{"buggy_code": ["package controller\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"math\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"runtime/debug\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\tclustercache \"github.com/argoproj/gitops-engine/pkg/cache\"\n\t\"github.com/argoproj/gitops-engine/pkg/diff\"\n\t\"github.com/argoproj/gitops-engine/pkg/health\"\n\tsynccommon \"github.com/argoproj/gitops-engine/pkg/sync/common\"\n\t\"github.com/argoproj/gitops-engine/pkg/utils/kube\"\n\tjsonpatch \"github.com/evanphx/json-patch\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"golang.org/x/sync/semaphore\"\n\tv1 \"k8s.io/api/core/v1\"\n\tapierr \"k8s.io/apimachinery/pkg/api/errors\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\n\t\"k8s.io/apimachinery/pkg/labels\"\n\tapiruntime \"k8s.io/apimachinery/pkg/runtime\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\t\"k8s.io/apimachinery/pkg/util/runtime\"\n\t\"k8s.io/apimachinery/pkg/util/wait\"\n\t\"k8s.io/apimachinery/pkg/watch\"\n\t\"k8s.io/client-go/kubernetes\"\n\t\"k8s.io/client-go/tools/cache\"\n\t\"k8s.io/client-go/util/workqueue\"\n\n\tstatecache \"github.com/argoproj/argo-cd/v2/controller/cache\"\n\t\"github.com/argoproj/argo-cd/v2/controller/metrics\"\n\t\"github.com/argoproj/argo-cd/v2/pkg/apis/application\"\n\tappv1 \"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1\"\n\tappclientset \"github.com/argoproj/argo-cd/v2/pkg/client/clientset/versioned\"\n\t\"github.com/argoproj/argo-cd/v2/pkg/client/informers/externalversions/application/v1alpha1\"\n\tapplisters \"github.com/argoproj/argo-cd/v2/pkg/client/listers/application/v1alpha1\"\n\t\"github.com/argoproj/argo-cd/v2/reposerver/apiclient\"\n\t\"github.com/argoproj/argo-cd/v2/util/argo\"\n\targodiff \"github.com/argoproj/argo-cd/v2/util/argo/diff\"\n\tappstatecache \"github.com/argoproj/argo-cd/v2/util/cache/appstate\"\n\t\"github.com/argoproj/argo-cd/v2/util/db\"\n\t\"github.com/argoproj/argo-cd/v2/util/errors\"\n\t\"github.com/argoproj/argo-cd/v2/util/glob\"\n\tlogutils \"github.com/argoproj/argo-cd/v2/util/log\"\n\tsettings_util \"github.com/argoproj/argo-cd/v2/util/settings\"\n)\n\nconst (\n\tupdateOperationStateTimeout = 1 * time.Second\n\t// orphanedIndex contains application which monitor orphaned resources by namespace\n\torphanedIndex = \"orphaned\"\n)\n\ntype CompareWith int\n\nconst (\n\t// Compare live application state against state defined in latest git revision with no resolved revision caching.\n\tCompareWithLatestForceResolve CompareWith = 3\n\t// Compare live application state against state defined in latest git revision.\n\tCompareWithLatest CompareWith = 2\n\t// Compare live application state against state defined using revision of most recent comparison.\n\tCompareWithRecent CompareWith = 1\n\t// Skip comparison and only refresh application resources tree\n\tComparisonWithNothing CompareWith = 0\n)\n\nfunc (a CompareWith) Max(b CompareWith) CompareWith {\n\treturn CompareWith(math.Max(float64(a), float64(b)))\n}\n\nfunc (a CompareWith) Pointer() *CompareWith {\n\treturn &a\n}\n\n// ApplicationController is the controller for application resources.\ntype ApplicationController struct {\n\tcache                *appstatecache.Cache\n\tnamespace            string\n\tkubeClientset        kubernetes.Interface\n\tkubectl              kube.Kubectl\n\tapplicationClientset appclientset.Interface\n\tauditLogger          *argo.AuditLogger\n\t// queue contains app namespace/name\n\tappRefreshQueue workqueue.RateLimitingInterface\n\t// queue contains app namespace/name/comparisonType and used to request app refresh with the predefined comparison type\n\tappComparisonTypeRefreshQueue workqueue.RateLimitingInterface\n\tappOperationQueue             workqueue.RateLimitingInterface\n\tprojectRefreshQueue           workqueue.RateLimitingInterface\n\tappInformer                   cache.SharedIndexInformer\n\tappLister                     applisters.ApplicationLister\n\tprojInformer                  cache.SharedIndexInformer\n\tappStateManager               AppStateManager\n\tstateCache                    statecache.LiveStateCache\n\tstatusRefreshTimeout          time.Duration\n\tselfHealTimeout               time.Duration\n\trepoClientset                 apiclient.Clientset\n\tdb                            db.ArgoDB\n\tsettingsMgr                   *settings_util.SettingsManager\n\trefreshRequestedApps          map[string]CompareWith\n\trefreshRequestedAppsMutex     *sync.Mutex\n\tmetricsServer                 *metrics.MetricsServer\n\tkubectlSemaphore              *semaphore.Weighted\n\tclusterFilter                 func(cluster *appv1.Cluster) bool\n\tprojByNameCache               sync.Map\n}\n\n// NewApplicationController creates new instance of ApplicationController.\nfunc NewApplicationController(\n\tnamespace string,\n\tsettingsMgr *settings_util.SettingsManager,\n\tkubeClientset kubernetes.Interface,\n\tapplicationClientset appclientset.Interface,\n\trepoClientset apiclient.Clientset,\n\targoCache *appstatecache.Cache,\n\tkubectl kube.Kubectl,\n\tappResyncPeriod time.Duration,\n\tselfHealTimeout time.Duration,\n\tmetricsPort int,\n\tmetricsCacheExpiration time.Duration,\n\tmetricsApplicationLabels []string,\n\tkubectlParallelismLimit int64,\n\tclusterFilter func(cluster *appv1.Cluster) bool,\n) (*ApplicationController, error) {\n\tlog.Infof(\"appResyncPeriod=%v\", appResyncPeriod)\n\tdb := db.NewDB(namespace, settingsMgr, kubeClientset)\n\tctrl := ApplicationController{\n\t\tcache:                         argoCache,\n\t\tnamespace:                     namespace,\n\t\tkubeClientset:                 kubeClientset,\n\t\tkubectl:                       kubectl,\n\t\tapplicationClientset:          applicationClientset,\n\t\trepoClientset:                 repoClientset,\n\t\tappRefreshQueue:               workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), \"app_reconciliation_queue\"),\n\t\tappOperationQueue:             workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), \"app_operation_processing_queue\"),\n\t\tprojectRefreshQueue:           workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), \"project_reconciliation_queue\"),\n\t\tappComparisonTypeRefreshQueue: workqueue.NewRateLimitingQueue(workqueue.DefaultControllerRateLimiter()),\n\t\tdb:                            db,\n\t\tstatusRefreshTimeout:          appResyncPeriod,\n\t\trefreshRequestedApps:          make(map[string]CompareWith),\n\t\trefreshRequestedAppsMutex:     &sync.Mutex{},\n\t\tauditLogger:                   argo.NewAuditLogger(namespace, kubeClientset, \"argocd-application-controller\"),\n\t\tsettingsMgr:                   settingsMgr,\n\t\tselfHealTimeout:               selfHealTimeout,\n\t\tclusterFilter:                 clusterFilter,\n\t\tprojByNameCache:               sync.Map{},\n\t}\n\tif kubectlParallelismLimit > 0 {\n\t\tctrl.kubectlSemaphore = semaphore.NewWeighted(kubectlParallelismLimit)\n\t}\n\tkubectl.SetOnKubectlRun(ctrl.onKubectlRun)\n\tappInformer, appLister := ctrl.newApplicationInformerAndLister()\n\tindexers := cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}\n\tprojInformer := v1alpha1.NewAppProjectInformer(applicationClientset, namespace, appResyncPeriod, indexers)\n\tprojInformer.AddEventHandler(cache.ResourceEventHandlerFuncs{\n\t\tAddFunc: func(obj interface{}) {\n\t\t\tif key, err := cache.MetaNamespaceKeyFunc(obj); err == nil {\n\t\t\t\tctrl.projectRefreshQueue.Add(key)\n\t\t\t\tif projMeta, ok := obj.(metav1.Object); ok {\n\t\t\t\t\tctrl.InvalidateProjectsCache(projMeta.GetName())\n\t\t\t\t}\n\n\t\t\t}\n\t\t},\n\t\tUpdateFunc: func(old, new interface{}) {\n\t\t\tif key, err := cache.MetaNamespaceKeyFunc(new); err == nil {\n\t\t\t\tctrl.projectRefreshQueue.Add(key)\n\t\t\t\tif projMeta, ok := new.(metav1.Object); ok {\n\t\t\t\t\tctrl.InvalidateProjectsCache(projMeta.GetName())\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tDeleteFunc: func(obj interface{}) {\n\t\t\tif key, err := cache.DeletionHandlingMetaNamespaceKeyFunc(obj); err == nil {\n\t\t\t\tctrl.projectRefreshQueue.Add(key)\n\t\t\t\tif projMeta, ok := obj.(metav1.Object); ok {\n\t\t\t\t\tctrl.InvalidateProjectsCache(projMeta.GetName())\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t})\n\tmetricsAddr := fmt.Sprintf(\"0.0.0.0:%d\", metricsPort)\n\tvar err error\n\tctrl.metricsServer, err = metrics.NewMetricsServer(metricsAddr, appLister, ctrl.canProcessApp, func(r *http.Request) error {\n\t\treturn nil\n\t}, metricsApplicationLabels)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif metricsCacheExpiration.Seconds() != 0 {\n\t\terr = ctrl.metricsServer.SetExpiration(metricsCacheExpiration)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tstateCache := statecache.NewLiveStateCache(db, appInformer, ctrl.settingsMgr, kubectl, ctrl.metricsServer, ctrl.handleObjectUpdated, clusterFilter, argo.NewResourceTracking())\n\tappStateManager := NewAppStateManager(db, applicationClientset, repoClientset, namespace, kubectl, ctrl.settingsMgr, stateCache, projInformer, ctrl.metricsServer, argoCache, ctrl.statusRefreshTimeout, argo.NewResourceTracking())\n\tctrl.appInformer = appInformer\n\tctrl.appLister = appLister\n\tctrl.projInformer = projInformer\n\tctrl.appStateManager = appStateManager\n\tctrl.stateCache = stateCache\n\n\treturn &ctrl, nil\n}\n\nfunc (ctrl *ApplicationController) InvalidateProjectsCache(names ...string) {\n\tif len(names) > 0 {\n\t\tfor _, name := range names {\n\t\t\tctrl.projByNameCache.Delete(name)\n\t\t}\n\t} else {\n\t\tctrl.projByNameCache.Range(func(key, _ interface{}) bool {\n\t\t\tctrl.projByNameCache.Delete(key)\n\t\t\treturn true\n\t\t})\n\t}\n}\n\nfunc (ctrl *ApplicationController) GetMetricsServer() *metrics.MetricsServer {\n\treturn ctrl.metricsServer\n}\n\nfunc (ctrl *ApplicationController) onKubectlRun(command string) (kube.CleanupFunc, error) {\n\tctrl.metricsServer.IncKubectlExec(command)\n\tif ctrl.kubectlSemaphore != nil {\n\t\tif err := ctrl.kubectlSemaphore.Acquire(context.Background(), 1); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tctrl.metricsServer.IncKubectlExecPending(command)\n\t}\n\treturn func() {\n\t\tif ctrl.kubectlSemaphore != nil {\n\t\t\tctrl.kubectlSemaphore.Release(1)\n\t\t\tctrl.metricsServer.DecKubectlExecPending(command)\n\t\t}\n\t}, nil\n}\n\nfunc isSelfReferencedApp(app *appv1.Application, ref v1.ObjectReference) bool {\n\tgvk := ref.GroupVersionKind()\n\treturn ref.UID == app.UID &&\n\t\tref.Name == app.Name &&\n\t\tref.Namespace == app.Namespace &&\n\t\tgvk.Group == application.Group &&\n\t\tgvk.Kind == application.ApplicationKind\n}\n\nfunc (ctrl *ApplicationController) newAppProjCache(name string) *appProjCache {\n\treturn &appProjCache{name: name, ctrl: ctrl}\n}\n\ntype appProjCache struct {\n\tname string\n\tctrl *ApplicationController\n\n\tlock    sync.Mutex\n\tappProj *appv1.AppProject\n}\n\nfunc (projCache *appProjCache) GetAppProject(ctx context.Context) (*appv1.AppProject, error) {\n\tprojCache.lock.Lock()\n\tdefer projCache.lock.Unlock()\n\tif projCache.appProj != nil {\n\t\treturn projCache.appProj, nil\n\t}\n\tproj, err := argo.GetAppProjectByName(projCache.name, applisters.NewAppProjectLister(projCache.ctrl.projInformer.GetIndexer()), projCache.ctrl.namespace, projCache.ctrl.settingsMgr, projCache.ctrl.db, ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tprojCache.appProj = proj\n\treturn projCache.appProj, nil\n}\n\nfunc (ctrl *ApplicationController) getAppProj(app *appv1.Application) (*appv1.AppProject, error) {\n\tprojCache, _ := ctrl.projByNameCache.LoadOrStore(app.Spec.GetProject(), ctrl.newAppProjCache(app.Spec.GetProject()))\n\treturn projCache.(*appProjCache).GetAppProject(context.TODO())\n}\n\nfunc (ctrl *ApplicationController) handleObjectUpdated(managedByApp map[string]bool, ref v1.ObjectReference) {\n\t// if namespaced resource is not managed by any app it might be orphaned resource of some other apps\n\tif len(managedByApp) == 0 && ref.Namespace != \"\" {\n\t\t// retrieve applications which monitor orphaned resources in the same namespace and refresh them unless resource is denied in app project\n\t\tif objs, err := ctrl.appInformer.GetIndexer().ByIndex(orphanedIndex, ref.Namespace); err == nil {\n\t\t\tfor i := range objs {\n\t\t\t\tapp, ok := objs[i].(*appv1.Application)\n\t\t\t\tif !ok {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tmanagedByApp[app.Name] = true\n\t\t\t}\n\t\t}\n\t}\n\tfor appName, isManagedResource := range managedByApp {\n\t\tobj, exists, err := ctrl.appInformer.GetIndexer().GetByKey(ctrl.namespace + \"/\" + appName)\n\t\tif app, ok := obj.(*appv1.Application); exists && err == nil && ok && isSelfReferencedApp(app, ref) {\n\t\t\t// Don't force refresh app if related resource is application itself. This prevents infinite reconciliation loop.\n\t\t\tcontinue\n\t\t}\n\n\t\tif !ctrl.canProcessApp(obj) {\n\t\t\t// Don't force refresh app if app belongs to a different controller shard\n\t\t\tcontinue\n\t\t}\n\n\t\tlevel := ComparisonWithNothing\n\t\tif isManagedResource {\n\t\t\tlevel = CompareWithRecent\n\t\t}\n\n\t\t// Additional check for debug level so we don't need to evaluate the\n\t\t// format string in case of non-debug scenarios\n\t\tif log.GetLevel() >= log.DebugLevel {\n\t\t\tvar resKey string\n\t\t\tif ref.Namespace != \"\" {\n\t\t\t\tresKey = ref.Namespace + \"/\" + ref.Name\n\t\t\t} else {\n\t\t\t\tresKey = \"(cluster-scoped)/\" + ref.Name\n\t\t\t}\n\t\t\tlog.Debugf(\"Refreshing app %s for change in cluster of object %s of type %s/%s\", appName, resKey, ref.APIVersion, ref.Kind)\n\t\t}\n\n\t\tctrl.requestAppRefresh(appName, &level, nil)\n\t}\n}\n\n// setAppManagedResources will build a list of ResourceDiff based on the provided comparisonResult\n// and persist app resources related data in the cache. Will return the persisted ApplicationTree.\nfunc (ctrl *ApplicationController) setAppManagedResources(a *appv1.Application, comparisonResult *comparisonResult) (*appv1.ApplicationTree, error) {\n\tmanagedResources, err := ctrl.hideSecretData(a, comparisonResult)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error getting managed resources: %s\", err)\n\t}\n\ttree, err := ctrl.getResourceTree(a, managedResources)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error getting resource tree: %s\", err)\n\t}\n\terr = ctrl.cache.SetAppResourcesTree(a.Name, tree)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error setting app resource tree: %s\", err)\n\t}\n\terr = ctrl.cache.SetAppManagedResources(a.Name, managedResources)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error setting app managed resources: %s\", err)\n\t}\n\treturn tree, nil\n}\n\n// returns true of given resources exist in the namespace by default and not managed by the user\nfunc isKnownOrphanedResourceExclusion(key kube.ResourceKey, proj *appv1.AppProject) bool {\n\tif key.Namespace == \"default\" && key.Group == \"\" && key.Kind == kube.ServiceKind && key.Name == \"kubernetes\" {\n\t\treturn true\n\t}\n\tif key.Group == \"\" && key.Kind == kube.ServiceAccountKind && key.Name == \"default\" {\n\t\treturn true\n\t}\n\tif key.Group == \"\" && key.Kind == \"ConfigMap\" && key.Name == \"kube-root-ca.crt\" {\n\t\treturn true\n\t}\n\tlist := proj.Spec.OrphanedResources.Ignore\n\tfor _, item := range list {\n\t\tif item.Kind == \"\" || glob.Match(item.Kind, key.Kind) {\n\t\t\tif glob.Match(item.Group, key.Group) {\n\t\t\t\tif item.Name == \"\" || glob.Match(item.Name, key.Name) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (ctrl *ApplicationController) getResourceTree(a *appv1.Application, managedResources []*appv1.ResourceDiff) (*appv1.ApplicationTree, error) {\n\tnodes := make([]appv1.ResourceNode, 0)\n\n\tproj, err := ctrl.getAppProj(a)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\torphanedNodesMap := make(map[kube.ResourceKey]appv1.ResourceNode)\n\twarnOrphaned := true\n\tif proj.Spec.OrphanedResources != nil {\n\t\torphanedNodesMap, err = ctrl.stateCache.GetNamespaceTopLevelResources(a.Spec.Destination.Server, a.Spec.Destination.Namespace)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\twarnOrphaned = proj.Spec.OrphanedResources.IsWarn()\n\t}\n\n\tfor i := range managedResources {\n\t\tmanagedResource := managedResources[i]\n\t\tdelete(orphanedNodesMap, kube.NewResourceKey(managedResource.Group, managedResource.Kind, managedResource.Namespace, managedResource.Name))\n\t\tvar live = &unstructured.Unstructured{}\n\t\terr := json.Unmarshal([]byte(managedResource.LiveState), &live)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tvar target = &unstructured.Unstructured{}\n\t\terr = json.Unmarshal([]byte(managedResource.TargetState), &target)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif live == nil {\n\t\t\tnodes = append(nodes, appv1.ResourceNode{\n\t\t\t\tResourceRef: appv1.ResourceRef{\n\t\t\t\t\tVersion:   target.GroupVersionKind().Version,\n\t\t\t\t\tName:      managedResource.Name,\n\t\t\t\t\tKind:      managedResource.Kind,\n\t\t\t\t\tGroup:     managedResource.Group,\n\t\t\t\t\tNamespace: managedResource.Namespace,\n\t\t\t\t},\n\t\t\t})\n\t\t} else {\n\t\t\terr := ctrl.stateCache.IterateHierarchy(a.Spec.Destination.Server, kube.GetResourceKey(live), func(child appv1.ResourceNode, appName string) {\n\t\t\t\tnodes = append(nodes, child)\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\torphanedNodes := make([]appv1.ResourceNode, 0)\n\tfor k := range orphanedNodesMap {\n\t\tif k.Namespace != \"\" && proj.IsGroupKindPermitted(k.GroupKind(), true) && !isKnownOrphanedResourceExclusion(k, proj) {\n\t\t\terr := ctrl.stateCache.IterateHierarchy(a.Spec.Destination.Server, k, func(child appv1.ResourceNode, appName string) {\n\t\t\t\tbelongToAnotherApp := false\n\t\t\t\tif appName != \"\" {\n\t\t\t\t\tif _, exists, err := ctrl.appInformer.GetIndexer().GetByKey(ctrl.namespace + \"/\" + appName); exists && err == nil {\n\t\t\t\t\t\tbelongToAnotherApp = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif !belongToAnotherApp {\n\t\t\t\t\torphanedNodes = append(orphanedNodes, child)\n\t\t\t\t}\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\tvar conditions []appv1.ApplicationCondition\n\tif len(orphanedNodes) > 0 && warnOrphaned {\n\t\tconditions = []appv1.ApplicationCondition{{\n\t\t\tType:    appv1.ApplicationConditionOrphanedResourceWarning,\n\t\t\tMessage: fmt.Sprintf(\"Application has %d orphaned resources\", len(orphanedNodes)),\n\t\t}}\n\t}\n\ta.Status.SetConditions(conditions, map[appv1.ApplicationConditionType]bool{appv1.ApplicationConditionOrphanedResourceWarning: true})\n\tsort.Slice(orphanedNodes, func(i, j int) bool {\n\t\treturn orphanedNodes[i].ResourceRef.String() < orphanedNodes[j].ResourceRef.String()\n\t})\n\n\thosts, err := ctrl.getAppHosts(a, nodes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &appv1.ApplicationTree{Nodes: nodes, OrphanedNodes: orphanedNodes, Hosts: hosts}, nil\n}\n\nfunc (ctrl *ApplicationController) getAppHosts(a *appv1.Application, appNodes []appv1.ResourceNode) ([]appv1.HostInfo, error) {\n\tsupportedResourceNames := map[v1.ResourceName]bool{\n\t\tv1.ResourceCPU:     true,\n\t\tv1.ResourceStorage: true,\n\t\tv1.ResourceMemory:  true,\n\t}\n\tappPods := map[kube.ResourceKey]bool{}\n\tfor _, node := range appNodes {\n\t\tif node.Group == \"\" && node.Kind == kube.PodKind {\n\t\t\tappPods[kube.NewResourceKey(node.Group, node.Kind, node.Namespace, node.Name)] = true\n\t\t}\n\t}\n\n\tallNodesInfo := map[string]statecache.NodeInfo{}\n\tallPodsByNode := map[string][]statecache.PodInfo{}\n\tappPodsByNode := map[string][]statecache.PodInfo{}\n\terr := ctrl.stateCache.IterateResources(a.Spec.Destination.Server, func(res *clustercache.Resource, info *statecache.ResourceInfo) {\n\t\tkey := res.ResourceKey()\n\n\t\tswitch {\n\t\tcase info.NodeInfo != nil && key.Group == \"\" && key.Kind == \"Node\":\n\t\t\tallNodesInfo[key.Name] = *info.NodeInfo\n\t\tcase info.PodInfo != nil && key.Group == \"\" && key.Kind == kube.PodKind:\n\t\t\tif appPods[key] {\n\t\t\t\tappPodsByNode[info.PodInfo.NodeName] = append(appPodsByNode[info.PodInfo.NodeName], *info.PodInfo)\n\t\t\t} else {\n\t\t\t\tallPodsByNode[info.PodInfo.NodeName] = append(allPodsByNode[info.PodInfo.NodeName], *info.PodInfo)\n\t\t\t}\n\t\t}\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar hosts []appv1.HostInfo\n\tfor nodeName, appPods := range appPodsByNode {\n\t\tnode, ok := allNodesInfo[nodeName]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tneighbors := allPodsByNode[nodeName]\n\n\t\tresources := map[v1.ResourceName]appv1.HostResourceInfo{}\n\t\tfor name, resource := range node.Capacity {\n\t\t\tinfo := resources[name]\n\t\t\tinfo.ResourceName = name\n\t\t\tinfo.Capacity += resource.MilliValue()\n\t\t\tresources[name] = info\n\t\t}\n\n\t\tfor _, pod := range appPods {\n\t\t\tfor name, resource := range pod.ResourceRequests {\n\t\t\t\tif !supportedResourceNames[name] {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tinfo := resources[name]\n\t\t\t\tinfo.RequestedByApp += resource.MilliValue()\n\t\t\t\tresources[name] = info\n\t\t\t}\n\t\t}\n\n\t\tfor _, pod := range neighbors {\n\t\t\tfor name, resource := range pod.ResourceRequests {\n\t\t\t\tif !supportedResourceNames[name] || pod.Phase == v1.PodSucceeded || pod.Phase == v1.PodFailed {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tinfo := resources[name]\n\t\t\t\tinfo.RequestedByNeighbors += resource.MilliValue()\n\t\t\t\tresources[name] = info\n\t\t\t}\n\t\t}\n\n\t\tvar resourcesInfo []appv1.HostResourceInfo\n\t\tfor _, info := range resources {\n\t\t\tif supportedResourceNames[info.ResourceName] && info.Capacity > 0 {\n\t\t\t\tresourcesInfo = append(resourcesInfo, info)\n\t\t\t}\n\t\t}\n\t\tsort.Slice(resourcesInfo, func(i, j int) bool {\n\t\t\treturn resourcesInfo[i].ResourceName < resourcesInfo[j].ResourceName\n\t\t})\n\t\thosts = append(hosts, appv1.HostInfo{Name: nodeName, SystemInfo: node.SystemInfo, ResourcesInfo: resourcesInfo})\n\t}\n\treturn hosts, nil\n}\n\nfunc (ctrl *ApplicationController) hideSecretData(app *appv1.Application, comparisonResult *comparisonResult) ([]*appv1.ResourceDiff, error) {\n\titems := make([]*appv1.ResourceDiff, len(comparisonResult.managedResources))\n\tfor i := range comparisonResult.managedResources {\n\t\tres := comparisonResult.managedResources[i]\n\t\titem := appv1.ResourceDiff{\n\t\t\tNamespace:       res.Namespace,\n\t\t\tName:            res.Name,\n\t\t\tGroup:           res.Group,\n\t\t\tKind:            res.Kind,\n\t\t\tHook:            res.Hook,\n\t\t\tResourceVersion: res.ResourceVersion,\n\t\t}\n\n\t\ttarget := res.Target\n\t\tlive := res.Live\n\t\tresDiff := res.Diff\n\t\tif res.Kind == kube.SecretKind && res.Group == \"\" {\n\t\t\tvar err error\n\t\t\ttarget, live, err = diff.HideSecretData(res.Target, res.Live)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error hiding secret data: %s\", err)\n\t\t\t}\n\t\t\tcompareOptions, err := ctrl.settingsMgr.GetResourceCompareOptions()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error getting resource compare options: %s\", err)\n\t\t\t}\n\t\t\tresourceOverrides, err := ctrl.settingsMgr.GetResourceOverrides()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error getting resource overrides: %s\", err)\n\t\t\t}\n\t\t\tappLabelKey, err := ctrl.settingsMgr.GetAppInstanceLabelKey()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error getting app instance label key: %s\", err)\n\t\t\t}\n\t\t\ttrackingMethod, err := ctrl.settingsMgr.GetTrackingMethod()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error getting tracking method: %s\", err)\n\t\t\t}\n\n\t\t\tdiffConfig, err := argodiff.NewDiffConfigBuilder().\n\t\t\t\tWithDiffSettings(app.Spec.IgnoreDifferences, resourceOverrides, compareOptions.IgnoreAggregatedRoles).\n\t\t\t\tWithTracking(appLabelKey, trackingMethod).\n\t\t\t\tWithNoCache().\n\t\t\t\tWithLogger(logutils.NewLogrusLogger(logutils.NewWithCurrentConfig())).\n\t\t\t\tBuild()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"appcontroller error building diff config: %s\", err)\n\t\t\t}\n\n\t\t\tdiffResult, err := argodiff.StateDiff(live, target, diffConfig)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error applying diff: %s\", err)\n\t\t\t}\n\t\t\tresDiff = diffResult\n\t\t}\n\n\t\tif live != nil {\n\t\t\tdata, err := json.Marshal(live)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error marshaling live json: %s\", err)\n\t\t\t}\n\t\t\titem.LiveState = string(data)\n\t\t} else {\n\t\t\titem.LiveState = \"null\"\n\t\t}\n\n\t\tif target != nil {\n\t\t\tdata, err := json.Marshal(target)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error marshaling target json: %s\", err)\n\t\t\t}\n\t\t\titem.TargetState = string(data)\n\t\t} else {\n\t\t\titem.TargetState = \"null\"\n\t\t}\n\t\titem.PredictedLiveState = string(resDiff.PredictedLive)\n\t\titem.NormalizedLiveState = string(resDiff.NormalizedLive)\n\t\titem.Modified = resDiff.Modified\n\n\t\titems[i] = &item\n\t}\n\treturn items, nil\n}\n\n// Run starts the Application CRD controller.\nfunc (ctrl *ApplicationController) Run(ctx context.Context, statusProcessors int, operationProcessors int) {\n\tdefer runtime.HandleCrash()\n\tdefer ctrl.appRefreshQueue.ShutDown()\n\tdefer ctrl.appComparisonTypeRefreshQueue.ShutDown()\n\tdefer ctrl.appOperationQueue.ShutDown()\n\tdefer ctrl.projectRefreshQueue.ShutDown()\n\n\tctrl.metricsServer.RegisterClustersInfoSource(ctx, ctrl.stateCache)\n\tctrl.RegisterClusterSecretUpdater(ctx)\n\n\tgo ctrl.appInformer.Run(ctx.Done())\n\tgo ctrl.projInformer.Run(ctx.Done())\n\n\terrors.CheckError(ctrl.stateCache.Init())\n\n\tif !cache.WaitForCacheSync(ctx.Done(), ctrl.appInformer.HasSynced, ctrl.projInformer.HasSynced) {\n\t\tlog.Error(\"Timed out waiting for caches to sync\")\n\t\treturn\n\t}\n\n\tgo func() { errors.CheckError(ctrl.stateCache.Run(ctx)) }()\n\tgo func() { errors.CheckError(ctrl.metricsServer.ListenAndServe()) }()\n\n\tfor i := 0; i < statusProcessors; i++ {\n\t\tgo wait.Until(func() {\n\t\t\tfor ctrl.processAppRefreshQueueItem() {\n\t\t\t}\n\t\t}, time.Second, ctx.Done())\n\t}\n\n\tfor i := 0; i < operationProcessors; i++ {\n\t\tgo wait.Until(func() {\n\t\t\tfor ctrl.processAppOperationQueueItem() {\n\t\t\t}\n\t\t}, time.Second, ctx.Done())\n\t}\n\n\tgo wait.Until(func() {\n\t\tfor ctrl.processAppComparisonTypeQueueItem() {\n\t\t}\n\t}, time.Second, ctx.Done())\n\n\tgo wait.Until(func() {\n\t\tfor ctrl.processProjectQueueItem() {\n\t\t}\n\t}, time.Second, ctx.Done())\n\t<-ctx.Done()\n}\n\nfunc (ctrl *ApplicationController) requestAppRefresh(appName string, compareWith *CompareWith, after *time.Duration) {\n\tkey := fmt.Sprintf(\"%s/%s\", ctrl.namespace, appName)\n\n\tif compareWith != nil && after != nil {\n\t\tctrl.appComparisonTypeRefreshQueue.AddAfter(fmt.Sprintf(\"%s/%d\", key, compareWith), *after)\n\t} else {\n\t\tif compareWith != nil {\n\t\t\tctrl.refreshRequestedAppsMutex.Lock()\n\t\t\tctrl.refreshRequestedApps[appName] = compareWith.Max(ctrl.refreshRequestedApps[appName])\n\t\t\tctrl.refreshRequestedAppsMutex.Unlock()\n\t\t}\n\t\tif after != nil {\n\t\t\tctrl.appRefreshQueue.AddAfter(key, *after)\n\t\t\tctrl.appOperationQueue.AddAfter(key, *after)\n\t\t} else {\n\t\t\tctrl.appRefreshQueue.Add(key)\n\t\t\tctrl.appOperationQueue.Add(key)\n\t\t}\n\t}\n}\n\nfunc (ctrl *ApplicationController) isRefreshRequested(appName string) (bool, CompareWith) {\n\tctrl.refreshRequestedAppsMutex.Lock()\n\tdefer ctrl.refreshRequestedAppsMutex.Unlock()\n\tlevel, ok := ctrl.refreshRequestedApps[appName]\n\tif ok {\n\t\tdelete(ctrl.refreshRequestedApps, appName)\n\t}\n\treturn ok, level\n}\n\nfunc (ctrl *ApplicationController) processAppOperationQueueItem() (processNext bool) {\n\tappKey, shutdown := ctrl.appOperationQueue.Get()\n\tif shutdown {\n\t\tprocessNext = false\n\t\treturn\n\t}\n\tprocessNext = true\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tlog.Errorf(\"Recovered from panic: %+v\\n%s\", r, debug.Stack())\n\t\t}\n\t\tctrl.appOperationQueue.Done(appKey)\n\t}()\n\n\tobj, exists, err := ctrl.appInformer.GetIndexer().GetByKey(appKey.(string))\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to get application '%s' from informer index: %+v\", appKey, err)\n\t\treturn\n\t}\n\tif !exists {\n\t\t// This happens after app was deleted, but the work queue still had an entry for it.\n\t\treturn\n\t}\n\torigApp, ok := obj.(*appv1.Application)\n\tif !ok {\n\t\tlog.Warnf(\"Key '%s' in index is not an application\", appKey)\n\t\treturn\n\t}\n\tapp := origApp.DeepCopy()\n\n\tif app.Operation != nil {\n\t\t// If we get here, we are about process an operation but we cannot rely on informer since it might has stale data.\n\t\t// So always retrieve the latest version to ensure it is not stale to avoid unnecessary syncing.\n\t\t// We cannot rely on informer since applications might be updated by both application controller and api server.\n\t\tfreshApp, err := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(ctrl.namespace).Get(context.Background(), app.ObjectMeta.Name, metav1.GetOptions{})\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Failed to retrieve latest application state: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tapp = freshApp\n\t}\n\n\tif app.Operation != nil {\n\t\tctrl.processRequestedAppOperation(app)\n\t} else if app.DeletionTimestamp != nil && app.CascadedDeletion() {\n\t\t_, err = ctrl.finalizeApplicationDeletion(app)\n\t\tif err != nil {\n\t\t\tctrl.setAppCondition(app, appv1.ApplicationCondition{\n\t\t\t\tType:    appv1.ApplicationConditionDeletionError,\n\t\t\t\tMessage: err.Error(),\n\t\t\t})\n\t\t\tmessage := fmt.Sprintf(\"Unable to delete application resources: %v\", err.Error())\n\t\t\tctrl.auditLogger.LogAppEvent(app, argo.EventInfo{Reason: argo.EventReasonStatusRefreshed, Type: v1.EventTypeWarning}, message)\n\t\t}\n\t}\n\treturn\n}\n\nfunc (ctrl *ApplicationController) processAppComparisonTypeQueueItem() (processNext bool) {\n\tkey, shutdown := ctrl.appComparisonTypeRefreshQueue.Get()\n\tprocessNext = true\n\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tlog.Errorf(\"Recovered from panic: %+v\\n%s\", r, debug.Stack())\n\t\t}\n\t\tctrl.appComparisonTypeRefreshQueue.Done(key)\n\t}()\n\tif shutdown {\n\t\tprocessNext = false\n\t\treturn\n\t}\n\n\tif parts := strings.Split(key.(string), \"/\"); len(parts) != 3 {\n\t\tlog.Warnf(\"Unexpected key format in appComparisonTypeRefreshTypeQueue. Key should consists of namespace/name/comparisonType but got: %s\", key.(string))\n\t} else {\n\t\tif compareWith, err := strconv.Atoi(parts[2]); err != nil {\n\t\t\tlog.Warnf(\"Unable to parse comparison type: %v\", err)\n\t\t\treturn\n\t\t} else {\n\t\t\tctrl.requestAppRefresh(parts[1], CompareWith(compareWith).Pointer(), nil)\n\t\t}\n\t}\n\treturn\n}\n\nfunc (ctrl *ApplicationController) processProjectQueueItem() (processNext bool) {\n\tkey, shutdown := ctrl.projectRefreshQueue.Get()\n\tprocessNext = true\n\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tlog.Errorf(\"Recovered from panic: %+v\\n%s\", r, debug.Stack())\n\t\t}\n\t\tctrl.projectRefreshQueue.Done(key)\n\t}()\n\tif shutdown {\n\t\tprocessNext = false\n\t\treturn\n\t}\n\tobj, exists, err := ctrl.projInformer.GetIndexer().GetByKey(key.(string))\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to get project '%s' from informer index: %+v\", key, err)\n\t\treturn\n\t}\n\tif !exists {\n\t\t// This happens after appproj was deleted, but the work queue still had an entry for it.\n\t\treturn\n\t}\n\torigProj, ok := obj.(*appv1.AppProject)\n\tif !ok {\n\t\tlog.Warnf(\"Key '%s' in index is not an appproject\", key)\n\t\treturn\n\t}\n\n\tif origProj.DeletionTimestamp != nil && origProj.HasFinalizer() {\n\t\tif err := ctrl.finalizeProjectDeletion(origProj.DeepCopy()); err != nil {\n\t\t\tlog.Warnf(\"Failed to finalize project deletion: %v\", err)\n\t\t}\n\t}\n\treturn\n}\n\nfunc (ctrl *ApplicationController) finalizeProjectDeletion(proj *appv1.AppProject) error {\n\tapps, err := ctrl.appLister.Applications(ctrl.namespace).List(labels.Everything())\n\tif err != nil {\n\t\treturn err\n\t}\n\tappsCount := 0\n\tfor i := range apps {\n\t\tif apps[i].Spec.GetProject() == proj.Name {\n\t\t\tappsCount++\n\t\t}\n\t}\n\tif appsCount == 0 {\n\t\treturn ctrl.removeProjectFinalizer(proj)\n\t} else {\n\t\tlog.Infof(\"Cannot remove project '%s' finalizer as is referenced by %d applications\", proj.Name, appsCount)\n\t}\n\treturn nil\n}\n\nfunc (ctrl *ApplicationController) removeProjectFinalizer(proj *appv1.AppProject) error {\n\tproj.RemoveFinalizer()\n\tvar patch []byte\n\tpatch, _ = json.Marshal(map[string]interface{}{\n\t\t\"metadata\": map[string]interface{}{\n\t\t\t\"finalizers\": proj.Finalizers,\n\t\t},\n\t})\n\t_, err := ctrl.applicationClientset.ArgoprojV1alpha1().AppProjects(ctrl.namespace).Patch(context.Background(), proj.Name, types.MergePatchType, patch, metav1.PatchOptions{})\n\treturn err\n}\n\n// shouldBeDeleted returns whether a given resource obj should be deleted on cascade delete of application app\nfunc (ctrl *ApplicationController) shouldBeDeleted(app *appv1.Application, obj *unstructured.Unstructured) bool {\n\treturn !kube.IsCRD(obj) && !isSelfReferencedApp(app, kube.GetObjectRef(obj))\n}\n\nfunc (ctrl *ApplicationController) getPermittedAppLiveObjects(app *appv1.Application, proj *appv1.AppProject) (map[kube.ResourceKey]*unstructured.Unstructured, error) {\n\tobjsMap, err := ctrl.stateCache.GetManagedLiveObjs(app, []*unstructured.Unstructured{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Don't delete live resources which are not permitted in the app project\n\tfor k, v := range objsMap {\n\t\tif !proj.IsLiveResourcePermitted(v, app.Spec.Destination.Server, app.Spec.Destination.Name) {\n\t\t\tdelete(objsMap, k)\n\t\t}\n\t}\n\treturn objsMap, nil\n}\n\nfunc (ctrl *ApplicationController) finalizeApplicationDeletion(app *appv1.Application) ([]*unstructured.Unstructured, error) {\n\tlogCtx := log.WithField(\"application\", app.Name)\n\tlogCtx.Infof(\"Deleting resources\")\n\t// Get refreshed application info, since informer app copy might be stale\n\tapp, err := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(app.Namespace).Get(context.Background(), app.Name, metav1.GetOptions{})\n\tif err != nil {\n\t\tif !apierr.IsNotFound(err) {\n\t\t\tlogCtx.Errorf(\"Unable to get refreshed application info prior deleting resources: %v\", err)\n\t\t}\n\t\treturn nil, nil\n\t}\n\tproj, err := ctrl.getAppProj(app)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// validDestination is true if the Application destination points to a cluster that is managed by Argo CD\n\t// (and thus either a cluster secret exists for it, or it's local); validDestination is false otherwise.\n\tvalidDestination := true\n\n\t// Validate the cluster using the Application destination's `name` field, if applicable,\n\t// and set the Server field, if needed.\n\tif err := argo.ValidateDestination(context.Background(), &app.Spec.Destination, ctrl.db); err != nil {\n\t\tlog.Warnf(\"Unable to validate destination of the Application being deleted: %v\", err)\n\t\tvalidDestination = false\n\t}\n\n\tobjs := make([]*unstructured.Unstructured, 0)\n\tvar cluster *appv1.Cluster\n\n\t// Attempt to validate the destination via its URL\n\tif validDestination {\n\t\tif cluster, err = ctrl.db.GetCluster(context.Background(), app.Spec.Destination.Server); err != nil {\n\t\t\tlog.Warnf(\"Unable to locate cluster URL for Application being deleted: %v\", err)\n\t\t\tvalidDestination = false\n\t\t}\n\t}\n\n\tif validDestination {\n\t\t// ApplicationDestination points to a valid cluster, so we may clean up the live objects\n\n\t\tobjsMap, err := ctrl.getPermittedAppLiveObjects(app, proj)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfor k := range objsMap {\n\t\t\t// Wait for objects pending deletion to complete before proceeding with next sync wave\n\t\t\tif objsMap[k].GetDeletionTimestamp() != nil {\n\t\t\t\tlogCtx.Infof(\"%d objects remaining for deletion\", len(objsMap))\n\t\t\t\treturn objs, nil\n\t\t\t}\n\n\t\t\tif ctrl.shouldBeDeleted(app, objsMap[k]) {\n\t\t\t\tobjs = append(objs, objsMap[k])\n\t\t\t}\n\t\t}\n\n\t\tconfig := metrics.AddMetricsTransportWrapper(ctrl.metricsServer, app, cluster.RESTConfig())\n\n\t\tfilteredObjs := FilterObjectsForDeletion(objs)\n\n\t\tpropagationPolicy := metav1.DeletePropagationForeground\n\t\tif app.GetPropagationPolicy() == appv1.BackgroundPropagationPolicyFinalizer {\n\t\t\tpropagationPolicy = metav1.DeletePropagationBackground\n\t\t}\n\t\tlogCtx.Infof(\"Deleting application's resources with %s propagation policy\", propagationPolicy)\n\n\t\terr = kube.RunAllAsync(len(filteredObjs), func(i int) error {\n\t\t\tobj := filteredObjs[i]\n\t\t\treturn ctrl.kubectl.DeleteResource(context.Background(), config, obj.GroupVersionKind(), obj.GetName(), obj.GetNamespace(), metav1.DeleteOptions{PropagationPolicy: &propagationPolicy})\n\t\t})\n\t\tif err != nil {\n\t\t\treturn objs, err\n\t\t}\n\n\t\tobjsMap, err = ctrl.getPermittedAppLiveObjects(app, proj)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfor k, obj := range objsMap {\n\t\t\tif !ctrl.shouldBeDeleted(app, obj) {\n\t\t\t\tdelete(objsMap, k)\n\t\t\t}\n\t\t}\n\t\tif len(objsMap) > 0 {\n\t\t\tlogCtx.Infof(\"%d objects remaining for deletion\", len(objsMap))\n\t\t\treturn objs, nil\n\t\t}\n\t}\n\n\tif err := ctrl.cache.SetAppManagedResources(app.Name, nil); err != nil {\n\t\treturn objs, err\n\t}\n\n\tif err := ctrl.cache.SetAppResourcesTree(app.Name, nil); err != nil {\n\t\treturn objs, err\n\t}\n\n\tif err := ctrl.removeCascadeFinalizer(app); err != nil {\n\t\treturn objs, err\n\t}\n\n\tif validDestination {\n\t\tlogCtx.Infof(\"Successfully deleted %d resources\", len(objs))\n\t} else {\n\t\tlogCtx.Infof(\"Resource entries removed from undefined cluster\")\n\t}\n\n\tctrl.projectRefreshQueue.Add(fmt.Sprintf(\"%s/%s\", app.Namespace, app.Spec.GetProject()))\n\treturn objs, nil\n}\n\nfunc (ctrl *ApplicationController) removeCascadeFinalizer(app *appv1.Application) error {\n\tapp.UnSetCascadedDeletion()\n\tvar patch []byte\n\tpatch, _ = json.Marshal(map[string]interface{}{\n\t\t\"metadata\": map[string]interface{}{\n\t\t\t\"finalizers\": app.Finalizers,\n\t\t},\n\t})\n\n\t_, err := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(app.Namespace).Patch(context.Background(), app.Name, types.MergePatchType, patch, metav1.PatchOptions{})\n\treturn err\n}\n\nfunc (ctrl *ApplicationController) setAppCondition(app *appv1.Application, condition appv1.ApplicationCondition) {\n\t// do nothing if app already has same condition\n\tfor _, c := range app.Status.Conditions {\n\t\tif c.Message == condition.Message && c.Type == condition.Type {\n\t\t\treturn\n\t\t}\n\t}\n\n\tapp.Status.SetConditions([]appv1.ApplicationCondition{condition}, map[appv1.ApplicationConditionType]bool{condition.Type: true})\n\n\tvar patch []byte\n\tpatch, err := json.Marshal(map[string]interface{}{\n\t\t\"status\": map[string]interface{}{\n\t\t\t\"conditions\": app.Status.Conditions,\n\t\t},\n\t})\n\tif err == nil {\n\t\t_, err = ctrl.applicationClientset.ArgoprojV1alpha1().Applications(app.Namespace).Patch(context.Background(), app.Name, types.MergePatchType, patch, metav1.PatchOptions{})\n\t}\n\tif err != nil {\n\t\tlog.Errorf(\"Unable to set application condition: %v\", err)\n\t}\n}\n\nfunc (ctrl *ApplicationController) processRequestedAppOperation(app *appv1.Application) {\n\tlogCtx := log.WithField(\"application\", app.Name)\n\tvar state *appv1.OperationState\n\t// Recover from any unexpected panics and automatically set the status to be failed\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tlogCtx.Errorf(\"Recovered from panic: %+v\\n%s\", r, debug.Stack())\n\t\t\tstate.Phase = synccommon.OperationError\n\t\t\tif rerr, ok := r.(error); ok {\n\t\t\t\tstate.Message = rerr.Error()\n\t\t\t} else {\n\t\t\t\tstate.Message = fmt.Sprintf(\"%v\", r)\n\t\t\t}\n\t\t\tctrl.setOperationState(app, state)\n\t\t}\n\t}()\n\tterminating := false\n\tif isOperationInProgress(app) {\n\t\tstate = app.Status.OperationState.DeepCopy()\n\t\tterminating = state.Phase == synccommon.OperationTerminating\n\t\t// Failed  operation with retry strategy might have be in-progress and has completion time\n\t\tif state.FinishedAt != nil && !terminating {\n\t\t\tretryAt, err := app.Status.OperationState.Operation.Retry.NextRetryAt(state.FinishedAt.Time, state.RetryCount)\n\t\t\tif err != nil {\n\t\t\t\tstate.Phase = synccommon.OperationFailed\n\t\t\t\tstate.Message = err.Error()\n\t\t\t\tctrl.setOperationState(app, state)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tretryAfter := time.Until(retryAt)\n\t\t\tif retryAfter > 0 {\n\t\t\t\tlogCtx.Infof(\"Skipping retrying in-progress operation. Attempting again at: %s\", retryAt.Format(time.RFC3339))\n\t\t\t\tctrl.requestAppRefresh(app.Name, CompareWithLatest.Pointer(), &retryAfter)\n\t\t\t\treturn\n\t\t\t} else {\n\t\t\t\t// retrying operation. remove previous failure time in app since it is used as a trigger\n\t\t\t\t// that previous failed and operation should be retried\n\t\t\t\tstate.FinishedAt = nil\n\t\t\t\tctrl.setOperationState(app, state)\n\t\t\t\t// Get rid of sync results and null out previous operation completion time\n\t\t\t\tstate.SyncResult = nil\n\t\t\t}\n\t\t} else {\n\t\t\tlogCtx.Infof(\"Resuming in-progress operation. phase: %s, message: %s\", state.Phase, state.Message)\n\t\t}\n\t} else {\n\t\tstate = &appv1.OperationState{Phase: synccommon.OperationRunning, Operation: *app.Operation, StartedAt: metav1.Now()}\n\t\tctrl.setOperationState(app, state)\n\t\tlogCtx.Infof(\"Initialized new operation: %v\", *app.Operation)\n\t}\n\n\tif err := argo.ValidateDestination(context.Background(), &app.Spec.Destination, ctrl.db); err != nil {\n\t\tstate.Phase = synccommon.OperationFailed\n\t\tstate.Message = err.Error()\n\t} else {\n\t\tctrl.appStateManager.SyncAppState(app, state)\n\t}\n\n\tif state.Phase == synccommon.OperationRunning {\n\t\t// It's possible for an app to be terminated while we were operating on it. We do not want\n\t\t// to clobber the Terminated state with Running. Get the latest app state to check for this.\n\t\tfreshApp, err := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(ctrl.namespace).Get(context.Background(), app.ObjectMeta.Name, metav1.GetOptions{})\n\t\tif err == nil {\n\t\t\tif freshApp.Status.OperationState != nil && freshApp.Status.OperationState.Phase == synccommon.OperationTerminating {\n\t\t\t\tstate.Phase = synccommon.OperationTerminating\n\t\t\t\tstate.Message = \"operation is terminating\"\n\t\t\t\t// after this, we will get requeued to the workqueue, but next time the\n\t\t\t\t// SyncAppState will operate in a Terminating phase, allowing the worker to perform\n\t\t\t\t// cleanup (e.g. delete jobs, workflows, etc...)\n\t\t\t}\n\t\t}\n\t} else if state.Phase == synccommon.OperationFailed || state.Phase == synccommon.OperationError {\n\t\tif !terminating && (state.RetryCount < state.Operation.Retry.Limit || state.Operation.Retry.Limit < 0) {\n\t\t\tnow := metav1.Now()\n\t\t\tstate.FinishedAt = &now\n\t\t\tif retryAt, err := state.Operation.Retry.NextRetryAt(now.Time, state.RetryCount); err != nil {\n\t\t\t\tstate.Phase = synccommon.OperationFailed\n\t\t\t\tstate.Message = fmt.Sprintf(\"%s (failed to retry: %v)\", state.Message, err)\n\t\t\t} else {\n\t\t\t\tstate.Phase = synccommon.OperationRunning\n\t\t\t\tstate.RetryCount++\n\t\t\t\tstate.Message = fmt.Sprintf(\"%s. Retrying attempt #%d at %s.\", state.Message, state.RetryCount, retryAt.Format(time.Kitchen))\n\t\t\t}\n\t\t} else if state.RetryCount > 0 {\n\t\t\tstate.Message = fmt.Sprintf(\"%s (retried %d times).\", state.Message, state.RetryCount)\n\t\t}\n\n\t}\n\n\tctrl.setOperationState(app, state)\n\tif state.Phase.Completed() && (app.Operation.Sync != nil && !app.Operation.Sync.DryRun) {\n\t\t// if we just completed an operation, force a refresh so that UI will report up-to-date\n\t\t// sync/health information\n\t\tif _, err := cache.MetaNamespaceKeyFunc(app); err == nil {\n\t\t\t// force app refresh with using CompareWithLatest comparison type and trigger app reconciliation loop\n\t\t\tctrl.requestAppRefresh(app.Name, CompareWithLatest.Pointer(), nil)\n\t\t} else {\n\t\t\tlogCtx.Warnf(\"Fails to requeue application: %v\", err)\n\t\t}\n\t}\n}\n\nfunc (ctrl *ApplicationController) setOperationState(app *appv1.Application, state *appv1.OperationState) {\n\tkube.RetryUntilSucceed(context.Background(), updateOperationStateTimeout, \"Update application operation state\", logutils.NewLogrusLogger(logutils.NewWithCurrentConfig()), func() error {\n\t\tif state.Phase == \"\" {\n\t\t\t// expose any bugs where we neglect to set phase\n\t\t\tpanic(\"no phase was set\")\n\t\t}\n\t\tif state.Phase.Completed() {\n\t\t\tnow := metav1.Now()\n\t\t\tstate.FinishedAt = &now\n\t\t}\n\t\tpatch := map[string]interface{}{\n\t\t\t\"status\": map[string]interface{}{\n\t\t\t\t\"operationState\": state,\n\t\t\t},\n\t\t}\n\t\tif state.Phase.Completed() {\n\t\t\t// If operation is completed, clear the operation field to indicate no operation is\n\t\t\t// in progress.\n\t\t\tpatch[\"operation\"] = nil\n\t\t}\n\t\tif reflect.DeepEqual(app.Status.OperationState, state) {\n\t\t\tlog.Infof(\"No operation updates necessary to '%s'. Skipping patch\", app.Name)\n\t\t\treturn nil\n\t\t}\n\t\tpatchJSON, err := json.Marshal(patch)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif app.Status.OperationState != nil && app.Status.OperationState.FinishedAt != nil && state.FinishedAt == nil {\n\t\t\tpatchJSON, err = jsonpatch.MergeMergePatches(patchJSON, []byte(`{\"status\": {\"operationState\": {\"finishedAt\": null}}}`))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tappClient := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(ctrl.namespace)\n\t\t_, err = appClient.Patch(context.Background(), app.Name, types.MergePatchType, patchJSON, metav1.PatchOptions{})\n\t\tif err != nil {\n\t\t\t// Stop retrying updating deleted application\n\t\t\tif apierr.IsNotFound(err) {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tlog.Infof(\"updated '%s' operation (phase: %s)\", app.Name, state.Phase)\n\t\tif state.Phase.Completed() {\n\t\t\teventInfo := argo.EventInfo{Reason: argo.EventReasonOperationCompleted}\n\t\t\tvar messages []string\n\t\t\tif state.Operation.Sync != nil && len(state.Operation.Sync.Resources) > 0 {\n\t\t\t\tmessages = []string{\"Partial sync operation\"}\n\t\t\t} else {\n\t\t\t\tmessages = []string{\"Sync operation\"}\n\t\t\t}\n\t\t\tif state.SyncResult != nil {\n\t\t\t\tmessages = append(messages, \"to\", state.SyncResult.Revision)\n\t\t\t}\n\t\t\tif state.Phase.Successful() {\n\t\t\t\teventInfo.Type = v1.EventTypeNormal\n\t\t\t\tmessages = append(messages, \"succeeded\")\n\t\t\t} else {\n\t\t\t\teventInfo.Type = v1.EventTypeWarning\n\t\t\t\tmessages = append(messages, \"failed:\", state.Message)\n\t\t\t}\n\t\t\tctrl.auditLogger.LogAppEvent(app, eventInfo, strings.Join(messages, \" \"))\n\t\t\tctrl.metricsServer.IncSync(app, state)\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc (ctrl *ApplicationController) processAppRefreshQueueItem() (processNext bool) {\n\tappKey, shutdown := ctrl.appRefreshQueue.Get()\n\tif shutdown {\n\t\tprocessNext = false\n\t\treturn\n\t}\n\tprocessNext = true\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tlog.Errorf(\"Recovered from panic: %+v\\n%s\", r, debug.Stack())\n\t\t}\n\t\tctrl.appRefreshQueue.Done(appKey)\n\t}()\n\n\tobj, exists, err := ctrl.appInformer.GetIndexer().GetByKey(appKey.(string))\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to get application '%s' from informer index: %+v\", appKey, err)\n\t\treturn\n\t}\n\tif !exists {\n\t\t// This happens after app was deleted, but the work queue still had an entry for it.\n\t\treturn\n\t}\n\torigApp, ok := obj.(*appv1.Application)\n\tif !ok {\n\t\tlog.Warnf(\"Key '%s' in index is not an application\", appKey)\n\t\treturn\n\t}\n\torigApp = origApp.DeepCopy()\n\tneedRefresh, refreshType, comparisonLevel := ctrl.needRefreshAppStatus(origApp, ctrl.statusRefreshTimeout)\n\n\tif !needRefresh {\n\t\treturn\n\t}\n\n\tapp := origApp.DeepCopy()\n\tlogCtx := log.WithFields(log.Fields{\"application\": app.Name})\n\tstartTime := time.Now()\n\tdefer func() {\n\t\treconcileDuration := time.Since(startTime)\n\t\tctrl.metricsServer.IncReconcile(origApp, reconcileDuration)\n\t\tlogCtx.WithFields(log.Fields{\n\t\t\t\"time_ms\":        reconcileDuration.Milliseconds(),\n\t\t\t\"level\":          comparisonLevel,\n\t\t\t\"dest-server\":    origApp.Spec.Destination.Server,\n\t\t\t\"dest-name\":      origApp.Spec.Destination.Name,\n\t\t\t\"dest-namespace\": origApp.Spec.Destination.Namespace,\n\t\t}).Info(\"Reconciliation completed\")\n\t}()\n\n\tif comparisonLevel == ComparisonWithNothing {\n\t\tmanagedResources := make([]*appv1.ResourceDiff, 0)\n\t\tif err := ctrl.cache.GetAppManagedResources(app.Name, &managedResources); err != nil {\n\t\t\tlogCtx.Warnf(\"Failed to get cached managed resources for tree reconciliation, fall back to full reconciliation\")\n\t\t} else {\n\t\t\tvar tree *appv1.ApplicationTree\n\t\t\tif tree, err = ctrl.getResourceTree(app, managedResources); err == nil {\n\t\t\t\tapp.Status.Summary = tree.GetSummary()\n\t\t\t\tif err := ctrl.cache.SetAppResourcesTree(app.Name, tree); err != nil {\n\t\t\t\t\tlogCtx.Errorf(\"Failed to cache resources tree: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tctrl.persistAppStatus(origApp, &app.Status)\n\t\t\treturn\n\t\t}\n\t}\n\n\tproject, hasErrors := ctrl.refreshAppConditions(app)\n\tif hasErrors {\n\t\tapp.Status.Sync.Status = appv1.SyncStatusCodeUnknown\n\t\tapp.Status.Health.Status = health.HealthStatusUnknown\n\t\tctrl.persistAppStatus(origApp, &app.Status)\n\t\treturn\n\t}\n\n\tvar localManifests []string\n\tif opState := app.Status.OperationState; opState != nil && opState.Operation.Sync != nil {\n\t\tlocalManifests = opState.Operation.Sync.Manifests\n\t}\n\n\trevision := app.Spec.Source.TargetRevision\n\tif comparisonLevel == CompareWithRecent {\n\t\trevision = app.Status.Sync.Revision\n\t}\n\n\tnow := metav1.Now()\n\tcompareResult := ctrl.appStateManager.CompareAppState(app, project, revision, app.Spec.Source,\n\t\trefreshType == appv1.RefreshTypeHard,\n\t\tcomparisonLevel == CompareWithLatestForceResolve, localManifests)\n\tfor k, v := range compareResult.timings {\n\t\tlogCtx = logCtx.WithField(k, v.Milliseconds())\n\t}\n\n\tctrl.normalizeApplication(origApp, app)\n\n\ttree, err := ctrl.setAppManagedResources(app, compareResult)\n\tif err != nil {\n\t\tlogCtx.Errorf(\"Failed to cache app resources: %v\", err)\n\t} else {\n\t\tapp.Status.Summary = tree.GetSummary()\n\t}\n\n\tif project.Spec.SyncWindows.Matches(app).CanSync(false) {\n\t\tsyncErrCond := ctrl.autoSync(app, compareResult.syncStatus, compareResult.resources)\n\t\tif syncErrCond != nil {\n\t\t\tapp.Status.SetConditions(\n\t\t\t\t[]appv1.ApplicationCondition{*syncErrCond},\n\t\t\t\tmap[appv1.ApplicationConditionType]bool{appv1.ApplicationConditionSyncError: true},\n\t\t\t)\n\t\t} else {\n\t\t\tapp.Status.SetConditions(\n\t\t\t\t[]appv1.ApplicationCondition{},\n\t\t\t\tmap[appv1.ApplicationConditionType]bool{appv1.ApplicationConditionSyncError: true},\n\t\t\t)\n\t\t}\n\t} else {\n\t\tlogCtx.Info(\"Sync prevented by sync window\")\n\t}\n\n\tif app.Status.ReconciledAt == nil || comparisonLevel >= CompareWithLatest {\n\t\tapp.Status.ReconciledAt = &now\n\t}\n\tapp.Status.Sync = *compareResult.syncStatus\n\tapp.Status.Health = *compareResult.healthStatus\n\tapp.Status.Resources = compareResult.resources\n\tsort.Slice(app.Status.Resources, func(i, j int) bool {\n\t\treturn resourceStatusKey(app.Status.Resources[i]) < resourceStatusKey(app.Status.Resources[j])\n\t})\n\tapp.Status.SourceType = compareResult.appSourceType\n\tctrl.persistAppStatus(origApp, &app.Status)\n\treturn\n}\n\nfunc resourceStatusKey(res appv1.ResourceStatus) string {\n\treturn strings.Join([]string{res.Group, res.Kind, res.Namespace, res.Name}, \"/\")\n}\n\n// needRefreshAppStatus answers if application status needs to be refreshed.\n// Returns true if application never been compared, has changed or comparison result has expired.\n// Additionally returns whether full refresh was requested or not.\n// If full refresh is requested then target and live state should be reconciled, else only live state tree should be updated.\nfunc (ctrl *ApplicationController) needRefreshAppStatus(app *appv1.Application, statusRefreshTimeout time.Duration) (bool, appv1.RefreshType, CompareWith) {\n\tlogCtx := log.WithFields(log.Fields{\"application\": app.Name})\n\tvar reason string\n\tcompareWith := CompareWithLatest\n\trefreshType := appv1.RefreshTypeNormal\n\texpired := app.Status.ReconciledAt == nil || app.Status.ReconciledAt.Add(statusRefreshTimeout).Before(time.Now().UTC())\n\n\tif requestedType, ok := app.IsRefreshRequested(); ok {\n\t\tcompareWith = CompareWithLatestForceResolve\n\t\t// user requested app refresh.\n\t\trefreshType = requestedType\n\t\treason = fmt.Sprintf(\"%s refresh requested\", refreshType)\n\t} else if !app.Spec.Source.Equals(app.Status.Sync.ComparedTo.Source) {\n\t\treason = \"spec.source differs\"\n\t\tcompareWith = CompareWithLatestForceResolve\n\t} else if expired {\n\t\t// The commented line below mysteriously crashes if app.Status.ReconciledAt is nil\n\t\t// reason = fmt.Sprintf(\"comparison expired. reconciledAt: %v, expiry: %v\", app.Status.ReconciledAt, statusRefreshTimeout)\n\t\t//TODO: find existing Golang bug or create a new one\n\t\treconciledAtStr := \"never\"\n\t\tif app.Status.ReconciledAt != nil {\n\t\t\treconciledAtStr = app.Status.ReconciledAt.String()\n\t\t}\n\t\treason = fmt.Sprintf(\"comparison expired. reconciledAt: %v, expiry: %v\", reconciledAtStr, statusRefreshTimeout)\n\t} else if !app.Spec.Destination.Equals(app.Status.Sync.ComparedTo.Destination) {\n\t\treason = \"spec.destination differs\"\n\t} else if requested, level := ctrl.isRefreshRequested(app.Name); requested {\n\t\tcompareWith = level\n\t\treason = \"controller refresh requested\"\n\t}\n\n\tif reason != \"\" {\n\t\tlogCtx.Infof(\"Refreshing app status (%s), level (%d)\", reason, compareWith)\n\t\treturn true, refreshType, compareWith\n\t}\n\treturn false, refreshType, compareWith\n}\n\nfunc (ctrl *ApplicationController) refreshAppConditions(app *appv1.Application) (*appv1.AppProject, bool) {\n\terrorConditions := make([]appv1.ApplicationCondition, 0)\n\tproj, err := ctrl.getAppProj(app)\n\tif err != nil {\n\t\tif apierr.IsNotFound(err) {\n\t\t\terrorConditions = append(errorConditions, appv1.ApplicationCondition{\n\t\t\t\tType:    appv1.ApplicationConditionInvalidSpecError,\n\t\t\t\tMessage: fmt.Sprintf(\"Application referencing project %s which does not exist\", app.Spec.Project),\n\t\t\t})\n\t\t} else {\n\t\t\terrorConditions = append(errorConditions, appv1.ApplicationCondition{\n\t\t\t\tType:    appv1.ApplicationConditionUnknownError,\n\t\t\t\tMessage: err.Error(),\n\t\t\t})\n\t\t}\n\t} else {\n\t\tspecConditions, err := argo.ValidatePermissions(context.Background(), &app.Spec, proj, ctrl.db)\n\t\tif err != nil {\n\t\t\terrorConditions = append(errorConditions, appv1.ApplicationCondition{\n\t\t\t\tType:    appv1.ApplicationConditionUnknownError,\n\t\t\t\tMessage: err.Error(),\n\t\t\t})\n\t\t} else {\n\t\t\terrorConditions = append(errorConditions, specConditions...)\n\t\t}\n\t}\n\tapp.Status.SetConditions(errorConditions, map[appv1.ApplicationConditionType]bool{\n\t\tappv1.ApplicationConditionInvalidSpecError: true,\n\t\tappv1.ApplicationConditionUnknownError:     true,\n\t})\n\treturn proj, len(errorConditions) > 0\n}\n\n// normalizeApplication normalizes an application.spec and additionally persists updates if it changed\nfunc (ctrl *ApplicationController) normalizeApplication(orig, app *appv1.Application) {\n\tlogCtx := log.WithFields(log.Fields{\"application\": app.Name})\n\tapp.Spec = *argo.NormalizeApplicationSpec(&app.Spec)\n\tpatch, modified, err := diff.CreateTwoWayMergePatch(orig, app, appv1.Application{})\n\tif err != nil {\n\t\tlogCtx.Errorf(\"error constructing app spec patch: %v\", err)\n\t} else if modified {\n\t\tappClient := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(app.Namespace)\n\t\t_, err = appClient.Patch(context.Background(), app.Name, types.MergePatchType, patch, metav1.PatchOptions{})\n\t\tif err != nil {\n\t\t\tlogCtx.Errorf(\"Error persisting normalized application spec: %v\", err)\n\t\t} else {\n\t\t\tlogCtx.Infof(\"Normalized app spec: %s\", string(patch))\n\t\t}\n\t}\n}\n\n// persistAppStatus persists updates to application status. If no changes were made, it is a no-op\nfunc (ctrl *ApplicationController) persistAppStatus(orig *appv1.Application, newStatus *appv1.ApplicationStatus) {\n\tlogCtx := log.WithFields(log.Fields{\"application\": orig.Name})\n\tif orig.Status.Sync.Status != newStatus.Sync.Status {\n\t\tmessage := fmt.Sprintf(\"Updated sync status: %s -> %s\", orig.Status.Sync.Status, newStatus.Sync.Status)\n\t\tctrl.auditLogger.LogAppEvent(orig, argo.EventInfo{Reason: argo.EventReasonResourceUpdated, Type: v1.EventTypeNormal}, message)\n\t}\n\tif orig.Status.Health.Status != newStatus.Health.Status {\n\t\tmessage := fmt.Sprintf(\"Updated health status: %s -> %s\", orig.Status.Health.Status, newStatus.Health.Status)\n\t\tctrl.auditLogger.LogAppEvent(orig, argo.EventInfo{Reason: argo.EventReasonResourceUpdated, Type: v1.EventTypeNormal}, message)\n\t}\n\tvar newAnnotations map[string]string\n\tif orig.GetAnnotations() != nil {\n\t\tnewAnnotations = make(map[string]string)\n\t\tfor k, v := range orig.GetAnnotations() {\n\t\t\tnewAnnotations[k] = v\n\t\t}\n\t\tdelete(newAnnotations, appv1.AnnotationKeyRefresh)\n\t}\n\tpatch, modified, err := diff.CreateTwoWayMergePatch(\n\t\t&appv1.Application{ObjectMeta: metav1.ObjectMeta{Annotations: orig.GetAnnotations()}, Status: orig.Status},\n\t\t&appv1.Application{ObjectMeta: metav1.ObjectMeta{Annotations: newAnnotations}, Status: *newStatus}, appv1.Application{})\n\tif err != nil {\n\t\tlogCtx.Errorf(\"Error constructing app status patch: %v\", err)\n\t\treturn\n\t}\n\tif !modified {\n\t\tlogCtx.Infof(\"No status changes. Skipping patch\")\n\t\treturn\n\t}\n\tlogCtx.Debugf(\"patch: %s\", string(patch))\n\tappClient := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(orig.Namespace)\n\t_, err = appClient.Patch(context.Background(), orig.Name, types.MergePatchType, patch, metav1.PatchOptions{})\n\tif err != nil {\n\t\tlogCtx.Warnf(\"Error updating application: %v\", err)\n\t} else {\n\t\tlogCtx.Infof(\"Update successful\")\n\t}\n}\n\n// autoSync will initiate a sync operation for an application configured with automated sync\nfunc (ctrl *ApplicationController) autoSync(app *appv1.Application, syncStatus *appv1.SyncStatus, resources []appv1.ResourceStatus) *appv1.ApplicationCondition {\n\tif app.Spec.SyncPolicy == nil || app.Spec.SyncPolicy.Automated == nil {\n\t\treturn nil\n\t}\n\tlogCtx := log.WithFields(log.Fields{\"application\": app.Name})\n\tif app.Operation != nil {\n\t\tlogCtx.Infof(\"Skipping auto-sync: another operation is in progress\")\n\t\treturn nil\n\t}\n\tif app.DeletionTimestamp != nil && !app.DeletionTimestamp.IsZero() {\n\t\tlogCtx.Infof(\"Skipping auto-sync: deletion in progress\")\n\t\treturn nil\n\t}\n\n\t// Only perform auto-sync if we detect OutOfSync status. This is to prevent us from attempting\n\t// a sync when application is already in a Synced or Unknown state\n\tif syncStatus.Status != appv1.SyncStatusCodeOutOfSync {\n\t\tlogCtx.Infof(\"Skipping auto-sync: application status is %s\", syncStatus.Status)\n\t\treturn nil\n\t}\n\n\tif !app.Spec.SyncPolicy.Automated.Prune {\n\t\trequirePruneOnly := true\n\t\tfor _, r := range resources {\n\t\t\tif r.Status != appv1.SyncStatusCodeSynced && !r.RequiresPruning {\n\t\t\t\trequirePruneOnly = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif requirePruneOnly {\n\t\t\tlogCtx.Infof(\"Skipping auto-sync: need to prune extra resources only but automated prune is disabled\")\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tdesiredCommitSHA := syncStatus.Revision\n\talreadyAttempted, attemptPhase := alreadyAttemptedSync(app, desiredCommitSHA)\n\tselfHeal := app.Spec.SyncPolicy.Automated.SelfHeal\n\top := appv1.Operation{\n\t\tSync: &appv1.SyncOperation{\n\t\t\tRevision:    desiredCommitSHA,\n\t\t\tPrune:       app.Spec.SyncPolicy.Automated.Prune,\n\t\t\tSyncOptions: app.Spec.SyncPolicy.SyncOptions,\n\t\t},\n\t\tInitiatedBy: appv1.OperationInitiator{Automated: true},\n\t\tRetry:       appv1.RetryStrategy{Limit: 5},\n\t}\n\tif app.Spec.SyncPolicy.Retry != nil {\n\t\top.Retry = *app.Spec.SyncPolicy.Retry\n\t}\n\t// It is possible for manifests to remain OutOfSync even after a sync/kubectl apply (e.g.\n\t// auto-sync with pruning disabled). We need to ensure that we do not keep Syncing an\n\t// application in an infinite loop. To detect this, we only attempt the Sync if the revision\n\t// and parameter overrides are different from our most recent sync operation.\n\tif alreadyAttempted && (!selfHeal || !attemptPhase.Successful()) {\n\t\tif !attemptPhase.Successful() {\n\t\t\tlogCtx.Warnf(\"Skipping auto-sync: failed previous sync attempt to %s\", desiredCommitSHA)\n\t\t\tmessage := fmt.Sprintf(\"Failed sync attempt to %s: %s\", desiredCommitSHA, app.Status.OperationState.Message)\n\t\t\treturn &appv1.ApplicationCondition{Type: appv1.ApplicationConditionSyncError, Message: message}\n\t\t}\n\t\tlogCtx.Infof(\"Skipping auto-sync: most recent sync already to %s\", desiredCommitSHA)\n\t\treturn nil\n\t} else if alreadyAttempted && selfHeal {\n\t\tif shouldSelfHeal, retryAfter := ctrl.shouldSelfHeal(app); shouldSelfHeal {\n\t\t\tfor _, resource := range resources {\n\t\t\t\tif resource.Status != appv1.SyncStatusCodeSynced {\n\t\t\t\t\top.Sync.Resources = append(op.Sync.Resources, appv1.SyncOperationResource{\n\t\t\t\t\t\tKind:  resource.Kind,\n\t\t\t\t\t\tGroup: resource.Group,\n\t\t\t\t\t\tName:  resource.Name,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlogCtx.Infof(\"Skipping auto-sync: already attempted sync to %s with timeout %v (retrying in %v)\", desiredCommitSHA, ctrl.selfHealTimeout, retryAfter)\n\t\t\tctrl.requestAppRefresh(app.Name, CompareWithLatest.Pointer(), &retryAfter)\n\t\t\treturn nil\n\t\t}\n\n\t}\n\n\tif app.Spec.SyncPolicy.Automated.Prune && !app.Spec.SyncPolicy.Automated.AllowEmpty {\n\t\tbAllNeedPrune := true\n\t\tfor _, r := range resources {\n\t\t\tif !r.RequiresPruning {\n\t\t\t\tbAllNeedPrune = false\n\t\t\t}\n\t\t}\n\t\tif bAllNeedPrune {\n\t\t\tmessage := fmt.Sprintf(\"Skipping sync attempt to %s: auto-sync will wipe out all resources\", desiredCommitSHA)\n\t\t\tlogCtx.Warnf(message)\n\t\t\treturn &appv1.ApplicationCondition{Type: appv1.ApplicationConditionSyncError, Message: message}\n\t\t}\n\t}\n\n\tappIf := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(app.Namespace)\n\t_, err := argo.SetAppOperation(appIf, app.Name, &op)\n\tif err != nil {\n\t\tlogCtx.Errorf(\"Failed to initiate auto-sync to %s: %v\", desiredCommitSHA, err)\n\t\treturn &appv1.ApplicationCondition{Type: appv1.ApplicationConditionSyncError, Message: err.Error()}\n\t}\n\tmessage := fmt.Sprintf(\"Initiated automated sync to '%s'\", desiredCommitSHA)\n\tctrl.auditLogger.LogAppEvent(app, argo.EventInfo{Reason: argo.EventReasonOperationStarted, Type: v1.EventTypeNormal}, message)\n\tlogCtx.Info(message)\n\treturn nil\n}\n\n// alreadyAttemptedSync returns whether or not the most recent sync was performed against the\n// commitSHA and with the same app source config which are currently set in the app\nfunc alreadyAttemptedSync(app *appv1.Application, commitSHA string) (bool, synccommon.OperationPhase) {\n\tif app.Status.OperationState == nil || app.Status.OperationState.Operation.Sync == nil || app.Status.OperationState.SyncResult == nil {\n\t\treturn false, \"\"\n\t}\n\tif app.Status.OperationState.SyncResult.Revision != commitSHA {\n\t\treturn false, \"\"\n\t}\n\t// Ignore differences in target revision, since we already just verified commitSHAs are equal,\n\t// and we do not want to trigger auto-sync due to things like HEAD != master\n\tspecSource := app.Spec.Source.DeepCopy()\n\tspecSource.TargetRevision = \"\"\n\tsyncResSource := app.Status.OperationState.SyncResult.Source.DeepCopy()\n\tsyncResSource.TargetRevision = \"\"\n\treturn reflect.DeepEqual(app.Spec.Source, app.Status.OperationState.SyncResult.Source), app.Status.OperationState.Phase\n}\n\nfunc (ctrl *ApplicationController) shouldSelfHeal(app *appv1.Application) (bool, time.Duration) {\n\tif app.Status.OperationState == nil {\n\t\treturn true, time.Duration(0)\n\t}\n\n\tvar retryAfter time.Duration\n\tif app.Status.OperationState.FinishedAt == nil {\n\t\tretryAfter = ctrl.selfHealTimeout\n\t} else {\n\t\tretryAfter = ctrl.selfHealTimeout - time.Since(app.Status.OperationState.FinishedAt.Time)\n\t}\n\treturn retryAfter <= 0, retryAfter\n}\n\nfunc (ctrl *ApplicationController) canProcessApp(obj interface{}) bool {\n\tapp, ok := obj.(*appv1.Application)\n\tif !ok {\n\t\treturn false\n\t}\n\tif ctrl.clusterFilter != nil {\n\t\tcluster, err := ctrl.db.GetCluster(context.Background(), app.Spec.Destination.Server)\n\t\tif err != nil {\n\t\t\treturn ctrl.clusterFilter(nil)\n\t\t}\n\t\treturn ctrl.clusterFilter(cluster)\n\t}\n\n\treturn true\n}\n\nfunc (ctrl *ApplicationController) newApplicationInformerAndLister() (cache.SharedIndexInformer, applisters.ApplicationLister) {\n\tinformer := cache.NewSharedIndexInformer(\n\t\t&cache.ListWatch{\n\t\t\tListFunc: func(options metav1.ListOptions) (apiruntime.Object, error) {\n\t\t\t\treturn ctrl.applicationClientset.ArgoprojV1alpha1().Applications(ctrl.namespace).List(context.TODO(), options)\n\t\t\t},\n\t\t\tWatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {\n\t\t\t\treturn ctrl.applicationClientset.ArgoprojV1alpha1().Applications(ctrl.namespace).Watch(context.TODO(), options)\n\t\t\t},\n\t\t},\n\t\t&appv1.Application{},\n\t\tctrl.statusRefreshTimeout,\n\t\tcache.Indexers{\n\t\t\tcache.NamespaceIndex: func(obj interface{}) ([]string, error) {\n\t\t\t\tapp, ok := obj.(*appv1.Application)\n\t\t\t\tif ok {\n\t\t\t\t\t// This call to 'ValidateDestination' ensures that the .spec.destination field of all Applications\n\t\t\t\t\t// returned by the informer/lister will have server field set (if not already set) based on the name.\n\t\t\t\t\t// (or, if not found, an error app condition)\n\n\t\t\t\t\t// If the server field is not set, set it based on the cluster name; if the cluster name can't be found,\n\t\t\t\t\t// log an error as an App Condition.\n\t\t\t\t\tif err := argo.ValidateDestination(context.Background(), &app.Spec.Destination, ctrl.db); err != nil {\n\t\t\t\t\t\tctrl.setAppCondition(app, appv1.ApplicationCondition{Type: appv1.ApplicationConditionInvalidSpecError, Message: err.Error()})\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn cache.MetaNamespaceIndexFunc(obj)\n\t\t\t},\n\t\t\torphanedIndex: func(obj interface{}) (i []string, e error) {\n\t\t\t\tapp, ok := obj.(*appv1.Application)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t}\n\n\t\t\t\tproj, err := applisters.NewAppProjectLister(ctrl.projInformer.GetIndexer()).AppProjects(ctrl.namespace).Get(app.Spec.GetProject())\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t}\n\t\t\t\tif proj.Spec.OrphanedResources != nil {\n\t\t\t\t\treturn []string{app.Spec.Destination.Namespace}, nil\n\t\t\t\t}\n\t\t\t\treturn nil, nil\n\t\t\t},\n\t\t},\n\t)\n\tlister := applisters.NewApplicationLister(informer.GetIndexer())\n\tinformer.AddEventHandler(\n\t\tcache.ResourceEventHandlerFuncs{\n\t\t\tAddFunc: func(obj interface{}) {\n\t\t\t\tif !ctrl.canProcessApp(obj) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tkey, err := cache.MetaNamespaceKeyFunc(obj)\n\t\t\t\tif err == nil {\n\t\t\t\t\tctrl.appRefreshQueue.Add(key)\n\t\t\t\t\tctrl.appOperationQueue.Add(key)\n\t\t\t\t}\n\t\t\t},\n\t\t\tUpdateFunc: func(old, new interface{}) {\n\t\t\t\tif !ctrl.canProcessApp(new) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tkey, err := cache.MetaNamespaceKeyFunc(new)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tvar compareWith *CompareWith\n\t\t\t\toldApp, oldOK := old.(*appv1.Application)\n\t\t\t\tnewApp, newOK := new.(*appv1.Application)\n\t\t\t\tif oldOK && newOK && automatedSyncEnabled(oldApp, newApp) {\n\t\t\t\t\tlog.WithField(\"application\", newApp.Name).Info(\"Enabled automated sync\")\n\t\t\t\t\tcompareWith = CompareWithLatest.Pointer()\n\t\t\t\t}\n\t\t\t\tctrl.requestAppRefresh(newApp.Name, compareWith, nil)\n\t\t\t\tctrl.appOperationQueue.Add(key)\n\t\t\t},\n\t\t\tDeleteFunc: func(obj interface{}) {\n\t\t\t\tif !ctrl.canProcessApp(obj) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\t// IndexerInformer uses a delta queue, therefore for deletes we have to use this\n\t\t\t\t// key function.\n\t\t\t\tkey, err := cache.DeletionHandlingMetaNamespaceKeyFunc(obj)\n\t\t\t\tif err == nil {\n\t\t\t\t\tctrl.appRefreshQueue.Add(key)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t)\n\treturn informer, lister\n}\n\nfunc (ctrl *ApplicationController) RegisterClusterSecretUpdater(ctx context.Context) {\n\tupdater := NewClusterInfoUpdater(ctrl.stateCache, ctrl.db, ctrl.appLister.Applications(ctrl.namespace), ctrl.cache, ctrl.clusterFilter)\n\tgo updater.Run(ctx)\n}\n\nfunc isOperationInProgress(app *appv1.Application) bool {\n\treturn app.Status.OperationState != nil && !app.Status.OperationState.Phase.Completed()\n}\n\n// automatedSyncEnabled tests if an app went from auto-sync disabled to enabled.\n// if it was toggled to be enabled, the informer handler will force a refresh\nfunc automatedSyncEnabled(oldApp *appv1.Application, newApp *appv1.Application) bool {\n\toldEnabled := false\n\toldSelfHealEnabled := false\n\tif oldApp.Spec.SyncPolicy != nil && oldApp.Spec.SyncPolicy.Automated != nil {\n\t\toldEnabled = true\n\t\toldSelfHealEnabled = oldApp.Spec.SyncPolicy.Automated.SelfHeal\n\t}\n\n\tnewEnabled := false\n\tnewSelfHealEnabled := false\n\tif newApp.Spec.SyncPolicy != nil && newApp.Spec.SyncPolicy.Automated != nil {\n\t\tnewEnabled = true\n\t\tnewSelfHealEnabled = newApp.Spec.SyncPolicy.Automated.SelfHeal\n\t}\n\tif !oldEnabled && newEnabled {\n\t\treturn true\n\t}\n\tif !oldSelfHealEnabled && newSelfHealEnabled {\n\t\treturn true\n\t}\n\t// nothing changed\n\treturn false\n}\n", "package controller\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"testing\"\n\t\"time\"\n\n\t\"k8s.io/apimachinery/pkg/api/resource\"\n\n\tclustercache \"github.com/argoproj/gitops-engine/pkg/cache\"\n\n\t\"github.com/argoproj/argo-cd/v2/common\"\n\tstatecache \"github.com/argoproj/argo-cd/v2/controller/cache\"\n\n\t\"github.com/argoproj/gitops-engine/pkg/cache/mocks\"\n\tsynccommon \"github.com/argoproj/gitops-engine/pkg/sync/common\"\n\t\"github.com/argoproj/gitops-engine/pkg/utils/kube\"\n\t\"github.com/argoproj/gitops-engine/pkg/utils/kube/kubetest\"\n\t\"github.com/ghodss/yaml\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/mock\"\n\tcorev1 \"k8s.io/api/core/v1\"\n\tapierr \"k8s.io/apimachinery/pkg/api/errors\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\t\"k8s.io/apimachinery/pkg/runtime/schema\"\n\t\"k8s.io/client-go/kubernetes/fake\"\n\tkubetesting \"k8s.io/client-go/testing\"\n\t\"k8s.io/client-go/tools/cache\"\n\n\tmockstatecache \"github.com/argoproj/argo-cd/v2/controller/cache/mocks\"\n\t\"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1\"\n\targoappv1 \"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1\"\n\tappclientset \"github.com/argoproj/argo-cd/v2/pkg/client/clientset/versioned/fake\"\n\t\"github.com/argoproj/argo-cd/v2/reposerver/apiclient\"\n\tmockrepoclient \"github.com/argoproj/argo-cd/v2/reposerver/apiclient/mocks\"\n\t\"github.com/argoproj/argo-cd/v2/test\"\n\tcacheutil \"github.com/argoproj/argo-cd/v2/util/cache\"\n\tappstatecache \"github.com/argoproj/argo-cd/v2/util/cache/appstate\"\n\t\"github.com/argoproj/argo-cd/v2/util/settings\"\n)\n\ntype namespacedResource struct {\n\targoappv1.ResourceNode\n\tAppName string\n}\n\ntype fakeData struct {\n\tapps                   []runtime.Object\n\tmanifestResponse       *apiclient.ManifestResponse\n\tmanagedLiveObjs        map[kube.ResourceKey]*unstructured.Unstructured\n\tnamespacedResources    map[kube.ResourceKey]namespacedResource\n\tconfigMapData          map[string]string\n\tmetricsCacheExpiration time.Duration\n}\n\nfunc newFakeController(data *fakeData) *ApplicationController {\n\tvar clust corev1.Secret\n\terr := yaml.Unmarshal([]byte(fakeCluster), &clust)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Mock out call to GenerateManifest\n\tmockRepoClient := mockrepoclient.RepoServerServiceClient{}\n\tmockRepoClient.On(\"GenerateManifest\", mock.Anything, mock.Anything).Return(data.manifestResponse, nil)\n\tmockRepoClientset := mockrepoclient.Clientset{RepoServerServiceClient: &mockRepoClient}\n\n\tsecret := corev1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"argocd-secret\",\n\t\t\tNamespace: test.FakeArgoCDNamespace,\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t\"admin.password\":   []byte(\"test\"),\n\t\t\t\"server.secretkey\": []byte(\"test\"),\n\t\t},\n\t}\n\tcm := corev1.ConfigMap{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"argocd-cm\",\n\t\t\tNamespace: test.FakeArgoCDNamespace,\n\t\t\tLabels: map[string]string{\n\t\t\t\t\"app.kubernetes.io/part-of\": \"argocd\",\n\t\t\t},\n\t\t},\n\t\tData: data.configMapData,\n\t}\n\tkubeClient := fake.NewSimpleClientset(&clust, &cm, &secret)\n\tsettingsMgr := settings.NewSettingsManager(context.Background(), kubeClient, test.FakeArgoCDNamespace)\n\tkubectl := &kubetest.MockKubectlCmd{}\n\tctrl, err := NewApplicationController(\n\t\ttest.FakeArgoCDNamespace,\n\t\tsettingsMgr,\n\t\tkubeClient,\n\t\tappclientset.NewSimpleClientset(data.apps...),\n\t\t&mockRepoClientset,\n\t\tappstatecache.NewCache(\n\t\t\tcacheutil.NewCache(cacheutil.NewInMemoryCache(1*time.Minute)),\n\t\t\t1*time.Minute,\n\t\t),\n\t\tkubectl,\n\t\ttime.Minute,\n\t\ttime.Minute,\n\t\tcommon.DefaultPortArgoCDMetrics,\n\t\tdata.metricsCacheExpiration,\n\t\t[]string{},\n\t\t0,\n\t\tnil,\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tcancelProj := test.StartInformer(ctrl.projInformer)\n\tdefer cancelProj()\n\tcancelApp := test.StartInformer(ctrl.appInformer)\n\tdefer cancelApp()\n\tclusterCacheMock := mocks.ClusterCache{}\n\tclusterCacheMock.On(\"IsNamespaced\", mock.Anything).Return(true, nil)\n\tclusterCacheMock.On(\"GetOpenAPISchema\").Return(nil, nil)\n\n\tmockStateCache := mockstatecache.LiveStateCache{}\n\tctrl.appStateManager.(*appStateManager).liveStateCache = &mockStateCache\n\tctrl.stateCache = &mockStateCache\n\tmockStateCache.On(\"IsNamespaced\", mock.Anything, mock.Anything).Return(true, nil)\n\tmockStateCache.On(\"GetManagedLiveObjs\", mock.Anything, mock.Anything).Return(data.managedLiveObjs, nil)\n\tmockStateCache.On(\"GetVersionsInfo\", mock.Anything).Return(\"v1.2.3\", nil, nil)\n\tresponse := make(map[kube.ResourceKey]argoappv1.ResourceNode)\n\tfor k, v := range data.namespacedResources {\n\t\tresponse[k] = v.ResourceNode\n\t}\n\tmockStateCache.On(\"GetNamespaceTopLevelResources\", mock.Anything, mock.Anything).Return(response, nil)\n\tmockStateCache.On(\"IterateResources\", mock.Anything, mock.Anything).Return(nil)\n\tmockStateCache.On(\"GetClusterCache\", mock.Anything).Return(&clusterCacheMock, nil)\n\tmockStateCache.On(\"IterateHierarchy\", mock.Anything, mock.Anything, mock.Anything).Run(func(args mock.Arguments) {\n\t\tkey := args[1].(kube.ResourceKey)\n\t\taction := args[2].(func(child argoappv1.ResourceNode, appName string))\n\t\tappName := \"\"\n\t\tif res, ok := data.namespacedResources[key]; ok {\n\t\t\tappName = res.AppName\n\t\t}\n\t\taction(argoappv1.ResourceNode{ResourceRef: argoappv1.ResourceRef{Kind: key.Kind, Group: key.Group, Namespace: key.Namespace, Name: key.Name}}, appName)\n\t}).Return(nil)\n\treturn ctrl\n}\n\nvar fakeCluster = `\napiVersion: v1\ndata:\n  # {\"bearerToken\":\"fake\",\"tlsClientConfig\":{\"insecure\":true},\"awsAuthConfig\":null}\n  config: eyJiZWFyZXJUb2tlbiI6ImZha2UiLCJ0bHNDbGllbnRDb25maWciOnsiaW5zZWN1cmUiOnRydWV9LCJhd3NBdXRoQ29uZmlnIjpudWxsfQ==\n  # minikube\n  name: bWluaWt1YmU=\n  # https://localhost:6443\n  server: aHR0cHM6Ly9sb2NhbGhvc3Q6NjQ0Mw==\nkind: Secret\nmetadata:\n  labels:\n    argocd.argoproj.io/secret-type: cluster\n  name: some-secret\n  namespace: ` + test.FakeArgoCDNamespace + `\ntype: Opaque\n`\n\nvar fakeApp = `\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  uid: \"123\"\n  name: my-app\n  namespace: ` + test.FakeArgoCDNamespace + `\nspec:\n  destination:\n    namespace: ` + test.FakeDestNamespace + `\n    server: https://localhost:6443\n  project: default\n  source:\n    path: some/path\n    repoURL: https://github.com/argoproj/argocd-example-apps.git\n  syncPolicy:\n    automated: {}\nstatus:\n  operationState:\n    finishedAt: 2018-09-21T23:50:29Z\n    message: successfully synced\n    operation:\n      sync:\n        revision: HEAD\n    phase: Succeeded\n    startedAt: 2018-09-21T23:50:25Z\n    syncResult:\n      resources:\n      - kind: RoleBinding\n        message: |-\n          rolebinding.rbac.authorization.k8s.io/always-outofsync reconciled\n          rolebinding.rbac.authorization.k8s.io/always-outofsync configured\n        name: always-outofsync\n        namespace: default\n        status: Synced\n      revision: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n      source:\n        path: some/path\n        repoURL: https://github.com/argoproj/argocd-example-apps.git\n`\n\nvar fakeAppWithDestName = `\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  uid: \"123\"\n  name: my-app\n  namespace: ` + test.FakeArgoCDNamespace + `\nspec:\n  destination:\n    namespace: ` + test.FakeDestNamespace + `\n    name: minikube\n  project: default\n  source:\n    path: some/path\n    repoURL: https://github.com/argoproj/argocd-example-apps.git\n  syncPolicy:\n    automated: {}\n`\n\nvar fakeAppWithDestMismatch = `\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  uid: \"123\"\n  name: my-app\n  namespace: ` + test.FakeArgoCDNamespace + `\nspec:\n  destination:\n    namespace: ` + test.FakeDestNamespace + `\n    name: another-cluster\n    server: https://localhost:6443\n  project: default\n  source:\n    path: some/path\n    repoURL: https://github.com/argoproj/argocd-example-apps.git\n  syncPolicy:\n    automated: {}\n`\n\nvar fakeStrayResource = `\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: test-cm\n  namespace: invalid\n  labels:\n    app.kubernetes.io/instance: my-app\ndata:\n`\n\nfunc newFakeApp() *argoappv1.Application {\n\treturn createFakeApp(fakeApp)\n}\n\nfunc newFakeAppWithDestMismatch() *argoappv1.Application {\n\treturn createFakeApp(fakeAppWithDestMismatch)\n}\n\nfunc newFakeAppWithDestName() *argoappv1.Application {\n\treturn createFakeApp(fakeAppWithDestName)\n}\n\nfunc createFakeApp(testApp string) *argoappv1.Application {\n\tvar app argoappv1.Application\n\terr := yaml.Unmarshal([]byte(testApp), &app)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn &app\n}\n\nfunc newFakeCM() map[string]interface{} {\n\tvar cm map[string]interface{}\n\terr := yaml.Unmarshal([]byte(fakeStrayResource), &cm)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn cm\n}\n\nfunc TestAutoSync(t *testing.T) {\n\tapp := newFakeApp()\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\tsyncStatus := argoappv1.SyncStatus{\n\t\tStatus:   argoappv1.SyncStatusCodeOutOfSync,\n\t\tRevision: \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\",\n\t}\n\tcond := ctrl.autoSync(app, &syncStatus, []argoappv1.ResourceStatus{{Name: \"guestbook\", Kind: kube.DeploymentKind, Status: argoappv1.SyncStatusCodeOutOfSync}})\n\tassert.Nil(t, cond)\n\tapp, err := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(test.FakeArgoCDNamespace).Get(context.Background(), \"my-app\", metav1.GetOptions{})\n\tassert.NoError(t, err)\n\tassert.NotNil(t, app.Operation)\n\tassert.NotNil(t, app.Operation.Sync)\n\tassert.False(t, app.Operation.Sync.Prune)\n}\n\nfunc TestAutoSyncNotAllowEmpty(t *testing.T) {\n\tapp := newFakeApp()\n\tapp.Spec.SyncPolicy.Automated.Prune = true\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\tsyncStatus := argoappv1.SyncStatus{\n\t\tStatus:   argoappv1.SyncStatusCodeOutOfSync,\n\t\tRevision: \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\",\n\t}\n\tcond := ctrl.autoSync(app, &syncStatus, []argoappv1.ResourceStatus{})\n\tassert.NotNil(t, cond)\n}\n\nfunc TestAutoSyncAllowEmpty(t *testing.T) {\n\tapp := newFakeApp()\n\tapp.Spec.SyncPolicy.Automated.Prune = true\n\tapp.Spec.SyncPolicy.Automated.AllowEmpty = true\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\tsyncStatus := argoappv1.SyncStatus{\n\t\tStatus:   argoappv1.SyncStatusCodeOutOfSync,\n\t\tRevision: \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\",\n\t}\n\tcond := ctrl.autoSync(app, &syncStatus, []argoappv1.ResourceStatus{})\n\tassert.Nil(t, cond)\n}\n\nfunc TestSkipAutoSync(t *testing.T) {\n\t// Verify we skip when we previously synced to it in our most recent history\n\t// Set current to 'aaaaa', desired to 'aaaa' and mark system OutOfSync\n\tt.Run(\"PreviouslySyncedToRevision\", func(t *testing.T) {\n\t\tapp := newFakeApp()\n\t\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\t\tsyncStatus := argoappv1.SyncStatus{\n\t\t\tStatus:   argoappv1.SyncStatusCodeOutOfSync,\n\t\t\tRevision: \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n\t\t}\n\t\tcond := ctrl.autoSync(app, &syncStatus, []argoappv1.ResourceStatus{})\n\t\tassert.Nil(t, cond)\n\t\tapp, err := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(test.FakeArgoCDNamespace).Get(context.Background(), \"my-app\", metav1.GetOptions{})\n\t\tassert.NoError(t, err)\n\t\tassert.Nil(t, app.Operation)\n\t})\n\n\t// Verify we skip when we are already Synced (even if revision is different)\n\tt.Run(\"AlreadyInSyncedState\", func(t *testing.T) {\n\t\tapp := newFakeApp()\n\t\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\t\tsyncStatus := argoappv1.SyncStatus{\n\t\t\tStatus:   argoappv1.SyncStatusCodeSynced,\n\t\t\tRevision: \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\",\n\t\t}\n\t\tcond := ctrl.autoSync(app, &syncStatus, []argoappv1.ResourceStatus{})\n\t\tassert.Nil(t, cond)\n\t\tapp, err := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(test.FakeArgoCDNamespace).Get(context.Background(), \"my-app\", metav1.GetOptions{})\n\t\tassert.NoError(t, err)\n\t\tassert.Nil(t, app.Operation)\n\t})\n\n\t// Verify we skip when auto-sync is disabled\n\tt.Run(\"AutoSyncIsDisabled\", func(t *testing.T) {\n\t\tapp := newFakeApp()\n\t\tapp.Spec.SyncPolicy = nil\n\t\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\t\tsyncStatus := argoappv1.SyncStatus{\n\t\t\tStatus:   argoappv1.SyncStatusCodeOutOfSync,\n\t\t\tRevision: \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\",\n\t\t}\n\t\tcond := ctrl.autoSync(app, &syncStatus, []argoappv1.ResourceStatus{})\n\t\tassert.Nil(t, cond)\n\t\tapp, err := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(test.FakeArgoCDNamespace).Get(context.Background(), \"my-app\", metav1.GetOptions{})\n\t\tassert.NoError(t, err)\n\t\tassert.Nil(t, app.Operation)\n\t})\n\n\t// Verify we skip when application is marked for deletion\n\tt.Run(\"ApplicationIsMarkedForDeletion\", func(t *testing.T) {\n\t\tapp := newFakeApp()\n\t\tnow := metav1.Now()\n\t\tapp.DeletionTimestamp = &now\n\t\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\t\tsyncStatus := argoappv1.SyncStatus{\n\t\t\tStatus:   argoappv1.SyncStatusCodeOutOfSync,\n\t\t\tRevision: \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\",\n\t\t}\n\t\tcond := ctrl.autoSync(app, &syncStatus, []argoappv1.ResourceStatus{})\n\t\tassert.Nil(t, cond)\n\t\tapp, err := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(test.FakeArgoCDNamespace).Get(context.Background(), \"my-app\", metav1.GetOptions{})\n\t\tassert.NoError(t, err)\n\t\tassert.Nil(t, app.Operation)\n\t})\n\n\t// Verify we skip when previous sync attempt failed and return error condition\n\t// Set current to 'aaaaa', desired to 'bbbbb' and add 'bbbbb' to failure history\n\tt.Run(\"PreviousSyncAttemptFailed\", func(t *testing.T) {\n\t\tapp := newFakeApp()\n\t\tapp.Status.OperationState = &argoappv1.OperationState{\n\t\t\tOperation: argoappv1.Operation{\n\t\t\t\tSync: &argoappv1.SyncOperation{},\n\t\t\t},\n\t\t\tPhase: synccommon.OperationFailed,\n\t\t\tSyncResult: &argoappv1.SyncOperationResult{\n\t\t\t\tRevision: \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\",\n\t\t\t\tSource:   *app.Spec.Source.DeepCopy(),\n\t\t\t},\n\t\t}\n\t\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\t\tsyncStatus := argoappv1.SyncStatus{\n\t\t\tStatus:   argoappv1.SyncStatusCodeOutOfSync,\n\t\t\tRevision: \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\",\n\t\t}\n\t\tcond := ctrl.autoSync(app, &syncStatus, []argoappv1.ResourceStatus{{Name: \"guestbook\", Kind: kube.DeploymentKind, Status: argoappv1.SyncStatusCodeOutOfSync}})\n\t\tassert.NotNil(t, cond)\n\t\tapp, err := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(test.FakeArgoCDNamespace).Get(context.Background(), \"my-app\", metav1.GetOptions{})\n\t\tassert.NoError(t, err)\n\t\tassert.Nil(t, app.Operation)\n\t})\n\n\tt.Run(\"NeedsToPruneResourcesOnlyButAutomatedPruneDisabled\", func(t *testing.T) {\n\t\tapp := newFakeApp()\n\t\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\t\tsyncStatus := argoappv1.SyncStatus{\n\t\t\tStatus:   argoappv1.SyncStatusCodeOutOfSync,\n\t\t\tRevision: \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\",\n\t\t}\n\t\tcond := ctrl.autoSync(app, &syncStatus, []argoappv1.ResourceStatus{\n\t\t\t{Name: \"guestbook\", Kind: kube.DeploymentKind, Status: argoappv1.SyncStatusCodeOutOfSync, RequiresPruning: true},\n\t\t})\n\t\tassert.Nil(t, cond)\n\t\tapp, err := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(test.FakeArgoCDNamespace).Get(context.Background(), \"my-app\", metav1.GetOptions{})\n\t\tassert.NoError(t, err)\n\t\tassert.Nil(t, app.Operation)\n\t})\n}\n\n// TestAutoSyncIndicateError verifies we skip auto-sync and return error condition if previous sync failed\nfunc TestAutoSyncIndicateError(t *testing.T) {\n\tapp := newFakeApp()\n\tapp.Spec.Source.Helm = &argoappv1.ApplicationSourceHelm{\n\t\tParameters: []argoappv1.HelmParameter{\n\t\t\t{\n\t\t\t\tName:  \"a\",\n\t\t\t\tValue: \"1\",\n\t\t\t},\n\t\t},\n\t}\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\tsyncStatus := argoappv1.SyncStatus{\n\t\tStatus:   argoappv1.SyncStatusCodeOutOfSync,\n\t\tRevision: \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n\t}\n\tapp.Status.OperationState = &argoappv1.OperationState{\n\t\tOperation: argoappv1.Operation{\n\t\t\tSync: &argoappv1.SyncOperation{\n\t\t\t\tSource: app.Spec.Source.DeepCopy(),\n\t\t\t},\n\t\t},\n\t\tPhase: synccommon.OperationFailed,\n\t\tSyncResult: &argoappv1.SyncOperationResult{\n\t\t\tRevision: \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n\t\t\tSource:   *app.Spec.Source.DeepCopy(),\n\t\t},\n\t}\n\tcond := ctrl.autoSync(app, &syncStatus, []argoappv1.ResourceStatus{{Name: \"guestbook\", Kind: kube.DeploymentKind, Status: argoappv1.SyncStatusCodeOutOfSync}})\n\tassert.NotNil(t, cond)\n\tapp, err := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(test.FakeArgoCDNamespace).Get(context.Background(), \"my-app\", metav1.GetOptions{})\n\tassert.NoError(t, err)\n\tassert.Nil(t, app.Operation)\n}\n\n// TestAutoSyncParameterOverrides verifies we auto-sync if revision is same but parameter overrides are different\nfunc TestAutoSyncParameterOverrides(t *testing.T) {\n\tapp := newFakeApp()\n\tapp.Spec.Source.Helm = &argoappv1.ApplicationSourceHelm{\n\t\tParameters: []argoappv1.HelmParameter{\n\t\t\t{\n\t\t\t\tName:  \"a\",\n\t\t\t\tValue: \"1\",\n\t\t\t},\n\t\t},\n\t}\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\tsyncStatus := argoappv1.SyncStatus{\n\t\tStatus:   argoappv1.SyncStatusCodeOutOfSync,\n\t\tRevision: \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n\t}\n\tapp.Status.OperationState = &argoappv1.OperationState{\n\t\tOperation: argoappv1.Operation{\n\t\t\tSync: &argoappv1.SyncOperation{\n\t\t\t\tSource: &argoappv1.ApplicationSource{\n\t\t\t\t\tHelm: &argoappv1.ApplicationSourceHelm{\n\t\t\t\t\t\tParameters: []argoappv1.HelmParameter{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tName:  \"a\",\n\t\t\t\t\t\t\t\tValue: \"2\", // this value changed\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tPhase: synccommon.OperationFailed,\n\t\tSyncResult: &argoappv1.SyncOperationResult{\n\t\t\tRevision: \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n\t\t},\n\t}\n\tcond := ctrl.autoSync(app, &syncStatus, []argoappv1.ResourceStatus{{Name: \"guestbook\", Kind: kube.DeploymentKind, Status: argoappv1.SyncStatusCodeOutOfSync}})\n\tassert.Nil(t, cond)\n\tapp, err := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(test.FakeArgoCDNamespace).Get(context.Background(), \"my-app\", metav1.GetOptions{})\n\tassert.NoError(t, err)\n\tassert.NotNil(t, app.Operation)\n}\n\n// TestFinalizeAppDeletion verifies application deletion\nfunc TestFinalizeAppDeletion(t *testing.T) {\n\tdefaultProj := argoappv1.AppProject{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"default\",\n\t\t\tNamespace: test.FakeArgoCDNamespace,\n\t\t},\n\t\tSpec: argoappv1.AppProjectSpec{\n\t\t\tSourceRepos: []string{\"*\"},\n\t\t\tDestinations: []argoappv1.ApplicationDestination{\n\t\t\t\t{\n\t\t\t\t\tServer:    \"*\",\n\t\t\t\t\tNamespace: \"*\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\t// Ensure app can be deleted cascading\n\tt.Run(\"CascadingDelete\", func(t *testing.T) {\n\t\tapp := newFakeApp()\n\t\tapp.Spec.Destination.Namespace = test.FakeArgoCDNamespace\n\t\tappObj := kube.MustToUnstructured(&app)\n\t\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app, &defaultProj}, managedLiveObjs: map[kube.ResourceKey]*unstructured.Unstructured{\n\t\t\tkube.GetResourceKey(appObj): appObj,\n\t\t}})\n\n\t\tpatched := false\n\t\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\t\tdefaultReactor := fakeAppCs.ReactionChain[0]\n\t\tfakeAppCs.ReactionChain = nil\n\t\tfakeAppCs.AddReactor(\"get\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\t\treturn defaultReactor.React(action)\n\t\t})\n\t\tfakeAppCs.AddReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\t\tpatched = true\n\t\t\treturn true, nil, nil\n\t\t})\n\t\t_, err := ctrl.finalizeApplicationDeletion(app)\n\t\tassert.NoError(t, err)\n\t\tassert.True(t, patched)\n\t})\n\n\t// Ensure any stray resources irregularly labeled with instance label of app are not deleted upon deleting,\n\t// when app project restriction is in place\n\tt.Run(\"ProjectRestrictionEnforced\", func(*testing.T) {\n\t\trestrictedProj := argoappv1.AppProject{\n\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\tName:      \"restricted\",\n\t\t\t\tNamespace: test.FakeArgoCDNamespace,\n\t\t\t},\n\t\t\tSpec: argoappv1.AppProjectSpec{\n\t\t\t\tSourceRepos: []string{\"*\"},\n\t\t\t\tDestinations: []argoappv1.ApplicationDestination{\n\t\t\t\t\t{\n\t\t\t\t\t\tServer:    \"*\",\n\t\t\t\t\t\tNamespace: \"my-app\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\tapp := newFakeApp()\n\t\tapp.Spec.Destination.Namespace = test.FakeArgoCDNamespace\n\t\tapp.Spec.Project = \"restricted\"\n\t\tappObj := kube.MustToUnstructured(&app)\n\t\tcm := newFakeCM()\n\t\tstrayObj := kube.MustToUnstructured(&cm)\n\t\tctrl := newFakeController(&fakeData{\n\t\t\tapps: []runtime.Object{app, &defaultProj, &restrictedProj},\n\t\t\tmanagedLiveObjs: map[kube.ResourceKey]*unstructured.Unstructured{\n\t\t\t\tkube.GetResourceKey(appObj):   appObj,\n\t\t\t\tkube.GetResourceKey(strayObj): strayObj,\n\t\t\t},\n\t\t})\n\n\t\tpatched := false\n\t\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\t\tdefaultReactor := fakeAppCs.ReactionChain[0]\n\t\tfakeAppCs.ReactionChain = nil\n\t\tfakeAppCs.AddReactor(\"get\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\t\treturn defaultReactor.React(action)\n\t\t})\n\t\tfakeAppCs.AddReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\t\tpatched = true\n\t\t\treturn true, nil, nil\n\t\t})\n\t\tobjs, err := ctrl.finalizeApplicationDeletion(app)\n\t\tassert.NoError(t, err)\n\t\tassert.True(t, patched)\n\t\tobjsMap, err := ctrl.stateCache.GetManagedLiveObjs(app, []*unstructured.Unstructured{})\n\t\tif err != nil {\n\t\t\tassert.NoError(t, err)\n\t\t}\n\t\t// Managed objects must be empty\n\t\tassert.Empty(t, objsMap)\n\t\t// Loop through all deleted objects, ensure that test-cm is none of them\n\t\tfor _, o := range objs {\n\t\t\tassert.NotEqual(t, \"test-cm\", o.GetName())\n\t\t}\n\t})\n\n\tt.Run(\"DeleteWithDestinationClusterName\", func(t *testing.T) {\n\t\tapp := newFakeAppWithDestName()\n\t\tappObj := kube.MustToUnstructured(&app)\n\t\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app, &defaultProj}, managedLiveObjs: map[kube.ResourceKey]*unstructured.Unstructured{\n\t\t\tkube.GetResourceKey(appObj): appObj,\n\t\t}})\n\t\tpatched := false\n\t\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\t\tdefaultReactor := fakeAppCs.ReactionChain[0]\n\t\tfakeAppCs.ReactionChain = nil\n\t\tfakeAppCs.AddReactor(\"get\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\t\treturn defaultReactor.React(action)\n\t\t})\n\t\tfakeAppCs.AddReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\t\tpatched = true\n\t\t\treturn true, nil, nil\n\t\t})\n\t\t_, err := ctrl.finalizeApplicationDeletion(app)\n\t\tassert.NoError(t, err)\n\t\tassert.True(t, patched)\n\t})\n\n\t// Create an Application with a cluster that doesn't exist\n\t// Ensure it can be deleted.\n\tt.Run(\"DeleteWithInvalidClusterName\", func(t *testing.T) {\n\n\t\tappTemplate := newFakeAppWithDestName()\n\n\t\ttestShouldDelete := func(app *argoappv1.Application) {\n\t\t\tappObj := kube.MustToUnstructured(&app)\n\t\t\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app, &defaultProj}, managedLiveObjs: map[kube.ResourceKey]*unstructured.Unstructured{\n\t\t\t\tkube.GetResourceKey(appObj): appObj,\n\t\t\t}})\n\n\t\t\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\t\t\tdefaultReactor := fakeAppCs.ReactionChain[0]\n\t\t\tfakeAppCs.ReactionChain = nil\n\t\t\tfakeAppCs.AddReactor(\"get\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\t\t\treturn defaultReactor.React(action)\n\t\t\t})\n\t\t\t_, err := ctrl.finalizeApplicationDeletion(app)\n\t\t\tassert.NoError(t, err)\n\t\t}\n\n\t\tapp1 := appTemplate.DeepCopy()\n\t\tapp1.Spec.Destination.Server = \"https://invalid\"\n\t\ttestShouldDelete(app1)\n\n\t\tapp2 := appTemplate.DeepCopy()\n\t\tapp2.Spec.Destination.Name = \"invalid\"\n\t\ttestShouldDelete(app2)\n\n\t\tapp3 := appTemplate.DeepCopy()\n\t\tapp3.Spec.Destination.Name = \"invalid\"\n\t\tapp3.Spec.Destination.Server = \"https://invalid\"\n\t\ttestShouldDelete(app3)\n\n\t})\n\n}\n\n// TestNormalizeApplication verifies we normalize an application during reconciliation\nfunc TestNormalizeApplication(t *testing.T) {\n\tdefaultProj := argoappv1.AppProject{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"default\",\n\t\t\tNamespace: test.FakeArgoCDNamespace,\n\t\t},\n\t\tSpec: argoappv1.AppProjectSpec{\n\t\t\tSourceRepos: []string{\"*\"},\n\t\t\tDestinations: []argoappv1.ApplicationDestination{\n\t\t\t\t{\n\t\t\t\t\tServer:    \"*\",\n\t\t\t\t\tNamespace: \"*\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tapp := newFakeApp()\n\tapp.Spec.Project = \"\"\n\tapp.Spec.Source.Kustomize = &argoappv1.ApplicationSourceKustomize{NamePrefix: \"foo-\"}\n\tdata := fakeData{\n\t\tapps: []runtime.Object{app, &defaultProj},\n\t\tmanifestResponse: &apiclient.ManifestResponse{\n\t\t\tManifests: []string{},\n\t\t\tNamespace: test.FakeDestNamespace,\n\t\t\tServer:    test.FakeClusterURL,\n\t\t\tRevision:  \"abc123\",\n\t\t},\n\t\tmanagedLiveObjs: make(map[kube.ResourceKey]*unstructured.Unstructured),\n\t}\n\n\t{\n\t\t// Verify we normalize the app because project is missing\n\t\tctrl := newFakeController(&data)\n\t\tkey, _ := cache.MetaNamespaceKeyFunc(app)\n\t\tctrl.appRefreshQueue.Add(key)\n\t\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\t\tfakeAppCs.ReactionChain = nil\n\t\tnormalized := false\n\t\tfakeAppCs.AddReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\t\tif patchAction, ok := action.(kubetesting.PatchAction); ok {\n\t\t\t\tif string(patchAction.GetPatch()) == `{\"spec\":{\"project\":\"default\"}}` {\n\t\t\t\t\tnormalized = true\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true, nil, nil\n\t\t})\n\t\tctrl.processAppRefreshQueueItem()\n\t\tassert.True(t, normalized)\n\t}\n\n\t{\n\t\t// Verify we don't unnecessarily normalize app when project is set\n\t\tapp.Spec.Project = \"default\"\n\t\tdata.apps[0] = app\n\t\tctrl := newFakeController(&data)\n\t\tkey, _ := cache.MetaNamespaceKeyFunc(app)\n\t\tctrl.appRefreshQueue.Add(key)\n\t\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\t\tfakeAppCs.ReactionChain = nil\n\t\tnormalized := false\n\t\tfakeAppCs.AddReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\t\tif patchAction, ok := action.(kubetesting.PatchAction); ok {\n\t\t\t\tif string(patchAction.GetPatch()) == `{\"spec\":{\"project\":\"default\"}}` {\n\t\t\t\t\tnormalized = true\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true, nil, nil\n\t\t})\n\t\tctrl.processAppRefreshQueueItem()\n\t\tassert.False(t, normalized)\n\t}\n}\n\nfunc TestHandleAppUpdated(t *testing.T) {\n\tapp := newFakeApp()\n\tapp.Spec.Destination.Namespace = test.FakeArgoCDNamespace\n\tapp.Spec.Destination.Server = argoappv1.KubernetesInternalAPIServerAddr\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\n\tctrl.handleObjectUpdated(map[string]bool{app.Name: true}, kube.GetObjectRef(kube.MustToUnstructured(app)))\n\tisRequested, level := ctrl.isRefreshRequested(app.Name)\n\tassert.False(t, isRequested)\n\tassert.Equal(t, ComparisonWithNothing, level)\n\n\tctrl.handleObjectUpdated(map[string]bool{app.Name: true}, corev1.ObjectReference{UID: \"test\", Kind: kube.DeploymentKind, Name: \"test\", Namespace: \"default\"})\n\tisRequested, level = ctrl.isRefreshRequested(app.Name)\n\tassert.True(t, isRequested)\n\tassert.Equal(t, CompareWithRecent, level)\n}\n\nfunc TestHandleOrphanedResourceUpdated(t *testing.T) {\n\tapp1 := newFakeApp()\n\tapp1.Name = \"app1\"\n\tapp1.Spec.Destination.Namespace = test.FakeArgoCDNamespace\n\tapp1.Spec.Destination.Server = argoappv1.KubernetesInternalAPIServerAddr\n\n\tapp2 := newFakeApp()\n\tapp2.Name = \"app2\"\n\tapp2.Spec.Destination.Namespace = test.FakeArgoCDNamespace\n\tapp2.Spec.Destination.Server = argoappv1.KubernetesInternalAPIServerAddr\n\n\tproj := defaultProj.DeepCopy()\n\tproj.Spec.OrphanedResources = &argoappv1.OrphanedResourcesMonitorSettings{}\n\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app1, app2, proj}})\n\n\tctrl.handleObjectUpdated(map[string]bool{}, corev1.ObjectReference{UID: \"test\", Kind: kube.DeploymentKind, Name: \"test\", Namespace: test.FakeArgoCDNamespace})\n\n\tisRequested, level := ctrl.isRefreshRequested(app1.Name)\n\tassert.True(t, isRequested)\n\tassert.Equal(t, CompareWithRecent, level)\n\n\tisRequested, level = ctrl.isRefreshRequested(app2.Name)\n\tassert.True(t, isRequested)\n\tassert.Equal(t, CompareWithRecent, level)\n}\n\nfunc TestGetResourceTree_HasOrphanedResources(t *testing.T) {\n\tapp := newFakeApp()\n\tproj := defaultProj.DeepCopy()\n\tproj.Spec.OrphanedResources = &argoappv1.OrphanedResourcesMonitorSettings{}\n\n\tmanagedDeploy := argoappv1.ResourceNode{\n\t\tResourceRef: argoappv1.ResourceRef{Group: \"apps\", Kind: \"Deployment\", Namespace: \"default\", Name: \"nginx-deployment\", Version: \"v1\"},\n\t}\n\torphanedDeploy1 := argoappv1.ResourceNode{\n\t\tResourceRef: argoappv1.ResourceRef{Group: \"apps\", Kind: \"Deployment\", Namespace: \"default\", Name: \"deploy1\"},\n\t}\n\torphanedDeploy2 := argoappv1.ResourceNode{\n\t\tResourceRef: argoappv1.ResourceRef{Group: \"apps\", Kind: \"Deployment\", Namespace: \"default\", Name: \"deploy2\"},\n\t}\n\n\tctrl := newFakeController(&fakeData{\n\t\tapps: []runtime.Object{app, proj},\n\t\tnamespacedResources: map[kube.ResourceKey]namespacedResource{\n\t\t\tkube.NewResourceKey(\"apps\", \"Deployment\", \"default\", \"nginx-deployment\"): {ResourceNode: managedDeploy},\n\t\t\tkube.NewResourceKey(\"apps\", \"Deployment\", \"default\", \"deploy1\"):          {ResourceNode: orphanedDeploy1},\n\t\t\tkube.NewResourceKey(\"apps\", \"Deployment\", \"default\", \"deploy2\"):          {ResourceNode: orphanedDeploy2},\n\t\t},\n\t})\n\ttree, err := ctrl.getResourceTree(app, []*argoappv1.ResourceDiff{{\n\t\tNamespace:   \"default\",\n\t\tName:        \"nginx-deployment\",\n\t\tKind:        \"Deployment\",\n\t\tGroup:       \"apps\",\n\t\tLiveState:   \"null\",\n\t\tTargetState: test.DeploymentManifest,\n\t}})\n\n\tassert.NoError(t, err)\n\tassert.Equal(t, tree.Nodes, []argoappv1.ResourceNode{managedDeploy})\n\tassert.Equal(t, tree.OrphanedNodes, []argoappv1.ResourceNode{orphanedDeploy1, orphanedDeploy2})\n}\n\nfunc TestSetOperationStateOnDeletedApp(t *testing.T) {\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{}})\n\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\tfakeAppCs.ReactionChain = nil\n\tpatched := false\n\tfakeAppCs.AddReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\tpatched = true\n\t\treturn true, nil, apierr.NewNotFound(schema.GroupResource{}, \"my-app\")\n\t})\n\tctrl.setOperationState(newFakeApp(), &argoappv1.OperationState{Phase: synccommon.OperationSucceeded})\n\tassert.True(t, patched)\n}\n\nfunc TestNeedRefreshAppStatus(t *testing.T) {\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{}})\n\n\tapp := newFakeApp()\n\tnow := metav1.Now()\n\tapp.Status.ReconciledAt = &now\n\tapp.Status.Sync = argoappv1.SyncStatus{\n\t\tStatus: argoappv1.SyncStatusCodeSynced,\n\t\tComparedTo: argoappv1.ComparedTo{\n\t\t\tSource:      app.Spec.Source,\n\t\t\tDestination: app.Spec.Destination,\n\t\t},\n\t}\n\n\t// no need to refresh just reconciled application\n\tneedRefresh, _, _ := ctrl.needRefreshAppStatus(app, 1*time.Hour)\n\tassert.False(t, needRefresh)\n\n\t// refresh app using the 'deepest' requested comparison level\n\tctrl.requestAppRefresh(app.Name, CompareWithRecent.Pointer(), nil)\n\tctrl.requestAppRefresh(app.Name, ComparisonWithNothing.Pointer(), nil)\n\n\tneedRefresh, refreshType, compareWith := ctrl.needRefreshAppStatus(app, 1*time.Hour)\n\tassert.True(t, needRefresh)\n\tassert.Equal(t, argoappv1.RefreshTypeNormal, refreshType)\n\tassert.Equal(t, CompareWithRecent, compareWith)\n\n\t// refresh application which status is not reconciled using latest commit\n\tapp.Status.Sync = argoappv1.SyncStatus{Status: argoappv1.SyncStatusCodeUnknown}\n\n\tneedRefresh, refreshType, compareWith = ctrl.needRefreshAppStatus(app, 1*time.Hour)\n\tassert.True(t, needRefresh)\n\tassert.Equal(t, argoappv1.RefreshTypeNormal, refreshType)\n\tassert.Equal(t, CompareWithLatestForceResolve, compareWith)\n\n\t{\n\t\t// refresh app using the 'latest' level if comparison expired\n\t\tapp := app.DeepCopy()\n\t\tctrl.requestAppRefresh(app.Name, CompareWithRecent.Pointer(), nil)\n\t\treconciledAt := metav1.NewTime(time.Now().UTC().Add(-1 * time.Hour))\n\t\tapp.Status.ReconciledAt = &reconciledAt\n\t\tneedRefresh, refreshType, compareWith = ctrl.needRefreshAppStatus(app, 1*time.Minute)\n\t\tassert.True(t, needRefresh)\n\t\tassert.Equal(t, argoappv1.RefreshTypeNormal, refreshType)\n\t\tassert.Equal(t, CompareWithLatestForceResolve, compareWith)\n\t}\n\n\t{\n\t\tapp := app.DeepCopy()\n\t\t// execute hard refresh if app has refresh annotation\n\t\treconciledAt := metav1.NewTime(time.Now().UTC().Add(-1 * time.Hour))\n\t\tapp.Status.ReconciledAt = &reconciledAt\n\t\tapp.Annotations = map[string]string{\n\t\t\tv1alpha1.AnnotationKeyRefresh: string(argoappv1.RefreshTypeHard),\n\t\t}\n\t\tneedRefresh, refreshType, compareWith = ctrl.needRefreshAppStatus(app, 1*time.Hour)\n\t\tassert.True(t, needRefresh)\n\t\tassert.Equal(t, argoappv1.RefreshTypeHard, refreshType)\n\t\tassert.Equal(t, CompareWithLatestForceResolve, compareWith)\n\t}\n\n\t{\n\t\tapp := app.DeepCopy()\n\t\t// ensure that CompareWithLatest level is used if application source has changed\n\t\tctrl.requestAppRefresh(app.Name, ComparisonWithNothing.Pointer(), nil)\n\t\t// sample app source change\n\t\tapp.Spec.Source.Helm = &argoappv1.ApplicationSourceHelm{\n\t\t\tParameters: []argoappv1.HelmParameter{{\n\t\t\t\tName:  \"foo\",\n\t\t\t\tValue: \"bar\",\n\t\t\t}},\n\t\t}\n\n\t\tneedRefresh, refreshType, compareWith = ctrl.needRefreshAppStatus(app, 1*time.Hour)\n\t\tassert.True(t, needRefresh)\n\t\tassert.Equal(t, argoappv1.RefreshTypeNormal, refreshType)\n\t\tassert.Equal(t, CompareWithLatestForceResolve, compareWith)\n\t}\n}\n\nfunc TestRefreshAppConditions(t *testing.T) {\n\tdefaultProj := argoappv1.AppProject{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"default\",\n\t\t\tNamespace: test.FakeArgoCDNamespace,\n\t\t},\n\t\tSpec: argoappv1.AppProjectSpec{\n\t\t\tSourceRepos: []string{\"*\"},\n\t\t\tDestinations: []argoappv1.ApplicationDestination{\n\t\t\t\t{\n\t\t\t\t\tServer:    \"*\",\n\t\t\t\t\tNamespace: \"*\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tt.Run(\"NoErrorConditions\", func(t *testing.T) {\n\t\tapp := newFakeApp()\n\t\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app, &defaultProj}})\n\n\t\t_, hasErrors := ctrl.refreshAppConditions(app)\n\t\tassert.False(t, hasErrors)\n\t\tassert.Len(t, app.Status.Conditions, 0)\n\t})\n\n\tt.Run(\"PreserveExistingWarningCondition\", func(t *testing.T) {\n\t\tapp := newFakeApp()\n\t\tapp.Status.SetConditions([]argoappv1.ApplicationCondition{{Type: argoappv1.ApplicationConditionExcludedResourceWarning}}, nil)\n\n\t\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app, &defaultProj}})\n\n\t\t_, hasErrors := ctrl.refreshAppConditions(app)\n\t\tassert.False(t, hasErrors)\n\t\tassert.Len(t, app.Status.Conditions, 1)\n\t\tassert.Equal(t, argoappv1.ApplicationConditionExcludedResourceWarning, app.Status.Conditions[0].Type)\n\t})\n\n\tt.Run(\"ReplacesSpecErrorCondition\", func(t *testing.T) {\n\t\tapp := newFakeApp()\n\t\tapp.Spec.Project = \"wrong project\"\n\t\tapp.Status.SetConditions([]argoappv1.ApplicationCondition{{Type: argoappv1.ApplicationConditionInvalidSpecError, Message: \"old message\"}}, nil)\n\n\t\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app, &defaultProj}})\n\n\t\t_, hasErrors := ctrl.refreshAppConditions(app)\n\t\tassert.True(t, hasErrors)\n\t\tassert.Len(t, app.Status.Conditions, 1)\n\t\tassert.Equal(t, argoappv1.ApplicationConditionInvalidSpecError, app.Status.Conditions[0].Type)\n\t\tassert.Equal(t, \"Application referencing project wrong project which does not exist\", app.Status.Conditions[0].Message)\n\t})\n}\n\nfunc TestUpdateReconciledAt(t *testing.T) {\n\tapp := newFakeApp()\n\treconciledAt := metav1.NewTime(time.Now().Add(-1 * time.Second))\n\tapp.Status = argoappv1.ApplicationStatus{ReconciledAt: &reconciledAt}\n\tapp.Status.Sync = argoappv1.SyncStatus{ComparedTo: argoappv1.ComparedTo{Source: app.Spec.Source, Destination: app.Spec.Destination}}\n\tctrl := newFakeController(&fakeData{\n\t\tapps: []runtime.Object{app, &defaultProj},\n\t\tmanifestResponse: &apiclient.ManifestResponse{\n\t\t\tManifests: []string{},\n\t\t\tNamespace: test.FakeDestNamespace,\n\t\t\tServer:    test.FakeClusterURL,\n\t\t\tRevision:  \"abc123\",\n\t\t},\n\t\tmanagedLiveObjs: make(map[kube.ResourceKey]*unstructured.Unstructured),\n\t})\n\tkey, _ := cache.MetaNamespaceKeyFunc(app)\n\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\tfakeAppCs.ReactionChain = nil\n\treceivedPatch := map[string]interface{}{}\n\tfakeAppCs.AddReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\tif patchAction, ok := action.(kubetesting.PatchAction); ok {\n\t\t\tassert.NoError(t, json.Unmarshal(patchAction.GetPatch(), &receivedPatch))\n\t\t}\n\t\treturn true, nil, nil\n\t})\n\n\tt.Run(\"UpdatedOnFullReconciliation\", func(t *testing.T) {\n\t\treceivedPatch = map[string]interface{}{}\n\t\tctrl.requestAppRefresh(app.Name, CompareWithLatest.Pointer(), nil)\n\t\tctrl.appRefreshQueue.Add(key)\n\n\t\tctrl.processAppRefreshQueueItem()\n\n\t\t_, updated, err := unstructured.NestedString(receivedPatch, \"status\", \"reconciledAt\")\n\t\tassert.NoError(t, err)\n\t\tassert.True(t, updated)\n\n\t\t_, updated, err = unstructured.NestedString(receivedPatch, \"status\", \"observedAt\")\n\t\tassert.NoError(t, err)\n\t\tassert.False(t, updated)\n\t})\n\n\tt.Run(\"NotUpdatedOnPartialReconciliation\", func(t *testing.T) {\n\t\treceivedPatch = map[string]interface{}{}\n\t\tctrl.appRefreshQueue.Add(key)\n\t\tctrl.requestAppRefresh(app.Name, CompareWithRecent.Pointer(), nil)\n\n\t\tctrl.processAppRefreshQueueItem()\n\n\t\t_, updated, err := unstructured.NestedString(receivedPatch, \"status\", \"reconciledAt\")\n\t\tassert.NoError(t, err)\n\t\tassert.False(t, updated)\n\n\t\t_, updated, err = unstructured.NestedString(receivedPatch, \"status\", \"observedAt\")\n\t\tassert.NoError(t, err)\n\t\tassert.False(t, updated)\n\t})\n\n}\n\nfunc TestFinalizeProjectDeletion_HasApplications(t *testing.T) {\n\tapp := newFakeApp()\n\tproj := &argoappv1.AppProject{ObjectMeta: metav1.ObjectMeta{Name: \"default\", Namespace: test.FakeArgoCDNamespace}}\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app, proj}})\n\n\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\tpatched := false\n\tfakeAppCs.PrependReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\tpatched = true\n\t\treturn true, nil, nil\n\t})\n\n\terr := ctrl.finalizeProjectDeletion(proj)\n\tassert.NoError(t, err)\n\tassert.False(t, patched)\n}\n\nfunc TestFinalizeProjectDeletion_DoesNotHaveApplications(t *testing.T) {\n\tproj := &argoappv1.AppProject{ObjectMeta: metav1.ObjectMeta{Name: \"default\", Namespace: test.FakeArgoCDNamespace}}\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{&defaultProj}})\n\n\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\treceivedPatch := map[string]interface{}{}\n\tfakeAppCs.PrependReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\tif patchAction, ok := action.(kubetesting.PatchAction); ok {\n\t\t\tassert.NoError(t, json.Unmarshal(patchAction.GetPatch(), &receivedPatch))\n\t\t}\n\t\treturn true, nil, nil\n\t})\n\n\terr := ctrl.finalizeProjectDeletion(proj)\n\tassert.NoError(t, err)\n\tassert.Equal(t, map[string]interface{}{\n\t\t\"metadata\": map[string]interface{}{\n\t\t\t\"finalizers\": nil,\n\t\t},\n\t}, receivedPatch)\n}\n\nfunc TestProcessRequestedAppOperation_FailedNoRetries(t *testing.T) {\n\tapp := newFakeApp()\n\tapp.Spec.Project = \"invalid-project\"\n\tapp.Operation = &argoappv1.Operation{\n\t\tSync: &argoappv1.SyncOperation{},\n\t}\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\treceivedPatch := map[string]interface{}{}\n\tfakeAppCs.PrependReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\tif patchAction, ok := action.(kubetesting.PatchAction); ok {\n\t\t\tassert.NoError(t, json.Unmarshal(patchAction.GetPatch(), &receivedPatch))\n\t\t}\n\t\treturn true, nil, nil\n\t})\n\n\tctrl.processRequestedAppOperation(app)\n\n\tphase, _, _ := unstructured.NestedString(receivedPatch, \"status\", \"operationState\", \"phase\")\n\tassert.Equal(t, string(synccommon.OperationError), phase)\n}\n\nfunc TestProcessRequestedAppOperation_InvalidDestination(t *testing.T) {\n\tapp := newFakeAppWithDestMismatch()\n\tapp.Spec.Project = \"test-project\"\n\tapp.Operation = &argoappv1.Operation{\n\t\tSync: &argoappv1.SyncOperation{},\n\t}\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\treceivedPatch := map[string]interface{}{}\n\tfunc() {\n\t\tfakeAppCs.Lock()\n\t\tdefer fakeAppCs.Unlock()\n\t\tfakeAppCs.PrependReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\t\tif patchAction, ok := action.(kubetesting.PatchAction); ok {\n\t\t\t\tassert.NoError(t, json.Unmarshal(patchAction.GetPatch(), &receivedPatch))\n\t\t\t}\n\t\t\treturn true, nil, nil\n\t\t})\n\t}()\n\n\tctrl.processRequestedAppOperation(app)\n\n\tphase, _, _ := unstructured.NestedString(receivedPatch, \"status\", \"operationState\", \"phase\")\n\tassert.Equal(t, string(synccommon.OperationFailed), phase)\n\tmessage, _, _ := unstructured.NestedString(receivedPatch, \"status\", \"operationState\", \"message\")\n\tassert.Contains(t, message, \"application destination can't have both name and server defined: another-cluster https://localhost:6443\")\n}\n\nfunc TestProcessRequestedAppOperation_FailedHasRetries(t *testing.T) {\n\tapp := newFakeApp()\n\tapp.Spec.Project = \"invalid-project\"\n\tapp.Operation = &argoappv1.Operation{\n\t\tSync:  &argoappv1.SyncOperation{},\n\t\tRetry: argoappv1.RetryStrategy{Limit: 1},\n\t}\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\treceivedPatch := map[string]interface{}{}\n\tfakeAppCs.PrependReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\tif patchAction, ok := action.(kubetesting.PatchAction); ok {\n\t\t\tassert.NoError(t, json.Unmarshal(patchAction.GetPatch(), &receivedPatch))\n\t\t}\n\t\treturn true, nil, nil\n\t})\n\n\tctrl.processRequestedAppOperation(app)\n\n\tphase, _, _ := unstructured.NestedString(receivedPatch, \"status\", \"operationState\", \"phase\")\n\tassert.Equal(t, string(synccommon.OperationRunning), phase)\n\tmessage, _, _ := unstructured.NestedString(receivedPatch, \"status\", \"operationState\", \"message\")\n\tassert.Contains(t, message, \"Retrying attempt #1\")\n\tretryCount, _, _ := unstructured.NestedFloat64(receivedPatch, \"status\", \"operationState\", \"retryCount\")\n\tassert.Equal(t, float64(1), retryCount)\n}\n\nfunc TestProcessRequestedAppOperation_RunningPreviouslyFailed(t *testing.T) {\n\tapp := newFakeApp()\n\tapp.Operation = &argoappv1.Operation{\n\t\tSync:  &argoappv1.SyncOperation{},\n\t\tRetry: argoappv1.RetryStrategy{Limit: 1},\n\t}\n\tapp.Status.OperationState.Phase = synccommon.OperationRunning\n\tapp.Status.OperationState.SyncResult.Resources = []*argoappv1.ResourceResult{{\n\t\tName:   \"guestbook\",\n\t\tKind:   \"Deployment\",\n\t\tGroup:  \"apps\",\n\t\tStatus: synccommon.ResultCodeSyncFailed,\n\t}}\n\n\tdata := &fakeData{\n\t\tapps: []runtime.Object{app, &defaultProj},\n\t\tmanifestResponse: &apiclient.ManifestResponse{\n\t\t\tManifests: []string{},\n\t\t\tNamespace: test.FakeDestNamespace,\n\t\t\tServer:    test.FakeClusterURL,\n\t\t\tRevision:  \"abc123\",\n\t\t},\n\t}\n\tctrl := newFakeController(data)\n\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\treceivedPatch := map[string]interface{}{}\n\tfakeAppCs.PrependReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\tif patchAction, ok := action.(kubetesting.PatchAction); ok {\n\t\t\tassert.NoError(t, json.Unmarshal(patchAction.GetPatch(), &receivedPatch))\n\t\t}\n\t\treturn true, nil, nil\n\t})\n\n\tctrl.processRequestedAppOperation(app)\n\n\tphase, _, _ := unstructured.NestedString(receivedPatch, \"status\", \"operationState\", \"phase\")\n\tassert.Equal(t, string(synccommon.OperationSucceeded), phase)\n}\n\nfunc TestProcessRequestedAppOperation_HasRetriesTerminated(t *testing.T) {\n\tapp := newFakeApp()\n\tapp.Operation = &argoappv1.Operation{\n\t\tSync:  &argoappv1.SyncOperation{},\n\t\tRetry: argoappv1.RetryStrategy{Limit: 10},\n\t}\n\tapp.Status.OperationState.Phase = synccommon.OperationTerminating\n\n\tdata := &fakeData{\n\t\tapps: []runtime.Object{app, &defaultProj},\n\t\tmanifestResponse: &apiclient.ManifestResponse{\n\t\t\tManifests: []string{},\n\t\t\tNamespace: test.FakeDestNamespace,\n\t\t\tServer:    test.FakeClusterURL,\n\t\t\tRevision:  \"abc123\",\n\t\t},\n\t}\n\tctrl := newFakeController(data)\n\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\treceivedPatch := map[string]interface{}{}\n\tfakeAppCs.PrependReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\tif patchAction, ok := action.(kubetesting.PatchAction); ok {\n\t\t\tassert.NoError(t, json.Unmarshal(patchAction.GetPatch(), &receivedPatch))\n\t\t}\n\t\treturn true, nil, nil\n\t})\n\n\tctrl.processRequestedAppOperation(app)\n\n\tphase, _, _ := unstructured.NestedString(receivedPatch, \"status\", \"operationState\", \"phase\")\n\tassert.Equal(t, string(synccommon.OperationFailed), phase)\n}\n\nfunc TestGetAppHosts(t *testing.T) {\n\tapp := newFakeApp()\n\tdata := &fakeData{\n\t\tapps: []runtime.Object{app, &defaultProj},\n\t\tmanifestResponse: &apiclient.ManifestResponse{\n\t\t\tManifests: []string{},\n\t\t\tNamespace: test.FakeDestNamespace,\n\t\t\tServer:    test.FakeClusterURL,\n\t\t\tRevision:  \"abc123\",\n\t\t},\n\t}\n\tctrl := newFakeController(data)\n\tmockStateCache := &mockstatecache.LiveStateCache{}\n\tmockStateCache.On(\"IterateResources\", mock.Anything, mock.MatchedBy(func(callback func(res *clustercache.Resource, info *statecache.ResourceInfo)) bool {\n\t\t// node resource\n\t\tcallback(&clustercache.Resource{\n\t\t\tRef: corev1.ObjectReference{Name: \"minikube\", Kind: \"Node\", APIVersion: \"v1\"},\n\t\t}, &statecache.ResourceInfo{NodeInfo: &statecache.NodeInfo{\n\t\t\tName:       \"minikube\",\n\t\t\tSystemInfo: corev1.NodeSystemInfo{OSImage: \"debian\"},\n\t\t\tCapacity:   map[corev1.ResourceName]resource.Quantity{corev1.ResourceCPU: resource.MustParse(\"5\")},\n\t\t}})\n\n\t\t// app pod\n\t\tcallback(&clustercache.Resource{\n\t\t\tRef: corev1.ObjectReference{Name: \"pod1\", Kind: kube.PodKind, APIVersion: \"v1\", Namespace: \"default\"},\n\t\t}, &statecache.ResourceInfo{PodInfo: &statecache.PodInfo{\n\t\t\tNodeName:         \"minikube\",\n\t\t\tResourceRequests: map[corev1.ResourceName]resource.Quantity{corev1.ResourceCPU: resource.MustParse(\"1\")},\n\t\t}})\n\t\t// neighbor pod\n\t\tcallback(&clustercache.Resource{\n\t\t\tRef: corev1.ObjectReference{Name: \"pod2\", Kind: kube.PodKind, APIVersion: \"v1\", Namespace: \"default\"},\n\t\t}, &statecache.ResourceInfo{PodInfo: &statecache.PodInfo{\n\t\t\tNodeName:         \"minikube\",\n\t\t\tResourceRequests: map[corev1.ResourceName]resource.Quantity{corev1.ResourceCPU: resource.MustParse(\"2\")},\n\t\t}})\n\t\treturn true\n\t})).Return(nil)\n\tctrl.stateCache = mockStateCache\n\n\thosts, err := ctrl.getAppHosts(app, []argoappv1.ResourceNode{{\n\t\tResourceRef: argoappv1.ResourceRef{Name: \"pod1\", Namespace: \"default\", Kind: kube.PodKind},\n\t\tInfo: []argoappv1.InfoItem{{\n\t\t\tName:  \"Host\",\n\t\t\tValue: \"Minikube\",\n\t\t}},\n\t}})\n\n\tassert.NoError(t, err)\n\tassert.Equal(t, []argoappv1.HostInfo{{\n\t\tName:       \"minikube\",\n\t\tSystemInfo: corev1.NodeSystemInfo{OSImage: \"debian\"},\n\t\tResourcesInfo: []argoappv1.HostResourceInfo{{\n\t\t\tResourceName: corev1.ResourceCPU, Capacity: 5000, RequestedByApp: 1000, RequestedByNeighbors: 2000},\n\t\t}}}, hosts)\n}\n\nfunc TestMetricsExpiration(t *testing.T) {\n\tapp := newFakeApp()\n\t// Check expiration is disabled by default\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\tassert.False(t, ctrl.metricsServer.HasExpiration())\n\t// Check expiration is enabled if set\n\tctrl = newFakeController(&fakeData{apps: []runtime.Object{app}, metricsCacheExpiration: 10 * time.Second})\n\tassert.True(t, ctrl.metricsServer.HasExpiration())\n}\n", "package cache\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"net\"\n\t\"net/url\"\n\t\"os/exec\"\n\t\"reflect\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\n\tclustercache \"github.com/argoproj/gitops-engine/pkg/cache\"\n\t\"github.com/argoproj/gitops-engine/pkg/health\"\n\t\"github.com/argoproj/gitops-engine/pkg/utils/kube\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"golang.org/x/sync/semaphore\"\n\tv1 \"k8s.io/api/core/v1\"\n\tkerrors \"k8s.io/apimachinery/pkg/api/errors\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\n\t\"k8s.io/apimachinery/pkg/runtime/schema\"\n\t\"k8s.io/apimachinery/pkg/watch\"\n\t\"k8s.io/client-go/tools/cache\"\n\n\t\"github.com/argoproj/argo-cd/v2/controller/metrics\"\n\tappv1 \"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1\"\n\t\"github.com/argoproj/argo-cd/v2/util/argo\"\n\t\"github.com/argoproj/argo-cd/v2/util/db\"\n\t\"github.com/argoproj/argo-cd/v2/util/env\"\n\tlogutils \"github.com/argoproj/argo-cd/v2/util/log\"\n\t\"github.com/argoproj/argo-cd/v2/util/lua\"\n\t\"github.com/argoproj/argo-cd/v2/util/settings\"\n)\n\nconst (\n\t// EnvClusterCacheResyncDuration is the env variable that holds cluster cache re-sync duration\n\tEnvClusterCacheResyncDuration = \"ARGOCD_CLUSTER_CACHE_RESYNC_DURATION\"\n\n\t// EnvClusterCacheWatchResyncDuration is the env variable that holds cluster cache watch re-sync duration\n\tEnvClusterCacheWatchResyncDuration = \"ARGOCD_CLUSTER_CACHE_WATCH_RESYNC_DURATION\"\n\n\t// EnvClusterRetryTimeoutDuration is the env variable that holds cluster retry duration when sync error happens\n\tEnvClusterSyncRetryTimeoutDuration = \"ARGOCD_CLUSTER_SYNC_RETRY_TIMEOUT_DURATION\"\n\n\t// EnvClusterCacheListPageSize is the env variable to control size of the list page size when making K8s queries\n\tEnvClusterCacheListPageSize = \"ARGOCD_CLUSTER_CACHE_LIST_PAGE_SIZE\"\n\n\t// EnvClusterCacheListSemaphore is the env variable to control size of the list semaphore\n\t// This is used to limit the number of concurrent memory consuming operations on the\n\t// k8s list queries results across all clusters to avoid memory spikes during cache initialization.\n\tEnvClusterCacheListSemaphore = \"ARGOCD_CLUSTER_CACHE_LIST_SEMAPHORE\"\n\n\t// EnvClusterCacheRetryLimit is the env variable to control the retry limit for listing resources during cluster cache sync\n\tEnvClusterCacheAttemptLimit = \"ARGOCD_CLUSTER_CACHE_ATTEMPT_LIMIT\"\n\n\t// EnvClusterCacheRetryUseBackoff is the env variable to control whether to use a backoff strategy with the retry during cluster cache sync\n\tEnvClusterCacheRetryUseBackoff = \"ARGOCD_CLUSTER_CACHE_RETRY_USE_BACKOFF\"\n)\n\n// GitOps engine cluster cache tuning options\nvar (\n\t// clusterCacheResyncDuration controls the duration of cluster cache refresh.\n\t// NOTE: this differs from gitops-engine default of 24h\n\tclusterCacheResyncDuration = 12 * time.Hour\n\n\t// clusterCacheWatchResyncDuration controls the maximum duration that group/kind watches are allowed to run\n\t// for before relisting & restarting the watch\n\tclusterCacheWatchResyncDuration = 10 * time.Minute\n\n\t// clusterSyncRetryTimeoutDuration controls the sync retry duration when cluster sync error happens\n\tclusterSyncRetryTimeoutDuration = 10 * time.Second\n\n\t// The default limit of 50 is chosen based on experiments.\n\tclusterCacheListSemaphoreSize int64 = 50\n\n\t// clusterCacheListPageSize is the page size when performing K8s list requests.\n\t// 500 is equal to kubectl's size\n\tclusterCacheListPageSize int64 = 500\n\n\t// clusterCacheRetryLimit sets a retry limit for failed requests during cluster cache sync\n\t// If set to 1, retries are disabled.\n\tclusterCacheAttemptLimit int32 = 1\n\n\t// clusterCacheRetryUseBackoff specifies whether to use a backoff strategy on cluster cache sync, if retry is enabled\n\tclusterCacheRetryUseBackoff bool = false\n)\n\nfunc init() {\n\tclusterCacheResyncDuration = env.ParseDurationFromEnv(EnvClusterCacheResyncDuration, clusterCacheResyncDuration, 0, math.MaxInt64)\n\tclusterCacheWatchResyncDuration = env.ParseDurationFromEnv(EnvClusterCacheWatchResyncDuration, clusterCacheWatchResyncDuration, 0, math.MaxInt64)\n\tclusterSyncRetryTimeoutDuration = env.ParseDurationFromEnv(EnvClusterSyncRetryTimeoutDuration, clusterSyncRetryTimeoutDuration, 0, math.MaxInt64)\n\tclusterCacheListPageSize = env.ParseInt64FromEnv(EnvClusterCacheListPageSize, clusterCacheListPageSize, 0, math.MaxInt64)\n\tclusterCacheListSemaphoreSize = env.ParseInt64FromEnv(EnvClusterCacheListSemaphore, clusterCacheListSemaphoreSize, 0, math.MaxInt64)\n\tclusterCacheAttemptLimit = int32(env.ParseInt64FromEnv(EnvClusterCacheAttemptLimit, 1, 1, math.MaxInt32))\n\tclusterCacheRetryUseBackoff = env.ParseBoolFromEnv(EnvClusterCacheRetryUseBackoff, false)\n}\n\ntype LiveStateCache interface {\n\t// Returns k8s server version\n\tGetVersionsInfo(serverURL string) (string, []kube.APIResourceInfo, error)\n\t// Returns true of given group kind is a namespaced resource\n\tIsNamespaced(server string, gk schema.GroupKind) (bool, error)\n\t// Returns synced cluster cache\n\tGetClusterCache(server string) (clustercache.ClusterCache, error)\n\t// Executes give callback against resource specified by the key and all its children\n\tIterateHierarchy(server string, key kube.ResourceKey, action func(child appv1.ResourceNode, appName string)) error\n\t// Returns state of live nodes which correspond for target nodes of specified application.\n\tGetManagedLiveObjs(a *appv1.Application, targetObjs []*unstructured.Unstructured) (map[kube.ResourceKey]*unstructured.Unstructured, error)\n\t// IterateResources iterates all resource stored in cache\n\tIterateResources(server string, callback func(res *clustercache.Resource, info *ResourceInfo)) error\n\t// Returns all top level resources (resources without owner references) of a specified namespace\n\tGetNamespaceTopLevelResources(server string, namespace string) (map[kube.ResourceKey]appv1.ResourceNode, error)\n\t// Starts watching resources of each controlled cluster.\n\tRun(ctx context.Context) error\n\t// Returns information about monitored clusters\n\tGetClustersInfo() []clustercache.ClusterInfo\n\t// Init must be executed before cache can be used\n\tInit() error\n}\n\ntype ObjectUpdatedHandler = func(managedByApp map[string]bool, ref v1.ObjectReference)\n\ntype PodInfo struct {\n\tNodeName         string\n\tResourceRequests v1.ResourceList\n\tPhase            v1.PodPhase\n}\n\ntype NodeInfo struct {\n\tName       string\n\tCapacity   v1.ResourceList\n\tSystemInfo v1.NodeSystemInfo\n}\n\ntype ResourceInfo struct {\n\tInfo    []appv1.InfoItem\n\tAppName string\n\tImages  []string\n\tHealth  *health.HealthStatus\n\t// NetworkingInfo are available only for known types involved into networking: Ingress, Service, Pod\n\tNetworkingInfo *appv1.ResourceNetworkingInfo\n\t// PodInfo is available for pods only\n\tPodInfo *PodInfo\n\t// NodeInfo is available for nodes only\n\tNodeInfo *NodeInfo\n}\n\nfunc NewLiveStateCache(\n\tdb db.ArgoDB,\n\tappInformer cache.SharedIndexInformer,\n\tsettingsMgr *settings.SettingsManager,\n\tkubectl kube.Kubectl,\n\tmetricsServer *metrics.MetricsServer,\n\tonObjectUpdated ObjectUpdatedHandler,\n\tclusterFilter func(cluster *appv1.Cluster) bool,\n\tresourceTracking argo.ResourceTracking) LiveStateCache {\n\n\treturn &liveStateCache{\n\t\tappInformer:      appInformer,\n\t\tdb:               db,\n\t\tclusters:         make(map[string]clustercache.ClusterCache),\n\t\tonObjectUpdated:  onObjectUpdated,\n\t\tkubectl:          kubectl,\n\t\tsettingsMgr:      settingsMgr,\n\t\tmetricsServer:    metricsServer,\n\t\tclusterFilter:    clusterFilter,\n\t\tresourceTracking: resourceTracking,\n\t}\n}\n\ntype cacheSettings struct {\n\tclusterSettings     clustercache.Settings\n\tappInstanceLabelKey string\n}\n\ntype liveStateCache struct {\n\tdb               db.ArgoDB\n\tappInformer      cache.SharedIndexInformer\n\tonObjectUpdated  ObjectUpdatedHandler\n\tkubectl          kube.Kubectl\n\tsettingsMgr      *settings.SettingsManager\n\tmetricsServer    *metrics.MetricsServer\n\tclusterFilter    func(cluster *appv1.Cluster) bool\n\tresourceTracking argo.ResourceTracking\n\n\tclusters      map[string]clustercache.ClusterCache\n\tcacheSettings cacheSettings\n\tlock          sync.RWMutex\n}\n\nfunc (c *liveStateCache) loadCacheSettings() (*cacheSettings, error) {\n\tappInstanceLabelKey, err := c.settingsMgr.GetAppInstanceLabelKey()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresourcesFilter, err := c.settingsMgr.GetResourcesFilter()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresourceOverrides, err := c.settingsMgr.GetResourceOverrides()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclusterSettings := clustercache.Settings{\n\t\tResourceHealthOverride: lua.ResourceHealthOverrides(resourceOverrides),\n\t\tResourcesFilter:        resourcesFilter,\n\t}\n\treturn &cacheSettings{clusterSettings, appInstanceLabelKey}, nil\n}\n\nfunc asResourceNode(r *clustercache.Resource) appv1.ResourceNode {\n\tgv, err := schema.ParseGroupVersion(r.Ref.APIVersion)\n\tif err != nil {\n\t\tgv = schema.GroupVersion{}\n\t}\n\tparentRefs := make([]appv1.ResourceRef, len(r.OwnerRefs))\n\tfor _, ownerRef := range r.OwnerRefs {\n\t\townerGvk := schema.FromAPIVersionAndKind(ownerRef.APIVersion, ownerRef.Kind)\n\t\townerKey := kube.NewResourceKey(ownerGvk.Group, ownerRef.Kind, r.Ref.Namespace, ownerRef.Name)\n\t\tparentRefs[0] = appv1.ResourceRef{Name: ownerRef.Name, Kind: ownerKey.Kind, Namespace: r.Ref.Namespace, Group: ownerKey.Group, UID: string(ownerRef.UID)}\n\t}\n\tvar resHealth *appv1.HealthStatus\n\tresourceInfo := resInfo(r)\n\tif resourceInfo.Health != nil {\n\t\tresHealth = &appv1.HealthStatus{Status: resourceInfo.Health.Status, Message: resourceInfo.Health.Message}\n\t}\n\treturn appv1.ResourceNode{\n\t\tResourceRef: appv1.ResourceRef{\n\t\t\tUID:       string(r.Ref.UID),\n\t\t\tName:      r.Ref.Name,\n\t\t\tGroup:     gv.Group,\n\t\t\tVersion:   gv.Version,\n\t\t\tKind:      r.Ref.Kind,\n\t\t\tNamespace: r.Ref.Namespace,\n\t\t},\n\t\tParentRefs:      parentRefs,\n\t\tInfo:            resourceInfo.Info,\n\t\tResourceVersion: r.ResourceVersion,\n\t\tNetworkingInfo:  resourceInfo.NetworkingInfo,\n\t\tImages:          resourceInfo.Images,\n\t\tHealth:          resHealth,\n\t\tCreatedAt:       r.CreationTimestamp,\n\t}\n}\n\nfunc resInfo(r *clustercache.Resource) *ResourceInfo {\n\tinfo, ok := r.Info.(*ResourceInfo)\n\tif !ok || info == nil {\n\t\tinfo = &ResourceInfo{}\n\t}\n\treturn info\n}\n\nfunc isRootAppNode(r *clustercache.Resource) bool {\n\treturn resInfo(r).AppName != \"\" && len(r.OwnerRefs) == 0\n}\n\nfunc getApp(r *clustercache.Resource, ns map[kube.ResourceKey]*clustercache.Resource) string {\n\treturn getAppRecursive(r, ns, map[kube.ResourceKey]bool{})\n}\n\nfunc ownerRefGV(ownerRef metav1.OwnerReference) schema.GroupVersion {\n\tgv, err := schema.ParseGroupVersion(ownerRef.APIVersion)\n\tif err != nil {\n\t\tgv = schema.GroupVersion{}\n\t}\n\treturn gv\n}\n\nfunc getAppRecursive(r *clustercache.Resource, ns map[kube.ResourceKey]*clustercache.Resource, visited map[kube.ResourceKey]bool) string {\n\tif !visited[r.ResourceKey()] {\n\t\tvisited[r.ResourceKey()] = true\n\t} else {\n\t\tlog.Warnf(\"Circular dependency detected: %v.\", visited)\n\t\treturn resInfo(r).AppName\n\t}\n\n\tif resInfo(r).AppName != \"\" {\n\t\treturn resInfo(r).AppName\n\t}\n\tfor _, ownerRef := range r.OwnerRefs {\n\t\tgv := ownerRefGV(ownerRef)\n\t\tif parent, ok := ns[kube.NewResourceKey(gv.Group, ownerRef.Kind, r.Ref.Namespace, ownerRef.Name)]; ok {\n\t\t\tapp := getAppRecursive(parent, ns, visited)\n\t\t\tif app != \"\" {\n\t\t\t\treturn app\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\"\n}\n\nvar (\n\tignoredRefreshResources = map[string]bool{\n\t\t\"/\" + kube.EndpointsKind: true,\n\t}\n)\n\n// skipAppRequeuing checks if the object is an API type which we want to skip requeuing against.\n// We ignore API types which have a high churn rate, and/or whose updates are irrelevant to the app\nfunc skipAppRequeuing(key kube.ResourceKey) bool {\n\treturn ignoredRefreshResources[key.Group+\"/\"+key.Kind]\n}\n\n// isRetryableError is a helper method to see whether an error\n// returned from the dynamic client is potentially retryable.\nfunc isRetryableError(err error) bool {\n\tif err == nil {\n\t\treturn false\n\t}\n\treturn kerrors.IsInternalError(err) ||\n\t\tkerrors.IsInvalid(err) ||\n\t\tkerrors.IsTooManyRequests(err) ||\n\t\tkerrors.IsServerTimeout(err) ||\n\t\tkerrors.IsServiceUnavailable(err) ||\n\t\tkerrors.IsTimeout(err) ||\n\t\tkerrors.IsUnexpectedObjectError(err) ||\n\t\tkerrors.IsUnexpectedServerError(err) ||\n\t\tisResourceQuotaConflictErr(err) ||\n\t\tisTransientNetworkErr(err) ||\n\t\tisExceededQuotaErr(err) ||\n\t\terrors.Is(err, syscall.ECONNRESET)\n}\n\nfunc isExceededQuotaErr(err error) bool {\n\treturn kerrors.IsForbidden(err) && strings.Contains(err.Error(), \"exceeded quota\")\n}\n\nfunc isResourceQuotaConflictErr(err error) bool {\n\treturn kerrors.IsConflict(err) && strings.Contains(err.Error(), \"Operation cannot be fulfilled on resourcequota\")\n}\n\nfunc isTransientNetworkErr(err error) bool {\n\tswitch err.(type) {\n\tcase net.Error:\n\t\tswitch err.(type) {\n\t\tcase *net.DNSError, *net.OpError, net.UnknownNetworkError:\n\t\t\treturn true\n\t\tcase *url.Error:\n\t\t\t// For a URL error, where it replies \"connection closed\"\n\t\t\t// retry again.\n\t\t\treturn strings.Contains(err.Error(), \"Connection closed by foreign host\")\n\t\t}\n\t}\n\n\terrorString := err.Error()\n\tif exitErr, ok := err.(*exec.ExitError); ok {\n\t\terrorString = fmt.Sprintf(\"%s %s\", errorString, exitErr.Stderr)\n\t}\n\tif strings.Contains(errorString, \"net/http: TLS handshake timeout\") ||\n\t\tstrings.Contains(errorString, \"i/o timeout\") ||\n\t\tstrings.Contains(errorString, \"connection timed out\") {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (c *liveStateCache) getCluster(server string) (clustercache.ClusterCache, error) {\n\tc.lock.RLock()\n\tclusterCache, ok := c.clusters[server]\n\tcacheSettings := c.cacheSettings\n\tc.lock.RUnlock()\n\n\tif ok {\n\t\treturn clusterCache, nil\n\t}\n\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tclusterCache, ok = c.clusters[server]\n\tif ok {\n\t\treturn clusterCache, nil\n\t}\n\n\tcluster, err := c.db.GetCluster(context.Background(), server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif !c.canHandleCluster(cluster) {\n\t\treturn nil, fmt.Errorf(\"controller is configured to ignore cluster %s\", cluster.Server)\n\t}\n\n\ttrackingMethod := argo.GetTrackingMethod(c.settingsMgr)\n\tclusterCacheOpts := []clustercache.UpdateSettingsFunc{\n\t\tclustercache.SetListSemaphore(semaphore.NewWeighted(clusterCacheListSemaphoreSize)),\n\t\tclustercache.SetListPageSize(clusterCacheListPageSize),\n\t\tclustercache.SetWatchResyncTimeout(clusterCacheWatchResyncDuration),\n\t\tclustercache.SetClusterSyncRetryTimeout(clusterSyncRetryTimeoutDuration),\n\t\tclustercache.SetResyncTimeout(clusterCacheResyncDuration),\n\t\tclustercache.SetSettings(cacheSettings.clusterSettings),\n\t\tclustercache.SetNamespaces(cluster.Namespaces),\n\t\tclustercache.SetClusterResources(cluster.ClusterResources),\n\t\tclustercache.SetPopulateResourceInfoHandler(func(un *unstructured.Unstructured, isRoot bool) (interface{}, bool) {\n\t\t\tres := &ResourceInfo{}\n\t\t\tpopulateNodeInfo(un, res)\n\t\t\tres.Health, _ = health.GetResourceHealth(un, cacheSettings.clusterSettings.ResourceHealthOverride)\n\n\t\t\tappName := c.resourceTracking.GetAppName(un, cacheSettings.appInstanceLabelKey, trackingMethod)\n\t\t\tif isRoot && appName != \"\" {\n\t\t\t\tres.AppName = appName\n\t\t\t}\n\t\t\tgvk := un.GroupVersionKind()\n\n\t\t\t// edge case. we do not label CRDs, so they miss the tracking label we inject. But we still\n\t\t\t// want the full resource to be available in our cache (to diff), so we store all CRDs\n\t\t\treturn res, res.AppName != \"\" || gvk.Kind == kube.CustomResourceDefinitionKind\n\t\t}),\n\t\tclustercache.SetLogr(logutils.NewLogrusLogger(log.WithField(\"server\", cluster.Server))),\n\t\tclustercache.SetRetryOptions(clusterCacheAttemptLimit, clusterCacheRetryUseBackoff, isRetryableError),\n\t}\n\n\tclusterCache = clustercache.NewClusterCache(cluster.RESTConfig(), clusterCacheOpts...)\n\n\t_ = clusterCache.OnResourceUpdated(func(newRes *clustercache.Resource, oldRes *clustercache.Resource, namespaceResources map[kube.ResourceKey]*clustercache.Resource) {\n\t\ttoNotify := make(map[string]bool)\n\t\tvar ref v1.ObjectReference\n\t\tif newRes != nil {\n\t\t\tref = newRes.Ref\n\t\t} else {\n\t\t\tref = oldRes.Ref\n\t\t}\n\t\tfor _, r := range []*clustercache.Resource{newRes, oldRes} {\n\t\t\tif r == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tapp := getApp(r, namespaceResources)\n\t\t\tif app == \"\" || skipAppRequeuing(r.ResourceKey()) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ttoNotify[app] = isRootAppNode(r) || toNotify[app]\n\t\t}\n\t\tc.onObjectUpdated(toNotify, ref)\n\t})\n\n\t_ = clusterCache.OnEvent(func(event watch.EventType, un *unstructured.Unstructured) {\n\t\tgvk := un.GroupVersionKind()\n\t\tc.metricsServer.IncClusterEventsCount(cluster.Server, gvk.Group, gvk.Kind)\n\t})\n\n\tc.clusters[server] = clusterCache\n\n\treturn clusterCache, nil\n}\n\nfunc (c *liveStateCache) getSyncedCluster(server string) (clustercache.ClusterCache, error) {\n\tclusterCache, err := c.getCluster(server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = clusterCache.EnsureSynced()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn clusterCache, nil\n}\n\nfunc (c *liveStateCache) invalidate(cacheSettings cacheSettings) {\n\tlog.Info(\"invalidating live state cache\")\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tc.cacheSettings = cacheSettings\n\tfor _, clust := range c.clusters {\n\t\tclust.Invalidate(clustercache.SetSettings(cacheSettings.clusterSettings))\n\t}\n\tlog.Info(\"live state cache invalidated\")\n}\n\nfunc (c *liveStateCache) IsNamespaced(server string, gk schema.GroupKind) (bool, error) {\n\tclusterInfo, err := c.getSyncedCluster(server)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn clusterInfo.IsNamespaced(gk)\n}\n\nfunc (c *liveStateCache) IterateHierarchy(server string, key kube.ResourceKey, action func(child appv1.ResourceNode, appName string)) error {\n\tclusterInfo, err := c.getSyncedCluster(server)\n\tif err != nil {\n\t\treturn err\n\t}\n\tclusterInfo.IterateHierarchy(key, func(resource *clustercache.Resource, namespaceResources map[kube.ResourceKey]*clustercache.Resource) {\n\t\taction(asResourceNode(resource), getApp(resource, namespaceResources))\n\t})\n\treturn nil\n}\n\nfunc (c *liveStateCache) IterateResources(server string, callback func(res *clustercache.Resource, info *ResourceInfo)) error {\n\tclusterInfo, err := c.getSyncedCluster(server)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_ = clusterInfo.FindResources(\"\", func(r *clustercache.Resource) bool {\n\t\tif info, ok := r.Info.(*ResourceInfo); ok {\n\t\t\tcallback(r, info)\n\t\t}\n\t\treturn false\n\t})\n\treturn nil\n}\n\nfunc (c *liveStateCache) GetNamespaceTopLevelResources(server string, namespace string) (map[kube.ResourceKey]appv1.ResourceNode, error) {\n\tclusterInfo, err := c.getSyncedCluster(server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresources := clusterInfo.FindResources(namespace, clustercache.TopLevelResource)\n\tres := make(map[kube.ResourceKey]appv1.ResourceNode)\n\tfor k, r := range resources {\n\t\tres[k] = asResourceNode(r)\n\t}\n\treturn res, nil\n}\n\nfunc (c *liveStateCache) GetManagedLiveObjs(a *appv1.Application, targetObjs []*unstructured.Unstructured) (map[kube.ResourceKey]*unstructured.Unstructured, error) {\n\tclusterInfo, err := c.getSyncedCluster(a.Spec.Destination.Server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn clusterInfo.GetManagedLiveObjs(targetObjs, func(r *clustercache.Resource) bool {\n\t\treturn resInfo(r).AppName == a.Name\n\t})\n}\n\nfunc (c *liveStateCache) GetVersionsInfo(serverURL string) (string, []kube.APIResourceInfo, error) {\n\tclusterInfo, err := c.getSyncedCluster(serverURL)\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\treturn clusterInfo.GetServerVersion(), clusterInfo.GetAPIResources(), nil\n}\n\nfunc (c *liveStateCache) isClusterHasApps(apps []interface{}, cluster *appv1.Cluster) bool {\n\tfor _, obj := range apps {\n\t\tapp, ok := obj.(*appv1.Application)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\terr := argo.ValidateDestination(context.Background(), &app.Spec.Destination, c.db)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif app.Spec.Destination.Server == cluster.Server {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (c *liveStateCache) watchSettings(ctx context.Context) {\n\tupdateCh := make(chan *settings.ArgoCDSettings, 1)\n\tc.settingsMgr.Subscribe(updateCh)\n\n\tdone := false\n\tfor !done {\n\t\tselect {\n\t\tcase <-updateCh:\n\t\t\tnextCacheSettings, err := c.loadCacheSettings()\n\t\t\tif err != nil {\n\t\t\t\tlog.Warnf(\"Failed to read updated settings: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tc.lock.Lock()\n\t\t\tneedInvalidate := false\n\t\t\tif !reflect.DeepEqual(c.cacheSettings, *nextCacheSettings) {\n\t\t\t\tc.cacheSettings = *nextCacheSettings\n\t\t\t\tneedInvalidate = true\n\t\t\t}\n\t\t\tc.lock.Unlock()\n\t\t\tif needInvalidate {\n\t\t\t\tc.invalidate(*nextCacheSettings)\n\t\t\t}\n\t\tcase <-ctx.Done():\n\t\t\tdone = true\n\t\t}\n\t}\n\tlog.Info(\"shutting down settings watch\")\n\tc.settingsMgr.Unsubscribe(updateCh)\n\tclose(updateCh)\n}\n\nfunc (c *liveStateCache) Init() error {\n\tcacheSettings, err := c.loadCacheSettings()\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.cacheSettings = *cacheSettings\n\treturn nil\n}\n\n// Run watches for resource changes annotated with application label on all registered clusters and schedule corresponding app refresh.\nfunc (c *liveStateCache) Run(ctx context.Context) error {\n\tgo c.watchSettings(ctx)\n\n\tkube.RetryUntilSucceed(ctx, clustercache.ClusterRetryTimeout, \"watch clusters\", logutils.NewLogrusLogger(logutils.NewWithCurrentConfig()), func() error {\n\t\treturn c.db.WatchClusters(ctx, c.handleAddEvent, c.handleModEvent, c.handleDeleteEvent)\n\t})\n\n\t<-ctx.Done()\n\tc.invalidate(c.cacheSettings)\n\treturn nil\n}\n\nfunc (c *liveStateCache) canHandleCluster(cluster *appv1.Cluster) bool {\n\tif c.clusterFilter == nil {\n\t\treturn true\n\t}\n\treturn c.clusterFilter(cluster)\n}\n\nfunc (c *liveStateCache) handleAddEvent(cluster *appv1.Cluster) {\n\tif !c.canHandleCluster(cluster) {\n\t\tlog.Infof(\"Ignoring cluster %s\", cluster.Server)\n\t\treturn\n\t}\n\n\tc.lock.Lock()\n\t_, ok := c.clusters[cluster.Server]\n\tc.lock.Unlock()\n\tif !ok {\n\t\tif c.isClusterHasApps(c.appInformer.GetStore().List(), cluster) {\n\t\t\tgo func() {\n\t\t\t\t// warm up cache for cluster with apps\n\t\t\t\t_, _ = c.getSyncedCluster(cluster.Server)\n\t\t\t}()\n\t\t}\n\t}\n}\n\nfunc (c *liveStateCache) handleModEvent(oldCluster *appv1.Cluster, newCluster *appv1.Cluster) {\n\tc.lock.Lock()\n\tcluster, ok := c.clusters[newCluster.Server]\n\tc.lock.Unlock()\n\tif ok {\n\t\tif !c.canHandleCluster(newCluster) {\n\t\t\tcluster.Invalidate()\n\t\t\tc.lock.Lock()\n\t\t\tdelete(c.clusters, newCluster.Server)\n\t\t\tc.lock.Unlock()\n\t\t\treturn\n\t\t}\n\n\t\tvar updateSettings []clustercache.UpdateSettingsFunc\n\t\tif !reflect.DeepEqual(oldCluster.Config, newCluster.Config) {\n\t\t\tupdateSettings = append(updateSettings, clustercache.SetConfig(newCluster.RESTConfig()))\n\t\t}\n\t\tif !reflect.DeepEqual(oldCluster.Namespaces, newCluster.Namespaces) {\n\t\t\tupdateSettings = append(updateSettings, clustercache.SetNamespaces(newCluster.Namespaces))\n\t\t}\n\t\tif !reflect.DeepEqual(oldCluster.ClusterResources, newCluster.ClusterResources) {\n\t\t\tupdateSettings = append(updateSettings, clustercache.SetClusterResources(newCluster.ClusterResources))\n\t\t}\n\t\tforceInvalidate := false\n\t\tif newCluster.RefreshRequestedAt != nil &&\n\t\t\tcluster.GetClusterInfo().LastCacheSyncTime != nil &&\n\t\t\tcluster.GetClusterInfo().LastCacheSyncTime.Before(newCluster.RefreshRequestedAt.Time) {\n\t\t\tforceInvalidate = true\n\t\t}\n\n\t\tif len(updateSettings) > 0 || forceInvalidate {\n\t\t\tcluster.Invalidate(updateSettings...)\n\t\t\tgo func() {\n\t\t\t\t// warm up cluster cache\n\t\t\t\t_ = cluster.EnsureSynced()\n\t\t\t}()\n\t\t}\n\t}\n\n}\n\nfunc (c *liveStateCache) handleDeleteEvent(clusterServer string) {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\tcluster, ok := c.clusters[clusterServer]\n\tif ok {\n\t\tcluster.Invalidate()\n\t\tdelete(c.clusters, clusterServer)\n\t}\n}\n\nfunc (c *liveStateCache) GetClustersInfo() []clustercache.ClusterInfo {\n\tclusters := make(map[string]clustercache.ClusterCache)\n\tc.lock.RLock()\n\tfor k := range c.clusters {\n\t\tclusters[k] = c.clusters[k]\n\t}\n\tc.lock.RUnlock()\n\n\tres := make([]clustercache.ClusterInfo, 0)\n\tfor server, c := range clusters {\n\t\tinfo := c.GetClusterInfo()\n\t\tinfo.Server = server\n\t\tres = append(res, info)\n\t}\n\treturn res\n}\n\nfunc (c *liveStateCache) GetClusterCache(server string) (clustercache.ClusterCache, error) {\n\treturn c.getSyncedCluster(server)\n}\n", "// Code generated by mockery v1.0.0. DO NOT EDIT.\n\npackage mocks\n\nimport (\n\tcontext \"context\"\n\n\tcache \"github.com/argoproj/gitops-engine/pkg/cache\"\n\n\tcontrollercache \"github.com/argoproj/argo-cd/v2/controller/cache\"\n\n\tkube \"github.com/argoproj/gitops-engine/pkg/utils/kube\"\n\n\tmock \"github.com/stretchr/testify/mock\"\n\n\tschema \"k8s.io/apimachinery/pkg/runtime/schema\"\n\n\tunstructured \"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\n\n\tv1alpha1 \"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1\"\n)\n\n// LiveStateCache is an autogenerated mock type for the LiveStateCache type\ntype LiveStateCache struct {\n\tmock.Mock\n}\n\n// GetClusterCache provides a mock function with given fields: server\nfunc (_m *LiveStateCache) GetClusterCache(server string) (cache.ClusterCache, error) {\n\tret := _m.Called(server)\n\n\tvar r0 cache.ClusterCache\n\tif rf, ok := ret.Get(0).(func(string) cache.ClusterCache); ok {\n\t\tr0 = rf(server)\n\t} else {\n\t\tif ret.Get(0) != nil {\n\t\t\tr0 = ret.Get(0).(cache.ClusterCache)\n\t\t}\n\t}\n\n\tvar r1 error\n\tif rf, ok := ret.Get(1).(func(string) error); ok {\n\t\tr1 = rf(server)\n\t} else {\n\t\tr1 = ret.Error(1)\n\t}\n\n\treturn r0, r1\n}\n\n// GetClustersInfo provides a mock function with given fields:\nfunc (_m *LiveStateCache) GetClustersInfo() []cache.ClusterInfo {\n\tret := _m.Called()\n\n\tvar r0 []cache.ClusterInfo\n\tif rf, ok := ret.Get(0).(func() []cache.ClusterInfo); ok {\n\t\tr0 = rf()\n\t} else {\n\t\tif ret.Get(0) != nil {\n\t\t\tr0 = ret.Get(0).([]cache.ClusterInfo)\n\t\t}\n\t}\n\n\treturn r0\n}\n\n// GetManagedLiveObjs provides a mock function with given fields: a, targetObjs\nfunc (_m *LiveStateCache) GetManagedLiveObjs(a *v1alpha1.Application, targetObjs []*unstructured.Unstructured) (map[kube.ResourceKey]*unstructured.Unstructured, error) {\n\tret := _m.Called(a, targetObjs)\n\n\tvar r0 map[kube.ResourceKey]*unstructured.Unstructured\n\tif rf, ok := ret.Get(0).(func(*v1alpha1.Application, []*unstructured.Unstructured) map[kube.ResourceKey]*unstructured.Unstructured); ok {\n\t\tr0 = rf(a, targetObjs)\n\t} else {\n\t\tif ret.Get(0) != nil {\n\t\t\tr0 = ret.Get(0).(map[kube.ResourceKey]*unstructured.Unstructured)\n\t\t}\n\t}\n\n\tvar r1 error\n\tif rf, ok := ret.Get(1).(func(*v1alpha1.Application, []*unstructured.Unstructured) error); ok {\n\t\tr1 = rf(a, targetObjs)\n\t} else {\n\t\tr1 = ret.Error(1)\n\t}\n\n\treturn r0, r1\n}\n\n// GetNamespaceTopLevelResources provides a mock function with given fields: server, namespace\nfunc (_m *LiveStateCache) GetNamespaceTopLevelResources(server string, namespace string) (map[kube.ResourceKey]v1alpha1.ResourceNode, error) {\n\tret := _m.Called(server, namespace)\n\n\tvar r0 map[kube.ResourceKey]v1alpha1.ResourceNode\n\tif rf, ok := ret.Get(0).(func(string, string) map[kube.ResourceKey]v1alpha1.ResourceNode); ok {\n\t\tr0 = rf(server, namespace)\n\t} else {\n\t\tif ret.Get(0) != nil {\n\t\t\tr0 = ret.Get(0).(map[kube.ResourceKey]v1alpha1.ResourceNode)\n\t\t}\n\t}\n\n\tvar r1 error\n\tif rf, ok := ret.Get(1).(func(string, string) error); ok {\n\t\tr1 = rf(server, namespace)\n\t} else {\n\t\tr1 = ret.Error(1)\n\t}\n\n\treturn r0, r1\n}\n\n// GetVersionsInfo provides a mock function with given fields: serverURL\nfunc (_m *LiveStateCache) GetVersionsInfo(serverURL string) (string, []kube.APIResourceInfo, error) {\n\tret := _m.Called(serverURL)\n\n\tvar r0 string\n\tif rf, ok := ret.Get(0).(func(string) string); ok {\n\t\tr0 = rf(serverURL)\n\t} else {\n\t\tr0 = ret.Get(0).(string)\n\t}\n\n\tvar r1 []kube.APIResourceInfo\n\tif rf, ok := ret.Get(1).(func(string) []kube.APIResourceInfo); ok {\n\t\tr1 = rf(serverURL)\n\t} else {\n\t\tif ret.Get(1) != nil {\n\t\t\tr1 = ret.Get(1).([]kube.APIResourceInfo)\n\t\t}\n\t}\n\n\tvar r2 error\n\tif rf, ok := ret.Get(2).(func(string) error); ok {\n\t\tr2 = rf(serverURL)\n\t} else {\n\t\tr2 = ret.Error(2)\n\t}\n\n\treturn r0, r1, r2\n}\n\n// Init provides a mock function with given fields:\nfunc (_m *LiveStateCache) Init() error {\n\tret := _m.Called()\n\n\tvar r0 error\n\tif rf, ok := ret.Get(0).(func() error); ok {\n\t\tr0 = rf()\n\t} else {\n\t\tr0 = ret.Error(0)\n\t}\n\n\treturn r0\n}\n\n// IsNamespaced provides a mock function with given fields: server, gk\nfunc (_m *LiveStateCache) IsNamespaced(server string, gk schema.GroupKind) (bool, error) {\n\tret := _m.Called(server, gk)\n\n\tvar r0 bool\n\tif rf, ok := ret.Get(0).(func(string, schema.GroupKind) bool); ok {\n\t\tr0 = rf(server, gk)\n\t} else {\n\t\tr0 = ret.Get(0).(bool)\n\t}\n\n\tvar r1 error\n\tif rf, ok := ret.Get(1).(func(string, schema.GroupKind) error); ok {\n\t\tr1 = rf(server, gk)\n\t} else {\n\t\tr1 = ret.Error(1)\n\t}\n\n\treturn r0, r1\n}\n\n// IterateHierarchy provides a mock function with given fields: server, key, action\nfunc (_m *LiveStateCache) IterateHierarchy(server string, key kube.ResourceKey, action func(v1alpha1.ResourceNode, string)) error {\n\tret := _m.Called(server, key, action)\n\n\tvar r0 error\n\tif rf, ok := ret.Get(0).(func(string, kube.ResourceKey, func(v1alpha1.ResourceNode, string)) error); ok {\n\t\tr0 = rf(server, key, action)\n\t} else {\n\t\tr0 = ret.Error(0)\n\t}\n\n\treturn r0\n}\n\n// IterateResources provides a mock function with given fields: server, callback\nfunc (_m *LiveStateCache) IterateResources(server string, callback func(*cache.Resource, *controllercache.ResourceInfo)) error {\n\tret := _m.Called(server, callback)\n\n\tvar r0 error\n\tif rf, ok := ret.Get(0).(func(string, func(*cache.Resource, *controllercache.ResourceInfo)) error); ok {\n\t\tr0 = rf(server, callback)\n\t} else {\n\t\tr0 = ret.Error(0)\n\t}\n\n\treturn r0\n}\n\n// Run provides a mock function with given fields: ctx\nfunc (_m *LiveStateCache) Run(ctx context.Context) error {\n\tret := _m.Called(ctx)\n\n\tvar r0 error\n\tif rf, ok := ret.Get(0).(func(context.Context) error); ok {\n\t\tr0 = rf(ctx)\n\t} else {\n\t\tr0 = ret.Error(0)\n\t}\n\n\treturn r0\n}\n", "module github.com/argoproj/argo-cd/v2\n\ngo 1.17\n\nrequire (\n\tgithub.com/Knetic/govaluate v3.0.1-0.20171022003610-9aa49832a739+incompatible\n\tgithub.com/Masterminds/semver/v3 v3.1.1\n\tgithub.com/TomOnTime/utfutil v0.0.0-20180511104225-09c41003ee1d\n\tgithub.com/alicebob/miniredis v2.5.0+incompatible\n\tgithub.com/alicebob/miniredis/v2 v2.14.2\n\tgithub.com/argoproj/gitops-engine v0.6.0\n\tgithub.com/argoproj/notifications-engine v0.3.1-0.20220127183449-91deed20b998\n\tgithub.com/argoproj/pkg v0.11.1-0.20211203175135-36c59d8fafe0\n\tgithub.com/bombsimon/logrusr/v2 v2.0.1\n\tgithub.com/bradleyfalzon/ghinstallation/v2 v2.0.4\n\tgithub.com/casbin/casbin/v2 v2.39.1\n\tgithub.com/chai2010/gettext-go v0.0.0-20170215093142-bf70f2a70fb1 // indirect\n\tgithub.com/coreos/go-oidc v2.1.0+incompatible\n\tgithub.com/dustin/go-humanize v1.0.0\n\tgithub.com/evanphx/json-patch v4.12.0+incompatible\n\tgithub.com/fsnotify/fsnotify v1.5.1\n\tgithub.com/ghodss/yaml v1.0.0\n\tgithub.com/go-git/go-git/v5 v5.4.2\n\tgithub.com/go-logr/logr v1.2.2\n\tgithub.com/go-openapi/loads v0.19.4\n\tgithub.com/go-openapi/runtime v0.19.4\n\tgithub.com/go-openapi/spec v0.19.5 // indirect\n\tgithub.com/go-openapi/validate v0.19.5 // indirect\n\tgithub.com/go-redis/cache/v8 v8.4.2\n\tgithub.com/go-redis/redis/v8 v8.11.3\n\tgithub.com/gobwas/glob v0.2.3\n\tgithub.com/gogits/go-gogs-client v0.0.0-20190616193657-5a05380e4bc2\n\tgithub.com/gogo/protobuf v1.3.2\n\tgithub.com/golang-jwt/jwt/v4 v4.2.0\n\tgithub.com/golang/protobuf v1.5.2\n\tgithub.com/gomodule/redigo v2.0.0+incompatible // indirect\n\tgithub.com/google/go-cmp v0.5.6\n\tgithub.com/google/go-jsonnet v0.18.0\n\tgithub.com/google/shlex v0.0.0-20191202100458-e7afc7fbc510\n\tgithub.com/google/uuid v1.1.2\n\tgithub.com/gorilla/handlers v1.5.1\n\tgithub.com/gregjones/httpcache v0.0.0-20190611155906-901d90724c79 // indirect\n\tgithub.com/grpc-ecosystem/go-grpc-middleware v1.3.0\n\tgithub.com/grpc-ecosystem/go-grpc-prometheus v1.2.0\n\tgithub.com/grpc-ecosystem/grpc-gateway v1.16.0\n\tgithub.com/hashicorp/go-retryablehttp v0.7.0\n\tgithub.com/improbable-eng/grpc-web v0.0.0-20181111100011-16092bd1d58a\n\tgithub.com/itchyny/gojq v0.12.3\n\tgithub.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51\n\tgithub.com/malexdev/utfutil v0.0.0-20180510171754-00c8d4a8e7a8 // indirect\n\tgithub.com/mattn/go-isatty v0.0.12\n\tgithub.com/mattn/go-zglob v0.0.3\n\tgithub.com/olekukonko/tablewriter v0.0.5\n\tgithub.com/patrickmn/go-cache v2.1.0+incompatible\n\tgithub.com/pkg/errors v0.9.1\n\tgithub.com/pquerna/cachecontrol v0.0.0-20180306154005-525d0eb5f91d // indirect\n\tgithub.com/prometheus/client_golang v1.11.0\n\tgithub.com/r3labs/diff v1.1.0\n\tgithub.com/robfig/cron v1.2.0\n\tgithub.com/rs/cors v1.8.0 // indirect\n\tgithub.com/sirupsen/logrus v1.8.1\n\tgithub.com/skratchdot/open-golang v0.0.0-20160302144031-75fb7ed4208c\n\tgithub.com/soheilhy/cmux v0.1.5\n\tgithub.com/spf13/cobra v1.2.1\n\tgithub.com/spf13/pflag v1.0.5\n\tgithub.com/stretchr/testify v1.7.0\n\tgithub.com/undefinedlabs/go-mpatch v1.0.6\n\tgithub.com/whilp/git-urls v0.0.0-20191001220047-6db9661140c0\n\tgithub.com/yuin/gopher-lua v0.0.0-20200816102855-ee81675732da\n\tgolang.org/x/crypto v0.0.0-20210817164053-32db794688a5\n\tgolang.org/x/net v0.0.0-20211209124913-491a49abca63\n\tgolang.org/x/oauth2 v0.0.0-20210819190943-2bc19b11175f\n\tgolang.org/x/sync v0.0.0-20210220032951-036812b2e83c\n\tgolang.org/x/term v0.0.0-20210615171337-6886f2dfbf5b\n\tgoogle.golang.org/genproto v0.0.0-20210831024726-fe130286e0e2\n\tgoogle.golang.org/grpc v1.40.0\n\tgoogle.golang.org/protobuf v1.27.1\n\tgopkg.in/go-playground/webhooks.v5 v5.11.0\n\tgopkg.in/yaml.v2 v2.4.0\n\tk8s.io/api v0.23.1\n\tk8s.io/apiextensions-apiserver v0.23.1\n\tk8s.io/apimachinery v0.23.1\n\tk8s.io/client-go v0.23.1\n\tk8s.io/code-generator v0.23.1\n\tk8s.io/klog/v2 v2.30.0\n\tk8s.io/kube-openapi v0.0.0-20211115234752-e816edb12b65\n\tk8s.io/kubectl v0.23.1\n\tk8s.io/utils v0.0.0-20210930125809-cb0fa318a74b\n\tlayeh.com/gopher-json v0.0.0-20190114024228-97fed8db8427\n\tsigs.k8s.io/controller-runtime v0.11.0\n\tsigs.k8s.io/structured-merge-diff/v4 v4.2.0\n\tsigs.k8s.io/yaml v1.3.0\n)\n\nrequire (\n\tcloud.google.com/go v0.81.0 // indirect\n\tgithub.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1 // indirect\n\tgithub.com/Azure/go-autorest v14.2.0+incompatible // indirect\n\tgithub.com/Azure/go-autorest/autorest v0.11.18 // indirect\n\tgithub.com/Azure/go-autorest/autorest/adal v0.9.13 // indirect\n\tgithub.com/Azure/go-autorest/autorest/date v0.3.0 // indirect\n\tgithub.com/Azure/go-autorest/logger v0.2.1 // indirect\n\tgithub.com/Azure/go-autorest/tracing v0.6.0 // indirect\n\tgithub.com/MakeNowJust/heredoc v0.0.0-20170808103936-bb23615498cd // indirect\n\tgithub.com/Masterminds/goutils v1.1.0 // indirect\n\tgithub.com/Masterminds/semver v1.5.0 // indirect\n\tgithub.com/Masterminds/sprig v2.22.0+incompatible // indirect\n\tgithub.com/Microsoft/go-winio v0.4.17 // indirect\n\tgithub.com/ProtonMail/go-crypto v0.0.0-20210428141323-04723f9f07d7 // indirect\n\tgithub.com/PuerkitoBio/purell v1.1.1 // indirect\n\tgithub.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578 // indirect\n\tgithub.com/RocketChat/Rocket.Chat.Go.SDK v0.0.0-20210112200207-10ab4d695d60 // indirect\n\tgithub.com/acomagu/bufpipe v1.0.3 // indirect\n\tgithub.com/alicebob/gopher-json v0.0.0-20200520072559-a9ecdc9d1d3a // indirect\n\tgithub.com/antonmedv/expr v1.8.9 // indirect\n\tgithub.com/asaskevich/govalidator v0.0.0-20190424111038-f61b66f89f4a // indirect\n\tgithub.com/beorn7/perks v1.0.1 // indirect\n\tgithub.com/cespare/xxhash/v2 v2.1.2 // indirect\n\tgithub.com/cpuguy83/go-md2man/v2 v2.0.0 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f // indirect\n\tgithub.com/docker/distribution v2.7.1+incompatible // indirect\n\tgithub.com/emicklei/go-restful v2.9.5+incompatible // indirect\n\tgithub.com/emirpasic/gods v1.12.0 // indirect\n\tgithub.com/exponent-io/jsonpath v0.0.0-20151013193312-d6023ce2651d // indirect\n\tgithub.com/fatih/camelcase v1.0.0 // indirect\n\tgithub.com/felixge/httpsnoop v1.0.1 // indirect\n\tgithub.com/form3tech-oss/jwt-go v3.2.3+incompatible // indirect\n\tgithub.com/fvbommel/sortorder v1.0.1 // indirect\n\tgithub.com/go-errors/errors v1.0.1 // indirect\n\tgithub.com/go-git/gcfg v1.5.0 // indirect\n\tgithub.com/go-git/go-billy/v5 v5.3.1 // indirect\n\tgithub.com/go-openapi/analysis v0.19.5 // indirect\n\tgithub.com/go-openapi/errors v0.19.2 // indirect\n\tgithub.com/go-openapi/jsonpointer v0.19.5 // indirect\n\tgithub.com/go-openapi/jsonreference v0.19.5 // indirect\n\tgithub.com/go-openapi/strfmt v0.19.3 // indirect\n\tgithub.com/go-openapi/swag v0.19.14 // indirect\n\tgithub.com/go-stack/stack v1.8.0 // indirect\n\tgithub.com/go-telegram-bot-api/telegram-bot-api/v5 v5.4.0 // indirect\n\tgithub.com/golang/glog v1.0.0 // indirect\n\tgithub.com/google/btree v1.0.1 // indirect\n\tgithub.com/google/go-github/v41 v41.0.0 // indirect\n\tgithub.com/google/go-querystring v1.1.0 // indirect\n\tgithub.com/google/gofuzz v1.1.0 // indirect\n\tgithub.com/googleapis/gnostic v0.5.5 // indirect\n\tgithub.com/gorilla/websocket v1.4.2 // indirect\n\tgithub.com/gregdel/pushover v1.1.0 // indirect\n\tgithub.com/hashicorp/go-cleanhttp v0.5.1 // indirect\n\tgithub.com/huandu/xstrings v1.3.0 // indirect\n\tgithub.com/imdario/mergo v0.3.12 // indirect\n\tgithub.com/inconshreveable/mousetrap v1.0.0 // indirect\n\tgithub.com/itchyny/timefmt-go v0.1.2 // indirect\n\tgithub.com/jbenet/go-context v0.0.0-20150711004518-d14ea06fba99 // indirect\n\tgithub.com/jonboulle/clockwork v0.2.2 // indirect\n\tgithub.com/josharian/intern v1.0.0 // indirect\n\tgithub.com/json-iterator/go v1.1.12 // indirect\n\tgithub.com/kevinburke/ssh_config v0.0.0-20201106050909-4977a11b4351 // indirect\n\tgithub.com/klauspost/compress v1.13.5 // indirect\n\tgithub.com/liggitt/tabwriter v0.0.0-20181228230101-89fcab3d43de // indirect\n\tgithub.com/mailru/easyjson v0.7.6 // indirect\n\tgithub.com/mattn/go-runewidth v0.0.9 // indirect\n\tgithub.com/matttproud/golang_protobuf_extensions v1.0.2-0.20181231171920-c182affec369 // indirect\n\tgithub.com/mitchellh/copystructure v1.0.0 // indirect\n\tgithub.com/mitchellh/go-homedir v1.1.0 // indirect\n\tgithub.com/mitchellh/go-wordwrap v1.0.0 // indirect\n\tgithub.com/mitchellh/mapstructure v1.4.1 // indirect\n\tgithub.com/mitchellh/reflectwalk v1.0.0 // indirect\n\tgithub.com/moby/spdystream v0.2.0 // indirect\n\tgithub.com/moby/term v0.0.0-20210610120745-9d4ed1856297 // indirect\n\tgithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect\n\tgithub.com/modern-go/reflect2 v1.0.2 // indirect\n\tgithub.com/monochromegane/go-gitignore v0.0.0-20200626010858-205db1a8cc00 // indirect\n\tgithub.com/opencontainers/go-digest v1.0.0 // indirect\n\tgithub.com/opsgenie/opsgenie-go-sdk-v2 v1.0.5 // indirect\n\tgithub.com/peterbourgon/diskv v2.0.1+incompatible // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/prometheus/client_model v0.2.0 // indirect\n\tgithub.com/prometheus/common v0.28.0 // indirect\n\tgithub.com/prometheus/procfs v0.6.0 // indirect\n\tgithub.com/russross/blackfriday v1.5.2 // indirect\n\tgithub.com/russross/blackfriday/v2 v2.0.1 // indirect\n\tgithub.com/sergi/go-diff v1.1.0 // indirect\n\tgithub.com/shurcooL/sanitized_anchor_name v1.0.0 // indirect\n\tgithub.com/slack-go/slack v0.10.1 // indirect\n\tgithub.com/stretchr/objx v0.2.0 // indirect\n\tgithub.com/vmihailenco/go-tinylfu v0.2.1 // indirect\n\tgithub.com/vmihailenco/msgpack/v5 v5.3.4 // indirect\n\tgithub.com/vmihailenco/tagparser/v2 v2.0.0 // indirect\n\tgithub.com/xanzy/ssh-agent v0.3.0 // indirect\n\tgithub.com/xlab/treeprint v0.0.0-20181112141820-a009c3971eca // indirect\n\tgo.mongodb.org/mongo-driver v1.1.2 // indirect\n\tgo.starlark.net v0.0.0-20200306205701-8dd3e2ee1dd5 // indirect\n\tgolang.org/x/exp v0.0.0-20210901193431-a062eea981d2 // indirect\n\tgolang.org/x/mod v0.5.1-0.20210830214625-1b1db11ec8f4 // indirect\n\tgolang.org/x/sys v0.0.0-20211029165221-6e7872819dc8 // indirect\n\tgolang.org/x/text v0.3.7 // indirect\n\tgolang.org/x/time v0.0.0-20210723032227-1f47c861a9ac // indirect\n\tgolang.org/x/tools v0.1.6-0.20210820212750-d4cc65f0b2ff // indirect\n\tgolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1 // indirect\n\tgomodules.xyz/envconfig v1.3.1-0.20190308184047-426f31af0d45 // indirect\n\tgomodules.xyz/notify v0.1.0 // indirect\n\tgoogle.golang.org/appengine v1.6.7 // indirect\n\tgopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc // indirect\n\tgopkg.in/gomail.v2 v2.0.0-20160411212932-81ebce5c23df // indirect\n\tgopkg.in/inf.v0 v0.9.1 // indirect\n\tgopkg.in/square/go-jose.v2 v2.2.2 // indirect\n\tgopkg.in/warnings.v0 v0.1.2 // indirect\n\tgopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b // indirect\n\tk8s.io/apiserver v0.23.1 // indirect\n\tk8s.io/cli-runtime v0.23.1 // indirect\n\tk8s.io/component-base v0.23.1 // indirect\n\tk8s.io/component-helpers v0.23.1 // indirect\n\tk8s.io/gengo v0.0.0-20211129171323-c02415ce4185 // indirect\n\tk8s.io/kube-aggregator v0.23.1 // indirect\n\tk8s.io/kubernetes v1.23.1 // indirect\n\tsigs.k8s.io/json v0.0.0-20211020170558-c049b76a60c6 // indirect\n\tsigs.k8s.io/kustomize/api v0.10.1 // indirect\n\tsigs.k8s.io/kustomize/kyaml v0.13.0 // indirect\n)\n\nreplace (\n\t// https://github.com/golang/go/issues/33546#issuecomment-519656923\n\tgithub.com/go-check/check => github.com/go-check/check v0.0.0-20180628173108-788fd7840127\n\n\tgithub.com/golang/protobuf => github.com/golang/protobuf v1.4.2\n\tgithub.com/gorilla/websocket => github.com/gorilla/websocket v1.4.2\n\tgithub.com/grpc-ecosystem/grpc-gateway => github.com/grpc-ecosystem/grpc-gateway v1.16.0\n\tgithub.com/improbable-eng/grpc-web => github.com/improbable-eng/grpc-web v0.0.0-20181111100011-16092bd1d58a\n\n\tgoogle.golang.org/grpc => google.golang.org/grpc v1.15.0\n\n\t// https://github.com/kubernetes/kubernetes/issues/79384#issuecomment-505627280\n\tk8s.io/api => k8s.io/api v0.23.1\n\tk8s.io/apiextensions-apiserver => k8s.io/apiextensions-apiserver v0.23.1\n\tk8s.io/apimachinery => k8s.io/apimachinery v0.23.1\n\tk8s.io/apiserver => k8s.io/apiserver v0.23.1\n\tk8s.io/cli-runtime => k8s.io/cli-runtime v0.23.1\n\tk8s.io/client-go => k8s.io/client-go v0.23.1\n\tk8s.io/cloud-provider => k8s.io/cloud-provider v0.23.1\n\tk8s.io/cluster-bootstrap => k8s.io/cluster-bootstrap v0.23.1\n\tk8s.io/code-generator => k8s.io/code-generator v0.23.1\n\tk8s.io/component-base => k8s.io/component-base v0.23.1\n\tk8s.io/component-helpers => k8s.io/component-helpers v0.23.1\n\tk8s.io/controller-manager => k8s.io/controller-manager v0.23.1\n\tk8s.io/cri-api => k8s.io/cri-api v0.23.1\n\tk8s.io/csi-translation-lib => k8s.io/csi-translation-lib v0.23.1\n\tk8s.io/kube-aggregator => k8s.io/kube-aggregator v0.23.1\n\tk8s.io/kube-controller-manager => k8s.io/kube-controller-manager v0.23.1\n\tk8s.io/kube-proxy => k8s.io/kube-proxy v0.23.1\n\tk8s.io/kube-scheduler => k8s.io/kube-scheduler v0.23.1\n\tk8s.io/kubectl => k8s.io/kubectl v0.23.1\n\tk8s.io/kubelet => k8s.io/kubelet v0.23.1\n\tk8s.io/legacy-cloud-providers => k8s.io/legacy-cloud-providers v0.23.1\n\tk8s.io/metrics => k8s.io/metrics v0.23.1\n\tk8s.io/mount-utils => k8s.io/mount-utils v0.23.1\n\tk8s.io/pod-security-admission => k8s.io/pod-security-admission v0.23.1\n\tk8s.io/sample-apiserver => k8s.io/sample-apiserver v0.23.1\n)\n", "bazil.org/fuse v0.0.0-20160811212531-371fbbdaa898/go.mod h1:Xbm+BRKSBEpa4q4hTSxohYNQpsxXPbPry4JJWOB3LB8=\nbitbucket.org/bertimus9/systemstat v0.0.0-20180207000608-0eeff89b0690/go.mod h1:Ulb78X89vxKYgdL24HMTiXYHlyHEvruOj1ZPlqeNEZM=\ncloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.38.0/go.mod h1:990N+gfupTy94rShfmMCWGDn0LpTmnzTp2qbd1dvSRU=\ncloud.google.com/go v0.44.1/go.mod h1:iSa0KzasP4Uvy3f1mN/7PiObzGgflwredwwASm/v6AU=\ncloud.google.com/go v0.44.2/go.mod h1:60680Gw3Yr4ikxnPRS/oxxkBccT6SA1yMk63TGekxKY=\ncloud.google.com/go v0.45.1/go.mod h1:RpBamKRgapWJb87xiFSdk4g1CME7QZg3uwTez+TSTjc=\ncloud.google.com/go v0.46.3/go.mod h1:a6bKKbmY7er1mI7TEI4lsAkts/mkhTSZK8w33B4RAg0=\ncloud.google.com/go v0.50.0/go.mod h1:r9sluTvynVuxRIOHXQEHMFffphuXHOMZMycpNR5e6To=\ncloud.google.com/go v0.52.0/go.mod h1:pXajvRH/6o3+F9jDHZWQ5PbGhn+o8w9qiu/CffaVdO4=\ncloud.google.com/go v0.53.0/go.mod h1:fp/UouUEsRkN6ryDKNW/Upv/JBKnv6WDthjR6+vze6M=\ncloud.google.com/go v0.54.0/go.mod h1:1rq2OEkV3YMf6n/9ZvGWI3GWw0VoqH/1x2nd8Is/bPc=\ncloud.google.com/go v0.56.0/go.mod h1:jr7tqZxxKOVYizybht9+26Z/gUq7tiRzu+ACVAMbKVk=\ncloud.google.com/go v0.57.0/go.mod h1:oXiQ6Rzq3RAkkY7N6t3TcE6jE+CIBBbA36lwQ1JyzZs=\ncloud.google.com/go v0.62.0/go.mod h1:jmCYTdRCQuc1PHIIJ/maLInMho30T/Y0M4hTdTShOYc=\ncloud.google.com/go v0.65.0/go.mod h1:O5N8zS7uWy9vkA9vayVHs65eM1ubvY4h553ofrNHObY=\ncloud.google.com/go v0.72.0/go.mod h1:M+5Vjvlc2wnp6tjzE102Dw08nGShTscUx2nZMufOKPI=\ncloud.google.com/go v0.74.0/go.mod h1:VV1xSbzvo+9QJOxLDaJfTjx5e+MePCpCWwvftOeQmWk=\ncloud.google.com/go v0.78.0/go.mod h1:QjdrLG0uq+YwhjoVOLsS1t7TW8fs36kLs4XO5R5ECHg=\ncloud.google.com/go v0.79.0/go.mod h1:3bzgcEeQlzbuEAYu4mrWhKqWjmpprinYgKJLgKHnbb8=\ncloud.google.com/go v0.81.0 h1:at8Tk2zUz63cLPR0JPWm5vp77pEZmzxEQBEfRKn1VV8=\ncloud.google.com/go v0.81.0/go.mod h1:mk/AM35KwGk/Nm2YSeZbxXdrNK3KZOYHmLkOqC2V6E0=\ncloud.google.com/go/bigquery v1.0.1/go.mod h1:i/xbL2UlR5RvWAURpBYZTtm/cXjCha9lbfbpx4poX+o=\ncloud.google.com/go/bigquery v1.3.0/go.mod h1:PjpwJnslEMmckchkHFfq+HTD2DmtT67aNFKH1/VBDHE=\ncloud.google.com/go/bigquery v1.4.0/go.mod h1:S8dzgnTigyfTmLBfrtrhyYhwRxG72rYxvftPBK2Dvzc=\ncloud.google.com/go/bigquery v1.5.0/go.mod h1:snEHRnqQbz117VIFhE8bmtwIDY80NLUZUMb4Nv6dBIg=\ncloud.google.com/go/bigquery v1.7.0/go.mod h1://okPTzCYNXSlb24MZs83e2Do+h+VXtc4gLoIoXIAPc=\ncloud.google.com/go/bigquery v1.8.0/go.mod h1:J5hqkt3O0uAFnINi6JXValWIb1v0goeZM77hZzJN/fQ=\ncloud.google.com/go/datastore v1.0.0/go.mod h1:LXYbyblFSglQ5pkeyhO+Qmw7ukd3C+pD7TKLgZqpHYE=\ncloud.google.com/go/datastore v1.1.0/go.mod h1:umbIZjpQpHh4hmRpGhH4tLFup+FVzqBi1b3c64qFpCk=\ncloud.google.com/go/firestore v1.1.0/go.mod h1:ulACoGHTpvq5r8rxGJ4ddJZBZqakUQqClKRT5SZwBmk=\ncloud.google.com/go/pubsub v1.0.1/go.mod h1:R0Gpsv3s54REJCy4fxDixWD93lHJMoZTyQ2kNxGRt3I=\ncloud.google.com/go/pubsub v1.1.0/go.mod h1:EwwdRX2sKPjnvnqCa270oGRyludottCI76h+R3AArQw=\ncloud.google.com/go/pubsub v1.2.0/go.mod h1:jhfEVHT8odbXTkndysNHCcx0awwzvfOlguIAii9o8iA=\ncloud.google.com/go/pubsub v1.3.1/go.mod h1:i+ucay31+CNRpDW4Lu78I4xXG+O1r/MAHgjpRVR+TSU=\ncloud.google.com/go/storage v1.0.0/go.mod h1:IhtSnM/ZTZV8YYJWCY8RULGVqBDmpoyjwiyrjsg+URw=\ncloud.google.com/go/storage v1.5.0/go.mod h1:tpKbwo567HUNpVclU5sGELwQWBDZ8gh0ZeosJ0Rtdos=\ncloud.google.com/go/storage v1.6.0/go.mod h1:N7U0C8pVQ/+NIKOBQyamJIeKQKkZ+mxpohlUTyfDhBk=\ncloud.google.com/go/storage v1.8.0/go.mod h1:Wv1Oy7z6Yz3DshWRJFhqM/UCfaWIRTdp0RXyy7KQOVs=\ncloud.google.com/go/storage v1.10.0/go.mod h1:FLPqc6j+Ki4BU591ie1oL6qBQGu2Bl/tZ9ullr3+Kg0=\ndmitri.shuralyov.com/gpu/mtl v0.0.0-20190408044501-666a987793e9/go.mod h1:H6x//7gZCb22OMCxBHrMx7a5I7Hp++hsVxbQ4BYO7hU=\ndmitri.shuralyov.com/gpu/mtl v0.0.0-20201218220906-28db891af037/go.mod h1:H6x//7gZCb22OMCxBHrMx7a5I7Hp++hsVxbQ4BYO7hU=\ngithub.com/Azure/azure-sdk-for-go v55.0.0+incompatible/go.mod h1:9XXNKU+eRnpl9moKnB4QOLf1HestfXbmab5FXxiDBjc=\ngithub.com/Azure/go-ansiterm v0.0.0-20170929234023-d6e3b3328b78/go.mod h1:LmzpDX56iTiv29bbRTIsUNlaFfuhWRQBWjQdVyAevI8=\ngithub.com/Azure/go-ansiterm v0.0.0-20210608223527-2377c96fe795/go.mod h1:LmzpDX56iTiv29bbRTIsUNlaFfuhWRQBWjQdVyAevI8=\ngithub.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1 h1:UQHMgLO+TxOElx5B5HZ4hJQsoJ/PvUvKRhJHDQXO8P8=\ngithub.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1/go.mod h1:xomTg63KZ2rFqZQzSB4Vz2SUXa1BpHTVz9L5PTmPC4E=\ngithub.com/Azure/go-autorest v14.2.0+incompatible h1:V5VMDjClD3GiElqLWO7mz2MxNAK/vTfRHdAubSIPRgs=\ngithub.com/Azure/go-autorest v14.2.0+incompatible/go.mod h1:r+4oMnoxhatjLLJ6zxSWATqVooLgysK6ZNox3g/xq24=\ngithub.com/Azure/go-autorest/autorest v0.11.18 h1:90Y4srNYrwOtAgVo3ndrQkTYn6kf1Eg/AjTFJ8Is2aM=\ngithub.com/Azure/go-autorest/autorest v0.11.18/go.mod h1:dSiJPy22c3u0OtOKDNttNgqpNFY/GeWa7GH/Pz56QRA=\ngithub.com/Azure/go-autorest/autorest/adal v0.9.13 h1:Mp5hbtOePIzM8pJVRa3YLrWWmZtoxRXqUEzCfJt3+/Q=\ngithub.com/Azure/go-autorest/autorest/adal v0.9.13/go.mod h1:W/MM4U6nLxnIskrw4UwWzlHfGjwUS50aOsc/I3yuU8M=\ngithub.com/Azure/go-autorest/autorest/date v0.3.0 h1:7gUk1U5M/CQbp9WoqinNzJar+8KY+LPI6wiWrP/myHw=\ngithub.com/Azure/go-autorest/autorest/date v0.3.0/go.mod h1:BI0uouVdmngYNUzGWeSYnokU+TrmwEsOqdt8Y6sso74=\ngithub.com/Azure/go-autorest/autorest/mocks v0.4.1 h1:K0laFcLE6VLTOwNgSxaGbUcLPuGXlNkbVvq4cW4nIHk=\ngithub.com/Azure/go-autorest/autorest/mocks v0.4.1/go.mod h1:LTp+uSrOhSkaKrUy935gNZuuIPPVsHlr9DSOxSayd+k=\ngithub.com/Azure/go-autorest/autorest/to v0.4.0/go.mod h1:fE8iZBn7LQR7zH/9XU2NcPR4o9jEImooCeWJcYV/zLE=\ngithub.com/Azure/go-autorest/autorest/validation v0.1.0/go.mod h1:Ha3z/SqBeaalWQvokg3NZAlQTalVMtOIAs1aGK7G6u8=\ngithub.com/Azure/go-autorest/logger v0.2.1 h1:IG7i4p/mDa2Ce4TRyAO8IHnVhAVF3RFU+ZtXWSmf4Tg=\ngithub.com/Azure/go-autorest/logger v0.2.1/go.mod h1:T9E3cAhj2VqvPOtCYAvby9aBXkZmbF5NWuPV8+WeEW8=\ngithub.com/Azure/go-autorest/tracing v0.6.0 h1:TYi4+3m5t6K48TGI9AUdb+IzbnSxvnvUMfuitfgcfuo=\ngithub.com/Azure/go-autorest/tracing v0.6.0/go.mod h1:+vhtPC754Xsa23ID7GlGsrdKBpUA79WCAKPPZVC2DeU=\ngithub.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=\ngithub.com/BurntSushi/xgb v0.0.0-20160522181843-27f122750802/go.mod h1:IVnqGOEym/WlBOVXweHU+Q+/VP0lqqI8lqeDx9IjBqo=\ngithub.com/DATA-DOG/go-sqlmock v1.3.3/go.mod h1:f/Ixk793poVmq4qj/V1dPUg2JEAKC73Q5eFN3EC/SaM=\ngithub.com/GoogleCloudPlatform/k8s-cloud-provider v1.16.1-0.20210702024009-ea6160c1d0e3/go.mod h1:8XasY4ymP2V/tn2OOV9ZadmiTE1FIB/h3W+yNlPttKw=\ngithub.com/JeffAshton/win_pdh v0.0.0-20161109143554-76bb4ee9f0ab/go.mod h1:3VYc5hodBMJ5+l/7J4xAyMeuM2PNuepvHlGs8yilUCA=\ngithub.com/Jeffail/gabs v1.4.0 h1://5fYRRTq1edjfIrQGvdkcd22pkYUrHZ5YC/H2GJVAo=\ngithub.com/Jeffail/gabs v1.4.0/go.mod h1:6xMvQMK4k33lb7GUUpaAPh6nKMmemQeg5d4gn7/bOXc=\ngithub.com/Knetic/govaluate v3.0.1-0.20171022003610-9aa49832a739+incompatible h1:1G1pk05UrOh0NlF1oeaaix1x8XzrfjIDK47TY0Zehcw=\ngithub.com/Knetic/govaluate v3.0.1-0.20171022003610-9aa49832a739+incompatible/go.mod h1:r7JcOSlj0wfOMncg0iLm8Leh48TZaKVeNIfJntJ2wa0=\ngithub.com/MakeNowJust/heredoc v0.0.0-20170808103936-bb23615498cd h1:sjQovDkwrZp8u+gxLtPgKGjk5hCxuy2hrRejBTA9xFU=\ngithub.com/MakeNowJust/heredoc v0.0.0-20170808103936-bb23615498cd/go.mod h1:64YHyfSL2R96J44Nlwm39UHepQbyR5q10x7iYa1ks2E=\ngithub.com/Masterminds/goutils v1.1.0 h1:zukEsf/1JZwCMgHiK3GZftabmxiCw4apj3a28RPBiVg=\ngithub.com/Masterminds/goutils v1.1.0/go.mod h1:8cTjp+g8YejhMuvIA5y2vz3BpJxksy863GQaJW2MFNU=\ngithub.com/Masterminds/semver v1.5.0 h1:H65muMkzWKEuNDnfl9d70GUjFniHKHRbFPGBuZ3QEww=\ngithub.com/Masterminds/semver v1.5.0/go.mod h1:MB6lktGJrhw8PrUyiEoblNEGEQ+RzHPF078ddwwvV3Y=\ngithub.com/Masterminds/semver/v3 v3.1.1 h1:hLg3sBzpNErnxhQtUy/mmLR2I9foDujNK030IGemrRc=\ngithub.com/Masterminds/semver/v3 v3.1.1/go.mod h1:VPu/7SZ7ePZ3QOrcuXROw5FAcLl4a0cBrbBpGY/8hQs=\ngithub.com/Masterminds/sprig v2.22.0+incompatible h1:z4yfnGrZ7netVz+0EDJ0Wi+5VZCSYp4Z0m2dk6cEM60=\ngithub.com/Masterminds/sprig v2.22.0+incompatible/go.mod h1:y6hNFY5UBTIWBxnzTeuNhlNS5hqE0NB0E6fgfo2Br3o=\ngithub.com/Microsoft/go-winio v0.4.14/go.mod h1:qXqCSQ3Xa7+6tgxaGTIe4Kpcdsi+P8jBhyzoq1bpyYA=\ngithub.com/Microsoft/go-winio v0.4.15/go.mod h1:tTuCMEN+UleMWgg9dVx4Hu52b1bJo+59jBh3ajtinzw=\ngithub.com/Microsoft/go-winio v0.4.16/go.mod h1:XB6nPKklQyQ7GC9LdcBEcBl8PF76WugXOPRXwdLnMv0=\ngithub.com/Microsoft/go-winio v0.4.17 h1:iT12IBVClFevaf8PuVyi3UmZOVh4OqnaLxDTW2O6j3w=\ngithub.com/Microsoft/go-winio v0.4.17/go.mod h1:JPGBdM1cNvN/6ISo+n8V5iA4v8pBzdOpzfwIujj1a84=\ngithub.com/Microsoft/hcsshim v0.8.22/go.mod h1:91uVCVzvX2QD16sMCenoxxXo6L1wJnLMX2PSufFMtF0=\ngithub.com/NYTimes/gziphandler v0.0.0-20170623195520-56545f4a5d46/go.mod h1:3wb06e3pkSAbeQ52E9H9iFoQsEEwGN64994WTCIhntQ=\ngithub.com/NYTimes/gziphandler v1.1.1/go.mod h1:n/CVRwUEOgIxrgPvAQhUUr9oeUtvrhMomdKFjzJNB0c=\ngithub.com/OneOfOne/xxhash v1.2.2/go.mod h1:HSdplMjZKSmBqAxg5vPj2TmRDmfkzw+cTzAElWljhcU=\ngithub.com/ProtonMail/go-crypto v0.0.0-20210428141323-04723f9f07d7 h1:YoJbenK9C67SkzkDfmQuVln04ygHj3vjZfd9FL+GmQQ=\ngithub.com/ProtonMail/go-crypto v0.0.0-20210428141323-04723f9f07d7/go.mod h1:z4/9nQmJSSwwds7ejkxaJwO37dru3geImFUdJlaLzQo=\ngithub.com/PuerkitoBio/purell v1.1.0/go.mod h1:c11w/QuzBsJSee3cPx9rAFu61PvFxuPbtSwDGJws/X0=\ngithub.com/PuerkitoBio/purell v1.1.1 h1:WEQqlqaGbrPkxLJWfBwQmfEAE1Z7ONdDLqrN38tNFfI=\ngithub.com/PuerkitoBio/purell v1.1.1/go.mod h1:c11w/QuzBsJSee3cPx9rAFu61PvFxuPbtSwDGJws/X0=\ngithub.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578 h1:d+Bc7a5rLufV/sSk/8dngufqelfh6jnri85riMAaF/M=\ngithub.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578/go.mod h1:uGdkoq3SwY9Y+13GIhn11/XLaGBb4BfwItxLd5jeuXE=\ngithub.com/RocketChat/Rocket.Chat.Go.SDK v0.0.0-20210112200207-10ab4d695d60 h1:prBTRx78AQnXzivNT9Crhu564W/zPPr3ibSlpT9xKcE=\ngithub.com/RocketChat/Rocket.Chat.Go.SDK v0.0.0-20210112200207-10ab4d695d60/go.mod h1:rjP7sIipbZcagro/6TCk6X0ZeFT2eyudH5+fve/cbBA=\ngithub.com/Shopify/sarama v1.19.0/go.mod h1:FVkBWblsNy7DGZRfXLU0O9RCGt5g3g3yEuWXgklEdEo=\ngithub.com/Shopify/toxiproxy v2.1.4+incompatible/go.mod h1:OXgGpZ6Cli1/URJOF1DMxUHB2q5Ap20/P/eIdh4G0pI=\ngithub.com/TomOnTime/utfutil v0.0.0-20180511104225-09c41003ee1d h1:WtAMR0fPCOfK7TPGZ8ZpLLY18HRvL7XJ3xcs0wnREgo=\ngithub.com/TomOnTime/utfutil v0.0.0-20180511104225-09c41003ee1d/go.mod h1:WML6KOYjeU8N6YyusMjj2qRvaPNUEvrQvaxuFcMRFJY=\ngithub.com/VividCortex/gohistogram v1.0.0/go.mod h1:Pf5mBqqDxYaXu3hDrrU+w6nw50o/4+TcAqDqk/vUH7g=\ngithub.com/acomagu/bufpipe v1.0.3 h1:fxAGrHZTgQ9w5QqVItgzwj235/uYZYgbXitB+dLupOk=\ngithub.com/acomagu/bufpipe v1.0.3/go.mod h1:mxdxdup/WdsKVreO5GpW4+M/1CE2sMG4jeGJ2sYmHc4=\ngithub.com/afex/hystrix-go v0.0.0-20180502004556-fa1af6a1f4f5/go.mod h1:SkGFH1ia65gfNATL8TAiHDNxPzPdmEL5uirI2Uyuz6c=\ngithub.com/agnivade/levenshtein v1.0.1/go.mod h1:CURSv5d9Uaml+FovSIICkLbAUZ9S4RqaHDIsdSBg7lM=\ngithub.com/ajstarks/svgo v0.0.0-20180226025133-644b8db467af/go.mod h1:K08gAheRH3/J6wwsYMMT4xOr94bZjxIelGM0+d/wbFw=\ngithub.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=\ngithub.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=\ngithub.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=\ngithub.com/alecthomas/units v0.0.0-20190717042225-c3de453c63f4/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=\ngithub.com/alecthomas/units v0.0.0-20190924025748-f65c72e2690d/go.mod h1:rBZYJk541a8SKzHPHnH3zbiI+7dagKZ0cgpgrD7Fyho=\ngithub.com/alicebob/gopher-json v0.0.0-20200520072559-a9ecdc9d1d3a h1:HbKu58rmZpUGpz5+4FfNmIU+FmZg2P3Xaj2v2bfNWmk=\ngithub.com/alicebob/gopher-json v0.0.0-20200520072559-a9ecdc9d1d3a/go.mod h1:SGnFV6hVsYE877CKEZ6tDNTjaSXYUk6QqoIK6PrAtcc=\ngithub.com/alicebob/miniredis v2.5.0+incompatible h1:yBHoLpsyjupjz3NL3MhKMVkR41j82Yjf3KFv7ApYzUI=\ngithub.com/alicebob/miniredis v2.5.0+incompatible/go.mod h1:8HZjEj4yU0dwhYHky+DxYx+6BMjkBbe5ONFIF1MXffk=\ngithub.com/alicebob/miniredis/v2 v2.14.2 h1:VeoqKUAsJfT2af61nDE7qhBzqn3J6xjnt9MFAbdrEtg=\ngithub.com/alicebob/miniredis/v2 v2.14.2/go.mod h1:gquAfGbzn92jvtrSC69+6zZnwSODVXVpYDRaGhWaL6I=\ngithub.com/andreyvit/diff v0.0.0-20170406064948-c7f18ee00883/go.mod h1:rCTlJbsFo29Kk6CurOXKm700vrz8f0KW0JNfpkRJY/8=\ngithub.com/anmitsu/go-shlex v0.0.0-20161002113705-648efa622239 h1:kFOfPq6dUM1hTo4JG6LR5AXSUEsOjtdm0kw0FtQtMJA=\ngithub.com/anmitsu/go-shlex v0.0.0-20161002113705-648efa622239/go.mod h1:2FmKhYUyUczH0OGQWaF5ceTx0UBShxjsH6f8oGKYe2c=\ngithub.com/antihax/optional v1.0.0/go.mod h1:uupD/76wgC+ih3iEmQUL+0Ugr19nfwCT1kdvxnR2qWY=\ngithub.com/antlr/antlr4/runtime/Go/antlr v0.0.0-20210826220005-b48c857c3a0e/go.mod h1:F7bn7fEU90QkQ3tnmaTx3LTKLEDqnwWODIYppRQ5hnY=\ngithub.com/antonmedv/expr v1.8.9 h1:O9stiHmHHww9b4ozhPx7T6BK7fXfOCHJ8ybxf0833zw=\ngithub.com/antonmedv/expr v1.8.9/go.mod h1:5qsM3oLGDND7sDmQGDXHkYfkjYMUX14qsgqmHhwGEk8=\ngithub.com/apache/thrift v0.12.0/go.mod h1:cp2SuWMxlEZw2r+iP2GNCdIi4C1qmUzdZFSVb+bacwQ=\ngithub.com/apache/thrift v0.13.0/go.mod h1:cp2SuWMxlEZw2r+iP2GNCdIi4C1qmUzdZFSVb+bacwQ=\ngithub.com/appscode/go v0.0.0-20190808133642-1d4ef1f1c1e0/go.mod h1:iy07dV61Z7QQdCKJCIvUoDL21u6AIceRhZzyleh2ymc=\ngithub.com/argoproj/gitops-engine v0.6.0 h1:Tnh6kUUVuBV0m3gueYIymAeErWl9XNN9O9JcOoNM0vU=\ngithub.com/argoproj/gitops-engine v0.6.0/go.mod h1:pRgVpLW7pZqf7n3COJ7UcDepk4cI61LAcJd64Q3Jq/c=\ngithub.com/argoproj/notifications-engine v0.3.1-0.20220127183449-91deed20b998 h1:V9RDg+IZeebnm3XjkfkbN07VM21Fu1Cy/RJNoHO++VM=\ngithub.com/argoproj/notifications-engine v0.3.1-0.20220127183449-91deed20b998/go.mod h1:5mKv7zEgI3NO0L+fsuRSwBSY9EIXSuyIsDND8O8TTIw=\ngithub.com/argoproj/pkg v0.11.1-0.20211203175135-36c59d8fafe0 h1:Cfp7rO/HpVxnwlRqJe0jHiBbZ77ZgXhB6HWlYD02Xdc=\ngithub.com/argoproj/pkg v0.11.1-0.20211203175135-36c59d8fafe0/go.mod h1:ra+bQPmbVAoEL+gYSKesuigt4m49i3Qa3mE/xQcjCiA=\ngithub.com/armon/circbuf v0.0.0-20150827004946-bbbad097214e/go.mod h1:3U/XgcO3hCbHZ8TKRvWD2dDTCfh9M9ya+I9JpbB7O8o=\ngithub.com/armon/consul-api v0.0.0-20180202201655-eb2c6b5be1b6/go.mod h1:grANhF5doyWs3UAsr3K4I6qtAmlQcZDesFNEHPZAzj8=\ngithub.com/armon/go-metrics v0.0.0-20180917152333-f0300d1749da/go.mod h1:Q73ZrmVTwzkszR9V5SSuryQ31EELlFMUz1kKyl939pY=\ngithub.com/armon/go-radix v0.0.0-20180808171621-7fddfc383310/go.mod h1:ufUuZ+zHj4x4TnLV4JWEpy2hxWSpsRywHrMgIH9cCH8=\ngithub.com/armon/go-socks5 v0.0.0-20160902184237-e75332964ef5 h1:0CwZNZbxp69SHPdPJAN/hZIm0C4OItdklCFmMRWYpio=\ngithub.com/armon/go-socks5 v0.0.0-20160902184237-e75332964ef5/go.mod h1:wHh0iHkYZB8zMSxRWpUBQtwG5a7fFgvEO+odwuTv2gs=\ngithub.com/aryann/difflib v0.0.0-20170710044230-e206f873d14a/go.mod h1:DAHtR1m6lCRdSC2Tm3DSWRPvIPr6xNKyeHdqDQSQT+A=\ngithub.com/asaskevich/govalidator v0.0.0-20180720115003-f9ffefc3facf/go.mod h1:lB+ZfQJz7igIIfQNfa7Ml4HSf2uFQQRzpGGRXenZAgY=\ngithub.com/asaskevich/govalidator v0.0.0-20190424111038-f61b66f89f4a h1:idn718Q4B6AGu/h5Sxe66HYVdqdGu2l9Iebqhi/AEoA=\ngithub.com/asaskevich/govalidator v0.0.0-20190424111038-f61b66f89f4a/go.mod h1:lB+ZfQJz7igIIfQNfa7Ml4HSf2uFQQRzpGGRXenZAgY=\ngithub.com/auth0/go-jwt-middleware v1.0.1/go.mod h1:YSeUX3z6+TF2H+7padiEqNJ73Zy9vXW72U//IgN0BIM=\ngithub.com/aws/aws-lambda-go v1.13.3/go.mod h1:4UKl9IzQMoD+QF79YdCuzCwp8VbmG4VAQwij/eHl5CU=\ngithub.com/aws/aws-sdk-go v1.27.0/go.mod h1:KmX6BPdI08NWTb3/sm4ZGu5ShLoqVDhKgpiN924inxo=\ngithub.com/aws/aws-sdk-go v1.33.16/go.mod h1:5zCpMtNQVjRREroY7sYe8lOMRSxkhG6MZveU8YkpAk0=\ngithub.com/aws/aws-sdk-go v1.35.24/go.mod h1:tlPOdRjfxPBpNIwqDj61rmsnA85v9jc0Ps9+muhnW+k=\ngithub.com/aws/aws-sdk-go v1.38.49/go.mod h1:hcU610XS61/+aQV88ixoOzUoG7v3b31pl2zKMmprdro=\ngithub.com/aws/aws-sdk-go-v2 v0.18.0/go.mod h1:JWVYvqSMppoMJC0x5wdwiImzgXTI9FuZwxzkQq9wy+g=\ngithub.com/beevik/ntp v0.2.0/go.mod h1:hIHWr+l3+/clUnF44zdK+CWW7fO8dR5cIylAQ76NRpg=\ngithub.com/benbjohnson/clock v1.0.3/go.mod h1:bGMdMPoPVvcYyt1gHDf4J2KE153Yf9BuiUKYMaxlTDM=\ngithub.com/benbjohnson/clock v1.1.0/go.mod h1:J11/hYXuz8f4ySSvYwY0FKfm+ezbsZBKZxNJlLklBHA=\ngithub.com/beorn7/perks v0.0.0-20180321164747-3a771d992973/go.mod h1:Dwedo/Wpr24TaqPxmxbtue+5NUziq4I4S80YR8gNf3Q=\ngithub.com/beorn7/perks v1.0.0/go.mod h1:KWe93zE9D1o94FZ5RNwFwVgaQK1VOXiVxmqh+CedLV8=\ngithub.com/beorn7/perks v1.0.1 h1:VlbKKnNfV8bJzeqoa4cOKqO6bYr3WgKZxO8Z16+hsOM=\ngithub.com/beorn7/perks v1.0.1/go.mod h1:G2ZrVWU2WbWT9wwq4/hrbKbnv/1ERSJQ0ibhJ6rlkpw=\ngithub.com/bgentry/speakeasy v0.1.0/go.mod h1:+zsyZBPWlz7T6j88CTgSN5bM796AkVf0kBD4zp0CCIs=\ngithub.com/bits-and-blooms/bitset v1.2.0/go.mod h1:gIdJ4wp64HaoK2YrL1Q5/N7Y16edYb8uY+O0FJTyyDA=\ngithub.com/bketelsen/crypt v0.0.3-0.20200106085610-5cbc8cc4026c/go.mod h1:MKsuJmJgSg28kpZDP6UIiPt0e0Oz0kqKNGyRaWEPv84=\ngithub.com/bketelsen/crypt v0.0.4/go.mod h1:aI6NrJ0pMGgvZKL1iVgXLnfIFJtfV+bKCoqOes/6LfM=\ngithub.com/blang/semver v3.5.0+incompatible/go.mod h1:kRBLl5iJ+tD4TcOOxsy/0fnwebNt5EWlYSAyrTnjyyk=\ngithub.com/blang/semver v3.5.1+incompatible/go.mod h1:kRBLl5iJ+tD4TcOOxsy/0fnwebNt5EWlYSAyrTnjyyk=\ngithub.com/boltdb/bolt v1.3.1/go.mod h1:clJnj/oiGkjum5o1McbSZDSLxVThjynRyGBgiAx27Ps=\ngithub.com/bombsimon/logrusr/v2 v2.0.1 h1:1VgxVNQMCvjirZIYaT9JYn6sAVGVEcNtRE0y4mvaOAM=\ngithub.com/bombsimon/logrusr/v2 v2.0.1/go.mod h1:ByVAX+vHdLGAfdroiMg6q0zgq2FODY2lc5YJvzmOJio=\ngithub.com/bradleyfalzon/ghinstallation/v2 v2.0.4 h1:tXKVfhE7FcSkhkv0UwkLvPDeZ4kz6OXd0PKPlFqf81M=\ngithub.com/bradleyfalzon/ghinstallation/v2 v2.0.4/go.mod h1:B40qPqJxWE0jDZgOR1JmaMy+4AY1eBP+IByOvqyAKp0=\ngithub.com/bwmarrin/discordgo v0.19.0/go.mod h1:O9S4p+ofTFwB02em7jkpkV8M3R0/PUVOwN61zSZ0r4Q=\ngithub.com/casbin/casbin/v2 v2.1.2/go.mod h1:YcPU1XXisHhLzuxH9coDNf2FbKpjGlbCg3n9yuLkIJQ=\ngithub.com/casbin/casbin/v2 v2.39.1 h1:TatfPL1hByffzPs610HL8+gBjCisAtEhjVhpIsbZ+ws=\ngithub.com/casbin/casbin/v2 v2.39.1/go.mod h1:sEL80qBYTbd+BPeL4iyvwYzFT3qwLaESq5aFKVLbLfA=\ngithub.com/cenkalti/backoff v2.1.1+incompatible/go.mod h1:90ReRw6GdpyfrHakVjL/QHaoyV4aDUVVkXQJJJ3NXXM=\ngithub.com/cenkalti/backoff v2.2.1+incompatible/go.mod h1:90ReRw6GdpyfrHakVjL/QHaoyV4aDUVVkXQJJJ3NXXM=\ngithub.com/certifi/gocertifi v0.0.0-20191021191039-0944d244cd40/go.mod h1:sGbDF6GwGcLpkNXPUTkMRoywsNa/ol15pxFe6ERfguA=\ngithub.com/certifi/gocertifi v0.0.0-20200922220541-2c3bb06c6054/go.mod h1:sGbDF6GwGcLpkNXPUTkMRoywsNa/ol15pxFe6ERfguA=\ngithub.com/cespare/xxhash v1.1.0 h1:a6HrQnmkObjyL+Gs60czilIUGqrzKutQD6XZog3p+ko=\ngithub.com/cespare/xxhash v1.1.0/go.mod h1:XrSqR1VqqWfGrhpAt58auRo0WTKS1nRRg3ghfAqPWnc=\ngithub.com/cespare/xxhash/v2 v2.1.1/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/cespare/xxhash/v2 v2.1.2 h1:YRXhKfTDauu4ajMg1TPgFO5jnlC2HCbmLXMcTG5cbYE=\ngithub.com/cespare/xxhash/v2 v2.1.2/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/chai2010/gettext-go v0.0.0-20160711120539-c6fed771bfd5/go.mod h1:/iP1qXHoty45bqomnu2LM+VVyAEdWN+vtSHGlQgyxbw=\ngithub.com/chai2010/gettext-go v0.0.0-20170215093142-bf70f2a70fb1 h1:HD4PLRzjuCVW79mQ0/pdsalOLHJ+FaEoqJLxfltpb2U=\ngithub.com/chai2010/gettext-go v0.0.0-20170215093142-bf70f2a70fb1/go.mod h1:/iP1qXHoty45bqomnu2LM+VVyAEdWN+vtSHGlQgyxbw=\ngithub.com/checkpoint-restore/go-criu/v5 v5.0.0/go.mod h1:cfwC0EG7HMUenopBsUf9d89JlCLQIfgVcNsNN0t6T2M=\ngithub.com/chzyer/logex v1.1.10/go.mod h1:+Ywpsq7O8HXn0nuIou7OrIPyXbp3wmkHB+jjWRnGsAI=\ngithub.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e/go.mod h1:nSuG5e5PlCu98SY8svDHJxuZscDgtXS6KTTbou5AhLI=\ngithub.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1/go.mod h1:Q3SI9o4m/ZMnBNeIyt5eFwwo7qiLfzFZmjNmxjkiQlU=\ngithub.com/cilium/ebpf v0.4.0/go.mod h1:4tRaxcgiL706VnOzHOdBlY8IEAIdxINsQBcU4xJJXRs=\ngithub.com/cilium/ebpf v0.6.2/go.mod h1:4tRaxcgiL706VnOzHOdBlY8IEAIdxINsQBcU4xJJXRs=\ngithub.com/clbanning/x2j v0.0.0-20191024224557-825249438eec/go.mod h1:jMjuTZXRI4dUb/I5gc9Hdhagfvm9+RyrPryS/auMzxE=\ngithub.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=\ngithub.com/clusterhq/flocker-go v0.0.0-20160920122132-2b8b7259d313/go.mod h1:P1wt9Z3DP8O6W3rvwCt0REIlshg1InHImaLW0t3ObY0=\ngithub.com/cockroachdb/datadriven v0.0.0-20190809214429-80d97fb3cbaa/go.mod h1:zn76sxSg3SzpJ0PPJaLDCu+Bu0Lg3sKTORVIj19EIF8=\ngithub.com/cockroachdb/datadriven v0.0.0-20200714090401-bf6692d28da5/go.mod h1:h6jFvWxBdQXxjopDMZyH2UVceIRfR84bdzbkoKrsWNo=\ngithub.com/cockroachdb/errors v1.2.4/go.mod h1:rQD95gz6FARkaKkQXUksEje/d9a6wBJoCr5oaCLELYA=\ngithub.com/cockroachdb/logtags v0.0.0-20190617123548-eb05cc24525f/go.mod h1:i/u985jwjWRlyHXQbwatDASoW0RMlZ/3i9yJHE2xLkI=\ngithub.com/codahale/hdrhistogram v0.0.0-20161010025455-3a0bb77429bd/go.mod h1:sE/e/2PUdi/liOCUjSTXgM1o87ZssimdTWN964YiIeI=\ngithub.com/codegangsta/inject v0.0.0-20150114235600-33e0aa1cb7c0/go.mod h1:4Zcjuz89kmFXt9morQgcfYZAYZ5n8WHjt81YYWIwtTM=\ngithub.com/codeskyblue/go-sh v0.0.0-20190412065543-76bd3d59ff27/go.mod h1:VQx0hjo2oUeQkQUET7wRwradO6f+fN5jzXgB/zROxxE=\ngithub.com/container-storage-interface/spec v1.5.0/go.mod h1:8K96oQNkJ7pFcC2R9Z1ynGGBB1I93kcS6PGg3SsOk8s=\ngithub.com/containerd/cgroups v1.0.1/go.mod h1:0SJrPIenamHDcZhEcJMNBB85rHcUsw4f25ZfBiPYRkU=\ngithub.com/containerd/console v1.0.1/go.mod h1:XUsP6YE/mKtz6bxc+I8UiKKTP04qjQL4qcS3XoQ5xkw=\ngithub.com/containerd/console v1.0.2/go.mod h1:ytZPjGgY2oeTkAONYafi2kSj0aYggsf8acV1PGKCbzQ=\ngithub.com/containerd/containerd v1.4.9/go.mod h1:bC6axHOhabU15QhwfG7w5PipXdVtMXFTttgp+kVtyUA=\ngithub.com/containerd/containerd v1.4.11/go.mod h1:bC6axHOhabU15QhwfG7w5PipXdVtMXFTttgp+kVtyUA=\ngithub.com/containerd/continuity v0.1.0/go.mod h1:ICJu0PwR54nI0yPEnJ6jcS+J7CZAUXrLh8lPo2knzsM=\ngithub.com/containerd/fifo v1.0.0/go.mod h1:ocF/ME1SX5b1AOlWi9r677YJmCPSwwWnQ9O123vzpE4=\ngithub.com/containerd/go-runc v1.0.0/go.mod h1:cNU0ZbCgCQVZK4lgG3P+9tn9/PaJNmoDXPpoJhDR+Ok=\ngithub.com/containerd/ttrpc v1.0.2/go.mod h1:UAxOpgT9ziI0gJrmKvgcZivgxOp8iFPSk8httJEt98Y=\ngithub.com/containerd/typeurl v1.0.2/go.mod h1:9trJWW2sRlGub4wZJRTW83VtbOLS6hwcDZXTn6oPz9s=\ngithub.com/containernetworking/cni v0.8.1/go.mod h1:LGwApLUm2FpoOfxTDEeq8T9ipbpZ61X79hmU3w8FmsY=\ngithub.com/coredns/caddy v1.1.0/go.mod h1:A6ntJQlAWuQfFlsd9hvigKbo2WS0VUs2l1e2F+BawD4=\ngithub.com/coredns/corefile-migration v1.0.14/go.mod h1:XnhgULOEouimnzgn0t4WPuFDN2/PJQcTxdWKC5eXNGE=\ngithub.com/coreos/bbolt v1.3.2/go.mod h1:iRUV2dpdMOn7Bo10OQBFzIJO9kkE559Wcmn+qkEiiKk=\ngithub.com/coreos/etcd v3.3.10+incompatible/go.mod h1:uF7uidLiAD3TWHmW31ZFd/JWoc32PjwdhPthX9715RE=\ngithub.com/coreos/etcd v3.3.13+incompatible/go.mod h1:uF7uidLiAD3TWHmW31ZFd/JWoc32PjwdhPthX9715RE=\ngithub.com/coreos/go-oidc v2.1.0+incompatible h1:sdJrfw8akMnCuUlaZU3tE/uYXFgfqom8DBE9so9EBsM=\ngithub.com/coreos/go-oidc v2.1.0+incompatible/go.mod h1:CgnwVTmzoESiwO9qyAFEMiHoZ1nMCKZlZ9V6mm3/LKc=\ngithub.com/coreos/go-semver v0.2.0/go.mod h1:nnelYz7RCh+5ahJtPPxZlU+153eP4D4r3EedlOD2RNk=\ngithub.com/coreos/go-semver v0.3.0/go.mod h1:nnelYz7RCh+5ahJtPPxZlU+153eP4D4r3EedlOD2RNk=\ngithub.com/coreos/go-systemd v0.0.0-20180511133405-39ca1b05acc7/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=\ngithub.com/coreos/go-systemd v0.0.0-20190321100706-95778dfbb74e/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=\ngithub.com/coreos/go-systemd/v22 v22.1.0/go.mod h1:xO0FLkIi5MaZafQlIrOotqXZ90ih+1atmu1JpKERPPk=\ngithub.com/coreos/go-systemd/v22 v22.3.2/go.mod h1:Y58oyj3AT4RCenI/lSvhwexgC+NSVTIJ3seZv2GcEnc=\ngithub.com/coreos/pkg v0.0.0-20160727233714-3ac0863d7acf/go.mod h1:E3G3o1h8I7cfcXa63jLwjI0eiQQMgzzUDFVpN/nH/eA=\ngithub.com/coreos/pkg v0.0.0-20180928190104-399ea9e2e55f/go.mod h1:E3G3o1h8I7cfcXa63jLwjI0eiQQMgzzUDFVpN/nH/eA=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.0-20190314233015-f79a8a8ca69d/go.mod h1:maD7wRr/U5Z6m/iR4s+kqSMx2CaBsrgA7czyZG/E6dU=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.0 h1:EoUDS0afbrsXAZ9YQ9jdu/mZ2sXgT1/2yyNng4PGlyM=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.0/go.mod h1:maD7wRr/U5Z6m/iR4s+kqSMx2CaBsrgA7czyZG/E6dU=\ngithub.com/creack/pty v1.1.7/go.mod h1:lj5s0c3V2DBrqTV7llrYr5NG6My20zk30Fl46Y7DoTY=\ngithub.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/creack/pty v1.1.11 h1:07n33Z8lZxZ2qwegKbObQohDhXDQxiMMz1NOUGYlesw=\ngithub.com/creack/pty v1.1.11/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/cyphar/filepath-securejoin v0.2.2/go.mod h1:FpkQEhXnPnOthhzymB7CGsFk2G9VLXONKD9G7QGMM+4=\ngithub.com/davecgh/go-spew v0.0.0-20161028175848-04cdfd42973b/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/daviddengcn/go-colortext v0.0.0-20160507010035-511bcaf42ccd/go.mod h1:dv4zxwHi5C/8AeI+4gX4dCWOIvNi7I6JCSX0HvlKPgE=\ngithub.com/deckarep/golang-set v1.7.1/go.mod h1:93vsz/8Wt4joVM7c2AVqh+YRMiUSc14yDtF28KmMOgQ=\ngithub.com/dgrijalva/jwt-go v3.2.0+incompatible/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=\ngithub.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f h1:lO4WD4F/rVNCu3HqELle0jiPLLBs70cWOduZpkS1E78=\ngithub.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f/go.mod h1:cuUVRXasLTGF7a8hSLbxyZXjz+1KgoB3wDUb6vlszIc=\ngithub.com/dgryski/go-sip13 v0.0.0-20181026042036-e10d5fee7954/go.mod h1:vAd38F8PWV+bWy6jNmig1y/TA+kYO4g3RSRF0IAv0no=\ngithub.com/dnaeon/go-vcr v1.0.1/go.mod h1:aBB1+wY4s93YsC3HHjMBMrwTj2R9FHDzUr9KyGc8n1E=\ngithub.com/docker/distribution v2.7.1+incompatible h1:a5mlkVzth6W5A4fOsS3D2EO5BUmsJpcB+cRlLU7cSug=\ngithub.com/docker/distribution v2.7.1+incompatible/go.mod h1:J2gT2udsDAN96Uj4KfcMRqY0/ypR+oyYUYmja8H+y+w=\ngithub.com/docker/docker v20.10.7+incompatible/go.mod h1:eEKB0N0r5NX/I1kEveEz05bcu8tLC/8azJZsviup8Sk=\ngithub.com/docker/go-connections v0.4.0/go.mod h1:Gbd7IOopHjR8Iph03tsViu4nIes5XhDvyHbTtUxmeec=\ngithub.com/docker/go-units v0.3.3/go.mod h1:fgPhTUdO+D/Jk86RDLlptpiXQzgHJF7gydDDbaIK4Dk=\ngithub.com/docker/go-units v0.4.0/go.mod h1:fgPhTUdO+D/Jk86RDLlptpiXQzgHJF7gydDDbaIK4Dk=\ngithub.com/docopt/docopt-go v0.0.0-20180111231733-ee0de3bc6815/go.mod h1:WwZ+bS3ebgob9U8Nd0kOddGdZWjyMGR8Wziv+TBNwSE=\ngithub.com/dustin/go-humanize v0.0.0-20171111073723-bb3d318650d4/go.mod h1:HtrtbFcZ19U5GC7JDqmcUSB87Iq5E25KnS6fMYU6eOk=\ngithub.com/dustin/go-humanize v1.0.0 h1:VSnTsYCnlFHaM2/igO1h6X3HA71jcobQuxemgkq4zYo=\ngithub.com/dustin/go-humanize v1.0.0/go.mod h1:HtrtbFcZ19U5GC7JDqmcUSB87Iq5E25KnS6fMYU6eOk=\ngithub.com/eapache/go-resiliency v1.1.0/go.mod h1:kFI+JgMyC7bLPUVY133qvEBtVayf5mFgVsvEsIPBvNs=\ngithub.com/eapache/go-xerial-snappy v0.0.0-20180814174437-776d5712da21/go.mod h1:+020luEh2TKB4/GOp8oxxtq0Daoen/Cii55CzbTV6DU=\ngithub.com/eapache/queue v1.1.0/go.mod h1:6eCeP0CKFpHLu8blIFXhExK/dRa7WDZfr6jVFPTqq+I=\ngithub.com/edsrzf/mmap-go v1.0.0/go.mod h1:YO35OhQPt3KJa3ryjFM5Bs14WD66h8eGKpfaBNrHW5M=\ngithub.com/elazarl/goproxy v0.0.0-20180725130230-947c36da3153 h1:yUdfgN0XgIJw7foRItutHYUIhlcKzcSf5vDpdhQAKTc=\ngithub.com/elazarl/goproxy v0.0.0-20180725130230-947c36da3153/go.mod h1:/Zj4wYkgs4iZTTu3o/KG3Itv/qCCa8VVMlb3i9OVuzc=\ngithub.com/emicklei/go-restful v0.0.0-20170410110728-ff4f55a20633/go.mod h1:otzb+WCGbkyDHkqmQmT5YD2WR4BBwUdeQoFo8l/7tVs=\ngithub.com/emicklei/go-restful v2.9.5+incompatible h1:spTtZBk5DYEvbxMVutUuTyh1Ao2r4iyvLdACqsl/Ljk=\ngithub.com/emicklei/go-restful v2.9.5+incompatible/go.mod h1:otzb+WCGbkyDHkqmQmT5YD2WR4BBwUdeQoFo8l/7tVs=\ngithub.com/emirpasic/gods v1.12.0 h1:QAUIPSaCu4G+POclxeqb3F+WPpdKqFGlw36+yOzGlrg=\ngithub.com/emirpasic/gods v1.12.0/go.mod h1:YfzfFFoVP/catgzJb4IKIqXjX78Ha8FMSDh3ymbK86o=\ngithub.com/euank/go-kmsg-parser v2.0.0+incompatible/go.mod h1:MhmAMZ8V4CYH4ybgdRwPr2TU5ThnS43puaKEMpja1uw=\ngithub.com/evanphx/json-patch v0.5.2/go.mod h1:ZWS5hhDbVDyob71nXKNL0+PWn6ToqBHMikGIFbs31qQ=\ngithub.com/evanphx/json-patch v4.11.0+incompatible/go.mod h1:50XU6AFN0ol/bzJsmQLiYLvXMP4fmwYFNcr97nuDLSk=\ngithub.com/evanphx/json-patch v4.12.0+incompatible h1:4onqiflcdA9EOZ4RxV643DvftH5pOlLGNtQ5lPWQu84=\ngithub.com/evanphx/json-patch v4.12.0+incompatible/go.mod h1:50XU6AFN0ol/bzJsmQLiYLvXMP4fmwYFNcr97nuDLSk=\ngithub.com/exponent-io/jsonpath v0.0.0-20151013193312-d6023ce2651d h1:105gxyaGwCFad8crR9dcMQWvV9Hvulu6hwUh4tWPJnM=\ngithub.com/exponent-io/jsonpath v0.0.0-20151013193312-d6023ce2651d/go.mod h1:ZZMPRZwes7CROmyNKgQzC3XPs6L/G2EJLHddWejkmf4=\ngithub.com/facebookgo/ensure v0.0.0-20160127193407-b4ab57deab51/go.mod h1:Yg+htXGokKKdzcwhuNDwVvN+uBxDGXJ7G/VN1d8fa64=\ngithub.com/facebookgo/stack v0.0.0-20160209184415-751773369052/go.mod h1:UbMTZqLaRiH3MsBH8va0n7s1pQYcu3uTb8G4tygF4Zg=\ngithub.com/facebookgo/subset v0.0.0-20150612182917-8dac2c3c4870/go.mod h1:5tD+neXqOorC30/tWg0LCSkrqj/AR6gu8yY8/fpw1q0=\ngithub.com/fatih/camelcase v1.0.0 h1:hxNvNX/xYBp0ovncs8WyWZrOrpBNub/JfaMvbURyft8=\ngithub.com/fatih/camelcase v1.0.0/go.mod h1:yN2Sb0lFhZJUdVvtELVWefmrXpuZESvPmqwoZc+/fpc=\ngithub.com/fatih/color v1.7.0/go.mod h1:Zm6kSWBoL9eyXnKyktHP6abPY2pDugNf5KwzbycvMj4=\ngithub.com/fatih/color v1.10.0/go.mod h1:ELkj/draVOlAH/xkhN6mQ50Qd0MPOk5AAr3maGEBuJM=\ngithub.com/felixge/httpsnoop v1.0.1 h1:lvB5Jl89CsZtGIWuTcDM1E/vkVs49/Ml7JJe07l8SPQ=\ngithub.com/felixge/httpsnoop v1.0.1/go.mod h1:m8KPJKqk1gH5J9DgRY2ASl2lWCfGKXixSwevea8zH2U=\ngithub.com/flosch/pongo2 v0.0.0-20181225140029-79872a7b2769/go.mod h1:tbAXHifHQWNSpWbiJHpJTZH5fi3XHhDMdP//vuz9WS4=\ngithub.com/flynn/go-shlex v0.0.0-20150515145356-3f9db97f8568/go.mod h1:xEzjJPgXI435gkrCt3MPfRiAkVrwSbHsst4LCFVfpJc=\ngithub.com/fogleman/gg v1.2.1-0.20190220221249-0403632d5b90/go.mod h1:R/bRT+9gY/C5z7JzPU0zXsXHKM4/ayA+zqcVNZzPa1k=\ngithub.com/form3tech-oss/jwt-go v3.2.2+incompatible/go.mod h1:pbq4aXjuKjdthFRnoDwaVPLA+WlJuPGy+QneDUgJi2k=\ngithub.com/form3tech-oss/jwt-go v3.2.3+incompatible h1:7ZaBxOI7TMoYBfyA3cQHErNNyAWIKUMIwqxEtgHOs5c=\ngithub.com/form3tech-oss/jwt-go v3.2.3+incompatible/go.mod h1:pbq4aXjuKjdthFRnoDwaVPLA+WlJuPGy+QneDUgJi2k=\ngithub.com/franela/goblin v0.0.0-20200105215937-c9ffbefa60db/go.mod h1:7dvUGVsVBjqR7JHJk0brhHOZYGmfBYOrK0ZhYMEtBr4=\ngithub.com/franela/goreq v0.0.0-20171204163338-bcd34c9993f8/go.mod h1:ZhphrRTfi2rbfLwlschooIH4+wKKDR4Pdxhh+TRoA20=\ngithub.com/frankban/quicktest v1.11.3/go.mod h1:wRf/ReqHper53s+kmmSZizM8NamnL3IM0I9ntUbOk+k=\ngithub.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMoQvtojpjFo=\ngithub.com/fsnotify/fsnotify v1.4.9/go.mod h1:znqG4EE+3YCdAaPaxE2ZRY/06pZUdp0tY4IgpuI1SZQ=\ngithub.com/fsnotify/fsnotify v1.5.1 h1:mZcQUHVQUQWoPXXtuf9yuEXKudkV2sx1E06UadKWpgI=\ngithub.com/fsnotify/fsnotify v1.5.1/go.mod h1:T3375wBYaZdLLcVNkcVbzGHY7f1l/uK5T5Ai1i3InKU=\ngithub.com/fvbommel/sortorder v1.0.1 h1:dSnXLt4mJYH25uDDGa3biZNQsozaUWDSWeKJ0qqFfzE=\ngithub.com/fvbommel/sortorder v1.0.1/go.mod h1:uk88iVf1ovNn1iLfgUVU2F9o5eO30ui720w+kxuqRs0=\ngithub.com/gdamore/encoding v1.0.0/go.mod h1:alR0ol34c49FCSBLjhosxzcPHQbf2trDkoo5dl+VrEg=\ngithub.com/gdamore/tcell v1.3.0/go.mod h1:Hjvr+Ofd+gLglo7RYKxxnzCBmev3BzsS67MebKS4zMM=\ngithub.com/getkin/kin-openapi v0.76.0/go.mod h1:660oXbgy5JFMKreazJaQTw7o+X00qeSyhcnluiMv+Xg=\ngithub.com/getsentry/raven-go v0.2.0/go.mod h1:KungGk8q33+aIAZUIVWZDr2OfAEBsO49PX4NzFV5kcQ=\ngithub.com/ghodss/yaml v1.0.0 h1:wQHKEahhL6wmXdzwWG11gIVCkOv05bNOh+Rxn0yngAk=\ngithub.com/ghodss/yaml v1.0.0/go.mod h1:4dBDuWmgqj2HViK6kFavaiC9ZROes6MMH2rRYeMEF04=\ngithub.com/gin-contrib/sse v0.1.0/go.mod h1:RHrZQHXnP2xjPF+u1gW/2HnVO7nvIa9PG3Gm+fLHvGI=\ngithub.com/gin-gonic/gin v1.5.0/go.mod h1:Nd6IXA8m5kNZdNEHMBd93KT+mdY3+bewLgRvmCsR2Do=\ngithub.com/gliderlabs/ssh v0.2.2 h1:6zsha5zo/TWhRhwqCD3+EarCAgZ2yN28ipRnGPnwkI0=\ngithub.com/gliderlabs/ssh v0.2.2/go.mod h1:U7qILu1NlMHj9FlMhZLlkCdDnU1DBEAqr0aevW3Awn0=\ngithub.com/globalsign/mgo v0.0.0-20180905125535-1ca0a4f7cbcb/go.mod h1:xkRDCp4j0OGD1HRkm4kmhM+pmpv3AKq5SU7GMg4oO/Q=\ngithub.com/globalsign/mgo v0.0.0-20181015135952-eeefdecb41b8/go.mod h1:xkRDCp4j0OGD1HRkm4kmhM+pmpv3AKq5SU7GMg4oO/Q=\ngithub.com/go-check/check v0.0.0-20180628173108-788fd7840127/go.mod h1:9ES+weclKsC9YodN5RgxqK/VD9HM9JsCSh7rNhMZE98=\ngithub.com/go-errors/errors v1.0.1 h1:LUHzmkK3GUKUrL/1gfBUxAHzcev3apQlezX/+O7ma6w=\ngithub.com/go-errors/errors v1.0.1/go.mod h1:f4zRHt4oKfwPJE5k8C9vpYG+aDHdBFUsgrm6/TyX73Q=\ngithub.com/go-git/gcfg v1.5.0 h1:Q5ViNfGF8zFgyJWPqYwA7qGFoMTEiBmdlkcfRmpIMa4=\ngithub.com/go-git/gcfg v1.5.0/go.mod h1:5m20vg6GwYabIxaOonVkTdrILxQMpEShl1xiMF4ua+E=\ngithub.com/go-git/go-billy/v5 v5.2.0/go.mod h1:pmpqyWchKfYfrkb/UVH4otLvyi/5gJlGI4Hb3ZqZ3W0=\ngithub.com/go-git/go-billy/v5 v5.3.1 h1:CPiOUAzKtMRvolEKw+bG1PLRpT7D3LIs3/3ey4Aiu34=\ngithub.com/go-git/go-billy/v5 v5.3.1/go.mod h1:pmpqyWchKfYfrkb/UVH4otLvyi/5gJlGI4Hb3ZqZ3W0=\ngithub.com/go-git/go-git-fixtures/v4 v4.2.1 h1:n9gGL1Ct/yIw+nfsfr8s4+sbhT+Ncu2SubfXjIWgci8=\ngithub.com/go-git/go-git-fixtures/v4 v4.2.1/go.mod h1:K8zd3kDUAykwTdDCr+I0per6Y6vMiRR/nnVTBtavnB0=\ngithub.com/go-git/go-git/v5 v5.4.2 h1:BXyZu9t0VkbiHtqrsvdq39UDhGJTl1h55VW6CSC4aY4=\ngithub.com/go-git/go-git/v5 v5.4.2/go.mod h1:gQ1kArt6d+n+BGd+/B/I74HwRTLhth2+zti4ihgckDc=\ngithub.com/go-gl/glfw v0.0.0-20190409004039-e6da0acd62b1/go.mod h1:vR7hzQXu2zJy9AVAgeJqvqgH9Q5CA+iKCZ2gyEVpxRU=\ngithub.com/go-gl/glfw/v3.3/glfw v0.0.0-20191125211704-12ad95a8df72/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=\ngithub.com/go-gl/glfw/v3.3/glfw v0.0.0-20200222043503-6f7a984d4dc4/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=\ngithub.com/go-kit/kit v0.8.0/go.mod h1:xBxKIO96dXMWWy0MnWVtmwkA9/13aqxPnvrjFYMA2as=\ngithub.com/go-kit/kit v0.9.0/go.mod h1:xBxKIO96dXMWWy0MnWVtmwkA9/13aqxPnvrjFYMA2as=\ngithub.com/go-kit/kit v0.10.0/go.mod h1:xUsJbQ/Fp4kEt7AFgCuvyX4a71u8h9jB8tj/ORgOZ7o=\ngithub.com/go-kit/log v0.1.0/go.mod h1:zbhenjAZHb184qTLMA9ZjW7ThYL0H2mk7Q6pNt4vbaY=\ngithub.com/go-logfmt/logfmt v0.3.0/go.mod h1:Qt1PoO58o5twSAckw1HlFXLmHsOX5/0LbT9GBnD5lWE=\ngithub.com/go-logfmt/logfmt v0.4.0/go.mod h1:3RMwSq7FuexP4Kalkev3ejPJsZTpXXBr9+V4qmtdjCk=\ngithub.com/go-logfmt/logfmt v0.5.0/go.mod h1:wCYkCAKZfumFQihp8CzCvQ3paCTfi41vtzG1KdI/P7A=\ngithub.com/go-logr/logr v0.1.0/go.mod h1:ixOQHD9gLJUVQQ2ZOR7zLEifBX6tGkNJF4QyIY7sIas=\ngithub.com/go-logr/logr v0.2.0/go.mod h1:z6/tIYblkpsD+a4lm/fGIIU9mZ+XfAiaFtq7xTgseGU=\ngithub.com/go-logr/logr v0.3.0/go.mod h1:z6/tIYblkpsD+a4lm/fGIIU9mZ+XfAiaFtq7xTgseGU=\ngithub.com/go-logr/logr v0.4.0/go.mod h1:z6/tIYblkpsD+a4lm/fGIIU9mZ+XfAiaFtq7xTgseGU=\ngithub.com/go-logr/logr v1.0.0/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=\ngithub.com/go-logr/logr v1.2.0/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=\ngithub.com/go-logr/logr v1.2.2 h1:ahHml/yUpnlb96Rp8HCvtYVPY8ZYpxq3g7UYchIYwbs=\ngithub.com/go-logr/logr v1.2.2/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=\ngithub.com/go-logr/zapr v1.2.0 h1:n4JnPI1T3Qq1SFEi/F8rwLrZERp2bso19PJZDB9dayk=\ngithub.com/go-logr/zapr v1.2.0/go.mod h1:Qa4Bsj2Vb+FAVeAKsLD8RLQ+YRJB8YDmOAKxaBQf7Ro=\ngithub.com/go-openapi/analysis v0.0.0-20180825180245-b006789cd277/go.mod h1:k70tL6pCuVxPJOHXQ+wIac1FUrvNkHolPie/cLEU6hI=\ngithub.com/go-openapi/analysis v0.17.0/go.mod h1:IowGgpVeD0vNm45So8nr+IcQ3pxVtpRoBWb8PVZO0ik=\ngithub.com/go-openapi/analysis v0.18.0/go.mod h1:IowGgpVeD0vNm45So8nr+IcQ3pxVtpRoBWb8PVZO0ik=\ngithub.com/go-openapi/analysis v0.19.2/go.mod h1:3P1osvZa9jKjb8ed2TPng3f0i/UY9snX6gxi44djMjk=\ngithub.com/go-openapi/analysis v0.19.5 h1:8b2ZgKfKIUTVQpTb77MoRDIMEIwvDVw40o3aOXdfYzI=\ngithub.com/go-openapi/analysis v0.19.5/go.mod h1:hkEAkxagaIvIP7VTn8ygJNkd4kAYON2rCu0v0ObL0AU=\ngithub.com/go-openapi/errors v0.17.0/go.mod h1:LcZQpmvG4wyF5j4IhA73wkLFQg+QJXOQHVjmcZxhka0=\ngithub.com/go-openapi/errors v0.18.0/go.mod h1:LcZQpmvG4wyF5j4IhA73wkLFQg+QJXOQHVjmcZxhka0=\ngithub.com/go-openapi/errors v0.19.2 h1:a2kIyV3w+OS3S97zxUndRVD46+FhGOUBDFY7nmu4CsY=\ngithub.com/go-openapi/errors v0.19.2/go.mod h1:qX0BLWsyaKfvhluLejVpVNwNRdXZhEbTA4kxxpKBC94=\ngithub.com/go-openapi/jsonpointer v0.17.0/go.mod h1:cOnomiV+CVVwFLk0A/MExoFMjwdsUdVpsRhURCKh+3M=\ngithub.com/go-openapi/jsonpointer v0.18.0/go.mod h1:cOnomiV+CVVwFLk0A/MExoFMjwdsUdVpsRhURCKh+3M=\ngithub.com/go-openapi/jsonpointer v0.19.2/go.mod h1:3akKfEdA7DF1sugOqz1dVQHBcuDBPKZGEoHC/NkiQRg=\ngithub.com/go-openapi/jsonpointer v0.19.3/go.mod h1:Pl9vOtqEWErmShwVjC8pYs9cog34VGT37dQOVbmoatg=\ngithub.com/go-openapi/jsonpointer v0.19.5 h1:gZr+CIYByUqjcgeLXnQu2gHYQC9o73G2XUeOFYEICuY=\ngithub.com/go-openapi/jsonpointer v0.19.5/go.mod h1:Pl9vOtqEWErmShwVjC8pYs9cog34VGT37dQOVbmoatg=\ngithub.com/go-openapi/jsonreference v0.17.0/go.mod h1:g4xxGn04lDIRh0GJb5QlpE3HfopLOL6uZrK/VgnsK9I=\ngithub.com/go-openapi/jsonreference v0.18.0/go.mod h1:g4xxGn04lDIRh0GJb5QlpE3HfopLOL6uZrK/VgnsK9I=\ngithub.com/go-openapi/jsonreference v0.19.2/go.mod h1:jMjeRr2HHw6nAVajTXJ4eiUwohSTlpa0o73RUL1owJc=\ngithub.com/go-openapi/jsonreference v0.19.3/go.mod h1:rjx6GuL8TTa9VaixXglHmQmIL98+wF9xc8zWvFonSJ8=\ngithub.com/go-openapi/jsonreference v0.19.5 h1:1WJP/wi4OjB4iV8KVbH73rQaoialJrqv8gitZLxGLtM=\ngithub.com/go-openapi/jsonreference v0.19.5/go.mod h1:RdybgQwPxbL4UEjuAruzK1x3nE69AqPYEJeo/TWfEeg=\ngithub.com/go-openapi/loads v0.17.0/go.mod h1:72tmFy5wsWx89uEVddd0RjRWPZm92WRLhf7AC+0+OOU=\ngithub.com/go-openapi/loads v0.18.0/go.mod h1:72tmFy5wsWx89uEVddd0RjRWPZm92WRLhf7AC+0+OOU=\ngithub.com/go-openapi/loads v0.19.0/go.mod h1:72tmFy5wsWx89uEVddd0RjRWPZm92WRLhf7AC+0+OOU=\ngithub.com/go-openapi/loads v0.19.2/go.mod h1:QAskZPMX5V0C2gvfkGZzJlINuP7Hx/4+ix5jWFxsNPs=\ngithub.com/go-openapi/loads v0.19.4 h1:5I4CCSqoWzT+82bBkNIvmLc0UOsoKKQ4Fz+3VxOB7SY=\ngithub.com/go-openapi/loads v0.19.4/go.mod h1:zZVHonKd8DXyxyw4yfnVjPzBjIQcLt0CCsn0N0ZrQsk=\ngithub.com/go-openapi/runtime v0.0.0-20180920151709-4f900dc2ade9/go.mod h1:6v9a6LTXWQCdL8k1AO3cvqx5OtZY/Y9wKTgaoP6YRfA=\ngithub.com/go-openapi/runtime v0.19.0/go.mod h1:OwNfisksmmaZse4+gpV3Ne9AyMOlP1lt4sK4FXt0O64=\ngithub.com/go-openapi/runtime v0.19.4 h1:csnOgcgAiuGoM/Po7PEpKDoNulCcF3FGbSnbHfxgjMI=\ngithub.com/go-openapi/runtime v0.19.4/go.mod h1:X277bwSUBxVlCYR3r7xgZZGKVvBd/29gLDlFGtJ8NL4=\ngithub.com/go-openapi/spec v0.17.0/go.mod h1:XkF/MOi14NmjsfZ8VtAKf8pIlbZzyoTvZsdfssdxcBI=\ngithub.com/go-openapi/spec v0.18.0/go.mod h1:XkF/MOi14NmjsfZ8VtAKf8pIlbZzyoTvZsdfssdxcBI=\ngithub.com/go-openapi/spec v0.19.2/go.mod h1:sCxk3jxKgioEJikev4fgkNmwS+3kuYdJtcsZsD5zxMY=\ngithub.com/go-openapi/spec v0.19.3/go.mod h1:FpwSN1ksY1eteniUU7X0N/BgJ7a4WvBFVA8Lj9mJglo=\ngithub.com/go-openapi/spec v0.19.5 h1:Xm0Ao53uqnk9QE/LlYV5DEU09UAgpliA85QoT9LzqPw=\ngithub.com/go-openapi/spec v0.19.5/go.mod h1:Hm2Jr4jv8G1ciIAo+frC/Ft+rR2kQDh8JHKHb3gWUSk=\ngithub.com/go-openapi/strfmt v0.17.0/go.mod h1:P82hnJI0CXkErkXi8IKjPbNBM6lV6+5pLP5l494TcyU=\ngithub.com/go-openapi/strfmt v0.18.0/go.mod h1:P82hnJI0CXkErkXi8IKjPbNBM6lV6+5pLP5l494TcyU=\ngithub.com/go-openapi/strfmt v0.19.0/go.mod h1:+uW+93UVvGGq2qGaZxdDeJqSAqBqBdl+ZPMF/cC8nDY=\ngithub.com/go-openapi/strfmt v0.19.3 h1:eRfyY5SkaNJCAwmmMcADjY31ow9+N7MCLW7oRkbsINA=\ngithub.com/go-openapi/strfmt v0.19.3/go.mod h1:0yX7dbo8mKIvc3XSKp7MNfxw4JytCfCD6+bY1AVL9LU=\ngithub.com/go-openapi/swag v0.17.0/go.mod h1:AByQ+nYG6gQg71GINrmuDXCPWdL640yX49/kXLo40Tg=\ngithub.com/go-openapi/swag v0.18.0/go.mod h1:AByQ+nYG6gQg71GINrmuDXCPWdL640yX49/kXLo40Tg=\ngithub.com/go-openapi/swag v0.19.2/go.mod h1:POnQmlKehdgb5mhVOsnJFsivZCEZ/vjK9gh66Z9tfKk=\ngithub.com/go-openapi/swag v0.19.5/go.mod h1:POnQmlKehdgb5mhVOsnJFsivZCEZ/vjK9gh66Z9tfKk=\ngithub.com/go-openapi/swag v0.19.14 h1:gm3vOOXfiuw5i9p5N9xJvfjvuofpyvLA9Wr6QfK5Fng=\ngithub.com/go-openapi/swag v0.19.14/go.mod h1:QYRuS/SOXUCsnplDa677K7+DxSOj6IPNl/eQntq43wQ=\ngithub.com/go-openapi/validate v0.18.0/go.mod h1:Uh4HdOzKt19xGIGm1qHf/ofbX1YQ4Y+MYsct2VUrAJ4=\ngithub.com/go-openapi/validate v0.19.2/go.mod h1:1tRCw7m3jtI8eNWEEliiAqUIcBztB2KDnRCRMUi7GTA=\ngithub.com/go-openapi/validate v0.19.5 h1:QhCBKRYqZR+SKo4gl1lPhPahope8/RLt6EVgY8X80w0=\ngithub.com/go-openapi/validate v0.19.5/go.mod h1:8DJv2CVJQ6kGNpFW6eV9N3JviE1C85nY1c2z52x1Gk4=\ngithub.com/go-ozzo/ozzo-validation v3.5.0+incompatible/go.mod h1:gsEKFIVnabGBt6mXmxK0MoFy+cZoTJY6mu5Ll3LVLBU=\ngithub.com/go-playground/locales v0.12.1/go.mod h1:IUMDtCfWo/w/mtMfIE/IG2K+Ey3ygWanZIBtBW0W2TM=\ngithub.com/go-playground/universal-translator v0.16.0/go.mod h1:1AnU7NaIRDWWzGEKwgtJRd2xk99HeFyHw3yid4rvQIY=\ngithub.com/go-redis/cache/v8 v8.4.2 h1:8YbsmnU1Ws3TKS6T+qALzYE/MlGE+A/lrlx1XTA3p6M=\ngithub.com/go-redis/cache/v8 v8.4.2/go.mod h1:X7Jjd69Ssbrf3xBQLtIDE0g3WcSbFoQiSGeb8QfEJ+g=\ngithub.com/go-redis/redis/v8 v8.11.3 h1:GCjoYp8c+yQTJfc0n69iwSiHjvuAdruxl7elnZCxgt8=\ngithub.com/go-redis/redis/v8 v8.11.3/go.mod h1:xNJ9xDG09FsIPwh3bWdk+0oDWHbtF9rPN0F/oD9XeKc=\ngithub.com/go-sql-driver/mysql v1.4.0/go.mod h1:zAC/RDZ24gD3HViQzih4MyKcchzm+sOG5ZlKdlhCg5w=\ngithub.com/go-sql-driver/mysql v1.5.0/go.mod h1:DCzpHaOWr8IXmIStZouvnhqoel9Qv2LBy8hT2VhHyBg=\ngithub.com/go-stack/stack v1.8.0 h1:5SgMzNM5HxrEjV0ww2lTmX6E2Izsfxas4+YHWRs3Lsk=\ngithub.com/go-stack/stack v1.8.0/go.mod h1:v0f6uXyyMGvRgIKkXu+yp6POWl0qKG85gN/melR3HDY=\ngithub.com/go-task/slim-sprig v0.0.0-20210107165309-348f09dbbbc0/go.mod h1:fyg7847qk6SyHyPtNmDHnmrv/HOrqktSC+C9fM+CJOE=\ngithub.com/go-telegram-bot-api/telegram-bot-api/v5 v5.4.0 h1:Mr3JcvBjQEhCN9wld6OHKHuHxWaoXTaQfYKmj7QwP18=\ngithub.com/go-telegram-bot-api/telegram-bot-api/v5 v5.4.0/go.mod h1:A2S0CWkNylc2phvKXWBBdD3K0iGnDBGbzRpISP2zBl8=\ngithub.com/go-test/deep v1.0.4 h1:u2CU3YKy9I2pmu9pX0eq50wCgjfGIt539SqR7FbHiho=\ngithub.com/go-test/deep v1.0.4/go.mod h1:wGDj63lr65AM2AQyKZd/NYHGb0R+1RLqB8NKt3aSFNA=\ngithub.com/gobuffalo/envy v1.7.0/go.mod h1:n7DRkBerg/aorDM8kbduw5dN3oXGswK5liaSCx4T5NI=\ngithub.com/gobwas/glob v0.2.3 h1:A4xDbljILXROh+kObIiy5kIaPYD8e96x1tgBhUI5J+Y=\ngithub.com/gobwas/glob v0.2.3/go.mod h1:d3Ez4x06l9bZtSvzIay5+Yzi0fmZzPgnTbPcKjJAkT8=\ngithub.com/godbus/dbus/v5 v5.0.3/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=\ngithub.com/godbus/dbus/v5 v5.0.4/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=\ngithub.com/gofrs/uuid v4.0.0+incompatible/go.mod h1:b2aQJv3Z4Fp6yNu3cdSllBxTCLRxnplIgP/c0N/04lM=\ngithub.com/gogits/go-gogs-client v0.0.0-20190616193657-5a05380e4bc2 h1:BbwX8wsMRDZRdNYxAna+4ls3wvMKJyn4PT6Zk1CPxP4=\ngithub.com/gogits/go-gogs-client v0.0.0-20190616193657-5a05380e4bc2/go.mod h1:cY2AIrMgHm6oOHmR7jY+9TtjzSjQ3iG7tURJG3Y6XH0=\ngithub.com/gogo/protobuf v1.1.1/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=\ngithub.com/gogo/protobuf v1.2.0/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=\ngithub.com/gogo/protobuf v1.2.1/go.mod h1:hp+jE20tsWTFYpLwKvXlhS1hjn+gTNwPg2I6zVXpSg4=\ngithub.com/gogo/protobuf v1.3.1/go.mod h1:SlYgWuQ5SjCEi6WLHjHCa1yvBfUnHcTbrrZtXPKa29o=\ngithub.com/gogo/protobuf v1.3.2 h1:Ov1cvc58UF3b5XjBnZv7+opcTcQFZebYjWzi34vdm4Q=\ngithub.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69NZV8Q=\ngithub.com/golang-jwt/jwt/v4 v4.0.0/go.mod h1:/xlHOz8bRuivTWchD4jCa+NbatV+wEUSzwAxVc6locg=\ngithub.com/golang-jwt/jwt/v4 v4.2.0 h1:besgBTC8w8HjP6NzQdxwKH9Z5oQMZ24ThTrHp3cZ8eU=\ngithub.com/golang-jwt/jwt/v4 v4.2.0/go.mod h1:/xlHOz8bRuivTWchD4jCa+NbatV+wEUSzwAxVc6locg=\ngithub.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0/go.mod h1:E/TSTwGwJL78qG/PmXZO1EjYhfJinVAhrmmHX6Z8B9k=\ngithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=\ngithub.com/golang/glog v1.0.0 h1:nfP3RFugxnNRyKgeWd4oI1nYvXpxrx8ck8ZrcizshdQ=\ngithub.com/golang/glog v1.0.0/go.mod h1:EWib/APOK0SL3dFbYqvxE3UYd8E6s1ouQ7iEp/0LWV4=\ngithub.com/golang/groupcache v0.0.0-20160516000752-02826c3e7903/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/groupcache v0.0.0-20190129154638-5b532d6fd5ef/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/groupcache v0.0.0-20190702054246-869f871628b6/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/groupcache v0.0.0-20191227052852-215e87163ea7/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/groupcache v0.0.0-20200121045136-8c9f03a8e57e/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da h1:oI5xCqsCo564l8iNU+DwB5epxmsaqB+rhGL0m5jtYqE=\ngithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/lint v0.0.0-20180702182130-06c8688daad7/go.mod h1:tluoj9z5200jBnyusfRPU2LqT6J+DAorxEvtC7LHB+E=\ngithub.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/mock v1.2.0/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/mock v1.3.1/go.mod h1:sBzyDLLjw3U8JLTeZvSv8jJB+tU5PVekmnlKIyFUx0Y=\ngithub.com/golang/mock v1.4.0/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=\ngithub.com/golang/mock v1.4.1/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=\ngithub.com/golang/mock v1.4.3/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=\ngithub.com/golang/mock v1.4.4/go.mod h1:l3mdAwkq5BuhzHwde/uurv3sEJeZMXNpwsxVWU71h+4=\ngithub.com/golang/mock v1.5.0 h1:jlYHihg//f7RRwuPfptm04yp4s7O6Kw8EZiVYIGcH0g=\ngithub.com/golang/mock v1.5.0/go.mod h1:CWnOUgYIOo4TcNZ0wHX3YZCqsaM1I1Jvs6v3mP3KVu8=\ngithub.com/golang/protobuf v1.4.2 h1:+Z5KGCizgyZCbGh1KZqA0fcLLkwbsjIzS4aV2v7wJX0=\ngithub.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=\ngithub.com/golang/snappy v0.0.0-20180518054509-2e65f85255db/go.mod h1:/XxbfmMg8lxefKM7IXC3fBNl/7bRcc72aCRzEWrmP2Q=\ngithub.com/golangplus/testing v0.0.0-20180327235837-af21d9c3145e/go.mod h1:0AA//k/eakGydO4jKRoRL2j92ZKSzTgj9tclaCrvXHk=\ngithub.com/gomodule/redigo v2.0.0+incompatible h1:K/R+8tc58AaqLkqG2Ol3Qk+DR/TlNuhuh457pBFPtt0=\ngithub.com/gomodule/redigo v2.0.0+incompatible/go.mod h1:B4C85qUVwatsJoIUNIfCRsp7qO0iAmpGFZ4EELWSbC4=\ngithub.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\ngithub.com/google/btree v1.0.0/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\ngithub.com/google/btree v1.0.1 h1:gK4Kx5IaGY9CD5sPJ36FHiBJ6ZXl0kilRiiCj+jdYp4=\ngithub.com/google/btree v1.0.1/go.mod h1:xXMiIv4Fb/0kKde4SpL7qlzvu5cMJDRkFDxJfI9uaxA=\ngithub.com/google/cadvisor v0.43.0/go.mod h1:+RdMSbc3FVr5NYCD2dOEJy/LI0jYJ/0xJXkzWXEyiFQ=\ngithub.com/google/cel-go v0.9.0/go.mod h1:U7ayypeSkw23szu4GaQTPJGx66c20mx8JklMSxrmI1w=\ngithub.com/google/cel-spec v0.6.0/go.mod h1:Nwjgxy5CbjlPrtCWjeDjUyKMl8w41YBYGjsyDdqk0xA=\ngithub.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=\ngithub.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.4.1/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.1/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.2/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.3/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.4/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.6 h1:BKbKCqvP6I+rmFHt06ZmyQtvB8xAkWdhFyr0ZUNZcxQ=\ngithub.com/google/go-cmp v0.5.6/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-github/v41 v41.0.0 h1:HseJrM2JFf2vfiZJ8anY2hqBjdfY1Vlj/K27ueww4gg=\ngithub.com/google/go-github/v41 v41.0.0/go.mod h1:XgmCA5H323A9rtgExdTcnDkcqp6S30AVACCBDOonIxg=\ngithub.com/google/go-jsonnet v0.18.0 h1:/6pTy6g+Jh1a1I2UMoAODkqELFiVIdOxbNwv0DDzoOg=\ngithub.com/google/go-jsonnet v0.18.0/go.mod h1:C3fTzyVJDslXdiTqw/bTFk7vSGyCtH3MGRbDfvEwGd0=\ngithub.com/google/go-querystring v1.0.0/go.mod h1:odCYkC5MyYFN7vkCjXpyrEuKhc/BUO6wN/zVPAxq5ck=\ngithub.com/google/go-querystring v1.1.0 h1:AnCroh3fv4ZBgVIf1Iwtovgjaw/GiKJo8M8yD/fhyJ8=\ngithub.com/google/go-querystring v1.1.0/go.mod h1:Kcdr2DB4koayq7X8pmAG4sNG59So17icRSOU623lUBU=\ngithub.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=\ngithub.com/google/gofuzz v1.1.0 h1:Hsa8mG0dQ46ij8Sl2AYJDUv1oA9/d6Vk+3LG99Oe02g=\ngithub.com/google/gofuzz v1.1.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=\ngithub.com/google/martian v2.1.0+incompatible/go.mod h1:9I4somxYTbIHy5NJKHRl3wXiIaQGbYVAs8BPL6v8lEs=\ngithub.com/google/martian/v3 v3.0.0/go.mod h1:y5Zk1BBys9G+gd6Jrk0W3cC1+ELVxBWuIGO+w/tUAp0=\ngithub.com/google/martian/v3 v3.1.0/go.mod h1:y5Zk1BBys9G+gd6Jrk0W3cC1+ELVxBWuIGO+w/tUAp0=\ngithub.com/google/pprof v0.0.0-20181206194817-3ea8567a2e57/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=\ngithub.com/google/pprof v0.0.0-20190515194954-54271f7e092f/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=\ngithub.com/google/pprof v0.0.0-20191218002539-d4f498aebedc/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/pprof v0.0.0-20200212024743-f11f1df84d12/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/pprof v0.0.0-20200229191704-1ebb73c60ed3/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/pprof v0.0.0-20200430221834-fc25d7d30c6d/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/pprof v0.0.0-20200708004538-1a94d8640e99/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/pprof v0.0.0-20201023163331-3e6fc7fc9c4c/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=\ngithub.com/google/pprof v0.0.0-20201203190320-1bf35d6f28c2/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=\ngithub.com/google/pprof v0.0.0-20210122040257-d980be63207e/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=\ngithub.com/google/pprof v0.0.0-20210226084205-cbba55b83ad5/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=\ngithub.com/google/renameio v0.1.0/go.mod h1:KWCgfxg9yswjAJkECMjeO8J8rahYeXnNhOm40UhjYkI=\ngithub.com/google/shlex v0.0.0-20191202100458-e7afc7fbc510 h1:El6M4kTTCOh6aBiKaUGG7oYTSPP8MxqL4YI3kZKwcP4=\ngithub.com/google/shlex v0.0.0-20191202100458-e7afc7fbc510/go.mod h1:pupxD2MaaD3pAXIBCelhxNneeOaAeabZDe5s4K6zSpQ=\ngithub.com/google/uuid v1.0.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/google/uuid v1.1.1/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/google/uuid v1.1.2 h1:EVhdT+1Kseyi1/pUmXKaFxYsDNy9RQYkMWRH68J/W7Y=\ngithub.com/google/uuid v1.1.2/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/googleapis/gax-go/v2 v2.0.4/go.mod h1:0Wqv26UfaUD9n4G6kQubkQ+KchISgw+vpHVxEJEs9eg=\ngithub.com/googleapis/gax-go/v2 v2.0.5/go.mod h1:DWXyrwAJ9X0FpwwEdw+IPEYBICEFu5mhpdKc/us6bOk=\ngithub.com/googleapis/gnostic v0.5.1/go.mod h1:6U4PtQXGIEt/Z3h5MAT7FNofLnw9vXk2cUuW7uA/OeU=\ngithub.com/googleapis/gnostic v0.5.5 h1:9fHAtK0uDfpveeqqo1hkEZJcFvYXAiCN3UutL8F9xHw=\ngithub.com/googleapis/gnostic v0.5.5/go.mod h1:7+EbHbldMins07ALC74bsA81Ovc97DwqyJO1AENw9kA=\ngithub.com/gopackage/ddp v0.0.0-20170117053602-652027933df4 h1:4EZlYQIiyecYJlUbVkFXCXHz1QPhVXcHnQKAzBTPfQo=\ngithub.com/gopackage/ddp v0.0.0-20170117053602-652027933df4/go.mod h1:lEO7XoHJ/xNRBCxrn4h/CEB67h0kW1B0t4ooP2yrjUA=\ngithub.com/gophercloud/gophercloud v0.1.0/go.mod h1:vxM41WHh5uqHVBMZHzuwNOHh8XEoIEcSTewFxm1c5g8=\ngithub.com/gopherjs/gopherjs v0.0.0-20181017120253-0766667cb4d1/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=\ngithub.com/gopherjs/gopherjs v0.0.0-20200217142428-fce0ec30dd00/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=\ngithub.com/gorilla/context v1.1.1/go.mod h1:kBGZzfjB9CEq2AlWe17Uuf7NDRt0dE0s8S51q0aT7Yg=\ngithub.com/gorilla/handlers v1.5.1 h1:9lRY6j8DEeeBT10CvO9hGW0gmky0BprnvDI5vfhUHH4=\ngithub.com/gorilla/handlers v1.5.1/go.mod h1:t8XrUpc4KVXb7HGyJ4/cEnwQiaxrX/hz1Zv/4g96P1Q=\ngithub.com/gorilla/mux v1.6.2/go.mod h1:1lud6UwP+6orDFRuTfBEV8e9/aOM/c4fVVCaMa2zaAs=\ngithub.com/gorilla/mux v1.7.3/go.mod h1:1lud6UwP+6orDFRuTfBEV8e9/aOM/c4fVVCaMa2zaAs=\ngithub.com/gorilla/mux v1.7.4/go.mod h1:DVbg23sWSpFRCP0SfiEN6jmj59UnW/n46BH5rLB71So=\ngithub.com/gorilla/mux v1.8.0/go.mod h1:DVbg23sWSpFRCP0SfiEN6jmj59UnW/n46BH5rLB71So=\ngithub.com/gorilla/websocket v1.4.2 h1:+/TMaTYc4QFitKJxsQ7Yye35DkWvkdLcvGKqM+x0Ufc=\ngithub.com/gorilla/websocket v1.4.2/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=\ngithub.com/gregdel/pushover v1.1.0 h1:dwHyvrcpZCOS9V1fAnKPaGRRI5OC55cVaKhMybqNsKQ=\ngithub.com/gregdel/pushover v1.1.0/go.mod h1:EcaO66Nn1StkpEm1iKtBTV3d2A16SoMsVER1PthX7to=\ngithub.com/gregjones/httpcache v0.0.0-20180305231024-9cad4c3443a7/go.mod h1:FecbI9+v66THATjSRHfNgh1IVFe/9kFxbXtjV0ctIMA=\ngithub.com/gregjones/httpcache v0.0.0-20190611155906-901d90724c79 h1:+ngKgrYPPJrOjhax5N+uePQ0Fh1Z7PheYoUI/0nzkPA=\ngithub.com/gregjones/httpcache v0.0.0-20190611155906-901d90724c79/go.mod h1:FecbI9+v66THATjSRHfNgh1IVFe/9kFxbXtjV0ctIMA=\ngithub.com/grpc-ecosystem/go-grpc-middleware v1.0.0/go.mod h1:FiyG127CGDf3tlThmgyCl78X/SZQqEOJBCDaAfeWzPs=\ngithub.com/grpc-ecosystem/go-grpc-middleware v1.0.1-0.20190118093823-f849b5445de4/go.mod h1:FiyG127CGDf3tlThmgyCl78X/SZQqEOJBCDaAfeWzPs=\ngithub.com/grpc-ecosystem/go-grpc-middleware v1.3.0 h1:+9834+KizmvFV7pXQGSXQTsaWhq2GjuNUt0aUU0YBYw=\ngithub.com/grpc-ecosystem/go-grpc-middleware v1.3.0/go.mod h1:z0ButlSOZa5vEBq9m2m2hlwIgKw+rp3sdCBRoJY+30Y=\ngithub.com/grpc-ecosystem/go-grpc-prometheus v1.2.0 h1:Ovs26xHkKqVztRpIrF/92BcuyuQ/YW4NSIpoGtfXNho=\ngithub.com/grpc-ecosystem/go-grpc-prometheus v1.2.0/go.mod h1:8NvIoxWQoOIhqOTXgfV/d3M/q6VIi02HzZEHgUlZvzk=\ngithub.com/grpc-ecosystem/grpc-gateway v1.16.0 h1:gmcG1KaJ57LophUzW0Hy8NmPhnMZb4M0+kPpLofRdBo=\ngithub.com/grpc-ecosystem/grpc-gateway v1.16.0/go.mod h1:BDjrQk3hbvj6Nolgz8mAMFbcEtjT1g+wF4CSlocrBnw=\ngithub.com/hashicorp/consul/api v1.1.0/go.mod h1:VmuI/Lkw1nC05EYQWNKwWGbkg+FbDBtguAZLlVdkD9Q=\ngithub.com/hashicorp/consul/api v1.3.0/go.mod h1:MmDNSzIMUjNpY/mQ398R4bk2FnqQLoPndWW5VkKPlCE=\ngithub.com/hashicorp/consul/sdk v0.1.1/go.mod h1:VKf9jXwCTEY1QZP2MOLRhb5i/I/ssyNV1vwHyQBF0x8=\ngithub.com/hashicorp/consul/sdk v0.3.0/go.mod h1:VKf9jXwCTEY1QZP2MOLRhb5i/I/ssyNV1vwHyQBF0x8=\ngithub.com/hashicorp/errwrap v1.0.0/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=\ngithub.com/hashicorp/go-cleanhttp v0.5.0/go.mod h1:JpRdi6/HCYpAwUzNwuwqhbovhLtngrth3wmdIIUrZ80=\ngithub.com/hashicorp/go-cleanhttp v0.5.1 h1:dH3aiDG9Jvb5r5+bYHsikaOUIpcM0xvgMXVoDkXMzJM=\ngithub.com/hashicorp/go-cleanhttp v0.5.1/go.mod h1:JpRdi6/HCYpAwUzNwuwqhbovhLtngrth3wmdIIUrZ80=\ngithub.com/hashicorp/go-hclog v0.9.2 h1:CG6TE5H9/JXsFWJCfoIVpKFIkFe6ysEuHirp4DxCsHI=\ngithub.com/hashicorp/go-hclog v0.9.2/go.mod h1:5CU+agLiy3J7N7QjHK5d05KxGsuXiQLrjA0H7acj2lQ=\ngithub.com/hashicorp/go-immutable-radix v1.0.0/go.mod h1:0y9vanUI8NX6FsYoO3zeMjhV/C5i9g4Q3DwcSNZ4P60=\ngithub.com/hashicorp/go-msgpack v0.5.3/go.mod h1:ahLV/dePpqEmjfWmKiqvPkv/twdG7iPBM1vqhUKIvfM=\ngithub.com/hashicorp/go-multierror v1.0.0/go.mod h1:dHtQlpGsu+cZNNAkkCN/P3hoUDHhCYQXV3UM06sGGrk=\ngithub.com/hashicorp/go-retryablehttp v0.5.1/go.mod h1:9B5zBasrRhHXnJnui7y6sL7es7NDiJgTc6Er0maI1Xs=\ngithub.com/hashicorp/go-retryablehttp v0.7.0 h1:eu1EI/mbirUgP5C8hVsTNaGZreBDlYiwC1FZWkvQPQ4=\ngithub.com/hashicorp/go-retryablehttp v0.7.0/go.mod h1:vAew36LZh98gCBJNLH42IQ1ER/9wtLZZ8meHqQvEYWY=\ngithub.com/hashicorp/go-rootcerts v1.0.0/go.mod h1:K6zTfqpRlCUIjkwsN4Z+hiSfzSTQa6eBIzfwKfwNnHU=\ngithub.com/hashicorp/go-sockaddr v1.0.0/go.mod h1:7Xibr9yA9JjQq1JpNB2Vw7kxv8xerXegt+ozgdvDeDU=\ngithub.com/hashicorp/go-syslog v1.0.0/go.mod h1:qPfqrKkXGihmCqbJM2mZgkZGvKG1dFdvsLplgctolz4=\ngithub.com/hashicorp/go-uuid v1.0.0/go.mod h1:6SBZvOh/SIDV7/2o3Jml5SYk/TvGqwFJ/bN7x4byOro=\ngithub.com/hashicorp/go-uuid v1.0.1/go.mod h1:6SBZvOh/SIDV7/2o3Jml5SYk/TvGqwFJ/bN7x4byOro=\ngithub.com/hashicorp/go-version v1.2.0/go.mod h1:fltr4n8CU8Ke44wwGCBoEymUuxUHl09ZGVZPK5anwXA=\ngithub.com/hashicorp/go.net v0.0.1/go.mod h1:hjKkEWcCURg++eb33jQU7oqQcI9XDCnUzHA0oac0k90=\ngithub.com/hashicorp/golang-lru v0.5.0/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\ngithub.com/hashicorp/golang-lru v0.5.1/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\ngithub.com/hashicorp/hcl v1.0.0/go.mod h1:E5yfLk+7swimpb2L/Alb/PJmXilQ/rhwaUYs4T20WEQ=\ngithub.com/hashicorp/logutils v1.0.0/go.mod h1:QIAnNjmIWmVIIkWDTG1z5v++HQmx9WQRO+LraFDTW64=\ngithub.com/hashicorp/mdns v1.0.0/go.mod h1:tL+uN++7HEJ6SQLQ2/p+z2pH24WQKWjBPkE0mNTz8vQ=\ngithub.com/hashicorp/memberlist v0.1.3/go.mod h1:ajVTdAv/9Im8oMAAj5G31PhhMCZJV2pPBoIllUwCN7I=\ngithub.com/hashicorp/serf v0.8.2/go.mod h1:6hOLApaqBFA1NXqRQAsxw9QxuDEvNxSQRwA/JwenrHc=\ngithub.com/heketi/heketi v10.3.0+incompatible/go.mod h1:bB9ly3RchcQqsQ9CpyaQwvva7RS5ytVoSoholZQON6o=\ngithub.com/heketi/tests v0.0.0-20151005000721-f3775cbcefd6/go.mod h1:xGMAM8JLi7UkZt1i4FQeQy0R2T8GLUwQhOP5M1gBhy4=\ngithub.com/howeyc/gopass v0.0.0-20170109162249-bf9dde6d0d2c/go.mod h1:lADxMC39cJJqL93Duh1xhAs4I2Zs8mKS89XWXFGp9cs=\ngithub.com/hpcloud/tail v1.0.0/go.mod h1:ab1qPbhIpdTxEkNHXyeSf5vhxWSCs/tWer42PpOxQnU=\ngithub.com/huandu/xstrings v1.3.0 h1:gvV6jG9dTgFEncxo+AF7PH6MZXi/vZl25owA/8Dg8Wo=\ngithub.com/huandu/xstrings v1.3.0/go.mod h1:y5/lhBue+AyNmUVz9RLU9xbLR0o4KIIExikq4ovT0aE=\ngithub.com/hudl/fargo v1.3.0/go.mod h1:y3CKSmjA+wD2gak7sUSXTAoopbhU08POFhmITJgmKTg=\ngithub.com/ianlancetaylor/demangle v0.0.0-20181102032728-5e5cf60278f6/go.mod h1:aSSvb/t6k1mPoxDqO4vJh6VOCGPwU4O0C2/Eqndh1Sc=\ngithub.com/ianlancetaylor/demangle v0.0.0-20200824232613-28f6c0f3b639/go.mod h1:aSSvb/t6k1mPoxDqO4vJh6VOCGPwU4O0C2/Eqndh1Sc=\ngithub.com/imdario/mergo v0.3.5/go.mod h1:2EnlNZ0deacrJVfApfmtdGgDfMuh/nq6Ok1EcJh5FfA=\ngithub.com/imdario/mergo v0.3.8/go.mod h1:2EnlNZ0deacrJVfApfmtdGgDfMuh/nq6Ok1EcJh5FfA=\ngithub.com/imdario/mergo v0.3.12 h1:b6R2BslTbIEToALKP7LxUvijTsNI9TAe80pLWN2g/HU=\ngithub.com/imdario/mergo v0.3.12/go.mod h1:jmQim1M+e3UYxmgPu/WyfjB3N3VflVyUjjjwH0dnCYA=\ngithub.com/improbable-eng/grpc-web v0.0.0-20181111100011-16092bd1d58a h1:RweVA0vnEyStwtAelyGmnU8ENDnwd1Q7pQr7U3J/rXo=\ngithub.com/improbable-eng/grpc-web v0.0.0-20181111100011-16092bd1d58a/go.mod h1:6hRR09jOEG81ADP5wCQju1z71g6OL4eEvELdran/3cs=\ngithub.com/inconshreveable/mousetrap v1.0.0 h1:Z8tu5sraLXCXIcARxBp/8cbvlwVa7Z1NHg9XEKhtSvM=\ngithub.com/inconshreveable/mousetrap v1.0.0/go.mod h1:PxqpIevigyE2G7u3NXJIT2ANytuPF1OarO4DADm73n8=\ngithub.com/influxdata/influxdb1-client v0.0.0-20191209144304-8bf82d3c094d/go.mod h1:qj24IKcXYK6Iy9ceXlo3Tc+vtHo9lIhSX5JddghvEPo=\ngithub.com/ishidawataru/sctp v0.0.0-20190723014705-7c296d48a2b5/go.mod h1:DM4VvS+hD/kDi1U1QsX2fnZowwBhqD0Dk3bRPKF/Oc8=\ngithub.com/itchyny/go-flags v1.5.0/go.mod h1:lenkYuCobuxLBAd/HGFE4LRoW8D3B6iXRQfWYJ+MNbA=\ngithub.com/itchyny/gojq v0.12.3 h1:s7jTCyOk/dy5bnDIScj24YX4Cr1yhEO2iW/bQT4Pm2s=\ngithub.com/itchyny/gojq v0.12.3/go.mod h1:mi4PdXSlFllHyByM68JKUrbiArtEdEnNEmjbwxcQKAg=\ngithub.com/itchyny/timefmt-go v0.1.2 h1:q0Xa4P5it6K6D7ISsbLAMwx1PnWlixDcJL6/sFs93Hs=\ngithub.com/itchyny/timefmt-go v0.1.2/go.mod h1:0osSSCQSASBJMsIZnhAaF1C2fCBTJZXrnj37mG8/c+A=\ngithub.com/jaytaylor/html2text v0.0.0-20190408195923-01ec452cbe43/go.mod h1:CVKlgaMiht+LXvHG173ujK6JUhZXKb2u/BQtjPDIvyk=\ngithub.com/jbenet/go-context v0.0.0-20150711004518-d14ea06fba99 h1:BQSFePA1RWJOlocH6Fxy8MmwDt+yVQYULKfN0RoTN8A=\ngithub.com/jbenet/go-context v0.0.0-20150711004518-d14ea06fba99/go.mod h1:1lJo3i6rXxKeerYnT8Nvf0QmHCRC1n8sfWVwXF2Frvo=\ngithub.com/jessevdk/go-flags v1.4.0/go.mod h1:4FA24M0QyGHXBuZZK/XkWh8h0e1EYbRYJSGM75WSRxI=\ngithub.com/jessevdk/go-flags v1.5.0/go.mod h1:Fw0T6WPc1dYxT4mKEZRfG5kJhaTDP9pj1c2EWnYs/m4=\ngithub.com/jmespath/go-jmespath v0.0.0-20180206201540-c2b33e8439af/go.mod h1:Nht3zPeWKUH0NzdCt2Blrr5ys8VGpn0CEB0cQHVjt7k=\ngithub.com/jmespath/go-jmespath v0.3.0/go.mod h1:9QtRXoHjLGCJ5IBSaohpXITPlowMeeYCZ7fLUTSywik=\ngithub.com/jmespath/go-jmespath v0.4.0/go.mod h1:T8mJZnbsbmF+m6zOOFylbeCJqk5+pHWvzYPziyZiYoo=\ngithub.com/jmespath/go-jmespath/internal/testify v1.5.1/go.mod h1:L3OGu8Wl2/fWfCI6z80xFu9LTZmf1ZRjMHUOPmWr69U=\ngithub.com/joho/godotenv v1.3.0/go.mod h1:7hK45KPybAkOC6peb+G5yklZfMxEjkZhHbwpqxOKXbg=\ngithub.com/jonboulle/clockwork v0.1.0/go.mod h1:Ii8DK3G1RaLaWxj9trq07+26W01tbo22gdxWY5EU2bo=\ngithub.com/jonboulle/clockwork v0.2.2 h1:UOGuzwb1PwsrDAObMuhUnj0p5ULPj8V/xJ7Kx9qUBdQ=\ngithub.com/jonboulle/clockwork v0.2.2/go.mod h1:Pkfl5aHPm1nk2H9h0bjmnJD/BcgbGXUBGnn1kMkgxc8=\ngithub.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=\ngithub.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=\ngithub.com/jpillora/backoff v1.0.0/go.mod h1:J/6gKK9jxlEcS3zixgDgUAsiuZ7yrSoa/FX5e0EB2j4=\ngithub.com/json-iterator/go v1.1.6/go.mod h1:+SdeFBvtyEkXs7REEP0seUULqWtbJapLOCVDaaPEHmU=\ngithub.com/json-iterator/go v1.1.7/go.mod h1:KdQUCv79m/52Kvf8AW2vK1V8akMuk1QjK/uOdHXbAo4=\ngithub.com/json-iterator/go v1.1.8/go.mod h1:KdQUCv79m/52Kvf8AW2vK1V8akMuk1QjK/uOdHXbAo4=\ngithub.com/json-iterator/go v1.1.10/go.mod h1:KdQUCv79m/52Kvf8AW2vK1V8akMuk1QjK/uOdHXbAo4=\ngithub.com/json-iterator/go v1.1.11/go.mod h1:KdQUCv79m/52Kvf8AW2vK1V8akMuk1QjK/uOdHXbAo4=\ngithub.com/json-iterator/go v1.1.12 h1:PV8peI4a0ysnczrg+LtxykD8LfKY9ML6u2jnxaEnrnM=\ngithub.com/json-iterator/go v1.1.12/go.mod h1:e30LSqwooZae/UwlEbR2852Gd8hjQvJoHmT4TnhNGBo=\ngithub.com/jstemmer/go-junit-report v0.0.0-20190106144839-af01ea7f8024/go.mod h1:6v2b51hI/fHJwM22ozAgKL4VKDeJcHhJFhtBdhmNjmU=\ngithub.com/jstemmer/go-junit-report v0.9.1/go.mod h1:Brl9GWCQeLvo8nXZwPNNblvFj/XSXhF0NWZEnDohbsk=\ngithub.com/jtolds/gls v4.20.0+incompatible/go.mod h1:QJZ7F/aHp+rZTRtaJ1ow/lLfFfVYBRgL+9YlvaHOwJU=\ngithub.com/juju/errors v0.0.0-20181118221551-089d3ea4e4d5/go.mod h1:W54LbzXuIE0boCoNJfwqpmkKJ1O4TCTZMetAt6jGk7Q=\ngithub.com/juju/loggo v0.0.0-20180524022052-584905176618/go.mod h1:vgyd7OREkbtVEN/8IXZe5Ooef3LQePvuBm9UWj6ZL8U=\ngithub.com/juju/testing v0.0.0-20180920084828-472a3e8b2073/go.mod h1:63prj8cnj0tU0S9OHjGJn+b1h0ZghCndfnbQolrYTwA=\ngithub.com/julienschmidt/httprouter v1.2.0/go.mod h1:SYymIcj16QtmaHHD7aYtjjsJG7VTCxuUUipMqKk8s4w=\ngithub.com/julienschmidt/httprouter v1.3.0/go.mod h1:JR6WtHb+2LUe8TCKY3cZOxFyyO8IZAc4RVcycCCAKdM=\ngithub.com/jung-kurt/gofpdf v1.0.3-0.20190309125859-24315acbbda5/go.mod h1:7Id9E/uU8ce6rXgefFLlgrJj/GYY22cpxn+r32jIOes=\ngithub.com/karrick/godirwalk v1.16.1/go.mod h1:j4mkqPuvaLI8mp1DroR3P6ad7cyYd4c1qeJ3RV7ULlk=\ngithub.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51 h1:Z9n2FFNUXsshfwJMBgNA0RU6/i7WVaAegv3PtuIHPMs=\ngithub.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51/go.mod h1:CzGEWj7cYgsdH8dAjBGEr58BoE7ScuLd+fwFZ44+/x8=\ngithub.com/kevinburke/ssh_config v0.0.0-20201106050909-4977a11b4351 h1:DowS9hvgyYSX4TO5NpyC606/Z4SxnNYbT+WX27or6Ck=\ngithub.com/kevinburke/ssh_config v0.0.0-20201106050909-4977a11b4351/go.mod h1:CT57kijsi8u/K/BOFA39wgDQJ9CxiF4nAY/ojJ6r6mM=\ngithub.com/kisielk/errcheck v1.1.0/go.mod h1:EZBBE59ingxPouuu3KfxchcWSUPOHkagtvWXihfKN4Q=\ngithub.com/kisielk/errcheck v1.2.0/go.mod h1:/BMXB+zMLi60iA8Vv6Ksmxu/1UDYcXs4uQLJ+jE2L00=\ngithub.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI2bnpBCr8=\ngithub.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=\ngithub.com/klauspost/compress v1.13.5 h1:9O69jUPDcsT9fEm74W92rZL9FQY7rCdaXVneq+yyzl4=\ngithub.com/klauspost/compress v1.13.5/go.mod h1:/3/Vjq9QcHkK5uEr5lBEmyoZ1iFhe47etQ6QUkpK6sk=\ngithub.com/klauspost/cpuid v1.2.3/go.mod h1:Pj4uuM528wm8OyEC2QMXAi2YiTZ96dNQPGgoMS4s3ek=\ngithub.com/konsorten/go-windows-terminal-sequences v1.0.1/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=\ngithub.com/konsorten/go-windows-terminal-sequences v1.0.2/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=\ngithub.com/konsorten/go-windows-terminal-sequences v1.0.3/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=\ngithub.com/kr/fs v0.1.0/go.mod h1:FFnZGqtBN9Gxj7eW1uZ42v5BccTP0vu6NEaFoC2HwRg=\ngithub.com/kr/logfmt v0.0.0-20140226030751-b84e30acd515/go.mod h1:+0opPa2QZZtGFBFZlji/RkVcI2GknAs/DXo4wKdlNEc=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pretty v0.2.0/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=\ngithub.com/kr/pretty v0.2.1 h1:Fmg33tUaq4/8ym9TJN1x7sLJnHVwhP33CNkpYV/7rwI=\ngithub.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/pty v1.1.5/go.mod h1:9r2w37qlBe7rQ6e1fg1S/9xpWHSnaqNdHD3WcMdbPDA=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/leodido/go-urn v1.1.0/go.mod h1:+cyI34gQWZcE1eQU7NVgKkkzdXDQHr1dBMtdAPozLkw=\ngithub.com/libopenstorage/openstorage v1.0.0/go.mod h1:Sp1sIObHjat1BeXhfMqLZ14wnOzEhNx2YQedreMcUyc=\ngithub.com/liggitt/tabwriter v0.0.0-20181228230101-89fcab3d43de h1:9TO3cAIGXtEhnIaL+V+BEER86oLrvS+kWobKpbJuye0=\ngithub.com/liggitt/tabwriter v0.0.0-20181228230101-89fcab3d43de/go.mod h1:zAbeS9B/r2mtpb6U+EI2rYA5OAXxsYw6wTamcNW+zcE=\ngithub.com/lightstep/lightstep-tracer-common/golang/gogo v0.0.0-20190605223551-bc2310a04743/go.mod h1:qklhhLq1aX+mtWk9cPHPzaBjWImj5ULL6C7HFJtXQMM=\ngithub.com/lightstep/lightstep-tracer-go v0.18.1/go.mod h1:jlF1pusYV4pidLvZ+XD0UBX0ZE6WURAspgAczcDHrL4=\ngithub.com/lithammer/dedent v1.1.0/go.mod h1:jrXYCQtgg0nJiN+StA2KgR7w6CiQNv9Fd/Z9BP0jIOc=\ngithub.com/lpabon/godbc v0.1.1/go.mod h1:Jo9QV0cf3U6jZABgiJ2skINAXb9j8m51r07g4KI92ZA=\ngithub.com/lucasb-eyer/go-colorful v1.0.2/go.mod h1:0MS4r+7BZKSJ5mw4/S5MPN+qHFF1fYclkSPilDOKW0s=\ngithub.com/lucasb-eyer/go-colorful v1.0.3/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=\ngithub.com/lusis/go-slackbot v0.0.0-20180109053408-401027ccfef5/go.mod h1:c2mYKRyMb1BPkO5St0c/ps62L4S0W2NAkaTXj9qEI+0=\ngithub.com/lusis/slack-test v0.0.0-20190426140909-c40012f20018/go.mod h1:sFlOUpQL1YcjhFVXhg1CG8ZASEs/Mf1oVb6H75JL/zg=\ngithub.com/magiconair/properties v1.8.0/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=\ngithub.com/magiconair/properties v1.8.1/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=\ngithub.com/magiconair/properties v1.8.5/go.mod h1:y3VJvCyxH9uVvJTWEGAELF3aiYNyPKd5NZ3oSwXrF60=\ngithub.com/mailgun/mailgun-go v2.0.0+incompatible/go.mod h1:NWTyU+O4aczg/nsGhQnvHL6v2n5Gy6Sv5tNDVvC6FbU=\ngithub.com/mailru/easyjson v0.0.0-20180823135443-60711f1a8329/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=\ngithub.com/mailru/easyjson v0.0.0-20190312143242-1de009706dbe/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=\ngithub.com/mailru/easyjson v0.0.0-20190614124828-94de47d64c63/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=\ngithub.com/mailru/easyjson v0.0.0-20190626092158-b2ccc519800e/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=\ngithub.com/mailru/easyjson v0.7.0/go.mod h1:KAzv3t3aY1NaHWoQz1+4F1ccyAH66Jk7yos7ldAVICs=\ngithub.com/mailru/easyjson v0.7.6 h1:8yTIVnZgCoiM1TgqoeTl+LfU5Jg6/xL3QhGQnimLYnA=\ngithub.com/mailru/easyjson v0.7.6/go.mod h1:xzfreul335JAWq5oZzymOObrkdz5UnU4kGfJJLY9Nlc=\ngithub.com/malexdev/utfutil v0.0.0-20180510171754-00c8d4a8e7a8 h1:A6SLdFpRzUUF5v9F/7T1fu3DERmOCgTwwP6x54eyFfU=\ngithub.com/malexdev/utfutil v0.0.0-20180510171754-00c8d4a8e7a8/go.mod h1:UtpLyb/EupVKXF/N0b4NRe1DNg+QYJsnsHQ038romhM=\ngithub.com/matryer/is v1.2.0 h1:92UTHpy8CDwaJ08GqLDzhhuixiBUUD1p3AU6PHddz4A=\ngithub.com/matryer/is v1.2.0/go.mod h1:2fLPjFQM9rhQ15aVEtbuwhJinnOqrmgXPNdZsdwlWXA=\ngithub.com/mattn/go-colorable v0.0.9/go.mod h1:9vuHe8Xs5qXnSaW/c/ABM9alt+Vo+STaOChaDxuIBZU=\ngithub.com/mattn/go-colorable v0.1.2/go.mod h1:U0ppj6V5qS13XJ6of8GYAs25YV2eR4EVcfRqFIhoBtE=\ngithub.com/mattn/go-colorable v0.1.8/go.mod h1:u6P/XSegPjTcexA+o6vUJrdnUu04hMope9wVRipJSqc=\ngithub.com/mattn/go-isatty v0.0.3/go.mod h1:M+lRXTBqGeGNdLjl/ufCoiOlB5xdOkqRJdNxMWT7Zi4=\ngithub.com/mattn/go-isatty v0.0.4/go.mod h1:M+lRXTBqGeGNdLjl/ufCoiOlB5xdOkqRJdNxMWT7Zi4=\ngithub.com/mattn/go-isatty v0.0.8/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=\ngithub.com/mattn/go-isatty v0.0.9/go.mod h1:YNRxwqDuOph6SZLI9vUUz6OYw3QyUt7WiY2yME+cCiQ=\ngithub.com/mattn/go-isatty v0.0.12 h1:wuysRhFDzyxgEmMf5xjvJ2M9dZoWAXNNr5LSBS7uHXY=\ngithub.com/mattn/go-isatty v0.0.12/go.mod h1:cbi8OIDigv2wuxKPP5vlRcQ1OAZbq2CE4Kysco4FUpU=\ngithub.com/mattn/go-runewidth v0.0.2/go.mod h1:LwmH8dsx7+W8Uxz3IHJYH5QSwggIsqBzpuz5H//U1FU=\ngithub.com/mattn/go-runewidth v0.0.4/go.mod h1:LwmH8dsx7+W8Uxz3IHJYH5QSwggIsqBzpuz5H//U1FU=\ngithub.com/mattn/go-runewidth v0.0.7/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=\ngithub.com/mattn/go-runewidth v0.0.8/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=\ngithub.com/mattn/go-runewidth v0.0.9 h1:Lm995f3rfxdpd6TSmuVCHVb/QhupuXlYr8sCI/QdE+0=\ngithub.com/mattn/go-runewidth v0.0.9/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=\ngithub.com/mattn/go-zglob v0.0.3 h1:6Ry4EYsScDyt5di4OI6xw1bYhOqfE5S33Z1OPy+d+To=\ngithub.com/mattn/go-zglob v0.0.3/go.mod h1:9fxibJccNxU2cnpIKLRRFA7zX7qhkJIQWBb449FYHOo=\ngithub.com/mattn/goveralls v0.0.2/go.mod h1:8d1ZMHsd7fW6IRPKQh46F2WRpyib5/X4FOpevwGNQEw=\ngithub.com/matttproud/golang_protobuf_extensions v1.0.1/go.mod h1:D8He9yQNgCq6Z5Ld7szi9bcBfOoFv/3dc6xSMkL2PC0=\ngithub.com/matttproud/golang_protobuf_extensions v1.0.2-0.20181231171920-c182affec369 h1:I0XW9+e1XWDxdcEniV4rQAIOPUGDq67JSCiRCgGCZLI=\ngithub.com/matttproud/golang_protobuf_extensions v1.0.2-0.20181231171920-c182affec369/go.mod h1:BSXmuO+STAnVfrANrmjBb36TMTDstsz7MSK+HVaYKv4=\ngithub.com/miekg/dns v1.0.14/go.mod h1:W1PPwlIAgtquWBMBEV9nkV9Cazfe8ScdGz/Lj7v3Nrg=\ngithub.com/mindprince/gonvml v0.0.0-20190828220739-9ebdce4bb989/go.mod h1:2eu9pRWp8mo84xCg6KswZ+USQHjwgRhNp06sozOdsTY=\ngithub.com/minio/md5-simd v1.1.0/go.mod h1:XpBqgZULrMYD3R+M28PcmP0CkI7PEMzB3U77ZrKZ0Gw=\ngithub.com/minio/minio-go/v7 v7.0.2/go.mod h1:dJ80Mv2HeGkYLH1sqS/ksz07ON6csH3S6JUMSQ2zAns=\ngithub.com/minio/sha256-simd v0.1.1/go.mod h1:B5e1o+1/KgNmWrSQK08Y6Z1Vb5pwIktudl0J58iy0KM=\ngithub.com/mistifyio/go-zfs v2.1.2-0.20190413222219-f784269be439+incompatible/go.mod h1:8AuVvqP/mXw1px98n46wfvcGfQ4ci2FwoAjKYxuo3Z4=\ngithub.com/mitchellh/cli v1.0.0/go.mod h1:hNIlj7HEI86fIcpObd7a0FcrxTWetlwJDGcceTlRvqc=\ngithub.com/mitchellh/copystructure v1.0.0 h1:Laisrj+bAB6b/yJwB5Bt3ITZhGJdqmxquMKeZ+mmkFQ=\ngithub.com/mitchellh/copystructure v1.0.0/go.mod h1:SNtv71yrdKgLRyLFxmLdkAbkKEFWgYaq1OVrnRcwhnw=\ngithub.com/mitchellh/go-homedir v1.0.0/go.mod h1:SfyaCUpYCn1Vlf4IUYiD9fPX4A5wJrkLzIz1N1q0pr0=\ngithub.com/mitchellh/go-homedir v1.1.0 h1:lukF9ziXFxDFPkA1vsr5zpc1XuPDn/wFntq5mG+4E0Y=\ngithub.com/mitchellh/go-homedir v1.1.0/go.mod h1:SfyaCUpYCn1Vlf4IUYiD9fPX4A5wJrkLzIz1N1q0pr0=\ngithub.com/mitchellh/go-testing-interface v1.0.0/go.mod h1:kRemZodwjscx+RGhAo8eIhFbs2+BFgRtFPeD/KE+zxI=\ngithub.com/mitchellh/go-wordwrap v1.0.0 h1:6GlHJ/LTGMrIJbwgdqdl2eEH8o+Exx/0m8ir9Gns0u4=\ngithub.com/mitchellh/go-wordwrap v1.0.0/go.mod h1:ZXFpozHsX6DPmq2I0TCekCxypsnAUbP2oI0UX1GXzOo=\ngithub.com/mitchellh/gox v0.4.0/go.mod h1:Sd9lOJ0+aimLBi73mGofS1ycjY8lL3uZM3JPS42BGNg=\ngithub.com/mitchellh/iochan v1.0.0/go.mod h1:JwYml1nuB7xOzsp52dPpHFffvOCDupsG0QubkSMEySY=\ngithub.com/mitchellh/mapstructure v0.0.0-20160808181253-ca63d7c062ee/go.mod h1:FVVH3fgwuzCH5S8UJGiWEs2h04kUh9fWfEaFds41c1Y=\ngithub.com/mitchellh/mapstructure v1.1.2/go.mod h1:FVVH3fgwuzCH5S8UJGiWEs2h04kUh9fWfEaFds41c1Y=\ngithub.com/mitchellh/mapstructure v1.4.1 h1:CpVNEelQCZBooIPDn+AR3NpivK/TIKU8bDxdASFVQag=\ngithub.com/mitchellh/mapstructure v1.4.1/go.mod h1:bFUtVrKA4DC2yAKiSyO/QUcy7e+RRV2QTWOzhPopBRo=\ngithub.com/mitchellh/reflectwalk v1.0.0 h1:9D+8oIskB4VJBN5SFlmc27fSlIBZaov1Wpk/IfikLNY=\ngithub.com/mitchellh/reflectwalk v1.0.0/go.mod h1:mSTlrgnPZtwu0c4WaC2kGObEpuNDbx0jmZXqmk4esnw=\ngithub.com/moby/ipvs v1.0.1/go.mod h1:2pngiyseZbIKXNv7hsKj3O9UEz30c53MT9005gt2hxQ=\ngithub.com/moby/spdystream v0.2.0 h1:cjW1zVyyoiM0T7b6UoySUFqzXMoqRckQtXwGPiBhOM8=\ngithub.com/moby/spdystream v0.2.0/go.mod h1:f7i0iNDQJ059oMTcWxx8MA/zKFIuD/lY+0GqbN2Wy8c=\ngithub.com/moby/sys/mountinfo v0.4.1/go.mod h1:rEr8tzG/lsIZHBtN/JjGG+LMYx9eXgW2JI+6q0qou+A=\ngithub.com/moby/term v0.0.0-20201216013528-df9cb8a40635/go.mod h1:FBS0z0QWA44HXygs7VXDUOGoN/1TV3RuWkLO04am3wc=\ngithub.com/moby/term v0.0.0-20210610120745-9d4ed1856297 h1:yH0SvLzcbZxcJXho2yh7CqdENGMQe73Cw3woZBpPli0=\ngithub.com/moby/term v0.0.0-20210610120745-9d4ed1856297/go.mod h1:vgPCkQMyxTZ7IDy8SXRufE172gr8+K/JE/7hHFxHW3A=\ngithub.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg=\ngithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/reflect2 v0.0.0-20180701023420-4b7aa43c6742/go.mod h1:bx2lNnkwVCuqBIxFjflWJWanXIb3RllmbCylyMrvgv0=\ngithub.com/modern-go/reflect2 v1.0.1/go.mod h1:bx2lNnkwVCuqBIxFjflWJWanXIb3RllmbCylyMrvgv0=\ngithub.com/modern-go/reflect2 v1.0.2 h1:xBagoLtFs94CBntxluKeaWgTMpvLxC4ur3nMaC9Gz0M=\ngithub.com/modern-go/reflect2 v1.0.2/go.mod h1:yWuevngMOJpCy52FWWMvUC8ws7m/LJsjYzDa0/r8luk=\ngithub.com/mohae/deepcopy v0.0.0-20170603005431-491d3605edfb/go.mod h1:TaXosZuwdSHYgviHp1DAtfrULt5eUgsSMsZf+YrPgl8=\ngithub.com/monochromegane/go-gitignore v0.0.0-20200626010858-205db1a8cc00 h1:n6/2gBQ3RWajuToeY6ZtZTIKv2v7ThUy5KKusIT0yc0=\ngithub.com/monochromegane/go-gitignore v0.0.0-20200626010858-205db1a8cc00/go.mod h1:Pm3mSP3c5uWn86xMLZ5Sa7JB9GsEZySvHYXCTK4E9q4=\ngithub.com/morikuni/aec v1.0.0/go.mod h1:BbKIizmSmc5MMPqRYbxO4ZU0S0+P200+tUnFx7PXmsc=\ngithub.com/moul/http2curl v1.0.0/go.mod h1:8UbvGypXm98wA/IqH45anm5Y2Z6ep6O31QGOAZ3H0fQ=\ngithub.com/mrunalp/fileutils v0.5.0/go.mod h1:M1WthSahJixYnrXQl/DFQuteStB1weuxD2QJNHXfbSQ=\ngithub.com/munnerz/goautoneg v0.0.0-20120707110453-a547fc61f48d/go.mod h1:+n7T8mK8HuQTcFwEeznm/DIxMOiR9yIdICNftLE1DvQ=\ngithub.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822/go.mod h1:+n7T8mK8HuQTcFwEeznm/DIxMOiR9yIdICNftLE1DvQ=\ngithub.com/mvdan/xurls v1.1.0/go.mod h1:tQlNn3BED8bE/15hnSL2HLkDeLWpNPAwtw7wkEq44oU=\ngithub.com/mwitkow/go-conntrack v0.0.0-20161129095857-cc309e4a2223/go.mod h1:qRWi+5nqEBWmkhHvq77mSJWrCKwh8bxhgT7d/eI7P4U=\ngithub.com/mwitkow/go-conntrack v0.0.0-20190716064945-2f068394615f h1:KUppIJq7/+SVif2QVs3tOP0zanoHgBEVAwHxUSIzRqU=\ngithub.com/mwitkow/go-conntrack v0.0.0-20190716064945-2f068394615f/go.mod h1:qRWi+5nqEBWmkhHvq77mSJWrCKwh8bxhgT7d/eI7P4U=\ngithub.com/mxk/go-flowrate v0.0.0-20140419014527-cca7078d478f/go.mod h1:ZdcZmHo+o7JKHSa8/e818NopupXU1YMK5fe1lsApnBw=\ngithub.com/nats-io/jwt v0.3.0/go.mod h1:fRYCDE99xlTsqUzISS1Bi75UBJ6ljOJQOAAu5VglpSg=\ngithub.com/nats-io/jwt v0.3.2/go.mod h1:/euKqTS1ZD+zzjYrY7pseZrTtWQSjujC7xjPc8wL6eU=\ngithub.com/nats-io/nats-server/v2 v2.1.2/go.mod h1:Afk+wRZqkMQs/p45uXdrVLuab3gwv3Z8C4HTBu8GD/k=\ngithub.com/nats-io/nats.go v1.9.1/go.mod h1:ZjDU1L/7fJ09jvUSRVBR2e7+RnLiiIQyqyzEE/Zbp4w=\ngithub.com/nats-io/nkeys v0.1.0/go.mod h1:xpnFELMwJABBLVhffcfd1MZx6VsNRFpEugbxziKVo7w=\ngithub.com/nats-io/nkeys v0.1.3/go.mod h1:xpnFELMwJABBLVhffcfd1MZx6VsNRFpEugbxziKVo7w=\ngithub.com/nats-io/nuid v1.0.1/go.mod h1:19wcPz3Ph3q0Jbyiqsd0kePYG7A95tJPxeL+1OSON2c=\ngithub.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e/go.mod h1:zD1mROLANZcx1PVRCS0qkT7pwLkGfwJo4zjcN/Tysno=\ngithub.com/nlopes/slack v0.5.0/go.mod h1:jVI4BBK3lSktibKahxBF74txcK2vyvkza1z/+rRnVAM=\ngithub.com/nxadm/tail v1.4.4/go.mod h1:kenIhsEOeOJmVchQTgglprH7qJGnHDVpk1VPCcaMI8A=\ngithub.com/nxadm/tail v1.4.8 h1:nPr65rt6Y5JFSKQO7qToXr7pePgD6Gwiw05lkbyAQTE=\ngithub.com/nxadm/tail v1.4.8/go.mod h1:+ncqLTQzXmGhMZNUePPaPqPvBxHAIsmXswZKocGu+AU=\ngithub.com/oklog/oklog v0.3.2/go.mod h1:FCV+B7mhrz4o+ueLpx+KqkyXRGMWOYEvfiXtdGtbWGs=\ngithub.com/oklog/run v1.0.0/go.mod h1:dlhp/R75TPv97u0XWUtDeV/lRKWPKSdTuV0TZvrmrQA=\ngithub.com/oklog/ulid v1.3.1/go.mod h1:CirwcVhetQ6Lv90oh/F+FBtV6XMibvdAFo93nm5qn4U=\ngithub.com/olekukonko/tablewriter v0.0.0-20170122224234-a0225b3f23b5/go.mod h1:vsDQFd/mU46D+Z4whnwzcISnGGzXWMclvtLoiIKAKIo=\ngithub.com/olekukonko/tablewriter v0.0.1/go.mod h1:vsDQFd/mU46D+Z4whnwzcISnGGzXWMclvtLoiIKAKIo=\ngithub.com/olekukonko/tablewriter v0.0.4/go.mod h1:zq6QwlOf5SlnkVbMSr5EoBv3636FWnp+qbPhuoO21uA=\ngithub.com/olekukonko/tablewriter v0.0.5 h1:P2Ga83D34wi1o9J6Wh1mRuqd4mF/x/lgBS7N7AbDhec=\ngithub.com/olekukonko/tablewriter v0.0.5/go.mod h1:hPp6KlRPjbx+hW8ykQs1w3UBbZlj6HuIJcUGPhkA7kY=\ngithub.com/oliveagle/jsonpath v0.0.0-20180606110733-2e52cf6e6852/go.mod h1:eqOVx5Vwu4gd2mmMZvVZsgIqNSaW3xxRThUJ0k/TPk4=\ngithub.com/onsi/ginkgo v0.0.0-20170829012221-11459a886d9c/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=\ngithub.com/onsi/ginkgo v1.6.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=\ngithub.com/onsi/ginkgo v1.7.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=\ngithub.com/onsi/ginkgo v1.8.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=\ngithub.com/onsi/ginkgo v1.12.1/go.mod h1:zj2OWP4+oCPe1qIXoGWkgMRwljMUYCdkwsT2108oapk=\ngithub.com/onsi/ginkgo v1.14.0/go.mod h1:iSB4RoI2tjJc9BBv4NKIKWKya62Rps+oPG/Lv9klQyY=\ngithub.com/onsi/ginkgo v1.14.1/go.mod h1:iSB4RoI2tjJc9BBv4NKIKWKya62Rps+oPG/Lv9klQyY=\ngithub.com/onsi/ginkgo v1.16.4/go.mod h1:dX+/inL/fNMqNlz0e9LfyB9TswhZpCVdJM/Z6Vvnwo0=\ngithub.com/onsi/ginkgo v1.16.5 h1:8xi0RTUf59SOSfEtZMvwTvXYMzG4gV23XVHOZiXNtnE=\ngithub.com/onsi/ginkgo v1.16.5/go.mod h1:+E8gABHa3K6zRBolWtd+ROzc/U5bkGt0FwiG042wbpU=\ngithub.com/onsi/gomega v0.0.0-20170829124025-dcabb60a477c/go.mod h1:C1qb7wdrVGGVU+Z6iS04AVkA3Q65CEZX59MT0QO5uiA=\ngithub.com/onsi/gomega v1.4.3/go.mod h1:ex+gbHU/CVuBBDIJjb2X0qEXbFg53c61hWP/1CpauHY=\ngithub.com/onsi/gomega v1.5.0/go.mod h1:ex+gbHU/CVuBBDIJjb2X0qEXbFg53c61hWP/1CpauHY=\ngithub.com/onsi/gomega v1.7.1/go.mod h1:XdKZgCCFLUoM/7CFJVPcG8C1xQ1AJ0vpAezJrB7JYyY=\ngithub.com/onsi/gomega v1.10.1/go.mod h1:iN09h71vgCQne3DLsj+A5owkum+a2tYe+TOCB1ybHNo=\ngithub.com/onsi/gomega v1.10.2/go.mod h1:iN09h71vgCQne3DLsj+A5owkum+a2tYe+TOCB1ybHNo=\ngithub.com/onsi/gomega v1.15.0/go.mod h1:cIuvLEne0aoVhAgh/O6ac0Op8WWw9H6eYCriF+tEHG0=\ngithub.com/onsi/gomega v1.17.0 h1:9Luw4uT5HTjHTN8+aNcSThgH1vdXnmdJ8xIfZ4wyTRE=\ngithub.com/onsi/gomega v1.17.0/go.mod h1:HnhC7FXeEQY45zxNK3PPoIUhzk/80Xly9PcubAlGdZY=\ngithub.com/op/go-logging v0.0.0-20160315200505-970db520ece7/go.mod h1:HzydrMdWErDVzsI23lYNej1Htcns9BCg93Dk0bBINWk=\ngithub.com/opencontainers/go-digest v1.0.0 h1:apOUWs51W5PlhuyGyz9FCeeBIOUDA/6nW8Oi/yOhh5U=\ngithub.com/opencontainers/go-digest v1.0.0/go.mod h1:0JzlMkj0TRzQZfJkVvzbP0HBR3IKzErnv2BNG4W4MAM=\ngithub.com/opencontainers/image-spec v1.0.1/go.mod h1:BtxoFyWECRxE4U/7sNtV5W15zMzWCbyJoFRP3s7yZA0=\ngithub.com/opencontainers/runc v1.0.2/go.mod h1:aTaHFFwQXuA71CiyxOdFFIorAoemI04suvGRQFzWTD0=\ngithub.com/opencontainers/runtime-spec v1.0.2/go.mod h1:jwyrGlmzljRJv/Fgzds9SsS/C5hL+LL3ko9hs6T5lQ0=\ngithub.com/opencontainers/runtime-spec v1.0.3-0.20200929063507-e6143ca7d51d/go.mod h1:jwyrGlmzljRJv/Fgzds9SsS/C5hL+LL3ko9hs6T5lQ0=\ngithub.com/opencontainers/runtime-spec v1.0.3-0.20210326190908-1c3f411f0417/go.mod h1:jwyrGlmzljRJv/Fgzds9SsS/C5hL+LL3ko9hs6T5lQ0=\ngithub.com/opencontainers/selinux v1.8.2/go.mod h1:MUIHuUEvKB1wtJjQdOyYRgOnLD2xAPP8dBsCoU0KuF8=\ngithub.com/opentracing-contrib/go-observer v0.0.0-20170622124052-a52f23424492/go.mod h1:Ngi6UdF0k5OKD5t5wlmGhe/EDKPoUM3BXZSSfIuJbis=\ngithub.com/opentracing/basictracer-go v1.0.0/go.mod h1:QfBfYuafItcjQuMwinw9GhYKwFXS9KnPs5lxoYwgW74=\ngithub.com/opentracing/opentracing-go v1.0.2/go.mod h1:UkNAQd3GIcIGf0SeVgPpRdFStlNbqXla1AfSYxPUl2o=\ngithub.com/opentracing/opentracing-go v1.1.0/go.mod h1:UkNAQd3GIcIGf0SeVgPpRdFStlNbqXla1AfSYxPUl2o=\ngithub.com/openzipkin-contrib/zipkin-go-opentracing v0.4.5/go.mod h1:/wsWhb9smxSfWAKL3wpBW7V8scJMt8N8gnaMCS9E/cA=\ngithub.com/openzipkin/zipkin-go v0.1.6/go.mod h1:QgAqvLzwWbR/WpD4A3cGpPtJrZXNIiJc5AZX7/PBEpw=\ngithub.com/openzipkin/zipkin-go v0.2.1/go.mod h1:NaW6tEwdmWMaCDZzg8sh+IBNOxHMPnhQw8ySjnjRyN4=\ngithub.com/openzipkin/zipkin-go v0.2.2/go.mod h1:NaW6tEwdmWMaCDZzg8sh+IBNOxHMPnhQw8ySjnjRyN4=\ngithub.com/opsgenie/opsgenie-go-sdk-v2 v1.0.5 h1:AnS8ZCC5dle8P4X4FZ+IOlX9v0jAkCMiZDIzRnYwBbs=\ngithub.com/opsgenie/opsgenie-go-sdk-v2 v1.0.5/go.mod h1:f0ezb0R/mrB9Hpm5RrIS6EX3ydjsR2nAB88nYYXZcNY=\ngithub.com/pact-foundation/pact-go v1.0.4/go.mod h1:uExwJY4kCzNPcHRj+hCR/HBbOOIwwtUjcrb0b5/5kLM=\ngithub.com/pascaldekloe/goe v0.0.0-20180627143212-57f6aae5913c/go.mod h1:lzWF7FIEvWOWxwDKqyGYQf6ZUaNfKdP144TG7ZOy1lc=\ngithub.com/patrickmn/go-cache v2.1.0+incompatible h1:HRMgzkcYKYpi3C8ajMPV8OFXaaRUnok+kx1WdO15EQc=\ngithub.com/patrickmn/go-cache v2.1.0+incompatible/go.mod h1:3Qf8kWWT7OJRJbdiICTKqZju1ZixQ/KpMGzzAfe6+WQ=\ngithub.com/pborman/uuid v1.2.0/go.mod h1:X/NO0urCmaxf9VXbdlT7C2Yzkj2IKimNn4k+gtPdI/k=\ngithub.com/pelletier/go-toml v1.2.0/go.mod h1:5z9KED0ma1S8pY6P1sdut58dfprrGBbd/94hg7ilaic=\ngithub.com/pelletier/go-toml v1.9.3/go.mod h1:u1nR/EPcESfeI/szUZKdtJ0xRNbUoANCkoOuaOx1Y+c=\ngithub.com/performancecopilot/speed v3.0.0+incompatible/go.mod h1:/CLtqpZ5gBg1M9iaPbIdPPGyKcA8hKdoy6hAWba7Yac=\ngithub.com/peterbourgon/diskv v2.0.1+incompatible h1:UBdAOUP5p4RWqPBg048CAvpKN+vxiaj6gdUUzhl4XmI=\ngithub.com/peterbourgon/diskv v2.0.1+incompatible/go.mod h1:uqqh8zWWbv1HBMNONnaR/tNboyR3/BZd58JJSHlUSCU=\ngithub.com/pierrec/lz4 v1.0.2-0.20190131084431-473cd7ce01a1/go.mod h1:3/3N9NVKO0jef7pBehbT1qWhCMrIgbYNnFAZCqQ5LRc=\ngithub.com/pierrec/lz4 v2.0.5+incompatible/go.mod h1:pdkljMzZIN41W+lC3N2tnIh5sFi+IEE17M5jbnwPHcY=\ngithub.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pkg/profile v1.2.1/go.mod h1:hJw3o1OdXxsrSjjVksARp5W95eeEaEfptyVZyv6JUPA=\ngithub.com/pkg/sftp v1.10.1/go.mod h1:lYOWFsE0bwd1+KfKJaKeuokY15vzFx25BLbzYYoAxZI=\ngithub.com/pmezard/go-difflib v0.0.0-20151028094244-d8ed2627bdf0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/posener/complete v1.1.1/go.mod h1:em0nMJCgc9GFtwrmVmEMR/ZL6WyhyjMBndrE9hABlRI=\ngithub.com/pquerna/cachecontrol v0.0.0-20171018203845-0dec1b30a021/go.mod h1:prYjPmNq4d1NPVmpShWobRqXY3q7Vp+80DqgxxUrUIA=\ngithub.com/pquerna/cachecontrol v0.0.0-20180306154005-525d0eb5f91d h1:7gXyC293Lsm2YWgQ+0uaAFFFDO82ruiQSwc3ua+Vtlc=\ngithub.com/pquerna/cachecontrol v0.0.0-20180306154005-525d0eb5f91d/go.mod h1:prYjPmNq4d1NPVmpShWobRqXY3q7Vp+80DqgxxUrUIA=\ngithub.com/prometheus/client_golang v0.9.1/go.mod h1:7SWBe2y4D6OKWSNQJUaRYU/AaXPKyh/dDVn+NZz0KFw=\ngithub.com/prometheus/client_golang v0.9.3-0.20190127221311-3c4408c8b829/go.mod h1:p2iRAGwDERtqlqzRXnrOVns+ignqQo//hLXqYxZYVNs=\ngithub.com/prometheus/client_golang v0.9.3/go.mod h1:/TN21ttK/J9q6uSwhBd54HahCDft0ttaMvbicHlPoso=\ngithub.com/prometheus/client_golang v1.0.0/go.mod h1:db9x61etRT2tGnBNRi70OPL5FsnadC4Ky3P0J6CfImo=\ngithub.com/prometheus/client_golang v1.3.0/go.mod h1:hJaj2vgQTGQmVCsAACORcieXFeDPbaTKGT+JTgUa3og=\ngithub.com/prometheus/client_golang v1.7.1/go.mod h1:PY5Wy2awLA44sXw4AOSfFBetzPP4j5+D6mVACh+pe2M=\ngithub.com/prometheus/client_golang v1.11.0 h1:HNkLOAEQMIDv/K+04rukrLx6ch7msSRwf3/SASFAGtQ=\ngithub.com/prometheus/client_golang v1.11.0/go.mod h1:Z6t4BnS23TR94PD6BsDNk8yVqroYurpAkEiz0P2BEV0=\ngithub.com/prometheus/client_model v0.0.0-20180712105110-5c3871d89910/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=\ngithub.com/prometheus/client_model v0.0.0-20190115171406-56726106282f/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=\ngithub.com/prometheus/client_model v0.0.0-20190129233127-fd36f4220a90/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/client_model v0.1.0/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/client_model v0.2.0 h1:uq5h0d+GuxiXLJLNABMgp2qUWDPiLvgCzz2dUR+/W/M=\ngithub.com/prometheus/client_model v0.2.0/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/common v0.0.0-20181113130724-41aa239b4cce/go.mod h1:daVV7qP5qjZbuso7PdcryaAu0sAZbrN9i7WWcTMWvro=\ngithub.com/prometheus/common v0.2.0/go.mod h1:TNfzLD0ON7rHzMJeJkieUDPYmFC7Snx/y86RQel1bk4=\ngithub.com/prometheus/common v0.4.0/go.mod h1:TNfzLD0ON7rHzMJeJkieUDPYmFC7Snx/y86RQel1bk4=\ngithub.com/prometheus/common v0.4.1/go.mod h1:TNfzLD0ON7rHzMJeJkieUDPYmFC7Snx/y86RQel1bk4=\ngithub.com/prometheus/common v0.7.0/go.mod h1:DjGbpBbp5NYNiECxcL/VnbXCCaQpKd3tt26CguLLsqA=\ngithub.com/prometheus/common v0.10.0/go.mod h1:Tlit/dnDKsSWFlCLTWaA1cyBgKHSMdTB80sz/V91rCo=\ngithub.com/prometheus/common v0.26.0/go.mod h1:M7rCNAaPfAosfx8veZJCuw84e35h3Cfd9VFqTh1DIvc=\ngithub.com/prometheus/common v0.28.0 h1:vGVfV9KrDTvWt5boZO0I19g2E3CsWfpPPKZM9dt3mEw=\ngithub.com/prometheus/common v0.28.0/go.mod h1:vu+V0TpY+O6vW9J44gczi3Ap/oXXR10b+M/gUGO4Hls=\ngithub.com/prometheus/procfs v0.0.0-20181005140218-185b4288413d/go.mod h1:c3At6R/oaqEKCNdg8wHV1ftS6bRYblBhIjjI8uT2IGk=\ngithub.com/prometheus/procfs v0.0.0-20190117184657-bf6a532e95b1/go.mod h1:c3At6R/oaqEKCNdg8wHV1ftS6bRYblBhIjjI8uT2IGk=\ngithub.com/prometheus/procfs v0.0.0-20190507164030-5867b95ac084/go.mod h1:TjEm7ze935MbeOT/UhFTIMYKhuLP4wbCsTZCD3I8kEA=\ngithub.com/prometheus/procfs v0.0.0-20190522114515-bc1a522cf7b1/go.mod h1:TjEm7ze935MbeOT/UhFTIMYKhuLP4wbCsTZCD3I8kEA=\ngithub.com/prometheus/procfs v0.0.2/go.mod h1:TjEm7ze935MbeOT/UhFTIMYKhuLP4wbCsTZCD3I8kEA=\ngithub.com/prometheus/procfs v0.0.8/go.mod h1:7Qr8sr6344vo1JqZ6HhLceV9o3AJ1Ff+GxbHq6oeK9A=\ngithub.com/prometheus/procfs v0.1.3/go.mod h1:lV6e/gmhEcM9IjHGsFOCxxuZ+z1YqCvr4OA4YeYWdaU=\ngithub.com/prometheus/procfs v0.6.0 h1:mxy4L2jP6qMonqmq+aTtOx1ifVWUgG/TAmntgbh3xv4=\ngithub.com/prometheus/procfs v0.6.0/go.mod h1:cz+aTbrPOrUb4q7XlbU9ygM+/jj0fzG6c1xBZuNvfVA=\ngithub.com/prometheus/tsdb v0.7.1/go.mod h1:qhTCs0VvXwvX/y3TZrWD7rabWM+ijKTux40TwIPHuXU=\ngithub.com/quobyte/api v0.1.8/go.mod h1:jL7lIHrmqQ7yh05OJ+eEEdHr0u/kmT1Ff9iHd+4H6VI=\ngithub.com/r3labs/diff v1.1.0 h1:V53xhrbTHrWFWq3gI4b94AjgEJOerO1+1l0xyHOBi8M=\ngithub.com/r3labs/diff v1.1.0/go.mod h1:7WjXasNzi0vJetRcB/RqNl5dlIsmXcTTLmF5IoH6Xig=\ngithub.com/rcrowley/go-metrics v0.0.0-20181016184325-3113b8401b8a/go.mod h1:bCqnVzQkZxMG4s8nGwiZ5l3QUCyqpo9Y+/ZMZ9VjZe4=\ngithub.com/remyoudompheng/bigfft v0.0.0-20170806203942-52369c62f446/go.mod h1:uYEyJGbgTkfkS4+E/PavXkNJcbFIpEtjt2B0KDQ5+9M=\ngithub.com/rivo/tview v0.0.0-20200219210816-cd38d7432498/go.mod h1:6lkG1x+13OShEf0EaOCaTQYyB7d5nSbb181KtjlS+84=\ngithub.com/rivo/uniseg v0.1.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/robfig/cron v1.2.0 h1:ZjScXvvxeQ63Dbyxy76Fj3AT3Ut0aKsyd2/tl3DTMuQ=\ngithub.com/robfig/cron v1.2.0/go.mod h1:JGuDeoQd7Z6yL4zQhZ3OPEVHB7fL6Ka6skscFHfmt2k=\ngithub.com/robfig/cron/v3 v3.0.1/go.mod h1:eQICP3HwyT7UooqI/z+Ov+PtYAWygg1TEWWzGIFLtro=\ngithub.com/rogpeppe/fastuuid v1.2.0/go.mod h1:jVj6XXZzXRy/MSR5jhDC/2q6DgLz+nrA6LYCDYWNEvQ=\ngithub.com/rogpeppe/go-internal v1.1.0/go.mod h1:M8bDsm7K2OlrFYOpmOWEs/qY81heoFRclV5y23lUDJ4=\ngithub.com/rogpeppe/go-internal v1.3.0/go.mod h1:M8bDsm7K2OlrFYOpmOWEs/qY81heoFRclV5y23lUDJ4=\ngithub.com/rs/cors v1.8.0 h1:P2KMzcFwrPoSjkF1WLRPsp3UMLyql8L4v9hQpVeK5so=\ngithub.com/rs/cors v1.8.0/go.mod h1:EBwu+T5AvHOcXwvZIkQFjUN6s8Czyqw12GL/Y0tUyRM=\ngithub.com/rs/xid v1.2.1/go.mod h1:+uKXf+4Djp6Md1KODXJxgGQPKngRmWyn10oCKFzNHOQ=\ngithub.com/rs/zerolog v1.21.0/go.mod h1:ZPhntP/xmq1nnND05hhpAh2QMhSsA4UN3MGZ6O2J3hM=\ngithub.com/rubiojr/go-vhd v0.0.0-20200706105327-02e210299021/go.mod h1:DM5xW0nvfNNm2uytzsvhI3OnX8uzaRAg8UX/CnDqbto=\ngithub.com/russross/blackfriday v1.5.2 h1:HyvC0ARfnZBqnXwABFeSZHpKvJHJJfPz81GNueLj0oo=\ngithub.com/russross/blackfriday v1.5.2/go.mod h1:JO/DiYxRf+HjHt06OyowR9PTA263kcR/rfWxYHBV53g=\ngithub.com/russross/blackfriday/v2 v2.0.1 h1:lPqVAte+HuHNfhJ/0LC98ESWRz8afy9tM/0RK8m9o+Q=\ngithub.com/russross/blackfriday/v2 v2.0.1/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=\ngithub.com/ryanuber/columnize v0.0.0-20160712163229-9b3edd62028f/go.mod h1:sm1tb6uqfes/u+d4ooFouqFdy9/2g9QGwK3SQygK0Ts=\ngithub.com/samuel/go-zookeeper v0.0.0-20190923202752-2cc03de413da/go.mod h1:gi+0XIa01GRL2eRQVjQkKGqKF3SF9vZR/HnPullcV2E=\ngithub.com/sanity-io/litter v1.2.0/go.mod h1:JF6pZUFgu2Q0sBZ+HSV35P8TVPI1TTzEwyu9FXAw2W4=\ngithub.com/sean-/seed v0.0.0-20170313163322-e2103e2c3529/go.mod h1:DxrIzT+xaE7yg65j358z/aeFdxmN0P9QXhEzd20vsDc=\ngithub.com/seccomp/libseccomp-golang v0.9.1/go.mod h1:GbW5+tmTXfcxTToHLXlScSlAvWlF4P2Ca7zGrPiEpWo=\ngithub.com/sergi/go-diff v1.0.0/go.mod h1:0CfEIISq7TuYL3j771MWULgwwjU+GofnZX9QAmXWZgo=\ngithub.com/sergi/go-diff v1.1.0 h1:we8PVUC3FE2uYfodKH/nBHMSetSfHDR6scGdBi+erh0=\ngithub.com/sergi/go-diff v1.1.0/go.mod h1:STckp+ISIX8hZLjrqAeVduY0gWCT9IjLuqbuNXdaHfM=\ngithub.com/shurcooL/sanitized_anchor_name v1.0.0 h1:PdmoCO6wvbs+7yrJyMORt4/BmY5IYyJwS/kOiWx8mHo=\ngithub.com/shurcooL/sanitized_anchor_name v1.0.0/go.mod h1:1NzhyTcUVG4SuEtjjoZeVRXNmyL/1OwPU0+IJeTBvfc=\ngithub.com/sirupsen/logrus v1.2.0/go.mod h1:LxeOpSwHxABJmUn/MG1IvRgCAasNZTLOkJPxbbu5VWo=\ngithub.com/sirupsen/logrus v1.4.1/go.mod h1:ni0Sbl8bgC9z8RoU9G6nDWqqs/fq4eDPysMBDgk/93Q=\ngithub.com/sirupsen/logrus v1.4.2/go.mod h1:tLMulIdttU9McNUspp0xgXVQah82FyeX6MwdIuYE2rE=\ngithub.com/sirupsen/logrus v1.6.0/go.mod h1:7uNnSEd1DgxDLC74fIahvMZmmYsHGZGEOFrfsX/uA88=\ngithub.com/sirupsen/logrus v1.7.0/go.mod h1:yWOB1SBYBC5VeMP7gHvWumXLIWorT60ONWic61uBYv0=\ngithub.com/sirupsen/logrus v1.8.1 h1:dJKuHgqk1NNQlqoA6BTlM1Wf9DOH3NBjQyu0h9+AZZE=\ngithub.com/sirupsen/logrus v1.8.1/go.mod h1:yWOB1SBYBC5VeMP7gHvWumXLIWorT60ONWic61uBYv0=\ngithub.com/skratchdot/open-golang v0.0.0-20160302144031-75fb7ed4208c h1:fyKiXKO1/I/B6Y2U8T7WdQGWzwehOuGIrljPtt7YTTI=\ngithub.com/skratchdot/open-golang v0.0.0-20160302144031-75fb7ed4208c/go.mod h1:sUM3LWHvSMaG192sy56D9F7CNvL7jUJVXoqM1QKLnog=\ngithub.com/slack-go/slack v0.10.1 h1:BGbxa0kMsGEvLOEoZmYs8T1wWfoZXwmQFBb6FgYCXUA=\ngithub.com/slack-go/slack v0.10.1/go.mod h1:wWL//kk0ho+FcQXcBTmEafUI5dz4qz5f4mMk8oIkioQ=\ngithub.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d/go.mod h1:OnSkiWE9lh6wB0YB77sQom3nweQdgAjqCqsofrRNTgc=\ngithub.com/smartystreets/assertions v1.1.0/go.mod h1:tcbTF8ujkAEcZ8TElKY+i30BzYlVhC/LOxJk7iOWnoo=\ngithub.com/smartystreets/goconvey v0.0.0-20190330032615-68dc04aab96a/go.mod h1:syvi0/a8iFYH4r/RixwvyeAJjdLS9QV7WQ/tjFTllLA=\ngithub.com/smartystreets/goconvey v0.0.0-20190731233626-505e41936337/go.mod h1:syvi0/a8iFYH4r/RixwvyeAJjdLS9QV7WQ/tjFTllLA=\ngithub.com/smartystreets/goconvey v1.6.4/go.mod h1:syvi0/a8iFYH4r/RixwvyeAJjdLS9QV7WQ/tjFTllLA=\ngithub.com/soheilhy/cmux v0.1.4/go.mod h1:IM3LyeVVIOuxMH7sFAkER9+bJ4dT7Ms6E4xg4kGIyLM=\ngithub.com/soheilhy/cmux v0.1.5 h1:jjzc5WVemNEDTLwv9tlmemhC73tI08BNOIGwBOo10Js=\ngithub.com/soheilhy/cmux v0.1.5/go.mod h1:T7TcVDs9LWfQgPlPsdngu6I6QIoyIFZDDC6sNE1GqG0=\ngithub.com/sony/gobreaker v0.4.1/go.mod h1:ZKptC7FHNvhBz7dN2LGjPVBz2sZJmc0/PkyDJOjmxWY=\ngithub.com/sony/sonyflake v1.0.0 h1:MpU6Ro7tfXwgn2l5eluf9xQvQJDROTBImNCfRXn/YeM=\ngithub.com/sony/sonyflake v1.0.0/go.mod h1:Jv3cfhf/UFtolOTTRd3q4Nl6ENqM+KfyZ5PseKfZGF4=\ngithub.com/spaolacci/murmur3 v0.0.0-20180118202830-f09979ecbc72/go.mod h1:JwIasOWyU6f++ZhiEuf87xNszmSA2myDM2Kzu9HwQUA=\ngithub.com/spf13/afero v1.1.2/go.mod h1:j4pytiNVoe2o6bmDsKpLACNPDBIoEAkihy7loJ1B0CQ=\ngithub.com/spf13/afero v1.2.2/go.mod h1:9ZxEEn6pIJ8Rxe320qSDBk6AsU0r9pR7Q4OcevTdifk=\ngithub.com/spf13/afero v1.6.0/go.mod h1:Ai8FlHk4v/PARR026UzYexafAt9roJ7LcLMAmO6Z93I=\ngithub.com/spf13/cast v1.3.0/go.mod h1:Qx5cxh0v+4UWYiBimWS+eyWzqEqokIECu5etghLkUJE=\ngithub.com/spf13/cast v1.3.1/go.mod h1:Qx5cxh0v+4UWYiBimWS+eyWzqEqokIECu5etghLkUJE=\ngithub.com/spf13/cobra v0.0.3/go.mod h1:1l0Ry5zgKvJasoi3XT1TypsSe7PqH0Sj9dhYf7v3XqQ=\ngithub.com/spf13/cobra v1.0.0/go.mod h1:/6GTrnGXV9HjY+aR4k0oJ5tcvakLuG6EuKReYlHNrgE=\ngithub.com/spf13/cobra v1.1.3/go.mod h1:pGADOWyqRD/YMrPZigI/zbliZ2wVD/23d+is3pSWzOo=\ngithub.com/spf13/cobra v1.2.1 h1:+KmjbUw1hriSNMF55oPrkZcb27aECyrj8V2ytv7kWDw=\ngithub.com/spf13/cobra v1.2.1/go.mod h1:ExllRjgxM/piMAM+3tAZvg8fsklGAf3tPfi+i8t68Nk=\ngithub.com/spf13/jwalterweatherman v1.0.0/go.mod h1:cQK4TGJAtQXfYWX+Ddv3mKDzgVb68N+wFjFa4jdeBTo=\ngithub.com/spf13/jwalterweatherman v1.1.0/go.mod h1:aNWZUN0dPAAO/Ljvb5BEdw96iTZ0EXowPYD95IqWIGo=\ngithub.com/spf13/pflag v0.0.0-20170130214245-9ff6c6923cff/go.mod h1:DYY7MBk1bdzusC3SYhjObp+wFpr4gzcvqqNjLnInEg4=\ngithub.com/spf13/pflag v1.0.1/go.mod h1:DYY7MBk1bdzusC3SYhjObp+wFpr4gzcvqqNjLnInEg4=\ngithub.com/spf13/pflag v1.0.3/go.mod h1:DYY7MBk1bdzusC3SYhjObp+wFpr4gzcvqqNjLnInEg4=\ngithub.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=\ngithub.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=\ngithub.com/spf13/viper v1.4.0/go.mod h1:PTJ7Z/lr49W6bUbkmS1V3by4uWynFiR9p7+dSq/yZzE=\ngithub.com/spf13/viper v1.7.0/go.mod h1:8WkrPz2fc9jxqZNCJI/76HCieCp4Q8HaLFoCha5qpdg=\ngithub.com/spf13/viper v1.8.1/go.mod h1:o0Pch8wJ9BVSWGQMbra6iw0oQ5oktSIBaujf1rJH9Ns=\ngithub.com/ssor/bom v0.0.0-20170718123548-6386211fdfcf/go.mod h1:RJID2RhlZKId02nZ62WenDCkgHFerpIOmW0iT7GKmXM=\ngithub.com/stoewer/go-strcase v1.2.0/go.mod h1:IBiWB2sKIp3wVVQ3Y035++gc+knqhUQag1KpM8ahLw8=\ngithub.com/storageos/go-api v2.2.0+incompatible/go.mod h1:ZrLn+e0ZuF3Y65PNF6dIwbJPZqfmtCXxFm9ckv0agOY=\ngithub.com/streadway/amqp v0.0.0-20190404075320-75d898a42a94/go.mod h1:AZpEONHx3DKn8O/DFsRAY58/XVQiIPMTMB1SddzLXVw=\ngithub.com/streadway/amqp v0.0.0-20190827072141-edfb9018d271/go.mod h1:AZpEONHx3DKn8O/DFsRAY58/XVQiIPMTMB1SddzLXVw=\ngithub.com/streadway/handy v0.0.0-20190108123426-d5acb3125c2a/go.mod h1:qNTQ5P5JnDBl6z3cMAg/SywNDC5ABu5ApDIw6lUbRmI=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.2.0 h1:Hbg2NidpLE8veEBkEZTL3CvlkUIVzuU9jDplZO54c48=\ngithub.com/stretchr/objx v0.2.0/go.mod h1:qt09Ya8vawLte6SNmTgCsAVtYtaKzEcn8ATUoHMkEqE=\ngithub.com/stretchr/testify v0.0.0-20161117074351-18a02ba4a312/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=\ngithub.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=\ngithub.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.0 h1:nwc3DEeHmmLAfoZucVR881uASk0Mfjw8xYJ99tb5CcY=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/subosito/gotenv v1.2.0/go.mod h1:N0PQaV/YGNqwC0u51sEeR/aUtSLEXKX9iv69rRypqCw=\ngithub.com/syndtr/gocapability v0.0.0-20200815063812-42c35b437635/go.mod h1:hkRG7XYTFWNJGYcbNJQlaLq0fg1yr4J4t/NcTQtrfww=\ngithub.com/tidwall/pretty v1.0.0 h1:HsD+QiTn7sK6flMKIvNmpqz1qrpP3Ps6jOKIKMooyg4=\ngithub.com/tidwall/pretty v1.0.0/go.mod h1:XNkn88O1ChpSDQmQeStsy+sBenx6DDtFZJxhVysOjyk=\ngithub.com/tmc/grpc-websocket-proxy v0.0.0-20170815181823-89b8d40f7ca8/go.mod h1:ncp9v5uamzpCO7NfCPTXjqaC+bZgJeR0sMTm6dMHP7U=\ngithub.com/tmc/grpc-websocket-proxy v0.0.0-20190109142713-0ad062ec5ee5/go.mod h1:ncp9v5uamzpCO7NfCPTXjqaC+bZgJeR0sMTm6dMHP7U=\ngithub.com/tmc/grpc-websocket-proxy v0.0.0-20201229170055-e5319fda7802/go.mod h1:ncp9v5uamzpCO7NfCPTXjqaC+bZgJeR0sMTm6dMHP7U=\ngithub.com/ugorji/go v1.1.4/go.mod h1:uQMGLiO92mf5W77hV/PUCpI3pbzQx3CRekS0kk+RGrc=\ngithub.com/ugorji/go v1.1.7/go.mod h1:kZn38zHttfInRq0xu/PH0az30d+z6vm202qpg1oXVMw=\ngithub.com/ugorji/go/codec v1.1.7/go.mod h1:Ax+UKWsSmolVDwsd+7N3ZtXu+yMGCf907BLYF3GoBXY=\ngithub.com/undefinedlabs/go-mpatch v1.0.6 h1:h8q5ORH/GaOE1Se1DMhrOyljXZEhRcROO7agMqWXCOY=\ngithub.com/undefinedlabs/go-mpatch v1.0.6/go.mod h1:TyJZDQ/5AgyN7FSLiBJ8RO9u2c6wbtRvK827b6AVqY4=\ngithub.com/urfave/cli v1.20.0/go.mod h1:70zkFmudgCuE/ngEzBv17Jvp/497gISqfk5gWijbERA=\ngithub.com/urfave/cli v1.22.1/go.mod h1:Gos4lmkARVdJ6EkW0WaNv/tZAAMe9V7XWyB60NtXRu0=\ngithub.com/urfave/cli v1.22.2/go.mod h1:Gos4lmkARVdJ6EkW0WaNv/tZAAMe9V7XWyB60NtXRu0=\ngithub.com/urfave/negroni v1.0.0/go.mod h1:Meg73S6kFm/4PpbYdq35yYWoCZ9mS/YSx+lKnmiohz4=\ngithub.com/vektah/gqlparser v1.1.2/go.mod h1:1ycwN7Ij5njmMkPPAOaRFY4rET2Enx7IkVv3vaXspKw=\ngithub.com/vishvananda/netlink v1.1.0/go.mod h1:cTgwzPIzzgDAYoQrMm0EdrjRUBkTqKYppBueQtXaqoE=\ngithub.com/vishvananda/netns v0.0.0-20191106174202-0a2b9b5464df/go.mod h1:JP3t17pCcGlemwknint6hfoeCVQrEMVwxRLRjXpq+BU=\ngithub.com/vishvananda/netns v0.0.0-20200728191858-db3c7e526aae/go.mod h1:DD4vA1DwXk04H54A1oHXtwZmA0grkVMdPxx/VGLCah0=\ngithub.com/vmihailenco/go-tinylfu v0.2.1 h1:78/wH+STtgM8+fN2GdjvvKoxF3mkdzoOoKQTchQRj+g=\ngithub.com/vmihailenco/go-tinylfu v0.2.1/go.mod h1:CutYi2Q9puTxfcolkliPq4npPuofg9N9t8JVrjzwa3Q=\ngithub.com/vmihailenco/msgpack/v5 v5.3.4 h1:qMKAwOV+meBw2Y8k9cVwAy7qErtYCwBzZ2ellBfvnqc=\ngithub.com/vmihailenco/msgpack/v5 v5.3.4/go.mod h1:7xyJ9e+0+9SaZT0Wt1RGleJXzli6Q/V5KbhBonMG9jc=\ngithub.com/vmihailenco/tagparser/v2 v2.0.0 h1:y09buUbR+b5aycVFQs/g70pqKVZNBmxwAhO7/IwNM9g=\ngithub.com/vmihailenco/tagparser/v2 v2.0.0/go.mod h1:Wri+At7QHww0WTrCBeu4J6bNtoV6mEfg5OIWRZA9qds=\ngithub.com/vmware/govmomi v0.20.3/go.mod h1:URlwyTFZX72RmxtxuaFL2Uj3fD1JTvZdx59bHWk6aFU=\ngithub.com/whilp/git-urls v0.0.0-20191001220047-6db9661140c0 h1:qqllXPzXh+So+mmANlX/gCJrgo+1kQyshMoQ+NASzm0=\ngithub.com/whilp/git-urls v0.0.0-20191001220047-6db9661140c0/go.mod h1:2rx5KE5FLD0HRfkkpyn8JwbVLBdhgeiOb2D2D9LLKM4=\ngithub.com/xanzy/ssh-agent v0.3.0 h1:wUMzuKtKilRgBAD1sUb8gOwwRr2FGoBVumcjoOACClI=\ngithub.com/xanzy/ssh-agent v0.3.0/go.mod h1:3s9xbODqPuuhK9JV1R321M/FlMZSBvE5aY6eAcqrDh0=\ngithub.com/xiang90/probing v0.0.0-20190116061207-43a291ad63a2/go.mod h1:UETIi67q53MR2AWcXfiuqkDkRtnGDLqkBTpCHuJHxtU=\ngithub.com/xlab/treeprint v0.0.0-20181112141820-a009c3971eca h1:1CFlNzQhALwjS9mBAUkycX616GzgsuYUOCHA5+HSlXI=\ngithub.com/xlab/treeprint v0.0.0-20181112141820-a009c3971eca/go.mod h1:ce1O1j6UtZfjr22oyGxGLbauSBp2YVXpARAosm7dHBg=\ngithub.com/xordataexchange/crypt v0.0.3-0.20170626215501-b2862e3d0a77/go.mod h1:aYKd//L2LvnjZzWKhF00oedf4jCCReLcmhLdhm1A27Q=\ngithub.com/yuin/goldmark v1.1.25/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.1.32/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.3.5/go.mod h1:mwnBkeHKe2W/ZEtQ+71ViKU8L12m81fl3OWwC1Zlc8k=\ngithub.com/yuin/goldmark v1.4.0/go.mod h1:mwnBkeHKe2W/ZEtQ+71ViKU8L12m81fl3OWwC1Zlc8k=\ngithub.com/yuin/gopher-lua v0.0.0-20200816102855-ee81675732da h1:NimzV1aGyq29m5ukMK0AMWEhFaL/lrEOaephfuoiARg=\ngithub.com/yuin/gopher-lua v0.0.0-20200816102855-ee81675732da/go.mod h1:E1AXubJBdNmFERAOucpDIxNzeGfLzg0mYh+UfMWdChA=\ngo.etcd.io/bbolt v1.3.2/go.mod h1:IbVyRI1SCnLcuJnV2u8VeU0CEYM7e686BmAb1XKL+uU=\ngo.etcd.io/bbolt v1.3.3/go.mod h1:IbVyRI1SCnLcuJnV2u8VeU0CEYM7e686BmAb1XKL+uU=\ngo.etcd.io/bbolt v1.3.6/go.mod h1:qXsaaIqmgQH0T+OPdb99Bf+PKfBBQVAdyD6TY9G8XM4=\ngo.etcd.io/etcd v0.0.0-20191023171146-3cf2f69b5738/go.mod h1:dnLIgRNXwCJa5e+c6mIZCrds/GIG4ncV9HhK5PX7jPg=\ngo.etcd.io/etcd/api/v3 v3.5.0/go.mod h1:cbVKeC6lCfl7j/8jBhAK6aIYO9XOjdptoxU/nLQcPvs=\ngo.etcd.io/etcd/client/pkg/v3 v3.5.0/go.mod h1:IJHfcCEKxYu1Os13ZdwCwIUTUVGYTSAM3YSwc9/Ac1g=\ngo.etcd.io/etcd/client/v2 v2.305.0/go.mod h1:h9puh54ZTgAKtEbut2oe9P4L/oqKCVB6xsXlzd7alYQ=\ngo.etcd.io/etcd/client/v3 v3.5.0/go.mod h1:AIKXXVX/DQXtfTEqBryiLTUXwON+GuvO6Z7lLS/oTh0=\ngo.etcd.io/etcd/pkg/v3 v3.5.0/go.mod h1:UzJGatBQ1lXChBkQF0AuAtkRQMYnHubxAEYIrC3MSsE=\ngo.etcd.io/etcd/raft/v3 v3.5.0/go.mod h1:UFOHSIvO/nKwd4lhkwabrTD3cqW5yVyYYf/KlD00Szc=\ngo.etcd.io/etcd/server/v3 v3.5.0/go.mod h1:3Ah5ruV+M+7RZr0+Y/5mNLwC+eQlni+mQmOVdCRJoS4=\ngo.mongodb.org/mongo-driver v1.0.3/go.mod h1:u7ryQJ+DOzQmeO7zB6MHyr8jkEQvC8vH7qLUO4lqsUM=\ngo.mongodb.org/mongo-driver v1.1.1/go.mod h1:u7ryQJ+DOzQmeO7zB6MHyr8jkEQvC8vH7qLUO4lqsUM=\ngo.mongodb.org/mongo-driver v1.1.2 h1:jxcFYjlkl8xaERsgLo+RNquI0epW6zuy/ZRQs6jnrFA=\ngo.mongodb.org/mongo-driver v1.1.2/go.mod h1:u7ryQJ+DOzQmeO7zB6MHyr8jkEQvC8vH7qLUO4lqsUM=\ngo.opencensus.io v0.20.1/go.mod h1:6WKK9ahsWS3RSO+PY9ZHZUfv2irvY6gN279GOPZjmmk=\ngo.opencensus.io v0.20.2/go.mod h1:6WKK9ahsWS3RSO+PY9ZHZUfv2irvY6gN279GOPZjmmk=\ngo.opencensus.io v0.21.0/go.mod h1:mSImk1erAIZhrmZN+AvHh14ztQfjbGwt4TtuofqLduU=\ngo.opencensus.io v0.22.0/go.mod h1:+kGneAE2xo2IficOXnaByMWTGM9T73dGwxeWcUqIpI8=\ngo.opencensus.io v0.22.2/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=\ngo.opencensus.io v0.22.3/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=\ngo.opencensus.io v0.22.4/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=\ngo.opencensus.io v0.22.5/go.mod h1:5pWMHQbX5EPX2/62yrJeAkowc+lfs/XD7Uxpq3pI6kk=\ngo.opencensus.io v0.23.0/go.mod h1:XItmlyltB5F7CS4xOC1DcqMoFqwtC6OG2xF7mCv7P7E=\ngo.opentelemetry.io/contrib v0.20.0/go.mod h1:G/EtFaa6qaN7+LxqfIAT3GiZa7Wv5DTBUzl5H4LY0Kc=\ngo.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.20.0/go.mod h1:oVGt1LRbBOBq1A5BQLlUg9UaU/54aiHw8cgjV3aWZ/E=\ngo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.20.0/go.mod h1:2AboqHi0CiIZU0qwhtUfCYD1GeUzvvIXWNkhDt7ZMG4=\ngo.opentelemetry.io/otel v0.20.0/go.mod h1:Y3ugLH2oa81t5QO+Lty+zXf8zC9L26ax4Nzoxm/dooo=\ngo.opentelemetry.io/otel/exporters/otlp v0.20.0/go.mod h1:YIieizyaN77rtLJra0buKiNBOm9XQfkPEKBeuhoMwAM=\ngo.opentelemetry.io/otel/metric v0.20.0/go.mod h1:598I5tYlH1vzBjn+BTuhzTCSb/9debfNp6R3s7Pr1eU=\ngo.opentelemetry.io/otel/oteltest v0.20.0/go.mod h1:L7bgKf9ZB7qCwT9Up7i9/pn0PWIa9FqQ2IQ8LoxiGnw=\ngo.opentelemetry.io/otel/sdk v0.20.0/go.mod h1:g/IcepuwNsoiX5Byy2nNV0ySUF1em498m7hBWC279Yc=\ngo.opentelemetry.io/otel/sdk/export/metric v0.20.0/go.mod h1:h7RBNMsDJ5pmI1zExLi+bJK+Dr8NQCh0qGhm1KDnNlE=\ngo.opentelemetry.io/otel/sdk/metric v0.20.0/go.mod h1:knxiS8Xd4E/N+ZqKmUPf3gTTZ4/0TjTXukfxjzSTpHE=\ngo.opentelemetry.io/otel/trace v0.20.0/go.mod h1:6GjCW8zgDjwGHGa6GkyeB8+/5vjT16gUEi0Nf1iBdgw=\ngo.opentelemetry.io/proto/otlp v0.7.0/go.mod h1:PqfVotwruBrMGOCsRd/89rSnXhoiJIqeYNgFYFoEGnI=\ngo.starlark.net v0.0.0-20200306205701-8dd3e2ee1dd5 h1:+FNtrFTmVw0YZGpBGX56XDee331t6JAXeK2bcyhLOOc=\ngo.starlark.net v0.0.0-20200306205701-8dd3e2ee1dd5/go.mod h1:nmDLcffg48OtT/PSW0Hg7FvpRQsQh5OSqIylirxKC7o=\ngo.uber.org/atomic v1.3.2/go.mod h1:gD2HeocX3+yG+ygLZcrzQJaqmWj9AIm7n08wl/qW/PE=\ngo.uber.org/atomic v1.4.0/go.mod h1:gD2HeocX3+yG+ygLZcrzQJaqmWj9AIm7n08wl/qW/PE=\ngo.uber.org/atomic v1.5.0/go.mod h1:sABNBOSYdrvTF6hTgEIbc7YasKWGhgEQZyfxyTvoXHQ=\ngo.uber.org/atomic v1.6.0/go.mod h1:sABNBOSYdrvTF6hTgEIbc7YasKWGhgEQZyfxyTvoXHQ=\ngo.uber.org/atomic v1.7.0 h1:ADUqmZGgLDDfbSL9ZmPxKTybcoEYHgpYfELNoN+7hsw=\ngo.uber.org/atomic v1.7.0/go.mod h1:fEN4uk6kAWBTFdckzkM89CLk9XfWZrxpCo0nPH17wJc=\ngo.uber.org/goleak v1.1.10/go.mod h1:8a7PlsEVH3e/a/GLqe5IIrQx6GzcnRmZEufDUTk4A7A=\ngo.uber.org/goleak v1.1.11-0.20210813005559-691160354723/go.mod h1:cwTWslyiVhfpKIDGSZEM2HlOvcqm+tG4zioyIeLoqMQ=\ngo.uber.org/goleak v1.1.12/go.mod h1:cwTWslyiVhfpKIDGSZEM2HlOvcqm+tG4zioyIeLoqMQ=\ngo.uber.org/multierr v1.1.0/go.mod h1:wR5kodmAFQ0UK8QlbwjlSNy0Z68gJhDJUG5sjR94q/0=\ngo.uber.org/multierr v1.3.0/go.mod h1:VgVr7evmIr6uPjLBxg28wmKNXyqE9akIJ5XnfpiKl+4=\ngo.uber.org/multierr v1.5.0/go.mod h1:FeouvMocqHpRaaGuG9EjoKcStLC43Zu/fmqdUMPcKYU=\ngo.uber.org/multierr v1.6.0 h1:y6IPFStTAIT5Ytl7/XYmHvzXQ7S3g/IeZW9hyZ5thw4=\ngo.uber.org/multierr v1.6.0/go.mod h1:cdWPpRnG4AhwMwsgIHip0KRBQjJy5kYEpYjJxpXp9iU=\ngo.uber.org/tools v0.0.0-20190618225709-2cfd321de3ee/go.mod h1:vJERXedbb3MVM5f9Ejo0C68/HhF8uaILCdgjnY+goOA=\ngo.uber.org/zap v1.10.0/go.mod h1:vwi/ZaCAaUcBkycHslxD9B2zi4UTXhF60s6SWpuDF0Q=\ngo.uber.org/zap v1.13.0/go.mod h1:zwrFLgMcdUuIBviXEYEH1YKNaOBnKXsx2IPda5bBwHM=\ngo.uber.org/zap v1.16.0/go.mod h1:MA8QOfq0BHJwdXa996Y4dYkAqRKB8/1K1QMMZVaNZjQ=\ngo.uber.org/zap v1.17.0/go.mod h1:MXVU+bhUf/A7Xi2HNOnopQOrmycQ5Ih87HtOu4q5SSo=\ngo.uber.org/zap v1.19.0/go.mod h1:xg/QME4nWcxGxrpdeYfq7UvYrLh66cuVKdrbD1XF/NI=\ngo.uber.org/zap v1.19.1 h1:ue41HOKd1vGURxrmeKIgELGb3jPW9DMUDGtsinblHwI=\ngo.uber.org/zap v1.19.1/go.mod h1:j3DNczoxDZroyBnOT1L/Q79cfUMGZxlv/9dzN7SM1rI=\ngolang.org/x/crypto v0.0.0-20180904163835-0709b304e793/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20181029021203-45a5f77698d3/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20181030102418-4d3f4d9ffa16/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20190211182817-74369b46fc67/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20190219172222-a4c6cb3142f2/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20190320223903-b7391e95e576/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20190422183909-d864b10871cd/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20190510104115-cbcb75029529/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20190513172903-22d7a77e9e5f/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20190605123033-f99c8df09eb5/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20190611184440-5c40567a22f8/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20190617133340-57b3e21c3d56/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20190701094942-4def268fd1a4/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20190820162420-60c769a6c586/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.0.0-20201002170205-7f63de1d35b0/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.0.0-20210322153248-0c34fe9e7dc2/go.mod h1:T9bdIzuCu7OtxOm1hfPfRQxPLYneinmdGuTeoZ9dtd4=\ngolang.org/x/crypto v0.0.0-20210421170649-83a5a9bb288b/go.mod h1:T9bdIzuCu7OtxOm1hfPfRQxPLYneinmdGuTeoZ9dtd4=\ngolang.org/x/crypto v0.0.0-20210817164053-32db794688a5 h1:HWj/xjIHfjYU5nVXpTM0s39J9CbLn7Cc5a7IC5rwsMQ=\ngolang.org/x/crypto v0.0.0-20210817164053-32db794688a5/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/exp v0.0.0-20180321215751-8460e604b9de/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20180807140117-3d87b88a115f/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20190125153040-c74c464bbbf2/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20190306152737-a1d7652674e8/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20190312203227-4b39c73a6495/go.mod h1:ZjyILWgesfNpC6sMxTJOJm9Kp84zZh5NQWvqDGG3Qr8=\ngolang.org/x/exp v0.0.0-20190510132918-efd6b22b2522/go.mod h1:ZjyILWgesfNpC6sMxTJOJm9Kp84zZh5NQWvqDGG3Qr8=\ngolang.org/x/exp v0.0.0-20190731235908-ec7cb31e5a56/go.mod h1:JhuoJpWY28nO4Vef9tZUw9qufEGTyX1+7lmHxV5q5G4=\ngolang.org/x/exp v0.0.0-20190829153037-c13cbed26979/go.mod h1:86+5VVa7VpoJ4kLfm080zCjGlMRFzhUhsZKEZO7MGek=\ngolang.org/x/exp v0.0.0-20191030013958-a1ab85dbe136/go.mod h1:JXzH8nQsPlswgeRAPE3MuO9GYsAcnJvJ4vnMwN/5qkY=\ngolang.org/x/exp v0.0.0-20191129062945-2f5052295587/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=\ngolang.org/x/exp v0.0.0-20191227195350-da58074b4299/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=\ngolang.org/x/exp v0.0.0-20200119233911-0405dc783f0a/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=\ngolang.org/x/exp v0.0.0-20200207192155-f17229e696bd/go.mod h1:J/WKrq2StrnmMY6+EHIKF9dgMWnmCNThgcyBT1FY9mM=\ngolang.org/x/exp v0.0.0-20200224162631-6cc2880d07d6/go.mod h1:3jZMyOhIsHpP37uCMkUooju7aAi5cS1Q23tOzKc+0MU=\ngolang.org/x/exp v0.0.0-20210220032938-85be41e4509f/go.mod h1:I6l2HNBLBZEcrOoCpyKLdY2lHoRZ8lI4x60KMCQDft4=\ngolang.org/x/exp v0.0.0-20210901193431-a062eea981d2 h1:Or4Ra3AAlhUlNn8WmIzw2Yq2vUHSkrP6E2e/FIESpF8=\ngolang.org/x/exp v0.0.0-20210901193431-a062eea981d2/go.mod h1:a3o/VtDNHN+dCVLEpzjjUHOzR+Ln3DHX056ZPzoZGGA=\ngolang.org/x/image v0.0.0-20180708004352-c73c2afc3b81/go.mod h1:ux5Hcp/YLpHSI86hEcLt0YII63i6oz57MZXIpbrjZUs=\ngolang.org/x/image v0.0.0-20190227222117-0694c2d4d067/go.mod h1:kZ7UVZpmo3dzQBMxlp+ypCbDeSB+sBbTgSJuh5dn5js=\ngolang.org/x/image v0.0.0-20190802002840-cff245a6509b/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=\ngolang.org/x/lint v0.0.0-20180702182130-06c8688daad7/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=\ngolang.org/x/lint v0.0.0-20190301231843-5614ed5bae6f/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/lint v0.0.0-20190409202823-959b441ac422/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/lint v0.0.0-20190909230951-414d861bb4ac/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/lint v0.0.0-20190930215403-16217165b5de/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/lint v0.0.0-20191125180803-fdd1cda4f05f/go.mod h1:5qLYkcX4OjUUV8bRuDixDT3tpyyb+LUpUlRWLxfhWrs=\ngolang.org/x/lint v0.0.0-20200130185559-910be7a94367/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=\ngolang.org/x/lint v0.0.0-20200302205851-738671d3881b/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=\ngolang.org/x/lint v0.0.0-20201208152925-83fdc39ff7b5/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=\ngolang.org/x/lint v0.0.0-20210508222113-6edffad5e616/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=\ngolang.org/x/mobile v0.0.0-20190312151609-d3739f865fa6/go.mod h1:z+o9i4GpDbdi3rU15maQ/Ox0txvL9dWGYEHz965HBQE=\ngolang.org/x/mobile v0.0.0-20190719004257-d2bd2a29d028/go.mod h1:E/iHnbuqvinMTCcRqshq8CkpyQDoeVncDDYHnLhea+o=\ngolang.org/x/mobile v0.0.0-20201217150744-e6ae53a27f4f/go.mod h1:skQtrUTUwhdJvXM/2KKJzY8pDgNr9I/FOMqDVRPBUS4=\ngolang.org/x/mod v0.0.0-20190513183733-4bf6d317e70e/go.mod h1:mXi4GBBbnImb6dmsKGUJ2LatrhH/nqhxcFungHvyanc=\ngolang.org/x/mod v0.1.0/go.mod h1:0QHyrYULN0/3qlju5TqG8bIK38QM8yzMo5ekMj3DlcY=\ngolang.org/x/mod v0.1.1-0.20191105210325-c90efee705ee/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=\ngolang.org/x/mod v0.1.1-0.20191107180719-034126e5016b/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=\ngolang.org/x/mod v0.1.1-0.20191209134235-331c550502dd/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.3.1-0.20200828183125-ce943fd02449/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.4.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.4.1/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.4.2/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.5.1-0.20210830214625-1b1db11ec8f4 h1:7Qds88gNaRx0Dz/1wOwXlR7asekh1B1u26wEwN6FcEI=\ngolang.org/x/mod v0.5.1-0.20210830214625-1b1db11ec8f4/go.mod h1:5OXOZSfqPIIbmVBIIKWRFfZjPR0E5r58TLhUjH0a2Ro=\ngolang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180906233101-161cd47e91fd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181005035420-146acd28ed58/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181023162649-9b4f9f5ad519/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181114220301-adae6a3d119a/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181201002055-351d144fa1fc/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190108225652-1e06a53dbb7e/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190125091013-d26f9f9a57f3/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190320064053-1272bf9dcd53/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190501004415-9ce7a6920f09/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190503192946-f4e77d36d62c/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190522155817-f3200d17e092/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=\ngolang.org/x/net v0.0.0-20190603091049-60506f45cf65/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=\ngolang.org/x/net v0.0.0-20190607181551-461777fb6f67/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190613194153-d28f0bde5980/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190628185345-da137c7871d7/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190724013045-ca1201d0de80/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190813141303-74dc4d7220e7/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190827160401-ba9fcec4b297/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20191209160850-c0dbc17a3553/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200114155413-6afb5195e5aa/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200202094626-16171245cfb2/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200222125558-5a598a2470a0/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200301022130-244492dfa37a/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200324143707-d3edc9973b7e/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200501053045-e0ff5e5a1de5/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200506145744-7e3656a0809f/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200513185701-a91f0712d120/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200520004742-59133d7f0dd7/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200520182314-0ba52f642ac2/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200625001655-4c5254603344/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=\ngolang.org/x/net v0.0.0-20200707034311-ab3426394381/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=\ngolang.org/x/net v0.0.0-20200822124328-c89045814202/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=\ngolang.org/x/net v0.0.0-20200904194848-62affa334b73/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=\ngolang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.0.0-20201031054903-ff519b6c9102/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.0.0-20201110031124-69a78807bb2b/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.0.0-20201202161906-c7110b5ffcbb/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.0.0-20201209123823-ac852fbbde11/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20201224014010-6772e930b67b/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20210119194325-5f4716e94777/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20210316092652-d523dce5a7f4/go.mod h1:RBQZq4jEuRlivfhVLdyRGr576XBO4/greRjx4P4O3yc=\ngolang.org/x/net v0.0.0-20210326060303-6b1517762897/go.mod h1:uSPa2vr4CLtc/ILN5odXGNXS6mhrKVzTaCXzk9m6W3k=\ngolang.org/x/net v0.0.0-20210405180319-a5a99cb37ef4/go.mod h1:p54w0d4576C0XHj96bSt6lcn1PtDYWL6XObtHCRCNQM=\ngolang.org/x/net v0.0.0-20210428140749-89ef3d95e781/go.mod h1:OJAsFXCWl8Ukc7SiCT/9KSuxbyM7479/AVlXFRxuMCk=\ngolang.org/x/net v0.0.0-20210503060351-7fd8e65b6420/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/net v0.0.0-20210525063256-abc453219eb5/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/net v0.0.0-20210805182204-aaa1db679c0d/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/net v0.0.0-20210825183410-e898025ed96a/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/net v0.0.0-20211209124913-491a49abca63 h1:iocB37TsdFuN6IBRZ+ry36wrkoV51/tl5vOWqkcPGvY=\ngolang.org/x/net v0.0.0-20211209124913-491a49abca63/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/oauth2 v0.0.0-20190604053449-0f29369cfe45/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/oauth2 v0.0.0-20191202225959-858c2ad4c8b6/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/oauth2 v0.0.0-20200107190931-bf48bf16ab8d/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/oauth2 v0.0.0-20200902213428-5d25da1a8d43/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20201109201403-9fd604954f58/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20201208152858-08078c50e5b5/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20210218202405-ba52d332ba99/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20210220000619-9bb904979d93/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20210313182246-cd4f82c27b84/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20210402161424-2e8d93401602/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20210427180440-81ed05c6b58c/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20210514164344-f6687ab2804c/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20210819190943-2bc19b11175f h1:Qmd2pbz05z7z6lm0DrgQVVPuBm92jqujBKMHMOlOQEw=\ngolang.org/x/oauth2 v0.0.0-20210819190943-2bc19b11175f/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190227155943-e225da77a7e6/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20200317015054-43a5402ce75a/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20200625203802-6e8e738ad208/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20201207232520-09787c993a3a/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20210220032951-036812b2e83c h1:5KslGYwFpkhGh+Q16bwMP3cOontH8FOep7tGV86Y7SQ=\ngolang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20180823144017-11551d06cbcc/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20180909124046-d0be0721c37e/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181026203630-95b1ffbd15a5/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181107165924-66b7b1311ac8/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181116152217-5ac8a444bdc5/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181122145206-62eef0e2fa9b/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190124100055-b90733256f2e/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190204203706-41f3e6584952/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190209173611-3b5209105503/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190312061237-fead79001313/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190321052220-f7bb7a8bee54/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190422165155-953cdadca894/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190502145724-3ef323f4f1fd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190507160741-ecd444e8653b/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190606165138-5da285871e9c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190606203320-7fc4e5ec1444/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190616124812-15dcb6c0061f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190624142023-c5567b49c5d0/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190626150813-e07cf5db2756/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190726091711-fc99dfbffb4e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190813064441-fde4db37ae7a/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190826190057-c7b8b68b1456/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190904154756-749cb33beabd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190916202348-b4ddaad3f8a3/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191001151750-bb3f8db39f24/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191002063906-3421d5a6bb1c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191005200804-aed5e4c7ecf9/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191022100944-742c48ecaeb7/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191026070338-33540a1f6037/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191115151921-52ab43148777/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191120155948-bd437916bb0e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191204072324-ce4227a45e2e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191220142924-d4481acd189f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191228213918-04cbcbbfeed8/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200106162015-b016eb3dc98e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200113162924-86b910548bc1/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200116001909-b77594299b42/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200120151820-655fe14d7479/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200122134326-e047566fdf82/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200202164722-d101bd2416d5/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200212091648-12a6c2dcc1e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200217220822-9197077df867/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200223170610-d5e6a3e2c0ae/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200302150141-5c8b2ff67527/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200331124033-c3d80250170d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200501052902-10377860bb8e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200511232937-7e40ca221e25/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200515095857-1151b9dac4a9/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200519105757-fe76b779f299/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200523222454-059865788121/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200615200032-f1bc736245b1/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200625212154-ddb9806d33ae/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200803210538-64077c9b5642/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200831180312-196b9ba8737a/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200905004654-be1d3432aa8f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200909081042-eff7692f9009/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200916030750-2334cc1a136f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200923182605-d9f96fdee20d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201201145000-ef89a241ccb3/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210104204734-6f8348627aad/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210112080510-489259a85091/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210119212857-b64e53b001e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210124154548-22da62e12c0c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210220050731-9a76102bfb43/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210301091718-77cc2087c03b/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210305230114-8fe3ee5dd75b/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210315160823-c6e025ad8005/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210320140829-1e4c9ba3b0c4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210324051608-47abb6519492/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210330210617-4fbd30eecc44/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210403161142-5e06dd20ab57/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210426230700-d19ff857e887/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210502180810-71e4cd670f79/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210503080704-8803ae5d1324/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210510120138-977fb7262007/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210603081109-ebe580a85c40/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210608053332-aa57babbf139/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210616094352-59db8d763f22/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210630005230-0f9fa26af87c/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210809222454-d867a43fc93e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210831042530-f4d43177bf5e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20211029165221-6e7872819dc8 h1:M69LAlWZCshgp0QSzyDcSsSIejIEeuaCVpmwcKwyLMk=\ngolang.org/x/sys v0.0.0-20211029165221-6e7872819dc8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210615171337-6886f2dfbf5b h1:9zKuko04nR4gjZ4+DNjHqRlAJqbJETHwiNKDqTfOjfE=\ngolang.org/x/term v0.0.0-20210615171337-6886f2dfbf5b/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.4/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.5/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7 h1:olpwvP2KacW1ZWvsR7uQhoyTYvKAupfQrRGBFM352Gk=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/time v0.0.0-20180412165947-fbb02b2291d2/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20191024005414-555d28b269f0/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20210220033141-f8bda1e9f3ba/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20210723032227-1f47c861a9ac h1:7zkz7BUtwNFFqcowJ+RIgu2MaV/MapERkDIy+mwPyjs=\ngolang.org/x/time v0.0.0-20210723032227-1f47c861a9ac/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/tools v0.0.0-20180221164845-07fd8470d635/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20180525024113-a5b4c53f6e8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20180828015842-6cd1fcedba52/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20181030221726-6c7e314b6563/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20181221001348-537d06c36207/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190125232054-d66bd3c5d5a6/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190206041539-40960b6deb8e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=\ngolang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190312151545-0bb0c0a6e846/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190312170243-e65039ee4138/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190328211700-ab21143f2384/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190425150028-36563e24a262/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20190506145303-2d16b83fe98c/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20190606124116-d0a3d012864b/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20190614205625-5aca471b1d59/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20190617190820-da514acc4774/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20190621195816-6e04913cbbac/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20190624222133-a101b041ded4/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20190628153133-6cdbf07be9d0/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20190816200558-6889da9d5479/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20190911174233-4f2ddba30aff/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191012152004-8de300cfc20a/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191029041327-9cc4af7d6b2c/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191029190741-b9c20aec41a5/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191108193012-7d206e10da11/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191112195655-aa38f8e97acc/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191113191852-77e3bb0ad9e7/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191115202509-3a792d9c32b2/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191125144606-a911d9008d1f/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191130070609-6e064ea0cf2d/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191216173652-a0e659d51361/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20191227053925-7b8e75db28f4/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200103221440-774c71fcf114/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200117012304-6edc0a871e69/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200117161641-43d50277825c/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200122220014-bf1340f18c4a/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200130002326-2f3ba24bd6e7/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200204074204-1cc6d1ef6c74/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200207183749-b753a1ba74fa/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200212150539-ea181f53ac56/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200224181240-023911ca70b2/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200227222343-706bc42d1f0d/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200304193943-95d2e580d8eb/go.mod h1:o4KQGtdN14AW+yjsvvwRTJJuXz8XRtIHtEnmAXLyFUw=\ngolang.org/x/tools v0.0.0-20200312045724-11d5b4c81c7d/go.mod h1:o4KQGtdN14AW+yjsvvwRTJJuXz8XRtIHtEnmAXLyFUw=\ngolang.org/x/tools v0.0.0-20200331025713-a30bf2db82d4/go.mod h1:Sl4aGygMT6LrqrWclx+PTx3U+LnKx/seiNR+3G19Ar8=\ngolang.org/x/tools v0.0.0-20200501065659-ab2804fb9c9d/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200505023115-26f46d2f7ef8/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200512131952-2bc93b1c0c88/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200515010526-7d3b6ebf133d/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200618134242-20370b0cb4b2/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200619180055-7c47624df98f/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200729194436-6467de6f59a7/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=\ngolang.org/x/tools v0.0.0-20200804011535-6c149bb5ef0d/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=\ngolang.org/x/tools v0.0.0-20200825202427-b303f430e36d/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=\ngolang.org/x/tools v0.0.0-20200904185747-39188db58858/go.mod h1:Cj7w3i3Rnn0Xh82ur9kSqwfTHTeVxaDqrfMjpcNT6bE=\ngolang.org/x/tools v0.0.0-20201110124207-079ba7bd75cd/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/tools v0.0.0-20201201161351-ac6f37ff4c2a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/tools v0.0.0-20201208233053-a543418bbed2/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/tools v0.0.0-20201224043029-2b0845dc783e/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/tools v0.0.0-20210105154028-b0ab187a4818/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/tools v0.0.0-20210106214847-113979e3529a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/tools v0.1.0/go.mod h1:xkSsbof2nBLbhDlRMhhhyNLN/zl3eTqcnHD5viDpcZ0=\ngolang.org/x/tools v0.1.2/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\ngolang.org/x/tools v0.1.5/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\ngolang.org/x/tools v0.1.6-0.20210820212750-d4cc65f0b2ff h1:VX/uD7MK0AHXGiScH3fsieUQUcpmRERPDYtqZdJnA+Q=\ngolang.org/x/tools v0.1.6-0.20210820212750-d4cc65f0b2ff/go.mod h1:YD9qOF0M9xpSpdWTBbzEl5e/RnCefISl8E5Noe10jFM=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1 h1:go1bK/D/BFZV2I8cIQd1NKEZ+0owSTG1fDTci4IqFcE=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngomodules.xyz/envconfig v1.3.1-0.20190308184047-426f31af0d45 h1:juzzlx91nWAOsHuOVfXZPMXHtJEKouZvY9bBbwlOeYs=\ngomodules.xyz/envconfig v1.3.1-0.20190308184047-426f31af0d45/go.mod h1:41y72mzHT7+jFNgyBpJRrZWuZJcLmLrTpq6iGgOFJMQ=\ngomodules.xyz/jsonpatch/v2 v2.2.0 h1:4pT439QV83L+G9FkcCriY6EkpcK6r6bK+A5FBUMI7qY=\ngomodules.xyz/jsonpatch/v2 v2.2.0/go.mod h1:WXp+iVDkoLQqPudfQ9GBlwB2eZ5DKOnjQZCYdOS8GPY=\ngomodules.xyz/notify v0.1.0 h1:lN7CAFKIWxaXJXm3F/7KTbgw3lUy9peh6iyjgj1skvA=\ngomodules.xyz/notify v0.1.0/go.mod h1:wGy0vLXGpabCg0j9WbjzXf7pM7Khz11FqCLtBbTujP0=\ngonum.org/v1/gonum v0.0.0-20180816165407-929014505bf4/go.mod h1:Y+Yx5eoAFn32cQvJDxZx5Dpnq+c3wtXuadVZAcxbbBo=\ngonum.org/v1/gonum v0.0.0-20190331200053-3d26580ed485/go.mod h1:2ltnJ7xHfj0zHS40VVPYEAAMTa3ZGguvHGBSJeRWqE0=\ngonum.org/v1/gonum v0.6.2/go.mod h1:9mxDZsDKxgMAuccQkewq682L+0eCu4dCN2yonUJTCLU=\ngonum.org/v1/netlib v0.0.0-20190313105609-8cb42192e0e0/go.mod h1:wa6Ws7BG/ESfp6dHfk7C6KdzKA7wR7u/rKwOGE66zvw=\ngonum.org/v1/netlib v0.0.0-20190331212654-76723241ea4e/go.mod h1:kS+toOQn6AQKjmKJ7gzohV1XkqsFehRA2FbsbkopSuQ=\ngonum.org/v1/plot v0.0.0-20190515093506-e2840ee46a6b/go.mod h1:Wt8AAjI+ypCyYX3nZBvf6cAIx93T+c/OS2HFAYskSZc=\ngoogle.golang.org/api v0.3.1/go.mod h1:6wY9I6uQWHQ8EM57III9mq/AjF+i8G65rmVagqKMtkk=\ngoogle.golang.org/api v0.4.0/go.mod h1:8k5glujaEP+g9n7WNsDg8QP6cUVNI86fCNMcbazEtwE=\ngoogle.golang.org/api v0.7.0/go.mod h1:WtwebWUNSVBH/HAw79HIFXZNqEvBhG+Ra+ax0hx3E3M=\ngoogle.golang.org/api v0.8.0/go.mod h1:o4eAsZoiT+ibD93RtjEohWalFOjRDx6CVaqeizhEnKg=\ngoogle.golang.org/api v0.9.0/go.mod h1:o4eAsZoiT+ibD93RtjEohWalFOjRDx6CVaqeizhEnKg=\ngoogle.golang.org/api v0.13.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=\ngoogle.golang.org/api v0.14.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=\ngoogle.golang.org/api v0.15.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=\ngoogle.golang.org/api v0.17.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.18.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.19.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.20.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.22.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.24.0/go.mod h1:lIXQywCXRcnZPGlsd8NbLnOjtAoL6em04bJ9+z0MncE=\ngoogle.golang.org/api v0.28.0/go.mod h1:lIXQywCXRcnZPGlsd8NbLnOjtAoL6em04bJ9+z0MncE=\ngoogle.golang.org/api v0.29.0/go.mod h1:Lcubydp8VUV7KeIHD9z2Bys/sm/vGKnG1UHuDBSrHWM=\ngoogle.golang.org/api v0.30.0/go.mod h1:QGmEvQ87FHZNiUVJkT14jQNYJ4ZJjdRF23ZXz5138Fc=\ngoogle.golang.org/api v0.35.0/go.mod h1:/XrVsuzM0rZmrsbjJutiuftIzeuTQcEeaYcSk/mQ1dg=\ngoogle.golang.org/api v0.36.0/go.mod h1:+z5ficQTmoYpPn8LCUNVpK5I7hwkpjbcgqA7I34qYtE=\ngoogle.golang.org/api v0.40.0/go.mod h1:fYKFpnQN0DsDSKRVRcQSDQNtqWPfM9i+zNPxepjRCQ8=\ngoogle.golang.org/api v0.41.0/go.mod h1:RkxM5lITDfTzmyKFPt+wGrCJbVfniCr2ool8kTBzRTU=\ngoogle.golang.org/api v0.43.0/go.mod h1:nQsDGjRXMo4lvh5hP0TKqF244gqhGcr/YSIykhUk/94=\ngoogle.golang.org/api v0.44.0/go.mod h1:EBOGZqzyhtvMDoxwS97ctnh0zUmYY6CxqXsc1AvkYD8=\ngoogle.golang.org/api v0.46.0/go.mod h1:ceL4oozhkAiTID8XMmJBsIxID/9wMXJVVFXPg4ylg3I=\ngoogle.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=\ngoogle.golang.org/appengine v1.2.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/appengine v1.5.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/appengine v1.6.1/go.mod h1:i06prIuMbXzDqacNJfV5OdTW448YApPu5ww/cMBSeb0=\ngoogle.golang.org/appengine v1.6.5/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=\ngoogle.golang.org/appengine v1.6.6/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=\ngoogle.golang.org/appengine v1.6.7 h1:FZR1q0exgwxzPzp/aF+VccGrSfxfPpkBqjIIEq3ru6c=\ngoogle.golang.org/appengine v1.6.7/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=\ngoogle.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20190307195333-5fe7a883aa19/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190418145605-e7d98fc518a7/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190425155659-357c62f0e4bb/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190502173448-54afdca5d873/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190530194941-fb225487d101/go.mod h1:z3L6/3dTEVtUr6QSP8miRzeRqwQOioJ9I66odjN4I7s=\ngoogle.golang.org/genproto v0.0.0-20190801165951-fa694d86fc64/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=\ngoogle.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=\ngoogle.golang.org/genproto v0.0.0-20190911173649-1774047e7e51/go.mod h1:IbNlFCBrqXvoKpeg0TB2l7cyZUmoaFKYIwrEpbDKLA8=\ngoogle.golang.org/genproto v0.0.0-20191108220845-16a3f7862a1a/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20191115194625-c23dd37a84c9/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20191216164720-4f79533eabd1/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20191230161307-f3c370f40bfb/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20200115191322-ca5a22157cba/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20200117163144-32f20d992d24/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20200122232147-0452cf42e150/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20200204135345-fa8e72b47b90/go.mod h1:GmwEX6Z4W5gMy59cAlVYjN9JhxgbQH6Gn+gFDQe2lzA=\ngoogle.golang.org/genproto v0.0.0-20200212174721-66ed5ce911ce/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200224152610-e50cd9704f63/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200228133532-8c2c7df3a383/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200305110556-506484158171/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200312145019-da6875a35672/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200331122359-1ee6d9798940/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200423170343-7949de9c1215/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200430143042-b979b6f78d84/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200511104702-f5ebc3bea380/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200513103714-09dca8ec2884/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200515170657-fc4c6c6a6587/go.mod h1:YsZOwe1myG/8QRHRsmBRE1LrgQY60beZKjly0O1fX9U=\ngoogle.golang.org/genproto v0.0.0-20200526211855-cb27e3aa2013/go.mod h1:NbSheEEYHJ7i3ixzK3sjbqSGDJWnxyFXZblF3eUsNvo=\ngoogle.golang.org/genproto v0.0.0-20200618031413-b414f8b61790/go.mod h1:jDfRM7FcilCzHH/e9qn6dsT145K34l5v+OpcnNgKAAA=\ngoogle.golang.org/genproto v0.0.0-20200729003335-053ba62fc06f/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20200804131852-c06518451d9c/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20200825200019-8632dd797987/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20200904004341-0bd0a958aa1d/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20201019141844-1ed22bb0c154/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20201102152239-715cce707fb0/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20201109203340-2640f1f9cdfb/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20201201144952-b05cb90ed32e/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20201210142538-e3217bee35cc/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20201214200347-8c77b98c765d/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20210222152913-aa3ee6e6a81c/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20210303154014-9728d6b83eeb/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20210310155132-4ce2db91004e/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20210319143718-93e7006c17a6/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20210402141018-6c239bbf2bb1/go.mod h1:9lPAdzaEmUacj36I+k7YKbEc5CXzPIeORRgDAUOu28A=\ngoogle.golang.org/genproto v0.0.0-20210429181445-86c259c2b4ab/go.mod h1:P3QM42oQyzQSnHPnZ/vqoCdDmzH28fzWByN9asMeM8A=\ngoogle.golang.org/genproto v0.0.0-20210602131652-f16073e35f0c/go.mod h1:UODoCrxHCcBojKKwX1terBiRUaqAsFqJiF615XL43r0=\ngoogle.golang.org/genproto v0.0.0-20210831024726-fe130286e0e2 h1:NHN4wOCScVzKhPenJ2dt+BTs3X/XkBVI/Rh4iDt55T8=\ngoogle.golang.org/genproto v0.0.0-20210831024726-fe130286e0e2/go.mod h1:eFjDcFEctNawg4eG61bRv87N7iHBWyVhJu7u1kqDUXY=\ngoogle.golang.org/grpc v1.15.0 h1:Az/KuahOM4NAidTEuJCv/RonAA7rYsTPkqXVjr+8OOw=\ngoogle.golang.org/grpc v1.15.0/go.mod h1:0JHn/cJsOMiMfNA9+DeHDlAU7KAAB5GDlYFpa9MZMio=\ngoogle.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=\ngoogle.golang.org/protobuf v1.22.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.23.1-0.20200526195155-81db48ad09cc/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.24.0/go.mod h1:r/3tXBNzIEhYS9I1OUVjXDlt8tc493IdKGjtUeSXeh4=\ngoogle.golang.org/protobuf v1.25.0/go.mod h1:9JNX74DMeImyA3h4bdi1ymwjUzf21/xIlbajtzgsN7c=\ngoogle.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=\ngoogle.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=\ngoogle.golang.org/protobuf v1.27.1 h1:SnqbnDw1V7RiZcXPx5MEeqPv2s79L9i7BJUlG/+RurQ=\ngoogle.golang.org/protobuf v1.27.1/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=\ngopkg.in/alecthomas/kingpin.v2 v2.2.6/go.mod h1:FMv+mEhP44yOT+4EoQTLFTRgOQ1FBLkstjWtayDeSgw=\ngopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc h1:2gGKlE2+asNV9m7xrywl36YYNnBG5ZQ0r/BOOxqPpmk=\ngopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc/go.mod h1:m7x9LTH6d71AHyAX77c9yqWCCa3UKHcVEj9y7hAtKDk=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=\ngopkg.in/cheggaaa/pb.v1 v1.0.25/go.mod h1:V/YB90LKu/1FcN3WVnfiiE5oMCibMjukxqG/qStrOgw=\ngopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=\ngopkg.in/fsnotify.v1 v1.4.7/go.mod h1:Tz8NjZHkW78fSQdbUxIjBTcgA1z1m8ZHf0WmKUhAMys=\ngopkg.in/gcfg.v1 v1.2.0/go.mod h1:yesOnuUOFQAhST5vPY4nbZsb/huCgGGXlipJsBn0b3o=\ngopkg.in/gcfg.v1 v1.2.3/go.mod h1:yesOnuUOFQAhST5vPY4nbZsb/huCgGGXlipJsBn0b3o=\ngopkg.in/go-playground/assert.v1 v1.2.1/go.mod h1:9RXL0bg/zibRAgZUYszZSwO/z8Y/a8bDuhia5mkpMnE=\ngopkg.in/go-playground/validator.v9 v9.29.1/go.mod h1:+c9/zcJMFNgbLvly1L1V+PpxWdVbfP1avr/N00E2vyQ=\ngopkg.in/go-playground/webhooks.v5 v5.11.0 h1:V3vej+ZXrVvO2EmBTKlhClEbpTqXH44K5OyLUMOkHMg=\ngopkg.in/go-playground/webhooks.v5 v5.11.0/go.mod h1:LZbya/qLVdbqDR1aKrGuWV6qbia2zCYSR5dpom2SInQ=\ngopkg.in/gomail.v2 v2.0.0-20160411212932-81ebce5c23df h1:n7WqCuqOuCbNr617RXOY0AWRXxgwEyPp2z+p0+hgMuE=\ngopkg.in/gomail.v2 v2.0.0-20160411212932-81ebce5c23df/go.mod h1:LRQQ+SO6ZHR7tOkpBDuZnXENFzX8qRjMDMyPD6BRkCw=\ngopkg.in/inf.v0 v0.9.1 h1:73M5CoZyi3ZLMOyDlQh031Cx6N9NDJ2Vvfl76EDAgDc=\ngopkg.in/inf.v0 v0.9.1/go.mod h1:cWUDdTG/fYaXco+Dcufb5Vnc6Gp2YChqWtbxRZE0mXw=\ngopkg.in/ini.v1 v1.51.0/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=\ngopkg.in/ini.v1 v1.57.0/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=\ngopkg.in/ini.v1 v1.62.0/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=\ngopkg.in/mgo.v2 v2.0.0-20180705113604-9856a29383ce/go.mod h1:yeKp02qBN3iKW1OzL3MGk2IdtZzaj7SFntXj72NppTA=\ngopkg.in/natefinch/lumberjack.v2 v2.0.0/go.mod h1:l0ndWWf7gzL7RNwBG7wST/UCcT4T24xpD6X8LsfU/+k=\ngopkg.in/square/go-jose.v2 v2.2.2 h1:orlkJ3myw8CN1nVQHBFfloD+L3egixIa4FvUP6RosSA=\ngopkg.in/square/go-jose.v2 v2.2.2/go.mod h1:M9dMgbHiYLoDGQrXy7OpJDJWiKiU//h+vD76mk0e1AI=\ngopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7 h1:uRGJdciOHaEIrze2W8Q3AKkepLTh2hOroT7a+7czfdQ=\ngopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7/go.mod h1:dt/ZhP58zS4L8KSrWDmTeBkI65Dw0HsyUHuEVlX15mw=\ngopkg.in/warnings.v0 v0.1.1/go.mod h1:jksf8JmL6Qr/oQM2OXTHunEvvTAsrWBLb6OOjuVWRNI=\ngopkg.in/warnings.v0 v0.1.2 h1:wFXVbFY8DY5/xOe1ECiWdKCzZlxgshcYVNkBHstARME=\ngopkg.in/warnings.v0 v0.1.2/go.mod h1:jksf8JmL6Qr/oQM2OXTHunEvvTAsrWBLb6OOjuVWRNI=\ngopkg.in/yaml.v2 v2.2.1/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.3/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.4/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.5/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.7/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.8/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.3.0/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.0-20200615113413-eeeca48fe776/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b h1:h8qDotaEPuJATrMmW04NCwg7v22aHH28wwpauUhK9Oo=\ngopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngotest.tools/v3 v3.0.2/go.mod h1:3SzNCllyD9/Y+b5r9JIKQ474KzkZyqLqEfYqMsX94Bk=\ngotest.tools/v3 v3.0.3 h1:4AuOwCGf4lLR9u3YOe2awrHygurzhO/HeQ6laiA6Sx0=\ngotest.tools/v3 v3.0.3/go.mod h1:Z7Lb0S5l+klDB31fvDQX8ss/FlKDxtlFlw3Oa8Ymbl8=\nhonnef.co/go/tools v0.0.0-20180728063816-88497007e858/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190106161140-3f1c8253044a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190418001031-e561f6794a2a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.1-2019.2.3/go.mod h1:a3bituU0lyd329TUQxRnasdCoJDkEUEAqEt0JzvZhAg=\nhonnef.co/go/tools v0.0.1-2020.1.3/go.mod h1:X/FiERA/W4tHapMX5mGpAtMSVEeEUOyHaw9vFzvIQ3k=\nhonnef.co/go/tools v0.0.1-2020.1.4/go.mod h1:X/FiERA/W4tHapMX5mGpAtMSVEeEUOyHaw9vFzvIQ3k=\nhonnef.co/go/tools v0.1.3/go.mod h1:NgwopIslSNH47DimFoV78dnkksY2EFtX0ajyb3K/las=\nk8s.io/api v0.23.1 h1:ncu/qfBfUoClqwkTGbeRqqOqBCRoUAflMuOaOD7J0c8=\nk8s.io/api v0.23.1/go.mod h1:WfXnOnwSqNtG62Y1CdjoMxh7r7u9QXGCkA1u0na2jgo=\nk8s.io/apiextensions-apiserver v0.23.1 h1:xxE0q1vLOVZiWORu1KwNRQFsGWtImueOrqSl13sS5EU=\nk8s.io/apiextensions-apiserver v0.23.1/go.mod h1:0qz4fPaHHsVhRApbtk3MGXNn2Q9M/cVWWhfHdY2SxiM=\nk8s.io/apimachinery v0.23.1 h1:sfBjlDFwj2onG0Ijx5C+SrAoeUscPrmghm7wHP+uXlo=\nk8s.io/apimachinery v0.23.1/go.mod h1:SADt2Kl8/sttJ62RRsi9MIV4o8f5S3coArm0Iu3fBno=\nk8s.io/apiserver v0.23.1 h1:vWGf8LcV9Pk/z5rdLmCiBDqE21ccbe930dzrtVMhw9g=\nk8s.io/apiserver v0.23.1/go.mod h1:Bqt0gWbeM2NefS8CjWswwd2VNAKN6lUKR85Ft4gippY=\nk8s.io/cli-runtime v0.23.1 h1:vHUZrq1Oejs0WaJnxs09mLHKScvIIl2hMSthhS8o8Yo=\nk8s.io/cli-runtime v0.23.1/go.mod h1:r9r8H/qfXo9w+69vwUL7LokKlLRKW5D6A8vUKCx+YL0=\nk8s.io/client-go v0.23.1 h1:Ma4Fhf/p07Nmj9yAB1H7UwbFHEBrSPg8lviR24U2GiQ=\nk8s.io/client-go v0.23.1/go.mod h1:6QSI8fEuqD4zgFK0xbdwfB/PthBsIxCJMa3s17WlcO0=\nk8s.io/cloud-provider v0.23.1/go.mod h1:kI8AnYwOSru5Bci8pPUWwV5kJMVkY1ICOp1p8KKZWpc=\nk8s.io/cluster-bootstrap v0.23.1/go.mod h1:p2732QxwSa13WPemmyIeykk16qVw15W7lgNRB6x7NpY=\nk8s.io/code-generator v0.23.1 h1:ViFOlP/0bYD7VrnUDS+ch5ej5EIuMawFmHcRuv9Yxyw=\nk8s.io/code-generator v0.23.1/go.mod h1:V7yn6VNTCWW8GqodYCESVo95fuiEg713S8B7WacWZDA=\nk8s.io/component-base v0.23.1 h1:j/BqdZUWeWKCy2v/jcgnOJAzpRYWSbGcjGVYICko8Uc=\nk8s.io/component-base v0.23.1/go.mod h1:6llmap8QtJIXGDd4uIWJhAq0Op8AtQo6bDW2RrNMTeo=\nk8s.io/component-helpers v0.23.1 h1:Xrtj0LwXUqYyTPvN2bOE2UcqURX+uSBmKX1koNGhVxI=\nk8s.io/component-helpers v0.23.1/go.mod h1:ZK24U+2oXnBPcas2KolLigVVN9g5zOzaHLkHiQMFGr0=\nk8s.io/controller-manager v0.23.1/go.mod h1:AFE4qIllvTh+nRwGr3SRSUt7F+xVSzXCeb0hhzYlU4k=\nk8s.io/cri-api v0.23.1/go.mod h1:REJE3PSU0h/LOV1APBrupxrEJqnoxZC8KWzkBUHwrK4=\nk8s.io/csi-translation-lib v0.23.1/go.mod h1:0ZyB0cZBV4ZkqibwilEhKnxOne28rq5FDSjO+0MUVio=\nk8s.io/gengo v0.0.0-20200413195148-3a45101e95ac/go.mod h1:ezvh/TsK7cY6rbqRK0oQQ8IAqLxYwwyPxAX1Pzy0ii0=\nk8s.io/gengo v0.0.0-20210813121822-485abfe95c7c/go.mod h1:FiNAH4ZV3gBg2Kwh89tzAEV2be7d5xI0vBa/VySYy3E=\nk8s.io/gengo v0.0.0-20211129171323-c02415ce4185 h1:TT1WdmqqXareKxZ/oNXEUSwKlLiHzPMyB0t8BaFeBYI=\nk8s.io/gengo v0.0.0-20211129171323-c02415ce4185/go.mod h1:FiNAH4ZV3gBg2Kwh89tzAEV2be7d5xI0vBa/VySYy3E=\nk8s.io/klog/v2 v2.0.0/go.mod h1:PBfzABfn139FHAV07az/IF9Wp1bkk3vpT2XSJ76fSDE=\nk8s.io/klog/v2 v2.2.0/go.mod h1:Od+F08eJP+W3HUb4pSrPpgp9DGU4GzlpG/TmITuYh/Y=\nk8s.io/klog/v2 v2.4.0/go.mod h1:Od+F08eJP+W3HUb4pSrPpgp9DGU4GzlpG/TmITuYh/Y=\nk8s.io/klog/v2 v2.5.0/go.mod h1:hy9LJ/NvuK+iVyP4Ehqva4HxZG/oXyIS3n3Jmire4Ec=\nk8s.io/klog/v2 v2.30.0 h1:bUO6drIvCIsvZ/XFgfxoGFQU/a4Qkh0iAlvUR7vlHJw=\nk8s.io/klog/v2 v2.30.0/go.mod h1:y1WjHnz7Dj687irZUWR/WLkLc5N1YHtjLdmgWjndZn0=\nk8s.io/kube-aggregator v0.23.1 h1:w05VLh3ji05gYQglMKKrwafgqjgIxZoBusxdSWS9d/4=\nk8s.io/kube-aggregator v0.23.1/go.mod h1:1SPZXYD/je2gKxxLBkYyG3yFxSCUWI5QTyjqP2ZxRDI=\nk8s.io/kube-controller-manager v0.23.1/go.mod h1:KbZeNSFsBM5j2ddB5yXJ1nTQx2j/1/Cf7cXzG27aKZ0=\nk8s.io/kube-openapi v0.0.0-20210421082810-95288971da7e/go.mod h1:vHXdDvt9+2spS2Rx9ql3I8tycm3H9FDfdUoIuKCefvw=\nk8s.io/kube-openapi v0.0.0-20211115234752-e816edb12b65 h1:E3J9oCLlaobFUqsjG9DfKbP2BmgwBL2p7pn0A3dG9W4=\nk8s.io/kube-openapi v0.0.0-20211115234752-e816edb12b65/go.mod h1:sX9MT8g7NVZM5lVL/j8QyCCJe8YSMW30QvGZWaCIDIk=\nk8s.io/kube-proxy v0.23.1/go.mod h1:65QJpMrjUMHfgX1q5Pl/KqVRZBMM4qLHNMo5MhKsnp0=\nk8s.io/kube-scheduler v0.23.1/go.mod h1:SFPvXnt7KlxTZILrtjH8VNwGDzXcdKKHrv4TkeZdYro=\nk8s.io/kubectl v0.23.1 h1:gmscOiV4Y4XIRIn14gQBBADoyyVrDZPbxRCTDga4RSA=\nk8s.io/kubectl v0.23.1/go.mod h1:Ui7dJKdUludF8yWAOSN7JZEkOuYixX5yF6E6NjoukKE=\nk8s.io/kubelet v0.23.1/go.mod h1:WdvMiehtNPhtiW8sSVVvr8YYU00L0u+0HkfMDEB0LKM=\nk8s.io/kubernetes v1.23.1 h1:iJfubd03CDap4m69Ue+u2I6quNUYiYlC8+TakEHATjc=\nk8s.io/kubernetes v1.23.1/go.mod h1:baMGbPpwwP0kT/+eAPtdqoWNRoXyyTJ2Zf+fw/Y8t04=\nk8s.io/legacy-cloud-providers v0.23.1/go.mod h1:HIt+r/ReEfjS6IGaGfpZ7tCna7hbMBXMOaIp/SWABVE=\nk8s.io/metrics v0.23.1/go.mod h1:qXvsM1KANrc+ZZeFwj6Phvf0NLiC+d3RwcsLcdGc+xs=\nk8s.io/mount-utils v0.23.1/go.mod h1:9pFhzVjxle1osJUo++9MFDat9HPkQUOoHCn+eExZ3Ew=\nk8s.io/pod-security-admission v0.23.1/go.mod h1:WDb/vFWf7jKSGe2e07LTEjDZ0MHMDhUIzXNvQ45HytU=\nk8s.io/sample-apiserver v0.23.1/go.mod h1:5ZQrkouVpN6GeNMZEJFkIpFwaxgDPJin/cIBXyDboC4=\nk8s.io/system-validators v1.6.0/go.mod h1:bPldcLgkIUK22ALflnsXk8pvkTEndYdNuaHH6gRrl0Q=\nk8s.io/utils v0.0.0-20201110183641-67b214c5f920/go.mod h1:jPW/WVKK9YHAvNhRxK0md/EJ228hCsBRufyofKtW8HA=\nk8s.io/utils v0.0.0-20210802155522-efc7438f0176/go.mod h1:jPW/WVKK9YHAvNhRxK0md/EJ228hCsBRufyofKtW8HA=\nk8s.io/utils v0.0.0-20210930125809-cb0fa318a74b h1:wxEMGetGMur3J1xuGLQY7GEQYg9bZxKn3tKo5k/eYcs=\nk8s.io/utils v0.0.0-20210930125809-cb0fa318a74b/go.mod h1:jPW/WVKK9YHAvNhRxK0md/EJ228hCsBRufyofKtW8HA=\nlayeh.com/gopher-json v0.0.0-20190114024228-97fed8db8427 h1:RZkKxMR3jbQxdCEcglq3j7wY3PRJIopAwBlx1RE71X0=\nlayeh.com/gopher-json v0.0.0-20190114024228-97fed8db8427/go.mod h1:ivKkcY8Zxw5ba0jldhZCYYQfGdb2K6u9tbYK1AwMIBc=\nmodernc.org/cc v1.0.0/go.mod h1:1Sk4//wdnYJiUIxnW8ddKpaOJCF37yAdqYnkxUpaYxw=\nmodernc.org/golex v1.0.0/go.mod h1:b/QX9oBD/LhixY6NDh+IdGv17hgB+51fET1i2kPSmvk=\nmodernc.org/mathutil v1.0.0/go.mod h1:wU0vUrJsVWBZ4P6e7xtFJEhFSNsfRLJ8H458uRjg03k=\nmodernc.org/strutil v1.0.0/go.mod h1:lstksw84oURvj9y3tn8lGvRxyRC1S2+g5uuIzNfIOBs=\nmodernc.org/xc v1.0.0/go.mod h1:mRNCo0bvLjGhHO9WsyuKVU4q0ceiDDDoEeWDJHrNx8I=\nrsc.io/binaryregexp v0.2.0/go.mod h1:qTv7/COck+e2FymRvadv62gMdZztPaShugOCi3I+8D8=\nrsc.io/pdf v0.1.1/go.mod h1:n8OzWcQ6Sp37PL01nO98y4iUCRdTGarVfzxY20ICaU4=\nrsc.io/quote/v3 v3.1.0/go.mod h1:yEA65RcK8LyAZtP9Kv3t0HmxON59tX3rD+tICJqUlj0=\nrsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA=\nsigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.0.25/go.mod h1:Mlj9PNLmG9bZ6BHFwFKDo5afkpWyUISkb9Me0GnK66I=\nsigs.k8s.io/controller-runtime v0.11.0 h1:DqO+c8mywcZLFJWILq4iktoECTyn30Bkj0CwgqMpZWQ=\nsigs.k8s.io/controller-runtime v0.11.0/go.mod h1:KKwLiTooNGu+JmLZGn9Sl3Gjmfj66eMbCQznLP5zcqA=\nsigs.k8s.io/json v0.0.0-20211020170558-c049b76a60c6 h1:fD1pz4yfdADVNfFmcP2aBEtudwUQ1AlLnRBALr33v3s=\nsigs.k8s.io/json v0.0.0-20211020170558-c049b76a60c6/go.mod h1:p4QtZmO4uMYipTQNzagwnNoseA6OxSUutVw05NhYDRs=\nsigs.k8s.io/kustomize/api v0.10.1 h1:KgU7hfYoscuqag84kxtzKdEC3mKMb99DPI3a0eaV1d0=\nsigs.k8s.io/kustomize/api v0.10.1/go.mod h1:2FigT1QN6xKdcnGS2Ppp1uIWrtWN28Ms8A3OZUZhwr8=\nsigs.k8s.io/kustomize/cmd/config v0.10.2/go.mod h1:K2aW7nXJ0AaT+VA/eO0/dzFLxmpFcTzudmAgDwPY1HQ=\nsigs.k8s.io/kustomize/kustomize/v4 v4.4.1/go.mod h1:qOKJMMz2mBP+vcS7vK+mNz4HBLjaQSWRY22EF6Tb7Io=\nsigs.k8s.io/kustomize/kyaml v0.13.0 h1:9c+ETyNfSrVhxvphs+K2dzT3dh5oVPPEqPOE/cUpScY=\nsigs.k8s.io/kustomize/kyaml v0.13.0/go.mod h1:FTJxEZ86ScK184NpGSAQcfEqee0nul8oLCK30D47m4E=\nsigs.k8s.io/structured-merge-diff/v4 v4.0.2/go.mod h1:bJZC9H9iH24zzfZ/41RGcq60oK1F7G282QMXDPYydCw=\nsigs.k8s.io/structured-merge-diff/v4 v4.1.2/go.mod h1:j/nl6xW8vLS49O8YvXW1ocPhZawJtm+Yrr7PPRQ0Vg4=\nsigs.k8s.io/structured-merge-diff/v4 v4.2.0 h1:kDvPBbnPk+qYmkHmSo8vKGp438IASWofnbbUKDE/bv0=\nsigs.k8s.io/structured-merge-diff/v4 v4.2.0/go.mod h1:j/nl6xW8vLS49O8YvXW1ocPhZawJtm+Yrr7PPRQ0Vg4=\nsigs.k8s.io/yaml v1.1.0/go.mod h1:UJmg0vDUVViEyp3mgSv9WPwZCDxu4rQW1olrI1uml+o=\nsigs.k8s.io/yaml v1.2.0/go.mod h1:yfXDCHCao9+ENCvLSE62v9VSji2MKu5jeNfTrofGhJc=\nsigs.k8s.io/yaml v1.3.0 h1:a2VclLzOGrwOHDiV8EfBGhvjHvP46CtW5j6POvhYGGo=\nsigs.k8s.io/yaml v1.3.0/go.mod h1:GeOyir5tyXNByN85N/dRIT9es5UQNerPYEKK56eTBm8=\nsourcegraph.com/sourcegraph/appdash v0.0.0-20190731080439-ebfcffb1b5c0/go.mod h1:hI742Nqp5OhwiqlzhgfbWU4mW4yO10fP+LoT9WOswdU=\n", "package v1alpha1\n\nimport (\n\tfmt \"fmt\"\n\t\"sort\"\n\t\"strconv\"\n\tstrings \"strings\"\n\n\t\"github.com/argoproj/argo-cd/v2/util/git\"\n\t\"github.com/argoproj/argo-cd/v2/util/glob\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\n\t\"k8s.io/apimachinery/pkg/runtime/schema\"\n)\n\n// AppProjectList is list of AppProject resources\n// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\ntype AppProjectList struct {\n\tmetav1.TypeMeta `json:\",inline\"`\n\tmetav1.ListMeta `json:\"metadata\" protobuf:\"bytes,1,opt,name=metadata\"`\n\tItems           []AppProject `json:\"items\" protobuf:\"bytes,2,rep,name=items\"`\n}\n\n// AppProject provides a logical grouping of applications, providing controls for:\n// * where the apps may deploy to (cluster whitelist)\n// * what may be deployed (repository whitelist, resource whitelist/blacklist)\n// * who can access these applications (roles, OIDC group claims bindings)\n// * and what they can do (RBAC policies)\n// * automation access to these roles (JWT tokens)\n// +genclient\n// +genclient:noStatus\n// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\n// +kubebuilder:resource:path=appprojects,shortName=appproj;appprojs\ntype AppProject struct {\n\tmetav1.TypeMeta   `json:\",inline\"`\n\tmetav1.ObjectMeta `json:\"metadata\" protobuf:\"bytes,1,opt,name=metadata\"`\n\tSpec              AppProjectSpec   `json:\"spec\" protobuf:\"bytes,2,opt,name=spec\"`\n\tStatus            AppProjectStatus `json:\"status,omitempty\" protobuf:\"bytes,3,opt,name=status\"`\n}\n\n// AppProjectStatus contains status information for AppProject CRs\ntype AppProjectStatus struct {\n\t// JWTTokensByRole contains a list of JWT tokens issued for a given role\n\tJWTTokensByRole map[string]JWTTokens `json:\"jwtTokensByRole,omitempty\" protobuf:\"bytes,1,opt,name=jwtTokensByRole\"`\n}\n\n// GetRoleByName returns the role in a project by the name with its index\nfunc (p *AppProject) GetRoleByName(name string) (*ProjectRole, int, error) {\n\tfor i, role := range p.Spec.Roles {\n\t\tif name == role.Name {\n\t\t\treturn &role, i, nil\n\t\t}\n\t}\n\treturn nil, -1, fmt.Errorf(\"role '%s' does not exist in project '%s'\", name, p.Name)\n}\n\n// GetJWTTokenFromSpec looks up the index of a JWTToken in a project by id (new token), if not then by the issue at time (old token)\nfunc (p *AppProject) GetJWTTokenFromSpec(roleName string, issuedAt int64, id string) (*JWTToken, int, error) {\n\t// This is for backward compatibility. In the oder version, JWTTokens are stored under spec.role\n\trole, _, err := p.GetRoleByName(roleName)\n\tif err != nil {\n\t\treturn nil, -1, err\n\t}\n\n\tif id != \"\" {\n\t\tfor i, token := range role.JWTTokens {\n\t\t\tif id == token.ID {\n\t\t\t\treturn &token, i, nil\n\t\t\t}\n\t\t}\n\t}\n\n\tif issuedAt != -1 {\n\t\tfor i, token := range role.JWTTokens {\n\t\t\tif issuedAt == token.IssuedAt {\n\t\t\t\treturn &token, i, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil, -1, fmt.Errorf(\"JWT token for role '%s' issued at '%d' does not exist in project '%s'\", role.Name, issuedAt, p.Name)\n}\n\n// GetJWTToken looks up the index of a JWTToken in a project by id (new token), if not then by the issue at time (old token)\nfunc (p *AppProject) GetJWTToken(roleName string, issuedAt int64, id string) (*JWTToken, int, error) {\n\t// This is for newer version, JWTTokens are stored under status\n\tif id != \"\" {\n\t\tfor i, token := range p.Status.JWTTokensByRole[roleName].Items {\n\t\t\tif id == token.ID {\n\t\t\t\treturn &token, i, nil\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif issuedAt != -1 {\n\t\tfor i, token := range p.Status.JWTTokensByRole[roleName].Items {\n\t\t\tif issuedAt == token.IssuedAt {\n\t\t\t\treturn &token, i, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil, -1, fmt.Errorf(\"JWT token for role '%s' issued at '%d' does not exist in project '%s'\", roleName, issuedAt, p.Name)\n}\n\n// RemoveJWTToken removes the specified JWT from an AppProject\nfunc (p AppProject) RemoveJWTToken(roleIndex int, issuedAt int64, id string) error {\n\troleName := p.Spec.Roles[roleIndex].Name\n\t// For backward compatibility\n\t_, jwtTokenIndex, err1 := p.GetJWTTokenFromSpec(roleName, issuedAt, id)\n\tif err1 == nil {\n\t\tp.Spec.Roles[roleIndex].JWTTokens[jwtTokenIndex] = p.Spec.Roles[roleIndex].JWTTokens[len(p.Spec.Roles[roleIndex].JWTTokens)-1]\n\t\tp.Spec.Roles[roleIndex].JWTTokens = p.Spec.Roles[roleIndex].JWTTokens[:len(p.Spec.Roles[roleIndex].JWTTokens)-1]\n\t}\n\n\t// New location for storing JWTToken\n\t_, jwtTokenIndex, err2 := p.GetJWTToken(roleName, issuedAt, id)\n\tif err2 == nil {\n\t\tp.Status.JWTTokensByRole[roleName].Items[jwtTokenIndex] = p.Status.JWTTokensByRole[roleName].Items[len(p.Status.JWTTokensByRole[roleName].Items)-1]\n\t\tp.Status.JWTTokensByRole[roleName] = JWTTokens{Items: p.Status.JWTTokensByRole[roleName].Items[:len(p.Status.JWTTokensByRole[roleName].Items)-1]}\n\t}\n\n\tif err1 == nil || err2 == nil {\n\t\t//If we find this token from either places, we can say there are no error\n\t\treturn nil\n\t} else {\n\t\t//If we could not locate this taken from either places, we can return any of the errors\n\t\treturn err2\n\t}\n}\n\n// TODO: document this method\nfunc (p *AppProject) ValidateJWTTokenID(roleName string, id string) error {\n\trole, _, err := p.GetRoleByName(roleName)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif id == \"\" {\n\t\treturn nil\n\t}\n\tfor _, token := range role.JWTTokens {\n\t\tif id == token.ID {\n\t\t\treturn status.Errorf(codes.InvalidArgument, \"Token id '%s' has been used. \", id)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (p *AppProject) ValidateProject() error {\n\tdestKeys := make(map[string]bool)\n\tfor _, dest := range p.Spec.Destinations {\n\t\tkey := fmt.Sprintf(\"%s/%s\", dest.Server, dest.Namespace)\n\t\tif _, ok := destKeys[key]; ok {\n\t\t\treturn status.Errorf(codes.InvalidArgument, \"destination '%s' already added\", key)\n\t\t}\n\t\tdestKeys[key] = true\n\t}\n\tsrcRepos := make(map[string]bool)\n\tfor _, src := range p.Spec.SourceRepos {\n\t\tif _, ok := srcRepos[src]; ok {\n\t\t\treturn status.Errorf(codes.InvalidArgument, \"source repository '%s' already added\", src)\n\t\t}\n\t\tsrcRepos[src] = true\n\t}\n\n\troleNames := make(map[string]bool)\n\tfor _, role := range p.Spec.Roles {\n\t\tif _, ok := roleNames[role.Name]; ok {\n\t\t\treturn status.Errorf(codes.AlreadyExists, \"role '%s' already exists\", role.Name)\n\t\t}\n\t\tif err := validateRoleName(role.Name); err != nil {\n\t\t\treturn err\n\t\t}\n\t\texistingPolicies := make(map[string]bool)\n\t\tfor _, policy := range role.Policies {\n\t\t\tif _, ok := existingPolicies[policy]; ok {\n\t\t\t\treturn status.Errorf(codes.AlreadyExists, \"policy '%s' already exists for role '%s'\", policy, role.Name)\n\t\t\t}\n\t\t\tif err := validatePolicy(p.Name, role.Name, policy); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\texistingPolicies[policy] = true\n\t\t}\n\t\texistingGroups := make(map[string]bool)\n\t\tfor _, group := range role.Groups {\n\t\t\tif _, ok := existingGroups[group]; ok {\n\t\t\t\treturn status.Errorf(codes.AlreadyExists, \"group '%s' already exists for role '%s'\", group, role.Name)\n\t\t\t}\n\t\t\tif err := validateGroupName(group); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\texistingGroups[group] = true\n\t\t}\n\t\troleNames[role.Name] = true\n\t}\n\n\tif p.Spec.SyncWindows.HasWindows() {\n\t\texistingWindows := make(map[string]bool)\n\t\tfor _, window := range p.Spec.SyncWindows {\n\t\t\tif _, ok := existingWindows[window.Kind+window.Schedule+window.Duration]; ok {\n\t\t\t\treturn status.Errorf(codes.AlreadyExists, \"window '%s':'%s':'%s' already exists, update or edit\", window.Kind, window.Schedule, window.Duration)\n\t\t\t}\n\t\t\terr := window.Validate()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif len(window.Applications) == 0 && len(window.Namespaces) == 0 && len(window.Clusters) == 0 {\n\t\t\t\treturn status.Errorf(codes.OutOfRange, \"window '%s':'%s':'%s' requires one of application, cluster or namespace\", window.Kind, window.Schedule, window.Duration)\n\t\t\t}\n\t\t\texistingWindows[window.Kind+window.Schedule+window.Duration] = true\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// AddGroupToRole adds an OIDC group to a role\nfunc (p *AppProject) AddGroupToRole(roleName, group string) (bool, error) {\n\trole, roleIndex, err := p.GetRoleByName(roleName)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tfor _, roleGroup := range role.Groups {\n\t\tif group == roleGroup {\n\t\t\treturn false, nil\n\t\t}\n\t}\n\trole.Groups = append(role.Groups, group)\n\tp.Spec.Roles[roleIndex] = *role\n\treturn true, nil\n}\n\n// RemoveGroupFromRole removes an OIDC group from a role\nfunc (p *AppProject) RemoveGroupFromRole(roleName, group string) (bool, error) {\n\trole, roleIndex, err := p.GetRoleByName(roleName)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tfor i, roleGroup := range role.Groups {\n\t\tif group == roleGroup {\n\t\t\trole.Groups = append(role.Groups[:i], role.Groups[i+1:]...)\n\t\t\tp.Spec.Roles[roleIndex] = *role\n\t\t\treturn true, nil\n\t\t}\n\t}\n\treturn false, nil\n}\n\n// NormalizePolicies normalizes the policies in the project\nfunc (p *AppProject) NormalizePolicies() {\n\tfor i, role := range p.Spec.Roles {\n\t\tvar normalizedPolicies []string\n\t\tfor _, policy := range role.Policies {\n\t\t\tnormalizedPolicies = append(normalizedPolicies, p.normalizePolicy(policy))\n\t\t}\n\t\tp.Spec.Roles[i].Policies = normalizedPolicies\n\t}\n}\n\nfunc (p *AppProject) normalizePolicy(policy string) string {\n\tpolicyComponents := strings.Split(policy, \",\")\n\tnormalizedPolicy := \"\"\n\tfor _, component := range policyComponents {\n\t\tif normalizedPolicy == \"\" {\n\t\t\tnormalizedPolicy = component\n\t\t} else {\n\t\t\tnormalizedPolicy = fmt.Sprintf(\"%s, %s\", normalizedPolicy, strings.Trim(component, \" \"))\n\t\t}\n\t}\n\treturn normalizedPolicy\n}\n\n// ProjectPoliciesString returns a Casbin formatted string of a project's policies for each role\nfunc (proj *AppProject) ProjectPoliciesString() string {\n\tvar policies []string\n\tfor _, role := range proj.Spec.Roles {\n\t\tprojectPolicy := fmt.Sprintf(\"p, proj:%s:%s, projects, get, %s, allow\", proj.ObjectMeta.Name, role.Name, proj.ObjectMeta.Name)\n\t\tpolicies = append(policies, projectPolicy)\n\t\tpolicies = append(policies, role.Policies...)\n\t\tfor _, groupName := range role.Groups {\n\t\t\tpolicies = append(policies, fmt.Sprintf(\"g, %s, proj:%s:%s\", groupName, proj.ObjectMeta.Name, role.Name))\n\t\t}\n\t}\n\treturn strings.Join(policies, \"\\n\")\n}\n\n// IsGroupKindPermitted validates if the given resource group/kind is permitted to be deployed in the project\nfunc (proj AppProject) IsGroupKindPermitted(gk schema.GroupKind, namespaced bool) bool {\n\tvar isWhiteListed, isBlackListed bool\n\tres := metav1.GroupKind{Group: gk.Group, Kind: gk.Kind}\n\n\tif namespaced {\n\t\tnamespaceWhitelist := proj.Spec.NamespaceResourceWhitelist\n\t\tnamespaceBlacklist := proj.Spec.NamespaceResourceBlacklist\n\n\t\tisWhiteListed = namespaceWhitelist == nil || len(namespaceWhitelist) != 0 && isResourceInList(res, namespaceWhitelist)\n\t\tisBlackListed = len(namespaceBlacklist) != 0 && isResourceInList(res, namespaceBlacklist)\n\t\treturn isWhiteListed && !isBlackListed\n\t}\n\n\tclusterWhitelist := proj.Spec.ClusterResourceWhitelist\n\tclusterBlacklist := proj.Spec.ClusterResourceBlacklist\n\n\tisWhiteListed = len(clusterWhitelist) != 0 && isResourceInList(res, clusterWhitelist)\n\tisBlackListed = len(clusterBlacklist) != 0 && isResourceInList(res, clusterBlacklist)\n\treturn isWhiteListed && !isBlackListed\n}\n\n// IsLiveResourcePermitted returns whether a live resource found in the cluster is permitted by an AppProject\nfunc (proj AppProject) IsLiveResourcePermitted(un *unstructured.Unstructured, server string, name string) bool {\n\tif !proj.IsGroupKindPermitted(un.GroupVersionKind().GroupKind(), un.GetNamespace() != \"\") {\n\t\treturn false\n\t}\n\tif un.GetNamespace() != \"\" {\n\t\treturn proj.IsDestinationPermitted(ApplicationDestination{Server: server, Namespace: un.GetNamespace(), Name: name})\n\t}\n\treturn true\n}\n\n// HasFinalizer returns true if a resource finalizer is set on an AppProject\nfunc (proj AppProject) HasFinalizer() bool {\n\treturn getFinalizerIndex(proj.ObjectMeta, ResourcesFinalizerName) > -1\n}\n\n// RemoveFinalizer removes a resource finalizer from an AppProject\nfunc (proj *AppProject) RemoveFinalizer() {\n\tsetFinalizer(&proj.ObjectMeta, ResourcesFinalizerName, false)\n}\n\nfunc globMatch(pattern string, val string, separators ...rune) bool {\n\tif pattern == \"*\" {\n\t\treturn true\n\t}\n\treturn glob.Match(pattern, val, separators...)\n}\n\n// IsSourcePermitted validates if the provided application's source is a one of the allowed sources for the project.\nfunc (proj AppProject) IsSourcePermitted(src ApplicationSource) bool {\n\tsrcNormalized := git.NormalizeGitURL(src.RepoURL)\n\tfor _, repoURL := range proj.Spec.SourceRepos {\n\t\tnormalized := git.NormalizeGitURL(repoURL)\n\t\tif globMatch(normalized, srcNormalized, '/') {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// IsDestinationPermitted validates if the provided application's destination is one of the allowed destinations for the project\nfunc (proj AppProject) IsDestinationPermitted(dst ApplicationDestination) bool {\n\tfor _, item := range proj.Spec.Destinations {\n\t\tdstNameMatched := dst.Name != \"\" && globMatch(item.Name, dst.Name)\n\t\tdstServerMatched := dst.Server != \"\" && globMatch(item.Server, dst.Server)\n\t\tif (dstServerMatched || dstNameMatched) && globMatch(item.Namespace, dst.Namespace) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// TODO: document this method\nfunc (proj *AppProject) NormalizeJWTTokens() bool {\n\tneedNormalize := false\n\tfor i, role := range proj.Spec.Roles {\n\t\tfor j, token := range role.JWTTokens {\n\t\t\tif token.ID == \"\" {\n\t\t\t\ttoken.ID = strconv.FormatInt(token.IssuedAt, 10)\n\t\t\t\trole.JWTTokens[j] = token\n\t\t\t\tneedNormalize = true\n\t\t\t}\n\t\t}\n\t\tproj.Spec.Roles[i] = role\n\t}\n\tfor _, roleTokenEntry := range proj.Status.JWTTokensByRole {\n\t\tfor j, token := range roleTokenEntry.Items {\n\t\t\tif token.ID == \"\" {\n\t\t\t\ttoken.ID = strconv.FormatInt(token.IssuedAt, 10)\n\t\t\t\troleTokenEntry.Items[j] = token\n\t\t\t\tneedNormalize = true\n\t\t\t}\n\t\t}\n\t}\n\tneedSync := syncJWTTokenBetweenStatusAndSpec(proj)\n\treturn needNormalize || needSync\n}\n\nfunc syncJWTTokenBetweenStatusAndSpec(proj *AppProject) bool {\n\texistingRole := map[string]bool{}\n\tneedSync := false\n\tfor roleIndex, role := range proj.Spec.Roles {\n\t\texistingRole[role.Name] = true\n\n\t\ttokensInSpec := role.JWTTokens\n\t\ttokensInStatus := []JWTToken{}\n\t\tif proj.Status.JWTTokensByRole == nil {\n\t\t\ttokensByRole := make(map[string]JWTTokens)\n\t\t\tproj.Status.JWTTokensByRole = tokensByRole\n\t\t} else {\n\t\t\ttokensInStatus = proj.Status.JWTTokensByRole[role.Name].Items\n\t\t}\n\t\ttokens := jwtTokensCombine(tokensInStatus, tokensInSpec)\n\n\t\tsort.Slice(proj.Spec.Roles[roleIndex].JWTTokens, func(i, j int) bool {\n\t\t\treturn proj.Spec.Roles[roleIndex].JWTTokens[i].IssuedAt > proj.Spec.Roles[roleIndex].JWTTokens[j].IssuedAt\n\t\t})\n\t\tsort.Slice(proj.Status.JWTTokensByRole[role.Name].Items, func(i, j int) bool {\n\t\t\treturn proj.Status.JWTTokensByRole[role.Name].Items[i].IssuedAt > proj.Status.JWTTokensByRole[role.Name].Items[j].IssuedAt\n\t\t})\n\t\tif !cmp.Equal(tokens, proj.Spec.Roles[roleIndex].JWTTokens) || !cmp.Equal(tokens, proj.Status.JWTTokensByRole[role.Name].Items) {\n\t\t\tneedSync = true\n\t\t}\n\n\t\tproj.Spec.Roles[roleIndex].JWTTokens = tokens\n\t\tproj.Status.JWTTokensByRole[role.Name] = JWTTokens{Items: tokens}\n\t}\n\tif proj.Status.JWTTokensByRole != nil {\n\t\tfor role := range proj.Status.JWTTokensByRole {\n\t\t\tif !existingRole[role] {\n\t\t\t\tdelete(proj.Status.JWTTokensByRole, role)\n\t\t\t\tneedSync = true\n\t\t\t}\n\t\t}\n\t}\n\n\treturn needSync\n}\n\nfunc jwtTokensCombine(tokens1 []JWTToken, tokens2 []JWTToken) []JWTToken {\n\ttokensMap := make(map[string]JWTToken)\n\tfor _, token := range append(tokens1, tokens2...) {\n\t\ttokensMap[token.ID] = token\n\t}\n\n\tvar tokens []JWTToken\n\tfor _, v := range tokensMap {\n\t\ttokens = append(tokens, v)\n\t}\n\n\tsort.Slice(tokens, func(i, j int) bool {\n\t\treturn tokens[i].IssuedAt > tokens[j].IssuedAt\n\t})\n\treturn tokens\n}\n", "package application\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\tkubecache \"github.com/argoproj/gitops-engine/pkg/cache\"\n\t\"github.com/argoproj/gitops-engine/pkg/diff\"\n\t\"github.com/argoproj/gitops-engine/pkg/sync/common\"\n\t\"github.com/argoproj/gitops-engine/pkg/utils/kube\"\n\t\"github.com/argoproj/gitops-engine/pkg/utils/text\"\n\t\"github.com/argoproj/pkg/sync\"\n\tjsonpatch \"github.com/evanphx/json-patch\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\tv1 \"k8s.io/api/core/v1\"\n\tapierr \"k8s.io/apimachinery/pkg/api/errors\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\n\t\"k8s.io/apimachinery/pkg/fields\"\n\t\"k8s.io/apimachinery/pkg/labels\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\t\"k8s.io/apimachinery/pkg/watch\"\n\t\"k8s.io/client-go/kubernetes\"\n\t\"k8s.io/client-go/rest\"\n\t\"k8s.io/client-go/tools/cache\"\n\t\"k8s.io/utils/pointer\"\n\n\targocommon \"github.com/argoproj/argo-cd/v2/common\"\n\t\"github.com/argoproj/argo-cd/v2/pkg/apiclient/application\"\n\t\"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1\"\n\tappv1 \"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1\"\n\tappclientset \"github.com/argoproj/argo-cd/v2/pkg/client/clientset/versioned\"\n\tapplisters \"github.com/argoproj/argo-cd/v2/pkg/client/listers/application/v1alpha1\"\n\t\"github.com/argoproj/argo-cd/v2/reposerver/apiclient\"\n\tservercache \"github.com/argoproj/argo-cd/v2/server/cache\"\n\t\"github.com/argoproj/argo-cd/v2/server/rbacpolicy\"\n\t\"github.com/argoproj/argo-cd/v2/util/argo\"\n\targoutil \"github.com/argoproj/argo-cd/v2/util/argo\"\n\t\"github.com/argoproj/argo-cd/v2/util/db\"\n\t\"github.com/argoproj/argo-cd/v2/util/env\"\n\t\"github.com/argoproj/argo-cd/v2/util/git\"\n\t\"github.com/argoproj/argo-cd/v2/util/io\"\n\tioutil \"github.com/argoproj/argo-cd/v2/util/io\"\n\t\"github.com/argoproj/argo-cd/v2/util/lua\"\n\t\"github.com/argoproj/argo-cd/v2/util/rbac\"\n\t\"github.com/argoproj/argo-cd/v2/util/session\"\n\t\"github.com/argoproj/argo-cd/v2/util/settings\"\n)\n\nconst (\n\tmaxPodLogsToRender                 = 10\n\tbackgroundPropagationPolicy string = \"background\"\n\tforegroundPropagationPolicy string = \"foreground\"\n)\n\nvar (\n\twatchAPIBufferSize = env.ParseNumFromEnv(argocommon.EnvWatchAPIBufferSize, 1000, 0, math.MaxInt32)\n)\n\n// Server provides a Application service\ntype Server struct {\n\tns             string\n\tkubeclientset  kubernetes.Interface\n\tappclientset   appclientset.Interface\n\tappLister      applisters.ApplicationNamespaceLister\n\tappInformer    cache.SharedIndexInformer\n\tappBroadcaster *broadcasterHandler\n\trepoClientset  apiclient.Clientset\n\tkubectl        kube.Kubectl\n\tdb             db.ArgoDB\n\tenf            *rbac.Enforcer\n\tprojectLock    sync.KeyLock\n\tauditLogger    *argo.AuditLogger\n\tsettingsMgr    *settings.SettingsManager\n\tcache          *servercache.Cache\n\tprojInformer   cache.SharedIndexInformer\n}\n\n// NewServer returns a new instance of the Application service\nfunc NewServer(\n\tnamespace string,\n\tkubeclientset kubernetes.Interface,\n\tappclientset appclientset.Interface,\n\tappLister applisters.ApplicationNamespaceLister,\n\tappInformer cache.SharedIndexInformer,\n\trepoClientset apiclient.Clientset,\n\tcache *servercache.Cache,\n\tkubectl kube.Kubectl,\n\tdb db.ArgoDB,\n\tenf *rbac.Enforcer,\n\tprojectLock sync.KeyLock,\n\tsettingsMgr *settings.SettingsManager,\n\tprojInformer cache.SharedIndexInformer,\n) application.ApplicationServiceServer {\n\tappBroadcaster := &broadcasterHandler{}\n\tappInformer.AddEventHandler(appBroadcaster)\n\treturn &Server{\n\t\tns:             namespace,\n\t\tappclientset:   appclientset,\n\t\tappLister:      appLister,\n\t\tappInformer:    appInformer,\n\t\tappBroadcaster: appBroadcaster,\n\t\tkubeclientset:  kubeclientset,\n\t\tcache:          cache,\n\t\tdb:             db,\n\t\trepoClientset:  repoClientset,\n\t\tkubectl:        kubectl,\n\t\tenf:            enf,\n\t\tprojectLock:    projectLock,\n\t\tauditLogger:    argo.NewAuditLogger(namespace, kubeclientset, \"argocd-server\"),\n\t\tsettingsMgr:    settingsMgr,\n\t\tprojInformer:   projInformer,\n\t}\n}\n\n// appRBACName formats fully qualified application name for RBAC check\nfunc appRBACName(app appv1.Application) string {\n\treturn fmt.Sprintf(\"%s/%s\", app.Spec.GetProject(), app.Name)\n}\n\n// List returns list of applications\nfunc (s *Server) List(ctx context.Context, q *application.ApplicationQuery) (*appv1.ApplicationList, error) {\n\tlabelsMap, err := labels.ConvertSelectorToLabelsMap(q.Selector)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tapps, err := s.appLister.List(labelsMap.AsSelector())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tnewItems := make([]appv1.Application, 0)\n\tfor _, a := range apps {\n\t\tif s.enf.Enforce(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionGet, appRBACName(*a)) {\n\t\t\tnewItems = append(newItems, *a)\n\t\t}\n\t}\n\tif q.Name != nil {\n\t\tnewItems, err = argoutil.FilterByName(newItems, *q.Name)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Filter applications by name\n\tnewItems = argoutil.FilterByProjects(newItems, q.Projects)\n\n\t// Filter applications by source repo URL\n\tnewItems = argoutil.FilterByRepo(newItems, q.Repo)\n\n\t// Sort found applications by name\n\tsort.Slice(newItems, func(i, j int) bool {\n\t\treturn newItems[i].Name < newItems[j].Name\n\t})\n\n\tappList := appv1.ApplicationList{\n\t\tListMeta: metav1.ListMeta{\n\t\t\tResourceVersion: s.appInformer.LastSyncResourceVersion(),\n\t\t},\n\t\tItems: newItems,\n\t}\n\treturn &appList, nil\n}\n\n// Create creates an application\nfunc (s *Server) Create(ctx context.Context, q *application.ApplicationCreateRequest) (*appv1.Application, error) {\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionCreate, appRBACName(q.Application)); err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.projectLock.RLock(q.Application.Spec.Project)\n\tdefer s.projectLock.RUnlock(q.Application.Spec.Project)\n\n\ta := q.Application\n\tvalidate := true\n\tif q.Validate != nil {\n\t\tvalidate = *q.Validate\n\t}\n\terr := s.validateAndNormalizeApp(ctx, &a, validate)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcreated, err := s.appclientset.ArgoprojV1alpha1().Applications(s.ns).Create(ctx, &a, metav1.CreateOptions{})\n\tif err == nil {\n\t\ts.logAppEvent(created, ctx, argo.EventReasonResourceCreated, \"created application\")\n\t\ts.waitSync(created)\n\t\treturn created, nil\n\t}\n\tif !apierr.IsAlreadyExists(err) {\n\t\treturn nil, err\n\t}\n\t// act idempotent if existing spec matches new spec\n\texisting, err := s.appLister.Get(a.Name)\n\tif err != nil {\n\t\treturn nil, status.Errorf(codes.Internal, \"unable to check existing application details: %v\", err)\n\t}\n\tequalSpecs := reflect.DeepEqual(existing.Spec, a.Spec) &&\n\t\treflect.DeepEqual(existing.Labels, a.Labels) &&\n\t\treflect.DeepEqual(existing.Annotations, a.Annotations) &&\n\t\treflect.DeepEqual(existing.Finalizers, a.Finalizers)\n\n\tif equalSpecs {\n\t\treturn existing, nil\n\t}\n\tif q.Upsert == nil || !*q.Upsert {\n\t\treturn nil, status.Errorf(codes.InvalidArgument, \"existing application spec is different, use upsert flag to force update\")\n\t}\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionUpdate, appRBACName(a)); err != nil {\n\t\treturn nil, err\n\t}\n\tupdated, err := s.updateApp(existing, &a, ctx, true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn updated, nil\n}\n\nfunc (s *Server) queryRepoServer(ctx context.Context, a *v1alpha1.Application, action func(\n\tclient apiclient.RepoServerServiceClient,\n\trepo *appv1.Repository,\n\thelmRepos []*appv1.Repository,\n\thelmCreds []*v1alpha1.RepoCreds,\n\thelmOptions *v1alpha1.HelmOptions,\n\tkustomizeOptions *v1alpha1.KustomizeOptions,\n\tenabledSourceTypes map[string]bool,\n) error) error {\n\n\tcloser, client, err := s.repoClientset.NewRepoServerClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ioutil.Close(closer)\n\trepo, err := s.db.GetRepository(ctx, a.Spec.Source.RepoURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\tkustomizeSettings, err := s.settingsMgr.GetKustomizeSettings()\n\tif err != nil {\n\t\treturn err\n\t}\n\tkustomizeOptions, err := kustomizeSettings.GetOptions(a.Spec.Source)\n\tif err != nil {\n\t\treturn err\n\t}\n\tproj, err := argo.GetAppProject(&a.Spec, applisters.NewAppProjectLister(s.projInformer.GetIndexer()), s.ns, s.settingsMgr, s.db, ctx)\n\tif err != nil {\n\t\tif apierr.IsNotFound(err) {\n\t\t\treturn status.Errorf(codes.InvalidArgument, \"application references project %s which does not exist\", a.Spec.Project)\n\t\t}\n\t\treturn err\n\t}\n\n\thelmRepos, err := s.db.ListHelmRepositories(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpermittedHelmRepos, err := argo.GetPermittedRepos(proj, helmRepos)\n\tif err != nil {\n\t\treturn err\n\t}\n\thelmRepositoryCredentials, err := s.db.GetAllHelmRepositoryCredentials(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\thelmOptions, err := s.settingsMgr.GetHelmSettings()\n\tif err != nil {\n\t\treturn err\n\t}\n\tpermittedHelmCredentials, err := argo.GetPermittedReposCredentials(proj, helmRepositoryCredentials)\n\tif err != nil {\n\t\treturn err\n\t}\n\tenabledSourceTypes, err := s.settingsMgr.GetEnabledSourceTypes()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn action(client, repo, permittedHelmRepos, permittedHelmCredentials, helmOptions, kustomizeOptions, enabledSourceTypes)\n}\n\n// GetManifests returns application manifests\nfunc (s *Server) GetManifests(ctx context.Context, q *application.ApplicationManifestQuery) (*apiclient.ManifestResponse, error) {\n\ta, err := s.appLister.Get(*q.Name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionGet, appRBACName(*a)); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar manifestInfo *apiclient.ManifestResponse\n\terr = s.queryRepoServer(ctx, a, func(\n\t\tclient apiclient.RepoServerServiceClient, repo *appv1.Repository, helmRepos []*appv1.Repository, helmCreds []*appv1.RepoCreds, helmOptions *appv1.HelmOptions, kustomizeOptions *appv1.KustomizeOptions, enableGenerateManifests map[string]bool) error {\n\t\trevision := a.Spec.Source.TargetRevision\n\t\tif q.Revision != \"\" {\n\t\t\trevision = q.Revision\n\t\t}\n\t\tappInstanceLabelKey, err := s.settingsMgr.GetAppInstanceLabelKey()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tplugins, err := s.plugins()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tconfig, err := s.getApplicationClusterConfig(ctx, a)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tserverVersion, err := s.kubectl.GetServerVersion(config)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tapiResources, err := s.kubectl.GetAPIResources(config, false, kubecache.NewNoopSettings())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tmanifestInfo, err = client.GenerateManifest(ctx, &apiclient.ManifestRequest{\n\t\t\tRepo:               repo,\n\t\t\tRevision:           revision,\n\t\t\tAppLabelKey:        appInstanceLabelKey,\n\t\t\tAppName:            a.Name,\n\t\t\tNamespace:          a.Spec.Destination.Namespace,\n\t\t\tApplicationSource:  &a.Spec.Source,\n\t\t\tRepos:              helmRepos,\n\t\t\tPlugins:            plugins,\n\t\t\tKustomizeOptions:   kustomizeOptions,\n\t\t\tKubeVersion:        serverVersion,\n\t\t\tApiVersions:        argo.APIResourcesToStrings(apiResources, true),\n\t\t\tHelmRepoCreds:      helmCreds,\n\t\t\tHelmOptions:        helmOptions,\n\t\t\tTrackingMethod:     string(argoutil.GetTrackingMethod(s.settingsMgr)),\n\t\t\tEnabledSourceTypes: enableGenerateManifests,\n\t\t})\n\t\treturn err\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor i, manifest := range manifestInfo.Manifests {\n\t\tobj := &unstructured.Unstructured{}\n\t\terr = json.Unmarshal([]byte(manifest), obj)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif obj.GetKind() == kube.SecretKind && obj.GroupVersionKind().Group == \"\" {\n\t\t\tobj, _, err = diff.HideSecretData(obj, nil)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tdata, err := json.Marshal(obj)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tmanifestInfo.Manifests[i] = string(data)\n\t\t}\n\t}\n\n\treturn manifestInfo, nil\n}\n\n// Get returns an application by name\nfunc (s *Server) Get(ctx context.Context, q *application.ApplicationQuery) (*appv1.Application, error) {\n\t// We must use a client Get instead of an informer Get, because it's common to call Get immediately\n\t// following a Watch (which is not yet powered by an informer), and the Get must reflect what was\n\t// previously seen by the client.\n\ta, err := s.appclientset.ArgoprojV1alpha1().Applications(s.ns).Get(ctx, q.GetName(), metav1.GetOptions{\n\t\tResourceVersion: q.ResourceVersion,\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionGet, appRBACName(*a)); err != nil {\n\t\treturn nil, err\n\t}\n\tif q.Refresh == nil {\n\t\treturn a, nil\n\t}\n\n\trefreshType := appv1.RefreshTypeNormal\n\tif *q.Refresh == string(appv1.RefreshTypeHard) {\n\t\trefreshType = appv1.RefreshTypeHard\n\t}\n\tappIf := s.appclientset.ArgoprojV1alpha1().Applications(s.ns)\n\n\t// subscribe early with buffered channel to ensure we don't miss events\n\tevents := make(chan *appv1.ApplicationWatchEvent, watchAPIBufferSize)\n\tunsubscribe := s.appBroadcaster.Subscribe(events, func(event *appv1.ApplicationWatchEvent) bool {\n\t\treturn event.Application.Name == q.GetName()\n\t})\n\tdefer unsubscribe()\n\n\tapp, err := argoutil.RefreshApp(appIf, *q.Name, refreshType)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif refreshType == appv1.RefreshTypeHard {\n\t\t// force refresh cached application details\n\t\tif err := s.queryRepoServer(ctx, a, func(\n\t\t\tclient apiclient.RepoServerServiceClient,\n\t\t\trepo *appv1.Repository,\n\t\t\thelmRepos []*appv1.Repository,\n\t\t\t_ []*appv1.RepoCreds,\n\t\t\thelmOptions *appv1.HelmOptions,\n\t\t\tkustomizeOptions *appv1.KustomizeOptions,\n\t\t\tenabledSourceTypes map[string]bool,\n\t\t) error {\n\t\t\t_, err := client.GetAppDetails(ctx, &apiclient.RepoServerAppDetailsQuery{\n\t\t\t\tRepo:               repo,\n\t\t\t\tSource:             &app.Spec.Source,\n\t\t\t\tAppName:            app.Name,\n\t\t\t\tKustomizeOptions:   kustomizeOptions,\n\t\t\t\tRepos:              helmRepos,\n\t\t\t\tNoCache:            true,\n\t\t\t\tTrackingMethod:     string(argoutil.GetTrackingMethod(s.settingsMgr)),\n\t\t\t\tEnabledSourceTypes: enabledSourceTypes,\n\t\t\t\tHelmOptions:        helmOptions,\n\t\t\t})\n\t\t\treturn err\n\t\t}); err != nil {\n\t\t\tlog.Warnf(\"Failed to force refresh application details: %v\", err)\n\t\t}\n\t}\n\n\tminVersion := 0\n\tif minVersion, err = strconv.Atoi(app.ResourceVersion); err != nil {\n\t\tminVersion = 0\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, fmt.Errorf(\"application refresh deadline exceeded\")\n\t\tcase event := <-events:\n\t\t\tif appVersion, err := strconv.Atoi(event.Application.ResourceVersion); err == nil && appVersion > minVersion {\n\t\t\t\tannotations := event.Application.GetAnnotations()\n\t\t\t\tif annotations == nil {\n\t\t\t\t\tannotations = make(map[string]string)\n\t\t\t\t}\n\t\t\t\tif _, ok := annotations[appv1.AnnotationKeyRefresh]; !ok {\n\t\t\t\t\treturn &event.Application, nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ListResourceEvents returns a list of event resources\nfunc (s *Server) ListResourceEvents(ctx context.Context, q *application.ApplicationResourceEventsQuery) (*v1.EventList, error) {\n\ta, err := s.appLister.Get(*q.Name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionGet, appRBACName(*a)); err != nil {\n\t\treturn nil, err\n\t}\n\tvar (\n\t\tkubeClientset kubernetes.Interface\n\t\tfieldSelector string\n\t\tnamespace     string\n\t)\n\t// There are two places where we get events. If we are getting application events, we query\n\t// our own cluster. If it is events on a resource on an external cluster, then we query the\n\t// external cluster using its rest.Config\n\tif q.ResourceName == \"\" && q.ResourceUID == \"\" {\n\t\tkubeClientset = s.kubeclientset\n\t\tnamespace = a.Namespace\n\t\tfieldSelector = fields.SelectorFromSet(map[string]string{\n\t\t\t\"involvedObject.name\":      a.Name,\n\t\t\t\"involvedObject.uid\":       string(a.UID),\n\t\t\t\"involvedObject.namespace\": a.Namespace,\n\t\t}).String()\n\t} else {\n\t\tnamespace = q.ResourceNamespace\n\t\tvar config *rest.Config\n\t\tconfig, err = s.getApplicationClusterConfig(ctx, a)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tkubeClientset, err = kubernetes.NewForConfig(config)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfieldSelector = fields.SelectorFromSet(map[string]string{\n\t\t\t\"involvedObject.name\":      q.ResourceName,\n\t\t\t\"involvedObject.uid\":       q.ResourceUID,\n\t\t\t\"involvedObject.namespace\": namespace,\n\t\t}).String()\n\t}\n\tlog.Infof(\"Querying for resource events with field selector: %s\", fieldSelector)\n\topts := metav1.ListOptions{FieldSelector: fieldSelector}\n\treturn kubeClientset.CoreV1().Events(namespace).List(ctx, opts)\n}\n\nfunc (s *Server) validateAndUpdateApp(ctx context.Context, newApp *appv1.Application, merge bool, validate bool) (*appv1.Application, error) {\n\ts.projectLock.RLock(newApp.Spec.GetProject())\n\tdefer s.projectLock.RUnlock(newApp.Spec.GetProject())\n\n\tapp, err := s.appclientset.ArgoprojV1alpha1().Applications(s.ns).Get(ctx, newApp.Name, metav1.GetOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = s.validateAndNormalizeApp(ctx, newApp, validate)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.updateApp(app, newApp, ctx, merge)\n}\n\nfunc mergeStringMaps(items ...map[string]string) map[string]string {\n\tres := make(map[string]string)\n\tfor _, m := range items {\n\t\tif m == nil {\n\t\t\tcontinue\n\t\t}\n\t\tfor k, v := range m {\n\t\t\tres[k] = v\n\t\t}\n\t}\n\treturn res\n}\n\nvar informerSyncTimeout = 2 * time.Second\n\n// waitSync is a helper to wait until the application informer cache is synced after create/update.\n// It waits until the app in the informer, has a resource version greater than the version in the\n// supplied app, or after 2 seconds, whichever comes first. Returns true if synced.\n// We use an informer cache for read operations (Get, List). Since the cache is only\n// eventually consistent, it is possible that it doesn't reflect an application change immediately\n// after a mutating API call (create/update). This function should be called after a creates &\n// update to give a probable (but not guaranteed) chance of being up-to-date after the create/update.\nfunc (s *Server) waitSync(app *appv1.Application) {\n\tlogCtx := log.WithField(\"application\", app.Name)\n\tdeadline := time.Now().Add(informerSyncTimeout)\n\tminVersion, err := strconv.Atoi(app.ResourceVersion)\n\tif err != nil {\n\t\tlogCtx.Warnf(\"waitSync failed: could not parse resource version %s\", app.ResourceVersion)\n\t\ttime.Sleep(50 * time.Millisecond) // sleep anyway\n\t\treturn\n\t}\n\tfor {\n\t\tif currApp, err := s.appLister.Get(app.Name); err == nil {\n\t\t\tcurrVersion, err := strconv.Atoi(currApp.ResourceVersion)\n\t\t\tif err == nil && currVersion >= minVersion {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tif time.Now().After(deadline) {\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(20 * time.Millisecond)\n\t}\n\tlogCtx.Warnf(\"waitSync failed: timed out\")\n}\n\nfunc (s *Server) updateApp(app *appv1.Application, newApp *appv1.Application, ctx context.Context, merge bool) (*appv1.Application, error) {\n\tfor i := 0; i < 10; i++ {\n\t\tapp.Spec = newApp.Spec\n\t\tif merge {\n\t\t\tapp.Labels = mergeStringMaps(app.Labels, newApp.Labels)\n\t\t\tapp.Annotations = mergeStringMaps(app.Annotations, newApp.Annotations)\n\t\t} else {\n\t\t\tapp.Labels = newApp.Labels\n\t\t\tapp.Annotations = newApp.Annotations\n\t\t}\n\n\t\tapp.Finalizers = newApp.Finalizers\n\n\t\tres, err := s.appclientset.ArgoprojV1alpha1().Applications(s.ns).Update(ctx, app, metav1.UpdateOptions{})\n\t\tif err == nil {\n\t\t\ts.logAppEvent(app, ctx, argo.EventReasonResourceUpdated, \"updated application spec\")\n\t\t\ts.waitSync(res)\n\t\t\treturn res, nil\n\t\t}\n\t\tif !apierr.IsConflict(err) {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tapp, err = s.appclientset.ArgoprojV1alpha1().Applications(s.ns).Get(ctx, newApp.Name, metav1.GetOptions{})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn nil, status.Errorf(codes.Internal, \"Failed to update application. Too many conflicts\")\n}\n\n// Update updates an application\nfunc (s *Server) Update(ctx context.Context, q *application.ApplicationUpdateRequest) (*appv1.Application, error) {\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionUpdate, appRBACName(*q.Application)); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvalidate := true\n\tif q.Validate != nil {\n\t\tvalidate = *q.Validate\n\t}\n\treturn s.validateAndUpdateApp(ctx, q.Application, false, validate)\n}\n\n// UpdateSpec updates an application spec and filters out any invalid parameter overrides\nfunc (s *Server) UpdateSpec(ctx context.Context, q *application.ApplicationUpdateSpecRequest) (*appv1.ApplicationSpec, error) {\n\ta, err := s.appclientset.ArgoprojV1alpha1().Applications(s.ns).Get(ctx, *q.Name, metav1.GetOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionUpdate, appRBACName(*a)); err != nil {\n\t\treturn nil, err\n\t}\n\ta.Spec = q.Spec\n\tvalidate := true\n\tif q.Validate != nil {\n\t\tvalidate = *q.Validate\n\t}\n\ta, err = s.validateAndUpdateApp(ctx, a, false, validate)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &a.Spec, nil\n}\n\n// Patch patches an application\nfunc (s *Server) Patch(ctx context.Context, q *application.ApplicationPatchRequest) (*appv1.Application, error) {\n\n\tapp, err := s.appclientset.ArgoprojV1alpha1().Applications(s.ns).Get(ctx, *q.Name, metav1.GetOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err = s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionUpdate, appRBACName(*app)); err != nil {\n\t\treturn nil, err\n\t}\n\n\tjsonApp, err := json.Marshal(app)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar patchApp []byte\n\n\tswitch q.PatchType {\n\tcase \"json\", \"\":\n\t\tpatch, err := jsonpatch.DecodePatch([]byte(q.Patch))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpatchApp, err = patch.Apply(jsonApp)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\tcase \"merge\":\n\t\tpatchApp, err = jsonpatch.MergePatch(jsonApp, []byte(q.Patch))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\tdefault:\n\t\treturn nil, status.Error(codes.InvalidArgument, fmt.Sprintf(\"Patch type '%s' is not supported\", q.PatchType))\n\t}\n\n\tnewApp := &v1alpha1.Application{}\n\terr = json.Unmarshal(patchApp, newApp)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn s.validateAndUpdateApp(ctx, newApp, false, true)\n}\n\n// Delete removes an application and all associated resources\nfunc (s *Server) Delete(ctx context.Context, q *application.ApplicationDeleteRequest) (*application.ApplicationResponse, error) {\n\ta, err := s.appclientset.ArgoprojV1alpha1().Applications(s.ns).Get(ctx, *q.Name, metav1.GetOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.projectLock.RLock(a.Spec.Project)\n\tdefer s.projectLock.RUnlock(a.Spec.Project)\n\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionDelete, appRBACName(*a)); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif q.Cascade != nil && !*q.Cascade && q.GetPropagationPolicy() != \"\" {\n\t\treturn nil, status.Error(codes.InvalidArgument, \"cannot set propagation policy when cascading is disabled\")\n\t}\n\n\tpatchFinalizer := false\n\tif q.Cascade == nil || *q.Cascade {\n\t\t// validate the propgation policy\n\t\tpolicyFinalizer := getPropagationPolicyFinalizer(q.GetPropagationPolicy())\n\t\tif policyFinalizer == \"\" {\n\t\t\treturn nil, status.Errorf(codes.InvalidArgument, \"invalid propagation policy: %s\", *q.PropagationPolicy)\n\t\t}\n\t\tif !a.IsFinalizerPresent(policyFinalizer) {\n\t\t\ta.SetCascadedDeletion(policyFinalizer)\n\t\t\tpatchFinalizer = true\n\t\t}\n\t} else {\n\t\tif a.CascadedDeletion() {\n\t\t\ta.UnSetCascadedDeletion()\n\t\t\tpatchFinalizer = true\n\t\t}\n\t}\n\n\tif patchFinalizer {\n\t\t// Although the cascaded deletion/propagation policy finalizer is not set when apps are created via\n\t\t// API, they will often be set by the user as part of declarative config. As part of a delete\n\t\t// request, we always calculate the patch to see if we need to set/unset the finalizer.\n\t\tpatch, err := json.Marshal(map[string]interface{}{\n\t\t\t\"metadata\": map[string]interface{}{\n\t\t\t\t\"finalizers\": a.Finalizers,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t_, err = s.appclientset.ArgoprojV1alpha1().Applications(a.Namespace).Patch(ctx, a.Name, types.MergePatchType, patch, metav1.PatchOptions{})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\terr = s.appclientset.ArgoprojV1alpha1().Applications(s.ns).Delete(ctx, *q.Name, metav1.DeleteOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts.logAppEvent(a, ctx, argo.EventReasonResourceDeleted, \"deleted application\")\n\treturn &application.ApplicationResponse{}, nil\n}\n\nfunc (s *Server) Watch(q *application.ApplicationQuery, ws application.ApplicationService_WatchServer) error {\n\tlogCtx := log.NewEntry(log.New())\n\tif q.Name != nil {\n\t\tlogCtx = logCtx.WithField(\"application\", *q.Name)\n\t}\n\tprojects := map[string]bool{}\n\tfor i := range q.Projects {\n\t\tprojects[q.Projects[i]] = true\n\t}\n\tclaims := ws.Context().Value(\"claims\")\n\tselector, err := labels.Parse(q.Selector)\n\tif err != nil {\n\t\treturn err\n\t}\n\tminVersion := 0\n\tif q.ResourceVersion != \"\" {\n\t\tif minVersion, err = strconv.Atoi(q.ResourceVersion); err != nil {\n\t\t\tminVersion = 0\n\t\t}\n\t}\n\n\t// sendIfPermitted is a helper to send the application to the client's streaming channel if the\n\t// caller has RBAC privileges permissions to view it\n\tsendIfPermitted := func(a appv1.Application, eventType watch.EventType) {\n\t\tif len(projects) > 0 && !projects[a.Spec.GetProject()] {\n\t\t\treturn\n\t\t}\n\n\t\tif appVersion, err := strconv.Atoi(a.ResourceVersion); err == nil && appVersion < minVersion {\n\t\t\treturn\n\t\t}\n\t\tmatchedEvent := (q.GetName() == \"\" || a.Name == q.GetName()) && selector.Matches(labels.Set(a.Labels))\n\t\tif !matchedEvent {\n\t\t\treturn\n\t\t}\n\n\t\tif !s.enf.Enforce(claims, rbacpolicy.ResourceApplications, rbacpolicy.ActionGet, appRBACName(a)) {\n\t\t\t// do not emit apps user does not have accessing\n\t\t\treturn\n\t\t}\n\t\terr := ws.Send(&appv1.ApplicationWatchEvent{\n\t\t\tType:        eventType,\n\t\t\tApplication: a,\n\t\t})\n\t\tif err != nil {\n\t\t\tlogCtx.Warnf(\"Unable to send stream message: %v\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\tevents := make(chan *appv1.ApplicationWatchEvent, watchAPIBufferSize)\n\t// Mimic watch API behavior: send ADDED events if no resource version provided\n\t// If watch API is executed for one application when emit event even if resource version is provided\n\t// This is required since single app watch API is used for during operations like app syncing and it is\n\t// critical to never miss events.\n\tif q.ResourceVersion == \"\" || q.GetName() != \"\" {\n\t\tapps, err := s.appLister.List(selector)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsort.Slice(apps, func(i, j int) bool {\n\t\t\treturn apps[i].Name < apps[j].Name\n\t\t})\n\t\tfor i := range apps {\n\t\t\tsendIfPermitted(*apps[i], watch.Added)\n\t\t}\n\t}\n\tunsubscribe := s.appBroadcaster.Subscribe(events)\n\tdefer unsubscribe()\n\tfor {\n\t\tselect {\n\t\tcase event := <-events:\n\t\t\tsendIfPermitted(event.Application, event.Type)\n\t\tcase <-ws.Context().Done():\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\nfunc (s *Server) validateAndNormalizeApp(ctx context.Context, app *appv1.Application, validate bool) error {\n\tproj, err := argo.GetAppProject(&app.Spec, applisters.NewAppProjectLister(s.projInformer.GetIndexer()), s.ns, s.settingsMgr, s.db, ctx)\n\tif err != nil {\n\t\tif apierr.IsNotFound(err) {\n\t\t\treturn status.Errorf(codes.InvalidArgument, \"application references project %s which does not exist\", app.Spec.Project)\n\t\t}\n\t\treturn err\n\t}\n\tcurrApp, err := s.appclientset.ArgoprojV1alpha1().Applications(s.ns).Get(ctx, app.Name, metav1.GetOptions{})\n\tif err != nil {\n\t\tif !apierr.IsNotFound(err) {\n\t\t\treturn err\n\t\t}\n\t\t// Kubernetes go-client will return a pointer to a zero-value app instead of nil, even\n\t\t// though the API response was NotFound. This behavior was confirmed via logs.\n\t\tcurrApp = nil\n\t}\n\tif currApp != nil && currApp.Spec.GetProject() != app.Spec.GetProject() {\n\t\t// When changing projects, caller must have application create & update privileges in new project\n\t\t// NOTE: the update check was already verified in the caller to this function\n\t\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionCreate, appRBACName(*app)); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// They also need 'update' privileges in the old project\n\t\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionUpdate, appRBACName(*currApp)); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// If source is Kustomize add build options\n\tkustomizeSettings, err := s.settingsMgr.GetKustomizeSettings()\n\tif err != nil {\n\t\treturn err\n\t}\n\tkustomizeOptions, err := kustomizeSettings.GetOptions(app.Spec.Source)\n\tif err != nil {\n\t\treturn err\n\t}\n\tplugins, err := s.plugins()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := argo.ValidateDestination(ctx, &app.Spec.Destination, s.db); err != nil {\n\t\treturn status.Errorf(codes.InvalidArgument, \"application destination spec for %s is invalid: %s\", app.Name, err.Error())\n\t}\n\n\tvar conditions []appv1.ApplicationCondition\n\tif validate {\n\t\tconditions, err = argo.ValidateRepo(ctx, app, s.repoClientset, s.db, kustomizeOptions, plugins, s.kubectl, proj, s.settingsMgr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif len(conditions) > 0 {\n\t\t\treturn status.Errorf(codes.InvalidArgument, \"application spec for %s is invalid: %s\", app.Name, argo.FormatAppConditions(conditions))\n\t\t}\n\t}\n\n\tconditions, err = argo.ValidatePermissions(ctx, &app.Spec, proj, s.db)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(conditions) > 0 {\n\t\treturn status.Errorf(codes.InvalidArgument, \"application spec for %s is invalid: %s\", app.Name, argo.FormatAppConditions(conditions))\n\t}\n\n\tapp.Spec = *argo.NormalizeApplicationSpec(&app.Spec)\n\treturn nil\n}\n\nfunc (s *Server) getApplicationClusterConfig(ctx context.Context, a *appv1.Application) (*rest.Config, error) {\n\tif err := argo.ValidateDestination(ctx, &a.Spec.Destination, s.db); err != nil {\n\t\treturn nil, err\n\t}\n\tclst, err := s.db.GetCluster(ctx, a.Spec.Destination.Server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconfig := clst.RESTConfig()\n\treturn config, err\n}\n\n// getCachedAppState loads the cached state and trigger app refresh if cache is missing\nfunc (s *Server) getCachedAppState(ctx context.Context, a *appv1.Application, getFromCache func() error) error {\n\terr := getFromCache()\n\tif err != nil && err == servercache.ErrCacheMiss {\n\t\tconditions := a.Status.GetConditions(map[appv1.ApplicationConditionType]bool{\n\t\t\tappv1.ApplicationConditionComparisonError:  true,\n\t\t\tappv1.ApplicationConditionInvalidSpecError: true,\n\t\t})\n\t\tif len(conditions) > 0 {\n\t\t\treturn errors.New(argoutil.FormatAppConditions(conditions))\n\t\t}\n\t\t_, err = s.Get(ctx, &application.ApplicationQuery{\n\t\t\tName:    pointer.StringPtr(a.Name),\n\t\t\tRefresh: pointer.StringPtr(string(appv1.RefreshTypeNormal)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn getFromCache()\n\t}\n\treturn err\n}\n\nfunc (s *Server) getAppResources(ctx context.Context, a *appv1.Application) (*appv1.ApplicationTree, error) {\n\tvar tree appv1.ApplicationTree\n\terr := s.getCachedAppState(ctx, a, func() error {\n\t\treturn s.cache.GetAppResourcesTree(a.Name, &tree)\n\t})\n\treturn &tree, err\n}\n\nfunc (s *Server) getAppResource(ctx context.Context, action string, q *application.ApplicationResourceRequest) (*appv1.ResourceNode, *rest.Config, *appv1.Application, error) {\n\ta, err := s.appLister.Get(*q.Name)\n\tif err != nil {\n\t\treturn nil, nil, nil, err\n\t}\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, action, appRBACName(*a)); err != nil {\n\t\treturn nil, nil, nil, err\n\t}\n\n\ttree, err := s.getAppResources(ctx, a)\n\tif err != nil {\n\t\treturn nil, nil, nil, err\n\t}\n\n\tfound := tree.FindNode(q.Group, q.Kind, q.Namespace, q.ResourceName)\n\tif found == nil {\n\t\treturn nil, nil, nil, status.Errorf(codes.InvalidArgument, \"%s %s %s not found as part of application %s\", q.Kind, q.Group, q.ResourceName, *q.Name)\n\t}\n\tconfig, err := s.getApplicationClusterConfig(ctx, a)\n\tif err != nil {\n\t\treturn nil, nil, nil, err\n\t}\n\treturn found, config, a, nil\n}\n\nfunc (s *Server) GetResource(ctx context.Context, q *application.ApplicationResourceRequest) (*application.ApplicationResourceResponse, error) {\n\tres, config, _, err := s.getAppResource(ctx, rbacpolicy.ActionGet, q)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// make sure to use specified resource version if provided\n\tif q.Version != \"\" {\n\t\tres.Version = q.Version\n\t}\n\tobj, err := s.kubectl.GetResource(ctx, config, res.GroupKindVersion(), res.Name, res.Namespace)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tobj, err = replaceSecretValues(obj)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdata, err := json.Marshal(obj.Object)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &application.ApplicationResourceResponse{Manifest: string(data)}, nil\n}\n\nfunc replaceSecretValues(obj *unstructured.Unstructured) (*unstructured.Unstructured, error) {\n\tif obj.GetKind() == kube.SecretKind && obj.GroupVersionKind().Group == \"\" {\n\t\t_, obj, err := diff.HideSecretData(nil, obj)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn obj, err\n\t}\n\treturn obj, nil\n}\n\n// PatchResource patches a resource\nfunc (s *Server) PatchResource(ctx context.Context, q *application.ApplicationResourcePatchRequest) (*application.ApplicationResourceResponse, error) {\n\tresourceRequest := &application.ApplicationResourceRequest{\n\t\tName:         q.Name,\n\t\tNamespace:    q.Namespace,\n\t\tResourceName: q.ResourceName,\n\t\tKind:         q.Kind,\n\t\tVersion:      q.Version,\n\t\tGroup:        q.Group,\n\t}\n\tres, config, a, err := s.getAppResource(ctx, rbacpolicy.ActionUpdate, resourceRequest)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionUpdate, appRBACName(*a)); err != nil {\n\t\treturn nil, err\n\t}\n\n\tmanifest, err := s.kubectl.PatchResource(ctx, config, res.GroupKindVersion(), res.Name, res.Namespace, types.PatchType(q.PatchType), []byte(q.Patch))\n\tif err != nil {\n\t\t// don't expose real error for secrets since it might contain secret data\n\t\tif res.Kind == kube.SecretKind && res.Group == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"failed to patch Secret %s/%s\", res.Namespace, res.Name)\n\t\t}\n\t\treturn nil, err\n\t}\n\tmanifest, err = replaceSecretValues(manifest)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdata, err := json.Marshal(manifest.Object)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts.logAppEvent(a, ctx, argo.EventReasonResourceUpdated, fmt.Sprintf(\"patched resource %s/%s '%s'\", q.Group, q.Kind, q.ResourceName))\n\treturn &application.ApplicationResourceResponse{\n\t\tManifest: string(data),\n\t}, nil\n}\n\n// DeleteResource deletes a specified resource\nfunc (s *Server) DeleteResource(ctx context.Context, q *application.ApplicationResourceDeleteRequest) (*application.ApplicationResponse, error) {\n\tresourceRequest := &application.ApplicationResourceRequest{\n\t\tName:         q.Name,\n\t\tNamespace:    q.Namespace,\n\t\tResourceName: q.ResourceName,\n\t\tKind:         q.Kind,\n\t\tVersion:      q.Version,\n\t\tGroup:        q.Group,\n\t}\n\tres, config, a, err := s.getAppResource(ctx, rbacpolicy.ActionDelete, resourceRequest)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionDelete, appRBACName(*a)); err != nil {\n\t\treturn nil, err\n\t}\n\tvar deleteOption metav1.DeleteOptions\n\tif q.GetOrphan() {\n\t\tpropagationPolicy := metav1.DeletePropagationOrphan\n\t\tdeleteOption = metav1.DeleteOptions{PropagationPolicy: &propagationPolicy}\n\t} else if q.GetForce() {\n\t\tpropagationPolicy := metav1.DeletePropagationBackground\n\t\tzeroGracePeriod := int64(0)\n\t\tdeleteOption = metav1.DeleteOptions{PropagationPolicy: &propagationPolicy, GracePeriodSeconds: &zeroGracePeriod}\n\t} else {\n\t\tpropagationPolicy := metav1.DeletePropagationForeground\n\t\tdeleteOption = metav1.DeleteOptions{PropagationPolicy: &propagationPolicy}\n\t}\n\terr = s.kubectl.DeleteResource(ctx, config, res.GroupKindVersion(), res.Name, res.Namespace, deleteOption)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts.logAppEvent(a, ctx, argo.EventReasonResourceDeleted, fmt.Sprintf(\"deleted resource %s/%s '%s'\", q.Group, q.Kind, q.ResourceName))\n\treturn &application.ApplicationResponse{}, nil\n}\n\nfunc (s *Server) ResourceTree(ctx context.Context, q *application.ResourcesQuery) (*appv1.ApplicationTree, error) {\n\ta, err := s.appLister.Get(q.GetApplicationName())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionGet, appRBACName(*a)); err != nil {\n\t\treturn nil, err\n\t}\n\treturn s.getAppResources(ctx, a)\n}\n\nfunc (s *Server) WatchResourceTree(q *application.ResourcesQuery, ws application.ApplicationService_WatchResourceTreeServer) error {\n\ta, err := s.appLister.Get(q.GetApplicationName())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := s.enf.EnforceErr(ws.Context().Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionGet, appRBACName(*a)); err != nil {\n\t\treturn err\n\t}\n\n\treturn s.cache.OnAppResourcesTreeChanged(ws.Context(), q.GetApplicationName(), func() error {\n\t\tvar tree appv1.ApplicationTree\n\t\terr := s.cache.GetAppResourcesTree(q.GetApplicationName(), &tree)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn ws.Send(&tree)\n\t})\n}\n\nfunc (s *Server) RevisionMetadata(ctx context.Context, q *application.RevisionMetadataQuery) (*v1alpha1.RevisionMetadata, error) {\n\ta, err := s.appLister.Get(q.GetName())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionGet, appRBACName(*a)); err != nil {\n\t\treturn nil, err\n\t}\n\trepo, err := s.db.GetRepository(ctx, a.Spec.Source.RepoURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// We need to get some information with the project associated to the app,\n\t// so we'll know whether GPG signatures are enforced.\n\tproj, err := argo.GetAppProject(&a.Spec, applisters.NewAppProjectLister(s.projInformer.GetIndexer()), a.Namespace, s.settingsMgr, s.db, ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconn, repoClient, err := s.repoClientset.NewRepoServerClient()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer ioutil.Close(conn)\n\treturn repoClient.GetRevisionMetadata(ctx, &apiclient.RepoServerRevisionMetadataRequest{\n\t\tRepo:           repo,\n\t\tRevision:       q.GetRevision(),\n\t\tCheckSignature: len(proj.Spec.SignatureKeys) > 0,\n\t})\n}\n\nfunc isMatchingResource(q *application.ResourcesQuery, key kube.ResourceKey) bool {\n\treturn (q.Name == \"\" || q.Name == key.Name) &&\n\t\t(q.Namespace == \"\" || q.Namespace == key.Namespace) &&\n\t\t(q.Group == \"\" || q.Group == key.Group) &&\n\t\t(q.Kind == \"\" || q.Kind == key.Kind)\n}\n\nfunc (s *Server) ManagedResources(ctx context.Context, q *application.ResourcesQuery) (*application.ManagedResourcesResponse, error) {\n\ta, err := s.appLister.Get(*q.ApplicationName)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error getting application: %s\", err)\n\t}\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionGet, appRBACName(*a)); err != nil {\n\t\treturn nil, fmt.Errorf(\"error verifying rbac: %s\", err)\n\t}\n\titems := make([]*appv1.ResourceDiff, 0)\n\terr = s.getCachedAppState(ctx, a, func() error {\n\t\treturn s.cache.GetAppManagedResources(a.Name, &items)\n\t})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error getting cached app state: %s\", err)\n\t}\n\tres := &application.ManagedResourcesResponse{}\n\tfor i := range items {\n\t\titem := items[i]\n\t\tif isMatchingResource(q, kube.ResourceKey{Name: item.Name, Namespace: item.Namespace, Kind: item.Kind, Group: item.Group}) {\n\t\t\tres.Items = append(res.Items, item)\n\t\t}\n\t}\n\n\treturn res, nil\n}\n\nfunc (s *Server) PodLogs(q *application.ApplicationPodLogsQuery, ws application.ApplicationService_PodLogsServer) error {\n\tif q.PodName != nil {\n\t\tpodKind := \"Pod\"\n\t\tq.Kind = &podKind\n\t\tq.ResourceName = q.PodName\n\t}\n\n\tvar sinceSeconds, tailLines *int64\n\tif q.SinceSeconds > 0 {\n\t\tsinceSeconds = &q.SinceSeconds\n\t}\n\tif q.TailLines > 0 {\n\t\ttailLines = &q.TailLines\n\t}\n\tvar untilTime *metav1.Time\n\tif q.GetUntilTime() != \"\" {\n\t\tif val, err := time.Parse(time.RFC3339Nano, q.GetUntilTime()); err != nil {\n\t\t\treturn fmt.Errorf(\"invalid untilTime parameter value: %v\", err)\n\t\t} else {\n\t\t\tuntilTimeVal := metav1.NewTime(val)\n\t\t\tuntilTime = &untilTimeVal\n\t\t}\n\t}\n\n\tliteral := \"\"\n\tinverse := false\n\tif q.GetFilter() != \"\" {\n\t\tliteral = *q.Filter\n\t\tif literal[0] == '!' {\n\t\t\tliteral = literal[1:]\n\t\t\tinverse = true\n\t\t}\n\t}\n\n\ta, err := s.appLister.Get(q.GetName())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := s.enf.EnforceErr(ws.Context().Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionGet, appRBACName(*a)); err != nil {\n\t\treturn err\n\t}\n\n\t// Temporarily, logs RBAC will be enforced only if an internal var serverRBACLogEnforceEnable (representing server.rbac.log.enforce.enable env var)\n\t// is defined and has a \"true\" value\n\t// Otherwise, no RBAC enforcement for logs will take place (meaning, PodLogs will return the logs,\n\t// even if there is no explicit RBAC allow, or if there is an explicit RBAC deny)\n\t// In the future, logs RBAC will be always enforced and the parameter along with this check will be removed\n\tserverRBACLogEnforceEnable, err := s.settingsMgr.GetServerRBACLogEnforceEnable()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif serverRBACLogEnforceEnable {\n\t\tif err := s.enf.EnforceErr(ws.Context().Value(\"claims\"), rbacpolicy.ResourceLogs, rbacpolicy.ActionGet, appRBACName(*a)); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\ttree, err := s.getAppResources(ws.Context(), a)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tconfig, err := s.getApplicationClusterConfig(ws.Context(), a)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tkubeClientset, err := kubernetes.NewForConfig(config)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// from the tree find pods which match query of kind, group, and resource name\n\tpods := getSelectedPods(tree.Nodes, q)\n\tif len(pods) == 0 {\n\t\treturn nil\n\t}\n\n\tif len(pods) > maxPodLogsToRender {\n\t\treturn errors.New(\"Max pods to view logs are reached. Please provide more granular query.\")\n\t}\n\n\tvar streams []chan logEntry\n\n\tfor _, pod := range pods {\n\t\tstream, err := kubeClientset.CoreV1().Pods(pod.Namespace).GetLogs(pod.Name, &v1.PodLogOptions{\n\t\t\tContainer:    q.Container,\n\t\t\tFollow:       q.Follow,\n\t\t\tTimestamps:   true,\n\t\t\tSinceSeconds: sinceSeconds,\n\t\t\tSinceTime:    q.SinceTime,\n\t\t\tTailLines:    tailLines,\n\t\t\tPrevious:     q.Previous,\n\t\t}).Stream(ws.Context())\n\t\tpodName := pod.Name\n\t\tlogStream := make(chan logEntry)\n\t\tif err == nil {\n\t\t\tdefer ioutil.Close(stream)\n\t\t}\n\n\t\tstreams = append(streams, logStream)\n\t\tgo func() {\n\t\t\t// if k8s failed to start steaming logs (typically because Pod is not ready yet)\n\t\t\t// then the error should be shown in the UI so that user know the reason\n\t\t\tif err != nil {\n\t\t\t\tlogStream <- logEntry{line: err.Error()}\n\t\t\t} else {\n\t\t\t\tparseLogsStream(podName, stream, logStream)\n\t\t\t}\n\t\t\tclose(logStream)\n\t\t}()\n\t}\n\n\tlogStream := mergeLogStreams(streams, time.Millisecond*100)\n\tsentCount := int64(0)\n\tdone := make(chan error)\n\tgo func() {\n\t\tfor entry := range logStream {\n\t\t\tif entry.err != nil {\n\t\t\t\tdone <- entry.err\n\t\t\t\treturn\n\t\t\t} else {\n\t\t\t\tif q.Filter != nil {\n\t\t\t\t\tlineContainsFilter := strings.Contains(entry.line, literal)\n\t\t\t\t\tif (inverse && lineContainsFilter) || (!inverse && !lineContainsFilter) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif untilTime != nil && entry.timeStamp.After(untilTime.Time) {\n\t\t\t\t\tdone <- ws.Send(&application.LogEntry{\n\t\t\t\t\t\tLast: true,\n\t\t\t\t\t})\n\t\t\t\t\treturn\n\t\t\t\t} else {\n\t\t\t\t\tsentCount++\n\t\t\t\t\tif err := ws.Send(&application.LogEntry{\n\t\t\t\t\t\tPodName:      entry.podName,\n\t\t\t\t\t\tContent:      entry.line,\n\t\t\t\t\t\tTimeStampStr: entry.timeStamp.Format(time.RFC3339Nano),\n\t\t\t\t\t\tTimeStamp:    metav1.NewTime(entry.timeStamp),\n\t\t\t\t\t}); err != nil {\n\t\t\t\t\t\tdone <- err\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdone <- ws.Send(&application.LogEntry{Last: true})\n\t}()\n\n\tselect {\n\tcase err := <-done:\n\t\treturn err\n\tcase <-ws.Context().Done():\n\t\tlog.WithField(\"application\", q.Name).Debug(\"k8s pod logs reader completed due to closed grpc context\")\n\t\treturn nil\n\t}\n}\n\n// from all of the treeNodes, get the pod who meets the criteria or whose parents meets the criteria\nfunc getSelectedPods(treeNodes []appv1.ResourceNode, q *application.ApplicationPodLogsQuery) []appv1.ResourceNode {\n\tvar pods []appv1.ResourceNode\n\tisTheOneMap := make(map[string]bool)\n\tfor _, treeNode := range treeNodes {\n\t\tif treeNode.Kind == kube.PodKind && treeNode.Group == \"\" {\n\t\t\tif isTheSelectedOne(&treeNode, q, treeNodes, isTheOneMap) {\n\t\t\t\tpods = append(pods, treeNode)\n\t\t\t}\n\t\t}\n\t}\n\treturn pods\n}\n\n// check is currentNode is matching with group, kind, and name, or if any of its parents matches\nfunc isTheSelectedOne(currentNode *appv1.ResourceNode, q *application.ApplicationPodLogsQuery, resourceNodes []appv1.ResourceNode, isTheOneMap map[string]bool) bool {\n\texist, value := isTheOneMap[currentNode.UID]\n\tif exist {\n\t\treturn value\n\t}\n\n\tif (q.ResourceName == nil || *q.ResourceName == \"\" || currentNode.Name == *q.ResourceName) &&\n\t\t(q.Kind == nil || *q.Kind == \"\" || currentNode.Kind == *q.Kind) &&\n\t\t(q.Group == nil || *q.Group == \"\" || currentNode.Group == *q.Group) &&\n\t\t(q.Namespace == \"\" || currentNode.Namespace == q.Namespace) {\n\t\tisTheOneMap[currentNode.UID] = true\n\t\treturn true\n\t}\n\n\tif len(currentNode.ParentRefs) == 0 {\n\t\tisTheOneMap[currentNode.UID] = false\n\t\treturn false\n\t}\n\n\tfor _, parentResource := range currentNode.ParentRefs {\n\t\t//look up parentResource from resourceNodes\n\t\t//then check if the parent isTheSelectedOne\n\t\tfor _, resourceNode := range resourceNodes {\n\t\t\tif resourceNode.Namespace == parentResource.Namespace &&\n\t\t\t\tresourceNode.Name == parentResource.Name &&\n\t\t\t\tresourceNode.Group == parentResource.Group &&\n\t\t\t\tresourceNode.Kind == parentResource.Kind {\n\t\t\t\tif isTheSelectedOne(&resourceNode, q, resourceNodes, isTheOneMap) {\n\t\t\t\t\tisTheOneMap[currentNode.UID] = true\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tisTheOneMap[currentNode.UID] = false\n\treturn false\n}\n\n// Sync syncs an application to its target state\nfunc (s *Server) Sync(ctx context.Context, syncReq *application.ApplicationSyncRequest) (*appv1.Application, error) {\n\tappIf := s.appclientset.ArgoprojV1alpha1().Applications(s.ns)\n\ta, err := appIf.Get(ctx, *syncReq.Name, metav1.GetOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tproj, err := argo.GetAppProject(&a.Spec, applisters.NewAppProjectLister(s.projInformer.GetIndexer()), a.Namespace, s.settingsMgr, s.db, ctx)\n\tif err != nil {\n\t\tif apierr.IsNotFound(err) {\n\t\t\treturn a, status.Errorf(codes.InvalidArgument, \"application references project %s which does not exist\", a.Spec.Project)\n\t\t}\n\t\treturn a, err\n\t}\n\n\tif !proj.Spec.SyncWindows.Matches(a).CanSync(true) {\n\t\treturn a, status.Errorf(codes.PermissionDenied, \"Cannot sync: Blocked by sync window\")\n\t}\n\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionSync, appRBACName(*a)); err != nil {\n\t\treturn nil, err\n\t}\n\tif syncReq.Manifests != nil {\n\t\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionOverride, appRBACName(*a)); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif a.Spec.SyncPolicy != nil && a.Spec.SyncPolicy.Automated != nil && !syncReq.DryRun {\n\t\t\treturn nil, status.Error(codes.FailedPrecondition, \"Cannot use local sync when Automatic Sync Policy is enabled unless for dry run\")\n\t\t}\n\t}\n\tif a.DeletionTimestamp != nil {\n\t\treturn nil, status.Errorf(codes.FailedPrecondition, \"application is deleting\")\n\t}\n\tif a.Spec.SyncPolicy != nil && a.Spec.SyncPolicy.Automated != nil {\n\t\tif syncReq.Revision != \"\" && syncReq.Revision != text.FirstNonEmpty(a.Spec.Source.TargetRevision, \"HEAD\") {\n\t\t\treturn nil, status.Errorf(codes.FailedPrecondition, \"Cannot sync to %s: auto-sync currently set to %s\", syncReq.Revision, a.Spec.Source.TargetRevision)\n\t\t}\n\t}\n\trevision, displayRevision, err := s.resolveRevision(ctx, a, syncReq)\n\tif err != nil {\n\t\treturn nil, status.Errorf(codes.FailedPrecondition, err.Error())\n\t}\n\n\tvar retry *appv1.RetryStrategy\n\tvar syncOptions appv1.SyncOptions\n\tif a.Spec.SyncPolicy != nil {\n\t\tsyncOptions = a.Spec.SyncPolicy.SyncOptions\n\t\tretry = a.Spec.SyncPolicy.Retry\n\t}\n\tif syncReq.RetryStrategy != nil {\n\t\tretry = syncReq.RetryStrategy\n\t}\n\tif syncReq.SyncOptions != nil {\n\t\tsyncOptions = syncReq.SyncOptions.Items\n\t}\n\n\t// We cannot use local manifests if we're only allowed to sync to signed commits\n\tif syncReq.Manifests != nil && len(proj.Spec.SignatureKeys) > 0 {\n\t\treturn nil, status.Errorf(codes.FailedPrecondition, \"Cannot use local sync when signature keys are required.\")\n\t}\n\n\top := appv1.Operation{\n\t\tSync: &appv1.SyncOperation{\n\t\t\tRevision:     revision,\n\t\t\tPrune:        syncReq.Prune,\n\t\t\tDryRun:       syncReq.DryRun,\n\t\t\tSyncOptions:  syncOptions,\n\t\t\tSyncStrategy: syncReq.Strategy,\n\t\t\tResources:    syncReq.Resources,\n\t\t\tManifests:    syncReq.Manifests,\n\t\t},\n\t\tInitiatedBy: appv1.OperationInitiator{Username: session.Username(ctx)},\n\t\tInfo:        syncReq.Infos,\n\t}\n\tif retry != nil {\n\t\top.Retry = *retry\n\t}\n\n\ta, err = argo.SetAppOperation(appIf, *syncReq.Name, &op)\n\tif err == nil {\n\t\tpartial := \"\"\n\t\tif len(syncReq.Resources) > 0 {\n\t\t\tpartial = \"partial \"\n\t\t}\n\t\treason := fmt.Sprintf(\"initiated %ssync to %s\", partial, displayRevision)\n\t\tif syncReq.Manifests != nil {\n\t\t\treason = fmt.Sprintf(\"initiated %ssync locally\", partial)\n\t\t}\n\t\ts.logAppEvent(a, ctx, argo.EventReasonOperationStarted, reason)\n\t}\n\treturn a, err\n}\n\nfunc (s *Server) Rollback(ctx context.Context, rollbackReq *application.ApplicationRollbackRequest) (*appv1.Application, error) {\n\tappIf := s.appclientset.ArgoprojV1alpha1().Applications(s.ns)\n\ta, err := appIf.Get(ctx, *rollbackReq.Name, metav1.GetOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionSync, appRBACName(*a)); err != nil {\n\t\treturn nil, err\n\t}\n\tif a.DeletionTimestamp != nil {\n\t\treturn nil, status.Errorf(codes.FailedPrecondition, \"application is deleting\")\n\t}\n\tif a.Spec.SyncPolicy != nil && a.Spec.SyncPolicy.Automated != nil {\n\t\treturn nil, status.Errorf(codes.FailedPrecondition, \"rollback cannot be initiated when auto-sync is enabled\")\n\t}\n\n\tvar deploymentInfo *appv1.RevisionHistory\n\tfor _, info := range a.Status.History {\n\t\tif info.ID == rollbackReq.ID {\n\t\t\tdeploymentInfo = &info\n\t\t\tbreak\n\t\t}\n\t}\n\tif deploymentInfo == nil {\n\t\treturn nil, status.Errorf(codes.InvalidArgument, \"application %s does not have deployment with id %v\", a.Name, rollbackReq.ID)\n\t}\n\tif deploymentInfo.Source.IsZero() {\n\t\t// Since source type was introduced to history starting with v0.12, and is now required for\n\t\t// rollback, we cannot support rollback to revisions deployed using Argo CD v0.11 or below\n\t\treturn nil, status.Errorf(codes.FailedPrecondition, \"cannot rollback to revision deployed with Argo CD v0.11 or lower. sync to revision instead.\")\n\t}\n\n\tvar syncOptions appv1.SyncOptions\n\tif a.Spec.SyncPolicy != nil {\n\t\tsyncOptions = a.Spec.SyncPolicy.SyncOptions\n\t}\n\n\t// Rollback is just a convenience around Sync\n\top := appv1.Operation{\n\t\tSync: &appv1.SyncOperation{\n\t\t\tRevision:     deploymentInfo.Revision,\n\t\t\tDryRun:       rollbackReq.DryRun,\n\t\t\tPrune:        rollbackReq.Prune,\n\t\t\tSyncOptions:  syncOptions,\n\t\t\tSyncStrategy: &appv1.SyncStrategy{Apply: &appv1.SyncStrategyApply{}},\n\t\t\tSource:       &deploymentInfo.Source,\n\t\t},\n\t}\n\ta, err = argo.SetAppOperation(appIf, *rollbackReq.Name, &op)\n\tif err == nil {\n\t\ts.logAppEvent(a, ctx, argo.EventReasonOperationStarted, fmt.Sprintf(\"initiated rollback to %d\", rollbackReq.ID))\n\t}\n\treturn a, err\n}\n\n// resolveRevision resolves the revision specified either in the sync request, or the\n// application source, into a concrete revision that will be used for a sync operation.\nfunc (s *Server) resolveRevision(ctx context.Context, app *appv1.Application, syncReq *application.ApplicationSyncRequest) (string, string, error) {\n\tif syncReq.Manifests != nil {\n\t\treturn \"\", \"\", nil\n\t}\n\tambiguousRevision := syncReq.Revision\n\tif ambiguousRevision == \"\" {\n\t\tambiguousRevision = app.Spec.Source.TargetRevision\n\t}\n\trepo, err := s.db.GetRepository(ctx, app.Spec.Source.RepoURL)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tconn, repoClient, err := s.repoClientset.NewRepoServerClient()\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tdefer io.Close(conn)\n\n\tif !app.Spec.Source.IsHelm() {\n\t\tif git.IsCommitSHA(ambiguousRevision) {\n\t\t\t// If it's already a commit SHA, then no need to look it up\n\t\t\treturn ambiguousRevision, ambiguousRevision, nil\n\t\t}\n\t}\n\n\tresolveRevisionResponse, err := repoClient.ResolveRevision(ctx, &apiclient.ResolveRevisionRequest{\n\t\tRepo:              repo,\n\t\tApp:               app,\n\t\tAmbiguousRevision: ambiguousRevision,\n\t})\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\treturn resolveRevisionResponse.Revision, resolveRevisionResponse.AmbiguousRevision, nil\n}\n\nfunc (s *Server) TerminateOperation(ctx context.Context, termOpReq *application.OperationTerminateRequest) (*application.OperationTerminateResponse, error) {\n\ta, err := s.appclientset.ArgoprojV1alpha1().Applications(s.ns).Get(ctx, *termOpReq.Name, metav1.GetOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionSync, appRBACName(*a)); err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor i := 0; i < 10; i++ {\n\t\tif a.Operation == nil || a.Status.OperationState == nil {\n\t\t\treturn nil, status.Errorf(codes.InvalidArgument, \"Unable to terminate operation. No operation is in progress\")\n\t\t}\n\t\ta.Status.OperationState.Phase = common.OperationTerminating\n\t\tupdated, err := s.appclientset.ArgoprojV1alpha1().Applications(s.ns).Update(ctx, a, metav1.UpdateOptions{})\n\t\tif err == nil {\n\t\t\ts.waitSync(updated)\n\t\t\ts.logAppEvent(a, ctx, argo.EventReasonResourceUpdated, \"terminated running operation\")\n\t\t\treturn &application.OperationTerminateResponse{}, nil\n\t\t}\n\t\tif !apierr.IsConflict(err) {\n\t\t\treturn nil, err\n\t\t}\n\t\tlog.Warnf(\"Failed to set operation for app '%s' due to update conflict. Retrying again...\", *termOpReq.Name)\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\ta, err = s.appclientset.ArgoprojV1alpha1().Applications(s.ns).Get(ctx, *termOpReq.Name, metav1.GetOptions{})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn nil, status.Errorf(codes.Internal, \"Failed to terminate app. Too many conflicts\")\n}\n\nfunc (s *Server) logAppEvent(a *appv1.Application, ctx context.Context, reason string, action string) {\n\teventInfo := argo.EventInfo{Type: v1.EventTypeNormal, Reason: reason}\n\tuser := session.Username(ctx)\n\tif user == \"\" {\n\t\tuser = \"Unknown user\"\n\t}\n\tmessage := fmt.Sprintf(\"%s %s\", user, action)\n\ts.auditLogger.LogAppEvent(a, eventInfo, message)\n}\n\nfunc (s *Server) logResourceEvent(res *appv1.ResourceNode, ctx context.Context, reason string, action string) {\n\teventInfo := argo.EventInfo{Type: v1.EventTypeNormal, Reason: reason}\n\tuser := session.Username(ctx)\n\tif user == \"\" {\n\t\tuser = \"Unknown user\"\n\t}\n\tmessage := fmt.Sprintf(\"%s %s\", user, action)\n\ts.auditLogger.LogResourceEvent(res, eventInfo, message)\n}\n\nfunc (s *Server) ListResourceActions(ctx context.Context, q *application.ApplicationResourceRequest) (*application.ResourceActionsListResponse, error) {\n\tres, config, _, err := s.getAppResource(ctx, rbacpolicy.ActionGet, q)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tobj, err := s.kubectl.GetResource(ctx, config, res.GroupKindVersion(), res.Name, res.Namespace)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresourceOverrides, err := s.settingsMgr.GetResourceOverrides()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tavailableActions, err := s.getAvailableActions(resourceOverrides, obj)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &application.ResourceActionsListResponse{Actions: availableActions}, nil\n}\n\nfunc (s *Server) getAvailableActions(resourceOverrides map[string]appv1.ResourceOverride, obj *unstructured.Unstructured) ([]appv1.ResourceAction, error) {\n\tluaVM := lua.VM{\n\t\tResourceOverrides: resourceOverrides,\n\t}\n\n\tdiscoveryScript, err := luaVM.GetResourceActionDiscovery(obj)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif discoveryScript == \"\" {\n\t\treturn []appv1.ResourceAction{}, nil\n\t}\n\tavailableActions, err := luaVM.ExecuteResourceActionDiscovery(obj, discoveryScript)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn availableActions, nil\n\n}\n\nfunc (s *Server) RunResourceAction(ctx context.Context, q *application.ResourceActionRunRequest) (*application.ApplicationResponse, error) {\n\tresourceRequest := &application.ApplicationResourceRequest{\n\t\tName:         q.Name,\n\t\tNamespace:    q.Namespace,\n\t\tResourceName: q.ResourceName,\n\t\tKind:         q.Kind,\n\t\tVersion:      q.Version,\n\t\tGroup:        q.Group,\n\t}\n\tactionRequest := fmt.Sprintf(\"%s/%s/%s/%s\", rbacpolicy.ActionAction, q.Group, q.Kind, q.Action)\n\tres, config, a, err := s.getAppResource(ctx, actionRequest, resourceRequest)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tliveObj, err := s.kubectl.GetResource(ctx, config, res.GroupKindVersion(), res.Name, res.Namespace)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresourceOverrides, err := s.settingsMgr.GetResourceOverrides()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tluaVM := lua.VM{\n\t\tResourceOverrides: resourceOverrides,\n\t}\n\taction, err := luaVM.GetResourceAction(liveObj, q.Action)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tnewObj, err := luaVM.ExecuteResourceAction(liveObj, action.ActionLua)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tnewObjBytes, err := json.Marshal(newObj)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tliveObjBytes, err := json.Marshal(liveObj)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdiffBytes, err := jsonpatch.CreateMergePatch(liveObjBytes, newObjBytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif string(diffBytes) == \"{}\" {\n\t\treturn &application.ApplicationResponse{}, nil\n\t}\n\n\t// The following logic detects if the resource action makes a modification to status and/or spec.\n\t// If status was modified, we attempt to patch the status using status subresource, in case the\n\t// CRD is configured using the status subresource feature. See:\n\t// https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#status-subresource\n\t// If status subresource is in use, the patch has to be split into two:\n\t// * one to update spec (and other non-status fields)\n\t// * the other to update only status.\n\tnonStatusPatch, statusPatch, err := splitStatusPatch(diffBytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif statusPatch != nil {\n\t\t_, err = s.kubectl.PatchResource(ctx, config, newObj.GroupVersionKind(), newObj.GetName(), newObj.GetNamespace(), types.MergePatchType, diffBytes, \"status\")\n\t\tif err != nil {\n\t\t\tif !apierr.IsNotFound(err) {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\t// K8s API server returns 404 NotFound when the CRD does not support the status subresource\n\t\t\t// if we get here, the CRD does not use the status subresource. We will fall back to a normal patch\n\t\t} else {\n\t\t\t// If we get here, the CRD does use the status subresource, so we must patch status and\n\t\t\t// spec separately. update the diffBytes to the spec-only patch and fall through.\n\t\t\tdiffBytes = nonStatusPatch\n\t\t}\n\t}\n\tif diffBytes != nil {\n\t\t_, err = s.kubectl.PatchResource(ctx, config, newObj.GroupVersionKind(), newObj.GetName(), newObj.GetNamespace(), types.MergePatchType, diffBytes)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\ts.logAppEvent(a, ctx, argo.EventReasonResourceActionRan, fmt.Sprintf(\"ran action %s on resource %s/%s/%s\", q.Action, res.Group, res.Kind, res.Name))\n\ts.logResourceEvent(res, ctx, argo.EventReasonResourceActionRan, fmt.Sprintf(\"ran action %s\", q.Action))\n\treturn &application.ApplicationResponse{}, nil\n}\n\n// splitStatusPatch splits a patch into two: one for a non-status patch, and the status-only patch.\n// Returns nil for either if the patch doesn't have modifications to non-status, or status, respectively.\nfunc splitStatusPatch(patch []byte) ([]byte, []byte, error) {\n\tvar obj map[string]interface{}\n\terr := json.Unmarshal(patch, &obj)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tvar nonStatusPatch, statusPatch []byte\n\tif statusVal, ok := obj[\"status\"]; ok {\n\t\t// calculate the status-only patch\n\t\tstatusObj := map[string]interface{}{\n\t\t\t\"status\": statusVal,\n\t\t}\n\t\tstatusPatch, err = json.Marshal(statusObj)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\t// remove status, and calculate the non-status patch\n\t\tdelete(obj, \"status\")\n\t\tif len(obj) > 0 {\n\t\t\tnonStatusPatch, err = json.Marshal(obj)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// status was not modified in patch\n\t\tnonStatusPatch = patch\n\t}\n\treturn nonStatusPatch, statusPatch, nil\n}\n\nfunc (s *Server) plugins() ([]*v1alpha1.ConfigManagementPlugin, error) {\n\tplugins, err := s.settingsMgr.GetConfigManagementPlugins()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttools := make([]*v1alpha1.ConfigManagementPlugin, len(plugins))\n\tfor i, p := range plugins {\n\t\tp := p\n\t\ttools[i] = &p\n\t}\n\treturn tools, nil\n}\n\nfunc (s *Server) GetApplicationSyncWindows(ctx context.Context, q *application.ApplicationSyncWindowsQuery) (*application.ApplicationSyncWindowsResponse, error) {\n\tappIf := s.appclientset.ArgoprojV1alpha1().Applications(s.ns)\n\ta, err := appIf.Get(ctx, *q.Name, metav1.GetOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionGet, appRBACName(*a)); err != nil {\n\t\treturn nil, err\n\t}\n\n\tproj, err := argo.GetAppProject(&a.Spec, applisters.NewAppProjectLister(s.projInformer.GetIndexer()), a.Namespace, s.settingsMgr, s.db, ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\twindows := proj.Spec.SyncWindows.Matches(a)\n\tsync := windows.CanSync(true)\n\n\tres := &application.ApplicationSyncWindowsResponse{\n\t\tActiveWindows:   convertSyncWindows(windows.Active()),\n\t\tAssignedWindows: convertSyncWindows(windows),\n\t\tCanSync:         &sync,\n\t}\n\n\treturn res, nil\n}\n\nfunc convertSyncWindows(w *v1alpha1.SyncWindows) []*application.ApplicationSyncWindow {\n\tif w != nil {\n\t\tvar windows []*application.ApplicationSyncWindow\n\t\tfor _, w := range *w {\n\t\t\tnw := &application.ApplicationSyncWindow{\n\t\t\t\tKind:       &w.Kind,\n\t\t\t\tSchedule:   &w.Schedule,\n\t\t\t\tDuration:   &w.Duration,\n\t\t\t\tManualSync: &w.ManualSync,\n\t\t\t}\n\t\t\twindows = append(windows, nw)\n\t\t}\n\t\tif len(windows) > 0 {\n\t\t\treturn windows\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc getPropagationPolicyFinalizer(policy string) string {\n\tswitch strings.ToLower(policy) {\n\tcase backgroundPropagationPolicy:\n\t\treturn appv1.BackgroundPropagationPolicyFinalizer\n\tcase foregroundPropagationPolicy:\n\t\treturn appv1.ForegroundPropagationPolicyFinalizer\n\tcase \"\":\n\t\treturn appv1.ResourcesFinalizerName\n\tdefault:\n\t\treturn \"\"\n\t}\n}\n", "package e2e\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"os\"\n\t\"path\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/argoproj/gitops-engine/pkg/diff\"\n\t\"github.com/argoproj/gitops-engine/pkg/health\"\n\t. \"github.com/argoproj/gitops-engine/pkg/sync/common\"\n\t\"github.com/argoproj/gitops-engine/pkg/utils/kube\"\n\t\"github.com/argoproj/pkg/errors\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\tv1 \"k8s.io/api/core/v1\"\n\tnetworkingv1 \"k8s.io/api/networking/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\n\t\"k8s.io/apimachinery/pkg/runtime/schema\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\t\"k8s.io/apimachinery/pkg/util/intstr\"\n\t\"k8s.io/utils/pointer\"\n\n\t\"github.com/argoproj/argo-cd/v2/common\"\n\tapplicationpkg \"github.com/argoproj/argo-cd/v2/pkg/apiclient/application\"\n\t. \"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1\"\n\t\"github.com/argoproj/argo-cd/v2/test/e2e/fixture\"\n\t. \"github.com/argoproj/argo-cd/v2/test/e2e/fixture\"\n\taccountFixture \"github.com/argoproj/argo-cd/v2/test/e2e/fixture/account\"\n\t. \"github.com/argoproj/argo-cd/v2/test/e2e/fixture/app\"\n\tprojectFixture \"github.com/argoproj/argo-cd/v2/test/e2e/fixture/project\"\n\trepoFixture \"github.com/argoproj/argo-cd/v2/test/e2e/fixture/repos\"\n\t\"github.com/argoproj/argo-cd/v2/test/e2e/testdata\"\n\t. \"github.com/argoproj/argo-cd/v2/util/argo\"\n\t. \"github.com/argoproj/argo-cd/v2/util/errors\"\n\t\"github.com/argoproj/argo-cd/v2/util/io\"\n\t\"github.com/argoproj/argo-cd/v2/util/settings\"\n)\n\nconst (\n\tguestbookPath          = \"guestbook\"\n\tguestbookPathLocal     = \"./testdata/guestbook_local\"\n\tglobalWithNoNameSpace  = \"global-with-no-namespace\"\n\tguestbookWithNamespace = \"guestbook-with-namespace\"\n)\n\n// This empty test is here only for clarity, to conform to logs rbac tests structure in account. This exact usecase is covered in the TestAppLogs test\nfunc TestGetLogsAllowNoSwitch(t *testing.T) {\n}\n\n// There is some code duplication in the below GetLogs tests, the reason for that is to allow getting rid of most of those tests easily in the next release,\n// when the temporary switch would die\nfunc TestGetLogsDenySwitchOn(t *testing.T) {\n\tSkipOnEnv(t, \"OPENSHIFT\")\n\n\taccountFixture.Given(t).\n\t\tName(\"test\").\n\t\tWhen().\n\t\tCreate().\n\t\tLogin().\n\t\tSetPermissions([]fixture.ACL{\n\t\t\t{\n\t\t\t\tResource: \"applications\",\n\t\t\t\tAction:   \"create\",\n\t\t\t\tScope:    \"*\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tResource: \"applications\",\n\t\t\t\tAction:   \"get\",\n\t\t\t\tScope:    \"*\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tResource: \"applications\",\n\t\t\t\tAction:   \"sync\",\n\t\t\t\tScope:    \"*\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tResource: \"projects\",\n\t\t\t\tAction:   \"get\",\n\t\t\t\tScope:    \"*\",\n\t\t\t},\n\t\t}, \"app-creator\")\n\n\tGivenWithSameState(t).\n\t\tPath(\"guestbook-logs\").\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tSetParamInSettingConfigMap(\"server.rbac.log.enforce.enable\", \"true\").\n\t\tThen().\n\t\tExpect(HealthIs(health.HealthStatusHealthy)).\n\t\tAnd(func(app *Application) {\n\t\t\t_, err := RunCli(\"app\", \"logs\", app.Name, \"--kind\", \"Deployment\", \"--group\", \"\", \"--name\", \"guestbook-ui\")\n\t\t\tassert.Error(t, err)\n\t\t\tassert.Contains(t, err.Error(), \"permission denied\")\n\t\t})\n}\n\nfunc TestGetLogsAllowSwitchOn(t *testing.T) {\n\tSkipOnEnv(t, \"OPENSHIFT\")\n\n\taccountFixture.Given(t).\n\t\tName(\"test\").\n\t\tWhen().\n\t\tCreate().\n\t\tLogin().\n\t\tSetPermissions([]fixture.ACL{\n\t\t\t{\n\t\t\t\tResource: \"applications\",\n\t\t\t\tAction:   \"create\",\n\t\t\t\tScope:    \"*\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tResource: \"applications\",\n\t\t\t\tAction:   \"get\",\n\t\t\t\tScope:    \"*\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tResource: \"applications\",\n\t\t\t\tAction:   \"sync\",\n\t\t\t\tScope:    \"*\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tResource: \"projects\",\n\t\t\t\tAction:   \"get\",\n\t\t\t\tScope:    \"*\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tResource: \"logs\",\n\t\t\t\tAction:   \"get\",\n\t\t\t\tScope:    \"*\",\n\t\t\t},\n\t\t}, \"app-creator\")\n\n\tGivenWithSameState(t).\n\t\tPath(\"guestbook-logs\").\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tSetParamInSettingConfigMap(\"server.rbac.log.enforce.enable\", \"true\").\n\t\tThen().\n\t\tExpect(HealthIs(health.HealthStatusHealthy)).\n\t\tAnd(func(app *Application) {\n\t\t\tout, err := RunCli(\"app\", \"logs\", app.Name, \"--kind\", \"Deployment\", \"--group\", \"\", \"--name\", \"guestbook-ui\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, out, \"Hi\")\n\t\t}).\n\t\tAnd(func(app *Application) {\n\t\t\tout, err := RunCli(\"app\", \"logs\", app.Name, \"--kind\", \"Pod\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, out, \"Hi\")\n\t\t}).\n\t\tAnd(func(app *Application) {\n\t\t\tout, err := RunCli(\"app\", \"logs\", app.Name, \"--kind\", \"Service\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.NotContains(t, out, \"Hi\")\n\t\t})\n\n}\n\nfunc TestGetLogsAllowSwitchOff(t *testing.T) {\n\tSkipOnEnv(t, \"OPENSHIFT\")\n\n\taccountFixture.Given(t).\n\t\tName(\"test\").\n\t\tWhen().\n\t\tCreate().\n\t\tLogin().\n\t\tSetPermissions([]fixture.ACL{\n\t\t\t{\n\t\t\t\tResource: \"applications\",\n\t\t\t\tAction:   \"create\",\n\t\t\t\tScope:    \"*\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tResource: \"applications\",\n\t\t\t\tAction:   \"get\",\n\t\t\t\tScope:    \"*\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tResource: \"applications\",\n\t\t\t\tAction:   \"sync\",\n\t\t\t\tScope:    \"*\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tResource: \"projects\",\n\t\t\t\tAction:   \"get\",\n\t\t\t\tScope:    \"*\",\n\t\t\t},\n\t\t}, \"app-creator\")\n\n\tGiven(t).\n\t\tPath(\"guestbook-logs\").\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tSetParamInSettingConfigMap(\"server.rbac.log.enforce.enable\", \"false\").\n\t\tThen().\n\t\tExpect(HealthIs(health.HealthStatusHealthy)).\n\t\tAnd(func(app *Application) {\n\t\t\tout, err := RunCli(\"app\", \"logs\", app.Name, \"--kind\", \"Deployment\", \"--group\", \"\", \"--name\", \"guestbook-ui\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, out, \"Hi\")\n\t\t}).\n\t\tAnd(func(app *Application) {\n\t\t\tout, err := RunCli(\"app\", \"logs\", app.Name, \"--kind\", \"Pod\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, out, \"Hi\")\n\t\t}).\n\t\tAnd(func(app *Application) {\n\t\t\tout, err := RunCli(\"app\", \"logs\", app.Name, \"--kind\", \"Service\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.NotContains(t, out, \"Hi\")\n\t\t})\n}\n\nfunc TestSyncToUnsignedCommit(t *testing.T) {\n\tSkipOnEnv(t, \"GPG\")\n\tGiven(t).\n\t\tProject(\"gpg\").\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tIgnoreErrors().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationError)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tExpect(HealthIs(health.HealthStatusMissing))\n}\n\nfunc TestSyncToSignedCommitWithoutKnownKey(t *testing.T) {\n\tSkipOnEnv(t, \"GPG\")\n\tGiven(t).\n\t\tProject(\"gpg\").\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tAddSignedFile(\"test.yaml\", \"null\").\n\t\tIgnoreErrors().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationError)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tExpect(HealthIs(health.HealthStatusMissing))\n}\n\nfunc TestSyncToSignedCommitKeyWithKnownKey(t *testing.T) {\n\tSkipOnEnv(t, \"GPG\")\n\tGiven(t).\n\t\tProject(\"gpg\").\n\t\tPath(guestbookPath).\n\t\tGPGPublicKeyAdded().\n\t\tSleep(2).\n\t\tWhen().\n\t\tAddSignedFile(\"test.yaml\", \"null\").\n\t\tIgnoreErrors().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tExpect(HealthIs(health.HealthStatusHealthy))\n}\n\nfunc TestAppCreation(t *testing.T) {\n\tctx := Given(t)\n\n\tctx.\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Equal(t, Name(), app.Name)\n\t\t\tassert.Equal(t, RepoURL(RepoURLTypeFile), app.Spec.Source.RepoURL)\n\t\t\tassert.Equal(t, guestbookPath, app.Spec.Source.Path)\n\t\t\tassert.Equal(t, DeploymentNamespace(), app.Spec.Destination.Namespace)\n\t\t\tassert.Equal(t, KubernetesInternalAPIServerAddr, app.Spec.Destination.Server)\n\t\t}).\n\t\tExpect(Event(EventReasonResourceCreated, \"create\")).\n\t\tAnd(func(_ *Application) {\n\t\t\t// app should be listed\n\t\t\toutput, err := RunCli(\"app\", \"list\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, output, Name())\n\t\t}).\n\t\tWhen().\n\t\t// ensure that create is idempotent\n\t\tCreateApp().\n\t\tThen().\n\t\tGiven().\n\t\tRevision(\"master\").\n\t\tWhen().\n\t\t// ensure that update replaces spec and merge labels and annotations\n\t\tAnd(func() {\n\t\t\tFailOnErr(AppClientset.ArgoprojV1alpha1().Applications(ArgoCDNamespace).Patch(context.Background(),\n\t\t\t\tctx.GetName(), types.MergePatchType, []byte(`{\"metadata\": {\"labels\": { \"test\": \"label\" }, \"annotations\": { \"test\": \"annotation\" }}}`), metav1.PatchOptions{}))\n\t\t}).\n\t\tCreateApp(\"--upsert\").\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Equal(t, \"label\", app.Labels[\"test\"])\n\t\t\tassert.Equal(t, \"annotation\", app.Annotations[\"test\"])\n\t\t\tassert.Equal(t, \"master\", app.Spec.Source.TargetRevision)\n\t\t})\n}\n\nfunc TestAppCreationWithoutForceUpdate(t *testing.T) {\n\tctx := Given(t)\n\n\tctx.\n\t\tPath(guestbookPath).\n\t\tDestName(\"in-cluster\").\n\t\tWhen().\n\t\tCreateApp().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Equal(t, Name(), app.Name)\n\t\t\tassert.Equal(t, RepoURL(RepoURLTypeFile), app.Spec.Source.RepoURL)\n\t\t\tassert.Equal(t, guestbookPath, app.Spec.Source.Path)\n\t\t\tassert.Equal(t, DeploymentNamespace(), app.Spec.Destination.Namespace)\n\t\t\tassert.Equal(t, \"in-cluster\", app.Spec.Destination.Name)\n\t\t}).\n\t\tExpect(Event(EventReasonResourceCreated, \"create\")).\n\t\tAnd(func(_ *Application) {\n\t\t\t// app should be listed\n\t\t\toutput, err := RunCli(\"app\", \"list\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, output, Name())\n\t\t}).\n\t\tWhen().\n\t\tIgnoreErrors().\n\t\tCreateApp().\n\t\tThen().\n\t\tExpect(Error(\"\", \"existing application spec is different, use upsert flag to force update\"))\n}\n\nfunc TestDeleteAppResource(t *testing.T) {\n\tctx := Given(t)\n\n\tctx.\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(_ *Application) {\n\t\t\t// app should be listed\n\t\t\tif _, err := RunCli(\"app\", \"delete-resource\", Name(), \"--kind\", \"Service\", \"--resource-name\", \"guestbook-ui\"); err != nil {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t}).\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tExpect(HealthIs(health.HealthStatusMissing))\n}\n\n// demonstrate that we cannot use a standard sync when an immutable field is changed, we must use \"force\"\nfunc TestImmutableChange(t *testing.T) {\n\tSkipOnEnv(t, \"OPENSHIFT\")\n\ttext := FailOnErr(Run(\".\", \"kubectl\", \"get\", \"service\", \"-n\", \"kube-system\", \"kube-dns\", \"-o\", \"jsonpath={.spec.clusterIP}\")).(string)\n\tparts := strings.Split(text, \".\")\n\tn := rand.Intn(254)\n\tip1 := fmt.Sprintf(\"%s.%s.%s.%d\", parts[0], parts[1], parts[2], n)\n\tip2 := fmt.Sprintf(\"%s.%s.%s.%d\", parts[0], parts[1], parts[2], n+1)\n\tGiven(t).\n\t\tPath(\"service\").\n\t\tWhen().\n\t\tCreateApp().\n\t\tPatchFile(\"service.yaml\", fmt.Sprintf(`[{\"op\": \"add\", \"path\": \"/spec/clusterIP\", \"value\": \"%s\"}]`, ip1)).\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tExpect(HealthIs(health.HealthStatusHealthy)).\n\t\tWhen().\n\t\tPatchFile(\"service.yaml\", fmt.Sprintf(`[{\"op\": \"add\", \"path\": \"/spec/clusterIP\", \"value\": \"%s\"}]`, ip2)).\n\t\tIgnoreErrors().\n\t\tSync().\n\t\tDoNotIgnoreErrors().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationFailed)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tExpect(ResourceResultNumbering(1)).\n\t\tExpect(ResourceResultMatches(ResourceResult{\n\t\t\tKind:      \"Service\",\n\t\t\tVersion:   \"v1\",\n\t\t\tNamespace: DeploymentNamespace(),\n\t\t\tName:      \"my-service\",\n\t\t\tSyncPhase: \"Sync\",\n\t\t\tStatus:    \"SyncFailed\",\n\t\t\tHookPhase: \"Failed\",\n\t\t\tMessage:   `Service \"my-service\" is invalid`,\n\t\t})).\n\t\t// now we can do this will a force\n\t\tGiven().\n\t\tForce().\n\t\tWhen().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tExpect(HealthIs(health.HealthStatusHealthy))\n}\n\nfunc TestInvalidAppProject(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tProject(\"does-not-exist\").\n\t\tWhen().\n\t\tIgnoreErrors().\n\t\tCreateApp().\n\t\tThen().\n\t\tExpect(Error(\"\", \"application references project does-not-exist which does not exist\"))\n}\n\nfunc TestAppDeletion(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tWhen().\n\t\tDelete(true).\n\t\tThen().\n\t\tExpect(DoesNotExist()).\n\t\tExpect(Event(EventReasonResourceDeleted, \"delete\"))\n\n\toutput, err := RunCli(\"app\", \"list\")\n\tassert.NoError(t, err)\n\tassert.NotContains(t, output, Name())\n}\n\nfunc TestAppLabels(t *testing.T) {\n\tGiven(t).\n\t\tPath(\"config-map\").\n\t\tWhen().\n\t\tCreateApp(\"-l\", \"foo=bar\").\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Contains(t, FailOnErr(RunCli(\"app\", \"list\")), Name())\n\t\t\tassert.Contains(t, FailOnErr(RunCli(\"app\", \"list\", \"-l\", \"foo=bar\")), Name())\n\t\t\tassert.NotContains(t, FailOnErr(RunCli(\"app\", \"list\", \"-l\", \"foo=rubbish\")), Name())\n\t\t}).\n\t\tGiven().\n\t\t// remove both name and replace labels means nothing will sync\n\t\tName(\"\").\n\t\tWhen().\n\t\tIgnoreErrors().\n\t\tSync(\"-l\", \"foo=rubbish\").\n\t\tDoNotIgnoreErrors().\n\t\tThen().\n\t\tExpect(Error(\"\", \"no apps match selector foo=rubbish\")).\n\t\t// check we can update the app and it is then sync'd\n\t\tGiven().\n\t\tWhen().\n\t\tSync(\"-l\", \"foo=bar\")\n}\n\nfunc TestTrackAppStateAndSyncApp(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tExpect(HealthIs(health.HealthStatusHealthy)).\n\t\tExpect(Success(fmt.Sprintf(\"Service     %s  guestbook-ui  Synced \", DeploymentNamespace()))).\n\t\tExpect(Success(fmt.Sprintf(\"apps   Deployment  %s  guestbook-ui  Synced\", DeploymentNamespace()))).\n\t\tExpect(Event(EventReasonResourceUpdated, \"sync\")).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.NotNil(t, app.Status.OperationState.SyncResult)\n\t\t})\n}\n\nfunc TestAppRollbackSuccessful(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.NotEmpty(t, app.Status.Sync.Revision)\n\t\t}).\n\t\tAnd(func(app *Application) {\n\t\t\tappWithHistory := app.DeepCopy()\n\t\t\tappWithHistory.Status.History = []RevisionHistory{{\n\t\t\t\tID:         1,\n\t\t\t\tRevision:   app.Status.Sync.Revision,\n\t\t\t\tDeployedAt: metav1.Time{Time: metav1.Now().UTC().Add(-1 * time.Minute)},\n\t\t\t\tSource:     app.Spec.Source,\n\t\t\t}, {\n\t\t\t\tID:         2,\n\t\t\t\tRevision:   \"cdb\",\n\t\t\t\tDeployedAt: metav1.Time{Time: metav1.Now().UTC().Add(-2 * time.Minute)},\n\t\t\t\tSource:     app.Spec.Source,\n\t\t\t}}\n\t\t\tpatch, _, err := diff.CreateTwoWayMergePatch(app, appWithHistory, &Application{})\n\t\t\tassert.NoError(t, err)\n\n\t\t\tapp, err = AppClientset.ArgoprojV1alpha1().Applications(ArgoCDNamespace).Patch(context.Background(), app.Name, types.MergePatchType, patch, metav1.PatchOptions{})\n\t\t\tassert.NoError(t, err)\n\n\t\t\t// sync app and make sure it reaches InSync state\n\t\t\t_, err = RunCli(\"app\", \"rollback\", app.Name, \"1\")\n\t\t\tassert.NoError(t, err)\n\n\t\t}).\n\t\tExpect(Event(EventReasonOperationStarted, \"rollback\")).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Equal(t, SyncStatusCodeSynced, app.Status.Sync.Status)\n\t\t\tassert.NotNil(t, app.Status.OperationState.SyncResult)\n\t\t\tassert.Equal(t, 2, len(app.Status.OperationState.SyncResult.Resources))\n\t\t\tassert.Equal(t, OperationSucceeded, app.Status.OperationState.Phase)\n\t\t\tassert.Equal(t, 3, len(app.Status.History))\n\t\t})\n}\n\nfunc TestComparisonFailsIfClusterNotAdded(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tDestServer(\"https://not-registered-cluster/api\").\n\t\tWhen().\n\t\tIgnoreErrors().\n\t\tCreateApp().\n\t\tThen().\n\t\tExpect(DoesNotExist())\n}\n\nfunc TestCannotSetInvalidPath(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tIgnoreErrors().\n\t\tAppSet(\"--path\", \"garbage\").\n\t\tThen().\n\t\tExpect(Error(\"\", \"app path does not exist\"))\n}\n\nfunc TestManipulateApplicationResources(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tmanifests, err := RunCli(\"app\", \"manifests\", app.Name, \"--source\", \"live\")\n\t\t\tassert.NoError(t, err)\n\t\t\tresources, err := kube.SplitYAML([]byte(manifests))\n\t\t\tassert.NoError(t, err)\n\n\t\t\tindex := -1\n\t\t\tfor i := range resources {\n\t\t\t\tif resources[i].GetKind() == kube.DeploymentKind {\n\t\t\t\t\tindex = i\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert.True(t, index > -1)\n\n\t\t\tdeployment := resources[index]\n\n\t\t\tcloser, client, err := ArgoCDClientset.NewApplicationClient()\n\t\t\tassert.NoError(t, err)\n\t\t\tdefer io.Close(closer)\n\n\t\t\t_, err = client.DeleteResource(context.Background(), &applicationpkg.ApplicationResourceDeleteRequest{\n\t\t\t\tName:         &app.Name,\n\t\t\t\tGroup:        deployment.GroupVersionKind().Group,\n\t\t\t\tKind:         deployment.GroupVersionKind().Kind,\n\t\t\t\tVersion:      deployment.GroupVersionKind().Version,\n\t\t\t\tNamespace:    deployment.GetNamespace(),\n\t\t\t\tResourceName: deployment.GetName(),\n\t\t\t})\n\t\t\tassert.NoError(t, err)\n\t\t}).\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync))\n}\n\nfunc assetSecretDataHidden(t *testing.T, manifest string) {\n\tsecret, err := UnmarshalToUnstructured(manifest)\n\tassert.NoError(t, err)\n\n\t_, hasStringData, err := unstructured.NestedMap(secret.Object, \"stringData\")\n\tassert.NoError(t, err)\n\tassert.False(t, hasStringData)\n\n\tsecretData, hasData, err := unstructured.NestedMap(secret.Object, \"data\")\n\tassert.NoError(t, err)\n\tassert.True(t, hasData)\n\tfor _, v := range secretData {\n\t\tassert.Regexp(t, regexp.MustCompile(`[*]*`), v)\n\t}\n\tvar lastAppliedConfigAnnotation string\n\tannotations := secret.GetAnnotations()\n\tif annotations != nil {\n\t\tlastAppliedConfigAnnotation = annotations[v1.LastAppliedConfigAnnotation]\n\t}\n\tif lastAppliedConfigAnnotation != \"\" {\n\t\tassetSecretDataHidden(t, lastAppliedConfigAnnotation)\n\t}\n}\n\nfunc TestAppWithSecrets(t *testing.T) {\n\tcloser, client, err := ArgoCDClientset.NewApplicationClient()\n\tassert.NoError(t, err)\n\tdefer io.Close(closer)\n\n\tGiven(t).\n\t\tPath(\"secrets\").\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tres := FailOnErr(client.GetResource(context.Background(), &applicationpkg.ApplicationResourceRequest{\n\t\t\t\tNamespace:    app.Spec.Destination.Namespace,\n\t\t\t\tKind:         kube.SecretKind,\n\t\t\t\tGroup:        \"\",\n\t\t\t\tName:         &app.Name,\n\t\t\t\tVersion:      \"v1\",\n\t\t\t\tResourceName: \"test-secret\",\n\t\t\t})).(*applicationpkg.ApplicationResourceResponse)\n\t\t\tassetSecretDataHidden(t, res.Manifest)\n\n\t\t\tmanifests, err := client.GetManifests(context.Background(), &applicationpkg.ApplicationManifestQuery{Name: &app.Name})\n\t\t\terrors.CheckError(err)\n\n\t\t\tfor _, manifest := range manifests.Manifests {\n\t\t\t\tassetSecretDataHidden(t, manifest)\n\t\t\t}\n\n\t\t\tdiffOutput := FailOnErr(RunCli(\"app\", \"diff\", app.Name)).(string)\n\t\t\tassert.Empty(t, diffOutput)\n\n\t\t\t// make sure resource update error does not print secret details\n\t\t\t_, err = RunCli(\"app\", \"patch-resource\", \"test-app-with-secrets\", \"--resource-name\", \"test-secret\",\n\t\t\t\t\"--kind\", \"Secret\", \"--patch\", `{\"op\": \"add\", \"path\": \"/data\", \"value\": \"hello\"}'`,\n\t\t\t\t\"--patch-type\", \"application/json-patch+json\")\n\t\t\trequire.Error(t, err)\n\t\t\tassert.Contains(t, err.Error(), fmt.Sprintf(\"failed to patch Secret %s/test-secret\", DeploymentNamespace()))\n\t\t\tassert.NotContains(t, err.Error(), \"username\")\n\t\t\tassert.NotContains(t, err.Error(), \"password\")\n\n\t\t\t// patch secret and make sure app is out of sync and diff detects the change\n\t\t\tFailOnErr(KubeClientset.CoreV1().Secrets(DeploymentNamespace()).Patch(context.Background(),\n\t\t\t\t\"test-secret\", types.JSONPatchType, []byte(`[\n\t{\"op\": \"remove\", \"path\": \"/data/username\"},\n\t{\"op\": \"add\", \"path\": \"/stringData\", \"value\": {\"password\": \"foo\"}}\n]`), metav1.PatchOptions{}))\n\t\t}).\n\t\tWhen().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tAnd(func(app *Application) {\n\t\t\tdiffOutput, err := RunCli(\"app\", \"diff\", app.Name)\n\t\t\tassert.Error(t, err)\n\t\t\tassert.Contains(t, diffOutput, \"username: ++++++++\")\n\t\t\tassert.Contains(t, diffOutput, \"password: ++++++++++++\")\n\n\t\t\t// local diff should ignore secrets\n\t\t\tdiffOutput = FailOnErr(RunCli(\"app\", \"diff\", app.Name, \"--local\", \"testdata/secrets\")).(string)\n\t\t\tassert.Empty(t, diffOutput)\n\n\t\t\t// ignore missing field and make sure diff shows no difference\n\t\t\tapp.Spec.IgnoreDifferences = []ResourceIgnoreDifferences{{\n\t\t\t\tKind: kube.SecretKind, JSONPointers: []string{\"/data\"},\n\t\t\t}}\n\t\t\tFailOnErr(client.UpdateSpec(context.Background(), &applicationpkg.ApplicationUpdateSpecRequest{Name: &app.Name, Spec: app.Spec}))\n\t\t}).\n\t\tWhen().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tdiffOutput := FailOnErr(RunCli(\"app\", \"diff\", app.Name)).(string)\n\t\t\tassert.Empty(t, diffOutput)\n\t\t}).\n\t\t// verify not committed secret also ignore during diffing\n\t\tWhen().\n\t\tWriteFile(\"secret3.yaml\", `\napiVersion: v1\nkind: Secret\nmetadata:\n  name: test-secret3\nstringData:\n  username: test-username`).\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\tdiffOutput := FailOnErr(RunCli(\"app\", \"diff\", app.Name, \"--local\", \"testdata/secrets\")).(string)\n\t\t\tassert.Empty(t, diffOutput)\n\t\t})\n}\n\nfunc TestResourceDiffing(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\t// Patch deployment\n\t\t\t_, err := KubeClientset.AppsV1().Deployments(DeploymentNamespace()).Patch(context.Background(),\n\t\t\t\t\"guestbook-ui\", types.JSONPatchType, []byte(`[{ \"op\": \"replace\", \"path\": \"/spec/template/spec/containers/0/image\", \"value\": \"test\" }]`), metav1.PatchOptions{})\n\t\t\tassert.NoError(t, err)\n\t\t}).\n\t\tWhen().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tAnd(func(app *Application) {\n\t\t\tdiffOutput, err := RunCli(\"app\", \"diff\", app.Name, \"--local\", \"testdata/guestbook\")\n\t\t\tassert.Error(t, err)\n\t\t\tassert.Contains(t, diffOutput, fmt.Sprintf(\"===== apps/Deployment %s/guestbook-ui ======\", DeploymentNamespace()))\n\t\t}).\n\t\tGiven().\n\t\tResourceOverrides(map[string]ResourceOverride{\"apps/Deployment\": {\n\t\t\tIgnoreDifferences: OverrideIgnoreDiff{JSONPointers: []string{\"/spec/template/spec/containers/0/image\"}},\n\t\t}}).\n\t\tWhen().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tdiffOutput, err := RunCli(\"app\", \"diff\", app.Name, \"--local\", \"testdata/guestbook\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Empty(t, diffOutput)\n\t\t}).\n\t\tGiven().\n\t\tWhen().\n\t\tAnd(func() {\n\t\t\toutput, err := RunWithStdin(testdata.SSARevisionHistoryDeployment, \"\", \"kubectl\", \"apply\", \"-n\", DeploymentNamespace(), \"--server-side=true\", \"--field-manager=revision-history-manager\", \"--validate=false\", \"--force-conflicts\", \"-f\", \"-\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, output, \"serverside-applied\")\n\t\t}).\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tGiven().\n\t\tResourceOverrides(map[string]ResourceOverride{\"apps/Deployment\": {\n\t\t\tIgnoreDifferences: OverrideIgnoreDiff{\n\t\t\t\tManagedFieldsManagers: []string{\"revision-history-manager\"},\n\t\t\t\tJSONPointers:          []string{\"/spec/template/spec/containers/0/image\"},\n\t\t\t},\n\t\t}}).\n\t\tWhen().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tGiven().\n\t\tWhen().\n\t\tSync().\n\t\tPatchApp(`[{\n\t\t\t\"op\": \"add\",\n\t\t\t\"path\": \"/spec/syncPolicy\",\n\t\t\t\"value\": { \"syncOptions\": [\"RespectIgnoreDifferences=true\"] }\n\t\t\t}]`).\n\t\tAnd(func() {\n\t\t\tdeployment, err := KubeClientset.AppsV1().Deployments(DeploymentNamespace()).Get(context.Background(), \"guestbook-ui\", metav1.GetOptions{})\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, int32(3), *deployment.Spec.RevisionHistoryLimit)\n\t\t}).\n\t\tAnd(func() {\n\t\t\toutput, err := RunWithStdin(testdata.SSARevisionHistoryDeployment, \"\", \"kubectl\", \"apply\", \"-n\", DeploymentNamespace(), \"--server-side=true\", \"--field-manager=revision-history-manager\", \"--validate=false\", \"--force-conflicts\", \"-f\", \"-\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, output, \"serverside-applied\")\n\t\t}).\n\t\tThen().\n\t\tWhen().Refresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tdeployment, err := KubeClientset.AppsV1().Deployments(DeploymentNamespace()).Get(context.Background(), \"guestbook-ui\", metav1.GetOptions{})\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, int32(1), *deployment.Spec.RevisionHistoryLimit)\n\t\t}).\n\t\tWhen().Sync().Then().Expect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tdeployment, err := KubeClientset.AppsV1().Deployments(DeploymentNamespace()).Get(context.Background(), \"guestbook-ui\", metav1.GetOptions{})\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, int32(1), *deployment.Spec.RevisionHistoryLimit)\n\t\t})\n}\n\nfunc TestCRDs(t *testing.T) {\n\ttestEdgeCasesApplicationResources(t, \"crd-creation\", health.HealthStatusHealthy)\n}\n\nfunc TestKnownTypesInCRDDiffing(t *testing.T) {\n\tdummiesGVR := schema.GroupVersionResource{Group: \"argoproj.io\", Version: \"v1alpha1\", Resource: \"dummies\"}\n\n\tGiven(t).\n\t\tPath(\"crd-creation\").\n\t\tWhen().CreateApp().Sync().Then().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).Expect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tWhen().\n\t\tAnd(func() {\n\t\t\tdummyResIf := DynamicClientset.Resource(dummiesGVR).Namespace(DeploymentNamespace())\n\t\t\tpatchData := []byte(`{\"spec\":{\"cpu\": \"2\"}}`)\n\t\t\tFailOnErr(dummyResIf.Patch(context.Background(), \"dummy-crd-instance\", types.MergePatchType, patchData, metav1.PatchOptions{}))\n\t\t}).Refresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tWhen().\n\t\tAnd(func() {\n\t\t\tSetResourceOverrides(map[string]ResourceOverride{\n\t\t\t\t\"argoproj.io/Dummy\": {\n\t\t\t\t\tKnownTypeFields: []KnownTypeField{{\n\t\t\t\t\t\tField: \"spec\",\n\t\t\t\t\t\tType:  \"core/v1/ResourceList\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t})\n\t\t}).\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced))\n}\n\nfunc TestDuplicatedResources(t *testing.T) {\n\ttestEdgeCasesApplicationResources(t, \"duplicated-resources\", health.HealthStatusHealthy)\n}\n\nfunc TestConfigMap(t *testing.T) {\n\ttestEdgeCasesApplicationResources(t, \"config-map\", health.HealthStatusHealthy, \"my-map  Synced                configmap/my-map created\")\n}\n\nfunc TestFailedConversion(t *testing.T) {\n\tif os.Getenv(\"ARGOCD_E2E_K3S\") == \"true\" {\n\t\tt.SkipNow()\n\t}\n\tdefer func() {\n\t\tFailOnErr(Run(\"\", \"kubectl\", \"delete\", \"apiservice\", \"v1beta1.metrics.k8s.io\"))\n\t}()\n\n\ttestEdgeCasesApplicationResources(t, \"failed-conversion\", health.HealthStatusProgressing)\n}\n\nfunc testEdgeCasesApplicationResources(t *testing.T, appPath string, statusCode health.HealthStatusCode, message ...string) {\n\texpect := Given(t).\n\t\tPath(appPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced))\n\tfor i := range message {\n\t\texpect = expect.Expect(Success(message[i]))\n\t}\n\texpect.\n\t\tExpect(HealthIs(statusCode)).\n\t\tAnd(func(app *Application) {\n\t\t\tdiffOutput, err := RunCli(\"app\", \"diff\", app.Name, \"--local\", path.Join(\"testdata\", appPath))\n\t\t\tassert.Empty(t, diffOutput)\n\t\t\tassert.NoError(t, err)\n\t\t})\n}\n\nconst actionsConfig = `discovery.lua: return { sample = {} }\ndefinitions:\n- name: sample\n  action.lua: |\n    obj.metadata.labels.sample = 'test'\n    return obj`\n\nfunc TestResourceAction(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tResourceOverrides(map[string]ResourceOverride{\"apps/Deployment\": {Actions: actionsConfig}}).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\n\t\t\tcloser, client, err := ArgoCDClientset.NewApplicationClient()\n\t\t\tassert.NoError(t, err)\n\t\t\tdefer io.Close(closer)\n\n\t\t\tactions, err := client.ListResourceActions(context.Background(), &applicationpkg.ApplicationResourceRequest{\n\t\t\t\tName:         &app.Name,\n\t\t\t\tGroup:        \"apps\",\n\t\t\t\tKind:         \"Deployment\",\n\t\t\t\tVersion:      \"v1\",\n\t\t\t\tNamespace:    DeploymentNamespace(),\n\t\t\t\tResourceName: \"guestbook-ui\",\n\t\t\t})\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, []ResourceAction{{Name: \"sample\", Disabled: false}}, actions.Actions)\n\n\t\t\t_, err = client.RunResourceAction(context.Background(), &applicationpkg.ResourceActionRunRequest{Name: &app.Name,\n\t\t\t\tGroup:        \"apps\",\n\t\t\t\tKind:         \"Deployment\",\n\t\t\t\tVersion:      \"v1\",\n\t\t\t\tNamespace:    DeploymentNamespace(),\n\t\t\t\tResourceName: \"guestbook-ui\",\n\t\t\t\tAction:       \"sample\",\n\t\t\t})\n\t\t\tassert.NoError(t, err)\n\n\t\t\tdeployment, err := KubeClientset.AppsV1().Deployments(DeploymentNamespace()).Get(context.Background(), \"guestbook-ui\", metav1.GetOptions{})\n\t\t\tassert.NoError(t, err)\n\n\t\t\tassert.Equal(t, \"test\", deployment.Labels[\"sample\"])\n\t\t})\n}\n\nfunc TestSyncResourceByLabel(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\t_, _ = RunCli(\"app\", \"sync\", app.Name, \"--label\", fmt.Sprintf(\"app.kubernetes.io/instance=%s\", app.Name))\n\t\t}).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\t_, err := RunCli(\"app\", \"sync\", app.Name, \"--label\", \"this-label=does-not-exist\")\n\t\t\tassert.Error(t, err)\n\t\t\tassert.Contains(t, err.Error(), \"level=fatal\")\n\t\t})\n}\n\nfunc TestLocalManifestSync(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\tres, _ := RunCli(\"app\", \"manifests\", app.Name)\n\t\t\tassert.Contains(t, res, \"containerPort: 80\")\n\t\t\tassert.Contains(t, res, \"image: gcr.io/heptio-images/ks-guestbook-demo:0.2\")\n\t\t}).\n\t\tGiven().\n\t\tLocalPath(guestbookPathLocal).\n\t\tWhen().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tres, _ := RunCli(\"app\", \"manifests\", app.Name)\n\t\t\tassert.Contains(t, res, \"containerPort: 81\")\n\t\t\tassert.Contains(t, res, \"image: gcr.io/heptio-images/ks-guestbook-demo:0.3\")\n\t\t}).\n\t\tGiven().\n\t\tLocalPath(\"\").\n\t\tWhen().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tres, _ := RunCli(\"app\", \"manifests\", app.Name)\n\t\t\tassert.Contains(t, res, \"containerPort: 80\")\n\t\t\tassert.Contains(t, res, \"image: gcr.io/heptio-images/ks-guestbook-demo:0.2\")\n\t\t})\n}\n\nfunc TestLocalSync(t *testing.T) {\n\tGiven(t).\n\t\t// we've got to use Helm as this uses kubeVersion\n\t\tPath(\"helm\").\n\t\tWhen().\n\t\tCreateApp().\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\tFailOnErr(RunCli(\"app\", \"sync\", app.Name, \"--local\", \"testdata/helm\"))\n\t\t})\n}\n\nfunc TestNoLocalSyncWithAutosyncEnabled(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\t_, err := RunCli(\"app\", \"set\", app.Name, \"--sync-policy\", \"automated\")\n\t\t\tassert.NoError(t, err)\n\n\t\t\t_, err = RunCli(\"app\", \"sync\", app.Name, \"--local\", guestbookPathLocal)\n\t\t\tassert.Error(t, err)\n\t\t})\n}\n\nfunc TestLocalSyncDryRunWithAutosyncEnabled(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\t_, err := RunCli(\"app\", \"set\", app.Name, \"--sync-policy\", \"automated\")\n\t\t\tassert.NoError(t, err)\n\n\t\t\tappBefore := app.DeepCopy()\n\t\t\t_, err = RunCli(\"app\", \"sync\", app.Name, \"--dry-run\", \"--local\", guestbookPathLocal)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tappAfter := app.DeepCopy()\n\t\t\tassert.True(t, reflect.DeepEqual(appBefore, appAfter))\n\t\t})\n}\n\nfunc TestSyncAsync(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tAsync(true).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(Success(\"\")).\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced))\n}\n\nfunc TestPermissions(t *testing.T) {\n\tEnsureCleanState(t)\n\tappName := Name()\n\t_, err := RunCli(\"proj\", \"create\", \"test\")\n\tassert.NoError(t, err)\n\n\t// make sure app cannot be created without permissions in project\n\t_, err = RunCli(\"app\", \"create\", appName, \"--repo\", RepoURL(RepoURLTypeFile),\n\t\t\"--path\", guestbookPath, \"--project\", \"test\", \"--dest-server\", KubernetesInternalAPIServerAddr, \"--dest-namespace\", DeploymentNamespace())\n\tassert.Error(t, err)\n\tsourceError := fmt.Sprintf(\"application repo %s is not permitted in project 'test'\", RepoURL(RepoURLTypeFile))\n\tdestinationError := fmt.Sprintf(\"application destination {%s %s} is not permitted in project 'test'\", KubernetesInternalAPIServerAddr, DeploymentNamespace())\n\n\tassert.Contains(t, err.Error(), sourceError)\n\tassert.Contains(t, err.Error(), destinationError)\n\n\tproj, err := AppClientset.ArgoprojV1alpha1().AppProjects(ArgoCDNamespace).Get(context.Background(), \"test\", metav1.GetOptions{})\n\tassert.NoError(t, err)\n\n\tproj.Spec.Destinations = []ApplicationDestination{{Server: \"*\", Namespace: \"*\"}}\n\tproj.Spec.SourceRepos = []string{\"*\"}\n\tproj, err = AppClientset.ArgoprojV1alpha1().AppProjects(ArgoCDNamespace).Update(context.Background(), proj, metav1.UpdateOptions{})\n\tassert.NoError(t, err)\n\n\t// make sure controller report permissions issues in conditions\n\t_, err = RunCli(\"app\", \"create\", appName, \"--repo\", RepoURL(RepoURLTypeFile),\n\t\t\"--path\", guestbookPath, \"--project\", \"test\", \"--dest-server\", KubernetesInternalAPIServerAddr, \"--dest-namespace\", DeploymentNamespace())\n\tassert.NoError(t, err)\n\tdefer func() {\n\t\terr = AppClientset.ArgoprojV1alpha1().Applications(ArgoCDNamespace).Delete(context.Background(), appName, metav1.DeleteOptions{})\n\t\tassert.NoError(t, err)\n\t}()\n\n\tproj.Spec.Destinations = []ApplicationDestination{}\n\tproj.Spec.SourceRepos = []string{}\n\t_, err = AppClientset.ArgoprojV1alpha1().AppProjects(ArgoCDNamespace).Update(context.Background(), proj, metav1.UpdateOptions{})\n\tassert.NoError(t, err)\n\ttime.Sleep(1 * time.Second)\n\tcloser, client, err := ArgoCDClientset.NewApplicationClient()\n\tassert.NoError(t, err)\n\tdefer io.Close(closer)\n\n\trefresh := string(RefreshTypeNormal)\n\tapp, err := client.Get(context.Background(), &applicationpkg.ApplicationQuery{Name: &appName, Refresh: &refresh})\n\tassert.NoError(t, err)\n\n\tdestinationErrorExist := false\n\tsourceErrorExist := false\n\tfor i := range app.Status.Conditions {\n\t\tif strings.Contains(app.Status.Conditions[i].Message, destinationError) {\n\t\t\tdestinationErrorExist = true\n\t\t}\n\t\tif strings.Contains(app.Status.Conditions[i].Message, sourceError) {\n\t\t\tsourceErrorExist = true\n\t\t}\n\t}\n\tassert.True(t, destinationErrorExist)\n\tassert.True(t, sourceErrorExist)\n}\n\nfunc TestPermissionWithScopedRepo(t *testing.T) {\n\tprojName := \"argo-project\"\n\tprojectFixture.\n\t\tGiven(t).\n\t\tName(projName).\n\t\tDestination(\"*,*\").\n\t\tWhen().\n\t\tCreate()\n\n\trepoFixture.Given(t, true).\n\t\tWhen().\n\t\tPath(RepoURL(RepoURLTypeFile)).\n\t\tProject(projName).\n\t\tCreate()\n\n\tGivenWithSameState(t).\n\t\tProject(projName).\n\t\tRepoURLType(RepoURLTypeFile).\n\t\tPath(\"two-nice-pods\").\n\t\tWhen().\n\t\tPatchFile(\"pod-1.yaml\", `[{\"op\": \"add\", \"path\": \"/metadata/annotations\", \"value\": {\"argocd.argoproj.io/sync-options\": \"Prune=false\"}}]`).\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tWhen().\n\t\tDeleteFile(\"pod-1.yaml\").\n\t\tRefresh(RefreshTypeHard).\n\t\tIgnoreErrors().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tExpect(ResourceSyncStatusIs(\"Pod\", \"pod-1\", SyncStatusCodeOutOfSync))\n}\n\nfunc TestPermissionDeniedWithScopedRepo(t *testing.T) {\n\tprojName := \"argo-project\"\n\tprojectFixture.\n\t\tGiven(t).\n\t\tName(projName).\n\t\tDestination(\"*,*\").\n\t\tWhen().\n\t\tCreate()\n\n\trepoFixture.Given(t, true).\n\t\tWhen().\n\t\tPath(RepoURL(RepoURLTypeFile)).\n\t\tCreate()\n\n\tGivenWithSameState(t).\n\t\tProject(projName).\n\t\tRepoURLType(RepoURLTypeFile).\n\t\tPath(\"two-nice-pods\").\n\t\tWhen().\n\t\tPatchFile(\"pod-1.yaml\", `[{\"op\": \"add\", \"path\": \"/metadata/annotations\", \"value\": {\"argocd.argoproj.io/sync-options\": \"Prune=false\"}}]`).\n\t\tIgnoreErrors().\n\t\tCreateApp().\n\t\tThen().\n\t\tExpect(Error(\"\", \"is not permitted in project\"))\n\n}\n\n// make sure that if we deleted a resource from the app, it is not pruned if annotated with Prune=false\nfunc TestSyncOptionPruneFalse(t *testing.T) {\n\tGiven(t).\n\t\tPath(\"two-nice-pods\").\n\t\tWhen().\n\t\tPatchFile(\"pod-1.yaml\", `[{\"op\": \"add\", \"path\": \"/metadata/annotations\", \"value\": {\"argocd.argoproj.io/sync-options\": \"Prune=false\"}}]`).\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tWhen().\n\t\tDeleteFile(\"pod-1.yaml\").\n\t\tRefresh(RefreshTypeHard).\n\t\tIgnoreErrors().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tExpect(ResourceSyncStatusIs(\"Pod\", \"pod-1\", SyncStatusCodeOutOfSync))\n}\n\n// make sure that if we have an invalid manifest, we can add it if we disable validation, we get a server error rather than a client error\nfunc TestSyncOptionValidateFalse(t *testing.T) {\n\n\t// k3s does not validate at all, so this test does not work\n\tif os.Getenv(\"ARGOCD_E2E_K3S\") == \"true\" {\n\t\tt.SkipNow()\n\t}\n\n\tGiven(t).\n\t\tPath(\"crd-validation\").\n\t\tWhen().\n\t\tCreateApp().\n\t\tThen().\n\t\tExpect(Success(\"\")).\n\t\tWhen().\n\t\tIgnoreErrors().\n\t\tSync().\n\t\tThen().\n\t\t// client error\n\t\tExpect(Error(\"error validating data\", \"\")).\n\t\tWhen().\n\t\tPatchFile(\"deployment.yaml\", `[{\"op\": \"add\", \"path\": \"/metadata/annotations\", \"value\": {\"argocd.argoproj.io/sync-options\": \"Validate=false\"}}]`).\n\t\tSync().\n\t\tThen().\n\t\t// server error\n\t\tExpect(Error(\"Error from server\", \"\"))\n}\n\n// make sure that, if we have a resource that needs pruning, but we're ignoring it, the app is in-sync\nfunc TestCompareOptionIgnoreExtraneous(t *testing.T) {\n\tGiven(t).\n\t\tPrune(false).\n\t\tPath(\"two-nice-pods\").\n\t\tWhen().\n\t\tPatchFile(\"pod-1.yaml\", `[{\"op\": \"add\", \"path\": \"/metadata/annotations\", \"value\": {\"argocd.argoproj.io/compare-options\": \"IgnoreExtraneous\"}}]`).\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tWhen().\n\t\tDeleteFile(\"pod-1.yaml\").\n\t\tRefresh(RefreshTypeHard).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Len(t, app.Status.Resources, 2)\n\t\t\tstatusByName := map[string]SyncStatusCode{}\n\t\t\tfor _, r := range app.Status.Resources {\n\t\t\t\tstatusByName[r.Name] = r.Status\n\t\t\t}\n\t\t\tassert.Equal(t, SyncStatusCodeOutOfSync, statusByName[\"pod-1\"])\n\t\t\tassert.Equal(t, SyncStatusCodeSynced, statusByName[\"pod-2\"])\n\t\t}).\n\t\tWhen().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced))\n}\n\nfunc TestSelfManagedApps(t *testing.T) {\n\n\tGiven(t).\n\t\tPath(\"self-managed-app\").\n\t\tWhen().\n\t\tPatchFile(\"resources.yaml\", fmt.Sprintf(`[{\"op\": \"replace\", \"path\": \"/spec/source/repoURL\", \"value\": \"%s\"}]`, RepoURL(RepoURLTypeFile))).\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(a *Application) {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second*3)\n\t\t\tdefer cancel()\n\n\t\t\treconciledCount := 0\n\t\t\tvar lastReconciledAt *metav1.Time\n\t\t\tfor event := range ArgoCDClientset.WatchApplicationWithRetry(ctx, a.Name, a.ResourceVersion) {\n\t\t\t\treconciledAt := event.Application.Status.ReconciledAt\n\t\t\t\tif reconciledAt == nil {\n\t\t\t\t\treconciledAt = &metav1.Time{}\n\t\t\t\t}\n\t\t\t\tif lastReconciledAt != nil && !lastReconciledAt.Equal(reconciledAt) {\n\t\t\t\t\treconciledCount = reconciledCount + 1\n\t\t\t\t}\n\t\t\t\tlastReconciledAt = reconciledAt\n\t\t\t}\n\n\t\t\tassert.True(t, reconciledCount < 3, \"Application was reconciled too many times\")\n\t\t})\n}\n\nfunc TestExcludedResource(t *testing.T) {\n\tGiven(t).\n\t\tResourceOverrides(map[string]ResourceOverride{\"apps/Deployment\": {Actions: actionsConfig}}).\n\t\tPath(guestbookPath).\n\t\tResourceFilter(settings.ResourcesFilter{\n\t\t\tResourceExclusions: []settings.FilteredResource{{Kinds: []string{kube.DeploymentKind}}},\n\t\t}).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(Condition(ApplicationConditionExcludedResourceWarning, \"Resource apps/Deployment guestbook-ui is excluded in the settings\"))\n}\n\nfunc TestRevisionHistoryLimit(t *testing.T) {\n\tGiven(t).\n\t\tPath(\"config-map\").\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Len(t, app.Status.History, 1)\n\t\t}).\n\t\tWhen().\n\t\tAppSet(\"--revision-history-limit\", \"1\").\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Len(t, app.Status.History, 1)\n\t\t})\n}\n\nfunc TestOrphanedResource(t *testing.T) {\n\tSkipOnEnv(t, \"OPENSHIFT\")\n\tGiven(t).\n\t\tProjectSpec(AppProjectSpec{\n\t\t\tSourceRepos:       []string{\"*\"},\n\t\t\tDestinations:      []ApplicationDestination{{Namespace: \"*\", Server: \"*\"}},\n\t\t\tOrphanedResources: &OrphanedResourcesMonitorSettings{Warn: pointer.BoolPtr(true)},\n\t\t}).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tExpect(NoConditions()).\n\t\tWhen().\n\t\tAnd(func() {\n\t\t\tFailOnErr(KubeClientset.CoreV1().ConfigMaps(DeploymentNamespace()).Create(context.Background(), &v1.ConfigMap{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName: \"orphaned-configmap\",\n\t\t\t\t},\n\t\t\t}, metav1.CreateOptions{}))\n\t\t}).\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(Condition(ApplicationConditionOrphanedResourceWarning, \"Application has 1 orphaned resources\")).\n\t\tAnd(func(app *Application) {\n\t\t\toutput, err := RunCli(\"app\", \"resources\", app.Name)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, output, \"orphaned-configmap\")\n\t\t}).\n\t\tGiven().\n\t\tProjectSpec(AppProjectSpec{\n\t\t\tSourceRepos:       []string{\"*\"},\n\t\t\tDestinations:      []ApplicationDestination{{Namespace: \"*\", Server: \"*\"}},\n\t\t\tOrphanedResources: &OrphanedResourcesMonitorSettings{Warn: pointer.BoolPtr(true), Ignore: []OrphanedResourceKey{{Group: \"Test\", Kind: \"ConfigMap\"}}},\n\t\t}).\n\t\tWhen().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(Condition(ApplicationConditionOrphanedResourceWarning, \"Application has 1 orphaned resources\")).\n\t\tAnd(func(app *Application) {\n\t\t\toutput, err := RunCli(\"app\", \"resources\", app.Name)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, output, \"orphaned-configmap\")\n\t\t}).\n\t\tGiven().\n\t\tProjectSpec(AppProjectSpec{\n\t\t\tSourceRepos:       []string{\"*\"},\n\t\t\tDestinations:      []ApplicationDestination{{Namespace: \"*\", Server: \"*\"}},\n\t\t\tOrphanedResources: &OrphanedResourcesMonitorSettings{Warn: pointer.BoolPtr(true), Ignore: []OrphanedResourceKey{{Kind: \"ConfigMap\"}}},\n\t\t}).\n\t\tWhen().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tExpect(NoConditions()).\n\t\tAnd(func(app *Application) {\n\t\t\toutput, err := RunCli(\"app\", \"resources\", app.Name)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.NotContains(t, output, \"orphaned-configmap\")\n\t\t}).\n\t\tGiven().\n\t\tProjectSpec(AppProjectSpec{\n\t\t\tSourceRepos:       []string{\"*\"},\n\t\t\tDestinations:      []ApplicationDestination{{Namespace: \"*\", Server: \"*\"}},\n\t\t\tOrphanedResources: &OrphanedResourcesMonitorSettings{Warn: pointer.BoolPtr(true), Ignore: []OrphanedResourceKey{{Kind: \"ConfigMap\", Name: \"orphaned-configmap\"}}},\n\t\t}).\n\t\tWhen().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tExpect(NoConditions()).\n\t\tAnd(func(app *Application) {\n\t\t\toutput, err := RunCli(\"app\", \"resources\", app.Name)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.NotContains(t, output, \"orphaned-configmap\")\n\t\t}).\n\t\tGiven().\n\t\tProjectSpec(AppProjectSpec{\n\t\t\tSourceRepos:       []string{\"*\"},\n\t\t\tDestinations:      []ApplicationDestination{{Namespace: \"*\", Server: \"*\"}},\n\t\t\tOrphanedResources: nil,\n\t\t}).\n\t\tWhen().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tExpect(NoConditions())\n}\n\nfunc TestNotPermittedResources(t *testing.T) {\n\tctx := Given(t)\n\n\tpathType := networkingv1.PathTypePrefix\n\tingress := &networkingv1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName: \"sample-ingress\",\n\t\t\tLabels: map[string]string{\n\t\t\t\tcommon.LabelKeyAppInstance: ctx.GetName(),\n\t\t\t},\n\t\t},\n\t\tSpec: networkingv1.IngressSpec{\n\t\t\tRules: []networkingv1.IngressRule{{\n\t\t\t\tIngressRuleValue: networkingv1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networkingv1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networkingv1.HTTPIngressPath{{\n\t\t\t\t\t\t\tPath: \"/\",\n\t\t\t\t\t\t\tBackend: networkingv1.IngressBackend{\n\t\t\t\t\t\t\t\tService: &networkingv1.IngressServiceBackend{\n\t\t\t\t\t\t\t\t\tName: \"guestbook-ui\",\n\t\t\t\t\t\t\t\t\tPort: networkingv1.ServiceBackendPort{Number: 80},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPathType: &pathType,\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\tdefer func() {\n\t\tlog.Infof(\"Ingress 'sample-ingress' deleted from %s\", ArgoCDNamespace)\n\t\tCheckError(KubeClientset.NetworkingV1().Ingresses(ArgoCDNamespace).Delete(context.Background(), \"sample-ingress\", metav1.DeleteOptions{}))\n\t}()\n\n\tsvc := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName: \"guestbook-ui\",\n\t\t\tLabels: map[string]string{\n\t\t\t\tcommon.LabelKeyAppInstance: ctx.GetName(),\n\t\t\t},\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tPort:       80,\n\t\t\t\tTargetPort: intstr.IntOrString{Type: intstr.Int, IntVal: 80},\n\t\t\t}},\n\t\t\tSelector: map[string]string{\n\t\t\t\t\"app\": \"guestbook-ui\",\n\t\t\t},\n\t\t},\n\t}\n\n\tctx.ProjectSpec(AppProjectSpec{\n\t\tSourceRepos:  []string{\"*\"},\n\t\tDestinations: []ApplicationDestination{{Namespace: DeploymentNamespace(), Server: \"*\"}},\n\t\tNamespaceResourceBlacklist: []metav1.GroupKind{\n\t\t\t{Group: \"\", Kind: \"Service\"},\n\t\t}}).\n\t\tAnd(func() {\n\t\t\tFailOnErr(KubeClientset.NetworkingV1().Ingresses(ArgoCDNamespace).Create(context.Background(), ingress, metav1.CreateOptions{}))\n\t\t\tFailOnErr(KubeClientset.CoreV1().Services(DeploymentNamespace()).Create(context.Background(), svc, metav1.CreateOptions{}))\n\t\t}).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tAnd(func(app *Application) {\n\t\t\tstatusByKind := make(map[string]ResourceStatus)\n\t\t\tfor _, res := range app.Status.Resources {\n\t\t\t\tstatusByKind[res.Kind] = res\n\t\t\t}\n\t\t\t_, hasIngress := statusByKind[kube.IngressKind]\n\t\t\tassert.False(t, hasIngress, \"Ingress is prohibited not managed object and should be even visible to user\")\n\t\t\tserviceStatus := statusByKind[kube.ServiceKind]\n\t\t\tassert.Equal(t, serviceStatus.Status, SyncStatusCodeUnknown, \"Service is prohibited managed resource so should be set to Unknown\")\n\t\t\tdeploymentStatus := statusByKind[kube.DeploymentKind]\n\t\t\tassert.Equal(t, deploymentStatus.Status, SyncStatusCodeOutOfSync)\n\t\t}).\n\t\tWhen().\n\t\tDelete(true).\n\t\tThen().\n\t\tExpect(DoesNotExist())\n\n\t// Make sure prohibited resources are not deleted during application deletion\n\tFailOnErr(KubeClientset.NetworkingV1().Ingresses(ArgoCDNamespace).Get(context.Background(), \"sample-ingress\", metav1.GetOptions{}))\n\tFailOnErr(KubeClientset.CoreV1().Services(DeploymentNamespace()).Get(context.Background(), \"guestbook-ui\", metav1.GetOptions{}))\n}\n\nfunc TestSyncWithInfos(t *testing.T) {\n\texpectedInfo := make([]*Info, 2)\n\texpectedInfo[0] = &Info{Name: \"name1\", Value: \"val1\"}\n\texpectedInfo[1] = &Info{Name: \"name2\", Value: \"val2\"}\n\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\t_, err := RunCli(\"app\", \"sync\", app.Name,\n\t\t\t\t\"--info\", fmt.Sprintf(\"%s=%s\", expectedInfo[0].Name, expectedInfo[0].Value),\n\t\t\t\t\"--info\", fmt.Sprintf(\"%s=%s\", expectedInfo[1].Name, expectedInfo[1].Value))\n\t\t\tassert.NoError(t, err)\n\t\t}).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.ElementsMatch(t, app.Status.OperationState.Operation.Info, expectedInfo)\n\t\t})\n}\n\n//Given: argocd app create does not provide --dest-namespace\n//       Manifest contains resource console which does not require namespace\n//Expect: no app.Status.Conditions\nfunc TestCreateAppWithNoNameSpaceForGlobalResource(t *testing.T) {\n\tGiven(t).\n\t\tPath(globalWithNoNameSpace).\n\t\tWhen().\n\t\tCreateWithNoNameSpace().\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\ttime.Sleep(500 * time.Millisecond)\n\t\t\tapp, err := AppClientset.ArgoprojV1alpha1().Applications(ArgoCDNamespace).Get(context.Background(), app.Name, metav1.GetOptions{})\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Len(t, app.Status.Conditions, 0)\n\t\t})\n}\n\n//Given: argocd app create does not provide --dest-namespace\n//       Manifest contains resource deployment, and service which requires namespace\n//       Deployment and service do not have namespace in manifest\n//Expect: app.Status.Conditions for deployment ans service which does not have namespace in manifest\nfunc TestCreateAppWithNoNameSpaceWhenRequired(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateWithNoNameSpace().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\tupdatedApp, err := AppClientset.ArgoprojV1alpha1().Applications(ArgoCDNamespace).Get(context.Background(), app.Name, metav1.GetOptions{})\n\t\t\trequire.NoError(t, err)\n\n\t\t\tassert.Len(t, updatedApp.Status.Conditions, 2)\n\t\t\tassert.Equal(t, updatedApp.Status.Conditions[0].Type, ApplicationConditionInvalidSpecError)\n\t\t\tassert.Equal(t, updatedApp.Status.Conditions[1].Type, ApplicationConditionInvalidSpecError)\n\t\t})\n}\n\n//Given: argocd app create does not provide --dest-namespace\n//       Manifest contains resource deployment, and service which requires namespace\n//       Some deployment and service has namespace in manifest\n//       Some deployment and service does not have namespace in manifest\n//Expect: app.Status.Conditions for deployment and service which does not have namespace in manifest\nfunc TestCreateAppWithNoNameSpaceWhenRequired2(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookWithNamespace).\n\t\tWhen().\n\t\tCreateWithNoNameSpace().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\tupdatedApp, err := AppClientset.ArgoprojV1alpha1().Applications(ArgoCDNamespace).Get(context.Background(), app.Name, metav1.GetOptions{})\n\t\t\trequire.NoError(t, err)\n\n\t\t\tassert.Len(t, updatedApp.Status.Conditions, 2)\n\t\t\tassert.Equal(t, updatedApp.Status.Conditions[0].Type, ApplicationConditionInvalidSpecError)\n\t\t\tassert.Equal(t, updatedApp.Status.Conditions[1].Type, ApplicationConditionInvalidSpecError)\n\t\t})\n}\n\nfunc TestListResource(t *testing.T) {\n\tSkipOnEnv(t, \"OPENSHIFT\")\n\tGiven(t).\n\t\tProjectSpec(AppProjectSpec{\n\t\t\tSourceRepos:       []string{\"*\"},\n\t\t\tDestinations:      []ApplicationDestination{{Namespace: \"*\", Server: \"*\"}},\n\t\t\tOrphanedResources: &OrphanedResourcesMonitorSettings{Warn: pointer.BoolPtr(true)},\n\t\t}).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tExpect(NoConditions()).\n\t\tWhen().\n\t\tAnd(func() {\n\t\t\tFailOnErr(KubeClientset.CoreV1().ConfigMaps(DeploymentNamespace()).Create(context.Background(), &v1.ConfigMap{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName: \"orphaned-configmap\",\n\t\t\t\t},\n\t\t\t}, metav1.CreateOptions{}))\n\t\t}).\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(Condition(ApplicationConditionOrphanedResourceWarning, \"Application has 1 orphaned resources\")).\n\t\tAnd(func(app *Application) {\n\t\t\toutput, err := RunCli(\"app\", \"resources\", app.Name)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, output, \"orphaned-configmap\")\n\t\t\tassert.Contains(t, output, \"guestbook-ui\")\n\t\t}).\n\t\tAnd(func(app *Application) {\n\t\t\toutput, err := RunCli(\"app\", \"resources\", app.Name, \"--orphaned=true\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, output, \"orphaned-configmap\")\n\t\t\tassert.NotContains(t, output, \"guestbook-ui\")\n\t\t}).\n\t\tAnd(func(app *Application) {\n\t\t\toutput, err := RunCli(\"app\", \"resources\", app.Name, \"--orphaned=false\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.NotContains(t, output, \"orphaned-configmap\")\n\t\t\tassert.Contains(t, output, \"guestbook-ui\")\n\t\t}).\n\t\tGiven().\n\t\tProjectSpec(AppProjectSpec{\n\t\t\tSourceRepos:       []string{\"*\"},\n\t\t\tDestinations:      []ApplicationDestination{{Namespace: \"*\", Server: \"*\"}},\n\t\t\tOrphanedResources: nil,\n\t\t}).\n\t\tWhen().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tExpect(NoConditions())\n}\n\n// Given application is set with --sync-option CreateNamespace=true\n//       application --dest-namespace does not exist\n// Verity application --dest-namespace is created\n//        application sync successful\n//        when application is deleted, --dest-namespace is not deleted\nfunc TestNamespaceAutoCreation(t *testing.T) {\n\tSkipOnEnv(t, \"OPENSHIFT\")\n\tupdatedNamespace := getNewNamespace(t)\n\tdefer func() {\n\t\tif !t.Skipped() {\n\t\t\t_, err := Run(\"\", \"kubectl\", \"delete\", \"namespace\", updatedNamespace)\n\t\t\tassert.NoError(t, err)\n\t\t}\n\t}()\n\tGiven(t).\n\t\tTimeout(30).\n\t\tPath(\"guestbook\").\n\t\tWhen().\n\t\tCreateApp(\"--sync-option\", \"CreateNamespace=true\").\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\t//Make sure the namespace we are about to update to does not exist\n\t\t\t_, err := Run(\"\", \"kubectl\", \"get\", \"namespace\", updatedNamespace)\n\t\t\tassert.Error(t, err)\n\t\t\tassert.Contains(t, err.Error(), \"not found\")\n\t\t}).\n\t\tWhen().\n\t\tAppSet(\"--dest-namespace\", updatedNamespace).\n\t\tSync().\n\t\tThen().\n\t\tExpect(Success(\"\")).\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).Expect(ResourceHealthWithNamespaceIs(\"Deployment\", \"guestbook-ui\", updatedNamespace, health.HealthStatusHealthy)).\n\t\tExpect(ResourceHealthWithNamespaceIs(\"Deployment\", \"guestbook-ui\", updatedNamespace, health.HealthStatusHealthy)).\n\t\tExpect(ResourceSyncStatusWithNamespaceIs(\"Deployment\", \"guestbook-ui\", updatedNamespace, SyncStatusCodeSynced)).\n\t\tExpect(ResourceSyncStatusWithNamespaceIs(\"Deployment\", \"guestbook-ui\", updatedNamespace, SyncStatusCodeSynced)).\n\t\tWhen().\n\t\tDelete(true).\n\t\tThen().\n\t\tExpect(Success(\"\")).\n\t\tAnd(func(app *Application) {\n\t\t\t//Verify delete app does not delete the namespace auto created\n\t\t\toutput, err := Run(\"\", \"kubectl\", \"get\", \"namespace\", updatedNamespace)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, output, updatedNamespace)\n\t\t})\n}\n\nfunc TestFailedSyncWithRetry(t *testing.T) {\n\tGiven(t).\n\t\tPath(\"hook\").\n\t\tWhen().\n\t\tPatchFile(\"hook.yaml\", `[{\"op\": \"replace\", \"path\": \"/metadata/annotations\", \"value\": {\"argocd.argoproj.io/hook\": \"PreSync\"}}]`).\n\t\t// make hook fail\n\t\tPatchFile(\"hook.yaml\", `[{\"op\": \"replace\", \"path\": \"/spec/containers/0/command\", \"value\": [\"false\"]}]`).\n\t\tCreateApp().\n\t\tIgnoreErrors().\n\t\tSync(\"--retry-limit=1\", \"--retry-backoff-duration=1s\").\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationFailed)).\n\t\tExpect(OperationMessageContains(\"retried 1 times\"))\n}\n\nfunc TestCreateDisableValidation(t *testing.T) {\n\tGiven(t).\n\t\tPath(\"baddir\").\n\t\tWhen().\n\t\tCreateApp(\"--validate=false\").\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\t_, err := RunCli(\"app\", \"create\", app.Name, \"--upsert\", \"--validate=false\", \"--repo\", RepoURL(RepoURLTypeFile),\n\t\t\t\t\"--path\", \"baddir2\", \"--project\", app.Spec.Project, \"--dest-server\", KubernetesInternalAPIServerAddr, \"--dest-namespace\", DeploymentNamespace())\n\t\t\tassert.NoError(t, err)\n\t\t}).\n\t\tWhen().\n\t\tAppSet(\"--path\", \"baddir3\", \"--validate=false\")\n\n}\n\nfunc TestCreateFromPartialFile(t *testing.T) {\n\tpartialApp :=\n\t\t`metadata:\n  labels:\n    labels.local/from-file: file\n    labels.local/from-args: file\n  annotations:\n    annotations.local/from-file: file\n  finalizers:\n  - resources-finalizer.argocd.argoproj.io\nspec:\n  syncPolicy:\n    automated:\n      prune: true\n`\n\n\tpath := \"helm-values\"\n\tGiven(t).\n\t\tWhen().\n\t\t// app should be auto-synced once created\n\t\tCreateFromPartialFile(partialApp, \"--path\", path, \"-l\", \"labels.local/from-args=args\", \"--helm-set\", \"foo=foo\").\n\t\tThen().\n\t\tExpect(Success(\"\")).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tExpect(NoConditions()).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Equal(t, map[string]string{\"labels.local/from-file\": \"file\", \"labels.local/from-args\": \"args\"}, app.ObjectMeta.Labels)\n\t\t\tassert.Equal(t, map[string]string{\"annotations.local/from-file\": \"file\"}, app.ObjectMeta.Annotations)\n\t\t\tassert.Equal(t, []string{\"resources-finalizer.argocd.argoproj.io\"}, app.ObjectMeta.Finalizers)\n\t\t\tassert.Equal(t, path, app.Spec.Source.Path)\n\t\t\tassert.Equal(t, []HelmParameter{{Name: \"foo\", Value: \"foo\"}}, app.Spec.Source.Helm.Parameters)\n\t\t})\n}\n\n// Ensure actions work when using a resource action that modifies status and/or spec\nfunc TestCRDStatusSubresourceAction(t *testing.T) {\n\tactions := `\ndiscovery.lua: |\n  actions = {}\n  actions[\"update-spec\"] = {[\"disabled\"] = false}\n  actions[\"update-status\"] = {[\"disabled\"] = false}\n  actions[\"update-both\"] = {[\"disabled\"] = false}\n  return actions\ndefinitions:\n- name: update-both\n  action.lua: |\n    obj.spec = {}\n    obj.spec.foo = \"update-both\"\n    obj.status = {}\n    obj.status.bar = \"update-both\"\n    return obj\n- name: update-spec\n  action.lua: |\n    obj.spec = {}\n    obj.spec.foo = \"update-spec\"\n    return obj\n- name: update-status\n  action.lua: |\n    obj.status = {}\n    obj.status.bar = \"update-status\"\n    return obj\n`\n\tGiven(t).\n\t\tPath(\"crd-subresource\").\n\t\tAnd(func() {\n\t\t\tSetResourceOverrides(map[string]ResourceOverride{\n\t\t\t\t\"argoproj.io/StatusSubResource\": {\n\t\t\t\t\tActions: actions,\n\t\t\t\t},\n\t\t\t\t\"argoproj.io/NonStatusSubResource\": {\n\t\t\t\t\tActions: actions,\n\t\t\t\t},\n\t\t\t})\n\t\t}).\n\t\tWhen().CreateApp().Sync().Then().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).Expect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tWhen().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\t// tests resource actions on a CRD using status subresource\n\t\tAnd(func(app *Application) {\n\t\t\t_, err := RunCli(\"app\", \"actions\", \"run\", app.Name, \"--kind\", \"StatusSubResource\", \"update-both\")\n\t\t\tassert.NoError(t, err)\n\t\t\ttext := FailOnErr(Run(\".\", \"kubectl\", \"-n\", app.Spec.Destination.Namespace, \"get\", \"statussubresources\", \"status-subresource\", \"-o\", \"jsonpath={.spec.foo}\")).(string)\n\t\t\tassert.Equal(t, \"update-both\", text)\n\t\t\ttext = FailOnErr(Run(\".\", \"kubectl\", \"-n\", app.Spec.Destination.Namespace, \"get\", \"statussubresources\", \"status-subresource\", \"-o\", \"jsonpath={.status.bar}\")).(string)\n\t\t\tassert.Equal(t, \"update-both\", text)\n\n\t\t\t_, err = RunCli(\"app\", \"actions\", \"run\", app.Name, \"--kind\", \"StatusSubResource\", \"update-spec\")\n\t\t\tassert.NoError(t, err)\n\t\t\ttext = FailOnErr(Run(\".\", \"kubectl\", \"-n\", app.Spec.Destination.Namespace, \"get\", \"statussubresources\", \"status-subresource\", \"-o\", \"jsonpath={.spec.foo}\")).(string)\n\t\t\tassert.Equal(t, \"update-spec\", text)\n\n\t\t\t_, err = RunCli(\"app\", \"actions\", \"run\", app.Name, \"--kind\", \"StatusSubResource\", \"update-status\")\n\t\t\tassert.NoError(t, err)\n\t\t\ttext = FailOnErr(Run(\".\", \"kubectl\", \"-n\", app.Spec.Destination.Namespace, \"get\", \"statussubresources\", \"status-subresource\", \"-o\", \"jsonpath={.status.bar}\")).(string)\n\t\t\tassert.Equal(t, \"update-status\", text)\n\t\t}).\n\t\t// tests resource actions on a CRD *not* using status subresource\n\t\tAnd(func(app *Application) {\n\t\t\t_, err := RunCli(\"app\", \"actions\", \"run\", app.Name, \"--kind\", \"NonStatusSubResource\", \"update-both\")\n\t\t\tassert.NoError(t, err)\n\t\t\ttext := FailOnErr(Run(\".\", \"kubectl\", \"-n\", app.Spec.Destination.Namespace, \"get\", \"nonstatussubresources\", \"non-status-subresource\", \"-o\", \"jsonpath={.spec.foo}\")).(string)\n\t\t\tassert.Equal(t, \"update-both\", text)\n\t\t\ttext = FailOnErr(Run(\".\", \"kubectl\", \"-n\", app.Spec.Destination.Namespace, \"get\", \"nonstatussubresources\", \"non-status-subresource\", \"-o\", \"jsonpath={.status.bar}\")).(string)\n\t\t\tassert.Equal(t, \"update-both\", text)\n\n\t\t\t_, err = RunCli(\"app\", \"actions\", \"run\", app.Name, \"--kind\", \"NonStatusSubResource\", \"update-spec\")\n\t\t\tassert.NoError(t, err)\n\t\t\ttext = FailOnErr(Run(\".\", \"kubectl\", \"-n\", app.Spec.Destination.Namespace, \"get\", \"nonstatussubresources\", \"non-status-subresource\", \"-o\", \"jsonpath={.spec.foo}\")).(string)\n\t\t\tassert.Equal(t, \"update-spec\", text)\n\n\t\t\t_, err = RunCli(\"app\", \"actions\", \"run\", app.Name, \"--kind\", \"NonStatusSubResource\", \"update-status\")\n\t\t\tassert.NoError(t, err)\n\t\t\ttext = FailOnErr(Run(\".\", \"kubectl\", \"-n\", app.Spec.Destination.Namespace, \"get\", \"nonstatussubresources\", \"non-status-subresource\", \"-o\", \"jsonpath={.status.bar}\")).(string)\n\t\t\tassert.Equal(t, \"update-status\", text)\n\t\t})\n}\n\nfunc TestAppLogs(t *testing.T) {\n\tSkipOnEnv(t, \"OPENSHIFT\")\n\tGiven(t).\n\t\tPath(\"guestbook-logs\").\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(HealthIs(health.HealthStatusHealthy)).\n\t\tAnd(func(app *Application) {\n\t\t\tout, err := RunCli(\"app\", \"logs\", app.Name, \"--kind\", \"Deployment\", \"--group\", \"\", \"--name\", \"guestbook-ui\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, out, \"Hi\")\n\t\t}).\n\t\tAnd(func(app *Application) {\n\t\t\tout, err := RunCli(\"app\", \"logs\", app.Name, \"--kind\", \"Pod\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, out, \"Hi\")\n\t\t}).\n\t\tAnd(func(app *Application) {\n\t\t\tout, err := RunCli(\"app\", \"logs\", app.Name, \"--kind\", \"Service\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.NotContains(t, out, \"Hi\")\n\t\t})\n}\n\nfunc TestAppWaitOperationInProgress(t *testing.T) {\n\tGiven(t).\n\t\tAnd(func() {\n\t\t\tSetResourceOverrides(map[string]ResourceOverride{\n\t\t\t\t\"batch/Job\": {\n\t\t\t\t\tHealthLua: `return { status = 'Running' }`,\n\t\t\t\t},\n\t\t\t\t\"apps/Deployment\": {\n\t\t\t\t\tHealthLua: `return { status = 'Suspended' }`,\n\t\t\t\t},\n\t\t\t})\n\t\t}).\n\t\tAsync(true).\n\t\tPath(\"hook-and-deployment\").\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\t// stuck in running state\n\t\tExpect(OperationPhaseIs(OperationRunning)).\n\t\tWhen().\n\t\tAnd(func() {\n\t\t\t_, err := RunCli(\"app\", \"wait\", Name(), \"--suspended\")\n\t\t\terrors.CheckError(err)\n\t\t})\n}\n\nfunc TestSyncOptionReplace(t *testing.T) {\n\tGiven(t).\n\t\tPath(\"config-map\").\n\t\tWhen().\n\t\tPatchFile(\"config-map.yaml\", `[{\"op\": \"add\", \"path\": \"/metadata/annotations\", \"value\": {\"argocd.argoproj.io/sync-options\": \"Replace=true\"}}]`).\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Equal(t, app.Status.OperationState.SyncResult.Resources[0].Message, \"configmap/my-map created\")\n\t\t}).\n\t\tWhen().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Equal(t, app.Status.OperationState.SyncResult.Resources[0].Message, \"configmap/my-map replaced\")\n\t\t})\n}\n\nfunc TestSyncOptionReplaceFromCLI(t *testing.T) {\n\tGiven(t).\n\t\tPath(\"config-map\").\n\t\tReplace().\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Equal(t, app.Status.OperationState.SyncResult.Resources[0].Message, \"configmap/my-map created\")\n\t\t}).\n\t\tWhen().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Equal(t, app.Status.OperationState.SyncResult.Resources[0].Message, \"configmap/my-map replaced\")\n\t\t})\n}\n\nfunc TestDiscoverNewCommit(t *testing.T) {\n\tvar sha string\n\tGiven(t).\n\t\tPath(\"config-map\").\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tsha = app.Status.Sync.Revision\n\t\t\tassert.NotEmpty(t, sha)\n\t\t}).\n\t\tWhen().\n\t\tPatchFile(\"config-map.yaml\", `[{\"op\": \"replace\", \"path\": \"/data/foo\", \"value\": \"hello\"}]`).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\t// make sure new commit is not discovered immediately after push\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Equal(t, sha, app.Status.Sync.Revision)\n\t\t}).\n\t\tWhen().\n\t\t// make sure new commit is not discovered after refresh is requested\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.NotEqual(t, sha, app.Status.Sync.Revision)\n\t\t})\n}\n\nfunc TestDisableManifestGeneration(t *testing.T) {\n\tGiven(t).\n\t\tPath(\"guestbook\").\n\t\tWhen().\n\t\tCreateApp().\n\t\tRefresh(RefreshTypeHard).\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Equal(t, app.Status.SourceType, ApplicationSourceTypeKustomize)\n\t\t}).\n\t\tWhen().\n\t\tAnd(func() {\n\t\t\tSetEnableManifestGeneration(map[ApplicationSourceType]bool{\n\t\t\t\tApplicationSourceTypeKustomize: false,\n\t\t\t})\n\t\t}).\n\t\tRefresh(RefreshTypeHard).\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Equal(t, app.Status.SourceType, ApplicationSourceTypeDirectory)\n\t\t})\n}\n", "package project\n\nimport (\n\t\"github.com/argoproj/argo-cd/v2/test/e2e/fixture\"\n)\n\n// this implements the \"when\" part of given/when/then\n//\n// none of the func implement error checks, and that is complete intended, you should check for errors\n// using the Then()\ntype Actions struct {\n\tcontext      *Context\n\tlastOutput   string\n\tlastError    error\n\tignoreErrors bool\n}\n\nfunc (a *Actions) IgnoreErrors() *Actions {\n\ta.ignoreErrors = true\n\treturn a\n}\n\nfunc (a *Actions) DoNotIgnoreErrors() *Actions {\n\ta.ignoreErrors = false\n\treturn a\n}\n\nfunc (a *Actions) Create(args ...string) *Actions {\n\targs = a.prepareCreateArgs(args)\n\n\t//  are you adding new context values? if you only use them for this func, then use args instead\n\ta.runCli(args...)\n\n\treturn a\n}\n\nfunc (a *Actions) Name(name string) *Actions {\n\ta.context.name = name\n\treturn a\n}\n\nfunc (a *Actions) prepareCreateArgs(args []string) []string {\n\ta.context.t.Helper()\n\targs = append([]string{\n\t\t\"proj\", \"create\", a.context.name,\n\t}, args...)\n\n\tif a.context.destination != \"\" {\n\t\targs = append(args, \"--dest\", a.context.destination)\n\t}\n\n\treturn args\n}\n\nfunc (a *Actions) Delete() *Actions {\n\ta.context.t.Helper()\n\ta.runCli(\"proj\", \"delete\", a.context.name)\n\treturn a\n}\n\nfunc (a *Actions) And(block func()) *Actions {\n\ta.context.t.Helper()\n\tblock()\n\treturn a\n}\n\nfunc (a *Actions) Then() *Consequences {\n\ta.context.t.Helper()\n\treturn &Consequences{a.context, a}\n}\n\nfunc (a *Actions) runCli(args ...string) {\n\ta.context.t.Helper()\n\ta.lastOutput, a.lastError = fixture.RunCli(args...)\n}\n"], "fixing_code": ["package controller\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"fmt\"\n\t\"math\"\n\t\"net/http\"\n\t\"reflect\"\n\t\"runtime/debug\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\tclustercache \"github.com/argoproj/gitops-engine/pkg/cache\"\n\t\"github.com/argoproj/gitops-engine/pkg/diff\"\n\t\"github.com/argoproj/gitops-engine/pkg/health\"\n\tsynccommon \"github.com/argoproj/gitops-engine/pkg/sync/common\"\n\t\"github.com/argoproj/gitops-engine/pkg/utils/kube\"\n\tjsonpatch \"github.com/evanphx/json-patch\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"golang.org/x/sync/semaphore\"\n\tv1 \"k8s.io/api/core/v1\"\n\tapierr \"k8s.io/apimachinery/pkg/api/errors\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\n\t\"k8s.io/apimachinery/pkg/labels\"\n\tapiruntime \"k8s.io/apimachinery/pkg/runtime\"\n\t\"k8s.io/apimachinery/pkg/runtime/schema\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\t\"k8s.io/apimachinery/pkg/util/runtime\"\n\t\"k8s.io/apimachinery/pkg/util/wait\"\n\t\"k8s.io/apimachinery/pkg/watch\"\n\t\"k8s.io/client-go/kubernetes\"\n\t\"k8s.io/client-go/tools/cache\"\n\t\"k8s.io/client-go/util/workqueue\"\n\n\tstatecache \"github.com/argoproj/argo-cd/v2/controller/cache\"\n\t\"github.com/argoproj/argo-cd/v2/controller/metrics\"\n\t\"github.com/argoproj/argo-cd/v2/pkg/apis/application\"\n\tappv1 \"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1\"\n\tappclientset \"github.com/argoproj/argo-cd/v2/pkg/client/clientset/versioned\"\n\t\"github.com/argoproj/argo-cd/v2/pkg/client/informers/externalversions/application/v1alpha1\"\n\tapplisters \"github.com/argoproj/argo-cd/v2/pkg/client/listers/application/v1alpha1\"\n\t\"github.com/argoproj/argo-cd/v2/reposerver/apiclient\"\n\t\"github.com/argoproj/argo-cd/v2/util/argo\"\n\targodiff \"github.com/argoproj/argo-cd/v2/util/argo/diff\"\n\tappstatecache \"github.com/argoproj/argo-cd/v2/util/cache/appstate\"\n\t\"github.com/argoproj/argo-cd/v2/util/db\"\n\t\"github.com/argoproj/argo-cd/v2/util/errors\"\n\t\"github.com/argoproj/argo-cd/v2/util/glob\"\n\tlogutils \"github.com/argoproj/argo-cd/v2/util/log\"\n\tsettings_util \"github.com/argoproj/argo-cd/v2/util/settings\"\n)\n\nconst (\n\tupdateOperationStateTimeout = 1 * time.Second\n\t// orphanedIndex contains application which monitor orphaned resources by namespace\n\torphanedIndex = \"orphaned\"\n)\n\ntype CompareWith int\n\nconst (\n\t// Compare live application state against state defined in latest git revision with no resolved revision caching.\n\tCompareWithLatestForceResolve CompareWith = 3\n\t// Compare live application state against state defined in latest git revision.\n\tCompareWithLatest CompareWith = 2\n\t// Compare live application state against state defined using revision of most recent comparison.\n\tCompareWithRecent CompareWith = 1\n\t// Skip comparison and only refresh application resources tree\n\tComparisonWithNothing CompareWith = 0\n)\n\nfunc (a CompareWith) Max(b CompareWith) CompareWith {\n\treturn CompareWith(math.Max(float64(a), float64(b)))\n}\n\nfunc (a CompareWith) Pointer() *CompareWith {\n\treturn &a\n}\n\n// ApplicationController is the controller for application resources.\ntype ApplicationController struct {\n\tcache                *appstatecache.Cache\n\tnamespace            string\n\tkubeClientset        kubernetes.Interface\n\tkubectl              kube.Kubectl\n\tapplicationClientset appclientset.Interface\n\tauditLogger          *argo.AuditLogger\n\t// queue contains app namespace/name\n\tappRefreshQueue workqueue.RateLimitingInterface\n\t// queue contains app namespace/name/comparisonType and used to request app refresh with the predefined comparison type\n\tappComparisonTypeRefreshQueue workqueue.RateLimitingInterface\n\tappOperationQueue             workqueue.RateLimitingInterface\n\tprojectRefreshQueue           workqueue.RateLimitingInterface\n\tappInformer                   cache.SharedIndexInformer\n\tappLister                     applisters.ApplicationLister\n\tprojInformer                  cache.SharedIndexInformer\n\tappStateManager               AppStateManager\n\tstateCache                    statecache.LiveStateCache\n\tstatusRefreshTimeout          time.Duration\n\tselfHealTimeout               time.Duration\n\trepoClientset                 apiclient.Clientset\n\tdb                            db.ArgoDB\n\tsettingsMgr                   *settings_util.SettingsManager\n\trefreshRequestedApps          map[string]CompareWith\n\trefreshRequestedAppsMutex     *sync.Mutex\n\tmetricsServer                 *metrics.MetricsServer\n\tkubectlSemaphore              *semaphore.Weighted\n\tclusterFilter                 func(cluster *appv1.Cluster) bool\n\tprojByNameCache               sync.Map\n}\n\n// NewApplicationController creates new instance of ApplicationController.\nfunc NewApplicationController(\n\tnamespace string,\n\tsettingsMgr *settings_util.SettingsManager,\n\tkubeClientset kubernetes.Interface,\n\tapplicationClientset appclientset.Interface,\n\trepoClientset apiclient.Clientset,\n\targoCache *appstatecache.Cache,\n\tkubectl kube.Kubectl,\n\tappResyncPeriod time.Duration,\n\tselfHealTimeout time.Duration,\n\tmetricsPort int,\n\tmetricsCacheExpiration time.Duration,\n\tmetricsApplicationLabels []string,\n\tkubectlParallelismLimit int64,\n\tclusterFilter func(cluster *appv1.Cluster) bool,\n) (*ApplicationController, error) {\n\tlog.Infof(\"appResyncPeriod=%v\", appResyncPeriod)\n\tdb := db.NewDB(namespace, settingsMgr, kubeClientset)\n\tctrl := ApplicationController{\n\t\tcache:                         argoCache,\n\t\tnamespace:                     namespace,\n\t\tkubeClientset:                 kubeClientset,\n\t\tkubectl:                       kubectl,\n\t\tapplicationClientset:          applicationClientset,\n\t\trepoClientset:                 repoClientset,\n\t\tappRefreshQueue:               workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), \"app_reconciliation_queue\"),\n\t\tappOperationQueue:             workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), \"app_operation_processing_queue\"),\n\t\tprojectRefreshQueue:           workqueue.NewNamedRateLimitingQueue(workqueue.DefaultControllerRateLimiter(), \"project_reconciliation_queue\"),\n\t\tappComparisonTypeRefreshQueue: workqueue.NewRateLimitingQueue(workqueue.DefaultControllerRateLimiter()),\n\t\tdb:                            db,\n\t\tstatusRefreshTimeout:          appResyncPeriod,\n\t\trefreshRequestedApps:          make(map[string]CompareWith),\n\t\trefreshRequestedAppsMutex:     &sync.Mutex{},\n\t\tauditLogger:                   argo.NewAuditLogger(namespace, kubeClientset, \"argocd-application-controller\"),\n\t\tsettingsMgr:                   settingsMgr,\n\t\tselfHealTimeout:               selfHealTimeout,\n\t\tclusterFilter:                 clusterFilter,\n\t\tprojByNameCache:               sync.Map{},\n\t}\n\tif kubectlParallelismLimit > 0 {\n\t\tctrl.kubectlSemaphore = semaphore.NewWeighted(kubectlParallelismLimit)\n\t}\n\tkubectl.SetOnKubectlRun(ctrl.onKubectlRun)\n\tappInformer, appLister := ctrl.newApplicationInformerAndLister()\n\tindexers := cache.Indexers{cache.NamespaceIndex: cache.MetaNamespaceIndexFunc}\n\tprojInformer := v1alpha1.NewAppProjectInformer(applicationClientset, namespace, appResyncPeriod, indexers)\n\tprojInformer.AddEventHandler(cache.ResourceEventHandlerFuncs{\n\t\tAddFunc: func(obj interface{}) {\n\t\t\tif key, err := cache.MetaNamespaceKeyFunc(obj); err == nil {\n\t\t\t\tctrl.projectRefreshQueue.Add(key)\n\t\t\t\tif projMeta, ok := obj.(metav1.Object); ok {\n\t\t\t\t\tctrl.InvalidateProjectsCache(projMeta.GetName())\n\t\t\t\t}\n\n\t\t\t}\n\t\t},\n\t\tUpdateFunc: func(old, new interface{}) {\n\t\t\tif key, err := cache.MetaNamespaceKeyFunc(new); err == nil {\n\t\t\t\tctrl.projectRefreshQueue.Add(key)\n\t\t\t\tif projMeta, ok := new.(metav1.Object); ok {\n\t\t\t\t\tctrl.InvalidateProjectsCache(projMeta.GetName())\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tDeleteFunc: func(obj interface{}) {\n\t\t\tif key, err := cache.DeletionHandlingMetaNamespaceKeyFunc(obj); err == nil {\n\t\t\t\tctrl.projectRefreshQueue.Add(key)\n\t\t\t\tif projMeta, ok := obj.(metav1.Object); ok {\n\t\t\t\t\tctrl.InvalidateProjectsCache(projMeta.GetName())\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t})\n\tmetricsAddr := fmt.Sprintf(\"0.0.0.0:%d\", metricsPort)\n\tvar err error\n\tctrl.metricsServer, err = metrics.NewMetricsServer(metricsAddr, appLister, ctrl.canProcessApp, func(r *http.Request) error {\n\t\treturn nil\n\t}, metricsApplicationLabels)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif metricsCacheExpiration.Seconds() != 0 {\n\t\terr = ctrl.metricsServer.SetExpiration(metricsCacheExpiration)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\tstateCache := statecache.NewLiveStateCache(db, appInformer, ctrl.settingsMgr, kubectl, ctrl.metricsServer, ctrl.handleObjectUpdated, clusterFilter, argo.NewResourceTracking())\n\tappStateManager := NewAppStateManager(db, applicationClientset, repoClientset, namespace, kubectl, ctrl.settingsMgr, stateCache, projInformer, ctrl.metricsServer, argoCache, ctrl.statusRefreshTimeout, argo.NewResourceTracking())\n\tctrl.appInformer = appInformer\n\tctrl.appLister = appLister\n\tctrl.projInformer = projInformer\n\tctrl.appStateManager = appStateManager\n\tctrl.stateCache = stateCache\n\n\treturn &ctrl, nil\n}\n\nfunc (ctrl *ApplicationController) InvalidateProjectsCache(names ...string) {\n\tif len(names) > 0 {\n\t\tfor _, name := range names {\n\t\t\tctrl.projByNameCache.Delete(name)\n\t\t}\n\t} else {\n\t\tctrl.projByNameCache.Range(func(key, _ interface{}) bool {\n\t\t\tctrl.projByNameCache.Delete(key)\n\t\t\treturn true\n\t\t})\n\t}\n}\n\nfunc (ctrl *ApplicationController) GetMetricsServer() *metrics.MetricsServer {\n\treturn ctrl.metricsServer\n}\n\nfunc (ctrl *ApplicationController) onKubectlRun(command string) (kube.CleanupFunc, error) {\n\tctrl.metricsServer.IncKubectlExec(command)\n\tif ctrl.kubectlSemaphore != nil {\n\t\tif err := ctrl.kubectlSemaphore.Acquire(context.Background(), 1); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tctrl.metricsServer.IncKubectlExecPending(command)\n\t}\n\treturn func() {\n\t\tif ctrl.kubectlSemaphore != nil {\n\t\t\tctrl.kubectlSemaphore.Release(1)\n\t\t\tctrl.metricsServer.DecKubectlExecPending(command)\n\t\t}\n\t}, nil\n}\n\nfunc isSelfReferencedApp(app *appv1.Application, ref v1.ObjectReference) bool {\n\tgvk := ref.GroupVersionKind()\n\treturn ref.UID == app.UID &&\n\t\tref.Name == app.Name &&\n\t\tref.Namespace == app.Namespace &&\n\t\tgvk.Group == application.Group &&\n\t\tgvk.Kind == application.ApplicationKind\n}\n\nfunc (ctrl *ApplicationController) newAppProjCache(name string) *appProjCache {\n\treturn &appProjCache{name: name, ctrl: ctrl}\n}\n\ntype appProjCache struct {\n\tname string\n\tctrl *ApplicationController\n\n\tlock    sync.Mutex\n\tappProj *appv1.AppProject\n}\n\nfunc (projCache *appProjCache) GetAppProject(ctx context.Context) (*appv1.AppProject, error) {\n\tprojCache.lock.Lock()\n\tdefer projCache.lock.Unlock()\n\tif projCache.appProj != nil {\n\t\treturn projCache.appProj, nil\n\t}\n\tproj, err := argo.GetAppProjectByName(projCache.name, applisters.NewAppProjectLister(projCache.ctrl.projInformer.GetIndexer()), projCache.ctrl.namespace, projCache.ctrl.settingsMgr, projCache.ctrl.db, ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tprojCache.appProj = proj\n\treturn projCache.appProj, nil\n}\n\nfunc (ctrl *ApplicationController) getAppProj(app *appv1.Application) (*appv1.AppProject, error) {\n\tprojCache, _ := ctrl.projByNameCache.LoadOrStore(app.Spec.GetProject(), ctrl.newAppProjCache(app.Spec.GetProject()))\n\treturn projCache.(*appProjCache).GetAppProject(context.TODO())\n}\n\nfunc (ctrl *ApplicationController) handleObjectUpdated(managedByApp map[string]bool, ref v1.ObjectReference) {\n\t// if namespaced resource is not managed by any app it might be orphaned resource of some other apps\n\tif len(managedByApp) == 0 && ref.Namespace != \"\" {\n\t\t// retrieve applications which monitor orphaned resources in the same namespace and refresh them unless resource is denied in app project\n\t\tif objs, err := ctrl.appInformer.GetIndexer().ByIndex(orphanedIndex, ref.Namespace); err == nil {\n\t\t\tfor i := range objs {\n\t\t\t\tapp, ok := objs[i].(*appv1.Application)\n\t\t\t\tif !ok {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tmanagedByApp[app.Name] = true\n\t\t\t}\n\t\t}\n\t}\n\tfor appName, isManagedResource := range managedByApp {\n\t\tobj, exists, err := ctrl.appInformer.GetIndexer().GetByKey(ctrl.namespace + \"/\" + appName)\n\t\tif app, ok := obj.(*appv1.Application); exists && err == nil && ok && isSelfReferencedApp(app, ref) {\n\t\t\t// Don't force refresh app if related resource is application itself. This prevents infinite reconciliation loop.\n\t\t\tcontinue\n\t\t}\n\n\t\tif !ctrl.canProcessApp(obj) {\n\t\t\t// Don't force refresh app if app belongs to a different controller shard\n\t\t\tcontinue\n\t\t}\n\n\t\tlevel := ComparisonWithNothing\n\t\tif isManagedResource {\n\t\t\tlevel = CompareWithRecent\n\t\t}\n\n\t\t// Additional check for debug level so we don't need to evaluate the\n\t\t// format string in case of non-debug scenarios\n\t\tif log.GetLevel() >= log.DebugLevel {\n\t\t\tvar resKey string\n\t\t\tif ref.Namespace != \"\" {\n\t\t\t\tresKey = ref.Namespace + \"/\" + ref.Name\n\t\t\t} else {\n\t\t\t\tresKey = \"(cluster-scoped)/\" + ref.Name\n\t\t\t}\n\t\t\tlog.Debugf(\"Refreshing app %s for change in cluster of object %s of type %s/%s\", appName, resKey, ref.APIVersion, ref.Kind)\n\t\t}\n\n\t\tctrl.requestAppRefresh(appName, &level, nil)\n\t}\n}\n\n// setAppManagedResources will build a list of ResourceDiff based on the provided comparisonResult\n// and persist app resources related data in the cache. Will return the persisted ApplicationTree.\nfunc (ctrl *ApplicationController) setAppManagedResources(a *appv1.Application, comparisonResult *comparisonResult) (*appv1.ApplicationTree, error) {\n\tmanagedResources, err := ctrl.hideSecretData(a, comparisonResult)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error getting managed resources: %s\", err)\n\t}\n\ttree, err := ctrl.getResourceTree(a, managedResources)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error getting resource tree: %s\", err)\n\t}\n\terr = ctrl.cache.SetAppResourcesTree(a.Name, tree)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error setting app resource tree: %s\", err)\n\t}\n\terr = ctrl.cache.SetAppManagedResources(a.Name, managedResources)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error setting app managed resources: %s\", err)\n\t}\n\treturn tree, nil\n}\n\n// returns true of given resources exist in the namespace by default and not managed by the user\nfunc isKnownOrphanedResourceExclusion(key kube.ResourceKey, proj *appv1.AppProject) bool {\n\tif key.Namespace == \"default\" && key.Group == \"\" && key.Kind == kube.ServiceKind && key.Name == \"kubernetes\" {\n\t\treturn true\n\t}\n\tif key.Group == \"\" && key.Kind == kube.ServiceAccountKind && key.Name == \"default\" {\n\t\treturn true\n\t}\n\tif key.Group == \"\" && key.Kind == \"ConfigMap\" && key.Name == \"kube-root-ca.crt\" {\n\t\treturn true\n\t}\n\tlist := proj.Spec.OrphanedResources.Ignore\n\tfor _, item := range list {\n\t\tif item.Kind == \"\" || glob.Match(item.Kind, key.Kind) {\n\t\t\tif glob.Match(item.Group, key.Group) {\n\t\t\t\tif item.Name == \"\" || glob.Match(item.Name, key.Name) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (ctrl *ApplicationController) getResourceTree(a *appv1.Application, managedResources []*appv1.ResourceDiff) (*appv1.ApplicationTree, error) {\n\tnodes := make([]appv1.ResourceNode, 0)\n\n\tproj, err := ctrl.getAppProj(a)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\torphanedNodesMap := make(map[kube.ResourceKey]appv1.ResourceNode)\n\twarnOrphaned := true\n\tif proj.Spec.OrphanedResources != nil {\n\t\torphanedNodesMap, err = ctrl.stateCache.GetNamespaceTopLevelResources(a.Spec.Destination.Server, a.Spec.Destination.Namespace)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\twarnOrphaned = proj.Spec.OrphanedResources.IsWarn()\n\t}\n\n\tfor i := range managedResources {\n\t\tmanagedResource := managedResources[i]\n\t\tdelete(orphanedNodesMap, kube.NewResourceKey(managedResource.Group, managedResource.Kind, managedResource.Namespace, managedResource.Name))\n\t\tvar live = &unstructured.Unstructured{}\n\t\terr := json.Unmarshal([]byte(managedResource.LiveState), &live)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tvar target = &unstructured.Unstructured{}\n\t\terr = json.Unmarshal([]byte(managedResource.TargetState), &target)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tif live == nil {\n\t\t\tnodes = append(nodes, appv1.ResourceNode{\n\t\t\t\tResourceRef: appv1.ResourceRef{\n\t\t\t\t\tVersion:   target.GroupVersionKind().Version,\n\t\t\t\t\tName:      managedResource.Name,\n\t\t\t\t\tKind:      managedResource.Kind,\n\t\t\t\t\tGroup:     managedResource.Group,\n\t\t\t\t\tNamespace: managedResource.Namespace,\n\t\t\t\t},\n\t\t\t})\n\t\t} else {\n\t\t\terr := ctrl.stateCache.IterateHierarchy(a.Spec.Destination.Server, kube.GetResourceKey(live), func(child appv1.ResourceNode, appName string) bool {\n\t\t\t\tif !proj.IsResourcePermitted(schema.GroupKind{Group: child.ResourceRef.Group, Kind: child.ResourceRef.Kind}, child.Namespace, a.Spec.Destination) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\tnodes = append(nodes, child)\n\t\t\t\treturn true\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\torphanedNodes := make([]appv1.ResourceNode, 0)\n\tfor k := range orphanedNodesMap {\n\t\tif k.Namespace != \"\" && proj.IsGroupKindPermitted(k.GroupKind(), true) && !isKnownOrphanedResourceExclusion(k, proj) {\n\t\t\terr := ctrl.stateCache.IterateHierarchy(a.Spec.Destination.Server, k, func(child appv1.ResourceNode, appName string) bool {\n\t\t\t\tbelongToAnotherApp := false\n\t\t\t\tif appName != \"\" {\n\t\t\t\t\tif _, exists, err := ctrl.appInformer.GetIndexer().GetByKey(ctrl.namespace + \"/\" + appName); exists && err == nil {\n\t\t\t\t\t\tbelongToAnotherApp = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif belongToAnotherApp || !proj.IsResourcePermitted(schema.GroupKind{Group: child.ResourceRef.Group, Kind: child.ResourceRef.Kind}, child.Namespace, a.Spec.Destination) {\n\t\t\t\t\treturn false\n\t\t\t\t}\n\t\t\t\torphanedNodes = append(orphanedNodes, child)\n\t\t\t\treturn true\n\t\t\t})\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t}\n\t}\n\tvar conditions []appv1.ApplicationCondition\n\tif len(orphanedNodes) > 0 && warnOrphaned {\n\t\tconditions = []appv1.ApplicationCondition{{\n\t\t\tType:    appv1.ApplicationConditionOrphanedResourceWarning,\n\t\t\tMessage: fmt.Sprintf(\"Application has %d orphaned resources\", len(orphanedNodes)),\n\t\t}}\n\t}\n\ta.Status.SetConditions(conditions, map[appv1.ApplicationConditionType]bool{appv1.ApplicationConditionOrphanedResourceWarning: true})\n\tsort.Slice(orphanedNodes, func(i, j int) bool {\n\t\treturn orphanedNodes[i].ResourceRef.String() < orphanedNodes[j].ResourceRef.String()\n\t})\n\n\thosts, err := ctrl.getAppHosts(a, nodes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &appv1.ApplicationTree{Nodes: nodes, OrphanedNodes: orphanedNodes, Hosts: hosts}, nil\n}\n\nfunc (ctrl *ApplicationController) getAppHosts(a *appv1.Application, appNodes []appv1.ResourceNode) ([]appv1.HostInfo, error) {\n\tsupportedResourceNames := map[v1.ResourceName]bool{\n\t\tv1.ResourceCPU:     true,\n\t\tv1.ResourceStorage: true,\n\t\tv1.ResourceMemory:  true,\n\t}\n\tappPods := map[kube.ResourceKey]bool{}\n\tfor _, node := range appNodes {\n\t\tif node.Group == \"\" && node.Kind == kube.PodKind {\n\t\t\tappPods[kube.NewResourceKey(node.Group, node.Kind, node.Namespace, node.Name)] = true\n\t\t}\n\t}\n\n\tallNodesInfo := map[string]statecache.NodeInfo{}\n\tallPodsByNode := map[string][]statecache.PodInfo{}\n\tappPodsByNode := map[string][]statecache.PodInfo{}\n\terr := ctrl.stateCache.IterateResources(a.Spec.Destination.Server, func(res *clustercache.Resource, info *statecache.ResourceInfo) {\n\t\tkey := res.ResourceKey()\n\n\t\tswitch {\n\t\tcase info.NodeInfo != nil && key.Group == \"\" && key.Kind == \"Node\":\n\t\t\tallNodesInfo[key.Name] = *info.NodeInfo\n\t\tcase info.PodInfo != nil && key.Group == \"\" && key.Kind == kube.PodKind:\n\t\t\tif appPods[key] {\n\t\t\t\tappPodsByNode[info.PodInfo.NodeName] = append(appPodsByNode[info.PodInfo.NodeName], *info.PodInfo)\n\t\t\t} else {\n\t\t\t\tallPodsByNode[info.PodInfo.NodeName] = append(allPodsByNode[info.PodInfo.NodeName], *info.PodInfo)\n\t\t\t}\n\t\t}\n\t})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar hosts []appv1.HostInfo\n\tfor nodeName, appPods := range appPodsByNode {\n\t\tnode, ok := allNodesInfo[nodeName]\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\n\t\tneighbors := allPodsByNode[nodeName]\n\n\t\tresources := map[v1.ResourceName]appv1.HostResourceInfo{}\n\t\tfor name, resource := range node.Capacity {\n\t\t\tinfo := resources[name]\n\t\t\tinfo.ResourceName = name\n\t\t\tinfo.Capacity += resource.MilliValue()\n\t\t\tresources[name] = info\n\t\t}\n\n\t\tfor _, pod := range appPods {\n\t\t\tfor name, resource := range pod.ResourceRequests {\n\t\t\t\tif !supportedResourceNames[name] {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\n\t\t\t\tinfo := resources[name]\n\t\t\t\tinfo.RequestedByApp += resource.MilliValue()\n\t\t\t\tresources[name] = info\n\t\t\t}\n\t\t}\n\n\t\tfor _, pod := range neighbors {\n\t\t\tfor name, resource := range pod.ResourceRequests {\n\t\t\t\tif !supportedResourceNames[name] || pod.Phase == v1.PodSucceeded || pod.Phase == v1.PodFailed {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tinfo := resources[name]\n\t\t\t\tinfo.RequestedByNeighbors += resource.MilliValue()\n\t\t\t\tresources[name] = info\n\t\t\t}\n\t\t}\n\n\t\tvar resourcesInfo []appv1.HostResourceInfo\n\t\tfor _, info := range resources {\n\t\t\tif supportedResourceNames[info.ResourceName] && info.Capacity > 0 {\n\t\t\t\tresourcesInfo = append(resourcesInfo, info)\n\t\t\t}\n\t\t}\n\t\tsort.Slice(resourcesInfo, func(i, j int) bool {\n\t\t\treturn resourcesInfo[i].ResourceName < resourcesInfo[j].ResourceName\n\t\t})\n\t\thosts = append(hosts, appv1.HostInfo{Name: nodeName, SystemInfo: node.SystemInfo, ResourcesInfo: resourcesInfo})\n\t}\n\treturn hosts, nil\n}\n\nfunc (ctrl *ApplicationController) hideSecretData(app *appv1.Application, comparisonResult *comparisonResult) ([]*appv1.ResourceDiff, error) {\n\titems := make([]*appv1.ResourceDiff, len(comparisonResult.managedResources))\n\tfor i := range comparisonResult.managedResources {\n\t\tres := comparisonResult.managedResources[i]\n\t\titem := appv1.ResourceDiff{\n\t\t\tNamespace:       res.Namespace,\n\t\t\tName:            res.Name,\n\t\t\tGroup:           res.Group,\n\t\t\tKind:            res.Kind,\n\t\t\tHook:            res.Hook,\n\t\t\tResourceVersion: res.ResourceVersion,\n\t\t}\n\n\t\ttarget := res.Target\n\t\tlive := res.Live\n\t\tresDiff := res.Diff\n\t\tif res.Kind == kube.SecretKind && res.Group == \"\" {\n\t\t\tvar err error\n\t\t\ttarget, live, err = diff.HideSecretData(res.Target, res.Live)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error hiding secret data: %s\", err)\n\t\t\t}\n\t\t\tcompareOptions, err := ctrl.settingsMgr.GetResourceCompareOptions()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error getting resource compare options: %s\", err)\n\t\t\t}\n\t\t\tresourceOverrides, err := ctrl.settingsMgr.GetResourceOverrides()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error getting resource overrides: %s\", err)\n\t\t\t}\n\t\t\tappLabelKey, err := ctrl.settingsMgr.GetAppInstanceLabelKey()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error getting app instance label key: %s\", err)\n\t\t\t}\n\t\t\ttrackingMethod, err := ctrl.settingsMgr.GetTrackingMethod()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error getting tracking method: %s\", err)\n\t\t\t}\n\n\t\t\tdiffConfig, err := argodiff.NewDiffConfigBuilder().\n\t\t\t\tWithDiffSettings(app.Spec.IgnoreDifferences, resourceOverrides, compareOptions.IgnoreAggregatedRoles).\n\t\t\t\tWithTracking(appLabelKey, trackingMethod).\n\t\t\t\tWithNoCache().\n\t\t\t\tWithLogger(logutils.NewLogrusLogger(logutils.NewWithCurrentConfig())).\n\t\t\t\tBuild()\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"appcontroller error building diff config: %s\", err)\n\t\t\t}\n\n\t\t\tdiffResult, err := argodiff.StateDiff(live, target, diffConfig)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error applying diff: %s\", err)\n\t\t\t}\n\t\t\tresDiff = diffResult\n\t\t}\n\n\t\tif live != nil {\n\t\t\tdata, err := json.Marshal(live)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error marshaling live json: %s\", err)\n\t\t\t}\n\t\t\titem.LiveState = string(data)\n\t\t} else {\n\t\t\titem.LiveState = \"null\"\n\t\t}\n\n\t\tif target != nil {\n\t\t\tdata, err := json.Marshal(target)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, fmt.Errorf(\"error marshaling target json: %s\", err)\n\t\t\t}\n\t\t\titem.TargetState = string(data)\n\t\t} else {\n\t\t\titem.TargetState = \"null\"\n\t\t}\n\t\titem.PredictedLiveState = string(resDiff.PredictedLive)\n\t\titem.NormalizedLiveState = string(resDiff.NormalizedLive)\n\t\titem.Modified = resDiff.Modified\n\n\t\titems[i] = &item\n\t}\n\treturn items, nil\n}\n\n// Run starts the Application CRD controller.\nfunc (ctrl *ApplicationController) Run(ctx context.Context, statusProcessors int, operationProcessors int) {\n\tdefer runtime.HandleCrash()\n\tdefer ctrl.appRefreshQueue.ShutDown()\n\tdefer ctrl.appComparisonTypeRefreshQueue.ShutDown()\n\tdefer ctrl.appOperationQueue.ShutDown()\n\tdefer ctrl.projectRefreshQueue.ShutDown()\n\n\tctrl.metricsServer.RegisterClustersInfoSource(ctx, ctrl.stateCache)\n\tctrl.RegisterClusterSecretUpdater(ctx)\n\n\tgo ctrl.appInformer.Run(ctx.Done())\n\tgo ctrl.projInformer.Run(ctx.Done())\n\n\terrors.CheckError(ctrl.stateCache.Init())\n\n\tif !cache.WaitForCacheSync(ctx.Done(), ctrl.appInformer.HasSynced, ctrl.projInformer.HasSynced) {\n\t\tlog.Error(\"Timed out waiting for caches to sync\")\n\t\treturn\n\t}\n\n\tgo func() { errors.CheckError(ctrl.stateCache.Run(ctx)) }()\n\tgo func() { errors.CheckError(ctrl.metricsServer.ListenAndServe()) }()\n\n\tfor i := 0; i < statusProcessors; i++ {\n\t\tgo wait.Until(func() {\n\t\t\tfor ctrl.processAppRefreshQueueItem() {\n\t\t\t}\n\t\t}, time.Second, ctx.Done())\n\t}\n\n\tfor i := 0; i < operationProcessors; i++ {\n\t\tgo wait.Until(func() {\n\t\t\tfor ctrl.processAppOperationQueueItem() {\n\t\t\t}\n\t\t}, time.Second, ctx.Done())\n\t}\n\n\tgo wait.Until(func() {\n\t\tfor ctrl.processAppComparisonTypeQueueItem() {\n\t\t}\n\t}, time.Second, ctx.Done())\n\n\tgo wait.Until(func() {\n\t\tfor ctrl.processProjectQueueItem() {\n\t\t}\n\t}, time.Second, ctx.Done())\n\t<-ctx.Done()\n}\n\nfunc (ctrl *ApplicationController) requestAppRefresh(appName string, compareWith *CompareWith, after *time.Duration) {\n\tkey := fmt.Sprintf(\"%s/%s\", ctrl.namespace, appName)\n\n\tif compareWith != nil && after != nil {\n\t\tctrl.appComparisonTypeRefreshQueue.AddAfter(fmt.Sprintf(\"%s/%d\", key, compareWith), *after)\n\t} else {\n\t\tif compareWith != nil {\n\t\t\tctrl.refreshRequestedAppsMutex.Lock()\n\t\t\tctrl.refreshRequestedApps[appName] = compareWith.Max(ctrl.refreshRequestedApps[appName])\n\t\t\tctrl.refreshRequestedAppsMutex.Unlock()\n\t\t}\n\t\tif after != nil {\n\t\t\tctrl.appRefreshQueue.AddAfter(key, *after)\n\t\t\tctrl.appOperationQueue.AddAfter(key, *after)\n\t\t} else {\n\t\t\tctrl.appRefreshQueue.Add(key)\n\t\t\tctrl.appOperationQueue.Add(key)\n\t\t}\n\t}\n}\n\nfunc (ctrl *ApplicationController) isRefreshRequested(appName string) (bool, CompareWith) {\n\tctrl.refreshRequestedAppsMutex.Lock()\n\tdefer ctrl.refreshRequestedAppsMutex.Unlock()\n\tlevel, ok := ctrl.refreshRequestedApps[appName]\n\tif ok {\n\t\tdelete(ctrl.refreshRequestedApps, appName)\n\t}\n\treturn ok, level\n}\n\nfunc (ctrl *ApplicationController) processAppOperationQueueItem() (processNext bool) {\n\tappKey, shutdown := ctrl.appOperationQueue.Get()\n\tif shutdown {\n\t\tprocessNext = false\n\t\treturn\n\t}\n\tprocessNext = true\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tlog.Errorf(\"Recovered from panic: %+v\\n%s\", r, debug.Stack())\n\t\t}\n\t\tctrl.appOperationQueue.Done(appKey)\n\t}()\n\n\tobj, exists, err := ctrl.appInformer.GetIndexer().GetByKey(appKey.(string))\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to get application '%s' from informer index: %+v\", appKey, err)\n\t\treturn\n\t}\n\tif !exists {\n\t\t// This happens after app was deleted, but the work queue still had an entry for it.\n\t\treturn\n\t}\n\torigApp, ok := obj.(*appv1.Application)\n\tif !ok {\n\t\tlog.Warnf(\"Key '%s' in index is not an application\", appKey)\n\t\treturn\n\t}\n\tapp := origApp.DeepCopy()\n\n\tif app.Operation != nil {\n\t\t// If we get here, we are about process an operation but we cannot rely on informer since it might has stale data.\n\t\t// So always retrieve the latest version to ensure it is not stale to avoid unnecessary syncing.\n\t\t// We cannot rely on informer since applications might be updated by both application controller and api server.\n\t\tfreshApp, err := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(ctrl.namespace).Get(context.Background(), app.ObjectMeta.Name, metav1.GetOptions{})\n\t\tif err != nil {\n\t\t\tlog.Errorf(\"Failed to retrieve latest application state: %v\", err)\n\t\t\treturn\n\t\t}\n\t\tapp = freshApp\n\t}\n\n\tif app.Operation != nil {\n\t\tctrl.processRequestedAppOperation(app)\n\t} else if app.DeletionTimestamp != nil && app.CascadedDeletion() {\n\t\t_, err = ctrl.finalizeApplicationDeletion(app)\n\t\tif err != nil {\n\t\t\tctrl.setAppCondition(app, appv1.ApplicationCondition{\n\t\t\t\tType:    appv1.ApplicationConditionDeletionError,\n\t\t\t\tMessage: err.Error(),\n\t\t\t})\n\t\t\tmessage := fmt.Sprintf(\"Unable to delete application resources: %v\", err.Error())\n\t\t\tctrl.auditLogger.LogAppEvent(app, argo.EventInfo{Reason: argo.EventReasonStatusRefreshed, Type: v1.EventTypeWarning}, message)\n\t\t}\n\t}\n\treturn\n}\n\nfunc (ctrl *ApplicationController) processAppComparisonTypeQueueItem() (processNext bool) {\n\tkey, shutdown := ctrl.appComparisonTypeRefreshQueue.Get()\n\tprocessNext = true\n\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tlog.Errorf(\"Recovered from panic: %+v\\n%s\", r, debug.Stack())\n\t\t}\n\t\tctrl.appComparisonTypeRefreshQueue.Done(key)\n\t}()\n\tif shutdown {\n\t\tprocessNext = false\n\t\treturn\n\t}\n\n\tif parts := strings.Split(key.(string), \"/\"); len(parts) != 3 {\n\t\tlog.Warnf(\"Unexpected key format in appComparisonTypeRefreshTypeQueue. Key should consists of namespace/name/comparisonType but got: %s\", key.(string))\n\t} else {\n\t\tif compareWith, err := strconv.Atoi(parts[2]); err != nil {\n\t\t\tlog.Warnf(\"Unable to parse comparison type: %v\", err)\n\t\t\treturn\n\t\t} else {\n\t\t\tctrl.requestAppRefresh(parts[1], CompareWith(compareWith).Pointer(), nil)\n\t\t}\n\t}\n\treturn\n}\n\nfunc (ctrl *ApplicationController) processProjectQueueItem() (processNext bool) {\n\tkey, shutdown := ctrl.projectRefreshQueue.Get()\n\tprocessNext = true\n\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tlog.Errorf(\"Recovered from panic: %+v\\n%s\", r, debug.Stack())\n\t\t}\n\t\tctrl.projectRefreshQueue.Done(key)\n\t}()\n\tif shutdown {\n\t\tprocessNext = false\n\t\treturn\n\t}\n\tobj, exists, err := ctrl.projInformer.GetIndexer().GetByKey(key.(string))\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to get project '%s' from informer index: %+v\", key, err)\n\t\treturn\n\t}\n\tif !exists {\n\t\t// This happens after appproj was deleted, but the work queue still had an entry for it.\n\t\treturn\n\t}\n\torigProj, ok := obj.(*appv1.AppProject)\n\tif !ok {\n\t\tlog.Warnf(\"Key '%s' in index is not an appproject\", key)\n\t\treturn\n\t}\n\n\tif origProj.DeletionTimestamp != nil && origProj.HasFinalizer() {\n\t\tif err := ctrl.finalizeProjectDeletion(origProj.DeepCopy()); err != nil {\n\t\t\tlog.Warnf(\"Failed to finalize project deletion: %v\", err)\n\t\t}\n\t}\n\treturn\n}\n\nfunc (ctrl *ApplicationController) finalizeProjectDeletion(proj *appv1.AppProject) error {\n\tapps, err := ctrl.appLister.Applications(ctrl.namespace).List(labels.Everything())\n\tif err != nil {\n\t\treturn err\n\t}\n\tappsCount := 0\n\tfor i := range apps {\n\t\tif apps[i].Spec.GetProject() == proj.Name {\n\t\t\tappsCount++\n\t\t}\n\t}\n\tif appsCount == 0 {\n\t\treturn ctrl.removeProjectFinalizer(proj)\n\t} else {\n\t\tlog.Infof(\"Cannot remove project '%s' finalizer as is referenced by %d applications\", proj.Name, appsCount)\n\t}\n\treturn nil\n}\n\nfunc (ctrl *ApplicationController) removeProjectFinalizer(proj *appv1.AppProject) error {\n\tproj.RemoveFinalizer()\n\tvar patch []byte\n\tpatch, _ = json.Marshal(map[string]interface{}{\n\t\t\"metadata\": map[string]interface{}{\n\t\t\t\"finalizers\": proj.Finalizers,\n\t\t},\n\t})\n\t_, err := ctrl.applicationClientset.ArgoprojV1alpha1().AppProjects(ctrl.namespace).Patch(context.Background(), proj.Name, types.MergePatchType, patch, metav1.PatchOptions{})\n\treturn err\n}\n\n// shouldBeDeleted returns whether a given resource obj should be deleted on cascade delete of application app\nfunc (ctrl *ApplicationController) shouldBeDeleted(app *appv1.Application, obj *unstructured.Unstructured) bool {\n\treturn !kube.IsCRD(obj) && !isSelfReferencedApp(app, kube.GetObjectRef(obj))\n}\n\nfunc (ctrl *ApplicationController) getPermittedAppLiveObjects(app *appv1.Application, proj *appv1.AppProject) (map[kube.ResourceKey]*unstructured.Unstructured, error) {\n\tobjsMap, err := ctrl.stateCache.GetManagedLiveObjs(app, []*unstructured.Unstructured{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// Don't delete live resources which are not permitted in the app project\n\tfor k, v := range objsMap {\n\t\tif !proj.IsLiveResourcePermitted(v, app.Spec.Destination.Server, app.Spec.Destination.Name) {\n\t\t\tdelete(objsMap, k)\n\t\t}\n\t}\n\treturn objsMap, nil\n}\n\nfunc (ctrl *ApplicationController) finalizeApplicationDeletion(app *appv1.Application) ([]*unstructured.Unstructured, error) {\n\tlogCtx := log.WithField(\"application\", app.Name)\n\tlogCtx.Infof(\"Deleting resources\")\n\t// Get refreshed application info, since informer app copy might be stale\n\tapp, err := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(app.Namespace).Get(context.Background(), app.Name, metav1.GetOptions{})\n\tif err != nil {\n\t\tif !apierr.IsNotFound(err) {\n\t\t\tlogCtx.Errorf(\"Unable to get refreshed application info prior deleting resources: %v\", err)\n\t\t}\n\t\treturn nil, nil\n\t}\n\tproj, err := ctrl.getAppProj(app)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// validDestination is true if the Application destination points to a cluster that is managed by Argo CD\n\t// (and thus either a cluster secret exists for it, or it's local); validDestination is false otherwise.\n\tvalidDestination := true\n\n\t// Validate the cluster using the Application destination's `name` field, if applicable,\n\t// and set the Server field, if needed.\n\tif err := argo.ValidateDestination(context.Background(), &app.Spec.Destination, ctrl.db); err != nil {\n\t\tlog.Warnf(\"Unable to validate destination of the Application being deleted: %v\", err)\n\t\tvalidDestination = false\n\t}\n\n\tobjs := make([]*unstructured.Unstructured, 0)\n\tvar cluster *appv1.Cluster\n\n\t// Attempt to validate the destination via its URL\n\tif validDestination {\n\t\tif cluster, err = ctrl.db.GetCluster(context.Background(), app.Spec.Destination.Server); err != nil {\n\t\t\tlog.Warnf(\"Unable to locate cluster URL for Application being deleted: %v\", err)\n\t\t\tvalidDestination = false\n\t\t}\n\t}\n\n\tif validDestination {\n\t\t// ApplicationDestination points to a valid cluster, so we may clean up the live objects\n\n\t\tobjsMap, err := ctrl.getPermittedAppLiveObjects(app, proj)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfor k := range objsMap {\n\t\t\t// Wait for objects pending deletion to complete before proceeding with next sync wave\n\t\t\tif objsMap[k].GetDeletionTimestamp() != nil {\n\t\t\t\tlogCtx.Infof(\"%d objects remaining for deletion\", len(objsMap))\n\t\t\t\treturn objs, nil\n\t\t\t}\n\n\t\t\tif ctrl.shouldBeDeleted(app, objsMap[k]) {\n\t\t\t\tobjs = append(objs, objsMap[k])\n\t\t\t}\n\t\t}\n\n\t\tconfig := metrics.AddMetricsTransportWrapper(ctrl.metricsServer, app, cluster.RESTConfig())\n\n\t\tfilteredObjs := FilterObjectsForDeletion(objs)\n\n\t\tpropagationPolicy := metav1.DeletePropagationForeground\n\t\tif app.GetPropagationPolicy() == appv1.BackgroundPropagationPolicyFinalizer {\n\t\t\tpropagationPolicy = metav1.DeletePropagationBackground\n\t\t}\n\t\tlogCtx.Infof(\"Deleting application's resources with %s propagation policy\", propagationPolicy)\n\n\t\terr = kube.RunAllAsync(len(filteredObjs), func(i int) error {\n\t\t\tobj := filteredObjs[i]\n\t\t\treturn ctrl.kubectl.DeleteResource(context.Background(), config, obj.GroupVersionKind(), obj.GetName(), obj.GetNamespace(), metav1.DeleteOptions{PropagationPolicy: &propagationPolicy})\n\t\t})\n\t\tif err != nil {\n\t\t\treturn objs, err\n\t\t}\n\n\t\tobjsMap, err = ctrl.getPermittedAppLiveObjects(app, proj)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tfor k, obj := range objsMap {\n\t\t\tif !ctrl.shouldBeDeleted(app, obj) {\n\t\t\t\tdelete(objsMap, k)\n\t\t\t}\n\t\t}\n\t\tif len(objsMap) > 0 {\n\t\t\tlogCtx.Infof(\"%d objects remaining for deletion\", len(objsMap))\n\t\t\treturn objs, nil\n\t\t}\n\t}\n\n\tif err := ctrl.cache.SetAppManagedResources(app.Name, nil); err != nil {\n\t\treturn objs, err\n\t}\n\n\tif err := ctrl.cache.SetAppResourcesTree(app.Name, nil); err != nil {\n\t\treturn objs, err\n\t}\n\n\tif err := ctrl.removeCascadeFinalizer(app); err != nil {\n\t\treturn objs, err\n\t}\n\n\tif validDestination {\n\t\tlogCtx.Infof(\"Successfully deleted %d resources\", len(objs))\n\t} else {\n\t\tlogCtx.Infof(\"Resource entries removed from undefined cluster\")\n\t}\n\n\tctrl.projectRefreshQueue.Add(fmt.Sprintf(\"%s/%s\", app.Namespace, app.Spec.GetProject()))\n\treturn objs, nil\n}\n\nfunc (ctrl *ApplicationController) removeCascadeFinalizer(app *appv1.Application) error {\n\tapp.UnSetCascadedDeletion()\n\tvar patch []byte\n\tpatch, _ = json.Marshal(map[string]interface{}{\n\t\t\"metadata\": map[string]interface{}{\n\t\t\t\"finalizers\": app.Finalizers,\n\t\t},\n\t})\n\n\t_, err := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(app.Namespace).Patch(context.Background(), app.Name, types.MergePatchType, patch, metav1.PatchOptions{})\n\treturn err\n}\n\nfunc (ctrl *ApplicationController) setAppCondition(app *appv1.Application, condition appv1.ApplicationCondition) {\n\t// do nothing if app already has same condition\n\tfor _, c := range app.Status.Conditions {\n\t\tif c.Message == condition.Message && c.Type == condition.Type {\n\t\t\treturn\n\t\t}\n\t}\n\n\tapp.Status.SetConditions([]appv1.ApplicationCondition{condition}, map[appv1.ApplicationConditionType]bool{condition.Type: true})\n\n\tvar patch []byte\n\tpatch, err := json.Marshal(map[string]interface{}{\n\t\t\"status\": map[string]interface{}{\n\t\t\t\"conditions\": app.Status.Conditions,\n\t\t},\n\t})\n\tif err == nil {\n\t\t_, err = ctrl.applicationClientset.ArgoprojV1alpha1().Applications(app.Namespace).Patch(context.Background(), app.Name, types.MergePatchType, patch, metav1.PatchOptions{})\n\t}\n\tif err != nil {\n\t\tlog.Errorf(\"Unable to set application condition: %v\", err)\n\t}\n}\n\nfunc (ctrl *ApplicationController) processRequestedAppOperation(app *appv1.Application) {\n\tlogCtx := log.WithField(\"application\", app.Name)\n\tvar state *appv1.OperationState\n\t// Recover from any unexpected panics and automatically set the status to be failed\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tlogCtx.Errorf(\"Recovered from panic: %+v\\n%s\", r, debug.Stack())\n\t\t\tstate.Phase = synccommon.OperationError\n\t\t\tif rerr, ok := r.(error); ok {\n\t\t\t\tstate.Message = rerr.Error()\n\t\t\t} else {\n\t\t\t\tstate.Message = fmt.Sprintf(\"%v\", r)\n\t\t\t}\n\t\t\tctrl.setOperationState(app, state)\n\t\t}\n\t}()\n\tterminating := false\n\tif isOperationInProgress(app) {\n\t\tstate = app.Status.OperationState.DeepCopy()\n\t\tterminating = state.Phase == synccommon.OperationTerminating\n\t\t// Failed  operation with retry strategy might have be in-progress and has completion time\n\t\tif state.FinishedAt != nil && !terminating {\n\t\t\tretryAt, err := app.Status.OperationState.Operation.Retry.NextRetryAt(state.FinishedAt.Time, state.RetryCount)\n\t\t\tif err != nil {\n\t\t\t\tstate.Phase = synccommon.OperationFailed\n\t\t\t\tstate.Message = err.Error()\n\t\t\t\tctrl.setOperationState(app, state)\n\t\t\t\treturn\n\t\t\t}\n\t\t\tretryAfter := time.Until(retryAt)\n\t\t\tif retryAfter > 0 {\n\t\t\t\tlogCtx.Infof(\"Skipping retrying in-progress operation. Attempting again at: %s\", retryAt.Format(time.RFC3339))\n\t\t\t\tctrl.requestAppRefresh(app.Name, CompareWithLatest.Pointer(), &retryAfter)\n\t\t\t\treturn\n\t\t\t} else {\n\t\t\t\t// retrying operation. remove previous failure time in app since it is used as a trigger\n\t\t\t\t// that previous failed and operation should be retried\n\t\t\t\tstate.FinishedAt = nil\n\t\t\t\tctrl.setOperationState(app, state)\n\t\t\t\t// Get rid of sync results and null out previous operation completion time\n\t\t\t\tstate.SyncResult = nil\n\t\t\t}\n\t\t} else {\n\t\t\tlogCtx.Infof(\"Resuming in-progress operation. phase: %s, message: %s\", state.Phase, state.Message)\n\t\t}\n\t} else {\n\t\tstate = &appv1.OperationState{Phase: synccommon.OperationRunning, Operation: *app.Operation, StartedAt: metav1.Now()}\n\t\tctrl.setOperationState(app, state)\n\t\tlogCtx.Infof(\"Initialized new operation: %v\", *app.Operation)\n\t}\n\n\tif err := argo.ValidateDestination(context.Background(), &app.Spec.Destination, ctrl.db); err != nil {\n\t\tstate.Phase = synccommon.OperationFailed\n\t\tstate.Message = err.Error()\n\t} else {\n\t\tctrl.appStateManager.SyncAppState(app, state)\n\t}\n\n\tif state.Phase == synccommon.OperationRunning {\n\t\t// It's possible for an app to be terminated while we were operating on it. We do not want\n\t\t// to clobber the Terminated state with Running. Get the latest app state to check for this.\n\t\tfreshApp, err := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(ctrl.namespace).Get(context.Background(), app.ObjectMeta.Name, metav1.GetOptions{})\n\t\tif err == nil {\n\t\t\tif freshApp.Status.OperationState != nil && freshApp.Status.OperationState.Phase == synccommon.OperationTerminating {\n\t\t\t\tstate.Phase = synccommon.OperationTerminating\n\t\t\t\tstate.Message = \"operation is terminating\"\n\t\t\t\t// after this, we will get requeued to the workqueue, but next time the\n\t\t\t\t// SyncAppState will operate in a Terminating phase, allowing the worker to perform\n\t\t\t\t// cleanup (e.g. delete jobs, workflows, etc...)\n\t\t\t}\n\t\t}\n\t} else if state.Phase == synccommon.OperationFailed || state.Phase == synccommon.OperationError {\n\t\tif !terminating && (state.RetryCount < state.Operation.Retry.Limit || state.Operation.Retry.Limit < 0) {\n\t\t\tnow := metav1.Now()\n\t\t\tstate.FinishedAt = &now\n\t\t\tif retryAt, err := state.Operation.Retry.NextRetryAt(now.Time, state.RetryCount); err != nil {\n\t\t\t\tstate.Phase = synccommon.OperationFailed\n\t\t\t\tstate.Message = fmt.Sprintf(\"%s (failed to retry: %v)\", state.Message, err)\n\t\t\t} else {\n\t\t\t\tstate.Phase = synccommon.OperationRunning\n\t\t\t\tstate.RetryCount++\n\t\t\t\tstate.Message = fmt.Sprintf(\"%s. Retrying attempt #%d at %s.\", state.Message, state.RetryCount, retryAt.Format(time.Kitchen))\n\t\t\t}\n\t\t} else if state.RetryCount > 0 {\n\t\t\tstate.Message = fmt.Sprintf(\"%s (retried %d times).\", state.Message, state.RetryCount)\n\t\t}\n\n\t}\n\n\tctrl.setOperationState(app, state)\n\tif state.Phase.Completed() && (app.Operation.Sync != nil && !app.Operation.Sync.DryRun) {\n\t\t// if we just completed an operation, force a refresh so that UI will report up-to-date\n\t\t// sync/health information\n\t\tif _, err := cache.MetaNamespaceKeyFunc(app); err == nil {\n\t\t\t// force app refresh with using CompareWithLatest comparison type and trigger app reconciliation loop\n\t\t\tctrl.requestAppRefresh(app.Name, CompareWithLatest.Pointer(), nil)\n\t\t} else {\n\t\t\tlogCtx.Warnf(\"Fails to requeue application: %v\", err)\n\t\t}\n\t}\n}\n\nfunc (ctrl *ApplicationController) setOperationState(app *appv1.Application, state *appv1.OperationState) {\n\tkube.RetryUntilSucceed(context.Background(), updateOperationStateTimeout, \"Update application operation state\", logutils.NewLogrusLogger(logutils.NewWithCurrentConfig()), func() error {\n\t\tif state.Phase == \"\" {\n\t\t\t// expose any bugs where we neglect to set phase\n\t\t\tpanic(\"no phase was set\")\n\t\t}\n\t\tif state.Phase.Completed() {\n\t\t\tnow := metav1.Now()\n\t\t\tstate.FinishedAt = &now\n\t\t}\n\t\tpatch := map[string]interface{}{\n\t\t\t\"status\": map[string]interface{}{\n\t\t\t\t\"operationState\": state,\n\t\t\t},\n\t\t}\n\t\tif state.Phase.Completed() {\n\t\t\t// If operation is completed, clear the operation field to indicate no operation is\n\t\t\t// in progress.\n\t\t\tpatch[\"operation\"] = nil\n\t\t}\n\t\tif reflect.DeepEqual(app.Status.OperationState, state) {\n\t\t\tlog.Infof(\"No operation updates necessary to '%s'. Skipping patch\", app.Name)\n\t\t\treturn nil\n\t\t}\n\t\tpatchJSON, err := json.Marshal(patch)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif app.Status.OperationState != nil && app.Status.OperationState.FinishedAt != nil && state.FinishedAt == nil {\n\t\t\tpatchJSON, err = jsonpatch.MergeMergePatches(patchJSON, []byte(`{\"status\": {\"operationState\": {\"finishedAt\": null}}}`))\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\n\t\tappClient := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(ctrl.namespace)\n\t\t_, err = appClient.Patch(context.Background(), app.Name, types.MergePatchType, patchJSON, metav1.PatchOptions{})\n\t\tif err != nil {\n\t\t\t// Stop retrying updating deleted application\n\t\t\tif apierr.IsNotFound(err) {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\t\tlog.Infof(\"updated '%s' operation (phase: %s)\", app.Name, state.Phase)\n\t\tif state.Phase.Completed() {\n\t\t\teventInfo := argo.EventInfo{Reason: argo.EventReasonOperationCompleted}\n\t\t\tvar messages []string\n\t\t\tif state.Operation.Sync != nil && len(state.Operation.Sync.Resources) > 0 {\n\t\t\t\tmessages = []string{\"Partial sync operation\"}\n\t\t\t} else {\n\t\t\t\tmessages = []string{\"Sync operation\"}\n\t\t\t}\n\t\t\tif state.SyncResult != nil {\n\t\t\t\tmessages = append(messages, \"to\", state.SyncResult.Revision)\n\t\t\t}\n\t\t\tif state.Phase.Successful() {\n\t\t\t\teventInfo.Type = v1.EventTypeNormal\n\t\t\t\tmessages = append(messages, \"succeeded\")\n\t\t\t} else {\n\t\t\t\teventInfo.Type = v1.EventTypeWarning\n\t\t\t\tmessages = append(messages, \"failed:\", state.Message)\n\t\t\t}\n\t\t\tctrl.auditLogger.LogAppEvent(app, eventInfo, strings.Join(messages, \" \"))\n\t\t\tctrl.metricsServer.IncSync(app, state)\n\t\t}\n\t\treturn nil\n\t})\n}\n\nfunc (ctrl *ApplicationController) processAppRefreshQueueItem() (processNext bool) {\n\tappKey, shutdown := ctrl.appRefreshQueue.Get()\n\tif shutdown {\n\t\tprocessNext = false\n\t\treturn\n\t}\n\tprocessNext = true\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tlog.Errorf(\"Recovered from panic: %+v\\n%s\", r, debug.Stack())\n\t\t}\n\t\tctrl.appRefreshQueue.Done(appKey)\n\t}()\n\n\tobj, exists, err := ctrl.appInformer.GetIndexer().GetByKey(appKey.(string))\n\tif err != nil {\n\t\tlog.Errorf(\"Failed to get application '%s' from informer index: %+v\", appKey, err)\n\t\treturn\n\t}\n\tif !exists {\n\t\t// This happens after app was deleted, but the work queue still had an entry for it.\n\t\treturn\n\t}\n\torigApp, ok := obj.(*appv1.Application)\n\tif !ok {\n\t\tlog.Warnf(\"Key '%s' in index is not an application\", appKey)\n\t\treturn\n\t}\n\torigApp = origApp.DeepCopy()\n\tneedRefresh, refreshType, comparisonLevel := ctrl.needRefreshAppStatus(origApp, ctrl.statusRefreshTimeout)\n\n\tif !needRefresh {\n\t\treturn\n\t}\n\n\tapp := origApp.DeepCopy()\n\tlogCtx := log.WithFields(log.Fields{\"application\": app.Name})\n\tstartTime := time.Now()\n\tdefer func() {\n\t\treconcileDuration := time.Since(startTime)\n\t\tctrl.metricsServer.IncReconcile(origApp, reconcileDuration)\n\t\tlogCtx.WithFields(log.Fields{\n\t\t\t\"time_ms\":        reconcileDuration.Milliseconds(),\n\t\t\t\"level\":          comparisonLevel,\n\t\t\t\"dest-server\":    origApp.Spec.Destination.Server,\n\t\t\t\"dest-name\":      origApp.Spec.Destination.Name,\n\t\t\t\"dest-namespace\": origApp.Spec.Destination.Namespace,\n\t\t}).Info(\"Reconciliation completed\")\n\t}()\n\n\tif comparisonLevel == ComparisonWithNothing {\n\t\tmanagedResources := make([]*appv1.ResourceDiff, 0)\n\t\tif err := ctrl.cache.GetAppManagedResources(app.Name, &managedResources); err != nil {\n\t\t\tlogCtx.Warnf(\"Failed to get cached managed resources for tree reconciliation, fall back to full reconciliation\")\n\t\t} else {\n\t\t\tvar tree *appv1.ApplicationTree\n\t\t\tif tree, err = ctrl.getResourceTree(app, managedResources); err == nil {\n\t\t\t\tapp.Status.Summary = tree.GetSummary()\n\t\t\t\tif err := ctrl.cache.SetAppResourcesTree(app.Name, tree); err != nil {\n\t\t\t\t\tlogCtx.Errorf(\"Failed to cache resources tree: %v\", err)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tctrl.persistAppStatus(origApp, &app.Status)\n\t\t\treturn\n\t\t}\n\t}\n\n\tproject, hasErrors := ctrl.refreshAppConditions(app)\n\tif hasErrors {\n\t\tapp.Status.Sync.Status = appv1.SyncStatusCodeUnknown\n\t\tapp.Status.Health.Status = health.HealthStatusUnknown\n\t\tctrl.persistAppStatus(origApp, &app.Status)\n\n\t\tif err := ctrl.cache.SetAppResourcesTree(app.Name, &appv1.ApplicationTree{}); err != nil {\n\t\t\tlog.Warnf(\"failed to set app resource tree: %v\", err)\n\t\t}\n\t\tif err := ctrl.cache.SetAppManagedResources(app.Name, nil); err != nil {\n\t\t\tlog.Warnf(\"failed to set app managed resources tree: %v\", err)\n\t\t}\n\t\treturn\n\t}\n\n\tvar localManifests []string\n\tif opState := app.Status.OperationState; opState != nil && opState.Operation.Sync != nil {\n\t\tlocalManifests = opState.Operation.Sync.Manifests\n\t}\n\n\trevision := app.Spec.Source.TargetRevision\n\tif comparisonLevel == CompareWithRecent {\n\t\trevision = app.Status.Sync.Revision\n\t}\n\n\tnow := metav1.Now()\n\tcompareResult := ctrl.appStateManager.CompareAppState(app, project, revision, app.Spec.Source,\n\t\trefreshType == appv1.RefreshTypeHard,\n\t\tcomparisonLevel == CompareWithLatestForceResolve, localManifests)\n\tfor k, v := range compareResult.timings {\n\t\tlogCtx = logCtx.WithField(k, v.Milliseconds())\n\t}\n\n\tctrl.normalizeApplication(origApp, app)\n\n\ttree, err := ctrl.setAppManagedResources(app, compareResult)\n\tif err != nil {\n\t\tlogCtx.Errorf(\"Failed to cache app resources: %v\", err)\n\t} else {\n\t\tapp.Status.Summary = tree.GetSummary()\n\t}\n\n\tif project.Spec.SyncWindows.Matches(app).CanSync(false) {\n\t\tsyncErrCond := ctrl.autoSync(app, compareResult.syncStatus, compareResult.resources)\n\t\tif syncErrCond != nil {\n\t\t\tapp.Status.SetConditions(\n\t\t\t\t[]appv1.ApplicationCondition{*syncErrCond},\n\t\t\t\tmap[appv1.ApplicationConditionType]bool{appv1.ApplicationConditionSyncError: true},\n\t\t\t)\n\t\t} else {\n\t\t\tapp.Status.SetConditions(\n\t\t\t\t[]appv1.ApplicationCondition{},\n\t\t\t\tmap[appv1.ApplicationConditionType]bool{appv1.ApplicationConditionSyncError: true},\n\t\t\t)\n\t\t}\n\t} else {\n\t\tlogCtx.Info(\"Sync prevented by sync window\")\n\t}\n\n\tif app.Status.ReconciledAt == nil || comparisonLevel >= CompareWithLatest {\n\t\tapp.Status.ReconciledAt = &now\n\t}\n\tapp.Status.Sync = *compareResult.syncStatus\n\tapp.Status.Health = *compareResult.healthStatus\n\tapp.Status.Resources = compareResult.resources\n\tsort.Slice(app.Status.Resources, func(i, j int) bool {\n\t\treturn resourceStatusKey(app.Status.Resources[i]) < resourceStatusKey(app.Status.Resources[j])\n\t})\n\tapp.Status.SourceType = compareResult.appSourceType\n\tctrl.persistAppStatus(origApp, &app.Status)\n\treturn\n}\n\nfunc resourceStatusKey(res appv1.ResourceStatus) string {\n\treturn strings.Join([]string{res.Group, res.Kind, res.Namespace, res.Name}, \"/\")\n}\n\n// needRefreshAppStatus answers if application status needs to be refreshed.\n// Returns true if application never been compared, has changed or comparison result has expired.\n// Additionally returns whether full refresh was requested or not.\n// If full refresh is requested then target and live state should be reconciled, else only live state tree should be updated.\nfunc (ctrl *ApplicationController) needRefreshAppStatus(app *appv1.Application, statusRefreshTimeout time.Duration) (bool, appv1.RefreshType, CompareWith) {\n\tlogCtx := log.WithFields(log.Fields{\"application\": app.Name})\n\tvar reason string\n\tcompareWith := CompareWithLatest\n\trefreshType := appv1.RefreshTypeNormal\n\texpired := app.Status.ReconciledAt == nil || app.Status.ReconciledAt.Add(statusRefreshTimeout).Before(time.Now().UTC())\n\n\tif requestedType, ok := app.IsRefreshRequested(); ok {\n\t\tcompareWith = CompareWithLatestForceResolve\n\t\t// user requested app refresh.\n\t\trefreshType = requestedType\n\t\treason = fmt.Sprintf(\"%s refresh requested\", refreshType)\n\t} else if !app.Spec.Source.Equals(app.Status.Sync.ComparedTo.Source) {\n\t\treason = \"spec.source differs\"\n\t\tcompareWith = CompareWithLatestForceResolve\n\t} else if expired {\n\t\t// The commented line below mysteriously crashes if app.Status.ReconciledAt is nil\n\t\t// reason = fmt.Sprintf(\"comparison expired. reconciledAt: %v, expiry: %v\", app.Status.ReconciledAt, statusRefreshTimeout)\n\t\t//TODO: find existing Golang bug or create a new one\n\t\treconciledAtStr := \"never\"\n\t\tif app.Status.ReconciledAt != nil {\n\t\t\treconciledAtStr = app.Status.ReconciledAt.String()\n\t\t}\n\t\treason = fmt.Sprintf(\"comparison expired. reconciledAt: %v, expiry: %v\", reconciledAtStr, statusRefreshTimeout)\n\t} else if !app.Spec.Destination.Equals(app.Status.Sync.ComparedTo.Destination) {\n\t\treason = \"spec.destination differs\"\n\t} else if requested, level := ctrl.isRefreshRequested(app.Name); requested {\n\t\tcompareWith = level\n\t\treason = \"controller refresh requested\"\n\t}\n\n\tif reason != \"\" {\n\t\tlogCtx.Infof(\"Refreshing app status (%s), level (%d)\", reason, compareWith)\n\t\treturn true, refreshType, compareWith\n\t}\n\treturn false, refreshType, compareWith\n}\n\nfunc (ctrl *ApplicationController) refreshAppConditions(app *appv1.Application) (*appv1.AppProject, bool) {\n\terrorConditions := make([]appv1.ApplicationCondition, 0)\n\tproj, err := ctrl.getAppProj(app)\n\tif err != nil {\n\t\tif apierr.IsNotFound(err) {\n\t\t\terrorConditions = append(errorConditions, appv1.ApplicationCondition{\n\t\t\t\tType:    appv1.ApplicationConditionInvalidSpecError,\n\t\t\t\tMessage: fmt.Sprintf(\"Application referencing project %s which does not exist\", app.Spec.Project),\n\t\t\t})\n\t\t} else {\n\t\t\terrorConditions = append(errorConditions, appv1.ApplicationCondition{\n\t\t\t\tType:    appv1.ApplicationConditionUnknownError,\n\t\t\t\tMessage: err.Error(),\n\t\t\t})\n\t\t}\n\t} else {\n\t\tspecConditions, err := argo.ValidatePermissions(context.Background(), &app.Spec, proj, ctrl.db)\n\t\tif err != nil {\n\t\t\terrorConditions = append(errorConditions, appv1.ApplicationCondition{\n\t\t\t\tType:    appv1.ApplicationConditionUnknownError,\n\t\t\t\tMessage: err.Error(),\n\t\t\t})\n\t\t} else {\n\t\t\terrorConditions = append(errorConditions, specConditions...)\n\t\t}\n\t}\n\tapp.Status.SetConditions(errorConditions, map[appv1.ApplicationConditionType]bool{\n\t\tappv1.ApplicationConditionInvalidSpecError: true,\n\t\tappv1.ApplicationConditionUnknownError:     true,\n\t})\n\treturn proj, len(errorConditions) > 0\n}\n\n// normalizeApplication normalizes an application.spec and additionally persists updates if it changed\nfunc (ctrl *ApplicationController) normalizeApplication(orig, app *appv1.Application) {\n\tlogCtx := log.WithFields(log.Fields{\"application\": app.Name})\n\tapp.Spec = *argo.NormalizeApplicationSpec(&app.Spec)\n\tpatch, modified, err := diff.CreateTwoWayMergePatch(orig, app, appv1.Application{})\n\tif err != nil {\n\t\tlogCtx.Errorf(\"error constructing app spec patch: %v\", err)\n\t} else if modified {\n\t\tappClient := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(app.Namespace)\n\t\t_, err = appClient.Patch(context.Background(), app.Name, types.MergePatchType, patch, metav1.PatchOptions{})\n\t\tif err != nil {\n\t\t\tlogCtx.Errorf(\"Error persisting normalized application spec: %v\", err)\n\t\t} else {\n\t\t\tlogCtx.Infof(\"Normalized app spec: %s\", string(patch))\n\t\t}\n\t}\n}\n\n// persistAppStatus persists updates to application status. If no changes were made, it is a no-op\nfunc (ctrl *ApplicationController) persistAppStatus(orig *appv1.Application, newStatus *appv1.ApplicationStatus) {\n\tlogCtx := log.WithFields(log.Fields{\"application\": orig.Name})\n\tif orig.Status.Sync.Status != newStatus.Sync.Status {\n\t\tmessage := fmt.Sprintf(\"Updated sync status: %s -> %s\", orig.Status.Sync.Status, newStatus.Sync.Status)\n\t\tctrl.auditLogger.LogAppEvent(orig, argo.EventInfo{Reason: argo.EventReasonResourceUpdated, Type: v1.EventTypeNormal}, message)\n\t}\n\tif orig.Status.Health.Status != newStatus.Health.Status {\n\t\tmessage := fmt.Sprintf(\"Updated health status: %s -> %s\", orig.Status.Health.Status, newStatus.Health.Status)\n\t\tctrl.auditLogger.LogAppEvent(orig, argo.EventInfo{Reason: argo.EventReasonResourceUpdated, Type: v1.EventTypeNormal}, message)\n\t}\n\tvar newAnnotations map[string]string\n\tif orig.GetAnnotations() != nil {\n\t\tnewAnnotations = make(map[string]string)\n\t\tfor k, v := range orig.GetAnnotations() {\n\t\t\tnewAnnotations[k] = v\n\t\t}\n\t\tdelete(newAnnotations, appv1.AnnotationKeyRefresh)\n\t}\n\tpatch, modified, err := diff.CreateTwoWayMergePatch(\n\t\t&appv1.Application{ObjectMeta: metav1.ObjectMeta{Annotations: orig.GetAnnotations()}, Status: orig.Status},\n\t\t&appv1.Application{ObjectMeta: metav1.ObjectMeta{Annotations: newAnnotations}, Status: *newStatus}, appv1.Application{})\n\tif err != nil {\n\t\tlogCtx.Errorf(\"Error constructing app status patch: %v\", err)\n\t\treturn\n\t}\n\tif !modified {\n\t\tlogCtx.Infof(\"No status changes. Skipping patch\")\n\t\treturn\n\t}\n\tlogCtx.Debugf(\"patch: %s\", string(patch))\n\tappClient := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(orig.Namespace)\n\t_, err = appClient.Patch(context.Background(), orig.Name, types.MergePatchType, patch, metav1.PatchOptions{})\n\tif err != nil {\n\t\tlogCtx.Warnf(\"Error updating application: %v\", err)\n\t} else {\n\t\tlogCtx.Infof(\"Update successful\")\n\t}\n}\n\n// autoSync will initiate a sync operation for an application configured with automated sync\nfunc (ctrl *ApplicationController) autoSync(app *appv1.Application, syncStatus *appv1.SyncStatus, resources []appv1.ResourceStatus) *appv1.ApplicationCondition {\n\tif app.Spec.SyncPolicy == nil || app.Spec.SyncPolicy.Automated == nil {\n\t\treturn nil\n\t}\n\tlogCtx := log.WithFields(log.Fields{\"application\": app.Name})\n\tif app.Operation != nil {\n\t\tlogCtx.Infof(\"Skipping auto-sync: another operation is in progress\")\n\t\treturn nil\n\t}\n\tif app.DeletionTimestamp != nil && !app.DeletionTimestamp.IsZero() {\n\t\tlogCtx.Infof(\"Skipping auto-sync: deletion in progress\")\n\t\treturn nil\n\t}\n\n\t// Only perform auto-sync if we detect OutOfSync status. This is to prevent us from attempting\n\t// a sync when application is already in a Synced or Unknown state\n\tif syncStatus.Status != appv1.SyncStatusCodeOutOfSync {\n\t\tlogCtx.Infof(\"Skipping auto-sync: application status is %s\", syncStatus.Status)\n\t\treturn nil\n\t}\n\n\tif !app.Spec.SyncPolicy.Automated.Prune {\n\t\trequirePruneOnly := true\n\t\tfor _, r := range resources {\n\t\t\tif r.Status != appv1.SyncStatusCodeSynced && !r.RequiresPruning {\n\t\t\t\trequirePruneOnly = false\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif requirePruneOnly {\n\t\t\tlogCtx.Infof(\"Skipping auto-sync: need to prune extra resources only but automated prune is disabled\")\n\t\t\treturn nil\n\t\t}\n\t}\n\n\tdesiredCommitSHA := syncStatus.Revision\n\talreadyAttempted, attemptPhase := alreadyAttemptedSync(app, desiredCommitSHA)\n\tselfHeal := app.Spec.SyncPolicy.Automated.SelfHeal\n\top := appv1.Operation{\n\t\tSync: &appv1.SyncOperation{\n\t\t\tRevision:    desiredCommitSHA,\n\t\t\tPrune:       app.Spec.SyncPolicy.Automated.Prune,\n\t\t\tSyncOptions: app.Spec.SyncPolicy.SyncOptions,\n\t\t},\n\t\tInitiatedBy: appv1.OperationInitiator{Automated: true},\n\t\tRetry:       appv1.RetryStrategy{Limit: 5},\n\t}\n\tif app.Spec.SyncPolicy.Retry != nil {\n\t\top.Retry = *app.Spec.SyncPolicy.Retry\n\t}\n\t// It is possible for manifests to remain OutOfSync even after a sync/kubectl apply (e.g.\n\t// auto-sync with pruning disabled). We need to ensure that we do not keep Syncing an\n\t// application in an infinite loop. To detect this, we only attempt the Sync if the revision\n\t// and parameter overrides are different from our most recent sync operation.\n\tif alreadyAttempted && (!selfHeal || !attemptPhase.Successful()) {\n\t\tif !attemptPhase.Successful() {\n\t\t\tlogCtx.Warnf(\"Skipping auto-sync: failed previous sync attempt to %s\", desiredCommitSHA)\n\t\t\tmessage := fmt.Sprintf(\"Failed sync attempt to %s: %s\", desiredCommitSHA, app.Status.OperationState.Message)\n\t\t\treturn &appv1.ApplicationCondition{Type: appv1.ApplicationConditionSyncError, Message: message}\n\t\t}\n\t\tlogCtx.Infof(\"Skipping auto-sync: most recent sync already to %s\", desiredCommitSHA)\n\t\treturn nil\n\t} else if alreadyAttempted && selfHeal {\n\t\tif shouldSelfHeal, retryAfter := ctrl.shouldSelfHeal(app); shouldSelfHeal {\n\t\t\tfor _, resource := range resources {\n\t\t\t\tif resource.Status != appv1.SyncStatusCodeSynced {\n\t\t\t\t\top.Sync.Resources = append(op.Sync.Resources, appv1.SyncOperationResource{\n\t\t\t\t\t\tKind:  resource.Kind,\n\t\t\t\t\t\tGroup: resource.Group,\n\t\t\t\t\t\tName:  resource.Name,\n\t\t\t\t\t})\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tlogCtx.Infof(\"Skipping auto-sync: already attempted sync to %s with timeout %v (retrying in %v)\", desiredCommitSHA, ctrl.selfHealTimeout, retryAfter)\n\t\t\tctrl.requestAppRefresh(app.Name, CompareWithLatest.Pointer(), &retryAfter)\n\t\t\treturn nil\n\t\t}\n\n\t}\n\n\tif app.Spec.SyncPolicy.Automated.Prune && !app.Spec.SyncPolicy.Automated.AllowEmpty {\n\t\tbAllNeedPrune := true\n\t\tfor _, r := range resources {\n\t\t\tif !r.RequiresPruning {\n\t\t\t\tbAllNeedPrune = false\n\t\t\t}\n\t\t}\n\t\tif bAllNeedPrune {\n\t\t\tmessage := fmt.Sprintf(\"Skipping sync attempt to %s: auto-sync will wipe out all resources\", desiredCommitSHA)\n\t\t\tlogCtx.Warnf(message)\n\t\t\treturn &appv1.ApplicationCondition{Type: appv1.ApplicationConditionSyncError, Message: message}\n\t\t}\n\t}\n\n\tappIf := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(app.Namespace)\n\t_, err := argo.SetAppOperation(appIf, app.Name, &op)\n\tif err != nil {\n\t\tlogCtx.Errorf(\"Failed to initiate auto-sync to %s: %v\", desiredCommitSHA, err)\n\t\treturn &appv1.ApplicationCondition{Type: appv1.ApplicationConditionSyncError, Message: err.Error()}\n\t}\n\tmessage := fmt.Sprintf(\"Initiated automated sync to '%s'\", desiredCommitSHA)\n\tctrl.auditLogger.LogAppEvent(app, argo.EventInfo{Reason: argo.EventReasonOperationStarted, Type: v1.EventTypeNormal}, message)\n\tlogCtx.Info(message)\n\treturn nil\n}\n\n// alreadyAttemptedSync returns whether or not the most recent sync was performed against the\n// commitSHA and with the same app source config which are currently set in the app\nfunc alreadyAttemptedSync(app *appv1.Application, commitSHA string) (bool, synccommon.OperationPhase) {\n\tif app.Status.OperationState == nil || app.Status.OperationState.Operation.Sync == nil || app.Status.OperationState.SyncResult == nil {\n\t\treturn false, \"\"\n\t}\n\tif app.Status.OperationState.SyncResult.Revision != commitSHA {\n\t\treturn false, \"\"\n\t}\n\t// Ignore differences in target revision, since we already just verified commitSHAs are equal,\n\t// and we do not want to trigger auto-sync due to things like HEAD != master\n\tspecSource := app.Spec.Source.DeepCopy()\n\tspecSource.TargetRevision = \"\"\n\tsyncResSource := app.Status.OperationState.SyncResult.Source.DeepCopy()\n\tsyncResSource.TargetRevision = \"\"\n\treturn reflect.DeepEqual(app.Spec.Source, app.Status.OperationState.SyncResult.Source), app.Status.OperationState.Phase\n}\n\nfunc (ctrl *ApplicationController) shouldSelfHeal(app *appv1.Application) (bool, time.Duration) {\n\tif app.Status.OperationState == nil {\n\t\treturn true, time.Duration(0)\n\t}\n\n\tvar retryAfter time.Duration\n\tif app.Status.OperationState.FinishedAt == nil {\n\t\tretryAfter = ctrl.selfHealTimeout\n\t} else {\n\t\tretryAfter = ctrl.selfHealTimeout - time.Since(app.Status.OperationState.FinishedAt.Time)\n\t}\n\treturn retryAfter <= 0, retryAfter\n}\n\nfunc (ctrl *ApplicationController) canProcessApp(obj interface{}) bool {\n\tapp, ok := obj.(*appv1.Application)\n\tif !ok {\n\t\treturn false\n\t}\n\tif ctrl.clusterFilter != nil {\n\t\tcluster, err := ctrl.db.GetCluster(context.Background(), app.Spec.Destination.Server)\n\t\tif err != nil {\n\t\t\treturn ctrl.clusterFilter(nil)\n\t\t}\n\t\treturn ctrl.clusterFilter(cluster)\n\t}\n\n\treturn true\n}\n\nfunc (ctrl *ApplicationController) newApplicationInformerAndLister() (cache.SharedIndexInformer, applisters.ApplicationLister) {\n\tinformer := cache.NewSharedIndexInformer(\n\t\t&cache.ListWatch{\n\t\t\tListFunc: func(options metav1.ListOptions) (apiruntime.Object, error) {\n\t\t\t\treturn ctrl.applicationClientset.ArgoprojV1alpha1().Applications(ctrl.namespace).List(context.TODO(), options)\n\t\t\t},\n\t\t\tWatchFunc: func(options metav1.ListOptions) (watch.Interface, error) {\n\t\t\t\treturn ctrl.applicationClientset.ArgoprojV1alpha1().Applications(ctrl.namespace).Watch(context.TODO(), options)\n\t\t\t},\n\t\t},\n\t\t&appv1.Application{},\n\t\tctrl.statusRefreshTimeout,\n\t\tcache.Indexers{\n\t\t\tcache.NamespaceIndex: func(obj interface{}) ([]string, error) {\n\t\t\t\tapp, ok := obj.(*appv1.Application)\n\t\t\t\tif ok {\n\t\t\t\t\t// This call to 'ValidateDestination' ensures that the .spec.destination field of all Applications\n\t\t\t\t\t// returned by the informer/lister will have server field set (if not already set) based on the name.\n\t\t\t\t\t// (or, if not found, an error app condition)\n\n\t\t\t\t\t// If the server field is not set, set it based on the cluster name; if the cluster name can't be found,\n\t\t\t\t\t// log an error as an App Condition.\n\t\t\t\t\tif err := argo.ValidateDestination(context.Background(), &app.Spec.Destination, ctrl.db); err != nil {\n\t\t\t\t\t\tctrl.setAppCondition(app, appv1.ApplicationCondition{Type: appv1.ApplicationConditionInvalidSpecError, Message: err.Error()})\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn cache.MetaNamespaceIndexFunc(obj)\n\t\t\t},\n\t\t\torphanedIndex: func(obj interface{}) (i []string, e error) {\n\t\t\t\tapp, ok := obj.(*appv1.Application)\n\t\t\t\tif !ok {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t}\n\n\t\t\t\tproj, err := applisters.NewAppProjectLister(ctrl.projInformer.GetIndexer()).AppProjects(ctrl.namespace).Get(app.Spec.GetProject())\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn nil, nil\n\t\t\t\t}\n\t\t\t\tif proj.Spec.OrphanedResources != nil {\n\t\t\t\t\treturn []string{app.Spec.Destination.Namespace}, nil\n\t\t\t\t}\n\t\t\t\treturn nil, nil\n\t\t\t},\n\t\t},\n\t)\n\tlister := applisters.NewApplicationLister(informer.GetIndexer())\n\tinformer.AddEventHandler(\n\t\tcache.ResourceEventHandlerFuncs{\n\t\t\tAddFunc: func(obj interface{}) {\n\t\t\t\tif !ctrl.canProcessApp(obj) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tkey, err := cache.MetaNamespaceKeyFunc(obj)\n\t\t\t\tif err == nil {\n\t\t\t\t\tctrl.appRefreshQueue.Add(key)\n\t\t\t\t\tctrl.appOperationQueue.Add(key)\n\t\t\t\t}\n\t\t\t},\n\t\t\tUpdateFunc: func(old, new interface{}) {\n\t\t\t\tif !ctrl.canProcessApp(new) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\n\t\t\t\tkey, err := cache.MetaNamespaceKeyFunc(new)\n\t\t\t\tif err != nil {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tvar compareWith *CompareWith\n\t\t\t\toldApp, oldOK := old.(*appv1.Application)\n\t\t\t\tnewApp, newOK := new.(*appv1.Application)\n\t\t\t\tif oldOK && newOK && automatedSyncEnabled(oldApp, newApp) {\n\t\t\t\t\tlog.WithField(\"application\", newApp.Name).Info(\"Enabled automated sync\")\n\t\t\t\t\tcompareWith = CompareWithLatest.Pointer()\n\t\t\t\t}\n\t\t\t\tctrl.requestAppRefresh(newApp.Name, compareWith, nil)\n\t\t\t\tctrl.appOperationQueue.Add(key)\n\t\t\t},\n\t\t\tDeleteFunc: func(obj interface{}) {\n\t\t\t\tif !ctrl.canProcessApp(obj) {\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\t// IndexerInformer uses a delta queue, therefore for deletes we have to use this\n\t\t\t\t// key function.\n\t\t\t\tkey, err := cache.DeletionHandlingMetaNamespaceKeyFunc(obj)\n\t\t\t\tif err == nil {\n\t\t\t\t\tctrl.appRefreshQueue.Add(key)\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t)\n\treturn informer, lister\n}\n\nfunc (ctrl *ApplicationController) RegisterClusterSecretUpdater(ctx context.Context) {\n\tupdater := NewClusterInfoUpdater(ctrl.stateCache, ctrl.db, ctrl.appLister.Applications(ctrl.namespace), ctrl.cache, ctrl.clusterFilter)\n\tgo updater.Run(ctx)\n}\n\nfunc isOperationInProgress(app *appv1.Application) bool {\n\treturn app.Status.OperationState != nil && !app.Status.OperationState.Phase.Completed()\n}\n\n// automatedSyncEnabled tests if an app went from auto-sync disabled to enabled.\n// if it was toggled to be enabled, the informer handler will force a refresh\nfunc automatedSyncEnabled(oldApp *appv1.Application, newApp *appv1.Application) bool {\n\toldEnabled := false\n\toldSelfHealEnabled := false\n\tif oldApp.Spec.SyncPolicy != nil && oldApp.Spec.SyncPolicy.Automated != nil {\n\t\toldEnabled = true\n\t\toldSelfHealEnabled = oldApp.Spec.SyncPolicy.Automated.SelfHeal\n\t}\n\n\tnewEnabled := false\n\tnewSelfHealEnabled := false\n\tif newApp.Spec.SyncPolicy != nil && newApp.Spec.SyncPolicy.Automated != nil {\n\t\tnewEnabled = true\n\t\tnewSelfHealEnabled = newApp.Spec.SyncPolicy.Automated.SelfHeal\n\t}\n\tif !oldEnabled && newEnabled {\n\t\treturn true\n\t}\n\tif !oldSelfHealEnabled && newSelfHealEnabled {\n\t\treturn true\n\t}\n\t// nothing changed\n\treturn false\n}\n", "package controller\n\nimport (\n\t\"context\"\n\t\"encoding/json\"\n\t\"testing\"\n\t\"time\"\n\n\t\"k8s.io/apimachinery/pkg/api/resource\"\n\n\tclustercache \"github.com/argoproj/gitops-engine/pkg/cache\"\n\n\t\"github.com/argoproj/argo-cd/v2/common\"\n\tstatecache \"github.com/argoproj/argo-cd/v2/controller/cache\"\n\n\t\"github.com/argoproj/gitops-engine/pkg/cache/mocks\"\n\tsynccommon \"github.com/argoproj/gitops-engine/pkg/sync/common\"\n\t\"github.com/argoproj/gitops-engine/pkg/utils/kube\"\n\t\"github.com/argoproj/gitops-engine/pkg/utils/kube/kubetest\"\n\t\"github.com/ghodss/yaml\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/mock\"\n\tcorev1 \"k8s.io/api/core/v1\"\n\tapierr \"k8s.io/apimachinery/pkg/api/errors\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\n\t\"k8s.io/apimachinery/pkg/runtime\"\n\t\"k8s.io/apimachinery/pkg/runtime/schema\"\n\t\"k8s.io/client-go/kubernetes/fake\"\n\tkubetesting \"k8s.io/client-go/testing\"\n\t\"k8s.io/client-go/tools/cache\"\n\n\tmockstatecache \"github.com/argoproj/argo-cd/v2/controller/cache/mocks\"\n\t\"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1\"\n\targoappv1 \"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1\"\n\tappclientset \"github.com/argoproj/argo-cd/v2/pkg/client/clientset/versioned/fake\"\n\t\"github.com/argoproj/argo-cd/v2/reposerver/apiclient\"\n\tmockrepoclient \"github.com/argoproj/argo-cd/v2/reposerver/apiclient/mocks\"\n\t\"github.com/argoproj/argo-cd/v2/test\"\n\tcacheutil \"github.com/argoproj/argo-cd/v2/util/cache\"\n\tappstatecache \"github.com/argoproj/argo-cd/v2/util/cache/appstate\"\n\t\"github.com/argoproj/argo-cd/v2/util/settings\"\n)\n\ntype namespacedResource struct {\n\targoappv1.ResourceNode\n\tAppName string\n}\n\ntype fakeData struct {\n\tapps                   []runtime.Object\n\tmanifestResponse       *apiclient.ManifestResponse\n\tmanagedLiveObjs        map[kube.ResourceKey]*unstructured.Unstructured\n\tnamespacedResources    map[kube.ResourceKey]namespacedResource\n\tconfigMapData          map[string]string\n\tmetricsCacheExpiration time.Duration\n}\n\nfunc newFakeController(data *fakeData) *ApplicationController {\n\tvar clust corev1.Secret\n\terr := yaml.Unmarshal([]byte(fakeCluster), &clust)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\n\t// Mock out call to GenerateManifest\n\tmockRepoClient := mockrepoclient.RepoServerServiceClient{}\n\tmockRepoClient.On(\"GenerateManifest\", mock.Anything, mock.Anything).Return(data.manifestResponse, nil)\n\tmockRepoClientset := mockrepoclient.Clientset{RepoServerServiceClient: &mockRepoClient}\n\n\tsecret := corev1.Secret{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"argocd-secret\",\n\t\t\tNamespace: test.FakeArgoCDNamespace,\n\t\t},\n\t\tData: map[string][]byte{\n\t\t\t\"admin.password\":   []byte(\"test\"),\n\t\t\t\"server.secretkey\": []byte(\"test\"),\n\t\t},\n\t}\n\tcm := corev1.ConfigMap{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"argocd-cm\",\n\t\t\tNamespace: test.FakeArgoCDNamespace,\n\t\t\tLabels: map[string]string{\n\t\t\t\t\"app.kubernetes.io/part-of\": \"argocd\",\n\t\t\t},\n\t\t},\n\t\tData: data.configMapData,\n\t}\n\tkubeClient := fake.NewSimpleClientset(&clust, &cm, &secret)\n\tsettingsMgr := settings.NewSettingsManager(context.Background(), kubeClient, test.FakeArgoCDNamespace)\n\tkubectl := &kubetest.MockKubectlCmd{}\n\tctrl, err := NewApplicationController(\n\t\ttest.FakeArgoCDNamespace,\n\t\tsettingsMgr,\n\t\tkubeClient,\n\t\tappclientset.NewSimpleClientset(data.apps...),\n\t\t&mockRepoClientset,\n\t\tappstatecache.NewCache(\n\t\t\tcacheutil.NewCache(cacheutil.NewInMemoryCache(1*time.Minute)),\n\t\t\t1*time.Minute,\n\t\t),\n\t\tkubectl,\n\t\ttime.Minute,\n\t\ttime.Minute,\n\t\tcommon.DefaultPortArgoCDMetrics,\n\t\tdata.metricsCacheExpiration,\n\t\t[]string{},\n\t\t0,\n\t\tnil,\n\t)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tcancelProj := test.StartInformer(ctrl.projInformer)\n\tdefer cancelProj()\n\tcancelApp := test.StartInformer(ctrl.appInformer)\n\tdefer cancelApp()\n\tclusterCacheMock := mocks.ClusterCache{}\n\tclusterCacheMock.On(\"IsNamespaced\", mock.Anything).Return(true, nil)\n\tclusterCacheMock.On(\"GetOpenAPISchema\").Return(nil, nil)\n\n\tmockStateCache := mockstatecache.LiveStateCache{}\n\tctrl.appStateManager.(*appStateManager).liveStateCache = &mockStateCache\n\tctrl.stateCache = &mockStateCache\n\tmockStateCache.On(\"IsNamespaced\", mock.Anything, mock.Anything).Return(true, nil)\n\tmockStateCache.On(\"GetManagedLiveObjs\", mock.Anything, mock.Anything).Return(data.managedLiveObjs, nil)\n\tmockStateCache.On(\"GetVersionsInfo\", mock.Anything).Return(\"v1.2.3\", nil, nil)\n\tresponse := make(map[kube.ResourceKey]argoappv1.ResourceNode)\n\tfor k, v := range data.namespacedResources {\n\t\tresponse[k] = v.ResourceNode\n\t}\n\tmockStateCache.On(\"GetNamespaceTopLevelResources\", mock.Anything, mock.Anything).Return(response, nil)\n\tmockStateCache.On(\"IterateResources\", mock.Anything, mock.Anything).Return(nil)\n\tmockStateCache.On(\"GetClusterCache\", mock.Anything).Return(&clusterCacheMock, nil)\n\tmockStateCache.On(\"IterateHierarchy\", mock.Anything, mock.Anything, mock.Anything).Run(func(args mock.Arguments) {\n\t\tkey := args[1].(kube.ResourceKey)\n\t\taction := args[2].(func(child argoappv1.ResourceNode, appName string) bool)\n\t\tappName := \"\"\n\t\tif res, ok := data.namespacedResources[key]; ok {\n\t\t\tappName = res.AppName\n\t\t}\n\t\t_ = action(argoappv1.ResourceNode{ResourceRef: argoappv1.ResourceRef{Kind: key.Kind, Group: key.Group, Namespace: key.Namespace, Name: key.Name}}, appName)\n\t}).Return(nil)\n\treturn ctrl\n}\n\nvar fakeCluster = `\napiVersion: v1\ndata:\n  # {\"bearerToken\":\"fake\",\"tlsClientConfig\":{\"insecure\":true},\"awsAuthConfig\":null}\n  config: eyJiZWFyZXJUb2tlbiI6ImZha2UiLCJ0bHNDbGllbnRDb25maWciOnsiaW5zZWN1cmUiOnRydWV9LCJhd3NBdXRoQ29uZmlnIjpudWxsfQ==\n  # minikube\n  name: bWluaWt1YmU=\n  # https://localhost:6443\n  server: aHR0cHM6Ly9sb2NhbGhvc3Q6NjQ0Mw==\nkind: Secret\nmetadata:\n  labels:\n    argocd.argoproj.io/secret-type: cluster\n  name: some-secret\n  namespace: ` + test.FakeArgoCDNamespace + `\ntype: Opaque\n`\n\nvar fakeApp = `\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  uid: \"123\"\n  name: my-app\n  namespace: ` + test.FakeArgoCDNamespace + `\nspec:\n  destination:\n    namespace: ` + test.FakeDestNamespace + `\n    server: https://localhost:6443\n  project: default\n  source:\n    path: some/path\n    repoURL: https://github.com/argoproj/argocd-example-apps.git\n  syncPolicy:\n    automated: {}\nstatus:\n  operationState:\n    finishedAt: 2018-09-21T23:50:29Z\n    message: successfully synced\n    operation:\n      sync:\n        revision: HEAD\n    phase: Succeeded\n    startedAt: 2018-09-21T23:50:25Z\n    syncResult:\n      resources:\n      - kind: RoleBinding\n        message: |-\n          rolebinding.rbac.authorization.k8s.io/always-outofsync reconciled\n          rolebinding.rbac.authorization.k8s.io/always-outofsync configured\n        name: always-outofsync\n        namespace: default\n        status: Synced\n      revision: aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n      source:\n        path: some/path\n        repoURL: https://github.com/argoproj/argocd-example-apps.git\n`\n\nvar fakeAppWithDestName = `\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  uid: \"123\"\n  name: my-app\n  namespace: ` + test.FakeArgoCDNamespace + `\nspec:\n  destination:\n    namespace: ` + test.FakeDestNamespace + `\n    name: minikube\n  project: default\n  source:\n    path: some/path\n    repoURL: https://github.com/argoproj/argocd-example-apps.git\n  syncPolicy:\n    automated: {}\n`\n\nvar fakeAppWithDestMismatch = `\napiVersion: argoproj.io/v1alpha1\nkind: Application\nmetadata:\n  uid: \"123\"\n  name: my-app\n  namespace: ` + test.FakeArgoCDNamespace + `\nspec:\n  destination:\n    namespace: ` + test.FakeDestNamespace + `\n    name: another-cluster\n    server: https://localhost:6443\n  project: default\n  source:\n    path: some/path\n    repoURL: https://github.com/argoproj/argocd-example-apps.git\n  syncPolicy:\n    automated: {}\n`\n\nvar fakeStrayResource = `\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: test-cm\n  namespace: invalid\n  labels:\n    app.kubernetes.io/instance: my-app\ndata:\n`\n\nfunc newFakeApp() *argoappv1.Application {\n\treturn createFakeApp(fakeApp)\n}\n\nfunc newFakeAppWithDestMismatch() *argoappv1.Application {\n\treturn createFakeApp(fakeAppWithDestMismatch)\n}\n\nfunc newFakeAppWithDestName() *argoappv1.Application {\n\treturn createFakeApp(fakeAppWithDestName)\n}\n\nfunc createFakeApp(testApp string) *argoappv1.Application {\n\tvar app argoappv1.Application\n\terr := yaml.Unmarshal([]byte(testApp), &app)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn &app\n}\n\nfunc newFakeCM() map[string]interface{} {\n\tvar cm map[string]interface{}\n\terr := yaml.Unmarshal([]byte(fakeStrayResource), &cm)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\treturn cm\n}\n\nfunc TestAutoSync(t *testing.T) {\n\tapp := newFakeApp()\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\tsyncStatus := argoappv1.SyncStatus{\n\t\tStatus:   argoappv1.SyncStatusCodeOutOfSync,\n\t\tRevision: \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\",\n\t}\n\tcond := ctrl.autoSync(app, &syncStatus, []argoappv1.ResourceStatus{{Name: \"guestbook\", Kind: kube.DeploymentKind, Status: argoappv1.SyncStatusCodeOutOfSync}})\n\tassert.Nil(t, cond)\n\tapp, err := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(test.FakeArgoCDNamespace).Get(context.Background(), \"my-app\", metav1.GetOptions{})\n\tassert.NoError(t, err)\n\tassert.NotNil(t, app.Operation)\n\tassert.NotNil(t, app.Operation.Sync)\n\tassert.False(t, app.Operation.Sync.Prune)\n}\n\nfunc TestAutoSyncNotAllowEmpty(t *testing.T) {\n\tapp := newFakeApp()\n\tapp.Spec.SyncPolicy.Automated.Prune = true\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\tsyncStatus := argoappv1.SyncStatus{\n\t\tStatus:   argoappv1.SyncStatusCodeOutOfSync,\n\t\tRevision: \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\",\n\t}\n\tcond := ctrl.autoSync(app, &syncStatus, []argoappv1.ResourceStatus{})\n\tassert.NotNil(t, cond)\n}\n\nfunc TestAutoSyncAllowEmpty(t *testing.T) {\n\tapp := newFakeApp()\n\tapp.Spec.SyncPolicy.Automated.Prune = true\n\tapp.Spec.SyncPolicy.Automated.AllowEmpty = true\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\tsyncStatus := argoappv1.SyncStatus{\n\t\tStatus:   argoappv1.SyncStatusCodeOutOfSync,\n\t\tRevision: \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\",\n\t}\n\tcond := ctrl.autoSync(app, &syncStatus, []argoappv1.ResourceStatus{})\n\tassert.Nil(t, cond)\n}\n\nfunc TestSkipAutoSync(t *testing.T) {\n\t// Verify we skip when we previously synced to it in our most recent history\n\t// Set current to 'aaaaa', desired to 'aaaa' and mark system OutOfSync\n\tt.Run(\"PreviouslySyncedToRevision\", func(t *testing.T) {\n\t\tapp := newFakeApp()\n\t\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\t\tsyncStatus := argoappv1.SyncStatus{\n\t\t\tStatus:   argoappv1.SyncStatusCodeOutOfSync,\n\t\t\tRevision: \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n\t\t}\n\t\tcond := ctrl.autoSync(app, &syncStatus, []argoappv1.ResourceStatus{})\n\t\tassert.Nil(t, cond)\n\t\tapp, err := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(test.FakeArgoCDNamespace).Get(context.Background(), \"my-app\", metav1.GetOptions{})\n\t\tassert.NoError(t, err)\n\t\tassert.Nil(t, app.Operation)\n\t})\n\n\t// Verify we skip when we are already Synced (even if revision is different)\n\tt.Run(\"AlreadyInSyncedState\", func(t *testing.T) {\n\t\tapp := newFakeApp()\n\t\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\t\tsyncStatus := argoappv1.SyncStatus{\n\t\t\tStatus:   argoappv1.SyncStatusCodeSynced,\n\t\t\tRevision: \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\",\n\t\t}\n\t\tcond := ctrl.autoSync(app, &syncStatus, []argoappv1.ResourceStatus{})\n\t\tassert.Nil(t, cond)\n\t\tapp, err := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(test.FakeArgoCDNamespace).Get(context.Background(), \"my-app\", metav1.GetOptions{})\n\t\tassert.NoError(t, err)\n\t\tassert.Nil(t, app.Operation)\n\t})\n\n\t// Verify we skip when auto-sync is disabled\n\tt.Run(\"AutoSyncIsDisabled\", func(t *testing.T) {\n\t\tapp := newFakeApp()\n\t\tapp.Spec.SyncPolicy = nil\n\t\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\t\tsyncStatus := argoappv1.SyncStatus{\n\t\t\tStatus:   argoappv1.SyncStatusCodeOutOfSync,\n\t\t\tRevision: \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\",\n\t\t}\n\t\tcond := ctrl.autoSync(app, &syncStatus, []argoappv1.ResourceStatus{})\n\t\tassert.Nil(t, cond)\n\t\tapp, err := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(test.FakeArgoCDNamespace).Get(context.Background(), \"my-app\", metav1.GetOptions{})\n\t\tassert.NoError(t, err)\n\t\tassert.Nil(t, app.Operation)\n\t})\n\n\t// Verify we skip when application is marked for deletion\n\tt.Run(\"ApplicationIsMarkedForDeletion\", func(t *testing.T) {\n\t\tapp := newFakeApp()\n\t\tnow := metav1.Now()\n\t\tapp.DeletionTimestamp = &now\n\t\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\t\tsyncStatus := argoappv1.SyncStatus{\n\t\t\tStatus:   argoappv1.SyncStatusCodeOutOfSync,\n\t\t\tRevision: \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\",\n\t\t}\n\t\tcond := ctrl.autoSync(app, &syncStatus, []argoappv1.ResourceStatus{})\n\t\tassert.Nil(t, cond)\n\t\tapp, err := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(test.FakeArgoCDNamespace).Get(context.Background(), \"my-app\", metav1.GetOptions{})\n\t\tassert.NoError(t, err)\n\t\tassert.Nil(t, app.Operation)\n\t})\n\n\t// Verify we skip when previous sync attempt failed and return error condition\n\t// Set current to 'aaaaa', desired to 'bbbbb' and add 'bbbbb' to failure history\n\tt.Run(\"PreviousSyncAttemptFailed\", func(t *testing.T) {\n\t\tapp := newFakeApp()\n\t\tapp.Status.OperationState = &argoappv1.OperationState{\n\t\t\tOperation: argoappv1.Operation{\n\t\t\t\tSync: &argoappv1.SyncOperation{},\n\t\t\t},\n\t\t\tPhase: synccommon.OperationFailed,\n\t\t\tSyncResult: &argoappv1.SyncOperationResult{\n\t\t\t\tRevision: \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\",\n\t\t\t\tSource:   *app.Spec.Source.DeepCopy(),\n\t\t\t},\n\t\t}\n\t\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\t\tsyncStatus := argoappv1.SyncStatus{\n\t\t\tStatus:   argoappv1.SyncStatusCodeOutOfSync,\n\t\t\tRevision: \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\",\n\t\t}\n\t\tcond := ctrl.autoSync(app, &syncStatus, []argoappv1.ResourceStatus{{Name: \"guestbook\", Kind: kube.DeploymentKind, Status: argoappv1.SyncStatusCodeOutOfSync}})\n\t\tassert.NotNil(t, cond)\n\t\tapp, err := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(test.FakeArgoCDNamespace).Get(context.Background(), \"my-app\", metav1.GetOptions{})\n\t\tassert.NoError(t, err)\n\t\tassert.Nil(t, app.Operation)\n\t})\n\n\tt.Run(\"NeedsToPruneResourcesOnlyButAutomatedPruneDisabled\", func(t *testing.T) {\n\t\tapp := newFakeApp()\n\t\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\t\tsyncStatus := argoappv1.SyncStatus{\n\t\t\tStatus:   argoappv1.SyncStatusCodeOutOfSync,\n\t\t\tRevision: \"bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\",\n\t\t}\n\t\tcond := ctrl.autoSync(app, &syncStatus, []argoappv1.ResourceStatus{\n\t\t\t{Name: \"guestbook\", Kind: kube.DeploymentKind, Status: argoappv1.SyncStatusCodeOutOfSync, RequiresPruning: true},\n\t\t})\n\t\tassert.Nil(t, cond)\n\t\tapp, err := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(test.FakeArgoCDNamespace).Get(context.Background(), \"my-app\", metav1.GetOptions{})\n\t\tassert.NoError(t, err)\n\t\tassert.Nil(t, app.Operation)\n\t})\n}\n\n// TestAutoSyncIndicateError verifies we skip auto-sync and return error condition if previous sync failed\nfunc TestAutoSyncIndicateError(t *testing.T) {\n\tapp := newFakeApp()\n\tapp.Spec.Source.Helm = &argoappv1.ApplicationSourceHelm{\n\t\tParameters: []argoappv1.HelmParameter{\n\t\t\t{\n\t\t\t\tName:  \"a\",\n\t\t\t\tValue: \"1\",\n\t\t\t},\n\t\t},\n\t}\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\tsyncStatus := argoappv1.SyncStatus{\n\t\tStatus:   argoappv1.SyncStatusCodeOutOfSync,\n\t\tRevision: \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n\t}\n\tapp.Status.OperationState = &argoappv1.OperationState{\n\t\tOperation: argoappv1.Operation{\n\t\t\tSync: &argoappv1.SyncOperation{\n\t\t\t\tSource: app.Spec.Source.DeepCopy(),\n\t\t\t},\n\t\t},\n\t\tPhase: synccommon.OperationFailed,\n\t\tSyncResult: &argoappv1.SyncOperationResult{\n\t\t\tRevision: \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n\t\t\tSource:   *app.Spec.Source.DeepCopy(),\n\t\t},\n\t}\n\tcond := ctrl.autoSync(app, &syncStatus, []argoappv1.ResourceStatus{{Name: \"guestbook\", Kind: kube.DeploymentKind, Status: argoappv1.SyncStatusCodeOutOfSync}})\n\tassert.NotNil(t, cond)\n\tapp, err := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(test.FakeArgoCDNamespace).Get(context.Background(), \"my-app\", metav1.GetOptions{})\n\tassert.NoError(t, err)\n\tassert.Nil(t, app.Operation)\n}\n\n// TestAutoSyncParameterOverrides verifies we auto-sync if revision is same but parameter overrides are different\nfunc TestAutoSyncParameterOverrides(t *testing.T) {\n\tapp := newFakeApp()\n\tapp.Spec.Source.Helm = &argoappv1.ApplicationSourceHelm{\n\t\tParameters: []argoappv1.HelmParameter{\n\t\t\t{\n\t\t\t\tName:  \"a\",\n\t\t\t\tValue: \"1\",\n\t\t\t},\n\t\t},\n\t}\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\tsyncStatus := argoappv1.SyncStatus{\n\t\tStatus:   argoappv1.SyncStatusCodeOutOfSync,\n\t\tRevision: \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n\t}\n\tapp.Status.OperationState = &argoappv1.OperationState{\n\t\tOperation: argoappv1.Operation{\n\t\t\tSync: &argoappv1.SyncOperation{\n\t\t\t\tSource: &argoappv1.ApplicationSource{\n\t\t\t\t\tHelm: &argoappv1.ApplicationSourceHelm{\n\t\t\t\t\t\tParameters: []argoappv1.HelmParameter{\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tName:  \"a\",\n\t\t\t\t\t\t\t\tValue: \"2\", // this value changed\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t\tPhase: synccommon.OperationFailed,\n\t\tSyncResult: &argoappv1.SyncOperationResult{\n\t\t\tRevision: \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n\t\t},\n\t}\n\tcond := ctrl.autoSync(app, &syncStatus, []argoappv1.ResourceStatus{{Name: \"guestbook\", Kind: kube.DeploymentKind, Status: argoappv1.SyncStatusCodeOutOfSync}})\n\tassert.Nil(t, cond)\n\tapp, err := ctrl.applicationClientset.ArgoprojV1alpha1().Applications(test.FakeArgoCDNamespace).Get(context.Background(), \"my-app\", metav1.GetOptions{})\n\tassert.NoError(t, err)\n\tassert.NotNil(t, app.Operation)\n}\n\n// TestFinalizeAppDeletion verifies application deletion\nfunc TestFinalizeAppDeletion(t *testing.T) {\n\tdefaultProj := argoappv1.AppProject{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"default\",\n\t\t\tNamespace: test.FakeArgoCDNamespace,\n\t\t},\n\t\tSpec: argoappv1.AppProjectSpec{\n\t\t\tSourceRepos: []string{\"*\"},\n\t\t\tDestinations: []argoappv1.ApplicationDestination{\n\t\t\t\t{\n\t\t\t\t\tServer:    \"*\",\n\t\t\t\t\tNamespace: \"*\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\t// Ensure app can be deleted cascading\n\tt.Run(\"CascadingDelete\", func(t *testing.T) {\n\t\tapp := newFakeApp()\n\t\tapp.Spec.Destination.Namespace = test.FakeArgoCDNamespace\n\t\tappObj := kube.MustToUnstructured(&app)\n\t\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app, &defaultProj}, managedLiveObjs: map[kube.ResourceKey]*unstructured.Unstructured{\n\t\t\tkube.GetResourceKey(appObj): appObj,\n\t\t}})\n\n\t\tpatched := false\n\t\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\t\tdefaultReactor := fakeAppCs.ReactionChain[0]\n\t\tfakeAppCs.ReactionChain = nil\n\t\tfakeAppCs.AddReactor(\"get\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\t\treturn defaultReactor.React(action)\n\t\t})\n\t\tfakeAppCs.AddReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\t\tpatched = true\n\t\t\treturn true, nil, nil\n\t\t})\n\t\t_, err := ctrl.finalizeApplicationDeletion(app)\n\t\tassert.NoError(t, err)\n\t\tassert.True(t, patched)\n\t})\n\n\t// Ensure any stray resources irregularly labeled with instance label of app are not deleted upon deleting,\n\t// when app project restriction is in place\n\tt.Run(\"ProjectRestrictionEnforced\", func(*testing.T) {\n\t\trestrictedProj := argoappv1.AppProject{\n\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\tName:      \"restricted\",\n\t\t\t\tNamespace: test.FakeArgoCDNamespace,\n\t\t\t},\n\t\t\tSpec: argoappv1.AppProjectSpec{\n\t\t\t\tSourceRepos: []string{\"*\"},\n\t\t\t\tDestinations: []argoappv1.ApplicationDestination{\n\t\t\t\t\t{\n\t\t\t\t\t\tServer:    \"*\",\n\t\t\t\t\t\tNamespace: \"my-app\",\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t},\n\t\t}\n\t\tapp := newFakeApp()\n\t\tapp.Spec.Destination.Namespace = test.FakeArgoCDNamespace\n\t\tapp.Spec.Project = \"restricted\"\n\t\tappObj := kube.MustToUnstructured(&app)\n\t\tcm := newFakeCM()\n\t\tstrayObj := kube.MustToUnstructured(&cm)\n\t\tctrl := newFakeController(&fakeData{\n\t\t\tapps: []runtime.Object{app, &defaultProj, &restrictedProj},\n\t\t\tmanagedLiveObjs: map[kube.ResourceKey]*unstructured.Unstructured{\n\t\t\t\tkube.GetResourceKey(appObj):   appObj,\n\t\t\t\tkube.GetResourceKey(strayObj): strayObj,\n\t\t\t},\n\t\t})\n\n\t\tpatched := false\n\t\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\t\tdefaultReactor := fakeAppCs.ReactionChain[0]\n\t\tfakeAppCs.ReactionChain = nil\n\t\tfakeAppCs.AddReactor(\"get\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\t\treturn defaultReactor.React(action)\n\t\t})\n\t\tfakeAppCs.AddReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\t\tpatched = true\n\t\t\treturn true, nil, nil\n\t\t})\n\t\tobjs, err := ctrl.finalizeApplicationDeletion(app)\n\t\tassert.NoError(t, err)\n\t\tassert.True(t, patched)\n\t\tobjsMap, err := ctrl.stateCache.GetManagedLiveObjs(app, []*unstructured.Unstructured{})\n\t\tif err != nil {\n\t\t\tassert.NoError(t, err)\n\t\t}\n\t\t// Managed objects must be empty\n\t\tassert.Empty(t, objsMap)\n\t\t// Loop through all deleted objects, ensure that test-cm is none of them\n\t\tfor _, o := range objs {\n\t\t\tassert.NotEqual(t, \"test-cm\", o.GetName())\n\t\t}\n\t})\n\n\tt.Run(\"DeleteWithDestinationClusterName\", func(t *testing.T) {\n\t\tapp := newFakeAppWithDestName()\n\t\tappObj := kube.MustToUnstructured(&app)\n\t\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app, &defaultProj}, managedLiveObjs: map[kube.ResourceKey]*unstructured.Unstructured{\n\t\t\tkube.GetResourceKey(appObj): appObj,\n\t\t}})\n\t\tpatched := false\n\t\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\t\tdefaultReactor := fakeAppCs.ReactionChain[0]\n\t\tfakeAppCs.ReactionChain = nil\n\t\tfakeAppCs.AddReactor(\"get\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\t\treturn defaultReactor.React(action)\n\t\t})\n\t\tfakeAppCs.AddReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\t\tpatched = true\n\t\t\treturn true, nil, nil\n\t\t})\n\t\t_, err := ctrl.finalizeApplicationDeletion(app)\n\t\tassert.NoError(t, err)\n\t\tassert.True(t, patched)\n\t})\n\n\t// Create an Application with a cluster that doesn't exist\n\t// Ensure it can be deleted.\n\tt.Run(\"DeleteWithInvalidClusterName\", func(t *testing.T) {\n\n\t\tappTemplate := newFakeAppWithDestName()\n\n\t\ttestShouldDelete := func(app *argoappv1.Application) {\n\t\t\tappObj := kube.MustToUnstructured(&app)\n\t\t\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app, &defaultProj}, managedLiveObjs: map[kube.ResourceKey]*unstructured.Unstructured{\n\t\t\t\tkube.GetResourceKey(appObj): appObj,\n\t\t\t}})\n\n\t\t\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\t\t\tdefaultReactor := fakeAppCs.ReactionChain[0]\n\t\t\tfakeAppCs.ReactionChain = nil\n\t\t\tfakeAppCs.AddReactor(\"get\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\t\t\treturn defaultReactor.React(action)\n\t\t\t})\n\t\t\t_, err := ctrl.finalizeApplicationDeletion(app)\n\t\t\tassert.NoError(t, err)\n\t\t}\n\n\t\tapp1 := appTemplate.DeepCopy()\n\t\tapp1.Spec.Destination.Server = \"https://invalid\"\n\t\ttestShouldDelete(app1)\n\n\t\tapp2 := appTemplate.DeepCopy()\n\t\tapp2.Spec.Destination.Name = \"invalid\"\n\t\ttestShouldDelete(app2)\n\n\t\tapp3 := appTemplate.DeepCopy()\n\t\tapp3.Spec.Destination.Name = \"invalid\"\n\t\tapp3.Spec.Destination.Server = \"https://invalid\"\n\t\ttestShouldDelete(app3)\n\n\t})\n\n}\n\n// TestNormalizeApplication verifies we normalize an application during reconciliation\nfunc TestNormalizeApplication(t *testing.T) {\n\tdefaultProj := argoappv1.AppProject{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"default\",\n\t\t\tNamespace: test.FakeArgoCDNamespace,\n\t\t},\n\t\tSpec: argoappv1.AppProjectSpec{\n\t\t\tSourceRepos: []string{\"*\"},\n\t\t\tDestinations: []argoappv1.ApplicationDestination{\n\t\t\t\t{\n\t\t\t\t\tServer:    \"*\",\n\t\t\t\t\tNamespace: \"*\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\tapp := newFakeApp()\n\tapp.Spec.Project = \"\"\n\tapp.Spec.Source.Kustomize = &argoappv1.ApplicationSourceKustomize{NamePrefix: \"foo-\"}\n\tdata := fakeData{\n\t\tapps: []runtime.Object{app, &defaultProj},\n\t\tmanifestResponse: &apiclient.ManifestResponse{\n\t\t\tManifests: []string{},\n\t\t\tNamespace: test.FakeDestNamespace,\n\t\t\tServer:    test.FakeClusterURL,\n\t\t\tRevision:  \"abc123\",\n\t\t},\n\t\tmanagedLiveObjs: make(map[kube.ResourceKey]*unstructured.Unstructured),\n\t}\n\n\t{\n\t\t// Verify we normalize the app because project is missing\n\t\tctrl := newFakeController(&data)\n\t\tkey, _ := cache.MetaNamespaceKeyFunc(app)\n\t\tctrl.appRefreshQueue.Add(key)\n\t\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\t\tfakeAppCs.ReactionChain = nil\n\t\tnormalized := false\n\t\tfakeAppCs.AddReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\t\tif patchAction, ok := action.(kubetesting.PatchAction); ok {\n\t\t\t\tif string(patchAction.GetPatch()) == `{\"spec\":{\"project\":\"default\"}}` {\n\t\t\t\t\tnormalized = true\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true, nil, nil\n\t\t})\n\t\tctrl.processAppRefreshQueueItem()\n\t\tassert.True(t, normalized)\n\t}\n\n\t{\n\t\t// Verify we don't unnecessarily normalize app when project is set\n\t\tapp.Spec.Project = \"default\"\n\t\tdata.apps[0] = app\n\t\tctrl := newFakeController(&data)\n\t\tkey, _ := cache.MetaNamespaceKeyFunc(app)\n\t\tctrl.appRefreshQueue.Add(key)\n\t\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\t\tfakeAppCs.ReactionChain = nil\n\t\tnormalized := false\n\t\tfakeAppCs.AddReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\t\tif patchAction, ok := action.(kubetesting.PatchAction); ok {\n\t\t\t\tif string(patchAction.GetPatch()) == `{\"spec\":{\"project\":\"default\"}}` {\n\t\t\t\t\tnormalized = true\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true, nil, nil\n\t\t})\n\t\tctrl.processAppRefreshQueueItem()\n\t\tassert.False(t, normalized)\n\t}\n}\n\nfunc TestHandleAppUpdated(t *testing.T) {\n\tapp := newFakeApp()\n\tapp.Spec.Destination.Namespace = test.FakeArgoCDNamespace\n\tapp.Spec.Destination.Server = argoappv1.KubernetesInternalAPIServerAddr\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\n\tctrl.handleObjectUpdated(map[string]bool{app.Name: true}, kube.GetObjectRef(kube.MustToUnstructured(app)))\n\tisRequested, level := ctrl.isRefreshRequested(app.Name)\n\tassert.False(t, isRequested)\n\tassert.Equal(t, ComparisonWithNothing, level)\n\n\tctrl.handleObjectUpdated(map[string]bool{app.Name: true}, corev1.ObjectReference{UID: \"test\", Kind: kube.DeploymentKind, Name: \"test\", Namespace: \"default\"})\n\tisRequested, level = ctrl.isRefreshRequested(app.Name)\n\tassert.True(t, isRequested)\n\tassert.Equal(t, CompareWithRecent, level)\n}\n\nfunc TestHandleOrphanedResourceUpdated(t *testing.T) {\n\tapp1 := newFakeApp()\n\tapp1.Name = \"app1\"\n\tapp1.Spec.Destination.Namespace = test.FakeArgoCDNamespace\n\tapp1.Spec.Destination.Server = argoappv1.KubernetesInternalAPIServerAddr\n\n\tapp2 := newFakeApp()\n\tapp2.Name = \"app2\"\n\tapp2.Spec.Destination.Namespace = test.FakeArgoCDNamespace\n\tapp2.Spec.Destination.Server = argoappv1.KubernetesInternalAPIServerAddr\n\n\tproj := defaultProj.DeepCopy()\n\tproj.Spec.OrphanedResources = &argoappv1.OrphanedResourcesMonitorSettings{}\n\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app1, app2, proj}})\n\n\tctrl.handleObjectUpdated(map[string]bool{}, corev1.ObjectReference{UID: \"test\", Kind: kube.DeploymentKind, Name: \"test\", Namespace: test.FakeArgoCDNamespace})\n\n\tisRequested, level := ctrl.isRefreshRequested(app1.Name)\n\tassert.True(t, isRequested)\n\tassert.Equal(t, CompareWithRecent, level)\n\n\tisRequested, level = ctrl.isRefreshRequested(app2.Name)\n\tassert.True(t, isRequested)\n\tassert.Equal(t, CompareWithRecent, level)\n}\n\nfunc TestGetResourceTree_HasOrphanedResources(t *testing.T) {\n\tapp := newFakeApp()\n\tproj := defaultProj.DeepCopy()\n\tproj.Spec.OrphanedResources = &argoappv1.OrphanedResourcesMonitorSettings{}\n\n\tmanagedDeploy := argoappv1.ResourceNode{\n\t\tResourceRef: argoappv1.ResourceRef{Group: \"apps\", Kind: \"Deployment\", Namespace: \"default\", Name: \"nginx-deployment\", Version: \"v1\"},\n\t}\n\torphanedDeploy1 := argoappv1.ResourceNode{\n\t\tResourceRef: argoappv1.ResourceRef{Group: \"apps\", Kind: \"Deployment\", Namespace: \"default\", Name: \"deploy1\"},\n\t}\n\torphanedDeploy2 := argoappv1.ResourceNode{\n\t\tResourceRef: argoappv1.ResourceRef{Group: \"apps\", Kind: \"Deployment\", Namespace: \"default\", Name: \"deploy2\"},\n\t}\n\n\tctrl := newFakeController(&fakeData{\n\t\tapps: []runtime.Object{app, proj},\n\t\tnamespacedResources: map[kube.ResourceKey]namespacedResource{\n\t\t\tkube.NewResourceKey(\"apps\", \"Deployment\", \"default\", \"nginx-deployment\"): {ResourceNode: managedDeploy},\n\t\t\tkube.NewResourceKey(\"apps\", \"Deployment\", \"default\", \"deploy1\"):          {ResourceNode: orphanedDeploy1},\n\t\t\tkube.NewResourceKey(\"apps\", \"Deployment\", \"default\", \"deploy2\"):          {ResourceNode: orphanedDeploy2},\n\t\t},\n\t})\n\ttree, err := ctrl.getResourceTree(app, []*argoappv1.ResourceDiff{{\n\t\tNamespace:   \"default\",\n\t\tName:        \"nginx-deployment\",\n\t\tKind:        \"Deployment\",\n\t\tGroup:       \"apps\",\n\t\tLiveState:   \"null\",\n\t\tTargetState: test.DeploymentManifest,\n\t}})\n\n\tassert.NoError(t, err)\n\tassert.Equal(t, tree.Nodes, []argoappv1.ResourceNode{managedDeploy})\n\tassert.Equal(t, tree.OrphanedNodes, []argoappv1.ResourceNode{orphanedDeploy1, orphanedDeploy2})\n}\n\nfunc TestSetOperationStateOnDeletedApp(t *testing.T) {\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{}})\n\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\tfakeAppCs.ReactionChain = nil\n\tpatched := false\n\tfakeAppCs.AddReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\tpatched = true\n\t\treturn true, nil, apierr.NewNotFound(schema.GroupResource{}, \"my-app\")\n\t})\n\tctrl.setOperationState(newFakeApp(), &argoappv1.OperationState{Phase: synccommon.OperationSucceeded})\n\tassert.True(t, patched)\n}\n\nfunc TestNeedRefreshAppStatus(t *testing.T) {\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{}})\n\n\tapp := newFakeApp()\n\tnow := metav1.Now()\n\tapp.Status.ReconciledAt = &now\n\tapp.Status.Sync = argoappv1.SyncStatus{\n\t\tStatus: argoappv1.SyncStatusCodeSynced,\n\t\tComparedTo: argoappv1.ComparedTo{\n\t\t\tSource:      app.Spec.Source,\n\t\t\tDestination: app.Spec.Destination,\n\t\t},\n\t}\n\n\t// no need to refresh just reconciled application\n\tneedRefresh, _, _ := ctrl.needRefreshAppStatus(app, 1*time.Hour)\n\tassert.False(t, needRefresh)\n\n\t// refresh app using the 'deepest' requested comparison level\n\tctrl.requestAppRefresh(app.Name, CompareWithRecent.Pointer(), nil)\n\tctrl.requestAppRefresh(app.Name, ComparisonWithNothing.Pointer(), nil)\n\n\tneedRefresh, refreshType, compareWith := ctrl.needRefreshAppStatus(app, 1*time.Hour)\n\tassert.True(t, needRefresh)\n\tassert.Equal(t, argoappv1.RefreshTypeNormal, refreshType)\n\tassert.Equal(t, CompareWithRecent, compareWith)\n\n\t// refresh application which status is not reconciled using latest commit\n\tapp.Status.Sync = argoappv1.SyncStatus{Status: argoappv1.SyncStatusCodeUnknown}\n\n\tneedRefresh, refreshType, compareWith = ctrl.needRefreshAppStatus(app, 1*time.Hour)\n\tassert.True(t, needRefresh)\n\tassert.Equal(t, argoappv1.RefreshTypeNormal, refreshType)\n\tassert.Equal(t, CompareWithLatestForceResolve, compareWith)\n\n\t{\n\t\t// refresh app using the 'latest' level if comparison expired\n\t\tapp := app.DeepCopy()\n\t\tctrl.requestAppRefresh(app.Name, CompareWithRecent.Pointer(), nil)\n\t\treconciledAt := metav1.NewTime(time.Now().UTC().Add(-1 * time.Hour))\n\t\tapp.Status.ReconciledAt = &reconciledAt\n\t\tneedRefresh, refreshType, compareWith = ctrl.needRefreshAppStatus(app, 1*time.Minute)\n\t\tassert.True(t, needRefresh)\n\t\tassert.Equal(t, argoappv1.RefreshTypeNormal, refreshType)\n\t\tassert.Equal(t, CompareWithLatestForceResolve, compareWith)\n\t}\n\n\t{\n\t\tapp := app.DeepCopy()\n\t\t// execute hard refresh if app has refresh annotation\n\t\treconciledAt := metav1.NewTime(time.Now().UTC().Add(-1 * time.Hour))\n\t\tapp.Status.ReconciledAt = &reconciledAt\n\t\tapp.Annotations = map[string]string{\n\t\t\tv1alpha1.AnnotationKeyRefresh: string(argoappv1.RefreshTypeHard),\n\t\t}\n\t\tneedRefresh, refreshType, compareWith = ctrl.needRefreshAppStatus(app, 1*time.Hour)\n\t\tassert.True(t, needRefresh)\n\t\tassert.Equal(t, argoappv1.RefreshTypeHard, refreshType)\n\t\tassert.Equal(t, CompareWithLatestForceResolve, compareWith)\n\t}\n\n\t{\n\t\tapp := app.DeepCopy()\n\t\t// ensure that CompareWithLatest level is used if application source has changed\n\t\tctrl.requestAppRefresh(app.Name, ComparisonWithNothing.Pointer(), nil)\n\t\t// sample app source change\n\t\tapp.Spec.Source.Helm = &argoappv1.ApplicationSourceHelm{\n\t\t\tParameters: []argoappv1.HelmParameter{{\n\t\t\t\tName:  \"foo\",\n\t\t\t\tValue: \"bar\",\n\t\t\t}},\n\t\t}\n\n\t\tneedRefresh, refreshType, compareWith = ctrl.needRefreshAppStatus(app, 1*time.Hour)\n\t\tassert.True(t, needRefresh)\n\t\tassert.Equal(t, argoappv1.RefreshTypeNormal, refreshType)\n\t\tassert.Equal(t, CompareWithLatestForceResolve, compareWith)\n\t}\n}\n\nfunc TestRefreshAppConditions(t *testing.T) {\n\tdefaultProj := argoappv1.AppProject{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName:      \"default\",\n\t\t\tNamespace: test.FakeArgoCDNamespace,\n\t\t},\n\t\tSpec: argoappv1.AppProjectSpec{\n\t\t\tSourceRepos: []string{\"*\"},\n\t\t\tDestinations: []argoappv1.ApplicationDestination{\n\t\t\t\t{\n\t\t\t\t\tServer:    \"*\",\n\t\t\t\t\tNamespace: \"*\",\n\t\t\t\t},\n\t\t\t},\n\t\t},\n\t}\n\n\tt.Run(\"NoErrorConditions\", func(t *testing.T) {\n\t\tapp := newFakeApp()\n\t\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app, &defaultProj}})\n\n\t\t_, hasErrors := ctrl.refreshAppConditions(app)\n\t\tassert.False(t, hasErrors)\n\t\tassert.Len(t, app.Status.Conditions, 0)\n\t})\n\n\tt.Run(\"PreserveExistingWarningCondition\", func(t *testing.T) {\n\t\tapp := newFakeApp()\n\t\tapp.Status.SetConditions([]argoappv1.ApplicationCondition{{Type: argoappv1.ApplicationConditionExcludedResourceWarning}}, nil)\n\n\t\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app, &defaultProj}})\n\n\t\t_, hasErrors := ctrl.refreshAppConditions(app)\n\t\tassert.False(t, hasErrors)\n\t\tassert.Len(t, app.Status.Conditions, 1)\n\t\tassert.Equal(t, argoappv1.ApplicationConditionExcludedResourceWarning, app.Status.Conditions[0].Type)\n\t})\n\n\tt.Run(\"ReplacesSpecErrorCondition\", func(t *testing.T) {\n\t\tapp := newFakeApp()\n\t\tapp.Spec.Project = \"wrong project\"\n\t\tapp.Status.SetConditions([]argoappv1.ApplicationCondition{{Type: argoappv1.ApplicationConditionInvalidSpecError, Message: \"old message\"}}, nil)\n\n\t\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app, &defaultProj}})\n\n\t\t_, hasErrors := ctrl.refreshAppConditions(app)\n\t\tassert.True(t, hasErrors)\n\t\tassert.Len(t, app.Status.Conditions, 1)\n\t\tassert.Equal(t, argoappv1.ApplicationConditionInvalidSpecError, app.Status.Conditions[0].Type)\n\t\tassert.Equal(t, \"Application referencing project wrong project which does not exist\", app.Status.Conditions[0].Message)\n\t})\n}\n\nfunc TestUpdateReconciledAt(t *testing.T) {\n\tapp := newFakeApp()\n\treconciledAt := metav1.NewTime(time.Now().Add(-1 * time.Second))\n\tapp.Status = argoappv1.ApplicationStatus{ReconciledAt: &reconciledAt}\n\tapp.Status.Sync = argoappv1.SyncStatus{ComparedTo: argoappv1.ComparedTo{Source: app.Spec.Source, Destination: app.Spec.Destination}}\n\tctrl := newFakeController(&fakeData{\n\t\tapps: []runtime.Object{app, &defaultProj},\n\t\tmanifestResponse: &apiclient.ManifestResponse{\n\t\t\tManifests: []string{},\n\t\t\tNamespace: test.FakeDestNamespace,\n\t\t\tServer:    test.FakeClusterURL,\n\t\t\tRevision:  \"abc123\",\n\t\t},\n\t\tmanagedLiveObjs: make(map[kube.ResourceKey]*unstructured.Unstructured),\n\t})\n\tkey, _ := cache.MetaNamespaceKeyFunc(app)\n\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\tfakeAppCs.ReactionChain = nil\n\treceivedPatch := map[string]interface{}{}\n\tfakeAppCs.AddReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\tif patchAction, ok := action.(kubetesting.PatchAction); ok {\n\t\t\tassert.NoError(t, json.Unmarshal(patchAction.GetPatch(), &receivedPatch))\n\t\t}\n\t\treturn true, nil, nil\n\t})\n\n\tt.Run(\"UpdatedOnFullReconciliation\", func(t *testing.T) {\n\t\treceivedPatch = map[string]interface{}{}\n\t\tctrl.requestAppRefresh(app.Name, CompareWithLatest.Pointer(), nil)\n\t\tctrl.appRefreshQueue.Add(key)\n\n\t\tctrl.processAppRefreshQueueItem()\n\n\t\t_, updated, err := unstructured.NestedString(receivedPatch, \"status\", \"reconciledAt\")\n\t\tassert.NoError(t, err)\n\t\tassert.True(t, updated)\n\n\t\t_, updated, err = unstructured.NestedString(receivedPatch, \"status\", \"observedAt\")\n\t\tassert.NoError(t, err)\n\t\tassert.False(t, updated)\n\t})\n\n\tt.Run(\"NotUpdatedOnPartialReconciliation\", func(t *testing.T) {\n\t\treceivedPatch = map[string]interface{}{}\n\t\tctrl.appRefreshQueue.Add(key)\n\t\tctrl.requestAppRefresh(app.Name, CompareWithRecent.Pointer(), nil)\n\n\t\tctrl.processAppRefreshQueueItem()\n\n\t\t_, updated, err := unstructured.NestedString(receivedPatch, \"status\", \"reconciledAt\")\n\t\tassert.NoError(t, err)\n\t\tassert.False(t, updated)\n\n\t\t_, updated, err = unstructured.NestedString(receivedPatch, \"status\", \"observedAt\")\n\t\tassert.NoError(t, err)\n\t\tassert.False(t, updated)\n\t})\n\n}\n\nfunc TestFinalizeProjectDeletion_HasApplications(t *testing.T) {\n\tapp := newFakeApp()\n\tproj := &argoappv1.AppProject{ObjectMeta: metav1.ObjectMeta{Name: \"default\", Namespace: test.FakeArgoCDNamespace}}\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app, proj}})\n\n\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\tpatched := false\n\tfakeAppCs.PrependReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\tpatched = true\n\t\treturn true, nil, nil\n\t})\n\n\terr := ctrl.finalizeProjectDeletion(proj)\n\tassert.NoError(t, err)\n\tassert.False(t, patched)\n}\n\nfunc TestFinalizeProjectDeletion_DoesNotHaveApplications(t *testing.T) {\n\tproj := &argoappv1.AppProject{ObjectMeta: metav1.ObjectMeta{Name: \"default\", Namespace: test.FakeArgoCDNamespace}}\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{&defaultProj}})\n\n\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\treceivedPatch := map[string]interface{}{}\n\tfakeAppCs.PrependReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\tif patchAction, ok := action.(kubetesting.PatchAction); ok {\n\t\t\tassert.NoError(t, json.Unmarshal(patchAction.GetPatch(), &receivedPatch))\n\t\t}\n\t\treturn true, nil, nil\n\t})\n\n\terr := ctrl.finalizeProjectDeletion(proj)\n\tassert.NoError(t, err)\n\tassert.Equal(t, map[string]interface{}{\n\t\t\"metadata\": map[string]interface{}{\n\t\t\t\"finalizers\": nil,\n\t\t},\n\t}, receivedPatch)\n}\n\nfunc TestProcessRequestedAppOperation_FailedNoRetries(t *testing.T) {\n\tapp := newFakeApp()\n\tapp.Spec.Project = \"invalid-project\"\n\tapp.Operation = &argoappv1.Operation{\n\t\tSync: &argoappv1.SyncOperation{},\n\t}\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\treceivedPatch := map[string]interface{}{}\n\tfakeAppCs.PrependReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\tif patchAction, ok := action.(kubetesting.PatchAction); ok {\n\t\t\tassert.NoError(t, json.Unmarshal(patchAction.GetPatch(), &receivedPatch))\n\t\t}\n\t\treturn true, nil, nil\n\t})\n\n\tctrl.processRequestedAppOperation(app)\n\n\tphase, _, _ := unstructured.NestedString(receivedPatch, \"status\", \"operationState\", \"phase\")\n\tassert.Equal(t, string(synccommon.OperationError), phase)\n}\n\nfunc TestProcessRequestedAppOperation_InvalidDestination(t *testing.T) {\n\tapp := newFakeAppWithDestMismatch()\n\tapp.Spec.Project = \"test-project\"\n\tapp.Operation = &argoappv1.Operation{\n\t\tSync: &argoappv1.SyncOperation{},\n\t}\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\treceivedPatch := map[string]interface{}{}\n\tfunc() {\n\t\tfakeAppCs.Lock()\n\t\tdefer fakeAppCs.Unlock()\n\t\tfakeAppCs.PrependReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\t\tif patchAction, ok := action.(kubetesting.PatchAction); ok {\n\t\t\t\tassert.NoError(t, json.Unmarshal(patchAction.GetPatch(), &receivedPatch))\n\t\t\t}\n\t\t\treturn true, nil, nil\n\t\t})\n\t}()\n\n\tctrl.processRequestedAppOperation(app)\n\n\tphase, _, _ := unstructured.NestedString(receivedPatch, \"status\", \"operationState\", \"phase\")\n\tassert.Equal(t, string(synccommon.OperationFailed), phase)\n\tmessage, _, _ := unstructured.NestedString(receivedPatch, \"status\", \"operationState\", \"message\")\n\tassert.Contains(t, message, \"application destination can't have both name and server defined: another-cluster https://localhost:6443\")\n}\n\nfunc TestProcessRequestedAppOperation_FailedHasRetries(t *testing.T) {\n\tapp := newFakeApp()\n\tapp.Spec.Project = \"invalid-project\"\n\tapp.Operation = &argoappv1.Operation{\n\t\tSync:  &argoappv1.SyncOperation{},\n\t\tRetry: argoappv1.RetryStrategy{Limit: 1},\n\t}\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\treceivedPatch := map[string]interface{}{}\n\tfakeAppCs.PrependReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\tif patchAction, ok := action.(kubetesting.PatchAction); ok {\n\t\t\tassert.NoError(t, json.Unmarshal(patchAction.GetPatch(), &receivedPatch))\n\t\t}\n\t\treturn true, nil, nil\n\t})\n\n\tctrl.processRequestedAppOperation(app)\n\n\tphase, _, _ := unstructured.NestedString(receivedPatch, \"status\", \"operationState\", \"phase\")\n\tassert.Equal(t, string(synccommon.OperationRunning), phase)\n\tmessage, _, _ := unstructured.NestedString(receivedPatch, \"status\", \"operationState\", \"message\")\n\tassert.Contains(t, message, \"Retrying attempt #1\")\n\tretryCount, _, _ := unstructured.NestedFloat64(receivedPatch, \"status\", \"operationState\", \"retryCount\")\n\tassert.Equal(t, float64(1), retryCount)\n}\n\nfunc TestProcessRequestedAppOperation_RunningPreviouslyFailed(t *testing.T) {\n\tapp := newFakeApp()\n\tapp.Operation = &argoappv1.Operation{\n\t\tSync:  &argoappv1.SyncOperation{},\n\t\tRetry: argoappv1.RetryStrategy{Limit: 1},\n\t}\n\tapp.Status.OperationState.Phase = synccommon.OperationRunning\n\tapp.Status.OperationState.SyncResult.Resources = []*argoappv1.ResourceResult{{\n\t\tName:   \"guestbook\",\n\t\tKind:   \"Deployment\",\n\t\tGroup:  \"apps\",\n\t\tStatus: synccommon.ResultCodeSyncFailed,\n\t}}\n\n\tdata := &fakeData{\n\t\tapps: []runtime.Object{app, &defaultProj},\n\t\tmanifestResponse: &apiclient.ManifestResponse{\n\t\t\tManifests: []string{},\n\t\t\tNamespace: test.FakeDestNamespace,\n\t\t\tServer:    test.FakeClusterURL,\n\t\t\tRevision:  \"abc123\",\n\t\t},\n\t}\n\tctrl := newFakeController(data)\n\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\treceivedPatch := map[string]interface{}{}\n\tfakeAppCs.PrependReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\tif patchAction, ok := action.(kubetesting.PatchAction); ok {\n\t\t\tassert.NoError(t, json.Unmarshal(patchAction.GetPatch(), &receivedPatch))\n\t\t}\n\t\treturn true, nil, nil\n\t})\n\n\tctrl.processRequestedAppOperation(app)\n\n\tphase, _, _ := unstructured.NestedString(receivedPatch, \"status\", \"operationState\", \"phase\")\n\tassert.Equal(t, string(synccommon.OperationSucceeded), phase)\n}\n\nfunc TestProcessRequestedAppOperation_HasRetriesTerminated(t *testing.T) {\n\tapp := newFakeApp()\n\tapp.Operation = &argoappv1.Operation{\n\t\tSync:  &argoappv1.SyncOperation{},\n\t\tRetry: argoappv1.RetryStrategy{Limit: 10},\n\t}\n\tapp.Status.OperationState.Phase = synccommon.OperationTerminating\n\n\tdata := &fakeData{\n\t\tapps: []runtime.Object{app, &defaultProj},\n\t\tmanifestResponse: &apiclient.ManifestResponse{\n\t\t\tManifests: []string{},\n\t\t\tNamespace: test.FakeDestNamespace,\n\t\t\tServer:    test.FakeClusterURL,\n\t\t\tRevision:  \"abc123\",\n\t\t},\n\t}\n\tctrl := newFakeController(data)\n\tfakeAppCs := ctrl.applicationClientset.(*appclientset.Clientset)\n\treceivedPatch := map[string]interface{}{}\n\tfakeAppCs.PrependReactor(\"patch\", \"*\", func(action kubetesting.Action) (handled bool, ret runtime.Object, err error) {\n\t\tif patchAction, ok := action.(kubetesting.PatchAction); ok {\n\t\t\tassert.NoError(t, json.Unmarshal(patchAction.GetPatch(), &receivedPatch))\n\t\t}\n\t\treturn true, nil, nil\n\t})\n\n\tctrl.processRequestedAppOperation(app)\n\n\tphase, _, _ := unstructured.NestedString(receivedPatch, \"status\", \"operationState\", \"phase\")\n\tassert.Equal(t, string(synccommon.OperationFailed), phase)\n}\n\nfunc TestGetAppHosts(t *testing.T) {\n\tapp := newFakeApp()\n\tdata := &fakeData{\n\t\tapps: []runtime.Object{app, &defaultProj},\n\t\tmanifestResponse: &apiclient.ManifestResponse{\n\t\t\tManifests: []string{},\n\t\t\tNamespace: test.FakeDestNamespace,\n\t\t\tServer:    test.FakeClusterURL,\n\t\t\tRevision:  \"abc123\",\n\t\t},\n\t}\n\tctrl := newFakeController(data)\n\tmockStateCache := &mockstatecache.LiveStateCache{}\n\tmockStateCache.On(\"IterateResources\", mock.Anything, mock.MatchedBy(func(callback func(res *clustercache.Resource, info *statecache.ResourceInfo)) bool {\n\t\t// node resource\n\t\tcallback(&clustercache.Resource{\n\t\t\tRef: corev1.ObjectReference{Name: \"minikube\", Kind: \"Node\", APIVersion: \"v1\"},\n\t\t}, &statecache.ResourceInfo{NodeInfo: &statecache.NodeInfo{\n\t\t\tName:       \"minikube\",\n\t\t\tSystemInfo: corev1.NodeSystemInfo{OSImage: \"debian\"},\n\t\t\tCapacity:   map[corev1.ResourceName]resource.Quantity{corev1.ResourceCPU: resource.MustParse(\"5\")},\n\t\t}})\n\n\t\t// app pod\n\t\tcallback(&clustercache.Resource{\n\t\t\tRef: corev1.ObjectReference{Name: \"pod1\", Kind: kube.PodKind, APIVersion: \"v1\", Namespace: \"default\"},\n\t\t}, &statecache.ResourceInfo{PodInfo: &statecache.PodInfo{\n\t\t\tNodeName:         \"minikube\",\n\t\t\tResourceRequests: map[corev1.ResourceName]resource.Quantity{corev1.ResourceCPU: resource.MustParse(\"1\")},\n\t\t}})\n\t\t// neighbor pod\n\t\tcallback(&clustercache.Resource{\n\t\t\tRef: corev1.ObjectReference{Name: \"pod2\", Kind: kube.PodKind, APIVersion: \"v1\", Namespace: \"default\"},\n\t\t}, &statecache.ResourceInfo{PodInfo: &statecache.PodInfo{\n\t\t\tNodeName:         \"minikube\",\n\t\t\tResourceRequests: map[corev1.ResourceName]resource.Quantity{corev1.ResourceCPU: resource.MustParse(\"2\")},\n\t\t}})\n\t\treturn true\n\t})).Return(nil)\n\tctrl.stateCache = mockStateCache\n\n\thosts, err := ctrl.getAppHosts(app, []argoappv1.ResourceNode{{\n\t\tResourceRef: argoappv1.ResourceRef{Name: \"pod1\", Namespace: \"default\", Kind: kube.PodKind},\n\t\tInfo: []argoappv1.InfoItem{{\n\t\t\tName:  \"Host\",\n\t\t\tValue: \"Minikube\",\n\t\t}},\n\t}})\n\n\tassert.NoError(t, err)\n\tassert.Equal(t, []argoappv1.HostInfo{{\n\t\tName:       \"minikube\",\n\t\tSystemInfo: corev1.NodeSystemInfo{OSImage: \"debian\"},\n\t\tResourcesInfo: []argoappv1.HostResourceInfo{{\n\t\t\tResourceName: corev1.ResourceCPU, Capacity: 5000, RequestedByApp: 1000, RequestedByNeighbors: 2000},\n\t\t}}}, hosts)\n}\n\nfunc TestMetricsExpiration(t *testing.T) {\n\tapp := newFakeApp()\n\t// Check expiration is disabled by default\n\tctrl := newFakeController(&fakeData{apps: []runtime.Object{app}})\n\tassert.False(t, ctrl.metricsServer.HasExpiration())\n\t// Check expiration is enabled if set\n\tctrl = newFakeController(&fakeData{apps: []runtime.Object{app}, metricsCacheExpiration: 10 * time.Second})\n\tassert.True(t, ctrl.metricsServer.HasExpiration())\n}\n", "package cache\n\nimport (\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"net\"\n\t\"net/url\"\n\t\"os/exec\"\n\t\"reflect\"\n\t\"strings\"\n\t\"sync\"\n\t\"syscall\"\n\t\"time\"\n\n\tclustercache \"github.com/argoproj/gitops-engine/pkg/cache\"\n\t\"github.com/argoproj/gitops-engine/pkg/health\"\n\t\"github.com/argoproj/gitops-engine/pkg/utils/kube\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"golang.org/x/sync/semaphore\"\n\tv1 \"k8s.io/api/core/v1\"\n\tkerrors \"k8s.io/apimachinery/pkg/api/errors\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\n\t\"k8s.io/apimachinery/pkg/runtime/schema\"\n\t\"k8s.io/apimachinery/pkg/watch\"\n\t\"k8s.io/client-go/tools/cache\"\n\n\t\"github.com/argoproj/argo-cd/v2/controller/metrics\"\n\tappv1 \"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1\"\n\t\"github.com/argoproj/argo-cd/v2/util/argo\"\n\t\"github.com/argoproj/argo-cd/v2/util/db\"\n\t\"github.com/argoproj/argo-cd/v2/util/env\"\n\tlogutils \"github.com/argoproj/argo-cd/v2/util/log\"\n\t\"github.com/argoproj/argo-cd/v2/util/lua\"\n\t\"github.com/argoproj/argo-cd/v2/util/settings\"\n)\n\nconst (\n\t// EnvClusterCacheResyncDuration is the env variable that holds cluster cache re-sync duration\n\tEnvClusterCacheResyncDuration = \"ARGOCD_CLUSTER_CACHE_RESYNC_DURATION\"\n\n\t// EnvClusterCacheWatchResyncDuration is the env variable that holds cluster cache watch re-sync duration\n\tEnvClusterCacheWatchResyncDuration = \"ARGOCD_CLUSTER_CACHE_WATCH_RESYNC_DURATION\"\n\n\t// EnvClusterRetryTimeoutDuration is the env variable that holds cluster retry duration when sync error happens\n\tEnvClusterSyncRetryTimeoutDuration = \"ARGOCD_CLUSTER_SYNC_RETRY_TIMEOUT_DURATION\"\n\n\t// EnvClusterCacheListPageSize is the env variable to control size of the list page size when making K8s queries\n\tEnvClusterCacheListPageSize = \"ARGOCD_CLUSTER_CACHE_LIST_PAGE_SIZE\"\n\n\t// EnvClusterCacheListSemaphore is the env variable to control size of the list semaphore\n\t// This is used to limit the number of concurrent memory consuming operations on the\n\t// k8s list queries results across all clusters to avoid memory spikes during cache initialization.\n\tEnvClusterCacheListSemaphore = \"ARGOCD_CLUSTER_CACHE_LIST_SEMAPHORE\"\n\n\t// EnvClusterCacheRetryLimit is the env variable to control the retry limit for listing resources during cluster cache sync\n\tEnvClusterCacheAttemptLimit = \"ARGOCD_CLUSTER_CACHE_ATTEMPT_LIMIT\"\n\n\t// EnvClusterCacheRetryUseBackoff is the env variable to control whether to use a backoff strategy with the retry during cluster cache sync\n\tEnvClusterCacheRetryUseBackoff = \"ARGOCD_CLUSTER_CACHE_RETRY_USE_BACKOFF\"\n)\n\n// GitOps engine cluster cache tuning options\nvar (\n\t// clusterCacheResyncDuration controls the duration of cluster cache refresh.\n\t// NOTE: this differs from gitops-engine default of 24h\n\tclusterCacheResyncDuration = 12 * time.Hour\n\n\t// clusterCacheWatchResyncDuration controls the maximum duration that group/kind watches are allowed to run\n\t// for before relisting & restarting the watch\n\tclusterCacheWatchResyncDuration = 10 * time.Minute\n\n\t// clusterSyncRetryTimeoutDuration controls the sync retry duration when cluster sync error happens\n\tclusterSyncRetryTimeoutDuration = 10 * time.Second\n\n\t// The default limit of 50 is chosen based on experiments.\n\tclusterCacheListSemaphoreSize int64 = 50\n\n\t// clusterCacheListPageSize is the page size when performing K8s list requests.\n\t// 500 is equal to kubectl's size\n\tclusterCacheListPageSize int64 = 500\n\n\t// clusterCacheRetryLimit sets a retry limit for failed requests during cluster cache sync\n\t// If set to 1, retries are disabled.\n\tclusterCacheAttemptLimit int32 = 1\n\n\t// clusterCacheRetryUseBackoff specifies whether to use a backoff strategy on cluster cache sync, if retry is enabled\n\tclusterCacheRetryUseBackoff bool = false\n)\n\nfunc init() {\n\tclusterCacheResyncDuration = env.ParseDurationFromEnv(EnvClusterCacheResyncDuration, clusterCacheResyncDuration, 0, math.MaxInt64)\n\tclusterCacheWatchResyncDuration = env.ParseDurationFromEnv(EnvClusterCacheWatchResyncDuration, clusterCacheWatchResyncDuration, 0, math.MaxInt64)\n\tclusterSyncRetryTimeoutDuration = env.ParseDurationFromEnv(EnvClusterSyncRetryTimeoutDuration, clusterSyncRetryTimeoutDuration, 0, math.MaxInt64)\n\tclusterCacheListPageSize = env.ParseInt64FromEnv(EnvClusterCacheListPageSize, clusterCacheListPageSize, 0, math.MaxInt64)\n\tclusterCacheListSemaphoreSize = env.ParseInt64FromEnv(EnvClusterCacheListSemaphore, clusterCacheListSemaphoreSize, 0, math.MaxInt64)\n\tclusterCacheAttemptLimit = int32(env.ParseInt64FromEnv(EnvClusterCacheAttemptLimit, 1, 1, math.MaxInt32))\n\tclusterCacheRetryUseBackoff = env.ParseBoolFromEnv(EnvClusterCacheRetryUseBackoff, false)\n}\n\ntype LiveStateCache interface {\n\t// Returns k8s server version\n\tGetVersionsInfo(serverURL string) (string, []kube.APIResourceInfo, error)\n\t// Returns true of given group kind is a namespaced resource\n\tIsNamespaced(server string, gk schema.GroupKind) (bool, error)\n\t// Returns synced cluster cache\n\tGetClusterCache(server string) (clustercache.ClusterCache, error)\n\t// Executes give callback against resource specified by the key and all its children\n\tIterateHierarchy(server string, key kube.ResourceKey, action func(child appv1.ResourceNode, appName string) bool) error\n\t// Returns state of live nodes which correspond for target nodes of specified application.\n\tGetManagedLiveObjs(a *appv1.Application, targetObjs []*unstructured.Unstructured) (map[kube.ResourceKey]*unstructured.Unstructured, error)\n\t// IterateResources iterates all resource stored in cache\n\tIterateResources(server string, callback func(res *clustercache.Resource, info *ResourceInfo)) error\n\t// Returns all top level resources (resources without owner references) of a specified namespace\n\tGetNamespaceTopLevelResources(server string, namespace string) (map[kube.ResourceKey]appv1.ResourceNode, error)\n\t// Starts watching resources of each controlled cluster.\n\tRun(ctx context.Context) error\n\t// Returns information about monitored clusters\n\tGetClustersInfo() []clustercache.ClusterInfo\n\t// Init must be executed before cache can be used\n\tInit() error\n}\n\ntype ObjectUpdatedHandler = func(managedByApp map[string]bool, ref v1.ObjectReference)\n\ntype PodInfo struct {\n\tNodeName         string\n\tResourceRequests v1.ResourceList\n\tPhase            v1.PodPhase\n}\n\ntype NodeInfo struct {\n\tName       string\n\tCapacity   v1.ResourceList\n\tSystemInfo v1.NodeSystemInfo\n}\n\ntype ResourceInfo struct {\n\tInfo    []appv1.InfoItem\n\tAppName string\n\tImages  []string\n\tHealth  *health.HealthStatus\n\t// NetworkingInfo are available only for known types involved into networking: Ingress, Service, Pod\n\tNetworkingInfo *appv1.ResourceNetworkingInfo\n\t// PodInfo is available for pods only\n\tPodInfo *PodInfo\n\t// NodeInfo is available for nodes only\n\tNodeInfo *NodeInfo\n}\n\nfunc NewLiveStateCache(\n\tdb db.ArgoDB,\n\tappInformer cache.SharedIndexInformer,\n\tsettingsMgr *settings.SettingsManager,\n\tkubectl kube.Kubectl,\n\tmetricsServer *metrics.MetricsServer,\n\tonObjectUpdated ObjectUpdatedHandler,\n\tclusterFilter func(cluster *appv1.Cluster) bool,\n\tresourceTracking argo.ResourceTracking) LiveStateCache {\n\n\treturn &liveStateCache{\n\t\tappInformer:      appInformer,\n\t\tdb:               db,\n\t\tclusters:         make(map[string]clustercache.ClusterCache),\n\t\tonObjectUpdated:  onObjectUpdated,\n\t\tkubectl:          kubectl,\n\t\tsettingsMgr:      settingsMgr,\n\t\tmetricsServer:    metricsServer,\n\t\tclusterFilter:    clusterFilter,\n\t\tresourceTracking: resourceTracking,\n\t}\n}\n\ntype cacheSettings struct {\n\tclusterSettings     clustercache.Settings\n\tappInstanceLabelKey string\n}\n\ntype liveStateCache struct {\n\tdb               db.ArgoDB\n\tappInformer      cache.SharedIndexInformer\n\tonObjectUpdated  ObjectUpdatedHandler\n\tkubectl          kube.Kubectl\n\tsettingsMgr      *settings.SettingsManager\n\tmetricsServer    *metrics.MetricsServer\n\tclusterFilter    func(cluster *appv1.Cluster) bool\n\tresourceTracking argo.ResourceTracking\n\n\tclusters      map[string]clustercache.ClusterCache\n\tcacheSettings cacheSettings\n\tlock          sync.RWMutex\n}\n\nfunc (c *liveStateCache) loadCacheSettings() (*cacheSettings, error) {\n\tappInstanceLabelKey, err := c.settingsMgr.GetAppInstanceLabelKey()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresourcesFilter, err := c.settingsMgr.GetResourcesFilter()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresourceOverrides, err := c.settingsMgr.GetResourceOverrides()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tclusterSettings := clustercache.Settings{\n\t\tResourceHealthOverride: lua.ResourceHealthOverrides(resourceOverrides),\n\t\tResourcesFilter:        resourcesFilter,\n\t}\n\treturn &cacheSettings{clusterSettings, appInstanceLabelKey}, nil\n}\n\nfunc asResourceNode(r *clustercache.Resource) appv1.ResourceNode {\n\tgv, err := schema.ParseGroupVersion(r.Ref.APIVersion)\n\tif err != nil {\n\t\tgv = schema.GroupVersion{}\n\t}\n\tparentRefs := make([]appv1.ResourceRef, len(r.OwnerRefs))\n\tfor _, ownerRef := range r.OwnerRefs {\n\t\townerGvk := schema.FromAPIVersionAndKind(ownerRef.APIVersion, ownerRef.Kind)\n\t\townerKey := kube.NewResourceKey(ownerGvk.Group, ownerRef.Kind, r.Ref.Namespace, ownerRef.Name)\n\t\tparentRefs[0] = appv1.ResourceRef{Name: ownerRef.Name, Kind: ownerKey.Kind, Namespace: r.Ref.Namespace, Group: ownerKey.Group, UID: string(ownerRef.UID)}\n\t}\n\tvar resHealth *appv1.HealthStatus\n\tresourceInfo := resInfo(r)\n\tif resourceInfo.Health != nil {\n\t\tresHealth = &appv1.HealthStatus{Status: resourceInfo.Health.Status, Message: resourceInfo.Health.Message}\n\t}\n\treturn appv1.ResourceNode{\n\t\tResourceRef: appv1.ResourceRef{\n\t\t\tUID:       string(r.Ref.UID),\n\t\t\tName:      r.Ref.Name,\n\t\t\tGroup:     gv.Group,\n\t\t\tVersion:   gv.Version,\n\t\t\tKind:      r.Ref.Kind,\n\t\t\tNamespace: r.Ref.Namespace,\n\t\t},\n\t\tParentRefs:      parentRefs,\n\t\tInfo:            resourceInfo.Info,\n\t\tResourceVersion: r.ResourceVersion,\n\t\tNetworkingInfo:  resourceInfo.NetworkingInfo,\n\t\tImages:          resourceInfo.Images,\n\t\tHealth:          resHealth,\n\t\tCreatedAt:       r.CreationTimestamp,\n\t}\n}\n\nfunc resInfo(r *clustercache.Resource) *ResourceInfo {\n\tinfo, ok := r.Info.(*ResourceInfo)\n\tif !ok || info == nil {\n\t\tinfo = &ResourceInfo{}\n\t}\n\treturn info\n}\n\nfunc isRootAppNode(r *clustercache.Resource) bool {\n\treturn resInfo(r).AppName != \"\" && len(r.OwnerRefs) == 0\n}\n\nfunc getApp(r *clustercache.Resource, ns map[kube.ResourceKey]*clustercache.Resource) string {\n\treturn getAppRecursive(r, ns, map[kube.ResourceKey]bool{})\n}\n\nfunc ownerRefGV(ownerRef metav1.OwnerReference) schema.GroupVersion {\n\tgv, err := schema.ParseGroupVersion(ownerRef.APIVersion)\n\tif err != nil {\n\t\tgv = schema.GroupVersion{}\n\t}\n\treturn gv\n}\n\nfunc getAppRecursive(r *clustercache.Resource, ns map[kube.ResourceKey]*clustercache.Resource, visited map[kube.ResourceKey]bool) string {\n\tif !visited[r.ResourceKey()] {\n\t\tvisited[r.ResourceKey()] = true\n\t} else {\n\t\tlog.Warnf(\"Circular dependency detected: %v.\", visited)\n\t\treturn resInfo(r).AppName\n\t}\n\n\tif resInfo(r).AppName != \"\" {\n\t\treturn resInfo(r).AppName\n\t}\n\tfor _, ownerRef := range r.OwnerRefs {\n\t\tgv := ownerRefGV(ownerRef)\n\t\tif parent, ok := ns[kube.NewResourceKey(gv.Group, ownerRef.Kind, r.Ref.Namespace, ownerRef.Name)]; ok {\n\t\t\tapp := getAppRecursive(parent, ns, visited)\n\t\t\tif app != \"\" {\n\t\t\t\treturn app\n\t\t\t}\n\t\t}\n\t}\n\treturn \"\"\n}\n\nvar (\n\tignoredRefreshResources = map[string]bool{\n\t\t\"/\" + kube.EndpointsKind: true,\n\t}\n)\n\n// skipAppRequeuing checks if the object is an API type which we want to skip requeuing against.\n// We ignore API types which have a high churn rate, and/or whose updates are irrelevant to the app\nfunc skipAppRequeuing(key kube.ResourceKey) bool {\n\treturn ignoredRefreshResources[key.Group+\"/\"+key.Kind]\n}\n\n// isRetryableError is a helper method to see whether an error\n// returned from the dynamic client is potentially retryable.\nfunc isRetryableError(err error) bool {\n\tif err == nil {\n\t\treturn false\n\t}\n\treturn kerrors.IsInternalError(err) ||\n\t\tkerrors.IsInvalid(err) ||\n\t\tkerrors.IsTooManyRequests(err) ||\n\t\tkerrors.IsServerTimeout(err) ||\n\t\tkerrors.IsServiceUnavailable(err) ||\n\t\tkerrors.IsTimeout(err) ||\n\t\tkerrors.IsUnexpectedObjectError(err) ||\n\t\tkerrors.IsUnexpectedServerError(err) ||\n\t\tisResourceQuotaConflictErr(err) ||\n\t\tisTransientNetworkErr(err) ||\n\t\tisExceededQuotaErr(err) ||\n\t\terrors.Is(err, syscall.ECONNRESET)\n}\n\nfunc isExceededQuotaErr(err error) bool {\n\treturn kerrors.IsForbidden(err) && strings.Contains(err.Error(), \"exceeded quota\")\n}\n\nfunc isResourceQuotaConflictErr(err error) bool {\n\treturn kerrors.IsConflict(err) && strings.Contains(err.Error(), \"Operation cannot be fulfilled on resourcequota\")\n}\n\nfunc isTransientNetworkErr(err error) bool {\n\tswitch err.(type) {\n\tcase net.Error:\n\t\tswitch err.(type) {\n\t\tcase *net.DNSError, *net.OpError, net.UnknownNetworkError:\n\t\t\treturn true\n\t\tcase *url.Error:\n\t\t\t// For a URL error, where it replies \"connection closed\"\n\t\t\t// retry again.\n\t\t\treturn strings.Contains(err.Error(), \"Connection closed by foreign host\")\n\t\t}\n\t}\n\n\terrorString := err.Error()\n\tif exitErr, ok := err.(*exec.ExitError); ok {\n\t\terrorString = fmt.Sprintf(\"%s %s\", errorString, exitErr.Stderr)\n\t}\n\tif strings.Contains(errorString, \"net/http: TLS handshake timeout\") ||\n\t\tstrings.Contains(errorString, \"i/o timeout\") ||\n\t\tstrings.Contains(errorString, \"connection timed out\") {\n\t\treturn true\n\t}\n\treturn false\n}\n\nfunc (c *liveStateCache) getCluster(server string) (clustercache.ClusterCache, error) {\n\tc.lock.RLock()\n\tclusterCache, ok := c.clusters[server]\n\tcacheSettings := c.cacheSettings\n\tc.lock.RUnlock()\n\n\tif ok {\n\t\treturn clusterCache, nil\n\t}\n\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tclusterCache, ok = c.clusters[server]\n\tif ok {\n\t\treturn clusterCache, nil\n\t}\n\n\tcluster, err := c.db.GetCluster(context.Background(), server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif !c.canHandleCluster(cluster) {\n\t\treturn nil, fmt.Errorf(\"controller is configured to ignore cluster %s\", cluster.Server)\n\t}\n\n\ttrackingMethod := argo.GetTrackingMethod(c.settingsMgr)\n\tclusterCacheOpts := []clustercache.UpdateSettingsFunc{\n\t\tclustercache.SetListSemaphore(semaphore.NewWeighted(clusterCacheListSemaphoreSize)),\n\t\tclustercache.SetListPageSize(clusterCacheListPageSize),\n\t\tclustercache.SetWatchResyncTimeout(clusterCacheWatchResyncDuration),\n\t\tclustercache.SetClusterSyncRetryTimeout(clusterSyncRetryTimeoutDuration),\n\t\tclustercache.SetResyncTimeout(clusterCacheResyncDuration),\n\t\tclustercache.SetSettings(cacheSettings.clusterSettings),\n\t\tclustercache.SetNamespaces(cluster.Namespaces),\n\t\tclustercache.SetClusterResources(cluster.ClusterResources),\n\t\tclustercache.SetPopulateResourceInfoHandler(func(un *unstructured.Unstructured, isRoot bool) (interface{}, bool) {\n\t\t\tres := &ResourceInfo{}\n\t\t\tpopulateNodeInfo(un, res)\n\t\t\tres.Health, _ = health.GetResourceHealth(un, cacheSettings.clusterSettings.ResourceHealthOverride)\n\n\t\t\tappName := c.resourceTracking.GetAppName(un, cacheSettings.appInstanceLabelKey, trackingMethod)\n\t\t\tif isRoot && appName != \"\" {\n\t\t\t\tres.AppName = appName\n\t\t\t}\n\t\t\tgvk := un.GroupVersionKind()\n\n\t\t\t// edge case. we do not label CRDs, so they miss the tracking label we inject. But we still\n\t\t\t// want the full resource to be available in our cache (to diff), so we store all CRDs\n\t\t\treturn res, res.AppName != \"\" || gvk.Kind == kube.CustomResourceDefinitionKind\n\t\t}),\n\t\tclustercache.SetLogr(logutils.NewLogrusLogger(log.WithField(\"server\", cluster.Server))),\n\t\tclustercache.SetRetryOptions(clusterCacheAttemptLimit, clusterCacheRetryUseBackoff, isRetryableError),\n\t}\n\n\tclusterCache = clustercache.NewClusterCache(cluster.RESTConfig(), clusterCacheOpts...)\n\n\t_ = clusterCache.OnResourceUpdated(func(newRes *clustercache.Resource, oldRes *clustercache.Resource, namespaceResources map[kube.ResourceKey]*clustercache.Resource) {\n\t\ttoNotify := make(map[string]bool)\n\t\tvar ref v1.ObjectReference\n\t\tif newRes != nil {\n\t\t\tref = newRes.Ref\n\t\t} else {\n\t\t\tref = oldRes.Ref\n\t\t}\n\t\tfor _, r := range []*clustercache.Resource{newRes, oldRes} {\n\t\t\tif r == nil {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tapp := getApp(r, namespaceResources)\n\t\t\tif app == \"\" || skipAppRequeuing(r.ResourceKey()) {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\ttoNotify[app] = isRootAppNode(r) || toNotify[app]\n\t\t}\n\t\tc.onObjectUpdated(toNotify, ref)\n\t})\n\n\t_ = clusterCache.OnEvent(func(event watch.EventType, un *unstructured.Unstructured) {\n\t\tgvk := un.GroupVersionKind()\n\t\tc.metricsServer.IncClusterEventsCount(cluster.Server, gvk.Group, gvk.Kind)\n\t})\n\n\tc.clusters[server] = clusterCache\n\n\treturn clusterCache, nil\n}\n\nfunc (c *liveStateCache) getSyncedCluster(server string) (clustercache.ClusterCache, error) {\n\tclusterCache, err := c.getCluster(server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\terr = clusterCache.EnsureSynced()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn clusterCache, nil\n}\n\nfunc (c *liveStateCache) invalidate(cacheSettings cacheSettings) {\n\tlog.Info(\"invalidating live state cache\")\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\n\tc.cacheSettings = cacheSettings\n\tfor _, clust := range c.clusters {\n\t\tclust.Invalidate(clustercache.SetSettings(cacheSettings.clusterSettings))\n\t}\n\tlog.Info(\"live state cache invalidated\")\n}\n\nfunc (c *liveStateCache) IsNamespaced(server string, gk schema.GroupKind) (bool, error) {\n\tclusterInfo, err := c.getSyncedCluster(server)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\treturn clusterInfo.IsNamespaced(gk)\n}\n\nfunc (c *liveStateCache) IterateHierarchy(server string, key kube.ResourceKey, action func(child appv1.ResourceNode, appName string) bool) error {\n\tclusterInfo, err := c.getSyncedCluster(server)\n\tif err != nil {\n\t\treturn err\n\t}\n\tclusterInfo.IterateHierarchy(key, func(resource *clustercache.Resource, namespaceResources map[kube.ResourceKey]*clustercache.Resource) bool {\n\t\treturn action(asResourceNode(resource), getApp(resource, namespaceResources))\n\t})\n\treturn nil\n}\n\nfunc (c *liveStateCache) IterateResources(server string, callback func(res *clustercache.Resource, info *ResourceInfo)) error {\n\tclusterInfo, err := c.getSyncedCluster(server)\n\tif err != nil {\n\t\treturn err\n\t}\n\t_ = clusterInfo.FindResources(\"\", func(r *clustercache.Resource) bool {\n\t\tif info, ok := r.Info.(*ResourceInfo); ok {\n\t\t\tcallback(r, info)\n\t\t}\n\t\treturn false\n\t})\n\treturn nil\n}\n\nfunc (c *liveStateCache) GetNamespaceTopLevelResources(server string, namespace string) (map[kube.ResourceKey]appv1.ResourceNode, error) {\n\tclusterInfo, err := c.getSyncedCluster(server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresources := clusterInfo.FindResources(namespace, clustercache.TopLevelResource)\n\tres := make(map[kube.ResourceKey]appv1.ResourceNode)\n\tfor k, r := range resources {\n\t\tres[k] = asResourceNode(r)\n\t}\n\treturn res, nil\n}\n\nfunc (c *liveStateCache) GetManagedLiveObjs(a *appv1.Application, targetObjs []*unstructured.Unstructured) (map[kube.ResourceKey]*unstructured.Unstructured, error) {\n\tclusterInfo, err := c.getSyncedCluster(a.Spec.Destination.Server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn clusterInfo.GetManagedLiveObjs(targetObjs, func(r *clustercache.Resource) bool {\n\t\treturn resInfo(r).AppName == a.Name\n\t})\n}\n\nfunc (c *liveStateCache) GetVersionsInfo(serverURL string) (string, []kube.APIResourceInfo, error) {\n\tclusterInfo, err := c.getSyncedCluster(serverURL)\n\tif err != nil {\n\t\treturn \"\", nil, err\n\t}\n\treturn clusterInfo.GetServerVersion(), clusterInfo.GetAPIResources(), nil\n}\n\nfunc (c *liveStateCache) isClusterHasApps(apps []interface{}, cluster *appv1.Cluster) bool {\n\tfor _, obj := range apps {\n\t\tapp, ok := obj.(*appv1.Application)\n\t\tif !ok {\n\t\t\tcontinue\n\t\t}\n\t\terr := argo.ValidateDestination(context.Background(), &app.Spec.Destination, c.db)\n\t\tif err != nil {\n\t\t\tcontinue\n\t\t}\n\t\tif app.Spec.Destination.Server == cluster.Server {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\nfunc (c *liveStateCache) watchSettings(ctx context.Context) {\n\tupdateCh := make(chan *settings.ArgoCDSettings, 1)\n\tc.settingsMgr.Subscribe(updateCh)\n\n\tdone := false\n\tfor !done {\n\t\tselect {\n\t\tcase <-updateCh:\n\t\t\tnextCacheSettings, err := c.loadCacheSettings()\n\t\t\tif err != nil {\n\t\t\t\tlog.Warnf(\"Failed to read updated settings: %v\", err)\n\t\t\t\tcontinue\n\t\t\t}\n\n\t\t\tc.lock.Lock()\n\t\t\tneedInvalidate := false\n\t\t\tif !reflect.DeepEqual(c.cacheSettings, *nextCacheSettings) {\n\t\t\t\tc.cacheSettings = *nextCacheSettings\n\t\t\t\tneedInvalidate = true\n\t\t\t}\n\t\t\tc.lock.Unlock()\n\t\t\tif needInvalidate {\n\t\t\t\tc.invalidate(*nextCacheSettings)\n\t\t\t}\n\t\tcase <-ctx.Done():\n\t\t\tdone = true\n\t\t}\n\t}\n\tlog.Info(\"shutting down settings watch\")\n\tc.settingsMgr.Unsubscribe(updateCh)\n\tclose(updateCh)\n}\n\nfunc (c *liveStateCache) Init() error {\n\tcacheSettings, err := c.loadCacheSettings()\n\tif err != nil {\n\t\treturn err\n\t}\n\tc.cacheSettings = *cacheSettings\n\treturn nil\n}\n\n// Run watches for resource changes annotated with application label on all registered clusters and schedule corresponding app refresh.\nfunc (c *liveStateCache) Run(ctx context.Context) error {\n\tgo c.watchSettings(ctx)\n\n\tkube.RetryUntilSucceed(ctx, clustercache.ClusterRetryTimeout, \"watch clusters\", logutils.NewLogrusLogger(logutils.NewWithCurrentConfig()), func() error {\n\t\treturn c.db.WatchClusters(ctx, c.handleAddEvent, c.handleModEvent, c.handleDeleteEvent)\n\t})\n\n\t<-ctx.Done()\n\tc.invalidate(c.cacheSettings)\n\treturn nil\n}\n\nfunc (c *liveStateCache) canHandleCluster(cluster *appv1.Cluster) bool {\n\tif c.clusterFilter == nil {\n\t\treturn true\n\t}\n\treturn c.clusterFilter(cluster)\n}\n\nfunc (c *liveStateCache) handleAddEvent(cluster *appv1.Cluster) {\n\tif !c.canHandleCluster(cluster) {\n\t\tlog.Infof(\"Ignoring cluster %s\", cluster.Server)\n\t\treturn\n\t}\n\n\tc.lock.Lock()\n\t_, ok := c.clusters[cluster.Server]\n\tc.lock.Unlock()\n\tif !ok {\n\t\tif c.isClusterHasApps(c.appInformer.GetStore().List(), cluster) {\n\t\t\tgo func() {\n\t\t\t\t// warm up cache for cluster with apps\n\t\t\t\t_, _ = c.getSyncedCluster(cluster.Server)\n\t\t\t}()\n\t\t}\n\t}\n}\n\nfunc (c *liveStateCache) handleModEvent(oldCluster *appv1.Cluster, newCluster *appv1.Cluster) {\n\tc.lock.Lock()\n\tcluster, ok := c.clusters[newCluster.Server]\n\tc.lock.Unlock()\n\tif ok {\n\t\tif !c.canHandleCluster(newCluster) {\n\t\t\tcluster.Invalidate()\n\t\t\tc.lock.Lock()\n\t\t\tdelete(c.clusters, newCluster.Server)\n\t\t\tc.lock.Unlock()\n\t\t\treturn\n\t\t}\n\n\t\tvar updateSettings []clustercache.UpdateSettingsFunc\n\t\tif !reflect.DeepEqual(oldCluster.Config, newCluster.Config) {\n\t\t\tupdateSettings = append(updateSettings, clustercache.SetConfig(newCluster.RESTConfig()))\n\t\t}\n\t\tif !reflect.DeepEqual(oldCluster.Namespaces, newCluster.Namespaces) {\n\t\t\tupdateSettings = append(updateSettings, clustercache.SetNamespaces(newCluster.Namespaces))\n\t\t}\n\t\tif !reflect.DeepEqual(oldCluster.ClusterResources, newCluster.ClusterResources) {\n\t\t\tupdateSettings = append(updateSettings, clustercache.SetClusterResources(newCluster.ClusterResources))\n\t\t}\n\t\tforceInvalidate := false\n\t\tif newCluster.RefreshRequestedAt != nil &&\n\t\t\tcluster.GetClusterInfo().LastCacheSyncTime != nil &&\n\t\t\tcluster.GetClusterInfo().LastCacheSyncTime.Before(newCluster.RefreshRequestedAt.Time) {\n\t\t\tforceInvalidate = true\n\t\t}\n\n\t\tif len(updateSettings) > 0 || forceInvalidate {\n\t\t\tcluster.Invalidate(updateSettings...)\n\t\t\tgo func() {\n\t\t\t\t// warm up cluster cache\n\t\t\t\t_ = cluster.EnsureSynced()\n\t\t\t}()\n\t\t}\n\t}\n\n}\n\nfunc (c *liveStateCache) handleDeleteEvent(clusterServer string) {\n\tc.lock.Lock()\n\tdefer c.lock.Unlock()\n\tcluster, ok := c.clusters[clusterServer]\n\tif ok {\n\t\tcluster.Invalidate()\n\t\tdelete(c.clusters, clusterServer)\n\t}\n}\n\nfunc (c *liveStateCache) GetClustersInfo() []clustercache.ClusterInfo {\n\tclusters := make(map[string]clustercache.ClusterCache)\n\tc.lock.RLock()\n\tfor k := range c.clusters {\n\t\tclusters[k] = c.clusters[k]\n\t}\n\tc.lock.RUnlock()\n\n\tres := make([]clustercache.ClusterInfo, 0)\n\tfor server, c := range clusters {\n\t\tinfo := c.GetClusterInfo()\n\t\tinfo.Server = server\n\t\tres = append(res, info)\n\t}\n\treturn res\n}\n\nfunc (c *liveStateCache) GetClusterCache(server string) (clustercache.ClusterCache, error) {\n\treturn c.getSyncedCluster(server)\n}\n", "// Code generated by mockery v1.0.0. DO NOT EDIT.\n\npackage mocks\n\nimport (\n\tcontext \"context\"\n\n\tcache \"github.com/argoproj/gitops-engine/pkg/cache\"\n\n\tcontrollercache \"github.com/argoproj/argo-cd/v2/controller/cache\"\n\n\tkube \"github.com/argoproj/gitops-engine/pkg/utils/kube\"\n\n\tmock \"github.com/stretchr/testify/mock\"\n\n\tschema \"k8s.io/apimachinery/pkg/runtime/schema\"\n\n\tunstructured \"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\n\n\tv1alpha1 \"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1\"\n)\n\n// LiveStateCache is an autogenerated mock type for the LiveStateCache type\ntype LiveStateCache struct {\n\tmock.Mock\n}\n\n// GetClusterCache provides a mock function with given fields: server\nfunc (_m *LiveStateCache) GetClusterCache(server string) (cache.ClusterCache, error) {\n\tret := _m.Called(server)\n\n\tvar r0 cache.ClusterCache\n\tif rf, ok := ret.Get(0).(func(string) cache.ClusterCache); ok {\n\t\tr0 = rf(server)\n\t} else {\n\t\tif ret.Get(0) != nil {\n\t\t\tr0 = ret.Get(0).(cache.ClusterCache)\n\t\t}\n\t}\n\n\tvar r1 error\n\tif rf, ok := ret.Get(1).(func(string) error); ok {\n\t\tr1 = rf(server)\n\t} else {\n\t\tr1 = ret.Error(1)\n\t}\n\n\treturn r0, r1\n}\n\n// GetClustersInfo provides a mock function with given fields:\nfunc (_m *LiveStateCache) GetClustersInfo() []cache.ClusterInfo {\n\tret := _m.Called()\n\n\tvar r0 []cache.ClusterInfo\n\tif rf, ok := ret.Get(0).(func() []cache.ClusterInfo); ok {\n\t\tr0 = rf()\n\t} else {\n\t\tif ret.Get(0) != nil {\n\t\t\tr0 = ret.Get(0).([]cache.ClusterInfo)\n\t\t}\n\t}\n\n\treturn r0\n}\n\n// GetManagedLiveObjs provides a mock function with given fields: a, targetObjs\nfunc (_m *LiveStateCache) GetManagedLiveObjs(a *v1alpha1.Application, targetObjs []*unstructured.Unstructured) (map[kube.ResourceKey]*unstructured.Unstructured, error) {\n\tret := _m.Called(a, targetObjs)\n\n\tvar r0 map[kube.ResourceKey]*unstructured.Unstructured\n\tif rf, ok := ret.Get(0).(func(*v1alpha1.Application, []*unstructured.Unstructured) map[kube.ResourceKey]*unstructured.Unstructured); ok {\n\t\tr0 = rf(a, targetObjs)\n\t} else {\n\t\tif ret.Get(0) != nil {\n\t\t\tr0 = ret.Get(0).(map[kube.ResourceKey]*unstructured.Unstructured)\n\t\t}\n\t}\n\n\tvar r1 error\n\tif rf, ok := ret.Get(1).(func(*v1alpha1.Application, []*unstructured.Unstructured) error); ok {\n\t\tr1 = rf(a, targetObjs)\n\t} else {\n\t\tr1 = ret.Error(1)\n\t}\n\n\treturn r0, r1\n}\n\n// GetNamespaceTopLevelResources provides a mock function with given fields: server, namespace\nfunc (_m *LiveStateCache) GetNamespaceTopLevelResources(server string, namespace string) (map[kube.ResourceKey]v1alpha1.ResourceNode, error) {\n\tret := _m.Called(server, namespace)\n\n\tvar r0 map[kube.ResourceKey]v1alpha1.ResourceNode\n\tif rf, ok := ret.Get(0).(func(string, string) map[kube.ResourceKey]v1alpha1.ResourceNode); ok {\n\t\tr0 = rf(server, namespace)\n\t} else {\n\t\tif ret.Get(0) != nil {\n\t\t\tr0 = ret.Get(0).(map[kube.ResourceKey]v1alpha1.ResourceNode)\n\t\t}\n\t}\n\n\tvar r1 error\n\tif rf, ok := ret.Get(1).(func(string, string) error); ok {\n\t\tr1 = rf(server, namespace)\n\t} else {\n\t\tr1 = ret.Error(1)\n\t}\n\n\treturn r0, r1\n}\n\n// GetVersionsInfo provides a mock function with given fields: serverURL\nfunc (_m *LiveStateCache) GetVersionsInfo(serverURL string) (string, []kube.APIResourceInfo, error) {\n\tret := _m.Called(serverURL)\n\n\tvar r0 string\n\tif rf, ok := ret.Get(0).(func(string) string); ok {\n\t\tr0 = rf(serverURL)\n\t} else {\n\t\tr0 = ret.Get(0).(string)\n\t}\n\n\tvar r1 []kube.APIResourceInfo\n\tif rf, ok := ret.Get(1).(func(string) []kube.APIResourceInfo); ok {\n\t\tr1 = rf(serverURL)\n\t} else {\n\t\tif ret.Get(1) != nil {\n\t\t\tr1 = ret.Get(1).([]kube.APIResourceInfo)\n\t\t}\n\t}\n\n\tvar r2 error\n\tif rf, ok := ret.Get(2).(func(string) error); ok {\n\t\tr2 = rf(serverURL)\n\t} else {\n\t\tr2 = ret.Error(2)\n\t}\n\n\treturn r0, r1, r2\n}\n\n// Init provides a mock function with given fields:\nfunc (_m *LiveStateCache) Init() error {\n\tret := _m.Called()\n\n\tvar r0 error\n\tif rf, ok := ret.Get(0).(func() error); ok {\n\t\tr0 = rf()\n\t} else {\n\t\tr0 = ret.Error(0)\n\t}\n\n\treturn r0\n}\n\n// IsNamespaced provides a mock function with given fields: server, gk\nfunc (_m *LiveStateCache) IsNamespaced(server string, gk schema.GroupKind) (bool, error) {\n\tret := _m.Called(server, gk)\n\n\tvar r0 bool\n\tif rf, ok := ret.Get(0).(func(string, schema.GroupKind) bool); ok {\n\t\tr0 = rf(server, gk)\n\t} else {\n\t\tr0 = ret.Get(0).(bool)\n\t}\n\n\tvar r1 error\n\tif rf, ok := ret.Get(1).(func(string, schema.GroupKind) error); ok {\n\t\tr1 = rf(server, gk)\n\t} else {\n\t\tr1 = ret.Error(1)\n\t}\n\n\treturn r0, r1\n}\n\n// IterateHierarchy provides a mock function with given fields: server, key, action\nfunc (_m *LiveStateCache) IterateHierarchy(server string, key kube.ResourceKey, action func(v1alpha1.ResourceNode, string) bool) error {\n\tret := _m.Called(server, key, action)\n\n\tvar r0 error\n\tif rf, ok := ret.Get(0).(func(string, kube.ResourceKey, func(v1alpha1.ResourceNode, string) bool) error); ok {\n\t\tr0 = rf(server, key, action)\n\t} else {\n\t\tr0 = ret.Error(0)\n\t}\n\n\treturn r0\n}\n\n// IterateResources provides a mock function with given fields: server, callback\nfunc (_m *LiveStateCache) IterateResources(server string, callback func(*cache.Resource, *controllercache.ResourceInfo)) error {\n\tret := _m.Called(server, callback)\n\n\tvar r0 error\n\tif rf, ok := ret.Get(0).(func(string, func(*cache.Resource, *controllercache.ResourceInfo)) error); ok {\n\t\tr0 = rf(server, callback)\n\t} else {\n\t\tr0 = ret.Error(0)\n\t}\n\n\treturn r0\n}\n\n// Run provides a mock function with given fields: ctx\nfunc (_m *LiveStateCache) Run(ctx context.Context) error {\n\tret := _m.Called(ctx)\n\n\tvar r0 error\n\tif rf, ok := ret.Get(0).(func(context.Context) error); ok {\n\t\tr0 = rf(ctx)\n\t} else {\n\t\tr0 = ret.Error(0)\n\t}\n\n\treturn r0\n}\n", "module github.com/argoproj/argo-cd/v2\n\ngo 1.17\n\nrequire (\n\tgithub.com/Knetic/govaluate v3.0.1-0.20171022003610-9aa49832a739+incompatible\n\tgithub.com/Masterminds/semver/v3 v3.1.1\n\tgithub.com/TomOnTime/utfutil v0.0.0-20180511104225-09c41003ee1d\n\tgithub.com/alicebob/miniredis v2.5.0+incompatible\n\tgithub.com/alicebob/miniredis/v2 v2.14.2\n\tgithub.com/argoproj/gitops-engine v0.6.1-0.20220316000647-723667dff7d5\n\tgithub.com/argoproj/notifications-engine v0.3.1-0.20220127183449-91deed20b998\n\tgithub.com/argoproj/pkg v0.11.1-0.20211203175135-36c59d8fafe0\n\tgithub.com/bombsimon/logrusr/v2 v2.0.1\n\tgithub.com/bradleyfalzon/ghinstallation/v2 v2.0.4\n\tgithub.com/casbin/casbin/v2 v2.39.1\n\tgithub.com/chai2010/gettext-go v0.0.0-20170215093142-bf70f2a70fb1 // indirect\n\tgithub.com/coreos/go-oidc v2.1.0+incompatible\n\tgithub.com/dustin/go-humanize v1.0.0\n\tgithub.com/evanphx/json-patch v4.12.0+incompatible\n\tgithub.com/fsnotify/fsnotify v1.5.1\n\tgithub.com/ghodss/yaml v1.0.0\n\tgithub.com/go-git/go-git/v5 v5.4.2\n\tgithub.com/go-logr/logr v1.2.2\n\tgithub.com/go-openapi/loads v0.19.4\n\tgithub.com/go-openapi/runtime v0.19.4\n\tgithub.com/go-openapi/spec v0.19.5 // indirect\n\tgithub.com/go-openapi/validate v0.19.5 // indirect\n\tgithub.com/go-redis/cache/v8 v8.4.2\n\tgithub.com/go-redis/redis/v8 v8.11.3\n\tgithub.com/gobwas/glob v0.2.3\n\tgithub.com/gogits/go-gogs-client v0.0.0-20190616193657-5a05380e4bc2\n\tgithub.com/gogo/protobuf v1.3.2\n\tgithub.com/golang-jwt/jwt/v4 v4.2.0\n\tgithub.com/golang/protobuf v1.5.2\n\tgithub.com/gomodule/redigo v2.0.0+incompatible // indirect\n\tgithub.com/google/go-cmp v0.5.6\n\tgithub.com/google/go-jsonnet v0.18.0\n\tgithub.com/google/shlex v0.0.0-20191202100458-e7afc7fbc510\n\tgithub.com/google/uuid v1.1.2\n\tgithub.com/gorilla/handlers v1.5.1\n\tgithub.com/gregjones/httpcache v0.0.0-20190611155906-901d90724c79 // indirect\n\tgithub.com/grpc-ecosystem/go-grpc-middleware v1.3.0\n\tgithub.com/grpc-ecosystem/go-grpc-prometheus v1.2.0\n\tgithub.com/grpc-ecosystem/grpc-gateway v1.16.0\n\tgithub.com/hashicorp/go-retryablehttp v0.7.0\n\tgithub.com/improbable-eng/grpc-web v0.0.0-20181111100011-16092bd1d58a\n\tgithub.com/itchyny/gojq v0.12.3\n\tgithub.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51\n\tgithub.com/malexdev/utfutil v0.0.0-20180510171754-00c8d4a8e7a8 // indirect\n\tgithub.com/mattn/go-isatty v0.0.12\n\tgithub.com/mattn/go-zglob v0.0.3\n\tgithub.com/olekukonko/tablewriter v0.0.5\n\tgithub.com/patrickmn/go-cache v2.1.0+incompatible\n\tgithub.com/pkg/errors v0.9.1\n\tgithub.com/pquerna/cachecontrol v0.0.0-20180306154005-525d0eb5f91d // indirect\n\tgithub.com/prometheus/client_golang v1.11.0\n\tgithub.com/r3labs/diff v1.1.0\n\tgithub.com/robfig/cron v1.2.0\n\tgithub.com/rs/cors v1.8.0 // indirect\n\tgithub.com/sirupsen/logrus v1.8.1\n\tgithub.com/skratchdot/open-golang v0.0.0-20160302144031-75fb7ed4208c\n\tgithub.com/soheilhy/cmux v0.1.5\n\tgithub.com/spf13/cobra v1.2.1\n\tgithub.com/spf13/pflag v1.0.5\n\tgithub.com/stretchr/testify v1.7.0\n\tgithub.com/undefinedlabs/go-mpatch v1.0.6\n\tgithub.com/whilp/git-urls v0.0.0-20191001220047-6db9661140c0\n\tgithub.com/yuin/gopher-lua v0.0.0-20200816102855-ee81675732da\n\tgolang.org/x/crypto v0.0.0-20210817164053-32db794688a5\n\tgolang.org/x/net v0.0.0-20211209124913-491a49abca63\n\tgolang.org/x/oauth2 v0.0.0-20210819190943-2bc19b11175f\n\tgolang.org/x/sync v0.0.0-20210220032951-036812b2e83c\n\tgolang.org/x/term v0.0.0-20210615171337-6886f2dfbf5b\n\tgoogle.golang.org/genproto v0.0.0-20210831024726-fe130286e0e2\n\tgoogle.golang.org/grpc v1.40.0\n\tgoogle.golang.org/protobuf v1.27.1\n\tgopkg.in/go-playground/webhooks.v5 v5.11.0\n\tgopkg.in/yaml.v2 v2.4.0\n\tk8s.io/api v0.23.1\n\tk8s.io/apiextensions-apiserver v0.23.1\n\tk8s.io/apimachinery v0.23.1\n\tk8s.io/client-go v0.23.1\n\tk8s.io/code-generator v0.23.1\n\tk8s.io/klog/v2 v2.30.0\n\tk8s.io/kube-openapi v0.0.0-20211115234752-e816edb12b65\n\tk8s.io/kubectl v0.23.1\n\tk8s.io/utils v0.0.0-20210930125809-cb0fa318a74b\n\tlayeh.com/gopher-json v0.0.0-20190114024228-97fed8db8427\n\tsigs.k8s.io/controller-runtime v0.11.0\n\tsigs.k8s.io/structured-merge-diff/v4 v4.2.0\n\tsigs.k8s.io/yaml v1.3.0\n)\n\nrequire (\n\tcloud.google.com/go v0.81.0 // indirect\n\tgithub.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1 // indirect\n\tgithub.com/Azure/go-autorest v14.2.0+incompatible // indirect\n\tgithub.com/Azure/go-autorest/autorest v0.11.18 // indirect\n\tgithub.com/Azure/go-autorest/autorest/adal v0.9.13 // indirect\n\tgithub.com/Azure/go-autorest/autorest/date v0.3.0 // indirect\n\tgithub.com/Azure/go-autorest/logger v0.2.1 // indirect\n\tgithub.com/Azure/go-autorest/tracing v0.6.0 // indirect\n\tgithub.com/MakeNowJust/heredoc v0.0.0-20170808103936-bb23615498cd // indirect\n\tgithub.com/Masterminds/goutils v1.1.0 // indirect\n\tgithub.com/Masterminds/semver v1.5.0 // indirect\n\tgithub.com/Masterminds/sprig v2.22.0+incompatible // indirect\n\tgithub.com/Microsoft/go-winio v0.4.17 // indirect\n\tgithub.com/ProtonMail/go-crypto v0.0.0-20210428141323-04723f9f07d7 // indirect\n\tgithub.com/PuerkitoBio/purell v1.1.1 // indirect\n\tgithub.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578 // indirect\n\tgithub.com/RocketChat/Rocket.Chat.Go.SDK v0.0.0-20210112200207-10ab4d695d60 // indirect\n\tgithub.com/acomagu/bufpipe v1.0.3 // indirect\n\tgithub.com/alicebob/gopher-json v0.0.0-20200520072559-a9ecdc9d1d3a // indirect\n\tgithub.com/antonmedv/expr v1.8.9 // indirect\n\tgithub.com/asaskevich/govalidator v0.0.0-20190424111038-f61b66f89f4a // indirect\n\tgithub.com/beorn7/perks v1.0.1 // indirect\n\tgithub.com/cespare/xxhash/v2 v2.1.2 // indirect\n\tgithub.com/cpuguy83/go-md2man/v2 v2.0.0 // indirect\n\tgithub.com/davecgh/go-spew v1.1.1 // indirect\n\tgithub.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f // indirect\n\tgithub.com/docker/distribution v2.7.1+incompatible // indirect\n\tgithub.com/emicklei/go-restful v2.9.5+incompatible // indirect\n\tgithub.com/emirpasic/gods v1.12.0 // indirect\n\tgithub.com/exponent-io/jsonpath v0.0.0-20151013193312-d6023ce2651d // indirect\n\tgithub.com/fatih/camelcase v1.0.0 // indirect\n\tgithub.com/felixge/httpsnoop v1.0.1 // indirect\n\tgithub.com/form3tech-oss/jwt-go v3.2.3+incompatible // indirect\n\tgithub.com/fvbommel/sortorder v1.0.1 // indirect\n\tgithub.com/go-errors/errors v1.0.1 // indirect\n\tgithub.com/go-git/gcfg v1.5.0 // indirect\n\tgithub.com/go-git/go-billy/v5 v5.3.1 // indirect\n\tgithub.com/go-openapi/analysis v0.19.5 // indirect\n\tgithub.com/go-openapi/errors v0.19.2 // indirect\n\tgithub.com/go-openapi/jsonpointer v0.19.5 // indirect\n\tgithub.com/go-openapi/jsonreference v0.19.5 // indirect\n\tgithub.com/go-openapi/strfmt v0.19.3 // indirect\n\tgithub.com/go-openapi/swag v0.19.14 // indirect\n\tgithub.com/go-stack/stack v1.8.0 // indirect\n\tgithub.com/go-telegram-bot-api/telegram-bot-api/v5 v5.4.0 // indirect\n\tgithub.com/golang/glog v1.0.0 // indirect\n\tgithub.com/google/btree v1.0.1 // indirect\n\tgithub.com/google/go-github/v41 v41.0.0 // indirect\n\tgithub.com/google/go-querystring v1.1.0 // indirect\n\tgithub.com/google/gofuzz v1.1.0 // indirect\n\tgithub.com/googleapis/gnostic v0.5.5 // indirect\n\tgithub.com/gorilla/websocket v1.4.2 // indirect\n\tgithub.com/gregdel/pushover v1.1.0 // indirect\n\tgithub.com/hashicorp/go-cleanhttp v0.5.1 // indirect\n\tgithub.com/huandu/xstrings v1.3.0 // indirect\n\tgithub.com/imdario/mergo v0.3.12 // indirect\n\tgithub.com/inconshreveable/mousetrap v1.0.0 // indirect\n\tgithub.com/itchyny/timefmt-go v0.1.2 // indirect\n\tgithub.com/jbenet/go-context v0.0.0-20150711004518-d14ea06fba99 // indirect\n\tgithub.com/jonboulle/clockwork v0.2.2 // indirect\n\tgithub.com/josharian/intern v1.0.0 // indirect\n\tgithub.com/json-iterator/go v1.1.12 // indirect\n\tgithub.com/kevinburke/ssh_config v0.0.0-20201106050909-4977a11b4351 // indirect\n\tgithub.com/klauspost/compress v1.13.5 // indirect\n\tgithub.com/liggitt/tabwriter v0.0.0-20181228230101-89fcab3d43de // indirect\n\tgithub.com/mailru/easyjson v0.7.6 // indirect\n\tgithub.com/mattn/go-runewidth v0.0.9 // indirect\n\tgithub.com/matttproud/golang_protobuf_extensions v1.0.2-0.20181231171920-c182affec369 // indirect\n\tgithub.com/mitchellh/copystructure v1.0.0 // indirect\n\tgithub.com/mitchellh/go-homedir v1.1.0 // indirect\n\tgithub.com/mitchellh/go-wordwrap v1.0.0 // indirect\n\tgithub.com/mitchellh/mapstructure v1.4.1 // indirect\n\tgithub.com/mitchellh/reflectwalk v1.0.0 // indirect\n\tgithub.com/moby/spdystream v0.2.0 // indirect\n\tgithub.com/moby/term v0.0.0-20210610120745-9d4ed1856297 // indirect\n\tgithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd // indirect\n\tgithub.com/modern-go/reflect2 v1.0.2 // indirect\n\tgithub.com/monochromegane/go-gitignore v0.0.0-20200626010858-205db1a8cc00 // indirect\n\tgithub.com/opencontainers/go-digest v1.0.0 // indirect\n\tgithub.com/opsgenie/opsgenie-go-sdk-v2 v1.0.5 // indirect\n\tgithub.com/peterbourgon/diskv v2.0.1+incompatible // indirect\n\tgithub.com/pmezard/go-difflib v1.0.0 // indirect\n\tgithub.com/prometheus/client_model v0.2.0 // indirect\n\tgithub.com/prometheus/common v0.28.0 // indirect\n\tgithub.com/prometheus/procfs v0.6.0 // indirect\n\tgithub.com/russross/blackfriday v1.5.2 // indirect\n\tgithub.com/russross/blackfriday/v2 v2.0.1 // indirect\n\tgithub.com/sergi/go-diff v1.1.0 // indirect\n\tgithub.com/shurcooL/sanitized_anchor_name v1.0.0 // indirect\n\tgithub.com/slack-go/slack v0.10.1 // indirect\n\tgithub.com/stretchr/objx v0.2.0 // indirect\n\tgithub.com/vmihailenco/go-tinylfu v0.2.1 // indirect\n\tgithub.com/vmihailenco/msgpack/v5 v5.3.4 // indirect\n\tgithub.com/vmihailenco/tagparser/v2 v2.0.0 // indirect\n\tgithub.com/xanzy/ssh-agent v0.3.0 // indirect\n\tgithub.com/xlab/treeprint v0.0.0-20181112141820-a009c3971eca // indirect\n\tgo.mongodb.org/mongo-driver v1.1.2 // indirect\n\tgo.starlark.net v0.0.0-20200306205701-8dd3e2ee1dd5 // indirect\n\tgolang.org/x/exp v0.0.0-20210901193431-a062eea981d2 // indirect\n\tgolang.org/x/mod v0.5.1-0.20210830214625-1b1db11ec8f4 // indirect\n\tgolang.org/x/sys v0.0.0-20211029165221-6e7872819dc8 // indirect\n\tgolang.org/x/text v0.3.7 // indirect\n\tgolang.org/x/time v0.0.0-20210723032227-1f47c861a9ac // indirect\n\tgolang.org/x/tools v0.1.6-0.20210820212750-d4cc65f0b2ff // indirect\n\tgolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1 // indirect\n\tgomodules.xyz/envconfig v1.3.1-0.20190308184047-426f31af0d45 // indirect\n\tgomodules.xyz/notify v0.1.0 // indirect\n\tgoogle.golang.org/appengine v1.6.7 // indirect\n\tgopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc // indirect\n\tgopkg.in/gomail.v2 v2.0.0-20160411212932-81ebce5c23df // indirect\n\tgopkg.in/inf.v0 v0.9.1 // indirect\n\tgopkg.in/square/go-jose.v2 v2.2.2 // indirect\n\tgopkg.in/warnings.v0 v0.1.2 // indirect\n\tgopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b // indirect\n\tk8s.io/apiserver v0.23.1 // indirect\n\tk8s.io/cli-runtime v0.23.1 // indirect\n\tk8s.io/component-base v0.23.1 // indirect\n\tk8s.io/component-helpers v0.23.1 // indirect\n\tk8s.io/gengo v0.0.0-20211129171323-c02415ce4185 // indirect\n\tk8s.io/kube-aggregator v0.23.1 // indirect\n\tk8s.io/kubernetes v1.23.1 // indirect\n\tsigs.k8s.io/json v0.0.0-20211020170558-c049b76a60c6 // indirect\n\tsigs.k8s.io/kustomize/api v0.10.1 // indirect\n\tsigs.k8s.io/kustomize/kyaml v0.13.0 // indirect\n)\n\nreplace (\n\t// https://github.com/golang/go/issues/33546#issuecomment-519656923\n\tgithub.com/go-check/check => github.com/go-check/check v0.0.0-20180628173108-788fd7840127\n\n\tgithub.com/golang/protobuf => github.com/golang/protobuf v1.4.2\n\tgithub.com/gorilla/websocket => github.com/gorilla/websocket v1.4.2\n\tgithub.com/grpc-ecosystem/grpc-gateway => github.com/grpc-ecosystem/grpc-gateway v1.16.0\n\tgithub.com/improbable-eng/grpc-web => github.com/improbable-eng/grpc-web v0.0.0-20181111100011-16092bd1d58a\n\n\tgoogle.golang.org/grpc => google.golang.org/grpc v1.15.0\n\n\t// https://github.com/kubernetes/kubernetes/issues/79384#issuecomment-505627280\n\tk8s.io/api => k8s.io/api v0.23.1\n\tk8s.io/apiextensions-apiserver => k8s.io/apiextensions-apiserver v0.23.1\n\tk8s.io/apimachinery => k8s.io/apimachinery v0.23.1\n\tk8s.io/apiserver => k8s.io/apiserver v0.23.1\n\tk8s.io/cli-runtime => k8s.io/cli-runtime v0.23.1\n\tk8s.io/client-go => k8s.io/client-go v0.23.1\n\tk8s.io/cloud-provider => k8s.io/cloud-provider v0.23.1\n\tk8s.io/cluster-bootstrap => k8s.io/cluster-bootstrap v0.23.1\n\tk8s.io/code-generator => k8s.io/code-generator v0.23.1\n\tk8s.io/component-base => k8s.io/component-base v0.23.1\n\tk8s.io/component-helpers => k8s.io/component-helpers v0.23.1\n\tk8s.io/controller-manager => k8s.io/controller-manager v0.23.1\n\tk8s.io/cri-api => k8s.io/cri-api v0.23.1\n\tk8s.io/csi-translation-lib => k8s.io/csi-translation-lib v0.23.1\n\tk8s.io/kube-aggregator => k8s.io/kube-aggregator v0.23.1\n\tk8s.io/kube-controller-manager => k8s.io/kube-controller-manager v0.23.1\n\tk8s.io/kube-proxy => k8s.io/kube-proxy v0.23.1\n\tk8s.io/kube-scheduler => k8s.io/kube-scheduler v0.23.1\n\tk8s.io/kubectl => k8s.io/kubectl v0.23.1\n\tk8s.io/kubelet => k8s.io/kubelet v0.23.1\n\tk8s.io/legacy-cloud-providers => k8s.io/legacy-cloud-providers v0.23.1\n\tk8s.io/metrics => k8s.io/metrics v0.23.1\n\tk8s.io/mount-utils => k8s.io/mount-utils v0.23.1\n\tk8s.io/pod-security-admission => k8s.io/pod-security-admission v0.23.1\n\tk8s.io/sample-apiserver => k8s.io/sample-apiserver v0.23.1\n)\n", "bazil.org/fuse v0.0.0-20160811212531-371fbbdaa898/go.mod h1:Xbm+BRKSBEpa4q4hTSxohYNQpsxXPbPry4JJWOB3LB8=\nbitbucket.org/bertimus9/systemstat v0.0.0-20180207000608-0eeff89b0690/go.mod h1:Ulb78X89vxKYgdL24HMTiXYHlyHEvruOj1ZPlqeNEZM=\ncloud.google.com/go v0.26.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.34.0/go.mod h1:aQUYkXzVsufM+DwF1aE+0xfcU+56JwCaLick0ClmMTw=\ncloud.google.com/go v0.38.0/go.mod h1:990N+gfupTy94rShfmMCWGDn0LpTmnzTp2qbd1dvSRU=\ncloud.google.com/go v0.44.1/go.mod h1:iSa0KzasP4Uvy3f1mN/7PiObzGgflwredwwASm/v6AU=\ncloud.google.com/go v0.44.2/go.mod h1:60680Gw3Yr4ikxnPRS/oxxkBccT6SA1yMk63TGekxKY=\ncloud.google.com/go v0.45.1/go.mod h1:RpBamKRgapWJb87xiFSdk4g1CME7QZg3uwTez+TSTjc=\ncloud.google.com/go v0.46.3/go.mod h1:a6bKKbmY7er1mI7TEI4lsAkts/mkhTSZK8w33B4RAg0=\ncloud.google.com/go v0.50.0/go.mod h1:r9sluTvynVuxRIOHXQEHMFffphuXHOMZMycpNR5e6To=\ncloud.google.com/go v0.52.0/go.mod h1:pXajvRH/6o3+F9jDHZWQ5PbGhn+o8w9qiu/CffaVdO4=\ncloud.google.com/go v0.53.0/go.mod h1:fp/UouUEsRkN6ryDKNW/Upv/JBKnv6WDthjR6+vze6M=\ncloud.google.com/go v0.54.0/go.mod h1:1rq2OEkV3YMf6n/9ZvGWI3GWw0VoqH/1x2nd8Is/bPc=\ncloud.google.com/go v0.56.0/go.mod h1:jr7tqZxxKOVYizybht9+26Z/gUq7tiRzu+ACVAMbKVk=\ncloud.google.com/go v0.57.0/go.mod h1:oXiQ6Rzq3RAkkY7N6t3TcE6jE+CIBBbA36lwQ1JyzZs=\ncloud.google.com/go v0.62.0/go.mod h1:jmCYTdRCQuc1PHIIJ/maLInMho30T/Y0M4hTdTShOYc=\ncloud.google.com/go v0.65.0/go.mod h1:O5N8zS7uWy9vkA9vayVHs65eM1ubvY4h553ofrNHObY=\ncloud.google.com/go v0.72.0/go.mod h1:M+5Vjvlc2wnp6tjzE102Dw08nGShTscUx2nZMufOKPI=\ncloud.google.com/go v0.74.0/go.mod h1:VV1xSbzvo+9QJOxLDaJfTjx5e+MePCpCWwvftOeQmWk=\ncloud.google.com/go v0.78.0/go.mod h1:QjdrLG0uq+YwhjoVOLsS1t7TW8fs36kLs4XO5R5ECHg=\ncloud.google.com/go v0.79.0/go.mod h1:3bzgcEeQlzbuEAYu4mrWhKqWjmpprinYgKJLgKHnbb8=\ncloud.google.com/go v0.81.0 h1:at8Tk2zUz63cLPR0JPWm5vp77pEZmzxEQBEfRKn1VV8=\ncloud.google.com/go v0.81.0/go.mod h1:mk/AM35KwGk/Nm2YSeZbxXdrNK3KZOYHmLkOqC2V6E0=\ncloud.google.com/go/bigquery v1.0.1/go.mod h1:i/xbL2UlR5RvWAURpBYZTtm/cXjCha9lbfbpx4poX+o=\ncloud.google.com/go/bigquery v1.3.0/go.mod h1:PjpwJnslEMmckchkHFfq+HTD2DmtT67aNFKH1/VBDHE=\ncloud.google.com/go/bigquery v1.4.0/go.mod h1:S8dzgnTigyfTmLBfrtrhyYhwRxG72rYxvftPBK2Dvzc=\ncloud.google.com/go/bigquery v1.5.0/go.mod h1:snEHRnqQbz117VIFhE8bmtwIDY80NLUZUMb4Nv6dBIg=\ncloud.google.com/go/bigquery v1.7.0/go.mod h1://okPTzCYNXSlb24MZs83e2Do+h+VXtc4gLoIoXIAPc=\ncloud.google.com/go/bigquery v1.8.0/go.mod h1:J5hqkt3O0uAFnINi6JXValWIb1v0goeZM77hZzJN/fQ=\ncloud.google.com/go/datastore v1.0.0/go.mod h1:LXYbyblFSglQ5pkeyhO+Qmw7ukd3C+pD7TKLgZqpHYE=\ncloud.google.com/go/datastore v1.1.0/go.mod h1:umbIZjpQpHh4hmRpGhH4tLFup+FVzqBi1b3c64qFpCk=\ncloud.google.com/go/firestore v1.1.0/go.mod h1:ulACoGHTpvq5r8rxGJ4ddJZBZqakUQqClKRT5SZwBmk=\ncloud.google.com/go/pubsub v1.0.1/go.mod h1:R0Gpsv3s54REJCy4fxDixWD93lHJMoZTyQ2kNxGRt3I=\ncloud.google.com/go/pubsub v1.1.0/go.mod h1:EwwdRX2sKPjnvnqCa270oGRyludottCI76h+R3AArQw=\ncloud.google.com/go/pubsub v1.2.0/go.mod h1:jhfEVHT8odbXTkndysNHCcx0awwzvfOlguIAii9o8iA=\ncloud.google.com/go/pubsub v1.3.1/go.mod h1:i+ucay31+CNRpDW4Lu78I4xXG+O1r/MAHgjpRVR+TSU=\ncloud.google.com/go/storage v1.0.0/go.mod h1:IhtSnM/ZTZV8YYJWCY8RULGVqBDmpoyjwiyrjsg+URw=\ncloud.google.com/go/storage v1.5.0/go.mod h1:tpKbwo567HUNpVclU5sGELwQWBDZ8gh0ZeosJ0Rtdos=\ncloud.google.com/go/storage v1.6.0/go.mod h1:N7U0C8pVQ/+NIKOBQyamJIeKQKkZ+mxpohlUTyfDhBk=\ncloud.google.com/go/storage v1.8.0/go.mod h1:Wv1Oy7z6Yz3DshWRJFhqM/UCfaWIRTdp0RXyy7KQOVs=\ncloud.google.com/go/storage v1.10.0/go.mod h1:FLPqc6j+Ki4BU591ie1oL6qBQGu2Bl/tZ9ullr3+Kg0=\ndmitri.shuralyov.com/gpu/mtl v0.0.0-20190408044501-666a987793e9/go.mod h1:H6x//7gZCb22OMCxBHrMx7a5I7Hp++hsVxbQ4BYO7hU=\ndmitri.shuralyov.com/gpu/mtl v0.0.0-20201218220906-28db891af037/go.mod h1:H6x//7gZCb22OMCxBHrMx7a5I7Hp++hsVxbQ4BYO7hU=\ngithub.com/Azure/azure-sdk-for-go v55.0.0+incompatible/go.mod h1:9XXNKU+eRnpl9moKnB4QOLf1HestfXbmab5FXxiDBjc=\ngithub.com/Azure/go-ansiterm v0.0.0-20170929234023-d6e3b3328b78/go.mod h1:LmzpDX56iTiv29bbRTIsUNlaFfuhWRQBWjQdVyAevI8=\ngithub.com/Azure/go-ansiterm v0.0.0-20210608223527-2377c96fe795/go.mod h1:LmzpDX56iTiv29bbRTIsUNlaFfuhWRQBWjQdVyAevI8=\ngithub.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1 h1:UQHMgLO+TxOElx5B5HZ4hJQsoJ/PvUvKRhJHDQXO8P8=\ngithub.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1/go.mod h1:xomTg63KZ2rFqZQzSB4Vz2SUXa1BpHTVz9L5PTmPC4E=\ngithub.com/Azure/go-autorest v14.2.0+incompatible h1:V5VMDjClD3GiElqLWO7mz2MxNAK/vTfRHdAubSIPRgs=\ngithub.com/Azure/go-autorest v14.2.0+incompatible/go.mod h1:r+4oMnoxhatjLLJ6zxSWATqVooLgysK6ZNox3g/xq24=\ngithub.com/Azure/go-autorest/autorest v0.11.18 h1:90Y4srNYrwOtAgVo3ndrQkTYn6kf1Eg/AjTFJ8Is2aM=\ngithub.com/Azure/go-autorest/autorest v0.11.18/go.mod h1:dSiJPy22c3u0OtOKDNttNgqpNFY/GeWa7GH/Pz56QRA=\ngithub.com/Azure/go-autorest/autorest/adal v0.9.13 h1:Mp5hbtOePIzM8pJVRa3YLrWWmZtoxRXqUEzCfJt3+/Q=\ngithub.com/Azure/go-autorest/autorest/adal v0.9.13/go.mod h1:W/MM4U6nLxnIskrw4UwWzlHfGjwUS50aOsc/I3yuU8M=\ngithub.com/Azure/go-autorest/autorest/date v0.3.0 h1:7gUk1U5M/CQbp9WoqinNzJar+8KY+LPI6wiWrP/myHw=\ngithub.com/Azure/go-autorest/autorest/date v0.3.0/go.mod h1:BI0uouVdmngYNUzGWeSYnokU+TrmwEsOqdt8Y6sso74=\ngithub.com/Azure/go-autorest/autorest/mocks v0.4.1 h1:K0laFcLE6VLTOwNgSxaGbUcLPuGXlNkbVvq4cW4nIHk=\ngithub.com/Azure/go-autorest/autorest/mocks v0.4.1/go.mod h1:LTp+uSrOhSkaKrUy935gNZuuIPPVsHlr9DSOxSayd+k=\ngithub.com/Azure/go-autorest/autorest/to v0.4.0/go.mod h1:fE8iZBn7LQR7zH/9XU2NcPR4o9jEImooCeWJcYV/zLE=\ngithub.com/Azure/go-autorest/autorest/validation v0.1.0/go.mod h1:Ha3z/SqBeaalWQvokg3NZAlQTalVMtOIAs1aGK7G6u8=\ngithub.com/Azure/go-autorest/logger v0.2.1 h1:IG7i4p/mDa2Ce4TRyAO8IHnVhAVF3RFU+ZtXWSmf4Tg=\ngithub.com/Azure/go-autorest/logger v0.2.1/go.mod h1:T9E3cAhj2VqvPOtCYAvby9aBXkZmbF5NWuPV8+WeEW8=\ngithub.com/Azure/go-autorest/tracing v0.6.0 h1:TYi4+3m5t6K48TGI9AUdb+IzbnSxvnvUMfuitfgcfuo=\ngithub.com/Azure/go-autorest/tracing v0.6.0/go.mod h1:+vhtPC754Xsa23ID7GlGsrdKBpUA79WCAKPPZVC2DeU=\ngithub.com/BurntSushi/toml v0.3.1/go.mod h1:xHWCNGjB5oqiDr8zfno3MHue2Ht5sIBksp03qcyfWMU=\ngithub.com/BurntSushi/xgb v0.0.0-20160522181843-27f122750802/go.mod h1:IVnqGOEym/WlBOVXweHU+Q+/VP0lqqI8lqeDx9IjBqo=\ngithub.com/DATA-DOG/go-sqlmock v1.3.3/go.mod h1:f/Ixk793poVmq4qj/V1dPUg2JEAKC73Q5eFN3EC/SaM=\ngithub.com/GoogleCloudPlatform/k8s-cloud-provider v1.16.1-0.20210702024009-ea6160c1d0e3/go.mod h1:8XasY4ymP2V/tn2OOV9ZadmiTE1FIB/h3W+yNlPttKw=\ngithub.com/JeffAshton/win_pdh v0.0.0-20161109143554-76bb4ee9f0ab/go.mod h1:3VYc5hodBMJ5+l/7J4xAyMeuM2PNuepvHlGs8yilUCA=\ngithub.com/Jeffail/gabs v1.4.0 h1://5fYRRTq1edjfIrQGvdkcd22pkYUrHZ5YC/H2GJVAo=\ngithub.com/Jeffail/gabs v1.4.0/go.mod h1:6xMvQMK4k33lb7GUUpaAPh6nKMmemQeg5d4gn7/bOXc=\ngithub.com/Knetic/govaluate v3.0.1-0.20171022003610-9aa49832a739+incompatible h1:1G1pk05UrOh0NlF1oeaaix1x8XzrfjIDK47TY0Zehcw=\ngithub.com/Knetic/govaluate v3.0.1-0.20171022003610-9aa49832a739+incompatible/go.mod h1:r7JcOSlj0wfOMncg0iLm8Leh48TZaKVeNIfJntJ2wa0=\ngithub.com/MakeNowJust/heredoc v0.0.0-20170808103936-bb23615498cd h1:sjQovDkwrZp8u+gxLtPgKGjk5hCxuy2hrRejBTA9xFU=\ngithub.com/MakeNowJust/heredoc v0.0.0-20170808103936-bb23615498cd/go.mod h1:64YHyfSL2R96J44Nlwm39UHepQbyR5q10x7iYa1ks2E=\ngithub.com/Masterminds/goutils v1.1.0 h1:zukEsf/1JZwCMgHiK3GZftabmxiCw4apj3a28RPBiVg=\ngithub.com/Masterminds/goutils v1.1.0/go.mod h1:8cTjp+g8YejhMuvIA5y2vz3BpJxksy863GQaJW2MFNU=\ngithub.com/Masterminds/semver v1.5.0 h1:H65muMkzWKEuNDnfl9d70GUjFniHKHRbFPGBuZ3QEww=\ngithub.com/Masterminds/semver v1.5.0/go.mod h1:MB6lktGJrhw8PrUyiEoblNEGEQ+RzHPF078ddwwvV3Y=\ngithub.com/Masterminds/semver/v3 v3.1.1 h1:hLg3sBzpNErnxhQtUy/mmLR2I9foDujNK030IGemrRc=\ngithub.com/Masterminds/semver/v3 v3.1.1/go.mod h1:VPu/7SZ7ePZ3QOrcuXROw5FAcLl4a0cBrbBpGY/8hQs=\ngithub.com/Masterminds/sprig v2.22.0+incompatible h1:z4yfnGrZ7netVz+0EDJ0Wi+5VZCSYp4Z0m2dk6cEM60=\ngithub.com/Masterminds/sprig v2.22.0+incompatible/go.mod h1:y6hNFY5UBTIWBxnzTeuNhlNS5hqE0NB0E6fgfo2Br3o=\ngithub.com/Microsoft/go-winio v0.4.14/go.mod h1:qXqCSQ3Xa7+6tgxaGTIe4Kpcdsi+P8jBhyzoq1bpyYA=\ngithub.com/Microsoft/go-winio v0.4.15/go.mod h1:tTuCMEN+UleMWgg9dVx4Hu52b1bJo+59jBh3ajtinzw=\ngithub.com/Microsoft/go-winio v0.4.16/go.mod h1:XB6nPKklQyQ7GC9LdcBEcBl8PF76WugXOPRXwdLnMv0=\ngithub.com/Microsoft/go-winio v0.4.17 h1:iT12IBVClFevaf8PuVyi3UmZOVh4OqnaLxDTW2O6j3w=\ngithub.com/Microsoft/go-winio v0.4.17/go.mod h1:JPGBdM1cNvN/6ISo+n8V5iA4v8pBzdOpzfwIujj1a84=\ngithub.com/Microsoft/hcsshim v0.8.22/go.mod h1:91uVCVzvX2QD16sMCenoxxXo6L1wJnLMX2PSufFMtF0=\ngithub.com/NYTimes/gziphandler v0.0.0-20170623195520-56545f4a5d46/go.mod h1:3wb06e3pkSAbeQ52E9H9iFoQsEEwGN64994WTCIhntQ=\ngithub.com/NYTimes/gziphandler v1.1.1/go.mod h1:n/CVRwUEOgIxrgPvAQhUUr9oeUtvrhMomdKFjzJNB0c=\ngithub.com/OneOfOne/xxhash v1.2.2/go.mod h1:HSdplMjZKSmBqAxg5vPj2TmRDmfkzw+cTzAElWljhcU=\ngithub.com/ProtonMail/go-crypto v0.0.0-20210428141323-04723f9f07d7 h1:YoJbenK9C67SkzkDfmQuVln04ygHj3vjZfd9FL+GmQQ=\ngithub.com/ProtonMail/go-crypto v0.0.0-20210428141323-04723f9f07d7/go.mod h1:z4/9nQmJSSwwds7ejkxaJwO37dru3geImFUdJlaLzQo=\ngithub.com/PuerkitoBio/purell v1.1.0/go.mod h1:c11w/QuzBsJSee3cPx9rAFu61PvFxuPbtSwDGJws/X0=\ngithub.com/PuerkitoBio/purell v1.1.1 h1:WEQqlqaGbrPkxLJWfBwQmfEAE1Z7ONdDLqrN38tNFfI=\ngithub.com/PuerkitoBio/purell v1.1.1/go.mod h1:c11w/QuzBsJSee3cPx9rAFu61PvFxuPbtSwDGJws/X0=\ngithub.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578 h1:d+Bc7a5rLufV/sSk/8dngufqelfh6jnri85riMAaF/M=\ngithub.com/PuerkitoBio/urlesc v0.0.0-20170810143723-de5bf2ad4578/go.mod h1:uGdkoq3SwY9Y+13GIhn11/XLaGBb4BfwItxLd5jeuXE=\ngithub.com/RocketChat/Rocket.Chat.Go.SDK v0.0.0-20210112200207-10ab4d695d60 h1:prBTRx78AQnXzivNT9Crhu564W/zPPr3ibSlpT9xKcE=\ngithub.com/RocketChat/Rocket.Chat.Go.SDK v0.0.0-20210112200207-10ab4d695d60/go.mod h1:rjP7sIipbZcagro/6TCk6X0ZeFT2eyudH5+fve/cbBA=\ngithub.com/Shopify/sarama v1.19.0/go.mod h1:FVkBWblsNy7DGZRfXLU0O9RCGt5g3g3yEuWXgklEdEo=\ngithub.com/Shopify/toxiproxy v2.1.4+incompatible/go.mod h1:OXgGpZ6Cli1/URJOF1DMxUHB2q5Ap20/P/eIdh4G0pI=\ngithub.com/TomOnTime/utfutil v0.0.0-20180511104225-09c41003ee1d h1:WtAMR0fPCOfK7TPGZ8ZpLLY18HRvL7XJ3xcs0wnREgo=\ngithub.com/TomOnTime/utfutil v0.0.0-20180511104225-09c41003ee1d/go.mod h1:WML6KOYjeU8N6YyusMjj2qRvaPNUEvrQvaxuFcMRFJY=\ngithub.com/VividCortex/gohistogram v1.0.0/go.mod h1:Pf5mBqqDxYaXu3hDrrU+w6nw50o/4+TcAqDqk/vUH7g=\ngithub.com/acomagu/bufpipe v1.0.3 h1:fxAGrHZTgQ9w5QqVItgzwj235/uYZYgbXitB+dLupOk=\ngithub.com/acomagu/bufpipe v1.0.3/go.mod h1:mxdxdup/WdsKVreO5GpW4+M/1CE2sMG4jeGJ2sYmHc4=\ngithub.com/afex/hystrix-go v0.0.0-20180502004556-fa1af6a1f4f5/go.mod h1:SkGFH1ia65gfNATL8TAiHDNxPzPdmEL5uirI2Uyuz6c=\ngithub.com/agnivade/levenshtein v1.0.1/go.mod h1:CURSv5d9Uaml+FovSIICkLbAUZ9S4RqaHDIsdSBg7lM=\ngithub.com/ajstarks/svgo v0.0.0-20180226025133-644b8db467af/go.mod h1:K08gAheRH3/J6wwsYMMT4xOr94bZjxIelGM0+d/wbFw=\ngithub.com/alecthomas/template v0.0.0-20160405071501-a0175ee3bccc/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=\ngithub.com/alecthomas/template v0.0.0-20190718012654-fb15b899a751/go.mod h1:LOuyumcjzFXgccqObfd/Ljyb9UuFJ6TxHnclSeseNhc=\ngithub.com/alecthomas/units v0.0.0-20151022065526-2efee857e7cf/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=\ngithub.com/alecthomas/units v0.0.0-20190717042225-c3de453c63f4/go.mod h1:ybxpYRFXyAe+OPACYpWeL0wqObRcbAqCMya13uyzqw0=\ngithub.com/alecthomas/units v0.0.0-20190924025748-f65c72e2690d/go.mod h1:rBZYJk541a8SKzHPHnH3zbiI+7dagKZ0cgpgrD7Fyho=\ngithub.com/alicebob/gopher-json v0.0.0-20200520072559-a9ecdc9d1d3a h1:HbKu58rmZpUGpz5+4FfNmIU+FmZg2P3Xaj2v2bfNWmk=\ngithub.com/alicebob/gopher-json v0.0.0-20200520072559-a9ecdc9d1d3a/go.mod h1:SGnFV6hVsYE877CKEZ6tDNTjaSXYUk6QqoIK6PrAtcc=\ngithub.com/alicebob/miniredis v2.5.0+incompatible h1:yBHoLpsyjupjz3NL3MhKMVkR41j82Yjf3KFv7ApYzUI=\ngithub.com/alicebob/miniredis v2.5.0+incompatible/go.mod h1:8HZjEj4yU0dwhYHky+DxYx+6BMjkBbe5ONFIF1MXffk=\ngithub.com/alicebob/miniredis/v2 v2.14.2 h1:VeoqKUAsJfT2af61nDE7qhBzqn3J6xjnt9MFAbdrEtg=\ngithub.com/alicebob/miniredis/v2 v2.14.2/go.mod h1:gquAfGbzn92jvtrSC69+6zZnwSODVXVpYDRaGhWaL6I=\ngithub.com/andreyvit/diff v0.0.0-20170406064948-c7f18ee00883/go.mod h1:rCTlJbsFo29Kk6CurOXKm700vrz8f0KW0JNfpkRJY/8=\ngithub.com/anmitsu/go-shlex v0.0.0-20161002113705-648efa622239 h1:kFOfPq6dUM1hTo4JG6LR5AXSUEsOjtdm0kw0FtQtMJA=\ngithub.com/anmitsu/go-shlex v0.0.0-20161002113705-648efa622239/go.mod h1:2FmKhYUyUczH0OGQWaF5ceTx0UBShxjsH6f8oGKYe2c=\ngithub.com/antihax/optional v1.0.0/go.mod h1:uupD/76wgC+ih3iEmQUL+0Ugr19nfwCT1kdvxnR2qWY=\ngithub.com/antlr/antlr4/runtime/Go/antlr v0.0.0-20210826220005-b48c857c3a0e/go.mod h1:F7bn7fEU90QkQ3tnmaTx3LTKLEDqnwWODIYppRQ5hnY=\ngithub.com/antonmedv/expr v1.8.9 h1:O9stiHmHHww9b4ozhPx7T6BK7fXfOCHJ8ybxf0833zw=\ngithub.com/antonmedv/expr v1.8.9/go.mod h1:5qsM3oLGDND7sDmQGDXHkYfkjYMUX14qsgqmHhwGEk8=\ngithub.com/apache/thrift v0.12.0/go.mod h1:cp2SuWMxlEZw2r+iP2GNCdIi4C1qmUzdZFSVb+bacwQ=\ngithub.com/apache/thrift v0.13.0/go.mod h1:cp2SuWMxlEZw2r+iP2GNCdIi4C1qmUzdZFSVb+bacwQ=\ngithub.com/appscode/go v0.0.0-20190808133642-1d4ef1f1c1e0/go.mod h1:iy07dV61Z7QQdCKJCIvUoDL21u6AIceRhZzyleh2ymc=\ngithub.com/argoproj/gitops-engine v0.6.1-0.20220316000647-723667dff7d5 h1:QZvSvXHKx/hKTvbw3EK+u9JDVlo6UvC4+IVqNIGbcUo=\ngithub.com/argoproj/gitops-engine v0.6.1-0.20220316000647-723667dff7d5/go.mod h1:pRgVpLW7pZqf7n3COJ7UcDepk4cI61LAcJd64Q3Jq/c=\ngithub.com/argoproj/notifications-engine v0.3.1-0.20220127183449-91deed20b998 h1:V9RDg+IZeebnm3XjkfkbN07VM21Fu1Cy/RJNoHO++VM=\ngithub.com/argoproj/notifications-engine v0.3.1-0.20220127183449-91deed20b998/go.mod h1:5mKv7zEgI3NO0L+fsuRSwBSY9EIXSuyIsDND8O8TTIw=\ngithub.com/argoproj/pkg v0.11.1-0.20211203175135-36c59d8fafe0 h1:Cfp7rO/HpVxnwlRqJe0jHiBbZ77ZgXhB6HWlYD02Xdc=\ngithub.com/argoproj/pkg v0.11.1-0.20211203175135-36c59d8fafe0/go.mod h1:ra+bQPmbVAoEL+gYSKesuigt4m49i3Qa3mE/xQcjCiA=\ngithub.com/armon/circbuf v0.0.0-20150827004946-bbbad097214e/go.mod h1:3U/XgcO3hCbHZ8TKRvWD2dDTCfh9M9ya+I9JpbB7O8o=\ngithub.com/armon/consul-api v0.0.0-20180202201655-eb2c6b5be1b6/go.mod h1:grANhF5doyWs3UAsr3K4I6qtAmlQcZDesFNEHPZAzj8=\ngithub.com/armon/go-metrics v0.0.0-20180917152333-f0300d1749da/go.mod h1:Q73ZrmVTwzkszR9V5SSuryQ31EELlFMUz1kKyl939pY=\ngithub.com/armon/go-radix v0.0.0-20180808171621-7fddfc383310/go.mod h1:ufUuZ+zHj4x4TnLV4JWEpy2hxWSpsRywHrMgIH9cCH8=\ngithub.com/armon/go-socks5 v0.0.0-20160902184237-e75332964ef5 h1:0CwZNZbxp69SHPdPJAN/hZIm0C4OItdklCFmMRWYpio=\ngithub.com/armon/go-socks5 v0.0.0-20160902184237-e75332964ef5/go.mod h1:wHh0iHkYZB8zMSxRWpUBQtwG5a7fFgvEO+odwuTv2gs=\ngithub.com/aryann/difflib v0.0.0-20170710044230-e206f873d14a/go.mod h1:DAHtR1m6lCRdSC2Tm3DSWRPvIPr6xNKyeHdqDQSQT+A=\ngithub.com/asaskevich/govalidator v0.0.0-20180720115003-f9ffefc3facf/go.mod h1:lB+ZfQJz7igIIfQNfa7Ml4HSf2uFQQRzpGGRXenZAgY=\ngithub.com/asaskevich/govalidator v0.0.0-20190424111038-f61b66f89f4a h1:idn718Q4B6AGu/h5Sxe66HYVdqdGu2l9Iebqhi/AEoA=\ngithub.com/asaskevich/govalidator v0.0.0-20190424111038-f61b66f89f4a/go.mod h1:lB+ZfQJz7igIIfQNfa7Ml4HSf2uFQQRzpGGRXenZAgY=\ngithub.com/auth0/go-jwt-middleware v1.0.1/go.mod h1:YSeUX3z6+TF2H+7padiEqNJ73Zy9vXW72U//IgN0BIM=\ngithub.com/aws/aws-lambda-go v1.13.3/go.mod h1:4UKl9IzQMoD+QF79YdCuzCwp8VbmG4VAQwij/eHl5CU=\ngithub.com/aws/aws-sdk-go v1.27.0/go.mod h1:KmX6BPdI08NWTb3/sm4ZGu5ShLoqVDhKgpiN924inxo=\ngithub.com/aws/aws-sdk-go v1.33.16/go.mod h1:5zCpMtNQVjRREroY7sYe8lOMRSxkhG6MZveU8YkpAk0=\ngithub.com/aws/aws-sdk-go v1.35.24/go.mod h1:tlPOdRjfxPBpNIwqDj61rmsnA85v9jc0Ps9+muhnW+k=\ngithub.com/aws/aws-sdk-go v1.38.49/go.mod h1:hcU610XS61/+aQV88ixoOzUoG7v3b31pl2zKMmprdro=\ngithub.com/aws/aws-sdk-go-v2 v0.18.0/go.mod h1:JWVYvqSMppoMJC0x5wdwiImzgXTI9FuZwxzkQq9wy+g=\ngithub.com/beevik/ntp v0.2.0/go.mod h1:hIHWr+l3+/clUnF44zdK+CWW7fO8dR5cIylAQ76NRpg=\ngithub.com/benbjohnson/clock v1.0.3/go.mod h1:bGMdMPoPVvcYyt1gHDf4J2KE153Yf9BuiUKYMaxlTDM=\ngithub.com/benbjohnson/clock v1.1.0/go.mod h1:J11/hYXuz8f4ySSvYwY0FKfm+ezbsZBKZxNJlLklBHA=\ngithub.com/beorn7/perks v0.0.0-20180321164747-3a771d992973/go.mod h1:Dwedo/Wpr24TaqPxmxbtue+5NUziq4I4S80YR8gNf3Q=\ngithub.com/beorn7/perks v1.0.0/go.mod h1:KWe93zE9D1o94FZ5RNwFwVgaQK1VOXiVxmqh+CedLV8=\ngithub.com/beorn7/perks v1.0.1 h1:VlbKKnNfV8bJzeqoa4cOKqO6bYr3WgKZxO8Z16+hsOM=\ngithub.com/beorn7/perks v1.0.1/go.mod h1:G2ZrVWU2WbWT9wwq4/hrbKbnv/1ERSJQ0ibhJ6rlkpw=\ngithub.com/bgentry/speakeasy v0.1.0/go.mod h1:+zsyZBPWlz7T6j88CTgSN5bM796AkVf0kBD4zp0CCIs=\ngithub.com/bits-and-blooms/bitset v1.2.0/go.mod h1:gIdJ4wp64HaoK2YrL1Q5/N7Y16edYb8uY+O0FJTyyDA=\ngithub.com/bketelsen/crypt v0.0.3-0.20200106085610-5cbc8cc4026c/go.mod h1:MKsuJmJgSg28kpZDP6UIiPt0e0Oz0kqKNGyRaWEPv84=\ngithub.com/bketelsen/crypt v0.0.4/go.mod h1:aI6NrJ0pMGgvZKL1iVgXLnfIFJtfV+bKCoqOes/6LfM=\ngithub.com/blang/semver v3.5.0+incompatible/go.mod h1:kRBLl5iJ+tD4TcOOxsy/0fnwebNt5EWlYSAyrTnjyyk=\ngithub.com/blang/semver v3.5.1+incompatible/go.mod h1:kRBLl5iJ+tD4TcOOxsy/0fnwebNt5EWlYSAyrTnjyyk=\ngithub.com/boltdb/bolt v1.3.1/go.mod h1:clJnj/oiGkjum5o1McbSZDSLxVThjynRyGBgiAx27Ps=\ngithub.com/bombsimon/logrusr/v2 v2.0.1 h1:1VgxVNQMCvjirZIYaT9JYn6sAVGVEcNtRE0y4mvaOAM=\ngithub.com/bombsimon/logrusr/v2 v2.0.1/go.mod h1:ByVAX+vHdLGAfdroiMg6q0zgq2FODY2lc5YJvzmOJio=\ngithub.com/bradleyfalzon/ghinstallation/v2 v2.0.4 h1:tXKVfhE7FcSkhkv0UwkLvPDeZ4kz6OXd0PKPlFqf81M=\ngithub.com/bradleyfalzon/ghinstallation/v2 v2.0.4/go.mod h1:B40qPqJxWE0jDZgOR1JmaMy+4AY1eBP+IByOvqyAKp0=\ngithub.com/bwmarrin/discordgo v0.19.0/go.mod h1:O9S4p+ofTFwB02em7jkpkV8M3R0/PUVOwN61zSZ0r4Q=\ngithub.com/casbin/casbin/v2 v2.1.2/go.mod h1:YcPU1XXisHhLzuxH9coDNf2FbKpjGlbCg3n9yuLkIJQ=\ngithub.com/casbin/casbin/v2 v2.39.1 h1:TatfPL1hByffzPs610HL8+gBjCisAtEhjVhpIsbZ+ws=\ngithub.com/casbin/casbin/v2 v2.39.1/go.mod h1:sEL80qBYTbd+BPeL4iyvwYzFT3qwLaESq5aFKVLbLfA=\ngithub.com/cenkalti/backoff v2.1.1+incompatible/go.mod h1:90ReRw6GdpyfrHakVjL/QHaoyV4aDUVVkXQJJJ3NXXM=\ngithub.com/cenkalti/backoff v2.2.1+incompatible/go.mod h1:90ReRw6GdpyfrHakVjL/QHaoyV4aDUVVkXQJJJ3NXXM=\ngithub.com/certifi/gocertifi v0.0.0-20191021191039-0944d244cd40/go.mod h1:sGbDF6GwGcLpkNXPUTkMRoywsNa/ol15pxFe6ERfguA=\ngithub.com/certifi/gocertifi v0.0.0-20200922220541-2c3bb06c6054/go.mod h1:sGbDF6GwGcLpkNXPUTkMRoywsNa/ol15pxFe6ERfguA=\ngithub.com/cespare/xxhash v1.1.0 h1:a6HrQnmkObjyL+Gs60czilIUGqrzKutQD6XZog3p+ko=\ngithub.com/cespare/xxhash v1.1.0/go.mod h1:XrSqR1VqqWfGrhpAt58auRo0WTKS1nRRg3ghfAqPWnc=\ngithub.com/cespare/xxhash/v2 v2.1.1/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/cespare/xxhash/v2 v2.1.2 h1:YRXhKfTDauu4ajMg1TPgFO5jnlC2HCbmLXMcTG5cbYE=\ngithub.com/cespare/xxhash/v2 v2.1.2/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=\ngithub.com/chai2010/gettext-go v0.0.0-20160711120539-c6fed771bfd5/go.mod h1:/iP1qXHoty45bqomnu2LM+VVyAEdWN+vtSHGlQgyxbw=\ngithub.com/chai2010/gettext-go v0.0.0-20170215093142-bf70f2a70fb1 h1:HD4PLRzjuCVW79mQ0/pdsalOLHJ+FaEoqJLxfltpb2U=\ngithub.com/chai2010/gettext-go v0.0.0-20170215093142-bf70f2a70fb1/go.mod h1:/iP1qXHoty45bqomnu2LM+VVyAEdWN+vtSHGlQgyxbw=\ngithub.com/checkpoint-restore/go-criu/v5 v5.0.0/go.mod h1:cfwC0EG7HMUenopBsUf9d89JlCLQIfgVcNsNN0t6T2M=\ngithub.com/chzyer/logex v1.1.10/go.mod h1:+Ywpsq7O8HXn0nuIou7OrIPyXbp3wmkHB+jjWRnGsAI=\ngithub.com/chzyer/readline v0.0.0-20180603132655-2972be24d48e/go.mod h1:nSuG5e5PlCu98SY8svDHJxuZscDgtXS6KTTbou5AhLI=\ngithub.com/chzyer/test v0.0.0-20180213035817-a1ea475d72b1/go.mod h1:Q3SI9o4m/ZMnBNeIyt5eFwwo7qiLfzFZmjNmxjkiQlU=\ngithub.com/cilium/ebpf v0.4.0/go.mod h1:4tRaxcgiL706VnOzHOdBlY8IEAIdxINsQBcU4xJJXRs=\ngithub.com/cilium/ebpf v0.6.2/go.mod h1:4tRaxcgiL706VnOzHOdBlY8IEAIdxINsQBcU4xJJXRs=\ngithub.com/clbanning/x2j v0.0.0-20191024224557-825249438eec/go.mod h1:jMjuTZXRI4dUb/I5gc9Hdhagfvm9+RyrPryS/auMzxE=\ngithub.com/client9/misspell v0.3.4/go.mod h1:qj6jICC3Q7zFZvVWo7KLAzC3yx5G7kyvSDkc90ppPyw=\ngithub.com/clusterhq/flocker-go v0.0.0-20160920122132-2b8b7259d313/go.mod h1:P1wt9Z3DP8O6W3rvwCt0REIlshg1InHImaLW0t3ObY0=\ngithub.com/cockroachdb/datadriven v0.0.0-20190809214429-80d97fb3cbaa/go.mod h1:zn76sxSg3SzpJ0PPJaLDCu+Bu0Lg3sKTORVIj19EIF8=\ngithub.com/cockroachdb/datadriven v0.0.0-20200714090401-bf6692d28da5/go.mod h1:h6jFvWxBdQXxjopDMZyH2UVceIRfR84bdzbkoKrsWNo=\ngithub.com/cockroachdb/errors v1.2.4/go.mod h1:rQD95gz6FARkaKkQXUksEje/d9a6wBJoCr5oaCLELYA=\ngithub.com/cockroachdb/logtags v0.0.0-20190617123548-eb05cc24525f/go.mod h1:i/u985jwjWRlyHXQbwatDASoW0RMlZ/3i9yJHE2xLkI=\ngithub.com/codahale/hdrhistogram v0.0.0-20161010025455-3a0bb77429bd/go.mod h1:sE/e/2PUdi/liOCUjSTXgM1o87ZssimdTWN964YiIeI=\ngithub.com/codegangsta/inject v0.0.0-20150114235600-33e0aa1cb7c0/go.mod h1:4Zcjuz89kmFXt9morQgcfYZAYZ5n8WHjt81YYWIwtTM=\ngithub.com/codeskyblue/go-sh v0.0.0-20190412065543-76bd3d59ff27/go.mod h1:VQx0hjo2oUeQkQUET7wRwradO6f+fN5jzXgB/zROxxE=\ngithub.com/container-storage-interface/spec v1.5.0/go.mod h1:8K96oQNkJ7pFcC2R9Z1ynGGBB1I93kcS6PGg3SsOk8s=\ngithub.com/containerd/cgroups v1.0.1/go.mod h1:0SJrPIenamHDcZhEcJMNBB85rHcUsw4f25ZfBiPYRkU=\ngithub.com/containerd/console v1.0.1/go.mod h1:XUsP6YE/mKtz6bxc+I8UiKKTP04qjQL4qcS3XoQ5xkw=\ngithub.com/containerd/console v1.0.2/go.mod h1:ytZPjGgY2oeTkAONYafi2kSj0aYggsf8acV1PGKCbzQ=\ngithub.com/containerd/containerd v1.4.9/go.mod h1:bC6axHOhabU15QhwfG7w5PipXdVtMXFTttgp+kVtyUA=\ngithub.com/containerd/containerd v1.4.11/go.mod h1:bC6axHOhabU15QhwfG7w5PipXdVtMXFTttgp+kVtyUA=\ngithub.com/containerd/continuity v0.1.0/go.mod h1:ICJu0PwR54nI0yPEnJ6jcS+J7CZAUXrLh8lPo2knzsM=\ngithub.com/containerd/fifo v1.0.0/go.mod h1:ocF/ME1SX5b1AOlWi9r677YJmCPSwwWnQ9O123vzpE4=\ngithub.com/containerd/go-runc v1.0.0/go.mod h1:cNU0ZbCgCQVZK4lgG3P+9tn9/PaJNmoDXPpoJhDR+Ok=\ngithub.com/containerd/ttrpc v1.0.2/go.mod h1:UAxOpgT9ziI0gJrmKvgcZivgxOp8iFPSk8httJEt98Y=\ngithub.com/containerd/typeurl v1.0.2/go.mod h1:9trJWW2sRlGub4wZJRTW83VtbOLS6hwcDZXTn6oPz9s=\ngithub.com/containernetworking/cni v0.8.1/go.mod h1:LGwApLUm2FpoOfxTDEeq8T9ipbpZ61X79hmU3w8FmsY=\ngithub.com/coredns/caddy v1.1.0/go.mod h1:A6ntJQlAWuQfFlsd9hvigKbo2WS0VUs2l1e2F+BawD4=\ngithub.com/coredns/corefile-migration v1.0.14/go.mod h1:XnhgULOEouimnzgn0t4WPuFDN2/PJQcTxdWKC5eXNGE=\ngithub.com/coreos/bbolt v1.3.2/go.mod h1:iRUV2dpdMOn7Bo10OQBFzIJO9kkE559Wcmn+qkEiiKk=\ngithub.com/coreos/etcd v3.3.10+incompatible/go.mod h1:uF7uidLiAD3TWHmW31ZFd/JWoc32PjwdhPthX9715RE=\ngithub.com/coreos/etcd v3.3.13+incompatible/go.mod h1:uF7uidLiAD3TWHmW31ZFd/JWoc32PjwdhPthX9715RE=\ngithub.com/coreos/go-oidc v2.1.0+incompatible h1:sdJrfw8akMnCuUlaZU3tE/uYXFgfqom8DBE9so9EBsM=\ngithub.com/coreos/go-oidc v2.1.0+incompatible/go.mod h1:CgnwVTmzoESiwO9qyAFEMiHoZ1nMCKZlZ9V6mm3/LKc=\ngithub.com/coreos/go-semver v0.2.0/go.mod h1:nnelYz7RCh+5ahJtPPxZlU+153eP4D4r3EedlOD2RNk=\ngithub.com/coreos/go-semver v0.3.0/go.mod h1:nnelYz7RCh+5ahJtPPxZlU+153eP4D4r3EedlOD2RNk=\ngithub.com/coreos/go-systemd v0.0.0-20180511133405-39ca1b05acc7/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=\ngithub.com/coreos/go-systemd v0.0.0-20190321100706-95778dfbb74e/go.mod h1:F5haX7vjVVG0kc13fIWeqUViNPyEJxv/OmvnBo0Yme4=\ngithub.com/coreos/go-systemd/v22 v22.1.0/go.mod h1:xO0FLkIi5MaZafQlIrOotqXZ90ih+1atmu1JpKERPPk=\ngithub.com/coreos/go-systemd/v22 v22.3.2/go.mod h1:Y58oyj3AT4RCenI/lSvhwexgC+NSVTIJ3seZv2GcEnc=\ngithub.com/coreos/pkg v0.0.0-20160727233714-3ac0863d7acf/go.mod h1:E3G3o1h8I7cfcXa63jLwjI0eiQQMgzzUDFVpN/nH/eA=\ngithub.com/coreos/pkg v0.0.0-20180928190104-399ea9e2e55f/go.mod h1:E3G3o1h8I7cfcXa63jLwjI0eiQQMgzzUDFVpN/nH/eA=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.0-20190314233015-f79a8a8ca69d/go.mod h1:maD7wRr/U5Z6m/iR4s+kqSMx2CaBsrgA7czyZG/E6dU=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.0 h1:EoUDS0afbrsXAZ9YQ9jdu/mZ2sXgT1/2yyNng4PGlyM=\ngithub.com/cpuguy83/go-md2man/v2 v2.0.0/go.mod h1:maD7wRr/U5Z6m/iR4s+kqSMx2CaBsrgA7czyZG/E6dU=\ngithub.com/creack/pty v1.1.7/go.mod h1:lj5s0c3V2DBrqTV7llrYr5NG6My20zk30Fl46Y7DoTY=\ngithub.com/creack/pty v1.1.9/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/creack/pty v1.1.11 h1:07n33Z8lZxZ2qwegKbObQohDhXDQxiMMz1NOUGYlesw=\ngithub.com/creack/pty v1.1.11/go.mod h1:oKZEueFk5CKHvIhNR5MUki03XCEU+Q6VDXinZuGJ33E=\ngithub.com/cyphar/filepath-securejoin v0.2.2/go.mod h1:FpkQEhXnPnOthhzymB7CGsFk2G9VLXONKD9G7QGMM+4=\ngithub.com/davecgh/go-spew v0.0.0-20161028175848-04cdfd42973b/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=\ngithub.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=\ngithub.com/daviddengcn/go-colortext v0.0.0-20160507010035-511bcaf42ccd/go.mod h1:dv4zxwHi5C/8AeI+4gX4dCWOIvNi7I6JCSX0HvlKPgE=\ngithub.com/deckarep/golang-set v1.7.1/go.mod h1:93vsz/8Wt4joVM7c2AVqh+YRMiUSc14yDtF28KmMOgQ=\ngithub.com/dgrijalva/jwt-go v3.2.0+incompatible/go.mod h1:E3ru+11k8xSBh+hMPgOLZmtrrCbhqsmaPHjLKYnJCaQ=\ngithub.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f h1:lO4WD4F/rVNCu3HqELle0jiPLLBs70cWOduZpkS1E78=\ngithub.com/dgryski/go-rendezvous v0.0.0-20200823014737-9f7001d12a5f/go.mod h1:cuUVRXasLTGF7a8hSLbxyZXjz+1KgoB3wDUb6vlszIc=\ngithub.com/dgryski/go-sip13 v0.0.0-20181026042036-e10d5fee7954/go.mod h1:vAd38F8PWV+bWy6jNmig1y/TA+kYO4g3RSRF0IAv0no=\ngithub.com/dnaeon/go-vcr v1.0.1/go.mod h1:aBB1+wY4s93YsC3HHjMBMrwTj2R9FHDzUr9KyGc8n1E=\ngithub.com/docker/distribution v2.7.1+incompatible h1:a5mlkVzth6W5A4fOsS3D2EO5BUmsJpcB+cRlLU7cSug=\ngithub.com/docker/distribution v2.7.1+incompatible/go.mod h1:J2gT2udsDAN96Uj4KfcMRqY0/ypR+oyYUYmja8H+y+w=\ngithub.com/docker/docker v20.10.7+incompatible/go.mod h1:eEKB0N0r5NX/I1kEveEz05bcu8tLC/8azJZsviup8Sk=\ngithub.com/docker/go-connections v0.4.0/go.mod h1:Gbd7IOopHjR8Iph03tsViu4nIes5XhDvyHbTtUxmeec=\ngithub.com/docker/go-units v0.3.3/go.mod h1:fgPhTUdO+D/Jk86RDLlptpiXQzgHJF7gydDDbaIK4Dk=\ngithub.com/docker/go-units v0.4.0/go.mod h1:fgPhTUdO+D/Jk86RDLlptpiXQzgHJF7gydDDbaIK4Dk=\ngithub.com/docopt/docopt-go v0.0.0-20180111231733-ee0de3bc6815/go.mod h1:WwZ+bS3ebgob9U8Nd0kOddGdZWjyMGR8Wziv+TBNwSE=\ngithub.com/dustin/go-humanize v0.0.0-20171111073723-bb3d318650d4/go.mod h1:HtrtbFcZ19U5GC7JDqmcUSB87Iq5E25KnS6fMYU6eOk=\ngithub.com/dustin/go-humanize v1.0.0 h1:VSnTsYCnlFHaM2/igO1h6X3HA71jcobQuxemgkq4zYo=\ngithub.com/dustin/go-humanize v1.0.0/go.mod h1:HtrtbFcZ19U5GC7JDqmcUSB87Iq5E25KnS6fMYU6eOk=\ngithub.com/eapache/go-resiliency v1.1.0/go.mod h1:kFI+JgMyC7bLPUVY133qvEBtVayf5mFgVsvEsIPBvNs=\ngithub.com/eapache/go-xerial-snappy v0.0.0-20180814174437-776d5712da21/go.mod h1:+020luEh2TKB4/GOp8oxxtq0Daoen/Cii55CzbTV6DU=\ngithub.com/eapache/queue v1.1.0/go.mod h1:6eCeP0CKFpHLu8blIFXhExK/dRa7WDZfr6jVFPTqq+I=\ngithub.com/edsrzf/mmap-go v1.0.0/go.mod h1:YO35OhQPt3KJa3ryjFM5Bs14WD66h8eGKpfaBNrHW5M=\ngithub.com/elazarl/goproxy v0.0.0-20180725130230-947c36da3153 h1:yUdfgN0XgIJw7foRItutHYUIhlcKzcSf5vDpdhQAKTc=\ngithub.com/elazarl/goproxy v0.0.0-20180725130230-947c36da3153/go.mod h1:/Zj4wYkgs4iZTTu3o/KG3Itv/qCCa8VVMlb3i9OVuzc=\ngithub.com/emicklei/go-restful v0.0.0-20170410110728-ff4f55a20633/go.mod h1:otzb+WCGbkyDHkqmQmT5YD2WR4BBwUdeQoFo8l/7tVs=\ngithub.com/emicklei/go-restful v2.9.5+incompatible h1:spTtZBk5DYEvbxMVutUuTyh1Ao2r4iyvLdACqsl/Ljk=\ngithub.com/emicklei/go-restful v2.9.5+incompatible/go.mod h1:otzb+WCGbkyDHkqmQmT5YD2WR4BBwUdeQoFo8l/7tVs=\ngithub.com/emirpasic/gods v1.12.0 h1:QAUIPSaCu4G+POclxeqb3F+WPpdKqFGlw36+yOzGlrg=\ngithub.com/emirpasic/gods v1.12.0/go.mod h1:YfzfFFoVP/catgzJb4IKIqXjX78Ha8FMSDh3ymbK86o=\ngithub.com/euank/go-kmsg-parser v2.0.0+incompatible/go.mod h1:MhmAMZ8V4CYH4ybgdRwPr2TU5ThnS43puaKEMpja1uw=\ngithub.com/evanphx/json-patch v0.5.2/go.mod h1:ZWS5hhDbVDyob71nXKNL0+PWn6ToqBHMikGIFbs31qQ=\ngithub.com/evanphx/json-patch v4.11.0+incompatible/go.mod h1:50XU6AFN0ol/bzJsmQLiYLvXMP4fmwYFNcr97nuDLSk=\ngithub.com/evanphx/json-patch v4.12.0+incompatible h1:4onqiflcdA9EOZ4RxV643DvftH5pOlLGNtQ5lPWQu84=\ngithub.com/evanphx/json-patch v4.12.0+incompatible/go.mod h1:50XU6AFN0ol/bzJsmQLiYLvXMP4fmwYFNcr97nuDLSk=\ngithub.com/exponent-io/jsonpath v0.0.0-20151013193312-d6023ce2651d h1:105gxyaGwCFad8crR9dcMQWvV9Hvulu6hwUh4tWPJnM=\ngithub.com/exponent-io/jsonpath v0.0.0-20151013193312-d6023ce2651d/go.mod h1:ZZMPRZwes7CROmyNKgQzC3XPs6L/G2EJLHddWejkmf4=\ngithub.com/facebookgo/ensure v0.0.0-20160127193407-b4ab57deab51/go.mod h1:Yg+htXGokKKdzcwhuNDwVvN+uBxDGXJ7G/VN1d8fa64=\ngithub.com/facebookgo/stack v0.0.0-20160209184415-751773369052/go.mod h1:UbMTZqLaRiH3MsBH8va0n7s1pQYcu3uTb8G4tygF4Zg=\ngithub.com/facebookgo/subset v0.0.0-20150612182917-8dac2c3c4870/go.mod h1:5tD+neXqOorC30/tWg0LCSkrqj/AR6gu8yY8/fpw1q0=\ngithub.com/fatih/camelcase v1.0.0 h1:hxNvNX/xYBp0ovncs8WyWZrOrpBNub/JfaMvbURyft8=\ngithub.com/fatih/camelcase v1.0.0/go.mod h1:yN2Sb0lFhZJUdVvtELVWefmrXpuZESvPmqwoZc+/fpc=\ngithub.com/fatih/color v1.7.0/go.mod h1:Zm6kSWBoL9eyXnKyktHP6abPY2pDugNf5KwzbycvMj4=\ngithub.com/fatih/color v1.10.0/go.mod h1:ELkj/draVOlAH/xkhN6mQ50Qd0MPOk5AAr3maGEBuJM=\ngithub.com/felixge/httpsnoop v1.0.1 h1:lvB5Jl89CsZtGIWuTcDM1E/vkVs49/Ml7JJe07l8SPQ=\ngithub.com/felixge/httpsnoop v1.0.1/go.mod h1:m8KPJKqk1gH5J9DgRY2ASl2lWCfGKXixSwevea8zH2U=\ngithub.com/flosch/pongo2 v0.0.0-20181225140029-79872a7b2769/go.mod h1:tbAXHifHQWNSpWbiJHpJTZH5fi3XHhDMdP//vuz9WS4=\ngithub.com/flynn/go-shlex v0.0.0-20150515145356-3f9db97f8568/go.mod h1:xEzjJPgXI435gkrCt3MPfRiAkVrwSbHsst4LCFVfpJc=\ngithub.com/fogleman/gg v1.2.1-0.20190220221249-0403632d5b90/go.mod h1:R/bRT+9gY/C5z7JzPU0zXsXHKM4/ayA+zqcVNZzPa1k=\ngithub.com/form3tech-oss/jwt-go v3.2.2+incompatible/go.mod h1:pbq4aXjuKjdthFRnoDwaVPLA+WlJuPGy+QneDUgJi2k=\ngithub.com/form3tech-oss/jwt-go v3.2.3+incompatible h1:7ZaBxOI7TMoYBfyA3cQHErNNyAWIKUMIwqxEtgHOs5c=\ngithub.com/form3tech-oss/jwt-go v3.2.3+incompatible/go.mod h1:pbq4aXjuKjdthFRnoDwaVPLA+WlJuPGy+QneDUgJi2k=\ngithub.com/franela/goblin v0.0.0-20200105215937-c9ffbefa60db/go.mod h1:7dvUGVsVBjqR7JHJk0brhHOZYGmfBYOrK0ZhYMEtBr4=\ngithub.com/franela/goreq v0.0.0-20171204163338-bcd34c9993f8/go.mod h1:ZhphrRTfi2rbfLwlschooIH4+wKKDR4Pdxhh+TRoA20=\ngithub.com/frankban/quicktest v1.11.3/go.mod h1:wRf/ReqHper53s+kmmSZizM8NamnL3IM0I9ntUbOk+k=\ngithub.com/fsnotify/fsnotify v1.4.7/go.mod h1:jwhsz4b93w/PPRr/qN1Yymfu8t87LnFCMoQvtojpjFo=\ngithub.com/fsnotify/fsnotify v1.4.9/go.mod h1:znqG4EE+3YCdAaPaxE2ZRY/06pZUdp0tY4IgpuI1SZQ=\ngithub.com/fsnotify/fsnotify v1.5.1 h1:mZcQUHVQUQWoPXXtuf9yuEXKudkV2sx1E06UadKWpgI=\ngithub.com/fsnotify/fsnotify v1.5.1/go.mod h1:T3375wBYaZdLLcVNkcVbzGHY7f1l/uK5T5Ai1i3InKU=\ngithub.com/fvbommel/sortorder v1.0.1 h1:dSnXLt4mJYH25uDDGa3biZNQsozaUWDSWeKJ0qqFfzE=\ngithub.com/fvbommel/sortorder v1.0.1/go.mod h1:uk88iVf1ovNn1iLfgUVU2F9o5eO30ui720w+kxuqRs0=\ngithub.com/gdamore/encoding v1.0.0/go.mod h1:alR0ol34c49FCSBLjhosxzcPHQbf2trDkoo5dl+VrEg=\ngithub.com/gdamore/tcell v1.3.0/go.mod h1:Hjvr+Ofd+gLglo7RYKxxnzCBmev3BzsS67MebKS4zMM=\ngithub.com/getkin/kin-openapi v0.76.0/go.mod h1:660oXbgy5JFMKreazJaQTw7o+X00qeSyhcnluiMv+Xg=\ngithub.com/getsentry/raven-go v0.2.0/go.mod h1:KungGk8q33+aIAZUIVWZDr2OfAEBsO49PX4NzFV5kcQ=\ngithub.com/ghodss/yaml v1.0.0 h1:wQHKEahhL6wmXdzwWG11gIVCkOv05bNOh+Rxn0yngAk=\ngithub.com/ghodss/yaml v1.0.0/go.mod h1:4dBDuWmgqj2HViK6kFavaiC9ZROes6MMH2rRYeMEF04=\ngithub.com/gin-contrib/sse v0.1.0/go.mod h1:RHrZQHXnP2xjPF+u1gW/2HnVO7nvIa9PG3Gm+fLHvGI=\ngithub.com/gin-gonic/gin v1.5.0/go.mod h1:Nd6IXA8m5kNZdNEHMBd93KT+mdY3+bewLgRvmCsR2Do=\ngithub.com/gliderlabs/ssh v0.2.2 h1:6zsha5zo/TWhRhwqCD3+EarCAgZ2yN28ipRnGPnwkI0=\ngithub.com/gliderlabs/ssh v0.2.2/go.mod h1:U7qILu1NlMHj9FlMhZLlkCdDnU1DBEAqr0aevW3Awn0=\ngithub.com/globalsign/mgo v0.0.0-20180905125535-1ca0a4f7cbcb/go.mod h1:xkRDCp4j0OGD1HRkm4kmhM+pmpv3AKq5SU7GMg4oO/Q=\ngithub.com/globalsign/mgo v0.0.0-20181015135952-eeefdecb41b8/go.mod h1:xkRDCp4j0OGD1HRkm4kmhM+pmpv3AKq5SU7GMg4oO/Q=\ngithub.com/go-check/check v0.0.0-20180628173108-788fd7840127/go.mod h1:9ES+weclKsC9YodN5RgxqK/VD9HM9JsCSh7rNhMZE98=\ngithub.com/go-errors/errors v1.0.1 h1:LUHzmkK3GUKUrL/1gfBUxAHzcev3apQlezX/+O7ma6w=\ngithub.com/go-errors/errors v1.0.1/go.mod h1:f4zRHt4oKfwPJE5k8C9vpYG+aDHdBFUsgrm6/TyX73Q=\ngithub.com/go-git/gcfg v1.5.0 h1:Q5ViNfGF8zFgyJWPqYwA7qGFoMTEiBmdlkcfRmpIMa4=\ngithub.com/go-git/gcfg v1.5.0/go.mod h1:5m20vg6GwYabIxaOonVkTdrILxQMpEShl1xiMF4ua+E=\ngithub.com/go-git/go-billy/v5 v5.2.0/go.mod h1:pmpqyWchKfYfrkb/UVH4otLvyi/5gJlGI4Hb3ZqZ3W0=\ngithub.com/go-git/go-billy/v5 v5.3.1 h1:CPiOUAzKtMRvolEKw+bG1PLRpT7D3LIs3/3ey4Aiu34=\ngithub.com/go-git/go-billy/v5 v5.3.1/go.mod h1:pmpqyWchKfYfrkb/UVH4otLvyi/5gJlGI4Hb3ZqZ3W0=\ngithub.com/go-git/go-git-fixtures/v4 v4.2.1 h1:n9gGL1Ct/yIw+nfsfr8s4+sbhT+Ncu2SubfXjIWgci8=\ngithub.com/go-git/go-git-fixtures/v4 v4.2.1/go.mod h1:K8zd3kDUAykwTdDCr+I0per6Y6vMiRR/nnVTBtavnB0=\ngithub.com/go-git/go-git/v5 v5.4.2 h1:BXyZu9t0VkbiHtqrsvdq39UDhGJTl1h55VW6CSC4aY4=\ngithub.com/go-git/go-git/v5 v5.4.2/go.mod h1:gQ1kArt6d+n+BGd+/B/I74HwRTLhth2+zti4ihgckDc=\ngithub.com/go-gl/glfw v0.0.0-20190409004039-e6da0acd62b1/go.mod h1:vR7hzQXu2zJy9AVAgeJqvqgH9Q5CA+iKCZ2gyEVpxRU=\ngithub.com/go-gl/glfw/v3.3/glfw v0.0.0-20191125211704-12ad95a8df72/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=\ngithub.com/go-gl/glfw/v3.3/glfw v0.0.0-20200222043503-6f7a984d4dc4/go.mod h1:tQ2UAYgL5IevRw8kRxooKSPJfGvJ9fJQFa0TUsXzTg8=\ngithub.com/go-kit/kit v0.8.0/go.mod h1:xBxKIO96dXMWWy0MnWVtmwkA9/13aqxPnvrjFYMA2as=\ngithub.com/go-kit/kit v0.9.0/go.mod h1:xBxKIO96dXMWWy0MnWVtmwkA9/13aqxPnvrjFYMA2as=\ngithub.com/go-kit/kit v0.10.0/go.mod h1:xUsJbQ/Fp4kEt7AFgCuvyX4a71u8h9jB8tj/ORgOZ7o=\ngithub.com/go-kit/log v0.1.0/go.mod h1:zbhenjAZHb184qTLMA9ZjW7ThYL0H2mk7Q6pNt4vbaY=\ngithub.com/go-logfmt/logfmt v0.3.0/go.mod h1:Qt1PoO58o5twSAckw1HlFXLmHsOX5/0LbT9GBnD5lWE=\ngithub.com/go-logfmt/logfmt v0.4.0/go.mod h1:3RMwSq7FuexP4Kalkev3ejPJsZTpXXBr9+V4qmtdjCk=\ngithub.com/go-logfmt/logfmt v0.5.0/go.mod h1:wCYkCAKZfumFQihp8CzCvQ3paCTfi41vtzG1KdI/P7A=\ngithub.com/go-logr/logr v0.1.0/go.mod h1:ixOQHD9gLJUVQQ2ZOR7zLEifBX6tGkNJF4QyIY7sIas=\ngithub.com/go-logr/logr v0.2.0/go.mod h1:z6/tIYblkpsD+a4lm/fGIIU9mZ+XfAiaFtq7xTgseGU=\ngithub.com/go-logr/logr v0.3.0/go.mod h1:z6/tIYblkpsD+a4lm/fGIIU9mZ+XfAiaFtq7xTgseGU=\ngithub.com/go-logr/logr v0.4.0/go.mod h1:z6/tIYblkpsD+a4lm/fGIIU9mZ+XfAiaFtq7xTgseGU=\ngithub.com/go-logr/logr v1.0.0/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=\ngithub.com/go-logr/logr v1.2.0/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=\ngithub.com/go-logr/logr v1.2.2 h1:ahHml/yUpnlb96Rp8HCvtYVPY8ZYpxq3g7UYchIYwbs=\ngithub.com/go-logr/logr v1.2.2/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=\ngithub.com/go-logr/zapr v1.2.0 h1:n4JnPI1T3Qq1SFEi/F8rwLrZERp2bso19PJZDB9dayk=\ngithub.com/go-logr/zapr v1.2.0/go.mod h1:Qa4Bsj2Vb+FAVeAKsLD8RLQ+YRJB8YDmOAKxaBQf7Ro=\ngithub.com/go-openapi/analysis v0.0.0-20180825180245-b006789cd277/go.mod h1:k70tL6pCuVxPJOHXQ+wIac1FUrvNkHolPie/cLEU6hI=\ngithub.com/go-openapi/analysis v0.17.0/go.mod h1:IowGgpVeD0vNm45So8nr+IcQ3pxVtpRoBWb8PVZO0ik=\ngithub.com/go-openapi/analysis v0.18.0/go.mod h1:IowGgpVeD0vNm45So8nr+IcQ3pxVtpRoBWb8PVZO0ik=\ngithub.com/go-openapi/analysis v0.19.2/go.mod h1:3P1osvZa9jKjb8ed2TPng3f0i/UY9snX6gxi44djMjk=\ngithub.com/go-openapi/analysis v0.19.5 h1:8b2ZgKfKIUTVQpTb77MoRDIMEIwvDVw40o3aOXdfYzI=\ngithub.com/go-openapi/analysis v0.19.5/go.mod h1:hkEAkxagaIvIP7VTn8ygJNkd4kAYON2rCu0v0ObL0AU=\ngithub.com/go-openapi/errors v0.17.0/go.mod h1:LcZQpmvG4wyF5j4IhA73wkLFQg+QJXOQHVjmcZxhka0=\ngithub.com/go-openapi/errors v0.18.0/go.mod h1:LcZQpmvG4wyF5j4IhA73wkLFQg+QJXOQHVjmcZxhka0=\ngithub.com/go-openapi/errors v0.19.2 h1:a2kIyV3w+OS3S97zxUndRVD46+FhGOUBDFY7nmu4CsY=\ngithub.com/go-openapi/errors v0.19.2/go.mod h1:qX0BLWsyaKfvhluLejVpVNwNRdXZhEbTA4kxxpKBC94=\ngithub.com/go-openapi/jsonpointer v0.17.0/go.mod h1:cOnomiV+CVVwFLk0A/MExoFMjwdsUdVpsRhURCKh+3M=\ngithub.com/go-openapi/jsonpointer v0.18.0/go.mod h1:cOnomiV+CVVwFLk0A/MExoFMjwdsUdVpsRhURCKh+3M=\ngithub.com/go-openapi/jsonpointer v0.19.2/go.mod h1:3akKfEdA7DF1sugOqz1dVQHBcuDBPKZGEoHC/NkiQRg=\ngithub.com/go-openapi/jsonpointer v0.19.3/go.mod h1:Pl9vOtqEWErmShwVjC8pYs9cog34VGT37dQOVbmoatg=\ngithub.com/go-openapi/jsonpointer v0.19.5 h1:gZr+CIYByUqjcgeLXnQu2gHYQC9o73G2XUeOFYEICuY=\ngithub.com/go-openapi/jsonpointer v0.19.5/go.mod h1:Pl9vOtqEWErmShwVjC8pYs9cog34VGT37dQOVbmoatg=\ngithub.com/go-openapi/jsonreference v0.17.0/go.mod h1:g4xxGn04lDIRh0GJb5QlpE3HfopLOL6uZrK/VgnsK9I=\ngithub.com/go-openapi/jsonreference v0.18.0/go.mod h1:g4xxGn04lDIRh0GJb5QlpE3HfopLOL6uZrK/VgnsK9I=\ngithub.com/go-openapi/jsonreference v0.19.2/go.mod h1:jMjeRr2HHw6nAVajTXJ4eiUwohSTlpa0o73RUL1owJc=\ngithub.com/go-openapi/jsonreference v0.19.3/go.mod h1:rjx6GuL8TTa9VaixXglHmQmIL98+wF9xc8zWvFonSJ8=\ngithub.com/go-openapi/jsonreference v0.19.5 h1:1WJP/wi4OjB4iV8KVbH73rQaoialJrqv8gitZLxGLtM=\ngithub.com/go-openapi/jsonreference v0.19.5/go.mod h1:RdybgQwPxbL4UEjuAruzK1x3nE69AqPYEJeo/TWfEeg=\ngithub.com/go-openapi/loads v0.17.0/go.mod h1:72tmFy5wsWx89uEVddd0RjRWPZm92WRLhf7AC+0+OOU=\ngithub.com/go-openapi/loads v0.18.0/go.mod h1:72tmFy5wsWx89uEVddd0RjRWPZm92WRLhf7AC+0+OOU=\ngithub.com/go-openapi/loads v0.19.0/go.mod h1:72tmFy5wsWx89uEVddd0RjRWPZm92WRLhf7AC+0+OOU=\ngithub.com/go-openapi/loads v0.19.2/go.mod h1:QAskZPMX5V0C2gvfkGZzJlINuP7Hx/4+ix5jWFxsNPs=\ngithub.com/go-openapi/loads v0.19.4 h1:5I4CCSqoWzT+82bBkNIvmLc0UOsoKKQ4Fz+3VxOB7SY=\ngithub.com/go-openapi/loads v0.19.4/go.mod h1:zZVHonKd8DXyxyw4yfnVjPzBjIQcLt0CCsn0N0ZrQsk=\ngithub.com/go-openapi/runtime v0.0.0-20180920151709-4f900dc2ade9/go.mod h1:6v9a6LTXWQCdL8k1AO3cvqx5OtZY/Y9wKTgaoP6YRfA=\ngithub.com/go-openapi/runtime v0.19.0/go.mod h1:OwNfisksmmaZse4+gpV3Ne9AyMOlP1lt4sK4FXt0O64=\ngithub.com/go-openapi/runtime v0.19.4 h1:csnOgcgAiuGoM/Po7PEpKDoNulCcF3FGbSnbHfxgjMI=\ngithub.com/go-openapi/runtime v0.19.4/go.mod h1:X277bwSUBxVlCYR3r7xgZZGKVvBd/29gLDlFGtJ8NL4=\ngithub.com/go-openapi/spec v0.17.0/go.mod h1:XkF/MOi14NmjsfZ8VtAKf8pIlbZzyoTvZsdfssdxcBI=\ngithub.com/go-openapi/spec v0.18.0/go.mod h1:XkF/MOi14NmjsfZ8VtAKf8pIlbZzyoTvZsdfssdxcBI=\ngithub.com/go-openapi/spec v0.19.2/go.mod h1:sCxk3jxKgioEJikev4fgkNmwS+3kuYdJtcsZsD5zxMY=\ngithub.com/go-openapi/spec v0.19.3/go.mod h1:FpwSN1ksY1eteniUU7X0N/BgJ7a4WvBFVA8Lj9mJglo=\ngithub.com/go-openapi/spec v0.19.5 h1:Xm0Ao53uqnk9QE/LlYV5DEU09UAgpliA85QoT9LzqPw=\ngithub.com/go-openapi/spec v0.19.5/go.mod h1:Hm2Jr4jv8G1ciIAo+frC/Ft+rR2kQDh8JHKHb3gWUSk=\ngithub.com/go-openapi/strfmt v0.17.0/go.mod h1:P82hnJI0CXkErkXi8IKjPbNBM6lV6+5pLP5l494TcyU=\ngithub.com/go-openapi/strfmt v0.18.0/go.mod h1:P82hnJI0CXkErkXi8IKjPbNBM6lV6+5pLP5l494TcyU=\ngithub.com/go-openapi/strfmt v0.19.0/go.mod h1:+uW+93UVvGGq2qGaZxdDeJqSAqBqBdl+ZPMF/cC8nDY=\ngithub.com/go-openapi/strfmt v0.19.3 h1:eRfyY5SkaNJCAwmmMcADjY31ow9+N7MCLW7oRkbsINA=\ngithub.com/go-openapi/strfmt v0.19.3/go.mod h1:0yX7dbo8mKIvc3XSKp7MNfxw4JytCfCD6+bY1AVL9LU=\ngithub.com/go-openapi/swag v0.17.0/go.mod h1:AByQ+nYG6gQg71GINrmuDXCPWdL640yX49/kXLo40Tg=\ngithub.com/go-openapi/swag v0.18.0/go.mod h1:AByQ+nYG6gQg71GINrmuDXCPWdL640yX49/kXLo40Tg=\ngithub.com/go-openapi/swag v0.19.2/go.mod h1:POnQmlKehdgb5mhVOsnJFsivZCEZ/vjK9gh66Z9tfKk=\ngithub.com/go-openapi/swag v0.19.5/go.mod h1:POnQmlKehdgb5mhVOsnJFsivZCEZ/vjK9gh66Z9tfKk=\ngithub.com/go-openapi/swag v0.19.14 h1:gm3vOOXfiuw5i9p5N9xJvfjvuofpyvLA9Wr6QfK5Fng=\ngithub.com/go-openapi/swag v0.19.14/go.mod h1:QYRuS/SOXUCsnplDa677K7+DxSOj6IPNl/eQntq43wQ=\ngithub.com/go-openapi/validate v0.18.0/go.mod h1:Uh4HdOzKt19xGIGm1qHf/ofbX1YQ4Y+MYsct2VUrAJ4=\ngithub.com/go-openapi/validate v0.19.2/go.mod h1:1tRCw7m3jtI8eNWEEliiAqUIcBztB2KDnRCRMUi7GTA=\ngithub.com/go-openapi/validate v0.19.5 h1:QhCBKRYqZR+SKo4gl1lPhPahope8/RLt6EVgY8X80w0=\ngithub.com/go-openapi/validate v0.19.5/go.mod h1:8DJv2CVJQ6kGNpFW6eV9N3JviE1C85nY1c2z52x1Gk4=\ngithub.com/go-ozzo/ozzo-validation v3.5.0+incompatible/go.mod h1:gsEKFIVnabGBt6mXmxK0MoFy+cZoTJY6mu5Ll3LVLBU=\ngithub.com/go-playground/locales v0.12.1/go.mod h1:IUMDtCfWo/w/mtMfIE/IG2K+Ey3ygWanZIBtBW0W2TM=\ngithub.com/go-playground/universal-translator v0.16.0/go.mod h1:1AnU7NaIRDWWzGEKwgtJRd2xk99HeFyHw3yid4rvQIY=\ngithub.com/go-redis/cache/v8 v8.4.2 h1:8YbsmnU1Ws3TKS6T+qALzYE/MlGE+A/lrlx1XTA3p6M=\ngithub.com/go-redis/cache/v8 v8.4.2/go.mod h1:X7Jjd69Ssbrf3xBQLtIDE0g3WcSbFoQiSGeb8QfEJ+g=\ngithub.com/go-redis/redis/v8 v8.11.3 h1:GCjoYp8c+yQTJfc0n69iwSiHjvuAdruxl7elnZCxgt8=\ngithub.com/go-redis/redis/v8 v8.11.3/go.mod h1:xNJ9xDG09FsIPwh3bWdk+0oDWHbtF9rPN0F/oD9XeKc=\ngithub.com/go-sql-driver/mysql v1.4.0/go.mod h1:zAC/RDZ24gD3HViQzih4MyKcchzm+sOG5ZlKdlhCg5w=\ngithub.com/go-sql-driver/mysql v1.5.0/go.mod h1:DCzpHaOWr8IXmIStZouvnhqoel9Qv2LBy8hT2VhHyBg=\ngithub.com/go-stack/stack v1.8.0 h1:5SgMzNM5HxrEjV0ww2lTmX6E2Izsfxas4+YHWRs3Lsk=\ngithub.com/go-stack/stack v1.8.0/go.mod h1:v0f6uXyyMGvRgIKkXu+yp6POWl0qKG85gN/melR3HDY=\ngithub.com/go-task/slim-sprig v0.0.0-20210107165309-348f09dbbbc0/go.mod h1:fyg7847qk6SyHyPtNmDHnmrv/HOrqktSC+C9fM+CJOE=\ngithub.com/go-telegram-bot-api/telegram-bot-api/v5 v5.4.0 h1:Mr3JcvBjQEhCN9wld6OHKHuHxWaoXTaQfYKmj7QwP18=\ngithub.com/go-telegram-bot-api/telegram-bot-api/v5 v5.4.0/go.mod h1:A2S0CWkNylc2phvKXWBBdD3K0iGnDBGbzRpISP2zBl8=\ngithub.com/go-test/deep v1.0.4 h1:u2CU3YKy9I2pmu9pX0eq50wCgjfGIt539SqR7FbHiho=\ngithub.com/go-test/deep v1.0.4/go.mod h1:wGDj63lr65AM2AQyKZd/NYHGb0R+1RLqB8NKt3aSFNA=\ngithub.com/gobuffalo/envy v1.7.0/go.mod h1:n7DRkBerg/aorDM8kbduw5dN3oXGswK5liaSCx4T5NI=\ngithub.com/gobwas/glob v0.2.3 h1:A4xDbljILXROh+kObIiy5kIaPYD8e96x1tgBhUI5J+Y=\ngithub.com/gobwas/glob v0.2.3/go.mod h1:d3Ez4x06l9bZtSvzIay5+Yzi0fmZzPgnTbPcKjJAkT8=\ngithub.com/godbus/dbus/v5 v5.0.3/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=\ngithub.com/godbus/dbus/v5 v5.0.4/go.mod h1:xhWf0FNVPg57R7Z0UbKHbJfkEywrmjJnf7w5xrFpKfA=\ngithub.com/gofrs/uuid v4.0.0+incompatible/go.mod h1:b2aQJv3Z4Fp6yNu3cdSllBxTCLRxnplIgP/c0N/04lM=\ngithub.com/gogits/go-gogs-client v0.0.0-20190616193657-5a05380e4bc2 h1:BbwX8wsMRDZRdNYxAna+4ls3wvMKJyn4PT6Zk1CPxP4=\ngithub.com/gogits/go-gogs-client v0.0.0-20190616193657-5a05380e4bc2/go.mod h1:cY2AIrMgHm6oOHmR7jY+9TtjzSjQ3iG7tURJG3Y6XH0=\ngithub.com/gogo/protobuf v1.1.1/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=\ngithub.com/gogo/protobuf v1.2.0/go.mod h1:r8qH/GZQm5c6nD/R0oafs1akxWv10x8SbQlK7atdtwQ=\ngithub.com/gogo/protobuf v1.2.1/go.mod h1:hp+jE20tsWTFYpLwKvXlhS1hjn+gTNwPg2I6zVXpSg4=\ngithub.com/gogo/protobuf v1.3.1/go.mod h1:SlYgWuQ5SjCEi6WLHjHCa1yvBfUnHcTbrrZtXPKa29o=\ngithub.com/gogo/protobuf v1.3.2 h1:Ov1cvc58UF3b5XjBnZv7+opcTcQFZebYjWzi34vdm4Q=\ngithub.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69NZV8Q=\ngithub.com/golang-jwt/jwt/v4 v4.0.0/go.mod h1:/xlHOz8bRuivTWchD4jCa+NbatV+wEUSzwAxVc6locg=\ngithub.com/golang-jwt/jwt/v4 v4.2.0 h1:besgBTC8w8HjP6NzQdxwKH9Z5oQMZ24ThTrHp3cZ8eU=\ngithub.com/golang-jwt/jwt/v4 v4.2.0/go.mod h1:/xlHOz8bRuivTWchD4jCa+NbatV+wEUSzwAxVc6locg=\ngithub.com/golang/freetype v0.0.0-20170609003504-e2365dfdc4a0/go.mod h1:E/TSTwGwJL78qG/PmXZO1EjYhfJinVAhrmmHX6Z8B9k=\ngithub.com/golang/glog v0.0.0-20160126235308-23def4e6c14b/go.mod h1:SBH7ygxi8pfUlaOkMMuAQtPIUF8ecWP5IEl/CR7VP2Q=\ngithub.com/golang/glog v1.0.0 h1:nfP3RFugxnNRyKgeWd4oI1nYvXpxrx8ck8ZrcizshdQ=\ngithub.com/golang/glog v1.0.0/go.mod h1:EWib/APOK0SL3dFbYqvxE3UYd8E6s1ouQ7iEp/0LWV4=\ngithub.com/golang/groupcache v0.0.0-20160516000752-02826c3e7903/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/groupcache v0.0.0-20190129154638-5b532d6fd5ef/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/groupcache v0.0.0-20190702054246-869f871628b6/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/groupcache v0.0.0-20191227052852-215e87163ea7/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/groupcache v0.0.0-20200121045136-8c9f03a8e57e/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da h1:oI5xCqsCo564l8iNU+DwB5epxmsaqB+rhGL0m5jtYqE=\ngithub.com/golang/groupcache v0.0.0-20210331224755-41bb18bfe9da/go.mod h1:cIg4eruTrX1D+g88fzRXU5OdNfaM+9IcxsU14FzY7Hc=\ngithub.com/golang/lint v0.0.0-20180702182130-06c8688daad7/go.mod h1:tluoj9z5200jBnyusfRPU2LqT6J+DAorxEvtC7LHB+E=\ngithub.com/golang/mock v1.1.1/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/mock v1.2.0/go.mod h1:oTYuIxOrZwtPieC+H1uAHpcLFnEyAGVDL/k47Jfbm0A=\ngithub.com/golang/mock v1.3.1/go.mod h1:sBzyDLLjw3U8JLTeZvSv8jJB+tU5PVekmnlKIyFUx0Y=\ngithub.com/golang/mock v1.4.0/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=\ngithub.com/golang/mock v1.4.1/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=\ngithub.com/golang/mock v1.4.3/go.mod h1:UOMv5ysSaYNkG+OFQykRIcU/QvvxJf3p21QfJ2Bt3cw=\ngithub.com/golang/mock v1.4.4/go.mod h1:l3mdAwkq5BuhzHwde/uurv3sEJeZMXNpwsxVWU71h+4=\ngithub.com/golang/mock v1.5.0 h1:jlYHihg//f7RRwuPfptm04yp4s7O6Kw8EZiVYIGcH0g=\ngithub.com/golang/mock v1.5.0/go.mod h1:CWnOUgYIOo4TcNZ0wHX3YZCqsaM1I1Jvs6v3mP3KVu8=\ngithub.com/golang/protobuf v1.4.2 h1:+Z5KGCizgyZCbGh1KZqA0fcLLkwbsjIzS4aV2v7wJX0=\ngithub.com/golang/protobuf v1.4.2/go.mod h1:oDoupMAO8OvCJWAcko0GGGIgR6R6ocIYbsSw735rRwI=\ngithub.com/golang/snappy v0.0.0-20180518054509-2e65f85255db/go.mod h1:/XxbfmMg8lxefKM7IXC3fBNl/7bRcc72aCRzEWrmP2Q=\ngithub.com/golangplus/testing v0.0.0-20180327235837-af21d9c3145e/go.mod h1:0AA//k/eakGydO4jKRoRL2j92ZKSzTgj9tclaCrvXHk=\ngithub.com/gomodule/redigo v2.0.0+incompatible h1:K/R+8tc58AaqLkqG2Ol3Qk+DR/TlNuhuh457pBFPtt0=\ngithub.com/gomodule/redigo v2.0.0+incompatible/go.mod h1:B4C85qUVwatsJoIUNIfCRsp7qO0iAmpGFZ4EELWSbC4=\ngithub.com/google/btree v0.0.0-20180813153112-4030bb1f1f0c/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\ngithub.com/google/btree v1.0.0/go.mod h1:lNA+9X1NB3Zf8V7Ke586lFgjr2dZNuvo3lPJSGZ5JPQ=\ngithub.com/google/btree v1.0.1 h1:gK4Kx5IaGY9CD5sPJ36FHiBJ6ZXl0kilRiiCj+jdYp4=\ngithub.com/google/btree v1.0.1/go.mod h1:xXMiIv4Fb/0kKde4SpL7qlzvu5cMJDRkFDxJfI9uaxA=\ngithub.com/google/cadvisor v0.43.0/go.mod h1:+RdMSbc3FVr5NYCD2dOEJy/LI0jYJ/0xJXkzWXEyiFQ=\ngithub.com/google/cel-go v0.9.0/go.mod h1:U7ayypeSkw23szu4GaQTPJGx66c20mx8JklMSxrmI1w=\ngithub.com/google/cel-spec v0.6.0/go.mod h1:Nwjgxy5CbjlPrtCWjeDjUyKMl8w41YBYGjsyDdqk0xA=\ngithub.com/google/go-cmp v0.2.0/go.mod h1:oXzfMopK8JAjlY9xF4vHSVASa0yLyX7SntLO5aqRK0M=\ngithub.com/google/go-cmp v0.3.0/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.3.1/go.mod h1:8QqcDgzrUqlUb/G2PQTWiueGozuR1884gddMywk6iLU=\ngithub.com/google/go-cmp v0.4.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.4.1/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.0/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.1/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.2/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.3/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.4/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.5/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-cmp v0.5.6 h1:BKbKCqvP6I+rmFHt06ZmyQtvB8xAkWdhFyr0ZUNZcxQ=\ngithub.com/google/go-cmp v0.5.6/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=\ngithub.com/google/go-github/v41 v41.0.0 h1:HseJrM2JFf2vfiZJ8anY2hqBjdfY1Vlj/K27ueww4gg=\ngithub.com/google/go-github/v41 v41.0.0/go.mod h1:XgmCA5H323A9rtgExdTcnDkcqp6S30AVACCBDOonIxg=\ngithub.com/google/go-jsonnet v0.18.0 h1:/6pTy6g+Jh1a1I2UMoAODkqELFiVIdOxbNwv0DDzoOg=\ngithub.com/google/go-jsonnet v0.18.0/go.mod h1:C3fTzyVJDslXdiTqw/bTFk7vSGyCtH3MGRbDfvEwGd0=\ngithub.com/google/go-querystring v1.0.0/go.mod h1:odCYkC5MyYFN7vkCjXpyrEuKhc/BUO6wN/zVPAxq5ck=\ngithub.com/google/go-querystring v1.1.0 h1:AnCroh3fv4ZBgVIf1Iwtovgjaw/GiKJo8M8yD/fhyJ8=\ngithub.com/google/go-querystring v1.1.0/go.mod h1:Kcdr2DB4koayq7X8pmAG4sNG59So17icRSOU623lUBU=\ngithub.com/google/gofuzz v1.0.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=\ngithub.com/google/gofuzz v1.1.0 h1:Hsa8mG0dQ46ij8Sl2AYJDUv1oA9/d6Vk+3LG99Oe02g=\ngithub.com/google/gofuzz v1.1.0/go.mod h1:dBl0BpW6vV/+mYPU4Po3pmUjxk6FQPldtuIdl/M65Eg=\ngithub.com/google/martian v2.1.0+incompatible/go.mod h1:9I4somxYTbIHy5NJKHRl3wXiIaQGbYVAs8BPL6v8lEs=\ngithub.com/google/martian/v3 v3.0.0/go.mod h1:y5Zk1BBys9G+gd6Jrk0W3cC1+ELVxBWuIGO+w/tUAp0=\ngithub.com/google/martian/v3 v3.1.0/go.mod h1:y5Zk1BBys9G+gd6Jrk0W3cC1+ELVxBWuIGO+w/tUAp0=\ngithub.com/google/pprof v0.0.0-20181206194817-3ea8567a2e57/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=\ngithub.com/google/pprof v0.0.0-20190515194954-54271f7e092f/go.mod h1:zfwlbNMJ+OItoe0UupaVj+oy1omPYYDuagoSzA8v9mc=\ngithub.com/google/pprof v0.0.0-20191218002539-d4f498aebedc/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/pprof v0.0.0-20200212024743-f11f1df84d12/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/pprof v0.0.0-20200229191704-1ebb73c60ed3/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/pprof v0.0.0-20200430221834-fc25d7d30c6d/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/pprof v0.0.0-20200708004538-1a94d8640e99/go.mod h1:ZgVRPoUq/hfqzAqh7sHMqb3I9Rq5C59dIz2SbBwJ4eM=\ngithub.com/google/pprof v0.0.0-20201023163331-3e6fc7fc9c4c/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=\ngithub.com/google/pprof v0.0.0-20201203190320-1bf35d6f28c2/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=\ngithub.com/google/pprof v0.0.0-20210122040257-d980be63207e/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=\ngithub.com/google/pprof v0.0.0-20210226084205-cbba55b83ad5/go.mod h1:kpwsk12EmLew5upagYY7GY0pfYCcupk39gWOCRROcvE=\ngithub.com/google/renameio v0.1.0/go.mod h1:KWCgfxg9yswjAJkECMjeO8J8rahYeXnNhOm40UhjYkI=\ngithub.com/google/shlex v0.0.0-20191202100458-e7afc7fbc510 h1:El6M4kTTCOh6aBiKaUGG7oYTSPP8MxqL4YI3kZKwcP4=\ngithub.com/google/shlex v0.0.0-20191202100458-e7afc7fbc510/go.mod h1:pupxD2MaaD3pAXIBCelhxNneeOaAeabZDe5s4K6zSpQ=\ngithub.com/google/uuid v1.0.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/google/uuid v1.1.1/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/google/uuid v1.1.2 h1:EVhdT+1Kseyi1/pUmXKaFxYsDNy9RQYkMWRH68J/W7Y=\ngithub.com/google/uuid v1.1.2/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=\ngithub.com/googleapis/gax-go/v2 v2.0.4/go.mod h1:0Wqv26UfaUD9n4G6kQubkQ+KchISgw+vpHVxEJEs9eg=\ngithub.com/googleapis/gax-go/v2 v2.0.5/go.mod h1:DWXyrwAJ9X0FpwwEdw+IPEYBICEFu5mhpdKc/us6bOk=\ngithub.com/googleapis/gnostic v0.5.1/go.mod h1:6U4PtQXGIEt/Z3h5MAT7FNofLnw9vXk2cUuW7uA/OeU=\ngithub.com/googleapis/gnostic v0.5.5 h1:9fHAtK0uDfpveeqqo1hkEZJcFvYXAiCN3UutL8F9xHw=\ngithub.com/googleapis/gnostic v0.5.5/go.mod h1:7+EbHbldMins07ALC74bsA81Ovc97DwqyJO1AENw9kA=\ngithub.com/gopackage/ddp v0.0.0-20170117053602-652027933df4 h1:4EZlYQIiyecYJlUbVkFXCXHz1QPhVXcHnQKAzBTPfQo=\ngithub.com/gopackage/ddp v0.0.0-20170117053602-652027933df4/go.mod h1:lEO7XoHJ/xNRBCxrn4h/CEB67h0kW1B0t4ooP2yrjUA=\ngithub.com/gophercloud/gophercloud v0.1.0/go.mod h1:vxM41WHh5uqHVBMZHzuwNOHh8XEoIEcSTewFxm1c5g8=\ngithub.com/gopherjs/gopherjs v0.0.0-20181017120253-0766667cb4d1/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=\ngithub.com/gopherjs/gopherjs v0.0.0-20200217142428-fce0ec30dd00/go.mod h1:wJfORRmW1u3UXTncJ5qlYoELFm8eSnnEO6hX4iZ3EWY=\ngithub.com/gorilla/context v1.1.1/go.mod h1:kBGZzfjB9CEq2AlWe17Uuf7NDRt0dE0s8S51q0aT7Yg=\ngithub.com/gorilla/handlers v1.5.1 h1:9lRY6j8DEeeBT10CvO9hGW0gmky0BprnvDI5vfhUHH4=\ngithub.com/gorilla/handlers v1.5.1/go.mod h1:t8XrUpc4KVXb7HGyJ4/cEnwQiaxrX/hz1Zv/4g96P1Q=\ngithub.com/gorilla/mux v1.6.2/go.mod h1:1lud6UwP+6orDFRuTfBEV8e9/aOM/c4fVVCaMa2zaAs=\ngithub.com/gorilla/mux v1.7.3/go.mod h1:1lud6UwP+6orDFRuTfBEV8e9/aOM/c4fVVCaMa2zaAs=\ngithub.com/gorilla/mux v1.7.4/go.mod h1:DVbg23sWSpFRCP0SfiEN6jmj59UnW/n46BH5rLB71So=\ngithub.com/gorilla/mux v1.8.0/go.mod h1:DVbg23sWSpFRCP0SfiEN6jmj59UnW/n46BH5rLB71So=\ngithub.com/gorilla/websocket v1.4.2 h1:+/TMaTYc4QFitKJxsQ7Yye35DkWvkdLcvGKqM+x0Ufc=\ngithub.com/gorilla/websocket v1.4.2/go.mod h1:YR8l580nyteQvAITg2hZ9XVh4b55+EU/adAjf1fMHhE=\ngithub.com/gregdel/pushover v1.1.0 h1:dwHyvrcpZCOS9V1fAnKPaGRRI5OC55cVaKhMybqNsKQ=\ngithub.com/gregdel/pushover v1.1.0/go.mod h1:EcaO66Nn1StkpEm1iKtBTV3d2A16SoMsVER1PthX7to=\ngithub.com/gregjones/httpcache v0.0.0-20180305231024-9cad4c3443a7/go.mod h1:FecbI9+v66THATjSRHfNgh1IVFe/9kFxbXtjV0ctIMA=\ngithub.com/gregjones/httpcache v0.0.0-20190611155906-901d90724c79 h1:+ngKgrYPPJrOjhax5N+uePQ0Fh1Z7PheYoUI/0nzkPA=\ngithub.com/gregjones/httpcache v0.0.0-20190611155906-901d90724c79/go.mod h1:FecbI9+v66THATjSRHfNgh1IVFe/9kFxbXtjV0ctIMA=\ngithub.com/grpc-ecosystem/go-grpc-middleware v1.0.0/go.mod h1:FiyG127CGDf3tlThmgyCl78X/SZQqEOJBCDaAfeWzPs=\ngithub.com/grpc-ecosystem/go-grpc-middleware v1.0.1-0.20190118093823-f849b5445de4/go.mod h1:FiyG127CGDf3tlThmgyCl78X/SZQqEOJBCDaAfeWzPs=\ngithub.com/grpc-ecosystem/go-grpc-middleware v1.3.0 h1:+9834+KizmvFV7pXQGSXQTsaWhq2GjuNUt0aUU0YBYw=\ngithub.com/grpc-ecosystem/go-grpc-middleware v1.3.0/go.mod h1:z0ButlSOZa5vEBq9m2m2hlwIgKw+rp3sdCBRoJY+30Y=\ngithub.com/grpc-ecosystem/go-grpc-prometheus v1.2.0 h1:Ovs26xHkKqVztRpIrF/92BcuyuQ/YW4NSIpoGtfXNho=\ngithub.com/grpc-ecosystem/go-grpc-prometheus v1.2.0/go.mod h1:8NvIoxWQoOIhqOTXgfV/d3M/q6VIi02HzZEHgUlZvzk=\ngithub.com/grpc-ecosystem/grpc-gateway v1.16.0 h1:gmcG1KaJ57LophUzW0Hy8NmPhnMZb4M0+kPpLofRdBo=\ngithub.com/grpc-ecosystem/grpc-gateway v1.16.0/go.mod h1:BDjrQk3hbvj6Nolgz8mAMFbcEtjT1g+wF4CSlocrBnw=\ngithub.com/hashicorp/consul/api v1.1.0/go.mod h1:VmuI/Lkw1nC05EYQWNKwWGbkg+FbDBtguAZLlVdkD9Q=\ngithub.com/hashicorp/consul/api v1.3.0/go.mod h1:MmDNSzIMUjNpY/mQ398R4bk2FnqQLoPndWW5VkKPlCE=\ngithub.com/hashicorp/consul/sdk v0.1.1/go.mod h1:VKf9jXwCTEY1QZP2MOLRhb5i/I/ssyNV1vwHyQBF0x8=\ngithub.com/hashicorp/consul/sdk v0.3.0/go.mod h1:VKf9jXwCTEY1QZP2MOLRhb5i/I/ssyNV1vwHyQBF0x8=\ngithub.com/hashicorp/errwrap v1.0.0/go.mod h1:YH+1FKiLXxHSkmPseP+kNlulaMuP3n2brvKWEqk/Jc4=\ngithub.com/hashicorp/go-cleanhttp v0.5.0/go.mod h1:JpRdi6/HCYpAwUzNwuwqhbovhLtngrth3wmdIIUrZ80=\ngithub.com/hashicorp/go-cleanhttp v0.5.1 h1:dH3aiDG9Jvb5r5+bYHsikaOUIpcM0xvgMXVoDkXMzJM=\ngithub.com/hashicorp/go-cleanhttp v0.5.1/go.mod h1:JpRdi6/HCYpAwUzNwuwqhbovhLtngrth3wmdIIUrZ80=\ngithub.com/hashicorp/go-hclog v0.9.2 h1:CG6TE5H9/JXsFWJCfoIVpKFIkFe6ysEuHirp4DxCsHI=\ngithub.com/hashicorp/go-hclog v0.9.2/go.mod h1:5CU+agLiy3J7N7QjHK5d05KxGsuXiQLrjA0H7acj2lQ=\ngithub.com/hashicorp/go-immutable-radix v1.0.0/go.mod h1:0y9vanUI8NX6FsYoO3zeMjhV/C5i9g4Q3DwcSNZ4P60=\ngithub.com/hashicorp/go-msgpack v0.5.3/go.mod h1:ahLV/dePpqEmjfWmKiqvPkv/twdG7iPBM1vqhUKIvfM=\ngithub.com/hashicorp/go-multierror v1.0.0/go.mod h1:dHtQlpGsu+cZNNAkkCN/P3hoUDHhCYQXV3UM06sGGrk=\ngithub.com/hashicorp/go-retryablehttp v0.5.1/go.mod h1:9B5zBasrRhHXnJnui7y6sL7es7NDiJgTc6Er0maI1Xs=\ngithub.com/hashicorp/go-retryablehttp v0.7.0 h1:eu1EI/mbirUgP5C8hVsTNaGZreBDlYiwC1FZWkvQPQ4=\ngithub.com/hashicorp/go-retryablehttp v0.7.0/go.mod h1:vAew36LZh98gCBJNLH42IQ1ER/9wtLZZ8meHqQvEYWY=\ngithub.com/hashicorp/go-rootcerts v1.0.0/go.mod h1:K6zTfqpRlCUIjkwsN4Z+hiSfzSTQa6eBIzfwKfwNnHU=\ngithub.com/hashicorp/go-sockaddr v1.0.0/go.mod h1:7Xibr9yA9JjQq1JpNB2Vw7kxv8xerXegt+ozgdvDeDU=\ngithub.com/hashicorp/go-syslog v1.0.0/go.mod h1:qPfqrKkXGihmCqbJM2mZgkZGvKG1dFdvsLplgctolz4=\ngithub.com/hashicorp/go-uuid v1.0.0/go.mod h1:6SBZvOh/SIDV7/2o3Jml5SYk/TvGqwFJ/bN7x4byOro=\ngithub.com/hashicorp/go-uuid v1.0.1/go.mod h1:6SBZvOh/SIDV7/2o3Jml5SYk/TvGqwFJ/bN7x4byOro=\ngithub.com/hashicorp/go-version v1.2.0/go.mod h1:fltr4n8CU8Ke44wwGCBoEymUuxUHl09ZGVZPK5anwXA=\ngithub.com/hashicorp/go.net v0.0.1/go.mod h1:hjKkEWcCURg++eb33jQU7oqQcI9XDCnUzHA0oac0k90=\ngithub.com/hashicorp/golang-lru v0.5.0/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\ngithub.com/hashicorp/golang-lru v0.5.1/go.mod h1:/m3WP610KZHVQ1SGc6re/UDhFvYD7pJ4Ao+sR/qLZy8=\ngithub.com/hashicorp/hcl v1.0.0/go.mod h1:E5yfLk+7swimpb2L/Alb/PJmXilQ/rhwaUYs4T20WEQ=\ngithub.com/hashicorp/logutils v1.0.0/go.mod h1:QIAnNjmIWmVIIkWDTG1z5v++HQmx9WQRO+LraFDTW64=\ngithub.com/hashicorp/mdns v1.0.0/go.mod h1:tL+uN++7HEJ6SQLQ2/p+z2pH24WQKWjBPkE0mNTz8vQ=\ngithub.com/hashicorp/memberlist v0.1.3/go.mod h1:ajVTdAv/9Im8oMAAj5G31PhhMCZJV2pPBoIllUwCN7I=\ngithub.com/hashicorp/serf v0.8.2/go.mod h1:6hOLApaqBFA1NXqRQAsxw9QxuDEvNxSQRwA/JwenrHc=\ngithub.com/heketi/heketi v10.3.0+incompatible/go.mod h1:bB9ly3RchcQqsQ9CpyaQwvva7RS5ytVoSoholZQON6o=\ngithub.com/heketi/tests v0.0.0-20151005000721-f3775cbcefd6/go.mod h1:xGMAM8JLi7UkZt1i4FQeQy0R2T8GLUwQhOP5M1gBhy4=\ngithub.com/howeyc/gopass v0.0.0-20170109162249-bf9dde6d0d2c/go.mod h1:lADxMC39cJJqL93Duh1xhAs4I2Zs8mKS89XWXFGp9cs=\ngithub.com/hpcloud/tail v1.0.0/go.mod h1:ab1qPbhIpdTxEkNHXyeSf5vhxWSCs/tWer42PpOxQnU=\ngithub.com/huandu/xstrings v1.3.0 h1:gvV6jG9dTgFEncxo+AF7PH6MZXi/vZl25owA/8Dg8Wo=\ngithub.com/huandu/xstrings v1.3.0/go.mod h1:y5/lhBue+AyNmUVz9RLU9xbLR0o4KIIExikq4ovT0aE=\ngithub.com/hudl/fargo v1.3.0/go.mod h1:y3CKSmjA+wD2gak7sUSXTAoopbhU08POFhmITJgmKTg=\ngithub.com/ianlancetaylor/demangle v0.0.0-20181102032728-5e5cf60278f6/go.mod h1:aSSvb/t6k1mPoxDqO4vJh6VOCGPwU4O0C2/Eqndh1Sc=\ngithub.com/ianlancetaylor/demangle v0.0.0-20200824232613-28f6c0f3b639/go.mod h1:aSSvb/t6k1mPoxDqO4vJh6VOCGPwU4O0C2/Eqndh1Sc=\ngithub.com/imdario/mergo v0.3.5/go.mod h1:2EnlNZ0deacrJVfApfmtdGgDfMuh/nq6Ok1EcJh5FfA=\ngithub.com/imdario/mergo v0.3.8/go.mod h1:2EnlNZ0deacrJVfApfmtdGgDfMuh/nq6Ok1EcJh5FfA=\ngithub.com/imdario/mergo v0.3.12 h1:b6R2BslTbIEToALKP7LxUvijTsNI9TAe80pLWN2g/HU=\ngithub.com/imdario/mergo v0.3.12/go.mod h1:jmQim1M+e3UYxmgPu/WyfjB3N3VflVyUjjjwH0dnCYA=\ngithub.com/improbable-eng/grpc-web v0.0.0-20181111100011-16092bd1d58a h1:RweVA0vnEyStwtAelyGmnU8ENDnwd1Q7pQr7U3J/rXo=\ngithub.com/improbable-eng/grpc-web v0.0.0-20181111100011-16092bd1d58a/go.mod h1:6hRR09jOEG81ADP5wCQju1z71g6OL4eEvELdran/3cs=\ngithub.com/inconshreveable/mousetrap v1.0.0 h1:Z8tu5sraLXCXIcARxBp/8cbvlwVa7Z1NHg9XEKhtSvM=\ngithub.com/inconshreveable/mousetrap v1.0.0/go.mod h1:PxqpIevigyE2G7u3NXJIT2ANytuPF1OarO4DADm73n8=\ngithub.com/influxdata/influxdb1-client v0.0.0-20191209144304-8bf82d3c094d/go.mod h1:qj24IKcXYK6Iy9ceXlo3Tc+vtHo9lIhSX5JddghvEPo=\ngithub.com/ishidawataru/sctp v0.0.0-20190723014705-7c296d48a2b5/go.mod h1:DM4VvS+hD/kDi1U1QsX2fnZowwBhqD0Dk3bRPKF/Oc8=\ngithub.com/itchyny/go-flags v1.5.0/go.mod h1:lenkYuCobuxLBAd/HGFE4LRoW8D3B6iXRQfWYJ+MNbA=\ngithub.com/itchyny/gojq v0.12.3 h1:s7jTCyOk/dy5bnDIScj24YX4Cr1yhEO2iW/bQT4Pm2s=\ngithub.com/itchyny/gojq v0.12.3/go.mod h1:mi4PdXSlFllHyByM68JKUrbiArtEdEnNEmjbwxcQKAg=\ngithub.com/itchyny/timefmt-go v0.1.2 h1:q0Xa4P5it6K6D7ISsbLAMwx1PnWlixDcJL6/sFs93Hs=\ngithub.com/itchyny/timefmt-go v0.1.2/go.mod h1:0osSSCQSASBJMsIZnhAaF1C2fCBTJZXrnj37mG8/c+A=\ngithub.com/jaytaylor/html2text v0.0.0-20190408195923-01ec452cbe43/go.mod h1:CVKlgaMiht+LXvHG173ujK6JUhZXKb2u/BQtjPDIvyk=\ngithub.com/jbenet/go-context v0.0.0-20150711004518-d14ea06fba99 h1:BQSFePA1RWJOlocH6Fxy8MmwDt+yVQYULKfN0RoTN8A=\ngithub.com/jbenet/go-context v0.0.0-20150711004518-d14ea06fba99/go.mod h1:1lJo3i6rXxKeerYnT8Nvf0QmHCRC1n8sfWVwXF2Frvo=\ngithub.com/jessevdk/go-flags v1.4.0/go.mod h1:4FA24M0QyGHXBuZZK/XkWh8h0e1EYbRYJSGM75WSRxI=\ngithub.com/jessevdk/go-flags v1.5.0/go.mod h1:Fw0T6WPc1dYxT4mKEZRfG5kJhaTDP9pj1c2EWnYs/m4=\ngithub.com/jmespath/go-jmespath v0.0.0-20180206201540-c2b33e8439af/go.mod h1:Nht3zPeWKUH0NzdCt2Blrr5ys8VGpn0CEB0cQHVjt7k=\ngithub.com/jmespath/go-jmespath v0.3.0/go.mod h1:9QtRXoHjLGCJ5IBSaohpXITPlowMeeYCZ7fLUTSywik=\ngithub.com/jmespath/go-jmespath v0.4.0/go.mod h1:T8mJZnbsbmF+m6zOOFylbeCJqk5+pHWvzYPziyZiYoo=\ngithub.com/jmespath/go-jmespath/internal/testify v1.5.1/go.mod h1:L3OGu8Wl2/fWfCI6z80xFu9LTZmf1ZRjMHUOPmWr69U=\ngithub.com/joho/godotenv v1.3.0/go.mod h1:7hK45KPybAkOC6peb+G5yklZfMxEjkZhHbwpqxOKXbg=\ngithub.com/jonboulle/clockwork v0.1.0/go.mod h1:Ii8DK3G1RaLaWxj9trq07+26W01tbo22gdxWY5EU2bo=\ngithub.com/jonboulle/clockwork v0.2.2 h1:UOGuzwb1PwsrDAObMuhUnj0p5ULPj8V/xJ7Kx9qUBdQ=\ngithub.com/jonboulle/clockwork v0.2.2/go.mod h1:Pkfl5aHPm1nk2H9h0bjmnJD/BcgbGXUBGnn1kMkgxc8=\ngithub.com/josharian/intern v1.0.0 h1:vlS4z54oSdjm0bgjRigI+G1HpF+tI+9rE5LLzOg8HmY=\ngithub.com/josharian/intern v1.0.0/go.mod h1:5DoeVV0s6jJacbCEi61lwdGj/aVlrQvzHFFd8Hwg//Y=\ngithub.com/jpillora/backoff v1.0.0/go.mod h1:J/6gKK9jxlEcS3zixgDgUAsiuZ7yrSoa/FX5e0EB2j4=\ngithub.com/json-iterator/go v1.1.6/go.mod h1:+SdeFBvtyEkXs7REEP0seUULqWtbJapLOCVDaaPEHmU=\ngithub.com/json-iterator/go v1.1.7/go.mod h1:KdQUCv79m/52Kvf8AW2vK1V8akMuk1QjK/uOdHXbAo4=\ngithub.com/json-iterator/go v1.1.8/go.mod h1:KdQUCv79m/52Kvf8AW2vK1V8akMuk1QjK/uOdHXbAo4=\ngithub.com/json-iterator/go v1.1.10/go.mod h1:KdQUCv79m/52Kvf8AW2vK1V8akMuk1QjK/uOdHXbAo4=\ngithub.com/json-iterator/go v1.1.11/go.mod h1:KdQUCv79m/52Kvf8AW2vK1V8akMuk1QjK/uOdHXbAo4=\ngithub.com/json-iterator/go v1.1.12 h1:PV8peI4a0ysnczrg+LtxykD8LfKY9ML6u2jnxaEnrnM=\ngithub.com/json-iterator/go v1.1.12/go.mod h1:e30LSqwooZae/UwlEbR2852Gd8hjQvJoHmT4TnhNGBo=\ngithub.com/jstemmer/go-junit-report v0.0.0-20190106144839-af01ea7f8024/go.mod h1:6v2b51hI/fHJwM22ozAgKL4VKDeJcHhJFhtBdhmNjmU=\ngithub.com/jstemmer/go-junit-report v0.9.1/go.mod h1:Brl9GWCQeLvo8nXZwPNNblvFj/XSXhF0NWZEnDohbsk=\ngithub.com/jtolds/gls v4.20.0+incompatible/go.mod h1:QJZ7F/aHp+rZTRtaJ1ow/lLfFfVYBRgL+9YlvaHOwJU=\ngithub.com/juju/errors v0.0.0-20181118221551-089d3ea4e4d5/go.mod h1:W54LbzXuIE0boCoNJfwqpmkKJ1O4TCTZMetAt6jGk7Q=\ngithub.com/juju/loggo v0.0.0-20180524022052-584905176618/go.mod h1:vgyd7OREkbtVEN/8IXZe5Ooef3LQePvuBm9UWj6ZL8U=\ngithub.com/juju/testing v0.0.0-20180920084828-472a3e8b2073/go.mod h1:63prj8cnj0tU0S9OHjGJn+b1h0ZghCndfnbQolrYTwA=\ngithub.com/julienschmidt/httprouter v1.2.0/go.mod h1:SYymIcj16QtmaHHD7aYtjjsJG7VTCxuUUipMqKk8s4w=\ngithub.com/julienschmidt/httprouter v1.3.0/go.mod h1:JR6WtHb+2LUe8TCKY3cZOxFyyO8IZAc4RVcycCCAKdM=\ngithub.com/jung-kurt/gofpdf v1.0.3-0.20190309125859-24315acbbda5/go.mod h1:7Id9E/uU8ce6rXgefFLlgrJj/GYY22cpxn+r32jIOes=\ngithub.com/karrick/godirwalk v1.16.1/go.mod h1:j4mkqPuvaLI8mp1DroR3P6ad7cyYd4c1qeJ3RV7ULlk=\ngithub.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51 h1:Z9n2FFNUXsshfwJMBgNA0RU6/i7WVaAegv3PtuIHPMs=\ngithub.com/kballard/go-shellquote v0.0.0-20180428030007-95032a82bc51/go.mod h1:CzGEWj7cYgsdH8dAjBGEr58BoE7ScuLd+fwFZ44+/x8=\ngithub.com/kevinburke/ssh_config v0.0.0-20201106050909-4977a11b4351 h1:DowS9hvgyYSX4TO5NpyC606/Z4SxnNYbT+WX27or6Ck=\ngithub.com/kevinburke/ssh_config v0.0.0-20201106050909-4977a11b4351/go.mod h1:CT57kijsi8u/K/BOFA39wgDQJ9CxiF4nAY/ojJ6r6mM=\ngithub.com/kisielk/errcheck v1.1.0/go.mod h1:EZBBE59ingxPouuu3KfxchcWSUPOHkagtvWXihfKN4Q=\ngithub.com/kisielk/errcheck v1.2.0/go.mod h1:/BMXB+zMLi60iA8Vv6Ksmxu/1UDYcXs4uQLJ+jE2L00=\ngithub.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI2bnpBCr8=\ngithub.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=\ngithub.com/klauspost/compress v1.13.5 h1:9O69jUPDcsT9fEm74W92rZL9FQY7rCdaXVneq+yyzl4=\ngithub.com/klauspost/compress v1.13.5/go.mod h1:/3/Vjq9QcHkK5uEr5lBEmyoZ1iFhe47etQ6QUkpK6sk=\ngithub.com/klauspost/cpuid v1.2.3/go.mod h1:Pj4uuM528wm8OyEC2QMXAi2YiTZ96dNQPGgoMS4s3ek=\ngithub.com/konsorten/go-windows-terminal-sequences v1.0.1/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=\ngithub.com/konsorten/go-windows-terminal-sequences v1.0.2/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=\ngithub.com/konsorten/go-windows-terminal-sequences v1.0.3/go.mod h1:T0+1ngSBFLxvqU3pZ+m/2kptfBszLMUkC4ZK/EgS/cQ=\ngithub.com/kr/fs v0.1.0/go.mod h1:FFnZGqtBN9Gxj7eW1uZ42v5BccTP0vu6NEaFoC2HwRg=\ngithub.com/kr/logfmt v0.0.0-20140226030751-b84e30acd515/go.mod h1:+0opPa2QZZtGFBFZlji/RkVcI2GknAs/DXo4wKdlNEc=\ngithub.com/kr/pretty v0.1.0/go.mod h1:dAy3ld7l9f0ibDNOQOHHMYYIIbhfbHSm3C4ZsoJORNo=\ngithub.com/kr/pretty v0.2.0/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=\ngithub.com/kr/pretty v0.2.1 h1:Fmg33tUaq4/8ym9TJN1x7sLJnHVwhP33CNkpYV/7rwI=\ngithub.com/kr/pretty v0.2.1/go.mod h1:ipq/a2n7PKx3OHsz4KJII5eveXtPO4qwEXGdVfWzfnI=\ngithub.com/kr/pty v1.1.1/go.mod h1:pFQYn66WHrOpPYNljwOMqo10TkYh1fy3cYio2l3bCsQ=\ngithub.com/kr/pty v1.1.5/go.mod h1:9r2w37qlBe7rQ6e1fg1S/9xpWHSnaqNdHD3WcMdbPDA=\ngithub.com/kr/text v0.1.0/go.mod h1:4Jbv+DJW3UT/LiOwJeYQe1efqtUx/iVham/4vfdArNI=\ngithub.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=\ngithub.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=\ngithub.com/leodido/go-urn v1.1.0/go.mod h1:+cyI34gQWZcE1eQU7NVgKkkzdXDQHr1dBMtdAPozLkw=\ngithub.com/libopenstorage/openstorage v1.0.0/go.mod h1:Sp1sIObHjat1BeXhfMqLZ14wnOzEhNx2YQedreMcUyc=\ngithub.com/liggitt/tabwriter v0.0.0-20181228230101-89fcab3d43de h1:9TO3cAIGXtEhnIaL+V+BEER86oLrvS+kWobKpbJuye0=\ngithub.com/liggitt/tabwriter v0.0.0-20181228230101-89fcab3d43de/go.mod h1:zAbeS9B/r2mtpb6U+EI2rYA5OAXxsYw6wTamcNW+zcE=\ngithub.com/lightstep/lightstep-tracer-common/golang/gogo v0.0.0-20190605223551-bc2310a04743/go.mod h1:qklhhLq1aX+mtWk9cPHPzaBjWImj5ULL6C7HFJtXQMM=\ngithub.com/lightstep/lightstep-tracer-go v0.18.1/go.mod h1:jlF1pusYV4pidLvZ+XD0UBX0ZE6WURAspgAczcDHrL4=\ngithub.com/lithammer/dedent v1.1.0/go.mod h1:jrXYCQtgg0nJiN+StA2KgR7w6CiQNv9Fd/Z9BP0jIOc=\ngithub.com/lpabon/godbc v0.1.1/go.mod h1:Jo9QV0cf3U6jZABgiJ2skINAXb9j8m51r07g4KI92ZA=\ngithub.com/lucasb-eyer/go-colorful v1.0.2/go.mod h1:0MS4r+7BZKSJ5mw4/S5MPN+qHFF1fYclkSPilDOKW0s=\ngithub.com/lucasb-eyer/go-colorful v1.0.3/go.mod h1:R4dSotOR9KMtayYi1e77YzuveK+i7ruzyGqttikkLy0=\ngithub.com/lusis/go-slackbot v0.0.0-20180109053408-401027ccfef5/go.mod h1:c2mYKRyMb1BPkO5St0c/ps62L4S0W2NAkaTXj9qEI+0=\ngithub.com/lusis/slack-test v0.0.0-20190426140909-c40012f20018/go.mod h1:sFlOUpQL1YcjhFVXhg1CG8ZASEs/Mf1oVb6H75JL/zg=\ngithub.com/magiconair/properties v1.8.0/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=\ngithub.com/magiconair/properties v1.8.1/go.mod h1:PppfXfuXeibc/6YijjN8zIbojt8czPbwD3XqdrwzmxQ=\ngithub.com/magiconair/properties v1.8.5/go.mod h1:y3VJvCyxH9uVvJTWEGAELF3aiYNyPKd5NZ3oSwXrF60=\ngithub.com/mailgun/mailgun-go v2.0.0+incompatible/go.mod h1:NWTyU+O4aczg/nsGhQnvHL6v2n5Gy6Sv5tNDVvC6FbU=\ngithub.com/mailru/easyjson v0.0.0-20180823135443-60711f1a8329/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=\ngithub.com/mailru/easyjson v0.0.0-20190312143242-1de009706dbe/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=\ngithub.com/mailru/easyjson v0.0.0-20190614124828-94de47d64c63/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=\ngithub.com/mailru/easyjson v0.0.0-20190626092158-b2ccc519800e/go.mod h1:C1wdFJiN94OJF2b5HbByQZoLdCWB1Yqtg26g4irojpc=\ngithub.com/mailru/easyjson v0.7.0/go.mod h1:KAzv3t3aY1NaHWoQz1+4F1ccyAH66Jk7yos7ldAVICs=\ngithub.com/mailru/easyjson v0.7.6 h1:8yTIVnZgCoiM1TgqoeTl+LfU5Jg6/xL3QhGQnimLYnA=\ngithub.com/mailru/easyjson v0.7.6/go.mod h1:xzfreul335JAWq5oZzymOObrkdz5UnU4kGfJJLY9Nlc=\ngithub.com/malexdev/utfutil v0.0.0-20180510171754-00c8d4a8e7a8 h1:A6SLdFpRzUUF5v9F/7T1fu3DERmOCgTwwP6x54eyFfU=\ngithub.com/malexdev/utfutil v0.0.0-20180510171754-00c8d4a8e7a8/go.mod h1:UtpLyb/EupVKXF/N0b4NRe1DNg+QYJsnsHQ038romhM=\ngithub.com/matryer/is v1.2.0 h1:92UTHpy8CDwaJ08GqLDzhhuixiBUUD1p3AU6PHddz4A=\ngithub.com/matryer/is v1.2.0/go.mod h1:2fLPjFQM9rhQ15aVEtbuwhJinnOqrmgXPNdZsdwlWXA=\ngithub.com/mattn/go-colorable v0.0.9/go.mod h1:9vuHe8Xs5qXnSaW/c/ABM9alt+Vo+STaOChaDxuIBZU=\ngithub.com/mattn/go-colorable v0.1.2/go.mod h1:U0ppj6V5qS13XJ6of8GYAs25YV2eR4EVcfRqFIhoBtE=\ngithub.com/mattn/go-colorable v0.1.8/go.mod h1:u6P/XSegPjTcexA+o6vUJrdnUu04hMope9wVRipJSqc=\ngithub.com/mattn/go-isatty v0.0.3/go.mod h1:M+lRXTBqGeGNdLjl/ufCoiOlB5xdOkqRJdNxMWT7Zi4=\ngithub.com/mattn/go-isatty v0.0.4/go.mod h1:M+lRXTBqGeGNdLjl/ufCoiOlB5xdOkqRJdNxMWT7Zi4=\ngithub.com/mattn/go-isatty v0.0.8/go.mod h1:Iq45c/XA43vh69/j3iqttzPXn0bhXyGjM0Hdxcsrc5s=\ngithub.com/mattn/go-isatty v0.0.9/go.mod h1:YNRxwqDuOph6SZLI9vUUz6OYw3QyUt7WiY2yME+cCiQ=\ngithub.com/mattn/go-isatty v0.0.12 h1:wuysRhFDzyxgEmMf5xjvJ2M9dZoWAXNNr5LSBS7uHXY=\ngithub.com/mattn/go-isatty v0.0.12/go.mod h1:cbi8OIDigv2wuxKPP5vlRcQ1OAZbq2CE4Kysco4FUpU=\ngithub.com/mattn/go-runewidth v0.0.2/go.mod h1:LwmH8dsx7+W8Uxz3IHJYH5QSwggIsqBzpuz5H//U1FU=\ngithub.com/mattn/go-runewidth v0.0.4/go.mod h1:LwmH8dsx7+W8Uxz3IHJYH5QSwggIsqBzpuz5H//U1FU=\ngithub.com/mattn/go-runewidth v0.0.7/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=\ngithub.com/mattn/go-runewidth v0.0.8/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=\ngithub.com/mattn/go-runewidth v0.0.9 h1:Lm995f3rfxdpd6TSmuVCHVb/QhupuXlYr8sCI/QdE+0=\ngithub.com/mattn/go-runewidth v0.0.9/go.mod h1:H031xJmbD/WCDINGzjvQ9THkh0rPKHF+m2gUSrubnMI=\ngithub.com/mattn/go-zglob v0.0.3 h1:6Ry4EYsScDyt5di4OI6xw1bYhOqfE5S33Z1OPy+d+To=\ngithub.com/mattn/go-zglob v0.0.3/go.mod h1:9fxibJccNxU2cnpIKLRRFA7zX7qhkJIQWBb449FYHOo=\ngithub.com/mattn/goveralls v0.0.2/go.mod h1:8d1ZMHsd7fW6IRPKQh46F2WRpyib5/X4FOpevwGNQEw=\ngithub.com/matttproud/golang_protobuf_extensions v1.0.1/go.mod h1:D8He9yQNgCq6Z5Ld7szi9bcBfOoFv/3dc6xSMkL2PC0=\ngithub.com/matttproud/golang_protobuf_extensions v1.0.2-0.20181231171920-c182affec369 h1:I0XW9+e1XWDxdcEniV4rQAIOPUGDq67JSCiRCgGCZLI=\ngithub.com/matttproud/golang_protobuf_extensions v1.0.2-0.20181231171920-c182affec369/go.mod h1:BSXmuO+STAnVfrANrmjBb36TMTDstsz7MSK+HVaYKv4=\ngithub.com/miekg/dns v1.0.14/go.mod h1:W1PPwlIAgtquWBMBEV9nkV9Cazfe8ScdGz/Lj7v3Nrg=\ngithub.com/mindprince/gonvml v0.0.0-20190828220739-9ebdce4bb989/go.mod h1:2eu9pRWp8mo84xCg6KswZ+USQHjwgRhNp06sozOdsTY=\ngithub.com/minio/md5-simd v1.1.0/go.mod h1:XpBqgZULrMYD3R+M28PcmP0CkI7PEMzB3U77ZrKZ0Gw=\ngithub.com/minio/minio-go/v7 v7.0.2/go.mod h1:dJ80Mv2HeGkYLH1sqS/ksz07ON6csH3S6JUMSQ2zAns=\ngithub.com/minio/sha256-simd v0.1.1/go.mod h1:B5e1o+1/KgNmWrSQK08Y6Z1Vb5pwIktudl0J58iy0KM=\ngithub.com/mistifyio/go-zfs v2.1.2-0.20190413222219-f784269be439+incompatible/go.mod h1:8AuVvqP/mXw1px98n46wfvcGfQ4ci2FwoAjKYxuo3Z4=\ngithub.com/mitchellh/cli v1.0.0/go.mod h1:hNIlj7HEI86fIcpObd7a0FcrxTWetlwJDGcceTlRvqc=\ngithub.com/mitchellh/copystructure v1.0.0 h1:Laisrj+bAB6b/yJwB5Bt3ITZhGJdqmxquMKeZ+mmkFQ=\ngithub.com/mitchellh/copystructure v1.0.0/go.mod h1:SNtv71yrdKgLRyLFxmLdkAbkKEFWgYaq1OVrnRcwhnw=\ngithub.com/mitchellh/go-homedir v1.0.0/go.mod h1:SfyaCUpYCn1Vlf4IUYiD9fPX4A5wJrkLzIz1N1q0pr0=\ngithub.com/mitchellh/go-homedir v1.1.0 h1:lukF9ziXFxDFPkA1vsr5zpc1XuPDn/wFntq5mG+4E0Y=\ngithub.com/mitchellh/go-homedir v1.1.0/go.mod h1:SfyaCUpYCn1Vlf4IUYiD9fPX4A5wJrkLzIz1N1q0pr0=\ngithub.com/mitchellh/go-testing-interface v1.0.0/go.mod h1:kRemZodwjscx+RGhAo8eIhFbs2+BFgRtFPeD/KE+zxI=\ngithub.com/mitchellh/go-wordwrap v1.0.0 h1:6GlHJ/LTGMrIJbwgdqdl2eEH8o+Exx/0m8ir9Gns0u4=\ngithub.com/mitchellh/go-wordwrap v1.0.0/go.mod h1:ZXFpozHsX6DPmq2I0TCekCxypsnAUbP2oI0UX1GXzOo=\ngithub.com/mitchellh/gox v0.4.0/go.mod h1:Sd9lOJ0+aimLBi73mGofS1ycjY8lL3uZM3JPS42BGNg=\ngithub.com/mitchellh/iochan v1.0.0/go.mod h1:JwYml1nuB7xOzsp52dPpHFffvOCDupsG0QubkSMEySY=\ngithub.com/mitchellh/mapstructure v0.0.0-20160808181253-ca63d7c062ee/go.mod h1:FVVH3fgwuzCH5S8UJGiWEs2h04kUh9fWfEaFds41c1Y=\ngithub.com/mitchellh/mapstructure v1.1.2/go.mod h1:FVVH3fgwuzCH5S8UJGiWEs2h04kUh9fWfEaFds41c1Y=\ngithub.com/mitchellh/mapstructure v1.4.1 h1:CpVNEelQCZBooIPDn+AR3NpivK/TIKU8bDxdASFVQag=\ngithub.com/mitchellh/mapstructure v1.4.1/go.mod h1:bFUtVrKA4DC2yAKiSyO/QUcy7e+RRV2QTWOzhPopBRo=\ngithub.com/mitchellh/reflectwalk v1.0.0 h1:9D+8oIskB4VJBN5SFlmc27fSlIBZaov1Wpk/IfikLNY=\ngithub.com/mitchellh/reflectwalk v1.0.0/go.mod h1:mSTlrgnPZtwu0c4WaC2kGObEpuNDbx0jmZXqmk4esnw=\ngithub.com/moby/ipvs v1.0.1/go.mod h1:2pngiyseZbIKXNv7hsKj3O9UEz30c53MT9005gt2hxQ=\ngithub.com/moby/spdystream v0.2.0 h1:cjW1zVyyoiM0T7b6UoySUFqzXMoqRckQtXwGPiBhOM8=\ngithub.com/moby/spdystream v0.2.0/go.mod h1:f7i0iNDQJ059oMTcWxx8MA/zKFIuD/lY+0GqbN2Wy8c=\ngithub.com/moby/sys/mountinfo v0.4.1/go.mod h1:rEr8tzG/lsIZHBtN/JjGG+LMYx9eXgW2JI+6q0qou+A=\ngithub.com/moby/term v0.0.0-20201216013528-df9cb8a40635/go.mod h1:FBS0z0QWA44HXygs7VXDUOGoN/1TV3RuWkLO04am3wc=\ngithub.com/moby/term v0.0.0-20210610120745-9d4ed1856297 h1:yH0SvLzcbZxcJXho2yh7CqdENGMQe73Cw3woZBpPli0=\ngithub.com/moby/term v0.0.0-20210610120745-9d4ed1856297/go.mod h1:vgPCkQMyxTZ7IDy8SXRufE172gr8+K/JE/7hHFxHW3A=\ngithub.com/modern-go/concurrent v0.0.0-20180228061459-e0a39a4cb421/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd h1:TRLaZ9cD/w8PVh93nsPXa1VrQ6jlwL5oN8l14QlcNfg=\ngithub.com/modern-go/concurrent v0.0.0-20180306012644-bacd9c7ef1dd/go.mod h1:6dJC0mAP4ikYIbvyc7fijjWJddQyLn8Ig3JB5CqoB9Q=\ngithub.com/modern-go/reflect2 v0.0.0-20180701023420-4b7aa43c6742/go.mod h1:bx2lNnkwVCuqBIxFjflWJWanXIb3RllmbCylyMrvgv0=\ngithub.com/modern-go/reflect2 v1.0.1/go.mod h1:bx2lNnkwVCuqBIxFjflWJWanXIb3RllmbCylyMrvgv0=\ngithub.com/modern-go/reflect2 v1.0.2 h1:xBagoLtFs94CBntxluKeaWgTMpvLxC4ur3nMaC9Gz0M=\ngithub.com/modern-go/reflect2 v1.0.2/go.mod h1:yWuevngMOJpCy52FWWMvUC8ws7m/LJsjYzDa0/r8luk=\ngithub.com/mohae/deepcopy v0.0.0-20170603005431-491d3605edfb/go.mod h1:TaXosZuwdSHYgviHp1DAtfrULt5eUgsSMsZf+YrPgl8=\ngithub.com/monochromegane/go-gitignore v0.0.0-20200626010858-205db1a8cc00 h1:n6/2gBQ3RWajuToeY6ZtZTIKv2v7ThUy5KKusIT0yc0=\ngithub.com/monochromegane/go-gitignore v0.0.0-20200626010858-205db1a8cc00/go.mod h1:Pm3mSP3c5uWn86xMLZ5Sa7JB9GsEZySvHYXCTK4E9q4=\ngithub.com/morikuni/aec v1.0.0/go.mod h1:BbKIizmSmc5MMPqRYbxO4ZU0S0+P200+tUnFx7PXmsc=\ngithub.com/moul/http2curl v1.0.0/go.mod h1:8UbvGypXm98wA/IqH45anm5Y2Z6ep6O31QGOAZ3H0fQ=\ngithub.com/mrunalp/fileutils v0.5.0/go.mod h1:M1WthSahJixYnrXQl/DFQuteStB1weuxD2QJNHXfbSQ=\ngithub.com/munnerz/goautoneg v0.0.0-20120707110453-a547fc61f48d/go.mod h1:+n7T8mK8HuQTcFwEeznm/DIxMOiR9yIdICNftLE1DvQ=\ngithub.com/munnerz/goautoneg v0.0.0-20191010083416-a7dc8b61c822/go.mod h1:+n7T8mK8HuQTcFwEeznm/DIxMOiR9yIdICNftLE1DvQ=\ngithub.com/mvdan/xurls v1.1.0/go.mod h1:tQlNn3BED8bE/15hnSL2HLkDeLWpNPAwtw7wkEq44oU=\ngithub.com/mwitkow/go-conntrack v0.0.0-20161129095857-cc309e4a2223/go.mod h1:qRWi+5nqEBWmkhHvq77mSJWrCKwh8bxhgT7d/eI7P4U=\ngithub.com/mwitkow/go-conntrack v0.0.0-20190716064945-2f068394615f h1:KUppIJq7/+SVif2QVs3tOP0zanoHgBEVAwHxUSIzRqU=\ngithub.com/mwitkow/go-conntrack v0.0.0-20190716064945-2f068394615f/go.mod h1:qRWi+5nqEBWmkhHvq77mSJWrCKwh8bxhgT7d/eI7P4U=\ngithub.com/mxk/go-flowrate v0.0.0-20140419014527-cca7078d478f/go.mod h1:ZdcZmHo+o7JKHSa8/e818NopupXU1YMK5fe1lsApnBw=\ngithub.com/nats-io/jwt v0.3.0/go.mod h1:fRYCDE99xlTsqUzISS1Bi75UBJ6ljOJQOAAu5VglpSg=\ngithub.com/nats-io/jwt v0.3.2/go.mod h1:/euKqTS1ZD+zzjYrY7pseZrTtWQSjujC7xjPc8wL6eU=\ngithub.com/nats-io/nats-server/v2 v2.1.2/go.mod h1:Afk+wRZqkMQs/p45uXdrVLuab3gwv3Z8C4HTBu8GD/k=\ngithub.com/nats-io/nats.go v1.9.1/go.mod h1:ZjDU1L/7fJ09jvUSRVBR2e7+RnLiiIQyqyzEE/Zbp4w=\ngithub.com/nats-io/nkeys v0.1.0/go.mod h1:xpnFELMwJABBLVhffcfd1MZx6VsNRFpEugbxziKVo7w=\ngithub.com/nats-io/nkeys v0.1.3/go.mod h1:xpnFELMwJABBLVhffcfd1MZx6VsNRFpEugbxziKVo7w=\ngithub.com/nats-io/nuid v1.0.1/go.mod h1:19wcPz3Ph3q0Jbyiqsd0kePYG7A95tJPxeL+1OSON2c=\ngithub.com/niemeyer/pretty v0.0.0-20200227124842-a10e7caefd8e/go.mod h1:zD1mROLANZcx1PVRCS0qkT7pwLkGfwJo4zjcN/Tysno=\ngithub.com/nlopes/slack v0.5.0/go.mod h1:jVI4BBK3lSktibKahxBF74txcK2vyvkza1z/+rRnVAM=\ngithub.com/nxadm/tail v1.4.4/go.mod h1:kenIhsEOeOJmVchQTgglprH7qJGnHDVpk1VPCcaMI8A=\ngithub.com/nxadm/tail v1.4.8 h1:nPr65rt6Y5JFSKQO7qToXr7pePgD6Gwiw05lkbyAQTE=\ngithub.com/nxadm/tail v1.4.8/go.mod h1:+ncqLTQzXmGhMZNUePPaPqPvBxHAIsmXswZKocGu+AU=\ngithub.com/oklog/oklog v0.3.2/go.mod h1:FCV+B7mhrz4o+ueLpx+KqkyXRGMWOYEvfiXtdGtbWGs=\ngithub.com/oklog/run v1.0.0/go.mod h1:dlhp/R75TPv97u0XWUtDeV/lRKWPKSdTuV0TZvrmrQA=\ngithub.com/oklog/ulid v1.3.1/go.mod h1:CirwcVhetQ6Lv90oh/F+FBtV6XMibvdAFo93nm5qn4U=\ngithub.com/olekukonko/tablewriter v0.0.0-20170122224234-a0225b3f23b5/go.mod h1:vsDQFd/mU46D+Z4whnwzcISnGGzXWMclvtLoiIKAKIo=\ngithub.com/olekukonko/tablewriter v0.0.1/go.mod h1:vsDQFd/mU46D+Z4whnwzcISnGGzXWMclvtLoiIKAKIo=\ngithub.com/olekukonko/tablewriter v0.0.4/go.mod h1:zq6QwlOf5SlnkVbMSr5EoBv3636FWnp+qbPhuoO21uA=\ngithub.com/olekukonko/tablewriter v0.0.5 h1:P2Ga83D34wi1o9J6Wh1mRuqd4mF/x/lgBS7N7AbDhec=\ngithub.com/olekukonko/tablewriter v0.0.5/go.mod h1:hPp6KlRPjbx+hW8ykQs1w3UBbZlj6HuIJcUGPhkA7kY=\ngithub.com/oliveagle/jsonpath v0.0.0-20180606110733-2e52cf6e6852/go.mod h1:eqOVx5Vwu4gd2mmMZvVZsgIqNSaW3xxRThUJ0k/TPk4=\ngithub.com/onsi/ginkgo v0.0.0-20170829012221-11459a886d9c/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=\ngithub.com/onsi/ginkgo v1.6.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=\ngithub.com/onsi/ginkgo v1.7.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=\ngithub.com/onsi/ginkgo v1.8.0/go.mod h1:lLunBs/Ym6LB5Z9jYTR76FiuTmxDTDusOGeTQH+WWjE=\ngithub.com/onsi/ginkgo v1.12.1/go.mod h1:zj2OWP4+oCPe1qIXoGWkgMRwljMUYCdkwsT2108oapk=\ngithub.com/onsi/ginkgo v1.14.0/go.mod h1:iSB4RoI2tjJc9BBv4NKIKWKya62Rps+oPG/Lv9klQyY=\ngithub.com/onsi/ginkgo v1.14.1/go.mod h1:iSB4RoI2tjJc9BBv4NKIKWKya62Rps+oPG/Lv9klQyY=\ngithub.com/onsi/ginkgo v1.16.4/go.mod h1:dX+/inL/fNMqNlz0e9LfyB9TswhZpCVdJM/Z6Vvnwo0=\ngithub.com/onsi/ginkgo v1.16.5 h1:8xi0RTUf59SOSfEtZMvwTvXYMzG4gV23XVHOZiXNtnE=\ngithub.com/onsi/ginkgo v1.16.5/go.mod h1:+E8gABHa3K6zRBolWtd+ROzc/U5bkGt0FwiG042wbpU=\ngithub.com/onsi/gomega v0.0.0-20170829124025-dcabb60a477c/go.mod h1:C1qb7wdrVGGVU+Z6iS04AVkA3Q65CEZX59MT0QO5uiA=\ngithub.com/onsi/gomega v1.4.3/go.mod h1:ex+gbHU/CVuBBDIJjb2X0qEXbFg53c61hWP/1CpauHY=\ngithub.com/onsi/gomega v1.5.0/go.mod h1:ex+gbHU/CVuBBDIJjb2X0qEXbFg53c61hWP/1CpauHY=\ngithub.com/onsi/gomega v1.7.1/go.mod h1:XdKZgCCFLUoM/7CFJVPcG8C1xQ1AJ0vpAezJrB7JYyY=\ngithub.com/onsi/gomega v1.10.1/go.mod h1:iN09h71vgCQne3DLsj+A5owkum+a2tYe+TOCB1ybHNo=\ngithub.com/onsi/gomega v1.10.2/go.mod h1:iN09h71vgCQne3DLsj+A5owkum+a2tYe+TOCB1ybHNo=\ngithub.com/onsi/gomega v1.15.0/go.mod h1:cIuvLEne0aoVhAgh/O6ac0Op8WWw9H6eYCriF+tEHG0=\ngithub.com/onsi/gomega v1.17.0 h1:9Luw4uT5HTjHTN8+aNcSThgH1vdXnmdJ8xIfZ4wyTRE=\ngithub.com/onsi/gomega v1.17.0/go.mod h1:HnhC7FXeEQY45zxNK3PPoIUhzk/80Xly9PcubAlGdZY=\ngithub.com/op/go-logging v0.0.0-20160315200505-970db520ece7/go.mod h1:HzydrMdWErDVzsI23lYNej1Htcns9BCg93Dk0bBINWk=\ngithub.com/opencontainers/go-digest v1.0.0 h1:apOUWs51W5PlhuyGyz9FCeeBIOUDA/6nW8Oi/yOhh5U=\ngithub.com/opencontainers/go-digest v1.0.0/go.mod h1:0JzlMkj0TRzQZfJkVvzbP0HBR3IKzErnv2BNG4W4MAM=\ngithub.com/opencontainers/image-spec v1.0.1/go.mod h1:BtxoFyWECRxE4U/7sNtV5W15zMzWCbyJoFRP3s7yZA0=\ngithub.com/opencontainers/runc v1.0.2/go.mod h1:aTaHFFwQXuA71CiyxOdFFIorAoemI04suvGRQFzWTD0=\ngithub.com/opencontainers/runtime-spec v1.0.2/go.mod h1:jwyrGlmzljRJv/Fgzds9SsS/C5hL+LL3ko9hs6T5lQ0=\ngithub.com/opencontainers/runtime-spec v1.0.3-0.20200929063507-e6143ca7d51d/go.mod h1:jwyrGlmzljRJv/Fgzds9SsS/C5hL+LL3ko9hs6T5lQ0=\ngithub.com/opencontainers/runtime-spec v1.0.3-0.20210326190908-1c3f411f0417/go.mod h1:jwyrGlmzljRJv/Fgzds9SsS/C5hL+LL3ko9hs6T5lQ0=\ngithub.com/opencontainers/selinux v1.8.2/go.mod h1:MUIHuUEvKB1wtJjQdOyYRgOnLD2xAPP8dBsCoU0KuF8=\ngithub.com/opentracing-contrib/go-observer v0.0.0-20170622124052-a52f23424492/go.mod h1:Ngi6UdF0k5OKD5t5wlmGhe/EDKPoUM3BXZSSfIuJbis=\ngithub.com/opentracing/basictracer-go v1.0.0/go.mod h1:QfBfYuafItcjQuMwinw9GhYKwFXS9KnPs5lxoYwgW74=\ngithub.com/opentracing/opentracing-go v1.0.2/go.mod h1:UkNAQd3GIcIGf0SeVgPpRdFStlNbqXla1AfSYxPUl2o=\ngithub.com/opentracing/opentracing-go v1.1.0/go.mod h1:UkNAQd3GIcIGf0SeVgPpRdFStlNbqXla1AfSYxPUl2o=\ngithub.com/openzipkin-contrib/zipkin-go-opentracing v0.4.5/go.mod h1:/wsWhb9smxSfWAKL3wpBW7V8scJMt8N8gnaMCS9E/cA=\ngithub.com/openzipkin/zipkin-go v0.1.6/go.mod h1:QgAqvLzwWbR/WpD4A3cGpPtJrZXNIiJc5AZX7/PBEpw=\ngithub.com/openzipkin/zipkin-go v0.2.1/go.mod h1:NaW6tEwdmWMaCDZzg8sh+IBNOxHMPnhQw8ySjnjRyN4=\ngithub.com/openzipkin/zipkin-go v0.2.2/go.mod h1:NaW6tEwdmWMaCDZzg8sh+IBNOxHMPnhQw8ySjnjRyN4=\ngithub.com/opsgenie/opsgenie-go-sdk-v2 v1.0.5 h1:AnS8ZCC5dle8P4X4FZ+IOlX9v0jAkCMiZDIzRnYwBbs=\ngithub.com/opsgenie/opsgenie-go-sdk-v2 v1.0.5/go.mod h1:f0ezb0R/mrB9Hpm5RrIS6EX3ydjsR2nAB88nYYXZcNY=\ngithub.com/pact-foundation/pact-go v1.0.4/go.mod h1:uExwJY4kCzNPcHRj+hCR/HBbOOIwwtUjcrb0b5/5kLM=\ngithub.com/pascaldekloe/goe v0.0.0-20180627143212-57f6aae5913c/go.mod h1:lzWF7FIEvWOWxwDKqyGYQf6ZUaNfKdP144TG7ZOy1lc=\ngithub.com/patrickmn/go-cache v2.1.0+incompatible h1:HRMgzkcYKYpi3C8ajMPV8OFXaaRUnok+kx1WdO15EQc=\ngithub.com/patrickmn/go-cache v2.1.0+incompatible/go.mod h1:3Qf8kWWT7OJRJbdiICTKqZju1ZixQ/KpMGzzAfe6+WQ=\ngithub.com/pborman/uuid v1.2.0/go.mod h1:X/NO0urCmaxf9VXbdlT7C2Yzkj2IKimNn4k+gtPdI/k=\ngithub.com/pelletier/go-toml v1.2.0/go.mod h1:5z9KED0ma1S8pY6P1sdut58dfprrGBbd/94hg7ilaic=\ngithub.com/pelletier/go-toml v1.9.3/go.mod h1:u1nR/EPcESfeI/szUZKdtJ0xRNbUoANCkoOuaOx1Y+c=\ngithub.com/performancecopilot/speed v3.0.0+incompatible/go.mod h1:/CLtqpZ5gBg1M9iaPbIdPPGyKcA8hKdoy6hAWba7Yac=\ngithub.com/peterbourgon/diskv v2.0.1+incompatible h1:UBdAOUP5p4RWqPBg048CAvpKN+vxiaj6gdUUzhl4XmI=\ngithub.com/peterbourgon/diskv v2.0.1+incompatible/go.mod h1:uqqh8zWWbv1HBMNONnaR/tNboyR3/BZd58JJSHlUSCU=\ngithub.com/pierrec/lz4 v1.0.2-0.20190131084431-473cd7ce01a1/go.mod h1:3/3N9NVKO0jef7pBehbT1qWhCMrIgbYNnFAZCqQ5LRc=\ngithub.com/pierrec/lz4 v2.0.5+incompatible/go.mod h1:pdkljMzZIN41W+lC3N2tnIh5sFi+IEE17M5jbnwPHcY=\ngithub.com/pkg/errors v0.8.0/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pkg/errors v0.8.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=\ngithub.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=\ngithub.com/pkg/profile v1.2.1/go.mod h1:hJw3o1OdXxsrSjjVksARp5W95eeEaEfptyVZyv6JUPA=\ngithub.com/pkg/sftp v1.10.1/go.mod h1:lYOWFsE0bwd1+KfKJaKeuokY15vzFx25BLbzYYoAxZI=\ngithub.com/pmezard/go-difflib v0.0.0-20151028094244-d8ed2627bdf0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=\ngithub.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=\ngithub.com/posener/complete v1.1.1/go.mod h1:em0nMJCgc9GFtwrmVmEMR/ZL6WyhyjMBndrE9hABlRI=\ngithub.com/pquerna/cachecontrol v0.0.0-20171018203845-0dec1b30a021/go.mod h1:prYjPmNq4d1NPVmpShWobRqXY3q7Vp+80DqgxxUrUIA=\ngithub.com/pquerna/cachecontrol v0.0.0-20180306154005-525d0eb5f91d h1:7gXyC293Lsm2YWgQ+0uaAFFFDO82ruiQSwc3ua+Vtlc=\ngithub.com/pquerna/cachecontrol v0.0.0-20180306154005-525d0eb5f91d/go.mod h1:prYjPmNq4d1NPVmpShWobRqXY3q7Vp+80DqgxxUrUIA=\ngithub.com/prometheus/client_golang v0.9.1/go.mod h1:7SWBe2y4D6OKWSNQJUaRYU/AaXPKyh/dDVn+NZz0KFw=\ngithub.com/prometheus/client_golang v0.9.3-0.20190127221311-3c4408c8b829/go.mod h1:p2iRAGwDERtqlqzRXnrOVns+ignqQo//hLXqYxZYVNs=\ngithub.com/prometheus/client_golang v0.9.3/go.mod h1:/TN21ttK/J9q6uSwhBd54HahCDft0ttaMvbicHlPoso=\ngithub.com/prometheus/client_golang v1.0.0/go.mod h1:db9x61etRT2tGnBNRi70OPL5FsnadC4Ky3P0J6CfImo=\ngithub.com/prometheus/client_golang v1.3.0/go.mod h1:hJaj2vgQTGQmVCsAACORcieXFeDPbaTKGT+JTgUa3og=\ngithub.com/prometheus/client_golang v1.7.1/go.mod h1:PY5Wy2awLA44sXw4AOSfFBetzPP4j5+D6mVACh+pe2M=\ngithub.com/prometheus/client_golang v1.11.0 h1:HNkLOAEQMIDv/K+04rukrLx6ch7msSRwf3/SASFAGtQ=\ngithub.com/prometheus/client_golang v1.11.0/go.mod h1:Z6t4BnS23TR94PD6BsDNk8yVqroYurpAkEiz0P2BEV0=\ngithub.com/prometheus/client_model v0.0.0-20180712105110-5c3871d89910/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=\ngithub.com/prometheus/client_model v0.0.0-20190115171406-56726106282f/go.mod h1:MbSGuTsp3dbXC40dX6PRTWyKYBIrTGTE9sqQNg2J8bo=\ngithub.com/prometheus/client_model v0.0.0-20190129233127-fd36f4220a90/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/client_model v0.1.0/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/client_model v0.2.0 h1:uq5h0d+GuxiXLJLNABMgp2qUWDPiLvgCzz2dUR+/W/M=\ngithub.com/prometheus/client_model v0.2.0/go.mod h1:xMI15A0UPsDsEKsMN9yxemIoYk6Tm2C1GtYGdfGttqA=\ngithub.com/prometheus/common v0.0.0-20181113130724-41aa239b4cce/go.mod h1:daVV7qP5qjZbuso7PdcryaAu0sAZbrN9i7WWcTMWvro=\ngithub.com/prometheus/common v0.2.0/go.mod h1:TNfzLD0ON7rHzMJeJkieUDPYmFC7Snx/y86RQel1bk4=\ngithub.com/prometheus/common v0.4.0/go.mod h1:TNfzLD0ON7rHzMJeJkieUDPYmFC7Snx/y86RQel1bk4=\ngithub.com/prometheus/common v0.4.1/go.mod h1:TNfzLD0ON7rHzMJeJkieUDPYmFC7Snx/y86RQel1bk4=\ngithub.com/prometheus/common v0.7.0/go.mod h1:DjGbpBbp5NYNiECxcL/VnbXCCaQpKd3tt26CguLLsqA=\ngithub.com/prometheus/common v0.10.0/go.mod h1:Tlit/dnDKsSWFlCLTWaA1cyBgKHSMdTB80sz/V91rCo=\ngithub.com/prometheus/common v0.26.0/go.mod h1:M7rCNAaPfAosfx8veZJCuw84e35h3Cfd9VFqTh1DIvc=\ngithub.com/prometheus/common v0.28.0 h1:vGVfV9KrDTvWt5boZO0I19g2E3CsWfpPPKZM9dt3mEw=\ngithub.com/prometheus/common v0.28.0/go.mod h1:vu+V0TpY+O6vW9J44gczi3Ap/oXXR10b+M/gUGO4Hls=\ngithub.com/prometheus/procfs v0.0.0-20181005140218-185b4288413d/go.mod h1:c3At6R/oaqEKCNdg8wHV1ftS6bRYblBhIjjI8uT2IGk=\ngithub.com/prometheus/procfs v0.0.0-20190117184657-bf6a532e95b1/go.mod h1:c3At6R/oaqEKCNdg8wHV1ftS6bRYblBhIjjI8uT2IGk=\ngithub.com/prometheus/procfs v0.0.0-20190507164030-5867b95ac084/go.mod h1:TjEm7ze935MbeOT/UhFTIMYKhuLP4wbCsTZCD3I8kEA=\ngithub.com/prometheus/procfs v0.0.0-20190522114515-bc1a522cf7b1/go.mod h1:TjEm7ze935MbeOT/UhFTIMYKhuLP4wbCsTZCD3I8kEA=\ngithub.com/prometheus/procfs v0.0.2/go.mod h1:TjEm7ze935MbeOT/UhFTIMYKhuLP4wbCsTZCD3I8kEA=\ngithub.com/prometheus/procfs v0.0.8/go.mod h1:7Qr8sr6344vo1JqZ6HhLceV9o3AJ1Ff+GxbHq6oeK9A=\ngithub.com/prometheus/procfs v0.1.3/go.mod h1:lV6e/gmhEcM9IjHGsFOCxxuZ+z1YqCvr4OA4YeYWdaU=\ngithub.com/prometheus/procfs v0.6.0 h1:mxy4L2jP6qMonqmq+aTtOx1ifVWUgG/TAmntgbh3xv4=\ngithub.com/prometheus/procfs v0.6.0/go.mod h1:cz+aTbrPOrUb4q7XlbU9ygM+/jj0fzG6c1xBZuNvfVA=\ngithub.com/prometheus/tsdb v0.7.1/go.mod h1:qhTCs0VvXwvX/y3TZrWD7rabWM+ijKTux40TwIPHuXU=\ngithub.com/quobyte/api v0.1.8/go.mod h1:jL7lIHrmqQ7yh05OJ+eEEdHr0u/kmT1Ff9iHd+4H6VI=\ngithub.com/r3labs/diff v1.1.0 h1:V53xhrbTHrWFWq3gI4b94AjgEJOerO1+1l0xyHOBi8M=\ngithub.com/r3labs/diff v1.1.0/go.mod h1:7WjXasNzi0vJetRcB/RqNl5dlIsmXcTTLmF5IoH6Xig=\ngithub.com/rcrowley/go-metrics v0.0.0-20181016184325-3113b8401b8a/go.mod h1:bCqnVzQkZxMG4s8nGwiZ5l3QUCyqpo9Y+/ZMZ9VjZe4=\ngithub.com/remyoudompheng/bigfft v0.0.0-20170806203942-52369c62f446/go.mod h1:uYEyJGbgTkfkS4+E/PavXkNJcbFIpEtjt2B0KDQ5+9M=\ngithub.com/rivo/tview v0.0.0-20200219210816-cd38d7432498/go.mod h1:6lkG1x+13OShEf0EaOCaTQYyB7d5nSbb181KtjlS+84=\ngithub.com/rivo/uniseg v0.1.0/go.mod h1:J6wj4VEh+S6ZtnVlnTBMWIodfgj8LQOQFoIToxlJtxc=\ngithub.com/robfig/cron v1.2.0 h1:ZjScXvvxeQ63Dbyxy76Fj3AT3Ut0aKsyd2/tl3DTMuQ=\ngithub.com/robfig/cron v1.2.0/go.mod h1:JGuDeoQd7Z6yL4zQhZ3OPEVHB7fL6Ka6skscFHfmt2k=\ngithub.com/robfig/cron/v3 v3.0.1/go.mod h1:eQICP3HwyT7UooqI/z+Ov+PtYAWygg1TEWWzGIFLtro=\ngithub.com/rogpeppe/fastuuid v1.2.0/go.mod h1:jVj6XXZzXRy/MSR5jhDC/2q6DgLz+nrA6LYCDYWNEvQ=\ngithub.com/rogpeppe/go-internal v1.1.0/go.mod h1:M8bDsm7K2OlrFYOpmOWEs/qY81heoFRclV5y23lUDJ4=\ngithub.com/rogpeppe/go-internal v1.3.0/go.mod h1:M8bDsm7K2OlrFYOpmOWEs/qY81heoFRclV5y23lUDJ4=\ngithub.com/rs/cors v1.8.0 h1:P2KMzcFwrPoSjkF1WLRPsp3UMLyql8L4v9hQpVeK5so=\ngithub.com/rs/cors v1.8.0/go.mod h1:EBwu+T5AvHOcXwvZIkQFjUN6s8Czyqw12GL/Y0tUyRM=\ngithub.com/rs/xid v1.2.1/go.mod h1:+uKXf+4Djp6Md1KODXJxgGQPKngRmWyn10oCKFzNHOQ=\ngithub.com/rs/zerolog v1.21.0/go.mod h1:ZPhntP/xmq1nnND05hhpAh2QMhSsA4UN3MGZ6O2J3hM=\ngithub.com/rubiojr/go-vhd v0.0.0-20200706105327-02e210299021/go.mod h1:DM5xW0nvfNNm2uytzsvhI3OnX8uzaRAg8UX/CnDqbto=\ngithub.com/russross/blackfriday v1.5.2 h1:HyvC0ARfnZBqnXwABFeSZHpKvJHJJfPz81GNueLj0oo=\ngithub.com/russross/blackfriday v1.5.2/go.mod h1:JO/DiYxRf+HjHt06OyowR9PTA263kcR/rfWxYHBV53g=\ngithub.com/russross/blackfriday/v2 v2.0.1 h1:lPqVAte+HuHNfhJ/0LC98ESWRz8afy9tM/0RK8m9o+Q=\ngithub.com/russross/blackfriday/v2 v2.0.1/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=\ngithub.com/ryanuber/columnize v0.0.0-20160712163229-9b3edd62028f/go.mod h1:sm1tb6uqfes/u+d4ooFouqFdy9/2g9QGwK3SQygK0Ts=\ngithub.com/samuel/go-zookeeper v0.0.0-20190923202752-2cc03de413da/go.mod h1:gi+0XIa01GRL2eRQVjQkKGqKF3SF9vZR/HnPullcV2E=\ngithub.com/sanity-io/litter v1.2.0/go.mod h1:JF6pZUFgu2Q0sBZ+HSV35P8TVPI1TTzEwyu9FXAw2W4=\ngithub.com/sean-/seed v0.0.0-20170313163322-e2103e2c3529/go.mod h1:DxrIzT+xaE7yg65j358z/aeFdxmN0P9QXhEzd20vsDc=\ngithub.com/seccomp/libseccomp-golang v0.9.1/go.mod h1:GbW5+tmTXfcxTToHLXlScSlAvWlF4P2Ca7zGrPiEpWo=\ngithub.com/sergi/go-diff v1.0.0/go.mod h1:0CfEIISq7TuYL3j771MWULgwwjU+GofnZX9QAmXWZgo=\ngithub.com/sergi/go-diff v1.1.0 h1:we8PVUC3FE2uYfodKH/nBHMSetSfHDR6scGdBi+erh0=\ngithub.com/sergi/go-diff v1.1.0/go.mod h1:STckp+ISIX8hZLjrqAeVduY0gWCT9IjLuqbuNXdaHfM=\ngithub.com/shurcooL/sanitized_anchor_name v1.0.0 h1:PdmoCO6wvbs+7yrJyMORt4/BmY5IYyJwS/kOiWx8mHo=\ngithub.com/shurcooL/sanitized_anchor_name v1.0.0/go.mod h1:1NzhyTcUVG4SuEtjjoZeVRXNmyL/1OwPU0+IJeTBvfc=\ngithub.com/sirupsen/logrus v1.2.0/go.mod h1:LxeOpSwHxABJmUn/MG1IvRgCAasNZTLOkJPxbbu5VWo=\ngithub.com/sirupsen/logrus v1.4.1/go.mod h1:ni0Sbl8bgC9z8RoU9G6nDWqqs/fq4eDPysMBDgk/93Q=\ngithub.com/sirupsen/logrus v1.4.2/go.mod h1:tLMulIdttU9McNUspp0xgXVQah82FyeX6MwdIuYE2rE=\ngithub.com/sirupsen/logrus v1.6.0/go.mod h1:7uNnSEd1DgxDLC74fIahvMZmmYsHGZGEOFrfsX/uA88=\ngithub.com/sirupsen/logrus v1.7.0/go.mod h1:yWOB1SBYBC5VeMP7gHvWumXLIWorT60ONWic61uBYv0=\ngithub.com/sirupsen/logrus v1.8.1 h1:dJKuHgqk1NNQlqoA6BTlM1Wf9DOH3NBjQyu0h9+AZZE=\ngithub.com/sirupsen/logrus v1.8.1/go.mod h1:yWOB1SBYBC5VeMP7gHvWumXLIWorT60ONWic61uBYv0=\ngithub.com/skratchdot/open-golang v0.0.0-20160302144031-75fb7ed4208c h1:fyKiXKO1/I/B6Y2U8T7WdQGWzwehOuGIrljPtt7YTTI=\ngithub.com/skratchdot/open-golang v0.0.0-20160302144031-75fb7ed4208c/go.mod h1:sUM3LWHvSMaG192sy56D9F7CNvL7jUJVXoqM1QKLnog=\ngithub.com/slack-go/slack v0.10.1 h1:BGbxa0kMsGEvLOEoZmYs8T1wWfoZXwmQFBb6FgYCXUA=\ngithub.com/slack-go/slack v0.10.1/go.mod h1:wWL//kk0ho+FcQXcBTmEafUI5dz4qz5f4mMk8oIkioQ=\ngithub.com/smartystreets/assertions v0.0.0-20180927180507-b2de0cb4f26d/go.mod h1:OnSkiWE9lh6wB0YB77sQom3nweQdgAjqCqsofrRNTgc=\ngithub.com/smartystreets/assertions v1.1.0/go.mod h1:tcbTF8ujkAEcZ8TElKY+i30BzYlVhC/LOxJk7iOWnoo=\ngithub.com/smartystreets/goconvey v0.0.0-20190330032615-68dc04aab96a/go.mod h1:syvi0/a8iFYH4r/RixwvyeAJjdLS9QV7WQ/tjFTllLA=\ngithub.com/smartystreets/goconvey v0.0.0-20190731233626-505e41936337/go.mod h1:syvi0/a8iFYH4r/RixwvyeAJjdLS9QV7WQ/tjFTllLA=\ngithub.com/smartystreets/goconvey v1.6.4/go.mod h1:syvi0/a8iFYH4r/RixwvyeAJjdLS9QV7WQ/tjFTllLA=\ngithub.com/soheilhy/cmux v0.1.4/go.mod h1:IM3LyeVVIOuxMH7sFAkER9+bJ4dT7Ms6E4xg4kGIyLM=\ngithub.com/soheilhy/cmux v0.1.5 h1:jjzc5WVemNEDTLwv9tlmemhC73tI08BNOIGwBOo10Js=\ngithub.com/soheilhy/cmux v0.1.5/go.mod h1:T7TcVDs9LWfQgPlPsdngu6I6QIoyIFZDDC6sNE1GqG0=\ngithub.com/sony/gobreaker v0.4.1/go.mod h1:ZKptC7FHNvhBz7dN2LGjPVBz2sZJmc0/PkyDJOjmxWY=\ngithub.com/sony/sonyflake v1.0.0 h1:MpU6Ro7tfXwgn2l5eluf9xQvQJDROTBImNCfRXn/YeM=\ngithub.com/sony/sonyflake v1.0.0/go.mod h1:Jv3cfhf/UFtolOTTRd3q4Nl6ENqM+KfyZ5PseKfZGF4=\ngithub.com/spaolacci/murmur3 v0.0.0-20180118202830-f09979ecbc72/go.mod h1:JwIasOWyU6f++ZhiEuf87xNszmSA2myDM2Kzu9HwQUA=\ngithub.com/spf13/afero v1.1.2/go.mod h1:j4pytiNVoe2o6bmDsKpLACNPDBIoEAkihy7loJ1B0CQ=\ngithub.com/spf13/afero v1.2.2/go.mod h1:9ZxEEn6pIJ8Rxe320qSDBk6AsU0r9pR7Q4OcevTdifk=\ngithub.com/spf13/afero v1.6.0/go.mod h1:Ai8FlHk4v/PARR026UzYexafAt9roJ7LcLMAmO6Z93I=\ngithub.com/spf13/cast v1.3.0/go.mod h1:Qx5cxh0v+4UWYiBimWS+eyWzqEqokIECu5etghLkUJE=\ngithub.com/spf13/cast v1.3.1/go.mod h1:Qx5cxh0v+4UWYiBimWS+eyWzqEqokIECu5etghLkUJE=\ngithub.com/spf13/cobra v0.0.3/go.mod h1:1l0Ry5zgKvJasoi3XT1TypsSe7PqH0Sj9dhYf7v3XqQ=\ngithub.com/spf13/cobra v1.0.0/go.mod h1:/6GTrnGXV9HjY+aR4k0oJ5tcvakLuG6EuKReYlHNrgE=\ngithub.com/spf13/cobra v1.1.3/go.mod h1:pGADOWyqRD/YMrPZigI/zbliZ2wVD/23d+is3pSWzOo=\ngithub.com/spf13/cobra v1.2.1 h1:+KmjbUw1hriSNMF55oPrkZcb27aECyrj8V2ytv7kWDw=\ngithub.com/spf13/cobra v1.2.1/go.mod h1:ExllRjgxM/piMAM+3tAZvg8fsklGAf3tPfi+i8t68Nk=\ngithub.com/spf13/jwalterweatherman v1.0.0/go.mod h1:cQK4TGJAtQXfYWX+Ddv3mKDzgVb68N+wFjFa4jdeBTo=\ngithub.com/spf13/jwalterweatherman v1.1.0/go.mod h1:aNWZUN0dPAAO/Ljvb5BEdw96iTZ0EXowPYD95IqWIGo=\ngithub.com/spf13/pflag v0.0.0-20170130214245-9ff6c6923cff/go.mod h1:DYY7MBk1bdzusC3SYhjObp+wFpr4gzcvqqNjLnInEg4=\ngithub.com/spf13/pflag v1.0.1/go.mod h1:DYY7MBk1bdzusC3SYhjObp+wFpr4gzcvqqNjLnInEg4=\ngithub.com/spf13/pflag v1.0.3/go.mod h1:DYY7MBk1bdzusC3SYhjObp+wFpr4gzcvqqNjLnInEg4=\ngithub.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=\ngithub.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=\ngithub.com/spf13/viper v1.4.0/go.mod h1:PTJ7Z/lr49W6bUbkmS1V3by4uWynFiR9p7+dSq/yZzE=\ngithub.com/spf13/viper v1.7.0/go.mod h1:8WkrPz2fc9jxqZNCJI/76HCieCp4Q8HaLFoCha5qpdg=\ngithub.com/spf13/viper v1.8.1/go.mod h1:o0Pch8wJ9BVSWGQMbra6iw0oQ5oktSIBaujf1rJH9Ns=\ngithub.com/ssor/bom v0.0.0-20170718123548-6386211fdfcf/go.mod h1:RJID2RhlZKId02nZ62WenDCkgHFerpIOmW0iT7GKmXM=\ngithub.com/stoewer/go-strcase v1.2.0/go.mod h1:IBiWB2sKIp3wVVQ3Y035++gc+knqhUQag1KpM8ahLw8=\ngithub.com/storageos/go-api v2.2.0+incompatible/go.mod h1:ZrLn+e0ZuF3Y65PNF6dIwbJPZqfmtCXxFm9ckv0agOY=\ngithub.com/streadway/amqp v0.0.0-20190404075320-75d898a42a94/go.mod h1:AZpEONHx3DKn8O/DFsRAY58/XVQiIPMTMB1SddzLXVw=\ngithub.com/streadway/amqp v0.0.0-20190827072141-edfb9018d271/go.mod h1:AZpEONHx3DKn8O/DFsRAY58/XVQiIPMTMB1SddzLXVw=\ngithub.com/streadway/handy v0.0.0-20190108123426-d5acb3125c2a/go.mod h1:qNTQ5P5JnDBl6z3cMAg/SywNDC5ABu5ApDIw6lUbRmI=\ngithub.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.1.1/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=\ngithub.com/stretchr/objx v0.2.0 h1:Hbg2NidpLE8veEBkEZTL3CvlkUIVzuU9jDplZO54c48=\ngithub.com/stretchr/objx v0.2.0/go.mod h1:qt09Ya8vawLte6SNmTgCsAVtYtaKzEcn8ATUoHMkEqE=\ngithub.com/stretchr/testify v0.0.0-20161117074351-18a02ba4a312/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=\ngithub.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=\ngithub.com/stretchr/testify v1.4.0/go.mod h1:j7eGeouHqKxXV5pUuKE4zz7dFj8WfuZ+81PSLYec5m4=\ngithub.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=\ngithub.com/stretchr/testify v1.6.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/stretchr/testify v1.7.0 h1:nwc3DEeHmmLAfoZucVR881uASk0Mfjw8xYJ99tb5CcY=\ngithub.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=\ngithub.com/subosito/gotenv v1.2.0/go.mod h1:N0PQaV/YGNqwC0u51sEeR/aUtSLEXKX9iv69rRypqCw=\ngithub.com/syndtr/gocapability v0.0.0-20200815063812-42c35b437635/go.mod h1:hkRG7XYTFWNJGYcbNJQlaLq0fg1yr4J4t/NcTQtrfww=\ngithub.com/tidwall/pretty v1.0.0 h1:HsD+QiTn7sK6flMKIvNmpqz1qrpP3Ps6jOKIKMooyg4=\ngithub.com/tidwall/pretty v1.0.0/go.mod h1:XNkn88O1ChpSDQmQeStsy+sBenx6DDtFZJxhVysOjyk=\ngithub.com/tmc/grpc-websocket-proxy v0.0.0-20170815181823-89b8d40f7ca8/go.mod h1:ncp9v5uamzpCO7NfCPTXjqaC+bZgJeR0sMTm6dMHP7U=\ngithub.com/tmc/grpc-websocket-proxy v0.0.0-20190109142713-0ad062ec5ee5/go.mod h1:ncp9v5uamzpCO7NfCPTXjqaC+bZgJeR0sMTm6dMHP7U=\ngithub.com/tmc/grpc-websocket-proxy v0.0.0-20201229170055-e5319fda7802/go.mod h1:ncp9v5uamzpCO7NfCPTXjqaC+bZgJeR0sMTm6dMHP7U=\ngithub.com/ugorji/go v1.1.4/go.mod h1:uQMGLiO92mf5W77hV/PUCpI3pbzQx3CRekS0kk+RGrc=\ngithub.com/ugorji/go v1.1.7/go.mod h1:kZn38zHttfInRq0xu/PH0az30d+z6vm202qpg1oXVMw=\ngithub.com/ugorji/go/codec v1.1.7/go.mod h1:Ax+UKWsSmolVDwsd+7N3ZtXu+yMGCf907BLYF3GoBXY=\ngithub.com/undefinedlabs/go-mpatch v1.0.6 h1:h8q5ORH/GaOE1Se1DMhrOyljXZEhRcROO7agMqWXCOY=\ngithub.com/undefinedlabs/go-mpatch v1.0.6/go.mod h1:TyJZDQ/5AgyN7FSLiBJ8RO9u2c6wbtRvK827b6AVqY4=\ngithub.com/urfave/cli v1.20.0/go.mod h1:70zkFmudgCuE/ngEzBv17Jvp/497gISqfk5gWijbERA=\ngithub.com/urfave/cli v1.22.1/go.mod h1:Gos4lmkARVdJ6EkW0WaNv/tZAAMe9V7XWyB60NtXRu0=\ngithub.com/urfave/cli v1.22.2/go.mod h1:Gos4lmkARVdJ6EkW0WaNv/tZAAMe9V7XWyB60NtXRu0=\ngithub.com/urfave/negroni v1.0.0/go.mod h1:Meg73S6kFm/4PpbYdq35yYWoCZ9mS/YSx+lKnmiohz4=\ngithub.com/vektah/gqlparser v1.1.2/go.mod h1:1ycwN7Ij5njmMkPPAOaRFY4rET2Enx7IkVv3vaXspKw=\ngithub.com/vishvananda/netlink v1.1.0/go.mod h1:cTgwzPIzzgDAYoQrMm0EdrjRUBkTqKYppBueQtXaqoE=\ngithub.com/vishvananda/netns v0.0.0-20191106174202-0a2b9b5464df/go.mod h1:JP3t17pCcGlemwknint6hfoeCVQrEMVwxRLRjXpq+BU=\ngithub.com/vishvananda/netns v0.0.0-20200728191858-db3c7e526aae/go.mod h1:DD4vA1DwXk04H54A1oHXtwZmA0grkVMdPxx/VGLCah0=\ngithub.com/vmihailenco/go-tinylfu v0.2.1 h1:78/wH+STtgM8+fN2GdjvvKoxF3mkdzoOoKQTchQRj+g=\ngithub.com/vmihailenco/go-tinylfu v0.2.1/go.mod h1:CutYi2Q9puTxfcolkliPq4npPuofg9N9t8JVrjzwa3Q=\ngithub.com/vmihailenco/msgpack/v5 v5.3.4 h1:qMKAwOV+meBw2Y8k9cVwAy7qErtYCwBzZ2ellBfvnqc=\ngithub.com/vmihailenco/msgpack/v5 v5.3.4/go.mod h1:7xyJ9e+0+9SaZT0Wt1RGleJXzli6Q/V5KbhBonMG9jc=\ngithub.com/vmihailenco/tagparser/v2 v2.0.0 h1:y09buUbR+b5aycVFQs/g70pqKVZNBmxwAhO7/IwNM9g=\ngithub.com/vmihailenco/tagparser/v2 v2.0.0/go.mod h1:Wri+At7QHww0WTrCBeu4J6bNtoV6mEfg5OIWRZA9qds=\ngithub.com/vmware/govmomi v0.20.3/go.mod h1:URlwyTFZX72RmxtxuaFL2Uj3fD1JTvZdx59bHWk6aFU=\ngithub.com/whilp/git-urls v0.0.0-20191001220047-6db9661140c0 h1:qqllXPzXh+So+mmANlX/gCJrgo+1kQyshMoQ+NASzm0=\ngithub.com/whilp/git-urls v0.0.0-20191001220047-6db9661140c0/go.mod h1:2rx5KE5FLD0HRfkkpyn8JwbVLBdhgeiOb2D2D9LLKM4=\ngithub.com/xanzy/ssh-agent v0.3.0 h1:wUMzuKtKilRgBAD1sUb8gOwwRr2FGoBVumcjoOACClI=\ngithub.com/xanzy/ssh-agent v0.3.0/go.mod h1:3s9xbODqPuuhK9JV1R321M/FlMZSBvE5aY6eAcqrDh0=\ngithub.com/xiang90/probing v0.0.0-20190116061207-43a291ad63a2/go.mod h1:UETIi67q53MR2AWcXfiuqkDkRtnGDLqkBTpCHuJHxtU=\ngithub.com/xlab/treeprint v0.0.0-20181112141820-a009c3971eca h1:1CFlNzQhALwjS9mBAUkycX616GzgsuYUOCHA5+HSlXI=\ngithub.com/xlab/treeprint v0.0.0-20181112141820-a009c3971eca/go.mod h1:ce1O1j6UtZfjr22oyGxGLbauSBp2YVXpARAosm7dHBg=\ngithub.com/xordataexchange/crypt v0.0.3-0.20170626215501-b2862e3d0a77/go.mod h1:aYKd//L2LvnjZzWKhF00oedf4jCCReLcmhLdhm1A27Q=\ngithub.com/yuin/goldmark v1.1.25/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.1.32/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=\ngithub.com/yuin/goldmark v1.3.5/go.mod h1:mwnBkeHKe2W/ZEtQ+71ViKU8L12m81fl3OWwC1Zlc8k=\ngithub.com/yuin/goldmark v1.4.0/go.mod h1:mwnBkeHKe2W/ZEtQ+71ViKU8L12m81fl3OWwC1Zlc8k=\ngithub.com/yuin/gopher-lua v0.0.0-20200816102855-ee81675732da h1:NimzV1aGyq29m5ukMK0AMWEhFaL/lrEOaephfuoiARg=\ngithub.com/yuin/gopher-lua v0.0.0-20200816102855-ee81675732da/go.mod h1:E1AXubJBdNmFERAOucpDIxNzeGfLzg0mYh+UfMWdChA=\ngo.etcd.io/bbolt v1.3.2/go.mod h1:IbVyRI1SCnLcuJnV2u8VeU0CEYM7e686BmAb1XKL+uU=\ngo.etcd.io/bbolt v1.3.3/go.mod h1:IbVyRI1SCnLcuJnV2u8VeU0CEYM7e686BmAb1XKL+uU=\ngo.etcd.io/bbolt v1.3.6/go.mod h1:qXsaaIqmgQH0T+OPdb99Bf+PKfBBQVAdyD6TY9G8XM4=\ngo.etcd.io/etcd v0.0.0-20191023171146-3cf2f69b5738/go.mod h1:dnLIgRNXwCJa5e+c6mIZCrds/GIG4ncV9HhK5PX7jPg=\ngo.etcd.io/etcd/api/v3 v3.5.0/go.mod h1:cbVKeC6lCfl7j/8jBhAK6aIYO9XOjdptoxU/nLQcPvs=\ngo.etcd.io/etcd/client/pkg/v3 v3.5.0/go.mod h1:IJHfcCEKxYu1Os13ZdwCwIUTUVGYTSAM3YSwc9/Ac1g=\ngo.etcd.io/etcd/client/v2 v2.305.0/go.mod h1:h9puh54ZTgAKtEbut2oe9P4L/oqKCVB6xsXlzd7alYQ=\ngo.etcd.io/etcd/client/v3 v3.5.0/go.mod h1:AIKXXVX/DQXtfTEqBryiLTUXwON+GuvO6Z7lLS/oTh0=\ngo.etcd.io/etcd/pkg/v3 v3.5.0/go.mod h1:UzJGatBQ1lXChBkQF0AuAtkRQMYnHubxAEYIrC3MSsE=\ngo.etcd.io/etcd/raft/v3 v3.5.0/go.mod h1:UFOHSIvO/nKwd4lhkwabrTD3cqW5yVyYYf/KlD00Szc=\ngo.etcd.io/etcd/server/v3 v3.5.0/go.mod h1:3Ah5ruV+M+7RZr0+Y/5mNLwC+eQlni+mQmOVdCRJoS4=\ngo.mongodb.org/mongo-driver v1.0.3/go.mod h1:u7ryQJ+DOzQmeO7zB6MHyr8jkEQvC8vH7qLUO4lqsUM=\ngo.mongodb.org/mongo-driver v1.1.1/go.mod h1:u7ryQJ+DOzQmeO7zB6MHyr8jkEQvC8vH7qLUO4lqsUM=\ngo.mongodb.org/mongo-driver v1.1.2 h1:jxcFYjlkl8xaERsgLo+RNquI0epW6zuy/ZRQs6jnrFA=\ngo.mongodb.org/mongo-driver v1.1.2/go.mod h1:u7ryQJ+DOzQmeO7zB6MHyr8jkEQvC8vH7qLUO4lqsUM=\ngo.opencensus.io v0.20.1/go.mod h1:6WKK9ahsWS3RSO+PY9ZHZUfv2irvY6gN279GOPZjmmk=\ngo.opencensus.io v0.20.2/go.mod h1:6WKK9ahsWS3RSO+PY9ZHZUfv2irvY6gN279GOPZjmmk=\ngo.opencensus.io v0.21.0/go.mod h1:mSImk1erAIZhrmZN+AvHh14ztQfjbGwt4TtuofqLduU=\ngo.opencensus.io v0.22.0/go.mod h1:+kGneAE2xo2IficOXnaByMWTGM9T73dGwxeWcUqIpI8=\ngo.opencensus.io v0.22.2/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=\ngo.opencensus.io v0.22.3/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=\ngo.opencensus.io v0.22.4/go.mod h1:yxeiOL68Rb0Xd1ddK5vPZ/oVn4vY4Ynel7k9FzqtOIw=\ngo.opencensus.io v0.22.5/go.mod h1:5pWMHQbX5EPX2/62yrJeAkowc+lfs/XD7Uxpq3pI6kk=\ngo.opencensus.io v0.23.0/go.mod h1:XItmlyltB5F7CS4xOC1DcqMoFqwtC6OG2xF7mCv7P7E=\ngo.opentelemetry.io/contrib v0.20.0/go.mod h1:G/EtFaa6qaN7+LxqfIAT3GiZa7Wv5DTBUzl5H4LY0Kc=\ngo.opentelemetry.io/contrib/instrumentation/google.golang.org/grpc/otelgrpc v0.20.0/go.mod h1:oVGt1LRbBOBq1A5BQLlUg9UaU/54aiHw8cgjV3aWZ/E=\ngo.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.20.0/go.mod h1:2AboqHi0CiIZU0qwhtUfCYD1GeUzvvIXWNkhDt7ZMG4=\ngo.opentelemetry.io/otel v0.20.0/go.mod h1:Y3ugLH2oa81t5QO+Lty+zXf8zC9L26ax4Nzoxm/dooo=\ngo.opentelemetry.io/otel/exporters/otlp v0.20.0/go.mod h1:YIieizyaN77rtLJra0buKiNBOm9XQfkPEKBeuhoMwAM=\ngo.opentelemetry.io/otel/metric v0.20.0/go.mod h1:598I5tYlH1vzBjn+BTuhzTCSb/9debfNp6R3s7Pr1eU=\ngo.opentelemetry.io/otel/oteltest v0.20.0/go.mod h1:L7bgKf9ZB7qCwT9Up7i9/pn0PWIa9FqQ2IQ8LoxiGnw=\ngo.opentelemetry.io/otel/sdk v0.20.0/go.mod h1:g/IcepuwNsoiX5Byy2nNV0ySUF1em498m7hBWC279Yc=\ngo.opentelemetry.io/otel/sdk/export/metric v0.20.0/go.mod h1:h7RBNMsDJ5pmI1zExLi+bJK+Dr8NQCh0qGhm1KDnNlE=\ngo.opentelemetry.io/otel/sdk/metric v0.20.0/go.mod h1:knxiS8Xd4E/N+ZqKmUPf3gTTZ4/0TjTXukfxjzSTpHE=\ngo.opentelemetry.io/otel/trace v0.20.0/go.mod h1:6GjCW8zgDjwGHGa6GkyeB8+/5vjT16gUEi0Nf1iBdgw=\ngo.opentelemetry.io/proto/otlp v0.7.0/go.mod h1:PqfVotwruBrMGOCsRd/89rSnXhoiJIqeYNgFYFoEGnI=\ngo.starlark.net v0.0.0-20200306205701-8dd3e2ee1dd5 h1:+FNtrFTmVw0YZGpBGX56XDee331t6JAXeK2bcyhLOOc=\ngo.starlark.net v0.0.0-20200306205701-8dd3e2ee1dd5/go.mod h1:nmDLcffg48OtT/PSW0Hg7FvpRQsQh5OSqIylirxKC7o=\ngo.uber.org/atomic v1.3.2/go.mod h1:gD2HeocX3+yG+ygLZcrzQJaqmWj9AIm7n08wl/qW/PE=\ngo.uber.org/atomic v1.4.0/go.mod h1:gD2HeocX3+yG+ygLZcrzQJaqmWj9AIm7n08wl/qW/PE=\ngo.uber.org/atomic v1.5.0/go.mod h1:sABNBOSYdrvTF6hTgEIbc7YasKWGhgEQZyfxyTvoXHQ=\ngo.uber.org/atomic v1.6.0/go.mod h1:sABNBOSYdrvTF6hTgEIbc7YasKWGhgEQZyfxyTvoXHQ=\ngo.uber.org/atomic v1.7.0 h1:ADUqmZGgLDDfbSL9ZmPxKTybcoEYHgpYfELNoN+7hsw=\ngo.uber.org/atomic v1.7.0/go.mod h1:fEN4uk6kAWBTFdckzkM89CLk9XfWZrxpCo0nPH17wJc=\ngo.uber.org/goleak v1.1.10/go.mod h1:8a7PlsEVH3e/a/GLqe5IIrQx6GzcnRmZEufDUTk4A7A=\ngo.uber.org/goleak v1.1.11-0.20210813005559-691160354723/go.mod h1:cwTWslyiVhfpKIDGSZEM2HlOvcqm+tG4zioyIeLoqMQ=\ngo.uber.org/goleak v1.1.12/go.mod h1:cwTWslyiVhfpKIDGSZEM2HlOvcqm+tG4zioyIeLoqMQ=\ngo.uber.org/multierr v1.1.0/go.mod h1:wR5kodmAFQ0UK8QlbwjlSNy0Z68gJhDJUG5sjR94q/0=\ngo.uber.org/multierr v1.3.0/go.mod h1:VgVr7evmIr6uPjLBxg28wmKNXyqE9akIJ5XnfpiKl+4=\ngo.uber.org/multierr v1.5.0/go.mod h1:FeouvMocqHpRaaGuG9EjoKcStLC43Zu/fmqdUMPcKYU=\ngo.uber.org/multierr v1.6.0 h1:y6IPFStTAIT5Ytl7/XYmHvzXQ7S3g/IeZW9hyZ5thw4=\ngo.uber.org/multierr v1.6.0/go.mod h1:cdWPpRnG4AhwMwsgIHip0KRBQjJy5kYEpYjJxpXp9iU=\ngo.uber.org/tools v0.0.0-20190618225709-2cfd321de3ee/go.mod h1:vJERXedbb3MVM5f9Ejo0C68/HhF8uaILCdgjnY+goOA=\ngo.uber.org/zap v1.10.0/go.mod h1:vwi/ZaCAaUcBkycHslxD9B2zi4UTXhF60s6SWpuDF0Q=\ngo.uber.org/zap v1.13.0/go.mod h1:zwrFLgMcdUuIBviXEYEH1YKNaOBnKXsx2IPda5bBwHM=\ngo.uber.org/zap v1.16.0/go.mod h1:MA8QOfq0BHJwdXa996Y4dYkAqRKB8/1K1QMMZVaNZjQ=\ngo.uber.org/zap v1.17.0/go.mod h1:MXVU+bhUf/A7Xi2HNOnopQOrmycQ5Ih87HtOu4q5SSo=\ngo.uber.org/zap v1.19.0/go.mod h1:xg/QME4nWcxGxrpdeYfq7UvYrLh66cuVKdrbD1XF/NI=\ngo.uber.org/zap v1.19.1 h1:ue41HOKd1vGURxrmeKIgELGb3jPW9DMUDGtsinblHwI=\ngo.uber.org/zap v1.19.1/go.mod h1:j3DNczoxDZroyBnOT1L/Q79cfUMGZxlv/9dzN7SM1rI=\ngolang.org/x/crypto v0.0.0-20180904163835-0709b304e793/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20181029021203-45a5f77698d3/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20181030102418-4d3f4d9ffa16/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20190211182817-74369b46fc67/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20190219172222-a4c6cb3142f2/go.mod h1:6SG95UA2DQfeDnfUPMdvaQW0Q7yPrPDi9nlGo2tz2b4=\ngolang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20190320223903-b7391e95e576/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=\ngolang.org/x/crypto v0.0.0-20190422183909-d864b10871cd/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20190510104115-cbcb75029529/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20190513172903-22d7a77e9e5f/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20190605123033-f99c8df09eb5/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20190611184440-5c40567a22f8/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20190617133340-57b3e21c3d56/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20190701094942-4def268fd1a4/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20190820162420-60c769a6c586/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=\ngolang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.0.0-20201002170205-7f63de1d35b0/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=\ngolang.org/x/crypto v0.0.0-20210322153248-0c34fe9e7dc2/go.mod h1:T9bdIzuCu7OtxOm1hfPfRQxPLYneinmdGuTeoZ9dtd4=\ngolang.org/x/crypto v0.0.0-20210421170649-83a5a9bb288b/go.mod h1:T9bdIzuCu7OtxOm1hfPfRQxPLYneinmdGuTeoZ9dtd4=\ngolang.org/x/crypto v0.0.0-20210817164053-32db794688a5 h1:HWj/xjIHfjYU5nVXpTM0s39J9CbLn7Cc5a7IC5rwsMQ=\ngolang.org/x/crypto v0.0.0-20210817164053-32db794688a5/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=\ngolang.org/x/exp v0.0.0-20180321215751-8460e604b9de/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20180807140117-3d87b88a115f/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20190121172915-509febef88a4/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20190125153040-c74c464bbbf2/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20190306152737-a1d7652674e8/go.mod h1:CJ0aWSM057203Lf6IL+f9T1iT9GByDxfZKAQTCR3kQA=\ngolang.org/x/exp v0.0.0-20190312203227-4b39c73a6495/go.mod h1:ZjyILWgesfNpC6sMxTJOJm9Kp84zZh5NQWvqDGG3Qr8=\ngolang.org/x/exp v0.0.0-20190510132918-efd6b22b2522/go.mod h1:ZjyILWgesfNpC6sMxTJOJm9Kp84zZh5NQWvqDGG3Qr8=\ngolang.org/x/exp v0.0.0-20190731235908-ec7cb31e5a56/go.mod h1:JhuoJpWY28nO4Vef9tZUw9qufEGTyX1+7lmHxV5q5G4=\ngolang.org/x/exp v0.0.0-20190829153037-c13cbed26979/go.mod h1:86+5VVa7VpoJ4kLfm080zCjGlMRFzhUhsZKEZO7MGek=\ngolang.org/x/exp v0.0.0-20191030013958-a1ab85dbe136/go.mod h1:JXzH8nQsPlswgeRAPE3MuO9GYsAcnJvJ4vnMwN/5qkY=\ngolang.org/x/exp v0.0.0-20191129062945-2f5052295587/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=\ngolang.org/x/exp v0.0.0-20191227195350-da58074b4299/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=\ngolang.org/x/exp v0.0.0-20200119233911-0405dc783f0a/go.mod h1:2RIsYlXP63K8oxa1u096TMicItID8zy7Y6sNkU49FU4=\ngolang.org/x/exp v0.0.0-20200207192155-f17229e696bd/go.mod h1:J/WKrq2StrnmMY6+EHIKF9dgMWnmCNThgcyBT1FY9mM=\ngolang.org/x/exp v0.0.0-20200224162631-6cc2880d07d6/go.mod h1:3jZMyOhIsHpP37uCMkUooju7aAi5cS1Q23tOzKc+0MU=\ngolang.org/x/exp v0.0.0-20210220032938-85be41e4509f/go.mod h1:I6l2HNBLBZEcrOoCpyKLdY2lHoRZ8lI4x60KMCQDft4=\ngolang.org/x/exp v0.0.0-20210901193431-a062eea981d2 h1:Or4Ra3AAlhUlNn8WmIzw2Yq2vUHSkrP6E2e/FIESpF8=\ngolang.org/x/exp v0.0.0-20210901193431-a062eea981d2/go.mod h1:a3o/VtDNHN+dCVLEpzjjUHOzR+Ln3DHX056ZPzoZGGA=\ngolang.org/x/image v0.0.0-20180708004352-c73c2afc3b81/go.mod h1:ux5Hcp/YLpHSI86hEcLt0YII63i6oz57MZXIpbrjZUs=\ngolang.org/x/image v0.0.0-20190227222117-0694c2d4d067/go.mod h1:kZ7UVZpmo3dzQBMxlp+ypCbDeSB+sBbTgSJuh5dn5js=\ngolang.org/x/image v0.0.0-20190802002840-cff245a6509b/go.mod h1:FeLwcggjj3mMvU+oOTbSwawSJRM1uh48EjtB4UJZlP0=\ngolang.org/x/lint v0.0.0-20180702182130-06c8688daad7/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190227174305-5b3e6a55c961/go.mod h1:wehouNa3lNwaWXcvxsM5YxQ5yQlVC4a0KAMCusXpPoU=\ngolang.org/x/lint v0.0.0-20190301231843-5614ed5bae6f/go.mod h1:UVdnD1Gm6xHRNCYTkRU2/jEulfH38KcIWyp/GAMgvoE=\ngolang.org/x/lint v0.0.0-20190313153728-d0100b6bd8b3/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/lint v0.0.0-20190409202823-959b441ac422/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/lint v0.0.0-20190909230951-414d861bb4ac/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/lint v0.0.0-20190930215403-16217165b5de/go.mod h1:6SW0HCj/g11FgYtHlgUYUwCkIfeOF89ocIRzGO/8vkc=\ngolang.org/x/lint v0.0.0-20191125180803-fdd1cda4f05f/go.mod h1:5qLYkcX4OjUUV8bRuDixDT3tpyyb+LUpUlRWLxfhWrs=\ngolang.org/x/lint v0.0.0-20200130185559-910be7a94367/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=\ngolang.org/x/lint v0.0.0-20200302205851-738671d3881b/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=\ngolang.org/x/lint v0.0.0-20201208152925-83fdc39ff7b5/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=\ngolang.org/x/lint v0.0.0-20210508222113-6edffad5e616/go.mod h1:3xt1FjdF8hUf6vQPIChWIBhFzV8gjjsPE/fR3IyQdNY=\ngolang.org/x/mobile v0.0.0-20190312151609-d3739f865fa6/go.mod h1:z+o9i4GpDbdi3rU15maQ/Ox0txvL9dWGYEHz965HBQE=\ngolang.org/x/mobile v0.0.0-20190719004257-d2bd2a29d028/go.mod h1:E/iHnbuqvinMTCcRqshq8CkpyQDoeVncDDYHnLhea+o=\ngolang.org/x/mobile v0.0.0-20201217150744-e6ae53a27f4f/go.mod h1:skQtrUTUwhdJvXM/2KKJzY8pDgNr9I/FOMqDVRPBUS4=\ngolang.org/x/mod v0.0.0-20190513183733-4bf6d317e70e/go.mod h1:mXi4GBBbnImb6dmsKGUJ2LatrhH/nqhxcFungHvyanc=\ngolang.org/x/mod v0.1.0/go.mod h1:0QHyrYULN0/3qlju5TqG8bIK38QM8yzMo5ekMj3DlcY=\ngolang.org/x/mod v0.1.1-0.20191105210325-c90efee705ee/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=\ngolang.org/x/mod v0.1.1-0.20191107180719-034126e5016b/go.mod h1:QqPTAvyqsEbceGzBzNggFXnrqF1CaUcvgkdR5Ot7KZg=\ngolang.org/x/mod v0.1.1-0.20191209134235-331c550502dd/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.3.1-0.20200828183125-ce943fd02449/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.4.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.4.1/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.4.2/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=\ngolang.org/x/mod v0.5.1-0.20210830214625-1b1db11ec8f4 h1:7Qds88gNaRx0Dz/1wOwXlR7asekh1B1u26wEwN6FcEI=\ngolang.org/x/mod v0.5.1-0.20210830214625-1b1db11ec8f4/go.mod h1:5OXOZSfqPIIbmVBIIKWRFfZjPR0E5r58TLhUjH0a2Ro=\ngolang.org/x/net v0.0.0-20180724234803-3673e40ba225/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180826012351-8a410e7b638d/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20180906233101-161cd47e91fd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181005035420-146acd28ed58/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181023162649-9b4f9f5ad519/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181114220301-adae6a3d119a/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20181201002055-351d144fa1fc/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190108225652-1e06a53dbb7e/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190125091013-d26f9f9a57f3/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190213061140-3a22650c66bd/go.mod h1:mL1N/T3taQHkDXs73rZJwtUhF3w3ftmwwsq0BUmARs4=\ngolang.org/x/net v0.0.0-20190311183353-d8887717615a/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190320064053-1272bf9dcd53/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190501004415-9ce7a6920f09/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190503192946-f4e77d36d62c/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=\ngolang.org/x/net v0.0.0-20190522155817-f3200d17e092/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=\ngolang.org/x/net v0.0.0-20190603091049-60506f45cf65/go.mod h1:HSz+uSET+XFnRR8LxR5pz3Of3rY3CfYBVs4xY44aLks=\ngolang.org/x/net v0.0.0-20190607181551-461777fb6f67/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190613194153-d28f0bde5980/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190628185345-da137c7871d7/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190724013045-ca1201d0de80/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190813141303-74dc4d7220e7/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20190827160401-ba9fcec4b297/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20191209160850-c0dbc17a3553/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200114155413-6afb5195e5aa/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200202094626-16171245cfb2/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200222125558-5a598a2470a0/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200301022130-244492dfa37a/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=\ngolang.org/x/net v0.0.0-20200324143707-d3edc9973b7e/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200501053045-e0ff5e5a1de5/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200506145744-7e3656a0809f/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200513185701-a91f0712d120/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200520004742-59133d7f0dd7/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200520182314-0ba52f642ac2/go.mod h1:qpuaurCH72eLCgpAm/N6yyVIVM9cpaDIP3A8BGJEC5A=\ngolang.org/x/net v0.0.0-20200625001655-4c5254603344/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=\ngolang.org/x/net v0.0.0-20200707034311-ab3426394381/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=\ngolang.org/x/net v0.0.0-20200822124328-c89045814202/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=\ngolang.org/x/net v0.0.0-20200904194848-62affa334b73/go.mod h1:/O7V0waA8r7cgGh81Ro3o1hOxt32SMVPicZroKQ2sZA=\ngolang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.0.0-20201031054903-ff519b6c9102/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.0.0-20201110031124-69a78807bb2b/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.0.0-20201202161906-c7110b5ffcbb/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=\ngolang.org/x/net v0.0.0-20201209123823-ac852fbbde11/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20201224014010-6772e930b67b/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20210119194325-5f4716e94777/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=\ngolang.org/x/net v0.0.0-20210316092652-d523dce5a7f4/go.mod h1:RBQZq4jEuRlivfhVLdyRGr576XBO4/greRjx4P4O3yc=\ngolang.org/x/net v0.0.0-20210326060303-6b1517762897/go.mod h1:uSPa2vr4CLtc/ILN5odXGNXS6mhrKVzTaCXzk9m6W3k=\ngolang.org/x/net v0.0.0-20210405180319-a5a99cb37ef4/go.mod h1:p54w0d4576C0XHj96bSt6lcn1PtDYWL6XObtHCRCNQM=\ngolang.org/x/net v0.0.0-20210428140749-89ef3d95e781/go.mod h1:OJAsFXCWl8Ukc7SiCT/9KSuxbyM7479/AVlXFRxuMCk=\ngolang.org/x/net v0.0.0-20210503060351-7fd8e65b6420/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/net v0.0.0-20210525063256-abc453219eb5/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/net v0.0.0-20210805182204-aaa1db679c0d/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/net v0.0.0-20210825183410-e898025ed96a/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/net v0.0.0-20211209124913-491a49abca63 h1:iocB37TsdFuN6IBRZ+ry36wrkoV51/tl5vOWqkcPGvY=\ngolang.org/x/net v0.0.0-20211209124913-491a49abca63/go.mod h1:9nx3DQGgdP8bBQD5qxJ1jj9UTztislL4KSBs9R2vV5Y=\ngolang.org/x/oauth2 v0.0.0-20180821212333-d2e6202438be/go.mod h1:N/0e6XlmueqKjAGxoOufVs8QHGRruUQn6yWY3a++T0U=\ngolang.org/x/oauth2 v0.0.0-20190226205417-e64efc72b421/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/oauth2 v0.0.0-20190604053449-0f29369cfe45/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/oauth2 v0.0.0-20191202225959-858c2ad4c8b6/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/oauth2 v0.0.0-20200107190931-bf48bf16ab8d/go.mod h1:gOpvHmFTYa4IltrdGE7lF6nIHvwfUNPOp7c8zoXwtLw=\ngolang.org/x/oauth2 v0.0.0-20200902213428-5d25da1a8d43/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20201109201403-9fd604954f58/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20201208152858-08078c50e5b5/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20210218202405-ba52d332ba99/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20210220000619-9bb904979d93/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20210313182246-cd4f82c27b84/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20210402161424-2e8d93401602/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20210427180440-81ed05c6b58c/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20210514164344-f6687ab2804c/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/oauth2 v0.0.0-20210819190943-2bc19b11175f h1:Qmd2pbz05z7z6lm0DrgQVVPuBm92jqujBKMHMOlOQEw=\ngolang.org/x/oauth2 v0.0.0-20210819190943-2bc19b11175f/go.mod h1:KelEdhl1UZF7XfJ4dDtk6s++YSgaE7mD/BuKKDLBl4A=\ngolang.org/x/sync v0.0.0-20180314180146-1d60e4601c6f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181108010431-42b317875d0f/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20181221193216-37e7f081c4d4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190227155943-e225da77a7e6/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20200317015054-43a5402ce75a/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20200625203802-6e8e738ad208/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20201207232520-09787c993a3a/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sync v0.0.0-20210220032951-036812b2e83c h1:5KslGYwFpkhGh+Q16bwMP3cOontH8FOep7tGV86Y7SQ=\ngolang.org/x/sync v0.0.0-20210220032951-036812b2e83c/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=\ngolang.org/x/sys v0.0.0-20180823144017-11551d06cbcc/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20180830151530-49385e6e1522/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20180905080454-ebe1bf3edb33/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20180909124046-d0be0721c37e/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181026203630-95b1ffbd15a5/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181107165924-66b7b1311ac8/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181116152217-5ac8a444bdc5/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20181122145206-62eef0e2fa9b/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190124100055-b90733256f2e/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190204203706-41f3e6584952/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190209173611-3b5209105503/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190222072716-a9d3bda3a223/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=\ngolang.org/x/sys v0.0.0-20190312061237-fead79001313/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190321052220-f7bb7a8bee54/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190422165155-953cdadca894/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190502145724-3ef323f4f1fd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190507160741-ecd444e8653b/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190606165138-5da285871e9c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190606203320-7fc4e5ec1444/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190616124812-15dcb6c0061f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190624142023-c5567b49c5d0/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190626150813-e07cf5db2756/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190726091711-fc99dfbffb4e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190813064441-fde4db37ae7a/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190826190057-c7b8b68b1456/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190904154756-749cb33beabd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20190916202348-b4ddaad3f8a3/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191001151750-bb3f8db39f24/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191002063906-3421d5a6bb1c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191005200804-aed5e4c7ecf9/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191022100944-742c48ecaeb7/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191026070338-33540a1f6037/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191115151921-52ab43148777/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191120155948-bd437916bb0e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191204072324-ce4227a45e2e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191220142924-d4481acd189f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20191228213918-04cbcbbfeed8/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200106162015-b016eb3dc98e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200113162924-86b910548bc1/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200116001909-b77594299b42/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200120151820-655fe14d7479/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200122134326-e047566fdf82/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200202164722-d101bd2416d5/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200212091648-12a6c2dcc1e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200217220822-9197077df867/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200223170610-d5e6a3e2c0ae/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200302150141-5c8b2ff67527/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200323222414-85ca7c5b95cd/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200331124033-c3d80250170d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200501052902-10377860bb8e/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200511232937-7e40ca221e25/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200515095857-1151b9dac4a9/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200519105757-fe76b779f299/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200523222454-059865788121/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200615200032-f1bc736245b1/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200625212154-ddb9806d33ae/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200803210538-64077c9b5642/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200831180312-196b9ba8737a/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200905004654-be1d3432aa8f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200909081042-eff7692f9009/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200916030750-2334cc1a136f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200923182605-d9f96fdee20d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20201201145000-ef89a241ccb3/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210104204734-6f8348627aad/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210112080510-489259a85091/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210119212857-b64e53b001e4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210124154548-22da62e12c0c/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210220050731-9a76102bfb43/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210301091718-77cc2087c03b/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210305230114-8fe3ee5dd75b/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210315160823-c6e025ad8005/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210320140829-1e4c9ba3b0c4/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210324051608-47abb6519492/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210330210617-4fbd30eecc44/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210403161142-5e06dd20ab57/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210423082822-04245dca01da/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210426230700-d19ff857e887/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210502180810-71e4cd670f79/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210503080704-8803ae5d1324/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=\ngolang.org/x/sys v0.0.0-20210510120138-977fb7262007/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210603081109-ebe580a85c40/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210608053332-aa57babbf139/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210616094352-59db8d763f22/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210630005230-0f9fa26af87c/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210809222454-d867a43fc93e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20210831042530-f4d43177bf5e/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/sys v0.0.0-20211029165221-6e7872819dc8 h1:M69LAlWZCshgp0QSzyDcSsSIejIEeuaCVpmwcKwyLMk=\ngolang.org/x/sys v0.0.0-20211029165221-6e7872819dc8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=\ngolang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=\ngolang.org/x/term v0.0.0-20210615171337-6886f2dfbf5b h1:9zKuko04nR4gjZ4+DNjHqRlAJqbJETHwiNKDqTfOjfE=\ngolang.org/x/term v0.0.0-20210615171337-6886f2dfbf5b/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=\ngolang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.1-0.20180807135948-17ff2d5776d2/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\ngolang.org/x/text v0.3.2/go.mod h1:bEr9sfX3Q8Zfm5fL9x+3itogRgK3+ptLWKqgva+5dAk=\ngolang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.4/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.5/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.6/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=\ngolang.org/x/text v0.3.7 h1:olpwvP2KacW1ZWvsR7uQhoyTYvKAupfQrRGBFM352Gk=\ngolang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=\ngolang.org/x/time v0.0.0-20180412165947-fbb02b2291d2/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20181108054448-85acf8d2951c/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20190308202827-9d24e82272b4/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20191024005414-555d28b269f0/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20210220033141-f8bda1e9f3ba/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/time v0.0.0-20210723032227-1f47c861a9ac h1:7zkz7BUtwNFFqcowJ+RIgu2MaV/MapERkDIy+mwPyjs=\ngolang.org/x/time v0.0.0-20210723032227-1f47c861a9ac/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=\ngolang.org/x/tools v0.0.0-20180221164845-07fd8470d635/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20180525024113-a5b4c53f6e8b/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20180828015842-6cd1fcedba52/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20181030221726-6c7e314b6563/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20181221001348-537d06c36207/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190125232054-d66bd3c5d5a6/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190206041539-40960b6deb8e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=\ngolang.org/x/tools v0.0.0-20190226205152-f727befe758c/go.mod h1:9Yl7xja0Znq3iFh3HoIrodX9oNMXvdceNzlUR8zjMvY=\ngolang.org/x/tools v0.0.0-20190311212946-11955173bddd/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190312151545-0bb0c0a6e846/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190312170243-e65039ee4138/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190328211700-ab21143f2384/go.mod h1:LCzVGOaR6xXOjkQ3onu1FJEFr0SW1gC7cKk1uF8kGRs=\ngolang.org/x/tools v0.0.0-20190425150028-36563e24a262/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20190506145303-2d16b83fe98c/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20190524140312-2c0ae7006135/go.mod h1:RgjU9mgBXZiqYHBnxXauZ1Gv1EHHAz9KjViQ78xBX0Q=\ngolang.org/x/tools v0.0.0-20190606124116-d0a3d012864b/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20190614205625-5aca471b1d59/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20190617190820-da514acc4774/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20190621195816-6e04913cbbac/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20190624222133-a101b041ded4/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20190628153133-6cdbf07be9d0/go.mod h1:/rFqwRUd4F7ZHNgwSSTFct+R/Kf4OFW1sUzUTQQTgfc=\ngolang.org/x/tools v0.0.0-20190816200558-6889da9d5479/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20190911174233-4f2ddba30aff/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191012152004-8de300cfc20a/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191029041327-9cc4af7d6b2c/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191029190741-b9c20aec41a5/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191108193012-7d206e10da11/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191112195655-aa38f8e97acc/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191113191852-77e3bb0ad9e7/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191115202509-3a792d9c32b2/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191125144606-a911d9008d1f/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191130070609-6e064ea0cf2d/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=\ngolang.org/x/tools v0.0.0-20191216173652-a0e659d51361/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20191227053925-7b8e75db28f4/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200103221440-774c71fcf114/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200117012304-6edc0a871e69/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200117161641-43d50277825c/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200122220014-bf1340f18c4a/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200130002326-2f3ba24bd6e7/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200204074204-1cc6d1ef6c74/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200207183749-b753a1ba74fa/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200212150539-ea181f53ac56/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200224181240-023911ca70b2/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200227222343-706bc42d1f0d/go.mod h1:TB2adYChydJhpapKDTa4BR/hXlZSLoq2Wpct/0txZ28=\ngolang.org/x/tools v0.0.0-20200304193943-95d2e580d8eb/go.mod h1:o4KQGtdN14AW+yjsvvwRTJJuXz8XRtIHtEnmAXLyFUw=\ngolang.org/x/tools v0.0.0-20200312045724-11d5b4c81c7d/go.mod h1:o4KQGtdN14AW+yjsvvwRTJJuXz8XRtIHtEnmAXLyFUw=\ngolang.org/x/tools v0.0.0-20200331025713-a30bf2db82d4/go.mod h1:Sl4aGygMT6LrqrWclx+PTx3U+LnKx/seiNR+3G19Ar8=\ngolang.org/x/tools v0.0.0-20200501065659-ab2804fb9c9d/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200505023115-26f46d2f7ef8/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200512131952-2bc93b1c0c88/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200515010526-7d3b6ebf133d/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200618134242-20370b0cb4b2/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200619180055-7c47624df98f/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=\ngolang.org/x/tools v0.0.0-20200729194436-6467de6f59a7/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=\ngolang.org/x/tools v0.0.0-20200804011535-6c149bb5ef0d/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=\ngolang.org/x/tools v0.0.0-20200825202427-b303f430e36d/go.mod h1:njjCfa9FT2d7l9Bc6FUM5FLjQPp3cFF28FI3qnDFljA=\ngolang.org/x/tools v0.0.0-20200904185747-39188db58858/go.mod h1:Cj7w3i3Rnn0Xh82ur9kSqwfTHTeVxaDqrfMjpcNT6bE=\ngolang.org/x/tools v0.0.0-20201110124207-079ba7bd75cd/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/tools v0.0.0-20201201161351-ac6f37ff4c2a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/tools v0.0.0-20201208233053-a543418bbed2/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/tools v0.0.0-20201224043029-2b0845dc783e/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/tools v0.0.0-20210105154028-b0ab187a4818/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/tools v0.0.0-20210106214847-113979e3529a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=\ngolang.org/x/tools v0.1.0/go.mod h1:xkSsbof2nBLbhDlRMhhhyNLN/zl3eTqcnHD5viDpcZ0=\ngolang.org/x/tools v0.1.2/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\ngolang.org/x/tools v0.1.5/go.mod h1:o0xws9oXOQQZyjljx8fwUC0k7L1pTE6eaCbjGeHmOkk=\ngolang.org/x/tools v0.1.6-0.20210820212750-d4cc65f0b2ff h1:VX/uD7MK0AHXGiScH3fsieUQUcpmRERPDYtqZdJnA+Q=\ngolang.org/x/tools v0.1.6-0.20210820212750-d4cc65f0b2ff/go.mod h1:YD9qOF0M9xpSpdWTBbzEl5e/RnCefISl8E5Noe10jFM=\ngolang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1 h1:go1bK/D/BFZV2I8cIQd1NKEZ+0owSTG1fDTci4IqFcE=\ngolang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=\ngomodules.xyz/envconfig v1.3.1-0.20190308184047-426f31af0d45 h1:juzzlx91nWAOsHuOVfXZPMXHtJEKouZvY9bBbwlOeYs=\ngomodules.xyz/envconfig v1.3.1-0.20190308184047-426f31af0d45/go.mod h1:41y72mzHT7+jFNgyBpJRrZWuZJcLmLrTpq6iGgOFJMQ=\ngomodules.xyz/jsonpatch/v2 v2.2.0 h1:4pT439QV83L+G9FkcCriY6EkpcK6r6bK+A5FBUMI7qY=\ngomodules.xyz/jsonpatch/v2 v2.2.0/go.mod h1:WXp+iVDkoLQqPudfQ9GBlwB2eZ5DKOnjQZCYdOS8GPY=\ngomodules.xyz/notify v0.1.0 h1:lN7CAFKIWxaXJXm3F/7KTbgw3lUy9peh6iyjgj1skvA=\ngomodules.xyz/notify v0.1.0/go.mod h1:wGy0vLXGpabCg0j9WbjzXf7pM7Khz11FqCLtBbTujP0=\ngonum.org/v1/gonum v0.0.0-20180816165407-929014505bf4/go.mod h1:Y+Yx5eoAFn32cQvJDxZx5Dpnq+c3wtXuadVZAcxbbBo=\ngonum.org/v1/gonum v0.0.0-20190331200053-3d26580ed485/go.mod h1:2ltnJ7xHfj0zHS40VVPYEAAMTa3ZGguvHGBSJeRWqE0=\ngonum.org/v1/gonum v0.6.2/go.mod h1:9mxDZsDKxgMAuccQkewq682L+0eCu4dCN2yonUJTCLU=\ngonum.org/v1/netlib v0.0.0-20190313105609-8cb42192e0e0/go.mod h1:wa6Ws7BG/ESfp6dHfk7C6KdzKA7wR7u/rKwOGE66zvw=\ngonum.org/v1/netlib v0.0.0-20190331212654-76723241ea4e/go.mod h1:kS+toOQn6AQKjmKJ7gzohV1XkqsFehRA2FbsbkopSuQ=\ngonum.org/v1/plot v0.0.0-20190515093506-e2840ee46a6b/go.mod h1:Wt8AAjI+ypCyYX3nZBvf6cAIx93T+c/OS2HFAYskSZc=\ngoogle.golang.org/api v0.3.1/go.mod h1:6wY9I6uQWHQ8EM57III9mq/AjF+i8G65rmVagqKMtkk=\ngoogle.golang.org/api v0.4.0/go.mod h1:8k5glujaEP+g9n7WNsDg8QP6cUVNI86fCNMcbazEtwE=\ngoogle.golang.org/api v0.7.0/go.mod h1:WtwebWUNSVBH/HAw79HIFXZNqEvBhG+Ra+ax0hx3E3M=\ngoogle.golang.org/api v0.8.0/go.mod h1:o4eAsZoiT+ibD93RtjEohWalFOjRDx6CVaqeizhEnKg=\ngoogle.golang.org/api v0.9.0/go.mod h1:o4eAsZoiT+ibD93RtjEohWalFOjRDx6CVaqeizhEnKg=\ngoogle.golang.org/api v0.13.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=\ngoogle.golang.org/api v0.14.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=\ngoogle.golang.org/api v0.15.0/go.mod h1:iLdEw5Ide6rF15KTC1Kkl0iskquN2gFfn9o9XIsbkAI=\ngoogle.golang.org/api v0.17.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.18.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.19.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.20.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.22.0/go.mod h1:BwFmGc8tA3vsd7r/7kR8DY7iEEGSU04BFxCo5jP/sfE=\ngoogle.golang.org/api v0.24.0/go.mod h1:lIXQywCXRcnZPGlsd8NbLnOjtAoL6em04bJ9+z0MncE=\ngoogle.golang.org/api v0.28.0/go.mod h1:lIXQywCXRcnZPGlsd8NbLnOjtAoL6em04bJ9+z0MncE=\ngoogle.golang.org/api v0.29.0/go.mod h1:Lcubydp8VUV7KeIHD9z2Bys/sm/vGKnG1UHuDBSrHWM=\ngoogle.golang.org/api v0.30.0/go.mod h1:QGmEvQ87FHZNiUVJkT14jQNYJ4ZJjdRF23ZXz5138Fc=\ngoogle.golang.org/api v0.35.0/go.mod h1:/XrVsuzM0rZmrsbjJutiuftIzeuTQcEeaYcSk/mQ1dg=\ngoogle.golang.org/api v0.36.0/go.mod h1:+z5ficQTmoYpPn8LCUNVpK5I7hwkpjbcgqA7I34qYtE=\ngoogle.golang.org/api v0.40.0/go.mod h1:fYKFpnQN0DsDSKRVRcQSDQNtqWPfM9i+zNPxepjRCQ8=\ngoogle.golang.org/api v0.41.0/go.mod h1:RkxM5lITDfTzmyKFPt+wGrCJbVfniCr2ool8kTBzRTU=\ngoogle.golang.org/api v0.43.0/go.mod h1:nQsDGjRXMo4lvh5hP0TKqF244gqhGcr/YSIykhUk/94=\ngoogle.golang.org/api v0.44.0/go.mod h1:EBOGZqzyhtvMDoxwS97ctnh0zUmYY6CxqXsc1AvkYD8=\ngoogle.golang.org/api v0.46.0/go.mod h1:ceL4oozhkAiTID8XMmJBsIxID/9wMXJVVFXPg4ylg3I=\ngoogle.golang.org/appengine v1.1.0/go.mod h1:EbEs0AVv82hx2wNQdGPgUI5lhzA/G0D9YwlJXL52JkM=\ngoogle.golang.org/appengine v1.2.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/appengine v1.4.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/appengine v1.5.0/go.mod h1:xpcJRLb0r/rnEns0DIKYYv+WjYCduHsrkT7/EB5XEv4=\ngoogle.golang.org/appengine v1.6.1/go.mod h1:i06prIuMbXzDqacNJfV5OdTW448YApPu5ww/cMBSeb0=\ngoogle.golang.org/appengine v1.6.5/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=\ngoogle.golang.org/appengine v1.6.6/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=\ngoogle.golang.org/appengine v1.6.7 h1:FZR1q0exgwxzPzp/aF+VccGrSfxfPpkBqjIIEq3ru6c=\ngoogle.golang.org/appengine v1.6.7/go.mod h1:8WjMMxjGQR8xUklV/ARdw2HLXBOI7O7uCIDZVag1xfc=\ngoogle.golang.org/genproto v0.0.0-20180817151627-c66870c02cf8/go.mod h1:JiN7NxoALGmiZfu7CAH4rXhgtRTLTxftemlI0sWmxmc=\ngoogle.golang.org/genproto v0.0.0-20190307195333-5fe7a883aa19/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190418145605-e7d98fc518a7/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190425155659-357c62f0e4bb/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190502173448-54afdca5d873/go.mod h1:VzzqZJRnGkLBvHegQrXjBqPurQTc5/KpmUdxsrq26oE=\ngoogle.golang.org/genproto v0.0.0-20190530194941-fb225487d101/go.mod h1:z3L6/3dTEVtUr6QSP8miRzeRqwQOioJ9I66odjN4I7s=\ngoogle.golang.org/genproto v0.0.0-20190801165951-fa694d86fc64/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=\ngoogle.golang.org/genproto v0.0.0-20190819201941-24fa4b261c55/go.mod h1:DMBHOl98Agz4BDEuKkezgsaosCRResVns1a3J2ZsMNc=\ngoogle.golang.org/genproto v0.0.0-20190911173649-1774047e7e51/go.mod h1:IbNlFCBrqXvoKpeg0TB2l7cyZUmoaFKYIwrEpbDKLA8=\ngoogle.golang.org/genproto v0.0.0-20191108220845-16a3f7862a1a/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20191115194625-c23dd37a84c9/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20191216164720-4f79533eabd1/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20191230161307-f3c370f40bfb/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20200115191322-ca5a22157cba/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20200117163144-32f20d992d24/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20200122232147-0452cf42e150/go.mod h1:n3cpQtvxv34hfy77yVDNjmbRyujviMdxYliBSkLhpCc=\ngoogle.golang.org/genproto v0.0.0-20200204135345-fa8e72b47b90/go.mod h1:GmwEX6Z4W5gMy59cAlVYjN9JhxgbQH6Gn+gFDQe2lzA=\ngoogle.golang.org/genproto v0.0.0-20200212174721-66ed5ce911ce/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200224152610-e50cd9704f63/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200228133532-8c2c7df3a383/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200305110556-506484158171/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200312145019-da6875a35672/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200331122359-1ee6d9798940/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200423170343-7949de9c1215/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200430143042-b979b6f78d84/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200511104702-f5ebc3bea380/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200513103714-09dca8ec2884/go.mod h1:55QSHmfGQM9UVYDPBsyGGes0y52j32PQ3BqQfXhyH3c=\ngoogle.golang.org/genproto v0.0.0-20200515170657-fc4c6c6a6587/go.mod h1:YsZOwe1myG/8QRHRsmBRE1LrgQY60beZKjly0O1fX9U=\ngoogle.golang.org/genproto v0.0.0-20200526211855-cb27e3aa2013/go.mod h1:NbSheEEYHJ7i3ixzK3sjbqSGDJWnxyFXZblF3eUsNvo=\ngoogle.golang.org/genproto v0.0.0-20200618031413-b414f8b61790/go.mod h1:jDfRM7FcilCzHH/e9qn6dsT145K34l5v+OpcnNgKAAA=\ngoogle.golang.org/genproto v0.0.0-20200729003335-053ba62fc06f/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20200804131852-c06518451d9c/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20200825200019-8632dd797987/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20200904004341-0bd0a958aa1d/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20201019141844-1ed22bb0c154/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20201102152239-715cce707fb0/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20201109203340-2640f1f9cdfb/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20201201144952-b05cb90ed32e/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20201210142538-e3217bee35cc/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20201214200347-8c77b98c765d/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20210222152913-aa3ee6e6a81c/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20210303154014-9728d6b83eeb/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20210310155132-4ce2db91004e/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20210319143718-93e7006c17a6/go.mod h1:FWY/as6DDZQgahTzZj3fqbO1CbirC29ZNUFHwi0/+no=\ngoogle.golang.org/genproto v0.0.0-20210402141018-6c239bbf2bb1/go.mod h1:9lPAdzaEmUacj36I+k7YKbEc5CXzPIeORRgDAUOu28A=\ngoogle.golang.org/genproto v0.0.0-20210429181445-86c259c2b4ab/go.mod h1:P3QM42oQyzQSnHPnZ/vqoCdDmzH28fzWByN9asMeM8A=\ngoogle.golang.org/genproto v0.0.0-20210602131652-f16073e35f0c/go.mod h1:UODoCrxHCcBojKKwX1terBiRUaqAsFqJiF615XL43r0=\ngoogle.golang.org/genproto v0.0.0-20210831024726-fe130286e0e2 h1:NHN4wOCScVzKhPenJ2dt+BTs3X/XkBVI/Rh4iDt55T8=\ngoogle.golang.org/genproto v0.0.0-20210831024726-fe130286e0e2/go.mod h1:eFjDcFEctNawg4eG61bRv87N7iHBWyVhJu7u1kqDUXY=\ngoogle.golang.org/grpc v1.15.0 h1:Az/KuahOM4NAidTEuJCv/RonAA7rYsTPkqXVjr+8OOw=\ngoogle.golang.org/grpc v1.15.0/go.mod h1:0JHn/cJsOMiMfNA9+DeHDlAU7KAAB5GDlYFpa9MZMio=\ngoogle.golang.org/protobuf v1.21.0/go.mod h1:47Nbq4nVaFHyn7ilMalzfO3qCViNmqZ2kzikPIcrTAo=\ngoogle.golang.org/protobuf v1.22.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.23.0/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.23.1-0.20200526195155-81db48ad09cc/go.mod h1:EGpADcykh3NcUnDUJcl1+ZksZNG86OlYog2l/sGQquU=\ngoogle.golang.org/protobuf v1.24.0/go.mod h1:r/3tXBNzIEhYS9I1OUVjXDlt8tc493IdKGjtUeSXeh4=\ngoogle.golang.org/protobuf v1.25.0/go.mod h1:9JNX74DMeImyA3h4bdi1ymwjUzf21/xIlbajtzgsN7c=\ngoogle.golang.org/protobuf v1.26.0-rc.1/go.mod h1:jlhhOSvTdKEhbULTjvd4ARK9grFBp09yW+WbY/TyQbw=\ngoogle.golang.org/protobuf v1.26.0/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=\ngoogle.golang.org/protobuf v1.27.1 h1:SnqbnDw1V7RiZcXPx5MEeqPv2s79L9i7BJUlG/+RurQ=\ngoogle.golang.org/protobuf v1.27.1/go.mod h1:9q0QmTI4eRPtz6boOQmLYwt+qCgq0jsYwAQnmE0givc=\ngopkg.in/alecthomas/kingpin.v2 v2.2.6/go.mod h1:FMv+mEhP44yOT+4EoQTLFTRgOQ1FBLkstjWtayDeSgw=\ngopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc h1:2gGKlE2+asNV9m7xrywl36YYNnBG5ZQ0r/BOOxqPpmk=\ngopkg.in/alexcesaro/quotedprintable.v3 v3.0.0-20150716171945-2caba252f4dc/go.mod h1:m7x9LTH6d71AHyAX77c9yqWCCa3UKHcVEj9y7hAtKDk=\ngopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20180628173108-788fd7840127/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20190902080502-41f04d3bba15/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20200227125254-8fa46927fb4f/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=\ngopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=\ngopkg.in/cheggaaa/pb.v1 v1.0.25/go.mod h1:V/YB90LKu/1FcN3WVnfiiE5oMCibMjukxqG/qStrOgw=\ngopkg.in/errgo.v2 v2.1.0/go.mod h1:hNsd1EY+bozCKY1Ytp96fpM3vjJbqLJn88ws8XvfDNI=\ngopkg.in/fsnotify.v1 v1.4.7/go.mod h1:Tz8NjZHkW78fSQdbUxIjBTcgA1z1m8ZHf0WmKUhAMys=\ngopkg.in/gcfg.v1 v1.2.0/go.mod h1:yesOnuUOFQAhST5vPY4nbZsb/huCgGGXlipJsBn0b3o=\ngopkg.in/gcfg.v1 v1.2.3/go.mod h1:yesOnuUOFQAhST5vPY4nbZsb/huCgGGXlipJsBn0b3o=\ngopkg.in/go-playground/assert.v1 v1.2.1/go.mod h1:9RXL0bg/zibRAgZUYszZSwO/z8Y/a8bDuhia5mkpMnE=\ngopkg.in/go-playground/validator.v9 v9.29.1/go.mod h1:+c9/zcJMFNgbLvly1L1V+PpxWdVbfP1avr/N00E2vyQ=\ngopkg.in/go-playground/webhooks.v5 v5.11.0 h1:V3vej+ZXrVvO2EmBTKlhClEbpTqXH44K5OyLUMOkHMg=\ngopkg.in/go-playground/webhooks.v5 v5.11.0/go.mod h1:LZbya/qLVdbqDR1aKrGuWV6qbia2zCYSR5dpom2SInQ=\ngopkg.in/gomail.v2 v2.0.0-20160411212932-81ebce5c23df h1:n7WqCuqOuCbNr617RXOY0AWRXxgwEyPp2z+p0+hgMuE=\ngopkg.in/gomail.v2 v2.0.0-20160411212932-81ebce5c23df/go.mod h1:LRQQ+SO6ZHR7tOkpBDuZnXENFzX8qRjMDMyPD6BRkCw=\ngopkg.in/inf.v0 v0.9.1 h1:73M5CoZyi3ZLMOyDlQh031Cx6N9NDJ2Vvfl76EDAgDc=\ngopkg.in/inf.v0 v0.9.1/go.mod h1:cWUDdTG/fYaXco+Dcufb5Vnc6Gp2YChqWtbxRZE0mXw=\ngopkg.in/ini.v1 v1.51.0/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=\ngopkg.in/ini.v1 v1.57.0/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=\ngopkg.in/ini.v1 v1.62.0/go.mod h1:pNLf8WUiyNEtQjuu5G5vTm06TEv9tsIgeAvK8hOrP4k=\ngopkg.in/mgo.v2 v2.0.0-20180705113604-9856a29383ce/go.mod h1:yeKp02qBN3iKW1OzL3MGk2IdtZzaj7SFntXj72NppTA=\ngopkg.in/natefinch/lumberjack.v2 v2.0.0/go.mod h1:l0ndWWf7gzL7RNwBG7wST/UCcT4T24xpD6X8LsfU/+k=\ngopkg.in/square/go-jose.v2 v2.2.2 h1:orlkJ3myw8CN1nVQHBFfloD+L3egixIa4FvUP6RosSA=\ngopkg.in/square/go-jose.v2 v2.2.2/go.mod h1:M9dMgbHiYLoDGQrXy7OpJDJWiKiU//h+vD76mk0e1AI=\ngopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7 h1:uRGJdciOHaEIrze2W8Q3AKkepLTh2hOroT7a+7czfdQ=\ngopkg.in/tomb.v1 v1.0.0-20141024135613-dd632973f1e7/go.mod h1:dt/ZhP58zS4L8KSrWDmTeBkI65Dw0HsyUHuEVlX15mw=\ngopkg.in/warnings.v0 v0.1.1/go.mod h1:jksf8JmL6Qr/oQM2OXTHunEvvTAsrWBLb6OOjuVWRNI=\ngopkg.in/warnings.v0 v0.1.2 h1:wFXVbFY8DY5/xOe1ECiWdKCzZlxgshcYVNkBHstARME=\ngopkg.in/warnings.v0 v0.1.2/go.mod h1:jksf8JmL6Qr/oQM2OXTHunEvvTAsrWBLb6OOjuVWRNI=\ngopkg.in/yaml.v2 v2.2.1/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.3/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.4/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.5/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.7/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.2.8/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.3.0/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=\ngopkg.in/yaml.v2 v2.4.0 h1:D8xgwECY7CYvx+Y2n4sBz93Jn9JRvxdiyyo8CTfuKaY=\ngopkg.in/yaml.v2 v2.4.0/go.mod h1:RDklbk79AGWmwhnvt/jBztapEOGDOx6ZbXqjP6csGnQ=\ngopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.0-20200615113413-eeeca48fe776/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b h1:h8qDotaEPuJATrMmW04NCwg7v22aHH28wwpauUhK9Oo=\ngopkg.in/yaml.v3 v3.0.0-20210107192922-496545a6307b/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=\ngotest.tools/v3 v3.0.2/go.mod h1:3SzNCllyD9/Y+b5r9JIKQ474KzkZyqLqEfYqMsX94Bk=\ngotest.tools/v3 v3.0.3 h1:4AuOwCGf4lLR9u3YOe2awrHygurzhO/HeQ6laiA6Sx0=\ngotest.tools/v3 v3.0.3/go.mod h1:Z7Lb0S5l+klDB31fvDQX8ss/FlKDxtlFlw3Oa8Ymbl8=\nhonnef.co/go/tools v0.0.0-20180728063816-88497007e858/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190102054323-c2f93a96b099/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190106161140-3f1c8253044a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190418001031-e561f6794a2a/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.0-20190523083050-ea95bdfd59fc/go.mod h1:rf3lG4BRIbNafJWhAfAdb/ePZxsR/4RtNHQocxwk9r4=\nhonnef.co/go/tools v0.0.1-2019.2.3/go.mod h1:a3bituU0lyd329TUQxRnasdCoJDkEUEAqEt0JzvZhAg=\nhonnef.co/go/tools v0.0.1-2020.1.3/go.mod h1:X/FiERA/W4tHapMX5mGpAtMSVEeEUOyHaw9vFzvIQ3k=\nhonnef.co/go/tools v0.0.1-2020.1.4/go.mod h1:X/FiERA/W4tHapMX5mGpAtMSVEeEUOyHaw9vFzvIQ3k=\nhonnef.co/go/tools v0.1.3/go.mod h1:NgwopIslSNH47DimFoV78dnkksY2EFtX0ajyb3K/las=\nk8s.io/api v0.23.1 h1:ncu/qfBfUoClqwkTGbeRqqOqBCRoUAflMuOaOD7J0c8=\nk8s.io/api v0.23.1/go.mod h1:WfXnOnwSqNtG62Y1CdjoMxh7r7u9QXGCkA1u0na2jgo=\nk8s.io/apiextensions-apiserver v0.23.1 h1:xxE0q1vLOVZiWORu1KwNRQFsGWtImueOrqSl13sS5EU=\nk8s.io/apiextensions-apiserver v0.23.1/go.mod h1:0qz4fPaHHsVhRApbtk3MGXNn2Q9M/cVWWhfHdY2SxiM=\nk8s.io/apimachinery v0.23.1 h1:sfBjlDFwj2onG0Ijx5C+SrAoeUscPrmghm7wHP+uXlo=\nk8s.io/apimachinery v0.23.1/go.mod h1:SADt2Kl8/sttJ62RRsi9MIV4o8f5S3coArm0Iu3fBno=\nk8s.io/apiserver v0.23.1 h1:vWGf8LcV9Pk/z5rdLmCiBDqE21ccbe930dzrtVMhw9g=\nk8s.io/apiserver v0.23.1/go.mod h1:Bqt0gWbeM2NefS8CjWswwd2VNAKN6lUKR85Ft4gippY=\nk8s.io/cli-runtime v0.23.1 h1:vHUZrq1Oejs0WaJnxs09mLHKScvIIl2hMSthhS8o8Yo=\nk8s.io/cli-runtime v0.23.1/go.mod h1:r9r8H/qfXo9w+69vwUL7LokKlLRKW5D6A8vUKCx+YL0=\nk8s.io/client-go v0.23.1 h1:Ma4Fhf/p07Nmj9yAB1H7UwbFHEBrSPg8lviR24U2GiQ=\nk8s.io/client-go v0.23.1/go.mod h1:6QSI8fEuqD4zgFK0xbdwfB/PthBsIxCJMa3s17WlcO0=\nk8s.io/cloud-provider v0.23.1/go.mod h1:kI8AnYwOSru5Bci8pPUWwV5kJMVkY1ICOp1p8KKZWpc=\nk8s.io/cluster-bootstrap v0.23.1/go.mod h1:p2732QxwSa13WPemmyIeykk16qVw15W7lgNRB6x7NpY=\nk8s.io/code-generator v0.23.1 h1:ViFOlP/0bYD7VrnUDS+ch5ej5EIuMawFmHcRuv9Yxyw=\nk8s.io/code-generator v0.23.1/go.mod h1:V7yn6VNTCWW8GqodYCESVo95fuiEg713S8B7WacWZDA=\nk8s.io/component-base v0.23.1 h1:j/BqdZUWeWKCy2v/jcgnOJAzpRYWSbGcjGVYICko8Uc=\nk8s.io/component-base v0.23.1/go.mod h1:6llmap8QtJIXGDd4uIWJhAq0Op8AtQo6bDW2RrNMTeo=\nk8s.io/component-helpers v0.23.1 h1:Xrtj0LwXUqYyTPvN2bOE2UcqURX+uSBmKX1koNGhVxI=\nk8s.io/component-helpers v0.23.1/go.mod h1:ZK24U+2oXnBPcas2KolLigVVN9g5zOzaHLkHiQMFGr0=\nk8s.io/controller-manager v0.23.1/go.mod h1:AFE4qIllvTh+nRwGr3SRSUt7F+xVSzXCeb0hhzYlU4k=\nk8s.io/cri-api v0.23.1/go.mod h1:REJE3PSU0h/LOV1APBrupxrEJqnoxZC8KWzkBUHwrK4=\nk8s.io/csi-translation-lib v0.23.1/go.mod h1:0ZyB0cZBV4ZkqibwilEhKnxOne28rq5FDSjO+0MUVio=\nk8s.io/gengo v0.0.0-20200413195148-3a45101e95ac/go.mod h1:ezvh/TsK7cY6rbqRK0oQQ8IAqLxYwwyPxAX1Pzy0ii0=\nk8s.io/gengo v0.0.0-20210813121822-485abfe95c7c/go.mod h1:FiNAH4ZV3gBg2Kwh89tzAEV2be7d5xI0vBa/VySYy3E=\nk8s.io/gengo v0.0.0-20211129171323-c02415ce4185 h1:TT1WdmqqXareKxZ/oNXEUSwKlLiHzPMyB0t8BaFeBYI=\nk8s.io/gengo v0.0.0-20211129171323-c02415ce4185/go.mod h1:FiNAH4ZV3gBg2Kwh89tzAEV2be7d5xI0vBa/VySYy3E=\nk8s.io/klog/v2 v2.0.0/go.mod h1:PBfzABfn139FHAV07az/IF9Wp1bkk3vpT2XSJ76fSDE=\nk8s.io/klog/v2 v2.2.0/go.mod h1:Od+F08eJP+W3HUb4pSrPpgp9DGU4GzlpG/TmITuYh/Y=\nk8s.io/klog/v2 v2.4.0/go.mod h1:Od+F08eJP+W3HUb4pSrPpgp9DGU4GzlpG/TmITuYh/Y=\nk8s.io/klog/v2 v2.5.0/go.mod h1:hy9LJ/NvuK+iVyP4Ehqva4HxZG/oXyIS3n3Jmire4Ec=\nk8s.io/klog/v2 v2.30.0 h1:bUO6drIvCIsvZ/XFgfxoGFQU/a4Qkh0iAlvUR7vlHJw=\nk8s.io/klog/v2 v2.30.0/go.mod h1:y1WjHnz7Dj687irZUWR/WLkLc5N1YHtjLdmgWjndZn0=\nk8s.io/kube-aggregator v0.23.1 h1:w05VLh3ji05gYQglMKKrwafgqjgIxZoBusxdSWS9d/4=\nk8s.io/kube-aggregator v0.23.1/go.mod h1:1SPZXYD/je2gKxxLBkYyG3yFxSCUWI5QTyjqP2ZxRDI=\nk8s.io/kube-controller-manager v0.23.1/go.mod h1:KbZeNSFsBM5j2ddB5yXJ1nTQx2j/1/Cf7cXzG27aKZ0=\nk8s.io/kube-openapi v0.0.0-20210421082810-95288971da7e/go.mod h1:vHXdDvt9+2spS2Rx9ql3I8tycm3H9FDfdUoIuKCefvw=\nk8s.io/kube-openapi v0.0.0-20211115234752-e816edb12b65 h1:E3J9oCLlaobFUqsjG9DfKbP2BmgwBL2p7pn0A3dG9W4=\nk8s.io/kube-openapi v0.0.0-20211115234752-e816edb12b65/go.mod h1:sX9MT8g7NVZM5lVL/j8QyCCJe8YSMW30QvGZWaCIDIk=\nk8s.io/kube-proxy v0.23.1/go.mod h1:65QJpMrjUMHfgX1q5Pl/KqVRZBMM4qLHNMo5MhKsnp0=\nk8s.io/kube-scheduler v0.23.1/go.mod h1:SFPvXnt7KlxTZILrtjH8VNwGDzXcdKKHrv4TkeZdYro=\nk8s.io/kubectl v0.23.1 h1:gmscOiV4Y4XIRIn14gQBBADoyyVrDZPbxRCTDga4RSA=\nk8s.io/kubectl v0.23.1/go.mod h1:Ui7dJKdUludF8yWAOSN7JZEkOuYixX5yF6E6NjoukKE=\nk8s.io/kubelet v0.23.1/go.mod h1:WdvMiehtNPhtiW8sSVVvr8YYU00L0u+0HkfMDEB0LKM=\nk8s.io/kubernetes v1.23.1 h1:iJfubd03CDap4m69Ue+u2I6quNUYiYlC8+TakEHATjc=\nk8s.io/kubernetes v1.23.1/go.mod h1:baMGbPpwwP0kT/+eAPtdqoWNRoXyyTJ2Zf+fw/Y8t04=\nk8s.io/legacy-cloud-providers v0.23.1/go.mod h1:HIt+r/ReEfjS6IGaGfpZ7tCna7hbMBXMOaIp/SWABVE=\nk8s.io/metrics v0.23.1/go.mod h1:qXvsM1KANrc+ZZeFwj6Phvf0NLiC+d3RwcsLcdGc+xs=\nk8s.io/mount-utils v0.23.1/go.mod h1:9pFhzVjxle1osJUo++9MFDat9HPkQUOoHCn+eExZ3Ew=\nk8s.io/pod-security-admission v0.23.1/go.mod h1:WDb/vFWf7jKSGe2e07LTEjDZ0MHMDhUIzXNvQ45HytU=\nk8s.io/sample-apiserver v0.23.1/go.mod h1:5ZQrkouVpN6GeNMZEJFkIpFwaxgDPJin/cIBXyDboC4=\nk8s.io/system-validators v1.6.0/go.mod h1:bPldcLgkIUK22ALflnsXk8pvkTEndYdNuaHH6gRrl0Q=\nk8s.io/utils v0.0.0-20201110183641-67b214c5f920/go.mod h1:jPW/WVKK9YHAvNhRxK0md/EJ228hCsBRufyofKtW8HA=\nk8s.io/utils v0.0.0-20210802155522-efc7438f0176/go.mod h1:jPW/WVKK9YHAvNhRxK0md/EJ228hCsBRufyofKtW8HA=\nk8s.io/utils v0.0.0-20210930125809-cb0fa318a74b h1:wxEMGetGMur3J1xuGLQY7GEQYg9bZxKn3tKo5k/eYcs=\nk8s.io/utils v0.0.0-20210930125809-cb0fa318a74b/go.mod h1:jPW/WVKK9YHAvNhRxK0md/EJ228hCsBRufyofKtW8HA=\nlayeh.com/gopher-json v0.0.0-20190114024228-97fed8db8427 h1:RZkKxMR3jbQxdCEcglq3j7wY3PRJIopAwBlx1RE71X0=\nlayeh.com/gopher-json v0.0.0-20190114024228-97fed8db8427/go.mod h1:ivKkcY8Zxw5ba0jldhZCYYQfGdb2K6u9tbYK1AwMIBc=\nmodernc.org/cc v1.0.0/go.mod h1:1Sk4//wdnYJiUIxnW8ddKpaOJCF37yAdqYnkxUpaYxw=\nmodernc.org/golex v1.0.0/go.mod h1:b/QX9oBD/LhixY6NDh+IdGv17hgB+51fET1i2kPSmvk=\nmodernc.org/mathutil v1.0.0/go.mod h1:wU0vUrJsVWBZ4P6e7xtFJEhFSNsfRLJ8H458uRjg03k=\nmodernc.org/strutil v1.0.0/go.mod h1:lstksw84oURvj9y3tn8lGvRxyRC1S2+g5uuIzNfIOBs=\nmodernc.org/xc v1.0.0/go.mod h1:mRNCo0bvLjGhHO9WsyuKVU4q0ceiDDDoEeWDJHrNx8I=\nrsc.io/binaryregexp v0.2.0/go.mod h1:qTv7/COck+e2FymRvadv62gMdZztPaShugOCi3I+8D8=\nrsc.io/pdf v0.1.1/go.mod h1:n8OzWcQ6Sp37PL01nO98y4iUCRdTGarVfzxY20ICaU4=\nrsc.io/quote/v3 v3.1.0/go.mod h1:yEA65RcK8LyAZtP9Kv3t0HmxON59tX3rD+tICJqUlj0=\nrsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA=\nsigs.k8s.io/apiserver-network-proxy/konnectivity-client v0.0.25/go.mod h1:Mlj9PNLmG9bZ6BHFwFKDo5afkpWyUISkb9Me0GnK66I=\nsigs.k8s.io/controller-runtime v0.11.0 h1:DqO+c8mywcZLFJWILq4iktoECTyn30Bkj0CwgqMpZWQ=\nsigs.k8s.io/controller-runtime v0.11.0/go.mod h1:KKwLiTooNGu+JmLZGn9Sl3Gjmfj66eMbCQznLP5zcqA=\nsigs.k8s.io/json v0.0.0-20211020170558-c049b76a60c6 h1:fD1pz4yfdADVNfFmcP2aBEtudwUQ1AlLnRBALr33v3s=\nsigs.k8s.io/json v0.0.0-20211020170558-c049b76a60c6/go.mod h1:p4QtZmO4uMYipTQNzagwnNoseA6OxSUutVw05NhYDRs=\nsigs.k8s.io/kustomize/api v0.10.1 h1:KgU7hfYoscuqag84kxtzKdEC3mKMb99DPI3a0eaV1d0=\nsigs.k8s.io/kustomize/api v0.10.1/go.mod h1:2FigT1QN6xKdcnGS2Ppp1uIWrtWN28Ms8A3OZUZhwr8=\nsigs.k8s.io/kustomize/cmd/config v0.10.2/go.mod h1:K2aW7nXJ0AaT+VA/eO0/dzFLxmpFcTzudmAgDwPY1HQ=\nsigs.k8s.io/kustomize/kustomize/v4 v4.4.1/go.mod h1:qOKJMMz2mBP+vcS7vK+mNz4HBLjaQSWRY22EF6Tb7Io=\nsigs.k8s.io/kustomize/kyaml v0.13.0 h1:9c+ETyNfSrVhxvphs+K2dzT3dh5oVPPEqPOE/cUpScY=\nsigs.k8s.io/kustomize/kyaml v0.13.0/go.mod h1:FTJxEZ86ScK184NpGSAQcfEqee0nul8oLCK30D47m4E=\nsigs.k8s.io/structured-merge-diff/v4 v4.0.2/go.mod h1:bJZC9H9iH24zzfZ/41RGcq60oK1F7G282QMXDPYydCw=\nsigs.k8s.io/structured-merge-diff/v4 v4.1.2/go.mod h1:j/nl6xW8vLS49O8YvXW1ocPhZawJtm+Yrr7PPRQ0Vg4=\nsigs.k8s.io/structured-merge-diff/v4 v4.2.0 h1:kDvPBbnPk+qYmkHmSo8vKGp438IASWofnbbUKDE/bv0=\nsigs.k8s.io/structured-merge-diff/v4 v4.2.0/go.mod h1:j/nl6xW8vLS49O8YvXW1ocPhZawJtm+Yrr7PPRQ0Vg4=\nsigs.k8s.io/yaml v1.1.0/go.mod h1:UJmg0vDUVViEyp3mgSv9WPwZCDxu4rQW1olrI1uml+o=\nsigs.k8s.io/yaml v1.2.0/go.mod h1:yfXDCHCao9+ENCvLSE62v9VSji2MKu5jeNfTrofGhJc=\nsigs.k8s.io/yaml v1.3.0 h1:a2VclLzOGrwOHDiV8EfBGhvjHvP46CtW5j6POvhYGGo=\nsigs.k8s.io/yaml v1.3.0/go.mod h1:GeOyir5tyXNByN85N/dRIT9es5UQNerPYEKK56eTBm8=\nsourcegraph.com/sourcegraph/appdash v0.0.0-20190731080439-ebfcffb1b5c0/go.mod h1:hI742Nqp5OhwiqlzhgfbWU4mW4yO10fP+LoT9WOswdU=\n", "package v1alpha1\n\nimport (\n\tfmt \"fmt\"\n\t\"sort\"\n\t\"strconv\"\n\tstrings \"strings\"\n\n\t\"github.com/argoproj/argo-cd/v2/util/git\"\n\t\"github.com/argoproj/argo-cd/v2/util/glob\"\n\n\t\"github.com/google/go-cmp/cmp\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\n\t\"k8s.io/apimachinery/pkg/runtime/schema\"\n)\n\n// AppProjectList is list of AppProject resources\n// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\ntype AppProjectList struct {\n\tmetav1.TypeMeta `json:\",inline\"`\n\tmetav1.ListMeta `json:\"metadata\" protobuf:\"bytes,1,opt,name=metadata\"`\n\tItems           []AppProject `json:\"items\" protobuf:\"bytes,2,rep,name=items\"`\n}\n\n// AppProject provides a logical grouping of applications, providing controls for:\n// * where the apps may deploy to (cluster whitelist)\n// * what may be deployed (repository whitelist, resource whitelist/blacklist)\n// * who can access these applications (roles, OIDC group claims bindings)\n// * and what they can do (RBAC policies)\n// * automation access to these roles (JWT tokens)\n// +genclient\n// +genclient:noStatus\n// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\n// +kubebuilder:resource:path=appprojects,shortName=appproj;appprojs\ntype AppProject struct {\n\tmetav1.TypeMeta   `json:\",inline\"`\n\tmetav1.ObjectMeta `json:\"metadata\" protobuf:\"bytes,1,opt,name=metadata\"`\n\tSpec              AppProjectSpec   `json:\"spec\" protobuf:\"bytes,2,opt,name=spec\"`\n\tStatus            AppProjectStatus `json:\"status,omitempty\" protobuf:\"bytes,3,opt,name=status\"`\n}\n\n// AppProjectStatus contains status information for AppProject CRs\ntype AppProjectStatus struct {\n\t// JWTTokensByRole contains a list of JWT tokens issued for a given role\n\tJWTTokensByRole map[string]JWTTokens `json:\"jwtTokensByRole,omitempty\" protobuf:\"bytes,1,opt,name=jwtTokensByRole\"`\n}\n\n// GetRoleByName returns the role in a project by the name with its index\nfunc (p *AppProject) GetRoleByName(name string) (*ProjectRole, int, error) {\n\tfor i, role := range p.Spec.Roles {\n\t\tif name == role.Name {\n\t\t\treturn &role, i, nil\n\t\t}\n\t}\n\treturn nil, -1, fmt.Errorf(\"role '%s' does not exist in project '%s'\", name, p.Name)\n}\n\n// GetJWTTokenFromSpec looks up the index of a JWTToken in a project by id (new token), if not then by the issue at time (old token)\nfunc (p *AppProject) GetJWTTokenFromSpec(roleName string, issuedAt int64, id string) (*JWTToken, int, error) {\n\t// This is for backward compatibility. In the oder version, JWTTokens are stored under spec.role\n\trole, _, err := p.GetRoleByName(roleName)\n\tif err != nil {\n\t\treturn nil, -1, err\n\t}\n\n\tif id != \"\" {\n\t\tfor i, token := range role.JWTTokens {\n\t\t\tif id == token.ID {\n\t\t\t\treturn &token, i, nil\n\t\t\t}\n\t\t}\n\t}\n\n\tif issuedAt != -1 {\n\t\tfor i, token := range role.JWTTokens {\n\t\t\tif issuedAt == token.IssuedAt {\n\t\t\t\treturn &token, i, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil, -1, fmt.Errorf(\"JWT token for role '%s' issued at '%d' does not exist in project '%s'\", role.Name, issuedAt, p.Name)\n}\n\n// GetJWTToken looks up the index of a JWTToken in a project by id (new token), if not then by the issue at time (old token)\nfunc (p *AppProject) GetJWTToken(roleName string, issuedAt int64, id string) (*JWTToken, int, error) {\n\t// This is for newer version, JWTTokens are stored under status\n\tif id != \"\" {\n\t\tfor i, token := range p.Status.JWTTokensByRole[roleName].Items {\n\t\t\tif id == token.ID {\n\t\t\t\treturn &token, i, nil\n\t\t\t}\n\t\t}\n\n\t}\n\n\tif issuedAt != -1 {\n\t\tfor i, token := range p.Status.JWTTokensByRole[roleName].Items {\n\t\t\tif issuedAt == token.IssuedAt {\n\t\t\t\treturn &token, i, nil\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil, -1, fmt.Errorf(\"JWT token for role '%s' issued at '%d' does not exist in project '%s'\", roleName, issuedAt, p.Name)\n}\n\n// RemoveJWTToken removes the specified JWT from an AppProject\nfunc (p AppProject) RemoveJWTToken(roleIndex int, issuedAt int64, id string) error {\n\troleName := p.Spec.Roles[roleIndex].Name\n\t// For backward compatibility\n\t_, jwtTokenIndex, err1 := p.GetJWTTokenFromSpec(roleName, issuedAt, id)\n\tif err1 == nil {\n\t\tp.Spec.Roles[roleIndex].JWTTokens[jwtTokenIndex] = p.Spec.Roles[roleIndex].JWTTokens[len(p.Spec.Roles[roleIndex].JWTTokens)-1]\n\t\tp.Spec.Roles[roleIndex].JWTTokens = p.Spec.Roles[roleIndex].JWTTokens[:len(p.Spec.Roles[roleIndex].JWTTokens)-1]\n\t}\n\n\t// New location for storing JWTToken\n\t_, jwtTokenIndex, err2 := p.GetJWTToken(roleName, issuedAt, id)\n\tif err2 == nil {\n\t\tp.Status.JWTTokensByRole[roleName].Items[jwtTokenIndex] = p.Status.JWTTokensByRole[roleName].Items[len(p.Status.JWTTokensByRole[roleName].Items)-1]\n\t\tp.Status.JWTTokensByRole[roleName] = JWTTokens{Items: p.Status.JWTTokensByRole[roleName].Items[:len(p.Status.JWTTokensByRole[roleName].Items)-1]}\n\t}\n\n\tif err1 == nil || err2 == nil {\n\t\t//If we find this token from either places, we can say there are no error\n\t\treturn nil\n\t} else {\n\t\t//If we could not locate this taken from either places, we can return any of the errors\n\t\treturn err2\n\t}\n}\n\n// TODO: document this method\nfunc (p *AppProject) ValidateJWTTokenID(roleName string, id string) error {\n\trole, _, err := p.GetRoleByName(roleName)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif id == \"\" {\n\t\treturn nil\n\t}\n\tfor _, token := range role.JWTTokens {\n\t\tif id == token.ID {\n\t\t\treturn status.Errorf(codes.InvalidArgument, \"Token id '%s' has been used. \", id)\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc (p *AppProject) ValidateProject() error {\n\tdestKeys := make(map[string]bool)\n\tfor _, dest := range p.Spec.Destinations {\n\t\tkey := fmt.Sprintf(\"%s/%s\", dest.Server, dest.Namespace)\n\t\tif _, ok := destKeys[key]; ok {\n\t\t\treturn status.Errorf(codes.InvalidArgument, \"destination '%s' already added\", key)\n\t\t}\n\t\tdestKeys[key] = true\n\t}\n\tsrcRepos := make(map[string]bool)\n\tfor _, src := range p.Spec.SourceRepos {\n\t\tif _, ok := srcRepos[src]; ok {\n\t\t\treturn status.Errorf(codes.InvalidArgument, \"source repository '%s' already added\", src)\n\t\t}\n\t\tsrcRepos[src] = true\n\t}\n\n\troleNames := make(map[string]bool)\n\tfor _, role := range p.Spec.Roles {\n\t\tif _, ok := roleNames[role.Name]; ok {\n\t\t\treturn status.Errorf(codes.AlreadyExists, \"role '%s' already exists\", role.Name)\n\t\t}\n\t\tif err := validateRoleName(role.Name); err != nil {\n\t\t\treturn err\n\t\t}\n\t\texistingPolicies := make(map[string]bool)\n\t\tfor _, policy := range role.Policies {\n\t\t\tif _, ok := existingPolicies[policy]; ok {\n\t\t\t\treturn status.Errorf(codes.AlreadyExists, \"policy '%s' already exists for role '%s'\", policy, role.Name)\n\t\t\t}\n\t\t\tif err := validatePolicy(p.Name, role.Name, policy); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\texistingPolicies[policy] = true\n\t\t}\n\t\texistingGroups := make(map[string]bool)\n\t\tfor _, group := range role.Groups {\n\t\t\tif _, ok := existingGroups[group]; ok {\n\t\t\t\treturn status.Errorf(codes.AlreadyExists, \"group '%s' already exists for role '%s'\", group, role.Name)\n\t\t\t}\n\t\t\tif err := validateGroupName(group); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\texistingGroups[group] = true\n\t\t}\n\t\troleNames[role.Name] = true\n\t}\n\n\tif p.Spec.SyncWindows.HasWindows() {\n\t\texistingWindows := make(map[string]bool)\n\t\tfor _, window := range p.Spec.SyncWindows {\n\t\t\tif _, ok := existingWindows[window.Kind+window.Schedule+window.Duration]; ok {\n\t\t\t\treturn status.Errorf(codes.AlreadyExists, \"window '%s':'%s':'%s' already exists, update or edit\", window.Kind, window.Schedule, window.Duration)\n\t\t\t}\n\t\t\terr := window.Validate()\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tif len(window.Applications) == 0 && len(window.Namespaces) == 0 && len(window.Clusters) == 0 {\n\t\t\t\treturn status.Errorf(codes.OutOfRange, \"window '%s':'%s':'%s' requires one of application, cluster or namespace\", window.Kind, window.Schedule, window.Duration)\n\t\t\t}\n\t\t\texistingWindows[window.Kind+window.Schedule+window.Duration] = true\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// AddGroupToRole adds an OIDC group to a role\nfunc (p *AppProject) AddGroupToRole(roleName, group string) (bool, error) {\n\trole, roleIndex, err := p.GetRoleByName(roleName)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tfor _, roleGroup := range role.Groups {\n\t\tif group == roleGroup {\n\t\t\treturn false, nil\n\t\t}\n\t}\n\trole.Groups = append(role.Groups, group)\n\tp.Spec.Roles[roleIndex] = *role\n\treturn true, nil\n}\n\n// RemoveGroupFromRole removes an OIDC group from a role\nfunc (p *AppProject) RemoveGroupFromRole(roleName, group string) (bool, error) {\n\trole, roleIndex, err := p.GetRoleByName(roleName)\n\tif err != nil {\n\t\treturn false, err\n\t}\n\tfor i, roleGroup := range role.Groups {\n\t\tif group == roleGroup {\n\t\t\trole.Groups = append(role.Groups[:i], role.Groups[i+1:]...)\n\t\t\tp.Spec.Roles[roleIndex] = *role\n\t\t\treturn true, nil\n\t\t}\n\t}\n\treturn false, nil\n}\n\n// NormalizePolicies normalizes the policies in the project\nfunc (p *AppProject) NormalizePolicies() {\n\tfor i, role := range p.Spec.Roles {\n\t\tvar normalizedPolicies []string\n\t\tfor _, policy := range role.Policies {\n\t\t\tnormalizedPolicies = append(normalizedPolicies, p.normalizePolicy(policy))\n\t\t}\n\t\tp.Spec.Roles[i].Policies = normalizedPolicies\n\t}\n}\n\nfunc (p *AppProject) normalizePolicy(policy string) string {\n\tpolicyComponents := strings.Split(policy, \",\")\n\tnormalizedPolicy := \"\"\n\tfor _, component := range policyComponents {\n\t\tif normalizedPolicy == \"\" {\n\t\t\tnormalizedPolicy = component\n\t\t} else {\n\t\t\tnormalizedPolicy = fmt.Sprintf(\"%s, %s\", normalizedPolicy, strings.Trim(component, \" \"))\n\t\t}\n\t}\n\treturn normalizedPolicy\n}\n\n// ProjectPoliciesString returns a Casbin formatted string of a project's policies for each role\nfunc (proj *AppProject) ProjectPoliciesString() string {\n\tvar policies []string\n\tfor _, role := range proj.Spec.Roles {\n\t\tprojectPolicy := fmt.Sprintf(\"p, proj:%s:%s, projects, get, %s, allow\", proj.ObjectMeta.Name, role.Name, proj.ObjectMeta.Name)\n\t\tpolicies = append(policies, projectPolicy)\n\t\tpolicies = append(policies, role.Policies...)\n\t\tfor _, groupName := range role.Groups {\n\t\t\tpolicies = append(policies, fmt.Sprintf(\"g, %s, proj:%s:%s\", groupName, proj.ObjectMeta.Name, role.Name))\n\t\t}\n\t}\n\treturn strings.Join(policies, \"\\n\")\n}\n\n// IsGroupKindPermitted validates if the given resource group/kind is permitted to be deployed in the project\nfunc (proj AppProject) IsGroupKindPermitted(gk schema.GroupKind, namespaced bool) bool {\n\tvar isWhiteListed, isBlackListed bool\n\tres := metav1.GroupKind{Group: gk.Group, Kind: gk.Kind}\n\n\tif namespaced {\n\t\tnamespaceWhitelist := proj.Spec.NamespaceResourceWhitelist\n\t\tnamespaceBlacklist := proj.Spec.NamespaceResourceBlacklist\n\n\t\tisWhiteListed = namespaceWhitelist == nil || len(namespaceWhitelist) != 0 && isResourceInList(res, namespaceWhitelist)\n\t\tisBlackListed = len(namespaceBlacklist) != 0 && isResourceInList(res, namespaceBlacklist)\n\t\treturn isWhiteListed && !isBlackListed\n\t}\n\n\tclusterWhitelist := proj.Spec.ClusterResourceWhitelist\n\tclusterBlacklist := proj.Spec.ClusterResourceBlacklist\n\n\tisWhiteListed = len(clusterWhitelist) != 0 && isResourceInList(res, clusterWhitelist)\n\tisBlackListed = len(clusterBlacklist) != 0 && isResourceInList(res, clusterBlacklist)\n\treturn isWhiteListed && !isBlackListed\n}\n\n// IsLiveResourcePermitted returns whether a live resource found in the cluster is permitted by an AppProject\nfunc (proj AppProject) IsLiveResourcePermitted(un *unstructured.Unstructured, server string, name string) bool {\n\treturn proj.IsResourcePermitted(un.GroupVersionKind().GroupKind(), un.GetNamespace(), ApplicationDestination{Server: server, Name: name})\n}\n\nfunc (proj AppProject) IsResourcePermitted(groupKind schema.GroupKind, namespace string, dest ApplicationDestination) bool {\n\tif !proj.IsGroupKindPermitted(groupKind, namespace != \"\") {\n\t\treturn false\n\t}\n\tif namespace != \"\" {\n\t\treturn proj.IsDestinationPermitted(ApplicationDestination{Server: dest.Server, Name: dest.Name, Namespace: namespace})\n\t}\n\treturn true\n}\n\n// HasFinalizer returns true if a resource finalizer is set on an AppProject\nfunc (proj AppProject) HasFinalizer() bool {\n\treturn getFinalizerIndex(proj.ObjectMeta, ResourcesFinalizerName) > -1\n}\n\n// RemoveFinalizer removes a resource finalizer from an AppProject\nfunc (proj *AppProject) RemoveFinalizer() {\n\tsetFinalizer(&proj.ObjectMeta, ResourcesFinalizerName, false)\n}\n\nfunc globMatch(pattern string, val string, separators ...rune) bool {\n\tif pattern == \"*\" {\n\t\treturn true\n\t}\n\treturn glob.Match(pattern, val, separators...)\n}\n\n// IsSourcePermitted validates if the provided application's source is a one of the allowed sources for the project.\nfunc (proj AppProject) IsSourcePermitted(src ApplicationSource) bool {\n\tsrcNormalized := git.NormalizeGitURL(src.RepoURL)\n\tfor _, repoURL := range proj.Spec.SourceRepos {\n\t\tnormalized := git.NormalizeGitURL(repoURL)\n\t\tif globMatch(normalized, srcNormalized, '/') {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// IsDestinationPermitted validates if the provided application's destination is one of the allowed destinations for the project\nfunc (proj AppProject) IsDestinationPermitted(dst ApplicationDestination) bool {\n\tfor _, item := range proj.Spec.Destinations {\n\t\tdstNameMatched := dst.Name != \"\" && globMatch(item.Name, dst.Name)\n\t\tdstServerMatched := dst.Server != \"\" && globMatch(item.Server, dst.Server)\n\t\tif (dstServerMatched || dstNameMatched) && globMatch(item.Namespace, dst.Namespace) {\n\t\t\treturn true\n\t\t}\n\t}\n\treturn false\n}\n\n// TODO: document this method\nfunc (proj *AppProject) NormalizeJWTTokens() bool {\n\tneedNormalize := false\n\tfor i, role := range proj.Spec.Roles {\n\t\tfor j, token := range role.JWTTokens {\n\t\t\tif token.ID == \"\" {\n\t\t\t\ttoken.ID = strconv.FormatInt(token.IssuedAt, 10)\n\t\t\t\trole.JWTTokens[j] = token\n\t\t\t\tneedNormalize = true\n\t\t\t}\n\t\t}\n\t\tproj.Spec.Roles[i] = role\n\t}\n\tfor _, roleTokenEntry := range proj.Status.JWTTokensByRole {\n\t\tfor j, token := range roleTokenEntry.Items {\n\t\t\tif token.ID == \"\" {\n\t\t\t\ttoken.ID = strconv.FormatInt(token.IssuedAt, 10)\n\t\t\t\troleTokenEntry.Items[j] = token\n\t\t\t\tneedNormalize = true\n\t\t\t}\n\t\t}\n\t}\n\tneedSync := syncJWTTokenBetweenStatusAndSpec(proj)\n\treturn needNormalize || needSync\n}\n\nfunc syncJWTTokenBetweenStatusAndSpec(proj *AppProject) bool {\n\texistingRole := map[string]bool{}\n\tneedSync := false\n\tfor roleIndex, role := range proj.Spec.Roles {\n\t\texistingRole[role.Name] = true\n\n\t\ttokensInSpec := role.JWTTokens\n\t\ttokensInStatus := []JWTToken{}\n\t\tif proj.Status.JWTTokensByRole == nil {\n\t\t\ttokensByRole := make(map[string]JWTTokens)\n\t\t\tproj.Status.JWTTokensByRole = tokensByRole\n\t\t} else {\n\t\t\ttokensInStatus = proj.Status.JWTTokensByRole[role.Name].Items\n\t\t}\n\t\ttokens := jwtTokensCombine(tokensInStatus, tokensInSpec)\n\n\t\tsort.Slice(proj.Spec.Roles[roleIndex].JWTTokens, func(i, j int) bool {\n\t\t\treturn proj.Spec.Roles[roleIndex].JWTTokens[i].IssuedAt > proj.Spec.Roles[roleIndex].JWTTokens[j].IssuedAt\n\t\t})\n\t\tsort.Slice(proj.Status.JWTTokensByRole[role.Name].Items, func(i, j int) bool {\n\t\t\treturn proj.Status.JWTTokensByRole[role.Name].Items[i].IssuedAt > proj.Status.JWTTokensByRole[role.Name].Items[j].IssuedAt\n\t\t})\n\t\tif !cmp.Equal(tokens, proj.Spec.Roles[roleIndex].JWTTokens) || !cmp.Equal(tokens, proj.Status.JWTTokensByRole[role.Name].Items) {\n\t\t\tneedSync = true\n\t\t}\n\n\t\tproj.Spec.Roles[roleIndex].JWTTokens = tokens\n\t\tproj.Status.JWTTokensByRole[role.Name] = JWTTokens{Items: tokens}\n\t}\n\tif proj.Status.JWTTokensByRole != nil {\n\t\tfor role := range proj.Status.JWTTokensByRole {\n\t\t\tif !existingRole[role] {\n\t\t\t\tdelete(proj.Status.JWTTokensByRole, role)\n\t\t\t\tneedSync = true\n\t\t\t}\n\t\t}\n\t}\n\n\treturn needSync\n}\n\nfunc jwtTokensCombine(tokens1 []JWTToken, tokens2 []JWTToken) []JWTToken {\n\ttokensMap := make(map[string]JWTToken)\n\tfor _, token := range append(tokens1, tokens2...) {\n\t\ttokensMap[token.ID] = token\n\t}\n\n\tvar tokens []JWTToken\n\tfor _, v := range tokensMap {\n\t\ttokens = append(tokens, v)\n\t}\n\n\tsort.Slice(tokens, func(i, j int) bool {\n\t\treturn tokens[i].IssuedAt > tokens[j].IssuedAt\n\t})\n\treturn tokens\n}\n", "package application\n\nimport (\n\t\"encoding/json\"\n\t\"errors\"\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n\t\"sort\"\n\t\"strconv\"\n\t\"strings\"\n\t\"time\"\n\n\tkubecache \"github.com/argoproj/gitops-engine/pkg/cache\"\n\t\"github.com/argoproj/gitops-engine/pkg/diff\"\n\t\"github.com/argoproj/gitops-engine/pkg/sync/common\"\n\t\"github.com/argoproj/gitops-engine/pkg/utils/kube\"\n\t\"github.com/argoproj/gitops-engine/pkg/utils/text\"\n\t\"github.com/argoproj/pkg/sync\"\n\tjsonpatch \"github.com/evanphx/json-patch\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"golang.org/x/net/context\"\n\t\"google.golang.org/grpc/codes\"\n\t\"google.golang.org/grpc/status\"\n\tv1 \"k8s.io/api/core/v1\"\n\tapierr \"k8s.io/apimachinery/pkg/api/errors\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\n\t\"k8s.io/apimachinery/pkg/fields\"\n\t\"k8s.io/apimachinery/pkg/labels\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\t\"k8s.io/apimachinery/pkg/watch\"\n\t\"k8s.io/client-go/kubernetes\"\n\t\"k8s.io/client-go/rest\"\n\t\"k8s.io/client-go/tools/cache\"\n\t\"k8s.io/utils/pointer\"\n\n\targocommon \"github.com/argoproj/argo-cd/v2/common\"\n\t\"github.com/argoproj/argo-cd/v2/pkg/apiclient/application\"\n\t\"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1\"\n\tappv1 \"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1\"\n\tappclientset \"github.com/argoproj/argo-cd/v2/pkg/client/clientset/versioned\"\n\tapplisters \"github.com/argoproj/argo-cd/v2/pkg/client/listers/application/v1alpha1\"\n\t\"github.com/argoproj/argo-cd/v2/reposerver/apiclient\"\n\tservercache \"github.com/argoproj/argo-cd/v2/server/cache\"\n\t\"github.com/argoproj/argo-cd/v2/server/rbacpolicy\"\n\t\"github.com/argoproj/argo-cd/v2/util/argo\"\n\targoutil \"github.com/argoproj/argo-cd/v2/util/argo\"\n\t\"github.com/argoproj/argo-cd/v2/util/db\"\n\t\"github.com/argoproj/argo-cd/v2/util/env\"\n\t\"github.com/argoproj/argo-cd/v2/util/git\"\n\t\"github.com/argoproj/argo-cd/v2/util/io\"\n\tioutil \"github.com/argoproj/argo-cd/v2/util/io\"\n\t\"github.com/argoproj/argo-cd/v2/util/lua\"\n\t\"github.com/argoproj/argo-cd/v2/util/rbac\"\n\t\"github.com/argoproj/argo-cd/v2/util/session\"\n\t\"github.com/argoproj/argo-cd/v2/util/settings\"\n)\n\nconst (\n\tmaxPodLogsToRender                 = 10\n\tbackgroundPropagationPolicy string = \"background\"\n\tforegroundPropagationPolicy string = \"foreground\"\n)\n\nvar (\n\twatchAPIBufferSize = env.ParseNumFromEnv(argocommon.EnvWatchAPIBufferSize, 1000, 0, math.MaxInt32)\n)\n\n// Server provides a Application service\ntype Server struct {\n\tns             string\n\tkubeclientset  kubernetes.Interface\n\tappclientset   appclientset.Interface\n\tappLister      applisters.ApplicationNamespaceLister\n\tappInformer    cache.SharedIndexInformer\n\tappBroadcaster *broadcasterHandler\n\trepoClientset  apiclient.Clientset\n\tkubectl        kube.Kubectl\n\tdb             db.ArgoDB\n\tenf            *rbac.Enforcer\n\tprojectLock    sync.KeyLock\n\tauditLogger    *argo.AuditLogger\n\tsettingsMgr    *settings.SettingsManager\n\tcache          *servercache.Cache\n\tprojInformer   cache.SharedIndexInformer\n}\n\n// NewServer returns a new instance of the Application service\nfunc NewServer(\n\tnamespace string,\n\tkubeclientset kubernetes.Interface,\n\tappclientset appclientset.Interface,\n\tappLister applisters.ApplicationNamespaceLister,\n\tappInformer cache.SharedIndexInformer,\n\trepoClientset apiclient.Clientset,\n\tcache *servercache.Cache,\n\tkubectl kube.Kubectl,\n\tdb db.ArgoDB,\n\tenf *rbac.Enforcer,\n\tprojectLock sync.KeyLock,\n\tsettingsMgr *settings.SettingsManager,\n\tprojInformer cache.SharedIndexInformer,\n) application.ApplicationServiceServer {\n\tappBroadcaster := &broadcasterHandler{}\n\tappInformer.AddEventHandler(appBroadcaster)\n\treturn &Server{\n\t\tns:             namespace,\n\t\tappclientset:   appclientset,\n\t\tappLister:      appLister,\n\t\tappInformer:    appInformer,\n\t\tappBroadcaster: appBroadcaster,\n\t\tkubeclientset:  kubeclientset,\n\t\tcache:          cache,\n\t\tdb:             db,\n\t\trepoClientset:  repoClientset,\n\t\tkubectl:        kubectl,\n\t\tenf:            enf,\n\t\tprojectLock:    projectLock,\n\t\tauditLogger:    argo.NewAuditLogger(namespace, kubeclientset, \"argocd-server\"),\n\t\tsettingsMgr:    settingsMgr,\n\t\tprojInformer:   projInformer,\n\t}\n}\n\n// appRBACName formats fully qualified application name for RBAC check\nfunc appRBACName(app appv1.Application) string {\n\treturn fmt.Sprintf(\"%s/%s\", app.Spec.GetProject(), app.Name)\n}\n\n// List returns list of applications\nfunc (s *Server) List(ctx context.Context, q *application.ApplicationQuery) (*appv1.ApplicationList, error) {\n\tlabelsMap, err := labels.ConvertSelectorToLabelsMap(q.Selector)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tapps, err := s.appLister.List(labelsMap.AsSelector())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tnewItems := make([]appv1.Application, 0)\n\tfor _, a := range apps {\n\t\tif s.enf.Enforce(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionGet, appRBACName(*a)) {\n\t\t\tnewItems = append(newItems, *a)\n\t\t}\n\t}\n\tif q.Name != nil {\n\t\tnewItems, err = argoutil.FilterByName(newItems, *q.Name)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\t// Filter applications by name\n\tnewItems = argoutil.FilterByProjects(newItems, q.Projects)\n\n\t// Filter applications by source repo URL\n\tnewItems = argoutil.FilterByRepo(newItems, q.Repo)\n\n\t// Sort found applications by name\n\tsort.Slice(newItems, func(i, j int) bool {\n\t\treturn newItems[i].Name < newItems[j].Name\n\t})\n\n\tappList := appv1.ApplicationList{\n\t\tListMeta: metav1.ListMeta{\n\t\t\tResourceVersion: s.appInformer.LastSyncResourceVersion(),\n\t\t},\n\t\tItems: newItems,\n\t}\n\treturn &appList, nil\n}\n\n// Create creates an application\nfunc (s *Server) Create(ctx context.Context, q *application.ApplicationCreateRequest) (*appv1.Application, error) {\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionCreate, appRBACName(q.Application)); err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.projectLock.RLock(q.Application.Spec.Project)\n\tdefer s.projectLock.RUnlock(q.Application.Spec.Project)\n\n\ta := q.Application\n\tvalidate := true\n\tif q.Validate != nil {\n\t\tvalidate = *q.Validate\n\t}\n\terr := s.validateAndNormalizeApp(ctx, &a, validate)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tcreated, err := s.appclientset.ArgoprojV1alpha1().Applications(s.ns).Create(ctx, &a, metav1.CreateOptions{})\n\tif err == nil {\n\t\ts.logAppEvent(created, ctx, argo.EventReasonResourceCreated, \"created application\")\n\t\ts.waitSync(created)\n\t\treturn created, nil\n\t}\n\tif !apierr.IsAlreadyExists(err) {\n\t\treturn nil, err\n\t}\n\t// act idempotent if existing spec matches new spec\n\texisting, err := s.appLister.Get(a.Name)\n\tif err != nil {\n\t\treturn nil, status.Errorf(codes.Internal, \"unable to check existing application details: %v\", err)\n\t}\n\tequalSpecs := reflect.DeepEqual(existing.Spec, a.Spec) &&\n\t\treflect.DeepEqual(existing.Labels, a.Labels) &&\n\t\treflect.DeepEqual(existing.Annotations, a.Annotations) &&\n\t\treflect.DeepEqual(existing.Finalizers, a.Finalizers)\n\n\tif equalSpecs {\n\t\treturn existing, nil\n\t}\n\tif q.Upsert == nil || !*q.Upsert {\n\t\treturn nil, status.Errorf(codes.InvalidArgument, \"existing application spec is different, use upsert flag to force update\")\n\t}\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionUpdate, appRBACName(a)); err != nil {\n\t\treturn nil, err\n\t}\n\tupdated, err := s.updateApp(existing, &a, ctx, true)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn updated, nil\n}\n\nfunc (s *Server) queryRepoServer(ctx context.Context, a *v1alpha1.Application, action func(\n\tclient apiclient.RepoServerServiceClient,\n\trepo *appv1.Repository,\n\thelmRepos []*appv1.Repository,\n\thelmCreds []*v1alpha1.RepoCreds,\n\thelmOptions *v1alpha1.HelmOptions,\n\tkustomizeOptions *v1alpha1.KustomizeOptions,\n\tenabledSourceTypes map[string]bool,\n) error) error {\n\n\tcloser, client, err := s.repoClientset.NewRepoServerClient()\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer ioutil.Close(closer)\n\trepo, err := s.db.GetRepository(ctx, a.Spec.Source.RepoURL)\n\tif err != nil {\n\t\treturn err\n\t}\n\tkustomizeSettings, err := s.settingsMgr.GetKustomizeSettings()\n\tif err != nil {\n\t\treturn err\n\t}\n\tkustomizeOptions, err := kustomizeSettings.GetOptions(a.Spec.Source)\n\tif err != nil {\n\t\treturn err\n\t}\n\tproj, err := argo.GetAppProject(&a.Spec, applisters.NewAppProjectLister(s.projInformer.GetIndexer()), s.ns, s.settingsMgr, s.db, ctx)\n\tif err != nil {\n\t\tif apierr.IsNotFound(err) {\n\t\t\treturn status.Errorf(codes.InvalidArgument, \"application references project %s which does not exist\", a.Spec.Project)\n\t\t}\n\t\treturn err\n\t}\n\n\thelmRepos, err := s.db.ListHelmRepositories(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tpermittedHelmRepos, err := argo.GetPermittedRepos(proj, helmRepos)\n\tif err != nil {\n\t\treturn err\n\t}\n\thelmRepositoryCredentials, err := s.db.GetAllHelmRepositoryCredentials(ctx)\n\tif err != nil {\n\t\treturn err\n\t}\n\thelmOptions, err := s.settingsMgr.GetHelmSettings()\n\tif err != nil {\n\t\treturn err\n\t}\n\tpermittedHelmCredentials, err := argo.GetPermittedReposCredentials(proj, helmRepositoryCredentials)\n\tif err != nil {\n\t\treturn err\n\t}\n\tenabledSourceTypes, err := s.settingsMgr.GetEnabledSourceTypes()\n\tif err != nil {\n\t\treturn err\n\t}\n\treturn action(client, repo, permittedHelmRepos, permittedHelmCredentials, helmOptions, kustomizeOptions, enabledSourceTypes)\n}\n\n// GetManifests returns application manifests\nfunc (s *Server) GetManifests(ctx context.Context, q *application.ApplicationManifestQuery) (*apiclient.ManifestResponse, error) {\n\ta, err := s.appLister.Get(*q.Name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionGet, appRBACName(*a)); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar manifestInfo *apiclient.ManifestResponse\n\terr = s.queryRepoServer(ctx, a, func(\n\t\tclient apiclient.RepoServerServiceClient, repo *appv1.Repository, helmRepos []*appv1.Repository, helmCreds []*appv1.RepoCreds, helmOptions *appv1.HelmOptions, kustomizeOptions *appv1.KustomizeOptions, enableGenerateManifests map[string]bool) error {\n\t\trevision := a.Spec.Source.TargetRevision\n\t\tif q.Revision != \"\" {\n\t\t\trevision = q.Revision\n\t\t}\n\t\tappInstanceLabelKey, err := s.settingsMgr.GetAppInstanceLabelKey()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tplugins, err := s.plugins()\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tconfig, err := s.getApplicationClusterConfig(ctx, a)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tserverVersion, err := s.kubectl.GetServerVersion(config)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tapiResources, err := s.kubectl.GetAPIResources(config, false, kubecache.NewNoopSettings())\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\n\t\tmanifestInfo, err = client.GenerateManifest(ctx, &apiclient.ManifestRequest{\n\t\t\tRepo:               repo,\n\t\t\tRevision:           revision,\n\t\t\tAppLabelKey:        appInstanceLabelKey,\n\t\t\tAppName:            a.Name,\n\t\t\tNamespace:          a.Spec.Destination.Namespace,\n\t\t\tApplicationSource:  &a.Spec.Source,\n\t\t\tRepos:              helmRepos,\n\t\t\tPlugins:            plugins,\n\t\t\tKustomizeOptions:   kustomizeOptions,\n\t\t\tKubeVersion:        serverVersion,\n\t\t\tApiVersions:        argo.APIResourcesToStrings(apiResources, true),\n\t\t\tHelmRepoCreds:      helmCreds,\n\t\t\tHelmOptions:        helmOptions,\n\t\t\tTrackingMethod:     string(argoutil.GetTrackingMethod(s.settingsMgr)),\n\t\t\tEnabledSourceTypes: enableGenerateManifests,\n\t\t})\n\t\treturn err\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor i, manifest := range manifestInfo.Manifests {\n\t\tobj := &unstructured.Unstructured{}\n\t\terr = json.Unmarshal([]byte(manifest), obj)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif obj.GetKind() == kube.SecretKind && obj.GroupVersionKind().Group == \"\" {\n\t\t\tobj, _, err = diff.HideSecretData(obj, nil)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tdata, err := json.Marshal(obj)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\tmanifestInfo.Manifests[i] = string(data)\n\t\t}\n\t}\n\n\treturn manifestInfo, nil\n}\n\n// Get returns an application by name\nfunc (s *Server) Get(ctx context.Context, q *application.ApplicationQuery) (*appv1.Application, error) {\n\t// We must use a client Get instead of an informer Get, because it's common to call Get immediately\n\t// following a Watch (which is not yet powered by an informer), and the Get must reflect what was\n\t// previously seen by the client.\n\ta, err := s.appclientset.ArgoprojV1alpha1().Applications(s.ns).Get(ctx, q.GetName(), metav1.GetOptions{\n\t\tResourceVersion: q.ResourceVersion,\n\t})\n\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionGet, appRBACName(*a)); err != nil {\n\t\treturn nil, err\n\t}\n\tif q.Refresh == nil {\n\t\treturn a, nil\n\t}\n\n\trefreshType := appv1.RefreshTypeNormal\n\tif *q.Refresh == string(appv1.RefreshTypeHard) {\n\t\trefreshType = appv1.RefreshTypeHard\n\t}\n\tappIf := s.appclientset.ArgoprojV1alpha1().Applications(s.ns)\n\n\t// subscribe early with buffered channel to ensure we don't miss events\n\tevents := make(chan *appv1.ApplicationWatchEvent, watchAPIBufferSize)\n\tunsubscribe := s.appBroadcaster.Subscribe(events, func(event *appv1.ApplicationWatchEvent) bool {\n\t\treturn event.Application.Name == q.GetName()\n\t})\n\tdefer unsubscribe()\n\n\tapp, err := argoutil.RefreshApp(appIf, *q.Name, refreshType)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif refreshType == appv1.RefreshTypeHard {\n\t\t// force refresh cached application details\n\t\tif err := s.queryRepoServer(ctx, a, func(\n\t\t\tclient apiclient.RepoServerServiceClient,\n\t\t\trepo *appv1.Repository,\n\t\t\thelmRepos []*appv1.Repository,\n\t\t\t_ []*appv1.RepoCreds,\n\t\t\thelmOptions *appv1.HelmOptions,\n\t\t\tkustomizeOptions *appv1.KustomizeOptions,\n\t\t\tenabledSourceTypes map[string]bool,\n\t\t) error {\n\t\t\t_, err := client.GetAppDetails(ctx, &apiclient.RepoServerAppDetailsQuery{\n\t\t\t\tRepo:               repo,\n\t\t\t\tSource:             &app.Spec.Source,\n\t\t\t\tAppName:            app.Name,\n\t\t\t\tKustomizeOptions:   kustomizeOptions,\n\t\t\t\tRepos:              helmRepos,\n\t\t\t\tNoCache:            true,\n\t\t\t\tTrackingMethod:     string(argoutil.GetTrackingMethod(s.settingsMgr)),\n\t\t\t\tEnabledSourceTypes: enabledSourceTypes,\n\t\t\t\tHelmOptions:        helmOptions,\n\t\t\t})\n\t\t\treturn err\n\t\t}); err != nil {\n\t\t\tlog.Warnf(\"Failed to force refresh application details: %v\", err)\n\t\t}\n\t}\n\n\tminVersion := 0\n\tif minVersion, err = strconv.Atoi(app.ResourceVersion); err != nil {\n\t\tminVersion = 0\n\t}\n\n\tfor {\n\t\tselect {\n\t\tcase <-ctx.Done():\n\t\t\treturn nil, fmt.Errorf(\"application refresh deadline exceeded\")\n\t\tcase event := <-events:\n\t\t\tif appVersion, err := strconv.Atoi(event.Application.ResourceVersion); err == nil && appVersion > minVersion {\n\t\t\t\tannotations := event.Application.GetAnnotations()\n\t\t\t\tif annotations == nil {\n\t\t\t\t\tannotations = make(map[string]string)\n\t\t\t\t}\n\t\t\t\tif _, ok := annotations[appv1.AnnotationKeyRefresh]; !ok {\n\t\t\t\t\treturn &event.Application, nil\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// ListResourceEvents returns a list of event resources\nfunc (s *Server) ListResourceEvents(ctx context.Context, q *application.ApplicationResourceEventsQuery) (*v1.EventList, error) {\n\ta, err := s.appLister.Get(*q.Name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionGet, appRBACName(*a)); err != nil {\n\t\treturn nil, err\n\t}\n\tvar (\n\t\tkubeClientset kubernetes.Interface\n\t\tfieldSelector string\n\t\tnamespace     string\n\t)\n\t// There are two places where we get events. If we are getting application events, we query\n\t// our own cluster. If it is events on a resource on an external cluster, then we query the\n\t// external cluster using its rest.Config\n\tif q.ResourceName == \"\" && q.ResourceUID == \"\" {\n\t\tkubeClientset = s.kubeclientset\n\t\tnamespace = a.Namespace\n\t\tfieldSelector = fields.SelectorFromSet(map[string]string{\n\t\t\t\"involvedObject.name\":      a.Name,\n\t\t\t\"involvedObject.uid\":       string(a.UID),\n\t\t\t\"involvedObject.namespace\": a.Namespace,\n\t\t}).String()\n\t} else {\n\t\ttree, err := s.getAppResources(ctx, a)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfound := false\n\t\tfor _, n := range append(tree.Nodes, tree.OrphanedNodes...) {\n\t\t\tif n.ResourceRef.UID == q.ResourceUID && n.ResourceRef.Name == q.ResourceName && n.ResourceRef.Namespace == q.ResourceNamespace {\n\t\t\t\tfound = true\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif !found {\n\t\t\treturn nil, status.Errorf(codes.InvalidArgument, \"%s not found as part of application %s\", q.ResourceName, *q.Name)\n\t\t}\n\n\t\tnamespace = q.ResourceNamespace\n\t\tvar config *rest.Config\n\t\tconfig, err = s.getApplicationClusterConfig(ctx, a)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tkubeClientset, err = kubernetes.NewForConfig(config)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tfieldSelector = fields.SelectorFromSet(map[string]string{\n\t\t\t\"involvedObject.name\":      q.ResourceName,\n\t\t\t\"involvedObject.uid\":       q.ResourceUID,\n\t\t\t\"involvedObject.namespace\": namespace,\n\t\t}).String()\n\t}\n\tlog.Infof(\"Querying for resource events with field selector: %s\", fieldSelector)\n\topts := metav1.ListOptions{FieldSelector: fieldSelector}\n\treturn kubeClientset.CoreV1().Events(namespace).List(ctx, opts)\n}\n\nfunc (s *Server) validateAndUpdateApp(ctx context.Context, newApp *appv1.Application, merge bool, validate bool) (*appv1.Application, error) {\n\ts.projectLock.RLock(newApp.Spec.GetProject())\n\tdefer s.projectLock.RUnlock(newApp.Spec.GetProject())\n\n\tapp, err := s.appclientset.ArgoprojV1alpha1().Applications(s.ns).Get(ctx, newApp.Name, metav1.GetOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\terr = s.validateAndNormalizeApp(ctx, newApp, validate)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn s.updateApp(app, newApp, ctx, merge)\n}\n\nfunc mergeStringMaps(items ...map[string]string) map[string]string {\n\tres := make(map[string]string)\n\tfor _, m := range items {\n\t\tif m == nil {\n\t\t\tcontinue\n\t\t}\n\t\tfor k, v := range m {\n\t\t\tres[k] = v\n\t\t}\n\t}\n\treturn res\n}\n\nvar informerSyncTimeout = 2 * time.Second\n\n// waitSync is a helper to wait until the application informer cache is synced after create/update.\n// It waits until the app in the informer, has a resource version greater than the version in the\n// supplied app, or after 2 seconds, whichever comes first. Returns true if synced.\n// We use an informer cache for read operations (Get, List). Since the cache is only\n// eventually consistent, it is possible that it doesn't reflect an application change immediately\n// after a mutating API call (create/update). This function should be called after a creates &\n// update to give a probable (but not guaranteed) chance of being up-to-date after the create/update.\nfunc (s *Server) waitSync(app *appv1.Application) {\n\tlogCtx := log.WithField(\"application\", app.Name)\n\tdeadline := time.Now().Add(informerSyncTimeout)\n\tminVersion, err := strconv.Atoi(app.ResourceVersion)\n\tif err != nil {\n\t\tlogCtx.Warnf(\"waitSync failed: could not parse resource version %s\", app.ResourceVersion)\n\t\ttime.Sleep(50 * time.Millisecond) // sleep anyway\n\t\treturn\n\t}\n\tfor {\n\t\tif currApp, err := s.appLister.Get(app.Name); err == nil {\n\t\t\tcurrVersion, err := strconv.Atoi(currApp.ResourceVersion)\n\t\t\tif err == nil && currVersion >= minVersion {\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\tif time.Now().After(deadline) {\n\t\t\tbreak\n\t\t}\n\t\ttime.Sleep(20 * time.Millisecond)\n\t}\n\tlogCtx.Warnf(\"waitSync failed: timed out\")\n}\n\nfunc (s *Server) updateApp(app *appv1.Application, newApp *appv1.Application, ctx context.Context, merge bool) (*appv1.Application, error) {\n\tfor i := 0; i < 10; i++ {\n\t\tapp.Spec = newApp.Spec\n\t\tif merge {\n\t\t\tapp.Labels = mergeStringMaps(app.Labels, newApp.Labels)\n\t\t\tapp.Annotations = mergeStringMaps(app.Annotations, newApp.Annotations)\n\t\t} else {\n\t\t\tapp.Labels = newApp.Labels\n\t\t\tapp.Annotations = newApp.Annotations\n\t\t}\n\n\t\tapp.Finalizers = newApp.Finalizers\n\n\t\tres, err := s.appclientset.ArgoprojV1alpha1().Applications(s.ns).Update(ctx, app, metav1.UpdateOptions{})\n\t\tif err == nil {\n\t\t\ts.logAppEvent(app, ctx, argo.EventReasonResourceUpdated, \"updated application spec\")\n\t\t\ts.waitSync(res)\n\t\t\treturn res, nil\n\t\t}\n\t\tif !apierr.IsConflict(err) {\n\t\t\treturn nil, err\n\t\t}\n\n\t\tapp, err = s.appclientset.ArgoprojV1alpha1().Applications(s.ns).Get(ctx, newApp.Name, metav1.GetOptions{})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn nil, status.Errorf(codes.Internal, \"Failed to update application. Too many conflicts\")\n}\n\n// Update updates an application\nfunc (s *Server) Update(ctx context.Context, q *application.ApplicationUpdateRequest) (*appv1.Application, error) {\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionUpdate, appRBACName(*q.Application)); err != nil {\n\t\treturn nil, err\n\t}\n\n\tvalidate := true\n\tif q.Validate != nil {\n\t\tvalidate = *q.Validate\n\t}\n\treturn s.validateAndUpdateApp(ctx, q.Application, false, validate)\n}\n\n// UpdateSpec updates an application spec and filters out any invalid parameter overrides\nfunc (s *Server) UpdateSpec(ctx context.Context, q *application.ApplicationUpdateSpecRequest) (*appv1.ApplicationSpec, error) {\n\ta, err := s.appclientset.ArgoprojV1alpha1().Applications(s.ns).Get(ctx, *q.Name, metav1.GetOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionUpdate, appRBACName(*a)); err != nil {\n\t\treturn nil, err\n\t}\n\ta.Spec = q.Spec\n\tvalidate := true\n\tif q.Validate != nil {\n\t\tvalidate = *q.Validate\n\t}\n\ta, err = s.validateAndUpdateApp(ctx, a, false, validate)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &a.Spec, nil\n}\n\n// Patch patches an application\nfunc (s *Server) Patch(ctx context.Context, q *application.ApplicationPatchRequest) (*appv1.Application, error) {\n\n\tapp, err := s.appclientset.ArgoprojV1alpha1().Applications(s.ns).Get(ctx, *q.Name, metav1.GetOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err = s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionUpdate, appRBACName(*app)); err != nil {\n\t\treturn nil, err\n\t}\n\n\tjsonApp, err := json.Marshal(app)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tvar patchApp []byte\n\n\tswitch q.PatchType {\n\tcase \"json\", \"\":\n\t\tpatch, err := jsonpatch.DecodePatch([]byte(q.Patch))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tpatchApp, err = patch.Apply(jsonApp)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\tcase \"merge\":\n\t\tpatchApp, err = jsonpatch.MergePatch(jsonApp, []byte(q.Patch))\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\tdefault:\n\t\treturn nil, status.Error(codes.InvalidArgument, fmt.Sprintf(\"Patch type '%s' is not supported\", q.PatchType))\n\t}\n\n\tnewApp := &v1alpha1.Application{}\n\terr = json.Unmarshal(patchApp, newApp)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn s.validateAndUpdateApp(ctx, newApp, false, true)\n}\n\n// Delete removes an application and all associated resources\nfunc (s *Server) Delete(ctx context.Context, q *application.ApplicationDeleteRequest) (*application.ApplicationResponse, error) {\n\ta, err := s.appclientset.ArgoprojV1alpha1().Applications(s.ns).Get(ctx, *q.Name, metav1.GetOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts.projectLock.RLock(a.Spec.Project)\n\tdefer s.projectLock.RUnlock(a.Spec.Project)\n\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionDelete, appRBACName(*a)); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif q.Cascade != nil && !*q.Cascade && q.GetPropagationPolicy() != \"\" {\n\t\treturn nil, status.Error(codes.InvalidArgument, \"cannot set propagation policy when cascading is disabled\")\n\t}\n\n\tpatchFinalizer := false\n\tif q.Cascade == nil || *q.Cascade {\n\t\t// validate the propgation policy\n\t\tpolicyFinalizer := getPropagationPolicyFinalizer(q.GetPropagationPolicy())\n\t\tif policyFinalizer == \"\" {\n\t\t\treturn nil, status.Errorf(codes.InvalidArgument, \"invalid propagation policy: %s\", *q.PropagationPolicy)\n\t\t}\n\t\tif !a.IsFinalizerPresent(policyFinalizer) {\n\t\t\ta.SetCascadedDeletion(policyFinalizer)\n\t\t\tpatchFinalizer = true\n\t\t}\n\t} else {\n\t\tif a.CascadedDeletion() {\n\t\t\ta.UnSetCascadedDeletion()\n\t\t\tpatchFinalizer = true\n\t\t}\n\t}\n\n\tif patchFinalizer {\n\t\t// Although the cascaded deletion/propagation policy finalizer is not set when apps are created via\n\t\t// API, they will often be set by the user as part of declarative config. As part of a delete\n\t\t// request, we always calculate the patch to see if we need to set/unset the finalizer.\n\t\tpatch, err := json.Marshal(map[string]interface{}{\n\t\t\t\"metadata\": map[string]interface{}{\n\t\t\t\t\"finalizers\": a.Finalizers,\n\t\t\t},\n\t\t})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\t_, err = s.appclientset.ArgoprojV1alpha1().Applications(a.Namespace).Patch(ctx, a.Name, types.MergePatchType, patch, metav1.PatchOptions{})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\terr = s.appclientset.ArgoprojV1alpha1().Applications(s.ns).Delete(ctx, *q.Name, metav1.DeleteOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts.logAppEvent(a, ctx, argo.EventReasonResourceDeleted, \"deleted application\")\n\treturn &application.ApplicationResponse{}, nil\n}\n\nfunc (s *Server) Watch(q *application.ApplicationQuery, ws application.ApplicationService_WatchServer) error {\n\tlogCtx := log.NewEntry(log.New())\n\tif q.Name != nil {\n\t\tlogCtx = logCtx.WithField(\"application\", *q.Name)\n\t}\n\tprojects := map[string]bool{}\n\tfor i := range q.Projects {\n\t\tprojects[q.Projects[i]] = true\n\t}\n\tclaims := ws.Context().Value(\"claims\")\n\tselector, err := labels.Parse(q.Selector)\n\tif err != nil {\n\t\treturn err\n\t}\n\tminVersion := 0\n\tif q.ResourceVersion != \"\" {\n\t\tif minVersion, err = strconv.Atoi(q.ResourceVersion); err != nil {\n\t\t\tminVersion = 0\n\t\t}\n\t}\n\n\t// sendIfPermitted is a helper to send the application to the client's streaming channel if the\n\t// caller has RBAC privileges permissions to view it\n\tsendIfPermitted := func(a appv1.Application, eventType watch.EventType) {\n\t\tif len(projects) > 0 && !projects[a.Spec.GetProject()] {\n\t\t\treturn\n\t\t}\n\n\t\tif appVersion, err := strconv.Atoi(a.ResourceVersion); err == nil && appVersion < minVersion {\n\t\t\treturn\n\t\t}\n\t\tmatchedEvent := (q.GetName() == \"\" || a.Name == q.GetName()) && selector.Matches(labels.Set(a.Labels))\n\t\tif !matchedEvent {\n\t\t\treturn\n\t\t}\n\n\t\tif !s.enf.Enforce(claims, rbacpolicy.ResourceApplications, rbacpolicy.ActionGet, appRBACName(a)) {\n\t\t\t// do not emit apps user does not have accessing\n\t\t\treturn\n\t\t}\n\t\terr := ws.Send(&appv1.ApplicationWatchEvent{\n\t\t\tType:        eventType,\n\t\t\tApplication: a,\n\t\t})\n\t\tif err != nil {\n\t\t\tlogCtx.Warnf(\"Unable to send stream message: %v\", err)\n\t\t\treturn\n\t\t}\n\t}\n\n\tevents := make(chan *appv1.ApplicationWatchEvent, watchAPIBufferSize)\n\t// Mimic watch API behavior: send ADDED events if no resource version provided\n\t// If watch API is executed for one application when emit event even if resource version is provided\n\t// This is required since single app watch API is used for during operations like app syncing and it is\n\t// critical to never miss events.\n\tif q.ResourceVersion == \"\" || q.GetName() != \"\" {\n\t\tapps, err := s.appLister.List(selector)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tsort.Slice(apps, func(i, j int) bool {\n\t\t\treturn apps[i].Name < apps[j].Name\n\t\t})\n\t\tfor i := range apps {\n\t\t\tsendIfPermitted(*apps[i], watch.Added)\n\t\t}\n\t}\n\tunsubscribe := s.appBroadcaster.Subscribe(events)\n\tdefer unsubscribe()\n\tfor {\n\t\tselect {\n\t\tcase event := <-events:\n\t\t\tsendIfPermitted(event.Application, event.Type)\n\t\tcase <-ws.Context().Done():\n\t\t\treturn nil\n\t\t}\n\t}\n}\n\nfunc (s *Server) validateAndNormalizeApp(ctx context.Context, app *appv1.Application, validate bool) error {\n\tproj, err := argo.GetAppProject(&app.Spec, applisters.NewAppProjectLister(s.projInformer.GetIndexer()), s.ns, s.settingsMgr, s.db, ctx)\n\tif err != nil {\n\t\tif apierr.IsNotFound(err) {\n\t\t\treturn status.Errorf(codes.InvalidArgument, \"application references project %s which does not exist\", app.Spec.Project)\n\t\t}\n\t\treturn err\n\t}\n\tcurrApp, err := s.appclientset.ArgoprojV1alpha1().Applications(s.ns).Get(ctx, app.Name, metav1.GetOptions{})\n\tif err != nil {\n\t\tif !apierr.IsNotFound(err) {\n\t\t\treturn err\n\t\t}\n\t\t// Kubernetes go-client will return a pointer to a zero-value app instead of nil, even\n\t\t// though the API response was NotFound. This behavior was confirmed via logs.\n\t\tcurrApp = nil\n\t}\n\tif currApp != nil && currApp.Spec.GetProject() != app.Spec.GetProject() {\n\t\t// When changing projects, caller must have application create & update privileges in new project\n\t\t// NOTE: the update check was already verified in the caller to this function\n\t\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionCreate, appRBACName(*app)); err != nil {\n\t\t\treturn err\n\t\t}\n\t\t// They also need 'update' privileges in the old project\n\t\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionUpdate, appRBACName(*currApp)); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// If source is Kustomize add build options\n\tkustomizeSettings, err := s.settingsMgr.GetKustomizeSettings()\n\tif err != nil {\n\t\treturn err\n\t}\n\tkustomizeOptions, err := kustomizeSettings.GetOptions(app.Spec.Source)\n\tif err != nil {\n\t\treturn err\n\t}\n\tplugins, err := s.plugins()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := argo.ValidateDestination(ctx, &app.Spec.Destination, s.db); err != nil {\n\t\treturn status.Errorf(codes.InvalidArgument, \"application destination spec for %s is invalid: %s\", app.Name, err.Error())\n\t}\n\n\tvar conditions []appv1.ApplicationCondition\n\tif validate {\n\t\tconditions, err = argo.ValidateRepo(ctx, app, s.repoClientset, s.db, kustomizeOptions, plugins, s.kubectl, proj, s.settingsMgr)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\tif len(conditions) > 0 {\n\t\t\treturn status.Errorf(codes.InvalidArgument, \"application spec for %s is invalid: %s\", app.Name, argo.FormatAppConditions(conditions))\n\t\t}\n\t}\n\n\tconditions, err = argo.ValidatePermissions(ctx, &app.Spec, proj, s.db)\n\tif err != nil {\n\t\treturn err\n\t}\n\tif len(conditions) > 0 {\n\t\treturn status.Errorf(codes.InvalidArgument, \"application spec for %s is invalid: %s\", app.Name, argo.FormatAppConditions(conditions))\n\t}\n\n\tapp.Spec = *argo.NormalizeApplicationSpec(&app.Spec)\n\treturn nil\n}\n\nfunc (s *Server) getApplicationClusterConfig(ctx context.Context, a *appv1.Application) (*rest.Config, error) {\n\tif err := argo.ValidateDestination(ctx, &a.Spec.Destination, s.db); err != nil {\n\t\treturn nil, err\n\t}\n\tclst, err := s.db.GetCluster(ctx, a.Spec.Destination.Server)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconfig := clst.RESTConfig()\n\treturn config, err\n}\n\n// getCachedAppState loads the cached state and trigger app refresh if cache is missing\nfunc (s *Server) getCachedAppState(ctx context.Context, a *appv1.Application, getFromCache func() error) error {\n\terr := getFromCache()\n\tif err != nil && err == servercache.ErrCacheMiss {\n\t\tconditions := a.Status.GetConditions(map[appv1.ApplicationConditionType]bool{\n\t\t\tappv1.ApplicationConditionComparisonError:  true,\n\t\t\tappv1.ApplicationConditionInvalidSpecError: true,\n\t\t})\n\t\tif len(conditions) > 0 {\n\t\t\treturn errors.New(argoutil.FormatAppConditions(conditions))\n\t\t}\n\t\t_, err = s.Get(ctx, &application.ApplicationQuery{\n\t\t\tName:    pointer.StringPtr(a.Name),\n\t\t\tRefresh: pointer.StringPtr(string(appv1.RefreshTypeNormal)),\n\t\t})\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn getFromCache()\n\t}\n\treturn err\n}\n\nfunc (s *Server) getAppResources(ctx context.Context, a *appv1.Application) (*appv1.ApplicationTree, error) {\n\tvar tree appv1.ApplicationTree\n\terr := s.getCachedAppState(ctx, a, func() error {\n\t\treturn s.cache.GetAppResourcesTree(a.Name, &tree)\n\t})\n\treturn &tree, err\n}\n\nfunc (s *Server) getAppLiveResource(ctx context.Context, action string, q *application.ApplicationResourceRequest) (*appv1.ResourceNode, *rest.Config, *appv1.Application, error) {\n\ta, err := s.appLister.Get(*q.Name)\n\tif err != nil {\n\t\treturn nil, nil, nil, err\n\t}\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, action, appRBACName(*a)); err != nil {\n\t\treturn nil, nil, nil, err\n\t}\n\n\ttree, err := s.getAppResources(ctx, a)\n\tif err != nil {\n\t\treturn nil, nil, nil, err\n\t}\n\n\tfound := tree.FindNode(q.Group, q.Kind, q.Namespace, q.ResourceName)\n\tif found == nil || found.ResourceRef.UID == \"\" {\n\t\treturn nil, nil, nil, status.Errorf(codes.InvalidArgument, \"%s %s %s not found as part of application %s\", q.Kind, q.Group, q.ResourceName, *q.Name)\n\t}\n\tconfig, err := s.getApplicationClusterConfig(ctx, a)\n\tif err != nil {\n\t\treturn nil, nil, nil, err\n\t}\n\treturn found, config, a, nil\n}\n\nfunc (s *Server) GetResource(ctx context.Context, q *application.ApplicationResourceRequest) (*application.ApplicationResourceResponse, error) {\n\tres, config, _, err := s.getAppLiveResource(ctx, rbacpolicy.ActionGet, q)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\t// make sure to use specified resource version if provided\n\tif q.Version != \"\" {\n\t\tres.Version = q.Version\n\t}\n\tobj, err := s.kubectl.GetResource(ctx, config, res.GroupKindVersion(), res.Name, res.Namespace)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tobj, err = replaceSecretValues(obj)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdata, err := json.Marshal(obj.Object)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn &application.ApplicationResourceResponse{Manifest: string(data)}, nil\n}\n\nfunc replaceSecretValues(obj *unstructured.Unstructured) (*unstructured.Unstructured, error) {\n\tif obj.GetKind() == kube.SecretKind && obj.GroupVersionKind().Group == \"\" {\n\t\t_, obj, err := diff.HideSecretData(nil, obj)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\treturn obj, err\n\t}\n\treturn obj, nil\n}\n\n// PatchResource patches a resource\nfunc (s *Server) PatchResource(ctx context.Context, q *application.ApplicationResourcePatchRequest) (*application.ApplicationResourceResponse, error) {\n\tresourceRequest := &application.ApplicationResourceRequest{\n\t\tName:         q.Name,\n\t\tNamespace:    q.Namespace,\n\t\tResourceName: q.ResourceName,\n\t\tKind:         q.Kind,\n\t\tVersion:      q.Version,\n\t\tGroup:        q.Group,\n\t}\n\tres, config, a, err := s.getAppLiveResource(ctx, rbacpolicy.ActionUpdate, resourceRequest)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionUpdate, appRBACName(*a)); err != nil {\n\t\treturn nil, err\n\t}\n\n\tmanifest, err := s.kubectl.PatchResource(ctx, config, res.GroupKindVersion(), res.Name, res.Namespace, types.PatchType(q.PatchType), []byte(q.Patch))\n\tif err != nil {\n\t\t// don't expose real error for secrets since it might contain secret data\n\t\tif res.Kind == kube.SecretKind && res.Group == \"\" {\n\t\t\treturn nil, fmt.Errorf(\"failed to patch Secret %s/%s\", res.Namespace, res.Name)\n\t\t}\n\t\treturn nil, err\n\t}\n\tmanifest, err = replaceSecretValues(manifest)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdata, err := json.Marshal(manifest.Object)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts.logAppEvent(a, ctx, argo.EventReasonResourceUpdated, fmt.Sprintf(\"patched resource %s/%s '%s'\", q.Group, q.Kind, q.ResourceName))\n\treturn &application.ApplicationResourceResponse{\n\t\tManifest: string(data),\n\t}, nil\n}\n\n// DeleteResource deletes a specified resource\nfunc (s *Server) DeleteResource(ctx context.Context, q *application.ApplicationResourceDeleteRequest) (*application.ApplicationResponse, error) {\n\tresourceRequest := &application.ApplicationResourceRequest{\n\t\tName:         q.Name,\n\t\tNamespace:    q.Namespace,\n\t\tResourceName: q.ResourceName,\n\t\tKind:         q.Kind,\n\t\tVersion:      q.Version,\n\t\tGroup:        q.Group,\n\t}\n\tres, config, a, err := s.getAppLiveResource(ctx, rbacpolicy.ActionDelete, resourceRequest)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionDelete, appRBACName(*a)); err != nil {\n\t\treturn nil, err\n\t}\n\tvar deleteOption metav1.DeleteOptions\n\tif q.GetOrphan() {\n\t\tpropagationPolicy := metav1.DeletePropagationOrphan\n\t\tdeleteOption = metav1.DeleteOptions{PropagationPolicy: &propagationPolicy}\n\t} else if q.GetForce() {\n\t\tpropagationPolicy := metav1.DeletePropagationBackground\n\t\tzeroGracePeriod := int64(0)\n\t\tdeleteOption = metav1.DeleteOptions{PropagationPolicy: &propagationPolicy, GracePeriodSeconds: &zeroGracePeriod}\n\t} else {\n\t\tpropagationPolicy := metav1.DeletePropagationForeground\n\t\tdeleteOption = metav1.DeleteOptions{PropagationPolicy: &propagationPolicy}\n\t}\n\terr = s.kubectl.DeleteResource(ctx, config, res.GroupKindVersion(), res.Name, res.Namespace, deleteOption)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ts.logAppEvent(a, ctx, argo.EventReasonResourceDeleted, fmt.Sprintf(\"deleted resource %s/%s '%s'\", q.Group, q.Kind, q.ResourceName))\n\treturn &application.ApplicationResponse{}, nil\n}\n\nfunc (s *Server) ResourceTree(ctx context.Context, q *application.ResourcesQuery) (*appv1.ApplicationTree, error) {\n\ta, err := s.appLister.Get(q.GetApplicationName())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionGet, appRBACName(*a)); err != nil {\n\t\treturn nil, err\n\t}\n\treturn s.getAppResources(ctx, a)\n}\n\nfunc (s *Server) WatchResourceTree(q *application.ResourcesQuery, ws application.ApplicationService_WatchResourceTreeServer) error {\n\ta, err := s.appLister.Get(q.GetApplicationName())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := s.enf.EnforceErr(ws.Context().Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionGet, appRBACName(*a)); err != nil {\n\t\treturn err\n\t}\n\n\treturn s.cache.OnAppResourcesTreeChanged(ws.Context(), q.GetApplicationName(), func() error {\n\t\tvar tree appv1.ApplicationTree\n\t\terr := s.cache.GetAppResourcesTree(q.GetApplicationName(), &tree)\n\t\tif err != nil {\n\t\t\treturn err\n\t\t}\n\t\treturn ws.Send(&tree)\n\t})\n}\n\nfunc (s *Server) RevisionMetadata(ctx context.Context, q *application.RevisionMetadataQuery) (*v1alpha1.RevisionMetadata, error) {\n\ta, err := s.appLister.Get(q.GetName())\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionGet, appRBACName(*a)); err != nil {\n\t\treturn nil, err\n\t}\n\trepo, err := s.db.GetRepository(ctx, a.Spec.Source.RepoURL)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\t// We need to get some information with the project associated to the app,\n\t// so we'll know whether GPG signatures are enforced.\n\tproj, err := argo.GetAppProject(&a.Spec, applisters.NewAppProjectLister(s.projInformer.GetIndexer()), a.Namespace, s.settingsMgr, s.db, ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tconn, repoClient, err := s.repoClientset.NewRepoServerClient()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tdefer ioutil.Close(conn)\n\treturn repoClient.GetRevisionMetadata(ctx, &apiclient.RepoServerRevisionMetadataRequest{\n\t\tRepo:           repo,\n\t\tRevision:       q.GetRevision(),\n\t\tCheckSignature: len(proj.Spec.SignatureKeys) > 0,\n\t})\n}\n\nfunc isMatchingResource(q *application.ResourcesQuery, key kube.ResourceKey) bool {\n\treturn (q.Name == \"\" || q.Name == key.Name) &&\n\t\t(q.Namespace == \"\" || q.Namespace == key.Namespace) &&\n\t\t(q.Group == \"\" || q.Group == key.Group) &&\n\t\t(q.Kind == \"\" || q.Kind == key.Kind)\n}\n\nfunc (s *Server) ManagedResources(ctx context.Context, q *application.ResourcesQuery) (*application.ManagedResourcesResponse, error) {\n\ta, err := s.appLister.Get(*q.ApplicationName)\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error getting application: %s\", err)\n\t}\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionGet, appRBACName(*a)); err != nil {\n\t\treturn nil, fmt.Errorf(\"error verifying rbac: %s\", err)\n\t}\n\titems := make([]*appv1.ResourceDiff, 0)\n\terr = s.getCachedAppState(ctx, a, func() error {\n\t\treturn s.cache.GetAppManagedResources(a.Name, &items)\n\t})\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"error getting cached app state: %s\", err)\n\t}\n\tres := &application.ManagedResourcesResponse{}\n\tfor i := range items {\n\t\titem := items[i]\n\t\tif isMatchingResource(q, kube.ResourceKey{Name: item.Name, Namespace: item.Namespace, Kind: item.Kind, Group: item.Group}) {\n\t\t\tres.Items = append(res.Items, item)\n\t\t}\n\t}\n\n\treturn res, nil\n}\n\nfunc (s *Server) PodLogs(q *application.ApplicationPodLogsQuery, ws application.ApplicationService_PodLogsServer) error {\n\tif q.PodName != nil {\n\t\tpodKind := \"Pod\"\n\t\tq.Kind = &podKind\n\t\tq.ResourceName = q.PodName\n\t}\n\n\tvar sinceSeconds, tailLines *int64\n\tif q.SinceSeconds > 0 {\n\t\tsinceSeconds = &q.SinceSeconds\n\t}\n\tif q.TailLines > 0 {\n\t\ttailLines = &q.TailLines\n\t}\n\tvar untilTime *metav1.Time\n\tif q.GetUntilTime() != \"\" {\n\t\tif val, err := time.Parse(time.RFC3339Nano, q.GetUntilTime()); err != nil {\n\t\t\treturn fmt.Errorf(\"invalid untilTime parameter value: %v\", err)\n\t\t} else {\n\t\t\tuntilTimeVal := metav1.NewTime(val)\n\t\t\tuntilTime = &untilTimeVal\n\t\t}\n\t}\n\n\tliteral := \"\"\n\tinverse := false\n\tif q.GetFilter() != \"\" {\n\t\tliteral = *q.Filter\n\t\tif literal[0] == '!' {\n\t\t\tliteral = literal[1:]\n\t\t\tinverse = true\n\t\t}\n\t}\n\n\ta, err := s.appLister.Get(q.GetName())\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif err := s.enf.EnforceErr(ws.Context().Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionGet, appRBACName(*a)); err != nil {\n\t\treturn err\n\t}\n\n\t// Temporarily, logs RBAC will be enforced only if an internal var serverRBACLogEnforceEnable (representing server.rbac.log.enforce.enable env var)\n\t// is defined and has a \"true\" value\n\t// Otherwise, no RBAC enforcement for logs will take place (meaning, PodLogs will return the logs,\n\t// even if there is no explicit RBAC allow, or if there is an explicit RBAC deny)\n\t// In the future, logs RBAC will be always enforced and the parameter along with this check will be removed\n\tserverRBACLogEnforceEnable, err := s.settingsMgr.GetServerRBACLogEnforceEnable()\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tif serverRBACLogEnforceEnable {\n\t\tif err := s.enf.EnforceErr(ws.Context().Value(\"claims\"), rbacpolicy.ResourceLogs, rbacpolicy.ActionGet, appRBACName(*a)); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\ttree, err := s.getAppResources(ws.Context(), a)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tconfig, err := s.getApplicationClusterConfig(ws.Context(), a)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\tkubeClientset, err := kubernetes.NewForConfig(config)\n\tif err != nil {\n\t\treturn err\n\t}\n\n\t// from the tree find pods which match query of kind, group, and resource name\n\tpods := getSelectedPods(tree.Nodes, q)\n\tif len(pods) == 0 {\n\t\treturn nil\n\t}\n\n\tif len(pods) > maxPodLogsToRender {\n\t\treturn errors.New(\"Max pods to view logs are reached. Please provide more granular query.\")\n\t}\n\n\tvar streams []chan logEntry\n\n\tfor _, pod := range pods {\n\t\tstream, err := kubeClientset.CoreV1().Pods(pod.Namespace).GetLogs(pod.Name, &v1.PodLogOptions{\n\t\t\tContainer:    q.Container,\n\t\t\tFollow:       q.Follow,\n\t\t\tTimestamps:   true,\n\t\t\tSinceSeconds: sinceSeconds,\n\t\t\tSinceTime:    q.SinceTime,\n\t\t\tTailLines:    tailLines,\n\t\t\tPrevious:     q.Previous,\n\t\t}).Stream(ws.Context())\n\t\tpodName := pod.Name\n\t\tlogStream := make(chan logEntry)\n\t\tif err == nil {\n\t\t\tdefer ioutil.Close(stream)\n\t\t}\n\n\t\tstreams = append(streams, logStream)\n\t\tgo func() {\n\t\t\t// if k8s failed to start steaming logs (typically because Pod is not ready yet)\n\t\t\t// then the error should be shown in the UI so that user know the reason\n\t\t\tif err != nil {\n\t\t\t\tlogStream <- logEntry{line: err.Error()}\n\t\t\t} else {\n\t\t\t\tparseLogsStream(podName, stream, logStream)\n\t\t\t}\n\t\t\tclose(logStream)\n\t\t}()\n\t}\n\n\tlogStream := mergeLogStreams(streams, time.Millisecond*100)\n\tsentCount := int64(0)\n\tdone := make(chan error)\n\tgo func() {\n\t\tfor entry := range logStream {\n\t\t\tif entry.err != nil {\n\t\t\t\tdone <- entry.err\n\t\t\t\treturn\n\t\t\t} else {\n\t\t\t\tif q.Filter != nil {\n\t\t\t\t\tlineContainsFilter := strings.Contains(entry.line, literal)\n\t\t\t\t\tif (inverse && lineContainsFilter) || (!inverse && !lineContainsFilter) {\n\t\t\t\t\t\tcontinue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif untilTime != nil && entry.timeStamp.After(untilTime.Time) {\n\t\t\t\t\tdone <- ws.Send(&application.LogEntry{\n\t\t\t\t\t\tLast: true,\n\t\t\t\t\t})\n\t\t\t\t\treturn\n\t\t\t\t} else {\n\t\t\t\t\tsentCount++\n\t\t\t\t\tif err := ws.Send(&application.LogEntry{\n\t\t\t\t\t\tPodName:      entry.podName,\n\t\t\t\t\t\tContent:      entry.line,\n\t\t\t\t\t\tTimeStampStr: entry.timeStamp.Format(time.RFC3339Nano),\n\t\t\t\t\t\tTimeStamp:    metav1.NewTime(entry.timeStamp),\n\t\t\t\t\t}); err != nil {\n\t\t\t\t\t\tdone <- err\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdone <- ws.Send(&application.LogEntry{Last: true})\n\t}()\n\n\tselect {\n\tcase err := <-done:\n\t\treturn err\n\tcase <-ws.Context().Done():\n\t\tlog.WithField(\"application\", q.Name).Debug(\"k8s pod logs reader completed due to closed grpc context\")\n\t\treturn nil\n\t}\n}\n\n// from all of the treeNodes, get the pod who meets the criteria or whose parents meets the criteria\nfunc getSelectedPods(treeNodes []appv1.ResourceNode, q *application.ApplicationPodLogsQuery) []appv1.ResourceNode {\n\tvar pods []appv1.ResourceNode\n\tisTheOneMap := make(map[string]bool)\n\tfor _, treeNode := range treeNodes {\n\t\tif treeNode.Kind == kube.PodKind && treeNode.Group == \"\" && treeNode.UID != \"\" {\n\t\t\tif isTheSelectedOne(&treeNode, q, treeNodes, isTheOneMap) {\n\t\t\t\tpods = append(pods, treeNode)\n\t\t\t}\n\t\t}\n\t}\n\treturn pods\n}\n\n// check is currentNode is matching with group, kind, and name, or if any of its parents matches\nfunc isTheSelectedOne(currentNode *appv1.ResourceNode, q *application.ApplicationPodLogsQuery, resourceNodes []appv1.ResourceNode, isTheOneMap map[string]bool) bool {\n\texist, value := isTheOneMap[currentNode.UID]\n\tif exist {\n\t\treturn value\n\t}\n\n\tif (q.ResourceName == nil || *q.ResourceName == \"\" || currentNode.Name == *q.ResourceName) &&\n\t\t(q.Kind == nil || *q.Kind == \"\" || currentNode.Kind == *q.Kind) &&\n\t\t(q.Group == nil || *q.Group == \"\" || currentNode.Group == *q.Group) &&\n\t\t(q.Namespace == \"\" || currentNode.Namespace == q.Namespace) {\n\t\tisTheOneMap[currentNode.UID] = true\n\t\treturn true\n\t}\n\n\tif len(currentNode.ParentRefs) == 0 {\n\t\tisTheOneMap[currentNode.UID] = false\n\t\treturn false\n\t}\n\n\tfor _, parentResource := range currentNode.ParentRefs {\n\t\t//look up parentResource from resourceNodes\n\t\t//then check if the parent isTheSelectedOne\n\t\tfor _, resourceNode := range resourceNodes {\n\t\t\tif resourceNode.Namespace == parentResource.Namespace &&\n\t\t\t\tresourceNode.Name == parentResource.Name &&\n\t\t\t\tresourceNode.Group == parentResource.Group &&\n\t\t\t\tresourceNode.Kind == parentResource.Kind {\n\t\t\t\tif isTheSelectedOne(&resourceNode, q, resourceNodes, isTheOneMap) {\n\t\t\t\t\tisTheOneMap[currentNode.UID] = true\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tisTheOneMap[currentNode.UID] = false\n\treturn false\n}\n\n// Sync syncs an application to its target state\nfunc (s *Server) Sync(ctx context.Context, syncReq *application.ApplicationSyncRequest) (*appv1.Application, error) {\n\tappIf := s.appclientset.ArgoprojV1alpha1().Applications(s.ns)\n\ta, err := appIf.Get(ctx, *syncReq.Name, metav1.GetOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tproj, err := argo.GetAppProject(&a.Spec, applisters.NewAppProjectLister(s.projInformer.GetIndexer()), a.Namespace, s.settingsMgr, s.db, ctx)\n\tif err != nil {\n\t\tif apierr.IsNotFound(err) {\n\t\t\treturn a, status.Errorf(codes.InvalidArgument, \"application references project %s which does not exist\", a.Spec.Project)\n\t\t}\n\t\treturn a, err\n\t}\n\n\tif !proj.Spec.SyncWindows.Matches(a).CanSync(true) {\n\t\treturn a, status.Errorf(codes.PermissionDenied, \"Cannot sync: Blocked by sync window\")\n\t}\n\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionSync, appRBACName(*a)); err != nil {\n\t\treturn nil, err\n\t}\n\tif syncReq.Manifests != nil {\n\t\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionOverride, appRBACName(*a)); err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t\tif a.Spec.SyncPolicy != nil && a.Spec.SyncPolicy.Automated != nil && !syncReq.DryRun {\n\t\t\treturn nil, status.Error(codes.FailedPrecondition, \"Cannot use local sync when Automatic Sync Policy is enabled unless for dry run\")\n\t\t}\n\t}\n\tif a.DeletionTimestamp != nil {\n\t\treturn nil, status.Errorf(codes.FailedPrecondition, \"application is deleting\")\n\t}\n\tif a.Spec.SyncPolicy != nil && a.Spec.SyncPolicy.Automated != nil {\n\t\tif syncReq.Revision != \"\" && syncReq.Revision != text.FirstNonEmpty(a.Spec.Source.TargetRevision, \"HEAD\") {\n\t\t\treturn nil, status.Errorf(codes.FailedPrecondition, \"Cannot sync to %s: auto-sync currently set to %s\", syncReq.Revision, a.Spec.Source.TargetRevision)\n\t\t}\n\t}\n\trevision, displayRevision, err := s.resolveRevision(ctx, a, syncReq)\n\tif err != nil {\n\t\treturn nil, status.Errorf(codes.FailedPrecondition, err.Error())\n\t}\n\n\tvar retry *appv1.RetryStrategy\n\tvar syncOptions appv1.SyncOptions\n\tif a.Spec.SyncPolicy != nil {\n\t\tsyncOptions = a.Spec.SyncPolicy.SyncOptions\n\t\tretry = a.Spec.SyncPolicy.Retry\n\t}\n\tif syncReq.RetryStrategy != nil {\n\t\tretry = syncReq.RetryStrategy\n\t}\n\tif syncReq.SyncOptions != nil {\n\t\tsyncOptions = syncReq.SyncOptions.Items\n\t}\n\n\t// We cannot use local manifests if we're only allowed to sync to signed commits\n\tif syncReq.Manifests != nil && len(proj.Spec.SignatureKeys) > 0 {\n\t\treturn nil, status.Errorf(codes.FailedPrecondition, \"Cannot use local sync when signature keys are required.\")\n\t}\n\n\top := appv1.Operation{\n\t\tSync: &appv1.SyncOperation{\n\t\t\tRevision:     revision,\n\t\t\tPrune:        syncReq.Prune,\n\t\t\tDryRun:       syncReq.DryRun,\n\t\t\tSyncOptions:  syncOptions,\n\t\t\tSyncStrategy: syncReq.Strategy,\n\t\t\tResources:    syncReq.Resources,\n\t\t\tManifests:    syncReq.Manifests,\n\t\t},\n\t\tInitiatedBy: appv1.OperationInitiator{Username: session.Username(ctx)},\n\t\tInfo:        syncReq.Infos,\n\t}\n\tif retry != nil {\n\t\top.Retry = *retry\n\t}\n\n\ta, err = argo.SetAppOperation(appIf, *syncReq.Name, &op)\n\tif err == nil {\n\t\tpartial := \"\"\n\t\tif len(syncReq.Resources) > 0 {\n\t\t\tpartial = \"partial \"\n\t\t}\n\t\treason := fmt.Sprintf(\"initiated %ssync to %s\", partial, displayRevision)\n\t\tif syncReq.Manifests != nil {\n\t\t\treason = fmt.Sprintf(\"initiated %ssync locally\", partial)\n\t\t}\n\t\ts.logAppEvent(a, ctx, argo.EventReasonOperationStarted, reason)\n\t}\n\treturn a, err\n}\n\nfunc (s *Server) Rollback(ctx context.Context, rollbackReq *application.ApplicationRollbackRequest) (*appv1.Application, error) {\n\tappIf := s.appclientset.ArgoprojV1alpha1().Applications(s.ns)\n\ta, err := appIf.Get(ctx, *rollbackReq.Name, metav1.GetOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionSync, appRBACName(*a)); err != nil {\n\t\treturn nil, err\n\t}\n\tif a.DeletionTimestamp != nil {\n\t\treturn nil, status.Errorf(codes.FailedPrecondition, \"application is deleting\")\n\t}\n\tif a.Spec.SyncPolicy != nil && a.Spec.SyncPolicy.Automated != nil {\n\t\treturn nil, status.Errorf(codes.FailedPrecondition, \"rollback cannot be initiated when auto-sync is enabled\")\n\t}\n\n\tvar deploymentInfo *appv1.RevisionHistory\n\tfor _, info := range a.Status.History {\n\t\tif info.ID == rollbackReq.ID {\n\t\t\tdeploymentInfo = &info\n\t\t\tbreak\n\t\t}\n\t}\n\tif deploymentInfo == nil {\n\t\treturn nil, status.Errorf(codes.InvalidArgument, \"application %s does not have deployment with id %v\", a.Name, rollbackReq.ID)\n\t}\n\tif deploymentInfo.Source.IsZero() {\n\t\t// Since source type was introduced to history starting with v0.12, and is now required for\n\t\t// rollback, we cannot support rollback to revisions deployed using Argo CD v0.11 or below\n\t\treturn nil, status.Errorf(codes.FailedPrecondition, \"cannot rollback to revision deployed with Argo CD v0.11 or lower. sync to revision instead.\")\n\t}\n\n\tvar syncOptions appv1.SyncOptions\n\tif a.Spec.SyncPolicy != nil {\n\t\tsyncOptions = a.Spec.SyncPolicy.SyncOptions\n\t}\n\n\t// Rollback is just a convenience around Sync\n\top := appv1.Operation{\n\t\tSync: &appv1.SyncOperation{\n\t\t\tRevision:     deploymentInfo.Revision,\n\t\t\tDryRun:       rollbackReq.DryRun,\n\t\t\tPrune:        rollbackReq.Prune,\n\t\t\tSyncOptions:  syncOptions,\n\t\t\tSyncStrategy: &appv1.SyncStrategy{Apply: &appv1.SyncStrategyApply{}},\n\t\t\tSource:       &deploymentInfo.Source,\n\t\t},\n\t}\n\ta, err = argo.SetAppOperation(appIf, *rollbackReq.Name, &op)\n\tif err == nil {\n\t\ts.logAppEvent(a, ctx, argo.EventReasonOperationStarted, fmt.Sprintf(\"initiated rollback to %d\", rollbackReq.ID))\n\t}\n\treturn a, err\n}\n\n// resolveRevision resolves the revision specified either in the sync request, or the\n// application source, into a concrete revision that will be used for a sync operation.\nfunc (s *Server) resolveRevision(ctx context.Context, app *appv1.Application, syncReq *application.ApplicationSyncRequest) (string, string, error) {\n\tif syncReq.Manifests != nil {\n\t\treturn \"\", \"\", nil\n\t}\n\tambiguousRevision := syncReq.Revision\n\tif ambiguousRevision == \"\" {\n\t\tambiguousRevision = app.Spec.Source.TargetRevision\n\t}\n\trepo, err := s.db.GetRepository(ctx, app.Spec.Source.RepoURL)\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tconn, repoClient, err := s.repoClientset.NewRepoServerClient()\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\tdefer io.Close(conn)\n\n\tif !app.Spec.Source.IsHelm() {\n\t\tif git.IsCommitSHA(ambiguousRevision) {\n\t\t\t// If it's already a commit SHA, then no need to look it up\n\t\t\treturn ambiguousRevision, ambiguousRevision, nil\n\t\t}\n\t}\n\n\tresolveRevisionResponse, err := repoClient.ResolveRevision(ctx, &apiclient.ResolveRevisionRequest{\n\t\tRepo:              repo,\n\t\tApp:               app,\n\t\tAmbiguousRevision: ambiguousRevision,\n\t})\n\tif err != nil {\n\t\treturn \"\", \"\", err\n\t}\n\treturn resolveRevisionResponse.Revision, resolveRevisionResponse.AmbiguousRevision, nil\n}\n\nfunc (s *Server) TerminateOperation(ctx context.Context, termOpReq *application.OperationTerminateRequest) (*application.OperationTerminateResponse, error) {\n\ta, err := s.appclientset.ArgoprojV1alpha1().Applications(s.ns).Get(ctx, *termOpReq.Name, metav1.GetOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionSync, appRBACName(*a)); err != nil {\n\t\treturn nil, err\n\t}\n\n\tfor i := 0; i < 10; i++ {\n\t\tif a.Operation == nil || a.Status.OperationState == nil {\n\t\t\treturn nil, status.Errorf(codes.InvalidArgument, \"Unable to terminate operation. No operation is in progress\")\n\t\t}\n\t\ta.Status.OperationState.Phase = common.OperationTerminating\n\t\tupdated, err := s.appclientset.ArgoprojV1alpha1().Applications(s.ns).Update(ctx, a, metav1.UpdateOptions{})\n\t\tif err == nil {\n\t\t\ts.waitSync(updated)\n\t\t\ts.logAppEvent(a, ctx, argo.EventReasonResourceUpdated, \"terminated running operation\")\n\t\t\treturn &application.OperationTerminateResponse{}, nil\n\t\t}\n\t\tif !apierr.IsConflict(err) {\n\t\t\treturn nil, err\n\t\t}\n\t\tlog.Warnf(\"Failed to set operation for app '%s' due to update conflict. Retrying again...\", *termOpReq.Name)\n\t\ttime.Sleep(100 * time.Millisecond)\n\t\ta, err = s.appclientset.ArgoprojV1alpha1().Applications(s.ns).Get(ctx, *termOpReq.Name, metav1.GetOptions{})\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\treturn nil, status.Errorf(codes.Internal, \"Failed to terminate app. Too many conflicts\")\n}\n\nfunc (s *Server) logAppEvent(a *appv1.Application, ctx context.Context, reason string, action string) {\n\teventInfo := argo.EventInfo{Type: v1.EventTypeNormal, Reason: reason}\n\tuser := session.Username(ctx)\n\tif user == \"\" {\n\t\tuser = \"Unknown user\"\n\t}\n\tmessage := fmt.Sprintf(\"%s %s\", user, action)\n\ts.auditLogger.LogAppEvent(a, eventInfo, message)\n}\n\nfunc (s *Server) logResourceEvent(res *appv1.ResourceNode, ctx context.Context, reason string, action string) {\n\teventInfo := argo.EventInfo{Type: v1.EventTypeNormal, Reason: reason}\n\tuser := session.Username(ctx)\n\tif user == \"\" {\n\t\tuser = \"Unknown user\"\n\t}\n\tmessage := fmt.Sprintf(\"%s %s\", user, action)\n\ts.auditLogger.LogResourceEvent(res, eventInfo, message)\n}\n\nfunc (s *Server) ListResourceActions(ctx context.Context, q *application.ApplicationResourceRequest) (*application.ResourceActionsListResponse, error) {\n\tres, config, _, err := s.getAppLiveResource(ctx, rbacpolicy.ActionGet, q)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tobj, err := s.kubectl.GetResource(ctx, config, res.GroupKindVersion(), res.Name, res.Namespace)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tresourceOverrides, err := s.settingsMgr.GetResourceOverrides()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tavailableActions, err := s.getAvailableActions(resourceOverrides, obj)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\treturn &application.ResourceActionsListResponse{Actions: availableActions}, nil\n}\n\nfunc (s *Server) getAvailableActions(resourceOverrides map[string]appv1.ResourceOverride, obj *unstructured.Unstructured) ([]appv1.ResourceAction, error) {\n\tluaVM := lua.VM{\n\t\tResourceOverrides: resourceOverrides,\n\t}\n\n\tdiscoveryScript, err := luaVM.GetResourceActionDiscovery(obj)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif discoveryScript == \"\" {\n\t\treturn []appv1.ResourceAction{}, nil\n\t}\n\tavailableActions, err := luaVM.ExecuteResourceActionDiscovery(obj, discoveryScript)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\treturn availableActions, nil\n\n}\n\nfunc (s *Server) RunResourceAction(ctx context.Context, q *application.ResourceActionRunRequest) (*application.ApplicationResponse, error) {\n\tresourceRequest := &application.ApplicationResourceRequest{\n\t\tName:         q.Name,\n\t\tNamespace:    q.Namespace,\n\t\tResourceName: q.ResourceName,\n\t\tKind:         q.Kind,\n\t\tVersion:      q.Version,\n\t\tGroup:        q.Group,\n\t}\n\tactionRequest := fmt.Sprintf(\"%s/%s/%s/%s\", rbacpolicy.ActionAction, q.Group, q.Kind, q.Action)\n\tres, config, a, err := s.getAppLiveResource(ctx, actionRequest, resourceRequest)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tliveObj, err := s.kubectl.GetResource(ctx, config, res.GroupKindVersion(), res.Name, res.Namespace)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tresourceOverrides, err := s.settingsMgr.GetResourceOverrides()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tluaVM := lua.VM{\n\t\tResourceOverrides: resourceOverrides,\n\t}\n\taction, err := luaVM.GetResourceAction(liveObj, q.Action)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tnewObj, err := luaVM.ExecuteResourceAction(liveObj, action.ActionLua)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tnewObjBytes, err := json.Marshal(newObj)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tliveObjBytes, err := json.Marshal(liveObj)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tdiffBytes, err := jsonpatch.CreateMergePatch(liveObjBytes, newObjBytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif string(diffBytes) == \"{}\" {\n\t\treturn &application.ApplicationResponse{}, nil\n\t}\n\n\t// The following logic detects if the resource action makes a modification to status and/or spec.\n\t// If status was modified, we attempt to patch the status using status subresource, in case the\n\t// CRD is configured using the status subresource feature. See:\n\t// https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/#status-subresource\n\t// If status subresource is in use, the patch has to be split into two:\n\t// * one to update spec (and other non-status fields)\n\t// * the other to update only status.\n\tnonStatusPatch, statusPatch, err := splitStatusPatch(diffBytes)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tif statusPatch != nil {\n\t\t_, err = s.kubectl.PatchResource(ctx, config, newObj.GroupVersionKind(), newObj.GetName(), newObj.GetNamespace(), types.MergePatchType, diffBytes, \"status\")\n\t\tif err != nil {\n\t\t\tif !apierr.IsNotFound(err) {\n\t\t\t\treturn nil, err\n\t\t\t}\n\t\t\t// K8s API server returns 404 NotFound when the CRD does not support the status subresource\n\t\t\t// if we get here, the CRD does not use the status subresource. We will fall back to a normal patch\n\t\t} else {\n\t\t\t// If we get here, the CRD does use the status subresource, so we must patch status and\n\t\t\t// spec separately. update the diffBytes to the spec-only patch and fall through.\n\t\t\tdiffBytes = nonStatusPatch\n\t\t}\n\t}\n\tif diffBytes != nil {\n\t\t_, err = s.kubectl.PatchResource(ctx, config, newObj.GroupVersionKind(), newObj.GetName(), newObj.GetNamespace(), types.MergePatchType, diffBytes)\n\t\tif err != nil {\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\ts.logAppEvent(a, ctx, argo.EventReasonResourceActionRan, fmt.Sprintf(\"ran action %s on resource %s/%s/%s\", q.Action, res.Group, res.Kind, res.Name))\n\ts.logResourceEvent(res, ctx, argo.EventReasonResourceActionRan, fmt.Sprintf(\"ran action %s\", q.Action))\n\treturn &application.ApplicationResponse{}, nil\n}\n\n// splitStatusPatch splits a patch into two: one for a non-status patch, and the status-only patch.\n// Returns nil for either if the patch doesn't have modifications to non-status, or status, respectively.\nfunc splitStatusPatch(patch []byte) ([]byte, []byte, error) {\n\tvar obj map[string]interface{}\n\terr := json.Unmarshal(patch, &obj)\n\tif err != nil {\n\t\treturn nil, nil, err\n\t}\n\tvar nonStatusPatch, statusPatch []byte\n\tif statusVal, ok := obj[\"status\"]; ok {\n\t\t// calculate the status-only patch\n\t\tstatusObj := map[string]interface{}{\n\t\t\t\"status\": statusVal,\n\t\t}\n\t\tstatusPatch, err = json.Marshal(statusObj)\n\t\tif err != nil {\n\t\t\treturn nil, nil, err\n\t\t}\n\t\t// remove status, and calculate the non-status patch\n\t\tdelete(obj, \"status\")\n\t\tif len(obj) > 0 {\n\t\t\tnonStatusPatch, err = json.Marshal(obj)\n\t\t\tif err != nil {\n\t\t\t\treturn nil, nil, err\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// status was not modified in patch\n\t\tnonStatusPatch = patch\n\t}\n\treturn nonStatusPatch, statusPatch, nil\n}\n\nfunc (s *Server) plugins() ([]*v1alpha1.ConfigManagementPlugin, error) {\n\tplugins, err := s.settingsMgr.GetConfigManagementPlugins()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\ttools := make([]*v1alpha1.ConfigManagementPlugin, len(plugins))\n\tfor i, p := range plugins {\n\t\tp := p\n\t\ttools[i] = &p\n\t}\n\treturn tools, nil\n}\n\nfunc (s *Server) GetApplicationSyncWindows(ctx context.Context, q *application.ApplicationSyncWindowsQuery) (*application.ApplicationSyncWindowsResponse, error) {\n\tappIf := s.appclientset.ArgoprojV1alpha1().Applications(s.ns)\n\ta, err := appIf.Get(ctx, *q.Name, metav1.GetOptions{})\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif err := s.enf.EnforceErr(ctx.Value(\"claims\"), rbacpolicy.ResourceApplications, rbacpolicy.ActionGet, appRBACName(*a)); err != nil {\n\t\treturn nil, err\n\t}\n\n\tproj, err := argo.GetAppProject(&a.Spec, applisters.NewAppProjectLister(s.projInformer.GetIndexer()), a.Namespace, s.settingsMgr, s.db, ctx)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\twindows := proj.Spec.SyncWindows.Matches(a)\n\tsync := windows.CanSync(true)\n\n\tres := &application.ApplicationSyncWindowsResponse{\n\t\tActiveWindows:   convertSyncWindows(windows.Active()),\n\t\tAssignedWindows: convertSyncWindows(windows),\n\t\tCanSync:         &sync,\n\t}\n\n\treturn res, nil\n}\n\nfunc convertSyncWindows(w *v1alpha1.SyncWindows) []*application.ApplicationSyncWindow {\n\tif w != nil {\n\t\tvar windows []*application.ApplicationSyncWindow\n\t\tfor _, w := range *w {\n\t\t\tnw := &application.ApplicationSyncWindow{\n\t\t\t\tKind:       &w.Kind,\n\t\t\t\tSchedule:   &w.Schedule,\n\t\t\t\tDuration:   &w.Duration,\n\t\t\t\tManualSync: &w.ManualSync,\n\t\t\t}\n\t\t\twindows = append(windows, nw)\n\t\t}\n\t\tif len(windows) > 0 {\n\t\t\treturn windows\n\t\t}\n\t}\n\treturn nil\n}\n\nfunc getPropagationPolicyFinalizer(policy string) string {\n\tswitch strings.ToLower(policy) {\n\tcase backgroundPropagationPolicy:\n\t\treturn appv1.BackgroundPropagationPolicyFinalizer\n\tcase foregroundPropagationPolicy:\n\t\treturn appv1.ForegroundPropagationPolicyFinalizer\n\tcase \"\":\n\t\treturn appv1.ResourcesFinalizerName\n\tdefault:\n\t\treturn \"\"\n\t}\n}\n", "package e2e\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"math/rand\"\n\t\"os\"\n\t\"path\"\n\t\"reflect\"\n\t\"regexp\"\n\t\"strings\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/argoproj/gitops-engine/pkg/diff\"\n\t\"github.com/argoproj/gitops-engine/pkg/health\"\n\t. \"github.com/argoproj/gitops-engine/pkg/sync/common\"\n\t\"github.com/argoproj/gitops-engine/pkg/utils/kube\"\n\t\"github.com/argoproj/pkg/errors\"\n\tlog \"github.com/sirupsen/logrus\"\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\tv1 \"k8s.io/api/core/v1\"\n\tnetworkingv1 \"k8s.io/api/networking/v1\"\n\tmetav1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n\t\"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured\"\n\t\"k8s.io/apimachinery/pkg/runtime/schema\"\n\t\"k8s.io/apimachinery/pkg/types\"\n\t\"k8s.io/apimachinery/pkg/util/intstr\"\n\t\"k8s.io/utils/pointer\"\n\n\t\"github.com/argoproj/argo-cd/v2/common\"\n\tapplicationpkg \"github.com/argoproj/argo-cd/v2/pkg/apiclient/application\"\n\t. \"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1\"\n\t\"github.com/argoproj/argo-cd/v2/test/e2e/fixture\"\n\t. \"github.com/argoproj/argo-cd/v2/test/e2e/fixture\"\n\taccountFixture \"github.com/argoproj/argo-cd/v2/test/e2e/fixture/account\"\n\t. \"github.com/argoproj/argo-cd/v2/test/e2e/fixture/app\"\n\tprojectFixture \"github.com/argoproj/argo-cd/v2/test/e2e/fixture/project\"\n\trepoFixture \"github.com/argoproj/argo-cd/v2/test/e2e/fixture/repos\"\n\t\"github.com/argoproj/argo-cd/v2/test/e2e/testdata\"\n\t. \"github.com/argoproj/argo-cd/v2/util/argo\"\n\t. \"github.com/argoproj/argo-cd/v2/util/errors\"\n\t\"github.com/argoproj/argo-cd/v2/util/io\"\n\t\"github.com/argoproj/argo-cd/v2/util/settings\"\n)\n\nconst (\n\tguestbookPath          = \"guestbook\"\n\tguestbookPathLocal     = \"./testdata/guestbook_local\"\n\tglobalWithNoNameSpace  = \"global-with-no-namespace\"\n\tguestbookWithNamespace = \"guestbook-with-namespace\"\n)\n\n// This empty test is here only for clarity, to conform to logs rbac tests structure in account. This exact usecase is covered in the TestAppLogs test\nfunc TestGetLogsAllowNoSwitch(t *testing.T) {\n}\n\n// There is some code duplication in the below GetLogs tests, the reason for that is to allow getting rid of most of those tests easily in the next release,\n// when the temporary switch would die\nfunc TestGetLogsDenySwitchOn(t *testing.T) {\n\tSkipOnEnv(t, \"OPENSHIFT\")\n\n\taccountFixture.Given(t).\n\t\tName(\"test\").\n\t\tWhen().\n\t\tCreate().\n\t\tLogin().\n\t\tSetPermissions([]fixture.ACL{\n\t\t\t{\n\t\t\t\tResource: \"applications\",\n\t\t\t\tAction:   \"create\",\n\t\t\t\tScope:    \"*\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tResource: \"applications\",\n\t\t\t\tAction:   \"get\",\n\t\t\t\tScope:    \"*\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tResource: \"applications\",\n\t\t\t\tAction:   \"sync\",\n\t\t\t\tScope:    \"*\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tResource: \"projects\",\n\t\t\t\tAction:   \"get\",\n\t\t\t\tScope:    \"*\",\n\t\t\t},\n\t\t}, \"app-creator\")\n\n\tGivenWithSameState(t).\n\t\tPath(\"guestbook-logs\").\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tSetParamInSettingConfigMap(\"server.rbac.log.enforce.enable\", \"true\").\n\t\tThen().\n\t\tExpect(HealthIs(health.HealthStatusHealthy)).\n\t\tAnd(func(app *Application) {\n\t\t\t_, err := RunCli(\"app\", \"logs\", app.Name, \"--kind\", \"Deployment\", \"--group\", \"\", \"--name\", \"guestbook-ui\")\n\t\t\tassert.Error(t, err)\n\t\t\tassert.Contains(t, err.Error(), \"permission denied\")\n\t\t})\n}\n\nfunc TestGetLogsAllowSwitchOn(t *testing.T) {\n\tSkipOnEnv(t, \"OPENSHIFT\")\n\n\taccountFixture.Given(t).\n\t\tName(\"test\").\n\t\tWhen().\n\t\tCreate().\n\t\tLogin().\n\t\tSetPermissions([]fixture.ACL{\n\t\t\t{\n\t\t\t\tResource: \"applications\",\n\t\t\t\tAction:   \"create\",\n\t\t\t\tScope:    \"*\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tResource: \"applications\",\n\t\t\t\tAction:   \"get\",\n\t\t\t\tScope:    \"*\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tResource: \"applications\",\n\t\t\t\tAction:   \"sync\",\n\t\t\t\tScope:    \"*\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tResource: \"projects\",\n\t\t\t\tAction:   \"get\",\n\t\t\t\tScope:    \"*\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tResource: \"logs\",\n\t\t\t\tAction:   \"get\",\n\t\t\t\tScope:    \"*\",\n\t\t\t},\n\t\t}, \"app-creator\")\n\n\tGivenWithSameState(t).\n\t\tPath(\"guestbook-logs\").\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tSetParamInSettingConfigMap(\"server.rbac.log.enforce.enable\", \"true\").\n\t\tThen().\n\t\tExpect(HealthIs(health.HealthStatusHealthy)).\n\t\tAnd(func(app *Application) {\n\t\t\tout, err := RunCli(\"app\", \"logs\", app.Name, \"--kind\", \"Deployment\", \"--group\", \"\", \"--name\", \"guestbook-ui\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, out, \"Hi\")\n\t\t}).\n\t\tAnd(func(app *Application) {\n\t\t\tout, err := RunCli(\"app\", \"logs\", app.Name, \"--kind\", \"Pod\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, out, \"Hi\")\n\t\t}).\n\t\tAnd(func(app *Application) {\n\t\t\tout, err := RunCli(\"app\", \"logs\", app.Name, \"--kind\", \"Service\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.NotContains(t, out, \"Hi\")\n\t\t})\n\n}\n\nfunc TestGetLogsAllowSwitchOff(t *testing.T) {\n\tSkipOnEnv(t, \"OPENSHIFT\")\n\n\taccountFixture.Given(t).\n\t\tName(\"test\").\n\t\tWhen().\n\t\tCreate().\n\t\tLogin().\n\t\tSetPermissions([]fixture.ACL{\n\t\t\t{\n\t\t\t\tResource: \"applications\",\n\t\t\t\tAction:   \"create\",\n\t\t\t\tScope:    \"*\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tResource: \"applications\",\n\t\t\t\tAction:   \"get\",\n\t\t\t\tScope:    \"*\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tResource: \"applications\",\n\t\t\t\tAction:   \"sync\",\n\t\t\t\tScope:    \"*\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tResource: \"projects\",\n\t\t\t\tAction:   \"get\",\n\t\t\t\tScope:    \"*\",\n\t\t\t},\n\t\t}, \"app-creator\")\n\n\tGiven(t).\n\t\tPath(\"guestbook-logs\").\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tSetParamInSettingConfigMap(\"server.rbac.log.enforce.enable\", \"false\").\n\t\tThen().\n\t\tExpect(HealthIs(health.HealthStatusHealthy)).\n\t\tAnd(func(app *Application) {\n\t\t\tout, err := RunCli(\"app\", \"logs\", app.Name, \"--kind\", \"Deployment\", \"--group\", \"\", \"--name\", \"guestbook-ui\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, out, \"Hi\")\n\t\t}).\n\t\tAnd(func(app *Application) {\n\t\t\tout, err := RunCli(\"app\", \"logs\", app.Name, \"--kind\", \"Pod\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, out, \"Hi\")\n\t\t}).\n\t\tAnd(func(app *Application) {\n\t\t\tout, err := RunCli(\"app\", \"logs\", app.Name, \"--kind\", \"Service\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.NotContains(t, out, \"Hi\")\n\t\t})\n}\n\nfunc TestSyncToUnsignedCommit(t *testing.T) {\n\tSkipOnEnv(t, \"GPG\")\n\tGiven(t).\n\t\tProject(\"gpg\").\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tIgnoreErrors().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationError)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tExpect(HealthIs(health.HealthStatusMissing))\n}\n\nfunc TestSyncToSignedCommitWithoutKnownKey(t *testing.T) {\n\tSkipOnEnv(t, \"GPG\")\n\tGiven(t).\n\t\tProject(\"gpg\").\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tAddSignedFile(\"test.yaml\", \"null\").\n\t\tIgnoreErrors().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationError)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tExpect(HealthIs(health.HealthStatusMissing))\n}\n\nfunc TestSyncToSignedCommitKeyWithKnownKey(t *testing.T) {\n\tSkipOnEnv(t, \"GPG\")\n\tGiven(t).\n\t\tProject(\"gpg\").\n\t\tPath(guestbookPath).\n\t\tGPGPublicKeyAdded().\n\t\tSleep(2).\n\t\tWhen().\n\t\tAddSignedFile(\"test.yaml\", \"null\").\n\t\tIgnoreErrors().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tExpect(HealthIs(health.HealthStatusHealthy))\n}\n\nfunc TestAppCreation(t *testing.T) {\n\tctx := Given(t)\n\n\tctx.\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Equal(t, Name(), app.Name)\n\t\t\tassert.Equal(t, RepoURL(RepoURLTypeFile), app.Spec.Source.RepoURL)\n\t\t\tassert.Equal(t, guestbookPath, app.Spec.Source.Path)\n\t\t\tassert.Equal(t, DeploymentNamespace(), app.Spec.Destination.Namespace)\n\t\t\tassert.Equal(t, KubernetesInternalAPIServerAddr, app.Spec.Destination.Server)\n\t\t}).\n\t\tExpect(Event(EventReasonResourceCreated, \"create\")).\n\t\tAnd(func(_ *Application) {\n\t\t\t// app should be listed\n\t\t\toutput, err := RunCli(\"app\", \"list\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, output, Name())\n\t\t}).\n\t\tWhen().\n\t\t// ensure that create is idempotent\n\t\tCreateApp().\n\t\tThen().\n\t\tGiven().\n\t\tRevision(\"master\").\n\t\tWhen().\n\t\t// ensure that update replaces spec and merge labels and annotations\n\t\tAnd(func() {\n\t\t\tFailOnErr(AppClientset.ArgoprojV1alpha1().Applications(ArgoCDNamespace).Patch(context.Background(),\n\t\t\t\tctx.GetName(), types.MergePatchType, []byte(`{\"metadata\": {\"labels\": { \"test\": \"label\" }, \"annotations\": { \"test\": \"annotation\" }}}`), metav1.PatchOptions{}))\n\t\t}).\n\t\tCreateApp(\"--upsert\").\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Equal(t, \"label\", app.Labels[\"test\"])\n\t\t\tassert.Equal(t, \"annotation\", app.Annotations[\"test\"])\n\t\t\tassert.Equal(t, \"master\", app.Spec.Source.TargetRevision)\n\t\t})\n}\n\nfunc TestAppCreationWithoutForceUpdate(t *testing.T) {\n\tctx := Given(t)\n\n\tctx.\n\t\tPath(guestbookPath).\n\t\tDestName(\"in-cluster\").\n\t\tWhen().\n\t\tCreateApp().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Equal(t, Name(), app.Name)\n\t\t\tassert.Equal(t, RepoURL(RepoURLTypeFile), app.Spec.Source.RepoURL)\n\t\t\tassert.Equal(t, guestbookPath, app.Spec.Source.Path)\n\t\t\tassert.Equal(t, DeploymentNamespace(), app.Spec.Destination.Namespace)\n\t\t\tassert.Equal(t, \"in-cluster\", app.Spec.Destination.Name)\n\t\t}).\n\t\tExpect(Event(EventReasonResourceCreated, \"create\")).\n\t\tAnd(func(_ *Application) {\n\t\t\t// app should be listed\n\t\t\toutput, err := RunCli(\"app\", \"list\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, output, Name())\n\t\t}).\n\t\tWhen().\n\t\tIgnoreErrors().\n\t\tCreateApp().\n\t\tThen().\n\t\tExpect(Error(\"\", \"existing application spec is different, use upsert flag to force update\"))\n}\n\nfunc TestDeleteAppResource(t *testing.T) {\n\tctx := Given(t)\n\n\tctx.\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(_ *Application) {\n\t\t\t// app should be listed\n\t\t\tif _, err := RunCli(\"app\", \"delete-resource\", Name(), \"--kind\", \"Service\", \"--resource-name\", \"guestbook-ui\"); err != nil {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t}).\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tExpect(HealthIs(health.HealthStatusMissing))\n}\n\n// demonstrate that we cannot use a standard sync when an immutable field is changed, we must use \"force\"\nfunc TestImmutableChange(t *testing.T) {\n\tSkipOnEnv(t, \"OPENSHIFT\")\n\ttext := FailOnErr(Run(\".\", \"kubectl\", \"get\", \"service\", \"-n\", \"kube-system\", \"kube-dns\", \"-o\", \"jsonpath={.spec.clusterIP}\")).(string)\n\tparts := strings.Split(text, \".\")\n\tn := rand.Intn(254)\n\tip1 := fmt.Sprintf(\"%s.%s.%s.%d\", parts[0], parts[1], parts[2], n)\n\tip2 := fmt.Sprintf(\"%s.%s.%s.%d\", parts[0], parts[1], parts[2], n+1)\n\tGiven(t).\n\t\tPath(\"service\").\n\t\tWhen().\n\t\tCreateApp().\n\t\tPatchFile(\"service.yaml\", fmt.Sprintf(`[{\"op\": \"add\", \"path\": \"/spec/clusterIP\", \"value\": \"%s\"}]`, ip1)).\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tExpect(HealthIs(health.HealthStatusHealthy)).\n\t\tWhen().\n\t\tPatchFile(\"service.yaml\", fmt.Sprintf(`[{\"op\": \"add\", \"path\": \"/spec/clusterIP\", \"value\": \"%s\"}]`, ip2)).\n\t\tIgnoreErrors().\n\t\tSync().\n\t\tDoNotIgnoreErrors().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationFailed)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tExpect(ResourceResultNumbering(1)).\n\t\tExpect(ResourceResultMatches(ResourceResult{\n\t\t\tKind:      \"Service\",\n\t\t\tVersion:   \"v1\",\n\t\t\tNamespace: DeploymentNamespace(),\n\t\t\tName:      \"my-service\",\n\t\t\tSyncPhase: \"Sync\",\n\t\t\tStatus:    \"SyncFailed\",\n\t\t\tHookPhase: \"Failed\",\n\t\t\tMessage:   `Service \"my-service\" is invalid`,\n\t\t})).\n\t\t// now we can do this will a force\n\t\tGiven().\n\t\tForce().\n\t\tWhen().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tExpect(HealthIs(health.HealthStatusHealthy))\n}\n\nfunc TestInvalidAppProject(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tProject(\"does-not-exist\").\n\t\tWhen().\n\t\tIgnoreErrors().\n\t\tCreateApp().\n\t\tThen().\n\t\tExpect(Error(\"\", \"application references project does-not-exist which does not exist\"))\n}\n\nfunc TestAppDeletion(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tWhen().\n\t\tDelete(true).\n\t\tThen().\n\t\tExpect(DoesNotExist()).\n\t\tExpect(Event(EventReasonResourceDeleted, \"delete\"))\n\n\toutput, err := RunCli(\"app\", \"list\")\n\tassert.NoError(t, err)\n\tassert.NotContains(t, output, Name())\n}\n\nfunc TestAppLabels(t *testing.T) {\n\tGiven(t).\n\t\tPath(\"config-map\").\n\t\tWhen().\n\t\tCreateApp(\"-l\", \"foo=bar\").\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Contains(t, FailOnErr(RunCli(\"app\", \"list\")), Name())\n\t\t\tassert.Contains(t, FailOnErr(RunCli(\"app\", \"list\", \"-l\", \"foo=bar\")), Name())\n\t\t\tassert.NotContains(t, FailOnErr(RunCli(\"app\", \"list\", \"-l\", \"foo=rubbish\")), Name())\n\t\t}).\n\t\tGiven().\n\t\t// remove both name and replace labels means nothing will sync\n\t\tName(\"\").\n\t\tWhen().\n\t\tIgnoreErrors().\n\t\tSync(\"-l\", \"foo=rubbish\").\n\t\tDoNotIgnoreErrors().\n\t\tThen().\n\t\tExpect(Error(\"\", \"no apps match selector foo=rubbish\")).\n\t\t// check we can update the app and it is then sync'd\n\t\tGiven().\n\t\tWhen().\n\t\tSync(\"-l\", \"foo=bar\")\n}\n\nfunc TestTrackAppStateAndSyncApp(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tExpect(HealthIs(health.HealthStatusHealthy)).\n\t\tExpect(Success(fmt.Sprintf(\"Service     %s  guestbook-ui  Synced \", DeploymentNamespace()))).\n\t\tExpect(Success(fmt.Sprintf(\"apps   Deployment  %s  guestbook-ui  Synced\", DeploymentNamespace()))).\n\t\tExpect(Event(EventReasonResourceUpdated, \"sync\")).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.NotNil(t, app.Status.OperationState.SyncResult)\n\t\t})\n}\n\nfunc TestAppRollbackSuccessful(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.NotEmpty(t, app.Status.Sync.Revision)\n\t\t}).\n\t\tAnd(func(app *Application) {\n\t\t\tappWithHistory := app.DeepCopy()\n\t\t\tappWithHistory.Status.History = []RevisionHistory{{\n\t\t\t\tID:         1,\n\t\t\t\tRevision:   app.Status.Sync.Revision,\n\t\t\t\tDeployedAt: metav1.Time{Time: metav1.Now().UTC().Add(-1 * time.Minute)},\n\t\t\t\tSource:     app.Spec.Source,\n\t\t\t}, {\n\t\t\t\tID:         2,\n\t\t\t\tRevision:   \"cdb\",\n\t\t\t\tDeployedAt: metav1.Time{Time: metav1.Now().UTC().Add(-2 * time.Minute)},\n\t\t\t\tSource:     app.Spec.Source,\n\t\t\t}}\n\t\t\tpatch, _, err := diff.CreateTwoWayMergePatch(app, appWithHistory, &Application{})\n\t\t\tassert.NoError(t, err)\n\n\t\t\tapp, err = AppClientset.ArgoprojV1alpha1().Applications(ArgoCDNamespace).Patch(context.Background(), app.Name, types.MergePatchType, patch, metav1.PatchOptions{})\n\t\t\tassert.NoError(t, err)\n\n\t\t\t// sync app and make sure it reaches InSync state\n\t\t\t_, err = RunCli(\"app\", \"rollback\", app.Name, \"1\")\n\t\t\tassert.NoError(t, err)\n\n\t\t}).\n\t\tExpect(Event(EventReasonOperationStarted, \"rollback\")).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Equal(t, SyncStatusCodeSynced, app.Status.Sync.Status)\n\t\t\tassert.NotNil(t, app.Status.OperationState.SyncResult)\n\t\t\tassert.Equal(t, 2, len(app.Status.OperationState.SyncResult.Resources))\n\t\t\tassert.Equal(t, OperationSucceeded, app.Status.OperationState.Phase)\n\t\t\tassert.Equal(t, 3, len(app.Status.History))\n\t\t})\n}\n\nfunc TestComparisonFailsIfClusterNotAdded(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tDestServer(\"https://not-registered-cluster/api\").\n\t\tWhen().\n\t\tIgnoreErrors().\n\t\tCreateApp().\n\t\tThen().\n\t\tExpect(DoesNotExist())\n}\n\nfunc TestCannotSetInvalidPath(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tIgnoreErrors().\n\t\tAppSet(\"--path\", \"garbage\").\n\t\tThen().\n\t\tExpect(Error(\"\", \"app path does not exist\"))\n}\n\nfunc TestManipulateApplicationResources(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tmanifests, err := RunCli(\"app\", \"manifests\", app.Name, \"--source\", \"live\")\n\t\t\tassert.NoError(t, err)\n\t\t\tresources, err := kube.SplitYAML([]byte(manifests))\n\t\t\tassert.NoError(t, err)\n\n\t\t\tindex := -1\n\t\t\tfor i := range resources {\n\t\t\t\tif resources[i].GetKind() == kube.DeploymentKind {\n\t\t\t\t\tindex = i\n\t\t\t\t\tbreak\n\t\t\t\t}\n\t\t\t}\n\t\t\tassert.True(t, index > -1)\n\n\t\t\tdeployment := resources[index]\n\n\t\t\tcloser, client, err := ArgoCDClientset.NewApplicationClient()\n\t\t\tassert.NoError(t, err)\n\t\t\tdefer io.Close(closer)\n\n\t\t\t_, err = client.DeleteResource(context.Background(), &applicationpkg.ApplicationResourceDeleteRequest{\n\t\t\t\tName:         &app.Name,\n\t\t\t\tGroup:        deployment.GroupVersionKind().Group,\n\t\t\t\tKind:         deployment.GroupVersionKind().Kind,\n\t\t\t\tVersion:      deployment.GroupVersionKind().Version,\n\t\t\t\tNamespace:    deployment.GetNamespace(),\n\t\t\t\tResourceName: deployment.GetName(),\n\t\t\t})\n\t\t\tassert.NoError(t, err)\n\t\t}).\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync))\n}\n\nfunc assetSecretDataHidden(t *testing.T, manifest string) {\n\tsecret, err := UnmarshalToUnstructured(manifest)\n\tassert.NoError(t, err)\n\n\t_, hasStringData, err := unstructured.NestedMap(secret.Object, \"stringData\")\n\tassert.NoError(t, err)\n\tassert.False(t, hasStringData)\n\n\tsecretData, hasData, err := unstructured.NestedMap(secret.Object, \"data\")\n\tassert.NoError(t, err)\n\tassert.True(t, hasData)\n\tfor _, v := range secretData {\n\t\tassert.Regexp(t, regexp.MustCompile(`[*]*`), v)\n\t}\n\tvar lastAppliedConfigAnnotation string\n\tannotations := secret.GetAnnotations()\n\tif annotations != nil {\n\t\tlastAppliedConfigAnnotation = annotations[v1.LastAppliedConfigAnnotation]\n\t}\n\tif lastAppliedConfigAnnotation != \"\" {\n\t\tassetSecretDataHidden(t, lastAppliedConfigAnnotation)\n\t}\n}\n\nfunc TestAppWithSecrets(t *testing.T) {\n\tcloser, client, err := ArgoCDClientset.NewApplicationClient()\n\tassert.NoError(t, err)\n\tdefer io.Close(closer)\n\n\tGiven(t).\n\t\tPath(\"secrets\").\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tres := FailOnErr(client.GetResource(context.Background(), &applicationpkg.ApplicationResourceRequest{\n\t\t\t\tNamespace:    app.Spec.Destination.Namespace,\n\t\t\t\tKind:         kube.SecretKind,\n\t\t\t\tGroup:        \"\",\n\t\t\t\tName:         &app.Name,\n\t\t\t\tVersion:      \"v1\",\n\t\t\t\tResourceName: \"test-secret\",\n\t\t\t})).(*applicationpkg.ApplicationResourceResponse)\n\t\t\tassetSecretDataHidden(t, res.Manifest)\n\n\t\t\tmanifests, err := client.GetManifests(context.Background(), &applicationpkg.ApplicationManifestQuery{Name: &app.Name})\n\t\t\terrors.CheckError(err)\n\n\t\t\tfor _, manifest := range manifests.Manifests {\n\t\t\t\tassetSecretDataHidden(t, manifest)\n\t\t\t}\n\n\t\t\tdiffOutput := FailOnErr(RunCli(\"app\", \"diff\", app.Name)).(string)\n\t\t\tassert.Empty(t, diffOutput)\n\n\t\t\t// make sure resource update error does not print secret details\n\t\t\t_, err = RunCli(\"app\", \"patch-resource\", \"test-app-with-secrets\", \"--resource-name\", \"test-secret\",\n\t\t\t\t\"--kind\", \"Secret\", \"--patch\", `{\"op\": \"add\", \"path\": \"/data\", \"value\": \"hello\"}'`,\n\t\t\t\t\"--patch-type\", \"application/json-patch+json\")\n\t\t\trequire.Error(t, err)\n\t\t\tassert.Contains(t, err.Error(), fmt.Sprintf(\"failed to patch Secret %s/test-secret\", DeploymentNamespace()))\n\t\t\tassert.NotContains(t, err.Error(), \"username\")\n\t\t\tassert.NotContains(t, err.Error(), \"password\")\n\n\t\t\t// patch secret and make sure app is out of sync and diff detects the change\n\t\t\tFailOnErr(KubeClientset.CoreV1().Secrets(DeploymentNamespace()).Patch(context.Background(),\n\t\t\t\t\"test-secret\", types.JSONPatchType, []byte(`[\n\t{\"op\": \"remove\", \"path\": \"/data/username\"},\n\t{\"op\": \"add\", \"path\": \"/stringData\", \"value\": {\"password\": \"foo\"}}\n]`), metav1.PatchOptions{}))\n\t\t}).\n\t\tWhen().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tAnd(func(app *Application) {\n\t\t\tdiffOutput, err := RunCli(\"app\", \"diff\", app.Name)\n\t\t\tassert.Error(t, err)\n\t\t\tassert.Contains(t, diffOutput, \"username: ++++++++\")\n\t\t\tassert.Contains(t, diffOutput, \"password: ++++++++++++\")\n\n\t\t\t// local diff should ignore secrets\n\t\t\tdiffOutput = FailOnErr(RunCli(\"app\", \"diff\", app.Name, \"--local\", \"testdata/secrets\")).(string)\n\t\t\tassert.Empty(t, diffOutput)\n\n\t\t\t// ignore missing field and make sure diff shows no difference\n\t\t\tapp.Spec.IgnoreDifferences = []ResourceIgnoreDifferences{{\n\t\t\t\tKind: kube.SecretKind, JSONPointers: []string{\"/data\"},\n\t\t\t}}\n\t\t\tFailOnErr(client.UpdateSpec(context.Background(), &applicationpkg.ApplicationUpdateSpecRequest{Name: &app.Name, Spec: app.Spec}))\n\t\t}).\n\t\tWhen().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tdiffOutput := FailOnErr(RunCli(\"app\", \"diff\", app.Name)).(string)\n\t\t\tassert.Empty(t, diffOutput)\n\t\t}).\n\t\t// verify not committed secret also ignore during diffing\n\t\tWhen().\n\t\tWriteFile(\"secret3.yaml\", `\napiVersion: v1\nkind: Secret\nmetadata:\n  name: test-secret3\nstringData:\n  username: test-username`).\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\tdiffOutput := FailOnErr(RunCli(\"app\", \"diff\", app.Name, \"--local\", \"testdata/secrets\")).(string)\n\t\t\tassert.Empty(t, diffOutput)\n\t\t})\n}\n\nfunc TestResourceDiffing(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\t// Patch deployment\n\t\t\t_, err := KubeClientset.AppsV1().Deployments(DeploymentNamespace()).Patch(context.Background(),\n\t\t\t\t\"guestbook-ui\", types.JSONPatchType, []byte(`[{ \"op\": \"replace\", \"path\": \"/spec/template/spec/containers/0/image\", \"value\": \"test\" }]`), metav1.PatchOptions{})\n\t\t\tassert.NoError(t, err)\n\t\t}).\n\t\tWhen().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tAnd(func(app *Application) {\n\t\t\tdiffOutput, err := RunCli(\"app\", \"diff\", app.Name, \"--local\", \"testdata/guestbook\")\n\t\t\tassert.Error(t, err)\n\t\t\tassert.Contains(t, diffOutput, fmt.Sprintf(\"===== apps/Deployment %s/guestbook-ui ======\", DeploymentNamespace()))\n\t\t}).\n\t\tGiven().\n\t\tResourceOverrides(map[string]ResourceOverride{\"apps/Deployment\": {\n\t\t\tIgnoreDifferences: OverrideIgnoreDiff{JSONPointers: []string{\"/spec/template/spec/containers/0/image\"}},\n\t\t}}).\n\t\tWhen().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tdiffOutput, err := RunCli(\"app\", \"diff\", app.Name, \"--local\", \"testdata/guestbook\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Empty(t, diffOutput)\n\t\t}).\n\t\tGiven().\n\t\tWhen().\n\t\tAnd(func() {\n\t\t\toutput, err := RunWithStdin(testdata.SSARevisionHistoryDeployment, \"\", \"kubectl\", \"apply\", \"-n\", DeploymentNamespace(), \"--server-side=true\", \"--field-manager=revision-history-manager\", \"--validate=false\", \"--force-conflicts\", \"-f\", \"-\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, output, \"serverside-applied\")\n\t\t}).\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tGiven().\n\t\tResourceOverrides(map[string]ResourceOverride{\"apps/Deployment\": {\n\t\t\tIgnoreDifferences: OverrideIgnoreDiff{\n\t\t\t\tManagedFieldsManagers: []string{\"revision-history-manager\"},\n\t\t\t\tJSONPointers:          []string{\"/spec/template/spec/containers/0/image\"},\n\t\t\t},\n\t\t}}).\n\t\tWhen().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tGiven().\n\t\tWhen().\n\t\tSync().\n\t\tPatchApp(`[{\n\t\t\t\"op\": \"add\",\n\t\t\t\"path\": \"/spec/syncPolicy\",\n\t\t\t\"value\": { \"syncOptions\": [\"RespectIgnoreDifferences=true\"] }\n\t\t\t}]`).\n\t\tAnd(func() {\n\t\t\tdeployment, err := KubeClientset.AppsV1().Deployments(DeploymentNamespace()).Get(context.Background(), \"guestbook-ui\", metav1.GetOptions{})\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, int32(3), *deployment.Spec.RevisionHistoryLimit)\n\t\t}).\n\t\tAnd(func() {\n\t\t\toutput, err := RunWithStdin(testdata.SSARevisionHistoryDeployment, \"\", \"kubectl\", \"apply\", \"-n\", DeploymentNamespace(), \"--server-side=true\", \"--field-manager=revision-history-manager\", \"--validate=false\", \"--force-conflicts\", \"-f\", \"-\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, output, \"serverside-applied\")\n\t\t}).\n\t\tThen().\n\t\tWhen().Refresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tdeployment, err := KubeClientset.AppsV1().Deployments(DeploymentNamespace()).Get(context.Background(), \"guestbook-ui\", metav1.GetOptions{})\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, int32(1), *deployment.Spec.RevisionHistoryLimit)\n\t\t}).\n\t\tWhen().Sync().Then().Expect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tdeployment, err := KubeClientset.AppsV1().Deployments(DeploymentNamespace()).Get(context.Background(), \"guestbook-ui\", metav1.GetOptions{})\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, int32(1), *deployment.Spec.RevisionHistoryLimit)\n\t\t})\n}\n\nfunc TestCRDs(t *testing.T) {\n\ttestEdgeCasesApplicationResources(t, \"crd-creation\", health.HealthStatusHealthy)\n}\n\nfunc TestKnownTypesInCRDDiffing(t *testing.T) {\n\tdummiesGVR := schema.GroupVersionResource{Group: \"argoproj.io\", Version: \"v1alpha1\", Resource: \"dummies\"}\n\n\tGiven(t).\n\t\tPath(\"crd-creation\").\n\t\tWhen().CreateApp().Sync().Then().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).Expect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tWhen().\n\t\tAnd(func() {\n\t\t\tdummyResIf := DynamicClientset.Resource(dummiesGVR).Namespace(DeploymentNamespace())\n\t\t\tpatchData := []byte(`{\"spec\":{\"cpu\": \"2\"}}`)\n\t\t\tFailOnErr(dummyResIf.Patch(context.Background(), \"dummy-crd-instance\", types.MergePatchType, patchData, metav1.PatchOptions{}))\n\t\t}).Refresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tWhen().\n\t\tAnd(func() {\n\t\t\tSetResourceOverrides(map[string]ResourceOverride{\n\t\t\t\t\"argoproj.io/Dummy\": {\n\t\t\t\t\tKnownTypeFields: []KnownTypeField{{\n\t\t\t\t\t\tField: \"spec\",\n\t\t\t\t\t\tType:  \"core/v1/ResourceList\",\n\t\t\t\t\t}},\n\t\t\t\t},\n\t\t\t})\n\t\t}).\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced))\n}\n\nfunc TestDuplicatedResources(t *testing.T) {\n\ttestEdgeCasesApplicationResources(t, \"duplicated-resources\", health.HealthStatusHealthy)\n}\n\nfunc TestConfigMap(t *testing.T) {\n\ttestEdgeCasesApplicationResources(t, \"config-map\", health.HealthStatusHealthy, \"my-map  Synced                configmap/my-map created\")\n}\n\nfunc TestFailedConversion(t *testing.T) {\n\tif os.Getenv(\"ARGOCD_E2E_K3S\") == \"true\" {\n\t\tt.SkipNow()\n\t}\n\tdefer func() {\n\t\tFailOnErr(Run(\"\", \"kubectl\", \"delete\", \"apiservice\", \"v1beta1.metrics.k8s.io\"))\n\t}()\n\n\ttestEdgeCasesApplicationResources(t, \"failed-conversion\", health.HealthStatusProgressing)\n}\n\nfunc testEdgeCasesApplicationResources(t *testing.T, appPath string, statusCode health.HealthStatusCode, message ...string) {\n\texpect := Given(t).\n\t\tPath(appPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced))\n\tfor i := range message {\n\t\texpect = expect.Expect(Success(message[i]))\n\t}\n\texpect.\n\t\tExpect(HealthIs(statusCode)).\n\t\tAnd(func(app *Application) {\n\t\t\tdiffOutput, err := RunCli(\"app\", \"diff\", app.Name, \"--local\", path.Join(\"testdata\", appPath))\n\t\t\tassert.Empty(t, diffOutput)\n\t\t\tassert.NoError(t, err)\n\t\t})\n}\n\nconst actionsConfig = `discovery.lua: return { sample = {} }\ndefinitions:\n- name: sample\n  action.lua: |\n    obj.metadata.labels.sample = 'test'\n    return obj`\n\nfunc TestResourceAction(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tResourceOverrides(map[string]ResourceOverride{\"apps/Deployment\": {Actions: actionsConfig}}).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\n\t\t\tcloser, client, err := ArgoCDClientset.NewApplicationClient()\n\t\t\tassert.NoError(t, err)\n\t\t\tdefer io.Close(closer)\n\n\t\t\tactions, err := client.ListResourceActions(context.Background(), &applicationpkg.ApplicationResourceRequest{\n\t\t\t\tName:         &app.Name,\n\t\t\t\tGroup:        \"apps\",\n\t\t\t\tKind:         \"Deployment\",\n\t\t\t\tVersion:      \"v1\",\n\t\t\t\tNamespace:    DeploymentNamespace(),\n\t\t\t\tResourceName: \"guestbook-ui\",\n\t\t\t})\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Equal(t, []ResourceAction{{Name: \"sample\", Disabled: false}}, actions.Actions)\n\n\t\t\t_, err = client.RunResourceAction(context.Background(), &applicationpkg.ResourceActionRunRequest{Name: &app.Name,\n\t\t\t\tGroup:        \"apps\",\n\t\t\t\tKind:         \"Deployment\",\n\t\t\t\tVersion:      \"v1\",\n\t\t\t\tNamespace:    DeploymentNamespace(),\n\t\t\t\tResourceName: \"guestbook-ui\",\n\t\t\t\tAction:       \"sample\",\n\t\t\t})\n\t\t\tassert.NoError(t, err)\n\n\t\t\tdeployment, err := KubeClientset.AppsV1().Deployments(DeploymentNamespace()).Get(context.Background(), \"guestbook-ui\", metav1.GetOptions{})\n\t\t\tassert.NoError(t, err)\n\n\t\t\tassert.Equal(t, \"test\", deployment.Labels[\"sample\"])\n\t\t})\n}\n\nfunc TestSyncResourceByLabel(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\t_, _ = RunCli(\"app\", \"sync\", app.Name, \"--label\", fmt.Sprintf(\"app.kubernetes.io/instance=%s\", app.Name))\n\t\t}).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\t_, err := RunCli(\"app\", \"sync\", app.Name, \"--label\", \"this-label=does-not-exist\")\n\t\t\tassert.Error(t, err)\n\t\t\tassert.Contains(t, err.Error(), \"level=fatal\")\n\t\t})\n}\n\nfunc TestLocalManifestSync(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\tres, _ := RunCli(\"app\", \"manifests\", app.Name)\n\t\t\tassert.Contains(t, res, \"containerPort: 80\")\n\t\t\tassert.Contains(t, res, \"image: gcr.io/heptio-images/ks-guestbook-demo:0.2\")\n\t\t}).\n\t\tGiven().\n\t\tLocalPath(guestbookPathLocal).\n\t\tWhen().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tres, _ := RunCli(\"app\", \"manifests\", app.Name)\n\t\t\tassert.Contains(t, res, \"containerPort: 81\")\n\t\t\tassert.Contains(t, res, \"image: gcr.io/heptio-images/ks-guestbook-demo:0.3\")\n\t\t}).\n\t\tGiven().\n\t\tLocalPath(\"\").\n\t\tWhen().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tres, _ := RunCli(\"app\", \"manifests\", app.Name)\n\t\t\tassert.Contains(t, res, \"containerPort: 80\")\n\t\t\tassert.Contains(t, res, \"image: gcr.io/heptio-images/ks-guestbook-demo:0.2\")\n\t\t})\n}\n\nfunc TestLocalSync(t *testing.T) {\n\tGiven(t).\n\t\t// we've got to use Helm as this uses kubeVersion\n\t\tPath(\"helm\").\n\t\tWhen().\n\t\tCreateApp().\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\tFailOnErr(RunCli(\"app\", \"sync\", app.Name, \"--local\", \"testdata/helm\"))\n\t\t})\n}\n\nfunc TestNoLocalSyncWithAutosyncEnabled(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\t_, err := RunCli(\"app\", \"set\", app.Name, \"--sync-policy\", \"automated\")\n\t\t\tassert.NoError(t, err)\n\n\t\t\t_, err = RunCli(\"app\", \"sync\", app.Name, \"--local\", guestbookPathLocal)\n\t\t\tassert.Error(t, err)\n\t\t})\n}\n\nfunc TestLocalSyncDryRunWithAutosyncEnabled(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\t_, err := RunCli(\"app\", \"set\", app.Name, \"--sync-policy\", \"automated\")\n\t\t\tassert.NoError(t, err)\n\n\t\t\tappBefore := app.DeepCopy()\n\t\t\t_, err = RunCli(\"app\", \"sync\", app.Name, \"--dry-run\", \"--local\", guestbookPathLocal)\n\t\t\tassert.NoError(t, err)\n\n\t\t\tappAfter := app.DeepCopy()\n\t\t\tassert.True(t, reflect.DeepEqual(appBefore, appAfter))\n\t\t})\n}\n\nfunc TestSyncAsync(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tAsync(true).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(Success(\"\")).\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced))\n}\n\n// assertResourceActions verifies if view/modify resource actions are successful/failing for given application\nfunc assertResourceActions(t *testing.T, appName string, successful bool) {\n\tassertError := func(err error, message string) {\n\t\tif successful {\n\t\t\tassert.NoError(t, err)\n\t\t} else {\n\t\t\tif assert.Error(t, err) {\n\t\t\t\tassert.Contains(t, err.Error(), message)\n\t\t\t}\n\t\t}\n\t}\n\n\tcloser, cdClient := ArgoCDClientset.NewApplicationClientOrDie()\n\tdefer io.Close(closer)\n\n\tdeploymentResource, err := KubeClientset.AppsV1().Deployments(DeploymentNamespace()).Get(context.Background(), \"guestbook-ui\", metav1.GetOptions{})\n\trequire.NoError(t, err)\n\n\tlogs, err := cdClient.PodLogs(context.Background(), &applicationpkg.ApplicationPodLogsQuery{\n\t\tGroup: pointer.String(\"apps\"), Kind: pointer.String(\"Deployment\"), Name: &appName, Namespace: DeploymentNamespace(),\n\t})\n\trequire.NoError(t, err)\n\t_, err = logs.Recv()\n\tassertError(err, \"EOF\")\n\n\texpectedError := fmt.Sprintf(\"Deployment apps guestbook-ui not found as part of application %s\", appName)\n\n\t_, err = cdClient.ListResourceEvents(context.Background(), &applicationpkg.ApplicationResourceEventsQuery{\n\t\tName: &appName, ResourceName: \"guestbook-ui\", ResourceNamespace: DeploymentNamespace(), ResourceUID: string(deploymentResource.UID)})\n\tassertError(err, fmt.Sprintf(\"%s not found as part of application %s\", \"guestbook-ui\", appName))\n\n\t_, err = cdClient.GetResource(context.Background(), &applicationpkg.ApplicationResourceRequest{\n\t\tName: &appName, ResourceName: \"guestbook-ui\", Namespace: DeploymentNamespace(), Version: \"v1\", Group: \"apps\", Kind: \"Deployment\"})\n\tassertError(err, expectedError)\n\n\t_, err = cdClient.DeleteResource(context.Background(), &applicationpkg.ApplicationResourceDeleteRequest{\n\t\tName: &appName, ResourceName: \"guestbook-ui\", Namespace: DeploymentNamespace(), Version: \"v1\", Group: \"apps\", Kind: \"Deployment\",\n\t})\n\tassertError(err, expectedError)\n\n\t_, err = cdClient.RunResourceAction(context.Background(), &applicationpkg.ResourceActionRunRequest{\n\t\tName: &appName, ResourceName: \"guestbook-ui\", Namespace: DeploymentNamespace(), Version: \"v1\", Group: \"apps\", Kind: \"Deployment\", Action: \"restart\",\n\t})\n\tassertError(err, expectedError)\n}\n\nfunc TestPermissions(t *testing.T) {\n\tappCtx := Given(t)\n\tprojName := \"argo-project\"\n\tprojActions := projectFixture.\n\t\tGiven(t).\n\t\tName(projName).\n\t\tWhen().\n\t\tCreate()\n\n\tsourceError := fmt.Sprintf(\"application repo %s is not permitted in project 'argo-project'\", RepoURL(RepoURLTypeFile))\n\tdestinationError := fmt.Sprintf(\"application destination {%s %s} is not permitted in project 'argo-project'\", KubernetesInternalAPIServerAddr, DeploymentNamespace())\n\n\tappCtx.\n\t\tPath(\"guestbook-logs\").\n\t\tProject(projName).\n\t\tWhen().\n\t\tIgnoreErrors().\n\t\t// ensure app is not created if project permissions are missing\n\t\tCreateApp().\n\t\tThen().\n\t\tExpect(Error(\"\", sourceError)).\n\t\tExpect(Error(\"\", destinationError)).\n\t\tWhen().\n\t\tDoNotIgnoreErrors().\n\t\t// add missing permissions, create and sync app\n\t\tAnd(func() {\n\t\t\tprojActions.AddDestination(\"*\", \"*\")\n\t\t\tprojActions.AddSource(\"*\")\n\t\t}).\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\t// make sure application resource actiions are successful\n\t\tAnd(func(app *Application) {\n\t\t\tassertResourceActions(t, app.Name, true)\n\t\t}).\n\t\tWhen().\n\t\t// remove projet permissions and \"refresh\" app\n\t\tAnd(func() {\n\t\t\tprojActions.UpdateProject(func(proj *AppProject) {\n\t\t\t\tproj.Spec.Destinations = nil\n\t\t\t\tproj.Spec.SourceRepos = nil\n\t\t\t})\n\t\t}).\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\t// ensure app resource tree is empty when source/destination permissions are missing\n\t\tExpect(Condition(ApplicationConditionInvalidSpecError, destinationError)).\n\t\tExpect(Condition(ApplicationConditionInvalidSpecError, sourceError)).\n\t\tAnd(func(app *Application) {\n\t\t\tcloser, cdClient := ArgoCDClientset.NewApplicationClientOrDie()\n\t\t\tdefer io.Close(closer)\n\t\t\ttree, err := cdClient.ResourceTree(context.Background(), &applicationpkg.ResourcesQuery{ApplicationName: &app.Name})\n\t\t\trequire.NoError(t, err)\n\t\t\tassert.Len(t, tree.Nodes, 0)\n\t\t\tassert.Len(t, tree.OrphanedNodes, 0)\n\t\t}).\n\t\tWhen().\n\t\t// add missing permissions but deny management of Deployment kind\n\t\tAnd(func() {\n\t\t\tprojActions.\n\t\t\t\tAddDestination(\"*\", \"*\").\n\t\t\t\tAddSource(\"*\").\n\t\t\t\tUpdateProject(func(proj *AppProject) {\n\t\t\t\t\tproj.Spec.NamespaceResourceBlacklist = []metav1.GroupKind{{Group: \"*\", Kind: \"Deployment\"}}\n\t\t\t\t})\n\t\t}).\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\t// make sure application resource actiions are failing\n\t\tAnd(func(app *Application) {\n\t\t\tassertResourceActions(t, \"test-permissions\", false)\n\t\t})\n}\n\nfunc TestPermissionWithScopedRepo(t *testing.T) {\n\tprojName := \"argo-project\"\n\tprojectFixture.\n\t\tGiven(t).\n\t\tName(projName).\n\t\tDestination(\"*,*\").\n\t\tWhen().\n\t\tCreate()\n\n\trepoFixture.Given(t, true).\n\t\tWhen().\n\t\tPath(RepoURL(RepoURLTypeFile)).\n\t\tProject(projName).\n\t\tCreate()\n\n\tGivenWithSameState(t).\n\t\tProject(projName).\n\t\tRepoURLType(RepoURLTypeFile).\n\t\tPath(\"two-nice-pods\").\n\t\tWhen().\n\t\tPatchFile(\"pod-1.yaml\", `[{\"op\": \"add\", \"path\": \"/metadata/annotations\", \"value\": {\"argocd.argoproj.io/sync-options\": \"Prune=false\"}}]`).\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tWhen().\n\t\tDeleteFile(\"pod-1.yaml\").\n\t\tRefresh(RefreshTypeHard).\n\t\tIgnoreErrors().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tExpect(ResourceSyncStatusIs(\"Pod\", \"pod-1\", SyncStatusCodeOutOfSync))\n}\n\nfunc TestPermissionDeniedWithScopedRepo(t *testing.T) {\n\tprojName := \"argo-project\"\n\tprojectFixture.\n\t\tGiven(t).\n\t\tName(projName).\n\t\tDestination(\"*,*\").\n\t\tWhen().\n\t\tCreate()\n\n\trepoFixture.Given(t, true).\n\t\tWhen().\n\t\tPath(RepoURL(RepoURLTypeFile)).\n\t\tCreate()\n\n\tGivenWithSameState(t).\n\t\tProject(projName).\n\t\tRepoURLType(RepoURLTypeFile).\n\t\tPath(\"two-nice-pods\").\n\t\tWhen().\n\t\tPatchFile(\"pod-1.yaml\", `[{\"op\": \"add\", \"path\": \"/metadata/annotations\", \"value\": {\"argocd.argoproj.io/sync-options\": \"Prune=false\"}}]`).\n\t\tIgnoreErrors().\n\t\tCreateApp().\n\t\tThen().\n\t\tExpect(Error(\"\", \"is not permitted in project\"))\n\n}\n\n// make sure that if we deleted a resource from the app, it is not pruned if annotated with Prune=false\nfunc TestSyncOptionPruneFalse(t *testing.T) {\n\tGiven(t).\n\t\tPath(\"two-nice-pods\").\n\t\tWhen().\n\t\tPatchFile(\"pod-1.yaml\", `[{\"op\": \"add\", \"path\": \"/metadata/annotations\", \"value\": {\"argocd.argoproj.io/sync-options\": \"Prune=false\"}}]`).\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tWhen().\n\t\tDeleteFile(\"pod-1.yaml\").\n\t\tRefresh(RefreshTypeHard).\n\t\tIgnoreErrors().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tExpect(ResourceSyncStatusIs(\"Pod\", \"pod-1\", SyncStatusCodeOutOfSync))\n}\n\n// make sure that if we have an invalid manifest, we can add it if we disable validation, we get a server error rather than a client error\nfunc TestSyncOptionValidateFalse(t *testing.T) {\n\n\t// k3s does not validate at all, so this test does not work\n\tif os.Getenv(\"ARGOCD_E2E_K3S\") == \"true\" {\n\t\tt.SkipNow()\n\t}\n\n\tGiven(t).\n\t\tPath(\"crd-validation\").\n\t\tWhen().\n\t\tCreateApp().\n\t\tThen().\n\t\tExpect(Success(\"\")).\n\t\tWhen().\n\t\tIgnoreErrors().\n\t\tSync().\n\t\tThen().\n\t\t// client error\n\t\tExpect(Error(\"error validating data\", \"\")).\n\t\tWhen().\n\t\tPatchFile(\"deployment.yaml\", `[{\"op\": \"add\", \"path\": \"/metadata/annotations\", \"value\": {\"argocd.argoproj.io/sync-options\": \"Validate=false\"}}]`).\n\t\tSync().\n\t\tThen().\n\t\t// server error\n\t\tExpect(Error(\"Error from server\", \"\"))\n}\n\n// make sure that, if we have a resource that needs pruning, but we're ignoring it, the app is in-sync\nfunc TestCompareOptionIgnoreExtraneous(t *testing.T) {\n\tGiven(t).\n\t\tPrune(false).\n\t\tPath(\"two-nice-pods\").\n\t\tWhen().\n\t\tPatchFile(\"pod-1.yaml\", `[{\"op\": \"add\", \"path\": \"/metadata/annotations\", \"value\": {\"argocd.argoproj.io/compare-options\": \"IgnoreExtraneous\"}}]`).\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tWhen().\n\t\tDeleteFile(\"pod-1.yaml\").\n\t\tRefresh(RefreshTypeHard).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Len(t, app.Status.Resources, 2)\n\t\t\tstatusByName := map[string]SyncStatusCode{}\n\t\t\tfor _, r := range app.Status.Resources {\n\t\t\t\tstatusByName[r.Name] = r.Status\n\t\t\t}\n\t\t\tassert.Equal(t, SyncStatusCodeOutOfSync, statusByName[\"pod-1\"])\n\t\t\tassert.Equal(t, SyncStatusCodeSynced, statusByName[\"pod-2\"])\n\t\t}).\n\t\tWhen().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced))\n}\n\nfunc TestSelfManagedApps(t *testing.T) {\n\n\tGiven(t).\n\t\tPath(\"self-managed-app\").\n\t\tWhen().\n\t\tPatchFile(\"resources.yaml\", fmt.Sprintf(`[{\"op\": \"replace\", \"path\": \"/spec/source/repoURL\", \"value\": \"%s\"}]`, RepoURL(RepoURLTypeFile))).\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(a *Application) {\n\t\t\tctx, cancel := context.WithTimeout(context.Background(), time.Second*3)\n\t\t\tdefer cancel()\n\n\t\t\treconciledCount := 0\n\t\t\tvar lastReconciledAt *metav1.Time\n\t\t\tfor event := range ArgoCDClientset.WatchApplicationWithRetry(ctx, a.Name, a.ResourceVersion) {\n\t\t\t\treconciledAt := event.Application.Status.ReconciledAt\n\t\t\t\tif reconciledAt == nil {\n\t\t\t\t\treconciledAt = &metav1.Time{}\n\t\t\t\t}\n\t\t\t\tif lastReconciledAt != nil && !lastReconciledAt.Equal(reconciledAt) {\n\t\t\t\t\treconciledCount = reconciledCount + 1\n\t\t\t\t}\n\t\t\t\tlastReconciledAt = reconciledAt\n\t\t\t}\n\n\t\t\tassert.True(t, reconciledCount < 3, \"Application was reconciled too many times\")\n\t\t})\n}\n\nfunc TestExcludedResource(t *testing.T) {\n\tGiven(t).\n\t\tResourceOverrides(map[string]ResourceOverride{\"apps/Deployment\": {Actions: actionsConfig}}).\n\t\tPath(guestbookPath).\n\t\tResourceFilter(settings.ResourcesFilter{\n\t\t\tResourceExclusions: []settings.FilteredResource{{Kinds: []string{kube.DeploymentKind}}},\n\t\t}).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(Condition(ApplicationConditionExcludedResourceWarning, \"Resource apps/Deployment guestbook-ui is excluded in the settings\"))\n}\n\nfunc TestRevisionHistoryLimit(t *testing.T) {\n\tGiven(t).\n\t\tPath(\"config-map\").\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Len(t, app.Status.History, 1)\n\t\t}).\n\t\tWhen().\n\t\tAppSet(\"--revision-history-limit\", \"1\").\n\t\tSync().\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Len(t, app.Status.History, 1)\n\t\t})\n}\n\nfunc TestOrphanedResource(t *testing.T) {\n\tSkipOnEnv(t, \"OPENSHIFT\")\n\tGiven(t).\n\t\tProjectSpec(AppProjectSpec{\n\t\t\tSourceRepos:       []string{\"*\"},\n\t\t\tDestinations:      []ApplicationDestination{{Namespace: \"*\", Server: \"*\"}},\n\t\t\tOrphanedResources: &OrphanedResourcesMonitorSettings{Warn: pointer.BoolPtr(true)},\n\t\t}).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tExpect(NoConditions()).\n\t\tWhen().\n\t\tAnd(func() {\n\t\t\tFailOnErr(KubeClientset.CoreV1().ConfigMaps(DeploymentNamespace()).Create(context.Background(), &v1.ConfigMap{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName: \"orphaned-configmap\",\n\t\t\t\t},\n\t\t\t}, metav1.CreateOptions{}))\n\t\t}).\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(Condition(ApplicationConditionOrphanedResourceWarning, \"Application has 1 orphaned resources\")).\n\t\tAnd(func(app *Application) {\n\t\t\toutput, err := RunCli(\"app\", \"resources\", app.Name)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, output, \"orphaned-configmap\")\n\t\t}).\n\t\tGiven().\n\t\tProjectSpec(AppProjectSpec{\n\t\t\tSourceRepos:       []string{\"*\"},\n\t\t\tDestinations:      []ApplicationDestination{{Namespace: \"*\", Server: \"*\"}},\n\t\t\tOrphanedResources: &OrphanedResourcesMonitorSettings{Warn: pointer.BoolPtr(true), Ignore: []OrphanedResourceKey{{Group: \"Test\", Kind: \"ConfigMap\"}}},\n\t\t}).\n\t\tWhen().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(Condition(ApplicationConditionOrphanedResourceWarning, \"Application has 1 orphaned resources\")).\n\t\tAnd(func(app *Application) {\n\t\t\toutput, err := RunCli(\"app\", \"resources\", app.Name)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, output, \"orphaned-configmap\")\n\t\t}).\n\t\tGiven().\n\t\tProjectSpec(AppProjectSpec{\n\t\t\tSourceRepos:       []string{\"*\"},\n\t\t\tDestinations:      []ApplicationDestination{{Namespace: \"*\", Server: \"*\"}},\n\t\t\tOrphanedResources: &OrphanedResourcesMonitorSettings{Warn: pointer.BoolPtr(true), Ignore: []OrphanedResourceKey{{Kind: \"ConfigMap\"}}},\n\t\t}).\n\t\tWhen().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tExpect(NoConditions()).\n\t\tAnd(func(app *Application) {\n\t\t\toutput, err := RunCli(\"app\", \"resources\", app.Name)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.NotContains(t, output, \"orphaned-configmap\")\n\t\t}).\n\t\tGiven().\n\t\tProjectSpec(AppProjectSpec{\n\t\t\tSourceRepos:       []string{\"*\"},\n\t\t\tDestinations:      []ApplicationDestination{{Namespace: \"*\", Server: \"*\"}},\n\t\t\tOrphanedResources: &OrphanedResourcesMonitorSettings{Warn: pointer.BoolPtr(true), Ignore: []OrphanedResourceKey{{Kind: \"ConfigMap\", Name: \"orphaned-configmap\"}}},\n\t\t}).\n\t\tWhen().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tExpect(NoConditions()).\n\t\tAnd(func(app *Application) {\n\t\t\toutput, err := RunCli(\"app\", \"resources\", app.Name)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.NotContains(t, output, \"orphaned-configmap\")\n\t\t}).\n\t\tGiven().\n\t\tProjectSpec(AppProjectSpec{\n\t\t\tSourceRepos:       []string{\"*\"},\n\t\t\tDestinations:      []ApplicationDestination{{Namespace: \"*\", Server: \"*\"}},\n\t\t\tOrphanedResources: nil,\n\t\t}).\n\t\tWhen().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tExpect(NoConditions())\n}\n\nfunc TestNotPermittedResources(t *testing.T) {\n\tctx := Given(t)\n\n\tpathType := networkingv1.PathTypePrefix\n\tingress := &networkingv1.Ingress{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName: \"sample-ingress\",\n\t\t\tLabels: map[string]string{\n\t\t\t\tcommon.LabelKeyAppInstance: ctx.GetName(),\n\t\t\t},\n\t\t},\n\t\tSpec: networkingv1.IngressSpec{\n\t\t\tRules: []networkingv1.IngressRule{{\n\t\t\t\tIngressRuleValue: networkingv1.IngressRuleValue{\n\t\t\t\t\tHTTP: &networkingv1.HTTPIngressRuleValue{\n\t\t\t\t\t\tPaths: []networkingv1.HTTPIngressPath{{\n\t\t\t\t\t\t\tPath: \"/\",\n\t\t\t\t\t\t\tBackend: networkingv1.IngressBackend{\n\t\t\t\t\t\t\t\tService: &networkingv1.IngressServiceBackend{\n\t\t\t\t\t\t\t\t\tName: \"guestbook-ui\",\n\t\t\t\t\t\t\t\t\tPort: networkingv1.ServiceBackendPort{Number: 80},\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tPathType: &pathType,\n\t\t\t\t\t\t}},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t}},\n\t\t},\n\t}\n\tdefer func() {\n\t\tlog.Infof(\"Ingress 'sample-ingress' deleted from %s\", ArgoCDNamespace)\n\t\tCheckError(KubeClientset.NetworkingV1().Ingresses(ArgoCDNamespace).Delete(context.Background(), \"sample-ingress\", metav1.DeleteOptions{}))\n\t}()\n\n\tsvc := &v1.Service{\n\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\tName: \"guestbook-ui\",\n\t\t\tLabels: map[string]string{\n\t\t\t\tcommon.LabelKeyAppInstance: ctx.GetName(),\n\t\t\t},\n\t\t},\n\t\tSpec: v1.ServiceSpec{\n\t\t\tPorts: []v1.ServicePort{{\n\t\t\t\tPort:       80,\n\t\t\t\tTargetPort: intstr.IntOrString{Type: intstr.Int, IntVal: 80},\n\t\t\t}},\n\t\t\tSelector: map[string]string{\n\t\t\t\t\"app\": \"guestbook-ui\",\n\t\t\t},\n\t\t},\n\t}\n\n\tctx.ProjectSpec(AppProjectSpec{\n\t\tSourceRepos:  []string{\"*\"},\n\t\tDestinations: []ApplicationDestination{{Namespace: DeploymentNamespace(), Server: \"*\"}},\n\t\tNamespaceResourceBlacklist: []metav1.GroupKind{\n\t\t\t{Group: \"\", Kind: \"Service\"},\n\t\t}}).\n\t\tAnd(func() {\n\t\t\tFailOnErr(KubeClientset.NetworkingV1().Ingresses(ArgoCDNamespace).Create(context.Background(), ingress, metav1.CreateOptions{}))\n\t\t\tFailOnErr(KubeClientset.CoreV1().Services(DeploymentNamespace()).Create(context.Background(), svc, metav1.CreateOptions{}))\n\t\t}).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tAnd(func(app *Application) {\n\t\t\tstatusByKind := make(map[string]ResourceStatus)\n\t\t\tfor _, res := range app.Status.Resources {\n\t\t\t\tstatusByKind[res.Kind] = res\n\t\t\t}\n\t\t\t_, hasIngress := statusByKind[kube.IngressKind]\n\t\t\tassert.False(t, hasIngress, \"Ingress is prohibited not managed object and should be even visible to user\")\n\t\t\tserviceStatus := statusByKind[kube.ServiceKind]\n\t\t\tassert.Equal(t, serviceStatus.Status, SyncStatusCodeUnknown, \"Service is prohibited managed resource so should be set to Unknown\")\n\t\t\tdeploymentStatus := statusByKind[kube.DeploymentKind]\n\t\t\tassert.Equal(t, deploymentStatus.Status, SyncStatusCodeOutOfSync)\n\t\t}).\n\t\tWhen().\n\t\tDelete(true).\n\t\tThen().\n\t\tExpect(DoesNotExist())\n\n\t// Make sure prohibited resources are not deleted during application deletion\n\tFailOnErr(KubeClientset.NetworkingV1().Ingresses(ArgoCDNamespace).Get(context.Background(), \"sample-ingress\", metav1.GetOptions{}))\n\tFailOnErr(KubeClientset.CoreV1().Services(DeploymentNamespace()).Get(context.Background(), \"guestbook-ui\", metav1.GetOptions{}))\n}\n\nfunc TestSyncWithInfos(t *testing.T) {\n\texpectedInfo := make([]*Info, 2)\n\texpectedInfo[0] = &Info{Name: \"name1\", Value: \"val1\"}\n\texpectedInfo[1] = &Info{Name: \"name2\", Value: \"val2\"}\n\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\t_, err := RunCli(\"app\", \"sync\", app.Name,\n\t\t\t\t\"--info\", fmt.Sprintf(\"%s=%s\", expectedInfo[0].Name, expectedInfo[0].Value),\n\t\t\t\t\"--info\", fmt.Sprintf(\"%s=%s\", expectedInfo[1].Name, expectedInfo[1].Value))\n\t\t\tassert.NoError(t, err)\n\t\t}).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.ElementsMatch(t, app.Status.OperationState.Operation.Info, expectedInfo)\n\t\t})\n}\n\n//Given: argocd app create does not provide --dest-namespace\n//       Manifest contains resource console which does not require namespace\n//Expect: no app.Status.Conditions\nfunc TestCreateAppWithNoNameSpaceForGlobalResource(t *testing.T) {\n\tGiven(t).\n\t\tPath(globalWithNoNameSpace).\n\t\tWhen().\n\t\tCreateWithNoNameSpace().\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\ttime.Sleep(500 * time.Millisecond)\n\t\t\tapp, err := AppClientset.ArgoprojV1alpha1().Applications(ArgoCDNamespace).Get(context.Background(), app.Name, metav1.GetOptions{})\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Len(t, app.Status.Conditions, 0)\n\t\t})\n}\n\n//Given: argocd app create does not provide --dest-namespace\n//       Manifest contains resource deployment, and service which requires namespace\n//       Deployment and service do not have namespace in manifest\n//Expect: app.Status.Conditions for deployment ans service which does not have namespace in manifest\nfunc TestCreateAppWithNoNameSpaceWhenRequired(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateWithNoNameSpace().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\tupdatedApp, err := AppClientset.ArgoprojV1alpha1().Applications(ArgoCDNamespace).Get(context.Background(), app.Name, metav1.GetOptions{})\n\t\t\trequire.NoError(t, err)\n\n\t\t\tassert.Len(t, updatedApp.Status.Conditions, 2)\n\t\t\tassert.Equal(t, updatedApp.Status.Conditions[0].Type, ApplicationConditionInvalidSpecError)\n\t\t\tassert.Equal(t, updatedApp.Status.Conditions[1].Type, ApplicationConditionInvalidSpecError)\n\t\t})\n}\n\n//Given: argocd app create does not provide --dest-namespace\n//       Manifest contains resource deployment, and service which requires namespace\n//       Some deployment and service has namespace in manifest\n//       Some deployment and service does not have namespace in manifest\n//Expect: app.Status.Conditions for deployment and service which does not have namespace in manifest\nfunc TestCreateAppWithNoNameSpaceWhenRequired2(t *testing.T) {\n\tGiven(t).\n\t\tPath(guestbookWithNamespace).\n\t\tWhen().\n\t\tCreateWithNoNameSpace().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\tupdatedApp, err := AppClientset.ArgoprojV1alpha1().Applications(ArgoCDNamespace).Get(context.Background(), app.Name, metav1.GetOptions{})\n\t\t\trequire.NoError(t, err)\n\n\t\t\tassert.Len(t, updatedApp.Status.Conditions, 2)\n\t\t\tassert.Equal(t, updatedApp.Status.Conditions[0].Type, ApplicationConditionInvalidSpecError)\n\t\t\tassert.Equal(t, updatedApp.Status.Conditions[1].Type, ApplicationConditionInvalidSpecError)\n\t\t})\n}\n\nfunc TestListResource(t *testing.T) {\n\tSkipOnEnv(t, \"OPENSHIFT\")\n\tGiven(t).\n\t\tProjectSpec(AppProjectSpec{\n\t\t\tSourceRepos:       []string{\"*\"},\n\t\t\tDestinations:      []ApplicationDestination{{Namespace: \"*\", Server: \"*\"}},\n\t\t\tOrphanedResources: &OrphanedResourcesMonitorSettings{Warn: pointer.BoolPtr(true)},\n\t\t}).\n\t\tPath(guestbookPath).\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tExpect(NoConditions()).\n\t\tWhen().\n\t\tAnd(func() {\n\t\t\tFailOnErr(KubeClientset.CoreV1().ConfigMaps(DeploymentNamespace()).Create(context.Background(), &v1.ConfigMap{\n\t\t\t\tObjectMeta: metav1.ObjectMeta{\n\t\t\t\t\tName: \"orphaned-configmap\",\n\t\t\t\t},\n\t\t\t}, metav1.CreateOptions{}))\n\t\t}).\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(Condition(ApplicationConditionOrphanedResourceWarning, \"Application has 1 orphaned resources\")).\n\t\tAnd(func(app *Application) {\n\t\t\toutput, err := RunCli(\"app\", \"resources\", app.Name)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, output, \"orphaned-configmap\")\n\t\t\tassert.Contains(t, output, \"guestbook-ui\")\n\t\t}).\n\t\tAnd(func(app *Application) {\n\t\t\toutput, err := RunCli(\"app\", \"resources\", app.Name, \"--orphaned=true\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, output, \"orphaned-configmap\")\n\t\t\tassert.NotContains(t, output, \"guestbook-ui\")\n\t\t}).\n\t\tAnd(func(app *Application) {\n\t\t\toutput, err := RunCli(\"app\", \"resources\", app.Name, \"--orphaned=false\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.NotContains(t, output, \"orphaned-configmap\")\n\t\t\tassert.Contains(t, output, \"guestbook-ui\")\n\t\t}).\n\t\tGiven().\n\t\tProjectSpec(AppProjectSpec{\n\t\t\tSourceRepos:       []string{\"*\"},\n\t\t\tDestinations:      []ApplicationDestination{{Namespace: \"*\", Server: \"*\"}},\n\t\t\tOrphanedResources: nil,\n\t\t}).\n\t\tWhen().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tExpect(NoConditions())\n}\n\n// Given application is set with --sync-option CreateNamespace=true\n//       application --dest-namespace does not exist\n// Verity application --dest-namespace is created\n//        application sync successful\n//        when application is deleted, --dest-namespace is not deleted\nfunc TestNamespaceAutoCreation(t *testing.T) {\n\tSkipOnEnv(t, \"OPENSHIFT\")\n\tupdatedNamespace := getNewNamespace(t)\n\tdefer func() {\n\t\tif !t.Skipped() {\n\t\t\t_, err := Run(\"\", \"kubectl\", \"delete\", \"namespace\", updatedNamespace)\n\t\t\tassert.NoError(t, err)\n\t\t}\n\t}()\n\tGiven(t).\n\t\tTimeout(30).\n\t\tPath(\"guestbook\").\n\t\tWhen().\n\t\tCreateApp(\"--sync-option\", \"CreateNamespace=true\").\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\t//Make sure the namespace we are about to update to does not exist\n\t\t\t_, err := Run(\"\", \"kubectl\", \"get\", \"namespace\", updatedNamespace)\n\t\t\tassert.Error(t, err)\n\t\t\tassert.Contains(t, err.Error(), \"not found\")\n\t\t}).\n\t\tWhen().\n\t\tAppSet(\"--dest-namespace\", updatedNamespace).\n\t\tSync().\n\t\tThen().\n\t\tExpect(Success(\"\")).\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).Expect(ResourceHealthWithNamespaceIs(\"Deployment\", \"guestbook-ui\", updatedNamespace, health.HealthStatusHealthy)).\n\t\tExpect(ResourceHealthWithNamespaceIs(\"Deployment\", \"guestbook-ui\", updatedNamespace, health.HealthStatusHealthy)).\n\t\tExpect(ResourceSyncStatusWithNamespaceIs(\"Deployment\", \"guestbook-ui\", updatedNamespace, SyncStatusCodeSynced)).\n\t\tExpect(ResourceSyncStatusWithNamespaceIs(\"Deployment\", \"guestbook-ui\", updatedNamespace, SyncStatusCodeSynced)).\n\t\tWhen().\n\t\tDelete(true).\n\t\tThen().\n\t\tExpect(Success(\"\")).\n\t\tAnd(func(app *Application) {\n\t\t\t//Verify delete app does not delete the namespace auto created\n\t\t\toutput, err := Run(\"\", \"kubectl\", \"get\", \"namespace\", updatedNamespace)\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, output, updatedNamespace)\n\t\t})\n}\n\nfunc TestFailedSyncWithRetry(t *testing.T) {\n\tGiven(t).\n\t\tPath(\"hook\").\n\t\tWhen().\n\t\tPatchFile(\"hook.yaml\", `[{\"op\": \"replace\", \"path\": \"/metadata/annotations\", \"value\": {\"argocd.argoproj.io/hook\": \"PreSync\"}}]`).\n\t\t// make hook fail\n\t\tPatchFile(\"hook.yaml\", `[{\"op\": \"replace\", \"path\": \"/spec/containers/0/command\", \"value\": [\"false\"]}]`).\n\t\tCreateApp().\n\t\tIgnoreErrors().\n\t\tSync(\"--retry-limit=1\", \"--retry-backoff-duration=1s\").\n\t\tThen().\n\t\tExpect(OperationPhaseIs(OperationFailed)).\n\t\tExpect(OperationMessageContains(\"retried 1 times\"))\n}\n\nfunc TestCreateDisableValidation(t *testing.T) {\n\tGiven(t).\n\t\tPath(\"baddir\").\n\t\tWhen().\n\t\tCreateApp(\"--validate=false\").\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\t_, err := RunCli(\"app\", \"create\", app.Name, \"--upsert\", \"--validate=false\", \"--repo\", RepoURL(RepoURLTypeFile),\n\t\t\t\t\"--path\", \"baddir2\", \"--project\", app.Spec.Project, \"--dest-server\", KubernetesInternalAPIServerAddr, \"--dest-namespace\", DeploymentNamespace())\n\t\t\tassert.NoError(t, err)\n\t\t}).\n\t\tWhen().\n\t\tAppSet(\"--path\", \"baddir3\", \"--validate=false\")\n\n}\n\nfunc TestCreateFromPartialFile(t *testing.T) {\n\tpartialApp :=\n\t\t`metadata:\n  labels:\n    labels.local/from-file: file\n    labels.local/from-args: file\n  annotations:\n    annotations.local/from-file: file\n  finalizers:\n  - resources-finalizer.argocd.argoproj.io\nspec:\n  syncPolicy:\n    automated:\n      prune: true\n`\n\n\tpath := \"helm-values\"\n\tGiven(t).\n\t\tWhen().\n\t\t// app should be auto-synced once created\n\t\tCreateFromPartialFile(partialApp, \"--path\", path, \"-l\", \"labels.local/from-args=args\", \"--helm-set\", \"foo=foo\").\n\t\tThen().\n\t\tExpect(Success(\"\")).\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tExpect(NoConditions()).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Equal(t, map[string]string{\"labels.local/from-file\": \"file\", \"labels.local/from-args\": \"args\"}, app.ObjectMeta.Labels)\n\t\t\tassert.Equal(t, map[string]string{\"annotations.local/from-file\": \"file\"}, app.ObjectMeta.Annotations)\n\t\t\tassert.Equal(t, []string{\"resources-finalizer.argocd.argoproj.io\"}, app.ObjectMeta.Finalizers)\n\t\t\tassert.Equal(t, path, app.Spec.Source.Path)\n\t\t\tassert.Equal(t, []HelmParameter{{Name: \"foo\", Value: \"foo\"}}, app.Spec.Source.Helm.Parameters)\n\t\t})\n}\n\n// Ensure actions work when using a resource action that modifies status and/or spec\nfunc TestCRDStatusSubresourceAction(t *testing.T) {\n\tactions := `\ndiscovery.lua: |\n  actions = {}\n  actions[\"update-spec\"] = {[\"disabled\"] = false}\n  actions[\"update-status\"] = {[\"disabled\"] = false}\n  actions[\"update-both\"] = {[\"disabled\"] = false}\n  return actions\ndefinitions:\n- name: update-both\n  action.lua: |\n    obj.spec = {}\n    obj.spec.foo = \"update-both\"\n    obj.status = {}\n    obj.status.bar = \"update-both\"\n    return obj\n- name: update-spec\n  action.lua: |\n    obj.spec = {}\n    obj.spec.foo = \"update-spec\"\n    return obj\n- name: update-status\n  action.lua: |\n    obj.status = {}\n    obj.status.bar = \"update-status\"\n    return obj\n`\n\tGiven(t).\n\t\tPath(\"crd-subresource\").\n\t\tAnd(func() {\n\t\t\tSetResourceOverrides(map[string]ResourceOverride{\n\t\t\t\t\"argoproj.io/StatusSubResource\": {\n\t\t\t\t\tActions: actions,\n\t\t\t\t},\n\t\t\t\t\"argoproj.io/NonStatusSubResource\": {\n\t\t\t\t\tActions: actions,\n\t\t\t\t},\n\t\t\t})\n\t\t}).\n\t\tWhen().CreateApp().Sync().Then().\n\t\tExpect(OperationPhaseIs(OperationSucceeded)).Expect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tWhen().\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\t// tests resource actions on a CRD using status subresource\n\t\tAnd(func(app *Application) {\n\t\t\t_, err := RunCli(\"app\", \"actions\", \"run\", app.Name, \"--kind\", \"StatusSubResource\", \"update-both\")\n\t\t\tassert.NoError(t, err)\n\t\t\ttext := FailOnErr(Run(\".\", \"kubectl\", \"-n\", app.Spec.Destination.Namespace, \"get\", \"statussubresources\", \"status-subresource\", \"-o\", \"jsonpath={.spec.foo}\")).(string)\n\t\t\tassert.Equal(t, \"update-both\", text)\n\t\t\ttext = FailOnErr(Run(\".\", \"kubectl\", \"-n\", app.Spec.Destination.Namespace, \"get\", \"statussubresources\", \"status-subresource\", \"-o\", \"jsonpath={.status.bar}\")).(string)\n\t\t\tassert.Equal(t, \"update-both\", text)\n\n\t\t\t_, err = RunCli(\"app\", \"actions\", \"run\", app.Name, \"--kind\", \"StatusSubResource\", \"update-spec\")\n\t\t\tassert.NoError(t, err)\n\t\t\ttext = FailOnErr(Run(\".\", \"kubectl\", \"-n\", app.Spec.Destination.Namespace, \"get\", \"statussubresources\", \"status-subresource\", \"-o\", \"jsonpath={.spec.foo}\")).(string)\n\t\t\tassert.Equal(t, \"update-spec\", text)\n\n\t\t\t_, err = RunCli(\"app\", \"actions\", \"run\", app.Name, \"--kind\", \"StatusSubResource\", \"update-status\")\n\t\t\tassert.NoError(t, err)\n\t\t\ttext = FailOnErr(Run(\".\", \"kubectl\", \"-n\", app.Spec.Destination.Namespace, \"get\", \"statussubresources\", \"status-subresource\", \"-o\", \"jsonpath={.status.bar}\")).(string)\n\t\t\tassert.Equal(t, \"update-status\", text)\n\t\t}).\n\t\t// tests resource actions on a CRD *not* using status subresource\n\t\tAnd(func(app *Application) {\n\t\t\t_, err := RunCli(\"app\", \"actions\", \"run\", app.Name, \"--kind\", \"NonStatusSubResource\", \"update-both\")\n\t\t\tassert.NoError(t, err)\n\t\t\ttext := FailOnErr(Run(\".\", \"kubectl\", \"-n\", app.Spec.Destination.Namespace, \"get\", \"nonstatussubresources\", \"non-status-subresource\", \"-o\", \"jsonpath={.spec.foo}\")).(string)\n\t\t\tassert.Equal(t, \"update-both\", text)\n\t\t\ttext = FailOnErr(Run(\".\", \"kubectl\", \"-n\", app.Spec.Destination.Namespace, \"get\", \"nonstatussubresources\", \"non-status-subresource\", \"-o\", \"jsonpath={.status.bar}\")).(string)\n\t\t\tassert.Equal(t, \"update-both\", text)\n\n\t\t\t_, err = RunCli(\"app\", \"actions\", \"run\", app.Name, \"--kind\", \"NonStatusSubResource\", \"update-spec\")\n\t\t\tassert.NoError(t, err)\n\t\t\ttext = FailOnErr(Run(\".\", \"kubectl\", \"-n\", app.Spec.Destination.Namespace, \"get\", \"nonstatussubresources\", \"non-status-subresource\", \"-o\", \"jsonpath={.spec.foo}\")).(string)\n\t\t\tassert.Equal(t, \"update-spec\", text)\n\n\t\t\t_, err = RunCli(\"app\", \"actions\", \"run\", app.Name, \"--kind\", \"NonStatusSubResource\", \"update-status\")\n\t\t\tassert.NoError(t, err)\n\t\t\ttext = FailOnErr(Run(\".\", \"kubectl\", \"-n\", app.Spec.Destination.Namespace, \"get\", \"nonstatussubresources\", \"non-status-subresource\", \"-o\", \"jsonpath={.status.bar}\")).(string)\n\t\t\tassert.Equal(t, \"update-status\", text)\n\t\t})\n}\n\nfunc TestAppLogs(t *testing.T) {\n\tSkipOnEnv(t, \"OPENSHIFT\")\n\tGiven(t).\n\t\tPath(\"guestbook-logs\").\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(HealthIs(health.HealthStatusHealthy)).\n\t\tAnd(func(app *Application) {\n\t\t\tout, err := RunCli(\"app\", \"logs\", app.Name, \"--kind\", \"Deployment\", \"--group\", \"\", \"--name\", \"guestbook-ui\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, out, \"Hi\")\n\t\t}).\n\t\tAnd(func(app *Application) {\n\t\t\tout, err := RunCli(\"app\", \"logs\", app.Name, \"--kind\", \"Pod\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.Contains(t, out, \"Hi\")\n\t\t}).\n\t\tAnd(func(app *Application) {\n\t\t\tout, err := RunCli(\"app\", \"logs\", app.Name, \"--kind\", \"Service\")\n\t\t\tassert.NoError(t, err)\n\t\t\tassert.NotContains(t, out, \"Hi\")\n\t\t})\n}\n\nfunc TestAppWaitOperationInProgress(t *testing.T) {\n\tGiven(t).\n\t\tAnd(func() {\n\t\t\tSetResourceOverrides(map[string]ResourceOverride{\n\t\t\t\t\"batch/Job\": {\n\t\t\t\t\tHealthLua: `return { status = 'Running' }`,\n\t\t\t\t},\n\t\t\t\t\"apps/Deployment\": {\n\t\t\t\t\tHealthLua: `return { status = 'Suspended' }`,\n\t\t\t\t},\n\t\t\t})\n\t\t}).\n\t\tAsync(true).\n\t\tPath(\"hook-and-deployment\").\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\t// stuck in running state\n\t\tExpect(OperationPhaseIs(OperationRunning)).\n\t\tWhen().\n\t\tAnd(func() {\n\t\t\t_, err := RunCli(\"app\", \"wait\", Name(), \"--suspended\")\n\t\t\terrors.CheckError(err)\n\t\t})\n}\n\nfunc TestSyncOptionReplace(t *testing.T) {\n\tGiven(t).\n\t\tPath(\"config-map\").\n\t\tWhen().\n\t\tPatchFile(\"config-map.yaml\", `[{\"op\": \"add\", \"path\": \"/metadata/annotations\", \"value\": {\"argocd.argoproj.io/sync-options\": \"Replace=true\"}}]`).\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Equal(t, app.Status.OperationState.SyncResult.Resources[0].Message, \"configmap/my-map created\")\n\t\t}).\n\t\tWhen().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Equal(t, app.Status.OperationState.SyncResult.Resources[0].Message, \"configmap/my-map replaced\")\n\t\t})\n}\n\nfunc TestSyncOptionReplaceFromCLI(t *testing.T) {\n\tGiven(t).\n\t\tPath(\"config-map\").\n\t\tReplace().\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Equal(t, app.Status.OperationState.SyncResult.Resources[0].Message, \"configmap/my-map created\")\n\t\t}).\n\t\tWhen().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Equal(t, app.Status.OperationState.SyncResult.Resources[0].Message, \"configmap/my-map replaced\")\n\t\t})\n}\n\nfunc TestDiscoverNewCommit(t *testing.T) {\n\tvar sha string\n\tGiven(t).\n\t\tPath(\"config-map\").\n\t\tWhen().\n\t\tCreateApp().\n\t\tSync().\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\tAnd(func(app *Application) {\n\t\t\tsha = app.Status.Sync.Revision\n\t\t\tassert.NotEmpty(t, sha)\n\t\t}).\n\t\tWhen().\n\t\tPatchFile(\"config-map.yaml\", `[{\"op\": \"replace\", \"path\": \"/data/foo\", \"value\": \"hello\"}]`).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeSynced)).\n\t\t// make sure new commit is not discovered immediately after push\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Equal(t, sha, app.Status.Sync.Revision)\n\t\t}).\n\t\tWhen().\n\t\t// make sure new commit is not discovered after refresh is requested\n\t\tRefresh(RefreshTypeNormal).\n\t\tThen().\n\t\tExpect(SyncStatusIs(SyncStatusCodeOutOfSync)).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.NotEqual(t, sha, app.Status.Sync.Revision)\n\t\t})\n}\n\nfunc TestDisableManifestGeneration(t *testing.T) {\n\tGiven(t).\n\t\tPath(\"guestbook\").\n\t\tWhen().\n\t\tCreateApp().\n\t\tRefresh(RefreshTypeHard).\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Equal(t, app.Status.SourceType, ApplicationSourceTypeKustomize)\n\t\t}).\n\t\tWhen().\n\t\tAnd(func() {\n\t\t\tSetEnableManifestGeneration(map[ApplicationSourceType]bool{\n\t\t\t\tApplicationSourceTypeKustomize: false,\n\t\t\t})\n\t\t}).\n\t\tRefresh(RefreshTypeHard).\n\t\tThen().\n\t\tAnd(func(app *Application) {\n\t\t\ttime.Sleep(1 * time.Second)\n\t\t}).\n\t\tAnd(func(app *Application) {\n\t\t\tassert.Equal(t, app.Status.SourceType, ApplicationSourceTypeDirectory)\n\t\t})\n}\n", "package project\n\nimport (\n\t\"context\"\n\n\t\"github.com/argoproj/argo-cd/v2/pkg/apis/application/v1alpha1\"\n\t\"github.com/argoproj/argo-cd/v2/test/e2e/fixture\"\n\t\"github.com/stretchr/testify/require\"\n\tv1 \"k8s.io/apimachinery/pkg/apis/meta/v1\"\n)\n\n// this implements the \"when\" part of given/when/then\n//\n// none of the func implement error checks, and that is complete intended, you should check for errors\n// using the Then()\ntype Actions struct {\n\tcontext      *Context\n\tlastOutput   string\n\tlastError    error\n\tignoreErrors bool\n}\n\nfunc (a *Actions) IgnoreErrors() *Actions {\n\ta.ignoreErrors = true\n\treturn a\n}\n\nfunc (a *Actions) DoNotIgnoreErrors() *Actions {\n\ta.ignoreErrors = false\n\treturn a\n}\n\nfunc (a *Actions) Create(args ...string) *Actions {\n\targs = a.prepareCreateArgs(args)\n\n\t//  are you adding new context values? if you only use them for this func, then use args instead\n\ta.runCli(args...)\n\n\treturn a\n}\n\nfunc (a *Actions) AddDestination(cluster string, namespace string) *Actions {\n\ta.runCli(\"proj\", \"add-destination\", a.context.name, cluster, namespace)\n\treturn a\n}\n\nfunc (a *Actions) AddSource(repo string) *Actions {\n\ta.runCli(\"proj\", \"add-source\", a.context.name, repo)\n\treturn a\n}\n\nfunc (a *Actions) UpdateProject(updater func(project *v1alpha1.AppProject)) *Actions {\n\tproj, err := fixture.AppClientset.ArgoprojV1alpha1().AppProjects(fixture.ArgoCDNamespace).Get(context.TODO(), a.context.name, v1.GetOptions{})\n\trequire.NoError(a.context.t, err)\n\tupdater(proj)\n\t_, err = fixture.AppClientset.ArgoprojV1alpha1().AppProjects(fixture.ArgoCDNamespace).Update(context.TODO(), proj, v1.UpdateOptions{})\n\trequire.NoError(a.context.t, err)\n\treturn a\n}\n\nfunc (a *Actions) Name(name string) *Actions {\n\ta.context.name = name\n\treturn a\n}\n\nfunc (a *Actions) prepareCreateArgs(args []string) []string {\n\ta.context.t.Helper()\n\targs = append([]string{\n\t\t\"proj\", \"create\", a.context.name,\n\t}, args...)\n\n\tif a.context.destination != \"\" {\n\t\targs = append(args, \"--dest\", a.context.destination)\n\t}\n\n\treturn args\n}\n\nfunc (a *Actions) Delete() *Actions {\n\ta.context.t.Helper()\n\ta.runCli(\"proj\", \"delete\", a.context.name)\n\treturn a\n}\n\nfunc (a *Actions) And(block func()) *Actions {\n\ta.context.t.Helper()\n\tblock()\n\treturn a\n}\n\nfunc (a *Actions) Then() *Consequences {\n\ta.context.t.Helper()\n\treturn &Consequences{a.context, a}\n}\n\nfunc (a *Actions) runCli(args ...string) {\n\ta.context.t.Helper()\n\ta.lastOutput, a.lastError = fixture.RunCli(args...)\n\tif !a.ignoreErrors {\n\t\trequire.Empty(a.context.t, a.lastError)\n\t}\n}\n"], "filenames": ["controller/appcontroller.go", "controller/appcontroller_test.go", "controller/cache/cache.go", "controller/cache/mocks/LiveStateCache.go", "go.mod", "go.sum", "pkg/apis/application/v1alpha1/app_project_types.go", "server/application/application.go", "test/e2e/app_management_test.go", "test/e2e/fixture/project/actions.go"], "buggy_code_start_loc": [30, 139, 111, 179, 11, 133, 316, 490, 1049, 3], "buggy_code_end_loc": [1293, 145, 491, 184, 12, 135, 321, 1680, 1107, 74], "fixing_code_start_loc": [31, 139, 111, 179, 11, 133, 316, 491, 1049, 4], "fixing_code_end_loc": [1308, 145, 491, 184, 12, 135, 325, 1695, 1168, 102], "type": "CWE-269", "message": "Argo CD is a declarative, GitOps continuous delivery tool for Kubernetes. All unpatched versions of Argo CD starting with 1.0.0 are vulnerable to an improper access control bug, allowing a malicious user to potentially escalate their privileges to admin-level. Versions starting with 0.8.0 and 0.5.0 contain limited versions of this issue. To perform exploits, an authorized Argo CD user must have push access to an Application's source git or Helm repository or `sync` and `override` access to an Application. Once a user has that access, different exploitation levels are possible depending on their other RBAC privileges. A patch for this vulnerability has been released in Argo CD versions 2.3.2, 2.2.8, and 2.1.14. Some mitigation measures are available but do not serve as a substitute for upgrading. To avoid privilege escalation, limit who has push access to Application source repositories or `sync` + `override` access to Applications; and limit which repositories are available in projects where users have `update` access to Applications. To avoid unauthorized resource inspection/tampering, limit who has `delete`, `get`, or `action` access to Applications.", "other": {"cve": {"id": "CVE-2022-24768", "sourceIdentifier": "security-advisories@github.com", "published": "2022-03-23T22:15:13.143", "lastModified": "2022-04-01T14:01:43.967", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Argo CD is a declarative, GitOps continuous delivery tool for Kubernetes. All unpatched versions of Argo CD starting with 1.0.0 are vulnerable to an improper access control bug, allowing a malicious user to potentially escalate their privileges to admin-level. Versions starting with 0.8.0 and 0.5.0 contain limited versions of this issue. To perform exploits, an authorized Argo CD user must have push access to an Application's source git or Helm repository or `sync` and `override` access to an Application. Once a user has that access, different exploitation levels are possible depending on their other RBAC privileges. A patch for this vulnerability has been released in Argo CD versions 2.3.2, 2.2.8, and 2.1.14. Some mitigation measures are available but do not serve as a substitute for upgrading. To avoid privilege escalation, limit who has push access to Application source repositories or `sync` + `override` access to Applications; and limit which repositories are available in projects where users have `update` access to Applications. To avoid unauthorized resource inspection/tampering, limit who has `delete`, `get`, or `action` access to Applications."}, {"lang": "es", "value": "Argo CD es una herramienta de entrega continua GitOps para Kubernetes. Todas las versiones no parcheadas de Argo CD a partir de la 1.0.0, son vulnerables a un bug de control de acceso inapropiado, que permite a un usuario malicioso escalar potencialmente sus privilegios a nivel de administrador. Las versiones a partir de 0.8.0 y 0.5.0, contienen versiones limitadas de este problema. Para llevar a cabo las explotaciones, un usuario autorizado de Argo CD debe presentar acceso push al repositorio git o Helm de una aplicaci\u00f3n o acceso \"sync\" y \"override\" a una aplicaci\u00f3n. Una vez que un usuario presenta ese acceso, son posibles diferentes niveles de explotaci\u00f3n dependiendo de sus otros privilegios RBAC. Ha sido publicado un parche para esta vulnerabilidad en versiones 2.3.2, 2.2.8 y 2.1.14 de Argo CD. Se presentan algunas medidas de mitigaci\u00f3n, pero no sirven para sustituir la actualizaci\u00f3n. Para evitar una escalada de privilegios, limite qui\u00e9n presente acceso push a los repositorios de origen de las aplicaciones o el acceso \"sync\" + \"override\" a las aplicaciones; y limite qu\u00e9 repositorios est\u00e1n disponibles en los proyectos donde los usuarios presenten acceso \"update\" a las aplicaciones. Para evitar la inspecci\u00f3n/manipulaci\u00f3n no autorizada de los recursos, limite qui\u00e9n presente acceso a \"delete\", \"getr\" o \"action\" en las aplicaciones"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.9, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.1, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-269"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:argo-cd:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.5.0", "versionEndExcluding": "2.1.14", "matchCriteriaId": "29EE98FA-63E2-438D-AA21-D0F98B49791C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:argo-cd:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.2.0", "versionEndExcluding": "2.2.8", "matchCriteriaId": "67165565-5A71-4A15-A742-E204FFD0730B"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxfoundation:argo-cd:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.2", "matchCriteriaId": "AB3538BE-AE35-48A4-A2F3-1943AF76C6AC"}]}]}], "references": [{"url": "https://github.com/argoproj/argo-cd/commit/af03b291d4b7e9d3ce9a6580ae9c8141af0e05cf", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/argoproj/argo-cd/releases/tag/v2.1.14", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/argoproj/argo-cd/releases/tag/v2.2.8", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/argoproj/argo-cd/releases/tag/v2.3.2", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/argoproj/argo-cd/security/advisories/GHSA-2f5v-8r3f-8pww", "source": "security-advisories@github.com", "tags": ["Mitigation", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/argoproj/argo-cd/commit/af03b291d4b7e9d3ce9a6580ae9c8141af0e05cf"}}