{"buggy_code": ["/*\n * NET\t\tAn implementation of the SOCKET network access protocol.\n *\n * Version:\t@(#)socket.c\t1.1.93\t18/02/95\n *\n * Authors:\tOrest Zborowski, <obz@Kodak.COM>\n *\t\tRoss Biro\n *\t\tFred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>\n *\n * Fixes:\n *\t\tAnonymous\t:\tNOTSOCK/BADF cleanup. Error fix in\n *\t\t\t\t\tshutdown()\n *\t\tAlan Cox\t:\tverify_area() fixes\n *\t\tAlan Cox\t:\tRemoved DDI\n *\t\tJonathan Kamens\t:\tSOCK_DGRAM reconnect bug\n *\t\tAlan Cox\t:\tMoved a load of checks to the very\n *\t\t\t\t\ttop level.\n *\t\tAlan Cox\t:\tMove address structures to/from user\n *\t\t\t\t\tmode above the protocol layers.\n *\t\tRob Janssen\t:\tAllow 0 length sends.\n *\t\tAlan Cox\t:\tAsynchronous I/O support (cribbed from the\n *\t\t\t\t\ttty drivers).\n *\t\tNiibe Yutaka\t:\tAsynchronous I/O for writes (4.4BSD style)\n *\t\tJeff Uphoff\t:\tMade max number of sockets command-line\n *\t\t\t\t\tconfigurable.\n *\t\tMatti Aarnio\t:\tMade the number of sockets dynamic,\n *\t\t\t\t\tto be allocated when needed, and mr.\n *\t\t\t\t\tUphoff's max is used as max to be\n *\t\t\t\t\tallowed to allocate.\n *\t\tLinus\t\t:\tArgh. removed all the socket allocation\n *\t\t\t\t\taltogether: it's in the inode now.\n *\t\tAlan Cox\t:\tMade sock_alloc()/sock_release() public\n *\t\t\t\t\tfor NetROM and future kernel nfsd type\n *\t\t\t\t\tstuff.\n *\t\tAlan Cox\t:\tsendmsg/recvmsg basics.\n *\t\tTom Dyas\t:\tExport net symbols.\n *\t\tMarcin Dalecki\t:\tFixed problems with CONFIG_NET=\"n\".\n *\t\tAlan Cox\t:\tAdded thread locking to sys_* calls\n *\t\t\t\t\tfor sockets. May have errors at the\n *\t\t\t\t\tmoment.\n *\t\tKevin Buhr\t:\tFixed the dumb errors in the above.\n *\t\tAndi Kleen\t:\tSome small cleanups, optimizations,\n *\t\t\t\t\tand fixed a copy_from_user() bug.\n *\t\tTigran Aivazian\t:\tsys_send(args) calls sys_sendto(args, NULL, 0)\n *\t\tTigran Aivazian\t:\tMade listen(2) backlog sanity checks\n *\t\t\t\t\tprotocol-independent\n *\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n *\n *\tThis module is effectively the top level interface to the BSD socket\n *\tparadigm.\n *\n *\tBased upon Swansea University Computer Society NET3.039\n */\n\n#include <linux/mm.h>\n#include <linux/socket.h>\n#include <linux/file.h>\n#include <linux/net.h>\n#include <linux/interrupt.h>\n#include <linux/thread_info.h>\n#include <linux/rcupdate.h>\n#include <linux/netdevice.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/wanrouter.h>\n#include <linux/if_bridge.h>\n#include <linux/if_frad.h>\n#include <linux/if_vlan.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/cache.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/kmod.h>\n#include <linux/audit.h>\n#include <linux/wireless.h>\n#include <linux/nsproxy.h>\n#include <linux/magic.h>\n#include <linux/slab.h>\n\n#include <asm/uaccess.h>\n#include <asm/unistd.h>\n\n#include <net/compat.h>\n#include <net/wext.h>\n#include <net/cls_cgroup.h>\n\n#include <net/sock.h>\n#include <linux/netfilter.h>\n\n#include <linux/if_tun.h>\n#include <linux/ipv6_route.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <linux/atalk.h>\n\nstatic int sock_no_open(struct inode *irrelevant, struct file *dontcare);\nstatic ssize_t sock_aio_read(struct kiocb *iocb, const struct iovec *iov,\n\t\t\t unsigned long nr_segs, loff_t pos);\nstatic ssize_t sock_aio_write(struct kiocb *iocb, const struct iovec *iov,\n\t\t\t  unsigned long nr_segs, loff_t pos);\nstatic int sock_mmap(struct file *file, struct vm_area_struct *vma);\n\nstatic int sock_close(struct inode *inode, struct file *file);\nstatic unsigned int sock_poll(struct file *file,\n\t\t\t      struct poll_table_struct *wait);\nstatic long sock_ioctl(struct file *file, unsigned int cmd, unsigned long arg);\n#ifdef CONFIG_COMPAT\nstatic long compat_sock_ioctl(struct file *file,\n\t\t\t      unsigned int cmd, unsigned long arg);\n#endif\nstatic int sock_fasync(int fd, struct file *filp, int on);\nstatic ssize_t sock_sendpage(struct file *file, struct page *page,\n\t\t\t     int offset, size_t size, loff_t *ppos, int more);\nstatic ssize_t sock_splice_read(struct file *file, loff_t *ppos,\n\t\t\t\tstruct pipe_inode_info *pipe, size_t len,\n\t\t\t\tunsigned int flags);\n\n/*\n *\tSocket files have a set of 'special' operations as well as the generic file ones. These don't appear\n *\tin the operation structures but are done directly via the socketcall() multiplexor.\n */\n\nstatic const struct file_operations socket_file_ops = {\n\t.owner =\tTHIS_MODULE,\n\t.llseek =\tno_llseek,\n\t.aio_read =\tsock_aio_read,\n\t.aio_write =\tsock_aio_write,\n\t.poll =\t\tsock_poll,\n\t.unlocked_ioctl = sock_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = compat_sock_ioctl,\n#endif\n\t.mmap =\t\tsock_mmap,\n\t.open =\t\tsock_no_open,\t/* special open code to disallow open via /proc */\n\t.release =\tsock_close,\n\t.fasync =\tsock_fasync,\n\t.sendpage =\tsock_sendpage,\n\t.splice_write = generic_splice_sendpage,\n\t.splice_read =\tsock_splice_read,\n};\n\n/*\n *\tThe protocol list. Each protocol is registered in here.\n */\n\nstatic DEFINE_SPINLOCK(net_family_lock);\nstatic const struct net_proto_family __rcu *net_families[NPROTO] __read_mostly;\n\n/*\n *\tStatistics counters of the socket lists\n */\n\nstatic DEFINE_PER_CPU(int, sockets_in_use);\n\n/*\n * Support routines.\n * Move socket addresses back and forth across the kernel/user\n * divide and look after the messy bits.\n */\n\n/**\n *\tmove_addr_to_kernel\t-\tcopy a socket address into kernel space\n *\t@uaddr: Address in user space\n *\t@kaddr: Address in kernel space\n *\t@ulen: Length in user space\n *\n *\tThe address is copied into kernel space. If the provided address is\n *\ttoo long an error code of -EINVAL is returned. If the copy gives\n *\tinvalid addresses -EFAULT is returned. On a success 0 is returned.\n */\n\nint move_addr_to_kernel(void __user *uaddr, int ulen, struct sockaddr *kaddr)\n{\n\tif (ulen < 0 || ulen > sizeof(struct sockaddr_storage))\n\t\treturn -EINVAL;\n\tif (ulen == 0)\n\t\treturn 0;\n\tif (copy_from_user(kaddr, uaddr, ulen))\n\t\treturn -EFAULT;\n\treturn audit_sockaddr(ulen, kaddr);\n}\n\n/**\n *\tmove_addr_to_user\t-\tcopy an address to user space\n *\t@kaddr: kernel space address\n *\t@klen: length of address in kernel\n *\t@uaddr: user space address\n *\t@ulen: pointer to user length field\n *\n *\tThe value pointed to by ulen on entry is the buffer length available.\n *\tThis is overwritten with the buffer space used. -EINVAL is returned\n *\tif an overlong buffer is specified or a negative buffer size. -EFAULT\n *\tis returned if either the buffer or the length field are not\n *\taccessible.\n *\tAfter copying the data up to the limit the user specifies, the true\n *\tlength of the data is written over the length limit the user\n *\tspecified. Zero is returned for a success.\n */\n\nstatic int move_addr_to_user(struct sockaddr *kaddr, int klen,\n\t\t\t     void __user *uaddr, int __user *ulen)\n{\n\tint err;\n\tint len;\n\n\terr = get_user(len, ulen);\n\tif (err)\n\t\treturn err;\n\tif (len > klen)\n\t\tlen = klen;\n\tif (len < 0 || len > sizeof(struct sockaddr_storage))\n\t\treturn -EINVAL;\n\tif (len) {\n\t\tif (audit_sockaddr(klen, kaddr))\n\t\t\treturn -ENOMEM;\n\t\tif (copy_to_user(uaddr, kaddr, len))\n\t\t\treturn -EFAULT;\n\t}\n\t/*\n\t *      \"fromlen shall refer to the value before truncation..\"\n\t *                      1003.1g\n\t */\n\treturn __put_user(klen, ulen);\n}\n\nstatic struct kmem_cache *sock_inode_cachep __read_mostly;\n\nstatic struct inode *sock_alloc_inode(struct super_block *sb)\n{\n\tstruct socket_alloc *ei;\n\tstruct socket_wq *wq;\n\n\tei = kmem_cache_alloc(sock_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\twq = kmalloc(sizeof(*wq), GFP_KERNEL);\n\tif (!wq) {\n\t\tkmem_cache_free(sock_inode_cachep, ei);\n\t\treturn NULL;\n\t}\n\tinit_waitqueue_head(&wq->wait);\n\twq->fasync_list = NULL;\n\tRCU_INIT_POINTER(ei->socket.wq, wq);\n\n\tei->socket.state = SS_UNCONNECTED;\n\tei->socket.flags = 0;\n\tei->socket.ops = NULL;\n\tei->socket.sk = NULL;\n\tei->socket.file = NULL;\n\n\treturn &ei->vfs_inode;\n}\n\nstatic void sock_destroy_inode(struct inode *inode)\n{\n\tstruct socket_alloc *ei;\n\tstruct socket_wq *wq;\n\n\tei = container_of(inode, struct socket_alloc, vfs_inode);\n\twq = rcu_dereference_protected(ei->socket.wq, 1);\n\tkfree_rcu(wq, rcu);\n\tkmem_cache_free(sock_inode_cachep, ei);\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct socket_alloc *ei = (struct socket_alloc *)foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic int init_inodecache(void)\n{\n\tsock_inode_cachep = kmem_cache_create(\"sock_inode_cache\",\n\t\t\t\t\t      sizeof(struct socket_alloc),\n\t\t\t\t\t      0,\n\t\t\t\t\t      (SLAB_HWCACHE_ALIGN |\n\t\t\t\t\t       SLAB_RECLAIM_ACCOUNT |\n\t\t\t\t\t       SLAB_MEM_SPREAD),\n\t\t\t\t\t      init_once);\n\tif (sock_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic const struct super_operations sockfs_ops = {\n\t.alloc_inode\t= sock_alloc_inode,\n\t.destroy_inode\t= sock_destroy_inode,\n\t.statfs\t\t= simple_statfs,\n};\n\n/*\n * sockfs_dname() is called from d_path().\n */\nstatic char *sockfs_dname(struct dentry *dentry, char *buffer, int buflen)\n{\n\treturn dynamic_dname(dentry, buffer, buflen, \"socket:[%lu]\",\n\t\t\t\tdentry->d_inode->i_ino);\n}\n\nstatic const struct dentry_operations sockfs_dentry_operations = {\n\t.d_dname  = sockfs_dname,\n};\n\nstatic struct dentry *sockfs_mount(struct file_system_type *fs_type,\n\t\t\t int flags, const char *dev_name, void *data)\n{\n\treturn mount_pseudo(fs_type, \"socket:\", &sockfs_ops,\n\t\t&sockfs_dentry_operations, SOCKFS_MAGIC);\n}\n\nstatic struct vfsmount *sock_mnt __read_mostly;\n\nstatic struct file_system_type sock_fs_type = {\n\t.name =\t\t\"sockfs\",\n\t.mount =\tsockfs_mount,\n\t.kill_sb =\tkill_anon_super,\n};\n\n/*\n *\tObtains the first available file descriptor and sets it up for use.\n *\n *\tThese functions create file structures and maps them to fd space\n *\tof the current process. On success it returns file descriptor\n *\tand file struct implicitly stored in sock->file.\n *\tNote that another thread may close file descriptor before we return\n *\tfrom this function. We use the fact that now we do not refer\n *\tto socket after mapping. If one day we will need it, this\n *\tfunction will increment ref. count on file by 1.\n *\n *\tIn any case returned fd MAY BE not valid!\n *\tThis race condition is unavoidable\n *\twith shared fd spaces, we cannot solve it inside kernel,\n *\tbut we take care of internal coherence yet.\n */\n\nstatic int sock_alloc_file(struct socket *sock, struct file **f, int flags)\n{\n\tstruct qstr name = { .name = \"\" };\n\tstruct path path;\n\tstruct file *file;\n\tint fd;\n\n\tfd = get_unused_fd_flags(flags);\n\tif (unlikely(fd < 0))\n\t\treturn fd;\n\n\tpath.dentry = d_alloc_pseudo(sock_mnt->mnt_sb, &name);\n\tif (unlikely(!path.dentry)) {\n\t\tput_unused_fd(fd);\n\t\treturn -ENOMEM;\n\t}\n\tpath.mnt = mntget(sock_mnt);\n\n\td_instantiate(path.dentry, SOCK_INODE(sock));\n\tSOCK_INODE(sock)->i_fop = &socket_file_ops;\n\n\tfile = alloc_file(&path, FMODE_READ | FMODE_WRITE,\n\t\t  &socket_file_ops);\n\tif (unlikely(!file)) {\n\t\t/* drop dentry, keep inode */\n\t\tihold(path.dentry->d_inode);\n\t\tpath_put(&path);\n\t\tput_unused_fd(fd);\n\t\treturn -ENFILE;\n\t}\n\n\tsock->file = file;\n\tfile->f_flags = O_RDWR | (flags & O_NONBLOCK);\n\tfile->f_pos = 0;\n\tfile->private_data = sock;\n\n\t*f = file;\n\treturn fd;\n}\n\nint sock_map_fd(struct socket *sock, int flags)\n{\n\tstruct file *newfile;\n\tint fd = sock_alloc_file(sock, &newfile, flags);\n\n\tif (likely(fd >= 0))\n\t\tfd_install(fd, newfile);\n\n\treturn fd;\n}\nEXPORT_SYMBOL(sock_map_fd);\n\nstatic struct socket *sock_from_file(struct file *file, int *err)\n{\n\tif (file->f_op == &socket_file_ops)\n\t\treturn file->private_data;\t/* set in sock_map_fd */\n\n\t*err = -ENOTSOCK;\n\treturn NULL;\n}\n\n/**\n *\tsockfd_lookup - Go from a file number to its socket slot\n *\t@fd: file handle\n *\t@err: pointer to an error code return\n *\n *\tThe file handle passed in is locked and the socket it is bound\n *\ttoo is returned. If an error occurs the err pointer is overwritten\n *\twith a negative errno code and NULL is returned. The function checks\n *\tfor both invalid handles and passing a handle which is not a socket.\n *\n *\tOn a success the socket object pointer is returned.\n */\n\nstruct socket *sockfd_lookup(int fd, int *err)\n{\n\tstruct file *file;\n\tstruct socket *sock;\n\n\tfile = fget(fd);\n\tif (!file) {\n\t\t*err = -EBADF;\n\t\treturn NULL;\n\t}\n\n\tsock = sock_from_file(file, err);\n\tif (!sock)\n\t\tfput(file);\n\treturn sock;\n}\nEXPORT_SYMBOL(sockfd_lookup);\n\nstatic struct socket *sockfd_lookup_light(int fd, int *err, int *fput_needed)\n{\n\tstruct file *file;\n\tstruct socket *sock;\n\n\t*err = -EBADF;\n\tfile = fget_light(fd, fput_needed);\n\tif (file) {\n\t\tsock = sock_from_file(file, err);\n\t\tif (sock)\n\t\t\treturn sock;\n\t\tfput_light(file, *fput_needed);\n\t}\n\treturn NULL;\n}\n\n/**\n *\tsock_alloc\t-\tallocate a socket\n *\n *\tAllocate a new inode and socket object. The two are bound together\n *\tand initialised. The socket is then returned. If we are out of inodes\n *\tNULL is returned.\n */\n\nstatic struct socket *sock_alloc(void)\n{\n\tstruct inode *inode;\n\tstruct socket *sock;\n\n\tinode = new_inode_pseudo(sock_mnt->mnt_sb);\n\tif (!inode)\n\t\treturn NULL;\n\n\tsock = SOCKET_I(inode);\n\n\tkmemcheck_annotate_bitfield(sock, type);\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = S_IFSOCK | S_IRWXUGO;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\n\tpercpu_add(sockets_in_use, 1);\n\treturn sock;\n}\n\n/*\n *\tIn theory you can't get an open on this inode, but /proc provides\n *\ta back door. Remember to keep it shut otherwise you'll let the\n *\tcreepy crawlies in.\n */\n\nstatic int sock_no_open(struct inode *irrelevant, struct file *dontcare)\n{\n\treturn -ENXIO;\n}\n\nconst struct file_operations bad_sock_fops = {\n\t.owner = THIS_MODULE,\n\t.open = sock_no_open,\n\t.llseek = noop_llseek,\n};\n\n/**\n *\tsock_release\t-\tclose a socket\n *\t@sock: socket to close\n *\n *\tThe socket is released from the protocol stack if it has a release\n *\tcallback, and the inode is then released if the socket is bound to\n *\tan inode not a file.\n */\n\nvoid sock_release(struct socket *sock)\n{\n\tif (sock->ops) {\n\t\tstruct module *owner = sock->ops->owner;\n\n\t\tsock->ops->release(sock);\n\t\tsock->ops = NULL;\n\t\tmodule_put(owner);\n\t}\n\n\tif (rcu_dereference_protected(sock->wq, 1)->fasync_list)\n\t\tprintk(KERN_ERR \"sock_release: fasync list not empty!\\n\");\n\n\tpercpu_sub(sockets_in_use, 1);\n\tif (!sock->file) {\n\t\tiput(SOCK_INODE(sock));\n\t\treturn;\n\t}\n\tsock->file = NULL;\n}\nEXPORT_SYMBOL(sock_release);\n\nint sock_tx_timestamp(struct sock *sk, __u8 *tx_flags)\n{\n\t*tx_flags = 0;\n\tif (sock_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE))\n\t\t*tx_flags |= SKBTX_HW_TSTAMP;\n\tif (sock_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE))\n\t\t*tx_flags |= SKBTX_SW_TSTAMP;\n\treturn 0;\n}\nEXPORT_SYMBOL(sock_tx_timestamp);\n\nstatic inline int __sock_sendmsg_nosec(struct kiocb *iocb, struct socket *sock,\n\t\t\t\t       struct msghdr *msg, size_t size)\n{\n\tstruct sock_iocb *si = kiocb_to_siocb(iocb);\n\n\tsock_update_classid(sock->sk);\n\n\tsi->sock = sock;\n\tsi->scm = NULL;\n\tsi->msg = msg;\n\tsi->size = size;\n\n\treturn sock->ops->sendmsg(iocb, sock, msg, size);\n}\n\nstatic inline int __sock_sendmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\t struct msghdr *msg, size_t size)\n{\n\tint err = security_socket_sendmsg(sock, msg, size);\n\n\treturn err ?: __sock_sendmsg_nosec(iocb, sock, msg, size);\n}\n\nint sock_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)\n{\n\tstruct kiocb iocb;\n\tstruct sock_iocb siocb;\n\tint ret;\n\n\tinit_sync_kiocb(&iocb, NULL);\n\tiocb.private = &siocb;\n\tret = __sock_sendmsg(&iocb, sock, msg, size);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&iocb);\n\treturn ret;\n}\nEXPORT_SYMBOL(sock_sendmsg);\n\nstatic int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg, size_t size)\n{\n\tstruct kiocb iocb;\n\tstruct sock_iocb siocb;\n\tint ret;\n\n\tinit_sync_kiocb(&iocb, NULL);\n\tiocb.private = &siocb;\n\tret = __sock_sendmsg_nosec(&iocb, sock, msg, size);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&iocb);\n\treturn ret;\n}\n\nint kernel_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t   struct kvec *vec, size_t num, size_t size)\n{\n\tmm_segment_t oldfs = get_fs();\n\tint result;\n\n\tset_fs(KERNEL_DS);\n\t/*\n\t * the following is safe, since for compiler definitions of kvec and\n\t * iovec are identical, yielding the same in-core layout and alignment\n\t */\n\tmsg->msg_iov = (struct iovec *)vec;\n\tmsg->msg_iovlen = num;\n\tresult = sock_sendmsg(sock, msg, size);\n\tset_fs(oldfs);\n\treturn result;\n}\nEXPORT_SYMBOL(kernel_sendmsg);\n\nstatic int ktime2ts(ktime_t kt, struct timespec *ts)\n{\n\tif (kt.tv64) {\n\t\t*ts = ktime_to_timespec(kt);\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\n/*\n * called from sock_recv_timestamp() if sock_flag(sk, SOCK_RCVTSTAMP)\n */\nvoid __sock_recv_timestamp(struct msghdr *msg, struct sock *sk,\n\tstruct sk_buff *skb)\n{\n\tint need_software_tstamp = sock_flag(sk, SOCK_RCVTSTAMP);\n\tstruct timespec ts[3];\n\tint empty = 1;\n\tstruct skb_shared_hwtstamps *shhwtstamps =\n\t\tskb_hwtstamps(skb);\n\n\t/* Race occurred between timestamp enabling and packet\n\t   receiving.  Fill in the current time for now. */\n\tif (need_software_tstamp && skb->tstamp.tv64 == 0)\n\t\t__net_timestamp(skb);\n\n\tif (need_software_tstamp) {\n\t\tif (!sock_flag(sk, SOCK_RCVTSTAMPNS)) {\n\t\t\tstruct timeval tv;\n\t\t\tskb_get_timestamp(skb, &tv);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMP,\n\t\t\t\t sizeof(tv), &tv);\n\t\t} else {\n\t\t\tskb_get_timestampns(skb, &ts[0]);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPNS,\n\t\t\t\t sizeof(ts[0]), &ts[0]);\n\t\t}\n\t}\n\n\n\tmemset(ts, 0, sizeof(ts));\n\tif (skb->tstamp.tv64 &&\n\t    sock_flag(sk, SOCK_TIMESTAMPING_SOFTWARE)) {\n\t\tskb_get_timestampns(skb, ts + 0);\n\t\tempty = 0;\n\t}\n\tif (shhwtstamps) {\n\t\tif (sock_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE) &&\n\t\t    ktime2ts(shhwtstamps->syststamp, ts + 1))\n\t\t\tempty = 0;\n\t\tif (sock_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE) &&\n\t\t    ktime2ts(shhwtstamps->hwtstamp, ts + 2))\n\t\t\tempty = 0;\n\t}\n\tif (!empty)\n\t\tput_cmsg(msg, SOL_SOCKET,\n\t\t\t SCM_TIMESTAMPING, sizeof(ts), &ts);\n}\nEXPORT_SYMBOL_GPL(__sock_recv_timestamp);\n\nstatic inline void sock_recv_drops(struct msghdr *msg, struct sock *sk,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tif (sock_flag(sk, SOCK_RXQ_OVFL) && skb && skb->dropcount)\n\t\tput_cmsg(msg, SOL_SOCKET, SO_RXQ_OVFL,\n\t\t\tsizeof(__u32), &skb->dropcount);\n}\n\nvoid __sock_recv_ts_and_drops(struct msghdr *msg, struct sock *sk,\n\tstruct sk_buff *skb)\n{\n\tsock_recv_timestamp(msg, sk, skb);\n\tsock_recv_drops(msg, sk, skb);\n}\nEXPORT_SYMBOL_GPL(__sock_recv_ts_and_drops);\n\nstatic inline int __sock_recvmsg_nosec(struct kiocb *iocb, struct socket *sock,\n\t\t\t\t       struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock_iocb *si = kiocb_to_siocb(iocb);\n\n\tsock_update_classid(sock->sk);\n\n\tsi->sock = sock;\n\tsi->scm = NULL;\n\tsi->msg = msg;\n\tsi->size = size;\n\tsi->flags = flags;\n\n\treturn sock->ops->recvmsg(iocb, sock, msg, size, flags);\n}\n\nstatic inline int __sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\t struct msghdr *msg, size_t size, int flags)\n{\n\tint err = security_socket_recvmsg(sock, msg, size, flags);\n\n\treturn err ?: __sock_recvmsg_nosec(iocb, sock, msg, size, flags);\n}\n\nint sock_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t size_t size, int flags)\n{\n\tstruct kiocb iocb;\n\tstruct sock_iocb siocb;\n\tint ret;\n\n\tinit_sync_kiocb(&iocb, NULL);\n\tiocb.private = &siocb;\n\tret = __sock_recvmsg(&iocb, sock, msg, size, flags);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&iocb);\n\treturn ret;\n}\nEXPORT_SYMBOL(sock_recvmsg);\n\nstatic int sock_recvmsg_nosec(struct socket *sock, struct msghdr *msg,\n\t\t\t      size_t size, int flags)\n{\n\tstruct kiocb iocb;\n\tstruct sock_iocb siocb;\n\tint ret;\n\n\tinit_sync_kiocb(&iocb, NULL);\n\tiocb.private = &siocb;\n\tret = __sock_recvmsg_nosec(&iocb, sock, msg, size, flags);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&iocb);\n\treturn ret;\n}\n\n/**\n * kernel_recvmsg - Receive a message from a socket (kernel space)\n * @sock:       The socket to receive the message from\n * @msg:        Received message\n * @vec:        Input s/g array for message data\n * @num:        Size of input s/g array\n * @size:       Number of bytes to read\n * @flags:      Message flags (MSG_DONTWAIT, etc...)\n *\n * On return the msg structure contains the scatter/gather array passed in the\n * vec argument. The array is modified so that it consists of the unfilled\n * portion of the original array.\n *\n * The returned value is the total number of bytes received, or an error.\n */\nint kernel_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t   struct kvec *vec, size_t num, size_t size, int flags)\n{\n\tmm_segment_t oldfs = get_fs();\n\tint result;\n\n\tset_fs(KERNEL_DS);\n\t/*\n\t * the following is safe, since for compiler definitions of kvec and\n\t * iovec are identical, yielding the same in-core layout and alignment\n\t */\n\tmsg->msg_iov = (struct iovec *)vec, msg->msg_iovlen = num;\n\tresult = sock_recvmsg(sock, msg, size, flags);\n\tset_fs(oldfs);\n\treturn result;\n}\nEXPORT_SYMBOL(kernel_recvmsg);\n\nstatic void sock_aio_dtor(struct kiocb *iocb)\n{\n\tkfree(iocb->private);\n}\n\nstatic ssize_t sock_sendpage(struct file *file, struct page *page,\n\t\t\t     int offset, size_t size, loff_t *ppos, int more)\n{\n\tstruct socket *sock;\n\tint flags;\n\n\tsock = file->private_data;\n\n\tflags = !(file->f_flags & O_NONBLOCK) ? 0 : MSG_DONTWAIT;\n\tif (more)\n\t\tflags |= MSG_MORE;\n\n\treturn kernel_sendpage(sock, page, offset, size, flags);\n}\n\nstatic ssize_t sock_splice_read(struct file *file, loff_t *ppos,\n\t\t\t\tstruct pipe_inode_info *pipe, size_t len,\n\t\t\t\tunsigned int flags)\n{\n\tstruct socket *sock = file->private_data;\n\n\tif (unlikely(!sock->ops->splice_read))\n\t\treturn -EINVAL;\n\n\tsock_update_classid(sock->sk);\n\n\treturn sock->ops->splice_read(sock, ppos, pipe, len, flags);\n}\n\nstatic struct sock_iocb *alloc_sock_iocb(struct kiocb *iocb,\n\t\t\t\t\t struct sock_iocb *siocb)\n{\n\tif (!is_sync_kiocb(iocb)) {\n\t\tsiocb = kmalloc(sizeof(*siocb), GFP_KERNEL);\n\t\tif (!siocb)\n\t\t\treturn NULL;\n\t\tiocb->ki_dtor = sock_aio_dtor;\n\t}\n\n\tsiocb->kiocb = iocb;\n\tiocb->private = siocb;\n\treturn siocb;\n}\n\nstatic ssize_t do_sock_read(struct msghdr *msg, struct kiocb *iocb,\n\t\tstruct file *file, const struct iovec *iov,\n\t\tunsigned long nr_segs)\n{\n\tstruct socket *sock = file->private_data;\n\tsize_t size = 0;\n\tint i;\n\n\tfor (i = 0; i < nr_segs; i++)\n\t\tsize += iov[i].iov_len;\n\n\tmsg->msg_name = NULL;\n\tmsg->msg_namelen = 0;\n\tmsg->msg_control = NULL;\n\tmsg->msg_controllen = 0;\n\tmsg->msg_iov = (struct iovec *)iov;\n\tmsg->msg_iovlen = nr_segs;\n\tmsg->msg_flags = (file->f_flags & O_NONBLOCK) ? MSG_DONTWAIT : 0;\n\n\treturn __sock_recvmsg(iocb, sock, msg, size, msg->msg_flags);\n}\n\nstatic ssize_t sock_aio_read(struct kiocb *iocb, const struct iovec *iov,\n\t\t\t\tunsigned long nr_segs, loff_t pos)\n{\n\tstruct sock_iocb siocb, *x;\n\n\tif (pos != 0)\n\t\treturn -ESPIPE;\n\n\tif (iocb->ki_left == 0)\t/* Match SYS5 behaviour */\n\t\treturn 0;\n\n\n\tx = alloc_sock_iocb(iocb, &siocb);\n\tif (!x)\n\t\treturn -ENOMEM;\n\treturn do_sock_read(&x->async_msg, iocb, iocb->ki_filp, iov, nr_segs);\n}\n\nstatic ssize_t do_sock_write(struct msghdr *msg, struct kiocb *iocb,\n\t\t\tstruct file *file, const struct iovec *iov,\n\t\t\tunsigned long nr_segs)\n{\n\tstruct socket *sock = file->private_data;\n\tsize_t size = 0;\n\tint i;\n\n\tfor (i = 0; i < nr_segs; i++)\n\t\tsize += iov[i].iov_len;\n\n\tmsg->msg_name = NULL;\n\tmsg->msg_namelen = 0;\n\tmsg->msg_control = NULL;\n\tmsg->msg_controllen = 0;\n\tmsg->msg_iov = (struct iovec *)iov;\n\tmsg->msg_iovlen = nr_segs;\n\tmsg->msg_flags = (file->f_flags & O_NONBLOCK) ? MSG_DONTWAIT : 0;\n\tif (sock->type == SOCK_SEQPACKET)\n\t\tmsg->msg_flags |= MSG_EOR;\n\n\treturn __sock_sendmsg(iocb, sock, msg, size);\n}\n\nstatic ssize_t sock_aio_write(struct kiocb *iocb, const struct iovec *iov,\n\t\t\t  unsigned long nr_segs, loff_t pos)\n{\n\tstruct sock_iocb siocb, *x;\n\n\tif (pos != 0)\n\t\treturn -ESPIPE;\n\n\tx = alloc_sock_iocb(iocb, &siocb);\n\tif (!x)\n\t\treturn -ENOMEM;\n\n\treturn do_sock_write(&x->async_msg, iocb, iocb->ki_filp, iov, nr_segs);\n}\n\n/*\n * Atomic setting of ioctl hooks to avoid race\n * with module unload.\n */\n\nstatic DEFINE_MUTEX(br_ioctl_mutex);\nstatic int (*br_ioctl_hook) (struct net *, unsigned int cmd, void __user *arg);\n\nvoid brioctl_set(int (*hook) (struct net *, unsigned int, void __user *))\n{\n\tmutex_lock(&br_ioctl_mutex);\n\tbr_ioctl_hook = hook;\n\tmutex_unlock(&br_ioctl_mutex);\n}\nEXPORT_SYMBOL(brioctl_set);\n\nstatic DEFINE_MUTEX(vlan_ioctl_mutex);\nstatic int (*vlan_ioctl_hook) (struct net *, void __user *arg);\n\nvoid vlan_ioctl_set(int (*hook) (struct net *, void __user *))\n{\n\tmutex_lock(&vlan_ioctl_mutex);\n\tvlan_ioctl_hook = hook;\n\tmutex_unlock(&vlan_ioctl_mutex);\n}\nEXPORT_SYMBOL(vlan_ioctl_set);\n\nstatic DEFINE_MUTEX(dlci_ioctl_mutex);\nstatic int (*dlci_ioctl_hook) (unsigned int, void __user *);\n\nvoid dlci_ioctl_set(int (*hook) (unsigned int, void __user *))\n{\n\tmutex_lock(&dlci_ioctl_mutex);\n\tdlci_ioctl_hook = hook;\n\tmutex_unlock(&dlci_ioctl_mutex);\n}\nEXPORT_SYMBOL(dlci_ioctl_set);\n\nstatic long sock_do_ioctl(struct net *net, struct socket *sock,\n\t\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tint err;\n\tvoid __user *argp = (void __user *)arg;\n\n\terr = sock->ops->ioctl(sock, cmd, arg);\n\n\t/*\n\t * If this ioctl is unknown try to hand it down\n\t * to the NIC driver.\n\t */\n\tif (err == -ENOIOCTLCMD)\n\t\terr = dev_ioctl(net, cmd, argp);\n\n\treturn err;\n}\n\n/*\n *\tWith an ioctl, arg may well be a user mode pointer, but we don't know\n *\twhat to do with it - that's up to the protocol still.\n */\n\nstatic long sock_ioctl(struct file *file, unsigned cmd, unsigned long arg)\n{\n\tstruct socket *sock;\n\tstruct sock *sk;\n\tvoid __user *argp = (void __user *)arg;\n\tint pid, err;\n\tstruct net *net;\n\n\tsock = file->private_data;\n\tsk = sock->sk;\n\tnet = sock_net(sk);\n\tif (cmd >= SIOCDEVPRIVATE && cmd <= (SIOCDEVPRIVATE + 15)) {\n\t\terr = dev_ioctl(net, cmd, argp);\n\t} else\n#ifdef CONFIG_WEXT_CORE\n\tif (cmd >= SIOCIWFIRST && cmd <= SIOCIWLAST) {\n\t\terr = dev_ioctl(net, cmd, argp);\n\t} else\n#endif\n\t\tswitch (cmd) {\n\t\tcase FIOSETOWN:\n\t\tcase SIOCSPGRP:\n\t\t\terr = -EFAULT;\n\t\t\tif (get_user(pid, (int __user *)argp))\n\t\t\t\tbreak;\n\t\t\terr = f_setown(sock->file, pid, 1);\n\t\t\tbreak;\n\t\tcase FIOGETOWN:\n\t\tcase SIOCGPGRP:\n\t\t\terr = put_user(f_getown(sock->file),\n\t\t\t\t       (int __user *)argp);\n\t\t\tbreak;\n\t\tcase SIOCGIFBR:\n\t\tcase SIOCSIFBR:\n\t\tcase SIOCBRADDBR:\n\t\tcase SIOCBRDELBR:\n\t\t\terr = -ENOPKG;\n\t\t\tif (!br_ioctl_hook)\n\t\t\t\trequest_module(\"bridge\");\n\n\t\t\tmutex_lock(&br_ioctl_mutex);\n\t\t\tif (br_ioctl_hook)\n\t\t\t\terr = br_ioctl_hook(net, cmd, argp);\n\t\t\tmutex_unlock(&br_ioctl_mutex);\n\t\t\tbreak;\n\t\tcase SIOCGIFVLAN:\n\t\tcase SIOCSIFVLAN:\n\t\t\terr = -ENOPKG;\n\t\t\tif (!vlan_ioctl_hook)\n\t\t\t\trequest_module(\"8021q\");\n\n\t\t\tmutex_lock(&vlan_ioctl_mutex);\n\t\t\tif (vlan_ioctl_hook)\n\t\t\t\terr = vlan_ioctl_hook(net, argp);\n\t\t\tmutex_unlock(&vlan_ioctl_mutex);\n\t\t\tbreak;\n\t\tcase SIOCADDDLCI:\n\t\tcase SIOCDELDLCI:\n\t\t\terr = -ENOPKG;\n\t\t\tif (!dlci_ioctl_hook)\n\t\t\t\trequest_module(\"dlci\");\n\n\t\t\tmutex_lock(&dlci_ioctl_mutex);\n\t\t\tif (dlci_ioctl_hook)\n\t\t\t\terr = dlci_ioctl_hook(cmd, argp);\n\t\t\tmutex_unlock(&dlci_ioctl_mutex);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = sock_do_ioctl(net, sock, cmd, arg);\n\t\t\tbreak;\n\t\t}\n\treturn err;\n}\n\nint sock_create_lite(int family, int type, int protocol, struct socket **res)\n{\n\tint err;\n\tstruct socket *sock = NULL;\n\n\terr = security_socket_create(family, type, protocol, 1);\n\tif (err)\n\t\tgoto out;\n\n\tsock = sock_alloc();\n\tif (!sock) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsock->type = type;\n\terr = security_socket_post_create(sock, family, type, protocol, 1);\n\tif (err)\n\t\tgoto out_release;\n\nout:\n\t*res = sock;\n\treturn err;\nout_release:\n\tsock_release(sock);\n\tsock = NULL;\n\tgoto out;\n}\nEXPORT_SYMBOL(sock_create_lite);\n\n/* No kernel lock held - perfect */\nstatic unsigned int sock_poll(struct file *file, poll_table *wait)\n{\n\tstruct socket *sock;\n\n\t/*\n\t *      We can't return errors to poll, so it's either yes or no.\n\t */\n\tsock = file->private_data;\n\treturn sock->ops->poll(file, sock, wait);\n}\n\nstatic int sock_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct socket *sock = file->private_data;\n\n\treturn sock->ops->mmap(file, sock, vma);\n}\n\nstatic int sock_close(struct inode *inode, struct file *filp)\n{\n\t/*\n\t *      It was possible the inode is NULL we were\n\t *      closing an unfinished socket.\n\t */\n\n\tif (!inode) {\n\t\tprintk(KERN_DEBUG \"sock_close: NULL inode\\n\");\n\t\treturn 0;\n\t}\n\tsock_release(SOCKET_I(inode));\n\treturn 0;\n}\n\n/*\n *\tUpdate the socket async list\n *\n *\tFasync_list locking strategy.\n *\n *\t1. fasync_list is modified only under process context socket lock\n *\t   i.e. under semaphore.\n *\t2. fasync_list is used under read_lock(&sk->sk_callback_lock)\n *\t   or under socket lock\n */\n\nstatic int sock_fasync(int fd, struct file *filp, int on)\n{\n\tstruct socket *sock = filp->private_data;\n\tstruct sock *sk = sock->sk;\n\tstruct socket_wq *wq;\n\n\tif (sk == NULL)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\twq = rcu_dereference_protected(sock->wq, sock_owned_by_user(sk));\n\tfasync_helper(fd, filp, on, &wq->fasync_list);\n\n\tif (!wq->fasync_list)\n\t\tsock_reset_flag(sk, SOCK_FASYNC);\n\telse\n\t\tsock_set_flag(sk, SOCK_FASYNC);\n\n\trelease_sock(sk);\n\treturn 0;\n}\n\n/* This function may be called only under socket lock or callback_lock or rcu_lock */\n\nint sock_wake_async(struct socket *sock, int how, int band)\n{\n\tstruct socket_wq *wq;\n\n\tif (!sock)\n\t\treturn -1;\n\trcu_read_lock();\n\twq = rcu_dereference(sock->wq);\n\tif (!wq || !wq->fasync_list) {\n\t\trcu_read_unlock();\n\t\treturn -1;\n\t}\n\tswitch (how) {\n\tcase SOCK_WAKE_WAITD:\n\t\tif (test_bit(SOCK_ASYNC_WAITDATA, &sock->flags))\n\t\t\tbreak;\n\t\tgoto call_kill;\n\tcase SOCK_WAKE_SPACE:\n\t\tif (!test_and_clear_bit(SOCK_ASYNC_NOSPACE, &sock->flags))\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase SOCK_WAKE_IO:\ncall_kill:\n\t\tkill_fasync(&wq->fasync_list, SIGIO, band);\n\t\tbreak;\n\tcase SOCK_WAKE_URG:\n\t\tkill_fasync(&wq->fasync_list, SIGURG, band);\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}\nEXPORT_SYMBOL(sock_wake_async);\n\nint __sock_create(struct net *net, int family, int type, int protocol,\n\t\t\t struct socket **res, int kern)\n{\n\tint err;\n\tstruct socket *sock;\n\tconst struct net_proto_family *pf;\n\n\t/*\n\t *      Check protocol is in range\n\t */\n\tif (family < 0 || family >= NPROTO)\n\t\treturn -EAFNOSUPPORT;\n\tif (type < 0 || type >= SOCK_MAX)\n\t\treturn -EINVAL;\n\n\t/* Compatibility.\n\n\t   This uglymoron is moved from INET layer to here to avoid\n\t   deadlock in module load.\n\t */\n\tif (family == PF_INET && type == SOCK_PACKET) {\n\t\tstatic int warned;\n\t\tif (!warned) {\n\t\t\twarned = 1;\n\t\t\tprintk(KERN_INFO \"%s uses obsolete (PF_INET,SOCK_PACKET)\\n\",\n\t\t\t       current->comm);\n\t\t}\n\t\tfamily = PF_PACKET;\n\t}\n\n\terr = security_socket_create(family, type, protocol, kern);\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t *\tAllocate the socket and allow the family to set things up. if\n\t *\tthe protocol is 0, the family is instructed to select an appropriate\n\t *\tdefault.\n\t */\n\tsock = sock_alloc();\n\tif (!sock) {\n\t\tif (net_ratelimit())\n\t\t\tprintk(KERN_WARNING \"socket: no more sockets\\n\");\n\t\treturn -ENFILE;\t/* Not exactly a match, but its the\n\t\t\t\t   closest posix thing */\n\t}\n\n\tsock->type = type;\n\n#ifdef CONFIG_MODULES\n\t/* Attempt to load a protocol module if the find failed.\n\t *\n\t * 12/09/1996 Marcin: But! this makes REALLY only sense, if the user\n\t * requested real, full-featured networking support upon configuration.\n\t * Otherwise module support will break!\n\t */\n\tif (rcu_access_pointer(net_families[family]) == NULL)\n\t\trequest_module(\"net-pf-%d\", family);\n#endif\n\n\trcu_read_lock();\n\tpf = rcu_dereference(net_families[family]);\n\terr = -EAFNOSUPPORT;\n\tif (!pf)\n\t\tgoto out_release;\n\n\t/*\n\t * We will call the ->create function, that possibly is in a loadable\n\t * module, so we have to bump that loadable module refcnt first.\n\t */\n\tif (!try_module_get(pf->owner))\n\t\tgoto out_release;\n\n\t/* Now protected by module ref count */\n\trcu_read_unlock();\n\n\terr = pf->create(net, sock, protocol, kern);\n\tif (err < 0)\n\t\tgoto out_module_put;\n\n\t/*\n\t * Now to bump the refcnt of the [loadable] module that owns this\n\t * socket at sock_release time we decrement its refcnt.\n\t */\n\tif (!try_module_get(sock->ops->owner))\n\t\tgoto out_module_busy;\n\n\t/*\n\t * Now that we're done with the ->create function, the [loadable]\n\t * module can have its refcnt decremented\n\t */\n\tmodule_put(pf->owner);\n\terr = security_socket_post_create(sock, family, type, protocol, kern);\n\tif (err)\n\t\tgoto out_sock_release;\n\t*res = sock;\n\n\treturn 0;\n\nout_module_busy:\n\terr = -EAFNOSUPPORT;\nout_module_put:\n\tsock->ops = NULL;\n\tmodule_put(pf->owner);\nout_sock_release:\n\tsock_release(sock);\n\treturn err;\n\nout_release:\n\trcu_read_unlock();\n\tgoto out_sock_release;\n}\nEXPORT_SYMBOL(__sock_create);\n\nint sock_create(int family, int type, int protocol, struct socket **res)\n{\n\treturn __sock_create(current->nsproxy->net_ns, family, type, protocol, res, 0);\n}\nEXPORT_SYMBOL(sock_create);\n\nint sock_create_kern(int family, int type, int protocol, struct socket **res)\n{\n\treturn __sock_create(&init_net, family, type, protocol, res, 1);\n}\nEXPORT_SYMBOL(sock_create_kern);\n\nSYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)\n{\n\tint retval;\n\tstruct socket *sock;\n\tint flags;\n\n\t/* Check the SOCK_* constants for consistency.  */\n\tBUILD_BUG_ON(SOCK_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON((SOCK_MAX | SOCK_TYPE_MASK) != SOCK_TYPE_MASK);\n\tBUILD_BUG_ON(SOCK_CLOEXEC & SOCK_TYPE_MASK);\n\tBUILD_BUG_ON(SOCK_NONBLOCK & SOCK_TYPE_MASK);\n\n\tflags = type & ~SOCK_TYPE_MASK;\n\tif (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))\n\t\treturn -EINVAL;\n\ttype &= SOCK_TYPE_MASK;\n\n\tif (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))\n\t\tflags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;\n\n\tretval = sock_create(family, type, protocol, &sock);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = sock_map_fd(sock, flags & (O_CLOEXEC | O_NONBLOCK));\n\tif (retval < 0)\n\t\tgoto out_release;\n\nout:\n\t/* It may be already another descriptor 8) Not kernel problem. */\n\treturn retval;\n\nout_release:\n\tsock_release(sock);\n\treturn retval;\n}\n\n/*\n *\tCreate a pair of connected sockets.\n */\n\nSYSCALL_DEFINE4(socketpair, int, family, int, type, int, protocol,\n\t\tint __user *, usockvec)\n{\n\tstruct socket *sock1, *sock2;\n\tint fd1, fd2, err;\n\tstruct file *newfile1, *newfile2;\n\tint flags;\n\n\tflags = type & ~SOCK_TYPE_MASK;\n\tif (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))\n\t\treturn -EINVAL;\n\ttype &= SOCK_TYPE_MASK;\n\n\tif (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))\n\t\tflags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;\n\n\t/*\n\t * Obtain the first socket and check if the underlying protocol\n\t * supports the socketpair call.\n\t */\n\n\terr = sock_create(family, type, protocol, &sock1);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = sock_create(family, type, protocol, &sock2);\n\tif (err < 0)\n\t\tgoto out_release_1;\n\n\terr = sock1->ops->socketpair(sock1, sock2);\n\tif (err < 0)\n\t\tgoto out_release_both;\n\n\tfd1 = sock_alloc_file(sock1, &newfile1, flags);\n\tif (unlikely(fd1 < 0)) {\n\t\terr = fd1;\n\t\tgoto out_release_both;\n\t}\n\n\tfd2 = sock_alloc_file(sock2, &newfile2, flags);\n\tif (unlikely(fd2 < 0)) {\n\t\terr = fd2;\n\t\tfput(newfile1);\n\t\tput_unused_fd(fd1);\n\t\tsock_release(sock2);\n\t\tgoto out;\n\t}\n\n\taudit_fd_pair(fd1, fd2);\n\tfd_install(fd1, newfile1);\n\tfd_install(fd2, newfile2);\n\t/* fd1 and fd2 may be already another descriptors.\n\t * Not kernel problem.\n\t */\n\n\terr = put_user(fd1, &usockvec[0]);\n\tif (!err)\n\t\terr = put_user(fd2, &usockvec[1]);\n\tif (!err)\n\t\treturn 0;\n\n\tsys_close(fd2);\n\tsys_close(fd1);\n\treturn err;\n\nout_release_both:\n\tsock_release(sock2);\nout_release_1:\n\tsock_release(sock1);\nout:\n\treturn err;\n}\n\n/*\n *\tBind a name to a socket. Nothing much to do here since it's\n *\tthe protocol's responsibility to handle the local address.\n *\n *\tWe move the socket address to kernel space before we call\n *\tthe protocol layer (having also checked the address is ok).\n */\n\nSYSCALL_DEFINE3(bind, int, fd, struct sockaddr __user *, umyaddr, int, addrlen)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint err, fput_needed;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock) {\n\t\terr = move_addr_to_kernel(umyaddr, addrlen, (struct sockaddr *)&address);\n\t\tif (err >= 0) {\n\t\t\terr = security_socket_bind(sock,\n\t\t\t\t\t\t   (struct sockaddr *)&address,\n\t\t\t\t\t\t   addrlen);\n\t\t\tif (!err)\n\t\t\t\terr = sock->ops->bind(sock,\n\t\t\t\t\t\t      (struct sockaddr *)\n\t\t\t\t\t\t      &address, addrlen);\n\t\t}\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\n/*\n *\tPerform a listen. Basically, we allow the protocol to do anything\n *\tnecessary for a listen, and if that works, we mark the socket as\n *\tready for listening.\n */\n\nSYSCALL_DEFINE2(listen, int, fd, int, backlog)\n{\n\tstruct socket *sock;\n\tint err, fput_needed;\n\tint somaxconn;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock) {\n\t\tsomaxconn = sock_net(sock->sk)->core.sysctl_somaxconn;\n\t\tif ((unsigned)backlog > somaxconn)\n\t\t\tbacklog = somaxconn;\n\n\t\terr = security_socket_listen(sock, backlog);\n\t\tif (!err)\n\t\t\terr = sock->ops->listen(sock, backlog);\n\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\n/*\n *\tFor accept, we attempt to create a new socket, set up the link\n *\twith the client, wake up the client, then return the new\n *\tconnected fd. We collect the address of the connector in kernel\n *\tspace and move it to user at the very end. This is unclean because\n *\twe open the socket then return an error.\n *\n *\t1003.1g adds the ability to recvmsg() to query connection pending\n *\tstatus to recvmsg. We need to add that support in a way thats\n *\tclean when we restucture accept also.\n */\n\nSYSCALL_DEFINE4(accept4, int, fd, struct sockaddr __user *, upeer_sockaddr,\n\t\tint __user *, upeer_addrlen, int, flags)\n{\n\tstruct socket *sock, *newsock;\n\tstruct file *newfile;\n\tint err, len, newfd, fput_needed;\n\tstruct sockaddr_storage address;\n\n\tif (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))\n\t\treturn -EINVAL;\n\n\tif (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))\n\t\tflags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\terr = -ENFILE;\n\tnewsock = sock_alloc();\n\tif (!newsock)\n\t\tgoto out_put;\n\n\tnewsock->type = sock->type;\n\tnewsock->ops = sock->ops;\n\n\t/*\n\t * We don't need try_module_get here, as the listening socket (sock)\n\t * has the protocol module (sock->ops->owner) held.\n\t */\n\t__module_get(newsock->ops->owner);\n\n\tnewfd = sock_alloc_file(newsock, &newfile, flags);\n\tif (unlikely(newfd < 0)) {\n\t\terr = newfd;\n\t\tsock_release(newsock);\n\t\tgoto out_put;\n\t}\n\n\terr = security_socket_accept(sock, newsock);\n\tif (err)\n\t\tgoto out_fd;\n\n\terr = sock->ops->accept(sock, newsock, sock->file->f_flags);\n\tif (err < 0)\n\t\tgoto out_fd;\n\n\tif (upeer_sockaddr) {\n\t\tif (newsock->ops->getname(newsock, (struct sockaddr *)&address,\n\t\t\t\t\t  &len, 2) < 0) {\n\t\t\terr = -ECONNABORTED;\n\t\t\tgoto out_fd;\n\t\t}\n\t\terr = move_addr_to_user((struct sockaddr *)&address,\n\t\t\t\t\tlen, upeer_sockaddr, upeer_addrlen);\n\t\tif (err < 0)\n\t\t\tgoto out_fd;\n\t}\n\n\t/* File flags are not inherited via accept() unlike another OSes. */\n\n\tfd_install(newfd, newfile);\n\terr = newfd;\n\nout_put:\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\nout_fd:\n\tfput(newfile);\n\tput_unused_fd(newfd);\n\tgoto out_put;\n}\n\nSYSCALL_DEFINE3(accept, int, fd, struct sockaddr __user *, upeer_sockaddr,\n\t\tint __user *, upeer_addrlen)\n{\n\treturn sys_accept4(fd, upeer_sockaddr, upeer_addrlen, 0);\n}\n\n/*\n *\tAttempt to connect to a socket with the server address.  The address\n *\tis in user space so we verify it is OK and move it to kernel space.\n *\n *\tFor 1003.1g we need to add clean support for a bind to AF_UNSPEC to\n *\tbreak bindings\n *\n *\tNOTE: 1003.1g draft 6.3 is broken with respect to AX.25/NetROM and\n *\tother SEQPACKET protocols that take time to connect() as it doesn't\n *\tinclude the -EINPROGRESS status for such sockets.\n */\n\nSYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uservaddr,\n\t\tint, addrlen)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint err, fput_needed;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\terr = move_addr_to_kernel(uservaddr, addrlen, (struct sockaddr *)&address);\n\tif (err < 0)\n\t\tgoto out_put;\n\n\terr =\n\t    security_socket_connect(sock, (struct sockaddr *)&address, addrlen);\n\tif (err)\n\t\tgoto out_put;\n\n\terr = sock->ops->connect(sock, (struct sockaddr *)&address, addrlen,\n\t\t\t\t sock->file->f_flags);\nout_put:\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\n/*\n *\tGet the local address ('name') of a socket object. Move the obtained\n *\tname to user space.\n */\n\nSYSCALL_DEFINE3(getsockname, int, fd, struct sockaddr __user *, usockaddr,\n\t\tint __user *, usockaddr_len)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint len, err, fput_needed;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\terr = security_socket_getsockname(sock);\n\tif (err)\n\t\tgoto out_put;\n\n\terr = sock->ops->getname(sock, (struct sockaddr *)&address, &len, 0);\n\tif (err)\n\t\tgoto out_put;\n\terr = move_addr_to_user((struct sockaddr *)&address, len, usockaddr, usockaddr_len);\n\nout_put:\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\n/*\n *\tGet the remote address ('name') of a socket object. Move the obtained\n *\tname to user space.\n */\n\nSYSCALL_DEFINE3(getpeername, int, fd, struct sockaddr __user *, usockaddr,\n\t\tint __user *, usockaddr_len)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint len, err, fput_needed;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock != NULL) {\n\t\terr = security_socket_getpeername(sock);\n\t\tif (err) {\n\t\t\tfput_light(sock->file, fput_needed);\n\t\t\treturn err;\n\t\t}\n\n\t\terr =\n\t\t    sock->ops->getname(sock, (struct sockaddr *)&address, &len,\n\t\t\t\t       1);\n\t\tif (!err)\n\t\t\terr = move_addr_to_user((struct sockaddr *)&address, len, usockaddr,\n\t\t\t\t\t\tusockaddr_len);\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\n/*\n *\tSend a datagram to a given address. We move the address into kernel\n *\tspace and check the user space data area is readable before invoking\n *\tthe protocol.\n */\n\nSYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len,\n\t\tunsigned, flags, struct sockaddr __user *, addr,\n\t\tint, addr_len)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint err;\n\tstruct msghdr msg;\n\tstruct iovec iov;\n\tint fput_needed;\n\n\tif (len > INT_MAX)\n\t\tlen = INT_MAX;\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\tiov.iov_base = buff;\n\tiov.iov_len = len;\n\tmsg.msg_name = NULL;\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_namelen = 0;\n\tif (addr) {\n\t\terr = move_addr_to_kernel(addr, addr_len, (struct sockaddr *)&address);\n\t\tif (err < 0)\n\t\t\tgoto out_put;\n\t\tmsg.msg_name = (struct sockaddr *)&address;\n\t\tmsg.msg_namelen = addr_len;\n\t}\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\tmsg.msg_flags = flags;\n\terr = sock_sendmsg(sock, &msg, len);\n\nout_put:\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\n/*\n *\tSend a datagram down a socket.\n */\n\nSYSCALL_DEFINE4(send, int, fd, void __user *, buff, size_t, len,\n\t\tunsigned, flags)\n{\n\treturn sys_sendto(fd, buff, len, flags, NULL, 0);\n}\n\n/*\n *\tReceive a frame from the socket and optionally record the address of the\n *\tsender. We verify the buffers are writable and if needed move the\n *\tsender address from kernel to user space.\n */\n\nSYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,\n\t\tunsigned, flags, struct sockaddr __user *, addr,\n\t\tint __user *, addr_len)\n{\n\tstruct socket *sock;\n\tstruct iovec iov;\n\tstruct msghdr msg;\n\tstruct sockaddr_storage address;\n\tint err, err2;\n\tint fput_needed;\n\n\tif (size > INT_MAX)\n\t\tsize = INT_MAX;\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_iov = &iov;\n\tiov.iov_len = size;\n\tiov.iov_base = ubuf;\n\tmsg.msg_name = (struct sockaddr *)&address;\n\tmsg.msg_namelen = sizeof(address);\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\terr = sock_recvmsg(sock, &msg, size, flags);\n\n\tif (err >= 0 && addr != NULL) {\n\t\terr2 = move_addr_to_user((struct sockaddr *)&address,\n\t\t\t\t\t msg.msg_namelen, addr, addr_len);\n\t\tif (err2 < 0)\n\t\t\terr = err2;\n\t}\n\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\n/*\n *\tReceive a datagram from a socket.\n */\n\nasmlinkage long sys_recv(int fd, void __user *ubuf, size_t size,\n\t\t\t unsigned flags)\n{\n\treturn sys_recvfrom(fd, ubuf, size, flags, NULL, NULL);\n}\n\n/*\n *\tSet a socket option. Because we don't know the option lengths we have\n *\tto pass the user mode parameter for the protocols to sort out.\n */\n\nSYSCALL_DEFINE5(setsockopt, int, fd, int, level, int, optname,\n\t\tchar __user *, optval, int, optlen)\n{\n\tint err, fput_needed;\n\tstruct socket *sock;\n\n\tif (optlen < 0)\n\t\treturn -EINVAL;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock != NULL) {\n\t\terr = security_socket_setsockopt(sock, level, optname);\n\t\tif (err)\n\t\t\tgoto out_put;\n\n\t\tif (level == SOL_SOCKET)\n\t\t\terr =\n\t\t\t    sock_setsockopt(sock, level, optname, optval,\n\t\t\t\t\t    optlen);\n\t\telse\n\t\t\terr =\n\t\t\t    sock->ops->setsockopt(sock, level, optname, optval,\n\t\t\t\t\t\t  optlen);\nout_put:\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\n/*\n *\tGet a socket option. Because we don't know the option lengths we have\n *\tto pass a user mode parameter for the protocols to sort out.\n */\n\nSYSCALL_DEFINE5(getsockopt, int, fd, int, level, int, optname,\n\t\tchar __user *, optval, int __user *, optlen)\n{\n\tint err, fput_needed;\n\tstruct socket *sock;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock != NULL) {\n\t\terr = security_socket_getsockopt(sock, level, optname);\n\t\tif (err)\n\t\t\tgoto out_put;\n\n\t\tif (level == SOL_SOCKET)\n\t\t\terr =\n\t\t\t    sock_getsockopt(sock, level, optname, optval,\n\t\t\t\t\t    optlen);\n\t\telse\n\t\t\terr =\n\t\t\t    sock->ops->getsockopt(sock, level, optname, optval,\n\t\t\t\t\t\t  optlen);\nout_put:\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\n/*\n *\tShutdown a socket.\n */\n\nSYSCALL_DEFINE2(shutdown, int, fd, int, how)\n{\n\tint err, fput_needed;\n\tstruct socket *sock;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock != NULL) {\n\t\terr = security_socket_shutdown(sock, how);\n\t\tif (!err)\n\t\t\terr = sock->ops->shutdown(sock, how);\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\n/* A couple of helpful macros for getting the address of the 32/64 bit\n * fields which are the same type (int / unsigned) on our platforms.\n */\n#define COMPAT_MSG(msg, member)\t((MSG_CMSG_COMPAT & flags) ? &msg##_compat->member : &msg->member)\n#define COMPAT_NAMELEN(msg)\tCOMPAT_MSG(msg, msg_namelen)\n#define COMPAT_FLAGS(msg)\tCOMPAT_MSG(msg, msg_flags)\n\nstruct used_address {\n\tstruct sockaddr_storage name;\n\tunsigned int name_len;\n};\n\nstatic int __sys_sendmsg(struct socket *sock, struct msghdr __user *msg,\n\t\t\t struct msghdr *msg_sys, unsigned flags,\n\t\t\t struct used_address *used_address)\n{\n\tstruct compat_msghdr __user *msg_compat =\n\t    (struct compat_msghdr __user *)msg;\n\tstruct sockaddr_storage address;\n\tstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;\n\tunsigned char ctl[sizeof(struct cmsghdr) + 20]\n\t    __attribute__ ((aligned(sizeof(__kernel_size_t))));\n\t/* 20 is size of ipv6_pktinfo */\n\tunsigned char *ctl_buf = ctl;\n\tint err, ctl_len, iov_size, total_len;\n\n\terr = -EFAULT;\n\tif (MSG_CMSG_COMPAT & flags) {\n\t\tif (get_compat_msghdr(msg_sys, msg_compat))\n\t\t\treturn -EFAULT;\n\t} else if (copy_from_user(msg_sys, msg, sizeof(struct msghdr)))\n\t\treturn -EFAULT;\n\n\t/* do not move before msg_sys is valid */\n\terr = -EMSGSIZE;\n\tif (msg_sys->msg_iovlen > UIO_MAXIOV)\n\t\tgoto out;\n\n\t/* Check whether to allocate the iovec area */\n\terr = -ENOMEM;\n\tiov_size = msg_sys->msg_iovlen * sizeof(struct iovec);\n\tif (msg_sys->msg_iovlen > UIO_FASTIOV) {\n\t\tiov = sock_kmalloc(sock->sk, iov_size, GFP_KERNEL);\n\t\tif (!iov)\n\t\t\tgoto out;\n\t}\n\n\t/* This will also move the address data into kernel space */\n\tif (MSG_CMSG_COMPAT & flags) {\n\t\terr = verify_compat_iovec(msg_sys, iov,\n\t\t\t\t\t  (struct sockaddr *)&address,\n\t\t\t\t\t  VERIFY_READ);\n\t} else\n\t\terr = verify_iovec(msg_sys, iov,\n\t\t\t\t   (struct sockaddr *)&address,\n\t\t\t\t   VERIFY_READ);\n\tif (err < 0)\n\t\tgoto out_freeiov;\n\ttotal_len = err;\n\n\terr = -ENOBUFS;\n\n\tif (msg_sys->msg_controllen > INT_MAX)\n\t\tgoto out_freeiov;\n\tctl_len = msg_sys->msg_controllen;\n\tif ((MSG_CMSG_COMPAT & flags) && ctl_len) {\n\t\terr =\n\t\t    cmsghdr_from_user_compat_to_kern(msg_sys, sock->sk, ctl,\n\t\t\t\t\t\t     sizeof(ctl));\n\t\tif (err)\n\t\t\tgoto out_freeiov;\n\t\tctl_buf = msg_sys->msg_control;\n\t\tctl_len = msg_sys->msg_controllen;\n\t} else if (ctl_len) {\n\t\tif (ctl_len > sizeof(ctl)) {\n\t\t\tctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);\n\t\t\tif (ctl_buf == NULL)\n\t\t\t\tgoto out_freeiov;\n\t\t}\n\t\terr = -EFAULT;\n\t\t/*\n\t\t * Careful! Before this, msg_sys->msg_control contains a user pointer.\n\t\t * Afterwards, it will be a kernel pointer. Thus the compiler-assisted\n\t\t * checking falls down on this.\n\t\t */\n\t\tif (copy_from_user(ctl_buf,\n\t\t\t\t   (void __user __force *)msg_sys->msg_control,\n\t\t\t\t   ctl_len))\n\t\t\tgoto out_freectl;\n\t\tmsg_sys->msg_control = ctl_buf;\n\t}\n\tmsg_sys->msg_flags = flags;\n\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tmsg_sys->msg_flags |= MSG_DONTWAIT;\n\t/*\n\t * If this is sendmmsg() and current destination address is same as\n\t * previously succeeded address, omit asking LSM's decision.\n\t * used_address->name_len is initialized to UINT_MAX so that the first\n\t * destination address never matches.\n\t */\n\tif (used_address && used_address->name_len == msg_sys->msg_namelen &&\n\t    !memcmp(&used_address->name, msg->msg_name,\n\t\t    used_address->name_len)) {\n\t\terr = sock_sendmsg_nosec(sock, msg_sys, total_len);\n\t\tgoto out_freectl;\n\t}\n\terr = sock_sendmsg(sock, msg_sys, total_len);\n\t/*\n\t * If this is sendmmsg() and sending to current destination address was\n\t * successful, remember it.\n\t */\n\tif (used_address && err >= 0) {\n\t\tused_address->name_len = msg_sys->msg_namelen;\n\t\tmemcpy(&used_address->name, msg->msg_name,\n\t\t       used_address->name_len);\n\t}\n\nout_freectl:\n\tif (ctl_buf != ctl)\n\t\tsock_kfree_s(sock->sk, ctl_buf, ctl_len);\nout_freeiov:\n\tif (iov != iovstack)\n\t\tsock_kfree_s(sock->sk, iov, iov_size);\nout:\n\treturn err;\n}\n\n/*\n *\tBSD sendmsg interface\n */\n\nSYSCALL_DEFINE3(sendmsg, int, fd, struct msghdr __user *, msg, unsigned, flags)\n{\n\tint fput_needed, err;\n\tstruct msghdr msg_sys;\n\tstruct socket *sock = sockfd_lookup_light(fd, &err, &fput_needed);\n\n\tif (!sock)\n\t\tgoto out;\n\n\terr = __sys_sendmsg(sock, msg, &msg_sys, flags, NULL);\n\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\n/*\n *\tLinux sendmmsg interface\n */\n\nint __sys_sendmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,\n\t\t   unsigned int flags)\n{\n\tint fput_needed, err, datagrams;\n\tstruct socket *sock;\n\tstruct mmsghdr __user *entry;\n\tstruct compat_mmsghdr __user *compat_entry;\n\tstruct msghdr msg_sys;\n\tstruct used_address used_address;\n\n\tif (vlen > UIO_MAXIOV)\n\t\tvlen = UIO_MAXIOV;\n\n\tdatagrams = 0;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\treturn err;\n\n\tused_address.name_len = UINT_MAX;\n\tentry = mmsg;\n\tcompat_entry = (struct compat_mmsghdr __user *)mmsg;\n\terr = 0;\n\n\twhile (datagrams < vlen) {\n\t\tif (MSG_CMSG_COMPAT & flags) {\n\t\t\terr = __sys_sendmsg(sock, (struct msghdr __user *)compat_entry,\n\t\t\t\t\t    &msg_sys, flags, &used_address);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\terr = __put_user(err, &compat_entry->msg_len);\n\t\t\t++compat_entry;\n\t\t} else {\n\t\t\terr = __sys_sendmsg(sock, (struct msghdr __user *)entry,\n\t\t\t\t\t    &msg_sys, flags, &used_address);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\terr = put_user(err, &entry->msg_len);\n\t\t\t++entry;\n\t\t}\n\n\t\tif (err)\n\t\t\tbreak;\n\t\t++datagrams;\n\t}\n\n\tfput_light(sock->file, fput_needed);\n\n\t/* We only return an error if no datagrams were able to be sent */\n\tif (datagrams != 0)\n\t\treturn datagrams;\n\n\treturn err;\n}\n\nSYSCALL_DEFINE4(sendmmsg, int, fd, struct mmsghdr __user *, mmsg,\n\t\tunsigned int, vlen, unsigned int, flags)\n{\n\treturn __sys_sendmmsg(fd, mmsg, vlen, flags);\n}\n\nstatic int __sys_recvmsg(struct socket *sock, struct msghdr __user *msg,\n\t\t\t struct msghdr *msg_sys, unsigned flags, int nosec)\n{\n\tstruct compat_msghdr __user *msg_compat =\n\t    (struct compat_msghdr __user *)msg;\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tunsigned long cmsg_ptr;\n\tint err, iov_size, total_len, len;\n\n\t/* kernel mode address */\n\tstruct sockaddr_storage addr;\n\n\t/* user mode address pointers */\n\tstruct sockaddr __user *uaddr;\n\tint __user *uaddr_len;\n\n\tif (MSG_CMSG_COMPAT & flags) {\n\t\tif (get_compat_msghdr(msg_sys, msg_compat))\n\t\t\treturn -EFAULT;\n\t} else if (copy_from_user(msg_sys, msg, sizeof(struct msghdr)))\n\t\treturn -EFAULT;\n\n\terr = -EMSGSIZE;\n\tif (msg_sys->msg_iovlen > UIO_MAXIOV)\n\t\tgoto out;\n\n\t/* Check whether to allocate the iovec area */\n\terr = -ENOMEM;\n\tiov_size = msg_sys->msg_iovlen * sizeof(struct iovec);\n\tif (msg_sys->msg_iovlen > UIO_FASTIOV) {\n\t\tiov = sock_kmalloc(sock->sk, iov_size, GFP_KERNEL);\n\t\tif (!iov)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *      Save the user-mode address (verify_iovec will change the\n\t *      kernel msghdr to use the kernel address space)\n\t */\n\n\tuaddr = (__force void __user *)msg_sys->msg_name;\n\tuaddr_len = COMPAT_NAMELEN(msg);\n\tif (MSG_CMSG_COMPAT & flags) {\n\t\terr = verify_compat_iovec(msg_sys, iov,\n\t\t\t\t\t  (struct sockaddr *)&addr,\n\t\t\t\t\t  VERIFY_WRITE);\n\t} else\n\t\terr = verify_iovec(msg_sys, iov,\n\t\t\t\t   (struct sockaddr *)&addr,\n\t\t\t\t   VERIFY_WRITE);\n\tif (err < 0)\n\t\tgoto out_freeiov;\n\ttotal_len = err;\n\n\tcmsg_ptr = (unsigned long)msg_sys->msg_control;\n\tmsg_sys->msg_flags = flags & (MSG_CMSG_CLOEXEC|MSG_CMSG_COMPAT);\n\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\terr = (nosec ? sock_recvmsg_nosec : sock_recvmsg)(sock, msg_sys,\n\t\t\t\t\t\t\t  total_len, flags);\n\tif (err < 0)\n\t\tgoto out_freeiov;\n\tlen = err;\n\n\tif (uaddr != NULL) {\n\t\terr = move_addr_to_user((struct sockaddr *)&addr,\n\t\t\t\t\tmsg_sys->msg_namelen, uaddr,\n\t\t\t\t\tuaddr_len);\n\t\tif (err < 0)\n\t\t\tgoto out_freeiov;\n\t}\n\terr = __put_user((msg_sys->msg_flags & ~MSG_CMSG_COMPAT),\n\t\t\t COMPAT_FLAGS(msg));\n\tif (err)\n\t\tgoto out_freeiov;\n\tif (MSG_CMSG_COMPAT & flags)\n\t\terr = __put_user((unsigned long)msg_sys->msg_control - cmsg_ptr,\n\t\t\t\t &msg_compat->msg_controllen);\n\telse\n\t\terr = __put_user((unsigned long)msg_sys->msg_control - cmsg_ptr,\n\t\t\t\t &msg->msg_controllen);\n\tif (err)\n\t\tgoto out_freeiov;\n\terr = len;\n\nout_freeiov:\n\tif (iov != iovstack)\n\t\tsock_kfree_s(sock->sk, iov, iov_size);\nout:\n\treturn err;\n}\n\n/*\n *\tBSD recvmsg interface\n */\n\nSYSCALL_DEFINE3(recvmsg, int, fd, struct msghdr __user *, msg,\n\t\tunsigned int, flags)\n{\n\tint fput_needed, err;\n\tstruct msghdr msg_sys;\n\tstruct socket *sock = sockfd_lookup_light(fd, &err, &fput_needed);\n\n\tif (!sock)\n\t\tgoto out;\n\n\terr = __sys_recvmsg(sock, msg, &msg_sys, flags, 0);\n\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\n/*\n *     Linux recvmmsg interface\n */\n\nint __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,\n\t\t   unsigned int flags, struct timespec *timeout)\n{\n\tint fput_needed, err, datagrams;\n\tstruct socket *sock;\n\tstruct mmsghdr __user *entry;\n\tstruct compat_mmsghdr __user *compat_entry;\n\tstruct msghdr msg_sys;\n\tstruct timespec end_time;\n\n\tif (timeout &&\n\t    poll_select_set_timeout(&end_time, timeout->tv_sec,\n\t\t\t\t    timeout->tv_nsec))\n\t\treturn -EINVAL;\n\n\tdatagrams = 0;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\treturn err;\n\n\terr = sock_error(sock->sk);\n\tif (err)\n\t\tgoto out_put;\n\n\tentry = mmsg;\n\tcompat_entry = (struct compat_mmsghdr __user *)mmsg;\n\n\twhile (datagrams < vlen) {\n\t\t/*\n\t\t * No need to ask LSM for more than the first datagram.\n\t\t */\n\t\tif (MSG_CMSG_COMPAT & flags) {\n\t\t\terr = __sys_recvmsg(sock, (struct msghdr __user *)compat_entry,\n\t\t\t\t\t    &msg_sys, flags & ~MSG_WAITFORONE,\n\t\t\t\t\t    datagrams);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\terr = __put_user(err, &compat_entry->msg_len);\n\t\t\t++compat_entry;\n\t\t} else {\n\t\t\terr = __sys_recvmsg(sock, (struct msghdr __user *)entry,\n\t\t\t\t\t    &msg_sys, flags & ~MSG_WAITFORONE,\n\t\t\t\t\t    datagrams);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\terr = put_user(err, &entry->msg_len);\n\t\t\t++entry;\n\t\t}\n\n\t\tif (err)\n\t\t\tbreak;\n\t\t++datagrams;\n\n\t\t/* MSG_WAITFORONE turns on MSG_DONTWAIT after one packet */\n\t\tif (flags & MSG_WAITFORONE)\n\t\t\tflags |= MSG_DONTWAIT;\n\n\t\tif (timeout) {\n\t\t\tktime_get_ts(timeout);\n\t\t\t*timeout = timespec_sub(end_time, *timeout);\n\t\t\tif (timeout->tv_sec < 0) {\n\t\t\t\ttimeout->tv_sec = timeout->tv_nsec = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Timeout, return less than vlen datagrams */\n\t\t\tif (timeout->tv_nsec == 0 && timeout->tv_sec == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Out of band data, return right away */\n\t\tif (msg_sys.msg_flags & MSG_OOB)\n\t\t\tbreak;\n\t}\n\nout_put:\n\tfput_light(sock->file, fput_needed);\n\n\tif (err == 0)\n\t\treturn datagrams;\n\n\tif (datagrams != 0) {\n\t\t/*\n\t\t * We may return less entries than requested (vlen) if the\n\t\t * sock is non block and there aren't enough datagrams...\n\t\t */\n\t\tif (err != -EAGAIN) {\n\t\t\t/*\n\t\t\t * ... or  if recvmsg returns an error after we\n\t\t\t * received some datagrams, where we record the\n\t\t\t * error to return on the next call or if the\n\t\t\t * app asks about it using getsockopt(SO_ERROR).\n\t\t\t */\n\t\t\tsock->sk->sk_err = -err;\n\t\t}\n\n\t\treturn datagrams;\n\t}\n\n\treturn err;\n}\n\nSYSCALL_DEFINE5(recvmmsg, int, fd, struct mmsghdr __user *, mmsg,\n\t\tunsigned int, vlen, unsigned int, flags,\n\t\tstruct timespec __user *, timeout)\n{\n\tint datagrams;\n\tstruct timespec timeout_sys;\n\n\tif (!timeout)\n\t\treturn __sys_recvmmsg(fd, mmsg, vlen, flags, NULL);\n\n\tif (copy_from_user(&timeout_sys, timeout, sizeof(timeout_sys)))\n\t\treturn -EFAULT;\n\n\tdatagrams = __sys_recvmmsg(fd, mmsg, vlen, flags, &timeout_sys);\n\n\tif (datagrams > 0 &&\n\t    copy_to_user(timeout, &timeout_sys, sizeof(timeout_sys)))\n\t\tdatagrams = -EFAULT;\n\n\treturn datagrams;\n}\n\n#ifdef __ARCH_WANT_SYS_SOCKETCALL\n/* Argument list sizes for sys_socketcall */\n#define AL(x) ((x) * sizeof(unsigned long))\nstatic const unsigned char nargs[21] = {\n\tAL(0), AL(3), AL(3), AL(3), AL(2), AL(3),\n\tAL(3), AL(3), AL(4), AL(4), AL(4), AL(6),\n\tAL(6), AL(2), AL(5), AL(5), AL(3), AL(3),\n\tAL(4), AL(5), AL(4)\n};\n\n#undef AL\n\n/*\n *\tSystem call vectors.\n *\n *\tArgument checking cleaned up. Saved 20% in size.\n *  This function doesn't need to set the kernel lock because\n *  it is set by the callees.\n */\n\nSYSCALL_DEFINE2(socketcall, int, call, unsigned long __user *, args)\n{\n\tunsigned long a[6];\n\tunsigned long a0, a1;\n\tint err;\n\tunsigned int len;\n\n\tif (call < 1 || call > SYS_SENDMMSG)\n\t\treturn -EINVAL;\n\n\tlen = nargs[call];\n\tif (len > sizeof(a))\n\t\treturn -EINVAL;\n\n\t/* copy_from_user should be SMP safe. */\n\tif (copy_from_user(a, args, len))\n\t\treturn -EFAULT;\n\n\taudit_socketcall(nargs[call] / sizeof(unsigned long), a);\n\n\ta0 = a[0];\n\ta1 = a[1];\n\n\tswitch (call) {\n\tcase SYS_SOCKET:\n\t\terr = sys_socket(a0, a1, a[2]);\n\t\tbreak;\n\tcase SYS_BIND:\n\t\terr = sys_bind(a0, (struct sockaddr __user *)a1, a[2]);\n\t\tbreak;\n\tcase SYS_CONNECT:\n\t\terr = sys_connect(a0, (struct sockaddr __user *)a1, a[2]);\n\t\tbreak;\n\tcase SYS_LISTEN:\n\t\terr = sys_listen(a0, a1);\n\t\tbreak;\n\tcase SYS_ACCEPT:\n\t\terr = sys_accept4(a0, (struct sockaddr __user *)a1,\n\t\t\t\t  (int __user *)a[2], 0);\n\t\tbreak;\n\tcase SYS_GETSOCKNAME:\n\t\terr =\n\t\t    sys_getsockname(a0, (struct sockaddr __user *)a1,\n\t\t\t\t    (int __user *)a[2]);\n\t\tbreak;\n\tcase SYS_GETPEERNAME:\n\t\terr =\n\t\t    sys_getpeername(a0, (struct sockaddr __user *)a1,\n\t\t\t\t    (int __user *)a[2]);\n\t\tbreak;\n\tcase SYS_SOCKETPAIR:\n\t\terr = sys_socketpair(a0, a1, a[2], (int __user *)a[3]);\n\t\tbreak;\n\tcase SYS_SEND:\n\t\terr = sys_send(a0, (void __user *)a1, a[2], a[3]);\n\t\tbreak;\n\tcase SYS_SENDTO:\n\t\terr = sys_sendto(a0, (void __user *)a1, a[2], a[3],\n\t\t\t\t (struct sockaddr __user *)a[4], a[5]);\n\t\tbreak;\n\tcase SYS_RECV:\n\t\terr = sys_recv(a0, (void __user *)a1, a[2], a[3]);\n\t\tbreak;\n\tcase SYS_RECVFROM:\n\t\terr = sys_recvfrom(a0, (void __user *)a1, a[2], a[3],\n\t\t\t\t   (struct sockaddr __user *)a[4],\n\t\t\t\t   (int __user *)a[5]);\n\t\tbreak;\n\tcase SYS_SHUTDOWN:\n\t\terr = sys_shutdown(a0, a1);\n\t\tbreak;\n\tcase SYS_SETSOCKOPT:\n\t\terr = sys_setsockopt(a0, a1, a[2], (char __user *)a[3], a[4]);\n\t\tbreak;\n\tcase SYS_GETSOCKOPT:\n\t\terr =\n\t\t    sys_getsockopt(a0, a1, a[2], (char __user *)a[3],\n\t\t\t\t   (int __user *)a[4]);\n\t\tbreak;\n\tcase SYS_SENDMSG:\n\t\terr = sys_sendmsg(a0, (struct msghdr __user *)a1, a[2]);\n\t\tbreak;\n\tcase SYS_SENDMMSG:\n\t\terr = sys_sendmmsg(a0, (struct mmsghdr __user *)a1, a[2], a[3]);\n\t\tbreak;\n\tcase SYS_RECVMSG:\n\t\terr = sys_recvmsg(a0, (struct msghdr __user *)a1, a[2]);\n\t\tbreak;\n\tcase SYS_RECVMMSG:\n\t\terr = sys_recvmmsg(a0, (struct mmsghdr __user *)a1, a[2], a[3],\n\t\t\t\t   (struct timespec __user *)a[4]);\n\t\tbreak;\n\tcase SYS_ACCEPT4:\n\t\terr = sys_accept4(a0, (struct sockaddr __user *)a1,\n\t\t\t\t  (int __user *)a[2], a[3]);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn err;\n}\n\n#endif\t\t\t\t/* __ARCH_WANT_SYS_SOCKETCALL */\n\n/**\n *\tsock_register - add a socket protocol handler\n *\t@ops: description of protocol\n *\n *\tThis function is called by a protocol handler that wants to\n *\tadvertise its address family, and have it linked into the\n *\tsocket interface. The value ops->family coresponds to the\n *\tsocket system call protocol family.\n */\nint sock_register(const struct net_proto_family *ops)\n{\n\tint err;\n\n\tif (ops->family >= NPROTO) {\n\t\tprintk(KERN_CRIT \"protocol %d >= NPROTO(%d)\\n\", ops->family,\n\t\t       NPROTO);\n\t\treturn -ENOBUFS;\n\t}\n\n\tspin_lock(&net_family_lock);\n\tif (rcu_dereference_protected(net_families[ops->family],\n\t\t\t\t      lockdep_is_held(&net_family_lock)))\n\t\terr = -EEXIST;\n\telse {\n\t\trcu_assign_pointer(net_families[ops->family], ops);\n\t\terr = 0;\n\t}\n\tspin_unlock(&net_family_lock);\n\n\tprintk(KERN_INFO \"NET: Registered protocol family %d\\n\", ops->family);\n\treturn err;\n}\nEXPORT_SYMBOL(sock_register);\n\n/**\n *\tsock_unregister - remove a protocol handler\n *\t@family: protocol family to remove\n *\n *\tThis function is called by a protocol handler that wants to\n *\tremove its address family, and have it unlinked from the\n *\tnew socket creation.\n *\n *\tIf protocol handler is a module, then it can use module reference\n *\tcounts to protect against new references. If protocol handler is not\n *\ta module then it needs to provide its own protection in\n *\tthe ops->create routine.\n */\nvoid sock_unregister(int family)\n{\n\tBUG_ON(family < 0 || family >= NPROTO);\n\n\tspin_lock(&net_family_lock);\n\trcu_assign_pointer(net_families[family], NULL);\n\tspin_unlock(&net_family_lock);\n\n\tsynchronize_rcu();\n\n\tprintk(KERN_INFO \"NET: Unregistered protocol family %d\\n\", family);\n}\nEXPORT_SYMBOL(sock_unregister);\n\nstatic int __init sock_init(void)\n{\n\tint err;\n\n\t/*\n\t *      Initialize sock SLAB cache.\n\t */\n\n\tsk_init();\n\n\t/*\n\t *      Initialize skbuff SLAB cache\n\t */\n\tskb_init();\n\n\t/*\n\t *      Initialize the protocols module.\n\t */\n\n\tinit_inodecache();\n\n\terr = register_filesystem(&sock_fs_type);\n\tif (err)\n\t\tgoto out_fs;\n\tsock_mnt = kern_mount(&sock_fs_type);\n\tif (IS_ERR(sock_mnt)) {\n\t\terr = PTR_ERR(sock_mnt);\n\t\tgoto out_mount;\n\t}\n\n\t/* The real protocol initialization is performed in later initcalls.\n\t */\n\n#ifdef CONFIG_NETFILTER\n\tnetfilter_init();\n#endif\n\n#ifdef CONFIG_NETWORK_PHY_TIMESTAMPING\n\tskb_timestamping_init();\n#endif\n\nout:\n\treturn err;\n\nout_mount:\n\tunregister_filesystem(&sock_fs_type);\nout_fs:\n\tgoto out;\n}\n\ncore_initcall(sock_init);\t/* early initcall */\n\n#ifdef CONFIG_PROC_FS\nvoid socket_seq_show(struct seq_file *seq)\n{\n\tint cpu;\n\tint counter = 0;\n\n\tfor_each_possible_cpu(cpu)\n\t    counter += per_cpu(sockets_in_use, cpu);\n\n\t/* It can be negative, by the way. 8) */\n\tif (counter < 0)\n\t\tcounter = 0;\n\n\tseq_printf(seq, \"sockets: used %d\\n\", counter);\n}\n#endif\t\t\t\t/* CONFIG_PROC_FS */\n\n#ifdef CONFIG_COMPAT\nstatic int do_siocgstamp(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, struct compat_timeval __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timeval ktv;\n\tint err;\n\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);\n\tset_fs(old_fs);\n\tif (!err) {\n\t\terr = put_user(ktv.tv_sec, &up->tv_sec);\n\t\terr |= __put_user(ktv.tv_usec, &up->tv_usec);\n\t}\n\treturn err;\n}\n\nstatic int do_siocgstampns(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, struct compat_timespec __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timespec kts;\n\tint err;\n\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);\n\tset_fs(old_fs);\n\tif (!err) {\n\t\terr = put_user(kts.tv_sec, &up->tv_sec);\n\t\terr |= __put_user(kts.tv_nsec, &up->tv_nsec);\n\t}\n\treturn err;\n}\n\nstatic int dev_ifname32(struct net *net, struct compat_ifreq __user *uifr32)\n{\n\tstruct ifreq __user *uifr;\n\tint err;\n\n\tuifr = compat_alloc_user_space(sizeof(struct ifreq));\n\tif (copy_in_user(uifr, uifr32, sizeof(struct compat_ifreq)))\n\t\treturn -EFAULT;\n\n\terr = dev_ioctl(net, SIOCGIFNAME, uifr);\n\tif (err)\n\t\treturn err;\n\n\tif (copy_in_user(uifr32, uifr, sizeof(struct compat_ifreq)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int dev_ifconf(struct net *net, struct compat_ifconf __user *uifc32)\n{\n\tstruct compat_ifconf ifc32;\n\tstruct ifconf ifc;\n\tstruct ifconf __user *uifc;\n\tstruct compat_ifreq __user *ifr32;\n\tstruct ifreq __user *ifr;\n\tunsigned int i, j;\n\tint err;\n\n\tif (copy_from_user(&ifc32, uifc32, sizeof(struct compat_ifconf)))\n\t\treturn -EFAULT;\n\n\tif (ifc32.ifcbuf == 0) {\n\t\tifc32.ifc_len = 0;\n\t\tifc.ifc_len = 0;\n\t\tifc.ifc_req = NULL;\n\t\tuifc = compat_alloc_user_space(sizeof(struct ifconf));\n\t} else {\n\t\tsize_t len = ((ifc32.ifc_len / sizeof(struct compat_ifreq)) + 1) *\n\t\t\tsizeof(struct ifreq);\n\t\tuifc = compat_alloc_user_space(sizeof(struct ifconf) + len);\n\t\tifc.ifc_len = len;\n\t\tifr = ifc.ifc_req = (void __user *)(uifc + 1);\n\t\tifr32 = compat_ptr(ifc32.ifcbuf);\n\t\tfor (i = 0; i < ifc32.ifc_len; i += sizeof(struct compat_ifreq)) {\n\t\t\tif (copy_in_user(ifr, ifr32, sizeof(struct compat_ifreq)))\n\t\t\t\treturn -EFAULT;\n\t\t\tifr++;\n\t\t\tifr32++;\n\t\t}\n\t}\n\tif (copy_to_user(uifc, &ifc, sizeof(struct ifconf)))\n\t\treturn -EFAULT;\n\n\terr = dev_ioctl(net, SIOCGIFCONF, uifc);\n\tif (err)\n\t\treturn err;\n\n\tif (copy_from_user(&ifc, uifc, sizeof(struct ifconf)))\n\t\treturn -EFAULT;\n\n\tifr = ifc.ifc_req;\n\tifr32 = compat_ptr(ifc32.ifcbuf);\n\tfor (i = 0, j = 0;\n\t     i + sizeof(struct compat_ifreq) <= ifc32.ifc_len && j < ifc.ifc_len;\n\t     i += sizeof(struct compat_ifreq), j += sizeof(struct ifreq)) {\n\t\tif (copy_in_user(ifr32, ifr, sizeof(struct compat_ifreq)))\n\t\t\treturn -EFAULT;\n\t\tifr32++;\n\t\tifr++;\n\t}\n\n\tif (ifc32.ifcbuf == 0) {\n\t\t/* Translate from 64-bit structure multiple to\n\t\t * a 32-bit one.\n\t\t */\n\t\ti = ifc.ifc_len;\n\t\ti = ((i / sizeof(struct ifreq)) * sizeof(struct compat_ifreq));\n\t\tifc32.ifc_len = i;\n\t} else {\n\t\tifc32.ifc_len = i;\n\t}\n\tif (copy_to_user(uifc32, &ifc32, sizeof(struct compat_ifconf)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int ethtool_ioctl(struct net *net, struct compat_ifreq __user *ifr32)\n{\n\tstruct compat_ethtool_rxnfc __user *compat_rxnfc;\n\tbool convert_in = false, convert_out = false;\n\tsize_t buf_size = ALIGN(sizeof(struct ifreq), 8);\n\tstruct ethtool_rxnfc __user *rxnfc;\n\tstruct ifreq __user *ifr;\n\tu32 rule_cnt = 0, actual_rule_cnt;\n\tu32 ethcmd;\n\tu32 data;\n\tint ret;\n\n\tif (get_user(data, &ifr32->ifr_ifru.ifru_data))\n\t\treturn -EFAULT;\n\n\tcompat_rxnfc = compat_ptr(data);\n\n\tif (get_user(ethcmd, &compat_rxnfc->cmd))\n\t\treturn -EFAULT;\n\n\t/* Most ethtool structures are defined without padding.\n\t * Unfortunately struct ethtool_rxnfc is an exception.\n\t */\n\tswitch (ethcmd) {\n\tdefault:\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\t/* Buffer size is variable */\n\t\tif (get_user(rule_cnt, &compat_rxnfc->rule_cnt))\n\t\t\treturn -EFAULT;\n\t\tif (rule_cnt > KMALLOC_MAX_SIZE / sizeof(u32))\n\t\t\treturn -ENOMEM;\n\t\tbuf_size += rule_cnt * sizeof(u32);\n\t\t/* fall through */\n\tcase ETHTOOL_GRXRINGS:\n\tcase ETHTOOL_GRXCLSRLCNT:\n\tcase ETHTOOL_GRXCLSRULE:\n\t\tconvert_out = true;\n\t\t/* fall through */\n\tcase ETHTOOL_SRXCLSRLDEL:\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\tbuf_size += sizeof(struct ethtool_rxnfc);\n\t\tconvert_in = true;\n\t\tbreak;\n\t}\n\n\tifr = compat_alloc_user_space(buf_size);\n\trxnfc = (void *)ifr + ALIGN(sizeof(struct ifreq), 8);\n\n\tif (copy_in_user(&ifr->ifr_name, &ifr32->ifr_name, IFNAMSIZ))\n\t\treturn -EFAULT;\n\n\tif (put_user(convert_in ? rxnfc : compat_ptr(data),\n\t\t     &ifr->ifr_ifru.ifru_data))\n\t\treturn -EFAULT;\n\n\tif (convert_in) {\n\t\t/* We expect there to be holes between fs.m_ext and\n\t\t * fs.ring_cookie and at the end of fs, but nowhere else.\n\t\t */\n\t\tBUILD_BUG_ON(offsetof(struct compat_ethtool_rxnfc, fs.m_ext) +\n\t\t\t     sizeof(compat_rxnfc->fs.m_ext) !=\n\t\t\t     offsetof(struct ethtool_rxnfc, fs.m_ext) +\n\t\t\t     sizeof(rxnfc->fs.m_ext));\n\t\tBUILD_BUG_ON(\n\t\t\toffsetof(struct compat_ethtool_rxnfc, fs.location) -\n\t\t\toffsetof(struct compat_ethtool_rxnfc, fs.ring_cookie) !=\n\t\t\toffsetof(struct ethtool_rxnfc, fs.location) -\n\t\t\toffsetof(struct ethtool_rxnfc, fs.ring_cookie));\n\n\t\tif (copy_in_user(rxnfc, compat_rxnfc,\n\t\t\t\t (void *)(&rxnfc->fs.m_ext + 1) -\n\t\t\t\t (void *)rxnfc) ||\n\t\t    copy_in_user(&rxnfc->fs.ring_cookie,\n\t\t\t\t &compat_rxnfc->fs.ring_cookie,\n\t\t\t\t (void *)(&rxnfc->fs.location + 1) -\n\t\t\t\t (void *)&rxnfc->fs.ring_cookie) ||\n\t\t    copy_in_user(&rxnfc->rule_cnt, &compat_rxnfc->rule_cnt,\n\t\t\t\t sizeof(rxnfc->rule_cnt)))\n\t\t\treturn -EFAULT;\n\t}\n\n\tret = dev_ioctl(net, SIOCETHTOOL, ifr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (convert_out) {\n\t\tif (copy_in_user(compat_rxnfc, rxnfc,\n\t\t\t\t (const void *)(&rxnfc->fs.m_ext + 1) -\n\t\t\t\t (const void *)rxnfc) ||\n\t\t    copy_in_user(&compat_rxnfc->fs.ring_cookie,\n\t\t\t\t &rxnfc->fs.ring_cookie,\n\t\t\t\t (const void *)(&rxnfc->fs.location + 1) -\n\t\t\t\t (const void *)&rxnfc->fs.ring_cookie) ||\n\t\t    copy_in_user(&compat_rxnfc->rule_cnt, &rxnfc->rule_cnt,\n\t\t\t\t sizeof(rxnfc->rule_cnt)))\n\t\t\treturn -EFAULT;\n\n\t\tif (ethcmd == ETHTOOL_GRXCLSRLALL) {\n\t\t\t/* As an optimisation, we only copy the actual\n\t\t\t * number of rules that the underlying\n\t\t\t * function returned.  Since Mallory might\n\t\t\t * change the rule count in user memory, we\n\t\t\t * check that it is less than the rule count\n\t\t\t * originally given (as the user buffer size),\n\t\t\t * which has been range-checked.\n\t\t\t */\n\t\t\tif (get_user(actual_rule_cnt, &rxnfc->rule_cnt))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (actual_rule_cnt < rule_cnt)\n\t\t\t\trule_cnt = actual_rule_cnt;\n\t\t\tif (copy_in_user(&compat_rxnfc->rule_locs[0],\n\t\t\t\t\t &rxnfc->rule_locs[0],\n\t\t\t\t\t rule_cnt * sizeof(u32)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int compat_siocwandev(struct net *net, struct compat_ifreq __user *uifr32)\n{\n\tvoid __user *uptr;\n\tcompat_uptr_t uptr32;\n\tstruct ifreq __user *uifr;\n\n\tuifr = compat_alloc_user_space(sizeof(*uifr));\n\tif (copy_in_user(uifr, uifr32, sizeof(struct compat_ifreq)))\n\t\treturn -EFAULT;\n\n\tif (get_user(uptr32, &uifr32->ifr_settings.ifs_ifsu))\n\t\treturn -EFAULT;\n\n\tuptr = compat_ptr(uptr32);\n\n\tif (put_user(uptr, &uifr->ifr_settings.ifs_ifsu.raw_hdlc))\n\t\treturn -EFAULT;\n\n\treturn dev_ioctl(net, SIOCWANDEV, uifr);\n}\n\nstatic int bond_ioctl(struct net *net, unsigned int cmd,\n\t\t\t struct compat_ifreq __user *ifr32)\n{\n\tstruct ifreq kifr;\n\tstruct ifreq __user *uifr;\n\tmm_segment_t old_fs;\n\tint err;\n\tu32 data;\n\tvoid __user *datap;\n\n\tswitch (cmd) {\n\tcase SIOCBONDENSLAVE:\n\tcase SIOCBONDRELEASE:\n\tcase SIOCBONDSETHWADDR:\n\tcase SIOCBONDCHANGEACTIVE:\n\t\tif (copy_from_user(&kifr, ifr32, sizeof(struct compat_ifreq)))\n\t\t\treturn -EFAULT;\n\n\t\told_fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = dev_ioctl(net, cmd,\n\t\t\t\t(struct ifreq __user __force *) &kifr);\n\t\tset_fs(old_fs);\n\n\t\treturn err;\n\tcase SIOCBONDSLAVEINFOQUERY:\n\tcase SIOCBONDINFOQUERY:\n\t\tuifr = compat_alloc_user_space(sizeof(*uifr));\n\t\tif (copy_in_user(&uifr->ifr_name, &ifr32->ifr_name, IFNAMSIZ))\n\t\t\treturn -EFAULT;\n\n\t\tif (get_user(data, &ifr32->ifr_ifru.ifru_data))\n\t\t\treturn -EFAULT;\n\n\t\tdatap = compat_ptr(data);\n\t\tif (put_user(datap, &uifr->ifr_ifru.ifru_data))\n\t\t\treturn -EFAULT;\n\n\t\treturn dev_ioctl(net, cmd, uifr);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int siocdevprivate_ioctl(struct net *net, unsigned int cmd,\n\t\t\t\t struct compat_ifreq __user *u_ifreq32)\n{\n\tstruct ifreq __user *u_ifreq64;\n\tchar tmp_buf[IFNAMSIZ];\n\tvoid __user *data64;\n\tu32 data32;\n\n\tif (copy_from_user(&tmp_buf[0], &(u_ifreq32->ifr_ifrn.ifrn_name[0]),\n\t\t\t   IFNAMSIZ))\n\t\treturn -EFAULT;\n\tif (__get_user(data32, &u_ifreq32->ifr_ifru.ifru_data))\n\t\treturn -EFAULT;\n\tdata64 = compat_ptr(data32);\n\n\tu_ifreq64 = compat_alloc_user_space(sizeof(*u_ifreq64));\n\n\t/* Don't check these user accesses, just let that get trapped\n\t * in the ioctl handler instead.\n\t */\n\tif (copy_to_user(&u_ifreq64->ifr_ifrn.ifrn_name[0], &tmp_buf[0],\n\t\t\t IFNAMSIZ))\n\t\treturn -EFAULT;\n\tif (__put_user(data64, &u_ifreq64->ifr_ifru.ifru_data))\n\t\treturn -EFAULT;\n\n\treturn dev_ioctl(net, cmd, u_ifreq64);\n}\n\nstatic int dev_ifsioc(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, struct compat_ifreq __user *uifr32)\n{\n\tstruct ifreq __user *uifr;\n\tint err;\n\n\tuifr = compat_alloc_user_space(sizeof(*uifr));\n\tif (copy_in_user(uifr, uifr32, sizeof(*uifr32)))\n\t\treturn -EFAULT;\n\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)uifr);\n\n\tif (!err) {\n\t\tswitch (cmd) {\n\t\tcase SIOCGIFFLAGS:\n\t\tcase SIOCGIFMETRIC:\n\t\tcase SIOCGIFMTU:\n\t\tcase SIOCGIFMEM:\n\t\tcase SIOCGIFHWADDR:\n\t\tcase SIOCGIFINDEX:\n\t\tcase SIOCGIFADDR:\n\t\tcase SIOCGIFBRDADDR:\n\t\tcase SIOCGIFDSTADDR:\n\t\tcase SIOCGIFNETMASK:\n\t\tcase SIOCGIFPFLAGS:\n\t\tcase SIOCGIFTXQLEN:\n\t\tcase SIOCGMIIPHY:\n\t\tcase SIOCGMIIREG:\n\t\t\tif (copy_in_user(uifr32, uifr, sizeof(*uifr32)))\n\t\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic int compat_sioc_ifmap(struct net *net, unsigned int cmd,\n\t\t\tstruct compat_ifreq __user *uifr32)\n{\n\tstruct ifreq ifr;\n\tstruct compat_ifmap __user *uifmap32;\n\tmm_segment_t old_fs;\n\tint err;\n\n\tuifmap32 = &uifr32->ifr_ifru.ifru_map;\n\terr = copy_from_user(&ifr, uifr32, sizeof(ifr.ifr_name));\n\terr |= __get_user(ifr.ifr_map.mem_start, &uifmap32->mem_start);\n\terr |= __get_user(ifr.ifr_map.mem_end, &uifmap32->mem_end);\n\terr |= __get_user(ifr.ifr_map.base_addr, &uifmap32->base_addr);\n\terr |= __get_user(ifr.ifr_map.irq, &uifmap32->irq);\n\terr |= __get_user(ifr.ifr_map.dma, &uifmap32->dma);\n\terr |= __get_user(ifr.ifr_map.port, &uifmap32->port);\n\tif (err)\n\t\treturn -EFAULT;\n\n\told_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\terr = dev_ioctl(net, cmd, (void  __user __force *)&ifr);\n\tset_fs(old_fs);\n\n\tif (cmd == SIOCGIFMAP && !err) {\n\t\terr = copy_to_user(uifr32, &ifr, sizeof(ifr.ifr_name));\n\t\terr |= __put_user(ifr.ifr_map.mem_start, &uifmap32->mem_start);\n\t\terr |= __put_user(ifr.ifr_map.mem_end, &uifmap32->mem_end);\n\t\terr |= __put_user(ifr.ifr_map.base_addr, &uifmap32->base_addr);\n\t\terr |= __put_user(ifr.ifr_map.irq, &uifmap32->irq);\n\t\terr |= __put_user(ifr.ifr_map.dma, &uifmap32->dma);\n\t\terr |= __put_user(ifr.ifr_map.port, &uifmap32->port);\n\t\tif (err)\n\t\t\terr = -EFAULT;\n\t}\n\treturn err;\n}\n\nstatic int compat_siocshwtstamp(struct net *net, struct compat_ifreq __user *uifr32)\n{\n\tvoid __user *uptr;\n\tcompat_uptr_t uptr32;\n\tstruct ifreq __user *uifr;\n\n\tuifr = compat_alloc_user_space(sizeof(*uifr));\n\tif (copy_in_user(uifr, uifr32, sizeof(struct compat_ifreq)))\n\t\treturn -EFAULT;\n\n\tif (get_user(uptr32, &uifr32->ifr_data))\n\t\treturn -EFAULT;\n\n\tuptr = compat_ptr(uptr32);\n\n\tif (put_user(uptr, &uifr->ifr_data))\n\t\treturn -EFAULT;\n\n\treturn dev_ioctl(net, SIOCSHWTSTAMP, uifr);\n}\n\nstruct rtentry32 {\n\tu32\t\trt_pad1;\n\tstruct sockaddr rt_dst;         /* target address               */\n\tstruct sockaddr rt_gateway;     /* gateway addr (RTF_GATEWAY)   */\n\tstruct sockaddr rt_genmask;     /* target network mask (IP)     */\n\tunsigned short\trt_flags;\n\tshort\t\trt_pad2;\n\tu32\t\trt_pad3;\n\tunsigned char\trt_tos;\n\tunsigned char\trt_class;\n\tshort\t\trt_pad4;\n\tshort\t\trt_metric;      /* +1 for binary compatibility! */\n\t/* char * */ u32 rt_dev;        /* forcing the device at add    */\n\tu32\t\trt_mtu;         /* per route MTU/Window         */\n\tu32\t\trt_window;      /* Window clamping              */\n\tunsigned short  rt_irtt;        /* Initial RTT                  */\n};\n\nstruct in6_rtmsg32 {\n\tstruct in6_addr\t\trtmsg_dst;\n\tstruct in6_addr\t\trtmsg_src;\n\tstruct in6_addr\t\trtmsg_gateway;\n\tu32\t\t\trtmsg_type;\n\tu16\t\t\trtmsg_dst_len;\n\tu16\t\t\trtmsg_src_len;\n\tu32\t\t\trtmsg_metric;\n\tu32\t\t\trtmsg_info;\n\tu32\t\t\trtmsg_flags;\n\ts32\t\t\trtmsg_ifindex;\n};\n\nstatic int routing_ioctl(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, void __user *argp)\n{\n\tint ret;\n\tvoid *r = NULL;\n\tstruct in6_rtmsg r6;\n\tstruct rtentry r4;\n\tchar devname[16];\n\tu32 rtdev;\n\tmm_segment_t old_fs = get_fs();\n\n\tif (sock && sock->sk && sock->sk->sk_family == AF_INET6) { /* ipv6 */\n\t\tstruct in6_rtmsg32 __user *ur6 = argp;\n\t\tret = copy_from_user(&r6.rtmsg_dst, &(ur6->rtmsg_dst),\n\t\t\t3 * sizeof(struct in6_addr));\n\t\tret |= __get_user(r6.rtmsg_type, &(ur6->rtmsg_type));\n\t\tret |= __get_user(r6.rtmsg_dst_len, &(ur6->rtmsg_dst_len));\n\t\tret |= __get_user(r6.rtmsg_src_len, &(ur6->rtmsg_src_len));\n\t\tret |= __get_user(r6.rtmsg_metric, &(ur6->rtmsg_metric));\n\t\tret |= __get_user(r6.rtmsg_info, &(ur6->rtmsg_info));\n\t\tret |= __get_user(r6.rtmsg_flags, &(ur6->rtmsg_flags));\n\t\tret |= __get_user(r6.rtmsg_ifindex, &(ur6->rtmsg_ifindex));\n\n\t\tr = (void *) &r6;\n\t} else { /* ipv4 */\n\t\tstruct rtentry32 __user *ur4 = argp;\n\t\tret = copy_from_user(&r4.rt_dst, &(ur4->rt_dst),\n\t\t\t\t\t3 * sizeof(struct sockaddr));\n\t\tret |= __get_user(r4.rt_flags, &(ur4->rt_flags));\n\t\tret |= __get_user(r4.rt_metric, &(ur4->rt_metric));\n\t\tret |= __get_user(r4.rt_mtu, &(ur4->rt_mtu));\n\t\tret |= __get_user(r4.rt_window, &(ur4->rt_window));\n\t\tret |= __get_user(r4.rt_irtt, &(ur4->rt_irtt));\n\t\tret |= __get_user(rtdev, &(ur4->rt_dev));\n\t\tif (rtdev) {\n\t\t\tret |= copy_from_user(devname, compat_ptr(rtdev), 15);\n\t\t\tr4.rt_dev = (char __user __force *)devname;\n\t\t\tdevname[15] = 0;\n\t\t} else\n\t\t\tr4.rt_dev = NULL;\n\n\t\tr = (void *) &r4;\n\t}\n\n\tif (ret) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tset_fs(KERNEL_DS);\n\tret = sock_do_ioctl(net, sock, cmd, (unsigned long) r);\n\tset_fs(old_fs);\n\nout:\n\treturn ret;\n}\n\n/* Since old style bridge ioctl's endup using SIOCDEVPRIVATE\n * for some operations; this forces use of the newer bridge-utils that\n * use compatible ioctls\n */\nstatic int old_bridge_ioctl(compat_ulong_t __user *argp)\n{\n\tcompat_ulong_t tmp;\n\n\tif (get_user(tmp, argp))\n\t\treturn -EFAULT;\n\tif (tmp == BRCTL_GET_VERSION)\n\t\treturn BRCTL_VERSION + 1;\n\treturn -EINVAL;\n}\n\nstatic int compat_sock_ioctl_trans(struct file *file, struct socket *sock,\n\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = compat_ptr(arg);\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\n\tif (cmd >= SIOCDEVPRIVATE && cmd <= (SIOCDEVPRIVATE + 15))\n\t\treturn siocdevprivate_ioctl(net, cmd, argp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFBR:\n\tcase SIOCGIFBR:\n\t\treturn old_bridge_ioctl(argp);\n\tcase SIOCGIFNAME:\n\t\treturn dev_ifname32(net, argp);\n\tcase SIOCGIFCONF:\n\t\treturn dev_ifconf(net, argp);\n\tcase SIOCETHTOOL:\n\t\treturn ethtool_ioctl(net, argp);\n\tcase SIOCWANDEV:\n\t\treturn compat_siocwandev(net, argp);\n\tcase SIOCGIFMAP:\n\tcase SIOCSIFMAP:\n\t\treturn compat_sioc_ifmap(net, cmd, argp);\n\tcase SIOCBONDENSLAVE:\n\tcase SIOCBONDRELEASE:\n\tcase SIOCBONDSETHWADDR:\n\tcase SIOCBONDSLAVEINFOQUERY:\n\tcase SIOCBONDINFOQUERY:\n\tcase SIOCBONDCHANGEACTIVE:\n\t\treturn bond_ioctl(net, cmd, argp);\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\treturn routing_ioctl(net, sock, cmd, argp);\n\tcase SIOCGSTAMP:\n\t\treturn do_siocgstamp(net, sock, cmd, argp);\n\tcase SIOCGSTAMPNS:\n\t\treturn do_siocgstampns(net, sock, cmd, argp);\n\tcase SIOCSHWTSTAMP:\n\t\treturn compat_siocshwtstamp(net, argp);\n\n\tcase FIOSETOWN:\n\tcase SIOCSPGRP:\n\tcase FIOGETOWN:\n\tcase SIOCGPGRP:\n\tcase SIOCBRADDBR:\n\tcase SIOCBRDELBR:\n\tcase SIOCGIFVLAN:\n\tcase SIOCSIFVLAN:\n\tcase SIOCADDDLCI:\n\tcase SIOCDELDLCI:\n\t\treturn sock_ioctl(file, cmd, arg);\n\n\tcase SIOCGIFFLAGS:\n\tcase SIOCSIFFLAGS:\n\tcase SIOCGIFMETRIC:\n\tcase SIOCSIFMETRIC:\n\tcase SIOCGIFMTU:\n\tcase SIOCSIFMTU:\n\tcase SIOCGIFMEM:\n\tcase SIOCSIFMEM:\n\tcase SIOCGIFHWADDR:\n\tcase SIOCSIFHWADDR:\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\tcase SIOCGIFINDEX:\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCSIFHWBROADCAST:\n\tcase SIOCDIFADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCSIFBRDADDR:\n\tcase SIOCGIFDSTADDR:\n\tcase SIOCSIFDSTADDR:\n\tcase SIOCGIFNETMASK:\n\tcase SIOCSIFNETMASK:\n\tcase SIOCSIFPFLAGS:\n\tcase SIOCGIFPFLAGS:\n\tcase SIOCGIFTXQLEN:\n\tcase SIOCSIFTXQLEN:\n\tcase SIOCBRADDIF:\n\tcase SIOCBRDELIF:\n\tcase SIOCSIFNAME:\n\tcase SIOCGMIIPHY:\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\t\treturn dev_ifsioc(net, sock, cmd, argp);\n\n\tcase SIOCSARP:\n\tcase SIOCGARP:\n\tcase SIOCDARP:\n\tcase SIOCATMARK:\n\t\treturn sock_do_ioctl(net, sock, cmd, arg);\n\t}\n\n\t/* Prevent warning from compat_sys_ioctl, these always\n\t * result in -EINVAL in the native case anyway. */\n\tswitch (cmd) {\n\tcase SIOCRTMSG:\n\tcase SIOCGIFCOUNT:\n\tcase SIOCSRARP:\n\tcase SIOCGRARP:\n\tcase SIOCDRARP:\n\tcase SIOCSIFLINK:\n\tcase SIOCGIFSLAVE:\n\tcase SIOCSIFSLAVE:\n\t\treturn -EINVAL;\n\t}\n\n\treturn -ENOIOCTLCMD;\n}\n\nstatic long compat_sock_ioctl(struct file *file, unsigned cmd,\n\t\t\t      unsigned long arg)\n{\n\tstruct socket *sock = file->private_data;\n\tint ret = -ENOIOCTLCMD;\n\tstruct sock *sk;\n\tstruct net *net;\n\n\tsk = sock->sk;\n\tnet = sock_net(sk);\n\n\tif (sock->ops->compat_ioctl)\n\t\tret = sock->ops->compat_ioctl(sock, cmd, arg);\n\n\tif (ret == -ENOIOCTLCMD &&\n\t    (cmd >= SIOCIWFIRST && cmd <= SIOCIWLAST))\n\t\tret = compat_wext_handle_ioctl(net, cmd, arg);\n\n\tif (ret == -ENOIOCTLCMD)\n\t\tret = compat_sock_ioctl_trans(file, sock, cmd, arg);\n\n\treturn ret;\n}\n#endif\n\nint kernel_bind(struct socket *sock, struct sockaddr *addr, int addrlen)\n{\n\treturn sock->ops->bind(sock, addr, addrlen);\n}\nEXPORT_SYMBOL(kernel_bind);\n\nint kernel_listen(struct socket *sock, int backlog)\n{\n\treturn sock->ops->listen(sock, backlog);\n}\nEXPORT_SYMBOL(kernel_listen);\n\nint kernel_accept(struct socket *sock, struct socket **newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\n\terr = sock_create_lite(sk->sk_family, sk->sk_type, sk->sk_protocol,\n\t\t\t       newsock);\n\tif (err < 0)\n\t\tgoto done;\n\n\terr = sock->ops->accept(sock, *newsock, flags);\n\tif (err < 0) {\n\t\tsock_release(*newsock);\n\t\t*newsock = NULL;\n\t\tgoto done;\n\t}\n\n\t(*newsock)->ops = sock->ops;\n\t__module_get((*newsock)->ops->owner);\n\ndone:\n\treturn err;\n}\nEXPORT_SYMBOL(kernel_accept);\n\nint kernel_connect(struct socket *sock, struct sockaddr *addr, int addrlen,\n\t\t   int flags)\n{\n\treturn sock->ops->connect(sock, addr, addrlen, flags);\n}\nEXPORT_SYMBOL(kernel_connect);\n\nint kernel_getsockname(struct socket *sock, struct sockaddr *addr,\n\t\t\t int *addrlen)\n{\n\treturn sock->ops->getname(sock, addr, addrlen, 0);\n}\nEXPORT_SYMBOL(kernel_getsockname);\n\nint kernel_getpeername(struct socket *sock, struct sockaddr *addr,\n\t\t\t int *addrlen)\n{\n\treturn sock->ops->getname(sock, addr, addrlen, 1);\n}\nEXPORT_SYMBOL(kernel_getpeername);\n\nint kernel_getsockopt(struct socket *sock, int level, int optname,\n\t\t\tchar *optval, int *optlen)\n{\n\tmm_segment_t oldfs = get_fs();\n\tchar __user *uoptval;\n\tint __user *uoptlen;\n\tint err;\n\n\tuoptval = (char __user __force *) optval;\n\tuoptlen = (int __user __force *) optlen;\n\n\tset_fs(KERNEL_DS);\n\tif (level == SOL_SOCKET)\n\t\terr = sock_getsockopt(sock, level, optname, uoptval, uoptlen);\n\telse\n\t\terr = sock->ops->getsockopt(sock, level, optname, uoptval,\n\t\t\t\t\t    uoptlen);\n\tset_fs(oldfs);\n\treturn err;\n}\nEXPORT_SYMBOL(kernel_getsockopt);\n\nint kernel_setsockopt(struct socket *sock, int level, int optname,\n\t\t\tchar *optval, unsigned int optlen)\n{\n\tmm_segment_t oldfs = get_fs();\n\tchar __user *uoptval;\n\tint err;\n\n\tuoptval = (char __user __force *) optval;\n\n\tset_fs(KERNEL_DS);\n\tif (level == SOL_SOCKET)\n\t\terr = sock_setsockopt(sock, level, optname, uoptval, optlen);\n\telse\n\t\terr = sock->ops->setsockopt(sock, level, optname, uoptval,\n\t\t\t\t\t    optlen);\n\tset_fs(oldfs);\n\treturn err;\n}\nEXPORT_SYMBOL(kernel_setsockopt);\n\nint kernel_sendpage(struct socket *sock, struct page *page, int offset,\n\t\t    size_t size, int flags)\n{\n\tsock_update_classid(sock->sk);\n\n\tif (sock->ops->sendpage)\n\t\treturn sock->ops->sendpage(sock, page, offset, size, flags);\n\n\treturn sock_no_sendpage(sock, page, offset, size, flags);\n}\nEXPORT_SYMBOL(kernel_sendpage);\n\nint kernel_sock_ioctl(struct socket *sock, int cmd, unsigned long arg)\n{\n\tmm_segment_t oldfs = get_fs();\n\tint err;\n\n\tset_fs(KERNEL_DS);\n\terr = sock->ops->ioctl(sock, cmd, arg);\n\tset_fs(oldfs);\n\n\treturn err;\n}\nEXPORT_SYMBOL(kernel_sock_ioctl);\n\nint kernel_sock_shutdown(struct socket *sock, enum sock_shutdown_cmd how)\n{\n\treturn sock->ops->shutdown(sock, how);\n}\nEXPORT_SYMBOL(kernel_sock_shutdown);\n"], "fixing_code": ["/*\n * NET\t\tAn implementation of the SOCKET network access protocol.\n *\n * Version:\t@(#)socket.c\t1.1.93\t18/02/95\n *\n * Authors:\tOrest Zborowski, <obz@Kodak.COM>\n *\t\tRoss Biro\n *\t\tFred N. van Kempen, <waltje@uWalt.NL.Mugnet.ORG>\n *\n * Fixes:\n *\t\tAnonymous\t:\tNOTSOCK/BADF cleanup. Error fix in\n *\t\t\t\t\tshutdown()\n *\t\tAlan Cox\t:\tverify_area() fixes\n *\t\tAlan Cox\t:\tRemoved DDI\n *\t\tJonathan Kamens\t:\tSOCK_DGRAM reconnect bug\n *\t\tAlan Cox\t:\tMoved a load of checks to the very\n *\t\t\t\t\ttop level.\n *\t\tAlan Cox\t:\tMove address structures to/from user\n *\t\t\t\t\tmode above the protocol layers.\n *\t\tRob Janssen\t:\tAllow 0 length sends.\n *\t\tAlan Cox\t:\tAsynchronous I/O support (cribbed from the\n *\t\t\t\t\ttty drivers).\n *\t\tNiibe Yutaka\t:\tAsynchronous I/O for writes (4.4BSD style)\n *\t\tJeff Uphoff\t:\tMade max number of sockets command-line\n *\t\t\t\t\tconfigurable.\n *\t\tMatti Aarnio\t:\tMade the number of sockets dynamic,\n *\t\t\t\t\tto be allocated when needed, and mr.\n *\t\t\t\t\tUphoff's max is used as max to be\n *\t\t\t\t\tallowed to allocate.\n *\t\tLinus\t\t:\tArgh. removed all the socket allocation\n *\t\t\t\t\taltogether: it's in the inode now.\n *\t\tAlan Cox\t:\tMade sock_alloc()/sock_release() public\n *\t\t\t\t\tfor NetROM and future kernel nfsd type\n *\t\t\t\t\tstuff.\n *\t\tAlan Cox\t:\tsendmsg/recvmsg basics.\n *\t\tTom Dyas\t:\tExport net symbols.\n *\t\tMarcin Dalecki\t:\tFixed problems with CONFIG_NET=\"n\".\n *\t\tAlan Cox\t:\tAdded thread locking to sys_* calls\n *\t\t\t\t\tfor sockets. May have errors at the\n *\t\t\t\t\tmoment.\n *\t\tKevin Buhr\t:\tFixed the dumb errors in the above.\n *\t\tAndi Kleen\t:\tSome small cleanups, optimizations,\n *\t\t\t\t\tand fixed a copy_from_user() bug.\n *\t\tTigran Aivazian\t:\tsys_send(args) calls sys_sendto(args, NULL, 0)\n *\t\tTigran Aivazian\t:\tMade listen(2) backlog sanity checks\n *\t\t\t\t\tprotocol-independent\n *\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n *\n *\tThis module is effectively the top level interface to the BSD socket\n *\tparadigm.\n *\n *\tBased upon Swansea University Computer Society NET3.039\n */\n\n#include <linux/mm.h>\n#include <linux/socket.h>\n#include <linux/file.h>\n#include <linux/net.h>\n#include <linux/interrupt.h>\n#include <linux/thread_info.h>\n#include <linux/rcupdate.h>\n#include <linux/netdevice.h>\n#include <linux/proc_fs.h>\n#include <linux/seq_file.h>\n#include <linux/mutex.h>\n#include <linux/wanrouter.h>\n#include <linux/if_bridge.h>\n#include <linux/if_frad.h>\n#include <linux/if_vlan.h>\n#include <linux/init.h>\n#include <linux/poll.h>\n#include <linux/cache.h>\n#include <linux/module.h>\n#include <linux/highmem.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/compat.h>\n#include <linux/kmod.h>\n#include <linux/audit.h>\n#include <linux/wireless.h>\n#include <linux/nsproxy.h>\n#include <linux/magic.h>\n#include <linux/slab.h>\n\n#include <asm/uaccess.h>\n#include <asm/unistd.h>\n\n#include <net/compat.h>\n#include <net/wext.h>\n#include <net/cls_cgroup.h>\n\n#include <net/sock.h>\n#include <linux/netfilter.h>\n\n#include <linux/if_tun.h>\n#include <linux/ipv6_route.h>\n#include <linux/route.h>\n#include <linux/sockios.h>\n#include <linux/atalk.h>\n\nstatic int sock_no_open(struct inode *irrelevant, struct file *dontcare);\nstatic ssize_t sock_aio_read(struct kiocb *iocb, const struct iovec *iov,\n\t\t\t unsigned long nr_segs, loff_t pos);\nstatic ssize_t sock_aio_write(struct kiocb *iocb, const struct iovec *iov,\n\t\t\t  unsigned long nr_segs, loff_t pos);\nstatic int sock_mmap(struct file *file, struct vm_area_struct *vma);\n\nstatic int sock_close(struct inode *inode, struct file *file);\nstatic unsigned int sock_poll(struct file *file,\n\t\t\t      struct poll_table_struct *wait);\nstatic long sock_ioctl(struct file *file, unsigned int cmd, unsigned long arg);\n#ifdef CONFIG_COMPAT\nstatic long compat_sock_ioctl(struct file *file,\n\t\t\t      unsigned int cmd, unsigned long arg);\n#endif\nstatic int sock_fasync(int fd, struct file *filp, int on);\nstatic ssize_t sock_sendpage(struct file *file, struct page *page,\n\t\t\t     int offset, size_t size, loff_t *ppos, int more);\nstatic ssize_t sock_splice_read(struct file *file, loff_t *ppos,\n\t\t\t\tstruct pipe_inode_info *pipe, size_t len,\n\t\t\t\tunsigned int flags);\n\n/*\n *\tSocket files have a set of 'special' operations as well as the generic file ones. These don't appear\n *\tin the operation structures but are done directly via the socketcall() multiplexor.\n */\n\nstatic const struct file_operations socket_file_ops = {\n\t.owner =\tTHIS_MODULE,\n\t.llseek =\tno_llseek,\n\t.aio_read =\tsock_aio_read,\n\t.aio_write =\tsock_aio_write,\n\t.poll =\t\tsock_poll,\n\t.unlocked_ioctl = sock_ioctl,\n#ifdef CONFIG_COMPAT\n\t.compat_ioctl = compat_sock_ioctl,\n#endif\n\t.mmap =\t\tsock_mmap,\n\t.open =\t\tsock_no_open,\t/* special open code to disallow open via /proc */\n\t.release =\tsock_close,\n\t.fasync =\tsock_fasync,\n\t.sendpage =\tsock_sendpage,\n\t.splice_write = generic_splice_sendpage,\n\t.splice_read =\tsock_splice_read,\n};\n\n/*\n *\tThe protocol list. Each protocol is registered in here.\n */\n\nstatic DEFINE_SPINLOCK(net_family_lock);\nstatic const struct net_proto_family __rcu *net_families[NPROTO] __read_mostly;\n\n/*\n *\tStatistics counters of the socket lists\n */\n\nstatic DEFINE_PER_CPU(int, sockets_in_use);\n\n/*\n * Support routines.\n * Move socket addresses back and forth across the kernel/user\n * divide and look after the messy bits.\n */\n\n/**\n *\tmove_addr_to_kernel\t-\tcopy a socket address into kernel space\n *\t@uaddr: Address in user space\n *\t@kaddr: Address in kernel space\n *\t@ulen: Length in user space\n *\n *\tThe address is copied into kernel space. If the provided address is\n *\ttoo long an error code of -EINVAL is returned. If the copy gives\n *\tinvalid addresses -EFAULT is returned. On a success 0 is returned.\n */\n\nint move_addr_to_kernel(void __user *uaddr, int ulen, struct sockaddr *kaddr)\n{\n\tif (ulen < 0 || ulen > sizeof(struct sockaddr_storage))\n\t\treturn -EINVAL;\n\tif (ulen == 0)\n\t\treturn 0;\n\tif (copy_from_user(kaddr, uaddr, ulen))\n\t\treturn -EFAULT;\n\treturn audit_sockaddr(ulen, kaddr);\n}\n\n/**\n *\tmove_addr_to_user\t-\tcopy an address to user space\n *\t@kaddr: kernel space address\n *\t@klen: length of address in kernel\n *\t@uaddr: user space address\n *\t@ulen: pointer to user length field\n *\n *\tThe value pointed to by ulen on entry is the buffer length available.\n *\tThis is overwritten with the buffer space used. -EINVAL is returned\n *\tif an overlong buffer is specified or a negative buffer size. -EFAULT\n *\tis returned if either the buffer or the length field are not\n *\taccessible.\n *\tAfter copying the data up to the limit the user specifies, the true\n *\tlength of the data is written over the length limit the user\n *\tspecified. Zero is returned for a success.\n */\n\nstatic int move_addr_to_user(struct sockaddr *kaddr, int klen,\n\t\t\t     void __user *uaddr, int __user *ulen)\n{\n\tint err;\n\tint len;\n\n\terr = get_user(len, ulen);\n\tif (err)\n\t\treturn err;\n\tif (len > klen)\n\t\tlen = klen;\n\tif (len < 0 || len > sizeof(struct sockaddr_storage))\n\t\treturn -EINVAL;\n\tif (len) {\n\t\tif (audit_sockaddr(klen, kaddr))\n\t\t\treturn -ENOMEM;\n\t\tif (copy_to_user(uaddr, kaddr, len))\n\t\t\treturn -EFAULT;\n\t}\n\t/*\n\t *      \"fromlen shall refer to the value before truncation..\"\n\t *                      1003.1g\n\t */\n\treturn __put_user(klen, ulen);\n}\n\nstatic struct kmem_cache *sock_inode_cachep __read_mostly;\n\nstatic struct inode *sock_alloc_inode(struct super_block *sb)\n{\n\tstruct socket_alloc *ei;\n\tstruct socket_wq *wq;\n\n\tei = kmem_cache_alloc(sock_inode_cachep, GFP_KERNEL);\n\tif (!ei)\n\t\treturn NULL;\n\twq = kmalloc(sizeof(*wq), GFP_KERNEL);\n\tif (!wq) {\n\t\tkmem_cache_free(sock_inode_cachep, ei);\n\t\treturn NULL;\n\t}\n\tinit_waitqueue_head(&wq->wait);\n\twq->fasync_list = NULL;\n\tRCU_INIT_POINTER(ei->socket.wq, wq);\n\n\tei->socket.state = SS_UNCONNECTED;\n\tei->socket.flags = 0;\n\tei->socket.ops = NULL;\n\tei->socket.sk = NULL;\n\tei->socket.file = NULL;\n\n\treturn &ei->vfs_inode;\n}\n\nstatic void sock_destroy_inode(struct inode *inode)\n{\n\tstruct socket_alloc *ei;\n\tstruct socket_wq *wq;\n\n\tei = container_of(inode, struct socket_alloc, vfs_inode);\n\twq = rcu_dereference_protected(ei->socket.wq, 1);\n\tkfree_rcu(wq, rcu);\n\tkmem_cache_free(sock_inode_cachep, ei);\n}\n\nstatic void init_once(void *foo)\n{\n\tstruct socket_alloc *ei = (struct socket_alloc *)foo;\n\n\tinode_init_once(&ei->vfs_inode);\n}\n\nstatic int init_inodecache(void)\n{\n\tsock_inode_cachep = kmem_cache_create(\"sock_inode_cache\",\n\t\t\t\t\t      sizeof(struct socket_alloc),\n\t\t\t\t\t      0,\n\t\t\t\t\t      (SLAB_HWCACHE_ALIGN |\n\t\t\t\t\t       SLAB_RECLAIM_ACCOUNT |\n\t\t\t\t\t       SLAB_MEM_SPREAD),\n\t\t\t\t\t      init_once);\n\tif (sock_inode_cachep == NULL)\n\t\treturn -ENOMEM;\n\treturn 0;\n}\n\nstatic const struct super_operations sockfs_ops = {\n\t.alloc_inode\t= sock_alloc_inode,\n\t.destroy_inode\t= sock_destroy_inode,\n\t.statfs\t\t= simple_statfs,\n};\n\n/*\n * sockfs_dname() is called from d_path().\n */\nstatic char *sockfs_dname(struct dentry *dentry, char *buffer, int buflen)\n{\n\treturn dynamic_dname(dentry, buffer, buflen, \"socket:[%lu]\",\n\t\t\t\tdentry->d_inode->i_ino);\n}\n\nstatic const struct dentry_operations sockfs_dentry_operations = {\n\t.d_dname  = sockfs_dname,\n};\n\nstatic struct dentry *sockfs_mount(struct file_system_type *fs_type,\n\t\t\t int flags, const char *dev_name, void *data)\n{\n\treturn mount_pseudo(fs_type, \"socket:\", &sockfs_ops,\n\t\t&sockfs_dentry_operations, SOCKFS_MAGIC);\n}\n\nstatic struct vfsmount *sock_mnt __read_mostly;\n\nstatic struct file_system_type sock_fs_type = {\n\t.name =\t\t\"sockfs\",\n\t.mount =\tsockfs_mount,\n\t.kill_sb =\tkill_anon_super,\n};\n\n/*\n *\tObtains the first available file descriptor and sets it up for use.\n *\n *\tThese functions create file structures and maps them to fd space\n *\tof the current process. On success it returns file descriptor\n *\tand file struct implicitly stored in sock->file.\n *\tNote that another thread may close file descriptor before we return\n *\tfrom this function. We use the fact that now we do not refer\n *\tto socket after mapping. If one day we will need it, this\n *\tfunction will increment ref. count on file by 1.\n *\n *\tIn any case returned fd MAY BE not valid!\n *\tThis race condition is unavoidable\n *\twith shared fd spaces, we cannot solve it inside kernel,\n *\tbut we take care of internal coherence yet.\n */\n\nstatic int sock_alloc_file(struct socket *sock, struct file **f, int flags)\n{\n\tstruct qstr name = { .name = \"\" };\n\tstruct path path;\n\tstruct file *file;\n\tint fd;\n\n\tfd = get_unused_fd_flags(flags);\n\tif (unlikely(fd < 0))\n\t\treturn fd;\n\n\tpath.dentry = d_alloc_pseudo(sock_mnt->mnt_sb, &name);\n\tif (unlikely(!path.dentry)) {\n\t\tput_unused_fd(fd);\n\t\treturn -ENOMEM;\n\t}\n\tpath.mnt = mntget(sock_mnt);\n\n\td_instantiate(path.dentry, SOCK_INODE(sock));\n\tSOCK_INODE(sock)->i_fop = &socket_file_ops;\n\n\tfile = alloc_file(&path, FMODE_READ | FMODE_WRITE,\n\t\t  &socket_file_ops);\n\tif (unlikely(!file)) {\n\t\t/* drop dentry, keep inode */\n\t\tihold(path.dentry->d_inode);\n\t\tpath_put(&path);\n\t\tput_unused_fd(fd);\n\t\treturn -ENFILE;\n\t}\n\n\tsock->file = file;\n\tfile->f_flags = O_RDWR | (flags & O_NONBLOCK);\n\tfile->f_pos = 0;\n\tfile->private_data = sock;\n\n\t*f = file;\n\treturn fd;\n}\n\nint sock_map_fd(struct socket *sock, int flags)\n{\n\tstruct file *newfile;\n\tint fd = sock_alloc_file(sock, &newfile, flags);\n\n\tif (likely(fd >= 0))\n\t\tfd_install(fd, newfile);\n\n\treturn fd;\n}\nEXPORT_SYMBOL(sock_map_fd);\n\nstatic struct socket *sock_from_file(struct file *file, int *err)\n{\n\tif (file->f_op == &socket_file_ops)\n\t\treturn file->private_data;\t/* set in sock_map_fd */\n\n\t*err = -ENOTSOCK;\n\treturn NULL;\n}\n\n/**\n *\tsockfd_lookup - Go from a file number to its socket slot\n *\t@fd: file handle\n *\t@err: pointer to an error code return\n *\n *\tThe file handle passed in is locked and the socket it is bound\n *\ttoo is returned. If an error occurs the err pointer is overwritten\n *\twith a negative errno code and NULL is returned. The function checks\n *\tfor both invalid handles and passing a handle which is not a socket.\n *\n *\tOn a success the socket object pointer is returned.\n */\n\nstruct socket *sockfd_lookup(int fd, int *err)\n{\n\tstruct file *file;\n\tstruct socket *sock;\n\n\tfile = fget(fd);\n\tif (!file) {\n\t\t*err = -EBADF;\n\t\treturn NULL;\n\t}\n\n\tsock = sock_from_file(file, err);\n\tif (!sock)\n\t\tfput(file);\n\treturn sock;\n}\nEXPORT_SYMBOL(sockfd_lookup);\n\nstatic struct socket *sockfd_lookup_light(int fd, int *err, int *fput_needed)\n{\n\tstruct file *file;\n\tstruct socket *sock;\n\n\t*err = -EBADF;\n\tfile = fget_light(fd, fput_needed);\n\tif (file) {\n\t\tsock = sock_from_file(file, err);\n\t\tif (sock)\n\t\t\treturn sock;\n\t\tfput_light(file, *fput_needed);\n\t}\n\treturn NULL;\n}\n\n/**\n *\tsock_alloc\t-\tallocate a socket\n *\n *\tAllocate a new inode and socket object. The two are bound together\n *\tand initialised. The socket is then returned. If we are out of inodes\n *\tNULL is returned.\n */\n\nstatic struct socket *sock_alloc(void)\n{\n\tstruct inode *inode;\n\tstruct socket *sock;\n\n\tinode = new_inode_pseudo(sock_mnt->mnt_sb);\n\tif (!inode)\n\t\treturn NULL;\n\n\tsock = SOCKET_I(inode);\n\n\tkmemcheck_annotate_bitfield(sock, type);\n\tinode->i_ino = get_next_ino();\n\tinode->i_mode = S_IFSOCK | S_IRWXUGO;\n\tinode->i_uid = current_fsuid();\n\tinode->i_gid = current_fsgid();\n\n\tpercpu_add(sockets_in_use, 1);\n\treturn sock;\n}\n\n/*\n *\tIn theory you can't get an open on this inode, but /proc provides\n *\ta back door. Remember to keep it shut otherwise you'll let the\n *\tcreepy crawlies in.\n */\n\nstatic int sock_no_open(struct inode *irrelevant, struct file *dontcare)\n{\n\treturn -ENXIO;\n}\n\nconst struct file_operations bad_sock_fops = {\n\t.owner = THIS_MODULE,\n\t.open = sock_no_open,\n\t.llseek = noop_llseek,\n};\n\n/**\n *\tsock_release\t-\tclose a socket\n *\t@sock: socket to close\n *\n *\tThe socket is released from the protocol stack if it has a release\n *\tcallback, and the inode is then released if the socket is bound to\n *\tan inode not a file.\n */\n\nvoid sock_release(struct socket *sock)\n{\n\tif (sock->ops) {\n\t\tstruct module *owner = sock->ops->owner;\n\n\t\tsock->ops->release(sock);\n\t\tsock->ops = NULL;\n\t\tmodule_put(owner);\n\t}\n\n\tif (rcu_dereference_protected(sock->wq, 1)->fasync_list)\n\t\tprintk(KERN_ERR \"sock_release: fasync list not empty!\\n\");\n\n\tpercpu_sub(sockets_in_use, 1);\n\tif (!sock->file) {\n\t\tiput(SOCK_INODE(sock));\n\t\treturn;\n\t}\n\tsock->file = NULL;\n}\nEXPORT_SYMBOL(sock_release);\n\nint sock_tx_timestamp(struct sock *sk, __u8 *tx_flags)\n{\n\t*tx_flags = 0;\n\tif (sock_flag(sk, SOCK_TIMESTAMPING_TX_HARDWARE))\n\t\t*tx_flags |= SKBTX_HW_TSTAMP;\n\tif (sock_flag(sk, SOCK_TIMESTAMPING_TX_SOFTWARE))\n\t\t*tx_flags |= SKBTX_SW_TSTAMP;\n\treturn 0;\n}\nEXPORT_SYMBOL(sock_tx_timestamp);\n\nstatic inline int __sock_sendmsg_nosec(struct kiocb *iocb, struct socket *sock,\n\t\t\t\t       struct msghdr *msg, size_t size)\n{\n\tstruct sock_iocb *si = kiocb_to_siocb(iocb);\n\n\tsock_update_classid(sock->sk);\n\n\tsi->sock = sock;\n\tsi->scm = NULL;\n\tsi->msg = msg;\n\tsi->size = size;\n\n\treturn sock->ops->sendmsg(iocb, sock, msg, size);\n}\n\nstatic inline int __sock_sendmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\t struct msghdr *msg, size_t size)\n{\n\tint err = security_socket_sendmsg(sock, msg, size);\n\n\treturn err ?: __sock_sendmsg_nosec(iocb, sock, msg, size);\n}\n\nint sock_sendmsg(struct socket *sock, struct msghdr *msg, size_t size)\n{\n\tstruct kiocb iocb;\n\tstruct sock_iocb siocb;\n\tint ret;\n\n\tinit_sync_kiocb(&iocb, NULL);\n\tiocb.private = &siocb;\n\tret = __sock_sendmsg(&iocb, sock, msg, size);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&iocb);\n\treturn ret;\n}\nEXPORT_SYMBOL(sock_sendmsg);\n\nstatic int sock_sendmsg_nosec(struct socket *sock, struct msghdr *msg, size_t size)\n{\n\tstruct kiocb iocb;\n\tstruct sock_iocb siocb;\n\tint ret;\n\n\tinit_sync_kiocb(&iocb, NULL);\n\tiocb.private = &siocb;\n\tret = __sock_sendmsg_nosec(&iocb, sock, msg, size);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&iocb);\n\treturn ret;\n}\n\nint kernel_sendmsg(struct socket *sock, struct msghdr *msg,\n\t\t   struct kvec *vec, size_t num, size_t size)\n{\n\tmm_segment_t oldfs = get_fs();\n\tint result;\n\n\tset_fs(KERNEL_DS);\n\t/*\n\t * the following is safe, since for compiler definitions of kvec and\n\t * iovec are identical, yielding the same in-core layout and alignment\n\t */\n\tmsg->msg_iov = (struct iovec *)vec;\n\tmsg->msg_iovlen = num;\n\tresult = sock_sendmsg(sock, msg, size);\n\tset_fs(oldfs);\n\treturn result;\n}\nEXPORT_SYMBOL(kernel_sendmsg);\n\nstatic int ktime2ts(ktime_t kt, struct timespec *ts)\n{\n\tif (kt.tv64) {\n\t\t*ts = ktime_to_timespec(kt);\n\t\treturn 1;\n\t} else {\n\t\treturn 0;\n\t}\n}\n\n/*\n * called from sock_recv_timestamp() if sock_flag(sk, SOCK_RCVTSTAMP)\n */\nvoid __sock_recv_timestamp(struct msghdr *msg, struct sock *sk,\n\tstruct sk_buff *skb)\n{\n\tint need_software_tstamp = sock_flag(sk, SOCK_RCVTSTAMP);\n\tstruct timespec ts[3];\n\tint empty = 1;\n\tstruct skb_shared_hwtstamps *shhwtstamps =\n\t\tskb_hwtstamps(skb);\n\n\t/* Race occurred between timestamp enabling and packet\n\t   receiving.  Fill in the current time for now. */\n\tif (need_software_tstamp && skb->tstamp.tv64 == 0)\n\t\t__net_timestamp(skb);\n\n\tif (need_software_tstamp) {\n\t\tif (!sock_flag(sk, SOCK_RCVTSTAMPNS)) {\n\t\t\tstruct timeval tv;\n\t\t\tskb_get_timestamp(skb, &tv);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMP,\n\t\t\t\t sizeof(tv), &tv);\n\t\t} else {\n\t\t\tskb_get_timestampns(skb, &ts[0]);\n\t\t\tput_cmsg(msg, SOL_SOCKET, SCM_TIMESTAMPNS,\n\t\t\t\t sizeof(ts[0]), &ts[0]);\n\t\t}\n\t}\n\n\n\tmemset(ts, 0, sizeof(ts));\n\tif (skb->tstamp.tv64 &&\n\t    sock_flag(sk, SOCK_TIMESTAMPING_SOFTWARE)) {\n\t\tskb_get_timestampns(skb, ts + 0);\n\t\tempty = 0;\n\t}\n\tif (shhwtstamps) {\n\t\tif (sock_flag(sk, SOCK_TIMESTAMPING_SYS_HARDWARE) &&\n\t\t    ktime2ts(shhwtstamps->syststamp, ts + 1))\n\t\t\tempty = 0;\n\t\tif (sock_flag(sk, SOCK_TIMESTAMPING_RAW_HARDWARE) &&\n\t\t    ktime2ts(shhwtstamps->hwtstamp, ts + 2))\n\t\t\tempty = 0;\n\t}\n\tif (!empty)\n\t\tput_cmsg(msg, SOL_SOCKET,\n\t\t\t SCM_TIMESTAMPING, sizeof(ts), &ts);\n}\nEXPORT_SYMBOL_GPL(__sock_recv_timestamp);\n\nstatic inline void sock_recv_drops(struct msghdr *msg, struct sock *sk,\n\t\t\t\t   struct sk_buff *skb)\n{\n\tif (sock_flag(sk, SOCK_RXQ_OVFL) && skb && skb->dropcount)\n\t\tput_cmsg(msg, SOL_SOCKET, SO_RXQ_OVFL,\n\t\t\tsizeof(__u32), &skb->dropcount);\n}\n\nvoid __sock_recv_ts_and_drops(struct msghdr *msg, struct sock *sk,\n\tstruct sk_buff *skb)\n{\n\tsock_recv_timestamp(msg, sk, skb);\n\tsock_recv_drops(msg, sk, skb);\n}\nEXPORT_SYMBOL_GPL(__sock_recv_ts_and_drops);\n\nstatic inline int __sock_recvmsg_nosec(struct kiocb *iocb, struct socket *sock,\n\t\t\t\t       struct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock_iocb *si = kiocb_to_siocb(iocb);\n\n\tsock_update_classid(sock->sk);\n\n\tsi->sock = sock;\n\tsi->scm = NULL;\n\tsi->msg = msg;\n\tsi->size = size;\n\tsi->flags = flags;\n\n\treturn sock->ops->recvmsg(iocb, sock, msg, size, flags);\n}\n\nstatic inline int __sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\t struct msghdr *msg, size_t size, int flags)\n{\n\tint err = security_socket_recvmsg(sock, msg, size, flags);\n\n\treturn err ?: __sock_recvmsg_nosec(iocb, sock, msg, size, flags);\n}\n\nint sock_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t size_t size, int flags)\n{\n\tstruct kiocb iocb;\n\tstruct sock_iocb siocb;\n\tint ret;\n\n\tinit_sync_kiocb(&iocb, NULL);\n\tiocb.private = &siocb;\n\tret = __sock_recvmsg(&iocb, sock, msg, size, flags);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&iocb);\n\treturn ret;\n}\nEXPORT_SYMBOL(sock_recvmsg);\n\nstatic int sock_recvmsg_nosec(struct socket *sock, struct msghdr *msg,\n\t\t\t      size_t size, int flags)\n{\n\tstruct kiocb iocb;\n\tstruct sock_iocb siocb;\n\tint ret;\n\n\tinit_sync_kiocb(&iocb, NULL);\n\tiocb.private = &siocb;\n\tret = __sock_recvmsg_nosec(&iocb, sock, msg, size, flags);\n\tif (-EIOCBQUEUED == ret)\n\t\tret = wait_on_sync_kiocb(&iocb);\n\treturn ret;\n}\n\n/**\n * kernel_recvmsg - Receive a message from a socket (kernel space)\n * @sock:       The socket to receive the message from\n * @msg:        Received message\n * @vec:        Input s/g array for message data\n * @num:        Size of input s/g array\n * @size:       Number of bytes to read\n * @flags:      Message flags (MSG_DONTWAIT, etc...)\n *\n * On return the msg structure contains the scatter/gather array passed in the\n * vec argument. The array is modified so that it consists of the unfilled\n * portion of the original array.\n *\n * The returned value is the total number of bytes received, or an error.\n */\nint kernel_recvmsg(struct socket *sock, struct msghdr *msg,\n\t\t   struct kvec *vec, size_t num, size_t size, int flags)\n{\n\tmm_segment_t oldfs = get_fs();\n\tint result;\n\n\tset_fs(KERNEL_DS);\n\t/*\n\t * the following is safe, since for compiler definitions of kvec and\n\t * iovec are identical, yielding the same in-core layout and alignment\n\t */\n\tmsg->msg_iov = (struct iovec *)vec, msg->msg_iovlen = num;\n\tresult = sock_recvmsg(sock, msg, size, flags);\n\tset_fs(oldfs);\n\treturn result;\n}\nEXPORT_SYMBOL(kernel_recvmsg);\n\nstatic void sock_aio_dtor(struct kiocb *iocb)\n{\n\tkfree(iocb->private);\n}\n\nstatic ssize_t sock_sendpage(struct file *file, struct page *page,\n\t\t\t     int offset, size_t size, loff_t *ppos, int more)\n{\n\tstruct socket *sock;\n\tint flags;\n\n\tsock = file->private_data;\n\n\tflags = !(file->f_flags & O_NONBLOCK) ? 0 : MSG_DONTWAIT;\n\tif (more)\n\t\tflags |= MSG_MORE;\n\n\treturn kernel_sendpage(sock, page, offset, size, flags);\n}\n\nstatic ssize_t sock_splice_read(struct file *file, loff_t *ppos,\n\t\t\t\tstruct pipe_inode_info *pipe, size_t len,\n\t\t\t\tunsigned int flags)\n{\n\tstruct socket *sock = file->private_data;\n\n\tif (unlikely(!sock->ops->splice_read))\n\t\treturn -EINVAL;\n\n\tsock_update_classid(sock->sk);\n\n\treturn sock->ops->splice_read(sock, ppos, pipe, len, flags);\n}\n\nstatic struct sock_iocb *alloc_sock_iocb(struct kiocb *iocb,\n\t\t\t\t\t struct sock_iocb *siocb)\n{\n\tif (!is_sync_kiocb(iocb)) {\n\t\tsiocb = kmalloc(sizeof(*siocb), GFP_KERNEL);\n\t\tif (!siocb)\n\t\t\treturn NULL;\n\t\tiocb->ki_dtor = sock_aio_dtor;\n\t}\n\n\tsiocb->kiocb = iocb;\n\tiocb->private = siocb;\n\treturn siocb;\n}\n\nstatic ssize_t do_sock_read(struct msghdr *msg, struct kiocb *iocb,\n\t\tstruct file *file, const struct iovec *iov,\n\t\tunsigned long nr_segs)\n{\n\tstruct socket *sock = file->private_data;\n\tsize_t size = 0;\n\tint i;\n\n\tfor (i = 0; i < nr_segs; i++)\n\t\tsize += iov[i].iov_len;\n\n\tmsg->msg_name = NULL;\n\tmsg->msg_namelen = 0;\n\tmsg->msg_control = NULL;\n\tmsg->msg_controllen = 0;\n\tmsg->msg_iov = (struct iovec *)iov;\n\tmsg->msg_iovlen = nr_segs;\n\tmsg->msg_flags = (file->f_flags & O_NONBLOCK) ? MSG_DONTWAIT : 0;\n\n\treturn __sock_recvmsg(iocb, sock, msg, size, msg->msg_flags);\n}\n\nstatic ssize_t sock_aio_read(struct kiocb *iocb, const struct iovec *iov,\n\t\t\t\tunsigned long nr_segs, loff_t pos)\n{\n\tstruct sock_iocb siocb, *x;\n\n\tif (pos != 0)\n\t\treturn -ESPIPE;\n\n\tif (iocb->ki_left == 0)\t/* Match SYS5 behaviour */\n\t\treturn 0;\n\n\n\tx = alloc_sock_iocb(iocb, &siocb);\n\tif (!x)\n\t\treturn -ENOMEM;\n\treturn do_sock_read(&x->async_msg, iocb, iocb->ki_filp, iov, nr_segs);\n}\n\nstatic ssize_t do_sock_write(struct msghdr *msg, struct kiocb *iocb,\n\t\t\tstruct file *file, const struct iovec *iov,\n\t\t\tunsigned long nr_segs)\n{\n\tstruct socket *sock = file->private_data;\n\tsize_t size = 0;\n\tint i;\n\n\tfor (i = 0; i < nr_segs; i++)\n\t\tsize += iov[i].iov_len;\n\n\tmsg->msg_name = NULL;\n\tmsg->msg_namelen = 0;\n\tmsg->msg_control = NULL;\n\tmsg->msg_controllen = 0;\n\tmsg->msg_iov = (struct iovec *)iov;\n\tmsg->msg_iovlen = nr_segs;\n\tmsg->msg_flags = (file->f_flags & O_NONBLOCK) ? MSG_DONTWAIT : 0;\n\tif (sock->type == SOCK_SEQPACKET)\n\t\tmsg->msg_flags |= MSG_EOR;\n\n\treturn __sock_sendmsg(iocb, sock, msg, size);\n}\n\nstatic ssize_t sock_aio_write(struct kiocb *iocb, const struct iovec *iov,\n\t\t\t  unsigned long nr_segs, loff_t pos)\n{\n\tstruct sock_iocb siocb, *x;\n\n\tif (pos != 0)\n\t\treturn -ESPIPE;\n\n\tx = alloc_sock_iocb(iocb, &siocb);\n\tif (!x)\n\t\treturn -ENOMEM;\n\n\treturn do_sock_write(&x->async_msg, iocb, iocb->ki_filp, iov, nr_segs);\n}\n\n/*\n * Atomic setting of ioctl hooks to avoid race\n * with module unload.\n */\n\nstatic DEFINE_MUTEX(br_ioctl_mutex);\nstatic int (*br_ioctl_hook) (struct net *, unsigned int cmd, void __user *arg);\n\nvoid brioctl_set(int (*hook) (struct net *, unsigned int, void __user *))\n{\n\tmutex_lock(&br_ioctl_mutex);\n\tbr_ioctl_hook = hook;\n\tmutex_unlock(&br_ioctl_mutex);\n}\nEXPORT_SYMBOL(brioctl_set);\n\nstatic DEFINE_MUTEX(vlan_ioctl_mutex);\nstatic int (*vlan_ioctl_hook) (struct net *, void __user *arg);\n\nvoid vlan_ioctl_set(int (*hook) (struct net *, void __user *))\n{\n\tmutex_lock(&vlan_ioctl_mutex);\n\tvlan_ioctl_hook = hook;\n\tmutex_unlock(&vlan_ioctl_mutex);\n}\nEXPORT_SYMBOL(vlan_ioctl_set);\n\nstatic DEFINE_MUTEX(dlci_ioctl_mutex);\nstatic int (*dlci_ioctl_hook) (unsigned int, void __user *);\n\nvoid dlci_ioctl_set(int (*hook) (unsigned int, void __user *))\n{\n\tmutex_lock(&dlci_ioctl_mutex);\n\tdlci_ioctl_hook = hook;\n\tmutex_unlock(&dlci_ioctl_mutex);\n}\nEXPORT_SYMBOL(dlci_ioctl_set);\n\nstatic long sock_do_ioctl(struct net *net, struct socket *sock,\n\t\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tint err;\n\tvoid __user *argp = (void __user *)arg;\n\n\terr = sock->ops->ioctl(sock, cmd, arg);\n\n\t/*\n\t * If this ioctl is unknown try to hand it down\n\t * to the NIC driver.\n\t */\n\tif (err == -ENOIOCTLCMD)\n\t\terr = dev_ioctl(net, cmd, argp);\n\n\treturn err;\n}\n\n/*\n *\tWith an ioctl, arg may well be a user mode pointer, but we don't know\n *\twhat to do with it - that's up to the protocol still.\n */\n\nstatic long sock_ioctl(struct file *file, unsigned cmd, unsigned long arg)\n{\n\tstruct socket *sock;\n\tstruct sock *sk;\n\tvoid __user *argp = (void __user *)arg;\n\tint pid, err;\n\tstruct net *net;\n\n\tsock = file->private_data;\n\tsk = sock->sk;\n\tnet = sock_net(sk);\n\tif (cmd >= SIOCDEVPRIVATE && cmd <= (SIOCDEVPRIVATE + 15)) {\n\t\terr = dev_ioctl(net, cmd, argp);\n\t} else\n#ifdef CONFIG_WEXT_CORE\n\tif (cmd >= SIOCIWFIRST && cmd <= SIOCIWLAST) {\n\t\terr = dev_ioctl(net, cmd, argp);\n\t} else\n#endif\n\t\tswitch (cmd) {\n\t\tcase FIOSETOWN:\n\t\tcase SIOCSPGRP:\n\t\t\terr = -EFAULT;\n\t\t\tif (get_user(pid, (int __user *)argp))\n\t\t\t\tbreak;\n\t\t\terr = f_setown(sock->file, pid, 1);\n\t\t\tbreak;\n\t\tcase FIOGETOWN:\n\t\tcase SIOCGPGRP:\n\t\t\terr = put_user(f_getown(sock->file),\n\t\t\t\t       (int __user *)argp);\n\t\t\tbreak;\n\t\tcase SIOCGIFBR:\n\t\tcase SIOCSIFBR:\n\t\tcase SIOCBRADDBR:\n\t\tcase SIOCBRDELBR:\n\t\t\terr = -ENOPKG;\n\t\t\tif (!br_ioctl_hook)\n\t\t\t\trequest_module(\"bridge\");\n\n\t\t\tmutex_lock(&br_ioctl_mutex);\n\t\t\tif (br_ioctl_hook)\n\t\t\t\terr = br_ioctl_hook(net, cmd, argp);\n\t\t\tmutex_unlock(&br_ioctl_mutex);\n\t\t\tbreak;\n\t\tcase SIOCGIFVLAN:\n\t\tcase SIOCSIFVLAN:\n\t\t\terr = -ENOPKG;\n\t\t\tif (!vlan_ioctl_hook)\n\t\t\t\trequest_module(\"8021q\");\n\n\t\t\tmutex_lock(&vlan_ioctl_mutex);\n\t\t\tif (vlan_ioctl_hook)\n\t\t\t\terr = vlan_ioctl_hook(net, argp);\n\t\t\tmutex_unlock(&vlan_ioctl_mutex);\n\t\t\tbreak;\n\t\tcase SIOCADDDLCI:\n\t\tcase SIOCDELDLCI:\n\t\t\terr = -ENOPKG;\n\t\t\tif (!dlci_ioctl_hook)\n\t\t\t\trequest_module(\"dlci\");\n\n\t\t\tmutex_lock(&dlci_ioctl_mutex);\n\t\t\tif (dlci_ioctl_hook)\n\t\t\t\terr = dlci_ioctl_hook(cmd, argp);\n\t\t\tmutex_unlock(&dlci_ioctl_mutex);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = sock_do_ioctl(net, sock, cmd, arg);\n\t\t\tbreak;\n\t\t}\n\treturn err;\n}\n\nint sock_create_lite(int family, int type, int protocol, struct socket **res)\n{\n\tint err;\n\tstruct socket *sock = NULL;\n\n\terr = security_socket_create(family, type, protocol, 1);\n\tif (err)\n\t\tgoto out;\n\n\tsock = sock_alloc();\n\tif (!sock) {\n\t\terr = -ENOMEM;\n\t\tgoto out;\n\t}\n\n\tsock->type = type;\n\terr = security_socket_post_create(sock, family, type, protocol, 1);\n\tif (err)\n\t\tgoto out_release;\n\nout:\n\t*res = sock;\n\treturn err;\nout_release:\n\tsock_release(sock);\n\tsock = NULL;\n\tgoto out;\n}\nEXPORT_SYMBOL(sock_create_lite);\n\n/* No kernel lock held - perfect */\nstatic unsigned int sock_poll(struct file *file, poll_table *wait)\n{\n\tstruct socket *sock;\n\n\t/*\n\t *      We can't return errors to poll, so it's either yes or no.\n\t */\n\tsock = file->private_data;\n\treturn sock->ops->poll(file, sock, wait);\n}\n\nstatic int sock_mmap(struct file *file, struct vm_area_struct *vma)\n{\n\tstruct socket *sock = file->private_data;\n\n\treturn sock->ops->mmap(file, sock, vma);\n}\n\nstatic int sock_close(struct inode *inode, struct file *filp)\n{\n\t/*\n\t *      It was possible the inode is NULL we were\n\t *      closing an unfinished socket.\n\t */\n\n\tif (!inode) {\n\t\tprintk(KERN_DEBUG \"sock_close: NULL inode\\n\");\n\t\treturn 0;\n\t}\n\tsock_release(SOCKET_I(inode));\n\treturn 0;\n}\n\n/*\n *\tUpdate the socket async list\n *\n *\tFasync_list locking strategy.\n *\n *\t1. fasync_list is modified only under process context socket lock\n *\t   i.e. under semaphore.\n *\t2. fasync_list is used under read_lock(&sk->sk_callback_lock)\n *\t   or under socket lock\n */\n\nstatic int sock_fasync(int fd, struct file *filp, int on)\n{\n\tstruct socket *sock = filp->private_data;\n\tstruct sock *sk = sock->sk;\n\tstruct socket_wq *wq;\n\n\tif (sk == NULL)\n\t\treturn -EINVAL;\n\n\tlock_sock(sk);\n\twq = rcu_dereference_protected(sock->wq, sock_owned_by_user(sk));\n\tfasync_helper(fd, filp, on, &wq->fasync_list);\n\n\tif (!wq->fasync_list)\n\t\tsock_reset_flag(sk, SOCK_FASYNC);\n\telse\n\t\tsock_set_flag(sk, SOCK_FASYNC);\n\n\trelease_sock(sk);\n\treturn 0;\n}\n\n/* This function may be called only under socket lock or callback_lock or rcu_lock */\n\nint sock_wake_async(struct socket *sock, int how, int band)\n{\n\tstruct socket_wq *wq;\n\n\tif (!sock)\n\t\treturn -1;\n\trcu_read_lock();\n\twq = rcu_dereference(sock->wq);\n\tif (!wq || !wq->fasync_list) {\n\t\trcu_read_unlock();\n\t\treturn -1;\n\t}\n\tswitch (how) {\n\tcase SOCK_WAKE_WAITD:\n\t\tif (test_bit(SOCK_ASYNC_WAITDATA, &sock->flags))\n\t\t\tbreak;\n\t\tgoto call_kill;\n\tcase SOCK_WAKE_SPACE:\n\t\tif (!test_and_clear_bit(SOCK_ASYNC_NOSPACE, &sock->flags))\n\t\t\tbreak;\n\t\t/* fall through */\n\tcase SOCK_WAKE_IO:\ncall_kill:\n\t\tkill_fasync(&wq->fasync_list, SIGIO, band);\n\t\tbreak;\n\tcase SOCK_WAKE_URG:\n\t\tkill_fasync(&wq->fasync_list, SIGURG, band);\n\t}\n\trcu_read_unlock();\n\treturn 0;\n}\nEXPORT_SYMBOL(sock_wake_async);\n\nint __sock_create(struct net *net, int family, int type, int protocol,\n\t\t\t struct socket **res, int kern)\n{\n\tint err;\n\tstruct socket *sock;\n\tconst struct net_proto_family *pf;\n\n\t/*\n\t *      Check protocol is in range\n\t */\n\tif (family < 0 || family >= NPROTO)\n\t\treturn -EAFNOSUPPORT;\n\tif (type < 0 || type >= SOCK_MAX)\n\t\treturn -EINVAL;\n\n\t/* Compatibility.\n\n\t   This uglymoron is moved from INET layer to here to avoid\n\t   deadlock in module load.\n\t */\n\tif (family == PF_INET && type == SOCK_PACKET) {\n\t\tstatic int warned;\n\t\tif (!warned) {\n\t\t\twarned = 1;\n\t\t\tprintk(KERN_INFO \"%s uses obsolete (PF_INET,SOCK_PACKET)\\n\",\n\t\t\t       current->comm);\n\t\t}\n\t\tfamily = PF_PACKET;\n\t}\n\n\terr = security_socket_create(family, type, protocol, kern);\n\tif (err)\n\t\treturn err;\n\n\t/*\n\t *\tAllocate the socket and allow the family to set things up. if\n\t *\tthe protocol is 0, the family is instructed to select an appropriate\n\t *\tdefault.\n\t */\n\tsock = sock_alloc();\n\tif (!sock) {\n\t\tif (net_ratelimit())\n\t\t\tprintk(KERN_WARNING \"socket: no more sockets\\n\");\n\t\treturn -ENFILE;\t/* Not exactly a match, but its the\n\t\t\t\t   closest posix thing */\n\t}\n\n\tsock->type = type;\n\n#ifdef CONFIG_MODULES\n\t/* Attempt to load a protocol module if the find failed.\n\t *\n\t * 12/09/1996 Marcin: But! this makes REALLY only sense, if the user\n\t * requested real, full-featured networking support upon configuration.\n\t * Otherwise module support will break!\n\t */\n\tif (rcu_access_pointer(net_families[family]) == NULL)\n\t\trequest_module(\"net-pf-%d\", family);\n#endif\n\n\trcu_read_lock();\n\tpf = rcu_dereference(net_families[family]);\n\terr = -EAFNOSUPPORT;\n\tif (!pf)\n\t\tgoto out_release;\n\n\t/*\n\t * We will call the ->create function, that possibly is in a loadable\n\t * module, so we have to bump that loadable module refcnt first.\n\t */\n\tif (!try_module_get(pf->owner))\n\t\tgoto out_release;\n\n\t/* Now protected by module ref count */\n\trcu_read_unlock();\n\n\terr = pf->create(net, sock, protocol, kern);\n\tif (err < 0)\n\t\tgoto out_module_put;\n\n\t/*\n\t * Now to bump the refcnt of the [loadable] module that owns this\n\t * socket at sock_release time we decrement its refcnt.\n\t */\n\tif (!try_module_get(sock->ops->owner))\n\t\tgoto out_module_busy;\n\n\t/*\n\t * Now that we're done with the ->create function, the [loadable]\n\t * module can have its refcnt decremented\n\t */\n\tmodule_put(pf->owner);\n\terr = security_socket_post_create(sock, family, type, protocol, kern);\n\tif (err)\n\t\tgoto out_sock_release;\n\t*res = sock;\n\n\treturn 0;\n\nout_module_busy:\n\terr = -EAFNOSUPPORT;\nout_module_put:\n\tsock->ops = NULL;\n\tmodule_put(pf->owner);\nout_sock_release:\n\tsock_release(sock);\n\treturn err;\n\nout_release:\n\trcu_read_unlock();\n\tgoto out_sock_release;\n}\nEXPORT_SYMBOL(__sock_create);\n\nint sock_create(int family, int type, int protocol, struct socket **res)\n{\n\treturn __sock_create(current->nsproxy->net_ns, family, type, protocol, res, 0);\n}\nEXPORT_SYMBOL(sock_create);\n\nint sock_create_kern(int family, int type, int protocol, struct socket **res)\n{\n\treturn __sock_create(&init_net, family, type, protocol, res, 1);\n}\nEXPORT_SYMBOL(sock_create_kern);\n\nSYSCALL_DEFINE3(socket, int, family, int, type, int, protocol)\n{\n\tint retval;\n\tstruct socket *sock;\n\tint flags;\n\n\t/* Check the SOCK_* constants for consistency.  */\n\tBUILD_BUG_ON(SOCK_CLOEXEC != O_CLOEXEC);\n\tBUILD_BUG_ON((SOCK_MAX | SOCK_TYPE_MASK) != SOCK_TYPE_MASK);\n\tBUILD_BUG_ON(SOCK_CLOEXEC & SOCK_TYPE_MASK);\n\tBUILD_BUG_ON(SOCK_NONBLOCK & SOCK_TYPE_MASK);\n\n\tflags = type & ~SOCK_TYPE_MASK;\n\tif (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))\n\t\treturn -EINVAL;\n\ttype &= SOCK_TYPE_MASK;\n\n\tif (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))\n\t\tflags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;\n\n\tretval = sock_create(family, type, protocol, &sock);\n\tif (retval < 0)\n\t\tgoto out;\n\n\tretval = sock_map_fd(sock, flags & (O_CLOEXEC | O_NONBLOCK));\n\tif (retval < 0)\n\t\tgoto out_release;\n\nout:\n\t/* It may be already another descriptor 8) Not kernel problem. */\n\treturn retval;\n\nout_release:\n\tsock_release(sock);\n\treturn retval;\n}\n\n/*\n *\tCreate a pair of connected sockets.\n */\n\nSYSCALL_DEFINE4(socketpair, int, family, int, type, int, protocol,\n\t\tint __user *, usockvec)\n{\n\tstruct socket *sock1, *sock2;\n\tint fd1, fd2, err;\n\tstruct file *newfile1, *newfile2;\n\tint flags;\n\n\tflags = type & ~SOCK_TYPE_MASK;\n\tif (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))\n\t\treturn -EINVAL;\n\ttype &= SOCK_TYPE_MASK;\n\n\tif (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))\n\t\tflags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;\n\n\t/*\n\t * Obtain the first socket and check if the underlying protocol\n\t * supports the socketpair call.\n\t */\n\n\terr = sock_create(family, type, protocol, &sock1);\n\tif (err < 0)\n\t\tgoto out;\n\n\terr = sock_create(family, type, protocol, &sock2);\n\tif (err < 0)\n\t\tgoto out_release_1;\n\n\terr = sock1->ops->socketpair(sock1, sock2);\n\tif (err < 0)\n\t\tgoto out_release_both;\n\n\tfd1 = sock_alloc_file(sock1, &newfile1, flags);\n\tif (unlikely(fd1 < 0)) {\n\t\terr = fd1;\n\t\tgoto out_release_both;\n\t}\n\n\tfd2 = sock_alloc_file(sock2, &newfile2, flags);\n\tif (unlikely(fd2 < 0)) {\n\t\terr = fd2;\n\t\tfput(newfile1);\n\t\tput_unused_fd(fd1);\n\t\tsock_release(sock2);\n\t\tgoto out;\n\t}\n\n\taudit_fd_pair(fd1, fd2);\n\tfd_install(fd1, newfile1);\n\tfd_install(fd2, newfile2);\n\t/* fd1 and fd2 may be already another descriptors.\n\t * Not kernel problem.\n\t */\n\n\terr = put_user(fd1, &usockvec[0]);\n\tif (!err)\n\t\terr = put_user(fd2, &usockvec[1]);\n\tif (!err)\n\t\treturn 0;\n\n\tsys_close(fd2);\n\tsys_close(fd1);\n\treturn err;\n\nout_release_both:\n\tsock_release(sock2);\nout_release_1:\n\tsock_release(sock1);\nout:\n\treturn err;\n}\n\n/*\n *\tBind a name to a socket. Nothing much to do here since it's\n *\tthe protocol's responsibility to handle the local address.\n *\n *\tWe move the socket address to kernel space before we call\n *\tthe protocol layer (having also checked the address is ok).\n */\n\nSYSCALL_DEFINE3(bind, int, fd, struct sockaddr __user *, umyaddr, int, addrlen)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint err, fput_needed;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock) {\n\t\terr = move_addr_to_kernel(umyaddr, addrlen, (struct sockaddr *)&address);\n\t\tif (err >= 0) {\n\t\t\terr = security_socket_bind(sock,\n\t\t\t\t\t\t   (struct sockaddr *)&address,\n\t\t\t\t\t\t   addrlen);\n\t\t\tif (!err)\n\t\t\t\terr = sock->ops->bind(sock,\n\t\t\t\t\t\t      (struct sockaddr *)\n\t\t\t\t\t\t      &address, addrlen);\n\t\t}\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\n/*\n *\tPerform a listen. Basically, we allow the protocol to do anything\n *\tnecessary for a listen, and if that works, we mark the socket as\n *\tready for listening.\n */\n\nSYSCALL_DEFINE2(listen, int, fd, int, backlog)\n{\n\tstruct socket *sock;\n\tint err, fput_needed;\n\tint somaxconn;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock) {\n\t\tsomaxconn = sock_net(sock->sk)->core.sysctl_somaxconn;\n\t\tif ((unsigned)backlog > somaxconn)\n\t\t\tbacklog = somaxconn;\n\n\t\terr = security_socket_listen(sock, backlog);\n\t\tif (!err)\n\t\t\terr = sock->ops->listen(sock, backlog);\n\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\n/*\n *\tFor accept, we attempt to create a new socket, set up the link\n *\twith the client, wake up the client, then return the new\n *\tconnected fd. We collect the address of the connector in kernel\n *\tspace and move it to user at the very end. This is unclean because\n *\twe open the socket then return an error.\n *\n *\t1003.1g adds the ability to recvmsg() to query connection pending\n *\tstatus to recvmsg. We need to add that support in a way thats\n *\tclean when we restucture accept also.\n */\n\nSYSCALL_DEFINE4(accept4, int, fd, struct sockaddr __user *, upeer_sockaddr,\n\t\tint __user *, upeer_addrlen, int, flags)\n{\n\tstruct socket *sock, *newsock;\n\tstruct file *newfile;\n\tint err, len, newfd, fput_needed;\n\tstruct sockaddr_storage address;\n\n\tif (flags & ~(SOCK_CLOEXEC | SOCK_NONBLOCK))\n\t\treturn -EINVAL;\n\n\tif (SOCK_NONBLOCK != O_NONBLOCK && (flags & SOCK_NONBLOCK))\n\t\tflags = (flags & ~SOCK_NONBLOCK) | O_NONBLOCK;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\terr = -ENFILE;\n\tnewsock = sock_alloc();\n\tif (!newsock)\n\t\tgoto out_put;\n\n\tnewsock->type = sock->type;\n\tnewsock->ops = sock->ops;\n\n\t/*\n\t * We don't need try_module_get here, as the listening socket (sock)\n\t * has the protocol module (sock->ops->owner) held.\n\t */\n\t__module_get(newsock->ops->owner);\n\n\tnewfd = sock_alloc_file(newsock, &newfile, flags);\n\tif (unlikely(newfd < 0)) {\n\t\terr = newfd;\n\t\tsock_release(newsock);\n\t\tgoto out_put;\n\t}\n\n\terr = security_socket_accept(sock, newsock);\n\tif (err)\n\t\tgoto out_fd;\n\n\terr = sock->ops->accept(sock, newsock, sock->file->f_flags);\n\tif (err < 0)\n\t\tgoto out_fd;\n\n\tif (upeer_sockaddr) {\n\t\tif (newsock->ops->getname(newsock, (struct sockaddr *)&address,\n\t\t\t\t\t  &len, 2) < 0) {\n\t\t\terr = -ECONNABORTED;\n\t\t\tgoto out_fd;\n\t\t}\n\t\terr = move_addr_to_user((struct sockaddr *)&address,\n\t\t\t\t\tlen, upeer_sockaddr, upeer_addrlen);\n\t\tif (err < 0)\n\t\t\tgoto out_fd;\n\t}\n\n\t/* File flags are not inherited via accept() unlike another OSes. */\n\n\tfd_install(newfd, newfile);\n\terr = newfd;\n\nout_put:\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\nout_fd:\n\tfput(newfile);\n\tput_unused_fd(newfd);\n\tgoto out_put;\n}\n\nSYSCALL_DEFINE3(accept, int, fd, struct sockaddr __user *, upeer_sockaddr,\n\t\tint __user *, upeer_addrlen)\n{\n\treturn sys_accept4(fd, upeer_sockaddr, upeer_addrlen, 0);\n}\n\n/*\n *\tAttempt to connect to a socket with the server address.  The address\n *\tis in user space so we verify it is OK and move it to kernel space.\n *\n *\tFor 1003.1g we need to add clean support for a bind to AF_UNSPEC to\n *\tbreak bindings\n *\n *\tNOTE: 1003.1g draft 6.3 is broken with respect to AX.25/NetROM and\n *\tother SEQPACKET protocols that take time to connect() as it doesn't\n *\tinclude the -EINPROGRESS status for such sockets.\n */\n\nSYSCALL_DEFINE3(connect, int, fd, struct sockaddr __user *, uservaddr,\n\t\tint, addrlen)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint err, fput_needed;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\terr = move_addr_to_kernel(uservaddr, addrlen, (struct sockaddr *)&address);\n\tif (err < 0)\n\t\tgoto out_put;\n\n\terr =\n\t    security_socket_connect(sock, (struct sockaddr *)&address, addrlen);\n\tif (err)\n\t\tgoto out_put;\n\n\terr = sock->ops->connect(sock, (struct sockaddr *)&address, addrlen,\n\t\t\t\t sock->file->f_flags);\nout_put:\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\n/*\n *\tGet the local address ('name') of a socket object. Move the obtained\n *\tname to user space.\n */\n\nSYSCALL_DEFINE3(getsockname, int, fd, struct sockaddr __user *, usockaddr,\n\t\tint __user *, usockaddr_len)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint len, err, fput_needed;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\terr = security_socket_getsockname(sock);\n\tif (err)\n\t\tgoto out_put;\n\n\terr = sock->ops->getname(sock, (struct sockaddr *)&address, &len, 0);\n\tif (err)\n\t\tgoto out_put;\n\terr = move_addr_to_user((struct sockaddr *)&address, len, usockaddr, usockaddr_len);\n\nout_put:\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\n/*\n *\tGet the remote address ('name') of a socket object. Move the obtained\n *\tname to user space.\n */\n\nSYSCALL_DEFINE3(getpeername, int, fd, struct sockaddr __user *, usockaddr,\n\t\tint __user *, usockaddr_len)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint len, err, fput_needed;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock != NULL) {\n\t\terr = security_socket_getpeername(sock);\n\t\tif (err) {\n\t\t\tfput_light(sock->file, fput_needed);\n\t\t\treturn err;\n\t\t}\n\n\t\terr =\n\t\t    sock->ops->getname(sock, (struct sockaddr *)&address, &len,\n\t\t\t\t       1);\n\t\tif (!err)\n\t\t\terr = move_addr_to_user((struct sockaddr *)&address, len, usockaddr,\n\t\t\t\t\t\tusockaddr_len);\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\n/*\n *\tSend a datagram to a given address. We move the address into kernel\n *\tspace and check the user space data area is readable before invoking\n *\tthe protocol.\n */\n\nSYSCALL_DEFINE6(sendto, int, fd, void __user *, buff, size_t, len,\n\t\tunsigned, flags, struct sockaddr __user *, addr,\n\t\tint, addr_len)\n{\n\tstruct socket *sock;\n\tstruct sockaddr_storage address;\n\tint err;\n\tstruct msghdr msg;\n\tstruct iovec iov;\n\tint fput_needed;\n\n\tif (len > INT_MAX)\n\t\tlen = INT_MAX;\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\tiov.iov_base = buff;\n\tiov.iov_len = len;\n\tmsg.msg_name = NULL;\n\tmsg.msg_iov = &iov;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_namelen = 0;\n\tif (addr) {\n\t\terr = move_addr_to_kernel(addr, addr_len, (struct sockaddr *)&address);\n\t\tif (err < 0)\n\t\t\tgoto out_put;\n\t\tmsg.msg_name = (struct sockaddr *)&address;\n\t\tmsg.msg_namelen = addr_len;\n\t}\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\tmsg.msg_flags = flags;\n\terr = sock_sendmsg(sock, &msg, len);\n\nout_put:\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\n/*\n *\tSend a datagram down a socket.\n */\n\nSYSCALL_DEFINE4(send, int, fd, void __user *, buff, size_t, len,\n\t\tunsigned, flags)\n{\n\treturn sys_sendto(fd, buff, len, flags, NULL, 0);\n}\n\n/*\n *\tReceive a frame from the socket and optionally record the address of the\n *\tsender. We verify the buffers are writable and if needed move the\n *\tsender address from kernel to user space.\n */\n\nSYSCALL_DEFINE6(recvfrom, int, fd, void __user *, ubuf, size_t, size,\n\t\tunsigned, flags, struct sockaddr __user *, addr,\n\t\tint __user *, addr_len)\n{\n\tstruct socket *sock;\n\tstruct iovec iov;\n\tstruct msghdr msg;\n\tstruct sockaddr_storage address;\n\tint err, err2;\n\tint fput_needed;\n\n\tif (size > INT_MAX)\n\t\tsize = INT_MAX;\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\tgoto out;\n\n\tmsg.msg_control = NULL;\n\tmsg.msg_controllen = 0;\n\tmsg.msg_iovlen = 1;\n\tmsg.msg_iov = &iov;\n\tiov.iov_len = size;\n\tiov.iov_base = ubuf;\n\tmsg.msg_name = (struct sockaddr *)&address;\n\tmsg.msg_namelen = sizeof(address);\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\terr = sock_recvmsg(sock, &msg, size, flags);\n\n\tif (err >= 0 && addr != NULL) {\n\t\terr2 = move_addr_to_user((struct sockaddr *)&address,\n\t\t\t\t\t msg.msg_namelen, addr, addr_len);\n\t\tif (err2 < 0)\n\t\t\terr = err2;\n\t}\n\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\n/*\n *\tReceive a datagram from a socket.\n */\n\nasmlinkage long sys_recv(int fd, void __user *ubuf, size_t size,\n\t\t\t unsigned flags)\n{\n\treturn sys_recvfrom(fd, ubuf, size, flags, NULL, NULL);\n}\n\n/*\n *\tSet a socket option. Because we don't know the option lengths we have\n *\tto pass the user mode parameter for the protocols to sort out.\n */\n\nSYSCALL_DEFINE5(setsockopt, int, fd, int, level, int, optname,\n\t\tchar __user *, optval, int, optlen)\n{\n\tint err, fput_needed;\n\tstruct socket *sock;\n\n\tif (optlen < 0)\n\t\treturn -EINVAL;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock != NULL) {\n\t\terr = security_socket_setsockopt(sock, level, optname);\n\t\tif (err)\n\t\t\tgoto out_put;\n\n\t\tif (level == SOL_SOCKET)\n\t\t\terr =\n\t\t\t    sock_setsockopt(sock, level, optname, optval,\n\t\t\t\t\t    optlen);\n\t\telse\n\t\t\terr =\n\t\t\t    sock->ops->setsockopt(sock, level, optname, optval,\n\t\t\t\t\t\t  optlen);\nout_put:\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\n/*\n *\tGet a socket option. Because we don't know the option lengths we have\n *\tto pass a user mode parameter for the protocols to sort out.\n */\n\nSYSCALL_DEFINE5(getsockopt, int, fd, int, level, int, optname,\n\t\tchar __user *, optval, int __user *, optlen)\n{\n\tint err, fput_needed;\n\tstruct socket *sock;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock != NULL) {\n\t\terr = security_socket_getsockopt(sock, level, optname);\n\t\tif (err)\n\t\t\tgoto out_put;\n\n\t\tif (level == SOL_SOCKET)\n\t\t\terr =\n\t\t\t    sock_getsockopt(sock, level, optname, optval,\n\t\t\t\t\t    optlen);\n\t\telse\n\t\t\terr =\n\t\t\t    sock->ops->getsockopt(sock, level, optname, optval,\n\t\t\t\t\t\t  optlen);\nout_put:\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\n/*\n *\tShutdown a socket.\n */\n\nSYSCALL_DEFINE2(shutdown, int, fd, int, how)\n{\n\tint err, fput_needed;\n\tstruct socket *sock;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (sock != NULL) {\n\t\terr = security_socket_shutdown(sock, how);\n\t\tif (!err)\n\t\t\terr = sock->ops->shutdown(sock, how);\n\t\tfput_light(sock->file, fput_needed);\n\t}\n\treturn err;\n}\n\n/* A couple of helpful macros for getting the address of the 32/64 bit\n * fields which are the same type (int / unsigned) on our platforms.\n */\n#define COMPAT_MSG(msg, member)\t((MSG_CMSG_COMPAT & flags) ? &msg##_compat->member : &msg->member)\n#define COMPAT_NAMELEN(msg)\tCOMPAT_MSG(msg, msg_namelen)\n#define COMPAT_FLAGS(msg)\tCOMPAT_MSG(msg, msg_flags)\n\nstruct used_address {\n\tstruct sockaddr_storage name;\n\tunsigned int name_len;\n};\n\nstatic int __sys_sendmsg(struct socket *sock, struct msghdr __user *msg,\n\t\t\t struct msghdr *msg_sys, unsigned flags,\n\t\t\t struct used_address *used_address)\n{\n\tstruct compat_msghdr __user *msg_compat =\n\t    (struct compat_msghdr __user *)msg;\n\tstruct sockaddr_storage address;\n\tstruct iovec iovstack[UIO_FASTIOV], *iov = iovstack;\n\tunsigned char ctl[sizeof(struct cmsghdr) + 20]\n\t    __attribute__ ((aligned(sizeof(__kernel_size_t))));\n\t/* 20 is size of ipv6_pktinfo */\n\tunsigned char *ctl_buf = ctl;\n\tint err, ctl_len, iov_size, total_len;\n\n\terr = -EFAULT;\n\tif (MSG_CMSG_COMPAT & flags) {\n\t\tif (get_compat_msghdr(msg_sys, msg_compat))\n\t\t\treturn -EFAULT;\n\t} else if (copy_from_user(msg_sys, msg, sizeof(struct msghdr)))\n\t\treturn -EFAULT;\n\n\t/* do not move before msg_sys is valid */\n\terr = -EMSGSIZE;\n\tif (msg_sys->msg_iovlen > UIO_MAXIOV)\n\t\tgoto out;\n\n\t/* Check whether to allocate the iovec area */\n\terr = -ENOMEM;\n\tiov_size = msg_sys->msg_iovlen * sizeof(struct iovec);\n\tif (msg_sys->msg_iovlen > UIO_FASTIOV) {\n\t\tiov = sock_kmalloc(sock->sk, iov_size, GFP_KERNEL);\n\t\tif (!iov)\n\t\t\tgoto out;\n\t}\n\n\t/* This will also move the address data into kernel space */\n\tif (MSG_CMSG_COMPAT & flags) {\n\t\terr = verify_compat_iovec(msg_sys, iov,\n\t\t\t\t\t  (struct sockaddr *)&address,\n\t\t\t\t\t  VERIFY_READ);\n\t} else\n\t\terr = verify_iovec(msg_sys, iov,\n\t\t\t\t   (struct sockaddr *)&address,\n\t\t\t\t   VERIFY_READ);\n\tif (err < 0)\n\t\tgoto out_freeiov;\n\ttotal_len = err;\n\n\terr = -ENOBUFS;\n\n\tif (msg_sys->msg_controllen > INT_MAX)\n\t\tgoto out_freeiov;\n\tctl_len = msg_sys->msg_controllen;\n\tif ((MSG_CMSG_COMPAT & flags) && ctl_len) {\n\t\terr =\n\t\t    cmsghdr_from_user_compat_to_kern(msg_sys, sock->sk, ctl,\n\t\t\t\t\t\t     sizeof(ctl));\n\t\tif (err)\n\t\t\tgoto out_freeiov;\n\t\tctl_buf = msg_sys->msg_control;\n\t\tctl_len = msg_sys->msg_controllen;\n\t} else if (ctl_len) {\n\t\tif (ctl_len > sizeof(ctl)) {\n\t\t\tctl_buf = sock_kmalloc(sock->sk, ctl_len, GFP_KERNEL);\n\t\t\tif (ctl_buf == NULL)\n\t\t\t\tgoto out_freeiov;\n\t\t}\n\t\terr = -EFAULT;\n\t\t/*\n\t\t * Careful! Before this, msg_sys->msg_control contains a user pointer.\n\t\t * Afterwards, it will be a kernel pointer. Thus the compiler-assisted\n\t\t * checking falls down on this.\n\t\t */\n\t\tif (copy_from_user(ctl_buf,\n\t\t\t\t   (void __user __force *)msg_sys->msg_control,\n\t\t\t\t   ctl_len))\n\t\t\tgoto out_freectl;\n\t\tmsg_sys->msg_control = ctl_buf;\n\t}\n\tmsg_sys->msg_flags = flags;\n\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tmsg_sys->msg_flags |= MSG_DONTWAIT;\n\t/*\n\t * If this is sendmmsg() and current destination address is same as\n\t * previously succeeded address, omit asking LSM's decision.\n\t * used_address->name_len is initialized to UINT_MAX so that the first\n\t * destination address never matches.\n\t */\n\tif (used_address && msg_sys->msg_name &&\n\t    used_address->name_len == msg_sys->msg_namelen &&\n\t    !memcmp(&used_address->name, msg_sys->msg_name,\n\t\t    used_address->name_len)) {\n\t\terr = sock_sendmsg_nosec(sock, msg_sys, total_len);\n\t\tgoto out_freectl;\n\t}\n\terr = sock_sendmsg(sock, msg_sys, total_len);\n\t/*\n\t * If this is sendmmsg() and sending to current destination address was\n\t * successful, remember it.\n\t */\n\tif (used_address && err >= 0) {\n\t\tused_address->name_len = msg_sys->msg_namelen;\n\t\tif (msg_sys->msg_name)\n\t\t\tmemcpy(&used_address->name, msg_sys->msg_name,\n\t\t\t       used_address->name_len);\n\t}\n\nout_freectl:\n\tif (ctl_buf != ctl)\n\t\tsock_kfree_s(sock->sk, ctl_buf, ctl_len);\nout_freeiov:\n\tif (iov != iovstack)\n\t\tsock_kfree_s(sock->sk, iov, iov_size);\nout:\n\treturn err;\n}\n\n/*\n *\tBSD sendmsg interface\n */\n\nSYSCALL_DEFINE3(sendmsg, int, fd, struct msghdr __user *, msg, unsigned, flags)\n{\n\tint fput_needed, err;\n\tstruct msghdr msg_sys;\n\tstruct socket *sock = sockfd_lookup_light(fd, &err, &fput_needed);\n\n\tif (!sock)\n\t\tgoto out;\n\n\terr = __sys_sendmsg(sock, msg, &msg_sys, flags, NULL);\n\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\n/*\n *\tLinux sendmmsg interface\n */\n\nint __sys_sendmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,\n\t\t   unsigned int flags)\n{\n\tint fput_needed, err, datagrams;\n\tstruct socket *sock;\n\tstruct mmsghdr __user *entry;\n\tstruct compat_mmsghdr __user *compat_entry;\n\tstruct msghdr msg_sys;\n\tstruct used_address used_address;\n\n\tif (vlen > UIO_MAXIOV)\n\t\tvlen = UIO_MAXIOV;\n\n\tdatagrams = 0;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\treturn err;\n\n\tused_address.name_len = UINT_MAX;\n\tentry = mmsg;\n\tcompat_entry = (struct compat_mmsghdr __user *)mmsg;\n\terr = 0;\n\n\twhile (datagrams < vlen) {\n\t\tif (MSG_CMSG_COMPAT & flags) {\n\t\t\terr = __sys_sendmsg(sock, (struct msghdr __user *)compat_entry,\n\t\t\t\t\t    &msg_sys, flags, &used_address);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\terr = __put_user(err, &compat_entry->msg_len);\n\t\t\t++compat_entry;\n\t\t} else {\n\t\t\terr = __sys_sendmsg(sock, (struct msghdr __user *)entry,\n\t\t\t\t\t    &msg_sys, flags, &used_address);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\terr = put_user(err, &entry->msg_len);\n\t\t\t++entry;\n\t\t}\n\n\t\tif (err)\n\t\t\tbreak;\n\t\t++datagrams;\n\t}\n\n\tfput_light(sock->file, fput_needed);\n\n\t/* We only return an error if no datagrams were able to be sent */\n\tif (datagrams != 0)\n\t\treturn datagrams;\n\n\treturn err;\n}\n\nSYSCALL_DEFINE4(sendmmsg, int, fd, struct mmsghdr __user *, mmsg,\n\t\tunsigned int, vlen, unsigned int, flags)\n{\n\treturn __sys_sendmmsg(fd, mmsg, vlen, flags);\n}\n\nstatic int __sys_recvmsg(struct socket *sock, struct msghdr __user *msg,\n\t\t\t struct msghdr *msg_sys, unsigned flags, int nosec)\n{\n\tstruct compat_msghdr __user *msg_compat =\n\t    (struct compat_msghdr __user *)msg;\n\tstruct iovec iovstack[UIO_FASTIOV];\n\tstruct iovec *iov = iovstack;\n\tunsigned long cmsg_ptr;\n\tint err, iov_size, total_len, len;\n\n\t/* kernel mode address */\n\tstruct sockaddr_storage addr;\n\n\t/* user mode address pointers */\n\tstruct sockaddr __user *uaddr;\n\tint __user *uaddr_len;\n\n\tif (MSG_CMSG_COMPAT & flags) {\n\t\tif (get_compat_msghdr(msg_sys, msg_compat))\n\t\t\treturn -EFAULT;\n\t} else if (copy_from_user(msg_sys, msg, sizeof(struct msghdr)))\n\t\treturn -EFAULT;\n\n\terr = -EMSGSIZE;\n\tif (msg_sys->msg_iovlen > UIO_MAXIOV)\n\t\tgoto out;\n\n\t/* Check whether to allocate the iovec area */\n\terr = -ENOMEM;\n\tiov_size = msg_sys->msg_iovlen * sizeof(struct iovec);\n\tif (msg_sys->msg_iovlen > UIO_FASTIOV) {\n\t\tiov = sock_kmalloc(sock->sk, iov_size, GFP_KERNEL);\n\t\tif (!iov)\n\t\t\tgoto out;\n\t}\n\n\t/*\n\t *      Save the user-mode address (verify_iovec will change the\n\t *      kernel msghdr to use the kernel address space)\n\t */\n\n\tuaddr = (__force void __user *)msg_sys->msg_name;\n\tuaddr_len = COMPAT_NAMELEN(msg);\n\tif (MSG_CMSG_COMPAT & flags) {\n\t\terr = verify_compat_iovec(msg_sys, iov,\n\t\t\t\t\t  (struct sockaddr *)&addr,\n\t\t\t\t\t  VERIFY_WRITE);\n\t} else\n\t\terr = verify_iovec(msg_sys, iov,\n\t\t\t\t   (struct sockaddr *)&addr,\n\t\t\t\t   VERIFY_WRITE);\n\tif (err < 0)\n\t\tgoto out_freeiov;\n\ttotal_len = err;\n\n\tcmsg_ptr = (unsigned long)msg_sys->msg_control;\n\tmsg_sys->msg_flags = flags & (MSG_CMSG_CLOEXEC|MSG_CMSG_COMPAT);\n\n\tif (sock->file->f_flags & O_NONBLOCK)\n\t\tflags |= MSG_DONTWAIT;\n\terr = (nosec ? sock_recvmsg_nosec : sock_recvmsg)(sock, msg_sys,\n\t\t\t\t\t\t\t  total_len, flags);\n\tif (err < 0)\n\t\tgoto out_freeiov;\n\tlen = err;\n\n\tif (uaddr != NULL) {\n\t\terr = move_addr_to_user((struct sockaddr *)&addr,\n\t\t\t\t\tmsg_sys->msg_namelen, uaddr,\n\t\t\t\t\tuaddr_len);\n\t\tif (err < 0)\n\t\t\tgoto out_freeiov;\n\t}\n\terr = __put_user((msg_sys->msg_flags & ~MSG_CMSG_COMPAT),\n\t\t\t COMPAT_FLAGS(msg));\n\tif (err)\n\t\tgoto out_freeiov;\n\tif (MSG_CMSG_COMPAT & flags)\n\t\terr = __put_user((unsigned long)msg_sys->msg_control - cmsg_ptr,\n\t\t\t\t &msg_compat->msg_controllen);\n\telse\n\t\terr = __put_user((unsigned long)msg_sys->msg_control - cmsg_ptr,\n\t\t\t\t &msg->msg_controllen);\n\tif (err)\n\t\tgoto out_freeiov;\n\terr = len;\n\nout_freeiov:\n\tif (iov != iovstack)\n\t\tsock_kfree_s(sock->sk, iov, iov_size);\nout:\n\treturn err;\n}\n\n/*\n *\tBSD recvmsg interface\n */\n\nSYSCALL_DEFINE3(recvmsg, int, fd, struct msghdr __user *, msg,\n\t\tunsigned int, flags)\n{\n\tint fput_needed, err;\n\tstruct msghdr msg_sys;\n\tstruct socket *sock = sockfd_lookup_light(fd, &err, &fput_needed);\n\n\tif (!sock)\n\t\tgoto out;\n\n\terr = __sys_recvmsg(sock, msg, &msg_sys, flags, 0);\n\n\tfput_light(sock->file, fput_needed);\nout:\n\treturn err;\n}\n\n/*\n *     Linux recvmmsg interface\n */\n\nint __sys_recvmmsg(int fd, struct mmsghdr __user *mmsg, unsigned int vlen,\n\t\t   unsigned int flags, struct timespec *timeout)\n{\n\tint fput_needed, err, datagrams;\n\tstruct socket *sock;\n\tstruct mmsghdr __user *entry;\n\tstruct compat_mmsghdr __user *compat_entry;\n\tstruct msghdr msg_sys;\n\tstruct timespec end_time;\n\n\tif (timeout &&\n\t    poll_select_set_timeout(&end_time, timeout->tv_sec,\n\t\t\t\t    timeout->tv_nsec))\n\t\treturn -EINVAL;\n\n\tdatagrams = 0;\n\n\tsock = sockfd_lookup_light(fd, &err, &fput_needed);\n\tif (!sock)\n\t\treturn err;\n\n\terr = sock_error(sock->sk);\n\tif (err)\n\t\tgoto out_put;\n\n\tentry = mmsg;\n\tcompat_entry = (struct compat_mmsghdr __user *)mmsg;\n\n\twhile (datagrams < vlen) {\n\t\t/*\n\t\t * No need to ask LSM for more than the first datagram.\n\t\t */\n\t\tif (MSG_CMSG_COMPAT & flags) {\n\t\t\terr = __sys_recvmsg(sock, (struct msghdr __user *)compat_entry,\n\t\t\t\t\t    &msg_sys, flags & ~MSG_WAITFORONE,\n\t\t\t\t\t    datagrams);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\terr = __put_user(err, &compat_entry->msg_len);\n\t\t\t++compat_entry;\n\t\t} else {\n\t\t\terr = __sys_recvmsg(sock, (struct msghdr __user *)entry,\n\t\t\t\t\t    &msg_sys, flags & ~MSG_WAITFORONE,\n\t\t\t\t\t    datagrams);\n\t\t\tif (err < 0)\n\t\t\t\tbreak;\n\t\t\terr = put_user(err, &entry->msg_len);\n\t\t\t++entry;\n\t\t}\n\n\t\tif (err)\n\t\t\tbreak;\n\t\t++datagrams;\n\n\t\t/* MSG_WAITFORONE turns on MSG_DONTWAIT after one packet */\n\t\tif (flags & MSG_WAITFORONE)\n\t\t\tflags |= MSG_DONTWAIT;\n\n\t\tif (timeout) {\n\t\t\tktime_get_ts(timeout);\n\t\t\t*timeout = timespec_sub(end_time, *timeout);\n\t\t\tif (timeout->tv_sec < 0) {\n\t\t\t\ttimeout->tv_sec = timeout->tv_nsec = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t/* Timeout, return less than vlen datagrams */\n\t\t\tif (timeout->tv_nsec == 0 && timeout->tv_sec == 0)\n\t\t\t\tbreak;\n\t\t}\n\n\t\t/* Out of band data, return right away */\n\t\tif (msg_sys.msg_flags & MSG_OOB)\n\t\t\tbreak;\n\t}\n\nout_put:\n\tfput_light(sock->file, fput_needed);\n\n\tif (err == 0)\n\t\treturn datagrams;\n\n\tif (datagrams != 0) {\n\t\t/*\n\t\t * We may return less entries than requested (vlen) if the\n\t\t * sock is non block and there aren't enough datagrams...\n\t\t */\n\t\tif (err != -EAGAIN) {\n\t\t\t/*\n\t\t\t * ... or  if recvmsg returns an error after we\n\t\t\t * received some datagrams, where we record the\n\t\t\t * error to return on the next call or if the\n\t\t\t * app asks about it using getsockopt(SO_ERROR).\n\t\t\t */\n\t\t\tsock->sk->sk_err = -err;\n\t\t}\n\n\t\treturn datagrams;\n\t}\n\n\treturn err;\n}\n\nSYSCALL_DEFINE5(recvmmsg, int, fd, struct mmsghdr __user *, mmsg,\n\t\tunsigned int, vlen, unsigned int, flags,\n\t\tstruct timespec __user *, timeout)\n{\n\tint datagrams;\n\tstruct timespec timeout_sys;\n\n\tif (!timeout)\n\t\treturn __sys_recvmmsg(fd, mmsg, vlen, flags, NULL);\n\n\tif (copy_from_user(&timeout_sys, timeout, sizeof(timeout_sys)))\n\t\treturn -EFAULT;\n\n\tdatagrams = __sys_recvmmsg(fd, mmsg, vlen, flags, &timeout_sys);\n\n\tif (datagrams > 0 &&\n\t    copy_to_user(timeout, &timeout_sys, sizeof(timeout_sys)))\n\t\tdatagrams = -EFAULT;\n\n\treturn datagrams;\n}\n\n#ifdef __ARCH_WANT_SYS_SOCKETCALL\n/* Argument list sizes for sys_socketcall */\n#define AL(x) ((x) * sizeof(unsigned long))\nstatic const unsigned char nargs[21] = {\n\tAL(0), AL(3), AL(3), AL(3), AL(2), AL(3),\n\tAL(3), AL(3), AL(4), AL(4), AL(4), AL(6),\n\tAL(6), AL(2), AL(5), AL(5), AL(3), AL(3),\n\tAL(4), AL(5), AL(4)\n};\n\n#undef AL\n\n/*\n *\tSystem call vectors.\n *\n *\tArgument checking cleaned up. Saved 20% in size.\n *  This function doesn't need to set the kernel lock because\n *  it is set by the callees.\n */\n\nSYSCALL_DEFINE2(socketcall, int, call, unsigned long __user *, args)\n{\n\tunsigned long a[6];\n\tunsigned long a0, a1;\n\tint err;\n\tunsigned int len;\n\n\tif (call < 1 || call > SYS_SENDMMSG)\n\t\treturn -EINVAL;\n\n\tlen = nargs[call];\n\tif (len > sizeof(a))\n\t\treturn -EINVAL;\n\n\t/* copy_from_user should be SMP safe. */\n\tif (copy_from_user(a, args, len))\n\t\treturn -EFAULT;\n\n\taudit_socketcall(nargs[call] / sizeof(unsigned long), a);\n\n\ta0 = a[0];\n\ta1 = a[1];\n\n\tswitch (call) {\n\tcase SYS_SOCKET:\n\t\terr = sys_socket(a0, a1, a[2]);\n\t\tbreak;\n\tcase SYS_BIND:\n\t\terr = sys_bind(a0, (struct sockaddr __user *)a1, a[2]);\n\t\tbreak;\n\tcase SYS_CONNECT:\n\t\terr = sys_connect(a0, (struct sockaddr __user *)a1, a[2]);\n\t\tbreak;\n\tcase SYS_LISTEN:\n\t\terr = sys_listen(a0, a1);\n\t\tbreak;\n\tcase SYS_ACCEPT:\n\t\terr = sys_accept4(a0, (struct sockaddr __user *)a1,\n\t\t\t\t  (int __user *)a[2], 0);\n\t\tbreak;\n\tcase SYS_GETSOCKNAME:\n\t\terr =\n\t\t    sys_getsockname(a0, (struct sockaddr __user *)a1,\n\t\t\t\t    (int __user *)a[2]);\n\t\tbreak;\n\tcase SYS_GETPEERNAME:\n\t\terr =\n\t\t    sys_getpeername(a0, (struct sockaddr __user *)a1,\n\t\t\t\t    (int __user *)a[2]);\n\t\tbreak;\n\tcase SYS_SOCKETPAIR:\n\t\terr = sys_socketpair(a0, a1, a[2], (int __user *)a[3]);\n\t\tbreak;\n\tcase SYS_SEND:\n\t\terr = sys_send(a0, (void __user *)a1, a[2], a[3]);\n\t\tbreak;\n\tcase SYS_SENDTO:\n\t\terr = sys_sendto(a0, (void __user *)a1, a[2], a[3],\n\t\t\t\t (struct sockaddr __user *)a[4], a[5]);\n\t\tbreak;\n\tcase SYS_RECV:\n\t\terr = sys_recv(a0, (void __user *)a1, a[2], a[3]);\n\t\tbreak;\n\tcase SYS_RECVFROM:\n\t\terr = sys_recvfrom(a0, (void __user *)a1, a[2], a[3],\n\t\t\t\t   (struct sockaddr __user *)a[4],\n\t\t\t\t   (int __user *)a[5]);\n\t\tbreak;\n\tcase SYS_SHUTDOWN:\n\t\terr = sys_shutdown(a0, a1);\n\t\tbreak;\n\tcase SYS_SETSOCKOPT:\n\t\terr = sys_setsockopt(a0, a1, a[2], (char __user *)a[3], a[4]);\n\t\tbreak;\n\tcase SYS_GETSOCKOPT:\n\t\terr =\n\t\t    sys_getsockopt(a0, a1, a[2], (char __user *)a[3],\n\t\t\t\t   (int __user *)a[4]);\n\t\tbreak;\n\tcase SYS_SENDMSG:\n\t\terr = sys_sendmsg(a0, (struct msghdr __user *)a1, a[2]);\n\t\tbreak;\n\tcase SYS_SENDMMSG:\n\t\terr = sys_sendmmsg(a0, (struct mmsghdr __user *)a1, a[2], a[3]);\n\t\tbreak;\n\tcase SYS_RECVMSG:\n\t\terr = sys_recvmsg(a0, (struct msghdr __user *)a1, a[2]);\n\t\tbreak;\n\tcase SYS_RECVMMSG:\n\t\terr = sys_recvmmsg(a0, (struct mmsghdr __user *)a1, a[2], a[3],\n\t\t\t\t   (struct timespec __user *)a[4]);\n\t\tbreak;\n\tcase SYS_ACCEPT4:\n\t\terr = sys_accept4(a0, (struct sockaddr __user *)a1,\n\t\t\t\t  (int __user *)a[2], a[3]);\n\t\tbreak;\n\tdefault:\n\t\terr = -EINVAL;\n\t\tbreak;\n\t}\n\treturn err;\n}\n\n#endif\t\t\t\t/* __ARCH_WANT_SYS_SOCKETCALL */\n\n/**\n *\tsock_register - add a socket protocol handler\n *\t@ops: description of protocol\n *\n *\tThis function is called by a protocol handler that wants to\n *\tadvertise its address family, and have it linked into the\n *\tsocket interface. The value ops->family coresponds to the\n *\tsocket system call protocol family.\n */\nint sock_register(const struct net_proto_family *ops)\n{\n\tint err;\n\n\tif (ops->family >= NPROTO) {\n\t\tprintk(KERN_CRIT \"protocol %d >= NPROTO(%d)\\n\", ops->family,\n\t\t       NPROTO);\n\t\treturn -ENOBUFS;\n\t}\n\n\tspin_lock(&net_family_lock);\n\tif (rcu_dereference_protected(net_families[ops->family],\n\t\t\t\t      lockdep_is_held(&net_family_lock)))\n\t\terr = -EEXIST;\n\telse {\n\t\trcu_assign_pointer(net_families[ops->family], ops);\n\t\terr = 0;\n\t}\n\tspin_unlock(&net_family_lock);\n\n\tprintk(KERN_INFO \"NET: Registered protocol family %d\\n\", ops->family);\n\treturn err;\n}\nEXPORT_SYMBOL(sock_register);\n\n/**\n *\tsock_unregister - remove a protocol handler\n *\t@family: protocol family to remove\n *\n *\tThis function is called by a protocol handler that wants to\n *\tremove its address family, and have it unlinked from the\n *\tnew socket creation.\n *\n *\tIf protocol handler is a module, then it can use module reference\n *\tcounts to protect against new references. If protocol handler is not\n *\ta module then it needs to provide its own protection in\n *\tthe ops->create routine.\n */\nvoid sock_unregister(int family)\n{\n\tBUG_ON(family < 0 || family >= NPROTO);\n\n\tspin_lock(&net_family_lock);\n\trcu_assign_pointer(net_families[family], NULL);\n\tspin_unlock(&net_family_lock);\n\n\tsynchronize_rcu();\n\n\tprintk(KERN_INFO \"NET: Unregistered protocol family %d\\n\", family);\n}\nEXPORT_SYMBOL(sock_unregister);\n\nstatic int __init sock_init(void)\n{\n\tint err;\n\n\t/*\n\t *      Initialize sock SLAB cache.\n\t */\n\n\tsk_init();\n\n\t/*\n\t *      Initialize skbuff SLAB cache\n\t */\n\tskb_init();\n\n\t/*\n\t *      Initialize the protocols module.\n\t */\n\n\tinit_inodecache();\n\n\terr = register_filesystem(&sock_fs_type);\n\tif (err)\n\t\tgoto out_fs;\n\tsock_mnt = kern_mount(&sock_fs_type);\n\tif (IS_ERR(sock_mnt)) {\n\t\terr = PTR_ERR(sock_mnt);\n\t\tgoto out_mount;\n\t}\n\n\t/* The real protocol initialization is performed in later initcalls.\n\t */\n\n#ifdef CONFIG_NETFILTER\n\tnetfilter_init();\n#endif\n\n#ifdef CONFIG_NETWORK_PHY_TIMESTAMPING\n\tskb_timestamping_init();\n#endif\n\nout:\n\treturn err;\n\nout_mount:\n\tunregister_filesystem(&sock_fs_type);\nout_fs:\n\tgoto out;\n}\n\ncore_initcall(sock_init);\t/* early initcall */\n\n#ifdef CONFIG_PROC_FS\nvoid socket_seq_show(struct seq_file *seq)\n{\n\tint cpu;\n\tint counter = 0;\n\n\tfor_each_possible_cpu(cpu)\n\t    counter += per_cpu(sockets_in_use, cpu);\n\n\t/* It can be negative, by the way. 8) */\n\tif (counter < 0)\n\t\tcounter = 0;\n\n\tseq_printf(seq, \"sockets: used %d\\n\", counter);\n}\n#endif\t\t\t\t/* CONFIG_PROC_FS */\n\n#ifdef CONFIG_COMPAT\nstatic int do_siocgstamp(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, struct compat_timeval __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timeval ktv;\n\tint err;\n\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&ktv);\n\tset_fs(old_fs);\n\tif (!err) {\n\t\terr = put_user(ktv.tv_sec, &up->tv_sec);\n\t\terr |= __put_user(ktv.tv_usec, &up->tv_usec);\n\t}\n\treturn err;\n}\n\nstatic int do_siocgstampns(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, struct compat_timespec __user *up)\n{\n\tmm_segment_t old_fs = get_fs();\n\tstruct timespec kts;\n\tint err;\n\n\tset_fs(KERNEL_DS);\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)&kts);\n\tset_fs(old_fs);\n\tif (!err) {\n\t\terr = put_user(kts.tv_sec, &up->tv_sec);\n\t\terr |= __put_user(kts.tv_nsec, &up->tv_nsec);\n\t}\n\treturn err;\n}\n\nstatic int dev_ifname32(struct net *net, struct compat_ifreq __user *uifr32)\n{\n\tstruct ifreq __user *uifr;\n\tint err;\n\n\tuifr = compat_alloc_user_space(sizeof(struct ifreq));\n\tif (copy_in_user(uifr, uifr32, sizeof(struct compat_ifreq)))\n\t\treturn -EFAULT;\n\n\terr = dev_ioctl(net, SIOCGIFNAME, uifr);\n\tif (err)\n\t\treturn err;\n\n\tif (copy_in_user(uifr32, uifr, sizeof(struct compat_ifreq)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int dev_ifconf(struct net *net, struct compat_ifconf __user *uifc32)\n{\n\tstruct compat_ifconf ifc32;\n\tstruct ifconf ifc;\n\tstruct ifconf __user *uifc;\n\tstruct compat_ifreq __user *ifr32;\n\tstruct ifreq __user *ifr;\n\tunsigned int i, j;\n\tint err;\n\n\tif (copy_from_user(&ifc32, uifc32, sizeof(struct compat_ifconf)))\n\t\treturn -EFAULT;\n\n\tif (ifc32.ifcbuf == 0) {\n\t\tifc32.ifc_len = 0;\n\t\tifc.ifc_len = 0;\n\t\tifc.ifc_req = NULL;\n\t\tuifc = compat_alloc_user_space(sizeof(struct ifconf));\n\t} else {\n\t\tsize_t len = ((ifc32.ifc_len / sizeof(struct compat_ifreq)) + 1) *\n\t\t\tsizeof(struct ifreq);\n\t\tuifc = compat_alloc_user_space(sizeof(struct ifconf) + len);\n\t\tifc.ifc_len = len;\n\t\tifr = ifc.ifc_req = (void __user *)(uifc + 1);\n\t\tifr32 = compat_ptr(ifc32.ifcbuf);\n\t\tfor (i = 0; i < ifc32.ifc_len; i += sizeof(struct compat_ifreq)) {\n\t\t\tif (copy_in_user(ifr, ifr32, sizeof(struct compat_ifreq)))\n\t\t\t\treturn -EFAULT;\n\t\t\tifr++;\n\t\t\tifr32++;\n\t\t}\n\t}\n\tif (copy_to_user(uifc, &ifc, sizeof(struct ifconf)))\n\t\treturn -EFAULT;\n\n\terr = dev_ioctl(net, SIOCGIFCONF, uifc);\n\tif (err)\n\t\treturn err;\n\n\tif (copy_from_user(&ifc, uifc, sizeof(struct ifconf)))\n\t\treturn -EFAULT;\n\n\tifr = ifc.ifc_req;\n\tifr32 = compat_ptr(ifc32.ifcbuf);\n\tfor (i = 0, j = 0;\n\t     i + sizeof(struct compat_ifreq) <= ifc32.ifc_len && j < ifc.ifc_len;\n\t     i += sizeof(struct compat_ifreq), j += sizeof(struct ifreq)) {\n\t\tif (copy_in_user(ifr32, ifr, sizeof(struct compat_ifreq)))\n\t\t\treturn -EFAULT;\n\t\tifr32++;\n\t\tifr++;\n\t}\n\n\tif (ifc32.ifcbuf == 0) {\n\t\t/* Translate from 64-bit structure multiple to\n\t\t * a 32-bit one.\n\t\t */\n\t\ti = ifc.ifc_len;\n\t\ti = ((i / sizeof(struct ifreq)) * sizeof(struct compat_ifreq));\n\t\tifc32.ifc_len = i;\n\t} else {\n\t\tifc32.ifc_len = i;\n\t}\n\tif (copy_to_user(uifc32, &ifc32, sizeof(struct compat_ifconf)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}\n\nstatic int ethtool_ioctl(struct net *net, struct compat_ifreq __user *ifr32)\n{\n\tstruct compat_ethtool_rxnfc __user *compat_rxnfc;\n\tbool convert_in = false, convert_out = false;\n\tsize_t buf_size = ALIGN(sizeof(struct ifreq), 8);\n\tstruct ethtool_rxnfc __user *rxnfc;\n\tstruct ifreq __user *ifr;\n\tu32 rule_cnt = 0, actual_rule_cnt;\n\tu32 ethcmd;\n\tu32 data;\n\tint ret;\n\n\tif (get_user(data, &ifr32->ifr_ifru.ifru_data))\n\t\treturn -EFAULT;\n\n\tcompat_rxnfc = compat_ptr(data);\n\n\tif (get_user(ethcmd, &compat_rxnfc->cmd))\n\t\treturn -EFAULT;\n\n\t/* Most ethtool structures are defined without padding.\n\t * Unfortunately struct ethtool_rxnfc is an exception.\n\t */\n\tswitch (ethcmd) {\n\tdefault:\n\t\tbreak;\n\tcase ETHTOOL_GRXCLSRLALL:\n\t\t/* Buffer size is variable */\n\t\tif (get_user(rule_cnt, &compat_rxnfc->rule_cnt))\n\t\t\treturn -EFAULT;\n\t\tif (rule_cnt > KMALLOC_MAX_SIZE / sizeof(u32))\n\t\t\treturn -ENOMEM;\n\t\tbuf_size += rule_cnt * sizeof(u32);\n\t\t/* fall through */\n\tcase ETHTOOL_GRXRINGS:\n\tcase ETHTOOL_GRXCLSRLCNT:\n\tcase ETHTOOL_GRXCLSRULE:\n\t\tconvert_out = true;\n\t\t/* fall through */\n\tcase ETHTOOL_SRXCLSRLDEL:\n\tcase ETHTOOL_SRXCLSRLINS:\n\t\tbuf_size += sizeof(struct ethtool_rxnfc);\n\t\tconvert_in = true;\n\t\tbreak;\n\t}\n\n\tifr = compat_alloc_user_space(buf_size);\n\trxnfc = (void *)ifr + ALIGN(sizeof(struct ifreq), 8);\n\n\tif (copy_in_user(&ifr->ifr_name, &ifr32->ifr_name, IFNAMSIZ))\n\t\treturn -EFAULT;\n\n\tif (put_user(convert_in ? rxnfc : compat_ptr(data),\n\t\t     &ifr->ifr_ifru.ifru_data))\n\t\treturn -EFAULT;\n\n\tif (convert_in) {\n\t\t/* We expect there to be holes between fs.m_ext and\n\t\t * fs.ring_cookie and at the end of fs, but nowhere else.\n\t\t */\n\t\tBUILD_BUG_ON(offsetof(struct compat_ethtool_rxnfc, fs.m_ext) +\n\t\t\t     sizeof(compat_rxnfc->fs.m_ext) !=\n\t\t\t     offsetof(struct ethtool_rxnfc, fs.m_ext) +\n\t\t\t     sizeof(rxnfc->fs.m_ext));\n\t\tBUILD_BUG_ON(\n\t\t\toffsetof(struct compat_ethtool_rxnfc, fs.location) -\n\t\t\toffsetof(struct compat_ethtool_rxnfc, fs.ring_cookie) !=\n\t\t\toffsetof(struct ethtool_rxnfc, fs.location) -\n\t\t\toffsetof(struct ethtool_rxnfc, fs.ring_cookie));\n\n\t\tif (copy_in_user(rxnfc, compat_rxnfc,\n\t\t\t\t (void *)(&rxnfc->fs.m_ext + 1) -\n\t\t\t\t (void *)rxnfc) ||\n\t\t    copy_in_user(&rxnfc->fs.ring_cookie,\n\t\t\t\t &compat_rxnfc->fs.ring_cookie,\n\t\t\t\t (void *)(&rxnfc->fs.location + 1) -\n\t\t\t\t (void *)&rxnfc->fs.ring_cookie) ||\n\t\t    copy_in_user(&rxnfc->rule_cnt, &compat_rxnfc->rule_cnt,\n\t\t\t\t sizeof(rxnfc->rule_cnt)))\n\t\t\treturn -EFAULT;\n\t}\n\n\tret = dev_ioctl(net, SIOCETHTOOL, ifr);\n\tif (ret)\n\t\treturn ret;\n\n\tif (convert_out) {\n\t\tif (copy_in_user(compat_rxnfc, rxnfc,\n\t\t\t\t (const void *)(&rxnfc->fs.m_ext + 1) -\n\t\t\t\t (const void *)rxnfc) ||\n\t\t    copy_in_user(&compat_rxnfc->fs.ring_cookie,\n\t\t\t\t &rxnfc->fs.ring_cookie,\n\t\t\t\t (const void *)(&rxnfc->fs.location + 1) -\n\t\t\t\t (const void *)&rxnfc->fs.ring_cookie) ||\n\t\t    copy_in_user(&compat_rxnfc->rule_cnt, &rxnfc->rule_cnt,\n\t\t\t\t sizeof(rxnfc->rule_cnt)))\n\t\t\treturn -EFAULT;\n\n\t\tif (ethcmd == ETHTOOL_GRXCLSRLALL) {\n\t\t\t/* As an optimisation, we only copy the actual\n\t\t\t * number of rules that the underlying\n\t\t\t * function returned.  Since Mallory might\n\t\t\t * change the rule count in user memory, we\n\t\t\t * check that it is less than the rule count\n\t\t\t * originally given (as the user buffer size),\n\t\t\t * which has been range-checked.\n\t\t\t */\n\t\t\tif (get_user(actual_rule_cnt, &rxnfc->rule_cnt))\n\t\t\t\treturn -EFAULT;\n\t\t\tif (actual_rule_cnt < rule_cnt)\n\t\t\t\trule_cnt = actual_rule_cnt;\n\t\t\tif (copy_in_user(&compat_rxnfc->rule_locs[0],\n\t\t\t\t\t &rxnfc->rule_locs[0],\n\t\t\t\t\t rule_cnt * sizeof(u32)))\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int compat_siocwandev(struct net *net, struct compat_ifreq __user *uifr32)\n{\n\tvoid __user *uptr;\n\tcompat_uptr_t uptr32;\n\tstruct ifreq __user *uifr;\n\n\tuifr = compat_alloc_user_space(sizeof(*uifr));\n\tif (copy_in_user(uifr, uifr32, sizeof(struct compat_ifreq)))\n\t\treturn -EFAULT;\n\n\tif (get_user(uptr32, &uifr32->ifr_settings.ifs_ifsu))\n\t\treturn -EFAULT;\n\n\tuptr = compat_ptr(uptr32);\n\n\tif (put_user(uptr, &uifr->ifr_settings.ifs_ifsu.raw_hdlc))\n\t\treturn -EFAULT;\n\n\treturn dev_ioctl(net, SIOCWANDEV, uifr);\n}\n\nstatic int bond_ioctl(struct net *net, unsigned int cmd,\n\t\t\t struct compat_ifreq __user *ifr32)\n{\n\tstruct ifreq kifr;\n\tstruct ifreq __user *uifr;\n\tmm_segment_t old_fs;\n\tint err;\n\tu32 data;\n\tvoid __user *datap;\n\n\tswitch (cmd) {\n\tcase SIOCBONDENSLAVE:\n\tcase SIOCBONDRELEASE:\n\tcase SIOCBONDSETHWADDR:\n\tcase SIOCBONDCHANGEACTIVE:\n\t\tif (copy_from_user(&kifr, ifr32, sizeof(struct compat_ifreq)))\n\t\t\treturn -EFAULT;\n\n\t\told_fs = get_fs();\n\t\tset_fs(KERNEL_DS);\n\t\terr = dev_ioctl(net, cmd,\n\t\t\t\t(struct ifreq __user __force *) &kifr);\n\t\tset_fs(old_fs);\n\n\t\treturn err;\n\tcase SIOCBONDSLAVEINFOQUERY:\n\tcase SIOCBONDINFOQUERY:\n\t\tuifr = compat_alloc_user_space(sizeof(*uifr));\n\t\tif (copy_in_user(&uifr->ifr_name, &ifr32->ifr_name, IFNAMSIZ))\n\t\t\treturn -EFAULT;\n\n\t\tif (get_user(data, &ifr32->ifr_ifru.ifru_data))\n\t\t\treturn -EFAULT;\n\n\t\tdatap = compat_ptr(data);\n\t\tif (put_user(datap, &uifr->ifr_ifru.ifru_data))\n\t\t\treturn -EFAULT;\n\n\t\treturn dev_ioctl(net, cmd, uifr);\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n}\n\nstatic int siocdevprivate_ioctl(struct net *net, unsigned int cmd,\n\t\t\t\t struct compat_ifreq __user *u_ifreq32)\n{\n\tstruct ifreq __user *u_ifreq64;\n\tchar tmp_buf[IFNAMSIZ];\n\tvoid __user *data64;\n\tu32 data32;\n\n\tif (copy_from_user(&tmp_buf[0], &(u_ifreq32->ifr_ifrn.ifrn_name[0]),\n\t\t\t   IFNAMSIZ))\n\t\treturn -EFAULT;\n\tif (__get_user(data32, &u_ifreq32->ifr_ifru.ifru_data))\n\t\treturn -EFAULT;\n\tdata64 = compat_ptr(data32);\n\n\tu_ifreq64 = compat_alloc_user_space(sizeof(*u_ifreq64));\n\n\t/* Don't check these user accesses, just let that get trapped\n\t * in the ioctl handler instead.\n\t */\n\tif (copy_to_user(&u_ifreq64->ifr_ifrn.ifrn_name[0], &tmp_buf[0],\n\t\t\t IFNAMSIZ))\n\t\treturn -EFAULT;\n\tif (__put_user(data64, &u_ifreq64->ifr_ifru.ifru_data))\n\t\treturn -EFAULT;\n\n\treturn dev_ioctl(net, cmd, u_ifreq64);\n}\n\nstatic int dev_ifsioc(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, struct compat_ifreq __user *uifr32)\n{\n\tstruct ifreq __user *uifr;\n\tint err;\n\n\tuifr = compat_alloc_user_space(sizeof(*uifr));\n\tif (copy_in_user(uifr, uifr32, sizeof(*uifr32)))\n\t\treturn -EFAULT;\n\n\terr = sock_do_ioctl(net, sock, cmd, (unsigned long)uifr);\n\n\tif (!err) {\n\t\tswitch (cmd) {\n\t\tcase SIOCGIFFLAGS:\n\t\tcase SIOCGIFMETRIC:\n\t\tcase SIOCGIFMTU:\n\t\tcase SIOCGIFMEM:\n\t\tcase SIOCGIFHWADDR:\n\t\tcase SIOCGIFINDEX:\n\t\tcase SIOCGIFADDR:\n\t\tcase SIOCGIFBRDADDR:\n\t\tcase SIOCGIFDSTADDR:\n\t\tcase SIOCGIFNETMASK:\n\t\tcase SIOCGIFPFLAGS:\n\t\tcase SIOCGIFTXQLEN:\n\t\tcase SIOCGMIIPHY:\n\t\tcase SIOCGMIIREG:\n\t\t\tif (copy_in_user(uifr32, uifr, sizeof(*uifr32)))\n\t\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn err;\n}\n\nstatic int compat_sioc_ifmap(struct net *net, unsigned int cmd,\n\t\t\tstruct compat_ifreq __user *uifr32)\n{\n\tstruct ifreq ifr;\n\tstruct compat_ifmap __user *uifmap32;\n\tmm_segment_t old_fs;\n\tint err;\n\n\tuifmap32 = &uifr32->ifr_ifru.ifru_map;\n\terr = copy_from_user(&ifr, uifr32, sizeof(ifr.ifr_name));\n\terr |= __get_user(ifr.ifr_map.mem_start, &uifmap32->mem_start);\n\terr |= __get_user(ifr.ifr_map.mem_end, &uifmap32->mem_end);\n\terr |= __get_user(ifr.ifr_map.base_addr, &uifmap32->base_addr);\n\terr |= __get_user(ifr.ifr_map.irq, &uifmap32->irq);\n\terr |= __get_user(ifr.ifr_map.dma, &uifmap32->dma);\n\terr |= __get_user(ifr.ifr_map.port, &uifmap32->port);\n\tif (err)\n\t\treturn -EFAULT;\n\n\told_fs = get_fs();\n\tset_fs(KERNEL_DS);\n\terr = dev_ioctl(net, cmd, (void  __user __force *)&ifr);\n\tset_fs(old_fs);\n\n\tif (cmd == SIOCGIFMAP && !err) {\n\t\terr = copy_to_user(uifr32, &ifr, sizeof(ifr.ifr_name));\n\t\terr |= __put_user(ifr.ifr_map.mem_start, &uifmap32->mem_start);\n\t\terr |= __put_user(ifr.ifr_map.mem_end, &uifmap32->mem_end);\n\t\terr |= __put_user(ifr.ifr_map.base_addr, &uifmap32->base_addr);\n\t\terr |= __put_user(ifr.ifr_map.irq, &uifmap32->irq);\n\t\terr |= __put_user(ifr.ifr_map.dma, &uifmap32->dma);\n\t\terr |= __put_user(ifr.ifr_map.port, &uifmap32->port);\n\t\tif (err)\n\t\t\terr = -EFAULT;\n\t}\n\treturn err;\n}\n\nstatic int compat_siocshwtstamp(struct net *net, struct compat_ifreq __user *uifr32)\n{\n\tvoid __user *uptr;\n\tcompat_uptr_t uptr32;\n\tstruct ifreq __user *uifr;\n\n\tuifr = compat_alloc_user_space(sizeof(*uifr));\n\tif (copy_in_user(uifr, uifr32, sizeof(struct compat_ifreq)))\n\t\treturn -EFAULT;\n\n\tif (get_user(uptr32, &uifr32->ifr_data))\n\t\treturn -EFAULT;\n\n\tuptr = compat_ptr(uptr32);\n\n\tif (put_user(uptr, &uifr->ifr_data))\n\t\treturn -EFAULT;\n\n\treturn dev_ioctl(net, SIOCSHWTSTAMP, uifr);\n}\n\nstruct rtentry32 {\n\tu32\t\trt_pad1;\n\tstruct sockaddr rt_dst;         /* target address               */\n\tstruct sockaddr rt_gateway;     /* gateway addr (RTF_GATEWAY)   */\n\tstruct sockaddr rt_genmask;     /* target network mask (IP)     */\n\tunsigned short\trt_flags;\n\tshort\t\trt_pad2;\n\tu32\t\trt_pad3;\n\tunsigned char\trt_tos;\n\tunsigned char\trt_class;\n\tshort\t\trt_pad4;\n\tshort\t\trt_metric;      /* +1 for binary compatibility! */\n\t/* char * */ u32 rt_dev;        /* forcing the device at add    */\n\tu32\t\trt_mtu;         /* per route MTU/Window         */\n\tu32\t\trt_window;      /* Window clamping              */\n\tunsigned short  rt_irtt;        /* Initial RTT                  */\n};\n\nstruct in6_rtmsg32 {\n\tstruct in6_addr\t\trtmsg_dst;\n\tstruct in6_addr\t\trtmsg_src;\n\tstruct in6_addr\t\trtmsg_gateway;\n\tu32\t\t\trtmsg_type;\n\tu16\t\t\trtmsg_dst_len;\n\tu16\t\t\trtmsg_src_len;\n\tu32\t\t\trtmsg_metric;\n\tu32\t\t\trtmsg_info;\n\tu32\t\t\trtmsg_flags;\n\ts32\t\t\trtmsg_ifindex;\n};\n\nstatic int routing_ioctl(struct net *net, struct socket *sock,\n\t\t\t unsigned int cmd, void __user *argp)\n{\n\tint ret;\n\tvoid *r = NULL;\n\tstruct in6_rtmsg r6;\n\tstruct rtentry r4;\n\tchar devname[16];\n\tu32 rtdev;\n\tmm_segment_t old_fs = get_fs();\n\n\tif (sock && sock->sk && sock->sk->sk_family == AF_INET6) { /* ipv6 */\n\t\tstruct in6_rtmsg32 __user *ur6 = argp;\n\t\tret = copy_from_user(&r6.rtmsg_dst, &(ur6->rtmsg_dst),\n\t\t\t3 * sizeof(struct in6_addr));\n\t\tret |= __get_user(r6.rtmsg_type, &(ur6->rtmsg_type));\n\t\tret |= __get_user(r6.rtmsg_dst_len, &(ur6->rtmsg_dst_len));\n\t\tret |= __get_user(r6.rtmsg_src_len, &(ur6->rtmsg_src_len));\n\t\tret |= __get_user(r6.rtmsg_metric, &(ur6->rtmsg_metric));\n\t\tret |= __get_user(r6.rtmsg_info, &(ur6->rtmsg_info));\n\t\tret |= __get_user(r6.rtmsg_flags, &(ur6->rtmsg_flags));\n\t\tret |= __get_user(r6.rtmsg_ifindex, &(ur6->rtmsg_ifindex));\n\n\t\tr = (void *) &r6;\n\t} else { /* ipv4 */\n\t\tstruct rtentry32 __user *ur4 = argp;\n\t\tret = copy_from_user(&r4.rt_dst, &(ur4->rt_dst),\n\t\t\t\t\t3 * sizeof(struct sockaddr));\n\t\tret |= __get_user(r4.rt_flags, &(ur4->rt_flags));\n\t\tret |= __get_user(r4.rt_metric, &(ur4->rt_metric));\n\t\tret |= __get_user(r4.rt_mtu, &(ur4->rt_mtu));\n\t\tret |= __get_user(r4.rt_window, &(ur4->rt_window));\n\t\tret |= __get_user(r4.rt_irtt, &(ur4->rt_irtt));\n\t\tret |= __get_user(rtdev, &(ur4->rt_dev));\n\t\tif (rtdev) {\n\t\t\tret |= copy_from_user(devname, compat_ptr(rtdev), 15);\n\t\t\tr4.rt_dev = (char __user __force *)devname;\n\t\t\tdevname[15] = 0;\n\t\t} else\n\t\t\tr4.rt_dev = NULL;\n\n\t\tr = (void *) &r4;\n\t}\n\n\tif (ret) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\n\tset_fs(KERNEL_DS);\n\tret = sock_do_ioctl(net, sock, cmd, (unsigned long) r);\n\tset_fs(old_fs);\n\nout:\n\treturn ret;\n}\n\n/* Since old style bridge ioctl's endup using SIOCDEVPRIVATE\n * for some operations; this forces use of the newer bridge-utils that\n * use compatible ioctls\n */\nstatic int old_bridge_ioctl(compat_ulong_t __user *argp)\n{\n\tcompat_ulong_t tmp;\n\n\tif (get_user(tmp, argp))\n\t\treturn -EFAULT;\n\tif (tmp == BRCTL_GET_VERSION)\n\t\treturn BRCTL_VERSION + 1;\n\treturn -EINVAL;\n}\n\nstatic int compat_sock_ioctl_trans(struct file *file, struct socket *sock,\n\t\t\t unsigned int cmd, unsigned long arg)\n{\n\tvoid __user *argp = compat_ptr(arg);\n\tstruct sock *sk = sock->sk;\n\tstruct net *net = sock_net(sk);\n\n\tif (cmd >= SIOCDEVPRIVATE && cmd <= (SIOCDEVPRIVATE + 15))\n\t\treturn siocdevprivate_ioctl(net, cmd, argp);\n\n\tswitch (cmd) {\n\tcase SIOCSIFBR:\n\tcase SIOCGIFBR:\n\t\treturn old_bridge_ioctl(argp);\n\tcase SIOCGIFNAME:\n\t\treturn dev_ifname32(net, argp);\n\tcase SIOCGIFCONF:\n\t\treturn dev_ifconf(net, argp);\n\tcase SIOCETHTOOL:\n\t\treturn ethtool_ioctl(net, argp);\n\tcase SIOCWANDEV:\n\t\treturn compat_siocwandev(net, argp);\n\tcase SIOCGIFMAP:\n\tcase SIOCSIFMAP:\n\t\treturn compat_sioc_ifmap(net, cmd, argp);\n\tcase SIOCBONDENSLAVE:\n\tcase SIOCBONDRELEASE:\n\tcase SIOCBONDSETHWADDR:\n\tcase SIOCBONDSLAVEINFOQUERY:\n\tcase SIOCBONDINFOQUERY:\n\tcase SIOCBONDCHANGEACTIVE:\n\t\treturn bond_ioctl(net, cmd, argp);\n\tcase SIOCADDRT:\n\tcase SIOCDELRT:\n\t\treturn routing_ioctl(net, sock, cmd, argp);\n\tcase SIOCGSTAMP:\n\t\treturn do_siocgstamp(net, sock, cmd, argp);\n\tcase SIOCGSTAMPNS:\n\t\treturn do_siocgstampns(net, sock, cmd, argp);\n\tcase SIOCSHWTSTAMP:\n\t\treturn compat_siocshwtstamp(net, argp);\n\n\tcase FIOSETOWN:\n\tcase SIOCSPGRP:\n\tcase FIOGETOWN:\n\tcase SIOCGPGRP:\n\tcase SIOCBRADDBR:\n\tcase SIOCBRDELBR:\n\tcase SIOCGIFVLAN:\n\tcase SIOCSIFVLAN:\n\tcase SIOCADDDLCI:\n\tcase SIOCDELDLCI:\n\t\treturn sock_ioctl(file, cmd, arg);\n\n\tcase SIOCGIFFLAGS:\n\tcase SIOCSIFFLAGS:\n\tcase SIOCGIFMETRIC:\n\tcase SIOCSIFMETRIC:\n\tcase SIOCGIFMTU:\n\tcase SIOCSIFMTU:\n\tcase SIOCGIFMEM:\n\tcase SIOCSIFMEM:\n\tcase SIOCGIFHWADDR:\n\tcase SIOCSIFHWADDR:\n\tcase SIOCADDMULTI:\n\tcase SIOCDELMULTI:\n\tcase SIOCGIFINDEX:\n\tcase SIOCGIFADDR:\n\tcase SIOCSIFADDR:\n\tcase SIOCSIFHWBROADCAST:\n\tcase SIOCDIFADDR:\n\tcase SIOCGIFBRDADDR:\n\tcase SIOCSIFBRDADDR:\n\tcase SIOCGIFDSTADDR:\n\tcase SIOCSIFDSTADDR:\n\tcase SIOCGIFNETMASK:\n\tcase SIOCSIFNETMASK:\n\tcase SIOCSIFPFLAGS:\n\tcase SIOCGIFPFLAGS:\n\tcase SIOCGIFTXQLEN:\n\tcase SIOCSIFTXQLEN:\n\tcase SIOCBRADDIF:\n\tcase SIOCBRDELIF:\n\tcase SIOCSIFNAME:\n\tcase SIOCGMIIPHY:\n\tcase SIOCGMIIREG:\n\tcase SIOCSMIIREG:\n\t\treturn dev_ifsioc(net, sock, cmd, argp);\n\n\tcase SIOCSARP:\n\tcase SIOCGARP:\n\tcase SIOCDARP:\n\tcase SIOCATMARK:\n\t\treturn sock_do_ioctl(net, sock, cmd, arg);\n\t}\n\n\t/* Prevent warning from compat_sys_ioctl, these always\n\t * result in -EINVAL in the native case anyway. */\n\tswitch (cmd) {\n\tcase SIOCRTMSG:\n\tcase SIOCGIFCOUNT:\n\tcase SIOCSRARP:\n\tcase SIOCGRARP:\n\tcase SIOCDRARP:\n\tcase SIOCSIFLINK:\n\tcase SIOCGIFSLAVE:\n\tcase SIOCSIFSLAVE:\n\t\treturn -EINVAL;\n\t}\n\n\treturn -ENOIOCTLCMD;\n}\n\nstatic long compat_sock_ioctl(struct file *file, unsigned cmd,\n\t\t\t      unsigned long arg)\n{\n\tstruct socket *sock = file->private_data;\n\tint ret = -ENOIOCTLCMD;\n\tstruct sock *sk;\n\tstruct net *net;\n\n\tsk = sock->sk;\n\tnet = sock_net(sk);\n\n\tif (sock->ops->compat_ioctl)\n\t\tret = sock->ops->compat_ioctl(sock, cmd, arg);\n\n\tif (ret == -ENOIOCTLCMD &&\n\t    (cmd >= SIOCIWFIRST && cmd <= SIOCIWLAST))\n\t\tret = compat_wext_handle_ioctl(net, cmd, arg);\n\n\tif (ret == -ENOIOCTLCMD)\n\t\tret = compat_sock_ioctl_trans(file, sock, cmd, arg);\n\n\treturn ret;\n}\n#endif\n\nint kernel_bind(struct socket *sock, struct sockaddr *addr, int addrlen)\n{\n\treturn sock->ops->bind(sock, addr, addrlen);\n}\nEXPORT_SYMBOL(kernel_bind);\n\nint kernel_listen(struct socket *sock, int backlog)\n{\n\treturn sock->ops->listen(sock, backlog);\n}\nEXPORT_SYMBOL(kernel_listen);\n\nint kernel_accept(struct socket *sock, struct socket **newsock, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tint err;\n\n\terr = sock_create_lite(sk->sk_family, sk->sk_type, sk->sk_protocol,\n\t\t\t       newsock);\n\tif (err < 0)\n\t\tgoto done;\n\n\terr = sock->ops->accept(sock, *newsock, flags);\n\tif (err < 0) {\n\t\tsock_release(*newsock);\n\t\t*newsock = NULL;\n\t\tgoto done;\n\t}\n\n\t(*newsock)->ops = sock->ops;\n\t__module_get((*newsock)->ops->owner);\n\ndone:\n\treturn err;\n}\nEXPORT_SYMBOL(kernel_accept);\n\nint kernel_connect(struct socket *sock, struct sockaddr *addr, int addrlen,\n\t\t   int flags)\n{\n\treturn sock->ops->connect(sock, addr, addrlen, flags);\n}\nEXPORT_SYMBOL(kernel_connect);\n\nint kernel_getsockname(struct socket *sock, struct sockaddr *addr,\n\t\t\t int *addrlen)\n{\n\treturn sock->ops->getname(sock, addr, addrlen, 0);\n}\nEXPORT_SYMBOL(kernel_getsockname);\n\nint kernel_getpeername(struct socket *sock, struct sockaddr *addr,\n\t\t\t int *addrlen)\n{\n\treturn sock->ops->getname(sock, addr, addrlen, 1);\n}\nEXPORT_SYMBOL(kernel_getpeername);\n\nint kernel_getsockopt(struct socket *sock, int level, int optname,\n\t\t\tchar *optval, int *optlen)\n{\n\tmm_segment_t oldfs = get_fs();\n\tchar __user *uoptval;\n\tint __user *uoptlen;\n\tint err;\n\n\tuoptval = (char __user __force *) optval;\n\tuoptlen = (int __user __force *) optlen;\n\n\tset_fs(KERNEL_DS);\n\tif (level == SOL_SOCKET)\n\t\terr = sock_getsockopt(sock, level, optname, uoptval, uoptlen);\n\telse\n\t\terr = sock->ops->getsockopt(sock, level, optname, uoptval,\n\t\t\t\t\t    uoptlen);\n\tset_fs(oldfs);\n\treturn err;\n}\nEXPORT_SYMBOL(kernel_getsockopt);\n\nint kernel_setsockopt(struct socket *sock, int level, int optname,\n\t\t\tchar *optval, unsigned int optlen)\n{\n\tmm_segment_t oldfs = get_fs();\n\tchar __user *uoptval;\n\tint err;\n\n\tuoptval = (char __user __force *) optval;\n\n\tset_fs(KERNEL_DS);\n\tif (level == SOL_SOCKET)\n\t\terr = sock_setsockopt(sock, level, optname, uoptval, optlen);\n\telse\n\t\terr = sock->ops->setsockopt(sock, level, optname, uoptval,\n\t\t\t\t\t    optlen);\n\tset_fs(oldfs);\n\treturn err;\n}\nEXPORT_SYMBOL(kernel_setsockopt);\n\nint kernel_sendpage(struct socket *sock, struct page *page, int offset,\n\t\t    size_t size, int flags)\n{\n\tsock_update_classid(sock->sk);\n\n\tif (sock->ops->sendpage)\n\t\treturn sock->ops->sendpage(sock, page, offset, size, flags);\n\n\treturn sock_no_sendpage(sock, page, offset, size, flags);\n}\nEXPORT_SYMBOL(kernel_sendpage);\n\nint kernel_sock_ioctl(struct socket *sock, int cmd, unsigned long arg)\n{\n\tmm_segment_t oldfs = get_fs();\n\tint err;\n\n\tset_fs(KERNEL_DS);\n\terr = sock->ops->ioctl(sock, cmd, arg);\n\tset_fs(oldfs);\n\n\treturn err;\n}\nEXPORT_SYMBOL(kernel_sock_ioctl);\n\nint kernel_sock_shutdown(struct socket *sock, enum sock_shutdown_cmd how)\n{\n\treturn sock->ops->shutdown(sock, how);\n}\nEXPORT_SYMBOL(kernel_sock_shutdown);\n"], "filenames": ["net/socket.c"], "buggy_code_start_loc": [1968], "buggy_code_end_loc": [1983], "fixing_code_start_loc": [1968], "fixing_code_end_loc": [1985], "type": "CWE-476", "message": "The __sys_sendmsg function in net/socket.c in the Linux kernel before 3.1 allows local users to cause a denial of service (system crash) via crafted use of the sendmmsg system call, leading to an incorrect pointer dereference.", "other": {"cve": {"id": "CVE-2011-4594", "sourceIdentifier": "secalert@redhat.com", "published": "2012-05-17T11:00:35.087", "lastModified": "2023-02-13T00:21:28.573", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "The __sys_sendmsg function in net/socket.c in the Linux kernel before 3.1 allows local users to cause a denial of service (system crash) via crafted use of the sendmmsg system call, leading to an incorrect pointer dereference."}, {"lang": "es", "value": "La funci\u00f3n __ sys_sendmsg en net/socket.c en el kernel de Linux antes de v3.1 permite a usuarios locales causar una denegaci\u00f3n de servicio (ca\u00edda del sistema) mediante el uso de una llamada a la 'system call' sendmmsg debidamente modificada, dando lugar a una eliminaci\u00f3n de referencia a puntero incorrecto."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 4.9}, "baseSeverity": "MEDIUM", "exploitabilityScore": 3.9, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.1", "matchCriteriaId": "156989A4-23D9-434A-B512-9C0F3583D13D"}]}]}], "references": [{"url": "http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git%3Ba=commit%3Bh=bc909d9ddbf7778371e36a651d6e4194b1cc7d4c", "source": "secalert@redhat.com"}, {"url": "http://www.kernel.org/pub/linux/kernel/v3.x/ChangeLog-3.1", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2011/12/08/4", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=761646", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/bc909d9ddbf7778371e36a651d6e4194b1cc7d4c", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/bc909d9ddbf7778371e36a651d6e4194b1cc7d4c"}}