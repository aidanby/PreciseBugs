{"buggy_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / BIFS codec sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n#include <gpac/internal/bifs_dev.h>\n#include \"quant.h\"\n\n\n#ifndef GPAC_DISABLE_BIFS\n\nGF_Err ParseMFFieldList(GF_BifsDecoder *codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field);\nGF_Err ParseMFFieldVec(GF_BifsDecoder *codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field);\n\n\nstatic void BM_SetCommandNode(GF_Command *com, GF_Node *node)\n{\n\tcom->node = node;\n\tgf_node_register(node, NULL);\n}\n\nstatic GF_Err BM_ParseMultipleIndexedReplace(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tu32 ID, ind, field_ind, NumBits, lenpos, lennum, count;\n\tGF_Node *node;\n\tGF_Err e;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tGF_FieldInfo field;\n\n\tID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\tnode = gf_sg_find_node(codec->current_graph, ID);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\tNumBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_IN)-1);\n\tind = gf_bs_read_int(bs, NumBits);\n\te = gf_bifs_get_field_index(node, ind, GF_SG_FIELD_CODING_IN, &field_ind);\n\tif (e) return e;\n\te = gf_node_get_field(node, field_ind, &field);\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tlenpos = gf_bs_read_int(bs, 5);\n\tlennum = gf_bs_read_int(bs, 5);\n\tcount = gf_bs_read_int(bs, lennum);\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_MULTIPLE_INDEXED_REPLACE);\n\tBM_SetCommandNode(com, node);\n\tfield.fieldType = gf_sg_vrml_get_sf_type(field.fieldType);\n\n\twhile (count) {\n\t\tinf = gf_sg_command_field_new(com);\n\t\tinf->pos = gf_bs_read_int(bs, lenpos);\n\t\tinf->fieldIndex = field.fieldIndex;\n\t\tinf->fieldType = field.fieldType;\n\n\t\tif (field.fieldType==GF_SG_VRML_SFNODE) {\n\t\t\tinf->new_node = gf_bifs_dec_node(codec, bs, field.NDTtype);\n\t\t\tif (codec->LastError) goto err;\n\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\tgf_node_register(inf->new_node, NULL);\n\t\t} else {\n\t\t\tfield.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t\t\te = gf_bifs_dec_sf_field(codec, bs, node, &field, GF_TRUE);\n\t\t\tif (e) goto err;\n\t\t}\n\t\tcount--;\n\t}\nerr:\n\tif (e) gf_sg_command_del(com);\n\telse gf_list_add(com_list, com);\n\treturn e;\n}\n\nstatic GF_Err BM_ParseMultipleReplace(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tu32 i, numFields, index, flag, nbBits, field_ref, fieldind;\n\tGF_Err e;\n\tGF_FieldInfo field;\n\tu32 NodeID;\n\tGF_Node *node;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\n\tNodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\tnode = gf_sg_find_node(codec->current_graph, NodeID);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\n\te = GF_OK;\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_MULTIPLE_REPLACE);\n\tBM_SetCommandNode(com, node);\n\tflag = gf_bs_read_int(bs, 1);\n\tif (flag) {\n\t\tnumFields = gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_DEF);\n\t\tfor (i=0; i<numFields; i++) {\n\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t\tif (!flag) continue;\n\t\t\tgf_bifs_get_field_index(node, i, GF_SG_FIELD_CODING_DEF, &index);\n\t\t\te = gf_node_get_field(node, index, &field);\n\t\t\tif (e) goto exit;\n\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\tinf->fieldType = field.fieldType;\n\t\t\tinf->fieldIndex = field.fieldIndex;\n\t\t\tif (inf->fieldType==GF_SG_VRML_SFNODE) {\n\t\t\t\tfield.far_ptr = inf->field_ptr = &inf->new_node;\n\t\t\t} else if (inf->fieldType==GF_SG_VRML_MFNODE) {\n\t\t\t\tfield.far_ptr = inf->field_ptr = &inf->node_list;\n\t\t\t} else {\n\t\t\t\tfield.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t\t\t}\n\t\t\te = gf_bifs_dec_field(codec, bs, node, &field, GF_TRUE);\n\t\t\tif (e) goto exit;\n\t\t}\n\t} else {\n\t\tflag = gf_bs_read_int(bs, 1);\n\t\tnbBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_DEF)-1);\n\t\twhile (!flag && (codec->LastError>=0)) {\n\t\t\tfield_ref = gf_bs_read_int(bs, nbBits);\n\t\t\te = gf_bifs_get_field_index(node, field_ref, GF_SG_FIELD_CODING_DEF, &fieldind);\n\t\t\tif (e) goto exit;\n\t\t\te = gf_node_get_field(node, fieldind, &field);\n\t\t\tif (e) goto exit;\n\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\tinf->fieldType = field.fieldType;\n\t\t\tinf->fieldIndex = field.fieldIndex;\n\t\t\tif (inf->fieldType==GF_SG_VRML_SFNODE) {\n\t\t\t\tfield.far_ptr = inf->field_ptr = &inf->new_node;\n\t\t\t} else if (inf->fieldType==GF_SG_VRML_MFNODE) {\n\t\t\t\tfield.far_ptr = inf->field_ptr = &inf->node_list;\n\t\t\t} else {\n\t\t\t\tfield.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t\t\t}\n\t\t\te = gf_bifs_dec_field(codec, bs, node, &field, GF_TRUE);\n\t\t\tif (e) goto exit;\n\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t}\n\t}\n\n\nexit:\n\tif (e) gf_sg_command_del(com);\n\telse gf_list_add(com_list, com);\n\treturn e;\n}\n\nstatic GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Node *node;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tnode = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t/*reset global QP*/\n\tif (codec->scenegraph->global_qp) {\n\t\tgf_node_unregister(codec->scenegraph->global_qp, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\tgf_node_unregister(node, NULL);\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\t/*register global QP*/\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\n\t/*register TWICE: once for the command, and for the scenegraph globalQP*/\n\tnode->sgprivate->num_instances = 2;\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}\n\nstatic GF_Err BM_ParseProtoDelete(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tu32 flag, count;\n\tGF_Command *com = gf_sg_command_new(codec->current_graph, GF_SG_PROTO_DELETE);\n\tflag = gf_bs_read_int(bs, 1);\n\tif (flag) {\n\t\tcount = 0;\n\t\tflag = gf_bs_read_int(bs, 1);\n\t\twhile (flag) {\n\t\t\tcom->del_proto_list = (u32*)gf_realloc(com->del_proto_list, sizeof(u32) * (com->del_proto_list_size+1));\n\t\t\tcom->del_proto_list[count] = gf_bs_read_int(bs, codec->info->config.ProtoIDBits);\n\t\t\tcom->del_proto_list_size++;\n\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t}\n\t} else {\n\t\tflag = gf_bs_read_int(bs, 5);\n\t\tcom->del_proto_list_size = gf_bs_read_int(bs, flag);\n\t\tcom->del_proto_list = (u32*)gf_realloc(com->del_proto_list, sizeof(u32) * (com->del_proto_list_size));\n\t\tflag = 0;\n\t\twhile (flag<com->del_proto_list_size) {\n\t\t\tcom->del_proto_list[flag] = gf_bs_read_int(bs, codec->info->config.ProtoIDBits);\n\t\t\tflag++;\n\t\t}\n\t}\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}\n\nstatic GF_Err BM_XReplace(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_FieldInfo targetField, fromField, decfield;\n\tGF_Node *target, *fromNode;\n\ts32 pos = -2;\n\tu32 id, nbBits, ind, aind;\n\tGF_Err e;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\n\tid = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\ttarget = gf_sg_find_node(codec->current_graph, id);\n\tif (!target) return GF_SG_UNKNOWN_NODE;\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_XREPLACE);\n\tBM_SetCommandNode(com, target);\n\tgf_list_add(com_list, com);\n\n\tnbBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(target, GF_SG_FIELD_CODING_IN)-1);\n\tind = gf_bs_read_int(bs, nbBits);\n\te = gf_bifs_get_field_index(target, ind, GF_SG_FIELD_CODING_IN, &aind);\n\tif (e) return e;\n\te = gf_node_get_field(target, aind, &targetField);\n\tif (e) return e;\n\n\tinf = gf_sg_command_field_new(com);\n\tinf->fieldIndex = aind;\n\n\tif (!gf_sg_vrml_is_sf_field(targetField.fieldType)) {\n\t\t/*this is indexed replacement*/\n\t\tif (gf_bs_read_int(bs, 1)) {\n\t\t\t/*index is dynamic*/\n\t\t\tif (gf_bs_read_int(bs, 1)) {\n\t\t\t\tGF_Node *n;\n\t\t\t\tid = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\t\t\t\tn = gf_sg_find_node(codec->current_graph, id);\n\t\t\t\tif (!n) return GF_SG_UNKNOWN_NODE;\n\t\t\t\tcom->toNodeID = id;\n\n\t\t\t\tnbBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(n, GF_SG_FIELD_CODING_DEF)-1);\n\t\t\t\tind = gf_bs_read_int(bs, nbBits);\n\t\t\t\te = gf_bifs_get_field_index(n, ind, GF_SG_FIELD_CODING_DEF, &aind);\n\t\t\t\tif (e) return e;\n\t\t\t\te = gf_node_get_field(n, aind, &fromField);\n\t\t\t\tif (e) return e;\n\t\t\t\tcom->toFieldIndex = aind;\n\t\t\t} else {\n\t\t\t\tu32 type = gf_bs_read_int(bs, 2);\n\t\t\t\tswitch (type) {\n\t\t\t\tcase 0:\n\t\t\t\t\tpos = gf_bs_read_int(bs, 16);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tpos = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (targetField.fieldType==GF_SG_VRML_MFNODE) {\n\t\t\tif (gf_bs_read_int(bs, 1)) {\n\t\t\t\ttarget = gf_node_list_get_child(*(GF_ChildNodeItem **)targetField.far_ptr, pos);\n\t\t\t\tif (!target) return GF_SG_UNKNOWN_NODE;\n\n\t\t\t\tnbBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(target, GF_SG_FIELD_CODING_IN)-1);\n\t\t\t\tind = gf_bs_read_int(bs, nbBits);\n\t\t\t\te = gf_bifs_get_field_index(target, ind, GF_SG_FIELD_CODING_IN, &aind);\n\t\t\t\tif (e) return e;\n\t\t\t\te = gf_node_get_field(target, aind, &targetField);\n\t\t\t\tif (e) return e;\n\t\t\t\tpos = -2;\n\t\t\t\tcom->child_field = aind;\n\t\t\t\tcom->ChildNodeTag = gf_node_get_tag(target);\n\t\t\t\tif (com->ChildNodeTag == TAG_ProtoNode) {\n\t\t\t\t\ts32 p_id = gf_sg_proto_get_id(gf_node_get_proto(target));\n\t\t\t\t\tcom->ChildNodeTag = -p_id;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinf->pos = pos;\n\t}\n\n\tfromNode = NULL;\n\tif (gf_bs_read_int(bs, 1)) {\n\t\tid = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\t\tfromNode = gf_sg_find_node(codec->current_graph, id);\n\t\tif (!fromNode) return GF_SG_UNKNOWN_NODE;\n\t\tcom->fromNodeID = id;\n\n\t\tnbBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(fromNode, GF_SG_FIELD_CODING_DEF)-1);\n\t\tind = gf_bs_read_int(bs, nbBits);\n\t\te = gf_bifs_get_field_index(fromNode, ind, GF_SG_FIELD_CODING_DEF, &aind);\n\t\tif (e) return e;\n\t\te = gf_node_get_field(fromNode, aind, &fromField);\n\t\tif (e) return e;\n\t\tcom->fromFieldIndex = aind;\n\n\t\treturn GF_OK;\n\t}\n\n\n\tif (pos>= -1) {\n\t\tinf->fieldType = gf_sg_vrml_get_sf_type(targetField.fieldType);\n\t} else {\n\t\tinf->fieldType = targetField.fieldType;\n\t}\n\tdecfield.fieldIndex = inf->fieldIndex;\n\tdecfield.fieldType = inf->fieldType;\n\n\tif (inf->fieldType==GF_SG_VRML_SFNODE) {\n\t\tdecfield.far_ptr = inf->field_ptr = &inf->new_node;\n\t} else if (inf->fieldType==GF_SG_VRML_MFNODE) {\n\t\tdecfield.far_ptr = inf->field_ptr = &inf->node_list;\n\t} else {\n\t\tdecfield.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t}\n\te = gf_bifs_dec_sf_field(codec, bs, target, &decfield, GF_TRUE);\n\treturn e;\n}\n\nstatic GF_Err BM_ParseExtendedUpdates(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tu32 type = gf_bs_read_int(bs, 8);\n\tGF_Err e;\n\n\tswitch (type) {\n\tcase 0:\n\t{\n\t\tGF_Command *com = gf_sg_command_new(codec->current_graph, GF_SG_PROTO_INSERT);\n\t\te = gf_bifs_dec_proto_list(codec, bs, com->new_proto_list);\n\t\tif (e) gf_sg_command_del(com);\n\t\telse gf_list_add(com_list, com);\n\t}\n\treturn e;\n\tcase 1:\n\t\treturn BM_ParseProtoDelete(codec, bs, com_list);\n\tcase 2:\n\t{\n\t\tGF_Command *com = gf_sg_command_new(codec->current_graph, GF_SG_PROTO_DELETE_ALL);\n\t\treturn gf_list_add(com_list, com);\n\t}\n\tcase 3:\n\t\treturn BM_ParseMultipleIndexedReplace(codec, bs, com_list);\n\tcase 4:\n\t\treturn BM_ParseMultipleReplace(codec, bs, com_list);\n\tcase 5:\n\t\treturn BM_ParseGlobalQuantizer(codec, bs, com_list);\n\tcase 6:\n\t{\n\t\tGF_Command *com;\n\t\tu32 ID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\t\tGF_Node *n = gf_sg_find_node(codec->current_graph, ID);\n\t\tif (!n) return GF_OK;\n\t\tcom = gf_sg_command_new(codec->current_graph, GF_SG_NODE_DELETE_EX);\n\t\tBM_SetCommandNode(com, n);\n\t\tgf_list_add(com_list, com);\n\t}\n\treturn GF_OK;\n\tcase 7:\n\t\treturn BM_XReplace(codec, bs, com_list);\n\n\tdefault:\n\t\treturn GF_BIFS_UNKNOWN_VERSION;\n\t}\n}\n\n/*inserts a node in a container (node.children)*/\nGF_Err BM_ParseNodeInsert(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tu32 NodeID, NDT;\n\tGF_CommandField *inf;\n\ts32 type, pos;\n\tGF_Node *node, *def;\n\n\tNodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\tdef = gf_sg_find_node(codec->current_graph, NodeID);\n\tif (!def) return GF_NON_COMPLIANT_BITSTREAM;\n\tNDT = gf_bifs_get_child_table(def);\n\tif (!NDT) return GF_NON_COMPLIANT_BITSTREAM;\n\n\ttype = gf_bs_read_int(bs, 2);\n\tswitch (type) {\n\tcase 0:\n\t\tpos = gf_bs_read_int(bs, 8);\n\t\tbreak;\n\tcase 2:\n\t\tpos = 0;\n\t\tbreak;\n\tcase 3:\n\t\t/*-1 means append*/\n\t\tpos = -1;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tnode = gf_bifs_dec_node(codec, bs, NDT);\n\tif (!codec->LastError) {\n\t\tGF_Command *com = gf_sg_command_new(codec->current_graph, GF_SG_NODE_INSERT);\n\t\tBM_SetCommandNode(com, def);\n\t\tinf = gf_sg_command_field_new(com);\n\t\tinf->pos = pos;\n\t\tinf->new_node = node;\n\t\tinf->field_ptr = &inf->new_node;\n\t\tinf->fieldType = GF_SG_VRML_SFNODE;\n\t\tgf_list_add(com_list, com);\n\t\t/*register*/\n\t\tgf_node_register(node, NULL);\n\t}\n\treturn codec->LastError;\n}\n\n/*NB This can insert a node as well (but usually not in the .children field)*/\nGF_Err BM_ParseIndexInsert(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Err e;\n\tu32 NodeID;\n\tu32 NumBits, ind, field_ind;\n\tu8 type;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\ts32 pos;\n\tGF_Node *def, *node;\n\tGF_FieldInfo field, sffield;\n\n\tNodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\tdef = gf_sg_find_node(codec->current_graph, NodeID);\n\tif (!def) return GF_NON_COMPLIANT_BITSTREAM;\n\t/*index insertion uses IN mode for field index*/\n\tNumBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(def, GF_SG_FIELD_CODING_IN)-1);\n\tind = gf_bs_read_int(bs, NumBits);\n\n\te = gf_bifs_get_field_index(def, ind, GF_SG_FIELD_CODING_IN, &field_ind);\n\tif (e) return e;\n\n\ttype = gf_bs_read_int(bs, 2);\n\tswitch (type) {\n\tcase 0:\n\t\tpos = gf_bs_read_int(bs, 16);\n\t\tbreak;\n\tcase 2:\n\t\tpos = 0;\n\t\tbreak;\n\tcase 3:\n\t\tpos = -1;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\te = gf_node_get_field(def, field_ind, &field);\n\tif (e) return e;\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tmemcpy(&sffield, &field, sizeof(GF_FieldInfo));\n\tsffield.fieldType = gf_sg_vrml_get_sf_type(field.fieldType);\n\n\t/*rescale the MFField and parse the SFField*/\n\tif (field.fieldType==GF_SG_VRML_MFNODE) {\n\t\tnode = gf_bifs_dec_node(codec, bs, field.NDTtype);\n\t\tif (!codec->LastError) {\n\t\t\tcom = gf_sg_command_new(codec->current_graph, GF_SG_INDEXED_INSERT);\n\t\t\tBM_SetCommandNode(com, def);\n\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\tinf->pos = pos;\n\t\t\tinf->fieldIndex = field_ind;\n\t\t\tinf->fieldType = sffield.fieldType;\n\t\t\tinf->new_node = node;\n\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\tgf_list_add(com_list, com);\n\t\t\t/*register*/\n\t\t\tgf_node_register(node, NULL);\n\t\t}\n\t} else {\n\t\tcom = gf_sg_command_new(codec->current_graph, GF_SG_INDEXED_INSERT);\n\t\tBM_SetCommandNode(com, def);\n\t\tinf = gf_sg_command_field_new(com);\n\t\tinf->pos = pos;\n\t\tinf->fieldIndex = field_ind;\n\t\tinf->fieldType = sffield.fieldType;\n\t\tsffield.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(sffield.fieldType);\n\t\tcodec->LastError = gf_bifs_dec_sf_field(codec, bs, def, &sffield, GF_TRUE);\n\t\tgf_list_add(com_list, com);\n\t}\n\treturn codec->LastError;\n}\n\n\nGF_Err BM_ParseRouteInsert(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Err e;\n\tu8 flag;\n\tGF_Command *com;\n\tGF_Node *InNode, *OutNode;\n\tu32 RouteID, outField, inField, numBits, ind, node_id;\n\tchar name[1000];\n\n\tRouteID = 0;\n\n\tflag = gf_bs_read_int(bs, 1);\n\t/*def'ed route*/\n\tif (flag) {\n\t\tRouteID = 1 + gf_bs_read_int(bs, codec->info->config.RouteIDBits);\n\t\tif (codec->UseName) gf_bifs_dec_name(bs, name, 1000);\n\t}\n\t/*origin*/\n\tnode_id = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\tOutNode = gf_sg_find_node(codec->current_graph, node_id);\n\tif (!OutNode) return GF_SG_UNKNOWN_NODE;\n\n\tnumBits = gf_node_get_num_fields_in_mode(OutNode, GF_SG_FIELD_CODING_OUT) - 1;\n\tnumBits = gf_get_bit_size(numBits);\n\tind = gf_bs_read_int(bs, numBits);\n\te = gf_bifs_get_field_index(OutNode, ind, GF_SG_FIELD_CODING_OUT, &outField);\n\tif (e) return e;\n\n\t/*target*/\n\tnode_id = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\tInNode = gf_sg_find_node(codec->current_graph, node_id);\n\tif (!InNode) return GF_SG_UNKNOWN_NODE;\n\n\tnumBits = gf_node_get_num_fields_in_mode(InNode, GF_SG_FIELD_CODING_IN) - 1;\n\tnumBits = gf_get_bit_size(numBits);\n\tind = gf_bs_read_int(bs, numBits);\n\te = gf_bifs_get_field_index(InNode, ind, GF_SG_FIELD_CODING_IN, &inField);\n\tif (e) return e;\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_ROUTE_INSERT);\n\tcom->RouteID = RouteID;\n\tif (codec->UseName) com->def_name = gf_strdup( name);\n\tcom->fromNodeID = gf_node_get_id(OutNode);\n\tcom->fromFieldIndex = outField;\n\tcom->toNodeID = gf_node_get_id(InNode);\n\tcom->toFieldIndex = inField;\n\tgf_list_add(com_list, com);\n\treturn codec->LastError;\n}\n\n\nGF_Err BM_ParseInsert(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tu8 type;\n\n\ttype = gf_bs_read_int(bs, 2);\n\tswitch (type) {\n\tcase 0:\n\t\treturn BM_ParseNodeInsert(codec, bs, com_list);\n\tcase 1:\n\t\treturn BM_ParseExtendedUpdates(codec, bs, com_list);\n\tcase 2:\n\t\treturn BM_ParseIndexInsert(codec, bs, com_list);\n\tcase 3:\n\t\treturn BM_ParseRouteInsert(codec, bs, com_list);\n\tdefault:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n}\n\n\nGF_Err BM_ParseIndexDelete(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tu32 NodeID, NumBits, ind, field_ind;\n\ts32 pos;\n\tGF_Command *com;\n\tu8 type;\n\tGF_Node *node;\n\tGF_Err e;\n\tGF_CommandField *inf;\n\tGF_FieldInfo field;\n\n\tNodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\tnode = gf_sg_find_node(codec->current_graph, NodeID);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tNumBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_IN) - 1);\n\tind = gf_bs_read_int(bs, NumBits);\n\n\ttype = gf_bs_read_int(bs, 2);\n\tswitch (type) {\n\tcase 0:\n\t\tpos = (u32) gf_bs_read_int(bs, 16);\n\t\tbreak;\n\tcase 2:\n\t\tpos = 0;\n\t\tbreak;\n\tcase 3:\n\t\tpos = -1;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\te = gf_bifs_get_field_index(node, ind, GF_SG_FIELD_CODING_IN, &field_ind);\n\tif (e) return e;\n\te = gf_node_get_field(node, field_ind, &field);\n\tif (e) return e;\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) return GF_NON_COMPLIANT_BITSTREAM;\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_INDEXED_DELETE);\n\tBM_SetCommandNode(com, node);\n\tinf = gf_sg_command_field_new(com);\n\tinf->pos = pos;\n\tinf->fieldIndex = field.fieldIndex;\n\tinf->fieldType = gf_sg_vrml_get_sf_type(field.fieldType);\n\tgf_list_add(com_list, com);\n\treturn codec->LastError;\n}\n\n\n\nGF_Err BM_ParseDelete(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tu8 type;\n\tu32 ID;\n\tGF_Command *com;\n\tGF_Node *n;\n\n\ttype = gf_bs_read_int(bs, 2);\n\tswitch (type) {\n\tcase 0:\n\t\tID = 1+gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\t\tn = gf_sg_find_node(codec->current_graph, ID);\n\t\tif (!n) return GF_OK;\n\t\tcom = gf_sg_command_new(codec->current_graph, GF_SG_NODE_DELETE);\n\t\tBM_SetCommandNode(com, n);\n\t\tgf_list_add(com_list, com);\n\t\treturn GF_OK;\n\tcase 2:\n\t\treturn BM_ParseIndexDelete(codec, bs, com_list);\n\tcase 3:\n\t\tcom = gf_sg_command_new(codec->current_graph, GF_SG_ROUTE_DELETE);\n\t\tcom->RouteID = 1+gf_bs_read_int(bs, codec->info->config.RouteIDBits);\n\t\tgf_list_add(com_list, com);\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err BM_ParseNodeReplace(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tu32 NodeID;\n\tGF_Command *com;\n\tGF_Node *node;\n\tGF_CommandField *inf;\n\n\tNodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\t/*this is delete / new on a DEF node: replace ALL instances*/\n\tnode = gf_sg_find_node(codec->current_graph, NodeID);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_NODE_REPLACE);\n\tBM_SetCommandNode(com, node);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tinf->field_ptr = &inf->new_node;\n\tgf_list_add(com_list, com);\n\tgf_node_register(inf->new_node, NULL);\n\treturn codec->LastError;\n}\n\nGF_Err BM_ParseFieldReplace(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Err e;\n\tGF_Command *com;\n\tu32 NodeID, ind, field_ind, NumBits;\n\tGF_Node *node;\n\tGF_FieldInfo field;\n\tGF_CommandField *inf;\n\n\tNodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\tnode = gf_sg_find_node(codec->current_graph, NodeID);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\tNumBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_IN)-1);\n\tind = gf_bs_read_int(bs, NumBits);\n\te = gf_bifs_get_field_index(node, ind, GF_SG_FIELD_CODING_IN, &field_ind);\n\tif (e) return e;\n\n\te = gf_node_get_field(node, field_ind, &field);\n\tif (e) return e;\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_FIELD_REPLACE);\n\tBM_SetCommandNode(com, node);\n\tinf = gf_sg_command_field_new(com);\n\tinf->fieldIndex = field_ind;\n\tinf->fieldType = field.fieldType;\n\tif (inf->fieldType == GF_SG_VRML_SFNODE) {\n\t\tfield.far_ptr = inf->field_ptr = &inf->new_node;\n\t} else if (inf->fieldType == GF_SG_VRML_MFNODE) {\n\t\tfield.far_ptr = inf->field_ptr = &inf->node_list;\n\t} else {\n\t\tfield.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(field.fieldType);\n\t}\n\t/*parse the field*/\n\tcodec->LastError = gf_bifs_dec_field(codec, bs, node, &field, GF_TRUE);\n\n\tgf_list_add(com_list, com);\n\treturn codec->LastError;\n}\n\nGF_Err BM_ParseIndexValueReplace(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tu32 NodeID, ind, field_ind, NumBits;\n\ts32 type, pos;\n\tGF_Command *com;\n\tGF_Node *node;\n\tGF_Err e;\n\tGF_FieldInfo field, sffield;\n\tGF_CommandField *inf;\n\n\t/*get the node*/\n\tNodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\n\tnode = gf_sg_find_node(codec->current_graph, NodeID);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\tNumBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_IN)-1);\n\tind = gf_bs_read_int(bs, NumBits);\n\te = gf_bifs_get_field_index(node, ind, GF_SG_FIELD_CODING_IN, &field_ind);\n\tif (e) return e;\n\n\te = gf_node_get_field(node, field_ind, &field);\n\tif (e) return e;\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) return GF_NON_COMPLIANT_BITSTREAM;\n\n\ttype = gf_bs_read_int(bs, 2);\n\tswitch (type) {\n\tcase 0:\n\t\tpos = gf_bs_read_int(bs, 16);\n\t\tbreak;\n\tcase 2:\n\t\tpos = 0;\n\t\tbreak;\n\tcase 3:\n\t\tpos = ((GenMFField *) field.far_ptr)->count - 1;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_INDEXED_REPLACE);\n\tBM_SetCommandNode(com, node);\n\tinf = gf_sg_command_field_new(com);\n\tinf->fieldIndex = field.fieldIndex;\n\tinf->pos = pos;\n\n\tif (field.fieldType == GF_SG_VRML_MFNODE) {\n\t\tinf->fieldType = GF_SG_VRML_SFNODE;\n\t\tinf->new_node = gf_bifs_dec_node(codec, bs, field.NDTtype);\n\t\tinf->field_ptr = &inf->new_node;\n\t\tif (inf->new_node) gf_node_register(inf->new_node, NULL);\n\t} else {\n\t\tmemcpy(&sffield, &field, sizeof(GF_FieldInfo));\n\t\tsffield.fieldType = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\tinf->fieldType = sffield.fieldType;\n\t\tsffield.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(sffield.fieldType);\n\t\tcodec->LastError = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_TRUE);\n\t}\n\tgf_list_add(com_list, com);\n\treturn codec->LastError;\n}\n\nGF_Err BM_ParseRouteReplace(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Err e;\n\tGF_Command *com;\n\tu32 RouteID, numBits, ind, node_id, fromID, toID;\n\tGF_Node *OutNode, *InNode;\n\n\tRouteID = 1+gf_bs_read_int(bs, codec->info->config.RouteIDBits);\n\n\t/*origin*/\n\tnode_id = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\tOutNode = gf_sg_find_node(codec->current_graph, node_id);\n\tif (!OutNode) return GF_NON_COMPLIANT_BITSTREAM;\n\tnumBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(OutNode, GF_SG_FIELD_CODING_OUT) - 1);\n\tind = gf_bs_read_int(bs, numBits);\n\te = gf_bifs_get_field_index(OutNode, ind, GF_SG_FIELD_CODING_OUT, &fromID);\n\tif (e) return e;\n\n\t/*target*/\n\tnode_id = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\tInNode = gf_sg_find_node(codec->current_graph, node_id);\n\tif (!InNode) return GF_NON_COMPLIANT_BITSTREAM;\n\tnumBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(InNode, GF_SG_FIELD_CODING_IN) - 1);\n\tind = gf_bs_read_int(bs, numBits);\n\te = gf_bifs_get_field_index(InNode, ind, GF_SG_FIELD_CODING_IN, &toID);\n\tif (e) return e;\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_ROUTE_REPLACE);\n\tcom->RouteID = RouteID;\n\tcom->fromNodeID = gf_node_get_id(OutNode);\n\tcom->fromFieldIndex = fromID;\n\tcom->toNodeID = gf_node_get_id(InNode);\n\tcom->toFieldIndex = toID;\n\tgf_list_add(com_list, com);\n\treturn codec->LastError;\n}\n\n\nGF_Err BM_ParseReplace(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tu8 type;\n\ttype = gf_bs_read_int(bs, 2);\n\tswitch (type) {\n\tcase 0:\n\t\treturn BM_ParseNodeReplace(codec, bs, com_list);\n\tcase 1:\n\t\treturn BM_ParseFieldReplace(codec, bs, com_list);\n\tcase 2:\n\t\treturn BM_ParseIndexValueReplace(codec, bs, com_list);\n\tcase 3:\n\t\treturn BM_ParseRouteReplace(codec, bs, com_list);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err BM_SceneReplace(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Command *com;\n\tGF_Node *backup_root;\n\tGF_List *backup_routes;\n\tGF_Err BD_DecSceneReplace(GF_BifsDecoder * codec, GF_BitStream *bs, GF_List *proto_list);\n\n\tbackup_routes = codec->scenegraph->Routes;\n\tbackup_root = codec->scenegraph->RootNode;\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_SCENE_REPLACE);\n\tcodec->scenegraph->Routes = gf_list_new();\n\tcodec->current_graph = codec->scenegraph;\n\tcodec->LastError = BD_DecSceneReplace(codec, bs, com->new_proto_list);\n\tcom->use_names = codec->UseName;\n\n\t/*restore*/\n\tcom->node = codec->scenegraph->RootNode;\n\tcodec->scenegraph->RootNode = backup_root;\n\tgf_list_add(com_list, com);\n\t/*insert routes*/\n\twhile (gf_list_count(codec->scenegraph->Routes)) {\n\t\tGF_Route *r = (GF_Route*)gf_list_get(codec->scenegraph->Routes, 0);\n\t\tGF_Command *ri = gf_sg_command_new(codec->current_graph, GF_SG_ROUTE_INSERT);\n\t\tgf_list_rem(codec->scenegraph->Routes, 0);\n\t\tri->fromFieldIndex = r->FromField.fieldIndex;\n\t\tri->fromNodeID = gf_node_get_id(r->FromNode);\n\t\tri->toFieldIndex = r->ToField.fieldIndex;\n\t\tri->toNodeID = gf_node_get_id(r->ToNode);\n\t\tif (r->ID) ri->RouteID = r->ID;\n\t\tri->def_name = r->name ? gf_strdup(r->name) : NULL;\n\t\tgf_list_add(com_list, ri);\n\t\tgf_sg_route_del(r);\n\t}\n\tgf_list_del(codec->scenegraph->Routes);\n\tcodec->scenegraph->Routes = backup_routes;\n\treturn codec->LastError;\n}\n\n\nGF_Err BM_ParseCommand(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tu8 go, type;\n\tGF_Err e;\n\tgo = 1;\n\te = GF_OK;\n\tGF_SceneGraph *cur_graph = codec->current_graph;\n\tGF_Proto *cur_proto = codec->pCurrentProto;\n\n\tcodec->LastError = GF_OK;\n\twhile (go) {\n\t\ttype = gf_bs_read_int(bs, 2);\n\t\tswitch (type) {\n\t\tcase 0:\n\t\t\te = BM_ParseInsert(codec, bs, com_list);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\te = BM_ParseDelete(codec, bs, com_list);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\te = BM_ParseReplace(codec, bs, com_list);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\te = BM_SceneReplace(codec, bs, com_list);\n\t\t\tbreak;\n\t\t}\n\t\tif (e) break;\n\t\tgo = gf_bs_read_int(bs, 1);\n\t}\n\twhile (gf_list_count(codec->QPs)) {\n\t\tgf_bifs_dec_qp_remove(codec, GF_TRUE);\n\t}\n\n\tcodec->current_graph = cur_graph;\n\tcodec->pCurrentProto = cur_proto;\n\treturn e;\n}\n\nvoid BM_EndOfStream(void *co)\n{\n\t((GF_BifsDecoder *) co)->LastError = GF_NON_COMPLIANT_BITSTREAM;\n}\n\nvoid gf_bs_set_eos_callback(GF_BitStream *bs, void (*EndOfStream)(void *par), void *par);\n\n\nGF_Err gf_bifs_flush_command_list(GF_BifsDecoder *codec)\n{\n\tGF_BitStream *bs;\n\tGF_Err e;\n\tCommandBufferItem *cbi;\n\tGF_SceneGraph *prev_root = codec->current_graph;\n\tM_QuantizationParameter *prev_qp = codec->ActiveQP;\n\tu32 prev_qp_count = gf_list_count(codec->QPs);\n\tu32 NbPass = gf_list_count(codec->command_buffers);\n\n\n\tcodec->ActiveQP = NULL;\n\tGF_List *nextPass = gf_list_new();\n\twhile (NbPass) {\n\t\twhile (gf_list_count(codec->command_buffers)) {\n\t\t\tcbi = (CommandBufferItem *)gf_list_get(codec->command_buffers, 0);\n\t\t\tgf_list_rem(codec->command_buffers, 0);\n\n\t\t\tcodec->current_graph = gf_node_get_graph(cbi->node);\n\t\t\te = GF_OK;\n\t\t\tif (cbi->cb->bufferSize) {\n\t\t\t\tbs = gf_bs_new((char*)cbi->cb->buffer, cbi->cb->bufferSize, GF_BITSTREAM_READ);\n\t\t\t\tgf_bs_set_eos_callback(bs, BM_EndOfStream, codec);\n\t\t\t\te = BM_ParseCommand(codec, bs, cbi->cb->commandList);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t}\n\t\t\tif (!e) {\n\t\t\t\tgf_node_unregister(cbi->node, NULL);\n\t\t\t\tgf_free(cbi);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*this may be an error or a dependency pb - reset coimmand list and move to next pass*/\n\t\t\twhile (gf_list_count(cbi->cb->commandList)) {\n\t\t\t\tu32 i;\n\t\t\t\tGF_CommandField *cf;\n\t\t\t\tGF_Command *com = (GF_Command *)gf_list_get(cbi->cb->commandList, 0);\n\t\t\t\tgf_list_rem(cbi->cb->commandList, 0);\n\t\t\t\tcf = (GF_CommandField *) gf_list_get(com->command_fields, 0);\n\t\t\t\tif (cf && cf->fieldType==GF_SG_VRML_SFCOMMANDBUFFER) {\n\t\t\t\t\tfor (i=0; i<gf_list_count(codec->command_buffers); i++) {\n\t\t\t\t\t\tCommandBufferItem *cbi2 = (CommandBufferItem *)gf_list_get(codec->command_buffers, i);\n\t\t\t\t\t\tif (cbi2->cb == cf->field_ptr) {\n\t\t\t\t\t\t\tgf_node_unregister(cbi2->node, NULL);\n\t\t\t\t\t\t\tgf_free(cbi2);\n\t\t\t\t\t\t\tgf_list_rem(codec->command_buffers, i);\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_sg_command_del(com);\n\t\t\t}\n\t\t\tgf_list_add(nextPass, cbi);\n\t\t}\n\t\tif (!gf_list_count(nextPass)) break;\n\t\t/*prepare next pass*/\n\t\twhile (gf_list_count(nextPass)) {\n\t\t\tcbi = (CommandBufferItem *)gf_list_get(nextPass, 0);\n\t\t\tgf_list_rem(nextPass, 0);\n\t\t\tgf_list_add(codec->command_buffers, cbi);\n\t\t}\n\t\tNbPass --;\n\t\tif (NbPass > gf_list_count(codec->command_buffers)) NbPass = gf_list_count(codec->command_buffers);\n\n\t\t//restore QP state\n\t\twhile (gf_list_count(codec->QPs) > prev_qp_count) {\n\t\t\tgf_list_rem(codec->QPs, 0); //QPs are inserted at head of list\n\t\t}\n\t\tcodec->ActiveQP = NULL;\n\t\tcodec->LastError = GF_OK;\n\t}\n\tgf_list_del(nextPass);\n\tcodec->current_graph = prev_root;\n\tcodec->ActiveQP = prev_qp;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_bifs_decode_command_list(GF_BifsDecoder *codec, u16 ESID, u8 *data, u32 data_length, GF_List *com_list)\n{\n\tGF_BitStream *bs;\n\tGF_Err e;\n\n\tif (!codec || !data || !codec->dec_memory_mode || !com_list) return GF_BAD_PARAM;\n\n\tcodec->info = gf_bifs_dec_get_stream(codec, ESID);\n\tif (!codec->info) return GF_BAD_PARAM;\n\tif (codec->info->config.elementaryMasks ) return GF_NOT_SUPPORTED;\n\n\t/*root parse (not conditionals)*/\n\tassert(codec->scenegraph);\n\t/*setup current scene graph*/\n\tcodec->current_graph = codec->scenegraph;\n\n\tcodec->ActiveQP = (M_QuantizationParameter*) codec->scenegraph->global_qp;\n\n\tbs = gf_bs_new(data, data_length, GF_BITSTREAM_READ);\n\tgf_bs_set_eos_callback(bs, BM_EndOfStream, codec);\n\n\te = BM_ParseCommand(codec, bs, com_list);\n\tgf_bs_del(bs);\n\n\t/*decode conditionals / input sensors*/\n\tif (!e) {\n\t\tgf_bifs_flush_command_list(codec);\n\t}\n\t/*if err or not reset conditionals*/\n\twhile (gf_list_count(codec->command_buffers)) {\n\t\tCommandBufferItem *cbi = (CommandBufferItem *)gf_list_get(codec->command_buffers, 0);\n\t\tgf_node_unregister(cbi->node, NULL);\n\t\tgf_free(cbi);\n\t\tgf_list_rem(codec->command_buffers, 0);\n\t}\n\n\t/*reset current config*/\n\tcodec->info = NULL;\n\tcodec->current_graph = NULL;\n\n\n\n//\tgf_mx_v(codec->mx);\n\treturn e;\n}\n\n#endif /*GPAC_DISABLE_BIFS*/\n\n"], "fixing_code": ["/*\n *\t\t\tGPAC - Multimedia Framework C SDK\n *\n *\t\t\tAuthors: Jean Le Feuvre\n *\t\t\tCopyright (c) Telecom ParisTech 2000-2012\n *\t\t\t\t\tAll rights reserved\n *\n *  This file is part of GPAC / BIFS codec sub-project\n *\n *  GPAC is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU Lesser General Public License as published by\n *  the Free Software Foundation; either version 2, or (at your option)\n *  any later version.\n *\n *  GPAC is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU Lesser General Public License for more details.\n *\n *  You should have received a copy of the GNU Lesser General Public\n *  License along with this library; see the file COPYING.  If not, write to\n *  the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n *\n */\n\n\n#include <gpac/internal/bifs_dev.h>\n#include \"quant.h\"\n\n\n#ifndef GPAC_DISABLE_BIFS\n\nGF_Err ParseMFFieldList(GF_BifsDecoder *codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field);\nGF_Err ParseMFFieldVec(GF_BifsDecoder *codec, GF_BitStream *bs, GF_Node *node, GF_FieldInfo *field);\n\n\nstatic void BM_SetCommandNode(GF_Command *com, GF_Node *node)\n{\n\tcom->node = node;\n\tgf_node_register(node, NULL);\n}\n\nstatic GF_Err BM_ParseMultipleIndexedReplace(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tu32 ID, ind, field_ind, NumBits, lenpos, lennum, count;\n\tGF_Node *node;\n\tGF_Err e;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tGF_FieldInfo field;\n\n\tID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\tnode = gf_sg_find_node(codec->current_graph, ID);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\tNumBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_IN)-1);\n\tind = gf_bs_read_int(bs, NumBits);\n\te = gf_bifs_get_field_index(node, ind, GF_SG_FIELD_CODING_IN, &field_ind);\n\tif (e) return e;\n\te = gf_node_get_field(node, field_ind, &field);\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tlenpos = gf_bs_read_int(bs, 5);\n\tlennum = gf_bs_read_int(bs, 5);\n\tcount = gf_bs_read_int(bs, lennum);\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_MULTIPLE_INDEXED_REPLACE);\n\tBM_SetCommandNode(com, node);\n\tfield.fieldType = gf_sg_vrml_get_sf_type(field.fieldType);\n\n\twhile (count) {\n\t\tinf = gf_sg_command_field_new(com);\n\t\tinf->pos = gf_bs_read_int(bs, lenpos);\n\t\tinf->fieldIndex = field.fieldIndex;\n\t\tinf->fieldType = field.fieldType;\n\n\t\tif (field.fieldType==GF_SG_VRML_SFNODE) {\n\t\t\tinf->new_node = gf_bifs_dec_node(codec, bs, field.NDTtype);\n\t\t\tif (codec->LastError) goto err;\n\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\tgf_node_register(inf->new_node, NULL);\n\t\t} else {\n\t\t\tfield.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t\t\te = gf_bifs_dec_sf_field(codec, bs, node, &field, GF_TRUE);\n\t\t\tif (e) goto err;\n\t\t}\n\t\tcount--;\n\t}\nerr:\n\tif (e) gf_sg_command_del(com);\n\telse gf_list_add(com_list, com);\n\treturn e;\n}\n\nstatic GF_Err BM_ParseMultipleReplace(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tu32 i, numFields, index, flag, nbBits, field_ref, fieldind;\n\tGF_Err e;\n\tGF_FieldInfo field;\n\tu32 NodeID;\n\tGF_Node *node;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\n\tNodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\tnode = gf_sg_find_node(codec->current_graph, NodeID);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\n\te = GF_OK;\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_MULTIPLE_REPLACE);\n\tBM_SetCommandNode(com, node);\n\tflag = gf_bs_read_int(bs, 1);\n\tif (flag) {\n\t\tnumFields = gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_DEF);\n\t\tfor (i=0; i<numFields; i++) {\n\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t\tif (!flag) continue;\n\t\t\tgf_bifs_get_field_index(node, i, GF_SG_FIELD_CODING_DEF, &index);\n\t\t\te = gf_node_get_field(node, index, &field);\n\t\t\tif (e) goto exit;\n\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\tinf->fieldType = field.fieldType;\n\t\t\tinf->fieldIndex = field.fieldIndex;\n\t\t\tif (inf->fieldType==GF_SG_VRML_SFNODE) {\n\t\t\t\tfield.far_ptr = inf->field_ptr = &inf->new_node;\n\t\t\t} else if (inf->fieldType==GF_SG_VRML_MFNODE) {\n\t\t\t\tfield.far_ptr = inf->field_ptr = &inf->node_list;\n\t\t\t} else {\n\t\t\t\tfield.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t\t\t}\n\t\t\te = gf_bifs_dec_field(codec, bs, node, &field, GF_TRUE);\n\t\t\tif (e) goto exit;\n\t\t}\n\t} else {\n\t\tflag = gf_bs_read_int(bs, 1);\n\t\tnbBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_DEF)-1);\n\t\twhile (!flag && (codec->LastError>=0)) {\n\t\t\tfield_ref = gf_bs_read_int(bs, nbBits);\n\t\t\te = gf_bifs_get_field_index(node, field_ref, GF_SG_FIELD_CODING_DEF, &fieldind);\n\t\t\tif (e) goto exit;\n\t\t\te = gf_node_get_field(node, fieldind, &field);\n\t\t\tif (e) goto exit;\n\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\tinf->fieldType = field.fieldType;\n\t\t\tinf->fieldIndex = field.fieldIndex;\n\t\t\tif (inf->fieldType==GF_SG_VRML_SFNODE) {\n\t\t\t\tfield.far_ptr = inf->field_ptr = &inf->new_node;\n\t\t\t} else if (inf->fieldType==GF_SG_VRML_MFNODE) {\n\t\t\t\tfield.far_ptr = inf->field_ptr = &inf->node_list;\n\t\t\t} else {\n\t\t\t\tfield.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t\t\t}\n\t\t\te = gf_bifs_dec_field(codec, bs, node, &field, GF_TRUE);\n\t\t\tif (e) goto exit;\n\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t}\n\t}\n\n\nexit:\n\tif (e) gf_sg_command_del(com);\n\telse gf_list_add(com_list, com);\n\treturn e;\n}\n\nstatic GF_Err BM_ParseGlobalQuantizer(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Node *node;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\tnode = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\n\t/*reset global QP*/\n\tif (codec->scenegraph->global_qp) {\n\t\tgf_node_unregister(codec->scenegraph->global_qp, NULL);\n\t}\n\tcodec->ActiveQP = NULL;\n\tcodec->scenegraph->global_qp = NULL;\n\n\tif (gf_node_get_tag(node) != TAG_MPEG4_QuantizationParameter) {\n\t\t//if node was just created (num_instances == 0), unregister\n\t\t//otherwise (USE node) don't do anything\n\t\tif (!node->sgprivate->num_instances) {\n\t\t\tnode->sgprivate->num_instances = 1;\n\t\t\tgf_node_unregister(node, NULL);\n\t\t}\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\t/*register global QP*/\n\tcodec->ActiveQP = (M_QuantizationParameter *) node;\n\tcodec->ActiveQP->isLocal = 0;\n\tcodec->scenegraph->global_qp = node;\n\n\t/*register TWICE: once for the command, and for the scenegraph globalQP*/\n\tgf_node_unregister(node, NULL);\n\tgf_node_unregister(node, NULL);\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_GLOBAL_QUANTIZER);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = node;\n\tinf->field_ptr = &inf->new_node;\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}\n\nstatic GF_Err BM_ParseProtoDelete(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tu32 flag, count;\n\tGF_Command *com = gf_sg_command_new(codec->current_graph, GF_SG_PROTO_DELETE);\n\tflag = gf_bs_read_int(bs, 1);\n\tif (flag) {\n\t\tcount = 0;\n\t\tflag = gf_bs_read_int(bs, 1);\n\t\twhile (flag) {\n\t\t\tcom->del_proto_list = (u32*)gf_realloc(com->del_proto_list, sizeof(u32) * (com->del_proto_list_size+1));\n\t\t\tcom->del_proto_list[count] = gf_bs_read_int(bs, codec->info->config.ProtoIDBits);\n\t\t\tcom->del_proto_list_size++;\n\t\t\tflag = gf_bs_read_int(bs, 1);\n\t\t}\n\t} else {\n\t\tflag = gf_bs_read_int(bs, 5);\n\t\tcom->del_proto_list_size = gf_bs_read_int(bs, flag);\n\t\tcom->del_proto_list = (u32*)gf_realloc(com->del_proto_list, sizeof(u32) * (com->del_proto_list_size));\n\t\tflag = 0;\n\t\twhile (flag<com->del_proto_list_size) {\n\t\t\tcom->del_proto_list[flag] = gf_bs_read_int(bs, codec->info->config.ProtoIDBits);\n\t\t\tflag++;\n\t\t}\n\t}\n\tgf_list_add(com_list, com);\n\treturn GF_OK;\n}\n\nstatic GF_Err BM_XReplace(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_FieldInfo targetField, fromField, decfield;\n\tGF_Node *target, *fromNode;\n\ts32 pos = -2;\n\tu32 id, nbBits, ind, aind;\n\tGF_Err e;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\n\tid = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\ttarget = gf_sg_find_node(codec->current_graph, id);\n\tif (!target) return GF_SG_UNKNOWN_NODE;\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_XREPLACE);\n\tBM_SetCommandNode(com, target);\n\tgf_list_add(com_list, com);\n\n\tnbBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(target, GF_SG_FIELD_CODING_IN)-1);\n\tind = gf_bs_read_int(bs, nbBits);\n\te = gf_bifs_get_field_index(target, ind, GF_SG_FIELD_CODING_IN, &aind);\n\tif (e) return e;\n\te = gf_node_get_field(target, aind, &targetField);\n\tif (e) return e;\n\n\tinf = gf_sg_command_field_new(com);\n\tinf->fieldIndex = aind;\n\n\tif (!gf_sg_vrml_is_sf_field(targetField.fieldType)) {\n\t\t/*this is indexed replacement*/\n\t\tif (gf_bs_read_int(bs, 1)) {\n\t\t\t/*index is dynamic*/\n\t\t\tif (gf_bs_read_int(bs, 1)) {\n\t\t\t\tGF_Node *n;\n\t\t\t\tid = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\t\t\t\tn = gf_sg_find_node(codec->current_graph, id);\n\t\t\t\tif (!n) return GF_SG_UNKNOWN_NODE;\n\t\t\t\tcom->toNodeID = id;\n\n\t\t\t\tnbBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(n, GF_SG_FIELD_CODING_DEF)-1);\n\t\t\t\tind = gf_bs_read_int(bs, nbBits);\n\t\t\t\te = gf_bifs_get_field_index(n, ind, GF_SG_FIELD_CODING_DEF, &aind);\n\t\t\t\tif (e) return e;\n\t\t\t\te = gf_node_get_field(n, aind, &fromField);\n\t\t\t\tif (e) return e;\n\t\t\t\tcom->toFieldIndex = aind;\n\t\t\t} else {\n\t\t\t\tu32 type = gf_bs_read_int(bs, 2);\n\t\t\t\tswitch (type) {\n\t\t\t\tcase 0:\n\t\t\t\t\tpos = gf_bs_read_int(bs, 16);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 2:\n\t\t\t\t\tpos = 0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 3:\n\t\t\t\t\tpos = -1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (targetField.fieldType==GF_SG_VRML_MFNODE) {\n\t\t\tif (gf_bs_read_int(bs, 1)) {\n\t\t\t\ttarget = gf_node_list_get_child(*(GF_ChildNodeItem **)targetField.far_ptr, pos);\n\t\t\t\tif (!target) return GF_SG_UNKNOWN_NODE;\n\n\t\t\t\tnbBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(target, GF_SG_FIELD_CODING_IN)-1);\n\t\t\t\tind = gf_bs_read_int(bs, nbBits);\n\t\t\t\te = gf_bifs_get_field_index(target, ind, GF_SG_FIELD_CODING_IN, &aind);\n\t\t\t\tif (e) return e;\n\t\t\t\te = gf_node_get_field(target, aind, &targetField);\n\t\t\t\tif (e) return e;\n\t\t\t\tpos = -2;\n\t\t\t\tcom->child_field = aind;\n\t\t\t\tcom->ChildNodeTag = gf_node_get_tag(target);\n\t\t\t\tif (com->ChildNodeTag == TAG_ProtoNode) {\n\t\t\t\t\ts32 p_id = gf_sg_proto_get_id(gf_node_get_proto(target));\n\t\t\t\t\tcom->ChildNodeTag = -p_id;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tinf->pos = pos;\n\t}\n\n\tfromNode = NULL;\n\tif (gf_bs_read_int(bs, 1)) {\n\t\tid = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\t\tfromNode = gf_sg_find_node(codec->current_graph, id);\n\t\tif (!fromNode) return GF_SG_UNKNOWN_NODE;\n\t\tcom->fromNodeID = id;\n\n\t\tnbBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(fromNode, GF_SG_FIELD_CODING_DEF)-1);\n\t\tind = gf_bs_read_int(bs, nbBits);\n\t\te = gf_bifs_get_field_index(fromNode, ind, GF_SG_FIELD_CODING_DEF, &aind);\n\t\tif (e) return e;\n\t\te = gf_node_get_field(fromNode, aind, &fromField);\n\t\tif (e) return e;\n\t\tcom->fromFieldIndex = aind;\n\n\t\treturn GF_OK;\n\t}\n\n\n\tif (pos>= -1) {\n\t\tinf->fieldType = gf_sg_vrml_get_sf_type(targetField.fieldType);\n\t} else {\n\t\tinf->fieldType = targetField.fieldType;\n\t}\n\tdecfield.fieldIndex = inf->fieldIndex;\n\tdecfield.fieldType = inf->fieldType;\n\n\tif (inf->fieldType==GF_SG_VRML_SFNODE) {\n\t\tdecfield.far_ptr = inf->field_ptr = &inf->new_node;\n\t} else if (inf->fieldType==GF_SG_VRML_MFNODE) {\n\t\tdecfield.far_ptr = inf->field_ptr = &inf->node_list;\n\t} else {\n\t\tdecfield.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(inf->fieldType);\n\t}\n\te = gf_bifs_dec_sf_field(codec, bs, target, &decfield, GF_TRUE);\n\treturn e;\n}\n\nstatic GF_Err BM_ParseExtendedUpdates(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tu32 type = gf_bs_read_int(bs, 8);\n\tGF_Err e;\n\n\tswitch (type) {\n\tcase 0:\n\t{\n\t\tGF_Command *com = gf_sg_command_new(codec->current_graph, GF_SG_PROTO_INSERT);\n\t\te = gf_bifs_dec_proto_list(codec, bs, com->new_proto_list);\n\t\tif (e) gf_sg_command_del(com);\n\t\telse gf_list_add(com_list, com);\n\t}\n\treturn e;\n\tcase 1:\n\t\treturn BM_ParseProtoDelete(codec, bs, com_list);\n\tcase 2:\n\t{\n\t\tGF_Command *com = gf_sg_command_new(codec->current_graph, GF_SG_PROTO_DELETE_ALL);\n\t\treturn gf_list_add(com_list, com);\n\t}\n\tcase 3:\n\t\treturn BM_ParseMultipleIndexedReplace(codec, bs, com_list);\n\tcase 4:\n\t\treturn BM_ParseMultipleReplace(codec, bs, com_list);\n\tcase 5:\n\t\treturn BM_ParseGlobalQuantizer(codec, bs, com_list);\n\tcase 6:\n\t{\n\t\tGF_Command *com;\n\t\tu32 ID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\t\tGF_Node *n = gf_sg_find_node(codec->current_graph, ID);\n\t\tif (!n) return GF_OK;\n\t\tcom = gf_sg_command_new(codec->current_graph, GF_SG_NODE_DELETE_EX);\n\t\tBM_SetCommandNode(com, n);\n\t\tgf_list_add(com_list, com);\n\t}\n\treturn GF_OK;\n\tcase 7:\n\t\treturn BM_XReplace(codec, bs, com_list);\n\n\tdefault:\n\t\treturn GF_BIFS_UNKNOWN_VERSION;\n\t}\n}\n\n/*inserts a node in a container (node.children)*/\nGF_Err BM_ParseNodeInsert(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tu32 NodeID, NDT;\n\tGF_CommandField *inf;\n\ts32 type, pos;\n\tGF_Node *node, *def;\n\n\tNodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\tdef = gf_sg_find_node(codec->current_graph, NodeID);\n\tif (!def) return GF_NON_COMPLIANT_BITSTREAM;\n\tNDT = gf_bifs_get_child_table(def);\n\tif (!NDT) return GF_NON_COMPLIANT_BITSTREAM;\n\n\ttype = gf_bs_read_int(bs, 2);\n\tswitch (type) {\n\tcase 0:\n\t\tpos = gf_bs_read_int(bs, 8);\n\t\tbreak;\n\tcase 2:\n\t\tpos = 0;\n\t\tbreak;\n\tcase 3:\n\t\t/*-1 means append*/\n\t\tpos = -1;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\tnode = gf_bifs_dec_node(codec, bs, NDT);\n\tif (!codec->LastError) {\n\t\tGF_Command *com = gf_sg_command_new(codec->current_graph, GF_SG_NODE_INSERT);\n\t\tBM_SetCommandNode(com, def);\n\t\tinf = gf_sg_command_field_new(com);\n\t\tinf->pos = pos;\n\t\tinf->new_node = node;\n\t\tinf->field_ptr = &inf->new_node;\n\t\tinf->fieldType = GF_SG_VRML_SFNODE;\n\t\tgf_list_add(com_list, com);\n\t\t/*register*/\n\t\tgf_node_register(node, NULL);\n\t}\n\treturn codec->LastError;\n}\n\n/*NB This can insert a node as well (but usually not in the .children field)*/\nGF_Err BM_ParseIndexInsert(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Err e;\n\tu32 NodeID;\n\tu32 NumBits, ind, field_ind;\n\tu8 type;\n\tGF_Command *com;\n\tGF_CommandField *inf;\n\ts32 pos;\n\tGF_Node *def, *node;\n\tGF_FieldInfo field, sffield;\n\n\tNodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\tdef = gf_sg_find_node(codec->current_graph, NodeID);\n\tif (!def) return GF_NON_COMPLIANT_BITSTREAM;\n\t/*index insertion uses IN mode for field index*/\n\tNumBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(def, GF_SG_FIELD_CODING_IN)-1);\n\tind = gf_bs_read_int(bs, NumBits);\n\n\te = gf_bifs_get_field_index(def, ind, GF_SG_FIELD_CODING_IN, &field_ind);\n\tif (e) return e;\n\n\ttype = gf_bs_read_int(bs, 2);\n\tswitch (type) {\n\tcase 0:\n\t\tpos = gf_bs_read_int(bs, 16);\n\t\tbreak;\n\tcase 2:\n\t\tpos = 0;\n\t\tbreak;\n\tcase 3:\n\t\tpos = -1;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\te = gf_node_get_field(def, field_ind, &field);\n\tif (e) return e;\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tmemcpy(&sffield, &field, sizeof(GF_FieldInfo));\n\tsffield.fieldType = gf_sg_vrml_get_sf_type(field.fieldType);\n\n\t/*rescale the MFField and parse the SFField*/\n\tif (field.fieldType==GF_SG_VRML_MFNODE) {\n\t\tnode = gf_bifs_dec_node(codec, bs, field.NDTtype);\n\t\tif (!codec->LastError) {\n\t\t\tcom = gf_sg_command_new(codec->current_graph, GF_SG_INDEXED_INSERT);\n\t\t\tBM_SetCommandNode(com, def);\n\t\t\tinf = gf_sg_command_field_new(com);\n\t\t\tinf->pos = pos;\n\t\t\tinf->fieldIndex = field_ind;\n\t\t\tinf->fieldType = sffield.fieldType;\n\t\t\tinf->new_node = node;\n\t\t\tinf->field_ptr = &inf->new_node;\n\t\t\tgf_list_add(com_list, com);\n\t\t\t/*register*/\n\t\t\tgf_node_register(node, NULL);\n\t\t}\n\t} else {\n\t\tcom = gf_sg_command_new(codec->current_graph, GF_SG_INDEXED_INSERT);\n\t\tBM_SetCommandNode(com, def);\n\t\tinf = gf_sg_command_field_new(com);\n\t\tinf->pos = pos;\n\t\tinf->fieldIndex = field_ind;\n\t\tinf->fieldType = sffield.fieldType;\n\t\tsffield.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(sffield.fieldType);\n\t\tcodec->LastError = gf_bifs_dec_sf_field(codec, bs, def, &sffield, GF_TRUE);\n\t\tgf_list_add(com_list, com);\n\t}\n\treturn codec->LastError;\n}\n\n\nGF_Err BM_ParseRouteInsert(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Err e;\n\tu8 flag;\n\tGF_Command *com;\n\tGF_Node *InNode, *OutNode;\n\tu32 RouteID, outField, inField, numBits, ind, node_id;\n\tchar name[1000];\n\n\tRouteID = 0;\n\n\tflag = gf_bs_read_int(bs, 1);\n\t/*def'ed route*/\n\tif (flag) {\n\t\tRouteID = 1 + gf_bs_read_int(bs, codec->info->config.RouteIDBits);\n\t\tif (codec->UseName) gf_bifs_dec_name(bs, name, 1000);\n\t}\n\t/*origin*/\n\tnode_id = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\tOutNode = gf_sg_find_node(codec->current_graph, node_id);\n\tif (!OutNode) return GF_SG_UNKNOWN_NODE;\n\n\tnumBits = gf_node_get_num_fields_in_mode(OutNode, GF_SG_FIELD_CODING_OUT) - 1;\n\tnumBits = gf_get_bit_size(numBits);\n\tind = gf_bs_read_int(bs, numBits);\n\te = gf_bifs_get_field_index(OutNode, ind, GF_SG_FIELD_CODING_OUT, &outField);\n\tif (e) return e;\n\n\t/*target*/\n\tnode_id = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\tInNode = gf_sg_find_node(codec->current_graph, node_id);\n\tif (!InNode) return GF_SG_UNKNOWN_NODE;\n\n\tnumBits = gf_node_get_num_fields_in_mode(InNode, GF_SG_FIELD_CODING_IN) - 1;\n\tnumBits = gf_get_bit_size(numBits);\n\tind = gf_bs_read_int(bs, numBits);\n\te = gf_bifs_get_field_index(InNode, ind, GF_SG_FIELD_CODING_IN, &inField);\n\tif (e) return e;\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_ROUTE_INSERT);\n\tcom->RouteID = RouteID;\n\tif (codec->UseName) com->def_name = gf_strdup( name);\n\tcom->fromNodeID = gf_node_get_id(OutNode);\n\tcom->fromFieldIndex = outField;\n\tcom->toNodeID = gf_node_get_id(InNode);\n\tcom->toFieldIndex = inField;\n\tgf_list_add(com_list, com);\n\treturn codec->LastError;\n}\n\n\nGF_Err BM_ParseInsert(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tu8 type;\n\n\ttype = gf_bs_read_int(bs, 2);\n\tswitch (type) {\n\tcase 0:\n\t\treturn BM_ParseNodeInsert(codec, bs, com_list);\n\tcase 1:\n\t\treturn BM_ParseExtendedUpdates(codec, bs, com_list);\n\tcase 2:\n\t\treturn BM_ParseIndexInsert(codec, bs, com_list);\n\tcase 3:\n\t\treturn BM_ParseRouteInsert(codec, bs, com_list);\n\tdefault:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n}\n\n\nGF_Err BM_ParseIndexDelete(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tu32 NodeID, NumBits, ind, field_ind;\n\ts32 pos;\n\tGF_Command *com;\n\tu8 type;\n\tGF_Node *node;\n\tGF_Err e;\n\tGF_CommandField *inf;\n\tGF_FieldInfo field;\n\n\tNodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\tnode = gf_sg_find_node(codec->current_graph, NodeID);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tNumBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_IN) - 1);\n\tind = gf_bs_read_int(bs, NumBits);\n\n\ttype = gf_bs_read_int(bs, 2);\n\tswitch (type) {\n\tcase 0:\n\t\tpos = (u32) gf_bs_read_int(bs, 16);\n\t\tbreak;\n\tcase 2:\n\t\tpos = 0;\n\t\tbreak;\n\tcase 3:\n\t\tpos = -1;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\te = gf_bifs_get_field_index(node, ind, GF_SG_FIELD_CODING_IN, &field_ind);\n\tif (e) return e;\n\te = gf_node_get_field(node, field_ind, &field);\n\tif (e) return e;\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) return GF_NON_COMPLIANT_BITSTREAM;\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_INDEXED_DELETE);\n\tBM_SetCommandNode(com, node);\n\tinf = gf_sg_command_field_new(com);\n\tinf->pos = pos;\n\tinf->fieldIndex = field.fieldIndex;\n\tinf->fieldType = gf_sg_vrml_get_sf_type(field.fieldType);\n\tgf_list_add(com_list, com);\n\treturn codec->LastError;\n}\n\n\n\nGF_Err BM_ParseDelete(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tu8 type;\n\tu32 ID;\n\tGF_Command *com;\n\tGF_Node *n;\n\n\ttype = gf_bs_read_int(bs, 2);\n\tswitch (type) {\n\tcase 0:\n\t\tID = 1+gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\t\tn = gf_sg_find_node(codec->current_graph, ID);\n\t\tif (!n) return GF_OK;\n\t\tcom = gf_sg_command_new(codec->current_graph, GF_SG_NODE_DELETE);\n\t\tBM_SetCommandNode(com, n);\n\t\tgf_list_add(com_list, com);\n\t\treturn GF_OK;\n\tcase 2:\n\t\treturn BM_ParseIndexDelete(codec, bs, com_list);\n\tcase 3:\n\t\tcom = gf_sg_command_new(codec->current_graph, GF_SG_ROUTE_DELETE);\n\t\tcom->RouteID = 1+gf_bs_read_int(bs, codec->info->config.RouteIDBits);\n\t\tgf_list_add(com_list, com);\n\t\treturn GF_OK;\n\tdefault:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\treturn GF_OK;\n}\n\n\nGF_Err BM_ParseNodeReplace(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tu32 NodeID;\n\tGF_Command *com;\n\tGF_Node *node;\n\tGF_CommandField *inf;\n\n\tNodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\t/*this is delete / new on a DEF node: replace ALL instances*/\n\tnode = gf_sg_find_node(codec->current_graph, NodeID);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_NODE_REPLACE);\n\tBM_SetCommandNode(com, node);\n\tinf = gf_sg_command_field_new(com);\n\tinf->new_node = gf_bifs_dec_node(codec, bs, NDT_SFWorldNode);\n\tinf->fieldType = GF_SG_VRML_SFNODE;\n\tinf->field_ptr = &inf->new_node;\n\tgf_list_add(com_list, com);\n\tgf_node_register(inf->new_node, NULL);\n\treturn codec->LastError;\n}\n\nGF_Err BM_ParseFieldReplace(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Err e;\n\tGF_Command *com;\n\tu32 NodeID, ind, field_ind, NumBits;\n\tGF_Node *node;\n\tGF_FieldInfo field;\n\tGF_CommandField *inf;\n\n\tNodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\tnode = gf_sg_find_node(codec->current_graph, NodeID);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\tNumBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_IN)-1);\n\tind = gf_bs_read_int(bs, NumBits);\n\te = gf_bifs_get_field_index(node, ind, GF_SG_FIELD_CODING_IN, &field_ind);\n\tif (e) return e;\n\n\te = gf_node_get_field(node, field_ind, &field);\n\tif (e) return e;\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_FIELD_REPLACE);\n\tBM_SetCommandNode(com, node);\n\tinf = gf_sg_command_field_new(com);\n\tinf->fieldIndex = field_ind;\n\tinf->fieldType = field.fieldType;\n\tif (inf->fieldType == GF_SG_VRML_SFNODE) {\n\t\tfield.far_ptr = inf->field_ptr = &inf->new_node;\n\t} else if (inf->fieldType == GF_SG_VRML_MFNODE) {\n\t\tfield.far_ptr = inf->field_ptr = &inf->node_list;\n\t} else {\n\t\tfield.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(field.fieldType);\n\t}\n\t/*parse the field*/\n\tcodec->LastError = gf_bifs_dec_field(codec, bs, node, &field, GF_TRUE);\n\n\tgf_list_add(com_list, com);\n\treturn codec->LastError;\n}\n\nGF_Err BM_ParseIndexValueReplace(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tu32 NodeID, ind, field_ind, NumBits;\n\ts32 type, pos;\n\tGF_Command *com;\n\tGF_Node *node;\n\tGF_Err e;\n\tGF_FieldInfo field, sffield;\n\tGF_CommandField *inf;\n\n\t/*get the node*/\n\tNodeID = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\n\tnode = gf_sg_find_node(codec->current_graph, NodeID);\n\tif (!node) return GF_NON_COMPLIANT_BITSTREAM;\n\tNumBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(node, GF_SG_FIELD_CODING_IN)-1);\n\tind = gf_bs_read_int(bs, NumBits);\n\te = gf_bifs_get_field_index(node, ind, GF_SG_FIELD_CODING_IN, &field_ind);\n\tif (e) return e;\n\n\te = gf_node_get_field(node, field_ind, &field);\n\tif (e) return e;\n\tif (gf_sg_vrml_is_sf_field(field.fieldType)) return GF_NON_COMPLIANT_BITSTREAM;\n\n\ttype = gf_bs_read_int(bs, 2);\n\tswitch (type) {\n\tcase 0:\n\t\tpos = gf_bs_read_int(bs, 16);\n\t\tbreak;\n\tcase 2:\n\t\tpos = 0;\n\t\tbreak;\n\tcase 3:\n\t\tpos = ((GenMFField *) field.far_ptr)->count - 1;\n\t\tbreak;\n\tdefault:\n\t\treturn GF_NON_COMPLIANT_BITSTREAM;\n\t}\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_INDEXED_REPLACE);\n\tBM_SetCommandNode(com, node);\n\tinf = gf_sg_command_field_new(com);\n\tinf->fieldIndex = field.fieldIndex;\n\tinf->pos = pos;\n\n\tif (field.fieldType == GF_SG_VRML_MFNODE) {\n\t\tinf->fieldType = GF_SG_VRML_SFNODE;\n\t\tinf->new_node = gf_bifs_dec_node(codec, bs, field.NDTtype);\n\t\tinf->field_ptr = &inf->new_node;\n\t\tif (inf->new_node) gf_node_register(inf->new_node, NULL);\n\t} else {\n\t\tmemcpy(&sffield, &field, sizeof(GF_FieldInfo));\n\t\tsffield.fieldType = gf_sg_vrml_get_sf_type(field.fieldType);\n\t\tinf->fieldType = sffield.fieldType;\n\t\tsffield.far_ptr = inf->field_ptr = gf_sg_vrml_field_pointer_new(sffield.fieldType);\n\t\tcodec->LastError = gf_bifs_dec_sf_field(codec, bs, node, &sffield, GF_TRUE);\n\t}\n\tgf_list_add(com_list, com);\n\treturn codec->LastError;\n}\n\nGF_Err BM_ParseRouteReplace(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Err e;\n\tGF_Command *com;\n\tu32 RouteID, numBits, ind, node_id, fromID, toID;\n\tGF_Node *OutNode, *InNode;\n\n\tRouteID = 1+gf_bs_read_int(bs, codec->info->config.RouteIDBits);\n\n\t/*origin*/\n\tnode_id = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\tOutNode = gf_sg_find_node(codec->current_graph, node_id);\n\tif (!OutNode) return GF_NON_COMPLIANT_BITSTREAM;\n\tnumBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(OutNode, GF_SG_FIELD_CODING_OUT) - 1);\n\tind = gf_bs_read_int(bs, numBits);\n\te = gf_bifs_get_field_index(OutNode, ind, GF_SG_FIELD_CODING_OUT, &fromID);\n\tif (e) return e;\n\n\t/*target*/\n\tnode_id = 1 + gf_bs_read_int(bs, codec->info->config.NodeIDBits);\n\tInNode = gf_sg_find_node(codec->current_graph, node_id);\n\tif (!InNode) return GF_NON_COMPLIANT_BITSTREAM;\n\tnumBits = gf_get_bit_size(gf_node_get_num_fields_in_mode(InNode, GF_SG_FIELD_CODING_IN) - 1);\n\tind = gf_bs_read_int(bs, numBits);\n\te = gf_bifs_get_field_index(InNode, ind, GF_SG_FIELD_CODING_IN, &toID);\n\tif (e) return e;\n\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_ROUTE_REPLACE);\n\tcom->RouteID = RouteID;\n\tcom->fromNodeID = gf_node_get_id(OutNode);\n\tcom->fromFieldIndex = fromID;\n\tcom->toNodeID = gf_node_get_id(InNode);\n\tcom->toFieldIndex = toID;\n\tgf_list_add(com_list, com);\n\treturn codec->LastError;\n}\n\n\nGF_Err BM_ParseReplace(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tu8 type;\n\ttype = gf_bs_read_int(bs, 2);\n\tswitch (type) {\n\tcase 0:\n\t\treturn BM_ParseNodeReplace(codec, bs, com_list);\n\tcase 1:\n\t\treturn BM_ParseFieldReplace(codec, bs, com_list);\n\tcase 2:\n\t\treturn BM_ParseIndexValueReplace(codec, bs, com_list);\n\tcase 3:\n\t\treturn BM_ParseRouteReplace(codec, bs, com_list);\n\t}\n\treturn GF_OK;\n}\n\nGF_Err BM_SceneReplace(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tGF_Command *com;\n\tGF_Node *backup_root;\n\tGF_List *backup_routes;\n\tGF_Err BD_DecSceneReplace(GF_BifsDecoder * codec, GF_BitStream *bs, GF_List *proto_list);\n\n\tbackup_routes = codec->scenegraph->Routes;\n\tbackup_root = codec->scenegraph->RootNode;\n\tcom = gf_sg_command_new(codec->current_graph, GF_SG_SCENE_REPLACE);\n\tcodec->scenegraph->Routes = gf_list_new();\n\tcodec->current_graph = codec->scenegraph;\n\tcodec->LastError = BD_DecSceneReplace(codec, bs, com->new_proto_list);\n\tcom->use_names = codec->UseName;\n\n\t/*restore*/\n\tcom->node = codec->scenegraph->RootNode;\n\tcodec->scenegraph->RootNode = backup_root;\n\tgf_list_add(com_list, com);\n\t/*insert routes*/\n\twhile (gf_list_count(codec->scenegraph->Routes)) {\n\t\tGF_Route *r = (GF_Route*)gf_list_get(codec->scenegraph->Routes, 0);\n\t\tGF_Command *ri = gf_sg_command_new(codec->current_graph, GF_SG_ROUTE_INSERT);\n\t\tgf_list_rem(codec->scenegraph->Routes, 0);\n\t\tri->fromFieldIndex = r->FromField.fieldIndex;\n\t\tri->fromNodeID = gf_node_get_id(r->FromNode);\n\t\tri->toFieldIndex = r->ToField.fieldIndex;\n\t\tri->toNodeID = gf_node_get_id(r->ToNode);\n\t\tif (r->ID) ri->RouteID = r->ID;\n\t\tri->def_name = r->name ? gf_strdup(r->name) : NULL;\n\t\tgf_list_add(com_list, ri);\n\t\tgf_sg_route_del(r);\n\t}\n\tgf_list_del(codec->scenegraph->Routes);\n\tcodec->scenegraph->Routes = backup_routes;\n\treturn codec->LastError;\n}\n\n\nGF_Err BM_ParseCommand(GF_BifsDecoder *codec, GF_BitStream *bs, GF_List *com_list)\n{\n\tu8 go, type;\n\tGF_Err e;\n\tgo = 1;\n\te = GF_OK;\n\tGF_SceneGraph *cur_graph = codec->current_graph;\n\tGF_Proto *cur_proto = codec->pCurrentProto;\n\n\tcodec->LastError = GF_OK;\n\twhile (go) {\n\t\ttype = gf_bs_read_int(bs, 2);\n\t\tswitch (type) {\n\t\tcase 0:\n\t\t\te = BM_ParseInsert(codec, bs, com_list);\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\te = BM_ParseDelete(codec, bs, com_list);\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\te = BM_ParseReplace(codec, bs, com_list);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\te = BM_SceneReplace(codec, bs, com_list);\n\t\t\tbreak;\n\t\t}\n\t\tif (e) break;\n\t\tgo = gf_bs_read_int(bs, 1);\n\t}\n\twhile (gf_list_count(codec->QPs)) {\n\t\tgf_bifs_dec_qp_remove(codec, GF_TRUE);\n\t}\n\n\tcodec->current_graph = cur_graph;\n\tcodec->pCurrentProto = cur_proto;\n\treturn e;\n}\n\nvoid BM_EndOfStream(void *co)\n{\n\t((GF_BifsDecoder *) co)->LastError = GF_NON_COMPLIANT_BITSTREAM;\n}\n\nvoid gf_bs_set_eos_callback(GF_BitStream *bs, void (*EndOfStream)(void *par), void *par);\n\n\nGF_Err gf_bifs_flush_command_list(GF_BifsDecoder *codec)\n{\n\tGF_BitStream *bs;\n\tGF_Err e;\n\tCommandBufferItem *cbi;\n\tGF_SceneGraph *prev_root = codec->current_graph;\n\tM_QuantizationParameter *prev_qp = codec->ActiveQP;\n\tu32 prev_qp_count = gf_list_count(codec->QPs);\n\tu32 NbPass = gf_list_count(codec->command_buffers);\n\n\n\tcodec->ActiveQP = NULL;\n\tGF_List *nextPass = gf_list_new();\n\twhile (NbPass) {\n\t\twhile (gf_list_count(codec->command_buffers)) {\n\t\t\tcbi = (CommandBufferItem *)gf_list_get(codec->command_buffers, 0);\n\t\t\tgf_list_rem(codec->command_buffers, 0);\n\n\t\t\tcodec->current_graph = gf_node_get_graph(cbi->node);\n\t\t\te = GF_OK;\n\t\t\tif (cbi->cb->bufferSize) {\n\t\t\t\tbs = gf_bs_new((char*)cbi->cb->buffer, cbi->cb->bufferSize, GF_BITSTREAM_READ);\n\t\t\t\tgf_bs_set_eos_callback(bs, BM_EndOfStream, codec);\n\t\t\t\te = BM_ParseCommand(codec, bs, cbi->cb->commandList);\n\t\t\t\tgf_bs_del(bs);\n\t\t\t}\n\t\t\tif (!e) {\n\t\t\t\tgf_node_unregister(cbi->node, NULL);\n\t\t\t\tgf_free(cbi);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/*this may be an error or a dependency pb - reset coimmand list and move to next pass*/\n\t\t\twhile (gf_list_count(cbi->cb->commandList)) {\n\t\t\t\tu32 i;\n\t\t\t\tGF_CommandField *cf;\n\t\t\t\tGF_Command *com = (GF_Command *)gf_list_get(cbi->cb->commandList, 0);\n\t\t\t\tgf_list_rem(cbi->cb->commandList, 0);\n\t\t\t\tcf = (GF_CommandField *) gf_list_get(com->command_fields, 0);\n\t\t\t\tif (cf && cf->fieldType==GF_SG_VRML_SFCOMMANDBUFFER) {\n\t\t\t\t\tfor (i=0; i<gf_list_count(codec->command_buffers); i++) {\n\t\t\t\t\t\tCommandBufferItem *cbi2 = (CommandBufferItem *)gf_list_get(codec->command_buffers, i);\n\t\t\t\t\t\tif (cbi2->cb == cf->field_ptr) {\n\t\t\t\t\t\t\tgf_node_unregister(cbi2->node, NULL);\n\t\t\t\t\t\t\tgf_free(cbi2);\n\t\t\t\t\t\t\tgf_list_rem(codec->command_buffers, i);\n\t\t\t\t\t\t\ti--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tgf_sg_command_del(com);\n\t\t\t}\n\t\t\tgf_list_add(nextPass, cbi);\n\t\t}\n\t\tif (!gf_list_count(nextPass)) break;\n\t\t/*prepare next pass*/\n\t\twhile (gf_list_count(nextPass)) {\n\t\t\tcbi = (CommandBufferItem *)gf_list_get(nextPass, 0);\n\t\t\tgf_list_rem(nextPass, 0);\n\t\t\tgf_list_add(codec->command_buffers, cbi);\n\t\t}\n\t\tNbPass --;\n\t\tif (NbPass > gf_list_count(codec->command_buffers)) NbPass = gf_list_count(codec->command_buffers);\n\n\t\t//restore QP state\n\t\twhile (gf_list_count(codec->QPs) > prev_qp_count) {\n\t\t\tgf_list_rem(codec->QPs, 0); //QPs are inserted at head of list\n\t\t}\n\t\tcodec->ActiveQP = NULL;\n\t\tcodec->LastError = GF_OK;\n\t}\n\tgf_list_del(nextPass);\n\tcodec->current_graph = prev_root;\n\tcodec->ActiveQP = prev_qp;\n\treturn GF_OK;\n}\n\nGF_EXPORT\nGF_Err gf_bifs_decode_command_list(GF_BifsDecoder *codec, u16 ESID, u8 *data, u32 data_length, GF_List *com_list)\n{\n\tGF_BitStream *bs;\n\tGF_Err e;\n\n\tif (!codec || !data || !codec->dec_memory_mode || !com_list) return GF_BAD_PARAM;\n\n\tcodec->info = gf_bifs_dec_get_stream(codec, ESID);\n\tif (!codec->info) return GF_BAD_PARAM;\n\tif (codec->info->config.elementaryMasks ) return GF_NOT_SUPPORTED;\n\n\t/*root parse (not conditionals)*/\n\tassert(codec->scenegraph);\n\t/*setup current scene graph*/\n\tcodec->current_graph = codec->scenegraph;\n\n\tcodec->ActiveQP = (M_QuantizationParameter*) codec->scenegraph->global_qp;\n\n\tbs = gf_bs_new(data, data_length, GF_BITSTREAM_READ);\n\tgf_bs_set_eos_callback(bs, BM_EndOfStream, codec);\n\n\te = BM_ParseCommand(codec, bs, com_list);\n\tgf_bs_del(bs);\n\n\t/*decode conditionals / input sensors*/\n\tif (!e) {\n\t\tgf_bifs_flush_command_list(codec);\n\t}\n\t/*if err or not reset conditionals*/\n\twhile (gf_list_count(codec->command_buffers)) {\n\t\tCommandBufferItem *cbi = (CommandBufferItem *)gf_list_get(codec->command_buffers, 0);\n\t\tgf_node_unregister(cbi->node, NULL);\n\t\tgf_free(cbi);\n\t\tgf_list_rem(codec->command_buffers, 0);\n\t}\n\n\t/*reset current config*/\n\tcodec->info = NULL;\n\tcodec->current_graph = NULL;\n\n\n\n//\tgf_mx_v(codec->mx);\n\treturn e;\n}\n\n#endif /*GPAC_DISABLE_BIFS*/\n\n"], "filenames": ["src/bifs/memory_decoder.c"], "buggy_code_start_loc": [181], "buggy_code_end_loc": [192], "fixing_code_start_loc": [181], "fixing_code_end_loc": [198], "type": "CWE-416", "message": "Use After Free in GitHub repository gpac/gpac prior to v2.1.0-DEV.", "other": {"cve": {"id": "CVE-2022-1795", "sourceIdentifier": "security@huntr.dev", "published": "2022-05-18T15:15:09.143", "lastModified": "2023-05-27T04:15:20.487", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Use After Free in GitHub repository gpac/gpac prior to v2.1.0-DEV."}, {"lang": "es", "value": "Un Uso de Memoria Previamente Liberada en el repositorio de GitHub gpac/gpac versiones anteriores a v2.1.0-DEV"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:H/PR:N/UI:N/S:C/C:L/I:L/A:H", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "HIGH", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.4, "impactScore": 5.3}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gpac:gpac:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.0", "matchCriteriaId": "206158F0-04ED-4B10-90D6-22D4F209FE36"}]}]}], "references": [{"url": "https://github.com/gpac/gpac/commit/c535bad50d5812d27ee5b22b54371bddec411514", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/9c312763-41a6-4fc7-827b-269eb86efcbc", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5411", "source": "security@huntr.dev"}]}, "github_commit_url": "https://github.com/gpac/gpac/commit/c535bad50d5812d27ee5b22b54371bddec411514"}}