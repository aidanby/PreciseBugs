{"buggy_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include <cstddef>\n#include <cstdlib>\n#include <string>\n\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/framework/kernel_def_builder.h\"\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/tensor_types.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/kernels/string_util.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/core/stringpiece.h\"\n#include \"tensorflow/core/platform/types.h\"\n#include \"tensorflow/core/util/bcast.h\"\n\nnamespace tensorflow {\n\n// Position/length can be 32 or 64-bit integers\ntemplate <typename T>\nclass SubstrOp : public OpKernel {\n public:\n  explicit SubstrOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    string unit;\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"unit\", &unit));\n    OP_REQUIRES_OK(ctx, ParseCharUnit(unit, &unit_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    // Get inputs\n    const Tensor& input_tensor = context->input(0);\n    const Tensor& pos_tensor = context->input(1);\n    const Tensor& len_tensor = context->input(2);\n    const TensorShape& input_shape = input_tensor.shape();\n    const TensorShape& pos_shape = pos_tensor.shape();\n\n    bool is_scalar = TensorShapeUtils::IsScalar(pos_shape);\n\n    if (is_scalar || input_shape == pos_shape) {\n      // pos/len are either scalar or match the shape of input_tensor\n      // Do not need to do broadcasting\n\n      // Reshape input\n      auto input = input_tensor.flat<tstring>();\n      // Allocate output\n      Tensor* output_tensor = nullptr;\n      OP_REQUIRES_OK(context,\n                     context->allocate_output(\"output\", input_tensor.shape(),\n                                              &output_tensor));\n      auto output = output_tensor->flat<tstring>();\n      if (is_scalar) {\n        // Perform Op with scalar pos/len\n        const T pos =\n            tensorflow::internal::SubtleMustCopy(pos_tensor.scalar<T>()());\n        const T len =\n            tensorflow::internal::SubtleMustCopy(len_tensor.scalar<T>()());\n        for (size_t i = 0; i < input_tensor.NumElements(); ++i) {\n          StringPiece in(input(i));\n          T byte_pos = pos;\n          T byte_len = len;\n          switch (unit_) {\n            case CharUnit::UTF8_CHAR:\n              OP_REQUIRES(\n                  context, UpdatePosAndLenForUtf8(in, &byte_pos, &byte_len),\n                  errors::InvalidArgument(\"pos \", pos, \" out of range for \",\n                                          \"string at index \", i));\n              break;\n            case CharUnit::BYTE:\n              byte_pos = AdjustedPosIndex(byte_pos, in);\n              OP_REQUIRES(\n                  context, FastBoundsCheck(byte_pos, in.size() + 1),\n                  errors::InvalidArgument(\"pos \", pos, \" out of range for \",\n                                          \"string b'\", in, \"' at index \", i));\n          }\n          StringPiece sub_in = in.substr(byte_pos, byte_len);\n          output(i).assign(sub_in.data(), sub_in.size());\n        }\n      } else {\n        // Perform Op element-wise with tensor pos/len\n        auto pos_flat = pos_tensor.flat<T>();\n        auto len_flat = len_tensor.flat<T>();\n        for (size_t i = 0; i < input_tensor.NumElements(); ++i) {\n          StringPiece in(input(i));\n          const T pos = tensorflow::internal::SubtleMustCopy(pos_flat(i));\n          const T len = tensorflow::internal::SubtleMustCopy(len_flat(i));\n          T byte_pos = pos;\n          T byte_len = len;\n          switch (unit_) {\n            case CharUnit::UTF8_CHAR:\n              OP_REQUIRES(\n                  context, UpdatePosAndLenForUtf8(in, &byte_pos, &byte_len),\n                  errors::InvalidArgument(\"pos \", pos, \" out of range for \",\n                                          \"string at index \", i));\n              break;\n            case CharUnit::BYTE:\n              byte_pos = AdjustedPosIndex(byte_pos, in);\n              OP_REQUIRES(\n                  context, FastBoundsCheck(byte_pos, in.size() + 1),\n                  errors::InvalidArgument(\"pos \", pos, \" out of range for \",\n                                          \"string b'\", in, \"' at index \", i));\n          }\n          StringPiece sub_in = in.substr(byte_pos, byte_len);\n          output(i).assign(sub_in.data(), sub_in.size());\n        }\n      }\n    } else {\n      // Perform op with broadcasting\n      // TODO: Use ternary broadcasting for once available in Eigen. Current\n      //       implementation iterates through broadcasted ops element-wise;\n      //       this should be parallelized.\n\n      // Create BCast helper with shape of input and pos/len\n      BCast bcast(BCast::FromShape(input_shape), BCast::FromShape(pos_shape));\n      OP_REQUIRES(context, bcast.IsValid(),\n                  errors::InvalidArgument(\n                      \"Incompatible shapes: \", input_shape.DebugString(),\n                      \" vs. \", pos_shape.DebugString()));\n      TensorShape output_shape = BCast::ToShape(bcast.result_shape());\n      int ndims = output_shape.dims();\n      Tensor* output_tensor = nullptr;\n      OP_REQUIRES_OK(context, context->allocate_output(\"output\", output_shape,\n                                                       &output_tensor));\n      switch (ndims) {\n        case 1: {\n          // Reshape tensors according to BCast results\n          auto input = input_tensor.shaped<tstring, 1>(bcast.x_reshape());\n          auto output = output_tensor->shaped<tstring, 1>(bcast.result_shape());\n          auto pos_shaped = pos_tensor.shaped<T, 1>(bcast.y_reshape());\n          auto len_shaped = len_tensor.shaped<T, 1>(bcast.y_reshape());\n\n          // Allocate temporary buffer for broadcasted input tensor\n          Tensor input_buffer;\n          OP_REQUIRES_OK(context, context->allocate_temp(\n                                      DT_STRING, output_shape, &input_buffer));\n          TTypes<tstring, 1>::Tensor input_bcast =\n              input_buffer.shaped<tstring, 1>(bcast.result_shape());\n          input_bcast =\n              input.broadcast(BCast::ToIndexArray<1>(bcast.x_bcast()));\n\n          // Allocate temporary buffer for broadcasted position tensor\n          Tensor pos_buffer;\n          OP_REQUIRES_OK(context,\n                         context->allocate_temp(DataTypeToEnum<T>::v(),\n                                                output_shape, &pos_buffer));\n          typename TTypes<T, 1>::Tensor pos_bcast(\n              pos_buffer.shaped<T, 1>(bcast.result_shape()));\n          pos_bcast =\n              pos_shaped.broadcast(BCast::ToIndexArray<1>(bcast.y_bcast()));\n\n          // Allocate temporary buffer for broadcasted length tensor\n          Tensor len_buffer;\n          OP_REQUIRES_OK(context,\n                         context->allocate_temp(DataTypeToEnum<T>::v(),\n                                                output_shape, &len_buffer));\n          typename TTypes<T, 1>::Tensor len_bcast(\n              len_buffer.shaped<T, 1>(bcast.result_shape()));\n          len_bcast =\n              len_shaped.broadcast(BCast::ToIndexArray<1>(bcast.y_bcast()));\n\n          // Iterate through broadcasted tensors and perform substr\n          for (int i = 0; i < output_shape.dim_size(0); ++i) {\n            StringPiece in(input_bcast(i));\n            const T pos = tensorflow::internal::SubtleMustCopy(pos_bcast(i));\n            const T len = tensorflow::internal::SubtleMustCopy(len_bcast(i));\n            T byte_pos = pos;\n            T byte_len = len;\n            switch (unit_) {\n              case CharUnit::UTF8_CHAR:\n                OP_REQUIRES(\n                    context, UpdatePosAndLenForUtf8(in, &byte_pos, &byte_len),\n                    errors::InvalidArgument(\"pos \", pos, \" out of range for \",\n                                            \"string at index \", i));\n                break;\n              case CharUnit::BYTE:\n                byte_pos = AdjustedPosIndex(byte_pos, in);\n                OP_REQUIRES(\n                    context,\n                    FastBoundsCheck(byte_pos, input_bcast(i).size() + 1),\n                    errors::InvalidArgument(\"pos \", pos, \" out of range for \",\n                                            \"string b'\", in, \"' at index \", i));\n            }\n            StringPiece sub_in = in.substr(byte_pos, byte_len);\n            output(i).assign(sub_in.data(), sub_in.size());\n          }\n          break;\n        }\n        case 2: {\n          // Reshape tensors according to BCast results\n          auto input = input_tensor.shaped<tstring, 2>(bcast.x_reshape());\n          auto output = output_tensor->shaped<tstring, 2>(bcast.result_shape());\n          auto pos_shaped = pos_tensor.shaped<T, 2>(bcast.y_reshape());\n          auto len_shaped = len_tensor.shaped<T, 2>(bcast.y_reshape());\n\n          // Allocate temporary buffer for broadcasted input tensor\n          Tensor input_buffer;\n          OP_REQUIRES_OK(context, context->allocate_temp(\n                                      DT_STRING, output_shape, &input_buffer));\n          TTypes<tstring, 2>::Tensor input_bcast =\n              input_buffer.shaped<tstring, 2>(bcast.result_shape());\n          input_bcast =\n              input.broadcast(BCast::ToIndexArray<2>(bcast.x_bcast()));\n\n          // Allocate temporary buffer for broadcasted position tensor\n          Tensor pos_buffer;\n          OP_REQUIRES_OK(context,\n                         context->allocate_temp(DataTypeToEnum<T>::v(),\n                                                output_shape, &pos_buffer));\n          typename TTypes<T, 2>::Tensor pos_bcast(\n              pos_buffer.shaped<T, 2>(bcast.result_shape()));\n          pos_bcast =\n              pos_shaped.broadcast(BCast::ToIndexArray<2>(bcast.y_bcast()));\n\n          // Allocate temporary buffer for broadcasted length tensor\n          Tensor len_buffer;\n          OP_REQUIRES_OK(context,\n                         context->allocate_temp(DataTypeToEnum<T>::v(),\n                                                output_shape, &len_buffer));\n          typename TTypes<T, 2>::Tensor len_bcast(\n              len_buffer.shaped<T, 2>(bcast.result_shape()));\n          len_bcast =\n              len_shaped.broadcast(BCast::ToIndexArray<2>(bcast.y_bcast()));\n\n          // Iterate through broadcasted tensors and perform substr\n          for (int i = 0; i < output_shape.dim_size(0); ++i) {\n            for (int j = 0; j < output_shape.dim_size(1); ++j) {\n              StringPiece in(input_bcast(i, j));\n              const T pos =\n                  tensorflow::internal::SubtleMustCopy(pos_bcast(i, j));\n              const T len =\n                  tensorflow::internal::SubtleMustCopy(len_bcast(i, j));\n              T byte_pos = pos;\n              T byte_len = len;\n              switch (unit_) {\n                case CharUnit::UTF8_CHAR:\n                  OP_REQUIRES(\n                      context, UpdatePosAndLenForUtf8(in, &byte_pos, &byte_len),\n                      errors::InvalidArgument(\"pos \", pos, \" out of range for \",\n                                              \"string at index \", i));\n                  break;\n                case CharUnit::BYTE:\n                  byte_pos = AdjustedPosIndex(byte_pos, in);\n                  OP_REQUIRES(\n                      context, FastBoundsCheck(byte_pos, in.size() + 1),\n                      errors::InvalidArgument(\"pos \", pos, \" out of range for \",\n                                              \"string b'\", in, \"' at index (\",\n                                              i, \", \", j, \")\"));\n              }\n              StringPiece sub_in = in.substr(byte_pos, byte_len);\n              output(i, j).assign(sub_in.data(), sub_in.size());\n            }\n          }\n          break;\n        }\n        default: {\n          context->SetStatus(errors::Unimplemented(\n              \"Substr broadcast not implemented for \", ndims, \" dimensions\"));\n        }\n      }\n    }\n  }\n\n private:\n  // This adjusts the requested position. Note it does not perform any bound\n  // checks.\n  static inline T AdjustedPosIndex(const T pos_requested, const StringPiece s) {\n    if (pos_requested < 0) {\n      return s.size() + pos_requested;\n    }\n    return pos_requested;\n  }\n\n  // Return true if successful; otherwise, return false if the `pos` argument\n  // is out of range in the string.\n  static inline bool UpdatePosAndLenForUtf8(const StringPiece in, T* pos,\n                                            T* len) {\n    if (*pos >= 0) {\n      return UpdatePositivePosAndLenForUtf8(in, *pos, *len, pos, len);\n    } else {\n      return UpdateNegativePosAndLenForUtf8(in, *pos, *len, pos, len);\n    }\n  }\n\n  static bool UpdatePositivePosAndLenForUtf8(const StringPiece in, const T pos,\n                                             const T len, T* char_pos,\n                                             T* char_len) {\n    *char_pos = 0;\n    // Determine byte position of the substring start.\n    if (!ForwardNUTF8CharPositions(in, pos, char_pos)) {\n      return false;\n    }\n    // Determine position of the end of the substring.\n    // The length will be capped at the end of the string, and we ignore whether\n    // the string had enough characters to handle it or not.\n    *char_len = *char_pos;\n    ForwardNUTF8CharPositions(in, len, char_len);\n    // The length in bytes is the position end of the substring less the start.\n    *char_len = *char_len - *char_pos;\n    return true;\n  }\n\n  // This function expects a negative position relative to the end of the\n  // string, but will update the character position to a positive number\n  // relative to the beginning of the string.\n  static bool UpdateNegativePosAndLenForUtf8(const StringPiece in, const T pos,\n                                             const T len, T* char_pos,\n                                             T* char_len) {\n    // Initially treat the length as position of the end of the substring.\n    *char_len = in.size();\n    // This is the number of character to skip from the end of the string to\n    // arrive at the position where the substring should end.\n    T utf8_chars_to_skip = -pos - len;\n    if (utf8_chars_to_skip < 0) {\n      utf8_chars_to_skip = 0;\n    }\n    // Find the byte position where the substring should end using the computed\n    // number of characters to skip.\n    if (!BackNUTF8CharPositions(in, utf8_chars_to_skip, char_len)) {\n      return false;\n    }\n    // Next, determine where the substring should begin. The number of chars to\n    // skip is the requested position minus the chars we've previously skipped.\n    *char_pos = *char_len;\n    if (!BackNUTF8CharPositions(in, -pos - utf8_chars_to_skip, char_pos)) {\n      return false;\n    }\n    // The length in bytes is the position end of the substring less the start.\n    *char_len = *char_len - *char_pos;\n    return true;\n  }\n\n  CharUnit unit_ = CharUnit::BYTE;\n};\n\n#define REGISTER_SUBSTR(type)                                      \\\n  REGISTER_KERNEL_BUILDER(                                         \\\n      Name(\"Substr\").Device(DEVICE_CPU).TypeConstraint<type>(\"T\"), \\\n      SubstrOp<type>);\nREGISTER_SUBSTR(int32);\nREGISTER_SUBSTR(int64);\n}  // namespace tensorflow\n", "# Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for Substr op from string_ops.\"\"\"\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom absl.testing import parameterized\nimport numpy as np\n\nfrom tensorflow.python.framework import errors_impl\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import string_ops\nfrom tensorflow.python.platform import test\n\n\nclass SubstrOpTest(test.TestCase, parameterized.TestCase):\n\n  @parameterized.parameters(\n      (np.int32, 1, \"BYTE\"),\n      (np.int64, 1, \"BYTE\"),\n      (np.int32, -4, \"BYTE\"),\n      (np.int64, -4, \"BYTE\"),\n      (np.int32, 1, \"UTF8_CHAR\"),\n      (np.int64, 1, \"UTF8_CHAR\"),\n      (np.int32, -4, \"UTF8_CHAR\"),\n      (np.int64, -4, \"UTF8_CHAR\"),\n  )\n  def testScalarString(self, dtype, pos, unit):\n    test_string = {\n        \"BYTE\": b\"Hello\",\n        \"UTF8_CHAR\": u\"He\\xc3\\xc3\\U0001f604\".encode(\"utf-8\"),\n    }[unit]\n    expected_value = {\n        \"BYTE\": b\"ell\",\n        \"UTF8_CHAR\": u\"e\\xc3\\xc3\".encode(\"utf-8\"),\n    }[unit]\n    position = np.array(pos, dtype)\n    length = np.array(3, dtype)\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      substr = self.evaluate(substr_op)\n      self.assertAllEqual(substr, expected_value)\n\n  @parameterized.parameters(\n      (np.int32, \"BYTE\"),\n      (np.int64, \"BYTE\"),\n      (np.int32, \"UTF8_CHAR\"),\n      (np.int64, \"UTF8_CHAR\"),\n  )\n  def testScalarString_EdgeCases(self, dtype, unit):\n    # Empty string\n    test_string = {\n        \"BYTE\": b\"\",\n        \"UTF8_CHAR\": u\"\".encode(\"utf-8\"),\n    }[unit]\n    expected_value = b\"\"\n    position = np.array(0, dtype)\n    length = np.array(3, dtype)\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      substr = self.evaluate(substr_op)\n      self.assertAllEqual(substr, expected_value)\n\n    # Full string\n    test_string = {\n        \"BYTE\": b\"Hello\",\n        \"UTF8_CHAR\": u\"H\\xc3ll\\U0001f604\".encode(\"utf-8\"),\n    }[unit]\n    position = np.array(0, dtype)\n    length = np.array(5, dtype)\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      substr = self.evaluate(substr_op)\n      self.assertAllEqual(substr, test_string)\n\n    # Full string (Negative)\n    test_string = {\n        \"BYTE\": b\"Hello\",\n        \"UTF8_CHAR\": u\"H\\xc3ll\\U0001f604\".encode(\"utf-8\"),\n    }[unit]\n    position = np.array(-5, dtype)\n    length = np.array(5, dtype)\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      substr = self.evaluate(substr_op)\n      self.assertAllEqual(substr, test_string)\n\n    # Length is larger in magnitude than a negative position\n    test_string = {\n        \"BYTE\": b\"Hello\",\n        \"UTF8_CHAR\": u\"H\\xc3ll\\U0001f604\".encode(\"utf-8\"),\n    }[unit]\n    expected_string = {\n        \"BYTE\": b\"ello\",\n        \"UTF8_CHAR\": u\"\\xc3ll\\U0001f604\".encode(\"utf-8\"),\n    }[unit]\n    position = np.array(-4, dtype)\n    length = np.array(5, dtype)\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      substr = self.evaluate(substr_op)\n      self.assertAllEqual(substr, expected_string)\n\n  @parameterized.parameters(\n      (np.int32, 1, \"BYTE\"),\n      (np.int64, 1, \"BYTE\"),\n      (np.int32, -4, \"BYTE\"),\n      (np.int64, -4, \"BYTE\"),\n      (np.int32, 1, \"UTF8_CHAR\"),\n      (np.int64, 1, \"UTF8_CHAR\"),\n      (np.int32, -4, \"UTF8_CHAR\"),\n      (np.int64, -4, \"UTF8_CHAR\"),\n  )\n  def testVectorStrings(self, dtype, pos, unit):\n    test_string = {\n        \"BYTE\": [b\"Hello\", b\"World\"],\n        \"UTF8_CHAR\": [x.encode(\"utf-8\") for x in [u\"H\\xc3llo\",\n                                                  u\"W\\U0001f604rld\"]],\n    }[unit]\n    expected_value = {\n        \"BYTE\": [b\"ell\", b\"orl\"],\n        \"UTF8_CHAR\": [x.encode(\"utf-8\") for x in [u\"\\xc3ll\", u\"\\U0001f604rl\"]],\n    }[unit]\n    position = np.array(pos, dtype)\n    length = np.array(3, dtype)\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      substr = self.evaluate(substr_op)\n      self.assertAllEqual(substr, expected_value)\n\n  @parameterized.parameters(\n      (np.int32, \"BYTE\"),\n      (np.int64, \"BYTE\"),\n      (np.int32, \"UTF8_CHAR\"),\n      (np.int64, \"UTF8_CHAR\"),\n  )\n  def testMatrixStrings(self, dtype, unit):\n    test_string = {\n        \"BYTE\": [[b\"ten\", b\"eleven\", b\"twelve\"],\n                 [b\"thirteen\", b\"fourteen\", b\"fifteen\"],\n                 [b\"sixteen\", b\"seventeen\", b\"eighteen\"]],\n        \"UTF8_CHAR\": [[x.encode(\"utf-8\") for x in [u\"\\U0001d229\\U0001d227n\",\n                                                   u\"\\xc6\\u053c\\u025bv\\u025bn\",\n                                                   u\"tw\\u0c1dlv\\u025b\"]],\n                      [x.encode(\"utf-8\") for x in [u\"He\\xc3\\xc3o\",\n                                                   u\"W\\U0001f604rld\",\n                                                   u\"d\\xfcd\\xea\"]]],\n    }[unit]\n    position = np.array(1, dtype)\n    length = np.array(4, dtype)\n    expected_value = {\n        \"BYTE\": [[b\"en\", b\"leve\", b\"welv\"], [b\"hirt\", b\"ourt\", b\"ifte\"],\n                 [b\"ixte\", b\"even\", b\"ight\"]],\n        \"UTF8_CHAR\": [[x.encode(\"utf-8\") for x in [u\"\\U0001d227n\",\n                                                   u\"\\u053c\\u025bv\\u025b\",\n                                                   u\"w\\u0c1dlv\"]],\n                      [x.encode(\"utf-8\") for x in [u\"e\\xc3\\xc3o\",\n                                                   u\"\\U0001f604rld\",\n                                                   u\"\\xfcd\\xea\"]]],\n    }[unit]\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      substr = self.evaluate(substr_op)\n      self.assertAllEqual(substr, expected_value)\n\n    position = np.array(-3, dtype)\n    length = np.array(2, dtype)\n    expected_value = {\n        \"BYTE\": [[b\"te\", b\"ve\", b\"lv\"], [b\"ee\", b\"ee\", b\"ee\"],\n                 [b\"ee\", b\"ee\", b\"ee\"]],\n        \"UTF8_CHAR\": [[x.encode(\"utf-8\") for x in [u\"\\U0001d229\\U0001d227\",\n                                                   u\"v\\u025b\", u\"lv\"]],\n                      [x.encode(\"utf-8\") for x in [u\"\\xc3\\xc3\", u\"rl\",\n                                                   u\"\\xfcd\"]]],\n    }[unit]\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      substr = self.evaluate(substr_op)\n      self.assertAllEqual(substr, expected_value)\n\n  @parameterized.parameters(\n      (np.int32, \"BYTE\"),\n      (np.int64, \"BYTE\"),\n      (np.int32, \"UTF8_CHAR\"),\n      (np.int64, \"UTF8_CHAR\"),\n  )\n  def testElementWisePosLen(self, dtype, unit):\n    test_string = {\n        \"BYTE\": [[b\"ten\", b\"eleven\", b\"twelve\"],\n                 [b\"thirteen\", b\"fourteen\", b\"fifteen\"],\n                 [b\"sixteen\", b\"seventeen\", b\"eighteen\"]],\n        \"UTF8_CHAR\": [[x.encode(\"utf-8\") for x in [u\"\\U0001d229\\U0001d227n\",\n                                                   u\"\\xc6\\u053c\\u025bv\\u025bn\",\n                                                   u\"tw\\u0c1dlv\\u025b\"]],\n                      [x.encode(\"utf-8\") for x in [u\"He\\xc3\\xc3o\",\n                                                   u\"W\\U0001f604rld\",\n                                                   u\"d\\xfcd\\xea\"]],\n                      [x.encode(\"utf-8\") for x in [u\"sixt\\xea\\xean\",\n                                                   u\"se\\U00010299enteen\",\n                                                   u\"ei\\U0001e920h\\x86een\"]]],\n    }[unit]\n    position = np.array([[1, -4, 3], [1, 2, -4], [-5, 2, 3]], dtype)\n    length = np.array([[2, 2, 4], [4, 3, 2], [5, 5, 5]], dtype)\n    expected_value = {\n        \"BYTE\": [[b\"en\", b\"ev\", b\"lve\"], [b\"hirt\", b\"urt\", b\"te\"],\n                 [b\"xteen\", b\"vente\", b\"hteen\"]],\n        \"UTF8_CHAR\": [[x.encode(\"utf-8\") for x in [u\"\\U0001d227n\",\n                                                   u\"\\u025bv\",\n                                                   u\"lv\\u025b\"]],\n                      [x.encode(\"utf-8\") for x in [u\"e\\xc3\\xc3o\",\n                                                   u\"rld\",\n                                                   u\"d\\xfc\"]],\n                      [x.encode(\"utf-8\") for x in [u\"xt\\xea\\xean\",\n                                                   u\"\\U00010299ente\",\n                                                   u\"h\\x86een\"]]],\n    }[unit]\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      substr = self.evaluate(substr_op)\n      self.assertAllEqual(substr, expected_value)\n\n  @parameterized.parameters(\n      (np.int32, \"BYTE\"),\n      (np.int64, \"BYTE\"),\n      (np.int32, \"UTF8_CHAR\"),\n      (np.int64, \"UTF8_CHAR\"),\n  )\n  def testBroadcast(self, dtype, unit):\n    # Broadcast pos/len onto input string\n    test_string = {\n        \"BYTE\": [[b\"ten\", b\"eleven\", b\"twelve\"],\n                 [b\"thirteen\", b\"fourteen\", b\"fifteen\"],\n                 [b\"sixteen\", b\"seventeen\", b\"eighteen\"],\n                 [b\"nineteen\", b\"twenty\", b\"twentyone\"]],\n        \"UTF8_CHAR\": [[x.encode(\"utf-8\") for x in [u\"\\U0001d229\\U0001d227n\",\n                                                   u\"\\xc6\\u053c\\u025bv\\u025bn\",\n                                                   u\"tw\\u0c1dlv\\u025b\"]],\n                      [x.encode(\"utf-8\") for x in [u\"th\\xcdrt\\xea\\xean\",\n                                                   u\"f\\U0001f604urt\\xea\\xean\",\n                                                   u\"f\\xcd\\ua09ctee\\ua0e4\"]],\n                      [x.encode(\"utf-8\") for x in [u\"s\\xcdxt\\xea\\xean\",\n                                                   u\"se\\U00010299enteen\",\n                                                   u\"ei\\U0001e920h\\x86een\"]],\n                      [x.encode(\"utf-8\") for x in [u\"nineteen\",\n                                                   u\"twenty\",\n                                                   u\"twentyone\"]]],\n    }[unit]\n    position = np.array([1, -4, 3], dtype)\n    length = np.array([1, 2, 3], dtype)\n    expected_value = {\n        \"BYTE\": [[b\"e\", b\"ev\", b\"lve\"], [b\"h\", b\"te\", b\"tee\"],\n                 [b\"i\", b\"te\", b\"hte\"], [b\"i\", b\"en\", b\"nty\"]],\n        \"UTF8_CHAR\": [[x.encode(\"utf-8\") for x in [u\"\\U0001d227\",\n                                                   u\"\\u025bv\", u\"lv\\u025b\"]],\n                      [x.encode(\"utf-8\") for x in [u\"h\", u\"t\\xea\", u\"tee\"]],\n                      [x.encode(\"utf-8\") for x in [u\"\\xcd\", u\"te\", u\"h\\x86e\"]],\n                      [x.encode(\"utf-8\") for x in [u\"i\", u\"en\", u\"nty\"]]],\n    }[unit]\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      substr = self.evaluate(substr_op)\n      self.assertAllEqual(substr, expected_value)\n\n    # Broadcast input string onto pos/len\n    test_string = {\n        \"BYTE\": [b\"thirteen\", b\"fourteen\", b\"fifteen\"],\n        \"UTF8_CHAR\": [x.encode(\"utf-8\") for x in [u\"th\\xcdrt\\xea\\xean\",\n                                                  u\"f\\U0001f604urt\\xea\\xean\",\n                                                  u\"f\\xcd\\ua09ctee\\ua0e4\"]],\n    }[unit]\n    position = np.array([[1, -2, 3], [-3, 2, 1], [5, 5, -5]], dtype)\n    length = np.array([[3, 2, 1], [1, 2, 3], [2, 2, 2]], dtype)\n    expected_value = {\n        \"BYTE\": [[b\"hir\", b\"en\", b\"t\"], [b\"e\", b\"ur\", b\"ift\"],\n                 [b\"ee\", b\"ee\", b\"ft\"]],\n        \"UTF8_CHAR\": [[x.encode(\"utf-8\") for x in [u\"h\\xcdr\", u\"\\xean\", u\"t\"]],\n                      [x.encode(\"utf-8\") for x in [u\"\\xea\", u\"ur\",\n                                                   u\"\\xcd\\ua09ct\"]],\n                      [x.encode(\"utf-8\") for x in [u\"\\xea\\xea\", u\"\\xea\\xea\",\n                                                   u\"\\ua09ct\"]]],\n    }[unit]\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      substr = self.evaluate(substr_op)\n      self.assertAllEqual(substr, expected_value)\n\n    # Test 1D broadcast\n    test_string = {\n        \"BYTE\": b\"thirteen\",\n        \"UTF8_CHAR\": u\"th\\xcdrt\\xea\\xean\".encode(\"utf-8\"),\n    }[unit]\n    position = np.array([1, -4, 7], dtype)\n    length = np.array([3, 2, 1], dtype)\n    expected_value = {\n        \"BYTE\": [b\"hir\", b\"te\", b\"n\"],\n        \"UTF8_CHAR\": [x.encode(\"utf-8\") for x in [u\"h\\xcdr\", u\"t\\xea\", u\"n\"]],\n    }[unit]\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      substr = self.evaluate(substr_op)\n      self.assertAllEqual(substr, expected_value)\n\n  @parameterized.parameters(\n      (np.int32, \"BYTE\"),\n      (np.int64, \"BYTE\"),\n      (np.int32, \"UTF8_CHAR\"),\n      (np.int64, \"UTF8_CHAR\"),\n  )\n  @test_util.run_deprecated_v1\n  def testBadBroadcast(self, dtype, unit):\n    test_string = [[b\"ten\", b\"eleven\", b\"twelve\"],\n                   [b\"thirteen\", b\"fourteen\", b\"fifteen\"],\n                   [b\"sixteen\", b\"seventeen\", b\"eighteen\"]]\n    position = np.array([1, 2, -3, 4], dtype)\n    length = np.array([1, 2, 3, 4], dtype)\n    with self.assertRaises(ValueError):\n      string_ops.substr(test_string, position, length, unit=unit)\n\n  @parameterized.parameters(\n      (np.int32, 6, \"BYTE\"),\n      (np.int64, 6, \"BYTE\"),\n      (np.int32, -6, \"BYTE\"),\n      (np.int64, -6, \"BYTE\"),\n      (np.int32, 6, \"UTF8_CHAR\"),\n      (np.int64, 6, \"UTF8_CHAR\"),\n      (np.int32, -6, \"UTF8_CHAR\"),\n      (np.int64, -6, \"UTF8_CHAR\"),\n  )\n  @test_util.run_deprecated_v1\n  def testOutOfRangeError_Scalar(self, dtype, pos, unit):\n    # Scalar/Scalar\n    test_string = {\n        \"BYTE\": b\"Hello\",\n        \"UTF8_CHAR\": u\"H\\xc3ll\\U0001f604\".encode(\"utf-8\"),\n    }[unit]\n    position = np.array(pos, dtype)\n    length = np.array(3, dtype)\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      with self.assertRaises(errors_impl.InvalidArgumentError):\n        self.evaluate(substr_op)\n\n  @parameterized.parameters(\n      (np.int32, 4, \"BYTE\"),\n      (np.int64, 4, \"BYTE\"),\n      (np.int32, -4, \"BYTE\"),\n      (np.int64, -4, \"BYTE\"),\n      (np.int32, 4, \"UTF8_CHAR\"),\n      (np.int64, 4, \"UTF8_CHAR\"),\n      (np.int32, -4, \"UTF8_CHAR\"),\n      (np.int64, -4, \"UTF8_CHAR\"),\n  )\n  @test_util.run_deprecated_v1\n  def testOutOfRangeError_VectorScalar(self, dtype, pos, unit):\n    # Vector/Scalar\n    test_string = {\n        \"BYTE\": [b\"good\", b\"good\", b\"bad\", b\"good\"],\n        \"UTF8_CHAR\": [x.encode(\"utf-8\") for x in [u\"g\\xc3\\xc3d\", u\"b\\xc3d\",\n                                                  u\"g\\xc3\\xc3d\"]],\n    }[unit]\n    position = np.array(pos, dtype)\n    length = np.array(1, dtype)\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      with self.assertRaises(errors_impl.InvalidArgumentError):\n        self.evaluate(substr_op)\n\n  @parameterized.parameters(\n      (np.int32, \"BYTE\"),\n      (np.int64, \"BYTE\"),\n      (np.int32, \"UTF8_CHAR\"),\n      (np.int64, \"UTF8_CHAR\"),\n  )\n  @test_util.run_deprecated_v1\n  def testOutOfRangeError_MatrixMatrix(self, dtype, unit):\n    # Matrix/Matrix\n    test_string = {\n        \"BYTE\": [[b\"good\", b\"good\", b\"good\"], [b\"good\", b\"good\", b\"bad\"],\n                 [b\"good\", b\"good\", b\"good\"]],\n        \"UTF8_CHAR\": [[x.encode(\"utf-8\") for x in [u\"g\\xc3\\xc3d\", u\"g\\xc3\\xc3d\",\n                                                   u\"g\\xc3\\xc3d\"]],\n                      [x.encode(\"utf-8\") for x in [u\"g\\xc3\\xc3d\", u\"g\\xc3\\xc3d\",\n                                                   u\"b\\xc3d\"]],\n                      [x.encode(\"utf-8\") for x in [u\"g\\xc3\\xc3d\", u\"g\\xc3\\xc3d\",\n                                                   u\"g\\xc3\\xc3d\"]]],\n    }[unit]\n    position = np.array([[1, 2, 3], [1, 2, 4], [1, 2, 3]], dtype)\n    length = np.array([[3, 2, 1], [1, 2, 3], [2, 2, 2]], dtype)\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      with self.assertRaises(errors_impl.InvalidArgumentError):\n        self.evaluate(substr_op)\n\n    # Matrix/Matrix (with negative)\n    position = np.array([[1, 2, -3], [1, 2, -4], [1, 2, -3]], dtype)\n    length = np.array([[3, 2, 1], [1, 2, 3], [2, 2, 2]], dtype)\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      with self.assertRaises(errors_impl.InvalidArgumentError):\n        self.evaluate(substr_op)\n\n  @parameterized.parameters(\n      (np.int32, \"BYTE\"),\n      (np.int64, \"BYTE\"),\n      (np.int32, \"UTF8_CHAR\"),\n      (np.int64, \"UTF8_CHAR\"),\n  )\n  @test_util.run_deprecated_v1\n  def testOutOfRangeError_Broadcast(self, dtype, unit):\n    # Broadcast\n    test_string = {\n        \"BYTE\": [[b\"good\", b\"good\", b\"good\"], [b\"good\", b\"good\", b\"bad\"]],\n        \"UTF8_CHAR\": [[x.encode(\"utf-8\") for x in [u\"g\\xc3\\xc3d\", u\"g\\xc3\\xc3d\",\n                                                   u\"g\\xc3\\xc3d\"]],\n                      [x.encode(\"utf-8\") for x in [u\"g\\xc3\\xc3d\", u\"g\\xc3\\xc3d\",\n                                                   u\"b\\xc3d\"]]],\n    }[unit]\n    position = np.array([1, 2, 4], dtype)\n    length = np.array([1, 2, 3], dtype)\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      with self.assertRaises(errors_impl.InvalidArgumentError):\n        self.evaluate(substr_op)\n\n    # Broadcast (with negative)\n    position = np.array([-1, -2, -4], dtype)\n    length = np.array([1, 2, 3], dtype)\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      with self.assertRaises(errors_impl.InvalidArgumentError):\n        self.evaluate(substr_op)\n\n  @parameterized.parameters(\n      (np.int32, \"BYTE\"),\n      (np.int64, \"BYTE\"),\n      (np.int32, \"UTF8_CHAR\"),\n      (np.int64, \"UTF8_CHAR\"),\n  )\n  @test_util.run_deprecated_v1\n  def testMismatchPosLenShapes(self, dtype, unit):\n    test_string = {\n        \"BYTE\": [[b\"ten\", b\"eleven\", b\"twelve\"],\n                 [b\"thirteen\", b\"fourteen\", b\"fifteen\"],\n                 [b\"sixteen\", b\"seventeen\", b\"eighteen\"]],\n        \"UTF8_CHAR\": [[x.encode(\"utf-8\") for x in [u\"\\U0001d229\\U0001d227n\",\n                                                   u\"\\xc6\\u053c\\u025bv\\u025bn\",\n                                                   u\"tw\\u0c1dlv\\u025b\"]],\n                      [x.encode(\"utf-8\") for x in [u\"th\\xcdrt\\xea\\xean\",\n                                                   u\"f\\U0001f604urt\\xea\\xean\",\n                                                   u\"f\\xcd\\ua09ctee\\ua0e4\"]],\n                      [x.encode(\"utf-8\") for x in [u\"s\\xcdxt\\xea\\xean\",\n                                                   u\"se\\U00010299enteen\",\n                                                   u\"ei\\U0001e920h\\x86een\"]]],\n    }[unit]\n    position = np.array([[1, 2, 3]], dtype)\n    length = np.array([2, 3, 4], dtype)\n    # Should fail: position/length have different rank\n    with self.assertRaises(ValueError):\n      string_ops.substr(test_string, position, length)\n\n    position = np.array([[1, 2, 3], [1, 2, 3], [1, 2, 3]], dtype)\n    length = np.array([[2, 3, 4]], dtype)\n    # Should fail: position/length have different dimensionality\n    with self.assertRaises(ValueError):\n      string_ops.substr(test_string, position, length)\n\n  @test_util.run_deprecated_v1\n  def testWrongDtype(self):\n    with self.cached_session():\n      with self.assertRaises(TypeError):\n        string_ops.substr(b\"test\", 3.0, 1)\n      with self.assertRaises(TypeError):\n        string_ops.substr(b\"test\", 3, 1.0)\n\n  @test_util.run_deprecated_v1\n  def testInvalidUnit(self):\n    with self.cached_session():\n      with self.assertRaises(ValueError):\n        string_ops.substr(b\"test\", 3, 1, unit=\"UTF8\")\n\n\nif __name__ == \"__main__\":\n  test.main()\n"], "fixing_code": ["/* Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n==============================================================================*/\n\n#include <cstddef>\n#include <cstdlib>\n#include <string>\n\n#include \"third_party/eigen3/unsupported/Eigen/CXX11/Tensor\"\n#include \"tensorflow/core/framework/bounds_check.h\"\n#include \"tensorflow/core/framework/kernel_def_builder.h\"\n#include \"tensorflow/core/framework/op.h\"\n#include \"tensorflow/core/framework/op_kernel.h\"\n#include \"tensorflow/core/framework/tensor.h\"\n#include \"tensorflow/core/framework/tensor_shape.h\"\n#include \"tensorflow/core/framework/tensor_types.h\"\n#include \"tensorflow/core/framework/types.h\"\n#include \"tensorflow/core/kernels/string_util.h\"\n#include \"tensorflow/core/lib/core/errors.h\"\n#include \"tensorflow/core/lib/core/stringpiece.h\"\n#include \"tensorflow/core/platform/types.h\"\n#include \"tensorflow/core/util/bcast.h\"\n\nnamespace tensorflow {\n\n// Position/length can be 32 or 64-bit integers\ntemplate <typename T>\nclass SubstrOp : public OpKernel {\n public:\n  explicit SubstrOp(OpKernelConstruction* ctx) : OpKernel(ctx) {\n    string unit;\n    OP_REQUIRES_OK(ctx, ctx->GetAttr(\"unit\", &unit));\n    OP_REQUIRES_OK(ctx, ParseCharUnit(unit, &unit_));\n  }\n\n  void Compute(OpKernelContext* context) override {\n    // Get inputs\n    const Tensor& input_tensor = context->input(0);\n    const Tensor& pos_tensor = context->input(1);\n    const Tensor& len_tensor = context->input(2);\n    const TensorShape& input_shape = input_tensor.shape();\n    const TensorShape& pos_shape = pos_tensor.shape();\n    const TensorShape& len_shape = len_tensor.shape();\n    OP_REQUIRES(context, (pos_shape == len_shape),\n                errors::InvalidArgument(\n                    \"pos and len should have the same shape, got: \",\n                    pos_shape.DebugString(), \" vs. \", len_shape.DebugString()));\n\n    bool is_scalar = TensorShapeUtils::IsScalar(pos_shape);\n\n    if (is_scalar || input_shape == pos_shape) {\n      // pos/len are either scalar or match the shape of input_tensor\n      // Do not need to do broadcasting\n\n      // Reshape input\n      auto input = input_tensor.flat<tstring>();\n      // Allocate output\n      Tensor* output_tensor = nullptr;\n      OP_REQUIRES_OK(context,\n                     context->allocate_output(\"output\", input_tensor.shape(),\n                                              &output_tensor));\n      auto output = output_tensor->flat<tstring>();\n      if (is_scalar) {\n        // Perform Op with scalar pos/len\n        const T pos =\n            tensorflow::internal::SubtleMustCopy(pos_tensor.scalar<T>()());\n        const T len =\n            tensorflow::internal::SubtleMustCopy(len_tensor.scalar<T>()());\n        for (size_t i = 0; i < input_tensor.NumElements(); ++i) {\n          StringPiece in(input(i));\n          T byte_pos = pos;\n          T byte_len = len;\n          switch (unit_) {\n            case CharUnit::UTF8_CHAR:\n              OP_REQUIRES(\n                  context, UpdatePosAndLenForUtf8(in, &byte_pos, &byte_len),\n                  errors::InvalidArgument(\"pos \", pos, \" out of range for \",\n                                          \"string at index \", i));\n              break;\n            case CharUnit::BYTE:\n              byte_pos = AdjustedPosIndex(byte_pos, in);\n              OP_REQUIRES(\n                  context, FastBoundsCheck(byte_pos, in.size() + 1),\n                  errors::InvalidArgument(\"pos \", pos, \" out of range for \",\n                                          \"string b'\", in, \"' at index \", i));\n          }\n          StringPiece sub_in = in.substr(byte_pos, byte_len);\n          output(i).assign(sub_in.data(), sub_in.size());\n        }\n      } else {\n        // Perform Op element-wise with tensor pos/len\n        auto pos_flat = pos_tensor.flat<T>();\n        auto len_flat = len_tensor.flat<T>();\n        for (size_t i = 0; i < input_tensor.NumElements(); ++i) {\n          StringPiece in(input(i));\n          const T pos = tensorflow::internal::SubtleMustCopy(pos_flat(i));\n          const T len = tensorflow::internal::SubtleMustCopy(len_flat(i));\n          T byte_pos = pos;\n          T byte_len = len;\n          switch (unit_) {\n            case CharUnit::UTF8_CHAR:\n              OP_REQUIRES(\n                  context, UpdatePosAndLenForUtf8(in, &byte_pos, &byte_len),\n                  errors::InvalidArgument(\"pos \", pos, \" out of range for \",\n                                          \"string at index \", i));\n              break;\n            case CharUnit::BYTE:\n              byte_pos = AdjustedPosIndex(byte_pos, in);\n              OP_REQUIRES(\n                  context, FastBoundsCheck(byte_pos, in.size() + 1),\n                  errors::InvalidArgument(\"pos \", pos, \" out of range for \",\n                                          \"string b'\", in, \"' at index \", i));\n          }\n          StringPiece sub_in = in.substr(byte_pos, byte_len);\n          output(i).assign(sub_in.data(), sub_in.size());\n        }\n      }\n    } else {\n      // Perform op with broadcasting\n      // TODO: Use ternary broadcasting for once available in Eigen. Current\n      //       implementation iterates through broadcasted ops element-wise;\n      //       this should be parallelized.\n\n      // Create BCast helper with shape of input and pos/len\n      BCast bcast(BCast::FromShape(input_shape), BCast::FromShape(pos_shape));\n      OP_REQUIRES(context, bcast.IsValid(),\n                  errors::InvalidArgument(\n                      \"Incompatible shapes: \", input_shape.DebugString(),\n                      \" vs. \", pos_shape.DebugString()));\n      TensorShape output_shape = BCast::ToShape(bcast.result_shape());\n      int ndims = output_shape.dims();\n      Tensor* output_tensor = nullptr;\n      OP_REQUIRES_OK(context, context->allocate_output(\"output\", output_shape,\n                                                       &output_tensor));\n      switch (ndims) {\n        case 1: {\n          // Reshape tensors according to BCast results\n          auto input = input_tensor.shaped<tstring, 1>(bcast.x_reshape());\n          auto output = output_tensor->shaped<tstring, 1>(bcast.result_shape());\n          auto pos_shaped = pos_tensor.shaped<T, 1>(bcast.y_reshape());\n          auto len_shaped = len_tensor.shaped<T, 1>(bcast.y_reshape());\n\n          // Allocate temporary buffer for broadcasted input tensor\n          Tensor input_buffer;\n          OP_REQUIRES_OK(context, context->allocate_temp(\n                                      DT_STRING, output_shape, &input_buffer));\n          TTypes<tstring, 1>::Tensor input_bcast =\n              input_buffer.shaped<tstring, 1>(bcast.result_shape());\n          input_bcast =\n              input.broadcast(BCast::ToIndexArray<1>(bcast.x_bcast()));\n\n          // Allocate temporary buffer for broadcasted position tensor\n          Tensor pos_buffer;\n          OP_REQUIRES_OK(context,\n                         context->allocate_temp(DataTypeToEnum<T>::v(),\n                                                output_shape, &pos_buffer));\n          typename TTypes<T, 1>::Tensor pos_bcast(\n              pos_buffer.shaped<T, 1>(bcast.result_shape()));\n          pos_bcast =\n              pos_shaped.broadcast(BCast::ToIndexArray<1>(bcast.y_bcast()));\n\n          // Allocate temporary buffer for broadcasted length tensor\n          Tensor len_buffer;\n          OP_REQUIRES_OK(context,\n                         context->allocate_temp(DataTypeToEnum<T>::v(),\n                                                output_shape, &len_buffer));\n          typename TTypes<T, 1>::Tensor len_bcast(\n              len_buffer.shaped<T, 1>(bcast.result_shape()));\n          len_bcast =\n              len_shaped.broadcast(BCast::ToIndexArray<1>(bcast.y_bcast()));\n\n          // Iterate through broadcasted tensors and perform substr\n          for (int i = 0; i < output_shape.dim_size(0); ++i) {\n            StringPiece in(input_bcast(i));\n            const T pos = tensorflow::internal::SubtleMustCopy(pos_bcast(i));\n            const T len = tensorflow::internal::SubtleMustCopy(len_bcast(i));\n            T byte_pos = pos;\n            T byte_len = len;\n            switch (unit_) {\n              case CharUnit::UTF8_CHAR:\n                OP_REQUIRES(\n                    context, UpdatePosAndLenForUtf8(in, &byte_pos, &byte_len),\n                    errors::InvalidArgument(\"pos \", pos, \" out of range for \",\n                                            \"string at index \", i));\n                break;\n              case CharUnit::BYTE:\n                byte_pos = AdjustedPosIndex(byte_pos, in);\n                OP_REQUIRES(\n                    context,\n                    FastBoundsCheck(byte_pos, input_bcast(i).size() + 1),\n                    errors::InvalidArgument(\"pos \", pos, \" out of range for \",\n                                            \"string b'\", in, \"' at index \", i));\n            }\n            StringPiece sub_in = in.substr(byte_pos, byte_len);\n            output(i).assign(sub_in.data(), sub_in.size());\n          }\n          break;\n        }\n        case 2: {\n          // Reshape tensors according to BCast results\n          auto input = input_tensor.shaped<tstring, 2>(bcast.x_reshape());\n          auto output = output_tensor->shaped<tstring, 2>(bcast.result_shape());\n          auto pos_shaped = pos_tensor.shaped<T, 2>(bcast.y_reshape());\n          auto len_shaped = len_tensor.shaped<T, 2>(bcast.y_reshape());\n\n          // Allocate temporary buffer for broadcasted input tensor\n          Tensor input_buffer;\n          OP_REQUIRES_OK(context, context->allocate_temp(\n                                      DT_STRING, output_shape, &input_buffer));\n          TTypes<tstring, 2>::Tensor input_bcast =\n              input_buffer.shaped<tstring, 2>(bcast.result_shape());\n          input_bcast =\n              input.broadcast(BCast::ToIndexArray<2>(bcast.x_bcast()));\n\n          // Allocate temporary buffer for broadcasted position tensor\n          Tensor pos_buffer;\n          OP_REQUIRES_OK(context,\n                         context->allocate_temp(DataTypeToEnum<T>::v(),\n                                                output_shape, &pos_buffer));\n          typename TTypes<T, 2>::Tensor pos_bcast(\n              pos_buffer.shaped<T, 2>(bcast.result_shape()));\n          pos_bcast =\n              pos_shaped.broadcast(BCast::ToIndexArray<2>(bcast.y_bcast()));\n\n          // Allocate temporary buffer for broadcasted length tensor\n          Tensor len_buffer;\n          OP_REQUIRES_OK(context,\n                         context->allocate_temp(DataTypeToEnum<T>::v(),\n                                                output_shape, &len_buffer));\n          typename TTypes<T, 2>::Tensor len_bcast(\n              len_buffer.shaped<T, 2>(bcast.result_shape()));\n          len_bcast =\n              len_shaped.broadcast(BCast::ToIndexArray<2>(bcast.y_bcast()));\n\n          // Iterate through broadcasted tensors and perform substr\n          for (int i = 0; i < output_shape.dim_size(0); ++i) {\n            for (int j = 0; j < output_shape.dim_size(1); ++j) {\n              StringPiece in(input_bcast(i, j));\n              const T pos =\n                  tensorflow::internal::SubtleMustCopy(pos_bcast(i, j));\n              const T len =\n                  tensorflow::internal::SubtleMustCopy(len_bcast(i, j));\n              T byte_pos = pos;\n              T byte_len = len;\n              switch (unit_) {\n                case CharUnit::UTF8_CHAR:\n                  OP_REQUIRES(\n                      context, UpdatePosAndLenForUtf8(in, &byte_pos, &byte_len),\n                      errors::InvalidArgument(\"pos \", pos, \" out of range for \",\n                                              \"string at index \", i));\n                  break;\n                case CharUnit::BYTE:\n                  byte_pos = AdjustedPosIndex(byte_pos, in);\n                  OP_REQUIRES(\n                      context, FastBoundsCheck(byte_pos, in.size() + 1),\n                      errors::InvalidArgument(\"pos \", pos, \" out of range for \",\n                                              \"string b'\", in, \"' at index (\",\n                                              i, \", \", j, \")\"));\n              }\n              StringPiece sub_in = in.substr(byte_pos, byte_len);\n              output(i, j).assign(sub_in.data(), sub_in.size());\n            }\n          }\n          break;\n        }\n        default: {\n          context->SetStatus(errors::Unimplemented(\n              \"Substr broadcast not implemented for \", ndims, \" dimensions\"));\n        }\n      }\n    }\n  }\n\n private:\n  // This adjusts the requested position. Note it does not perform any bound\n  // checks.\n  static inline T AdjustedPosIndex(const T pos_requested, const StringPiece s) {\n    if (pos_requested < 0) {\n      return s.size() + pos_requested;\n    }\n    return pos_requested;\n  }\n\n  // Return true if successful; otherwise, return false if the `pos` argument\n  // is out of range in the string.\n  static inline bool UpdatePosAndLenForUtf8(const StringPiece in, T* pos,\n                                            T* len) {\n    if (*pos >= 0) {\n      return UpdatePositivePosAndLenForUtf8(in, *pos, *len, pos, len);\n    } else {\n      return UpdateNegativePosAndLenForUtf8(in, *pos, *len, pos, len);\n    }\n  }\n\n  static bool UpdatePositivePosAndLenForUtf8(const StringPiece in, const T pos,\n                                             const T len, T* char_pos,\n                                             T* char_len) {\n    *char_pos = 0;\n    // Determine byte position of the substring start.\n    if (!ForwardNUTF8CharPositions(in, pos, char_pos)) {\n      return false;\n    }\n    // Determine position of the end of the substring.\n    // The length will be capped at the end of the string, and we ignore whether\n    // the string had enough characters to handle it or not.\n    *char_len = *char_pos;\n    ForwardNUTF8CharPositions(in, len, char_len);\n    // The length in bytes is the position end of the substring less the start.\n    *char_len = *char_len - *char_pos;\n    return true;\n  }\n\n  // This function expects a negative position relative to the end of the\n  // string, but will update the character position to a positive number\n  // relative to the beginning of the string.\n  static bool UpdateNegativePosAndLenForUtf8(const StringPiece in, const T pos,\n                                             const T len, T* char_pos,\n                                             T* char_len) {\n    // Initially treat the length as position of the end of the substring.\n    *char_len = in.size();\n    // This is the number of character to skip from the end of the string to\n    // arrive at the position where the substring should end.\n    T utf8_chars_to_skip = -pos - len;\n    if (utf8_chars_to_skip < 0) {\n      utf8_chars_to_skip = 0;\n    }\n    // Find the byte position where the substring should end using the computed\n    // number of characters to skip.\n    if (!BackNUTF8CharPositions(in, utf8_chars_to_skip, char_len)) {\n      return false;\n    }\n    // Next, determine where the substring should begin. The number of chars to\n    // skip is the requested position minus the chars we've previously skipped.\n    *char_pos = *char_len;\n    if (!BackNUTF8CharPositions(in, -pos - utf8_chars_to_skip, char_pos)) {\n      return false;\n    }\n    // The length in bytes is the position end of the substring less the start.\n    *char_len = *char_len - *char_pos;\n    return true;\n  }\n\n  CharUnit unit_ = CharUnit::BYTE;\n};\n\n#define REGISTER_SUBSTR(type)                                      \\\n  REGISTER_KERNEL_BUILDER(                                         \\\n      Name(\"Substr\").Device(DEVICE_CPU).TypeConstraint<type>(\"T\"), \\\n      SubstrOp<type>);\nREGISTER_SUBSTR(int32);\nREGISTER_SUBSTR(int64);\n}  // namespace tensorflow\n", "# Copyright 2016 The TensorFlow Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n# ==============================================================================\n\"\"\"Tests for Substr op from string_ops.\"\"\"\n\nfrom __future__ import absolute_import\nfrom __future__ import division\nfrom __future__ import print_function\n\nfrom absl.testing import parameterized\nimport numpy as np\n\nfrom tensorflow.python.framework import errors_impl\nfrom tensorflow.python.framework import test_util\nfrom tensorflow.python.ops import string_ops\nfrom tensorflow.python.platform import test\n\n\nclass SubstrOpTest(test.TestCase, parameterized.TestCase):\n\n  @parameterized.parameters(\n      (np.int32, 1, \"BYTE\"),\n      (np.int64, 1, \"BYTE\"),\n      (np.int32, -4, \"BYTE\"),\n      (np.int64, -4, \"BYTE\"),\n      (np.int32, 1, \"UTF8_CHAR\"),\n      (np.int64, 1, \"UTF8_CHAR\"),\n      (np.int32, -4, \"UTF8_CHAR\"),\n      (np.int64, -4, \"UTF8_CHAR\"),\n  )\n  def testScalarString(self, dtype, pos, unit):\n    test_string = {\n        \"BYTE\": b\"Hello\",\n        \"UTF8_CHAR\": u\"He\\xc3\\xc3\\U0001f604\".encode(\"utf-8\"),\n    }[unit]\n    expected_value = {\n        \"BYTE\": b\"ell\",\n        \"UTF8_CHAR\": u\"e\\xc3\\xc3\".encode(\"utf-8\"),\n    }[unit]\n    position = np.array(pos, dtype)\n    length = np.array(3, dtype)\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      substr = self.evaluate(substr_op)\n      self.assertAllEqual(substr, expected_value)\n\n  @parameterized.parameters(\n      (np.int32, \"BYTE\"),\n      (np.int64, \"BYTE\"),\n      (np.int32, \"UTF8_CHAR\"),\n      (np.int64, \"UTF8_CHAR\"),\n  )\n  def testScalarString_EdgeCases(self, dtype, unit):\n    # Empty string\n    test_string = {\n        \"BYTE\": b\"\",\n        \"UTF8_CHAR\": u\"\".encode(\"utf-8\"),\n    }[unit]\n    expected_value = b\"\"\n    position = np.array(0, dtype)\n    length = np.array(3, dtype)\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      substr = self.evaluate(substr_op)\n      self.assertAllEqual(substr, expected_value)\n\n    # Full string\n    test_string = {\n        \"BYTE\": b\"Hello\",\n        \"UTF8_CHAR\": u\"H\\xc3ll\\U0001f604\".encode(\"utf-8\"),\n    }[unit]\n    position = np.array(0, dtype)\n    length = np.array(5, dtype)\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      substr = self.evaluate(substr_op)\n      self.assertAllEqual(substr, test_string)\n\n    # Full string (Negative)\n    test_string = {\n        \"BYTE\": b\"Hello\",\n        \"UTF8_CHAR\": u\"H\\xc3ll\\U0001f604\".encode(\"utf-8\"),\n    }[unit]\n    position = np.array(-5, dtype)\n    length = np.array(5, dtype)\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      substr = self.evaluate(substr_op)\n      self.assertAllEqual(substr, test_string)\n\n    # Length is larger in magnitude than a negative position\n    test_string = {\n        \"BYTE\": b\"Hello\",\n        \"UTF8_CHAR\": u\"H\\xc3ll\\U0001f604\".encode(\"utf-8\"),\n    }[unit]\n    expected_string = {\n        \"BYTE\": b\"ello\",\n        \"UTF8_CHAR\": u\"\\xc3ll\\U0001f604\".encode(\"utf-8\"),\n    }[unit]\n    position = np.array(-4, dtype)\n    length = np.array(5, dtype)\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      substr = self.evaluate(substr_op)\n      self.assertAllEqual(substr, expected_string)\n\n  @parameterized.parameters(\n      (np.int32, 1, \"BYTE\"),\n      (np.int64, 1, \"BYTE\"),\n      (np.int32, -4, \"BYTE\"),\n      (np.int64, -4, \"BYTE\"),\n      (np.int32, 1, \"UTF8_CHAR\"),\n      (np.int64, 1, \"UTF8_CHAR\"),\n      (np.int32, -4, \"UTF8_CHAR\"),\n      (np.int64, -4, \"UTF8_CHAR\"),\n  )\n  def testVectorStrings(self, dtype, pos, unit):\n    test_string = {\n        \"BYTE\": [b\"Hello\", b\"World\"],\n        \"UTF8_CHAR\": [x.encode(\"utf-8\") for x in [u\"H\\xc3llo\",\n                                                  u\"W\\U0001f604rld\"]],\n    }[unit]\n    expected_value = {\n        \"BYTE\": [b\"ell\", b\"orl\"],\n        \"UTF8_CHAR\": [x.encode(\"utf-8\") for x in [u\"\\xc3ll\", u\"\\U0001f604rl\"]],\n    }[unit]\n    position = np.array(pos, dtype)\n    length = np.array(3, dtype)\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      substr = self.evaluate(substr_op)\n      self.assertAllEqual(substr, expected_value)\n\n  @parameterized.parameters(\n      (np.int32, \"BYTE\"),\n      (np.int64, \"BYTE\"),\n      (np.int32, \"UTF8_CHAR\"),\n      (np.int64, \"UTF8_CHAR\"),\n  )\n  def testMatrixStrings(self, dtype, unit):\n    test_string = {\n        \"BYTE\": [[b\"ten\", b\"eleven\", b\"twelve\"],\n                 [b\"thirteen\", b\"fourteen\", b\"fifteen\"],\n                 [b\"sixteen\", b\"seventeen\", b\"eighteen\"]],\n        \"UTF8_CHAR\": [[x.encode(\"utf-8\") for x in [u\"\\U0001d229\\U0001d227n\",\n                                                   u\"\\xc6\\u053c\\u025bv\\u025bn\",\n                                                   u\"tw\\u0c1dlv\\u025b\"]],\n                      [x.encode(\"utf-8\") for x in [u\"He\\xc3\\xc3o\",\n                                                   u\"W\\U0001f604rld\",\n                                                   u\"d\\xfcd\\xea\"]]],\n    }[unit]\n    position = np.array(1, dtype)\n    length = np.array(4, dtype)\n    expected_value = {\n        \"BYTE\": [[b\"en\", b\"leve\", b\"welv\"], [b\"hirt\", b\"ourt\", b\"ifte\"],\n                 [b\"ixte\", b\"even\", b\"ight\"]],\n        \"UTF8_CHAR\": [[x.encode(\"utf-8\") for x in [u\"\\U0001d227n\",\n                                                   u\"\\u053c\\u025bv\\u025b\",\n                                                   u\"w\\u0c1dlv\"]],\n                      [x.encode(\"utf-8\") for x in [u\"e\\xc3\\xc3o\",\n                                                   u\"\\U0001f604rld\",\n                                                   u\"\\xfcd\\xea\"]]],\n    }[unit]\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      substr = self.evaluate(substr_op)\n      self.assertAllEqual(substr, expected_value)\n\n    position = np.array(-3, dtype)\n    length = np.array(2, dtype)\n    expected_value = {\n        \"BYTE\": [[b\"te\", b\"ve\", b\"lv\"], [b\"ee\", b\"ee\", b\"ee\"],\n                 [b\"ee\", b\"ee\", b\"ee\"]],\n        \"UTF8_CHAR\": [[x.encode(\"utf-8\") for x in [u\"\\U0001d229\\U0001d227\",\n                                                   u\"v\\u025b\", u\"lv\"]],\n                      [x.encode(\"utf-8\") for x in [u\"\\xc3\\xc3\", u\"rl\",\n                                                   u\"\\xfcd\"]]],\n    }[unit]\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      substr = self.evaluate(substr_op)\n      self.assertAllEqual(substr, expected_value)\n\n  @parameterized.parameters(\n      (np.int32, \"BYTE\"),\n      (np.int64, \"BYTE\"),\n      (np.int32, \"UTF8_CHAR\"),\n      (np.int64, \"UTF8_CHAR\"),\n  )\n  def testElementWisePosLen(self, dtype, unit):\n    test_string = {\n        \"BYTE\": [[b\"ten\", b\"eleven\", b\"twelve\"],\n                 [b\"thirteen\", b\"fourteen\", b\"fifteen\"],\n                 [b\"sixteen\", b\"seventeen\", b\"eighteen\"]],\n        \"UTF8_CHAR\": [[x.encode(\"utf-8\") for x in [u\"\\U0001d229\\U0001d227n\",\n                                                   u\"\\xc6\\u053c\\u025bv\\u025bn\",\n                                                   u\"tw\\u0c1dlv\\u025b\"]],\n                      [x.encode(\"utf-8\") for x in [u\"He\\xc3\\xc3o\",\n                                                   u\"W\\U0001f604rld\",\n                                                   u\"d\\xfcd\\xea\"]],\n                      [x.encode(\"utf-8\") for x in [u\"sixt\\xea\\xean\",\n                                                   u\"se\\U00010299enteen\",\n                                                   u\"ei\\U0001e920h\\x86een\"]]],\n    }[unit]\n    position = np.array([[1, -4, 3], [1, 2, -4], [-5, 2, 3]], dtype)\n    length = np.array([[2, 2, 4], [4, 3, 2], [5, 5, 5]], dtype)\n    expected_value = {\n        \"BYTE\": [[b\"en\", b\"ev\", b\"lve\"], [b\"hirt\", b\"urt\", b\"te\"],\n                 [b\"xteen\", b\"vente\", b\"hteen\"]],\n        \"UTF8_CHAR\": [[x.encode(\"utf-8\") for x in [u\"\\U0001d227n\",\n                                                   u\"\\u025bv\",\n                                                   u\"lv\\u025b\"]],\n                      [x.encode(\"utf-8\") for x in [u\"e\\xc3\\xc3o\",\n                                                   u\"rld\",\n                                                   u\"d\\xfc\"]],\n                      [x.encode(\"utf-8\") for x in [u\"xt\\xea\\xean\",\n                                                   u\"\\U00010299ente\",\n                                                   u\"h\\x86een\"]]],\n    }[unit]\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      substr = self.evaluate(substr_op)\n      self.assertAllEqual(substr, expected_value)\n\n  @parameterized.parameters(\n      (np.int32, \"BYTE\"),\n      (np.int64, \"BYTE\"),\n      (np.int32, \"UTF8_CHAR\"),\n      (np.int64, \"UTF8_CHAR\"),\n  )\n  def testBroadcast(self, dtype, unit):\n    # Broadcast pos/len onto input string\n    test_string = {\n        \"BYTE\": [[b\"ten\", b\"eleven\", b\"twelve\"],\n                 [b\"thirteen\", b\"fourteen\", b\"fifteen\"],\n                 [b\"sixteen\", b\"seventeen\", b\"eighteen\"],\n                 [b\"nineteen\", b\"twenty\", b\"twentyone\"]],\n        \"UTF8_CHAR\": [[x.encode(\"utf-8\") for x in [u\"\\U0001d229\\U0001d227n\",\n                                                   u\"\\xc6\\u053c\\u025bv\\u025bn\",\n                                                   u\"tw\\u0c1dlv\\u025b\"]],\n                      [x.encode(\"utf-8\") for x in [u\"th\\xcdrt\\xea\\xean\",\n                                                   u\"f\\U0001f604urt\\xea\\xean\",\n                                                   u\"f\\xcd\\ua09ctee\\ua0e4\"]],\n                      [x.encode(\"utf-8\") for x in [u\"s\\xcdxt\\xea\\xean\",\n                                                   u\"se\\U00010299enteen\",\n                                                   u\"ei\\U0001e920h\\x86een\"]],\n                      [x.encode(\"utf-8\") for x in [u\"nineteen\",\n                                                   u\"twenty\",\n                                                   u\"twentyone\"]]],\n    }[unit]\n    position = np.array([1, -4, 3], dtype)\n    length = np.array([1, 2, 3], dtype)\n    expected_value = {\n        \"BYTE\": [[b\"e\", b\"ev\", b\"lve\"], [b\"h\", b\"te\", b\"tee\"],\n                 [b\"i\", b\"te\", b\"hte\"], [b\"i\", b\"en\", b\"nty\"]],\n        \"UTF8_CHAR\": [[x.encode(\"utf-8\") for x in [u\"\\U0001d227\",\n                                                   u\"\\u025bv\", u\"lv\\u025b\"]],\n                      [x.encode(\"utf-8\") for x in [u\"h\", u\"t\\xea\", u\"tee\"]],\n                      [x.encode(\"utf-8\") for x in [u\"\\xcd\", u\"te\", u\"h\\x86e\"]],\n                      [x.encode(\"utf-8\") for x in [u\"i\", u\"en\", u\"nty\"]]],\n    }[unit]\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      substr = self.evaluate(substr_op)\n      self.assertAllEqual(substr, expected_value)\n\n    # Broadcast input string onto pos/len\n    test_string = {\n        \"BYTE\": [b\"thirteen\", b\"fourteen\", b\"fifteen\"],\n        \"UTF8_CHAR\": [x.encode(\"utf-8\") for x in [u\"th\\xcdrt\\xea\\xean\",\n                                                  u\"f\\U0001f604urt\\xea\\xean\",\n                                                  u\"f\\xcd\\ua09ctee\\ua0e4\"]],\n    }[unit]\n    position = np.array([[1, -2, 3], [-3, 2, 1], [5, 5, -5]], dtype)\n    length = np.array([[3, 2, 1], [1, 2, 3], [2, 2, 2]], dtype)\n    expected_value = {\n        \"BYTE\": [[b\"hir\", b\"en\", b\"t\"], [b\"e\", b\"ur\", b\"ift\"],\n                 [b\"ee\", b\"ee\", b\"ft\"]],\n        \"UTF8_CHAR\": [[x.encode(\"utf-8\") for x in [u\"h\\xcdr\", u\"\\xean\", u\"t\"]],\n                      [x.encode(\"utf-8\") for x in [u\"\\xea\", u\"ur\",\n                                                   u\"\\xcd\\ua09ct\"]],\n                      [x.encode(\"utf-8\") for x in [u\"\\xea\\xea\", u\"\\xea\\xea\",\n                                                   u\"\\ua09ct\"]]],\n    }[unit]\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      substr = self.evaluate(substr_op)\n      self.assertAllEqual(substr, expected_value)\n\n    # Test 1D broadcast\n    test_string = {\n        \"BYTE\": b\"thirteen\",\n        \"UTF8_CHAR\": u\"th\\xcdrt\\xea\\xean\".encode(\"utf-8\"),\n    }[unit]\n    position = np.array([1, -4, 7], dtype)\n    length = np.array([3, 2, 1], dtype)\n    expected_value = {\n        \"BYTE\": [b\"hir\", b\"te\", b\"n\"],\n        \"UTF8_CHAR\": [x.encode(\"utf-8\") for x in [u\"h\\xcdr\", u\"t\\xea\", u\"n\"]],\n    }[unit]\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      substr = self.evaluate(substr_op)\n      self.assertAllEqual(substr, expected_value)\n\n  @parameterized.parameters(\n      (np.int32, \"BYTE\"),\n      (np.int64, \"BYTE\"),\n      (np.int32, \"UTF8_CHAR\"),\n      (np.int64, \"UTF8_CHAR\"),\n  )\n  @test_util.run_deprecated_v1\n  def testBadBroadcast(self, dtype, unit):\n    test_string = [[b\"ten\", b\"eleven\", b\"twelve\"],\n                   [b\"thirteen\", b\"fourteen\", b\"fifteen\"],\n                   [b\"sixteen\", b\"seventeen\", b\"eighteen\"]]\n    position = np.array([1, 2, -3, 4], dtype)\n    length = np.array([1, 2, 3, 4], dtype)\n    with self.assertRaises(ValueError):\n      string_ops.substr(test_string, position, length, unit=unit)\n\n  @parameterized.parameters(\n      (np.int32, 6, \"BYTE\"),\n      (np.int64, 6, \"BYTE\"),\n      (np.int32, -6, \"BYTE\"),\n      (np.int64, -6, \"BYTE\"),\n      (np.int32, 6, \"UTF8_CHAR\"),\n      (np.int64, 6, \"UTF8_CHAR\"),\n      (np.int32, -6, \"UTF8_CHAR\"),\n      (np.int64, -6, \"UTF8_CHAR\"),\n  )\n  @test_util.run_deprecated_v1\n  def testOutOfRangeError_Scalar(self, dtype, pos, unit):\n    # Scalar/Scalar\n    test_string = {\n        \"BYTE\": b\"Hello\",\n        \"UTF8_CHAR\": u\"H\\xc3ll\\U0001f604\".encode(\"utf-8\"),\n    }[unit]\n    position = np.array(pos, dtype)\n    length = np.array(3, dtype)\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      with self.assertRaises(errors_impl.InvalidArgumentError):\n        self.evaluate(substr_op)\n\n  @parameterized.parameters(\n      (np.int32, 4, \"BYTE\"),\n      (np.int64, 4, \"BYTE\"),\n      (np.int32, -4, \"BYTE\"),\n      (np.int64, -4, \"BYTE\"),\n      (np.int32, 4, \"UTF8_CHAR\"),\n      (np.int64, 4, \"UTF8_CHAR\"),\n      (np.int32, -4, \"UTF8_CHAR\"),\n      (np.int64, -4, \"UTF8_CHAR\"),\n  )\n  @test_util.run_deprecated_v1\n  def testOutOfRangeError_VectorScalar(self, dtype, pos, unit):\n    # Vector/Scalar\n    test_string = {\n        \"BYTE\": [b\"good\", b\"good\", b\"bad\", b\"good\"],\n        \"UTF8_CHAR\": [x.encode(\"utf-8\") for x in [u\"g\\xc3\\xc3d\", u\"b\\xc3d\",\n                                                  u\"g\\xc3\\xc3d\"]],\n    }[unit]\n    position = np.array(pos, dtype)\n    length = np.array(1, dtype)\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      with self.assertRaises(errors_impl.InvalidArgumentError):\n        self.evaluate(substr_op)\n\n  @parameterized.parameters(\n      (np.int32, \"BYTE\"),\n      (np.int64, \"BYTE\"),\n      (np.int32, \"UTF8_CHAR\"),\n      (np.int64, \"UTF8_CHAR\"),\n  )\n  @test_util.run_deprecated_v1\n  def testOutOfRangeError_MatrixMatrix(self, dtype, unit):\n    # Matrix/Matrix\n    test_string = {\n        \"BYTE\": [[b\"good\", b\"good\", b\"good\"], [b\"good\", b\"good\", b\"bad\"],\n                 [b\"good\", b\"good\", b\"good\"]],\n        \"UTF8_CHAR\": [[x.encode(\"utf-8\") for x in [u\"g\\xc3\\xc3d\", u\"g\\xc3\\xc3d\",\n                                                   u\"g\\xc3\\xc3d\"]],\n                      [x.encode(\"utf-8\") for x in [u\"g\\xc3\\xc3d\", u\"g\\xc3\\xc3d\",\n                                                   u\"b\\xc3d\"]],\n                      [x.encode(\"utf-8\") for x in [u\"g\\xc3\\xc3d\", u\"g\\xc3\\xc3d\",\n                                                   u\"g\\xc3\\xc3d\"]]],\n    }[unit]\n    position = np.array([[1, 2, 3], [1, 2, 4], [1, 2, 3]], dtype)\n    length = np.array([[3, 2, 1], [1, 2, 3], [2, 2, 2]], dtype)\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      with self.assertRaises(errors_impl.InvalidArgumentError):\n        self.evaluate(substr_op)\n\n    # Matrix/Matrix (with negative)\n    position = np.array([[1, 2, -3], [1, 2, -4], [1, 2, -3]], dtype)\n    length = np.array([[3, 2, 1], [1, 2, 3], [2, 2, 2]], dtype)\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      with self.assertRaises(errors_impl.InvalidArgumentError):\n        self.evaluate(substr_op)\n\n  @parameterized.parameters(\n      (np.int32, \"BYTE\"),\n      (np.int64, \"BYTE\"),\n      (np.int32, \"UTF8_CHAR\"),\n      (np.int64, \"UTF8_CHAR\"),\n  )\n  @test_util.run_deprecated_v1\n  def testOutOfRangeError_Broadcast(self, dtype, unit):\n    # Broadcast\n    test_string = {\n        \"BYTE\": [[b\"good\", b\"good\", b\"good\"], [b\"good\", b\"good\", b\"bad\"]],\n        \"UTF8_CHAR\": [[x.encode(\"utf-8\") for x in [u\"g\\xc3\\xc3d\", u\"g\\xc3\\xc3d\",\n                                                   u\"g\\xc3\\xc3d\"]],\n                      [x.encode(\"utf-8\") for x in [u\"g\\xc3\\xc3d\", u\"g\\xc3\\xc3d\",\n                                                   u\"b\\xc3d\"]]],\n    }[unit]\n    position = np.array([1, 2, 4], dtype)\n    length = np.array([1, 2, 3], dtype)\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      with self.assertRaises(errors_impl.InvalidArgumentError):\n        self.evaluate(substr_op)\n\n    # Broadcast (with negative)\n    position = np.array([-1, -2, -4], dtype)\n    length = np.array([1, 2, 3], dtype)\n    substr_op = string_ops.substr(test_string, position, length, unit=unit)\n    with self.cached_session():\n      with self.assertRaises(errors_impl.InvalidArgumentError):\n        self.evaluate(substr_op)\n\n  @parameterized.parameters(\n      (np.int32, \"BYTE\"),\n      (np.int64, \"BYTE\"),\n      (np.int32, \"UTF8_CHAR\"),\n      (np.int64, \"UTF8_CHAR\"),\n  )\n  @test_util.run_deprecated_v1\n  def testMismatchPosLenShapes(self, dtype, unit):\n    test_string = {\n        \"BYTE\": [[b\"ten\", b\"eleven\", b\"twelve\"],\n                 [b\"thirteen\", b\"fourteen\", b\"fifteen\"],\n                 [b\"sixteen\", b\"seventeen\", b\"eighteen\"]],\n        \"UTF8_CHAR\": [[x.encode(\"utf-8\") for x in [u\"\\U0001d229\\U0001d227n\",\n                                                   u\"\\xc6\\u053c\\u025bv\\u025bn\",\n                                                   u\"tw\\u0c1dlv\\u025b\"]],\n                      [x.encode(\"utf-8\") for x in [u\"th\\xcdrt\\xea\\xean\",\n                                                   u\"f\\U0001f604urt\\xea\\xean\",\n                                                   u\"f\\xcd\\ua09ctee\\ua0e4\"]],\n                      [x.encode(\"utf-8\") for x in [u\"s\\xcdxt\\xea\\xean\",\n                                                   u\"se\\U00010299enteen\",\n                                                   u\"ei\\U0001e920h\\x86een\"]]],\n    }[unit]\n    position = np.array([[1, 2, 3]], dtype)\n    length = np.array([2, 3, 4], dtype)\n    # Should fail: position/length have different rank\n    with self.assertRaises(ValueError):\n      string_ops.substr(test_string, position, length)\n\n    position = np.array([[1, 2, 3], [1, 2, 3], [1, 2, 3]], dtype)\n    length = np.array([[2, 3, 4]], dtype)\n    # Should fail: position/length have different dimensionality\n    with self.assertRaises(ValueError):\n      string_ops.substr(test_string, position, length)\n\n  @test_util.run_deprecated_v1\n  def testWrongDtype(self):\n    with self.cached_session():\n      with self.assertRaises(TypeError):\n        string_ops.substr(b\"test\", 3.0, 1)\n      with self.assertRaises(TypeError):\n        string_ops.substr(b\"test\", 3, 1.0)\n\n  @test_util.run_deprecated_v1\n  def testInvalidUnit(self):\n    with self.cached_session():\n      with self.assertRaises(ValueError):\n        string_ops.substr(b\"test\", 3, 1, unit=\"UTF8\")\n\n  def testInvalidPos(self):\n    # Test case for GitHub issue 46900.\n    with self.assertRaises((ValueError, errors_impl.InvalidArgumentError)):\n      x = string_ops.substr(b\"abc\", len=1, pos=[1, -1])\n      self.evaluate(x)\n\n    with self.assertRaises((ValueError, errors_impl.InvalidArgumentError)):\n      x = string_ops.substr(b\"abc\", len=1, pos=[1, 2])\n      self.evaluate(x)\n\n\nif __name__ == \"__main__\":\n  test.main()\n"], "filenames": ["tensorflow/core/kernels/substr_op.cc", "tensorflow/python/kernel_tests/substr_op_test.py"], "buggy_code_start_loc": [53, 494], "buggy_code_end_loc": [53, 494], "fixing_code_start_loc": [54, 495], "fixing_code_end_loc": [59, 505], "type": "CWE-755", "message": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via `CHECK`-fail in `tf.strings.substr` with invalid arguments. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range.", "other": {"cve": {"id": "CVE-2021-29617", "sourceIdentifier": "security-advisories@github.com", "published": "2021-05-14T20:15:16.223", "lastModified": "2021-07-27T17:12:33.503", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TensorFlow is an end-to-end open source platform for machine learning. An attacker can cause a denial of service via `CHECK`-fail in `tf.strings.substr` with invalid arguments. The fix will be included in TensorFlow 2.5.0. We will also cherrypick this commit on TensorFlow 2.4.2, TensorFlow 2.3.3, TensorFlow 2.2.3 and TensorFlow 2.1.4, as these are also affected and still in supported range."}, {"lang": "es", "value": "TensorFlow es una plataforma de c\u00f3digo abierto de extremo a extremo para el aprendizaje autom\u00e1tico.&#xa0;Un atacante puede causar una denegaci\u00f3n de servicio por medio de \"CHECK\" - fallo en \"tf.strings.substr\" con argumentos no comprobados.&#xa0;La correcci\u00f3n ser\u00e1 inclu\u00edda en TensorFlow versi\u00f3n 2.5.0.&#xa0;Tambi\u00e9n seleccionaremos este commit en TensorFlow versi\u00f3n 2.4.2, TensorFlow versi\u00f3n 2.3.3, TensorFlow versi\u00f3n 2.2.3 y TensorFlow versi\u00f3n 2.1.4, ya que estos tambi\u00e9n est\u00e1n afectados y a\u00fan est\u00e1n en el rango compatible"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:N/S:U/C:N/I:N/A:L", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 2.5, "baseSeverity": "LOW"}, "exploitabilityScore": 1.0, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-755"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.1.4", "matchCriteriaId": "323ABCCE-24EB-47CC-87F6-48C101477587"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.2.0", "versionEndExcluding": "2.2.3", "matchCriteriaId": "64ABA90C-0649-4BB0-89C9-83C14BBDCC0F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.3.0", "versionEndExcluding": "2.3.3", "matchCriteriaId": "0F83E0CF-CBF6-4C24-8683-3E7A5DC95BA9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:google:tensorflow:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.4.0", "versionEndExcluding": "2.4.2", "matchCriteriaId": "8259531B-A8AC-4F8B-B60F-B69DE4767C03"}]}]}], "references": [{"url": "https://github.com/tensorflow/issues/46900", "source": "security-advisories@github.com", "tags": ["Broken Link"]}, {"url": "https://github.com/tensorflow/issues/46974", "source": "security-advisories@github.com", "tags": ["Broken Link"]}, {"url": "https://github.com/tensorflow/tensorflow/commit/890f7164b70354c57d40eda52dcdd7658677c09f", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tensorflow/tensorflow/security/advisories/GHSA-mmq6-q8r3-48fm", "source": "security-advisories@github.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tensorflow/tensorflow/commit/890f7164b70354c57d40eda52dcdd7658677c09f"}}