{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%               FFFFF  EEEEE   AAA   TTTTT  U   U  RRRR   EEEEE               %\n%               F      E      A   A    T    U   U  R   R  E                   %\n%               FFF    EEE    AAAAA    T    U   U  RRRR   EEE                 %\n%               F      E      A   A    T    U   U  R R    E                   %\n%               F      EEEEE  A   A    T     UUU   R  R   EEEEE               %\n%                                                                             %\n%                                                                             %\n%                      MagickCore Image Feature Methods                       %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/animate.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/client.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/composite.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/compress.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/display.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/feature.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/magic.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/matrix.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/morphology-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/paint.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantize.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/random_.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/segment.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/signature-private.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/timer.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/version.h\"\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     C a n n y E d g e I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CannyEdgeImage() uses a multi-stage algorithm to detect a wide range of\n%  edges in images.\n%\n%  The format of the CannyEdgeImage method is:\n%\n%      Image *CannyEdgeImage(const Image *image,const double radius,\n%        const double sigma,const double lower_percent,\n%        const double upper_percent,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o radius: the radius of the gaussian smoothing filter.\n%\n%    o sigma: the sigma of the gaussian smoothing filter.\n%\n%    o lower_percent: percentage of edge pixels in the lower threshold.\n%\n%    o upper_percent: percentage of edge pixels in the upper threshold.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\ntypedef struct _CannyInfo\n{\n  double\n    magnitude,\n    intensity;\n\n  int\n    orientation;\n\n  ssize_t\n    x,\n    y;\n} CannyInfo;\n\nstatic inline MagickBooleanType IsAuthenticPixel(const Image *image,\n  const ssize_t x,const ssize_t y)\n{\n  if ((x < 0) || (x >= (ssize_t) image->columns))\n    return(MagickFalse);\n  if ((y < 0) || (y >= (ssize_t) image->rows))\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType TraceEdges(Image *edge_image,CacheView *edge_view,\n  MatrixInfo *canny_cache,const ssize_t x,const ssize_t y,\n  const double lower_threshold,ExceptionInfo *exception)\n{\n  CannyInfo\n    edge,\n    pixel;\n\n  MagickBooleanType\n    status;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  q=GetCacheViewAuthenticPixels(edge_view,x,y,1,1,exception);\n  if (q == (Quantum *) NULL)\n    return(MagickFalse);\n  *q=QuantumRange;\n  status=SyncCacheViewAuthenticPixels(edge_view,exception);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  if (GetMatrixElement(canny_cache,0,0,&edge) == MagickFalse)\n    return(MagickFalse);\n  edge.x=x;\n  edge.y=y;\n  if (SetMatrixElement(canny_cache,0,0,&edge) == MagickFalse)\n    return(MagickFalse);\n  for (i=1; i != 0; )\n  {\n    ssize_t\n      v;\n\n    i--;\n    status=GetMatrixElement(canny_cache,i,0,&edge);\n    if (status == MagickFalse)\n      return(MagickFalse);\n    for (v=(-1); v <= 1; v++)\n    {\n      ssize_t\n        u;\n\n      for (u=(-1); u <= 1; u++)\n      {\n        if ((u == 0) && (v == 0))\n          continue;\n        if (IsAuthenticPixel(edge_image,edge.x+u,edge.y+v) == MagickFalse)\n          continue;\n        /*\n          Not an edge if gradient value is below the lower threshold.\n        */\n        q=GetCacheViewAuthenticPixels(edge_view,edge.x+u,edge.y+v,1,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          return(MagickFalse);\n        status=GetMatrixElement(canny_cache,edge.x+u,edge.y+v,&pixel);\n        if (status == MagickFalse)\n          return(MagickFalse);\n        if ((GetPixelIntensity(edge_image,q) == 0.0) &&\n            (pixel.intensity >= lower_threshold))\n          {\n            *q=QuantumRange;\n            status=SyncCacheViewAuthenticPixels(edge_view,exception);\n            if (status == MagickFalse)\n              return(MagickFalse);\n            edge.x+=u;\n            edge.y+=v;\n            status=SetMatrixElement(canny_cache,i,0,&edge);\n            if (status == MagickFalse)\n              return(MagickFalse);\n            i++;\n          }\n      }\n    }\n  }\n  return(MagickTrue);\n}\n\nMagickExport Image *CannyEdgeImage(const Image *image,const double radius,\n  const double sigma,const double lower_percent,const double upper_percent,\n  ExceptionInfo *exception)\n{\n#define CannyEdgeImageTag  \"CannyEdge/Image\"\n\n  CacheView\n    *edge_view;\n\n  CannyInfo\n    element;\n\n  char\n    geometry[MagickPathExtent];\n\n  double\n    lower_threshold,\n    max,\n    min,\n    upper_threshold;\n\n  Image\n    *edge_image;\n\n  KernelInfo\n    *kernel_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  MatrixInfo\n    *canny_cache;\n\n  ssize_t\n    y;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  /*\n    Filter out noise.\n  */\n  (void) FormatLocaleString(geometry,MagickPathExtent,\n    \"blur:%.20gx%.20g;blur:%.20gx%.20g+90\",radius,sigma,radius,sigma);\n  kernel_info=AcquireKernelInfo(geometry,exception);\n  if (kernel_info == (KernelInfo *) NULL)\n    ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n  edge_image=MorphologyImage(image,ConvolveMorphology,1,kernel_info,exception);\n  kernel_info=DestroyKernelInfo(kernel_info);\n  if (edge_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (TransformImageColorspace(edge_image,GRAYColorspace,exception) == MagickFalse)\n    {\n      edge_image=DestroyImage(edge_image);\n      return((Image *) NULL);\n    }\n  (void) SetImageAlphaChannel(edge_image,OffAlphaChannel,exception);\n  /*\n    Find the intensity gradient of the image.\n  */\n  canny_cache=AcquireMatrixInfo(edge_image->columns,edge_image->rows,\n    sizeof(CannyInfo),exception);\n  if (canny_cache == (MatrixInfo *) NULL)\n    {\n      edge_image=DestroyImage(edge_image);\n      return((Image *) NULL);\n    }\n  status=MagickTrue;\n  edge_view=AcquireVirtualCacheView(edge_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status) \\\n    magick_number_threads(edge_image,edge_image,edge_image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) edge_image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(edge_view,0,y,edge_image->columns+1,2,\n      exception);\n    if (p == (const Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) edge_image->columns; x++)\n    {\n      CannyInfo\n        pixel;\n\n      double\n        dx,\n        dy;\n\n      register const Quantum\n        *magick_restrict kernel_pixels;\n\n      ssize_t\n        v;\n\n      static double\n        Gx[2][2] =\n        {\n          { -1.0,  +1.0 },\n          { -1.0,  +1.0 }\n        },\n        Gy[2][2] =\n        {\n          { +1.0, +1.0 },\n          { -1.0, -1.0 }\n        };\n\n      (void) memset(&pixel,0,sizeof(pixel));\n      dx=0.0;\n      dy=0.0;\n      kernel_pixels=p;\n      for (v=0; v < 2; v++)\n      {\n        ssize_t\n          u;\n\n        for (u=0; u < 2; u++)\n        {\n          double\n            intensity;\n\n          intensity=GetPixelIntensity(edge_image,kernel_pixels+u);\n          dx+=0.5*Gx[v][u]*intensity;\n          dy+=0.5*Gy[v][u]*intensity;\n        }\n        kernel_pixels+=edge_image->columns+1;\n      }\n      pixel.magnitude=hypot(dx,dy);\n      pixel.orientation=0;\n      if (fabs(dx) > MagickEpsilon)\n        {\n          double\n            slope;\n\n          slope=dy/dx;\n          if (slope < 0.0)\n            {\n              if (slope < -2.41421356237)\n                pixel.orientation=0;\n              else\n                if (slope < -0.414213562373)\n                  pixel.orientation=1;\n                else\n                  pixel.orientation=2;\n            }\n          else\n            {\n              if (slope > 2.41421356237)\n                pixel.orientation=0;\n              else\n                if (slope > 0.414213562373)\n                  pixel.orientation=3;\n                else\n                  pixel.orientation=2;\n            }\n        }\n      if (SetMatrixElement(canny_cache,x,y,&pixel) == MagickFalse)\n        continue;\n      p+=GetPixelChannels(edge_image);\n    }\n  }\n  edge_view=DestroyCacheView(edge_view);\n  /*\n    Non-maxima suppression, remove pixels that are not considered to be part\n    of an edge.\n  */\n  progress=0;\n  (void) GetMatrixElement(canny_cache,0,0,&element);\n  max=element.intensity;\n  min=element.intensity;\n  edge_view=AcquireAuthenticCacheView(edge_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status) \\\n    magick_number_threads(edge_image,edge_image,edge_image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) edge_image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(edge_view,0,y,edge_image->columns,1,\n      exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) edge_image->columns; x++)\n    {\n      CannyInfo\n        alpha_pixel,\n        beta_pixel,\n        pixel;\n\n      (void) GetMatrixElement(canny_cache,x,y,&pixel);\n      switch (pixel.orientation)\n      {\n        case 0:\n        default:\n        {\n          /*\n            0 degrees, north and south.\n          */\n          (void) GetMatrixElement(canny_cache,x,y-1,&alpha_pixel);\n          (void) GetMatrixElement(canny_cache,x,y+1,&beta_pixel);\n          break;\n        }\n        case 1:\n        {\n          /*\n            45 degrees, northwest and southeast.\n          */\n          (void) GetMatrixElement(canny_cache,x-1,y-1,&alpha_pixel);\n          (void) GetMatrixElement(canny_cache,x+1,y+1,&beta_pixel);\n          break;\n        }\n        case 2:\n        {\n          /*\n            90 degrees, east and west.\n          */\n          (void) GetMatrixElement(canny_cache,x-1,y,&alpha_pixel);\n          (void) GetMatrixElement(canny_cache,x+1,y,&beta_pixel);\n          break;\n        }\n        case 3:\n        {\n          /*\n            135 degrees, northeast and southwest.\n          */\n          (void) GetMatrixElement(canny_cache,x+1,y-1,&beta_pixel);\n          (void) GetMatrixElement(canny_cache,x-1,y+1,&alpha_pixel);\n          break;\n        }\n      }\n      pixel.intensity=pixel.magnitude;\n      if ((pixel.magnitude < alpha_pixel.magnitude) ||\n          (pixel.magnitude < beta_pixel.magnitude))\n        pixel.intensity=0;\n      (void) SetMatrixElement(canny_cache,x,y,&pixel);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp critical (MagickCore_CannyEdgeImage)\n#endif\n      {\n        if (pixel.intensity < min)\n          min=pixel.intensity;\n        if (pixel.intensity > max)\n          max=pixel.intensity;\n      }\n      *q=0;\n      q+=GetPixelChannels(edge_image);\n    }\n    if (SyncCacheViewAuthenticPixels(edge_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  edge_view=DestroyCacheView(edge_view);\n  /*\n    Estimate hysteresis threshold.\n  */\n  lower_threshold=lower_percent*(max-min)+min;\n  upper_threshold=upper_percent*(max-min)+min;\n  /*\n    Hysteresis threshold.\n  */\n  edge_view=AcquireAuthenticCacheView(edge_image,exception);\n  for (y=0; y < (ssize_t) edge_image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    for (x=0; x < (ssize_t) edge_image->columns; x++)\n    {\n      CannyInfo\n        pixel;\n\n      register const Quantum\n        *magick_restrict p;\n\n      /*\n        Edge if pixel gradient higher than upper threshold.\n      */\n      p=GetCacheViewVirtualPixels(edge_view,x,y,1,1,exception);\n      if (p == (const Quantum *) NULL)\n        continue;\n      status=GetMatrixElement(canny_cache,x,y,&pixel);\n      if (status == MagickFalse)\n        continue;\n      if ((GetPixelIntensity(edge_image,p) == 0.0) &&\n          (pixel.intensity >= upper_threshold))\n        status=TraceEdges(edge_image,edge_view,canny_cache,x,y,lower_threshold,\n          exception);\n    }\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,CannyEdgeImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  edge_view=DestroyCacheView(edge_view);\n  /*\n    Free resources.\n  */\n  canny_cache=DestroyMatrixInfo(canny_cache);\n  return(edge_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e F e a t u r e s                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageFeatures() returns features for each channel in the image in\n%  each of four directions (horizontal, vertical, left and right diagonals)\n%  for the specified distance.  The features include the angular second\n%  moment, contrast, correlation, sum of squares: variance, inverse difference\n%  moment, sum average, sum varience, sum entropy, entropy, difference variance,%  difference entropy, information measures of correlation 1, information\n%  measures of correlation 2, and maximum correlation coefficient.  You can\n%  access the red channel contrast, for example, like this:\n%\n%      channel_features=GetImageFeatures(image,1,exception);\n%      contrast=channel_features[RedPixelChannel].contrast[0];\n%\n%  Use MagickRelinquishMemory() to free the features buffer.\n%\n%  The format of the GetImageFeatures method is:\n%\n%      ChannelFeatures *GetImageFeatures(const Image *image,\n%        const size_t distance,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o distance: the distance.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline double MagickLog10(const double x)\n{\n#define Log10Epsilon  (1.0e-11)\n\n if (fabs(x) < Log10Epsilon)\n   return(log10(Log10Epsilon));\n return(log10(fabs(x)));\n}\n\nMagickExport ChannelFeatures *GetImageFeatures(const Image *image,\n  const size_t distance,ExceptionInfo *exception)\n{\n  typedef struct _ChannelStatistics\n  {\n    PixelInfo\n      direction[4];  /* horizontal, vertical, left and right diagonals */\n  } ChannelStatistics;\n\n  CacheView\n    *image_view;\n\n  ChannelFeatures\n    *channel_features;\n\n  ChannelStatistics\n    **cooccurrence,\n    correlation,\n    *density_x,\n    *density_xy,\n    *density_y,\n    entropy_x,\n    entropy_xy,\n    entropy_xy1,\n    entropy_xy2,\n    entropy_y,\n    mean,\n    **Q,\n    *sum,\n    sum_squares,\n    variance;\n\n  PixelPacket\n    gray,\n    *grays;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i,\n    r;\n\n  size_t\n    length;\n\n  unsigned int\n    number_grays;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->columns < (distance+1)) || (image->rows < (distance+1)))\n    return((ChannelFeatures *) NULL);\n  length=MaxPixelChannels+1UL;\n  channel_features=(ChannelFeatures *) AcquireQuantumMemory(length,\n    sizeof(*channel_features));\n  if (channel_features == (ChannelFeatures *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) memset(channel_features,0,length*\n    sizeof(*channel_features));\n  /*\n    Form grays.\n  */\n  grays=(PixelPacket *) AcquireQuantumMemory(MaxMap+1UL,sizeof(*grays));\n  if (grays == (PixelPacket *) NULL)\n    {\n      channel_features=(ChannelFeatures *) RelinquishMagickMemory(\n        channel_features);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(channel_features);\n    }\n  for (i=0; i <= (ssize_t) MaxMap; i++)\n  {\n    grays[i].red=(~0U);\n    grays[i].green=(~0U);\n    grays[i].blue=(~0U);\n    grays[i].alpha=(~0U);\n    grays[i].black=(~0U);\n  }\n  status=MagickTrue;\n  image_view=AcquireVirtualCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (r=0; r < (ssize_t) image->rows; r++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,r,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      grays[ScaleQuantumToMap(GetPixelRed(image,p))].red=\n        ScaleQuantumToMap(GetPixelRed(image,p));\n      grays[ScaleQuantumToMap(GetPixelGreen(image,p))].green=\n        ScaleQuantumToMap(GetPixelGreen(image,p));\n      grays[ScaleQuantumToMap(GetPixelBlue(image,p))].blue=\n        ScaleQuantumToMap(GetPixelBlue(image,p));\n      if (image->colorspace == CMYKColorspace)\n        grays[ScaleQuantumToMap(GetPixelBlack(image,p))].black=\n          ScaleQuantumToMap(GetPixelBlack(image,p));\n      if (image->alpha_trait != UndefinedPixelTrait)\n        grays[ScaleQuantumToMap(GetPixelAlpha(image,p))].alpha=\n          ScaleQuantumToMap(GetPixelAlpha(image,p));\n      p+=GetPixelChannels(image);\n    }\n  }\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    {\n      grays=(PixelPacket *) RelinquishMagickMemory(grays);\n      channel_features=(ChannelFeatures *) RelinquishMagickMemory(\n        channel_features);\n      return(channel_features);\n    }\n  (void) memset(&gray,0,sizeof(gray));\n  for (i=0; i <= (ssize_t) MaxMap; i++)\n  {\n    if (grays[i].red != ~0U)\n      grays[gray.red++].red=grays[i].red;\n    if (grays[i].green != ~0U)\n      grays[gray.green++].green=grays[i].green;\n    if (grays[i].blue != ~0U)\n      grays[gray.blue++].blue=grays[i].blue;\n    if (image->colorspace == CMYKColorspace)\n      if (grays[i].black != ~0U)\n        grays[gray.black++].black=grays[i].black;\n    if (image->alpha_trait != UndefinedPixelTrait)\n      if (grays[i].alpha != ~0U)\n        grays[gray.alpha++].alpha=grays[i].alpha;\n  }\n  /*\n    Allocate spatial dependence matrix.\n  */\n  number_grays=gray.red;\n  if (gray.green > number_grays)\n    number_grays=gray.green;\n  if (gray.blue > number_grays)\n    number_grays=gray.blue;\n  if (image->colorspace == CMYKColorspace)\n    if (gray.black > number_grays)\n      number_grays=gray.black;\n  if (image->alpha_trait != UndefinedPixelTrait)\n    if (gray.alpha > number_grays)\n      number_grays=gray.alpha;\n  cooccurrence=(ChannelStatistics **) AcquireQuantumMemory(number_grays,\n    sizeof(*cooccurrence));\n  density_x=(ChannelStatistics *) AcquireQuantumMemory(2*(number_grays+1),\n    sizeof(*density_x));\n  density_xy=(ChannelStatistics *) AcquireQuantumMemory(2*(number_grays+1),\n    sizeof(*density_xy));\n  density_y=(ChannelStatistics *) AcquireQuantumMemory(2*(number_grays+1),\n    sizeof(*density_y));\n  Q=(ChannelStatistics **) AcquireQuantumMemory(number_grays,sizeof(*Q));\n  sum=(ChannelStatistics *) AcquireQuantumMemory(number_grays,sizeof(*sum));\n  if ((cooccurrence == (ChannelStatistics **) NULL) ||\n      (density_x == (ChannelStatistics *) NULL) ||\n      (density_xy == (ChannelStatistics *) NULL) ||\n      (density_y == (ChannelStatistics *) NULL) ||\n      (Q == (ChannelStatistics **) NULL) ||\n      (sum == (ChannelStatistics *) NULL))\n    {\n      if (Q != (ChannelStatistics **) NULL)\n        {\n          for (i=0; i < (ssize_t) number_grays; i++)\n            Q[i]=(ChannelStatistics *) RelinquishMagickMemory(Q[i]);\n          Q=(ChannelStatistics **) RelinquishMagickMemory(Q);\n        }\n      if (sum != (ChannelStatistics *) NULL)\n        sum=(ChannelStatistics *) RelinquishMagickMemory(sum);\n      if (density_y != (ChannelStatistics *) NULL)\n        density_y=(ChannelStatistics *) RelinquishMagickMemory(density_y);\n      if (density_xy != (ChannelStatistics *) NULL)\n        density_xy=(ChannelStatistics *) RelinquishMagickMemory(density_xy);\n      if (density_x != (ChannelStatistics *) NULL)\n        density_x=(ChannelStatistics *) RelinquishMagickMemory(density_x);\n      if (cooccurrence != (ChannelStatistics **) NULL)\n        {\n          for (i=0; i < (ssize_t) number_grays; i++)\n            cooccurrence[i]=(ChannelStatistics *)\n              RelinquishMagickMemory(cooccurrence[i]);\n          cooccurrence=(ChannelStatistics **) RelinquishMagickMemory(\n            cooccurrence);\n        }\n      grays=(PixelPacket *) RelinquishMagickMemory(grays);\n      channel_features=(ChannelFeatures *) RelinquishMagickMemory(\n        channel_features);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(channel_features);\n    }\n  (void) memset(&correlation,0,sizeof(correlation));\n  (void) memset(density_x,0,2*(number_grays+1)*sizeof(*density_x));\n  (void) memset(density_xy,0,2*(number_grays+1)*sizeof(*density_xy));\n  (void) memset(density_y,0,2*(number_grays+1)*sizeof(*density_y));\n  (void) memset(&mean,0,sizeof(mean));\n  (void) memset(sum,0,number_grays*sizeof(*sum));\n  (void) memset(&sum_squares,0,sizeof(sum_squares));\n  (void) memset(density_xy,0,2*number_grays*sizeof(*density_xy));\n  (void) memset(&entropy_x,0,sizeof(entropy_x));\n  (void) memset(&entropy_xy,0,sizeof(entropy_xy));\n  (void) memset(&entropy_xy1,0,sizeof(entropy_xy1));\n  (void) memset(&entropy_xy2,0,sizeof(entropy_xy2));\n  (void) memset(&entropy_y,0,sizeof(entropy_y));\n  (void) memset(&variance,0,sizeof(variance));\n  for (i=0; i < (ssize_t) number_grays; i++)\n  {\n    cooccurrence[i]=(ChannelStatistics *) AcquireQuantumMemory(number_grays,\n      sizeof(**cooccurrence));\n    Q[i]=(ChannelStatistics *) AcquireQuantumMemory(number_grays,sizeof(**Q));\n    if ((cooccurrence[i] == (ChannelStatistics *) NULL) ||\n        (Q[i] == (ChannelStatistics *) NULL))\n      break;\n    (void) memset(cooccurrence[i],0,number_grays*\n      sizeof(**cooccurrence));\n    (void) memset(Q[i],0,number_grays*sizeof(**Q));\n  }\n  if (i < (ssize_t) number_grays)\n    {\n      for (i--; i >= 0; i--)\n      {\n        if (Q[i] != (ChannelStatistics *) NULL)\n          Q[i]=(ChannelStatistics *) RelinquishMagickMemory(Q[i]);\n        if (cooccurrence[i] != (ChannelStatistics *) NULL)\n          cooccurrence[i]=(ChannelStatistics *)\n            RelinquishMagickMemory(cooccurrence[i]);\n      }\n      Q=(ChannelStatistics **) RelinquishMagickMemory(Q);\n      cooccurrence=(ChannelStatistics **) RelinquishMagickMemory(cooccurrence);\n      sum=(ChannelStatistics *) RelinquishMagickMemory(sum);\n      density_y=(ChannelStatistics *) RelinquishMagickMemory(density_y);\n      density_xy=(ChannelStatistics *) RelinquishMagickMemory(density_xy);\n      density_x=(ChannelStatistics *) RelinquishMagickMemory(density_x);\n      grays=(PixelPacket *) RelinquishMagickMemory(grays);\n      channel_features=(ChannelFeatures *) RelinquishMagickMemory(\n        channel_features);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(channel_features);\n    }\n  /*\n    Initialize spatial dependence matrix.\n  */\n  status=MagickTrue;\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (r=0; r < (ssize_t) image->rows; r++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    ssize_t\n      offset,\n      u,\n      v;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,-(ssize_t) distance,r,image->columns+\n      2*distance,distance+2,exception);\n    if (p == (const Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    p+=distance*GetPixelChannels(image);;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      for (i=0; i < 4; i++)\n      {\n        switch (i)\n        {\n          case 0:\n          default:\n          {\n            /*\n              Horizontal adjacency.\n            */\n            offset=(ssize_t) distance;\n            break;\n          }\n          case 1:\n          {\n            /*\n              Vertical adjacency.\n            */\n            offset=(ssize_t) (image->columns+2*distance);\n            break;\n          }\n          case 2:\n          {\n            /*\n              Right diagonal adjacency.\n            */\n            offset=(ssize_t) ((image->columns+2*distance)-distance);\n            break;\n          }\n          case 3:\n          {\n            /*\n              Left diagonal adjacency.\n            */\n            offset=(ssize_t) ((image->columns+2*distance)+distance);\n            break;\n          }\n        }\n        u=0;\n        v=0;\n        while (grays[u].red != ScaleQuantumToMap(GetPixelRed(image,p)))\n          u++;\n        while (grays[v].red != ScaleQuantumToMap(GetPixelRed(image,p+offset*GetPixelChannels(image))))\n          v++;\n        cooccurrence[u][v].direction[i].red++;\n        cooccurrence[v][u].direction[i].red++;\n        u=0;\n        v=0;\n        while (grays[u].green != ScaleQuantumToMap(GetPixelGreen(image,p)))\n          u++;\n        while (grays[v].green != ScaleQuantumToMap(GetPixelGreen(image,p+offset*GetPixelChannels(image))))\n          v++;\n        cooccurrence[u][v].direction[i].green++;\n        cooccurrence[v][u].direction[i].green++;\n        u=0;\n        v=0;\n        while (grays[u].blue != ScaleQuantumToMap(GetPixelBlue(image,p)))\n          u++;\n        while (grays[v].blue != ScaleQuantumToMap(GetPixelBlue(image,p+offset*GetPixelChannels(image))))\n          v++;\n        cooccurrence[u][v].direction[i].blue++;\n        cooccurrence[v][u].direction[i].blue++;\n        if (image->colorspace == CMYKColorspace)\n          {\n            u=0;\n            v=0;\n            while (grays[u].black != ScaleQuantumToMap(GetPixelBlack(image,p)))\n              u++;\n            while (grays[v].black != ScaleQuantumToMap(GetPixelBlack(image,p+offset*GetPixelChannels(image))))\n              v++;\n            cooccurrence[u][v].direction[i].black++;\n            cooccurrence[v][u].direction[i].black++;\n          }\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            u=0;\n            v=0;\n            while (grays[u].alpha != ScaleQuantumToMap(GetPixelAlpha(image,p)))\n              u++;\n            while (grays[v].alpha != ScaleQuantumToMap(GetPixelAlpha(image,p+offset*GetPixelChannels(image))))\n              v++;\n            cooccurrence[u][v].direction[i].alpha++;\n            cooccurrence[v][u].direction[i].alpha++;\n          }\n      }\n      p+=GetPixelChannels(image);\n    }\n  }\n  grays=(PixelPacket *) RelinquishMagickMemory(grays);\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    {\n      for (i=0; i < (ssize_t) number_grays; i++)\n        cooccurrence[i]=(ChannelStatistics *)\n          RelinquishMagickMemory(cooccurrence[i]);\n      cooccurrence=(ChannelStatistics **) RelinquishMagickMemory(cooccurrence);\n      channel_features=(ChannelFeatures *) RelinquishMagickMemory(\n        channel_features);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(channel_features);\n    }\n  /*\n    Normalize spatial dependence matrix.\n  */\n  for (i=0; i < 4; i++)\n  {\n    double\n      normalize;\n\n    register ssize_t\n      y;\n\n    switch (i)\n    {\n      case 0:\n      default:\n      {\n        /*\n          Horizontal adjacency.\n        */\n        normalize=2.0*image->rows*(image->columns-distance);\n        break;\n      }\n      case 1:\n      {\n        /*\n          Vertical adjacency.\n        */\n        normalize=2.0*(image->rows-distance)*image->columns;\n        break;\n      }\n      case 2:\n      {\n        /*\n          Right diagonal adjacency.\n        */\n        normalize=2.0*(image->rows-distance)*(image->columns-distance);\n        break;\n      }\n      case 3:\n      {\n        /*\n          Left diagonal adjacency.\n        */\n        normalize=2.0*(image->rows-distance)*(image->columns-distance);\n        break;\n      }\n    }\n    normalize=PerceptibleReciprocal(normalize);\n    for (y=0; y < (ssize_t) number_grays; y++)\n    {\n      register ssize_t\n        x;\n\n      for (x=0; x < (ssize_t) number_grays; x++)\n      {\n        cooccurrence[x][y].direction[i].red*=normalize;\n        cooccurrence[x][y].direction[i].green*=normalize;\n        cooccurrence[x][y].direction[i].blue*=normalize;\n        if (image->colorspace == CMYKColorspace)\n          cooccurrence[x][y].direction[i].black*=normalize;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          cooccurrence[x][y].direction[i].alpha*=normalize;\n      }\n    }\n  }\n  /*\n    Compute texture features.\n  */\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status) \\\n    magick_number_threads(image,image,number_grays,1)\n#endif\n  for (i=0; i < 4; i++)\n  {\n    register ssize_t\n      y;\n\n    for (y=0; y < (ssize_t) number_grays; y++)\n    {\n      register ssize_t\n        x;\n\n      for (x=0; x < (ssize_t) number_grays; x++)\n      {\n        /*\n          Angular second moment:  measure of homogeneity of the image.\n        */\n        channel_features[RedPixelChannel].angular_second_moment[i]+=\n          cooccurrence[x][y].direction[i].red*\n          cooccurrence[x][y].direction[i].red;\n        channel_features[GreenPixelChannel].angular_second_moment[i]+=\n          cooccurrence[x][y].direction[i].green*\n          cooccurrence[x][y].direction[i].green;\n        channel_features[BluePixelChannel].angular_second_moment[i]+=\n          cooccurrence[x][y].direction[i].blue*\n          cooccurrence[x][y].direction[i].blue;\n        if (image->colorspace == CMYKColorspace)\n          channel_features[BlackPixelChannel].angular_second_moment[i]+=\n            cooccurrence[x][y].direction[i].black*\n            cooccurrence[x][y].direction[i].black;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          channel_features[AlphaPixelChannel].angular_second_moment[i]+=\n            cooccurrence[x][y].direction[i].alpha*\n            cooccurrence[x][y].direction[i].alpha;\n        /*\n          Correlation: measure of linear-dependencies in the image.\n        */\n        sum[y].direction[i].red+=cooccurrence[x][y].direction[i].red;\n        sum[y].direction[i].green+=cooccurrence[x][y].direction[i].green;\n        sum[y].direction[i].blue+=cooccurrence[x][y].direction[i].blue;\n        if (image->colorspace == CMYKColorspace)\n          sum[y].direction[i].black+=cooccurrence[x][y].direction[i].black;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          sum[y].direction[i].alpha+=cooccurrence[x][y].direction[i].alpha;\n        correlation.direction[i].red+=x*y*cooccurrence[x][y].direction[i].red;\n        correlation.direction[i].green+=x*y*\n          cooccurrence[x][y].direction[i].green;\n        correlation.direction[i].blue+=x*y*\n          cooccurrence[x][y].direction[i].blue;\n        if (image->colorspace == CMYKColorspace)\n          correlation.direction[i].black+=x*y*\n            cooccurrence[x][y].direction[i].black;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          correlation.direction[i].alpha+=x*y*\n            cooccurrence[x][y].direction[i].alpha;\n        /*\n          Inverse Difference Moment.\n        */\n        channel_features[RedPixelChannel].inverse_difference_moment[i]+=\n          cooccurrence[x][y].direction[i].red/((y-x)*(y-x)+1);\n        channel_features[GreenPixelChannel].inverse_difference_moment[i]+=\n          cooccurrence[x][y].direction[i].green/((y-x)*(y-x)+1);\n        channel_features[BluePixelChannel].inverse_difference_moment[i]+=\n          cooccurrence[x][y].direction[i].blue/((y-x)*(y-x)+1);\n        if (image->colorspace == CMYKColorspace)\n          channel_features[BlackPixelChannel].inverse_difference_moment[i]+=\n            cooccurrence[x][y].direction[i].black/((y-x)*(y-x)+1);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          channel_features[AlphaPixelChannel].inverse_difference_moment[i]+=\n            cooccurrence[x][y].direction[i].alpha/((y-x)*(y-x)+1);\n        /*\n          Sum average.\n        */\n        density_xy[y+x+2].direction[i].red+=\n          cooccurrence[x][y].direction[i].red;\n        density_xy[y+x+2].direction[i].green+=\n          cooccurrence[x][y].direction[i].green;\n        density_xy[y+x+2].direction[i].blue+=\n          cooccurrence[x][y].direction[i].blue;\n        if (image->colorspace == CMYKColorspace)\n          density_xy[y+x+2].direction[i].black+=\n            cooccurrence[x][y].direction[i].black;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          density_xy[y+x+2].direction[i].alpha+=\n            cooccurrence[x][y].direction[i].alpha;\n        /*\n          Entropy.\n        */\n        channel_features[RedPixelChannel].entropy[i]-=\n          cooccurrence[x][y].direction[i].red*\n          MagickLog10(cooccurrence[x][y].direction[i].red);\n        channel_features[GreenPixelChannel].entropy[i]-=\n          cooccurrence[x][y].direction[i].green*\n          MagickLog10(cooccurrence[x][y].direction[i].green);\n        channel_features[BluePixelChannel].entropy[i]-=\n          cooccurrence[x][y].direction[i].blue*\n          MagickLog10(cooccurrence[x][y].direction[i].blue);\n        if (image->colorspace == CMYKColorspace)\n          channel_features[BlackPixelChannel].entropy[i]-=\n            cooccurrence[x][y].direction[i].black*\n            MagickLog10(cooccurrence[x][y].direction[i].black);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          channel_features[AlphaPixelChannel].entropy[i]-=\n            cooccurrence[x][y].direction[i].alpha*\n            MagickLog10(cooccurrence[x][y].direction[i].alpha);\n        /*\n          Information Measures of Correlation.\n        */\n        density_x[x].direction[i].red+=cooccurrence[x][y].direction[i].red;\n        density_x[x].direction[i].green+=cooccurrence[x][y].direction[i].green;\n        density_x[x].direction[i].blue+=cooccurrence[x][y].direction[i].blue;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          density_x[x].direction[i].alpha+=\n            cooccurrence[x][y].direction[i].alpha;\n        if (image->colorspace == CMYKColorspace)\n          density_x[x].direction[i].black+=\n            cooccurrence[x][y].direction[i].black;\n        density_y[y].direction[i].red+=cooccurrence[x][y].direction[i].red;\n        density_y[y].direction[i].green+=cooccurrence[x][y].direction[i].green;\n        density_y[y].direction[i].blue+=cooccurrence[x][y].direction[i].blue;\n        if (image->colorspace == CMYKColorspace)\n          density_y[y].direction[i].black+=\n            cooccurrence[x][y].direction[i].black;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          density_y[y].direction[i].alpha+=\n            cooccurrence[x][y].direction[i].alpha;\n      }\n      mean.direction[i].red+=y*sum[y].direction[i].red;\n      sum_squares.direction[i].red+=y*y*sum[y].direction[i].red;\n      mean.direction[i].green+=y*sum[y].direction[i].green;\n      sum_squares.direction[i].green+=y*y*sum[y].direction[i].green;\n      mean.direction[i].blue+=y*sum[y].direction[i].blue;\n      sum_squares.direction[i].blue+=y*y*sum[y].direction[i].blue;\n      if (image->colorspace == CMYKColorspace)\n        {\n          mean.direction[i].black+=y*sum[y].direction[i].black;\n          sum_squares.direction[i].black+=y*y*sum[y].direction[i].black;\n        }\n      if (image->alpha_trait != UndefinedPixelTrait)\n        {\n          mean.direction[i].alpha+=y*sum[y].direction[i].alpha;\n          sum_squares.direction[i].alpha+=y*y*sum[y].direction[i].alpha;\n        }\n    }\n    /*\n      Correlation: measure of linear-dependencies in the image.\n    */\n    channel_features[RedPixelChannel].correlation[i]=\n      (correlation.direction[i].red-mean.direction[i].red*\n      mean.direction[i].red)/(sqrt(sum_squares.direction[i].red-\n      (mean.direction[i].red*mean.direction[i].red))*sqrt(\n      sum_squares.direction[i].red-(mean.direction[i].red*\n      mean.direction[i].red)));\n    channel_features[GreenPixelChannel].correlation[i]=\n      (correlation.direction[i].green-mean.direction[i].green*\n      mean.direction[i].green)/(sqrt(sum_squares.direction[i].green-\n      (mean.direction[i].green*mean.direction[i].green))*sqrt(\n      sum_squares.direction[i].green-(mean.direction[i].green*\n      mean.direction[i].green)));\n    channel_features[BluePixelChannel].correlation[i]=\n      (correlation.direction[i].blue-mean.direction[i].blue*\n      mean.direction[i].blue)/(sqrt(sum_squares.direction[i].blue-\n      (mean.direction[i].blue*mean.direction[i].blue))*sqrt(\n      sum_squares.direction[i].blue-(mean.direction[i].blue*\n      mean.direction[i].blue)));\n    if (image->colorspace == CMYKColorspace)\n      channel_features[BlackPixelChannel].correlation[i]=\n        (correlation.direction[i].black-mean.direction[i].black*\n        mean.direction[i].black)/(sqrt(sum_squares.direction[i].black-\n        (mean.direction[i].black*mean.direction[i].black))*sqrt(\n        sum_squares.direction[i].black-(mean.direction[i].black*\n        mean.direction[i].black)));\n    if (image->alpha_trait != UndefinedPixelTrait)\n      channel_features[AlphaPixelChannel].correlation[i]=\n        (correlation.direction[i].alpha-mean.direction[i].alpha*\n        mean.direction[i].alpha)/(sqrt(sum_squares.direction[i].alpha-\n        (mean.direction[i].alpha*mean.direction[i].alpha))*sqrt(\n        sum_squares.direction[i].alpha-(mean.direction[i].alpha*\n        mean.direction[i].alpha)));\n  }\n  /*\n    Compute more texture features.\n  */\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status) \\\n    magick_number_threads(image,image,number_grays,1)\n#endif\n  for (i=0; i < 4; i++)\n  {\n    register ssize_t\n      x;\n\n    for (x=2; x < (ssize_t) (2*number_grays); x++)\n    {\n      /*\n        Sum average.\n      */\n      channel_features[RedPixelChannel].sum_average[i]+=\n        x*density_xy[x].direction[i].red;\n      channel_features[GreenPixelChannel].sum_average[i]+=\n        x*density_xy[x].direction[i].green;\n      channel_features[BluePixelChannel].sum_average[i]+=\n        x*density_xy[x].direction[i].blue;\n      if (image->colorspace == CMYKColorspace)\n        channel_features[BlackPixelChannel].sum_average[i]+=\n          x*density_xy[x].direction[i].black;\n      if (image->alpha_trait != UndefinedPixelTrait)\n        channel_features[AlphaPixelChannel].sum_average[i]+=\n          x*density_xy[x].direction[i].alpha;\n      /*\n        Sum entropy.\n      */\n      channel_features[RedPixelChannel].sum_entropy[i]-=\n        density_xy[x].direction[i].red*\n        MagickLog10(density_xy[x].direction[i].red);\n      channel_features[GreenPixelChannel].sum_entropy[i]-=\n        density_xy[x].direction[i].green*\n        MagickLog10(density_xy[x].direction[i].green);\n      channel_features[BluePixelChannel].sum_entropy[i]-=\n        density_xy[x].direction[i].blue*\n        MagickLog10(density_xy[x].direction[i].blue);\n      if (image->colorspace == CMYKColorspace)\n        channel_features[BlackPixelChannel].sum_entropy[i]-=\n          density_xy[x].direction[i].black*\n          MagickLog10(density_xy[x].direction[i].black);\n      if (image->alpha_trait != UndefinedPixelTrait)\n        channel_features[AlphaPixelChannel].sum_entropy[i]-=\n          density_xy[x].direction[i].alpha*\n          MagickLog10(density_xy[x].direction[i].alpha);\n      /*\n        Sum variance.\n      */\n      channel_features[RedPixelChannel].sum_variance[i]+=\n        (x-channel_features[RedPixelChannel].sum_entropy[i])*\n        (x-channel_features[RedPixelChannel].sum_entropy[i])*\n        density_xy[x].direction[i].red;\n      channel_features[GreenPixelChannel].sum_variance[i]+=\n        (x-channel_features[GreenPixelChannel].sum_entropy[i])*\n        (x-channel_features[GreenPixelChannel].sum_entropy[i])*\n        density_xy[x].direction[i].green;\n      channel_features[BluePixelChannel].sum_variance[i]+=\n        (x-channel_features[BluePixelChannel].sum_entropy[i])*\n        (x-channel_features[BluePixelChannel].sum_entropy[i])*\n        density_xy[x].direction[i].blue;\n      if (image->colorspace == CMYKColorspace)\n        channel_features[BlackPixelChannel].sum_variance[i]+=\n          (x-channel_features[BlackPixelChannel].sum_entropy[i])*\n          (x-channel_features[BlackPixelChannel].sum_entropy[i])*\n          density_xy[x].direction[i].black;\n      if (image->alpha_trait != UndefinedPixelTrait)\n        channel_features[AlphaPixelChannel].sum_variance[i]+=\n          (x-channel_features[AlphaPixelChannel].sum_entropy[i])*\n          (x-channel_features[AlphaPixelChannel].sum_entropy[i])*\n          density_xy[x].direction[i].alpha;\n    }\n  }\n  /*\n    Compute more texture features.\n  */\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status) \\\n    magick_number_threads(image,image,number_grays,1)\n#endif\n  for (i=0; i < 4; i++)\n  {\n    register ssize_t\n      y;\n\n    for (y=0; y < (ssize_t) number_grays; y++)\n    {\n      register ssize_t\n        x;\n\n      for (x=0; x < (ssize_t) number_grays; x++)\n      {\n        /*\n          Sum of Squares: Variance\n        */\n        variance.direction[i].red+=(y-mean.direction[i].red+1)*\n          (y-mean.direction[i].red+1)*cooccurrence[x][y].direction[i].red;\n        variance.direction[i].green+=(y-mean.direction[i].green+1)*\n          (y-mean.direction[i].green+1)*cooccurrence[x][y].direction[i].green;\n        variance.direction[i].blue+=(y-mean.direction[i].blue+1)*\n          (y-mean.direction[i].blue+1)*cooccurrence[x][y].direction[i].blue;\n        if (image->colorspace == CMYKColorspace)\n          variance.direction[i].black+=(y-mean.direction[i].black+1)*\n            (y-mean.direction[i].black+1)*cooccurrence[x][y].direction[i].black;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          variance.direction[i].alpha+=(y-mean.direction[i].alpha+1)*\n            (y-mean.direction[i].alpha+1)*\n            cooccurrence[x][y].direction[i].alpha;\n        /*\n          Sum average / Difference Variance.\n        */\n        density_xy[MagickAbsoluteValue(y-x)].direction[i].red+=\n          cooccurrence[x][y].direction[i].red;\n        density_xy[MagickAbsoluteValue(y-x)].direction[i].green+=\n          cooccurrence[x][y].direction[i].green;\n        density_xy[MagickAbsoluteValue(y-x)].direction[i].blue+=\n          cooccurrence[x][y].direction[i].blue;\n        if (image->colorspace == CMYKColorspace)\n          density_xy[MagickAbsoluteValue(y-x)].direction[i].black+=\n            cooccurrence[x][y].direction[i].black;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          density_xy[MagickAbsoluteValue(y-x)].direction[i].alpha+=\n            cooccurrence[x][y].direction[i].alpha;\n        /*\n          Information Measures of Correlation.\n        */\n        entropy_xy.direction[i].red-=cooccurrence[x][y].direction[i].red*\n          MagickLog10(cooccurrence[x][y].direction[i].red);\n        entropy_xy.direction[i].green-=cooccurrence[x][y].direction[i].green*\n          MagickLog10(cooccurrence[x][y].direction[i].green);\n        entropy_xy.direction[i].blue-=cooccurrence[x][y].direction[i].blue*\n          MagickLog10(cooccurrence[x][y].direction[i].blue);\n        if (image->colorspace == CMYKColorspace)\n          entropy_xy.direction[i].black-=cooccurrence[x][y].direction[i].black*\n            MagickLog10(cooccurrence[x][y].direction[i].black);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          entropy_xy.direction[i].alpha-=\n            cooccurrence[x][y].direction[i].alpha*MagickLog10(\n            cooccurrence[x][y].direction[i].alpha);\n        entropy_xy1.direction[i].red-=(cooccurrence[x][y].direction[i].red*\n          MagickLog10(density_x[x].direction[i].red*density_y[y].direction[i].red));\n        entropy_xy1.direction[i].green-=(cooccurrence[x][y].direction[i].green*\n          MagickLog10(density_x[x].direction[i].green*\n          density_y[y].direction[i].green));\n        entropy_xy1.direction[i].blue-=(cooccurrence[x][y].direction[i].blue*\n          MagickLog10(density_x[x].direction[i].blue*density_y[y].direction[i].blue));\n        if (image->colorspace == CMYKColorspace)\n          entropy_xy1.direction[i].black-=(\n            cooccurrence[x][y].direction[i].black*MagickLog10(\n            density_x[x].direction[i].black*density_y[y].direction[i].black));\n        if (image->alpha_trait != UndefinedPixelTrait)\n          entropy_xy1.direction[i].alpha-=(\n            cooccurrence[x][y].direction[i].alpha*MagickLog10(\n            density_x[x].direction[i].alpha*density_y[y].direction[i].alpha));\n        entropy_xy2.direction[i].red-=(density_x[x].direction[i].red*\n          density_y[y].direction[i].red*MagickLog10(density_x[x].direction[i].red*\n          density_y[y].direction[i].red));\n        entropy_xy2.direction[i].green-=(density_x[x].direction[i].green*\n          density_y[y].direction[i].green*MagickLog10(density_x[x].direction[i].green*\n          density_y[y].direction[i].green));\n        entropy_xy2.direction[i].blue-=(density_x[x].direction[i].blue*\n          density_y[y].direction[i].blue*MagickLog10(density_x[x].direction[i].blue*\n          density_y[y].direction[i].blue));\n        if (image->colorspace == CMYKColorspace)\n          entropy_xy2.direction[i].black-=(density_x[x].direction[i].black*\n            density_y[y].direction[i].black*MagickLog10(\n            density_x[x].direction[i].black*density_y[y].direction[i].black));\n        if (image->alpha_trait != UndefinedPixelTrait)\n          entropy_xy2.direction[i].alpha-=(density_x[x].direction[i].alpha*\n            density_y[y].direction[i].alpha*MagickLog10(\n            density_x[x].direction[i].alpha*density_y[y].direction[i].alpha));\n      }\n    }\n    channel_features[RedPixelChannel].variance_sum_of_squares[i]=\n      variance.direction[i].red;\n    channel_features[GreenPixelChannel].variance_sum_of_squares[i]=\n      variance.direction[i].green;\n    channel_features[BluePixelChannel].variance_sum_of_squares[i]=\n      variance.direction[i].blue;\n    if (image->colorspace == CMYKColorspace)\n      channel_features[BlackPixelChannel].variance_sum_of_squares[i]=\n        variance.direction[i].black;\n    if (image->alpha_trait != UndefinedPixelTrait)\n      channel_features[AlphaPixelChannel].variance_sum_of_squares[i]=\n        variance.direction[i].alpha;\n  }\n  /*\n    Compute more texture features.\n  */\n  (void) memset(&variance,0,sizeof(variance));\n  (void) memset(&sum_squares,0,sizeof(sum_squares));\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status) \\\n    magick_number_threads(image,image,number_grays,1)\n#endif\n  for (i=0; i < 4; i++)\n  {\n    register ssize_t\n      x;\n\n    for (x=0; x < (ssize_t) number_grays; x++)\n    {\n      /*\n        Difference variance.\n      */\n      variance.direction[i].red+=density_xy[x].direction[i].red;\n      variance.direction[i].green+=density_xy[x].direction[i].green;\n      variance.direction[i].blue+=density_xy[x].direction[i].blue;\n      if (image->colorspace == CMYKColorspace)\n        variance.direction[i].black+=density_xy[x].direction[i].black;\n      if (image->alpha_trait != UndefinedPixelTrait)\n        variance.direction[i].alpha+=density_xy[x].direction[i].alpha;\n      sum_squares.direction[i].red+=density_xy[x].direction[i].red*\n        density_xy[x].direction[i].red;\n      sum_squares.direction[i].green+=density_xy[x].direction[i].green*\n        density_xy[x].direction[i].green;\n      sum_squares.direction[i].blue+=density_xy[x].direction[i].blue*\n        density_xy[x].direction[i].blue;\n      if (image->colorspace == CMYKColorspace)\n        sum_squares.direction[i].black+=density_xy[x].direction[i].black*\n          density_xy[x].direction[i].black;\n      if (image->alpha_trait != UndefinedPixelTrait)\n        sum_squares.direction[i].alpha+=density_xy[x].direction[i].alpha*\n          density_xy[x].direction[i].alpha;\n      /*\n        Difference entropy.\n      */\n      channel_features[RedPixelChannel].difference_entropy[i]-=\n        density_xy[x].direction[i].red*\n        MagickLog10(density_xy[x].direction[i].red);\n      channel_features[GreenPixelChannel].difference_entropy[i]-=\n        density_xy[x].direction[i].green*\n        MagickLog10(density_xy[x].direction[i].green);\n      channel_features[BluePixelChannel].difference_entropy[i]-=\n        density_xy[x].direction[i].blue*\n        MagickLog10(density_xy[x].direction[i].blue);\n      if (image->colorspace == CMYKColorspace)\n        channel_features[BlackPixelChannel].difference_entropy[i]-=\n          density_xy[x].direction[i].black*\n          MagickLog10(density_xy[x].direction[i].black);\n      if (image->alpha_trait != UndefinedPixelTrait)\n        channel_features[AlphaPixelChannel].difference_entropy[i]-=\n          density_xy[x].direction[i].alpha*\n          MagickLog10(density_xy[x].direction[i].alpha);\n      /*\n        Information Measures of Correlation.\n      */\n      entropy_x.direction[i].red-=(density_x[x].direction[i].red*\n        MagickLog10(density_x[x].direction[i].red));\n      entropy_x.direction[i].green-=(density_x[x].direction[i].green*\n        MagickLog10(density_x[x].direction[i].green));\n      entropy_x.direction[i].blue-=(density_x[x].direction[i].blue*\n        MagickLog10(density_x[x].direction[i].blue));\n      if (image->colorspace == CMYKColorspace)\n        entropy_x.direction[i].black-=(density_x[x].direction[i].black*\n          MagickLog10(density_x[x].direction[i].black));\n      if (image->alpha_trait != UndefinedPixelTrait)\n        entropy_x.direction[i].alpha-=(density_x[x].direction[i].alpha*\n          MagickLog10(density_x[x].direction[i].alpha));\n      entropy_y.direction[i].red-=(density_y[x].direction[i].red*\n        MagickLog10(density_y[x].direction[i].red));\n      entropy_y.direction[i].green-=(density_y[x].direction[i].green*\n        MagickLog10(density_y[x].direction[i].green));\n      entropy_y.direction[i].blue-=(density_y[x].direction[i].blue*\n        MagickLog10(density_y[x].direction[i].blue));\n      if (image->colorspace == CMYKColorspace)\n        entropy_y.direction[i].black-=(density_y[x].direction[i].black*\n          MagickLog10(density_y[x].direction[i].black));\n      if (image->alpha_trait != UndefinedPixelTrait)\n        entropy_y.direction[i].alpha-=(density_y[x].direction[i].alpha*\n          MagickLog10(density_y[x].direction[i].alpha));\n    }\n    /*\n      Difference variance.\n    */\n    channel_features[RedPixelChannel].difference_variance[i]=\n      (((double) number_grays*number_grays*sum_squares.direction[i].red)-\n      (variance.direction[i].red*variance.direction[i].red))/\n      ((double) number_grays*number_grays*number_grays*number_grays);\n    channel_features[GreenPixelChannel].difference_variance[i]=\n      (((double) number_grays*number_grays*sum_squares.direction[i].green)-\n      (variance.direction[i].green*variance.direction[i].green))/\n      ((double) number_grays*number_grays*number_grays*number_grays);\n    channel_features[BluePixelChannel].difference_variance[i]=\n      (((double) number_grays*number_grays*sum_squares.direction[i].blue)-\n      (variance.direction[i].blue*variance.direction[i].blue))/\n      ((double) number_grays*number_grays*number_grays*number_grays);\n    if (image->colorspace == CMYKColorspace)\n      channel_features[BlackPixelChannel].difference_variance[i]=\n        (((double) number_grays*number_grays*sum_squares.direction[i].black)-\n        (variance.direction[i].black*variance.direction[i].black))/\n        ((double) number_grays*number_grays*number_grays*number_grays);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      channel_features[AlphaPixelChannel].difference_variance[i]=\n        (((double) number_grays*number_grays*sum_squares.direction[i].alpha)-\n        (variance.direction[i].alpha*variance.direction[i].alpha))/\n        ((double) number_grays*number_grays*number_grays*number_grays);\n    /*\n      Information Measures of Correlation.\n    */\n    channel_features[RedPixelChannel].measure_of_correlation_1[i]=\n      (entropy_xy.direction[i].red-entropy_xy1.direction[i].red)/\n      (entropy_x.direction[i].red > entropy_y.direction[i].red ?\n       entropy_x.direction[i].red : entropy_y.direction[i].red);\n    channel_features[GreenPixelChannel].measure_of_correlation_1[i]=\n      (entropy_xy.direction[i].green-entropy_xy1.direction[i].green)/\n      (entropy_x.direction[i].green > entropy_y.direction[i].green ?\n       entropy_x.direction[i].green : entropy_y.direction[i].green);\n    channel_features[BluePixelChannel].measure_of_correlation_1[i]=\n      (entropy_xy.direction[i].blue-entropy_xy1.direction[i].blue)/\n      (entropy_x.direction[i].blue > entropy_y.direction[i].blue ?\n       entropy_x.direction[i].blue : entropy_y.direction[i].blue);\n    if (image->colorspace == CMYKColorspace)\n      channel_features[BlackPixelChannel].measure_of_correlation_1[i]=\n        (entropy_xy.direction[i].black-entropy_xy1.direction[i].black)/\n        (entropy_x.direction[i].black > entropy_y.direction[i].black ?\n         entropy_x.direction[i].black : entropy_y.direction[i].black);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      channel_features[AlphaPixelChannel].measure_of_correlation_1[i]=\n        (entropy_xy.direction[i].alpha-entropy_xy1.direction[i].alpha)/\n        (entropy_x.direction[i].alpha > entropy_y.direction[i].alpha ?\n         entropy_x.direction[i].alpha : entropy_y.direction[i].alpha);\n    channel_features[RedPixelChannel].measure_of_correlation_2[i]=\n      (sqrt(fabs(1.0-exp(-2.0*(double) (entropy_xy2.direction[i].red-\n      entropy_xy.direction[i].red)))));\n    channel_features[GreenPixelChannel].measure_of_correlation_2[i]=\n      (sqrt(fabs(1.0-exp(-2.0*(double) (entropy_xy2.direction[i].green-\n      entropy_xy.direction[i].green)))));\n    channel_features[BluePixelChannel].measure_of_correlation_2[i]=\n      (sqrt(fabs(1.0-exp(-2.0*(double) (entropy_xy2.direction[i].blue-\n      entropy_xy.direction[i].blue)))));\n    if (image->colorspace == CMYKColorspace)\n      channel_features[BlackPixelChannel].measure_of_correlation_2[i]=\n        (sqrt(fabs(1.0-exp(-2.0*(double) (entropy_xy2.direction[i].black-\n        entropy_xy.direction[i].black)))));\n    if (image->alpha_trait != UndefinedPixelTrait)\n      channel_features[AlphaPixelChannel].measure_of_correlation_2[i]=\n        (sqrt(fabs(1.0-exp(-2.0*(double) (entropy_xy2.direction[i].alpha-\n        entropy_xy.direction[i].alpha)))));\n  }\n  /*\n    Compute more texture features.\n  */\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status) \\\n    magick_number_threads(image,image,number_grays,1)\n#endif\n  for (i=0; i < 4; i++)\n  {\n    ssize_t\n      z;\n\n    for (z=0; z < (ssize_t) number_grays; z++)\n    {\n      register ssize_t\n        y;\n\n      ChannelStatistics\n        pixel;\n\n      (void) memset(&pixel,0,sizeof(pixel));\n      for (y=0; y < (ssize_t) number_grays; y++)\n      {\n        register ssize_t\n          x;\n\n        for (x=0; x < (ssize_t) number_grays; x++)\n        {\n          /*\n            Contrast:  amount of local variations present in an image.\n          */\n          if (((y-x) == z) || ((x-y) == z))\n            {\n              pixel.direction[i].red+=cooccurrence[x][y].direction[i].red;\n              pixel.direction[i].green+=cooccurrence[x][y].direction[i].green;\n              pixel.direction[i].blue+=cooccurrence[x][y].direction[i].blue;\n              if (image->colorspace == CMYKColorspace)\n                pixel.direction[i].black+=cooccurrence[x][y].direction[i].black;\n              if (image->alpha_trait != UndefinedPixelTrait)\n                pixel.direction[i].alpha+=\n                  cooccurrence[x][y].direction[i].alpha;\n            }\n          /*\n            Maximum Correlation Coefficient.\n          */\n          Q[z][y].direction[i].red+=cooccurrence[z][x].direction[i].red*\n            cooccurrence[y][x].direction[i].red/density_x[z].direction[i].red/\n            density_y[x].direction[i].red;\n          Q[z][y].direction[i].green+=cooccurrence[z][x].direction[i].green*\n            cooccurrence[y][x].direction[i].green/\n            density_x[z].direction[i].green/density_y[x].direction[i].red;\n          Q[z][y].direction[i].blue+=cooccurrence[z][x].direction[i].blue*\n            cooccurrence[y][x].direction[i].blue/density_x[z].direction[i].blue/\n            density_y[x].direction[i].blue;\n          if (image->colorspace == CMYKColorspace)\n            Q[z][y].direction[i].black+=cooccurrence[z][x].direction[i].black*\n              cooccurrence[y][x].direction[i].black/\n              density_x[z].direction[i].black/density_y[x].direction[i].black;\n          if (image->alpha_trait != UndefinedPixelTrait)\n            Q[z][y].direction[i].alpha+=\n              cooccurrence[z][x].direction[i].alpha*\n              cooccurrence[y][x].direction[i].alpha/\n              density_x[z].direction[i].alpha/\n              density_y[x].direction[i].alpha;\n        }\n      }\n      channel_features[RedPixelChannel].contrast[i]+=z*z*\n        pixel.direction[i].red;\n      channel_features[GreenPixelChannel].contrast[i]+=z*z*\n        pixel.direction[i].green;\n      channel_features[BluePixelChannel].contrast[i]+=z*z*\n        pixel.direction[i].blue;\n      if (image->colorspace == CMYKColorspace)\n        channel_features[BlackPixelChannel].contrast[i]+=z*z*\n          pixel.direction[i].black;\n      if (image->alpha_trait != UndefinedPixelTrait)\n        channel_features[AlphaPixelChannel].contrast[i]+=z*z*\n          pixel.direction[i].alpha;\n    }\n    /*\n      Maximum Correlation Coefficient.\n      Future: return second largest eigenvalue of Q.\n    */\n    channel_features[RedPixelChannel].maximum_correlation_coefficient[i]=\n      sqrt((double) -1.0);\n    channel_features[GreenPixelChannel].maximum_correlation_coefficient[i]=\n      sqrt((double) -1.0);\n    channel_features[BluePixelChannel].maximum_correlation_coefficient[i]=\n      sqrt((double) -1.0);\n    if (image->colorspace == CMYKColorspace)\n      channel_features[BlackPixelChannel].maximum_correlation_coefficient[i]=\n        sqrt((double) -1.0);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      channel_features[AlphaPixelChannel].maximum_correlation_coefficient[i]=\n        sqrt((double) -1.0);\n  }\n  /*\n    Relinquish resources.\n  */\n  sum=(ChannelStatistics *) RelinquishMagickMemory(sum);\n  for (i=0; i < (ssize_t) number_grays; i++)\n    Q[i]=(ChannelStatistics *) RelinquishMagickMemory(Q[i]);\n  Q=(ChannelStatistics **) RelinquishMagickMemory(Q);\n  density_y=(ChannelStatistics *) RelinquishMagickMemory(density_y);\n  density_xy=(ChannelStatistics *) RelinquishMagickMemory(density_xy);\n  density_x=(ChannelStatistics *) RelinquishMagickMemory(density_x);\n  for (i=0; i < (ssize_t) number_grays; i++)\n    cooccurrence[i]=(ChannelStatistics *)\n      RelinquishMagickMemory(cooccurrence[i]);\n  cooccurrence=(ChannelStatistics **) RelinquishMagickMemory(cooccurrence);\n  return(channel_features);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     H o u g h L i n e I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Use HoughLineImage() in conjunction with any binary edge extracted image (we\n%  recommand Canny) to identify lines in the image.  The algorithm accumulates\n%  counts for every white pixel for every possible orientation (for angles from\n%  0 to 179 in 1 degree increments) and distance from the center of the image to\n%  the corner (in 1 px increments) and stores the counts in an accumulator\n%  matrix of angle vs distance. The size of the accumulator is 180x(diagonal/2).\n%  Next it searches this space for peaks in counts and converts the locations\n%  of the peaks to slope and intercept in the normal x,y input image space. Use\n%  the slope/intercepts to find the endpoints clipped to the bounds of the\n%  image. The lines are then drawn. The counts are a measure of the length of\n%  the lines.\n%\n%  The format of the HoughLineImage method is:\n%\n%      Image *HoughLineImage(const Image *image,const size_t width,\n%        const size_t height,const size_t threshold,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o width, height: find line pairs as local maxima in this neighborhood.\n%\n%    o threshold: the line count threshold.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline double MagickRound(double x)\n{\n  /*\n    Round the fraction to nearest integer.\n  */\n  if ((x-floor(x)) < (ceil(x)-x))\n    return(floor(x));\n  return(ceil(x));\n}\n\nstatic Image *RenderHoughLines(const ImageInfo *image_info,const size_t columns,\n  const size_t rows,ExceptionInfo *exception)\n{\n#define BoundingBox  \"viewbox\"\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Open image.\n  */\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->columns=columns;\n  image->rows=rows;\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  draw_info->affine.sx=image->resolution.x == 0.0 ? 1.0 : image->resolution.x/\n    DefaultResolution;\n  draw_info->affine.sy=image->resolution.y == 0.0 ? 1.0 : image->resolution.y/\n    DefaultResolution;\n  image->columns=(size_t) (draw_info->affine.sx*image->columns);\n  image->rows=(size_t) (draw_info->affine.sy*image->rows);\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  if (SetImageBackgroundColor(image,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Render drawing.\n  */\n  if (GetBlobStreamData(image) == (unsigned char *) NULL)\n    draw_info->primitive=FileToString(image->filename,~0UL,exception);\n  else\n    {\n      draw_info->primitive=(char *) AcquireMagickMemory((size_t)\n        GetBlobSize(image)+1);\n      if (draw_info->primitive != (char *) NULL)\n        {\n          (void) memcpy(draw_info->primitive,GetBlobStreamData(image),\n            (size_t) GetBlobSize(image));\n          draw_info->primitive[GetBlobSize(image)]='\\0';\n        }\n     }\n  (void) DrawImage(image,draw_info,exception);\n  draw_info=DestroyDrawInfo(draw_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\nMagickExport Image *HoughLineImage(const Image *image,const size_t width,\n  const size_t height,const size_t threshold,ExceptionInfo *exception)\n{\n#define HoughLineImageTag  \"HoughLine/Image\"\n\n  CacheView\n    *image_view;\n\n  char\n    message[MagickPathExtent],\n    path[MagickPathExtent];\n\n  const char\n    *artifact;\n\n  double\n    hough_height;\n\n  Image\n    *lines_image = NULL;\n\n  ImageInfo\n    *image_info;\n\n  int\n    file;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  MatrixInfo\n    *accumulator;\n\n  PointInfo\n    center;\n\n  register ssize_t\n    y;\n\n  size_t\n    accumulator_height,\n    accumulator_width,\n    line_count;\n\n  /*\n    Create the accumulator.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  accumulator_width=180;\n  hough_height=((sqrt(2.0)*(double) (image->rows > image->columns ?\n    image->rows : image->columns))/2.0);\n  accumulator_height=(size_t) (2.0*hough_height);\n  accumulator=AcquireMatrixInfo(accumulator_width,accumulator_height,\n    sizeof(double),exception);\n  if (accumulator == (MatrixInfo *) NULL)\n    ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (NullMatrix(accumulator) == MagickFalse)\n    {\n      accumulator=DestroyMatrixInfo(accumulator);\n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  /*\n    Populate the accumulator.\n  */\n  status=MagickTrue;\n  progress=0;\n  center.x=(double) image->columns/2.0;\n  center.y=(double) image->rows/2.0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (GetPixelIntensity(image,p) > (QuantumRange/2.0))\n        {\n          register ssize_t\n            i;\n\n          for (i=0; i < 180; i++)\n          {\n            double\n              count,\n              radius;\n\n            radius=(((double) x-center.x)*cos(DegreesToRadians((double) i)))+\n              (((double) y-center.y)*sin(DegreesToRadians((double) i)));\n            (void) GetMatrixElement(accumulator,i,(ssize_t)\n              MagickRound(radius+hough_height),&count);\n            count++;\n            (void) SetMatrixElement(accumulator,i,(ssize_t)\n              MagickRound(radius+hough_height),&count);\n          }\n        }\n      p+=GetPixelChannels(image);\n    }\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,CannyEdgeImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    {\n      accumulator=DestroyMatrixInfo(accumulator);\n      return((Image *) NULL);\n    }\n  /*\n    Generate line segments from accumulator.\n  */\n  file=AcquireUniqueFileResource(path);\n  if (file == -1)\n    {\n      accumulator=DestroyMatrixInfo(accumulator);\n      return((Image *) NULL);\n    }\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"# Hough line transform: %.20gx%.20g%+.20g\\n\",(double) width,\n    (double) height,(double) threshold);\n  if (write(file,message,strlen(message)) != (ssize_t) strlen(message))\n    status=MagickFalse;\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"viewbox 0 0 %.20g %.20g\\n\",(double) image->columns,(double) image->rows);\n  if (write(file,message,strlen(message)) != (ssize_t) strlen(message))\n    status=MagickFalse;\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"# x1,y1 x2,y2 # count angle distance\\n\");\n  if (write(file,message,strlen(message)) != (ssize_t) strlen(message))\n    status=MagickFalse;\n  line_count=image->columns > image->rows ? image->columns/4 : image->rows/4;\n  if (threshold != 0)\n    line_count=threshold;\n  for (y=0; y < (ssize_t) accumulator_height; y++)\n  {\n    register ssize_t\n      x;\n\n    for (x=0; x < (ssize_t) accumulator_width; x++)\n    {\n      double\n        count;\n\n      (void) GetMatrixElement(accumulator,x,y,&count);\n      if (count >= (double) line_count)\n        {\n          double\n            maxima;\n\n          SegmentInfo\n            line;\n\n          ssize_t\n            v;\n\n          /*\n            Is point a local maxima?\n          */\n          maxima=count;\n          for (v=(-((ssize_t) height/2)); v <= (((ssize_t) height/2)); v++)\n          {\n            ssize_t\n              u;\n\n            for (u=(-((ssize_t) width/2)); u <= (((ssize_t) width/2)); u++)\n            {\n              if ((u != 0) || (v !=0))\n                {\n                  (void) GetMatrixElement(accumulator,x+u,y+v,&count);\n                  if (count > maxima)\n                    {\n                      maxima=count;\n                      break;\n                    }\n                }\n            }\n            if (u < (ssize_t) (width/2))\n              break;\n          }\n          (void) GetMatrixElement(accumulator,x,y,&count);\n          if (maxima > count)\n            continue;\n          if ((x >= 45) && (x <= 135))\n            {\n              /*\n                y = (r-x cos(t))/sin(t)\n              */\n              line.x1=0.0;\n              line.y1=((double) (y-(accumulator_height/2.0))-((line.x1-\n                (image->columns/2.0))*cos(DegreesToRadians((double) x))))/\n                sin(DegreesToRadians((double) x))+(image->rows/2.0);\n              line.x2=(double) image->columns;\n              line.y2=((double) (y-(accumulator_height/2.0))-((line.x2-\n                (image->columns/2.0))*cos(DegreesToRadians((double) x))))/\n                sin(DegreesToRadians((double) x))+(image->rows/2.0);\n            }\n          else\n            {\n              /*\n                x = (r-y cos(t))/sin(t)\n              */\n              line.y1=0.0;\n              line.x1=((double) (y-(accumulator_height/2.0))-((line.y1-\n                (image->rows/2.0))*sin(DegreesToRadians((double) x))))/\n                cos(DegreesToRadians((double) x))+(image->columns/2.0);\n              line.y2=(double) image->rows;\n              line.x2=((double) (y-(accumulator_height/2.0))-((line.y2-\n                (image->rows/2.0))*sin(DegreesToRadians((double) x))))/\n                cos(DegreesToRadians((double) x))+(image->columns/2.0);\n            }\n          (void) FormatLocaleString(message,MagickPathExtent,\n            \"line %g,%g %g,%g  # %g %g %g\\n\",line.x1,line.y1,line.x2,line.y2,\n            maxima,(double) x,(double) y);\n          if (write(file,message,strlen(message)) != (ssize_t) strlen(message))\n            status=MagickFalse;\n        }\n    }\n  }\n  (void) close(file);\n  /*\n    Render lines to image canvas.\n  */\n  image_info=AcquireImageInfo();\n  image_info->background_color=image->background_color;\n  (void) FormatLocaleString(image_info->filename,MagickPathExtent,\"%s\",path);\n  artifact=GetImageArtifact(image,\"background\");\n  if (artifact != (const char *) NULL)\n    (void) SetImageOption(image_info,\"background\",artifact);\n  artifact=GetImageArtifact(image,\"fill\");\n  if (artifact != (const char *) NULL)\n    (void) SetImageOption(image_info,\"fill\",artifact);\n  artifact=GetImageArtifact(image,\"stroke\");\n  if (artifact != (const char *) NULL)\n    (void) SetImageOption(image_info,\"stroke\",artifact);\n  artifact=GetImageArtifact(image,\"strokewidth\");\n  if (artifact != (const char *) NULL)\n    (void) SetImageOption(image_info,\"strokewidth\",artifact);\n  lines_image=RenderHoughLines(image_info,image->columns,image->rows,exception);\n  artifact=GetImageArtifact(image,\"hough-lines:accumulator\");\n  if ((lines_image != (Image *) NULL) &&\n      (IsStringTrue(artifact) != MagickFalse))\n    {\n      Image\n        *accumulator_image;\n\n      accumulator_image=MatrixToImage(accumulator,exception);\n      if (accumulator_image != (Image *) NULL)\n        AppendImageToList(&lines_image,accumulator_image);\n    }\n  /*\n    Free resources.\n  */\n  accumulator=DestroyMatrixInfo(accumulator);\n  image_info=DestroyImageInfo(image_info);\n  (void) RelinquishUniqueFileResource(path);\n  return(GetFirstImageInList(lines_image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     M e a n S h i f t I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MeanShiftImage() delineate arbitrarily shaped clusters in the image. For\n%  each pixel, it visits all the pixels in the neighborhood specified by\n%  the window centered at the pixel and excludes those that are outside the\n%  radius=(window-1)/2 surrounding the pixel. From those pixels, it finds those\n%  that are within the specified color distance from the current mean, and\n%  computes a new x,y centroid from those coordinates and a new mean. This new\n%  x,y centroid is used as the center for a new window. This process iterates\n%  until it converges and the final mean is replaces the (original window\n%  center) pixel value. It repeats this process for the next pixel, etc.,\n%  until it processes all pixels in the image. Results are typically better with\n%  colorspaces other than sRGB. We recommend YIQ, YUV or YCbCr.\n%\n%  The format of the MeanShiftImage method is:\n%\n%      Image *MeanShiftImage(const Image *image,const size_t width,\n%        const size_t height,const double color_distance,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o width, height: find pixels in this neighborhood.\n%\n%    o color_distance: the color distance.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *MeanShiftImage(const Image *image,const size_t width,\n  const size_t height,const double color_distance,ExceptionInfo *exception)\n{\n#define MaxMeanShiftIterations  100\n#define MeanShiftImageTag  \"MeanShift/Image\"\n\n  CacheView\n    *image_view,\n    *mean_view,\n    *pixel_view;\n\n  Image\n    *mean_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  mean_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (mean_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(mean_image,DirectClass,exception) == MagickFalse)\n    {\n      mean_image=DestroyImage(mean_image);\n      return((Image *) NULL);\n    }\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  pixel_view=AcquireVirtualCacheView(image,exception);\n  mean_view=AcquireAuthenticCacheView(mean_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status,progress) \\\n    magick_number_threads(mean_image,mean_image,mean_image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) mean_image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=GetCacheViewAuthenticPixels(mean_view,0,y,mean_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) mean_image->columns; x++)\n    {\n      PixelInfo\n        mean_pixel,\n        previous_pixel;\n\n      PointInfo\n        mean_location,\n        previous_location;\n\n      register ssize_t\n        i;\n\n      GetPixelInfo(image,&mean_pixel);\n      GetPixelInfoPixel(image,p,&mean_pixel);\n      mean_location.x=(double) x;\n      mean_location.y=(double) y;\n      for (i=0; i < MaxMeanShiftIterations; i++)\n      {\n        double\n          distance,\n          gamma;\n\n        PixelInfo\n          sum_pixel;\n\n        PointInfo\n          sum_location;\n\n        ssize_t\n          count,\n          v;\n\n        sum_location.x=0.0;\n        sum_location.y=0.0;\n        GetPixelInfo(image,&sum_pixel);\n        previous_location=mean_location;\n        previous_pixel=mean_pixel;\n        count=0;\n        for (v=(-((ssize_t) height/2)); v <= (((ssize_t) height/2)); v++)\n        {\n          ssize_t\n            u;\n\n          for (u=(-((ssize_t) width/2)); u <= (((ssize_t) width/2)); u++)\n          {\n            if ((v*v+u*u) <= (ssize_t) ((width/2)*(height/2)))\n              {\n                PixelInfo\n                  pixel;\n\n                status=GetOneCacheViewVirtualPixelInfo(pixel_view,(ssize_t)\n                  MagickRound(mean_location.x+u),(ssize_t) MagickRound(\n                  mean_location.y+v),&pixel,exception);\n                distance=(mean_pixel.red-pixel.red)*(mean_pixel.red-pixel.red)+\n                  (mean_pixel.green-pixel.green)*(mean_pixel.green-pixel.green)+\n                  (mean_pixel.blue-pixel.blue)*(mean_pixel.blue-pixel.blue);\n                if (distance <= (color_distance*color_distance))\n                  {\n                    sum_location.x+=mean_location.x+u;\n                    sum_location.y+=mean_location.y+v;\n                    sum_pixel.red+=pixel.red;\n                    sum_pixel.green+=pixel.green;\n                    sum_pixel.blue+=pixel.blue;\n                    sum_pixel.alpha+=pixel.alpha;\n                    count++;\n                  }\n              }\n          }\n        }\n        gamma=1.0/count;\n        mean_location.x=gamma*sum_location.x;\n        mean_location.y=gamma*sum_location.y;\n        mean_pixel.red=gamma*sum_pixel.red;\n        mean_pixel.green=gamma*sum_pixel.green;\n        mean_pixel.blue=gamma*sum_pixel.blue;\n        mean_pixel.alpha=gamma*sum_pixel.alpha;\n        distance=(mean_location.x-previous_location.x)*\n          (mean_location.x-previous_location.x)+\n          (mean_location.y-previous_location.y)*\n          (mean_location.y-previous_location.y)+\n          255.0*QuantumScale*(mean_pixel.red-previous_pixel.red)*\n          255.0*QuantumScale*(mean_pixel.red-previous_pixel.red)+\n          255.0*QuantumScale*(mean_pixel.green-previous_pixel.green)*\n          255.0*QuantumScale*(mean_pixel.green-previous_pixel.green)+\n          255.0*QuantumScale*(mean_pixel.blue-previous_pixel.blue)*\n          255.0*QuantumScale*(mean_pixel.blue-previous_pixel.blue);\n        if (distance <= 3.0)\n          break;\n      }\n      SetPixelRed(mean_image,ClampToQuantum(mean_pixel.red),q);\n      SetPixelGreen(mean_image,ClampToQuantum(mean_pixel.green),q);\n      SetPixelBlue(mean_image,ClampToQuantum(mean_pixel.blue),q);\n      SetPixelAlpha(mean_image,ClampToQuantum(mean_pixel.alpha),q);\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(mean_image);\n    }\n    if (SyncCacheViewAuthenticPixels(mean_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,MeanShiftImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  mean_view=DestroyCacheView(mean_view);\n  pixel_view=DestroyCacheView(pixel_view);\n  image_view=DestroyCacheView(image_view);\n  return(mean_image);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%               FFFFF  EEEEE   AAA   TTTTT  U   U  RRRR   EEEEE               %\n%               F      E      A   A    T    U   U  R   R  E                   %\n%               FFF    EEE    AAAAA    T    U   U  RRRR   EEE                 %\n%               F      E      A   A    T    U   U  R R    E                   %\n%               F      EEEEE  A   A    T     UUU   R  R   EEEEE               %\n%                                                                             %\n%                                                                             %\n%                      MagickCore Image Feature Methods                       %\n%                                                                             %\n%                              Software Design                                %\n%                                   Cristy                                    %\n%                                 July 1992                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/animate.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/blob-private.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/cache-private.h\"\n#include \"MagickCore/cache-view.h\"\n#include \"MagickCore/channel.h\"\n#include \"MagickCore/client.h\"\n#include \"MagickCore/color.h\"\n#include \"MagickCore/color-private.h\"\n#include \"MagickCore/colorspace.h\"\n#include \"MagickCore/colorspace-private.h\"\n#include \"MagickCore/composite.h\"\n#include \"MagickCore/composite-private.h\"\n#include \"MagickCore/compress.h\"\n#include \"MagickCore/constitute.h\"\n#include \"MagickCore/display.h\"\n#include \"MagickCore/draw.h\"\n#include \"MagickCore/enhance.h\"\n#include \"MagickCore/exception.h\"\n#include \"MagickCore/exception-private.h\"\n#include \"MagickCore/feature.h\"\n#include \"MagickCore/gem.h\"\n#include \"MagickCore/geometry.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/magic.h\"\n#include \"MagickCore/magick.h\"\n#include \"MagickCore/matrix.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/module.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/morphology-private.h\"\n#include \"MagickCore/option.h\"\n#include \"MagickCore/paint.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/profile.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantize.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/random_.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/segment.h\"\n#include \"MagickCore/semaphore.h\"\n#include \"MagickCore/signature-private.h\"\n#include \"MagickCore/string_.h\"\n#include \"MagickCore/thread-private.h\"\n#include \"MagickCore/timer.h\"\n#include \"MagickCore/utility.h\"\n#include \"MagickCore/version.h\"\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     C a n n y E d g e I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  CannyEdgeImage() uses a multi-stage algorithm to detect a wide range of\n%  edges in images.\n%\n%  The format of the CannyEdgeImage method is:\n%\n%      Image *CannyEdgeImage(const Image *image,const double radius,\n%        const double sigma,const double lower_percent,\n%        const double upper_percent,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o radius: the radius of the gaussian smoothing filter.\n%\n%    o sigma: the sigma of the gaussian smoothing filter.\n%\n%    o lower_percent: percentage of edge pixels in the lower threshold.\n%\n%    o upper_percent: percentage of edge pixels in the upper threshold.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\ntypedef struct _CannyInfo\n{\n  double\n    magnitude,\n    intensity;\n\n  int\n    orientation;\n\n  ssize_t\n    x,\n    y;\n} CannyInfo;\n\nstatic inline MagickBooleanType IsAuthenticPixel(const Image *image,\n  const ssize_t x,const ssize_t y)\n{\n  if ((x < 0) || (x >= (ssize_t) image->columns))\n    return(MagickFalse);\n  if ((y < 0) || (y >= (ssize_t) image->rows))\n    return(MagickFalse);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType TraceEdges(Image *edge_image,CacheView *edge_view,\n  MatrixInfo *canny_cache,const ssize_t x,const ssize_t y,\n  const double lower_threshold,ExceptionInfo *exception)\n{\n  CannyInfo\n    edge,\n    pixel;\n\n  MagickBooleanType\n    status;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i;\n\n  q=GetCacheViewAuthenticPixels(edge_view,x,y,1,1,exception);\n  if (q == (Quantum *) NULL)\n    return(MagickFalse);\n  *q=QuantumRange;\n  status=SyncCacheViewAuthenticPixels(edge_view,exception);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  if (GetMatrixElement(canny_cache,0,0,&edge) == MagickFalse)\n    return(MagickFalse);\n  edge.x=x;\n  edge.y=y;\n  if (SetMatrixElement(canny_cache,0,0,&edge) == MagickFalse)\n    return(MagickFalse);\n  for (i=1; i != 0; )\n  {\n    ssize_t\n      v;\n\n    i--;\n    status=GetMatrixElement(canny_cache,i,0,&edge);\n    if (status == MagickFalse)\n      return(MagickFalse);\n    for (v=(-1); v <= 1; v++)\n    {\n      ssize_t\n        u;\n\n      for (u=(-1); u <= 1; u++)\n      {\n        if ((u == 0) && (v == 0))\n          continue;\n        if (IsAuthenticPixel(edge_image,edge.x+u,edge.y+v) == MagickFalse)\n          continue;\n        /*\n          Not an edge if gradient value is below the lower threshold.\n        */\n        q=GetCacheViewAuthenticPixels(edge_view,edge.x+u,edge.y+v,1,1,\n          exception);\n        if (q == (Quantum *) NULL)\n          return(MagickFalse);\n        status=GetMatrixElement(canny_cache,edge.x+u,edge.y+v,&pixel);\n        if (status == MagickFalse)\n          return(MagickFalse);\n        if ((GetPixelIntensity(edge_image,q) == 0.0) &&\n            (pixel.intensity >= lower_threshold))\n          {\n            *q=QuantumRange;\n            status=SyncCacheViewAuthenticPixels(edge_view,exception);\n            if (status == MagickFalse)\n              return(MagickFalse);\n            edge.x+=u;\n            edge.y+=v;\n            status=SetMatrixElement(canny_cache,i,0,&edge);\n            if (status == MagickFalse)\n              return(MagickFalse);\n            i++;\n          }\n      }\n    }\n  }\n  return(MagickTrue);\n}\n\nMagickExport Image *CannyEdgeImage(const Image *image,const double radius,\n  const double sigma,const double lower_percent,const double upper_percent,\n  ExceptionInfo *exception)\n{\n#define CannyEdgeImageTag  \"CannyEdge/Image\"\n\n  CacheView\n    *edge_view;\n\n  CannyInfo\n    element;\n\n  char\n    geometry[MagickPathExtent];\n\n  double\n    lower_threshold,\n    max,\n    min,\n    upper_threshold;\n\n  Image\n    *edge_image;\n\n  KernelInfo\n    *kernel_info;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  MatrixInfo\n    *canny_cache;\n\n  ssize_t\n    y;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  /*\n    Filter out noise.\n  */\n  (void) FormatLocaleString(geometry,MagickPathExtent,\n    \"blur:%.20gx%.20g;blur:%.20gx%.20g+90\",radius,sigma,radius,sigma);\n  kernel_info=AcquireKernelInfo(geometry,exception);\n  if (kernel_info == (KernelInfo *) NULL)\n    ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n  edge_image=MorphologyImage(image,ConvolveMorphology,1,kernel_info,exception);\n  kernel_info=DestroyKernelInfo(kernel_info);\n  if (edge_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (TransformImageColorspace(edge_image,GRAYColorspace,exception) == MagickFalse)\n    {\n      edge_image=DestroyImage(edge_image);\n      return((Image *) NULL);\n    }\n  (void) SetImageAlphaChannel(edge_image,OffAlphaChannel,exception);\n  /*\n    Find the intensity gradient of the image.\n  */\n  canny_cache=AcquireMatrixInfo(edge_image->columns,edge_image->rows,\n    sizeof(CannyInfo),exception);\n  if (canny_cache == (MatrixInfo *) NULL)\n    {\n      edge_image=DestroyImage(edge_image);\n      return((Image *) NULL);\n    }\n  status=MagickTrue;\n  edge_view=AcquireVirtualCacheView(edge_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status) \\\n    magick_number_threads(edge_image,edge_image,edge_image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) edge_image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(edge_view,0,y,edge_image->columns+1,2,\n      exception);\n    if (p == (const Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) edge_image->columns; x++)\n    {\n      CannyInfo\n        pixel;\n\n      double\n        dx,\n        dy;\n\n      register const Quantum\n        *magick_restrict kernel_pixels;\n\n      ssize_t\n        v;\n\n      static double\n        Gx[2][2] =\n        {\n          { -1.0,  +1.0 },\n          { -1.0,  +1.0 }\n        },\n        Gy[2][2] =\n        {\n          { +1.0, +1.0 },\n          { -1.0, -1.0 }\n        };\n\n      (void) memset(&pixel,0,sizeof(pixel));\n      dx=0.0;\n      dy=0.0;\n      kernel_pixels=p;\n      for (v=0; v < 2; v++)\n      {\n        ssize_t\n          u;\n\n        for (u=0; u < 2; u++)\n        {\n          double\n            intensity;\n\n          intensity=GetPixelIntensity(edge_image,kernel_pixels+u);\n          dx+=0.5*Gx[v][u]*intensity;\n          dy+=0.5*Gy[v][u]*intensity;\n        }\n        kernel_pixels+=edge_image->columns+1;\n      }\n      pixel.magnitude=hypot(dx,dy);\n      pixel.orientation=0;\n      if (fabs(dx) > MagickEpsilon)\n        {\n          double\n            slope;\n\n          slope=dy/dx;\n          if (slope < 0.0)\n            {\n              if (slope < -2.41421356237)\n                pixel.orientation=0;\n              else\n                if (slope < -0.414213562373)\n                  pixel.orientation=1;\n                else\n                  pixel.orientation=2;\n            }\n          else\n            {\n              if (slope > 2.41421356237)\n                pixel.orientation=0;\n              else\n                if (slope > 0.414213562373)\n                  pixel.orientation=3;\n                else\n                  pixel.orientation=2;\n            }\n        }\n      if (SetMatrixElement(canny_cache,x,y,&pixel) == MagickFalse)\n        continue;\n      p+=GetPixelChannels(edge_image);\n    }\n  }\n  edge_view=DestroyCacheView(edge_view);\n  /*\n    Non-maxima suppression, remove pixels that are not considered to be part\n    of an edge.\n  */\n  progress=0;\n  (void) GetMatrixElement(canny_cache,0,0,&element);\n  max=element.intensity;\n  min=element.intensity;\n  edge_view=AcquireAuthenticCacheView(edge_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status) \\\n    magick_number_threads(edge_image,edge_image,edge_image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) edge_image->rows; y++)\n  {\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    q=GetCacheViewAuthenticPixels(edge_view,0,y,edge_image->columns,1,\n      exception);\n    if (q == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) edge_image->columns; x++)\n    {\n      CannyInfo\n        alpha_pixel,\n        beta_pixel,\n        pixel;\n\n      (void) GetMatrixElement(canny_cache,x,y,&pixel);\n      switch (pixel.orientation)\n      {\n        case 0:\n        default:\n        {\n          /*\n            0 degrees, north and south.\n          */\n          (void) GetMatrixElement(canny_cache,x,y-1,&alpha_pixel);\n          (void) GetMatrixElement(canny_cache,x,y+1,&beta_pixel);\n          break;\n        }\n        case 1:\n        {\n          /*\n            45 degrees, northwest and southeast.\n          */\n          (void) GetMatrixElement(canny_cache,x-1,y-1,&alpha_pixel);\n          (void) GetMatrixElement(canny_cache,x+1,y+1,&beta_pixel);\n          break;\n        }\n        case 2:\n        {\n          /*\n            90 degrees, east and west.\n          */\n          (void) GetMatrixElement(canny_cache,x-1,y,&alpha_pixel);\n          (void) GetMatrixElement(canny_cache,x+1,y,&beta_pixel);\n          break;\n        }\n        case 3:\n        {\n          /*\n            135 degrees, northeast and southwest.\n          */\n          (void) GetMatrixElement(canny_cache,x+1,y-1,&beta_pixel);\n          (void) GetMatrixElement(canny_cache,x-1,y+1,&alpha_pixel);\n          break;\n        }\n      }\n      pixel.intensity=pixel.magnitude;\n      if ((pixel.magnitude < alpha_pixel.magnitude) ||\n          (pixel.magnitude < beta_pixel.magnitude))\n        pixel.intensity=0;\n      (void) SetMatrixElement(canny_cache,x,y,&pixel);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n      #pragma omp critical (MagickCore_CannyEdgeImage)\n#endif\n      {\n        if (pixel.intensity < min)\n          min=pixel.intensity;\n        if (pixel.intensity > max)\n          max=pixel.intensity;\n      }\n      *q=0;\n      q+=GetPixelChannels(edge_image);\n    }\n    if (SyncCacheViewAuthenticPixels(edge_view,exception) == MagickFalse)\n      status=MagickFalse;\n  }\n  edge_view=DestroyCacheView(edge_view);\n  /*\n    Estimate hysteresis threshold.\n  */\n  lower_threshold=lower_percent*(max-min)+min;\n  upper_threshold=upper_percent*(max-min)+min;\n  /*\n    Hysteresis threshold.\n  */\n  edge_view=AcquireAuthenticCacheView(edge_image,exception);\n  for (y=0; y < (ssize_t) edge_image->rows; y++)\n  {\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    for (x=0; x < (ssize_t) edge_image->columns; x++)\n    {\n      CannyInfo\n        pixel;\n\n      register const Quantum\n        *magick_restrict p;\n\n      /*\n        Edge if pixel gradient higher than upper threshold.\n      */\n      p=GetCacheViewVirtualPixels(edge_view,x,y,1,1,exception);\n      if (p == (const Quantum *) NULL)\n        continue;\n      status=GetMatrixElement(canny_cache,x,y,&pixel);\n      if (status == MagickFalse)\n        continue;\n      if ((GetPixelIntensity(edge_image,p) == 0.0) &&\n          (pixel.intensity >= upper_threshold))\n        status=TraceEdges(edge_image,edge_view,canny_cache,x,y,lower_threshold,\n          exception);\n    }\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,CannyEdgeImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  edge_view=DestroyCacheView(edge_view);\n  /*\n    Free resources.\n  */\n  canny_cache=DestroyMatrixInfo(canny_cache);\n  return(edge_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%   G e t I m a g e F e a t u r e s                                           %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  GetImageFeatures() returns features for each channel in the image in\n%  each of four directions (horizontal, vertical, left and right diagonals)\n%  for the specified distance.  The features include the angular second\n%  moment, contrast, correlation, sum of squares: variance, inverse difference\n%  moment, sum average, sum varience, sum entropy, entropy, difference variance,%  difference entropy, information measures of correlation 1, information\n%  measures of correlation 2, and maximum correlation coefficient.  You can\n%  access the red channel contrast, for example, like this:\n%\n%      channel_features=GetImageFeatures(image,1,exception);\n%      contrast=channel_features[RedPixelChannel].contrast[0];\n%\n%  Use MagickRelinquishMemory() to free the features buffer.\n%\n%  The format of the GetImageFeatures method is:\n%\n%      ChannelFeatures *GetImageFeatures(const Image *image,\n%        const size_t distance,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o distance: the distance.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline double MagickLog10(const double x)\n{\n#define Log10Epsilon  (1.0e-11)\n\n if (fabs(x) < Log10Epsilon)\n   return(log10(Log10Epsilon));\n return(log10(fabs(x)));\n}\n\nMagickExport ChannelFeatures *GetImageFeatures(const Image *image,\n  const size_t distance,ExceptionInfo *exception)\n{\n  typedef struct _ChannelStatistics\n  {\n    PixelInfo\n      direction[4];  /* horizontal, vertical, left and right diagonals */\n  } ChannelStatistics;\n\n  CacheView\n    *image_view;\n\n  ChannelFeatures\n    *channel_features;\n\n  ChannelStatistics\n    **cooccurrence,\n    correlation,\n    *density_x,\n    *density_xy,\n    *density_y,\n    entropy_x,\n    entropy_xy,\n    entropy_xy1,\n    entropy_xy2,\n    entropy_y,\n    mean,\n    **Q,\n    *sum,\n    sum_squares,\n    variance;\n\n  PixelPacket\n    gray,\n    *grays;\n\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    i,\n    r;\n\n  size_t\n    length;\n\n  unsigned int\n    number_grays;\n\n  assert(image != (Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  if ((image->columns < (distance+1)) || (image->rows < (distance+1)))\n    return((ChannelFeatures *) NULL);\n  length=MaxPixelChannels+1UL;\n  channel_features=(ChannelFeatures *) AcquireQuantumMemory(length,\n    sizeof(*channel_features));\n  if (channel_features == (ChannelFeatures *) NULL)\n    ThrowFatalException(ResourceLimitFatalError,\"MemoryAllocationFailed\");\n  (void) memset(channel_features,0,length*\n    sizeof(*channel_features));\n  /*\n    Form grays.\n  */\n  grays=(PixelPacket *) AcquireQuantumMemory(MaxMap+1UL,sizeof(*grays));\n  if (grays == (PixelPacket *) NULL)\n    {\n      channel_features=(ChannelFeatures *) RelinquishMagickMemory(\n        channel_features);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(channel_features);\n    }\n  for (i=0; i <= (ssize_t) MaxMap; i++)\n  {\n    grays[i].red=(~0U);\n    grays[i].green=(~0U);\n    grays[i].blue=(~0U);\n    grays[i].alpha=(~0U);\n    grays[i].black=(~0U);\n  }\n  status=MagickTrue;\n  image_view=AcquireVirtualCacheView(image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status) \\\n    magick_number_threads(image,image,image->rows,1)\n#endif\n  for (r=0; r < (ssize_t) image->rows; r++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,r,image->columns,1,exception);\n    if (p == (const Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      grays[ScaleQuantumToMap(GetPixelRed(image,p))].red=\n        ScaleQuantumToMap(GetPixelRed(image,p));\n      grays[ScaleQuantumToMap(GetPixelGreen(image,p))].green=\n        ScaleQuantumToMap(GetPixelGreen(image,p));\n      grays[ScaleQuantumToMap(GetPixelBlue(image,p))].blue=\n        ScaleQuantumToMap(GetPixelBlue(image,p));\n      if (image->colorspace == CMYKColorspace)\n        grays[ScaleQuantumToMap(GetPixelBlack(image,p))].black=\n          ScaleQuantumToMap(GetPixelBlack(image,p));\n      if (image->alpha_trait != UndefinedPixelTrait)\n        grays[ScaleQuantumToMap(GetPixelAlpha(image,p))].alpha=\n          ScaleQuantumToMap(GetPixelAlpha(image,p));\n      p+=GetPixelChannels(image);\n    }\n  }\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    {\n      grays=(PixelPacket *) RelinquishMagickMemory(grays);\n      channel_features=(ChannelFeatures *) RelinquishMagickMemory(\n        channel_features);\n      return(channel_features);\n    }\n  (void) memset(&gray,0,sizeof(gray));\n  for (i=0; i <= (ssize_t) MaxMap; i++)\n  {\n    if (grays[i].red != ~0U)\n      grays[gray.red++].red=grays[i].red;\n    if (grays[i].green != ~0U)\n      grays[gray.green++].green=grays[i].green;\n    if (grays[i].blue != ~0U)\n      grays[gray.blue++].blue=grays[i].blue;\n    if (image->colorspace == CMYKColorspace)\n      if (grays[i].black != ~0U)\n        grays[gray.black++].black=grays[i].black;\n    if (image->alpha_trait != UndefinedPixelTrait)\n      if (grays[i].alpha != ~0U)\n        grays[gray.alpha++].alpha=grays[i].alpha;\n  }\n  /*\n    Allocate spatial dependence matrix.\n  */\n  number_grays=gray.red;\n  if (gray.green > number_grays)\n    number_grays=gray.green;\n  if (gray.blue > number_grays)\n    number_grays=gray.blue;\n  if (image->colorspace == CMYKColorspace)\n    if (gray.black > number_grays)\n      number_grays=gray.black;\n  if (image->alpha_trait != UndefinedPixelTrait)\n    if (gray.alpha > number_grays)\n      number_grays=gray.alpha;\n  cooccurrence=(ChannelStatistics **) AcquireQuantumMemory(number_grays,\n    sizeof(*cooccurrence));\n  density_x=(ChannelStatistics *) AcquireQuantumMemory(2*(number_grays+1),\n    sizeof(*density_x));\n  density_xy=(ChannelStatistics *) AcquireQuantumMemory(2*(number_grays+1),\n    sizeof(*density_xy));\n  density_y=(ChannelStatistics *) AcquireQuantumMemory(2*(number_grays+1),\n    sizeof(*density_y));\n  Q=(ChannelStatistics **) AcquireQuantumMemory(number_grays,sizeof(*Q));\n  sum=(ChannelStatistics *) AcquireQuantumMemory(number_grays,sizeof(*sum));\n  if ((cooccurrence == (ChannelStatistics **) NULL) ||\n      (density_x == (ChannelStatistics *) NULL) ||\n      (density_xy == (ChannelStatistics *) NULL) ||\n      (density_y == (ChannelStatistics *) NULL) ||\n      (Q == (ChannelStatistics **) NULL) ||\n      (sum == (ChannelStatistics *) NULL))\n    {\n      if (Q != (ChannelStatistics **) NULL)\n        {\n          for (i=0; i < (ssize_t) number_grays; i++)\n            Q[i]=(ChannelStatistics *) RelinquishMagickMemory(Q[i]);\n          Q=(ChannelStatistics **) RelinquishMagickMemory(Q);\n        }\n      if (sum != (ChannelStatistics *) NULL)\n        sum=(ChannelStatistics *) RelinquishMagickMemory(sum);\n      if (density_y != (ChannelStatistics *) NULL)\n        density_y=(ChannelStatistics *) RelinquishMagickMemory(density_y);\n      if (density_xy != (ChannelStatistics *) NULL)\n        density_xy=(ChannelStatistics *) RelinquishMagickMemory(density_xy);\n      if (density_x != (ChannelStatistics *) NULL)\n        density_x=(ChannelStatistics *) RelinquishMagickMemory(density_x);\n      if (cooccurrence != (ChannelStatistics **) NULL)\n        {\n          for (i=0; i < (ssize_t) number_grays; i++)\n            cooccurrence[i]=(ChannelStatistics *)\n              RelinquishMagickMemory(cooccurrence[i]);\n          cooccurrence=(ChannelStatistics **) RelinquishMagickMemory(\n            cooccurrence);\n        }\n      grays=(PixelPacket *) RelinquishMagickMemory(grays);\n      channel_features=(ChannelFeatures *) RelinquishMagickMemory(\n        channel_features);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(channel_features);\n    }\n  (void) memset(&correlation,0,sizeof(correlation));\n  (void) memset(density_x,0,2*(number_grays+1)*sizeof(*density_x));\n  (void) memset(density_xy,0,2*(number_grays+1)*sizeof(*density_xy));\n  (void) memset(density_y,0,2*(number_grays+1)*sizeof(*density_y));\n  (void) memset(&mean,0,sizeof(mean));\n  (void) memset(sum,0,number_grays*sizeof(*sum));\n  (void) memset(&sum_squares,0,sizeof(sum_squares));\n  (void) memset(density_xy,0,2*number_grays*sizeof(*density_xy));\n  (void) memset(&entropy_x,0,sizeof(entropy_x));\n  (void) memset(&entropy_xy,0,sizeof(entropy_xy));\n  (void) memset(&entropy_xy1,0,sizeof(entropy_xy1));\n  (void) memset(&entropy_xy2,0,sizeof(entropy_xy2));\n  (void) memset(&entropy_y,0,sizeof(entropy_y));\n  (void) memset(&variance,0,sizeof(variance));\n  for (i=0; i < (ssize_t) number_grays; i++)\n  {\n    cooccurrence[i]=(ChannelStatistics *) AcquireQuantumMemory(number_grays,\n      sizeof(**cooccurrence));\n    Q[i]=(ChannelStatistics *) AcquireQuantumMemory(number_grays,sizeof(**Q));\n    if ((cooccurrence[i] == (ChannelStatistics *) NULL) ||\n        (Q[i] == (ChannelStatistics *) NULL))\n      break;\n    (void) memset(cooccurrence[i],0,number_grays*\n      sizeof(**cooccurrence));\n    (void) memset(Q[i],0,number_grays*sizeof(**Q));\n  }\n  if (i < (ssize_t) number_grays)\n    {\n      for (i--; i >= 0; i--)\n      {\n        if (Q[i] != (ChannelStatistics *) NULL)\n          Q[i]=(ChannelStatistics *) RelinquishMagickMemory(Q[i]);\n        if (cooccurrence[i] != (ChannelStatistics *) NULL)\n          cooccurrence[i]=(ChannelStatistics *)\n            RelinquishMagickMemory(cooccurrence[i]);\n      }\n      Q=(ChannelStatistics **) RelinquishMagickMemory(Q);\n      cooccurrence=(ChannelStatistics **) RelinquishMagickMemory(cooccurrence);\n      sum=(ChannelStatistics *) RelinquishMagickMemory(sum);\n      density_y=(ChannelStatistics *) RelinquishMagickMemory(density_y);\n      density_xy=(ChannelStatistics *) RelinquishMagickMemory(density_xy);\n      density_x=(ChannelStatistics *) RelinquishMagickMemory(density_x);\n      grays=(PixelPacket *) RelinquishMagickMemory(grays);\n      channel_features=(ChannelFeatures *) RelinquishMagickMemory(\n        channel_features);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(channel_features);\n    }\n  /*\n    Initialize spatial dependence matrix.\n  */\n  status=MagickTrue;\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (r=0; r < (ssize_t) image->rows; r++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    ssize_t\n      offset,\n      u,\n      v;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,-(ssize_t) distance,r,image->columns+\n      2*distance,distance+2,exception);\n    if (p == (const Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    p+=distance*GetPixelChannels(image);;\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      for (i=0; i < 4; i++)\n      {\n        switch (i)\n        {\n          case 0:\n          default:\n          {\n            /*\n              Horizontal adjacency.\n            */\n            offset=(ssize_t) distance;\n            break;\n          }\n          case 1:\n          {\n            /*\n              Vertical adjacency.\n            */\n            offset=(ssize_t) (image->columns+2*distance);\n            break;\n          }\n          case 2:\n          {\n            /*\n              Right diagonal adjacency.\n            */\n            offset=(ssize_t) ((image->columns+2*distance)-distance);\n            break;\n          }\n          case 3:\n          {\n            /*\n              Left diagonal adjacency.\n            */\n            offset=(ssize_t) ((image->columns+2*distance)+distance);\n            break;\n          }\n        }\n        u=0;\n        v=0;\n        while (grays[u].red != ScaleQuantumToMap(GetPixelRed(image,p)))\n          u++;\n        while (grays[v].red != ScaleQuantumToMap(GetPixelRed(image,p+offset*GetPixelChannels(image))))\n          v++;\n        cooccurrence[u][v].direction[i].red++;\n        cooccurrence[v][u].direction[i].red++;\n        u=0;\n        v=0;\n        while (grays[u].green != ScaleQuantumToMap(GetPixelGreen(image,p)))\n          u++;\n        while (grays[v].green != ScaleQuantumToMap(GetPixelGreen(image,p+offset*GetPixelChannels(image))))\n          v++;\n        cooccurrence[u][v].direction[i].green++;\n        cooccurrence[v][u].direction[i].green++;\n        u=0;\n        v=0;\n        while (grays[u].blue != ScaleQuantumToMap(GetPixelBlue(image,p)))\n          u++;\n        while (grays[v].blue != ScaleQuantumToMap(GetPixelBlue(image,p+offset*GetPixelChannels(image))))\n          v++;\n        cooccurrence[u][v].direction[i].blue++;\n        cooccurrence[v][u].direction[i].blue++;\n        if (image->colorspace == CMYKColorspace)\n          {\n            u=0;\n            v=0;\n            while (grays[u].black != ScaleQuantumToMap(GetPixelBlack(image,p)))\n              u++;\n            while (grays[v].black != ScaleQuantumToMap(GetPixelBlack(image,p+offset*GetPixelChannels(image))))\n              v++;\n            cooccurrence[u][v].direction[i].black++;\n            cooccurrence[v][u].direction[i].black++;\n          }\n        if (image->alpha_trait != UndefinedPixelTrait)\n          {\n            u=0;\n            v=0;\n            while (grays[u].alpha != ScaleQuantumToMap(GetPixelAlpha(image,p)))\n              u++;\n            while (grays[v].alpha != ScaleQuantumToMap(GetPixelAlpha(image,p+offset*GetPixelChannels(image))))\n              v++;\n            cooccurrence[u][v].direction[i].alpha++;\n            cooccurrence[v][u].direction[i].alpha++;\n          }\n      }\n      p+=GetPixelChannels(image);\n    }\n  }\n  grays=(PixelPacket *) RelinquishMagickMemory(grays);\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    {\n      for (i=0; i < (ssize_t) number_grays; i++)\n        cooccurrence[i]=(ChannelStatistics *)\n          RelinquishMagickMemory(cooccurrence[i]);\n      cooccurrence=(ChannelStatistics **) RelinquishMagickMemory(cooccurrence);\n      channel_features=(ChannelFeatures *) RelinquishMagickMemory(\n        channel_features);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(channel_features);\n    }\n  /*\n    Normalize spatial dependence matrix.\n  */\n  for (i=0; i < 4; i++)\n  {\n    double\n      normalize;\n\n    register ssize_t\n      y;\n\n    switch (i)\n    {\n      case 0:\n      default:\n      {\n        /*\n          Horizontal adjacency.\n        */\n        normalize=2.0*image->rows*(image->columns-distance);\n        break;\n      }\n      case 1:\n      {\n        /*\n          Vertical adjacency.\n        */\n        normalize=2.0*(image->rows-distance)*image->columns;\n        break;\n      }\n      case 2:\n      {\n        /*\n          Right diagonal adjacency.\n        */\n        normalize=2.0*(image->rows-distance)*(image->columns-distance);\n        break;\n      }\n      case 3:\n      {\n        /*\n          Left diagonal adjacency.\n        */\n        normalize=2.0*(image->rows-distance)*(image->columns-distance);\n        break;\n      }\n    }\n    normalize=PerceptibleReciprocal(normalize);\n    for (y=0; y < (ssize_t) number_grays; y++)\n    {\n      register ssize_t\n        x;\n\n      for (x=0; x < (ssize_t) number_grays; x++)\n      {\n        cooccurrence[x][y].direction[i].red*=normalize;\n        cooccurrence[x][y].direction[i].green*=normalize;\n        cooccurrence[x][y].direction[i].blue*=normalize;\n        if (image->colorspace == CMYKColorspace)\n          cooccurrence[x][y].direction[i].black*=normalize;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          cooccurrence[x][y].direction[i].alpha*=normalize;\n      }\n    }\n  }\n  /*\n    Compute texture features.\n  */\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status) \\\n    magick_number_threads(image,image,number_grays,1)\n#endif\n  for (i=0; i < 4; i++)\n  {\n    register ssize_t\n      y;\n\n    for (y=0; y < (ssize_t) number_grays; y++)\n    {\n      register ssize_t\n        x;\n\n      for (x=0; x < (ssize_t) number_grays; x++)\n      {\n        /*\n          Angular second moment:  measure of homogeneity of the image.\n        */\n        channel_features[RedPixelChannel].angular_second_moment[i]+=\n          cooccurrence[x][y].direction[i].red*\n          cooccurrence[x][y].direction[i].red;\n        channel_features[GreenPixelChannel].angular_second_moment[i]+=\n          cooccurrence[x][y].direction[i].green*\n          cooccurrence[x][y].direction[i].green;\n        channel_features[BluePixelChannel].angular_second_moment[i]+=\n          cooccurrence[x][y].direction[i].blue*\n          cooccurrence[x][y].direction[i].blue;\n        if (image->colorspace == CMYKColorspace)\n          channel_features[BlackPixelChannel].angular_second_moment[i]+=\n            cooccurrence[x][y].direction[i].black*\n            cooccurrence[x][y].direction[i].black;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          channel_features[AlphaPixelChannel].angular_second_moment[i]+=\n            cooccurrence[x][y].direction[i].alpha*\n            cooccurrence[x][y].direction[i].alpha;\n        /*\n          Correlation: measure of linear-dependencies in the image.\n        */\n        sum[y].direction[i].red+=cooccurrence[x][y].direction[i].red;\n        sum[y].direction[i].green+=cooccurrence[x][y].direction[i].green;\n        sum[y].direction[i].blue+=cooccurrence[x][y].direction[i].blue;\n        if (image->colorspace == CMYKColorspace)\n          sum[y].direction[i].black+=cooccurrence[x][y].direction[i].black;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          sum[y].direction[i].alpha+=cooccurrence[x][y].direction[i].alpha;\n        correlation.direction[i].red+=x*y*cooccurrence[x][y].direction[i].red;\n        correlation.direction[i].green+=x*y*\n          cooccurrence[x][y].direction[i].green;\n        correlation.direction[i].blue+=x*y*\n          cooccurrence[x][y].direction[i].blue;\n        if (image->colorspace == CMYKColorspace)\n          correlation.direction[i].black+=x*y*\n            cooccurrence[x][y].direction[i].black;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          correlation.direction[i].alpha+=x*y*\n            cooccurrence[x][y].direction[i].alpha;\n        /*\n          Inverse Difference Moment.\n        */\n        channel_features[RedPixelChannel].inverse_difference_moment[i]+=\n          cooccurrence[x][y].direction[i].red/((y-x)*(y-x)+1);\n        channel_features[GreenPixelChannel].inverse_difference_moment[i]+=\n          cooccurrence[x][y].direction[i].green/((y-x)*(y-x)+1);\n        channel_features[BluePixelChannel].inverse_difference_moment[i]+=\n          cooccurrence[x][y].direction[i].blue/((y-x)*(y-x)+1);\n        if (image->colorspace == CMYKColorspace)\n          channel_features[BlackPixelChannel].inverse_difference_moment[i]+=\n            cooccurrence[x][y].direction[i].black/((y-x)*(y-x)+1);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          channel_features[AlphaPixelChannel].inverse_difference_moment[i]+=\n            cooccurrence[x][y].direction[i].alpha/((y-x)*(y-x)+1);\n        /*\n          Sum average.\n        */\n        density_xy[y+x+2].direction[i].red+=\n          cooccurrence[x][y].direction[i].red;\n        density_xy[y+x+2].direction[i].green+=\n          cooccurrence[x][y].direction[i].green;\n        density_xy[y+x+2].direction[i].blue+=\n          cooccurrence[x][y].direction[i].blue;\n        if (image->colorspace == CMYKColorspace)\n          density_xy[y+x+2].direction[i].black+=\n            cooccurrence[x][y].direction[i].black;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          density_xy[y+x+2].direction[i].alpha+=\n            cooccurrence[x][y].direction[i].alpha;\n        /*\n          Entropy.\n        */\n        channel_features[RedPixelChannel].entropy[i]-=\n          cooccurrence[x][y].direction[i].red*\n          MagickLog10(cooccurrence[x][y].direction[i].red);\n        channel_features[GreenPixelChannel].entropy[i]-=\n          cooccurrence[x][y].direction[i].green*\n          MagickLog10(cooccurrence[x][y].direction[i].green);\n        channel_features[BluePixelChannel].entropy[i]-=\n          cooccurrence[x][y].direction[i].blue*\n          MagickLog10(cooccurrence[x][y].direction[i].blue);\n        if (image->colorspace == CMYKColorspace)\n          channel_features[BlackPixelChannel].entropy[i]-=\n            cooccurrence[x][y].direction[i].black*\n            MagickLog10(cooccurrence[x][y].direction[i].black);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          channel_features[AlphaPixelChannel].entropy[i]-=\n            cooccurrence[x][y].direction[i].alpha*\n            MagickLog10(cooccurrence[x][y].direction[i].alpha);\n        /*\n          Information Measures of Correlation.\n        */\n        density_x[x].direction[i].red+=cooccurrence[x][y].direction[i].red;\n        density_x[x].direction[i].green+=cooccurrence[x][y].direction[i].green;\n        density_x[x].direction[i].blue+=cooccurrence[x][y].direction[i].blue;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          density_x[x].direction[i].alpha+=\n            cooccurrence[x][y].direction[i].alpha;\n        if (image->colorspace == CMYKColorspace)\n          density_x[x].direction[i].black+=\n            cooccurrence[x][y].direction[i].black;\n        density_y[y].direction[i].red+=cooccurrence[x][y].direction[i].red;\n        density_y[y].direction[i].green+=cooccurrence[x][y].direction[i].green;\n        density_y[y].direction[i].blue+=cooccurrence[x][y].direction[i].blue;\n        if (image->colorspace == CMYKColorspace)\n          density_y[y].direction[i].black+=\n            cooccurrence[x][y].direction[i].black;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          density_y[y].direction[i].alpha+=\n            cooccurrence[x][y].direction[i].alpha;\n      }\n      mean.direction[i].red+=y*sum[y].direction[i].red;\n      sum_squares.direction[i].red+=y*y*sum[y].direction[i].red;\n      mean.direction[i].green+=y*sum[y].direction[i].green;\n      sum_squares.direction[i].green+=y*y*sum[y].direction[i].green;\n      mean.direction[i].blue+=y*sum[y].direction[i].blue;\n      sum_squares.direction[i].blue+=y*y*sum[y].direction[i].blue;\n      if (image->colorspace == CMYKColorspace)\n        {\n          mean.direction[i].black+=y*sum[y].direction[i].black;\n          sum_squares.direction[i].black+=y*y*sum[y].direction[i].black;\n        }\n      if (image->alpha_trait != UndefinedPixelTrait)\n        {\n          mean.direction[i].alpha+=y*sum[y].direction[i].alpha;\n          sum_squares.direction[i].alpha+=y*y*sum[y].direction[i].alpha;\n        }\n    }\n    /*\n      Correlation: measure of linear-dependencies in the image.\n    */\n    channel_features[RedPixelChannel].correlation[i]=\n      (correlation.direction[i].red-mean.direction[i].red*\n      mean.direction[i].red)/(sqrt(sum_squares.direction[i].red-\n      (mean.direction[i].red*mean.direction[i].red))*sqrt(\n      sum_squares.direction[i].red-(mean.direction[i].red*\n      mean.direction[i].red)));\n    channel_features[GreenPixelChannel].correlation[i]=\n      (correlation.direction[i].green-mean.direction[i].green*\n      mean.direction[i].green)/(sqrt(sum_squares.direction[i].green-\n      (mean.direction[i].green*mean.direction[i].green))*sqrt(\n      sum_squares.direction[i].green-(mean.direction[i].green*\n      mean.direction[i].green)));\n    channel_features[BluePixelChannel].correlation[i]=\n      (correlation.direction[i].blue-mean.direction[i].blue*\n      mean.direction[i].blue)/(sqrt(sum_squares.direction[i].blue-\n      (mean.direction[i].blue*mean.direction[i].blue))*sqrt(\n      sum_squares.direction[i].blue-(mean.direction[i].blue*\n      mean.direction[i].blue)));\n    if (image->colorspace == CMYKColorspace)\n      channel_features[BlackPixelChannel].correlation[i]=\n        (correlation.direction[i].black-mean.direction[i].black*\n        mean.direction[i].black)/(sqrt(sum_squares.direction[i].black-\n        (mean.direction[i].black*mean.direction[i].black))*sqrt(\n        sum_squares.direction[i].black-(mean.direction[i].black*\n        mean.direction[i].black)));\n    if (image->alpha_trait != UndefinedPixelTrait)\n      channel_features[AlphaPixelChannel].correlation[i]=\n        (correlation.direction[i].alpha-mean.direction[i].alpha*\n        mean.direction[i].alpha)/(sqrt(sum_squares.direction[i].alpha-\n        (mean.direction[i].alpha*mean.direction[i].alpha))*sqrt(\n        sum_squares.direction[i].alpha-(mean.direction[i].alpha*\n        mean.direction[i].alpha)));\n  }\n  /*\n    Compute more texture features.\n  */\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status) \\\n    magick_number_threads(image,image,number_grays,1)\n#endif\n  for (i=0; i < 4; i++)\n  {\n    register ssize_t\n      x;\n\n    for (x=2; x < (ssize_t) (2*number_grays); x++)\n    {\n      /*\n        Sum average.\n      */\n      channel_features[RedPixelChannel].sum_average[i]+=\n        x*density_xy[x].direction[i].red;\n      channel_features[GreenPixelChannel].sum_average[i]+=\n        x*density_xy[x].direction[i].green;\n      channel_features[BluePixelChannel].sum_average[i]+=\n        x*density_xy[x].direction[i].blue;\n      if (image->colorspace == CMYKColorspace)\n        channel_features[BlackPixelChannel].sum_average[i]+=\n          x*density_xy[x].direction[i].black;\n      if (image->alpha_trait != UndefinedPixelTrait)\n        channel_features[AlphaPixelChannel].sum_average[i]+=\n          x*density_xy[x].direction[i].alpha;\n      /*\n        Sum entropy.\n      */\n      channel_features[RedPixelChannel].sum_entropy[i]-=\n        density_xy[x].direction[i].red*\n        MagickLog10(density_xy[x].direction[i].red);\n      channel_features[GreenPixelChannel].sum_entropy[i]-=\n        density_xy[x].direction[i].green*\n        MagickLog10(density_xy[x].direction[i].green);\n      channel_features[BluePixelChannel].sum_entropy[i]-=\n        density_xy[x].direction[i].blue*\n        MagickLog10(density_xy[x].direction[i].blue);\n      if (image->colorspace == CMYKColorspace)\n        channel_features[BlackPixelChannel].sum_entropy[i]-=\n          density_xy[x].direction[i].black*\n          MagickLog10(density_xy[x].direction[i].black);\n      if (image->alpha_trait != UndefinedPixelTrait)\n        channel_features[AlphaPixelChannel].sum_entropy[i]-=\n          density_xy[x].direction[i].alpha*\n          MagickLog10(density_xy[x].direction[i].alpha);\n      /*\n        Sum variance.\n      */\n      channel_features[RedPixelChannel].sum_variance[i]+=\n        (x-channel_features[RedPixelChannel].sum_entropy[i])*\n        (x-channel_features[RedPixelChannel].sum_entropy[i])*\n        density_xy[x].direction[i].red;\n      channel_features[GreenPixelChannel].sum_variance[i]+=\n        (x-channel_features[GreenPixelChannel].sum_entropy[i])*\n        (x-channel_features[GreenPixelChannel].sum_entropy[i])*\n        density_xy[x].direction[i].green;\n      channel_features[BluePixelChannel].sum_variance[i]+=\n        (x-channel_features[BluePixelChannel].sum_entropy[i])*\n        (x-channel_features[BluePixelChannel].sum_entropy[i])*\n        density_xy[x].direction[i].blue;\n      if (image->colorspace == CMYKColorspace)\n        channel_features[BlackPixelChannel].sum_variance[i]+=\n          (x-channel_features[BlackPixelChannel].sum_entropy[i])*\n          (x-channel_features[BlackPixelChannel].sum_entropy[i])*\n          density_xy[x].direction[i].black;\n      if (image->alpha_trait != UndefinedPixelTrait)\n        channel_features[AlphaPixelChannel].sum_variance[i]+=\n          (x-channel_features[AlphaPixelChannel].sum_entropy[i])*\n          (x-channel_features[AlphaPixelChannel].sum_entropy[i])*\n          density_xy[x].direction[i].alpha;\n    }\n  }\n  /*\n    Compute more texture features.\n  */\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status) \\\n    magick_number_threads(image,image,number_grays,1)\n#endif\n  for (i=0; i < 4; i++)\n  {\n    register ssize_t\n      y;\n\n    for (y=0; y < (ssize_t) number_grays; y++)\n    {\n      register ssize_t\n        x;\n\n      for (x=0; x < (ssize_t) number_grays; x++)\n      {\n        /*\n          Sum of Squares: Variance\n        */\n        variance.direction[i].red+=(y-mean.direction[i].red+1)*\n          (y-mean.direction[i].red+1)*cooccurrence[x][y].direction[i].red;\n        variance.direction[i].green+=(y-mean.direction[i].green+1)*\n          (y-mean.direction[i].green+1)*cooccurrence[x][y].direction[i].green;\n        variance.direction[i].blue+=(y-mean.direction[i].blue+1)*\n          (y-mean.direction[i].blue+1)*cooccurrence[x][y].direction[i].blue;\n        if (image->colorspace == CMYKColorspace)\n          variance.direction[i].black+=(y-mean.direction[i].black+1)*\n            (y-mean.direction[i].black+1)*cooccurrence[x][y].direction[i].black;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          variance.direction[i].alpha+=(y-mean.direction[i].alpha+1)*\n            (y-mean.direction[i].alpha+1)*\n            cooccurrence[x][y].direction[i].alpha;\n        /*\n          Sum average / Difference Variance.\n        */\n        density_xy[MagickAbsoluteValue(y-x)].direction[i].red+=\n          cooccurrence[x][y].direction[i].red;\n        density_xy[MagickAbsoluteValue(y-x)].direction[i].green+=\n          cooccurrence[x][y].direction[i].green;\n        density_xy[MagickAbsoluteValue(y-x)].direction[i].blue+=\n          cooccurrence[x][y].direction[i].blue;\n        if (image->colorspace == CMYKColorspace)\n          density_xy[MagickAbsoluteValue(y-x)].direction[i].black+=\n            cooccurrence[x][y].direction[i].black;\n        if (image->alpha_trait != UndefinedPixelTrait)\n          density_xy[MagickAbsoluteValue(y-x)].direction[i].alpha+=\n            cooccurrence[x][y].direction[i].alpha;\n        /*\n          Information Measures of Correlation.\n        */\n        entropy_xy.direction[i].red-=cooccurrence[x][y].direction[i].red*\n          MagickLog10(cooccurrence[x][y].direction[i].red);\n        entropy_xy.direction[i].green-=cooccurrence[x][y].direction[i].green*\n          MagickLog10(cooccurrence[x][y].direction[i].green);\n        entropy_xy.direction[i].blue-=cooccurrence[x][y].direction[i].blue*\n          MagickLog10(cooccurrence[x][y].direction[i].blue);\n        if (image->colorspace == CMYKColorspace)\n          entropy_xy.direction[i].black-=cooccurrence[x][y].direction[i].black*\n            MagickLog10(cooccurrence[x][y].direction[i].black);\n        if (image->alpha_trait != UndefinedPixelTrait)\n          entropy_xy.direction[i].alpha-=\n            cooccurrence[x][y].direction[i].alpha*MagickLog10(\n            cooccurrence[x][y].direction[i].alpha);\n        entropy_xy1.direction[i].red-=(cooccurrence[x][y].direction[i].red*\n          MagickLog10(density_x[x].direction[i].red*density_y[y].direction[i].red));\n        entropy_xy1.direction[i].green-=(cooccurrence[x][y].direction[i].green*\n          MagickLog10(density_x[x].direction[i].green*\n          density_y[y].direction[i].green));\n        entropy_xy1.direction[i].blue-=(cooccurrence[x][y].direction[i].blue*\n          MagickLog10(density_x[x].direction[i].blue*density_y[y].direction[i].blue));\n        if (image->colorspace == CMYKColorspace)\n          entropy_xy1.direction[i].black-=(\n            cooccurrence[x][y].direction[i].black*MagickLog10(\n            density_x[x].direction[i].black*density_y[y].direction[i].black));\n        if (image->alpha_trait != UndefinedPixelTrait)\n          entropy_xy1.direction[i].alpha-=(\n            cooccurrence[x][y].direction[i].alpha*MagickLog10(\n            density_x[x].direction[i].alpha*density_y[y].direction[i].alpha));\n        entropy_xy2.direction[i].red-=(density_x[x].direction[i].red*\n          density_y[y].direction[i].red*MagickLog10(density_x[x].direction[i].red*\n          density_y[y].direction[i].red));\n        entropy_xy2.direction[i].green-=(density_x[x].direction[i].green*\n          density_y[y].direction[i].green*MagickLog10(density_x[x].direction[i].green*\n          density_y[y].direction[i].green));\n        entropy_xy2.direction[i].blue-=(density_x[x].direction[i].blue*\n          density_y[y].direction[i].blue*MagickLog10(density_x[x].direction[i].blue*\n          density_y[y].direction[i].blue));\n        if (image->colorspace == CMYKColorspace)\n          entropy_xy2.direction[i].black-=(density_x[x].direction[i].black*\n            density_y[y].direction[i].black*MagickLog10(\n            density_x[x].direction[i].black*density_y[y].direction[i].black));\n        if (image->alpha_trait != UndefinedPixelTrait)\n          entropy_xy2.direction[i].alpha-=(density_x[x].direction[i].alpha*\n            density_y[y].direction[i].alpha*MagickLog10(\n            density_x[x].direction[i].alpha*density_y[y].direction[i].alpha));\n      }\n    }\n    channel_features[RedPixelChannel].variance_sum_of_squares[i]=\n      variance.direction[i].red;\n    channel_features[GreenPixelChannel].variance_sum_of_squares[i]=\n      variance.direction[i].green;\n    channel_features[BluePixelChannel].variance_sum_of_squares[i]=\n      variance.direction[i].blue;\n    if (image->colorspace == CMYKColorspace)\n      channel_features[BlackPixelChannel].variance_sum_of_squares[i]=\n        variance.direction[i].black;\n    if (image->alpha_trait != UndefinedPixelTrait)\n      channel_features[AlphaPixelChannel].variance_sum_of_squares[i]=\n        variance.direction[i].alpha;\n  }\n  /*\n    Compute more texture features.\n  */\n  (void) memset(&variance,0,sizeof(variance));\n  (void) memset(&sum_squares,0,sizeof(sum_squares));\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status) \\\n    magick_number_threads(image,image,number_grays,1)\n#endif\n  for (i=0; i < 4; i++)\n  {\n    register ssize_t\n      x;\n\n    for (x=0; x < (ssize_t) number_grays; x++)\n    {\n      /*\n        Difference variance.\n      */\n      variance.direction[i].red+=density_xy[x].direction[i].red;\n      variance.direction[i].green+=density_xy[x].direction[i].green;\n      variance.direction[i].blue+=density_xy[x].direction[i].blue;\n      if (image->colorspace == CMYKColorspace)\n        variance.direction[i].black+=density_xy[x].direction[i].black;\n      if (image->alpha_trait != UndefinedPixelTrait)\n        variance.direction[i].alpha+=density_xy[x].direction[i].alpha;\n      sum_squares.direction[i].red+=density_xy[x].direction[i].red*\n        density_xy[x].direction[i].red;\n      sum_squares.direction[i].green+=density_xy[x].direction[i].green*\n        density_xy[x].direction[i].green;\n      sum_squares.direction[i].blue+=density_xy[x].direction[i].blue*\n        density_xy[x].direction[i].blue;\n      if (image->colorspace == CMYKColorspace)\n        sum_squares.direction[i].black+=density_xy[x].direction[i].black*\n          density_xy[x].direction[i].black;\n      if (image->alpha_trait != UndefinedPixelTrait)\n        sum_squares.direction[i].alpha+=density_xy[x].direction[i].alpha*\n          density_xy[x].direction[i].alpha;\n      /*\n        Difference entropy.\n      */\n      channel_features[RedPixelChannel].difference_entropy[i]-=\n        density_xy[x].direction[i].red*\n        MagickLog10(density_xy[x].direction[i].red);\n      channel_features[GreenPixelChannel].difference_entropy[i]-=\n        density_xy[x].direction[i].green*\n        MagickLog10(density_xy[x].direction[i].green);\n      channel_features[BluePixelChannel].difference_entropy[i]-=\n        density_xy[x].direction[i].blue*\n        MagickLog10(density_xy[x].direction[i].blue);\n      if (image->colorspace == CMYKColorspace)\n        channel_features[BlackPixelChannel].difference_entropy[i]-=\n          density_xy[x].direction[i].black*\n          MagickLog10(density_xy[x].direction[i].black);\n      if (image->alpha_trait != UndefinedPixelTrait)\n        channel_features[AlphaPixelChannel].difference_entropy[i]-=\n          density_xy[x].direction[i].alpha*\n          MagickLog10(density_xy[x].direction[i].alpha);\n      /*\n        Information Measures of Correlation.\n      */\n      entropy_x.direction[i].red-=(density_x[x].direction[i].red*\n        MagickLog10(density_x[x].direction[i].red));\n      entropy_x.direction[i].green-=(density_x[x].direction[i].green*\n        MagickLog10(density_x[x].direction[i].green));\n      entropy_x.direction[i].blue-=(density_x[x].direction[i].blue*\n        MagickLog10(density_x[x].direction[i].blue));\n      if (image->colorspace == CMYKColorspace)\n        entropy_x.direction[i].black-=(density_x[x].direction[i].black*\n          MagickLog10(density_x[x].direction[i].black));\n      if (image->alpha_trait != UndefinedPixelTrait)\n        entropy_x.direction[i].alpha-=(density_x[x].direction[i].alpha*\n          MagickLog10(density_x[x].direction[i].alpha));\n      entropy_y.direction[i].red-=(density_y[x].direction[i].red*\n        MagickLog10(density_y[x].direction[i].red));\n      entropy_y.direction[i].green-=(density_y[x].direction[i].green*\n        MagickLog10(density_y[x].direction[i].green));\n      entropy_y.direction[i].blue-=(density_y[x].direction[i].blue*\n        MagickLog10(density_y[x].direction[i].blue));\n      if (image->colorspace == CMYKColorspace)\n        entropy_y.direction[i].black-=(density_y[x].direction[i].black*\n          MagickLog10(density_y[x].direction[i].black));\n      if (image->alpha_trait != UndefinedPixelTrait)\n        entropy_y.direction[i].alpha-=(density_y[x].direction[i].alpha*\n          MagickLog10(density_y[x].direction[i].alpha));\n    }\n    /*\n      Difference variance.\n    */\n    channel_features[RedPixelChannel].difference_variance[i]=\n      (((double) number_grays*number_grays*sum_squares.direction[i].red)-\n      (variance.direction[i].red*variance.direction[i].red))/\n      ((double) number_grays*number_grays*number_grays*number_grays);\n    channel_features[GreenPixelChannel].difference_variance[i]=\n      (((double) number_grays*number_grays*sum_squares.direction[i].green)-\n      (variance.direction[i].green*variance.direction[i].green))/\n      ((double) number_grays*number_grays*number_grays*number_grays);\n    channel_features[BluePixelChannel].difference_variance[i]=\n      (((double) number_grays*number_grays*sum_squares.direction[i].blue)-\n      (variance.direction[i].blue*variance.direction[i].blue))/\n      ((double) number_grays*number_grays*number_grays*number_grays);\n    if (image->colorspace == CMYKColorspace)\n      channel_features[BlackPixelChannel].difference_variance[i]=\n        (((double) number_grays*number_grays*sum_squares.direction[i].black)-\n        (variance.direction[i].black*variance.direction[i].black))/\n        ((double) number_grays*number_grays*number_grays*number_grays);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      channel_features[AlphaPixelChannel].difference_variance[i]=\n        (((double) number_grays*number_grays*sum_squares.direction[i].alpha)-\n        (variance.direction[i].alpha*variance.direction[i].alpha))/\n        ((double) number_grays*number_grays*number_grays*number_grays);\n    /*\n      Information Measures of Correlation.\n    */\n    channel_features[RedPixelChannel].measure_of_correlation_1[i]=\n      (entropy_xy.direction[i].red-entropy_xy1.direction[i].red)/\n      (entropy_x.direction[i].red > entropy_y.direction[i].red ?\n       entropy_x.direction[i].red : entropy_y.direction[i].red);\n    channel_features[GreenPixelChannel].measure_of_correlation_1[i]=\n      (entropy_xy.direction[i].green-entropy_xy1.direction[i].green)/\n      (entropy_x.direction[i].green > entropy_y.direction[i].green ?\n       entropy_x.direction[i].green : entropy_y.direction[i].green);\n    channel_features[BluePixelChannel].measure_of_correlation_1[i]=\n      (entropy_xy.direction[i].blue-entropy_xy1.direction[i].blue)/\n      (entropy_x.direction[i].blue > entropy_y.direction[i].blue ?\n       entropy_x.direction[i].blue : entropy_y.direction[i].blue);\n    if (image->colorspace == CMYKColorspace)\n      channel_features[BlackPixelChannel].measure_of_correlation_1[i]=\n        (entropy_xy.direction[i].black-entropy_xy1.direction[i].black)/\n        (entropy_x.direction[i].black > entropy_y.direction[i].black ?\n         entropy_x.direction[i].black : entropy_y.direction[i].black);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      channel_features[AlphaPixelChannel].measure_of_correlation_1[i]=\n        (entropy_xy.direction[i].alpha-entropy_xy1.direction[i].alpha)/\n        (entropy_x.direction[i].alpha > entropy_y.direction[i].alpha ?\n         entropy_x.direction[i].alpha : entropy_y.direction[i].alpha);\n    channel_features[RedPixelChannel].measure_of_correlation_2[i]=\n      (sqrt(fabs(1.0-exp(-2.0*(double) (entropy_xy2.direction[i].red-\n      entropy_xy.direction[i].red)))));\n    channel_features[GreenPixelChannel].measure_of_correlation_2[i]=\n      (sqrt(fabs(1.0-exp(-2.0*(double) (entropy_xy2.direction[i].green-\n      entropy_xy.direction[i].green)))));\n    channel_features[BluePixelChannel].measure_of_correlation_2[i]=\n      (sqrt(fabs(1.0-exp(-2.0*(double) (entropy_xy2.direction[i].blue-\n      entropy_xy.direction[i].blue)))));\n    if (image->colorspace == CMYKColorspace)\n      channel_features[BlackPixelChannel].measure_of_correlation_2[i]=\n        (sqrt(fabs(1.0-exp(-2.0*(double) (entropy_xy2.direction[i].black-\n        entropy_xy.direction[i].black)))));\n    if (image->alpha_trait != UndefinedPixelTrait)\n      channel_features[AlphaPixelChannel].measure_of_correlation_2[i]=\n        (sqrt(fabs(1.0-exp(-2.0*(double) (entropy_xy2.direction[i].alpha-\n        entropy_xy.direction[i].alpha)))));\n  }\n  /*\n    Compute more texture features.\n  */\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status) \\\n    magick_number_threads(image,image,number_grays,1)\n#endif\n  for (i=0; i < 4; i++)\n  {\n    ssize_t\n      z;\n\n    for (z=0; z < (ssize_t) number_grays; z++)\n    {\n      register ssize_t\n        y;\n\n      ChannelStatistics\n        pixel;\n\n      (void) memset(&pixel,0,sizeof(pixel));\n      for (y=0; y < (ssize_t) number_grays; y++)\n      {\n        register ssize_t\n          x;\n\n        for (x=0; x < (ssize_t) number_grays; x++)\n        {\n          /*\n            Contrast:  amount of local variations present in an image.\n          */\n          if (((y-x) == z) || ((x-y) == z))\n            {\n              pixel.direction[i].red+=cooccurrence[x][y].direction[i].red;\n              pixel.direction[i].green+=cooccurrence[x][y].direction[i].green;\n              pixel.direction[i].blue+=cooccurrence[x][y].direction[i].blue;\n              if (image->colorspace == CMYKColorspace)\n                pixel.direction[i].black+=cooccurrence[x][y].direction[i].black;\n              if (image->alpha_trait != UndefinedPixelTrait)\n                pixel.direction[i].alpha+=\n                  cooccurrence[x][y].direction[i].alpha;\n            }\n          /*\n            Maximum Correlation Coefficient.\n          */\n          Q[z][y].direction[i].red+=cooccurrence[z][x].direction[i].red*\n            cooccurrence[y][x].direction[i].red/density_x[z].direction[i].red/\n            density_y[x].direction[i].red;\n          Q[z][y].direction[i].green+=cooccurrence[z][x].direction[i].green*\n            cooccurrence[y][x].direction[i].green/\n            density_x[z].direction[i].green/density_y[x].direction[i].red;\n          Q[z][y].direction[i].blue+=cooccurrence[z][x].direction[i].blue*\n            cooccurrence[y][x].direction[i].blue/density_x[z].direction[i].blue/\n            density_y[x].direction[i].blue;\n          if (image->colorspace == CMYKColorspace)\n            Q[z][y].direction[i].black+=cooccurrence[z][x].direction[i].black*\n              cooccurrence[y][x].direction[i].black/\n              density_x[z].direction[i].black/density_y[x].direction[i].black;\n          if (image->alpha_trait != UndefinedPixelTrait)\n            Q[z][y].direction[i].alpha+=\n              cooccurrence[z][x].direction[i].alpha*\n              cooccurrence[y][x].direction[i].alpha/\n              density_x[z].direction[i].alpha/\n              density_y[x].direction[i].alpha;\n        }\n      }\n      channel_features[RedPixelChannel].contrast[i]+=z*z*\n        pixel.direction[i].red;\n      channel_features[GreenPixelChannel].contrast[i]+=z*z*\n        pixel.direction[i].green;\n      channel_features[BluePixelChannel].contrast[i]+=z*z*\n        pixel.direction[i].blue;\n      if (image->colorspace == CMYKColorspace)\n        channel_features[BlackPixelChannel].contrast[i]+=z*z*\n          pixel.direction[i].black;\n      if (image->alpha_trait != UndefinedPixelTrait)\n        channel_features[AlphaPixelChannel].contrast[i]+=z*z*\n          pixel.direction[i].alpha;\n    }\n    /*\n      Maximum Correlation Coefficient.\n      Future: return second largest eigenvalue of Q.\n    */\n    channel_features[RedPixelChannel].maximum_correlation_coefficient[i]=\n      sqrt((double) -1.0);\n    channel_features[GreenPixelChannel].maximum_correlation_coefficient[i]=\n      sqrt((double) -1.0);\n    channel_features[BluePixelChannel].maximum_correlation_coefficient[i]=\n      sqrt((double) -1.0);\n    if (image->colorspace == CMYKColorspace)\n      channel_features[BlackPixelChannel].maximum_correlation_coefficient[i]=\n        sqrt((double) -1.0);\n    if (image->alpha_trait != UndefinedPixelTrait)\n      channel_features[AlphaPixelChannel].maximum_correlation_coefficient[i]=\n        sqrt((double) -1.0);\n  }\n  /*\n    Relinquish resources.\n  */\n  sum=(ChannelStatistics *) RelinquishMagickMemory(sum);\n  for (i=0; i < (ssize_t) number_grays; i++)\n    Q[i]=(ChannelStatistics *) RelinquishMagickMemory(Q[i]);\n  Q=(ChannelStatistics **) RelinquishMagickMemory(Q);\n  density_y=(ChannelStatistics *) RelinquishMagickMemory(density_y);\n  density_xy=(ChannelStatistics *) RelinquishMagickMemory(density_xy);\n  density_x=(ChannelStatistics *) RelinquishMagickMemory(density_x);\n  for (i=0; i < (ssize_t) number_grays; i++)\n    cooccurrence[i]=(ChannelStatistics *)\n      RelinquishMagickMemory(cooccurrence[i]);\n  cooccurrence=(ChannelStatistics **) RelinquishMagickMemory(cooccurrence);\n  return(channel_features);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     H o u g h L i n e I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  Use HoughLineImage() in conjunction with any binary edge extracted image (we\n%  recommand Canny) to identify lines in the image.  The algorithm accumulates\n%  counts for every white pixel for every possible orientation (for angles from\n%  0 to 179 in 1 degree increments) and distance from the center of the image to\n%  the corner (in 1 px increments) and stores the counts in an accumulator\n%  matrix of angle vs distance. The size of the accumulator is 180x(diagonal/2).\n%  Next it searches this space for peaks in counts and converts the locations\n%  of the peaks to slope and intercept in the normal x,y input image space. Use\n%  the slope/intercepts to find the endpoints clipped to the bounds of the\n%  image. The lines are then drawn. The counts are a measure of the length of\n%  the lines.\n%\n%  The format of the HoughLineImage method is:\n%\n%      Image *HoughLineImage(const Image *image,const size_t width,\n%        const size_t height,const size_t threshold,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o width, height: find line pairs as local maxima in this neighborhood.\n%\n%    o threshold: the line count threshold.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\nstatic inline double MagickRound(double x)\n{\n  /*\n    Round the fraction to nearest integer.\n  */\n  if ((x-floor(x)) < (ceil(x)-x))\n    return(floor(x));\n  return(ceil(x));\n}\n\nstatic Image *RenderHoughLines(const ImageInfo *image_info,const size_t columns,\n  const size_t rows,ExceptionInfo *exception)\n{\n#define BoundingBox  \"viewbox\"\n\n  DrawInfo\n    *draw_info;\n\n  Image\n    *image;\n\n  MagickBooleanType\n    status;\n\n  /*\n    Open image.\n  */\n  image=AcquireImage(image_info,exception);\n  status=OpenBlob(image_info,image,ReadBinaryBlobMode,exception);\n  if (status == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  image->columns=columns;\n  image->rows=rows;\n  draw_info=CloneDrawInfo(image_info,(DrawInfo *) NULL);\n  draw_info->affine.sx=image->resolution.x == 0.0 ? 1.0 : image->resolution.x/\n    DefaultResolution;\n  draw_info->affine.sy=image->resolution.y == 0.0 ? 1.0 : image->resolution.y/\n    DefaultResolution;\n  image->columns=(size_t) (draw_info->affine.sx*image->columns);\n  image->rows=(size_t) (draw_info->affine.sy*image->rows);\n  status=SetImageExtent(image,image->columns,image->rows,exception);\n  if (status == MagickFalse)\n    return(DestroyImageList(image));\n  if (SetImageBackgroundColor(image,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return((Image *) NULL);\n    }\n  /*\n    Render drawing.\n  */\n  if (GetBlobStreamData(image) == (unsigned char *) NULL)\n    draw_info->primitive=FileToString(image->filename,~0UL,exception);\n  else\n    {\n      draw_info->primitive=(char *) AcquireMagickMemory((size_t)\n        GetBlobSize(image)+1);\n      if (draw_info->primitive != (char *) NULL)\n        {\n          (void) memcpy(draw_info->primitive,GetBlobStreamData(image),\n            (size_t) GetBlobSize(image));\n          draw_info->primitive[GetBlobSize(image)]='\\0';\n        }\n     }\n  (void) DrawImage(image,draw_info,exception);\n  draw_info=DestroyDrawInfo(draw_info);\n  (void) CloseBlob(image);\n  return(GetFirstImageInList(image));\n}\n\nMagickExport Image *HoughLineImage(const Image *image,const size_t width,\n  const size_t height,const size_t threshold,ExceptionInfo *exception)\n{\n#define HoughLineImageTag  \"HoughLine/Image\"\n\n  CacheView\n    *image_view;\n\n  char\n    message[MagickPathExtent],\n    path[MagickPathExtent];\n\n  const char\n    *artifact;\n\n  double\n    hough_height;\n\n  Image\n    *lines_image = NULL;\n\n  ImageInfo\n    *image_info;\n\n  int\n    file;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  MatrixInfo\n    *accumulator;\n\n  PointInfo\n    center;\n\n  register ssize_t\n    y;\n\n  size_t\n    accumulator_height,\n    accumulator_width,\n    line_count;\n\n  /*\n    Create the accumulator.\n  */\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  accumulator_width=180;\n  hough_height=((sqrt(2.0)*(double) (image->rows > image->columns ?\n    image->rows : image->columns))/2.0);\n  accumulator_height=(size_t) (2.0*hough_height);\n  accumulator=AcquireMatrixInfo(accumulator_width,accumulator_height,\n    sizeof(double),exception);\n  if (accumulator == (MatrixInfo *) NULL)\n    ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n  if (NullMatrix(accumulator) == MagickFalse)\n    {\n      accumulator=DestroyMatrixInfo(accumulator);\n      ThrowImageException(ResourceLimitError,\"MemoryAllocationFailed\");\n    }\n  /*\n    Populate the accumulator.\n  */\n  status=MagickTrue;\n  progress=0;\n  center.x=(double) image->columns/2.0;\n  center.y=(double) image->rows/2.0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0; y < (ssize_t) image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    if (p == (Quantum *) NULL)\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) image->columns; x++)\n    {\n      if (GetPixelIntensity(image,p) > (QuantumRange/2.0))\n        {\n          register ssize_t\n            i;\n\n          for (i=0; i < 180; i++)\n          {\n            double\n              count,\n              radius;\n\n            radius=(((double) x-center.x)*cos(DegreesToRadians((double) i)))+\n              (((double) y-center.y)*sin(DegreesToRadians((double) i)));\n            (void) GetMatrixElement(accumulator,i,(ssize_t)\n              MagickRound(radius+hough_height),&count);\n            count++;\n            (void) SetMatrixElement(accumulator,i,(ssize_t)\n              MagickRound(radius+hough_height),&count);\n          }\n        }\n      p+=GetPixelChannels(image);\n    }\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,CannyEdgeImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  image_view=DestroyCacheView(image_view);\n  if (status == MagickFalse)\n    {\n      accumulator=DestroyMatrixInfo(accumulator);\n      return((Image *) NULL);\n    }\n  /*\n    Generate line segments from accumulator.\n  */\n  file=AcquireUniqueFileResource(path);\n  if (file == -1)\n    {\n      accumulator=DestroyMatrixInfo(accumulator);\n      return((Image *) NULL);\n    }\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"# Hough line transform: %.20gx%.20g%+.20g\\n\",(double) width,\n    (double) height,(double) threshold);\n  if (write(file,message,strlen(message)) != (ssize_t) strlen(message))\n    status=MagickFalse;\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"viewbox 0 0 %.20g %.20g\\n\",(double) image->columns,(double) image->rows);\n  if (write(file,message,strlen(message)) != (ssize_t) strlen(message))\n    status=MagickFalse;\n  (void) FormatLocaleString(message,MagickPathExtent,\n    \"# x1,y1 x2,y2 # count angle distance\\n\");\n  if (write(file,message,strlen(message)) != (ssize_t) strlen(message))\n    status=MagickFalse;\n  line_count=image->columns > image->rows ? image->columns/4 : image->rows/4;\n  if (threshold != 0)\n    line_count=threshold;\n  for (y=0; y < (ssize_t) accumulator_height; y++)\n  {\n    register ssize_t\n      x;\n\n    for (x=0; x < (ssize_t) accumulator_width; x++)\n    {\n      double\n        count;\n\n      (void) GetMatrixElement(accumulator,x,y,&count);\n      if (count >= (double) line_count)\n        {\n          double\n            maxima;\n\n          SegmentInfo\n            line;\n\n          ssize_t\n            v;\n\n          /*\n            Is point a local maxima?\n          */\n          maxima=count;\n          for (v=(-((ssize_t) height/2)); v <= (((ssize_t) height/2)); v++)\n          {\n            ssize_t\n              u;\n\n            for (u=(-((ssize_t) width/2)); u <= (((ssize_t) width/2)); u++)\n            {\n              if ((u != 0) || (v !=0))\n                {\n                  (void) GetMatrixElement(accumulator,x+u,y+v,&count);\n                  if (count > maxima)\n                    {\n                      maxima=count;\n                      break;\n                    }\n                }\n            }\n            if (u < (ssize_t) (width/2))\n              break;\n          }\n          (void) GetMatrixElement(accumulator,x,y,&count);\n          if (maxima > count)\n            continue;\n          if ((x >= 45) && (x <= 135))\n            {\n              /*\n                y = (r-x cos(t))/sin(t)\n              */\n              line.x1=0.0;\n              line.y1=((double) (y-(accumulator_height/2.0))-((line.x1-\n                (image->columns/2.0))*cos(DegreesToRadians((double) x))))/\n                sin(DegreesToRadians((double) x))+(image->rows/2.0);\n              line.x2=(double) image->columns;\n              line.y2=((double) (y-(accumulator_height/2.0))-((line.x2-\n                (image->columns/2.0))*cos(DegreesToRadians((double) x))))/\n                sin(DegreesToRadians((double) x))+(image->rows/2.0);\n            }\n          else\n            {\n              /*\n                x = (r-y cos(t))/sin(t)\n              */\n              line.y1=0.0;\n              line.x1=((double) (y-(accumulator_height/2.0))-((line.y1-\n                (image->rows/2.0))*sin(DegreesToRadians((double) x))))/\n                cos(DegreesToRadians((double) x))+(image->columns/2.0);\n              line.y2=(double) image->rows;\n              line.x2=((double) (y-(accumulator_height/2.0))-((line.y2-\n                (image->rows/2.0))*sin(DegreesToRadians((double) x))))/\n                cos(DegreesToRadians((double) x))+(image->columns/2.0);\n            }\n          (void) FormatLocaleString(message,MagickPathExtent,\n            \"line %g,%g %g,%g  # %g %g %g\\n\",line.x1,line.y1,line.x2,line.y2,\n            maxima,(double) x,(double) y);\n          if (write(file,message,strlen(message)) != (ssize_t) strlen(message))\n            status=MagickFalse;\n        }\n    }\n  }\n  (void) close(file);\n  /*\n    Render lines to image canvas.\n  */\n  image_info=AcquireImageInfo();\n  image_info->background_color=image->background_color;\n  (void) FormatLocaleString(image_info->filename,MagickPathExtent,\"%s\",path);\n  artifact=GetImageArtifact(image,\"background\");\n  if (artifact != (const char *) NULL)\n    (void) SetImageOption(image_info,\"background\",artifact);\n  artifact=GetImageArtifact(image,\"fill\");\n  if (artifact != (const char *) NULL)\n    (void) SetImageOption(image_info,\"fill\",artifact);\n  artifact=GetImageArtifact(image,\"stroke\");\n  if (artifact != (const char *) NULL)\n    (void) SetImageOption(image_info,\"stroke\",artifact);\n  artifact=GetImageArtifact(image,\"strokewidth\");\n  if (artifact != (const char *) NULL)\n    (void) SetImageOption(image_info,\"strokewidth\",artifact);\n  lines_image=RenderHoughLines(image_info,image->columns,image->rows,exception);\n  artifact=GetImageArtifact(image,\"hough-lines:accumulator\");\n  if ((lines_image != (Image *) NULL) &&\n      (IsStringTrue(artifact) != MagickFalse))\n    {\n      Image\n        *accumulator_image;\n\n      accumulator_image=MatrixToImage(accumulator,exception);\n      if (accumulator_image != (Image *) NULL)\n        AppendImageToList(&lines_image,accumulator_image);\n    }\n  /*\n    Free resources.\n  */\n  accumulator=DestroyMatrixInfo(accumulator);\n  image_info=DestroyImageInfo(image_info);\n  (void) RelinquishUniqueFileResource(path);\n  return(GetFirstImageInList(lines_image));\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     M e a n S h i f t I m a g e                                             %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  MeanShiftImage() delineate arbitrarily shaped clusters in the image. For\n%  each pixel, it visits all the pixels in the neighborhood specified by\n%  the window centered at the pixel and excludes those that are outside the\n%  radius=(window-1)/2 surrounding the pixel. From those pixels, it finds those\n%  that are within the specified color distance from the current mean, and\n%  computes a new x,y centroid from those coordinates and a new mean. This new\n%  x,y centroid is used as the center for a new window. This process iterates\n%  until it converges and the final mean is replaces the (original window\n%  center) pixel value. It repeats this process for the next pixel, etc.,\n%  until it processes all pixels in the image. Results are typically better with\n%  colorspaces other than sRGB. We recommend YIQ, YUV or YCbCr.\n%\n%  The format of the MeanShiftImage method is:\n%\n%      Image *MeanShiftImage(const Image *image,const size_t width,\n%        const size_t height,const double color_distance,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o width, height: find pixels in this neighborhood.\n%\n%    o color_distance: the color distance.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *MeanShiftImage(const Image *image,const size_t width,\n  const size_t height,const double color_distance,ExceptionInfo *exception)\n{\n#define MaxMeanShiftIterations  100\n#define MeanShiftImageTag  \"MeanShift/Image\"\n\n  CacheView\n    *image_view,\n    *mean_view,\n    *pixel_view;\n\n  Image\n    *mean_image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(image != (const Image *) NULL);\n  assert(image->signature == MagickCoreSignature);\n  if (image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",image->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  mean_image=CloneImage(image,0,0,MagickTrue,exception);\n  if (mean_image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(mean_image,DirectClass,exception) == MagickFalse)\n    {\n      mean_image=DestroyImage(mean_image);\n      return((Image *) NULL);\n    }\n  status=MagickTrue;\n  progress=0;\n  image_view=AcquireVirtualCacheView(image,exception);\n  pixel_view=AcquireVirtualCacheView(image,exception);\n  mean_view=AcquireAuthenticCacheView(mean_image,exception);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(status,progress) \\\n    magick_number_threads(mean_image,mean_image,mean_image->rows,1)\n#endif\n  for (y=0; y < (ssize_t) mean_image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict p;\n\n    register Quantum\n      *magick_restrict q;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    p=GetCacheViewVirtualPixels(image_view,0,y,image->columns,1,exception);\n    q=GetCacheViewAuthenticPixels(mean_view,0,y,mean_image->columns,1,\n      exception);\n    if ((p == (const Quantum *) NULL) || (q == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) mean_image->columns; x++)\n    {\n      PixelInfo\n        mean_pixel,\n        previous_pixel;\n\n      PointInfo\n        mean_location,\n        previous_location;\n\n      register ssize_t\n        i;\n\n      GetPixelInfo(image,&mean_pixel);\n      GetPixelInfoPixel(image,p,&mean_pixel);\n      mean_location.x=(double) x;\n      mean_location.y=(double) y;\n      for (i=0; i < MaxMeanShiftIterations; i++)\n      {\n        double\n          distance,\n          gamma;\n\n        PixelInfo\n          sum_pixel;\n\n        PointInfo\n          sum_location;\n\n        ssize_t\n          count,\n          v;\n\n        sum_location.x=0.0;\n        sum_location.y=0.0;\n        GetPixelInfo(image,&sum_pixel);\n        previous_location=mean_location;\n        previous_pixel=mean_pixel;\n        count=0;\n        for (v=(-((ssize_t) height/2)); v <= (((ssize_t) height/2)); v++)\n        {\n          ssize_t\n            u;\n\n          for (u=(-((ssize_t) width/2)); u <= (((ssize_t) width/2)); u++)\n          {\n            if ((v*v+u*u) <= (ssize_t) ((width/2)*(height/2)))\n              {\n                PixelInfo\n                  pixel;\n\n                status=GetOneCacheViewVirtualPixelInfo(pixel_view,(ssize_t)\n                  MagickRound(mean_location.x+u),(ssize_t) MagickRound(\n                  mean_location.y+v),&pixel,exception);\n                distance=(mean_pixel.red-pixel.red)*(mean_pixel.red-pixel.red)+\n                  (mean_pixel.green-pixel.green)*(mean_pixel.green-pixel.green)+\n                  (mean_pixel.blue-pixel.blue)*(mean_pixel.blue-pixel.blue);\n                if (distance <= (color_distance*color_distance))\n                  {\n                    sum_location.x+=mean_location.x+u;\n                    sum_location.y+=mean_location.y+v;\n                    sum_pixel.red+=pixel.red;\n                    sum_pixel.green+=pixel.green;\n                    sum_pixel.blue+=pixel.blue;\n                    sum_pixel.alpha+=pixel.alpha;\n                    count++;\n                  }\n              }\n          }\n        }\n        gamma=PerceptibleReciprocal(count);\n        mean_location.x=gamma*sum_location.x;\n        mean_location.y=gamma*sum_location.y;\n        mean_pixel.red=gamma*sum_pixel.red;\n        mean_pixel.green=gamma*sum_pixel.green;\n        mean_pixel.blue=gamma*sum_pixel.blue;\n        mean_pixel.alpha=gamma*sum_pixel.alpha;\n        distance=(mean_location.x-previous_location.x)*\n          (mean_location.x-previous_location.x)+\n          (mean_location.y-previous_location.y)*\n          (mean_location.y-previous_location.y)+\n          255.0*QuantumScale*(mean_pixel.red-previous_pixel.red)*\n          255.0*QuantumScale*(mean_pixel.red-previous_pixel.red)+\n          255.0*QuantumScale*(mean_pixel.green-previous_pixel.green)*\n          255.0*QuantumScale*(mean_pixel.green-previous_pixel.green)+\n          255.0*QuantumScale*(mean_pixel.blue-previous_pixel.blue)*\n          255.0*QuantumScale*(mean_pixel.blue-previous_pixel.blue);\n        if (distance <= 3.0)\n          break;\n      }\n      SetPixelRed(mean_image,ClampToQuantum(mean_pixel.red),q);\n      SetPixelGreen(mean_image,ClampToQuantum(mean_pixel.green),q);\n      SetPixelBlue(mean_image,ClampToQuantum(mean_pixel.blue),q);\n      SetPixelAlpha(mean_image,ClampToQuantum(mean_pixel.alpha),q);\n      p+=GetPixelChannels(image);\n      q+=GetPixelChannels(mean_image);\n    }\n    if (SyncCacheViewAuthenticPixels(mean_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (image->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(image,MeanShiftImageTag,progress,image->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  mean_view=DestroyCacheView(mean_view);\n  pixel_view=DestroyCacheView(pixel_view);\n  image_view=DestroyCacheView(image_view);\n  return(mean_image);\n}\n"], "filenames": ["MagickCore/feature.c"], "buggy_code_start_loc": [2296], "buggy_code_end_loc": [2297], "fixing_code_start_loc": [2296], "fixing_code_end_loc": [2297], "type": "CWE-369", "message": "In ImageMagick 7.x before 7.0.8-41 and 6.x before 6.9.10-41, there is a divide-by-zero vulnerability in the MeanShiftImage function. It allows an attacker to cause a denial of service by sending a crafted file.", "other": {"cve": {"id": "CVE-2019-14981", "sourceIdentifier": "cve@mitre.org", "published": "2019-08-12T23:15:11.600", "lastModified": "2020-08-19T18:58:33.827", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In ImageMagick 7.x before 7.0.8-41 and 6.x before 6.9.10-41, there is a divide-by-zero vulnerability in the MeanShiftImage function. It allows an attacker to cause a denial of service by sending a crafted file."}, {"lang": "es", "value": "En ImageMagick versiones 7.x anteriores a 7.0.8-41 y versiones 6.x anteriores a 6.9.10-41, hay  una vulnerabilidad de divisi\u00f3n por cero en la funci\u00f3n MeanShiftImage. Permite a un atacante causar una denegaci\u00f3n de servicio mediante el env\u00edo de un archivo especialmente dise\u00f1ado."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-369"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "6.0", "versionEndExcluding": "6.9.10-41", "matchCriteriaId": "26AC6455-68F9-418E-B71A-3E9A35155603"}, {"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:*:*:*:*:*:*:*:*", "versionStartIncluding": "7.0.0-0", "versionEndExcluding": "7.0.8-41", "matchCriteriaId": "349C9D88-CD50-4928-B492-1CF880BA00F6"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.04:*:*:*:*:*:*:*", "matchCriteriaId": "CD783B0C-9246-47D9-A937-6144FE8BFF0F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:19.10:*:*:*:*:*:*:*", "matchCriteriaId": "A31C8344-3E02-4EB8-8BD8-4C84B7959624"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-11/msg00040.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://lists.opensuse.org/opensuse-security-announce/2019-11/msg00042.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/a77d8d97f5a7bced0468f0b08798c83fb67427bc", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/1552", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick6/commit/b522d2d857d2f75b659936b59b0da9df1682c256", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2019/10/msg00028.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/08/msg00030.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4192-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2020/dsa-4712", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/a77d8d97f5a7bced0468f0b08798c83fb67427bc"}}