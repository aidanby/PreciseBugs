{"buggy_code": ["/*\n * corre.c\n *\n * Routines to implement Compact Rise-and-Run-length Encoding (CoRRE).  This\n * code is based on krw's original javatel rfbserver.\n */\n\n/*\n *  Copyright (C) 2002 RealVNC Ltd.\n *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.\n *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  \n *  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n#include <rfb/rfb.h>\n\n/*\n * cl->beforeEncBuf contains pixel data in the client's format.\n * cl->afterEncBuf contains the RRE encoded version.  If the RRE encoded version is\n * larger than the raw data or if it exceeds cl->afterEncBufSize then\n * raw encoding is used instead.\n */\n\nstatic int subrectEncode8(rfbClientPtr cl, uint8_t *data, int w, int h);\nstatic int subrectEncode16(rfbClientPtr cl, uint16_t *data, int w, int h);\nstatic int subrectEncode32(rfbClientPtr cl, uint32_t *data, int w, int h);\nstatic uint32_t getBgColour(char *data, int size, int bpp);\nstatic rfbBool rfbSendSmallRectEncodingCoRRE(rfbClientPtr cl, int x, int y,\n                                          int w, int h);\n\n\n/*\n * rfbSendRectEncodingCoRRE - send an arbitrary size rectangle using CoRRE\n * encoding.\n */\n\nrfbBool\nrfbSendRectEncodingCoRRE(rfbClientPtr cl,\n                         int x,\n                         int y,\n                         int w,\n                         int h)\n{\n    if (h > cl->correMaxHeight) {\n        return (rfbSendRectEncodingCoRRE(cl, x, y, w, cl->correMaxHeight) &&\n\t\trfbSendRectEncodingCoRRE(cl, x, y + cl->correMaxHeight, w,\n\t\t\t\t\t h - cl->correMaxHeight));\n    }\n\n    if (w > cl->correMaxWidth) {\n        return (rfbSendRectEncodingCoRRE(cl, x, y, cl->correMaxWidth, h) &&\n\t\trfbSendRectEncodingCoRRE(cl, x + cl->correMaxWidth, y,\n\t\t\t\t\t w - cl->correMaxWidth, h));\n    }\n\n    rfbSendSmallRectEncodingCoRRE(cl, x, y, w, h);\n    return TRUE;\n}\n\n\n\n/*\n * rfbSendSmallRectEncodingCoRRE - send a small (guaranteed < 256x256)\n * rectangle using CoRRE encoding.\n */\n\nstatic rfbBool\nrfbSendSmallRectEncodingCoRRE(rfbClientPtr cl,\n                              int x,\n                              int y,\n                              int w,\n                              int h)\n{\n    rfbFramebufferUpdateRectHeader rect;\n    rfbRREHeader hdr;\n    int nSubrects;\n    int i;\n    char *fbptr = (cl->scaledScreen->frameBuffer + (cl->scaledScreen->paddedWidthInBytes * y)\n                   + (x * (cl->scaledScreen->bitsPerPixel / 8)));\n\n    int maxRawSize = (cl->scaledScreen->width * cl->scaledScreen->height\n                      * (cl->format.bitsPerPixel / 8));\n\n    if (cl->beforeEncBufSize < maxRawSize) {\n        cl->beforeEncBufSize = maxRawSize;\n        if (cl->beforeEncBuf == NULL)\n            cl->beforeEncBuf = (char *)malloc(cl->beforeEncBufSize);\n        else\n            cl->beforeEncBuf = (char *)realloc(cl->beforeEncBuf, cl->beforeEncBufSize);\n    }\n\n    if (cl->afterEncBufSize < maxRawSize) {\n        cl->afterEncBufSize = maxRawSize;\n        if (cl->afterEncBuf == NULL)\n            cl->afterEncBuf = (char *)malloc(cl->afterEncBufSize);\n        else\n            cl->afterEncBuf = (char *)realloc(cl->afterEncBuf, cl->afterEncBufSize);\n    }\n\n    (*cl->translateFn)(cl->translateLookupTable,&(cl->screen->serverFormat),\n                       &cl->format, fbptr, cl->beforeEncBuf,\n                       cl->scaledScreen->paddedWidthInBytes, w, h);\n\n    switch (cl->format.bitsPerPixel) {\n    case 8:\n        nSubrects = subrectEncode8(cl, (uint8_t *)cl->beforeEncBuf, w, h);\n        break;\n    case 16:\n        nSubrects = subrectEncode16(cl, (uint16_t *)cl->beforeEncBuf, w, h);\n        break;\n    case 32:\n        nSubrects = subrectEncode32(cl, (uint32_t *)cl->beforeEncBuf, w, h);\n        break;\n    default:\n        rfbLog(\"getBgColour: bpp %d?\\n\",cl->format.bitsPerPixel);\n        return FALSE;\n    }\n        \n    if (nSubrects < 0) {\n\n        /* RRE encoding was too large, use raw */\n\n        return rfbSendRectEncodingRaw(cl, x, y, w, h);\n    }\n\n    rfbStatRecordEncodingSent(cl,rfbEncodingCoRRE,\n        sz_rfbFramebufferUpdateRectHeader + sz_rfbRREHeader + cl->afterEncBufLen,\n        sz_rfbFramebufferUpdateRectHeader + w * h * (cl->format.bitsPerPixel / 8));\n\n    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader + sz_rfbRREHeader\n        > UPDATE_BUF_SIZE)\n    {\n        if (!rfbSendUpdateBuf(cl))\n            return FALSE;\n    }\n\n    rect.r.x = Swap16IfLE(x);\n    rect.r.y = Swap16IfLE(y);\n    rect.r.w = Swap16IfLE(w);\n    rect.r.h = Swap16IfLE(h);\n    rect.encoding = Swap32IfLE(rfbEncodingCoRRE);\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,\n           sz_rfbFramebufferUpdateRectHeader);\n    cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n\n    hdr.nSubrects = Swap32IfLE(nSubrects);\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&hdr, sz_rfbRREHeader);\n    cl->ublen += sz_rfbRREHeader;\n\n    for (i = 0; i < cl->afterEncBufLen;) {\n\n        int bytesToCopy = UPDATE_BUF_SIZE - cl->ublen;\n\n        if (i + bytesToCopy > cl->afterEncBufLen) {\n            bytesToCopy = cl->afterEncBufLen - i;\n        }\n\n        memcpy(&cl->updateBuf[cl->ublen], &cl->afterEncBuf[i], bytesToCopy);\n\n        cl->ublen += bytesToCopy;\n        i += bytesToCopy;\n\n        if (cl->ublen == UPDATE_BUF_SIZE) {\n            if (!rfbSendUpdateBuf(cl))\n                return FALSE;\n        }\n    }\n\n    return TRUE;\n}\n\n\n\n/*\n * subrectEncode() encodes the given multicoloured rectangle as a background \n * colour overwritten by single-coloured rectangles.  It returns the number \n * of subrectangles in the encoded buffer, or -1 if subrect encoding won't\n * fit in the buffer.  It puts the encoded rectangles in cl->afterEncBuf.  The\n * single-colour rectangle partition is not optimal, but does find the biggest\n * horizontal or vertical rectangle top-left anchored to each consecutive \n * coordinate position.\n *\n * The coding scheme is simply [<bgcolour><subrect><subrect>...] where each \n * <subrect> is [<colour><x><y><w><h>].\n */\n\n#define DEFINE_SUBRECT_ENCODE(bpp)                                            \\\nstatic int                                                                    \\\nsubrectEncode##bpp(rfbClientPtr client, uint##bpp##_t *data, int w, int h) {                       \\\n    uint##bpp##_t cl;                                                         \\\n    rfbCoRRERectangle subrect;                                                \\\n    int x,y;                                                                  \\\n    int i,j;                                                                  \\\n    int hx=0,hy,vx=0,vy;                                                      \\\n    int hyflag;                                                               \\\n    uint##bpp##_t *seg;                                                       \\\n    uint##bpp##_t *line;                                                      \\\n    int hw,hh,vw,vh;                                                          \\\n    int thex,they,thew,theh;                                                  \\\n    int numsubs = 0;                                                          \\\n    int newLen;                                                               \\\n    uint##bpp##_t bg = (uint##bpp##_t)getBgColour((char*)data,w*h,bpp);       \\\n                                                                              \\\n    *((uint##bpp##_t*)client->afterEncBuf) = bg;                                      \\\n                                                                              \\\n    client->afterEncBufLen = (bpp/8);                                                 \\\n                                                                              \\\n    for (y=0; y<h; y++) {                                                     \\\n      line = data+(y*w);                                                      \\\n      for (x=0; x<w; x++) {                                                   \\\n        if (line[x] != bg) {                                                  \\\n          cl = line[x];                                                       \\\n          hy = y-1;                                                           \\\n          hyflag = 1;                                                         \\\n          for (j=y; j<h; j++) {                                               \\\n            seg = data+(j*w);                                                 \\\n            if (seg[x] != cl) {break;}                                        \\\n            i = x;                                                            \\\n            while ((seg[i] == cl) && (i < w)) i += 1;                         \\\n            i -= 1;                                                           \\\n            if (j == y) vx = hx = i;                                          \\\n            if (i < vx) vx = i;                                               \\\n            if ((hyflag > 0) && (i >= hx)) {hy += 1;} else {hyflag = 0;}      \\\n          }                                                                   \\\n          vy = j-1;                                                           \\\n                                                                              \\\n          /*  We now have two possible subrects: (x,y,hx,hy) and (x,y,vx,vy)  \\\n           *  We'll choose the bigger of the two.                             \\\n           */                                                                 \\\n          hw = hx-x+1;                                                        \\\n          hh = hy-y+1;                                                        \\\n          vw = vx-x+1;                                                        \\\n          vh = vy-y+1;                                                        \\\n                                                                              \\\n          thex = x;                                                           \\\n          they = y;                                                           \\\n                                                                              \\\n          if ((hw*hh) > (vw*vh)) {                                            \\\n            thew = hw;                                                        \\\n            theh = hh;                                                        \\\n          } else {                                                            \\\n            thew = vw;                                                        \\\n            theh = vh;                                                        \\\n          }                                                                   \\\n                                                                              \\\n          subrect.x = thex;                                                   \\\n          subrect.y = they;                                                   \\\n          subrect.w = thew;                                                   \\\n          subrect.h = theh;                                                   \\\n                                                                              \\\n          newLen = client->afterEncBufLen + (bpp/8) + sz_rfbCoRRERectangle;           \\\n          if ((newLen > (w * h * (bpp/8))) || (newLen > client->afterEncBufSize))     \\\n            return -1;                                                        \\\n                                                                              \\\n          numsubs += 1;                                                       \\\n          *((uint##bpp##_t*)(client->afterEncBuf + client->afterEncBufLen)) = cl;             \\\n          client->afterEncBufLen += (bpp/8);                                          \\\n          memcpy(&client->afterEncBuf[client->afterEncBufLen],&subrect,sz_rfbCoRRERectangle); \\\n          client->afterEncBufLen += sz_rfbCoRRERectangle;                             \\\n                                                                              \\\n          /*                                                                  \\\n           * Now mark the subrect as done.                                    \\\n           */                                                                 \\\n          for (j=they; j < (they+theh); j++) {                                \\\n            for (i=thex; i < (thex+thew); i++) {                              \\\n              data[j*w+i] = bg;                                               \\\n            }                                                                 \\\n          }                                                                   \\\n        }                                                                     \\\n      }                                                                       \\\n    }                                                                         \\\n                                                                              \\\n    return numsubs;                                                           \\\n}\n\nDEFINE_SUBRECT_ENCODE(8)\nDEFINE_SUBRECT_ENCODE(16)\nDEFINE_SUBRECT_ENCODE(32)\n\n\n/*\n * getBgColour() gets the most prevalent colour in a byte array.\n */\nstatic uint32_t\ngetBgColour(char *data, int size, int bpp)\n{\n\n#define NUMCLRS 256\n  \n  static int counts[NUMCLRS];\n  int i,j,k;\n\n  int maxcount = 0;\n  uint8_t maxclr = 0;\n\n  if (bpp != 8) {\n    if (bpp == 16) {\n      return ((uint16_t *)data)[0];\n    } else if (bpp == 32) {\n      return ((uint32_t *)data)[0];\n    } else {\n      rfbLog(\"getBgColour: bpp %d?\\n\",bpp);\n      return 0;\n    }\n  }\n\n  for (i=0; i<NUMCLRS; i++) {\n    counts[i] = 0;\n  }\n\n  for (j=0; j<size; j++) {\n    k = (int)(((uint8_t *)data)[j]);\n    if (k >= NUMCLRS) {\n      rfbLog(\"getBgColour: unusual colour = %d\\n\", k);\n      return 0;\n    }\n    counts[k] += 1;\n    if (counts[k] > maxcount) {\n      maxcount = counts[k];\n      maxclr = ((uint8_t *)data)[j];\n    }\n  }\n  \n  return maxclr;\n}\n", "/*\n * hextile.c\n *\n * Routines to implement Hextile Encoding\n */\n\n/*\n *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.\n *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  \n *  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n#include <rfb/rfb.h>\n\nstatic rfbBool sendHextiles8(rfbClientPtr cl, int x, int y, int w, int h);\nstatic rfbBool sendHextiles16(rfbClientPtr cl, int x, int y, int w, int h);\nstatic rfbBool sendHextiles32(rfbClientPtr cl, int x, int y, int w, int h);\n\n\n/*\n * rfbSendRectEncodingHextile - send a rectangle using hextile encoding.\n */\n\nrfbBool\nrfbSendRectEncodingHextile(rfbClientPtr cl,\n                           int x,\n                           int y,\n                           int w,\n                           int h)\n{\n    rfbFramebufferUpdateRectHeader rect;\n    \n    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader > UPDATE_BUF_SIZE) {\n        if (!rfbSendUpdateBuf(cl))\n            return FALSE;\n    }\n\n    rect.r.x = Swap16IfLE(x);\n    rect.r.y = Swap16IfLE(y);\n    rect.r.w = Swap16IfLE(w);\n    rect.r.h = Swap16IfLE(h);\n    rect.encoding = Swap32IfLE(rfbEncodingHextile);\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,\n           sz_rfbFramebufferUpdateRectHeader);\n    cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n\n    rfbStatRecordEncodingSent(cl, rfbEncodingHextile,\n          sz_rfbFramebufferUpdateRectHeader,\n          sz_rfbFramebufferUpdateRectHeader + w * (cl->format.bitsPerPixel / 8) * h);\n\n    switch (cl->format.bitsPerPixel) {\n    case 8:\n        return sendHextiles8(cl, x, y, w, h);\n    case 16:\n        return sendHextiles16(cl, x, y, w, h);\n    case 32:\n        return sendHextiles32(cl, x, y, w, h);\n    }\n\n    rfbLog(\"rfbSendRectEncodingHextile: bpp %d?\\n\", cl->format.bitsPerPixel);\n    return FALSE;\n}\n\n\n#define PUT_PIXEL8(pix) (cl->updateBuf[cl->ublen++] = (pix))\n\n#define PUT_PIXEL16(pix) (cl->updateBuf[cl->ublen++] = ((char*)&(pix))[0], \\\n                          cl->updateBuf[cl->ublen++] = ((char*)&(pix))[1])\n\n#define PUT_PIXEL32(pix) (cl->updateBuf[cl->ublen++] = ((char*)&(pix))[0], \\\n                          cl->updateBuf[cl->ublen++] = ((char*)&(pix))[1], \\\n                          cl->updateBuf[cl->ublen++] = ((char*)&(pix))[2], \\\n                          cl->updateBuf[cl->ublen++] = ((char*)&(pix))[3])\n\n\n#define DEFINE_SEND_HEXTILES(bpp)                                               \\\n                                                                                \\\n                                                                                \\\nstatic rfbBool subrectEncode##bpp(rfbClientPtr cli, uint##bpp##_t *data,        \\\n\t\tint w, int h, uint##bpp##_t bg, uint##bpp##_t fg, rfbBool mono);\\\nstatic void testColours##bpp(uint##bpp##_t *data, int size, rfbBool *mono,      \\\n                  rfbBool *solid, uint##bpp##_t *bg, uint##bpp##_t *fg);        \\\n                                                                                \\\n                                                                                \\\n/*                                                                              \\\n * rfbSendHextiles                                                              \\\n */                                                                             \\\n                                                                                \\\nstatic rfbBool                                                                  \\\nsendHextiles##bpp(rfbClientPtr cl, int rx, int ry, int rw, int rh) {            \\\n    int x, y, w, h;                                                             \\\n    int startUblen;                                                             \\\n    char *fbptr;                                                                \\\n    uint##bpp##_t bg = 0, fg = 0, newBg, newFg;                                 \\\n    rfbBool mono, solid;                                                        \\\n    rfbBool validBg = FALSE;                                                    \\\n    rfbBool validFg = FALSE;                                                    \\\n    uint##bpp##_t clientPixelData[16*16*(bpp/8)];                               \\\n                                                                                \\\n    for (y = ry; y < ry+rh; y += 16) {                                          \\\n        for (x = rx; x < rx+rw; x += 16) {                                      \\\n            w = h = 16;                                                         \\\n            if (rx+rw - x < 16)                                                 \\\n                w = rx+rw - x;                                                  \\\n            if (ry+rh - y < 16)                                                 \\\n                h = ry+rh - y;                                                  \\\n                                                                                \\\n            if ((cl->ublen + 1 + (2 + 16 * 16) * (bpp/8)) >                     \\\n                UPDATE_BUF_SIZE) {                                              \\\n                if (!rfbSendUpdateBuf(cl))                                      \\\n                    return FALSE;                                               \\\n            }                                                                   \\\n                                                                                \\\n            fbptr = (cl->scaledScreen->frameBuffer + (cl->scaledScreen->paddedWidthInBytes * y)   \\\n                     + (x * (cl->scaledScreen->bitsPerPixel / 8)));                   \\\n                                                                                \\\n            (*cl->translateFn)(cl->translateLookupTable, &(cl->screen->serverFormat),      \\\n                               &cl->format, fbptr, (char *)clientPixelData,     \\\n                               cl->scaledScreen->paddedWidthInBytes, w, h);           \\\n                                                                                \\\n            startUblen = cl->ublen;                                             \\\n            cl->updateBuf[startUblen] = 0;                                      \\\n            cl->ublen++;                                                        \\\n            rfbStatRecordEncodingSentAdd(cl, rfbEncodingHextile, 1);            \\\n                                                                                \\\n            testColours##bpp(clientPixelData, w * h,                            \\\n                             &mono, &solid, &newBg, &newFg);                    \\\n                                                                                \\\n            if (!validBg || (newBg != bg)) {                                    \\\n                validBg = TRUE;                                                 \\\n                bg = newBg;                                                     \\\n                cl->updateBuf[startUblen] |= rfbHextileBackgroundSpecified;     \\\n                PUT_PIXEL##bpp(bg);                                             \\\n            }                                                                   \\\n                                                                                \\\n            if (solid) {                                                        \\\n                continue;                                                       \\\n            }                                                                   \\\n                                                                                \\\n            cl->updateBuf[startUblen] |= rfbHextileAnySubrects;                 \\\n                                                                                \\\n            if (mono) {                                                         \\\n                if (!validFg || (newFg != fg)) {                                \\\n                    validFg = TRUE;                                             \\\n                    fg = newFg;                                                 \\\n                    cl->updateBuf[startUblen] |= rfbHextileForegroundSpecified; \\\n                    PUT_PIXEL##bpp(fg);                                         \\\n                }                                                               \\\n            } else {                                                            \\\n                validFg = FALSE;                                                \\\n                cl->updateBuf[startUblen] |= rfbHextileSubrectsColoured;        \\\n            }                                                                   \\\n                                                                                \\\n            if (!subrectEncode##bpp(cl, clientPixelData, w, h, bg, fg, mono)) { \\\n                /* encoding was too large, use raw */                           \\\n                validBg = FALSE;                                                \\\n                validFg = FALSE;                                                \\\n                cl->ublen = startUblen;                                         \\\n                cl->updateBuf[cl->ublen++] = rfbHextileRaw;                     \\\n                (*cl->translateFn)(cl->translateLookupTable,                    \\\n                                   &(cl->screen->serverFormat), &cl->format, fbptr,        \\\n                                   (char *)clientPixelData,                     \\\n                                   cl->scaledScreen->paddedWidthInBytes, w, h); \\\n                                                                                \\\n                memcpy(&cl->updateBuf[cl->ublen], (char *)clientPixelData,      \\\n                       w * h * (bpp/8));                                        \\\n                                                                                \\\n                cl->ublen += w * h * (bpp/8);                                   \\\n                rfbStatRecordEncodingSentAdd(cl, rfbEncodingHextile,            \\\n                             w * h * (bpp/8));                                  \\\n            }                                                                   \\\n        }                                                                       \\\n    }                                                                           \\\n                                                                                \\\n    return TRUE;                                                                \\\n}                                                                               \\\n                                                                                \\\n                                                                                \\\nstatic rfbBool                                                                  \\\nsubrectEncode##bpp(rfbClientPtr cl, uint##bpp##_t *data, int w, int h,          \\\n                   uint##bpp##_t bg, uint##bpp##_t fg, rfbBool mono)            \\\n{                                                                               \\\n    uint##bpp##_t cl2;                                                          \\\n    int x,y;                                                                    \\\n    int i,j;                                                                    \\\n    int hx=0,hy,vx=0,vy;                                                        \\\n    int hyflag;                                                                 \\\n    uint##bpp##_t *seg;                                                         \\\n    uint##bpp##_t *line;                                                        \\\n    int hw,hh,vw,vh;                                                            \\\n    int thex,they,thew,theh;                                                    \\\n    int numsubs = 0;                                                            \\\n    int newLen;                                                                 \\\n    int nSubrectsUblen;                                                         \\\n                                                                                \\\n    nSubrectsUblen = cl->ublen;                                                 \\\n    cl->ublen++;                                                                \\\n    rfbStatRecordEncodingSentAdd(cl, rfbEncodingHextile, 1);                    \\\n                                                                                \\\n    for (y=0; y<h; y++) {                                                       \\\n        line = data+(y*w);                                                      \\\n        for (x=0; x<w; x++) {                                                   \\\n            if (line[x] != bg) {                                                \\\n                cl2 = line[x];                                                  \\\n                hy = y-1;                                                       \\\n                hyflag = 1;                                                     \\\n                for (j=y; j<h; j++) {                                           \\\n                    seg = data+(j*w);                                           \\\n                    if (seg[x] != cl2) {break;}                                 \\\n                    i = x;                                                      \\\n                    while ((seg[i] == cl2) && (i < w)) i += 1;                  \\\n                    i -= 1;                                                     \\\n                    if (j == y) vx = hx = i;                                    \\\n                    if (i < vx) vx = i;                                         \\\n                    if ((hyflag > 0) && (i >= hx)) {                            \\\n                        hy += 1;                                                \\\n                    } else {                                                    \\\n                        hyflag = 0;                                             \\\n                    }                                                           \\\n                }                                                               \\\n                vy = j-1;                                                       \\\n                                                                                \\\n                /* We now have two possible subrects: (x,y,hx,hy) and           \\\n                 * (x,y,vx,vy).  We'll choose the bigger of the two.            \\\n                 */                                                             \\\n                hw = hx-x+1;                                                    \\\n                hh = hy-y+1;                                                    \\\n                vw = vx-x+1;                                                    \\\n                vh = vy-y+1;                                                    \\\n                                                                                \\\n                thex = x;                                                       \\\n                they = y;                                                       \\\n                                                                                \\\n                if ((hw*hh) > (vw*vh)) {                                        \\\n                    thew = hw;                                                  \\\n                    theh = hh;                                                  \\\n                } else {                                                        \\\n                    thew = vw;                                                  \\\n                    theh = vh;                                                  \\\n                }                                                               \\\n                                                                                \\\n                if (mono) {                                                     \\\n                    newLen = cl->ublen - nSubrectsUblen + 2;                    \\\n                } else {                                                        \\\n                    newLen = cl->ublen - nSubrectsUblen + bpp/8 + 2;            \\\n                }                                                               \\\n                                                                                \\\n                if (newLen > (w * h * (bpp/8)))                                 \\\n                    return FALSE;                                               \\\n                                                                                \\\n                numsubs += 1;                                                   \\\n                                                                                \\\n                if (!mono) PUT_PIXEL##bpp(cl2);                                 \\\n                                                                                \\\n                cl->updateBuf[cl->ublen++] = rfbHextilePackXY(thex,they);       \\\n                cl->updateBuf[cl->ublen++] = rfbHextilePackWH(thew,theh);       \\\n                rfbStatRecordEncodingSentAdd(cl, rfbEncodingHextile, 1);        \\\n                                                                                \\\n                /*                                                              \\\n                 * Now mark the subrect as done.                                \\\n                 */                                                             \\\n                for (j=they; j < (they+theh); j++) {                            \\\n                    for (i=thex; i < (thex+thew); i++) {                        \\\n                        data[j*w+i] = bg;                                       \\\n                    }                                                           \\\n                }                                                               \\\n            }                                                                   \\\n        }                                                                       \\\n    }                                                                           \\\n                                                                                \\\n    cl->updateBuf[nSubrectsUblen] = numsubs;                                    \\\n                                                                                \\\n    return TRUE;                                                                \\\n}                                                                               \\\n                                                                                \\\n                                                                                \\\n/*                                                                              \\\n * testColours() tests if there are one (solid), two (mono) or more             \\\n * colours in a tile and gets a reasonable guess at the best background         \\\n * pixel, and the foreground pixel for mono.                                    \\\n */                                                                             \\\n                                                                                \\\nstatic void                                                                     \\\ntestColours##bpp(uint##bpp##_t *data, int size, rfbBool *mono, rfbBool *solid,  \\\n                 uint##bpp##_t *bg, uint##bpp##_t *fg) {                        \\\n    uint##bpp##_t colour1 = 0, colour2 = 0;                                     \\\n    int n1 = 0, n2 = 0;                                                         \\\n    *mono = TRUE;                                                               \\\n    *solid = TRUE;                                                              \\\n                                                                                \\\n    for (; size > 0; size--, data++) {                                          \\\n                                                                                \\\n        if (n1 == 0)                                                            \\\n            colour1 = *data;                                                    \\\n                                                                                \\\n        if (*data == colour1) {                                                 \\\n            n1++;                                                               \\\n            continue;                                                           \\\n        }                                                                       \\\n                                                                                \\\n        if (n2 == 0) {                                                          \\\n            *solid = FALSE;                                                     \\\n            colour2 = *data;                                                    \\\n        }                                                                       \\\n                                                                                \\\n        if (*data == colour2) {                                                 \\\n            n2++;                                                               \\\n            continue;                                                           \\\n        }                                                                       \\\n                                                                                \\\n        *mono = FALSE;                                                          \\\n        break;                                                                  \\\n    }                                                                           \\\n                                                                                \\\n    if (n1 > n2) {                                                              \\\n        *bg = colour1;                                                          \\\n        *fg = colour2;                                                          \\\n    } else {                                                                    \\\n        *bg = colour2;                                                          \\\n        *fg = colour1;                                                          \\\n    }                                                                           \\\n}\n\nDEFINE_SEND_HEXTILES(8)\nDEFINE_SEND_HEXTILES(16)\nDEFINE_SEND_HEXTILES(32)\n", "/*\n * rre.c\n *\n * Routines to implement Rise-and-Run-length Encoding (RRE).  This\n * code is based on krw's original javatel rfbserver.\n */\n\n/*\n *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.\n *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  \n *  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n#include <rfb/rfb.h>\n\n/*\n * cl->beforeEncBuf contains pixel data in the client's format.\n * cl->afterEncBuf contains the RRE encoded version.  If the RRE encoded version is\n * larger than the raw data or if it exceeds cl->afterEncBufSize then\n * raw encoding is used instead.\n */\n\nstatic int subrectEncode8(rfbClientPtr cl, uint8_t *data, int w, int h);\nstatic int subrectEncode16(rfbClientPtr cl, uint16_t *data, int w, int h);\nstatic int subrectEncode32(rfbClientPtr cl, uint32_t *data, int w, int h);\nstatic uint32_t getBgColour(char *data, int size, int bpp);\n\n\n/*\n * rfbSendRectEncodingRRE - send a given rectangle using RRE encoding.\n */\n\nrfbBool\nrfbSendRectEncodingRRE(rfbClientPtr cl,\n                       int x,\n                       int y,\n                       int w,\n                       int h)\n{\n    rfbFramebufferUpdateRectHeader rect;\n    rfbRREHeader hdr;\n    int nSubrects;\n    int i;\n    char *fbptr = (cl->scaledScreen->frameBuffer + (cl->scaledScreen->paddedWidthInBytes * y)\n                   + (x * (cl->scaledScreen->bitsPerPixel / 8)));\n\n    int maxRawSize = (cl->scaledScreen->width * cl->scaledScreen->height\n                      * (cl->format.bitsPerPixel / 8));\n\n    if (cl->beforeEncBufSize < maxRawSize) {\n        cl->beforeEncBufSize = maxRawSize;\n        if (cl->beforeEncBuf == NULL)\n            cl->beforeEncBuf = (char *)malloc(cl->beforeEncBufSize);\n        else\n            cl->beforeEncBuf = (char *)realloc(cl->beforeEncBuf, cl->beforeEncBufSize);\n    }\n\n    if (cl->afterEncBufSize < maxRawSize) {\n        cl->afterEncBufSize = maxRawSize;\n        if (cl->afterEncBuf == NULL)\n            cl->afterEncBuf = (char *)malloc(cl->afterEncBufSize);\n        else\n            cl->afterEncBuf = (char *)realloc(cl->afterEncBuf, cl->afterEncBufSize);\n    }\n\n    (*cl->translateFn)(cl->translateLookupTable,\n\t\t       &(cl->screen->serverFormat),\n                       &cl->format, fbptr, cl->beforeEncBuf,\n                       cl->scaledScreen->paddedWidthInBytes, w, h);\n\n    switch (cl->format.bitsPerPixel) {\n    case 8:\n        nSubrects = subrectEncode8(cl, (uint8_t *)cl->beforeEncBuf, w, h);\n        break;\n    case 16:\n        nSubrects = subrectEncode16(cl, (uint16_t *)cl->beforeEncBuf, w, h);\n        break;\n    case 32:\n        nSubrects = subrectEncode32(cl, (uint32_t *)cl->beforeEncBuf, w, h);\n        break;\n    default:\n        rfbLog(\"getBgColour: bpp %d?\\n\",cl->format.bitsPerPixel);\n        return FALSE;\n    }\n        \n    if (nSubrects < 0) {\n\n        /* RRE encoding was too large, use raw */\n\n        return rfbSendRectEncodingRaw(cl, x, y, w, h);\n    }\n\n    rfbStatRecordEncodingSent(cl, rfbEncodingRRE,\n                              sz_rfbFramebufferUpdateRectHeader + sz_rfbRREHeader + cl->afterEncBufLen,\n                              sz_rfbFramebufferUpdateRectHeader + w * h * (cl->format.bitsPerPixel / 8));\n\n    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader + sz_rfbRREHeader\n        > UPDATE_BUF_SIZE)\n    {\n        if (!rfbSendUpdateBuf(cl))\n            return FALSE;\n    }\n\n    rect.r.x = Swap16IfLE(x);\n    rect.r.y = Swap16IfLE(y);\n    rect.r.w = Swap16IfLE(w);\n    rect.r.h = Swap16IfLE(h);\n    rect.encoding = Swap32IfLE(rfbEncodingRRE);\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,\n           sz_rfbFramebufferUpdateRectHeader);\n    cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n\n    hdr.nSubrects = Swap32IfLE(nSubrects);\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&hdr, sz_rfbRREHeader);\n    cl->ublen += sz_rfbRREHeader;\n\n    for (i = 0; i < cl->afterEncBufLen;) {\n\n        int bytesToCopy = UPDATE_BUF_SIZE - cl->ublen;\n\n        if (i + bytesToCopy > cl->afterEncBufLen) {\n            bytesToCopy = cl->afterEncBufLen - i;\n        }\n\n        memcpy(&cl->updateBuf[cl->ublen], &cl->afterEncBuf[i], bytesToCopy);\n\n        cl->ublen += bytesToCopy;\n        i += bytesToCopy;\n\n        if (cl->ublen == UPDATE_BUF_SIZE) {\n            if (!rfbSendUpdateBuf(cl))\n                return FALSE;\n        }\n    }\n\n    return TRUE;\n}\n\n\n\n/*\n * subrectEncode() encodes the given multicoloured rectangle as a background \n * colour overwritten by single-coloured rectangles.  It returns the number \n * of subrectangles in the encoded buffer, or -1 if subrect encoding won't\n * fit in the buffer.  It puts the encoded rectangles in cl->afterEncBuf.  The\n * single-colour rectangle partition is not optimal, but does find the biggest\n * horizontal or vertical rectangle top-left anchored to each consecutive \n * coordinate position.\n *\n * The coding scheme is simply [<bgcolour><subrect><subrect>...] where each \n * <subrect> is [<colour><x><y><w><h>].\n */\n\n#define DEFINE_SUBRECT_ENCODE(bpp)                                            \\\nstatic int                                                                    \\\n subrectEncode##bpp(rfbClientPtr client, uint##bpp##_t *data, int w, int h) { \\\n    uint##bpp##_t cl;                                                         \\\n    rfbRectangle subrect;                                                     \\\n    int x,y;                                                                  \\\n    int i,j;                                                                  \\\n    int hx=0,hy,vx=0,vy;                                                      \\\n    int hyflag;                                                               \\\n    uint##bpp##_t *seg;                                                       \\\n    uint##bpp##_t *line;                                                      \\\n    int hw,hh,vw,vh;                                                          \\\n    int thex,they,thew,theh;                                                  \\\n    int numsubs = 0;                                                          \\\n    int newLen;                                                               \\\n    uint##bpp##_t bg = (uint##bpp##_t)getBgColour((char*)data,w*h,bpp);       \\\n                                                                              \\\n    *((uint##bpp##_t*)client->afterEncBuf) = bg;                                      \\\n                                                                              \\\n    client->afterEncBufLen = (bpp/8);                                                 \\\n                                                                              \\\n    for (y=0; y<h; y++) {                                                     \\\n      line = data+(y*w);                                                      \\\n      for (x=0; x<w; x++) {                                                   \\\n        if (line[x] != bg) {                                                  \\\n          cl = line[x];                                                       \\\n          hy = y-1;                                                           \\\n          hyflag = 1;                                                         \\\n          for (j=y; j<h; j++) {                                               \\\n            seg = data+(j*w);                                                 \\\n            if (seg[x] != cl) {break;}                                        \\\n            i = x;                                                            \\\n            while ((seg[i] == cl) && (i < w)) i += 1;                         \\\n            i -= 1;                                                           \\\n            if (j == y) vx = hx = i;                                          \\\n            if (i < vx) vx = i;                                               \\\n            if ((hyflag > 0) && (i >= hx)) {hy += 1;} else {hyflag = 0;}      \\\n          }                                                                   \\\n          vy = j-1;                                                           \\\n                                                                              \\\n          /*  We now have two possible subrects: (x,y,hx,hy) and (x,y,vx,vy)  \\\n           *  We'll choose the bigger of the two.                             \\\n           */                                                                 \\\n          hw = hx-x+1;                                                        \\\n          hh = hy-y+1;                                                        \\\n          vw = vx-x+1;                                                        \\\n          vh = vy-y+1;                                                        \\\n                                                                              \\\n          thex = x;                                                           \\\n          they = y;                                                           \\\n                                                                              \\\n          if ((hw*hh) > (vw*vh)) {                                            \\\n            thew = hw;                                                        \\\n            theh = hh;                                                        \\\n          } else {                                                            \\\n            thew = vw;                                                        \\\n            theh = vh;                                                        \\\n          }                                                                   \\\n                                                                              \\\n          subrect.x = Swap16IfLE(thex);                                       \\\n          subrect.y = Swap16IfLE(they);                                       \\\n          subrect.w = Swap16IfLE(thew);                                       \\\n          subrect.h = Swap16IfLE(theh);                                       \\\n                                                                              \\\n          newLen = client->afterEncBufLen + (bpp/8) + sz_rfbRectangle;                \\\n          if ((newLen > (w * h * (bpp/8))) || (newLen > client->afterEncBufSize))     \\\n            return -1;                                                        \\\n                                                                              \\\n          numsubs += 1;                                                       \\\n          *((uint##bpp##_t*)(client->afterEncBuf + client->afterEncBufLen)) = cl;             \\\n          client->afterEncBufLen += (bpp/8);                                          \\\n          memcpy(&client->afterEncBuf[client->afterEncBufLen],&subrect,sz_rfbRectangle);      \\\n          client->afterEncBufLen += sz_rfbRectangle;                                  \\\n                                                                              \\\n          /*                                                                  \\\n           * Now mark the subrect as done.                                    \\\n           */                                                                 \\\n          for (j=they; j < (they+theh); j++) {                                \\\n            for (i=thex; i < (thex+thew); i++) {                              \\\n              data[j*w+i] = bg;                                               \\\n            }                                                                 \\\n          }                                                                   \\\n        }                                                                     \\\n      }                                                                       \\\n    }                                                                         \\\n                                                                              \\\n    return numsubs;                                                           \\\n}\n\nDEFINE_SUBRECT_ENCODE(8)\nDEFINE_SUBRECT_ENCODE(16)\nDEFINE_SUBRECT_ENCODE(32)\n\n\n/*\n * getBgColour() gets the most prevalent colour in a byte array.\n */\nstatic uint32_t\ngetBgColour(char *data, int size, int bpp)\n{\n    \n#define NUMCLRS 256\n  \n  static int counts[NUMCLRS];\n  int i,j,k;\n\n  int maxcount = 0;\n  uint8_t maxclr = 0;\n\n  if (bpp != 8) {\n    if (bpp == 16) {\n      return ((uint16_t *)data)[0];\n    } else if (bpp == 32) {\n      return ((uint32_t *)data)[0];\n    } else {\n      rfbLog(\"getBgColour: bpp %d?\\n\",bpp);\n      return 0;\n    }\n  }\n\n  for (i=0; i<NUMCLRS; i++) {\n    counts[i] = 0;\n  }\n\n  for (j=0; j<size; j++) {\n    k = (int)(((uint8_t *)data)[j]);\n    if (k >= NUMCLRS) {\n      rfbErr(\"getBgColour: unusual colour = %d\\n\", k);\n      return 0;\n    }\n    counts[k] += 1;\n    if (counts[k] > maxcount) {\n      maxcount = counts[k];\n      maxclr = ((uint8_t *)data)[j];\n    }\n  }\n  \n  return maxclr;\n}\n"], "fixing_code": ["/*\n * corre.c\n *\n * Routines to implement Compact Rise-and-Run-length Encoding (CoRRE).  This\n * code is based on krw's original javatel rfbserver.\n */\n\n/*\n *  Copyright (C) 2002 RealVNC Ltd.\n *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.\n *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  \n *  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n#include <rfb/rfb.h>\n\n/*\n * cl->beforeEncBuf contains pixel data in the client's format.\n * cl->afterEncBuf contains the RRE encoded version.  If the RRE encoded version is\n * larger than the raw data or if it exceeds cl->afterEncBufSize then\n * raw encoding is used instead.\n */\n\nstatic int subrectEncode8(rfbClientPtr cl, uint8_t *data, int w, int h);\nstatic int subrectEncode16(rfbClientPtr cl, uint16_t *data, int w, int h);\nstatic int subrectEncode32(rfbClientPtr cl, uint32_t *data, int w, int h);\nstatic uint32_t getBgColour(char *data, int size, int bpp);\nstatic rfbBool rfbSendSmallRectEncodingCoRRE(rfbClientPtr cl, int x, int y,\n                                          int w, int h);\n\n\n/*\n * rfbSendRectEncodingCoRRE - send an arbitrary size rectangle using CoRRE\n * encoding.\n */\n\nrfbBool\nrfbSendRectEncodingCoRRE(rfbClientPtr cl,\n                         int x,\n                         int y,\n                         int w,\n                         int h)\n{\n    if (h > cl->correMaxHeight) {\n        return (rfbSendRectEncodingCoRRE(cl, x, y, w, cl->correMaxHeight) &&\n\t\trfbSendRectEncodingCoRRE(cl, x, y + cl->correMaxHeight, w,\n\t\t\t\t\t h - cl->correMaxHeight));\n    }\n\n    if (w > cl->correMaxWidth) {\n        return (rfbSendRectEncodingCoRRE(cl, x, y, cl->correMaxWidth, h) &&\n\t\trfbSendRectEncodingCoRRE(cl, x + cl->correMaxWidth, y,\n\t\t\t\t\t w - cl->correMaxWidth, h));\n    }\n\n    rfbSendSmallRectEncodingCoRRE(cl, x, y, w, h);\n    return TRUE;\n}\n\n\n\n/*\n * rfbSendSmallRectEncodingCoRRE - send a small (guaranteed < 256x256)\n * rectangle using CoRRE encoding.\n */\n\nstatic rfbBool\nrfbSendSmallRectEncodingCoRRE(rfbClientPtr cl,\n                              int x,\n                              int y,\n                              int w,\n                              int h)\n{\n    rfbFramebufferUpdateRectHeader rect;\n    rfbRREHeader hdr;\n    int nSubrects;\n    int i;\n    char *fbptr = (cl->scaledScreen->frameBuffer + (cl->scaledScreen->paddedWidthInBytes * y)\n                   + (x * (cl->scaledScreen->bitsPerPixel / 8)));\n\n    int maxRawSize = (cl->scaledScreen->width * cl->scaledScreen->height\n                      * (cl->format.bitsPerPixel / 8));\n\n    if (cl->beforeEncBufSize < maxRawSize) {\n        cl->beforeEncBufSize = maxRawSize;\n        if (cl->beforeEncBuf == NULL)\n            cl->beforeEncBuf = (char *)malloc(cl->beforeEncBufSize);\n        else\n            cl->beforeEncBuf = (char *)realloc(cl->beforeEncBuf, cl->beforeEncBufSize);\n    }\n\n    if (cl->afterEncBufSize < maxRawSize) {\n        cl->afterEncBufSize = maxRawSize;\n        if (cl->afterEncBuf == NULL)\n            cl->afterEncBuf = (char *)malloc(cl->afterEncBufSize);\n        else\n            cl->afterEncBuf = (char *)realloc(cl->afterEncBuf, cl->afterEncBufSize);\n    }\n\n    (*cl->translateFn)(cl->translateLookupTable,&(cl->screen->serverFormat),\n                       &cl->format, fbptr, cl->beforeEncBuf,\n                       cl->scaledScreen->paddedWidthInBytes, w, h);\n\n    switch (cl->format.bitsPerPixel) {\n    case 8:\n        nSubrects = subrectEncode8(cl, (uint8_t *)cl->beforeEncBuf, w, h);\n        break;\n    case 16:\n        nSubrects = subrectEncode16(cl, (uint16_t *)cl->beforeEncBuf, w, h);\n        break;\n    case 32:\n        nSubrects = subrectEncode32(cl, (uint32_t *)cl->beforeEncBuf, w, h);\n        break;\n    default:\n        rfbLog(\"getBgColour: bpp %d?\\n\",cl->format.bitsPerPixel);\n        return FALSE;\n    }\n        \n    if (nSubrects < 0) {\n\n        /* RRE encoding was too large, use raw */\n\n        return rfbSendRectEncodingRaw(cl, x, y, w, h);\n    }\n\n    rfbStatRecordEncodingSent(cl,rfbEncodingCoRRE,\n        sz_rfbFramebufferUpdateRectHeader + sz_rfbRREHeader + cl->afterEncBufLen,\n        sz_rfbFramebufferUpdateRectHeader + w * h * (cl->format.bitsPerPixel / 8));\n\n    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader + sz_rfbRREHeader\n        > UPDATE_BUF_SIZE)\n    {\n        if (!rfbSendUpdateBuf(cl))\n            return FALSE;\n    }\n\n    rect.r.x = Swap16IfLE(x);\n    rect.r.y = Swap16IfLE(y);\n    rect.r.w = Swap16IfLE(w);\n    rect.r.h = Swap16IfLE(h);\n    rect.encoding = Swap32IfLE(rfbEncodingCoRRE);\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,\n           sz_rfbFramebufferUpdateRectHeader);\n    cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n\n    hdr.nSubrects = Swap32IfLE(nSubrects);\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&hdr, sz_rfbRREHeader);\n    cl->ublen += sz_rfbRREHeader;\n\n    for (i = 0; i < cl->afterEncBufLen;) {\n\n        int bytesToCopy = UPDATE_BUF_SIZE - cl->ublen;\n\n        if (i + bytesToCopy > cl->afterEncBufLen) {\n            bytesToCopy = cl->afterEncBufLen - i;\n        }\n\n        memcpy(&cl->updateBuf[cl->ublen], &cl->afterEncBuf[i], bytesToCopy);\n\n        cl->ublen += bytesToCopy;\n        i += bytesToCopy;\n\n        if (cl->ublen == UPDATE_BUF_SIZE) {\n            if (!rfbSendUpdateBuf(cl))\n                return FALSE;\n        }\n    }\n\n    return TRUE;\n}\n\n\n\n/*\n * subrectEncode() encodes the given multicoloured rectangle as a background \n * colour overwritten by single-coloured rectangles.  It returns the number \n * of subrectangles in the encoded buffer, or -1 if subrect encoding won't\n * fit in the buffer.  It puts the encoded rectangles in cl->afterEncBuf.  The\n * single-colour rectangle partition is not optimal, but does find the biggest\n * horizontal or vertical rectangle top-left anchored to each consecutive \n * coordinate position.\n *\n * The coding scheme is simply [<bgcolour><subrect><subrect>...] where each \n * <subrect> is [<colour><x><y><w><h>].\n */\n\n#define DEFINE_SUBRECT_ENCODE(bpp)                                            \\\nstatic int                                                                    \\\nsubrectEncode##bpp(rfbClientPtr client, uint##bpp##_t *data, int w, int h) {                       \\\n    uint##bpp##_t cl;                                                         \\\n    rfbCoRRERectangle subrect;                                                \\\n    int x,y;                                                                  \\\n    int i,j;                                                                  \\\n    int hx=0,hy,vx=0,vy;                                                      \\\n    int hyflag;                                                               \\\n    uint##bpp##_t *seg;                                                       \\\n    uint##bpp##_t *line;                                                      \\\n    int hw,hh,vw,vh;                                                          \\\n    int thex,they,thew,theh;                                                  \\\n    int numsubs = 0;                                                          \\\n    int newLen;                                                               \\\n    uint##bpp##_t bg = (uint##bpp##_t)getBgColour((char*)data,w*h,bpp);       \\\n                                                                              \\\n    *((uint##bpp##_t*)client->afterEncBuf) = bg;                                      \\\n                                                                              \\\n    client->afterEncBufLen = (bpp/8);                                                 \\\n                                                                              \\\n    for (y=0; y<h; y++) {                                                     \\\n      line = data+(y*w);                                                      \\\n      for (x=0; x<w; x++) {                                                   \\\n        if (line[x] != bg) {                                                  \\\n          cl = line[x];                                                       \\\n          hy = y-1;                                                           \\\n          hyflag = 1;                                                         \\\n          for (j=y; j<h; j++) {                                               \\\n            seg = data+(j*w);                                                 \\\n            if (seg[x] != cl) {break;}                                        \\\n            i = x;                                                            \\\n            while ((i < w) && (seg[i] == cl)) i += 1;                         \\\n            i -= 1;                                                           \\\n            if (j == y) vx = hx = i;                                          \\\n            if (i < vx) vx = i;                                               \\\n            if ((hyflag > 0) && (i >= hx)) {hy += 1;} else {hyflag = 0;}      \\\n          }                                                                   \\\n          vy = j-1;                                                           \\\n                                                                              \\\n          /*  We now have two possible subrects: (x,y,hx,hy) and (x,y,vx,vy)  \\\n           *  We'll choose the bigger of the two.                             \\\n           */                                                                 \\\n          hw = hx-x+1;                                                        \\\n          hh = hy-y+1;                                                        \\\n          vw = vx-x+1;                                                        \\\n          vh = vy-y+1;                                                        \\\n                                                                              \\\n          thex = x;                                                           \\\n          they = y;                                                           \\\n                                                                              \\\n          if ((hw*hh) > (vw*vh)) {                                            \\\n            thew = hw;                                                        \\\n            theh = hh;                                                        \\\n          } else {                                                            \\\n            thew = vw;                                                        \\\n            theh = vh;                                                        \\\n          }                                                                   \\\n                                                                              \\\n          subrect.x = thex;                                                   \\\n          subrect.y = they;                                                   \\\n          subrect.w = thew;                                                   \\\n          subrect.h = theh;                                                   \\\n                                                                              \\\n          newLen = client->afterEncBufLen + (bpp/8) + sz_rfbCoRRERectangle;           \\\n          if ((newLen > (w * h * (bpp/8))) || (newLen > client->afterEncBufSize))     \\\n            return -1;                                                        \\\n                                                                              \\\n          numsubs += 1;                                                       \\\n          *((uint##bpp##_t*)(client->afterEncBuf + client->afterEncBufLen)) = cl;             \\\n          client->afterEncBufLen += (bpp/8);                                          \\\n          memcpy(&client->afterEncBuf[client->afterEncBufLen],&subrect,sz_rfbCoRRERectangle); \\\n          client->afterEncBufLen += sz_rfbCoRRERectangle;                             \\\n                                                                              \\\n          /*                                                                  \\\n           * Now mark the subrect as done.                                    \\\n           */                                                                 \\\n          for (j=they; j < (they+theh); j++) {                                \\\n            for (i=thex; i < (thex+thew); i++) {                              \\\n              data[j*w+i] = bg;                                               \\\n            }                                                                 \\\n          }                                                                   \\\n        }                                                                     \\\n      }                                                                       \\\n    }                                                                         \\\n                                                                              \\\n    return numsubs;                                                           \\\n}\n\nDEFINE_SUBRECT_ENCODE(8)\nDEFINE_SUBRECT_ENCODE(16)\nDEFINE_SUBRECT_ENCODE(32)\n\n\n/*\n * getBgColour() gets the most prevalent colour in a byte array.\n */\nstatic uint32_t\ngetBgColour(char *data, int size, int bpp)\n{\n\n#define NUMCLRS 256\n  \n  static int counts[NUMCLRS];\n  int i,j,k;\n\n  int maxcount = 0;\n  uint8_t maxclr = 0;\n\n  if (bpp != 8) {\n    if (bpp == 16) {\n      return ((uint16_t *)data)[0];\n    } else if (bpp == 32) {\n      return ((uint32_t *)data)[0];\n    } else {\n      rfbLog(\"getBgColour: bpp %d?\\n\",bpp);\n      return 0;\n    }\n  }\n\n  for (i=0; i<NUMCLRS; i++) {\n    counts[i] = 0;\n  }\n\n  for (j=0; j<size; j++) {\n    k = (int)(((uint8_t *)data)[j]);\n    if (k >= NUMCLRS) {\n      rfbLog(\"getBgColour: unusual colour = %d\\n\", k);\n      return 0;\n    }\n    counts[k] += 1;\n    if (counts[k] > maxcount) {\n      maxcount = counts[k];\n      maxclr = ((uint8_t *)data)[j];\n    }\n  }\n  \n  return maxclr;\n}\n", "/*\n * hextile.c\n *\n * Routines to implement Hextile Encoding\n */\n\n/*\n *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.\n *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  \n *  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n#include <rfb/rfb.h>\n\nstatic rfbBool sendHextiles8(rfbClientPtr cl, int x, int y, int w, int h);\nstatic rfbBool sendHextiles16(rfbClientPtr cl, int x, int y, int w, int h);\nstatic rfbBool sendHextiles32(rfbClientPtr cl, int x, int y, int w, int h);\n\n\n/*\n * rfbSendRectEncodingHextile - send a rectangle using hextile encoding.\n */\n\nrfbBool\nrfbSendRectEncodingHextile(rfbClientPtr cl,\n                           int x,\n                           int y,\n                           int w,\n                           int h)\n{\n    rfbFramebufferUpdateRectHeader rect;\n    \n    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader > UPDATE_BUF_SIZE) {\n        if (!rfbSendUpdateBuf(cl))\n            return FALSE;\n    }\n\n    rect.r.x = Swap16IfLE(x);\n    rect.r.y = Swap16IfLE(y);\n    rect.r.w = Swap16IfLE(w);\n    rect.r.h = Swap16IfLE(h);\n    rect.encoding = Swap32IfLE(rfbEncodingHextile);\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,\n           sz_rfbFramebufferUpdateRectHeader);\n    cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n\n    rfbStatRecordEncodingSent(cl, rfbEncodingHextile,\n          sz_rfbFramebufferUpdateRectHeader,\n          sz_rfbFramebufferUpdateRectHeader + w * (cl->format.bitsPerPixel / 8) * h);\n\n    switch (cl->format.bitsPerPixel) {\n    case 8:\n        return sendHextiles8(cl, x, y, w, h);\n    case 16:\n        return sendHextiles16(cl, x, y, w, h);\n    case 32:\n        return sendHextiles32(cl, x, y, w, h);\n    }\n\n    rfbLog(\"rfbSendRectEncodingHextile: bpp %d?\\n\", cl->format.bitsPerPixel);\n    return FALSE;\n}\n\n\n#define PUT_PIXEL8(pix) (cl->updateBuf[cl->ublen++] = (pix))\n\n#define PUT_PIXEL16(pix) (cl->updateBuf[cl->ublen++] = ((char*)&(pix))[0], \\\n                          cl->updateBuf[cl->ublen++] = ((char*)&(pix))[1])\n\n#define PUT_PIXEL32(pix) (cl->updateBuf[cl->ublen++] = ((char*)&(pix))[0], \\\n                          cl->updateBuf[cl->ublen++] = ((char*)&(pix))[1], \\\n                          cl->updateBuf[cl->ublen++] = ((char*)&(pix))[2], \\\n                          cl->updateBuf[cl->ublen++] = ((char*)&(pix))[3])\n\n\n#define DEFINE_SEND_HEXTILES(bpp)                                               \\\n                                                                                \\\n                                                                                \\\nstatic rfbBool subrectEncode##bpp(rfbClientPtr cli, uint##bpp##_t *data,        \\\n\t\tint w, int h, uint##bpp##_t bg, uint##bpp##_t fg, rfbBool mono);\\\nstatic void testColours##bpp(uint##bpp##_t *data, int size, rfbBool *mono,      \\\n                  rfbBool *solid, uint##bpp##_t *bg, uint##bpp##_t *fg);        \\\n                                                                                \\\n                                                                                \\\n/*                                                                              \\\n * rfbSendHextiles                                                              \\\n */                                                                             \\\n                                                                                \\\nstatic rfbBool                                                                  \\\nsendHextiles##bpp(rfbClientPtr cl, int rx, int ry, int rw, int rh) {            \\\n    int x, y, w, h;                                                             \\\n    int startUblen;                                                             \\\n    char *fbptr;                                                                \\\n    uint##bpp##_t bg = 0, fg = 0, newBg, newFg;                                 \\\n    rfbBool mono, solid;                                                        \\\n    rfbBool validBg = FALSE;                                                    \\\n    rfbBool validFg = FALSE;                                                    \\\n    uint##bpp##_t clientPixelData[16*16*(bpp/8)];                               \\\n                                                                                \\\n    for (y = ry; y < ry+rh; y += 16) {                                          \\\n        for (x = rx; x < rx+rw; x += 16) {                                      \\\n            w = h = 16;                                                         \\\n            if (rx+rw - x < 16)                                                 \\\n                w = rx+rw - x;                                                  \\\n            if (ry+rh - y < 16)                                                 \\\n                h = ry+rh - y;                                                  \\\n                                                                                \\\n            if ((cl->ublen + 1 + (2 + 16 * 16) * (bpp/8)) >                     \\\n                UPDATE_BUF_SIZE) {                                              \\\n                if (!rfbSendUpdateBuf(cl))                                      \\\n                    return FALSE;                                               \\\n            }                                                                   \\\n                                                                                \\\n            fbptr = (cl->scaledScreen->frameBuffer + (cl->scaledScreen->paddedWidthInBytes * y)   \\\n                     + (x * (cl->scaledScreen->bitsPerPixel / 8)));                   \\\n                                                                                \\\n            (*cl->translateFn)(cl->translateLookupTable, &(cl->screen->serverFormat),      \\\n                               &cl->format, fbptr, (char *)clientPixelData,     \\\n                               cl->scaledScreen->paddedWidthInBytes, w, h);           \\\n                                                                                \\\n            startUblen = cl->ublen;                                             \\\n            cl->updateBuf[startUblen] = 0;                                      \\\n            cl->ublen++;                                                        \\\n            rfbStatRecordEncodingSentAdd(cl, rfbEncodingHextile, 1);            \\\n                                                                                \\\n            testColours##bpp(clientPixelData, w * h,                            \\\n                             &mono, &solid, &newBg, &newFg);                    \\\n                                                                                \\\n            if (!validBg || (newBg != bg)) {                                    \\\n                validBg = TRUE;                                                 \\\n                bg = newBg;                                                     \\\n                cl->updateBuf[startUblen] |= rfbHextileBackgroundSpecified;     \\\n                PUT_PIXEL##bpp(bg);                                             \\\n            }                                                                   \\\n                                                                                \\\n            if (solid) {                                                        \\\n                continue;                                                       \\\n            }                                                                   \\\n                                                                                \\\n            cl->updateBuf[startUblen] |= rfbHextileAnySubrects;                 \\\n                                                                                \\\n            if (mono) {                                                         \\\n                if (!validFg || (newFg != fg)) {                                \\\n                    validFg = TRUE;                                             \\\n                    fg = newFg;                                                 \\\n                    cl->updateBuf[startUblen] |= rfbHextileForegroundSpecified; \\\n                    PUT_PIXEL##bpp(fg);                                         \\\n                }                                                               \\\n            } else {                                                            \\\n                validFg = FALSE;                                                \\\n                cl->updateBuf[startUblen] |= rfbHextileSubrectsColoured;        \\\n            }                                                                   \\\n                                                                                \\\n            if (!subrectEncode##bpp(cl, clientPixelData, w, h, bg, fg, mono)) { \\\n                /* encoding was too large, use raw */                           \\\n                validBg = FALSE;                                                \\\n                validFg = FALSE;                                                \\\n                cl->ublen = startUblen;                                         \\\n                cl->updateBuf[cl->ublen++] = rfbHextileRaw;                     \\\n                (*cl->translateFn)(cl->translateLookupTable,                    \\\n                                   &(cl->screen->serverFormat), &cl->format, fbptr,        \\\n                                   (char *)clientPixelData,                     \\\n                                   cl->scaledScreen->paddedWidthInBytes, w, h); \\\n                                                                                \\\n                memcpy(&cl->updateBuf[cl->ublen], (char *)clientPixelData,      \\\n                       w * h * (bpp/8));                                        \\\n                                                                                \\\n                cl->ublen += w * h * (bpp/8);                                   \\\n                rfbStatRecordEncodingSentAdd(cl, rfbEncodingHextile,            \\\n                             w * h * (bpp/8));                                  \\\n            }                                                                   \\\n        }                                                                       \\\n    }                                                                           \\\n                                                                                \\\n    return TRUE;                                                                \\\n}                                                                               \\\n                                                                                \\\n                                                                                \\\nstatic rfbBool                                                                  \\\nsubrectEncode##bpp(rfbClientPtr cl, uint##bpp##_t *data, int w, int h,          \\\n                   uint##bpp##_t bg, uint##bpp##_t fg, rfbBool mono)            \\\n{                                                                               \\\n    uint##bpp##_t cl2;                                                          \\\n    int x,y;                                                                    \\\n    int i,j;                                                                    \\\n    int hx=0,hy,vx=0,vy;                                                        \\\n    int hyflag;                                                                 \\\n    uint##bpp##_t *seg;                                                         \\\n    uint##bpp##_t *line;                                                        \\\n    int hw,hh,vw,vh;                                                            \\\n    int thex,they,thew,theh;                                                    \\\n    int numsubs = 0;                                                            \\\n    int newLen;                                                                 \\\n    int nSubrectsUblen;                                                         \\\n                                                                                \\\n    nSubrectsUblen = cl->ublen;                                                 \\\n    cl->ublen++;                                                                \\\n    rfbStatRecordEncodingSentAdd(cl, rfbEncodingHextile, 1);                    \\\n                                                                                \\\n    for (y=0; y<h; y++) {                                                       \\\n        line = data+(y*w);                                                      \\\n        for (x=0; x<w; x++) {                                                   \\\n            if (line[x] != bg) {                                                \\\n                cl2 = line[x];                                                  \\\n                hy = y-1;                                                       \\\n                hyflag = 1;                                                     \\\n                for (j=y; j<h; j++) {                                           \\\n                    seg = data+(j*w);                                           \\\n                    if (seg[x] != cl2) {break;}                                 \\\n                    i = x;                                                      \\\n                    while ((i < w) && (seg[i] == cl2)) i += 1;                  \\\n                    i -= 1;                                                     \\\n                    if (j == y) vx = hx = i;                                    \\\n                    if (i < vx) vx = i;                                         \\\n                    if ((hyflag > 0) && (i >= hx)) {                            \\\n                        hy += 1;                                                \\\n                    } else {                                                    \\\n                        hyflag = 0;                                             \\\n                    }                                                           \\\n                }                                                               \\\n                vy = j-1;                                                       \\\n                                                                                \\\n                /* We now have two possible subrects: (x,y,hx,hy) and           \\\n                 * (x,y,vx,vy).  We'll choose the bigger of the two.            \\\n                 */                                                             \\\n                hw = hx-x+1;                                                    \\\n                hh = hy-y+1;                                                    \\\n                vw = vx-x+1;                                                    \\\n                vh = vy-y+1;                                                    \\\n                                                                                \\\n                thex = x;                                                       \\\n                they = y;                                                       \\\n                                                                                \\\n                if ((hw*hh) > (vw*vh)) {                                        \\\n                    thew = hw;                                                  \\\n                    theh = hh;                                                  \\\n                } else {                                                        \\\n                    thew = vw;                                                  \\\n                    theh = vh;                                                  \\\n                }                                                               \\\n                                                                                \\\n                if (mono) {                                                     \\\n                    newLen = cl->ublen - nSubrectsUblen + 2;                    \\\n                } else {                                                        \\\n                    newLen = cl->ublen - nSubrectsUblen + bpp/8 + 2;            \\\n                }                                                               \\\n                                                                                \\\n                if (newLen > (w * h * (bpp/8)))                                 \\\n                    return FALSE;                                               \\\n                                                                                \\\n                numsubs += 1;                                                   \\\n                                                                                \\\n                if (!mono) PUT_PIXEL##bpp(cl2);                                 \\\n                                                                                \\\n                cl->updateBuf[cl->ublen++] = rfbHextilePackXY(thex,they);       \\\n                cl->updateBuf[cl->ublen++] = rfbHextilePackWH(thew,theh);       \\\n                rfbStatRecordEncodingSentAdd(cl, rfbEncodingHextile, 1);        \\\n                                                                                \\\n                /*                                                              \\\n                 * Now mark the subrect as done.                                \\\n                 */                                                             \\\n                for (j=they; j < (they+theh); j++) {                            \\\n                    for (i=thex; i < (thex+thew); i++) {                        \\\n                        data[j*w+i] = bg;                                       \\\n                    }                                                           \\\n                }                                                               \\\n            }                                                                   \\\n        }                                                                       \\\n    }                                                                           \\\n                                                                                \\\n    cl->updateBuf[nSubrectsUblen] = numsubs;                                    \\\n                                                                                \\\n    return TRUE;                                                                \\\n}                                                                               \\\n                                                                                \\\n                                                                                \\\n/*                                                                              \\\n * testColours() tests if there are one (solid), two (mono) or more             \\\n * colours in a tile and gets a reasonable guess at the best background         \\\n * pixel, and the foreground pixel for mono.                                    \\\n */                                                                             \\\n                                                                                \\\nstatic void                                                                     \\\ntestColours##bpp(uint##bpp##_t *data, int size, rfbBool *mono, rfbBool *solid,  \\\n                 uint##bpp##_t *bg, uint##bpp##_t *fg) {                        \\\n    uint##bpp##_t colour1 = 0, colour2 = 0;                                     \\\n    int n1 = 0, n2 = 0;                                                         \\\n    *mono = TRUE;                                                               \\\n    *solid = TRUE;                                                              \\\n                                                                                \\\n    for (; size > 0; size--, data++) {                                          \\\n                                                                                \\\n        if (n1 == 0)                                                            \\\n            colour1 = *data;                                                    \\\n                                                                                \\\n        if (*data == colour1) {                                                 \\\n            n1++;                                                               \\\n            continue;                                                           \\\n        }                                                                       \\\n                                                                                \\\n        if (n2 == 0) {                                                          \\\n            *solid = FALSE;                                                     \\\n            colour2 = *data;                                                    \\\n        }                                                                       \\\n                                                                                \\\n        if (*data == colour2) {                                                 \\\n            n2++;                                                               \\\n            continue;                                                           \\\n        }                                                                       \\\n                                                                                \\\n        *mono = FALSE;                                                          \\\n        break;                                                                  \\\n    }                                                                           \\\n                                                                                \\\n    if (n1 > n2) {                                                              \\\n        *bg = colour1;                                                          \\\n        *fg = colour2;                                                          \\\n    } else {                                                                    \\\n        *bg = colour2;                                                          \\\n        *fg = colour1;                                                          \\\n    }                                                                           \\\n}\n\nDEFINE_SEND_HEXTILES(8)\nDEFINE_SEND_HEXTILES(16)\nDEFINE_SEND_HEXTILES(32)\n", "/*\n * rre.c\n *\n * Routines to implement Rise-and-Run-length Encoding (RRE).  This\n * code is based on krw's original javatel rfbserver.\n */\n\n/*\n *  OSXvnc Copyright (C) 2001 Dan McGuirk <mcguirk@incompleteness.net>.\n *  Original Xvnc code Copyright (C) 1999 AT&T Laboratories Cambridge.  \n *  All Rights Reserved.\n *\n *  This is free software; you can redistribute it and/or modify\n *  it under the terms of the GNU General Public License as published by\n *  the Free Software Foundation; either version 2 of the License, or\n *  (at your option) any later version.\n *\n *  This software is distributed in the hope that it will be useful,\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *  GNU General Public License for more details.\n *\n *  You should have received a copy of the GNU General Public License\n *  along with this software; if not, write to the Free Software\n *  Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n *  USA.\n */\n\n#include <rfb/rfb.h>\n\n/*\n * cl->beforeEncBuf contains pixel data in the client's format.\n * cl->afterEncBuf contains the RRE encoded version.  If the RRE encoded version is\n * larger than the raw data or if it exceeds cl->afterEncBufSize then\n * raw encoding is used instead.\n */\n\nstatic int subrectEncode8(rfbClientPtr cl, uint8_t *data, int w, int h);\nstatic int subrectEncode16(rfbClientPtr cl, uint16_t *data, int w, int h);\nstatic int subrectEncode32(rfbClientPtr cl, uint32_t *data, int w, int h);\nstatic uint32_t getBgColour(char *data, int size, int bpp);\n\n\n/*\n * rfbSendRectEncodingRRE - send a given rectangle using RRE encoding.\n */\n\nrfbBool\nrfbSendRectEncodingRRE(rfbClientPtr cl,\n                       int x,\n                       int y,\n                       int w,\n                       int h)\n{\n    rfbFramebufferUpdateRectHeader rect;\n    rfbRREHeader hdr;\n    int nSubrects;\n    int i;\n    char *fbptr = (cl->scaledScreen->frameBuffer + (cl->scaledScreen->paddedWidthInBytes * y)\n                   + (x * (cl->scaledScreen->bitsPerPixel / 8)));\n\n    int maxRawSize = (cl->scaledScreen->width * cl->scaledScreen->height\n                      * (cl->format.bitsPerPixel / 8));\n\n    if (cl->beforeEncBufSize < maxRawSize) {\n        cl->beforeEncBufSize = maxRawSize;\n        if (cl->beforeEncBuf == NULL)\n            cl->beforeEncBuf = (char *)malloc(cl->beforeEncBufSize);\n        else\n            cl->beforeEncBuf = (char *)realloc(cl->beforeEncBuf, cl->beforeEncBufSize);\n    }\n\n    if (cl->afterEncBufSize < maxRawSize) {\n        cl->afterEncBufSize = maxRawSize;\n        if (cl->afterEncBuf == NULL)\n            cl->afterEncBuf = (char *)malloc(cl->afterEncBufSize);\n        else\n            cl->afterEncBuf = (char *)realloc(cl->afterEncBuf, cl->afterEncBufSize);\n    }\n\n    (*cl->translateFn)(cl->translateLookupTable,\n\t\t       &(cl->screen->serverFormat),\n                       &cl->format, fbptr, cl->beforeEncBuf,\n                       cl->scaledScreen->paddedWidthInBytes, w, h);\n\n    switch (cl->format.bitsPerPixel) {\n    case 8:\n        nSubrects = subrectEncode8(cl, (uint8_t *)cl->beforeEncBuf, w, h);\n        break;\n    case 16:\n        nSubrects = subrectEncode16(cl, (uint16_t *)cl->beforeEncBuf, w, h);\n        break;\n    case 32:\n        nSubrects = subrectEncode32(cl, (uint32_t *)cl->beforeEncBuf, w, h);\n        break;\n    default:\n        rfbLog(\"getBgColour: bpp %d?\\n\",cl->format.bitsPerPixel);\n        return FALSE;\n    }\n        \n    if (nSubrects < 0) {\n\n        /* RRE encoding was too large, use raw */\n\n        return rfbSendRectEncodingRaw(cl, x, y, w, h);\n    }\n\n    rfbStatRecordEncodingSent(cl, rfbEncodingRRE,\n                              sz_rfbFramebufferUpdateRectHeader + sz_rfbRREHeader + cl->afterEncBufLen,\n                              sz_rfbFramebufferUpdateRectHeader + w * h * (cl->format.bitsPerPixel / 8));\n\n    if (cl->ublen + sz_rfbFramebufferUpdateRectHeader + sz_rfbRREHeader\n        > UPDATE_BUF_SIZE)\n    {\n        if (!rfbSendUpdateBuf(cl))\n            return FALSE;\n    }\n\n    rect.r.x = Swap16IfLE(x);\n    rect.r.y = Swap16IfLE(y);\n    rect.r.w = Swap16IfLE(w);\n    rect.r.h = Swap16IfLE(h);\n    rect.encoding = Swap32IfLE(rfbEncodingRRE);\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&rect,\n           sz_rfbFramebufferUpdateRectHeader);\n    cl->ublen += sz_rfbFramebufferUpdateRectHeader;\n\n    hdr.nSubrects = Swap32IfLE(nSubrects);\n\n    memcpy(&cl->updateBuf[cl->ublen], (char *)&hdr, sz_rfbRREHeader);\n    cl->ublen += sz_rfbRREHeader;\n\n    for (i = 0; i < cl->afterEncBufLen;) {\n\n        int bytesToCopy = UPDATE_BUF_SIZE - cl->ublen;\n\n        if (i + bytesToCopy > cl->afterEncBufLen) {\n            bytesToCopy = cl->afterEncBufLen - i;\n        }\n\n        memcpy(&cl->updateBuf[cl->ublen], &cl->afterEncBuf[i], bytesToCopy);\n\n        cl->ublen += bytesToCopy;\n        i += bytesToCopy;\n\n        if (cl->ublen == UPDATE_BUF_SIZE) {\n            if (!rfbSendUpdateBuf(cl))\n                return FALSE;\n        }\n    }\n\n    return TRUE;\n}\n\n\n\n/*\n * subrectEncode() encodes the given multicoloured rectangle as a background \n * colour overwritten by single-coloured rectangles.  It returns the number \n * of subrectangles in the encoded buffer, or -1 if subrect encoding won't\n * fit in the buffer.  It puts the encoded rectangles in cl->afterEncBuf.  The\n * single-colour rectangle partition is not optimal, but does find the biggest\n * horizontal or vertical rectangle top-left anchored to each consecutive \n * coordinate position.\n *\n * The coding scheme is simply [<bgcolour><subrect><subrect>...] where each \n * <subrect> is [<colour><x><y><w><h>].\n */\n\n#define DEFINE_SUBRECT_ENCODE(bpp)                                            \\\nstatic int                                                                    \\\n subrectEncode##bpp(rfbClientPtr client, uint##bpp##_t *data, int w, int h) { \\\n    uint##bpp##_t cl;                                                         \\\n    rfbRectangle subrect;                                                     \\\n    int x,y;                                                                  \\\n    int i,j;                                                                  \\\n    int hx=0,hy,vx=0,vy;                                                      \\\n    int hyflag;                                                               \\\n    uint##bpp##_t *seg;                                                       \\\n    uint##bpp##_t *line;                                                      \\\n    int hw,hh,vw,vh;                                                          \\\n    int thex,they,thew,theh;                                                  \\\n    int numsubs = 0;                                                          \\\n    int newLen;                                                               \\\n    uint##bpp##_t bg = (uint##bpp##_t)getBgColour((char*)data,w*h,bpp);       \\\n                                                                              \\\n    *((uint##bpp##_t*)client->afterEncBuf) = bg;                                      \\\n                                                                              \\\n    client->afterEncBufLen = (bpp/8);                                                 \\\n                                                                              \\\n    for (y=0; y<h; y++) {                                                     \\\n      line = data+(y*w);                                                      \\\n      for (x=0; x<w; x++) {                                                   \\\n        if (line[x] != bg) {                                                  \\\n          cl = line[x];                                                       \\\n          hy = y-1;                                                           \\\n          hyflag = 1;                                                         \\\n          for (j=y; j<h; j++) {                                               \\\n            seg = data+(j*w);                                                 \\\n            if (seg[x] != cl) {break;}                                        \\\n            i = x;                                                            \\\n            while ((i < w) && (seg[i] == cl)) i += 1;                         \\\n            i -= 1;                                                           \\\n            if (j == y) vx = hx = i;                                          \\\n            if (i < vx) vx = i;                                               \\\n            if ((hyflag > 0) && (i >= hx)) {hy += 1;} else {hyflag = 0;}      \\\n          }                                                                   \\\n          vy = j-1;                                                           \\\n                                                                              \\\n          /*  We now have two possible subrects: (x,y,hx,hy) and (x,y,vx,vy)  \\\n           *  We'll choose the bigger of the two.                             \\\n           */                                                                 \\\n          hw = hx-x+1;                                                        \\\n          hh = hy-y+1;                                                        \\\n          vw = vx-x+1;                                                        \\\n          vh = vy-y+1;                                                        \\\n                                                                              \\\n          thex = x;                                                           \\\n          they = y;                                                           \\\n                                                                              \\\n          if ((hw*hh) > (vw*vh)) {                                            \\\n            thew = hw;                                                        \\\n            theh = hh;                                                        \\\n          } else {                                                            \\\n            thew = vw;                                                        \\\n            theh = vh;                                                        \\\n          }                                                                   \\\n                                                                              \\\n          subrect.x = Swap16IfLE(thex);                                       \\\n          subrect.y = Swap16IfLE(they);                                       \\\n          subrect.w = Swap16IfLE(thew);                                       \\\n          subrect.h = Swap16IfLE(theh);                                       \\\n                                                                              \\\n          newLen = client->afterEncBufLen + (bpp/8) + sz_rfbRectangle;                \\\n          if ((newLen > (w * h * (bpp/8))) || (newLen > client->afterEncBufSize))     \\\n            return -1;                                                        \\\n                                                                              \\\n          numsubs += 1;                                                       \\\n          *((uint##bpp##_t*)(client->afterEncBuf + client->afterEncBufLen)) = cl;             \\\n          client->afterEncBufLen += (bpp/8);                                          \\\n          memcpy(&client->afterEncBuf[client->afterEncBufLen],&subrect,sz_rfbRectangle);      \\\n          client->afterEncBufLen += sz_rfbRectangle;                                  \\\n                                                                              \\\n          /*                                                                  \\\n           * Now mark the subrect as done.                                    \\\n           */                                                                 \\\n          for (j=they; j < (they+theh); j++) {                                \\\n            for (i=thex; i < (thex+thew); i++) {                              \\\n              data[j*w+i] = bg;                                               \\\n            }                                                                 \\\n          }                                                                   \\\n        }                                                                     \\\n      }                                                                       \\\n    }                                                                         \\\n                                                                              \\\n    return numsubs;                                                           \\\n}\n\nDEFINE_SUBRECT_ENCODE(8)\nDEFINE_SUBRECT_ENCODE(16)\nDEFINE_SUBRECT_ENCODE(32)\n\n\n/*\n * getBgColour() gets the most prevalent colour in a byte array.\n */\nstatic uint32_t\ngetBgColour(char *data, int size, int bpp)\n{\n    \n#define NUMCLRS 256\n  \n  static int counts[NUMCLRS];\n  int i,j,k;\n\n  int maxcount = 0;\n  uint8_t maxclr = 0;\n\n  if (bpp != 8) {\n    if (bpp == 16) {\n      return ((uint16_t *)data)[0];\n    } else if (bpp == 32) {\n      return ((uint32_t *)data)[0];\n    } else {\n      rfbLog(\"getBgColour: bpp %d?\\n\",bpp);\n      return 0;\n    }\n  }\n\n  for (i=0; i<NUMCLRS; i++) {\n    counts[i] = 0;\n  }\n\n  for (j=0; j<size; j++) {\n    k = (int)(((uint8_t *)data)[j]);\n    if (k >= NUMCLRS) {\n      rfbErr(\"getBgColour: unusual colour = %d\\n\", k);\n      return 0;\n    }\n    counts[k] += 1;\n    if (counts[k] > maxcount) {\n      maxcount = counts[k];\n      maxclr = ((uint8_t *)data)[j];\n    }\n  }\n  \n  return maxclr;\n}\n"], "filenames": ["libvncserver/corre.c", "libvncserver/hextile.c", "libvncserver/rre.c"], "buggy_code_start_loc": [236, 227, 203], "buggy_code_end_loc": [237, 228, 204], "fixing_code_start_loc": [236, 227, 203], "fixing_code_end_loc": [237, 228, 204], "type": "CWE-787", "message": "An issue was discovered in LibVNCServer before 0.9.13. libvncserver/rre.c allows out-of-bounds access via encodings.", "other": {"cve": {"id": "CVE-2020-14404", "sourceIdentifier": "cve@mitre.org", "published": "2020-06-17T16:15:12.290", "lastModified": "2022-03-09T22:18:50.803", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "An issue was discovered in LibVNCServer before 0.9.13. libvncserver/rre.c allows out-of-bounds access via encodings."}, {"lang": "es", "value": "Se detect\u00f3 un problema en LibVNCServer versiones anteriores a 0.9.13. La biblioteca libvncserver/rre.c permite un acceso fuera de l\u00edmites por medio de codificaciones"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libvnc_project:libvncserver:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.9.12", "matchCriteriaId": "DEF1BF44-78B8-44E3-9A5A-29AB8111322B"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:14.04:*:*:*:lts:*:*:*", "matchCriteriaId": "B5A6F2F3-4894-4392-8296-3B8DD2679084"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:lts:*:*:*", "matchCriteriaId": "F7016A2A-8365-4F1A-89A2-7A19F2BCAE5B"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.10:*:*:*:*:*:*:*", "matchCriteriaId": "07C312A0-CD2C-4B9C-B064-6409B25C278F"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1500_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "3A664216-EEA0-423F-8E11-59C746FDEEFE"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1500:-:*:*:*:*:*:*:*", "matchCriteriaId": "9596C8CD-B03F-4E9D-82AB-0986FDD1B47C"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1500_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "CD78291E-48D8-4718-AE14-BDF93BD557D7"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1500_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "5BB898D3-07A3-42A1-8F1B-53C3B005982D"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1900_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "AD1209DE-2724-493D-8276-1BE959BFE6BF"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1900:-:*:*:*:*:*:*:*", "matchCriteriaId": "6A9143A6-A93A-45CA-8A1F-6EE30647B54A"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc1900_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "92F7FC17-F19F-4BD6-9704-49B67D22B532"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc1900_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "3D34BD13-4E71-48A2-851D-AE7CE2A03C28"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc2200_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "FE4A6F13-385B-4A13-B8D8-3BBC4E9D5B67"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc2200:-:*:*:*:*:*:*:*", "matchCriteriaId": "3E63E423-7450-4043-B33B-3FFF5BBE1CB2"}]}]}, {"operator": "AND", "nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:siemens:simatic_itc2200_pro_firmware:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.0.0.0", "versionEndExcluding": "3.2.1.0", "matchCriteriaId": "71A51CA4-1A62-47BC-99A3-4DC9F3986FF5"}]}, {"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": false, "criteria": "cpe:2.3:h:siemens:simatic_itc2200_pro:-:*:*:*:*:*:*:*", "matchCriteriaId": "CD278558-AB0E-4FC1-9E5B-6B57D29CB86A"}]}]}], "references": [{"url": "https://cert-portal.siemens.com/productcert/pdf/ssa-390195.pdf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibVNC/libvncserver/commit/74e8a70f2c9a5248d6718ce443e07c7ed314dfff", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibVNC/libvncserver/compare/LibVNCServer-0.9.12...LibVNCServer-0.9.13", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00035.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/08/msg00045.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4434-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4573-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibVNC/libvncserver/commit/74e8a70f2c9a5248d6718ce443e07c7ed314dfff"}}