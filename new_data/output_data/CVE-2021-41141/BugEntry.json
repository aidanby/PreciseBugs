{"buggy_code": ["/*\n * Copyright (C)2020 Teluu Inc. (http://www.teluu.com)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n#include <pjmedia-codec/and_aud_mediacodec.h>\n#include <pjmedia-codec/amr_sdp_match.h>\n#include <pjmedia/codec.h>\n#include <pjmedia/errno.h>\n#include <pjmedia/endpoint.h>\n#include <pjmedia/plc.h>\n#include <pjmedia/port.h>\n#include <pjmedia/silencedet.h>\n#include <pj/assert.h>\n#include <pj/log.h>\n#include <pj/math.h>\n#include <pj/pool.h>\n#include <pj/string.h>\n#include <pj/os.h>\n\n/*\n * Only build this file if PJMEDIA_HAS_ANDROID_MEDIACODEC != 0\n */\n#if defined(PJMEDIA_HAS_ANDROID_MEDIACODEC) && \\\n            PJMEDIA_HAS_ANDROID_MEDIACODEC != 0\n\n/* Android AMediaCodec: */\n#include \"media/NdkMediaCodec.h\"\n\n#define THIS_FILE  \"and_aud_mediacodec.cpp\"\n\n#define AND_MEDIA_KEY_PCM_ENCODING       \"pcm-encoding\"\n#define AND_MEDIA_KEY_CHANNEL_COUNT      \"channel-count\"\n#define AND_MEDIA_KEY_SAMPLE_RATE        \"sample-rate\"\n#define AND_MEDIA_KEY_BITRATE            \"bitrate\"\n#define AND_MEDIA_KEY_MIME               \"mime\"\n\n#define CODEC_WAIT_RETRY \t10\n#define CODEC_THREAD_WAIT \t10\n/* Timeout until the buffer is ready in ms. */\n#define CODEC_DEQUEUE_TIMEOUT \t10\n\n/* Prototypes for Android MediaCodec codecs factory */\nstatic pj_status_t and_media_test_alloc(pjmedia_codec_factory *factory,\n\t\t\t\t\tconst pjmedia_codec_info *id );\nstatic pj_status_t and_media_default_attr(pjmedia_codec_factory *factory,\n\t\t\t\t\t  const pjmedia_codec_info *id,\n\t\t\t\t\t  pjmedia_codec_param *attr );\nstatic pj_status_t and_media_enum_codecs(pjmedia_codec_factory *factory,\n\t\t\t\t\t unsigned *count,\n\t\t\t\t\t pjmedia_codec_info codecs[]);\nstatic pj_status_t and_media_alloc_codec(pjmedia_codec_factory *factory,\n\t\t\t\t\t const pjmedia_codec_info *id,\n\t\t\t\t\t pjmedia_codec **p_codec);\nstatic pj_status_t and_media_dealloc_codec(pjmedia_codec_factory *factory,\n\t\t\t\t\t   pjmedia_codec *codec );\n\n/* Prototypes for Android MediaCodec codecs implementation. */\nstatic pj_status_t  and_media_codec_init(pjmedia_codec *codec,\n\t\t\t\t\t pj_pool_t *pool );\nstatic pj_status_t  and_media_codec_open(pjmedia_codec *codec,\n\t\t\t\t\t pjmedia_codec_param *attr );\nstatic pj_status_t  and_media_codec_close(pjmedia_codec *codec );\nstatic pj_status_t  and_media_codec_modify(pjmedia_codec *codec,\n\t\t\t\t\t   const pjmedia_codec_param *attr );\nstatic pj_status_t  and_media_codec_parse(pjmedia_codec *codec,\n\t\t\t\t\t  void *pkt,\n\t\t\t\t\t  pj_size_t pkt_size,\n\t\t\t\t\t  const pj_timestamp *ts,\n\t\t\t\t\t  unsigned *frame_cnt,\n\t\t\t\t\t  pjmedia_frame frames[]);\nstatic pj_status_t  and_media_codec_encode(pjmedia_codec *codec,\n\t\t\t\t\t   const struct pjmedia_frame *input,\n\t\t\t\t\t   unsigned output_buf_len,\n\t\t\t\t\t   struct pjmedia_frame *output);\nstatic pj_status_t  and_media_codec_decode(pjmedia_codec *codec,\n\t\t\t\t\t   const struct pjmedia_frame *input,\n\t\t\t\t\t   unsigned output_buf_len,\n\t\t\t\t\t   struct pjmedia_frame *output);\nstatic pj_status_t  and_media_codec_recover(pjmedia_codec *codec,\n\t\t\t\t\t    unsigned output_buf_len,\n\t\t\t\t\t    struct pjmedia_frame *output);\n\n/* Definition for Android MediaCodec codecs operations. */\nstatic pjmedia_codec_op and_media_op =\n{\n    &and_media_codec_init,\n    &and_media_codec_open,\n    &and_media_codec_close,\n    &and_media_codec_modify,\n    &and_media_codec_parse,\n    &and_media_codec_encode,\n    &and_media_codec_decode,\n    &and_media_codec_recover\n};\n\n/* Definition for Android MediaCodec codecs factory operations. */\nstatic pjmedia_codec_factory_op and_media_factory_op =\n{\n    &and_media_test_alloc,\n    &and_media_default_attr,\n    &and_media_enum_codecs,\n    &and_media_alloc_codec,\n    &and_media_dealloc_codec,\n    &pjmedia_codec_and_media_aud_deinit\n};\n\n/* Android MediaCodec codecs factory */\nstatic struct and_media_factory {\n    pjmedia_codec_factory    base;\n    pjmedia_endpt\t    *endpt;\n    pj_pool_t\t\t    *pool;\n    pj_mutex_t        \t    *mutex;\n} and_media_factory;\n\ntypedef enum and_aud_codec_id {\n    /* AMRNB codec. */\n    AND_AUD_CODEC_AMRNB,\n\n    /* AMRWB codec. */\n    AND_AUD_CODEC_AMRWB\n} and_aud_codec_id;\n\n/* Android MediaCodec codecs private data. */\ntypedef struct and_media_private {\n    int\t\t\t codec_idx;\t    /**< Codec index.\t\t    */\n    void\t\t*codec_setting;\t    /**< Specific codec setting.    */\n    pj_pool_t\t\t*pool;\t\t    /**< Pool for each instance.    */\n    AMediaCodec         *enc;               /**< Encoder state.\t\t    */\n    AMediaCodec         *dec;               /**< Decoder state.\t\t    */\n\n    pj_uint16_t\t\t frame_size;\t    /**< Bitstream frame size.\t    */\n\n    pj_bool_t\t\t plc_enabled;\t    /**< PLC enabled flag.\t    */\n    pjmedia_plc\t\t*plc;\t\t    /**< PJMEDIA PLC engine, NULL if \n\t\t\t\t\t\t codec has internal PLC.    */\n\n    pj_bool_t\t\t vad_enabled;\t    /**< VAD enabled flag.\t    */\n    pjmedia_silence_det\t*vad;\t\t    /**< PJMEDIA VAD engine, NULL if \n\t\t\t\t\t\t codec has internal VAD.    */\n    pj_timestamp\t last_tx;\t    /**< Timestamp of last transmit.*/\n} and_media_private_t;\n\n/* CUSTOM CALLBACKS */\n\n/* Parse frames from a packet. Default behaviour of frame parsing is \n * just separating frames based on calculating frame length derived \n * from bitrate. Implement this callback when the default behaviour is \n * unapplicable.\n */\ntypedef pj_status_t (*parse_cb)(and_media_private_t *codec_data, void *pkt,\n\t\t\t\tpj_size_t pkt_size, const pj_timestamp *ts,\n\t\t\t\tunsigned *frame_cnt, pjmedia_frame frames[]);\n\n/* Pack frames into a packet. Default behaviour of packing frames is \n * just stacking the frames with octet aligned without adding any \n * payload header. Implement this callback when the default behaviour is\n * unapplicable.\n */\ntypedef pj_status_t (*pack_cb)(and_media_private_t *codec_data,\n\t\t\t       unsigned nframes, void *pkt, pj_size_t *pkt_size,\n\t\t\t       pj_size_t max_pkt_size);\n\n/* This callback is useful for preparing a frame before pass it to decoder.\n */\ntypedef void (*predecode_cb)(and_media_private_t  *codec_data,\n\t\t\t     const pjmedia_frame *rtp_frame,\n\t\t\t     pjmedia_frame *out);\n\n#if PJMEDIA_HAS_AND_MEDIA_AMRNB || PJMEDIA_HAS_AND_MEDIA_AMRWB\n/* Custom callback implementations. */\nstatic pj_status_t parse_amr(and_media_private_t *codec_data, void *pkt,\n\t\t\t     pj_size_t pkt_size, const pj_timestamp *ts,\n\t\t\t     unsigned *frame_cnt, pjmedia_frame frames[]);\nstatic  pj_status_t pack_amr(and_media_private_t *codec_data, unsigned nframes,\n\t\t\t     void *pkt, pj_size_t *pkt_size,\n\t\t\t     pj_size_t max_pkt_size);\nstatic void predecode_amr(and_media_private_t  *codec_data,\n\t\t\t  const pjmedia_frame *input,\n\t\t\t  pjmedia_frame *out);\n#endif\n\n#if PJMEDIA_HAS_AND_MEDIA_AMRNB\n\nstatic pj_str_t AMRNB_encoder[] = {{(char *)\"OMX.google.amrnb.encoder\\0\", 24},\n\t\t\t\t   {(char *)\"c2.android.amrnb.encoder\\0\", 24}};\n\nstatic pj_str_t AMRNB_decoder[] = {{(char *)\"OMX.google.amrnb.decoder\\0\", 24},\n\t\t\t           {(char *)\"c2.android.amrnb.decoder\\0\", 24}};\n#endif\n\n#if PJMEDIA_HAS_AND_MEDIA_AMRWB\n\nstatic pj_str_t AMRWB_encoder[] = {{(char *)\"OMX.google.amrwb.encoder\\0\", 24},\n\t\t\t\t   {(char *)\"c2.android.amrwb.encoder\\0\", 24}};\n\nstatic pj_str_t AMRWB_decoder[] = {{(char *)\"OMX.google.amrwb.decoder\\0\", 24},\n\t\t\t\t   {(char *)\"c2.android.amrwb.decoder\\0\", 24}};\n#endif\n\n/* Android MediaCodec codec implementation descriptions. */\nstatic struct and_media_codec {\n    int\t\t     enabled;\t\t/* Is this codec enabled?\t    */\n    const char\t    *name;\t\t/* Codec name.\t\t\t    */\n    const char      *mime_type;         /* Mime type.                       */\n    pj_str_t        *encoder_name;      /* Encoder name.                    */\n    pj_str_t        *decoder_name;      /* Decoder name.                    */\n\n    pj_uint8_t\t     pt;\t\t/* Payload type.\t\t    */\n    and_aud_codec_id codec_id;\t\t/* Codec id.                        */\n    unsigned\t     clock_rate;\t/* Codec's clock rate.\t\t    */\n    unsigned\t     channel_count;\t/* Codec's channel count.\t    */\n    unsigned\t     samples_per_frame;\t/* Codec's samples count.\t    */\n    unsigned\t     def_bitrate;\t/* Default bitrate of this codec.   */\n    unsigned\t     max_bitrate;\t/* Maximum bitrate of this codec.   */\n    pj_uint8_t\t     frm_per_pkt;\t/* Default num of frames per packet.*/\n    int\t\t     has_native_vad;\t/* Codec has internal VAD?\t    */\n    int\t\t     has_native_plc;\t/* Codec has internal PLC?\t    */\n\n    parse_cb\t     parse;\t\t/* Callback to parse bitstream.\t    */\n    pack_cb\t     pack;\t\t/* Callback to pack bitstream.\t    */\n    predecode_cb     predecode;         /* Callback to prepare bitstream\n                                           before passing it to decoder.    */\n\n    pjmedia_codec_fmtp dec_fmtp;\t/* Decoder's fmtp params.\t    */\n}\n\nand_media_codec[] =\n{\n#   if PJMEDIA_HAS_AND_MEDIA_AMRNB\n    {0, \"AMR\", \"audio/3gpp\", NULL, NULL,\n        PJMEDIA_RTP_PT_AMR, AND_AUD_CODEC_AMRNB, 8000, 1, 160, 7400, 12200,\n        2, 0, 0, &parse_amr, &pack_amr, &predecode_amr,\n        {1, {{{(char *)\"octet-align\", 11}, {(char *)\"1\", 1}}}}\n    },\n#   endif\n\n#   if PJMEDIA_HAS_AND_MEDIA_AMRWB\n    {0, \"AMR-WB\", \"audio/amr-wb\", NULL, NULL,\n        PJMEDIA_RTP_PT_AMRWB, AND_AUD_CODEC_AMRWB, 16000, 1, 320, 15850, 23850,\n        2, 0, 0, &parse_amr, &pack_amr, &predecode_amr,\n\t{1, {{{(char *)\"octet-align\", 11}, {(char *)\"1\", 1}}}}\n    },\n#   endif\n};\n\n#if PJMEDIA_HAS_AND_MEDIA_AMRNB || PJMEDIA_HAS_AND_MEDIA_AMRWB\n\n#include <pjmedia-codec/amr_helper.h>\n\ntypedef struct amr_settings_t {\n    pjmedia_codec_amr_pack_setting enc_setting;\n    pjmedia_codec_amr_pack_setting dec_setting;\n    pj_int8_t enc_mode;\n} amr_settings_t;\n\n/* Pack AMR payload */\nstatic pj_status_t pack_amr(and_media_private_t *codec_data, unsigned nframes,\n\t\t\t    void *pkt, pj_size_t *pkt_size,\n\t\t\t    pj_size_t max_pkt_size)\n{\n    enum {MAX_FRAMES_PER_PACKET = PJMEDIA_MAX_FRAME_DURATION_MS / 20};\n\n    pjmedia_frame frames[MAX_FRAMES_PER_PACKET];\n    pj_uint8_t *p; /* Read cursor */\n    pjmedia_codec_amr_pack_setting *setting;\n    unsigned i;\n    pj_status_t status;\n\n    setting = &((amr_settings_t*)codec_data->codec_setting)->enc_setting;\n\n    /* Align pkt buf right */\n    p = (pj_uint8_t*)pkt + max_pkt_size - *pkt_size;\n    pj_memmove(p, pkt, *pkt_size);\n\n    /* Get frames */\n    for (i = 0; i < nframes; ++i) {\n\tpjmedia_codec_amr_bit_info *info = (pjmedia_codec_amr_bit_info*)\n\t\t\t\t\t    &frames[i].bit_info;\n\tpj_bzero(info, sizeof(*info));\n\tinfo->frame_type = (pj_uint8_t)((*p >> 3) & 0x0F);\n\tinfo->good_quality = (pj_uint8_t)((*p >> 2) & 0x01);\n\tinfo->mode = ((amr_settings_t*)codec_data->codec_setting)->enc_mode;\n\tinfo->start_bit = 0;\n\tframes[i].buf = p + 1;\n        if (setting->amr_nb) {\n            frames[i].size = (info->frame_type <= 8)?\n                             pjmedia_codec_amrnb_framelen[info->frame_type] : 0;\n        } else {\n            frames[i].size = (info->frame_type <= 9)?\n                             pjmedia_codec_amrwb_framelen[info->frame_type] : 0;\n        }\n\tp += frames[i].size + 1;\n    }\n    /* Pack */\n    *pkt_size = max_pkt_size;\n    status = pjmedia_codec_amr_pack(frames, nframes, setting, pkt, pkt_size);\n\n    return status;\n}\n\n/* Parse AMR payload into frames. */\nstatic pj_status_t parse_amr(and_media_private_t *codec_data, void *pkt,\n\t\t\t     pj_size_t pkt_size, const pj_timestamp *ts,\n\t\t\t     unsigned *frame_cnt, pjmedia_frame frames[])\n{\n    amr_settings_t* s = (amr_settings_t*)codec_data->codec_setting;\n    pjmedia_codec_amr_pack_setting *setting;\n    pj_status_t status;\n    pj_uint8_t cmr;\n\n    setting = &s->dec_setting;\n    status = pjmedia_codec_amr_parse(pkt, pkt_size, ts, setting, frames, \n\t\t\t\t     frame_cnt, &cmr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Check Change Mode Request. */\n    if (((setting->amr_nb && cmr <= 7) || (!setting->amr_nb && cmr <= 8)) &&\n\ts->enc_mode != cmr)\n    {\n\ts->enc_mode = cmr;\n    }\n    return PJ_SUCCESS;\n}\n\nstatic void predecode_amr(and_media_private_t *codec_data,\n\t\t\t  const pjmedia_frame *input,\n\t\t\t  pjmedia_frame *out)\n{\n    pjmedia_codec_amr_bit_info *info;\n    pj_uint8_t *bitstream = (pj_uint8_t *)out->buf;\n    pjmedia_codec_amr_pack_setting *setting;\n\n    out->buf = &bitstream[1];\n    setting = &((amr_settings_t*)codec_data->codec_setting)->dec_setting;\n    pjmedia_codec_amr_predecode(input, setting, out);\n    info = (pjmedia_codec_amr_bit_info*)&out->bit_info;\n    bitstream[0] = (info->frame_type << 3) | (info->good_quality << 2);\n    out->buf = &bitstream[0];\n    ++out->size;\n}\n\n#endif /* PJMEDIA_HAS_AND_MEDIA_AMRNB || PJMEDIA_HAS_AND_MEDIA_AMRWB */\n\nstatic pj_status_t configure_codec(and_media_private_t *and_media_data,\n\t\t\t\t   pj_bool_t is_encoder)\n{\n    media_status_t am_status;\n    AMediaFormat *aud_fmt;\n    int idx = and_media_data->codec_idx;\n    AMediaCodec *codec = (is_encoder?and_media_data->enc:and_media_data->dec);\n\n    aud_fmt = AMediaFormat_new();\n    if (!aud_fmt) {\n        return PJ_ENOMEM;\n    }\n    AMediaFormat_setString(aud_fmt, AND_MEDIA_KEY_MIME,\n                           and_media_codec[idx].mime_type);\n    AMediaFormat_setInt32(aud_fmt, AND_MEDIA_KEY_PCM_ENCODING, 2);\n    AMediaFormat_setInt32(aud_fmt, AND_MEDIA_KEY_CHANNEL_COUNT,\n                          and_media_codec[idx].channel_count);\n    AMediaFormat_setInt32(aud_fmt, AND_MEDIA_KEY_SAMPLE_RATE,\n\t\t\t  and_media_codec[idx].clock_rate);\n    AMediaFormat_setInt32(aud_fmt, AND_MEDIA_KEY_BITRATE,\n\t\t\t  and_media_codec[idx].def_bitrate);\n\n    /* Configure and start encoder. */\n    am_status = AMediaCodec_configure(codec, aud_fmt, NULL, NULL, is_encoder);\n    AMediaFormat_delete(aud_fmt);\n    if (am_status != AMEDIA_OK) {\n        PJ_LOG(4, (THIS_FILE, \"%s [0x%x] configure failed, status=%d\",\n               is_encoder?\"Encoder\":\"Decoder\", codec, am_status));\n        return PJMEDIA_CODEC_EFAILED;\n    }\n    am_status = AMediaCodec_start(codec);\n    if (am_status != AMEDIA_OK) {\n\tPJ_LOG(4, (THIS_FILE, \"%s [0x%x] start failed, status=%d\",\n\t       is_encoder?\"Encoder\":\"Decoder\", codec, am_status));\n\treturn PJMEDIA_CODEC_EFAILED;\n    }\n    PJ_LOG(4, (THIS_FILE, \"%s [0x%x] started\", is_encoder?\"Encoder\":\"Decoder\",\n\t   codec));\n    return PJ_SUCCESS;\n}\n\n/*\n * Initialize and register Android MediaCodec codec factory to pjmedia endpoint.\n */\nPJ_DEF(pj_status_t) pjmedia_codec_and_media_aud_init( pjmedia_endpt *endpt )\n{\n    pjmedia_codec_mgr *codec_mgr;\n    pj_str_t codec_name;\n    pj_status_t status;\n\n    if (and_media_factory.pool != NULL) {\n\t/* Already initialized. */\n\treturn PJ_SUCCESS;\n    }\n\n    PJ_LOG(4, (THIS_FILE, \"Initing codec\"));\n\n    /* Create Android MediaCodec codec factory. */\n    and_media_factory.base.op = &and_media_factory_op;\n    and_media_factory.base.factory_data = NULL;\n    and_media_factory.endpt = endpt;\n\n    and_media_factory.pool = pjmedia_endpt_create_pool(endpt,\n                                                   \"Android MediaCodec codecs\",\n                                                   4000, 4000);\n    if (!and_media_factory.pool)\n\treturn PJ_ENOMEM;\n\n    /* Create mutex. */\n    status = pj_mutex_create_simple(and_media_factory.pool,\n                                    \"Android MediaCodec codecs\",\n\t\t\t\t    &and_media_factory.mutex);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Get the codec manager. */\n    codec_mgr = pjmedia_endpt_get_codec_mgr(endpt);\n    if (!codec_mgr) {\n\tstatus = PJ_EINVALIDOP;\n\tgoto on_error;\n    }\n\n#if PJMEDIA_HAS_AND_MEDIA_AMRNB\n    PJ_LOG(4, (THIS_FILE, \"Registering AMRNB codec\"));\n\n    pj_cstr(&codec_name, \"AMR\");\n    status = pjmedia_sdp_neg_register_fmt_match_cb(\n\t\t\t\t\t\t&codec_name,\n\t\t\t\t\t\t&pjmedia_codec_amr_match_sdp);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n#endif\n\n#if PJMEDIA_HAS_AND_MEDIA_AMRWB\n    PJ_LOG(4, (THIS_FILE, \"Registering AMRWB codec\"));\n\n    pj_cstr(&codec_name, \"AMR-WB\");\n    status = pjmedia_sdp_neg_register_fmt_match_cb(\n\t\t\t\t\t\t&codec_name,\n\t\t\t\t\t\t&pjmedia_codec_amr_match_sdp);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n#endif\n\n    /* Suppress compile warning */\n    PJ_UNUSED_ARG(codec_name);\n\n    /* Register codec factory to endpoint. */\n    status = pjmedia_codec_mgr_register_factory(codec_mgr, \n\t\t\t\t\t\t&and_media_factory.base);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Done. */\n    return PJ_SUCCESS;\n\non_error:\n    pj_pool_release(and_media_factory.pool);\n    and_media_factory.pool = NULL;\n    return status;\n}\n\n/*\n * Unregister Android MediaCodec codecs factory from pjmedia endpoint.\n */\nPJ_DEF(pj_status_t) pjmedia_codec_and_media_aud_deinit(void)\n{\n    pjmedia_codec_mgr *codec_mgr;\n    pj_status_t status;\n\n    if (and_media_factory.pool == NULL) {\n\t/* Already deinitialized */\n\treturn PJ_SUCCESS;\n    }\n\n    pj_mutex_lock(and_media_factory.mutex);\n\n    /* Get the codec manager. */\n    codec_mgr = pjmedia_endpt_get_codec_mgr(and_media_factory.endpt);\n    if (!codec_mgr) {\n\tpj_pool_release(and_media_factory.pool);\n\tand_media_factory.pool = NULL;\n\tpj_mutex_unlock(and_media_factory.mutex);\n\treturn PJ_EINVALIDOP;\n    }\n\n    /* Unregister Android MediaCodec codecs factory. */\n    status = pjmedia_codec_mgr_unregister_factory(codec_mgr,\n\t\t\t\t\t\t  &and_media_factory.base);\n\n    /* Destroy mutex. */\n    pj_mutex_unlock(and_media_factory.mutex);\n    pj_mutex_destroy(and_media_factory.mutex);\n    and_media_factory.mutex = NULL;\n\n    /* Destroy pool. */\n    pj_pool_release(and_media_factory.pool);\n    and_media_factory.pool = NULL;\n\n    return status;\n}\n\n/*\n * Check if factory can allocate the specified codec. \n */\nstatic pj_status_t and_media_test_alloc(pjmedia_codec_factory *factory,\n\t\t\t\t\tconst pjmedia_codec_info *info )\n{\n    unsigned i;\n\n    PJ_UNUSED_ARG(factory);\n\n    /* Type MUST be audio. */\n    if (info->type != PJMEDIA_TYPE_AUDIO)\n\treturn PJMEDIA_CODEC_EUNSUP;\n\n    for (i = 0; i < PJ_ARRAY_SIZE(and_media_codec); ++i) {\n\tpj_str_t name = pj_str((char*)and_media_codec[i].name);\n\tif ((pj_stricmp(&info->encoding_name, &name) == 0) &&\n\t    (info->clock_rate == (unsigned)and_media_codec[i].clock_rate) &&\n\t    (info->channel_cnt == (unsigned)and_media_codec[i].channel_count) &&\n\t    (and_media_codec[i].enabled))\n\t{\n\t    return PJ_SUCCESS;\n\t}\n    }\n\n    /* Unsupported, or mode is disabled. */\n    return PJMEDIA_CODEC_EUNSUP;\n}\n\n/*\n * Generate default attribute.\n */\nstatic pj_status_t and_media_default_attr (pjmedia_codec_factory *factory,\n\t\t\t\t\t   const pjmedia_codec_info *id,\n\t\t\t\t\t   pjmedia_codec_param *attr)\n{\n    unsigned i;\n\n    PJ_ASSERT_RETURN(factory==&and_media_factory.base, PJ_EINVAL);\n\n    pj_bzero(attr, sizeof(pjmedia_codec_param));\n\n    for (i = 0; i < PJ_ARRAY_SIZE(and_media_codec); ++i) {\n\tpj_str_t name = pj_str((char*)and_media_codec[i].name);\n\tif ((and_media_codec[i].enabled) &&\n\t    (pj_stricmp(&id->encoding_name, &name) == 0) &&\n\t    (id->clock_rate == (unsigned)and_media_codec[i].clock_rate) &&\n\t    (id->channel_cnt == (unsigned)and_media_codec[i].channel_count) &&\n\t    (id->pt == (unsigned)and_media_codec[i].pt))\n\t{\n\t    attr->info.pt = (pj_uint8_t)id->pt;\n\t    attr->info.channel_cnt = and_media_codec[i].channel_count;\n\t    attr->info.clock_rate = and_media_codec[i].clock_rate;\n\t    attr->info.avg_bps = and_media_codec[i].def_bitrate;\n\t    attr->info.max_bps = and_media_codec[i].max_bitrate;\n\t    attr->info.pcm_bits_per_sample = 16;\n\t    attr->info.frm_ptime =  (pj_uint16_t)\n\t\t\t\t(and_media_codec[i].samples_per_frame * 1000 /\n\t\t\t\tand_media_codec[i].channel_count /\n\t\t\t\tand_media_codec[i].clock_rate);\n\t    attr->setting.frm_per_pkt = and_media_codec[i].frm_per_pkt;\n\n\t    /* Default flags. */\n\t    attr->setting.plc = 1;\n\t    attr->setting.penh= 0;\n\t    attr->setting.vad = 1;\n\t    attr->setting.cng = attr->setting.vad;\n\t    attr->setting.dec_fmtp = and_media_codec[i].dec_fmtp;\n\n\t    return PJ_SUCCESS;\n\t}\n    }\n\n    return PJMEDIA_CODEC_EUNSUP;\n}\n\nstatic pj_bool_t codec_exists(const pj_str_t *codec_name)\n{\n    AMediaCodec *codec;\n    char *codec_txt;\n\n    codec_txt = codec_name->ptr;\n\n    codec = AMediaCodec_createCodecByName(codec_txt);\n    if (!codec) {\n\tPJ_LOG(4, (THIS_FILE, \"Failed creating codec : %.*s\", codec_name->slen,\n\t\t   codec_name->ptr));\n\treturn PJ_FALSE;\n    }\n    AMediaCodec_delete(codec);\n\n    return PJ_TRUE;\n}\n\n/*\n * Enum codecs supported by this factory.\n */\nstatic pj_status_t and_media_enum_codecs(pjmedia_codec_factory *factory,\n\t\t\t\t\t unsigned *count,\n\t\t\t\t\t pjmedia_codec_info codecs[])\n{\n    unsigned max;\n    unsigned i;\n\n    PJ_UNUSED_ARG(factory);\n    PJ_ASSERT_RETURN(codecs && *count > 0, PJ_EINVAL);\n\n    max = *count;\n\n    for (i = 0, *count = 0; i < PJ_ARRAY_SIZE(and_media_codec) &&\n         *count < max; ++i)\n    {\n\tunsigned enc_idx, dec_idx;\n\tpj_str_t *enc_name = NULL;\n\tunsigned num_enc = 0;\n\tpj_str_t *dec_name = NULL;\n\tunsigned num_dec = 0;\n\n\tswitch (and_media_codec[i].codec_id) {\n\n\tcase AND_AUD_CODEC_AMRNB:\n#if PJMEDIA_HAS_AND_MEDIA_AMRNB\n\t    enc_name = &AMRNB_encoder[0];\n\t    dec_name = &AMRNB_decoder[0];\n\t    num_enc = PJ_ARRAY_SIZE(AMRNB_encoder);\n\t    num_dec = PJ_ARRAY_SIZE(AMRNB_decoder);\n#endif\n\t    break;\n\tcase AND_AUD_CODEC_AMRWB:\n#if PJMEDIA_HAS_AND_MEDIA_AMRWB\n\t    enc_name = &AMRWB_encoder[0];\n\t    dec_name = &AMRWB_decoder[0];\n\t    num_enc = PJ_ARRAY_SIZE(AMRWB_encoder);\n\t    num_dec = PJ_ARRAY_SIZE(AMRWB_decoder);\n#endif\n\n\t    break;\n\tdefault:\n\t    continue;\n\t};\n\tif (!enc_name || !dec_name) {\n\t    continue;\n\t}\n\n\tfor (enc_idx = 0; enc_idx < num_enc ;++enc_idx, ++enc_name) {\n\t    if (codec_exists(enc_name)) {\n\t\tbreak;\n\t    }\n\t}\n\tif (enc_idx == num_enc)\n\t    continue;\n\n\tfor (dec_idx = 0; dec_idx < num_dec ;++dec_idx, ++dec_name) {\n\t    if (codec_exists(dec_name)) {\n\t\tbreak;\n\t    }\n\t}\n\tif (dec_idx == num_dec)\n\t    continue;\n\n\tand_media_codec[i].encoder_name = enc_name;\n\tand_media_codec[i].decoder_name = dec_name;\n\tpj_bzero(&codecs[*count], sizeof(pjmedia_codec_info));\n\tcodecs[*count].encoding_name = pj_str((char*)and_media_codec[i].name);\n\tcodecs[*count].pt = and_media_codec[i].pt;\n\tcodecs[*count].type = PJMEDIA_TYPE_AUDIO;\n\tcodecs[*count].clock_rate = and_media_codec[i].clock_rate;\n\tcodecs[*count].channel_cnt = and_media_codec[i].channel_count;\n\tand_media_codec[i].enabled = PJ_TRUE;\n\tPJ_LOG(4, (THIS_FILE, \"Found encoder [%d]: %.*s and decoder: %.*s \",\n\t\t   *count, enc_name->slen, enc_name->ptr, dec_name->slen,\n\t\t   dec_name->ptr));\n\t++*count;\n    }\n\n    return PJ_SUCCESS;\n}\n\nstatic void create_codec(and_media_private_t *and_media_data)\n{\n    char const *enc_name =\n\t\t   and_media_codec[and_media_data->codec_idx].encoder_name->ptr;\n    char const *dec_name =\n\t\t   and_media_codec[and_media_data->codec_idx].decoder_name->ptr;\n\n    if (!and_media_data->enc) {\n\tand_media_data->enc = AMediaCodec_createCodecByName(enc_name);\n\tif (!and_media_data->enc) {\n\t    PJ_LOG(4, (THIS_FILE, \"Failed creating encoder: %s\", enc_name));\n\t}\n\tPJ_LOG(4, (THIS_FILE, \"Done creating encoder: %s [0x%x]\", enc_name,\n\t       and_media_data->enc));\n    }\n\n    if (!and_media_data->dec) {\n\tand_media_data->dec = AMediaCodec_createCodecByName(dec_name);\n\tif (!and_media_data->dec) {\n\t    PJ_LOG(4, (THIS_FILE, \"Failed creating decoder: %s\", dec_name));\n\t}\n\tPJ_LOG(4, (THIS_FILE, \"Done creating decoder: %s [0x%x]\", dec_name,\n\t       and_media_data->dec));\n    }\n}\n\n/*\n * Allocate a new codec instance.\n */\nstatic pj_status_t and_media_alloc_codec(pjmedia_codec_factory *factory,\n\t\t\t\t\t const pjmedia_codec_info *id,\n\t\t\t\t\t pjmedia_codec **p_codec)\n{\n    and_media_private_t *codec_data;\n    pjmedia_codec *codec;\n    int idx;\n    pj_pool_t *pool;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(factory && id && p_codec, PJ_EINVAL);\n    PJ_ASSERT_RETURN(factory == &and_media_factory.base, PJ_EINVAL);\n\n    pj_mutex_lock(and_media_factory.mutex);\n\n    /* Find codec's index */\n    idx = -1;\n    for (i = 0; i < PJ_ARRAY_SIZE(and_media_codec); ++i) {\n\tpj_str_t name = pj_str((char*)and_media_codec[i].name);\n\tif ((pj_stricmp(&id->encoding_name, &name) == 0) &&\n\t    (id->clock_rate == (unsigned)and_media_codec[i].clock_rate) &&\n\t    (id->channel_cnt == (unsigned)and_media_codec[i].channel_count) &&\n\t    (and_media_codec[i].enabled))\n\t{\n\t    idx = i;\n\t    break;\n\t}\n    }\n    if (idx == -1) {\n\t*p_codec = NULL;\n\treturn PJMEDIA_CODEC_EFAILED;\n    }\n\n    /* Create pool for codec instance */\n    pool = pjmedia_endpt_create_pool(and_media_factory.endpt, \"andmedaud%p\",\n                                     512, 512);\n    codec = PJ_POOL_ZALLOC_T(pool, pjmedia_codec);\n    PJ_ASSERT_RETURN(codec != NULL, PJ_ENOMEM);\n    codec->op = &and_media_op;\n    codec->factory = factory;\n    codec->codec_data = PJ_POOL_ZALLOC_T(pool, and_media_private_t);\n    codec_data = (and_media_private_t*) codec->codec_data;\n\n    /* Create PLC if codec has no internal PLC */\n    if (!and_media_codec[idx].has_native_plc) {\n\tpj_status_t status;\n\tstatus = pjmedia_plc_create(pool, and_media_codec[idx].clock_rate,\n\t\t\t\t    and_media_codec[idx].samples_per_frame, 0,\n\t\t\t\t    &codec_data->plc);\n\tif (status != PJ_SUCCESS) {\n\t    goto on_error;\n\t}\n    }\n\n    /* Create silence detector if codec has no internal VAD */\n    if (!and_media_codec[idx].has_native_vad) {\n\tpj_status_t status;\n\tstatus = pjmedia_silence_det_create(pool,\n\t\t\t\t\tand_media_codec[idx].clock_rate,\n\t\t\t\t\tand_media_codec[idx].samples_per_frame,\n\t\t\t\t\t&codec_data->vad);\n\tif (status != PJ_SUCCESS) {\n\t    goto on_error;\n\t}\n    }\n\n    codec_data->pool = pool;\n    codec_data->codec_idx = idx;\n\n    create_codec(codec_data);\n    if (!codec_data->enc || !codec_data->dec) {\n\tgoto on_error;\n    }\n    pj_mutex_unlock(and_media_factory.mutex);\n\n    *p_codec = codec;\n    return PJ_SUCCESS;\n\non_error:\n    pj_mutex_unlock(and_media_factory.mutex);\n    and_media_dealloc_codec(factory, codec);\n    return PJMEDIA_CODEC_EFAILED;\n}\n\n/*\n * Free codec.\n */\nstatic pj_status_t and_media_dealloc_codec(pjmedia_codec_factory *factory,\n\t\t\t\t\t   pjmedia_codec *codec )\n{\n    and_media_private_t *codec_data;\n\n    PJ_ASSERT_RETURN(factory && codec, PJ_EINVAL);\n    PJ_ASSERT_RETURN(factory == &and_media_factory.base, PJ_EINVAL);\n\n    /* Close codec, if it's not closed. */\n    codec_data = (and_media_private_t*) codec->codec_data;\n    if (codec_data->enc) {\n        AMediaCodec_stop(codec_data->enc);\n        AMediaCodec_delete(codec_data->enc);\n        codec_data->enc = NULL;\n    }\n\n    if (codec_data->dec) {\n        AMediaCodec_stop(codec_data->dec);\n        AMediaCodec_delete(codec_data->dec);\n        codec_data->dec = NULL;\n    }\n    pj_pool_release(codec_data->pool);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Init codec.\n */\nstatic pj_status_t and_media_codec_init(pjmedia_codec *codec,\n\t\t\t\t        pj_pool_t *pool )\n{\n    PJ_UNUSED_ARG(codec);\n    PJ_UNUSED_ARG(pool);\n    return PJ_SUCCESS;\n}\n\n/*\n * Open codec.\n */\nstatic pj_status_t and_media_codec_open(pjmedia_codec *codec,\n\t\t\t\t\tpjmedia_codec_param *attr)\n{\n    and_media_private_t *codec_data = (and_media_private_t*) codec->codec_data;\n    struct and_media_codec *and_media_data =\n\t\t\t\t\t&and_media_codec[codec_data->codec_idx];\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(codec && attr, PJ_EINVAL);\n    PJ_ASSERT_RETURN(codec_data != NULL, PJ_EINVALIDOP);\n\n    PJ_LOG(5,(THIS_FILE, \"Opening codec..\"));\n\n    codec_data->vad_enabled = (attr->setting.vad != 0);\n    codec_data->plc_enabled = (attr->setting.plc != 0);\n    and_media_data->clock_rate = attr->info.clock_rate;\n\n#if PJMEDIA_HAS_AND_MEDIA_AMRNB\n    if (and_media_data->codec_id == AND_AUD_CODEC_AMRNB ||\n\tand_media_data->codec_id == AND_AUD_CODEC_AMRWB)\n    {\n\tamr_settings_t *s;\n\tpj_uint8_t octet_align = 0;\n\tpj_int8_t enc_mode;\n\tunsigned i;\n\n\tenc_mode = pjmedia_codec_amr_get_mode(attr->info.avg_bps);\n\n\tpj_assert(enc_mode >= 0 && enc_mode <= 8);\n\n\t/* Check AMR specific attributes */\n\tfor (i = 0; i < attr->setting.dec_fmtp.cnt; ++i) {\n\t    /* octet-align, one of the parameters that must have same value\n\t     * in offer & answer (RFC 4867 Section 8.3.1). Just check fmtp\n\t     * in the decoder side, since it's value is guaranteed to fulfil\n\t     * above requirement (by SDP negotiator).\n\t     */\n\t    const pj_str_t STR_FMTP_OCTET_ALIGN = {(char *)\"octet-align\", 11};\n\n\t    if (pj_stricmp(&attr->setting.dec_fmtp.param[i].name,\n\t\t\t   &STR_FMTP_OCTET_ALIGN) == 0)\n\t    {\n\t\toctet_align=(pj_uint8_t)\n\t\t\t    pj_strtoul(&attr->setting.dec_fmtp.param[i].val);\n\t\tbreak;\n\t    }\n\t}\n\tfor (i = 0; i < attr->setting.enc_fmtp.cnt; ++i) {\n\t    /* mode-set, encoding mode is chosen based on local default mode\n\t     * setting:\n\t     * - if local default mode is included in the mode-set, use it\n\t     * - otherwise, find the closest mode to local default mode;\n\t     *   if there are two closest modes, prefer to use the higher\n\t     *   one, e.g: local default mode is 4, the mode-set param\n\t     *   contains '2,3,5,6', then 5 will be chosen.\n\t     */\n\t    const pj_str_t STR_FMTP_MODE_SET = {(char *)\"mode-set\", 8};\n\n\t    if (pj_stricmp(&attr->setting.enc_fmtp.param[i].name,\n\t\t\t   &STR_FMTP_MODE_SET) == 0)\n\t    {\n\t\tconst char *p;\n\t\tpj_size_t l;\n\t\tpj_int8_t diff = 99;\n\n\t\tp = pj_strbuf(&attr->setting.enc_fmtp.param[i].val);\n\t\tl = pj_strlen(&attr->setting.enc_fmtp.param[i].val);\n\n\t\twhile (l--) {\n\t\t    if ((and_media_data->codec_id == AND_AUD_CODEC_AMRNB &&\n\t\t\t *p>='0' && *p<='7') ||\n\t\t        (and_media_data->codec_id == AND_AUD_CODEC_AMRWB &&\n\t\t         *p>='0' && *p<='8'))\n\t\t    {\n\t\t\tpj_int8_t tmp = (pj_int8_t)(*p - '0' - enc_mode);\n\n\t\t\tif (PJ_ABS(diff) > PJ_ABS(tmp) ||\n\t\t\t    (PJ_ABS(diff) == PJ_ABS(tmp) && tmp > diff))\n\t\t\t{\n\t\t\t    diff = tmp;\n\t\t\t    if (diff == 0) break;\n\t\t\t}\n\t\t    }\n\t\t    ++p;\n\t\t}\n\t\tif (diff == 99)\n\t\t    goto on_error;\n\n\t\tenc_mode = (pj_int8_t)(enc_mode + diff);\n\n\t\tbreak;\n\t    }\n\t}\n\t/* Initialize AMR specific settings */\n\ts = PJ_POOL_ZALLOC_T(codec_data->pool, amr_settings_t);\n\tcodec_data->codec_setting = s;\n\n\ts->enc_setting.amr_nb = (pj_uint8_t)\n\t\t\t      (and_media_data->codec_id == AND_AUD_CODEC_AMRNB);\n\ts->enc_setting.octet_aligned = octet_align;\n\ts->enc_setting.reorder = 0;\n\ts->enc_setting.cmr = 15;\n\ts->dec_setting.amr_nb = (pj_uint8_t)\n\t\t\t      (and_media_data->codec_id == AND_AUD_CODEC_AMRNB);\n\ts->dec_setting.octet_aligned = octet_align;\n\ts->dec_setting.reorder = 0;\n\t/* Apply encoder mode/bitrate */\n\ts->enc_mode = enc_mode;\n\n\tPJ_LOG(4, (THIS_FILE, \"Encoder setting octet_aligned=%d reorder=%d\"\n\t\t   \" cmr=%d enc_mode=%d\",\n\t\t   s->enc_setting.octet_aligned, s->enc_setting.reorder,\n\t\t   s->enc_setting.cmr, enc_mode));\n\tPJ_LOG(4, (THIS_FILE, \"Decoder setting octet_aligned=%d reorder=%d\",\n\t\t   s->dec_setting.octet_aligned, s->dec_setting.reorder));\n    }\n#endif\n    status = configure_codec(codec_data, PJ_TRUE);\n    if (status != PJ_SUCCESS) {\n        goto on_error;\n    }\n    status = configure_codec(codec_data, PJ_FALSE);\n    if (status != PJ_SUCCESS) {\n\tgoto on_error;\n    }\n\n    return PJ_SUCCESS;\n\non_error:\n    return PJMEDIA_CODEC_EFAILED;\n}\n\n/*\n * Close codec.\n */\nstatic pj_status_t and_media_codec_close(pjmedia_codec *codec)\n{\n    PJ_UNUSED_ARG(codec);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Modify codec settings.\n */\nstatic pj_status_t  and_media_codec_modify(pjmedia_codec *codec,\n\t\t\t\t\t   const pjmedia_codec_param *attr)\n{\n    and_media_private_t *codec_data = (and_media_private_t*) codec->codec_data;\n\n    codec_data->vad_enabled = (attr->setting.vad != 0);\n    codec_data->plc_enabled = (attr->setting.plc != 0);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Get frames in the packet.\n */\nstatic pj_status_t and_media_codec_parse(pjmedia_codec *codec,\n\t\t\t\t\t void *pkt,\n\t\t\t\t\t pj_size_t pkt_size,\n\t\t\t\t\t const pj_timestamp *ts,\n\t\t\t\t\t unsigned *frame_cnt,\n\t\t\t\t\t pjmedia_frame frames[])\n{\n    and_media_private_t *codec_data = (and_media_private_t*) codec->codec_data;\n    struct and_media_codec *and_media_data =\n\t\t\t\t\t&and_media_codec[codec_data->codec_idx];\n    unsigned count = 0;\n\n    PJ_ASSERT_RETURN(frame_cnt, PJ_EINVAL);\n\n    if (and_media_data->parse != NULL) {\n\treturn and_media_data->parse(codec_data, pkt,  pkt_size, ts, frame_cnt,\n\t\t\t\t     frames);\n    }\n\n    while (pkt_size >= codec_data->frame_size && count < *frame_cnt) {\n\tframes[count].type = PJMEDIA_FRAME_TYPE_AUDIO;\n\tframes[count].buf = pkt;\n\tframes[count].size = codec_data->frame_size;\n\tframes[count].timestamp.u64 = ts->u64 +\n\t\t\t\t      count*and_media_data->samples_per_frame;\n\tpkt = ((char*)pkt) + codec_data->frame_size;\n\tpkt_size -= codec_data->frame_size;\n\t++count;\n    }\n\n    if (pkt_size && count < *frame_cnt) {\n\tframes[count].type = PJMEDIA_FRAME_TYPE_AUDIO;\n\tframes[count].buf = pkt;\n\tframes[count].size = pkt_size;\n\tframes[count].timestamp.u64 = ts->u64 +\n\t\t\t\t      count*and_media_data->samples_per_frame;\n\t++count;\n    }\n\n    *frame_cnt = count;\n    return PJ_SUCCESS;\n}\n\n/*\n * Encode frames.\n */\nstatic pj_status_t and_media_codec_encode(pjmedia_codec *codec,\n\t\t\t\t\t  const struct pjmedia_frame *input,\n\t\t\t\t\t  unsigned output_buf_len,\n\t\t\t\t\t  struct pjmedia_frame *output)\n{\n    and_media_private_t *codec_data = (and_media_private_t*) codec->codec_data;\n    struct and_media_codec *and_media_data =\n\t\t\t\t\t&and_media_codec[codec_data->codec_idx];\n    unsigned samples_per_frame;\n    unsigned nsamples;\n    unsigned nframes;\n    pj_size_t tx = 0;\n    pj_int16_t *pcm_in = (pj_int16_t*)input->buf;\n    pj_uint8_t  *bits_out = (pj_uint8_t*) output->buf;\n    pj_uint8_t pt;\n\n    /* Invoke external VAD if codec has no internal VAD */\n    if (codec_data->vad && codec_data->vad_enabled) {\n\tpj_bool_t is_silence;\n\tpj_int32_t silence_duration;\n\n\tsilence_duration = pj_timestamp_diff32(&codec_data->last_tx, \n\t\t\t\t\t       &input->timestamp);\n\n\tis_silence = pjmedia_silence_det_detect(codec_data->vad, \n\t\t\t\t\t        (const pj_int16_t*) input->buf,\n\t\t\t\t\t\t(input->size >> 1),\n\t\t\t\t\t\tNULL);\n\tif (is_silence &&\n\t    (PJMEDIA_CODEC_MAX_SILENCE_PERIOD == -1 ||\n\t     silence_duration < (PJMEDIA_CODEC_MAX_SILENCE_PERIOD *\n\t \t\t\t (int)and_media_data->clock_rate / 1000)))\n\t{\n\t    output->type = PJMEDIA_FRAME_TYPE_NONE;\n\t    output->buf = NULL;\n\t    output->size = 0;\n\t    output->timestamp = input->timestamp;\n\t    return PJ_SUCCESS;\n\t} else {\n\t    codec_data->last_tx = input->timestamp;\n\t}\n    }\n    nsamples = input->size >> 1;\n    samples_per_frame = and_media_data->samples_per_frame;\n    pt = and_media_data->pt;\n    nframes = nsamples / samples_per_frame;\n\n    PJ_ASSERT_RETURN(nsamples % samples_per_frame == 0, \n\t\t     PJMEDIA_CODEC_EPCMFRMINLEN);\n\n    /* Encode the frames */\n    while (nsamples >= samples_per_frame) {\n        pj_ssize_t buf_idx;\n        unsigned i;\n        pj_size_t output_size;\n        pj_uint8_t *output_buf;\n        AMediaCodecBufferInfo buf_info;\n\n        buf_idx = AMediaCodec_dequeueInputBuffer(codec_data->enc,\n\t\t\t\t\t         CODEC_DEQUEUE_TIMEOUT);\n\n        if (buf_idx >= 0) {\n\t    media_status_t am_status;\n\t    pj_size_t output_size;\n            unsigned input_size = samples_per_frame << 1;\n\n\t    pj_uint8_t *input_buf = AMediaCodec_getInputBuffer(codec_data->enc,\n\t\t\t\t\t\t        buf_idx, &output_size);\n\n\t    if (input_buf && output_size >= input_size) {\n\t        pj_memcpy(input_buf, pcm_in, input_size);\n\n\t        am_status = AMediaCodec_queueInputBuffer(codec_data->enc,\n\t\t\t\t                  buf_idx, 0, input_size, 0, 0);\n\t        if (am_status != AMEDIA_OK) {\n\t\t    PJ_LOG(4, (THIS_FILE, \"Encoder queueInputBuffer return %d\",\n\t\t               am_status));\n\t\t    goto on_return;\n\t        }\n\t    } else {\n\t        if (!input_buf) {\n\t\t    PJ_LOG(4,(THIS_FILE, \"Encoder getInputBuffer \"\n\t\t\t\t         \"returns no input buff\"));\n\t        } else {\n\t\t    PJ_LOG(4,(THIS_FILE, \"Encoder getInputBuffer \"\n\t\t\t\t         \"size: %d, expecting %d.\",\n\t\t\t\t         input_buf, output_size, input_size));\n\t        }\n\t        goto on_return;\n\t    }\n        } else {\n\t    PJ_LOG(4,(THIS_FILE, \"Encoder dequeueInputBuffer failed[%d]\",\n                      buf_idx));\n\t    goto on_return;\n        }\n\n        for (i = 0; i < CODEC_WAIT_RETRY; ++i) {\n\t    buf_idx = AMediaCodec_dequeueOutputBuffer(codec_data->enc,\n\t\t\t\t\t\t      &buf_info,\n\t\t\t\t\t\t      CODEC_DEQUEUE_TIMEOUT);\n\t    if (buf_idx == -1) {\n\t        /* Timeout, wait until output buffer is availble. */\n\t        pj_thread_sleep(CODEC_THREAD_WAIT);\n\t    } else {\n\t        break;\n\t    }\n        }\n\n        if (buf_idx < 0) {\n\t    PJ_LOG(4, (THIS_FILE, \"Encoder dequeueOutputBuffer failed %d\",\n\t\t   buf_idx));\n            goto on_return;\n        }\n\n        output_buf = AMediaCodec_getOutputBuffer(codec_data->enc,\n                                                 buf_idx,\n                                                 &output_size);\n        if (!output_buf) {\n            PJ_LOG(4, (THIS_FILE, \"Encoder failed getting output buffer, \"\n                       \"buffer size=%d, flags %d\",\n                       buf_info.size, buf_info.flags));\n            goto on_return;\n        }\n\n        pj_memcpy(bits_out, output_buf, buf_info.size);\n        AMediaCodec_releaseOutputBuffer(codec_data->enc,\n                                        buf_idx,\n                                        0);\n        bits_out += buf_info.size;\n        tx += buf_info.size;\n\tpcm_in += samples_per_frame;\n\tnsamples -= samples_per_frame;\n    }\n    if (and_media_data->pack != NULL) {\n\tand_media_data->pack(codec_data, nframes, output->buf, &tx,\n\t\t\t     output_buf_len);\n    }\n    /* Check if we don't need to transmit the frame (DTX) */\n    if (tx == 0) {\n\toutput->buf = NULL;\n\toutput->size = 0;\n\toutput->timestamp.u64 = input->timestamp.u64;\n\toutput->type = PJMEDIA_FRAME_TYPE_NONE;\n\treturn PJ_SUCCESS;\n    }\n    output->size = tx;\n    output->type = PJMEDIA_FRAME_TYPE_AUDIO;\n    output->timestamp = input->timestamp;\n\n    return PJ_SUCCESS;\n\non_return:\n    output->size = 0;\n    output->buf = NULL;\n    output->type = PJMEDIA_FRAME_TYPE_NONE;\n    output->timestamp.u64 = input->timestamp.u64;\n    return PJ_SUCCESS;\n}\n\n/*\n * Decode frame.\n */\nstatic pj_status_t and_media_codec_decode(pjmedia_codec *codec,\n\t\t\t\t\t  const struct pjmedia_frame *input,\n\t\t\t\t\t  unsigned output_buf_len,\n\t\t\t\t\t  struct pjmedia_frame *output)\n{\n    and_media_private_t *codec_data = (and_media_private_t*) codec->codec_data;\n    struct and_media_codec *and_media_data =\n\t\t\t\t\t&and_media_codec[codec_data->codec_idx];\n    unsigned samples_per_frame;\n    unsigned i;\n\n    pj_uint8_t pt;\n    pj_ssize_t buf_idx = -1;\n    pj_uint8_t *input_buf;\n    pj_size_t input_size;\n    pj_size_t output_size;\n    media_status_t am_status;\n    AMediaCodecBufferInfo buf_info;\n    pj_uint8_t *output_buf;\n    pjmedia_frame input_;\n\n    pj_bzero(&input_, sizeof(pjmedia_frame));\n    pt = and_media_data->pt;\n    samples_per_frame = and_media_data->samples_per_frame;\n\n    PJ_ASSERT_RETURN(output_buf_len >= samples_per_frame << 1,\n\t\t     PJMEDIA_CODEC_EPCMTOOSHORT);\n\n    if (input->type != PJMEDIA_FRAME_TYPE_AUDIO)\n    {\n\tgoto on_return;\n    }\n\n    buf_idx = AMediaCodec_dequeueInputBuffer(codec_data->dec,\n\t\t\t\t\t     CODEC_DEQUEUE_TIMEOUT);\n\n    if (buf_idx < 0) {\n\tPJ_LOG(4,(THIS_FILE, \"Decoder dequeueInputBuffer failed return %d\",\n\t\t  buf_idx));\n\tgoto on_return;\n    }\n\n    input_buf = AMediaCodec_getInputBuffer(codec_data->dec,\n\t\t\t\t\t   buf_idx,\n\t\t\t\t\t   &input_size);\n    if (input_buf == 0) {\n\tPJ_LOG(4,(THIS_FILE, \"Decoder getInputBuffer failed \"\n\t\t  \"return input_buf=%d, size=%d\", input_buf, input_size));\n\tgoto on_return;\n    }\n\n    if (and_media_data->predecode) {\n\tinput_.buf = input_buf;\n\tand_media_data->predecode(codec_data, input, &input_);\n    } else {\n\tinput_.size = input->size;\n\tpj_memcpy(input_buf, input->buf, input->size);\n    }\n\n    am_status = AMediaCodec_queueInputBuffer(codec_data->dec,\n\t\t\t\t\t     buf_idx,\n\t\t\t\t\t     0,\n\t\t\t\t\t     input_.size,\n\t\t\t\t\t     input->timestamp.u32.lo,\n\t\t\t\t\t     0);\n    if (am_status != AMEDIA_OK) {\n\tPJ_LOG(4,(THIS_FILE, \"Decoder queueInputBuffer failed return %d\",\n\t\t  am_status));\n\tgoto on_return;\n    }\n\n    for (i = 0; i < CODEC_WAIT_RETRY; ++i) {\n\tbuf_idx = AMediaCodec_dequeueOutputBuffer(codec_data->dec,\n\t\t\t\t\t\t  &buf_info,\n\t\t\t\t\t\t  CODEC_DEQUEUE_TIMEOUT);\n\tif (buf_idx == -1) {\n\t    /* Timeout, wait until output buffer is availble. */\n\t    PJ_LOG(5, (THIS_FILE, \"Decoder dequeueOutputBuffer timeout[%d]\",\n\t\t       i+1));\n\t    pj_thread_sleep(CODEC_THREAD_WAIT);\n\t} else {\n\t    break;\n\t}\n    }\n    if (buf_idx < 0) {\n\tPJ_LOG(5, (THIS_FILE, \"Decoder dequeueOutputBuffer failed [%d]\",\n\t\t   buf_idx));\n\tgoto on_return;\n    }\n\n    output_buf = AMediaCodec_getOutputBuffer(codec_data->dec,\n\t\t\t\t\t     buf_idx,\n\t\t\t\t\t     &output_size);\n    if (output_buf == NULL) {\n\tam_status = AMediaCodec_releaseOutputBuffer(codec_data->dec,\n\t\t\t\t\tbuf_idx,\n\t\t\t\t\t0);\n\tif (am_status != AMEDIA_OK) {\n\t    PJ_LOG(4,(THIS_FILE, \"Decoder releaseOutputBuffer failed %d\",\n\t\t      am_status));\n\t}\n\tPJ_LOG(4,(THIS_FILE, \"Decoder getOutputBuffer failed\"));\n\tgoto on_return;\n    }\n    pj_memcpy(output->buf, output_buf, buf_info.size);\n    output->type = PJMEDIA_FRAME_TYPE_AUDIO;\n    output->size = buf_info.size;\n    output->timestamp.u64 = input->timestamp.u64;\n    am_status = AMediaCodec_releaseOutputBuffer(codec_data->dec,\n\t\t\t\t\t\tbuf_idx,\n\t\t\t\t\t\t0);\n\n    /* Invoke external PLC if codec has no internal PLC */\n    if (codec_data->plc && codec_data->plc_enabled)\n\tpjmedia_plc_save(codec_data->plc, (pj_int16_t*)output->buf);\n\n    return PJ_SUCCESS;\n\non_return:\n    pjmedia_zero_samples((pj_int16_t*)output->buf, samples_per_frame);\n    output->size = samples_per_frame << 1;\n    output->timestamp.u64 = input->timestamp.u64;\n    output->type = PJMEDIA_FRAME_TYPE_AUDIO;\n    return PJ_SUCCESS;\n}\n\n/* \n * Recover lost frame.\n */\nstatic pj_status_t  and_media_codec_recover(pjmedia_codec *codec,\n\t\t\t\t\t    unsigned output_buf_len,\n\t\t\t\t\t    struct pjmedia_frame *output)\n{\n    and_media_private_t *codec_data = (and_media_private_t*) codec->codec_data;\n    struct and_media_codec *and_media_data =\n\t\t\t\t\t&and_media_codec[codec_data->codec_idx];\n    unsigned samples_per_frame;\n    pj_bool_t generate_plc = (codec_data->plc_enabled && codec_data->plc);\n\n    PJ_UNUSED_ARG(output_buf_len);\n\n    samples_per_frame = and_media_data->samples_per_frame;\n    output->type = PJMEDIA_FRAME_TYPE_AUDIO;\n    output->size = samples_per_frame << 1;\n\n    if (generate_plc)\n\tpjmedia_plc_generate(codec_data->plc, (pj_int16_t*)output->buf);\n    else\n\tpjmedia_zero_samples((pj_int16_t*)output->buf, samples_per_frame);\n\n    return PJ_SUCCESS;\n}\n\n\n#endif\t/* PJMEDIA_HAS_ANDROID_MEDIACODEC */\n\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia-codec/ipp_codecs.h>\n#include <pjmedia-codec/amr_sdp_match.h>\n#include <pjmedia-codec/g7221_sdp_match.h>\n#include <pjmedia/codec.h>\n#include <pjmedia/errno.h>\n#include <pjmedia/endpoint.h>\n#include <pjmedia/plc.h>\n#include <pjmedia/port.h>\n#include <pjmedia/silencedet.h>\n#include <pj/assert.h>\n#include <pj/log.h>\n#include <pj/math.h>\n#include <pj/pool.h>\n#include <pj/string.h>\n#include <pj/os.h>\n\n\n/*\n * Only build this file if PJMEDIA_HAS_INTEL_IPP != 0\n */\n#if defined(PJMEDIA_HAS_INTEL_IPP) && PJMEDIA_HAS_INTEL_IPP != 0\n\n#include <usc.h>\n#include <ippversion.h>\n\n#define THIS_FILE   \"ipp_codecs.c\"\n\n\n/* Prototypes for IPP codecs factory */\nstatic pj_status_t ipp_test_alloc( pjmedia_codec_factory *factory, \n\t\t\t\t   const pjmedia_codec_info *id );\nstatic pj_status_t ipp_default_attr( pjmedia_codec_factory *factory, \n\t\t\t\t     const pjmedia_codec_info *id, \n\t\t\t\t     pjmedia_codec_param *attr );\nstatic pj_status_t ipp_enum_codecs( pjmedia_codec_factory *factory, \n\t\t\t\t    unsigned *count, \n\t\t\t\t    pjmedia_codec_info codecs[]);\nstatic pj_status_t ipp_alloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t    const pjmedia_codec_info *id, \n\t\t\t\t    pjmedia_codec **p_codec);\nstatic pj_status_t ipp_dealloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t      pjmedia_codec *codec );\n\n/* Prototypes for IPP codecs implementation. */\nstatic pj_status_t  ipp_codec_init( pjmedia_codec *codec, \n\t\t\t\t    pj_pool_t *pool );\nstatic pj_status_t  ipp_codec_open( pjmedia_codec *codec, \n\t\t\t\t    pjmedia_codec_param *attr );\nstatic pj_status_t  ipp_codec_close( pjmedia_codec *codec );\nstatic pj_status_t  ipp_codec_modify(pjmedia_codec *codec, \n\t\t\t\t     const pjmedia_codec_param *attr );\nstatic pj_status_t  ipp_codec_parse( pjmedia_codec *codec,\n\t\t\t\t     void *pkt,\n\t\t\t\t     pj_size_t pkt_size,\n\t\t\t\t     const pj_timestamp *ts,\n\t\t\t\t     unsigned *frame_cnt,\n\t\t\t\t     pjmedia_frame frames[]);\nstatic pj_status_t  ipp_codec_encode( pjmedia_codec *codec, \n\t\t\t\t      const struct pjmedia_frame *input,\n\t\t\t\t      unsigned output_buf_len, \n\t\t\t\t      struct pjmedia_frame *output);\nstatic pj_status_t  ipp_codec_decode( pjmedia_codec *codec, \n\t\t\t\t      const struct pjmedia_frame *input,\n\t\t\t\t      unsigned output_buf_len, \n\t\t\t\t      struct pjmedia_frame *output);\nstatic pj_status_t  ipp_codec_recover(pjmedia_codec *codec, \n\t\t\t\t      unsigned output_buf_len, \n\t\t\t\t      struct pjmedia_frame *output);\n\n/* Definition for IPP codecs operations. */\nstatic pjmedia_codec_op ipp_op = \n{\n    &ipp_codec_init,\n    &ipp_codec_open,\n    &ipp_codec_close,\n    &ipp_codec_modify,\n    &ipp_codec_parse,\n    &ipp_codec_encode,\n    &ipp_codec_decode,\n    &ipp_codec_recover\n};\n\n/* Definition for IPP codecs factory operations. */\nstatic pjmedia_codec_factory_op ipp_factory_op =\n{\n    &ipp_test_alloc,\n    &ipp_default_attr,\n    &ipp_enum_codecs,\n    &ipp_alloc_codec,\n    &ipp_dealloc_codec,\n    &pjmedia_codec_ipp_deinit\n};\n\n/* IPP codecs factory */\nstatic struct ipp_factory {\n    pjmedia_codec_factory    base;\n    pjmedia_endpt\t    *endpt;\n    pj_pool_t\t\t    *pool;\n    pj_mutex_t\t\t    *mutex;\n    unsigned\t\t     g7221_pcm_shift;\n} ipp_factory;\n\n/* IPP codecs private data. */\ntypedef struct ipp_private {\n    int\t\t\t codec_idx;\t    /**< Codec index.\t\t    */\n    void\t\t*codec_setting;\t    /**< Specific codec setting.    */\n    pj_pool_t\t\t*pool;\t\t    /**< Pool for each instance.    */\n\n    USC_Handle\t\t enc;\t\t    /**< Encoder state.\t\t    */\n    USC_Handle\t\t dec;\t\t    /**< Decoder state.\t\t    */\n    USC_CodecInfo\t*info;\t\t    /**< Native codec info.\t    */\n    pj_uint16_t\t\t frame_size;\t    /**< Bitstream frame size.\t    */\n\n    pj_bool_t\t\t plc_enabled;\t    /**< PLC enabled flag.\t    */\n    pjmedia_plc\t\t*plc;\t\t    /**< PJMEDIA PLC engine, NULL if \n\t\t\t\t\t\t codec has internal PLC.    */\n\n    pj_bool_t\t\t vad_enabled;\t    /**< VAD enabled flag.\t    */\n    pjmedia_silence_det\t*vad;\t\t    /**< PJMEDIA VAD engine, NULL if \n\t\t\t\t\t\t codec has internal VAD.    */\n    pj_timestamp\t last_tx;\t    /**< Timestamp of last transmit.*/\n\n    unsigned\t\t g7221_pcm_shift;   /**< G722.1 PCM level adjustment*/\n} ipp_private_t;\n\n\n/* USC codec implementations. */\nextern USC_Fxns USC_G729AFP_Fxns;\nextern USC_Fxns USC_G729I_Fxns;\nextern USC_Fxns USC_G723_Fxns;\nextern USC_Fxns USC_G726_Fxns;\nextern USC_Fxns USC_G728_Fxns;\nextern USC_Fxns USC_G722_Fxns;\nextern USC_Fxns USC_GSMAMR_Fxns;\nextern USC_Fxns USC_AMRWB_Fxns;\nextern USC_Fxns USC_AMRWBE_Fxns;\n\n\n/* CUSTOM CALLBACKS */\n\n/* This callback is useful for translating RTP frame into USC frame, e.g:\n * reassigning frame attributes, reorder bitstream. Default behaviour of\n * the translation is just setting the USC frame buffer & its size as \n * specified in RTP frame, setting USC frame frametype to 0, setting bitrate\n * of USC frame to bitrate info of codec_data. Implement this callback when \n * the default behaviour is unapplicable.\n */\ntypedef void (*predecode_cb)(ipp_private_t *codec_data,\n\t\t\t     const pjmedia_frame *rtp_frame,\n\t\t\t     USC_Bitstream *usc_frame);\n\n/* Parse frames from a packet. Default behaviour of frame parsing is \n * just separating frames based on calculating frame length derived \n * from bitrate. Implement this callback when the default behaviour is \n * unapplicable.\n */\ntypedef pj_status_t (*parse_cb)(ipp_private_t *codec_data, void *pkt, \n\t\t\t\tpj_size_t pkt_size, const pj_timestamp *ts,\n\t\t\t\tunsigned *frame_cnt, pjmedia_frame frames[]);\n\n/* Pack frames into a packet. Default behaviour of packing frames is \n * just stacking the frames with octet aligned without adding any \n * payload header. Implement this callback when the default behaviour is\n * unapplicable.\n */\ntypedef pj_status_t (*pack_cb)(ipp_private_t *codec_data, void *pkt, \n\t\t\t       pj_size_t *pkt_size, pj_size_t max_pkt_size);\n\n\n\n/* Custom callback implementations. */\nstatic    void predecode_g723( ipp_private_t *codec_data,\n\t\t\t       const pjmedia_frame *rtp_frame,\n\t\t\t       USC_Bitstream *usc_frame);\nstatic pj_status_t parse_g723( ipp_private_t *codec_data, void *pkt, \n\t\t\t       pj_size_t pkt_size, const pj_timestamp *ts,\n\t\t\t       unsigned *frame_cnt, pjmedia_frame frames[]);\n\nstatic void predecode_g729( ipp_private_t *codec_data,\n\t\t\t    const pjmedia_frame *rtp_frame,\n\t\t\t    USC_Bitstream *usc_frame);\n\nstatic    void predecode_amr( ipp_private_t *codec_data,\n\t\t\t      const pjmedia_frame *rtp_frame,\n\t\t\t      USC_Bitstream *usc_frame);\nstatic pj_status_t parse_amr( ipp_private_t *codec_data, void *pkt, \n\t\t\t      pj_size_t pkt_size, const pj_timestamp *ts,\n\t\t\t      unsigned *frame_cnt, pjmedia_frame frames[]);\nstatic  pj_status_t pack_amr( ipp_private_t *codec_data, void *pkt, \n\t\t\t      pj_size_t *pkt_size, pj_size_t max_pkt_size);\n\nstatic    void predecode_g7221( ipp_private_t *codec_data,\n\t\t\t\tconst pjmedia_frame *rtp_frame,\n\t\t\t\tUSC_Bitstream *usc_frame);\nstatic  pj_status_t pack_g7221( ipp_private_t *codec_data, void *pkt, \n\t\t\t        pj_size_t *pkt_size, pj_size_t max_pkt_size);\n\n/* IPP codec implementation descriptions. */\nstatic struct ipp_codec {\n    int\t\t     enabled;\t\t/* Is this codec enabled?\t    */\n    const char\t    *name;\t\t/* Codec name.\t\t\t    */\n    pj_uint8_t\t     pt;\t\t/* Payload type.\t\t    */\n    USC_Fxns\t    *fxns;\t\t/* USC callback functions.\t    */\n    unsigned\t     clock_rate;\t/* Codec's clock rate.\t\t    */\n    unsigned\t     channel_count;\t/* Codec's channel count.\t    */\n    unsigned\t     samples_per_frame;\t/* Codec's samples count.\t    */\n\n    unsigned\t     def_bitrate;\t/* Default bitrate of this codec.   */\n    unsigned\t     max_bitrate;\t/* Maximum bitrate of this codec.   */\n    pj_uint8_t\t     frm_per_pkt;\t/* Default num of frames per packet.*/\n    int\t\t     has_native_vad;\t/* Codec has internal VAD?\t    */\n    int\t\t     has_native_plc;\t/* Codec has internal PLC?\t    */\n\n    predecode_cb     predecode;\t\t/* Callback to translate RTP frame\n\t\t\t\t\t   into USC frame.\t\t    */\n    parse_cb\t     parse;\t\t/* Callback to parse bitstream.\t    */\n    pack_cb\t     pack;\t\t/* Callback to pack bitstream.\t    */\n\n    pjmedia_codec_fmtp dec_fmtp;\t/* Decoder's fmtp params.\t    */\n}\n\nipp_codec[] = \n{\n#   if PJMEDIA_HAS_INTEL_IPP_CODEC_AMR\n    {1, \"AMR\",\t    PJMEDIA_RTP_PT_AMR,       &USC_GSMAMR_Fxns,  8000, 1, 160, \n\t\t    7400, 12200, 2, 1, 1, \n\t\t    &predecode_amr, &parse_amr, &pack_amr,\n\t\t    {1, {{{\"octet-align\", 11}, {\"1\", 1}}} }\n    },\n#   endif\n\n#   if PJMEDIA_HAS_INTEL_IPP_CODEC_AMRWB\n    {1, \"AMR-WB\",   PJMEDIA_RTP_PT_AMRWB,     &USC_AMRWB_Fxns,  16000, 1, 320,\n\t\t    15850, 23850, 2, 1, 1, \n\t\t    &predecode_amr, &parse_amr, &pack_amr,\n\t\t    {1, {{{\"octet-align\", 11}, {\"1\", 1}}} }\n    },\n#   endif\n\n#   if PJMEDIA_HAS_INTEL_IPP_CODEC_G729\n#\tif defined(PJ_HAS_FLOATING_POINT) && (PJ_HAS_FLOATING_POINT != 0)\n    {1, \"G729\",\t    PJMEDIA_RTP_PT_G729,      &USC_G729AFP_Fxns, 8000, 1,  80,\n\t\t    8000, 11800, 2, 1, 1, \n\t\t    &predecode_g729, NULL, NULL\n    },\n#\telse\n    {1, \"G729\",\t    PJMEDIA_RTP_PT_G729,      &USC_G729I_Fxns,\t 8000, 1,  80,\n\t\t    8000, 11800, 2, 1, 1, \n\t\t    &predecode_g729, NULL, NULL\n    },\n#\tendif\n#   endif\n\n#   if PJMEDIA_HAS_INTEL_IPP_CODEC_G723_1\n    /* This is actually G.723.1 */\n    {1, \"G723\",\t    PJMEDIA_RTP_PT_G723,      &USC_G723_Fxns,\t 8000, 1, 240,  \n\t\t    6300,  6300, 1, 1, 1, \n\t\t    &predecode_g723, &parse_g723, NULL\n    },\n#   endif\n\n#   if PJMEDIA_HAS_INTEL_IPP_CODEC_G726\n    {0, \"G726-16\",  PJMEDIA_RTP_PT_G726_16,   &USC_G726_Fxns,\t 8000, 1,  80, \n\t\t    16000, 16000, 2, 0, 0,\n\t\t    NULL, NULL, NULL\n    },\n    {0, \"G726-24\",  PJMEDIA_RTP_PT_G726_24,   &USC_G726_Fxns,\t 8000, 1,  80, \n\t\t    24000, 24000, 2, 0, 0,\n\t\t    NULL, NULL, NULL\n    },\n    {1, \"G726-32\",  PJMEDIA_RTP_PT_G726_32,   &USC_G726_Fxns,\t 8000, 1,  80, \n\t\t    32000, 32000, 2, 0, 0,\n\t\t    NULL, NULL, NULL\n    },\n    {0, \"G726-40\",  PJMEDIA_RTP_PT_G726_40,   &USC_G726_Fxns,\t 8000, 1,  80, \n\t\t    40000, 40000, 2, 0, 0,\n\t\t    NULL, NULL, NULL\n    },\n    /* Old definition of G726-32 */\n    {1, \"G721\",\t    PJMEDIA_RTP_PT_G721,      &USC_G726_Fxns,\t 8000, 1,  80, \n\t\t    32000, 32000, 2, 0, 0,\n\t\t    NULL, NULL, NULL\n    },\n#   endif\n\n#   if PJMEDIA_HAS_INTEL_IPP_CODEC_G728\n    {1, \"G728\",\t    PJMEDIA_RTP_PT_G728,      &USC_G728_Fxns,\t 8000, 1,  80, \n\t\t    16000, 16000, 2, 0, 1,\n\t\t    NULL, NULL, NULL\n    },\n#   endif\n\n#   if PJMEDIA_HAS_INTEL_IPP_CODEC_G722_1\n    {0, \"G7221\",    PJMEDIA_RTP_PT_G722_1_16, &USC_G722_Fxns,\t16000, 1, 320, \n\t\t    16000, 16000, 1, 0, 1,\n\t\t    predecode_g7221, NULL, pack_g7221,\n\t\t    {1, {{{\"bitrate\", 7}, {\"16000\", 5}}} }\n    },\n    {1, \"G7221\",    PJMEDIA_RTP_PT_G722_1_24, &USC_G722_Fxns,\t16000, 1, 320, \n\t\t    24000, 24000, 1, 0, 1,\n\t\t    predecode_g7221, NULL, pack_g7221,\n\t\t    {1, {{{\"bitrate\", 7}, {\"24000\", 5}}} }\n    },\n    {1, \"G7221\",    PJMEDIA_RTP_PT_G722_1_32, &USC_G722_Fxns,\t16000, 1, 320, \n\t\t    32000, 32000, 1, 0, 1,\n\t\t    predecode_g7221, NULL, pack_g7221,\n\t\t    {1, {{{\"bitrate\", 7}, {\"32000\", 5}}} }\n    },\n#   endif\n};\n\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_G729\n\nstatic void predecode_g729( ipp_private_t *codec_data,\n\t\t\t    const pjmedia_frame *rtp_frame,\n\t\t\t    USC_Bitstream *usc_frame)\n{\n    switch (rtp_frame->size) {\n    case 2:\n\t/* SID */\n\tusc_frame->frametype = 1;\n\tusc_frame->bitrate = codec_data->info->params.modes.bitrate;\n\tbreak;\n    case 8:  \n\t/* G729D */\n\tusc_frame->frametype = 2;\n\tusc_frame->bitrate = 6400;\n\tbreak;\n    case 10: \n\t/* G729 */\n\tusc_frame->frametype = 3;\n\tusc_frame->bitrate = 8000;\n\tbreak;\n    case 15: \n\t/* G729E */\n\tusc_frame->frametype = 4;\n\tusc_frame->bitrate = 11800;\n\tbreak;\n    default: \n\tusc_frame->frametype = 0;\n\tusc_frame->bitrate = 0;\n\tbreak;\n    }\n\n    usc_frame->pBuffer = rtp_frame->buf;\n    usc_frame->nbytes = rtp_frame->size;\n}\n\n#endif /* PJMEDIA_HAS_INTEL_IPP_CODEC_G729 */\n\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_G723_1\n\nstatic    void predecode_g723( ipp_private_t *codec_data,\n\t\t\t       const pjmedia_frame *rtp_frame,\n\t\t\t       USC_Bitstream *usc_frame)\n{\n    int i, HDR = 0;\n    pj_uint8_t *f = (pj_uint8_t*)rtp_frame->buf;\n\n    PJ_UNUSED_ARG(codec_data);\n\n    for (i = 0; i < 2; ++i){\n\tint tmp;\n\ttmp = (f[0] >> (i & 0x7)) & 1;\n\tHDR +=  tmp << i ;\n    }\n\n    usc_frame->pBuffer = rtp_frame->buf;\n    usc_frame->nbytes = rtp_frame->size;\n    usc_frame->bitrate = HDR == 0? 6300 : 5300;\n    usc_frame->frametype = 0;\n}\n\nstatic pj_status_t parse_g723(ipp_private_t *codec_data, void *pkt, \n\t\t\t      pj_size_t pkt_size, const pj_timestamp *ts,\n\t\t\t      unsigned *frame_cnt, pjmedia_frame frames[])\n{\n    unsigned count = 0;\n    pj_uint8_t *f = (pj_uint8_t*)pkt;\n\n    while (pkt_size && count < *frame_cnt) {\n\tint framesize, i, j;\n\tint HDR = 0;\n\n\tfor (i = 0; i < 2; ++i){\n\t    j = (f[0] >> (i & 0x7)) & 1;\n\t    HDR +=  j << i ;\n\t}\n\n\tif (HDR == 0)\n\t    framesize = 24;\n\telse if (HDR == 1)\n\t    framesize = 20;\n\telse if (HDR == 2)\n\t    framesize = 4;\n\telse if (HDR == 3)\n\t    framesize = 1;\n\telse {\n\t    pj_assert(!\"Unknown G723.1 frametype, packet may be corrupted!\");\n\t    return PJMEDIA_CODEC_EINMODE;\n\t}\n\n\tframes[count].type = PJMEDIA_FRAME_TYPE_AUDIO;\n\tframes[count].buf = f;\n\tframes[count].size = framesize;\n\tframes[count].timestamp.u64 = ts->u64 + count * \n\t\t\tipp_codec[codec_data->codec_idx].samples_per_frame;\n\n\tf += framesize;\n\tpkt_size -= framesize;\n\n\t++count;\n    }\n\n    *frame_cnt = count;\n    return PJ_SUCCESS;\n}\n\n#endif /* PJMEDIA_HAS_INTEL_IPP_CODEC_G723_1 */\n\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_AMR || PJMEDIA_HAS_INTEL_IPP_CODEC_AMRWB\n\n#include <pjmedia-codec/amr_helper.h>\n\ntypedef struct amr_settings_t {\n    pjmedia_codec_amr_pack_setting enc_setting;\n    pjmedia_codec_amr_pack_setting dec_setting;\n    pj_int8_t enc_mode;\n} amr_settings_t;\n\n\n/* Rearrange AMR bitstream and convert RTP frame into USC frame:\n * - make the start_bit to be 0\n * - if it is speech frame, reorder bitstream from sensitivity bits order\n *   to encoder bits order.\n * - set the appropriate value of usc_frame.\n */\nstatic void predecode_amr( ipp_private_t *codec_data,\n\t\t\t   const pjmedia_frame *rtp_frame,\n\t\t\t   USC_Bitstream *usc_frame)\n{\n    pjmedia_frame frame;\n    pjmedia_codec_amr_bit_info *info;\n    pjmedia_codec_amr_pack_setting *setting;\n\n    setting = &((amr_settings_t*)codec_data->codec_setting)->dec_setting;\n\n    frame = *rtp_frame;\n    pjmedia_codec_amr_predecode(rtp_frame, setting, &frame);\n    info = (pjmedia_codec_amr_bit_info*) &frame.bit_info;\n\n    usc_frame->pBuffer = frame.buf;\n    usc_frame->nbytes = frame.size;\n    if (info->mode != -1) {\n\tusc_frame->bitrate = setting->amr_nb? \n\t\t\t     pjmedia_codec_amrnb_bitrates[info->mode]:\n\t\t\t     pjmedia_codec_amrwb_bitrates[info->mode];\n    } else {\n\tusc_frame->bitrate = 0;\n    }\n\n    if (frame.size > 5) {\n\t/* Speech */\n\tif (info->good_quality)\n\t    usc_frame->frametype = 0;\n\telse\n\t    usc_frame->frametype = setting->amr_nb ? 5 : 6;\n    } else if (frame.size == 5) {\n\t/* SID */\n\tif (info->good_quality) {\n\t    usc_frame->frametype = info->STI? 2 : 1;\n\t} else {\n\t    usc_frame->frametype = setting->amr_nb ? 6 : 7;\n\t}\n    } else {\n\t/* no data */\n\tusc_frame->frametype = 3;\n    }\n}\n\n/* Pack AMR payload */\nstatic pj_status_t pack_amr(ipp_private_t *codec_data, void *pkt, \n\t\t\t    pj_size_t *pkt_size, pj_size_t max_pkt_size)\n{\n    enum {MAX_FRAMES_PER_PACKET = PJMEDIA_MAX_FRAME_DURATION_MS / 20};\n\n    pjmedia_frame frames[MAX_FRAMES_PER_PACKET];\n    unsigned nframes = 0;\n    pjmedia_codec_amr_bit_info *info;\n    pj_uint8_t *r; /* Read cursor */\n    pj_uint8_t SID_FT;\n    pjmedia_codec_amr_pack_setting *setting;\n    const pj_uint8_t *framelen_tbl;\n\n    setting = &((amr_settings_t*)codec_data->codec_setting)->enc_setting;\n    framelen_tbl = setting->amr_nb? pjmedia_codec_amrnb_framelen:\n\t\t\t\t    pjmedia_codec_amrwb_framelen;\n\n    SID_FT = (pj_uint8_t)(setting->amr_nb? 8 : 9);\n\n    /* Align pkt buf right */\n    r = (pj_uint8_t*)pkt + max_pkt_size - *pkt_size;\n    pj_memmove(r, pkt, *pkt_size);\n\n    /* Get frames */\n    for (;;) {\n\tpj_bool_t eof;\n\tpj_uint16_t info_;\n\n\tinfo_ = *((pj_uint16_t*)r);\n\teof = ((info_ & 0x40) != 0);\n\n\tinfo = (pjmedia_codec_amr_bit_info*) &frames[nframes].bit_info;\n\tpj_bzero(info, sizeof(*info));\n\tinfo->frame_type = (pj_uint8_t)(info_ & 0x0F);\n\tinfo->good_quality = (pj_uint8_t)((info_ & 0x80) == 0);\n\tinfo->mode = (pj_int8_t) ((info_ >> 8) & 0x0F);\n\tinfo->STI = (pj_uint8_t)((info_ >> 5) & 1);\n\n\tframes[nframes].buf = r + 2;\n\tframes[nframes].size = info->frame_type <= SID_FT ?\n\t\t\t       framelen_tbl[info->frame_type] : 0;\n\n\tr += frames[nframes].size + 2;\n\n\t/* Last frame */\n\tif (++nframes >= MAX_FRAMES_PER_PACKET || eof)\n\t    break;\n    }\n\n    /* Pack */\n    *pkt_size = max_pkt_size;\n    return pjmedia_codec_amr_pack(frames, nframes, setting, pkt, pkt_size);\n}\n\n\n/* Parse AMR payload into frames. */\nstatic pj_status_t parse_amr(ipp_private_t *codec_data, void *pkt, \n\t\t\t     pj_size_t pkt_size, const pj_timestamp *ts,\n\t\t\t     unsigned *frame_cnt, pjmedia_frame frames[])\n{\n    amr_settings_t* s = (amr_settings_t*)codec_data->codec_setting;\n    pjmedia_codec_amr_pack_setting *setting;\n    pj_status_t status;\n    pj_uint8_t cmr;\n\n    setting = &s->dec_setting;\n\n    status = pjmedia_codec_amr_parse(pkt, pkt_size, ts, setting, frames, \n\t\t\t\t     frame_cnt, &cmr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Check Change Mode Request. */\n    if (((setting->amr_nb && cmr <= 7) || (!setting->amr_nb && cmr <= 8)) &&\n\ts->enc_mode != cmr)\n    {\n\tstruct ipp_codec *ippc = &ipp_codec[codec_data->codec_idx];\n\n\ts->enc_mode = cmr;\n\tcodec_data->info->params.modes.bitrate = s->enc_setting.amr_nb?\n\t\t\t\tpjmedia_codec_amrnb_bitrates[s->enc_mode] :\n\t\t\t\tpjmedia_codec_amrwb_bitrates[s->enc_mode];\n\tippc->fxns->std.Control(&codec_data->info->params.modes, \n\t\t\t\tcodec_data->enc);\n\n\tPJ_LOG(4,(THIS_FILE, \"AMR%s switched encoding mode to: %d (%dbps)\",\n\t\t  (s->enc_setting.amr_nb?\"\":\"-WB\"),\n\t\t  s->enc_mode,\n\t\t  codec_data->info->params.modes.bitrate));\n    }\n\n    return PJ_SUCCESS;\n}\n\n#endif /* PJMEDIA_HAS_INTEL_IPP_CODEC_AMR */\n\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_G722_1\n\nstatic void predecode_g7221( ipp_private_t *codec_data,\n\t\t\t     const pjmedia_frame *rtp_frame,\n\t\t\t     USC_Bitstream *usc_frame)\n{\n    usc_frame->pBuffer = (char*)rtp_frame->buf;\n    usc_frame->nbytes = rtp_frame->size;\n    usc_frame->frametype = 0;\n    usc_frame->bitrate = codec_data->info->params.modes.bitrate;\n\n#if defined(PJ_IS_LITTLE_ENDIAN) && PJ_IS_LITTLE_ENDIAN!=0\n    {\n\tpj_uint16_t *p, *p_end;\n\n\tp = (pj_uint16_t*)rtp_frame->buf;\n\tp_end = p + rtp_frame->size/2;\n\twhile (p < p_end) {\n\t    *p = pj_ntohs(*p);\n\t    ++p;\n\t}\n    }\n#endif\n}\n\nstatic pj_status_t pack_g7221( ipp_private_t *codec_data, void *pkt, \n\t\t\t       pj_size_t *pkt_size, pj_size_t max_pkt_size)\n{\n    PJ_UNUSED_ARG(codec_data);\n    PJ_UNUSED_ARG(max_pkt_size);\n\n#if defined(PJ_IS_LITTLE_ENDIAN) && PJ_IS_LITTLE_ENDIAN!=0\n    {\n\tpj_uint16_t *p, *p_end;\n\n\tp = (pj_uint16_t*)pkt;\n\tp_end = p + *pkt_size/2;\n\twhile (p < p_end) {\n\t    *p = pj_htons(*p);\n\t    ++p;\n\t}\n    }\n#else\n    PJ_UNUSED_ARG(pkt);\n    PJ_UNUSED_ARG(pkt_size);\n#endif\n\n    return PJ_SUCCESS;\n}\n\n\n#include <pjmedia-codec/g7221.h>\n\n\nPJ_DEF(pj_status_t) pjmedia_codec_g7221_set_pcm_shift(int val)\n{\n    PJ_ASSERT_RETURN(val >= 0, PJ_EINVAL);\n\n    ipp_factory.g7221_pcm_shift = val;\n    return PJ_SUCCESS;\n}\n\n\n#endif /* PJMEDIA_HAS_INTEL_IPP_CODEC_G722_1 */\n\n/*\n * Initialize and register IPP codec factory to pjmedia endpoint.\n */\nPJ_DEF(pj_status_t) pjmedia_codec_ipp_init( pjmedia_endpt *endpt )\n{\n    pjmedia_codec_mgr *codec_mgr;\n    pj_str_t codec_name;\n    pj_status_t status;\n\n    if (ipp_factory.pool != NULL) {\n\t/* Already initialized. */\n\treturn PJ_SUCCESS;\n    }\n\n    /* Create IPP codec factory. */\n    ipp_factory.base.op = &ipp_factory_op;\n    ipp_factory.base.factory_data = NULL;\n    ipp_factory.endpt = endpt;\n    ipp_factory.g7221_pcm_shift = PJMEDIA_G7221_DEFAULT_PCM_SHIFT;\n\n    ipp_factory.pool = pjmedia_endpt_create_pool(endpt, \"IPP codecs\", 4000, 4000);\n    if (!ipp_factory.pool)\n\treturn PJ_ENOMEM;\n\n    /* Create mutex. */\n    status = pj_mutex_create_simple(ipp_factory.pool, \"IPP codecs\", \n\t\t\t\t    &ipp_factory.mutex);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Get the codec manager. */\n    codec_mgr = pjmedia_endpt_get_codec_mgr(endpt);\n    if (!codec_mgr) {\n\tstatus = PJ_EINVALIDOP;\n\tgoto on_error;\n    }\n\n    /* Register format match callback. */\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_G722_1\n    pj_cstr(&codec_name, \"G7221\");\n    status = pjmedia_sdp_neg_register_fmt_match_cb(\n\t\t\t\t\t&codec_name,\n\t\t\t\t\t&pjmedia_codec_g7221_match_sdp);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n#endif\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_AMR\n    pj_cstr(&codec_name, \"AMR\");\n    status = pjmedia_sdp_neg_register_fmt_match_cb(\n\t\t\t\t\t&codec_name,\n\t\t\t\t\t&pjmedia_codec_amr_match_sdp);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n#endif\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_AMRWB\n    pj_cstr(&codec_name, \"AMR-WB\");\n    status = pjmedia_sdp_neg_register_fmt_match_cb(\n\t\t\t\t\t&codec_name,\n\t\t\t\t\t&pjmedia_codec_amr_match_sdp);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n#endif\n\n    /* Suppress compile warning */\n    PJ_UNUSED_ARG(codec_name);\n\n    /* Register codec factory to endpoint. */\n    status = pjmedia_codec_mgr_register_factory(codec_mgr, \n\t\t\t\t\t\t&ipp_factory.base);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Done. */\n    return PJ_SUCCESS;\n\non_error:\n    pj_pool_release(ipp_factory.pool);\n    ipp_factory.pool = NULL;\n    return status;\n}\n\n/*\n * Unregister IPP codecs factory from pjmedia endpoint.\n */\nPJ_DEF(pj_status_t) pjmedia_codec_ipp_deinit(void)\n{\n    pjmedia_codec_mgr *codec_mgr;\n    pj_status_t status;\n\n    if (ipp_factory.pool == NULL) {\n\t/* Already deinitialized */\n\treturn PJ_SUCCESS;\n    }\n\n    pj_mutex_lock(ipp_factory.mutex);\n\n    /* Get the codec manager. */\n    codec_mgr = pjmedia_endpt_get_codec_mgr(ipp_factory.endpt);\n    if (!codec_mgr) {\n\tpj_pool_release(ipp_factory.pool);\n\tipp_factory.pool = NULL;\n\tpj_mutex_unlock(ipp_factory.mutex);\n\treturn PJ_EINVALIDOP;\n    }\n\n    /* Unregister IPP codecs factory. */\n    status = pjmedia_codec_mgr_unregister_factory(codec_mgr,\n\t\t\t\t\t\t  &ipp_factory.base);\n    \n    /* Destroy mutex. */\n    pj_mutex_unlock(ipp_factory.mutex);\n    pj_mutex_destroy(ipp_factory.mutex);\n    ipp_factory.mutex = NULL;\n\n    /* Destroy pool. */\n    pj_pool_release(ipp_factory.pool);\n    ipp_factory.pool = NULL;\n\n    return status;\n}\n\n\n/* \n * Check if factory can allocate the specified codec. \n */\nstatic pj_status_t ipp_test_alloc( pjmedia_codec_factory *factory, \n\t\t\t\t   const pjmedia_codec_info *info )\n{\n    unsigned i;\n\n    PJ_UNUSED_ARG(factory);\n\n    /* Type MUST be audio. */\n    if (info->type != PJMEDIA_TYPE_AUDIO)\n\treturn PJMEDIA_CODEC_EUNSUP;\n\n    for (i = 0; i < PJ_ARRAY_SIZE(ipp_codec); ++i) {\n\tpj_str_t name = pj_str((char*)ipp_codec[i].name);\n\tif ((pj_stricmp(&info->encoding_name, &name) == 0) &&\n\t    (info->clock_rate == (unsigned)ipp_codec[i].clock_rate) &&\n\t    (info->channel_cnt == (unsigned)ipp_codec[i].channel_count) &&\n\t    (ipp_codec[i].enabled))\n\t{\n\t    return PJ_SUCCESS;\n\t}\n    }\n    \n    /* Unsupported, or mode is disabled. */\n    return PJMEDIA_CODEC_EUNSUP;\n}\n\n/*\n * Generate default attribute.\n */\nstatic pj_status_t ipp_default_attr (pjmedia_codec_factory *factory, \n\t\t\t\t      const pjmedia_codec_info *id, \n\t\t\t\t      pjmedia_codec_param *attr )\n{\n    unsigned i;\n\n    PJ_ASSERT_RETURN(factory==&ipp_factory.base, PJ_EINVAL);\n\n    pj_bzero(attr, sizeof(pjmedia_codec_param));\n\n    for (i = 0; i < PJ_ARRAY_SIZE(ipp_codec); ++i) {\n\tpj_str_t name = pj_str((char*)ipp_codec[i].name);\n\tif ((pj_stricmp(&id->encoding_name, &name) == 0) &&\n\t    (id->clock_rate == (unsigned)ipp_codec[i].clock_rate) &&\n\t    (id->channel_cnt == (unsigned)ipp_codec[i].channel_count) &&\n\t    (id->pt == (unsigned)ipp_codec[i].pt))\n\t{\n\t    attr->info.pt = (pj_uint8_t)id->pt;\n\t    attr->info.channel_cnt = ipp_codec[i].channel_count;\n\t    attr->info.clock_rate = ipp_codec[i].clock_rate;\n\t    attr->info.avg_bps = ipp_codec[i].def_bitrate;\n\t    attr->info.max_bps = ipp_codec[i].max_bitrate;\n\t    attr->info.pcm_bits_per_sample = 16;\n\t    attr->info.frm_ptime =  (pj_uint16_t)\n\t\t\t\t    (ipp_codec[i].samples_per_frame * 1000 / \n\t\t\t\t    ipp_codec[i].channel_count / \n\t\t\t\t    ipp_codec[i].clock_rate);\n\t    attr->setting.frm_per_pkt = ipp_codec[i].frm_per_pkt;\n\n\t    /* Default flags. */\n\t    attr->setting.plc = 1;\n\t    attr->setting.penh= 0;\n\t    attr->setting.vad = 1;\n\t    attr->setting.cng = attr->setting.vad;\n\t    attr->setting.dec_fmtp = ipp_codec[i].dec_fmtp;\n\n\t    if (attr->setting.vad == 0) {\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_G729\n\t\tif (id->pt == PJMEDIA_RTP_PT_G729) {\n\t\t    /* Signal G729 Annex B is being disabled */\n\t\t    attr->setting.dec_fmtp.cnt = 1;\n\t\t    pj_strset2(&attr->setting.dec_fmtp.param[0].name, \"annexb\");\n\t\t    pj_strset2(&attr->setting.dec_fmtp.param[0].val, \"no\");\n\t\t}\n#endif\n\t    }\n\n\t    return PJ_SUCCESS;\n\t}\n    }\n\n    return PJMEDIA_CODEC_EUNSUP;\n}\n\n/*\n * Enum codecs supported by this factory.\n */\nstatic pj_status_t ipp_enum_codecs(pjmedia_codec_factory *factory, \n\t\t\t\t    unsigned *count, \n\t\t\t\t    pjmedia_codec_info codecs[])\n{\n    unsigned max;\n    unsigned i;\n\n    PJ_UNUSED_ARG(factory);\n    PJ_ASSERT_RETURN(codecs && *count > 0, PJ_EINVAL);\n\n    max = *count;\n    \n    for (i = 0, *count = 0; i < PJ_ARRAY_SIZE(ipp_codec) && *count < max; ++i) \n    {\n\tif (!ipp_codec[i].enabled)\n\t    continue;\n\n\tpj_bzero(&codecs[*count], sizeof(pjmedia_codec_info));\n\tcodecs[*count].encoding_name = pj_str((char*)ipp_codec[i].name);\n\tcodecs[*count].pt = ipp_codec[i].pt;\n\tcodecs[*count].type = PJMEDIA_TYPE_AUDIO;\n\tcodecs[*count].clock_rate = ipp_codec[i].clock_rate;\n\tcodecs[*count].channel_cnt = ipp_codec[i].channel_count;\n\n\t++*count;\n    }\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Allocate a new codec instance.\n */\nstatic pj_status_t ipp_alloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t    const pjmedia_codec_info *id,\n\t\t\t\t    pjmedia_codec **p_codec)\n{\n    ipp_private_t *codec_data;\n    pjmedia_codec *codec;\n    int idx;\n    pj_pool_t *pool;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(factory && id && p_codec, PJ_EINVAL);\n    PJ_ASSERT_RETURN(factory == &ipp_factory.base, PJ_EINVAL);\n\n    pj_mutex_lock(ipp_factory.mutex);\n\n    /* Find codec's index */\n    idx = -1;\n    for (i = 0; i < PJ_ARRAY_SIZE(ipp_codec); ++i) {\n\tpj_str_t name = pj_str((char*)ipp_codec[i].name);\n\tif ((pj_stricmp(&id->encoding_name, &name) == 0) &&\n\t    (id->clock_rate == (unsigned)ipp_codec[i].clock_rate) &&\n\t    (id->channel_cnt == (unsigned)ipp_codec[i].channel_count) &&\n\t    (ipp_codec[i].enabled))\n\t{\n\t    idx = i;\n\t    break;\n\t}\n    }\n    if (idx == -1) {\n\t*p_codec = NULL;\n\treturn PJMEDIA_CODEC_EFAILED;\n    }\n\n    /* Create pool for codec instance */\n    pool = pjmedia_endpt_create_pool(ipp_factory.endpt, \"IPPcodec\", 512, 512);\n    codec = PJ_POOL_ZALLOC_T(pool, pjmedia_codec);\n    PJ_ASSERT_RETURN(codec != NULL, PJ_ENOMEM);\n    codec->op = &ipp_op;\n    codec->factory = factory;\n    codec->codec_data = PJ_POOL_ZALLOC_T(pool, ipp_private_t);\n    codec_data = (ipp_private_t*) codec->codec_data;\n\n    /* Create PLC if codec has no internal PLC */\n    if (!ipp_codec[idx].has_native_plc) {\n\tpj_status_t status;\n\tstatus = pjmedia_plc_create(pool, ipp_codec[idx].clock_rate, \n\t\t\t\t    ipp_codec[idx].samples_per_frame, 0,\n\t\t\t\t    &codec_data->plc);\n\tif (status != PJ_SUCCESS) {\n\t    pj_pool_release(pool);\n\t    pj_mutex_unlock(ipp_factory.mutex);\n\t    return status;\n\t}\n    }\n\n    /* Create silence detector if codec has no internal VAD */\n    if (!ipp_codec[idx].has_native_vad) {\n\tpj_status_t status;\n\tstatus = pjmedia_silence_det_create(pool,\n\t\t\t\t\t    ipp_codec[idx].clock_rate,\n\t\t\t\t\t    ipp_codec[idx].samples_per_frame,\n\t\t\t\t\t    &codec_data->vad);\n\tif (status != PJ_SUCCESS) {\n\t    pj_pool_release(pool);\n\t    pj_mutex_unlock(ipp_factory.mutex);\n\t    return status;\n\t}\n    }\n\n    codec_data->pool = pool;\n    codec_data->codec_idx = idx;\n\n    pj_mutex_unlock(ipp_factory.mutex);\n\n    *p_codec = codec;\n    return PJ_SUCCESS;\n}\n\n/*\n * Free codec.\n */\nstatic pj_status_t ipp_dealloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t      pjmedia_codec *codec )\n{\n    ipp_private_t *codec_data;\n\n    PJ_ASSERT_RETURN(factory && codec, PJ_EINVAL);\n    PJ_ASSERT_RETURN(factory == &ipp_factory.base, PJ_EINVAL);\n\n    /* Close codec, if it's not closed. */\n    codec_data = (ipp_private_t*) codec->codec_data;\n    if (codec_data->enc != NULL || codec_data->dec != NULL) {\n\tipp_codec_close(codec);\n    }\n\n    pj_pool_release(codec_data->pool);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Init codec.\n */\nstatic pj_status_t ipp_codec_init( pjmedia_codec *codec, \n\t\t\t\t   pj_pool_t *pool )\n{\n    PJ_UNUSED_ARG(codec);\n    PJ_UNUSED_ARG(pool);\n    return PJ_SUCCESS;\n}\n\n/*\n * Open codec.\n */\nstatic pj_status_t ipp_codec_open( pjmedia_codec *codec, \n\t\t\t\t   pjmedia_codec_param *attr )\n{\n    ipp_private_t *codec_data = (ipp_private_t*) codec->codec_data;\n    struct ipp_codec *ippc = &ipp_codec[codec_data->codec_idx];\n    int info_size;\n    pj_pool_t *pool;\n    int i, j;\n    USC_MemBank *membanks;\n    int nb_membanks;\n\n    pool = codec_data->pool;\n\n    /* Get the codec info size */\n    if (USC_NoError != ippc->fxns->std.GetInfoSize(&info_size)) {\n\tPJ_LOG(1,(THIS_FILE, \"Error getting codec info size\"));\n\tgoto on_error;\n    }\n    /* Get the codec info */\n    codec_data->info = pj_pool_zalloc(pool, info_size);\n    if (USC_NoError != ippc->fxns->std.GetInfo((USC_Handle)NULL, \n\t\t\t\t\t       codec_data->info))\n    {\n\tPJ_LOG(1,(THIS_FILE, \"Error getting codec info\"));\n\tgoto on_error;\n    }\n\n    /* PREPARING THE ENCODER */\n\n    /* Setting the encoder params */\n    codec_data->info->params.direction = USC_ENCODE;\n    codec_data->info->params.modes.vad = attr->setting.vad && \n\t\t\t\t\t ippc->has_native_vad;\n    codec_data->info->params.modes.bitrate = attr->info.avg_bps;\n    codec_data->info->params.law = 0; /* Linear PCM input */\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_G729\n    if (ippc->pt == PJMEDIA_RTP_PT_G729) {\n\t/* Check if G729 Annex B is signaled to be disabled */\n\tfor (i = 0; i < attr->setting.enc_fmtp.cnt; ++i) {\n\t    if (pj_stricmp2(&attr->setting.enc_fmtp.param[i].name, \"annexb\")==0)\n\t    {\n\t\tif (pj_stricmp2(&attr->setting.enc_fmtp.param[i].val, \"no\")==0)\n\t\t{\n\t\t    attr->setting.vad = 0;\n\t\t    codec_data->info->params.modes.vad = 0;\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n    }\n#endif\n\n    /* Get number of memory blocks needed by the encoder */\n    if (USC_NoError != ippc->fxns->std.NumAlloc(&codec_data->info->params,\n\t\t\t\t\t        &nb_membanks))\n    {\n\tPJ_LOG(1,(THIS_FILE, \"Error getting no of memory blocks of encoder\"));\n\tgoto on_error;\n    }\n\n    /* Allocate memory blocks table */\n    membanks = (USC_MemBank*) pj_pool_zalloc(pool, \n\t\t\t\t\t     sizeof(USC_MemBank) * nb_membanks);\n    /* Get size of each memory block */\n    if (USC_NoError != ippc->fxns->std.MemAlloc(&codec_data->info->params, \n\t\t\t\t\t        membanks))\n    {\n\tPJ_LOG(1,(THIS_FILE, \"Error getting memory blocks size of encoder\"));\n\tgoto on_error;\n    }\n\n    /* Allocate memory for each block */\n    for (i = 0; i < nb_membanks; i++) {\n\tmembanks[i].pMem = (char*) pj_pool_zalloc(pool, membanks[i].nbytes);\n    }\n\n    /* Create encoder instance */\n    if (USC_NoError != ippc->fxns->std.Init(&codec_data->info->params,\n\t\t\t\t\t    membanks, \n\t\t\t\t\t    &codec_data->enc))\n    {\n\tPJ_LOG(1,(THIS_FILE, \"Error initializing encoder\"));\n\tgoto on_error;\n    }\n\n    /* PREPARING THE DECODER */\n\n    /* Setting the decoder params */\n    codec_data->info->params.direction = USC_DECODE;\n\n    /* Not sure if VAD affects decoder, just try to be safe */\n    //codec_data->info->params.modes.vad = ippc->has_native_vad;\n\n    /* Get number of memory blocks needed by the decoder */\n    if (USC_NoError != ippc->fxns->std.NumAlloc(&codec_data->info->params, \n\t\t\t\t\t\t &nb_membanks))\n    {\n\tPJ_LOG(1,(THIS_FILE, \"Error getting no of memory blocks of decoder\"));\n\tgoto on_error;\n    }\n\n    /* Allocate memory blocks table */\n    membanks = (USC_MemBank*) pj_pool_zalloc(pool, \n\t\t\t\t\t     sizeof(USC_MemBank) * nb_membanks);\n    /* Get size of each memory block */\n    if (USC_NoError != ippc->fxns->std.MemAlloc(&codec_data->info->params, \n\t\t\t\t\t\tmembanks))\n    {\n\tPJ_LOG(1,(THIS_FILE, \"Error getting memory blocks size of decoder\"));\n\tgoto on_error;\n    }\n\n    /* Allocate memory for each block */\n    for (i = 0; i < nb_membanks; i++) {\n\tmembanks[i].pMem = (char*) pj_pool_zalloc(pool, membanks[i].nbytes);\n    }\n\n    /* Create decoder instance */\n    if (USC_NoError != ippc->fxns->std.Init(&codec_data->info->params, \n\t\t\t\t\t    membanks, &codec_data->dec))\n    {\n\tPJ_LOG(1,(THIS_FILE, \"Error initializing decoder\"));\n\tgoto on_error;\n    }\n\n    /* Update codec info */\n    ippc->fxns->std.GetInfo((USC_Handle)codec_data->enc, codec_data->info);\n\n    /* Get bitstream size */\n    i = codec_data->info->params.modes.bitrate * ippc->samples_per_frame;\n    j = ippc->clock_rate << 3;\n    codec_data->frame_size = (pj_uint16_t)(i / j);\n    if (i % j) ++codec_data->frame_size;\n\n    codec_data->vad_enabled = (attr->setting.vad != 0);\n    codec_data->plc_enabled = (attr->setting.plc != 0);\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_AMR\n    /* Init AMR settings */\n    if (ippc->pt == PJMEDIA_RTP_PT_AMR || ippc->pt == PJMEDIA_RTP_PT_AMRWB) {\n\tamr_settings_t *s;\n\tpj_uint8_t octet_align = 0;\n\tpj_int8_t enc_mode;\n\n\tenc_mode = pjmedia_codec_amr_get_mode(\n\t\t\t\tcodec_data->info->params.modes.bitrate);\n\tpj_assert(enc_mode >= 0 && enc_mode <= 8);\n\n\t/* Check AMR specific attributes */\n\n\tfor (i = 0; i < attr->setting.dec_fmtp.cnt; ++i) {\n\t    /* octet-align, one of the parameters that must have same value \n\t     * in offer & answer (RFC 4867 Section 8.3.1). Just check fmtp\n\t     * in the decoder side, since it's value is guaranteed to fulfil \n\t     * above requirement (by SDP negotiator).\n\t     */\n\t    const pj_str_t STR_FMTP_OCTET_ALIGN = {\"octet-align\", 11};\n\t    \n\t    if (pj_stricmp(&attr->setting.dec_fmtp.param[i].name, \n\t\t\t   &STR_FMTP_OCTET_ALIGN) == 0)\n\t    {\n\t\toctet_align=(pj_uint8_t)\n\t\t\t    pj_strtoul(&attr->setting.dec_fmtp.param[i].val);\n\t\tbreak;\n\t    }\n\t}\n\n\tfor (i = 0; i < attr->setting.enc_fmtp.cnt; ++i) {\n\t    /* mode-set, encoding mode is chosen based on local default mode \n\t     * setting:\n\t     * - if local default mode is included in the mode-set, use it\n\t     * - otherwise, find the closest mode to local default mode;\n\t     *   if there are two closest modes, prefer to use the higher\n\t     *   one, e.g: local default mode is 4, the mode-set param\n\t     *   contains '2,3,5,6', then 5 will be chosen.\n\t     */\n\t    const pj_str_t STR_FMTP_MODE_SET = {\"mode-set\", 8};\n\t    \n\t    if (pj_stricmp(&attr->setting.enc_fmtp.param[i].name, \n\t\t\t   &STR_FMTP_MODE_SET) == 0)\n\t    {\n\t\tconst char *p;\n\t\tpj_size_t l;\n\t\tpj_int8_t diff = 99;\n\t\t\n\t\tp = pj_strbuf(&attr->setting.enc_fmtp.param[i].val);\n\t\tl = pj_strlen(&attr->setting.enc_fmtp.param[i].val);\n\n\t\twhile (l--) {\n\t\t    if ((ippc->pt==PJMEDIA_RTP_PT_AMR && *p>='0' && *p<='7') ||\n\t\t        (ippc->pt==PJMEDIA_RTP_PT_AMRWB && *p>='0' && *p<='8'))\n\t\t    {\n\t\t\tpj_int8_t tmp = (pj_int8_t)(*p - '0' - enc_mode);\n\n\t\t\tif (PJ_ABS(diff) > PJ_ABS(tmp) || \n\t\t\t    (PJ_ABS(diff) == PJ_ABS(tmp) && tmp > diff))\n\t\t\t{\n\t\t\t    diff = tmp;\n\t\t\t    if (diff == 0) break;\n\t\t\t}\n\t\t    }\n\t\t    ++p;\n\t\t}\n\n\t\tif (diff == 99)\n\t\t    goto on_error;\n\n\t\tenc_mode = (pj_int8_t)(enc_mode + diff);\n\n\t\tbreak;\n\t    }\n\t}\n\n\t/* Initialize AMR specific settings */\n\ts = PJ_POOL_ZALLOC_T(pool, amr_settings_t);\n\tcodec_data->codec_setting = s;\n\n\ts->enc_setting.amr_nb = (pj_uint8_t)(ippc->pt == PJMEDIA_RTP_PT_AMR);\n\ts->enc_setting.octet_aligned = octet_align;\n\ts->enc_setting.reorder = PJ_TRUE;\n\ts->enc_setting.cmr = 15;\n\n\ts->dec_setting.amr_nb = (pj_uint8_t)(ippc->pt == PJMEDIA_RTP_PT_AMR);\n\ts->dec_setting.octet_aligned = octet_align;\n\ts->dec_setting.reorder = PJ_TRUE;\n\n\t/* Apply encoder mode/bitrate */\n\ts->enc_mode = enc_mode;\n\tcodec_data->info->params.modes.bitrate = s->enc_setting.amr_nb?\n\t\t\t\tpjmedia_codec_amrnb_bitrates[s->enc_mode]:\n\t\t\t\tpjmedia_codec_amrwb_bitrates[s->enc_mode];\n\tippc->fxns->std.Control(&codec_data->info->params.modes, \n\t\t\t\tcodec_data->enc);\n\n\tPJ_LOG(4,(THIS_FILE, \"AMR%s encoding mode: %d (%dbps)\", \n\t\t  (s->enc_setting.amr_nb?\"\":\"-WB\"),\n\t\t  s->enc_mode,\n\t\t  codec_data->info->params.modes.bitrate));\n\n\t/* Return back bitrate info to application */\n\tattr->info.avg_bps = codec_data->info->params.modes.bitrate;\n    }\n#endif\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_G722_1\n    if (ippc->pt >= PJMEDIA_RTP_PT_G722_1_16 && \n\tippc->pt <= PJMEDIA_RTP_PT_G7221_RSV2)\n    {\n\tcodec_data->g7221_pcm_shift = ipp_factory.g7221_pcm_shift;\n    }\n#endif\n\n    return PJ_SUCCESS;\n\non_error:\n    return PJMEDIA_CODEC_EFAILED;\n}\n\n/*\n * Close codec.\n */\nstatic pj_status_t ipp_codec_close( pjmedia_codec *codec )\n{\n    PJ_UNUSED_ARG(codec);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Modify codec settings.\n */\nstatic pj_status_t  ipp_codec_modify(pjmedia_codec *codec, \n\t\t\t\t     const pjmedia_codec_param *attr )\n{\n    ipp_private_t *codec_data = (ipp_private_t*) codec->codec_data;\n    struct ipp_codec *ippc = &ipp_codec[codec_data->codec_idx];\n\n    codec_data->vad_enabled = (attr->setting.vad != 0);\n    codec_data->plc_enabled = (attr->setting.plc != 0);\n\n    if (ippc->has_native_vad) {\n\tUSC_Modes modes;\n\n\tmodes = codec_data->info->params.modes;\n\tmodes.vad = codec_data->vad_enabled;\n\tippc->fxns->std.Control(&modes, codec_data->enc);\n    }\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Get frames in the packet.\n */\nstatic pj_status_t  ipp_codec_parse( pjmedia_codec *codec,\n\t\t\t\t     void *pkt,\n\t\t\t\t     pj_size_t pkt_size,\n\t\t\t\t     const pj_timestamp *ts,\n\t\t\t\t     unsigned *frame_cnt,\n\t\t\t\t     pjmedia_frame frames[])\n{\n    ipp_private_t *codec_data = (ipp_private_t*) codec->codec_data;\n    struct ipp_codec *ippc = &ipp_codec[codec_data->codec_idx];\n    unsigned count = 0;\n\n    PJ_ASSERT_RETURN(frame_cnt, PJ_EINVAL);\n\n    if (ippc->parse != NULL) {\n\treturn ippc->parse(codec_data, pkt,  pkt_size, ts, frame_cnt, frames);\n    }\n\n    while (pkt_size >= codec_data->frame_size && count < *frame_cnt) {\n\tframes[count].type = PJMEDIA_FRAME_TYPE_AUDIO;\n\tframes[count].buf = pkt;\n\tframes[count].size = codec_data->frame_size;\n\tframes[count].timestamp.u64 = ts->u64 + count*ippc->samples_per_frame;\n\n\tpkt = ((char*)pkt) + codec_data->frame_size;\n\tpkt_size -= codec_data->frame_size;\n\n\t++count;\n    }\n\n    if (pkt_size && count < *frame_cnt) {\n\tframes[count].type = PJMEDIA_FRAME_TYPE_AUDIO;\n\tframes[count].buf = pkt;\n\tframes[count].size = pkt_size;\n\tframes[count].timestamp.u64 = ts->u64 + count*ippc->samples_per_frame;\n\t++count;\n    }\n\n    *frame_cnt = count;\n    return PJ_SUCCESS;\n}\n\n/*\n * Encode frames.\n */\nstatic pj_status_t ipp_codec_encode( pjmedia_codec *codec, \n\t\t\t\t     const struct pjmedia_frame *input,\n\t\t\t\t     unsigned output_buf_len, \n\t\t\t\t     struct pjmedia_frame *output)\n{\n    ipp_private_t *codec_data = (ipp_private_t*) codec->codec_data;\n    struct ipp_codec *ippc = &ipp_codec[codec_data->codec_idx];\n    unsigned samples_per_frame;\n    unsigned nsamples;\n    pj_size_t tx = 0;\n    pj_int16_t *pcm_in   = (pj_int16_t*)input->buf;\n    pj_uint8_t  *bits_out = (pj_uint8_t*) output->buf;\n    pj_uint8_t pt;\n\n    /* Invoke external VAD if codec has no internal VAD */\n    if (codec_data->vad && codec_data->vad_enabled) {\n\tpj_bool_t is_silence;\n\tpj_int32_t silence_duration;\n\n\tsilence_duration = pj_timestamp_diff32(&codec_data->last_tx, \n\t\t\t\t\t       &input->timestamp);\n\n\tis_silence = pjmedia_silence_det_detect(codec_data->vad, \n\t\t\t\t\t        (const pj_int16_t*) input->buf,\n\t\t\t\t\t\t(input->size >> 1),\n\t\t\t\t\t\tNULL);\n\tif (is_silence &&\n\t    (PJMEDIA_CODEC_MAX_SILENCE_PERIOD == -1 ||\n\t     silence_duration < (PJMEDIA_CODEC_MAX_SILENCE_PERIOD *\n\t \t\t\t (int)ippc->clock_rate / 1000)))\n\t{\n\t    output->type = PJMEDIA_FRAME_TYPE_NONE;\n\t    output->buf = NULL;\n\t    output->size = 0;\n\t    output->timestamp = input->timestamp;\n\t    return PJ_SUCCESS;\n\t} else {\n\t    codec_data->last_tx = input->timestamp;\n\t}\n    }\n\n    nsamples = input->size >> 1;\n    samples_per_frame = ippc->samples_per_frame;\n    pt = ippc->pt;\n\n    PJ_ASSERT_RETURN(nsamples % samples_per_frame == 0, \n\t\t     PJMEDIA_CODEC_EPCMFRMINLEN);\n\n    /* Encode the frames */\n    while (nsamples >= samples_per_frame) {\n\tUSC_PCMStream in;\n\tUSC_Bitstream out;\n\n\tin.bitrate = codec_data->info->params.modes.bitrate;\n\tin.nbytes = samples_per_frame << 1;\n\tin.pBuffer = (char*)pcm_in;\n\tin.pcmType.bitPerSample = codec_data->info->params.pcmType.bitPerSample;\n\tin.pcmType.nChannels = codec_data->info->params.pcmType.nChannels;\n\tin.pcmType.sample_frequency = codec_data->info->params.pcmType.sample_frequency;\n\n\tout.pBuffer = (char*)bits_out;\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_AMR\n\t/* For AMR: reserve two octets for AMR frame info */\n\tif (pt == PJMEDIA_RTP_PT_AMR || pt == PJMEDIA_RTP_PT_AMRWB) {\n\t    out.pBuffer += 2;\n\t}\n#endif\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_G722_1\n\t/* For G722.1: adjust the encoder input signal level */\n\tif (pt >= PJMEDIA_RTP_PT_G722_1_16 && \n\t    pt <= PJMEDIA_RTP_PT_G7221_RSV2 &&\n\t    codec_data->g7221_pcm_shift)\n\t{\n\t    unsigned i;\n\t    for (i = 0; i < samples_per_frame; ++i)\n\t\tpcm_in[i] >>= codec_data->g7221_pcm_shift;\n\t}\n#endif\n\n\tif (USC_NoError != ippc->fxns->Encode(codec_data->enc, &in, &out)) {\n\t    break;\n\t}\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_AMR\n\t/* For AMR: put info (frametype, degraded, last frame, mode) in the \n\t * first two octets for payload packing.\n\t */\n\tif (pt == PJMEDIA_RTP_PT_AMR || pt == PJMEDIA_RTP_PT_AMRWB) {\n\t    pj_uint16_t *info = (pj_uint16_t*)bits_out;\n\n\t    /* Two octets for AMR frame info, 0=LSB:\n\t     * bit 0-3\t: frame type\n\t     * bit 5\t: STI flag\n\t     * bit 6\t: last frame flag\n\t     * bit 7\t: quality flag\n\t     * bit 8-11\t: mode\n\t     */\n\t    out.nbytes += 2;\n\t    if (out.frametype == 0 || out.frametype == 4 || \n\t\t(pt == PJMEDIA_RTP_PT_AMR && out.frametype == 5) ||\n\t\t(pt == PJMEDIA_RTP_PT_AMRWB && out.frametype == 6))\n\t    {\n\t\t/* Speech frame type */\n\t\t*info = (char)pjmedia_codec_amr_get_mode(out.bitrate);\n\t\t/* Quality */\n\t\tif (out.frametype == 5 || out.frametype == 6)\n\t\t    *info |= 0x80;\n\t    } else if (out.frametype == 1 || out.frametype == 2 || \n\t\t       (pt == PJMEDIA_RTP_PT_AMR && out.frametype == 6) ||\n\t\t       (pt == PJMEDIA_RTP_PT_AMRWB && out.frametype == 7))\n\t    {\n\t\t/* SID frame type */\n\t\t*info = (pj_uint8_t)(pt == PJMEDIA_RTP_PT_AMRWB? 9 : 8);\n\t\t/* Quality */\n\t\tif (out.frametype == 6 || out.frametype == 7)\n\t\t    *info |= 0x80;\n\t\t/* STI */\n\t\tif (out.frametype != 1)\n\t\t    *info |= 0x20;\n\t    } else {\n\t\t/* Untransmited */\n\t\t*info = 15;\n\t\tout.nbytes = 2;\n\t    }\n\n\t    /* Mode */\n\t    *info |= (char)pjmedia_codec_amr_get_mode(out.bitrate) << 8;\n\n\t    /* Last frame flag */\n\t    if (nsamples == samples_per_frame)\n\t\t*info |= 0x40;\n\t}\n#endif\n\n\tpcm_in += samples_per_frame;\n\tnsamples -= samples_per_frame;\n\ttx += out.nbytes;\n\tbits_out += out.nbytes;\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_G729\n\tif (pt == PJMEDIA_RTP_PT_G729) {\n\t    if (out.frametype == 1) {\n\t\t/* SID */\n\t\tbreak;\n\t    } else if (out.frametype == 0) {\n\t\t/* Untransmitted */\n\t\ttx -= out.nbytes;\n\t\tbreak;\n\t    }\n\t}\n#endif\n\n    }\n\n    if (ippc->pack != NULL) {\n\tippc->pack(codec_data, output->buf, &tx, output_buf_len);\n    }\n\n    /* Check if we don't need to transmit the frame (DTX) */\n    if (tx == 0) {\n\toutput->buf = NULL;\n\toutput->size = 0;\n\toutput->timestamp.u64 = input->timestamp.u64;\n\toutput->type = PJMEDIA_FRAME_TYPE_NONE;\n\treturn PJ_SUCCESS;\n    }\n\n    output->size = tx;\n    output->type = PJMEDIA_FRAME_TYPE_AUDIO;\n    output->timestamp = input->timestamp;\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Decode frame.\n */\nstatic pj_status_t ipp_codec_decode( pjmedia_codec *codec, \n\t\t\t\t     const struct pjmedia_frame *input,\n\t\t\t\t     unsigned output_buf_len, \n\t\t\t\t     struct pjmedia_frame *output)\n{\n    ipp_private_t *codec_data = (ipp_private_t*) codec->codec_data;\n    struct ipp_codec *ippc = &ipp_codec[codec_data->codec_idx];\n    unsigned samples_per_frame;\n    USC_PCMStream out;\n    USC_Bitstream in;\n    pj_uint8_t pt;\n\n    pt = ippc->pt; \n    samples_per_frame = ippc->samples_per_frame;\n\n    PJ_ASSERT_RETURN(output_buf_len >= samples_per_frame << 1,\n\t\t     PJMEDIA_CODEC_EPCMTOOSHORT);\n\n    if (input->type == PJMEDIA_FRAME_TYPE_AUDIO) {\n\tif (ippc->predecode) {\n\t    ippc->predecode(codec_data, input, &in);\n\t} else {\n\t    /* Most IPP codecs have frametype==0 for speech frame */\n\t    in.pBuffer = (char*)input->buf;\n\t    in.nbytes = input->size;\n\t    in.frametype = 0;\n\t    in.bitrate = codec_data->info->params.modes.bitrate;\n\t}\n\n\tout.pBuffer = output->buf;\n    }\n\n    if (input->type != PJMEDIA_FRAME_TYPE_AUDIO ||\n\tUSC_NoError != ippc->fxns->Decode(codec_data->dec, &in, &out)) \n    {\n\tpjmedia_zero_samples((pj_int16_t*)output->buf, samples_per_frame);\n\toutput->size = samples_per_frame << 1;\n\toutput->timestamp.u64 = input->timestamp.u64;\n\toutput->type = PJMEDIA_FRAME_TYPE_AUDIO;\n\treturn PJ_SUCCESS;\n    }\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_G726\n    /* For G.726: amplify decoding result (USC G.726 encoder deamplified it) */\n    if (pt == PJMEDIA_RTP_PT_G726_16 || pt == PJMEDIA_RTP_PT_G726_24 ||\n\tpt == PJMEDIA_RTP_PT_G726_32 || pt == PJMEDIA_RTP_PT_G726_40 ||\n\tpt == PJMEDIA_RTP_PT_G721)\n    {\n\tunsigned i;\n\tpj_int16_t *s = (pj_int16_t*)output->buf;\n\n\tfor (i = 0; i < samples_per_frame; ++i)\n\t    s[i] <<= 2;\n    }\n#endif\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_G722_1\n    /* For G722.1: adjust the decoder output signal level */\n    if (pt >= PJMEDIA_RTP_PT_G722_1_16 && \n\tpt <= PJMEDIA_RTP_PT_G7221_RSV2 &&\n\tcodec_data->g7221_pcm_shift)\n    {\n\tunsigned i;\n\tpj_int16_t *s = (pj_int16_t*)output->buf;\n\n\tfor (i = 0; i < samples_per_frame; ++i)\n\t    s[i] <<= codec_data->g7221_pcm_shift;\n    }\n#endif\n\n    output->type = PJMEDIA_FRAME_TYPE_AUDIO;\n    output->size = samples_per_frame << 1;\n    output->timestamp.u64 = input->timestamp.u64;\n\n    /* Invoke external PLC if codec has no internal PLC */\n    if (codec_data->plc && codec_data->plc_enabled)\n\tpjmedia_plc_save(codec_data->plc, (pj_int16_t*)output->buf);\n\n    return PJ_SUCCESS;\n}\n\n/* \n * Recover lost frame.\n */\nstatic pj_status_t  ipp_codec_recover(pjmedia_codec *codec, \n\t\t\t\t      unsigned output_buf_len, \n\t\t\t\t      struct pjmedia_frame *output)\n{\n    ipp_private_t *codec_data = (ipp_private_t*) codec->codec_data;\n    struct ipp_codec *ippc = &ipp_codec[codec_data->codec_idx];\n    unsigned samples_per_frame;\n\n    PJ_UNUSED_ARG(output_buf_len);\n\n    samples_per_frame = ippc->samples_per_frame;\n\n    output->type = PJMEDIA_FRAME_TYPE_AUDIO;\n    output->size = samples_per_frame << 1;\n\n    if (codec_data->plc_enabled) {\n\tif (codec_data->plc) {\n\t    pjmedia_plc_generate(codec_data->plc, (pj_int16_t*)output->buf);\n\t} else {\n\t    USC_PCMStream out;\n\t    out.pBuffer = output->buf;\n\t    ippc->fxns->Decode(codec_data->dec, NULL, &out);\n\t}\n    } else {\n\tpjmedia_zero_samples((pj_int16_t*)output->buf, samples_per_frame);\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n#if defined(_MSC_VER) && PJMEDIA_AUTO_LINK_IPP_LIBS\n#   pragma comment( lib, \"ippcore.lib\")\n#   pragma comment( lib, \"ipps.lib\")\n#   pragma comment( lib, \"ippsc.lib\")\n#   if defined(IPP_VERSION_MAJOR) && IPP_VERSION_MAJOR<=6\n#\tpragma comment( lib, \"ippsr.lib\")\n#   endif\n//#   pragma comment( lib, \"ippcorel.lib\")\n//#   pragma comment( lib, \"ippsemerged.lib\")\n//#   pragma comment( lib, \"ippsmerged.lib\")\n//#   pragma comment( lib, \"ippscemerged.lib\")\n//#   pragma comment( lib, \"ippscmerged.lib\")\n//#   pragma comment( lib, \"ippsremerged.lib\")\n//#   pragma comment( lib, \"ippsrmerged.lib\")\n#   if defined(IPP_VERSION_MAJOR) && IPP_VERSION_MAJOR>=6\n#\tpragma comment( lib, \"speech.lib\")\n#   else\n#\tpragma comment( lib, \"usc.lib\")\n#   endif\n#endif\n\n\n#endif\t/* PJMEDIA_HAS_INTEL_IPP */\n\n", "/* $Id$ */\n/*\n * Copyright (C) 2015-2016 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2012-2015 Zaark Technology AB\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n/* This file is the implementation of Opus codec wrapper and was contributed by\n * Zaark Technology AB\n */\n\n#include <pjmedia-codec/opus.h>\n#include <pjmedia/errno.h>\n#include <pjmedia/endpoint.h>\n#include <pj/log.h>\n#include <pj/math.h>\n\n#if defined(PJMEDIA_HAS_OPUS_CODEC) && (PJMEDIA_HAS_OPUS_CODEC!=0)\n\n#include <opus/opus.h>\n\n#define THIS_FILE \"opus.c\"\n\n/* Default packet loss concealment setting. */\n#define OPUS_DEFAULT_PLC\t1\n/* Default Voice Activity Detector setting. */\n#define OPUS_DEFAULT_VAD\t0\n\n/* Maximum size of an encoded packet. \n * If the the actual size is bigger, the encode/parse will fail.\n */\n#define MAX_ENCODED_PACKET_SIZE \t1280\n\n/* Default frame time (msec) */\n#define PTIME\t\t\t20\n\n/* Tracing */\n#if 0\n#   define TRACE_(expr)\tPJ_LOG(4,expr)\n#else\n#   define TRACE_(expr)\n#endif\n\n\n/* Prototypes for Opus factory */\nstatic pj_status_t factory_test_alloc( pjmedia_codec_factory *factory, \n\t\t\t\t       const pjmedia_codec_info *ci );\nstatic pj_status_t factory_default_attr( pjmedia_codec_factory *factory, \n\t\t\t\t\t const pjmedia_codec_info *ci, \n\t\t\t\t\t pjmedia_codec_param *attr );\nstatic pj_status_t factory_enum_codecs( pjmedia_codec_factory *factory, \n\t\t\t\t\tunsigned *count, \n\t\t\t\t\tpjmedia_codec_info codecs[]);\nstatic pj_status_t factory_alloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t\tconst pjmedia_codec_info *ci, \n\t\t\t\t\tpjmedia_codec **p_codec);\nstatic pj_status_t factory_dealloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t\t  pjmedia_codec *codec );\n\n\n/* Prototypes for Opus implementation. */\nstatic pj_status_t codec_init( pjmedia_codec *codec, \n\t\t\t       pj_pool_t *pool );\nstatic pj_status_t codec_open( pjmedia_codec *codec, \n\t\t\t       pjmedia_codec_param *attr );\nstatic pj_status_t codec_close( pjmedia_codec *codec );\nstatic pj_status_t codec_modify( pjmedia_codec *codec, \n\t\t\t\t const pjmedia_codec_param *attr );\nstatic pj_status_t codec_parse( pjmedia_codec *codec,\n\t\t\t\tvoid *pkt,\n\t\t\t\tpj_size_t pkt_size,\n\t\t\t\tconst pj_timestamp *ts,\n\t\t\t\tunsigned *frame_cnt,\n\t\t\t\tpjmedia_frame frames[]);\nstatic pj_status_t codec_encode( pjmedia_codec *codec, \n\t\t\t\t const struct pjmedia_frame *input,\n\t\t\t\t unsigned output_buf_len, \n\t\t\t\t struct pjmedia_frame *output);\nstatic pj_status_t codec_decode( pjmedia_codec *codec, \n\t\t\t\t const struct pjmedia_frame *input,\n\t\t\t\t unsigned output_buf_len, \n\t\t\t\t struct pjmedia_frame *output);\nstatic pj_status_t codec_recover( pjmedia_codec *codec,\n\t\t\t\t  unsigned output_buf_len,\n\t\t\t\t  struct pjmedia_frame *output);\n\n/* Definition for Opus operations. */\nstatic pjmedia_codec_op opus_op = \n{\n    &codec_init,\n    &codec_open,\n    &codec_close,\n    &codec_modify,\n    &codec_parse,\n    &codec_encode,\n    &codec_decode,\n    &codec_recover\n};\n\n/* Definition for Opus factory operations. */\nstatic pjmedia_codec_factory_op opus_factory_op =\n{\n    &factory_test_alloc,\n    &factory_default_attr,\n    &factory_enum_codecs,\n    &factory_alloc_codec,\n    &factory_dealloc_codec,\n    &pjmedia_codec_opus_deinit\n};\n\n\n/* Opus factory */\nstruct opus_codec_factory\n{\n    pjmedia_codec_factory  base;\n    pjmedia_endpt\t  *endpt;\n    pj_pool_t\t\t  *pool;\n};\n\n/* Opus codec private data. */\nstruct opus_data\n{\n    pj_pool_t         \t\t*pool;\n    pj_mutex_t        \t\t*mutex;\n    OpusEncoder \t\t*enc;\n    OpusDecoder       \t\t*dec;\n    OpusRepacketizer  \t\t*enc_packer;\n    OpusRepacketizer  \t\t*dec_packer;\n    pjmedia_codec_opus_config \t cfg;\n    unsigned   \t\t\t enc_ptime;\n    unsigned\t\t\t dec_ptime;\n    pjmedia_frame      \t\t dec_frame[2];\n    int                \t\t dec_frame_index;\n};\n\n/* Codec factory instance */\nstatic struct opus_codec_factory opus_codec_factory;\n\n/* Opus default configuration */\nstatic pjmedia_codec_opus_config opus_cfg =\n{\n    PJMEDIA_CODEC_OPUS_DEFAULT_SAMPLE_RATE,     /* Sample rate\t\t*/\n    1,\t\t\t\t\t\t/* Channel count\t*/\n    PTIME,\t\t\t\t\t/* Frame time \t\t*/\t\t\t\n    PJMEDIA_CODEC_OPUS_DEFAULT_BIT_RATE,\t/* Bit rate             */\n    5,\t\t\t\t\t\t/* Expected packet loss */\n    PJMEDIA_CODEC_OPUS_DEFAULT_COMPLEXITY,\t/* Complexity           */\n    PJMEDIA_CODEC_OPUS_DEFAULT_CBR,\t\t/* Constant bit rate    */\n};\n\n\nstatic int get_opus_bw_constant (unsigned sample_rate)\n{\n    if (sample_rate <= 8000)\n\treturn OPUS_BANDWIDTH_NARROWBAND;\n    else if (sample_rate <= 12000)\n\treturn OPUS_BANDWIDTH_MEDIUMBAND;\n    else if (sample_rate <= 16000)\n\treturn OPUS_BANDWIDTH_WIDEBAND;\n    else if (sample_rate <= 24000)\n\treturn OPUS_BANDWIDTH_SUPERWIDEBAND;\n    else\n\treturn OPUS_BANDWIDTH_FULLBAND;\n}\n\n\n/*\n * Initialize and register Opus codec factory to pjmedia endpoint.\n */\nPJ_DEF(pj_status_t) pjmedia_codec_opus_init( pjmedia_endpt *endpt )\n{\n    pj_status_t status;\n    pjmedia_codec_mgr *codec_mgr;\n\n    PJ_ASSERT_RETURN(endpt, PJ_EINVAL);\n\n    if (opus_codec_factory.pool != NULL)\n\treturn PJ_SUCCESS;\n\n    /* Create the Opus codec factory */\n    opus_codec_factory.base.op           = &opus_factory_op;\n    opus_codec_factory.base.factory_data = &opus_codec_factory;\n    opus_codec_factory.endpt             = endpt;\n\n    opus_codec_factory.pool = pjmedia_endpt_create_pool(endpt, \"opus-factory\",\n    \t\t\t\t\t\t\t1024, 1024);\n    if (!opus_codec_factory.pool) {\n\tPJ_LOG(2, (THIS_FILE, \"Unable to create memory pool for Opus codec\"));\n\treturn PJ_ENOMEM;\n    }\n\n    /* Get the codec manager */\n    codec_mgr = pjmedia_endpt_get_codec_mgr(endpt);\n    if (!codec_mgr) {\n\tPJ_LOG(2, (THIS_FILE, \"Unable to get the codec manager\"));\n\tstatus = PJ_EINVALIDOP;\n\tgoto on_codec_factory_error;\n    }\n\n    /* Register the codec factory */\n    status = pjmedia_codec_mgr_register_factory (codec_mgr,\n\t\t\t\t\t\t &opus_codec_factory.base);\n    if (status != PJ_SUCCESS) {\n\tPJ_LOG(2, (THIS_FILE, \"Unable to register the codec factory\"));\n\tgoto on_codec_factory_error;\n    }\n\n    return PJ_SUCCESS;\n\non_codec_factory_error:\n    pj_pool_release(opus_codec_factory.pool);\n    opus_codec_factory.pool = NULL;\n    return status;\n}\n\n\n/*\n * Unregister Opus codec factory from pjmedia endpoint and\n * deinitialize the codec.\n */\nPJ_DEF(pj_status_t) pjmedia_codec_opus_deinit( void )\n{\n    pj_status_t status;\n    pjmedia_codec_mgr *codec_mgr;\n\n    if (opus_codec_factory.pool == NULL)\n\treturn PJ_SUCCESS;\n\n    /* Get the codec manager */\n    codec_mgr = pjmedia_endpt_get_codec_mgr(opus_codec_factory.endpt);\n    if (!codec_mgr) {\n\tPJ_LOG(2, (THIS_FILE, \"Unable to get the codec manager\"));\n\tpj_pool_release(opus_codec_factory.pool);\n\topus_codec_factory.pool = NULL;\n\treturn PJ_EINVALIDOP;\n    }\n\n    /* Unregister the codec factory */\n    status = pjmedia_codec_mgr_unregister_factory(codec_mgr,\n\t\t\t\t\t\t  &opus_codec_factory.base);\n    if (status != PJ_SUCCESS)\n\tPJ_LOG(2, (THIS_FILE, \"Unable to unregister the codec factory\"));\n\n    /* Release the memory pool */\n    pj_pool_release(opus_codec_factory.pool);\n    opus_codec_factory.pool = NULL;\n\n    return status;\n}\n\n\n/**\n * Get the opus configuration for a specific sample rate.\n */\nPJ_DEF(pj_status_t)\npjmedia_codec_opus_get_config( pjmedia_codec_opus_config *cfg )\n{\n    PJ_ASSERT_RETURN(cfg, PJ_EINVAL);\n\n    pj_memcpy(cfg, &opus_cfg, sizeof(pjmedia_codec_opus_config));\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_str_t STR_MAX_PLAYBACK = {\"maxplaybackrate\", 15};\nstatic pj_str_t STR_MAX_CAPTURE  = {\"sprop-maxcapturerate\", 20};\nstatic pj_str_t STR_STEREO  \t = {\"stereo\", 6};\nstatic pj_str_t STR_SPROP_STEREO = {\"sprop-stereo\", 12};\nstatic pj_str_t STR_MAX_BIT_RATE = {\"maxaveragebitrate\", 17};\nstatic pj_str_t STR_INBAND_FEC   = {\"useinbandfec\", 12};\nstatic pj_str_t STR_DTX          = {\"usedtx\", 6};\nstatic pj_str_t STR_CBR          = {\"cbr\", 3};\n\nstatic int find_fmtp(pjmedia_codec_fmtp *fmtp, pj_str_t *name, pj_bool_t add)\n{\n    int i;\n    for (i = 0; i < fmtp->cnt; i++) {\n    \tif (pj_stricmp(&fmtp->param[i].name, name) == 0)\n\t    return i;\n    }\n    \n    if (add && (i < PJMEDIA_CODEC_MAX_FMTP_CNT)) {\n        fmtp->param[i].name = *name;\n        fmtp->cnt++;\n        return i;\n    } else\n        return -1;\n}\n\nstatic void remove_fmtp(pjmedia_codec_fmtp *fmtp, pj_str_t *name)\n{\n    int i, j;\n    for (i = 0; i < fmtp->cnt; i++) {\n    \tif (pj_stricmp(&fmtp->param[i].name, name) == 0) {\n    \t    fmtp->cnt--;\n    \t    for (j = i; j < fmtp->cnt; j++) {\n    \t    \tfmtp->param[i].name = fmtp->param[i+1].name;\n    \t    \tfmtp->param[i].val = fmtp->param[i+1].val;\n    \t    }\n    \t}\n    }\n}\n\nstatic pj_status_t generate_fmtp(pjmedia_codec_param *attr)\n{\n    int idx;\n    static char bitrate_str[12];\n    static char clockrate_str[12];\n    \n    if (attr->info.clock_rate != 48000) {\n\tpj_ansi_snprintf(clockrate_str, sizeof(clockrate_str), \"%u\",\n\t\t\t attr->info.clock_rate);\n\n        idx = find_fmtp(&attr->setting.dec_fmtp, &STR_MAX_PLAYBACK, PJ_TRUE);\n        if (idx >= 0)\n\t    attr->setting.dec_fmtp.param[idx].val = pj_str(clockrate_str);\n\n\tidx = find_fmtp(&attr->setting.dec_fmtp, &STR_MAX_CAPTURE, PJ_TRUE);\n\tif (idx >= 0)\n\t    attr->setting.dec_fmtp.param[idx].val = pj_str(clockrate_str);\n    } else {\n    \tremove_fmtp(&attr->setting.dec_fmtp, &STR_MAX_PLAYBACK);\n    \tremove_fmtp(&attr->setting.dec_fmtp, &STR_MAX_CAPTURE);\n    }\n\n    /* Check if we need to set parameter 'maxaveragebitrate' */\n    if (opus_cfg.bit_rate > 0) {\n        idx = find_fmtp(&attr->setting.dec_fmtp, &STR_MAX_BIT_RATE, PJ_TRUE);\n        if (idx >= 0) {\n\t    pj_ansi_snprintf(bitrate_str, sizeof(bitrate_str), \"%u\",\n\t\t\t     attr->info.avg_bps);\n\t    attr->setting.dec_fmtp.param[idx].val = pj_str(bitrate_str);\n\t}\n    } else {\n        remove_fmtp(&attr->setting.dec_fmtp, &STR_MAX_BIT_RATE);\n    }\n\n    if (attr->info.channel_cnt > 1) {\n        idx = find_fmtp(&attr->setting.dec_fmtp, &STR_STEREO, PJ_TRUE);\n        if (idx >= 0)\n\t    attr->setting.dec_fmtp.param[idx].val = pj_str(\"1\");\n\n        idx = find_fmtp(&attr->setting.dec_fmtp, &STR_SPROP_STEREO, PJ_TRUE);\n        if (idx >= 0)\n\t    attr->setting.dec_fmtp.param[idx].val = pj_str(\"1\");\n    } else {\n    \tremove_fmtp(&attr->setting.dec_fmtp, &STR_STEREO);\n    \tremove_fmtp(&attr->setting.dec_fmtp, &STR_SPROP_STEREO);\n    }\n\n    if (opus_cfg.cbr) {\n        idx = find_fmtp(&attr->setting.dec_fmtp, &STR_CBR, PJ_TRUE);\n        if (idx >= 0)\n\t    attr->setting.dec_fmtp.param[idx].val = pj_str(\"1\");\n    } else {\n    \tremove_fmtp(&attr->setting.dec_fmtp, &STR_CBR);\n    }\n\n    if (attr->setting.plc) {\n        idx = find_fmtp(&attr->setting.dec_fmtp, &STR_INBAND_FEC, PJ_TRUE);\n        if (idx >= 0)\n\t    attr->setting.dec_fmtp.param[idx].val = pj_str(\"1\");\n    } else {\n    \tremove_fmtp(&attr->setting.dec_fmtp, &STR_INBAND_FEC);\n    }\n\n    if (attr->setting.vad) {\n        idx = find_fmtp(&attr->setting.dec_fmtp, &STR_DTX, PJ_TRUE);\n        if (idx >= 0)\n\t    attr->setting.dec_fmtp.param[idx].val = pj_str(\"1\");\n    } else {\n    \tremove_fmtp(&attr->setting.dec_fmtp, &STR_DTX);\n    }\n    \n    return PJ_SUCCESS;\n}\n\n/**\n * Set the opus configuration and default param.\n */\nPJ_DEF(pj_status_t)\npjmedia_codec_opus_set_default_param(const pjmedia_codec_opus_config *cfg,\n\t\t\t\t     pjmedia_codec_param *param )\n{\n    const pj_str_t opus_str = {\"opus\", 4};\n    const pjmedia_codec_info *info[1];\n    pjmedia_codec_mgr *codec_mgr;\n    unsigned count = 1;\n    pj_status_t status;\n\n    TRACE_((THIS_FILE, \"%s:%d: - TRACE\", __FUNCTION__, __LINE__));\n    PJ_ASSERT_RETURN(cfg && param, PJ_EINVAL);\n\n    codec_mgr = pjmedia_endpt_get_codec_mgr(opus_codec_factory.endpt);\n\n    status = pjmedia_codec_mgr_find_codecs_by_id(codec_mgr, &opus_str,\n\t\t\t\t\t\t &count, info, NULL);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Set sample rate */\n    if (cfg->sample_rate != 8000 && cfg->sample_rate != 12000 &&\n\tcfg->sample_rate != 16000 && cfg->sample_rate != 24000 &&\n\tcfg->sample_rate != 48000)\n    {\n\treturn PJ_EINVAL;\n    }\n\n    param->info.clock_rate = opus_cfg.sample_rate = cfg->sample_rate;\n    param->info.max_bps = opus_cfg.sample_rate * 2;\n    opus_cfg.frm_ptime = cfg->frm_ptime;\n    param->info.frm_ptime = (pj_uint16_t)cfg->frm_ptime;\n\n    /* Set channel count */\n    if (cfg->channel_cnt != 1 && cfg->channel_cnt != 2)\n        return PJ_EINVAL;\n    param->info.channel_cnt = opus_cfg.channel_cnt = cfg->channel_cnt;\n\n    /* Set bit_rate */\n    if ((cfg->bit_rate != PJMEDIA_CODEC_OPUS_DEFAULT_BIT_RATE) && \n       (cfg->bit_rate < 6000 || cfg->bit_rate > 510000)) \n    {\n\treturn PJ_EINVAL;\n    }\n    opus_cfg.bit_rate = cfg->bit_rate;\n    param->info.avg_bps = opus_cfg.bit_rate;\n\n    /* Set expected packet loss */\n    if (cfg->packet_loss >= 100)\n\treturn PJ_EINVAL;\n    opus_cfg.packet_loss = cfg->packet_loss;\n\n    /* Set complexity */\n    if (cfg->complexity > 10)\n\treturn PJ_EINVAL;\n    opus_cfg.complexity = cfg->complexity;\n\n    opus_cfg.cbr = cfg->cbr;\n    \n    generate_fmtp(param);\n\n    status = pjmedia_codec_mgr_set_default_param(codec_mgr, info[0], param);\n    return status;\n}\n\n\n/*\n * Check if factory can allocate the specified codec.\n */\nstatic pj_status_t factory_test_alloc( pjmedia_codec_factory *factory, \n\t\t\t\t       const pjmedia_codec_info *ci )\n{\n    const pj_str_t opus_tag = {\"OPUS\", 4};\n\n    PJ_UNUSED_ARG(factory);\n    PJ_ASSERT_RETURN(factory==&opus_codec_factory.base, PJ_EINVAL);\n\n    /* Type MUST be audio. */\n    if (ci->type != PJMEDIA_TYPE_AUDIO)\n\treturn PJMEDIA_CODEC_EUNSUP;\n\n    /* Check encoding name. */\n    if (pj_stricmp(&ci->encoding_name, &opus_tag) != 0)\n\treturn PJMEDIA_CODEC_EUNSUP;\n\n    /* Check clock rate */\n    if (ci->clock_rate != 8000 && ci->clock_rate != 12000 &&\n\tci->clock_rate != 16000 && ci->clock_rate != 24000 &&\n\tci->clock_rate != 48000)\n    {\n\treturn PJMEDIA_CODEC_EUNSUP;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Generate default attribute.\n */\nstatic pj_status_t factory_default_attr( pjmedia_codec_factory *factory, \n\t\t\t\t\t const pjmedia_codec_info *ci, \n\t\t\t\t\t pjmedia_codec_param *attr )\n{\n    PJ_UNUSED_ARG(factory);\n    TRACE_((THIS_FILE, \"%s:%d: - TRACE\", __FUNCTION__, __LINE__));\n\n    pj_bzero(attr, sizeof(pjmedia_codec_param));\n    attr->info.pt          \t   = (pj_uint8_t)ci->pt;\n    attr->info.clock_rate  \t   = opus_cfg.sample_rate;\n    attr->info.channel_cnt \t   = opus_cfg.channel_cnt;\n    attr->info.avg_bps     \t   = opus_cfg.bit_rate;\n    attr->info.max_bps     \t   = opus_cfg.sample_rate * 2;\n    attr->info.frm_ptime   \t   = (pj_uint16_t)opus_cfg.frm_ptime;\n    attr->setting.frm_per_pkt \t   = 1;\n    attr->info.pcm_bits_per_sample = 16;\n    attr->setting.vad      \t   = OPUS_DEFAULT_VAD;\n    attr->setting.plc      \t   = OPUS_DEFAULT_PLC;\n\n    /* Set max RX frame size to 1275 (max Opus frame size) to anticipate\n     * possible ptime change on the fly.\n     */\n    attr->info.max_rx_frame_size   = 1275;\n\n    generate_fmtp(attr);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Enum codecs supported by this factory.\n */\nstatic pj_status_t factory_enum_codecs( pjmedia_codec_factory *factory, \n\t\t\t\t\tunsigned *count, \n\t\t\t\t\tpjmedia_codec_info codecs[] )\n{\n    PJ_UNUSED_ARG(factory);\n    PJ_ASSERT_RETURN(codecs, PJ_EINVAL);\n\n    if (*count > 0) {\n\tpj_bzero(&codecs[0], sizeof(pjmedia_codec_info));\n\tcodecs[0].type          = PJMEDIA_TYPE_AUDIO;\n\tcodecs[0].pt            = PJMEDIA_RTP_PT_OPUS;\n        /*\n         * RFC 7587, Section 7:\n         * The media subtype (\"opus\") goes in SDP \"a=rtpmap\" as the encoding\n         * name. The RTP clock rate in \"a=rtpmap\" MUST be 48000 and the\n         * number of channels MUST be 2.\n         */\t\n\tcodecs[0].encoding_name = pj_str(\"opus\");\n\tcodecs[0].clock_rate    = 48000;\n\tcodecs[0].channel_cnt   = 2;\n\t*count = 1;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Allocate a new Opus codec instance.\n */\nstatic pj_status_t factory_alloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t\tconst pjmedia_codec_info *ci, \n\t\t\t\t\tpjmedia_codec **p_codec )\n{\n    pjmedia_codec *codec;\n    pj_pool_t *pool;\n    pj_status_t status;\n    struct opus_data *opus_data;\n    struct opus_codec_factory *f = (struct opus_codec_factory*) factory;\n\n    PJ_UNUSED_ARG(ci);\n    TRACE_((THIS_FILE, \"%s:%d: - TRACE\", __FUNCTION__, __LINE__));\n\n    pool = pjmedia_endpt_create_pool(f->endpt, \"opus\", 512, 512);\n    if (!pool) return PJ_ENOMEM;\n    \n    opus_data = PJ_POOL_ZALLOC_T(pool, struct opus_data);\n    codec     = PJ_POOL_ZALLOC_T(pool, pjmedia_codec);\n\n    status = pj_mutex_create_simple (pool, \"opus_mutex\", &opus_data->mutex);\n    if (status != PJ_SUCCESS) {\n    \tpj_pool_release(pool);\n    \treturn status;\n    }\n\n    pj_memcpy(&opus_data->cfg, &opus_cfg, sizeof(pjmedia_codec_opus_config));\n    opus_data->pool      = pool;\n    codec->op            = &opus_op;\n    codec->factory       = factory;\n    codec->codec_data    = opus_data;\n\n    *p_codec = codec;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Free codec.\n */\nstatic pj_status_t factory_dealloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t\t  pjmedia_codec *codec )\n{\n    struct opus_data *opus_data;\n\n    PJ_ASSERT_RETURN(factory && codec, PJ_EINVAL);\n    PJ_ASSERT_RETURN(factory == &opus_codec_factory.base, PJ_EINVAL);\n\n    opus_data = (struct opus_data *)codec->codec_data;\n    if (opus_data) {\n        pj_mutex_destroy(opus_data->mutex);\n        opus_data->mutex = NULL;\n\tpj_pool_release(opus_data->pool);\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Init codec.\n */\nstatic pj_status_t codec_init( pjmedia_codec *codec, \n\t\t\t       pj_pool_t *pool )\n{\n    PJ_UNUSED_ARG(codec);\n    PJ_UNUSED_ARG(pool);\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Open codec.\n */\nstatic pj_status_t  codec_open( pjmedia_codec *codec,\n\t\t\t\tpjmedia_codec_param *attr )\n{\n    struct opus_data *opus_data = (struct opus_data *)codec->codec_data;\n    int idx, err;\n    pj_bool_t auto_bit_rate = PJ_TRUE;\n\n    PJ_ASSERT_RETURN(codec && attr && opus_data, PJ_EINVAL);\n\n    pj_mutex_lock (opus_data->mutex);\n\n    TRACE_((THIS_FILE, \"%s:%d: - TRACE\", __FUNCTION__, __LINE__));\n\n    opus_data->cfg.sample_rate = attr->info.clock_rate;\n    opus_data->cfg.channel_cnt = attr->info.channel_cnt;\n    opus_data->enc_ptime = opus_data->dec_ptime = attr->info.frm_ptime;\n\n    /* Allocate memory used by the codec */\n    if (!opus_data->enc) {\n\t/* Allocate memory for max 2 channels */\n\topus_data->enc = pj_pool_zalloc(opus_data->pool,\n\t\t\t\t\topus_encoder_get_size(2));\n    }\n    if (!opus_data->dec) {\n\t/* Allocate memory for max 2 channels */\n\topus_data->dec = pj_pool_zalloc(opus_data->pool,\n\t\t\t\t\topus_decoder_get_size(2));\n    }\n    if (!opus_data->enc_packer) {\n\topus_data->enc_packer = pj_pool_zalloc(opus_data->pool,\n\t\t\t\t\t       opus_repacketizer_get_size());\n    }\n    if (!opus_data->dec_packer) {\n\topus_data->dec_packer = pj_pool_zalloc(opus_data->pool,\n\t\t\t\t\t       opus_repacketizer_get_size());\n    }\n    if (!opus_data->enc || !opus_data->dec ||\n\t!opus_data->enc_packer || !opus_data->dec_packer)\n    {\n\tPJ_LOG(2, (THIS_FILE, \"Unable to allocate memory for the codec\"));\n        pj_mutex_unlock (opus_data->mutex);\n\treturn PJ_ENOMEM;\n    }\n\n    /* Check max average bit rate */\n    idx = find_fmtp(&attr->setting.enc_fmtp, &STR_MAX_BIT_RATE, PJ_FALSE);\n    if (idx >= 0) {\n\tunsigned rate;\n\tauto_bit_rate = PJ_FALSE;\n\trate = (unsigned)pj_strtoul(&attr->setting.enc_fmtp.param[idx].val);\n\tif (rate < attr->info.avg_bps)\n\t    attr->info.avg_bps = rate;\n    }\n\n    /* Check plc */\n    idx = find_fmtp(&attr->setting.enc_fmtp, &STR_INBAND_FEC, PJ_FALSE);\n    if (idx >= 0) {\n\tunsigned plc;\n\tplc = (unsigned) pj_strtoul(&attr->setting.enc_fmtp.param[idx].val);\n\tattr->setting.plc = plc > 0? PJ_TRUE: PJ_FALSE;\n    }\n\n    /* Check vad */\n    idx = find_fmtp(&attr->setting.enc_fmtp, &STR_DTX, PJ_FALSE);\n    if (idx >= 0) {\n\tunsigned vad;\n\tvad = (unsigned) pj_strtoul(&attr->setting.enc_fmtp.param[idx].val);\n\tattr->setting.vad = vad > 0? PJ_TRUE: PJ_FALSE;\n    }\n\n    /* Check cbr */\n    idx = find_fmtp(&attr->setting.enc_fmtp, &STR_CBR, PJ_FALSE);\n    if (idx >= 0) {\n\tunsigned cbr;\n\tcbr = (unsigned) pj_strtoul(&attr->setting.enc_fmtp.param[idx].val);\n\topus_data->cfg.cbr = cbr > 0? PJ_TRUE: PJ_FALSE;\n    }\n    \n    /* Check max average bit rate */\n    idx = find_fmtp(&attr->setting.dec_fmtp, &STR_MAX_BIT_RATE, PJ_FALSE);\n    if (idx >= 0) {\n\tunsigned rate;\n\trate = (unsigned) pj_strtoul(&attr->setting.dec_fmtp.param[idx].val);\n\tif (rate < attr->info.avg_bps)\n\t    attr->info.avg_bps = rate;\n    }\n\n    TRACE_((THIS_FILE, \"%s:%d: sample_rate: %u\",\n\t    __FUNCTION__, __LINE__, opus_data->cfg.sample_rate));\n\n    /* Initialize encoder */\n    err = opus_encoder_init(opus_data->enc,\n\t\t\t    opus_data->cfg.sample_rate,\n\t\t\t    attr->info.channel_cnt,\n\t\t\t    OPUS_APPLICATION_VOIP);\n    if (err != OPUS_OK) {\n\tPJ_LOG(2, (THIS_FILE, \"Unable to create encoder\"));\n\treturn PJMEDIA_CODEC_EFAILED;\n    }\n    \n    /* Set signal type */\n    opus_encoder_ctl(opus_data->enc, OPUS_SET_SIGNAL(OPUS_SIGNAL_VOICE));\n    /* Set bitrate */\n    opus_encoder_ctl(opus_data->enc, OPUS_SET_BITRATE(auto_bit_rate?\n    \t\t\t\t\t\t      OPUS_AUTO:\n    \t\t\t\t\t\t      attr->info.avg_bps));\n    /* Set VAD */\n    opus_encoder_ctl(opus_data->enc, OPUS_SET_DTX(attr->setting.vad ? 1 : 0));\n    /* Set PLC */\n    opus_encoder_ctl(opus_data->enc,\n    \t\t     OPUS_SET_INBAND_FEC(attr->setting.plc ? 1 : 0));\n    /* Set bandwidth */\n    opus_encoder_ctl(opus_data->enc,\n    \t\t     OPUS_SET_MAX_BANDWIDTH(get_opus_bw_constant(\n    \t\t\t\t\t    opus_data->cfg.sample_rate)));\n    /* Set expected packet loss */\n    opus_encoder_ctl(opus_data->enc,\n    \t\tOPUS_SET_PACKET_LOSS_PERC(opus_data->cfg.packet_loss));\n    /* Set complexity */\n    opus_encoder_ctl(opus_data->enc,\n\t\t     OPUS_SET_COMPLEXITY(opus_data->cfg.complexity));\n    /* Set constant bit rate */\n    opus_encoder_ctl(opus_data->enc,\n    \t\t     OPUS_SET_VBR(opus_data->cfg.cbr ? 0 : 1));\n\n    PJ_LOG(5, (THIS_FILE, \"Initialize Opus encoder, sample rate: %d, \"\n    \t\t\t  \"avg bitrate: %d, vad: %d, plc: %d, pkt loss: %d, \"\n    \t\t\t  \"complexity: %d, constant bit rate: %d\",\n               \t\t  opus_data->cfg.sample_rate,\n               \t\t  attr->info.avg_bps, attr->setting.vad?1:0,\n               \t\t  attr->setting.plc?1:0,\n               \t\t  opus_data->cfg.packet_loss,\n               \t\t  opus_data->cfg.complexity,\n               \t\t  opus_data->cfg.cbr?1:0));\n\n    /* Initialize decoder */\n    err = opus_decoder_init (opus_data->dec,\n\t\t\t     opus_data->cfg.sample_rate,\n\t\t\t     attr->info.channel_cnt);\n    if (err != OPUS_OK) {\n\tPJ_LOG(2, (THIS_FILE, \"Unable to initialize decoder\"));\n\treturn PJMEDIA_CODEC_EFAILED;\n    }\n\n    /* Initialize temporary decode frames used for FEC */\n    opus_data->dec_frame[0].type = PJMEDIA_FRAME_TYPE_NONE;\n    opus_data->dec_frame[0].buf  = pj_pool_zalloc(opus_data->pool,                                   \n        \t(opus_data->cfg.sample_rate / 1000)\n                * 60 * attr->info.channel_cnt * 2 /* bytes per sample */);\n    opus_data->dec_frame[1].type = PJMEDIA_FRAME_TYPE_NONE;\n    opus_data->dec_frame[1].buf  = pj_pool_zalloc(opus_data->pool,\n\t\t(opus_data->cfg.sample_rate / 1000)\n                * 60 * attr->info.channel_cnt * 2 /* bytes per sample */);\n    opus_data->dec_frame_index = -1;\n\n    /* Initialize the repacketizers */\n    opus_repacketizer_init(opus_data->enc_packer);\n    opus_repacketizer_init(opus_data->dec_packer);\n\n    pj_mutex_unlock (opus_data->mutex);\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Close codec.\n */\nstatic pj_status_t  codec_close( pjmedia_codec *codec )\n{\n    PJ_UNUSED_ARG(codec);\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Modify codec settings.\n */\nstatic pj_status_t  codec_modify( pjmedia_codec *codec, \n\t\t\t\t  const pjmedia_codec_param *attr )\n{\n    struct opus_data *opus_data = (struct opus_data *)codec->codec_data;\n\n    pj_mutex_lock (opus_data->mutex);\n\n    TRACE_((THIS_FILE, \"%s:%d: - TRACE\", __FUNCTION__, __LINE__));\n\n    /* Set bitrate */\n    opus_data->cfg.bit_rate = attr->info.avg_bps;\n    opus_encoder_ctl(opus_data->enc, OPUS_SET_BITRATE(attr->info.avg_bps?\n    \t\t\t\t\t\t      attr->info.avg_bps:\n    \t\t\t\t\t\t      OPUS_AUTO));\n    /* Set VAD */\n    opus_encoder_ctl(opus_data->enc, OPUS_SET_DTX(attr->setting.vad ? 1 : 0));\n    /* Set PLC */\n    opus_encoder_ctl(opus_data->enc,\n    \t\t     OPUS_SET_INBAND_FEC(attr->setting.plc ? 1 : 0));\n\n    pj_mutex_unlock (opus_data->mutex);\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get frames in the packet.\n */\nstatic pj_status_t  codec_parse( pjmedia_codec *codec,\n\t\t\t\t void *pkt,\n\t\t\t\t pj_size_t pkt_size,\n\t\t\t\t const pj_timestamp *ts,\n\t\t\t\t unsigned *frame_cnt,\n\t\t\t\t pjmedia_frame frames[] )\n{\n    struct opus_data *opus_data = (struct opus_data *)codec->codec_data;\n    unsigned char tmp_buf[MAX_ENCODED_PACKET_SIZE];\n    int i, num_frames;\n    int size, out_pos;\n    unsigned samples_per_frame = 0;\n#if (USE_INCOMING_WORSE_SETTINGS)\n    int bw;\n#endif\n\n    pj_mutex_lock (opus_data->mutex);\n\n    if (pkt_size > sizeof(tmp_buf)) {\n\tPJ_LOG(5, (THIS_FILE, \"Encoded size bigger than buffer\"));\n        pj_mutex_unlock (opus_data->mutex);\n\treturn PJMEDIA_CODEC_EFRMTOOSHORT;\n    }\n\n    pj_memcpy(tmp_buf, pkt, pkt_size);\n\n    opus_repacketizer_init(opus_data->dec_packer);\n    opus_repacketizer_cat(opus_data->dec_packer, tmp_buf, pkt_size);\n\n    num_frames = opus_repacketizer_get_nb_frames(opus_data->dec_packer);\n    if (num_frames == 0) {\n      PJ_LOG(2, (THIS_FILE, \"No frames retrieved (num_frames = 0)\"));\n      pj_mutex_unlock(opus_data->mutex);\n      return PJMEDIA_CODEC_EFAILED;\n    }\n\n    out_pos = 0;\n    for (i = 0; i < num_frames; ++i) {\n\tsize = opus_repacketizer_out_range(opus_data->dec_packer, i, i+1,\n\t\t\t\t\t   ((unsigned char*)pkt) + out_pos,\n\t\t\t\t\t   sizeof(tmp_buf));\n\tif (size < 0) {\n\t    PJ_LOG(5, (THIS_FILE, \"Parse failed! (pkt_size=%d, err=%d)\",\n\t\t       pkt_size, size));\n            pj_mutex_unlock (opus_data->mutex);\n\t    return PJMEDIA_CODEC_EFAILED;\n\t}\n\tframes[i].type = PJMEDIA_FRAME_TYPE_AUDIO;\n\tframes[i].buf = ((char*)pkt) + out_pos;\n\tframes[i].size = size;\n\tframes[i].bit_info = 0;\n\n\tif (i == 0) {\n\t    int nsamples;\n\t    unsigned ptime;\n\n\t    nsamples = opus_packet_get_nb_samples(frames[i].buf,\n\t\t\t\t\t\t  frames[i].size,\n\t\t\t\t\t\t  opus_data->cfg.sample_rate);\n\t    if (nsamples <= 0) {\n\t\tPJ_LOG(5, (THIS_FILE, \"Parse failed to get samples number! \"\n\t\t\t\t      \"(err=%d)\", nsamples));\n\t\tpj_mutex_unlock (opus_data->mutex);\n\t\treturn PJMEDIA_CODEC_EFAILED;\n\t    }\n\n\t    ptime = nsamples * 1000 / opus_data->cfg.sample_rate;\n    \t    if (ptime != opus_data->dec_ptime) {\n             \tPJ_LOG(4, (THIS_FILE, \"Opus ptime change detected: %d ms \"\n             \t\t\t      \"--> %d ms\",\n             \t\t\t      opus_data->dec_ptime, ptime));\n        \topus_data->dec_ptime = ptime;\n        \topus_data->dec_frame_index = -1;\n\n        \t/* Signal to the stream about ptime change. */\n\t\tframes[i].bit_info = 0x10000 | nsamples;\n    \t    }\n\t    samples_per_frame = nsamples;\n   \t}\n\n\tframes[i].timestamp.u64 = ts->u64 + i * samples_per_frame;\n\tout_pos += size;\n    }\n    *frame_cnt = num_frames;\n\n    pj_mutex_unlock (opus_data->mutex);\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Encode frame.\n */\nstatic pj_status_t codec_encode( pjmedia_codec *codec, \n\t\t\t\t const struct pjmedia_frame *input,\n\t\t\t\t unsigned output_buf_len, \n\t\t\t\t struct pjmedia_frame *output )\n{\n    struct opus_data *opus_data = (struct opus_data *)codec->codec_data;\n    opus_int32 size  = 0;\n    unsigned in_pos  = 0;\n    unsigned out_pos = 0;\n    unsigned frame_size;\n    unsigned samples_per_frame;\n    unsigned char tmp_buf[MAX_ENCODED_PACKET_SIZE];\n    unsigned tmp_bytes_left = sizeof(tmp_buf);\n\n    pj_mutex_lock (opus_data->mutex);\n\n    samples_per_frame = (opus_data->cfg.sample_rate *\n\t\t\t opus_data->enc_ptime) / 1000;\n    frame_size = samples_per_frame * opus_data->cfg.channel_cnt *\n    \t\t sizeof(opus_int16);\n\n    opus_repacketizer_init(opus_data->enc_packer);\n    while (input->size - in_pos >= frame_size) {\n\tsize = opus_encode(opus_data->enc,\n\t\t\t   (const opus_int16*)(((char*)input->buf) + in_pos),\n\t\t\t   samples_per_frame,\n\t\t\t   tmp_buf + out_pos,\n\t\t\t   (tmp_bytes_left < frame_size ?\n\t\t\t    tmp_bytes_left : frame_size));\n\tif (size < 0) {\n\t    PJ_LOG(4, (THIS_FILE, \"Encode failed! (%d)\", size));\n            pj_mutex_unlock (opus_data->mutex);\n\t    return PJMEDIA_CODEC_EFAILED;\n\t} else if (size > 0) {\n\t    /* Only add packets containing more than the TOC */\n\t    opus_repacketizer_cat(opus_data->enc_packer,\n\t\t\t\t  tmp_buf + out_pos,\n\t\t\t\t  size);\n\t    out_pos += size;\n\t    tmp_bytes_left -= size;\n\t}\n\tin_pos += frame_size;\n    }\n\n    if (!opus_repacketizer_get_nb_frames(opus_data->enc_packer)) {\n\t/* Empty packet */\n\toutput->size      = 0;\n\toutput->type      = PJMEDIA_FRAME_TYPE_NONE;\n\toutput->timestamp = input->timestamp;\n    }\n\n    if (size) {\n\tsize = opus_repacketizer_out(opus_data->enc_packer,\n\t\t\t\t     output->buf,\n\t\t\t\t     output_buf_len);\n\tif (size < 0) {\n\t    PJ_LOG(4, (THIS_FILE, \"Encode failed! (%d), out_size: %u\",\n\t    \t\t\t  size, output_buf_len));\n\t    pj_mutex_unlock (opus_data->mutex);\n\t    return PJMEDIA_CODEC_EFAILED;\n\t}\n    }\n\n    output->size      = (unsigned)size;\n    output->type      = PJMEDIA_FRAME_TYPE_AUDIO;\n    output->timestamp = input->timestamp;\n\n    pj_mutex_unlock (opus_data->mutex);\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Decode frame.\n */\nstatic pj_status_t  codec_decode( pjmedia_codec *codec, \n\t\t\t\t  const struct pjmedia_frame *input,\n\t\t\t\t  unsigned output_buf_len, \n\t\t\t\t  struct pjmedia_frame *output )\n{\n    struct opus_data *opus_data = (struct opus_data *)codec->codec_data;\n    int decoded_samples;\n    pjmedia_frame *inframe;\n    int fec = 0;\n    int frm_size;\n\n    PJ_UNUSED_ARG(output_buf_len);\n\n    pj_mutex_lock (opus_data->mutex);\n\n    if (opus_data->dec_frame_index == -1) {\n        /* First packet, buffer it. */\n        opus_data->dec_frame[0].type = input->type;\n        opus_data->dec_frame[0].size = input->size;\n        opus_data->dec_frame[0].timestamp = input->timestamp;\n        pj_memcpy(opus_data->dec_frame[0].buf, input->buf, input->size);\n        opus_data->dec_frame_index = 0;\n        pj_mutex_unlock (opus_data->mutex);\n\n        /* Return zero decoded bytes */\n        output->size = 0;\n        output->type = PJMEDIA_FRAME_TYPE_NONE;\n        output->timestamp = input->timestamp;\n\n        return PJ_SUCCESS;\n    }\n\n    inframe = &opus_data->dec_frame[opus_data->dec_frame_index];\n\n    if (inframe->type != PJMEDIA_FRAME_TYPE_AUDIO) {\n        /* Update current frame index */\n        opus_data->dec_frame_index++;\n        if (opus_data->dec_frame_index > 1)\n            opus_data->dec_frame_index = 0;\n        /* Copy original input buffer to current indexed frame */\n        inframe = &opus_data->dec_frame[opus_data->dec_frame_index];\n        inframe->type = input->type;\n        inframe->size = input->size;\n        inframe->timestamp = input->timestamp;\n        pj_memcpy(inframe->buf, input->buf, input->size);\n        fec = 1;\n    }\n\n    /* From Opus doc: In the case of PLC (data==NULL) or FEC(decode_fec=1),\n     * then frame_size needs to be exactly the duration of audio that\n     * is missing.\n     */\n    frm_size = output->size / (sizeof(opus_int16) *\n               opus_data->cfg.channel_cnt);\n    if (inframe->type != PJMEDIA_FRAME_TYPE_AUDIO || fec) {\n\tfrm_size = PJ_MIN((unsigned)frm_size,\n\t\t\t  opus_data->cfg.sample_rate *\n\t\t\t  opus_data->dec_ptime / 1000);\n    }\n    decoded_samples = opus_decode( opus_data->dec,\n                                   inframe->type==PJMEDIA_FRAME_TYPE_AUDIO ?\n                                   inframe->buf : NULL,\n                                   inframe->type==PJMEDIA_FRAME_TYPE_AUDIO ?\n                                   inframe->size : 0,\n                                   (opus_int16*)output->buf,\n                                   frm_size,\n                                   fec);\n    output->timestamp = inframe->timestamp;\n     \n    if (inframe->type == PJMEDIA_FRAME_TYPE_AUDIO) {\n        /* Mark current indexed frame as invalid */\n        inframe->type = PJMEDIA_FRAME_TYPE_NONE;\n        /* Update current frame index */\n        opus_data->dec_frame_index++;\n        if (opus_data->dec_frame_index > 1)\n            opus_data->dec_frame_index = 0;\n        /* Copy original input buffer to current indexed frame */\n        inframe = &opus_data->dec_frame[opus_data->dec_frame_index];\n        inframe->type = input->type;\n        inframe->size = input->size;\n        inframe->timestamp = input->timestamp;\n        pj_memcpy(inframe->buf, input->buf, input->size);\n    }\n\n    if (decoded_samples < 0) {\n        PJ_LOG(4, (THIS_FILE, \"Decode failed!\"));\n        pj_mutex_unlock (opus_data->mutex);\n        return PJMEDIA_CODEC_EFAILED;\n    }\n\n    output->size = decoded_samples * sizeof(opus_int16) * \n    \t\t   opus_data->cfg.channel_cnt;\n    output->type = PJMEDIA_FRAME_TYPE_AUDIO;\n\n    pj_mutex_unlock (opus_data->mutex);\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Recover lost frame.\n */\nstatic pj_status_t  codec_recover( pjmedia_codec *codec,\n\t\t\t\t   unsigned output_buf_len,\n\t\t\t\t   struct pjmedia_frame *output )\n{\n    struct opus_data *opus_data = (struct opus_data *)codec->codec_data;\n    int decoded_samples;\n    pjmedia_frame *inframe;\n    int frm_size;\n\n    PJ_UNUSED_ARG(output_buf_len);\n    pj_mutex_lock (opus_data->mutex);\n\n    if (opus_data->dec_frame_index == -1) {\n        /* Recover the first packet? Don't think so, fill it with zeroes. */\n\tunsigned samples_per_frame;\n\tsamples_per_frame = opus_data->cfg.sample_rate * opus_data->dec_ptime/\n\t\t\t    1000;\n\toutput->type = PJMEDIA_FRAME_TYPE_AUDIO;\n\toutput->size = samples_per_frame << 1;\n\tpjmedia_zero_samples((pj_int16_t*)output->buf, samples_per_frame);\n        pj_mutex_unlock (opus_data->mutex);\n\n        return PJ_SUCCESS;\n    }\n\n    inframe = &opus_data->dec_frame[opus_data->dec_frame_index];\n    frm_size = output->size / (sizeof(opus_int16) *\n               opus_data->cfg.channel_cnt);\n    if (inframe->type != PJMEDIA_FRAME_TYPE_AUDIO) {\n\tfrm_size = PJ_MIN((unsigned)frm_size, opus_data->cfg.sample_rate *\n\t\t\t  opus_data->dec_ptime/1000);\n    }\n    decoded_samples = opus_decode(opus_data->dec,\n\t\t\t\t  inframe->type==PJMEDIA_FRAME_TYPE_AUDIO ?\n\t\t\t\t  inframe->buf : NULL,\n\t\t\t\t  inframe->type==PJMEDIA_FRAME_TYPE_AUDIO ?\n\t\t\t\t  inframe->size : 0,\n\t\t\t\t  (opus_int16*)output->buf,\n\t\t\t\t  frm_size,\n\t\t\t\t  0);\n\n    /* Mark current indexed frame as invalid */\n    inframe->type = PJMEDIA_FRAME_TYPE_NONE;\n    \n    /* Update current frame index */\n    opus_data->dec_frame_index++;\n    if (opus_data->dec_frame_index > 1)\n        opus_data->dec_frame_index = 0;\n    /* Mark current indexed frame as invalid */\n    inframe = &opus_data->dec_frame[opus_data->dec_frame_index];\n    inframe->type = PJMEDIA_FRAME_TYPE_NONE;\n\n    if (decoded_samples < 0) {\n        PJ_LOG(4, (THIS_FILE, \"Recover failed!\"));\n        pj_mutex_unlock (opus_data->mutex);\n        return PJMEDIA_CODEC_EFAILED;\n    }\n\n    output->size = decoded_samples * sizeof(opus_int16) * \n    \t\t   opus_data->cfg.channel_cnt;\n    output->type = PJMEDIA_FRAME_TYPE_AUDIO;\n    output->timestamp = inframe->timestamp;\n\n    pj_mutex_unlock (opus_data->mutex);\n    return PJ_SUCCESS;\n}\n\n#if defined(_MSC_VER)\n#   pragma comment(lib, \"libopus.a\")\n#endif\n\n\n#endif /* PJMEDIA_HAS_OPUS_CODEC */\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia-codec/passthrough.h>\n#include <pjmedia-codec/amr_sdp_match.h>\n#include <pjmedia/codec.h>\n#include <pjmedia/errno.h>\n#include <pjmedia/endpoint.h>\n#include <pjmedia/port.h>\n#include <pj/assert.h>\n#include <pj/log.h>\n#include <pj/math.h>\n#include <pj/pool.h>\n#include <pj/string.h>\n#include <pj/os.h>\n\n/*\n * Only build this file if PJMEDIA_HAS_PASSTHROUGH_CODECS != 0\n */\n#if defined(PJMEDIA_HAS_PASSTHROUGH_CODECS) && PJMEDIA_HAS_PASSTHROUGH_CODECS!=0\n\n#define THIS_FILE   \"passthrough.c\"\n\n\n/* Prototypes for passthrough codecs factory */\nstatic pj_status_t test_alloc( pjmedia_codec_factory *factory, \n\t\t\t       const pjmedia_codec_info *id );\nstatic pj_status_t default_attr( pjmedia_codec_factory *factory, \n\t\t\t\t const pjmedia_codec_info *id, \n\t\t\t\t pjmedia_codec_param *attr );\nstatic pj_status_t enum_codecs( pjmedia_codec_factory *factory, \n\t\t\t\tunsigned *count, \n\t\t\t\tpjmedia_codec_info codecs[]);\nstatic pj_status_t alloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\tconst pjmedia_codec_info *id, \n\t\t\t\tpjmedia_codec **p_codec);\nstatic pj_status_t dealloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t  pjmedia_codec *codec );\n\n/* Prototypes for passthrough codecs implementation. */\nstatic pj_status_t codec_init( pjmedia_codec *codec, \n\t\t\t       pj_pool_t *pool );\nstatic pj_status_t codec_open( pjmedia_codec *codec, \n\t\t\t       pjmedia_codec_param *attr );\nstatic pj_status_t codec_close( pjmedia_codec *codec );\nstatic pj_status_t codec_modify(pjmedia_codec *codec, \n\t\t\t        const pjmedia_codec_param *attr );\nstatic pj_status_t codec_parse( pjmedia_codec *codec,\n\t\t\t        void *pkt,\n\t\t\t\tpj_size_t pkt_size,\n\t\t\t\tconst pj_timestamp *ts,\n\t\t\t\tunsigned *frame_cnt,\n\t\t\t\tpjmedia_frame frames[]);\nstatic pj_status_t codec_encode( pjmedia_codec *codec, \n\t\t\t\t const struct pjmedia_frame *input,\n\t\t\t\t unsigned output_buf_len,\n\t\t\t\t struct pjmedia_frame *output);\nstatic pj_status_t codec_decode( pjmedia_codec *codec,\n\t\t\t\t const struct pjmedia_frame *input,\n\t\t\t\t unsigned output_buf_len, \n\t\t\t\t struct pjmedia_frame *output);\nstatic pj_status_t codec_recover( pjmedia_codec *codec, \n\t\t\t\t  unsigned output_buf_len, \n\t\t\t\t  struct pjmedia_frame *output);\n\n/* Definition for passthrough codecs operations. */\nstatic pjmedia_codec_op codec_op = \n{\n    &codec_init,\n    &codec_open,\n    &codec_close,\n    &codec_modify,\n    &codec_parse,\n    &codec_encode,\n    &codec_decode,\n    &codec_recover\n};\n\n/* Definition for passthrough codecs factory operations. */\nstatic pjmedia_codec_factory_op codec_factory_op =\n{\n    &test_alloc,\n    &default_attr,\n    &enum_codecs,\n    &alloc_codec,\n    &dealloc_codec,\n    &pjmedia_codec_passthrough_deinit\n};\n\n/* Passthrough codecs factory */\nstatic struct codec_factory {\n    pjmedia_codec_factory    base;\n    pjmedia_endpt\t    *endpt;\n    pj_pool_t\t\t    *pool;\n    pj_mutex_t\t\t    *mutex;\n} codec_factory;\n\n/* Passthrough codecs private data. */\ntypedef struct codec_private {\n    pj_pool_t\t\t*pool;\t\t    /**< Pool for each instance.    */\n    int\t\t\t codec_idx;\t    /**< Codec index.\t\t    */\n    void\t\t*codec_setting;\t    /**< Specific codec setting.    */\n    pj_uint16_t\t\t avg_frame_size;    /**< Average of frame size.\t    */\n    unsigned\t\t samples_per_frame; /**< Samples per frame, for iLBC\n\t\t\t\t\t\t this can be 240 or 160, can\n\t\t\t\t\t\t only be known after codec is\n\t\t\t\t\t\t opened.\t\t    */\n} codec_private_t;\n\n\n\n/* CUSTOM CALLBACKS */\n\n/* Parse frames from a packet. Default behaviour of frame parsing is \n * just separating frames based on calculating frame length derived \n * from bitrate. Implement this callback when the default behaviour is \n * unapplicable.\n */\ntypedef pj_status_t (*parse_cb)(codec_private_t *codec_data, void *pkt, \n\t\t\t\tpj_size_t pkt_size, const pj_timestamp *ts,\n\t\t\t\tunsigned *frame_cnt, pjmedia_frame frames[]);\n\n/* Pack frames into a packet. Default behaviour of packing frames is \n * just stacking the frames with octet aligned without adding any \n * payload header. Implement this callback when the default behaviour is\n * unapplicable.\n */\ntypedef pj_status_t (*pack_cb)(codec_private_t *codec_data, \n\t\t\t       const struct pjmedia_frame_ext *input,\n\t\t\t       unsigned output_buf_len, \n\t\t\t       struct pjmedia_frame *output);\n\n\n/* Custom callback implementations. */\nstatic pj_status_t parse_amr( codec_private_t *codec_data, void *pkt, \n\t\t\t      pj_size_t pkt_size, const pj_timestamp *ts,\n\t\t\t      unsigned *frame_cnt, pjmedia_frame frames[]);\nstatic pj_status_t pack_amr ( codec_private_t *codec_data,\n\t\t\t      const struct pjmedia_frame_ext *input,\n\t\t\t      unsigned output_buf_len, \n\t\t\t      struct pjmedia_frame *output);\n\n\n/* Passthrough codec implementation descriptions. */\nstatic struct codec_desc {\n    int\t\t     enabled;\t\t/* Is this codec enabled?\t    */\n    const char\t    *name;\t\t/* Codec name.\t\t\t    */\n    pj_uint8_t\t     pt;\t\t/* Payload type.\t\t    */\n    pjmedia_format_id fmt_id;\t\t/* Source format.\t\t    */\n    unsigned\t     clock_rate;\t/* Codec's clock rate.\t\t    */\n    unsigned\t     channel_count;\t/* Codec's channel count.\t    */\n    unsigned\t     samples_per_frame;\t/* Codec's samples count.\t    */\n    unsigned\t     def_bitrate;\t/* Default bitrate of this codec.   */\n    unsigned\t     max_bitrate;\t/* Maximum bitrate of this codec.   */\n    pj_uint8_t\t     frm_per_pkt;\t/* Default num of frames per packet.*/\n    pj_uint8_t\t     vad;\t\t/* VAD enabled/disabled.\t    */\n    pj_uint8_t\t     plc;\t\t/* PLC enabled/disabled.\t    */\n    parse_cb\t     parse;\t\t/* Callback to parse bitstream.\t    */\n    pack_cb\t     pack;\t\t/* Callback to pack bitstream.\t    */\n    pjmedia_codec_fmtp dec_fmtp;\t/* Decoder's fmtp params.\t    */\n}\n\ncodec_desc[] = \n{\n#   if PJMEDIA_HAS_PASSTHROUGH_CODEC_AMR\n    {1, \"AMR\",\t    PJMEDIA_RTP_PT_AMR,       PJMEDIA_FORMAT_AMR,\n\t\t    8000, 1, 160, \n\t\t    7400, 12200, 2, 1, 1,\n\t\t    &parse_amr, &pack_amr\n\t\t    /*, {1, {{{\"octet-align\", 11}, {\"1\", 1}}} } */\n    },\n#   endif\n\n#   if PJMEDIA_HAS_PASSTHROUGH_CODEC_G729\n    {1, \"G729\",\t    PJMEDIA_RTP_PT_G729,      PJMEDIA_FORMAT_G729,\n\t\t    8000, 1,  80,\n\t\t    8000, 8000, 2, 1, 1\n    },\n#   endif\n\n#   if PJMEDIA_HAS_PASSTHROUGH_CODEC_ILBC\n    {1, \"iLBC\",\t    PJMEDIA_RTP_PT_ILBC,      PJMEDIA_FORMAT_ILBC,\n\t\t    8000, 1,  240,\n\t\t    13333, 15200, 1, 1, 1,\n\t\t    NULL, NULL,\n\t\t    {1, {{{\"mode\", 4}, {\"30\", 2}}} }\n    },\n#   endif\n\n#   if PJMEDIA_HAS_PASSTHROUGH_CODEC_PCMU\n    {1, \"PCMU\",\t    PJMEDIA_RTP_PT_PCMU,      PJMEDIA_FORMAT_PCMU,\n\t\t    8000, 1,  80,\n\t\t    64000, 64000, 2, 1, 1\n    },\n#   endif\n\n#   if PJMEDIA_HAS_PASSTHROUGH_CODEC_PCMA\n    {1, \"PCMA\",\t    PJMEDIA_RTP_PT_PCMA,      PJMEDIA_FORMAT_PCMA,\n\t\t    8000, 1,  80,\n\t\t    64000, 64000, 2, 1, 1\n    },\n#   endif\n};\n\n\n#if PJMEDIA_HAS_PASSTHROUGH_CODEC_AMR\n\n#include <pjmedia-codec/amr_helper.h>\n\ntypedef struct amr_settings_t {\n    pjmedia_codec_amr_pack_setting enc_setting;\n    pjmedia_codec_amr_pack_setting dec_setting;\n    pj_int8_t enc_mode;\n} amr_settings_t;\n\n\n/* Pack AMR payload */\nstatic pj_status_t pack_amr ( codec_private_t *codec_data,\n\t\t\t      const struct pjmedia_frame_ext *input,\n\t\t\t      unsigned output_buf_len, \n\t\t\t      struct pjmedia_frame *output)\n{\n    enum {MAX_FRAMES_PER_PACKET = PJMEDIA_MAX_FRAME_DURATION_MS / 20};\n\n    pjmedia_frame frames[MAX_FRAMES_PER_PACKET];\n    amr_settings_t* setting = (amr_settings_t*)codec_data->codec_setting;\n    pjmedia_codec_amr_pack_setting *enc_setting = &setting->enc_setting;\n    pj_uint8_t SID_FT;\n    unsigned i;\n\n    pj_assert(input->subframe_cnt <= MAX_FRAMES_PER_PACKET);\n\n    SID_FT = (pj_uint8_t)(enc_setting->amr_nb? 8 : 9);\n\n    /* Get frames */\n    for (i = 0; i < input->subframe_cnt; ++i) {\n\tpjmedia_frame_ext_subframe *sf;\n\tpjmedia_codec_amr_bit_info *info;\n\tunsigned len;\n\t\n\tsf = pjmedia_frame_ext_get_subframe(input, i);\n\tlen = (sf->bitlen + 7) >> 3;\n\t\n\tinfo = (pjmedia_codec_amr_bit_info*) &frames[i].bit_info;\n\tpj_bzero(info, sizeof(*info));\n\t\n\tif (len == 0) {\n\t    /* DTX */\n\t    info->frame_type = 15;\n\t} else {\n\t    info->frame_type = pjmedia_codec_amr_get_mode2(enc_setting->amr_nb, \n\t\t\t\t\t\t\t   len);\n\t}\n\tinfo->good_quality = 1;\n\tinfo->mode = setting->enc_mode;\n\tif (info->frame_type == SID_FT)\n\t    info->STI = (sf->data[4] >> 4) & 1;\n\n\tframes[i].buf = sf->data;\n\tframes[i].size = len;\n    }\n\n    output->size = output_buf_len;\n\n    return pjmedia_codec_amr_pack(frames, input->subframe_cnt, enc_setting, \n\t\t\t\t  output->buf, &output->size);\n}\n\n\n/* Parse AMR payload into frames. */\nstatic pj_status_t parse_amr(codec_private_t *codec_data, void *pkt, \n\t\t\t     pj_size_t pkt_size, const pj_timestamp *ts,\n\t\t\t     unsigned *frame_cnt, pjmedia_frame frames[])\n{\n    amr_settings_t* s = (amr_settings_t*)codec_data->codec_setting;\n    pjmedia_codec_amr_pack_setting *setting;\n    pj_status_t status;\n    pj_uint8_t cmr;\n\n    setting = &s->dec_setting;\n\n    status = pjmedia_codec_amr_parse(pkt, pkt_size, ts, setting, frames, \n\t\t\t\t     frame_cnt, &cmr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    // CMR is not supported for now. \n    /* Check Change Mode Request. */\n    //if ((setting->amr_nb && cmr <= 7) || (!setting->amr_nb && cmr <= 8)) {\n    //\ts->enc_mode = cmr;\n    //}\n\n    return PJ_SUCCESS;\n}\n\n#endif /* PJMEDIA_HAS_PASSTHROUGH_CODEC_AMR */\n\n\n/*\n * Initialize and register passthrough codec factory to pjmedia endpoint.\n */\nPJ_DEF(pj_status_t) pjmedia_codec_passthrough_init( pjmedia_endpt *endpt )\n{\n    pjmedia_codec_mgr *codec_mgr;\n    pj_str_t codec_name;\n    pj_status_t status;\n\n    if (codec_factory.pool != NULL) {\n\t/* Already initialized. */\n\treturn PJ_EEXISTS;\n    }\n\n    /* Create passthrough codec factory. */\n    codec_factory.base.op = &codec_factory_op;\n    codec_factory.base.factory_data = NULL;\n    codec_factory.endpt = endpt;\n\n    codec_factory.pool = pjmedia_endpt_create_pool(endpt, \"Passthrough codecs\",\n\t\t\t\t\t\t   4000, 4000);\n    if (!codec_factory.pool)\n\treturn PJ_ENOMEM;\n\n    /* Create mutex. */\n    status = pj_mutex_create_simple(codec_factory.pool, \"Passthrough codecs\",\n\t\t\t\t    &codec_factory.mutex);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Get the codec manager. */\n    codec_mgr = pjmedia_endpt_get_codec_mgr(endpt);\n    if (!codec_mgr) {\n\tstatus = PJ_EINVALIDOP;\n\tgoto on_error;\n    }\n\n    /* Register format match callback. */\n#if PJMEDIA_HAS_PASSTHROUGH_CODEC_AMR\n    pj_cstr(&codec_name, \"AMR\");\n    status = pjmedia_sdp_neg_register_fmt_match_cb(\n\t\t\t\t\t&codec_name,\n\t\t\t\t\t&pjmedia_codec_amr_match_sdp);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n#endif\n\n    /* Suppress compile warning */\n    PJ_UNUSED_ARG(codec_name);\n\n    /* Register codec factory to endpoint. */\n    status = pjmedia_codec_mgr_register_factory(codec_mgr, \n\t\t\t\t\t\t&codec_factory.base);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Done. */\n    return PJ_SUCCESS;\n\non_error:\n    pj_pool_release(codec_factory.pool);\n    codec_factory.pool = NULL;\n    return status;\n}\n\n/*\n * Initialize and register passthrough codec factory to pjmedia endpoint.\n */\nPJ_DEF(pj_status_t) pjmedia_codec_passthrough_init2( \n\t\t      pjmedia_endpt *endpt,\n\t\t      const pjmedia_codec_passthrough_setting *setting)\n{\n    if (codec_factory.pool != NULL) {\n\t/* Already initialized. */\n\treturn PJ_EEXISTS;\n    }\n\n    if (setting != NULL) {\n\tunsigned i;\n\n\t/* Enable/disable codecs based on the specified encoding formats */\n\tfor (i = 0; i < PJ_ARRAY_SIZE(codec_desc); ++i) {\n\t    pj_bool_t enabled = PJ_FALSE;\n\t    unsigned j;\n\n\t    for (j = 0; j < setting->fmt_cnt && !enabled; ++j) {\n\t\tif ((pj_uint32_t)codec_desc[i].fmt_id == setting->fmts[j].id)\n\t\t    enabled = PJ_TRUE;\n\t    }\n\n\t    codec_desc[i].enabled = enabled;\n\t}\n\n#if PJMEDIA_HAS_PASSTHROUGH_CODEC_ILBC\n\t/* Update iLBC codec description based on default mode setting. */\n\tfor (i = 0; i < PJ_ARRAY_SIZE(codec_desc); ++i) {\n\t    if (codec_desc[i].enabled && \n\t\tcodec_desc[i].fmt_id == PJMEDIA_FORMAT_ILBC)\n\t    {\n\t\tcodec_desc[i].samples_per_frame = \n\t\t\t\t(setting->ilbc_mode == 20? 160 : 240);\n\t\tcodec_desc[i].def_bitrate = \n\t\t\t\t(setting->ilbc_mode == 20? 15200 : 13333);\n\t\tpj_strset2(&codec_desc[i].dec_fmtp.param[0].val, \n\t\t\t\t(setting->ilbc_mode == 20? \"20\" : \"30\"));\n\t\tbreak;\n\t    }\n\t}\n#endif\n    }\n\n    return pjmedia_codec_passthrough_init(endpt);\n}\n\n/*\n * Unregister passthrough codecs factory from pjmedia endpoint.\n */\nPJ_DEF(pj_status_t) pjmedia_codec_passthrough_deinit(void)\n{\n    pjmedia_codec_mgr *codec_mgr;\n    unsigned i;\n    pj_status_t status;\n\n    if (codec_factory.pool == NULL) {\n\t/* Already deinitialized */\n\treturn PJ_SUCCESS;\n    }\n\n    pj_mutex_lock(codec_factory.mutex);\n\n    /* Get the codec manager. */\n    codec_mgr = pjmedia_endpt_get_codec_mgr(codec_factory.endpt);\n    if (!codec_mgr) {\n\tpj_pool_release(codec_factory.pool);\n\tcodec_factory.pool = NULL;\n\tpj_mutex_unlock(codec_factory.mutex);\n\treturn PJ_EINVALIDOP;\n    }\n\n    /* Unregister passthrough codecs factory. */\n    status = pjmedia_codec_mgr_unregister_factory(codec_mgr,\n\t\t\t\t\t\t  &codec_factory.base);\n    \n    /* Destroy mutex. */\n    pj_mutex_unlock(codec_factory.mutex);\n    pj_mutex_destroy(codec_factory.mutex);\n    codec_factory.mutex = NULL;\n\n    /* Destroy pool. */\n    pj_pool_release(codec_factory.pool);\n    codec_factory.pool = NULL;\n\n    /* Re-enable all codecs in the codec_desc. */\n    for (i = 0; i < PJ_ARRAY_SIZE(codec_desc); ++i) {\n\tcodec_desc[i].enabled = PJ_TRUE;\n    }\n\n    return status;\n}\n\n/* \n * Check if factory can allocate the specified codec. \n */\nstatic pj_status_t test_alloc( pjmedia_codec_factory *factory, \n\t\t\t       const pjmedia_codec_info *info )\n{\n    unsigned i;\n\n    PJ_UNUSED_ARG(factory);\n\n    /* Type MUST be audio. */\n    if (info->type != PJMEDIA_TYPE_AUDIO)\n\treturn PJMEDIA_CODEC_EUNSUP;\n\n    for (i = 0; i < PJ_ARRAY_SIZE(codec_desc); ++i) {\n\tpj_str_t name = pj_str((char*)codec_desc[i].name);\n\tif ((pj_stricmp(&info->encoding_name, &name) == 0) &&\n\t    (info->clock_rate == (unsigned)codec_desc[i].clock_rate) &&\n\t    (info->channel_cnt == (unsigned)codec_desc[i].channel_count) &&\n\t    (codec_desc[i].enabled))\n\t{\n\t    return PJ_SUCCESS;\n\t}\n    }\n    \n    /* Unsupported, or mode is disabled. */\n    return PJMEDIA_CODEC_EUNSUP;\n}\n\n/*\n * Generate default attribute.\n */\nstatic pj_status_t default_attr ( pjmedia_codec_factory *factory, \n\t\t\t\t  const pjmedia_codec_info *id, \n\t\t\t\t  pjmedia_codec_param *attr )\n{\n    unsigned i;\n\n    PJ_ASSERT_RETURN(factory==&codec_factory.base, PJ_EINVAL);\n\n    pj_bzero(attr, sizeof(pjmedia_codec_param));\n\n    for (i = 0; i < PJ_ARRAY_SIZE(codec_desc); ++i) {\n\tpj_str_t name = pj_str((char*)codec_desc[i].name);\n\tif ((pj_stricmp(&id->encoding_name, &name) == 0) &&\n\t    (id->clock_rate == (unsigned)codec_desc[i].clock_rate) &&\n\t    (id->channel_cnt == (unsigned)codec_desc[i].channel_count) &&\n\t    (id->pt == (unsigned)codec_desc[i].pt))\n\t{\n\t    attr->info.pt = (pj_uint8_t)id->pt;\n\t    attr->info.channel_cnt = codec_desc[i].channel_count;\n\t    attr->info.clock_rate = codec_desc[i].clock_rate;\n\t    attr->info.avg_bps = codec_desc[i].def_bitrate;\n\t    attr->info.max_bps = codec_desc[i].max_bitrate;\n\t    attr->info.pcm_bits_per_sample = 16;\n\t    attr->info.frm_ptime =  (pj_uint16_t)\n\t\t\t\t    (codec_desc[i].samples_per_frame * 1000 / \n\t\t\t\t    codec_desc[i].channel_count / \n\t\t\t\t    codec_desc[i].clock_rate);\n\t    attr->info.fmt_id = codec_desc[i].fmt_id;\n\n\t    /* Default flags. */\n\t    attr->setting.frm_per_pkt = codec_desc[i].frm_per_pkt;\n\t    attr->setting.plc = codec_desc[i].plc;\n\t    attr->setting.penh= 0;\n\t    attr->setting.vad = codec_desc[i].vad;\n\t    attr->setting.cng = attr->setting.vad;\n\t    attr->setting.dec_fmtp = codec_desc[i].dec_fmtp;\n\n\t    if (attr->setting.vad == 0) {\n#if PJMEDIA_HAS_PASSTHROUGH_CODEC_G729\n\t\tif (id->pt == PJMEDIA_RTP_PT_G729) {\n\t\t    /* Signal G729 Annex B is being disabled */\n\t\t    attr->setting.dec_fmtp.cnt = 1;\n\t\t    pj_strset2(&attr->setting.dec_fmtp.param[0].name, \"annexb\");\n\t\t    pj_strset2(&attr->setting.dec_fmtp.param[0].val, \"no\");\n\t\t}\n#endif\n\t    }\n\n\t    return PJ_SUCCESS;\n\t}\n    }\n\n    return PJMEDIA_CODEC_EUNSUP;\n}\n\n/*\n * Enum codecs supported by this factory.\n */\nstatic pj_status_t enum_codecs( pjmedia_codec_factory *factory, \n\t\t\t\tunsigned *count, \n\t\t\t\tpjmedia_codec_info codecs[])\n{\n    unsigned max;\n    unsigned i;\n\n    PJ_UNUSED_ARG(factory);\n    PJ_ASSERT_RETURN(codecs && *count > 0, PJ_EINVAL);\n\n    max = *count;\n    \n    for (i = 0, *count = 0; i < PJ_ARRAY_SIZE(codec_desc) && *count < max; ++i) \n    {\n\tif (!codec_desc[i].enabled)\n\t    continue;\n\n\tpj_bzero(&codecs[*count], sizeof(pjmedia_codec_info));\n\tcodecs[*count].encoding_name = pj_str((char*)codec_desc[i].name);\n\tcodecs[*count].pt = codec_desc[i].pt;\n\tcodecs[*count].type = PJMEDIA_TYPE_AUDIO;\n\tcodecs[*count].clock_rate = codec_desc[i].clock_rate;\n\tcodecs[*count].channel_cnt = codec_desc[i].channel_count;\n\n\t++*count;\n    }\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Allocate a new codec instance.\n */\nstatic pj_status_t alloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\tconst pjmedia_codec_info *id,\n\t\t\t\tpjmedia_codec **p_codec)\n{\n    codec_private_t *codec_data;\n    pjmedia_codec *codec;\n    int idx;\n    pj_pool_t *pool;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(factory && id && p_codec, PJ_EINVAL);\n    PJ_ASSERT_RETURN(factory == &codec_factory.base, PJ_EINVAL);\n\n    pj_mutex_lock(codec_factory.mutex);\n\n    /* Find codec's index */\n    idx = -1;\n    for (i = 0; i < PJ_ARRAY_SIZE(codec_desc); ++i) {\n\tpj_str_t name = pj_str((char*)codec_desc[i].name);\n\tif ((pj_stricmp(&id->encoding_name, &name) == 0) &&\n\t    (id->clock_rate == (unsigned)codec_desc[i].clock_rate) &&\n\t    (id->channel_cnt == (unsigned)codec_desc[i].channel_count) &&\n\t    (codec_desc[i].enabled))\n\t{\n\t    idx = i;\n\t    break;\n\t}\n    }\n    if (idx == -1) {\n\t*p_codec = NULL;\n\treturn PJMEDIA_CODEC_EUNSUP;\n    }\n\n    /* Create pool for codec instance */\n    pool = pjmedia_endpt_create_pool(codec_factory.endpt, \"passthroughcodec\",\n\t\t\t\t     512, 512);\n    codec = PJ_POOL_ZALLOC_T(pool, pjmedia_codec);\n    codec->op = &codec_op;\n    codec->factory = factory;\n    codec->codec_data = PJ_POOL_ZALLOC_T(pool, codec_private_t);\n    codec_data = (codec_private_t*) codec->codec_data;\n    codec_data->pool = pool;\n    codec_data->codec_idx = idx;\n\n    pj_mutex_unlock(codec_factory.mutex);\n\n    *p_codec = codec;\n    return PJ_SUCCESS;\n}\n\n/*\n * Free codec.\n */\nstatic pj_status_t dealloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t  pjmedia_codec *codec )\n{\n    codec_private_t *codec_data;\n\n    PJ_ASSERT_RETURN(factory && codec, PJ_EINVAL);\n    PJ_ASSERT_RETURN(factory == &codec_factory.base, PJ_EINVAL);\n\n    /* Close codec, if it's not closed. */\n    codec_data = (codec_private_t*) codec->codec_data;\n    codec_close(codec);\n\n    pj_pool_release(codec_data->pool);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Init codec.\n */\nstatic pj_status_t codec_init( pjmedia_codec *codec, \n\t\t\t       pj_pool_t *pool )\n{\n    PJ_UNUSED_ARG(codec);\n    PJ_UNUSED_ARG(pool);\n    return PJ_SUCCESS;\n}\n\n/*\n * Open codec.\n */\nstatic pj_status_t codec_open( pjmedia_codec *codec, \n\t\t\t       pjmedia_codec_param *attr )\n{\n    codec_private_t *codec_data = (codec_private_t*) codec->codec_data;\n    struct codec_desc *desc = &codec_desc[codec_data->codec_idx];\n    pj_pool_t *pool;\n    int i, j;\n\n    pool = codec_data->pool;\n\n    /* Cache samples per frame value */\n    codec_data->samples_per_frame = desc->samples_per_frame;\n\n    /* Calculate bitstream size */\n    i = attr->info.avg_bps * codec_data->samples_per_frame;\n    j = desc->clock_rate << 3;\n    codec_data->avg_frame_size = (pj_uint16_t)(i / j);\n    if (i % j) ++codec_data->avg_frame_size;\n\n#if PJMEDIA_HAS_PASSTHROUGH_CODEC_AMR\n    /* Init AMR settings */\n    if (desc->pt == PJMEDIA_RTP_PT_AMR || desc->pt == PJMEDIA_RTP_PT_AMRWB) {\n\tamr_settings_t *s;\n\tpj_uint8_t octet_align = 0;\n\tpj_int8_t enc_mode;\n\t\n\tenc_mode = pjmedia_codec_amr_get_mode(attr->info.avg_bps);\n\tpj_assert(enc_mode >= 0 && enc_mode <= 8);\n\n\tfor (i = 0; i < attr->setting.dec_fmtp.cnt; ++i) {\n\t    const pj_str_t STR_FMTP_OCTET_ALIGN = {\"octet-align\", 11};\n\t    \n\t    /* Fetch octet-align setting. It should be fine to fetch only \n\t     * the decoder, since encoder & decoder must use the same setting \n\t     * (RFC 4867 section 8.3.1).\n\t     */\n\t    if (pj_stricmp(&attr->setting.dec_fmtp.param[i].name, \n\t\t\t   &STR_FMTP_OCTET_ALIGN) == 0)\n\t    {\n\t\toctet_align=(pj_uint8_t)\n\t\t\t    (pj_strtoul(&attr->setting.dec_fmtp.param[i].val));\n\t\tbreak;\n\t    }\n\t}\n\n\tfor (i = 0; i < attr->setting.enc_fmtp.cnt; ++i) {\n\t    const pj_str_t STR_FMTP_MODE_SET = {\"mode-set\", 8};\n\n\t    /* mode-set, encoding mode is chosen based on local default mode \n\t     * setting:\n\t     * - if local default mode is included in the mode-set, use it\n\t     * - otherwise, find the closest mode to local default mode;\n\t     *   if there are two closest modes, prefer to use the higher\n\t     *   one, e.g: local default mode is 4, the mode-set param\n\t     *   contains '2,3,5,6', then 5 will be chosen.\n\t     */\n\t    if (pj_stricmp(&attr->setting.enc_fmtp.param[i].name, \n\t\t\t   &STR_FMTP_MODE_SET) == 0)\n\t    {\n\t\tconst char *p;\n\t\tpj_size_t l;\n\t\tpj_int8_t diff = 99;\n\t\t\n\t\tp = pj_strbuf(&attr->setting.enc_fmtp.param[i].val);\n\t\tl = pj_strlen(&attr->setting.enc_fmtp.param[i].val);\n\n\t\twhile (l--) {\n\t\t    if ((desc->pt==PJMEDIA_RTP_PT_AMR && *p>='0' && *p<='7') ||\n\t\t        (desc->pt==PJMEDIA_RTP_PT_AMRWB && *p>='0' && *p<='8'))\n\t\t    {\n\t\t\tpj_int8_t tmp = (pj_int8_t)(*p - '0' - enc_mode);\n\n\t\t\tif (PJ_ABS(diff) > PJ_ABS(tmp) || \n\t\t\t    (PJ_ABS(diff) == PJ_ABS(tmp) && tmp > diff))\n\t\t\t{\n\t\t\t    diff = tmp;\n\t\t\t    if (diff == 0) break;\n\t\t\t}\n\t\t    }\n\t\t    ++p;\n\t\t}\n\n\t\tif (diff == 99)\n\t\t    return PJMEDIA_CODEC_EFAILED;\n\n\t\tenc_mode = (pj_int8_t)(enc_mode + diff);\n\n\t\tbreak;\n\t    }\n\t}\n\n\ts = PJ_POOL_ZALLOC_T(pool, amr_settings_t);\n\tcodec_data->codec_setting = s;\n\n\ts->enc_mode = enc_mode;\n\tif (s->enc_mode < 0)\n\t    return PJMEDIA_CODEC_EINMODE;\n\n\ts->enc_setting.amr_nb = (pj_uint8_t)(desc->pt == PJMEDIA_RTP_PT_AMR);\n\ts->enc_setting.octet_aligned = octet_align;\n\ts->enc_setting.reorder = PJ_FALSE; /* Note this! passthrough codec\n\t\t\t\t\t      doesn't do sensitivity bits \n\t\t\t\t\t      reordering */\n\ts->enc_setting.cmr = 15;\n\t\n\ts->dec_setting.amr_nb = (pj_uint8_t)(desc->pt == PJMEDIA_RTP_PT_AMR);\n\ts->dec_setting.octet_aligned = octet_align;\n\ts->dec_setting.reorder = PJ_FALSE; /* Note this! passthrough codec\n\t\t\t\t\t      doesn't do sensitivity bits \n\t\t\t\t\t      reordering */\n\t\n\t/* Return back bitrate info to application */\n\tattr->info.avg_bps = s->enc_setting.amr_nb?\n\t\t\t     pjmedia_codec_amrnb_bitrates[s->enc_mode]:\n\t\t\t     pjmedia_codec_amrwb_bitrates[s->enc_mode];\n    }\n#endif\n\n#if PJMEDIA_HAS_PASSTHROUGH_CODEC_ILBC\n    /* Init iLBC settings */\n    if (desc->pt == PJMEDIA_RTP_PT_ILBC)\n    {\n\tenum { DEFAULT_MODE = 30 };\n\tstatic pj_str_t STR_MODE = {\"mode\", 4};\n\tpj_uint16_t dec_fmtp_mode = DEFAULT_MODE, \n\t\t    enc_fmtp_mode = DEFAULT_MODE;\n\n\t/* Get decoder mode */\n\tfor (i = 0; i < attr->setting.dec_fmtp.cnt; ++i) {\n\t    if (pj_stricmp(&attr->setting.dec_fmtp.param[i].name, &STR_MODE) == 0)\n\t    {\n\t\tdec_fmtp_mode = (pj_uint16_t)\n\t\t\t\tpj_strtoul(&attr->setting.dec_fmtp.param[i].val);\n\t\tbreak;\n\t    }\n\t}\n\n\t/* Decoder mode must be set */\n\tPJ_ASSERT_RETURN(dec_fmtp_mode == 20 || dec_fmtp_mode == 30, \n\t\t\t PJMEDIA_CODEC_EINMODE);\n\n\t/* Get encoder mode */\n\tfor (i = 0; i < attr->setting.enc_fmtp.cnt; ++i) {\n\t    if (pj_stricmp(&attr->setting.enc_fmtp.param[i].name, &STR_MODE) == 0)\n\t    {\n\t\tenc_fmtp_mode = (pj_uint16_t)\n\t\t\t\tpj_strtoul(&attr->setting.enc_fmtp.param[i].val);\n\t\tbreak;\n\t    }\n\t}\n\n\tPJ_ASSERT_RETURN(enc_fmtp_mode==20 || enc_fmtp_mode==30, \n\t\t\t PJMEDIA_CODEC_EINMODE);\n\n\t/* Both sides of a bi-directional session MUST use the same \"mode\" value.\n\t * In this point, possible values are only 20 or 30, so when encoder and\n\t * decoder modes are not same, just use the default mode, it is 30.\n\t */\n\tif (enc_fmtp_mode != dec_fmtp_mode) {\n\t    enc_fmtp_mode = dec_fmtp_mode = DEFAULT_MODE;\n\t    PJ_LOG(4,(pool->obj_name, \n\t\t      \"Normalized iLBC encoder and decoder modes to %d\", \n\t\t      DEFAULT_MODE));\n\t}\n\n\t/* Update some attributes based on negotiated mode. */\n\tattr->info.avg_bps = (dec_fmtp_mode == 30? 13333 : 15200);\n\tattr->info.frm_ptime = dec_fmtp_mode;\n\n\t/* Override average frame size */\n\tcodec_data->avg_frame_size = (dec_fmtp_mode == 30? 50 : 38);\n\n\t/* Override samples per frame */\n\tcodec_data->samples_per_frame = (dec_fmtp_mode == 30? 240 : 160);\n    }\n#endif\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Close codec.\n */\nstatic pj_status_t codec_close( pjmedia_codec *codec )\n{\n    PJ_UNUSED_ARG(codec);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Modify codec settings.\n */\nstatic pj_status_t codec_modify( pjmedia_codec *codec, \n\t\t\t\t const pjmedia_codec_param *attr )\n{\n    /* Not supported yet. */\n    PJ_UNUSED_ARG(codec);\n    PJ_UNUSED_ARG(attr);\n\n    return PJ_ENOTSUP;\n}\n\n/*\n * Get frames in the packet.\n */\nstatic pj_status_t codec_parse( pjmedia_codec *codec,\n\t\t\t\tvoid *pkt,\n\t\t\t\tpj_size_t pkt_size,\n\t\t\t\tconst pj_timestamp *ts,\n\t\t\t\tunsigned *frame_cnt,\n\t\t\t\tpjmedia_frame frames[])\n{\n    codec_private_t *codec_data = (codec_private_t*) codec->codec_data;\n    struct codec_desc *desc = &codec_desc[codec_data->codec_idx];\n    unsigned count = 0;\n\n    PJ_ASSERT_RETURN(frame_cnt, PJ_EINVAL);\n\n    if (desc->parse != NULL) {\n\treturn desc->parse(codec_data, pkt,  pkt_size, ts, frame_cnt, frames);\n    }\n\n    while (pkt_size >= codec_data->avg_frame_size && count < *frame_cnt) {\n\tframes[count].type = PJMEDIA_FRAME_TYPE_AUDIO;\n\tframes[count].buf = pkt;\n\tframes[count].size = codec_data->avg_frame_size;\n\tframes[count].timestamp.u64 = ts->u64 + \n\t\t\t\t      count * codec_data->samples_per_frame;\n\n\tpkt = (pj_uint8_t*)pkt + codec_data->avg_frame_size;\n\tpkt_size -= codec_data->avg_frame_size;\n\n\t++count;\n    }\n\n    if (pkt_size && count < *frame_cnt) {\n\tframes[count].type = PJMEDIA_FRAME_TYPE_AUDIO;\n\tframes[count].buf = pkt;\n\tframes[count].size = pkt_size;\n\tframes[count].timestamp.u64 = ts->u64 + \n\t\t\t\t       count * codec_data->samples_per_frame;\n\t++count;\n    }\n\n    *frame_cnt = count;\n    return PJ_SUCCESS;\n}\n\n/*\n * Encode frames.\n */\nstatic pj_status_t codec_encode( pjmedia_codec *codec, \n\t\t\t\t const struct pjmedia_frame *input,\n\t\t\t\t unsigned output_buf_len, \n\t\t\t\t struct pjmedia_frame *output)\n{\n    codec_private_t *codec_data = (codec_private_t*) codec->codec_data;\n    struct codec_desc *desc = &codec_desc[codec_data->codec_idx];\n    const pjmedia_frame_ext *input_ = (const pjmedia_frame_ext*) input;\n\n    pj_assert(input && input->type == PJMEDIA_FRAME_TYPE_EXTENDED);\n\n    if (desc->pack != NULL) {\n\tdesc->pack(codec_data, input_, output_buf_len, output);\n    } else {\n\tif (input_->subframe_cnt == 0) {\n\t    /* DTX */\n\t    output->buf = NULL;\n\t    output->size = 0;\n\t    output->type = PJMEDIA_FRAME_TYPE_NONE;\n\t} else {\n\t    unsigned i;\n\t    pj_uint8_t *p = output->buf;\n\n\t    output->type = PJMEDIA_FRAME_TYPE_AUDIO;\n\t    output->size = 0;\n\t    \n\t    for (i = 0; i < input_->subframe_cnt; ++i) {\n\t\tpjmedia_frame_ext_subframe *sf;\n\t\tunsigned sf_len;\n\n\t\tsf = pjmedia_frame_ext_get_subframe(input_, i);\n\t\tpj_assert(sf);\n\n\t\tsf_len = (sf->bitlen + 7) >> 3;\n\n\t\tpj_memcpy(p, sf->data, sf_len);\n\t\tp += sf_len;\n\t\toutput->size += sf_len;\n\n\t\t/* If there is SID or DTX frame, break the loop. */\n\t\tif (desc->pt == PJMEDIA_RTP_PT_G729 && \n\t\t    sf_len < codec_data->avg_frame_size)\n\t\t{\n\t\t    break;\n\t\t}\n\t\t\n\t    }\n\t}\n    }\n\n    output->timestamp = input->timestamp;\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Decode frame.\n */\nstatic pj_status_t codec_decode( pjmedia_codec *codec, \n\t\t\t\t const struct pjmedia_frame *input,\n\t\t\t\t unsigned output_buf_len, \n\t\t\t\t struct pjmedia_frame *output)\n{\n    codec_private_t *codec_data = (codec_private_t*) codec->codec_data;\n#if PJMEDIA_HAS_PASSTHROUGH_CODEC_AMR\n    struct codec_desc *desc = &codec_desc[codec_data->codec_idx];\n#endif\n    pjmedia_frame_ext *output_ = (pjmedia_frame_ext*) output;\n\n    pj_assert(input);\n    PJ_UNUSED_ARG(output_buf_len);\n\n#if PJMEDIA_HAS_PASSTHROUGH_CODEC_AMR\n    /* Need to rearrange the AMR bitstream, since the bitstream may not be \n     * started from bit 0 or may need to be reordered from sensitivity order \n     * into encoder bits order.\n     */\n    if (desc->pt == PJMEDIA_RTP_PT_AMR || desc->pt == PJMEDIA_RTP_PT_AMRWB) {\n\tpjmedia_frame input_;\n\tpjmedia_codec_amr_pack_setting *setting;\n\n\tsetting = &((amr_settings_t*)codec_data->codec_setting)->dec_setting;\n\n\tinput_ = *input;\n\tpjmedia_codec_amr_predecode(input, setting, &input_);\n\t\n\tpjmedia_frame_ext_append_subframe(output_, input_.buf, \n\t\t\t\t\t  (pj_uint16_t)(input_.size << 3),\n\t\t\t\t\t  (pj_uint16_t)codec_data->samples_per_frame);\n\toutput->timestamp = input->timestamp;\n\t\n\treturn PJ_SUCCESS;\n    }\n#endif\n    \n    pjmedia_frame_ext_append_subframe(output_, input->buf, \n\t\t\t\t      (pj_uint16_t)(input->size << 3),\n\t\t\t\t      (pj_uint16_t)codec_data->samples_per_frame);\n    output->timestamp = input->timestamp;\n\n    return PJ_SUCCESS;\n}\n\n/* \n * Recover lost frame.\n */\nstatic pj_status_t codec_recover( pjmedia_codec *codec, \n\t\t\t\t  unsigned output_buf_len, \n\t\t\t\t  struct pjmedia_frame *output)\n{\n    codec_private_t *codec_data = (codec_private_t*) codec->codec_data;\n    pjmedia_frame_ext *output_ = (pjmedia_frame_ext*) output;\n\n    PJ_UNUSED_ARG(output_buf_len);\n\n    pjmedia_frame_ext_append_subframe(output_, NULL, 0,\n\t\t\t\t      (pj_uint16_t)codec_data->samples_per_frame);\n\n    return PJ_SUCCESS;\n}\n\n#endif\t/* PJMEDIA_HAS_PASSTHROUGH_CODECS */\n\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n\n#include <pjmedia-codec/speex.h>\n#include <pjmedia/codec.h>\n#include <pjmedia/errno.h>\n#include <pjmedia/endpoint.h>\n#include <pjmedia/port.h>\n#include <speex/speex.h>\n#include <pj/assert.h>\n#include <pj/log.h>\n#include <pj/pool.h>\n#include <pj/string.h>\n#include <pj/os.h>\n\n/*\n * Only build this file if PJMEDIA_HAS_SPEEX_CODEC != 0\n */\n#if defined(PJMEDIA_HAS_SPEEX_CODEC) && PJMEDIA_HAS_SPEEX_CODEC!=0\n\n\n#define THIS_FILE   \"speex_codec.c\"\n\n/* Prototypes for Speex factory */\nstatic pj_status_t spx_test_alloc( pjmedia_codec_factory *factory, \n\t\t\t\t   const pjmedia_codec_info *id );\nstatic pj_status_t spx_default_attr( pjmedia_codec_factory *factory, \n\t\t\t\t     const pjmedia_codec_info *id, \n\t\t\t\t     pjmedia_codec_param *attr );\nstatic pj_status_t spx_enum_codecs( pjmedia_codec_factory *factory, \n\t\t\t\t    unsigned *count, \n\t\t\t\t    pjmedia_codec_info codecs[]);\nstatic pj_status_t spx_alloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t    const pjmedia_codec_info *id, \n\t\t\t\t    pjmedia_codec **p_codec);\nstatic pj_status_t spx_dealloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t      pjmedia_codec *codec );\n\n/* Prototypes for Speex implementation. */\nstatic pj_status_t  spx_codec_init( pjmedia_codec *codec, \n\t\t\t\t    pj_pool_t *pool );\nstatic pj_status_t  spx_codec_open( pjmedia_codec *codec, \n\t\t\t\t    pjmedia_codec_param *attr );\nstatic pj_status_t  spx_codec_close( pjmedia_codec *codec );\nstatic pj_status_t  spx_codec_modify(pjmedia_codec *codec, \n\t\t\t\t     const pjmedia_codec_param *attr );\nstatic pj_status_t  spx_codec_parse( pjmedia_codec *codec,\n\t\t\t\t     void *pkt,\n\t\t\t\t     pj_size_t pkt_size,\n\t\t\t\t     const pj_timestamp *ts,\n\t\t\t\t     unsigned *frame_cnt,\n\t\t\t\t     pjmedia_frame frames[]);\nstatic pj_status_t  spx_codec_encode( pjmedia_codec *codec, \n\t\t\t\t      const struct pjmedia_frame *input,\n\t\t\t\t      unsigned output_buf_len, \n\t\t\t\t      struct pjmedia_frame *output);\nstatic pj_status_t  spx_codec_decode( pjmedia_codec *codec, \n\t\t\t\t      const struct pjmedia_frame *input,\n\t\t\t\t      unsigned output_buf_len, \n\t\t\t\t      struct pjmedia_frame *output);\nstatic pj_status_t  spx_codec_recover(pjmedia_codec *codec, \n\t\t\t\t      unsigned output_buf_len, \n\t\t\t\t      struct pjmedia_frame *output);\n\n/* Definition for Speex codec operations. */\nstatic pjmedia_codec_op spx_op = \n{\n    &spx_codec_init,\n    &spx_codec_open,\n    &spx_codec_close,\n    &spx_codec_modify,\n    &spx_codec_parse,\n    &spx_codec_encode,\n    &spx_codec_decode,\n    &spx_codec_recover\n};\n\n/* Definition for Speex codec factory operations. */\nstatic pjmedia_codec_factory_op spx_factory_op =\n{\n    &spx_test_alloc,\n    &spx_default_attr,\n    &spx_enum_codecs,\n    &spx_alloc_codec,\n    &spx_dealloc_codec,\n    &pjmedia_codec_speex_deinit\n};\n\n/* Index to Speex parameter. */\nenum\n{\n    PARAM_NB,\t/* Index for narrowband parameter.\t*/\n    PARAM_WB,\t/* Index for wideband parameter.\t*/\n    PARAM_UWB,\t/* Index for ultra-wideband parameter\t*/\n};\n\n/* Speex default parameter */\nstruct speex_param\n{\n    int\t\t     enabled;\t\t/* Is this mode enabled?\t    */\n    const SpeexMode *mode;\t\t/* Speex mode.\t\t\t    */\n    int\t\t     pt;\t\t/* Payload type.\t\t    */\n    unsigned\t     clock_rate;\t/* Default sampling rate to be used.*/\n    int\t\t     quality;\t\t/* Default encoder quality.\t    */\n    int\t\t     complexity;\t/* Default encoder complexity.\t    */\n    int\t\t     samples_per_frame;\t/* Samples per frame.\t\t    */\n    int\t\t     framesize;\t\t/* Frame size for current mode.\t    */\n    int\t\t     bitrate;\t\t/* Bit rate for current mode.\t    */\n    int\t\t     max_bitrate;\t/* Max bit rate for current mode.   */\n};\n\n/* Speex factory */\nstatic struct spx_factory\n{\n    pjmedia_codec_factory    base;\n    pjmedia_endpt\t    *endpt;\n    pj_pool_t\t\t    *pool;\n    pj_mutex_t\t\t    *mutex;\n    pjmedia_codec\t     codec_list;\n    struct speex_param\t     speex_param[3];\n\n} spx_factory;\n\n/* Speex codec private data. */\nstruct spx_private\n{\n    int\t\t\t param_id;\t    /**< Index to speex param.\t*/\n\n    void\t\t*enc;\t\t    /**< Encoder state.\t\t*/\n    SpeexBits\t\t enc_bits;\t    /**< Encoder bits.\t\t*/\n    void\t\t*dec;\t\t    /**< Decoder state.\t\t*/\n    SpeexBits\t\t dec_bits;\t    /**< Decoder bits.\t\t*/\n};\n\n\n/*\n * Get codec bitrate and frame size.\n */\nstatic pj_status_t get_speex_info( struct speex_param *p )\n{\n    void *state;\n    int tmp;\n\n    /* Create temporary encoder */\n    state = speex_encoder_init(p->mode);\n    if (!state)\n\treturn PJMEDIA_CODEC_EFAILED;\n\n    /* Set the quality */\n    if (p->quality != -1)\n\tspeex_encoder_ctl(state, SPEEX_SET_QUALITY, &p->quality);\n\n    /* Sampling rate. */\n    speex_encoder_ctl(state, SPEEX_SET_SAMPLING_RATE, &p->clock_rate);\n\n    /* VAD off to have max bitrate */\n    tmp = 0;\n    speex_encoder_ctl(state, SPEEX_SET_VAD, &tmp);\n\n    /* Complexity. */\n    if (p->complexity != -1)\n\tspeex_encoder_ctl(state, SPEEX_SET_COMPLEXITY, &p->complexity);\n\n    /* Now get the frame size */\n    speex_encoder_ctl(state, SPEEX_GET_FRAME_SIZE, &p->samples_per_frame);\n\n    /* Now get the average bitrate */\n    speex_encoder_ctl(state, SPEEX_GET_BITRATE, &p->bitrate);\n\n    /* Calculate framesize. */\n    p->framesize = p->bitrate * 20 / 1000;\n\n    /* Now get the maximum bitrate by using maximum quality (=10) */\n    tmp = 10;\n    speex_encoder_ctl(state, SPEEX_SET_QUALITY, &tmp);\n    speex_encoder_ctl(state, SPEEX_GET_BITRATE, &p->max_bitrate);\n\n    /* Destroy encoder. */\n    speex_encoder_destroy(state);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Initialize and register Speex codec factory to pjmedia endpoint.\n */\nPJ_DEF(pj_status_t) pjmedia_codec_speex_init( pjmedia_endpt *endpt,\n\t\t\t\t\t      unsigned options,\n\t\t\t\t\t      int quality,\n\t\t\t\t\t      int complexity )\n{\n    pjmedia_codec_mgr *codec_mgr;\n    unsigned i;\n    pj_status_t status;\n\n    if (spx_factory.pool != NULL) {\n\t/* Already initialized. */\n\treturn PJ_SUCCESS;\n    }\n\n    /* Get defaults */\n    if (quality < 0) quality = PJMEDIA_CODEC_SPEEX_DEFAULT_QUALITY;\n    if (complexity < 0) complexity = PJMEDIA_CODEC_SPEEX_DEFAULT_COMPLEXITY;\n\n    /* Validate quality & complexity */\n    PJ_ASSERT_RETURN(quality >= 0 && quality <= 10, PJ_EINVAL);\n    PJ_ASSERT_RETURN(complexity >= 1 && complexity <= 10, PJ_EINVAL);\n\n    /* Create Speex codec factory. */\n    spx_factory.base.op = &spx_factory_op;\n    spx_factory.base.factory_data = NULL;\n    spx_factory.endpt = endpt;\n\n    spx_factory.pool = pjmedia_endpt_create_pool(endpt, \"speex\", \n\t\t\t\t\t\t       4000, 4000);\n    if (!spx_factory.pool)\n\treturn PJ_ENOMEM;\n\n    pj_list_init(&spx_factory.codec_list);\n\n    /* Create mutex. */\n    status = pj_mutex_create_simple(spx_factory.pool, \"speex\", \n\t\t\t\t    &spx_factory.mutex);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Initialize default Speex parameter. */\n    spx_factory.speex_param[PARAM_NB].enabled = \n\t((options & PJMEDIA_SPEEX_NO_NB) == 0);\n    spx_factory.speex_param[PARAM_NB].pt = PJMEDIA_RTP_PT_SPEEX_NB;\n    spx_factory.speex_param[PARAM_NB].mode = speex_lib_get_mode(SPEEX_MODEID_NB);\n    spx_factory.speex_param[PARAM_NB].clock_rate = 8000;\n    spx_factory.speex_param[PARAM_NB].quality = quality;\n    spx_factory.speex_param[PARAM_NB].complexity = complexity;\n\n    spx_factory.speex_param[PARAM_WB].enabled = \n\t((options & PJMEDIA_SPEEX_NO_WB) == 0);\n    spx_factory.speex_param[PARAM_WB].pt = PJMEDIA_RTP_PT_SPEEX_WB;\n    spx_factory.speex_param[PARAM_WB].mode = speex_lib_get_mode(SPEEX_MODEID_WB);\n    spx_factory.speex_param[PARAM_WB].clock_rate = 16000;\n    spx_factory.speex_param[PARAM_WB].quality = quality;\n    spx_factory.speex_param[PARAM_WB].complexity = complexity;\n\n    spx_factory.speex_param[PARAM_UWB].enabled = \n\t((options & PJMEDIA_SPEEX_NO_UWB) == 0);\n    spx_factory.speex_param[PARAM_UWB].pt = PJMEDIA_RTP_PT_SPEEX_UWB;\n    spx_factory.speex_param[PARAM_UWB].mode = speex_lib_get_mode(SPEEX_MODEID_UWB);\n    spx_factory.speex_param[PARAM_UWB].clock_rate = 32000;\n    spx_factory.speex_param[PARAM_UWB].quality = quality;\n    spx_factory.speex_param[PARAM_UWB].complexity = complexity;\n\n    /* Somehow quality <=4 is broken in linux. */\n    if (quality <= 4 && quality >= 0) {\n\tPJ_LOG(5,(THIS_FILE, \"Adjusting quality to 5 for uwb\"));\n\tspx_factory.speex_param[PARAM_UWB].quality = 5;\n    }\n\n    /* Get codec framesize and avg bitrate for each mode. */\n    for (i=0; i<PJ_ARRAY_SIZE(spx_factory.speex_param); ++i) {\n\tstatus = get_speex_info(&spx_factory.speex_param[i]);\n    }\n\n    /* Get the codec manager. */\n    codec_mgr = pjmedia_endpt_get_codec_mgr(endpt);\n    if (!codec_mgr) {\n\tstatus = PJ_EINVALIDOP;\n\tgoto on_error;\n    }\n\n    /* Register codec factory to endpoint. */\n    status = pjmedia_codec_mgr_register_factory(codec_mgr, \n\t\t\t\t\t\t&spx_factory.base);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Done. */\n    return PJ_SUCCESS;\n\non_error:\n    pj_pool_release(spx_factory.pool);\n    spx_factory.pool = NULL;\n    return status;\n}\n\n\n/*\n * Initialize with default settings.\n */\nPJ_DEF(pj_status_t) pjmedia_codec_speex_init_default(pjmedia_endpt *endpt)\n{\n    return pjmedia_codec_speex_init(endpt, 0, -1, -1);\n}\n\n/*\n * Change the settings of Speex codec.\n */\nPJ_DEF(pj_status_t) pjmedia_codec_speex_set_param(unsigned clock_rate,\n\t\t\t\t\t\t  int quality,\n\t\t\t\t\t\t  int complexity)\n{\n    unsigned i;\n\n    /* Get defaults */\n    if (quality < 0) quality = PJMEDIA_CODEC_SPEEX_DEFAULT_QUALITY;\n    if (complexity < 0) complexity = PJMEDIA_CODEC_SPEEX_DEFAULT_COMPLEXITY;\n\n    /* Validate quality & complexity */\n    PJ_ASSERT_RETURN(quality >= 0 && quality <= 10, PJ_EINVAL);\n    PJ_ASSERT_RETURN(complexity >= 1 && complexity <= 10, PJ_EINVAL);\n\n    /* Apply the settings */\n    for (i=0; i<PJ_ARRAY_SIZE(spx_factory.speex_param); ++i) {\n\tif (spx_factory.speex_param[i].clock_rate == clock_rate) {\n\t    pj_status_t status;\n\n\t    spx_factory.speex_param[i].quality = quality;\n\t    spx_factory.speex_param[i].complexity = complexity;\n\n\t    /* Somehow quality<=4 is broken in linux. */\n\t    if (i == PARAM_UWB && quality <= 4 && quality >= 0) {\n\t\tPJ_LOG(5,(THIS_FILE, \"Adjusting quality to 5 for uwb\"));\n\t\tspx_factory.speex_param[PARAM_UWB].quality = 5;\n\t    }\n\n\t    status = get_speex_info(&spx_factory.speex_param[i]);\n\n\t    return status;\n\t}\n    }\n\n    return PJ_EINVAL;\n}\n\n/*\n * Unregister Speex codec factory from pjmedia endpoint and deinitialize\n * the Speex codec library.\n */\nPJ_DEF(pj_status_t) pjmedia_codec_speex_deinit(void)\n{\n    pjmedia_codec_mgr *codec_mgr;\n    pj_status_t status;\n\n    if (spx_factory.pool == NULL) {\n\t/* Already deinitialized */\n\treturn PJ_SUCCESS;\n    }\n\n    pj_mutex_lock(spx_factory.mutex);\n\n    /* We don't want to deinit if there's outstanding codec. */\n    /* This is silly, as we'll always have codec in the list if\n       we ever allocate a codec! A better behavior maybe is to \n       deallocate all codecs in the list.\n    if (!pj_list_empty(&spx_factory.codec_list)) {\n\tpj_mutex_unlock(spx_factory.mutex);\n\treturn PJ_EBUSY;\n    }\n    */\n\n    /* Get the codec manager. */\n    codec_mgr = pjmedia_endpt_get_codec_mgr(spx_factory.endpt);\n    if (!codec_mgr) {\n\tpj_pool_release(spx_factory.pool);\n\tspx_factory.pool = NULL;\n\treturn PJ_EINVALIDOP;\n    }\n\n    /* Unregister Speex codec factory. */\n    status = pjmedia_codec_mgr_unregister_factory(codec_mgr,\n\t\t\t\t\t\t  &spx_factory.base);\n    \n    /* Destroy mutex. */\n    pj_mutex_unlock(spx_factory.mutex);\n    pj_mutex_destroy(spx_factory.mutex);\n    spx_factory.mutex = NULL;\n\n    /* Destroy pool. */\n    pj_pool_release(spx_factory.pool);\n    spx_factory.pool = NULL;\n\n    return status;\n}\n\n/* \n * Check if factory can allocate the specified codec. \n */\nstatic pj_status_t spx_test_alloc( pjmedia_codec_factory *factory, \n\t\t\t\t   const pjmedia_codec_info *info )\n{\n    const pj_str_t speex_tag = { \"speex\", 5};\n    unsigned i;\n\n    PJ_UNUSED_ARG(factory);\n\n    /* Type MUST be audio. */\n    if (info->type != PJMEDIA_TYPE_AUDIO)\n\treturn PJMEDIA_CODEC_EUNSUP;\n\n    /* Check encoding name. */\n    if (pj_stricmp(&info->encoding_name, &speex_tag) != 0)\n\treturn PJMEDIA_CODEC_EUNSUP;\n\n    /* Check clock-rate */\n    for (i=0; i<PJ_ARRAY_SIZE(spx_factory.speex_param); ++i) {\n\tif (info->clock_rate == spx_factory.speex_param[i].clock_rate) {\n\t    /* Okay, let's Speex! */\n\t    return PJ_SUCCESS;\n\t}\n    }\n\n    \n    /* Unsupported, or mode is disabled. */\n    return PJMEDIA_CODEC_EUNSUP;\n}\n\n/*\n * Generate default attribute.\n */\nstatic pj_status_t spx_default_attr (pjmedia_codec_factory *factory, \n\t\t\t\t      const pjmedia_codec_info *id, \n\t\t\t\t      pjmedia_codec_param *attr )\n{\n\n    PJ_ASSERT_RETURN(factory==&spx_factory.base, PJ_EINVAL);\n\n    pj_bzero(attr, sizeof(pjmedia_codec_param));\n    attr->info.pt = (pj_uint8_t)id->pt;\n    attr->info.channel_cnt = 1;\n\n    if (id->clock_rate <= 8000) {\n\tattr->info.clock_rate = spx_factory.speex_param[PARAM_NB].clock_rate;\n\tattr->info.avg_bps = spx_factory.speex_param[PARAM_NB].bitrate;\n\tattr->info.max_bps = spx_factory.speex_param[PARAM_NB].max_bitrate;\n\n    } else if (id->clock_rate <= 16000) {\n\tattr->info.clock_rate = spx_factory.speex_param[PARAM_WB].clock_rate;\n\tattr->info.avg_bps = spx_factory.speex_param[PARAM_WB].bitrate;\n\tattr->info.max_bps = spx_factory.speex_param[PARAM_WB].max_bitrate;\n\n    } else {\n\t/* Wow.. somebody is doing ultra-wideband. Cool...! */\n\tattr->info.clock_rate = spx_factory.speex_param[PARAM_UWB].clock_rate;\n\tattr->info.avg_bps = spx_factory.speex_param[PARAM_UWB].bitrate;\n\tattr->info.max_bps = spx_factory.speex_param[PARAM_UWB].max_bitrate;\n    }\n\n    attr->info.pcm_bits_per_sample = 16;\n    attr->info.frm_ptime = 20;\n    attr->info.pt = (pj_uint8_t)id->pt;\n\n    attr->setting.frm_per_pkt = 1;\n\n    /* Default flags. */\n    attr->setting.cng = 1;\n    attr->setting.plc = 1;\n    attr->setting.penh =1 ;\n    attr->setting.vad = 1;\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Enum codecs supported by this factory (i.e. only Speex!).\n */\nstatic pj_status_t spx_enum_codecs(pjmedia_codec_factory *factory, \n\t\t\t\t    unsigned *count, \n\t\t\t\t    pjmedia_codec_info codecs[])\n{\n    unsigned max;\n    int i;  /* Must be signed */\n\n    PJ_UNUSED_ARG(factory);\n    PJ_ASSERT_RETURN(codecs && *count > 0, PJ_EINVAL);\n\n    max = *count;\n    *count = 0;\n\n    /*\n     * We return three codecs here, and in this order:\n     *\t- ultra-wideband, wideband, and narrowband.\n     */\n    for (i=PJ_ARRAY_SIZE(spx_factory.speex_param)-1; i>=0 && *count<max; --i) {\n\n\tif (!spx_factory.speex_param[i].enabled)\n\t    continue;\n\n\tpj_bzero(&codecs[*count], sizeof(pjmedia_codec_info));\n\tcodecs[*count].encoding_name = pj_str(\"speex\");\n\tcodecs[*count].pt = spx_factory.speex_param[i].pt;\n\tcodecs[*count].type = PJMEDIA_TYPE_AUDIO;\n\tcodecs[*count].clock_rate = spx_factory.speex_param[i].clock_rate;\n\tcodecs[*count].channel_cnt = 1;\n\n\t++*count;\n    }\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Allocate a new Speex codec instance.\n */\nstatic pj_status_t spx_alloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t    const pjmedia_codec_info *id,\n\t\t\t\t    pjmedia_codec **p_codec)\n{\n    pjmedia_codec *codec;\n    struct spx_private *spx;\n\n    PJ_ASSERT_RETURN(factory && id && p_codec, PJ_EINVAL);\n    PJ_ASSERT_RETURN(factory == &spx_factory.base, PJ_EINVAL);\n\n\n    pj_mutex_lock(spx_factory.mutex);\n\n    /* Get free nodes, if any. */\n    if (!pj_list_empty(&spx_factory.codec_list)) {\n\tcodec = spx_factory.codec_list.next;\n\tpj_list_erase(codec);\n    } else {\n\tcodec = PJ_POOL_ZALLOC_T(spx_factory.pool, pjmedia_codec);\n\tPJ_ASSERT_RETURN(codec != NULL, PJ_ENOMEM);\n\tcodec->op = &spx_op;\n\tcodec->factory = factory;\n\tcodec->codec_data = pj_pool_alloc(spx_factory.pool,\n\t\t\t\t\t  sizeof(struct spx_private));\n    }\n\n    pj_mutex_unlock(spx_factory.mutex);\n\n    spx = (struct spx_private*) codec->codec_data;\n    spx->enc = NULL;\n    spx->dec = NULL;\n\n    if (id->clock_rate <= 8000)\n\tspx->param_id = PARAM_NB;\n    else if (id->clock_rate <= 16000)\n\tspx->param_id = PARAM_WB;\n    else\n\tspx->param_id = PARAM_UWB;\n\n    *p_codec = codec;\n    return PJ_SUCCESS;\n}\n\n/*\n * Free codec.\n */\nstatic pj_status_t spx_dealloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t      pjmedia_codec *codec )\n{\n    struct spx_private *spx;\n\n    PJ_ASSERT_RETURN(factory && codec, PJ_EINVAL);\n    PJ_ASSERT_RETURN(factory == &spx_factory.base, PJ_EINVAL);\n\n    /* Close codec, if it's not closed. */\n    spx = (struct spx_private*) codec->codec_data;\n    if (spx->enc != NULL || spx->dec != NULL) {\n\tspx_codec_close(codec);\n    }\n\n    /* Put in the free list. */\n    pj_mutex_lock(spx_factory.mutex);\n    pj_list_push_front(&spx_factory.codec_list, codec);\n    pj_mutex_unlock(spx_factory.mutex);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Init codec.\n */\nstatic pj_status_t spx_codec_init( pjmedia_codec *codec, \n\t\t\t\t   pj_pool_t *pool )\n{\n    PJ_UNUSED_ARG(codec);\n    PJ_UNUSED_ARG(pool);\n    return PJ_SUCCESS;\n}\n\n/*\n * Open codec.\n */\nstatic pj_status_t spx_codec_open( pjmedia_codec *codec, \n\t\t\t\t   pjmedia_codec_param *attr )\n{\n    struct spx_private *spx;\n    int id, tmp;\n\n    spx = (struct spx_private*) codec->codec_data;\n    id = spx->param_id;\n\n    /* \n     * Create and initialize encoder. \n     */\n    spx->enc = speex_encoder_init(spx_factory.speex_param[id].mode);\n    if (!spx->enc)\n\treturn PJMEDIA_CODEC_EFAILED;\n    speex_bits_init(&spx->enc_bits);\n\n    /* Set the quality*/\n    if (spx_factory.speex_param[id].quality != -1) {\n\tspeex_encoder_ctl(spx->enc, SPEEX_SET_QUALITY, \n\t\t\t  &spx_factory.speex_param[id].quality);\n    }\n\n    /* Sampling rate. */\n    tmp = attr->info.clock_rate;\n    speex_encoder_ctl(spx->enc, SPEEX_SET_SAMPLING_RATE, \n\t\t      &spx_factory.speex_param[id].clock_rate);\n\n    /* VAD */\n    tmp = (attr->setting.vad != 0);\n    speex_encoder_ctl(spx->enc, SPEEX_SET_VAD, &tmp);\n    speex_encoder_ctl(spx->enc, SPEEX_SET_DTX, &tmp);\n\n    /* Complexity */\n    if (spx_factory.speex_param[id].complexity != -1) {\n\tspeex_encoder_ctl(spx->enc, SPEEX_SET_COMPLEXITY, \n\t\t\t  &spx_factory.speex_param[id].complexity);\n    }\n\n    /* \n     * Create and initialize decoder. \n     */\n    spx->dec = speex_decoder_init(spx_factory.speex_param[id].mode);\n    if (!spx->dec) {\n\tspx_codec_close(codec);\n\treturn PJMEDIA_CODEC_EFAILED;\n    }\n    speex_bits_init(&spx->dec_bits);\n\n    /* Sampling rate. */\n    speex_decoder_ctl(spx->dec, SPEEX_SET_SAMPLING_RATE, \n\t\t      &spx_factory.speex_param[id].clock_rate);\n\n    /* PENH */\n    tmp = attr->setting.penh;\n    speex_decoder_ctl(spx->dec, SPEEX_SET_ENH, &tmp);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Close codec.\n */\nstatic pj_status_t spx_codec_close( pjmedia_codec *codec )\n{\n    struct spx_private *spx;\n\n    spx = (struct spx_private*) codec->codec_data;\n\n    /* Destroy encoder*/\n    if (spx->enc) {\n\tspeex_encoder_destroy( spx->enc );\n\tspx->enc = NULL;\n\tspeex_bits_destroy( &spx->enc_bits );\n    }\n\n    /* Destroy decoder */\n    if (spx->dec) {\n\tspeex_decoder_destroy( spx->dec);\n\tspx->dec = NULL;\n\tspeex_bits_destroy( &spx->dec_bits );\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Modify codec settings.\n */\nstatic pj_status_t  spx_codec_modify(pjmedia_codec *codec, \n\t\t\t\t     const pjmedia_codec_param *attr )\n{\n    struct spx_private *spx;\n    int tmp;\n\n    spx = (struct spx_private*) codec->codec_data;\n\n    /* VAD */\n    tmp = (attr->setting.vad != 0);\n    speex_encoder_ctl(spx->enc, SPEEX_SET_VAD, &tmp);\n    speex_encoder_ctl(spx->enc, SPEEX_SET_DTX, &tmp);\n\n    /* PENH */\n    tmp = attr->setting.penh;\n    speex_decoder_ctl(spx->dec, SPEEX_SET_ENH, &tmp);\n\n    return PJ_SUCCESS;\n}\n\n#if 0\n#  define TRACE__(args)\t    PJ_LOG(5,args)\n#else\n#  define TRACE__(args)\n#endif\n\n#undef THIS_FUNC\n#define THIS_FUNC \"speex_get_next_frame\"\n\n#define NB_SUBMODES 16\n#define NB_SUBMODE_BITS 4\n\n#define SB_SUBMODES 8\n#define SB_SUBMODE_BITS 3\n\n/* This function will iterate frames & submodes in the Speex bits.\n * Returns 0 if a frame found, otherwise returns -1.\n */\nstatic int speex_get_next_frame(SpeexBits *bits)\n{\n    static const int inband_skip_table[NB_SUBMODES] =\n       {1, 1, 4, 4, 4, 4, 4, 4, 8, 8, 16, 16, 32, 32, 64, 64 };\n    static const int wb_skip_table[SB_SUBMODES] =\n       {SB_SUBMODE_BITS+1, 36, 112, 192, 352, -1, -1, -1};\n\n    unsigned submode;\n    unsigned nb_count = 0;\n\n    while (speex_bits_remaining(bits) >= 5) {\n\tunsigned wb_count = 0;\n\tunsigned bit_ptr = bits->bitPtr;\n\tunsigned char_ptr = bits->charPtr;\n\n\t/* WB frame */\n\twhile ((speex_bits_remaining(bits) >= 4)\n\t    && speex_bits_unpack_unsigned(bits, 1))\n\t{\n\t    int advance;\n\n\t    submode = speex_bits_unpack_unsigned(bits, 3);\n\t    advance = wb_skip_table[submode];\n\t    if (advance < 0) {\n\t\tTRACE__((THIS_FUNC, \"Invalid mode encountered. \"\n\t\t\t \"The stream is corrupted.\"));\n\t\treturn -1;\n\t    } \n\t    TRACE__((THIS_FUNC, \"WB layer skipped: %d bits\", advance));\n\t    advance -= (SB_SUBMODE_BITS+1);\n\t    speex_bits_advance(bits, advance);\n\n\t    bit_ptr = bits->bitPtr;\n\t    char_ptr = bits->charPtr;\n\n\t    /* Consecutive subband frames may not exceed 2 frames */\n\t    if (++wb_count > 2)\n\t\treturn -1;\n\t}\n\n\t/* End of bits, return the frame */\n\tif (speex_bits_remaining(bits) < 4) {\n\t    TRACE__((THIS_FUNC, \"End of stream\"));\n\t    return 0;\n\t}\n\n\t/* Stop iteration, return the frame */\n\tif (nb_count > 0) {\n\t    bits->bitPtr = bit_ptr;\n\t    bits->charPtr = char_ptr;\n\t    return 0;\n\t}\n\n\t/* Get control bits */\n\tsubmode = speex_bits_unpack_unsigned(bits, 4);\n\tTRACE__((THIS_FUNC, \"Control bits: %d at %d\", \n\t\t submode, bits->charPtr*8+bits->bitPtr));\n\n\tif (submode == 15) {\n\t    TRACE__((THIS_FUNC, \"Found submode: terminator\"));\n\t    return -1;\n\t} else if (submode == 14) {\n\t    /* in-band signal; next 4 bits contain signal id */\n\t    submode = speex_bits_unpack_unsigned(bits, 4);\n\t    TRACE__((THIS_FUNC, \"Found submode: in-band %d bits\", \n\t\t     inband_skip_table[submode]));\n\t    speex_bits_advance(bits, inband_skip_table[submode]);\n\t} else if (submode == 13) {\n\t    /* user in-band; next 5 bits contain msg len */\n\t    submode = speex_bits_unpack_unsigned(bits, 5);\n\t    TRACE__((THIS_FUNC, \"Found submode: user-band %d bytes\", submode));\n\t    speex_bits_advance(bits, submode * 8);\n\t} else if (submode > 8) {\n\t    TRACE__((THIS_FUNC, \"Unknown sub-mode %d\", submode));\n\t    return -1;\n\t} else {\n\t    /* NB frame */\n\t    int advance = submode;\n\t    speex_mode_query(&speex_nb_mode, SPEEX_SUBMODE_BITS_PER_FRAME, &advance);\n\t    if (advance < 0) {\n\t\tTRACE__((THIS_FUNC, \"Invalid mode encountered. \"\n\t\t\t \"The stream is corrupted.\"));\n\t\treturn -1;\n\t    }\n\t    TRACE__((THIS_FUNC, \"Submode %d: %d bits\", submode, advance));\n\t    advance -= (NB_SUBMODE_BITS+1);\n\t    speex_bits_advance(bits, advance);\n\n\t    ++nb_count;\n\t}\n    }\n\n    return 0;\n}\n\n\n/*\n * Get frames in the packet.\n */\nstatic pj_status_t  spx_codec_parse( pjmedia_codec *codec,\n\t\t\t\t     void *pkt,\n\t\t\t\t     pj_size_t pkt_size,\n\t\t\t\t     const pj_timestamp *ts,\n\t\t\t\t     unsigned *frame_cnt,\n\t\t\t\t     pjmedia_frame frames[])\n{\n    struct spx_private *spx = (struct spx_private*) codec->codec_data;\n    unsigned samples_per_frame;\n    unsigned count = 0;\n    int char_ptr = 0;\n    int bit_ptr = 0;\n\n    samples_per_frame=spx_factory.speex_param[spx->param_id].samples_per_frame;\n\n    /* Copy the data into the speex bit-stream */\n    speex_bits_read_from(&spx->dec_bits, (char*)pkt, (int)pkt_size);\n\n    while (speex_get_next_frame(&spx->dec_bits) == 0 && \n\t   spx->dec_bits.charPtr != char_ptr)\n    {\n\tframes[count].buf = (char*)pkt + char_ptr;\n\t/* Bit info contains start bit offset of the frame */\n\tframes[count].bit_info = bit_ptr;\n\tframes[count].type = PJMEDIA_FRAME_TYPE_AUDIO;\n\tframes[count].timestamp.u64 = ts->u64 +\n\t\t\t\t      (pj_uint64_t)count * samples_per_frame;\n\tframes[count].size = spx->dec_bits.charPtr - char_ptr;\n\tif (spx->dec_bits.bitPtr)\n\t    ++frames[count].size;\n\n\tbit_ptr = spx->dec_bits.bitPtr;\n\tchar_ptr = spx->dec_bits.charPtr;\n\n\t++count;\n    }\n\n    *frame_cnt = count;\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Encode frames.\n */\nstatic pj_status_t spx_codec_encode( pjmedia_codec *codec, \n\t\t\t\t     const struct pjmedia_frame *input,\n\t\t\t\t     unsigned output_buf_len, \n\t\t\t\t     struct pjmedia_frame *output)\n{\n    struct spx_private *spx;\n    unsigned samples_per_frame;\n    int tx = 0;\n    spx_int16_t *pcm_in = (spx_int16_t*)input->buf;\n    pj_size_t nsamples;\n\n    spx = (struct spx_private*) codec->codec_data;\n\n    if (input->type != PJMEDIA_FRAME_TYPE_AUDIO) {\n\toutput->size = 0;\n\toutput->buf = NULL;\n\toutput->timestamp = input->timestamp;\n\toutput->type = input->type;\n\treturn PJ_SUCCESS;\n    }\n\n    nsamples = input->size >> 1;\n    samples_per_frame=spx_factory.speex_param[spx->param_id].samples_per_frame;\n\n    PJ_ASSERT_RETURN(nsamples % samples_per_frame == 0, \n\t\t     PJMEDIA_CODEC_EPCMFRMINLEN);\n\n    /* Flush all the bits in the struct so we can encode a new frame */\n    speex_bits_reset(&spx->enc_bits);\n\n    /* Encode the frames */\n    while (nsamples >= samples_per_frame) {\n\ttx += speex_encode_int(spx->enc, pcm_in, &spx->enc_bits);\n\tpcm_in += samples_per_frame;\n\tnsamples -= samples_per_frame;\n    }\n\n    /* Check if we need not to transmit the frame (DTX) */\n    if (tx == 0) {\n\toutput->buf = NULL;\n\toutput->size = 0;\n\toutput->timestamp.u64 = input->timestamp.u64;\n\toutput->type = PJMEDIA_FRAME_TYPE_NONE;\n\treturn PJ_SUCCESS;\n    }\n\n    /* Check size. */\n    pj_assert(speex_bits_nbytes(&spx->enc_bits) <= (int)output_buf_len);\n\n    /* Copy the bits to an array of char that can be written */\n    output->size = speex_bits_write(&spx->enc_bits, \n\t\t\t\t    (char*)output->buf, output_buf_len);\n    output->type = PJMEDIA_FRAME_TYPE_AUDIO;\n    output->timestamp = input->timestamp;\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Decode frame.\n */\nstatic pj_status_t spx_codec_decode( pjmedia_codec *codec, \n\t\t\t\t     const struct pjmedia_frame *input,\n\t\t\t\t     unsigned output_buf_len, \n\t\t\t\t     struct pjmedia_frame *output)\n{\n    struct spx_private *spx;\n    unsigned samples_per_frame;\n\n    spx = (struct spx_private*) codec->codec_data;\n    samples_per_frame=spx_factory.speex_param[spx->param_id].samples_per_frame;\n\n    PJ_ASSERT_RETURN(output_buf_len >= samples_per_frame << 1,\n\t\t     PJMEDIA_CODEC_EPCMTOOSHORT);\n\n    if (input->type != PJMEDIA_FRAME_TYPE_AUDIO) {\n\tpjmedia_zero_samples((pj_int16_t*)output->buf, samples_per_frame);\n\toutput->size = samples_per_frame << 1;\n\toutput->timestamp.u64 = input->timestamp.u64;\n\toutput->type = PJMEDIA_FRAME_TYPE_AUDIO;\n\treturn PJ_SUCCESS;\n    }\n\n    /* Copy the data into the bit-stream struct */\n    speex_bits_read_from(&spx->dec_bits, (char*)input->buf, (int)input->size);\n    \n    /* Set Speex dec_bits pointer to the start bit of the frame */\n    speex_bits_advance(&spx->dec_bits, input->bit_info);\n\n    /* Decode the data */\n    speex_decode_int(spx->dec, &spx->dec_bits, (spx_int16_t*)output->buf);\n\n    output->type = PJMEDIA_FRAME_TYPE_AUDIO;\n    output->size = samples_per_frame << 1;\n    output->timestamp.u64 = input->timestamp.u64;\n\n    return PJ_SUCCESS;\n}\n\n/* \n * Recover lost frame.\n */\nstatic pj_status_t  spx_codec_recover(pjmedia_codec *codec, \n\t\t\t\t      unsigned output_buf_len, \n\t\t\t\t      struct pjmedia_frame *output)\n{\n    struct spx_private *spx;\n    unsigned count;\n\n    /* output_buf_len is unreferenced when building in Release mode */\n    PJ_UNUSED_ARG(output_buf_len);\n\n    spx = (struct spx_private*) codec->codec_data;\n\n    count = spx_factory.speex_param[spx->param_id].clock_rate * 20 / 1000;\n    pj_assert(count <= output_buf_len/2);\n\n    /* Recover packet loss */\n    speex_decode_int(spx->dec, NULL, (spx_int16_t*) output->buf);\n\n    output->size = count * 2;\n\n    return PJ_SUCCESS;\n}\n\n\n#endif\t/* PJMEDIA_HAS_SPEEX_CODEC */\n", "/* $Id$ */\n/* \n * Copyright (C) 2019 Teluu Inc. (http://www.teluu.com)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/vid_conf.h>\n#include <pjmedia/clock.h>\n#include <pjmedia/converter.h>\n#include <pjmedia/errno.h>\n#include <pj/array.h>\n#include <pj/log.h>\n#include <pj/os.h>\n\n#if defined(PJMEDIA_HAS_VIDEO) && (PJMEDIA_HAS_VIDEO != 0)\n\n\n#define CONF_NAME\t\"vidconf\"\n#define CONF_SIGN\tPJMEDIA_SIG_VID_CONF\n\n/* If set, conf will stop clock when there is no ports connection. However,\n * this may cause stuck if port remove/disconnect is called from the clock\n * callback. So better disable this for now.\n */\n#define AUTO_STOP_CLOCK 0\n\n/* Maximum number of consecutive errors that will only be printed once. */\n#define MAX_ERR_COUNT 150\n\n/* Clockrate for video timestamp unit */\n#define TS_CLOCK_RATE\t90000\n\n#define THIS_FILE\t\"vid_conf.c\"\n#define TRACE_(x)\tPJ_LOG(5,x)\n\n\n/*\n * Conference bridge.\n */\nstruct pjmedia_vid_conf\n{\n    pjmedia_vid_conf_setting opt;\t/**< Settings.\t\t\t    */\n    unsigned\t\t  port_cnt;\t/**< Current number of ports.\t    */\n    unsigned\t\t  connect_cnt;\t/**< Total number of connections    */\n    pj_mutex_t\t\t *mutex;\t/**< Conference mutex.\t\t    */\n    struct vconf_port\t**ports;\t/**< Array of ports.\t\t    */\n    pjmedia_clock\t *clock;\t/**< Clock.\t\t\t    */\n};\n\n\n/*\n * Rendering state: converter, layout settings, etc.\n */\ntypedef struct render_state\n{\n    pjmedia_format_id\tsrc_fmt_id;\t/**< Source format ID.\t\t    */\n    pjmedia_rect_size\tsrc_frame_size;\t/**< Source frame size.\t\t    */\n    pjmedia_rect\tsrc_rect;\t/**< Source region to be rendered.  */\n\n    pjmedia_format_id\tdst_fmt_id;\t/**< Destination format ID.\t    */\n    pjmedia_rect_size\tdst_frame_size;\t/**< Destination frame size.\t    */\n    pjmedia_rect\tdst_rect;\t/**< Destination region.\t    */\n\n    pjmedia_converter\t*converter;\t/**< Converter.\t\t\t    */\n\n} render_state;\n\n\n/*\n * Conference bridge port.\n */\ntypedef struct vconf_port\n{\n    pj_pool_t\t\t*pool;\t\t/**< Pool.\t\t\t    */\n    unsigned\t\t idx;\t\t/**< Port index.\t\t    */\n    pj_str_t\t\t name;\t\t/**< Port name.\t\t\t    */\n    pjmedia_port\t*port;\t\t/**< Video port.\t\t    */\n    pjmedia_format\t format;\t/**< Copy of port format info.\t    */\n    pj_uint32_t\t\t ts_interval;\t/**< Port put/get interval.\t    */\n    pj_timestamp\t ts_next;\t/**< Time for next put/get_frame(). */\n    void\t\t*get_buf;\t/**< Buffer for get_frame().\t    */\n    pj_size_t\t\t get_buf_size;\t/**< Buffer size for get_frame().   */\n    void\t\t*put_buf;\t/**< Buffer for put_frame().\t    */\n    pj_size_t\t\t put_buf_size;\t/**< Buffer size for put_frame().   */\n\n    unsigned\t\t listener_cnt;\t/**< Number of listeners.\t    */\n    unsigned\t\t*listener_slots;/**< Array of listeners (for info). */\n\n    unsigned\t\t transmitter_cnt;/**<Number of transmitters.\t    */\n    unsigned\t\t*transmitter_slots;/**< Array of transmitters.\t    */\n    pj_pool_t\t       **render_pool;\t/**< Array of pool for render state */\n    render_state       **render_states;\t/**< Array of render_state (one for\n\t\t\t\t\t     each transmitter).\t\t    */\n\n    pj_status_t\t\t  last_err;\t/**< Last error status.\t\t    */\n    unsigned\t\t  last_err_cnt;\t/**< Last error count.\t\t    */\n} vconf_port;\n\n\n/* Prototypes */\nstatic void on_clock_tick(const pj_timestamp *ts, void *user_data);\nstatic pj_status_t render_src_frame(vconf_port *src, vconf_port *sink,\n\t\t\t\t    unsigned transmitter_idx);\nstatic void update_render_state(pjmedia_vid_conf *vid_conf, vconf_port *cp);\nstatic void cleanup_render_state(vconf_port *cp,\n\t\t\t\t unsigned transmitter_idx);\n\n\n/*\n * Initialize video conference settings with default values.\n */\nPJ_DEF(void) pjmedia_vid_conf_setting_default(pjmedia_vid_conf_setting *opt)\n{\n    pj_bzero(opt, sizeof(*opt));\n    opt->max_slot_cnt = 32;\n    opt->frame_rate = 60;\n}\n\n\n/*\n * Create a video conference bridge.\n */\nPJ_DEF(pj_status_t) pjmedia_vid_conf_create(\n\t\t\t\t\tpj_pool_t *pool,\n\t\t\t\t\tconst pjmedia_vid_conf_setting *opt,\n\t\t\t\t\tpjmedia_vid_conf **p_vid_conf)\n{\n    pjmedia_vid_conf *vid_conf;\n    pjmedia_clock_param clock_param;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(pool && p_vid_conf, PJ_EINVAL);\n\n    /* Allocate conf structure */\n    vid_conf = PJ_POOL_ZALLOC_T(pool, pjmedia_vid_conf);\n    PJ_ASSERT_RETURN(vid_conf, PJ_ENOMEM);\n\n    /* Init settings */\n    if (opt) {\n\tvid_conf->opt = *opt;\n    } else {\n\tpjmedia_vid_conf_setting_default(&vid_conf->opt);\n    }\n\n    /* Allocate ports */\n    vid_conf->ports = (vconf_port**)\n\t\t      pj_pool_zalloc(pool, vid_conf->opt.max_slot_cnt *\n\t\t\t\t\t   sizeof(vconf_port*));\n    PJ_ASSERT_RETURN(vid_conf->ports, PJ_ENOMEM);\n\n    /* Create mutex */\n    status = pj_mutex_create_recursive(pool, CONF_NAME, &vid_conf->mutex);\n    if (status != PJ_SUCCESS) {\n\tpjmedia_vid_conf_destroy(vid_conf);\n\treturn status;\n    }\n\n    /* Create clock */\n    pj_bzero(&clock_param, sizeof(clock_param));\n    clock_param.clock_rate = TS_CLOCK_RATE;\n    clock_param.usec_interval = 1000000 / vid_conf->opt.frame_rate;\n    status = pjmedia_clock_create2(pool, &clock_param, 0, &on_clock_tick,\n\t\t\t\t   vid_conf, &vid_conf->clock);\n    if (status != PJ_SUCCESS) {\n\tpjmedia_vid_conf_destroy(vid_conf);\n\treturn status;\n    }\n\n    /* Done */\n    *p_vid_conf = vid_conf;\n\n    PJ_LOG(5,(THIS_FILE, \"Created video conference bridge with %d ports\",\n\t      vid_conf->opt.max_slot_cnt));\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Destroy video conference bridge.\n */\nPJ_DEF(pj_status_t) pjmedia_vid_conf_destroy(pjmedia_vid_conf *vid_conf)\n{\n    unsigned i;\n\n    PJ_ASSERT_RETURN(vid_conf, PJ_EINVAL);\n\n    /* Destroy clock */\n    if (vid_conf->clock) {\n\tpjmedia_clock_destroy(vid_conf->clock);\n\tvid_conf->clock = NULL;\n    }\n\n    /* Remove any registered ports (at least to cleanup their pool) */\n    for (i=0; i < vid_conf->opt.max_slot_cnt; ++i) {\n\tpjmedia_vid_conf_remove_port(vid_conf, i);\n    }\n\n    /* Destroy mutex */\n    if (vid_conf->mutex) {\n\tpj_mutex_destroy(vid_conf->mutex);\n\tvid_conf->mutex = NULL;\n    }\n\n    PJ_LOG(5,(THIS_FILE, \"Video conference bridge destroyed\"));\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Add a media port to the video conference bridge.\n */\nPJ_DEF(pj_status_t) pjmedia_vid_conf_add_port( pjmedia_vid_conf *vid_conf,\n\t\t\t\t\t       pj_pool_t *parent_pool,\n\t\t\t\t\t       pjmedia_port *port,\n\t\t\t\t\t       const pj_str_t *name,\n\t\t\t\t\t       void *opt,\n\t\t\t\t\t       unsigned *p_slot)\n{\n    pj_pool_t *pool;\n    vconf_port *cport;\n    unsigned index;\n\n    PJ_ASSERT_RETURN(vid_conf && parent_pool && port, PJ_EINVAL);\n    PJ_ASSERT_RETURN(port->info.fmt.type==PJMEDIA_TYPE_VIDEO &&\n\t\t     port->info.fmt.detail_type==PJMEDIA_FORMAT_DETAIL_VIDEO,\n\t\t     PJ_EINVAL);\n    PJ_UNUSED_ARG(opt);\n\n    /* If name is not specified, use the port's name */\n    if (!name)\n\tname = &port->info.name;\n\n    pj_mutex_lock(vid_conf->mutex);\n\n    if (vid_conf->port_cnt >= vid_conf->opt.max_slot_cnt) {\n\tpj_assert(!\"Too many ports\");\n\tpj_mutex_unlock(vid_conf->mutex);\n\treturn PJ_ETOOMANY;\n    }\n\n    /* Find empty port in the conference bridge. */\n    for (index=0; index < vid_conf->opt.max_slot_cnt; ++index) {\n\tif (vid_conf->ports[index] == NULL)\n\t    break;\n    }\n    pj_assert(index != vid_conf->opt.max_slot_cnt);\n\n    /* Create pool */\n    pool = pj_pool_create(parent_pool->factory, name->ptr, 500, 500, NULL);\n    PJ_ASSERT_RETURN(pool, PJ_ENOMEM);\n\n    /* Create port. */\n    cport = PJ_POOL_ZALLOC_T(pool, vconf_port);\n    PJ_ASSERT_RETURN(cport, PJ_ENOMEM);\n\n    /* Set pool, port, index, and name */\n    cport->pool = pool;\n    cport->port = port;\n    cport->format = port->info.fmt;\n    cport->idx  = index;\n    pj_strdup_with_null(pool, &cport->name, name);\n\n    /* Init put/get_frame() intervals */\n    {\n\tpjmedia_ratio *fps = &port->info.fmt.det.vid.fps;\n\tpj_uint32_t vconf_interval = (pj_uint32_t)\n\t\t\t\t     (TS_CLOCK_RATE * 1.0 /\n\t\t\t\t     vid_conf->opt.frame_rate);\n\tcport->ts_interval = (pj_uint32_t)(TS_CLOCK_RATE * 1.0 /\n\t\t\t\t\t   fps->num * fps->denum);\n\n\t/* Normalize the interval */\n\tif (cport->ts_interval < vconf_interval) {\n\t    cport->ts_interval = vconf_interval;\n\t    PJ_LOG(3,(THIS_FILE, \"Warning: frame rate of port %s is higher \"\n\t\t\t\t \"than video conference bridge (%d > %d)\",\n\t\t\t\t name->ptr, (int)(fps->num/fps->denum),\n\t\t\t\t vid_conf->opt.frame_rate));\n\t}\n    }\n\n    /* Allocate buffer for put/get_frame() */\n    {\n\tconst pjmedia_video_format_info *vfi;\n\tpjmedia_video_apply_fmt_param vafp;\n\tpj_status_t status;\n\n\tvfi = pjmedia_get_video_format_info(NULL, port->info.fmt.id);\n\tif (!vfi) {\n\t    PJ_LOG(4,(THIS_FILE, \"pjmedia_vid_conf_add_port(): \"\n\t\t\t\t \"unrecognized format %04X\",\n\t\t\t\t port->info.fmt.id));\n\t    return PJMEDIA_EBADFMT;\n\t}\n\n\tpj_bzero(&vafp, sizeof(vafp));\n\tvafp.size = port->info.fmt.det.vid.size;\n\tstatus = (*vfi->apply_fmt)(vfi, &vafp);\n\tif (status != PJ_SUCCESS) {\n\t    PJ_LOG(4,(THIS_FILE, \"pjmedia_vid_conf_add_port(): \"\n\t\t\t\t \"Failed to apply format %04X\",\n\t\t\t\t port->info.fmt.id));\n\t    return status;\n\t}\n\tif (port->put_frame) {\n\t    cport->put_buf_size = vafp.framebytes;\n\t    cport->put_buf = pj_pool_zalloc(cport->pool, cport->put_buf_size);\n\t}\n\tif (port->get_frame) {\n\t    cport->get_buf_size = vafp.framebytes;\n\t    cport->get_buf = pj_pool_zalloc(cport->pool, cport->get_buf_size);\n\t}\n    }\n\n    /* Create listener array */\n    cport->listener_slots = (unsigned*)\n\t\t\t    pj_pool_zalloc(pool,\n\t\t\t\t\t   vid_conf->opt.max_slot_cnt *\n\t\t\t\t\t   sizeof(unsigned));\n    PJ_ASSERT_RETURN(cport->listener_slots, PJ_ENOMEM);\n\n    /* Create transmitter array */\n    cport->transmitter_slots = (unsigned*)\n\t\t\t       pj_pool_zalloc(pool,\n\t\t\t\t\t      vid_conf->opt.max_slot_cnt *\n\t\t\t\t\t      sizeof(unsigned));\n    PJ_ASSERT_RETURN(cport->transmitter_slots, PJ_ENOMEM);\n\n    /* Create pointer-to-render_state array */\n    cport->render_states = (render_state**)\n\t\t\t   pj_pool_zalloc(pool,\n\t\t\t\t\t  vid_conf->opt.max_slot_cnt *\n\t\t\t\t\t  sizeof(render_state*));\n    PJ_ASSERT_RETURN(cport->render_states, PJ_ENOMEM);\n\n    /* Create pointer-to-render-pool array */\n    cport->render_pool = (pj_pool_t**)\n\t\t\t pj_pool_zalloc(pool,\n\t\t\t\t\tvid_conf->opt.max_slot_cnt *\n\t\t\t\t\tsizeof(pj_pool_t*));\n    PJ_ASSERT_RETURN(cport->render_pool, PJ_ENOMEM);\n\n    /* Register the conf port. */\n    vid_conf->ports[index] = cport;\n    vid_conf->port_cnt++;\n\n    PJ_LOG(4,(THIS_FILE,\"Added port %d (%.*s)\",\n\t      index, (int)cport->name.slen, cport->name.ptr));\n\n    pj_mutex_unlock(vid_conf->mutex);\n\n    /* Done. */\n    if (p_slot) {\n\t*p_slot = index;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Remove a media port from the video conference bridge.\n */\nPJ_DEF(pj_status_t) pjmedia_vid_conf_remove_port( pjmedia_vid_conf *vid_conf,\n\t\t\t\t\t\t  unsigned slot)\n{\n    vconf_port *cport;\n\n    PJ_ASSERT_RETURN(vid_conf && slot<vid_conf->opt.max_slot_cnt, PJ_EINVAL);\n\n    pj_mutex_lock(vid_conf->mutex);\n\n    /* Port must be valid. */\n    cport = vid_conf->ports[slot];\n    if (cport == NULL) {\n\tpj_mutex_unlock(vid_conf->mutex);\n\treturn PJ_EINVAL;\n    }\n\n    /* Disconnect slot -> listeners */\n    while (cport->listener_cnt) {\n\tpjmedia_vid_conf_disconnect_port(vid_conf, slot,\n\t\t\t\t\t cport->listener_slots[0]);\n    }\n\n    /* Disconnect transmitters -> slot */\n    while (cport->transmitter_cnt) {\n\tpjmedia_vid_conf_disconnect_port(vid_conf,\n\t\t\t\t\t cport->transmitter_slots[0], slot);\n    }\n\n    /* Remove the port. */\n    vid_conf->ports[slot] = NULL;\n    --vid_conf->port_cnt;\n\n    PJ_LOG(4,(THIS_FILE,\"Removed port %d (%.*s)\",\n\t      slot, (int)cport->name.slen, cport->name.ptr));\n\n    /* Release pool */\n    pj_pool_safe_release(&cport->pool);\n\n    if (AUTO_STOP_CLOCK && vid_conf->connect_cnt == 0) {\n\tpj_status_t status;\n\n\t/* Warning: will stuck if this is called from the clock thread */\n\tstatus = pjmedia_clock_stop(vid_conf->clock);\n\tif (status != PJ_SUCCESS) {\n\t    PJ_PERROR(4, (THIS_FILE, status, \"Failed to stop clock\"));\n\t    return status;\n\t}\n    }\n\n    pj_mutex_unlock(vid_conf->mutex);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get number of ports currently registered in the video conference bridge.\n */\nPJ_DEF(unsigned) pjmedia_vid_conf_get_port_count(pjmedia_vid_conf *vid_conf)\n{\n    return vid_conf->port_cnt;\n}\n\n\n/*\n * Enumerate occupied slots in the video conference bridge.\n */\nPJ_DEF(pj_status_t) pjmedia_vid_conf_enum_ports( pjmedia_vid_conf *vid_conf,\n\t\t\t\t\t\t unsigned slots[],\n\t\t\t\t\t\t unsigned *count)\n{\n    unsigned i, tmp_count=0;\n\n    PJ_ASSERT_RETURN(vid_conf && slots && count, PJ_EINVAL);\n\n    /* Lock mutex */\n    pj_mutex_lock(vid_conf->mutex);\n\n    for (i=0; i<vid_conf->opt.max_slot_cnt && tmp_count<*count; ++i) {\n\tif (!vid_conf->ports[i])\n\t    continue;\n\n\tslots[tmp_count++] = i;\n    }\n\n    /* Unlock mutex */\n    pj_mutex_unlock(vid_conf->mutex);\n\n    *count = tmp_count;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get port info.\n */\nPJ_DEF(pj_status_t) pjmedia_vid_conf_get_port_info(\n\t\t\t\t\t    pjmedia_vid_conf *vid_conf,\n\t\t\t\t\t    unsigned slot,\n\t\t\t\t\t    pjmedia_vid_conf_port_info *info)\n{\n    vconf_port *cp;\n\n    /* Check arguments */\n    PJ_ASSERT_RETURN(vid_conf && slot<vid_conf->opt.max_slot_cnt, PJ_EINVAL);\n\n    /* Lock mutex */\n    pj_mutex_lock(vid_conf->mutex);\n\n    /* Port must be valid. */\n    cp = vid_conf->ports[slot];\n    if (cp == NULL) {\n\tpj_mutex_unlock(vid_conf->mutex);\n\treturn PJ_EINVAL;\n    }\n\n    info->slot = slot;\n    info->name = cp->name;\n    pjmedia_format_copy(&info->format, &cp->port->info.fmt);\n    info->listener_cnt = cp->listener_cnt;\n    info->listener_slots = cp->listener_slots;\n    info->transmitter_cnt = cp->transmitter_cnt;\n    info->transmitter_slots = cp->transmitter_slots;\n\n    /* Unlock mutex */\n    pj_mutex_unlock(vid_conf->mutex);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Enable unidirectional video flow from the specified source slot to\n * the specified sink slot.\n */\nPJ_DEF(pj_status_t) pjmedia_vid_conf_connect_port(\n\t\t\t\t\t    pjmedia_vid_conf *vid_conf,\n\t\t\t\t\t    unsigned src_slot,\n\t\t\t\t\t    unsigned sink_slot,\n\t\t\t\t\t    void *opt)\n{\n    vconf_port *src_port, *dst_port;\n    unsigned i;\n\n    /* Check arguments */\n    PJ_ASSERT_RETURN(vid_conf &&\n\t\t     src_slot<vid_conf->opt.max_slot_cnt && \n\t\t     sink_slot<vid_conf->opt.max_slot_cnt, PJ_EINVAL);\n    PJ_UNUSED_ARG(opt);\n\n    pj_mutex_lock(vid_conf->mutex);\n\n    /* Ports must be valid. */\n    src_port = vid_conf->ports[src_slot];\n    dst_port = vid_conf->ports[sink_slot];\n    if (!src_port || !src_port->port->get_frame ||\n\t!dst_port || !dst_port->port->put_frame)\n    {\n\tPJ_LOG(4,(THIS_FILE,\"Failed connecting video ports, make sure that \"\n\t\t\t    \"source has get_frame() & sink has put_frame()\"));\n\tpj_mutex_unlock(vid_conf->mutex);\n\treturn PJ_EINVAL;\n    }\n\n    /* Check if connection has been made */\n    for (i=0; i<src_port->listener_cnt; ++i) {\n\tif (src_port->listener_slots[i] == sink_slot)\n\t    break;\n    }\n\n    if (i == src_port->listener_cnt) {\n\tsrc_port->listener_slots[src_port->listener_cnt] = sink_slot;\n\tdst_port->transmitter_slots[dst_port->transmitter_cnt] = src_slot;\n\t++src_port->listener_cnt;\n\t++dst_port->transmitter_cnt;\n\n\tif (src_port->listener_cnt == 1) {\n    \t    /* If this is the first listener, initialize source's buffer\n    \t     * with black color.\n    \t     */\n\t    const pjmedia_video_format_info *vfi;\n\t    pjmedia_video_apply_fmt_param vafp;\n\n\t    vfi = pjmedia_get_video_format_info(NULL,\n\t    \t\t\t\t\tsrc_port->port->info.fmt.id);\n\t    pj_bzero(&vafp, sizeof(vafp));\n\t    vafp.size = src_port->port->info.fmt.det.vid.size;\n\t    (*vfi->apply_fmt)(vfi, &vafp);\n\n\t    if (vfi->color_model == PJMEDIA_COLOR_MODEL_RGB) {\n\t    \tpj_memset(src_port->get_buf, 0, vafp.framebytes);\n\t    } else if (src_port->port->info.fmt.id == PJMEDIA_FORMAT_I420 ||\n\t  \t       src_port->port->info.fmt.id == PJMEDIA_FORMAT_YV12)\n\t    {\t    \t\n\t    \tpj_memset(src_port->get_buf, 16, vafp.plane_bytes[0]);\n\t    \tpj_memset((pj_uint8_t*)src_port->get_buf + vafp.plane_bytes[0],\n\t\t      \t  0x80, vafp.plane_bytes[1] * 2);\n\t    }\n\t}\n\n\tupdate_render_state(vid_conf, dst_port);\n\n\t++vid_conf->connect_cnt;\n\tif (vid_conf->connect_cnt == 1) {\n\t    pj_status_t status;\n\t    status = pjmedia_clock_start(vid_conf->clock);\n\t    if (status != PJ_SUCCESS) {\n\t\tPJ_PERROR(4, (THIS_FILE, status, \"Failed to start clock\"));\n\t\treturn status;\n\t    }\n\t}\n\n\tPJ_LOG(4,(THIS_FILE,\"Port %d (%.*s) transmitting to port %d (%.*s)\",\n\t\t  src_slot,\n\t\t  (int)src_port->name.slen,\n\t\t  src_port->name.ptr,\n\t\t  sink_slot,\n\t\t  (int)dst_port->name.slen,\n\t\t  dst_port->name.ptr));\n    }\n\n    pj_mutex_unlock(vid_conf->mutex);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Disconnect unidirectional video flow from the specified source to\n * the specified sink slot.\n */\nPJ_DEF(pj_status_t) pjmedia_vid_conf_disconnect_port(\n\t\t\t\t\t    pjmedia_vid_conf *vid_conf,\n\t\t\t\t\t    unsigned src_slot,\n\t\t\t\t\t    unsigned sink_slot)\n{\n    vconf_port *src_port, *dst_port;\n    unsigned i, j;\n\n    /* Check arguments */\n    PJ_ASSERT_RETURN(vid_conf &&\n\t\t     src_slot<vid_conf->opt.max_slot_cnt && \n\t\t     sink_slot<vid_conf->opt.max_slot_cnt, PJ_EINVAL);\n\n    pj_mutex_lock(vid_conf->mutex);\n\n    /* Ports must be valid. */\n    src_port = vid_conf->ports[src_slot];\n    dst_port = vid_conf->ports[sink_slot];\n    if (!src_port || !dst_port) {\n\tpj_mutex_unlock(vid_conf->mutex);\n\treturn PJ_EINVAL;\n    }\n\n    /* Check if connection has been made */\n    for (i=0; i<src_port->listener_cnt; ++i) {\n\tif (src_port->listener_slots[i] == sink_slot)\n\t    break;\n    }\n    for (j=0; j<dst_port->transmitter_cnt; ++j) {\n\tif (dst_port->transmitter_slots[j] == src_slot)\n\t    break;\n    }\n\n    if (i != src_port->listener_cnt && j != dst_port->transmitter_cnt) {\n\tunsigned k;\n\n\tpj_assert(src_port->listener_cnt > 0 && \n\t\t  src_port->listener_cnt < vid_conf->opt.max_slot_cnt);\n\tpj_assert(dst_port->transmitter_cnt > 0 && \n\t\t  dst_port->transmitter_cnt < vid_conf->opt.max_slot_cnt);\n\n\t/* Cleanup all render states of the sink */\n\tfor (k=0; k<dst_port->transmitter_cnt; ++k)\n\t    cleanup_render_state(dst_port, k);\n\n\t/* Update listeners array of the source and transmitters array of\n\t * the sink.\n\t */\n\tpj_array_erase(src_port->listener_slots, sizeof(unsigned), \n\t\t       src_port->listener_cnt, i);\n\tpj_array_erase(dst_port->transmitter_slots, sizeof(unsigned), \n\t\t       dst_port->transmitter_cnt, j);\n\t--src_port->listener_cnt;\n\t--dst_port->transmitter_cnt;\n\n\t/* Update render states of the sink */\n\tupdate_render_state(vid_conf, dst_port);\n\n\t--vid_conf->connect_cnt;\n\n\tif (AUTO_STOP_CLOCK && vid_conf->connect_cnt == 0) {\n\t    pj_status_t status;\n\t    /* Warning: will stuck if this is called from the clock thread */\n\t    status = pjmedia_clock_stop(vid_conf->clock);\n\t    if (status != PJ_SUCCESS) {\n\t\tPJ_PERROR(4, (THIS_FILE, status, \"Failed to stop clock\"));\n\t\treturn status;\n\t    }\n\t}\n\n\tPJ_LOG(4,(THIS_FILE,\n\t\t  \"Port %d (%.*s) stop transmitting to port %d (%.*s)\",\n\t\t  src_slot,\n\t\t  (int)src_port->name.slen,\n\t\t  src_port->name.ptr,\n\t\t  sink_slot,\n\t\t  (int)dst_port->name.slen,\n\t\t  dst_port->name.ptr));\n    }\n\n    pj_mutex_unlock(vid_conf->mutex);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Internal functions.\n */\n\nstatic void on_clock_tick(const pj_timestamp *now, void *user_data)\n{\n    pjmedia_vid_conf *vid_conf = (pjmedia_vid_conf*)user_data;\n    unsigned ci, i;\n    pj_int32_t ts_diff;\n    pjmedia_frame frame;\n    pj_status_t status;\n\n    pj_mutex_lock(vid_conf->mutex);\n\n    /* Iterate all (sink) ports */\n    for (i=0, ci=0; i<vid_conf->opt.max_slot_cnt &&\n\t\t    ci<vid_conf->port_cnt; ++i)\n    {\n\tunsigned j;\n\tpj_bool_t got_frame = PJ_FALSE;\n\tpj_bool_t ts_incremented = PJ_FALSE;\n\tvconf_port *sink = vid_conf->ports[i];\n\n\t/* Skip empty port */\n\tif (!sink)\n\t    continue;\n\n\t/* Increment occupied port counter */\n\t++ci;\n\n\t/* Skip non-sink port */\n\tif (!sink->port->put_frame)\n\t    continue;\n\n\tif (sink->ts_next.u64 == 0)\n\t    sink->ts_next = *now;\n\n\t/* Skip if too early for put_frame(), note:\n\t * early = (now < ts_next)\n\t * But careful for timestamp wrapped around.\n\t */\n\tts_diff = pj_timestamp_diff32(&sink->ts_next, now);\n\tif (ts_diff < 0 || ts_diff > TS_CLOCK_RATE)\n\t    continue;\n\n\t/* Clean up sink put buffer (should we draw black instead?) */\n\t//pj_bzero(sink->put_buf, sink->put_buf_size);\n\n\t/* Iterate transmitters of this sink port */\n\tfor (j=0; j < sink->transmitter_cnt; ++j) {\n\t    vconf_port *src = vid_conf->ports[sink->transmitter_slots[j]];\n\t    pj_int32_t src_ts_diff;\n\n\t    if (src->ts_next.u64 == 0)\n\t\tsrc->ts_next = *now;\n\n\t    /* Is it time for src->get_frame()? yes, if (now >= ts_next) */\n\t    src_ts_diff = pj_timestamp_diff32(&src->ts_next, now);\n\t    if (src_ts_diff >= 0) {\n\n\t\t/* Call src->get_frame().\n\t\t * Possible optimization: if this src only has one listener,\n\t\t * perhaps we can skip this src buffer and directly render it\n\t\t * to sink buffer (but still need buffer if conversion any).\n\t\t */\n\t\tpj_bzero(&frame, sizeof(frame));\n\t\tframe.type = PJMEDIA_FRAME_TYPE_VIDEO;\n\t\tframe.timestamp = *now;\n\t\tframe.buf = src->get_buf;\n\t\tframe.size = src->get_buf_size;\n\t\tstatus = pjmedia_port_get_frame(src->port, &frame);\n\t\tif (status != PJ_SUCCESS) {\n\t\t    PJ_PERROR(5, (THIS_FILE, status,\n\t\t\t\t  \"Failed to get frame from port %d [%s]!\",\n\t\t\t\t  src->idx, src->port->info.name.ptr));\n\t\t}\n\n\t\t/* Update next src put/get */\n\t\tpj_add_timestamp32(&src->ts_next, src->ts_interval);\n\t\tts_incremented = src==sink;\n\t    }\n\n\t    /* Render src get buffer to sink put buffer (based on sink layout\n\t     * settings, if any)\n\t     */\n\t    status = render_src_frame(src, sink, j);\n\t    if (status != PJ_SUCCESS) {\n\t\tPJ_PERROR(5, (THIS_FILE, status,\n\t\t\t      \"Failed to render frame from port %d [%s] to \"\n\t\t\t      \"%d [%s]\",\n\t\t\t      src->idx, src->port->info.name.ptr,\n\t\t\t      sink->idx, sink->port->info.name.ptr));\n\t    }\n\n\t    got_frame = PJ_TRUE;\n\t}\n\n\t/* Call sink->put_frame()\n\t * Note that if transmitter_cnt==0, we should still call put_frame()\n\t * with zero frame size, as sink may need to send keep-alive packets\n\t * and get timestamp update.\n\t */\n\tpj_bzero(&frame, sizeof(frame));\n\tframe.type = PJMEDIA_FRAME_TYPE_VIDEO;\n\tframe.timestamp = *now;\n\tif (got_frame) {\n\t    frame.buf = sink->put_buf;\n\t    frame.size = sink->put_buf_size;\n\t}\n\tstatus = pjmedia_port_put_frame(sink->port, &frame);\n\tif (got_frame && status != PJ_SUCCESS) {\n\t    sink->last_err_cnt++;\n\t    if (sink->last_err != status ||\n\t        sink->last_err_cnt % MAX_ERR_COUNT == 0)\n\t    {\n\t\tif (sink->last_err != status)\n\t\t    sink->last_err_cnt = 1;\n\t\tsink->last_err = status;\n\t    \tPJ_PERROR(5, (THIS_FILE, status,\n\t\t\t      \"Failed (%d time(s)) to put frame to port %d\"\n\t\t\t      \" [%s]!\", sink->last_err_cnt,\n\t\t\t      sink->idx, sink->port->info.name.ptr));\n\t    }\n\t} else {\n\t    sink->last_err = status;\n\t    sink->last_err_cnt = 0;\n\t}\n\n\t/* Update next put/get, careful that it may have been updated\n\t * if this port transmits to itself!\n\t */\n\tif (!ts_incremented) {\n\t    pj_add_timestamp32(&sink->ts_next, sink->ts_interval);\n\t}\n    }\n\n    pj_mutex_unlock(vid_conf->mutex);\n}\n\nstatic pj_bool_t is_landscape(const pjmedia_rect_size *size) {\n    return (size->w >= size->h);\n}\n\n/* Adjust a frame size to match ratio specified in the ref_size.\n * Either dimension of the frame may be cropped (but will never be\n * expanded).\n */\nstatic void match_ratio_crop(pjmedia_rect_size *size,\n\t\t\t     const pjmedia_rect_size *ref_size)\n{\n    pjmedia_rect_size res;\n\n    /* Try match width first */\n    res.w = size->w;\n    res.h = ref_size->h * size->w / ref_size->w;\n    \n    /* If original height turns out to be shorther, match height */\n    if (size->h < res.h) {\n\tres.w = ref_size->w * size->h / ref_size->h;\n\tres.h = size->h;\n    }\n\n    *size = res;\n    return;\n}\n\n/* Cleanup rendering states, called when a transmitter is disconnected\n * from a listener, or before reinit-ing rendering state of a listener\n * when new connection has just been made.\n */\nstatic void cleanup_render_state(vconf_port *cp,\n\t\t\t\t unsigned transmitter_idx)\n{\n    render_state *rs = cp->render_states[transmitter_idx];\n    if (rs && rs->converter)\n    {\n\tpjmedia_converter_destroy(rs->converter);\n\trs->converter = NULL;\n    }\n    cp->render_states[transmitter_idx] = NULL;\n\n    if (cp->render_pool[transmitter_idx]) {\n\tpj_pool_safe_release(&cp->render_pool[transmitter_idx]);\n\n\tTRACE_((THIS_FILE, \"Cleaned up render state for connection %d->%d\",\n\t\tcp->transmitter_slots[transmitter_idx], cp->idx));\n    }\n}\n\n/* This function will do:\n * - Recalculate layout setting, i.e: get video pos and size\n *   for each transmitter\n * - Check if converter is needed and setup it.\n * - Those above things will be stored in render_state and\n *   will be used by render_src_frame()\n */\nstatic void update_render_state(pjmedia_vid_conf *vid_conf, vconf_port *cp)\n{\n    pjmedia_format_id fmt_id, tr_fmt_id[4];\n    pjmedia_rect_size size, tr_size[4];\n    unsigned i;\n    pj_status_t status;\n\n    /* Nothing to render, just return */\n    if (cp->transmitter_cnt == 0)\n\treturn;\n\n    TRACE_((THIS_FILE, \"Updating render state for port id %d (%d sources)..\",\n\t    cp->idx, cp->transmitter_cnt));\n\n    fmt_id = cp->port->info.fmt.id;\n    size   = cp->port->info.fmt.det.vid.size;\n    for (i = 0; i < cp->transmitter_cnt; ++i) {\n\tvconf_port *tr = vid_conf->ports[cp->transmitter_slots[i]];\n\n\t/* Cleanup render states & pool */\n\tcleanup_render_state(cp, i);\n\n\t/* Gather format ID, size of each transmitter */\n\ttr_fmt_id[i] = tr->port->info.fmt.id;\n\ttr_size[i]   = tr->port->info.fmt.det.vid.size;\n    }\n\n    /* If only one transmitter and it has matched format & size, just use\n     * plain memcpy(). Usually preview window or call stream window will\n     * have matched format & size with its source.\n     */\n    if (cp->transmitter_cnt == 1 && fmt_id == tr_fmt_id[0] &&\n\tpj_memcmp(&size, &tr_size[0], sizeof(size))==0)\n    {\n\tTRACE_((THIS_FILE, \"This port only has single source with \"\n\t\t\t   \"matched format & size, no conversion needed\"));\n\treturn;\n    }\n\n    for (i = 0; i < cp->transmitter_cnt && i < 4; ++i) {\n\tpj_pool_t *pool;\n\trender_state *rs;\n\tpjmedia_conversion_param cparam;\n\tchar tmp_buf[32];\n\n\t/* Create pool & render state */\n\tpj_ansi_snprintf(tmp_buf, sizeof(tmp_buf), \"vcport_rs_%d->%d\",\n\t\t\t cp->transmitter_slots[i], cp->idx);\n\tpool = pj_pool_create(cp->pool->factory, tmp_buf, 128, 128, NULL);\n\tcp->render_pool[i] = pool;\n\trs = cp->render_states[i] = PJ_POOL_ZALLOC_T(pool, render_state);\n\n\tTRACE_((THIS_FILE, \"Created render state for connection %d->%d\",\n\t\t\t   cp->transmitter_slots[i], cp->idx));\n\n\t/* Setup format & frame */\n\trs->src_fmt_id = tr_fmt_id[i];\n\trs->dst_fmt_id = fmt_id;\n\trs->src_frame_size = tr_size[i];\n\trs->dst_frame_size = size;\n\n\t/* For now, draw the whole source frame, will adjust ratio later */\n\trs->src_rect.coord.x = rs->src_rect.coord.y = 0;\n\trs->src_rect.size = tr_size[i];\n\n\t/* Setup layout */\n\tif (cp->transmitter_cnt == 1) {\n\t    rs->dst_rect.coord.x = rs->dst_rect.coord.y = 0;\n\t    rs->dst_rect.size = size;\n\t} else if (cp->transmitter_cnt == 2) {\n\t    if (is_landscape(&size)) {\n\t\t/*\n\t\t *          |\n\t\t * Source 0 | Source 1\n\t\t *          |\n\t\t */\n\t\trs->dst_rect.coord.x = i * (size.w/2);\n\t\trs->dst_rect.coord.y = 0;\n\t\trs->dst_rect.size.w = size.w / 2;\n\t\trs->dst_rect.size.h = size.h;\n\t    } else {\n\t\t/*\n\t\t * Source 0\n\t\t * --------\n\t\t * Source 1\n\t\t */\n\t\trs->dst_rect.coord.x = 0;\n\t\trs->dst_rect.coord.y = i * (size.h/2);\n\t\trs->dst_rect.size.w = size.w;\n\t\trs->dst_rect.size.h = size.h / 2;\n\t    }\n\t} else if (cp->transmitter_cnt == 3) {\n\t    if (is_landscape(&size)) {\n\t\t/*\n\t\t *          | Source 1\n\t\t * Source 0 |---------\n\t\t *          | Source 2\n\t\t */\n\t\trs->dst_rect.coord.x = (i==0)? 0 : size.w/2;\n\t\trs->dst_rect.coord.y = (i!=2)? 0 : size.h/2;\n\t\trs->dst_rect.size.w = size.w / 2;\n\t\trs->dst_rect.size.h = (i==0)? size.h : size.h/2;\n\t    } else {\n\t\t/*\n\t\t * Source 0\n\t\t * --------\n\t\t * Source 1\n\t\t * --------\n\t\t * Source 2\n\t\t */\n\t\trs->dst_rect.coord.x = 0;\n\t\trs->dst_rect.coord.y = i * size.h/3;\n\t\trs->dst_rect.size.w = size.w;\n\t\trs->dst_rect.size.h = size.h/3;\n\t    }\n\t} else if (cp->transmitter_cnt == 4) {\n\t    if (is_landscape(&size)) {\n\t\t/*\n\t\t * Source 0 | Source 1\n\t\t * ---------|---------\n\t\t * Source 2 | Source 3\n\t\t */\n\t\trs->dst_rect.coord.x = (i%2==0)? 0 : size.w/2;\n\t\trs->dst_rect.coord.y = (i/2==0)? 0 : size.h/2;\n\t\trs->dst_rect.size.w = size.w/2;\n\t\trs->dst_rect.size.h = size.h/2;\n\t    } else {\n\t\t/*\n\t\t * Source 0\n\t\t * --------\n\t\t * Source 1\n\t\t * --------\n\t\t * Source 2\n\t\t * --------\n\t\t * Source 3\n\t\t */\n\t\trs->dst_rect.coord.x = 0;\n\t\trs->dst_rect.coord.y = i * size.h/4;\n\t\trs->dst_rect.size.w = size.w;\n\t\trs->dst_rect.size.h = size.h/4;\n\t    }\n\t}\n\n\t/* Adjust source size to match aspect ratio of rendering space. */\n\tmatch_ratio_crop(&rs->src_rect.size, &rs->dst_rect.size);\n\n\t/* Now adjust source position after source size adjustment. */\n\tif (rs->src_rect.size.w < tr_size[i].w)\n\t    rs->src_rect.coord.x = (tr_size[i].w - rs->src_rect.size.w)/2;\n\tif (rs->src_rect.size.h < tr_size[i].h)\n\t    rs->src_rect.coord.y = (tr_size[i].h - rs->src_rect.size.h)/2;\n\n\tTRACE_((THIS_FILE, \"src#%d=%s/%dx%d->%dx%d@%d,%d dst=%dx%d@%d,%d\",\n\t\t\t   i, pjmedia_fourcc_name(tr_fmt_id[i], tmp_buf),\n\t\t\t   tr_size[i].w, tr_size[i].h,\n\t\t\t   rs->src_rect.size.w, rs->src_rect.size.h,\n\t\t\t   rs->src_rect.coord.x, rs->src_rect.coord.y,\n\t\t\t   rs->dst_rect.size.w, rs->dst_rect.size.h,\n\t\t\t   rs->dst_rect.coord.x, rs->dst_rect.coord.y));\n\n\t/* Create converter */\n\tpjmedia_format_init_video(&cparam.src, rs->src_fmt_id,\n\t\t\t\t  rs->src_rect.size.w,\n\t\t\t\t  rs->src_rect.size.h,\n\t\t\t\t  0, 1);\n\tpjmedia_format_init_video(&cparam.dst, rs->dst_fmt_id,\n\t\t\t\t  rs->dst_rect.size.w,\n\t\t\t\t  rs->dst_rect.size.h,\n\t\t\t\t  0, 1);\n\tstatus = pjmedia_converter_create(NULL, pool, &cparam,\n\t\t\t\t\t  &rs->converter);\n\tif (status != PJ_SUCCESS) {\n\t    PJ_PERROR(4,(THIS_FILE, status,\n\t\t\t \"Port %d failed creating converter \"\n\t\t\t \"for source %d\", cp->idx, i));\n\t}\n    }\n}\n\n/* Render frame from source to sink buffer based on rendering settings. */\nstatic pj_status_t render_src_frame(vconf_port *src, vconf_port *sink,\n\t\t\t\t    unsigned transmitter_idx)\n{\n    pj_status_t status;\n    render_state *rs = sink->render_states[transmitter_idx];\n\n    if (sink->transmitter_cnt == 1 && (!rs || !rs->converter)) {\n\t/* The only transmitter and no conversion needed */\n\tpj_assert(src->get_buf_size <= sink->put_buf_size);\n\tpj_memcpy(sink->put_buf, src->get_buf, src->get_buf_size);\n    } else if (rs && rs->converter) {\n\tpjmedia_frame src_frame, dst_frame;\n\t\n\tpj_bzero(&src_frame, sizeof(src_frame));\n\tsrc_frame.buf = src->get_buf;\n\tsrc_frame.size = src->get_buf_size;\n\n\tpj_bzero(&dst_frame, sizeof(dst_frame));\n\tdst_frame.buf = sink->put_buf;\n\tdst_frame.size = sink->put_buf_size;\n\n\tstatus = pjmedia_converter_convert2(rs->converter,\n\t\t\t\t\t    &src_frame,\n\t\t\t\t\t    &rs->src_frame_size,\n\t\t\t\t\t    &rs->src_rect.coord,\n\t\t\t\t\t    &dst_frame,\n\t\t\t\t\t    &rs->dst_frame_size,\n\t\t\t\t\t    &rs->dst_rect.coord,\n\t\t\t\t\t    NULL);\n\tif (status != PJ_SUCCESS) {\n\t    PJ_PERROR(4,(THIS_FILE, status,\n\t\t\t \"Port id %d: converter failed in \"\n\t\t\t \"rendering frame from port id %d\",\n\t\t\t sink->idx, transmitter_idx));\n\t    return status;\n\t}\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/* Update or refresh port states from video port info. */\nPJ_DEF(pj_status_t) pjmedia_vid_conf_update_port( pjmedia_vid_conf *vid_conf,\n\t\t\t\t\t\t  unsigned slot)\n{\n    vconf_port *cport;\n    pjmedia_format old_fmt;\n    pjmedia_format new_fmt;\n\n    PJ_ASSERT_RETURN(vid_conf && slot<vid_conf->opt.max_slot_cnt, PJ_EINVAL);\n\n    pj_mutex_lock(vid_conf->mutex);\n\n    /* Port must be valid. */\n    cport = vid_conf->ports[slot];\n    if (cport == NULL) {\n\tpj_mutex_unlock(vid_conf->mutex);\n\treturn PJ_EINVAL;\n    }\n\n    /* Get the old & new formats */\n    old_fmt = cport->format;\n    new_fmt = cport->port->info.fmt;\n\n    /* Update put/get_frame() intervals */\n    if (pj_memcmp(&new_fmt.det.vid.fps, &old_fmt.det.vid.fps,\n\t\t  sizeof(pjmedia_ratio)))\n    {\n\tpjmedia_ratio *fps = &new_fmt.det.vid.fps;\n\tpj_uint32_t vconf_interval = (pj_uint32_t)\n\t\t\t\t     (TS_CLOCK_RATE * 1.0 /\n\t\t\t\t     vid_conf->opt.frame_rate);\n\tcport->ts_interval = (pj_uint32_t)(TS_CLOCK_RATE * 1.0 /\n\t\t\t\t\t   fps->num * fps->denum);\n\n\t/* Normalize the interval */\n\tif (cport->ts_interval < vconf_interval) {\n\t    cport->ts_interval = vconf_interval;\n\t    PJ_LOG(3,(THIS_FILE, \"Warning: frame rate of port %s is higher \"\n\t\t\t\t \"than video conference bridge (%d > %d)\",\n\t\t\t\t cport->name.ptr, (int)(fps->num/fps->denum),\n\t\t\t\t vid_conf->opt.frame_rate));\n\t}\n\n\tPJ_LOG(4,(THIS_FILE,\n\t\t  \"Port %d (%s): updated frame rate %d -> %d\",\n\t\t  slot, cport->name.ptr,\n\t\t  (int)(old_fmt.det.vid.fps.num/old_fmt.det.vid.fps.denum),\n\t\t  (int)(fps->num/fps->denum)));\n    }\n\n    /* Update buffer for put/get_frame() */\n    if (new_fmt.id != old_fmt.id ||\n\tpj_memcmp(&new_fmt.det.vid.size, &old_fmt.det.vid.size,\n\t\t  sizeof(pjmedia_rect_size)))\n    {\n\tconst pjmedia_video_format_info *vfi;\n\tpjmedia_video_apply_fmt_param vafp;\n\tpj_status_t status;\n\tunsigned i;\n\n\tvfi = pjmedia_get_video_format_info(NULL, new_fmt.id);\n\tif (!vfi) {\n\t    PJ_LOG(1,(THIS_FILE, \"pjmedia_vid_conf_update_port(): \"\n\t\t\t\t \"unrecognized format %04X\",\n\t\t\t\t new_fmt.id));\n\t    pj_mutex_unlock(vid_conf->mutex);\n\t    return PJMEDIA_EBADFMT;\n\t}\n\n\tpj_bzero(&vafp, sizeof(vafp));\n\tvafp.size = new_fmt.det.vid.size;\n\tstatus = (*vfi->apply_fmt)(vfi, &vafp);\n\tif (status != PJ_SUCCESS) {\n\t    PJ_LOG(1,(THIS_FILE, \"pjmedia_vid_conf_update_port(): \"\n\t\t\t\t \"Failed to apply format %04X\",\n\t\t\t\t new_fmt.id));\n\t    pj_mutex_unlock(vid_conf->mutex);\n\t    return status;\n\t}\n\tif (cport->port->put_frame) {\n\t    if (cport->put_buf_size < vafp.framebytes)\n\t\tcport->put_buf = pj_pool_zalloc(cport->pool, vafp.framebytes);\n\t    cport->put_buf_size = vafp.framebytes;\n\t}\n\tif (cport->port->get_frame) {\n\t    if (cport->get_buf_size < vafp.framebytes)\n\t\tcport->get_buf = pj_pool_zalloc(cport->pool, vafp.framebytes);\n\t    cport->get_buf_size = vafp.framebytes;\n\t}\n\n\t/* Update render state */\n\tupdate_render_state(vid_conf, cport);\n\n\t/* Update render state of listeners */\n\tfor (i=0; i < cport->listener_cnt; ++i) {\n\t    vconf_port *sink = vid_conf->ports[cport->listener_slots[i]];\n\t    update_render_state(vid_conf, sink);\n\t}\n\n\tPJ_LOG(4,(THIS_FILE,\n\t\t  \"Port %d (%s): updated frame size %dx%d -> %dx%d\",\n\t\t  slot, cport->name.ptr,\n\t\t  old_fmt.det.vid.size.w, old_fmt.det.vid.size.h,\n\t\t  new_fmt.det.vid.size.w, new_fmt.det.vid.size.h));\n    }\n\n\n    /* Update cport format info */\n    cport->format = new_fmt;\n    pj_mutex_unlock(vid_conf->mutex);\n\n    return PJ_SUCCESS;\n}\n\n\n#endif /* PJMEDIA_HAS_VIDEO */\n"], "fixing_code": ["/*\n * Copyright (C)2020 Teluu Inc. (http://www.teluu.com)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n */\n#include <pjmedia-codec/and_aud_mediacodec.h>\n#include <pjmedia-codec/amr_sdp_match.h>\n#include <pjmedia/codec.h>\n#include <pjmedia/errno.h>\n#include <pjmedia/endpoint.h>\n#include <pjmedia/plc.h>\n#include <pjmedia/port.h>\n#include <pjmedia/silencedet.h>\n#include <pj/assert.h>\n#include <pj/log.h>\n#include <pj/math.h>\n#include <pj/pool.h>\n#include <pj/string.h>\n#include <pj/os.h>\n\n/*\n * Only build this file if PJMEDIA_HAS_ANDROID_MEDIACODEC != 0\n */\n#if defined(PJMEDIA_HAS_ANDROID_MEDIACODEC) && \\\n            PJMEDIA_HAS_ANDROID_MEDIACODEC != 0\n\n/* Android AMediaCodec: */\n#include \"media/NdkMediaCodec.h\"\n\n#define THIS_FILE  \"and_aud_mediacodec.cpp\"\n\n#define AND_MEDIA_KEY_PCM_ENCODING       \"pcm-encoding\"\n#define AND_MEDIA_KEY_CHANNEL_COUNT      \"channel-count\"\n#define AND_MEDIA_KEY_SAMPLE_RATE        \"sample-rate\"\n#define AND_MEDIA_KEY_BITRATE            \"bitrate\"\n#define AND_MEDIA_KEY_MIME               \"mime\"\n\n#define CODEC_WAIT_RETRY \t10\n#define CODEC_THREAD_WAIT \t10\n/* Timeout until the buffer is ready in ms. */\n#define CODEC_DEQUEUE_TIMEOUT \t10\n\n/* Prototypes for Android MediaCodec codecs factory */\nstatic pj_status_t and_media_test_alloc(pjmedia_codec_factory *factory,\n\t\t\t\t\tconst pjmedia_codec_info *id );\nstatic pj_status_t and_media_default_attr(pjmedia_codec_factory *factory,\n\t\t\t\t\t  const pjmedia_codec_info *id,\n\t\t\t\t\t  pjmedia_codec_param *attr );\nstatic pj_status_t and_media_enum_codecs(pjmedia_codec_factory *factory,\n\t\t\t\t\t unsigned *count,\n\t\t\t\t\t pjmedia_codec_info codecs[]);\nstatic pj_status_t and_media_alloc_codec(pjmedia_codec_factory *factory,\n\t\t\t\t\t const pjmedia_codec_info *id,\n\t\t\t\t\t pjmedia_codec **p_codec);\nstatic pj_status_t and_media_dealloc_codec(pjmedia_codec_factory *factory,\n\t\t\t\t\t   pjmedia_codec *codec );\n\n/* Prototypes for Android MediaCodec codecs implementation. */\nstatic pj_status_t  and_media_codec_init(pjmedia_codec *codec,\n\t\t\t\t\t pj_pool_t *pool );\nstatic pj_status_t  and_media_codec_open(pjmedia_codec *codec,\n\t\t\t\t\t pjmedia_codec_param *attr );\nstatic pj_status_t  and_media_codec_close(pjmedia_codec *codec );\nstatic pj_status_t  and_media_codec_modify(pjmedia_codec *codec,\n\t\t\t\t\t   const pjmedia_codec_param *attr );\nstatic pj_status_t  and_media_codec_parse(pjmedia_codec *codec,\n\t\t\t\t\t  void *pkt,\n\t\t\t\t\t  pj_size_t pkt_size,\n\t\t\t\t\t  const pj_timestamp *ts,\n\t\t\t\t\t  unsigned *frame_cnt,\n\t\t\t\t\t  pjmedia_frame frames[]);\nstatic pj_status_t  and_media_codec_encode(pjmedia_codec *codec,\n\t\t\t\t\t   const struct pjmedia_frame *input,\n\t\t\t\t\t   unsigned output_buf_len,\n\t\t\t\t\t   struct pjmedia_frame *output);\nstatic pj_status_t  and_media_codec_decode(pjmedia_codec *codec,\n\t\t\t\t\t   const struct pjmedia_frame *input,\n\t\t\t\t\t   unsigned output_buf_len,\n\t\t\t\t\t   struct pjmedia_frame *output);\nstatic pj_status_t  and_media_codec_recover(pjmedia_codec *codec,\n\t\t\t\t\t    unsigned output_buf_len,\n\t\t\t\t\t    struct pjmedia_frame *output);\n\n/* Definition for Android MediaCodec codecs operations. */\nstatic pjmedia_codec_op and_media_op =\n{\n    &and_media_codec_init,\n    &and_media_codec_open,\n    &and_media_codec_close,\n    &and_media_codec_modify,\n    &and_media_codec_parse,\n    &and_media_codec_encode,\n    &and_media_codec_decode,\n    &and_media_codec_recover\n};\n\n/* Definition for Android MediaCodec codecs factory operations. */\nstatic pjmedia_codec_factory_op and_media_factory_op =\n{\n    &and_media_test_alloc,\n    &and_media_default_attr,\n    &and_media_enum_codecs,\n    &and_media_alloc_codec,\n    &and_media_dealloc_codec,\n    &pjmedia_codec_and_media_aud_deinit\n};\n\n/* Android MediaCodec codecs factory */\nstatic struct and_media_factory {\n    pjmedia_codec_factory    base;\n    pjmedia_endpt\t    *endpt;\n    pj_pool_t\t\t    *pool;\n    pj_mutex_t        \t    *mutex;\n} and_media_factory;\n\ntypedef enum and_aud_codec_id {\n    /* AMRNB codec. */\n    AND_AUD_CODEC_AMRNB,\n\n    /* AMRWB codec. */\n    AND_AUD_CODEC_AMRWB\n} and_aud_codec_id;\n\n/* Android MediaCodec codecs private data. */\ntypedef struct and_media_private {\n    int\t\t\t codec_idx;\t    /**< Codec index.\t\t    */\n    void\t\t*codec_setting;\t    /**< Specific codec setting.    */\n    pj_pool_t\t\t*pool;\t\t    /**< Pool for each instance.    */\n    AMediaCodec         *enc;               /**< Encoder state.\t\t    */\n    AMediaCodec         *dec;               /**< Decoder state.\t\t    */\n\n    pj_uint16_t\t\t frame_size;\t    /**< Bitstream frame size.\t    */\n\n    pj_bool_t\t\t plc_enabled;\t    /**< PLC enabled flag.\t    */\n    pjmedia_plc\t\t*plc;\t\t    /**< PJMEDIA PLC engine, NULL if \n\t\t\t\t\t\t codec has internal PLC.    */\n\n    pj_bool_t\t\t vad_enabled;\t    /**< VAD enabled flag.\t    */\n    pjmedia_silence_det\t*vad;\t\t    /**< PJMEDIA VAD engine, NULL if \n\t\t\t\t\t\t codec has internal VAD.    */\n    pj_timestamp\t last_tx;\t    /**< Timestamp of last transmit.*/\n} and_media_private_t;\n\n/* CUSTOM CALLBACKS */\n\n/* Parse frames from a packet. Default behaviour of frame parsing is \n * just separating frames based on calculating frame length derived \n * from bitrate. Implement this callback when the default behaviour is \n * unapplicable.\n */\ntypedef pj_status_t (*parse_cb)(and_media_private_t *codec_data, void *pkt,\n\t\t\t\tpj_size_t pkt_size, const pj_timestamp *ts,\n\t\t\t\tunsigned *frame_cnt, pjmedia_frame frames[]);\n\n/* Pack frames into a packet. Default behaviour of packing frames is \n * just stacking the frames with octet aligned without adding any \n * payload header. Implement this callback when the default behaviour is\n * unapplicable.\n */\ntypedef pj_status_t (*pack_cb)(and_media_private_t *codec_data,\n\t\t\t       unsigned nframes, void *pkt, pj_size_t *pkt_size,\n\t\t\t       pj_size_t max_pkt_size);\n\n/* This callback is useful for preparing a frame before pass it to decoder.\n */\ntypedef void (*predecode_cb)(and_media_private_t  *codec_data,\n\t\t\t     const pjmedia_frame *rtp_frame,\n\t\t\t     pjmedia_frame *out);\n\n#if PJMEDIA_HAS_AND_MEDIA_AMRNB || PJMEDIA_HAS_AND_MEDIA_AMRWB\n/* Custom callback implementations. */\nstatic pj_status_t parse_amr(and_media_private_t *codec_data, void *pkt,\n\t\t\t     pj_size_t pkt_size, const pj_timestamp *ts,\n\t\t\t     unsigned *frame_cnt, pjmedia_frame frames[]);\nstatic  pj_status_t pack_amr(and_media_private_t *codec_data, unsigned nframes,\n\t\t\t     void *pkt, pj_size_t *pkt_size,\n\t\t\t     pj_size_t max_pkt_size);\nstatic void predecode_amr(and_media_private_t  *codec_data,\n\t\t\t  const pjmedia_frame *input,\n\t\t\t  pjmedia_frame *out);\n#endif\n\n#if PJMEDIA_HAS_AND_MEDIA_AMRNB\n\nstatic pj_str_t AMRNB_encoder[] = {{(char *)\"OMX.google.amrnb.encoder\\0\", 24},\n\t\t\t\t   {(char *)\"c2.android.amrnb.encoder\\0\", 24}};\n\nstatic pj_str_t AMRNB_decoder[] = {{(char *)\"OMX.google.amrnb.decoder\\0\", 24},\n\t\t\t           {(char *)\"c2.android.amrnb.decoder\\0\", 24}};\n#endif\n\n#if PJMEDIA_HAS_AND_MEDIA_AMRWB\n\nstatic pj_str_t AMRWB_encoder[] = {{(char *)\"OMX.google.amrwb.encoder\\0\", 24},\n\t\t\t\t   {(char *)\"c2.android.amrwb.encoder\\0\", 24}};\n\nstatic pj_str_t AMRWB_decoder[] = {{(char *)\"OMX.google.amrwb.decoder\\0\", 24},\n\t\t\t\t   {(char *)\"c2.android.amrwb.decoder\\0\", 24}};\n#endif\n\n/* Android MediaCodec codec implementation descriptions. */\nstatic struct and_media_codec {\n    int\t\t     enabled;\t\t/* Is this codec enabled?\t    */\n    const char\t    *name;\t\t/* Codec name.\t\t\t    */\n    const char      *mime_type;         /* Mime type.                       */\n    pj_str_t        *encoder_name;      /* Encoder name.                    */\n    pj_str_t        *decoder_name;      /* Decoder name.                    */\n\n    pj_uint8_t\t     pt;\t\t/* Payload type.\t\t    */\n    and_aud_codec_id codec_id;\t\t/* Codec id.                        */\n    unsigned\t     clock_rate;\t/* Codec's clock rate.\t\t    */\n    unsigned\t     channel_count;\t/* Codec's channel count.\t    */\n    unsigned\t     samples_per_frame;\t/* Codec's samples count.\t    */\n    unsigned\t     def_bitrate;\t/* Default bitrate of this codec.   */\n    unsigned\t     max_bitrate;\t/* Maximum bitrate of this codec.   */\n    pj_uint8_t\t     frm_per_pkt;\t/* Default num of frames per packet.*/\n    int\t\t     has_native_vad;\t/* Codec has internal VAD?\t    */\n    int\t\t     has_native_plc;\t/* Codec has internal PLC?\t    */\n\n    parse_cb\t     parse;\t\t/* Callback to parse bitstream.\t    */\n    pack_cb\t     pack;\t\t/* Callback to pack bitstream.\t    */\n    predecode_cb     predecode;         /* Callback to prepare bitstream\n                                           before passing it to decoder.    */\n\n    pjmedia_codec_fmtp dec_fmtp;\t/* Decoder's fmtp params.\t    */\n}\n\nand_media_codec[] =\n{\n#   if PJMEDIA_HAS_AND_MEDIA_AMRNB\n    {0, \"AMR\", \"audio/3gpp\", NULL, NULL,\n        PJMEDIA_RTP_PT_AMR, AND_AUD_CODEC_AMRNB, 8000, 1, 160, 7400, 12200,\n        2, 0, 0, &parse_amr, &pack_amr, &predecode_amr,\n        {1, {{{(char *)\"octet-align\", 11}, {(char *)\"1\", 1}}}}\n    },\n#   endif\n\n#   if PJMEDIA_HAS_AND_MEDIA_AMRWB\n    {0, \"AMR-WB\", \"audio/amr-wb\", NULL, NULL,\n        PJMEDIA_RTP_PT_AMRWB, AND_AUD_CODEC_AMRWB, 16000, 1, 320, 15850, 23850,\n        2, 0, 0, &parse_amr, &pack_amr, &predecode_amr,\n\t{1, {{{(char *)\"octet-align\", 11}, {(char *)\"1\", 1}}}}\n    },\n#   endif\n};\n\n#if PJMEDIA_HAS_AND_MEDIA_AMRNB || PJMEDIA_HAS_AND_MEDIA_AMRWB\n\n#include <pjmedia-codec/amr_helper.h>\n\ntypedef struct amr_settings_t {\n    pjmedia_codec_amr_pack_setting enc_setting;\n    pjmedia_codec_amr_pack_setting dec_setting;\n    pj_int8_t enc_mode;\n} amr_settings_t;\n\n/* Pack AMR payload */\nstatic pj_status_t pack_amr(and_media_private_t *codec_data, unsigned nframes,\n\t\t\t    void *pkt, pj_size_t *pkt_size,\n\t\t\t    pj_size_t max_pkt_size)\n{\n    enum {MAX_FRAMES_PER_PACKET = PJMEDIA_MAX_FRAME_DURATION_MS / 20};\n\n    pjmedia_frame frames[MAX_FRAMES_PER_PACKET];\n    pj_uint8_t *p; /* Read cursor */\n    pjmedia_codec_amr_pack_setting *setting;\n    unsigned i;\n    pj_status_t status;\n\n    setting = &((amr_settings_t*)codec_data->codec_setting)->enc_setting;\n\n    /* Align pkt buf right */\n    p = (pj_uint8_t*)pkt + max_pkt_size - *pkt_size;\n    pj_memmove(p, pkt, *pkt_size);\n\n    /* Get frames */\n    for (i = 0; i < nframes; ++i) {\n\tpjmedia_codec_amr_bit_info *info = (pjmedia_codec_amr_bit_info*)\n\t\t\t\t\t    &frames[i].bit_info;\n\tpj_bzero(info, sizeof(*info));\n\tinfo->frame_type = (pj_uint8_t)((*p >> 3) & 0x0F);\n\tinfo->good_quality = (pj_uint8_t)((*p >> 2) & 0x01);\n\tinfo->mode = ((amr_settings_t*)codec_data->codec_setting)->enc_mode;\n\tinfo->start_bit = 0;\n\tframes[i].buf = p + 1;\n        if (setting->amr_nb) {\n            frames[i].size = (info->frame_type <= 8)?\n                             pjmedia_codec_amrnb_framelen[info->frame_type] : 0;\n        } else {\n            frames[i].size = (info->frame_type <= 9)?\n                             pjmedia_codec_amrwb_framelen[info->frame_type] : 0;\n        }\n\tp += frames[i].size + 1;\n    }\n    /* Pack */\n    *pkt_size = max_pkt_size;\n    status = pjmedia_codec_amr_pack(frames, nframes, setting, pkt, pkt_size);\n\n    return status;\n}\n\n/* Parse AMR payload into frames. */\nstatic pj_status_t parse_amr(and_media_private_t *codec_data, void *pkt,\n\t\t\t     pj_size_t pkt_size, const pj_timestamp *ts,\n\t\t\t     unsigned *frame_cnt, pjmedia_frame frames[])\n{\n    amr_settings_t* s = (amr_settings_t*)codec_data->codec_setting;\n    pjmedia_codec_amr_pack_setting *setting;\n    pj_status_t status;\n    pj_uint8_t cmr;\n\n    setting = &s->dec_setting;\n    status = pjmedia_codec_amr_parse(pkt, pkt_size, ts, setting, frames, \n\t\t\t\t     frame_cnt, &cmr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Check Change Mode Request. */\n    if (((setting->amr_nb && cmr <= 7) || (!setting->amr_nb && cmr <= 8)) &&\n\ts->enc_mode != cmr)\n    {\n\ts->enc_mode = cmr;\n    }\n    return PJ_SUCCESS;\n}\n\nstatic void predecode_amr(and_media_private_t *codec_data,\n\t\t\t  const pjmedia_frame *input,\n\t\t\t  pjmedia_frame *out)\n{\n    pjmedia_codec_amr_bit_info *info;\n    pj_uint8_t *bitstream = (pj_uint8_t *)out->buf;\n    pjmedia_codec_amr_pack_setting *setting;\n\n    out->buf = &bitstream[1];\n    setting = &((amr_settings_t*)codec_data->codec_setting)->dec_setting;\n    pjmedia_codec_amr_predecode(input, setting, out);\n    info = (pjmedia_codec_amr_bit_info*)&out->bit_info;\n    bitstream[0] = (info->frame_type << 3) | (info->good_quality << 2);\n    out->buf = &bitstream[0];\n    ++out->size;\n}\n\n#endif /* PJMEDIA_HAS_AND_MEDIA_AMRNB || PJMEDIA_HAS_AND_MEDIA_AMRWB */\n\nstatic pj_status_t configure_codec(and_media_private_t *and_media_data,\n\t\t\t\t   pj_bool_t is_encoder)\n{\n    media_status_t am_status;\n    AMediaFormat *aud_fmt;\n    int idx = and_media_data->codec_idx;\n    AMediaCodec *codec = (is_encoder?and_media_data->enc:and_media_data->dec);\n\n    aud_fmt = AMediaFormat_new();\n    if (!aud_fmt) {\n        return PJ_ENOMEM;\n    }\n    AMediaFormat_setString(aud_fmt, AND_MEDIA_KEY_MIME,\n                           and_media_codec[idx].mime_type);\n    AMediaFormat_setInt32(aud_fmt, AND_MEDIA_KEY_PCM_ENCODING, 2);\n    AMediaFormat_setInt32(aud_fmt, AND_MEDIA_KEY_CHANNEL_COUNT,\n                          and_media_codec[idx].channel_count);\n    AMediaFormat_setInt32(aud_fmt, AND_MEDIA_KEY_SAMPLE_RATE,\n\t\t\t  and_media_codec[idx].clock_rate);\n    AMediaFormat_setInt32(aud_fmt, AND_MEDIA_KEY_BITRATE,\n\t\t\t  and_media_codec[idx].def_bitrate);\n\n    /* Configure and start encoder. */\n    am_status = AMediaCodec_configure(codec, aud_fmt, NULL, NULL, is_encoder);\n    AMediaFormat_delete(aud_fmt);\n    if (am_status != AMEDIA_OK) {\n        PJ_LOG(4, (THIS_FILE, \"%s [0x%x] configure failed, status=%d\",\n               is_encoder?\"Encoder\":\"Decoder\", codec, am_status));\n        return PJMEDIA_CODEC_EFAILED;\n    }\n    am_status = AMediaCodec_start(codec);\n    if (am_status != AMEDIA_OK) {\n\tPJ_LOG(4, (THIS_FILE, \"%s [0x%x] start failed, status=%d\",\n\t       is_encoder?\"Encoder\":\"Decoder\", codec, am_status));\n\treturn PJMEDIA_CODEC_EFAILED;\n    }\n    PJ_LOG(4, (THIS_FILE, \"%s [0x%x] started\", is_encoder?\"Encoder\":\"Decoder\",\n\t   codec));\n    return PJ_SUCCESS;\n}\n\n/*\n * Initialize and register Android MediaCodec codec factory to pjmedia endpoint.\n */\nPJ_DEF(pj_status_t) pjmedia_codec_and_media_aud_init( pjmedia_endpt *endpt )\n{\n    pjmedia_codec_mgr *codec_mgr;\n    pj_str_t codec_name;\n    pj_status_t status;\n\n    if (and_media_factory.pool != NULL) {\n\t/* Already initialized. */\n\treturn PJ_SUCCESS;\n    }\n\n    PJ_LOG(4, (THIS_FILE, \"Initing codec\"));\n\n    /* Create Android MediaCodec codec factory. */\n    and_media_factory.base.op = &and_media_factory_op;\n    and_media_factory.base.factory_data = NULL;\n    and_media_factory.endpt = endpt;\n\n    and_media_factory.pool = pjmedia_endpt_create_pool(endpt,\n                                                   \"Android MediaCodec codecs\",\n                                                   4000, 4000);\n    if (!and_media_factory.pool)\n\treturn PJ_ENOMEM;\n\n    /* Create mutex. */\n    status = pj_mutex_create_simple(and_media_factory.pool,\n                                    \"Android MediaCodec codecs\",\n\t\t\t\t    &and_media_factory.mutex);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Get the codec manager. */\n    codec_mgr = pjmedia_endpt_get_codec_mgr(endpt);\n    if (!codec_mgr) {\n\tstatus = PJ_EINVALIDOP;\n\tgoto on_error;\n    }\n\n#if PJMEDIA_HAS_AND_MEDIA_AMRNB\n    PJ_LOG(4, (THIS_FILE, \"Registering AMRNB codec\"));\n\n    pj_cstr(&codec_name, \"AMR\");\n    status = pjmedia_sdp_neg_register_fmt_match_cb(\n\t\t\t\t\t\t&codec_name,\n\t\t\t\t\t\t&pjmedia_codec_amr_match_sdp);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n#endif\n\n#if PJMEDIA_HAS_AND_MEDIA_AMRWB\n    PJ_LOG(4, (THIS_FILE, \"Registering AMRWB codec\"));\n\n    pj_cstr(&codec_name, \"AMR-WB\");\n    status = pjmedia_sdp_neg_register_fmt_match_cb(\n\t\t\t\t\t\t&codec_name,\n\t\t\t\t\t\t&pjmedia_codec_amr_match_sdp);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n#endif\n\n    /* Suppress compile warning */\n    PJ_UNUSED_ARG(codec_name);\n\n    /* Register codec factory to endpoint. */\n    status = pjmedia_codec_mgr_register_factory(codec_mgr, \n\t\t\t\t\t\t&and_media_factory.base);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Done. */\n    return PJ_SUCCESS;\n\non_error:\n    pj_pool_release(and_media_factory.pool);\n    and_media_factory.pool = NULL;\n    return status;\n}\n\n/*\n * Unregister Android MediaCodec codecs factory from pjmedia endpoint.\n */\nPJ_DEF(pj_status_t) pjmedia_codec_and_media_aud_deinit(void)\n{\n    pjmedia_codec_mgr *codec_mgr;\n    pj_status_t status;\n\n    if (and_media_factory.pool == NULL) {\n\t/* Already deinitialized */\n\treturn PJ_SUCCESS;\n    }\n\n    pj_mutex_lock(and_media_factory.mutex);\n\n    /* Get the codec manager. */\n    codec_mgr = pjmedia_endpt_get_codec_mgr(and_media_factory.endpt);\n    if (!codec_mgr) {\n\tpj_pool_release(and_media_factory.pool);\n\tand_media_factory.pool = NULL;\n\tpj_mutex_unlock(and_media_factory.mutex);\n\treturn PJ_EINVALIDOP;\n    }\n\n    /* Unregister Android MediaCodec codecs factory. */\n    status = pjmedia_codec_mgr_unregister_factory(codec_mgr,\n\t\t\t\t\t\t  &and_media_factory.base);\n\n    /* Destroy mutex. */\n    pj_mutex_unlock(and_media_factory.mutex);\n    pj_mutex_destroy(and_media_factory.mutex);\n    and_media_factory.mutex = NULL;\n\n    /* Destroy pool. */\n    pj_pool_release(and_media_factory.pool);\n    and_media_factory.pool = NULL;\n\n    return status;\n}\n\n/*\n * Check if factory can allocate the specified codec. \n */\nstatic pj_status_t and_media_test_alloc(pjmedia_codec_factory *factory,\n\t\t\t\t\tconst pjmedia_codec_info *info )\n{\n    unsigned i;\n\n    PJ_UNUSED_ARG(factory);\n\n    /* Type MUST be audio. */\n    if (info->type != PJMEDIA_TYPE_AUDIO)\n\treturn PJMEDIA_CODEC_EUNSUP;\n\n    for (i = 0; i < PJ_ARRAY_SIZE(and_media_codec); ++i) {\n\tpj_str_t name = pj_str((char*)and_media_codec[i].name);\n\tif ((pj_stricmp(&info->encoding_name, &name) == 0) &&\n\t    (info->clock_rate == (unsigned)and_media_codec[i].clock_rate) &&\n\t    (info->channel_cnt == (unsigned)and_media_codec[i].channel_count) &&\n\t    (and_media_codec[i].enabled))\n\t{\n\t    return PJ_SUCCESS;\n\t}\n    }\n\n    /* Unsupported, or mode is disabled. */\n    return PJMEDIA_CODEC_EUNSUP;\n}\n\n/*\n * Generate default attribute.\n */\nstatic pj_status_t and_media_default_attr (pjmedia_codec_factory *factory,\n\t\t\t\t\t   const pjmedia_codec_info *id,\n\t\t\t\t\t   pjmedia_codec_param *attr)\n{\n    unsigned i;\n\n    PJ_ASSERT_RETURN(factory==&and_media_factory.base, PJ_EINVAL);\n\n    pj_bzero(attr, sizeof(pjmedia_codec_param));\n\n    for (i = 0; i < PJ_ARRAY_SIZE(and_media_codec); ++i) {\n\tpj_str_t name = pj_str((char*)and_media_codec[i].name);\n\tif ((and_media_codec[i].enabled) &&\n\t    (pj_stricmp(&id->encoding_name, &name) == 0) &&\n\t    (id->clock_rate == (unsigned)and_media_codec[i].clock_rate) &&\n\t    (id->channel_cnt == (unsigned)and_media_codec[i].channel_count) &&\n\t    (id->pt == (unsigned)and_media_codec[i].pt))\n\t{\n\t    attr->info.pt = (pj_uint8_t)id->pt;\n\t    attr->info.channel_cnt = and_media_codec[i].channel_count;\n\t    attr->info.clock_rate = and_media_codec[i].clock_rate;\n\t    attr->info.avg_bps = and_media_codec[i].def_bitrate;\n\t    attr->info.max_bps = and_media_codec[i].max_bitrate;\n\t    attr->info.pcm_bits_per_sample = 16;\n\t    attr->info.frm_ptime =  (pj_uint16_t)\n\t\t\t\t(and_media_codec[i].samples_per_frame * 1000 /\n\t\t\t\tand_media_codec[i].channel_count /\n\t\t\t\tand_media_codec[i].clock_rate);\n\t    attr->setting.frm_per_pkt = and_media_codec[i].frm_per_pkt;\n\n\t    /* Default flags. */\n\t    attr->setting.plc = 1;\n\t    attr->setting.penh= 0;\n\t    attr->setting.vad = 1;\n\t    attr->setting.cng = attr->setting.vad;\n\t    attr->setting.dec_fmtp = and_media_codec[i].dec_fmtp;\n\n\t    return PJ_SUCCESS;\n\t}\n    }\n\n    return PJMEDIA_CODEC_EUNSUP;\n}\n\nstatic pj_bool_t codec_exists(const pj_str_t *codec_name)\n{\n    AMediaCodec *codec;\n    char *codec_txt;\n\n    codec_txt = codec_name->ptr;\n\n    codec = AMediaCodec_createCodecByName(codec_txt);\n    if (!codec) {\n\tPJ_LOG(4, (THIS_FILE, \"Failed creating codec : %.*s\", codec_name->slen,\n\t\t   codec_name->ptr));\n\treturn PJ_FALSE;\n    }\n    AMediaCodec_delete(codec);\n\n    return PJ_TRUE;\n}\n\n/*\n * Enum codecs supported by this factory.\n */\nstatic pj_status_t and_media_enum_codecs(pjmedia_codec_factory *factory,\n\t\t\t\t\t unsigned *count,\n\t\t\t\t\t pjmedia_codec_info codecs[])\n{\n    unsigned max;\n    unsigned i;\n\n    PJ_UNUSED_ARG(factory);\n    PJ_ASSERT_RETURN(codecs && *count > 0, PJ_EINVAL);\n\n    max = *count;\n\n    for (i = 0, *count = 0; i < PJ_ARRAY_SIZE(and_media_codec) &&\n         *count < max; ++i)\n    {\n\tunsigned enc_idx, dec_idx;\n\tpj_str_t *enc_name = NULL;\n\tunsigned num_enc = 0;\n\tpj_str_t *dec_name = NULL;\n\tunsigned num_dec = 0;\n\n\tswitch (and_media_codec[i].codec_id) {\n\n\tcase AND_AUD_CODEC_AMRNB:\n#if PJMEDIA_HAS_AND_MEDIA_AMRNB\n\t    enc_name = &AMRNB_encoder[0];\n\t    dec_name = &AMRNB_decoder[0];\n\t    num_enc = PJ_ARRAY_SIZE(AMRNB_encoder);\n\t    num_dec = PJ_ARRAY_SIZE(AMRNB_decoder);\n#endif\n\t    break;\n\tcase AND_AUD_CODEC_AMRWB:\n#if PJMEDIA_HAS_AND_MEDIA_AMRWB\n\t    enc_name = &AMRWB_encoder[0];\n\t    dec_name = &AMRWB_decoder[0];\n\t    num_enc = PJ_ARRAY_SIZE(AMRWB_encoder);\n\t    num_dec = PJ_ARRAY_SIZE(AMRWB_decoder);\n#endif\n\n\t    break;\n\tdefault:\n\t    continue;\n\t};\n\tif (!enc_name || !dec_name) {\n\t    continue;\n\t}\n\n\tfor (enc_idx = 0; enc_idx < num_enc ;++enc_idx, ++enc_name) {\n\t    if (codec_exists(enc_name)) {\n\t\tbreak;\n\t    }\n\t}\n\tif (enc_idx == num_enc)\n\t    continue;\n\n\tfor (dec_idx = 0; dec_idx < num_dec ;++dec_idx, ++dec_name) {\n\t    if (codec_exists(dec_name)) {\n\t\tbreak;\n\t    }\n\t}\n\tif (dec_idx == num_dec)\n\t    continue;\n\n\tand_media_codec[i].encoder_name = enc_name;\n\tand_media_codec[i].decoder_name = dec_name;\n\tpj_bzero(&codecs[*count], sizeof(pjmedia_codec_info));\n\tcodecs[*count].encoding_name = pj_str((char*)and_media_codec[i].name);\n\tcodecs[*count].pt = and_media_codec[i].pt;\n\tcodecs[*count].type = PJMEDIA_TYPE_AUDIO;\n\tcodecs[*count].clock_rate = and_media_codec[i].clock_rate;\n\tcodecs[*count].channel_cnt = and_media_codec[i].channel_count;\n\tand_media_codec[i].enabled = PJ_TRUE;\n\tPJ_LOG(4, (THIS_FILE, \"Found encoder [%d]: %.*s and decoder: %.*s \",\n\t\t   *count, enc_name->slen, enc_name->ptr, dec_name->slen,\n\t\t   dec_name->ptr));\n\t++*count;\n    }\n\n    return PJ_SUCCESS;\n}\n\nstatic void create_codec(and_media_private_t *and_media_data)\n{\n    char const *enc_name =\n\t\t   and_media_codec[and_media_data->codec_idx].encoder_name->ptr;\n    char const *dec_name =\n\t\t   and_media_codec[and_media_data->codec_idx].decoder_name->ptr;\n\n    if (!and_media_data->enc) {\n\tand_media_data->enc = AMediaCodec_createCodecByName(enc_name);\n\tif (!and_media_data->enc) {\n\t    PJ_LOG(4, (THIS_FILE, \"Failed creating encoder: %s\", enc_name));\n\t}\n\tPJ_LOG(4, (THIS_FILE, \"Done creating encoder: %s [0x%x]\", enc_name,\n\t       and_media_data->enc));\n    }\n\n    if (!and_media_data->dec) {\n\tand_media_data->dec = AMediaCodec_createCodecByName(dec_name);\n\tif (!and_media_data->dec) {\n\t    PJ_LOG(4, (THIS_FILE, \"Failed creating decoder: %s\", dec_name));\n\t}\n\tPJ_LOG(4, (THIS_FILE, \"Done creating decoder: %s [0x%x]\", dec_name,\n\t       and_media_data->dec));\n    }\n}\n\n/*\n * Allocate a new codec instance.\n */\nstatic pj_status_t and_media_alloc_codec(pjmedia_codec_factory *factory,\n\t\t\t\t\t const pjmedia_codec_info *id,\n\t\t\t\t\t pjmedia_codec **p_codec)\n{\n    and_media_private_t *codec_data;\n    pjmedia_codec *codec;\n    int idx;\n    pj_pool_t *pool;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(factory && id && p_codec, PJ_EINVAL);\n    PJ_ASSERT_RETURN(factory == &and_media_factory.base, PJ_EINVAL);\n\n    pj_mutex_lock(and_media_factory.mutex);\n\n    /* Find codec's index */\n    idx = -1;\n    for (i = 0; i < PJ_ARRAY_SIZE(and_media_codec); ++i) {\n\tpj_str_t name = pj_str((char*)and_media_codec[i].name);\n\tif ((pj_stricmp(&id->encoding_name, &name) == 0) &&\n\t    (id->clock_rate == (unsigned)and_media_codec[i].clock_rate) &&\n\t    (id->channel_cnt == (unsigned)and_media_codec[i].channel_count) &&\n\t    (and_media_codec[i].enabled))\n\t{\n\t    idx = i;\n\t    break;\n\t}\n    }\n    if (idx == -1) {\n\t*p_codec = NULL;\n\tpj_mutex_unlock(and_media_factory.mutex);\n\treturn PJMEDIA_CODEC_EFAILED;\n    }\n\n    /* Create pool for codec instance */\n    pool = pjmedia_endpt_create_pool(and_media_factory.endpt, \"andmedaud%p\",\n                                     512, 512);\n    codec = PJ_POOL_ZALLOC_T(pool, pjmedia_codec);\n    PJ_ASSERT_RETURN(codec != NULL, PJ_ENOMEM);\n    codec->op = &and_media_op;\n    codec->factory = factory;\n    codec->codec_data = PJ_POOL_ZALLOC_T(pool, and_media_private_t);\n    codec_data = (and_media_private_t*) codec->codec_data;\n\n    /* Create PLC if codec has no internal PLC */\n    if (!and_media_codec[idx].has_native_plc) {\n\tpj_status_t status;\n\tstatus = pjmedia_plc_create(pool, and_media_codec[idx].clock_rate,\n\t\t\t\t    and_media_codec[idx].samples_per_frame, 0,\n\t\t\t\t    &codec_data->plc);\n\tif (status != PJ_SUCCESS) {\n\t    goto on_error;\n\t}\n    }\n\n    /* Create silence detector if codec has no internal VAD */\n    if (!and_media_codec[idx].has_native_vad) {\n\tpj_status_t status;\n\tstatus = pjmedia_silence_det_create(pool,\n\t\t\t\t\tand_media_codec[idx].clock_rate,\n\t\t\t\t\tand_media_codec[idx].samples_per_frame,\n\t\t\t\t\t&codec_data->vad);\n\tif (status != PJ_SUCCESS) {\n\t    goto on_error;\n\t}\n    }\n\n    codec_data->pool = pool;\n    codec_data->codec_idx = idx;\n\n    create_codec(codec_data);\n    if (!codec_data->enc || !codec_data->dec) {\n\tgoto on_error;\n    }\n    pj_mutex_unlock(and_media_factory.mutex);\n\n    *p_codec = codec;\n    return PJ_SUCCESS;\n\non_error:\n    pj_mutex_unlock(and_media_factory.mutex);\n    and_media_dealloc_codec(factory, codec);\n    return PJMEDIA_CODEC_EFAILED;\n}\n\n/*\n * Free codec.\n */\nstatic pj_status_t and_media_dealloc_codec(pjmedia_codec_factory *factory,\n\t\t\t\t\t   pjmedia_codec *codec )\n{\n    and_media_private_t *codec_data;\n\n    PJ_ASSERT_RETURN(factory && codec, PJ_EINVAL);\n    PJ_ASSERT_RETURN(factory == &and_media_factory.base, PJ_EINVAL);\n\n    /* Close codec, if it's not closed. */\n    codec_data = (and_media_private_t*) codec->codec_data;\n    if (codec_data->enc) {\n        AMediaCodec_stop(codec_data->enc);\n        AMediaCodec_delete(codec_data->enc);\n        codec_data->enc = NULL;\n    }\n\n    if (codec_data->dec) {\n        AMediaCodec_stop(codec_data->dec);\n        AMediaCodec_delete(codec_data->dec);\n        codec_data->dec = NULL;\n    }\n    pj_pool_release(codec_data->pool);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Init codec.\n */\nstatic pj_status_t and_media_codec_init(pjmedia_codec *codec,\n\t\t\t\t        pj_pool_t *pool )\n{\n    PJ_UNUSED_ARG(codec);\n    PJ_UNUSED_ARG(pool);\n    return PJ_SUCCESS;\n}\n\n/*\n * Open codec.\n */\nstatic pj_status_t and_media_codec_open(pjmedia_codec *codec,\n\t\t\t\t\tpjmedia_codec_param *attr)\n{\n    and_media_private_t *codec_data = (and_media_private_t*) codec->codec_data;\n    struct and_media_codec *and_media_data =\n\t\t\t\t\t&and_media_codec[codec_data->codec_idx];\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(codec && attr, PJ_EINVAL);\n    PJ_ASSERT_RETURN(codec_data != NULL, PJ_EINVALIDOP);\n\n    PJ_LOG(5,(THIS_FILE, \"Opening codec..\"));\n\n    codec_data->vad_enabled = (attr->setting.vad != 0);\n    codec_data->plc_enabled = (attr->setting.plc != 0);\n    and_media_data->clock_rate = attr->info.clock_rate;\n\n#if PJMEDIA_HAS_AND_MEDIA_AMRNB\n    if (and_media_data->codec_id == AND_AUD_CODEC_AMRNB ||\n\tand_media_data->codec_id == AND_AUD_CODEC_AMRWB)\n    {\n\tamr_settings_t *s;\n\tpj_uint8_t octet_align = 0;\n\tpj_int8_t enc_mode;\n\tunsigned i;\n\n\tenc_mode = pjmedia_codec_amr_get_mode(attr->info.avg_bps);\n\n\tpj_assert(enc_mode >= 0 && enc_mode <= 8);\n\n\t/* Check AMR specific attributes */\n\tfor (i = 0; i < attr->setting.dec_fmtp.cnt; ++i) {\n\t    /* octet-align, one of the parameters that must have same value\n\t     * in offer & answer (RFC 4867 Section 8.3.1). Just check fmtp\n\t     * in the decoder side, since it's value is guaranteed to fulfil\n\t     * above requirement (by SDP negotiator).\n\t     */\n\t    const pj_str_t STR_FMTP_OCTET_ALIGN = {(char *)\"octet-align\", 11};\n\n\t    if (pj_stricmp(&attr->setting.dec_fmtp.param[i].name,\n\t\t\t   &STR_FMTP_OCTET_ALIGN) == 0)\n\t    {\n\t\toctet_align=(pj_uint8_t)\n\t\t\t    pj_strtoul(&attr->setting.dec_fmtp.param[i].val);\n\t\tbreak;\n\t    }\n\t}\n\tfor (i = 0; i < attr->setting.enc_fmtp.cnt; ++i) {\n\t    /* mode-set, encoding mode is chosen based on local default mode\n\t     * setting:\n\t     * - if local default mode is included in the mode-set, use it\n\t     * - otherwise, find the closest mode to local default mode;\n\t     *   if there are two closest modes, prefer to use the higher\n\t     *   one, e.g: local default mode is 4, the mode-set param\n\t     *   contains '2,3,5,6', then 5 will be chosen.\n\t     */\n\t    const pj_str_t STR_FMTP_MODE_SET = {(char *)\"mode-set\", 8};\n\n\t    if (pj_stricmp(&attr->setting.enc_fmtp.param[i].name,\n\t\t\t   &STR_FMTP_MODE_SET) == 0)\n\t    {\n\t\tconst char *p;\n\t\tpj_size_t l;\n\t\tpj_int8_t diff = 99;\n\n\t\tp = pj_strbuf(&attr->setting.enc_fmtp.param[i].val);\n\t\tl = pj_strlen(&attr->setting.enc_fmtp.param[i].val);\n\n\t\twhile (l--) {\n\t\t    if ((and_media_data->codec_id == AND_AUD_CODEC_AMRNB &&\n\t\t\t *p>='0' && *p<='7') ||\n\t\t        (and_media_data->codec_id == AND_AUD_CODEC_AMRWB &&\n\t\t         *p>='0' && *p<='8'))\n\t\t    {\n\t\t\tpj_int8_t tmp = (pj_int8_t)(*p - '0' - enc_mode);\n\n\t\t\tif (PJ_ABS(diff) > PJ_ABS(tmp) ||\n\t\t\t    (PJ_ABS(diff) == PJ_ABS(tmp) && tmp > diff))\n\t\t\t{\n\t\t\t    diff = tmp;\n\t\t\t    if (diff == 0) break;\n\t\t\t}\n\t\t    }\n\t\t    ++p;\n\t\t}\n\t\tif (diff == 99)\n\t\t    goto on_error;\n\n\t\tenc_mode = (pj_int8_t)(enc_mode + diff);\n\n\t\tbreak;\n\t    }\n\t}\n\t/* Initialize AMR specific settings */\n\ts = PJ_POOL_ZALLOC_T(codec_data->pool, amr_settings_t);\n\tcodec_data->codec_setting = s;\n\n\ts->enc_setting.amr_nb = (pj_uint8_t)\n\t\t\t      (and_media_data->codec_id == AND_AUD_CODEC_AMRNB);\n\ts->enc_setting.octet_aligned = octet_align;\n\ts->enc_setting.reorder = 0;\n\ts->enc_setting.cmr = 15;\n\ts->dec_setting.amr_nb = (pj_uint8_t)\n\t\t\t      (and_media_data->codec_id == AND_AUD_CODEC_AMRNB);\n\ts->dec_setting.octet_aligned = octet_align;\n\ts->dec_setting.reorder = 0;\n\t/* Apply encoder mode/bitrate */\n\ts->enc_mode = enc_mode;\n\n\tPJ_LOG(4, (THIS_FILE, \"Encoder setting octet_aligned=%d reorder=%d\"\n\t\t   \" cmr=%d enc_mode=%d\",\n\t\t   s->enc_setting.octet_aligned, s->enc_setting.reorder,\n\t\t   s->enc_setting.cmr, enc_mode));\n\tPJ_LOG(4, (THIS_FILE, \"Decoder setting octet_aligned=%d reorder=%d\",\n\t\t   s->dec_setting.octet_aligned, s->dec_setting.reorder));\n    }\n#endif\n    status = configure_codec(codec_data, PJ_TRUE);\n    if (status != PJ_SUCCESS) {\n        goto on_error;\n    }\n    status = configure_codec(codec_data, PJ_FALSE);\n    if (status != PJ_SUCCESS) {\n\tgoto on_error;\n    }\n\n    return PJ_SUCCESS;\n\non_error:\n    return PJMEDIA_CODEC_EFAILED;\n}\n\n/*\n * Close codec.\n */\nstatic pj_status_t and_media_codec_close(pjmedia_codec *codec)\n{\n    PJ_UNUSED_ARG(codec);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Modify codec settings.\n */\nstatic pj_status_t  and_media_codec_modify(pjmedia_codec *codec,\n\t\t\t\t\t   const pjmedia_codec_param *attr)\n{\n    and_media_private_t *codec_data = (and_media_private_t*) codec->codec_data;\n\n    codec_data->vad_enabled = (attr->setting.vad != 0);\n    codec_data->plc_enabled = (attr->setting.plc != 0);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Get frames in the packet.\n */\nstatic pj_status_t and_media_codec_parse(pjmedia_codec *codec,\n\t\t\t\t\t void *pkt,\n\t\t\t\t\t pj_size_t pkt_size,\n\t\t\t\t\t const pj_timestamp *ts,\n\t\t\t\t\t unsigned *frame_cnt,\n\t\t\t\t\t pjmedia_frame frames[])\n{\n    and_media_private_t *codec_data = (and_media_private_t*) codec->codec_data;\n    struct and_media_codec *and_media_data =\n\t\t\t\t\t&and_media_codec[codec_data->codec_idx];\n    unsigned count = 0;\n\n    PJ_ASSERT_RETURN(frame_cnt, PJ_EINVAL);\n\n    if (and_media_data->parse != NULL) {\n\treturn and_media_data->parse(codec_data, pkt,  pkt_size, ts, frame_cnt,\n\t\t\t\t     frames);\n    }\n\n    while (pkt_size >= codec_data->frame_size && count < *frame_cnt) {\n\tframes[count].type = PJMEDIA_FRAME_TYPE_AUDIO;\n\tframes[count].buf = pkt;\n\tframes[count].size = codec_data->frame_size;\n\tframes[count].timestamp.u64 = ts->u64 +\n\t\t\t\t      count*and_media_data->samples_per_frame;\n\tpkt = ((char*)pkt) + codec_data->frame_size;\n\tpkt_size -= codec_data->frame_size;\n\t++count;\n    }\n\n    if (pkt_size && count < *frame_cnt) {\n\tframes[count].type = PJMEDIA_FRAME_TYPE_AUDIO;\n\tframes[count].buf = pkt;\n\tframes[count].size = pkt_size;\n\tframes[count].timestamp.u64 = ts->u64 +\n\t\t\t\t      count*and_media_data->samples_per_frame;\n\t++count;\n    }\n\n    *frame_cnt = count;\n    return PJ_SUCCESS;\n}\n\n/*\n * Encode frames.\n */\nstatic pj_status_t and_media_codec_encode(pjmedia_codec *codec,\n\t\t\t\t\t  const struct pjmedia_frame *input,\n\t\t\t\t\t  unsigned output_buf_len,\n\t\t\t\t\t  struct pjmedia_frame *output)\n{\n    and_media_private_t *codec_data = (and_media_private_t*) codec->codec_data;\n    struct and_media_codec *and_media_data =\n\t\t\t\t\t&and_media_codec[codec_data->codec_idx];\n    unsigned samples_per_frame;\n    unsigned nsamples;\n    unsigned nframes;\n    pj_size_t tx = 0;\n    pj_int16_t *pcm_in = (pj_int16_t*)input->buf;\n    pj_uint8_t  *bits_out = (pj_uint8_t*) output->buf;\n    pj_uint8_t pt;\n\n    /* Invoke external VAD if codec has no internal VAD */\n    if (codec_data->vad && codec_data->vad_enabled) {\n\tpj_bool_t is_silence;\n\tpj_int32_t silence_duration;\n\n\tsilence_duration = pj_timestamp_diff32(&codec_data->last_tx, \n\t\t\t\t\t       &input->timestamp);\n\n\tis_silence = pjmedia_silence_det_detect(codec_data->vad, \n\t\t\t\t\t        (const pj_int16_t*) input->buf,\n\t\t\t\t\t\t(input->size >> 1),\n\t\t\t\t\t\tNULL);\n\tif (is_silence &&\n\t    (PJMEDIA_CODEC_MAX_SILENCE_PERIOD == -1 ||\n\t     silence_duration < (PJMEDIA_CODEC_MAX_SILENCE_PERIOD *\n\t \t\t\t (int)and_media_data->clock_rate / 1000)))\n\t{\n\t    output->type = PJMEDIA_FRAME_TYPE_NONE;\n\t    output->buf = NULL;\n\t    output->size = 0;\n\t    output->timestamp = input->timestamp;\n\t    return PJ_SUCCESS;\n\t} else {\n\t    codec_data->last_tx = input->timestamp;\n\t}\n    }\n    nsamples = input->size >> 1;\n    samples_per_frame = and_media_data->samples_per_frame;\n    pt = and_media_data->pt;\n    nframes = nsamples / samples_per_frame;\n\n    PJ_ASSERT_RETURN(nsamples % samples_per_frame == 0, \n\t\t     PJMEDIA_CODEC_EPCMFRMINLEN);\n\n    /* Encode the frames */\n    while (nsamples >= samples_per_frame) {\n        pj_ssize_t buf_idx;\n        unsigned i;\n        pj_size_t output_size;\n        pj_uint8_t *output_buf;\n        AMediaCodecBufferInfo buf_info;\n\n        buf_idx = AMediaCodec_dequeueInputBuffer(codec_data->enc,\n\t\t\t\t\t         CODEC_DEQUEUE_TIMEOUT);\n\n        if (buf_idx >= 0) {\n\t    media_status_t am_status;\n\t    pj_size_t output_size;\n            unsigned input_size = samples_per_frame << 1;\n\n\t    pj_uint8_t *input_buf = AMediaCodec_getInputBuffer(codec_data->enc,\n\t\t\t\t\t\t        buf_idx, &output_size);\n\n\t    if (input_buf && output_size >= input_size) {\n\t        pj_memcpy(input_buf, pcm_in, input_size);\n\n\t        am_status = AMediaCodec_queueInputBuffer(codec_data->enc,\n\t\t\t\t                  buf_idx, 0, input_size, 0, 0);\n\t        if (am_status != AMEDIA_OK) {\n\t\t    PJ_LOG(4, (THIS_FILE, \"Encoder queueInputBuffer return %d\",\n\t\t               am_status));\n\t\t    goto on_return;\n\t        }\n\t    } else {\n\t        if (!input_buf) {\n\t\t    PJ_LOG(4,(THIS_FILE, \"Encoder getInputBuffer \"\n\t\t\t\t         \"returns no input buff\"));\n\t        } else {\n\t\t    PJ_LOG(4,(THIS_FILE, \"Encoder getInputBuffer \"\n\t\t\t\t         \"size: %d, expecting %d.\",\n\t\t\t\t         input_buf, output_size, input_size));\n\t        }\n\t        goto on_return;\n\t    }\n        } else {\n\t    PJ_LOG(4,(THIS_FILE, \"Encoder dequeueInputBuffer failed[%d]\",\n                      buf_idx));\n\t    goto on_return;\n        }\n\n        for (i = 0; i < CODEC_WAIT_RETRY; ++i) {\n\t    buf_idx = AMediaCodec_dequeueOutputBuffer(codec_data->enc,\n\t\t\t\t\t\t      &buf_info,\n\t\t\t\t\t\t      CODEC_DEQUEUE_TIMEOUT);\n\t    if (buf_idx == -1) {\n\t        /* Timeout, wait until output buffer is availble. */\n\t        pj_thread_sleep(CODEC_THREAD_WAIT);\n\t    } else {\n\t        break;\n\t    }\n        }\n\n        if (buf_idx < 0) {\n\t    PJ_LOG(4, (THIS_FILE, \"Encoder dequeueOutputBuffer failed %d\",\n\t\t   buf_idx));\n            goto on_return;\n        }\n\n        output_buf = AMediaCodec_getOutputBuffer(codec_data->enc,\n                                                 buf_idx,\n                                                 &output_size);\n        if (!output_buf) {\n            PJ_LOG(4, (THIS_FILE, \"Encoder failed getting output buffer, \"\n                       \"buffer size=%d, flags %d\",\n                       buf_info.size, buf_info.flags));\n            goto on_return;\n        }\n\n        pj_memcpy(bits_out, output_buf, buf_info.size);\n        AMediaCodec_releaseOutputBuffer(codec_data->enc,\n                                        buf_idx,\n                                        0);\n        bits_out += buf_info.size;\n        tx += buf_info.size;\n\tpcm_in += samples_per_frame;\n\tnsamples -= samples_per_frame;\n    }\n    if (and_media_data->pack != NULL) {\n\tand_media_data->pack(codec_data, nframes, output->buf, &tx,\n\t\t\t     output_buf_len);\n    }\n    /* Check if we don't need to transmit the frame (DTX) */\n    if (tx == 0) {\n\toutput->buf = NULL;\n\toutput->size = 0;\n\toutput->timestamp.u64 = input->timestamp.u64;\n\toutput->type = PJMEDIA_FRAME_TYPE_NONE;\n\treturn PJ_SUCCESS;\n    }\n    output->size = tx;\n    output->type = PJMEDIA_FRAME_TYPE_AUDIO;\n    output->timestamp = input->timestamp;\n\n    return PJ_SUCCESS;\n\non_return:\n    output->size = 0;\n    output->buf = NULL;\n    output->type = PJMEDIA_FRAME_TYPE_NONE;\n    output->timestamp.u64 = input->timestamp.u64;\n    return PJ_SUCCESS;\n}\n\n/*\n * Decode frame.\n */\nstatic pj_status_t and_media_codec_decode(pjmedia_codec *codec,\n\t\t\t\t\t  const struct pjmedia_frame *input,\n\t\t\t\t\t  unsigned output_buf_len,\n\t\t\t\t\t  struct pjmedia_frame *output)\n{\n    and_media_private_t *codec_data = (and_media_private_t*) codec->codec_data;\n    struct and_media_codec *and_media_data =\n\t\t\t\t\t&and_media_codec[codec_data->codec_idx];\n    unsigned samples_per_frame;\n    unsigned i;\n\n    pj_uint8_t pt;\n    pj_ssize_t buf_idx = -1;\n    pj_uint8_t *input_buf;\n    pj_size_t input_size;\n    pj_size_t output_size;\n    media_status_t am_status;\n    AMediaCodecBufferInfo buf_info;\n    pj_uint8_t *output_buf;\n    pjmedia_frame input_;\n\n    pj_bzero(&input_, sizeof(pjmedia_frame));\n    pt = and_media_data->pt;\n    samples_per_frame = and_media_data->samples_per_frame;\n\n    PJ_ASSERT_RETURN(output_buf_len >= samples_per_frame << 1,\n\t\t     PJMEDIA_CODEC_EPCMTOOSHORT);\n\n    if (input->type != PJMEDIA_FRAME_TYPE_AUDIO)\n    {\n\tgoto on_return;\n    }\n\n    buf_idx = AMediaCodec_dequeueInputBuffer(codec_data->dec,\n\t\t\t\t\t     CODEC_DEQUEUE_TIMEOUT);\n\n    if (buf_idx < 0) {\n\tPJ_LOG(4,(THIS_FILE, \"Decoder dequeueInputBuffer failed return %d\",\n\t\t  buf_idx));\n\tgoto on_return;\n    }\n\n    input_buf = AMediaCodec_getInputBuffer(codec_data->dec,\n\t\t\t\t\t   buf_idx,\n\t\t\t\t\t   &input_size);\n    if (input_buf == 0) {\n\tPJ_LOG(4,(THIS_FILE, \"Decoder getInputBuffer failed \"\n\t\t  \"return input_buf=%d, size=%d\", input_buf, input_size));\n\tgoto on_return;\n    }\n\n    if (and_media_data->predecode) {\n\tinput_.buf = input_buf;\n\tand_media_data->predecode(codec_data, input, &input_);\n    } else {\n\tinput_.size = input->size;\n\tpj_memcpy(input_buf, input->buf, input->size);\n    }\n\n    am_status = AMediaCodec_queueInputBuffer(codec_data->dec,\n\t\t\t\t\t     buf_idx,\n\t\t\t\t\t     0,\n\t\t\t\t\t     input_.size,\n\t\t\t\t\t     input->timestamp.u32.lo,\n\t\t\t\t\t     0);\n    if (am_status != AMEDIA_OK) {\n\tPJ_LOG(4,(THIS_FILE, \"Decoder queueInputBuffer failed return %d\",\n\t\t  am_status));\n\tgoto on_return;\n    }\n\n    for (i = 0; i < CODEC_WAIT_RETRY; ++i) {\n\tbuf_idx = AMediaCodec_dequeueOutputBuffer(codec_data->dec,\n\t\t\t\t\t\t  &buf_info,\n\t\t\t\t\t\t  CODEC_DEQUEUE_TIMEOUT);\n\tif (buf_idx == -1) {\n\t    /* Timeout, wait until output buffer is availble. */\n\t    PJ_LOG(5, (THIS_FILE, \"Decoder dequeueOutputBuffer timeout[%d]\",\n\t\t       i+1));\n\t    pj_thread_sleep(CODEC_THREAD_WAIT);\n\t} else {\n\t    break;\n\t}\n    }\n    if (buf_idx < 0) {\n\tPJ_LOG(5, (THIS_FILE, \"Decoder dequeueOutputBuffer failed [%d]\",\n\t\t   buf_idx));\n\tgoto on_return;\n    }\n\n    output_buf = AMediaCodec_getOutputBuffer(codec_data->dec,\n\t\t\t\t\t     buf_idx,\n\t\t\t\t\t     &output_size);\n    if (output_buf == NULL) {\n\tam_status = AMediaCodec_releaseOutputBuffer(codec_data->dec,\n\t\t\t\t\tbuf_idx,\n\t\t\t\t\t0);\n\tif (am_status != AMEDIA_OK) {\n\t    PJ_LOG(4,(THIS_FILE, \"Decoder releaseOutputBuffer failed %d\",\n\t\t      am_status));\n\t}\n\tPJ_LOG(4,(THIS_FILE, \"Decoder getOutputBuffer failed\"));\n\tgoto on_return;\n    }\n    pj_memcpy(output->buf, output_buf, buf_info.size);\n    output->type = PJMEDIA_FRAME_TYPE_AUDIO;\n    output->size = buf_info.size;\n    output->timestamp.u64 = input->timestamp.u64;\n    am_status = AMediaCodec_releaseOutputBuffer(codec_data->dec,\n\t\t\t\t\t\tbuf_idx,\n\t\t\t\t\t\t0);\n\n    /* Invoke external PLC if codec has no internal PLC */\n    if (codec_data->plc && codec_data->plc_enabled)\n\tpjmedia_plc_save(codec_data->plc, (pj_int16_t*)output->buf);\n\n    return PJ_SUCCESS;\n\non_return:\n    pjmedia_zero_samples((pj_int16_t*)output->buf, samples_per_frame);\n    output->size = samples_per_frame << 1;\n    output->timestamp.u64 = input->timestamp.u64;\n    output->type = PJMEDIA_FRAME_TYPE_AUDIO;\n    return PJ_SUCCESS;\n}\n\n/* \n * Recover lost frame.\n */\nstatic pj_status_t  and_media_codec_recover(pjmedia_codec *codec,\n\t\t\t\t\t    unsigned output_buf_len,\n\t\t\t\t\t    struct pjmedia_frame *output)\n{\n    and_media_private_t *codec_data = (and_media_private_t*) codec->codec_data;\n    struct and_media_codec *and_media_data =\n\t\t\t\t\t&and_media_codec[codec_data->codec_idx];\n    unsigned samples_per_frame;\n    pj_bool_t generate_plc = (codec_data->plc_enabled && codec_data->plc);\n\n    PJ_UNUSED_ARG(output_buf_len);\n\n    samples_per_frame = and_media_data->samples_per_frame;\n    output->type = PJMEDIA_FRAME_TYPE_AUDIO;\n    output->size = samples_per_frame << 1;\n\n    if (generate_plc)\n\tpjmedia_plc_generate(codec_data->plc, (pj_int16_t*)output->buf);\n    else\n\tpjmedia_zero_samples((pj_int16_t*)output->buf, samples_per_frame);\n\n    return PJ_SUCCESS;\n}\n\n\n#endif\t/* PJMEDIA_HAS_ANDROID_MEDIACODEC */\n\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia-codec/ipp_codecs.h>\n#include <pjmedia-codec/amr_sdp_match.h>\n#include <pjmedia-codec/g7221_sdp_match.h>\n#include <pjmedia/codec.h>\n#include <pjmedia/errno.h>\n#include <pjmedia/endpoint.h>\n#include <pjmedia/plc.h>\n#include <pjmedia/port.h>\n#include <pjmedia/silencedet.h>\n#include <pj/assert.h>\n#include <pj/log.h>\n#include <pj/math.h>\n#include <pj/pool.h>\n#include <pj/string.h>\n#include <pj/os.h>\n\n\n/*\n * Only build this file if PJMEDIA_HAS_INTEL_IPP != 0\n */\n#if defined(PJMEDIA_HAS_INTEL_IPP) && PJMEDIA_HAS_INTEL_IPP != 0\n\n#include <usc.h>\n#include <ippversion.h>\n\n#define THIS_FILE   \"ipp_codecs.c\"\n\n\n/* Prototypes for IPP codecs factory */\nstatic pj_status_t ipp_test_alloc( pjmedia_codec_factory *factory, \n\t\t\t\t   const pjmedia_codec_info *id );\nstatic pj_status_t ipp_default_attr( pjmedia_codec_factory *factory, \n\t\t\t\t     const pjmedia_codec_info *id, \n\t\t\t\t     pjmedia_codec_param *attr );\nstatic pj_status_t ipp_enum_codecs( pjmedia_codec_factory *factory, \n\t\t\t\t    unsigned *count, \n\t\t\t\t    pjmedia_codec_info codecs[]);\nstatic pj_status_t ipp_alloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t    const pjmedia_codec_info *id, \n\t\t\t\t    pjmedia_codec **p_codec);\nstatic pj_status_t ipp_dealloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t      pjmedia_codec *codec );\n\n/* Prototypes for IPP codecs implementation. */\nstatic pj_status_t  ipp_codec_init( pjmedia_codec *codec, \n\t\t\t\t    pj_pool_t *pool );\nstatic pj_status_t  ipp_codec_open( pjmedia_codec *codec, \n\t\t\t\t    pjmedia_codec_param *attr );\nstatic pj_status_t  ipp_codec_close( pjmedia_codec *codec );\nstatic pj_status_t  ipp_codec_modify(pjmedia_codec *codec, \n\t\t\t\t     const pjmedia_codec_param *attr );\nstatic pj_status_t  ipp_codec_parse( pjmedia_codec *codec,\n\t\t\t\t     void *pkt,\n\t\t\t\t     pj_size_t pkt_size,\n\t\t\t\t     const pj_timestamp *ts,\n\t\t\t\t     unsigned *frame_cnt,\n\t\t\t\t     pjmedia_frame frames[]);\nstatic pj_status_t  ipp_codec_encode( pjmedia_codec *codec, \n\t\t\t\t      const struct pjmedia_frame *input,\n\t\t\t\t      unsigned output_buf_len, \n\t\t\t\t      struct pjmedia_frame *output);\nstatic pj_status_t  ipp_codec_decode( pjmedia_codec *codec, \n\t\t\t\t      const struct pjmedia_frame *input,\n\t\t\t\t      unsigned output_buf_len, \n\t\t\t\t      struct pjmedia_frame *output);\nstatic pj_status_t  ipp_codec_recover(pjmedia_codec *codec, \n\t\t\t\t      unsigned output_buf_len, \n\t\t\t\t      struct pjmedia_frame *output);\n\n/* Definition for IPP codecs operations. */\nstatic pjmedia_codec_op ipp_op = \n{\n    &ipp_codec_init,\n    &ipp_codec_open,\n    &ipp_codec_close,\n    &ipp_codec_modify,\n    &ipp_codec_parse,\n    &ipp_codec_encode,\n    &ipp_codec_decode,\n    &ipp_codec_recover\n};\n\n/* Definition for IPP codecs factory operations. */\nstatic pjmedia_codec_factory_op ipp_factory_op =\n{\n    &ipp_test_alloc,\n    &ipp_default_attr,\n    &ipp_enum_codecs,\n    &ipp_alloc_codec,\n    &ipp_dealloc_codec,\n    &pjmedia_codec_ipp_deinit\n};\n\n/* IPP codecs factory */\nstatic struct ipp_factory {\n    pjmedia_codec_factory    base;\n    pjmedia_endpt\t    *endpt;\n    pj_pool_t\t\t    *pool;\n    pj_mutex_t\t\t    *mutex;\n    unsigned\t\t     g7221_pcm_shift;\n} ipp_factory;\n\n/* IPP codecs private data. */\ntypedef struct ipp_private {\n    int\t\t\t codec_idx;\t    /**< Codec index.\t\t    */\n    void\t\t*codec_setting;\t    /**< Specific codec setting.    */\n    pj_pool_t\t\t*pool;\t\t    /**< Pool for each instance.    */\n\n    USC_Handle\t\t enc;\t\t    /**< Encoder state.\t\t    */\n    USC_Handle\t\t dec;\t\t    /**< Decoder state.\t\t    */\n    USC_CodecInfo\t*info;\t\t    /**< Native codec info.\t    */\n    pj_uint16_t\t\t frame_size;\t    /**< Bitstream frame size.\t    */\n\n    pj_bool_t\t\t plc_enabled;\t    /**< PLC enabled flag.\t    */\n    pjmedia_plc\t\t*plc;\t\t    /**< PJMEDIA PLC engine, NULL if \n\t\t\t\t\t\t codec has internal PLC.    */\n\n    pj_bool_t\t\t vad_enabled;\t    /**< VAD enabled flag.\t    */\n    pjmedia_silence_det\t*vad;\t\t    /**< PJMEDIA VAD engine, NULL if \n\t\t\t\t\t\t codec has internal VAD.    */\n    pj_timestamp\t last_tx;\t    /**< Timestamp of last transmit.*/\n\n    unsigned\t\t g7221_pcm_shift;   /**< G722.1 PCM level adjustment*/\n} ipp_private_t;\n\n\n/* USC codec implementations. */\nextern USC_Fxns USC_G729AFP_Fxns;\nextern USC_Fxns USC_G729I_Fxns;\nextern USC_Fxns USC_G723_Fxns;\nextern USC_Fxns USC_G726_Fxns;\nextern USC_Fxns USC_G728_Fxns;\nextern USC_Fxns USC_G722_Fxns;\nextern USC_Fxns USC_GSMAMR_Fxns;\nextern USC_Fxns USC_AMRWB_Fxns;\nextern USC_Fxns USC_AMRWBE_Fxns;\n\n\n/* CUSTOM CALLBACKS */\n\n/* This callback is useful for translating RTP frame into USC frame, e.g:\n * reassigning frame attributes, reorder bitstream. Default behaviour of\n * the translation is just setting the USC frame buffer & its size as \n * specified in RTP frame, setting USC frame frametype to 0, setting bitrate\n * of USC frame to bitrate info of codec_data. Implement this callback when \n * the default behaviour is unapplicable.\n */\ntypedef void (*predecode_cb)(ipp_private_t *codec_data,\n\t\t\t     const pjmedia_frame *rtp_frame,\n\t\t\t     USC_Bitstream *usc_frame);\n\n/* Parse frames from a packet. Default behaviour of frame parsing is \n * just separating frames based on calculating frame length derived \n * from bitrate. Implement this callback when the default behaviour is \n * unapplicable.\n */\ntypedef pj_status_t (*parse_cb)(ipp_private_t *codec_data, void *pkt, \n\t\t\t\tpj_size_t pkt_size, const pj_timestamp *ts,\n\t\t\t\tunsigned *frame_cnt, pjmedia_frame frames[]);\n\n/* Pack frames into a packet. Default behaviour of packing frames is \n * just stacking the frames with octet aligned without adding any \n * payload header. Implement this callback when the default behaviour is\n * unapplicable.\n */\ntypedef pj_status_t (*pack_cb)(ipp_private_t *codec_data, void *pkt, \n\t\t\t       pj_size_t *pkt_size, pj_size_t max_pkt_size);\n\n\n\n/* Custom callback implementations. */\nstatic    void predecode_g723( ipp_private_t *codec_data,\n\t\t\t       const pjmedia_frame *rtp_frame,\n\t\t\t       USC_Bitstream *usc_frame);\nstatic pj_status_t parse_g723( ipp_private_t *codec_data, void *pkt, \n\t\t\t       pj_size_t pkt_size, const pj_timestamp *ts,\n\t\t\t       unsigned *frame_cnt, pjmedia_frame frames[]);\n\nstatic void predecode_g729( ipp_private_t *codec_data,\n\t\t\t    const pjmedia_frame *rtp_frame,\n\t\t\t    USC_Bitstream *usc_frame);\n\nstatic    void predecode_amr( ipp_private_t *codec_data,\n\t\t\t      const pjmedia_frame *rtp_frame,\n\t\t\t      USC_Bitstream *usc_frame);\nstatic pj_status_t parse_amr( ipp_private_t *codec_data, void *pkt, \n\t\t\t      pj_size_t pkt_size, const pj_timestamp *ts,\n\t\t\t      unsigned *frame_cnt, pjmedia_frame frames[]);\nstatic  pj_status_t pack_amr( ipp_private_t *codec_data, void *pkt, \n\t\t\t      pj_size_t *pkt_size, pj_size_t max_pkt_size);\n\nstatic    void predecode_g7221( ipp_private_t *codec_data,\n\t\t\t\tconst pjmedia_frame *rtp_frame,\n\t\t\t\tUSC_Bitstream *usc_frame);\nstatic  pj_status_t pack_g7221( ipp_private_t *codec_data, void *pkt, \n\t\t\t        pj_size_t *pkt_size, pj_size_t max_pkt_size);\n\n/* IPP codec implementation descriptions. */\nstatic struct ipp_codec {\n    int\t\t     enabled;\t\t/* Is this codec enabled?\t    */\n    const char\t    *name;\t\t/* Codec name.\t\t\t    */\n    pj_uint8_t\t     pt;\t\t/* Payload type.\t\t    */\n    USC_Fxns\t    *fxns;\t\t/* USC callback functions.\t    */\n    unsigned\t     clock_rate;\t/* Codec's clock rate.\t\t    */\n    unsigned\t     channel_count;\t/* Codec's channel count.\t    */\n    unsigned\t     samples_per_frame;\t/* Codec's samples count.\t    */\n\n    unsigned\t     def_bitrate;\t/* Default bitrate of this codec.   */\n    unsigned\t     max_bitrate;\t/* Maximum bitrate of this codec.   */\n    pj_uint8_t\t     frm_per_pkt;\t/* Default num of frames per packet.*/\n    int\t\t     has_native_vad;\t/* Codec has internal VAD?\t    */\n    int\t\t     has_native_plc;\t/* Codec has internal PLC?\t    */\n\n    predecode_cb     predecode;\t\t/* Callback to translate RTP frame\n\t\t\t\t\t   into USC frame.\t\t    */\n    parse_cb\t     parse;\t\t/* Callback to parse bitstream.\t    */\n    pack_cb\t     pack;\t\t/* Callback to pack bitstream.\t    */\n\n    pjmedia_codec_fmtp dec_fmtp;\t/* Decoder's fmtp params.\t    */\n}\n\nipp_codec[] = \n{\n#   if PJMEDIA_HAS_INTEL_IPP_CODEC_AMR\n    {1, \"AMR\",\t    PJMEDIA_RTP_PT_AMR,       &USC_GSMAMR_Fxns,  8000, 1, 160, \n\t\t    7400, 12200, 2, 1, 1, \n\t\t    &predecode_amr, &parse_amr, &pack_amr,\n\t\t    {1, {{{\"octet-align\", 11}, {\"1\", 1}}} }\n    },\n#   endif\n\n#   if PJMEDIA_HAS_INTEL_IPP_CODEC_AMRWB\n    {1, \"AMR-WB\",   PJMEDIA_RTP_PT_AMRWB,     &USC_AMRWB_Fxns,  16000, 1, 320,\n\t\t    15850, 23850, 2, 1, 1, \n\t\t    &predecode_amr, &parse_amr, &pack_amr,\n\t\t    {1, {{{\"octet-align\", 11}, {\"1\", 1}}} }\n    },\n#   endif\n\n#   if PJMEDIA_HAS_INTEL_IPP_CODEC_G729\n#\tif defined(PJ_HAS_FLOATING_POINT) && (PJ_HAS_FLOATING_POINT != 0)\n    {1, \"G729\",\t    PJMEDIA_RTP_PT_G729,      &USC_G729AFP_Fxns, 8000, 1,  80,\n\t\t    8000, 11800, 2, 1, 1, \n\t\t    &predecode_g729, NULL, NULL\n    },\n#\telse\n    {1, \"G729\",\t    PJMEDIA_RTP_PT_G729,      &USC_G729I_Fxns,\t 8000, 1,  80,\n\t\t    8000, 11800, 2, 1, 1, \n\t\t    &predecode_g729, NULL, NULL\n    },\n#\tendif\n#   endif\n\n#   if PJMEDIA_HAS_INTEL_IPP_CODEC_G723_1\n    /* This is actually G.723.1 */\n    {1, \"G723\",\t    PJMEDIA_RTP_PT_G723,      &USC_G723_Fxns,\t 8000, 1, 240,  \n\t\t    6300,  6300, 1, 1, 1, \n\t\t    &predecode_g723, &parse_g723, NULL\n    },\n#   endif\n\n#   if PJMEDIA_HAS_INTEL_IPP_CODEC_G726\n    {0, \"G726-16\",  PJMEDIA_RTP_PT_G726_16,   &USC_G726_Fxns,\t 8000, 1,  80, \n\t\t    16000, 16000, 2, 0, 0,\n\t\t    NULL, NULL, NULL\n    },\n    {0, \"G726-24\",  PJMEDIA_RTP_PT_G726_24,   &USC_G726_Fxns,\t 8000, 1,  80, \n\t\t    24000, 24000, 2, 0, 0,\n\t\t    NULL, NULL, NULL\n    },\n    {1, \"G726-32\",  PJMEDIA_RTP_PT_G726_32,   &USC_G726_Fxns,\t 8000, 1,  80, \n\t\t    32000, 32000, 2, 0, 0,\n\t\t    NULL, NULL, NULL\n    },\n    {0, \"G726-40\",  PJMEDIA_RTP_PT_G726_40,   &USC_G726_Fxns,\t 8000, 1,  80, \n\t\t    40000, 40000, 2, 0, 0,\n\t\t    NULL, NULL, NULL\n    },\n    /* Old definition of G726-32 */\n    {1, \"G721\",\t    PJMEDIA_RTP_PT_G721,      &USC_G726_Fxns,\t 8000, 1,  80, \n\t\t    32000, 32000, 2, 0, 0,\n\t\t    NULL, NULL, NULL\n    },\n#   endif\n\n#   if PJMEDIA_HAS_INTEL_IPP_CODEC_G728\n    {1, \"G728\",\t    PJMEDIA_RTP_PT_G728,      &USC_G728_Fxns,\t 8000, 1,  80, \n\t\t    16000, 16000, 2, 0, 1,\n\t\t    NULL, NULL, NULL\n    },\n#   endif\n\n#   if PJMEDIA_HAS_INTEL_IPP_CODEC_G722_1\n    {0, \"G7221\",    PJMEDIA_RTP_PT_G722_1_16, &USC_G722_Fxns,\t16000, 1, 320, \n\t\t    16000, 16000, 1, 0, 1,\n\t\t    predecode_g7221, NULL, pack_g7221,\n\t\t    {1, {{{\"bitrate\", 7}, {\"16000\", 5}}} }\n    },\n    {1, \"G7221\",    PJMEDIA_RTP_PT_G722_1_24, &USC_G722_Fxns,\t16000, 1, 320, \n\t\t    24000, 24000, 1, 0, 1,\n\t\t    predecode_g7221, NULL, pack_g7221,\n\t\t    {1, {{{\"bitrate\", 7}, {\"24000\", 5}}} }\n    },\n    {1, \"G7221\",    PJMEDIA_RTP_PT_G722_1_32, &USC_G722_Fxns,\t16000, 1, 320, \n\t\t    32000, 32000, 1, 0, 1,\n\t\t    predecode_g7221, NULL, pack_g7221,\n\t\t    {1, {{{\"bitrate\", 7}, {\"32000\", 5}}} }\n    },\n#   endif\n};\n\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_G729\n\nstatic void predecode_g729( ipp_private_t *codec_data,\n\t\t\t    const pjmedia_frame *rtp_frame,\n\t\t\t    USC_Bitstream *usc_frame)\n{\n    switch (rtp_frame->size) {\n    case 2:\n\t/* SID */\n\tusc_frame->frametype = 1;\n\tusc_frame->bitrate = codec_data->info->params.modes.bitrate;\n\tbreak;\n    case 8:  \n\t/* G729D */\n\tusc_frame->frametype = 2;\n\tusc_frame->bitrate = 6400;\n\tbreak;\n    case 10: \n\t/* G729 */\n\tusc_frame->frametype = 3;\n\tusc_frame->bitrate = 8000;\n\tbreak;\n    case 15: \n\t/* G729E */\n\tusc_frame->frametype = 4;\n\tusc_frame->bitrate = 11800;\n\tbreak;\n    default: \n\tusc_frame->frametype = 0;\n\tusc_frame->bitrate = 0;\n\tbreak;\n    }\n\n    usc_frame->pBuffer = rtp_frame->buf;\n    usc_frame->nbytes = rtp_frame->size;\n}\n\n#endif /* PJMEDIA_HAS_INTEL_IPP_CODEC_G729 */\n\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_G723_1\n\nstatic    void predecode_g723( ipp_private_t *codec_data,\n\t\t\t       const pjmedia_frame *rtp_frame,\n\t\t\t       USC_Bitstream *usc_frame)\n{\n    int i, HDR = 0;\n    pj_uint8_t *f = (pj_uint8_t*)rtp_frame->buf;\n\n    PJ_UNUSED_ARG(codec_data);\n\n    for (i = 0; i < 2; ++i){\n\tint tmp;\n\ttmp = (f[0] >> (i & 0x7)) & 1;\n\tHDR +=  tmp << i ;\n    }\n\n    usc_frame->pBuffer = rtp_frame->buf;\n    usc_frame->nbytes = rtp_frame->size;\n    usc_frame->bitrate = HDR == 0? 6300 : 5300;\n    usc_frame->frametype = 0;\n}\n\nstatic pj_status_t parse_g723(ipp_private_t *codec_data, void *pkt, \n\t\t\t      pj_size_t pkt_size, const pj_timestamp *ts,\n\t\t\t      unsigned *frame_cnt, pjmedia_frame frames[])\n{\n    unsigned count = 0;\n    pj_uint8_t *f = (pj_uint8_t*)pkt;\n\n    while (pkt_size && count < *frame_cnt) {\n\tint framesize, i, j;\n\tint HDR = 0;\n\n\tfor (i = 0; i < 2; ++i){\n\t    j = (f[0] >> (i & 0x7)) & 1;\n\t    HDR +=  j << i ;\n\t}\n\n\tif (HDR == 0)\n\t    framesize = 24;\n\telse if (HDR == 1)\n\t    framesize = 20;\n\telse if (HDR == 2)\n\t    framesize = 4;\n\telse if (HDR == 3)\n\t    framesize = 1;\n\telse {\n\t    pj_assert(!\"Unknown G723.1 frametype, packet may be corrupted!\");\n\t    return PJMEDIA_CODEC_EINMODE;\n\t}\n\n\tframes[count].type = PJMEDIA_FRAME_TYPE_AUDIO;\n\tframes[count].buf = f;\n\tframes[count].size = framesize;\n\tframes[count].timestamp.u64 = ts->u64 + count * \n\t\t\tipp_codec[codec_data->codec_idx].samples_per_frame;\n\n\tf += framesize;\n\tpkt_size -= framesize;\n\n\t++count;\n    }\n\n    *frame_cnt = count;\n    return PJ_SUCCESS;\n}\n\n#endif /* PJMEDIA_HAS_INTEL_IPP_CODEC_G723_1 */\n\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_AMR || PJMEDIA_HAS_INTEL_IPP_CODEC_AMRWB\n\n#include <pjmedia-codec/amr_helper.h>\n\ntypedef struct amr_settings_t {\n    pjmedia_codec_amr_pack_setting enc_setting;\n    pjmedia_codec_amr_pack_setting dec_setting;\n    pj_int8_t enc_mode;\n} amr_settings_t;\n\n\n/* Rearrange AMR bitstream and convert RTP frame into USC frame:\n * - make the start_bit to be 0\n * - if it is speech frame, reorder bitstream from sensitivity bits order\n *   to encoder bits order.\n * - set the appropriate value of usc_frame.\n */\nstatic void predecode_amr( ipp_private_t *codec_data,\n\t\t\t   const pjmedia_frame *rtp_frame,\n\t\t\t   USC_Bitstream *usc_frame)\n{\n    pjmedia_frame frame;\n    pjmedia_codec_amr_bit_info *info;\n    pjmedia_codec_amr_pack_setting *setting;\n\n    setting = &((amr_settings_t*)codec_data->codec_setting)->dec_setting;\n\n    frame = *rtp_frame;\n    pjmedia_codec_amr_predecode(rtp_frame, setting, &frame);\n    info = (pjmedia_codec_amr_bit_info*) &frame.bit_info;\n\n    usc_frame->pBuffer = frame.buf;\n    usc_frame->nbytes = frame.size;\n    if (info->mode != -1) {\n\tusc_frame->bitrate = setting->amr_nb? \n\t\t\t     pjmedia_codec_amrnb_bitrates[info->mode]:\n\t\t\t     pjmedia_codec_amrwb_bitrates[info->mode];\n    } else {\n\tusc_frame->bitrate = 0;\n    }\n\n    if (frame.size > 5) {\n\t/* Speech */\n\tif (info->good_quality)\n\t    usc_frame->frametype = 0;\n\telse\n\t    usc_frame->frametype = setting->amr_nb ? 5 : 6;\n    } else if (frame.size == 5) {\n\t/* SID */\n\tif (info->good_quality) {\n\t    usc_frame->frametype = info->STI? 2 : 1;\n\t} else {\n\t    usc_frame->frametype = setting->amr_nb ? 6 : 7;\n\t}\n    } else {\n\t/* no data */\n\tusc_frame->frametype = 3;\n    }\n}\n\n/* Pack AMR payload */\nstatic pj_status_t pack_amr(ipp_private_t *codec_data, void *pkt, \n\t\t\t    pj_size_t *pkt_size, pj_size_t max_pkt_size)\n{\n    enum {MAX_FRAMES_PER_PACKET = PJMEDIA_MAX_FRAME_DURATION_MS / 20};\n\n    pjmedia_frame frames[MAX_FRAMES_PER_PACKET];\n    unsigned nframes = 0;\n    pjmedia_codec_amr_bit_info *info;\n    pj_uint8_t *r; /* Read cursor */\n    pj_uint8_t SID_FT;\n    pjmedia_codec_amr_pack_setting *setting;\n    const pj_uint8_t *framelen_tbl;\n\n    setting = &((amr_settings_t*)codec_data->codec_setting)->enc_setting;\n    framelen_tbl = setting->amr_nb? pjmedia_codec_amrnb_framelen:\n\t\t\t\t    pjmedia_codec_amrwb_framelen;\n\n    SID_FT = (pj_uint8_t)(setting->amr_nb? 8 : 9);\n\n    /* Align pkt buf right */\n    r = (pj_uint8_t*)pkt + max_pkt_size - *pkt_size;\n    pj_memmove(r, pkt, *pkt_size);\n\n    /* Get frames */\n    for (;;) {\n\tpj_bool_t eof;\n\tpj_uint16_t info_;\n\n\tinfo_ = *((pj_uint16_t*)r);\n\teof = ((info_ & 0x40) != 0);\n\n\tinfo = (pjmedia_codec_amr_bit_info*) &frames[nframes].bit_info;\n\tpj_bzero(info, sizeof(*info));\n\tinfo->frame_type = (pj_uint8_t)(info_ & 0x0F);\n\tinfo->good_quality = (pj_uint8_t)((info_ & 0x80) == 0);\n\tinfo->mode = (pj_int8_t) ((info_ >> 8) & 0x0F);\n\tinfo->STI = (pj_uint8_t)((info_ >> 5) & 1);\n\n\tframes[nframes].buf = r + 2;\n\tframes[nframes].size = info->frame_type <= SID_FT ?\n\t\t\t       framelen_tbl[info->frame_type] : 0;\n\n\tr += frames[nframes].size + 2;\n\n\t/* Last frame */\n\tif (++nframes >= MAX_FRAMES_PER_PACKET || eof)\n\t    break;\n    }\n\n    /* Pack */\n    *pkt_size = max_pkt_size;\n    return pjmedia_codec_amr_pack(frames, nframes, setting, pkt, pkt_size);\n}\n\n\n/* Parse AMR payload into frames. */\nstatic pj_status_t parse_amr(ipp_private_t *codec_data, void *pkt, \n\t\t\t     pj_size_t pkt_size, const pj_timestamp *ts,\n\t\t\t     unsigned *frame_cnt, pjmedia_frame frames[])\n{\n    amr_settings_t* s = (amr_settings_t*)codec_data->codec_setting;\n    pjmedia_codec_amr_pack_setting *setting;\n    pj_status_t status;\n    pj_uint8_t cmr;\n\n    setting = &s->dec_setting;\n\n    status = pjmedia_codec_amr_parse(pkt, pkt_size, ts, setting, frames, \n\t\t\t\t     frame_cnt, &cmr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Check Change Mode Request. */\n    if (((setting->amr_nb && cmr <= 7) || (!setting->amr_nb && cmr <= 8)) &&\n\ts->enc_mode != cmr)\n    {\n\tstruct ipp_codec *ippc = &ipp_codec[codec_data->codec_idx];\n\n\ts->enc_mode = cmr;\n\tcodec_data->info->params.modes.bitrate = s->enc_setting.amr_nb?\n\t\t\t\tpjmedia_codec_amrnb_bitrates[s->enc_mode] :\n\t\t\t\tpjmedia_codec_amrwb_bitrates[s->enc_mode];\n\tippc->fxns->std.Control(&codec_data->info->params.modes, \n\t\t\t\tcodec_data->enc);\n\n\tPJ_LOG(4,(THIS_FILE, \"AMR%s switched encoding mode to: %d (%dbps)\",\n\t\t  (s->enc_setting.amr_nb?\"\":\"-WB\"),\n\t\t  s->enc_mode,\n\t\t  codec_data->info->params.modes.bitrate));\n    }\n\n    return PJ_SUCCESS;\n}\n\n#endif /* PJMEDIA_HAS_INTEL_IPP_CODEC_AMR */\n\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_G722_1\n\nstatic void predecode_g7221( ipp_private_t *codec_data,\n\t\t\t     const pjmedia_frame *rtp_frame,\n\t\t\t     USC_Bitstream *usc_frame)\n{\n    usc_frame->pBuffer = (char*)rtp_frame->buf;\n    usc_frame->nbytes = rtp_frame->size;\n    usc_frame->frametype = 0;\n    usc_frame->bitrate = codec_data->info->params.modes.bitrate;\n\n#if defined(PJ_IS_LITTLE_ENDIAN) && PJ_IS_LITTLE_ENDIAN!=0\n    {\n\tpj_uint16_t *p, *p_end;\n\n\tp = (pj_uint16_t*)rtp_frame->buf;\n\tp_end = p + rtp_frame->size/2;\n\twhile (p < p_end) {\n\t    *p = pj_ntohs(*p);\n\t    ++p;\n\t}\n    }\n#endif\n}\n\nstatic pj_status_t pack_g7221( ipp_private_t *codec_data, void *pkt, \n\t\t\t       pj_size_t *pkt_size, pj_size_t max_pkt_size)\n{\n    PJ_UNUSED_ARG(codec_data);\n    PJ_UNUSED_ARG(max_pkt_size);\n\n#if defined(PJ_IS_LITTLE_ENDIAN) && PJ_IS_LITTLE_ENDIAN!=0\n    {\n\tpj_uint16_t *p, *p_end;\n\n\tp = (pj_uint16_t*)pkt;\n\tp_end = p + *pkt_size/2;\n\twhile (p < p_end) {\n\t    *p = pj_htons(*p);\n\t    ++p;\n\t}\n    }\n#else\n    PJ_UNUSED_ARG(pkt);\n    PJ_UNUSED_ARG(pkt_size);\n#endif\n\n    return PJ_SUCCESS;\n}\n\n\n#include <pjmedia-codec/g7221.h>\n\n\nPJ_DEF(pj_status_t) pjmedia_codec_g7221_set_pcm_shift(int val)\n{\n    PJ_ASSERT_RETURN(val >= 0, PJ_EINVAL);\n\n    ipp_factory.g7221_pcm_shift = val;\n    return PJ_SUCCESS;\n}\n\n\n#endif /* PJMEDIA_HAS_INTEL_IPP_CODEC_G722_1 */\n\n/*\n * Initialize and register IPP codec factory to pjmedia endpoint.\n */\nPJ_DEF(pj_status_t) pjmedia_codec_ipp_init( pjmedia_endpt *endpt )\n{\n    pjmedia_codec_mgr *codec_mgr;\n    pj_str_t codec_name;\n    pj_status_t status;\n\n    if (ipp_factory.pool != NULL) {\n\t/* Already initialized. */\n\treturn PJ_SUCCESS;\n    }\n\n    /* Create IPP codec factory. */\n    ipp_factory.base.op = &ipp_factory_op;\n    ipp_factory.base.factory_data = NULL;\n    ipp_factory.endpt = endpt;\n    ipp_factory.g7221_pcm_shift = PJMEDIA_G7221_DEFAULT_PCM_SHIFT;\n\n    ipp_factory.pool = pjmedia_endpt_create_pool(endpt, \"IPP codecs\", 4000, 4000);\n    if (!ipp_factory.pool)\n\treturn PJ_ENOMEM;\n\n    /* Create mutex. */\n    status = pj_mutex_create_simple(ipp_factory.pool, \"IPP codecs\", \n\t\t\t\t    &ipp_factory.mutex);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Get the codec manager. */\n    codec_mgr = pjmedia_endpt_get_codec_mgr(endpt);\n    if (!codec_mgr) {\n\tstatus = PJ_EINVALIDOP;\n\tgoto on_error;\n    }\n\n    /* Register format match callback. */\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_G722_1\n    pj_cstr(&codec_name, \"G7221\");\n    status = pjmedia_sdp_neg_register_fmt_match_cb(\n\t\t\t\t\t&codec_name,\n\t\t\t\t\t&pjmedia_codec_g7221_match_sdp);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n#endif\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_AMR\n    pj_cstr(&codec_name, \"AMR\");\n    status = pjmedia_sdp_neg_register_fmt_match_cb(\n\t\t\t\t\t&codec_name,\n\t\t\t\t\t&pjmedia_codec_amr_match_sdp);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n#endif\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_AMRWB\n    pj_cstr(&codec_name, \"AMR-WB\");\n    status = pjmedia_sdp_neg_register_fmt_match_cb(\n\t\t\t\t\t&codec_name,\n\t\t\t\t\t&pjmedia_codec_amr_match_sdp);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n#endif\n\n    /* Suppress compile warning */\n    PJ_UNUSED_ARG(codec_name);\n\n    /* Register codec factory to endpoint. */\n    status = pjmedia_codec_mgr_register_factory(codec_mgr, \n\t\t\t\t\t\t&ipp_factory.base);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Done. */\n    return PJ_SUCCESS;\n\non_error:\n    pj_pool_release(ipp_factory.pool);\n    ipp_factory.pool = NULL;\n    return status;\n}\n\n/*\n * Unregister IPP codecs factory from pjmedia endpoint.\n */\nPJ_DEF(pj_status_t) pjmedia_codec_ipp_deinit(void)\n{\n    pjmedia_codec_mgr *codec_mgr;\n    pj_status_t status;\n\n    if (ipp_factory.pool == NULL) {\n\t/* Already deinitialized */\n\treturn PJ_SUCCESS;\n    }\n\n    pj_mutex_lock(ipp_factory.mutex);\n\n    /* Get the codec manager. */\n    codec_mgr = pjmedia_endpt_get_codec_mgr(ipp_factory.endpt);\n    if (!codec_mgr) {\n\tpj_pool_release(ipp_factory.pool);\n\tipp_factory.pool = NULL;\n\tpj_mutex_unlock(ipp_factory.mutex);\n\treturn PJ_EINVALIDOP;\n    }\n\n    /* Unregister IPP codecs factory. */\n    status = pjmedia_codec_mgr_unregister_factory(codec_mgr,\n\t\t\t\t\t\t  &ipp_factory.base);\n    \n    /* Destroy mutex. */\n    pj_mutex_unlock(ipp_factory.mutex);\n    pj_mutex_destroy(ipp_factory.mutex);\n    ipp_factory.mutex = NULL;\n\n    /* Destroy pool. */\n    pj_pool_release(ipp_factory.pool);\n    ipp_factory.pool = NULL;\n\n    return status;\n}\n\n\n/* \n * Check if factory can allocate the specified codec. \n */\nstatic pj_status_t ipp_test_alloc( pjmedia_codec_factory *factory, \n\t\t\t\t   const pjmedia_codec_info *info )\n{\n    unsigned i;\n\n    PJ_UNUSED_ARG(factory);\n\n    /* Type MUST be audio. */\n    if (info->type != PJMEDIA_TYPE_AUDIO)\n\treturn PJMEDIA_CODEC_EUNSUP;\n\n    for (i = 0; i < PJ_ARRAY_SIZE(ipp_codec); ++i) {\n\tpj_str_t name = pj_str((char*)ipp_codec[i].name);\n\tif ((pj_stricmp(&info->encoding_name, &name) == 0) &&\n\t    (info->clock_rate == (unsigned)ipp_codec[i].clock_rate) &&\n\t    (info->channel_cnt == (unsigned)ipp_codec[i].channel_count) &&\n\t    (ipp_codec[i].enabled))\n\t{\n\t    return PJ_SUCCESS;\n\t}\n    }\n    \n    /* Unsupported, or mode is disabled. */\n    return PJMEDIA_CODEC_EUNSUP;\n}\n\n/*\n * Generate default attribute.\n */\nstatic pj_status_t ipp_default_attr (pjmedia_codec_factory *factory, \n\t\t\t\t      const pjmedia_codec_info *id, \n\t\t\t\t      pjmedia_codec_param *attr )\n{\n    unsigned i;\n\n    PJ_ASSERT_RETURN(factory==&ipp_factory.base, PJ_EINVAL);\n\n    pj_bzero(attr, sizeof(pjmedia_codec_param));\n\n    for (i = 0; i < PJ_ARRAY_SIZE(ipp_codec); ++i) {\n\tpj_str_t name = pj_str((char*)ipp_codec[i].name);\n\tif ((pj_stricmp(&id->encoding_name, &name) == 0) &&\n\t    (id->clock_rate == (unsigned)ipp_codec[i].clock_rate) &&\n\t    (id->channel_cnt == (unsigned)ipp_codec[i].channel_count) &&\n\t    (id->pt == (unsigned)ipp_codec[i].pt))\n\t{\n\t    attr->info.pt = (pj_uint8_t)id->pt;\n\t    attr->info.channel_cnt = ipp_codec[i].channel_count;\n\t    attr->info.clock_rate = ipp_codec[i].clock_rate;\n\t    attr->info.avg_bps = ipp_codec[i].def_bitrate;\n\t    attr->info.max_bps = ipp_codec[i].max_bitrate;\n\t    attr->info.pcm_bits_per_sample = 16;\n\t    attr->info.frm_ptime =  (pj_uint16_t)\n\t\t\t\t    (ipp_codec[i].samples_per_frame * 1000 / \n\t\t\t\t    ipp_codec[i].channel_count / \n\t\t\t\t    ipp_codec[i].clock_rate);\n\t    attr->setting.frm_per_pkt = ipp_codec[i].frm_per_pkt;\n\n\t    /* Default flags. */\n\t    attr->setting.plc = 1;\n\t    attr->setting.penh= 0;\n\t    attr->setting.vad = 1;\n\t    attr->setting.cng = attr->setting.vad;\n\t    attr->setting.dec_fmtp = ipp_codec[i].dec_fmtp;\n\n\t    if (attr->setting.vad == 0) {\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_G729\n\t\tif (id->pt == PJMEDIA_RTP_PT_G729) {\n\t\t    /* Signal G729 Annex B is being disabled */\n\t\t    attr->setting.dec_fmtp.cnt = 1;\n\t\t    pj_strset2(&attr->setting.dec_fmtp.param[0].name, \"annexb\");\n\t\t    pj_strset2(&attr->setting.dec_fmtp.param[0].val, \"no\");\n\t\t}\n#endif\n\t    }\n\n\t    return PJ_SUCCESS;\n\t}\n    }\n\n    return PJMEDIA_CODEC_EUNSUP;\n}\n\n/*\n * Enum codecs supported by this factory.\n */\nstatic pj_status_t ipp_enum_codecs(pjmedia_codec_factory *factory, \n\t\t\t\t    unsigned *count, \n\t\t\t\t    pjmedia_codec_info codecs[])\n{\n    unsigned max;\n    unsigned i;\n\n    PJ_UNUSED_ARG(factory);\n    PJ_ASSERT_RETURN(codecs && *count > 0, PJ_EINVAL);\n\n    max = *count;\n    \n    for (i = 0, *count = 0; i < PJ_ARRAY_SIZE(ipp_codec) && *count < max; ++i) \n    {\n\tif (!ipp_codec[i].enabled)\n\t    continue;\n\n\tpj_bzero(&codecs[*count], sizeof(pjmedia_codec_info));\n\tcodecs[*count].encoding_name = pj_str((char*)ipp_codec[i].name);\n\tcodecs[*count].pt = ipp_codec[i].pt;\n\tcodecs[*count].type = PJMEDIA_TYPE_AUDIO;\n\tcodecs[*count].clock_rate = ipp_codec[i].clock_rate;\n\tcodecs[*count].channel_cnt = ipp_codec[i].channel_count;\n\n\t++*count;\n    }\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Allocate a new codec instance.\n */\nstatic pj_status_t ipp_alloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t    const pjmedia_codec_info *id,\n\t\t\t\t    pjmedia_codec **p_codec)\n{\n    ipp_private_t *codec_data;\n    pjmedia_codec *codec;\n    int idx;\n    pj_pool_t *pool;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(factory && id && p_codec, PJ_EINVAL);\n    PJ_ASSERT_RETURN(factory == &ipp_factory.base, PJ_EINVAL);\n\n    pj_mutex_lock(ipp_factory.mutex);\n\n    /* Find codec's index */\n    idx = -1;\n    for (i = 0; i < PJ_ARRAY_SIZE(ipp_codec); ++i) {\n\tpj_str_t name = pj_str((char*)ipp_codec[i].name);\n\tif ((pj_stricmp(&id->encoding_name, &name) == 0) &&\n\t    (id->clock_rate == (unsigned)ipp_codec[i].clock_rate) &&\n\t    (id->channel_cnt == (unsigned)ipp_codec[i].channel_count) &&\n\t    (ipp_codec[i].enabled))\n\t{\n\t    idx = i;\n\t    break;\n\t}\n    }\n    if (idx == -1) {\n\t*p_codec = NULL;\n\tpj_mutex_unlock(ipp_factory.mutex);\n\treturn PJMEDIA_CODEC_EFAILED;\n    }\n\n    /* Create pool for codec instance */\n    pool = pjmedia_endpt_create_pool(ipp_factory.endpt, \"IPPcodec\", 512, 512);\n    codec = PJ_POOL_ZALLOC_T(pool, pjmedia_codec);\n    PJ_ASSERT_RETURN(codec != NULL, PJ_ENOMEM);\n    codec->op = &ipp_op;\n    codec->factory = factory;\n    codec->codec_data = PJ_POOL_ZALLOC_T(pool, ipp_private_t);\n    codec_data = (ipp_private_t*) codec->codec_data;\n\n    /* Create PLC if codec has no internal PLC */\n    if (!ipp_codec[idx].has_native_plc) {\n\tpj_status_t status;\n\tstatus = pjmedia_plc_create(pool, ipp_codec[idx].clock_rate, \n\t\t\t\t    ipp_codec[idx].samples_per_frame, 0,\n\t\t\t\t    &codec_data->plc);\n\tif (status != PJ_SUCCESS) {\n\t    pj_pool_release(pool);\n\t    pj_mutex_unlock(ipp_factory.mutex);\n\t    return status;\n\t}\n    }\n\n    /* Create silence detector if codec has no internal VAD */\n    if (!ipp_codec[idx].has_native_vad) {\n\tpj_status_t status;\n\tstatus = pjmedia_silence_det_create(pool,\n\t\t\t\t\t    ipp_codec[idx].clock_rate,\n\t\t\t\t\t    ipp_codec[idx].samples_per_frame,\n\t\t\t\t\t    &codec_data->vad);\n\tif (status != PJ_SUCCESS) {\n\t    pj_pool_release(pool);\n\t    pj_mutex_unlock(ipp_factory.mutex);\n\t    return status;\n\t}\n    }\n\n    codec_data->pool = pool;\n    codec_data->codec_idx = idx;\n\n    pj_mutex_unlock(ipp_factory.mutex);\n\n    *p_codec = codec;\n    return PJ_SUCCESS;\n}\n\n/*\n * Free codec.\n */\nstatic pj_status_t ipp_dealloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t      pjmedia_codec *codec )\n{\n    ipp_private_t *codec_data;\n\n    PJ_ASSERT_RETURN(factory && codec, PJ_EINVAL);\n    PJ_ASSERT_RETURN(factory == &ipp_factory.base, PJ_EINVAL);\n\n    /* Close codec, if it's not closed. */\n    codec_data = (ipp_private_t*) codec->codec_data;\n    if (codec_data->enc != NULL || codec_data->dec != NULL) {\n\tipp_codec_close(codec);\n    }\n\n    pj_pool_release(codec_data->pool);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Init codec.\n */\nstatic pj_status_t ipp_codec_init( pjmedia_codec *codec, \n\t\t\t\t   pj_pool_t *pool )\n{\n    PJ_UNUSED_ARG(codec);\n    PJ_UNUSED_ARG(pool);\n    return PJ_SUCCESS;\n}\n\n/*\n * Open codec.\n */\nstatic pj_status_t ipp_codec_open( pjmedia_codec *codec, \n\t\t\t\t   pjmedia_codec_param *attr )\n{\n    ipp_private_t *codec_data = (ipp_private_t*) codec->codec_data;\n    struct ipp_codec *ippc = &ipp_codec[codec_data->codec_idx];\n    int info_size;\n    pj_pool_t *pool;\n    int i, j;\n    USC_MemBank *membanks;\n    int nb_membanks;\n\n    pool = codec_data->pool;\n\n    /* Get the codec info size */\n    if (USC_NoError != ippc->fxns->std.GetInfoSize(&info_size)) {\n\tPJ_LOG(1,(THIS_FILE, \"Error getting codec info size\"));\n\tgoto on_error;\n    }\n    /* Get the codec info */\n    codec_data->info = pj_pool_zalloc(pool, info_size);\n    if (USC_NoError != ippc->fxns->std.GetInfo((USC_Handle)NULL, \n\t\t\t\t\t       codec_data->info))\n    {\n\tPJ_LOG(1,(THIS_FILE, \"Error getting codec info\"));\n\tgoto on_error;\n    }\n\n    /* PREPARING THE ENCODER */\n\n    /* Setting the encoder params */\n    codec_data->info->params.direction = USC_ENCODE;\n    codec_data->info->params.modes.vad = attr->setting.vad && \n\t\t\t\t\t ippc->has_native_vad;\n    codec_data->info->params.modes.bitrate = attr->info.avg_bps;\n    codec_data->info->params.law = 0; /* Linear PCM input */\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_G729\n    if (ippc->pt == PJMEDIA_RTP_PT_G729) {\n\t/* Check if G729 Annex B is signaled to be disabled */\n\tfor (i = 0; i < attr->setting.enc_fmtp.cnt; ++i) {\n\t    if (pj_stricmp2(&attr->setting.enc_fmtp.param[i].name, \"annexb\")==0)\n\t    {\n\t\tif (pj_stricmp2(&attr->setting.enc_fmtp.param[i].val, \"no\")==0)\n\t\t{\n\t\t    attr->setting.vad = 0;\n\t\t    codec_data->info->params.modes.vad = 0;\n\t\t}\n\t\tbreak;\n\t    }\n\t}\n    }\n#endif\n\n    /* Get number of memory blocks needed by the encoder */\n    if (USC_NoError != ippc->fxns->std.NumAlloc(&codec_data->info->params,\n\t\t\t\t\t        &nb_membanks))\n    {\n\tPJ_LOG(1,(THIS_FILE, \"Error getting no of memory blocks of encoder\"));\n\tgoto on_error;\n    }\n\n    /* Allocate memory blocks table */\n    membanks = (USC_MemBank*) pj_pool_zalloc(pool, \n\t\t\t\t\t     sizeof(USC_MemBank) * nb_membanks);\n    /* Get size of each memory block */\n    if (USC_NoError != ippc->fxns->std.MemAlloc(&codec_data->info->params, \n\t\t\t\t\t        membanks))\n    {\n\tPJ_LOG(1,(THIS_FILE, \"Error getting memory blocks size of encoder\"));\n\tgoto on_error;\n    }\n\n    /* Allocate memory for each block */\n    for (i = 0; i < nb_membanks; i++) {\n\tmembanks[i].pMem = (char*) pj_pool_zalloc(pool, membanks[i].nbytes);\n    }\n\n    /* Create encoder instance */\n    if (USC_NoError != ippc->fxns->std.Init(&codec_data->info->params,\n\t\t\t\t\t    membanks, \n\t\t\t\t\t    &codec_data->enc))\n    {\n\tPJ_LOG(1,(THIS_FILE, \"Error initializing encoder\"));\n\tgoto on_error;\n    }\n\n    /* PREPARING THE DECODER */\n\n    /* Setting the decoder params */\n    codec_data->info->params.direction = USC_DECODE;\n\n    /* Not sure if VAD affects decoder, just try to be safe */\n    //codec_data->info->params.modes.vad = ippc->has_native_vad;\n\n    /* Get number of memory blocks needed by the decoder */\n    if (USC_NoError != ippc->fxns->std.NumAlloc(&codec_data->info->params, \n\t\t\t\t\t\t &nb_membanks))\n    {\n\tPJ_LOG(1,(THIS_FILE, \"Error getting no of memory blocks of decoder\"));\n\tgoto on_error;\n    }\n\n    /* Allocate memory blocks table */\n    membanks = (USC_MemBank*) pj_pool_zalloc(pool, \n\t\t\t\t\t     sizeof(USC_MemBank) * nb_membanks);\n    /* Get size of each memory block */\n    if (USC_NoError != ippc->fxns->std.MemAlloc(&codec_data->info->params, \n\t\t\t\t\t\tmembanks))\n    {\n\tPJ_LOG(1,(THIS_FILE, \"Error getting memory blocks size of decoder\"));\n\tgoto on_error;\n    }\n\n    /* Allocate memory for each block */\n    for (i = 0; i < nb_membanks; i++) {\n\tmembanks[i].pMem = (char*) pj_pool_zalloc(pool, membanks[i].nbytes);\n    }\n\n    /* Create decoder instance */\n    if (USC_NoError != ippc->fxns->std.Init(&codec_data->info->params, \n\t\t\t\t\t    membanks, &codec_data->dec))\n    {\n\tPJ_LOG(1,(THIS_FILE, \"Error initializing decoder\"));\n\tgoto on_error;\n    }\n\n    /* Update codec info */\n    ippc->fxns->std.GetInfo((USC_Handle)codec_data->enc, codec_data->info);\n\n    /* Get bitstream size */\n    i = codec_data->info->params.modes.bitrate * ippc->samples_per_frame;\n    j = ippc->clock_rate << 3;\n    codec_data->frame_size = (pj_uint16_t)(i / j);\n    if (i % j) ++codec_data->frame_size;\n\n    codec_data->vad_enabled = (attr->setting.vad != 0);\n    codec_data->plc_enabled = (attr->setting.plc != 0);\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_AMR\n    /* Init AMR settings */\n    if (ippc->pt == PJMEDIA_RTP_PT_AMR || ippc->pt == PJMEDIA_RTP_PT_AMRWB) {\n\tamr_settings_t *s;\n\tpj_uint8_t octet_align = 0;\n\tpj_int8_t enc_mode;\n\n\tenc_mode = pjmedia_codec_amr_get_mode(\n\t\t\t\tcodec_data->info->params.modes.bitrate);\n\tpj_assert(enc_mode >= 0 && enc_mode <= 8);\n\n\t/* Check AMR specific attributes */\n\n\tfor (i = 0; i < attr->setting.dec_fmtp.cnt; ++i) {\n\t    /* octet-align, one of the parameters that must have same value \n\t     * in offer & answer (RFC 4867 Section 8.3.1). Just check fmtp\n\t     * in the decoder side, since it's value is guaranteed to fulfil \n\t     * above requirement (by SDP negotiator).\n\t     */\n\t    const pj_str_t STR_FMTP_OCTET_ALIGN = {\"octet-align\", 11};\n\t    \n\t    if (pj_stricmp(&attr->setting.dec_fmtp.param[i].name, \n\t\t\t   &STR_FMTP_OCTET_ALIGN) == 0)\n\t    {\n\t\toctet_align=(pj_uint8_t)\n\t\t\t    pj_strtoul(&attr->setting.dec_fmtp.param[i].val);\n\t\tbreak;\n\t    }\n\t}\n\n\tfor (i = 0; i < attr->setting.enc_fmtp.cnt; ++i) {\n\t    /* mode-set, encoding mode is chosen based on local default mode \n\t     * setting:\n\t     * - if local default mode is included in the mode-set, use it\n\t     * - otherwise, find the closest mode to local default mode;\n\t     *   if there are two closest modes, prefer to use the higher\n\t     *   one, e.g: local default mode is 4, the mode-set param\n\t     *   contains '2,3,5,6', then 5 will be chosen.\n\t     */\n\t    const pj_str_t STR_FMTP_MODE_SET = {\"mode-set\", 8};\n\t    \n\t    if (pj_stricmp(&attr->setting.enc_fmtp.param[i].name, \n\t\t\t   &STR_FMTP_MODE_SET) == 0)\n\t    {\n\t\tconst char *p;\n\t\tpj_size_t l;\n\t\tpj_int8_t diff = 99;\n\t\t\n\t\tp = pj_strbuf(&attr->setting.enc_fmtp.param[i].val);\n\t\tl = pj_strlen(&attr->setting.enc_fmtp.param[i].val);\n\n\t\twhile (l--) {\n\t\t    if ((ippc->pt==PJMEDIA_RTP_PT_AMR && *p>='0' && *p<='7') ||\n\t\t        (ippc->pt==PJMEDIA_RTP_PT_AMRWB && *p>='0' && *p<='8'))\n\t\t    {\n\t\t\tpj_int8_t tmp = (pj_int8_t)(*p - '0' - enc_mode);\n\n\t\t\tif (PJ_ABS(diff) > PJ_ABS(tmp) || \n\t\t\t    (PJ_ABS(diff) == PJ_ABS(tmp) && tmp > diff))\n\t\t\t{\n\t\t\t    diff = tmp;\n\t\t\t    if (diff == 0) break;\n\t\t\t}\n\t\t    }\n\t\t    ++p;\n\t\t}\n\n\t\tif (diff == 99)\n\t\t    goto on_error;\n\n\t\tenc_mode = (pj_int8_t)(enc_mode + diff);\n\n\t\tbreak;\n\t    }\n\t}\n\n\t/* Initialize AMR specific settings */\n\ts = PJ_POOL_ZALLOC_T(pool, amr_settings_t);\n\tcodec_data->codec_setting = s;\n\n\ts->enc_setting.amr_nb = (pj_uint8_t)(ippc->pt == PJMEDIA_RTP_PT_AMR);\n\ts->enc_setting.octet_aligned = octet_align;\n\ts->enc_setting.reorder = PJ_TRUE;\n\ts->enc_setting.cmr = 15;\n\n\ts->dec_setting.amr_nb = (pj_uint8_t)(ippc->pt == PJMEDIA_RTP_PT_AMR);\n\ts->dec_setting.octet_aligned = octet_align;\n\ts->dec_setting.reorder = PJ_TRUE;\n\n\t/* Apply encoder mode/bitrate */\n\ts->enc_mode = enc_mode;\n\tcodec_data->info->params.modes.bitrate = s->enc_setting.amr_nb?\n\t\t\t\tpjmedia_codec_amrnb_bitrates[s->enc_mode]:\n\t\t\t\tpjmedia_codec_amrwb_bitrates[s->enc_mode];\n\tippc->fxns->std.Control(&codec_data->info->params.modes, \n\t\t\t\tcodec_data->enc);\n\n\tPJ_LOG(4,(THIS_FILE, \"AMR%s encoding mode: %d (%dbps)\", \n\t\t  (s->enc_setting.amr_nb?\"\":\"-WB\"),\n\t\t  s->enc_mode,\n\t\t  codec_data->info->params.modes.bitrate));\n\n\t/* Return back bitrate info to application */\n\tattr->info.avg_bps = codec_data->info->params.modes.bitrate;\n    }\n#endif\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_G722_1\n    if (ippc->pt >= PJMEDIA_RTP_PT_G722_1_16 && \n\tippc->pt <= PJMEDIA_RTP_PT_G7221_RSV2)\n    {\n\tcodec_data->g7221_pcm_shift = ipp_factory.g7221_pcm_shift;\n    }\n#endif\n\n    return PJ_SUCCESS;\n\non_error:\n    return PJMEDIA_CODEC_EFAILED;\n}\n\n/*\n * Close codec.\n */\nstatic pj_status_t ipp_codec_close( pjmedia_codec *codec )\n{\n    PJ_UNUSED_ARG(codec);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Modify codec settings.\n */\nstatic pj_status_t  ipp_codec_modify(pjmedia_codec *codec, \n\t\t\t\t     const pjmedia_codec_param *attr )\n{\n    ipp_private_t *codec_data = (ipp_private_t*) codec->codec_data;\n    struct ipp_codec *ippc = &ipp_codec[codec_data->codec_idx];\n\n    codec_data->vad_enabled = (attr->setting.vad != 0);\n    codec_data->plc_enabled = (attr->setting.plc != 0);\n\n    if (ippc->has_native_vad) {\n\tUSC_Modes modes;\n\n\tmodes = codec_data->info->params.modes;\n\tmodes.vad = codec_data->vad_enabled;\n\tippc->fxns->std.Control(&modes, codec_data->enc);\n    }\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Get frames in the packet.\n */\nstatic pj_status_t  ipp_codec_parse( pjmedia_codec *codec,\n\t\t\t\t     void *pkt,\n\t\t\t\t     pj_size_t pkt_size,\n\t\t\t\t     const pj_timestamp *ts,\n\t\t\t\t     unsigned *frame_cnt,\n\t\t\t\t     pjmedia_frame frames[])\n{\n    ipp_private_t *codec_data = (ipp_private_t*) codec->codec_data;\n    struct ipp_codec *ippc = &ipp_codec[codec_data->codec_idx];\n    unsigned count = 0;\n\n    PJ_ASSERT_RETURN(frame_cnt, PJ_EINVAL);\n\n    if (ippc->parse != NULL) {\n\treturn ippc->parse(codec_data, pkt,  pkt_size, ts, frame_cnt, frames);\n    }\n\n    while (pkt_size >= codec_data->frame_size && count < *frame_cnt) {\n\tframes[count].type = PJMEDIA_FRAME_TYPE_AUDIO;\n\tframes[count].buf = pkt;\n\tframes[count].size = codec_data->frame_size;\n\tframes[count].timestamp.u64 = ts->u64 + count*ippc->samples_per_frame;\n\n\tpkt = ((char*)pkt) + codec_data->frame_size;\n\tpkt_size -= codec_data->frame_size;\n\n\t++count;\n    }\n\n    if (pkt_size && count < *frame_cnt) {\n\tframes[count].type = PJMEDIA_FRAME_TYPE_AUDIO;\n\tframes[count].buf = pkt;\n\tframes[count].size = pkt_size;\n\tframes[count].timestamp.u64 = ts->u64 + count*ippc->samples_per_frame;\n\t++count;\n    }\n\n    *frame_cnt = count;\n    return PJ_SUCCESS;\n}\n\n/*\n * Encode frames.\n */\nstatic pj_status_t ipp_codec_encode( pjmedia_codec *codec, \n\t\t\t\t     const struct pjmedia_frame *input,\n\t\t\t\t     unsigned output_buf_len, \n\t\t\t\t     struct pjmedia_frame *output)\n{\n    ipp_private_t *codec_data = (ipp_private_t*) codec->codec_data;\n    struct ipp_codec *ippc = &ipp_codec[codec_data->codec_idx];\n    unsigned samples_per_frame;\n    unsigned nsamples;\n    pj_size_t tx = 0;\n    pj_int16_t *pcm_in   = (pj_int16_t*)input->buf;\n    pj_uint8_t  *bits_out = (pj_uint8_t*) output->buf;\n    pj_uint8_t pt;\n\n    /* Invoke external VAD if codec has no internal VAD */\n    if (codec_data->vad && codec_data->vad_enabled) {\n\tpj_bool_t is_silence;\n\tpj_int32_t silence_duration;\n\n\tsilence_duration = pj_timestamp_diff32(&codec_data->last_tx, \n\t\t\t\t\t       &input->timestamp);\n\n\tis_silence = pjmedia_silence_det_detect(codec_data->vad, \n\t\t\t\t\t        (const pj_int16_t*) input->buf,\n\t\t\t\t\t\t(input->size >> 1),\n\t\t\t\t\t\tNULL);\n\tif (is_silence &&\n\t    (PJMEDIA_CODEC_MAX_SILENCE_PERIOD == -1 ||\n\t     silence_duration < (PJMEDIA_CODEC_MAX_SILENCE_PERIOD *\n\t \t\t\t (int)ippc->clock_rate / 1000)))\n\t{\n\t    output->type = PJMEDIA_FRAME_TYPE_NONE;\n\t    output->buf = NULL;\n\t    output->size = 0;\n\t    output->timestamp = input->timestamp;\n\t    return PJ_SUCCESS;\n\t} else {\n\t    codec_data->last_tx = input->timestamp;\n\t}\n    }\n\n    nsamples = input->size >> 1;\n    samples_per_frame = ippc->samples_per_frame;\n    pt = ippc->pt;\n\n    PJ_ASSERT_RETURN(nsamples % samples_per_frame == 0, \n\t\t     PJMEDIA_CODEC_EPCMFRMINLEN);\n\n    /* Encode the frames */\n    while (nsamples >= samples_per_frame) {\n\tUSC_PCMStream in;\n\tUSC_Bitstream out;\n\n\tin.bitrate = codec_data->info->params.modes.bitrate;\n\tin.nbytes = samples_per_frame << 1;\n\tin.pBuffer = (char*)pcm_in;\n\tin.pcmType.bitPerSample = codec_data->info->params.pcmType.bitPerSample;\n\tin.pcmType.nChannels = codec_data->info->params.pcmType.nChannels;\n\tin.pcmType.sample_frequency = codec_data->info->params.pcmType.sample_frequency;\n\n\tout.pBuffer = (char*)bits_out;\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_AMR\n\t/* For AMR: reserve two octets for AMR frame info */\n\tif (pt == PJMEDIA_RTP_PT_AMR || pt == PJMEDIA_RTP_PT_AMRWB) {\n\t    out.pBuffer += 2;\n\t}\n#endif\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_G722_1\n\t/* For G722.1: adjust the encoder input signal level */\n\tif (pt >= PJMEDIA_RTP_PT_G722_1_16 && \n\t    pt <= PJMEDIA_RTP_PT_G7221_RSV2 &&\n\t    codec_data->g7221_pcm_shift)\n\t{\n\t    unsigned i;\n\t    for (i = 0; i < samples_per_frame; ++i)\n\t\tpcm_in[i] >>= codec_data->g7221_pcm_shift;\n\t}\n#endif\n\n\tif (USC_NoError != ippc->fxns->Encode(codec_data->enc, &in, &out)) {\n\t    break;\n\t}\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_AMR\n\t/* For AMR: put info (frametype, degraded, last frame, mode) in the \n\t * first two octets for payload packing.\n\t */\n\tif (pt == PJMEDIA_RTP_PT_AMR || pt == PJMEDIA_RTP_PT_AMRWB) {\n\t    pj_uint16_t *info = (pj_uint16_t*)bits_out;\n\n\t    /* Two octets for AMR frame info, 0=LSB:\n\t     * bit 0-3\t: frame type\n\t     * bit 5\t: STI flag\n\t     * bit 6\t: last frame flag\n\t     * bit 7\t: quality flag\n\t     * bit 8-11\t: mode\n\t     */\n\t    out.nbytes += 2;\n\t    if (out.frametype == 0 || out.frametype == 4 || \n\t\t(pt == PJMEDIA_RTP_PT_AMR && out.frametype == 5) ||\n\t\t(pt == PJMEDIA_RTP_PT_AMRWB && out.frametype == 6))\n\t    {\n\t\t/* Speech frame type */\n\t\t*info = (char)pjmedia_codec_amr_get_mode(out.bitrate);\n\t\t/* Quality */\n\t\tif (out.frametype == 5 || out.frametype == 6)\n\t\t    *info |= 0x80;\n\t    } else if (out.frametype == 1 || out.frametype == 2 || \n\t\t       (pt == PJMEDIA_RTP_PT_AMR && out.frametype == 6) ||\n\t\t       (pt == PJMEDIA_RTP_PT_AMRWB && out.frametype == 7))\n\t    {\n\t\t/* SID frame type */\n\t\t*info = (pj_uint8_t)(pt == PJMEDIA_RTP_PT_AMRWB? 9 : 8);\n\t\t/* Quality */\n\t\tif (out.frametype == 6 || out.frametype == 7)\n\t\t    *info |= 0x80;\n\t\t/* STI */\n\t\tif (out.frametype != 1)\n\t\t    *info |= 0x20;\n\t    } else {\n\t\t/* Untransmited */\n\t\t*info = 15;\n\t\tout.nbytes = 2;\n\t    }\n\n\t    /* Mode */\n\t    *info |= (char)pjmedia_codec_amr_get_mode(out.bitrate) << 8;\n\n\t    /* Last frame flag */\n\t    if (nsamples == samples_per_frame)\n\t\t*info |= 0x40;\n\t}\n#endif\n\n\tpcm_in += samples_per_frame;\n\tnsamples -= samples_per_frame;\n\ttx += out.nbytes;\n\tbits_out += out.nbytes;\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_G729\n\tif (pt == PJMEDIA_RTP_PT_G729) {\n\t    if (out.frametype == 1) {\n\t\t/* SID */\n\t\tbreak;\n\t    } else if (out.frametype == 0) {\n\t\t/* Untransmitted */\n\t\ttx -= out.nbytes;\n\t\tbreak;\n\t    }\n\t}\n#endif\n\n    }\n\n    if (ippc->pack != NULL) {\n\tippc->pack(codec_data, output->buf, &tx, output_buf_len);\n    }\n\n    /* Check if we don't need to transmit the frame (DTX) */\n    if (tx == 0) {\n\toutput->buf = NULL;\n\toutput->size = 0;\n\toutput->timestamp.u64 = input->timestamp.u64;\n\toutput->type = PJMEDIA_FRAME_TYPE_NONE;\n\treturn PJ_SUCCESS;\n    }\n\n    output->size = tx;\n    output->type = PJMEDIA_FRAME_TYPE_AUDIO;\n    output->timestamp = input->timestamp;\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Decode frame.\n */\nstatic pj_status_t ipp_codec_decode( pjmedia_codec *codec, \n\t\t\t\t     const struct pjmedia_frame *input,\n\t\t\t\t     unsigned output_buf_len, \n\t\t\t\t     struct pjmedia_frame *output)\n{\n    ipp_private_t *codec_data = (ipp_private_t*) codec->codec_data;\n    struct ipp_codec *ippc = &ipp_codec[codec_data->codec_idx];\n    unsigned samples_per_frame;\n    USC_PCMStream out;\n    USC_Bitstream in;\n    pj_uint8_t pt;\n\n    pt = ippc->pt; \n    samples_per_frame = ippc->samples_per_frame;\n\n    PJ_ASSERT_RETURN(output_buf_len >= samples_per_frame << 1,\n\t\t     PJMEDIA_CODEC_EPCMTOOSHORT);\n\n    if (input->type == PJMEDIA_FRAME_TYPE_AUDIO) {\n\tif (ippc->predecode) {\n\t    ippc->predecode(codec_data, input, &in);\n\t} else {\n\t    /* Most IPP codecs have frametype==0 for speech frame */\n\t    in.pBuffer = (char*)input->buf;\n\t    in.nbytes = input->size;\n\t    in.frametype = 0;\n\t    in.bitrate = codec_data->info->params.modes.bitrate;\n\t}\n\n\tout.pBuffer = output->buf;\n    }\n\n    if (input->type != PJMEDIA_FRAME_TYPE_AUDIO ||\n\tUSC_NoError != ippc->fxns->Decode(codec_data->dec, &in, &out)) \n    {\n\tpjmedia_zero_samples((pj_int16_t*)output->buf, samples_per_frame);\n\toutput->size = samples_per_frame << 1;\n\toutput->timestamp.u64 = input->timestamp.u64;\n\toutput->type = PJMEDIA_FRAME_TYPE_AUDIO;\n\treturn PJ_SUCCESS;\n    }\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_G726\n    /* For G.726: amplify decoding result (USC G.726 encoder deamplified it) */\n    if (pt == PJMEDIA_RTP_PT_G726_16 || pt == PJMEDIA_RTP_PT_G726_24 ||\n\tpt == PJMEDIA_RTP_PT_G726_32 || pt == PJMEDIA_RTP_PT_G726_40 ||\n\tpt == PJMEDIA_RTP_PT_G721)\n    {\n\tunsigned i;\n\tpj_int16_t *s = (pj_int16_t*)output->buf;\n\n\tfor (i = 0; i < samples_per_frame; ++i)\n\t    s[i] <<= 2;\n    }\n#endif\n\n#if PJMEDIA_HAS_INTEL_IPP_CODEC_G722_1\n    /* For G722.1: adjust the decoder output signal level */\n    if (pt >= PJMEDIA_RTP_PT_G722_1_16 && \n\tpt <= PJMEDIA_RTP_PT_G7221_RSV2 &&\n\tcodec_data->g7221_pcm_shift)\n    {\n\tunsigned i;\n\tpj_int16_t *s = (pj_int16_t*)output->buf;\n\n\tfor (i = 0; i < samples_per_frame; ++i)\n\t    s[i] <<= codec_data->g7221_pcm_shift;\n    }\n#endif\n\n    output->type = PJMEDIA_FRAME_TYPE_AUDIO;\n    output->size = samples_per_frame << 1;\n    output->timestamp.u64 = input->timestamp.u64;\n\n    /* Invoke external PLC if codec has no internal PLC */\n    if (codec_data->plc && codec_data->plc_enabled)\n\tpjmedia_plc_save(codec_data->plc, (pj_int16_t*)output->buf);\n\n    return PJ_SUCCESS;\n}\n\n/* \n * Recover lost frame.\n */\nstatic pj_status_t  ipp_codec_recover(pjmedia_codec *codec, \n\t\t\t\t      unsigned output_buf_len, \n\t\t\t\t      struct pjmedia_frame *output)\n{\n    ipp_private_t *codec_data = (ipp_private_t*) codec->codec_data;\n    struct ipp_codec *ippc = &ipp_codec[codec_data->codec_idx];\n    unsigned samples_per_frame;\n\n    PJ_UNUSED_ARG(output_buf_len);\n\n    samples_per_frame = ippc->samples_per_frame;\n\n    output->type = PJMEDIA_FRAME_TYPE_AUDIO;\n    output->size = samples_per_frame << 1;\n\n    if (codec_data->plc_enabled) {\n\tif (codec_data->plc) {\n\t    pjmedia_plc_generate(codec_data->plc, (pj_int16_t*)output->buf);\n\t} else {\n\t    USC_PCMStream out;\n\t    out.pBuffer = output->buf;\n\t    ippc->fxns->Decode(codec_data->dec, NULL, &out);\n\t}\n    } else {\n\tpjmedia_zero_samples((pj_int16_t*)output->buf, samples_per_frame);\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n#if defined(_MSC_VER) && PJMEDIA_AUTO_LINK_IPP_LIBS\n#   pragma comment( lib, \"ippcore.lib\")\n#   pragma comment( lib, \"ipps.lib\")\n#   pragma comment( lib, \"ippsc.lib\")\n#   if defined(IPP_VERSION_MAJOR) && IPP_VERSION_MAJOR<=6\n#\tpragma comment( lib, \"ippsr.lib\")\n#   endif\n//#   pragma comment( lib, \"ippcorel.lib\")\n//#   pragma comment( lib, \"ippsemerged.lib\")\n//#   pragma comment( lib, \"ippsmerged.lib\")\n//#   pragma comment( lib, \"ippscemerged.lib\")\n//#   pragma comment( lib, \"ippscmerged.lib\")\n//#   pragma comment( lib, \"ippsremerged.lib\")\n//#   pragma comment( lib, \"ippsrmerged.lib\")\n#   if defined(IPP_VERSION_MAJOR) && IPP_VERSION_MAJOR>=6\n#\tpragma comment( lib, \"speech.lib\")\n#   else\n#\tpragma comment( lib, \"usc.lib\")\n#   endif\n#endif\n\n\n#endif\t/* PJMEDIA_HAS_INTEL_IPP */\n\n", "/* $Id$ */\n/*\n * Copyright (C) 2015-2016 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2012-2015 Zaark Technology AB\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n/* This file is the implementation of Opus codec wrapper and was contributed by\n * Zaark Technology AB\n */\n\n#include <pjmedia-codec/opus.h>\n#include <pjmedia/errno.h>\n#include <pjmedia/endpoint.h>\n#include <pj/log.h>\n#include <pj/math.h>\n\n#if defined(PJMEDIA_HAS_OPUS_CODEC) && (PJMEDIA_HAS_OPUS_CODEC!=0)\n\n#include <opus/opus.h>\n\n#define THIS_FILE \"opus.c\"\n\n/* Default packet loss concealment setting. */\n#define OPUS_DEFAULT_PLC\t1\n/* Default Voice Activity Detector setting. */\n#define OPUS_DEFAULT_VAD\t0\n\n/* Maximum size of an encoded packet. \n * If the the actual size is bigger, the encode/parse will fail.\n */\n#define MAX_ENCODED_PACKET_SIZE \t1280\n\n/* Default frame time (msec) */\n#define PTIME\t\t\t20\n\n/* Tracing */\n#if 0\n#   define TRACE_(expr)\tPJ_LOG(4,expr)\n#else\n#   define TRACE_(expr)\n#endif\n\n\n/* Prototypes for Opus factory */\nstatic pj_status_t factory_test_alloc( pjmedia_codec_factory *factory, \n\t\t\t\t       const pjmedia_codec_info *ci );\nstatic pj_status_t factory_default_attr( pjmedia_codec_factory *factory, \n\t\t\t\t\t const pjmedia_codec_info *ci, \n\t\t\t\t\t pjmedia_codec_param *attr );\nstatic pj_status_t factory_enum_codecs( pjmedia_codec_factory *factory, \n\t\t\t\t\tunsigned *count, \n\t\t\t\t\tpjmedia_codec_info codecs[]);\nstatic pj_status_t factory_alloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t\tconst pjmedia_codec_info *ci, \n\t\t\t\t\tpjmedia_codec **p_codec);\nstatic pj_status_t factory_dealloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t\t  pjmedia_codec *codec );\n\n\n/* Prototypes for Opus implementation. */\nstatic pj_status_t codec_init( pjmedia_codec *codec, \n\t\t\t       pj_pool_t *pool );\nstatic pj_status_t codec_open( pjmedia_codec *codec, \n\t\t\t       pjmedia_codec_param *attr );\nstatic pj_status_t codec_close( pjmedia_codec *codec );\nstatic pj_status_t codec_modify( pjmedia_codec *codec, \n\t\t\t\t const pjmedia_codec_param *attr );\nstatic pj_status_t codec_parse( pjmedia_codec *codec,\n\t\t\t\tvoid *pkt,\n\t\t\t\tpj_size_t pkt_size,\n\t\t\t\tconst pj_timestamp *ts,\n\t\t\t\tunsigned *frame_cnt,\n\t\t\t\tpjmedia_frame frames[]);\nstatic pj_status_t codec_encode( pjmedia_codec *codec, \n\t\t\t\t const struct pjmedia_frame *input,\n\t\t\t\t unsigned output_buf_len, \n\t\t\t\t struct pjmedia_frame *output);\nstatic pj_status_t codec_decode( pjmedia_codec *codec, \n\t\t\t\t const struct pjmedia_frame *input,\n\t\t\t\t unsigned output_buf_len, \n\t\t\t\t struct pjmedia_frame *output);\nstatic pj_status_t codec_recover( pjmedia_codec *codec,\n\t\t\t\t  unsigned output_buf_len,\n\t\t\t\t  struct pjmedia_frame *output);\n\n/* Definition for Opus operations. */\nstatic pjmedia_codec_op opus_op = \n{\n    &codec_init,\n    &codec_open,\n    &codec_close,\n    &codec_modify,\n    &codec_parse,\n    &codec_encode,\n    &codec_decode,\n    &codec_recover\n};\n\n/* Definition for Opus factory operations. */\nstatic pjmedia_codec_factory_op opus_factory_op =\n{\n    &factory_test_alloc,\n    &factory_default_attr,\n    &factory_enum_codecs,\n    &factory_alloc_codec,\n    &factory_dealloc_codec,\n    &pjmedia_codec_opus_deinit\n};\n\n\n/* Opus factory */\nstruct opus_codec_factory\n{\n    pjmedia_codec_factory  base;\n    pjmedia_endpt\t  *endpt;\n    pj_pool_t\t\t  *pool;\n};\n\n/* Opus codec private data. */\nstruct opus_data\n{\n    pj_pool_t         \t\t*pool;\n    pj_mutex_t        \t\t*mutex;\n    OpusEncoder \t\t*enc;\n    OpusDecoder       \t\t*dec;\n    OpusRepacketizer  \t\t*enc_packer;\n    OpusRepacketizer  \t\t*dec_packer;\n    pjmedia_codec_opus_config \t cfg;\n    unsigned   \t\t\t enc_ptime;\n    unsigned\t\t\t dec_ptime;\n    pjmedia_frame      \t\t dec_frame[2];\n    int                \t\t dec_frame_index;\n};\n\n/* Codec factory instance */\nstatic struct opus_codec_factory opus_codec_factory;\n\n/* Opus default configuration */\nstatic pjmedia_codec_opus_config opus_cfg =\n{\n    PJMEDIA_CODEC_OPUS_DEFAULT_SAMPLE_RATE,     /* Sample rate\t\t*/\n    1,\t\t\t\t\t\t/* Channel count\t*/\n    PTIME,\t\t\t\t\t/* Frame time \t\t*/\t\t\t\n    PJMEDIA_CODEC_OPUS_DEFAULT_BIT_RATE,\t/* Bit rate             */\n    5,\t\t\t\t\t\t/* Expected packet loss */\n    PJMEDIA_CODEC_OPUS_DEFAULT_COMPLEXITY,\t/* Complexity           */\n    PJMEDIA_CODEC_OPUS_DEFAULT_CBR,\t\t/* Constant bit rate    */\n};\n\n\nstatic int get_opus_bw_constant (unsigned sample_rate)\n{\n    if (sample_rate <= 8000)\n\treturn OPUS_BANDWIDTH_NARROWBAND;\n    else if (sample_rate <= 12000)\n\treturn OPUS_BANDWIDTH_MEDIUMBAND;\n    else if (sample_rate <= 16000)\n\treturn OPUS_BANDWIDTH_WIDEBAND;\n    else if (sample_rate <= 24000)\n\treturn OPUS_BANDWIDTH_SUPERWIDEBAND;\n    else\n\treturn OPUS_BANDWIDTH_FULLBAND;\n}\n\n\n/*\n * Initialize and register Opus codec factory to pjmedia endpoint.\n */\nPJ_DEF(pj_status_t) pjmedia_codec_opus_init( pjmedia_endpt *endpt )\n{\n    pj_status_t status;\n    pjmedia_codec_mgr *codec_mgr;\n\n    PJ_ASSERT_RETURN(endpt, PJ_EINVAL);\n\n    if (opus_codec_factory.pool != NULL)\n\treturn PJ_SUCCESS;\n\n    /* Create the Opus codec factory */\n    opus_codec_factory.base.op           = &opus_factory_op;\n    opus_codec_factory.base.factory_data = &opus_codec_factory;\n    opus_codec_factory.endpt             = endpt;\n\n    opus_codec_factory.pool = pjmedia_endpt_create_pool(endpt, \"opus-factory\",\n    \t\t\t\t\t\t\t1024, 1024);\n    if (!opus_codec_factory.pool) {\n\tPJ_LOG(2, (THIS_FILE, \"Unable to create memory pool for Opus codec\"));\n\treturn PJ_ENOMEM;\n    }\n\n    /* Get the codec manager */\n    codec_mgr = pjmedia_endpt_get_codec_mgr(endpt);\n    if (!codec_mgr) {\n\tPJ_LOG(2, (THIS_FILE, \"Unable to get the codec manager\"));\n\tstatus = PJ_EINVALIDOP;\n\tgoto on_codec_factory_error;\n    }\n\n    /* Register the codec factory */\n    status = pjmedia_codec_mgr_register_factory (codec_mgr,\n\t\t\t\t\t\t &opus_codec_factory.base);\n    if (status != PJ_SUCCESS) {\n\tPJ_LOG(2, (THIS_FILE, \"Unable to register the codec factory\"));\n\tgoto on_codec_factory_error;\n    }\n\n    return PJ_SUCCESS;\n\non_codec_factory_error:\n    pj_pool_release(opus_codec_factory.pool);\n    opus_codec_factory.pool = NULL;\n    return status;\n}\n\n\n/*\n * Unregister Opus codec factory from pjmedia endpoint and\n * deinitialize the codec.\n */\nPJ_DEF(pj_status_t) pjmedia_codec_opus_deinit( void )\n{\n    pj_status_t status;\n    pjmedia_codec_mgr *codec_mgr;\n\n    if (opus_codec_factory.pool == NULL)\n\treturn PJ_SUCCESS;\n\n    /* Get the codec manager */\n    codec_mgr = pjmedia_endpt_get_codec_mgr(opus_codec_factory.endpt);\n    if (!codec_mgr) {\n\tPJ_LOG(2, (THIS_FILE, \"Unable to get the codec manager\"));\n\tpj_pool_release(opus_codec_factory.pool);\n\topus_codec_factory.pool = NULL;\n\treturn PJ_EINVALIDOP;\n    }\n\n    /* Unregister the codec factory */\n    status = pjmedia_codec_mgr_unregister_factory(codec_mgr,\n\t\t\t\t\t\t  &opus_codec_factory.base);\n    if (status != PJ_SUCCESS)\n\tPJ_LOG(2, (THIS_FILE, \"Unable to unregister the codec factory\"));\n\n    /* Release the memory pool */\n    pj_pool_release(opus_codec_factory.pool);\n    opus_codec_factory.pool = NULL;\n\n    return status;\n}\n\n\n/**\n * Get the opus configuration for a specific sample rate.\n */\nPJ_DEF(pj_status_t)\npjmedia_codec_opus_get_config( pjmedia_codec_opus_config *cfg )\n{\n    PJ_ASSERT_RETURN(cfg, PJ_EINVAL);\n\n    pj_memcpy(cfg, &opus_cfg, sizeof(pjmedia_codec_opus_config));\n    return PJ_SUCCESS;\n}\n\n\nstatic pj_str_t STR_MAX_PLAYBACK = {\"maxplaybackrate\", 15};\nstatic pj_str_t STR_MAX_CAPTURE  = {\"sprop-maxcapturerate\", 20};\nstatic pj_str_t STR_STEREO  \t = {\"stereo\", 6};\nstatic pj_str_t STR_SPROP_STEREO = {\"sprop-stereo\", 12};\nstatic pj_str_t STR_MAX_BIT_RATE = {\"maxaveragebitrate\", 17};\nstatic pj_str_t STR_INBAND_FEC   = {\"useinbandfec\", 12};\nstatic pj_str_t STR_DTX          = {\"usedtx\", 6};\nstatic pj_str_t STR_CBR          = {\"cbr\", 3};\n\nstatic int find_fmtp(pjmedia_codec_fmtp *fmtp, pj_str_t *name, pj_bool_t add)\n{\n    int i;\n    for (i = 0; i < fmtp->cnt; i++) {\n    \tif (pj_stricmp(&fmtp->param[i].name, name) == 0)\n\t    return i;\n    }\n    \n    if (add && (i < PJMEDIA_CODEC_MAX_FMTP_CNT)) {\n        fmtp->param[i].name = *name;\n        fmtp->cnt++;\n        return i;\n    } else\n        return -1;\n}\n\nstatic void remove_fmtp(pjmedia_codec_fmtp *fmtp, pj_str_t *name)\n{\n    int i, j;\n    for (i = 0; i < fmtp->cnt; i++) {\n    \tif (pj_stricmp(&fmtp->param[i].name, name) == 0) {\n    \t    fmtp->cnt--;\n    \t    for (j = i; j < fmtp->cnt; j++) {\n    \t    \tfmtp->param[i].name = fmtp->param[i+1].name;\n    \t    \tfmtp->param[i].val = fmtp->param[i+1].val;\n    \t    }\n    \t}\n    }\n}\n\nstatic pj_status_t generate_fmtp(pjmedia_codec_param *attr)\n{\n    int idx;\n    static char bitrate_str[12];\n    static char clockrate_str[12];\n    \n    if (attr->info.clock_rate != 48000) {\n\tpj_ansi_snprintf(clockrate_str, sizeof(clockrate_str), \"%u\",\n\t\t\t attr->info.clock_rate);\n\n        idx = find_fmtp(&attr->setting.dec_fmtp, &STR_MAX_PLAYBACK, PJ_TRUE);\n        if (idx >= 0)\n\t    attr->setting.dec_fmtp.param[idx].val = pj_str(clockrate_str);\n\n\tidx = find_fmtp(&attr->setting.dec_fmtp, &STR_MAX_CAPTURE, PJ_TRUE);\n\tif (idx >= 0)\n\t    attr->setting.dec_fmtp.param[idx].val = pj_str(clockrate_str);\n    } else {\n    \tremove_fmtp(&attr->setting.dec_fmtp, &STR_MAX_PLAYBACK);\n    \tremove_fmtp(&attr->setting.dec_fmtp, &STR_MAX_CAPTURE);\n    }\n\n    /* Check if we need to set parameter 'maxaveragebitrate' */\n    if (opus_cfg.bit_rate > 0) {\n        idx = find_fmtp(&attr->setting.dec_fmtp, &STR_MAX_BIT_RATE, PJ_TRUE);\n        if (idx >= 0) {\n\t    pj_ansi_snprintf(bitrate_str, sizeof(bitrate_str), \"%u\",\n\t\t\t     attr->info.avg_bps);\n\t    attr->setting.dec_fmtp.param[idx].val = pj_str(bitrate_str);\n\t}\n    } else {\n        remove_fmtp(&attr->setting.dec_fmtp, &STR_MAX_BIT_RATE);\n    }\n\n    if (attr->info.channel_cnt > 1) {\n        idx = find_fmtp(&attr->setting.dec_fmtp, &STR_STEREO, PJ_TRUE);\n        if (idx >= 0)\n\t    attr->setting.dec_fmtp.param[idx].val = pj_str(\"1\");\n\n        idx = find_fmtp(&attr->setting.dec_fmtp, &STR_SPROP_STEREO, PJ_TRUE);\n        if (idx >= 0)\n\t    attr->setting.dec_fmtp.param[idx].val = pj_str(\"1\");\n    } else {\n    \tremove_fmtp(&attr->setting.dec_fmtp, &STR_STEREO);\n    \tremove_fmtp(&attr->setting.dec_fmtp, &STR_SPROP_STEREO);\n    }\n\n    if (opus_cfg.cbr) {\n        idx = find_fmtp(&attr->setting.dec_fmtp, &STR_CBR, PJ_TRUE);\n        if (idx >= 0)\n\t    attr->setting.dec_fmtp.param[idx].val = pj_str(\"1\");\n    } else {\n    \tremove_fmtp(&attr->setting.dec_fmtp, &STR_CBR);\n    }\n\n    if (attr->setting.plc) {\n        idx = find_fmtp(&attr->setting.dec_fmtp, &STR_INBAND_FEC, PJ_TRUE);\n        if (idx >= 0)\n\t    attr->setting.dec_fmtp.param[idx].val = pj_str(\"1\");\n    } else {\n    \tremove_fmtp(&attr->setting.dec_fmtp, &STR_INBAND_FEC);\n    }\n\n    if (attr->setting.vad) {\n        idx = find_fmtp(&attr->setting.dec_fmtp, &STR_DTX, PJ_TRUE);\n        if (idx >= 0)\n\t    attr->setting.dec_fmtp.param[idx].val = pj_str(\"1\");\n    } else {\n    \tremove_fmtp(&attr->setting.dec_fmtp, &STR_DTX);\n    }\n    \n    return PJ_SUCCESS;\n}\n\n/**\n * Set the opus configuration and default param.\n */\nPJ_DEF(pj_status_t)\npjmedia_codec_opus_set_default_param(const pjmedia_codec_opus_config *cfg,\n\t\t\t\t     pjmedia_codec_param *param )\n{\n    const pj_str_t opus_str = {\"opus\", 4};\n    const pjmedia_codec_info *info[1];\n    pjmedia_codec_mgr *codec_mgr;\n    unsigned count = 1;\n    pj_status_t status;\n\n    TRACE_((THIS_FILE, \"%s:%d: - TRACE\", __FUNCTION__, __LINE__));\n    PJ_ASSERT_RETURN(cfg && param, PJ_EINVAL);\n\n    codec_mgr = pjmedia_endpt_get_codec_mgr(opus_codec_factory.endpt);\n\n    status = pjmedia_codec_mgr_find_codecs_by_id(codec_mgr, &opus_str,\n\t\t\t\t\t\t &count, info, NULL);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    /* Set sample rate */\n    if (cfg->sample_rate != 8000 && cfg->sample_rate != 12000 &&\n\tcfg->sample_rate != 16000 && cfg->sample_rate != 24000 &&\n\tcfg->sample_rate != 48000)\n    {\n\treturn PJ_EINVAL;\n    }\n\n    param->info.clock_rate = opus_cfg.sample_rate = cfg->sample_rate;\n    param->info.max_bps = opus_cfg.sample_rate * 2;\n    opus_cfg.frm_ptime = cfg->frm_ptime;\n    param->info.frm_ptime = (pj_uint16_t)cfg->frm_ptime;\n\n    /* Set channel count */\n    if (cfg->channel_cnt != 1 && cfg->channel_cnt != 2)\n        return PJ_EINVAL;\n    param->info.channel_cnt = opus_cfg.channel_cnt = cfg->channel_cnt;\n\n    /* Set bit_rate */\n    if ((cfg->bit_rate != PJMEDIA_CODEC_OPUS_DEFAULT_BIT_RATE) && \n       (cfg->bit_rate < 6000 || cfg->bit_rate > 510000)) \n    {\n\treturn PJ_EINVAL;\n    }\n    opus_cfg.bit_rate = cfg->bit_rate;\n    param->info.avg_bps = opus_cfg.bit_rate;\n\n    /* Set expected packet loss */\n    if (cfg->packet_loss >= 100)\n\treturn PJ_EINVAL;\n    opus_cfg.packet_loss = cfg->packet_loss;\n\n    /* Set complexity */\n    if (cfg->complexity > 10)\n\treturn PJ_EINVAL;\n    opus_cfg.complexity = cfg->complexity;\n\n    opus_cfg.cbr = cfg->cbr;\n    \n    generate_fmtp(param);\n\n    status = pjmedia_codec_mgr_set_default_param(codec_mgr, info[0], param);\n    return status;\n}\n\n\n/*\n * Check if factory can allocate the specified codec.\n */\nstatic pj_status_t factory_test_alloc( pjmedia_codec_factory *factory, \n\t\t\t\t       const pjmedia_codec_info *ci )\n{\n    const pj_str_t opus_tag = {\"OPUS\", 4};\n\n    PJ_UNUSED_ARG(factory);\n    PJ_ASSERT_RETURN(factory==&opus_codec_factory.base, PJ_EINVAL);\n\n    /* Type MUST be audio. */\n    if (ci->type != PJMEDIA_TYPE_AUDIO)\n\treturn PJMEDIA_CODEC_EUNSUP;\n\n    /* Check encoding name. */\n    if (pj_stricmp(&ci->encoding_name, &opus_tag) != 0)\n\treturn PJMEDIA_CODEC_EUNSUP;\n\n    /* Check clock rate */\n    if (ci->clock_rate != 8000 && ci->clock_rate != 12000 &&\n\tci->clock_rate != 16000 && ci->clock_rate != 24000 &&\n\tci->clock_rate != 48000)\n    {\n\treturn PJMEDIA_CODEC_EUNSUP;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Generate default attribute.\n */\nstatic pj_status_t factory_default_attr( pjmedia_codec_factory *factory, \n\t\t\t\t\t const pjmedia_codec_info *ci, \n\t\t\t\t\t pjmedia_codec_param *attr )\n{\n    PJ_UNUSED_ARG(factory);\n    TRACE_((THIS_FILE, \"%s:%d: - TRACE\", __FUNCTION__, __LINE__));\n\n    pj_bzero(attr, sizeof(pjmedia_codec_param));\n    attr->info.pt          \t   = (pj_uint8_t)ci->pt;\n    attr->info.clock_rate  \t   = opus_cfg.sample_rate;\n    attr->info.channel_cnt \t   = opus_cfg.channel_cnt;\n    attr->info.avg_bps     \t   = opus_cfg.bit_rate;\n    attr->info.max_bps     \t   = opus_cfg.sample_rate * 2;\n    attr->info.frm_ptime   \t   = (pj_uint16_t)opus_cfg.frm_ptime;\n    attr->setting.frm_per_pkt \t   = 1;\n    attr->info.pcm_bits_per_sample = 16;\n    attr->setting.vad      \t   = OPUS_DEFAULT_VAD;\n    attr->setting.plc      \t   = OPUS_DEFAULT_PLC;\n\n    /* Set max RX frame size to 1275 (max Opus frame size) to anticipate\n     * possible ptime change on the fly.\n     */\n    attr->info.max_rx_frame_size   = 1275;\n\n    generate_fmtp(attr);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Enum codecs supported by this factory.\n */\nstatic pj_status_t factory_enum_codecs( pjmedia_codec_factory *factory, \n\t\t\t\t\tunsigned *count, \n\t\t\t\t\tpjmedia_codec_info codecs[] )\n{\n    PJ_UNUSED_ARG(factory);\n    PJ_ASSERT_RETURN(codecs, PJ_EINVAL);\n\n    if (*count > 0) {\n\tpj_bzero(&codecs[0], sizeof(pjmedia_codec_info));\n\tcodecs[0].type          = PJMEDIA_TYPE_AUDIO;\n\tcodecs[0].pt            = PJMEDIA_RTP_PT_OPUS;\n        /*\n         * RFC 7587, Section 7:\n         * The media subtype (\"opus\") goes in SDP \"a=rtpmap\" as the encoding\n         * name. The RTP clock rate in \"a=rtpmap\" MUST be 48000 and the\n         * number of channels MUST be 2.\n         */\t\n\tcodecs[0].encoding_name = pj_str(\"opus\");\n\tcodecs[0].clock_rate    = 48000;\n\tcodecs[0].channel_cnt   = 2;\n\t*count = 1;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Allocate a new Opus codec instance.\n */\nstatic pj_status_t factory_alloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t\tconst pjmedia_codec_info *ci, \n\t\t\t\t\tpjmedia_codec **p_codec )\n{\n    pjmedia_codec *codec;\n    pj_pool_t *pool;\n    pj_status_t status;\n    struct opus_data *opus_data;\n    struct opus_codec_factory *f = (struct opus_codec_factory*) factory;\n\n    PJ_UNUSED_ARG(ci);\n    TRACE_((THIS_FILE, \"%s:%d: - TRACE\", __FUNCTION__, __LINE__));\n\n    pool = pjmedia_endpt_create_pool(f->endpt, \"opus\", 512, 512);\n    if (!pool) return PJ_ENOMEM;\n    \n    opus_data = PJ_POOL_ZALLOC_T(pool, struct opus_data);\n    codec     = PJ_POOL_ZALLOC_T(pool, pjmedia_codec);\n\n    status = pj_mutex_create_simple (pool, \"opus_mutex\", &opus_data->mutex);\n    if (status != PJ_SUCCESS) {\n    \tpj_pool_release(pool);\n    \treturn status;\n    }\n\n    pj_memcpy(&opus_data->cfg, &opus_cfg, sizeof(pjmedia_codec_opus_config));\n    opus_data->pool      = pool;\n    codec->op            = &opus_op;\n    codec->factory       = factory;\n    codec->codec_data    = opus_data;\n\n    *p_codec = codec;\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Free codec.\n */\nstatic pj_status_t factory_dealloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t\t  pjmedia_codec *codec )\n{\n    struct opus_data *opus_data;\n\n    PJ_ASSERT_RETURN(factory && codec, PJ_EINVAL);\n    PJ_ASSERT_RETURN(factory == &opus_codec_factory.base, PJ_EINVAL);\n\n    opus_data = (struct opus_data *)codec->codec_data;\n    if (opus_data) {\n        pj_mutex_destroy(opus_data->mutex);\n        opus_data->mutex = NULL;\n\tpj_pool_release(opus_data->pool);\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Init codec.\n */\nstatic pj_status_t codec_init( pjmedia_codec *codec, \n\t\t\t       pj_pool_t *pool )\n{\n    PJ_UNUSED_ARG(codec);\n    PJ_UNUSED_ARG(pool);\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Open codec.\n */\nstatic pj_status_t  codec_open( pjmedia_codec *codec,\n\t\t\t\tpjmedia_codec_param *attr )\n{\n    struct opus_data *opus_data = (struct opus_data *)codec->codec_data;\n    int idx, err;\n    pj_bool_t auto_bit_rate = PJ_TRUE;\n\n    PJ_ASSERT_RETURN(codec && attr && opus_data, PJ_EINVAL);\n\n    pj_mutex_lock (opus_data->mutex);\n\n    TRACE_((THIS_FILE, \"%s:%d: - TRACE\", __FUNCTION__, __LINE__));\n\n    opus_data->cfg.sample_rate = attr->info.clock_rate;\n    opus_data->cfg.channel_cnt = attr->info.channel_cnt;\n    opus_data->enc_ptime = opus_data->dec_ptime = attr->info.frm_ptime;\n\n    /* Allocate memory used by the codec */\n    if (!opus_data->enc) {\n\t/* Allocate memory for max 2 channels */\n\topus_data->enc = pj_pool_zalloc(opus_data->pool,\n\t\t\t\t\topus_encoder_get_size(2));\n    }\n    if (!opus_data->dec) {\n\t/* Allocate memory for max 2 channels */\n\topus_data->dec = pj_pool_zalloc(opus_data->pool,\n\t\t\t\t\topus_decoder_get_size(2));\n    }\n    if (!opus_data->enc_packer) {\n\topus_data->enc_packer = pj_pool_zalloc(opus_data->pool,\n\t\t\t\t\t       opus_repacketizer_get_size());\n    }\n    if (!opus_data->dec_packer) {\n\topus_data->dec_packer = pj_pool_zalloc(opus_data->pool,\n\t\t\t\t\t       opus_repacketizer_get_size());\n    }\n    if (!opus_data->enc || !opus_data->dec ||\n\t!opus_data->enc_packer || !opus_data->dec_packer)\n    {\n\tPJ_LOG(2, (THIS_FILE, \"Unable to allocate memory for the codec\"));\n        pj_mutex_unlock (opus_data->mutex);\n\treturn PJ_ENOMEM;\n    }\n\n    /* Check max average bit rate */\n    idx = find_fmtp(&attr->setting.enc_fmtp, &STR_MAX_BIT_RATE, PJ_FALSE);\n    if (idx >= 0) {\n\tunsigned rate;\n\tauto_bit_rate = PJ_FALSE;\n\trate = (unsigned)pj_strtoul(&attr->setting.enc_fmtp.param[idx].val);\n\tif (rate < attr->info.avg_bps)\n\t    attr->info.avg_bps = rate;\n    }\n\n    /* Check plc */\n    idx = find_fmtp(&attr->setting.enc_fmtp, &STR_INBAND_FEC, PJ_FALSE);\n    if (idx >= 0) {\n\tunsigned plc;\n\tplc = (unsigned) pj_strtoul(&attr->setting.enc_fmtp.param[idx].val);\n\tattr->setting.plc = plc > 0? PJ_TRUE: PJ_FALSE;\n    }\n\n    /* Check vad */\n    idx = find_fmtp(&attr->setting.enc_fmtp, &STR_DTX, PJ_FALSE);\n    if (idx >= 0) {\n\tunsigned vad;\n\tvad = (unsigned) pj_strtoul(&attr->setting.enc_fmtp.param[idx].val);\n\tattr->setting.vad = vad > 0? PJ_TRUE: PJ_FALSE;\n    }\n\n    /* Check cbr */\n    idx = find_fmtp(&attr->setting.enc_fmtp, &STR_CBR, PJ_FALSE);\n    if (idx >= 0) {\n\tunsigned cbr;\n\tcbr = (unsigned) pj_strtoul(&attr->setting.enc_fmtp.param[idx].val);\n\topus_data->cfg.cbr = cbr > 0? PJ_TRUE: PJ_FALSE;\n    }\n    \n    /* Check max average bit rate */\n    idx = find_fmtp(&attr->setting.dec_fmtp, &STR_MAX_BIT_RATE, PJ_FALSE);\n    if (idx >= 0) {\n\tunsigned rate;\n\trate = (unsigned) pj_strtoul(&attr->setting.dec_fmtp.param[idx].val);\n\tif (rate < attr->info.avg_bps)\n\t    attr->info.avg_bps = rate;\n    }\n\n    TRACE_((THIS_FILE, \"%s:%d: sample_rate: %u\",\n\t    __FUNCTION__, __LINE__, opus_data->cfg.sample_rate));\n\n    /* Initialize encoder */\n    err = opus_encoder_init(opus_data->enc,\n\t\t\t    opus_data->cfg.sample_rate,\n\t\t\t    attr->info.channel_cnt,\n\t\t\t    OPUS_APPLICATION_VOIP);\n    if (err != OPUS_OK) {\n\tPJ_LOG(2, (THIS_FILE, \"Unable to create encoder\"));\n\tpj_mutex_unlock (opus_data->mutex);\n\treturn PJMEDIA_CODEC_EFAILED;\n    }\n    \n    /* Set signal type */\n    opus_encoder_ctl(opus_data->enc, OPUS_SET_SIGNAL(OPUS_SIGNAL_VOICE));\n    /* Set bitrate */\n    opus_encoder_ctl(opus_data->enc, OPUS_SET_BITRATE(auto_bit_rate?\n    \t\t\t\t\t\t      OPUS_AUTO:\n    \t\t\t\t\t\t      attr->info.avg_bps));\n    /* Set VAD */\n    opus_encoder_ctl(opus_data->enc, OPUS_SET_DTX(attr->setting.vad ? 1 : 0));\n    /* Set PLC */\n    opus_encoder_ctl(opus_data->enc,\n    \t\t     OPUS_SET_INBAND_FEC(attr->setting.plc ? 1 : 0));\n    /* Set bandwidth */\n    opus_encoder_ctl(opus_data->enc,\n    \t\t     OPUS_SET_MAX_BANDWIDTH(get_opus_bw_constant(\n    \t\t\t\t\t    opus_data->cfg.sample_rate)));\n    /* Set expected packet loss */\n    opus_encoder_ctl(opus_data->enc,\n    \t\tOPUS_SET_PACKET_LOSS_PERC(opus_data->cfg.packet_loss));\n    /* Set complexity */\n    opus_encoder_ctl(opus_data->enc,\n\t\t     OPUS_SET_COMPLEXITY(opus_data->cfg.complexity));\n    /* Set constant bit rate */\n    opus_encoder_ctl(opus_data->enc,\n    \t\t     OPUS_SET_VBR(opus_data->cfg.cbr ? 0 : 1));\n\n    PJ_LOG(5, (THIS_FILE, \"Initialize Opus encoder, sample rate: %d, \"\n    \t\t\t  \"avg bitrate: %d, vad: %d, plc: %d, pkt loss: %d, \"\n    \t\t\t  \"complexity: %d, constant bit rate: %d\",\n               \t\t  opus_data->cfg.sample_rate,\n               \t\t  attr->info.avg_bps, attr->setting.vad?1:0,\n               \t\t  attr->setting.plc?1:0,\n               \t\t  opus_data->cfg.packet_loss,\n               \t\t  opus_data->cfg.complexity,\n               \t\t  opus_data->cfg.cbr?1:0));\n\n    /* Initialize decoder */\n    err = opus_decoder_init (opus_data->dec,\n\t\t\t     opus_data->cfg.sample_rate,\n\t\t\t     attr->info.channel_cnt);\n    if (err != OPUS_OK) {\n\tPJ_LOG(2, (THIS_FILE, \"Unable to initialize decoder\"));\n\tpj_mutex_unlock (opus_data->mutex);\n\treturn PJMEDIA_CODEC_EFAILED;\n    }\n\n    /* Initialize temporary decode frames used for FEC */\n    opus_data->dec_frame[0].type = PJMEDIA_FRAME_TYPE_NONE;\n    opus_data->dec_frame[0].buf  = pj_pool_zalloc(opus_data->pool,                                   \n        \t(opus_data->cfg.sample_rate / 1000)\n                * 60 * attr->info.channel_cnt * 2 /* bytes per sample */);\n    opus_data->dec_frame[1].type = PJMEDIA_FRAME_TYPE_NONE;\n    opus_data->dec_frame[1].buf  = pj_pool_zalloc(opus_data->pool,\n\t\t(opus_data->cfg.sample_rate / 1000)\n                * 60 * attr->info.channel_cnt * 2 /* bytes per sample */);\n    opus_data->dec_frame_index = -1;\n\n    /* Initialize the repacketizers */\n    opus_repacketizer_init(opus_data->enc_packer);\n    opus_repacketizer_init(opus_data->dec_packer);\n\n    pj_mutex_unlock (opus_data->mutex);\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Close codec.\n */\nstatic pj_status_t  codec_close( pjmedia_codec *codec )\n{\n    PJ_UNUSED_ARG(codec);\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Modify codec settings.\n */\nstatic pj_status_t  codec_modify( pjmedia_codec *codec, \n\t\t\t\t  const pjmedia_codec_param *attr )\n{\n    struct opus_data *opus_data = (struct opus_data *)codec->codec_data;\n\n    pj_mutex_lock (opus_data->mutex);\n\n    TRACE_((THIS_FILE, \"%s:%d: - TRACE\", __FUNCTION__, __LINE__));\n\n    /* Set bitrate */\n    opus_data->cfg.bit_rate = attr->info.avg_bps;\n    opus_encoder_ctl(opus_data->enc, OPUS_SET_BITRATE(attr->info.avg_bps?\n    \t\t\t\t\t\t      attr->info.avg_bps:\n    \t\t\t\t\t\t      OPUS_AUTO));\n    /* Set VAD */\n    opus_encoder_ctl(opus_data->enc, OPUS_SET_DTX(attr->setting.vad ? 1 : 0));\n    /* Set PLC */\n    opus_encoder_ctl(opus_data->enc,\n    \t\t     OPUS_SET_INBAND_FEC(attr->setting.plc ? 1 : 0));\n\n    pj_mutex_unlock (opus_data->mutex);\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get frames in the packet.\n */\nstatic pj_status_t  codec_parse( pjmedia_codec *codec,\n\t\t\t\t void *pkt,\n\t\t\t\t pj_size_t pkt_size,\n\t\t\t\t const pj_timestamp *ts,\n\t\t\t\t unsigned *frame_cnt,\n\t\t\t\t pjmedia_frame frames[] )\n{\n    struct opus_data *opus_data = (struct opus_data *)codec->codec_data;\n    unsigned char tmp_buf[MAX_ENCODED_PACKET_SIZE];\n    int i, num_frames;\n    int size, out_pos;\n    unsigned samples_per_frame = 0;\n#if (USE_INCOMING_WORSE_SETTINGS)\n    int bw;\n#endif\n\n    pj_mutex_lock (opus_data->mutex);\n\n    if (pkt_size > sizeof(tmp_buf)) {\n\tPJ_LOG(5, (THIS_FILE, \"Encoded size bigger than buffer\"));\n        pj_mutex_unlock (opus_data->mutex);\n\treturn PJMEDIA_CODEC_EFRMTOOSHORT;\n    }\n\n    pj_memcpy(tmp_buf, pkt, pkt_size);\n\n    opus_repacketizer_init(opus_data->dec_packer);\n    opus_repacketizer_cat(opus_data->dec_packer, tmp_buf, pkt_size);\n\n    num_frames = opus_repacketizer_get_nb_frames(opus_data->dec_packer);\n    if (num_frames == 0) {\n      PJ_LOG(2, (THIS_FILE, \"No frames retrieved (num_frames = 0)\"));\n      pj_mutex_unlock(opus_data->mutex);\n      return PJMEDIA_CODEC_EFAILED;\n    }\n\n    out_pos = 0;\n    for (i = 0; i < num_frames; ++i) {\n\tsize = opus_repacketizer_out_range(opus_data->dec_packer, i, i+1,\n\t\t\t\t\t   ((unsigned char*)pkt) + out_pos,\n\t\t\t\t\t   sizeof(tmp_buf));\n\tif (size < 0) {\n\t    PJ_LOG(5, (THIS_FILE, \"Parse failed! (pkt_size=%d, err=%d)\",\n\t\t       pkt_size, size));\n            pj_mutex_unlock (opus_data->mutex);\n\t    return PJMEDIA_CODEC_EFAILED;\n\t}\n\tframes[i].type = PJMEDIA_FRAME_TYPE_AUDIO;\n\tframes[i].buf = ((char*)pkt) + out_pos;\n\tframes[i].size = size;\n\tframes[i].bit_info = 0;\n\n\tif (i == 0) {\n\t    int nsamples;\n\t    unsigned ptime;\n\n\t    nsamples = opus_packet_get_nb_samples(frames[i].buf,\n\t\t\t\t\t\t  frames[i].size,\n\t\t\t\t\t\t  opus_data->cfg.sample_rate);\n\t    if (nsamples <= 0) {\n\t\tPJ_LOG(5, (THIS_FILE, \"Parse failed to get samples number! \"\n\t\t\t\t      \"(err=%d)\", nsamples));\n\t\tpj_mutex_unlock (opus_data->mutex);\n\t\treturn PJMEDIA_CODEC_EFAILED;\n\t    }\n\n\t    ptime = nsamples * 1000 / opus_data->cfg.sample_rate;\n    \t    if (ptime != opus_data->dec_ptime) {\n             \tPJ_LOG(4, (THIS_FILE, \"Opus ptime change detected: %d ms \"\n             \t\t\t      \"--> %d ms\",\n             \t\t\t      opus_data->dec_ptime, ptime));\n        \topus_data->dec_ptime = ptime;\n        \topus_data->dec_frame_index = -1;\n\n        \t/* Signal to the stream about ptime change. */\n\t\tframes[i].bit_info = 0x10000 | nsamples;\n    \t    }\n\t    samples_per_frame = nsamples;\n   \t}\n\n\tframes[i].timestamp.u64 = ts->u64 + i * samples_per_frame;\n\tout_pos += size;\n    }\n    *frame_cnt = num_frames;\n\n    pj_mutex_unlock (opus_data->mutex);\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Encode frame.\n */\nstatic pj_status_t codec_encode( pjmedia_codec *codec, \n\t\t\t\t const struct pjmedia_frame *input,\n\t\t\t\t unsigned output_buf_len, \n\t\t\t\t struct pjmedia_frame *output )\n{\n    struct opus_data *opus_data = (struct opus_data *)codec->codec_data;\n    opus_int32 size  = 0;\n    unsigned in_pos  = 0;\n    unsigned out_pos = 0;\n    unsigned frame_size;\n    unsigned samples_per_frame;\n    unsigned char tmp_buf[MAX_ENCODED_PACKET_SIZE];\n    unsigned tmp_bytes_left = sizeof(tmp_buf);\n\n    pj_mutex_lock (opus_data->mutex);\n\n    samples_per_frame = (opus_data->cfg.sample_rate *\n\t\t\t opus_data->enc_ptime) / 1000;\n    frame_size = samples_per_frame * opus_data->cfg.channel_cnt *\n    \t\t sizeof(opus_int16);\n\n    opus_repacketizer_init(opus_data->enc_packer);\n    while (input->size - in_pos >= frame_size) {\n\tsize = opus_encode(opus_data->enc,\n\t\t\t   (const opus_int16*)(((char*)input->buf) + in_pos),\n\t\t\t   samples_per_frame,\n\t\t\t   tmp_buf + out_pos,\n\t\t\t   (tmp_bytes_left < frame_size ?\n\t\t\t    tmp_bytes_left : frame_size));\n\tif (size < 0) {\n\t    PJ_LOG(4, (THIS_FILE, \"Encode failed! (%d)\", size));\n            pj_mutex_unlock (opus_data->mutex);\n\t    return PJMEDIA_CODEC_EFAILED;\n\t} else if (size > 0) {\n\t    /* Only add packets containing more than the TOC */\n\t    opus_repacketizer_cat(opus_data->enc_packer,\n\t\t\t\t  tmp_buf + out_pos,\n\t\t\t\t  size);\n\t    out_pos += size;\n\t    tmp_bytes_left -= size;\n\t}\n\tin_pos += frame_size;\n    }\n\n    if (!opus_repacketizer_get_nb_frames(opus_data->enc_packer)) {\n\t/* Empty packet */\n\toutput->size      = 0;\n\toutput->type      = PJMEDIA_FRAME_TYPE_NONE;\n\toutput->timestamp = input->timestamp;\n    }\n\n    if (size) {\n\tsize = opus_repacketizer_out(opus_data->enc_packer,\n\t\t\t\t     output->buf,\n\t\t\t\t     output_buf_len);\n\tif (size < 0) {\n\t    PJ_LOG(4, (THIS_FILE, \"Encode failed! (%d), out_size: %u\",\n\t    \t\t\t  size, output_buf_len));\n\t    pj_mutex_unlock (opus_data->mutex);\n\t    return PJMEDIA_CODEC_EFAILED;\n\t}\n    }\n\n    output->size      = (unsigned)size;\n    output->type      = PJMEDIA_FRAME_TYPE_AUDIO;\n    output->timestamp = input->timestamp;\n\n    pj_mutex_unlock (opus_data->mutex);\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Decode frame.\n */\nstatic pj_status_t  codec_decode( pjmedia_codec *codec, \n\t\t\t\t  const struct pjmedia_frame *input,\n\t\t\t\t  unsigned output_buf_len, \n\t\t\t\t  struct pjmedia_frame *output )\n{\n    struct opus_data *opus_data = (struct opus_data *)codec->codec_data;\n    int decoded_samples;\n    pjmedia_frame *inframe;\n    int fec = 0;\n    int frm_size;\n\n    PJ_UNUSED_ARG(output_buf_len);\n\n    pj_mutex_lock (opus_data->mutex);\n\n    if (opus_data->dec_frame_index == -1) {\n        /* First packet, buffer it. */\n        opus_data->dec_frame[0].type = input->type;\n        opus_data->dec_frame[0].size = input->size;\n        opus_data->dec_frame[0].timestamp = input->timestamp;\n        pj_memcpy(opus_data->dec_frame[0].buf, input->buf, input->size);\n        opus_data->dec_frame_index = 0;\n        pj_mutex_unlock (opus_data->mutex);\n\n        /* Return zero decoded bytes */\n        output->size = 0;\n        output->type = PJMEDIA_FRAME_TYPE_NONE;\n        output->timestamp = input->timestamp;\n\n        return PJ_SUCCESS;\n    }\n\n    inframe = &opus_data->dec_frame[opus_data->dec_frame_index];\n\n    if (inframe->type != PJMEDIA_FRAME_TYPE_AUDIO) {\n        /* Update current frame index */\n        opus_data->dec_frame_index++;\n        if (opus_data->dec_frame_index > 1)\n            opus_data->dec_frame_index = 0;\n        /* Copy original input buffer to current indexed frame */\n        inframe = &opus_data->dec_frame[opus_data->dec_frame_index];\n        inframe->type = input->type;\n        inframe->size = input->size;\n        inframe->timestamp = input->timestamp;\n        pj_memcpy(inframe->buf, input->buf, input->size);\n        fec = 1;\n    }\n\n    /* From Opus doc: In the case of PLC (data==NULL) or FEC(decode_fec=1),\n     * then frame_size needs to be exactly the duration of audio that\n     * is missing.\n     */\n    frm_size = output->size / (sizeof(opus_int16) *\n               opus_data->cfg.channel_cnt);\n    if (inframe->type != PJMEDIA_FRAME_TYPE_AUDIO || fec) {\n\tfrm_size = PJ_MIN((unsigned)frm_size,\n\t\t\t  opus_data->cfg.sample_rate *\n\t\t\t  opus_data->dec_ptime / 1000);\n    }\n    decoded_samples = opus_decode( opus_data->dec,\n                                   inframe->type==PJMEDIA_FRAME_TYPE_AUDIO ?\n                                   inframe->buf : NULL,\n                                   inframe->type==PJMEDIA_FRAME_TYPE_AUDIO ?\n                                   inframe->size : 0,\n                                   (opus_int16*)output->buf,\n                                   frm_size,\n                                   fec);\n    output->timestamp = inframe->timestamp;\n     \n    if (inframe->type == PJMEDIA_FRAME_TYPE_AUDIO) {\n        /* Mark current indexed frame as invalid */\n        inframe->type = PJMEDIA_FRAME_TYPE_NONE;\n        /* Update current frame index */\n        opus_data->dec_frame_index++;\n        if (opus_data->dec_frame_index > 1)\n            opus_data->dec_frame_index = 0;\n        /* Copy original input buffer to current indexed frame */\n        inframe = &opus_data->dec_frame[opus_data->dec_frame_index];\n        inframe->type = input->type;\n        inframe->size = input->size;\n        inframe->timestamp = input->timestamp;\n        pj_memcpy(inframe->buf, input->buf, input->size);\n    }\n\n    if (decoded_samples < 0) {\n        PJ_LOG(4, (THIS_FILE, \"Decode failed!\"));\n        pj_mutex_unlock (opus_data->mutex);\n        return PJMEDIA_CODEC_EFAILED;\n    }\n\n    output->size = decoded_samples * sizeof(opus_int16) * \n    \t\t   opus_data->cfg.channel_cnt;\n    output->type = PJMEDIA_FRAME_TYPE_AUDIO;\n\n    pj_mutex_unlock (opus_data->mutex);\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Recover lost frame.\n */\nstatic pj_status_t  codec_recover( pjmedia_codec *codec,\n\t\t\t\t   unsigned output_buf_len,\n\t\t\t\t   struct pjmedia_frame *output )\n{\n    struct opus_data *opus_data = (struct opus_data *)codec->codec_data;\n    int decoded_samples;\n    pjmedia_frame *inframe;\n    int frm_size;\n\n    PJ_UNUSED_ARG(output_buf_len);\n    pj_mutex_lock (opus_data->mutex);\n\n    if (opus_data->dec_frame_index == -1) {\n        /* Recover the first packet? Don't think so, fill it with zeroes. */\n\tunsigned samples_per_frame;\n\tsamples_per_frame = opus_data->cfg.sample_rate * opus_data->dec_ptime/\n\t\t\t    1000;\n\toutput->type = PJMEDIA_FRAME_TYPE_AUDIO;\n\toutput->size = samples_per_frame << 1;\n\tpjmedia_zero_samples((pj_int16_t*)output->buf, samples_per_frame);\n        pj_mutex_unlock (opus_data->mutex);\n\n        return PJ_SUCCESS;\n    }\n\n    inframe = &opus_data->dec_frame[opus_data->dec_frame_index];\n    frm_size = output->size / (sizeof(opus_int16) *\n               opus_data->cfg.channel_cnt);\n    if (inframe->type != PJMEDIA_FRAME_TYPE_AUDIO) {\n\tfrm_size = PJ_MIN((unsigned)frm_size, opus_data->cfg.sample_rate *\n\t\t\t  opus_data->dec_ptime/1000);\n    }\n    decoded_samples = opus_decode(opus_data->dec,\n\t\t\t\t  inframe->type==PJMEDIA_FRAME_TYPE_AUDIO ?\n\t\t\t\t  inframe->buf : NULL,\n\t\t\t\t  inframe->type==PJMEDIA_FRAME_TYPE_AUDIO ?\n\t\t\t\t  inframe->size : 0,\n\t\t\t\t  (opus_int16*)output->buf,\n\t\t\t\t  frm_size,\n\t\t\t\t  0);\n\n    /* Mark current indexed frame as invalid */\n    inframe->type = PJMEDIA_FRAME_TYPE_NONE;\n    \n    /* Update current frame index */\n    opus_data->dec_frame_index++;\n    if (opus_data->dec_frame_index > 1)\n        opus_data->dec_frame_index = 0;\n    /* Mark current indexed frame as invalid */\n    inframe = &opus_data->dec_frame[opus_data->dec_frame_index];\n    inframe->type = PJMEDIA_FRAME_TYPE_NONE;\n\n    if (decoded_samples < 0) {\n        PJ_LOG(4, (THIS_FILE, \"Recover failed!\"));\n        pj_mutex_unlock (opus_data->mutex);\n        return PJMEDIA_CODEC_EFAILED;\n    }\n\n    output->size = decoded_samples * sizeof(opus_int16) * \n    \t\t   opus_data->cfg.channel_cnt;\n    output->type = PJMEDIA_FRAME_TYPE_AUDIO;\n    output->timestamp = inframe->timestamp;\n\n    pj_mutex_unlock (opus_data->mutex);\n    return PJ_SUCCESS;\n}\n\n#if defined(_MSC_VER)\n#   pragma comment(lib, \"libopus.a\")\n#endif\n\n\n#endif /* PJMEDIA_HAS_OPUS_CODEC */\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia-codec/passthrough.h>\n#include <pjmedia-codec/amr_sdp_match.h>\n#include <pjmedia/codec.h>\n#include <pjmedia/errno.h>\n#include <pjmedia/endpoint.h>\n#include <pjmedia/port.h>\n#include <pj/assert.h>\n#include <pj/log.h>\n#include <pj/math.h>\n#include <pj/pool.h>\n#include <pj/string.h>\n#include <pj/os.h>\n\n/*\n * Only build this file if PJMEDIA_HAS_PASSTHROUGH_CODECS != 0\n */\n#if defined(PJMEDIA_HAS_PASSTHROUGH_CODECS) && PJMEDIA_HAS_PASSTHROUGH_CODECS!=0\n\n#define THIS_FILE   \"passthrough.c\"\n\n\n/* Prototypes for passthrough codecs factory */\nstatic pj_status_t test_alloc( pjmedia_codec_factory *factory, \n\t\t\t       const pjmedia_codec_info *id );\nstatic pj_status_t default_attr( pjmedia_codec_factory *factory, \n\t\t\t\t const pjmedia_codec_info *id, \n\t\t\t\t pjmedia_codec_param *attr );\nstatic pj_status_t enum_codecs( pjmedia_codec_factory *factory, \n\t\t\t\tunsigned *count, \n\t\t\t\tpjmedia_codec_info codecs[]);\nstatic pj_status_t alloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\tconst pjmedia_codec_info *id, \n\t\t\t\tpjmedia_codec **p_codec);\nstatic pj_status_t dealloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t  pjmedia_codec *codec );\n\n/* Prototypes for passthrough codecs implementation. */\nstatic pj_status_t codec_init( pjmedia_codec *codec, \n\t\t\t       pj_pool_t *pool );\nstatic pj_status_t codec_open( pjmedia_codec *codec, \n\t\t\t       pjmedia_codec_param *attr );\nstatic pj_status_t codec_close( pjmedia_codec *codec );\nstatic pj_status_t codec_modify(pjmedia_codec *codec, \n\t\t\t        const pjmedia_codec_param *attr );\nstatic pj_status_t codec_parse( pjmedia_codec *codec,\n\t\t\t        void *pkt,\n\t\t\t\tpj_size_t pkt_size,\n\t\t\t\tconst pj_timestamp *ts,\n\t\t\t\tunsigned *frame_cnt,\n\t\t\t\tpjmedia_frame frames[]);\nstatic pj_status_t codec_encode( pjmedia_codec *codec, \n\t\t\t\t const struct pjmedia_frame *input,\n\t\t\t\t unsigned output_buf_len,\n\t\t\t\t struct pjmedia_frame *output);\nstatic pj_status_t codec_decode( pjmedia_codec *codec,\n\t\t\t\t const struct pjmedia_frame *input,\n\t\t\t\t unsigned output_buf_len, \n\t\t\t\t struct pjmedia_frame *output);\nstatic pj_status_t codec_recover( pjmedia_codec *codec, \n\t\t\t\t  unsigned output_buf_len, \n\t\t\t\t  struct pjmedia_frame *output);\n\n/* Definition for passthrough codecs operations. */\nstatic pjmedia_codec_op codec_op = \n{\n    &codec_init,\n    &codec_open,\n    &codec_close,\n    &codec_modify,\n    &codec_parse,\n    &codec_encode,\n    &codec_decode,\n    &codec_recover\n};\n\n/* Definition for passthrough codecs factory operations. */\nstatic pjmedia_codec_factory_op codec_factory_op =\n{\n    &test_alloc,\n    &default_attr,\n    &enum_codecs,\n    &alloc_codec,\n    &dealloc_codec,\n    &pjmedia_codec_passthrough_deinit\n};\n\n/* Passthrough codecs factory */\nstatic struct codec_factory {\n    pjmedia_codec_factory    base;\n    pjmedia_endpt\t    *endpt;\n    pj_pool_t\t\t    *pool;\n    pj_mutex_t\t\t    *mutex;\n} codec_factory;\n\n/* Passthrough codecs private data. */\ntypedef struct codec_private {\n    pj_pool_t\t\t*pool;\t\t    /**< Pool for each instance.    */\n    int\t\t\t codec_idx;\t    /**< Codec index.\t\t    */\n    void\t\t*codec_setting;\t    /**< Specific codec setting.    */\n    pj_uint16_t\t\t avg_frame_size;    /**< Average of frame size.\t    */\n    unsigned\t\t samples_per_frame; /**< Samples per frame, for iLBC\n\t\t\t\t\t\t this can be 240 or 160, can\n\t\t\t\t\t\t only be known after codec is\n\t\t\t\t\t\t opened.\t\t    */\n} codec_private_t;\n\n\n\n/* CUSTOM CALLBACKS */\n\n/* Parse frames from a packet. Default behaviour of frame parsing is \n * just separating frames based on calculating frame length derived \n * from bitrate. Implement this callback when the default behaviour is \n * unapplicable.\n */\ntypedef pj_status_t (*parse_cb)(codec_private_t *codec_data, void *pkt, \n\t\t\t\tpj_size_t pkt_size, const pj_timestamp *ts,\n\t\t\t\tunsigned *frame_cnt, pjmedia_frame frames[]);\n\n/* Pack frames into a packet. Default behaviour of packing frames is \n * just stacking the frames with octet aligned without adding any \n * payload header. Implement this callback when the default behaviour is\n * unapplicable.\n */\ntypedef pj_status_t (*pack_cb)(codec_private_t *codec_data, \n\t\t\t       const struct pjmedia_frame_ext *input,\n\t\t\t       unsigned output_buf_len, \n\t\t\t       struct pjmedia_frame *output);\n\n\n/* Custom callback implementations. */\nstatic pj_status_t parse_amr( codec_private_t *codec_data, void *pkt, \n\t\t\t      pj_size_t pkt_size, const pj_timestamp *ts,\n\t\t\t      unsigned *frame_cnt, pjmedia_frame frames[]);\nstatic pj_status_t pack_amr ( codec_private_t *codec_data,\n\t\t\t      const struct pjmedia_frame_ext *input,\n\t\t\t      unsigned output_buf_len, \n\t\t\t      struct pjmedia_frame *output);\n\n\n/* Passthrough codec implementation descriptions. */\nstatic struct codec_desc {\n    int\t\t     enabled;\t\t/* Is this codec enabled?\t    */\n    const char\t    *name;\t\t/* Codec name.\t\t\t    */\n    pj_uint8_t\t     pt;\t\t/* Payload type.\t\t    */\n    pjmedia_format_id fmt_id;\t\t/* Source format.\t\t    */\n    unsigned\t     clock_rate;\t/* Codec's clock rate.\t\t    */\n    unsigned\t     channel_count;\t/* Codec's channel count.\t    */\n    unsigned\t     samples_per_frame;\t/* Codec's samples count.\t    */\n    unsigned\t     def_bitrate;\t/* Default bitrate of this codec.   */\n    unsigned\t     max_bitrate;\t/* Maximum bitrate of this codec.   */\n    pj_uint8_t\t     frm_per_pkt;\t/* Default num of frames per packet.*/\n    pj_uint8_t\t     vad;\t\t/* VAD enabled/disabled.\t    */\n    pj_uint8_t\t     plc;\t\t/* PLC enabled/disabled.\t    */\n    parse_cb\t     parse;\t\t/* Callback to parse bitstream.\t    */\n    pack_cb\t     pack;\t\t/* Callback to pack bitstream.\t    */\n    pjmedia_codec_fmtp dec_fmtp;\t/* Decoder's fmtp params.\t    */\n}\n\ncodec_desc[] = \n{\n#   if PJMEDIA_HAS_PASSTHROUGH_CODEC_AMR\n    {1, \"AMR\",\t    PJMEDIA_RTP_PT_AMR,       PJMEDIA_FORMAT_AMR,\n\t\t    8000, 1, 160, \n\t\t    7400, 12200, 2, 1, 1,\n\t\t    &parse_amr, &pack_amr\n\t\t    /*, {1, {{{\"octet-align\", 11}, {\"1\", 1}}} } */\n    },\n#   endif\n\n#   if PJMEDIA_HAS_PASSTHROUGH_CODEC_G729\n    {1, \"G729\",\t    PJMEDIA_RTP_PT_G729,      PJMEDIA_FORMAT_G729,\n\t\t    8000, 1,  80,\n\t\t    8000, 8000, 2, 1, 1\n    },\n#   endif\n\n#   if PJMEDIA_HAS_PASSTHROUGH_CODEC_ILBC\n    {1, \"iLBC\",\t    PJMEDIA_RTP_PT_ILBC,      PJMEDIA_FORMAT_ILBC,\n\t\t    8000, 1,  240,\n\t\t    13333, 15200, 1, 1, 1,\n\t\t    NULL, NULL,\n\t\t    {1, {{{\"mode\", 4}, {\"30\", 2}}} }\n    },\n#   endif\n\n#   if PJMEDIA_HAS_PASSTHROUGH_CODEC_PCMU\n    {1, \"PCMU\",\t    PJMEDIA_RTP_PT_PCMU,      PJMEDIA_FORMAT_PCMU,\n\t\t    8000, 1,  80,\n\t\t    64000, 64000, 2, 1, 1\n    },\n#   endif\n\n#   if PJMEDIA_HAS_PASSTHROUGH_CODEC_PCMA\n    {1, \"PCMA\",\t    PJMEDIA_RTP_PT_PCMA,      PJMEDIA_FORMAT_PCMA,\n\t\t    8000, 1,  80,\n\t\t    64000, 64000, 2, 1, 1\n    },\n#   endif\n};\n\n\n#if PJMEDIA_HAS_PASSTHROUGH_CODEC_AMR\n\n#include <pjmedia-codec/amr_helper.h>\n\ntypedef struct amr_settings_t {\n    pjmedia_codec_amr_pack_setting enc_setting;\n    pjmedia_codec_amr_pack_setting dec_setting;\n    pj_int8_t enc_mode;\n} amr_settings_t;\n\n\n/* Pack AMR payload */\nstatic pj_status_t pack_amr ( codec_private_t *codec_data,\n\t\t\t      const struct pjmedia_frame_ext *input,\n\t\t\t      unsigned output_buf_len, \n\t\t\t      struct pjmedia_frame *output)\n{\n    enum {MAX_FRAMES_PER_PACKET = PJMEDIA_MAX_FRAME_DURATION_MS / 20};\n\n    pjmedia_frame frames[MAX_FRAMES_PER_PACKET];\n    amr_settings_t* setting = (amr_settings_t*)codec_data->codec_setting;\n    pjmedia_codec_amr_pack_setting *enc_setting = &setting->enc_setting;\n    pj_uint8_t SID_FT;\n    unsigned i;\n\n    pj_assert(input->subframe_cnt <= MAX_FRAMES_PER_PACKET);\n\n    SID_FT = (pj_uint8_t)(enc_setting->amr_nb? 8 : 9);\n\n    /* Get frames */\n    for (i = 0; i < input->subframe_cnt; ++i) {\n\tpjmedia_frame_ext_subframe *sf;\n\tpjmedia_codec_amr_bit_info *info;\n\tunsigned len;\n\t\n\tsf = pjmedia_frame_ext_get_subframe(input, i);\n\tlen = (sf->bitlen + 7) >> 3;\n\t\n\tinfo = (pjmedia_codec_amr_bit_info*) &frames[i].bit_info;\n\tpj_bzero(info, sizeof(*info));\n\t\n\tif (len == 0) {\n\t    /* DTX */\n\t    info->frame_type = 15;\n\t} else {\n\t    info->frame_type = pjmedia_codec_amr_get_mode2(enc_setting->amr_nb, \n\t\t\t\t\t\t\t   len);\n\t}\n\tinfo->good_quality = 1;\n\tinfo->mode = setting->enc_mode;\n\tif (info->frame_type == SID_FT)\n\t    info->STI = (sf->data[4] >> 4) & 1;\n\n\tframes[i].buf = sf->data;\n\tframes[i].size = len;\n    }\n\n    output->size = output_buf_len;\n\n    return pjmedia_codec_amr_pack(frames, input->subframe_cnt, enc_setting, \n\t\t\t\t  output->buf, &output->size);\n}\n\n\n/* Parse AMR payload into frames. */\nstatic pj_status_t parse_amr(codec_private_t *codec_data, void *pkt, \n\t\t\t     pj_size_t pkt_size, const pj_timestamp *ts,\n\t\t\t     unsigned *frame_cnt, pjmedia_frame frames[])\n{\n    amr_settings_t* s = (amr_settings_t*)codec_data->codec_setting;\n    pjmedia_codec_amr_pack_setting *setting;\n    pj_status_t status;\n    pj_uint8_t cmr;\n\n    setting = &s->dec_setting;\n\n    status = pjmedia_codec_amr_parse(pkt, pkt_size, ts, setting, frames, \n\t\t\t\t     frame_cnt, &cmr);\n    if (status != PJ_SUCCESS)\n\treturn status;\n\n    // CMR is not supported for now. \n    /* Check Change Mode Request. */\n    //if ((setting->amr_nb && cmr <= 7) || (!setting->amr_nb && cmr <= 8)) {\n    //\ts->enc_mode = cmr;\n    //}\n\n    return PJ_SUCCESS;\n}\n\n#endif /* PJMEDIA_HAS_PASSTHROUGH_CODEC_AMR */\n\n\n/*\n * Initialize and register passthrough codec factory to pjmedia endpoint.\n */\nPJ_DEF(pj_status_t) pjmedia_codec_passthrough_init( pjmedia_endpt *endpt )\n{\n    pjmedia_codec_mgr *codec_mgr;\n    pj_str_t codec_name;\n    pj_status_t status;\n\n    if (codec_factory.pool != NULL) {\n\t/* Already initialized. */\n\treturn PJ_EEXISTS;\n    }\n\n    /* Create passthrough codec factory. */\n    codec_factory.base.op = &codec_factory_op;\n    codec_factory.base.factory_data = NULL;\n    codec_factory.endpt = endpt;\n\n    codec_factory.pool = pjmedia_endpt_create_pool(endpt, \"Passthrough codecs\",\n\t\t\t\t\t\t   4000, 4000);\n    if (!codec_factory.pool)\n\treturn PJ_ENOMEM;\n\n    /* Create mutex. */\n    status = pj_mutex_create_simple(codec_factory.pool, \"Passthrough codecs\",\n\t\t\t\t    &codec_factory.mutex);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Get the codec manager. */\n    codec_mgr = pjmedia_endpt_get_codec_mgr(endpt);\n    if (!codec_mgr) {\n\tstatus = PJ_EINVALIDOP;\n\tgoto on_error;\n    }\n\n    /* Register format match callback. */\n#if PJMEDIA_HAS_PASSTHROUGH_CODEC_AMR\n    pj_cstr(&codec_name, \"AMR\");\n    status = pjmedia_sdp_neg_register_fmt_match_cb(\n\t\t\t\t\t&codec_name,\n\t\t\t\t\t&pjmedia_codec_amr_match_sdp);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n#endif\n\n    /* Suppress compile warning */\n    PJ_UNUSED_ARG(codec_name);\n\n    /* Register codec factory to endpoint. */\n    status = pjmedia_codec_mgr_register_factory(codec_mgr, \n\t\t\t\t\t\t&codec_factory.base);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Done. */\n    return PJ_SUCCESS;\n\non_error:\n    pj_pool_release(codec_factory.pool);\n    codec_factory.pool = NULL;\n    return status;\n}\n\n/*\n * Initialize and register passthrough codec factory to pjmedia endpoint.\n */\nPJ_DEF(pj_status_t) pjmedia_codec_passthrough_init2( \n\t\t      pjmedia_endpt *endpt,\n\t\t      const pjmedia_codec_passthrough_setting *setting)\n{\n    if (codec_factory.pool != NULL) {\n\t/* Already initialized. */\n\treturn PJ_EEXISTS;\n    }\n\n    if (setting != NULL) {\n\tunsigned i;\n\n\t/* Enable/disable codecs based on the specified encoding formats */\n\tfor (i = 0; i < PJ_ARRAY_SIZE(codec_desc); ++i) {\n\t    pj_bool_t enabled = PJ_FALSE;\n\t    unsigned j;\n\n\t    for (j = 0; j < setting->fmt_cnt && !enabled; ++j) {\n\t\tif ((pj_uint32_t)codec_desc[i].fmt_id == setting->fmts[j].id)\n\t\t    enabled = PJ_TRUE;\n\t    }\n\n\t    codec_desc[i].enabled = enabled;\n\t}\n\n#if PJMEDIA_HAS_PASSTHROUGH_CODEC_ILBC\n\t/* Update iLBC codec description based on default mode setting. */\n\tfor (i = 0; i < PJ_ARRAY_SIZE(codec_desc); ++i) {\n\t    if (codec_desc[i].enabled && \n\t\tcodec_desc[i].fmt_id == PJMEDIA_FORMAT_ILBC)\n\t    {\n\t\tcodec_desc[i].samples_per_frame = \n\t\t\t\t(setting->ilbc_mode == 20? 160 : 240);\n\t\tcodec_desc[i].def_bitrate = \n\t\t\t\t(setting->ilbc_mode == 20? 15200 : 13333);\n\t\tpj_strset2(&codec_desc[i].dec_fmtp.param[0].val, \n\t\t\t\t(setting->ilbc_mode == 20? \"20\" : \"30\"));\n\t\tbreak;\n\t    }\n\t}\n#endif\n    }\n\n    return pjmedia_codec_passthrough_init(endpt);\n}\n\n/*\n * Unregister passthrough codecs factory from pjmedia endpoint.\n */\nPJ_DEF(pj_status_t) pjmedia_codec_passthrough_deinit(void)\n{\n    pjmedia_codec_mgr *codec_mgr;\n    unsigned i;\n    pj_status_t status;\n\n    if (codec_factory.pool == NULL) {\n\t/* Already deinitialized */\n\treturn PJ_SUCCESS;\n    }\n\n    pj_mutex_lock(codec_factory.mutex);\n\n    /* Get the codec manager. */\n    codec_mgr = pjmedia_endpt_get_codec_mgr(codec_factory.endpt);\n    if (!codec_mgr) {\n\tpj_pool_release(codec_factory.pool);\n\tcodec_factory.pool = NULL;\n\tpj_mutex_unlock(codec_factory.mutex);\n\treturn PJ_EINVALIDOP;\n    }\n\n    /* Unregister passthrough codecs factory. */\n    status = pjmedia_codec_mgr_unregister_factory(codec_mgr,\n\t\t\t\t\t\t  &codec_factory.base);\n    \n    /* Destroy mutex. */\n    pj_mutex_unlock(codec_factory.mutex);\n    pj_mutex_destroy(codec_factory.mutex);\n    codec_factory.mutex = NULL;\n\n    /* Destroy pool. */\n    pj_pool_release(codec_factory.pool);\n    codec_factory.pool = NULL;\n\n    /* Re-enable all codecs in the codec_desc. */\n    for (i = 0; i < PJ_ARRAY_SIZE(codec_desc); ++i) {\n\tcodec_desc[i].enabled = PJ_TRUE;\n    }\n\n    return status;\n}\n\n/* \n * Check if factory can allocate the specified codec. \n */\nstatic pj_status_t test_alloc( pjmedia_codec_factory *factory, \n\t\t\t       const pjmedia_codec_info *info )\n{\n    unsigned i;\n\n    PJ_UNUSED_ARG(factory);\n\n    /* Type MUST be audio. */\n    if (info->type != PJMEDIA_TYPE_AUDIO)\n\treturn PJMEDIA_CODEC_EUNSUP;\n\n    for (i = 0; i < PJ_ARRAY_SIZE(codec_desc); ++i) {\n\tpj_str_t name = pj_str((char*)codec_desc[i].name);\n\tif ((pj_stricmp(&info->encoding_name, &name) == 0) &&\n\t    (info->clock_rate == (unsigned)codec_desc[i].clock_rate) &&\n\t    (info->channel_cnt == (unsigned)codec_desc[i].channel_count) &&\n\t    (codec_desc[i].enabled))\n\t{\n\t    return PJ_SUCCESS;\n\t}\n    }\n    \n    /* Unsupported, or mode is disabled. */\n    return PJMEDIA_CODEC_EUNSUP;\n}\n\n/*\n * Generate default attribute.\n */\nstatic pj_status_t default_attr ( pjmedia_codec_factory *factory, \n\t\t\t\t  const pjmedia_codec_info *id, \n\t\t\t\t  pjmedia_codec_param *attr )\n{\n    unsigned i;\n\n    PJ_ASSERT_RETURN(factory==&codec_factory.base, PJ_EINVAL);\n\n    pj_bzero(attr, sizeof(pjmedia_codec_param));\n\n    for (i = 0; i < PJ_ARRAY_SIZE(codec_desc); ++i) {\n\tpj_str_t name = pj_str((char*)codec_desc[i].name);\n\tif ((pj_stricmp(&id->encoding_name, &name) == 0) &&\n\t    (id->clock_rate == (unsigned)codec_desc[i].clock_rate) &&\n\t    (id->channel_cnt == (unsigned)codec_desc[i].channel_count) &&\n\t    (id->pt == (unsigned)codec_desc[i].pt))\n\t{\n\t    attr->info.pt = (pj_uint8_t)id->pt;\n\t    attr->info.channel_cnt = codec_desc[i].channel_count;\n\t    attr->info.clock_rate = codec_desc[i].clock_rate;\n\t    attr->info.avg_bps = codec_desc[i].def_bitrate;\n\t    attr->info.max_bps = codec_desc[i].max_bitrate;\n\t    attr->info.pcm_bits_per_sample = 16;\n\t    attr->info.frm_ptime =  (pj_uint16_t)\n\t\t\t\t    (codec_desc[i].samples_per_frame * 1000 / \n\t\t\t\t    codec_desc[i].channel_count / \n\t\t\t\t    codec_desc[i].clock_rate);\n\t    attr->info.fmt_id = codec_desc[i].fmt_id;\n\n\t    /* Default flags. */\n\t    attr->setting.frm_per_pkt = codec_desc[i].frm_per_pkt;\n\t    attr->setting.plc = codec_desc[i].plc;\n\t    attr->setting.penh= 0;\n\t    attr->setting.vad = codec_desc[i].vad;\n\t    attr->setting.cng = attr->setting.vad;\n\t    attr->setting.dec_fmtp = codec_desc[i].dec_fmtp;\n\n\t    if (attr->setting.vad == 0) {\n#if PJMEDIA_HAS_PASSTHROUGH_CODEC_G729\n\t\tif (id->pt == PJMEDIA_RTP_PT_G729) {\n\t\t    /* Signal G729 Annex B is being disabled */\n\t\t    attr->setting.dec_fmtp.cnt = 1;\n\t\t    pj_strset2(&attr->setting.dec_fmtp.param[0].name, \"annexb\");\n\t\t    pj_strset2(&attr->setting.dec_fmtp.param[0].val, \"no\");\n\t\t}\n#endif\n\t    }\n\n\t    return PJ_SUCCESS;\n\t}\n    }\n\n    return PJMEDIA_CODEC_EUNSUP;\n}\n\n/*\n * Enum codecs supported by this factory.\n */\nstatic pj_status_t enum_codecs( pjmedia_codec_factory *factory, \n\t\t\t\tunsigned *count, \n\t\t\t\tpjmedia_codec_info codecs[])\n{\n    unsigned max;\n    unsigned i;\n\n    PJ_UNUSED_ARG(factory);\n    PJ_ASSERT_RETURN(codecs && *count > 0, PJ_EINVAL);\n\n    max = *count;\n    \n    for (i = 0, *count = 0; i < PJ_ARRAY_SIZE(codec_desc) && *count < max; ++i) \n    {\n\tif (!codec_desc[i].enabled)\n\t    continue;\n\n\tpj_bzero(&codecs[*count], sizeof(pjmedia_codec_info));\n\tcodecs[*count].encoding_name = pj_str((char*)codec_desc[i].name);\n\tcodecs[*count].pt = codec_desc[i].pt;\n\tcodecs[*count].type = PJMEDIA_TYPE_AUDIO;\n\tcodecs[*count].clock_rate = codec_desc[i].clock_rate;\n\tcodecs[*count].channel_cnt = codec_desc[i].channel_count;\n\n\t++*count;\n    }\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Allocate a new codec instance.\n */\nstatic pj_status_t alloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\tconst pjmedia_codec_info *id,\n\t\t\t\tpjmedia_codec **p_codec)\n{\n    codec_private_t *codec_data;\n    pjmedia_codec *codec;\n    int idx;\n    pj_pool_t *pool;\n    unsigned i;\n\n    PJ_ASSERT_RETURN(factory && id && p_codec, PJ_EINVAL);\n    PJ_ASSERT_RETURN(factory == &codec_factory.base, PJ_EINVAL);\n\n    pj_mutex_lock(codec_factory.mutex);\n\n    /* Find codec's index */\n    idx = -1;\n    for (i = 0; i < PJ_ARRAY_SIZE(codec_desc); ++i) {\n\tpj_str_t name = pj_str((char*)codec_desc[i].name);\n\tif ((pj_stricmp(&id->encoding_name, &name) == 0) &&\n\t    (id->clock_rate == (unsigned)codec_desc[i].clock_rate) &&\n\t    (id->channel_cnt == (unsigned)codec_desc[i].channel_count) &&\n\t    (codec_desc[i].enabled))\n\t{\n\t    idx = i;\n\t    break;\n\t}\n    }\n    if (idx == -1) {\n\t*p_codec = NULL;\n\tpj_mutex_unlock(codec_factory.mutex);\n\treturn PJMEDIA_CODEC_EUNSUP;\n    }\n\n    /* Create pool for codec instance */\n    pool = pjmedia_endpt_create_pool(codec_factory.endpt, \"passthroughcodec\",\n\t\t\t\t     512, 512);\n    codec = PJ_POOL_ZALLOC_T(pool, pjmedia_codec);\n    codec->op = &codec_op;\n    codec->factory = factory;\n    codec->codec_data = PJ_POOL_ZALLOC_T(pool, codec_private_t);\n    codec_data = (codec_private_t*) codec->codec_data;\n    codec_data->pool = pool;\n    codec_data->codec_idx = idx;\n\n    pj_mutex_unlock(codec_factory.mutex);\n\n    *p_codec = codec;\n    return PJ_SUCCESS;\n}\n\n/*\n * Free codec.\n */\nstatic pj_status_t dealloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t  pjmedia_codec *codec )\n{\n    codec_private_t *codec_data;\n\n    PJ_ASSERT_RETURN(factory && codec, PJ_EINVAL);\n    PJ_ASSERT_RETURN(factory == &codec_factory.base, PJ_EINVAL);\n\n    /* Close codec, if it's not closed. */\n    codec_data = (codec_private_t*) codec->codec_data;\n    codec_close(codec);\n\n    pj_pool_release(codec_data->pool);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Init codec.\n */\nstatic pj_status_t codec_init( pjmedia_codec *codec, \n\t\t\t       pj_pool_t *pool )\n{\n    PJ_UNUSED_ARG(codec);\n    PJ_UNUSED_ARG(pool);\n    return PJ_SUCCESS;\n}\n\n/*\n * Open codec.\n */\nstatic pj_status_t codec_open( pjmedia_codec *codec, \n\t\t\t       pjmedia_codec_param *attr )\n{\n    codec_private_t *codec_data = (codec_private_t*) codec->codec_data;\n    struct codec_desc *desc = &codec_desc[codec_data->codec_idx];\n    pj_pool_t *pool;\n    int i, j;\n\n    pool = codec_data->pool;\n\n    /* Cache samples per frame value */\n    codec_data->samples_per_frame = desc->samples_per_frame;\n\n    /* Calculate bitstream size */\n    i = attr->info.avg_bps * codec_data->samples_per_frame;\n    j = desc->clock_rate << 3;\n    codec_data->avg_frame_size = (pj_uint16_t)(i / j);\n    if (i % j) ++codec_data->avg_frame_size;\n\n#if PJMEDIA_HAS_PASSTHROUGH_CODEC_AMR\n    /* Init AMR settings */\n    if (desc->pt == PJMEDIA_RTP_PT_AMR || desc->pt == PJMEDIA_RTP_PT_AMRWB) {\n\tamr_settings_t *s;\n\tpj_uint8_t octet_align = 0;\n\tpj_int8_t enc_mode;\n\t\n\tenc_mode = pjmedia_codec_amr_get_mode(attr->info.avg_bps);\n\tpj_assert(enc_mode >= 0 && enc_mode <= 8);\n\n\tfor (i = 0; i < attr->setting.dec_fmtp.cnt; ++i) {\n\t    const pj_str_t STR_FMTP_OCTET_ALIGN = {\"octet-align\", 11};\n\t    \n\t    /* Fetch octet-align setting. It should be fine to fetch only \n\t     * the decoder, since encoder & decoder must use the same setting \n\t     * (RFC 4867 section 8.3.1).\n\t     */\n\t    if (pj_stricmp(&attr->setting.dec_fmtp.param[i].name, \n\t\t\t   &STR_FMTP_OCTET_ALIGN) == 0)\n\t    {\n\t\toctet_align=(pj_uint8_t)\n\t\t\t    (pj_strtoul(&attr->setting.dec_fmtp.param[i].val));\n\t\tbreak;\n\t    }\n\t}\n\n\tfor (i = 0; i < attr->setting.enc_fmtp.cnt; ++i) {\n\t    const pj_str_t STR_FMTP_MODE_SET = {\"mode-set\", 8};\n\n\t    /* mode-set, encoding mode is chosen based on local default mode \n\t     * setting:\n\t     * - if local default mode is included in the mode-set, use it\n\t     * - otherwise, find the closest mode to local default mode;\n\t     *   if there are two closest modes, prefer to use the higher\n\t     *   one, e.g: local default mode is 4, the mode-set param\n\t     *   contains '2,3,5,6', then 5 will be chosen.\n\t     */\n\t    if (pj_stricmp(&attr->setting.enc_fmtp.param[i].name, \n\t\t\t   &STR_FMTP_MODE_SET) == 0)\n\t    {\n\t\tconst char *p;\n\t\tpj_size_t l;\n\t\tpj_int8_t diff = 99;\n\t\t\n\t\tp = pj_strbuf(&attr->setting.enc_fmtp.param[i].val);\n\t\tl = pj_strlen(&attr->setting.enc_fmtp.param[i].val);\n\n\t\twhile (l--) {\n\t\t    if ((desc->pt==PJMEDIA_RTP_PT_AMR && *p>='0' && *p<='7') ||\n\t\t        (desc->pt==PJMEDIA_RTP_PT_AMRWB && *p>='0' && *p<='8'))\n\t\t    {\n\t\t\tpj_int8_t tmp = (pj_int8_t)(*p - '0' - enc_mode);\n\n\t\t\tif (PJ_ABS(diff) > PJ_ABS(tmp) || \n\t\t\t    (PJ_ABS(diff) == PJ_ABS(tmp) && tmp > diff))\n\t\t\t{\n\t\t\t    diff = tmp;\n\t\t\t    if (diff == 0) break;\n\t\t\t}\n\t\t    }\n\t\t    ++p;\n\t\t}\n\n\t\tif (diff == 99)\n\t\t    return PJMEDIA_CODEC_EFAILED;\n\n\t\tenc_mode = (pj_int8_t)(enc_mode + diff);\n\n\t\tbreak;\n\t    }\n\t}\n\n\ts = PJ_POOL_ZALLOC_T(pool, amr_settings_t);\n\tcodec_data->codec_setting = s;\n\n\ts->enc_mode = enc_mode;\n\tif (s->enc_mode < 0)\n\t    return PJMEDIA_CODEC_EINMODE;\n\n\ts->enc_setting.amr_nb = (pj_uint8_t)(desc->pt == PJMEDIA_RTP_PT_AMR);\n\ts->enc_setting.octet_aligned = octet_align;\n\ts->enc_setting.reorder = PJ_FALSE; /* Note this! passthrough codec\n\t\t\t\t\t      doesn't do sensitivity bits \n\t\t\t\t\t      reordering */\n\ts->enc_setting.cmr = 15;\n\t\n\ts->dec_setting.amr_nb = (pj_uint8_t)(desc->pt == PJMEDIA_RTP_PT_AMR);\n\ts->dec_setting.octet_aligned = octet_align;\n\ts->dec_setting.reorder = PJ_FALSE; /* Note this! passthrough codec\n\t\t\t\t\t      doesn't do sensitivity bits \n\t\t\t\t\t      reordering */\n\t\n\t/* Return back bitrate info to application */\n\tattr->info.avg_bps = s->enc_setting.amr_nb?\n\t\t\t     pjmedia_codec_amrnb_bitrates[s->enc_mode]:\n\t\t\t     pjmedia_codec_amrwb_bitrates[s->enc_mode];\n    }\n#endif\n\n#if PJMEDIA_HAS_PASSTHROUGH_CODEC_ILBC\n    /* Init iLBC settings */\n    if (desc->pt == PJMEDIA_RTP_PT_ILBC)\n    {\n\tenum { DEFAULT_MODE = 30 };\n\tstatic pj_str_t STR_MODE = {\"mode\", 4};\n\tpj_uint16_t dec_fmtp_mode = DEFAULT_MODE, \n\t\t    enc_fmtp_mode = DEFAULT_MODE;\n\n\t/* Get decoder mode */\n\tfor (i = 0; i < attr->setting.dec_fmtp.cnt; ++i) {\n\t    if (pj_stricmp(&attr->setting.dec_fmtp.param[i].name, &STR_MODE) == 0)\n\t    {\n\t\tdec_fmtp_mode = (pj_uint16_t)\n\t\t\t\tpj_strtoul(&attr->setting.dec_fmtp.param[i].val);\n\t\tbreak;\n\t    }\n\t}\n\n\t/* Decoder mode must be set */\n\tPJ_ASSERT_RETURN(dec_fmtp_mode == 20 || dec_fmtp_mode == 30, \n\t\t\t PJMEDIA_CODEC_EINMODE);\n\n\t/* Get encoder mode */\n\tfor (i = 0; i < attr->setting.enc_fmtp.cnt; ++i) {\n\t    if (pj_stricmp(&attr->setting.enc_fmtp.param[i].name, &STR_MODE) == 0)\n\t    {\n\t\tenc_fmtp_mode = (pj_uint16_t)\n\t\t\t\tpj_strtoul(&attr->setting.enc_fmtp.param[i].val);\n\t\tbreak;\n\t    }\n\t}\n\n\tPJ_ASSERT_RETURN(enc_fmtp_mode==20 || enc_fmtp_mode==30, \n\t\t\t PJMEDIA_CODEC_EINMODE);\n\n\t/* Both sides of a bi-directional session MUST use the same \"mode\" value.\n\t * In this point, possible values are only 20 or 30, so when encoder and\n\t * decoder modes are not same, just use the default mode, it is 30.\n\t */\n\tif (enc_fmtp_mode != dec_fmtp_mode) {\n\t    enc_fmtp_mode = dec_fmtp_mode = DEFAULT_MODE;\n\t    PJ_LOG(4,(pool->obj_name, \n\t\t      \"Normalized iLBC encoder and decoder modes to %d\", \n\t\t      DEFAULT_MODE));\n\t}\n\n\t/* Update some attributes based on negotiated mode. */\n\tattr->info.avg_bps = (dec_fmtp_mode == 30? 13333 : 15200);\n\tattr->info.frm_ptime = dec_fmtp_mode;\n\n\t/* Override average frame size */\n\tcodec_data->avg_frame_size = (dec_fmtp_mode == 30? 50 : 38);\n\n\t/* Override samples per frame */\n\tcodec_data->samples_per_frame = (dec_fmtp_mode == 30? 240 : 160);\n    }\n#endif\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Close codec.\n */\nstatic pj_status_t codec_close( pjmedia_codec *codec )\n{\n    PJ_UNUSED_ARG(codec);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Modify codec settings.\n */\nstatic pj_status_t codec_modify( pjmedia_codec *codec, \n\t\t\t\t const pjmedia_codec_param *attr )\n{\n    /* Not supported yet. */\n    PJ_UNUSED_ARG(codec);\n    PJ_UNUSED_ARG(attr);\n\n    return PJ_ENOTSUP;\n}\n\n/*\n * Get frames in the packet.\n */\nstatic pj_status_t codec_parse( pjmedia_codec *codec,\n\t\t\t\tvoid *pkt,\n\t\t\t\tpj_size_t pkt_size,\n\t\t\t\tconst pj_timestamp *ts,\n\t\t\t\tunsigned *frame_cnt,\n\t\t\t\tpjmedia_frame frames[])\n{\n    codec_private_t *codec_data = (codec_private_t*) codec->codec_data;\n    struct codec_desc *desc = &codec_desc[codec_data->codec_idx];\n    unsigned count = 0;\n\n    PJ_ASSERT_RETURN(frame_cnt, PJ_EINVAL);\n\n    if (desc->parse != NULL) {\n\treturn desc->parse(codec_data, pkt,  pkt_size, ts, frame_cnt, frames);\n    }\n\n    while (pkt_size >= codec_data->avg_frame_size && count < *frame_cnt) {\n\tframes[count].type = PJMEDIA_FRAME_TYPE_AUDIO;\n\tframes[count].buf = pkt;\n\tframes[count].size = codec_data->avg_frame_size;\n\tframes[count].timestamp.u64 = ts->u64 + \n\t\t\t\t      count * codec_data->samples_per_frame;\n\n\tpkt = (pj_uint8_t*)pkt + codec_data->avg_frame_size;\n\tpkt_size -= codec_data->avg_frame_size;\n\n\t++count;\n    }\n\n    if (pkt_size && count < *frame_cnt) {\n\tframes[count].type = PJMEDIA_FRAME_TYPE_AUDIO;\n\tframes[count].buf = pkt;\n\tframes[count].size = pkt_size;\n\tframes[count].timestamp.u64 = ts->u64 + \n\t\t\t\t       count * codec_data->samples_per_frame;\n\t++count;\n    }\n\n    *frame_cnt = count;\n    return PJ_SUCCESS;\n}\n\n/*\n * Encode frames.\n */\nstatic pj_status_t codec_encode( pjmedia_codec *codec, \n\t\t\t\t const struct pjmedia_frame *input,\n\t\t\t\t unsigned output_buf_len, \n\t\t\t\t struct pjmedia_frame *output)\n{\n    codec_private_t *codec_data = (codec_private_t*) codec->codec_data;\n    struct codec_desc *desc = &codec_desc[codec_data->codec_idx];\n    const pjmedia_frame_ext *input_ = (const pjmedia_frame_ext*) input;\n\n    pj_assert(input && input->type == PJMEDIA_FRAME_TYPE_EXTENDED);\n\n    if (desc->pack != NULL) {\n\tdesc->pack(codec_data, input_, output_buf_len, output);\n    } else {\n\tif (input_->subframe_cnt == 0) {\n\t    /* DTX */\n\t    output->buf = NULL;\n\t    output->size = 0;\n\t    output->type = PJMEDIA_FRAME_TYPE_NONE;\n\t} else {\n\t    unsigned i;\n\t    pj_uint8_t *p = output->buf;\n\n\t    output->type = PJMEDIA_FRAME_TYPE_AUDIO;\n\t    output->size = 0;\n\t    \n\t    for (i = 0; i < input_->subframe_cnt; ++i) {\n\t\tpjmedia_frame_ext_subframe *sf;\n\t\tunsigned sf_len;\n\n\t\tsf = pjmedia_frame_ext_get_subframe(input_, i);\n\t\tpj_assert(sf);\n\n\t\tsf_len = (sf->bitlen + 7) >> 3;\n\n\t\tpj_memcpy(p, sf->data, sf_len);\n\t\tp += sf_len;\n\t\toutput->size += sf_len;\n\n\t\t/* If there is SID or DTX frame, break the loop. */\n\t\tif (desc->pt == PJMEDIA_RTP_PT_G729 && \n\t\t    sf_len < codec_data->avg_frame_size)\n\t\t{\n\t\t    break;\n\t\t}\n\t\t\n\t    }\n\t}\n    }\n\n    output->timestamp = input->timestamp;\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Decode frame.\n */\nstatic pj_status_t codec_decode( pjmedia_codec *codec, \n\t\t\t\t const struct pjmedia_frame *input,\n\t\t\t\t unsigned output_buf_len, \n\t\t\t\t struct pjmedia_frame *output)\n{\n    codec_private_t *codec_data = (codec_private_t*) codec->codec_data;\n#if PJMEDIA_HAS_PASSTHROUGH_CODEC_AMR\n    struct codec_desc *desc = &codec_desc[codec_data->codec_idx];\n#endif\n    pjmedia_frame_ext *output_ = (pjmedia_frame_ext*) output;\n\n    pj_assert(input);\n    PJ_UNUSED_ARG(output_buf_len);\n\n#if PJMEDIA_HAS_PASSTHROUGH_CODEC_AMR\n    /* Need to rearrange the AMR bitstream, since the bitstream may not be \n     * started from bit 0 or may need to be reordered from sensitivity order \n     * into encoder bits order.\n     */\n    if (desc->pt == PJMEDIA_RTP_PT_AMR || desc->pt == PJMEDIA_RTP_PT_AMRWB) {\n\tpjmedia_frame input_;\n\tpjmedia_codec_amr_pack_setting *setting;\n\n\tsetting = &((amr_settings_t*)codec_data->codec_setting)->dec_setting;\n\n\tinput_ = *input;\n\tpjmedia_codec_amr_predecode(input, setting, &input_);\n\t\n\tpjmedia_frame_ext_append_subframe(output_, input_.buf, \n\t\t\t\t\t  (pj_uint16_t)(input_.size << 3),\n\t\t\t\t\t  (pj_uint16_t)codec_data->samples_per_frame);\n\toutput->timestamp = input->timestamp;\n\t\n\treturn PJ_SUCCESS;\n    }\n#endif\n    \n    pjmedia_frame_ext_append_subframe(output_, input->buf, \n\t\t\t\t      (pj_uint16_t)(input->size << 3),\n\t\t\t\t      (pj_uint16_t)codec_data->samples_per_frame);\n    output->timestamp = input->timestamp;\n\n    return PJ_SUCCESS;\n}\n\n/* \n * Recover lost frame.\n */\nstatic pj_status_t codec_recover( pjmedia_codec *codec, \n\t\t\t\t  unsigned output_buf_len, \n\t\t\t\t  struct pjmedia_frame *output)\n{\n    codec_private_t *codec_data = (codec_private_t*) codec->codec_data;\n    pjmedia_frame_ext *output_ = (pjmedia_frame_ext*) output;\n\n    PJ_UNUSED_ARG(output_buf_len);\n\n    pjmedia_frame_ext_append_subframe(output_, NULL, 0,\n\t\t\t\t      (pj_uint16_t)codec_data->samples_per_frame);\n\n    return PJ_SUCCESS;\n}\n\n#endif\t/* PJMEDIA_HAS_PASSTHROUGH_CODECS */\n\n", "/* $Id$ */\n/* \n * Copyright (C) 2008-2011 Teluu Inc. (http://www.teluu.com)\n * Copyright (C) 2003-2008 Benny Prijono <benny@prijono.org>\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n\n#include <pjmedia-codec/speex.h>\n#include <pjmedia/codec.h>\n#include <pjmedia/errno.h>\n#include <pjmedia/endpoint.h>\n#include <pjmedia/port.h>\n#include <speex/speex.h>\n#include <pj/assert.h>\n#include <pj/log.h>\n#include <pj/pool.h>\n#include <pj/string.h>\n#include <pj/os.h>\n\n/*\n * Only build this file if PJMEDIA_HAS_SPEEX_CODEC != 0\n */\n#if defined(PJMEDIA_HAS_SPEEX_CODEC) && PJMEDIA_HAS_SPEEX_CODEC!=0\n\n\n#define THIS_FILE   \"speex_codec.c\"\n\n/* Prototypes for Speex factory */\nstatic pj_status_t spx_test_alloc( pjmedia_codec_factory *factory, \n\t\t\t\t   const pjmedia_codec_info *id );\nstatic pj_status_t spx_default_attr( pjmedia_codec_factory *factory, \n\t\t\t\t     const pjmedia_codec_info *id, \n\t\t\t\t     pjmedia_codec_param *attr );\nstatic pj_status_t spx_enum_codecs( pjmedia_codec_factory *factory, \n\t\t\t\t    unsigned *count, \n\t\t\t\t    pjmedia_codec_info codecs[]);\nstatic pj_status_t spx_alloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t    const pjmedia_codec_info *id, \n\t\t\t\t    pjmedia_codec **p_codec);\nstatic pj_status_t spx_dealloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t      pjmedia_codec *codec );\n\n/* Prototypes for Speex implementation. */\nstatic pj_status_t  spx_codec_init( pjmedia_codec *codec, \n\t\t\t\t    pj_pool_t *pool );\nstatic pj_status_t  spx_codec_open( pjmedia_codec *codec, \n\t\t\t\t    pjmedia_codec_param *attr );\nstatic pj_status_t  spx_codec_close( pjmedia_codec *codec );\nstatic pj_status_t  spx_codec_modify(pjmedia_codec *codec, \n\t\t\t\t     const pjmedia_codec_param *attr );\nstatic pj_status_t  spx_codec_parse( pjmedia_codec *codec,\n\t\t\t\t     void *pkt,\n\t\t\t\t     pj_size_t pkt_size,\n\t\t\t\t     const pj_timestamp *ts,\n\t\t\t\t     unsigned *frame_cnt,\n\t\t\t\t     pjmedia_frame frames[]);\nstatic pj_status_t  spx_codec_encode( pjmedia_codec *codec, \n\t\t\t\t      const struct pjmedia_frame *input,\n\t\t\t\t      unsigned output_buf_len, \n\t\t\t\t      struct pjmedia_frame *output);\nstatic pj_status_t  spx_codec_decode( pjmedia_codec *codec, \n\t\t\t\t      const struct pjmedia_frame *input,\n\t\t\t\t      unsigned output_buf_len, \n\t\t\t\t      struct pjmedia_frame *output);\nstatic pj_status_t  spx_codec_recover(pjmedia_codec *codec, \n\t\t\t\t      unsigned output_buf_len, \n\t\t\t\t      struct pjmedia_frame *output);\n\n/* Definition for Speex codec operations. */\nstatic pjmedia_codec_op spx_op = \n{\n    &spx_codec_init,\n    &spx_codec_open,\n    &spx_codec_close,\n    &spx_codec_modify,\n    &spx_codec_parse,\n    &spx_codec_encode,\n    &spx_codec_decode,\n    &spx_codec_recover\n};\n\n/* Definition for Speex codec factory operations. */\nstatic pjmedia_codec_factory_op spx_factory_op =\n{\n    &spx_test_alloc,\n    &spx_default_attr,\n    &spx_enum_codecs,\n    &spx_alloc_codec,\n    &spx_dealloc_codec,\n    &pjmedia_codec_speex_deinit\n};\n\n/* Index to Speex parameter. */\nenum\n{\n    PARAM_NB,\t/* Index for narrowband parameter.\t*/\n    PARAM_WB,\t/* Index for wideband parameter.\t*/\n    PARAM_UWB,\t/* Index for ultra-wideband parameter\t*/\n};\n\n/* Speex default parameter */\nstruct speex_param\n{\n    int\t\t     enabled;\t\t/* Is this mode enabled?\t    */\n    const SpeexMode *mode;\t\t/* Speex mode.\t\t\t    */\n    int\t\t     pt;\t\t/* Payload type.\t\t    */\n    unsigned\t     clock_rate;\t/* Default sampling rate to be used.*/\n    int\t\t     quality;\t\t/* Default encoder quality.\t    */\n    int\t\t     complexity;\t/* Default encoder complexity.\t    */\n    int\t\t     samples_per_frame;\t/* Samples per frame.\t\t    */\n    int\t\t     framesize;\t\t/* Frame size for current mode.\t    */\n    int\t\t     bitrate;\t\t/* Bit rate for current mode.\t    */\n    int\t\t     max_bitrate;\t/* Max bit rate for current mode.   */\n};\n\n/* Speex factory */\nstatic struct spx_factory\n{\n    pjmedia_codec_factory    base;\n    pjmedia_endpt\t    *endpt;\n    pj_pool_t\t\t    *pool;\n    pj_mutex_t\t\t    *mutex;\n    pjmedia_codec\t     codec_list;\n    struct speex_param\t     speex_param[3];\n\n} spx_factory;\n\n/* Speex codec private data. */\nstruct spx_private\n{\n    int\t\t\t param_id;\t    /**< Index to speex param.\t*/\n\n    void\t\t*enc;\t\t    /**< Encoder state.\t\t*/\n    SpeexBits\t\t enc_bits;\t    /**< Encoder bits.\t\t*/\n    void\t\t*dec;\t\t    /**< Decoder state.\t\t*/\n    SpeexBits\t\t dec_bits;\t    /**< Decoder bits.\t\t*/\n};\n\n\n/*\n * Get codec bitrate and frame size.\n */\nstatic pj_status_t get_speex_info( struct speex_param *p )\n{\n    void *state;\n    int tmp;\n\n    /* Create temporary encoder */\n    state = speex_encoder_init(p->mode);\n    if (!state)\n\treturn PJMEDIA_CODEC_EFAILED;\n\n    /* Set the quality */\n    if (p->quality != -1)\n\tspeex_encoder_ctl(state, SPEEX_SET_QUALITY, &p->quality);\n\n    /* Sampling rate. */\n    speex_encoder_ctl(state, SPEEX_SET_SAMPLING_RATE, &p->clock_rate);\n\n    /* VAD off to have max bitrate */\n    tmp = 0;\n    speex_encoder_ctl(state, SPEEX_SET_VAD, &tmp);\n\n    /* Complexity. */\n    if (p->complexity != -1)\n\tspeex_encoder_ctl(state, SPEEX_SET_COMPLEXITY, &p->complexity);\n\n    /* Now get the frame size */\n    speex_encoder_ctl(state, SPEEX_GET_FRAME_SIZE, &p->samples_per_frame);\n\n    /* Now get the average bitrate */\n    speex_encoder_ctl(state, SPEEX_GET_BITRATE, &p->bitrate);\n\n    /* Calculate framesize. */\n    p->framesize = p->bitrate * 20 / 1000;\n\n    /* Now get the maximum bitrate by using maximum quality (=10) */\n    tmp = 10;\n    speex_encoder_ctl(state, SPEEX_SET_QUALITY, &tmp);\n    speex_encoder_ctl(state, SPEEX_GET_BITRATE, &p->max_bitrate);\n\n    /* Destroy encoder. */\n    speex_encoder_destroy(state);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Initialize and register Speex codec factory to pjmedia endpoint.\n */\nPJ_DEF(pj_status_t) pjmedia_codec_speex_init( pjmedia_endpt *endpt,\n\t\t\t\t\t      unsigned options,\n\t\t\t\t\t      int quality,\n\t\t\t\t\t      int complexity )\n{\n    pjmedia_codec_mgr *codec_mgr;\n    unsigned i;\n    pj_status_t status;\n\n    if (spx_factory.pool != NULL) {\n\t/* Already initialized. */\n\treturn PJ_SUCCESS;\n    }\n\n    /* Get defaults */\n    if (quality < 0) quality = PJMEDIA_CODEC_SPEEX_DEFAULT_QUALITY;\n    if (complexity < 0) complexity = PJMEDIA_CODEC_SPEEX_DEFAULT_COMPLEXITY;\n\n    /* Validate quality & complexity */\n    PJ_ASSERT_RETURN(quality >= 0 && quality <= 10, PJ_EINVAL);\n    PJ_ASSERT_RETURN(complexity >= 1 && complexity <= 10, PJ_EINVAL);\n\n    /* Create Speex codec factory. */\n    spx_factory.base.op = &spx_factory_op;\n    spx_factory.base.factory_data = NULL;\n    spx_factory.endpt = endpt;\n\n    spx_factory.pool = pjmedia_endpt_create_pool(endpt, \"speex\", \n\t\t\t\t\t\t       4000, 4000);\n    if (!spx_factory.pool)\n\treturn PJ_ENOMEM;\n\n    pj_list_init(&spx_factory.codec_list);\n\n    /* Create mutex. */\n    status = pj_mutex_create_simple(spx_factory.pool, \"speex\", \n\t\t\t\t    &spx_factory.mutex);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Initialize default Speex parameter. */\n    spx_factory.speex_param[PARAM_NB].enabled = \n\t((options & PJMEDIA_SPEEX_NO_NB) == 0);\n    spx_factory.speex_param[PARAM_NB].pt = PJMEDIA_RTP_PT_SPEEX_NB;\n    spx_factory.speex_param[PARAM_NB].mode = speex_lib_get_mode(SPEEX_MODEID_NB);\n    spx_factory.speex_param[PARAM_NB].clock_rate = 8000;\n    spx_factory.speex_param[PARAM_NB].quality = quality;\n    spx_factory.speex_param[PARAM_NB].complexity = complexity;\n\n    spx_factory.speex_param[PARAM_WB].enabled = \n\t((options & PJMEDIA_SPEEX_NO_WB) == 0);\n    spx_factory.speex_param[PARAM_WB].pt = PJMEDIA_RTP_PT_SPEEX_WB;\n    spx_factory.speex_param[PARAM_WB].mode = speex_lib_get_mode(SPEEX_MODEID_WB);\n    spx_factory.speex_param[PARAM_WB].clock_rate = 16000;\n    spx_factory.speex_param[PARAM_WB].quality = quality;\n    spx_factory.speex_param[PARAM_WB].complexity = complexity;\n\n    spx_factory.speex_param[PARAM_UWB].enabled = \n\t((options & PJMEDIA_SPEEX_NO_UWB) == 0);\n    spx_factory.speex_param[PARAM_UWB].pt = PJMEDIA_RTP_PT_SPEEX_UWB;\n    spx_factory.speex_param[PARAM_UWB].mode = speex_lib_get_mode(SPEEX_MODEID_UWB);\n    spx_factory.speex_param[PARAM_UWB].clock_rate = 32000;\n    spx_factory.speex_param[PARAM_UWB].quality = quality;\n    spx_factory.speex_param[PARAM_UWB].complexity = complexity;\n\n    /* Somehow quality <=4 is broken in linux. */\n    if (quality <= 4 && quality >= 0) {\n\tPJ_LOG(5,(THIS_FILE, \"Adjusting quality to 5 for uwb\"));\n\tspx_factory.speex_param[PARAM_UWB].quality = 5;\n    }\n\n    /* Get codec framesize and avg bitrate for each mode. */\n    for (i=0; i<PJ_ARRAY_SIZE(spx_factory.speex_param); ++i) {\n\tstatus = get_speex_info(&spx_factory.speex_param[i]);\n    }\n\n    /* Get the codec manager. */\n    codec_mgr = pjmedia_endpt_get_codec_mgr(endpt);\n    if (!codec_mgr) {\n\tstatus = PJ_EINVALIDOP;\n\tgoto on_error;\n    }\n\n    /* Register codec factory to endpoint. */\n    status = pjmedia_codec_mgr_register_factory(codec_mgr, \n\t\t\t\t\t\t&spx_factory.base);\n    if (status != PJ_SUCCESS)\n\tgoto on_error;\n\n    /* Done. */\n    return PJ_SUCCESS;\n\non_error:\n    pj_pool_release(spx_factory.pool);\n    spx_factory.pool = NULL;\n    return status;\n}\n\n\n/*\n * Initialize with default settings.\n */\nPJ_DEF(pj_status_t) pjmedia_codec_speex_init_default(pjmedia_endpt *endpt)\n{\n    return pjmedia_codec_speex_init(endpt, 0, -1, -1);\n}\n\n/*\n * Change the settings of Speex codec.\n */\nPJ_DEF(pj_status_t) pjmedia_codec_speex_set_param(unsigned clock_rate,\n\t\t\t\t\t\t  int quality,\n\t\t\t\t\t\t  int complexity)\n{\n    unsigned i;\n\n    /* Get defaults */\n    if (quality < 0) quality = PJMEDIA_CODEC_SPEEX_DEFAULT_QUALITY;\n    if (complexity < 0) complexity = PJMEDIA_CODEC_SPEEX_DEFAULT_COMPLEXITY;\n\n    /* Validate quality & complexity */\n    PJ_ASSERT_RETURN(quality >= 0 && quality <= 10, PJ_EINVAL);\n    PJ_ASSERT_RETURN(complexity >= 1 && complexity <= 10, PJ_EINVAL);\n\n    /* Apply the settings */\n    for (i=0; i<PJ_ARRAY_SIZE(spx_factory.speex_param); ++i) {\n\tif (spx_factory.speex_param[i].clock_rate == clock_rate) {\n\t    pj_status_t status;\n\n\t    spx_factory.speex_param[i].quality = quality;\n\t    spx_factory.speex_param[i].complexity = complexity;\n\n\t    /* Somehow quality<=4 is broken in linux. */\n\t    if (i == PARAM_UWB && quality <= 4 && quality >= 0) {\n\t\tPJ_LOG(5,(THIS_FILE, \"Adjusting quality to 5 for uwb\"));\n\t\tspx_factory.speex_param[PARAM_UWB].quality = 5;\n\t    }\n\n\t    status = get_speex_info(&spx_factory.speex_param[i]);\n\n\t    return status;\n\t}\n    }\n\n    return PJ_EINVAL;\n}\n\n/*\n * Unregister Speex codec factory from pjmedia endpoint and deinitialize\n * the Speex codec library.\n */\nPJ_DEF(pj_status_t) pjmedia_codec_speex_deinit(void)\n{\n    pjmedia_codec_mgr *codec_mgr;\n    pj_status_t status;\n\n    if (spx_factory.pool == NULL) {\n\t/* Already deinitialized */\n\treturn PJ_SUCCESS;\n    }\n\n    pj_mutex_lock(spx_factory.mutex);\n\n    /* We don't want to deinit if there's outstanding codec. */\n    /* This is silly, as we'll always have codec in the list if\n       we ever allocate a codec! A better behavior maybe is to \n       deallocate all codecs in the list.\n    if (!pj_list_empty(&spx_factory.codec_list)) {\n\tpj_mutex_unlock(spx_factory.mutex);\n\treturn PJ_EBUSY;\n    }\n    */\n\n    /* Get the codec manager. */\n    codec_mgr = pjmedia_endpt_get_codec_mgr(spx_factory.endpt);\n    if (!codec_mgr) {\n\tpj_pool_release(spx_factory.pool);\n\tspx_factory.pool = NULL;\n\tpj_mutex_unlock(spx_factory.mutex);\n\treturn PJ_EINVALIDOP;\n    }\n\n    /* Unregister Speex codec factory. */\n    status = pjmedia_codec_mgr_unregister_factory(codec_mgr,\n\t\t\t\t\t\t  &spx_factory.base);\n    \n    /* Destroy mutex. */\n    pj_mutex_unlock(spx_factory.mutex);\n    pj_mutex_destroy(spx_factory.mutex);\n    spx_factory.mutex = NULL;\n\n    /* Destroy pool. */\n    pj_pool_release(spx_factory.pool);\n    spx_factory.pool = NULL;\n\n    return status;\n}\n\n/* \n * Check if factory can allocate the specified codec. \n */\nstatic pj_status_t spx_test_alloc( pjmedia_codec_factory *factory, \n\t\t\t\t   const pjmedia_codec_info *info )\n{\n    const pj_str_t speex_tag = { \"speex\", 5};\n    unsigned i;\n\n    PJ_UNUSED_ARG(factory);\n\n    /* Type MUST be audio. */\n    if (info->type != PJMEDIA_TYPE_AUDIO)\n\treturn PJMEDIA_CODEC_EUNSUP;\n\n    /* Check encoding name. */\n    if (pj_stricmp(&info->encoding_name, &speex_tag) != 0)\n\treturn PJMEDIA_CODEC_EUNSUP;\n\n    /* Check clock-rate */\n    for (i=0; i<PJ_ARRAY_SIZE(spx_factory.speex_param); ++i) {\n\tif (info->clock_rate == spx_factory.speex_param[i].clock_rate) {\n\t    /* Okay, let's Speex! */\n\t    return PJ_SUCCESS;\n\t}\n    }\n\n    \n    /* Unsupported, or mode is disabled. */\n    return PJMEDIA_CODEC_EUNSUP;\n}\n\n/*\n * Generate default attribute.\n */\nstatic pj_status_t spx_default_attr (pjmedia_codec_factory *factory, \n\t\t\t\t      const pjmedia_codec_info *id, \n\t\t\t\t      pjmedia_codec_param *attr )\n{\n\n    PJ_ASSERT_RETURN(factory==&spx_factory.base, PJ_EINVAL);\n\n    pj_bzero(attr, sizeof(pjmedia_codec_param));\n    attr->info.pt = (pj_uint8_t)id->pt;\n    attr->info.channel_cnt = 1;\n\n    if (id->clock_rate <= 8000) {\n\tattr->info.clock_rate = spx_factory.speex_param[PARAM_NB].clock_rate;\n\tattr->info.avg_bps = spx_factory.speex_param[PARAM_NB].bitrate;\n\tattr->info.max_bps = spx_factory.speex_param[PARAM_NB].max_bitrate;\n\n    } else if (id->clock_rate <= 16000) {\n\tattr->info.clock_rate = spx_factory.speex_param[PARAM_WB].clock_rate;\n\tattr->info.avg_bps = spx_factory.speex_param[PARAM_WB].bitrate;\n\tattr->info.max_bps = spx_factory.speex_param[PARAM_WB].max_bitrate;\n\n    } else {\n\t/* Wow.. somebody is doing ultra-wideband. Cool...! */\n\tattr->info.clock_rate = spx_factory.speex_param[PARAM_UWB].clock_rate;\n\tattr->info.avg_bps = spx_factory.speex_param[PARAM_UWB].bitrate;\n\tattr->info.max_bps = spx_factory.speex_param[PARAM_UWB].max_bitrate;\n    }\n\n    attr->info.pcm_bits_per_sample = 16;\n    attr->info.frm_ptime = 20;\n    attr->info.pt = (pj_uint8_t)id->pt;\n\n    attr->setting.frm_per_pkt = 1;\n\n    /* Default flags. */\n    attr->setting.cng = 1;\n    attr->setting.plc = 1;\n    attr->setting.penh =1 ;\n    attr->setting.vad = 1;\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Enum codecs supported by this factory (i.e. only Speex!).\n */\nstatic pj_status_t spx_enum_codecs(pjmedia_codec_factory *factory, \n\t\t\t\t    unsigned *count, \n\t\t\t\t    pjmedia_codec_info codecs[])\n{\n    unsigned max;\n    int i;  /* Must be signed */\n\n    PJ_UNUSED_ARG(factory);\n    PJ_ASSERT_RETURN(codecs && *count > 0, PJ_EINVAL);\n\n    max = *count;\n    *count = 0;\n\n    /*\n     * We return three codecs here, and in this order:\n     *\t- ultra-wideband, wideband, and narrowband.\n     */\n    for (i=PJ_ARRAY_SIZE(spx_factory.speex_param)-1; i>=0 && *count<max; --i) {\n\n\tif (!spx_factory.speex_param[i].enabled)\n\t    continue;\n\n\tpj_bzero(&codecs[*count], sizeof(pjmedia_codec_info));\n\tcodecs[*count].encoding_name = pj_str(\"speex\");\n\tcodecs[*count].pt = spx_factory.speex_param[i].pt;\n\tcodecs[*count].type = PJMEDIA_TYPE_AUDIO;\n\tcodecs[*count].clock_rate = spx_factory.speex_param[i].clock_rate;\n\tcodecs[*count].channel_cnt = 1;\n\n\t++*count;\n    }\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Allocate a new Speex codec instance.\n */\nstatic pj_status_t spx_alloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t    const pjmedia_codec_info *id,\n\t\t\t\t    pjmedia_codec **p_codec)\n{\n    pjmedia_codec *codec;\n    struct spx_private *spx;\n\n    PJ_ASSERT_RETURN(factory && id && p_codec, PJ_EINVAL);\n    PJ_ASSERT_RETURN(factory == &spx_factory.base, PJ_EINVAL);\n\n\n    pj_mutex_lock(spx_factory.mutex);\n\n    /* Get free nodes, if any. */\n    if (!pj_list_empty(&spx_factory.codec_list)) {\n\tcodec = spx_factory.codec_list.next;\n\tpj_list_erase(codec);\n    } else {\n\tcodec = PJ_POOL_ZALLOC_T(spx_factory.pool, pjmedia_codec);\n\tPJ_ASSERT_RETURN(codec != NULL, PJ_ENOMEM);\n\tcodec->op = &spx_op;\n\tcodec->factory = factory;\n\tcodec->codec_data = pj_pool_alloc(spx_factory.pool,\n\t\t\t\t\t  sizeof(struct spx_private));\n    }\n\n    pj_mutex_unlock(spx_factory.mutex);\n\n    spx = (struct spx_private*) codec->codec_data;\n    spx->enc = NULL;\n    spx->dec = NULL;\n\n    if (id->clock_rate <= 8000)\n\tspx->param_id = PARAM_NB;\n    else if (id->clock_rate <= 16000)\n\tspx->param_id = PARAM_WB;\n    else\n\tspx->param_id = PARAM_UWB;\n\n    *p_codec = codec;\n    return PJ_SUCCESS;\n}\n\n/*\n * Free codec.\n */\nstatic pj_status_t spx_dealloc_codec( pjmedia_codec_factory *factory, \n\t\t\t\t      pjmedia_codec *codec )\n{\n    struct spx_private *spx;\n\n    PJ_ASSERT_RETURN(factory && codec, PJ_EINVAL);\n    PJ_ASSERT_RETURN(factory == &spx_factory.base, PJ_EINVAL);\n\n    /* Close codec, if it's not closed. */\n    spx = (struct spx_private*) codec->codec_data;\n    if (spx->enc != NULL || spx->dec != NULL) {\n\tspx_codec_close(codec);\n    }\n\n    /* Put in the free list. */\n    pj_mutex_lock(spx_factory.mutex);\n    pj_list_push_front(&spx_factory.codec_list, codec);\n    pj_mutex_unlock(spx_factory.mutex);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Init codec.\n */\nstatic pj_status_t spx_codec_init( pjmedia_codec *codec, \n\t\t\t\t   pj_pool_t *pool )\n{\n    PJ_UNUSED_ARG(codec);\n    PJ_UNUSED_ARG(pool);\n    return PJ_SUCCESS;\n}\n\n/*\n * Open codec.\n */\nstatic pj_status_t spx_codec_open( pjmedia_codec *codec, \n\t\t\t\t   pjmedia_codec_param *attr )\n{\n    struct spx_private *spx;\n    int id, tmp;\n\n    spx = (struct spx_private*) codec->codec_data;\n    id = spx->param_id;\n\n    /* \n     * Create and initialize encoder. \n     */\n    spx->enc = speex_encoder_init(spx_factory.speex_param[id].mode);\n    if (!spx->enc)\n\treturn PJMEDIA_CODEC_EFAILED;\n    speex_bits_init(&spx->enc_bits);\n\n    /* Set the quality*/\n    if (spx_factory.speex_param[id].quality != -1) {\n\tspeex_encoder_ctl(spx->enc, SPEEX_SET_QUALITY, \n\t\t\t  &spx_factory.speex_param[id].quality);\n    }\n\n    /* Sampling rate. */\n    tmp = attr->info.clock_rate;\n    speex_encoder_ctl(spx->enc, SPEEX_SET_SAMPLING_RATE, \n\t\t      &spx_factory.speex_param[id].clock_rate);\n\n    /* VAD */\n    tmp = (attr->setting.vad != 0);\n    speex_encoder_ctl(spx->enc, SPEEX_SET_VAD, &tmp);\n    speex_encoder_ctl(spx->enc, SPEEX_SET_DTX, &tmp);\n\n    /* Complexity */\n    if (spx_factory.speex_param[id].complexity != -1) {\n\tspeex_encoder_ctl(spx->enc, SPEEX_SET_COMPLEXITY, \n\t\t\t  &spx_factory.speex_param[id].complexity);\n    }\n\n    /* \n     * Create and initialize decoder. \n     */\n    spx->dec = speex_decoder_init(spx_factory.speex_param[id].mode);\n    if (!spx->dec) {\n\tspx_codec_close(codec);\n\treturn PJMEDIA_CODEC_EFAILED;\n    }\n    speex_bits_init(&spx->dec_bits);\n\n    /* Sampling rate. */\n    speex_decoder_ctl(spx->dec, SPEEX_SET_SAMPLING_RATE, \n\t\t      &spx_factory.speex_param[id].clock_rate);\n\n    /* PENH */\n    tmp = attr->setting.penh;\n    speex_decoder_ctl(spx->dec, SPEEX_SET_ENH, &tmp);\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Close codec.\n */\nstatic pj_status_t spx_codec_close( pjmedia_codec *codec )\n{\n    struct spx_private *spx;\n\n    spx = (struct spx_private*) codec->codec_data;\n\n    /* Destroy encoder*/\n    if (spx->enc) {\n\tspeex_encoder_destroy( spx->enc );\n\tspx->enc = NULL;\n\tspeex_bits_destroy( &spx->enc_bits );\n    }\n\n    /* Destroy decoder */\n    if (spx->dec) {\n\tspeex_decoder_destroy( spx->dec);\n\tspx->dec = NULL;\n\tspeex_bits_destroy( &spx->dec_bits );\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Modify codec settings.\n */\nstatic pj_status_t  spx_codec_modify(pjmedia_codec *codec, \n\t\t\t\t     const pjmedia_codec_param *attr )\n{\n    struct spx_private *spx;\n    int tmp;\n\n    spx = (struct spx_private*) codec->codec_data;\n\n    /* VAD */\n    tmp = (attr->setting.vad != 0);\n    speex_encoder_ctl(spx->enc, SPEEX_SET_VAD, &tmp);\n    speex_encoder_ctl(spx->enc, SPEEX_SET_DTX, &tmp);\n\n    /* PENH */\n    tmp = attr->setting.penh;\n    speex_decoder_ctl(spx->dec, SPEEX_SET_ENH, &tmp);\n\n    return PJ_SUCCESS;\n}\n\n#if 0\n#  define TRACE__(args)\t    PJ_LOG(5,args)\n#else\n#  define TRACE__(args)\n#endif\n\n#undef THIS_FUNC\n#define THIS_FUNC \"speex_get_next_frame\"\n\n#define NB_SUBMODES 16\n#define NB_SUBMODE_BITS 4\n\n#define SB_SUBMODES 8\n#define SB_SUBMODE_BITS 3\n\n/* This function will iterate frames & submodes in the Speex bits.\n * Returns 0 if a frame found, otherwise returns -1.\n */\nstatic int speex_get_next_frame(SpeexBits *bits)\n{\n    static const int inband_skip_table[NB_SUBMODES] =\n       {1, 1, 4, 4, 4, 4, 4, 4, 8, 8, 16, 16, 32, 32, 64, 64 };\n    static const int wb_skip_table[SB_SUBMODES] =\n       {SB_SUBMODE_BITS+1, 36, 112, 192, 352, -1, -1, -1};\n\n    unsigned submode;\n    unsigned nb_count = 0;\n\n    while (speex_bits_remaining(bits) >= 5) {\n\tunsigned wb_count = 0;\n\tunsigned bit_ptr = bits->bitPtr;\n\tunsigned char_ptr = bits->charPtr;\n\n\t/* WB frame */\n\twhile ((speex_bits_remaining(bits) >= 4)\n\t    && speex_bits_unpack_unsigned(bits, 1))\n\t{\n\t    int advance;\n\n\t    submode = speex_bits_unpack_unsigned(bits, 3);\n\t    advance = wb_skip_table[submode];\n\t    if (advance < 0) {\n\t\tTRACE__((THIS_FUNC, \"Invalid mode encountered. \"\n\t\t\t \"The stream is corrupted.\"));\n\t\treturn -1;\n\t    } \n\t    TRACE__((THIS_FUNC, \"WB layer skipped: %d bits\", advance));\n\t    advance -= (SB_SUBMODE_BITS+1);\n\t    speex_bits_advance(bits, advance);\n\n\t    bit_ptr = bits->bitPtr;\n\t    char_ptr = bits->charPtr;\n\n\t    /* Consecutive subband frames may not exceed 2 frames */\n\t    if (++wb_count > 2)\n\t\treturn -1;\n\t}\n\n\t/* End of bits, return the frame */\n\tif (speex_bits_remaining(bits) < 4) {\n\t    TRACE__((THIS_FUNC, \"End of stream\"));\n\t    return 0;\n\t}\n\n\t/* Stop iteration, return the frame */\n\tif (nb_count > 0) {\n\t    bits->bitPtr = bit_ptr;\n\t    bits->charPtr = char_ptr;\n\t    return 0;\n\t}\n\n\t/* Get control bits */\n\tsubmode = speex_bits_unpack_unsigned(bits, 4);\n\tTRACE__((THIS_FUNC, \"Control bits: %d at %d\", \n\t\t submode, bits->charPtr*8+bits->bitPtr));\n\n\tif (submode == 15) {\n\t    TRACE__((THIS_FUNC, \"Found submode: terminator\"));\n\t    return -1;\n\t} else if (submode == 14) {\n\t    /* in-band signal; next 4 bits contain signal id */\n\t    submode = speex_bits_unpack_unsigned(bits, 4);\n\t    TRACE__((THIS_FUNC, \"Found submode: in-band %d bits\", \n\t\t     inband_skip_table[submode]));\n\t    speex_bits_advance(bits, inband_skip_table[submode]);\n\t} else if (submode == 13) {\n\t    /* user in-band; next 5 bits contain msg len */\n\t    submode = speex_bits_unpack_unsigned(bits, 5);\n\t    TRACE__((THIS_FUNC, \"Found submode: user-band %d bytes\", submode));\n\t    speex_bits_advance(bits, submode * 8);\n\t} else if (submode > 8) {\n\t    TRACE__((THIS_FUNC, \"Unknown sub-mode %d\", submode));\n\t    return -1;\n\t} else {\n\t    /* NB frame */\n\t    int advance = submode;\n\t    speex_mode_query(&speex_nb_mode, SPEEX_SUBMODE_BITS_PER_FRAME, &advance);\n\t    if (advance < 0) {\n\t\tTRACE__((THIS_FUNC, \"Invalid mode encountered. \"\n\t\t\t \"The stream is corrupted.\"));\n\t\treturn -1;\n\t    }\n\t    TRACE__((THIS_FUNC, \"Submode %d: %d bits\", submode, advance));\n\t    advance -= (NB_SUBMODE_BITS+1);\n\t    speex_bits_advance(bits, advance);\n\n\t    ++nb_count;\n\t}\n    }\n\n    return 0;\n}\n\n\n/*\n * Get frames in the packet.\n */\nstatic pj_status_t  spx_codec_parse( pjmedia_codec *codec,\n\t\t\t\t     void *pkt,\n\t\t\t\t     pj_size_t pkt_size,\n\t\t\t\t     const pj_timestamp *ts,\n\t\t\t\t     unsigned *frame_cnt,\n\t\t\t\t     pjmedia_frame frames[])\n{\n    struct spx_private *spx = (struct spx_private*) codec->codec_data;\n    unsigned samples_per_frame;\n    unsigned count = 0;\n    int char_ptr = 0;\n    int bit_ptr = 0;\n\n    samples_per_frame=spx_factory.speex_param[spx->param_id].samples_per_frame;\n\n    /* Copy the data into the speex bit-stream */\n    speex_bits_read_from(&spx->dec_bits, (char*)pkt, (int)pkt_size);\n\n    while (speex_get_next_frame(&spx->dec_bits) == 0 && \n\t   spx->dec_bits.charPtr != char_ptr)\n    {\n\tframes[count].buf = (char*)pkt + char_ptr;\n\t/* Bit info contains start bit offset of the frame */\n\tframes[count].bit_info = bit_ptr;\n\tframes[count].type = PJMEDIA_FRAME_TYPE_AUDIO;\n\tframes[count].timestamp.u64 = ts->u64 +\n\t\t\t\t      (pj_uint64_t)count * samples_per_frame;\n\tframes[count].size = spx->dec_bits.charPtr - char_ptr;\n\tif (spx->dec_bits.bitPtr)\n\t    ++frames[count].size;\n\n\tbit_ptr = spx->dec_bits.bitPtr;\n\tchar_ptr = spx->dec_bits.charPtr;\n\n\t++count;\n    }\n\n    *frame_cnt = count;\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Encode frames.\n */\nstatic pj_status_t spx_codec_encode( pjmedia_codec *codec, \n\t\t\t\t     const struct pjmedia_frame *input,\n\t\t\t\t     unsigned output_buf_len, \n\t\t\t\t     struct pjmedia_frame *output)\n{\n    struct spx_private *spx;\n    unsigned samples_per_frame;\n    int tx = 0;\n    spx_int16_t *pcm_in = (spx_int16_t*)input->buf;\n    pj_size_t nsamples;\n\n    spx = (struct spx_private*) codec->codec_data;\n\n    if (input->type != PJMEDIA_FRAME_TYPE_AUDIO) {\n\toutput->size = 0;\n\toutput->buf = NULL;\n\toutput->timestamp = input->timestamp;\n\toutput->type = input->type;\n\treturn PJ_SUCCESS;\n    }\n\n    nsamples = input->size >> 1;\n    samples_per_frame=spx_factory.speex_param[spx->param_id].samples_per_frame;\n\n    PJ_ASSERT_RETURN(nsamples % samples_per_frame == 0, \n\t\t     PJMEDIA_CODEC_EPCMFRMINLEN);\n\n    /* Flush all the bits in the struct so we can encode a new frame */\n    speex_bits_reset(&spx->enc_bits);\n\n    /* Encode the frames */\n    while (nsamples >= samples_per_frame) {\n\ttx += speex_encode_int(spx->enc, pcm_in, &spx->enc_bits);\n\tpcm_in += samples_per_frame;\n\tnsamples -= samples_per_frame;\n    }\n\n    /* Check if we need not to transmit the frame (DTX) */\n    if (tx == 0) {\n\toutput->buf = NULL;\n\toutput->size = 0;\n\toutput->timestamp.u64 = input->timestamp.u64;\n\toutput->type = PJMEDIA_FRAME_TYPE_NONE;\n\treturn PJ_SUCCESS;\n    }\n\n    /* Check size. */\n    pj_assert(speex_bits_nbytes(&spx->enc_bits) <= (int)output_buf_len);\n\n    /* Copy the bits to an array of char that can be written */\n    output->size = speex_bits_write(&spx->enc_bits, \n\t\t\t\t    (char*)output->buf, output_buf_len);\n    output->type = PJMEDIA_FRAME_TYPE_AUDIO;\n    output->timestamp = input->timestamp;\n\n    return PJ_SUCCESS;\n}\n\n/*\n * Decode frame.\n */\nstatic pj_status_t spx_codec_decode( pjmedia_codec *codec, \n\t\t\t\t     const struct pjmedia_frame *input,\n\t\t\t\t     unsigned output_buf_len, \n\t\t\t\t     struct pjmedia_frame *output)\n{\n    struct spx_private *spx;\n    unsigned samples_per_frame;\n\n    spx = (struct spx_private*) codec->codec_data;\n    samples_per_frame=spx_factory.speex_param[spx->param_id].samples_per_frame;\n\n    PJ_ASSERT_RETURN(output_buf_len >= samples_per_frame << 1,\n\t\t     PJMEDIA_CODEC_EPCMTOOSHORT);\n\n    if (input->type != PJMEDIA_FRAME_TYPE_AUDIO) {\n\tpjmedia_zero_samples((pj_int16_t*)output->buf, samples_per_frame);\n\toutput->size = samples_per_frame << 1;\n\toutput->timestamp.u64 = input->timestamp.u64;\n\toutput->type = PJMEDIA_FRAME_TYPE_AUDIO;\n\treturn PJ_SUCCESS;\n    }\n\n    /* Copy the data into the bit-stream struct */\n    speex_bits_read_from(&spx->dec_bits, (char*)input->buf, (int)input->size);\n    \n    /* Set Speex dec_bits pointer to the start bit of the frame */\n    speex_bits_advance(&spx->dec_bits, input->bit_info);\n\n    /* Decode the data */\n    speex_decode_int(spx->dec, &spx->dec_bits, (spx_int16_t*)output->buf);\n\n    output->type = PJMEDIA_FRAME_TYPE_AUDIO;\n    output->size = samples_per_frame << 1;\n    output->timestamp.u64 = input->timestamp.u64;\n\n    return PJ_SUCCESS;\n}\n\n/* \n * Recover lost frame.\n */\nstatic pj_status_t  spx_codec_recover(pjmedia_codec *codec, \n\t\t\t\t      unsigned output_buf_len, \n\t\t\t\t      struct pjmedia_frame *output)\n{\n    struct spx_private *spx;\n    unsigned count;\n\n    /* output_buf_len is unreferenced when building in Release mode */\n    PJ_UNUSED_ARG(output_buf_len);\n\n    spx = (struct spx_private*) codec->codec_data;\n\n    count = spx_factory.speex_param[spx->param_id].clock_rate * 20 / 1000;\n    pj_assert(count <= output_buf_len/2);\n\n    /* Recover packet loss */\n    speex_decode_int(spx->dec, NULL, (spx_int16_t*) output->buf);\n\n    output->size = count * 2;\n\n    return PJ_SUCCESS;\n}\n\n\n#endif\t/* PJMEDIA_HAS_SPEEX_CODEC */\n", "/* $Id$ */\n/* \n * Copyright (C) 2019 Teluu Inc. (http://www.teluu.com)\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA \n */\n#include <pjmedia/vid_conf.h>\n#include <pjmedia/clock.h>\n#include <pjmedia/converter.h>\n#include <pjmedia/errno.h>\n#include <pj/array.h>\n#include <pj/log.h>\n#include <pj/os.h>\n\n#if defined(PJMEDIA_HAS_VIDEO) && (PJMEDIA_HAS_VIDEO != 0)\n\n\n#define CONF_NAME\t\"vidconf\"\n#define CONF_SIGN\tPJMEDIA_SIG_VID_CONF\n\n/* If set, conf will stop clock when there is no ports connection. However,\n * this may cause stuck if port remove/disconnect is called from the clock\n * callback. So better disable this for now.\n */\n#define AUTO_STOP_CLOCK 0\n\n/* Maximum number of consecutive errors that will only be printed once. */\n#define MAX_ERR_COUNT 150\n\n/* Clockrate for video timestamp unit */\n#define TS_CLOCK_RATE\t90000\n\n#define THIS_FILE\t\"vid_conf.c\"\n#define TRACE_(x)\tPJ_LOG(5,x)\n\n\n/*\n * Conference bridge.\n */\nstruct pjmedia_vid_conf\n{\n    pjmedia_vid_conf_setting opt;\t/**< Settings.\t\t\t    */\n    unsigned\t\t  port_cnt;\t/**< Current number of ports.\t    */\n    unsigned\t\t  connect_cnt;\t/**< Total number of connections    */\n    pj_mutex_t\t\t *mutex;\t/**< Conference mutex.\t\t    */\n    struct vconf_port\t**ports;\t/**< Array of ports.\t\t    */\n    pjmedia_clock\t *clock;\t/**< Clock.\t\t\t    */\n};\n\n\n/*\n * Rendering state: converter, layout settings, etc.\n */\ntypedef struct render_state\n{\n    pjmedia_format_id\tsrc_fmt_id;\t/**< Source format ID.\t\t    */\n    pjmedia_rect_size\tsrc_frame_size;\t/**< Source frame size.\t\t    */\n    pjmedia_rect\tsrc_rect;\t/**< Source region to be rendered.  */\n\n    pjmedia_format_id\tdst_fmt_id;\t/**< Destination format ID.\t    */\n    pjmedia_rect_size\tdst_frame_size;\t/**< Destination frame size.\t    */\n    pjmedia_rect\tdst_rect;\t/**< Destination region.\t    */\n\n    pjmedia_converter\t*converter;\t/**< Converter.\t\t\t    */\n\n} render_state;\n\n\n/*\n * Conference bridge port.\n */\ntypedef struct vconf_port\n{\n    pj_pool_t\t\t*pool;\t\t/**< Pool.\t\t\t    */\n    unsigned\t\t idx;\t\t/**< Port index.\t\t    */\n    pj_str_t\t\t name;\t\t/**< Port name.\t\t\t    */\n    pjmedia_port\t*port;\t\t/**< Video port.\t\t    */\n    pjmedia_format\t format;\t/**< Copy of port format info.\t    */\n    pj_uint32_t\t\t ts_interval;\t/**< Port put/get interval.\t    */\n    pj_timestamp\t ts_next;\t/**< Time for next put/get_frame(). */\n    void\t\t*get_buf;\t/**< Buffer for get_frame().\t    */\n    pj_size_t\t\t get_buf_size;\t/**< Buffer size for get_frame().   */\n    void\t\t*put_buf;\t/**< Buffer for put_frame().\t    */\n    pj_size_t\t\t put_buf_size;\t/**< Buffer size for put_frame().   */\n\n    unsigned\t\t listener_cnt;\t/**< Number of listeners.\t    */\n    unsigned\t\t*listener_slots;/**< Array of listeners (for info). */\n\n    unsigned\t\t transmitter_cnt;/**<Number of transmitters.\t    */\n    unsigned\t\t*transmitter_slots;/**< Array of transmitters.\t    */\n    pj_pool_t\t       **render_pool;\t/**< Array of pool for render state */\n    render_state       **render_states;\t/**< Array of render_state (one for\n\t\t\t\t\t     each transmitter).\t\t    */\n\n    pj_status_t\t\t  last_err;\t/**< Last error status.\t\t    */\n    unsigned\t\t  last_err_cnt;\t/**< Last error count.\t\t    */\n} vconf_port;\n\n\n/* Prototypes */\nstatic void on_clock_tick(const pj_timestamp *ts, void *user_data);\nstatic pj_status_t render_src_frame(vconf_port *src, vconf_port *sink,\n\t\t\t\t    unsigned transmitter_idx);\nstatic void update_render_state(pjmedia_vid_conf *vid_conf, vconf_port *cp);\nstatic void cleanup_render_state(vconf_port *cp,\n\t\t\t\t unsigned transmitter_idx);\n\n\n/*\n * Initialize video conference settings with default values.\n */\nPJ_DEF(void) pjmedia_vid_conf_setting_default(pjmedia_vid_conf_setting *opt)\n{\n    pj_bzero(opt, sizeof(*opt));\n    opt->max_slot_cnt = 32;\n    opt->frame_rate = 60;\n}\n\n\n/*\n * Create a video conference bridge.\n */\nPJ_DEF(pj_status_t) pjmedia_vid_conf_create(\n\t\t\t\t\tpj_pool_t *pool,\n\t\t\t\t\tconst pjmedia_vid_conf_setting *opt,\n\t\t\t\t\tpjmedia_vid_conf **p_vid_conf)\n{\n    pjmedia_vid_conf *vid_conf;\n    pjmedia_clock_param clock_param;\n    pj_status_t status;\n\n    PJ_ASSERT_RETURN(pool && p_vid_conf, PJ_EINVAL);\n\n    /* Allocate conf structure */\n    vid_conf = PJ_POOL_ZALLOC_T(pool, pjmedia_vid_conf);\n    PJ_ASSERT_RETURN(vid_conf, PJ_ENOMEM);\n\n    /* Init settings */\n    if (opt) {\n\tvid_conf->opt = *opt;\n    } else {\n\tpjmedia_vid_conf_setting_default(&vid_conf->opt);\n    }\n\n    /* Allocate ports */\n    vid_conf->ports = (vconf_port**)\n\t\t      pj_pool_zalloc(pool, vid_conf->opt.max_slot_cnt *\n\t\t\t\t\t   sizeof(vconf_port*));\n    PJ_ASSERT_RETURN(vid_conf->ports, PJ_ENOMEM);\n\n    /* Create mutex */\n    status = pj_mutex_create_recursive(pool, CONF_NAME, &vid_conf->mutex);\n    if (status != PJ_SUCCESS) {\n\tpjmedia_vid_conf_destroy(vid_conf);\n\treturn status;\n    }\n\n    /* Create clock */\n    pj_bzero(&clock_param, sizeof(clock_param));\n    clock_param.clock_rate = TS_CLOCK_RATE;\n    clock_param.usec_interval = 1000000 / vid_conf->opt.frame_rate;\n    status = pjmedia_clock_create2(pool, &clock_param, 0, &on_clock_tick,\n\t\t\t\t   vid_conf, &vid_conf->clock);\n    if (status != PJ_SUCCESS) {\n\tpjmedia_vid_conf_destroy(vid_conf);\n\treturn status;\n    }\n\n    /* Done */\n    *p_vid_conf = vid_conf;\n\n    PJ_LOG(5,(THIS_FILE, \"Created video conference bridge with %d ports\",\n\t      vid_conf->opt.max_slot_cnt));\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Destroy video conference bridge.\n */\nPJ_DEF(pj_status_t) pjmedia_vid_conf_destroy(pjmedia_vid_conf *vid_conf)\n{\n    unsigned i;\n\n    PJ_ASSERT_RETURN(vid_conf, PJ_EINVAL);\n\n    /* Destroy clock */\n    if (vid_conf->clock) {\n\tpjmedia_clock_destroy(vid_conf->clock);\n\tvid_conf->clock = NULL;\n    }\n\n    /* Remove any registered ports (at least to cleanup their pool) */\n    for (i=0; i < vid_conf->opt.max_slot_cnt; ++i) {\n\tpjmedia_vid_conf_remove_port(vid_conf, i);\n    }\n\n    /* Destroy mutex */\n    if (vid_conf->mutex) {\n\tpj_mutex_destroy(vid_conf->mutex);\n\tvid_conf->mutex = NULL;\n    }\n\n    PJ_LOG(5,(THIS_FILE, \"Video conference bridge destroyed\"));\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Add a media port to the video conference bridge.\n */\nPJ_DEF(pj_status_t) pjmedia_vid_conf_add_port( pjmedia_vid_conf *vid_conf,\n\t\t\t\t\t       pj_pool_t *parent_pool,\n\t\t\t\t\t       pjmedia_port *port,\n\t\t\t\t\t       const pj_str_t *name,\n\t\t\t\t\t       void *opt,\n\t\t\t\t\t       unsigned *p_slot)\n{\n    pj_pool_t *pool;\n    vconf_port *cport;\n    unsigned index;\n\n    PJ_ASSERT_RETURN(vid_conf && parent_pool && port, PJ_EINVAL);\n    PJ_ASSERT_RETURN(port->info.fmt.type==PJMEDIA_TYPE_VIDEO &&\n\t\t     port->info.fmt.detail_type==PJMEDIA_FORMAT_DETAIL_VIDEO,\n\t\t     PJ_EINVAL);\n    PJ_UNUSED_ARG(opt);\n\n    /* If name is not specified, use the port's name */\n    if (!name)\n\tname = &port->info.name;\n\n    pj_mutex_lock(vid_conf->mutex);\n\n    if (vid_conf->port_cnt >= vid_conf->opt.max_slot_cnt) {\n\tpj_assert(!\"Too many ports\");\n\tpj_mutex_unlock(vid_conf->mutex);\n\treturn PJ_ETOOMANY;\n    }\n\n    /* Find empty port in the conference bridge. */\n    for (index=0; index < vid_conf->opt.max_slot_cnt; ++index) {\n\tif (vid_conf->ports[index] == NULL)\n\t    break;\n    }\n    pj_assert(index != vid_conf->opt.max_slot_cnt);\n\n    /* Create pool */\n    pool = pj_pool_create(parent_pool->factory, name->ptr, 500, 500, NULL);\n    PJ_ASSERT_RETURN(pool, PJ_ENOMEM);\n\n    /* Create port. */\n    cport = PJ_POOL_ZALLOC_T(pool, vconf_port);\n    PJ_ASSERT_RETURN(cport, PJ_ENOMEM);\n\n    /* Set pool, port, index, and name */\n    cport->pool = pool;\n    cport->port = port;\n    cport->format = port->info.fmt;\n    cport->idx  = index;\n    pj_strdup_with_null(pool, &cport->name, name);\n\n    /* Init put/get_frame() intervals */\n    {\n\tpjmedia_ratio *fps = &port->info.fmt.det.vid.fps;\n\tpj_uint32_t vconf_interval = (pj_uint32_t)\n\t\t\t\t     (TS_CLOCK_RATE * 1.0 /\n\t\t\t\t     vid_conf->opt.frame_rate);\n\tcport->ts_interval = (pj_uint32_t)(TS_CLOCK_RATE * 1.0 /\n\t\t\t\t\t   fps->num * fps->denum);\n\n\t/* Normalize the interval */\n\tif (cport->ts_interval < vconf_interval) {\n\t    cport->ts_interval = vconf_interval;\n\t    PJ_LOG(3,(THIS_FILE, \"Warning: frame rate of port %s is higher \"\n\t\t\t\t \"than video conference bridge (%d > %d)\",\n\t\t\t\t name->ptr, (int)(fps->num/fps->denum),\n\t\t\t\t vid_conf->opt.frame_rate));\n\t}\n    }\n\n    /* Allocate buffer for put/get_frame() */\n    {\n\tconst pjmedia_video_format_info *vfi;\n\tpjmedia_video_apply_fmt_param vafp;\n\tpj_status_t status;\n\n\tvfi = pjmedia_get_video_format_info(NULL, port->info.fmt.id);\n\tif (!vfi) {\n\t    PJ_LOG(4,(THIS_FILE, \"pjmedia_vid_conf_add_port(): \"\n\t\t\t\t \"unrecognized format %04X\",\n\t\t\t\t port->info.fmt.id));\n\t    pj_mutex_unlock(vid_conf->mutex);\n\t    return PJMEDIA_EBADFMT;\n\t}\n\n\tpj_bzero(&vafp, sizeof(vafp));\n\tvafp.size = port->info.fmt.det.vid.size;\n\tstatus = (*vfi->apply_fmt)(vfi, &vafp);\n\tif (status != PJ_SUCCESS) {\n\t    PJ_LOG(4,(THIS_FILE, \"pjmedia_vid_conf_add_port(): \"\n\t\t\t\t \"Failed to apply format %04X\",\n\t\t\t\t port->info.fmt.id));\n\t    pj_mutex_unlock(vid_conf->mutex);\n\t    return status;\n\t}\n\tif (port->put_frame) {\n\t    cport->put_buf_size = vafp.framebytes;\n\t    cport->put_buf = pj_pool_zalloc(cport->pool, cport->put_buf_size);\n\t}\n\tif (port->get_frame) {\n\t    cport->get_buf_size = vafp.framebytes;\n\t    cport->get_buf = pj_pool_zalloc(cport->pool, cport->get_buf_size);\n\t}\n    }\n\n    /* Create listener array */\n    cport->listener_slots = (unsigned*)\n\t\t\t    pj_pool_zalloc(pool,\n\t\t\t\t\t   vid_conf->opt.max_slot_cnt *\n\t\t\t\t\t   sizeof(unsigned));\n    if (!cport->listener_slots) {\t\n\tpj_mutex_unlock(vid_conf->mutex);\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create transmitter array */\n    cport->transmitter_slots = (unsigned*)\n\t\t\t       pj_pool_zalloc(pool,\n\t\t\t\t\t      vid_conf->opt.max_slot_cnt *\n\t\t\t\t\t      sizeof(unsigned));    \n    if (!cport->transmitter_slots) {\n\tpj_mutex_unlock(vid_conf->mutex);\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create pointer-to-render_state array */\n    cport->render_states = (render_state**)\n\t\t\t   pj_pool_zalloc(pool,\n\t\t\t\t\t  vid_conf->opt.max_slot_cnt *\n\t\t\t\t\t  sizeof(render_state*));\n\n    if (!cport->render_states) {\n\tpj_mutex_unlock(vid_conf->mutex);\n\treturn PJ_ENOMEM;\n    }\n\n    /* Create pointer-to-render-pool array */\n    cport->render_pool = (pj_pool_t**)\n\t\t\t pj_pool_zalloc(pool,\n\t\t\t\t\tvid_conf->opt.max_slot_cnt *\n\t\t\t\t\tsizeof(pj_pool_t*));    \n    if (!cport->render_pool) {\n\tpj_mutex_unlock(vid_conf->mutex);\n\treturn PJ_ENOMEM;\n    }\n\n    /* Register the conf port. */\n    vid_conf->ports[index] = cport;\n    vid_conf->port_cnt++;\n\n    PJ_LOG(4,(THIS_FILE,\"Added port %d (%.*s)\",\n\t      index, (int)cport->name.slen, cport->name.ptr));\n\n    pj_mutex_unlock(vid_conf->mutex);\n\n    /* Done. */\n    if (p_slot) {\n\t*p_slot = index;\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Remove a media port from the video conference bridge.\n */\nPJ_DEF(pj_status_t) pjmedia_vid_conf_remove_port( pjmedia_vid_conf *vid_conf,\n\t\t\t\t\t\t  unsigned slot)\n{\n    vconf_port *cport;\n\n    PJ_ASSERT_RETURN(vid_conf && slot<vid_conf->opt.max_slot_cnt, PJ_EINVAL);\n\n    pj_mutex_lock(vid_conf->mutex);\n\n    /* Port must be valid. */\n    cport = vid_conf->ports[slot];\n    if (cport == NULL) {\n\tpj_mutex_unlock(vid_conf->mutex);\n\treturn PJ_EINVAL;\n    }\n\n    /* Disconnect slot -> listeners */\n    while (cport->listener_cnt) {\n\tpjmedia_vid_conf_disconnect_port(vid_conf, slot,\n\t\t\t\t\t cport->listener_slots[0]);\n    }\n\n    /* Disconnect transmitters -> slot */\n    while (cport->transmitter_cnt) {\n\tpjmedia_vid_conf_disconnect_port(vid_conf,\n\t\t\t\t\t cport->transmitter_slots[0], slot);\n    }\n\n    /* Remove the port. */\n    vid_conf->ports[slot] = NULL;\n    --vid_conf->port_cnt;\n\n    PJ_LOG(4,(THIS_FILE,\"Removed port %d (%.*s)\",\n\t      slot, (int)cport->name.slen, cport->name.ptr));\n\n    /* Release pool */\n    pj_pool_safe_release(&cport->pool);\n\n    if (AUTO_STOP_CLOCK && vid_conf->connect_cnt == 0) {\n\tpj_status_t status;\n\n\t/* Warning: will stuck if this is called from the clock thread */\n\tstatus = pjmedia_clock_stop(vid_conf->clock);\n\tif (status != PJ_SUCCESS) {\n\t    PJ_PERROR(4, (THIS_FILE, status, \"Failed to stop clock\"));\n\t    pj_mutex_unlock(vid_conf->mutex);\n\t    return status;\n\t}\n    }\n\n    pj_mutex_unlock(vid_conf->mutex);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get number of ports currently registered in the video conference bridge.\n */\nPJ_DEF(unsigned) pjmedia_vid_conf_get_port_count(pjmedia_vid_conf *vid_conf)\n{\n    return vid_conf->port_cnt;\n}\n\n\n/*\n * Enumerate occupied slots in the video conference bridge.\n */\nPJ_DEF(pj_status_t) pjmedia_vid_conf_enum_ports( pjmedia_vid_conf *vid_conf,\n\t\t\t\t\t\t unsigned slots[],\n\t\t\t\t\t\t unsigned *count)\n{\n    unsigned i, tmp_count=0;\n\n    PJ_ASSERT_RETURN(vid_conf && slots && count, PJ_EINVAL);\n\n    /* Lock mutex */\n    pj_mutex_lock(vid_conf->mutex);\n\n    for (i=0; i<vid_conf->opt.max_slot_cnt && tmp_count<*count; ++i) {\n\tif (!vid_conf->ports[i])\n\t    continue;\n\n\tslots[tmp_count++] = i;\n    }\n\n    /* Unlock mutex */\n    pj_mutex_unlock(vid_conf->mutex);\n\n    *count = tmp_count;\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Get port info.\n */\nPJ_DEF(pj_status_t) pjmedia_vid_conf_get_port_info(\n\t\t\t\t\t    pjmedia_vid_conf *vid_conf,\n\t\t\t\t\t    unsigned slot,\n\t\t\t\t\t    pjmedia_vid_conf_port_info *info)\n{\n    vconf_port *cp;\n\n    /* Check arguments */\n    PJ_ASSERT_RETURN(vid_conf && slot<vid_conf->opt.max_slot_cnt, PJ_EINVAL);\n\n    /* Lock mutex */\n    pj_mutex_lock(vid_conf->mutex);\n\n    /* Port must be valid. */\n    cp = vid_conf->ports[slot];\n    if (cp == NULL) {\n\tpj_mutex_unlock(vid_conf->mutex);\n\treturn PJ_EINVAL;\n    }\n\n    info->slot = slot;\n    info->name = cp->name;\n    pjmedia_format_copy(&info->format, &cp->port->info.fmt);\n    info->listener_cnt = cp->listener_cnt;\n    info->listener_slots = cp->listener_slots;\n    info->transmitter_cnt = cp->transmitter_cnt;\n    info->transmitter_slots = cp->transmitter_slots;\n\n    /* Unlock mutex */\n    pj_mutex_unlock(vid_conf->mutex);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Enable unidirectional video flow from the specified source slot to\n * the specified sink slot.\n */\nPJ_DEF(pj_status_t) pjmedia_vid_conf_connect_port(\n\t\t\t\t\t    pjmedia_vid_conf *vid_conf,\n\t\t\t\t\t    unsigned src_slot,\n\t\t\t\t\t    unsigned sink_slot,\n\t\t\t\t\t    void *opt)\n{\n    vconf_port *src_port, *dst_port;\n    unsigned i;\n\n    /* Check arguments */\n    PJ_ASSERT_RETURN(vid_conf &&\n\t\t     src_slot<vid_conf->opt.max_slot_cnt && \n\t\t     sink_slot<vid_conf->opt.max_slot_cnt, PJ_EINVAL);\n    PJ_UNUSED_ARG(opt);\n\n    pj_mutex_lock(vid_conf->mutex);\n\n    /* Ports must be valid. */\n    src_port = vid_conf->ports[src_slot];\n    dst_port = vid_conf->ports[sink_slot];\n    if (!src_port || !src_port->port->get_frame ||\n\t!dst_port || !dst_port->port->put_frame)\n    {\n\tPJ_LOG(4,(THIS_FILE,\"Failed connecting video ports, make sure that \"\n\t\t\t    \"source has get_frame() & sink has put_frame()\"));\n\tpj_mutex_unlock(vid_conf->mutex);\n\treturn PJ_EINVAL;\n    }\n\n    /* Check if connection has been made */\n    for (i=0; i<src_port->listener_cnt; ++i) {\n\tif (src_port->listener_slots[i] == sink_slot)\n\t    break;\n    }\n\n    if (i == src_port->listener_cnt) {\n\tsrc_port->listener_slots[src_port->listener_cnt] = sink_slot;\n\tdst_port->transmitter_slots[dst_port->transmitter_cnt] = src_slot;\n\t++src_port->listener_cnt;\n\t++dst_port->transmitter_cnt;\n\n\tif (src_port->listener_cnt == 1) {\n    \t    /* If this is the first listener, initialize source's buffer\n    \t     * with black color.\n    \t     */\n\t    const pjmedia_video_format_info *vfi;\n\t    pjmedia_video_apply_fmt_param vafp;\n\n\t    vfi = pjmedia_get_video_format_info(NULL,\n\t    \t\t\t\t\tsrc_port->port->info.fmt.id);\n\t    pj_bzero(&vafp, sizeof(vafp));\n\t    vafp.size = src_port->port->info.fmt.det.vid.size;\n\t    (*vfi->apply_fmt)(vfi, &vafp);\n\n\t    if (vfi->color_model == PJMEDIA_COLOR_MODEL_RGB) {\n\t    \tpj_memset(src_port->get_buf, 0, vafp.framebytes);\n\t    } else if (src_port->port->info.fmt.id == PJMEDIA_FORMAT_I420 ||\n\t  \t       src_port->port->info.fmt.id == PJMEDIA_FORMAT_YV12)\n\t    {\t    \t\n\t    \tpj_memset(src_port->get_buf, 16, vafp.plane_bytes[0]);\n\t    \tpj_memset((pj_uint8_t*)src_port->get_buf + vafp.plane_bytes[0],\n\t\t      \t  0x80, vafp.plane_bytes[1] * 2);\n\t    }\n\t}\n\n\tupdate_render_state(vid_conf, dst_port);\n\n\t++vid_conf->connect_cnt;\n\tif (vid_conf->connect_cnt == 1) {\n\t    pj_status_t status;\n\t    status = pjmedia_clock_start(vid_conf->clock);\n\t    if (status != PJ_SUCCESS) {\n\t\tPJ_PERROR(4, (THIS_FILE, status, \"Failed to start clock\"));\n\t\tpj_mutex_unlock(vid_conf->mutex);\n\t\treturn status;\n\t    }\n\t}\n\n\tPJ_LOG(4,(THIS_FILE,\"Port %d (%.*s) transmitting to port %d (%.*s)\",\n\t\t  src_slot,\n\t\t  (int)src_port->name.slen,\n\t\t  src_port->name.ptr,\n\t\t  sink_slot,\n\t\t  (int)dst_port->name.slen,\n\t\t  dst_port->name.ptr));\n    }\n\n    pj_mutex_unlock(vid_conf->mutex);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Disconnect unidirectional video flow from the specified source to\n * the specified sink slot.\n */\nPJ_DEF(pj_status_t) pjmedia_vid_conf_disconnect_port(\n\t\t\t\t\t    pjmedia_vid_conf *vid_conf,\n\t\t\t\t\t    unsigned src_slot,\n\t\t\t\t\t    unsigned sink_slot)\n{\n    vconf_port *src_port, *dst_port;\n    unsigned i, j;\n\n    /* Check arguments */\n    PJ_ASSERT_RETURN(vid_conf &&\n\t\t     src_slot<vid_conf->opt.max_slot_cnt && \n\t\t     sink_slot<vid_conf->opt.max_slot_cnt, PJ_EINVAL);\n\n    pj_mutex_lock(vid_conf->mutex);\n\n    /* Ports must be valid. */\n    src_port = vid_conf->ports[src_slot];\n    dst_port = vid_conf->ports[sink_slot];\n    if (!src_port || !dst_port) {\n\tpj_mutex_unlock(vid_conf->mutex);\n\treturn PJ_EINVAL;\n    }\n\n    /* Check if connection has been made */\n    for (i=0; i<src_port->listener_cnt; ++i) {\n\tif (src_port->listener_slots[i] == sink_slot)\n\t    break;\n    }\n    for (j=0; j<dst_port->transmitter_cnt; ++j) {\n\tif (dst_port->transmitter_slots[j] == src_slot)\n\t    break;\n    }\n\n    if (i != src_port->listener_cnt && j != dst_port->transmitter_cnt) {\n\tunsigned k;\n\n\tpj_assert(src_port->listener_cnt > 0 && \n\t\t  src_port->listener_cnt < vid_conf->opt.max_slot_cnt);\n\tpj_assert(dst_port->transmitter_cnt > 0 && \n\t\t  dst_port->transmitter_cnt < vid_conf->opt.max_slot_cnt);\n\n\t/* Cleanup all render states of the sink */\n\tfor (k=0; k<dst_port->transmitter_cnt; ++k)\n\t    cleanup_render_state(dst_port, k);\n\n\t/* Update listeners array of the source and transmitters array of\n\t * the sink.\n\t */\n\tpj_array_erase(src_port->listener_slots, sizeof(unsigned), \n\t\t       src_port->listener_cnt, i);\n\tpj_array_erase(dst_port->transmitter_slots, sizeof(unsigned), \n\t\t       dst_port->transmitter_cnt, j);\n\t--src_port->listener_cnt;\n\t--dst_port->transmitter_cnt;\n\n\t/* Update render states of the sink */\n\tupdate_render_state(vid_conf, dst_port);\n\n\t--vid_conf->connect_cnt;\n\n\tif (AUTO_STOP_CLOCK && vid_conf->connect_cnt == 0) {\n\t    pj_status_t status;\n\t    /* Warning: will stuck if this is called from the clock thread */\n\t    status = pjmedia_clock_stop(vid_conf->clock);\n\t    if (status != PJ_SUCCESS) {\n\t\tPJ_PERROR(4, (THIS_FILE, status, \"Failed to stop clock\"));\n\t\tpj_mutex_unlock(vid_conf->mutex);\n\t\treturn status;\n\t    }\n\t}\n\n\tPJ_LOG(4,(THIS_FILE,\n\t\t  \"Port %d (%.*s) stop transmitting to port %d (%.*s)\",\n\t\t  src_slot,\n\t\t  (int)src_port->name.slen,\n\t\t  src_port->name.ptr,\n\t\t  sink_slot,\n\t\t  (int)dst_port->name.slen,\n\t\t  dst_port->name.ptr));\n    }\n\n    pj_mutex_unlock(vid_conf->mutex);\n\n    return PJ_SUCCESS;\n}\n\n\n/*\n * Internal functions.\n */\n\nstatic void on_clock_tick(const pj_timestamp *now, void *user_data)\n{\n    pjmedia_vid_conf *vid_conf = (pjmedia_vid_conf*)user_data;\n    unsigned ci, i;\n    pj_int32_t ts_diff;\n    pjmedia_frame frame;\n    pj_status_t status;\n\n    pj_mutex_lock(vid_conf->mutex);\n\n    /* Iterate all (sink) ports */\n    for (i=0, ci=0; i<vid_conf->opt.max_slot_cnt &&\n\t\t    ci<vid_conf->port_cnt; ++i)\n    {\n\tunsigned j;\n\tpj_bool_t got_frame = PJ_FALSE;\n\tpj_bool_t ts_incremented = PJ_FALSE;\n\tvconf_port *sink = vid_conf->ports[i];\n\n\t/* Skip empty port */\n\tif (!sink)\n\t    continue;\n\n\t/* Increment occupied port counter */\n\t++ci;\n\n\t/* Skip non-sink port */\n\tif (!sink->port->put_frame)\n\t    continue;\n\n\tif (sink->ts_next.u64 == 0)\n\t    sink->ts_next = *now;\n\n\t/* Skip if too early for put_frame(), note:\n\t * early = (now < ts_next)\n\t * But careful for timestamp wrapped around.\n\t */\n\tts_diff = pj_timestamp_diff32(&sink->ts_next, now);\n\tif (ts_diff < 0 || ts_diff > TS_CLOCK_RATE)\n\t    continue;\n\n\t/* Clean up sink put buffer (should we draw black instead?) */\n\t//pj_bzero(sink->put_buf, sink->put_buf_size);\n\n\t/* Iterate transmitters of this sink port */\n\tfor (j=0; j < sink->transmitter_cnt; ++j) {\n\t    vconf_port *src = vid_conf->ports[sink->transmitter_slots[j]];\n\t    pj_int32_t src_ts_diff;\n\n\t    if (src->ts_next.u64 == 0)\n\t\tsrc->ts_next = *now;\n\n\t    /* Is it time for src->get_frame()? yes, if (now >= ts_next) */\n\t    src_ts_diff = pj_timestamp_diff32(&src->ts_next, now);\n\t    if (src_ts_diff >= 0) {\n\n\t\t/* Call src->get_frame().\n\t\t * Possible optimization: if this src only has one listener,\n\t\t * perhaps we can skip this src buffer and directly render it\n\t\t * to sink buffer (but still need buffer if conversion any).\n\t\t */\n\t\tpj_bzero(&frame, sizeof(frame));\n\t\tframe.type = PJMEDIA_FRAME_TYPE_VIDEO;\n\t\tframe.timestamp = *now;\n\t\tframe.buf = src->get_buf;\n\t\tframe.size = src->get_buf_size;\n\t\tstatus = pjmedia_port_get_frame(src->port, &frame);\n\t\tif (status != PJ_SUCCESS) {\n\t\t    PJ_PERROR(5, (THIS_FILE, status,\n\t\t\t\t  \"Failed to get frame from port %d [%s]!\",\n\t\t\t\t  src->idx, src->port->info.name.ptr));\n\t\t}\n\n\t\t/* Update next src put/get */\n\t\tpj_add_timestamp32(&src->ts_next, src->ts_interval);\n\t\tts_incremented = src==sink;\n\t    }\n\n\t    /* Render src get buffer to sink put buffer (based on sink layout\n\t     * settings, if any)\n\t     */\n\t    status = render_src_frame(src, sink, j);\n\t    if (status != PJ_SUCCESS) {\n\t\tPJ_PERROR(5, (THIS_FILE, status,\n\t\t\t      \"Failed to render frame from port %d [%s] to \"\n\t\t\t      \"%d [%s]\",\n\t\t\t      src->idx, src->port->info.name.ptr,\n\t\t\t      sink->idx, sink->port->info.name.ptr));\n\t    }\n\n\t    got_frame = PJ_TRUE;\n\t}\n\n\t/* Call sink->put_frame()\n\t * Note that if transmitter_cnt==0, we should still call put_frame()\n\t * with zero frame size, as sink may need to send keep-alive packets\n\t * and get timestamp update.\n\t */\n\tpj_bzero(&frame, sizeof(frame));\n\tframe.type = PJMEDIA_FRAME_TYPE_VIDEO;\n\tframe.timestamp = *now;\n\tif (got_frame) {\n\t    frame.buf = sink->put_buf;\n\t    frame.size = sink->put_buf_size;\n\t}\n\tstatus = pjmedia_port_put_frame(sink->port, &frame);\n\tif (got_frame && status != PJ_SUCCESS) {\n\t    sink->last_err_cnt++;\n\t    if (sink->last_err != status ||\n\t        sink->last_err_cnt % MAX_ERR_COUNT == 0)\n\t    {\n\t\tif (sink->last_err != status)\n\t\t    sink->last_err_cnt = 1;\n\t\tsink->last_err = status;\n\t    \tPJ_PERROR(5, (THIS_FILE, status,\n\t\t\t      \"Failed (%d time(s)) to put frame to port %d\"\n\t\t\t      \" [%s]!\", sink->last_err_cnt,\n\t\t\t      sink->idx, sink->port->info.name.ptr));\n\t    }\n\t} else {\n\t    sink->last_err = status;\n\t    sink->last_err_cnt = 0;\n\t}\n\n\t/* Update next put/get, careful that it may have been updated\n\t * if this port transmits to itself!\n\t */\n\tif (!ts_incremented) {\n\t    pj_add_timestamp32(&sink->ts_next, sink->ts_interval);\n\t}\n    }\n\n    pj_mutex_unlock(vid_conf->mutex);\n}\n\nstatic pj_bool_t is_landscape(const pjmedia_rect_size *size) {\n    return (size->w >= size->h);\n}\n\n/* Adjust a frame size to match ratio specified in the ref_size.\n * Either dimension of the frame may be cropped (but will never be\n * expanded).\n */\nstatic void match_ratio_crop(pjmedia_rect_size *size,\n\t\t\t     const pjmedia_rect_size *ref_size)\n{\n    pjmedia_rect_size res;\n\n    /* Try match width first */\n    res.w = size->w;\n    res.h = ref_size->h * size->w / ref_size->w;\n    \n    /* If original height turns out to be shorther, match height */\n    if (size->h < res.h) {\n\tres.w = ref_size->w * size->h / ref_size->h;\n\tres.h = size->h;\n    }\n\n    *size = res;\n    return;\n}\n\n/* Cleanup rendering states, called when a transmitter is disconnected\n * from a listener, or before reinit-ing rendering state of a listener\n * when new connection has just been made.\n */\nstatic void cleanup_render_state(vconf_port *cp,\n\t\t\t\t unsigned transmitter_idx)\n{\n    render_state *rs = cp->render_states[transmitter_idx];\n    if (rs && rs->converter)\n    {\n\tpjmedia_converter_destroy(rs->converter);\n\trs->converter = NULL;\n    }\n    cp->render_states[transmitter_idx] = NULL;\n\n    if (cp->render_pool[transmitter_idx]) {\n\tpj_pool_safe_release(&cp->render_pool[transmitter_idx]);\n\n\tTRACE_((THIS_FILE, \"Cleaned up render state for connection %d->%d\",\n\t\tcp->transmitter_slots[transmitter_idx], cp->idx));\n    }\n}\n\n/* This function will do:\n * - Recalculate layout setting, i.e: get video pos and size\n *   for each transmitter\n * - Check if converter is needed and setup it.\n * - Those above things will be stored in render_state and\n *   will be used by render_src_frame()\n */\nstatic void update_render_state(pjmedia_vid_conf *vid_conf, vconf_port *cp)\n{\n    pjmedia_format_id fmt_id, tr_fmt_id[4];\n    pjmedia_rect_size size, tr_size[4];\n    unsigned i;\n    pj_status_t status;\n\n    /* Nothing to render, just return */\n    if (cp->transmitter_cnt == 0)\n\treturn;\n\n    TRACE_((THIS_FILE, \"Updating render state for port id %d (%d sources)..\",\n\t    cp->idx, cp->transmitter_cnt));\n\n    fmt_id = cp->port->info.fmt.id;\n    size   = cp->port->info.fmt.det.vid.size;\n    for (i = 0; i < cp->transmitter_cnt; ++i) {\n\tvconf_port *tr = vid_conf->ports[cp->transmitter_slots[i]];\n\n\t/* Cleanup render states & pool */\n\tcleanup_render_state(cp, i);\n\n\t/* Gather format ID, size of each transmitter */\n\ttr_fmt_id[i] = tr->port->info.fmt.id;\n\ttr_size[i]   = tr->port->info.fmt.det.vid.size;\n    }\n\n    /* If only one transmitter and it has matched format & size, just use\n     * plain memcpy(). Usually preview window or call stream window will\n     * have matched format & size with its source.\n     */\n    if (cp->transmitter_cnt == 1 && fmt_id == tr_fmt_id[0] &&\n\tpj_memcmp(&size, &tr_size[0], sizeof(size))==0)\n    {\n\tTRACE_((THIS_FILE, \"This port only has single source with \"\n\t\t\t   \"matched format & size, no conversion needed\"));\n\treturn;\n    }\n\n    for (i = 0; i < cp->transmitter_cnt && i < 4; ++i) {\n\tpj_pool_t *pool;\n\trender_state *rs;\n\tpjmedia_conversion_param cparam;\n\tchar tmp_buf[32];\n\n\t/* Create pool & render state */\n\tpj_ansi_snprintf(tmp_buf, sizeof(tmp_buf), \"vcport_rs_%d->%d\",\n\t\t\t cp->transmitter_slots[i], cp->idx);\n\tpool = pj_pool_create(cp->pool->factory, tmp_buf, 128, 128, NULL);\n\tcp->render_pool[i] = pool;\n\trs = cp->render_states[i] = PJ_POOL_ZALLOC_T(pool, render_state);\n\n\tTRACE_((THIS_FILE, \"Created render state for connection %d->%d\",\n\t\t\t   cp->transmitter_slots[i], cp->idx));\n\n\t/* Setup format & frame */\n\trs->src_fmt_id = tr_fmt_id[i];\n\trs->dst_fmt_id = fmt_id;\n\trs->src_frame_size = tr_size[i];\n\trs->dst_frame_size = size;\n\n\t/* For now, draw the whole source frame, will adjust ratio later */\n\trs->src_rect.coord.x = rs->src_rect.coord.y = 0;\n\trs->src_rect.size = tr_size[i];\n\n\t/* Setup layout */\n\tif (cp->transmitter_cnt == 1) {\n\t    rs->dst_rect.coord.x = rs->dst_rect.coord.y = 0;\n\t    rs->dst_rect.size = size;\n\t} else if (cp->transmitter_cnt == 2) {\n\t    if (is_landscape(&size)) {\n\t\t/*\n\t\t *          |\n\t\t * Source 0 | Source 1\n\t\t *          |\n\t\t */\n\t\trs->dst_rect.coord.x = i * (size.w/2);\n\t\trs->dst_rect.coord.y = 0;\n\t\trs->dst_rect.size.w = size.w / 2;\n\t\trs->dst_rect.size.h = size.h;\n\t    } else {\n\t\t/*\n\t\t * Source 0\n\t\t * --------\n\t\t * Source 1\n\t\t */\n\t\trs->dst_rect.coord.x = 0;\n\t\trs->dst_rect.coord.y = i * (size.h/2);\n\t\trs->dst_rect.size.w = size.w;\n\t\trs->dst_rect.size.h = size.h / 2;\n\t    }\n\t} else if (cp->transmitter_cnt == 3) {\n\t    if (is_landscape(&size)) {\n\t\t/*\n\t\t *          | Source 1\n\t\t * Source 0 |---------\n\t\t *          | Source 2\n\t\t */\n\t\trs->dst_rect.coord.x = (i==0)? 0 : size.w/2;\n\t\trs->dst_rect.coord.y = (i!=2)? 0 : size.h/2;\n\t\trs->dst_rect.size.w = size.w / 2;\n\t\trs->dst_rect.size.h = (i==0)? size.h : size.h/2;\n\t    } else {\n\t\t/*\n\t\t * Source 0\n\t\t * --------\n\t\t * Source 1\n\t\t * --------\n\t\t * Source 2\n\t\t */\n\t\trs->dst_rect.coord.x = 0;\n\t\trs->dst_rect.coord.y = i * size.h/3;\n\t\trs->dst_rect.size.w = size.w;\n\t\trs->dst_rect.size.h = size.h/3;\n\t    }\n\t} else if (cp->transmitter_cnt == 4) {\n\t    if (is_landscape(&size)) {\n\t\t/*\n\t\t * Source 0 | Source 1\n\t\t * ---------|---------\n\t\t * Source 2 | Source 3\n\t\t */\n\t\trs->dst_rect.coord.x = (i%2==0)? 0 : size.w/2;\n\t\trs->dst_rect.coord.y = (i/2==0)? 0 : size.h/2;\n\t\trs->dst_rect.size.w = size.w/2;\n\t\trs->dst_rect.size.h = size.h/2;\n\t    } else {\n\t\t/*\n\t\t * Source 0\n\t\t * --------\n\t\t * Source 1\n\t\t * --------\n\t\t * Source 2\n\t\t * --------\n\t\t * Source 3\n\t\t */\n\t\trs->dst_rect.coord.x = 0;\n\t\trs->dst_rect.coord.y = i * size.h/4;\n\t\trs->dst_rect.size.w = size.w;\n\t\trs->dst_rect.size.h = size.h/4;\n\t    }\n\t}\n\n\t/* Adjust source size to match aspect ratio of rendering space. */\n\tmatch_ratio_crop(&rs->src_rect.size, &rs->dst_rect.size);\n\n\t/* Now adjust source position after source size adjustment. */\n\tif (rs->src_rect.size.w < tr_size[i].w)\n\t    rs->src_rect.coord.x = (tr_size[i].w - rs->src_rect.size.w)/2;\n\tif (rs->src_rect.size.h < tr_size[i].h)\n\t    rs->src_rect.coord.y = (tr_size[i].h - rs->src_rect.size.h)/2;\n\n\tTRACE_((THIS_FILE, \"src#%d=%s/%dx%d->%dx%d@%d,%d dst=%dx%d@%d,%d\",\n\t\t\t   i, pjmedia_fourcc_name(tr_fmt_id[i], tmp_buf),\n\t\t\t   tr_size[i].w, tr_size[i].h,\n\t\t\t   rs->src_rect.size.w, rs->src_rect.size.h,\n\t\t\t   rs->src_rect.coord.x, rs->src_rect.coord.y,\n\t\t\t   rs->dst_rect.size.w, rs->dst_rect.size.h,\n\t\t\t   rs->dst_rect.coord.x, rs->dst_rect.coord.y));\n\n\t/* Create converter */\n\tpjmedia_format_init_video(&cparam.src, rs->src_fmt_id,\n\t\t\t\t  rs->src_rect.size.w,\n\t\t\t\t  rs->src_rect.size.h,\n\t\t\t\t  0, 1);\n\tpjmedia_format_init_video(&cparam.dst, rs->dst_fmt_id,\n\t\t\t\t  rs->dst_rect.size.w,\n\t\t\t\t  rs->dst_rect.size.h,\n\t\t\t\t  0, 1);\n\tstatus = pjmedia_converter_create(NULL, pool, &cparam,\n\t\t\t\t\t  &rs->converter);\n\tif (status != PJ_SUCCESS) {\n\t    PJ_PERROR(4,(THIS_FILE, status,\n\t\t\t \"Port %d failed creating converter \"\n\t\t\t \"for source %d\", cp->idx, i));\n\t}\n    }\n}\n\n/* Render frame from source to sink buffer based on rendering settings. */\nstatic pj_status_t render_src_frame(vconf_port *src, vconf_port *sink,\n\t\t\t\t    unsigned transmitter_idx)\n{\n    pj_status_t status;\n    render_state *rs = sink->render_states[transmitter_idx];\n\n    if (sink->transmitter_cnt == 1 && (!rs || !rs->converter)) {\n\t/* The only transmitter and no conversion needed */\n\tpj_assert(src->get_buf_size <= sink->put_buf_size);\n\tpj_memcpy(sink->put_buf, src->get_buf, src->get_buf_size);\n    } else if (rs && rs->converter) {\n\tpjmedia_frame src_frame, dst_frame;\n\t\n\tpj_bzero(&src_frame, sizeof(src_frame));\n\tsrc_frame.buf = src->get_buf;\n\tsrc_frame.size = src->get_buf_size;\n\n\tpj_bzero(&dst_frame, sizeof(dst_frame));\n\tdst_frame.buf = sink->put_buf;\n\tdst_frame.size = sink->put_buf_size;\n\n\tstatus = pjmedia_converter_convert2(rs->converter,\n\t\t\t\t\t    &src_frame,\n\t\t\t\t\t    &rs->src_frame_size,\n\t\t\t\t\t    &rs->src_rect.coord,\n\t\t\t\t\t    &dst_frame,\n\t\t\t\t\t    &rs->dst_frame_size,\n\t\t\t\t\t    &rs->dst_rect.coord,\n\t\t\t\t\t    NULL);\n\tif (status != PJ_SUCCESS) {\n\t    PJ_PERROR(4,(THIS_FILE, status,\n\t\t\t \"Port id %d: converter failed in \"\n\t\t\t \"rendering frame from port id %d\",\n\t\t\t sink->idx, transmitter_idx));\n\t    return status;\n\t}\n    }\n\n    return PJ_SUCCESS;\n}\n\n\n/* Update or refresh port states from video port info. */\nPJ_DEF(pj_status_t) pjmedia_vid_conf_update_port( pjmedia_vid_conf *vid_conf,\n\t\t\t\t\t\t  unsigned slot)\n{\n    vconf_port *cport;\n    pjmedia_format old_fmt;\n    pjmedia_format new_fmt;\n\n    PJ_ASSERT_RETURN(vid_conf && slot<vid_conf->opt.max_slot_cnt, PJ_EINVAL);\n\n    pj_mutex_lock(vid_conf->mutex);\n\n    /* Port must be valid. */\n    cport = vid_conf->ports[slot];\n    if (cport == NULL) {\n\tpj_mutex_unlock(vid_conf->mutex);\n\treturn PJ_EINVAL;\n    }\n\n    /* Get the old & new formats */\n    old_fmt = cport->format;\n    new_fmt = cport->port->info.fmt;\n\n    /* Update put/get_frame() intervals */\n    if (pj_memcmp(&new_fmt.det.vid.fps, &old_fmt.det.vid.fps,\n\t\t  sizeof(pjmedia_ratio)))\n    {\n\tpjmedia_ratio *fps = &new_fmt.det.vid.fps;\n\tpj_uint32_t vconf_interval = (pj_uint32_t)\n\t\t\t\t     (TS_CLOCK_RATE * 1.0 /\n\t\t\t\t     vid_conf->opt.frame_rate);\n\tcport->ts_interval = (pj_uint32_t)(TS_CLOCK_RATE * 1.0 /\n\t\t\t\t\t   fps->num * fps->denum);\n\n\t/* Normalize the interval */\n\tif (cport->ts_interval < vconf_interval) {\n\t    cport->ts_interval = vconf_interval;\n\t    PJ_LOG(3,(THIS_FILE, \"Warning: frame rate of port %s is higher \"\n\t\t\t\t \"than video conference bridge (%d > %d)\",\n\t\t\t\t cport->name.ptr, (int)(fps->num/fps->denum),\n\t\t\t\t vid_conf->opt.frame_rate));\n\t}\n\n\tPJ_LOG(4,(THIS_FILE,\n\t\t  \"Port %d (%s): updated frame rate %d -> %d\",\n\t\t  slot, cport->name.ptr,\n\t\t  (int)(old_fmt.det.vid.fps.num/old_fmt.det.vid.fps.denum),\n\t\t  (int)(fps->num/fps->denum)));\n    }\n\n    /* Update buffer for put/get_frame() */\n    if (new_fmt.id != old_fmt.id ||\n\tpj_memcmp(&new_fmt.det.vid.size, &old_fmt.det.vid.size,\n\t\t  sizeof(pjmedia_rect_size)))\n    {\n\tconst pjmedia_video_format_info *vfi;\n\tpjmedia_video_apply_fmt_param vafp;\n\tpj_status_t status;\n\tunsigned i;\n\n\tvfi = pjmedia_get_video_format_info(NULL, new_fmt.id);\n\tif (!vfi) {\n\t    PJ_LOG(1,(THIS_FILE, \"pjmedia_vid_conf_update_port(): \"\n\t\t\t\t \"unrecognized format %04X\",\n\t\t\t\t new_fmt.id));\n\t    pj_mutex_unlock(vid_conf->mutex);\n\t    return PJMEDIA_EBADFMT;\n\t}\n\n\tpj_bzero(&vafp, sizeof(vafp));\n\tvafp.size = new_fmt.det.vid.size;\n\tstatus = (*vfi->apply_fmt)(vfi, &vafp);\n\tif (status != PJ_SUCCESS) {\n\t    PJ_LOG(1,(THIS_FILE, \"pjmedia_vid_conf_update_port(): \"\n\t\t\t\t \"Failed to apply format %04X\",\n\t\t\t\t new_fmt.id));\n\t    pj_mutex_unlock(vid_conf->mutex);\n\t    return status;\n\t}\n\tif (cport->port->put_frame) {\n\t    if (cport->put_buf_size < vafp.framebytes)\n\t\tcport->put_buf = pj_pool_zalloc(cport->pool, vafp.framebytes);\n\t    cport->put_buf_size = vafp.framebytes;\n\t}\n\tif (cport->port->get_frame) {\n\t    if (cport->get_buf_size < vafp.framebytes)\n\t\tcport->get_buf = pj_pool_zalloc(cport->pool, vafp.framebytes);\n\t    cport->get_buf_size = vafp.framebytes;\n\t}\n\n\t/* Update render state */\n\tupdate_render_state(vid_conf, cport);\n\n\t/* Update render state of listeners */\n\tfor (i=0; i < cport->listener_cnt; ++i) {\n\t    vconf_port *sink = vid_conf->ports[cport->listener_slots[i]];\n\t    update_render_state(vid_conf, sink);\n\t}\n\n\tPJ_LOG(4,(THIS_FILE,\n\t\t  \"Port %d (%s): updated frame size %dx%d -> %dx%d\",\n\t\t  slot, cport->name.ptr,\n\t\t  old_fmt.det.vid.size.w, old_fmt.det.vid.size.h,\n\t\t  new_fmt.det.vid.size.w, new_fmt.det.vid.size.h));\n    }\n\n\n    /* Update cport format info */\n    cport->format = new_fmt;\n    pj_mutex_unlock(vid_conf->mutex);\n\n    return PJ_SUCCESS;\n}\n\n\n#endif /* PJMEDIA_HAS_VIDEO */\n"], "filenames": ["pjmedia/src/pjmedia-codec/and_aud_mediacodec.cpp", "pjmedia/src/pjmedia-codec/ipp_codecs.c", "pjmedia/src/pjmedia-codec/opus.c", "pjmedia/src/pjmedia-codec/passthrough.c", "pjmedia/src/pjmedia-codec/speex_codec.c", "pjmedia/src/pjmedia/vid_conf.c"], "buggy_code_start_loc": [756, 941, 725, 627, 381, 306], "buggy_code_end_loc": [756, 941, 769, 627, 381, 675], "fixing_code_start_loc": [757, 942, 726, 628, 382, 307], "fixing_code_end_loc": [758, 943, 772, 629, 383, 694], "type": "CWE-667", "message": "PJSIP is a free and open source multimedia communication library written in the C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In various parts of PJSIP, when error/failure occurs, it is found that the function returns without releasing the currently held locks. This could result in a system deadlock, which cause a denial of service for the users. No release has yet been made which contains the linked fix commit. All versions up to an including 2.11.1 are affected. Users may need to manually apply the patch.", "other": {"cve": {"id": "CVE-2021-41141", "sourceIdentifier": "security-advisories@github.com", "published": "2022-01-04T19:15:14.687", "lastModified": "2022-11-16T19:07:09.427", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "PJSIP is a free and open source multimedia communication library written in the C language implementing standard based protocols such as SIP, SDP, RTP, STUN, TURN, and ICE. In various parts of PJSIP, when error/failure occurs, it is found that the function returns without releasing the currently held locks. This could result in a system deadlock, which cause a denial of service for the users. No release has yet been made which contains the linked fix commit. All versions up to an including 2.11.1 are affected. Users may need to manually apply the patch."}, {"lang": "es", "value": "PJSIP es una biblioteca de comunicaci\u00f3n multimedia gratuita y de c\u00f3digo abierto escrita en lenguaje C que implementa protocolos basados en est\u00e1ndares como SIP, SDP, RTP, STUN, TURN e ICE. En varias partes de PJSIP, cuando es producido un error/fallo, es encontrado que la funci\u00f3n retorna sin liberar los bloqueos que se presentan actualmente. Esto podr\u00eda resultar en un bloqueo del sistema, que causar\u00eda una denegaci\u00f3n de servicio para los usuarios. Todav\u00eda no ha sido realizado ninguna publicaci\u00f3n que contenga el commit de correcci\u00f3n vinculado. Todas las versiones hasta la 2.11.1 incluy\u00e9ndola est\u00e1n afectadas. Es posible que los usuarios tengan que aplicar el parche manualmente"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:C", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "COMPLETE", "baseScore": 7.8}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-667"}]}, {"source": "nvd@nist.gov", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-667"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:teluu:pjsip:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.11.1", "matchCriteriaId": "6BB0273A-3235-4BC7-A1BE-7D35BABD8617"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://github.com/pjsip/pjproject/commit/1aa2c0e0fb60a1b0bf793e0d834073ffe50fb196", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/pjsip/pjproject/security/advisories/GHSA-8fmx-hqw7-6gmc", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/03/msg00035.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202210-37", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/pjsip/pjproject/commit/1aa2c0e0fb60a1b0bf793e0d834073ffe50fb196"}}