{"buggy_code": ["/*************************************************\n*     Exim - an Internet mail transport agent    *\n*************************************************/\n\n/* Copyright (c) University of Cambridge 1995 - 2018 */\n/* Copyright (c) The Exim Maintainers 2020 */\n/* See the file NOTICE for conditions of use and distribution. */\n\n/* Functions for finding hosts, either by gethostbyname(), gethostbyaddr(), or\ndirectly via the DNS. When IPv6 is supported, getipnodebyname() and\ngetipnodebyaddr() may be used instead of gethostbyname() and gethostbyaddr(),\nif the newer functions are available. This module also contains various other\nfunctions concerned with hosts and addresses, and a random number function,\nused for randomizing hosts with equal MXs but available for use in other parts\nof Exim. */\n\n\n#include \"exim.h\"\n\n\n/* Static variable for preserving the list of interface addresses in case it is\nused more than once. */\n\nstatic ip_address_item *local_interface_data = NULL;\n\n\n#ifdef USE_INET_NTOA_FIX\n/*************************************************\n*         Replacement for broken inet_ntoa()     *\n*************************************************/\n\n/* On IRIX systems, gcc uses a different structure passing convention to the\nnative libraries. This causes inet_ntoa() to always yield 0.0.0.0 or\n255.255.255.255. To get round this, we provide a private version of the\nfunction here. It is used only if USE_INET_NTOA_FIX is set, which should happen\nonly when gcc is in use on an IRIX system. Code send to me by J.T. Breitner,\nwith these comments:\n\n  code by Stuart Levy\n  as seen in comp.sys.sgi.admin\n\nAugust 2005: Apparently this is also needed for AIX systems; USE_INET_NTOA_FIX\nshould now be set for them as well.\n\nArguments:  sa  an in_addr structure\nReturns:        pointer to static text string\n*/\n\nchar *\ninet_ntoa(struct in_addr sa)\n{\nstatic uschar addr[20];\nsprintf(addr, \"%d.%d.%d.%d\",\n        (US &sa.s_addr)[0],\n        (US &sa.s_addr)[1],\n        (US &sa.s_addr)[2],\n        (US &sa.s_addr)[3]);\n  return addr;\n}\n#endif\n\n\n\n/*************************************************\n*              Random number generator           *\n*************************************************/\n\n/* This is a simple pseudo-random number generator. It does not have to be\nvery good for the uses to which it is put. When running the regression tests,\nstart with a fixed seed.\n\nIf you need better, see vaguely_random_number() which is potentially stronger,\nif a crypto library is available, but might end up just calling this instead.\n\nArguments:\n  limit:    one more than the largest number required\n\nReturns:    a pseudo-random number in the range 0 to limit-1\n*/\n\nint\nrandom_number(int limit)\n{\nif (limit < 1)\n  return 0;\nif (random_seed == 0)\n  {\n  if (f.running_in_test_harness) random_seed = 42; else\n    {\n    int p = (int)getpid();\n    random_seed = (int)time(NULL) ^ ((p << 16) | p);\n    }\n  }\nrandom_seed = 1103515245 * random_seed + 12345;\nreturn (unsigned int)(random_seed >> 16) % limit;\n}\n\n/*************************************************\n*      Wrappers for logging lookup times         *\n*************************************************/\n\n/* When the 'slow_lookup_log' variable is enabled, these wrappers will\nwrite to the log file all (potential) dns lookups that take more than\nslow_lookup_log milliseconds\n*/\n\nstatic void\nlog_long_lookup(const uschar * type, const uschar * data, unsigned long msec)\n{\nlog_write(0, LOG_MAIN, \"Long %s lookup for '%s': %lu msec\",\n  type, data, msec);\n}\n\n\n/* returns the current system epoch time in milliseconds. */\nstatic unsigned long\nget_time_in_ms()\n{\nstruct timeval tmp_time;\nunsigned long seconds, microseconds;\n\ngettimeofday(&tmp_time, NULL);\nseconds = (unsigned long) tmp_time.tv_sec;\nmicroseconds = (unsigned long) tmp_time.tv_usec;\nreturn seconds*1000 + microseconds/1000;\n}\n\n\nstatic int\ndns_lookup_timerwrap(dns_answer *dnsa, const uschar *name, int type,\n  const uschar **fully_qualified_name)\n{\nint retval;\nunsigned long time_msec;\n\nif (!slow_lookup_log)\n  return dns_lookup(dnsa, name, type, fully_qualified_name);\n\ntime_msec = get_time_in_ms();\nretval = dns_lookup(dnsa, name, type, fully_qualified_name);\nif ((time_msec = get_time_in_ms() - time_msec) > slow_lookup_log)\n  log_long_lookup(dns_text_type(type), name, time_msec);\nreturn retval;\n}\n\n\n/*************************************************\n*       Replace gethostbyname() when testing     *\n*************************************************/\n\n/* This function is called instead of gethostbyname(), gethostbyname2(), or\ngetipnodebyname() when running in the test harness. . It also\nrecognizes an unqualified \"localhost\" and forces it to the appropriate loopback\naddress. IP addresses are treated as literals. For other names, it uses the DNS\nto find the host name. In the test harness, this means it will access only the\nfake DNS resolver.\n\nArguments:\n  name          the host name or a textual IP address\n  af            AF_INET or AF_INET6\n  error_num     where to put an error code:\n                HOST_NOT_FOUND/TRY_AGAIN/NO_RECOVERY/NO_DATA\n\nReturns:        a hostent structure or NULL for an error\n*/\n\nstatic struct hostent *\nhost_fake_gethostbyname(const uschar *name, int af, int *error_num)\n{\n#if HAVE_IPV6\nint alen = (af == AF_INET)? sizeof(struct in_addr):sizeof(struct in6_addr);\n#else\nint alen = sizeof(struct in_addr);\n#endif\n\nint ipa;\nconst uschar *lname = name;\nuschar *adds;\nuschar **alist;\nstruct hostent *yield;\ndns_answer * dnsa = store_get_dns_answer();\ndns_scan dnss;\n\nDEBUG(D_host_lookup)\n  debug_printf(\"using host_fake_gethostbyname for %s (%s)\\n\", name,\n    af == AF_INET ? \"IPv4\" : \"IPv6\");\n\n/* Handle unqualified \"localhost\" */\n\nif (Ustrcmp(name, \"localhost\") == 0)\n  lname = af == AF_INET ? US\"127.0.0.1\" : US\"::1\";\n\n/* Handle a literal IP address */\n\nif ((ipa = string_is_ip_address(lname, NULL)) != 0)\n  if (   ipa == 4 && af == AF_INET\n     ||  ipa == 6 && af == AF_INET6)\n    {\n    int x[4];\n    yield = store_get(sizeof(struct hostent), FALSE);\n    alist = store_get(2 * sizeof(char *), FALSE);\n    adds  = store_get(alen, FALSE);\n    yield->h_name = CS name;\n    yield->h_aliases = NULL;\n    yield->h_addrtype = af;\n    yield->h_length = alen;\n    yield->h_addr_list = CSS alist;\n    *alist++ = adds;\n    for (int n = host_aton(lname, x), i = 0; i < n; i++)\n      {\n      int y = x[i];\n      *adds++ = (y >> 24) & 255;\n      *adds++ = (y >> 16) & 255;\n      *adds++ = (y >> 8) & 255;\n      *adds++ = y & 255;\n      }\n    *alist = NULL;\n    }\n\n  /* Wrong kind of literal address */\n\n  else\n    {\n    *error_num = HOST_NOT_FOUND;\n    yield = NULL;\n    goto out;\n    }\n\n/* Handle a host name */\n\nelse\n  {\n  int type = af == AF_INET ? T_A:T_AAAA;\n  int rc = dns_lookup_timerwrap(dnsa, lname, type, NULL);\n  int count = 0;\n\n  lookup_dnssec_authenticated = NULL;\n\n  switch(rc)\n    {\n    case DNS_SUCCEED: break;\n    case DNS_NOMATCH: *error_num = HOST_NOT_FOUND; yield = NULL; goto out;\n    case DNS_NODATA:  *error_num = NO_DATA; yield = NULL; goto out;\n    case DNS_AGAIN:   *error_num = TRY_AGAIN; yield = NULL; goto out;\n    default:\n    case DNS_FAIL:    *error_num = NO_RECOVERY; yield = NULL; goto out;\n    }\n\n  for (dns_record * rr = dns_next_rr(dnsa, &dnss, RESET_ANSWERS);\n       rr;\n       rr = dns_next_rr(dnsa, &dnss, RESET_NEXT)) if (rr->type == type)\n    count++;\n\n  yield = store_get(sizeof(struct hostent), FALSE);\n  alist = store_get((count + 1) * sizeof(char *), FALSE);\n  adds  = store_get(count *alen, FALSE);\n\n  yield->h_name = CS name;\n  yield->h_aliases = NULL;\n  yield->h_addrtype = af;\n  yield->h_length = alen;\n  yield->h_addr_list = CSS alist;\n\n  for (dns_record * rr = dns_next_rr(dnsa, &dnss, RESET_ANSWERS);\n       rr;\n       rr = dns_next_rr(dnsa, &dnss, RESET_NEXT)) if (rr->type == type)\n    {\n    int x[4];\n    dns_address *da;\n    if (!(da = dns_address_from_rr(dnsa, rr))) break;\n    *alist++ = adds;\n    for (int n = host_aton(da->address, x), i = 0; i < n; i++)\n      {\n      int y = x[i];\n      *adds++ = (y >> 24) & 255;\n      *adds++ = (y >> 16) & 255;\n      *adds++ = (y >> 8) & 255;\n      *adds++ = y & 255;\n      }\n    }\n  *alist = NULL;\n  }\n\nout:\n\nstore_free_dns_answer(dnsa);\nreturn yield;\n}\n\n\n\n/*************************************************\n*       Build chain of host items from list      *\n*************************************************/\n\n/* This function builds a chain of host items from a textual list of host\nnames. It does not do any lookups. If randomize is true, the chain is build in\na randomized order. There may be multiple groups of independently randomized\nhosts; they are delimited by a host name consisting of just \"+\".\n\nArguments:\n  anchor      anchor for the chain\n  list        text list\n  randomize   TRUE for randomizing\n\nReturns:      nothing\n*/\n\nvoid\nhost_build_hostlist(host_item **anchor, const uschar *list, BOOL randomize)\n{\nint sep = 0;\nint fake_mx = MX_NONE;          /* This value is actually -1 */\nuschar *name;\n\nif (!list) return;\nif (randomize) fake_mx--;       /* Start at -2 for randomizing */\n\n*anchor = NULL;\n\nwhile ((name = string_nextinlist(&list, &sep, NULL, 0)))\n  {\n  host_item *h;\n\n  if (name[0] == '+' && name[1] == 0)   /* \"+\" delimits a randomized group */\n    {                                   /* ignore if not randomizing */\n    if (randomize) fake_mx--;\n    continue;\n    }\n\n  h = store_get(sizeof(host_item), FALSE);\n  h->name = name;\n  h->address = NULL;\n  h->port = PORT_NONE;\n  h->mx = fake_mx;\n  h->sort_key = randomize? (-fake_mx)*1000 + random_number(1000) : 0;\n  h->status = hstatus_unknown;\n  h->why = hwhy_unknown;\n  h->last_try = 0;\n\n  if (!*anchor)\n    {\n    h->next = NULL;\n    *anchor = h;\n    }\n  else\n    {\n    host_item *hh = *anchor;\n    if (h->sort_key < hh->sort_key)\n      {\n      h->next = hh;\n      *anchor = h;\n      }\n    else\n      {\n      while (hh->next && h->sort_key >= hh->next->sort_key)\n        hh = hh->next;\n      h->next = hh->next;\n      hh->next = h;\n      }\n    }\n  }\n}\n\n\n\n\n\n/*************************************************\n*        Extract port from address string        *\n*************************************************/\n\n/* In the spool file, and in the -oMa and -oMi options, a host plus port is\ngiven as an IP address followed by a dot and a port number. This function\ndecodes this.\n\nAn alternative format for the -oMa and -oMi options is [ip address]:port which\nis what Exim 4 uses for output, because it seems to becoming commonly used,\nwhereas the dot form confuses some programs/people. So we recognize that form\ntoo.\n\nArgument:\n  address    points to the string; if there is a port, the '.' in the string\n             is overwritten with zero to terminate the address; if the string\n             is in the [xxx]:ppp format, the address is shifted left and the\n             brackets are removed\n\nReturns:     0 if there is no port, else the port number. If there's a syntax\n             error, leave the incoming address alone, and return 0.\n*/\n\nint\nhost_address_extract_port(uschar *address)\n{\nint port = 0;\nuschar *endptr;\n\n/* Handle the \"bracketed with colon on the end\" format */\n\nif (*address == '[')\n  {\n  uschar *rb = address + 1;\n  while (*rb != 0 && *rb != ']') rb++;\n  if (*rb++ == 0) return 0;        /* Missing ]; leave invalid address */\n  if (*rb == ':')\n    {\n    port = Ustrtol(rb + 1, &endptr, 10);\n    if (*endptr != 0) return 0;    /* Invalid port; leave invalid address */\n    }\n  else if (*rb != 0) return 0;     /* Bad syntax; leave invalid address */\n  memmove(address, address + 1, rb - address - 2);\n  rb[-2] = 0;\n  }\n\n/* Handle the \"dot on the end\" format */\n\nelse\n  {\n  int skip = -3;                   /* Skip 3 dots in IPv4 addresses */\n  address--;\n  while (*(++address) != 0)\n    {\n    int ch = *address;\n    if (ch == ':') skip = 0;       /* Skip 0 dots in IPv6 addresses */\n      else if (ch == '.' && skip++ >= 0) break;\n    }\n  if (*address == 0) return 0;\n  port = Ustrtol(address + 1, &endptr, 10);\n  if (*endptr != 0) return 0;      /* Invalid port; leave invalid address */\n  *address = 0;\n  }\n\nreturn port;\n}\n\n\n/*************************************************\n*         Get port from a host item's name       *\n*************************************************/\n\n/* This function is called when finding the IP address for a host that is in a\nlist of hosts explicitly configured, such as in the manualroute router, or in a\nfallback hosts list. We see if there is a port specification at the end of the\nhost name, and if so, remove it. A minimum length of 3 is required for the\noriginal name; nothing shorter is recognized as having a port.\n\nWe test for a name ending with a sequence of digits; if preceded by colon we\nhave a port if the character before the colon is ] and the name starts with [\nor if there are no other colons in the name (i.e. it's not an IPv6 address).\n\nArguments:  pointer to the host item\nReturns:    a port number or PORT_NONE\n*/\n\nint\nhost_item_get_port(host_item *h)\n{\nconst uschar *p;\nint port, x;\nint len = Ustrlen(h->name);\n\nif (len < 3 || (p = h->name + len - 1, !isdigit(*p))) return PORT_NONE;\n\n/* Extract potential port number */\n\nport = *p-- - '0';\nx = 10;\n\nwhile (p > h->name + 1 && isdigit(*p))\n  {\n  port += (*p-- - '0') * x;\n  x *= 10;\n  }\n\n/* The smallest value of p at this point is h->name + 1. */\n\nif (*p != ':') return PORT_NONE;\n\nif (p[-1] == ']' && h->name[0] == '[')\n  h->name = string_copyn(h->name + 1, p - h->name - 2);\nelse if (Ustrchr(h->name, ':') == p)\n  h->name = string_copyn(h->name, p - h->name);\nelse return PORT_NONE;\n\nDEBUG(D_route|D_host_lookup) debug_printf(\"host=%s port=%d\\n\", h->name, port);\nreturn port;\n}\n\n\n\n#ifndef STAND_ALONE    /* Omit when standalone testing */\n\n/*************************************************\n*     Build sender_fullhost and sender_rcvhost   *\n*************************************************/\n\n/* This function is called when sender_host_name and/or sender_helo_name\nhave been set. Or might have been set - for a local message read off the spool\nthey won't be. In that case, do nothing. Otherwise, set up the fullhost string\nas follows:\n\n(a) No sender_host_name or sender_helo_name: \"[ip address]\"\n(b) Just sender_host_name: \"host_name [ip address]\"\n(c) Just sender_helo_name: \"(helo_name) [ip address]\" unless helo is IP\n            in which case: \"[ip address}\"\n(d) The two are identical: \"host_name [ip address]\" includes helo = IP\n(e) The two are different: \"host_name (helo_name) [ip address]\"\n\nIf log_incoming_port is set, the sending host's port number is added to the IP\naddress.\n\nThis function also builds sender_rcvhost for use in Received: lines, whose\nsyntax is a bit different. This value also includes the RFC 1413 identity.\nThere wouldn't be two different variables if I had got all this right in the\nfirst place.\n\nBecause this data may survive over more than one incoming SMTP message, it has\nto be in permanent store.  However, STARTTLS has to be forgotten and redone\non a multi-message conn, so this will be called once per message then.  Hence\nwe use malloc, so we can free.\n\nArguments:  none\nReturns:    nothing\n*/\n\nvoid\nhost_build_sender_fullhost(void)\n{\nBOOL show_helo = TRUE;\nuschar * address, * fullhost, * rcvhost;\nrmark reset_point;\nint len;\n\nif (!sender_host_address) return;\n\nreset_point = store_mark();\n\n/* Set up address, with or without the port. After discussion, it seems that\nthe only format that doesn't cause trouble is [aaaa]:pppp. However, we can't\nuse this directly as the first item for Received: because it ain't an RFC 2822\ndomain. Sigh. */\n\naddress = string_sprintf(\"[%s]:%d\", sender_host_address, sender_host_port);\nif (!LOGGING(incoming_port) || sender_host_port <= 0)\n  *(Ustrrchr(address, ':')) = 0;\n\n/* If there's no EHLO/HELO data, we can't show it. */\n\nif (!sender_helo_name) show_helo = FALSE;\n\n/* If HELO/EHLO was followed by an IP literal, it's messy because of two\nfeatures of IPv6. Firstly, there's the \"IPv6:\" prefix (Exim is liberal and\ndoesn't require this, for historical reasons). Secondly, IPv6 addresses may not\nbe given in canonical form, so we have to canonicalize them before comparing. As\nit happens, the code works for both IPv4 and IPv6. */\n\nelse if (sender_helo_name[0] == '[' &&\n         sender_helo_name[(len=Ustrlen(sender_helo_name))-1] == ']')\n  {\n  int offset = 1;\n  uschar *helo_ip;\n\n  if (strncmpic(sender_helo_name + 1, US\"IPv6:\", 5) == 0) offset += 5;\n  if (strncmpic(sender_helo_name + 1, US\"IPv4:\", 5) == 0) offset += 5;\n\n  helo_ip = string_copyn(sender_helo_name + offset, len - offset - 1);\n\n  if (string_is_ip_address(helo_ip, NULL) != 0)\n    {\n    int x[4], y[4];\n    int sizex, sizey;\n    uschar ipx[48], ipy[48];    /* large enough for full IPv6 */\n\n    sizex = host_aton(helo_ip, x);\n    sizey = host_aton(sender_host_address, y);\n\n    (void)host_nmtoa(sizex, x, -1, ipx, ':');\n    (void)host_nmtoa(sizey, y, -1, ipy, ':');\n\n    if (strcmpic(ipx, ipy) == 0) show_helo = FALSE;\n    }\n  }\n\n/* Host name is not verified */\n\nif (!sender_host_name)\n  {\n  uschar *portptr = Ustrstr(address, \"]:\");\n  gstring * g;\n  int adlen;    /* Sun compiler doesn't like ++ in initializers */\n\n  adlen = portptr ? (++portptr - address) : Ustrlen(address);\n  fullhost = sender_helo_name\n    ? string_sprintf(\"(%s) %s\", sender_helo_name, address)\n    : address;\n\n  g = string_catn(NULL, address, adlen);\n\n  if (sender_ident || show_helo || portptr)\n    {\n    int firstptr;\n    g = string_catn(g, US\" (\", 2);\n    firstptr = g->ptr;\n\n    if (portptr)\n      g = string_append(g, 2, US\"port=\", portptr + 1);\n\n    if (show_helo)\n      g = string_append(g, 2,\n        firstptr == g->ptr ? US\"helo=\" : US\" helo=\", sender_helo_name);\n\n    if (sender_ident)\n      g = string_append(g, 2,\n        firstptr == g->ptr ? US\"ident=\" : US\" ident=\", sender_ident);\n\n    g = string_catn(g, US\")\", 1);\n    }\n\n  rcvhost = string_from_gstring(g);\n  }\n\n/* Host name is known and verified. Unless we've already found that the HELO\ndata matches the IP address, compare it with the name. */\n\nelse\n  {\n  if (show_helo && strcmpic(sender_host_name, sender_helo_name) == 0)\n    show_helo = FALSE;\n\n  if (show_helo)\n    {\n    fullhost = string_sprintf(\"%s (%s) %s\", sender_host_name,\n      sender_helo_name, address);\n    rcvhost = sender_ident\n      ?  string_sprintf(\"%s\\n\\t(%s helo=%s ident=%s)\", sender_host_name,\n        address, sender_helo_name, sender_ident)\n      : string_sprintf(\"%s (%s helo=%s)\", sender_host_name,\n        address, sender_helo_name);\n    }\n  else\n    {\n    fullhost = string_sprintf(\"%s %s\", sender_host_name, address);\n    rcvhost = sender_ident\n      ?  string_sprintf(\"%s (%s ident=%s)\", sender_host_name, address,\n        sender_ident)\n      : string_sprintf(\"%s (%s)\", sender_host_name, address);\n    }\n  }\n\nsender_fullhost = string_copy_perm(fullhost, TRUE);\nsender_rcvhost = string_copy_perm(rcvhost, TRUE);\n\nstore_reset(reset_point);\n\nDEBUG(D_host_lookup) debug_printf(\"sender_fullhost = %s\\n\", sender_fullhost);\nDEBUG(D_host_lookup) debug_printf(\"sender_rcvhost = %s\\n\", sender_rcvhost);\n}\n\n\n\n/*************************************************\n*          Build host+ident message              *\n*************************************************/\n\n/* Used when logging rejections and various ACL and SMTP incidents. The text\nreturn depends on whether sender_fullhost and sender_ident are set or not:\n\n  no ident, no host   => U=unknown\n  no ident, host set  => H=sender_fullhost\n  ident set, no host  => U=ident\n  ident set, host set => H=sender_fullhost U=ident\n\nUse taint-unchecked routines on the assumption we'll never expand the results.\n\nArguments:\n  useflag   TRUE if first item to be flagged (H= or U=); if there are two\n              items, the second is always flagged\n\nReturns:    pointer to a string in big_buffer\n*/\n\nuschar *\nhost_and_ident(BOOL useflag)\n{\nif (!sender_fullhost)\n  string_format_nt(big_buffer, big_buffer_size, \"%s%s\", useflag ? \"U=\" : \"\",\n     sender_ident ? sender_ident : US\"unknown\");\nelse\n  {\n  uschar * flag = useflag ? US\"H=\" : US\"\";\n  uschar * iface = US\"\";\n  if (LOGGING(incoming_interface) && interface_address)\n    iface = string_sprintf(\" I=[%s]:%d\", interface_address, interface_port);\n  if (sender_ident)\n    string_format_nt(big_buffer, big_buffer_size, \"%s%s%s U=%s\",\n      flag, sender_fullhost, iface, sender_ident);\n  else\n    string_format_nt(big_buffer, big_buffer_size, \"%s%s%s\",\n      flag, sender_fullhost, iface);\n  }\nreturn big_buffer;\n}\n\n#endif   /* STAND_ALONE */\n\n\n\n\n/*************************************************\n*         Build list of local interfaces         *\n*************************************************/\n\n/* This function interprets the contents of the local_interfaces or\nextra_local_interfaces options, and creates an ip_address_item block for each\nitem on the list. There is no special interpretation of any IP addresses; in\nparticular, 0.0.0.0 and ::0 are returned without modification. If any address\nincludes a port, it is set in the block. Otherwise the port value is set to\nzero.\n\nArguments:\n  list        the list\n  name        the name of the option being expanded\n\nReturns:      a chain of ip_address_items, each containing to a textual\n              version of an IP address, and a port number (host order) or\n              zero if no port was given with the address\n*/\n\nip_address_item *\nhost_build_ifacelist(const uschar *list, uschar *name)\n{\nint sep = 0;\nuschar *s;\nip_address_item * yield = NULL, * last = NULL, * next;\nBOOL taint = is_tainted(list);\n\nwhile ((s = string_nextinlist(&list, &sep, NULL, 0)))\n  {\n  int ipv;\n  int port = host_address_extract_port(s);            /* Leaves just the IP address */\n\n  if (!(ipv = string_is_ip_address(s, NULL)))\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Malformed IP address \\\"%s\\\" in %s\",\n      s, name);\n\n  /* Skip IPv6 addresses if IPv6 is disabled. */\n\n  if (disable_ipv6 && ipv == 6) continue;\n\n  /* This use of strcpy() is OK because we have checked that s is a valid IP\n  address above. The field in the ip_address_item is large enough to hold an\n  IPv6 address. */\n\n  next = store_get(sizeof(ip_address_item), taint);\n  next->next = NULL;\n  Ustrcpy(next->address, s);\n  next->port = port;\n  next->v6_include_v4 = FALSE;\n  next->log = NULL;\n\n  if (!yield)\n    yield = last = next;\n  else\n    {\n    last->next = next;\n    last = next;\n    }\n  }\n\nreturn yield;\n}\n\n\n\n\n\n/*************************************************\n*         Find addresses on local interfaces     *\n*************************************************/\n\n/* This function finds the addresses of local IP interfaces. These are used\nwhen testing for routing to the local host. As the function may be called more\nthan once, the list is preserved in permanent store, pointed to by a static\nvariable, to save doing the work more than once per process.\n\nThe generic list of interfaces is obtained by calling host_build_ifacelist()\nfor local_interfaces and extra_local_interfaces. This list scanned to remove\nduplicates (which may exist with different ports - not relevant here). If\neither of the wildcard IP addresses (0.0.0.0 and ::0) are encountered, they are\nreplaced by the appropriate (IPv4 or IPv6) list of actual local interfaces,\nobtained from os_find_running_interfaces().\n\nArguments:    none\nReturns:      a chain of ip_address_items, each containing to a textual\n              version of an IP address; the port numbers are not relevant\n*/\n\n\n/* First, a local subfunction to add an interface to a list in permanent store,\nbut only if there isn't a previous copy of that address on the list. */\n\nstatic ip_address_item *\nadd_unique_interface(ip_address_item *list, ip_address_item *ipa)\n{\nip_address_item *ipa2;\nfor (ipa2 = list; ipa2; ipa2 = ipa2->next)\n  if (Ustrcmp(ipa2->address, ipa->address) == 0) return list;\nipa2 = store_get_perm(sizeof(ip_address_item), FALSE);\n*ipa2 = *ipa;\nipa2->next = list;\nreturn ipa2;\n}\n\n\n/* This is the globally visible function */\n\nip_address_item *\nhost_find_interfaces(void)\n{\nip_address_item *running_interfaces = NULL;\n\nif (!local_interface_data)\n  {\n  void *reset_item = store_mark();\n  ip_address_item *dlist = host_build_ifacelist(CUS local_interfaces,\n    US\"local_interfaces\");\n  ip_address_item *xlist = host_build_ifacelist(CUS extra_local_interfaces,\n    US\"extra_local_interfaces\");\n  ip_address_item *ipa;\n\n  if (!dlist) dlist = xlist;\n  else\n    {\n    for (ipa = dlist; ipa->next; ipa = ipa->next) ;\n    ipa->next = xlist;\n    }\n\n  for (ipa = dlist; ipa; ipa = ipa->next)\n    {\n    if (Ustrcmp(ipa->address, \"0.0.0.0\") == 0 ||\n        Ustrcmp(ipa->address, \"::0\") == 0)\n      {\n      BOOL ipv6 = ipa->address[0] == ':';\n      if (!running_interfaces)\n        running_interfaces = os_find_running_interfaces();\n      for (ip_address_item * ipa2 = running_interfaces; ipa2; ipa2 = ipa2->next)\n        if ((Ustrchr(ipa2->address, ':') != NULL) == ipv6)\n          local_interface_data = add_unique_interface(local_interface_data,\n\t\t\t\t\t\t      ipa2);\n      }\n    else\n      {\n      local_interface_data = add_unique_interface(local_interface_data, ipa);\n      DEBUG(D_interface)\n        {\n        debug_printf(\"Configured local interface: address=%s\", ipa->address);\n        if (ipa->port != 0) debug_printf(\" port=%d\", ipa->port);\n        debug_printf(\"\\n\");\n        }\n      }\n    }\n  store_reset(reset_item);\n  }\n\nreturn local_interface_data;\n}\n\n\n\n\n\n/*************************************************\n*        Convert network IP address to text      *\n*************************************************/\n\n/* Given an IPv4 or IPv6 address in binary, convert it to a text\nstring and return the result in a piece of new store. The address can\neither be given directly, or passed over in a sockaddr structure. Note\nthat this isn't the converse of host_aton() because of byte ordering\ndifferences. See host_nmtoa() below.\n\nArguments:\n  type       if < 0 then arg points to a sockaddr, else\n             either AF_INET or AF_INET6\n  arg        points to a sockaddr if type is < 0, or\n             points to an IPv4 address (32 bits), or\n             points to an IPv6 address (128 bits),\n             in both cases, in network byte order\n  buffer     if NULL, the result is returned in gotten store;\n             else points to a buffer to hold the answer\n  portptr    points to where to put the port number, if non NULL; only\n             used when type < 0\n\nReturns:     pointer to character string\n*/\n\nuschar *\nhost_ntoa(int type, const void *arg, uschar *buffer, int *portptr)\n{\nuschar *yield;\n\n/* The new world. It is annoying that we have to fish out the address from\ndifferent places in the block, depending on what kind of address it is. It\nis also a pain that inet_ntop() returns a const uschar *, whereas the IPv4\nfunction inet_ntoa() returns just uschar *, and some picky compilers insist\non warning if one assigns a const uschar * to a uschar *. Hence the casts. */\n\n#if HAVE_IPV6\nuschar addr_buffer[46];\nif (type < 0)\n  {\n  int family = ((struct sockaddr *)arg)->sa_family;\n  if (family == AF_INET6)\n    {\n    struct sockaddr_in6 *sk = (struct sockaddr_in6 *)arg;\n    yield = US inet_ntop(family, &(sk->sin6_addr), CS addr_buffer,\n      sizeof(addr_buffer));\n    if (portptr != NULL) *portptr = ntohs(sk->sin6_port);\n    }\n  else\n    {\n    struct sockaddr_in *sk = (struct sockaddr_in *)arg;\n    yield = US inet_ntop(family, &(sk->sin_addr), CS addr_buffer,\n      sizeof(addr_buffer));\n    if (portptr != NULL) *portptr = ntohs(sk->sin_port);\n    }\n  }\nelse\n  {\n  yield = US inet_ntop(type, arg, CS addr_buffer, sizeof(addr_buffer));\n  }\n\n/* If the result is a mapped IPv4 address, show it in V4 format. */\n\nif (Ustrncmp(yield, \"::ffff:\", 7) == 0) yield += 7;\n\n#else  /* HAVE_IPV6 */\n\n/* The old world */\n\nif (type < 0)\n  {\n  yield = US inet_ntoa(((struct sockaddr_in *)arg)->sin_addr);\n  if (portptr != NULL) *portptr = ntohs(((struct sockaddr_in *)arg)->sin_port);\n  }\nelse\n  yield = US inet_ntoa(*((struct in_addr *)arg));\n#endif\n\n/* If there is no buffer, put the string into some new store. */\n\nif (!buffer) buffer = store_get(46, FALSE);\n\n/* Callers of this function with a non-NULL buffer must ensure that it is\nlarge enough to hold an IPv6 address, namely, at least 46 bytes. That's what\nmakes this use of strcpy() OK.\nIf the library returned apparently an apparently tainted string, clean it;\nwe trust IP addresses. */\n\nstring_format_nt(buffer, 46, \"%s\", yield);\nreturn buffer;\n}\n\n\n\n\n/*************************************************\n*         Convert address text to binary         *\n*************************************************/\n\n/* Given the textual form of an IP address, convert it to binary in an\narray of ints. IPv4 addresses occupy one int; IPv6 addresses occupy 4 ints.\nThe result has the first byte in the most significant byte of the first int. In\nother words, the result is not in network byte order, but in host byte order.\nAs a result, this is not the converse of host_ntoa(), which expects network\nbyte order. See host_nmtoa() below.\n\nArguments:\n  address    points to the textual address, checked for syntax\n  bin        points to an array of 4 ints\n\nReturns:     the number of ints used\n*/\n\nint\nhost_aton(const uschar *address, int *bin)\n{\nint x[4];\nint v4offset = 0;\n\n/* Handle IPv6 address, which may end with an IPv4 address. It may also end\nwith a \"scope\", introduced by a percent sign. This code is NOT enclosed in #if\nHAVE_IPV6 in order that IPv6 addresses are recognized even if IPv6 is not\nsupported. */\n\nif (Ustrchr(address, ':') != NULL)\n  {\n  const uschar *p = address;\n  const uschar *component[8];\n  BOOL ipv4_ends = FALSE;\n  int ci = 0;\n  int nulloffset = 0;\n  int v6count = 8;\n  int i;\n\n  /* If the address starts with a colon, it will start with two colons.\n  Just lose the first one, which will leave a null first component. */\n\n  if (*p == ':') p++;\n\n  /* Split the address into components separated by colons. The input address\n  is supposed to be checked for syntax. There was a case where this was\n  overlooked; to guard against that happening again, check here and crash if\n  there are too many components. */\n\n  while (*p != 0 && *p != '%')\n    {\n    int len = Ustrcspn(p, \":%\");\n    if (len == 0) nulloffset = ci;\n    if (ci > 7) log_write(0, LOG_MAIN|LOG_PANIC_DIE,\n      \"Internal error: invalid IPv6 address \\\"%s\\\" passed to host_aton()\",\n      address);\n    component[ci++] = p;\n    p += len;\n    if (*p == ':') p++;\n    }\n\n  /* If the final component contains a dot, it is a trailing v4 address.\n  As the syntax is known to be checked, just set up for a trailing\n  v4 address and restrict the v6 part to 6 components. */\n\n  if (Ustrchr(component[ci-1], '.') != NULL)\n    {\n    address = component[--ci];\n    ipv4_ends = TRUE;\n    v4offset = 3;\n    v6count = 6;\n    }\n\n  /* If there are fewer than 6 or 8 components, we have to insert some\n  more empty ones in the middle. */\n\n  if (ci < v6count)\n    {\n    int insert_count = v6count - ci;\n    for (i = v6count-1; i > nulloffset + insert_count; i--)\n      component[i] = component[i - insert_count];\n    while (i > nulloffset) component[i--] = US\"\";\n    }\n\n  /* Now turn the components into binary in pairs and bung them\n  into the vector of ints. */\n\n  for (i = 0; i < v6count; i += 2)\n    bin[i/2] = (Ustrtol(component[i], NULL, 16) << 16) +\n      Ustrtol(component[i+1], NULL, 16);\n\n  /* If there was no terminating v4 component, we are done. */\n\n  if (!ipv4_ends) return 4;\n  }\n\n/* Handle IPv4 address */\n\n(void)sscanf(CS address, \"%d.%d.%d.%d\", x, x+1, x+2, x+3);\nbin[v4offset] = ((uint)x[0] << 24) + (x[1] << 16) + (x[2] << 8) + x[3];\nreturn v4offset+1;\n}\n\n\n/*************************************************\n*           Apply mask to an IP address          *\n*************************************************/\n\n/* Mask an address held in 1 or 4 ints, with the ms bit in the ms bit of the\nfirst int, etc.\n\nArguments:\n  count        the number of ints\n  binary       points to the ints to be masked\n  mask         the count of ms bits to leave, or -1 if no masking\n\nReturns:       nothing\n*/\n\nvoid\nhost_mask(int count, int *binary, int mask)\n{\nif (mask < 0) mask = 99999;\nfor (int i = 0; i < count; i++)\n  {\n  int wordmask;\n  if (mask == 0) wordmask = 0;\n  else if (mask < 32)\n    {\n    wordmask = (uint)(-1) << (32 - mask);\n    mask = 0;\n    }\n  else\n    {\n    wordmask = -1;\n    mask -= 32;\n    }\n  binary[i] &= wordmask;\n  }\n}\n\n\n\n\n/*************************************************\n*     Convert masked IP address in ints to text  *\n*************************************************/\n\n/* We can't use host_ntoa() because it assumes the binary values are in network\nbyte order, and these are the result of host_aton(), which puts them in ints in\nhost byte order. Also, we really want IPv6 addresses to be in a canonical\nformat, so we output them with no abbreviation. In a number of cases we can't\nuse the normal colon separator in them because it terminates keys in lsearch\nfiles, so we want to use dot instead. There's an argument that specifies what\nto use for IPv6 addresses.\n\nArguments:\n  count       1 or 4 (number of ints)\n  binary      points to the ints\n  mask        mask value; if < 0 don't add to result\n  buffer      big enough to hold the result\n  sep         component separator character for IPv6 addresses\n\nReturns:      the number of characters placed in buffer, not counting\n              the final nul.\n*/\n\nint\nhost_nmtoa(int count, int *binary, int mask, uschar *buffer, int sep)\n{\nint j;\nuschar *tt = buffer;\n\nif (count == 1)\n  {\n  j = binary[0];\n  for (int i = 24; i >= 0; i -= 8)\n    tt += sprintf(CS tt, \"%d.\", (j >> i) & 255);\n  }\nelse\n  for (int i = 0; i < 4; i++)\n    {\n    j = binary[i];\n    tt += sprintf(CS tt, \"%04x%c%04x%c\", (j >> 16) & 0xffff, sep, j & 0xffff, sep);\n    }\n\ntt--;   /* lose final separator */\n\nif (mask < 0)\n  *tt = 0;\nelse\n  tt += sprintf(CS tt, \"/%d\", mask);\n\nreturn tt - buffer;\n}\n\n\n/* Like host_nmtoa() but: ipv6-only, canonical output, no mask\n\nArguments:\n  binary      points to the ints\n  buffer      big enough to hold the result\n\nReturns:      the number of characters placed in buffer, not counting\n\t      the final nul.\n*/\n\nint\nipv6_nmtoa(int * binary, uschar * buffer)\n{\nint i, j, k;\nuschar * c = buffer;\nuschar * d = NULL;\t/* shut insufficiently \"clever\" compiler up */\n\nfor (i = 0; i < 4; i++)\n  {\t\t\t/* expand to text */\n  j = binary[i];\n  c += sprintf(CS c, \"%x:%x:\", (j >> 16) & 0xffff, j & 0xffff);\n  }\n\nfor (c = buffer, k = -1, i = 0; i < 8; i++)\n  {\t\t\t/* find longest 0-group sequence */\n  if (*c == '0')\t/* must be \"0:\" */\n    {\n    uschar * s = c;\n    j = i;\n    while (c[2] == '0') i++, c += 2;\n    if (i-j > k)\n      {\n      k = i-j;\t\t/* length of sequence */\n      d = s;\t\t/* start of sequence */\n      }\n    }\n  while (*++c != ':') ;\n  c++;\n  }\n\n*--c = '\\0';\t/* drop trailing colon */\n\n/* debug_printf(\"%s: D k %d <%s> <%s>\\n\", __FUNCTION__, k, buffer, buffer + 2*(k+1)); */\nif (k >= 0)\n  {\t\t\t/* collapse */\n  c = d + 2*(k+1);\n  if (d == buffer) c--;\t/* need extra colon */\n  *d++ = ':';\t/* 1st 0 */\n  while ((*d++ = *c++)) ;\n  }\nelse\n  d = c;\n\nreturn d - buffer;\n}\n\n\n\n/*************************************************\n*        Check port for tls_on_connect           *\n*************************************************/\n\n/* This function checks whether a given incoming port is configured for tls-\non-connect. It is called from the daemon and from inetd handling. If the global\noption tls_on_connect is already set, all ports operate this way. Otherwise, we\ncheck the tls_on_connect_ports option for a list of ports.\n\nArgument:  a port number\nReturns:   TRUE or FALSE\n*/\n\nBOOL\nhost_is_tls_on_connect_port(int port)\n{\nint sep = 0;\nconst uschar * list = tls_in.on_connect_ports;\n\nif (tls_in.on_connect) return TRUE;\n\nfor (uschar * s, * end; s = string_nextinlist(&list, &sep, NULL, 0); )\n  if (Ustrtol(s, &end, 10) == port)\n    return TRUE;\n\nreturn FALSE;\n}\n\n\n\n/*************************************************\n*        Check whether host is in a network      *\n*************************************************/\n\n/* This function checks whether a given IP address matches a pattern that\nrepresents either a single host, or a network (using CIDR notation). The caller\nof this function must check the syntax of the arguments before calling it.\n\nArguments:\n  host        string representation of the ip-address to check\n  net         string representation of the network, with optional CIDR mask\n  maskoffset  offset to the / that introduces the mask in the key\n              zero if there is no mask\n\nReturns:\n  TRUE   the host is inside the network\n  FALSE  the host is NOT inside the network\n*/\n\nBOOL\nhost_is_in_net(const uschar *host, const uschar *net, int maskoffset)\n{\nint address[4];\nint incoming[4];\nint mlen;\nint size = host_aton(net, address);\nint insize;\n\n/* No mask => all bits to be checked */\n\nif (maskoffset == 0) mlen = 99999;    /* Big number */\n  else mlen = Uatoi(net + maskoffset + 1);\n\n/* Convert the incoming address to binary. */\n\ninsize = host_aton(host, incoming);\n\n/* Convert IPv4 addresses given in IPv6 compatible mode, which represent\n   connections from IPv4 hosts to IPv6 hosts, that is, addresses of the form\n   ::ffff:<v4address>, to IPv4 format. */\n\nif (insize == 4 && incoming[0] == 0 && incoming[1] == 0 &&\n    incoming[2] == 0xffff)\n  {\n  insize = 1;\n  incoming[0] = incoming[3];\n  }\n\n/* No match if the sizes don't agree. */\n\nif (insize != size) return FALSE;\n\n/* Else do the masked comparison. */\n\nfor (int i = 0; i < size; i++)\n  {\n  int mask;\n  if (mlen == 0) mask = 0;\n  else if (mlen < 32)\n    {\n    mask = (uint)(-1) << (32 - mlen);\n    mlen = 0;\n    }\n  else\n    {\n    mask = -1;\n    mlen -= 32;\n    }\n  if ((incoming[i] & mask) != (address[i] & mask)) return FALSE;\n  }\n\nreturn TRUE;\n}\n\n\n\n/*************************************************\n*       Scan host list for local hosts           *\n*************************************************/\n\n/* Scan through a chain of addresses and check whether any of them is the\naddress of an interface on the local machine. If so, remove that address and\nany previous ones with the same MX value, and all subsequent ones (which will\nhave greater or equal MX values) from the chain. Note: marking them as unusable\nis NOT the right thing to do because it causes the hosts not to be used for\nother domains, for which they may well be correct.\n\nThe hosts may be part of a longer chain; we only process those between the\ninitial pointer and the \"last\" pointer.\n\nThere is also a list of \"pseudo-local\" host names which are checked against the\nhost names. Any match causes that host item to be treated the same as one which\nmatches a local IP address.\n\nIf the very first host is a local host, then all MX records had a precedence\ngreater than or equal to that of the local host. Either there's a problem in\nthe DNS, or an apparently remote name turned out to be an abbreviation for the\nlocal host. Give a specific return code, and let the caller decide what to do.\nOtherwise, give a success code if at least one host address has been found.\n\nArguments:\n  host        pointer to the first host in the chain\n  lastptr     pointer to pointer to the last host in the chain (may be updated)\n  removed     if not NULL, set TRUE if some local addresses were removed\n                from the list\n\nReturns:\n  HOST_FOUND       if there is at least one host with an IP address on the chain\n                     and an MX value less than any MX value associated with the\n                     local host\n  HOST_FOUND_LOCAL if a local host is among the lowest-numbered MX hosts; when\n                     the host addresses were obtained from A records or\n                     gethostbyname(), the MX values are set to -1.\n  HOST_FIND_FAILED if no valid hosts with set IP addresses were found\n*/\n\nint\nhost_scan_for_local_hosts(host_item *host, host_item **lastptr, BOOL *removed)\n{\nint yield = HOST_FIND_FAILED;\nhost_item *last = *lastptr;\nhost_item *prev = NULL;\nhost_item *h;\n\nif (removed != NULL) *removed = FALSE;\n\nif (local_interface_data == NULL) local_interface_data = host_find_interfaces();\n\nfor (h = host; h != last->next; h = h->next)\n  {\n  #ifndef STAND_ALONE\n  if (hosts_treat_as_local != NULL)\n    {\n    int rc;\n    const uschar *save = deliver_domain;\n    deliver_domain = h->name;   /* set $domain */\n    rc = match_isinlist(string_copylc(h->name), CUSS &hosts_treat_as_local, 0,\n      &domainlist_anchor, NULL, MCL_DOMAIN, TRUE, NULL);\n    deliver_domain = save;\n    if (rc == OK) goto FOUND_LOCAL;\n    }\n  #endif\n\n  /* It seems that on many operating systems, 0.0.0.0 is treated as a synonym\n  for 127.0.0.1 and refers to the local host. We therefore force it always to\n  be treated as local. */\n\n  if (h->address != NULL)\n    {\n    if (Ustrcmp(h->address, \"0.0.0.0\") == 0) goto FOUND_LOCAL;\n    for (ip_address_item * ip = local_interface_data; ip; ip = ip->next)\n      if (Ustrcmp(h->address, ip->address) == 0) goto FOUND_LOCAL;\n    yield = HOST_FOUND;  /* At least one remote address has been found */\n    }\n\n  /* Update prev to point to the last host item before any that have\n  the same MX value as the one we have just considered. */\n\n  if (h->next == NULL || h->next->mx != h->mx) prev = h;\n  }\n\nreturn yield;  /* No local hosts found: return HOST_FOUND or HOST_FIND_FAILED */\n\n/* A host whose IP address matches a local IP address, or whose name matches\nsomething in hosts_treat_as_local has been found. */\n\nFOUND_LOCAL:\n\nif (prev == NULL)\n  {\n  HDEBUG(D_host_lookup) debug_printf((h->mx >= 0)?\n    \"local host has lowest MX\\n\" :\n    \"local host found for non-MX address\\n\");\n  return HOST_FOUND_LOCAL;\n  }\n\nHDEBUG(D_host_lookup)\n  {\n  debug_printf(\"local host in host list - removed hosts:\\n\");\n  for (h = prev->next; h != last->next; h = h->next)\n    debug_printf(\"  %s %s %d\\n\", h->name, h->address, h->mx);\n  }\n\nif (removed != NULL) *removed = TRUE;\nprev->next = last->next;\n*lastptr = prev;\nreturn yield;\n}\n\n\n\n\n/*************************************************\n*        Remove duplicate IPs in host list       *\n*************************************************/\n\n/* You would think that administrators could set up their DNS records so that\none ended up with a list of unique IP addresses after looking up A or MX\nrecords, but apparently duplication is common. So we scan such lists and\nremove the later duplicates. Note that we may get lists in which some host\naddresses are not set.\n\nArguments:\n  host        pointer to the first host in the chain\n  lastptr     pointer to pointer to the last host in the chain (may be updated)\n\nReturns:      nothing\n*/\n\nstatic void\nhost_remove_duplicates(host_item *host, host_item **lastptr)\n{\nwhile (host != *lastptr)\n  {\n  if (host->address != NULL)\n    {\n    host_item *h = host;\n    while (h != *lastptr)\n      {\n      if (h->next->address != NULL &&\n          Ustrcmp(h->next->address, host->address) == 0)\n        {\n        DEBUG(D_host_lookup) debug_printf(\"duplicate IP address %s (MX=%d) \"\n          \"removed\\n\", host->address, h->next->mx);\n        if (h->next == *lastptr) *lastptr = h;\n        h->next = h->next->next;\n        }\n      else h = h->next;\n      }\n    }\n  /* If the last item was removed, host may have become == *lastptr */\n  if (host != *lastptr) host = host->next;\n  }\n}\n\n\n\n\n/*************************************************\n*    Find sender host name by gethostbyaddr()    *\n*************************************************/\n\n/* This used to be the only way it was done, but it turns out that not all\nsystems give aliases for calls to gethostbyaddr() - or one of the modern\nequivalents like getipnodebyaddr(). Fortunately, multiple PTR records are rare,\nbut they can still exist. This function is now used only when a DNS lookup of\nthe IP address fails, in order to give access to /etc/hosts.\n\nArguments:   none\nReturns:     OK, DEFER, FAIL\n*/\n\nstatic int\nhost_name_lookup_byaddr(void)\n{\nstruct hostent * hosts;\nstruct in_addr addr;\nunsigned long time_msec = 0;\t/* init to quieten dumb static analysis */\n\nif (slow_lookup_log) time_msec = get_time_in_ms();\n\n/* Lookup on IPv6 system */\n\n#if HAVE_IPV6\nif (Ustrchr(sender_host_address, ':') != NULL)\n  {\n  struct in6_addr addr6;\n  if (inet_pton(AF_INET6, CS sender_host_address, &addr6) != 1)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"unable to parse \\\"%s\\\" as an \"\n      \"IPv6 address\", sender_host_address);\n  #if HAVE_GETIPNODEBYADDR\n  hosts = getipnodebyaddr(CS &addr6, sizeof(addr6), AF_INET6, &h_errno);\n  #else\n  hosts = gethostbyaddr(CS &addr6, sizeof(addr6), AF_INET6);\n  #endif\n  }\nelse\n  {\n  if (inet_pton(AF_INET, CS sender_host_address, &addr) != 1)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"unable to parse \\\"%s\\\" as an \"\n      \"IPv4 address\", sender_host_address);\n  #if HAVE_GETIPNODEBYADDR\n  hosts = getipnodebyaddr(CS &addr, sizeof(addr), AF_INET, &h_errno);\n  #else\n  hosts = gethostbyaddr(CS &addr, sizeof(addr), AF_INET);\n  #endif\n  }\n\n/* Do lookup on IPv4 system */\n\n#else\naddr.s_addr = (S_ADDR_TYPE)inet_addr(CS sender_host_address);\nhosts = gethostbyaddr(CS(&addr), sizeof(addr), AF_INET);\n#endif\n\nif (  slow_lookup_log\n   && (time_msec = get_time_in_ms() - time_msec) > slow_lookup_log\n   )\n  log_long_lookup(US\"gethostbyaddr\", sender_host_address, time_msec);\n\n/* Failed to look up the host. */\n\nif (!hosts)\n  {\n  HDEBUG(D_host_lookup) debug_printf(\"IP address lookup failed: h_errno=%d\\n\",\n    h_errno);\n  return (h_errno == TRY_AGAIN || h_errno == NO_RECOVERY) ? DEFER : FAIL;\n  }\n\n/* It seems there are some records in the DNS that yield an empty name. We\ntreat this as non-existent. In some operating systems, this is returned as an\nempty string; in others as a single dot. */\n\nif (!hosts->h_name || !hosts->h_name[0] || hosts->h_name[0] == '.')\n  {\n  HDEBUG(D_host_lookup) debug_printf(\"IP address lookup yielded an empty name: \"\n    \"treated as non-existent host name\\n\");\n  return FAIL;\n  }\n\n/* Copy and lowercase the name, which is in static storage in many systems.\nPut it in permanent memory. */\n\n  {\n  int old_pool = store_pool;\n  store_pool = POOL_TAINT_PERM;\t\t/* names are tainted */\n\n  sender_host_name = string_copylc(US hosts->h_name);\n\n  /* If the host has aliases, build a copy of the alias list */\n\n  if (hosts->h_aliases)\n    {\n    int count = 1;\n    uschar **ptr;\n\n    for (uschar ** aliases = USS hosts->h_aliases; *aliases; aliases++) count++;\n    store_pool = POOL_PERM;\n    ptr = sender_host_aliases = store_get(count * sizeof(uschar *), FALSE);\n    store_pool = POOL_TAINT_PERM;\n\n    for (uschar ** aliases = USS hosts->h_aliases; *aliases; aliases++)\n      *ptr++ = string_copylc(*aliases);\n    *ptr = NULL;\n    }\n  store_pool = old_pool;\n  }\n\nreturn OK;\n}\n\n\n\n/*************************************************\n*        Find host name for incoming call        *\n*************************************************/\n\n/* Put the name in permanent store, pointed to by sender_host_name. We also set\nup a list of alias names, pointed to by sender_host_alias. The list is\nNULL-terminated. The incoming address is in sender_host_address, either in\ndotted-quad form for IPv4 or in colon-separated form for IPv6.\n\nThis function does a thorough check that the names it finds point back to the\nincoming IP address. Any that do not are discarded. Note that this is relied on\nby the ACL reverse_host_lookup check.\n\nOn some systems, get{host,ipnode}byaddr() appears to do this internally, but\nthis it not universally true. Also, for release 4.30, this function was changed\nto do a direct DNS lookup first, by default[1], because it turns out that that\nis the only guaranteed way to find all the aliases on some systems. My\nexperiments indicate that Solaris gethostbyaddr() gives the aliases for but\nLinux does not.\n\n[1] The actual order is controlled by the host_lookup_order option.\n\nArguments:    none\nReturns:      OK on success, the answer being placed in the global variable\n                sender_host_name, with any aliases in a list hung off\n                sender_host_aliases\n              FAIL if no host name can be found\n              DEFER if a temporary error was encountered\n\nThe variable host_lookup_msg is set to an empty string on success, or to a\nreason for the failure otherwise, in a form suitable for tagging onto an error\nmessage, and also host_lookup_failed is set TRUE if the lookup failed. If there\nwas a defer, host_lookup_deferred is set TRUE.\n\nAny dynamically constructed string for host_lookup_msg must be in permanent\nstore, because it might be used for several incoming messages on the same SMTP\nconnection. */\n\nint\nhost_name_lookup(void)\n{\nint old_pool, rc;\nint sep = 0;\nuschar *save_hostname;\nuschar **aliases;\nuschar *ordername;\nconst uschar *list = host_lookup_order;\ndns_answer * dnsa = store_get_dns_answer();\ndns_scan dnss;\n\nsender_host_dnssec = host_lookup_deferred = host_lookup_failed = FALSE;\n\nHDEBUG(D_host_lookup)\n  debug_printf(\"looking up host name for %s\\n\", sender_host_address);\n\n/* For testing the case when a lookup does not complete, we have a special\nreserved IP address. */\n\nif (f.running_in_test_harness &&\n    Ustrcmp(sender_host_address, \"99.99.99.99\") == 0)\n  {\n  HDEBUG(D_host_lookup)\n    debug_printf(\"Test harness: host name lookup returns DEFER\\n\");\n  host_lookup_deferred = TRUE;\n  return DEFER;\n  }\n\n/* Do lookups directly in the DNS or via gethostbyaddr() (or equivalent), in\nthe order specified by the host_lookup_order option. */\n\nwhile ((ordername = string_nextinlist(&list, &sep, NULL, 0)))\n  {\n  if (strcmpic(ordername, US\"bydns\") == 0)\n    {\n    uschar * name = dns_build_reverse(sender_host_address);\n\n    dns_init(FALSE, FALSE, FALSE);    /* dnssec ctrl by dns_dnssec_ok glbl */\n    rc = dns_lookup_timerwrap(dnsa, name, T_PTR, NULL);\n\n    /* The first record we come across is used for the name; others are\n    considered to be aliases. We have to scan twice, in order to find out the\n    number of aliases. However, if all the names are empty, we will behave as\n    if failure. (PTR records that yield empty names have been encountered in\n    the DNS.) */\n\n    if (rc == DNS_SUCCEED)\n      {\n      uschar **aptr = NULL;\n      int ssize = 264;\n      int count = 0;\n      int old_pool = store_pool;\n\n      sender_host_dnssec = dns_is_secure(dnsa);\n      DEBUG(D_dns)\n        debug_printf(\"Reverse DNS security status: %s\\n\",\n            sender_host_dnssec ? \"DNSSEC verified (AD)\" : \"unverified\");\n\n      store_pool = POOL_PERM;        /* Save names in permanent storage */\n\n      for (dns_record * rr = dns_next_rr(dnsa, &dnss, RESET_ANSWERS);\n           rr;\n           rr = dns_next_rr(dnsa, &dnss, RESET_NEXT)) if (rr->type == T_PTR)\n\tcount++;\n\n      /* Get store for the list of aliases. For compatibility with\n      gethostbyaddr, we make an empty list if there are none. */\n\n      aptr = sender_host_aliases = store_get(count * sizeof(uschar *), FALSE);\n\n      /* Re-scan and extract the names */\n\n      for (dns_record * rr = dns_next_rr(dnsa, &dnss, RESET_ANSWERS);\n           rr;\n           rr = dns_next_rr(dnsa, &dnss, RESET_NEXT)) if (rr->type == T_PTR)\n        {\n        uschar * s = store_get(ssize, TRUE);\t/* names are tainted */\n\n        /* If an overlong response was received, the data will have been\n        truncated and dn_expand may fail. */\n\n        if (dn_expand(dnsa->answer, dnsa->answer + dnsa->answerlen,\n             US (rr->data), (DN_EXPAND_ARG4_TYPE)(s), ssize) < 0)\n          {\n          log_write(0, LOG_MAIN, \"host name alias list truncated for %s\",\n            sender_host_address);\n          break;\n          }\n\n        store_release_above(s + Ustrlen(s) + 1);\n        if (!s[0])\n          {\n          HDEBUG(D_host_lookup) debug_printf(\"IP address lookup yielded an \"\n            \"empty name: treated as non-existent host name\\n\");\n          continue;\n          }\n        if (!sender_host_name) sender_host_name = s;\n\telse *aptr++ = s;\n        while (*s) { *s = tolower(*s); s++; }\n        }\n\n      *aptr = NULL;            /* End of alias list */\n      store_pool = old_pool;   /* Reset store pool */\n\n      /* If we've found a name, break out of the \"order\" loop */\n\n      if (sender_host_name) break;\n      }\n\n    /* If the DNS lookup deferred, we must also defer. */\n\n    if (rc == DNS_AGAIN)\n      {\n      HDEBUG(D_host_lookup)\n        debug_printf(\"IP address PTR lookup gave temporary error\\n\");\n      host_lookup_deferred = TRUE;\n      return DEFER;\n      }\n    }\n\n  /* Do a lookup using gethostbyaddr() - or equivalent */\n\n  else if (strcmpic(ordername, US\"byaddr\") == 0)\n    {\n    HDEBUG(D_host_lookup)\n      debug_printf(\"IP address lookup using gethostbyaddr()\\n\");\n    rc = host_name_lookup_byaddr();\n    if (rc == DEFER)\n      {\n      host_lookup_deferred = TRUE;\n      return rc;                       /* Can't carry on */\n      }\n    if (rc == OK) break;               /* Found a name */\n    }\n  }      /* Loop for bydns/byaddr scanning */\n\n/* If we have failed to find a name, return FAIL and log when required.\nNB host_lookup_msg must be in permanent store.  */\n\nif (!sender_host_name)\n  {\n  if (host_checking || !f.log_testing_mode)\n    log_write(L_host_lookup_failed, LOG_MAIN, \"no host name found for IP \"\n      \"address %s\", sender_host_address);\n  host_lookup_msg = US\" (failed to find host name from IP address)\";\n  host_lookup_failed = TRUE;\n  return FAIL;\n  }\n\nHDEBUG(D_host_lookup)\n  {\n  uschar **aliases = sender_host_aliases;\n  debug_printf(\"IP address lookup yielded \\\"%s\\\"\\n\", sender_host_name);\n  while (*aliases != NULL) debug_printf(\"  alias \\\"%s\\\"\\n\", *aliases++);\n  }\n\n/* We need to verify that a forward lookup on the name we found does indeed\ncorrespond to the address. This is for security: in principle a malefactor who\nhappened to own a reverse zone could set it to point to any names at all.\n\nThis code was present in versions of Exim before 3.20. At that point I took it\nout because I thought that gethostbyaddr() did the check anyway. It turns out\nthat this isn't always the case, so it's coming back in at 4.01. This version\nis actually better, because it also checks aliases.\n\nThe code was made more robust at release 4.21. Prior to that, it accepted all\nthe names if any of them had the correct IP address. Now the code checks all\nthe names, and accepts only those that have the correct IP address. */\n\nsave_hostname = sender_host_name;   /* Save for error messages */\naliases = sender_host_aliases;\nfor (uschar * hname = sender_host_name; hname; hname = *aliases++)\n  {\n  int rc;\n  BOOL ok = FALSE;\n  host_item h = { .next = NULL, .name = hname, .mx = MX_NONE, .address = NULL };\n  dnssec_domains d =\n    { .request = sender_host_dnssec ? US\"*\" : NULL, .require = NULL };\n\n  if (  (rc = host_find_bydns(&h, NULL, HOST_FIND_BY_A | HOST_FIND_BY_AAAA,\n\t  NULL, NULL, NULL, &d, NULL, NULL)) == HOST_FOUND\n     || rc == HOST_FOUND_LOCAL\n     )\n    {\n    HDEBUG(D_host_lookup) debug_printf(\"checking addresses for %s\\n\", hname);\n\n    /* If the forward lookup was not secure we cancel the is-secure variable */\n\n    DEBUG(D_dns) debug_printf(\"Forward DNS security status: %s\\n\",\n\t  h.dnssec == DS_YES ? \"DNSSEC verified (AD)\" : \"unverified\");\n    if (h.dnssec != DS_YES) sender_host_dnssec = FALSE;\n\n    for (host_item * hh = &h; hh; hh = hh->next)\n      if (host_is_in_net(hh->address, sender_host_address, 0))\n        {\n        HDEBUG(D_host_lookup) debug_printf(\"  %s OK\\n\", hh->address);\n        ok = TRUE;\n        break;\n        }\n      else\n        HDEBUG(D_host_lookup) debug_printf(\"  %s\\n\", hh->address);\n\n    if (!ok) HDEBUG(D_host_lookup)\n      debug_printf(\"no IP address for %s matched %s\\n\", hname,\n        sender_host_address);\n    }\n  else if (rc == HOST_FIND_AGAIN)\n    {\n    HDEBUG(D_host_lookup) debug_printf(\"temporary error for host name lookup\\n\");\n    host_lookup_deferred = TRUE;\n    sender_host_name = NULL;\n    return DEFER;\n    }\n  else\n    HDEBUG(D_host_lookup) debug_printf(\"no IP addresses found for %s\\n\", hname);\n\n  /* If this name is no good, and it's the sender name, set it null pro tem;\n  if it's an alias, just remove it from the list. */\n\n  if (!ok)\n    {\n    if (hname == sender_host_name) sender_host_name = NULL; else\n      {\n      uschar **a;                              /* Don't amalgamate - some */\n      a = --aliases;                           /* compilers grumble */\n      while (*a != NULL) { *a = a[1]; a++; }\n      }\n    }\n  }\n\n/* If sender_host_name == NULL, it means we didn't like the name. Replace\nit with the first alias, if there is one. */\n\nif (sender_host_name == NULL && *sender_host_aliases != NULL)\n  sender_host_name = *sender_host_aliases++;\n\n/* If we now have a main name, all is well. */\n\nif (sender_host_name != NULL) return OK;\n\n/* We have failed to find an address that matches. */\n\nHDEBUG(D_host_lookup)\n  debug_printf(\"%s does not match any IP address for %s\\n\",\n    sender_host_address, save_hostname);\n\n/* This message must be in permanent store */\n\nold_pool = store_pool;\nstore_pool = POOL_PERM;\nhost_lookup_msg = string_sprintf(\" (%s does not match any IP address for %s)\",\n  sender_host_address, save_hostname);\nstore_pool = old_pool;\nhost_lookup_failed = TRUE;\nreturn FAIL;\n}\n\n\n\n\n/*************************************************\n*    Find IP address(es) for host by name        *\n*************************************************/\n\n/* The input is a host_item structure with the name filled in and the address\nfield set to NULL. We use gethostbyname() or getipnodebyname() or\ngethostbyname2(), as appropriate. Of course, these functions may use the DNS,\nbut they do not do MX processing. It appears, however, that in some systems the\ncurrent setting of resolver options is used when one of these functions calls\nthe resolver. For this reason, we call dns_init() at the start, with arguments\ninfluenced by bits in \"flags\", just as we do for host_find_bydns().\n\nThe second argument provides a host list (usually an IP list) of hosts to\nignore. This makes it possible to ignore IPv6 link-local addresses or loopback\naddresses in unreasonable places.\n\nThe lookup may result in a change of name. For compatibility with the dns\nlookup, return this via fully_qualified_name as well as updating the host item.\nThe lookup may also yield more than one IP address, in which case chain on\nsubsequent host_item structures.\n\nArguments:\n  host                   a host item with the name and MX filled in;\n                           the address is to be filled in;\n                           multiple IP addresses cause other host items to be\n                             chained on.\n  ignore_target_hosts    a list of hosts to ignore\n  flags                  HOST_FIND_QUALIFY_SINGLE   ) passed to\n                         HOST_FIND_SEARCH_PARENTS   )   dns_init()\n  fully_qualified_name   if not NULL, set to point to host name for\n                         compatibility with host_find_bydns\n  local_host_check       TRUE if a check for the local host is wanted\n\nReturns:                 HOST_FIND_FAILED  Failed to find the host or domain\n                         HOST_FIND_AGAIN   Try again later\n                         HOST_FOUND        Host found - data filled in\n                         HOST_FOUND_LOCAL  Host found and is the local host\n*/\n\nint\nhost_find_byname(host_item *host, const uschar *ignore_target_hosts, int flags,\n  const uschar **fully_qualified_name, BOOL local_host_check)\n{\nint yield, times;\nhost_item *last = NULL;\nBOOL temp_error = FALSE;\nint af;\n\n#ifndef DISABLE_TLS\n/* Copy the host name at this point to the value which is used for\nTLS certificate name checking, before anything modifies it.  */\n\nhost->certname = host->name;\n#endif\n\n/* Make sure DNS options are set as required. This appears to be necessary in\nsome circumstances when the get..byname() function actually calls the DNS. */\n\ndns_init((flags & HOST_FIND_QUALIFY_SINGLE) != 0,\n         (flags & HOST_FIND_SEARCH_PARENTS) != 0,\n\t FALSE);\t\t/* Cannot retrieve dnssec status so do not request */\n\n/* In an IPv6 world, unless IPv6 has been disabled, we need to scan for both\nkinds of address, so go round the loop twice. Note that we have ensured that\nAF_INET6 is defined even in an IPv4 world, which makes for slightly tidier\ncode. However, if dns_ipv4_lookup matches the domain, we also just do IPv4\nlookups here (except when testing standalone). */\n\n#if HAVE_IPV6\n  #ifdef STAND_ALONE\n  if (disable_ipv6)\n  #else\n  if (  disable_ipv6\n     ||    dns_ipv4_lookup\n\t&& match_isinlist(host->name, CUSS &dns_ipv4_lookup, 0,\n\t    &domainlist_anchor, NULL, MCL_DOMAIN, TRUE, NULL) == OK)\n  #endif\n\n    { af = AF_INET; times = 1; }\n  else\n    { af = AF_INET6; times = 2; }\n\n/* No IPv6 support */\n\n#else   /* HAVE_IPV6 */\n  af = AF_INET; times = 1;\n#endif  /* HAVE_IPV6 */\n\n/* Initialize the flag that gets set for DNS syntax check errors, so that the\ninterface to this function can be similar to host_find_bydns. */\n\nf.host_find_failed_syntax = FALSE;\n\n/* Loop to look up both kinds of address in an IPv6 world */\n\nfor (int i = 1; i <= times;\n     #if HAVE_IPV6\n       af = AF_INET,     /* If 2 passes, IPv4 on the second */\n     #endif\n     i++)\n  {\n  BOOL ipv4_addr;\n  int error_num = 0;\n  struct hostent *hostdata;\n  unsigned long time_msec = 0;\t/* compiler quietening */\n\n  #ifdef STAND_ALONE\n  printf(\"Looking up: %s\\n\", host->name);\n  #endif\n\n  if (slow_lookup_log) time_msec = get_time_in_ms();\n\n  #if HAVE_IPV6\n  if (f.running_in_test_harness)\n    hostdata = host_fake_gethostbyname(host->name, af, &error_num);\n  else\n    {\n    #if HAVE_GETIPNODEBYNAME\n    hostdata = getipnodebyname(CS host->name, af, 0, &error_num);\n    #else\n    hostdata = gethostbyname2(CS host->name, af);\n    error_num = h_errno;\n    #endif\n    }\n\n  #else    /* not HAVE_IPV6 */\n  if (f.running_in_test_harness)\n    hostdata = host_fake_gethostbyname(host->name, af, &error_num);\n  else\n    {\n    hostdata = gethostbyname(CS host->name);\n    error_num = h_errno;\n    }\n  #endif   /* HAVE_IPV6 */\n\n  if (   slow_lookup_log\n      && (time_msec = get_time_in_ms() - time_msec) > slow_lookup_log)\n    log_long_lookup(US\"gethostbyname\", host->name, time_msec);\n\n  if (!hostdata)\n    {\n    uschar * error;\n    switch (error_num)\n      {\n      case HOST_NOT_FOUND: error = US\"HOST_NOT_FOUND\";\tbreak;\n      case TRY_AGAIN:      error = US\"TRY_AGAIN\";   temp_error = TRUE; break;\n      case NO_RECOVERY:    error = US\"NO_RECOVERY\"; temp_error = TRUE; break;\n      case NO_DATA:        error = US\"NO_DATA\";\t\tbreak;\n    #if NO_DATA != NO_ADDRESS\n      case NO_ADDRESS:     error = US\"NO_ADDRESS\";\tbreak;\n    #endif\n      default: error = US\"?\"; break;\n      }\n\n    DEBUG(D_host_lookup) debug_printf(\"%s(af=%s) returned %d (%s)\\n\",\n      f.running_in_test_harness ? \"host_fake_gethostbyname\" :\n#if HAVE_IPV6\n# if HAVE_GETIPNODEBYNAME\n        \"getipnodebyname\",\n# else\n        \"gethostbyname2\",\n# endif\n#else\n\t\"gethostbyname\",\n#endif\n      af == AF_INET ? \"inet\" : \"inet6\", error_num, error);\n\n    continue;\n    }\n  if (!(hostdata->h_addr_list)[0]) continue;\n\n  /* Replace the name with the fully qualified one if necessary, and fill in\n  the fully_qualified_name pointer. */\n\n  if (hostdata->h_name[0] && Ustrcmp(host->name, hostdata->h_name) != 0)\n    host->name = string_copy_dnsdomain(US hostdata->h_name);\n  if (fully_qualified_name) *fully_qualified_name = host->name;\n\n  /* Get the list of addresses. IPv4 and IPv6 addresses can be distinguished\n  by their different lengths. Scan the list, ignoring any that are to be\n  ignored, and build a chain from the rest. */\n\n  ipv4_addr = hostdata->h_length == sizeof(struct in_addr);\n\n  for (uschar ** addrlist = USS hostdata->h_addr_list; *addrlist; addrlist++)\n    {\n    uschar *text_address =\n      host_ntoa(ipv4_addr? AF_INET:AF_INET6, *addrlist, NULL, NULL);\n\n    #ifndef STAND_ALONE\n    if (  ignore_target_hosts\n       && verify_check_this_host(&ignore_target_hosts, NULL, host->name,\n\t    text_address, NULL) == OK)\n      {\n      DEBUG(D_host_lookup)\n        debug_printf(\"ignored host %s [%s]\\n\", host->name, text_address);\n      continue;\n      }\n    #endif\n\n    /* If this is the first address, last is NULL and we put the data in the\n    original block. */\n\n    if (!last)\n      {\n      host->address = text_address;\n      host->port = PORT_NONE;\n      host->status = hstatus_unknown;\n      host->why = hwhy_unknown;\n      host->dnssec = DS_UNK;\n      last = host;\n      }\n\n    /* Else add further host item blocks for any other addresses, keeping\n    the order. */\n\n    else\n      {\n      host_item *next = store_get(sizeof(host_item), FALSE);\n      next->name = host->name;\n#ifndef DISABLE_TLS\n      next->certname = host->certname;\n#endif\n      next->mx = host->mx;\n      next->address = text_address;\n      next->port = PORT_NONE;\n      next->status = hstatus_unknown;\n      next->why = hwhy_unknown;\n      next->dnssec = DS_UNK;\n      next->last_try = 0;\n      next->next = last->next;\n      last->next = next;\n      last = next;\n      }\n    }\n  }\n\n/* If no hosts were found, the address field in the original host block will be\nNULL. If temp_error is set, at least one of the lookups gave a temporary error,\nso we pass that back. */\n\nif (!host->address)\n  {\n  uschar *msg =\n    #ifndef STAND_ALONE\n    !message_id[0] && smtp_in\n      ? string_sprintf(\"no IP address found for host %s (during %s)\", host->name,\n          smtp_get_connection_info()) :\n    #endif\n    string_sprintf(\"no IP address found for host %s\", host->name);\n\n  HDEBUG(D_host_lookup) debug_printf(\"%s\\n\", msg);\n  if (temp_error) goto RETURN_AGAIN;\n  if (host_checking || !f.log_testing_mode)\n    log_write(L_host_lookup_failed, LOG_MAIN, \"%s\", msg);\n  return HOST_FIND_FAILED;\n  }\n\n/* Remove any duplicate IP addresses, then check to see if this is the local\nhost if required. */\n\nhost_remove_duplicates(host, &last);\nyield = local_host_check?\n  host_scan_for_local_hosts(host, &last, NULL) : HOST_FOUND;\n\nHDEBUG(D_host_lookup)\n  {\n  if (fully_qualified_name)\n    debug_printf(\"fully qualified name = %s\\n\", *fully_qualified_name);\n  debug_printf(\"%s looked up these IP addresses:\\n\",\n    #if HAVE_IPV6\n      #if HAVE_GETIPNODEBYNAME\n      \"getipnodebyname\"\n      #else\n      \"gethostbyname2\"\n      #endif\n    #else\n    \"gethostbyname\"\n    #endif\n    );\n  for (const host_item * h = host; h != last->next; h = h->next)\n    debug_printf(\"  name=%s address=%s\\n\", h->name,\n      h->address ? h->address : US\"<null>\");\n  }\n\n/* Return the found status. */\n\nreturn yield;\n\n/* Handle the case when there is a temporary error. If the name matches\ndns_again_means_nonexist, return permanent rather than temporary failure. */\n\nRETURN_AGAIN:\n  {\n#ifndef STAND_ALONE\n  int rc;\n  const uschar *save = deliver_domain;\n  deliver_domain = host->name;  /* set $domain */\n  rc = match_isinlist(host->name, CUSS &dns_again_means_nonexist, 0,\n    &domainlist_anchor, NULL, MCL_DOMAIN, TRUE, NULL);\n  deliver_domain = save;\n  if (rc == OK)\n    {\n    DEBUG(D_host_lookup) debug_printf(\"%s is in dns_again_means_nonexist: \"\n      \"returning HOST_FIND_FAILED\\n\", host->name);\n    return HOST_FIND_FAILED;\n    }\n#endif\n  return HOST_FIND_AGAIN;\n  }\n}\n\n\n\n/*************************************************\n*        Fill in a host address from the DNS     *\n*************************************************/\n\n/* Given a host item, with its name, port and mx fields set, and its address\nfield set to NULL, fill in its IP address from the DNS. If it is multi-homed,\ncreate additional host items for the additional addresses, copying all the\nother fields, and randomizing the order.\n\nOn IPv6 systems, AAAA records are sought first, then A records.\n\nThe host name may be changed if the DNS returns a different name - e.g. fully\nqualified or changed via CNAME. If fully_qualified_name is not NULL, dns_lookup\nensures that it points to the fully qualified name. However, this is the fully\nqualified version of the original name; if a CNAME is involved, the actual\ncanonical host name may be different again, and so we get it directly from the\nrelevant RR. Note that we do NOT change the mx field of the host item in this\nfunction as it may be called to set the addresses of hosts taken from MX\nrecords.\n\nArguments:\n  host                  points to the host item we're filling in\n  lastptr               points to pointer to last host item in a chain of\n                          host items (may be updated if host is last and gets\n                          extended because multihomed)\n  ignore_target_hosts   list of hosts to ignore\n  allow_ip              if TRUE, recognize an IP address and return it\n  fully_qualified_name  if not NULL, return fully qualified name here if\n                          the contents are different (i.e. it must be preset\n                          to something)\n  dnssec_request\tif TRUE request the AD bit\n  dnssec_require\tif TRUE require the AD bit\n  whichrrs\t\tselect ipv4, ipv6 results\n\nReturns:       HOST_FIND_FAILED     couldn't find A record\n               HOST_FIND_AGAIN      try again later\n\t       HOST_FIND_SECURITY   dnssec required but not acheived\n               HOST_FOUND           found AAAA and/or A record(s)\n               HOST_IGNORED         found, but all IPs ignored\n*/\n\nstatic int\nset_address_from_dns(host_item *host, host_item **lastptr,\n  const uschar *ignore_target_hosts, BOOL allow_ip,\n  const uschar **fully_qualified_name,\n  BOOL dnssec_request, BOOL dnssec_require, int whichrrs)\n{\nhost_item *thishostlast = NULL;    /* Indicates not yet filled in anything */\nBOOL v6_find_again = FALSE;\nBOOL dnssec_fail = FALSE;\nint i;\ndns_answer * dnsa;\n\n#ifndef DISABLE_TLS\n/* Copy the host name at this point to the value which is used for\nTLS certificate name checking, before any CNAME-following modifies it.  */\n\nhost->certname = host->name;\n#endif\n\n/* If allow_ip is set, a name which is an IP address returns that value\nas its address. This is used for MX records when allow_mx_to_ip is set, for\nthose sites that feel they have to flaunt the RFC rules. */\n\nif (allow_ip && string_is_ip_address(host->name, NULL) != 0)\n  {\n  #ifndef STAND_ALONE\n  if (  ignore_target_hosts\n     && verify_check_this_host(&ignore_target_hosts, NULL, host->name,\n        host->name, NULL) == OK)\n    return HOST_IGNORED;\n  #endif\n\n  host->address = host->name;\n  return HOST_FOUND;\n  }\n\ndnsa = store_get_dns_answer();\n\n/* On an IPv6 system, unless IPv6 is disabled, go round the loop up to twice,\nlooking for AAAA records the first time. However, unless doing standalone\ntesting, we force an IPv4 lookup if the domain matches dns_ipv4_lookup global.\nOn an IPv4 system, go round the loop once only, looking only for A records. */\n\n#if HAVE_IPV6\n  #ifndef STAND_ALONE\n    if (  disable_ipv6\n       || !(whichrrs & HOST_FIND_BY_AAAA)\n       ||    dns_ipv4_lookup\n          && match_isinlist(host->name, CUSS &dns_ipv4_lookup, 0,\n\t      &domainlist_anchor, NULL, MCL_DOMAIN, TRUE, NULL) == OK\n       )\n      i = 0;    /* look up A records only */\n    else\n  #endif        /* STAND_ALONE */\n\n  i = 1;        /* look up AAAA and A records */\n\n/* The IPv4 world */\n\n#else           /* HAVE_IPV6 */\n  i = 0;        /* look up A records only */\n#endif          /* HAVE_IPV6 */\n\nfor (; i >= 0; i--)\n  {\n  static int types[] = { T_A, T_AAAA };\n  int type = types[i];\n  int randoffset = i == (whichrrs & HOST_FIND_IPV4_FIRST ? 1 : 0)\n    ? 500 : 0;  /* Ensures v6/4 sort order */\n  dns_scan dnss;\n\n  int rc = dns_lookup_timerwrap(dnsa, host->name, type, fully_qualified_name);\n  lookup_dnssec_authenticated = !dnssec_request ? NULL\n    : dns_is_secure(dnsa) ? US\"yes\" : US\"no\";\n\n  DEBUG(D_dns)\n    if (  (dnssec_request || dnssec_require)\n       && !dns_is_secure(dnsa)\n       && dns_is_aa(dnsa)\n       )\n      debug_printf(\"DNS lookup of %.256s (A/AAAA) requested AD, but got AA\\n\", host->name);\n\n  /* We want to return HOST_FIND_AGAIN if one of the A or AAAA lookups\n  fails or times out, but not if another one succeeds. (In the early\n  IPv6 days there are name servers that always fail on AAAA, but are happy\n  to give out an A record. We want to proceed with that A record.) */\n\n  if (rc != DNS_SUCCEED)\n    {\n    if (i == 0)  /* Just tried for an A record, i.e. end of loop */\n      {\n      if (host->address != NULL)\n        i = HOST_FOUND;  /* AAAA was found */\n      else if (rc == DNS_AGAIN || rc == DNS_FAIL || v6_find_again)\n        i = HOST_FIND_AGAIN;\n      else\n\ti = HOST_FIND_FAILED;    /* DNS_NOMATCH or DNS_NODATA */\n      goto out;\n      }\n\n    /* Tried for an AAAA record: remember if this was a temporary\n    error, and look for the next record type. */\n\n    if (rc != DNS_NOMATCH && rc != DNS_NODATA) v6_find_again = TRUE;\n    continue;\n    }\n\n  if (dnssec_request)\n    {\n    if (dns_is_secure(dnsa))\n      {\n      DEBUG(D_host_lookup) debug_printf(\"%s A DNSSEC\\n\", host->name);\n      if (host->dnssec == DS_UNK) /* set in host_find_bydns() */\n\thost->dnssec = DS_YES;\n      }\n    else\n      {\n      if (dnssec_require)\n\t{\n\tdnssec_fail = TRUE;\n\tDEBUG(D_host_lookup) debug_printf(\"dnssec fail on %s for %.256s\",\n\t\ti>0 ? \"AAAA\" : \"A\", host->name);\n\tcontinue;\n\t}\n      if (host->dnssec == DS_YES) /* set in host_find_bydns() */\n\t{\n\tDEBUG(D_host_lookup) debug_printf(\"%s A cancel DNSSEC\\n\", host->name);\n\thost->dnssec = DS_NO;\n\tlookup_dnssec_authenticated = US\"no\";\n\t}\n      }\n    }\n\n  /* Lookup succeeded: fill in the given host item with the first non-ignored\n  address found; create additional items for any others. A single A6 record\n  may generate more than one address.  The lookup had a chance to update the\n  fqdn; we do not want any later times round the loop to do so. */\n\n  fully_qualified_name = NULL;\n\n  for (dns_record * rr = dns_next_rr(dnsa, &dnss, RESET_ANSWERS);\n       rr;\n       rr = dns_next_rr(dnsa, &dnss, RESET_NEXT)) if (rr->type == type)\n    {\n    dns_address * da = dns_address_from_rr(dnsa, rr);\n\n    DEBUG(D_host_lookup)\n      if (!da) debug_printf(\"no addresses extracted from A6 RR for %s\\n\",\n\t  host->name);\n\n    /* This loop runs only once for A and AAAA records, but may run\n    several times for an A6 record that generated multiple addresses. */\n\n    for (; da; da = da->next)\n      {\n      #ifndef STAND_ALONE\n      if (ignore_target_hosts != NULL &&\n\t    verify_check_this_host(&ignore_target_hosts, NULL,\n\t      host->name, da->address, NULL) == OK)\n\t{\n\tDEBUG(D_host_lookup)\n\t  debug_printf(\"ignored host %s [%s]\\n\", host->name, da->address);\n\tcontinue;\n\t}\n      #endif\n\n      /* If this is the first address, stick it in the given host block,\n      and change the name if the returned RR has a different name. */\n\n      if (thishostlast == NULL)\n\t{\n\tif (strcmpic(host->name, rr->name) != 0)\n\t  host->name = string_copy_dnsdomain(rr->name);\n\thost->address = da->address;\n\thost->sort_key = host->mx * 1000 + random_number(500) + randoffset;\n\thost->status = hstatus_unknown;\n\thost->why = hwhy_unknown;\n\tthishostlast = host;\n\t}\n\n      /* Not the first address. Check for, and ignore, duplicates. Then\n      insert in the chain at a random point. */\n\n      else\n\t{\n\tint new_sort_key;\n\thost_item *next;\n\n\t/* End of our local chain is specified by \"thishostlast\". */\n\n\tfor (next = host;; next = next->next)\n\t  {\n\t  if (Ustrcmp(CS da->address, next->address) == 0) break;\n\t  if (next == thishostlast) { next = NULL; break; }\n\t  }\n\tif (next != NULL) continue;  /* With loop for next address */\n\n\t/* Not a duplicate */\n\n\tnew_sort_key = host->mx * 1000 + random_number(500) + randoffset;\n\tnext = store_get(sizeof(host_item), FALSE);\n\n\t/* New address goes first: insert the new block after the first one\n\t(so as not to disturb the original pointer) but put the new address\n\tin the original block. */\n\n\tif (new_sort_key < host->sort_key)\n\t  {\n\t  *next = *host;                                  /* Copies port */\n\t  host->next = next;\n\t  host->address = da->address;\n\t  host->sort_key = new_sort_key;\n\t  if (thishostlast == host) thishostlast = next;  /* Local last */\n\t  if (*lastptr == host) *lastptr = next;          /* Global last */\n\t  }\n\n\t/* Otherwise scan down the addresses for this host to find the\n\tone to insert after. */\n\n\telse\n\t  {\n\t  host_item *h = host;\n\t  while (h != thishostlast)\n\t    {\n\t    if (new_sort_key < h->next->sort_key) break;\n\t    h = h->next;\n\t    }\n\t  *next = *h;                                 /* Copies port */\n\t  h->next = next;\n\t  next->address = da->address;\n\t  next->sort_key = new_sort_key;\n\t  if (h == thishostlast) thishostlast = next; /* Local last */\n\t  if (h == *lastptr) *lastptr = next;         /* Global last */\n\t  }\n\t}\n      }\n    }\n  }\n\n/* Control gets here only if the second lookup (the A record) succeeded.\nHowever, the address may not be filled in if it was ignored. */\n\ni = host->address\n  ? HOST_FOUND\n  : dnssec_fail\n  ? HOST_FIND_SECURITY\n  : HOST_IGNORED;\n\nout:\n  store_free_dns_answer(dnsa);\n  return i;\n}\n\n\n\n\n/*************************************************\n*    Find IP addresses and host names via DNS    *\n*************************************************/\n\n/* The input is a host_item structure with the name field filled in and the\naddress field set to NULL. This may be in a chain of other host items. The\nlookup may result in more than one IP address, in which case we must created\nnew host blocks for the additional addresses, and insert them into the chain.\nThe original name may not be fully qualified. Use the fully_qualified_name\nargument to return the official name, as returned by the resolver.\n\nArguments:\n  host                  point to initial host item\n  ignore_target_hosts   a list of hosts to ignore\n  whichrrs              flags indicating which RRs to look for:\n                          HOST_FIND_BY_SRV  => look for SRV\n                          HOST_FIND_BY_MX   => look for MX\n                          HOST_FIND_BY_A    => look for A\n                          HOST_FIND_BY_AAAA => look for AAAA\n                        also flags indicating how the lookup is done\n                          HOST_FIND_QUALIFY_SINGLE   ) passed to the\n                          HOST_FIND_SEARCH_PARENTS   )   resolver\n\t\t\t  HOST_FIND_IPV4_FIRST => reverse usual result ordering\n\t\t\t  HOST_FIND_IPV4_ONLY  => MX results elide ipv6\n  srv_service           when SRV used, the service name\n  srv_fail_domains      DNS errors for these domains => assume nonexist\n  mx_fail_domains       DNS errors for these domains => assume nonexist\n  dnssec_d.request =>   make dnssec request: domainlist\n  dnssec_d.require =>   ditto and nonexist failures\n  fully_qualified_name  if not NULL, return fully-qualified name\n  removed               set TRUE if local host was removed from the list\n\nReturns:                HOST_FIND_FAILED  Failed to find the host or domain;\n                                          if there was a syntax error,\n                                          host_find_failed_syntax is set.\n                        HOST_FIND_AGAIN   Could not resolve at this time\n\t\t\tHOST_FIND_SECURITY dnsssec required but not acheived\n                        HOST_FOUND        Host found\n                        HOST_FOUND_LOCAL  The lowest MX record points to this\n                                          machine, if MX records were found, or\n                                          an A record that was found contains\n                                          an address of the local host\n*/\n\nint\nhost_find_bydns(host_item *host, const uschar *ignore_target_hosts, int whichrrs,\n  uschar *srv_service, uschar *srv_fail_domains, uschar *mx_fail_domains,\n  const dnssec_domains *dnssec_d,\n  const uschar **fully_qualified_name, BOOL *removed)\n{\nhost_item *h, *last;\nint rc = DNS_FAIL;\nint ind_type = 0;\nint yield;\ndns_answer * dnsa = store_get_dns_answer();\ndns_scan dnss;\nBOOL dnssec_require = dnssec_d\n  && match_isinlist(host->name, CUSS &dnssec_d->require,\n\t\t  0, &domainlist_anchor, NULL, MCL_DOMAIN, TRUE, NULL) == OK;\nBOOL dnssec_request = dnssec_require\n    || (  dnssec_d\n       && match_isinlist(host->name, CUSS &dnssec_d->request,\n\t\t    0, &domainlist_anchor, NULL, MCL_DOMAIN, TRUE, NULL) == OK);\ndnssec_status_t dnssec;\n\n/* Set the default fully qualified name to the incoming name, initialize the\nresolver if necessary, set up the relevant options, and initialize the flag\nthat gets set for DNS syntax check errors. */\n\nif (fully_qualified_name != NULL) *fully_qualified_name = host->name;\ndns_init((whichrrs & HOST_FIND_QUALIFY_SINGLE) != 0,\n         (whichrrs & HOST_FIND_SEARCH_PARENTS) != 0,\n\t dnssec_request);\nf.host_find_failed_syntax = FALSE;\n\n/* First, if requested, look for SRV records. The service name is given; we\nassume TCP protocol. DNS domain names are constrained to a maximum of 256\ncharacters, so the code below should be safe. */\n\nif (whichrrs & HOST_FIND_BY_SRV)\n  {\n  gstring * g;\n  uschar * temp_fully_qualified_name;\n  int prefix_length;\n\n  g = string_fmt_append(NULL, \"_%s._tcp.%n%.256s\",\n\tsrv_service, &prefix_length, host->name);\n  temp_fully_qualified_name = string_from_gstring(g);\n  ind_type = T_SRV;\n\n  /* Search for SRV records. If the fully qualified name is different to\n  the input name, pass back the new original domain, without the prepended\n  magic. */\n\n  dnssec = DS_UNK;\n  lookup_dnssec_authenticated = NULL;\n  rc = dns_lookup_timerwrap(dnsa, temp_fully_qualified_name, ind_type,\n\tCUSS &temp_fully_qualified_name);\n\n  DEBUG(D_dns)\n    if ((dnssec_request || dnssec_require)\n\t&& !dns_is_secure(dnsa)\n\t&& dns_is_aa(dnsa))\n      debug_printf(\"DNS lookup of %.256s (SRV) requested AD, but got AA\\n\", host->name);\n\n  if (dnssec_request)\n    {\n    if (dns_is_secure(dnsa))\n      { dnssec = DS_YES; lookup_dnssec_authenticated = US\"yes\"; }\n    else\n      { dnssec = DS_NO; lookup_dnssec_authenticated = US\"no\"; }\n    }\n\n  if (temp_fully_qualified_name != g->s && fully_qualified_name != NULL)\n    *fully_qualified_name = temp_fully_qualified_name + prefix_length;\n\n  /* On DNS failures, we give the \"try again\" error unless the domain is\n  listed as one for which we continue. */\n\n  if (rc == DNS_SUCCEED && dnssec_require && !dns_is_secure(dnsa))\n    {\n    log_write(L_host_lookup_failed, LOG_MAIN,\n\t\t\"dnssec fail on SRV for %.256s\", host->name);\n    rc = DNS_FAIL;\n    }\n  if (rc == DNS_FAIL || rc == DNS_AGAIN)\n    {\n#ifndef STAND_ALONE\n    if (match_isinlist(host->name, CUSS &srv_fail_domains, 0,\n\t&domainlist_anchor, NULL, MCL_DOMAIN, TRUE, NULL) != OK)\n#endif\n      { yield = HOST_FIND_AGAIN; goto out; }\n    DEBUG(D_host_lookup) debug_printf(\"DNS_%s treated as DNS_NODATA \"\n      \"(domain in srv_fail_domains)\\n\", rc == DNS_FAIL ? \"FAIL\":\"AGAIN\");\n    }\n  }\n\n/* If we did not find any SRV records, search the DNS for MX records, if\nrequested to do so. If the result is DNS_NOMATCH, it means there is no such\ndomain, and there's no point in going on to look for address records with the\nsame domain. The result will be DNS_NODATA if the domain exists but has no MX\nrecords. On DNS failures, we give the \"try again\" error unless the domain is\nlisted as one for which we continue. */\n\nif (rc != DNS_SUCCEED  &&  whichrrs & HOST_FIND_BY_MX)\n  {\n  ind_type = T_MX;\n  dnssec = DS_UNK;\n  lookup_dnssec_authenticated = NULL;\n  rc = dns_lookup_timerwrap(dnsa, host->name, ind_type, fully_qualified_name);\n\n  DEBUG(D_dns)\n    if (  (dnssec_request || dnssec_require)\n       && !dns_is_secure(dnsa)\n       && dns_is_aa(dnsa))\n      debug_printf(\"DNS lookup of %.256s (MX) requested AD, but got AA\\n\", host->name);\n\n  if (dnssec_request)\n    if (dns_is_secure(dnsa))\n      {\n      DEBUG(D_host_lookup) debug_printf(\"%s (MX resp) DNSSEC\\n\", host->name);\n      dnssec = DS_YES; lookup_dnssec_authenticated = US\"yes\";\n      }\n    else\n      {\n      dnssec = DS_NO; lookup_dnssec_authenticated = US\"no\";\n      }\n\n  switch (rc)\n    {\n    case DNS_NOMATCH:\n      yield = HOST_FIND_FAILED; goto out;\n\n    case DNS_SUCCEED:\n      if (!dnssec_require || dns_is_secure(dnsa))\n\tbreak;\n      DEBUG(D_host_lookup)\n\tdebug_printf(\"dnssec fail on MX for %.256s\", host->name);\n#ifndef STAND_ALONE\n      if (match_isinlist(host->name, CUSS &mx_fail_domains, 0,\n\t  &domainlist_anchor, NULL, MCL_DOMAIN, TRUE, NULL) != OK)\n\t{ yield = HOST_FIND_SECURITY; goto out; }\n#endif\n      rc = DNS_FAIL;\n      /*FALLTHROUGH*/\n\n    case DNS_FAIL:\n    case DNS_AGAIN:\n#ifndef STAND_ALONE\n      if (match_isinlist(host->name, CUSS &mx_fail_domains, 0,\n\t  &domainlist_anchor, NULL, MCL_DOMAIN, TRUE, NULL) != OK)\n#endif\n\t{ yield = HOST_FIND_AGAIN; goto out; }\n      DEBUG(D_host_lookup) debug_printf(\"DNS_%s treated as DNS_NODATA \"\n\t\"(domain in mx_fail_domains)\\n\", (rc == DNS_FAIL)? \"FAIL\":\"AGAIN\");\n      break;\n    }\n  }\n\n/* If we haven't found anything yet, and we are requested to do so, try for an\nA or AAAA record. If we find it (or them) check to see that it isn't the local\nhost. */\n\nif (rc != DNS_SUCCEED)\n  {\n  if (!(whichrrs & (HOST_FIND_BY_A | HOST_FIND_BY_AAAA)))\n    {\n    DEBUG(D_host_lookup) debug_printf(\"Address records are not being sought\\n\");\n    yield = HOST_FIND_FAILED;\n    goto out;\n    }\n\n  last = host;        /* End of local chainlet */\n  host->mx = MX_NONE;\n  host->port = PORT_NONE;\n  host->dnssec = DS_UNK;\n  lookup_dnssec_authenticated = NULL;\n  rc = set_address_from_dns(host, &last, ignore_target_hosts, FALSE,\n    fully_qualified_name, dnssec_request, dnssec_require, whichrrs);\n\n  /* If one or more address records have been found, check that none of them\n  are local. Since we know the host items all have their IP addresses\n  inserted, host_scan_for_local_hosts() can only return HOST_FOUND or\n  HOST_FOUND_LOCAL. We do not need to scan for duplicate IP addresses here,\n  because set_address_from_dns() removes them. */\n\n  if (rc == HOST_FOUND)\n    rc = host_scan_for_local_hosts(host, &last, removed);\n  else\n    if (rc == HOST_IGNORED) rc = HOST_FIND_FAILED;  /* No special action */\n\n  DEBUG(D_host_lookup)\n    if (host->address)\n      {\n      if (fully_qualified_name)\n        debug_printf(\"fully qualified name = %s\\n\", *fully_qualified_name);\n      for (host_item * h = host; h != last->next; h = h->next)\n        debug_printf(\"%s %s mx=%d sort=%d %s\\n\", h->name,\n          h->address ? h->address : US\"<null>\", h->mx, h->sort_key,\n          h->status >= hstatus_unusable ? US\"*\" : US\"\");\n      }\n\n  yield = rc;\n  goto out;\n  }\n\n/* We have found one or more MX or SRV records. Sort them according to\nprecedence. Put the data for the first one into the existing host block, and\ninsert new host_item blocks into the chain for the remainder. For equal\nprecedences one is supposed to randomize the order. To make this happen, the\nsorting is actually done on the MX value * 1000 + a random number. This is put\ninto a host field called sort_key.\n\nIn the case of hosts with both IPv6 and IPv4 addresses, we want to choose the\nIPv6 address in preference. At this stage, we don't know what kind of address\nthe host has. We choose a random number < 500; if later we find an A record\nfirst, we add 500 to the random number. Then for any other address records, we\nuse random numbers in the range 0-499 for AAAA records and 500-999 for A\nrecords.\n\nAt this point we remove any duplicates that point to the same host, retaining\nonly the one with the lowest precedence. We cannot yet check for precedence\ngreater than that of the local host, because that test cannot be properly done\nuntil the addresses have been found - an MX record may point to a name for this\nhost which is not the primary hostname. */\n\nlast = NULL;    /* Indicates that not even the first item is filled yet */\n\nfor (dns_record * rr = dns_next_rr(dnsa, &dnss, RESET_ANSWERS);\n     rr;\n     rr = dns_next_rr(dnsa, &dnss, RESET_NEXT)) if (rr->type == ind_type)\n  {\n  int precedence, weight;\n  int port = PORT_NONE;\n  const uschar * s = rr->data;\t/* MUST be unsigned for GETSHORT */\n  uschar data[256];\n\n  GETSHORT(precedence, s);      /* Pointer s is advanced */\n\n  /* For MX records, we use a random \"weight\" which causes multiple records of\n  the same precedence to sort randomly. */\n\n  if (ind_type == T_MX)\n    weight = random_number(500);\n  else\n    {\n    /* SRV records are specified with a port and a weight. The weight is used\n    in a special algorithm. However, to start with, we just use it to order the\n    records of equal priority (precedence). */\n    GETSHORT(weight, s);\n    GETSHORT(port, s);\n    }\n\n  /* Get the name of the host pointed to. */\n\n  (void)dn_expand(dnsa->answer, dnsa->answer + dnsa->answerlen, s,\n    (DN_EXPAND_ARG4_TYPE)data, sizeof(data));\n\n  /* Check that we haven't already got this host on the chain; if we have,\n  keep only the lower precedence. This situation shouldn't occur, but you\n  never know what junk might get into the DNS (and this case has been seen on\n  more than one occasion). */\n\n  if (last)       /* This is not the first record */\n    {\n    host_item *prev = NULL;\n\n    for (h = host; h != last->next; prev = h, h = h->next)\n      if (strcmpic(h->name, data) == 0)\n        {\n        DEBUG(D_host_lookup)\n          debug_printf(\"discarded duplicate host %s (MX=%d)\\n\", data,\n            precedence > h->mx ? precedence : h->mx);\n        if (precedence >= h->mx) goto NEXT_MX_RR; /* Skip greater precedence */\n        if (h == host)                            /* Override first item */\n          {\n          h->mx = precedence;\n          host->sort_key = precedence * 1000 + weight;\n          goto NEXT_MX_RR;\n          }\n\n        /* Unwanted host item is not the first in the chain, so we can get\n        get rid of it by cutting it out. */\n\n        prev->next = h->next;\n        if (h == last) last = prev;\n        break;\n        }\n    }\n\n  /* If this is the first MX or SRV record, put the data into the existing host\n  block. Otherwise, add a new block in the correct place; if it has to be\n  before the first block, copy the first block's data to a new second block. */\n\n  if (!last)\n    {\n    host->name = string_copy_dnsdomain(data);\n    host->address = NULL;\n    host->port = port;\n    host->mx = precedence;\n    host->sort_key = precedence * 1000 + weight;\n    host->status = hstatus_unknown;\n    host->why = hwhy_unknown;\n    host->dnssec = dnssec;\n    last = host;\n    }\n  else\n\n  /* Make a new host item and seek the correct insertion place */\n    {\n    int sort_key = precedence * 1000 + weight;\n    host_item *next = store_get(sizeof(host_item), FALSE);\n    next->name = string_copy_dnsdomain(data);\n    next->address = NULL;\n    next->port = port;\n    next->mx = precedence;\n    next->sort_key = sort_key;\n    next->status = hstatus_unknown;\n    next->why = hwhy_unknown;\n    next->dnssec = dnssec;\n    next->last_try = 0;\n\n    /* Handle the case when we have to insert before the first item. */\n\n    if (sort_key < host->sort_key)\n      {\n      host_item htemp;\n      htemp = *host;\n      *host = *next;\n      *next = htemp;\n      host->next = next;\n      if (last == host) last = next;\n      }\n    else\n\n    /* Else scan down the items we have inserted as part of this exercise;\n    don't go further. */\n      {\n      for (h = host; h != last; h = h->next)\n        if (sort_key < h->next->sort_key)\n          {\n          next->next = h->next;\n          h->next = next;\n          break;\n          }\n\n      /* Join on after the last host item that's part of this\n      processing if we haven't stopped sooner. */\n\n      if (h == last)\n        {\n        next->next = last->next;\n        last->next = next;\n        last = next;\n        }\n      }\n    }\n\n  NEXT_MX_RR: continue;\n  }\n\nif (!last)\t/* No rr of correct type; give up */\n  {\n  yield = HOST_FIND_FAILED;\n  goto out;\n  }\n\n/* If the list of hosts was obtained from SRV records, there are two things to\ndo. First, if there is only one host, and it's name is \".\", it means there is\nno SMTP service at this domain. Otherwise, we have to sort the hosts of equal\npriority according to their weights, using an algorithm that is defined in RFC\n2782. The hosts are currently sorted by priority and weight. For each priority\ngroup we have to pick off one host and put it first, and then repeat for any\nremaining in the same priority group. */\n\nif (ind_type == T_SRV)\n  {\n  host_item ** pptr;\n\n  if (host == last && host->name[0] == 0)\n    {\n    DEBUG(D_host_lookup) debug_printf(\"the single SRV record is \\\".\\\"\\n\");\n    yield = HOST_FIND_FAILED;\n    goto out;\n    }\n\n  DEBUG(D_host_lookup)\n    {\n    debug_printf(\"original ordering of hosts from SRV records:\\n\");\n    for (h = host; h != last->next; h = h->next)\n      debug_printf(\"  %s P=%d W=%d\\n\", h->name, h->mx, h->sort_key % 1000);\n    }\n\n  for (pptr = &host, h = host; h != last; pptr = &h->next, h = h->next)\n    {\n    int sum = 0;\n    host_item *hh;\n\n    /* Find the last following host that has the same precedence. At the same\n    time, compute the sum of the weights and the running totals. These can be\n    stored in the sort_key field. */\n\n    for (hh = h; hh != last; hh = hh->next)\n      {\n      int weight = hh->sort_key % 1000;   /* was precedence * 1000 + weight */\n      sum += weight;\n      hh->sort_key = sum;\n      if (hh->mx != hh->next->mx) break;\n      }\n\n    /* If there's more than one host at this precedence (priority), we need to\n    pick one to go first. */\n\n    if (hh != h)\n      {\n      host_item *hhh;\n      host_item **ppptr;\n      int randomizer = random_number(sum + 1);\n\n      for (ppptr = pptr, hhh = h;\n           hhh != hh;\n           ppptr = &hhh->next, hhh = hhh->next)\n        if (hhh->sort_key >= randomizer)\n\t  break;\n\n      /* hhh now points to the host that should go first; ppptr points to the\n      place that points to it. Unfortunately, if the start of the minilist is\n      the start of the entire list, we can't just swap the items over, because\n      we must not change the value of host, since it is passed in from outside.\n      One day, this could perhaps be changed.\n\n      The special case is fudged by putting the new item *second* in the chain,\n      and then transferring the data between the first and second items. We\n      can't just swap the first and the chosen item, because that would mean\n      that an item with zero weight might no longer be first. */\n\n      if (hhh != h)\n        {\n        *ppptr = hhh->next;          /* Cuts it out of the chain */\n\n        if (h == host)\n          {\n          host_item temp = *h;\n          *h = *hhh;\n          *hhh = temp;\n          hhh->next = temp.next;\n          h->next = hhh;\n          }\n        else\n          {\n          hhh->next = h;               /* The rest of the chain follows it */\n          *pptr = hhh;                 /* It takes the place of h */\n          h = hhh;                     /* It's now the start of this minilist */\n          }\n        }\n      }\n\n    /* A host has been chosen to be first at this priority and h now points\n    to this host. There may be others at the same priority, or others at a\n    different priority. Before we leave this host, we need to put back a sort\n    key of the traditional MX kind, in case this host is multihomed, because\n    the sort key is used for ordering the multiple IP addresses. We do not need\n    to ensure that these new sort keys actually reflect the order of the hosts,\n    however. */\n\n    h->sort_key = h->mx * 1000 + random_number(500);\n    }   /* Move on to the next host */\n  }\n\n/* Now we have to find IP addresses for all the hosts. We have ensured above\nthat the names in all the host items are unique. Before release 4.61 we used to\nprocess records from the additional section in the DNS packet that returned the\nMX or SRV records. However, a DNS name server is free to drop any resource\nrecords from the additional section. In theory, this has always been a\npotential problem, but it is exacerbated by the advent of IPv6. If a host had\nseveral IPv4 addresses and some were not in the additional section, at least\nExim would try the others. However, if a host had both IPv4 and IPv6 addresses\nand all the IPv4 (say) addresses were absent, Exim would try only for a IPv6\nconnection, and never try an IPv4 address. When there was only IPv4\nconnectivity, this was a disaster that did in practice occur.\n\nSo, from release 4.61 onwards, we always search for A and AAAA records\nexplicitly. The names shouldn't point to CNAMES, but we use the general lookup\nfunction that handles them, just in case. If any lookup gives a soft error,\nchange the default yield.\n\nFor these DNS lookups, we must disable qualify_single and search_parents;\notherwise invalid host names obtained from MX or SRV records can cause trouble\nif they happen to match something local. */\n\nyield = HOST_FIND_FAILED;    /* Default yield */\ndns_init(FALSE, FALSE,       /* Disable qualify_single and search_parents */\n\t dnssec_request || dnssec_require);\n\nfor (h = host; h != last->next; h = h->next)\n  {\n  if (h->address) continue;  /* Inserted by a multihomed host */\n\n  rc = set_address_from_dns(h, &last, ignore_target_hosts, allow_mx_to_ip,\n    NULL, dnssec_request, dnssec_require,\n    whichrrs & HOST_FIND_IPV4_ONLY\n    ?  HOST_FIND_BY_A  :  HOST_FIND_BY_A | HOST_FIND_BY_AAAA);\n  if (rc != HOST_FOUND)\n    {\n    h->status = hstatus_unusable;\n    switch (rc)\n      {\n      case HOST_FIND_AGAIN:\tyield = rc; h->why = hwhy_deferred; break;\n      case HOST_FIND_SECURITY:\tyield = rc; h->why = hwhy_insecure; break;\n      case HOST_IGNORED:\th->why = hwhy_ignored; break;\n      default:\t\t\th->why = hwhy_failed; break;\n      }\n    }\n  }\n\n/* Scan the list for any hosts that are marked unusable because they have\nbeen explicitly ignored, and remove them from the list, as if they did not\nexist. If we end up with just a single, ignored host, flatten its fields as if\nnothing was found. */\n\nif (ignore_target_hosts)\n  {\n  host_item *prev = NULL;\n  for (h = host; h != last->next; h = h->next)\n    {\n    REDO:\n    if (h->why != hwhy_ignored)        /* Non ignored host, just continue */\n      prev = h;\n    else if (prev == NULL)             /* First host is ignored */\n      {\n      if (h != last)                   /* First is not last */\n        {\n        if (h->next == last) last = h; /* Overwrite it with next */\n        *h = *(h->next);               /* and reprocess it. */\n        goto REDO;                     /* C should have redo, like Perl */\n        }\n      }\n    else                               /* Ignored host is not first - */\n      {                                /*   cut it out */\n      prev->next = h->next;\n      if (h == last) last = prev;\n      }\n    }\n\n  if (host->why == hwhy_ignored) host->address = NULL;\n  }\n\n/* There is still one complication in the case of IPv6. Although the code above\narranges that IPv6 addresses take precedence over IPv4 addresses for multihomed\nhosts, it doesn't do this for addresses that apply to different hosts with the\nsame MX precedence, because the sorting on MX precedence happens first. So we\nhave to make another pass to check for this case. We ensure that, within a\nsingle MX preference value, IPv6 addresses come first. This can separate the\naddresses of a multihomed host, but that should not matter. */\n\n#if HAVE_IPV6\nif (h != last && !disable_ipv6) for (h = host; h != last; h = h->next)\n  {\n  host_item temp;\n  host_item *next = h->next;\n\n  if (  h->mx != next->mx\t\t\t/* If next is different MX */\n     || !h->address\t\t\t\t/* OR this one is unset */\n     )\n    continue;\t\t\t\t\t/* move on to next */\n\n  if (  whichrrs & HOST_FIND_IPV4_FIRST\n     ?     !Ustrchr(h->address, ':')\t\t/* OR this one is IPv4 */\n        || next->address\n           && Ustrchr(next->address, ':')\t/* OR next is IPv6 */\n\n     :     Ustrchr(h->address, ':')\t\t/* OR this one is IPv6 */\n        || next->address\n           && !Ustrchr(next->address, ':')\t/* OR next is IPv4 */\n     )\n    continue;                                /* move on to next */\n\n  temp = *h;                                 /* otherwise, swap */\n  temp.next = next->next;\n  *h = *next;\n  h->next = next;\n  *next = temp;\n  }\n#endif\n\n/* Remove any duplicate IP addresses and then scan the list of hosts for any\nwhose IP addresses are on the local host. If any are found, all hosts with the\nsame or higher MX values are removed. However, if the local host has the lowest\nnumbered MX, then HOST_FOUND_LOCAL is returned. Otherwise, if at least one host\nwith an IP address is on the list, HOST_FOUND is returned. Otherwise,\nHOST_FIND_FAILED is returned, but in this case do not update the yield, as it\nmight have been set to HOST_FIND_AGAIN just above here. If not, it will already\nbe HOST_FIND_FAILED. */\n\nhost_remove_duplicates(host, &last);\nrc = host_scan_for_local_hosts(host, &last, removed);\nif (rc != HOST_FIND_FAILED) yield = rc;\n\nDEBUG(D_host_lookup)\n  {\n  if (fully_qualified_name)\n    debug_printf(\"fully qualified name = %s\\n\", *fully_qualified_name);\n  debug_printf(\"host_find_bydns yield = %s (%d); returned hosts:\\n\",\n    yield == HOST_FOUND\t\t? \"HOST_FOUND\" :\n    yield == HOST_FOUND_LOCAL\t? \"HOST_FOUND_LOCAL\" :\n    yield == HOST_FIND_SECURITY\t? \"HOST_FIND_SECURITY\" :\n    yield == HOST_FIND_AGAIN\t? \"HOST_FIND_AGAIN\" :\n    yield == HOST_FIND_FAILED\t? \"HOST_FIND_FAILED\" : \"?\",\n    yield);\n  for (h = host; h != last->next; h = h->next)\n    {\n    debug_printf(\"  %s %s MX=%d %s\", h->name,\n      !h->address ? US\"<null>\" : h->address, h->mx,\n      h->dnssec == DS_YES ? US\"DNSSEC \" : US\"\");\n    if (h->port != PORT_NONE) debug_printf(\"port=%d \", h->port);\n    if (h->status >= hstatus_unusable) debug_printf(\"*\");\n    debug_printf(\"\\n\");\n    }\n  }\n\nout:\n\ndns_init(FALSE, FALSE, FALSE);\t/* clear the dnssec bit for getaddrbyname */\nstore_free_dns_answer(dnsa);\nreturn yield;\n}\n\n\n\n\n#ifdef SUPPORT_DANE\n/* Lookup TLSA record for host/port.\nReturn:  OK\t\tsuccess with dnssec; DANE mode\n         DEFER\t\tDo not use this host now, may retry later\n\t FAIL_FORCED\tNo TLSA record; DANE not usable\n\t FAIL\t\tDo not use this connection\n*/\n\nint\ntlsa_lookup(const host_item * host, dns_answer * dnsa, BOOL dane_required)\n{\nuschar buffer[300];\nconst uschar * fullname = buffer;\nint rc;\nBOOL sec;\n\n/* TLSA lookup string */\n(void)sprintf(CS buffer, \"_%d._tcp.%.256s\", host->port, host->name);\n\nrc = dns_lookup_timerwrap(dnsa, buffer, T_TLSA, &fullname);\nsec = dns_is_secure(dnsa);\nDEBUG(D_transport)\n  debug_printf(\"TLSA lookup ret %s %sDNSSEC\\n\", dns_rc_names[rc], sec ? \"\" : \"not \");\n\nswitch (rc)\n  {\n  case DNS_AGAIN:\n    return DEFER; /* just defer this TLS'd conn */\n\n  case DNS_SUCCEED:\n    if (sec)\n      {\n      DEBUG(D_transport)\n\t{\n\tdns_scan dnss;\n\tfor (dns_record * rr = dns_next_rr(dnsa, &dnss, RESET_ANSWERS); rr;\n\t     rr = dns_next_rr(dnsa, &dnss, RESET_NEXT))\n\t  if (rr->type == T_TLSA && rr->size > 3)\n\t    {\n\t    uint16_t payload_length = rr->size - 3;\n\t    uschar s[MAX_TLSA_EXPANDED_SIZE], * sp = s, * p = US rr->data;\n\n\t    sp += sprintf(CS sp, \"%d \", *p++); /* usage */\n\t    sp += sprintf(CS sp, \"%d \", *p++); /* selector */\n\t    sp += sprintf(CS sp, \"%d \", *p++); /* matchtype */\n\t    while (payload_length-- > 0 && sp-s < (MAX_TLSA_EXPANDED_SIZE - 4))\n\t      sp += sprintf(CS sp, \"%02x\", *p++);\n\n\t    debug_printf(\" %s\\n\", s);\n\t    }\n\t}\n      return OK;\n      }\n    log_write(0, LOG_MAIN,\n      \"DANE error: TLSA lookup for %s not DNSSEC\", host->name);\n    /*FALLTRHOUGH*/\n\n  case DNS_NODATA:\t/* no TLSA RR for this lookup */\n  case DNS_NOMATCH:\t/* no records at all for this lookup */\n    return dane_required ? FAIL : FAIL_FORCED;\n\n  default:\n  case DNS_FAIL:\n    return dane_required ? FAIL : DEFER;\n  }\n}\n#endif\t/*SUPPORT_DANE*/\n\n\n\n/*************************************************\n**************************************************\n*             Stand-alone test program           *\n**************************************************\n*************************************************/\n\n#ifdef STAND_ALONE\n\nint main(int argc, char **cargv)\n{\nhost_item h;\nint whichrrs = HOST_FIND_BY_MX | HOST_FIND_BY_A | HOST_FIND_BY_AAAA;\nBOOL byname = FALSE;\nBOOL qualify_single = TRUE;\nBOOL search_parents = FALSE;\nBOOL request_dnssec = FALSE;\nBOOL require_dnssec = FALSE;\nuschar **argv = USS cargv;\nuschar buffer[256];\n\ndisable_ipv6 = FALSE;\nprimary_hostname = US\"\";\nstore_init();\nstore_pool = POOL_MAIN;\ndebug_selector = D_host_lookup|D_interface;\ndebug_file = stdout;\ndebug_fd = fileno(debug_file);\n\nprintf(\"Exim stand-alone host functions test\\n\");\n\nhost_find_interfaces();\ndebug_selector = D_host_lookup | D_dns;\n\nif (argc > 1) primary_hostname = argv[1];\n\n/* So that debug level changes can be done first */\n\ndns_init(qualify_single, search_parents, FALSE);\n\nprintf(\"Testing host lookup\\n\");\nprintf(\"> \");\nwhile (Ufgets(buffer, 256, stdin) != NULL)\n  {\n  int rc;\n  int len = Ustrlen(buffer);\n  uschar *fully_qualified_name;\n\n  while (len > 0 && isspace(buffer[len-1])) len--;\n  buffer[len] = 0;\n\n  if (Ustrcmp(buffer, \"q\") == 0) break;\n\n  if (Ustrcmp(buffer, \"byname\") == 0) byname = TRUE;\n  else if (Ustrcmp(buffer, \"no_byname\") == 0) byname = FALSE;\n  else if (Ustrcmp(buffer, \"a_only\") == 0) whichrrs = HOST_FIND_BY_A | HOST_FIND_BY_AAAA;\n  else if (Ustrcmp(buffer, \"mx_only\") == 0) whichrrs = HOST_FIND_BY_MX;\n  else if (Ustrcmp(buffer, \"srv_only\") == 0) whichrrs = HOST_FIND_BY_SRV;\n  else if (Ustrcmp(buffer, \"srv+a\") == 0)\n    whichrrs = HOST_FIND_BY_SRV | HOST_FIND_BY_A | HOST_FIND_BY_AAAA;\n  else if (Ustrcmp(buffer, \"srv+mx\") == 0)\n    whichrrs = HOST_FIND_BY_SRV | HOST_FIND_BY_MX;\n  else if (Ustrcmp(buffer, \"srv+mx+a\") == 0)\n    whichrrs = HOST_FIND_BY_SRV | HOST_FIND_BY_MX | HOST_FIND_BY_A | HOST_FIND_BY_AAAA;\n  else if (Ustrcmp(buffer, \"qualify_single\")    == 0) qualify_single = TRUE;\n  else if (Ustrcmp(buffer, \"no_qualify_single\") == 0) qualify_single = FALSE;\n  else if (Ustrcmp(buffer, \"search_parents\")    == 0) search_parents = TRUE;\n  else if (Ustrcmp(buffer, \"no_search_parents\") == 0) search_parents = FALSE;\n  else if (Ustrcmp(buffer, \"request_dnssec\")    == 0) request_dnssec = TRUE;\n  else if (Ustrcmp(buffer, \"no_request_dnssec\") == 0) request_dnssec = FALSE;\n  else if (Ustrcmp(buffer, \"require_dnssec\")    == 0) require_dnssec = TRUE;\n  else if (Ustrcmp(buffer, \"no_require_dnssec\") == 0) require_dnssec = FALSE;\n  else if (Ustrcmp(buffer, \"test_harness\") == 0)\n    f.running_in_test_harness = !f.running_in_test_harness;\n  else if (Ustrcmp(buffer, \"ipv6\") == 0) disable_ipv6 = !disable_ipv6;\n  else if (Ustrcmp(buffer, \"res_debug\") == 0)\n    {\n    _res.options ^= RES_DEBUG;\n    }\n  else if (Ustrncmp(buffer, \"retrans\", 7) == 0)\n    {\n    (void)sscanf(CS(buffer+8), \"%d\", &dns_retrans);\n    _res.retrans = dns_retrans;\n    }\n  else if (Ustrncmp(buffer, \"retry\", 5) == 0)\n    {\n    (void)sscanf(CS(buffer+6), \"%d\", &dns_retry);\n    _res.retry = dns_retry;\n    }\n  else\n    {\n    int flags = whichrrs;\n    dnssec_domains d;\n\n    h.name = buffer;\n    h.next = NULL;\n    h.mx = MX_NONE;\n    h.port = PORT_NONE;\n    h.status = hstatus_unknown;\n    h.why = hwhy_unknown;\n    h.address = NULL;\n\n    if (qualify_single) flags |= HOST_FIND_QUALIFY_SINGLE;\n    if (search_parents) flags |= HOST_FIND_SEARCH_PARENTS;\n\n    d.request = request_dnssec ? &h.name : NULL;\n    d.require = require_dnssec ? &h.name : NULL;\n\n    rc = byname\n      ? host_find_byname(&h, NULL, flags, &fully_qualified_name, TRUE)\n      : host_find_bydns(&h, NULL, flags, US\"smtp\", NULL, NULL,\n\t\t\t&d, &fully_qualified_name, NULL);\n\n    switch (rc)\n      {\n      case HOST_FIND_FAILED:\tprintf(\"Failed\\n\");\tbreak;\n      case HOST_FIND_AGAIN:\tprintf(\"Again\\n\");\tbreak;\n      case HOST_FIND_SECURITY:\tprintf(\"Security\\n\");\tbreak;\n      case HOST_FOUND_LOCAL:\tprintf(\"Local\\n\");\tbreak;\n      }\n    }\n\n  printf(\"\\n> \");\n  }\n\nprintf(\"Testing host_aton\\n\");\nprintf(\"> \");\nwhile (Ufgets(buffer, 256, stdin) != NULL)\n  {\n  int x[4];\n  int len = Ustrlen(buffer);\n\n  while (len > 0 && isspace(buffer[len-1])) len--;\n  buffer[len] = 0;\n\n  if (Ustrcmp(buffer, \"q\") == 0) break;\n\n  len = host_aton(buffer, x);\n  printf(\"length = %d \", len);\n  for (int i = 0; i < len; i++)\n    {\n    printf(\"%04x \", (x[i] >> 16) & 0xffff);\n    printf(\"%04x \", x[i] & 0xffff);\n    }\n  printf(\"\\n> \");\n  }\n\nprintf(\"\\n\");\n\nprintf(\"Testing host_name_lookup\\n\");\nprintf(\"> \");\nwhile (Ufgets(buffer, 256, stdin) != NULL)\n  {\n  int len = Ustrlen(buffer);\n  while (len > 0 && isspace(buffer[len-1])) len--;\n  buffer[len] = 0;\n  if (Ustrcmp(buffer, \"q\") == 0) break;\n  sender_host_address = buffer;\n  sender_host_name = NULL;\n  sender_host_aliases = NULL;\n  host_lookup_msg = US\"\";\n  host_lookup_failed = FALSE;\n  if (host_name_lookup() == FAIL)  /* Debug causes printing */\n    printf(\"Lookup failed:%s\\n\", host_lookup_msg);\n  printf(\"\\n> \");\n  }\n\nprintf(\"\\n\");\n\nreturn 0;\n}\n#endif  /* STAND_ALONE */\n\n/* vi: aw ai sw=2\n*/\n/* End of host.c */\n"], "fixing_code": ["/*************************************************\n*     Exim - an Internet mail transport agent    *\n*************************************************/\n\n/* Copyright (c) University of Cambridge 1995 - 2018 */\n/* Copyright (c) The Exim Maintainers 2020 */\n/* See the file NOTICE for conditions of use and distribution. */\n\n/* Functions for finding hosts, either by gethostbyname(), gethostbyaddr(), or\ndirectly via the DNS. When IPv6 is supported, getipnodebyname() and\ngetipnodebyaddr() may be used instead of gethostbyname() and gethostbyaddr(),\nif the newer functions are available. This module also contains various other\nfunctions concerned with hosts and addresses, and a random number function,\nused for randomizing hosts with equal MXs but available for use in other parts\nof Exim. */\n\n\n#include \"exim.h\"\n\n\n/* Static variable for preserving the list of interface addresses in case it is\nused more than once. */\n\nstatic ip_address_item *local_interface_data = NULL;\n\n\n#ifdef USE_INET_NTOA_FIX\n/*************************************************\n*         Replacement for broken inet_ntoa()     *\n*************************************************/\n\n/* On IRIX systems, gcc uses a different structure passing convention to the\nnative libraries. This causes inet_ntoa() to always yield 0.0.0.0 or\n255.255.255.255. To get round this, we provide a private version of the\nfunction here. It is used only if USE_INET_NTOA_FIX is set, which should happen\nonly when gcc is in use on an IRIX system. Code send to me by J.T. Breitner,\nwith these comments:\n\n  code by Stuart Levy\n  as seen in comp.sys.sgi.admin\n\nAugust 2005: Apparently this is also needed for AIX systems; USE_INET_NTOA_FIX\nshould now be set for them as well.\n\nArguments:  sa  an in_addr structure\nReturns:        pointer to static text string\n*/\n\nchar *\ninet_ntoa(struct in_addr sa)\n{\nstatic uschar addr[20];\nsprintf(addr, \"%d.%d.%d.%d\",\n        (US &sa.s_addr)[0],\n        (US &sa.s_addr)[1],\n        (US &sa.s_addr)[2],\n        (US &sa.s_addr)[3]);\n  return addr;\n}\n#endif\n\n\n\n/*************************************************\n*              Random number generator           *\n*************************************************/\n\n/* This is a simple pseudo-random number generator. It does not have to be\nvery good for the uses to which it is put. When running the regression tests,\nstart with a fixed seed.\n\nIf you need better, see vaguely_random_number() which is potentially stronger,\nif a crypto library is available, but might end up just calling this instead.\n\nArguments:\n  limit:    one more than the largest number required\n\nReturns:    a pseudo-random number in the range 0 to limit-1\n*/\n\nint\nrandom_number(int limit)\n{\nif (limit < 1)\n  return 0;\nif (random_seed == 0)\n  {\n  if (f.running_in_test_harness) random_seed = 42; else\n    {\n    int p = (int)getpid();\n    random_seed = (int)time(NULL) ^ ((p << 16) | p);\n    }\n  }\nrandom_seed = 1103515245 * random_seed + 12345;\nreturn (unsigned int)(random_seed >> 16) % limit;\n}\n\n/*************************************************\n*      Wrappers for logging lookup times         *\n*************************************************/\n\n/* When the 'slow_lookup_log' variable is enabled, these wrappers will\nwrite to the log file all (potential) dns lookups that take more than\nslow_lookup_log milliseconds\n*/\n\nstatic void\nlog_long_lookup(const uschar * type, const uschar * data, unsigned long msec)\n{\nlog_write(0, LOG_MAIN, \"Long %s lookup for '%s': %lu msec\",\n  type, data, msec);\n}\n\n\n/* returns the current system epoch time in milliseconds. */\nstatic unsigned long\nget_time_in_ms()\n{\nstruct timeval tmp_time;\nunsigned long seconds, microseconds;\n\ngettimeofday(&tmp_time, NULL);\nseconds = (unsigned long) tmp_time.tv_sec;\nmicroseconds = (unsigned long) tmp_time.tv_usec;\nreturn seconds*1000 + microseconds/1000;\n}\n\n\nstatic int\ndns_lookup_timerwrap(dns_answer *dnsa, const uschar *name, int type,\n  const uschar **fully_qualified_name)\n{\nint retval;\nunsigned long time_msec;\n\nif (!slow_lookup_log)\n  return dns_lookup(dnsa, name, type, fully_qualified_name);\n\ntime_msec = get_time_in_ms();\nretval = dns_lookup(dnsa, name, type, fully_qualified_name);\nif ((time_msec = get_time_in_ms() - time_msec) > slow_lookup_log)\n  log_long_lookup(dns_text_type(type), name, time_msec);\nreturn retval;\n}\n\n\n/*************************************************\n*       Replace gethostbyname() when testing     *\n*************************************************/\n\n/* This function is called instead of gethostbyname(), gethostbyname2(), or\ngetipnodebyname() when running in the test harness. . It also\nrecognizes an unqualified \"localhost\" and forces it to the appropriate loopback\naddress. IP addresses are treated as literals. For other names, it uses the DNS\nto find the host name. In the test harness, this means it will access only the\nfake DNS resolver.\n\nArguments:\n  name          the host name or a textual IP address\n  af            AF_INET or AF_INET6\n  error_num     where to put an error code:\n                HOST_NOT_FOUND/TRY_AGAIN/NO_RECOVERY/NO_DATA\n\nReturns:        a hostent structure or NULL for an error\n*/\n\nstatic struct hostent *\nhost_fake_gethostbyname(const uschar *name, int af, int *error_num)\n{\n#if HAVE_IPV6\nint alen = (af == AF_INET)? sizeof(struct in_addr):sizeof(struct in6_addr);\n#else\nint alen = sizeof(struct in_addr);\n#endif\n\nint ipa;\nconst uschar *lname = name;\nuschar *adds;\nuschar **alist;\nstruct hostent *yield;\ndns_answer * dnsa = store_get_dns_answer();\ndns_scan dnss;\n\nDEBUG(D_host_lookup)\n  debug_printf(\"using host_fake_gethostbyname for %s (%s)\\n\", name,\n    af == AF_INET ? \"IPv4\" : \"IPv6\");\n\n/* Handle unqualified \"localhost\" */\n\nif (Ustrcmp(name, \"localhost\") == 0)\n  lname = af == AF_INET ? US\"127.0.0.1\" : US\"::1\";\n\n/* Handle a literal IP address */\n\nif ((ipa = string_is_ip_address(lname, NULL)) != 0)\n  if (   ipa == 4 && af == AF_INET\n     ||  ipa == 6 && af == AF_INET6)\n    {\n    int x[4];\n    yield = store_get(sizeof(struct hostent), FALSE);\n    alist = store_get(2 * sizeof(char *), FALSE);\n    adds  = store_get(alen, FALSE);\n    yield->h_name = CS name;\n    yield->h_aliases = NULL;\n    yield->h_addrtype = af;\n    yield->h_length = alen;\n    yield->h_addr_list = CSS alist;\n    *alist++ = adds;\n    for (int n = host_aton(lname, x), i = 0; i < n; i++)\n      {\n      int y = x[i];\n      *adds++ = (y >> 24) & 255;\n      *adds++ = (y >> 16) & 255;\n      *adds++ = (y >> 8) & 255;\n      *adds++ = y & 255;\n      }\n    *alist = NULL;\n    }\n\n  /* Wrong kind of literal address */\n\n  else\n    {\n    *error_num = HOST_NOT_FOUND;\n    yield = NULL;\n    goto out;\n    }\n\n/* Handle a host name */\n\nelse\n  {\n  int type = af == AF_INET ? T_A:T_AAAA;\n  int rc = dns_lookup_timerwrap(dnsa, lname, type, NULL);\n  int count = 0;\n\n  lookup_dnssec_authenticated = NULL;\n\n  switch(rc)\n    {\n    case DNS_SUCCEED: break;\n    case DNS_NOMATCH: *error_num = HOST_NOT_FOUND; yield = NULL; goto out;\n    case DNS_NODATA:  *error_num = NO_DATA; yield = NULL; goto out;\n    case DNS_AGAIN:   *error_num = TRY_AGAIN; yield = NULL; goto out;\n    default:\n    case DNS_FAIL:    *error_num = NO_RECOVERY; yield = NULL; goto out;\n    }\n\n  for (dns_record * rr = dns_next_rr(dnsa, &dnss, RESET_ANSWERS);\n       rr;\n       rr = dns_next_rr(dnsa, &dnss, RESET_NEXT)) if (rr->type == type)\n    count++;\n\n  yield = store_get(sizeof(struct hostent), FALSE);\n  alist = store_get((count + 1) * sizeof(char *), FALSE);\n  adds  = store_get(count *alen, FALSE);\n\n  yield->h_name = CS name;\n  yield->h_aliases = NULL;\n  yield->h_addrtype = af;\n  yield->h_length = alen;\n  yield->h_addr_list = CSS alist;\n\n  for (dns_record * rr = dns_next_rr(dnsa, &dnss, RESET_ANSWERS);\n       rr;\n       rr = dns_next_rr(dnsa, &dnss, RESET_NEXT)) if (rr->type == type)\n    {\n    int x[4];\n    dns_address *da;\n    if (!(da = dns_address_from_rr(dnsa, rr))) break;\n    *alist++ = adds;\n    for (int n = host_aton(da->address, x), i = 0; i < n; i++)\n      {\n      int y = x[i];\n      *adds++ = (y >> 24) & 255;\n      *adds++ = (y >> 16) & 255;\n      *adds++ = (y >> 8) & 255;\n      *adds++ = y & 255;\n      }\n    }\n  *alist = NULL;\n  }\n\nout:\n\nstore_free_dns_answer(dnsa);\nreturn yield;\n}\n\n\n\n/*************************************************\n*       Build chain of host items from list      *\n*************************************************/\n\n/* This function builds a chain of host items from a textual list of host\nnames. It does not do any lookups. If randomize is true, the chain is build in\na randomized order. There may be multiple groups of independently randomized\nhosts; they are delimited by a host name consisting of just \"+\".\n\nArguments:\n  anchor      anchor for the chain\n  list        text list\n  randomize   TRUE for randomizing\n\nReturns:      nothing\n*/\n\nvoid\nhost_build_hostlist(host_item **anchor, const uschar *list, BOOL randomize)\n{\nint sep = 0;\nint fake_mx = MX_NONE;          /* This value is actually -1 */\nuschar *name;\n\nif (!list) return;\nif (randomize) fake_mx--;       /* Start at -2 for randomizing */\n\n*anchor = NULL;\n\nwhile ((name = string_nextinlist(&list, &sep, NULL, 0)))\n  {\n  host_item *h;\n\n  if (name[0] == '+' && name[1] == 0)   /* \"+\" delimits a randomized group */\n    {                                   /* ignore if not randomizing */\n    if (randomize) fake_mx--;\n    continue;\n    }\n\n  h = store_get(sizeof(host_item), FALSE);\n  h->name = name;\n  h->address = NULL;\n  h->port = PORT_NONE;\n  h->mx = fake_mx;\n  h->sort_key = randomize? (-fake_mx)*1000 + random_number(1000) : 0;\n  h->status = hstatus_unknown;\n  h->why = hwhy_unknown;\n  h->last_try = 0;\n\n  if (!*anchor)\n    {\n    h->next = NULL;\n    *anchor = h;\n    }\n  else\n    {\n    host_item *hh = *anchor;\n    if (h->sort_key < hh->sort_key)\n      {\n      h->next = hh;\n      *anchor = h;\n      }\n    else\n      {\n      while (hh->next && h->sort_key >= hh->next->sort_key)\n        hh = hh->next;\n      h->next = hh->next;\n      hh->next = h;\n      }\n    }\n  }\n}\n\n\n\n\n\n/*************************************************\n*        Extract port from address string        *\n*************************************************/\n\n/* In the spool file, and in the -oMa and -oMi options, a host plus port is\ngiven as an IP address followed by a dot and a port number. This function\ndecodes this.\n\nAn alternative format for the -oMa and -oMi options is [ip address]:port which\nis what Exim 4 uses for output, because it seems to becoming commonly used,\nwhereas the dot form confuses some programs/people. So we recognize that form\ntoo.\n\nArgument:\n  address    points to the string; if there is a port, the '.' in the string\n             is overwritten with zero to terminate the address; if the string\n             is in the [xxx]:ppp format, the address is shifted left and the\n             brackets are removed\n\nReturns:     0 if there is no port, else the port number. If there's a syntax\n             error, leave the incoming address alone, and return 0.\n*/\n\nint\nhost_address_extract_port(uschar *address)\n{\nint port = 0;\nuschar *endptr;\n\n/* Handle the \"bracketed with colon on the end\" format */\n\nif (*address == '[')\n  {\n  uschar *rb = address + 1;\n  while (*rb != 0 && *rb != ']') rb++;\n  if (*rb++ == 0) return 0;        /* Missing ]; leave invalid address */\n  if (*rb == ':')\n    {\n    port = Ustrtol(rb + 1, &endptr, 10);\n    if (*endptr != 0) return 0;    /* Invalid port; leave invalid address */\n    }\n  else if (*rb != 0) return 0;     /* Bad syntax; leave invalid address */\n  memmove(address, address + 1, rb - address - 2);\n  rb[-2] = 0;\n  }\n\n/* Handle the \"dot on the end\" format */\n\nelse\n  {\n  int skip = -3;                   /* Skip 3 dots in IPv4 addresses */\n  address--;\n  while (*(++address) != 0)\n    {\n    int ch = *address;\n    if (ch == ':') skip = 0;       /* Skip 0 dots in IPv6 addresses */\n      else if (ch == '.' && skip++ >= 0) break;\n    }\n  if (*address == 0) return 0;\n  port = Ustrtol(address + 1, &endptr, 10);\n  if (*endptr != 0) return 0;      /* Invalid port; leave invalid address */\n  *address = 0;\n  }\n\nreturn port;\n}\n\n\n/*************************************************\n*         Get port from a host item's name       *\n*************************************************/\n\n/* This function is called when finding the IP address for a host that is in a\nlist of hosts explicitly configured, such as in the manualroute router, or in a\nfallback hosts list. We see if there is a port specification at the end of the\nhost name, and if so, remove it. A minimum length of 3 is required for the\noriginal name; nothing shorter is recognized as having a port.\n\nWe test for a name ending with a sequence of digits; if preceded by colon we\nhave a port if the character before the colon is ] and the name starts with [\nor if there are no other colons in the name (i.e. it's not an IPv6 address).\n\nArguments:  pointer to the host item\nReturns:    a port number or PORT_NONE\n*/\n\nint\nhost_item_get_port(host_item *h)\n{\nconst uschar *p;\nint port, x;\nint len = Ustrlen(h->name);\n\nif (len < 3 || (p = h->name + len - 1, !isdigit(*p))) return PORT_NONE;\n\n/* Extract potential port number */\n\nport = *p-- - '0';\nx = 10;\n\nwhile (p > h->name + 1 && isdigit(*p))\n  {\n  port += (*p-- - '0') * x;\n  x *= 10;\n  }\n\n/* The smallest value of p at this point is h->name + 1. */\n\nif (*p != ':') return PORT_NONE;\n\nif (p[-1] == ']' && h->name[0] == '[')\n  h->name = string_copyn(h->name + 1, p - h->name - 2);\nelse if (Ustrchr(h->name, ':') == p)\n  h->name = string_copyn(h->name, p - h->name);\nelse return PORT_NONE;\n\nDEBUG(D_route|D_host_lookup) debug_printf(\"host=%s port=%d\\n\", h->name, port);\nreturn port;\n}\n\n\n\n#ifndef STAND_ALONE    /* Omit when standalone testing */\n\n/*************************************************\n*     Build sender_fullhost and sender_rcvhost   *\n*************************************************/\n\n/* This function is called when sender_host_name and/or sender_helo_name\nhave been set. Or might have been set - for a local message read off the spool\nthey won't be. In that case, do nothing. Otherwise, set up the fullhost string\nas follows:\n\n(a) No sender_host_name or sender_helo_name: \"[ip address]\"\n(b) Just sender_host_name: \"host_name [ip address]\"\n(c) Just sender_helo_name: \"(helo_name) [ip address]\" unless helo is IP\n            in which case: \"[ip address}\"\n(d) The two are identical: \"host_name [ip address]\" includes helo = IP\n(e) The two are different: \"host_name (helo_name) [ip address]\"\n\nIf log_incoming_port is set, the sending host's port number is added to the IP\naddress.\n\nThis function also builds sender_rcvhost for use in Received: lines, whose\nsyntax is a bit different. This value also includes the RFC 1413 identity.\nThere wouldn't be two different variables if I had got all this right in the\nfirst place.\n\nBecause this data may survive over more than one incoming SMTP message, it has\nto be in permanent store.  However, STARTTLS has to be forgotten and redone\non a multi-message conn, so this will be called once per message then.  Hence\nwe use malloc, so we can free.\n\nArguments:  none\nReturns:    nothing\n*/\n\nvoid\nhost_build_sender_fullhost(void)\n{\nBOOL show_helo = TRUE;\nuschar * address, * fullhost, * rcvhost;\nrmark reset_point;\nint len;\n\nif (!sender_host_address) return;\n\nreset_point = store_mark();\n\n/* Set up address, with or without the port. After discussion, it seems that\nthe only format that doesn't cause trouble is [aaaa]:pppp. However, we can't\nuse this directly as the first item for Received: because it ain't an RFC 2822\ndomain. Sigh. */\n\naddress = string_sprintf(\"[%s]:%d\", sender_host_address, sender_host_port);\nif (!LOGGING(incoming_port) || sender_host_port <= 0)\n  *(Ustrrchr(address, ':')) = 0;\n\n/* If there's no EHLO/HELO data, we can't show it. */\n\nif (!sender_helo_name) show_helo = FALSE;\n\n/* If HELO/EHLO was followed by an IP literal, it's messy because of two\nfeatures of IPv6. Firstly, there's the \"IPv6:\" prefix (Exim is liberal and\ndoesn't require this, for historical reasons). Secondly, IPv6 addresses may not\nbe given in canonical form, so we have to canonicalize them before comparing. As\nit happens, the code works for both IPv4 and IPv6. */\n\nelse if (sender_helo_name[0] == '[' &&\n         sender_helo_name[(len=Ustrlen(sender_helo_name))-1] == ']')\n  {\n  int offset = 1;\n  uschar *helo_ip;\n\n  if (strncmpic(sender_helo_name + 1, US\"IPv6:\", 5) == 0) offset += 5;\n  if (strncmpic(sender_helo_name + 1, US\"IPv4:\", 5) == 0) offset += 5;\n\n  helo_ip = string_copyn(sender_helo_name + offset, len - offset - 1);\n\n  if (string_is_ip_address(helo_ip, NULL) != 0)\n    {\n    int x[4], y[4];\n    int sizex, sizey;\n    uschar ipx[48], ipy[48];    /* large enough for full IPv6 */\n\n    sizex = host_aton(helo_ip, x);\n    sizey = host_aton(sender_host_address, y);\n\n    (void)host_nmtoa(sizex, x, -1, ipx, ':');\n    (void)host_nmtoa(sizey, y, -1, ipy, ':');\n\n    if (strcmpic(ipx, ipy) == 0) show_helo = FALSE;\n    }\n  }\n\n/* Host name is not verified */\n\nif (!sender_host_name)\n  {\n  uschar *portptr = Ustrstr(address, \"]:\");\n  gstring * g;\n  int adlen;    /* Sun compiler doesn't like ++ in initializers */\n\n  adlen = portptr ? (++portptr - address) : Ustrlen(address);\n  fullhost = sender_helo_name\n    ? string_sprintf(\"(%s) %s\", sender_helo_name, address)\n    : address;\n\n  g = string_catn(NULL, address, adlen);\n\n  if (sender_ident || show_helo || portptr)\n    {\n    int firstptr;\n    g = string_catn(g, US\" (\", 2);\n    firstptr = g->ptr;\n\n    if (portptr)\n      g = string_append(g, 2, US\"port=\", portptr + 1);\n\n    if (show_helo)\n      g = string_append(g, 2,\n        firstptr == g->ptr ? US\"helo=\" : US\" helo=\", sender_helo_name);\n\n    if (sender_ident)\n      g = string_append(g, 2,\n        firstptr == g->ptr ? US\"ident=\" : US\" ident=\", sender_ident);\n\n    g = string_catn(g, US\")\", 1);\n    }\n\n  rcvhost = string_from_gstring(g);\n  }\n\n/* Host name is known and verified. Unless we've already found that the HELO\ndata matches the IP address, compare it with the name. */\n\nelse\n  {\n  if (show_helo && strcmpic(sender_host_name, sender_helo_name) == 0)\n    show_helo = FALSE;\n\n  if (show_helo)\n    {\n    fullhost = string_sprintf(\"%s (%s) %s\", sender_host_name,\n      sender_helo_name, address);\n    rcvhost = sender_ident\n      ?  string_sprintf(\"%s\\n\\t(%s helo=%s ident=%s)\", sender_host_name,\n        address, sender_helo_name, sender_ident)\n      : string_sprintf(\"%s (%s helo=%s)\", sender_host_name,\n        address, sender_helo_name);\n    }\n  else\n    {\n    fullhost = string_sprintf(\"%s %s\", sender_host_name, address);\n    rcvhost = sender_ident\n      ?  string_sprintf(\"%s (%s ident=%s)\", sender_host_name, address,\n        sender_ident)\n      : string_sprintf(\"%s (%s)\", sender_host_name, address);\n    }\n  }\n\nsender_fullhost = string_copy_perm(fullhost, TRUE);\nsender_rcvhost = string_copy_perm(rcvhost, TRUE);\n\nstore_reset(reset_point);\n\nDEBUG(D_host_lookup) debug_printf(\"sender_fullhost = %s\\n\", sender_fullhost);\nDEBUG(D_host_lookup) debug_printf(\"sender_rcvhost = %s\\n\", sender_rcvhost);\n}\n\n\n\n/*************************************************\n*          Build host+ident message              *\n*************************************************/\n\n/* Used when logging rejections and various ACL and SMTP incidents. The text\nreturn depends on whether sender_fullhost and sender_ident are set or not:\n\n  no ident, no host   => U=unknown\n  no ident, host set  => H=sender_fullhost\n  ident set, no host  => U=ident\n  ident set, host set => H=sender_fullhost U=ident\n\nUse taint-unchecked routines on the assumption we'll never expand the results.\n\nArguments:\n  useflag   TRUE if first item to be flagged (H= or U=); if there are two\n              items, the second is always flagged\n\nReturns:    pointer to a string in big_buffer\n*/\n\nuschar *\nhost_and_ident(BOOL useflag)\n{\nif (!sender_fullhost)\n  string_format_nt(big_buffer, big_buffer_size, \"%s%s\", useflag ? \"U=\" : \"\",\n     sender_ident ? sender_ident : US\"unknown\");\nelse\n  {\n  uschar * flag = useflag ? US\"H=\" : US\"\";\n  uschar * iface = US\"\";\n  if (LOGGING(incoming_interface) && interface_address)\n    iface = string_sprintf(\" I=[%s]:%d\", interface_address, interface_port);\n  if (sender_ident)\n    string_format_nt(big_buffer, big_buffer_size, \"%s%s%s U=%s\",\n      flag, sender_fullhost, iface, sender_ident);\n  else\n    string_format_nt(big_buffer, big_buffer_size, \"%s%s%s\",\n      flag, sender_fullhost, iface);\n  }\nreturn big_buffer;\n}\n\n#endif   /* STAND_ALONE */\n\n\n\n\n/*************************************************\n*         Build list of local interfaces         *\n*************************************************/\n\n/* This function interprets the contents of the local_interfaces or\nextra_local_interfaces options, and creates an ip_address_item block for each\nitem on the list. There is no special interpretation of any IP addresses; in\nparticular, 0.0.0.0 and ::0 are returned without modification. If any address\nincludes a port, it is set in the block. Otherwise the port value is set to\nzero.\n\nArguments:\n  list        the list\n  name        the name of the option being expanded\n\nReturns:      a chain of ip_address_items, each containing to a textual\n              version of an IP address, and a port number (host order) or\n              zero if no port was given with the address\n*/\n\nip_address_item *\nhost_build_ifacelist(const uschar *list, uschar *name)\n{\nint sep = 0;\nuschar *s;\nip_address_item * yield = NULL, * last = NULL, * next;\nBOOL taint = is_tainted(list);\n\nwhile ((s = string_nextinlist(&list, &sep, NULL, 0)))\n  {\n  int ipv;\n  int port = host_address_extract_port(s);            /* Leaves just the IP address */\n\n  if (!(ipv = string_is_ip_address(s, NULL)))\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"Malformed IP address \\\"%s\\\" in %s\",\n      s, name);\n\n  /* Skip IPv6 addresses if IPv6 is disabled. */\n\n  if (disable_ipv6 && ipv == 6) continue;\n\n  /* This use of strcpy() is OK because we have checked that s is a valid IP\n  address above. The field in the ip_address_item is large enough to hold an\n  IPv6 address. */\n\n  next = store_get(sizeof(ip_address_item), taint);\n  next->next = NULL;\n  Ustrcpy(next->address, s);\n  next->port = port;\n  next->v6_include_v4 = FALSE;\n  next->log = NULL;\n\n  if (!yield)\n    yield = last = next;\n  else\n    {\n    last->next = next;\n    last = next;\n    }\n  }\n\nreturn yield;\n}\n\n\n\n\n\n/*************************************************\n*         Find addresses on local interfaces     *\n*************************************************/\n\n/* This function finds the addresses of local IP interfaces. These are used\nwhen testing for routing to the local host. As the function may be called more\nthan once, the list is preserved in permanent store, pointed to by a static\nvariable, to save doing the work more than once per process.\n\nThe generic list of interfaces is obtained by calling host_build_ifacelist()\nfor local_interfaces and extra_local_interfaces. This list scanned to remove\nduplicates (which may exist with different ports - not relevant here). If\neither of the wildcard IP addresses (0.0.0.0 and ::0) are encountered, they are\nreplaced by the appropriate (IPv4 or IPv6) list of actual local interfaces,\nobtained from os_find_running_interfaces().\n\nArguments:    none\nReturns:      a chain of ip_address_items, each containing to a textual\n              version of an IP address; the port numbers are not relevant\n*/\n\n\n/* First, a local subfunction to add an interface to a list in permanent store,\nbut only if there isn't a previous copy of that address on the list. */\n\nstatic ip_address_item *\nadd_unique_interface(ip_address_item *list, ip_address_item *ipa)\n{\nip_address_item *ipa2;\nfor (ipa2 = list; ipa2; ipa2 = ipa2->next)\n  if (Ustrcmp(ipa2->address, ipa->address) == 0) return list;\nipa2 = store_get_perm(sizeof(ip_address_item), FALSE);\n*ipa2 = *ipa;\nipa2->next = list;\nreturn ipa2;\n}\n\n\n/* This is the globally visible function */\n\nip_address_item *\nhost_find_interfaces(void)\n{\nip_address_item *running_interfaces = NULL;\n\nif (!local_interface_data)\n  {\n  void *reset_item = store_mark();\n  ip_address_item *dlist = host_build_ifacelist(CUS local_interfaces,\n    US\"local_interfaces\");\n  ip_address_item *xlist = host_build_ifacelist(CUS extra_local_interfaces,\n    US\"extra_local_interfaces\");\n  ip_address_item *ipa;\n\n  if (!dlist) dlist = xlist;\n  else\n    {\n    for (ipa = dlist; ipa->next; ipa = ipa->next) ;\n    ipa->next = xlist;\n    }\n\n  for (ipa = dlist; ipa; ipa = ipa->next)\n    {\n    if (Ustrcmp(ipa->address, \"0.0.0.0\") == 0 ||\n        Ustrcmp(ipa->address, \"::0\") == 0)\n      {\n      BOOL ipv6 = ipa->address[0] == ':';\n      if (!running_interfaces)\n        running_interfaces = os_find_running_interfaces();\n      for (ip_address_item * ipa2 = running_interfaces; ipa2; ipa2 = ipa2->next)\n        if ((Ustrchr(ipa2->address, ':') != NULL) == ipv6)\n          local_interface_data = add_unique_interface(local_interface_data,\n\t\t\t\t\t\t      ipa2);\n      }\n    else\n      {\n      local_interface_data = add_unique_interface(local_interface_data, ipa);\n      DEBUG(D_interface)\n        {\n        debug_printf(\"Configured local interface: address=%s\", ipa->address);\n        if (ipa->port != 0) debug_printf(\" port=%d\", ipa->port);\n        debug_printf(\"\\n\");\n        }\n      }\n    }\n  store_reset(reset_item);\n  }\n\nreturn local_interface_data;\n}\n\n\n\n\n\n/*************************************************\n*        Convert network IP address to text      *\n*************************************************/\n\n/* Given an IPv4 or IPv6 address in binary, convert it to a text\nstring and return the result in a piece of new store. The address can\neither be given directly, or passed over in a sockaddr structure. Note\nthat this isn't the converse of host_aton() because of byte ordering\ndifferences. See host_nmtoa() below.\n\nArguments:\n  type       if < 0 then arg points to a sockaddr, else\n             either AF_INET or AF_INET6\n  arg        points to a sockaddr if type is < 0, or\n             points to an IPv4 address (32 bits), or\n             points to an IPv6 address (128 bits),\n             in both cases, in network byte order\n  buffer     if NULL, the result is returned in gotten store;\n             else points to a buffer to hold the answer\n  portptr    points to where to put the port number, if non NULL; only\n             used when type < 0\n\nReturns:     pointer to character string\n*/\n\nuschar *\nhost_ntoa(int type, const void *arg, uschar *buffer, int *portptr)\n{\nuschar *yield;\n\n/* The new world. It is annoying that we have to fish out the address from\ndifferent places in the block, depending on what kind of address it is. It\nis also a pain that inet_ntop() returns a const uschar *, whereas the IPv4\nfunction inet_ntoa() returns just uschar *, and some picky compilers insist\non warning if one assigns a const uschar * to a uschar *. Hence the casts. */\n\n#if HAVE_IPV6\nuschar addr_buffer[46];\nif (type < 0)\n  {\n  int family = ((struct sockaddr *)arg)->sa_family;\n  if (family == AF_INET6)\n    {\n    struct sockaddr_in6 *sk = (struct sockaddr_in6 *)arg;\n    yield = US inet_ntop(family, &(sk->sin6_addr), CS addr_buffer,\n      sizeof(addr_buffer));\n    if (portptr != NULL) *portptr = ntohs(sk->sin6_port);\n    }\n  else\n    {\n    struct sockaddr_in *sk = (struct sockaddr_in *)arg;\n    yield = US inet_ntop(family, &(sk->sin_addr), CS addr_buffer,\n      sizeof(addr_buffer));\n    if (portptr != NULL) *portptr = ntohs(sk->sin_port);\n    }\n  }\nelse\n  {\n  yield = US inet_ntop(type, arg, CS addr_buffer, sizeof(addr_buffer));\n  }\n\n/* If the result is a mapped IPv4 address, show it in V4 format. */\n\nif (Ustrncmp(yield, \"::ffff:\", 7) == 0) yield += 7;\n\n#else  /* HAVE_IPV6 */\n\n/* The old world */\n\nif (type < 0)\n  {\n  yield = US inet_ntoa(((struct sockaddr_in *)arg)->sin_addr);\n  if (portptr != NULL) *portptr = ntohs(((struct sockaddr_in *)arg)->sin_port);\n  }\nelse\n  yield = US inet_ntoa(*((struct in_addr *)arg));\n#endif\n\n/* If there is no buffer, put the string into some new store. */\n\nif (!buffer) buffer = store_get(46, FALSE);\n\n/* Callers of this function with a non-NULL buffer must ensure that it is\nlarge enough to hold an IPv6 address, namely, at least 46 bytes. That's what\nmakes this use of strcpy() OK.\nIf the library returned apparently an apparently tainted string, clean it;\nwe trust IP addresses. */\n\nstring_format_nt(buffer, 46, \"%s\", yield);\nreturn buffer;\n}\n\n\n\n\n/*************************************************\n*         Convert address text to binary         *\n*************************************************/\n\n/* Given the textual form of an IP address, convert it to binary in an\narray of ints. IPv4 addresses occupy one int; IPv6 addresses occupy 4 ints.\nThe result has the first byte in the most significant byte of the first int. In\nother words, the result is not in network byte order, but in host byte order.\nAs a result, this is not the converse of host_ntoa(), which expects network\nbyte order. See host_nmtoa() below.\n\nArguments:\n  address    points to the textual address, checked for syntax\n  bin        points to an array of 4 ints\n\nReturns:     the number of ints used\n*/\n\nint\nhost_aton(const uschar *address, int *bin)\n{\nint x[4];\nint v4offset = 0;\n\n/* Handle IPv6 address, which may end with an IPv4 address. It may also end\nwith a \"scope\", introduced by a percent sign. This code is NOT enclosed in #if\nHAVE_IPV6 in order that IPv6 addresses are recognized even if IPv6 is not\nsupported. */\n\nif (Ustrchr(address, ':') != NULL)\n  {\n  const uschar *p = address;\n  const uschar *component[8];\n  BOOL ipv4_ends = FALSE;\n  int ci = 0;\n  int nulloffset = 0;\n  int v6count = 8;\n  int i;\n\n  /* If the address starts with a colon, it will start with two colons.\n  Just lose the first one, which will leave a null first component. */\n\n  if (*p == ':') p++;\n\n  /* Split the address into components separated by colons. The input address\n  is supposed to be checked for syntax. There was a case where this was\n  overlooked; to guard against that happening again, check here and crash if\n  there are too many components. */\n\n  while (*p != 0 && *p != '%')\n    {\n    int len = Ustrcspn(p, \":%\");\n    if (len == 0) nulloffset = ci;\n    if (ci > 7) log_write(0, LOG_MAIN|LOG_PANIC_DIE,\n      \"Internal error: invalid IPv6 address \\\"%s\\\" passed to host_aton()\",\n      address);\n    component[ci++] = p;\n    p += len;\n    if (*p == ':') p++;\n    }\n\n  /* If the final component contains a dot, it is a trailing v4 address.\n  As the syntax is known to be checked, just set up for a trailing\n  v4 address and restrict the v6 part to 6 components. */\n\n  if (Ustrchr(component[ci-1], '.') != NULL)\n    {\n    address = component[--ci];\n    ipv4_ends = TRUE;\n    v4offset = 3;\n    v6count = 6;\n    }\n\n  /* If there are fewer than 6 or 8 components, we have to insert some\n  more empty ones in the middle. */\n\n  if (ci < v6count)\n    {\n    int insert_count = v6count - ci;\n    for (i = v6count-1; i > nulloffset + insert_count; i--)\n      component[i] = component[i - insert_count];\n    while (i > nulloffset) component[i--] = US\"\";\n    }\n\n  /* Now turn the components into binary in pairs and bung them\n  into the vector of ints. */\n\n  for (i = 0; i < v6count; i += 2)\n    bin[i/2] = (Ustrtol(component[i], NULL, 16) << 16) +\n      Ustrtol(component[i+1], NULL, 16);\n\n  /* If there was no terminating v4 component, we are done. */\n\n  if (!ipv4_ends) return 4;\n  }\n\n/* Handle IPv4 address */\n\n(void)sscanf(CS address, \"%d.%d.%d.%d\", x, x+1, x+2, x+3);\nbin[v4offset] = ((uint)x[0] << 24) + (x[1] << 16) + (x[2] << 8) + x[3];\nreturn v4offset+1;\n}\n\n\n/*************************************************\n*           Apply mask to an IP address          *\n*************************************************/\n\n/* Mask an address held in 1 or 4 ints, with the ms bit in the ms bit of the\nfirst int, etc.\n\nArguments:\n  count        the number of ints\n  binary       points to the ints to be masked\n  mask         the count of ms bits to leave, or -1 if no masking\n\nReturns:       nothing\n*/\n\nvoid\nhost_mask(int count, int *binary, int mask)\n{\nif (mask < 0) mask = 99999;\nfor (int i = 0; i < count; i++)\n  {\n  int wordmask;\n  if (mask == 0) wordmask = 0;\n  else if (mask < 32)\n    {\n    wordmask = (uint)(-1) << (32 - mask);\n    mask = 0;\n    }\n  else\n    {\n    wordmask = -1;\n    mask -= 32;\n    }\n  binary[i] &= wordmask;\n  }\n}\n\n\n\n\n/*************************************************\n*     Convert masked IP address in ints to text  *\n*************************************************/\n\n/* We can't use host_ntoa() because it assumes the binary values are in network\nbyte order, and these are the result of host_aton(), which puts them in ints in\nhost byte order. Also, we really want IPv6 addresses to be in a canonical\nformat, so we output them with no abbreviation. In a number of cases we can't\nuse the normal colon separator in them because it terminates keys in lsearch\nfiles, so we want to use dot instead. There's an argument that specifies what\nto use for IPv6 addresses.\n\nArguments:\n  count       1 or 4 (number of ints)\n  binary      points to the ints\n  mask        mask value; if < 0 don't add to result\n  buffer      big enough to hold the result\n  sep         component separator character for IPv6 addresses\n\nReturns:      the number of characters placed in buffer, not counting\n              the final nul.\n*/\n\nint\nhost_nmtoa(int count, int *binary, int mask, uschar *buffer, int sep)\n{\nint j;\nuschar *tt = buffer;\n\nif (count == 1)\n  {\n  j = binary[0];\n  for (int i = 24; i >= 0; i -= 8)\n    tt += sprintf(CS tt, \"%d.\", (j >> i) & 255);\n  }\nelse\n  for (int i = 0; i < 4; i++)\n    {\n    j = binary[i];\n    tt += sprintf(CS tt, \"%04x%c%04x%c\", (j >> 16) & 0xffff, sep, j & 0xffff, sep);\n    }\n\ntt--;   /* lose final separator */\n\nif (mask < 0)\n  *tt = 0;\nelse\n  tt += sprintf(CS tt, \"/%d\", mask);\n\nreturn tt - buffer;\n}\n\n\n/* Like host_nmtoa() but: ipv6-only, canonical output, no mask\n\nArguments:\n  binary      points to the ints\n  buffer      big enough to hold the result\n\nReturns:      the number of characters placed in buffer, not counting\n\t      the final nul.\n*/\n\nint\nipv6_nmtoa(int * binary, uschar * buffer)\n{\nint i, j, k;\nuschar * c = buffer;\nuschar * d = NULL;\t/* shut insufficiently \"clever\" compiler up */\n\nfor (i = 0; i < 4; i++)\n  {\t\t\t/* expand to text */\n  j = binary[i];\n  c += sprintf(CS c, \"%x:%x:\", (j >> 16) & 0xffff, j & 0xffff);\n  }\n\nfor (c = buffer, k = -1, i = 0; i < 8; i++)\n  {\t\t\t/* find longest 0-group sequence */\n  if (*c == '0')\t/* must be \"0:\" */\n    {\n    uschar * s = c;\n    j = i;\n    while (c[2] == '0') i++, c += 2;\n    if (i-j > k)\n      {\n      k = i-j;\t\t/* length of sequence */\n      d = s;\t\t/* start of sequence */\n      }\n    }\n  while (*++c != ':') ;\n  c++;\n  }\n\n*--c = '\\0';\t/* drop trailing colon */\n\n/* debug_printf(\"%s: D k %d <%s> <%s>\\n\", __FUNCTION__, k, buffer, buffer + 2*(k+1)); */\nif (k >= 0)\n  {\t\t\t/* collapse */\n  c = d + 2*(k+1);\n  if (d == buffer) c--;\t/* need extra colon */\n  *d++ = ':';\t/* 1st 0 */\n  while ((*d++ = *c++)) ;\n  }\nelse\n  d = c;\n\nreturn d - buffer;\n}\n\n\n\n/*************************************************\n*        Check port for tls_on_connect           *\n*************************************************/\n\n/* This function checks whether a given incoming port is configured for tls-\non-connect. It is called from the daemon and from inetd handling. If the global\noption tls_on_connect is already set, all ports operate this way. Otherwise, we\ncheck the tls_on_connect_ports option for a list of ports.\n\nArgument:  a port number\nReturns:   TRUE or FALSE\n*/\n\nBOOL\nhost_is_tls_on_connect_port(int port)\n{\nint sep = 0;\nconst uschar * list = tls_in.on_connect_ports;\n\nif (tls_in.on_connect) return TRUE;\n\nfor (uschar * s, * end; s = string_nextinlist(&list, &sep, NULL, 0); )\n  if (Ustrtol(s, &end, 10) == port)\n    return TRUE;\n\nreturn FALSE;\n}\n\n\n\n/*************************************************\n*        Check whether host is in a network      *\n*************************************************/\n\n/* This function checks whether a given IP address matches a pattern that\nrepresents either a single host, or a network (using CIDR notation). The caller\nof this function must check the syntax of the arguments before calling it.\n\nArguments:\n  host        string representation of the ip-address to check\n  net         string representation of the network, with optional CIDR mask\n  maskoffset  offset to the / that introduces the mask in the key\n              zero if there is no mask\n\nReturns:\n  TRUE   the host is inside the network\n  FALSE  the host is NOT inside the network\n*/\n\nBOOL\nhost_is_in_net(const uschar *host, const uschar *net, int maskoffset)\n{\nint address[4];\nint incoming[4];\nint mlen;\nint size = host_aton(net, address);\nint insize;\n\n/* No mask => all bits to be checked */\n\nif (maskoffset == 0) mlen = 99999;    /* Big number */\n  else mlen = Uatoi(net + maskoffset + 1);\n\n/* Convert the incoming address to binary. */\n\ninsize = host_aton(host, incoming);\n\n/* Convert IPv4 addresses given in IPv6 compatible mode, which represent\n   connections from IPv4 hosts to IPv6 hosts, that is, addresses of the form\n   ::ffff:<v4address>, to IPv4 format. */\n\nif (insize == 4 && incoming[0] == 0 && incoming[1] == 0 &&\n    incoming[2] == 0xffff)\n  {\n  insize = 1;\n  incoming[0] = incoming[3];\n  }\n\n/* No match if the sizes don't agree. */\n\nif (insize != size) return FALSE;\n\n/* Else do the masked comparison. */\n\nfor (int i = 0; i < size; i++)\n  {\n  int mask;\n  if (mlen == 0) mask = 0;\n  else if (mlen < 32)\n    {\n    mask = (uint)(-1) << (32 - mlen);\n    mlen = 0;\n    }\n  else\n    {\n    mask = -1;\n    mlen -= 32;\n    }\n  if ((incoming[i] & mask) != (address[i] & mask)) return FALSE;\n  }\n\nreturn TRUE;\n}\n\n\n\n/*************************************************\n*       Scan host list for local hosts           *\n*************************************************/\n\n/* Scan through a chain of addresses and check whether any of them is the\naddress of an interface on the local machine. If so, remove that address and\nany previous ones with the same MX value, and all subsequent ones (which will\nhave greater or equal MX values) from the chain. Note: marking them as unusable\nis NOT the right thing to do because it causes the hosts not to be used for\nother domains, for which they may well be correct.\n\nThe hosts may be part of a longer chain; we only process those between the\ninitial pointer and the \"last\" pointer.\n\nThere is also a list of \"pseudo-local\" host names which are checked against the\nhost names. Any match causes that host item to be treated the same as one which\nmatches a local IP address.\n\nIf the very first host is a local host, then all MX records had a precedence\ngreater than or equal to that of the local host. Either there's a problem in\nthe DNS, or an apparently remote name turned out to be an abbreviation for the\nlocal host. Give a specific return code, and let the caller decide what to do.\nOtherwise, give a success code if at least one host address has been found.\n\nArguments:\n  host        pointer to the first host in the chain\n  lastptr     pointer to pointer to the last host in the chain (may be updated)\n  removed     if not NULL, set TRUE if some local addresses were removed\n                from the list\n\nReturns:\n  HOST_FOUND       if there is at least one host with an IP address on the chain\n                     and an MX value less than any MX value associated with the\n                     local host\n  HOST_FOUND_LOCAL if a local host is among the lowest-numbered MX hosts; when\n                     the host addresses were obtained from A records or\n                     gethostbyname(), the MX values are set to -1.\n  HOST_FIND_FAILED if no valid hosts with set IP addresses were found\n*/\n\nint\nhost_scan_for_local_hosts(host_item *host, host_item **lastptr, BOOL *removed)\n{\nint yield = HOST_FIND_FAILED;\nhost_item *last = *lastptr;\nhost_item *prev = NULL;\nhost_item *h;\n\nif (removed != NULL) *removed = FALSE;\n\nif (local_interface_data == NULL) local_interface_data = host_find_interfaces();\n\nfor (h = host; h != last->next; h = h->next)\n  {\n  #ifndef STAND_ALONE\n  if (hosts_treat_as_local != NULL)\n    {\n    int rc;\n    const uschar *save = deliver_domain;\n    deliver_domain = h->name;   /* set $domain */\n    rc = match_isinlist(string_copylc(h->name), CUSS &hosts_treat_as_local, 0,\n      &domainlist_anchor, NULL, MCL_DOMAIN, TRUE, NULL);\n    deliver_domain = save;\n    if (rc == OK) goto FOUND_LOCAL;\n    }\n  #endif\n\n  /* It seems that on many operating systems, 0.0.0.0 is treated as a synonym\n  for 127.0.0.1 and refers to the local host. We therefore force it always to\n  be treated as local. */\n\n  if (h->address != NULL)\n    {\n    if (Ustrcmp(h->address, \"0.0.0.0\") == 0) goto FOUND_LOCAL;\n    for (ip_address_item * ip = local_interface_data; ip; ip = ip->next)\n      if (Ustrcmp(h->address, ip->address) == 0) goto FOUND_LOCAL;\n    yield = HOST_FOUND;  /* At least one remote address has been found */\n    }\n\n  /* Update prev to point to the last host item before any that have\n  the same MX value as the one we have just considered. */\n\n  if (h->next == NULL || h->next->mx != h->mx) prev = h;\n  }\n\nreturn yield;  /* No local hosts found: return HOST_FOUND or HOST_FIND_FAILED */\n\n/* A host whose IP address matches a local IP address, or whose name matches\nsomething in hosts_treat_as_local has been found. */\n\nFOUND_LOCAL:\n\nif (prev == NULL)\n  {\n  HDEBUG(D_host_lookup) debug_printf((h->mx >= 0)?\n    \"local host has lowest MX\\n\" :\n    \"local host found for non-MX address\\n\");\n  return HOST_FOUND_LOCAL;\n  }\n\nHDEBUG(D_host_lookup)\n  {\n  debug_printf(\"local host in host list - removed hosts:\\n\");\n  for (h = prev->next; h != last->next; h = h->next)\n    debug_printf(\"  %s %s %d\\n\", h->name, h->address, h->mx);\n  }\n\nif (removed != NULL) *removed = TRUE;\nprev->next = last->next;\n*lastptr = prev;\nreturn yield;\n}\n\n\n\n\n/*************************************************\n*        Remove duplicate IPs in host list       *\n*************************************************/\n\n/* You would think that administrators could set up their DNS records so that\none ended up with a list of unique IP addresses after looking up A or MX\nrecords, but apparently duplication is common. So we scan such lists and\nremove the later duplicates. Note that we may get lists in which some host\naddresses are not set.\n\nArguments:\n  host        pointer to the first host in the chain\n  lastptr     pointer to pointer to the last host in the chain (may be updated)\n\nReturns:      nothing\n*/\n\nstatic void\nhost_remove_duplicates(host_item *host, host_item **lastptr)\n{\nwhile (host != *lastptr)\n  {\n  if (host->address != NULL)\n    {\n    host_item *h = host;\n    while (h != *lastptr)\n      {\n      if (h->next->address != NULL &&\n          Ustrcmp(h->next->address, host->address) == 0)\n        {\n        DEBUG(D_host_lookup) debug_printf(\"duplicate IP address %s (MX=%d) \"\n          \"removed\\n\", host->address, h->next->mx);\n        if (h->next == *lastptr) *lastptr = h;\n        h->next = h->next->next;\n        }\n      else h = h->next;\n      }\n    }\n  /* If the last item was removed, host may have become == *lastptr */\n  if (host != *lastptr) host = host->next;\n  }\n}\n\n\n\n\n/*************************************************\n*    Find sender host name by gethostbyaddr()    *\n*************************************************/\n\n/* This used to be the only way it was done, but it turns out that not all\nsystems give aliases for calls to gethostbyaddr() - or one of the modern\nequivalents like getipnodebyaddr(). Fortunately, multiple PTR records are rare,\nbut they can still exist. This function is now used only when a DNS lookup of\nthe IP address fails, in order to give access to /etc/hosts.\n\nArguments:   none\nReturns:     OK, DEFER, FAIL\n*/\n\nstatic int\nhost_name_lookup_byaddr(void)\n{\nstruct hostent * hosts;\nstruct in_addr addr;\nunsigned long time_msec = 0;\t/* init to quieten dumb static analysis */\n\nif (slow_lookup_log) time_msec = get_time_in_ms();\n\n/* Lookup on IPv6 system */\n\n#if HAVE_IPV6\nif (Ustrchr(sender_host_address, ':') != NULL)\n  {\n  struct in6_addr addr6;\n  if (inet_pton(AF_INET6, CS sender_host_address, &addr6) != 1)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"unable to parse \\\"%s\\\" as an \"\n      \"IPv6 address\", sender_host_address);\n  #if HAVE_GETIPNODEBYADDR\n  hosts = getipnodebyaddr(CS &addr6, sizeof(addr6), AF_INET6, &h_errno);\n  #else\n  hosts = gethostbyaddr(CS &addr6, sizeof(addr6), AF_INET6);\n  #endif\n  }\nelse\n  {\n  if (inet_pton(AF_INET, CS sender_host_address, &addr) != 1)\n    log_write(0, LOG_MAIN|LOG_PANIC_DIE, \"unable to parse \\\"%s\\\" as an \"\n      \"IPv4 address\", sender_host_address);\n  #if HAVE_GETIPNODEBYADDR\n  hosts = getipnodebyaddr(CS &addr, sizeof(addr), AF_INET, &h_errno);\n  #else\n  hosts = gethostbyaddr(CS &addr, sizeof(addr), AF_INET);\n  #endif\n  }\n\n/* Do lookup on IPv4 system */\n\n#else\naddr.s_addr = (S_ADDR_TYPE)inet_addr(CS sender_host_address);\nhosts = gethostbyaddr(CS(&addr), sizeof(addr), AF_INET);\n#endif\n\nif (  slow_lookup_log\n   && (time_msec = get_time_in_ms() - time_msec) > slow_lookup_log\n   )\n  log_long_lookup(US\"gethostbyaddr\", sender_host_address, time_msec);\n\n/* Failed to look up the host. */\n\nif (!hosts)\n  {\n  HDEBUG(D_host_lookup) debug_printf(\"IP address lookup failed: h_errno=%d\\n\",\n    h_errno);\n  return (h_errno == TRY_AGAIN || h_errno == NO_RECOVERY) ? DEFER : FAIL;\n  }\n\n/* It seems there are some records in the DNS that yield an empty name. We\ntreat this as non-existent. In some operating systems, this is returned as an\nempty string; in others as a single dot. */\n\nif (!hosts->h_name || !hosts->h_name[0] || hosts->h_name[0] == '.')\n  {\n  HDEBUG(D_host_lookup) debug_printf(\"IP address lookup yielded an empty name: \"\n    \"treated as non-existent host name\\n\");\n  return FAIL;\n  }\n\n/* Copy and lowercase the name, which is in static storage in many systems.\nPut it in permanent memory. */\n\n  {\n  int old_pool = store_pool;\n  store_pool = POOL_TAINT_PERM;\t\t/* names are tainted */\n\n  sender_host_name = string_copylc(US hosts->h_name);\n\n  /* If the host has aliases, build a copy of the alias list */\n\n  if (hosts->h_aliases)\n    {\n    int count = 1;  /* need 1 more for terminating NULL */\n    uschar **ptr;\n\n    for (uschar ** aliases = USS hosts->h_aliases; *aliases; aliases++) count++;\n    store_pool = POOL_PERM;\n    ptr = sender_host_aliases = store_get(count * sizeof(uschar *), FALSE);\n    store_pool = POOL_TAINT_PERM;\n\n    for (uschar ** aliases = USS hosts->h_aliases; *aliases; aliases++)\n      *ptr++ = string_copylc(*aliases);\n    *ptr = NULL;\n    }\n  store_pool = old_pool;\n  }\n\nreturn OK;\n}\n\n\n\n/*************************************************\n*        Find host name for incoming call        *\n*************************************************/\n\n/* Put the name in permanent store, pointed to by sender_host_name. We also set\nup a list of alias names, pointed to by sender_host_alias. The list is\nNULL-terminated. The incoming address is in sender_host_address, either in\ndotted-quad form for IPv4 or in colon-separated form for IPv6.\n\nThis function does a thorough check that the names it finds point back to the\nincoming IP address. Any that do not are discarded. Note that this is relied on\nby the ACL reverse_host_lookup check.\n\nOn some systems, get{host,ipnode}byaddr() appears to do this internally, but\nthis it not universally true. Also, for release 4.30, this function was changed\nto do a direct DNS lookup first, by default[1], because it turns out that that\nis the only guaranteed way to find all the aliases on some systems. My\nexperiments indicate that Solaris gethostbyaddr() gives the aliases for but\nLinux does not.\n\n[1] The actual order is controlled by the host_lookup_order option.\n\nArguments:    none\nReturns:      OK on success, the answer being placed in the global variable\n                sender_host_name, with any aliases in a list hung off\n                sender_host_aliases\n              FAIL if no host name can be found\n              DEFER if a temporary error was encountered\n\nThe variable host_lookup_msg is set to an empty string on success, or to a\nreason for the failure otherwise, in a form suitable for tagging onto an error\nmessage, and also host_lookup_failed is set TRUE if the lookup failed. If there\nwas a defer, host_lookup_deferred is set TRUE.\n\nAny dynamically constructed string for host_lookup_msg must be in permanent\nstore, because it might be used for several incoming messages on the same SMTP\nconnection. */\n\nint\nhost_name_lookup(void)\n{\nint old_pool, rc;\nint sep = 0;\nuschar *save_hostname;\nuschar **aliases;\nuschar *ordername;\nconst uschar *list = host_lookup_order;\ndns_answer * dnsa = store_get_dns_answer();\ndns_scan dnss;\n\nsender_host_dnssec = host_lookup_deferred = host_lookup_failed = FALSE;\n\nHDEBUG(D_host_lookup)\n  debug_printf(\"looking up host name for %s\\n\", sender_host_address);\n\n/* For testing the case when a lookup does not complete, we have a special\nreserved IP address. */\n\nif (f.running_in_test_harness &&\n    Ustrcmp(sender_host_address, \"99.99.99.99\") == 0)\n  {\n  HDEBUG(D_host_lookup)\n    debug_printf(\"Test harness: host name lookup returns DEFER\\n\");\n  host_lookup_deferred = TRUE;\n  return DEFER;\n  }\n\n/* Do lookups directly in the DNS or via gethostbyaddr() (or equivalent), in\nthe order specified by the host_lookup_order option. */\n\nwhile ((ordername = string_nextinlist(&list, &sep, NULL, 0)))\n  {\n  if (strcmpic(ordername, US\"bydns\") == 0)\n    {\n    uschar * name = dns_build_reverse(sender_host_address);\n\n    dns_init(FALSE, FALSE, FALSE);    /* dnssec ctrl by dns_dnssec_ok glbl */\n    rc = dns_lookup_timerwrap(dnsa, name, T_PTR, NULL);\n\n    /* The first record we come across is used for the name; others are\n    considered to be aliases. We have to scan twice, in order to find out the\n    number of aliases. However, if all the names are empty, we will behave as\n    if failure. (PTR records that yield empty names have been encountered in\n    the DNS.) */\n\n    if (rc == DNS_SUCCEED)\n      {\n      uschar **aptr = NULL;\n      int ssize = 264;\n      int count = 1;  /* need 1 more for terminating NULL */\n      int old_pool = store_pool;\n\n      sender_host_dnssec = dns_is_secure(dnsa);\n      DEBUG(D_dns)\n        debug_printf(\"Reverse DNS security status: %s\\n\",\n            sender_host_dnssec ? \"DNSSEC verified (AD)\" : \"unverified\");\n\n      store_pool = POOL_PERM;        /* Save names in permanent storage */\n\n      for (dns_record * rr = dns_next_rr(dnsa, &dnss, RESET_ANSWERS);\n           rr;\n           rr = dns_next_rr(dnsa, &dnss, RESET_NEXT)) if (rr->type == T_PTR)\n\tcount++;\n\n      /* Get store for the list of aliases. For compatibility with\n      gethostbyaddr, we make an empty list if there are none. */\n\n      aptr = sender_host_aliases = store_get(count * sizeof(uschar *), FALSE);\n\n      /* Re-scan and extract the names */\n\n      for (dns_record * rr = dns_next_rr(dnsa, &dnss, RESET_ANSWERS);\n           rr;\n           rr = dns_next_rr(dnsa, &dnss, RESET_NEXT)) if (rr->type == T_PTR)\n        {\n        uschar * s = store_get(ssize, TRUE);\t/* names are tainted */\n\n        /* If an overlong response was received, the data will have been\n        truncated and dn_expand may fail. */\n\n        if (dn_expand(dnsa->answer, dnsa->answer + dnsa->answerlen,\n             US (rr->data), (DN_EXPAND_ARG4_TYPE)(s), ssize) < 0)\n          {\n          log_write(0, LOG_MAIN, \"host name alias list truncated for %s\",\n            sender_host_address);\n          break;\n          }\n\n        store_release_above(s + Ustrlen(s) + 1);\n        if (!s[0])\n          {\n          HDEBUG(D_host_lookup) debug_printf(\"IP address lookup yielded an \"\n            \"empty name: treated as non-existent host name\\n\");\n          continue;\n          }\n        if (!sender_host_name) sender_host_name = s;\n\telse *aptr++ = s;\n        while (*s) { *s = tolower(*s); s++; }\n        }\n\n      *aptr = NULL;            /* End of alias list */\n      store_pool = old_pool;   /* Reset store pool */\n\n      /* If we've found a name, break out of the \"order\" loop */\n\n      if (sender_host_name) break;\n      }\n\n    /* If the DNS lookup deferred, we must also defer. */\n\n    if (rc == DNS_AGAIN)\n      {\n      HDEBUG(D_host_lookup)\n        debug_printf(\"IP address PTR lookup gave temporary error\\n\");\n      host_lookup_deferred = TRUE;\n      return DEFER;\n      }\n    }\n\n  /* Do a lookup using gethostbyaddr() - or equivalent */\n\n  else if (strcmpic(ordername, US\"byaddr\") == 0)\n    {\n    HDEBUG(D_host_lookup)\n      debug_printf(\"IP address lookup using gethostbyaddr()\\n\");\n    rc = host_name_lookup_byaddr();\n    if (rc == DEFER)\n      {\n      host_lookup_deferred = TRUE;\n      return rc;                       /* Can't carry on */\n      }\n    if (rc == OK) break;               /* Found a name */\n    }\n  }      /* Loop for bydns/byaddr scanning */\n\n/* If we have failed to find a name, return FAIL and log when required.\nNB host_lookup_msg must be in permanent store.  */\n\nif (!sender_host_name)\n  {\n  if (host_checking || !f.log_testing_mode)\n    log_write(L_host_lookup_failed, LOG_MAIN, \"no host name found for IP \"\n      \"address %s\", sender_host_address);\n  host_lookup_msg = US\" (failed to find host name from IP address)\";\n  host_lookup_failed = TRUE;\n  return FAIL;\n  }\n\nHDEBUG(D_host_lookup)\n  {\n  uschar **aliases = sender_host_aliases;\n  debug_printf(\"IP address lookup yielded \\\"%s\\\"\\n\", sender_host_name);\n  while (*aliases != NULL) debug_printf(\"  alias \\\"%s\\\"\\n\", *aliases++);\n  }\n\n/* We need to verify that a forward lookup on the name we found does indeed\ncorrespond to the address. This is for security: in principle a malefactor who\nhappened to own a reverse zone could set it to point to any names at all.\n\nThis code was present in versions of Exim before 3.20. At that point I took it\nout because I thought that gethostbyaddr() did the check anyway. It turns out\nthat this isn't always the case, so it's coming back in at 4.01. This version\nis actually better, because it also checks aliases.\n\nThe code was made more robust at release 4.21. Prior to that, it accepted all\nthe names if any of them had the correct IP address. Now the code checks all\nthe names, and accepts only those that have the correct IP address. */\n\nsave_hostname = sender_host_name;   /* Save for error messages */\naliases = sender_host_aliases;\nfor (uschar * hname = sender_host_name; hname; hname = *aliases++)\n  {\n  int rc;\n  BOOL ok = FALSE;\n  host_item h = { .next = NULL, .name = hname, .mx = MX_NONE, .address = NULL };\n  dnssec_domains d =\n    { .request = sender_host_dnssec ? US\"*\" : NULL, .require = NULL };\n\n  if (  (rc = host_find_bydns(&h, NULL, HOST_FIND_BY_A | HOST_FIND_BY_AAAA,\n\t  NULL, NULL, NULL, &d, NULL, NULL)) == HOST_FOUND\n     || rc == HOST_FOUND_LOCAL\n     )\n    {\n    HDEBUG(D_host_lookup) debug_printf(\"checking addresses for %s\\n\", hname);\n\n    /* If the forward lookup was not secure we cancel the is-secure variable */\n\n    DEBUG(D_dns) debug_printf(\"Forward DNS security status: %s\\n\",\n\t  h.dnssec == DS_YES ? \"DNSSEC verified (AD)\" : \"unverified\");\n    if (h.dnssec != DS_YES) sender_host_dnssec = FALSE;\n\n    for (host_item * hh = &h; hh; hh = hh->next)\n      if (host_is_in_net(hh->address, sender_host_address, 0))\n        {\n        HDEBUG(D_host_lookup) debug_printf(\"  %s OK\\n\", hh->address);\n        ok = TRUE;\n        break;\n        }\n      else\n        HDEBUG(D_host_lookup) debug_printf(\"  %s\\n\", hh->address);\n\n    if (!ok) HDEBUG(D_host_lookup)\n      debug_printf(\"no IP address for %s matched %s\\n\", hname,\n        sender_host_address);\n    }\n  else if (rc == HOST_FIND_AGAIN)\n    {\n    HDEBUG(D_host_lookup) debug_printf(\"temporary error for host name lookup\\n\");\n    host_lookup_deferred = TRUE;\n    sender_host_name = NULL;\n    return DEFER;\n    }\n  else\n    HDEBUG(D_host_lookup) debug_printf(\"no IP addresses found for %s\\n\", hname);\n\n  /* If this name is no good, and it's the sender name, set it null pro tem;\n  if it's an alias, just remove it from the list. */\n\n  if (!ok)\n    {\n    if (hname == sender_host_name) sender_host_name = NULL; else\n      {\n      uschar **a;                              /* Don't amalgamate - some */\n      a = --aliases;                           /* compilers grumble */\n      while (*a != NULL) { *a = a[1]; a++; }\n      }\n    }\n  }\n\n/* If sender_host_name == NULL, it means we didn't like the name. Replace\nit with the first alias, if there is one. */\n\nif (sender_host_name == NULL && *sender_host_aliases != NULL)\n  sender_host_name = *sender_host_aliases++;\n\n/* If we now have a main name, all is well. */\n\nif (sender_host_name != NULL) return OK;\n\n/* We have failed to find an address that matches. */\n\nHDEBUG(D_host_lookup)\n  debug_printf(\"%s does not match any IP address for %s\\n\",\n    sender_host_address, save_hostname);\n\n/* This message must be in permanent store */\n\nold_pool = store_pool;\nstore_pool = POOL_PERM;\nhost_lookup_msg = string_sprintf(\" (%s does not match any IP address for %s)\",\n  sender_host_address, save_hostname);\nstore_pool = old_pool;\nhost_lookup_failed = TRUE;\nreturn FAIL;\n}\n\n\n\n\n/*************************************************\n*    Find IP address(es) for host by name        *\n*************************************************/\n\n/* The input is a host_item structure with the name filled in and the address\nfield set to NULL. We use gethostbyname() or getipnodebyname() or\ngethostbyname2(), as appropriate. Of course, these functions may use the DNS,\nbut they do not do MX processing. It appears, however, that in some systems the\ncurrent setting of resolver options is used when one of these functions calls\nthe resolver. For this reason, we call dns_init() at the start, with arguments\ninfluenced by bits in \"flags\", just as we do for host_find_bydns().\n\nThe second argument provides a host list (usually an IP list) of hosts to\nignore. This makes it possible to ignore IPv6 link-local addresses or loopback\naddresses in unreasonable places.\n\nThe lookup may result in a change of name. For compatibility with the dns\nlookup, return this via fully_qualified_name as well as updating the host item.\nThe lookup may also yield more than one IP address, in which case chain on\nsubsequent host_item structures.\n\nArguments:\n  host                   a host item with the name and MX filled in;\n                           the address is to be filled in;\n                           multiple IP addresses cause other host items to be\n                             chained on.\n  ignore_target_hosts    a list of hosts to ignore\n  flags                  HOST_FIND_QUALIFY_SINGLE   ) passed to\n                         HOST_FIND_SEARCH_PARENTS   )   dns_init()\n  fully_qualified_name   if not NULL, set to point to host name for\n                         compatibility with host_find_bydns\n  local_host_check       TRUE if a check for the local host is wanted\n\nReturns:                 HOST_FIND_FAILED  Failed to find the host or domain\n                         HOST_FIND_AGAIN   Try again later\n                         HOST_FOUND        Host found - data filled in\n                         HOST_FOUND_LOCAL  Host found and is the local host\n*/\n\nint\nhost_find_byname(host_item *host, const uschar *ignore_target_hosts, int flags,\n  const uschar **fully_qualified_name, BOOL local_host_check)\n{\nint yield, times;\nhost_item *last = NULL;\nBOOL temp_error = FALSE;\nint af;\n\n#ifndef DISABLE_TLS\n/* Copy the host name at this point to the value which is used for\nTLS certificate name checking, before anything modifies it.  */\n\nhost->certname = host->name;\n#endif\n\n/* Make sure DNS options are set as required. This appears to be necessary in\nsome circumstances when the get..byname() function actually calls the DNS. */\n\ndns_init((flags & HOST_FIND_QUALIFY_SINGLE) != 0,\n         (flags & HOST_FIND_SEARCH_PARENTS) != 0,\n\t FALSE);\t\t/* Cannot retrieve dnssec status so do not request */\n\n/* In an IPv6 world, unless IPv6 has been disabled, we need to scan for both\nkinds of address, so go round the loop twice. Note that we have ensured that\nAF_INET6 is defined even in an IPv4 world, which makes for slightly tidier\ncode. However, if dns_ipv4_lookup matches the domain, we also just do IPv4\nlookups here (except when testing standalone). */\n\n#if HAVE_IPV6\n  #ifdef STAND_ALONE\n  if (disable_ipv6)\n  #else\n  if (  disable_ipv6\n     ||    dns_ipv4_lookup\n\t&& match_isinlist(host->name, CUSS &dns_ipv4_lookup, 0,\n\t    &domainlist_anchor, NULL, MCL_DOMAIN, TRUE, NULL) == OK)\n  #endif\n\n    { af = AF_INET; times = 1; }\n  else\n    { af = AF_INET6; times = 2; }\n\n/* No IPv6 support */\n\n#else   /* HAVE_IPV6 */\n  af = AF_INET; times = 1;\n#endif  /* HAVE_IPV6 */\n\n/* Initialize the flag that gets set for DNS syntax check errors, so that the\ninterface to this function can be similar to host_find_bydns. */\n\nf.host_find_failed_syntax = FALSE;\n\n/* Loop to look up both kinds of address in an IPv6 world */\n\nfor (int i = 1; i <= times;\n     #if HAVE_IPV6\n       af = AF_INET,     /* If 2 passes, IPv4 on the second */\n     #endif\n     i++)\n  {\n  BOOL ipv4_addr;\n  int error_num = 0;\n  struct hostent *hostdata;\n  unsigned long time_msec = 0;\t/* compiler quietening */\n\n  #ifdef STAND_ALONE\n  printf(\"Looking up: %s\\n\", host->name);\n  #endif\n\n  if (slow_lookup_log) time_msec = get_time_in_ms();\n\n  #if HAVE_IPV6\n  if (f.running_in_test_harness)\n    hostdata = host_fake_gethostbyname(host->name, af, &error_num);\n  else\n    {\n    #if HAVE_GETIPNODEBYNAME\n    hostdata = getipnodebyname(CS host->name, af, 0, &error_num);\n    #else\n    hostdata = gethostbyname2(CS host->name, af);\n    error_num = h_errno;\n    #endif\n    }\n\n  #else    /* not HAVE_IPV6 */\n  if (f.running_in_test_harness)\n    hostdata = host_fake_gethostbyname(host->name, af, &error_num);\n  else\n    {\n    hostdata = gethostbyname(CS host->name);\n    error_num = h_errno;\n    }\n  #endif   /* HAVE_IPV6 */\n\n  if (   slow_lookup_log\n      && (time_msec = get_time_in_ms() - time_msec) > slow_lookup_log)\n    log_long_lookup(US\"gethostbyname\", host->name, time_msec);\n\n  if (!hostdata)\n    {\n    uschar * error;\n    switch (error_num)\n      {\n      case HOST_NOT_FOUND: error = US\"HOST_NOT_FOUND\";\tbreak;\n      case TRY_AGAIN:      error = US\"TRY_AGAIN\";   temp_error = TRUE; break;\n      case NO_RECOVERY:    error = US\"NO_RECOVERY\"; temp_error = TRUE; break;\n      case NO_DATA:        error = US\"NO_DATA\";\t\tbreak;\n    #if NO_DATA != NO_ADDRESS\n      case NO_ADDRESS:     error = US\"NO_ADDRESS\";\tbreak;\n    #endif\n      default: error = US\"?\"; break;\n      }\n\n    DEBUG(D_host_lookup) debug_printf(\"%s(af=%s) returned %d (%s)\\n\",\n      f.running_in_test_harness ? \"host_fake_gethostbyname\" :\n#if HAVE_IPV6\n# if HAVE_GETIPNODEBYNAME\n        \"getipnodebyname\",\n# else\n        \"gethostbyname2\",\n# endif\n#else\n\t\"gethostbyname\",\n#endif\n      af == AF_INET ? \"inet\" : \"inet6\", error_num, error);\n\n    continue;\n    }\n  if (!(hostdata->h_addr_list)[0]) continue;\n\n  /* Replace the name with the fully qualified one if necessary, and fill in\n  the fully_qualified_name pointer. */\n\n  if (hostdata->h_name[0] && Ustrcmp(host->name, hostdata->h_name) != 0)\n    host->name = string_copy_dnsdomain(US hostdata->h_name);\n  if (fully_qualified_name) *fully_qualified_name = host->name;\n\n  /* Get the list of addresses. IPv4 and IPv6 addresses can be distinguished\n  by their different lengths. Scan the list, ignoring any that are to be\n  ignored, and build a chain from the rest. */\n\n  ipv4_addr = hostdata->h_length == sizeof(struct in_addr);\n\n  for (uschar ** addrlist = USS hostdata->h_addr_list; *addrlist; addrlist++)\n    {\n    uschar *text_address =\n      host_ntoa(ipv4_addr? AF_INET:AF_INET6, *addrlist, NULL, NULL);\n\n    #ifndef STAND_ALONE\n    if (  ignore_target_hosts\n       && verify_check_this_host(&ignore_target_hosts, NULL, host->name,\n\t    text_address, NULL) == OK)\n      {\n      DEBUG(D_host_lookup)\n        debug_printf(\"ignored host %s [%s]\\n\", host->name, text_address);\n      continue;\n      }\n    #endif\n\n    /* If this is the first address, last is NULL and we put the data in the\n    original block. */\n\n    if (!last)\n      {\n      host->address = text_address;\n      host->port = PORT_NONE;\n      host->status = hstatus_unknown;\n      host->why = hwhy_unknown;\n      host->dnssec = DS_UNK;\n      last = host;\n      }\n\n    /* Else add further host item blocks for any other addresses, keeping\n    the order. */\n\n    else\n      {\n      host_item *next = store_get(sizeof(host_item), FALSE);\n      next->name = host->name;\n#ifndef DISABLE_TLS\n      next->certname = host->certname;\n#endif\n      next->mx = host->mx;\n      next->address = text_address;\n      next->port = PORT_NONE;\n      next->status = hstatus_unknown;\n      next->why = hwhy_unknown;\n      next->dnssec = DS_UNK;\n      next->last_try = 0;\n      next->next = last->next;\n      last->next = next;\n      last = next;\n      }\n    }\n  }\n\n/* If no hosts were found, the address field in the original host block will be\nNULL. If temp_error is set, at least one of the lookups gave a temporary error,\nso we pass that back. */\n\nif (!host->address)\n  {\n  uschar *msg =\n    #ifndef STAND_ALONE\n    !message_id[0] && smtp_in\n      ? string_sprintf(\"no IP address found for host %s (during %s)\", host->name,\n          smtp_get_connection_info()) :\n    #endif\n    string_sprintf(\"no IP address found for host %s\", host->name);\n\n  HDEBUG(D_host_lookup) debug_printf(\"%s\\n\", msg);\n  if (temp_error) goto RETURN_AGAIN;\n  if (host_checking || !f.log_testing_mode)\n    log_write(L_host_lookup_failed, LOG_MAIN, \"%s\", msg);\n  return HOST_FIND_FAILED;\n  }\n\n/* Remove any duplicate IP addresses, then check to see if this is the local\nhost if required. */\n\nhost_remove_duplicates(host, &last);\nyield = local_host_check?\n  host_scan_for_local_hosts(host, &last, NULL) : HOST_FOUND;\n\nHDEBUG(D_host_lookup)\n  {\n  if (fully_qualified_name)\n    debug_printf(\"fully qualified name = %s\\n\", *fully_qualified_name);\n  debug_printf(\"%s looked up these IP addresses:\\n\",\n    #if HAVE_IPV6\n      #if HAVE_GETIPNODEBYNAME\n      \"getipnodebyname\"\n      #else\n      \"gethostbyname2\"\n      #endif\n    #else\n    \"gethostbyname\"\n    #endif\n    );\n  for (const host_item * h = host; h != last->next; h = h->next)\n    debug_printf(\"  name=%s address=%s\\n\", h->name,\n      h->address ? h->address : US\"<null>\");\n  }\n\n/* Return the found status. */\n\nreturn yield;\n\n/* Handle the case when there is a temporary error. If the name matches\ndns_again_means_nonexist, return permanent rather than temporary failure. */\n\nRETURN_AGAIN:\n  {\n#ifndef STAND_ALONE\n  int rc;\n  const uschar *save = deliver_domain;\n  deliver_domain = host->name;  /* set $domain */\n  rc = match_isinlist(host->name, CUSS &dns_again_means_nonexist, 0,\n    &domainlist_anchor, NULL, MCL_DOMAIN, TRUE, NULL);\n  deliver_domain = save;\n  if (rc == OK)\n    {\n    DEBUG(D_host_lookup) debug_printf(\"%s is in dns_again_means_nonexist: \"\n      \"returning HOST_FIND_FAILED\\n\", host->name);\n    return HOST_FIND_FAILED;\n    }\n#endif\n  return HOST_FIND_AGAIN;\n  }\n}\n\n\n\n/*************************************************\n*        Fill in a host address from the DNS     *\n*************************************************/\n\n/* Given a host item, with its name, port and mx fields set, and its address\nfield set to NULL, fill in its IP address from the DNS. If it is multi-homed,\ncreate additional host items for the additional addresses, copying all the\nother fields, and randomizing the order.\n\nOn IPv6 systems, AAAA records are sought first, then A records.\n\nThe host name may be changed if the DNS returns a different name - e.g. fully\nqualified or changed via CNAME. If fully_qualified_name is not NULL, dns_lookup\nensures that it points to the fully qualified name. However, this is the fully\nqualified version of the original name; if a CNAME is involved, the actual\ncanonical host name may be different again, and so we get it directly from the\nrelevant RR. Note that we do NOT change the mx field of the host item in this\nfunction as it may be called to set the addresses of hosts taken from MX\nrecords.\n\nArguments:\n  host                  points to the host item we're filling in\n  lastptr               points to pointer to last host item in a chain of\n                          host items (may be updated if host is last and gets\n                          extended because multihomed)\n  ignore_target_hosts   list of hosts to ignore\n  allow_ip              if TRUE, recognize an IP address and return it\n  fully_qualified_name  if not NULL, return fully qualified name here if\n                          the contents are different (i.e. it must be preset\n                          to something)\n  dnssec_request\tif TRUE request the AD bit\n  dnssec_require\tif TRUE require the AD bit\n  whichrrs\t\tselect ipv4, ipv6 results\n\nReturns:       HOST_FIND_FAILED     couldn't find A record\n               HOST_FIND_AGAIN      try again later\n\t       HOST_FIND_SECURITY   dnssec required but not acheived\n               HOST_FOUND           found AAAA and/or A record(s)\n               HOST_IGNORED         found, but all IPs ignored\n*/\n\nstatic int\nset_address_from_dns(host_item *host, host_item **lastptr,\n  const uschar *ignore_target_hosts, BOOL allow_ip,\n  const uschar **fully_qualified_name,\n  BOOL dnssec_request, BOOL dnssec_require, int whichrrs)\n{\nhost_item *thishostlast = NULL;    /* Indicates not yet filled in anything */\nBOOL v6_find_again = FALSE;\nBOOL dnssec_fail = FALSE;\nint i;\ndns_answer * dnsa;\n\n#ifndef DISABLE_TLS\n/* Copy the host name at this point to the value which is used for\nTLS certificate name checking, before any CNAME-following modifies it.  */\n\nhost->certname = host->name;\n#endif\n\n/* If allow_ip is set, a name which is an IP address returns that value\nas its address. This is used for MX records when allow_mx_to_ip is set, for\nthose sites that feel they have to flaunt the RFC rules. */\n\nif (allow_ip && string_is_ip_address(host->name, NULL) != 0)\n  {\n  #ifndef STAND_ALONE\n  if (  ignore_target_hosts\n     && verify_check_this_host(&ignore_target_hosts, NULL, host->name,\n        host->name, NULL) == OK)\n    return HOST_IGNORED;\n  #endif\n\n  host->address = host->name;\n  return HOST_FOUND;\n  }\n\ndnsa = store_get_dns_answer();\n\n/* On an IPv6 system, unless IPv6 is disabled, go round the loop up to twice,\nlooking for AAAA records the first time. However, unless doing standalone\ntesting, we force an IPv4 lookup if the domain matches dns_ipv4_lookup global.\nOn an IPv4 system, go round the loop once only, looking only for A records. */\n\n#if HAVE_IPV6\n  #ifndef STAND_ALONE\n    if (  disable_ipv6\n       || !(whichrrs & HOST_FIND_BY_AAAA)\n       ||    dns_ipv4_lookup\n          && match_isinlist(host->name, CUSS &dns_ipv4_lookup, 0,\n\t      &domainlist_anchor, NULL, MCL_DOMAIN, TRUE, NULL) == OK\n       )\n      i = 0;    /* look up A records only */\n    else\n  #endif        /* STAND_ALONE */\n\n  i = 1;        /* look up AAAA and A records */\n\n/* The IPv4 world */\n\n#else           /* HAVE_IPV6 */\n  i = 0;        /* look up A records only */\n#endif          /* HAVE_IPV6 */\n\nfor (; i >= 0; i--)\n  {\n  static int types[] = { T_A, T_AAAA };\n  int type = types[i];\n  int randoffset = i == (whichrrs & HOST_FIND_IPV4_FIRST ? 1 : 0)\n    ? 500 : 0;  /* Ensures v6/4 sort order */\n  dns_scan dnss;\n\n  int rc = dns_lookup_timerwrap(dnsa, host->name, type, fully_qualified_name);\n  lookup_dnssec_authenticated = !dnssec_request ? NULL\n    : dns_is_secure(dnsa) ? US\"yes\" : US\"no\";\n\n  DEBUG(D_dns)\n    if (  (dnssec_request || dnssec_require)\n       && !dns_is_secure(dnsa)\n       && dns_is_aa(dnsa)\n       )\n      debug_printf(\"DNS lookup of %.256s (A/AAAA) requested AD, but got AA\\n\", host->name);\n\n  /* We want to return HOST_FIND_AGAIN if one of the A or AAAA lookups\n  fails or times out, but not if another one succeeds. (In the early\n  IPv6 days there are name servers that always fail on AAAA, but are happy\n  to give out an A record. We want to proceed with that A record.) */\n\n  if (rc != DNS_SUCCEED)\n    {\n    if (i == 0)  /* Just tried for an A record, i.e. end of loop */\n      {\n      if (host->address != NULL)\n        i = HOST_FOUND;  /* AAAA was found */\n      else if (rc == DNS_AGAIN || rc == DNS_FAIL || v6_find_again)\n        i = HOST_FIND_AGAIN;\n      else\n\ti = HOST_FIND_FAILED;    /* DNS_NOMATCH or DNS_NODATA */\n      goto out;\n      }\n\n    /* Tried for an AAAA record: remember if this was a temporary\n    error, and look for the next record type. */\n\n    if (rc != DNS_NOMATCH && rc != DNS_NODATA) v6_find_again = TRUE;\n    continue;\n    }\n\n  if (dnssec_request)\n    {\n    if (dns_is_secure(dnsa))\n      {\n      DEBUG(D_host_lookup) debug_printf(\"%s A DNSSEC\\n\", host->name);\n      if (host->dnssec == DS_UNK) /* set in host_find_bydns() */\n\thost->dnssec = DS_YES;\n      }\n    else\n      {\n      if (dnssec_require)\n\t{\n\tdnssec_fail = TRUE;\n\tDEBUG(D_host_lookup) debug_printf(\"dnssec fail on %s for %.256s\",\n\t\ti>0 ? \"AAAA\" : \"A\", host->name);\n\tcontinue;\n\t}\n      if (host->dnssec == DS_YES) /* set in host_find_bydns() */\n\t{\n\tDEBUG(D_host_lookup) debug_printf(\"%s A cancel DNSSEC\\n\", host->name);\n\thost->dnssec = DS_NO;\n\tlookup_dnssec_authenticated = US\"no\";\n\t}\n      }\n    }\n\n  /* Lookup succeeded: fill in the given host item with the first non-ignored\n  address found; create additional items for any others. A single A6 record\n  may generate more than one address.  The lookup had a chance to update the\n  fqdn; we do not want any later times round the loop to do so. */\n\n  fully_qualified_name = NULL;\n\n  for (dns_record * rr = dns_next_rr(dnsa, &dnss, RESET_ANSWERS);\n       rr;\n       rr = dns_next_rr(dnsa, &dnss, RESET_NEXT)) if (rr->type == type)\n    {\n    dns_address * da = dns_address_from_rr(dnsa, rr);\n\n    DEBUG(D_host_lookup)\n      if (!da) debug_printf(\"no addresses extracted from A6 RR for %s\\n\",\n\t  host->name);\n\n    /* This loop runs only once for A and AAAA records, but may run\n    several times for an A6 record that generated multiple addresses. */\n\n    for (; da; da = da->next)\n      {\n      #ifndef STAND_ALONE\n      if (ignore_target_hosts != NULL &&\n\t    verify_check_this_host(&ignore_target_hosts, NULL,\n\t      host->name, da->address, NULL) == OK)\n\t{\n\tDEBUG(D_host_lookup)\n\t  debug_printf(\"ignored host %s [%s]\\n\", host->name, da->address);\n\tcontinue;\n\t}\n      #endif\n\n      /* If this is the first address, stick it in the given host block,\n      and change the name if the returned RR has a different name. */\n\n      if (thishostlast == NULL)\n\t{\n\tif (strcmpic(host->name, rr->name) != 0)\n\t  host->name = string_copy_dnsdomain(rr->name);\n\thost->address = da->address;\n\thost->sort_key = host->mx * 1000 + random_number(500) + randoffset;\n\thost->status = hstatus_unknown;\n\thost->why = hwhy_unknown;\n\tthishostlast = host;\n\t}\n\n      /* Not the first address. Check for, and ignore, duplicates. Then\n      insert in the chain at a random point. */\n\n      else\n\t{\n\tint new_sort_key;\n\thost_item *next;\n\n\t/* End of our local chain is specified by \"thishostlast\". */\n\n\tfor (next = host;; next = next->next)\n\t  {\n\t  if (Ustrcmp(CS da->address, next->address) == 0) break;\n\t  if (next == thishostlast) { next = NULL; break; }\n\t  }\n\tif (next != NULL) continue;  /* With loop for next address */\n\n\t/* Not a duplicate */\n\n\tnew_sort_key = host->mx * 1000 + random_number(500) + randoffset;\n\tnext = store_get(sizeof(host_item), FALSE);\n\n\t/* New address goes first: insert the new block after the first one\n\t(so as not to disturb the original pointer) but put the new address\n\tin the original block. */\n\n\tif (new_sort_key < host->sort_key)\n\t  {\n\t  *next = *host;                                  /* Copies port */\n\t  host->next = next;\n\t  host->address = da->address;\n\t  host->sort_key = new_sort_key;\n\t  if (thishostlast == host) thishostlast = next;  /* Local last */\n\t  if (*lastptr == host) *lastptr = next;          /* Global last */\n\t  }\n\n\t/* Otherwise scan down the addresses for this host to find the\n\tone to insert after. */\n\n\telse\n\t  {\n\t  host_item *h = host;\n\t  while (h != thishostlast)\n\t    {\n\t    if (new_sort_key < h->next->sort_key) break;\n\t    h = h->next;\n\t    }\n\t  *next = *h;                                 /* Copies port */\n\t  h->next = next;\n\t  next->address = da->address;\n\t  next->sort_key = new_sort_key;\n\t  if (h == thishostlast) thishostlast = next; /* Local last */\n\t  if (h == *lastptr) *lastptr = next;         /* Global last */\n\t  }\n\t}\n      }\n    }\n  }\n\n/* Control gets here only if the second lookup (the A record) succeeded.\nHowever, the address may not be filled in if it was ignored. */\n\ni = host->address\n  ? HOST_FOUND\n  : dnssec_fail\n  ? HOST_FIND_SECURITY\n  : HOST_IGNORED;\n\nout:\n  store_free_dns_answer(dnsa);\n  return i;\n}\n\n\n\n\n/*************************************************\n*    Find IP addresses and host names via DNS    *\n*************************************************/\n\n/* The input is a host_item structure with the name field filled in and the\naddress field set to NULL. This may be in a chain of other host items. The\nlookup may result in more than one IP address, in which case we must created\nnew host blocks for the additional addresses, and insert them into the chain.\nThe original name may not be fully qualified. Use the fully_qualified_name\nargument to return the official name, as returned by the resolver.\n\nArguments:\n  host                  point to initial host item\n  ignore_target_hosts   a list of hosts to ignore\n  whichrrs              flags indicating which RRs to look for:\n                          HOST_FIND_BY_SRV  => look for SRV\n                          HOST_FIND_BY_MX   => look for MX\n                          HOST_FIND_BY_A    => look for A\n                          HOST_FIND_BY_AAAA => look for AAAA\n                        also flags indicating how the lookup is done\n                          HOST_FIND_QUALIFY_SINGLE   ) passed to the\n                          HOST_FIND_SEARCH_PARENTS   )   resolver\n\t\t\t  HOST_FIND_IPV4_FIRST => reverse usual result ordering\n\t\t\t  HOST_FIND_IPV4_ONLY  => MX results elide ipv6\n  srv_service           when SRV used, the service name\n  srv_fail_domains      DNS errors for these domains => assume nonexist\n  mx_fail_domains       DNS errors for these domains => assume nonexist\n  dnssec_d.request =>   make dnssec request: domainlist\n  dnssec_d.require =>   ditto and nonexist failures\n  fully_qualified_name  if not NULL, return fully-qualified name\n  removed               set TRUE if local host was removed from the list\n\nReturns:                HOST_FIND_FAILED  Failed to find the host or domain;\n                                          if there was a syntax error,\n                                          host_find_failed_syntax is set.\n                        HOST_FIND_AGAIN   Could not resolve at this time\n\t\t\tHOST_FIND_SECURITY dnsssec required but not acheived\n                        HOST_FOUND        Host found\n                        HOST_FOUND_LOCAL  The lowest MX record points to this\n                                          machine, if MX records were found, or\n                                          an A record that was found contains\n                                          an address of the local host\n*/\n\nint\nhost_find_bydns(host_item *host, const uschar *ignore_target_hosts, int whichrrs,\n  uschar *srv_service, uschar *srv_fail_domains, uschar *mx_fail_domains,\n  const dnssec_domains *dnssec_d,\n  const uschar **fully_qualified_name, BOOL *removed)\n{\nhost_item *h, *last;\nint rc = DNS_FAIL;\nint ind_type = 0;\nint yield;\ndns_answer * dnsa = store_get_dns_answer();\ndns_scan dnss;\nBOOL dnssec_require = dnssec_d\n  && match_isinlist(host->name, CUSS &dnssec_d->require,\n\t\t  0, &domainlist_anchor, NULL, MCL_DOMAIN, TRUE, NULL) == OK;\nBOOL dnssec_request = dnssec_require\n    || (  dnssec_d\n       && match_isinlist(host->name, CUSS &dnssec_d->request,\n\t\t    0, &domainlist_anchor, NULL, MCL_DOMAIN, TRUE, NULL) == OK);\ndnssec_status_t dnssec;\n\n/* Set the default fully qualified name to the incoming name, initialize the\nresolver if necessary, set up the relevant options, and initialize the flag\nthat gets set for DNS syntax check errors. */\n\nif (fully_qualified_name != NULL) *fully_qualified_name = host->name;\ndns_init((whichrrs & HOST_FIND_QUALIFY_SINGLE) != 0,\n         (whichrrs & HOST_FIND_SEARCH_PARENTS) != 0,\n\t dnssec_request);\nf.host_find_failed_syntax = FALSE;\n\n/* First, if requested, look for SRV records. The service name is given; we\nassume TCP protocol. DNS domain names are constrained to a maximum of 256\ncharacters, so the code below should be safe. */\n\nif (whichrrs & HOST_FIND_BY_SRV)\n  {\n  gstring * g;\n  uschar * temp_fully_qualified_name;\n  int prefix_length;\n\n  g = string_fmt_append(NULL, \"_%s._tcp.%n%.256s\",\n\tsrv_service, &prefix_length, host->name);\n  temp_fully_qualified_name = string_from_gstring(g);\n  ind_type = T_SRV;\n\n  /* Search for SRV records. If the fully qualified name is different to\n  the input name, pass back the new original domain, without the prepended\n  magic. */\n\n  dnssec = DS_UNK;\n  lookup_dnssec_authenticated = NULL;\n  rc = dns_lookup_timerwrap(dnsa, temp_fully_qualified_name, ind_type,\n\tCUSS &temp_fully_qualified_name);\n\n  DEBUG(D_dns)\n    if ((dnssec_request || dnssec_require)\n\t&& !dns_is_secure(dnsa)\n\t&& dns_is_aa(dnsa))\n      debug_printf(\"DNS lookup of %.256s (SRV) requested AD, but got AA\\n\", host->name);\n\n  if (dnssec_request)\n    {\n    if (dns_is_secure(dnsa))\n      { dnssec = DS_YES; lookup_dnssec_authenticated = US\"yes\"; }\n    else\n      { dnssec = DS_NO; lookup_dnssec_authenticated = US\"no\"; }\n    }\n\n  if (temp_fully_qualified_name != g->s && fully_qualified_name != NULL)\n    *fully_qualified_name = temp_fully_qualified_name + prefix_length;\n\n  /* On DNS failures, we give the \"try again\" error unless the domain is\n  listed as one for which we continue. */\n\n  if (rc == DNS_SUCCEED && dnssec_require && !dns_is_secure(dnsa))\n    {\n    log_write(L_host_lookup_failed, LOG_MAIN,\n\t\t\"dnssec fail on SRV for %.256s\", host->name);\n    rc = DNS_FAIL;\n    }\n  if (rc == DNS_FAIL || rc == DNS_AGAIN)\n    {\n#ifndef STAND_ALONE\n    if (match_isinlist(host->name, CUSS &srv_fail_domains, 0,\n\t&domainlist_anchor, NULL, MCL_DOMAIN, TRUE, NULL) != OK)\n#endif\n      { yield = HOST_FIND_AGAIN; goto out; }\n    DEBUG(D_host_lookup) debug_printf(\"DNS_%s treated as DNS_NODATA \"\n      \"(domain in srv_fail_domains)\\n\", rc == DNS_FAIL ? \"FAIL\":\"AGAIN\");\n    }\n  }\n\n/* If we did not find any SRV records, search the DNS for MX records, if\nrequested to do so. If the result is DNS_NOMATCH, it means there is no such\ndomain, and there's no point in going on to look for address records with the\nsame domain. The result will be DNS_NODATA if the domain exists but has no MX\nrecords. On DNS failures, we give the \"try again\" error unless the domain is\nlisted as one for which we continue. */\n\nif (rc != DNS_SUCCEED  &&  whichrrs & HOST_FIND_BY_MX)\n  {\n  ind_type = T_MX;\n  dnssec = DS_UNK;\n  lookup_dnssec_authenticated = NULL;\n  rc = dns_lookup_timerwrap(dnsa, host->name, ind_type, fully_qualified_name);\n\n  DEBUG(D_dns)\n    if (  (dnssec_request || dnssec_require)\n       && !dns_is_secure(dnsa)\n       && dns_is_aa(dnsa))\n      debug_printf(\"DNS lookup of %.256s (MX) requested AD, but got AA\\n\", host->name);\n\n  if (dnssec_request)\n    if (dns_is_secure(dnsa))\n      {\n      DEBUG(D_host_lookup) debug_printf(\"%s (MX resp) DNSSEC\\n\", host->name);\n      dnssec = DS_YES; lookup_dnssec_authenticated = US\"yes\";\n      }\n    else\n      {\n      dnssec = DS_NO; lookup_dnssec_authenticated = US\"no\";\n      }\n\n  switch (rc)\n    {\n    case DNS_NOMATCH:\n      yield = HOST_FIND_FAILED; goto out;\n\n    case DNS_SUCCEED:\n      if (!dnssec_require || dns_is_secure(dnsa))\n\tbreak;\n      DEBUG(D_host_lookup)\n\tdebug_printf(\"dnssec fail on MX for %.256s\", host->name);\n#ifndef STAND_ALONE\n      if (match_isinlist(host->name, CUSS &mx_fail_domains, 0,\n\t  &domainlist_anchor, NULL, MCL_DOMAIN, TRUE, NULL) != OK)\n\t{ yield = HOST_FIND_SECURITY; goto out; }\n#endif\n      rc = DNS_FAIL;\n      /*FALLTHROUGH*/\n\n    case DNS_FAIL:\n    case DNS_AGAIN:\n#ifndef STAND_ALONE\n      if (match_isinlist(host->name, CUSS &mx_fail_domains, 0,\n\t  &domainlist_anchor, NULL, MCL_DOMAIN, TRUE, NULL) != OK)\n#endif\n\t{ yield = HOST_FIND_AGAIN; goto out; }\n      DEBUG(D_host_lookup) debug_printf(\"DNS_%s treated as DNS_NODATA \"\n\t\"(domain in mx_fail_domains)\\n\", (rc == DNS_FAIL)? \"FAIL\":\"AGAIN\");\n      break;\n    }\n  }\n\n/* If we haven't found anything yet, and we are requested to do so, try for an\nA or AAAA record. If we find it (or them) check to see that it isn't the local\nhost. */\n\nif (rc != DNS_SUCCEED)\n  {\n  if (!(whichrrs & (HOST_FIND_BY_A | HOST_FIND_BY_AAAA)))\n    {\n    DEBUG(D_host_lookup) debug_printf(\"Address records are not being sought\\n\");\n    yield = HOST_FIND_FAILED;\n    goto out;\n    }\n\n  last = host;        /* End of local chainlet */\n  host->mx = MX_NONE;\n  host->port = PORT_NONE;\n  host->dnssec = DS_UNK;\n  lookup_dnssec_authenticated = NULL;\n  rc = set_address_from_dns(host, &last, ignore_target_hosts, FALSE,\n    fully_qualified_name, dnssec_request, dnssec_require, whichrrs);\n\n  /* If one or more address records have been found, check that none of them\n  are local. Since we know the host items all have their IP addresses\n  inserted, host_scan_for_local_hosts() can only return HOST_FOUND or\n  HOST_FOUND_LOCAL. We do not need to scan for duplicate IP addresses here,\n  because set_address_from_dns() removes them. */\n\n  if (rc == HOST_FOUND)\n    rc = host_scan_for_local_hosts(host, &last, removed);\n  else\n    if (rc == HOST_IGNORED) rc = HOST_FIND_FAILED;  /* No special action */\n\n  DEBUG(D_host_lookup)\n    if (host->address)\n      {\n      if (fully_qualified_name)\n        debug_printf(\"fully qualified name = %s\\n\", *fully_qualified_name);\n      for (host_item * h = host; h != last->next; h = h->next)\n        debug_printf(\"%s %s mx=%d sort=%d %s\\n\", h->name,\n          h->address ? h->address : US\"<null>\", h->mx, h->sort_key,\n          h->status >= hstatus_unusable ? US\"*\" : US\"\");\n      }\n\n  yield = rc;\n  goto out;\n  }\n\n/* We have found one or more MX or SRV records. Sort them according to\nprecedence. Put the data for the first one into the existing host block, and\ninsert new host_item blocks into the chain for the remainder. For equal\nprecedences one is supposed to randomize the order. To make this happen, the\nsorting is actually done on the MX value * 1000 + a random number. This is put\ninto a host field called sort_key.\n\nIn the case of hosts with both IPv6 and IPv4 addresses, we want to choose the\nIPv6 address in preference. At this stage, we don't know what kind of address\nthe host has. We choose a random number < 500; if later we find an A record\nfirst, we add 500 to the random number. Then for any other address records, we\nuse random numbers in the range 0-499 for AAAA records and 500-999 for A\nrecords.\n\nAt this point we remove any duplicates that point to the same host, retaining\nonly the one with the lowest precedence. We cannot yet check for precedence\ngreater than that of the local host, because that test cannot be properly done\nuntil the addresses have been found - an MX record may point to a name for this\nhost which is not the primary hostname. */\n\nlast = NULL;    /* Indicates that not even the first item is filled yet */\n\nfor (dns_record * rr = dns_next_rr(dnsa, &dnss, RESET_ANSWERS);\n     rr;\n     rr = dns_next_rr(dnsa, &dnss, RESET_NEXT)) if (rr->type == ind_type)\n  {\n  int precedence, weight;\n  int port = PORT_NONE;\n  const uschar * s = rr->data;\t/* MUST be unsigned for GETSHORT */\n  uschar data[256];\n\n  GETSHORT(precedence, s);      /* Pointer s is advanced */\n\n  /* For MX records, we use a random \"weight\" which causes multiple records of\n  the same precedence to sort randomly. */\n\n  if (ind_type == T_MX)\n    weight = random_number(500);\n  else\n    {\n    /* SRV records are specified with a port and a weight. The weight is used\n    in a special algorithm. However, to start with, we just use it to order the\n    records of equal priority (precedence). */\n    GETSHORT(weight, s);\n    GETSHORT(port, s);\n    }\n\n  /* Get the name of the host pointed to. */\n\n  (void)dn_expand(dnsa->answer, dnsa->answer + dnsa->answerlen, s,\n    (DN_EXPAND_ARG4_TYPE)data, sizeof(data));\n\n  /* Check that we haven't already got this host on the chain; if we have,\n  keep only the lower precedence. This situation shouldn't occur, but you\n  never know what junk might get into the DNS (and this case has been seen on\n  more than one occasion). */\n\n  if (last)       /* This is not the first record */\n    {\n    host_item *prev = NULL;\n\n    for (h = host; h != last->next; prev = h, h = h->next)\n      if (strcmpic(h->name, data) == 0)\n        {\n        DEBUG(D_host_lookup)\n          debug_printf(\"discarded duplicate host %s (MX=%d)\\n\", data,\n            precedence > h->mx ? precedence : h->mx);\n        if (precedence >= h->mx) goto NEXT_MX_RR; /* Skip greater precedence */\n        if (h == host)                            /* Override first item */\n          {\n          h->mx = precedence;\n          host->sort_key = precedence * 1000 + weight;\n          goto NEXT_MX_RR;\n          }\n\n        /* Unwanted host item is not the first in the chain, so we can get\n        get rid of it by cutting it out. */\n\n        prev->next = h->next;\n        if (h == last) last = prev;\n        break;\n        }\n    }\n\n  /* If this is the first MX or SRV record, put the data into the existing host\n  block. Otherwise, add a new block in the correct place; if it has to be\n  before the first block, copy the first block's data to a new second block. */\n\n  if (!last)\n    {\n    host->name = string_copy_dnsdomain(data);\n    host->address = NULL;\n    host->port = port;\n    host->mx = precedence;\n    host->sort_key = precedence * 1000 + weight;\n    host->status = hstatus_unknown;\n    host->why = hwhy_unknown;\n    host->dnssec = dnssec;\n    last = host;\n    }\n  else\n\n  /* Make a new host item and seek the correct insertion place */\n    {\n    int sort_key = precedence * 1000 + weight;\n    host_item *next = store_get(sizeof(host_item), FALSE);\n    next->name = string_copy_dnsdomain(data);\n    next->address = NULL;\n    next->port = port;\n    next->mx = precedence;\n    next->sort_key = sort_key;\n    next->status = hstatus_unknown;\n    next->why = hwhy_unknown;\n    next->dnssec = dnssec;\n    next->last_try = 0;\n\n    /* Handle the case when we have to insert before the first item. */\n\n    if (sort_key < host->sort_key)\n      {\n      host_item htemp;\n      htemp = *host;\n      *host = *next;\n      *next = htemp;\n      host->next = next;\n      if (last == host) last = next;\n      }\n    else\n\n    /* Else scan down the items we have inserted as part of this exercise;\n    don't go further. */\n      {\n      for (h = host; h != last; h = h->next)\n        if (sort_key < h->next->sort_key)\n          {\n          next->next = h->next;\n          h->next = next;\n          break;\n          }\n\n      /* Join on after the last host item that's part of this\n      processing if we haven't stopped sooner. */\n\n      if (h == last)\n        {\n        next->next = last->next;\n        last->next = next;\n        last = next;\n        }\n      }\n    }\n\n  NEXT_MX_RR: continue;\n  }\n\nif (!last)\t/* No rr of correct type; give up */\n  {\n  yield = HOST_FIND_FAILED;\n  goto out;\n  }\n\n/* If the list of hosts was obtained from SRV records, there are two things to\ndo. First, if there is only one host, and it's name is \".\", it means there is\nno SMTP service at this domain. Otherwise, we have to sort the hosts of equal\npriority according to their weights, using an algorithm that is defined in RFC\n2782. The hosts are currently sorted by priority and weight. For each priority\ngroup we have to pick off one host and put it first, and then repeat for any\nremaining in the same priority group. */\n\nif (ind_type == T_SRV)\n  {\n  host_item ** pptr;\n\n  if (host == last && host->name[0] == 0)\n    {\n    DEBUG(D_host_lookup) debug_printf(\"the single SRV record is \\\".\\\"\\n\");\n    yield = HOST_FIND_FAILED;\n    goto out;\n    }\n\n  DEBUG(D_host_lookup)\n    {\n    debug_printf(\"original ordering of hosts from SRV records:\\n\");\n    for (h = host; h != last->next; h = h->next)\n      debug_printf(\"  %s P=%d W=%d\\n\", h->name, h->mx, h->sort_key % 1000);\n    }\n\n  for (pptr = &host, h = host; h != last; pptr = &h->next, h = h->next)\n    {\n    int sum = 0;\n    host_item *hh;\n\n    /* Find the last following host that has the same precedence. At the same\n    time, compute the sum of the weights and the running totals. These can be\n    stored in the sort_key field. */\n\n    for (hh = h; hh != last; hh = hh->next)\n      {\n      int weight = hh->sort_key % 1000;   /* was precedence * 1000 + weight */\n      sum += weight;\n      hh->sort_key = sum;\n      if (hh->mx != hh->next->mx) break;\n      }\n\n    /* If there's more than one host at this precedence (priority), we need to\n    pick one to go first. */\n\n    if (hh != h)\n      {\n      host_item *hhh;\n      host_item **ppptr;\n      int randomizer = random_number(sum + 1);\n\n      for (ppptr = pptr, hhh = h;\n           hhh != hh;\n           ppptr = &hhh->next, hhh = hhh->next)\n        if (hhh->sort_key >= randomizer)\n\t  break;\n\n      /* hhh now points to the host that should go first; ppptr points to the\n      place that points to it. Unfortunately, if the start of the minilist is\n      the start of the entire list, we can't just swap the items over, because\n      we must not change the value of host, since it is passed in from outside.\n      One day, this could perhaps be changed.\n\n      The special case is fudged by putting the new item *second* in the chain,\n      and then transferring the data between the first and second items. We\n      can't just swap the first and the chosen item, because that would mean\n      that an item with zero weight might no longer be first. */\n\n      if (hhh != h)\n        {\n        *ppptr = hhh->next;          /* Cuts it out of the chain */\n\n        if (h == host)\n          {\n          host_item temp = *h;\n          *h = *hhh;\n          *hhh = temp;\n          hhh->next = temp.next;\n          h->next = hhh;\n          }\n        else\n          {\n          hhh->next = h;               /* The rest of the chain follows it */\n          *pptr = hhh;                 /* It takes the place of h */\n          h = hhh;                     /* It's now the start of this minilist */\n          }\n        }\n      }\n\n    /* A host has been chosen to be first at this priority and h now points\n    to this host. There may be others at the same priority, or others at a\n    different priority. Before we leave this host, we need to put back a sort\n    key of the traditional MX kind, in case this host is multihomed, because\n    the sort key is used for ordering the multiple IP addresses. We do not need\n    to ensure that these new sort keys actually reflect the order of the hosts,\n    however. */\n\n    h->sort_key = h->mx * 1000 + random_number(500);\n    }   /* Move on to the next host */\n  }\n\n/* Now we have to find IP addresses for all the hosts. We have ensured above\nthat the names in all the host items are unique. Before release 4.61 we used to\nprocess records from the additional section in the DNS packet that returned the\nMX or SRV records. However, a DNS name server is free to drop any resource\nrecords from the additional section. In theory, this has always been a\npotential problem, but it is exacerbated by the advent of IPv6. If a host had\nseveral IPv4 addresses and some were not in the additional section, at least\nExim would try the others. However, if a host had both IPv4 and IPv6 addresses\nand all the IPv4 (say) addresses were absent, Exim would try only for a IPv6\nconnection, and never try an IPv4 address. When there was only IPv4\nconnectivity, this was a disaster that did in practice occur.\n\nSo, from release 4.61 onwards, we always search for A and AAAA records\nexplicitly. The names shouldn't point to CNAMES, but we use the general lookup\nfunction that handles them, just in case. If any lookup gives a soft error,\nchange the default yield.\n\nFor these DNS lookups, we must disable qualify_single and search_parents;\notherwise invalid host names obtained from MX or SRV records can cause trouble\nif they happen to match something local. */\n\nyield = HOST_FIND_FAILED;    /* Default yield */\ndns_init(FALSE, FALSE,       /* Disable qualify_single and search_parents */\n\t dnssec_request || dnssec_require);\n\nfor (h = host; h != last->next; h = h->next)\n  {\n  if (h->address) continue;  /* Inserted by a multihomed host */\n\n  rc = set_address_from_dns(h, &last, ignore_target_hosts, allow_mx_to_ip,\n    NULL, dnssec_request, dnssec_require,\n    whichrrs & HOST_FIND_IPV4_ONLY\n    ?  HOST_FIND_BY_A  :  HOST_FIND_BY_A | HOST_FIND_BY_AAAA);\n  if (rc != HOST_FOUND)\n    {\n    h->status = hstatus_unusable;\n    switch (rc)\n      {\n      case HOST_FIND_AGAIN:\tyield = rc; h->why = hwhy_deferred; break;\n      case HOST_FIND_SECURITY:\tyield = rc; h->why = hwhy_insecure; break;\n      case HOST_IGNORED:\th->why = hwhy_ignored; break;\n      default:\t\t\th->why = hwhy_failed; break;\n      }\n    }\n  }\n\n/* Scan the list for any hosts that are marked unusable because they have\nbeen explicitly ignored, and remove them from the list, as if they did not\nexist. If we end up with just a single, ignored host, flatten its fields as if\nnothing was found. */\n\nif (ignore_target_hosts)\n  {\n  host_item *prev = NULL;\n  for (h = host; h != last->next; h = h->next)\n    {\n    REDO:\n    if (h->why != hwhy_ignored)        /* Non ignored host, just continue */\n      prev = h;\n    else if (prev == NULL)             /* First host is ignored */\n      {\n      if (h != last)                   /* First is not last */\n        {\n        if (h->next == last) last = h; /* Overwrite it with next */\n        *h = *(h->next);               /* and reprocess it. */\n        goto REDO;                     /* C should have redo, like Perl */\n        }\n      }\n    else                               /* Ignored host is not first - */\n      {                                /*   cut it out */\n      prev->next = h->next;\n      if (h == last) last = prev;\n      }\n    }\n\n  if (host->why == hwhy_ignored) host->address = NULL;\n  }\n\n/* There is still one complication in the case of IPv6. Although the code above\narranges that IPv6 addresses take precedence over IPv4 addresses for multihomed\nhosts, it doesn't do this for addresses that apply to different hosts with the\nsame MX precedence, because the sorting on MX precedence happens first. So we\nhave to make another pass to check for this case. We ensure that, within a\nsingle MX preference value, IPv6 addresses come first. This can separate the\naddresses of a multihomed host, but that should not matter. */\n\n#if HAVE_IPV6\nif (h != last && !disable_ipv6) for (h = host; h != last; h = h->next)\n  {\n  host_item temp;\n  host_item *next = h->next;\n\n  if (  h->mx != next->mx\t\t\t/* If next is different MX */\n     || !h->address\t\t\t\t/* OR this one is unset */\n     )\n    continue;\t\t\t\t\t/* move on to next */\n\n  if (  whichrrs & HOST_FIND_IPV4_FIRST\n     ?     !Ustrchr(h->address, ':')\t\t/* OR this one is IPv4 */\n        || next->address\n           && Ustrchr(next->address, ':')\t/* OR next is IPv6 */\n\n     :     Ustrchr(h->address, ':')\t\t/* OR this one is IPv6 */\n        || next->address\n           && !Ustrchr(next->address, ':')\t/* OR next is IPv4 */\n     )\n    continue;                                /* move on to next */\n\n  temp = *h;                                 /* otherwise, swap */\n  temp.next = next->next;\n  *h = *next;\n  h->next = next;\n  *next = temp;\n  }\n#endif\n\n/* Remove any duplicate IP addresses and then scan the list of hosts for any\nwhose IP addresses are on the local host. If any are found, all hosts with the\nsame or higher MX values are removed. However, if the local host has the lowest\nnumbered MX, then HOST_FOUND_LOCAL is returned. Otherwise, if at least one host\nwith an IP address is on the list, HOST_FOUND is returned. Otherwise,\nHOST_FIND_FAILED is returned, but in this case do not update the yield, as it\nmight have been set to HOST_FIND_AGAIN just above here. If not, it will already\nbe HOST_FIND_FAILED. */\n\nhost_remove_duplicates(host, &last);\nrc = host_scan_for_local_hosts(host, &last, removed);\nif (rc != HOST_FIND_FAILED) yield = rc;\n\nDEBUG(D_host_lookup)\n  {\n  if (fully_qualified_name)\n    debug_printf(\"fully qualified name = %s\\n\", *fully_qualified_name);\n  debug_printf(\"host_find_bydns yield = %s (%d); returned hosts:\\n\",\n    yield == HOST_FOUND\t\t? \"HOST_FOUND\" :\n    yield == HOST_FOUND_LOCAL\t? \"HOST_FOUND_LOCAL\" :\n    yield == HOST_FIND_SECURITY\t? \"HOST_FIND_SECURITY\" :\n    yield == HOST_FIND_AGAIN\t? \"HOST_FIND_AGAIN\" :\n    yield == HOST_FIND_FAILED\t? \"HOST_FIND_FAILED\" : \"?\",\n    yield);\n  for (h = host; h != last->next; h = h->next)\n    {\n    debug_printf(\"  %s %s MX=%d %s\", h->name,\n      !h->address ? US\"<null>\" : h->address, h->mx,\n      h->dnssec == DS_YES ? US\"DNSSEC \" : US\"\");\n    if (h->port != PORT_NONE) debug_printf(\"port=%d \", h->port);\n    if (h->status >= hstatus_unusable) debug_printf(\"*\");\n    debug_printf(\"\\n\");\n    }\n  }\n\nout:\n\ndns_init(FALSE, FALSE, FALSE);\t/* clear the dnssec bit for getaddrbyname */\nstore_free_dns_answer(dnsa);\nreturn yield;\n}\n\n\n\n\n#ifdef SUPPORT_DANE\n/* Lookup TLSA record for host/port.\nReturn:  OK\t\tsuccess with dnssec; DANE mode\n         DEFER\t\tDo not use this host now, may retry later\n\t FAIL_FORCED\tNo TLSA record; DANE not usable\n\t FAIL\t\tDo not use this connection\n*/\n\nint\ntlsa_lookup(const host_item * host, dns_answer * dnsa, BOOL dane_required)\n{\nuschar buffer[300];\nconst uschar * fullname = buffer;\nint rc;\nBOOL sec;\n\n/* TLSA lookup string */\n(void)sprintf(CS buffer, \"_%d._tcp.%.256s\", host->port, host->name);\n\nrc = dns_lookup_timerwrap(dnsa, buffer, T_TLSA, &fullname);\nsec = dns_is_secure(dnsa);\nDEBUG(D_transport)\n  debug_printf(\"TLSA lookup ret %s %sDNSSEC\\n\", dns_rc_names[rc], sec ? \"\" : \"not \");\n\nswitch (rc)\n  {\n  case DNS_AGAIN:\n    return DEFER; /* just defer this TLS'd conn */\n\n  case DNS_SUCCEED:\n    if (sec)\n      {\n      DEBUG(D_transport)\n\t{\n\tdns_scan dnss;\n\tfor (dns_record * rr = dns_next_rr(dnsa, &dnss, RESET_ANSWERS); rr;\n\t     rr = dns_next_rr(dnsa, &dnss, RESET_NEXT))\n\t  if (rr->type == T_TLSA && rr->size > 3)\n\t    {\n\t    uint16_t payload_length = rr->size - 3;\n\t    uschar s[MAX_TLSA_EXPANDED_SIZE], * sp = s, * p = US rr->data;\n\n\t    sp += sprintf(CS sp, \"%d \", *p++); /* usage */\n\t    sp += sprintf(CS sp, \"%d \", *p++); /* selector */\n\t    sp += sprintf(CS sp, \"%d \", *p++); /* matchtype */\n\t    while (payload_length-- > 0 && sp-s < (MAX_TLSA_EXPANDED_SIZE - 4))\n\t      sp += sprintf(CS sp, \"%02x\", *p++);\n\n\t    debug_printf(\" %s\\n\", s);\n\t    }\n\t}\n      return OK;\n      }\n    log_write(0, LOG_MAIN,\n      \"DANE error: TLSA lookup for %s not DNSSEC\", host->name);\n    /*FALLTRHOUGH*/\n\n  case DNS_NODATA:\t/* no TLSA RR for this lookup */\n  case DNS_NOMATCH:\t/* no records at all for this lookup */\n    return dane_required ? FAIL : FAIL_FORCED;\n\n  default:\n  case DNS_FAIL:\n    return dane_required ? FAIL : DEFER;\n  }\n}\n#endif\t/*SUPPORT_DANE*/\n\n\n\n/*************************************************\n**************************************************\n*             Stand-alone test program           *\n**************************************************\n*************************************************/\n\n#ifdef STAND_ALONE\n\nint main(int argc, char **cargv)\n{\nhost_item h;\nint whichrrs = HOST_FIND_BY_MX | HOST_FIND_BY_A | HOST_FIND_BY_AAAA;\nBOOL byname = FALSE;\nBOOL qualify_single = TRUE;\nBOOL search_parents = FALSE;\nBOOL request_dnssec = FALSE;\nBOOL require_dnssec = FALSE;\nuschar **argv = USS cargv;\nuschar buffer[256];\n\ndisable_ipv6 = FALSE;\nprimary_hostname = US\"\";\nstore_init();\nstore_pool = POOL_MAIN;\ndebug_selector = D_host_lookup|D_interface;\ndebug_file = stdout;\ndebug_fd = fileno(debug_file);\n\nprintf(\"Exim stand-alone host functions test\\n\");\n\nhost_find_interfaces();\ndebug_selector = D_host_lookup | D_dns;\n\nif (argc > 1) primary_hostname = argv[1];\n\n/* So that debug level changes can be done first */\n\ndns_init(qualify_single, search_parents, FALSE);\n\nprintf(\"Testing host lookup\\n\");\nprintf(\"> \");\nwhile (Ufgets(buffer, 256, stdin) != NULL)\n  {\n  int rc;\n  int len = Ustrlen(buffer);\n  uschar *fully_qualified_name;\n\n  while (len > 0 && isspace(buffer[len-1])) len--;\n  buffer[len] = 0;\n\n  if (Ustrcmp(buffer, \"q\") == 0) break;\n\n  if (Ustrcmp(buffer, \"byname\") == 0) byname = TRUE;\n  else if (Ustrcmp(buffer, \"no_byname\") == 0) byname = FALSE;\n  else if (Ustrcmp(buffer, \"a_only\") == 0) whichrrs = HOST_FIND_BY_A | HOST_FIND_BY_AAAA;\n  else if (Ustrcmp(buffer, \"mx_only\") == 0) whichrrs = HOST_FIND_BY_MX;\n  else if (Ustrcmp(buffer, \"srv_only\") == 0) whichrrs = HOST_FIND_BY_SRV;\n  else if (Ustrcmp(buffer, \"srv+a\") == 0)\n    whichrrs = HOST_FIND_BY_SRV | HOST_FIND_BY_A | HOST_FIND_BY_AAAA;\n  else if (Ustrcmp(buffer, \"srv+mx\") == 0)\n    whichrrs = HOST_FIND_BY_SRV | HOST_FIND_BY_MX;\n  else if (Ustrcmp(buffer, \"srv+mx+a\") == 0)\n    whichrrs = HOST_FIND_BY_SRV | HOST_FIND_BY_MX | HOST_FIND_BY_A | HOST_FIND_BY_AAAA;\n  else if (Ustrcmp(buffer, \"qualify_single\")    == 0) qualify_single = TRUE;\n  else if (Ustrcmp(buffer, \"no_qualify_single\") == 0) qualify_single = FALSE;\n  else if (Ustrcmp(buffer, \"search_parents\")    == 0) search_parents = TRUE;\n  else if (Ustrcmp(buffer, \"no_search_parents\") == 0) search_parents = FALSE;\n  else if (Ustrcmp(buffer, \"request_dnssec\")    == 0) request_dnssec = TRUE;\n  else if (Ustrcmp(buffer, \"no_request_dnssec\") == 0) request_dnssec = FALSE;\n  else if (Ustrcmp(buffer, \"require_dnssec\")    == 0) require_dnssec = TRUE;\n  else if (Ustrcmp(buffer, \"no_require_dnssec\") == 0) require_dnssec = FALSE;\n  else if (Ustrcmp(buffer, \"test_harness\") == 0)\n    f.running_in_test_harness = !f.running_in_test_harness;\n  else if (Ustrcmp(buffer, \"ipv6\") == 0) disable_ipv6 = !disable_ipv6;\n  else if (Ustrcmp(buffer, \"res_debug\") == 0)\n    {\n    _res.options ^= RES_DEBUG;\n    }\n  else if (Ustrncmp(buffer, \"retrans\", 7) == 0)\n    {\n    (void)sscanf(CS(buffer+8), \"%d\", &dns_retrans);\n    _res.retrans = dns_retrans;\n    }\n  else if (Ustrncmp(buffer, \"retry\", 5) == 0)\n    {\n    (void)sscanf(CS(buffer+6), \"%d\", &dns_retry);\n    _res.retry = dns_retry;\n    }\n  else\n    {\n    int flags = whichrrs;\n    dnssec_domains d;\n\n    h.name = buffer;\n    h.next = NULL;\n    h.mx = MX_NONE;\n    h.port = PORT_NONE;\n    h.status = hstatus_unknown;\n    h.why = hwhy_unknown;\n    h.address = NULL;\n\n    if (qualify_single) flags |= HOST_FIND_QUALIFY_SINGLE;\n    if (search_parents) flags |= HOST_FIND_SEARCH_PARENTS;\n\n    d.request = request_dnssec ? &h.name : NULL;\n    d.require = require_dnssec ? &h.name : NULL;\n\n    rc = byname\n      ? host_find_byname(&h, NULL, flags, &fully_qualified_name, TRUE)\n      : host_find_bydns(&h, NULL, flags, US\"smtp\", NULL, NULL,\n\t\t\t&d, &fully_qualified_name, NULL);\n\n    switch (rc)\n      {\n      case HOST_FIND_FAILED:\tprintf(\"Failed\\n\");\tbreak;\n      case HOST_FIND_AGAIN:\tprintf(\"Again\\n\");\tbreak;\n      case HOST_FIND_SECURITY:\tprintf(\"Security\\n\");\tbreak;\n      case HOST_FOUND_LOCAL:\tprintf(\"Local\\n\");\tbreak;\n      }\n    }\n\n  printf(\"\\n> \");\n  }\n\nprintf(\"Testing host_aton\\n\");\nprintf(\"> \");\nwhile (Ufgets(buffer, 256, stdin) != NULL)\n  {\n  int x[4];\n  int len = Ustrlen(buffer);\n\n  while (len > 0 && isspace(buffer[len-1])) len--;\n  buffer[len] = 0;\n\n  if (Ustrcmp(buffer, \"q\") == 0) break;\n\n  len = host_aton(buffer, x);\n  printf(\"length = %d \", len);\n  for (int i = 0; i < len; i++)\n    {\n    printf(\"%04x \", (x[i] >> 16) & 0xffff);\n    printf(\"%04x \", x[i] & 0xffff);\n    }\n  printf(\"\\n> \");\n  }\n\nprintf(\"\\n\");\n\nprintf(\"Testing host_name_lookup\\n\");\nprintf(\"> \");\nwhile (Ufgets(buffer, 256, stdin) != NULL)\n  {\n  int len = Ustrlen(buffer);\n  while (len > 0 && isspace(buffer[len-1])) len--;\n  buffer[len] = 0;\n  if (Ustrcmp(buffer, \"q\") == 0) break;\n  sender_host_address = buffer;\n  sender_host_name = NULL;\n  sender_host_aliases = NULL;\n  host_lookup_msg = US\"\";\n  host_lookup_failed = FALSE;\n  if (host_name_lookup() == FAIL)  /* Debug causes printing */\n    printf(\"Lookup failed:%s\\n\", host_lookup_msg);\n  printf(\"\\n> \");\n  }\n\nprintf(\"\\n\");\n\nreturn 0;\n}\n#endif  /* STAND_ALONE */\n\n/* vi: aw ai sw=2\n*/\n/* End of host.c */\n"], "filenames": ["src/src/host.c"], "buggy_code_start_loc": [1585], "buggy_code_end_loc": [1695], "fixing_code_start_loc": [1585], "fixing_code_end_loc": [1695], "type": "CWE-787", "message": "Exim before 4.95 has a heap-based buffer overflow for the alias list in host_name_lookup in host.c when sender_host_name is set.", "other": {"cve": {"id": "CVE-2022-37452", "sourceIdentifier": "cve@mitre.org", "published": "2022-08-07T18:15:08.343", "lastModified": "2022-10-28T12:52:47.180", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Exim before 4.95 has a heap-based buffer overflow for the alias list in host_name_lookup in host.c when sender_host_name is set."}, {"lang": "es", "value": "Exim versiones anteriores a 4.95, presenta un desbordamiento de b\u00fafer en la regi\u00f3n heap de la memoria para la lista de alias en la funci\u00f3n host_name_lookup en el archivo host.c cuando sender_host_name est\u00e1 establecido"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:exim:exim:*:*:*:*:*:*:*:*", "versionEndExcluding": "4.95", "matchCriteriaId": "58E69558-B96C-4F4F-B8E1-15F3CA8443CA"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}]}]}], "references": [{"url": "https://github.com/Exim/exim/commit/d4bc023436e4cce7c23c5f8bb5199e178b4cc743", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/Exim/exim/compare/exim-4.94...exim-4.95", "source": "cve@mitre.org", "tags": ["Patch", "Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/Exim/exim/wiki/EximSecurity", "source": "cve@mitre.org", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/ivd38/exim_overflow", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/08/msg00014.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.exim.org/static/doc/security/", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2022/08/06/8", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Exim/exim/commit/d4bc023436e4cce7c23c5f8bb5199e178b4cc743"}}