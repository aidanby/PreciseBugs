{"buggy_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.attachment.internal.refactoring.job;\n\nimport java.io.IOException;\nimport java.util.Objects;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Provider;\n\nimport org.xwiki.attachment.internal.AttachmentsManager;\nimport org.xwiki.attachment.internal.RedirectAttachmentClassDocumentInitializer;\nimport org.xwiki.attachment.refactoring.MoveAttachmentRequest;\nimport org.xwiki.attachment.refactoring.event.AttachmentMovedEvent;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.localization.ContextualLocalizationManager;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.refactoring.internal.job.AbstractEntityJob;\nimport org.xwiki.refactoring.job.EntityJobStatus;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceResolver;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiAttachment;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.objects.BaseObject;\n\nimport static org.apache.commons.lang.exception.ExceptionUtils.getRootCauseMessage;\nimport static org.xwiki.attachment.internal.RedirectAttachmentClassDocumentInitializer.SOURCE_NAME_FIELD;\nimport static org.xwiki.attachment.internal.RedirectAttachmentClassDocumentInitializer.TARGET_LOCATION_FIELD;\nimport static org.xwiki.attachment.internal.RedirectAttachmentClassDocumentInitializer.TARGET_NAME_FIELD;\n\n/**\n * This is the job in charge of moving attachments.\n *\n * @version $Id$\n * @since 14.0RC1\n */\n@Component\n@Named(MoveAttachmentJob.HINT)\npublic class MoveAttachmentJob\n    extends AbstractEntityJob<MoveAttachmentRequest, EntityJobStatus<MoveAttachmentRequest>>\n{\n    /**\n     * The hint for this job.\n     */\n    public static final String HINT = \"refactoring/attachment/move\";\n\n    @Inject\n    private Provider<XWikiContext> xcontextProvider;\n\n    @Inject\n    private EntityReferenceSerializer<String> entityReferenceSerializer;\n\n    @Inject\n    private ContextualLocalizationManager contextualLocalizationManager;\n\n    @Inject\n    private EntityReferenceSerializer<String> referenceSerializer;\n\n    @Inject\n    private AttachmentsManager attachmentsManager;\n\n    @Inject\n    @Named(\"document\")\n    private UserReferenceResolver<DocumentReference> documentReferenceUserReferenceResolver;\n\n    @Override\n    public String getType()\n    {\n        return HINT;\n    }\n\n    @Override\n    protected void process(EntityReference source)\n    {\n        this.progressManager.pushLevelProgress(2, this);\n        AttachmentReference destination = this.request.getProperty(MoveAttachmentRequest.DESTINATION);\n        boolean autoRedirect = this.request.getProperty(MoveAttachmentRequest.AUTO_REDIRECT);\n\n        XWiki wiki = this.xcontextProvider.get().getWiki();\n\n        // Update the author for the attribution of the attachment uploader.\n        this.modelBridge.setContextUserReference(this.request.getUserReference());\n        try {\n            this.progressManager.startStep(this);\n            moveAttachment(source, destination, autoRedirect, wiki);\n            this.progressManager.endStep(this);\n\n            this.progressManager.startStep(this);\n            this.observationManager.notify(new AttachmentMovedEvent((AttachmentReference) source, destination), this,\n                this.request);\n            this.progressManager.endStep(this);\n        } finally {\n            this.progressManager.popLevelProgress(this);\n        }\n    }\n\n    private void moveAttachment(EntityReference source, AttachmentReference destination, boolean autoRedirect,\n        XWiki wiki)\n    {\n        try {\n            XWikiDocument sourceDocument = wiki.getDocument(source.getParent(), this.xcontextProvider.get());\n            XWikiDocument targetDocument = wiki.getDocument(destination.getParent(), this.xcontextProvider.get());\n            XWikiAttachment sourceAttachment = sourceDocument.getExactAttachment(source.getName());\n\n            // Update the author of the source and target documents.\n            UserReference authorUserReference =\n                this.documentReferenceUserReferenceResolver.resolve(this.request.getUserReference());\n            sourceDocument.getAuthors().setEffectiveMetadataAuthor(authorUserReference);\n            sourceDocument.getAuthors().setOriginalMetadataAuthor(authorUserReference);\n            targetDocument.getAuthors().setEffectiveMetadataAuthor(authorUserReference);\n            targetDocument.getAuthors().setOriginalMetadataAuthor(authorUserReference);\n\n            // Remove the original attachment and create a new one with the same name.\n            sourceDocument.removeAttachment(sourceAttachment);\n\n            addAttachment(targetDocument, sourceAttachment, destination.getName());\n\n            this.attachmentsManager.removeExistingRedirection(destination.getName(), targetDocument);\n\n            if (autoRedirect) {\n                initializeAutoRedirection(source, destination, sourceDocument);\n            }\n\n            if (Objects.equals(source.getParent(), destination.getParent())) {\n                wiki.saveDocument(sourceDocument,\n                    this.contextualLocalizationManager.getTranslationPlain(\"attachment.job.saveDocument.inPlace\",\n                        source.getName(), destination.getName()),\n                    this.xcontextProvider.get());\n            } else {\n                transactionalMove(wiki, sourceDocument, targetDocument, sourceAttachment.getFilename(),\n                    destination.getName());\n            }\n        } catch (XWikiException | IOException e) {\n            this.logger.warn(\"Failed to move attachment [{}] to [{}]. Cause: [{}]\", source, destination,\n                getRootCauseMessage(e));\n        }\n    }\n\n    /**\n     * Move the attachment from one document to another. In case of failure when saving the target document, the source\n     * document is rollback with its attachment.\n     *\n     * @param wiki the wiki instance used to perform the documents save\n     * @param sourceDocument the source document, containing the attachment to move\n     * @param targetDocument the target document, in which to move the attachment\n     * @param sourceFileName the file name of the source attachment\n     * @param targetFileName the file name of the target attachment\n     * @throws XWikiException in case of error when save the document\n     * @throws IOException in case of error when putting back the attachment in the source document during the\n     *     rollback\n     */\n    private void transactionalMove(XWiki wiki, XWikiDocument sourceDocument, XWikiDocument targetDocument,\n        String sourceFileName, String targetFileName) throws XWikiException, IOException\n    {\n        String sourceSerialized = this.referenceSerializer.serialize(sourceDocument.getDocumentReference());\n        String destinationSerialized = this.referenceSerializer.serialize(targetDocument.getDocumentReference());\n        String historyMessageSource =\n            this.contextualLocalizationManager.getTranslationPlain(\"attachment.job.saveDocument.source\",\n                destinationSerialized);\n        String historyMessageTarget =\n            this.contextualLocalizationManager.getTranslationPlain(\"attachment.job.saveDocument.target\",\n                sourceSerialized);\n        wiki.saveDocument(sourceDocument, historyMessageSource, this.xcontextProvider.get());\n        try {\n            wiki.saveDocument(targetDocument, historyMessageTarget, this.xcontextProvider.get());\n        } catch (Exception e) {\n            // In case of failure during the save of the second document, we rollback the first one to its initial state\n            // (i.e., with the attachment added again).\n            // Remove the added attachment from the target document.\n            XWikiAttachment attachment = targetDocument.getExactAttachment(targetFileName);\n            addAttachment(sourceDocument, attachment, sourceFileName);\n            targetDocument.removeAttachment(attachment);\n            String historyMessageRollbackTarget =\n                this.contextualLocalizationManager.getTranslationPlain(\"attachment.job.rollbackDocument.target\",\n                    sourceFileName, sourceSerialized);\n            wiki.saveDocument(sourceDocument, historyMessageRollbackTarget, true, this.xcontextProvider.get());\n            // We re-throw the exception since at the end, the job failed.\n            throw e;\n        }\n    }\n\n    private void initializeAutoRedirection(EntityReference source, AttachmentReference destination,\n        XWikiDocument sourceDocument)\n        throws XWikiException\n    {\n        int idx = sourceDocument.createXObject(RedirectAttachmentClassDocumentInitializer.REFERENCE,\n            this.xcontextProvider.get());\n        BaseObject xObject =\n            sourceDocument.getXObject(RedirectAttachmentClassDocumentInitializer.REFERENCE, idx);\n        if (xObject != null) {\n            xObject.setStringValue(SOURCE_NAME_FIELD, source.getName());\n            xObject.setStringValue(TARGET_LOCATION_FIELD,\n                this.entityReferenceSerializer.serialize(destination.getParent()));\n            xObject.setStringValue(TARGET_NAME_FIELD, destination.getName());\n        }\n    }\n\n    private void addAttachment(XWikiDocument targetDocument, XWikiAttachment oldAttachment, String newName)\n        throws IOException, XWikiException\n    {\n        // Clone the attachment and its history to the new document, with the new name.\n        XWikiAttachment newAttachment = oldAttachment.clone(newName, this.xcontextProvider.get());\n        newAttachment.setDoc(targetDocument);\n        targetDocument.setAttachment(newAttachment);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.attachment.internal.refactoring.job;\n\nimport javax.inject.Named;\nimport javax.inject.Provider;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\nimport org.mockito.Mock;\nimport org.xwiki.attachment.internal.AttachmentsManager;\nimport org.xwiki.attachment.internal.RedirectAttachmentClassDocumentInitializer;\nimport org.xwiki.attachment.refactoring.MoveAttachmentRequest;\nimport org.xwiki.localization.ContextualLocalizationManager;\nimport org.xwiki.model.document.DocumentAuthors;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.refactoring.internal.ModelBridge;\nimport org.xwiki.test.LogLevel;\nimport org.xwiki.test.junit5.LogCaptureExtension;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.test.junit5.mockito.MockComponent;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceResolver;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiAttachment;\nimport com.xpn.xwiki.doc.XWikiDocument;\n\nimport ch.qos.logback.classic.Level;\n\nimport static java.util.Collections.singletonList;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.Mockito.doThrow;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.verifyNoInteractions;\nimport static org.mockito.Mockito.when;\n\n/**\n * Test of {@link MoveAttachmentJob}.\n *\n * @version $Id$\n * @since 14.0RC1\n */\n@ComponentTest\nclass MoveAttachmentJobTest\n{\n    private static final DocumentReference SOURCE_LOCATION = new DocumentReference(\"xwiki\", \"Space\", \"Source\");\n\n    private static final AttachmentReference SOURCE_ATTACHMENT_LOCATION =\n        new AttachmentReference(\"oldName\", SOURCE_LOCATION);\n\n    private static final DocumentReference AUTHOR_REFERENCE = new DocumentReference(\"xwiki\", \"XWiki\", \"User1\");\n\n    private static final DocumentReference TARGET_LOCATION = new DocumentReference(\"xwiki\", \"Space\", \"Target\");\n\n    private static final AttachmentReference TARGET_ATTACHMENT_LOCATION =\n        new AttachmentReference(\"newName\", TARGET_LOCATION);\n\n    @InjectMockComponents\n    private MoveAttachmentJob job;\n\n    @MockComponent\n    private Provider<XWikiContext> xcontextProvider;\n\n    @MockComponent\n    private EntityReferenceSerializer<String> entityReferenceSerializer;\n\n    @MockComponent\n    private ContextualLocalizationManager contextualLocalizationManager;\n\n    @MockComponent\n    private EntityReferenceSerializer<String> referenceSerializer;\n\n    @MockComponent\n    private AttachmentsManager attachmentsManager;\n\n    @MockComponent\n    protected ModelBridge modelBridge;\n\n    @MockComponent\n    @Named(\"document\")\n    private UserReferenceResolver<DocumentReference> documentReferenceUserReferenceResolver;\n\n    @Mock\n    private XWikiContext context;\n\n    @Mock\n    private XWiki wiki;\n\n    @Mock\n    private XWikiDocument sourceDocument;\n\n    @Mock\n    private XWikiDocument targetDocument;\n\n    @Mock\n    private DocumentAuthors sourceAuthors;\n\n    @Mock\n    private DocumentAuthors targetAuthors;\n\n    @Mock\n    private UserReference authorReference;\n\n    @RegisterExtension\n    LogCaptureExtension logCapture = new LogCaptureExtension(LogLevel.WARN);\n\n    private MoveAttachmentRequest request;\n\n    @BeforeEach\n    void setUp() throws Exception\n    {\n        this.request = new MoveAttachmentRequest();\n        this.job.initialize(this.request);\n        when(this.xcontextProvider.get()).thenReturn(this.context);\n        when(this.context.getWiki()).thenReturn(this.wiki);\n\n        // The cast is mandatory otherwise the wrong method is mocked (the DocumentReference one).\n        when(this.wiki.getDocument((EntityReference) SOURCE_LOCATION, this.context)).thenReturn(this.sourceDocument);\n        when(this.wiki.getDocument((EntityReference) TARGET_LOCATION, this.context)).thenReturn(this.targetDocument);\n        when(this.sourceDocument.getAuthors()).thenReturn(this.sourceAuthors);\n        when(this.targetDocument.getAuthors()).thenReturn(this.targetAuthors);\n        when(this.sourceDocument.getDocumentReference()).thenReturn(SOURCE_LOCATION);\n        when(this.targetDocument.getDocumentReference()).thenReturn(TARGET_LOCATION);\n        when(this.referenceSerializer.serialize(TARGET_ATTACHMENT_LOCATION)).thenReturn(\"xwiki:Space.Target@newName\");\n        when(this.referenceSerializer.serialize(SOURCE_ATTACHMENT_LOCATION)).thenReturn(\"xwiki:Space.Source@oldName\");\n        when(this.referenceSerializer.serialize(TARGET_LOCATION)).thenReturn(\"xwiki:Space.Target\");\n        when(this.referenceSerializer.serialize(SOURCE_LOCATION)).thenReturn(\"xwiki:Space.Source\");\n        when(this.documentReferenceUserReferenceResolver.resolve(AUTHOR_REFERENCE)).thenReturn(this.authorReference);\n    }\n\n    @Test\n    void process() throws Exception\n    {\n        // Request initialization.\n        this.request.setEntityReferences(singletonList(SOURCE_ATTACHMENT_LOCATION));\n        this.request.setProperty(MoveAttachmentRequest.DESTINATION, TARGET_ATTACHMENT_LOCATION);\n        this.request.setProperty(MoveAttachmentRequest.AUTO_REDIRECT, true);\n        this.request.setInteractive(false);\n        this.request.setUserReference(AUTHOR_REFERENCE);\n\n        XWikiAttachment sourceAttachment = mock(XWikiAttachment.class);\n        XWikiAttachment targetAttachment = mock(XWikiAttachment.class);\n\n        when(sourceAttachment.getFilename()).thenReturn(\"oldName\");\n        when(this.sourceDocument.getExactAttachment(\"oldName\")).thenReturn(sourceAttachment);\n        when(this.contextualLocalizationManager.getTranslationPlain(\"attachment.job.saveDocument.source\",\n            \"xwiki:Space.Target\"))\n            .thenReturn(\"attachment.job.saveDocument.source [xwiki:Space.Target]\");\n        when(this.contextualLocalizationManager.getTranslationPlain(\"attachment.job.saveDocument.target\",\n            \"xwiki:Space.Source\"))\n            .thenReturn(\"attachment.job.saveDocument.target [xwiki:Space.Source]\");\n        when(sourceAttachment.clone(\"newName\", this.context)).thenReturn(targetAttachment);\n\n        this.job.process(SOURCE_ATTACHMENT_LOCATION);\n        verify(this.sourceDocument).removeAttachment(sourceAttachment);\n        verify(this.attachmentsManager).removeExistingRedirection(\"newName\", this.targetDocument);\n        // Initialization of the redirection.\n        verify(this.sourceDocument).createXObject(RedirectAttachmentClassDocumentInitializer.REFERENCE, this.context);\n        verify(this.wiki).saveDocument(this.sourceDocument,\n            \"attachment.job.saveDocument.source [xwiki:Space.Target]\", this.context);\n        verify(this.wiki).saveDocument(this.targetDocument,\n            \"attachment.job.saveDocument.target [xwiki:Space.Source]\", this.context);\n        verify(this.modelBridge).setContextUserReference(AUTHOR_REFERENCE);\n        verify(this.targetAuthors).setEffectiveMetadataAuthor(this.authorReference);\n        verify(this.sourceAuthors).setEffectiveMetadataAuthor(this.authorReference);\n        verify(this.targetAuthors).setOriginalMetadataAuthor(this.authorReference);\n        verify(this.sourceAuthors).setOriginalMetadataAuthor(this.authorReference);\n        verify(targetAttachment).setDoc(this.targetDocument);\n        verify(this.targetDocument).setAttachment(targetAttachment);\n    }\n\n    @Test\n    void processTargetSaveFail() throws Exception\n    {\n        // Request initialization.\n        this.request.setEntityReferences(singletonList(SOURCE_ATTACHMENT_LOCATION));\n        this.request.setProperty(MoveAttachmentRequest.DESTINATION, TARGET_ATTACHMENT_LOCATION);\n        this.request.setProperty(MoveAttachmentRequest.AUTO_REDIRECT, true);\n        this.request.setInteractive(false);\n\n        XWikiAttachment sourceAttachment = mock(XWikiAttachment.class);\n        XWikiAttachment targetAttachment = mock(XWikiAttachment.class);\n        XWikiAttachment newSourceAttachment = mock(XWikiAttachment.class);\n        when(sourceAttachment.getFilename()).thenReturn(\"oldName\");\n        when(this.sourceDocument.getExactAttachment(\"oldName\")).thenReturn(sourceAttachment);\n        when(this.targetDocument.getExactAttachment(\"newName\")).thenReturn(targetAttachment);\n        when(this.contextualLocalizationManager.getTranslationPlain(\"attachment.job.saveDocument.source\",\n            \"xwiki:Space.Target\"))\n            .thenReturn(\"attachment.job.saveDocument.source [xwiki:Space.Target]\");\n        when(this.contextualLocalizationManager.getTranslationPlain(\"attachment.job.saveDocument.target\",\n            \"xwiki:Space.Source\"))\n            .thenReturn(\"attachment.job.saveDocument.target [xwiki:Space.Source]\");\n        when(this.contextualLocalizationManager.getTranslationPlain(\"attachment.job.rollbackDocument.target\",\n            \"oldName\", \"xwiki:Space.Source\")).thenReturn(\n            \"attachment.job.rollbackDocument.target [oldName, xwiki:Space.Source]\");\n        doThrow(new XWikiException()).when(this.wiki)\n            .saveDocument(this.targetDocument, \"attachment.job.saveDocument.target [xwiki:Space.Source]\", this.context);\n        when(sourceAttachment.clone(\"newName\", this.context)).thenReturn(targetAttachment);\n        when(targetAttachment.clone(\"oldName\", this.context)).thenReturn(newSourceAttachment);\n\n        this.job.process(SOURCE_ATTACHMENT_LOCATION);\n        verify(this.sourceDocument).removeAttachment(sourceAttachment);\n        verify(this.attachmentsManager).removeExistingRedirection(\"newName\", this.targetDocument);\n        // Initialization of the redirection.\n        verify(this.sourceDocument).createXObject(RedirectAttachmentClassDocumentInitializer.REFERENCE, this.context);\n        verify(this.wiki).saveDocument(this.sourceDocument,\n            \"attachment.job.saveDocument.source [xwiki:Space.Target]\", this.context);\n        // Check that the attachment is rolled back and saved again.\n        verify(this.wiki).saveDocument(this.sourceDocument,\n            \"attachment.job.rollbackDocument.target [oldName, xwiki:Space.Source]\", true, this.context);\n        verify(targetAttachment).setDoc(this.targetDocument);\n        verify(this.targetDocument).setAttachment(targetAttachment);\n        verify(newSourceAttachment).setDoc(this.sourceDocument);\n        verify(this.sourceDocument).setAttachment(newSourceAttachment);\n        assertEquals(1, this.logCapture.size());\n        assertEquals(Level.WARN, this.logCapture.getLogEvent(0).getLevel());\n        assertEquals(\n            \"Failed to move attachment [Attachment xwiki:Space.Source@oldName] to \"\n                + \"[Attachment xwiki:Space.Target@newName]. Cause: [XWikiException: Error number 0 in 0]\",\n            this.logCapture.getMessage(0));\n    }\n\n    @Test\n    void processRename() throws Exception\n    {\n        // Request initialization.\n        this.request.setEntityReferences(singletonList(SOURCE_ATTACHMENT_LOCATION));\n        this.request.setProperty(MoveAttachmentRequest.DESTINATION,\n            new AttachmentReference(\"newName\", SOURCE_LOCATION));\n        this.request.setProperty(MoveAttachmentRequest.AUTO_REDIRECT, true);\n        this.request.setInteractive(false);\n        this.request.setUserReference(AUTHOR_REFERENCE);\n\n        XWikiAttachment sourceAttachment = mock(XWikiAttachment.class);\n        XWikiAttachment targetAttachment = mock(XWikiAttachment.class);\n        when(sourceAttachment.getFilename()).thenReturn(\"oldName\");\n        when(this.sourceDocument.getExactAttachment(\"oldName\")).thenReturn(sourceAttachment);\n        when(this.contextualLocalizationManager.getTranslationPlain(\"attachment.job.saveDocument.inPlace\",\n            \"oldName\", \"newName\")).thenReturn(\"attachment.job.saveDocument.inPlace [oldName, newName]\");\n        when(sourceAttachment.clone(\"newName\", this.context)).thenReturn(targetAttachment);\n\n        this.job.process(SOURCE_ATTACHMENT_LOCATION);\n\n        // Since we rename inside the source, the target document must not be modified.\n        verifyNoInteractions(this.targetDocument);\n        verify(this.sourceDocument).removeAttachment(sourceAttachment);\n        verify(this.attachmentsManager).removeExistingRedirection(\"newName\", this.sourceDocument);\n        verify(targetAttachment).setDoc(this.sourceDocument);\n        verify(this.sourceDocument).setAttachment(targetAttachment);\n        // Initialization of the redirection.\n        verify(this.sourceDocument).createXObject(RedirectAttachmentClassDocumentInitializer.REFERENCE, this.context);\n        verify(this.wiki).saveDocument(this.sourceDocument, \"attachment.job.saveDocument.inPlace [oldName, newName]\",\n            this.context);\n        verify(this.modelBridge).setContextUserReference(AUTHOR_REFERENCE);\n        verify(this.sourceAuthors, times(2)).setEffectiveMetadataAuthor(this.authorReference);\n        verify(this.sourceAuthors, times(2)).setOriginalMetadataAuthor(this.authorReference);\n    }\n}\n"], "fixing_code": ["/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.attachment.internal.refactoring.job;\n\nimport java.io.IOException;\nimport java.util.Objects;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Provider;\n\nimport org.xwiki.attachment.internal.AttachmentsManager;\nimport org.xwiki.attachment.internal.RedirectAttachmentClassDocumentInitializer;\nimport org.xwiki.attachment.refactoring.MoveAttachmentRequest;\nimport org.xwiki.attachment.refactoring.event.AttachmentMovedEvent;\nimport org.xwiki.component.annotation.Component;\nimport org.xwiki.localization.ContextualLocalizationManager;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.refactoring.internal.job.AbstractEntityJob;\nimport org.xwiki.refactoring.job.EntityJobStatus;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceResolver;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiAttachment;\nimport com.xpn.xwiki.doc.XWikiDocument;\nimport com.xpn.xwiki.objects.BaseObject;\n\nimport static org.apache.commons.lang.exception.ExceptionUtils.getRootCauseMessage;\nimport static org.xwiki.attachment.internal.RedirectAttachmentClassDocumentInitializer.SOURCE_NAME_FIELD;\nimport static org.xwiki.attachment.internal.RedirectAttachmentClassDocumentInitializer.TARGET_LOCATION_FIELD;\nimport static org.xwiki.attachment.internal.RedirectAttachmentClassDocumentInitializer.TARGET_NAME_FIELD;\n\n/**\n * This is the job in charge of moving attachments.\n *\n * @version $Id$\n * @since 14.0RC1\n */\n@Component\n@Named(MoveAttachmentJob.HINT)\npublic class MoveAttachmentJob\n    extends AbstractEntityJob<MoveAttachmentRequest, EntityJobStatus<MoveAttachmentRequest>>\n{\n    /**\n     * The hint for this job.\n     */\n    public static final String HINT = \"refactoring/attachment/move\";\n\n    @Inject\n    private Provider<XWikiContext> xcontextProvider;\n\n    @Inject\n    private EntityReferenceSerializer<String> entityReferenceSerializer;\n\n    @Inject\n    private ContextualLocalizationManager contextualLocalizationManager;\n\n    @Inject\n    private EntityReferenceSerializer<String> referenceSerializer;\n\n    @Inject\n    private AttachmentsManager attachmentsManager;\n\n    @Inject\n    @Named(\"document\")\n    private UserReferenceResolver<DocumentReference> documentReferenceUserReferenceResolver;\n\n    @Override\n    public String getType()\n    {\n        return HINT;\n    }\n\n    @Override\n    protected void process(EntityReference source)\n    {\n        this.progressManager.pushLevelProgress(2, this);\n        AttachmentReference destination = this.request.getProperty(MoveAttachmentRequest.DESTINATION);\n        boolean autoRedirect = this.request.getProperty(MoveAttachmentRequest.AUTO_REDIRECT);\n\n        XWiki wiki = this.xcontextProvider.get().getWiki();\n\n        // Update the author for the attribution of the attachment uploader.\n        this.modelBridge.setContextUserReference(this.request.getUserReference());\n        try {\n            if (checkMoveRights(source, destination)) {\n                this.progressManager.startStep(this);\n                moveAttachment(source, destination, autoRedirect, wiki);\n                this.progressManager.endStep(this);\n\n                this.progressManager.startStep(this);\n                this.observationManager.notify(new AttachmentMovedEvent((AttachmentReference) source, destination),\n                    this,\n                    this.request);\n                this.progressManager.endStep(this);\n            }\n        } finally {\n            this.progressManager.popLevelProgress(this);\n        }\n    }\n\n    private boolean checkMoveRights(EntityReference source, EntityReference destination)\n    {\n        // Check view and edit right on source to ensure that the user doesn't get view right through the move.\n        // While edit right implies view right, the view right might be explicitly denied.\n        boolean hasSourceRight = hasAccess(Right.VIEW, source) && hasAccess(Right.EDIT, source);\n        boolean hasDestinationRight = hasAccess(Right.EDIT, destination);\n\n        if (!hasSourceRight) {\n            this.logger.error(\"You don't have sufficient permissions over the source attachment [{}].\", source);\n        } else if (!hasDestinationRight) {\n            // The destination's document might be the same as the source, therefore, only log the error when there is\n            // no error regarding the source.\n            this.logger.error(\"You don't have sufficient permissions over the destination attachment [{}].\",\n                destination);\n        }\n\n        return hasSourceRight && hasDestinationRight;\n    }\n\n    private void moveAttachment(EntityReference source, AttachmentReference destination, boolean autoRedirect,\n        XWiki wiki)\n    {\n        try {\n            XWikiDocument sourceDocument = wiki.getDocument(source.getParent(), this.xcontextProvider.get());\n            XWikiDocument targetDocument = wiki.getDocument(destination.getParent(), this.xcontextProvider.get());\n            XWikiAttachment sourceAttachment = sourceDocument.getExactAttachment(source.getName());\n\n            // Update the author of the source and target documents.\n            UserReference authorUserReference =\n                this.documentReferenceUserReferenceResolver.resolve(this.request.getUserReference());\n            sourceDocument.getAuthors().setEffectiveMetadataAuthor(authorUserReference);\n            sourceDocument.getAuthors().setOriginalMetadataAuthor(authorUserReference);\n            targetDocument.getAuthors().setEffectiveMetadataAuthor(authorUserReference);\n            targetDocument.getAuthors().setOriginalMetadataAuthor(authorUserReference);\n\n            // Remove the original attachment and create a new one with the same name.\n            sourceDocument.removeAttachment(sourceAttachment);\n\n            addAttachment(targetDocument, sourceAttachment, destination.getName());\n\n            this.attachmentsManager.removeExistingRedirection(destination.getName(), targetDocument);\n\n            if (autoRedirect) {\n                initializeAutoRedirection(source, destination, sourceDocument);\n            }\n\n            if (Objects.equals(source.getParent(), destination.getParent())) {\n                wiki.saveDocument(sourceDocument,\n                    this.contextualLocalizationManager.getTranslationPlain(\"attachment.job.saveDocument.inPlace\",\n                        source.getName(), destination.getName()),\n                    this.xcontextProvider.get());\n            } else {\n                transactionalMove(wiki, sourceDocument, targetDocument, sourceAttachment.getFilename(),\n                    destination.getName());\n            }\n        } catch (XWikiException | IOException e) {\n            this.logger.warn(\"Failed to move attachment [{}] to [{}]. Cause: [{}]\", source, destination,\n                getRootCauseMessage(e));\n        }\n    }\n\n    /**\n     * Move the attachment from one document to another. In case of failure when saving the target document, the source\n     * document is rollback with its attachment.\n     *\n     * @param wiki the wiki instance used to perform the documents save\n     * @param sourceDocument the source document, containing the attachment to move\n     * @param targetDocument the target document, in which to move the attachment\n     * @param sourceFileName the file name of the source attachment\n     * @param targetFileName the file name of the target attachment\n     * @throws XWikiException in case of error when save the document\n     * @throws IOException in case of error when putting back the attachment in the source document during the\n     *     rollback\n     */\n    private void transactionalMove(XWiki wiki, XWikiDocument sourceDocument, XWikiDocument targetDocument,\n        String sourceFileName, String targetFileName) throws XWikiException, IOException\n    {\n        String sourceSerialized = this.referenceSerializer.serialize(sourceDocument.getDocumentReference());\n        String destinationSerialized = this.referenceSerializer.serialize(targetDocument.getDocumentReference());\n        String historyMessageSource =\n            this.contextualLocalizationManager.getTranslationPlain(\"attachment.job.saveDocument.source\",\n                destinationSerialized);\n        String historyMessageTarget =\n            this.contextualLocalizationManager.getTranslationPlain(\"attachment.job.saveDocument.target\",\n                sourceSerialized);\n        wiki.saveDocument(sourceDocument, historyMessageSource, this.xcontextProvider.get());\n        try {\n            wiki.saveDocument(targetDocument, historyMessageTarget, this.xcontextProvider.get());\n        } catch (Exception e) {\n            // In case of failure during the save of the second document, we rollback the first one to its initial state\n            // (i.e., with the attachment added again).\n            // Remove the added attachment from the target document.\n            XWikiAttachment attachment = targetDocument.getExactAttachment(targetFileName);\n            addAttachment(sourceDocument, attachment, sourceFileName);\n            targetDocument.removeAttachment(attachment);\n            String historyMessageRollbackTarget =\n                this.contextualLocalizationManager.getTranslationPlain(\"attachment.job.rollbackDocument.target\",\n                    sourceFileName, sourceSerialized);\n            wiki.saveDocument(sourceDocument, historyMessageRollbackTarget, true, this.xcontextProvider.get());\n            // We re-throw the exception since at the end, the job failed.\n            throw e;\n        }\n    }\n\n    private void initializeAutoRedirection(EntityReference source, AttachmentReference destination,\n        XWikiDocument sourceDocument)\n        throws XWikiException\n    {\n        int idx = sourceDocument.createXObject(RedirectAttachmentClassDocumentInitializer.REFERENCE,\n            this.xcontextProvider.get());\n        BaseObject xObject =\n            sourceDocument.getXObject(RedirectAttachmentClassDocumentInitializer.REFERENCE, idx);\n        if (xObject != null) {\n            xObject.setStringValue(SOURCE_NAME_FIELD, source.getName());\n            xObject.setStringValue(TARGET_LOCATION_FIELD,\n                this.entityReferenceSerializer.serialize(destination.getParent()));\n            xObject.setStringValue(TARGET_NAME_FIELD, destination.getName());\n        }\n    }\n\n    private void addAttachment(XWikiDocument targetDocument, XWikiAttachment oldAttachment, String newName)\n        throws IOException, XWikiException\n    {\n        // Clone the attachment and its history to the new document, with the new name.\n        XWikiAttachment newAttachment = oldAttachment.clone(newName, this.xcontextProvider.get());\n        newAttachment.setDoc(targetDocument);\n        targetDocument.setAttachment(newAttachment);\n    }\n}\n", "/*\n * See the NOTICE file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * This is free software; you can redistribute it and/or modify it\n * under the terms of the GNU Lesser General Public License as\n * published by the Free Software Foundation; either version 2.1 of\n * the License, or (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this software; if not, write to the Free\n * Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA\n * 02110-1301 USA, or see the FSF site: http://www.fsf.org.\n */\npackage org.xwiki.attachment.internal.refactoring.job;\n\nimport javax.inject.Named;\nimport javax.inject.Provider;\n\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.RegisterExtension;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.CsvSource;\nimport org.mockito.Mock;\nimport org.xwiki.attachment.internal.AttachmentsManager;\nimport org.xwiki.attachment.internal.RedirectAttachmentClassDocumentInitializer;\nimport org.xwiki.attachment.refactoring.MoveAttachmentRequest;\nimport org.xwiki.localization.ContextualLocalizationManager;\nimport org.xwiki.model.document.DocumentAuthors;\nimport org.xwiki.model.reference.AttachmentReference;\nimport org.xwiki.model.reference.DocumentReference;\nimport org.xwiki.model.reference.EntityReference;\nimport org.xwiki.model.reference.EntityReferenceSerializer;\nimport org.xwiki.refactoring.internal.ModelBridge;\nimport org.xwiki.security.authorization.AuthorizationManager;\nimport org.xwiki.security.authorization.Right;\nimport org.xwiki.test.LogLevel;\nimport org.xwiki.test.junit5.LogCaptureExtension;\nimport org.xwiki.test.junit5.mockito.ComponentTest;\nimport org.xwiki.test.junit5.mockito.InjectMockComponents;\nimport org.xwiki.test.junit5.mockito.MockComponent;\nimport org.xwiki.user.UserReference;\nimport org.xwiki.user.UserReferenceResolver;\n\nimport com.xpn.xwiki.XWiki;\nimport com.xpn.xwiki.XWikiContext;\nimport com.xpn.xwiki.XWikiException;\nimport com.xpn.xwiki.doc.XWikiAttachment;\nimport com.xpn.xwiki.doc.XWikiDocument;\n\nimport ch.qos.logback.classic.Level;\n\nimport static java.util.Collections.singletonList;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.ArgumentMatchers.eq;\nimport static org.mockito.Mockito.doThrow;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.never;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.verifyNoInteractions;\nimport static org.mockito.Mockito.when;\n\n/**\n * Test of {@link MoveAttachmentJob}.\n *\n * @version $Id$\n * @since 14.0RC1\n */\n@ComponentTest\nclass MoveAttachmentJobTest\n{\n    private static final DocumentReference SOURCE_LOCATION = new DocumentReference(\"xwiki\", \"Space\", \"Source\");\n\n    private static final AttachmentReference SOURCE_ATTACHMENT_LOCATION =\n        new AttachmentReference(\"oldName\", SOURCE_LOCATION);\n\n    private static final DocumentReference AUTHOR_REFERENCE = new DocumentReference(\"xwiki\", \"XWiki\", \"User1\");\n\n    private static final DocumentReference USER2_REFERENCE = new DocumentReference(\"xwiki\", \"XWiki\", \"User2\");\n\n    private static final DocumentReference TARGET_LOCATION = new DocumentReference(\"xwiki\", \"Space\", \"Target\");\n\n    private static final AttachmentReference TARGET_ATTACHMENT_LOCATION =\n        new AttachmentReference(\"newName\", TARGET_LOCATION);\n\n    @InjectMockComponents\n    private MoveAttachmentJob job;\n\n    @MockComponent\n    private Provider<XWikiContext> xcontextProvider;\n\n    @MockComponent\n    private EntityReferenceSerializer<String> entityReferenceSerializer;\n\n    @MockComponent\n    private ContextualLocalizationManager contextualLocalizationManager;\n\n    @MockComponent\n    private EntityReferenceSerializer<String> referenceSerializer;\n\n    @MockComponent\n    private AttachmentsManager attachmentsManager;\n\n    @MockComponent\n    private ModelBridge modelBridge;\n\n    @MockComponent\n    @Named(\"document\")\n    private UserReferenceResolver<DocumentReference> documentReferenceUserReferenceResolver;\n\n    @MockComponent\n    private AuthorizationManager authorizationManager;\n\n    @Mock\n    private XWikiContext context;\n\n    @Mock\n    private XWiki wiki;\n\n    @Mock\n    private XWikiDocument sourceDocument;\n\n    @Mock\n    private XWikiDocument targetDocument;\n\n    @Mock\n    private DocumentAuthors sourceAuthors;\n\n    @Mock\n    private DocumentAuthors targetAuthors;\n\n    @Mock\n    private UserReference authorReference;\n\n    @RegisterExtension\n    private LogCaptureExtension logCapture = new LogCaptureExtension(LogLevel.WARN);\n\n    private MoveAttachmentRequest request;\n\n    @BeforeEach\n    void setUp() throws Exception\n    {\n        this.request = new MoveAttachmentRequest();\n        this.job.initialize(this.request);\n        when(this.xcontextProvider.get()).thenReturn(this.context);\n        when(this.context.getWiki()).thenReturn(this.wiki);\n\n        // The cast is mandatory otherwise the wrong method is mocked (the DocumentReference one).\n        when(this.wiki.getDocument((EntityReference) SOURCE_LOCATION, this.context)).thenReturn(this.sourceDocument);\n        when(this.wiki.getDocument((EntityReference) TARGET_LOCATION, this.context)).thenReturn(this.targetDocument);\n        when(this.sourceDocument.getAuthors()).thenReturn(this.sourceAuthors);\n        when(this.targetDocument.getAuthors()).thenReturn(this.targetAuthors);\n        when(this.sourceDocument.getDocumentReference()).thenReturn(SOURCE_LOCATION);\n        when(this.targetDocument.getDocumentReference()).thenReturn(TARGET_LOCATION);\n        when(this.referenceSerializer.serialize(TARGET_ATTACHMENT_LOCATION)).thenReturn(\"xwiki:Space.Target@newName\");\n        when(this.referenceSerializer.serialize(SOURCE_ATTACHMENT_LOCATION)).thenReturn(\"xwiki:Space.Source@oldName\");\n        when(this.referenceSerializer.serialize(TARGET_LOCATION)).thenReturn(\"xwiki:Space.Target\");\n        when(this.referenceSerializer.serialize(SOURCE_LOCATION)).thenReturn(\"xwiki:Space.Source\");\n        when(this.documentReferenceUserReferenceResolver.resolve(AUTHOR_REFERENCE)).thenReturn(this.authorReference);\n\n        // Grant global view and edit right.\n        when(this.authorizationManager.hasAccess(eq(Right.VIEW), eq(AUTHOR_REFERENCE), any(AttachmentReference.class)))\n            .thenReturn(true);\n        when(this.authorizationManager.hasAccess(eq(Right.EDIT), eq(AUTHOR_REFERENCE), any(AttachmentReference.class)))\n            .thenReturn(true);\n    }\n\n    @Test\n    void process() throws Exception\n    {\n        // Request initialization.\n        this.request.setEntityReferences(singletonList(SOURCE_ATTACHMENT_LOCATION));\n        this.request.setProperty(MoveAttachmentRequest.DESTINATION, TARGET_ATTACHMENT_LOCATION);\n        this.request.setProperty(MoveAttachmentRequest.AUTO_REDIRECT, true);\n        this.request.setInteractive(false);\n        this.request.setUserReference(AUTHOR_REFERENCE);\n        this.request.setAuthorReference(AUTHOR_REFERENCE);\n\n        XWikiAttachment sourceAttachment = mock(XWikiAttachment.class);\n        XWikiAttachment targetAttachment = mock(XWikiAttachment.class);\n\n        when(sourceAttachment.getFilename()).thenReturn(\"oldName\");\n        when(this.sourceDocument.getExactAttachment(\"oldName\")).thenReturn(sourceAttachment);\n        when(this.contextualLocalizationManager.getTranslationPlain(\"attachment.job.saveDocument.source\",\n            \"xwiki:Space.Target\"))\n            .thenReturn(\"attachment.job.saveDocument.source [xwiki:Space.Target]\");\n        when(this.contextualLocalizationManager.getTranslationPlain(\"attachment.job.saveDocument.target\",\n            \"xwiki:Space.Source\"))\n            .thenReturn(\"attachment.job.saveDocument.target [xwiki:Space.Source]\");\n        when(sourceAttachment.clone(\"newName\", this.context)).thenReturn(targetAttachment);\n\n        this.job.process(SOURCE_ATTACHMENT_LOCATION);\n        verify(this.sourceDocument).removeAttachment(sourceAttachment);\n        verify(this.attachmentsManager).removeExistingRedirection(\"newName\", this.targetDocument);\n        // Initialization of the redirection.\n        verify(this.sourceDocument).createXObject(RedirectAttachmentClassDocumentInitializer.REFERENCE, this.context);\n        verify(this.wiki).saveDocument(this.sourceDocument,\n            \"attachment.job.saveDocument.source [xwiki:Space.Target]\", this.context);\n        verify(this.wiki).saveDocument(this.targetDocument,\n            \"attachment.job.saveDocument.target [xwiki:Space.Source]\", this.context);\n        verify(this.modelBridge).setContextUserReference(AUTHOR_REFERENCE);\n        verify(this.targetAuthors).setEffectiveMetadataAuthor(this.authorReference);\n        verify(this.sourceAuthors).setEffectiveMetadataAuthor(this.authorReference);\n        verify(this.targetAuthors).setOriginalMetadataAuthor(this.authorReference);\n        verify(this.sourceAuthors).setOriginalMetadataAuthor(this.authorReference);\n        verify(targetAttachment).setDoc(this.targetDocument);\n        verify(this.targetDocument).setAttachment(targetAttachment);\n    }\n\n    @Test\n    void processTargetSaveFail() throws Exception\n    {\n        // Request initialization.\n        this.request.setEntityReferences(singletonList(SOURCE_ATTACHMENT_LOCATION));\n        this.request.setProperty(MoveAttachmentRequest.DESTINATION, TARGET_ATTACHMENT_LOCATION);\n        this.request.setProperty(MoveAttachmentRequest.AUTO_REDIRECT, true);\n        this.request.setInteractive(false);\n        this.request.setUserReference(AUTHOR_REFERENCE);\n        this.request.setAuthorReference(AUTHOR_REFERENCE);\n\n        XWikiAttachment sourceAttachment = mock(XWikiAttachment.class);\n        XWikiAttachment targetAttachment = mock(XWikiAttachment.class);\n        XWikiAttachment newSourceAttachment = mock(XWikiAttachment.class);\n        when(sourceAttachment.getFilename()).thenReturn(\"oldName\");\n        when(this.sourceDocument.getExactAttachment(\"oldName\")).thenReturn(sourceAttachment);\n        when(this.targetDocument.getExactAttachment(\"newName\")).thenReturn(targetAttachment);\n        when(this.contextualLocalizationManager.getTranslationPlain(\"attachment.job.saveDocument.source\",\n            \"xwiki:Space.Target\"))\n            .thenReturn(\"attachment.job.saveDocument.source [xwiki:Space.Target]\");\n        when(this.contextualLocalizationManager.getTranslationPlain(\"attachment.job.saveDocument.target\",\n            \"xwiki:Space.Source\"))\n            .thenReturn(\"attachment.job.saveDocument.target [xwiki:Space.Source]\");\n        when(this.contextualLocalizationManager.getTranslationPlain(\"attachment.job.rollbackDocument.target\",\n            \"oldName\", \"xwiki:Space.Source\")).thenReturn(\n            \"attachment.job.rollbackDocument.target [oldName, xwiki:Space.Source]\");\n        doThrow(new XWikiException()).when(this.wiki)\n            .saveDocument(this.targetDocument, \"attachment.job.saveDocument.target [xwiki:Space.Source]\", this.context);\n        when(sourceAttachment.clone(\"newName\", this.context)).thenReturn(targetAttachment);\n        when(targetAttachment.clone(\"oldName\", this.context)).thenReturn(newSourceAttachment);\n\n        this.job.process(SOURCE_ATTACHMENT_LOCATION);\n        verify(this.sourceDocument).removeAttachment(sourceAttachment);\n        verify(this.attachmentsManager).removeExistingRedirection(\"newName\", this.targetDocument);\n        // Initialization of the redirection.\n        verify(this.sourceDocument).createXObject(RedirectAttachmentClassDocumentInitializer.REFERENCE, this.context);\n        verify(this.wiki).saveDocument(this.sourceDocument,\n            \"attachment.job.saveDocument.source [xwiki:Space.Target]\", this.context);\n        // Check that the attachment is rolled back and saved again.\n        verify(this.wiki).saveDocument(this.sourceDocument,\n            \"attachment.job.rollbackDocument.target [oldName, xwiki:Space.Source]\", true, this.context);\n        verify(targetAttachment).setDoc(this.targetDocument);\n        verify(this.targetDocument).setAttachment(targetAttachment);\n        verify(newSourceAttachment).setDoc(this.sourceDocument);\n        verify(this.sourceDocument).setAttachment(newSourceAttachment);\n        assertEquals(1, this.logCapture.size());\n        assertEquals(Level.WARN, this.logCapture.getLogEvent(0).getLevel());\n        assertEquals(\n            \"Failed to move attachment [Attachment xwiki:Space.Source@oldName] to \"\n                + \"[Attachment xwiki:Space.Target@newName]. Cause: [XWikiException: Error number 0 in 0]\",\n            this.logCapture.getMessage(0));\n    }\n\n    @Test\n    void processRename() throws Exception\n    {\n        // Request initialization.\n        this.request.setEntityReferences(singletonList(SOURCE_ATTACHMENT_LOCATION));\n        this.request.setProperty(MoveAttachmentRequest.DESTINATION,\n            new AttachmentReference(\"newName\", SOURCE_LOCATION));\n        this.request.setProperty(MoveAttachmentRequest.AUTO_REDIRECT, true);\n        this.request.setInteractive(false);\n        this.request.setUserReference(AUTHOR_REFERENCE);\n        this.request.setAuthorReference(AUTHOR_REFERENCE);\n\n        XWikiAttachment sourceAttachment = mock(XWikiAttachment.class);\n        XWikiAttachment targetAttachment = mock(XWikiAttachment.class);\n        when(sourceAttachment.getFilename()).thenReturn(\"oldName\");\n        when(this.sourceDocument.getExactAttachment(\"oldName\")).thenReturn(sourceAttachment);\n        when(this.contextualLocalizationManager.getTranslationPlain(\"attachment.job.saveDocument.inPlace\",\n            \"oldName\", \"newName\")).thenReturn(\"attachment.job.saveDocument.inPlace [oldName, newName]\");\n        when(sourceAttachment.clone(\"newName\", this.context)).thenReturn(targetAttachment);\n\n        this.job.process(SOURCE_ATTACHMENT_LOCATION);\n\n        // Since we rename inside the source, the target document must not be modified.\n        verifyNoInteractions(this.targetDocument);\n        verify(this.sourceDocument).removeAttachment(sourceAttachment);\n        verify(this.attachmentsManager).removeExistingRedirection(\"newName\", this.sourceDocument);\n        verify(targetAttachment).setDoc(this.sourceDocument);\n        verify(this.sourceDocument).setAttachment(targetAttachment);\n        // Initialization of the redirection.\n        verify(this.sourceDocument).createXObject(RedirectAttachmentClassDocumentInitializer.REFERENCE, this.context);\n        verify(this.wiki).saveDocument(this.sourceDocument, \"attachment.job.saveDocument.inPlace [oldName, newName]\",\n            this.context);\n        verify(this.modelBridge).setContextUserReference(AUTHOR_REFERENCE);\n        verify(this.sourceAuthors, times(2)).setEffectiveMetadataAuthor(this.authorReference);\n        verify(this.sourceAuthors, times(2)).setOriginalMetadataAuthor(this.authorReference);\n    }\n\n    @ParameterizedTest\n    @CsvSource({\n        \"true, true\",\n        \"false, true\",\n        \"true, false\",\n        \"false, false\"\n    })\n    void failWithoutRights(boolean canView, boolean canEdit) throws Exception\n    {\n        // Request initialization.\n        this.request.setEntityReferences(singletonList(SOURCE_ATTACHMENT_LOCATION));\n        this.request.setProperty(MoveAttachmentRequest.DESTINATION, TARGET_ATTACHMENT_LOCATION);\n        this.request.setProperty(MoveAttachmentRequest.AUTO_REDIRECT, true);\n        this.request.setInteractive(false);\n        this.request.setUserReference(USER2_REFERENCE);\n        this.request.setAuthorReference(AUTHOR_REFERENCE);\n\n        when(this.authorizationManager.hasAccess(Right.EDIT, USER2_REFERENCE, SOURCE_ATTACHMENT_LOCATION))\n            .thenReturn(canEdit);\n        when(this.authorizationManager.hasAccess(Right.VIEW, USER2_REFERENCE, SOURCE_ATTACHMENT_LOCATION))\n            .thenReturn(canView);\n        when(this.authorizationManager.hasAccess(Right.EDIT, USER2_REFERENCE, TARGET_ATTACHMENT_LOCATION))\n            .thenReturn(false);\n\n        this.job.process(SOURCE_ATTACHMENT_LOCATION);\n\n        // Verify nothing has been modified.\n        verifyNoInteractions(this.sourceDocument, this.targetDocument);\n        verifyNoInteractions(this.attachmentsManager);\n        verify(this.wiki, never()).saveDocument(any(), any(), any());\n        verifyNoInteractions(this.targetAuthors, this.sourceAuthors);\n\n        if (!canEdit || !canView) {\n            assertEquals(\"You don't have sufficient permissions over the source attachment \"\n                + \"[Attachment xwiki:Space.Source@oldName].\", this.logCapture.getMessage(0));\n        } else {\n            assertEquals(\"You don't have sufficient permissions over the destination attachment \"\n                + \"[Attachment xwiki:Space.Target@newName].\", this.logCapture.getMessage(0));\n        }\n    }\n}\n"], "filenames": ["xwiki-platform-core/xwiki-platform-attachment/xwiki-platform-attachment-api/src/main/java/org/xwiki/attachment/internal/refactoring/job/MoveAttachmentJob.java", "xwiki-platform-core/xwiki-platform-attachment/xwiki-platform-attachment-api/src/test/java/org/xwiki/attachment/internal/refactoring/job/MoveAttachmentJobTest.java"], "buggy_code_start_loc": [40, 27], "buggy_code_end_loc": [119, 284], "fixing_code_start_loc": [41, 28], "fixing_code_end_loc": [143, 348], "type": "CWE-862", "message": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting with the introduction of attachment move support in version 14.0-rc-1 and prior to versions 14.4.8, 14.10.4, and 15.0-rc-1, an attacker with edit access on any document (can be the user profile which is editable by default) can move any attachment of any other document to this attacker-controlled document. This allows the attacker to access and possibly publish any attachment of which the name is known, regardless if the attacker has view or edit rights on the source document of this attachment. Further, the attachment is deleted from the source document. This vulnerability has been patched in XWiki 14.4.8, 14.10.4, and 15.0 RC1. There is no workaround apart from upgrading to a fixed version.", "other": {"cve": {"id": "CVE-2023-37910", "sourceIdentifier": "security-advisories@github.com", "published": "2023-10-25T18:17:28.477", "lastModified": "2023-10-31T19:17:29.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "XWiki Platform is a generic wiki platform offering runtime services for applications built on top of it. Starting with the introduction of attachment move support in version 14.0-rc-1 and prior to versions 14.4.8, 14.10.4, and 15.0-rc-1, an attacker with edit access on any document (can be the user profile which is editable by default) can move any attachment of any other document to this attacker-controlled document. This allows the attacker to access and possibly publish any attachment of which the name is known, regardless if the attacker has view or edit rights on the source document of this attachment. Further, the attachment is deleted from the source document. This vulnerability has been patched in XWiki 14.4.8, 14.10.4, and 15.0 RC1. There is no workaround apart from upgrading to a fixed version."}, {"lang": "es", "value": "XWiki Platform es una plataforma wiki gen\u00e9rica que ofrece servicios de ejecuci\u00f3n para aplicaciones creadas sobre ella. A partir de la introducci\u00f3n de la compatibilidad con el movimiento de archivos adjuntos en la versi\u00f3n 14.0-rc-1 y antes de las versiones 14.4.8, 14.10.4 y 15.0-rc-1, un atacante con acceso de edici\u00f3n a cualquier documento (puede ser el perfil de usuario que est\u00e1 editable de forma predeterminada) puede mover cualquier archivo adjunto de cualquier otro documento a este documento controlado por el atacante. Esto permite al atacante acceder y posiblemente publicar cualquier archivo adjunto cuyo nombre se conozca, independientemente de si el atacante tiene derechos de visualizaci\u00f3n o edici\u00f3n sobre el documento fuente de este archivo adjunto. Adem\u00e1s, el archivo adjunto se elimina del documento fuente. Esta vulnerabilidad ha sido parcheada en XWiki 14.4.8, 14.10.4 y 15.0 RC1. No existe otro workaround aparte de actualizar a una versi\u00f3n fija."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-862"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-862"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.0", "versionEndExcluding": "14.4.8", "matchCriteriaId": "AD2B185D-F8A6-49EB-B485-744F234B8730"}, {"vulnerable": true, "criteria": "cpe:2.3:a:xwiki:xwiki:*:*:*:*:*:*:*:*", "versionStartIncluding": "14.5", "versionEndExcluding": "14.10.4", "matchCriteriaId": "90CB686A-3833-4F03-A312-38825481A17C"}]}]}], "references": [{"url": "https://github.com/xwiki/xwiki-platform/commit/d7720219d60d7201c696c3196c9d4a86d0881325", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/xwiki/xwiki-platform/security/advisories/GHSA-rwwx-6572-mp29", "source": "security-advisories@github.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://jira.xwiki.org/browse/XWIKI-20334", "source": "security-advisories@github.com", "tags": ["Exploit", "Issue Tracking", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/xwiki/xwiki-platform/commit/d7720219d60d7201c696c3196c9d4a86d0881325"}}