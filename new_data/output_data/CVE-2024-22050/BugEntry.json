{"buggy_code": ["# Iodine\n[![Gem Version](https://badge.fury.io/rb/iodine.svg)](https://badge.fury.io/rb/iodine)\n[![Inline docs](http://inch-ci.org/github/boazsegev/iodine.svg?branch=master)](http://www.rubydoc.info/github/boazsegev/iodine/master/frames)\n\nPlease notice that this change log contains changes for upcoming releases as well. Please refer to the current gem version to review the current release.\n\n## Changes:\n\n#### Change log v.0.7.33\n\n**Fix**: (`iodine`) exception protection would fail and crash if the exception throws wasn't of type `Exception`. I'm not sure how this would happen, but on some Ruby versions it appeared to have occur, maybe where a custom `raise` would be called with a non-exception type. The issue was fixed by testing for the availability of the `message` and `backtrace` functions. Credit to Jan Biedermann (@janbiedermann) for exposing this issue (#76).\n\n**Fix**: (`cli`) the CLI interface no longer requires Rack to be installed. If Rack is installed, it will be used. Otherwise, a copy of the Rack::Builder code will execute, licensed under the MIT license from the Rack source code (Copyright (C) 2007-2019 [Leah Neukirchen](http://leahneukirchen.org/infopage.html)).\n\n**Compatibility**: (`facil`) iodine would raise the signal `SIGINT` when shutting down in cluster mode, even if shutdown was initiated using `Iodine.stop`. Although this was designed to ensure worker processes would stop, this approach caused RSpec to stop testing and report an error. A temporary fix was applied and might be upstreamed to the facil.io repo. Credit to Jan Biedermann (@janbiedermann) for exposing this issue (#76).\n\n#### Change log v.0.7.32\n\n**Fix**: (`http1`) fixes a race-condition between the `on_ready` and `on_data` events, that could result in the `on_data` event being called twice instead of once (only possible with some clients). On multi-threaded workers, this could result in the CPU spinning while the task lock remains busy. Credit to N\u00e9stor Coppi (@Shelvak) for exposing the issue and providing an example application with detailed reports. Issue #75.\n\n#### Change log v.0.7.31\n\n**Security**: a heap-overflow vulnerability was fixed in the WebSocket parser. This attack could have been triggered remotely by a maliciously crafted message-header. Credit to Dane (4cad@silvertoque) for exposing this issue and providing a Python script demonstrating the attack. \n\nIt's recommended that all iodine users update to the latest version.\n\n#### Change log v.0.7.30\n\n**Update**: (`cli`) added support for the `-pid` flag - stores the master processes PID in a file.\n\n**Update**: (`cli`) added support for the `-config` (`-C`) flag - loads a configuration file immediately after loading iodine.\n\n#### Change log v.0.7.29\n\n**Fix**: fixed an issue where `env['rack.input'].read(nil, nil)` would return `nil` instead of `\"\"` on zero-content requests (i.e., an empty POST request). Credit to @thexa4 (Max Maton) for exposing this issue and providing a POC for debugging (issue #71).\n\n#### Change log v.0.7.28\n\n**Fix**: fixed an issue where iodine would crush (or hang) if unprotected exceptions were raised within a response body's `each` loop. This also fixes Fiber support when streaming with Roda (note: iodine will concat the body in a buffer before sending it). Credit to @adam12 (Adam Daniels) both for exposing the issue (#70) and testing possible solutions.\n\n#### Change log v.0.7.27\n\n**Compatibility**: (`iodine`) fixed the HTTP request `SCRIPT_NAME` variable (in the Rack `env`) to default to the global environment variable `SCRIPT_NAME` when `SCRIPT_NAME` isn't root (`/`). Credit to @thexa4 (Max Maton) for exposing this compatibility concern (issue #68).\n\n#### Change log v.0.7.26\n\n**Fix**: (`http`) fixed HTTP date format to force the day of the month to use two digits. Credit to @ianks (Ian Ker-Seymer) for exposing this issue (issue #64).\n\n**Fix**: (`iodine`) fixed static file service without an application (when using iodine as a stand-alone static file server).\n\n**Fix**: (`fio`) miscellaneous compatibility updates.\n\n#### Change log v.0.7.25\n\n**Fix**: (`iodine`) fixed host name binding when running `iodine` using `rackup` or through `Rack`. Credit to @adam12 (Adam Daniels) for PR #60.\n\n**Fix**: (`iodine`) removed bundler requirement in the `iodine.gemspec` file.\n\n#### Change log v.0.7.24\n\n**Fix**: (`fio`) fixed server shutdown on pub/sub stress, where internal pub/sub stress was mistakingly identified as a Slowloris attack. Credit to @moxgeek (Marouane Elmidaoui) for exposing this issue (plezi#32).\n\n**Fix**: (`fio`): fixed Slowloris detection for buffer attack variation.\n\n**Fix**: (`fio`): fixed `pending` result, where packet count wouldn't decrement until queue was drained.\n\n**Updates**: (`fio`) facil.io updates, including pub/sub memory improvements for cluster mode.\n\n#### Change log v.0.7.23\n\n**Fix**: (`fio`): fixed logging message for overflowing log messages. Credit to @weskerfoot (Wesley Kerfoot) and @adam12 (Adam Daniels) for exposing the issue (issue #56).\n\n**Updates**: (`fio`) facil.io updates.\n\n#### Change log v.0.7.22\n\n**Fix**: (`fio`, `redis`) fixed IPC messages between redis connections (in the master process) and callback blocks (executed in the worker processes). Credit to @moxgeek (Marouane Elmidaoui) for exposing this issue (plezi#31).\n\n#### Change log v.0.7.21\n\n**Fix**: (`iodine`, `redis`) Redis response was attempting to create Ruby objects outside the GIL. This is now fixed by entering the GIL earlier (before objects are created). Credit to @moxgeek (Marouane Elmidaoui) for exposing this issue (plezi#31).\n\n**Fix**: (`redis`) fixed Redis reconnection. Address and port data was mistakingly written at the wrong address, causing it to be overwritten by incoming (non-pub/sub) data.\n\n**Fix**: (`redis`) fixed a race condition in the Redis reconnection logic which might have caused more then a single pub/sub connection to be established and the first pending command to be sent again.\n\n#### Change log v.0.7.20\n\n**Security**: (`fio`) lower and smarter Slowloris detection limits (backlog limit is now 1,024 responses / messages per client). \n\n**Security**: (`http`) HTTP/1.1 slow client throttling - new requests will not be consumed until pending responses were sent. Since HTTP/1.1 is a response-request protocol, this protocol specific approach should protect the HTTP application against slow clients.\n\n**Fix**: (`iodine`) remove redundant Content-Type printout. Credit to @giovannibonetti (Giovanni Bonetti) for exposing the issue (#53).\n\n**Fix**: (`fio`) fix capacity maximization log to accommodate issues where `getrlimit` would return a `rlim_max` that's too high for `rlim_cur` (macOS).\n\n**Fix**: (`fio`) fix uninitialized `kqueue` message in `fio_poll_remove_fd`.\n\n**Fix**: (`docs`) @giovannibonetti (Giovanni Bonetti) fixed an error in the Rails README section, PR #52.\n\n#### Change log v.0.7.19\n\n**Deprecation**: (`iodine`) deprecated the CLI option `-tls-password`, use `-tls-pass` instead.\n\n**Security**: (`fio`) Slowloris mitigation is now part of the core library, where `FIO_SLOWLORIS_LIMIT` pending calls to `write` (currently 4,096 backlogged calls) will flag the connection as an attacker and close the connection. This protocol independent approach improves security.\n\n**Fix**: (`iodine`) log open file / socket limit per worker on startup.\n\n**Fix**: (`iodine`) application warm-up error was fixed. Deprecation warnings will still print for deprecated symbols loaded due to the warm-up sequence.\n\n**Update**: (`iodine`, `cli`) Support the environment variables `\"WORKERS\"` and `\"THREADS\"` out of the box (jury is out regarding `\"PORT\"` and `\"ADDRESS\"`, just use CLI for now).\n\n#### Change log v.0.7.18\n\n**Fix** (`pubsub`) fixed pub/sub for longer WebSocket messages. Issue where network byte ordering wasn't always respected and integer bit size was wrong for larger payloads. Credit to Marouane Elmidaoui (@moxgeek) for exposing the issue.\n\n#### Change log v.0.7.17\n\n**Security**: (`fio`) improved security against hash flooding attacks.\n\n**Update**: (`iodine`) SSL/TLS support!\n\n**Update**: (`iodine`) WebSocket client connections are now supported using `Iodine.connect` (both `ws://` and `wss://`)!\n\n**Deprecation**: (`iodine`) deprecated `DEFAULT_HTTP_ARGS` in favor of `DEFAULT_SETTEINGS`.\n\n**Deprecation**: (`iodine`) deprecated `Iodine.listen2http` in favor of `Iodine.listen service: :http`.\n\n**Fix**: (`iodine` / `pubsub`) fixed possible issue with global subscriptions (non-connection bound subscriptions).\n\n**Fix**: (`Iodine::Mustache`) fixed support for named argument, documentation and loading template from memory (rather than file) when creating a new `Iodine::Mustache` object.\n\n**Fix**: (`redis`) fixed an issue where destroying the Redis engine and exiting pre-maturely, could cause a segmentation fault during cleanup.\n\n**Fix**: (`iodine`, `fio`) fixed logging message when listening to Unix Sockets.\n\n**Fix**: (`iodine`) fixed CLI argument recognition for WebSocket message limits and HTTP header limits. Typos in the CLI argument names prevented the CLI from effecting the default values.\n\n**Fix**: (`fio`) fixed unaligned memory access in SipHash implementation and added secret randomization for each application restart.\n\n**Optimization**: (`iodine`) caching common header names to decrease Ruby memory allocations per request.\n\n#### Change log v.0.7.16\n\n**Security**: (`fio`) security fixes from the facil.io core library (updated to 0.7.0.beta6).\n\n**Update**: (`iodine`) better Redis support from CLI and environment (by setting the `IODINE_REDIS_URL` environment variable).\n\n**Optimization**: (`Iodine::Mustache`) optimized worst case scenario seeking by seeking Symbols before Strings, which improved seeking times.\n\n#### Change log v.0.7.15\n\n**Fix**: (`fio`) fixed a minor memory leak in cluster mode, caused by the root process not freeing the hash map used for child process subscription monitoring (only effected hot restarts).\n\n**Fix**: (`fio`) fixed superfluous and potentially erroneous pub/sub engine callback calls to `unsubscribe`, caused by (mistakingly) reporting filter channel closure.\n\n**Fix**: (`http/1.1`) avoid processing further requests if the connection was closed.\n\n**Fix**: (`iodine`) fixed some errors in the documentation and added a missing deprecation notice.\n\n**Update**: (`fio`) updated the automatic concurrency calculations to leave resources for the system when a negative value is provided (was only available for worker count calculations, now available for thread count as well).\n\n#### Change log v.0.7.14\n\n**Fix**: (`facil.io`) fixed superfluous ping event.\n\n**Fix**: (`iodine_tcp`) fixed responsiveness to the argument name `timeout` (a spelling mistake was testing for `timout`).\n\n**Fix**: (`iodine_store`) fixed missing EOL marker in DEBUG messages when reporting iodine's GC guard activity.\n\n**Update**: (`iodine`) added support for dynamic (hot) connection callback switching.\n\n#### Change log v.0.7.13\n\n**Fix**: (`mustache`) added support for padding in template partials.\n\n**Fix**: (`mustache`) added support for method names as keys (i.e., `{{user.to_json}}` or `{{#user}}{{to_json}}{{/user}}`). Note: no arguments may be passed (no Ruby code parsing, just testing against method names).\n\n#### Change log v.0.7.12\n\n**Fix**: (`mustache`) fixed multiple issues with `Iodine::Mustache` and added lambda support for mustache templates.\n\n#### Change log v.0.7.11\n\n**Fix**: (`fio`) Deletes Unix sockets once done listening. Fixes an issue where the files would remain intact.\n\n**Optimization**: (`fio`) significant memory allocation optimizations. The facil.io allocator (included with iodine) helps to protect against heap fragmentation and improves speed for concurrent memory allocations when forking / multi-threading.\n\n#### Change log v.0.7.10\n\n**Fix**: (pub/sub) fixed connection lock for pub/sub tasks. Now pub/sub Ruby tasks will lock the connection, protecting the user's code against concurrent access to the connection's data.\n\n**Fix**: (installation) fixed `CFLAGS` compilation value to allow for pre-existing values set by Ruby.\n\n**Fix**: (installation) fixed possible issues than could occur when installing iodine with  `FIO_FORCE_MALLOC`.\n\n**Optimization**: (pub/sub) leverages facil.io broadcasting optimizations, minimizing memory allocations when broadcasting pub/sub messages directly to multiple WebSocket clients.\n\n**Update**: (fio) updated the facil.io code to leverage it's urgent task queue for outbound IO, which minimizes reliance on the IO backup thread.\n\n**Update**: (IO) minor tweaks to the IO backup thread and CLI output format.\n\n#### Change log v.0.7.9\n\n**Fix**: fixed the background IO backup thread initialization and sleep interval. This thread isn't critical. It's only used to (slowly) flush sockets when all the actual threads are blocked by long running Ruby application code.\n\n**Feature**: added the `Iodine.worker?` and `Iodine.master?` methods, for process identification.\n\n**Update**: Updated the automatic ActiveRecord `fork` handling code and added automatic Sequel `fork` handling, to protect against possible database communication errors related to the risk of connection sharing across worker processes.\n\n**Update**: Moved the command line option parsing code, to leverage facil.io's `fio_cli`... It appears more flexible than Ruby's `optparse` (where command line naming is concerned).\n\n**Deprecation**: deprecated the global namespace DSL (`after_fork`, etc'). Use the new `Iodine.on_state(:after_fork)` method instead.\n\n#### Change log v.0.7.8\n\n**Fix**: `unsubscribe` possibly wouldn't unsubscribe from a connection-bound subscription when instructed to do so. This was discovered during a review of a issue #45 submitted by @ojab.\n\n**Fix**: Documentation typo fixed by @ojab in PR#46.\n\n**Fix**: Documentation errors exposed by @ojab regarding the pub/sub specification draft and the WebSocket/SSE specification draft.\n\n#### Change log v.0.7.7\n\n**Fix**: (facil.io) fixed critical issue with cookies, where no more than a single cookie could be set (duplicate headers would be zeroed out before being set). Credit to @ojab for exposing the issue.\n\n#### Change log v.0.7.6\n\n**Fix**: (facil.io edge) timeout review was experiencing some errors that could cause timeouts to be ignored. This was fixed in the facil.io edge branch.\n\n**Fix**: (Ruby 2.2) fixed a possible error with the Mustache parser on Ruby 2.2. I don't run Ruby 2.2, but this came up as a warning during CI tests.\n\n**Fix**: `on_worker_boot` was mistakenly updated to a pre-fork callback (instead of a post fork callback) when attempting to fix the `on_worker_fork` behavior. This timing issue is now fixed and `on_worker_boot` is called **after** forking (both on the master process and the worker).\n\n#### Change log v.0.7.5\n\n**Fix**: fixed issue with direct calls to `publish` in the pre-defined pub/sub engines. These direct calls are used by custom engines when the default engine was replaced and would attempt (erroneously) direct engine access rather than use the `fio_publish` function.\n\n**Fix**: fixed possible Array overflow risk that could result in memory corruption in some cases.\n\n**Fix**: fixed more missing `static` keywords in the code. these should have little or no effect on the namespace (they were using long unique names with the `iodine` prefix).\n\n#### Change log v.0.7.4\n\n**Fix**: fixed a missing `static` keyword in the Ruby<=>C storage bridge which caused performance degradation and introduced namespace conflict risks.\n\n**Fix**: fixed the `on_worker_fork` callback timing, to be performed before forking the process (Puma compatibility).\n\n**Fix**: fixes to minor issues are included in the facil.io edge update.\n\n**Optimize**: minor optimization to memory use, included in facil.io edge updates.\n\n#### Change log v.0.7.3\n\n**Fix**: (facil.io) updating facil.io fixes a channel name memory leak that was fixed in facil.io's edge version.\n\n**Updated**: Improved logging for server data, allowing for total log silencing - this doesn't effect HTTP logging, only iodine's core logging system.\n\n#### Change log v.0.7.2\n\n**Updated**: updated the logging for HTTP services startup, to minimize log clutter.\n\n**Feature**: (mustache) added features to `Iodine::Mustache`, to expose more of the functionality offered by facil.io.\n\n**Fix**: (facil.io) updated from the facil.io edge (master) branch. This should fix some exposed symbols (that should have been private), minimize name-collision risks, and fix an unknown issue with the mime-type registry cleanup and other possible issues.\n\n#### Change log v.0.7.1\n\n**Fix**: Fixed compilation issues with older `gcc` compilers.\n\n#### Change log v.0.7.0\n\nThis version bump is performed because the internal engine changed significantly and might be considered less mature. The public API remains unbroken. \n\n**Fix**: Fixed a documentation error. Credit to @Fonsan (Erik Fonselius) for PR #41.\n\n**Feature**: (mustache) Added a bridge to facil.io's mustache template rendering engine. This isn't really a server concern, but [facil.io's C code](http://facil.io) includes this functionality anyway and it offers increased XSS protection by utilizing aggressive HTML escaping (and it's also faster than the Ruby canonical version).\n\n**Update**: (facil.io) Updated to facil.io version 0.7.0 (edge). This could effect memory consumption behavior but otherwise shouldn't effect iodine all that much.\n\n\n#### Change log v.0.6.5\n\n**Fix**: (facil.io - logging) Fix typo in log output. Credit to @bjeanes (Bo Jeanes) for PR #39.\n\n#### Change log v.0.6.4\n\n**Fix**: (HTTP/WebSockets) fixed an issue where negative status return values (such as ActionCable's `-1` status code) could cause iodine to assume an abnormal error and shut down the connection. Credit to @mdesantis (Maurizio De Santis) for opening issue #38.\n\n#### Change log v.0.6.3\n\n**Fix**: (WebSockets) fixed an issue where WebSocket message events would attempt to create a String object outside the GVL.\n\n**Fix**: (`Iodine::Connection`) minor updated to the documentation and memory validation system.\n\n#### Change log v.0.6.2\n\n**Fix**: (`Iodine::PubSub`) fixed an issue where lazy initialization would cause the shutdown process to crash if no Pub/Sub engines were ever registered (fixes an attempt to seek within an uninitialized data structure). Credit to @sj26 (Samuel Cochran) for reporting the issue.\n\n#### Change log v.0.6.1\n\n**Fix**: (`Iodine::PubSub`) fixed typo, `Iodine::PubSub.detach` is now correctly spelled.\n\n**Fix**: (`Iodine::PubSub`) fix issue #37 where iodine would crash after the server's shutdown process due to Ruby Pub/Sub engines still being attached (or set as default) even after the Ruby interpreter freed all the Ruby objects. Credit to @sj26 (Samuel Cochran) for reporting the issue.\n\n#### Change log v.0.6.0\n\nI apologize to all my amazing early adopters for the rapid changes in the API for connection objects (SSE / WebSockets) and Pub/Sub. This was a result of an attempt to create a de-facto standard with other server authors. Hopefully the API in the 0.6.0 release will see the last of the changes.\n\n**API BREAKING CHANGE**: The API for persistent connections (SSE / WebSockets) was drastically changed in accordance with the Rack specification discussion that required each callback to accept a \"client\" object (replacing the `extend` approach). Please see the documentation.\n\n**API BREAKING CHANGE**: `Iodine.attach` was removed due to instability and issues regarding TLS/SSL and file system IO. I hope to fix these issues in a future release. For now the `Iodine.attach_fd` can be used for clear-text sockets and pipes.\n\n**API BREAKING CHANGE**: Pub/Sub API was changed, replacing the previously suggested pub/sub object with an updated `unsubscribe` method. This means there's no need for the client to map channel names to specific subscriptions (Iodine will perform this housekeeping task for the client).\n\n**Fix**: Iodine should now build correctly on FreeBSD. Credit to @adam12 (Adam Daniels) for detecting the issue.\n\n---\n\n#### Change log v.0.5.2\n\n**Fix**: fixed compilation issues on FreeBSD. Credit to @adam12 (Adam Daniels) for opening issue #35 and offering a patch.\n\n#### Change log v.0.5.1\n\n**Fix**: fixed compilation issues on OS X version < 10.12 and Alpine Linux. Credit to @jdickey (Jeff Dickey) for opening issue #32.\n\n**Fix**: fixed some documentation errors. Credit to @janko-m (Janko Marohni\u0107) for catching typos in the README.\n\n#### Change log v.0.5.0\n\nChanged... everything. At least all the internal bits and some of the API.\n\nIodine 0.5.0 is a stability oriented release. It also supports the updated Rack specification draft for WebSocket and SSE connections (yes, iodine 0.5.0 brings about SSE support).\n\nDeprecated the `each` function family in favor of the more scalable pub/sub approach.\n\nMoved the HTTP network layer outside of the GIL, more robust pub/sub (using Unix Sockets instead of pipes), hot restart (in cluster mode) and more.\n\nLarger header support. The total headers length now defaults to 32Kb, but can be adjusted. A hard coded limit of 8Kb per header line is still enforced (to minimize network buffer).\n\nImproved concurrency and energy consumption (idling CPU cycles reduced).\n\nHigher overall memory consumption might be observed (some security and network features now perform data copying rather than allowing for direct data access).\n\nImproved automatic header completion for missing `Content-Length`, `Date` and `Last-Modified`.\n\nSupport for the Unicorn style `before_fork` and `after_fork` DSL as well as the Puma style `on_worker_boot` DSL.\n\nCredit to Anatoly Nosov (@jomei) for fixing some typos in the documentation.\n\n---\n\n#### Change log v.0.4.19\n\n**Feature**: (`iodine`) added requested feature in issue #27, `Iodine.running?` will return Iodine's state.\n\n#### Change log v.0.4.18\n\n**Fix**: (`iodine pub/bus`) fixed issue #27 (?) where the `block` used for subscriptions would be recycled by the GC and the memory address (retained by `iodine`) would point at invalid Ruby objects (at worst) or become invalid (at best). Credit to Dmitry Davydov (@haukot) for exposing this issue.\n\n**Fix**: (`facil pub/bus`) fixed issue #27 (?) where the `memcpy` was used instead of `memmove`, resulting in possibly corrupt data in cluster messaging system. Credit to Dmitry Davydov (@haukot) for exposing this issue.\n\n#### Change log v.0.4.17\n\n**Fix**: (`iodine RubyCaller`) fixed issue #26 that exposed an issue in the exception handling logic. This fix enforces exception handling whenever entering the Ruby GVL (GIL), allowing C functions to safely enter the user's Ruby code (where before C functions were assumed to be safe and user code would be executed unprotected when routed through certain functions). Credit to Dmitry Davydov (@haukot) for exposing this issue (issue #26).\n\n#### Change log v.0.4.16\n\n**Fix**: (`websocket_parser`) The websocket parser had a memory offset and alignment handling issue in it's unmasking (XOR) logic and the new memory alignment protection code. The issue would impact the parser in rare occasions when multiple messages where pipelined in the internal buffer and their length produced an odd alignment (the issue would occur with very fast clients, or a very stressed server).\n\n#### Change log v.0.4.15\n\n**Update**: (`facil.io`) updating the facil.io library version to use the 0.5.8 released version.\n\nThis includes the following changes (as well as other minor changes), as detailed in facil.io's CHANGELOG:\n\n**Compatibility**: (`websocket_parser`) removed unaligned memory access from the XOR logic in the parser, making it more compatible with older CPU systems that don't support unaligned memory access or 64 bit word lengths.\n\n**Optimization**: (`defer`) rewrote the data structure to use a hybrid cyclic buffer and linked list for the task queue (instead of a simple linked list), optimizing locality and minimizing memory allocations.\n\n**Compatibility**: (`gcc-6`) Fix some compatibility concerns with `gcc` version 6, as well as some warnings that were exposed when testing with `gcc`.\n\n---\n\n#### Change log v.0.4.14\n\n**Fix**: (`facil.io`) fixes an issue where timer monitoring would report failure when the timer exists and is being monitored.\n\n---\n\n#### Change log v.0.4.12\n\n**Fix**: (`facil.io`) fixes some lingering issues with the new Websocket parser, namely an issue where certain network packet lengths would cause the parser to fail. Credit to Tom Lahti (@uidzip) for exposing the issue.\n\n---\n\n#### Change log v.0.4.11\n\n**Fix**: (`iodine`) use Ruby `fork` instead of system `fork`, allowing Ruby hooks to run before and after forking. This also fixes an issue where the Ruby timer thread isn't (re)initialized.\n\n---\n\n#### Change log v.0.4.10\n\n**Portability**: (`mac OS High Sierra`) iodine will load the Objective C library on macOS machines before starting up the server - this will prevent `fork` from crashing the server on macOS High Sierra, see [discussion here](https://github.com/puma/puma/issues/1421).\n\n**Fix**: (`facil.io`) fixes an error with the new Websocket parser (introduced in v. 0.4.9) that caused medium sized messages (127 Bytes - 64Kib) to be parsed incorrectly. Apologies. The test program I used seems to have validated messages using length comparison (instead of data comparison). Credit to Tom Lahti (@uidzip) for exposing the issue.\n\n---\n\n#### Change log v.0.4.9\n\n**Change**: (`facil.io`) the internal Websocket parser was replaced with something easier to read, for maintainability reasons. Performance seems to be mostly unaffected (sometimes it's faster and sometimes it's slower, common case is slightly optimized).\n\n**Change**: (`facil.io`) iodine will compile facil.io with the `NO_CHILD_REAPER` flag, in order to workaround the Rails ExecJS gem that [assumes no child reaping is performed](https://github.com/rails/execjs/issues/68). This workaround is, hopefully, temporary. Credit to @jerryshen for exposing the issue.\n\n**Fix**: (`Iodine`) test for timer creation error in `run_after` and `run_every`.\n\n**Fix**: (`facil.io`) timer creation now correctly detects if the reactor was stopped, allowing the creation of new timers before the reactor's reactivation.\n\n**Fix**: (`facil.io`) timer timeout review is now correctly ignored, preventing the timer from being shut down prematurely.\n\n---\n\n#### Change log v.0.4.8\n\n**Change**: (`facil.io`) the internal HTTP parser was replaced with something easier to read, for maintainability reasons. Performance seems to be unaffected.\n\n**Fix**: HTTP request logging included an extra info line which was a debug/testing message inherited from `facil.io` v.0.5.3-pre-release. This is now removed.\n\n**Performance**: The `now` HTTP Date string is now cached for up to 2 seconds, improving performance for `Date`, `Last-Modified` and Iodine logging messages that relate to the current time. However, it's likely that Rack will write it's own date string, masking this feature.\n\n---\n\n#### Change log v.0.4.7\n\n**Update**: Now using `facil.io` edge (stripped down v.0.5.3).\n\n**Fix**: (`websocket`) fix #21, where a client's first message could have been lost due to long `on_open` processing times. This was fixed by fragmenting the `upgrade` event into two events, adding the `facil_attach_locked` feature and attaching the new protocol before sending the response. Credit to @madsheep and @nilclass for exposing the issue and tracking it down to the `on_open` callbacks.\n\n**Fix**: (`sock`) sockets created using the TCP/IP `sock` library now use `TCP_NODELAY` as the new default. This shouldn't be considered a breaking change as much as it should be considered a fix.\n\n**Fix**: (`http1`) HTTP/1.x now correctly initializes the `udata` pointer to NULL fore each new request.\n\n**Fix**: (`defer`) a shutdown issue in `defer_perform_in_fork` was detected by @cdkrot and his fix was implemented.\n\n---\n\n#### Change log v.0.4.6\n\n**Update**: Now using `facil.io` v.0.5.2.\n\n**Fix**: (from `facil.io`) fix `SIGTERM` handling, make sure sibling processes exit when a sibling dies.\n\n---\n\n#### Change log v.0.4.5\n\n**Fix**: fix static file service for `X-Sendfile` as well as static error file fallback pages (404.html etc').\n\n---\n\n#### Change log v.0.4.4\n\n**Fix**: fixed an issue related to Ruby 2.3 optimizations of String management (an issue that didn't seem to effect Ruby 2.4). This fix disables the recyclable buffer implemented for the `on_message` Websocket callback. The callback will now receive a copy of the buffer (not the buffer itself), so there is no risk of collisions between the network buffer (managed in C) and the `on_message(data)` String (managed by Ruby).\n\n---\n\n#### Change log v.0.4.3\n\n**Fix**: fixed a possible issue in fragmented pipelined Websocket messages.\n\n---\n\n#### Change log v.0.4.2\n\n**Fix**: fixed an issue where Websocket `ping` timeouts were being ignored for the default `Iodine::Rack` server, causing the default (40 seconds) to persist over specified valued.\n\n**Fix**: fixed a possible issue with high-jacking which might cause the server to hang.\n\n---\n\n#### Change log v.0.4.1\n\n**Fix**: postpone warmup in fear of abuse and collisions when using `fork`. i.e., during warmup, an application might perform actions that conflict with `fork` and worker initialization, such as creating a database connection pool during warmup, or maybe spawning a thread. Now `warmup` is postponed until *after* worker processes are up and running, resulting in a per-process warmup rather than a per-cluster warmup.\n\n**Fix** move the `rake-compiler` dependency to \"development\" instead of \"runtime\". Credit to Luis Lavena (@luislavena) for exposing the issue (#19).\n\n---\n\n#### Change log v.0.4.0\n\n**Braking change**: Some of the API was changed / updated, hopefully simplified.\n\n**DEPRECTAION / Braking change**: The `websocket#write_each` function is gone. Future (planned) support for a Pub/Sub API would have caused confusion and since it's barely used (probably only there as a benchmarking proof of concept) it was removed.\n\n**Update**: Now using `facil.io` v.0.5.0 The extended features include the following listed features.\n\n**Fixes**: This was such a big rewrite, I suspect half the fixes I want to list are things I broke during the rewrite... but there were plenty of fixes.\n\n**Feature**: Iodine now support native Websocket Pub/Sub, with [an example in the `examples` folder](./examples/redis.ru). i.e.:\n\n```ruby\n# Within a Websocket connection:\nsubscribe \"chat\"\npublish \"chat\", \"Iodine is here!\"\n```\n\n**Feature**: Iodine's Pub/Sub API supports both direct client messages and server filtered messages. i.e.\n\n```ruby\n# Within a Websocket connection:\nsubscribe(\"chat-server\") {|msg| write \"Notice: #{msg}\" }\n# v.s\nsubscribe(\"chat-client\")\n\npublish \"chat-server\", \"Iodine is here!\"\n```\n\n**Feature**: Iodine's Pub/Sub API includes support for home made Pub/Sub Engines connecting Iodine to your Pub/Sub service of choice.\n\n**Feature**: Iodine's Pub/Sub support includes a Process Cluster engine (pub/sub to all Websockets sharing the process cluster) as well as a Single Process engine (pub/sub to all websockets supporting a single process).\n\n**Feature**: Iodine's Pub/Sub support includes a native Redis Pub/Sub engine. The parser is written from the ground up in C to keep the Iodine licensing as MIT. It's young, so keep your eyes pealed and submit any issues you encounter.\n\n**Feature + Breaking Change**: Iodine now support multiple HTTP servers at once. i.e.:\n\n```ruby\n# `Iodine::HTTP.listen` initializes an HTTP service in the C and system levels, so it can't be changed once initialized.\nIodine::HTTP.listen port: 3000, app: my_app1\nIodine::HTTP.listen port: 3000, app: my_app2, public: \"./www\"\nIodine.start\n```\n\n---\n\n#### Change log v.0.3.6\n\n**Update**: Now using `facil.io` v.0.4.3. This fixes some delays in websocket packet flushing (latency), as well as other internal polishes. It also promises some possible future feature extensions that could add a major performance boost.\n\n---\n\n#### Change log v.0.3.5\n\n**Fix**: (`sock`) Fixed an issue with the `sendfile` implementation on macOS and BSD, where medium to large files wouldn't be sent correctly.\n\n**Minor changes**: This release incorporates some more minor changes from the [`facil.io` 0.4.2 update](https://github.com/boazsegev/facil.io/releases/tag/v.0.4.2).\n\n---\n\n#### Change log v.0.3.4\n\n**Fix**: (`sock`, `facil`, bscrypt) Add missing `static` keywords to prevent state collisions with other libraries.\n\n---\n\n#### Change log v.0.3.3\n\n**Update**: Now using `facil.io` v.0.4.1\n\n**Fix**: (from `facil.io`) fixed the default response `Date` (should have been \"now\", but wasn't initialized).\n\n**Compatibility**: (from `facil.io`) Now checks for HTTP/1.0 clients to determine connection persistence.\n\n**Compatibility**: (from `facil.io`) Added spaces after header names (`:` => `: `), since some parsers don't seem to read the RFC.\n\n---\n\n#### Change log v.0.3.2\n\n**Fix**: (from `facil.io`) fixed thread throttling for better energy conservation.\n\n**Fix**: (from `facil.io`) fixed stream response logging.\n\n---\n\n#### Change log v.0.3.1\n\n**Update**: Follow `facil.io`'s update for healthier thread throttling and energy consumption.\n---\n\n#### Change log v.0.3.1\n\n**Fix**: Fixed a minor issue with the logging of responses where the size of the response is unknown (streamed).\n\n**Gem Specification update**: We updated the gem specification to allow for Rack 1.x users and to update the gem description.\n\n---\n\n#### Change log v.0.3.0\n\n**`facil.io` C Core Update**: The C library core that drives Iodine [`facil.io`](http://facil.io) was updated to version 0.4.0 and Iodine follows closely on the heels of this update. The transition was easy enough and the API remains unchanged... but because the performance gain was so big and because it's a new code base, we opted to bump the minor release version.\n\n---\n\n#### Change log v.0.2.17\n\n**Performance**: Enhanced Performance for single threaded / blocking applications by adding a dedicated IO thread. This is related to issue #14.\n\n---\n\n#### Change log v.0.2.16\n\n**Update**: iodine can now run as a basic HTTP static file server without a Ruby application (no `config.ru`) when the `-www` option is used from the command line.\n\n---\n\n#### Change log v.0.2.15\n\n**Fix**: Fixed typo in logging and code comments, credit to @jmoriau in PR #13.\n\n---\n\n#### Change log v.0.2.14\n\n**Fix**: fixed the experimental `each_write`. An issue was found where passing a block might crash Iodine, since the block will be freed by the GC before Iodine was done with it. Now the block is correctly added to the object Registry, preventing premature memory deallocation.\n\n**Fix**: fixed another issue with `each_write` where a race condition review was performed outside the protected critical section, in some cases this would caused memory to be freed twice and crash the server. This issue is now resolved.\n\n**Deprecation**: In version 0.2.1 we have notified that the the Websocket method `uuid` was deprecated in favor of `conn_id`, as suggested by the [Rack Websocket Draft](https://github.com/rack/rack/pull/1107). This deprecation is now enforced.\n\n---\n\n#### Change log v.0.2.13\n\n**Fix**: Fixed an issue presented in the C layer, where big fragmented Websocket messages sent by the client could cause parsing errors and potentially, in some cases, cause a server thread to spin in a loop (DoS). Credit to @Filly for exposing the issue in the [`facil.io`](https://github.com/boazsegev/facil.io) layer. It should be noted that Chrome is the only browser where this issue could be invoked for testing.\n\n**Credit**: credit to Elia Schito (@elia) and Augusts Bautra (@Epigene) for fixing parts of the documentation (PR #11 , #12).\n\n---\n\n#### Change log v.0.2.12\n\n**Fix**: removed `mempool` after it failed some stress and concurrency tests.\n\n---\n\n#### Change log v.0.2.11\n\n**Fix**: C layer memory pool had a race-condition that could have caused, in some unlikely events, memory allocation failure for Websocket protocol handlers. This had now been addressed and fixed.\n\n**Experimental feature**: added an `each_write` feature to allow direct `write` operations that write data to all open Websocket connections sharing the same process (worker). When this method is called without the optional block, the data will be sent without the need to acquire the Ruby GIL.\n\n**Update**: lessons learned from `facil.io` have been implemented for better compatibility of Iodine's core C layer.\n\n---\n\n#### Change log v.0.2.10\n\n**Update**: added documentation and an extra helper method to set a connection's timeout when using custom protocols (Iodine as an EventMachine alternative).\n\n**C Layer Update** updated the [`facil.io`](http://facil.io) library used, to incorporate the following fixes / update:\n\n* Better cross platform compilation by avoiding some name-space clashes. i.e, fixes a name clash with the `__used` directive / macro, where some OSs (i.e. CentOS) used a similar directive with different semantics.\n\n* Reviewed and fixed some signed vs. unsigned integer comparisons.\n\n* Smoother event scheduling by increasing the event-node's pool size.\n\n* Smoother thread concurrency growth by managing thread `nanosleep` times as thread count dependent.\n\n* Cleared out \"unused variable\" warnings.\n\n* Streamlined the `accept` process to remove a double socket's data clean-up.\n\n* `SERVER_DELAY_IO` is now implemented as an event instead of a stack frame.\n\n* Fixed a possible Linux `sendfile` implementation issue where sometimes errors wouldn't be caught or `sendfile` would be called past a file's limit (edge case handling).\n\n* `bscrypt` random generator (where `dev/random` is unavailable) should now provide more entropy.\n\n\n---\n\n#### Change log v.0.2.9\n\n**Fix**: fixed a gcc-4.8 compatibility issue that prevented iodine 0.2.8 from compiling on Heroku's cedar-14 stack. This was related to missing system include files in gcc-4.8. It should be noted that Heroku's stack and compiler (which utilizes Ubuntu 14) has known issues and / or limited support for some of it's published features... but I should have remembered that before releasing version 0.2.8... sorry about that.\n\n---\n\n#### Change log v.0.2.8\n\n**Memory Performance**: The Websocket connection Protocol now utilizes both a C level memory pool and a local thread storage for temporary data. This helps mitigate possible memory fragmentation issues related to long running processes and long-lived objects. In addition, the socket `read` buffer was moved from the protocol object to a local thread storage (assumes pthreads and not green threads). This minimizes the memory footprint for each connection (at the expense of memory locality) and should allow Iodine to support more concurrent connections using less system resources. Last, but not least, the default message buffer per connection starts at 4Kb instead of 16Kb (grows as needed, up to `Iodine::Rack.max_msg_size`), assuming smaller messages are the norm.\n\n**Housekeeping**: Cleaned up some code, removed old files, copied over the latest [`facil.io`](http://facil.io) library. There's probably some more housekeeping left to perform, especially anywhere where documentation is concerned. I welcome help with documentation.\n\n---\n\n#### Change log v.0.2.7\n\n**Minor Fix**: fixed an issue where a negative number of processes or threads would initiate a very large number of forks, promoting a system resource choke. Limited the number of threads (1023) and processes (127).\n\n**Update**: Automated the number of processes (forks) and threads used when these are not explicitly specified. These follow the number of cores / 2.\n\n---\n\n#### Change log v.0.2.6\n\n**Update**: The IO reactor review will now be delayed until all events scheduled are done. This means that is events schedule future events, no IO data will be reviewed until all scheduled data is done. Foolish use might cause infinite loops that skip the IO reactor, but otherwise performance is improved (since the IO reactor might cause a thread to \"sleep\", delaying event execution).\n\n---\n\n#### Change log v.0.2.5\n\n**Fix:**: fix for issue #9 (credit to Jack Christensen for exposing the issue) caused by an unlocked critical section's \"window of opportunity\" that allowed asynchronous Websocket `each` blocks to run during the tail of the Websocket handshake (while the `on_open` callback was running in parallel).\n\n**Minor Fix**: Fix Iodine::Rack's startup message's `fprintf` call to fit correct argument sizes (Linux warnings).\n\n---\n\n#### Change log v.0.2.4\n\n**Minor Fix**: Patched Iodine against Apple's broken `getrlimit` on macOS. This allows correct auto-setting of open file limits for the socket layer.\n\n**Minor Fix**: Fixed the processor under-utilization warning, where \"0\" might be shown for the number processes instead of \"1\".\n\n**Update**: Added support for the `env` keys `HTTP_VERSION` and `SERVER_PROTOCOL` to indicate the HTTP protocol version. Iodine implements an HTTP/1.1 server, so versions aren't expected to be higher than 1.x.\n\n**Update**: Iodine::Rack startup messages now include details regarding open file limits imposed by the OS (open file limits control the maximum allowed concurrent connections and other resource limits).\n\n---\n\n#### Change log v.0.2.3\n\n**Update**: The `write` system call is now deferred when resources allow, meaning that (as long as the `write` buffer isn't full) `write` is not only non-blocking, but it's performed as a separate event, outside of the Ruby GIL.\n\n**Update**: The global socket `write` buffer was increased to ~16Mb (from ~4Mb), allowing for more concurrent `write` operations. However, the `write` buffer is still limited and `write` might block while the buffer is full. Blocking and \"hanging\" the server until there's enough room in the buffer for the requested `write` will slow the server down while keeping it healthy and more secure. IMHO, it is the lesser of two evils.\n\n---\n\n#### Change log v.0.2.2\n\n**Update** The static file service now supports `ETag` caching, sending a 304 (not changed) response for valid ETags.\n\n**Update**: A performance warning now shows if the CPUs are significantly under-utilized (less than half are used) of if too many are utilized (more than double the amount of CPUs), warning against under-utilization or excessive context switching (respectively).\n\n---\n\n#### Change log v.0.2.1\n\n**Notice**: The [Rack Websocket Draft](https://github.com/rack/rack/pull/1107) does not support the `each` and `defer` methods. Although I tried to maintain these as part of the draft, the community preferred to leave the implementation of these to the client (rather then the server). If collisions occur, these methods might be removed in the future.\n\n**Update**: Websockets now support the `has_pending?` method and `on_ready` callback, as suggested by the [Rack Websocket Draft](https://github.com/rack/rack/pull/1107).\n\n**Update**: deprecated the Websocket method `uuid` in favor of `conn_id`, as suggested by the [Rack Websocket Draft](https://github.com/rack/rack/pull/1107).\n\n**Fix**: fixed an issue were the server would crash when attempting to send a long enough websocket message.\n\n---\n\n#### Change log v.0.2.0\n\nThis version is a total rewrite. The API is totally changed, nothing stayed.\n\nIodine is now written in C, as a C extension for Ruby. The little, if any, ruby code written is just the fluff and feathers.\n\n---\n\n### deprecation of the 0.1.x version line\n\n#### Change log v.0.1.21\n\n**Optimization**: Minor optimizations. i.e. - creates 1 less Time object per request (The logging still creates a Time object unless disabled using `Iodine.logger = nil`).\n\n**Security**: HTTP/1 now reviews the Body's size as it grows (similar to HTTP/2), mitigating any potential attacks related to the size of the data sent.\n\n**Logs**: Log the number of threads utilized when starting up the server.\n\n---\n\n#### Change log v.0.1.20\n\n**Update/Fix**: Updated the `x-forwarded-for` header recognition, to accommodate an Array formatting sometimes used (`[\"ip1\", \"ip2\", ...]`).\n\n**Update**: native support for the `Forwarded` header HTTP.\n\n**API Changes**: `Iodine::HTTP.max_http_buffer` was replaced with `Iodine::HTTP.max_body_size`, for a better understanding of the method's result.\n\n---\n\n#### Change log v.0.1.19\n\n**Update**: added the `go_away` method to the HTTP/1 protocol, for seamless connection closeing across HTTP/2, HTTP/1 and Websockets.\n\n---\n\n#### Change log v.0.1.18\n\n**Update**: The request now has the shortcut method `Request#host_name` for accessing the host's name (without the port part of the string).\n\n---\n\n#### Change log v.0.1.17\n\n**Credit**: thanks you @frozenfoxx for going through the readme and fixing my broken grammar.\n\n**Fix**: fixed an issue where multiple Pings might get sent when pinging takes time. Now pings are exclusive (run within their own Mutex).\n\n**Fix**: HTTP/2 is back... sorry about breaking it in the 0.1.16 version. When I updated the write buffer I forgot to write the status of the response, causing a protocol error related with the headers. It's now working again.\n\n**Update**: by default and for security reasons, session id's created through a secure connection (SSL) will NOT be available on a non secure connection (SSL/TLS). However, while upgrading to the encrypted connection, the non_encrypted session storage is now available for review using the `Response#session_old` method.\n\n* Remember that sessions are never really safe, no matter how much we guard them. Session hijacking is far too easy. This is why Iodine stores the session data locally and not within the session cookie. This is also why you should review any authentication before performing sensitive tasks based on session stored authentication data.\n\n---\n\n#### Change log v.0.1.16\n\n**Performance**: HTTP/1 and HTTP/2 connections now share and recycle their write buffer when while reading the response body and writing it to the IO. This (hopefully) prevents excess `malloc` calls by the interpreter.\n\n---\n\n#### Change log v.0.1.15\n\n**Update**: IO reactor will now update IO status even when tasks are pending. IO will still be read only when there are no more tasks to handle, but this allows chained tasks to relate to the updated IO status. i.e. this should improve Websocket availability for broadcasting (delay from connection to availability might occur until IO is registered).\n\n**Update**: Websockets now support the `on_ping` callback, which will be called whenever a ping was sent without error.\n\n---\n\n#### Change log v.0.1.14\n\n**Update**: the Response now supports `redirect_to` for both permanent and temporary redirection, with an optional `flash` cookie setup.\n\n**Performance**: the Protocol class now recycles the data string as a thread global socket buffer (different threads have different buffer strings), preventing excessive `malloc` calls by the Ruby interpreter. To keep the `data` (in `on_message(data)`) past the `on_message` method's scope, be sure to duplicate it using `data.dup`, or the string's buffer will be recycled.\n\n---\n\n#### Change log v.0.1.13\n\n**Change**: Session cookie lifetime is now limited to the browser's session. The local data will still persist until the tmp-folder is cleared (when using session file storage).\n\n**Fix**: renamed the SSL session token so that the SSL session id isn't lost when a non-secure session is used.\n\n**Fix**: The `flash` cookie-jar will now actively prevent Symbol and String keys from overlapping.\n\n**Compatibility**: minor fixes and changes in preparation for Ruby 2.3.0. These may affect performance due to slower String initialization times.\n\n---\n\n#### Change log v.0.1.12\n\n**Update**: Passing a hash as the cookie value will allow to set cookie parameters using the {Response#set_cookie} options. i.e.: `cookies['key']= {value: \"lock\", max_age: 20}`.\n\n**Security**: set the HTTPOnly flag for session id cookies.\n\n---\n\n#### Change log v.0.1.11\n\n**Fix**: fixed the Rack server Handler, which was broken in version 0.1.10.\n\n---\n\n#### Change log v.0.1.10\n\n**Fix**: make sure the WebsocketClient doesn't automatically renew the connection when the connection was manually closed by the client.\n\n**Performance**: faster TimedEvent clearing when manually stopped. Minor improvements to direct big-file sending (recycle buffer to avoid `malloc`).\n\n---\n\n#### Change log v.0.1.9\n\n**Fix**: WebsocketClient connection renewal will now keep the same WebsocketClient instance object.\n\n**Update** Creating a TimedEvent before Iodine starts running will automatically 'nudge' Iodine into \"Task polling\" mode, cycling until the user signals a stop.\n\n**Update**: repeatedly calling `Iodine.force_start!` will now be ignored, as might have been expected. Once Iodine had started, `force_start!` cannot be called until Iodine had finished (and even than, Iodine might never be as fresh nor as young as it was).\n\n---\n\n#### Change log v.0.1.8\n\n**Fix**: Websocket broadcasts are now correctly executed within the IO's mutex locker. This maintains the idea that only one thread at a time should be executing code on behalf of any given Protocol object (\"yes\" to concurrency between objects but \"no\" to concurrency within objects).\n\n**Fix** fixed an issue where manually setting the number of threads for Rack applications (when using Iodine as a Rack server), the setting was mistakenly ignored.\n\n**Fix** fixed an issue where sometimes extracting the HTTP response's body would fail (if body is `nil`).\n\n**Feature**: session objects are now aware of the session id. The session id is available by calling `response.session.id`\n\n**Fix** fixed an issue where HTTP streaming wasn't chunk encoding after connection error handling update.\n\n**Fix** fixed an issue where HTTP streaming would disconnect while still processing. Streaming timeout now extended to 15 seconds between response writes.\n\n---\n\n#### Change log v.0.1.7\n\nRemoved a deprecation notice for blocking API. Client API will remain blocking due to use-case requirements.\n\n---\n\n#### Change log v.0.1.6\n\n**Fix**: fixed an issue where a session key-value pair might not get deleted when using `session.delete key` and the `key` is not a String object. Also, now setting a key's value to `nil` should delete the key-value pair.\n\n**Fix**: fixed an issue where WebsocketClient wouldn't mask outgoing data, causing some servers to respond badly.\n\n**Performance**: minor performance improvements to the Websocket parser, for unmasking messages.\n\n**Deprecation notice**:\n\n(removed after reviewing use-cases).\n\n---\n\n#### Change log v.0.1.5\n\n**Feature**: The Response#body can now be set to a File object, allowing Iodine to preserve memory when serving large static files from disc. Limited Range requests are also supported - together, these changes allow Iodine to serve media files (such as movies) while suffering a smaller memory penalty and supporting a wider variety of players (Safari requires Range request support for it's media player).\n\n**Fix**: Fixed an issue where Iodine might take a long time to shut down after a Fatal Error during the server initialization.\n\n---\n\n#### Change log v.0.1.4\n\n**Fix**: fixed an issue with where the WebsocketClient#on_close wouldn't be called for a renewable Websocket connection during shutdown.\n\n**Fix**: fixed an issue where a protocol's #on_close callback wouldn't be called if the Iodine server receives a shutdown signal.\n\n**Fix**: fixed an issue where HTTP2 header size limit condition was not recognized by the Ruby parser (a double space issue, might be an issue with the 2.2.3 Ruby parser).\n\n---\n\n#### Change log v.0.1.3\n\n**Fix**: fixed an issue with the new form/multipart parser, where the '+' sign would be converted to spaces on form fields (not uploaded files), causing in-advert potential change to the original POSTed data.\n\n---\n\n#### Change log v.0.1.2\n\n**Fix**: fixed an issue where the default implementation of `ping` did not reset the timeout if the connection wasn't being closed (the default implementation checks if the Protocol is working on existing data and either resets the timer allowing the work to complete or closes the connection if no work is being done).\n\n---\n\n#### Change log v.0.1.1\n\n**Fix**: Fixed an issue where slow processing of HTTP/1 requests could cause timeout disconnections to occur while the request is being processed.\n\n**Change/Security**: Uploads now use temporary files. Aceessing the data for file uploads should be done throught the `:file` property of the params hash (i.e. `params[:upload_field_name][:file]`). Using the `:data` property (old API) would cause the whole file to be dumped to the memory and the file's content will be returned as a String.\n\n**Change/Security**: HTTP upload limits are now enforced. The current default limit is about ~0.5GB.\n\n**Feature**: WebsocketClient now supports both an auto-connection-renewal and a polling machanism built in to the `WebsocketClient.connect` API. The polling feature is mostly a handy helper for testing, as it is assumed that connection renewal and pub/sub offer a better design than polling.\n\n**Logging**: Better HTTP error logging and recognition.\n\n---\n\n#### Change log v.0.1.0\n\n**First actual release**:\n\nWe learn, we evolve, we change... but we remember our past and do our best to help with the transition and make it worth the toll it takes on our resources.\n\nI took much of the code used for GRHTTP and GReactor, changed it, morphed it and united it into the singular Iodine gem. This includes Major API changes, refactoring of code, bug fixes and changes to the core approach of how a task/io based application should behave or be constructed.\n\nFor example, Iodine kicks in automatically when the setup script is done, so that all code is run from within tasks and IO connections and no code is run in parallel to the Iodine engine.\n\nAnother example, Iodine now favors Object Oriented code, so that some actions - such as writing a network service - require classes of objects to be declared or inherited (i.e. the Protocol class).\n\nThis allows objects to manage their data as if they were in a single thread environment, unless the objects themselves are calling asynchronous code. For example, the Protocol class makes sure that the `on_open` and `on_message(data)` callbacks are executed within a Mutex (`on_close` is an exception to the rule since it is assumed that objects should be prepared to loose network connection at any moment).\n\nAnother example is that real-life deployment preferences were favored over adjustability or features. This means that some command-line arguments are automatically recognized (such as the `-p <port>` argument) and that Iodine assumes a single web service per script/process (whereas GReactor and GRHTTP allowed multiple listening sockets).\n\nI tested this new gem during the 0.0.x version releases, and I feel that version 0.1.0 is stable enough to work with. For instance, I left the Iodine server running all night under stress (repeatedly benchmarking it)... millions of requests later, under heavy load, a restart wasn't required and memory consumption didn't show any increase after the warmup period.\n\n\n\n## License\n\nThe gem is available as open source under the terms of the [MIT License](http://opensource.org/licenses/MIT).\n", "/* *****************************************************************************\nCopyright: Boaz Segev, 2018-2019\nLicense: MIT\n\nFeel free to copy, use and enjoy according to the license provided.\n***************************************************************************** */\n\n#include <fio.h>\n\n#define FIO_INCLUDE_STR\n#include <fio.h>\n\n#define FIO_FORCE_MALLOC_TMP 1\n#define FIO_INCLUDE_LINKED_LIST\n#include <fio.h>\n\n#include <ctype.h>\n#include <errno.h>\n#include <limits.h>\n#include <pthread.h>\n#include <sys/mman.h>\n#include <unistd.h>\n\n#include <netdb.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n\n#include <arpa/inet.h>\n\n/* force poll for testing? */\n#ifndef FIO_ENGINE_POLL\n#define FIO_ENGINE_POLL 0\n#endif\n\n#if !FIO_ENGINE_POLL && !FIO_ENGINE_EPOLL && !FIO_ENGINE_KQUEUE\n#if defined(__linux__)\n#define FIO_ENGINE_EPOLL 1\n#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__NetBSD__) ||     \\\n    defined(__OpenBSD__) || defined(__bsdi__) || defined(__DragonFly__)\n#define FIO_ENGINE_KQUEUE 1\n#else\n#define FIO_ENGINE_POLL 1\n#endif\n#endif\n\n/* for kqueue and epoll only */\n#ifndef FIO_POLL_MAX_EVENTS\n#define FIO_POLL_MAX_EVENTS 64\n#endif\n\n#ifndef FIO_POLL_TICK\n#define FIO_POLL_TICK 1000\n#endif\n\n#ifndef FIO_USE_URGENT_QUEUE\n#define FIO_USE_URGENT_QUEUE 1\n#endif\n\n#ifndef DEBUG_SPINLOCK\n#define DEBUG_SPINLOCK 0\n#endif\n\n/* Slowloris mitigation  (must be less than 1<<16) */\n#ifndef FIO_SLOWLORIS_LIMIT\n#define FIO_SLOWLORIS_LIMIT (1 << 10)\n#endif\n\n#if !defined(__clang__) && !defined(__GNUC__)\n#define __thread _Thread_value\n#endif\n\n#ifndef FIO_TLS_WEAK\n#define FIO_TLS_WEAK __attribute__((weak))\n#endif\n\n/* Mitigates MAP_ANONYMOUS not being defined on older versions of MacOS */\n#if !defined(MAP_ANONYMOUS)\n#if defined(MAP_ANON)\n#define MAP_ANONYMOUS MAP_ANON\n#else\n#define MAP_ANONYMOUS 0\n#endif\n#endif\n\n/* *****************************************************************************\nEvent deferring (declarations)\n***************************************************************************** */\n\nstatic void deferred_on_close(void *uuid_, void *pr_);\nstatic void deferred_on_shutdown(void *arg, void *arg2);\nstatic void deferred_on_ready(void *arg, void *arg2);\nstatic void deferred_on_data(void *uuid, void *arg2);\nstatic void deferred_ping(void *arg, void *arg2);\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n                       Main State Machine Data Structures\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\ntypedef void (*fio_uuid_link_fn)(void *);\n#define FIO_SET_NAME fio_uuid_links\n#define FIO_SET_OBJ_TYPE fio_uuid_link_fn\n#define FIO_SET_OBJ_COMPARE(o1, o2) 1\n#include <fio.h>\n\n/** User-space socket buffer data */\ntypedef struct fio_packet_s fio_packet_s;\nstruct fio_packet_s {\n  fio_packet_s *next;\n  int (*write_func)(int fd, struct fio_packet_s *packet);\n  void (*dealloc)(void *buffer);\n  union {\n    void *buffer;\n    intptr_t fd;\n  } data;\n  uintptr_t offset;\n  uintptr_t length;\n};\n\n/** Connection data (fd_data) */\ntypedef struct {\n  /* current data to be send */\n  fio_packet_s *packet;\n  /** the last packet in the queue. */\n  fio_packet_s **packet_last;\n  /* Data sent so far */\n  size_t sent;\n  /* fd protocol */\n  fio_protocol_s *protocol;\n  /* timer handler */\n  time_t active;\n  /** The number of pending packets that are in the queue. */\n  uint16_t packet_count;\n  /* timeout settings */\n  uint8_t timeout;\n  /* indicates that the fd should be considered scheduled (added to poll) */\n  fio_lock_i scheduled;\n  /* protocol lock */\n  fio_lock_i protocol_lock;\n  /* used to convert `fd` to `uuid` and validate connections */\n  uint8_t counter;\n  /* socket lock */\n  fio_lock_i sock_lock;\n  /** Connection is open */\n  uint8_t open;\n  /** indicated that the connection should be closed. */\n  uint8_t close;\n  /** peer address length */\n  uint8_t addr_len;\n  /** peer address length */\n  uint8_t addr[48];\n  /** RW hooks. */\n  fio_rw_hook_s *rw_hooks;\n  /** RW udata. */\n  void *rw_udata;\n  /* Objects linked to the UUID */\n  fio_uuid_links_s links;\n} fio_fd_data_s;\n\ntypedef struct {\n  struct timespec last_cycle;\n  /* connection capacity */\n  uint32_t capa;\n  /* connections counted towards shutdown (NOT while running) */\n  uint32_t connection_count;\n  /* thread list */\n  fio_ls_s thread_ids;\n  /* active workers */\n  uint16_t workers;\n  /* timer handler */\n  uint16_t threads;\n  /* timeout review loop flag */\n  uint8_t need_review;\n  /* spinning down process */\n  uint8_t volatile active;\n  /* worker process flag - true also for single process */\n  uint8_t is_worker;\n  /* polling and global lock */\n  fio_lock_i lock;\n  /* The highest active fd with a protocol object */\n  uint32_t max_protocol_fd;\n  /* timer handler */\n  pid_t parent;\n#if FIO_ENGINE_POLL\n  struct pollfd *poll;\n#endif\n  fio_fd_data_s info[];\n} fio_data_s;\n\n/** The logging level */\n#if DEBUG\nint FIO_LOG_LEVEL = FIO_LOG_LEVEL_DEBUG;\n#else\nint FIO_LOG_LEVEL = FIO_LOG_LEVEL_INFO;\n#endif\nstatic fio_data_s *fio_data = NULL;\n\n/* used for protocol locking by task type. */\ntypedef struct {\n  fio_lock_i locks[3];\n  unsigned rsv : 8;\n} protocol_metadata_s;\n\n/* used for accessing the protocol locking in a safe byte aligned way. */\nunion protocol_metadata_union_u {\n  size_t opaque;\n  protocol_metadata_s meta;\n};\n\n#define fd_data(fd) (fio_data->info[(uintptr_t)(fd)])\n#define uuid_data(uuid) fd_data(fio_uuid2fd((uuid)))\n#define fd2uuid(fd)                                                            \\\n  ((intptr_t)((((uintptr_t)(fd)) << 8) | fd_data((fd)).counter))\n\n/**\n * Returns the maximum number of open files facil.io can handle per worker\n * process.\n *\n * Total OS limits might apply as well but aren't shown.\n *\n * The value of 0 indicates either that the facil.io library wasn't initialized\n * yet or that it's resources were released.\n */\nsize_t fio_capa(void) {\n  if (fio_data)\n    return fio_data->capa;\n  return 0;\n}\n\n/* *****************************************************************************\nPacket allocation (for socket's user-buffer)\n***************************************************************************** */\n\nstatic inline void fio_packet_free(fio_packet_s *packet) {\n  packet->dealloc(packet->data.buffer);\n  fio_free(packet);\n}\nstatic inline fio_packet_s *fio_packet_alloc(void) {\n  fio_packet_s *packet = fio_malloc(sizeof(*packet));\n  FIO_ASSERT_ALLOC(packet);\n  return packet;\n}\n\n/* *****************************************************************************\nCore Connection Data Clearing\n***************************************************************************** */\n\n/* set the minimal max_protocol_fd */\nstatic void fio_max_fd_min(uint32_t fd) {\n  if (fio_data->max_protocol_fd > fd)\n    return;\n  fio_lock(&fio_data->lock);\n  if (fio_data->max_protocol_fd < fd)\n    fio_data->max_protocol_fd = fd;\n  fio_unlock(&fio_data->lock);\n}\n\n/* set the minimal max_protocol_fd */\nstatic void fio_max_fd_shrink(void) {\n  fio_lock(&fio_data->lock);\n  uint32_t fd = fio_data->max_protocol_fd;\n  while (fd && fd_data(fd).protocol == NULL)\n    --fd;\n  fio_data->max_protocol_fd = fd;\n  fio_unlock(&fio_data->lock);\n}\n\n/* resets connection data, marking it as either open or closed. */\nstatic inline int fio_clear_fd(intptr_t fd, uint8_t is_open) {\n  fio_packet_s *packet;\n  fio_protocol_s *protocol;\n  fio_rw_hook_s *rw_hooks;\n  void *rw_udata;\n  fio_uuid_links_s links;\n  fio_lock(&(fd_data(fd).sock_lock));\n  links = fd_data(fd).links;\n  packet = fd_data(fd).packet;\n  protocol = fd_data(fd).protocol;\n  rw_hooks = fd_data(fd).rw_hooks;\n  rw_udata = fd_data(fd).rw_udata;\n  fd_data(fd) = (fio_fd_data_s){\n      .open = is_open,\n      .sock_lock = fd_data(fd).sock_lock,\n      .protocol_lock = fd_data(fd).protocol_lock,\n      .rw_hooks = (fio_rw_hook_s *)&FIO_DEFAULT_RW_HOOKS,\n      .counter = fd_data(fd).counter + 1,\n      .packet_last = &fd_data(fd).packet,\n  };\n  fio_unlock(&(fd_data(fd).sock_lock));\n  if (rw_hooks && rw_hooks->cleanup)\n    rw_hooks->cleanup(rw_udata);\n  while (packet) {\n    fio_packet_s *tmp = packet;\n    packet = packet->next;\n    fio_packet_free(tmp);\n  }\n  if (fio_uuid_links_count(&links)) {\n    FIO_SET_FOR_LOOP(&links, pos) {\n      if (pos->hash)\n        pos->obj((void *)pos->hash);\n    }\n  }\n  fio_uuid_links_free(&links);\n  if (protocol && protocol->on_close) {\n    fio_defer(deferred_on_close, (void *)fd2uuid(fd), protocol);\n  }\n  if (is_open)\n    fio_max_fd_min(fd);\n  return 0;\n}\n\nstatic inline void fio_force_close_in_poll(intptr_t uuid) {\n  uuid_data(uuid).close = 2;\n  fio_force_close(uuid);\n}\n\n/* *****************************************************************************\nProtocol Locking and UUID validation\n***************************************************************************** */\n\n/* Macro for accessing the protocol locking / metadata. */\n#define prt_meta(prt) (((union protocol_metadata_union_u *)(&(prt)->rsv))->meta)\n\n/** locks a connection's protocol returns a pointer that need to be unlocked. */\ninline static fio_protocol_s *protocol_try_lock(intptr_t fd,\n                                                enum fio_protocol_lock_e type) {\n  errno = 0;\n  if (fio_trylock(&fd_data(fd).protocol_lock))\n    goto would_block;\n  fio_protocol_s *pr = fd_data(fd).protocol;\n  if (!pr) {\n    fio_unlock(&fd_data(fd).protocol_lock);\n    goto invalid;\n  }\n  if (fio_trylock(&prt_meta(pr).locks[type])) {\n    fio_unlock(&fd_data(fd).protocol_lock);\n    goto would_block;\n  }\n  fio_unlock(&fd_data(fd).protocol_lock);\n  return pr;\nwould_block:\n  errno = EWOULDBLOCK;\n  return NULL;\ninvalid:\n  errno = EBADF;\n  return NULL;\n}\n/** See `fio_protocol_try_lock` for details. */\ninline static void protocol_unlock(fio_protocol_s *pr,\n                                   enum fio_protocol_lock_e type) {\n  fio_unlock(&prt_meta(pr).locks[type]);\n}\n\n/** returns 1 if the UUID is valid and 0 if it isn't. */\n#define uuid_is_valid(uuid)                                                    \\\n  ((intptr_t)(uuid) >= 0 &&                                                    \\\n   ((uint32_t)fio_uuid2fd((uuid))) < fio_data->capa &&                         \\\n   ((uintptr_t)(uuid)&0xFF) == uuid_data((uuid)).counter)\n\n/* public API. */\nfio_protocol_s *fio_protocol_try_lock(intptr_t uuid,\n                                      enum fio_protocol_lock_e type) {\n  if (!uuid_is_valid(uuid)) {\n    errno = EBADF;\n    return NULL;\n  }\n  return protocol_try_lock(fio_uuid2fd(uuid), type);\n}\n\n/* public API. */\nvoid fio_protocol_unlock(fio_protocol_s *pr, enum fio_protocol_lock_e type) {\n  protocol_unlock(pr, type);\n}\n\n/* *****************************************************************************\nUUID validation and state\n***************************************************************************** */\n\n/* public API. */\nintptr_t fio_fd2uuid(int fd) {\n  if (fd < 0 || (size_t)fd >= fio_data->capa)\n    return -1;\n  if (!fd_data(fd).open) {\n    fio_lock(&fd_data(fd).protocol_lock);\n    fio_clear_fd(fd, 1);\n    fio_unlock(&fd_data(fd).protocol_lock);\n  }\n  return fd2uuid(fd);\n}\n\n/* public API. */\nint fio_is_valid(intptr_t uuid) { return uuid_is_valid(uuid); }\n\n/* public API. */\nint fio_is_closed(intptr_t uuid) {\n  return !uuid_is_valid(uuid) || !uuid_data(uuid).open || uuid_data(uuid).close;\n}\n\nvoid fio_stop(void) {\n  if (fio_data)\n    fio_data->active = 0;\n}\n\n/* public API. */\nint16_t fio_is_running(void) { return fio_data && fio_data->active; }\n\n/* public API. */\nstruct timespec fio_last_tick(void) {\n  return fio_data->last_cycle;\n}\n\n#define touchfd(fd) fd_data((fd)).active = fio_data->last_cycle.tv_sec\n\n/* public API. */\nvoid fio_touch(intptr_t uuid) {\n  if (uuid_is_valid(uuid))\n    touchfd(fio_uuid2fd(uuid));\n}\n\n/* public API. */\nfio_str_info_s fio_peer_addr(intptr_t uuid) {\n  if (fio_is_closed(uuid) || !uuid_data(uuid).addr_len)\n    return (fio_str_info_s){.data = NULL, .len = 0, .capa = 0};\n  return (fio_str_info_s){.data = (char *)uuid_data(uuid).addr,\n                          .len = uuid_data(uuid).addr_len,\n                          .capa = 0};\n}\n\n/**\n * Writes the local machine address (qualified host name) to the buffer.\n *\n * Returns the amount of data written (excluding the NUL byte).\n *\n * `limit` is the maximum number of bytes in the buffer, including the NUL byte.\n *\n * If the returned value == limit - 1, the result might have been truncated.\n *\n * If 0 is returned, an erro might have occured (see `errno`) and the contents\n * of `dest` is undefined.\n */\nsize_t fio_local_addr(char *dest, size_t limit) {\n  if (gethostname(dest, limit))\n    return 0;\n\n  struct addrinfo hints, *info;\n  memset(&hints, 0, sizeof hints);\n  hints.ai_family = AF_UNSPEC;     // don't care IPv4 or IPv6\n  hints.ai_socktype = SOCK_STREAM; // TCP stream sockets\n  hints.ai_flags = AI_CANONNAME;   // get cannonical name\n\n  if (getaddrinfo(dest, \"http\", &hints, &info) != 0)\n    return 0;\n\n  for (struct addrinfo *pos = info; pos; pos = pos->ai_next) {\n    if (pos->ai_canonname) {\n      size_t len = strlen(pos->ai_canonname);\n      if (len >= limit)\n        len = limit - 1;\n      memcpy(dest, pos->ai_canonname, len);\n      dest[len] = 0;\n      freeaddrinfo(info);\n      return len;\n    }\n  }\n\n  freeaddrinfo(info);\n  return 0;\n}\n\n/* *****************************************************************************\nUUID attachments (linking objects to the UUID's lifetime)\n***************************************************************************** */\n\n/* public API. */\nvoid fio_uuid_link(intptr_t uuid, void *obj, void (*on_close)(void *obj)) {\n  if (!uuid_is_valid(uuid))\n    goto invalid;\n  fio_lock(&uuid_data(uuid).sock_lock);\n  if (!uuid_is_valid(uuid))\n    goto locked_invalid;\n  fio_uuid_links_overwrite(&uuid_data(uuid).links, (uintptr_t)obj, on_close,\n                           NULL);\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  return;\nlocked_invalid:\n  fio_unlock(&uuid_data(uuid).sock_lock);\ninvalid:\n  errno = EBADF;\n  on_close(obj);\n}\n\n/* public API. */\nint fio_uuid_unlink(intptr_t uuid, void *obj) {\n  if (!uuid_is_valid(uuid))\n    goto invalid;\n  fio_lock(&uuid_data(uuid).sock_lock);\n  if (!uuid_is_valid(uuid))\n    goto locked_invalid;\n  /* default object comparison is always true */\n  int ret =\n      fio_uuid_links_remove(&uuid_data(uuid).links, (uintptr_t)obj, NULL, NULL);\n  if (ret)\n    errno = ENOTCONN;\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  return ret;\nlocked_invalid:\n  fio_unlock(&uuid_data(uuid).sock_lock);\ninvalid:\n  errno = EBADF;\n  return -1;\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n                         Default Thread / Fork handler\n\n                           And Concurrency Helpers\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/**\nOVERRIDE THIS to replace the default `fork` implementation.\n\nBehaves like the system's `fork`.\n*/\n#pragma weak fio_fork\nint __attribute__((weak)) fio_fork(void) { return fork(); }\n\n/**\n * OVERRIDE THIS to replace the default pthread implementation.\n *\n * Accepts a pointer to a function and a single argument that should be executed\n * within a new thread.\n *\n * The function should allocate memory for the thread object and return a\n * pointer to the allocated memory that identifies the thread.\n *\n * On error NULL should be returned.\n */\n#pragma weak fio_thread_new\nvoid *__attribute__((weak))\nfio_thread_new(void *(*thread_func)(void *), void *arg) {\n  pthread_t *thread = malloc(sizeof(*thread));\n  FIO_ASSERT_ALLOC(thread);\n  if (pthread_create(thread, NULL, thread_func, arg))\n    goto error;\n  return thread;\nerror:\n  free(thread);\n  return NULL;\n}\n\n/**\n * OVERRIDE THIS to replace the default pthread implementation.\n *\n * Frees the memory associated with a thread identifier (allows the thread to\n * run it's course, just the identifier is freed).\n */\n#pragma weak fio_thread_free\nvoid __attribute__((weak)) fio_thread_free(void *p_thr) {\n  if (*((pthread_t *)p_thr)) {\n    pthread_detach(*((pthread_t *)p_thr));\n  }\n  free(p_thr);\n}\n\n/**\n * OVERRIDE THIS to replace the default pthread implementation.\n *\n * Accepts a pointer returned from `fio_thread_new` (should also free any\n * allocated memory) and joins the associated thread.\n *\n * Return value is ignored.\n */\n#pragma weak fio_thread_join\nint __attribute__((weak)) fio_thread_join(void *p_thr) {\n  if (!p_thr || !(*((pthread_t *)p_thr)))\n    return -1;\n  pthread_join(*((pthread_t *)p_thr), NULL);\n  *((pthread_t *)p_thr) = (pthread_t)NULL;\n  free(p_thr);\n  return 0;\n}\n\n/* *****************************************************************************\nSuspending and renewing thread execution (signaling events)\n***************************************************************************** */\n\n#ifndef DEFER_THROTTLE\n#define DEFER_THROTTLE 2097148UL\n#endif\n#ifndef FIO_DEFER_THROTTLE_LIMIT\n#define FIO_DEFER_THROTTLE_LIMIT 134217472UL\n#endif\n\n/**\n * The polling throttling model will use pipes to suspend and resume threads...\n *\n * However, it seems the approach is currently broken, at least on macOS.\n * I don't know why.\n *\n * If polling is disabled, the progressive throttling model will be used.\n *\n * The progressive throttling makes concurrency and parallelism likely, but uses\n * progressive nano-sleep throttling system that is less exact.\n */\n#ifndef FIO_DEFER_THROTTLE_POLL\n#define FIO_DEFER_THROTTLE_POLL 0\n#endif\n\ntypedef struct fio_thread_queue_s {\n  fio_ls_embd_s node;\n  int fd_wait;   /* used for weaiting (read signal) */\n  int fd_signal; /* used for signalling (write) */\n} fio_thread_queue_s;\n\nfio_ls_embd_s fio_thread_queue = FIO_LS_INIT(fio_thread_queue);\nfio_lock_i fio_thread_lock = FIO_LOCK_INIT;\nstatic __thread fio_thread_queue_s fio_thread_data = {.fd_wait = -1,\n                                                      .fd_signal = -1};\n\nFIO_FUNC inline void fio_thread_make_suspendable(void) {\n  if (fio_thread_data.fd_signal >= 0)\n    return;\n  int fd[2] = {0, 0};\n  int ret = pipe(fd);\n  FIO_ASSERT(ret == 0, \"`pipe` failed.\");\n  FIO_ASSERT(fio_set_non_block(fd[0]) == 0,\n             \"(fio) couldn't set internal pipe to non-blocking mode.\");\n  FIO_ASSERT(fio_set_non_block(fd[1]) == 0,\n             \"(fio) couldn't set internal pipe to non-blocking mode.\");\n  fio_thread_data.fd_wait = fd[0];\n  fio_thread_data.fd_signal = fd[1];\n}\n\nFIO_FUNC inline void fio_thread_cleanup(void) {\n  if (fio_thread_data.fd_signal < 0)\n    return;\n  close(fio_thread_data.fd_wait);\n  close(fio_thread_data.fd_signal);\n  fio_thread_data.fd_wait = -1;\n  fio_thread_data.fd_signal = -1;\n}\n\n/* suspend thread execution (might be resumed unexpectedly) */\nFIO_FUNC void fio_thread_suspend(void) {\n  fio_lock(&fio_thread_lock);\n  fio_ls_embd_push(&fio_thread_queue, &fio_thread_data.node);\n  fio_unlock(&fio_thread_lock);\n  struct pollfd list = {\n      .events = (POLLPRI | POLLIN),\n      .fd = fio_thread_data.fd_wait,\n  };\n  if (poll(&list, 1, 5000) > 0) {\n    /* thread was removed from the list through signal */\n    uint64_t data;\n    int r = read(fio_thread_data.fd_wait, &data, sizeof(data));\n    (void)r;\n  } else {\n    /* remove self from list */\n    fio_lock(&fio_thread_lock);\n    fio_ls_embd_remove(&fio_thread_data.node);\n    fio_unlock(&fio_thread_lock);\n  }\n}\n\n/* wake up a single thread */\nFIO_FUNC void fio_thread_signal(void) {\n  fio_thread_queue_s *t;\n  int fd = -2;\n  fio_lock(&fio_thread_lock);\n  t = (fio_thread_queue_s *)fio_ls_embd_shift(&fio_thread_queue);\n  if (t)\n    fd = t->fd_signal;\n  fio_unlock(&fio_thread_lock);\n  if (fd >= 0) {\n    uint64_t data = 1;\n    int r = write(fd, (void *)&data, sizeof(data));\n    (void)r;\n  } else if (fd == -1) {\n    /* hardly the best way, but there's a thread sleeping on air */\n    kill(getpid(), SIGCONT);\n  }\n}\n\n/* wake up all threads */\nFIO_FUNC void fio_thread_broadcast(void) {\n  while (fio_ls_embd_any(&fio_thread_queue)) {\n    fio_thread_signal();\n  }\n}\n\nstatic size_t fio_poll(void);\n/**\n * A thread entering this function should wait for new evennts.\n */\nstatic void fio_defer_thread_wait(void) {\n#if FIO_ENGINE_POLL\n  fio_poll();\n  return;\n#endif\n  if (FIO_DEFER_THROTTLE_POLL) {\n    fio_thread_suspend();\n  } else {\n    /* keeps threads active (concurrent), but reduces performance */\n    static __thread size_t static_throttle = 262143UL;\n    fio_throttle_thread(static_throttle);\n    if (fio_defer_has_queue())\n      static_throttle = 1;\n    else if (static_throttle < FIO_DEFER_THROTTLE_LIMIT)\n      static_throttle = (static_throttle << 1);\n  }\n}\n\nstatic inline void fio_defer_on_thread_start(void) {\n  if (FIO_DEFER_THROTTLE_POLL)\n    fio_thread_make_suspendable();\n}\nstatic inline void fio_defer_thread_signal(void) {\n  if (FIO_DEFER_THROTTLE_POLL)\n    fio_thread_signal();\n}\nstatic inline void fio_defer_on_thread_end(void) {\n  if (FIO_DEFER_THROTTLE_POLL) {\n    fio_thread_broadcast();\n    fio_thread_cleanup();\n  }\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                             Task Management\n\n                  Task / Event schduling and execution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n#ifndef DEFER_QUEUE_BLOCK_COUNT\n#if UINTPTR_MAX <= 0xFFFFFFFF\n/* Almost a page of memory on most 32 bit machines: ((4096/4)-8)/3 */\n#define DEFER_QUEUE_BLOCK_COUNT 338\n#else\n/* Almost a page of memory on most 64 bit machines: ((4096/8)-8)/3 */\n#define DEFER_QUEUE_BLOCK_COUNT 168\n#endif\n#endif\n\n/* task node data */\ntypedef struct {\n  void (*func)(void *, void *);\n  void *arg1;\n  void *arg2;\n} fio_defer_task_s;\n\n/* task queue block */\ntypedef struct fio_defer_queue_block_s fio_defer_queue_block_s;\nstruct fio_defer_queue_block_s {\n  fio_defer_task_s tasks[DEFER_QUEUE_BLOCK_COUNT];\n  fio_defer_queue_block_s *next;\n  size_t write;\n  size_t read;\n  unsigned char state;\n};\n\n/* task queue object */\ntypedef struct { /* a lock for the state machine, used for multi-threading\n                    support */\n  fio_lock_i lock;\n  /* current active block to pop tasks */\n  fio_defer_queue_block_s *reader;\n  /* current active block to push tasks */\n  fio_defer_queue_block_s *writer;\n  /* static, built-in, queue */\n  fio_defer_queue_block_s static_queue;\n} fio_task_queue_s;\n\n/* the state machine - this holds all the data about the task queue and pool */\nstatic fio_task_queue_s task_queue_normal = {\n    .reader = &task_queue_normal.static_queue,\n    .writer = &task_queue_normal.static_queue};\n\nstatic fio_task_queue_s task_queue_urgent = {\n    .reader = &task_queue_urgent.static_queue,\n    .writer = &task_queue_urgent.static_queue};\n\n/* *****************************************************************************\nInternal Task API\n***************************************************************************** */\n\n#if DEBUG\nstatic size_t fio_defer_count_alloc, fio_defer_count_dealloc;\n#define COUNT_ALLOC fio_atomic_add(&fio_defer_count_alloc, 1)\n#define COUNT_DEALLOC fio_atomic_add(&fio_defer_count_dealloc, 1)\n#define COUNT_RESET                                                            \\\n  do {                                                                         \\\n    fio_defer_count_alloc = fio_defer_count_dealloc = 0;                       \\\n  } while (0)\n#else\n#define COUNT_ALLOC\n#define COUNT_DEALLOC\n#define COUNT_RESET\n#endif\n\nstatic inline void fio_defer_push_task_fn(fio_defer_task_s task,\n                                          fio_task_queue_s *queue) {\n  fio_lock(&queue->lock);\n\n  /* test if full */\n  if (queue->writer->state && queue->writer->write == queue->writer->read) {\n    /* return to static buffer or allocate new buffer */\n    if (queue->static_queue.state == 2) {\n      queue->writer->next = &queue->static_queue;\n    } else {\n      queue->writer->next = fio_malloc(sizeof(*queue->writer->next));\n      COUNT_ALLOC;\n      if (!queue->writer->next)\n        goto critical_error;\n    }\n    queue->writer = queue->writer->next;\n    queue->writer->write = 0;\n    queue->writer->read = 0;\n    queue->writer->state = 0;\n    queue->writer->next = NULL;\n  }\n\n  /* place task and finish */\n  queue->writer->tasks[queue->writer->write++] = task;\n  /* cycle buffer */\n  if (queue->writer->write == DEFER_QUEUE_BLOCK_COUNT) {\n    queue->writer->write = 0;\n    queue->writer->state = 1;\n  }\n  fio_unlock(&queue->lock);\n  return;\n\ncritical_error:\n  fio_unlock(&queue->lock);\n  FIO_ASSERT_ALLOC(NULL)\n}\n\n#define fio_defer_push_task(func_, arg1_, arg2_)                               \\\n  do {                                                                         \\\n    fio_defer_push_task_fn(                                                    \\\n        (fio_defer_task_s){.func = func_, .arg1 = arg1_, .arg2 = arg2_},       \\\n        &task_queue_normal);                                                   \\\n    fio_defer_thread_signal();                                                 \\\n  } while (0)\n\n#if FIO_USE_URGENT_QUEUE\n#define fio_defer_push_urgent(func_, arg1_, arg2_)                             \\\n  fio_defer_push_task_fn(                                                      \\\n      (fio_defer_task_s){.func = func_, .arg1 = arg1_, .arg2 = arg2_},         \\\n      &task_queue_urgent)\n#else\n#define fio_defer_push_urgent(func_, arg1_, arg2_)                             \\\n  fio_defer_push_task(func_, arg1_, arg2_)\n#endif\n\nstatic inline fio_defer_task_s fio_defer_pop_task(fio_task_queue_s *queue) {\n  fio_defer_task_s ret = (fio_defer_task_s){.func = NULL};\n  fio_defer_queue_block_s *to_free = NULL;\n  /* lock the state machine, grab/create a task and place it at the tail */\n  fio_lock(&queue->lock);\n\n  /* empty? */\n  if (queue->reader->write == queue->reader->read && !queue->reader->state)\n    goto finish;\n  /* collect task */\n  ret = queue->reader->tasks[queue->reader->read++];\n  /* cycle */\n  if (queue->reader->read == DEFER_QUEUE_BLOCK_COUNT) {\n    queue->reader->read = 0;\n    queue->reader->state = 0;\n  }\n  /* did we finish the queue in the buffer? */\n  if (queue->reader->write == queue->reader->read) {\n    if (queue->reader->next) {\n      to_free = queue->reader;\n      queue->reader = queue->reader->next;\n    } else {\n      if (queue->reader != &queue->static_queue &&\n          queue->static_queue.state == 2) {\n        to_free = queue->reader;\n        queue->writer = &queue->static_queue;\n        queue->reader = &queue->static_queue;\n      }\n      queue->reader->write = queue->reader->read = queue->reader->state = 0;\n    }\n  }\n\nfinish:\n  if (to_free == &queue->static_queue) {\n    queue->static_queue.state = 2;\n    queue->static_queue.next = NULL;\n  }\n  fio_unlock(&queue->lock);\n\n  if (to_free && to_free != &queue->static_queue) {\n    fio_free(to_free);\n    COUNT_DEALLOC;\n  }\n  return ret;\n}\n\n/* same as fio_defer_clear_queue , just inlined */\nstatic inline void fio_defer_clear_tasks_for_queue(fio_task_queue_s *queue) {\n  fio_lock(&queue->lock);\n  while (queue->reader) {\n    fio_defer_queue_block_s *tmp = queue->reader;\n    queue->reader = queue->reader->next;\n    if (tmp != &queue->static_queue) {\n      COUNT_DEALLOC;\n      free(tmp);\n    }\n  }\n  queue->static_queue = (fio_defer_queue_block_s){.next = NULL};\n  queue->reader = queue->writer = &queue->static_queue;\n  fio_unlock(&queue->lock);\n}\n\n/**\n * Performs a single task from the queue, returning -1 if the queue was empty.\n */\nstatic inline int\nfio_defer_perform_single_task_for_queue(fio_task_queue_s *queue) {\n  fio_defer_task_s task = fio_defer_pop_task(queue);\n  if (!task.func)\n    return -1;\n  task.func(task.arg1, task.arg2);\n  return 0;\n}\n\nstatic inline void fio_defer_clear_tasks(void) {\n  fio_defer_clear_tasks_for_queue(&task_queue_normal);\n#if FIO_USE_URGENT_QUEUE\n  fio_defer_clear_tasks_for_queue(&task_queue_urgent);\n#endif\n}\n\nstatic void fio_defer_on_fork(void) {\n  task_queue_normal.lock = FIO_LOCK_INIT;\n#if FIO_USE_URGENT_QUEUE\n  task_queue_urgent.lock = FIO_LOCK_INIT;\n#endif\n}\n\n/* *****************************************************************************\nExternal Task API\n***************************************************************************** */\n\n/** Defer an execution of a function for later. */\nint fio_defer(void (*func)(void *, void *), void *arg1, void *arg2) {\n  /* must have a task to defer */\n  if (!func)\n    goto call_error;\n  fio_defer_push_task(func, arg1, arg2);\n  return 0;\n\ncall_error:\n  return -1;\n}\n\n/** Performs all deferred functions until the queue had been depleted. */\nvoid fio_defer_perform(void) {\n#if FIO_USE_URGENT_QUEUE\n  while (fio_defer_perform_single_task_for_queue(&task_queue_urgent) == 0 ||\n         fio_defer_perform_single_task_for_queue(&task_queue_normal) == 0)\n    ;\n#else\n  while (fio_defer_perform_single_task_for_queue(&task_queue_normal) == 0)\n    ;\n#endif\n  //   for (;;) {\n  // #if FIO_USE_URGENT_QUEUE\n  //     fio_defer_task_s task = fio_defer_pop_task(&task_queue_urgent);\n  //     if (!task.func)\n  //       task = fio_defer_pop_task(&task_queue_normal);\n  // #else\n  //     fio_defer_task_s task = fio_defer_pop_task(&task_queue_normal);\n  // #endif\n  //     if (!task.func)\n  //       return;\n  //     task.func(task.arg1, task.arg2);\n  //   }\n}\n\n/** Returns true if there are deferred functions waiting for execution. */\nint fio_defer_has_queue(void) {\n#if FIO_USE_URGENT_QUEUE\n  return task_queue_urgent.reader != task_queue_urgent.writer ||\n         task_queue_urgent.reader->write != task_queue_urgent.reader->read ||\n         task_queue_normal.reader != task_queue_normal.writer ||\n         task_queue_normal.reader->write != task_queue_normal.reader->read;\n#else\n  return task_queue_normal.reader != task_queue_normal.writer ||\n         task_queue_normal.reader->write != task_queue_normal.reader->read;\n#endif\n}\n\n/** Clears the queue. */\nvoid fio_defer_clear_queue(void) { fio_defer_clear_tasks(); }\n\n/* Thread pool task */\nstatic void *fio_defer_cycle(void *ignr) {\n  fio_defer_on_thread_start();\n  for (;;) {\n    fio_defer_perform();\n    if (!fio_is_running())\n      break;\n    fio_defer_thread_wait();\n  }\n  fio_defer_on_thread_end();\n  return ignr;\n}\n\n/* thread pool type */\ntypedef struct {\n  size_t thread_count;\n  void *threads[];\n} fio_defer_thread_pool_s;\n\n/* joins a thread pool */\nstatic void fio_defer_thread_pool_join(fio_defer_thread_pool_s *pool) {\n  for (size_t i = 0; i < pool->thread_count; ++i) {\n    fio_thread_join(pool->threads[i]);\n  }\n  free(pool);\n}\n\n/* creates a thread pool */\nstatic fio_defer_thread_pool_s *fio_defer_thread_pool_new(size_t count) {\n  if (!count)\n    count = 1;\n  fio_defer_thread_pool_s *pool =\n      malloc(sizeof(*pool) + (count * sizeof(void *)));\n  FIO_ASSERT_ALLOC(pool);\n  pool->thread_count = count;\n  for (size_t i = 0; i < count; ++i) {\n    pool->threads[i] = fio_thread_new(fio_defer_cycle, NULL);\n    if (!pool->threads[i]) {\n      pool->thread_count = i;\n      goto error;\n    }\n  }\n  return pool;\nerror:\n  FIO_LOG_FATAL(\"couldn't spawn threads for thread pool, attempting shutdown.\");\n  fio_stop();\n  fio_defer_thread_pool_join(pool);\n  return NULL;\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n                                     Timers\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\ntypedef struct {\n  fio_ls_embd_s node;\n  struct timespec due;\n  size_t interval; /*in ms */\n  size_t repetitions;\n  void (*task)(void *);\n  void *arg;\n  void (*on_finish)(void *);\n} fio_timer_s;\n\nstatic fio_ls_embd_s fio_timers = FIO_LS_INIT(fio_timers);\n\nstatic fio_lock_i fio_timer_lock = FIO_LOCK_INIT;\n\n/** Marks the current time as facil.io's cycle time */\nstatic inline void fio_mark_time(void) {\n  clock_gettime(CLOCK_REALTIME, &fio_data->last_cycle);\n}\n\n/** Calculates the due time for a task, given it's interval */\nstatic struct timespec fio_timer_calc_due(size_t interval) {\n  struct timespec now = fio_last_tick();\n  if (interval > 1000) {\n    now.tv_sec += interval / 1000;\n    interval -= interval / 1000;\n  }\n  now.tv_nsec += (interval * 1000000UL);\n  if (now.tv_nsec > 1000000000L) {\n    now.tv_nsec -= 1000000000L;\n    now.tv_sec += 1;\n  }\n  return now;\n}\n\n/** Returns the number of miliseconds until the next event, up to FIO_POLL_TICK\n */\nstatic size_t fio_timer_calc_first_interval(void) {\n  if (fio_defer_has_queue())\n    return 0;\n  if (fio_ls_embd_is_empty(&fio_timers)) {\n    return FIO_POLL_TICK;\n  }\n  struct timespec now = fio_last_tick();\n  struct timespec due =\n      FIO_LS_EMBD_OBJ(fio_timer_s, node, fio_timers.next)->due;\n  if (due.tv_sec < now.tv_sec ||\n      (due.tv_sec == now.tv_sec && due.tv_nsec <= now.tv_nsec))\n    return 0;\n  size_t interval = 1000L * (due.tv_sec - now.tv_sec);\n  if (due.tv_nsec >= now.tv_nsec) {\n    interval += (due.tv_nsec - now.tv_nsec) / 1000000L;\n  } else {\n    interval -= (now.tv_nsec - due.tv_nsec) / 1000000L;\n  }\n  if (interval > FIO_POLL_TICK)\n    interval = FIO_POLL_TICK;\n  return interval;\n}\n\n/* simple a<=>b if \"a\" is bigger a negative result is returned, eq == 0. */\nstatic int fio_timer_compare(struct timespec a, struct timespec b) {\n  if (a.tv_sec == b.tv_sec) {\n    if (a.tv_nsec < b.tv_nsec)\n      return 1;\n    if (a.tv_nsec > b.tv_nsec)\n      return -1;\n    return 0;\n  }\n  if (a.tv_sec < b.tv_sec)\n    return 1;\n  return -1;\n}\n\n/** Places a timer in an ordered linked list. */\nstatic void fio_timer_add_order(fio_timer_s *timer) {\n  timer->due = fio_timer_calc_due(timer->interval);\n  // fio_ls_embd_s *pos = &fio_timers;\n  fio_lock(&fio_timer_lock);\n  FIO_LS_EMBD_FOR(&fio_timers, node) {\n    fio_timer_s *t2 = FIO_LS_EMBD_OBJ(fio_timer_s, node, node);\n    if (fio_timer_compare(timer->due, t2->due) >= 0) {\n      fio_ls_embd_push(node, &timer->node);\n      goto finish;\n    }\n  }\n  fio_ls_embd_push(&fio_timers, &timer->node);\nfinish:\n  fio_unlock(&fio_timer_lock);\n}\n\n/** Performs a timer task and re-adds it to the queue (or cleans it up) */\nstatic void fio_timer_perform_single(void *timer_, void *ignr) {\n  fio_timer_s *timer = timer_;\n  timer->task(timer->arg);\n  if (!timer->repetitions || fio_atomic_sub(&timer->repetitions, 1))\n    goto reschedule;\n  if (timer->on_finish)\n    timer->on_finish(timer->arg);\n  free(timer);\n  return;\n  (void)ignr;\nreschedule:\n  fio_timer_add_order(timer);\n}\n\n/** schedules all timers that are due to be performed. */\nstatic void fio_timer_schedule(void) {\n  struct timespec now = fio_last_tick();\n  fio_lock(&fio_timer_lock);\n  while (fio_ls_embd_any(&fio_timers) &&\n         fio_timer_compare(\n             FIO_LS_EMBD_OBJ(fio_timer_s, node, fio_timers.next)->due, now) >=\n             0) {\n    fio_ls_embd_s *tmp = fio_ls_embd_remove(fio_timers.next);\n    fio_defer(fio_timer_perform_single, FIO_LS_EMBD_OBJ(fio_timer_s, node, tmp),\n              NULL);\n  }\n  fio_unlock(&fio_timer_lock);\n}\n\nstatic void fio_timer_clear_all(void) {\n  fio_lock(&fio_timer_lock);\n  while (fio_ls_embd_any(&fio_timers)) {\n    fio_timer_s *timer =\n        FIO_LS_EMBD_OBJ(fio_timer_s, node, fio_ls_embd_pop(&fio_timers));\n    if (timer->on_finish)\n      timer->on_finish(timer->arg);\n    free(timer);\n  }\n  fio_unlock(&fio_timer_lock);\n}\n\n/**\n * Creates a timer to run a task at the specified interval.\n *\n * The task will repeat `repetitions` times. If `repetitions` is set to 0, task\n * will repeat forever.\n *\n * Returns -1 on error.\n *\n * The `on_finish` handler is always called (even on error).\n */\nint fio_run_every(size_t milliseconds, size_t repetitions, void (*task)(void *),\n                  void *arg, void (*on_finish)(void *)) {\n  if (!task || (milliseconds == 0 && !repetitions))\n    return -1;\n  fio_timer_s *timer = malloc(sizeof(*timer));\n  FIO_ASSERT_ALLOC(timer);\n  fio_mark_time();\n  *timer = (fio_timer_s){\n      .due = fio_timer_calc_due(milliseconds),\n      .interval = milliseconds,\n      .repetitions = repetitions,\n      .task = task,\n      .arg = arg,\n      .on_finish = on_finish,\n  };\n  fio_timer_add_order(timer);\n  return 0;\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n                               Concurrency Helpers\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\nvolatile uint8_t fio_signal_children_flag = 0;\n\n/* store old signal handlers to propegate signal handling */\nstatic struct sigaction fio_old_sig_chld;\nstatic struct sigaction fio_old_sig_pipe;\nstatic struct sigaction fio_old_sig_term;\nstatic struct sigaction fio_old_sig_int;\n#if !FIO_DISABLE_HOT_RESTART\nstatic struct sigaction fio_old_sig_usr1;\n#endif\n\n/*\n * Zombie Reaping\n * With thanks to Dr Graham D Shaw.\n * http://www.microhowto.info/howto/reap_zombie_processes_using_a_sigchld_handler.html\n */\nstatic void reap_child_handler(int sig) {\n  (void)(sig);\n  int old_errno = errno;\n  while (waitpid(-1, NULL, WNOHANG) > 0)\n    ;\n  errno = old_errno;\n  if (fio_old_sig_chld.sa_handler != SIG_IGN &&\n      fio_old_sig_chld.sa_handler != SIG_DFL)\n    fio_old_sig_chld.sa_handler(sig);\n}\n\n/* initializes zombie reaping for the process */\nvoid fio_reap_children(void) {\n  struct sigaction sa;\n  if (fio_old_sig_chld.sa_handler)\n    return;\n  sa.sa_handler = reap_child_handler;\n  sigemptyset(&sa.sa_mask);\n  sa.sa_flags = SA_RESTART | SA_NOCLDSTOP;\n  if (sigaction(SIGCHLD, &sa, &fio_old_sig_chld) == -1) {\n    perror(\"Child reaping initialization failed\");\n    kill(0, SIGINT);\n    exit(errno);\n  }\n}\n\n/* handles the SIGUSR1, SIGINT and SIGTERM signals. */\nstatic void sig_int_handler(int sig) {\n  struct sigaction *old = NULL;\n  switch (sig) {\n#if !FIO_DISABLE_HOT_RESTART\n  case SIGUSR1:\n    fio_signal_children_flag = 1;\n    old = &fio_old_sig_usr1;\n    break;\n#endif\n    /* fallthrough */\n  case SIGINT:\n    if (!old)\n      old = &fio_old_sig_int;\n    /* fallthrough */\n  case SIGTERM:\n    if (!old)\n      old = &fio_old_sig_term;\n    fio_stop();\n    break;\n  case SIGPIPE:\n    if (!old)\n      old = &fio_old_sig_pipe;\n  /* fallthrough */\n  default:\n    break;\n  }\n  /* propagate signale handling to previous existing handler (if any) */\n  if (old->sa_handler != SIG_IGN && old->sa_handler != SIG_DFL)\n    old->sa_handler(sig);\n}\n\n/* setup handling for the SIGUSR1, SIGPIPE, SIGINT and SIGTERM signals. */\nstatic void fio_signal_handler_setup(void) {\n  /* setup signal handling */\n  struct sigaction act;\n  if (fio_old_sig_int.sa_handler)\n    return;\n\n  memset(&act, 0, sizeof(act));\n\n  act.sa_handler = sig_int_handler;\n  sigemptyset(&act.sa_mask);\n  act.sa_flags = SA_RESTART | SA_NOCLDSTOP;\n\n  if (sigaction(SIGINT, &act, &fio_old_sig_int)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n\n  if (sigaction(SIGTERM, &act, &fio_old_sig_term)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n#if !FIO_DISABLE_HOT_RESTART\n  if (sigaction(SIGUSR1, &act, &fio_old_sig_usr1)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n#endif\n\n  act.sa_handler = SIG_IGN;\n  if (sigaction(SIGPIPE, &act, &fio_old_sig_pipe)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n}\n\nvoid fio_signal_handler_reset(void) {\n  struct sigaction old;\n  if (!fio_old_sig_int.sa_handler)\n    return;\n  memset(&old, 0, sizeof(old));\n  sigaction(SIGINT, &fio_old_sig_int, &old);\n  sigaction(SIGTERM, &fio_old_sig_term, &old);\n  sigaction(SIGPIPE, &fio_old_sig_pipe, &old);\n  if (fio_old_sig_chld.sa_handler)\n    sigaction(SIGCHLD, &fio_old_sig_chld, &old);\n#if !FIO_DISABLE_HOT_RESTART\n  sigaction(SIGUSR1, &fio_old_sig_usr1, &old);\n  memset(&fio_old_sig_usr1, 0, sizeof(fio_old_sig_usr1));\n#endif\n  memset(&fio_old_sig_int, 0, sizeof(fio_old_sig_int));\n  memset(&fio_old_sig_term, 0, sizeof(fio_old_sig_term));\n  memset(&fio_old_sig_pipe, 0, sizeof(fio_old_sig_pipe));\n  memset(&fio_old_sig_chld, 0, sizeof(fio_old_sig_chld));\n}\n\n/**\n * Returns 1 if the current process is a worker process or a single process.\n *\n * Otherwise returns 0.\n *\n * NOTE: When cluster mode is off, the root process is also the worker process.\n *       This means that single process instances don't automatically respawn\n *       after critical errors.\n */\nint fio_is_worker(void) { return fio_data->is_worker; }\n\n/**\n * Returns 1 if the current process is the master (root) process.\n *\n * Otherwise returns 0.\n */\nint fio_is_master(void) {\n  return fio_data->is_worker == 0 || fio_data->workers == 1;\n}\n\n/** returns facil.io's parent (root) process pid. */\npid_t fio_parent_pid(void) { return fio_data->parent; }\n\nstatic inline size_t fio_detect_cpu_cores(void) {\n  ssize_t cpu_count = 0;\n#ifdef _SC_NPROCESSORS_ONLN\n  cpu_count = sysconf(_SC_NPROCESSORS_ONLN);\n  if (cpu_count < 0) {\n    FIO_LOG_WARNING(\"CPU core count auto-detection failed.\");\n    return 0;\n  }\n#else\n  FIO_LOG_WARNING(\"CPU core count auto-detection failed.\");\n#endif\n  return cpu_count;\n}\n\n/**\n * Returns the number of expected threads / processes to be used by facil.io.\n *\n * The pointers should start with valid values that match the expected threads /\n * processes values passed to `fio_run`.\n *\n * The data in the pointers will be overwritten with the result.\n */\nvoid fio_expected_concurrency(int16_t *threads, int16_t *processes) {\n  if (!threads || !processes)\n    return;\n  if (!*threads && !*processes) {\n    /* both options set to 0 - default to cores*cores matrix */\n    ssize_t cpu_count = fio_detect_cpu_cores();\n#if FIO_CPU_CORES_LIMIT\n    if (cpu_count > FIO_CPU_CORES_LIMIT) {\n      static int print_cores_warning = 1;\n      if (print_cores_warning) {\n        FIO_LOG_WARNING(\n            \"Detected %zu cores. Capping auto-detection of cores to %zu.\\n\"\n            \"      Avoid this message by setting threads / workers manually.\\n\"\n            \"      To increase auto-detection limit, recompile with:\\n\"\n            \"             -DFIO_CPU_CORES_LIMIT=%zu\",\n            (size_t)cpu_count, (size_t)FIO_CPU_CORES_LIMIT, (size_t)cpu_count);\n        print_cores_warning = 0;\n      }\n      cpu_count = FIO_CPU_CORES_LIMIT;\n    }\n#endif\n    *threads = *processes = (int16_t)cpu_count;\n    if (cpu_count > 3) {\n      /* leave a core available for the kernel */\n      --(*processes);\n    }\n  } else if (*threads < 0 || *processes < 0) {\n    /* Set any option that is less than 0 be equal to cores/value */\n    /* Set any option equal to 0 be equal to the other option in value */\n    ssize_t cpu_count = fio_detect_cpu_cores();\n    size_t thread_cpu_adjust = (*threads <= 0 ? 1 : 0);\n    size_t worker_cpu_adjust = (*processes <= 0 ? 1 : 0);\n\n    if (cpu_count > 0) {\n      int16_t tmp = 0;\n      if (*threads < 0)\n        tmp = (int16_t)(cpu_count / (*threads * -1));\n      else if (*threads == 0) {\n        tmp = -1 * *processes;\n        thread_cpu_adjust = 0;\n      } else\n        tmp = *threads;\n      if (*processes < 0)\n        *processes = (int16_t)(cpu_count / (*processes * -1));\n      else if (*processes == 0) {\n        *processes = -1 * *threads;\n        worker_cpu_adjust = 0;\n      }\n      *threads = tmp;\n      tmp = *processes;\n      if (worker_cpu_adjust && (*processes * *threads) >= cpu_count &&\n          cpu_count > 3) {\n        /* leave a resources available for the kernel */\n        --*processes;\n      }\n      if (thread_cpu_adjust && (*threads * tmp) >= cpu_count && cpu_count > 3) {\n        /* leave a resources available for the kernel */\n        --*threads;\n      }\n    }\n  }\n\n  /* make sure we have at least one process and at least one thread */\n  if (*processes <= 0)\n    *processes = 1;\n  if (*threads <= 0)\n    *threads = 1;\n}\n\nstatic fio_lock_i fio_fork_lock = FIO_LOCK_INIT;\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n\n                       Polling State Machine - epoll\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n#if FIO_ENGINE_EPOLL\n#include <sys/epoll.h>\n\n/**\n * Returns a C string detailing the IO engine selected during compilation.\n *\n * Valid values are \"kqueue\", \"epoll\" and \"poll\".\n */\nchar const *fio_engine(void) { return \"epoll\"; }\n\n/* epoll tester, in and out */\nstatic int evio_fd[3] = {-1, -1, -1};\n\nstatic void fio_poll_close(void) {\n  for (int i = 0; i < 3; ++i) {\n    if (evio_fd[i] != -1) {\n      close(evio_fd[i]);\n      evio_fd[i] = -1;\n    }\n  }\n}\n\nstatic void fio_poll_init(void) {\n  fio_poll_close();\n  for (int i = 0; i < 3; ++i) {\n    evio_fd[i] = epoll_create1(EPOLL_CLOEXEC);\n    if (evio_fd[i] == -1)\n      goto error;\n  }\n  for (int i = 1; i < 3; ++i) {\n    struct epoll_event chevent = {\n        .events = (EPOLLOUT | EPOLLIN),\n        .data.fd = evio_fd[i],\n    };\n    if (epoll_ctl(evio_fd[0], EPOLL_CTL_ADD, evio_fd[i], &chevent) == -1)\n      goto error;\n  }\n  return;\nerror:\n  FIO_LOG_FATAL(\"couldn't initialize epoll.\");\n  fio_poll_close();\n  exit(errno);\n  return;\n}\n\nstatic inline int fio_poll_add2(int fd, uint32_t events, int ep_fd) {\n  struct epoll_event chevent;\n  int ret;\n  do {\n    errno = 0;\n    chevent = (struct epoll_event){\n        .events = events,\n        .data.fd = fd,\n    };\n    ret = epoll_ctl(ep_fd, EPOLL_CTL_MOD, fd, &chevent);\n    if (ret == -1 && errno == ENOENT) {\n      errno = 0;\n      chevent = (struct epoll_event){\n          .events = events,\n          .data.fd = fd,\n      };\n      ret = epoll_ctl(ep_fd, EPOLL_CTL_ADD, fd, &chevent);\n    }\n  } while (errno == EINTR);\n\n  return ret;\n}\n\nstatic inline void fio_poll_add_read(intptr_t fd) {\n  fio_poll_add2(fd, (EPOLLIN | EPOLLRDHUP | EPOLLHUP | EPOLLONESHOT),\n                evio_fd[1]);\n  return;\n}\n\nstatic inline void fio_poll_add_write(intptr_t fd) {\n  fio_poll_add2(fd, (EPOLLOUT | EPOLLRDHUP | EPOLLHUP | EPOLLONESHOT),\n                evio_fd[2]);\n  return;\n}\n\nstatic inline void fio_poll_add(intptr_t fd) {\n  if (fio_poll_add2(fd, (EPOLLIN | EPOLLRDHUP | EPOLLHUP | EPOLLONESHOT),\n                    evio_fd[1]) == -1)\n    return;\n  fio_poll_add2(fd, (EPOLLOUT | EPOLLRDHUP | EPOLLHUP | EPOLLONESHOT),\n                evio_fd[2]);\n  return;\n}\n\nFIO_FUNC inline void fio_poll_remove_fd(intptr_t fd) {\n  struct epoll_event chevent = {.events = (EPOLLOUT | EPOLLIN), .data.fd = fd};\n  epoll_ctl(evio_fd[1], EPOLL_CTL_DEL, fd, &chevent);\n  epoll_ctl(evio_fd[2], EPOLL_CTL_DEL, fd, &chevent);\n}\n\nstatic size_t fio_poll(void) {\n  int timeout_millisec = fio_timer_calc_first_interval();\n  struct epoll_event internal[2];\n  struct epoll_event events[FIO_POLL_MAX_EVENTS];\n  int total = 0;\n  /* wait for events and handle them */\n  int internal_count = epoll_wait(evio_fd[0], internal, 2, timeout_millisec);\n  if (internal_count == 0)\n    return internal_count;\n  for (int j = 0; j < internal_count; ++j) {\n    int active_count =\n        epoll_wait(internal[j].data.fd, events, FIO_POLL_MAX_EVENTS, 0);\n    if (active_count > 0) {\n      for (int i = 0; i < active_count; i++) {\n        if (events[i].events & (~(EPOLLIN | EPOLLOUT))) {\n          // errors are hendled as disconnections (on_close)\n          fio_force_close_in_poll(fd2uuid(events[i].data.fd));\n        } else {\n          // no error, then it's an active event(s)\n          if (events[i].events & EPOLLOUT) {\n            fio_defer_push_urgent(deferred_on_ready,\n                                  (void *)fd2uuid(events[i].data.fd), NULL);\n          }\n          if (events[i].events & EPOLLIN)\n            fio_defer_push_task(deferred_on_data,\n                                (void *)fd2uuid(events[i].data.fd), NULL);\n        }\n      } // end for loop\n      total += active_count;\n    }\n  }\n  return total;\n}\n\n#endif\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n\n                       Polling State Machine - kqueue\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n#if FIO_ENGINE_KQUEUE\n#include <sys/event.h>\n\n/**\n * Returns a C string detailing the IO engine selected during compilation.\n *\n * Valid values are \"kqueue\", \"epoll\" and \"poll\".\n */\nchar const *fio_engine(void) { return \"kqueue\"; }\n\nstatic int evio_fd = -1;\n\nstatic void fio_poll_close(void) { close(evio_fd); }\n\nstatic void fio_poll_init(void) {\n  fio_poll_close();\n  evio_fd = kqueue();\n  if (evio_fd == -1) {\n    FIO_LOG_FATAL(\"couldn't open kqueue.\\n\");\n    exit(errno);\n  }\n}\n\nstatic inline void fio_poll_add_read(intptr_t fd) {\n  struct kevent chevent[1];\n  EV_SET(chevent, fd, EVFILT_READ, EV_ADD | EV_ENABLE | EV_CLEAR | EV_ONESHOT,\n         0, 0, ((void *)fd));\n  do {\n    errno = 0;\n    kevent(evio_fd, chevent, 1, NULL, 0, NULL);\n  } while (errno == EINTR);\n  return;\n}\n\nstatic inline void fio_poll_add_write(intptr_t fd) {\n  struct kevent chevent[1];\n  EV_SET(chevent, fd, EVFILT_WRITE, EV_ADD | EV_ENABLE | EV_CLEAR | EV_ONESHOT,\n         0, 0, ((void *)fd));\n  do {\n    errno = 0;\n    kevent(evio_fd, chevent, 1, NULL, 0, NULL);\n  } while (errno == EINTR);\n  return;\n}\n\nstatic inline void fio_poll_add(intptr_t fd) {\n  struct kevent chevent[2];\n  EV_SET(chevent, fd, EVFILT_READ, EV_ADD | EV_ENABLE | EV_CLEAR | EV_ONESHOT,\n         0, 0, ((void *)fd));\n  EV_SET(chevent + 1, fd, EVFILT_WRITE,\n         EV_ADD | EV_ENABLE | EV_CLEAR | EV_ONESHOT, 0, 0, ((void *)fd));\n  do {\n    errno = 0;\n    kevent(evio_fd, chevent, 2, NULL, 0, NULL);\n  } while (errno == EINTR);\n  return;\n}\n\nFIO_FUNC inline void fio_poll_remove_fd(intptr_t fd) {\n  if (evio_fd < 0)\n    return;\n  struct kevent chevent[2];\n  EV_SET(chevent, fd, EVFILT_READ, EV_DELETE, 0, 0, NULL);\n  EV_SET(chevent + 1, fd, EVFILT_WRITE, EV_DELETE, 0, 0, NULL);\n  do {\n    errno = 0;\n    kevent(evio_fd, chevent, 2, NULL, 0, NULL);\n  } while (errno == EINTR);\n}\n\nstatic size_t fio_poll(void) {\n  if (evio_fd < 0)\n    return -1;\n  int timeout_millisec = fio_timer_calc_first_interval();\n  struct kevent events[FIO_POLL_MAX_EVENTS] = {{0}};\n\n  const struct timespec timeout = {\n      .tv_sec = (timeout_millisec / 1000),\n      .tv_nsec = ((timeout_millisec & (~1023UL)) * 1000000)};\n  /* wait for events and handle them */\n  int active_count =\n      kevent(evio_fd, NULL, 0, events, FIO_POLL_MAX_EVENTS, &timeout);\n\n  if (active_count > 0) {\n    for (int i = 0; i < active_count; i++) {\n      // test for event(s) type\n      if (events[i].filter == EVFILT_WRITE) {\n        fio_defer_push_urgent(deferred_on_ready,\n                              ((void *)fd2uuid(events[i].udata)), NULL);\n      } else if (events[i].filter == EVFILT_READ) {\n        fio_defer_push_task(deferred_on_data, (void *)fd2uuid(events[i].udata),\n                            NULL);\n      }\n      if (events[i].flags & (EV_EOF | EV_ERROR)) {\n        fio_force_close_in_poll(fd2uuid(events[i].udata));\n      }\n    }\n  } else if (active_count < 0) {\n    if (errno == EINTR)\n      return 0;\n    return -1;\n  }\n  return active_count;\n}\n\n#endif\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n\n                       Polling State Machine - poll\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n#if FIO_ENGINE_POLL\n\n/**\n * Returns a C string detailing the IO engine selected during compilation.\n *\n * Valid values are \"kqueue\", \"epoll\" and \"poll\".\n */\nchar const *fio_engine(void) { return \"poll\"; }\n\n#define FIO_POLL_READ_EVENTS (POLLPRI | POLLIN)\n#define FIO_POLL_WRITE_EVENTS (POLLOUT)\n\nstatic void fio_poll_close(void) {}\n\nstatic void fio_poll_init(void) {}\n\nstatic inline void fio_poll_remove_fd(int fd) {\n  fio_data->poll[fd].fd = -1;\n  fio_data->poll[fd].events = 0;\n}\n\nstatic inline void fio_poll_add_read(int fd) {\n  fio_data->poll[fd].fd = fd;\n  fio_data->poll[fd].events |= FIO_POLL_READ_EVENTS;\n}\n\nstatic inline void fio_poll_add_write(int fd) {\n  fio_data->poll[fd].fd = fd;\n  fio_data->poll[fd].events |= FIO_POLL_WRITE_EVENTS;\n}\n\nstatic inline void fio_poll_add(int fd) {\n  fio_data->poll[fd].fd = fd;\n  fio_data->poll[fd].events = FIO_POLL_READ_EVENTS | FIO_POLL_WRITE_EVENTS;\n}\n\nstatic inline void fio_poll_remove_read(int fd) {\n  fio_lock(&fio_data->lock);\n  if (fio_data->poll[fd].events & FIO_POLL_WRITE_EVENTS)\n    fio_data->poll[fd].events = FIO_POLL_WRITE_EVENTS;\n  else {\n    fio_poll_remove_fd(fd);\n  }\n  fio_unlock(&fio_data->lock);\n}\n\nstatic inline void fio_poll_remove_write(int fd) {\n  fio_lock(&fio_data->lock);\n  if (fio_data->poll[fd].events & FIO_POLL_READ_EVENTS)\n    fio_data->poll[fd].events = FIO_POLL_READ_EVENTS;\n  else {\n    fio_poll_remove_fd(fd);\n  }\n  fio_unlock(&fio_data->lock);\n}\n\n/** returns non-zero if events were scheduled, 0 if idle */\nstatic size_t fio_poll(void) {\n  /* shrink fd poll range */\n  size_t end = fio_data->capa; // max_protocol_fd might break TLS\n  size_t start = 0;\n  struct pollfd *list = NULL;\n  fio_lock(&fio_data->lock);\n  while (start < end && fio_data->poll[start].fd == -1)\n    ++start;\n  while (start < end && fio_data->poll[end - 1].fd == -1)\n    --end;\n  if (start != end) {\n    /* copy poll list for multi-threaded poll */\n    list = fio_malloc(sizeof(struct pollfd) * end);\n    memcpy(list + start, fio_data->poll + start,\n           (sizeof(struct pollfd)) * (end - start));\n  }\n  fio_unlock(&fio_data->lock);\n\n  int timeout = fio_timer_calc_first_interval();\n  size_t count = 0;\n\n  if (start == end) {\n    fio_throttle_thread((timeout * 1000000UL));\n  } else if (poll(list + start, end - start, timeout) == -1) {\n    goto finish;\n  }\n  for (size_t i = start; i < end; ++i) {\n    if (list[i].revents) {\n      touchfd(i);\n      ++count;\n      if (list[i].revents & FIO_POLL_WRITE_EVENTS) {\n        // FIO_LOG_DEBUG(\"Poll Write %zu => %p\", i, (void *)fd2uuid(i));\n        fio_poll_remove_write(i);\n        fio_defer_push_urgent(deferred_on_ready, (void *)fd2uuid(i), NULL);\n      }\n      if (list[i].revents & FIO_POLL_READ_EVENTS) {\n        // FIO_LOG_DEBUG(\"Poll Read %zu => %p\", i, (void *)fd2uuid(i));\n        fio_poll_remove_read(i);\n        fio_defer_push_task(deferred_on_data, (void *)fd2uuid(i), NULL);\n      }\n      if (list[i].revents & (POLLHUP | POLLERR)) {\n        // FIO_LOG_DEBUG(\"Poll Hangup %zu => %p\", i, (void *)fd2uuid(i));\n        fio_poll_remove_fd(i);\n        fio_force_close_in_poll(fd2uuid(i));\n      }\n      if (list[i].revents & POLLNVAL) {\n        // FIO_LOG_DEBUG(\"Poll Invalid %zu => %p\", i, (void *)fd2uuid(i));\n        fio_poll_remove_fd(i);\n        fio_lock(&fd_data(i).protocol_lock);\n        fio_clear_fd(i, 0);\n        fio_unlock(&fd_data(i).protocol_lock);\n      }\n    }\n  }\nfinish:\n  fio_free(list);\n  return count;\n}\n\n#endif /* FIO_ENGINE_POLL */\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n                         IO Callbacks / Event Handling\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/* *****************************************************************************\nMock Protocol Callbacks and Service Funcions\n***************************************************************************** */\nstatic void mock_on_ev(intptr_t uuid, fio_protocol_s *protocol) {\n  (void)uuid;\n  (void)protocol;\n}\n\nstatic void mock_on_data(intptr_t uuid, fio_protocol_s *protocol) {\n  fio_suspend(uuid);\n  (void)protocol;\n}\n\nstatic uint8_t mock_on_shutdown(intptr_t uuid, fio_protocol_s *protocol) {\n  return 0;\n  (void)protocol;\n  (void)uuid;\n}\n\nstatic uint8_t mock_on_shutdown_eternal(intptr_t uuid,\n                                        fio_protocol_s *protocol) {\n  return 255;\n  (void)protocol;\n  (void)uuid;\n}\n\nstatic void mock_ping(intptr_t uuid, fio_protocol_s *protocol) {\n  (void)protocol;\n  fio_force_close(uuid);\n}\nstatic void mock_ping2(intptr_t uuid, fio_protocol_s *protocol) {\n  (void)protocol;\n  touchfd(fio_uuid2fd(uuid));\n  if (uuid_data(uuid).timeout == 255)\n    return;\n  protocol->ping = mock_ping;\n  uuid_data(uuid).timeout = 8;\n  fio_close(uuid);\n}\n\nFIO_FUNC void mock_ping_eternal(intptr_t uuid, fio_protocol_s *protocol) {\n  (void)protocol;\n  fio_touch(uuid);\n}\n\n/* *****************************************************************************\nDeferred event handlers - these tasks safely forward the events to the Protocol\n***************************************************************************** */\n\nstatic void deferred_on_close(void *uuid_, void *pr_) {\n  fio_protocol_s *pr = pr_;\n  if (pr->rsv)\n    goto postpone;\n  pr->on_close((intptr_t)uuid_, pr);\n  return;\npostpone:\n  fio_defer_push_task(deferred_on_close, uuid_, pr_);\n}\n\nstatic void deferred_on_shutdown(void *arg, void *arg2) {\n  if (!uuid_data(arg).protocol) {\n    return;\n  }\n  fio_protocol_s *pr = protocol_try_lock(fio_uuid2fd(arg), FIO_PR_LOCK_TASK);\n  if (!pr) {\n    if (errno == EBADF)\n      return;\n    goto postpone;\n  }\n  touchfd(fio_uuid2fd(arg));\n  uint8_t r = pr->on_shutdown ? pr->on_shutdown((intptr_t)arg, pr) : 0;\n  if (r) {\n    if (r == 255) {\n      uuid_data(arg).timeout = 0;\n    } else {\n      fio_atomic_add(&fio_data->connection_count, 1);\n      uuid_data(arg).timeout = r;\n    }\n    pr->ping = mock_ping2;\n    protocol_unlock(pr, FIO_PR_LOCK_TASK);\n  } else {\n    fio_atomic_add(&fio_data->connection_count, 1);\n    uuid_data(arg).timeout = 8;\n    pr->ping = mock_ping;\n    protocol_unlock(pr, FIO_PR_LOCK_TASK);\n    fio_close((intptr_t)arg);\n  }\n  return;\npostpone:\n  fio_defer_push_task(deferred_on_shutdown, arg, NULL);\n  (void)arg2;\n}\n\nstatic void deferred_on_ready_usr(void *arg, void *arg2) {\n  errno = 0;\n  fio_protocol_s *pr = protocol_try_lock(fio_uuid2fd(arg), FIO_PR_LOCK_WRITE);\n  if (!pr) {\n    if (errno == EBADF)\n      return;\n    goto postpone;\n  }\n  pr->on_ready((intptr_t)arg, pr);\n  protocol_unlock(pr, FIO_PR_LOCK_WRITE);\n  return;\npostpone:\n  fio_defer_push_task(deferred_on_ready, arg, NULL);\n  (void)arg2;\n}\n\nstatic void deferred_on_ready(void *arg, void *arg2) {\n  errno = 0;\n  if (fio_flush((intptr_t)arg) > 0 || errno == EWOULDBLOCK || errno == EAGAIN) {\n    if (arg2)\n      fio_defer_push_urgent(deferred_on_ready, arg, NULL);\n    else\n      fio_poll_add_write(fio_uuid2fd(arg));\n    return;\n  }\n  if (!uuid_data(arg).protocol) {\n    return;\n  }\n\n  fio_defer_push_task(deferred_on_ready_usr, arg, NULL);\n}\n\nstatic void deferred_on_data(void *uuid, void *arg2) {\n  if (fio_is_closed((intptr_t)uuid)) {\n    return;\n  }\n  if (!uuid_data(uuid).protocol)\n    goto no_protocol;\n  fio_protocol_s *pr = protocol_try_lock(fio_uuid2fd(uuid), FIO_PR_LOCK_TASK);\n  if (!pr) {\n    if (errno == EBADF) {\n      return;\n    }\n    goto postpone;\n  }\n  fio_unlock(&uuid_data(uuid).scheduled);\n  pr->on_data((intptr_t)uuid, pr);\n  protocol_unlock(pr, FIO_PR_LOCK_TASK);\n  if (!fio_trylock(&uuid_data(uuid).scheduled)) {\n    fio_poll_add_read(fio_uuid2fd((intptr_t)uuid));\n  }\n  return;\n\npostpone:\n  if (arg2) {\n    /* the event is being forced, so force rescheduling */\n    fio_defer_push_task(deferred_on_data, (void *)uuid, (void *)1);\n  } else {\n    /* the protocol was locked, so there might not be any need for the event */\n    fio_poll_add_read(fio_uuid2fd((intptr_t)uuid));\n  }\n  return;\n\nno_protocol:\n  /* a missing protocol might still want to invoke the RW hook flush */\n  deferred_on_ready(uuid, arg2);\n  return;\n}\n\nstatic void deferred_ping(void *arg, void *arg2) {\n  if (!uuid_data(arg).protocol ||\n      (uuid_data(arg).timeout &&\n       (uuid_data(arg).timeout + uuid_data(arg).active >\n        (fio_data->last_cycle.tv_sec)))) {\n    return;\n  }\n  fio_protocol_s *pr = protocol_try_lock(fio_uuid2fd(arg), FIO_PR_LOCK_WRITE);\n  if (!pr)\n    goto postpone;\n  pr->ping((intptr_t)arg, pr);\n  protocol_unlock(pr, FIO_PR_LOCK_WRITE);\n  return;\npostpone:\n  fio_defer_push_task(deferred_ping, arg, NULL);\n  (void)arg2;\n}\n\n/* *****************************************************************************\nForcing / Suspending IO events\n***************************************************************************** */\n\nvoid fio_force_event(intptr_t uuid, enum fio_io_event ev) {\n  if (!uuid_is_valid(uuid))\n    return;\n  switch (ev) {\n  case FIO_EVENT_ON_DATA:\n    fio_trylock(&uuid_data(uuid).scheduled);\n    fio_defer_push_task(deferred_on_data, (void *)uuid, (void *)1);\n    break;\n  case FIO_EVENT_ON_TIMEOUT:\n    fio_defer_push_task(deferred_ping, (void *)uuid, NULL);\n    break;\n  case FIO_EVENT_ON_READY:\n    fio_defer_push_urgent(deferred_on_ready, (void *)uuid, NULL);\n    break;\n  }\n}\n\nvoid fio_suspend(intptr_t uuid) {\n  if (uuid_is_valid(uuid))\n    fio_trylock(&uuid_data(uuid).scheduled);\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n                               IO Socket Layer\n\n                     Read / Write / Accept / Connect / etc'\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/* *****************************************************************************\nInternal socket initialization functions\n***************************************************************************** */\n\n/**\nSets a socket to non blocking state.\n\nThis function is called automatically for the new socket, when using\n`fio_accept` or `fio_connect`.\n*/\nint fio_set_non_block(int fd) {\n/* If they have O_NONBLOCK, use the Posix way to do it */\n#if defined(O_NONBLOCK)\n  /* Fixme: O_NONBLOCK is defined but broken on SunOS 4.1.x and AIX 3.2.5. */\n  int flags;\n  if (-1 == (flags = fcntl(fd, F_GETFL, 0)))\n    flags = 0;\n#ifdef O_CLOEXEC\n  return fcntl(fd, F_SETFL, flags | O_NONBLOCK | O_CLOEXEC);\n#else\n  return fcntl(fd, F_SETFL, flags | O_NONBLOCK);\n#endif\n#elif defined(FIONBIO)\n  /* Otherwise, use the old way of doing it */\n  static int flags = 1;\n  return ioctl(fd, FIONBIO, &flags);\n#else\n#error No functions / argumnet macros for non-blocking sockets.\n#endif\n}\n\nstatic void fio_tcp_addr_cpy(int fd, int family, struct sockaddr *addrinfo) {\n  const char *result =\n      inet_ntop(family,\n                family == AF_INET\n                    ? (void *)&(((struct sockaddr_in *)addrinfo)->sin_addr)\n                    : (void *)&(((struct sockaddr_in6 *)addrinfo)->sin6_addr),\n                (char *)fd_data(fd).addr, sizeof(fd_data(fd).addr));\n  if (result) {\n    fd_data(fd).addr_len = strlen((char *)fd_data(fd).addr);\n  } else {\n    fd_data(fd).addr_len = 0;\n    fd_data(fd).addr[0] = 0;\n  }\n}\n\n/**\n * `fio_accept` accepts a new socket connection from a server socket - see the\n * server flag on `fio_socket`.\n *\n * NOTE: this function does NOT attach the socket to the IO reactor -see\n * `fio_attach`.\n */\nintptr_t fio_accept(intptr_t srv_uuid) {\n  struct sockaddr_in6 addrinfo[2]; /* grab a slice of stack (aligned) */\n  socklen_t addrlen = sizeof(addrinfo);\n  int client;\n#ifdef SOCK_NONBLOCK\n  client = accept4(fio_uuid2fd(srv_uuid), (struct sockaddr *)addrinfo, &addrlen,\n                   SOCK_NONBLOCK | SOCK_CLOEXEC);\n  if (client <= 0)\n    return -1;\n#else\n  client = accept(fio_uuid2fd(srv_uuid), (struct sockaddr *)addrinfo, &addrlen);\n  if (client <= 0)\n    return -1;\n  if (fio_set_non_block(client) == -1) {\n    close(client);\n    return -1;\n  }\n#endif\n  // avoid the TCP delay algorithm.\n  {\n    int optval = 1;\n    setsockopt(client, IPPROTO_TCP, TCP_NODELAY, &optval, sizeof(optval));\n  }\n  // handle socket buffers.\n  {\n    int optval = 0;\n    socklen_t size = (socklen_t)sizeof(optval);\n    if (!getsockopt(client, SOL_SOCKET, SO_SNDBUF, &optval, &size) &&\n        optval <= 131072) {\n      optval = 131072;\n      setsockopt(client, SOL_SOCKET, SO_SNDBUF, &optval, sizeof(optval));\n      optval = 131072;\n      setsockopt(client, SOL_SOCKET, SO_RCVBUF, &optval, sizeof(optval));\n    }\n  }\n\n  fio_lock(&fd_data(client).protocol_lock);\n  fio_clear_fd(client, 1);\n  fio_unlock(&fd_data(client).protocol_lock);\n  /* copy peer address */\n  if (((struct sockaddr *)addrinfo)->sa_family == AF_UNIX) {\n    fd_data(client).addr_len = uuid_data(srv_uuid).addr_len;\n    if (uuid_data(srv_uuid).addr_len) {\n      memcpy(fd_data(client).addr, uuid_data(srv_uuid).addr,\n             uuid_data(srv_uuid).addr_len + 1);\n    }\n  } else {\n    fio_tcp_addr_cpy(client, ((struct sockaddr *)addrinfo)->sa_family,\n                     (struct sockaddr *)addrinfo);\n  }\n\n  return fd2uuid(client);\n}\n\n/* Creates a Unix socket - returning it's uuid (or -1) */\nstatic intptr_t fio_unix_socket(const char *address, uint8_t server) {\n  /* Unix socket */\n  struct sockaddr_un addr = {0};\n  size_t addr_len = strlen(address);\n  if (addr_len >= sizeof(addr.sun_path)) {\n    FIO_LOG_ERROR(\"(fio_unix_socket) address too long (%zu bytes > %zu bytes).\",\n                  addr_len, sizeof(addr.sun_path) - 1);\n    errno = ENAMETOOLONG;\n    return -1;\n  }\n  addr.sun_family = AF_UNIX;\n  memcpy(addr.sun_path, address, addr_len + 1); /* copy the NUL byte. */\n#if defined(__APPLE__)\n  addr.sun_len = addr_len;\n#endif\n  // get the file descriptor\n  int fd = socket(AF_UNIX, SOCK_STREAM, 0);\n  if (fd == -1) {\n    return -1;\n  }\n  if (fio_set_non_block(fd) == -1) {\n    close(fd);\n    return -1;\n  }\n  if (server) {\n    unlink(addr.sun_path);\n    if (bind(fd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n      // perror(\"couldn't bind unix socket\");\n      close(fd);\n      return -1;\n    }\n    if (listen(fd, SOMAXCONN) < 0) {\n      // perror(\"couldn't start listening to unix socket\");\n      close(fd);\n      return -1;\n    }\n    /* chmod for foriegn connections */\n    fchmod(fd, 0777);\n  } else {\n    if (connect(fd, (struct sockaddr *)&addr, sizeof(addr)) == -1 &&\n        errno != EINPROGRESS) {\n      close(fd);\n      return -1;\n    }\n  }\n  fio_lock(&fd_data(fd).protocol_lock);\n  fio_clear_fd(fd, 1);\n  fio_unlock(&fd_data(fd).protocol_lock);\n  if (addr_len < sizeof(fd_data(fd).addr)) {\n    memcpy(fd_data(fd).addr, address, addr_len + 1); /* copy the NUL byte. */\n    fd_data(fd).addr_len = addr_len;\n  }\n  return fd2uuid(fd);\n}\n\n/* Creates a TCP/IP socket - returning it's uuid (or -1) */\nstatic intptr_t fio_tcp_socket(const char *address, const char *port,\n                               uint8_t server) {\n  /* TCP/IP socket */\n  // setup the address\n  struct addrinfo hints = {0};\n  struct addrinfo *addrinfo;       // will point to the results\n  memset(&hints, 0, sizeof hints); // make sure the struct is empty\n  hints.ai_family = AF_UNSPEC;     // don't care IPv4 or IPv6\n  hints.ai_socktype = SOCK_STREAM; // TCP stream sockets\n  hints.ai_flags = AI_PASSIVE;     // fill in my IP for me\n  if (getaddrinfo(address, port, &hints, &addrinfo)) {\n    // perror(\"addr err\");\n    return -1;\n  }\n  // get the file descriptor\n  int fd =\n      socket(addrinfo->ai_family, addrinfo->ai_socktype, addrinfo->ai_protocol);\n  if (fd <= 0) {\n    freeaddrinfo(addrinfo);\n    return -1;\n  }\n  // make sure the socket is non-blocking\n  if (fio_set_non_block(fd) < 0) {\n    freeaddrinfo(addrinfo);\n    close(fd);\n    return -1;\n  }\n  if (server) {\n    {\n      // avoid the \"address taken\"\n      int optval = 1;\n      setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\n    }\n    // bind the address to the socket\n    int bound = 0;\n    for (struct addrinfo *i = addrinfo; i != NULL; i = i->ai_next) {\n      if (!bind(fd, i->ai_addr, i->ai_addrlen))\n        bound = 1;\n    }\n    if (!bound) {\n      // perror(\"bind err\");\n      freeaddrinfo(addrinfo);\n      close(fd);\n      return -1;\n    }\n#ifdef TCP_FASTOPEN\n    {\n      // support TCP Fast Open when available\n      int optval = 128;\n      setsockopt(fd, addrinfo->ai_protocol, TCP_FASTOPEN, &optval,\n                 sizeof(optval));\n    }\n#endif\n    if (listen(fd, SOMAXCONN) < 0) {\n      freeaddrinfo(addrinfo);\n      close(fd);\n      return -1;\n    }\n  } else {\n    int one = 1;\n    setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &one, sizeof(one));\n    errno = 0;\n    for (struct addrinfo *i = addrinfo; i; i = i->ai_next) {\n      if (connect(fd, i->ai_addr, i->ai_addrlen) == 0 || errno == EINPROGRESS)\n        goto socket_okay;\n    }\n    freeaddrinfo(addrinfo);\n    close(fd);\n    return -1;\n  }\nsocket_okay:\n  fio_lock(&fd_data(fd).protocol_lock);\n  fio_clear_fd(fd, 1);\n  fio_unlock(&fd_data(fd).protocol_lock);\n  fio_tcp_addr_cpy(fd, addrinfo->ai_family, (void *)addrinfo);\n  freeaddrinfo(addrinfo);\n  return fd2uuid(fd);\n}\n\n/* PUBLIC API: opens a server or client socket */\nintptr_t fio_socket(const char *address, const char *port, uint8_t server) {\n  intptr_t uuid;\n  if (port) {\n    char *pos = (char *)port;\n    int64_t n = fio_atol(&pos);\n    /* make sure port is only numerical */\n    if (*pos) {\n      FIO_LOG_ERROR(\"(fio_socket) port %s is not a number.\", port);\n      errno = EINVAL;\n      return -1;\n    }\n    /* a negative port number will revert to a Unix socket. */\n    if (n <= 0) {\n      if (n < -1)\n        FIO_LOG_WARNING(\"(fio_socket) negative port number %s is ignored.\",\n                        port);\n      port = NULL;\n    }\n  }\n  if (!address && !port) {\n    FIO_LOG_ERROR(\"(fio_socket) both address and port are missing or invalid.\");\n    errno = EINVAL;\n    return -1;\n  }\n  if (!port) {\n    do {\n      errno = 0;\n      uuid = fio_unix_socket(address, server);\n    } while (errno == EINTR);\n  } else {\n    do {\n      errno = 0;\n      uuid = fio_tcp_socket(address, port, server);\n    } while (errno == EINTR);\n  }\n  return uuid;\n}\n\n/* *****************************************************************************\nInternal socket flushing related functions\n***************************************************************************** */\n\n#ifndef BUFFER_FILE_READ_SIZE\n#define BUFFER_FILE_READ_SIZE 49152\n#endif\n\n#if !defined(USE_SENDFILE) && !defined(USE_SENDFILE_LINUX) &&                  \\\n    !defined(USE_SENDFILE_BSD) && !defined(USE_SENDFILE_APPLE)\n#if defined(__linux__) /* linux sendfile works  */\n#define USE_SENDFILE_LINUX 1\n#elif defined(__FreeBSD__) /* FreeBSD sendfile should work - not tested */\n#define USE_SENDFILE_BSD 1\n#elif defined(__APPLE__) /* Is the apple sendfile still broken? */\n#define USE_SENDFILE_APPLE 2\n#else /* sendfile might not be available - always set to 0 */\n#define USE_SENDFILE 0\n#endif\n\n#endif\n\nstatic void fio_sock_perform_close_fd(intptr_t fd) { close(fd); }\n\nstatic inline void fio_sock_packet_rotate_unsafe(uintptr_t fd) {\n  fio_packet_s *packet = fd_data(fd).packet;\n  fd_data(fd).packet = packet->next;\n  fio_atomic_sub(&fd_data(fd).packet_count, 1);\n  if (!packet->next) {\n    fd_data(fd).packet_last = &fd_data(fd).packet;\n    fd_data(fd).packet_count = 0;\n  } else if (&packet->next == fd_data(fd).packet_last) {\n    fd_data(fd).packet_last = &fd_data(fd).packet;\n  }\n  fio_packet_free(packet);\n}\n\nstatic int fio_sock_write_buffer(int fd, fio_packet_s *packet) {\n  int written = fd_data(fd).rw_hooks->write(\n      fd2uuid(fd), fd_data(fd).rw_udata,\n      ((uint8_t *)packet->data.buffer + packet->offset), packet->length);\n  if (written > 0) {\n    packet->length -= written;\n    packet->offset += written;\n    if (!packet->length) {\n      fio_sock_packet_rotate_unsafe(fd);\n    }\n  }\n  return written;\n}\n\nstatic int fio_sock_write_from_fd(int fd, fio_packet_s *packet) {\n  ssize_t asked = 0;\n  ssize_t sent = 0;\n  ssize_t total = 0;\n  char buff[BUFFER_FILE_READ_SIZE];\n  do {\n    packet->offset += sent;\n    packet->length -= sent;\n  retry:\n    asked = pread(packet->data.fd, buff,\n                  ((packet->length < BUFFER_FILE_READ_SIZE)\n                       ? packet->length\n                       : BUFFER_FILE_READ_SIZE),\n                  packet->offset);\n    if (asked <= 0)\n      goto read_error;\n    sent = fd_data(fd).rw_hooks->write(fd2uuid(fd), fd_data(fd).rw_udata, buff,\n                                       asked);\n  } while (sent == asked && packet->length);\n  if (sent >= 0) {\n    packet->offset += sent;\n    packet->length -= sent;\n    total += sent;\n    if (!packet->length) {\n      fio_sock_packet_rotate_unsafe(fd);\n      return 1;\n    }\n  }\n  return total;\n\nread_error:\n  if (sent == 0) {\n    fio_sock_packet_rotate_unsafe(fd);\n    return 1;\n  }\n  if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)\n    goto retry;\n  return -1;\n}\n\n#if USE_SENDFILE_LINUX /* linux sendfile API */\n#include <sys/sendfile.h>\n\nstatic int fio_sock_sendfile_from_fd(int fd, fio_packet_s *packet) {\n  ssize_t sent;\n  sent =\n      sendfile64(fd, packet->data.fd, (off_t *)&packet->offset, packet->length);\n  if (sent < 0)\n    return -1;\n  packet->length -= sent;\n  if (!packet->length)\n    fio_sock_packet_rotate_unsafe(fd);\n  return sent;\n}\n\n#elif USE_SENDFILE_BSD || USE_SENDFILE_APPLE /* FreeBSD / Apple API */\n#include <sys/uio.h>\n\nstatic int fio_sock_sendfile_from_fd(int fd, fio_packet_s *packet) {\n  off_t act_sent = 0;\n  ssize_t ret = 0;\n  while (packet->length) {\n    act_sent = packet->length;\n#if USE_SENDFILE_APPLE\n    ret = sendfile(packet->data.fd, fd, packet->offset, &act_sent, NULL, 0);\n#else\n    ret = sendfile(packet->data.fd, fd, packet->offset, (size_t)act_sent, NULL,\n                   &act_sent, 0);\n#endif\n    if (ret < 0)\n      goto error;\n    packet->length -= act_sent;\n    packet->offset += act_sent;\n  }\n  fio_sock_packet_rotate_unsafe(fd);\n  return act_sent;\nerror:\n  if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR) {\n    packet->length -= act_sent;\n    packet->offset += act_sent;\n  }\n  return -1;\n}\n\n#else\nstatic int (*fio_sock_sendfile_from_fd)(int fd, fio_packet_s *packet) =\n    fio_sock_write_from_fd;\n\n#endif\n\n/* *****************************************************************************\nSocket / Connection Functions\n***************************************************************************** */\n\n/**\n * Returns the information available about the socket's peer address.\n *\n * If no information is available, the struct will be initialized with zero\n * (`addr == NULL`).\n * The information is only available when the socket was accepted using\n * `fio_accept` or opened using `fio_connect`.\n */\n\n/**\n * `fio_read` attempts to read up to count bytes from the socket into the\n * buffer starting at `buffer`.\n *\n * `fio_read`'s return values are wildly different then the native return\n * values and they aim at making far simpler sense.\n *\n * `fio_read` returns the number of bytes read (0 is a valid return value which\n * simply means that no bytes were read from the buffer).\n *\n * On a fatal connection error that leads to the connection being closed (or if\n * the connection is already closed), `fio_read` returns -1.\n *\n * The value 0 is the valid value indicating no data was read.\n *\n * Data might be available in the kernel's buffer while it is not available to\n * be read using `fio_read` (i.e., when using a transport layer, such as TLS).\n */\nssize_t fio_read(intptr_t uuid, void *buffer, size_t count) {\n  if (!uuid_is_valid(uuid) || !uuid_data(uuid).open) {\n    errno = EBADF;\n    return -1;\n  }\n  if (count == 0)\n    return 0;\n  fio_lock(&uuid_data(uuid).sock_lock);\n  ssize_t (*rw_read)(intptr_t, void *, void *, size_t) =\n      uuid_data(uuid).rw_hooks->read;\n  void *udata = uuid_data(uuid).rw_udata;\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  int old_errno = errno;\n  ssize_t ret;\nretry_int:\n  ret = rw_read(uuid, udata, buffer, count);\n  if (ret > 0) {\n    fio_touch(uuid);\n    return ret;\n  }\n  if (ret < 0 && errno == EINTR)\n    goto retry_int;\n  if (ret < 0 &&\n      (errno == EWOULDBLOCK || errno == EAGAIN || errno == ENOTCONN)) {\n    errno = old_errno;\n    return 0;\n  }\n  fio_force_close(uuid);\n  return -1;\n}\n\n/**\n * `fio_write2_fn` is the actual function behind the macro `fio_write2`.\n */\nssize_t fio_write2_fn(intptr_t uuid, fio_write_args_s options) {\n  if (!uuid_is_valid(uuid))\n    goto error;\n\n  /* create packet */\n  fio_packet_s *packet = fio_packet_alloc();\n  *packet = (fio_packet_s){\n      .length = options.length,\n      .offset = options.offset,\n      .data.buffer = (void *)options.data.buffer,\n  };\n  if (options.is_fd) {\n    packet->write_func = (uuid_data(uuid).rw_hooks == &FIO_DEFAULT_RW_HOOKS)\n                             ? fio_sock_sendfile_from_fd\n                             : fio_sock_write_from_fd;\n    packet->dealloc =\n        (options.after.dealloc ? options.after.dealloc\n                               : (void (*)(void *))fio_sock_perform_close_fd);\n  } else {\n    packet->write_func = fio_sock_write_buffer;\n    packet->dealloc = (options.after.dealloc ? options.after.dealloc : free);\n  }\n  /* add packet to outgoing list */\n  uint8_t was_empty = 1;\n  fio_lock(&uuid_data(uuid).sock_lock);\n  if (!uuid_is_valid(uuid)) {\n    goto locked_error;\n  }\n  if (uuid_data(uuid).packet)\n    was_empty = 0;\n  if (options.urgent == 0) {\n    *uuid_data(uuid).packet_last = packet;\n    uuid_data(uuid).packet_last = &packet->next;\n  } else {\n    fio_packet_s **pos = &uuid_data(uuid).packet;\n    if (*pos)\n      pos = &(*pos)->next;\n    packet->next = *pos;\n    *pos = packet;\n    if (!packet->next) {\n      uuid_data(uuid).packet_last = &packet->next;\n    }\n  }\n  fio_atomic_add(&uuid_data(uuid).packet_count, 1);\n  fio_unlock(&uuid_data(uuid).sock_lock);\n\n  if (was_empty) {\n    touchfd(fio_uuid2fd(uuid));\n    deferred_on_ready((void *)uuid, (void *)1);\n  }\n  return 0;\nlocked_error:\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  fio_packet_free(packet);\n  errno = EBADF;\n  return -1;\nerror:\n  if (options.after.dealloc) {\n    options.after.dealloc((void *)options.data.buffer);\n  }\n  errno = EBADF;\n  return -1;\n}\n\n/** A noop function for fio_write2 in cases not deallocation is required. */\nvoid FIO_DEALLOC_NOOP(void *arg) { (void)arg; }\n\n/**\n * Returns the number of `fio_write` calls that are waiting in the socket's\n * queue and haven't been processed.\n */\nsize_t fio_pending(intptr_t uuid) {\n  if (!uuid_is_valid(uuid))\n    return 0;\n  return uuid_data(uuid).packet_count;\n}\n\n/**\n * `fio_close` marks the connection for disconnection once all the data was\n * sent. The actual disconnection will be managed by the `fio_flush` function.\n *\n * `fio_flash` will be automatically scheduled.\n */\nvoid fio_close(intptr_t uuid) {\n  if (!uuid_is_valid(uuid)) {\n    errno = EBADF;\n    return;\n  }\n  if (uuid_data(uuid).packet || uuid_data(uuid).sock_lock) {\n    uuid_data(uuid).close = 1;\n    fio_poll_add_write(fio_uuid2fd(uuid));\n    return;\n  }\n  fio_force_close(uuid);\n}\n\n/**\n * `fio_force_close` closes the connection immediately, without adhering to any\n * protocol restrictions and without sending any remaining data in the\n * connection buffer.\n */\nvoid fio_force_close(intptr_t uuid) {\n  if (!uuid_is_valid(uuid)) {\n    errno = EBADF;\n    return;\n  }\n  // FIO_LOG_DEBUG(\"fio_force_close called for uuid %p\", (void *)uuid);\n  /* make sure the close marker is set */\n  if (!uuid_data(uuid).close)\n    uuid_data(uuid).close = 1;\n  /* clear away any packets in case we want to cut the connection short. */\n  fio_packet_s *packet = NULL;\n  fio_lock(&uuid_data(uuid).sock_lock);\n  packet = uuid_data(uuid).packet;\n  uuid_data(uuid).packet = NULL;\n  uuid_data(uuid).packet_last = &uuid_data(uuid).packet;\n  uuid_data(uuid).sent = 0;\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  while (packet) {\n    fio_packet_s *tmp = packet;\n    packet = packet->next;\n    fio_packet_free(tmp);\n  }\n  /* check for rw-hooks termination packet */\n  if (uuid_data(uuid).open && (uuid_data(uuid).close & 1) &&\n      uuid_data(uuid).rw_hooks->before_close(uuid, uuid_data(uuid).rw_udata)) {\n    uuid_data(uuid).close = 2; /* don't repeat the before_close callback */\n    fio_touch(uuid);\n    fio_poll_add_write(fio_uuid2fd(uuid));\n    return;\n  }\n  fio_lock(&uuid_data(uuid).protocol_lock);\n  fio_clear_fd(fio_uuid2fd(uuid), 0);\n  fio_unlock(&uuid_data(uuid).protocol_lock);\n  close(fio_uuid2fd(uuid));\n#if FIO_ENGINE_POLL\n  fio_poll_remove_fd(fio_uuid2fd(uuid));\n#endif\n  if (fio_data->connection_count)\n    fio_atomic_sub(&fio_data->connection_count, 1);\n}\n\n/**\n * `fio_flush` attempts to write any remaining data in the internal buffer to\n * the underlying file descriptor and closes the underlying file descriptor once\n * if it's marked for closure (and all the data was sent).\n *\n * Return values: 1 will be returned if data remains in the buffer. 0\n * will be returned if the buffer was fully drained. -1 will be returned on an\n * error or when the connection is closed.\n */\nssize_t fio_flush(intptr_t uuid) {\n  if (!uuid_is_valid(uuid))\n    goto invalid;\n  errno = 0;\n  ssize_t flushed = 0;\n  int tmp;\n  /* start critical section */\n  if (fio_trylock(&uuid_data(uuid).sock_lock))\n    goto would_block;\n\n  if (!uuid_data(uuid).packet)\n    goto flush_rw_hook;\n\n  const fio_packet_s *old_packet = uuid_data(uuid).packet;\n  const size_t old_sent = uuid_data(uuid).sent;\n\n  tmp = uuid_data(uuid).packet->write_func(fio_uuid2fd(uuid),\n                                           uuid_data(uuid).packet);\n  if (tmp <= 0) {\n    goto test_errno;\n  }\n\n  if (uuid_data(uuid).packet_count >= 1024 &&\n      uuid_data(uuid).packet == old_packet &&\n      uuid_data(uuid).sent >= old_sent &&\n      (uuid_data(uuid).sent - old_sent) < 32768) {\n    /* Slowloris attack assumed */\n    goto attacked;\n  }\n\n  /* end critical section */\n  fio_unlock(&uuid_data(uuid).sock_lock);\n\n  /* test for fio_close marker */\n  if (!uuid_data(uuid).packet && uuid_data(uuid).close)\n    goto closed;\n\n  /* return state */\n  return uuid_data(uuid).open && uuid_data(uuid).packet != NULL;\n\nwould_block:\n  errno = EWOULDBLOCK;\n  return -1;\n\nclosed:\n  fio_force_close(uuid);\n  return -1;\n\nflush_rw_hook:\n  flushed = uuid_data(uuid).rw_hooks->flush(uuid, uuid_data(uuid).rw_udata);\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  if (!flushed)\n    return 0;\n  if (flushed < 0) {\n    goto test_errno;\n  }\n  touchfd(fio_uuid2fd(uuid));\n  return 1;\n\ntest_errno:\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  switch (errno) {\n  case EWOULDBLOCK: /* fallthrough */\n#if EWOULDBLOCK != EAGAIN\n  case EAGAIN: /* fallthrough */\n#endif\n  case ENOTCONN:      /* fallthrough */\n  case EINPROGRESS:   /* fallthrough */\n  case ENOSPC:        /* fallthrough */\n  case EADDRNOTAVAIL: /* fallthrough */\n  case EINTR:\n    return 1;\n  case EFAULT:\n    FIO_LOG_ERROR(\"fio_flush EFAULT - possible memory address error sent to \"\n                  \"Unix socket.\");\n    /* fallthrough */\n  case EPIPE:  /* fallthrough */\n  case EIO:    /* fallthrough */\n  case EINVAL: /* fallthrough */\n  case EBADF:\n    uuid_data(uuid).close = 1;\n    fio_force_close(uuid);\n    return -1;\n  }\n  fprintf(stderr, \"UUID error: %p (%d)\\n\", (void *)uuid, errno);\n  perror(\"No errno handler\");\n  return 0;\n\ninvalid:\n  /* bad UUID */\n  errno = EBADF;\n  return -1;\n\nattacked:\n  /* don't close, just detach from facil.io and mark uuid as invalid */\n  FIO_LOG_WARNING(\"(facil.io) possible Slowloris attack from %.*s\",\n                  (int)fio_peer_addr(uuid).len, fio_peer_addr(uuid).data);\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  fio_clear_fd(fio_uuid2fd(uuid), 0);\n  return -1;\n}\n\n/** `fio_flush_all` attempts flush all the open connections. */\nsize_t fio_flush_all(void) {\n  if (!fio_data)\n    return 0;\n  size_t count = 0;\n  for (uintptr_t i = 0; i <= fio_data->max_protocol_fd; ++i) {\n    if ((fd_data(i).open || fd_data(i).packet) && fio_flush(fd2uuid(i)) > 0)\n      ++count;\n  }\n  return count;\n}\n\n/* *****************************************************************************\nConnection Read / Write Hooks, for overriding the system calls\n***************************************************************************** */\n\nstatic ssize_t fio_hooks_default_read(intptr_t uuid, void *udata, void *buf,\n                                      size_t count) {\n  return read(fio_uuid2fd(uuid), buf, count);\n  (void)(udata);\n}\nstatic ssize_t fio_hooks_default_write(intptr_t uuid, void *udata,\n                                       const void *buf, size_t count) {\n  return write(fio_uuid2fd(uuid), buf, count);\n  (void)(udata);\n}\n\nstatic ssize_t fio_hooks_default_before_close(intptr_t uuid, void *udata) {\n  return 0;\n  (void)udata;\n  (void)uuid;\n}\n\nstatic ssize_t fio_hooks_default_flush(intptr_t uuid, void *udata) {\n  return 0;\n  (void)(uuid);\n  (void)(udata);\n}\n\nstatic void fio_hooks_default_cleanup(void *udata) { (void)(udata); }\n\nconst fio_rw_hook_s FIO_DEFAULT_RW_HOOKS = {\n    .read = fio_hooks_default_read,\n    .write = fio_hooks_default_write,\n    .flush = fio_hooks_default_flush,\n    .before_close = fio_hooks_default_before_close,\n    .cleanup = fio_hooks_default_cleanup,\n};\n\n/**\n * Replaces an existing read/write hook with another from within a read/write\n * hook callback.\n *\n * Does NOT call any cleanup callbacks.\n *\n * Returns -1 on error, 0 on success.\n */\nint fio_rw_hook_replace_unsafe(intptr_t uuid, fio_rw_hook_s *rw_hooks,\n                               void *udata) {\n  int replaced = -1;\n  uint8_t was_locked;\n  intptr_t fd = fio_uuid2fd(uuid);\n  if (!rw_hooks->read)\n    rw_hooks->read = fio_hooks_default_read;\n  if (!rw_hooks->write)\n    rw_hooks->write = fio_hooks_default_write;\n  if (!rw_hooks->flush)\n    rw_hooks->flush = fio_hooks_default_flush;\n  if (!rw_hooks->before_close)\n    rw_hooks->before_close = fio_hooks_default_before_close;\n  if (!rw_hooks->cleanup)\n    rw_hooks->cleanup = fio_hooks_default_cleanup;\n  /* protect against some fulishness... but not all of it. */\n  was_locked = fio_trylock(&fd_data(fd).sock_lock);\n  if (fd2uuid(fd) == uuid) {\n    fd_data(fd).rw_hooks = rw_hooks;\n    fd_data(fd).rw_udata = udata;\n    replaced = 0;\n  }\n  if (!was_locked)\n    fio_unlock(&fd_data(fd).sock_lock);\n  return replaced;\n}\n\n/** Sets a socket hook state (a pointer to the struct). */\nint fio_rw_hook_set(intptr_t uuid, fio_rw_hook_s *rw_hooks, void *udata) {\n  if (fio_is_closed(uuid))\n    goto invalid_uuid;\n  if (!rw_hooks->read)\n    rw_hooks->read = fio_hooks_default_read;\n  if (!rw_hooks->write)\n    rw_hooks->write = fio_hooks_default_write;\n  if (!rw_hooks->flush)\n    rw_hooks->flush = fio_hooks_default_flush;\n  if (!rw_hooks->before_close)\n    rw_hooks->before_close = fio_hooks_default_before_close;\n  if (!rw_hooks->cleanup)\n    rw_hooks->cleanup = fio_hooks_default_cleanup;\n  intptr_t fd = fio_uuid2fd(uuid);\n  fio_rw_hook_s *old_rw_hooks;\n  void *old_udata;\n  fio_lock(&fd_data(fd).sock_lock);\n  if (fd2uuid(fd) != uuid) {\n    fio_unlock(&fd_data(fd).sock_lock);\n    goto invalid_uuid;\n  }\n  old_rw_hooks = fd_data(fd).rw_hooks;\n  old_udata = fd_data(fd).rw_udata;\n  fd_data(fd).rw_hooks = rw_hooks;\n  fd_data(fd).rw_udata = udata;\n  fio_unlock(&fd_data(fd).sock_lock);\n  if (old_rw_hooks && old_rw_hooks->cleanup)\n    old_rw_hooks->cleanup(old_udata);\n  return 0;\ninvalid_uuid:\n  if (!rw_hooks->cleanup)\n    rw_hooks->cleanup(udata);\n  return -1;\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n                           IO Protocols and Attachment\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/* *****************************************************************************\nSetting the protocol\n***************************************************************************** */\n\n/* managing the protocol pointer array and the `on_close` callback */\nstatic int fio_attach__internal(void *uuid_, void *protocol_) {\n  intptr_t uuid = (intptr_t)uuid_;\n  fio_protocol_s *protocol = (fio_protocol_s *)protocol_;\n  if (protocol) {\n    if (!protocol->on_close) {\n      protocol->on_close = mock_on_ev;\n    }\n    if (!protocol->on_data) {\n      protocol->on_data = mock_on_data;\n    }\n    if (!protocol->on_ready) {\n      protocol->on_ready = mock_on_ev;\n    }\n    if (!protocol->ping) {\n      protocol->ping = mock_ping;\n    }\n    if (!protocol->on_shutdown) {\n      protocol->on_shutdown = mock_on_shutdown;\n    }\n    prt_meta(protocol) = (protocol_metadata_s){.rsv = 0};\n  }\n  if (!uuid_is_valid(uuid))\n    goto invalid_uuid_unlocked;\n  fio_lock(&uuid_data(uuid).protocol_lock);\n  if (!uuid_is_valid(uuid)) {\n    goto invalid_uuid;\n  }\n  fio_protocol_s *old_pr = uuid_data(uuid).protocol;\n  uuid_data(uuid).open = 1;\n  uuid_data(uuid).protocol = protocol;\n  touchfd(fio_uuid2fd(uuid));\n  fio_unlock(&uuid_data(uuid).protocol_lock);\n  if (old_pr) {\n    /* protocol replacement */\n    fio_defer_push_task(deferred_on_close, (void *)uuid, old_pr);\n    if (!protocol) {\n      /* hijacking */\n      fio_poll_remove_fd(fio_uuid2fd(uuid));\n      fio_poll_add_write(fio_uuid2fd(uuid));\n    }\n  } else if (protocol) {\n    /* adding a new uuid to the reactor */\n    fio_poll_add(fio_uuid2fd(uuid));\n  }\n  fio_max_fd_min(fio_uuid2fd(uuid));\n  return 0;\n\ninvalid_uuid:\n  fio_unlock(&uuid_data(uuid).protocol_lock);\ninvalid_uuid_unlocked:\n  // FIO_LOG_DEBUG(\"fio_attach failed for invalid uuid %p\", (void *)uuid);\n  if (protocol)\n    fio_defer_push_task(deferred_on_close, (void *)uuid, protocol);\n  if (uuid == -1)\n    errno = EBADF;\n  else\n    errno = ENOTCONN;\n  return -1;\n}\n\n/**\n * Attaches (or updates) a protocol object to a socket UUID.\n * Returns -1 on error and 0 on success.\n */\nvoid fio_attach(intptr_t uuid, fio_protocol_s *protocol) {\n  fio_attach__internal((void *)uuid, protocol);\n}\n/** Attaches (or updates) a protocol object to a socket UUID.\n * Returns -1 on error and 0 on success.\n */\nvoid fio_attach_fd(int fd, fio_protocol_s *protocol) {\n  fio_attach__internal((void *)fio_fd2uuid(fd), protocol);\n}\n\n/** Sets a timeout for a specific connection (only when running and valid). */\nvoid fio_timeout_set(intptr_t uuid, uint8_t timeout) {\n  if (uuid_is_valid(uuid)) {\n    touchfd(fio_uuid2fd(uuid));\n    uuid_data(uuid).timeout = timeout;\n  } else {\n    FIO_LOG_DEBUG(\"Called fio_timeout_set for invalid uuid %p\", (void *)uuid);\n  }\n}\n/** Gets a timeout for a specific connection. Returns 0 if there's no set\n * timeout or the connection is inactive. */\nuint8_t fio_timeout_get(intptr_t uuid) { return uuid_data(uuid).timeout; }\n\n/* *****************************************************************************\nCore Callbacks for forking / starting up / cleaning up\n***************************************************************************** */\n\ntypedef struct {\n  fio_ls_embd_s node;\n  void (*func)(void *);\n  void *arg;\n} callback_data_s;\n\ntypedef struct {\n  fio_lock_i lock;\n  fio_ls_embd_s callbacks;\n} callback_collection_s;\n\nstatic callback_collection_s callback_collection[FIO_CALL_NEVER + 1];\n\nstatic void fio_state_on_idle_perform(void *task, void *arg) {\n  ((void (*)(void *))(uintptr_t)task)(arg);\n}\n\nstatic inline void fio_state_callback_ensure(callback_collection_s *c) {\n  if (c->callbacks.next)\n    return;\n  c->callbacks = (fio_ls_embd_s)FIO_LS_INIT(c->callbacks);\n}\n\n/** Adds a callback to the list of callbacks to be called for the event. */\nvoid fio_state_callback_add(callback_type_e c_type, void (*func)(void *),\n                            void *arg) {\n  if (c_type == FIO_CALL_ON_INITIALIZE && fio_data) {\n    func(arg);\n    return;\n  }\n  if (!func || (int)c_type < 0 || c_type > FIO_CALL_NEVER)\n    return;\n  fio_lock(&callback_collection[c_type].lock);\n  fio_state_callback_ensure(&callback_collection[c_type]);\n  callback_data_s *tmp = malloc(sizeof(*tmp));\n  FIO_ASSERT_ALLOC(tmp);\n  *tmp = (callback_data_s){.func = func, .arg = arg};\n  fio_ls_embd_push(&callback_collection[c_type].callbacks, &tmp->node);\n  fio_unlock(&callback_collection[c_type].lock);\n}\n\n/** Removes a callback from the list of callbacks to be called for the event. */\nint fio_state_callback_remove(callback_type_e c_type, void (*func)(void *),\n                              void *arg) {\n  if ((int)c_type < 0 || c_type > FIO_CALL_NEVER)\n    return -1;\n  fio_lock(&callback_collection[c_type].lock);\n  FIO_LS_EMBD_FOR(&callback_collection[c_type].callbacks, pos) {\n    callback_data_s *tmp = (FIO_LS_EMBD_OBJ(callback_data_s, node, pos));\n    if (tmp->func == func && tmp->arg == arg) {\n      fio_ls_embd_remove(&tmp->node);\n      free(tmp);\n      goto success;\n    }\n  }\n  fio_unlock(&callback_collection[c_type].lock);\n  return -1;\nsuccess:\n  fio_unlock(&callback_collection[c_type].lock);\n  return -0;\n}\n\n/** Forces all the existing callbacks to run, as if the event occurred. */\nvoid fio_state_callback_force(callback_type_e c_type) {\n  if ((int)c_type < 0 || c_type > FIO_CALL_NEVER)\n    return;\n  /* copy collection */\n  fio_ls_embd_s copy = FIO_LS_INIT(copy);\n  fio_lock(&callback_collection[c_type].lock);\n  fio_state_callback_ensure(&callback_collection[c_type]);\n  switch (c_type) {            /* the difference between `unshift` and `push` */\n  case FIO_CALL_ON_INITIALIZE: /* fallthrough */\n  case FIO_CALL_PRE_START:     /* fallthrough */\n  case FIO_CALL_BEFORE_FORK:   /* fallthrough */\n  case FIO_CALL_AFTER_FORK:    /* fallthrough */\n  case FIO_CALL_IN_CHILD:      /* fallthrough */\n  case FIO_CALL_IN_MASTER:     /* fallthrough */\n  case FIO_CALL_ON_START:      /* fallthrough */\n    FIO_LS_EMBD_FOR(&callback_collection[c_type].callbacks, pos) {\n      callback_data_s *tmp = fio_malloc(sizeof(*tmp));\n      FIO_ASSERT_ALLOC(tmp);\n      *tmp = *(FIO_LS_EMBD_OBJ(callback_data_s, node, pos));\n      fio_ls_embd_unshift(&copy, &tmp->node);\n    }\n    break;\n\n  case FIO_CALL_ON_IDLE: /* idle callbacks are orderless and evented */\n    FIO_LS_EMBD_FOR(&callback_collection[c_type].callbacks, pos) {\n      callback_data_s *tmp = FIO_LS_EMBD_OBJ(callback_data_s, node, pos);\n      fio_defer_push_task(fio_state_on_idle_perform,\n                          (void *)(uintptr_t)tmp->func, tmp->arg);\n    }\n    break;\n\n  case FIO_CALL_ON_SHUTDOWN:     /* fallthrough */\n  case FIO_CALL_ON_FINISH:       /* fallthrough */\n  case FIO_CALL_ON_PARENT_CRUSH: /* fallthrough */\n  case FIO_CALL_ON_CHILD_CRUSH:  /* fallthrough */\n  case FIO_CALL_AT_EXIT:         /* fallthrough */\n  case FIO_CALL_NEVER:           /* fallthrough */\n  default:\n    FIO_LS_EMBD_FOR(&callback_collection[c_type].callbacks, pos) {\n      callback_data_s *tmp = fio_malloc(sizeof(*tmp));\n      FIO_ASSERT_ALLOC(tmp);\n      *tmp = *(FIO_LS_EMBD_OBJ(callback_data_s, node, pos));\n      fio_ls_embd_push(&copy, &tmp->node);\n    }\n    break;\n  }\n\n  fio_unlock(&callback_collection[c_type].lock);\n  /* run callbacks + free data */\n  while (fio_ls_embd_any(&copy)) {\n    callback_data_s *tmp =\n        FIO_LS_EMBD_OBJ(callback_data_s, node, fio_ls_embd_pop(&copy));\n    if (tmp->func) {\n      tmp->func(tmp->arg);\n    }\n    fio_free(tmp);\n  }\n}\n\n/** Clears all the existing callbacks for the event. */\nvoid fio_state_callback_clear(callback_type_e c_type) {\n  if ((int)c_type < 0 || c_type > FIO_CALL_NEVER)\n    return;\n  fio_lock(&callback_collection[c_type].lock);\n  fio_state_callback_ensure(&callback_collection[c_type]);\n  while (fio_ls_embd_any(&callback_collection[c_type].callbacks)) {\n    callback_data_s *tmp = FIO_LS_EMBD_OBJ(\n        callback_data_s, node,\n        fio_ls_embd_shift(&callback_collection[c_type].callbacks));\n    free(tmp);\n  }\n  fio_unlock(&callback_collection[c_type].lock);\n}\n\nvoid fio_state_callback_on_fork(void) {\n  for (size_t i = 0; i < (FIO_CALL_NEVER + 1); ++i) {\n    callback_collection[i].lock = FIO_LOCK_INIT;\n  }\n}\nvoid fio_state_callback_clear_all(void) {\n  for (size_t i = 0; i < (FIO_CALL_NEVER + 1); ++i) {\n    fio_state_callback_clear((callback_type_e)i);\n  }\n}\n\n/* *****************************************************************************\nIO bound tasks\n***************************************************************************** */\n\n// typedef struct {\n//   enum fio_protocol_lock_e type;\n//   void (*task)(intptr_t uuid, fio_protocol_s *, void *udata);\n//   void *udata;\n//   void (*fallback)(intptr_t uuid, void *udata);\n// } fio_defer_iotask_args_s;\n\nstatic void fio_io_task_perform(void *uuid_, void *args_) {\n  fio_defer_iotask_args_s *args = args_;\n  intptr_t uuid = (intptr_t)uuid_;\n  fio_protocol_s *pr = fio_protocol_try_lock(uuid, args->type);\n  if (!pr)\n    goto postpone;\n  args->task(uuid, pr, args->udata);\n  fio_protocol_unlock(pr, args->type);\n  fio_free(args);\n  return;\npostpone:\n  if (errno == EBADF) {\n    if (args->fallback)\n      args->fallback(uuid, args->udata);\n    fio_free(args);\n    return;\n  }\n  fio_defer_push_task(fio_io_task_perform, uuid_, args_);\n}\n/**\n * Schedules a protected connection task. The task will run within the\n * connection's lock.\n *\n * If an error ocuurs or the connection is closed before the task can run, the\n * `fallback` task wil be called instead, allowing for resource cleanup.\n */\nvoid fio_defer_io_task FIO_IGNORE_MACRO(intptr_t uuid,\n                                        fio_defer_iotask_args_s args) {\n  if (!args.task) {\n    if (args.fallback)\n      fio_defer_push_task((void (*)(void *, void *))args.fallback, (void *)uuid,\n                          args.udata);\n    return;\n  }\n  fio_defer_iotask_args_s *cpy = fio_malloc(sizeof(*cpy));\n  FIO_ASSERT_ALLOC(cpy);\n  *cpy = args;\n  fio_defer_push_task(fio_io_task_perform, (void *)uuid, cpy);\n}\n\n/* *****************************************************************************\nInitialize the library\n***************************************************************************** */\n\nstatic void fio_pubsub_on_fork(void);\n\n/* Called within a child process after it starts. */\nstatic void fio_on_fork(void) {\n  fio_timer_lock = FIO_LOCK_INIT;\n  fio_data->lock = FIO_LOCK_INIT;\n  fio_defer_on_fork();\n  fio_malloc_after_fork();\n  fio_poll_init();\n  fio_state_callback_on_fork();\n\n  const size_t limit = fio_data->capa;\n  for (size_t i = 0; i < limit; ++i) {\n    fd_data(i).sock_lock = FIO_LOCK_INIT;\n    fd_data(i).protocol_lock = FIO_LOCK_INIT;\n    if (fd_data(i).protocol) {\n      fd_data(i).protocol->rsv = 0;\n      fio_force_close(fd2uuid(i));\n    }\n  }\n\n  fio_pubsub_on_fork();\n  fio_max_fd_shrink();\n  uint16_t old_active = fio_data->active;\n  fio_data->active = 0;\n  fio_defer_perform();\n  fio_data->active = old_active;\n  fio_data->is_worker = 1;\n}\n\nstatic void fio_mem_destroy(void);\nstatic void __attribute__((destructor)) fio_lib_destroy(void) {\n  uint8_t add_eol = fio_is_master();\n  fio_data->active = 0;\n  fio_on_fork();\n  fio_defer_perform();\n  fio_state_callback_force(FIO_CALL_AT_EXIT);\n  fio_state_callback_clear_all();\n  fio_defer_perform();\n  fio_poll_close();\n  fio_timer_clear_all();\n  fio_free(fio_data);\n  /* memory library destruction must be last */\n  fio_mem_destroy();\n  FIO_LOG_DEBUG(\"(%d) facil.io resources released, exit complete.\",\n                (int)getpid());\n  if (add_eol)\n    fprintf(stderr, \"\\n\"); /* add EOL to logs (logging adds EOL before text */\n}\n\nstatic void fio_mem_init(void);\nstatic void fio_cluster_init(void);\nstatic void fio_pubsub_initialize(void);\nstatic void __attribute__((constructor)) fio_lib_init(void) {\n  /* detect socket capacity - MUST be first...*/\n  ssize_t capa = 0;\n  {\n#ifdef _SC_OPEN_MAX\n    capa = sysconf(_SC_OPEN_MAX);\n#elif defined(FOPEN_MAX)\n    capa = FOPEN_MAX;\n#endif\n    // try to maximize limits - collect max and set to max\n    struct rlimit rlim = {.rlim_max = 0};\n    if (getrlimit(RLIMIT_NOFILE, &rlim) == -1) {\n      FIO_LOG_WARNING(\"`getrlimit` failed in `fio_lib_init`.\");\n      perror(\"\\terrno:\");\n    } else {\n      rlim_t original = rlim.rlim_cur;\n      rlim.rlim_cur = rlim.rlim_max;\n      if (rlim.rlim_cur > FIO_MAX_SOCK_CAPACITY) {\n        rlim.rlim_cur = rlim.rlim_max = FIO_MAX_SOCK_CAPACITY;\n      }\n      while (setrlimit(RLIMIT_NOFILE, &rlim) == -1 && rlim.rlim_cur > original)\n        --rlim.rlim_cur;\n      getrlimit(RLIMIT_NOFILE, &rlim);\n      capa = rlim.rlim_cur;\n      if (capa > 1024) /* leave a slice of room */\n        capa -= 16;\n    }\n    /* initialize memory allocator */\n    fio_mem_init();\n    /* initialize polling engine */\n    fio_poll_init();\n    /* initialize the cluster engine */\n    fio_pubsub_initialize();\n#if DEBUG\n#if FIO_ENGINE_POLL\n    FIO_LOG_INFO(\"facil.io \" FIO_VERSION_STRING \" capacity initialization:\\n\"\n                 \"*    Meximum open files %zu out of %zu\\n\"\n                 \"*    Allocating %zu bytes for state handling.\\n\"\n                 \"*    %zu bytes per connection + %zu for state handling.\",\n                 capa, (size_t)rlim.rlim_max,\n                 (sizeof(*fio_data) + (capa * (sizeof(*fio_data->poll))) +\n                  (capa * (sizeof(*fio_data->info)))),\n                 (sizeof(*fio_data->poll) + sizeof(*fio_data->info)),\n                 sizeof(*fio_data));\n#else\n    FIO_LOG_INFO(\"facil.io \" FIO_VERSION_STRING \" capacity initialization:\\n\"\n                 \"*    Meximum open files %zu out of %zu\\n\"\n                 \"*    Allocating %zu bytes for state handling.\\n\"\n                 \"*    %zu bytes per connection + %zu for state handling.\",\n                 capa, (size_t)rlim.rlim_max,\n                 (sizeof(*fio_data) + (capa * (sizeof(*fio_data->info)))),\n                 (sizeof(*fio_data->info)), sizeof(*fio_data));\n#endif\n#endif\n  }\n\n#if FIO_ENGINE_POLL\n  /* allocate and initialize main data structures by detected capacity */\n  fio_data = fio_mmap(sizeof(*fio_data) + (capa * (sizeof(*fio_data->poll))) +\n                      (capa * (sizeof(*fio_data->info))));\n  FIO_ASSERT_ALLOC(fio_data);\n  fio_data->capa = capa;\n  fio_data->poll =\n      (void *)((uintptr_t)(fio_data + 1) + (sizeof(fio_data->info[0]) * capa));\n#else\n  /* allocate and initialize main data structures by detected capacity */\n  fio_data = fio_mmap(sizeof(*fio_data) + (capa * (sizeof(*fio_data->info))));\n  FIO_ASSERT_ALLOC(fio_data);\n  fio_data->capa = capa;\n#endif\n  fio_data->parent = getpid();\n  fio_data->connection_count = 0;\n  fio_mark_time();\n\n  for (ssize_t i = 0; i < capa; ++i) {\n    fio_clear_fd(i, 0);\n#if FIO_ENGINE_POLL\n    fio_data->poll[i].fd = -1;\n#endif\n  }\n\n  /* call initialization callbacks */\n  fio_state_callback_force(FIO_CALL_ON_INITIALIZE);\n  fio_state_callback_clear(FIO_CALL_ON_INITIALIZE);\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n                             Running the IO Reactor\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\nstatic void fio_cluster_signal_children(void);\n\nstatic void fio_review_timeout(void *arg, void *ignr) {\n  // TODO: Fix review for connections with no protocol?\n  (void)ignr;\n  fio_protocol_s *tmp;\n  time_t review = fio_data->last_cycle.tv_sec;\n  intptr_t fd = (intptr_t)arg;\n\n  uint16_t timeout = fd_data(fd).timeout;\n  if (!timeout)\n    timeout = 300; /* enforced timout settings */\n  if (!fd_data(fd).protocol || (fd_data(fd).active + timeout >= review))\n    goto finish;\n  tmp = protocol_try_lock(fd, FIO_PR_LOCK_STATE);\n  if (!tmp) {\n    if (errno == EBADF)\n      goto finish;\n    goto reschedule;\n  }\n  if (prt_meta(tmp).locks[FIO_PR_LOCK_TASK] ||\n      prt_meta(tmp).locks[FIO_PR_LOCK_WRITE])\n    goto unlock;\n  fio_defer_push_task(deferred_ping, (void *)fio_fd2uuid((int)fd), NULL);\nunlock:\n  protocol_unlock(tmp, FIO_PR_LOCK_STATE);\nfinish:\n  do {\n    fd++;\n  } while (!fd_data(fd).protocol && (fd <= fio_data->max_protocol_fd));\n\n  if (fio_data->max_protocol_fd < fd) {\n    fio_data->need_review = 1;\n    return;\n  }\nreschedule:\n  fio_defer_push_task(fio_review_timeout, (void *)fd, NULL);\n}\n\n/* reactor pattern cycling - common actions */\nstatic void fio_cycle_schedule_events(void) {\n  static int idle = 0;\n  static time_t last_to_review = 0;\n  fio_mark_time();\n  fio_timer_schedule();\n  fio_max_fd_shrink();\n  if (fio_signal_children_flag) {\n    /* hot restart support */\n    fio_signal_children_flag = 0;\n    fio_cluster_signal_children();\n  }\n  int events = fio_poll();\n  if (events < 0) {\n    return;\n  }\n  if (events > 0) {\n    idle = 1;\n  } else {\n    /* events == 0 */\n    if (idle) {\n      fio_state_callback_force(FIO_CALL_ON_IDLE);\n      idle = 0;\n    }\n  }\n  if (fio_data->need_review && fio_data->last_cycle.tv_sec != last_to_review) {\n    last_to_review = fio_data->last_cycle.tv_sec;\n    fio_data->need_review = 0;\n    fio_defer_push_task(fio_review_timeout, (void *)0, NULL);\n  }\n}\n\n/* reactor pattern cycling during cleanup */\nstatic void fio_cycle_unwind(void *ignr, void *ignr2) {\n  if (fio_data->connection_count) {\n    fio_cycle_schedule_events();\n    fio_defer_push_task(fio_cycle_unwind, ignr, ignr2);\n    return;\n  }\n  fio_stop();\n  return;\n}\n\n/* reactor pattern cycling */\nstatic void fio_cycle(void *ignr, void *ignr2) {\n  fio_cycle_schedule_events();\n  if (fio_data->active) {\n    fio_defer_push_task(fio_cycle, ignr, ignr2);\n    return;\n  }\n  return;\n}\n\n/* TODO: fixme */\nstatic void fio_worker_startup(void) {\n  /* Call the on_start callbacks for worker processes. */\n  if (fio_data->workers == 1 || fio_data->is_worker) {\n    fio_state_callback_force(FIO_CALL_ON_START);\n    fio_state_callback_clear(FIO_CALL_ON_START);\n  }\n\n  if (fio_data->workers == 1) {\n    /* Single Process - the root is also a worker */\n    fio_data->is_worker = 1;\n  } else if (fio_data->is_worker) {\n    /* Worker Process */\n    FIO_LOG_INFO(\"%d is running.\", (int)getpid());\n  } else {\n    /* Root Process should run in single thread mode */\n    fio_data->threads = 1;\n  }\n\n  /* require timeout review */\n  fio_data->need_review = 1;\n\n  /* the cycle task will loop by re-scheduling until it's time to finish */\n  fio_defer_push_task(fio_cycle, NULL, NULL);\n\n  /* A single thread doesn't need a pool. */\n  if (fio_data->threads > 1) {\n    fio_defer_thread_pool_join(fio_defer_thread_pool_new(fio_data->threads));\n  } else {\n    fio_defer_perform();\n  }\n}\n\n/* performs all clean-up / shutdown requirements except for the exit sequence */\nstatic void fio_worker_cleanup(void) {\n  /* switch to winding down */\n  if (fio_data->is_worker)\n    FIO_LOG_INFO(\"(%d) detected exit signal.\", (int)getpid());\n  else\n    FIO_LOG_INFO(\"Server Detected exit signal.\");\n  fio_state_callback_force(FIO_CALL_ON_SHUTDOWN);\n  for (size_t i = 0; i <= fio_data->max_protocol_fd; ++i) {\n    if (fd_data(i).protocol) {\n      fio_defer_push_task(deferred_on_shutdown, (void *)fd2uuid(i), NULL);\n    }\n  }\n  fio_defer_push_task(fio_cycle_unwind, NULL, NULL);\n  fio_defer_perform();\n  for (size_t i = 0; i <= fio_data->max_protocol_fd; ++i) {\n    if (fd_data(i).protocol || fd_data(i).open) {\n      fio_force_close(fd2uuid(i));\n    }\n  }\n  fio_defer_perform();\n  fio_state_callback_force(FIO_CALL_ON_FINISH);\n  fio_defer_perform();\n  if (!fio_data->is_worker) {\n    fio_cluster_signal_children();\n    while (wait(NULL) != -1)\n      ;\n  }\n  fio_defer_perform();\n  fio_signal_handler_reset();\n  if (fio_data->parent == getpid()) {\n    FIO_LOG_INFO(\"   ---  Shutdown Complete  ---\\n\");\n  } else {\n    FIO_LOG_INFO(\"(%d) cleanup complete.\", (int)getpid());\n  }\n}\n\nstatic void fio_sentinel_task(void *arg1, void *arg2);\nstatic void *fio_sentinel_worker_thread(void *arg) {\n  errno = 0;\n  pid_t child = fio_fork();\n  /* release fork lock. */\n  fio_unlock(&fio_fork_lock);\n  if (child == -1) {\n    FIO_LOG_FATAL(\"couldn't spawn worker.\");\n    perror(\"\\n           errno\");\n    kill(fio_parent_pid(), SIGINT);\n    fio_stop();\n    return NULL;\n  } else if (child) {\n    int status;\n    waitpid(child, &status, 0);\n#if DEBUG\n    if (fio_data->active) { /* !WIFEXITED(status) || WEXITSTATUS(status) */\n      if (!WIFEXITED(status) || WEXITSTATUS(status)) {\n        FIO_LOG_FATAL(\"Child worker (%d) crashed. Stopping services.\", child);\n        fio_state_callback_force(FIO_CALL_ON_CHILD_CRUSH);\n      } else {\n        FIO_LOG_FATAL(\"Child worker (%d) shutdown. Stopping services.\", child);\n      }\n      kill(0, SIGINT);\n    }\n#else\n    if (fio_data->active) {\n      /* don't call any functions while forking. */\n      fio_lock(&fio_fork_lock);\n      if (!WIFEXITED(status) || WEXITSTATUS(status)) {\n        FIO_LOG_ERROR(\"Child worker (%d) crashed. Respawning worker.\",\n                      (int)child);\n        fio_state_callback_force(FIO_CALL_ON_CHILD_CRUSH);\n      } else {\n        FIO_LOG_WARNING(\"Child worker (%d) shutdown. Respawning worker.\",\n                        (int)child);\n      }\n      fio_defer_push_task(fio_sentinel_task, NULL, NULL);\n      fio_unlock(&fio_fork_lock);\n    }\n#endif\n  } else {\n    fio_on_fork();\n    fio_state_callback_force(FIO_CALL_AFTER_FORK);\n    fio_state_callback_force(FIO_CALL_IN_CHILD);\n    fio_worker_startup();\n    fio_worker_cleanup();\n    exit(0);\n  }\n  return NULL;\n  (void)arg;\n}\n\nstatic void fio_sentinel_task(void *arg1, void *arg2) {\n  if (!fio_data->active)\n    return;\n  fio_state_callback_force(FIO_CALL_BEFORE_FORK);\n  fio_lock(&fio_fork_lock); /* will wait for worker thread to release lock. */\n  void *thrd =\n      fio_thread_new(fio_sentinel_worker_thread, (void *)&fio_fork_lock);\n  fio_thread_free(thrd);\n  fio_lock(&fio_fork_lock);   /* will wait for worker thread to release lock. */\n  fio_unlock(&fio_fork_lock); /* release lock for next fork. */\n  fio_state_callback_force(FIO_CALL_AFTER_FORK);\n  fio_state_callback_force(FIO_CALL_IN_MASTER);\n  (void)arg1;\n  (void)arg2;\n}\n\nFIO_FUNC void fio_start_(void) {} /* marker for SublimeText3 jump feature */\n\n/**\n * Starts the facil.io event loop. This function will return after facil.io is\n * done (after shutdown).\n *\n * See the `struct fio_start_args` details for any possible named arguments.\n *\n * This method blocks the current thread until the server is stopped (when a\n * SIGINT/SIGTERM is received).\n */\nvoid fio_start FIO_IGNORE_MACRO(struct fio_start_args args) {\n  fio_expected_concurrency(&args.threads, &args.workers);\n  fio_signal_handler_setup();\n\n  fio_data->workers = (uint16_t)args.workers;\n  fio_data->threads = (uint16_t)args.threads;\n  fio_data->active = 1;\n  fio_data->is_worker = 0;\n\n  fio_state_callback_force(FIO_CALL_PRE_START);\n\n  FIO_LOG_INFO(\n      \"Server is running %u %s X %u %s with facil.io \" FIO_VERSION_STRING\n      \" (%s)\\n\"\n      \"* Detected capacity: %d open file limit\\n\"\n      \"* Root pid: %d\\n\"\n      \"* Press ^C to stop\\n\",\n      fio_data->workers, fio_data->workers > 1 ? \"workers\" : \"worker\",\n      fio_data->threads, fio_data->threads > 1 ? \"threads\" : \"thread\",\n      fio_engine(), fio_data->capa, (int)fio_data->parent);\n\n  if (args.workers > 1) {\n    for (int i = 0; i < args.workers && fio_data->active; ++i) {\n      fio_sentinel_task(NULL, NULL);\n    }\n  }\n  fio_worker_startup();\n  fio_worker_cleanup();\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                       Converting Numbers to Strings (and back)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/* *****************************************************************************\nStrings to Numbers\n***************************************************************************** */\n\nFIO_FUNC inline size_t fio_atol_skip_zero(char **pstr) {\n  char *const start = *pstr;\n  while (**pstr == '0') {\n    ++(*pstr);\n  }\n  return (size_t)(*pstr - *start);\n}\n\n/* consumes any digits in the string (base 2-10), returning their value */\nFIO_FUNC inline uint64_t fio_atol_consume(char **pstr, uint8_t base) {\n  uint64_t result = 0;\n  const uint64_t limit = UINT64_MAX - (base * base);\n  while (**pstr >= '0' && **pstr < ('0' + base) && result <= (limit)) {\n    result = (result * base) + (**pstr - '0');\n    ++(*pstr);\n  }\n  return result;\n}\n\n/* returns true if there's data to be skipped */\nFIO_FUNC inline uint8_t fio_atol_skip_test(char **pstr, uint8_t base) {\n  return (**pstr >= '0' && **pstr < ('0' + base));\n}\n\n/* consumes any digits in the string (base 2-10), returning the count skipped */\nFIO_FUNC inline uint64_t fio_atol_skip(char **pstr, uint8_t base) {\n  uint64_t result = 0;\n  while (fio_atol_skip_test(pstr, base)) {\n    ++result;\n    ++(*pstr);\n  }\n  return result;\n}\n\n/* consumes any hex data in the string, returning their value */\nFIO_FUNC inline uint64_t fio_atol_consume_hex(char **pstr) {\n  uint64_t result = 0;\n  const uint64_t limit = UINT64_MAX - (16 * 16);\n  for (; result <= limit;) {\n    uint8_t tmp;\n    if (**pstr >= '0' && **pstr <= '9')\n      tmp = **pstr - '0';\n    else if (**pstr >= 'A' && **pstr <= 'F')\n      tmp = **pstr - ('A' - 10);\n    else if (**pstr >= 'a' && **pstr <= 'f')\n      tmp = **pstr - ('a' - 10);\n    else\n      return result;\n    result = (result << 4) | tmp;\n    ++(*pstr);\n  }\n  return result;\n}\n\n/* returns true if there's data to be skipped */\nFIO_FUNC inline uint8_t fio_atol_skip_hex_test(char **pstr) {\n  return (**pstr >= '0' && **pstr <= '9') || (**pstr >= 'A' && **pstr <= 'F') ||\n         (**pstr >= 'a' && **pstr <= 'f');\n}\n\n/* consumes any digits in the string (base 2-10), returning the count skipped */\nFIO_FUNC inline uint64_t fio_atol_skip_hex(char **pstr) {\n  uint64_t result = 0;\n  while (fio_atol_skip_hex_test(pstr)) {\n    ++result;\n    ++(*pstr);\n  }\n  return result;\n}\n\n/* caches a up to 8*8 */\n// static inline fio_atol_pow_10_cache(size_t ex) {}\n\n/**\n * A helper function that converts between String data to a signed int64_t.\n *\n * Numbers are assumed to be in base 10. Octal (`0###`), Hex (`0x##`/`x##`) and\n * binary (`0b##`/ `b##`) are recognized as well. For binary Most Significant\n * Bit must come first.\n *\n * The most significant difference between this function and `strtol` (aside of\n * API design), is the added support for binary representations.\n */\nint64_t fio_atol(char **pstr) {\n  /* No binary representation in strtol */\n  char *str = *pstr;\n  uint64_t result = 0;\n  uint8_t invert = 0;\n  while (isspace(*str))\n    ++(str);\n  if (str[0] == '-') {\n    invert ^= 1;\n    ++str;\n  } else if (*str == '+') {\n    ++(str);\n  }\n\n  if (str[0] == 'B' || str[0] == 'b' ||\n      (str[0] == '0' && (str[1] == 'b' || str[1] == 'B'))) {\n    /* base 2 */\n    if (str[0] == '0')\n      str++;\n    str++;\n    fio_atol_skip_zero(&str);\n    while (str[0] == '0' || str[0] == '1') {\n      result = (result << 1) | (str[0] - '0');\n      str++;\n    }\n    goto sign; /* no overlow protection, since sign might be embedded */\n\n  } else if (str[0] == 'x' || str[0] == 'X' ||\n             (str[0] == '0' && (str[1] == 'x' || str[1] == 'X'))) {\n    /* base 16 */\n    if (str[0] == '0')\n      str++;\n    str++;\n    fio_atol_skip_zero(&str);\n    result = fio_atol_consume_hex(&str);\n    if (fio_atol_skip_hex_test(&str)) /* too large for a number */\n      return 0;\n    goto sign; /* no overlow protection, since sign might be embedded */\n  } else if (str[0] == '0') {\n    fio_atol_skip_zero(&str);\n    /* base 8 */\n    result = fio_atol_consume(&str, 8);\n    if (fio_atol_skip_test(&str, 8)) /* too large for a number */\n      return 0;\n  } else {\n    /* base 10 */\n    result = fio_atol_consume(&str, 10);\n    if (fio_atol_skip_test(&str, 10)) /* too large for a number */\n      return 0;\n  }\n  if (result & ((uint64_t)1 << 63))\n    result = INT64_MAX; /* signed overflow protection */\nsign:\n  if (invert)\n    result = 0 - result;\n  *pstr = str;\n  return (int64_t)result;\n}\n\n/** A helper function that converts between String data to a signed double. */\ndouble fio_atof(char **pstr) { return strtold(*pstr, pstr); }\n\n/* *****************************************************************************\nNumbers to Strings\n***************************************************************************** */\n\n/**\n * A helper function that writes a signed int64_t to a string.\n *\n * No overflow guard is provided, make sure there's at least 68 bytes\n * available (for base 2).\n *\n * Offers special support for base 2 (binary), base 8 (octal), base 10 and base\n * 16 (hex). An unsupported base will silently default to base 10. Prefixes\n * are automatically added (i.e., \"0x\" for hex and \"0b\" for base 2).\n *\n * Returns the number of bytes actually written (excluding the NUL\n * terminator).\n */\nsize_t fio_ltoa(char *dest, int64_t num, uint8_t base) {\n  const char notation[] = {'0', '1', '2', '3', '4', '5', '6', '7',\n                           '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n\n  size_t len = 0;\n  char buf[48]; /* we only need up to 20 for base 10, but base 3 needs 41... */\n\n  if (!num)\n    goto zero;\n\n  switch (base) {\n  case 1: /* fallthrough */\n  case 2:\n    /* Base 2 */\n    {\n      uint64_t n = num; /* avoid bit shifting inconsistencies with signed bit */\n      uint8_t i = 0;    /* counting bits */\n      dest[len++] = '0';\n      dest[len++] = 'b';\n\n      while ((i < 64) && (n & 0x8000000000000000) == 0) {\n        n = n << 1;\n        i++;\n      }\n      /* make sure the Binary representation doesn't appear signed. */\n      if (i) {\n        dest[len++] = '0';\n      }\n      /* write to dest. */\n      while (i < 64) {\n        dest[len++] = ((n & 0x8000000000000000) ? '1' : '0');\n        n = n << 1;\n        i++;\n      }\n      dest[len] = 0;\n      return len;\n    }\n  case 8:\n    /* Base 8 */\n    {\n      uint64_t l = 0;\n      if (num < 0) {\n        dest[len++] = '-';\n        num = 0 - num;\n      }\n      dest[len++] = '0';\n\n      while (num) {\n        buf[l++] = '0' + (num & 7);\n        num = num >> 3;\n      }\n      while (l) {\n        --l;\n        dest[len++] = buf[l];\n      }\n      dest[len] = 0;\n      return len;\n    }\n\n  case 16:\n    /* Base 16 */\n    {\n      uint64_t n = num; /* avoid bit shifting inconsistencies with signed bit */\n      uint8_t i = 0;    /* counting bits */\n      dest[len++] = '0';\n      dest[len++] = 'x';\n      while (i < 8 && (n & 0xFF00000000000000) == 0) {\n        n = n << 8;\n        i++;\n      }\n      /* make sure the Hex representation doesn't appear misleadingly signed. */\n      if (i && (n & 0x8000000000000000)) {\n        dest[len++] = '0';\n        dest[len++] = '0';\n      }\n      /* write the damn thing, high to low */\n      while (i < 8) {\n        uint8_t tmp = (n & 0xF000000000000000) >> 60;\n        dest[len++] = notation[tmp];\n        tmp = (n & 0x0F00000000000000) >> 56;\n        dest[len++] = notation[tmp];\n        i++;\n        n = n << 8;\n      }\n      dest[len] = 0;\n      return len;\n    }\n  case 3: /* fallthrough */\n  case 4: /* fallthrough */\n  case 5: /* fallthrough */\n  case 6: /* fallthrough */\n  case 7: /* fallthrough */\n  case 9: /* fallthrough */\n    /* rare bases */\n    if (num < 0) {\n      dest[len++] = '-';\n      num = 0 - num;\n    }\n    uint64_t l = 0;\n    while (num) {\n      uint64_t t = num / base;\n      buf[l++] = '0' + (num - (t * base));\n      num = t;\n    }\n    while (l) {\n      --l;\n      dest[len++] = buf[l];\n    }\n    dest[len] = 0;\n    return len;\n\n  default:\n    break;\n  }\n  /* Base 10, the default base */\n\n  if (num < 0) {\n    dest[len++] = '-';\n    num = 0 - num;\n  }\n  uint64_t l = 0;\n  while (num) {\n    uint64_t t = num / 10;\n    buf[l++] = '0' + (num - (t * 10));\n    num = t;\n  }\n  while (l) {\n    --l;\n    dest[len++] = buf[l];\n  }\n  dest[len] = 0;\n  return len;\n\nzero:\n  switch (base) {\n  case 1:\n  case 2:\n    dest[len++] = '0';\n    dest[len++] = 'b';\n    break;\n  case 8:\n    dest[len++] = '0';\n    break;\n  case 16:\n    dest[len++] = '0';\n    dest[len++] = 'x';\n    dest[len++] = '0';\n    break;\n  }\n  dest[len++] = '0';\n  dest[len] = 0;\n  return len;\n}\n\n/**\n * A helper function that converts between a double to a string.\n *\n * No overflow guard is provided, make sure there's at least 130 bytes\n * available (for base 2).\n *\n * Supports base 2, base 10 and base 16. An unsupported base will silently\n * default to base 10. Prefixes aren't added (i.e., no \"0x\" or \"0b\" at the\n * beginning of the string).\n *\n * Returns the number of bytes actually written (excluding the NUL\n * terminator).\n */\nsize_t fio_ftoa(char *dest, double num, uint8_t base) {\n  if (base == 2 || base == 16) {\n    /* handle the binary / Hex representation the same as if it were an\n     * int64_t\n     */\n    int64_t *i = (void *)&num;\n    return fio_ltoa(dest, *i, base);\n  }\n\n  size_t written = sprintf(dest, \"%g\", num);\n  uint8_t need_zero = 1;\n  char *start = dest;\n  while (*start) {\n    if (*start == ',') // locale issues?\n      *start = '.';\n    if (*start == '.' || *start == 'e') {\n      need_zero = 0;\n      break;\n    }\n    start++;\n  }\n  if (need_zero) {\n    dest[written++] = '.';\n    dest[written++] = '0';\n  }\n  return written;\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n                       SSL/TLS Weak Symbols for TLS Support\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/**\n * Returns the number of registered ALPN protocol names.\n *\n * This could be used when deciding if protocol selection should be delegated to\n * the ALPN mechanism, or whether a protocol should be immediately assigned.\n *\n * If no ALPN protocols are registered, zero (0) is returned.\n */\nuintptr_t FIO_TLS_WEAK fio_tls_alpn_count(void *tls) {\n  return 0;\n  (void)tls;\n}\n\n/**\n * Establishes an SSL/TLS connection as an SSL/TLS Server, using the specified\n * context / settings object.\n *\n * The `uuid` should be a socket UUID that is already connected to a peer (i.e.,\n * the result of `fio_accept`).\n *\n * The `udata` is an opaque user data pointer that is passed along to the\n * protocol selected (if any protocols were added using `fio_tls_alpn_add`).\n */\nvoid FIO_TLS_WEAK fio_tls_accept(intptr_t uuid, void *tls, void *udata) {\n  FIO_LOG_FATAL(\"No supported SSL/TLS library available.\");\n  exit(-1);\n  return;\n  (void)uuid;\n  (void)tls;\n  (void)udata;\n}\n\n/**\n * Establishes an SSL/TLS connection as an SSL/TLS Client, using the specified\n * context / settings object.\n *\n * The `uuid` should be a socket UUID that is already connected to a peer (i.e.,\n * one received by a `fio_connect` specified callback `on_connect`).\n *\n * The `udata` is an opaque user data pointer that is passed along to the\n * protocol selected (if any protocols were added using `fio_tls_alpn_add`).\n */\nvoid FIO_TLS_WEAK fio_tls_connect(intptr_t uuid, void *tls, void *udata) {\n  FIO_LOG_FATAL(\"No supported SSL/TLS library available.\");\n  exit(-1);\n  return;\n  (void)uuid;\n  (void)tls;\n  (void)udata;\n}\n\n/**\n * Increase the reference count for the TLS object.\n *\n * Decrease with `fio_tls_destroy`.\n */\nvoid FIO_TLS_WEAK fio_tls_dup(void *tls) {\n  FIO_LOG_FATAL(\"No supported SSL/TLS library available.\");\n  exit(-1);\n  return;\n  (void)tls;\n}\n\n/**\n * Destroys the SSL/TLS context / settings object and frees any related\n * resources / memory.\n */\nvoid FIO_TLS_WEAK fio_tls_destroy(void *tls) {\n  FIO_LOG_FATAL(\"No supported SSL/TLS library available.\");\n  exit(-1);\n  return;\n  (void)tls;\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                       Listening to Incoming Connections\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/* *****************************************************************************\nThe listening protocol (use the facil.io API to make a socket and attach it)\n***************************************************************************** */\n\ntypedef struct {\n  fio_protocol_s pr;\n  intptr_t uuid;\n  void *udata;\n  void (*on_open)(intptr_t uuid, void *udata);\n  void (*on_start)(intptr_t uuid, void *udata);\n  void (*on_finish)(intptr_t uuid, void *udata);\n  char *port;\n  char *addr;\n  size_t port_len;\n  size_t addr_len;\n  void *tls;\n} fio_listen_protocol_s;\n\nstatic void fio_listen_cleanup_task(void *pr_) {\n  fio_listen_protocol_s *pr = pr_;\n  if (pr->tls)\n    fio_tls_destroy(pr->tls);\n  if (pr->on_finish) {\n    pr->on_finish(pr->uuid, pr->udata);\n  }\n  fio_force_close(pr->uuid);\n  if (pr->addr &&\n      (!pr->port || *pr->port == 0 ||\n       (pr->port[0] == '0' && pr->port[1] == 0)) &&\n      fio_is_master()) {\n    /* delete Unix sockets */\n    unlink(pr->addr);\n  }\n  free(pr_);\n}\n\nstatic void fio_listen_on_startup(void *pr_) {\n  fio_state_callback_remove(FIO_CALL_ON_SHUTDOWN, fio_listen_cleanup_task, pr_);\n  fio_listen_protocol_s *pr = pr_;\n  fio_attach(pr->uuid, &pr->pr);\n  if (pr->port_len)\n    FIO_LOG_DEBUG(\"(%d) started listening on port %s\", (int)getpid(), pr->port);\n  else\n    FIO_LOG_DEBUG(\"(%d) started listening on Unix Socket at %s\", (int)getpid(),\n                  pr->addr);\n}\n\nstatic void fio_listen_on_close(intptr_t uuid, fio_protocol_s *pr_) {\n  fio_listen_cleanup_task(pr_);\n  (void)uuid;\n}\n\nstatic void fio_listen_on_data(intptr_t uuid, fio_protocol_s *pr_) {\n  fio_listen_protocol_s *pr = (fio_listen_protocol_s *)pr_;\n  for (int i = 0; i < 4; ++i) {\n    intptr_t client = fio_accept(uuid);\n    if (client == -1)\n      return;\n    pr->on_open(client, pr->udata);\n  }\n}\n\nstatic void fio_listen_on_data_tls(intptr_t uuid, fio_protocol_s *pr_) {\n  fio_listen_protocol_s *pr = (fio_listen_protocol_s *)pr_;\n  for (int i = 0; i < 4; ++i) {\n    intptr_t client = fio_accept(uuid);\n    if (client == -1)\n      return;\n    fio_tls_accept(client, pr->tls, pr->udata);\n    pr->on_open(client, pr->udata);\n  }\n}\n\nstatic void fio_listen_on_data_tls_alpn(intptr_t uuid, fio_protocol_s *pr_) {\n  fio_listen_protocol_s *pr = (fio_listen_protocol_s *)pr_;\n  for (int i = 0; i < 4; ++i) {\n    intptr_t client = fio_accept(uuid);\n    if (client == -1)\n      return;\n    fio_tls_accept(client, pr->tls, pr->udata);\n  }\n}\n\n/* stub for editor - unused */\nvoid fio_listen____(void);\n/**\n * Schedule a network service on a listening socket.\n *\n * Returns the listening socket or -1 (on error).\n */\nintptr_t fio_listen FIO_IGNORE_MACRO(struct fio_listen_args args) {\n  // ...\n  if ((!args.on_open && (!args.tls || !fio_tls_alpn_count(args.tls))) ||\n      (!args.address && !args.port)) {\n    errno = EINVAL;\n    goto error;\n  }\n\n  size_t addr_len = 0;\n  size_t port_len = 0;\n  if (args.address)\n    addr_len = strlen(args.address);\n  if (args.port) {\n    port_len = strlen(args.port);\n    char *tmp = (char *)args.port;\n    if (!fio_atol(&tmp)) {\n      port_len = 0;\n      args.port = NULL;\n    }\n    if (*tmp) {\n      /* port format was invalid, should be only numerals */\n      errno = EINVAL;\n      goto error;\n    }\n  }\n  const intptr_t uuid = fio_socket(args.address, args.port, 1);\n  if (uuid == -1)\n    goto error;\n\n  fio_listen_protocol_s *pr = malloc(sizeof(*pr) + addr_len + port_len +\n                                     ((addr_len + port_len) ? 2 : 0));\n  FIO_ASSERT_ALLOC(pr);\n\n  if (args.tls)\n    fio_tls_dup(args.tls);\n\n  *pr = (fio_listen_protocol_s){\n      .pr =\n          {\n              .on_close = fio_listen_on_close,\n              .ping = mock_ping_eternal,\n              .on_data = (args.tls ? (fio_tls_alpn_count(args.tls)\n                                          ? fio_listen_on_data_tls_alpn\n                                          : fio_listen_on_data_tls)\n                                   : fio_listen_on_data),\n          },\n      .uuid = uuid,\n      .udata = args.udata,\n      .on_open = args.on_open,\n      .on_start = args.on_start,\n      .on_finish = args.on_finish,\n      .tls = args.tls,\n      .addr_len = addr_len,\n      .port_len = port_len,\n      .addr = (char *)(pr + 1),\n      .port = ((char *)(pr + 1) + addr_len + 1),\n  };\n\n  if (addr_len)\n    memcpy(pr->addr, args.address, addr_len + 1);\n  if (port_len)\n    memcpy(pr->port, args.port, port_len + 1);\n\n  if (fio_is_running()) {\n    fio_attach(pr->uuid, &pr->pr);\n  } else {\n    fio_state_callback_add(FIO_CALL_ON_START, fio_listen_on_startup, pr);\n    fio_state_callback_add(FIO_CALL_ON_SHUTDOWN, fio_listen_cleanup_task, pr);\n  }\n\n  if (args.port)\n    FIO_LOG_INFO(\"Listening on port %s\", args.port);\n  else\n    FIO_LOG_INFO(\"Listening on Unix Socket at %s\", args.address);\n\n  return uuid;\nerror:\n  if (args.on_finish) {\n    args.on_finish(-1, args.udata);\n  }\n  return -1;\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                   Connecting to remote servers as a client\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/* *****************************************************************************\nThe connection protocol (use the facil.io API to make a socket and attach it)\n***************************************************************************** */\n\ntypedef struct {\n  fio_protocol_s pr;\n  intptr_t uuid;\n  void *udata;\n  void *tls;\n  void (*on_connect)(intptr_t uuid, void *udata);\n  void (*on_fail)(intptr_t uuid, void *udata);\n} fio_connect_protocol_s;\n\nstatic void fio_connect_on_close(intptr_t uuid, fio_protocol_s *pr_) {\n  fio_connect_protocol_s *pr = (fio_connect_protocol_s *)pr_;\n  if (pr->on_fail)\n    pr->on_fail(uuid, pr->udata);\n  if (pr->tls)\n    fio_tls_destroy(pr->tls);\n  fio_free(pr);\n  (void)uuid;\n}\n\nstatic void fio_connect_on_ready(intptr_t uuid, fio_protocol_s *pr_) {\n  fio_connect_protocol_s *pr = (fio_connect_protocol_s *)pr_;\n  if (pr->pr.on_ready == mock_on_ev)\n    return; /* Don't call on_connect more than once */\n  pr->pr.on_ready = mock_on_ev;\n  pr->on_fail = NULL;\n  pr->on_connect(uuid, pr->udata);\n  fio_poll_add(fio_uuid2fd(uuid));\n  (void)uuid;\n}\n\nstatic void fio_connect_on_ready_tls(intptr_t uuid, fio_protocol_s *pr_) {\n  fio_connect_protocol_s *pr = (fio_connect_protocol_s *)pr_;\n  if (pr->pr.on_ready == mock_on_ev)\n    return; /* Don't call on_connect more than once */\n  pr->pr.on_ready = mock_on_ev;\n  pr->on_fail = NULL;\n  fio_tls_connect(uuid, pr->tls, pr->udata);\n  pr->on_connect(uuid, pr->udata);\n  fio_poll_add(fio_uuid2fd(uuid));\n  (void)uuid;\n}\n\nstatic void fio_connect_on_ready_tls_alpn(intptr_t uuid, fio_protocol_s *pr_) {\n  fio_connect_protocol_s *pr = (fio_connect_protocol_s *)pr_;\n  if (pr->pr.on_ready == mock_on_ev)\n    return; /* Don't call on_connect more than once */\n  pr->pr.on_ready = mock_on_ev;\n  pr->on_fail = NULL;\n  fio_tls_connect(uuid, pr->tls, pr->udata);\n  fio_poll_add(fio_uuid2fd(uuid));\n  (void)uuid;\n}\n\n/* stub for sublime text function navigation */\nintptr_t fio_connect___(struct fio_connect_args args);\n\nintptr_t fio_connect FIO_IGNORE_MACRO(struct fio_connect_args args) {\n  if ((!args.on_connect && (!args.tls || !fio_tls_alpn_count(args.tls))) ||\n      (!args.address && !args.port)) {\n    errno = EINVAL;\n    goto error;\n  }\n  const intptr_t uuid = fio_socket(args.address, args.port, 0);\n  if (uuid == -1)\n    goto error;\n  fio_timeout_set(uuid, args.timeout);\n\n  fio_connect_protocol_s *pr = fio_malloc(sizeof(*pr));\n  FIO_ASSERT_ALLOC(pr);\n\n  if (args.tls)\n    fio_tls_dup(args.tls);\n\n  *pr = (fio_connect_protocol_s){\n      .pr =\n          {\n              .on_ready = (args.tls ? (fio_tls_alpn_count(args.tls)\n                                           ? fio_connect_on_ready_tls_alpn\n                                           : fio_connect_on_ready_tls)\n                                    : fio_connect_on_ready),\n              .on_close = fio_connect_on_close,\n          },\n      .uuid = uuid,\n      .tls = args.tls,\n      .udata = args.udata,\n      .on_connect = args.on_connect,\n      .on_fail = args.on_fail,\n  };\n  fio_attach(uuid, &pr->pr);\n  return uuid;\nerror:\n  if (args.on_fail)\n    args.on_fail(-1, args.udata);\n  return -1;\n}\n\n/* *****************************************************************************\nURL address parsing\n***************************************************************************** */\n\n/**\n * Parses the URI returning it's components and their lengths (no decoding\n * performed, doesn't accept decoded URIs).\n *\n * The returned string are NOT NUL terminated, they are merely locations within\n * the original string.\n *\n * This function expects any of the following formats:\n *\n * * `/complete_path?query#target`\n *\n *   i.e.: /index.html?page=1#list\n *\n * * `host:port/complete_path?query#target`\n *\n *   i.e.:\n *      example.com/index.html\n *      example.com:8080/index.html\n *\n * * `schema://user:password@host:port/path?query#target`\n *\n *   i.e.: http://example.com/index.html?page=1#list\n *\n * Invalid formats might produce unexpected results. No error testing performed.\n */\nfio_url_s fio_url_parse(const char *url, size_t length) {\n  /*\n  Intention:\n  [schema://][user[:]][password[@]][host.com[:/]][:port/][/path][?quary][#target]\n  */\n  const char *end = url + length;\n  const char *pos = url;\n  fio_url_s r = {.scheme = {.data = (char *)url}};\n  if (length == 0) {\n    goto finish;\n  }\n\n  if (pos[0] == '/') {\n    /* start at path */\n    goto start_path;\n  }\n\n  while (pos < end && pos[0] != ':' && pos[0] != '/' && pos[0] != '@' &&\n         pos[0] != '#' && pos[0] != '?')\n    ++pos;\n\n  if (pos == end) {\n    /* was only host (path starts with '/') */\n    r.host = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n    goto finish;\n  }\n  switch (pos[0]) {\n  case '@':\n    /* username@[host] */\n    r.user = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n    ++pos;\n    goto start_host;\n  case '/':\n    /* host[/path] */\n    r.host = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n    goto start_path;\n  case '?':\n    /* host?[query] */\n    r.host = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n    ++pos;\n    goto start_query;\n  case '#':\n    /* host#[target] */\n    r.host = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n    ++pos;\n    goto start_target;\n  case ':':\n    if (pos + 2 <= end && pos[1] == '/' && pos[2] == '/') {\n      /* scheme:// */\n      r.scheme.len = pos - url;\n      pos += 3;\n    } else {\n      /* username:[password] OR */\n      /* host:[port] */\n      r.user = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n      ++pos;\n      goto start_password;\n    }\n    break;\n  }\n\n  // start_username:\n  url = pos;\n  while (pos < end && pos[0] != ':' && pos[0] != '/' && pos[0] != '@'\n         /* && pos[0] != '#' && pos[0] != '?' */)\n    ++pos;\n\n  if (pos >= end) { /* scheme://host */\n    r.host = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n    goto finish;\n  }\n\n  switch (pos[0]) {\n  case '/':\n    /* scheme://host[/path] */\n    r.host = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n    goto start_path;\n  case '@':\n    /* scheme://username@[host]... */\n    r.user = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n    ++pos;\n    goto start_host;\n  case ':':\n    /* scheme://username:[password]@[host]... OR */\n    /* scheme://host:[port][/...] */\n    r.user = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n    ++pos;\n    break;\n  }\n\nstart_password:\n  url = pos;\n  while (pos < end && pos[0] != '/' && pos[0] != '@')\n    ++pos;\n\n  if (pos >= end) {\n    /* was host:port */\n    r.port = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n    r.host = r.user;\n    r.user.len = 0;\n    goto finish;\n    ;\n  }\n\n  switch (pos[0]) {\n  case '/':\n    r.port = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n    r.host = r.user;\n    r.user.len = 0;\n    goto start_path;\n  case '@':\n    r.password = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n    ++pos;\n    break;\n  }\n\nstart_host:\n  url = pos;\n  while (pos < end && pos[0] != '/' && pos[0] != ':' && pos[0] != '#' &&\n         pos[0] != '?')\n    ++pos;\n\n  r.host = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n  if (pos >= end) {\n    goto finish;\n  }\n  switch (pos[0]) {\n  case '/':\n    /* scheme://[...@]host[/path] */\n    goto start_path;\n  case '?':\n    /* scheme://[...@]host?[query] (bad)*/\n    ++pos;\n    goto start_query;\n  case '#':\n    /* scheme://[...@]host#[target] (bad)*/\n    ++pos;\n    goto start_target;\n    // case ':':\n    /* scheme://[...@]host:[port] */\n  }\n  ++pos;\n\n  // start_port:\n  url = pos;\n  while (pos < end && pos[0] != '/' && pos[0] != '#' && pos[0] != '?')\n    ++pos;\n\n  r.port = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n\n  if (pos >= end) {\n    /* scheme://[...@]host:port */\n    goto finish;\n  }\n  switch (pos[0]) {\n  case '?':\n    /* scheme://[...@]host:port?[query] (bad)*/\n    ++pos;\n    goto start_query;\n  case '#':\n    /* scheme://[...@]host:port#[target] (bad)*/\n    ++pos;\n    goto start_target;\n    // case '/':\n    /* scheme://[...@]host:port[/path] */\n  }\n\nstart_path:\n  url = pos;\n  while (pos < end && pos[0] != '#' && pos[0] != '?')\n    ++pos;\n\n  r.path = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n\n  if (pos >= end) {\n    goto finish;\n  }\n  ++pos;\n  if (pos[-1] == '#')\n    goto start_target;\n\nstart_query:\n  url = pos;\n  while (pos < end && pos[0] != '#')\n    ++pos;\n\n  r.query = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n  ++pos;\n\n  if (pos >= end)\n    goto finish;\n\nstart_target:\n  r.target = (fio_str_info_s){.data = (char *)pos, .len = end - pos};\n\nfinish:\n\n  /* set any empty values to NULL */\n  if (!r.scheme.len)\n    r.scheme.data = NULL;\n  if (!r.user.len)\n    r.user.data = NULL;\n  if (!r.password.len)\n    r.password.data = NULL;\n  if (!r.host.len)\n    r.host.data = NULL;\n  if (!r.port.len)\n    r.port.data = NULL;\n  if (!r.path.len)\n    r.path.data = NULL;\n  if (!r.query.len)\n    r.query.data = NULL;\n  if (!r.target.len)\n    r.target.data = NULL;\n\n  return r;\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                       Cluster Messaging Implementation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n#if FIO_PUBSUB_SUPPORT\n\n/* *****************************************************************************\n * Data Structures - Channel / Subscriptions data\n **************************************************************************** */\n\ntypedef enum fio_cluster_message_type_e {\n  FIO_CLUSTER_MSG_FORWARD,\n  FIO_CLUSTER_MSG_JSON,\n  FIO_CLUSTER_MSG_ROOT,\n  FIO_CLUSTER_MSG_ROOT_JSON,\n  FIO_CLUSTER_MSG_PUBSUB_SUB,\n  FIO_CLUSTER_MSG_PUBSUB_UNSUB,\n  FIO_CLUSTER_MSG_PATTERN_SUB,\n  FIO_CLUSTER_MSG_PATTERN_UNSUB,\n  FIO_CLUSTER_MSG_SHUTDOWN,\n  FIO_CLUSTER_MSG_ERROR,\n  FIO_CLUSTER_MSG_PING,\n} fio_cluster_message_type_e;\n\ntypedef struct fio_collection_s fio_collection_s;\n\n#ifndef __clang__ /* clang might misbehave by assumming non-alignment */\n#pragma pack(1)   /* https://gitter.im/halide/Halide/archives/2018/07/24 */\n#endif\ntypedef struct {\n  size_t name_len;\n  char *name;\n  volatile size_t ref;\n  fio_ls_embd_s subscriptions;\n  fio_collection_s *parent;\n  fio_match_fn match;\n  fio_lock_i lock;\n} channel_s;\n#ifndef __clang__\n#pragma pack()\n#endif\n\nstruct subscription_s {\n  fio_ls_embd_s node;\n  channel_s *parent;\n  void (*on_message)(fio_msg_s *msg);\n  void (*on_unsubscribe)(void *udata1, void *udata2);\n  void *udata1;\n  void *udata2;\n  /** reference counter. */\n  uintptr_t ref;\n  /** prevents the callback from running concurrently for multiple messages. */\n  fio_lock_i lock;\n  fio_lock_i unsubscribed;\n};\n\n/* Use `malloc` / `free`, because channles might have a long life. */\n\n/** Used internally by the Set object to create a new channel. */\nstatic channel_s *fio_channel_copy(channel_s *src) {\n  channel_s *dest = malloc(sizeof(*dest) + src->name_len + 1);\n  FIO_ASSERT_ALLOC(dest);\n  dest->name_len = src->name_len;\n  dest->match = src->match;\n  dest->parent = src->parent;\n  dest->name = (char *)(dest + 1);\n  if (src->name_len)\n    memcpy(dest->name, src->name, src->name_len);\n  dest->name[src->name_len] = 0;\n  dest->subscriptions = (fio_ls_embd_s)FIO_LS_INIT(dest->subscriptions);\n  dest->ref = 1;\n  dest->lock = FIO_LOCK_INIT;\n  return dest;\n}\n/** Frees a channel (reference counting). */\nstatic void fio_channel_free(channel_s *ch) {\n  if (!ch)\n    return;\n  if (fio_atomic_sub(&ch->ref, 1))\n    return;\n  free(ch);\n}\n/** Increases a channel's reference count. */\nstatic void fio_channel_dup(channel_s *ch) {\n  if (!ch)\n    return;\n  fio_atomic_add(&ch->ref, 1);\n}\n/** Tests if two channels are equal. */\nstatic int fio_channel_cmp(channel_s *ch1, channel_s *ch2) {\n  return ch1->name_len == ch2->name_len && ch1->match == ch2->match &&\n         !memcmp(ch1->name, ch2->name, ch1->name_len);\n}\n/* pub/sub channels and core data sets have a long life, so avoid fio_malloc */\n#define FIO_FORCE_MALLOC_TMP 1\n#define FIO_SET_NAME fio_ch_set\n#define FIO_SET_OBJ_TYPE channel_s *\n#define FIO_SET_OBJ_COMPARE(o1, o2) fio_channel_cmp((o1), (o2))\n#define FIO_SET_OBJ_DESTROY(obj) fio_channel_free((obj))\n#define FIO_SET_OBJ_COPY(dest, src) ((dest) = fio_channel_copy((src)))\n#include <fio.h>\n\n#define FIO_FORCE_MALLOC_TMP 1\n#define FIO_ARY_NAME fio_meta_ary\n#define FIO_ARY_TYPE fio_msg_metadata_fn\n#include <fio.h>\n\n#define FIO_FORCE_MALLOC_TMP 1\n#define FIO_SET_NAME fio_engine_set\n#define FIO_SET_OBJ_TYPE fio_pubsub_engine_s *\n#define FIO_SET_OBJ_COMPARE(k1, k2) ((k1) == (k2))\n#include <fio.h>\n\nstruct fio_collection_s {\n  fio_ch_set_s channels;\n  fio_lock_i lock;\n};\n\n#define COLLECTION_INIT                                                        \\\n  { .channels = FIO_SET_INIT, .lock = FIO_LOCK_INIT }\n\nstatic struct {\n  fio_collection_s filters;\n  fio_collection_s pubsub;\n  fio_collection_s patterns;\n  struct {\n    fio_engine_set_s set;\n    fio_lock_i lock;\n  } engines;\n  struct {\n    fio_meta_ary_s ary;\n    fio_lock_i lock;\n  } meta;\n} fio_postoffice = {\n    .filters = COLLECTION_INIT,\n    .pubsub = COLLECTION_INIT,\n    .patterns = COLLECTION_INIT,\n    .engines.lock = FIO_LOCK_INIT,\n    .meta.lock = FIO_LOCK_INIT,\n};\n\n/** used to contain the message before it's passed to the handler */\ntypedef struct {\n  fio_msg_s msg;\n  size_t marker;\n  size_t meta_len;\n  fio_msg_metadata_s *meta;\n} fio_msg_client_s;\n\n/** used to contain the message internally while publishing */\ntypedef struct {\n  fio_str_info_s channel;\n  fio_str_info_s data;\n  uintptr_t ref; /* internal reference counter */\n  int32_t filter;\n  int8_t is_json;\n  size_t meta_len;\n  fio_msg_metadata_s meta[];\n} fio_msg_internal_s;\n\n/** The default engine (settable). */\nfio_pubsub_engine_s *FIO_PUBSUB_DEFAULT = FIO_PUBSUB_CLUSTER;\n\n/* *****************************************************************************\nInternal message object creation\n***************************************************************************** */\n\n/** returns a temporary fio_meta_ary_s with a copy of the metadata array */\nstatic fio_meta_ary_s fio_postoffice_meta_copy_new(void) {\n  fio_meta_ary_s t = FIO_ARY_INIT;\n  if (!fio_meta_ary_count(&fio_postoffice.meta.ary)) {\n    return t;\n  }\n  fio_lock(&fio_postoffice.meta.lock);\n  fio_meta_ary_concat(&t, &fio_postoffice.meta.ary);\n  fio_unlock(&fio_postoffice.meta.lock);\n  return t;\n}\n\n/** frees a temporary copy created by postoffice_meta_copy_new */\nstatic inline void fio_postoffice_meta_copy_free(fio_meta_ary_s *cpy) {\n  fio_meta_ary_free(cpy);\n}\n\nstatic void fio_postoffice_meta_update(fio_msg_internal_s *m) {\n  if (m->filter || !m->meta_len)\n    return;\n  fio_meta_ary_s t = fio_postoffice_meta_copy_new();\n  if (t.end > m->meta_len)\n    t.end = m->meta_len;\n  m->meta_len = t.end;\n  while (t.end) {\n    --t.end;\n    m->meta[t.end] = t.arry[t.end](m->channel, m->data, m->is_json);\n  }\n  fio_postoffice_meta_copy_free(&t);\n}\n\nstatic fio_msg_internal_s *\nfio_msg_internal_create(int32_t filter, uint32_t type, fio_str_info_s ch,\n                        fio_str_info_s data, int8_t is_json, int8_t cpy) {\n  fio_meta_ary_s t = FIO_ARY_INIT;\n  if (!filter)\n    t = fio_postoffice_meta_copy_new();\n  fio_msg_internal_s *m = fio_malloc(sizeof(*m) + (sizeof(*m->meta) * t.end) +\n                                     (ch.len) + (data.len) + 16 + 2);\n  FIO_ASSERT_ALLOC(m);\n  *m = (fio_msg_internal_s){\n      .filter = filter,\n      .channel = (fio_str_info_s){.data = (char *)(m->meta + t.end) + 16,\n                                  .len = ch.len},\n      .data = (fio_str_info_s){.data = ((char *)(m->meta + t.end) + ch.len +\n                                        16 + 1),\n                               .len = data.len},\n      .is_json = is_json,\n      .ref = 1,\n      .meta_len = t.end,\n  };\n  fio_u2str32((uint8_t *)(m + 1) + (sizeof(*m->meta) * t.end), ch.len);\n  fio_u2str32((uint8_t *)(m + 1) + (sizeof(*m->meta) * t.end) + 4, data.len);\n  fio_u2str32((uint8_t *)(m + 1) + (sizeof(*m->meta) * t.end) + 8, type);\n  fio_u2str32((uint8_t *)(m + 1) + (sizeof(*m->meta) * t.end) + 12,\n              (uint32_t)filter);\n  // m->channel.data[ch.len] = 0; /* redundant, fio_malloc is all zero */\n  // m->data.data[data.len] = 0; /* redundant, fio_malloc is all zero */\n  if (cpy) {\n    memcpy(m->channel.data, ch.data, ch.len);\n    memcpy(m->data.data, data.data, data.len);\n    while (t.end) {\n      --t.end;\n      m->meta[t.end] = t.arry[t.end](m->channel, m->data, is_json);\n    }\n  }\n  fio_postoffice_meta_copy_free(&t);\n  return m;\n}\n\n/** frees the internal message data */\nstatic inline void fio_msg_internal_finalize(fio_msg_internal_s *m) {\n  if (!m->channel.len)\n    m->channel.data = NULL;\n  if (!m->data.len)\n    m->data.data = NULL;\n}\n\n/** frees the internal message data */\nstatic inline void fio_msg_internal_free(fio_msg_internal_s *m) {\n  if (fio_atomic_sub(&m->ref, 1))\n    return;\n  while (m->meta_len) {\n    --m->meta_len;\n    if (m->meta[m->meta_len].on_finish) {\n      fio_msg_s tmp_msg = {\n          .channel = m->channel,\n          .msg = m->data,\n      };\n      m->meta[m->meta_len].on_finish(&tmp_msg, m->meta[m->meta_len].metadata);\n    }\n  }\n  fio_free(m);\n}\n\nstatic void fio_msg_internal_free2(void *m) { fio_msg_internal_free(m); }\n\n/* add reference count to fio_msg_internal_s */\nstatic inline fio_msg_internal_s *fio_msg_internal_dup(fio_msg_internal_s *m) {\n  fio_atomic_add(&m->ref, 1);\n  return m;\n}\n\n/** internal helper */\n\nstatic inline ssize_t fio_msg_internal_send_dup(intptr_t uuid,\n                                                fio_msg_internal_s *m) {\n  return fio_write2(uuid, .data.buffer = fio_msg_internal_dup(m),\n                    .offset = (sizeof(*m) + (m->meta_len * sizeof(*m->meta))),\n                    .length = 16 + m->data.len + m->channel.len + 2,\n                    .after.dealloc = fio_msg_internal_free2);\n}\n\n/**\n * A mock pub/sub callback for external subscriptions.\n */\nstatic void fio_mock_on_message(fio_msg_s *msg) { (void)msg; }\n\n/* *****************************************************************************\nChannel Subscription Management\n***************************************************************************** */\n\nstatic void fio_pubsub_on_channel_create(channel_s *ch);\nstatic void fio_pubsub_on_channel_destroy(channel_s *ch);\n\n/* some comon tasks extracted */\nstatic inline channel_s *fio_filter_dup_lock_internal(channel_s *ch,\n                                                      uint64_t hashed,\n                                                      fio_collection_s *c) {\n  fio_lock(&c->lock);\n  ch = fio_ch_set_insert(&c->channels, hashed, ch);\n  fio_channel_dup(ch);\n  fio_lock(&ch->lock);\n  fio_unlock(&c->lock);\n  return ch;\n}\n\n/** Creates / finds a filter channel, adds a reference count and locks it. */\nstatic channel_s *fio_filter_dup_lock(uint32_t filter) {\n  channel_s ch = (channel_s){\n      .name = (char *)&filter,\n      .name_len = (sizeof(filter)),\n      .parent = &fio_postoffice.filters,\n      .ref = 8, /* avoid freeing stack memory */\n  };\n  return fio_filter_dup_lock_internal(&ch, filter, &fio_postoffice.filters);\n}\n\n/** Creates / finds a pubsub channel, adds a reference count and locks it. */\nstatic channel_s *fio_channel_dup_lock(fio_str_info_s name) {\n  channel_s ch = (channel_s){\n      .name = name.data,\n      .name_len = name.len,\n      .parent = &fio_postoffice.pubsub,\n      .ref = 8, /* avoid freeing stack memory */\n  };\n  uint64_t hashed_name = FIO_HASH_FN(\n      name.data, name.len, &fio_postoffice.pubsub, &fio_postoffice.pubsub);\n  channel_s *ch_p =\n      fio_filter_dup_lock_internal(&ch, hashed_name, &fio_postoffice.pubsub);\n  if (fio_ls_embd_is_empty(&ch_p->subscriptions)) {\n    fio_pubsub_on_channel_create(ch_p);\n  }\n  return ch_p;\n}\n\n/** Creates / finds a pattern channel, adds a reference count and locks it. */\nstatic channel_s *fio_channel_match_dup_lock(fio_str_info_s name,\n                                             fio_match_fn match) {\n  channel_s ch = (channel_s){\n      .name = name.data,\n      .name_len = name.len,\n      .parent = &fio_postoffice.patterns,\n      .match = match,\n      .ref = 8, /* avoid freeing stack memory */\n  };\n  uint64_t hashed_name = FIO_HASH_FN(\n      name.data, name.len, &fio_postoffice.pubsub, &fio_postoffice.pubsub);\n  channel_s *ch_p =\n      fio_filter_dup_lock_internal(&ch, hashed_name, &fio_postoffice.patterns);\n  if (fio_ls_embd_is_empty(&ch_p->subscriptions)) {\n    fio_pubsub_on_channel_create(ch_p);\n  }\n  return ch_p;\n}\n\n/* to be used for reference counting (subtructing) */\nstatic inline void fio_subscription_free(subscription_s *s) {\n  if (fio_atomic_sub(&s->ref, 1)) {\n    return;\n  }\n  if (s->on_unsubscribe) {\n    s->on_unsubscribe(s->udata1, s->udata2);\n  }\n  fio_channel_free(s->parent);\n  fio_free(s);\n}\n\n/** SublimeText 3 marker */\nsubscription_s *fio_subscribe___(subscribe_args_s args);\n\n/** Subscribes to a filter, pub/sub channle or patten */\nsubscription_s *fio_subscribe FIO_IGNORE_MACRO(subscribe_args_s args) {\n  if (!args.on_message)\n    goto error;\n  channel_s *ch;\n  subscription_s *s = fio_malloc(sizeof(*s));\n  FIO_ASSERT_ALLOC(s);\n  *s = (subscription_s){\n      .on_message = args.on_message,\n      .on_unsubscribe = args.on_unsubscribe,\n      .udata1 = args.udata1,\n      .udata2 = args.udata2,\n      .ref = 1,\n      .lock = FIO_LOCK_INIT,\n  };\n  if (args.filter) {\n    ch = fio_filter_dup_lock(args.filter);\n  } else if (args.match) {\n    ch = fio_channel_match_dup_lock(args.channel, args.match);\n  } else {\n    ch = fio_channel_dup_lock(args.channel);\n  }\n  s->parent = ch;\n  fio_ls_embd_push(&ch->subscriptions, &s->node);\n  fio_unlock((&ch->lock));\n  return s;\nerror:\n  if (args.on_unsubscribe)\n    args.on_unsubscribe(args.udata1, args.udata2);\n  return NULL;\n}\n\n/** Unsubscribes from a filter, pub/sub channle or patten */\nvoid fio_unsubscribe(subscription_s *s) {\n  if (!s)\n    return;\n  if (fio_trylock(&s->unsubscribed))\n    goto finish;\n  fio_lock(&s->lock);\n  channel_s *ch = s->parent;\n  uint8_t removed = 0;\n  fio_lock(&ch->lock);\n  fio_ls_embd_remove(&s->node);\n  /* check if channel is done for */\n  if (fio_ls_embd_is_empty(&ch->subscriptions)) {\n    fio_collection_s *c = ch->parent;\n    uint64_t hashed = FIO_HASH_FN(\n        ch->name, ch->name_len, &fio_postoffice.pubsub, &fio_postoffice.pubsub);\n    /* lock collection */\n    fio_lock(&c->lock);\n    /* test again within lock */\n    if (fio_ls_embd_is_empty(&ch->subscriptions)) {\n      fio_ch_set_remove(&c->channels, hashed, ch, NULL);\n      removed = (c != &fio_postoffice.filters);\n    }\n    fio_unlock(&c->lock);\n  }\n  fio_unlock(&ch->lock);\n  if (removed) {\n    fio_pubsub_on_channel_destroy(ch);\n  }\n\n  /* promise the subscription will be inactive */\n  s->on_message = NULL;\n  fio_unlock(&s->lock);\nfinish:\n  fio_subscription_free(s);\n}\n\n/**\n * This helper returns a temporary String with the subscription's channel (or a\n * string representing the filter).\n *\n * To keep the string beyond the lifetime of the subscription, copy the string.\n */\nfio_str_info_s fio_subscription_channel(subscription_s *subscription) {\n  return (fio_str_info_s){.data = subscription->parent->name,\n                          .len = subscription->parent->name_len};\n}\n\n/* *****************************************************************************\nEngine handling and Management\n***************************************************************************** */\n\n/* implemented later, informs root process about pub/sub subscriptions */\nstatic inline void fio_cluster_inform_root_about_channel(channel_s *ch,\n                                                         int add);\n\n/* runs in lock(!) let'm all know */\nstatic void fio_pubsub_on_channel_create(channel_s *ch) {\n  fio_lock(&fio_postoffice.engines.lock);\n  FIO_SET_FOR_LOOP(&fio_postoffice.engines.set, pos) {\n    if (!pos->hash)\n      continue;\n    pos->obj->subscribe(pos->obj,\n                        (fio_str_info_s){.data = ch->name, .len = ch->name_len},\n                        ch->match);\n  }\n  fio_unlock(&fio_postoffice.engines.lock);\n  fio_cluster_inform_root_about_channel(ch, 1);\n}\n\n/* runs in lock(!) let'm all know */\nstatic void fio_pubsub_on_channel_destroy(channel_s *ch) {\n  fio_lock(&fio_postoffice.engines.lock);\n  FIO_SET_FOR_LOOP(&fio_postoffice.engines.set, pos) {\n    if (!pos->hash)\n      continue;\n    pos->obj->unsubscribe(\n        pos->obj, (fio_str_info_s){.data = ch->name, .len = ch->name_len},\n        ch->match);\n  }\n  fio_unlock(&fio_postoffice.engines.lock);\n  fio_cluster_inform_root_about_channel(ch, 0);\n}\n\n/**\n * Attaches an engine, so it's callback can be called by facil.io.\n *\n * The `subscribe` callback will be called for every existing channel.\n *\n * NOTE: the root (master) process will call `subscribe` for any channel in any\n * process, while all the other processes will call `subscribe` only for their\n * own channels. This allows engines to use the root (master) process as an\n * exclusive subscription process.\n */\nvoid fio_pubsub_attach(fio_pubsub_engine_s *engine) {\n  fio_lock(&fio_postoffice.engines.lock);\n  fio_engine_set_insert(&fio_postoffice.engines.set, (uintptr_t)engine, engine);\n  fio_unlock(&fio_postoffice.engines.lock);\n  fio_pubsub_reattach(engine);\n}\n\n/** Detaches an engine, so it could be safely destroyed. */\nvoid fio_pubsub_detach(fio_pubsub_engine_s *engine) {\n  fio_lock(&fio_postoffice.engines.lock);\n  fio_engine_set_remove(&fio_postoffice.engines.set, (uintptr_t)engine, engine,\n                        NULL);\n  fio_unlock(&fio_postoffice.engines.lock);\n}\n\n/** Returns true (1) if the engine is attached to the system. */\nint fio_pubsub_is_attached(fio_pubsub_engine_s *engine) {\n  fio_pubsub_engine_s *addr;\n  fio_lock(&fio_postoffice.engines.lock);\n  addr = fio_engine_set_find(&fio_postoffice.engines.set, (uintptr_t)engine,\n                             engine);\n  fio_unlock(&fio_postoffice.engines.lock);\n  return addr != NULL;\n}\n\n/**\n * Engines can ask facil.io to call the `subscribe` callback for all active\n * channels.\n *\n * This allows engines that lost their connection to their Pub/Sub service to\n * resubscribe all the currently active channels with the new connection.\n *\n * CAUTION: This is an evented task... try not to free the engine's memory while\n * resubscriptions are under way...\n *\n * NOTE: the root (master) process will call `subscribe` for any channel in any\n * process, while all the other processes will call `subscribe` only for their\n * own channels. This allows engines to use the root (master) process as an\n * exclusive subscription process.\n */\nvoid fio_pubsub_reattach(fio_pubsub_engine_s *eng) {\n  fio_lock(&fio_postoffice.pubsub.lock);\n  FIO_SET_FOR_LOOP(&fio_postoffice.pubsub.channels, pos) {\n    if (!pos->hash)\n      continue;\n    eng->subscribe(\n        eng,\n        (fio_str_info_s){.data = pos->obj->name, .len = pos->obj->name_len},\n        NULL);\n  }\n  fio_unlock(&fio_postoffice.pubsub.lock);\n  fio_lock(&fio_postoffice.patterns.lock);\n  FIO_SET_FOR_LOOP(&fio_postoffice.patterns.channels, pos) {\n    if (!pos->hash)\n      continue;\n    eng->subscribe(\n        eng,\n        (fio_str_info_s){.data = pos->obj->name, .len = pos->obj->name_len},\n        pos->obj->match);\n  }\n  fio_unlock(&fio_postoffice.patterns.lock);\n}\n\n/* *****************************************************************************\n * Message Metadata handling\n **************************************************************************** */\n\nvoid fio_message_metadata_callback_set(fio_msg_metadata_fn callback,\n                                       int enable) {\n  if (!callback)\n    return;\n  fio_lock(&fio_postoffice.meta.lock);\n  fio_meta_ary_remove2(&fio_postoffice.meta.ary, callback, NULL);\n  if (enable)\n    fio_meta_ary_push(&fio_postoffice.meta.ary, callback);\n  fio_unlock(&fio_postoffice.meta.lock);\n}\n\n/** Finds the message's metadata by it's type ID. */\nvoid *fio_message_metadata(fio_msg_s *msg, intptr_t type_id) {\n  fio_msg_metadata_s *meta = ((fio_msg_client_s *)msg)->meta;\n  size_t len = ((fio_msg_client_s *)msg)->meta_len;\n  while (len) {\n    --len;\n    if (meta[len].type_id == type_id)\n      return meta[len].metadata;\n  }\n  return NULL;\n}\n\n/* *****************************************************************************\n * Publishing to the subsriptions\n **************************************************************************** */\n\n/* common internal tasks */\nstatic channel_s *fio_channel_find_dup_internal(channel_s *ch_tmp,\n                                                uint64_t hashed,\n                                                fio_collection_s *c) {\n  fio_lock(&c->lock);\n  channel_s *ch = fio_ch_set_find(&c->channels, hashed, ch_tmp);\n  if (!ch) {\n    fio_unlock(&c->lock);\n    return NULL;\n  }\n  fio_channel_dup(ch);\n  fio_unlock(&c->lock);\n  return ch;\n}\n\n/** Finds a filter channel, increasing it's reference count if it exists. */\nstatic channel_s *fio_filter_find_dup(uint32_t filter) {\n  channel_s tmp = {.name = (char *)(&filter), .name_len = sizeof(filter)};\n  channel_s *ch =\n      fio_channel_find_dup_internal(&tmp, filter, &fio_postoffice.filters);\n  return ch;\n}\n\n/** Finds a pubsub channel, increasing it's reference count if it exists. */\nstatic channel_s *fio_channel_find_dup(fio_str_info_s name) {\n  channel_s tmp = {.name = name.data, .name_len = name.len};\n  uint64_t hashed_name = FIO_HASH_FN(\n      name.data, name.len, &fio_postoffice.pubsub, &fio_postoffice.pubsub);\n  channel_s *ch =\n      fio_channel_find_dup_internal(&tmp, hashed_name, &fio_postoffice.pubsub);\n  return ch;\n}\n\n/* defers the callback (mark only) */\nvoid fio_message_defer(fio_msg_s *msg_) {\n  fio_msg_client_s *cl = (fio_msg_client_s *)msg_;\n  cl->marker = 1;\n}\n\n/* performs the actual callback */\nstatic void fio_perform_subscription_callback(void *s_, void *msg_) {\n  subscription_s *s = s_;\n  if (fio_trylock(&s->lock)) {\n    fio_defer_push_task(fio_perform_subscription_callback, s_, msg_);\n    return;\n  }\n  fio_msg_internal_s *msg = (fio_msg_internal_s *)msg_;\n  fio_msg_client_s m = {\n      .msg =\n          {\n              .channel = msg->channel,\n              .msg = msg->data,\n              .filter = msg->filter,\n              .udata1 = s->udata1,\n              .udata2 = s->udata2,\n          },\n      .meta_len = msg->meta_len,\n      .meta = msg->meta,\n      .marker = 0,\n  };\n  if (s->on_message) {\n    /* the on_message callback is removed when a subscription is canceled. */\n    s->on_message(&m.msg);\n  }\n  fio_unlock(&s->lock);\n  if (m.marker) {\n    fio_defer_push_task(fio_perform_subscription_callback, s_, msg_);\n    return;\n  }\n  fio_msg_internal_free(msg);\n  fio_subscription_free(s);\n}\n\n/** UNSAFE! publishes a message to a channel, managing the reference counts */\nstatic void fio_publish2channel(channel_s *ch, fio_msg_internal_s *msg) {\n  FIO_LS_EMBD_FOR(&ch->subscriptions, pos) {\n    subscription_s *s = FIO_LS_EMBD_OBJ(subscription_s, node, pos);\n    if (!s || s->on_message == fio_mock_on_message) {\n      continue;\n    }\n    fio_atomic_add(&s->ref, 1);\n    fio_atomic_add(&msg->ref, 1);\n    fio_defer_push_task(fio_perform_subscription_callback, s, msg);\n  }\n  fio_msg_internal_free(msg);\n}\nstatic void fio_publish2channel_task(void *ch_, void *msg) {\n  channel_s *ch = ch_;\n  if (!ch_)\n    return;\n  if (!msg)\n    goto finish;\n  if (fio_trylock(&ch->lock)) {\n    fio_defer_push_urgent(fio_publish2channel_task, ch, msg);\n    return;\n  }\n  fio_publish2channel(ch, msg);\n  fio_unlock(&ch->lock);\nfinish:\n  fio_channel_free(ch);\n}\n\n/** Publishes the message to the current process and frees the strings. */\nstatic void fio_publish2process(fio_msg_internal_s *m) {\n  fio_msg_internal_finalize(m);\n  channel_s *ch;\n  if (m->filter) {\n    ch = fio_filter_find_dup(m->filter);\n    if (!ch) {\n      goto finish;\n    }\n  } else {\n    ch = fio_channel_find_dup(m->channel);\n  }\n  /* exact match */\n  if (ch) {\n    fio_defer_push_urgent(fio_publish2channel_task, ch,\n                          fio_msg_internal_dup(m));\n  }\n  if (m->filter == 0) {\n    /* pattern matching match */\n    fio_lock(&fio_postoffice.patterns.lock);\n    FIO_SET_FOR_LOOP(&fio_postoffice.patterns.channels, p) {\n      if (!p->hash) {\n        continue;\n      }\n\n      if (p->obj->match(\n              (fio_str_info_s){.data = p->obj->name, .len = p->obj->name_len},\n              m->channel)) {\n        fio_channel_dup(p->obj);\n        fio_defer_push_urgent(fio_publish2channel_task, p->obj,\n                              fio_msg_internal_dup(m));\n      }\n    }\n    fio_unlock(&fio_postoffice.patterns.lock);\n  }\nfinish:\n  fio_msg_internal_free(m);\n}\n\n/* *****************************************************************************\n * Data Structures - Core Structures\n **************************************************************************** */\n\n#define CLUSTER_READ_BUFFER 16384\n\n#define FIO_SET_NAME fio_sub_hash\n#define FIO_SET_OBJ_TYPE subscription_s *\n#define FIO_SET_KEY_TYPE fio_str_s\n#define FIO_SET_KEY_COPY(k1, k2)                                               \\\n  (k1) = FIO_STR_INIT;                                                         \\\n  fio_str_concat(&(k1), &(k2))\n#define FIO_SET_KEY_COMPARE(k1, k2) fio_str_iseq(&(k1), &(k2))\n#define FIO_SET_KEY_DESTROY(key) fio_str_free(&(key))\n#define FIO_SET_OBJ_DESTROY(obj) fio_unsubscribe(obj)\n#include <fio.h>\n\n#define FIO_CLUSTER_NAME_LIMIT 255\n\ntypedef struct cluster_pr_s {\n  fio_protocol_s protocol;\n  fio_msg_internal_s *msg;\n  void (*handler)(struct cluster_pr_s *pr);\n  void (*sender)(void *data, intptr_t avoid_uuid);\n  fio_sub_hash_s pubsub;\n  fio_sub_hash_s patterns;\n  intptr_t uuid;\n  uint32_t exp_channel;\n  uint32_t exp_msg;\n  uint32_t type;\n  int32_t filter;\n  uint32_t length;\n  fio_lock_i lock;\n  uint8_t buffer[CLUSTER_READ_BUFFER];\n} cluster_pr_s;\n\nstatic struct cluster_data_s {\n  intptr_t uuid;\n  fio_ls_s clients;\n  fio_lock_i lock;\n  char name[FIO_CLUSTER_NAME_LIMIT + 1];\n} cluster_data = {.clients = FIO_LS_INIT(cluster_data.clients),\n                  .lock = FIO_LOCK_INIT};\n\nstatic void fio_cluster_data_cleanup(int delete_file) {\n  if (delete_file && cluster_data.name[0]) {\n#if DEBUG\n    FIO_LOG_DEBUG(\"(%d) unlinking cluster's Unix socket.\", (int)getpid());\n#endif\n    unlink(cluster_data.name);\n  }\n  while (fio_ls_any(&cluster_data.clients)) {\n    intptr_t uuid = (intptr_t)fio_ls_pop(&cluster_data.clients);\n    if (uuid > 0) {\n      fio_close(uuid);\n    }\n  }\n  cluster_data.uuid = 0;\n  cluster_data.lock = FIO_LOCK_INIT;\n  cluster_data.clients = (fio_ls_s)FIO_LS_INIT(cluster_data.clients);\n}\n\nstatic void fio_cluster_cleanup(void *ignore) {\n  /* cleanup the cluster data */\n  fio_cluster_data_cleanup(fio_parent_pid() == getpid());\n  (void)ignore;\n}\n\nstatic void fio_cluster_init(void) {\n  fio_cluster_data_cleanup(0);\n  /* create a unique socket name */\n  char *tmp_folder = getenv(\"TMPDIR\");\n  uint32_t tmp_folder_len = 0;\n  if (!tmp_folder || ((tmp_folder_len = (uint32_t)strlen(tmp_folder)) >\n                      (FIO_CLUSTER_NAME_LIMIT - 28))) {\n#ifdef P_tmpdir\n    tmp_folder = (char *)P_tmpdir;\n    if (tmp_folder)\n      tmp_folder_len = (uint32_t)strlen(tmp_folder);\n#else\n    tmp_folder = \"/tmp/\";\n    tmp_folder_len = 5;\n#endif\n  }\n  if (tmp_folder_len >= (FIO_CLUSTER_NAME_LIMIT - 28)) {\n    tmp_folder_len = 0;\n  }\n  if (tmp_folder_len) {\n    memcpy(cluster_data.name, tmp_folder, tmp_folder_len);\n    if (cluster_data.name[tmp_folder_len - 1] != '/')\n      cluster_data.name[tmp_folder_len++] = '/';\n  }\n  memcpy(cluster_data.name + tmp_folder_len, \"facil-io-sock-\", 14);\n  tmp_folder_len += 14;\n  tmp_folder_len +=\n      snprintf(cluster_data.name + tmp_folder_len,\n               FIO_CLUSTER_NAME_LIMIT - tmp_folder_len, \"%d\", (int)getpid());\n  cluster_data.name[tmp_folder_len] = 0;\n\n  /* remove if existing */\n  unlink(cluster_data.name);\n  /* add cleanup callback */\n  fio_state_callback_add(FIO_CALL_AT_EXIT, fio_cluster_cleanup, NULL);\n}\n\n/* *****************************************************************************\n * Cluster Protocol callbacks\n **************************************************************************** */\n\nstatic inline void fio_cluster_protocol_free(void *pr) { fio_free(pr); }\n\nstatic uint8_t fio_cluster_on_shutdown(intptr_t uuid, fio_protocol_s *pr_) {\n  cluster_pr_s *p = (cluster_pr_s *)pr_;\n  p->sender(fio_msg_internal_create(0, FIO_CLUSTER_MSG_SHUTDOWN,\n                                    (fio_str_info_s){.len = 0},\n                                    (fio_str_info_s){.len = 0}, 0, 1),\n            -1);\n  return 255;\n  (void)pr_;\n  (void)uuid;\n}\n\nstatic void fio_cluster_on_data(intptr_t uuid, fio_protocol_s *pr_) {\n  cluster_pr_s *c = (cluster_pr_s *)pr_;\n  ssize_t i =\n      fio_read(uuid, c->buffer + c->length, CLUSTER_READ_BUFFER - c->length);\n  if (i <= 0)\n    return;\n  c->length += i;\n  i = 0;\n  do {\n    if (!c->exp_channel && !c->exp_msg) {\n      if (c->length - i < 16)\n        break;\n      c->exp_channel = fio_str2u32(c->buffer + i) + 1;\n      c->exp_msg = fio_str2u32(c->buffer + i + 4) + 1;\n      c->type = fio_str2u32(c->buffer + i + 8);\n      c->filter = (int32_t)fio_str2u32(c->buffer + i + 12);\n      if (c->exp_channel) {\n        if (c->exp_channel >= (1024 * 1024 * 16) + 1) {\n          FIO_LOG_FATAL(\"(%d) cluster message name too long (16Mb limit): %u\\n\",\n                        (int)getpid(), (unsigned int)c->exp_channel);\n          exit(1);\n          return;\n        }\n      }\n      if (c->exp_msg) {\n        if (c->exp_msg >= (1024 * 1024 * 64) + 1) {\n          FIO_LOG_FATAL(\"(%d) cluster message data too long (64Mb limit): %u\\n\",\n                        (int)getpid(), (unsigned int)c->exp_msg);\n          exit(1);\n          return;\n        }\n      }\n      c->msg = fio_msg_internal_create(\n          c->filter, c->type,\n          (fio_str_info_s){.data = (char *)(c->msg + 1),\n                           .len = c->exp_channel - 1},\n          (fio_str_info_s){.data = ((char *)(c->msg + 1) + c->exp_channel + 1),\n                           .len = c->exp_msg - 1},\n          (int8_t)(c->type == FIO_CLUSTER_MSG_JSON ||\n                   c->type == FIO_CLUSTER_MSG_ROOT_JSON),\n          0);\n      i += 16;\n    }\n    if (c->exp_channel) {\n      if (c->exp_channel + i > c->length) {\n        memcpy(c->msg->channel.data +\n                   ((c->msg->channel.len + 1) - c->exp_channel),\n               (char *)c->buffer + i, (size_t)(c->length - i));\n        c->exp_channel -= (c->length - i);\n        i = c->length;\n        break;\n      } else {\n        memcpy(c->msg->channel.data +\n                   ((c->msg->channel.len + 1) - c->exp_channel),\n               (char *)c->buffer + i, (size_t)(c->exp_channel));\n        i += c->exp_channel;\n        c->exp_channel = 0;\n      }\n    }\n    if (c->exp_msg) {\n      if (c->exp_msg + i > c->length) {\n        memcpy(c->msg->data.data + ((c->msg->data.len + 1) - c->exp_msg),\n               (char *)c->buffer + i, (size_t)(c->length - i));\n        c->exp_msg -= (c->length - i);\n        i = c->length;\n        break;\n      } else {\n        memcpy(c->msg->data.data + ((c->msg->data.len + 1) - c->exp_msg),\n               (char *)c->buffer + i, (size_t)(c->exp_msg));\n        i += c->exp_msg;\n        c->exp_msg = 0;\n      }\n    }\n    fio_postoffice_meta_update(c->msg);\n    c->handler(c);\n    fio_msg_internal_free(c->msg);\n    c->msg = NULL;\n  } while (c->length > i);\n  c->length -= i;\n  if (c->length && i) {\n    memmove(c->buffer, c->buffer + i, c->length);\n  }\n  (void)pr_;\n}\n\nstatic void fio_cluster_ping(intptr_t uuid, fio_protocol_s *pr_) {\n  fio_msg_internal_s *m = fio_msg_internal_create(\n      0, FIO_CLUSTER_MSG_PING, (fio_str_info_s){.len = 0},\n      (fio_str_info_s){.len = 0}, 0, 1);\n  fio_msg_internal_send_dup(uuid, m);\n  fio_msg_internal_free(m);\n  (void)pr_;\n}\n\nstatic void fio_cluster_on_close(intptr_t uuid, fio_protocol_s *pr_) {\n  cluster_pr_s *c = (cluster_pr_s *)pr_;\n  if (!fio_data->is_worker) {\n    /* a child was lost, respawning is handled elsewhere. */\n    fio_lock(&cluster_data.lock);\n    FIO_LS_FOR(&cluster_data.clients, pos) {\n      if (pos->obj == (void *)uuid) {\n        fio_ls_remove(pos);\n        break;\n      }\n    }\n    fio_unlock(&cluster_data.lock);\n  } else if (fio_data->active) {\n    /* no shutdown message received - parent crashed. */\n    if (c->type != FIO_CLUSTER_MSG_SHUTDOWN && fio_is_running()) {\n      FIO_LOG_FATAL(\"(%d) Parent Process crash detected!\", (int)getpid());\n      fio_state_callback_force(FIO_CALL_ON_PARENT_CRUSH);\n      fio_state_callback_clear(FIO_CALL_ON_PARENT_CRUSH);\n      fio_cluster_data_cleanup(1);\n      kill(getpid(), SIGINT);\n    }\n  }\n  if (c->msg)\n    fio_msg_internal_free(c->msg);\n  c->msg = NULL;\n  fio_sub_hash_free(&c->pubsub);\n  fio_cluster_protocol_free(c);\n  (void)uuid;\n}\n\nstatic inline fio_protocol_s *\nfio_cluster_protocol_alloc(intptr_t uuid,\n                           void (*handler)(struct cluster_pr_s *pr),\n                           void (*sender)(void *data, intptr_t auuid)) {\n  cluster_pr_s *p = fio_mmap(sizeof(*p));\n  if (!p) {\n    FIO_LOG_FATAL(\"Cluster protocol allocation failed.\");\n    exit(errno);\n  }\n  p->protocol = (fio_protocol_s){\n      .ping = fio_cluster_ping,\n      .on_close = fio_cluster_on_close,\n      .on_shutdown = fio_cluster_on_shutdown,\n      .on_data = fio_cluster_on_data,\n  };\n  p->uuid = uuid;\n  p->handler = handler;\n  p->sender = sender;\n  p->pubsub = (fio_sub_hash_s)FIO_SET_INIT;\n  p->patterns = (fio_sub_hash_s)FIO_SET_INIT;\n  p->lock = FIO_LOCK_INIT;\n  return &p->protocol;\n}\n\n/* *****************************************************************************\n * Master (server) IPC Connections\n **************************************************************************** */\n\nstatic void fio_cluster_server_sender(void *m_, intptr_t avoid_uuid) {\n  fio_msg_internal_s *m = m_;\n  fio_lock(&cluster_data.lock);\n  FIO_LS_FOR(&cluster_data.clients, pos) {\n    if ((intptr_t)pos->obj != -1) {\n      if ((intptr_t)pos->obj != avoid_uuid) {\n        fio_msg_internal_send_dup((intptr_t)pos->obj, m);\n      }\n    }\n  }\n  fio_unlock(&cluster_data.lock);\n  fio_msg_internal_free(m);\n}\n\nstatic void fio_cluster_server_handler(struct cluster_pr_s *pr) {\n  /* what to do? */\n  // fprintf(stderr, \"-\");\n  switch ((fio_cluster_message_type_e)pr->type) {\n\n  case FIO_CLUSTER_MSG_FORWARD: /* fallthrough */\n  case FIO_CLUSTER_MSG_JSON: {\n    fio_cluster_server_sender(fio_msg_internal_dup(pr->msg), pr->uuid);\n    fio_publish2process(fio_msg_internal_dup(pr->msg));\n    break;\n  }\n\n  case FIO_CLUSTER_MSG_PUBSUB_SUB: {\n    subscription_s *s =\n        fio_subscribe(.on_message = fio_mock_on_message, .match = NULL,\n                      .channel = pr->msg->channel);\n    fio_str_s tmp = FIO_STR_INIT_EXISTING(\n        pr->msg->channel.data, pr->msg->channel.len, 0); // don't free\n    fio_lock(&pr->lock);\n    fio_sub_hash_insert(&pr->pubsub,\n                        FIO_HASH_FN(pr->msg->channel.data, pr->msg->channel.len,\n                                    &fio_postoffice.pubsub,\n                                    &fio_postoffice.pubsub),\n                        tmp, s, NULL);\n    fio_unlock(&pr->lock);\n    break;\n  }\n  case FIO_CLUSTER_MSG_PUBSUB_UNSUB: {\n    fio_str_s tmp = FIO_STR_INIT_EXISTING(\n        pr->msg->channel.data, pr->msg->channel.len, 0); // don't free\n    fio_lock(&pr->lock);\n    fio_sub_hash_remove(&pr->pubsub,\n                        FIO_HASH_FN(pr->msg->channel.data, pr->msg->channel.len,\n                                    &fio_postoffice.pubsub,\n                                    &fio_postoffice.pubsub),\n                        tmp, NULL);\n    fio_unlock(&pr->lock);\n    break;\n  }\n\n  case FIO_CLUSTER_MSG_PATTERN_SUB: {\n    uintptr_t match = fio_str2u64(pr->msg->data.data);\n    subscription_s *s = fio_subscribe(.on_message = fio_mock_on_message,\n                                      .match = (fio_match_fn)match,\n                                      .channel = pr->msg->channel);\n    fio_str_s tmp = FIO_STR_INIT_EXISTING(\n        pr->msg->channel.data, pr->msg->channel.len, 0); // don't free\n    fio_lock(&pr->lock);\n    fio_sub_hash_insert(&pr->patterns,\n                        FIO_HASH_FN(pr->msg->channel.data, pr->msg->channel.len,\n                                    &fio_postoffice.pubsub,\n                                    &fio_postoffice.pubsub),\n                        tmp, s, NULL);\n    fio_unlock(&pr->lock);\n    break;\n  }\n\n  case FIO_CLUSTER_MSG_PATTERN_UNSUB: {\n    fio_str_s tmp = FIO_STR_INIT_EXISTING(\n        pr->msg->channel.data, pr->msg->channel.len, 0); // don't free\n    fio_lock(&pr->lock);\n    fio_sub_hash_remove(&pr->patterns,\n                        FIO_HASH_FN(pr->msg->channel.data, pr->msg->channel.len,\n                                    &fio_postoffice.pubsub,\n                                    &fio_postoffice.pubsub),\n                        tmp, NULL);\n    fio_unlock(&pr->lock);\n    break;\n  }\n\n  case FIO_CLUSTER_MSG_ROOT_JSON:\n    pr->type = FIO_CLUSTER_MSG_JSON; /* fallthrough */\n  case FIO_CLUSTER_MSG_ROOT:\n    fio_publish2process(fio_msg_internal_dup(pr->msg));\n    break;\n\n  case FIO_CLUSTER_MSG_SHUTDOWN: /* fallthrough */\n  case FIO_CLUSTER_MSG_ERROR:    /* fallthrough */\n  case FIO_CLUSTER_MSG_PING:     /* fallthrough */\n  default:\n    break;\n  }\n}\n\n/** Called when a ne client is available */\nstatic void fio_cluster_listen_accept(intptr_t uuid, fio_protocol_s *protocol) {\n  (void)protocol;\n  /* prevent `accept` backlog in parent */\n  intptr_t client;\n  while ((client = fio_accept(uuid)) != -1) {\n    fio_attach(client,\n               fio_cluster_protocol_alloc(client, fio_cluster_server_handler,\n                                          fio_cluster_server_sender));\n    fio_lock(&cluster_data.lock);\n    fio_ls_push(&cluster_data.clients, (void *)client);\n    fio_unlock(&cluster_data.lock);\n  }\n}\n\n/** Called when the connection was closed, but will not run concurrently */\nstatic void fio_cluster_listen_on_close(intptr_t uuid,\n                                        fio_protocol_s *protocol) {\n  free(protocol);\n  cluster_data.uuid = -1;\n  if (fio_parent_pid() == getpid()) {\n#if DEBUG\n    FIO_LOG_DEBUG(\"(%d) stopped listening for cluster connections\",\n                  (int)getpid());\n#endif\n    if (fio_data->active)\n      fio_stop();\n  }\n  (void)uuid;\n}\n\nstatic void fio_listen2cluster(void *ignore) {\n  /* this is called for each `fork`, but we only need this to run once. */\n  fio_lock(&cluster_data.lock);\n  cluster_data.uuid = fio_socket(cluster_data.name, NULL, 1);\n  fio_unlock(&cluster_data.lock);\n  if (cluster_data.uuid < 0) {\n    FIO_LOG_FATAL(\"(facil.io cluster) failed to open cluster socket.\");\n    perror(\"             check file permissions. errno:\");\n    exit(errno);\n  }\n  fio_protocol_s *p = malloc(sizeof(*p));\n  FIO_ASSERT_ALLOC(p);\n  *p = (fio_protocol_s){\n      .on_data = fio_cluster_listen_accept,\n      .on_shutdown = mock_on_shutdown_eternal,\n      .ping = mock_ping_eternal,\n      .on_close = fio_cluster_listen_on_close,\n  };\n  FIO_LOG_DEBUG(\"(%d) Listening to cluster: %s\", (int)getpid(),\n                cluster_data.name);\n  fio_attach(cluster_data.uuid, p);\n  (void)ignore;\n}\n\n/* *****************************************************************************\n * Worker (client) IPC connections\n **************************************************************************** */\n\nstatic void fio_cluster_client_handler(struct cluster_pr_s *pr) {\n  /* what to do? */\n  switch ((fio_cluster_message_type_e)pr->type) {\n  case FIO_CLUSTER_MSG_FORWARD: /* fallthrough */\n  case FIO_CLUSTER_MSG_JSON:\n    fio_publish2process(fio_msg_internal_dup(pr->msg));\n    break;\n  case FIO_CLUSTER_MSG_SHUTDOWN:\n    fio_stop();\n  case FIO_CLUSTER_MSG_ERROR:         /* fallthrough */\n  case FIO_CLUSTER_MSG_PING:          /* fallthrough */\n  case FIO_CLUSTER_MSG_ROOT:          /* fallthrough */\n  case FIO_CLUSTER_MSG_ROOT_JSON:     /* fallthrough */\n  case FIO_CLUSTER_MSG_PUBSUB_SUB:    /* fallthrough */\n  case FIO_CLUSTER_MSG_PUBSUB_UNSUB:  /* fallthrough */\n  case FIO_CLUSTER_MSG_PATTERN_SUB:   /* fallthrough */\n  case FIO_CLUSTER_MSG_PATTERN_UNSUB: /* fallthrough */\n\n  default:\n    break;\n  }\n}\nstatic void fio_cluster_client_sender(void *m_, intptr_t ignr_) {\n  fio_msg_internal_s *m = m_;\n  if (!uuid_is_valid(cluster_data.uuid) && fio_data->active) {\n    /* delay message delivery until we have a vaild uuid */\n    fio_defer_push_task((void (*)(void *, void *))fio_cluster_client_sender, m_,\n                        (void *)ignr_);\n    return;\n  }\n  fio_msg_internal_send_dup(cluster_data.uuid, m);\n  fio_msg_internal_free(m);\n}\n\n/** The address of the server we are connecting to. */\n// char *address;\n/** The port on the server we are connecting to. */\n// char *port;\n/**\n * The `on_connect` callback should return a pointer to a protocol object\n * that will handle any connection related events.\n *\n * Should either call `facil_attach` or close the connection.\n */\nstatic void fio_cluster_on_connect(intptr_t uuid, void *udata) {\n  cluster_data.uuid = uuid;\n\n  /* inform root about all existing channels */\n  fio_lock(&fio_postoffice.pubsub.lock);\n  FIO_SET_FOR_LOOP(&fio_postoffice.pubsub.channels, pos) {\n    if (!pos->hash) {\n      continue;\n    }\n    fio_cluster_inform_root_about_channel(pos->obj, 1);\n  }\n  fio_unlock(&fio_postoffice.pubsub.lock);\n  fio_lock(&fio_postoffice.patterns.lock);\n  FIO_SET_FOR_LOOP(&fio_postoffice.patterns.channels, pos) {\n    if (!pos->hash) {\n      continue;\n    }\n    fio_cluster_inform_root_about_channel(pos->obj, 1);\n  }\n  fio_unlock(&fio_postoffice.patterns.lock);\n\n  fio_attach(uuid, fio_cluster_protocol_alloc(uuid, fio_cluster_client_handler,\n                                              fio_cluster_client_sender));\n  (void)udata;\n}\n/**\n * The `on_fail` is called when a socket fails to connect. The old sock UUID\n * is passed along.\n */\nstatic void fio_cluster_on_fail(intptr_t uuid, void *udata) {\n  FIO_LOG_FATAL(\"(facil.io) unknown cluster connection error\");\n  perror(\"       errno\");\n  kill(fio_parent_pid(), SIGINT);\n  fio_stop();\n  // exit(errno ? errno : 1);\n  (void)udata;\n  (void)uuid;\n}\n\nstatic void fio_connect2cluster(void *ignore) {\n  if (cluster_data.uuid)\n    fio_force_close(cluster_data.uuid);\n  cluster_data.uuid = 0;\n  /* this is called for each child, but not for single a process worker. */\n  fio_connect(.address = cluster_data.name, .port = NULL,\n              .on_connect = fio_cluster_on_connect,\n              .on_fail = fio_cluster_on_fail);\n  (void)ignore;\n}\n\nstatic void fio_send2cluster(fio_msg_internal_s *m) {\n  if (!fio_is_running()) {\n    FIO_LOG_ERROR(\"facio.io cluster inactive, can't send message.\");\n    return;\n  }\n  if (fio_data->workers == 1) {\n    /* nowhere to send to */\n    return;\n  }\n  if (fio_is_master()) {\n    fio_cluster_server_sender(fio_msg_internal_dup(m), -1);\n  } else {\n    fio_cluster_client_sender(fio_msg_internal_dup(m), -1);\n  }\n}\n\n/* *****************************************************************************\n * Propegation\n **************************************************************************** */\n\nstatic inline void fio_cluster_inform_root_about_channel(channel_s *ch,\n                                                         int add) {\n  if (!fio_data->is_worker || fio_data->workers == 1 || !cluster_data.uuid ||\n      !ch)\n    return;\n  fio_str_info_s ch_name = {.data = ch->name, .len = ch->name_len};\n  fio_str_info_s msg = {.data = NULL, .len = 0};\n#if DEBUG\n  FIO_LOG_DEBUG(\"(%d) informing root about: %s (%zu) msg type %d\",\n                (int)getpid(), ch_name.data, ch_name.len,\n                (ch->match ? (add ? FIO_CLUSTER_MSG_PATTERN_SUB\n                                  : FIO_CLUSTER_MSG_PATTERN_UNSUB)\n                           : (add ? FIO_CLUSTER_MSG_PUBSUB_SUB\n                                  : FIO_CLUSTER_MSG_PUBSUB_UNSUB)));\n#endif\n  char buf[8] = {0};\n  if (ch->match) {\n    fio_u2str64(buf, (uint64_t)ch->match);\n    msg.data = buf;\n    msg.len = sizeof(ch->match);\n  }\n\n  fio_cluster_client_sender(\n      fio_msg_internal_create(0,\n                              (ch->match\n                                   ? (add ? FIO_CLUSTER_MSG_PATTERN_SUB\n                                          : FIO_CLUSTER_MSG_PATTERN_UNSUB)\n                                   : (add ? FIO_CLUSTER_MSG_PUBSUB_SUB\n                                          : FIO_CLUSTER_MSG_PUBSUB_UNSUB)),\n                              ch_name, msg, 0, 1),\n      -1);\n}\n\n/* *****************************************************************************\n * Initialization\n **************************************************************************** */\n\nstatic void fio_accept_after_fork(void *ignore) {\n  /* prevent `accept` backlog in parent */\n  fio_cluster_listen_accept(cluster_data.uuid, NULL);\n  (void)ignore;\n}\n\nstatic void fio_cluster_at_exit(void *ignore) {\n  /* unlock all */\n  fio_pubsub_on_fork();\n  /* clear subscriptions of all types */\n  while (fio_ch_set_count(&fio_postoffice.patterns.channels)) {\n    channel_s *ch = fio_ch_set_last(&fio_postoffice.patterns.channels);\n    while (fio_ls_embd_any(&ch->subscriptions)) {\n      subscription_s *sub =\n          FIO_LS_EMBD_OBJ(subscription_s, node, ch->subscriptions.next);\n      fio_unsubscribe(sub);\n    }\n    fio_ch_set_pop(&fio_postoffice.patterns.channels);\n  }\n\n  while (fio_ch_set_count(&fio_postoffice.pubsub.channels)) {\n    channel_s *ch = fio_ch_set_last(&fio_postoffice.pubsub.channels);\n    while (fio_ls_embd_any(&ch->subscriptions)) {\n      subscription_s *sub =\n          FIO_LS_EMBD_OBJ(subscription_s, node, ch->subscriptions.next);\n      fio_unsubscribe(sub);\n    }\n    fio_ch_set_pop(&fio_postoffice.pubsub.channels);\n  }\n\n  while (fio_ch_set_count(&fio_postoffice.filters.channels)) {\n    channel_s *ch = fio_ch_set_last(&fio_postoffice.filters.channels);\n    while (fio_ls_embd_any(&ch->subscriptions)) {\n      subscription_s *sub =\n          FIO_LS_EMBD_OBJ(subscription_s, node, ch->subscriptions.next);\n      fio_unsubscribe(sub);\n    }\n    fio_ch_set_pop(&fio_postoffice.filters.channels);\n  }\n  fio_ch_set_free(&fio_postoffice.filters.channels);\n  fio_ch_set_free(&fio_postoffice.patterns.channels);\n  fio_ch_set_free(&fio_postoffice.pubsub.channels);\n\n  /* clear engines */\n  FIO_PUBSUB_DEFAULT = FIO_PUBSUB_CLUSTER;\n  while (fio_engine_set_count(&fio_postoffice.engines.set)) {\n    fio_pubsub_detach(fio_engine_set_last(&fio_postoffice.engines.set));\n    fio_engine_set_last(&fio_postoffice.engines.set);\n  }\n  fio_engine_set_free(&fio_postoffice.engines.set);\n\n  /* clear meta hooks */\n  fio_meta_ary_free(&fio_postoffice.meta.ary);\n  /* perform newly created tasks */\n  fio_defer_perform();\n  (void)ignore;\n}\n\nstatic void fio_pubsub_initialize(void) {\n  fio_cluster_init();\n  fio_state_callback_add(FIO_CALL_PRE_START, fio_listen2cluster, NULL);\n  fio_state_callback_add(FIO_CALL_IN_MASTER, fio_accept_after_fork, NULL);\n  fio_state_callback_add(FIO_CALL_IN_CHILD, fio_connect2cluster, NULL);\n  fio_state_callback_add(FIO_CALL_ON_FINISH, fio_cluster_cleanup, NULL);\n  fio_state_callback_add(FIO_CALL_AT_EXIT, fio_cluster_at_exit, NULL);\n}\n\n/* *****************************************************************************\nCluster forking handler\n***************************************************************************** */\n\nstatic void fio_pubsub_on_fork(void) {\n  fio_postoffice.filters.lock = FIO_LOCK_INIT;\n  fio_postoffice.pubsub.lock = FIO_LOCK_INIT;\n  fio_postoffice.patterns.lock = FIO_LOCK_INIT;\n  fio_postoffice.engines.lock = FIO_LOCK_INIT;\n  fio_postoffice.meta.lock = FIO_LOCK_INIT;\n  cluster_data.lock = FIO_LOCK_INIT;\n  cluster_data.uuid = 0;\n  FIO_SET_FOR_LOOP(&fio_postoffice.filters.channels, pos) {\n    if (!pos->hash)\n      continue;\n    pos->obj->lock = FIO_LOCK_INIT;\n    FIO_LS_EMBD_FOR(&pos->obj->subscriptions, n) {\n      FIO_LS_EMBD_OBJ(subscription_s, node, n)->lock = FIO_LOCK_INIT;\n    }\n  }\n  FIO_SET_FOR_LOOP(&fio_postoffice.pubsub.channels, pos) {\n    if (!pos->hash)\n      continue;\n    pos->obj->lock = FIO_LOCK_INIT;\n    FIO_LS_EMBD_FOR(&pos->obj->subscriptions, n) {\n      FIO_LS_EMBD_OBJ(subscription_s, node, n)->lock = FIO_LOCK_INIT;\n    }\n  }\n  FIO_SET_FOR_LOOP(&fio_postoffice.patterns.channels, pos) {\n    if (!pos->hash)\n      continue;\n    pos->obj->lock = FIO_LOCK_INIT;\n    FIO_LS_EMBD_FOR(&pos->obj->subscriptions, n) {\n      FIO_LS_EMBD_OBJ(subscription_s, node, n)->lock = FIO_LOCK_INIT;\n    }\n  }\n}\n\n/* *****************************************************************************\n * External API\n **************************************************************************** */\n\n/** Signals children (or self) to shutdown) - NOT signal safe. */\nstatic void fio_cluster_signal_children(void) {\n  if (fio_parent_pid() != getpid()) {\n    fio_stop();\n    return;\n  }\n  fio_cluster_server_sender(fio_msg_internal_create(0, FIO_CLUSTER_MSG_SHUTDOWN,\n                                                    (fio_str_info_s){.len = 0},\n                                                    (fio_str_info_s){.len = 0},\n                                                    0, 1),\n                            -1);\n}\n\n/* Sublime Text marker */\nvoid fio_publish___(fio_publish_args_s args);\n/**\n * Publishes a message to the relevant subscribers (if any).\n *\n * See `facil_publish_args_s` for details.\n *\n * By default the message is sent using the FIO_PUBSUB_CLUSTER engine (all\n * processes, including the calling process).\n *\n * To limit the message only to other processes (exclude the calling process),\n * use the FIO_PUBSUB_SIBLINGS engine.\n *\n * To limit the message only to the calling process, use the\n * FIO_PUBSUB_PROCESS engine.\n *\n * To publish messages to the pub/sub layer, the `.filter` argument MUST be\n * equal to 0 or missing.\n */\nvoid fio_publish FIO_IGNORE_MACRO(fio_publish_args_s args) {\n  if (args.filter && !args.engine) {\n    args.engine = FIO_PUBSUB_CLUSTER;\n  } else if (!args.engine) {\n    args.engine = FIO_PUBSUB_DEFAULT;\n  }\n  fio_msg_internal_s *m = NULL;\n  switch ((uintptr_t)args.engine) {\n  case 0UL: /* fallthrough (missing default) */\n  case 1UL: // ((uintptr_t)FIO_PUBSUB_CLUSTER):\n    m = fio_msg_internal_create(\n        args.filter,\n        (args.is_json ? FIO_CLUSTER_MSG_JSON : FIO_CLUSTER_MSG_FORWARD),\n        args.channel, args.message, args.is_json, 1);\n    fio_send2cluster(m);\n    fio_publish2process(m);\n    break;\n  case 2UL: // ((uintptr_t)FIO_PUBSUB_PROCESS):\n    m = fio_msg_internal_create(args.filter, 0, args.channel, args.message,\n                                args.is_json, 1);\n    fio_publish2process(m);\n    break;\n  case 3UL: // ((uintptr_t)FIO_PUBSUB_SIBLINGS):\n    m = fio_msg_internal_create(\n        args.filter,\n        (args.is_json ? FIO_CLUSTER_MSG_JSON : FIO_CLUSTER_MSG_FORWARD),\n        args.channel, args.message, args.is_json, 1);\n    fio_send2cluster(m);\n    fio_msg_internal_free(m);\n    m = NULL;\n    break;\n  case 4UL: // ((uintptr_t)FIO_PUBSUB_ROOT):\n    m = fio_msg_internal_create(\n        args.filter,\n        (args.is_json ? FIO_CLUSTER_MSG_ROOT_JSON : FIO_CLUSTER_MSG_ROOT),\n        args.channel, args.message, args.is_json, 1);\n    if (fio_data->is_worker == 0 || fio_data->workers == 1) {\n      fio_publish2process(m);\n    } else {\n      fio_cluster_client_sender(m, -1);\n    }\n    break;\n  default:\n    if (args.filter != 0) {\n      FIO_LOG_ERROR(\"(pub/sub) pub/sub engines can only be used for \"\n                    \"pub/sub messages (no filter).\");\n      return;\n    }\n    args.engine->publish(args.engine, args.channel, args.message, args.is_json);\n  }\n  return;\n}\n\n/* *****************************************************************************\n * Glob Matching\n **************************************************************************** */\n\n/** A binary glob matching helper. Returns 1 on match, otherwise returns 0. */\nstatic int fio_glob_match(fio_str_info_s pat, fio_str_info_s ch) {\n  /* adapted and rewritten, with thankfulness, from the code at:\n   * https://github.com/opnfv/kvmfornfv/blob/master/kernel/lib/glob.c\n   *\n   * Original version's copyright:\n   * Copyright 2015 Open Platform for NFV Project, Inc. and its contributors\n   * Under the MIT license.\n   */\n\n  /*\n   * Backtrack to previous * on mismatch and retry starting one\n   * character later in the string.  Because * matches all characters,\n   * there's never a need to backtrack multiple levels.\n   */\n  uint8_t *back_pat = NULL, *back_str = (uint8_t *)ch.data;\n  size_t back_pat_len = 0, back_str_len = ch.len;\n\n  /*\n   * Loop over each token (character or class) in pat, matching\n   * it against the remaining unmatched tail of str.  Return false\n   * on mismatch, or true after matching the trailing nul bytes.\n   */\n  while (ch.len) {\n    uint8_t c = *(uint8_t *)ch.data++;\n    uint8_t d = *(uint8_t *)pat.data++;\n    ch.len--;\n    pat.len--;\n\n    switch (d) {\n    case '?': /* Wildcard: anything goes */\n      break;\n\n    case '*':       /* Any-length wildcard */\n      if (!pat.len) /* Optimize trailing * case */\n        return 1;\n      back_pat = (uint8_t *)pat.data;\n      back_pat_len = pat.len;\n      back_str = (uint8_t *)--ch.data; /* Allow zero-length match */\n      back_str_len = ++ch.len;\n      break;\n\n    case '[': { /* Character class */\n      uint8_t match = 0, inverted = (*(uint8_t *)pat.data == '^');\n      uint8_t *cls = (uint8_t *)pat.data + inverted;\n      uint8_t a = *cls++;\n\n      /*\n       * Iterate over each span in the character class.\n       * A span is either a single character a, or a\n       * range a-b.  The first span may begin with ']'.\n       */\n      do {\n        uint8_t b = a;\n\n        if (cls[0] == '-' && cls[1] != ']') {\n          b = cls[1];\n\n          cls += 2;\n          if (a > b) {\n            uint8_t tmp = a;\n            a = b;\n            b = tmp;\n          }\n        }\n        match |= (a <= c && c <= b);\n      } while ((a = *cls++) != ']');\n\n      if (match == inverted)\n        goto backtrack;\n      pat.len -= cls - (uint8_t *)pat.data;\n      pat.data = (char *)cls;\n\n    } break;\n    case '\\\\':\n      d = *(uint8_t *)pat.data++;\n      pat.len--;\n    /* fallthrough */\n    default: /* Literal character */\n      if (c == d)\n        break;\n    backtrack:\n      if (!back_pat)\n        return 0; /* No point continuing */\n      /* Try again from last *, one character later in str. */\n      pat.data = (char *)back_pat;\n      ch.data = (char *)++back_str;\n      ch.len = --back_str_len;\n      pat.len = back_pat_len;\n    }\n  }\n  return !ch.len && !pat.len;\n}\n\nfio_match_fn FIO_MATCH_GLOB = fio_glob_match;\n\n#else /* FIO_PUBSUB_SUPPORT */\n\nstatic void fio_pubsub_on_fork(void) {}\nstatic void fio_cluster_init(void) {}\nstatic void fio_cluster_signal_children(void) {}\n\n#endif /* FIO_PUBSUB_SUPPORT */\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                   Memory Allocator Details & Implementation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/* *****************************************************************************\nAllocator default settings\n***************************************************************************** */\n\n/* doun't change these */\n#undef FIO_MEMORY_BLOCK_SLICES\n#undef FIO_MEMORY_BLOCK_HEADER_SIZE\n#undef FIO_MEMORY_BLOCK_START_POS\n#undef FIO_MEMORY_MAX_SLICES_PER_BLOCK\n#undef FIO_MEMORY_BLOCK_MASK\n\n/* The number of blocks pre-allocated each system call, 256 ==8Mb */\n#ifndef FIO_MEMORY_BLOCKS_PER_ALLOCATION\n#define FIO_MEMORY_BLOCKS_PER_ALLOCATION 256\n#endif\n\n#define FIO_MEMORY_BLOCK_MASK (FIO_MEMORY_BLOCK_SIZE - 1) /* 0b0...1... */\n\n#define FIO_MEMORY_BLOCK_SLICES (FIO_MEMORY_BLOCK_SIZE >> 4) /* 16B slices */\n\n/* must be divisable by 16 bytes, bigger than min(sizeof(block_s), 16) */\n#define FIO_MEMORY_BLOCK_HEADER_SIZE 32\n\n/* allocation counter position (start) */\n#define FIO_MEMORY_BLOCK_START_POS (FIO_MEMORY_BLOCK_HEADER_SIZE >> 4)\n\n#define FIO_MEMORY_MAX_SLICES_PER_BLOCK                                        \\\n  (FIO_MEMORY_BLOCK_SLICES - FIO_MEMORY_BLOCK_START_POS)\n\n/* *****************************************************************************\nFIO_FORCE_MALLOC handler\n***************************************************************************** */\n\n#if FIO_FORCE_MALLOC\n\nvoid *fio_malloc(size_t size) { return calloc(size, 1); }\n\nvoid *fio_calloc(size_t size_per_unit, size_t unit_count) {\n  return calloc(size_per_unit, unit_count);\n}\n\nvoid fio_free(void *ptr) { free(ptr); }\n\nvoid *fio_realloc(void *ptr, size_t new_size) {\n  return realloc((ptr), (new_size));\n}\n\nvoid *fio_realloc2(void *ptr, size_t new_size, size_t copy_length) {\n  return realloc((ptr), (new_size));\n  (void)copy_length;\n}\n\nvoid *fio_mmap(size_t size) { return calloc(size, 1); }\n\nvoid fio_malloc_after_fork(void) {}\nvoid fio_mem_destroy(void) {}\nvoid fio_mem_init(void) {}\n\n#else\n\n/* *****************************************************************************\nMemory Copying by 16 byte units\n***************************************************************************** */\n\n/** used internally, only when memory addresses are known to be aligned */\nstatic inline void fio_memcpy(void *__restrict dest_, void *__restrict src_,\n                              size_t units) {\n#if __SIZEOF_INT128__ == 9 /* a 128bit type exists... but tests favor 64bit */\n  register __uint128_t *dest = dest_;\n  register __uint128_t *src = src_;\n#elif SIZE_MAX == 0xFFFFFFFFFFFFFFFF /* 64 bit size_t */\n  register size_t *dest = dest_;\n  register size_t *src = src_;\n  units = units << 1;\n#elif SIZE_MAX == 0xFFFFFFFF         /* 32 bit size_t */\n  register size_t *dest = dest_;\n  register size_t *src = src_;\n  units = units << 2;\n#else                                /* unknow... assume 16 bit? */\n  register size_t *dest = dest_;\n  register size_t *src = src_;\n  units = units << 3;\n#endif\n  while (units >= 16) { /* unroll loop */\n    dest[0] = src[0];\n    dest[1] = src[1];\n    dest[2] = src[2];\n    dest[3] = src[3];\n    dest[4] = src[4];\n    dest[5] = src[5];\n    dest[6] = src[6];\n    dest[7] = src[7];\n    dest[8] = src[8];\n    dest[9] = src[9];\n    dest[10] = src[10];\n    dest[11] = src[11];\n    dest[12] = src[12];\n    dest[13] = src[13];\n    dest[14] = src[14];\n    dest[15] = src[15];\n    dest += 16;\n    src += 16;\n    units -= 16;\n  }\n  switch (units) {\n  case 15:\n    *(dest++) = *(src++); /* fallthrough */\n  case 14:\n    *(dest++) = *(src++); /* fallthrough */\n  case 13:\n    *(dest++) = *(src++); /* fallthrough */\n  case 12:\n    *(dest++) = *(src++); /* fallthrough */\n  case 11:\n    *(dest++) = *(src++); /* fallthrough */\n  case 10:\n    *(dest++) = *(src++); /* fallthrough */\n  case 9:\n    *(dest++) = *(src++); /* fallthrough */\n  case 8:\n    *(dest++) = *(src++); /* fallthrough */\n  case 7:\n    *(dest++) = *(src++); /* fallthrough */\n  case 6:\n    *(dest++) = *(src++); /* fallthrough */\n  case 5:\n    *(dest++) = *(src++); /* fallthrough */\n  case 4:\n    *(dest++) = *(src++); /* fallthrough */\n  case 3:\n    *(dest++) = *(src++); /* fallthrough */\n  case 2:\n    *(dest++) = *(src++); /* fallthrough */\n  case 1:\n    *(dest++) = *(src++);\n  }\n}\n\n/* *****************************************************************************\nSystem Memory wrappers\n***************************************************************************** */\n\n/*\n * allocates memory using `mmap`, but enforces block size alignment.\n * requires page aligned `len`.\n *\n * `align_shift` is used to move the memory page alignment to allow for a single\n * page allocation header. align_shift MUST be either 0 (normal) or 1 (single\n * page header). Other values might cause errors.\n */\nstatic inline void *sys_alloc(size_t len, uint8_t is_indi) {\n  void *result;\n  static void *next_alloc = NULL;\n/* hope for the best? */\n#ifdef MAP_ALIGNED\n  result =\n      mmap(next_alloc, len, PROT_READ | PROT_WRITE,\n           MAP_PRIVATE | MAP_ANONYMOUS | MAP_ALIGNED(FIO_MEMORY_BLOCK_SIZE_LOG),\n           -1, 0);\n#else\n  result = mmap(next_alloc, len, PROT_READ | PROT_WRITE,\n                MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n#endif\n  if (result == MAP_FAILED)\n    return NULL;\n  if (((uintptr_t)result & FIO_MEMORY_BLOCK_MASK)) {\n    munmap(result, len);\n    result = mmap(NULL, len + FIO_MEMORY_BLOCK_SIZE, PROT_READ | PROT_WRITE,\n                  MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    if (result == MAP_FAILED) {\n      return NULL;\n    }\n    const uintptr_t offset =\n        (FIO_MEMORY_BLOCK_SIZE - ((uintptr_t)result & FIO_MEMORY_BLOCK_MASK));\n    if (offset) {\n      munmap(result, offset);\n      result = (void *)((uintptr_t)result + offset);\n    }\n    munmap((void *)((uintptr_t)result + len), FIO_MEMORY_BLOCK_SIZE - offset);\n  }\n  if (is_indi ==\n      0) /* advance by a block's allocation size for next allocation */\n    next_alloc =\n        (void *)((uintptr_t)result +\n                 (FIO_MEMORY_BLOCK_SIZE * (FIO_MEMORY_BLOCKS_PER_ALLOCATION)));\n  else /* add 1TB for realloc */\n    next_alloc = (void *)((uintptr_t)result + (is_indi * ((uintptr_t)1 << 30)));\n  return result;\n}\n\n/* frees memory using `munmap`. requires exact, page aligned, `len` */\nstatic inline void sys_free(void *mem, size_t len) { munmap(mem, len); }\n\nstatic void *sys_realloc(void *mem, size_t prev_len, size_t new_len) {\n  if (new_len > prev_len) {\n    void *result;\n#if defined(__linux__)\n    result = mremap(mem, prev_len, new_len, 0);\n    if (result != MAP_FAILED)\n      return result;\n#endif\n    result = mmap((void *)((uintptr_t)mem + prev_len), new_len - prev_len,\n                  PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    if (result == (void *)((uintptr_t)mem + prev_len)) {\n      result = mem;\n    } else {\n      /* copy and free */\n      munmap(result, new_len - prev_len); /* free the failed attempt */\n      result = sys_alloc(new_len, 1);     /* allocate new memory */\n      if (!result) {\n        return NULL;\n      }\n      fio_memcpy(result, mem, prev_len >> 4); /* copy data */\n      // memcpy(result, mem, prev_len);\n      munmap(mem, prev_len); /* free original memory */\n    }\n    return result;\n  }\n  if (new_len + 4096 < prev_len) /* more than a single dangling page */\n    munmap((void *)((uintptr_t)mem + new_len), prev_len - new_len);\n  return mem;\n}\n\n/** Rounds up any size to the nearest page alignment (assumes 4096 bytes per\n * page) */\nstatic inline size_t sys_round_size(size_t size) {\n  return (size & (~4095)) + (4096 * (!!(size & 4095)));\n}\n\n/* *****************************************************************************\nData Types\n***************************************************************************** */\n\n/* The basic block header. Starts a 32Kib memory block */\ntypedef struct block_s block_s;\n\nstruct block_s {\n  block_s *parent;   /* REQUIRED, root == point to self */\n  uint16_t ref;      /* reference count (per memory page) */\n  uint16_t pos;      /* position into the block */\n  uint16_t max;      /* available memory count */\n  uint16_t root_ref; /* root reference memory padding */\n};\n\ntypedef struct block_node_s block_node_s;\nstruct block_node_s {\n  block_s dont_touch; /* prevent block internal data from being corrupted */\n  fio_ls_embd_s node; /* next block */\n};\n\n/* a per-CPU core \"arena\" for memory allocations  */\ntypedef struct {\n  block_s *block;\n  fio_lock_i lock;\n} arena_s;\n\n/* The memory allocators persistent state */\nstatic struct {\n  fio_ls_embd_s available; /* free list for memory blocks */\n  // intptr_t count;          /* free list counter */\n  size_t cores;    /* the number of detected CPU cores*/\n  fio_lock_i lock; /* a global lock */\n  uint8_t forked;  /* a forked collection indicator. */\n} memory = {\n    .cores = 1,\n    .lock = FIO_LOCK_INIT,\n    .available = FIO_LS_INIT(memory.available),\n};\n\n/* The per-CPU arena array. */\nstatic arena_s *arenas;\n\n/* The per-CPU arena array. */\nstatic long double on_malloc_zero;\n\n#if DEBUG\n/* The per-CPU arena array. */\nstatic size_t fio_mem_block_count_max;\n/* The per-CPU arena array. */\nstatic size_t fio_mem_block_count;\n#define FIO_MEMORY_ON_BLOCK_ALLOC()                                            \\\n  do {                                                                         \\\n    fio_atomic_add(&fio_mem_block_count, 1);                                   \\\n    if (fio_mem_block_count > fio_mem_block_count_max)                         \\\n      fio_mem_block_count_max = fio_mem_block_count;                           \\\n  } while (0)\n#define FIO_MEMORY_ON_BLOCK_FREE()                                             \\\n  do {                                                                         \\\n    fio_atomic_sub(&fio_mem_block_count, 1);                                   \\\n  } while (0)\n#define FIO_MEMORY_PRINT_BLOCK_STAT()                                          \\\n  FIO_LOG_INFO(                                                                \\\n      \"(fio) Total memory blocks allocated before cleanup %zu\\n\"               \\\n      \"       Maximum memory blocks allocated at a single time %zu\\n\",         \\\n      fio_mem_block_count, fio_mem_block_count_max)\n#define FIO_MEMORY_PRINT_BLOCK_STAT_END()                                      \\\n  FIO_LOG_INFO(\"(fio) Total memory blocks allocated \"                          \\\n               \"after cleanup (possible leak) %zu\\n\",                          \\\n               fio_mem_block_count)\n#else\n#define FIO_MEMORY_ON_BLOCK_ALLOC()\n#define FIO_MEMORY_ON_BLOCK_FREE()\n#define FIO_MEMORY_PRINT_BLOCK_STAT()\n#define FIO_MEMORY_PRINT_BLOCK_STAT_END()\n#endif\n/* *****************************************************************************\nPer-CPU Arena management\n***************************************************************************** */\n\n/* returned a locked arena. Attempts the preffered arena first. */\nstatic inline arena_s *arena_lock(arena_s *preffered) {\n  if (!preffered)\n    preffered = arenas;\n  if (!fio_trylock(&preffered->lock))\n    return preffered;\n  do {\n    arena_s *arena = preffered;\n    for (size_t i = (size_t)(arena - arenas); i < memory.cores; ++i) {\n      if ((preffered == arenas || arena != preffered) &&\n          !fio_trylock(&arena->lock))\n        return arena;\n      ++arena;\n    }\n    if (preffered == arenas)\n      fio_reschedule_thread();\n    preffered = arenas;\n  } while (1);\n}\n\nstatic __thread arena_s *arena_last_used;\n\nstatic void arena_enter(void) { arena_last_used = arena_lock(arena_last_used); }\n\nstatic inline void arena_exit(void) { fio_unlock(&arena_last_used->lock); }\n\n/** Clears any memory locks, in case of a system call to `fork`. */\nvoid fio_malloc_after_fork(void) {\n  arena_last_used = NULL;\n  if (!arenas) {\n    return;\n  }\n  memory.lock = FIO_LOCK_INIT;\n  memory.forked = 1;\n  for (size_t i = 0; i < memory.cores; ++i) {\n    arenas[i].lock = FIO_LOCK_INIT;\n  }\n}\n\n/* *****************************************************************************\nBlock management / allocation\n***************************************************************************** */\n\nstatic inline void block_init_root(block_s *blk, block_s *parent) {\n  *blk = (block_s){\n      .parent = parent,\n      .ref = 1,\n      .pos = FIO_MEMORY_BLOCK_START_POS,\n      .root_ref = 1,\n  };\n}\n\n/* intializes the block header for an available block of memory. */\nstatic inline void block_init(block_s *blk) {\n  /* initialization shouldn't effect `parent` or `root_ref`*/\n  blk->ref = 1;\n  blk->pos = FIO_MEMORY_BLOCK_START_POS;\n  /* zero out linked list memory (everything else is already zero) */\n  ((block_node_s *)blk)->node.next = NULL;\n  ((block_node_s *)blk)->node.prev = NULL;\n  /* bump parent reference count */\n  fio_atomic_add(&blk->parent->root_ref, 1);\n}\n\n/* intializes the block header for an available block of memory. */\nstatic inline void block_free(block_s *blk) {\n  if (fio_atomic_sub(&blk->ref, 1))\n    return;\n\n  memset(blk + 1, 0, (FIO_MEMORY_BLOCK_SIZE - sizeof(*blk)));\n  fio_lock(&memory.lock);\n  fio_ls_embd_push(&memory.available, &((block_node_s *)blk)->node);\n\n  blk = blk->parent;\n\n  if (fio_atomic_sub(&blk->root_ref, 1)) {\n    fio_unlock(&memory.lock);\n    return;\n  }\n  // fio_unlock(&memory.lock);\n  // return;\n\n  /* remove all of the root block's children (slices) from the memory pool */\n  for (size_t i = 0; i < FIO_MEMORY_BLOCKS_PER_ALLOCATION; ++i) {\n    block_node_s *pos =\n        (block_node_s *)((uintptr_t)blk + (i * FIO_MEMORY_BLOCK_SIZE));\n    fio_ls_embd_remove(&pos->node);\n  }\n\n  fio_unlock(&memory.lock);\n  sys_free(blk, FIO_MEMORY_BLOCK_SIZE * FIO_MEMORY_BLOCKS_PER_ALLOCATION);\n  FIO_LOG_DEBUG(\"memory allocator returned %p to the system\", (void *)blk);\n  FIO_MEMORY_ON_BLOCK_FREE();\n}\n\n/* intializes the block header for an available block of memory. */\nstatic inline block_s *block_new(void) {\n  block_s *blk = NULL;\n\n  fio_lock(&memory.lock);\n  blk = (block_s *)fio_ls_embd_pop(&memory.available);\n  if (blk) {\n    blk = (block_s *)FIO_LS_EMBD_OBJ(block_node_s, node, blk);\n    FIO_ASSERT(((uintptr_t)blk & FIO_MEMORY_BLOCK_MASK) == 0,\n               \"Memory allocator error! double `fio_free`?\\n\");\n    block_init(blk); /* must be performed within lock */\n    fio_unlock(&memory.lock);\n    return blk;\n  }\n  /* collect memory from the system */\n  blk = sys_alloc(FIO_MEMORY_BLOCK_SIZE * FIO_MEMORY_BLOCKS_PER_ALLOCATION, 0);\n  if (!blk) {\n    fio_unlock(&memory.lock);\n    return NULL;\n  }\n  FIO_LOG_DEBUG(\"memory allocator allocated %p from the system\", (void *)blk);\n  FIO_MEMORY_ON_BLOCK_ALLOC();\n  block_init_root(blk, blk);\n  /* the extra memory goes into the memory pool. initialize + linke-list. */\n  block_node_s *tmp = (block_node_s *)blk;\n  for (int i = 1; i < FIO_MEMORY_BLOCKS_PER_ALLOCATION; ++i) {\n    tmp = (block_node_s *)((uintptr_t)tmp + FIO_MEMORY_BLOCK_SIZE);\n    block_init_root((block_s *)tmp, blk);\n    fio_ls_embd_push(&memory.available, &tmp->node);\n  }\n  fio_unlock(&memory.lock);\n  /* return the root block (which isn't in the memory pool). */\n  return blk;\n}\n\n/* allocates memory from within a block - called within an arena's lock */\nstatic inline void *block_slice(uint16_t units) {\n  block_s *blk = arena_last_used->block;\n  if (!blk) {\n    /* arena is empty */\n    blk = block_new();\n    arena_last_used->block = blk;\n  } else if (blk->pos + units > FIO_MEMORY_MAX_SLICES_PER_BLOCK) {\n    /* not enough memory in the block - rotate */\n    block_free(blk);\n    blk = block_new();\n    arena_last_used->block = blk;\n  }\n  if (!blk) {\n    /* no system memory available? */\n    errno = ENOMEM;\n    return NULL;\n  }\n  /* slice block starting at blk->pos and increase reference count */\n  const void *mem = (void *)((uintptr_t)blk + ((uintptr_t)blk->pos << 4));\n  fio_atomic_add(&blk->ref, 1);\n  blk->pos += units;\n  if (blk->pos >= FIO_MEMORY_MAX_SLICES_PER_BLOCK) {\n    /* ... the block was fully utilized, clear arena */\n    block_free(blk);\n    arena_last_used->block = NULL;\n  }\n  return (void *)mem;\n}\n\n/* handle's a bock's reference count - called without a lock */\nstatic inline void block_slice_free(void *mem) {\n  /* locate block boundary */\n  block_s *blk = (block_s *)((uintptr_t)mem & (~FIO_MEMORY_BLOCK_MASK));\n  block_free(blk);\n}\n\n/* *****************************************************************************\nNon-Block allocations (direct from the system)\n***************************************************************************** */\n\n/* allocates directly from the system adding size header - no lock required. */\nstatic inline void *big_alloc(size_t size) {\n  size = sys_round_size(size + 16);\n  size_t *mem = sys_alloc(size, 1);\n  if (!mem)\n    goto error;\n  *mem = size;\n  return (void *)(((uintptr_t)mem) + 16);\nerror:\n  return NULL;\n}\n\n/* reads size header and frees memory back to the system */\nstatic inline void big_free(void *ptr) {\n  size_t *mem = (void *)(((uintptr_t)ptr) - 16);\n  sys_free(mem, *mem);\n}\n\n/* reallocates memory using the system, resetting the size header */\nstatic inline void *big_realloc(void *ptr, size_t new_size) {\n  size_t *mem = (void *)(((uintptr_t)ptr) - 16);\n  new_size = sys_round_size(new_size + 16);\n  mem = sys_realloc(mem, *mem, new_size);\n  if (!mem)\n    goto error;\n  *mem = new_size;\n  return (void *)(((uintptr_t)mem) + 16);\nerror:\n  return NULL;\n}\n\n/* *****************************************************************************\nAllocator Initialization (initialize arenas and allocate a block for each CPU)\n***************************************************************************** */\n\n#if DEBUG\nvoid fio_memory_dump_missing(void) {\n  fprintf(stderr, \"\\n ==== Attempting Memory Dump (will crash) ====\\n\");\n  if (fio_ls_embd_is_empty(&memory.available)) {\n    fprintf(stderr, \"- Memory dump attempt canceled\\n\");\n    return;\n  }\n  block_node_s *smallest =\n      FIO_LS_EMBD_OBJ(block_node_s, node, memory.available.next);\n  FIO_LS_EMBD_FOR(&memory.available, node) {\n    block_node_s *tmp = FIO_LS_EMBD_OBJ(block_node_s, node, node);\n    if (smallest > tmp)\n      smallest = tmp;\n  }\n\n  for (size_t i = 0;\n       i < FIO_MEMORY_BLOCK_SIZE * FIO_MEMORY_BLOCKS_PER_ALLOCATION; ++i) {\n    if ((((uintptr_t)smallest + i) & FIO_MEMORY_BLOCK_MASK) == 0) {\n      i += 32;\n      fprintf(stderr, \"---block jump---\\n\");\n      continue;\n    }\n    if (((char *)smallest)[i])\n      fprintf(stderr, \"%c\", ((char *)smallest)[i]);\n  }\n}\n#else\n#define fio_memory_dump_missing()\n#endif\n\nstatic void fio_mem_init(void) {\n  if (arenas)\n    return;\n\n  ssize_t cpu_count = 0;\n#ifdef _SC_NPROCESSORS_ONLN\n  cpu_count = sysconf(_SC_NPROCESSORS_ONLN);\n#else\n#warning Dynamic CPU core count is unavailable - assuming 8 cores for memory allocation pools.\n#endif\n  if (cpu_count <= 0)\n    cpu_count = 8;\n  memory.cores = cpu_count;\n  arenas = big_alloc(sizeof(*arenas) * cpu_count);\n  FIO_ASSERT_ALLOC(arenas);\n  block_free(block_new());\n  pthread_atfork(NULL, NULL, fio_malloc_after_fork);\n}\n\nstatic void fio_mem_destroy(void) {\n  if (!arenas)\n    return;\n\n  FIO_MEMORY_PRINT_BLOCK_STAT();\n\n  for (size_t i = 0; i < memory.cores; ++i) {\n    if (arenas[i].block)\n      block_free(arenas[i].block);\n    arenas[i].block = NULL;\n  }\n  if (!memory.forked && fio_ls_embd_any(&memory.available)) {\n    FIO_LOG_WARNING(\"facil.io detected memory traces remaining after cleanup\"\n                    \" - memory leak?\");\n    FIO_MEMORY_PRINT_BLOCK_STAT_END();\n    size_t count = 0;\n    FIO_LS_EMBD_FOR(&memory.available, node) { ++count; }\n    FIO_LOG_DEBUG(\"Memory blocks in pool: %zu (%zu blocks per allocation).\",\n                  count, (size_t)FIO_MEMORY_BLOCKS_PER_ALLOCATION);\n#if FIO_MEM_DUMP\n    fio_memory_dump_missing();\n#endif\n  }\n  big_free(arenas);\n  arenas = NULL;\n}\n/* *****************************************************************************\nMemory allocation / deacclocation API\n***************************************************************************** */\n\nvoid *fio_malloc(size_t size) {\n#if FIO_OVERRIDE_MALLOC\n  if (!arenas)\n    fio_mem_init();\n#endif\n  if (!size) {\n    /* changed behavior prevents \"allocation failed\" test for `malloc(0)` */\n    return (void *)(&on_malloc_zero);\n  }\n  if (size >= FIO_MEMORY_BLOCK_ALLOC_LIMIT) {\n    /* system allocation - must be block aligned */\n    // FIO_LOG_WARNING(\"fio_malloc re-routed to mmap - big allocation\");\n    return big_alloc(size);\n  }\n  /* ceiling for 16 byte alignement, translated to 16 byte units */\n  size = (size >> 4) + (!!(size & 15));\n  arena_enter();\n  void *mem = block_slice(size);\n  arena_exit();\n  return mem;\n}\n\nvoid *fio_calloc(size_t size, size_t count) {\n  return fio_malloc(size * count); // memory is pre-initialized by mmap or pool.\n}\n\nvoid fio_free(void *ptr) {\n  if (!ptr || ptr == (void *)&on_malloc_zero)\n    return;\n  if (((uintptr_t)ptr & FIO_MEMORY_BLOCK_MASK) == 16) {\n    /* big allocation - direct from the system */\n    big_free(ptr);\n    return;\n  }\n  /* allocated within block */\n  block_slice_free(ptr);\n}\n\n/**\n * Re-allocates memory. An attept to avoid copying the data is made only for big\n * memory allocations.\n *\n * This variation is slightly faster as it might copy less data\n */\nvoid *fio_realloc2(void *ptr, size_t new_size, size_t copy_length) {\n  if (!ptr || ptr == (void *)&on_malloc_zero) {\n    return fio_malloc(new_size);\n  }\n  if (!new_size) {\n    goto zero_size;\n  }\n  if (((uintptr_t)ptr & FIO_MEMORY_BLOCK_MASK) == 16) {\n    /* big reallocation - direct from the system */\n    return big_realloc(ptr, new_size);\n  }\n  /* allocated within block - don't even try to expand the allocation */\n  /* ceiling for 16 byte alignement, translated to 16 byte units */\n  void *new_mem = fio_malloc(new_size);\n  if (!new_mem)\n    return NULL;\n  new_size = ((new_size >> 4) + (!!(new_size & 15)));\n  copy_length = ((copy_length >> 4) + (!!(copy_length & 15)));\n  fio_memcpy(new_mem, ptr, copy_length > new_size ? new_size : copy_length);\n\n  block_slice_free(ptr);\n  return new_mem;\nzero_size:\n  fio_free(ptr);\n  return fio_malloc(0);\n}\n\nvoid *fio_realloc(void *ptr, size_t new_size) {\n  const size_t max_old =\n      FIO_MEMORY_BLOCK_SIZE - ((uintptr_t)ptr & FIO_MEMORY_BLOCK_MASK);\n  return fio_realloc2(ptr, new_size, max_old);\n}\n\n/**\n * Allocates memory directly using `mmap`, this is prefered for larger objects\n * that have a long lifetime.\n *\n * `fio_free` can be used for deallocating the memory.\n */\nvoid *fio_mmap(size_t size) {\n  if (!size) {\n    return NULL;\n  }\n  return big_alloc(size);\n}\n\n/* *****************************************************************************\nFIO_OVERRIDE_MALLOC - override glibc / library malloc\n***************************************************************************** */\n#if FIO_OVERRIDE_MALLOC\nvoid *malloc(size_t size) { return fio_malloc(size); }\nvoid *calloc(size_t size, size_t count) { return fio_calloc(size, count); }\nvoid free(void *ptr) { fio_free(ptr); }\nvoid *realloc(void *ptr, size_t new_size) { return fio_realloc(ptr, new_size); }\n#endif\n\n#endif\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n                      Random Generator Functions\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/* tested for randomness using code from: http://xoshiro.di.unimi.it/hwd.php */\nuint64_t fio_rand64(void) {\n  /* modeled after xoroshiro128+, by David Blackman and Sebastiano Vigna */\n  static __thread uint64_t s[2]; /* random state */\n  static __thread uint16_t c;    /* seed counter */\n  const uint64_t P[] = {0x37701261ED6C16C7ULL, 0x764DBBB75F3B3E0DULL};\n  if (c++ == 0) {\n    /* re-seed state every 65,536 requests */\n#ifdef RUSAGE_SELF\n    struct rusage rusage;\n    getrusage(RUSAGE_SELF, &rusage);\n    s[0] = fio_risky_hash(&rusage, sizeof(rusage), s[0]);\n    s[1] = fio_risky_hash(&rusage, sizeof(rusage), s[0]);\n#else\n    struct timespec clk;\n    clock_gettime(CLOCK_REALTIME, &clk);\n    s[0] = fio_risky_hash(&clk, sizeof(clk), s[0]);\n    s[1] = fio_risky_hash(&clk, sizeof(clk), s[0]);\n#endif\n  }\n  s[0] += fio_lrot64(s[0], 33) * P[0];\n  s[1] += fio_lrot64(s[1], 33) * P[1];\n  return fio_lrot64(s[0], 31) + fio_lrot64(s[1], 29);\n}\n\n/* copies 64 bits of randomness (8 bytes) repeatedly... */\nvoid fio_rand_bytes(void *data_, size_t len) {\n  if (!data_ || !len)\n    return;\n  uint8_t *data = data_;\n  /* unroll 32 bytes / 256 bit writes */\n  for (size_t i = (len >> 5); i; --i) {\n    const uint64_t t0 = fio_rand64();\n    const uint64_t t1 = fio_rand64();\n    const uint64_t t2 = fio_rand64();\n    const uint64_t t3 = fio_rand64();\n    fio_u2str64(data, t0);\n    fio_u2str64(data + 8, t1);\n    fio_u2str64(data + 16, t2);\n    fio_u2str64(data + 24, t3);\n    data += 32;\n  }\n  uint64_t tmp;\n  /* 64 bit steps  */\n  switch (len & 24) {\n  case 24:\n    tmp = fio_rand64();\n    fio_u2str64(data + 16, tmp);\n    /* fallthrough */\n  case 16:\n    tmp = fio_rand64();\n    fio_u2str64(data + 8, tmp);\n    /* fallthrough */\n  case 8:\n    tmp = fio_rand64();\n    fio_u2str64(data, tmp);\n    data += len & 24;\n  }\n  if ((len & 7)) {\n    tmp = fio_rand64();\n    /* leftover bytes */\n    switch ((len & 7)) {\n    case 7:\n      data[6] = (tmp >> 8) & 0xFF;\n      /* fallthrough */\n    case 6:\n      data[5] = (tmp >> 16) & 0xFF;\n      /* fallthrough */\n    case 5:\n      data[4] = (tmp >> 24) & 0xFF;\n      /* fallthrough */\n    case 4:\n      data[3] = (tmp >> 32) & 0xFF;\n      /* fallthrough */\n    case 3:\n      data[2] = (tmp >> 40) & 0xFF;\n      /* fallthrough */\n    case 2:\n      data[1] = (tmp >> 48) & 0xFF;\n      /* fallthrough */\n    case 1:\n      data[0] = (tmp >> 56) & 0xFF;\n    }\n  }\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n                             Hash Functions and Base64\n\n                  SipHash / SHA-1 / SHA-2 / Base64 / Hex encoding\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/* *****************************************************************************\nSipHash\n***************************************************************************** */\n\n#if __BIG_ENDIAN__ /* SipHash is Little Endian */\n#define sip_local64(i) fio_bswap64((i))\n#else\n#define sip_local64(i) (i)\n#endif\n\nstatic inline uint64_t fio_siphash_xy(const void *data, size_t len, size_t x,\n                                      size_t y, uint64_t key1, uint64_t key2) {\n  /* initialize the 4 words */\n  uint64_t v0 = (0x0706050403020100ULL ^ 0x736f6d6570736575ULL) ^ key1;\n  uint64_t v1 = (0x0f0e0d0c0b0a0908ULL ^ 0x646f72616e646f6dULL) ^ key2;\n  uint64_t v2 = (0x0706050403020100ULL ^ 0x6c7967656e657261ULL) ^ key1;\n  uint64_t v3 = (0x0f0e0d0c0b0a0908ULL ^ 0x7465646279746573ULL) ^ key2;\n  const uint8_t *w8 = data;\n  uint8_t len_mod = len & 255;\n  union {\n    uint64_t i;\n    uint8_t str[8];\n  } word;\n\n#define hash_map_SipRound                                                      \\\n  do {                                                                         \\\n    v2 += v3;                                                                  \\\n    v3 = fio_lrot64(v3, 16) ^ v2;                                              \\\n    v0 += v1;                                                                  \\\n    v1 = fio_lrot64(v1, 13) ^ v0;                                              \\\n    v0 = fio_lrot64(v0, 32);                                                   \\\n    v2 += v1;                                                                  \\\n    v0 += v3;                                                                  \\\n    v1 = fio_lrot64(v1, 17) ^ v2;                                              \\\n    v3 = fio_lrot64(v3, 21) ^ v0;                                              \\\n    v2 = fio_lrot64(v2, 32);                                                   \\\n  } while (0);\n\n  while (len >= 8) {\n    word.i = sip_local64(fio_str2u64(w8));\n    v3 ^= word.i;\n    /* Sip Rounds */\n    for (size_t i = 0; i < x; ++i) {\n      hash_map_SipRound;\n    }\n    v0 ^= word.i;\n    w8 += 8;\n    len -= 8;\n  }\n  word.i = 0;\n  uint8_t *pos = word.str;\n  switch (len) { /* fallthrough is intentional */\n  case 7:\n    pos[6] = w8[6];\n    /* fallthrough */\n  case 6:\n    pos[5] = w8[5];\n    /* fallthrough */\n  case 5:\n    pos[4] = w8[4];\n    /* fallthrough */\n  case 4:\n    pos[3] = w8[3];\n    /* fallthrough */\n  case 3:\n    pos[2] = w8[2];\n    /* fallthrough */\n  case 2:\n    pos[1] = w8[1];\n    /* fallthrough */\n  case 1:\n    pos[0] = w8[0];\n  }\n  word.str[7] = len_mod;\n\n  /* last round */\n  v3 ^= word.i;\n  hash_map_SipRound;\n  hash_map_SipRound;\n  v0 ^= word.i;\n  /* Finalization */\n  v2 ^= 0xff;\n  /* d iterations of SipRound */\n  for (size_t i = 0; i < y; ++i) {\n    hash_map_SipRound;\n  }\n  hash_map_SipRound;\n  hash_map_SipRound;\n  hash_map_SipRound;\n  hash_map_SipRound;\n  /* XOR it all together */\n  v0 ^= v1 ^ v2 ^ v3;\n#undef hash_map_SipRound\n  return v0;\n}\n\nuint64_t fio_siphash24(const void *data, size_t len, uint64_t key1,\n                       uint64_t key2) {\n  return fio_siphash_xy(data, len, 2, 4, key1, key2);\n}\n\nuint64_t fio_siphash13(const void *data, size_t len, uint64_t key1,\n                       uint64_t key2) {\n  return fio_siphash_xy(data, len, 1, 3, key1, key2);\n}\n\n/* *****************************************************************************\nSHA-1\n***************************************************************************** */\n\nstatic const uint8_t sha1_padding[64] = {0x80, 0};\n\n/**\nProcess the buffer once full.\n*/\nstatic inline void fio_sha1_perform_all_rounds(fio_sha1_s *s,\n                                               const uint8_t *buffer) {\n  /* collect data */\n  uint32_t a = s->digest.i[0];\n  uint32_t b = s->digest.i[1];\n  uint32_t c = s->digest.i[2];\n  uint32_t d = s->digest.i[3];\n  uint32_t e = s->digest.i[4];\n  uint32_t t, w[16];\n  /* copy data to words, performing byte swapping as needed */\n  w[0] = fio_str2u32(buffer);\n  w[1] = fio_str2u32(buffer + 4);\n  w[2] = fio_str2u32(buffer + 8);\n  w[3] = fio_str2u32(buffer + 12);\n  w[4] = fio_str2u32(buffer + 16);\n  w[5] = fio_str2u32(buffer + 20);\n  w[6] = fio_str2u32(buffer + 24);\n  w[7] = fio_str2u32(buffer + 28);\n  w[8] = fio_str2u32(buffer + 32);\n  w[9] = fio_str2u32(buffer + 36);\n  w[10] = fio_str2u32(buffer + 40);\n  w[11] = fio_str2u32(buffer + 44);\n  w[12] = fio_str2u32(buffer + 48);\n  w[13] = fio_str2u32(buffer + 52);\n  w[14] = fio_str2u32(buffer + 56);\n  w[15] = fio_str2u32(buffer + 60);\n  /* perform rounds */\n#undef perform_single_round\n#define perform_single_round(num)                                              \\\n  t = fio_lrot32(a, 5) + e + w[num] + ((b & c) | ((~b) & d)) + 0x5A827999;     \\\n  e = d;                                                                       \\\n  d = c;                                                                       \\\n  c = fio_lrot32(b, 30);                                                       \\\n  b = a;                                                                       \\\n  a = t;\n\n#define perform_four_rounds(i)                                                 \\\n  perform_single_round(i);                                                     \\\n  perform_single_round(i + 1);                                                 \\\n  perform_single_round(i + 2);                                                 \\\n  perform_single_round(i + 3);\n\n  perform_four_rounds(0);\n  perform_four_rounds(4);\n  perform_four_rounds(8);\n  perform_four_rounds(12);\n\n#undef perform_single_round\n#define perform_single_round(i)                                                \\\n  w[(i)&15] = fio_lrot32((w[(i - 3) & 15] ^ w[(i - 8) & 15] ^                  \\\n                          w[(i - 14) & 15] ^ w[(i - 16) & 15]),                \\\n                         1);                                                   \\\n  t = fio_lrot32(a, 5) + e + w[(i)&15] + ((b & c) | ((~b) & d)) + 0x5A827999;  \\\n  e = d;                                                                       \\\n  d = c;                                                                       \\\n  c = fio_lrot32(b, 30);                                                       \\\n  b = a;                                                                       \\\n  a = t;\n\n  perform_four_rounds(16);\n\n#undef perform_single_round\n#define perform_single_round(i)                                                \\\n  w[(i)&15] = fio_lrot32((w[(i - 3) & 15] ^ w[(i - 8) & 15] ^                  \\\n                          w[(i - 14) & 15] ^ w[(i - 16) & 15]),                \\\n                         1);                                                   \\\n  t = fio_lrot32(a, 5) + e + w[(i)&15] + (b ^ c ^ d) + 0x6ED9EBA1;             \\\n  e = d;                                                                       \\\n  d = c;                                                                       \\\n  c = fio_lrot32(b, 30);                                                       \\\n  b = a;                                                                       \\\n  a = t;\n\n  perform_four_rounds(20);\n  perform_four_rounds(24);\n  perform_four_rounds(28);\n  perform_four_rounds(32);\n  perform_four_rounds(36);\n\n#undef perform_single_round\n#define perform_single_round(i)                                                \\\n  w[(i)&15] = fio_lrot32((w[(i - 3) & 15] ^ w[(i - 8) & 15] ^                  \\\n                          w[(i - 14) & 15] ^ w[(i - 16) & 15]),                \\\n                         1);                                                   \\\n  t = fio_lrot32(a, 5) + e + w[(i)&15] + ((b & (c | d)) | (c & d)) +           \\\n      0x8F1BBCDC;                                                              \\\n  e = d;                                                                       \\\n  d = c;                                                                       \\\n  c = fio_lrot32(b, 30);                                                       \\\n  b = a;                                                                       \\\n  a = t;\n\n  perform_four_rounds(40);\n  perform_four_rounds(44);\n  perform_four_rounds(48);\n  perform_four_rounds(52);\n  perform_four_rounds(56);\n#undef perform_single_round\n#define perform_single_round(i)                                                \\\n  w[(i)&15] = fio_lrot32((w[(i - 3) & 15] ^ w[(i - 8) & 15] ^                  \\\n                          w[(i - 14) & 15] ^ w[(i - 16) & 15]),                \\\n                         1);                                                   \\\n  t = fio_lrot32(a, 5) + e + w[(i)&15] + (b ^ c ^ d) + 0xCA62C1D6;             \\\n  e = d;                                                                       \\\n  d = c;                                                                       \\\n  c = fio_lrot32(b, 30);                                                       \\\n  b = a;                                                                       \\\n  a = t;\n  perform_four_rounds(60);\n  perform_four_rounds(64);\n  perform_four_rounds(68);\n  perform_four_rounds(72);\n  perform_four_rounds(76);\n\n  /* store data */\n  s->digest.i[4] += e;\n  s->digest.i[3] += d;\n  s->digest.i[2] += c;\n  s->digest.i[1] += b;\n  s->digest.i[0] += a;\n}\n\n/**\nInitialize or reset the `sha1` object. This must be performed before hashing\ndata using sha1.\n*/\nfio_sha1_s fio_sha1_init(void) {\n  return (fio_sha1_s){.digest.i[0] = 0x67452301,\n                      .digest.i[1] = 0xefcdab89,\n                      .digest.i[2] = 0x98badcfe,\n                      .digest.i[3] = 0x10325476,\n                      .digest.i[4] = 0xc3d2e1f0};\n}\n\n/**\nWrites data to the sha1 buffer.\n*/\nvoid fio_sha1_write(fio_sha1_s *s, const void *data, size_t len) {\n  size_t in_buffer = s->length & 63;\n  size_t partial = 64 - in_buffer;\n  s->length += len;\n  if (partial > len) {\n    memcpy(s->buffer + in_buffer, data, len);\n    return;\n  }\n  if (in_buffer) {\n    memcpy(s->buffer + in_buffer, data, partial);\n    len -= partial;\n    data = (void *)((uintptr_t)data + partial);\n    fio_sha1_perform_all_rounds(s, s->buffer);\n  }\n  while (len >= 64) {\n    fio_sha1_perform_all_rounds(s, data);\n    data = (void *)((uintptr_t)data + 64);\n    len -= 64;\n  }\n  if (len) {\n    memcpy(s->buffer + in_buffer, data, len);\n  }\n  return;\n}\n\nchar *fio_sha1_result(fio_sha1_s *s) {\n  size_t in_buffer = s->length & 63;\n  if (in_buffer > 55) {\n    memcpy(s->buffer + in_buffer, sha1_padding, 64 - in_buffer);\n    fio_sha1_perform_all_rounds(s, s->buffer);\n    memcpy(s->buffer, sha1_padding + 1, 56);\n  } else if (in_buffer != 55) {\n    memcpy(s->buffer + in_buffer, sha1_padding, 56 - in_buffer);\n  } else {\n    s->buffer[55] = sha1_padding[0];\n  }\n  /* store the length in BITS - alignment should be promised by struct */\n  /* this must the number in BITS, encoded as a BIG ENDIAN 64 bit number */\n  uint64_t *len = (uint64_t *)(s->buffer + 56);\n  *len = s->length << 3;\n  *len = fio_lton64(*len);\n  fio_sha1_perform_all_rounds(s, s->buffer);\n\n  /* change back to little endian */\n  s->digest.i[0] = fio_ntol32(s->digest.i[0]);\n  s->digest.i[1] = fio_ntol32(s->digest.i[1]);\n  s->digest.i[2] = fio_ntol32(s->digest.i[2]);\n  s->digest.i[3] = fio_ntol32(s->digest.i[3]);\n  s->digest.i[4] = fio_ntol32(s->digest.i[4]);\n\n  return (char *)s->digest.str;\n}\n\n#undef perform_single_round\n\n/* *****************************************************************************\nSHA-2\n***************************************************************************** */\n\nstatic const uint8_t sha2_padding[128] = {0x80, 0};\n\n/* SHA-224 and SHA-256 constants */\nstatic uint32_t sha2_256_words[] = {\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,\n    0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,\n    0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n    0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,\n    0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,\n    0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2};\n\n/* SHA-512 and friends constants */\nstatic uint64_t sha2_512_words[] = {\n    0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f,\n    0xe9b5dba58189dbbc, 0x3956c25bf348b538, 0x59f111f1b605d019,\n    0x923f82a4af194f9b, 0xab1c5ed5da6d8118, 0xd807aa98a3030242,\n    0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,\n    0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235,\n    0xc19bf174cf692694, 0xe49b69c19ef14ad2, 0xefbe4786384f25e3,\n    0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65, 0x2de92c6f592b0275,\n    0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,\n    0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f,\n    0xbf597fc7beef0ee4, 0xc6e00bf33da88fc2, 0xd5a79147930aa725,\n    0x06ca6351e003826f, 0x142929670a0e6e70, 0x27b70a8546d22ffc,\n    0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,\n    0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6,\n    0x92722c851482353b, 0xa2bfe8a14cf10364, 0xa81a664bbc423001,\n    0xc24b8b70d0f89791, 0xc76c51a30654be30, 0xd192e819d6ef5218,\n    0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,\n    0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99,\n    0x34b0bcb5e19b48a8, 0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb,\n    0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3, 0x748f82ee5defb2fc,\n    0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,\n    0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915,\n    0xc67178f2e372532b, 0xca273eceea26619c, 0xd186b8c721c0c207,\n    0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178, 0x06f067aa72176fba,\n    0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,\n    0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc,\n    0x431d67c49c100d4c, 0x4cc5d4becb3e42b6, 0x597f299cfc657e2a,\n    0x5fcb6fab3ad6faec, 0x6c44198c4a475817};\n\n/* Specific Macros for the SHA-2 processing */\n\n#define Ch(x, y, z) (((x) & (y)) ^ ((~(x)) & z))\n#define Maj(x, y, z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))\n\n#define Eps0_32(x)                                                             \\\n  (fio_rrot32((x), 2) ^ fio_rrot32((x), 13) ^ fio_rrot32((x), 22))\n#define Eps1_32(x)                                                             \\\n  (fio_rrot32((x), 6) ^ fio_rrot32((x), 11) ^ fio_rrot32((x), 25))\n#define Omg0_32(x) (fio_rrot32((x), 7) ^ fio_rrot32((x), 18) ^ (((x) >> 3)))\n#define Omg1_32(x) (fio_rrot32((x), 17) ^ fio_rrot32((x), 19) ^ (((x) >> 10)))\n\n#define Eps0_64(x)                                                             \\\n  (fio_rrot64((x), 28) ^ fio_rrot64((x), 34) ^ fio_rrot64((x), 39))\n#define Eps1_64(x)                                                             \\\n  (fio_rrot64((x), 14) ^ fio_rrot64((x), 18) ^ fio_rrot64((x), 41))\n#define Omg0_64(x) (fio_rrot64((x), 1) ^ fio_rrot64((x), 8) ^ (((x) >> 7)))\n#define Omg1_64(x) (fio_rrot64((x), 19) ^ fio_rrot64((x), 61) ^ (((x) >> 6)))\n\n/**\nProcess the buffer once full.\n*/\nstatic inline void fio_sha2_perform_all_rounds(fio_sha2_s *s,\n                                               const uint8_t *data) {\n  if (s->type & 1) { /* 512 derived type */\n    // process values for the 64bit words\n    uint64_t a = s->digest.i64[0];\n    uint64_t b = s->digest.i64[1];\n    uint64_t c = s->digest.i64[2];\n    uint64_t d = s->digest.i64[3];\n    uint64_t e = s->digest.i64[4];\n    uint64_t f = s->digest.i64[5];\n    uint64_t g = s->digest.i64[6];\n    uint64_t h = s->digest.i64[7];\n    uint64_t t1, t2, w[80];\n    w[0] = fio_str2u64(data);\n    w[1] = fio_str2u64(data + 8);\n    w[2] = fio_str2u64(data + 16);\n    w[3] = fio_str2u64(data + 24);\n    w[4] = fio_str2u64(data + 32);\n    w[5] = fio_str2u64(data + 40);\n    w[6] = fio_str2u64(data + 48);\n    w[7] = fio_str2u64(data + 56);\n    w[8] = fio_str2u64(data + 64);\n    w[9] = fio_str2u64(data + 72);\n    w[10] = fio_str2u64(data + 80);\n    w[11] = fio_str2u64(data + 88);\n    w[12] = fio_str2u64(data + 96);\n    w[13] = fio_str2u64(data + 104);\n    w[14] = fio_str2u64(data + 112);\n    w[15] = fio_str2u64(data + 120);\n\n#undef perform_single_round\n#define perform_single_round(i)                                                \\\n  t1 = h + Eps1_64(e) + Ch(e, f, g) + sha2_512_words[i] + w[i];                \\\n  t2 = Eps0_64(a) + Maj(a, b, c);                                              \\\n  h = g;                                                                       \\\n  g = f;                                                                       \\\n  f = e;                                                                       \\\n  e = d + t1;                                                                  \\\n  d = c;                                                                       \\\n  c = b;                                                                       \\\n  b = a;                                                                       \\\n  a = t1 + t2;\n\n#define perform_4rounds(i)                                                     \\\n  perform_single_round(i);                                                     \\\n  perform_single_round(i + 1);                                                 \\\n  perform_single_round(i + 2);                                                 \\\n  perform_single_round(i + 3);\n\n    perform_4rounds(0);\n    perform_4rounds(4);\n    perform_4rounds(8);\n    perform_4rounds(12);\n\n#undef perform_single_round\n#define perform_single_round(i)                                                \\\n  w[i] = Omg1_64(w[i - 2]) + w[i - 7] + Omg0_64(w[i - 15]) + w[i - 16];        \\\n  t1 = h + Eps1_64(e) + Ch(e, f, g) + sha2_512_words[i] + w[i];                \\\n  t2 = Eps0_64(a) + Maj(a, b, c);                                              \\\n  h = g;                                                                       \\\n  g = f;                                                                       \\\n  f = e;                                                                       \\\n  e = d + t1;                                                                  \\\n  d = c;                                                                       \\\n  c = b;                                                                       \\\n  b = a;                                                                       \\\n  a = t1 + t2;\n\n    perform_4rounds(16);\n    perform_4rounds(20);\n    perform_4rounds(24);\n    perform_4rounds(28);\n    perform_4rounds(32);\n    perform_4rounds(36);\n    perform_4rounds(40);\n    perform_4rounds(44);\n    perform_4rounds(48);\n    perform_4rounds(52);\n    perform_4rounds(56);\n    perform_4rounds(60);\n    perform_4rounds(64);\n    perform_4rounds(68);\n    perform_4rounds(72);\n    perform_4rounds(76);\n\n    s->digest.i64[0] += a;\n    s->digest.i64[1] += b;\n    s->digest.i64[2] += c;\n    s->digest.i64[3] += d;\n    s->digest.i64[4] += e;\n    s->digest.i64[5] += f;\n    s->digest.i64[6] += g;\n    s->digest.i64[7] += h;\n    return;\n  } else {\n    // process values for the 32bit words\n    uint32_t a = s->digest.i32[0];\n    uint32_t b = s->digest.i32[1];\n    uint32_t c = s->digest.i32[2];\n    uint32_t d = s->digest.i32[3];\n    uint32_t e = s->digest.i32[4];\n    uint32_t f = s->digest.i32[5];\n    uint32_t g = s->digest.i32[6];\n    uint32_t h = s->digest.i32[7];\n    uint32_t t1, t2, w[64];\n\n    w[0] = fio_str2u32(data);\n    w[1] = fio_str2u32(data + 4);\n    w[2] = fio_str2u32(data + 8);\n    w[3] = fio_str2u32(data + 12);\n    w[4] = fio_str2u32(data + 16);\n    w[5] = fio_str2u32(data + 20);\n    w[6] = fio_str2u32(data + 24);\n    w[7] = fio_str2u32(data + 28);\n    w[8] = fio_str2u32(data + 32);\n    w[9] = fio_str2u32(data + 36);\n    w[10] = fio_str2u32(data + 40);\n    w[11] = fio_str2u32(data + 44);\n    w[12] = fio_str2u32(data + 48);\n    w[13] = fio_str2u32(data + 52);\n    w[14] = fio_str2u32(data + 56);\n    w[15] = fio_str2u32(data + 60);\n\n#undef perform_single_round\n#define perform_single_round(i)                                                \\\n  t1 = h + Eps1_32(e) + Ch(e, f, g) + sha2_256_words[i] + w[i];                \\\n  t2 = Eps0_32(a) + Maj(a, b, c);                                              \\\n  h = g;                                                                       \\\n  g = f;                                                                       \\\n  f = e;                                                                       \\\n  e = d + t1;                                                                  \\\n  d = c;                                                                       \\\n  c = b;                                                                       \\\n  b = a;                                                                       \\\n  a = t1 + t2;\n\n    perform_4rounds(0);\n    perform_4rounds(4);\n    perform_4rounds(8);\n    perform_4rounds(12);\n\n#undef perform_single_round\n#define perform_single_round(i)                                                \\\n  w[i] = Omg1_32(w[i - 2]) + w[i - 7] + Omg0_32(w[i - 15]) + w[i - 16];        \\\n  t1 = h + Eps1_32(e) + Ch(e, f, g) + sha2_256_words[i] + w[i];                \\\n  t2 = Eps0_32(a) + Maj(a, b, c);                                              \\\n  h = g;                                                                       \\\n  g = f;                                                                       \\\n  f = e;                                                                       \\\n  e = d + t1;                                                                  \\\n  d = c;                                                                       \\\n  c = b;                                                                       \\\n  b = a;                                                                       \\\n  a = t1 + t2;\n\n    perform_4rounds(16);\n    perform_4rounds(20);\n    perform_4rounds(24);\n    perform_4rounds(28);\n    perform_4rounds(32);\n    perform_4rounds(36);\n    perform_4rounds(40);\n    perform_4rounds(44);\n    perform_4rounds(48);\n    perform_4rounds(52);\n    perform_4rounds(56);\n    perform_4rounds(60);\n\n    s->digest.i32[0] += a;\n    s->digest.i32[1] += b;\n    s->digest.i32[2] += c;\n    s->digest.i32[3] += d;\n    s->digest.i32[4] += e;\n    s->digest.i32[5] += f;\n    s->digest.i32[6] += g;\n    s->digest.i32[7] += h;\n  }\n}\n\n/**\nInitialize/reset the SHA-2 object.\n\nSHA-2 is actually a family of functions with different variants. When\ninitializing the SHA-2 container, you must select the variant you intend to\napply. The following are valid options (see the fio_sha2_variant_e enum):\n\n- SHA_512 (== 0)\n- SHA_384\n- SHA_512_224\n- SHA_512_256\n- SHA_256\n- SHA_224\n\n*/\nfio_sha2_s fio_sha2_init(fio_sha2_variant_e variant) {\n  if (variant == SHA_256) {\n    return (fio_sha2_s){\n        .type = SHA_256,\n        .digest.i32[0] = 0x6a09e667,\n        .digest.i32[1] = 0xbb67ae85,\n        .digest.i32[2] = 0x3c6ef372,\n        .digest.i32[3] = 0xa54ff53a,\n        .digest.i32[4] = 0x510e527f,\n        .digest.i32[5] = 0x9b05688c,\n        .digest.i32[6] = 0x1f83d9ab,\n        .digest.i32[7] = 0x5be0cd19,\n    };\n  } else if (variant == SHA_384) {\n    return (fio_sha2_s){\n        .type = SHA_384,\n        .digest.i64[0] = 0xcbbb9d5dc1059ed8,\n        .digest.i64[1] = 0x629a292a367cd507,\n        .digest.i64[2] = 0x9159015a3070dd17,\n        .digest.i64[3] = 0x152fecd8f70e5939,\n        .digest.i64[4] = 0x67332667ffc00b31,\n        .digest.i64[5] = 0x8eb44a8768581511,\n        .digest.i64[6] = 0xdb0c2e0d64f98fa7,\n        .digest.i64[7] = 0x47b5481dbefa4fa4,\n    };\n  } else if (variant == SHA_512) {\n    return (fio_sha2_s){\n        .type = SHA_512,\n        .digest.i64[0] = 0x6a09e667f3bcc908,\n        .digest.i64[1] = 0xbb67ae8584caa73b,\n        .digest.i64[2] = 0x3c6ef372fe94f82b,\n        .digest.i64[3] = 0xa54ff53a5f1d36f1,\n        .digest.i64[4] = 0x510e527fade682d1,\n        .digest.i64[5] = 0x9b05688c2b3e6c1f,\n        .digest.i64[6] = 0x1f83d9abfb41bd6b,\n        .digest.i64[7] = 0x5be0cd19137e2179,\n    };\n  } else if (variant == SHA_224) {\n    return (fio_sha2_s){\n        .type = SHA_224,\n        .digest.i32[0] = 0xc1059ed8,\n        .digest.i32[1] = 0x367cd507,\n        .digest.i32[2] = 0x3070dd17,\n        .digest.i32[3] = 0xf70e5939,\n        .digest.i32[4] = 0xffc00b31,\n        .digest.i32[5] = 0x68581511,\n        .digest.i32[6] = 0x64f98fa7,\n        .digest.i32[7] = 0xbefa4fa4,\n    };\n  } else if (variant == SHA_512_224) {\n    return (fio_sha2_s){\n        .type = SHA_512_224,\n        .digest.i64[0] = 0x8c3d37c819544da2,\n        .digest.i64[1] = 0x73e1996689dcd4d6,\n        .digest.i64[2] = 0x1dfab7ae32ff9c82,\n        .digest.i64[3] = 0x679dd514582f9fcf,\n        .digest.i64[4] = 0x0f6d2b697bd44da8,\n        .digest.i64[5] = 0x77e36f7304c48942,\n        .digest.i64[6] = 0x3f9d85a86a1d36c8,\n        .digest.i64[7] = 0x1112e6ad91d692a1,\n    };\n  } else if (variant == SHA_512_256) {\n    return (fio_sha2_s){\n        .type = SHA_512_256,\n        .digest.i64[0] = 0x22312194fc2bf72c,\n        .digest.i64[1] = 0x9f555fa3c84c64c2,\n        .digest.i64[2] = 0x2393b86b6f53b151,\n        .digest.i64[3] = 0x963877195940eabd,\n        .digest.i64[4] = 0x96283ee2a88effe3,\n        .digest.i64[5] = 0xbe5e1e2553863992,\n        .digest.i64[6] = 0x2b0199fc2c85b8aa,\n        .digest.i64[7] = 0x0eb72ddc81c52ca2,\n    };\n  }\n  FIO_LOG_FATAL(\"SHA-2 ERROR - variant unknown\");\n  exit(2);\n}\n\n/**\nWrites data to the SHA-2 buffer.\n*/\nvoid fio_sha2_write(fio_sha2_s *s, const void *data, size_t len) {\n  size_t in_buffer;\n  size_t partial;\n  if (s->type & 1) { /* 512 type derived */\n    in_buffer = s->length.words[0] & 127;\n    if (s->length.words[0] + len < s->length.words[0]) {\n      /* we are at wraping around the 64bit limit */\n      s->length.words[1] = (s->length.words[1] << 1) | 1;\n    }\n    s->length.words[0] += len;\n    partial = 128 - in_buffer;\n\n    if (partial > len) {\n      memcpy(s->buffer + in_buffer, data, len);\n      return;\n    }\n    if (in_buffer) {\n      memcpy(s->buffer + in_buffer, data, partial);\n      len -= partial;\n      data = (void *)((uintptr_t)data + partial);\n      fio_sha2_perform_all_rounds(s, s->buffer);\n    }\n    while (len >= 128) {\n      fio_sha2_perform_all_rounds(s, data);\n      data = (void *)((uintptr_t)data + 128);\n      len -= 128;\n    }\n    if (len) {\n      memcpy(s->buffer + in_buffer, data, len);\n    }\n    return;\n  }\n  /* else... NOT 512 bits derived (64bit base) */\n\n  in_buffer = s->length.words[0] & 63;\n  partial = 64 - in_buffer;\n\n  s->length.words[0] += len;\n\n  if (partial > len) {\n    memcpy(s->buffer + in_buffer, data, len);\n    return;\n  }\n  if (in_buffer) {\n    memcpy(s->buffer + in_buffer, data, partial);\n    len -= partial;\n    data = (void *)((uintptr_t)data + partial);\n    fio_sha2_perform_all_rounds(s, s->buffer);\n  }\n  while (len >= 64) {\n    fio_sha2_perform_all_rounds(s, data);\n    data = (void *)((uintptr_t)data + 64);\n    len -= 64;\n  }\n  if (len) {\n    memcpy(s->buffer + in_buffer, data, len);\n  }\n  return;\n}\n\n/**\nFinalizes the SHA-2 hash, returning the Hashed data.\n\n`sha2_result` can be called for the same object multiple times, but the\nfinalization will only be performed the first time this function is called.\n*/\nchar *fio_sha2_result(fio_sha2_s *s) {\n  if (s->type & 1) {\n    /* 512 bits derived hashing */\n\n    size_t in_buffer = s->length.words[0] & 127;\n\n    if (in_buffer > 111) {\n      memcpy(s->buffer + in_buffer, sha2_padding, 128 - in_buffer);\n      fio_sha2_perform_all_rounds(s, s->buffer);\n      memcpy(s->buffer, sha2_padding + 1, 112);\n    } else if (in_buffer != 111) {\n      memcpy(s->buffer + in_buffer, sha2_padding, 112 - in_buffer);\n    } else {\n      s->buffer[111] = sha2_padding[0];\n    }\n    /* store the length in BITS - alignment should be promised by struct */\n    /* this must the number in BITS, encoded as a BIG ENDIAN 64 bit number */\n\n    s->length.words[1] = (s->length.words[1] << 3) | (s->length.words[0] >> 61);\n    s->length.words[0] = s->length.words[0] << 3;\n    s->length.words[0] = fio_lton64(s->length.words[0]);\n    s->length.words[1] = fio_lton64(s->length.words[1]);\n\n#if !__BIG_ENDIAN__\n    {\n      uint_fast64_t tmp = s->length.words[0];\n      s->length.words[0] = s->length.words[1];\n      s->length.words[1] = tmp;\n    }\n#endif\n\n    uint64_t *len = (uint64_t *)(s->buffer + 112);\n    len[0] = s->length.words[0];\n    len[1] = s->length.words[1];\n    fio_sha2_perform_all_rounds(s, s->buffer);\n\n    /* change back to little endian */\n    s->digest.i64[0] = fio_ntol64(s->digest.i64[0]);\n    s->digest.i64[1] = fio_ntol64(s->digest.i64[1]);\n    s->digest.i64[2] = fio_ntol64(s->digest.i64[2]);\n    s->digest.i64[3] = fio_ntol64(s->digest.i64[3]);\n    s->digest.i64[4] = fio_ntol64(s->digest.i64[4]);\n    s->digest.i64[5] = fio_ntol64(s->digest.i64[5]);\n    s->digest.i64[6] = fio_ntol64(s->digest.i64[6]);\n    s->digest.i64[7] = fio_ntol64(s->digest.i64[7]);\n    // set NULL bytes for SHA-2 Type\n    switch (s->type) {\n    case SHA_512_224:\n      s->digest.str[28] = 0;\n      break;\n    case SHA_512_256:\n      s->digest.str[32] = 0;\n      break;\n    case SHA_384:\n      s->digest.str[48] = 0;\n      break;\n    default:\n      s->digest.str[64] =\n          0; /* sometimes the optimizer messes the NUL sequence */\n      break;\n    }\n    // fprintf(stderr, \"result requested, in hex, is:\");\n    // for (size_t i = 0; i < ((s->type & 1) ? 64 : 32); i++)\n    //   fprintf(stderr, \"%02x\", (unsigned int)(s->digest.str[i] & 0xFF));\n    // fprintf(stderr, \"\\r\\n\");\n    return (char *)s->digest.str;\n  }\n\n  size_t in_buffer = s->length.words[0] & 63;\n  if (in_buffer > 55) {\n    memcpy(s->buffer + in_buffer, sha2_padding, 64 - in_buffer);\n    fio_sha2_perform_all_rounds(s, s->buffer);\n    memcpy(s->buffer, sha2_padding + 1, 56);\n  } else if (in_buffer != 55) {\n    memcpy(s->buffer + in_buffer, sha2_padding, 56 - in_buffer);\n  } else {\n    s->buffer[55] = sha2_padding[0];\n  }\n  /* store the length in BITS - alignment should be promised by struct */\n  /* this must the number in BITS, encoded as a BIG ENDIAN 64 bit number */\n  uint64_t *len = (uint64_t *)(s->buffer + 56);\n  *len = s->length.words[0] << 3;\n  *len = fio_lton64(*len);\n  fio_sha2_perform_all_rounds(s, s->buffer);\n\n  /* change back to little endian, if required */\n\n  s->digest.i32[0] = fio_ntol32(s->digest.i32[0]);\n  s->digest.i32[1] = fio_ntol32(s->digest.i32[1]);\n  s->digest.i32[2] = fio_ntol32(s->digest.i32[2]);\n  s->digest.i32[3] = fio_ntol32(s->digest.i32[3]);\n  s->digest.i32[4] = fio_ntol32(s->digest.i32[4]);\n  s->digest.i32[5] = fio_ntol32(s->digest.i32[5]);\n  s->digest.i32[6] = fio_ntol32(s->digest.i32[6]);\n  s->digest.i32[7] = fio_ntol32(s->digest.i32[7]);\n\n  // set NULL bytes for SHA_224\n  if (s->type == SHA_224)\n    s->digest.str[28] = 0;\n  // fprintf(stderr, \"SHA-2 result requested, in hex, is:\");\n  // for (size_t i = 0; i < ((s->type & 1) ? 64 : 32); i++)\n  //   fprintf(stderr, \"%02x\", (unsigned int)(s->digest.str[i] & 0xFF));\n  // fprintf(stderr, \"\\r\\n\");\n  return (char *)s->digest.str;\n}\n\n#undef perform_single_round\n\n/* ****************************************************************************\nBase64 encoding\n***************************************************************************** */\n\n/** the base64 encoding array */\nstatic const char base64_encodes_original[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n/** the base64 encoding array */\nstatic const char base64_encodes_url[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\";\n\n/**\nA base64 decoding array.\n\nGeneration script (Ruby):\n\na = []; a[255] = 0\ns = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".bytes;\ns.length.times {|i| a[s[i]] = i };\ns = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+,\".bytes;\ns.length.times {|i| a[s[i]] = i };\ns = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\".bytes;\ns.length.times {|i| a[s[i]] = i }; a.map!{ |i| i.to_i }; a\n\n*/\nstatic unsigned base64_decodes[] = {\n    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n    0,  0,  0,  0,  0,  62, 63, 62, 0,  63, 52, 53, 54, 55, 56, 57, 58, 59, 60,\n    61, 0,  0,  0,  64, 0,  0,  0,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10,\n    11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0,  0,  0,  0,\n    63, 0,  26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,\n    43, 44, 45, 46, 47, 48, 49, 50, 51, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n    0,  0,  0,  0,  0,  0,  0,  0,  0,\n};\n#define BITVAL(x) (base64_decodes[(x)] & 63)\n\n/*\n * The actual encoding logic. The map can be switched for encoding variations.\n */\nstatic inline int fio_base64_encode_internal(char *target, const char *data,\n                                             int len,\n                                             const char *base64_encodes) {\n  /* walk backwards, allowing fo inplace decoding (target == data) */\n  int groups = len / 3;\n  const int mod = len - (groups * 3);\n  const int target_size = (groups + (mod != 0)) * 4;\n  char *writer = target + target_size - 1;\n  const char *reader = data + len - 1;\n  writer[1] = 0;\n  switch (mod) {\n  case 2: {\n    char tmp2 = *(reader--);\n    char tmp1 = *(reader--);\n    *(writer--) = '=';\n    *(writer--) = base64_encodes[((tmp2 & 15) << 2)];\n    *(writer--) = base64_encodes[((tmp1 & 3) << 4) | ((tmp2 >> 4) & 15)];\n    *(writer--) = base64_encodes[(tmp1 >> 2) & 63];\n  } break;\n  case 1: {\n    char tmp1 = *(reader--);\n    *(writer--) = '=';\n    *(writer--) = '=';\n    *(writer--) = base64_encodes[(tmp1 & 3) << 4];\n    *(writer--) = base64_encodes[(tmp1 >> 2) & 63];\n  } break;\n  }\n  while (groups) {\n    groups--;\n    const char tmp3 = *(reader--);\n    const char tmp2 = *(reader--);\n    const char tmp1 = *(reader--);\n    *(writer--) = base64_encodes[tmp3 & 63];\n    *(writer--) = base64_encodes[((tmp2 & 15) << 2) | ((tmp3 >> 6) & 3)];\n    *(writer--) = base64_encodes[(((tmp1 & 3) << 4) | ((tmp2 >> 4) & 15))];\n    *(writer--) = base64_encodes[(tmp1 >> 2) & 63];\n  }\n  return target_size;\n}\n\n/**\nThis will encode a byte array (data) of a specified length (len) and\nplace the encoded data into the target byte buffer (target). The target buffer\nMUST have enough room for the expected data.\n\nBase64 encoding always requires 4 bytes for each 3 bytes. Padding is added if\nthe raw data's length isn't devisable by 3.\n\nAlways assume the target buffer should have room enough for (len*4/3 + 4)\nbytes.\n\nReturns the number of bytes actually written to the target buffer\n(including the Base64 required padding and excluding a NULL terminator).\n\nA NULL terminator char is NOT written to the target buffer.\n*/\nint fio_base64_encode(char *target, const char *data, int len) {\n  return fio_base64_encode_internal(target, data, len, base64_encodes_original);\n}\n\n/**\nSame as fio_base64_encode, but using Base64URL encoding.\n*/\nint fio_base64url_encode(char *target, const char *data, int len) {\n  return fio_base64_encode_internal(target, data, len, base64_encodes_url);\n}\n\n/**\nThis will decode a Base64 encoded string of a specified length (len) and\nplace the decoded data into the target byte buffer (target).\n\nThe target buffer MUST have enough room for the expected data.\n\nA NULL byte will be appended to the target buffer. The function will return\nthe number of bytes written to the target buffer.\n\nIf the target buffer is NULL, the encoded string will be destructively edited\nand the decoded data will be placed in the original string's buffer.\n\nBase64 encoding always requires 4 bytes for each 3 bytes. Padding is added if\nthe raw data's length isn't devisable by 3. Hence, the target buffer should\nbe, at least, `base64_len/4*3 + 3` long.\n\nReturns the number of bytes actually written to the target buffer (excluding\nthe NULL terminator byte).\n\nIf an error occurred, returns the number of bytes written up to the error. Test\n`errno` for error (will be set to ERANGE).\n*/\nint fio_base64_decode(char *target, char *encoded, int base64_len) {\n  if (!target)\n    target = encoded;\n  if (base64_len <= 0) {\n    target[0] = 0;\n    return 0;\n  }\n  int written = 0;\n  uint8_t tmp1, tmp2, tmp3, tmp4;\n  // skip unknown data at end\n  while (base64_len &&\n         !base64_decodes[*(uint8_t *)(encoded + (base64_len - 1))]) {\n    base64_len--;\n  }\n  // skip white space\n  while (base64_len && isspace((*(uint8_t *)encoded))) {\n    base64_len--;\n    encoded++;\n  }\n  while (base64_len >= 4) {\n    if (!base64_len) {\n      return written;\n    }\n    tmp1 = *(uint8_t *)(encoded++);\n    tmp2 = *(uint8_t *)(encoded++);\n    tmp3 = *(uint8_t *)(encoded++);\n    tmp4 = *(uint8_t *)(encoded++);\n    if (!base64_decodes[tmp1] || !base64_decodes[tmp2] ||\n        !base64_decodes[tmp3] || !base64_decodes[tmp4]) {\n      errno = ERANGE;\n      goto finish;\n    }\n    *(target++) = (BITVAL(tmp1) << 2) | (BITVAL(tmp2) >> 4);\n    *(target++) = (BITVAL(tmp2) << 4) | (BITVAL(tmp3) >> 2);\n    *(target++) = (BITVAL(tmp3) << 6) | (BITVAL(tmp4));\n    // make sure we don't loop forever.\n    base64_len -= 4;\n    // count written bytes\n    written += 3;\n    // skip white space\n    while (base64_len && isspace((*encoded))) {\n      base64_len--;\n      encoded++;\n    }\n  }\n  // deal with the \"tail\" of the mis-encoded stream - this shouldn't happen\n  tmp1 = 0;\n  tmp2 = 0;\n  tmp3 = 0;\n  tmp4 = 0;\n  switch (base64_len) {\n  case 1:\n    tmp1 = *(uint8_t *)(encoded++);\n    if (!base64_decodes[tmp1]) {\n      errno = ERANGE;\n      goto finish;\n    }\n    *(target++) = BITVAL(tmp1);\n    written += 1;\n    break;\n  case 2:\n    tmp1 = *(uint8_t *)(encoded++);\n    tmp2 = *(uint8_t *)(encoded++);\n    if (!base64_decodes[tmp1] || !base64_decodes[tmp2]) {\n      errno = ERANGE;\n      goto finish;\n    }\n    *(target++) = (BITVAL(tmp1) << 2) | (BITVAL(tmp2) >> 6);\n    *(target++) = (BITVAL(tmp2) << 4);\n    written += 2;\n    break;\n  case 3:\n    tmp1 = *(uint8_t *)(encoded++);\n    tmp2 = *(uint8_t *)(encoded++);\n    tmp3 = *(uint8_t *)(encoded++);\n    if (!base64_decodes[tmp1] || !base64_decodes[tmp2] ||\n        !base64_decodes[tmp3]) {\n      errno = ERANGE;\n      goto finish;\n    }\n    *(target++) = (BITVAL(tmp1) << 2) | (BITVAL(tmp2) >> 6);\n    *(target++) = (BITVAL(tmp2) << 4) | (BITVAL(tmp3) >> 2);\n    *(target++) = BITVAL(tmp3) << 6;\n    written += 3;\n    break;\n  }\nfinish:\n  if (encoded[-1] == '=') {\n    target--;\n    written--;\n    if (encoded[-2] == '=') {\n      target--;\n      written--;\n    }\n    if (written < 0)\n      written = 0;\n  }\n  *target = 0;\n  return written;\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                     Testing\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n#if DEBUG\n\n// clang-format off\n#if defined(HAVE_OPENSSL)\n#  include <openssl/sha.h>\n#endif\n// clang-format on\n\n/* *****************************************************************************\nTesting Linked Lists\n***************************************************************************** */\n\n#define FIO_LLIST_TEST_LIMIT 1016\n\n/**\n * Tests linked list functionality.\n */\n#ifndef H_FIO_LINKED_LIST_H\n#define fio_llist_test()\n#else\nFIO_FUNC inline void fio_llist_test(void) {\n  fio_ls_s list = FIO_LS_INIT(list);\n  size_t counter;\n  fprintf(stderr, \"=== Testing Core Linked List features (fio_ls and \"\n                  \"fio_ls_embs functions)\\n\");\n  /* test push/shift */\n  for (uintptr_t i = 0; i < FIO_LLIST_TEST_LIMIT; ++i) {\n    fio_ls_push(&list, (void *)i);\n  }\n  FIO_ASSERT(fio_ls_any(&list), \"List should be populated after fio_ls_push\");\n  counter = 0;\n  FIO_LS_FOR(&list, pos) {\n    FIO_ASSERT((size_t)pos->obj == counter,\n               \"`FIO_LS_FOR` value error (%zu != %zu)\", (size_t)pos->obj,\n               counter);\n    ++counter;\n  }\n  counter = 0;\n  while (fio_ls_any(&list)) {\n    FIO_ASSERT(counter < FIO_LLIST_TEST_LIMIT,\n               \"`fio_ls_any` didn't return false when expected %p<=%p=>%p\",\n               (void *)list.prev, (void *)&list, (void *)list.next);\n    size_t tmp = (size_t)fio_ls_shift(&list);\n    FIO_ASSERT(tmp == counter, \"`fio_ls_shift` value error (%zu != %zu)\", tmp,\n               counter);\n    ++counter;\n  }\n  FIO_ASSERT(counter == FIO_LLIST_TEST_LIMIT,\n             \"List item count error (%zu != %zu)\", counter,\n             (size_t)FIO_LLIST_TEST_LIMIT);\n  /* test unshift/pop */\n  for (uintptr_t i = 0; i < FIO_LLIST_TEST_LIMIT; ++i) {\n    fio_ls_unshift(&list, (void *)i);\n  }\n  FIO_ASSERT(fio_ls_any(&list),\n             \"List should be populated after fio_ls_unshift\");\n  counter = 0;\n  while (!fio_ls_is_empty(&list)) {\n    FIO_ASSERT(counter < FIO_LLIST_TEST_LIMIT,\n               \"`fio_ls_is_empty` didn't return true when expected %p<=%p=>%p\",\n               (void *)list.prev, (void *)&list, (void *)list.next);\n    size_t tmp = (size_t)fio_ls_pop(&list);\n    FIO_ASSERT(tmp == counter, \"`fio_ls_pop` value error (%zu != %zu)\", tmp,\n               counter);\n    ++counter;\n  }\n  FIO_ASSERT(counter == FIO_LLIST_TEST_LIMIT,\n             \"List item count error (%zu != %zu)\", counter,\n             (size_t)FIO_LLIST_TEST_LIMIT);\n\n  /* Re-test for embeded list */\n\n  struct fio_ls_test_s {\n    size_t i;\n    fio_ls_embd_s node;\n  };\n\n  fio_ls_embd_s emlist = FIO_LS_INIT(emlist);\n\n  /* test push/shift */\n  for (uintptr_t i = 0; i < FIO_LLIST_TEST_LIMIT; ++i) {\n    struct fio_ls_test_s *n = malloc(sizeof(*n));\n    FIO_ASSERT_ALLOC(n);\n    n->i = i;\n    fio_ls_embd_push(&emlist, &n->node);\n    FIO_ASSERT(FIO_LS_EMBD_OBJ(struct fio_ls_test_s, node, emlist.next)->i == 0,\n               \"fio_ls_embd_push should push to the end.\");\n  }\n  FIO_ASSERT(fio_ls_embd_any(&emlist),\n             \"List should be populated after fio_ls_embd_push\");\n  counter = 0;\n  FIO_LS_EMBD_FOR(&emlist, pos) {\n    FIO_ASSERT(FIO_LS_EMBD_OBJ(struct fio_ls_test_s, node, pos)->i == counter,\n               \"`FIO_LS_EMBD_FOR` value error (%zu != %zu)\",\n               FIO_LS_EMBD_OBJ(struct fio_ls_test_s, node, pos)->i, counter);\n    ++counter;\n  }\n  counter = 0;\n  while (fio_ls_embd_any(&emlist)) {\n    FIO_ASSERT(counter < FIO_LLIST_TEST_LIMIT,\n               \"`fio_ls_embd_any` didn't return false when expected %p<=%p=>%p\",\n               (void *)emlist.prev, (void *)&emlist, (void *)emlist.next);\n    struct fio_ls_test_s *n =\n        FIO_LS_EMBD_OBJ(struct fio_ls_test_s, node, fio_ls_embd_shift(&emlist));\n    FIO_ASSERT(n->i == counter, \"`fio_ls_embd_shift` value error (%zu != %zu)\",\n               n->i, counter);\n    free(n);\n    ++counter;\n  }\n  FIO_ASSERT(counter == FIO_LLIST_TEST_LIMIT,\n             \"List item count error (%zu != %zu)\", counter,\n             (size_t)FIO_LLIST_TEST_LIMIT);\n  /* test shift/unshift */\n  for (uintptr_t i = 0; i < FIO_LLIST_TEST_LIMIT; ++i) {\n    struct fio_ls_test_s *n = malloc(sizeof(*n));\n    FIO_ASSERT_ALLOC(n)\n    n->i = i;\n    fio_ls_embd_unshift(&emlist, &n->node);\n    FIO_ASSERT(FIO_LS_EMBD_OBJ(struct fio_ls_test_s, node, emlist.next)->i == i,\n               \"fio_ls_embd_unshift should push to the start.\");\n  }\n  FIO_ASSERT(fio_ls_embd_any(&emlist),\n             \"List should be populated after fio_ls_embd_unshift\");\n  counter = 0;\n  while (!fio_ls_embd_is_empty(&emlist)) {\n    FIO_ASSERT(\n        counter < FIO_LLIST_TEST_LIMIT,\n        \"`fio_ls_embd_is_empty` didn't return true when expected %p<=%p=>%p\",\n        (void *)emlist.prev, (void *)&emlist, (void *)emlist.next);\n    struct fio_ls_test_s *n =\n        FIO_LS_EMBD_OBJ(struct fio_ls_test_s, node, fio_ls_embd_pop(&emlist));\n    FIO_ASSERT(n->i == counter, \"`fio_ls_embd_pop` value error (%zu != %zu)\",\n               n->i, counter);\n    free(n);\n    ++counter;\n  }\n  FIO_ASSERT(counter == FIO_LLIST_TEST_LIMIT,\n             \"List item count error (%zu != %zu)\", counter,\n             (size_t)FIO_LLIST_TEST_LIMIT);\n  fprintf(stderr, \"* passed.\\n\");\n}\n#endif\n\n/* *****************************************************************************\nTesting Strings\n***************************************************************************** */\n\n#ifndef H_FIO_STR_H\n#define fio_str_test()\n#else\n\nstatic int fio_str_test_dealloc_counter = 0;\n\nFIO_FUNC void fio_str_test_dealloc(void *s) {\n  FIO_ASSERT(!fio_str_test_dealloc_counter,\n             \"fio_str_s reference count error!\\n\");\n  fio_free(s);\n  fprintf(stderr, \"* reference counting `fio_str_free2` pass.\\n\");\n}\n\n/**\n * Tests the fio_str functionality.\n */\nFIO_FUNC inline void fio_str_test(void) {\n#define ROUND_UP_CAPA_2WORDS(num)                                              \\\n  (((num + 1) & (sizeof(long double) - 1))                                     \\\n       ? ((num + 1) | (sizeof(long double) - 1))                               \\\n       : (num))\n  fprintf(stderr, \"=== Testing Core String features (fio_str_s functions)\\n\");\n  fprintf(stderr, \"* String container size: %zu\\n\", sizeof(fio_str_s));\n  fprintf(stderr,\n          \"* Self-Contained String Capacity (FIO_STR_SMALL_CAPA): %zu\\n\",\n          FIO_STR_SMALL_CAPA);\n  fio_str_s str = {.small = 0}; /* test zeroed out memory */\n  FIO_ASSERT(fio_str_capa(&str) == FIO_STR_SMALL_CAPA - 1,\n             \"Small String capacity reporting error!\");\n  FIO_ASSERT(fio_str_len(&str) == 0, \"Small String length reporting error!\");\n  FIO_ASSERT(fio_str_data(&str) ==\n                 (char *)((uintptr_t)(&str + 1) - FIO_STR_SMALL_CAPA),\n             \"Small String pointer reporting error (%zd offset)!\",\n             (ssize_t)(((char *)((uintptr_t)(&str + 1) - FIO_STR_SMALL_CAPA)) -\n                       fio_str_data(&str)));\n  fio_str_write(&str, \"World\", 4);\n  FIO_ASSERT(str.small,\n             \"Small String writing error - not small on small write!\");\n  FIO_ASSERT(fio_str_capa(&str) == FIO_STR_SMALL_CAPA - 1,\n             \"Small String capacity reporting error after write!\");\n  FIO_ASSERT(fio_str_len(&str) == 4,\n             \"Small String length reporting error after write!\");\n  FIO_ASSERT(fio_str_data(&str) ==\n                 (char *)((uintptr_t)(&str + 1) - FIO_STR_SMALL_CAPA),\n             \"Small String pointer reporting error after write!\");\n  FIO_ASSERT(strlen(fio_str_data(&str)) == 4,\n             \"Small String NUL missing after write (%zu)!\",\n             strlen(fio_str_data(&str)));\n  FIO_ASSERT(!strcmp(fio_str_data(&str), \"Worl\"),\n             \"Small String write error (%s)!\", fio_str_data(&str));\n  FIO_ASSERT(fio_str_data(&str) == fio_str_info(&str).data,\n             \"Small String `fio_str_data` != `fio_str_info(s).data` (%p != %p)\",\n             (void *)fio_str_data(&str), (void *)fio_str_info(&str).data);\n\n  fio_str_capa_assert(&str, sizeof(fio_str_s) - 1);\n  FIO_ASSERT(!str.small,\n             \"Long String reporting as small after capacity update!\");\n  FIO_ASSERT(fio_str_capa(&str) >= sizeof(fio_str_s) - 1,\n             \"Long String capacity update error (%zu != %zu)!\",\n             fio_str_capa(&str), sizeof(fio_str_s));\n  FIO_ASSERT(fio_str_data(&str) == fio_str_info(&str).data,\n             \"Long String `fio_str_data` !>= `fio_str_info(s).data` (%p != %p)\",\n             (void *)fio_str_data(&str), (void *)fio_str_info(&str).data);\n\n  FIO_ASSERT(\n      fio_str_len(&str) == 4,\n      \"Long String length changed during conversion from small string (%zu)!\",\n      fio_str_len(&str));\n  FIO_ASSERT(fio_str_data(&str) == str.data,\n             \"Long String pointer reporting error after capacity update!\");\n  FIO_ASSERT(strlen(fio_str_data(&str)) == 4,\n             \"Long String NUL missing after capacity update (%zu)!\",\n             strlen(fio_str_data(&str)));\n  FIO_ASSERT(!strcmp(fio_str_data(&str), \"Worl\"),\n             \"Long String value changed after capacity update (%s)!\",\n             fio_str_data(&str));\n\n  fio_str_write(&str, \"d!\", 2);\n  FIO_ASSERT(!strcmp(fio_str_data(&str), \"World!\"),\n             \"Long String `write` error (%s)!\", fio_str_data(&str));\n\n  fio_str_replace(&str, 0, 0, \"Hello \", 6);\n  FIO_ASSERT(!strcmp(fio_str_data(&str), \"Hello World!\"),\n             \"Long String `insert` error (%s)!\", fio_str_data(&str));\n\n  fio_str_resize(&str, 6);\n  FIO_ASSERT(!strcmp(fio_str_data(&str), \"Hello \"),\n             \"Long String `resize` clipping error (%s)!\", fio_str_data(&str));\n\n  fio_str_replace(&str, 6, 0, \"My World!\", 9);\n  FIO_ASSERT(!strcmp(fio_str_data(&str), \"Hello My World!\"),\n             \"Long String `replace` error when testing overflow (%s)!\",\n             fio_str_data(&str));\n\n  str.capa = str.len;\n  fio_str_replace(&str, -10, 2, \"Big\", 3);\n  FIO_ASSERT(!strcmp(fio_str_data(&str), \"Hello Big World!\"),\n             \"Long String `replace` error when testing splicing (%s)!\",\n             fio_str_data(&str));\n\n  FIO_ASSERT(\n      fio_str_capa(&str) == ROUND_UP_CAPA_2WORDS(strlen(\"Hello Big World!\")),\n      \"Long String `fio_str_replace` capacity update error (%zu != %zu)!\",\n      fio_str_capa(&str), ROUND_UP_CAPA_2WORDS(strlen(\"Hello Big World!\")));\n\n  if (str.len < FIO_STR_SMALL_CAPA) {\n    fio_str_compact(&str);\n    FIO_ASSERT(str.small, \"Compacting didn't change String to small!\");\n    FIO_ASSERT(fio_str_len(&str) == strlen(\"Hello Big World!\"),\n               \"Compacting altered String length! (%zu != %zu)!\",\n               fio_str_len(&str), strlen(\"Hello Big World!\"));\n    FIO_ASSERT(!strcmp(fio_str_data(&str), \"Hello Big World!\"),\n               \"Compact data error (%s)!\", fio_str_data(&str));\n    FIO_ASSERT(fio_str_capa(&str) == FIO_STR_SMALL_CAPA - 1,\n               \"Compacted String capacity reporting error!\");\n  } else {\n    fprintf(stderr, \"* skipped `compact` test!\\n\");\n  }\n\n  {\n    fio_str_freeze(&str);\n    fio_str_info_s old_state = fio_str_info(&str);\n    fio_str_write(&str, \"more data to be written here\", 28);\n    fio_str_replace(&str, 2, 1, \"more data to be written here\", 28);\n    fio_str_info_s new_state = fio_str_info(&str);\n    FIO_ASSERT(old_state.len == new_state.len, \"Frozen String length changed!\");\n    FIO_ASSERT(old_state.data == new_state.data,\n               \"Frozen String pointer changed!\");\n    FIO_ASSERT(\n        old_state.capa == new_state.capa,\n        \"Frozen String capacity changed (allowed, but shouldn't happen)!\");\n    str.frozen = 0;\n  }\n  fio_str_printf(&str, \" %u\", 42);\n  FIO_ASSERT(!strcmp(fio_str_data(&str), \"Hello Big World! 42\"),\n             \"`fio_str_printf` data error (%s)!\", fio_str_data(&str));\n\n  {\n    fio_str_s str2 = FIO_STR_INIT;\n    fio_str_concat(&str2, &str);\n    FIO_ASSERT(fio_str_iseq(&str, &str2),\n               \"`fio_str_concat` error, strings not equal (%s != %s)!\",\n               fio_str_data(&str), fio_str_data(&str2));\n    fio_str_write(&str2, \":extra data\", 11);\n    FIO_ASSERT(\n        !fio_str_iseq(&str, &str2),\n        \"`fio_str_write` error after copy, strings equal ((%zu)%s == (%zu)%s)!\",\n        fio_str_len(&str), fio_str_data(&str), fio_str_len(&str2),\n        fio_str_data(&str2));\n\n    fio_str_free(&str2);\n  }\n\n  fio_str_free(&str);\n\n  fio_str_write_i(&str, -42);\n  FIO_ASSERT(fio_str_len(&str) == 3 && !memcmp(\"-42\", fio_str_data(&str), 3),\n             \"fio_str_write_i output error ((%zu) %s != -42)\",\n             fio_str_len(&str), fio_str_data(&str));\n  fio_str_free(&str);\n\n  {\n    fprintf(stderr, \"* testing `fio_str_readfile`, and reference counting.\\n\");\n    fio_str_s *s = fio_str_new2();\n    FIO_ASSERT(s && s->small,\n               \"`fio_str_new2` error, string not initialized (%p)!\", (void *)s);\n    fio_str_s *s2 = fio_str_dup(s);\n\n    ++fio_str_test_dealloc_counter;\n\n    FIO_ASSERT(s2 == s, \"`fio_str_dup` error, should return self!\");\n    FIO_ASSERT(s->ref == 1,\n               \"`fio_str_dup` error, reference counter not incremented!\");\n\n    fprintf(stderr, \"* reading a file.\\n\");\n    fio_str_info_s state = fio_str_readfile(s, __FILE__, 0, 0);\n    if (!s->small) /* attach deallocation test */\n      s->dealloc = fio_str_test_dealloc;\n\n    FIO_ASSERT(state.data,\n               \"`fio_str_readfile` error, no data was read for file %s!\",\n               __FILE__);\n\n    FIO_ASSERT(!memcmp(state.data,\n                       \"/* \"\n                       \"******************************************************\"\n                       \"***********************\",\n                       80),\n               \"`fio_str_readfile` content error, header mismatch!\\n %s\",\n               state.data);\n    fprintf(stderr, \"* testing UTF-8 validation and length.\\n\");\n    FIO_ASSERT(\n        fio_str_utf8_valid(s),\n        \"`fio_str_utf8_valid` error, code in this file should be valid!\");\n    FIO_ASSERT(fio_str_utf8_len(s) && (fio_str_utf8_len(s) <= fio_str_len(s)) &&\n                   (fio_str_utf8_len(s) >= (fio_str_len(s)) >> 1),\n               \"`fio_str_utf8_len` error, invalid value (%zu / %zu!\",\n               fio_str_utf8_len(s), fio_str_len(s));\n\n    fprintf(stderr, \"* reviewing reference counting `fio_str_free2` (1/2).\\n\");\n    fio_str_free2(s2);\n    --fio_str_test_dealloc_counter;\n    FIO_ASSERT(s->ref == 0,\n               \"`fio_str_free2` error, reference counter not subtracted!\");\n    FIO_ASSERT(s->small == 0, \"`fio_str_free2` error, strring reinitialized!\");\n    FIO_ASSERT(\n        fio_str_data(s) == state.data,\n        \"`fio_str_free2` error, data freed while references exist! (%p != %p)\",\n        (void *)fio_str_data(s), (void *)state.data);\n\n    if (1) {\n      /* String content == whole file (this file) */\n      intptr_t pos = -11;\n      size_t len = 20;\n      fprintf(stderr, \"* testing UTF-8 positioning.\\n\");\n\n      FIO_ASSERT(\n          fio_str_utf8_select(s, &pos, &len) == 0,\n          \"`fio_str_utf8_select` returned error for negative pos! (%zd, %zu)\",\n          (ssize_t)pos, len);\n      FIO_ASSERT(\n          pos == (intptr_t)state.len - 10, /* no UTF-8 bytes in this file */\n          \"`fio_str_utf8_select` error, negative position invalid! (%zd)\",\n          (ssize_t)pos);\n      FIO_ASSERT(len == 10,\n                 \"`fio_str_utf8_select` error, trancated length invalid! (%zd)\",\n                 (ssize_t)len);\n      pos = 10;\n      len = 20;\n      FIO_ASSERT(fio_str_utf8_select(s, &pos, &len) == 0,\n                 \"`fio_str_utf8_select` returned error! (%zd, %zu)\",\n                 (ssize_t)pos, len);\n      FIO_ASSERT(pos == 10,\n                 \"`fio_str_utf8_select` error, position invalid! (%zd)\",\n                 (ssize_t)pos);\n      FIO_ASSERT(len == 20,\n                 \"`fio_str_utf8_select` error, length invalid! (%zd)\",\n                 (ssize_t)len);\n    }\n    fprintf(stderr, \"* reviewing reference counting `fio_str_free2` (2/2).\\n\");\n    fio_str_free2(s);\n    fprintf(stderr, \"* finished reference counting test.\\n\");\n  }\n  fio_str_free(&str);\n  if (1) {\n\n    const char *utf8_sample = /* three hearts, small-big-small*/\n        \"\\xf0\\x9f\\x92\\x95\\xe2\\x9d\\xa4\\xef\\xb8\\x8f\\xf0\\x9f\\x92\\x95\";\n    fio_str_write(&str, utf8_sample, strlen(utf8_sample));\n    intptr_t pos = -2;\n    size_t len = 2;\n    FIO_ASSERT(fio_str_utf8_select(&str, &pos, &len) == 0,\n               \"`fio_str_utf8_select` returned error for negative pos on \"\n               \"UTF-8 data! (%zd, %zu)\",\n               (ssize_t)pos, len);\n    FIO_ASSERT(pos == (intptr_t)fio_str_len(&str) - 4, /* 4 byte emoji */\n               \"`fio_str_utf8_select` error, negative position invalid on \"\n               \"UTF-8 data! (%zd)\",\n               (ssize_t)pos);\n    FIO_ASSERT(len == 4, /* last utf-8 char is 4 byte long */\n               \"`fio_str_utf8_select` error, trancated length invalid on \"\n               \"UTF-8 data! (%zd)\",\n               (ssize_t)len);\n    pos = 1;\n    len = 20;\n    FIO_ASSERT(fio_str_utf8_select(&str, &pos, &len) == 0,\n               \"`fio_str_utf8_select` returned error on UTF-8 data! (%zd, %zu)\",\n               (ssize_t)pos, len);\n    FIO_ASSERT(\n        pos == 4,\n        \"`fio_str_utf8_select` error, position invalid on UTF-8 data! (%zd)\",\n        (ssize_t)pos);\n    FIO_ASSERT(\n        len == 10,\n        \"`fio_str_utf8_select` error, length invalid on UTF-8 data! (%zd)\",\n        (ssize_t)len);\n    pos = 1;\n    len = 3;\n    FIO_ASSERT(\n        fio_str_utf8_select(&str, &pos, &len) == 0,\n        \"`fio_str_utf8_select` returned error on UTF-8 data (2)! (%zd, %zu)\",\n        (ssize_t)pos, len);\n    FIO_ASSERT(\n        len == 10, /* 3 UTF-8 chars: 4 byte + 4 byte + 2 byte codes == 10 */\n        \"`fio_str_utf8_select` error, length invalid on UTF-8 data! (%zd)\",\n        (ssize_t)len);\n  }\n  fio_str_free(&str);\n  if (1) {\n    str = FIO_STR_INIT_STATIC(\"Welcome\");\n    FIO_ASSERT(fio_str_capa(&str) == 0, \"Static string capacity non-zero.\");\n    FIO_ASSERT(fio_str_len(&str) > 0,\n               \"Static string length should be automatically calculated.\");\n    FIO_ASSERT(str.dealloc == NULL,\n               \"Static string deallocation function should be NULL.\");\n    fio_str_free(&str);\n    str = FIO_STR_INIT_STATIC(\"Welcome\");\n    fio_str_info_s state = fio_str_write(&str, \" Home\", 5);\n    FIO_ASSERT(state.capa > 0, \"Static string not converted to non-static.\");\n    FIO_ASSERT(str.dealloc, \"Missing static string deallocation function\"\n                            \" after `fio_str_write`.\");\n\n    fprintf(stderr, \"* reviewing `fio_str_detach`.\\n   (%zu): %s\\n\",\n            fio_str_info(&str).len, fio_str_info(&str).data);\n    char *cstr = fio_str_detach(&str);\n    FIO_ASSERT(cstr, \"`fio_str_detach` returned NULL\");\n    FIO_ASSERT(!memcmp(cstr, \"Welcome Home\\0\", 13),\n               \"`fio_str_detach` string error: %s\", cstr);\n    fio_free(cstr);\n    FIO_ASSERT(fio_str_len(&str) == 0, \"`fio_str_detach` data wasn't cleared.\");\n    // fio_str_free(&str);\n  }\n  fprintf(stderr, \"* passed.\\n\");\n}\n#endif\n\n/* *****************************************************************************\nTesting Memory Allocator\n***************************************************************************** */\n\n#if FIO_FORCE_MALLOC\n#define fio_malloc_test()                                                      \\\n  fprintf(stderr, \"\\n=== SKIPPED facil.io memory allocator (bypassed)\\n\");\n#else\nFIO_FUNC void fio_malloc_test(void) {\n  fprintf(stderr, \"\\n=== Testing facil.io memory allocator's system calls\\n\");\n  char *mem = sys_alloc(FIO_MEMORY_BLOCK_SIZE, 0);\n  FIO_ASSERT(mem, \"sys_alloc failed to allocate memory!\\n\");\n  FIO_ASSERT(!((uintptr_t)mem & FIO_MEMORY_BLOCK_MASK),\n             \"Memory allocation not aligned to FIO_MEMORY_BLOCK_SIZE!\");\n  mem[0] = 'a';\n  mem[FIO_MEMORY_BLOCK_SIZE - 1] = 'z';\n  fprintf(stderr, \"* Testing reallocation from %p\\n\", (void *)mem);\n  char *mem2 =\n      sys_realloc(mem, FIO_MEMORY_BLOCK_SIZE, FIO_MEMORY_BLOCK_SIZE * 2);\n  if (mem == mem2)\n    fprintf(stderr, \"* Performed system realloc without copy :-)\\n\");\n  FIO_ASSERT(mem2[0] == 'a' && mem2[FIO_MEMORY_BLOCK_SIZE - 1] == 'z',\n             \"Reaclloc data was lost!\");\n  sys_free(mem2, FIO_MEMORY_BLOCK_SIZE * 2);\n  fprintf(stderr, \"=== Testing facil.io memory allocator's internal data.\\n\");\n  FIO_ASSERT(arenas, \"Missing arena data - library not initialized!\");\n  fio_free(NULL); /* fio_free(NULL) shouldn't crash... */\n  mem = fio_malloc(1);\n  FIO_ASSERT(mem, \"fio_malloc failed to allocate memory!\\n\");\n  FIO_ASSERT(!((uintptr_t)mem & 15), \"fio_malloc memory not aligned!\\n\");\n  FIO_ASSERT(((uintptr_t)mem & FIO_MEMORY_BLOCK_MASK) != 16,\n             \"small fio_malloc memory indicates system allocation!\\n\");\n  mem[0] = 'a';\n  FIO_ASSERT(mem[0] == 'a', \"allocate memory wasn't written to!\\n\");\n  mem = fio_realloc(mem, 1);\n  FIO_ASSERT(mem, \"fio_realloc failed!\\n\");\n  FIO_ASSERT(mem[0] == 'a', \"fio_realloc memory wasn't copied!\\n\");\n  FIO_ASSERT(arena_last_used, \"arena_last_used wasn't initialized!\\n\");\n  fio_free(mem);\n  block_s *b = arena_last_used->block;\n\n  /* move arena to block's start */\n  while (arena_last_used->block == b) {\n    mem = fio_malloc(1);\n    FIO_ASSERT(mem, \"fio_malloc failed to allocate memory!\\n\");\n    fio_free(mem);\n  }\n  /* make sure a block is assigned */\n  fio_free(fio_malloc(1));\n  b = arena_last_used->block;\n  size_t count = 1;\n  /* count allocations within block */\n  do {\n    FIO_ASSERT(mem, \"fio_malloc failed to allocate memory!\\n\");\n    FIO_ASSERT(!((uintptr_t)mem & 15),\n               \"fio_malloc memory not aligned at allocation #%zu!\\n\", count);\n    FIO_ASSERT((((uintptr_t)mem & FIO_MEMORY_BLOCK_MASK) != 16),\n               \"fio_malloc memory indicates system allocation!\\n\");\n#if __x86_64__\n    fio_memcpy((size_t *)mem, (size_t *)\"0123456789abcdefg\", 1);\n#else\n    mem[0] = 'a';\n#endif\n    fio_free(mem); /* make sure we hold on to the block, so it rotates */\n    mem = fio_malloc(1);\n    ++count;\n  } while (arena_last_used->block == b);\n  {\n    fprintf(stderr, \"* Confirm block address: %p, last allocation was %p\\n\",\n            (void *)arena_last_used->block, (void *)mem);\n    fprintf(\n        stderr,\n        \"* Performed %zu allocations out of expected %zu allocations per \"\n        \"block.\\n\",\n        count,\n        (size_t)((FIO_MEMORY_BLOCK_SLICES - 2) - (sizeof(block_s) >> 4) - 1));\n    fio_ls_embd_s old_memory_list = memory.available;\n    fio_free(mem);\n    FIO_ASSERT(fio_ls_embd_any(&memory.available),\n               \"memory pool empty (memory block wasn't freed)!\\n\");\n    FIO_ASSERT(old_memory_list.next != memory.available.next ||\n                   memory.available.prev != old_memory_list.prev,\n               \"memory pool not updated after block being freed!\\n\");\n  }\n  /* rotate block again */\n  b = arena_last_used->block;\n  mem = fio_realloc(mem, 1);\n  do {\n    mem2 = mem;\n    mem = fio_malloc(1);\n    fio_free(mem2); /* make sure we hold on to the block, so it rotates */\n    FIO_ASSERT(mem, \"fio_malloc failed to allocate memory!\\n\");\n    FIO_ASSERT(!((uintptr_t)mem & 15),\n               \"fio_malloc memory not aligned at allocation #%zu!\\n\", count);\n    FIO_ASSERT((((uintptr_t)mem & FIO_MEMORY_BLOCK_MASK) != 16),\n               \"fio_malloc memory indicates system allocation!\\n\");\n#if __x86_64__\n    fio_memcpy((size_t *)mem, (size_t *)\"0123456789abcdefg\", 1);\n#else\n    mem[0] = 'a';\n#endif\n    ++count;\n  } while (arena_last_used->block == b);\n\n  mem2 = mem;\n  mem = fio_calloc(FIO_MEMORY_BLOCK_ALLOC_LIMIT - 64, 1);\n  fio_free(mem2);\n  FIO_ASSERT(mem,\n             \"failed to allocate FIO_MEMORY_BLOCK_ALLOC_LIMIT - 64 bytes!\\n\");\n  FIO_ASSERT(((uintptr_t)mem & FIO_MEMORY_BLOCK_MASK) != 16,\n             \"fio_calloc (under limit) memory alignment error!\\n\");\n  mem2 = fio_malloc(1);\n  FIO_ASSERT(mem2, \"fio_malloc(1) failed to allocate memory!\\n\");\n  mem2[0] = 'a';\n\n  for (uintptr_t i = 0; i < (FIO_MEMORY_BLOCK_ALLOC_LIMIT - 64); ++i) {\n    FIO_ASSERT(mem[i] == 0,\n               \"calloc returned memory that wasn't initialized?!\\n\");\n  }\n  fio_free(mem);\n\n  mem = fio_malloc(FIO_MEMORY_BLOCK_SIZE);\n  FIO_ASSERT(mem, \"fio_malloc failed to FIO_MEMORY_BLOCK_SIZE bytes!\\n\");\n  FIO_ASSERT(((uintptr_t)mem & FIO_MEMORY_BLOCK_MASK) == 16,\n             \"fio_malloc (big) memory isn't aligned!\\n\");\n  mem = fio_realloc(mem, FIO_MEMORY_BLOCK_SIZE * 2);\n  FIO_ASSERT(mem,\n             \"fio_realloc (big) failed on FIO_MEMORY_BLOCK_SIZE X2 bytes!\\n\");\n  fio_free(mem);\n  FIO_ASSERT(((uintptr_t)mem & FIO_MEMORY_BLOCK_MASK) == 16,\n             \"fio_realloc (big) memory isn't aligned!\\n\");\n\n  {\n    void *m0 = fio_malloc(0);\n    void *rm0 = fio_realloc(m0, 16);\n    FIO_ASSERT(m0 != rm0, \"fio_realloc(fio_malloc(0), 16) failed!\\n\");\n    fio_free(rm0);\n  }\n  {\n    size_t pool_size = 0;\n    FIO_LS_EMBD_FOR(&memory.available, node) { ++pool_size; }\n    mem = fio_mmap(512);\n    FIO_ASSERT(mem, \"fio_mmap allocation failed!\\n\");\n    fio_free(mem);\n    size_t new_pool_size = 0;\n    FIO_LS_EMBD_FOR(&memory.available, node) { ++new_pool_size; }\n    FIO_ASSERT(new_pool_size == pool_size,\n               \"fio_free of fio_mmap went to memory pool!\\n\");\n  }\n\n  fprintf(stderr, \"* passed.\\n\");\n}\n#endif\n\n/* *****************************************************************************\nTesting Core Callback add / remove / ensure\n***************************************************************************** */\n\nFIO_FUNC void fio_state_callback_test_task(void *pi) {\n  ((uintptr_t *)pi)[0] += 1;\n}\n\n#define FIO_STATE_TEST_COUNT 10\nFIO_FUNC void fio_state_callback_order_test_task(void *pi) {\n  static uintptr_t start = FIO_STATE_TEST_COUNT;\n  --start;\n  FIO_ASSERT((uintptr_t)pi == start,\n             \"Callback order error, expecting %zu, got %zu\", (size_t)start,\n             (size_t)pi);\n}\n\nFIO_FUNC void fio_state_callback_test(void) {\n  fprintf(stderr, \"=== Testing facil.io workflow state callback system\\n\");\n  uintptr_t result = 0;\n  uintptr_t other = 0;\n  fio_state_callback_add(FIO_CALL_NEVER, fio_state_callback_test_task, &result);\n  FIO_ASSERT(callback_collection[FIO_CALL_NEVER].callbacks.next,\n             \"Callback list failed to initialize.\");\n  fio_state_callback_force(FIO_CALL_NEVER);\n  FIO_ASSERT(result == 1, \"Callback wasn't called!\");\n  fio_state_callback_force(FIO_CALL_NEVER);\n  FIO_ASSERT(result == 2, \"Callback wasn't called (second time)!\");\n  fio_state_callback_remove(FIO_CALL_NEVER, fio_state_callback_test_task,\n                            &result);\n  fio_state_callback_force(FIO_CALL_NEVER);\n  FIO_ASSERT(result == 2, \"Callback wasn't removed!\");\n  fio_state_callback_add(FIO_CALL_NEVER, fio_state_callback_test_task, &result);\n  fio_state_callback_add(FIO_CALL_NEVER, fio_state_callback_test_task, &other);\n  fio_state_callback_clear(FIO_CALL_NEVER);\n  fio_state_callback_force(FIO_CALL_NEVER);\n  FIO_ASSERT(result == 2 && other == 0, \"Callbacks werent cleared!\");\n  for (uintptr_t i = 0; i < FIO_STATE_TEST_COUNT; ++i) {\n    fio_state_callback_add(FIO_CALL_NEVER, fio_state_callback_order_test_task,\n                           (void *)i);\n  }\n  fio_state_callback_force(FIO_CALL_NEVER);\n  fio_state_callback_clear(FIO_CALL_NEVER);\n  fprintf(stderr, \"* passed.\\n\");\n}\n#undef FIO_STATE_TEST_COUNT\n/* *****************************************************************************\nTesting fio_timers\n***************************************************************************** */\n\nFIO_FUNC void fio_timer_test_task(void *arg) { ++(((size_t *)arg)[0]); }\n\nFIO_FUNC void fio_timer_test(void) {\n  fprintf(stderr, \"=== Testing facil.io timer system\\n\");\n  size_t result = 0;\n  const size_t total = 5;\n  fio_data->active = 1;\n  FIO_ASSERT(fio_timers.next, \"Timers not initialized!\");\n  FIO_ASSERT(fio_run_every(0, 0, fio_timer_test_task, NULL, NULL) == -1,\n             \"Timers without an interval should be an error.\");\n  FIO_ASSERT(fio_run_every(1000, 0, NULL, NULL, NULL) == -1,\n             \"Timers without a task should be an error.\");\n  FIO_ASSERT(fio_run_every(900, total, fio_timer_test_task, &result,\n                           fio_timer_test_task) == 0,\n             \"Timer creation failure.\");\n  FIO_ASSERT(fio_ls_embd_any(&fio_timers),\n             \"Timer scheduling failure - no timer in list.\");\n  FIO_ASSERT(fio_timer_calc_first_interval() >= 898 &&\n                 fio_timer_calc_first_interval() <= 902,\n             \"next timer calculation error %zu\",\n             fio_timer_calc_first_interval());\n\n  fio_ls_embd_s *first = fio_timers.next;\n  FIO_ASSERT(fio_run_every(10000, total, fio_timer_test_task, &result,\n                           fio_timer_test_task) == 0,\n             \"Timer creation failure (second timer).\");\n  FIO_ASSERT(fio_timers.next == first, \"Timer Ordering error!\");\n\n  FIO_ASSERT(fio_timer_calc_first_interval() >= 898 &&\n                 fio_timer_calc_first_interval() <= 902,\n             \"next timer calculation error (after added timer) %zu\",\n             fio_timer_calc_first_interval());\n\n  fio_data->last_cycle.tv_nsec += 800;\n  fio_timer_schedule();\n  fio_defer_perform();\n  FIO_ASSERT(result == 0, \"Timer filtering error (%zu != 0)\\n\", result);\n\n  for (size_t i = 0; i < total; ++i) {\n    fio_data->last_cycle.tv_sec += 1;\n    // fio_data->last_cycle.tv_nsec += 1;\n    fio_timer_schedule();\n    fio_defer_perform();\n    FIO_ASSERT(((i != total - 1 && result == i + 1) ||\n                (i == total - 1 && result == total + 1)),\n               \"Timer running and rescheduling error (%zu != %zu)\\n\", result,\n               i + 1);\n    FIO_ASSERT(fio_timers.next == first || i == total - 1,\n               \"Timer Ordering error on cycle %zu!\", i);\n  }\n\n  fio_data->last_cycle.tv_sec += 10;\n  fio_timer_schedule();\n  fio_defer_perform();\n  FIO_ASSERT(result == total + 2, \"Timer # 2 error (%zu != %zu)\\n\", result,\n             total + 2);\n  fio_data->active = 0;\n  fio_timer_clear_all();\n  fio_defer_clear_tasks();\n  fprintf(stderr, \"* passed.\\n\");\n}\n\n/* *****************************************************************************\nTesting listening socket\n***************************************************************************** */\n\nFIO_FUNC void fio_socket_test(void) {\n  /* initialize unix socket name */\n  fio_str_s sock_name = FIO_STR_INIT;\n#ifdef P_tmpdir\n  fio_str_write(&sock_name, P_tmpdir, strlen(P_tmpdir));\n  if (fio_str_len(&sock_name) &&\n      fio_str_data(&sock_name)[fio_str_len(&sock_name) - 1] == '/')\n    fio_str_resize(&sock_name, fio_str_len(&sock_name) - 1);\n#else\n  fio_str_write(&sock_name, \"/tmp\", 4);\n#endif\n  fio_str_printf(&sock_name, \"/fio_test_sock-%d.sock\", (int)getpid());\n\n  fprintf(stderr, \"=== Testing facil.io listening socket creation (partial \"\n                  \"testing only).\\n\");\n  fprintf(stderr, \"* testing on TCP/IP port 8765 and Unix socket: %s\\n\",\n          fio_str_data(&sock_name));\n  intptr_t uuid = fio_socket(fio_str_data(&sock_name), NULL, 1);\n  FIO_ASSERT(uuid != -1, \"Failed to open unix socket\\n\");\n  FIO_ASSERT(uuid_data(uuid).open, \"Unix socket not initialized\");\n  intptr_t client1 = fio_socket(fio_str_data(&sock_name), NULL, 0);\n  FIO_ASSERT(client1 != -1, \"Failed to connect to unix socket.\");\n  intptr_t client2 = fio_accept(uuid);\n  FIO_ASSERT(client2 != -1, \"Failed to accept unix socket connection.\");\n  fprintf(stderr, \"* Unix server addr %s\\n\", fio_peer_addr(uuid).data);\n  fprintf(stderr, \"* Unix client1 addr %s\\n\", fio_peer_addr(client1).data);\n  fprintf(stderr, \"* Unix client2 addr %s\\n\", fio_peer_addr(client2).data);\n  {\n    char tmp_buf[28];\n    ssize_t r = -1;\n    ssize_t timer_junk;\n    fio_write(client1, \"Hello World\", 11);\n    if (0) {\n      /* packet may have been sent synchronously, don't test */\n      if (!uuid_data(client1).packet)\n        unlink(__FILE__ \".sock\");\n      FIO_ASSERT(uuid_data(client1).packet, \"fio_write error, no packet!\")\n    }\n    /* prevent poll from hanging */\n    fio_run_every(5, 1, fio_timer_test_task, &timer_junk, fio_timer_test_task);\n    errno = EAGAIN;\n    for (size_t i = 0; i < 100 && r <= 0 &&\n                       (r == 0 || errno == EAGAIN || errno == EWOULDBLOCK);\n         ++i) {\n      fio_poll();\n      fio_defer_perform();\n      fio_reschedule_thread();\n      errno = 0;\n      r = fio_read(client2, tmp_buf, 28);\n    }\n    if (!(r > 0 && r <= 28) || memcmp(\"Hello World\", tmp_buf, r)) {\n      perror(\"* ernno\");\n      unlink(__FILE__ \".sock\");\n    }\n    FIO_ASSERT(r > 0 && r <= 28,\n               \"Failed to read from unix socket \" __FILE__ \".sock %zd\", r);\n    FIO_ASSERT(!memcmp(\"Hello World\", tmp_buf, r),\n               \"Unix socket Read/Write cycle error (%zd: %.*s)\", r, (int)r,\n               tmp_buf);\n    fprintf(stderr, \"* Unix socket Read/Write cycle passed: %.*s\\n\", (int)r,\n            tmp_buf);\n    fio_data->last_cycle.tv_sec += 10;\n    fio_timer_clear_all();\n  }\n\n  fio_force_close(client1);\n  fio_force_close(client2);\n  fio_force_close(uuid);\n  unlink(fio_str_data(&sock_name));\n  /* free unix socket name */\n  fio_str_free(&sock_name);\n\n  uuid = fio_socket(NULL, \"8765\", 1);\n  FIO_ASSERT(uuid != -1, \"Failed to open TCP/IP socket on port 8765\");\n  FIO_ASSERT(uuid_data(uuid).open, \"TCP/IP socket not initialized\");\n  fprintf(stderr, \"* TCP/IP server addr %s\\n\", fio_peer_addr(uuid).data);\n  client1 = fio_socket(\"Localhost\", \"8765\", 0);\n  FIO_ASSERT(client1 != -1, \"Failed to connect to TCP/IP socket on port 8765\");\n  fprintf(stderr, \"* TCP/IP client1 addr %s\\n\", fio_peer_addr(client1).data);\n  errno = EAGAIN;\n  for (size_t i = 0; i < 100 && (errno == EAGAIN || errno == EWOULDBLOCK);\n       ++i) {\n    errno = 0;\n    fio_reschedule_thread();\n    client2 = fio_accept(uuid);\n  }\n  if (client2 == -1)\n    perror(\"accept error\");\n  FIO_ASSERT(client2 != -1,\n             \"Failed to accept TCP/IP socket connection on port 8765\");\n  fprintf(stderr, \"* TCP/IP client2 addr %s\\n\", fio_peer_addr(client2).data);\n  fio_force_close(client1);\n  fio_force_close(client2);\n  fio_force_close(uuid);\n  fio_timer_clear_all();\n  fio_defer_clear_tasks();\n  fprintf(stderr, \"* passed.\\n\");\n}\n\n/* *****************************************************************************\nTesting listening socket\n***************************************************************************** */\n\nFIO_FUNC void fio_cycle_test_task(void *arg) {\n  fio_stop();\n  (void)arg;\n}\nFIO_FUNC void fio_cycle_test_task2(void *arg) {\n  fprintf(stderr, \"* facil.io cycling test fatal error!\\n\");\n  exit(-1);\n  (void)arg;\n}\n\nFIO_FUNC void fio_cycle_test(void) {\n  fprintf(stderr,\n          \"=== Testing facil.io cycling logic (partial - only tests timers)\\n\");\n  fio_mark_time();\n  fio_timer_clear_all();\n  struct timespec start = fio_last_tick();\n  fio_run_every(1000, 1, fio_cycle_test_task, NULL, NULL);\n  fio_run_every(10000, 1, fio_cycle_test_task2, NULL, NULL);\n  fio_start(.threads = 1, .workers = 1);\n  struct timespec end = fio_last_tick();\n  fio_timer_clear_all();\n  FIO_ASSERT(end.tv_sec == start.tv_sec + 1 || end.tv_sec == start.tv_sec + 2,\n             \"facil.io cycling error?\");\n  fprintf(stderr, \"* passed.\\n\");\n}\n/* *****************************************************************************\nTesting fio_defer task system\n***************************************************************************** */\n\n#define FIO_DEFER_TOTAL_COUNT (512 * 1024)\n\n#ifndef FIO_DEFER_TEST_PRINT\n#define FIO_DEFER_TEST_PRINT 0\n#endif\n\nFIO_FUNC void sample_task(void *i_count, void *unused2) {\n  (void)(unused2);\n  fio_atomic_add((uintptr_t *)i_count, 1);\n}\n\nFIO_FUNC void sched_sample_task(void *count, void *i_count) {\n  for (size_t i = 0; i < (uintptr_t)count; i++) {\n    fio_defer(sample_task, i_count, NULL);\n  }\n}\n\nFIO_FUNC void fio_defer_test(void) {\n  const size_t cpu_cores = fio_detect_cpu_cores();\n  FIO_ASSERT(cpu_cores, \"couldn't detect CPU cores!\");\n  uintptr_t i_count;\n  clock_t start, end;\n  fprintf(stderr, \"=== Testing facil.io task scheduling (fio_defer)\\n\");\n  FIO_ASSERT(!fio_defer_has_queue(), \"facil.io queue always active.\")\n  i_count = 0;\n  start = clock();\n  for (size_t i = 0; i < FIO_DEFER_TOTAL_COUNT; i++) {\n    sample_task(&i_count, NULL);\n  }\n  end = clock();\n  if (FIO_DEFER_TEST_PRINT) {\n    fprintf(stderr,\n            \"Deferless (direct call) counter: %lu cycles with i_count = %lu, \"\n            \"%lu/%lu free/malloc\\n\",\n            (unsigned long)(end - start), (unsigned long)i_count,\n            (unsigned long)fio_defer_count_dealloc,\n            (unsigned long)fio_defer_count_alloc);\n  }\n  size_t i_count_should_be = i_count;\n\n  if (FIO_DEFER_TEST_PRINT) {\n    fprintf(stderr, \"\\n\");\n  }\n\n  for (size_t i = 1; FIO_DEFER_TOTAL_COUNT >> i; ++i) {\n    i_count = 0;\n    const size_t per_task = FIO_DEFER_TOTAL_COUNT >> i;\n    const size_t tasks = 1 << i;\n    start = clock();\n    for (size_t j = 0; j < tasks; ++j) {\n      fio_defer(sched_sample_task, (void *)per_task, &i_count);\n    }\n    FIO_ASSERT(fio_defer_has_queue(), \"facil.io queue not marked.\")\n    fio_defer_thread_pool_join(fio_defer_thread_pool_new((i % cpu_cores) + 1));\n    end = clock();\n    if (FIO_DEFER_TEST_PRINT) {\n      fprintf(stderr,\n              \"- Defer %zu threads, %zu scheduling loops (%zu each):\\n\"\n              \"    %lu cycles with i_count = %lu, %lu/%lu \"\n              \"free/malloc\\n\",\n              ((i % cpu_cores) + 1), tasks, per_task,\n              (unsigned long)(end - start), (unsigned long)i_count,\n              (unsigned long)fio_defer_count_dealloc,\n              (unsigned long)fio_defer_count_alloc);\n    } else {\n      fprintf(stderr, \".\");\n    }\n    FIO_ASSERT(i_count == i_count_should_be, \"ERROR: defer count invalid\\n\");\n    FIO_ASSERT(fio_defer_count_dealloc == fio_defer_count_alloc,\n               \"defer deallocation vs. allocation error, %zu != %zu\",\n               fio_defer_count_dealloc, fio_defer_count_alloc);\n  }\n  FIO_ASSERT(task_queue_normal.writer == &task_queue_normal.static_queue,\n             \"defer library didn't release dynamic queue (should be static)\");\n  fprintf(stderr, \"\\n* passed.\\n\");\n}\n\n/* *****************************************************************************\nArray data-structure Testing\n***************************************************************************** */\n\ntypedef struct {\n  int i;\n  char c;\n} fio_ary_test_type_s;\n\n#define FIO_ARY_NAME fio_i_ary\n#define FIO_ARY_TYPE uintptr_t\n#include \"fio.h\"\n\nFIO_FUNC intptr_t ary_alloc_counter = 0;\nFIO_FUNC void copy_s(fio_ary_test_type_s *d, fio_ary_test_type_s *s) {\n  ++ary_alloc_counter;\n  *d = *s;\n}\n\n#define FIO_ARY_NAME fio_s_ary\n#define FIO_ARY_TYPE fio_ary_test_type_s\n#define FIO_ARY_COPY(dest, src) copy_s(&(dest), &(src))\n#define FIO_ARY_COMPARE(dest, src) ((dest).i == (src).i && (dest).c == (src).c)\n#define FIO_ARY_DESTROY(obj) (--ary_alloc_counter)\n#include \"fio.h\"\n\nFIO_FUNC void fio_ary_test(void) {\n  /* code */\n  fio_i_ary__test();\n  fio_s_ary__test();\n  FIO_ASSERT(!ary_alloc_counter, \"array object deallocation error, %ld != 0\",\n             ary_alloc_counter);\n}\n\n/* *****************************************************************************\nSet data-structure Testing\n***************************************************************************** */\n\n#define FIO_SET_TEST_COUNT 524288UL\n\n#define FIO_SET_NAME fio_set_test\n#define FIO_SET_OBJ_TYPE uintptr_t\n#include <fio.h>\n\n#define FIO_SET_NAME fio_hash_test\n#define FIO_SET_KEY_TYPE uintptr_t\n#define FIO_SET_OBJ_TYPE uintptr_t\n#include <fio.h>\n\n#define FIO_SET_NAME fio_set_attack\n#define FIO_SET_OBJ_COMPARE(a, b) ((a) == (b))\n#define FIO_SET_OBJ_TYPE uintptr_t\n#include <fio.h>\n\nFIO_FUNC void fio_set_test(void) {\n  fio_set_test_s s = FIO_SET_INIT;\n  fio_hash_test_s h = FIO_SET_INIT;\n  fprintf(\n      stderr,\n      \"=== Testing Core ordered Set (re-including fio.h with FIO_SET_NAME)\\n\");\n  fprintf(stderr, \"* Inserting %lu items\\n\", FIO_SET_TEST_COUNT);\n\n  FIO_ASSERT(fio_set_test_count(&s) == 0, \"empty set should have zero objects\");\n  FIO_ASSERT(fio_set_test_capa(&s) == 0, \"empty set should have no capacity\");\n  FIO_ASSERT(fio_hash_test_capa(&h) == 0, \"empty hash should have no capacity\");\n  FIO_ASSERT(!fio_set_test_is_fragmented(&s),\n             \"empty set shouldn't be considered fragmented\");\n  FIO_ASSERT(!fio_hash_test_is_fragmented(&h),\n             \"empty hash shouldn't be considered fragmented\");\n  FIO_ASSERT(!fio_set_test_last(&s), \"empty set shouldn't have a last object\");\n  FIO_ASSERT(!fio_hash_test_last(&h).key && !fio_hash_test_last(&h).obj,\n             \"empty hash shouldn't have a last object\");\n\n  for (uintptr_t i = 1; i < FIO_SET_TEST_COUNT; ++i) {\n    fio_set_test_insert(&s, i, i);\n    fio_hash_test_insert(&h, i, i, i + 1, NULL);\n    FIO_ASSERT(fio_set_test_find(&s, i, i), \"set find failed after insert\");\n    FIO_ASSERT(fio_hash_test_find(&h, i, i), \"hash find failed after insert\");\n    FIO_ASSERT(i == fio_set_test_find(&s, i, i), \"set insertion != find\");\n    FIO_ASSERT(i + 1 == fio_hash_test_find(&h, i, i), \"hash insertion != find\");\n  }\n  fprintf(stderr, \"* Seeking %lu items\\n\", FIO_SET_TEST_COUNT);\n  for (unsigned long i = 1; i < FIO_SET_TEST_COUNT; ++i) {\n    FIO_ASSERT((i == fio_set_test_find(&s, i, i)),\n               \"set insertion != find (seek)\");\n    FIO_ASSERT((i + 1 == fio_hash_test_find(&h, i, i)),\n               \"hash insertion != find (seek)\");\n  }\n  {\n    fprintf(stderr, \"* Testing order for %lu items in set\\n\",\n            FIO_SET_TEST_COUNT);\n    uintptr_t i = 1;\n    FIO_SET_FOR_LOOP(&s, pos) {\n      FIO_ASSERT(pos->obj == i, \"object order mismatch %lu != %lu.\",\n                 (unsigned long)i, (unsigned long)pos->obj);\n      ++i;\n    }\n  }\n  {\n    fprintf(stderr, \"* Testing order for %lu items in hash\\n\",\n            FIO_SET_TEST_COUNT);\n    uintptr_t i = 1;\n    FIO_SET_FOR_LOOP(&h, pos) {\n      FIO_ASSERT(pos->obj.obj == i + 1 && pos->obj.key == i,\n                 \"object order mismatch %lu != %lu.\", (unsigned long)i,\n                 (unsigned long)pos->obj.key);\n      ++i;\n    }\n  }\n\n  fprintf(stderr, \"* Removing odd items from %lu items\\n\", FIO_SET_TEST_COUNT);\n  for (unsigned long i = 1; i < FIO_SET_TEST_COUNT; i += 2) {\n    fio_set_test_remove(&s, i, i, NULL);\n    fio_hash_test_remove(&h, i, i, NULL);\n    FIO_ASSERT(!(fio_set_test_find(&s, i, i)),\n               \"Removal failed in set (still exists).\");\n    FIO_ASSERT(!(fio_hash_test_find(&h, i, i)),\n               \"Removal failed in hash (still exists).\");\n  }\n  {\n    fprintf(stderr, \"* Testing for %lu / 2 holes\\n\", FIO_SET_TEST_COUNT);\n    uintptr_t i = 1;\n    FIO_SET_FOR_LOOP(&s, pos) {\n      if (pos->hash == 0) {\n        FIO_ASSERT((i & 1) == 1, \"deleted object wasn't odd\");\n      } else {\n        FIO_ASSERT(pos->obj == i, \"deleted object value mismatch %lu != %lu\",\n                   (unsigned long)i, (unsigned long)pos->obj);\n      }\n      ++i;\n    }\n    i = 1;\n    FIO_SET_FOR_LOOP(&h, pos) {\n      if (pos->hash == 0) {\n        FIO_ASSERT((i & 1) == 1, \"deleted object wasn't odd\");\n      } else {\n        FIO_ASSERT(pos->obj.key == i,\n                   \"deleted object value mismatch %lu != %lu\", (unsigned long)i,\n                   (unsigned long)pos->obj.key);\n      }\n      ++i;\n    }\n    {\n      fprintf(stderr, \"* Poping two elements (testing pop through holes)\\n\");\n      FIO_ASSERT(fio_set_test_last(&s), \"Pop `last` 1 failed - no last object\");\n      uintptr_t tmp = fio_set_test_last(&s);\n      FIO_ASSERT(tmp, \"Pop set `last` 1 failed to collect object\");\n      fio_set_test_pop(&s);\n      FIO_ASSERT(\n          fio_set_test_last(&s) != tmp,\n          \"Pop `last` 2 in set same as `last` 1 - failed to collect object\");\n      tmp = fio_hash_test_last(&h).key;\n      FIO_ASSERT(tmp, \"Pop hash `last` 1 failed to collect object\");\n      fio_hash_test_pop(&h);\n      FIO_ASSERT(\n          fio_hash_test_last(&h).key != tmp,\n          \"Pop `last` 2 in hash same as `last` 1 - failed to collect object\");\n      FIO_ASSERT(fio_set_test_last(&s), \"Pop `last` 2 failed - no last object\");\n      FIO_ASSERT(fio_hash_test_last(&h).obj,\n                 \"Pop `last` 2 failed in hash - no last object\");\n      fio_set_test_pop(&s);\n      fio_hash_test_pop(&h);\n    }\n    if (1) {\n      uintptr_t tmp = 1;\n      fio_set_test_remove(&s, tmp, tmp, NULL);\n      fio_hash_test_remove(&h, tmp, tmp, NULL);\n      size_t count = s.count;\n      fio_set_test_overwrite(&s, tmp, tmp, NULL);\n      FIO_ASSERT(\n          count + 1 == s.count,\n          \"Re-adding a removed item in set should increase count by 1 (%zu + \"\n          \"1 != %zu).\",\n          count, (size_t)s.count);\n      count = h.count;\n      fio_hash_test_insert(&h, tmp, tmp, tmp, NULL);\n      FIO_ASSERT(\n          count + 1 == h.count,\n          \"Re-adding a removed item in hash should increase count by 1 (%zu + \"\n          \"1 != %zu).\",\n          count, (size_t)s.count);\n      tmp = fio_set_test_find(&s, tmp, tmp);\n      FIO_ASSERT(tmp == 1,\n                 \"Re-adding a removed item should update the item in the set \"\n                 \"(%lu != 1)!\",\n                 (unsigned long)fio_set_test_find(&s, tmp, tmp));\n      fio_set_test_remove(&s, tmp, tmp, NULL);\n      fio_hash_test_remove(&h, tmp, tmp, NULL);\n      FIO_ASSERT(count == h.count,\n                 \"Re-removing an item should decrease count (%zu != %zu).\",\n                 count, (size_t)s.count);\n      FIO_ASSERT(!fio_set_test_find(&s, tmp, tmp),\n                 \"Re-removing a re-added item should update the item!\");\n    }\n  }\n  fprintf(stderr, \"* Compacting HashMap to %lu\\n\", FIO_SET_TEST_COUNT >> 1);\n  fio_set_test_compact(&s);\n  {\n    fprintf(stderr, \"* Testing that %lu items are continuous\\n\",\n            FIO_SET_TEST_COUNT >> 1);\n    uintptr_t i = 0;\n    FIO_SET_FOR_LOOP(&s, pos) {\n      FIO_ASSERT(pos->hash != 0, \"Found a hole after compact.\");\n      ++i;\n    }\n    FIO_ASSERT(i == s.count, \"count error (%lu != %lu).\", i, s.count);\n  }\n\n  fio_set_test_free(&s);\n  fio_hash_test_free(&h);\n  FIO_ASSERT(!s.map && !s.ordered && !s.pos && !s.capa,\n             \"HashMap not re-initialized after free.\");\n\n  fio_set_test_capa_require(&s, FIO_SET_TEST_COUNT);\n\n  FIO_ASSERT(\n      s.map && s.ordered && !s.pos && s.capa >= FIO_SET_TEST_COUNT,\n      \"capa_require changes state in a bad way (%p, %p, %zu, %zu ?>= %zu)\",\n      (void *)s.map, (void *)s.ordered, s.pos, s.capa, FIO_SET_TEST_COUNT);\n\n  for (unsigned long i = 1; i < FIO_SET_TEST_COUNT; ++i) {\n    fio_set_test_insert(&s, i, i);\n    FIO_ASSERT(fio_set_test_find(&s, i, i),\n               \"find failed after insert (2nd round)\");\n    FIO_ASSERT(i == fio_set_test_find(&s, i, i),\n               \"insertion (2nd round) != find\");\n    FIO_ASSERT(i == s.count, \"count error (%lu != %lu) post insertion.\", i,\n               s.count);\n  }\n  fio_set_test_free(&s);\n  /* full/partial collision attack against set and test response */\n  if (1) {\n    fio_set_attack_s as = FIO_SET_INIT;\n    time_t start_ok = clock();\n    for (uintptr_t i = 0; i < FIO_SET_TEST_COUNT; ++i) {\n      fio_set_attack_insert(&as, i, i + 1);\n      FIO_ASSERT(fio_set_attack_find(&as, i, i + 1) == i + 1,\n                 \"set attack verctor failed sanity test (seek != insert)\");\n    }\n    time_t end_ok = clock();\n    FIO_ASSERT(fio_set_attack_count(&as) == FIO_SET_TEST_COUNT,\n               \"set attack verctor failed sanity test (count error %zu != %zu)\",\n               fio_set_attack_count(&as), FIO_SET_TEST_COUNT);\n    fio_set_attack_free(&as);\n\n    /* full collision attack */\n    time_t start_bad = clock();\n    for (uintptr_t i = 0; i < FIO_SET_TEST_COUNT; ++i) {\n      fio_set_attack_insert(&as, 1, i + 1);\n    }\n    time_t end_bad = clock();\n    FIO_ASSERT(fio_set_attack_count(&as) != FIO_SET_TEST_COUNT,\n               \"set attack success! too many full-collisions inserts!\");\n    FIO_LOG_DEBUG(\"set full-collision attack final count/capa = %zu / %zu\",\n                  fio_set_attack_count(&as), fio_set_attack_capa(&as));\n    FIO_LOG_DEBUG(\"set full-collision attack timing impact (attack vs. normal) \"\n                  \"%zu vs. %zu\",\n                  end_bad - start_bad, end_ok - start_ok);\n    fio_set_attack_free(&as);\n\n    /* partial collision attack */\n    start_bad = clock();\n    for (uintptr_t i = 0; i < FIO_SET_TEST_COUNT; ++i) {\n      fio_set_attack_insert(&as, ((i << 20) | 1), i + 1);\n    }\n    end_bad = clock();\n    FIO_ASSERT(fio_set_attack_count(&as) == FIO_SET_TEST_COUNT,\n               \"partial collision resolusion failed, not enough inserts!\");\n    FIO_LOG_DEBUG(\"set partial collision attack final count/capa = %zu / %zu\",\n                  fio_set_attack_count(&as), fio_set_attack_capa(&as));\n    FIO_LOG_DEBUG(\"set partial collision attack timing impact (attack vs. \"\n                  \"normal) %zu vs. %zu\",\n                  end_bad - start_bad, end_ok - start_ok);\n    fio_set_attack_free(&as);\n  }\n}\n\n/* *****************************************************************************\nBad Hash (risky hash) tests\n***************************************************************************** */\n\nFIO_FUNC void fio_riskyhash_speed_test(void) {\n  /* test based on code from BearSSL with credit to Thomas Pornin */\n  uint8_t buffer[8192];\n  memset(buffer, 'T', sizeof(buffer));\n  /* warmup */\n  uint64_t hash = 0;\n  for (size_t i = 0; i < 4; i++) {\n    hash += fio_risky_hash(buffer, 8192, 1);\n    memcpy(buffer, &hash, sizeof(hash));\n  }\n  /* loop until test runs for more than 2 seconds */\n  for (uint64_t cycles = 8192;;) {\n    clock_t start, end;\n    start = clock();\n    for (size_t i = cycles; i > 0; i--) {\n      hash += fio_risky_hash(buffer, 8192, 1);\n      __asm__ volatile(\"\" ::: \"memory\");\n    }\n    end = clock();\n    memcpy(buffer, &hash, sizeof(hash));\n    if ((end - start) >= (2 * CLOCKS_PER_SEC) ||\n        cycles >= ((uint64_t)1 << 62)) {\n      fprintf(stderr, \"%-20s %8.2f MB/s\\n\", \"fio_risky_hash\",\n              (double)(sizeof(buffer) * cycles) /\n                  (((end - start) * 1000000.0 / CLOCKS_PER_SEC)));\n      break;\n    }\n    cycles <<= 2;\n  }\n}\n\nFIO_FUNC void fio_riskyhash_test(void) {\n  fprintf(stderr, \"===================================\\n\");\n#if NODEBUG\n  fio_riskyhash_speed_test();\n#else\n  fprintf(stderr, \"fio_risky_hash speed test skipped (debug mode is slow)\\n\");\n  fio_str_info_s str1 =\n      (fio_str_info_s){.data = \"nothing_is_really_here1\", .len = 23};\n  fio_str_info_s str2 =\n      (fio_str_info_s){.data = \"nothing_is_really_here2\", .len = 23};\n  fio_str_s copy = FIO_STR_INIT;\n  FIO_ASSERT(fio_risky_hash(str1.data, str1.len, 1) !=\n                 fio_risky_hash(str2.data, str2.len, 1),\n             \"Different strings should have a different risky hash\");\n  fio_str_write(&copy, str1.data, str1.len);\n  FIO_ASSERT(fio_risky_hash(str1.data, str1.len, 1) ==\n                 fio_risky_hash(fio_str_data(&copy), fio_str_len(&copy), 1),\n             \"Same string values should have the same risky hash\");\n  fio_str_free(&copy);\n  (void)fio_riskyhash_speed_test;\n#endif\n}\n\n/* *****************************************************************************\nSipHash tests\n***************************************************************************** */\n\nFIO_FUNC void fio_siphash_speed_test(void) {\n  /* test based on code from BearSSL with credit to Thomas Pornin */\n  uint8_t buffer[8192];\n  memset(buffer, 'T', sizeof(buffer));\n  /* warmup */\n  uint64_t hash = 0;\n  for (size_t i = 0; i < 4; i++) {\n    hash += fio_siphash24(buffer, sizeof(buffer), 0, 0);\n    memcpy(buffer, &hash, sizeof(hash));\n  }\n  /* loop until test runs for more than 2 seconds */\n  for (uint64_t cycles = 8192;;) {\n    clock_t start, end;\n    start = clock();\n    for (size_t i = cycles; i > 0; i--) {\n      hash += fio_siphash24(buffer, sizeof(buffer), 0, 0);\n      __asm__ volatile(\"\" ::: \"memory\");\n    }\n    end = clock();\n    memcpy(buffer, &hash, sizeof(hash));\n    if ((end - start) >= (2 * CLOCKS_PER_SEC) ||\n        cycles >= ((uint64_t)1 << 62)) {\n      fprintf(stderr, \"%-20s %8.2f MB/s\\n\", \"fio SipHash24\",\n              (double)(sizeof(buffer) * cycles) /\n                  (((end - start) * 1000000.0 / CLOCKS_PER_SEC)));\n      break;\n    }\n    cycles <<= 2;\n  }\n  /* loop until test runs for more than 2 seconds */\n  for (uint64_t cycles = 8192;;) {\n    clock_t start, end;\n    start = clock();\n    for (size_t i = cycles; i > 0; i--) {\n      hash += fio_siphash13(buffer, sizeof(buffer), 0, 0);\n      __asm__ volatile(\"\" ::: \"memory\");\n    }\n    end = clock();\n    memcpy(buffer, &hash, sizeof(hash));\n    if ((end - start) >= (2 * CLOCKS_PER_SEC) ||\n        cycles >= ((uint64_t)1 << 62)) {\n      fprintf(stderr, \"%-20s %8.2f MB/s\\n\", \"fio SipHash13\",\n              (double)(sizeof(buffer) * cycles) /\n                  (((end - start) * 1000000.0 / CLOCKS_PER_SEC)));\n      break;\n    }\n    cycles <<= 2;\n  }\n}\n\nFIO_FUNC void fio_siphash_test(void) {\n  fprintf(stderr, \"===================================\\n\");\n#if NODEBUG\n  fio_siphash_speed_test();\n#else\n  fprintf(stderr, \"fio SipHash speed test skipped (debug mode is slow)\\n\");\n  (void)fio_siphash_speed_test;\n#endif\n}\n/* *****************************************************************************\nSHA-1 tests\n***************************************************************************** */\n\nFIO_FUNC void fio_sha1_speed_test(void) {\n  /* test based on code from BearSSL with credit to Thomas Pornin */\n  uint8_t buffer[8192];\n  uint8_t result[21];\n  fio_sha1_s sha1;\n  memset(buffer, 'T', sizeof(buffer));\n  /* warmup */\n  for (size_t i = 0; i < 4; i++) {\n    sha1 = fio_sha1_init();\n    fio_sha1_write(&sha1, buffer, sizeof(buffer));\n    memcpy(result, fio_sha1_result(&sha1), 21);\n  }\n  /* loop until test runs for more than 2 seconds */\n  for (size_t cycles = 8192;;) {\n    clock_t start, end;\n    sha1 = fio_sha1_init();\n    start = clock();\n    for (size_t i = cycles; i > 0; i--) {\n      fio_sha1_write(&sha1, buffer, sizeof(buffer));\n      __asm__ volatile(\"\" ::: \"memory\");\n    }\n    end = clock();\n    fio_sha1_result(&sha1);\n    if ((end - start) >= (2 * CLOCKS_PER_SEC)) {\n      fprintf(stderr, \"%-20s %8.2f MB/s\\n\", \"fio SHA-1\",\n              (double)(sizeof(buffer) * cycles) /\n                  (((end - start) * 1000000.0 / CLOCKS_PER_SEC)));\n      break;\n    }\n    cycles <<= 1;\n  }\n}\n\n#ifdef HAVE_OPENSSL\nFIO_FUNC void fio_sha1_open_ssl_speed_test(void) {\n  /* test based on code from BearSSL with credit to Thomas Pornin */\n  uint8_t buffer[8192];\n  uint8_t result[21];\n  SHA_CTX o_sh1;\n  memset(buffer, 'T', sizeof(buffer));\n  /* warmup */\n  for (size_t i = 0; i < 4; i++) {\n    SHA1_Init(&o_sh1);\n    SHA1_Update(&o_sh1, buffer, sizeof(buffer));\n    SHA1_Final(result, &o_sh1);\n  }\n  /* loop until test runs for more than 2 seconds */\n  for (size_t cycles = 8192;;) {\n    clock_t start, end;\n    SHA1_Init(&o_sh1);\n    start = clock();\n    for (size_t i = cycles; i > 0; i--) {\n      SHA1_Update(&o_sh1, buffer, sizeof(buffer));\n      __asm__ volatile(\"\" ::: \"memory\");\n    }\n    end = clock();\n    SHA1_Final(result, &o_sh1);\n    if ((end - start) >= (2 * CLOCKS_PER_SEC)) {\n      fprintf(stderr, \"%-20s %8.2f MB/s\\n\", \"OpenSSL SHA-1\",\n              (double)(sizeof(buffer) * cycles) /\n                  (((end - start) * 1000000.0 / CLOCKS_PER_SEC)));\n      break;\n    }\n    cycles <<= 1;\n  }\n}\n#endif\n\nFIO_FUNC void fio_sha1_test(void) {\n  // clang-format off\n  struct {\n    char *str;\n    uint8_t hash[21];\n  } sets[] = {\n      {\"The quick brown fox jumps over the lazy dog\",\n       {0x2f, 0xd4, 0xe1, 0xc6, 0x7a, 0x2d, 0x28, 0xfc, 0xed, 0x84, 0x9e,\n        0xe1, 0xbb, 0x76, 0xe7, 0x39, 0x1b, 0x93, 0xeb, 0x12, 0}}, // a set with\n                                                                   // a string\n      {\"\",\n       {\n           0xda, 0x39, 0xa3, 0xee, 0x5e, 0x6b, 0x4b, 0x0d, 0x32, 0x55,\n           0xbf, 0xef, 0x95, 0x60, 0x18, 0x90, 0xaf, 0xd8, 0x07, 0x09,\n       }},        // an empty set\n      {NULL, {0}} // Stop\n  };\n  // clang-format on\n  int i = 0;\n  fio_sha1_s sha1;\n  fprintf(stderr, \"===================================\\n\");\n  fprintf(stderr, \"fio SHA-1 struct size: %zu\\n\", sizeof(fio_sha1_s));\n  fprintf(stderr, \"+ fio\");\n  while (sets[i].str) {\n    sha1 = fio_sha1_init();\n    fio_sha1_write(&sha1, sets[i].str, strlen(sets[i].str));\n    if (strcmp(fio_sha1_result(&sha1), (char *)sets[i].hash)) {\n      fprintf(stderr, \":\\n--- fio SHA-1 Test FAILED!\\nstring: %s\\nexpected: \",\n              sets[i].str);\n      char *p = (char *)sets[i].hash;\n      while (*p)\n        fprintf(stderr, \"%02x\", *(p++) & 0xFF);\n      fprintf(stderr, \"\\ngot: \");\n      p = fio_sha1_result(&sha1);\n      while (*p)\n        fprintf(stderr, \"%02x\", *(p++) & 0xFF);\n      fprintf(stderr, \"\\n\");\n      FIO_ASSERT(0, \"SHA-1 failure.\");\n      return;\n    }\n    i++;\n  }\n  fprintf(stderr, \" SHA-1 passed.\\n\");\n#if NODEBUG\n  fio_sha1_speed_test();\n#else\n  fprintf(stderr, \"fio SHA1 speed test skipped (debug mode is slow)\\n\");\n  (void)fio_sha1_speed_test;\n#endif\n\n#ifdef HAVE_OPENSSL\n\n#if NODEBUG\n  fio_sha1_open_ssl_speed_test();\n#else\n  fprintf(stderr, \"OpenSSL SHA1 speed test skipped (debug mode is slow)\\n\");\n  (void)fio_sha1_open_ssl_speed_test;\n#endif\n  fprintf(stderr, \"===================================\\n\");\n  fprintf(stderr, \"fio SHA-1 struct size: %lu\\n\",\n          (unsigned long)sizeof(fio_sha1_s));\n  fprintf(stderr, \"OpenSSL SHA-1 struct size: %lu\\n\",\n          (unsigned long)sizeof(SHA_CTX));\n  fprintf(stderr, \"===================================\\n\");\n#endif /* HAVE_OPENSSL */\n}\n\n/* *****************************************************************************\nSHA-2 tests\n***************************************************************************** */\n\nFIO_FUNC char *sha2_variant_names[] = {\n    \"unknown\", \"SHA_512\",     \"SHA_256\", \"SHA_512_256\",\n    \"SHA_224\", \"SHA_512_224\", \"none\",    \"SHA_384\",\n};\n\nFIO_FUNC void fio_sha2_speed_test(fio_sha2_variant_e var,\n                                  const char *var_name) {\n  /* test based on code from BearSSL with credit to Thomas Pornin */\n  uint8_t buffer[8192];\n  uint8_t result[65];\n  fio_sha2_s sha2;\n  memset(buffer, 'T', sizeof(buffer));\n  /* warmup */\n  for (size_t i = 0; i < 4; i++) {\n    sha2 = fio_sha2_init(var);\n    fio_sha2_write(&sha2, buffer, sizeof(buffer));\n    memcpy(result, fio_sha2_result(&sha2), 65);\n  }\n  /* loop until test runs for more than 2 seconds */\n  for (size_t cycles = 8192;;) {\n    clock_t start, end;\n    sha2 = fio_sha2_init(var);\n    start = clock();\n    for (size_t i = cycles; i > 0; i--) {\n      fio_sha2_write(&sha2, buffer, sizeof(buffer));\n      __asm__ volatile(\"\" ::: \"memory\");\n    }\n    end = clock();\n    fio_sha2_result(&sha2);\n    if ((end - start) >= (2 * CLOCKS_PER_SEC)) {\n      fprintf(stderr, \"%-20s %8.2f MB/s\\n\", var_name,\n              (double)(sizeof(buffer) * cycles) /\n                  (((end - start) * 1000000.0 / CLOCKS_PER_SEC)));\n      break;\n    }\n    cycles <<= 1;\n  }\n}\n\nFIO_FUNC void fio_sha2_openssl_speed_test(const char *var_name, int (*init)(),\n                                          int (*update)(), int (*final)(),\n                                          void *sha) {\n  /* test adapted from BearSSL code with credit to Thomas Pornin */\n  uint8_t buffer[8192];\n  uint8_t result[1024];\n  memset(buffer, 'T', sizeof(buffer));\n  /* warmup */\n  for (size_t i = 0; i < 4; i++) {\n    init(sha);\n    update(sha, buffer, sizeof(buffer));\n    final(result, sha);\n  }\n  /* loop until test runs for more than 2 seconds */\n  for (size_t cycles = 2048;;) {\n    clock_t start, end;\n    init(sha);\n    start = clock();\n    for (size_t i = cycles; i > 0; i--) {\n      update(sha, buffer, sizeof(buffer));\n      __asm__ volatile(\"\" ::: \"memory\");\n    }\n    end = clock();\n    final(result, sha);\n    if ((end - start) >= (2 * CLOCKS_PER_SEC)) {\n      fprintf(stderr, \"%-20s %8.2f MB/s\\n\", var_name,\n              (double)(sizeof(buffer) * cycles) /\n                  (((end - start) * 1000000.0 / CLOCKS_PER_SEC)));\n      break;\n    }\n    cycles <<= 1;\n  }\n}\nFIO_FUNC void fio_sha2_test(void) {\n  fio_sha2_s s;\n  char *expect;\n  char *got;\n  char *str = \"\";\n  fprintf(stderr, \"===================================\\n\");\n  fprintf(stderr, \"fio SHA-2 struct size: %zu\\n\", sizeof(fio_sha2_s));\n  fprintf(stderr, \"+ fio\");\n  // start tests\n  s = fio_sha2_init(SHA_224);\n  fio_sha2_write(&s, str, 0);\n  expect = \"\\xd1\\x4a\\x02\\x8c\\x2a\\x3a\\x2b\\xc9\\x47\\x61\\x02\\xbb\\x28\\x82\\x34\\xc4\"\n           \"\\x15\\xa2\\xb0\\x1f\\x82\\x8e\\xa6\\x2a\\xc5\\xb3\\xe4\\x2f\";\n  got = fio_sha2_result(&s);\n  if (strcmp(expect, got))\n    goto error;\n\n  s = fio_sha2_init(SHA_256);\n  fio_sha2_write(&s, str, 0);\n  expect =\n      \"\\xe3\\xb0\\xc4\\x42\\x98\\xfc\\x1c\\x14\\x9a\\xfb\\xf4\\xc8\\x99\\x6f\\xb9\\x24\\x27\"\n      \"\\xae\\x41\\xe4\\x64\\x9b\\x93\\x4c\\xa4\\x95\\x99\\x1b\\x78\\x52\\xb8\\x55\";\n  got = fio_sha2_result(&s);\n  if (strcmp(expect, got))\n    goto error;\n\n  s = fio_sha2_init(SHA_512);\n  fio_sha2_write(&s, str, 0);\n  expect = \"\\xcf\\x83\\xe1\\x35\\x7e\\xef\\xb8\\xbd\\xf1\\x54\\x28\\x50\\xd6\\x6d\"\n           \"\\x80\\x07\\xd6\\x20\\xe4\\x05\\x0b\\x57\\x15\\xdc\\x83\\xf4\\xa9\\x21\"\n           \"\\xd3\\x6c\\xe9\\xce\\x47\\xd0\\xd1\\x3c\\x5d\\x85\\xf2\\xb0\\xff\\x83\"\n           \"\\x18\\xd2\\x87\\x7e\\xec\\x2f\\x63\\xb9\\x31\\xbd\\x47\\x41\\x7a\\x81\"\n           \"\\xa5\\x38\\x32\\x7a\\xf9\\x27\\xda\\x3e\";\n  got = fio_sha2_result(&s);\n  if (strcmp(expect, got))\n    goto error;\n\n  s = fio_sha2_init(SHA_384);\n  fio_sha2_write(&s, str, 0);\n  expect = \"\\x38\\xb0\\x60\\xa7\\x51\\xac\\x96\\x38\\x4c\\xd9\\x32\\x7e\"\n           \"\\xb1\\xb1\\xe3\\x6a\\x21\\xfd\\xb7\\x11\\x14\\xbe\\x07\\x43\\x4c\\x0c\"\n           \"\\xc7\\xbf\\x63\\xf6\\xe1\\xda\\x27\\x4e\\xde\\xbf\\xe7\\x6f\\x65\\xfb\"\n           \"\\xd5\\x1a\\xd2\\xf1\\x48\\x98\\xb9\\x5b\";\n  got = fio_sha2_result(&s);\n  if (strcmp(expect, got))\n    goto error;\n\n  s = fio_sha2_init(SHA_512_224);\n  fio_sha2_write(&s, str, 0);\n  expect = \"\\x6e\\xd0\\xdd\\x02\\x80\\x6f\\xa8\\x9e\\x25\\xde\\x06\\x0c\\x19\\xd3\"\n           \"\\xac\\x86\\xca\\xbb\\x87\\xd6\\xa0\\xdd\\xd0\\x5c\\x33\\x3b\\x84\\xf4\";\n  got = fio_sha2_result(&s);\n  if (strcmp(expect, got))\n    goto error;\n\n  s = fio_sha2_init(SHA_512_256);\n  fio_sha2_write(&s, str, 0);\n  expect = \"\\xc6\\x72\\xb8\\xd1\\xef\\x56\\xed\\x28\\xab\\x87\\xc3\\x62\\x2c\\x51\\x14\\x06\"\n           \"\\x9b\\xdd\\x3a\\xd7\\xb8\\xf9\\x73\\x74\\x98\\xd0\\xc0\\x1e\\xce\\xf0\\x96\\x7a\";\n  got = fio_sha2_result(&s);\n  if (strcmp(expect, got))\n    goto error;\n\n  s = fio_sha2_init(SHA_512);\n  str = \"god is a rotten tomato\";\n  fio_sha2_write(&s, str, strlen(str));\n  expect = \"\\x61\\x97\\x4d\\x41\\x9f\\x77\\x45\\x21\\x09\\x4e\\x95\\xa3\\xcb\\x4d\\xe4\\x79\"\n           \"\\x26\\x32\\x2f\\x2b\\xe2\\x62\\x64\\x5a\\xb4\\x5d\\x3f\\x73\\x69\\xef\\x46\\x20\"\n           \"\\xb2\\xd3\\xce\\xda\\xa9\\xc2\\x2c\\xac\\xe3\\xf9\\x02\\xb2\\x20\\x5d\\x2e\\xfd\"\n           \"\\x40\\xca\\xa0\\xc1\\x67\\xe0\\xdc\\xdf\\x60\\x04\\x3e\\x4e\\x76\\x87\\x82\\x74\";\n  got = fio_sha2_result(&s);\n  if (strcmp(expect, got))\n    goto error;\n\n  // s = fio_sha2_init(SHA_256);\n  // str = \"The quick brown fox jumps over the lazy dog\";\n  // fio_sha2_write(&s, str, strlen(str));\n  // expect =\n  //     \"\\xd7\\xa8\\xfb\\xb3\\x07\\xd7\\x80\\x94\\x69\\xca\\x9a\\xbc\\xb0\\x08\\x2e\\x4f\"\n  //     \"\\x8d\\x56\\x51\\xe4\\x6d\\x3c\\xdb\\x76\\x2d\\x02\\xd0\\xbf\\x37\\xc9\\xe5\\x92\";\n  // got = fio_sha2_result(&s);\n  // if (strcmp(expect, got))\n  //   goto error;\n\n  s = fio_sha2_init(SHA_224);\n  str = \"The quick brown fox jumps over the lazy dog\";\n  fio_sha2_write(&s, str, strlen(str));\n  expect = \"\\x73\\x0e\\x10\\x9b\\xd7\\xa8\\xa3\\x2b\\x1c\\xb9\\xd9\\xa0\\x9a\\xa2\"\n           \"\\x32\\x5d\\x24\\x30\\x58\\x7d\\xdb\\xc0\\xc3\\x8b\\xad\\x91\\x15\\x25\";\n  got = fio_sha2_result(&s);\n  if (strcmp(expect, got))\n    goto error;\n  fprintf(stderr, \" SHA-2 passed.\\n\");\n\n#if NODEBUG\n  fio_sha2_speed_test(SHA_224, \"fio SHA-224\");\n  fio_sha2_speed_test(SHA_256, \"fio SHA-256\");\n  fio_sha2_speed_test(SHA_384, \"fio SHA-384\");\n  fio_sha2_speed_test(SHA_512, \"fio SHA-512\");\n#else\n  fprintf(stderr, \"fio SHA-2 speed test skipped (debug mode is slow)\\n\");\n#endif\n\n#ifdef HAVE_OPENSSL\n\n#if NODEBUG\n  {\n    SHA512_CTX s2;\n    SHA256_CTX s3;\n    fio_sha2_openssl_speed_test(\"OpenSSL SHA512\", SHA512_Init, SHA512_Update,\n                                SHA512_Final, &s2);\n    fio_sha2_openssl_speed_test(\"OpenSSL SHA256\", SHA256_Init, SHA256_Update,\n                                SHA256_Final, &s3);\n  }\n#endif\n  fprintf(stderr, \"===================================\\n\");\n  fprintf(stderr, \"fio SHA-2 struct size: %zu\\n\", sizeof(fio_sha2_s));\n  fprintf(stderr, \"OpenSSL SHA-2/256 struct size: %zu\\n\", sizeof(SHA256_CTX));\n  fprintf(stderr, \"OpenSSL SHA-2/512 struct size: %zu\\n\", sizeof(SHA512_CTX));\n  fprintf(stderr, \"===================================\\n\");\n#endif /* HAVE_OPENSSL */\n\n  return;\n\nerror:\n  fprintf(stderr,\n          \":\\n--- fio SHA-2 Test FAILED!\\ntype: \"\n          \"%s (%d)\\nstring %s\\nexpected:\\n\",\n          sha2_variant_names[s.type], s.type, str);\n  while (*expect)\n    fprintf(stderr, \"%02x\", *(expect++) & 0xFF);\n  fprintf(stderr, \"\\ngot:\\n\");\n  while (*got)\n    fprintf(stderr, \"%02x\", *(got++) & 0xFF);\n  fprintf(stderr, \"\\n\");\n  (void)fio_sha2_speed_test;\n  (void)fio_sha2_openssl_speed_test;\n  FIO_ASSERT(0, \"SHA-2 failure.\");\n}\n\n/* *****************************************************************************\nBase64 tests\n***************************************************************************** */\n\nFIO_FUNC void fio_base64_speed_test(void) {\n  /* test based on code from BearSSL with credit to Thomas Pornin */\n  char buffer[8192];\n  char result[8192 * 2];\n  memset(buffer, 'T', sizeof(buffer));\n  /* warmup */\n  for (size_t i = 0; i < 4; i++) {\n    fio_base64_encode(result, buffer, sizeof(buffer));\n    memcpy(buffer, result, sizeof(buffer));\n  }\n  /* loop until test runs for more than 2 seconds */\n  for (size_t cycles = 8192;;) {\n    clock_t start, end;\n    start = clock();\n    for (size_t i = cycles; i > 0; i--) {\n      fio_base64_encode(result, buffer, sizeof(buffer));\n      __asm__ volatile(\"\" ::: \"memory\");\n    }\n    end = clock();\n    if ((end - start) >= (2 * CLOCKS_PER_SEC)) {\n      fprintf(stderr, \"%-20s %8.2f MB/s\\n\", \"fio Base64 Encode\",\n              (double)(sizeof(buffer) * cycles) /\n                  (((end - start) * 1000000.0 / CLOCKS_PER_SEC)));\n      break;\n    }\n    cycles <<= 2;\n  }\n\n  /* speed test decoding */\n  const int encoded_len =\n      fio_base64_encode(result, buffer, (int)(sizeof(buffer) - 2));\n  /* warmup */\n  for (size_t i = 0; i < 4; i++) {\n    fio_base64_decode(buffer, result, encoded_len);\n    __asm__ volatile(\"\" ::: \"memory\");\n  }\n  /* loop until test runs for more than 2 seconds */\n  for (size_t cycles = 8192;;) {\n    clock_t start, end;\n    start = clock();\n    for (size_t i = cycles; i > 0; i--) {\n      fio_base64_decode(buffer, result, encoded_len);\n      __asm__ volatile(\"\" ::: \"memory\");\n    }\n    end = clock();\n    if ((end - start) >= (2 * CLOCKS_PER_SEC)) {\n      fprintf(stderr, \"%-20s %8.2f MB/s\\n\", \"fio Base64 Decode\",\n              (double)(encoded_len * cycles) /\n                  (((end - start) * 1000000.0 / CLOCKS_PER_SEC)));\n      break;\n    }\n    cycles <<= 2;\n  }\n}\n\nFIO_FUNC void fio_base64_test(void) {\n  struct {\n    char *str;\n    char *base64;\n  } sets[] = {\n      {\"Man is distinguished, not only by his reason, but by this singular \"\n       \"passion from other animals, which is a lust of the mind, that by a \"\n       \"perseverance of delight in the continued \"\n       \"and indefatigable generation \"\n       \"of knowledge, exceeds the short vehemence of any carnal pleasure.\",\n       \"TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB\"\n       \"0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIG\"\n       \"x1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpb\"\n       \"iB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xl\"\n       \"ZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3V\"\n       \"yZS4=\"},\n      {\"any carnal pleasure.\", \"YW55IGNhcm5hbCBwbGVhc3VyZS4=\"},\n      {\"any carnal pleasure\", \"YW55IGNhcm5hbCBwbGVhc3VyZQ==\"},\n      {\"any carnal pleasur\", \"YW55IGNhcm5hbCBwbGVhc3Vy\"},\n      {\"\", \"\"},\n      {\"f\", \"Zg==\"},\n      {\"fo\", \"Zm8=\"},\n      {\"foo\", \"Zm9v\"},\n      {\"foob\", \"Zm9vYg==\"},\n      {\"fooba\", \"Zm9vYmE=\"},\n      {\"foobar\", \"Zm9vYmFy\"},\n      {NULL, NULL} // Stop\n  };\n  int i = 0;\n  char buffer[1024];\n  fprintf(stderr, \"===================================\\n\");\n  fprintf(stderr, \"+ fio\");\n  while (sets[i].str) {\n    fio_base64_encode(buffer, sets[i].str, strlen(sets[i].str));\n    if (strcmp(buffer, sets[i].base64)) {\n      fprintf(stderr,\n              \":\\n--- fio Base64 Test FAILED!\\nstring: %s\\nlength: %lu\\n \"\n              \"expected: %s\\ngot: %s\\n\\n\",\n              sets[i].str, strlen(sets[i].str), sets[i].base64, buffer);\n      FIO_ASSERT(0, \"Base64 failure.\");\n    }\n    i++;\n  }\n  if (!sets[i].str)\n    fprintf(stderr, \" Base64 encode passed.\\n\");\n\n  i = 0;\n  fprintf(stderr, \"+ fio\");\n  while (sets[i].str) {\n    fio_base64_decode(buffer, sets[i].base64, strlen(sets[i].base64));\n    if (strcmp(buffer, sets[i].str)) {\n      fprintf(stderr,\n              \":\\n--- fio Base64 Test FAILED!\\nbase64: %s\\nexpected: \"\n              \"%s\\ngot: %s\\n\\n\",\n              sets[i].base64, sets[i].str, buffer);\n      FIO_ASSERT(0, \"Base64 failure.\");\n    }\n    i++;\n  }\n  fprintf(stderr, \" Base64 decode passed.\\n\");\n\n#if NODEBUG\n  fio_base64_speed_test();\n#else\n  fprintf(stderr,\n          \"* Base64 speed test skipped (debug speeds are always slow).\\n\");\n  (void)fio_base64_speed_test;\n#endif\n}\n\n/*******************************************************************************\nRandom Testing\n***************************************************************************** */\n\nFIO_FUNC void fio_test_random(void) {\n  fprintf(stderr, \"=== Testing random generator\\n\");\n  uint64_t rnd = fio_rand64();\n  FIO_ASSERT((rnd != fio_rand64() && rnd != fio_rand64()),\n             \"fio_rand64 returned the same result three times in a row.\");\n#if NODEBUG\n  uint64_t buffer1[8];\n  uint8_t buffer2[8192];\n  clock_t start, end;\n  start = clock();\n  for (size_t i = 0; i < (8388608 / (64 / 8)); i++) {\n    buffer1[i & 7] = fio_rand64();\n    __asm__ volatile(\"\" ::: \"memory\");\n  }\n  end = clock();\n  fprintf(stderr,\n          \"+ Random generator available\\n+ created 8Mb using 64bits \"\n          \"Random %lu CPU clock count ~%.2fMb/s\\n\",\n          end - start, (8.0) / (((double)(end - start)) / CLOCKS_PER_SEC));\n  start = clock();\n  for (size_t i = 0; i < (8388608 / (8192)); i++) {\n    fio_rand_bytes(buffer2, 8192);\n    __asm__ volatile(\"\" ::: \"memory\");\n  }\n  end = clock();\n  fprintf(stderr,\n          \"+ created 8Mb using 8,192 Bytes \"\n          \"Random %lu CPU clock count ~%.2fMb/s\\n\",\n          end - start, (8.0) / (((double)(end - start)) / CLOCKS_PER_SEC));\n  (void)buffer1;\n  (void)buffer2;\n#endif\n}\n\n/* *****************************************************************************\nPoll (not kqueue or epoll) tests\n***************************************************************************** */\n#if FIO_ENGINE_POLL\nFIO_FUNC void fio_poll_test(void) {\n  fprintf(stderr, \"=== Testing poll add / remove fd\\n\");\n  fio_poll_add(5);\n  FIO_ASSERT(fio_data->poll[5].fd == 5, \"fio_poll_add didn't set used fd data\");\n  FIO_ASSERT(fio_data->poll[5].events ==\n                 (FIO_POLL_READ_EVENTS | FIO_POLL_WRITE_EVENTS),\n             \"fio_poll_add didn't set used fd flags\");\n  fio_poll_add(7);\n  FIO_ASSERT(fio_data->poll[6].fd == -1,\n             \"fio_poll_add didn't reset unused fd data %d\",\n             fio_data->poll[6].fd);\n  fio_poll_add(6);\n  fio_poll_remove_fd(6);\n  FIO_ASSERT(fio_data->poll[6].fd == -1,\n             \"fio_poll_remove_fd didn't reset unused fd data\");\n  FIO_ASSERT(fio_data->poll[6].events == 0,\n             \"fio_poll_remove_fd didn't reset unused fd flags\");\n  fio_poll_remove_read(7);\n  FIO_ASSERT(fio_data->poll[7].events == (FIO_POLL_WRITE_EVENTS),\n             \"fio_poll_remove_read didn't remove read flags\");\n  fio_poll_add_read(7);\n  fio_poll_remove_write(7);\n  FIO_ASSERT(fio_data->poll[7].events == (FIO_POLL_READ_EVENTS),\n             \"fio_poll_remove_write didn't remove read flags\");\n  fio_poll_add_write(7);\n  fio_poll_remove_read(7);\n  FIO_ASSERT(fio_data->poll[7].events == (FIO_POLL_WRITE_EVENTS),\n             \"fio_poll_add_write didn't add the write flag?\");\n  fio_poll_remove_write(7);\n  FIO_ASSERT(fio_data->poll[7].fd == -1,\n             \"fio_poll_remove (both) didn't reset unused fd data\");\n  FIO_ASSERT(fio_data->poll[7].events == 0,\n             \"fio_poll_remove (both) didn't reset unused fd flags\");\n  fio_poll_remove_fd(5);\n  fprintf(stderr, \"\\n* passed.\\n\");\n}\n#else\n#define fio_poll_test()\n#endif\n\n/* *****************************************************************************\nTest UUID Linking\n***************************************************************************** */\n\nFIO_FUNC void fio_uuid_link_test_on_close(void *obj) {\n  fio_atomic_add((uintptr_t *)obj, 1);\n}\n\nFIO_FUNC void fio_uuid_link_test(void) {\n  fprintf(stderr, \"=== Testing fio_uuid_link\\n\");\n  uintptr_t called = 0;\n  uintptr_t removed = 0;\n  intptr_t uuid = fio_socket(NULL, \"8765\", 1);\n  FIO_ASSERT(uuid != -1, \"fio_uuid_link_test failed to create a socket!\");\n  fio_uuid_link(uuid, &called, fio_uuid_link_test_on_close);\n  FIO_ASSERT(called == 0,\n             \"fio_uuid_link failed - on_close callback called too soon!\");\n  fio_uuid_link(uuid, &removed, fio_uuid_link_test_on_close);\n  fio_uuid_unlink(uuid, &removed);\n  fio_close(uuid);\n  fio_defer_perform();\n  FIO_ASSERT(called, \"fio_uuid_link failed - on_close callback wasn't called!\");\n  FIO_ASSERT(called, \"fio_uuid_unlink failed - on_close callback was called \"\n                     \"(wasn't removed)!\");\n  fprintf(stderr, \"* passed.\\n\");\n}\n\n/* *****************************************************************************\nByte Order Testing\n***************************************************************************** */\n\nFIO_FUNC void fio_str2u_test(void) {\n  fprintf(stderr, \"=== Testing fio_u2strX and fio_u2strX functions.\\n\");\n  char buffer[32];\n  for (int64_t i = -1024; i < 1024; ++i) {\n    fio_u2str64(buffer, i);\n    __asm__ volatile(\"\" ::: \"memory\");\n    FIO_ASSERT((int64_t)fio_str2u64(buffer) == i,\n               \"fio_u2str64 / fio_str2u64  mismatch %zd != %zd\",\n               (ssize_t)fio_str2u64(buffer), (ssize_t)i);\n  }\n  for (int32_t i = -1024; i < 1024; ++i) {\n    fio_u2str32(buffer, i);\n    __asm__ volatile(\"\" ::: \"memory\");\n    FIO_ASSERT((int32_t)fio_str2u32(buffer) == i,\n               \"fio_u2str32 / fio_str2u32  mismatch %zd != %zd\",\n               (ssize_t)(fio_str2u32(buffer)), (ssize_t)i);\n  }\n  for (int16_t i = -1024; i < 1024; ++i) {\n    fio_u2str16(buffer, i);\n    __asm__ volatile(\"\" ::: \"memory\");\n    FIO_ASSERT((int16_t)fio_str2u16(buffer) == i,\n               \"fio_u2str16 / fio_str2u16  mismatch %zd != %zd\",\n               (ssize_t)(fio_str2u16(buffer)), (ssize_t)i);\n  }\n  fprintf(stderr, \"* passed.\\n\");\n}\n\n/* *****************************************************************************\nPub/Sub partial tests\n***************************************************************************** */\n\n#if FIO_PUBSUB_SUPPORT\n\nFIO_FUNC void fio_pubsub_test_on_message(fio_msg_s *msg) {\n  fio_atomic_add((uintptr_t *)msg->udata1, 1);\n}\nFIO_FUNC void fio_pubsub_test_on_unsubscribe(void *udata1, void *udata2) {\n  fio_atomic_add((uintptr_t *)udata1, 1);\n  (void)udata2;\n}\n\nFIO_FUNC void fio_pubsub_test(void) {\n  fprintf(stderr, \"=== Testing pub/sub (partial)\\n\");\n  fio_data->active = 1;\n  fio_data->is_worker = 1;\n  fio_data->workers = 1;\n  subscription_s *s = fio_subscribe(.filter = 1, .on_message = NULL);\n  uintptr_t counter = 0;\n  uintptr_t expect = 0;\n  FIO_ASSERT(!s, \"fio_subscribe should fail without a callback!\");\n  char buffer[8];\n  fio_u2str32((uint8_t *)buffer + 1, 42);\n  FIO_ASSERT(fio_str2u32((uint8_t *)buffer + 1) == 42,\n             \"fio_u2str32 / fio_str2u32 not reversible (42)!\");\n  fio_u2str32((uint8_t *)buffer, 4);\n  FIO_ASSERT(fio_str2u32((uint8_t *)buffer) == 4,\n             \"fio_u2str32 / fio_str2u32 not reversible (4)!\");\n  subscription_s *s2 =\n      fio_subscribe(.filter = 1, .udata1 = &counter,\n                    .on_message = fio_pubsub_test_on_message,\n                    .on_unsubscribe = fio_pubsub_test_on_unsubscribe);\n  FIO_ASSERT(s2, \"fio_subscribe FAILED on filtered subscription.\");\n  fio_publish(.filter = 1);\n  ++expect;\n  fio_defer_perform();\n  FIO_ASSERT(counter == expect, \"publishing failed to filter 1!\");\n  fio_publish(.filter = 2);\n  fio_defer_perform();\n  FIO_ASSERT(counter == expect, \"publishing to filter 2 arrived at filter 1!\");\n  fio_unsubscribe(s);\n  fio_unsubscribe(s2);\n  ++expect;\n  fio_defer_perform();\n  FIO_ASSERT(counter == expect, \"unsubscribe wasn't called for filter 1!\");\n  s = fio_subscribe(.channel = {0, 4, \"name\"}, .udata1 = &counter,\n                    .on_message = fio_pubsub_test_on_message,\n                    .on_unsubscribe = fio_pubsub_test_on_unsubscribe);\n  FIO_ASSERT(s, \"fio_subscribe FAILED on named subscription.\");\n  fio_publish(.channel = {0, 4, \"name\"});\n  ++expect;\n  fio_defer_perform();\n  FIO_ASSERT(counter == expect, \"publishing failed to named channel!\");\n  fio_publish(.channel = {0, 4, \"none\"});\n  fio_defer_perform();\n  FIO_ASSERT(counter == expect,\n             \"publishing arrived to named channel with wrong name!\");\n  fio_unsubscribe(s);\n  ++expect;\n  fio_defer_perform();\n  FIO_ASSERT(counter == expect, \"unsubscribe wasn't called for named channel!\");\n  fio_data->is_worker = 0;\n  fio_data->active = 0;\n  fio_data->workers = 0;\n  fio_defer_perform();\n  (void)fio_pubsub_test_on_message;\n  (void)fio_pubsub_test_on_unsubscribe;\n  fprintf(stderr, \"* passed.\\n\");\n}\n#else\n#define fio_pubsub_test()\n#endif\n\n/* *****************************************************************************\nString 2 Number and Number 2 String (partial) testing\n***************************************************************************** */\n\n#if NODEBUG\n#define FIO_ATOL_TEST_MAX_CYCLES 3145728\n#else\n#define FIO_ATOL_TEST_MAX_CYCLES 4096\n#endif\nFIO_FUNC void fio_atol_test(void) {\n  fprintf(stderr, \"=== Testing fio_ltoa and fio_atol (partial)\\n\");\n#ifndef NODEBUG\n  fprintf(stderr,\n          \"Note: No optimizations - facil.io performance will be slow.\\n\");\n#endif\n  fprintf(stderr,\n          \"      Test with make test/optimized for realistic results.\\n\");\n  time_t start, end;\n\n#define TEST_ATOL(s, n)                                                        \\\n  do {                                                                         \\\n    char *p = (char *)(s);                                                     \\\n    int64_t r = fio_atol(&p);                                                  \\\n    FIO_ASSERT(r == (n), \"fio_atol test error! %s => %zd (not %zd)\",           \\\n               ((char *)(s)), (size_t)r, (size_t)n);                           \\\n    FIO_ASSERT((s) + strlen((s)) == p,                                         \\\n               \"fio_atol test error! %s reading position not at end (%zu)\",    \\\n               (s), (size_t)(p - (s)));                                        \\\n    char buf[72];                                                              \\\n    buf[fio_ltoa(buf, n, 2)] = 0;                                              \\\n    p = buf;                                                                   \\\n    FIO_ASSERT(fio_atol(&p) == (n),                                            \\\n               \"fio_ltoa base 2 test error! \"                                  \\\n               \"%s != %s (%zd)\",                                               \\\n               buf, ((char *)(s)), (size_t)((p = buf), fio_atol(&p)));         \\\n    buf[fio_ltoa(buf, n, 8)] = 0;                                              \\\n    p = buf;                                                                   \\\n    FIO_ASSERT(fio_atol(&p) == (n),                                            \\\n               \"fio_ltoa base 8 test error! \"                                  \\\n               \"%s != %s (%zd)\",                                               \\\n               buf, ((char *)(s)), (size_t)((p = buf), fio_atol(&p)));         \\\n    buf[fio_ltoa(buf, n, 10)] = 0;                                             \\\n    p = buf;                                                                   \\\n    FIO_ASSERT(fio_atol(&p) == (n),                                            \\\n               \"fio_ltoa base 10 test error! \"                                 \\\n               \"%s != %s (%zd)\",                                               \\\n               buf, ((char *)(s)), (size_t)((p = buf), fio_atol(&p)));         \\\n    buf[fio_ltoa(buf, n, 16)] = 0;                                             \\\n    p = buf;                                                                   \\\n    FIO_ASSERT(fio_atol(&p) == (n),                                            \\\n               \"fio_ltoa base 16 test error! \"                                 \\\n               \"%s != %s (%zd)\",                                               \\\n               buf, ((char *)(s)), (size_t)((p = buf), fio_atol(&p)));         \\\n  } while (0)\n  TEST_ATOL(\"0x1\", 1);\n  TEST_ATOL(\"-0x1\", -1);\n  TEST_ATOL(\"-0xa\", -10);                                /* sign before hex */\n  TEST_ATOL(\"0xe5d4c3b2a1908770\", -1885667171979196560); /* sign within hex */\n  TEST_ATOL(\"0b00000000000011\", 3);\n  TEST_ATOL(\"-0b00000000000011\", -3);\n  TEST_ATOL(\"0b0000000000000000000000000000000000000000000000000\", 0);\n  TEST_ATOL(\"0\", 0);\n  TEST_ATOL(\"1\", 1);\n  TEST_ATOL(\"2\", 2);\n  TEST_ATOL(\"-2\", -2);\n  TEST_ATOL(\"0000000000000000000000000000000000000000000000042\", 34); /* oct */\n  TEST_ATOL(\"9223372036854775807\", 9223372036854775807LL); /* INT64_MAX */\n  TEST_ATOL(\"9223372036854775808\",\n            9223372036854775807LL); /* INT64_MAX overflow protection */\n  TEST_ATOL(\"9223372036854775999\",\n            9223372036854775807LL); /* INT64_MAX overflow protection */\n\n  char number_hex[128] = \"0xe5d4c3b2a1908770\"; /* hex with embedded sign */\n  // char number_hex[128] = \"-0x1a2b3c4d5e6f7890\";\n  char number[128] = \"-1885667171979196560\";\n  intptr_t expect = -1885667171979196560;\n  intptr_t result = 0;\n\n  result = 0;\n\n  start = clock();\n  for (size_t i = 0; i < FIO_ATOL_TEST_MAX_CYCLES; ++i) {\n    __asm__ volatile(\"\" ::: \"memory\");\n    char *pos = number;\n    result = fio_atol(&pos);\n    __asm__ volatile(\"\" ::: \"memory\");\n  }\n  end = clock();\n  fprintf(stderr, \"fio_atol base 10 (%ld): %zd CPU cycles\\n\", result,\n          end - start);\n\n  result = 0;\n  start = clock();\n  for (size_t i = 0; i < FIO_ATOL_TEST_MAX_CYCLES; ++i) {\n    __asm__ volatile(\"\" ::: \"memory\");\n    result = strtol(number, NULL, 0);\n    __asm__ volatile(\"\" ::: \"memory\");\n  }\n  end = clock();\n  fprintf(stderr, \"native strtol base 10 (%ld): %zd CPU cycles\\n\", result,\n          end - start);\n\n  result = 0;\n  start = clock();\n  for (size_t i = 0; i < FIO_ATOL_TEST_MAX_CYCLES; ++i) {\n    __asm__ volatile(\"\" ::: \"memory\");\n    char *pos = number_hex;\n    result = fio_atol(&pos);\n    __asm__ volatile(\"\" ::: \"memory\");\n  }\n  end = clock();\n  fprintf(stderr, \"fio_atol base 16 (%ld): %zd CPU cycles\\n\", result,\n          end - start);\n\n  result = 0;\n  start = clock();\n  for (size_t i = 0; i < FIO_ATOL_TEST_MAX_CYCLES; ++i) {\n    __asm__ volatile(\"\" ::: \"memory\");\n    result = strtol(number_hex, NULL, 0);\n    __asm__ volatile(\"\" ::: \"memory\");\n  }\n  end = clock();\n  fprintf(stderr, \"native strtol base 16 (%ld): %zd CPU cycles%s\\n\", result,\n          end - start, (result != expect ? \" (!?stdlib overflow?!)\" : \"\"));\n\n  result = 0;\n  start = clock();\n  for (size_t i = 0; i < FIO_ATOL_TEST_MAX_CYCLES; ++i) {\n    __asm__ volatile(\"\" ::: \"memory\");\n    fio_ltoa(number, expect, 10);\n    __asm__ volatile(\"\" ::: \"memory\");\n  }\n  end = clock();\n  {\n    char *buf = number;\n    FIO_ASSERT(fio_atol(&buf) == expect,\n               \"fio_ltoa with base 10 returned wrong result (%s != %ld)\",\n               number, expect);\n  }\n  fprintf(stderr, \"fio_ltoa base 10 (%s): %zd CPU cycles\\n\", number,\n          end - start);\n\n  result = 0;\n  start = clock();\n  for (size_t i = 0; i < FIO_ATOL_TEST_MAX_CYCLES; ++i) {\n    __asm__ volatile(\"\" ::: \"memory\");\n    sprintf(number, \"%ld\", expect);\n    __asm__ volatile(\"\" ::: \"memory\");\n  }\n  end = clock();\n  fprintf(stderr, \"native sprintf base 10 (%s): %zd CPU cycles\\n\", number,\n          end - start);\n  FIO_ASSERT(fio_ltoa(number, 0, 0) == 1,\n             \"base 10 zero should be single char.\");\n  FIO_ASSERT(memcmp(number, \"0\", 2) == 0, \"base 10 zero should be \\\"0\\\" (%s).\",\n             number);\n  fprintf(stderr, \"* passed.\\n\");\n#undef TEST_ATOL\n}\n\n/* *****************************************************************************\nString 2 Float and Float 2 String (partial) testing\n***************************************************************************** */\n\nFIO_FUNC void fio_atof_test(void) {\n  fprintf(stderr, \"=== Testing fio_ftoa and fio_ftoa (partial)\\n\");\n#define TEST_DOUBLE(s, d, must)                                                \\\n  do {                                                                         \\\n    char *p = (char *)(s);                                                     \\\n    double r = fio_atof(&p);                                                   \\\n    if (r != (d)) {                                                            \\\n      FIO_LOG_DEBUG(\"Double Test Error! %s => %.19g (not %.19g)\",              \\\n                    ((char *)(s)), r, d);                                      \\\n      if (must) {                                                              \\\n        FIO_ASSERT(0, \"double test failed on %s\", ((char *)(s)));              \\\n        exit(-1);                                                              \\\n      }                                                                        \\\n    }                                                                          \\\n  } while (0)\n  /* The numbers were copied from https://github.com/miloyip/rapidjson */\n  TEST_DOUBLE(\"0.0\", 0.0, 1);\n  TEST_DOUBLE(\"-0.0\", -0.0, 1);\n  TEST_DOUBLE(\"1.0\", 1.0, 1);\n  TEST_DOUBLE(\"-1.0\", -1.0, 1);\n  TEST_DOUBLE(\"1.5\", 1.5, 1);\n  TEST_DOUBLE(\"-1.5\", -1.5, 1);\n  TEST_DOUBLE(\"3.1416\", 3.1416, 1);\n  TEST_DOUBLE(\"1E10\", 1E10, 1);\n  TEST_DOUBLE(\"1e10\", 1e10, 1);\n  TEST_DOUBLE(\"1E+10\", 1E+10, 1);\n  TEST_DOUBLE(\"1E-10\", 1E-10, 1);\n  TEST_DOUBLE(\"-1E10\", -1E10, 1);\n  TEST_DOUBLE(\"-1e10\", -1e10, 1);\n  TEST_DOUBLE(\"-1E+10\", -1E+10, 1);\n  TEST_DOUBLE(\"-1E-10\", -1E-10, 1);\n  TEST_DOUBLE(\"1.234E+10\", 1.234E+10, 1);\n  TEST_DOUBLE(\"1.234E-10\", 1.234E-10, 1);\n  TEST_DOUBLE(\"1.79769e+308\", 1.79769e+308, 1);\n  TEST_DOUBLE(\"2.22507e-308\", 2.22507e-308, 1);\n  TEST_DOUBLE(\"-1.79769e+308\", -1.79769e+308, 1);\n  TEST_DOUBLE(\"-2.22507e-308\", -2.22507e-308, 1);\n  TEST_DOUBLE(\"4.9406564584124654e-324\", 4.9406564584124654e-324, 0);\n  TEST_DOUBLE(\"2.2250738585072009e-308\", 2.2250738585072009e-308, 0);\n  TEST_DOUBLE(\"2.2250738585072014e-308\", 2.2250738585072014e-308, 1);\n  TEST_DOUBLE(\"1.7976931348623157e+308\", 1.7976931348623157e+308, 1);\n  TEST_DOUBLE(\"1e-10000\", 0.0, 0);\n  TEST_DOUBLE(\"18446744073709551616\", 18446744073709551616.0, 0);\n\n  TEST_DOUBLE(\"-9223372036854775809\", -9223372036854775809.0, 0);\n\n  TEST_DOUBLE(\"0.9868011474609375\", 0.9868011474609375, 0);\n  TEST_DOUBLE(\"123e34\", 123e34, 1);\n  TEST_DOUBLE(\"45913141877270640000.0\", 45913141877270640000.0, 1);\n  TEST_DOUBLE(\"2.2250738585072011e-308\", 2.2250738585072011e-308, 0);\n  TEST_DOUBLE(\"1e-214748363\", 0.0, 1);\n  TEST_DOUBLE(\"1e-214748364\", 0.0, 1);\n  TEST_DOUBLE(\"0.017976931348623157e+310, 1\", 1.7976931348623157e+308, 0);\n\n  TEST_DOUBLE(\"2.2250738585072012e-308\", 2.2250738585072014e-308, 0);\n  TEST_DOUBLE(\"2.22507385850720113605740979670913197593481954635164565e-308\",\n              2.2250738585072014e-308, 0);\n\n  TEST_DOUBLE(\"0.999999999999999944488848768742172978818416595458984375\", 1.0,\n              0);\n  TEST_DOUBLE(\"0.999999999999999944488848768742172978818416595458984376\", 1.0,\n              0);\n  TEST_DOUBLE(\"1.00000000000000011102230246251565404236316680908203125\", 1.0,\n              0);\n  TEST_DOUBLE(\"1.00000000000000011102230246251565404236316680908203124\", 1.0,\n              0);\n\n  TEST_DOUBLE(\"72057594037927928.0\", 72057594037927928.0, 0);\n  TEST_DOUBLE(\"72057594037927936.0\", 72057594037927936.0, 0);\n  TEST_DOUBLE(\"72057594037927932.0\", 72057594037927936.0, 0);\n  TEST_DOUBLE(\"7205759403792793200001e-5\", 72057594037927936.0, 0);\n\n  TEST_DOUBLE(\"9223372036854774784.0\", 9223372036854774784.0, 0);\n  TEST_DOUBLE(\"9223372036854775808.0\", 9223372036854775808.0, 0);\n  TEST_DOUBLE(\"9223372036854775296.0\", 9223372036854775808.0, 0);\n  TEST_DOUBLE(\"922337203685477529600001e-5\", 9223372036854775808.0, 0);\n\n  TEST_DOUBLE(\"10141204801825834086073718800384\",\n              10141204801825834086073718800384.0, 0);\n  TEST_DOUBLE(\"10141204801825835211973625643008\",\n              10141204801825835211973625643008.0, 0);\n  TEST_DOUBLE(\"10141204801825834649023672221696\",\n              10141204801825835211973625643008.0, 0);\n  TEST_DOUBLE(\"1014120480182583464902367222169600001e-5\",\n              10141204801825835211973625643008.0, 0);\n\n  TEST_DOUBLE(\"5708990770823838890407843763683279797179383808\",\n              5708990770823838890407843763683279797179383808.0, 0);\n  TEST_DOUBLE(\"5708990770823839524233143877797980545530986496\",\n              5708990770823839524233143877797980545530986496.0, 0);\n  TEST_DOUBLE(\"5708990770823839207320493820740630171355185152\",\n              5708990770823839524233143877797980545530986496.0, 0);\n  TEST_DOUBLE(\"5708990770823839207320493820740630171355185152001e-3\",\n              5708990770823839524233143877797980545530986496.0, 0);\n  fprintf(stderr, \"\\n* passed.\\n\");\n}\n/* *****************************************************************************\nRun all tests\n***************************************************************************** */\n\nvoid fio_test(void) {\n  FIO_ASSERT(fio_capa(), \"facil.io initialization error!\");\n  fio_malloc_test();\n  fio_state_callback_test();\n  fio_str_test();\n  fio_atol_test();\n  fio_atof_test();\n  fio_str2u_test();\n  fio_llist_test();\n  fio_ary_test();\n  fio_set_test();\n  fio_defer_test();\n  fio_timer_test();\n  fio_poll_test();\n  fio_socket_test();\n  fio_uuid_link_test();\n  fio_cycle_test();\n  fio_riskyhash_test();\n  fio_siphash_test();\n  fio_sha1_test();\n  fio_sha2_test();\n  fio_base64_test();\n  fio_test_random();\n  fio_pubsub_test();\n  (void)fio_sentinel_task;\n  (void)deferred_on_shutdown;\n  (void)fio_poll;\n}\n\n#endif /* DEBUG */\n", "/*\nCopyright: Boaz Segev, 2018-2019\nLicense: MIT\n\nFeel free to copy, use and enjoy according to the license provided.\n*/\n\n#ifndef H_FACIL_IO_H\n/**\n\"facil.h\" is the main header for the facil.io server platform.\n*/\n#define H_FACIL_IO_H\n\n/* *****************************************************************************\n * Table of contents (find by subject):\n * =================\n * Version and helper macros\n * Helper String Information Type\n * Memory pool / custom allocator for short lived objects\n * Logging and testing helpers\n *\n * Connection Callback (Protocol) Management\n * Listening to Incoming Connections\n * Connecting to remote servers as a client\n * Starting the IO reactor and reviewing it's state\n * Socket / Connection Functions\n * Connection Read / Write Hooks, for overriding the system calls\n * Concurrency overridable functions\n * Connection Task scheduling\n * Event / Task scheduling\n * Startup / State Callbacks (fork, start up, idle, etc')\n * Lower Level API - for special circumstances, use with care under\n *\n * Pub/Sub / Cluster Messages API\n * Cluster Messages and Pub/Sub\n * Cluster / Pub/Sub Middleware and Extensions (\"Engines\")\n *\n * Atomic Operations and Spin Locking Helper Functions\n * Simple Constant Time Operations\n * Byte Swapping and Network Order\n *\n * Converting Numbers to Strings (and back)\n * Strings to Numbers\n * Numbers to Strings* Random Generator Functions\n *\n * SipHash\n * SHA-1\n * SHA-2\n * Base64 (URL) encoding\n *\n * Memory Allocator Details\n *\n * Spin locking Implementation\n *\n ******** facil.io Data Types (String, Set / Hash Map, Linked Lists, etc')\n *\n * These types can be included by defining the macros and (re)including fio.h.\n *\n *\n *\n *                      #ifdef FIO_INCLUDE_LINKED_LIST\n *\n * Linked List Helpers\n * Independent Linked List API\n * Embedded Linked List API* Independent Linked List Implementation\n * Embeded Linked List Implementation\n *\n *\n *\n *                      #ifdef FIO_INCLUDE_STR\n *\n * String Helpers\n * String API - Initialization and Destruction\n * String API - String state (data pointers, length, capacity, etc')\n * String API - Memory management\n * String API - UTF-8 State\n * String Implementation - state (data pointers, length, capacity, etc')\n * String Implementation - Memory management\n * String Implementation - UTF-8 State\n * String Implementation - Content Manipulation and Review\n *\n *\n *\n *            #ifdef FIO_ARY_NAME - can be included more than once\n *\n * Dynamic Array Data-Store\n * Array API\n * Array Type\n * Array Memory Management\n * Array API implementation\n * Array Testing\n *\n *\n *\n *            #ifdef FIO_SET_NAME - can be included more than once\n *\n * Set / Hash Map Data-Store\n * Set / Hash Map API\n * Set / Hash Map Internal Data Structures\n * Set / Hash Map Internal Helpers\n * Set / Hash Map Implementation\n *\n *****************************************************************************\n */\n\n/* *****************************************************************************\nVersion and helper macros\n***************************************************************************** */\n\n#define FIO_VERSION_MAJOR 0\n#define FIO_VERSION_MINOR 7\n#define FIO_VERSION_PATCH 0\n#define FIO_VERSION_BETA 9\n\n/* Automatically convert version data to a string constant - ignore these two */\n#define FIO_MACRO2STR_STEP2(macro) #macro\n#define FIO_MACRO2STR(macro) FIO_MACRO2STR_STEP2(macro)\n\n/** The facil.io version as a String literal */\n#if FIO_VERSION_BETA\n#define FIO_VERSION_STRING                                                     \\\n  FIO_MACRO2STR(FIO_VERSION_MAJOR)                                             \\\n  \".\" FIO_MACRO2STR(FIO_VERSION_MINOR) \".\" FIO_MACRO2STR(                      \\\n      FIO_VERSION_PATCH) \".beta\" FIO_MACRO2STR(FIO_VERSION_BETA)\n#else\n#define FIO_VERSION_STRING                                                     \\\n  FIO_MACRO2STR(FIO_VERSION_MAJOR)                                             \\\n  \".\" FIO_MACRO2STR(FIO_VERSION_MINOR) \".\" FIO_MACRO2STR(FIO_VERSION_PATCH)\n#endif\n\n#ifndef FIO_MAX_SOCK_CAPACITY\n/**\n * The maximum number of connections per worker process.\n */\n#define FIO_MAX_SOCK_CAPACITY 131072\n#endif\n\n#ifndef FIO_CPU_CORES_LIMIT\n/**\n * If facil.io detects more CPU cores than the number of cores stated in the\n * FIO_CPU_CORES_LIMIT, it will assume an error and cap the number of cores\n * detected to the assigned limit.\n *\n * This is only relevant to automated values, when running facil.io with zero\n * threads and processes, which invokes a large matrix of workers and threads\n * (see {facil_run})\n *\n * The default auto-detection cap is set at 8 cores. The number is arbitrary\n * (historically the number 7 was used after testing `malloc` race conditions on\n * a MacBook Pro).\n *\n * This does NOT effect manually set (non-zero) worker/thread values.\n */\n#define FIO_CPU_CORES_LIMIT 8\n#endif\n\n#ifndef FIO_DEFER_THROTTLE_PROGRESSIVE\n/**\n * The progressive throttling model makes concurrency and parallelism more\n * likely.\n *\n * Otherwise threads are assumed to be intended for \"fallback\" in case of slow\n * user code, where a single thread should be active most of the time and other\n * threads are activated only when that single thread is slow to perform.\n */\n#define FIO_DEFER_THROTTLE_PROGRESSIVE 1\n#endif\n\n#ifndef FIO_PRINT_STATE\n/**\n * Enables the depraceted FIO_LOG_STATE(msg,...) macro, which prints information\n * level messages to stderr.\n */\n#define FIO_PRINT_STATE 0\n#endif\n\n#ifndef FIO_PUBSUB_SUPPORT\n/**\n * If true (1), compiles the facil.io pub/sub API.\n */\n#define FIO_PUBSUB_SUPPORT 1\n#endif\n\n#ifndef FIO_LOG_LENGTH_LIMIT\n/**\n * Since logging uses stack memory rather than dynamic allocation, it's memory\n * usage must be limited to avoid exploding the stack. The following sets the\n * memory used for a logging event.\n */\n#define FIO_LOG_LENGTH_LIMIT 2048\n#endif\n\n#ifndef FIO_IGNORE_MACRO\n/**\n * This is used internally to ignore macros that shadow functions (avoiding\n * named arguments when required).\n */\n#define FIO_IGNORE_MACRO\n#endif\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n\n#include <errno.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#include <time.h>\n\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <unistd.h>\n\n#if !defined(__GNUC__) && !defined(__clang__) && !defined(FIO_GNUC_BYPASS)\n#define __attribute__(...)\n#define __has_include(...) 0\n#define __has_builtin(...) 0\n#define FIO_GNUC_BYPASS 1\n#elif !defined(__clang__) && !defined(__has_builtin)\n/* E.g: GCC < 6.0 doesn't support __has_builtin */\n#define __has_builtin(...) 0\n#define FIO_GNUC_BYPASS 1\n#endif\n\n#if defined(__GNUC__) && (__GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 5))\n/* GCC < 4.5 doesn't support deprecation reason string */\n#define deprecated(reason) deprecated\n#endif\n\n#ifndef FIO_FUNC\n#define FIO_FUNC static __attribute__((unused))\n#endif\n\n#if defined(__FreeBSD__)\n#include <netinet/in.h>\n#include <sys/socket.h>\n#endif\n\n/* *****************************************************************************\nPatch for OSX version < 10.12 from https://stackoverflow.com/a/9781275/4025095\n***************************************************************************** */\n#if defined(__MACH__) && !defined(CLOCK_REALTIME)\n#include <sys/time.h>\n#define CLOCK_REALTIME 0\n#define clock_gettime patch_clock_gettime\n// clock_gettime is not implemented on older versions of OS X (< 10.12).\n// If implemented, CLOCK_REALTIME will have already been defined.\nstatic inline int patch_clock_gettime(int clk_id, struct timespec *t) {\n  struct timeval now;\n  int rv = gettimeofday(&now, NULL);\n  if (rv)\n    return rv;\n  t->tv_sec = now.tv_sec;\n  t->tv_nsec = now.tv_usec * 1000;\n  return 0;\n  (void)clk_id;\n}\n#endif\n\n/* *****************************************************************************\nC++ extern start\n***************************************************************************** */\n/* support C++ */\n#ifdef __cplusplus\nextern \"C\" {\n/* C++ keyword was deprecated */\n#define register\n#endif\n\n/* *****************************************************************************\nHelper String Information Type\n***************************************************************************** */\n\n#ifndef FIO_STR_INFO_TYPE\n/** A string information type, reports information about a C string. */\ntypedef struct fio_str_info_s {\n  size_t capa; /* Buffer capacity, if the string is writable. */\n  size_t len;  /* String length. */\n  char *data;  /* String's first byte. */\n} fio_str_info_s;\n#define FIO_STR_INFO_TYPE\n#endif\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n\n\n\n\n\nMemory pool / custom allocator for short lived objects\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/* inform the compiler that the returned value is aligned on 16 byte marker */\n#if FIO_FORCE_MALLOC\n#define FIO_ALIGN\n#define FIO_ALIGN_NEW\n#elif __clang__ || __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ > 8)\n#define FIO_ALIGN __attribute__((assume_aligned(16)))\n#define FIO_ALIGN_NEW __attribute__((malloc, assume_aligned(16)))\n#else\n#define FIO_ALIGN\n#define FIO_ALIGN_NEW\n#endif\n\n/**\n * Allocates memory using a per-CPU core block memory pool.\n * Memory is zeroed out.\n *\n * Allocations above FIO_MEMORY_BLOCK_ALLOC_LIMIT (16Kb when using 32Kb blocks)\n * will be redirected to `mmap`, as if `fio_mmap` was called.\n */\nvoid *FIO_ALIGN_NEW fio_malloc(size_t size);\n\n/**\n * same as calling `fio_malloc(size_per_unit * unit_count)`;\n *\n * Allocations above FIO_MEMORY_BLOCK_ALLOC_LIMIT (16Kb when using 32Kb blocks)\n * will be redirected to `mmap`, as if `fio_mmap` was called.\n */\nvoid *FIO_ALIGN_NEW fio_calloc(size_t size_per_unit, size_t unit_count);\n\n/** Frees memory that was allocated using this library. */\nvoid fio_free(void *ptr);\n\n/**\n * Re-allocates memory. An attempt to avoid copying the data is made only for\n * big memory allocations (larger than FIO_MEMORY_BLOCK_ALLOC_LIMIT).\n */\nvoid *FIO_ALIGN fio_realloc(void *ptr, size_t new_size);\n\n/**\n * Re-allocates memory. An attempt to avoid copying the data is made only for\n * big memory allocations (larger than FIO_MEMORY_BLOCK_ALLOC_LIMIT).\n *\n * This variation is slightly faster as it might copy less data.\n */\nvoid *FIO_ALIGN fio_realloc2(void *ptr, size_t new_size, size_t copy_length);\n\n/**\n * Allocates memory directly using `mmap`, this is prefered for objects that\n * both require almost a page of memory (or more) and expect a long lifetime.\n *\n * However, since this allocation will invoke the system call (`mmap`), it will\n * be inherently slower.\n *\n * `fio_free` can be used for deallocating the memory.\n */\nvoid *FIO_ALIGN_NEW fio_mmap(size_t size);\n\n/**\n * When forking is called manually, call this function to reset the facil.io\n * memory allocator's locks.\n */\nvoid fio_malloc_after_fork(void);\n\n#undef FIO_ALIGN\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n\n\n\n\n\nLogging and testing helpers\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/** Logging level of zero (no logging). */\n#define FIO_LOG_LEVEL_NONE 0\n/** Log fatal errors. */\n#define FIO_LOG_LEVEL_FATAL 1\n/** Log errors and fatal errors. */\n#define FIO_LOG_LEVEL_ERROR 2\n/** Log warnings, errors and fatal errors. */\n#define FIO_LOG_LEVEL_WARNING 3\n/** Log every message (info, warnings, errors and fatal errors). */\n#define FIO_LOG_LEVEL_INFO 4\n/** Log everything, including debug messages. */\n#define FIO_LOG_LEVEL_DEBUG 5\n\n#if FIO_LOG_LENGTH_LIMIT > 128\n#define FIO_LOG____LENGTH_ON_STACK FIO_LOG_LENGTH_LIMIT\n#define FIO_LOG____LENGTH_BORDER (FIO_LOG_LENGTH_LIMIT - 32)\n#else\n#define FIO_LOG____LENGTH_ON_STACK (FIO_LOG_LENGTH_LIMIT + 32)\n#define FIO_LOG____LENGTH_BORDER FIO_LOG_LENGTH_LIMIT\n#endif\n/** The logging level */\nint __attribute__((weak)) FIO_LOG_LEVEL;\n\n#pragma weak FIO_LOG2STDERR\nvoid __attribute__((format(printf, 1, 0), weak))\nFIO_LOG2STDERR(const char *format, ...) {\n  char tmp___log[FIO_LOG____LENGTH_ON_STACK];\n  va_list argv;\n  va_start(argv, format);\n  int len___log = vsnprintf(tmp___log, FIO_LOG_LENGTH_LIMIT - 2, format, argv);\n  va_end(argv);\n  if (len___log <= 0 || len___log >= FIO_LOG_LENGTH_LIMIT - 2) {\n    if (len___log >= FIO_LOG_LENGTH_LIMIT - 2) {\n      memcpy(tmp___log + FIO_LOG____LENGTH_BORDER, \"... (warning: truncated).\",\n             25);\n      len___log = FIO_LOG____LENGTH_BORDER + 25;\n    } else {\n      fwrite(\"ERROR: log output error (can't write).\\n\", 39, 1, stderr);\n      return;\n    }\n  }\n  tmp___log[len___log++] = '\\n';\n  tmp___log[len___log] = '0';\n  fwrite(tmp___log, len___log, 1, stderr);\n}\n\n#ifndef FIO_LOG_PRINT\n#define FIO_LOG_PRINT(level, ...)                                              \\\n  do {                                                                         \\\n    if (level <= FIO_LOG_LEVEL) {                                              \\\n      FIO_LOG2STDERR(__VA_ARGS__);                                             \\\n    }                                                                          \\\n  } while (0)\n#define FIO_LOG_DEBUG(...)                                                     \\\n  FIO_LOG_PRINT(FIO_LOG_LEVEL_DEBUG,                                           \\\n                \"DEBUG (\"__FILE__                                              \\\n                \":\" FIO_MACRO2STR(__LINE__) \"): \" __VA_ARGS__)\n#define FIO_LOG_INFO(...)                                                      \\\n  FIO_LOG_PRINT(FIO_LOG_LEVEL_INFO, \"INFO: \" __VA_ARGS__)\n#define FIO_LOG_WARNING(...)                                                   \\\n  FIO_LOG_PRINT(FIO_LOG_LEVEL_WARNING, \"WARNING: \" __VA_ARGS__)\n#define FIO_LOG_ERROR(...)                                                     \\\n  FIO_LOG_PRINT(FIO_LOG_LEVEL_ERROR, \"ERROR: \" __VA_ARGS__)\n#define FIO_LOG_FATAL(...)                                                     \\\n  FIO_LOG_PRINT(FIO_LOG_LEVEL_FATAL, \"FATAL: \" __VA_ARGS__)\n#endif\n\n#if FIO_PRINT_STATE\n#define FIO_LOG_STATE(...)                                                     \\\n  FIO_LOG_PRINT(FIO_LOG_LEVEL_INFO,                                            \\\n                \"WARNING: FIO_LOG_STATE is deprecated\\n\" __VA_ARGS__)\n#else\n#define FIO_LOG_STATE(...)\n#endif\n\n#define FIO_ASSERT(cond, ...)                                                  \\\n  if (!(cond)) {                                                               \\\n    FIO_LOG_FATAL(\"(\" __FILE__ \":\" FIO_MACRO2STR(__LINE__) \") \"__VA_ARGS__);   \\\n    perror(\"     errno\");                                                      \\\n    exit(-1);                                                                  \\\n  }\n\n#ifndef FIO_ASSERT_ALLOC\n/** Tests for an allocation failure. The behavior can be overridden. */\n#define FIO_ASSERT_ALLOC(ptr)                                                  \\\n  if (!(ptr)) {                                                                \\\n    FIO_LOG_FATAL(\"memory allocation error \"__FILE__                           \\\n                  \":\" FIO_MACRO2STR(__LINE__));                                \\\n    kill(0, SIGINT);                                                           \\\n    exit(errno);                                                               \\\n  }\n#endif\n\n#if DEBUG\n#define FIO_ASSERT_DEBUG(cond, ...)                                            \\\n  if (!(cond)) {                                                               \\\n    FIO_LOG_DEBUG(__VA_ARGS__);                                                \\\n    perror(\"     errno\");                                                      \\\n    exit(-1);                                                                  \\\n  }\n#else\n#define FIO_ASSERT_DEBUG(...)\n#endif\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n\n\n\n\n\nConnection Callback (Protocol) Management\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\ntypedef struct fio_protocol_s fio_protocol_s;\n/**************************************************************************/ /**\n* The Protocol\n\nThe Protocol struct defines the callbacks used for the connection and sets it's\nbehaviour. The Protocol struct is part of facil.io's core design.\n\nFor concurrency reasons, a protocol instance SHOULD be unique to each\nconnections. Different connections shouldn't share a single protocol object\n(callbacks and data can obviously be shared).\n\nAll the callbacks receive a unique connection ID (a localized UUID) that can be\nconverted to the original file descriptor when in need.\n\nThis allows facil.io to prevent old connection handles from sending data\nto new connections after a file descriptor is \"recycled\" by the OS.\n*/\nstruct fio_protocol_s {\n  /** Called when a data is available, but will not run concurrently */\n  void (*on_data)(intptr_t uuid, fio_protocol_s *protocol);\n  /** called once all pending `fio_write` calls are finished. */\n  void (*on_ready)(intptr_t uuid, fio_protocol_s *protocol);\n  /**\n   * Called when the server is shutting down, immediately before closing the\n   * connection.\n   *\n   * The callback runs within a {FIO_PR_LOCK_TASK} lock, so it will never run\n   * concurrently with {on_data} or other connection specific tasks.\n   *\n   * The `on_shutdown` callback should return 0 to close the socket or a number\n   * between 1..254 to delay the socket closure by that amount of time.\n   *\n   * Once the socket wass marked for closure, facil.io will allow 8 seconds for\n   * all the data to be sent before forcfully closing the socket (regardless of\n   * state).\n   *\n   * If the `on_shutdown` returns 255, the socket is ignored and it will be\n   * abruptly terminated when all other sockets have finished their graceful\n   * shutdown procedure.\n   */\n  uint8_t (*on_shutdown)(intptr_t uuid, fio_protocol_s *protocol);\n  /** Called when the connection was closed, but will not run concurrently */\n  void (*on_close)(intptr_t uuid, fio_protocol_s *protocol);\n  /** called when a connection's timeout was reached */\n  void (*ping)(intptr_t uuid, fio_protocol_s *protocol);\n  /** private metadata used by facil. */\n  size_t rsv;\n};\n\n/**\n * Attaches (or updates) a protocol object to a socket UUID.\n *\n * The new protocol object can be NULL, which will detach (\"hijack\"), the\n * socket .\n *\n * The old protocol's `on_close` (if any) will be scheduled.\n *\n * On error, the new protocol's `on_close` callback will be called immediately.\n */\nvoid fio_attach(intptr_t uuid, fio_protocol_s *protocol);\n\n/**\n * Attaches (or updates) a protocol object to a file descriptor (fd).\n *\n * The new protocol object can be NULL, which will detach (\"hijack\"), the\n * socket and the `fd` can be one created outside of facil.io.\n *\n * The old protocol's `on_close` (if any) will be scheduled.\n *\n * On error, the new protocol's `on_close` callback will be called immediately.\n *\n * NOTE: before attaching a file descriptor that was created outside of\n * facil.io's library, make sure it is set to non-blocking mode (see\n * `fio_set_non_block`). facil.io file descriptors are all non-blocking and it\n * will assumes this is the case for the attached fd.\n */\nvoid fio_attach_fd(int fd, fio_protocol_s *protocol);\n\n/**\n * Sets a socket to non blocking state.\n *\n * This will also set the O_CLOEXEC flag for the file descriptor.\n *\n * This function is called automatically for the new socket, when using\n * `fio_accept` or `fio_connect`.\n */\nint fio_set_non_block(int fd);\n\n/**\n * Returns the maximum number of open files facil.io can handle per worker\n * process.\n *\n * Total OS limits might apply as well but aren't shown.\n *\n * The value of 0 indicates either that the facil.io library wasn't initialized\n * yet or that it's resources were released.\n */\nsize_t fio_capa(void);\n\n/** Sets a timeout for a specific connection (only when running and valid). */\nvoid fio_timeout_set(intptr_t uuid, uint8_t timeout);\n\n/** Gets a timeout for a specific connection. Returns 0 if none. */\nuint8_t fio_timeout_get(intptr_t uuid);\n\n/**\n * \"Touches\" a socket connection, resetting it's timeout counter.\n */\nvoid fio_touch(intptr_t uuid);\n\nenum fio_io_event {\n  FIO_EVENT_ON_DATA,\n  FIO_EVENT_ON_READY,\n  FIO_EVENT_ON_TIMEOUT\n};\n/** Schedules an IO event, even if it did not occur. */\nvoid fio_force_event(intptr_t uuid, enum fio_io_event);\n\n/**\n * Temporarily prevents `on_data` events from firing.\n *\n * The `on_data` event will be automatically rescheduled when (if) the socket's\n * outgoing buffer fills up or when `fio_force_event` is called with\n * `FIO_EVENT_ON_DATA`.\n *\n * Note: the function will work as expected when called within the protocol's\n * `on_data` callback and the `uuid` refers to a valid socket. Otherwise the\n * function might quietly fail.\n */\nvoid fio_suspend(intptr_t uuid);\n\n/* *****************************************************************************\nListening to Incoming Connections\n***************************************************************************** */\n\n/* Arguments for the fio_listen function */\nstruct fio_listen_args {\n  /**\n   * Called whenever a new connection is accepted.\n   *\n   * Should either call `fio_attach` or close the connection.\n   */\n  void (*on_open)(intptr_t uuid, void *udata);\n  /** The network service / port. Defaults to \"3000\". */\n  const char *port;\n  /** The socket binding address. Defaults to the recommended NULL. */\n  const char *address;\n  /** a pointer to a `fio_tls_s` object, for SSL/TLS support (fio_tls.h). */\n  void *tls;\n  /** Opaque user data. */\n  void *udata;\n  /**\n   * Called when the server starts (or a worker process is respawned), allowing\n   * for further initialization, such as timed event scheduling or VM\n   * initialization.\n   *\n   * This will be called separately for every worker process whenever it is\n   * spawned.\n   */\n  void (*on_start)(intptr_t uuid, void *udata);\n  /**\n   * Called when the server is done, usable for cleanup.\n   *\n   * This will be called separately for every process. */\n  void (*on_finish)(intptr_t uuid, void *udata);\n};\n\n/**\n * Sets up a network service on a listening socket.\n *\n * Returns the listening socket's uuid or -1 (on error).\n *\n * See the `fio_listen` Macro for details.\n */\nintptr_t fio_listen(struct fio_listen_args args);\n\n/************************************************************************ */ /**\nListening to Incoming Connections\n===\n\nListening to incoming connections is pretty straight forward.\n\nAfter a new connection is accepted, the `on_open` callback is called. `on_open`\nshould allocate the new connection's protocol and call `fio_attach` to attach\nthe protocol to the connection's uuid.\n\nThe protocol's `on_close` callback is expected to handle any cleanup required.\n\nThe following is an example echo server using facil.io:\n\n```c\n#include <fio.h>\n\n// A callback to be called whenever data is available on the socket\nstatic void echo_on_data(intptr_t uuid, fio_protocol_s *prt) {\n  (void)prt; // we can ignore the unused argument\n  // echo buffer\n  char buffer[1024] = {'E', 'c', 'h', 'o', ':', ' '};\n  ssize_t len;\n  // Read to the buffer, starting after the \"Echo: \"\n  while ((len = fio_read(uuid, buffer + 6, 1018)) > 0) {\n    fprintf(stderr, \"Read: %.*s\", (int)len, buffer + 6);\n    // Write back the message\n    fio_write(uuid, buffer, len + 6);\n    // Handle goodbye\n    if ((buffer[6] | 32) == 'b' && (buffer[7] | 32) == 'y' &&\n        (buffer[8] | 32) == 'e') {\n      fio_write(uuid, \"Goodbye.\\n\", 9);\n      fio_close(uuid);\n      return;\n    }\n  }\n}\n\n// A callback called whenever a timeout is reach\nstatic void echo_ping(intptr_t uuid, fio_protocol_s *prt) {\n  (void)prt; // we can ignore the unused argument\n  fio_write(uuid, \"Server: Are you there?\\n\", 23);\n}\n\n// A callback called if the server is shutting down...\n// ... while the connection is still open\nstatic uint8_t echo_on_shutdown(intptr_t uuid, fio_protocol_s *prt) {\n  (void)prt; // we can ignore the unused argument\n  fio_write(uuid, \"Echo server shutting down\\nGoodbye.\\n\", 35);\n  return 0;\n}\n\nstatic void echo_on_close(intptr_t uuid, fio_protocol_s *proto) {\n  fprintf(stderr, \"Connection %p closed.\\n\", (void *)proto);\n  free(proto);\n  (void)uuid;\n}\n\n// A callback called for new connections\nstatic void echo_on_open(intptr_t uuid, void *udata) {\n  (void)udata; // ignore this\n  // Protocol objects MUST be dynamically allocated when multi-threading.\n  fio_protocol_s *echo_proto = malloc(sizeof(*echo_proto));\n  *echo_proto = (fio_protocol_s){.service = \"echo\",\n                                 .on_data = echo_on_data,\n                                 .on_shutdown = echo_on_shutdown,\n                                 .on_close = echo_on_close,\n                                 .ping = echo_ping};\n  fprintf(stderr, \"New Connection %p received from %s\\n\", (void *)echo_proto,\n          fio_peer_addr(uuid).data);\n  fio_attach(uuid, echo_proto);\n  fio_write2(uuid, .data.buffer = \"Echo Service: Welcome\\n\", .length = 22,\n             .after.dealloc = FIO_DEALLOC_NOOP);\n  fio_timeout_set(uuid, 5);\n}\n\nint main() {\n  // Setup a listening socket\n  if (fio_listen(.port = \"3000\", .on_open = echo_on_open) == -1) {\n    perror(\"No listening socket available on port 3000\");\n    exit(-1);\n  }\n  // Run the server and hang until a stop signal is received.\n  fio_start(.threads = 4, .workers = 1);\n}\n```\n*/\n#define fio_listen(...) fio_listen((struct fio_listen_args){__VA_ARGS__})\n\n/* *****************************************************************************\nConnecting to remote servers as a client\n***************************************************************************** */\n\n/**\nNamed arguments for the `fio_connect` function, that allows non-blocking\nconnections to be established.\n*/\nstruct fio_connect_args {\n  /** The address of the server we are connecting to. */\n  const char *address;\n  /** The port on the server we are connecting to. */\n  const char *port;\n  /**\n   * The `on_connect` callback either call `fio_attach` or close the connection.\n   */\n  void (*on_connect)(intptr_t uuid, void *udata);\n  /**\n   * The `on_fail` is called when a socket fails to connect. The old sock UUID\n   * is passed along.\n   */\n  void (*on_fail)(intptr_t uuid, void *udata);\n  /** a pointer to a `fio_tls_s` object, for SSL/TLS support (fio_tls.h). */\n  void *tls;\n  /** Opaque user data. */\n  void *udata;\n  /** A non-system timeout after which connection is assumed to have failed. */\n  uint8_t timeout;\n};\n\n/**\nCreates a client connection (in addition or instead of the server).\n\nSee the `struct fio_connect_args` details for any possible named arguments.\n\n* `.address` should be the address of the server.\n\n* `.port` the server's port.\n\n* `.udata`opaque user data.\n\n* `.on_connect` called once a connection was established.\n\n    Should return a pointer to a `fio_protocol_s` object, to handle connection\n    callbacks.\n\n* `.on_fail` called if a connection failed to establish.\n\n(experimental: untested)\n*/\nintptr_t fio_connect(struct fio_connect_args);\n#define fio_connect(...) fio_connect((struct fio_connect_args){__VA_ARGS__})\n\n/* *****************************************************************************\nURL address parsing\n***************************************************************************** */\n\n/** the result returned by `fio_url_parse` */\ntypedef struct {\n  fio_str_info_s scheme;\n  fio_str_info_s user;\n  fio_str_info_s password;\n  fio_str_info_s host;\n  fio_str_info_s port;\n  fio_str_info_s path;\n  fio_str_info_s query;\n  fio_str_info_s target;\n} fio_url_s;\n\n/**\n * Parses the URI returning it's components and their lengths (no decoding\n * performed, doesn't accept decoded URIs).\n *\n * The returned string are NOT NUL terminated, they are merely locations within\n * the original string.\n *\n * This function attempts to accept many different formats, including any of the\n * following:\n *\n * * `/complete_path?query#target`\n *\n *   i.e.: /index.html?page=1#list\n *\n * * `host:port/complete_path?query#target`\n *\n *   i.e.:\n *      example.com\n *      example.com:8080\n *      example.com/index.html\n *      example.com:8080/index.html\n *      example.com:8080/index.html?key=val#target\n *\n * * `user:password@host:port/path?query#target`\n *\n *   i.e.: user:1234@example.com:8080/index.html\n *\n * * `username[:password]@host[:port][...]`\n *\n *   i.e.: john:1234@example.com\n *\n * * `schema://user:password@host:port/path?query#target`\n *\n *   i.e.: http://example.com/index.html?page=1#list\n *\n * Invalid formats might produce unexpected results. No error testing performed.\n */\nfio_url_s fio_url_parse(const char *url, size_t length);\n/* *****************************************************************************\nStarting the IO reactor and reviewing it's state\n***************************************************************************** */\n\nstruct fio_start_args {\n  /**\n   * The number of threads to run in the thread pool. Has \"smart\" defaults.\n   *\n   *\n   * A positive value will indicate a set number of threads (or workers).\n   *\n   * Zeros and negative values are fun and include an interesting shorthand:\n   *\n   * * Negative values indicate a fraction of the number of CPU cores. i.e.\n   *   -2 will normally indicate \"half\" (1/2) the number of cores.\n   *\n   * * If the other option (i.e. `.workers` when setting `.threads`) is zero,\n   *   it will be automatically updated to reflect the option's absolute value.\n   *   i.e.:\n   *   if .threads == -2 and .workers == 0,\n   *   than facil.io will run 2 worker processes with (cores/2) threads per\n   *   process.\n   */\n  int16_t threads;\n  /** The number of worker processes to run. See `threads`. */\n  int16_t workers;\n};\n\n/**\n * Starts the facil.io event loop. This function will return after facil.io is\n * done (after shutdown).\n *\n * See the `struct fio_start_args` details for any possible named arguments.\n *\n * This method blocks the current thread until the server is stopped (when a\n * SIGINT/SIGTERM is received).\n */\nvoid fio_start(struct fio_start_args args);\n#define fio_start(...) fio_start((struct fio_start_args){__VA_ARGS__})\n\n/**\n * Attempts to stop the facil.io application. This only works within the Root\n * process. A worker process will simply respawn itself.\n */\nvoid fio_stop(void);\n\n/**\n * Returns the number of expected threads / processes to be used by facil.io.\n *\n * The pointers should start with valid values that match the expected threads /\n * processes values passed to `fio_start`.\n *\n * The data in the pointers will be overwritten with the result.\n */\nvoid fio_expected_concurrency(int16_t *threads, int16_t *workers);\n\n/**\n * Returns the number of worker processes if facil.io is running.\n *\n * (1 is returned when in single process mode, otherwise the number of workers)\n */\nint16_t fio_is_running(void);\n\n/**\n * Returns 1 if the current process is a worker process or a single process.\n *\n * Otherwise returns 0.\n *\n * NOTE: When cluster mode is off, the root process is also the worker process.\n *       This means that single process instances don't automatically respawn\n *       after critical errors.\n */\nint fio_is_worker(void);\n\n/**\n * Returns 1 if the current process is the master (root) process.\n *\n * Otherwise returns 0.\n */\nint fio_is_master(void);\n\n/** Returns facil.io's parent (root) process pid. */\npid_t fio_parent_pid(void);\n\n/**\n * Initializes zombie reaping for the process. Call before `fio_start` to enable\n * global zombie reaping.\n */\nvoid fio_reap_children(void);\n\n/**\n * Resets any existing signal handlers, restoring their state to before they\n * were set by facil.io.\n *\n * This stops both child reaping (`fio_reap_children`) and the default facil.io\n * signal handlers (i.e., CTRL-C).\n *\n * This function will be called automatically by facil.io whenever facil.io\n * stops.\n */\nvoid fio_signal_handler_reset(void);\n\n/**\n * Returns the last time the server reviewed any pending IO events.\n */\nstruct timespec fio_last_tick(void);\n\n/**\n * Returns a C string detailing the IO engine selected during compilation.\n *\n * Valid values are \"kqueue\", \"epoll\" and \"poll\".\n */\nchar const *fio_engine(void);\n\n/* *****************************************************************************\nSocket / Connection Functions\n***************************************************************************** */\n\n/**\n * Creates a Unix or a TCP/IP socket and returns it's unique identifier.\n *\n * For TCP/IP server sockets (`is_server` is `1`), a NULL `address` variable is\n * recommended. Use \"localhost\" or \"127.0.0.1\" to limit access to the server\n * application.\n *\n * For TCP/IP client sockets (`is_server` is `0`), a remote `address` and `port`\n * combination will be required\n *\n * For Unix server or client sockets, set the `port` variable to NULL or `0`.\n *\n * Returns -1 on error. Any other value is a valid unique identifier.\n *\n * Note: facil.io uses unique identifiers to protect sockets from collisions.\n *       However these identifiers can be converted to the underlying file\n *       descriptor using the `fio_uuid2fd` macro.\n */\nintptr_t fio_socket(const char *address, const char *port, uint8_t is_server);\n\n/**\n * `fio_accept` accepts a new socket connection from a server socket - see the\n * server flag on `fio_socket`.\n *\n * Accepted connection are automatically set to non-blocking mode and the\n * O_CLOEXEC flag is set.\n *\n * NOTE: this function does NOT attach the socket to the IO reactor - see\n * `fio_attach`.\n */\nintptr_t fio_accept(intptr_t srv_uuid);\n\n/**\n * Returns 1 if the uuid refers to a valid and open, socket.\n *\n * Returns 0 if not.\n */\nint fio_is_valid(intptr_t uuid);\n\n/**\n * Returns 1 if the uuid is invalid or the socket is flagged to be closed.\n *\n * Returns 0 if the socket is valid, open and isn't flagged to be closed.\n */\nint fio_is_closed(intptr_t uuid);\n\n/**\n * `fio_close` marks the connection for disconnection once all the data was\n * sent. The actual disconnection will be managed by the `fio_flush` function.\n *\n * `fio_flash` will be automatically scheduled.\n */\nvoid fio_close(intptr_t uuid);\n\n/**\n * `fio_force_close` closes the connection immediately, without adhering to any\n * protocol restrictions and without sending any remaining data in the\n * connection buffer.\n */\nvoid fio_force_close(intptr_t uuid);\n\n/**\n * Returns the information available about the socket's peer address.\n *\n * If no information is available, the struct will be initialized with zero\n * (`addr == NULL`).\n * The information is only available when the socket was accepted using\n * `fio_accept` or opened using `fio_connect`.\n */\nfio_str_info_s fio_peer_addr(intptr_t uuid);\n\n/**\n * Writes the local machine address (qualified host name) to the buffer.\n *\n * Returns the amount of data written (excluding the NUL byte).\n *\n * `limit` is the maximum number of bytes in the buffer, including the NUL byte.\n *\n * If the returned value == limit - 1, the result might have been truncated.\n *\n * If 0 is returned, an erro might have occured (see `errno`) and the contents\n * of `dest` is undefined.\n */\nsize_t fio_local_addr(char *dest, size_t limit);\n\n/**\n * `fio_read` attempts to read up to count bytes from the socket into the\n * buffer starting at `buffer`.\n *\n * `fio_read`'s return values are wildly different then the native return\n * values and they aim at making far simpler sense.\n *\n * `fio_read` returns the number of bytes read (0 is a valid return value which\n * simply means that no bytes were read from the buffer).\n *\n * On a fatal connection error that leads to the connection being closed (or if\n * the connection is already closed), `fio_read` returns -1.\n *\n * The value 0 is the valid value indicating no data was read.\n *\n * Data might be available in the kernel's buffer while it is not available to\n * be read using `fio_read` (i.e., when using a transport layer, such as TLS).\n */\nssize_t fio_read(intptr_t uuid, void *buffer, size_t count);\n\n/** The following structure is used for `fio_write2_fn` function arguments. */\ntypedef struct {\n  union {\n    /** The in-memory data to be sent. */\n    const void *buffer;\n    /** The data to be sent, if this is a file. */\n    const intptr_t fd;\n  } data;\n  union {\n    /**\n     * This deallocation callback will be called when the packet is finished\n     * with the buffer.\n     *\n     * If no deallocation callback is set, `free` (or `close`) will be used.\n     *\n     * Note: socket library functions MUST NEVER be called by a callback, or a\n     * deadlock might occur.\n     */\n    void (*dealloc)(void *buffer);\n    /**\n     * This is an alternative deallocation callback accessor (same memory space\n     * as `dealloc`) for conveniently setting the file `close` callback.\n     *\n     * Note: `sock` library functions MUST NEVER be called by a callback, or a\n     * deadlock might occur.\n     */\n    void (*close)(intptr_t fd);\n  } after;\n  /** The length (size) of the buffer, or the amount of data to be sent from the\n   * file descriptor.\n   */\n  uintptr_t length;\n  /** Starting point offset from the buffer or file descriptor's beginning. */\n  uintptr_t offset;\n  /** The packet will be sent as soon as possible. */\n  unsigned urgent : 1;\n  /**\n   * The data union contains the value of a file descriptor (`int`). i.e.:\n   *  `.data.fd = fd` or `.data.buffer = (void*)fd;`\n   */\n  unsigned is_fd : 1;\n  /** for internal use */\n  unsigned rsv : 1;\n  /** for internal use */\n  unsigned rsv2 : 1;\n} fio_write_args_s;\n\n/**\n * `fio_write2_fn` is the actual function behind the macro `fio_write2`.\n */\nssize_t fio_write2_fn(intptr_t uuid, fio_write_args_s options);\n\n/**\n * Schedules data to be written to the socket.\n *\n * `fio_write2` is similar to `fio_write`, except that it allows far more\n * flexibility.\n *\n * On error, -1 will be returned. Otherwise returns 0.\n *\n * See the `fio_write_args_s` structure for details.\n *\n * NOTE: The data is \"moved\" to the ownership of the socket, not copied. The\n * data will be deallocated according to the `.after.dealloc` function.\n */\n#define fio_write2(uuid, ...)                                                  \\\n  fio_write2_fn(uuid, (fio_write_args_s){__VA_ARGS__})\n\n/** A noop function for fio_write2 in cases not deallocation is required. */\nvoid FIO_DEALLOC_NOOP(void *arg);\n#define FIO_CLOSE_NOOP ((void (*)(intptr_t))FIO_DEALLOC_NOOP)\n\n/**\n * `fio_write` copies `legnth` data from the buffer and schedules the data to\n * be sent over the socket.\n *\n * The data isn't necessarily written to the socket. The actual writing to the\n * socket is handled by the IO reactor.\n *\n * On error, -1 will be returned. Otherwise returns 0.\n *\n * Returns the same values as `fio_write2`.\n */\n// ssize_t fio_write(uintptr_t uuid, void *buffer, size_t legnth);\ninline FIO_FUNC ssize_t fio_write(const intptr_t uuid, const void *buffer,\n                                  const size_t length) {\n  if (!length || !buffer)\n    return 0;\n  void *cpy = fio_malloc(length);\n  if (!cpy)\n    return -1;\n  memcpy(cpy, buffer, length);\n  return fio_write2(uuid, .data.buffer = cpy, .length = length,\n                    .after.dealloc = fio_free);\n}\n\n/**\n * Sends data from a file as if it were a single atomic packet (sends up to\n * length bytes or until EOF is reached).\n *\n * Once the file was sent, the `source_fd` will be closed using `close`.\n *\n * The file will be buffered to the socket chunk by chunk, so that memory\n * consumption is capped. The system's `sendfile` might be used if conditions\n * permit.\n *\n * `offset` dictates the starting point for the data to be sent and length sets\n * the maximum amount of data to be sent.\n *\n * Returns -1 and closes the file on error. Returns 0 on success.\n */\ninline FIO_FUNC ssize_t fio_sendfile(intptr_t uuid, intptr_t source_fd,\n                                     off_t offset, size_t length) {\n  return fio_write2(uuid, .data.fd = source_fd, .length = length, .is_fd = 1,\n                    .offset = offset);\n}\n\n/**\n * Returns the number of `fio_write` calls that are waiting in the socket's\n * queue and haven't been processed.\n */\nsize_t fio_pending(intptr_t uuid);\n\n/**\n * `fio_flush` attempts to write any remaining data in the internal buffer to\n * the underlying file descriptor and closes the underlying file descriptor once\n * if it's marked for closure (and all the data was sent).\n *\n * Return values: 1 will be returned if data remains in the buffer. 0\n * will be returned if the buffer was fully drained. -1 will be returned on an\n * error or when the connection is closed.\n *\n * errno will be set to EWOULDBLOCK if the socket's lock is busy.\n */\nssize_t fio_flush(intptr_t uuid);\n\n/** Blocks until all the data was flushed from the buffer */\n#define fio_flush_strong(uuid)                                                 \\\n  do {                                                                         \\\n    errno = 0;                                                                 \\\n  } while (fio_flush(uuid) > 0 || errno == EWOULDBLOCK)\n\n/**\n * `fio_flush_all` attempts flush all the open connections.\n *\n * Returns the number of sockets still in need to be flushed.\n */\nsize_t fio_flush_all(void);\n\n/**\n * Convert between a facil.io connection's identifier (uuid) and system's fd.\n */\n#define fio_uuid2fd(uuid) ((int)((uintptr_t)uuid >> 8))\n\n/**\n * `fio_fd2uuid` takes an existing file decriptor `fd` and returns it's active\n * `uuid`.\n *\n * If the file descriptor was closed, __it will be registered as open__.\n *\n * If the file descriptor was closed directly (not using `fio_close`) or the\n * closure event hadn't been processed, a false positive will be possible. This\n * is not an issue, since the use of an invalid fd will result in the registry\n * being updated and the fd being closed.\n *\n * Returns -1 on error. Returns a valid socket (non-random) UUID.\n */\nintptr_t fio_fd2uuid(int fd);\n\n/**\n * `fio_fd2uuid` takes an existing file decriptor `fd` and returns it's active\n * `uuid`.\n *\n * If the file descriptor is marked as closed (wasn't opened / registered with\n * facil.io) the function returns -1;\n *\n * If the file descriptor was closed directly (not using `fio_close`) or the\n * closure event hadn't been processed, a false positive will be possible. This\n * is not an issue, since the use of an invalid fd will result in the registry\n * being updated and the fd being closed.\n *\n * Returns -1 on error. Returns a valid socket (non-random) UUID.\n */\nintptr_t fio_fd2uuid(int fd);\n\n/* *****************************************************************************\nConnection Object Links\n***************************************************************************** */\n\n/**\n * Links an object to a connection's lifetime, calling the `on_close` callback\n * once the connection has died.\n *\n * If the `uuid` is invalid, the `on_close` callback will be called immediately.\n *\n * NOTE: the `on_close` callback will be called with high priority. Long tasks\n * should be deferred.\n */\nvoid fio_uuid_link(intptr_t uuid, void *obj, void (*on_close)(void *obj));\n\n/**\n * Un-links an object from the connection's lifetime, so it's `on_close`\n * callback will NOT be called.\n *\n * Returns 0 on success and -1 if the object couldn't be found, setting `errno`\n * to `EBADF` if the `uuid` was invalid and `ENOTCONN` if the object wasn't\n * found (wasn't linked).\n *\n * NOTICE: a failure likely means that the object's `on_close` callback was\n * already called!\n */\nint fio_uuid_unlink(intptr_t uuid, void *obj);\n\n/* *****************************************************************************\nConnection Read / Write Hooks, for overriding the system calls\n***************************************************************************** */\n\n/**\n * The following struct is used for setting a the read/write hooks that will\n * replace the default system calls to `recv` and `write`.\n *\n * Note: facil.io library functions MUST NEVER be called by any r/w hook, or a\n * deadlock might occur.\n */\ntypedef struct fio_rw_hook_s {\n  /**\n   * Implement reading from a file descriptor. Should behave like the file\n   * system `read` call, including the setup or errno to EAGAIN / EWOULDBLOCK.\n   *\n   * Note: facil.io library functions MUST NEVER be called by any r/w hook, or a\n   * deadlock might occur.\n   */\n  ssize_t (*read)(intptr_t uuid, void *udata, void *buf, size_t count);\n  /**\n   * Implement writing to a file descriptor. Should behave like the file system\n   * `write` call.\n   *\n   * If an internal buffer is implemented and it is full, errno should be set to\n   * EWOULDBLOCK and the function should return -1.\n   *\n   * The function is expected to call the `flush` callback (or it's logic)\n   * internally. Either `write` OR `flush` are called.\n   *\n   * Note: facil.io library functions MUST NEVER be called by any r/w hook, or a\n   * deadlock might occur.\n   */\n  ssize_t (*write)(intptr_t uuid, void *udata, const void *buf, size_t count);\n  /**\n   * When implemented, this function will be called to flush any data remaining\n   * in the internal buffer.\n   *\n   * The function should return the number of bytes remaining in the internal\n   * buffer (0 is a valid response) or -1 (on error).\n   *\n   * Note: facil.io library functions MUST NEVER be called by any r/w hook, or a\n   * deadlock might occur.\n   */\n  ssize_t (*flush)(intptr_t uuid, void *udata);\n  /**\n   * The `before_close` callback is called only once before closing the `uuid`\n   * and it might not get called at all if an abnormal closure is detected.\n   *\n   * If the function returns a non-zero value, than closure will be delayed\n   * until the `flush` returns 0 (or less). This allows a closure signal to be\n   * sent by the read/write hook when such a signal is required.\n   *\n   * Note: facil.io library functions MUST NEVER be called by any r/w hook, or a\n   * deadlock might occur.\n   * */\n  ssize_t (*before_close)(intptr_t uuid, void *udata);\n  /**\n   * Called to perform cleanup after the socket was closed or a new read/write\n   * hook was set using `fio_rw_hook_set`.\n   *\n   * This callback is always called, even if `fio_rw_hook_set` fails.\n   * */\n  void (*cleanup)(void *udata);\n} fio_rw_hook_s;\n\n/** Sets a socket hook state (a pointer to the struct). */\nint fio_rw_hook_set(intptr_t uuid, fio_rw_hook_s *rw_hooks, void *udata);\n\n/**\n * Replaces an existing read/write hook with another from within a read/write\n * hook callback.\n *\n * Does NOT call any cleanup callbacks.\n *\n * Replaces existing udata. Call with the existing udata to keep it.\n *\n * Returns -1 on error, 0 on success.\n *\n * Note: this function is marked as unsafe, since it should only be called from\n *       within an existing read/write hook callback. Otherwise, data corruption\n *       might occur.\n */\nint fio_rw_hook_replace_unsafe(intptr_t uuid, fio_rw_hook_s *rw_hooks,\n                               void *udata);\n\n/** The default Read/Write hooks used for system Read/Write (udata == NULL). */\nextern const fio_rw_hook_s FIO_DEFAULT_RW_HOOKS;\n\n/* *****************************************************************************\nConcurrency overridable functions\n\nThese functions can be overridden so as to adjust for different environments.\n***************************************************************************** */\n\n/**\nOVERRIDE THIS to replace the default `fork` implementation.\n\nBehaves like the system's `fork`.\n*/\nint fio_fork(void);\n\n/**\n * OVERRIDE THIS to replace the default pthread implementation.\n *\n * Accepts a pointer to a function and a single argument that should be executed\n * within a new thread.\n *\n * The function should allocate memory for the thread object and return a\n * pointer to the allocated memory that identifies the thread.\n *\n * On error NULL should be returned.\n */\nvoid *fio_thread_new(void *(*thread_func)(void *), void *arg);\n\n/**\n * OVERRIDE THIS to replace the default pthread implementation.\n *\n * Frees the memory associated with a thread identifier (allows the thread to\n * run it's course, just the identifier is freed).\n */\nvoid fio_thread_free(void *p_thr);\n\n/**\n * OVERRIDE THIS to replace the default pthread implementation.\n *\n * Accepts a pointer returned from `fio_thread_new` (should also free any\n * allocated memory) and joins the associated thread.\n *\n * Return value is ignored.\n */\nint fio_thread_join(void *p_thr);\n\n/* *****************************************************************************\nConnection Task scheduling\n***************************************************************************** */\n\n/**\n * This is used to lock the protocol againste concurrency collisions and\n * concurrent memory deallocation.\n *\n * However, there are three levels of protection that allow non-coliding tasks\n * to protect the protocol object from being deallocated while in use:\n *\n * * `FIO_PR_LOCK_TASK` - a task lock locks might change data owned by the\n *    protocol object. This task is used for tasks such as `on_data`.\n *\n * * `FIO_PR_LOCK_WRITE` - a lock that promises only to use static data (data\n *    that tasks never changes) in order to write to the underlying socket.\n *    This lock is used for tasks such as `on_ready` and `ping`\n *\n * * `FIO_PR_LOCK_STATE` - a lock that promises only to retrieve static data\n *    (data that tasks never changes), performing no actions. This usually\n *    isn't used for client side code (used internally by facil) and is only\n *     meant for very short locks.\n */\nenum fio_protocol_lock_e {\n  FIO_PR_LOCK_TASK = 0,\n  FIO_PR_LOCK_WRITE = 1,\n  FIO_PR_LOCK_STATE = 2\n};\n\n/** Named arguments for the `fio_defer` function. */\ntypedef struct {\n  /** The type of task to be performed. Defaults to `FIO_PR_LOCK_TASK` but could\n   * also be seto to `FIO_PR_LOCK_WRITE`. */\n  enum fio_protocol_lock_e type;\n  /** The task (function) to be performed. This is required. */\n  void (*task)(intptr_t uuid, fio_protocol_s *, void *udata);\n  /** An opaque user data that will be passed along to the task. */\n  void *udata;\n  /** A fallback task, in case the connection was lost. Good for cleanup. */\n  void (*fallback)(intptr_t uuid, void *udata);\n} fio_defer_iotask_args_s;\n\n/**\n * Schedules a protected connection task. The task will run within the\n * connection's lock.\n *\n * If an error ocuurs or the connection is closed before the task can run, the\n * `fallback` task wil be called instead, allowing for resource cleanup.\n */\nvoid fio_defer_io_task(intptr_t uuid, fio_defer_iotask_args_s args);\n#define fio_defer_io_task(uuid, ...)                                           \\\n  fio_defer_io_task((uuid), (fio_defer_iotask_args_s){__VA_ARGS__})\n\n/* *****************************************************************************\nEvent / Task scheduling\n***************************************************************************** */\n\n/**\n * Defers a task's execution.\n *\n * Tasks are functions of the type `void task(void *, void *)`, they return\n * nothing (void) and accept two opaque `void *` pointers, user-data 1\n * (`udata1`) and user-data 2 (`udata2`).\n *\n * Returns -1 or error, 0 on success.\n */\nint fio_defer(void (*task)(void *, void *), void *udata1, void *udata2);\n\n/**\n * Creates a timer to run a task at the specified interval.\n *\n * The task will repeat `repetitions` times. If `repetitions` is set to 0, task\n * will repeat forever.\n *\n * Returns -1 on error.\n *\n * The `on_finish` handler is always called (even on error).\n */\nint fio_run_every(size_t milliseconds, size_t repetitions, void (*task)(void *),\n                  void *arg, void (*on_finish)(void *));\n\n/**\n * Performs all deferred tasks.\n */\nvoid fio_defer_perform(void);\n\n/** Returns true if there are deferred functions waiting for execution. */\nint fio_defer_has_queue(void);\n\n/* *****************************************************************************\nStartup / State Callbacks (fork, start up, idle, etc')\n***************************************************************************** */\n\n/** a callback type signifier */\ntypedef enum {\n  /** Called once during library initialization. */\n  FIO_CALL_ON_INITIALIZE,\n  /** Called once before starting up the IO reactor. */\n  FIO_CALL_PRE_START,\n  /** Called before each time the IO reactor forks a new worker. */\n  FIO_CALL_BEFORE_FORK,\n  /** Called after each fork (both in parent and workers). */\n  FIO_CALL_AFTER_FORK,\n  /** Called by a worker process right after forking. */\n  FIO_CALL_IN_CHILD,\n  /** Called by the master process after spawning a worker (after forking). */\n  FIO_CALL_IN_MASTER,\n  /** Called every time a *Worker* proceess starts. */\n  FIO_CALL_ON_START,\n  /** Called when facil.io enters idling mode. */\n  FIO_CALL_ON_IDLE,\n  /** Called before starting the shutdown sequence. */\n  FIO_CALL_ON_SHUTDOWN,\n  /** Called just before finishing up (both on chlid and parent processes). */\n  FIO_CALL_ON_FINISH,\n  /** Called by each worker the moment it detects the master process crashed. */\n  FIO_CALL_ON_PARENT_CRUSH,\n  /** Called by the parent (master) after a worker process crashed. */\n  FIO_CALL_ON_CHILD_CRUSH,\n  /** An alternative to the system's at_exit. */\n  FIO_CALL_AT_EXIT,\n  /** used for testing. */\n  FIO_CALL_NEVER\n} callback_type_e;\n\n/** Adds a callback to the list of callbacks to be called for the event. */\nvoid fio_state_callback_add(callback_type_e, void (*func)(void *), void *arg);\n\n/** Removes a callback from the list of callbacks to be called for the event. */\nint fio_state_callback_remove(callback_type_e, void (*func)(void *), void *arg);\n\n/**\n * Forces all the existing callbacks to run, as if the event occurred.\n *\n * Callbacks are called from last to first (last callback executes first).\n *\n * During an event, changes to the callback list are ignored (callbacks can't\n * remove other callbacks for the same event).\n */\nvoid fio_state_callback_force(callback_type_e);\n\n/** Clears all the existing callbacks for the event. */\nvoid fio_state_callback_clear(callback_type_e);\n\n/* *****************************************************************************\nLower Level API - for special circumstances, use with care.\n***************************************************************************** */\n\n/**\n * This function allows out-of-task access to a connection's `fio_protocol_s`\n * object by attempting to acquire a locked pointer.\n *\n * CAREFUL: mostly, the protocol object will be locked and a pointer will be\n * sent to the connection event's callback. However, if you need access to the\n * protocol object from outside a running connection task, you might need to\n * lock the protocol to prevent it from being closed / freed in the background.\n *\n * facil.io uses three different locks:\n *\n * * FIO_PR_LOCK_TASK locks the protocol for normal tasks (i.e. `on_data`,\n * `fio_defer`, `fio_every`).\n *\n * * FIO_PR_LOCK_WRITE locks the protocol for high priority `fio_write`\n * oriented tasks (i.e. `ping`, `on_ready`).\n *\n * * FIO_PR_LOCK_STATE locks the protocol for quick operations that need to copy\n * data from the protocol's data structure.\n *\n * IMPORTANT: Remember to call `fio_protocol_unlock` using the same lock type.\n *\n * Returns NULL on error (lock busy == EWOULDBLOCK, connection invalid == EBADF)\n * and a pointer to a protocol object on success.\n *\n * On error, consider calling `fio_defer` or `defer` instead of busy waiting.\n * Busy waiting SHOULD be avoided whenever possible.\n */\nfio_protocol_s *fio_protocol_try_lock(intptr_t uuid, enum fio_protocol_lock_e);\n/** Don't unlock what you don't own... see `fio_protocol_try_lock` for\n * details. */\nvoid fio_protocol_unlock(fio_protocol_s *pr, enum fio_protocol_lock_e);\n\n/* *****************************************************************************\n * Pub/Sub / Cluster Messages API\n *\n * Facil supports a message oriented API for use for Inter Process Communication\n * (IPC), publish/subscribe patterns, horizontal scaling and similar use-cases.\n *\n **************************************************************************** */\n#if FIO_PUBSUB_SUPPORT\n\n/* *****************************************************************************\n * Cluster Messages and Pub/Sub\n **************************************************************************** */\n\n/** An opaque subscription type. */\ntypedef struct subscription_s subscription_s;\n\n/** A pub/sub engine data structure. See details later on. */\ntypedef struct fio_pubsub_engine_s fio_pubsub_engine_s;\n\n/** The default engine (settable). Initial default is FIO_PUBSUB_CLUSTER. */\nextern fio_pubsub_engine_s *FIO_PUBSUB_DEFAULT;\n/** Used to publish the message to all clients in the cluster. */\n#define FIO_PUBSUB_CLUSTER ((fio_pubsub_engine_s *)1)\n/** Used to publish the message only within the current process. */\n#define FIO_PUBSUB_PROCESS ((fio_pubsub_engine_s *)2)\n/** Used to publish the message except within the current process. */\n#define FIO_PUBSUB_SIBLINGS ((fio_pubsub_engine_s *)3)\n/** Used to publish the message exclusively to the root / master process. */\n#define FIO_PUBSUB_ROOT ((fio_pubsub_engine_s *)4)\n\n/** Message structure, with an integer filter as well as a channel filter. */\ntypedef struct fio_msg_s {\n  /** A unique message type. Negative values are reserved, 0 == pub/sub. */\n  int32_t filter;\n  /**\n   * A channel name, allowing for pub/sub patterns.\n   *\n   * NOTE: the channel and msg strings should be considered immutable. The .capa\n   * field might be used for internal data.\n   */\n  fio_str_info_s channel;\n  /**\n   * The actual message.\n   *\n   * NOTE: the channel and msg strings should be considered immutable. The .capa\n   *field might be used for internal data.\n   **/\n  fio_str_info_s msg;\n  /** The `udata1` argument associated with the subscription. */\n  void *udata1;\n  /** The `udata1` argument associated with the subscription. */\n  void *udata2;\n  /** flag indicating if the message is JSON data or binary/text. */\n  uint8_t is_json;\n} fio_msg_s;\n\n/**\n * Pattern matching callback type - should return 0 unless channel matches\n * pattern.\n */\ntypedef int (*fio_match_fn)(fio_str_info_s pattern, fio_str_info_s channel);\n\nextern fio_match_fn FIO_MATCH_GLOB;\n\n/**\n * Possible arguments for the fio_subscribe method.\n *\n * NOTICE: passing protocol objects to the `udata` is not safe. This is because\n * protocol objects might be destroyed or invalidated according to both network\n * events (socket closure) and internal changes (i.e., `fio_attach` being\n * called). The preferred way is to add the `uuid` to the `udata` field and call\n * `fio_protocol_try_lock`.\n */\ntypedef struct {\n  /**\n   * If `filter` is set, all messages that match the filter's numerical value\n   * will be forwarded to the subscription's callback.\n   *\n   * Subscriptions can either require a match by filter or match by channel.\n   * This will match the subscription by filter.\n   */\n  int32_t filter;\n  /**\n   * If `channel` is set, all messages where `filter == 0` and the channel is an\n   * exact match will be forwarded to the subscription's callback.\n   *\n   * Subscriptions can either require a match by filter or match by channel.\n   * This will match the subscription by channel (only messages with no `filter`\n   * will be received.\n   */\n  fio_str_info_s channel;\n  /**\n   * The the `match` function allows pattern matching for channel names.\n   *\n   * When using a match function, the channel name is considered to be a pattern\n   * and each pub/sub message (a message where filter == 0) will be tested\n   * against that pattern.\n   *\n   * Using pattern subscriptions extensively could become a performance concern,\n   * since channel names are tested against each distinct pattern rather than\n   * leveraging a hashmap for possible name matching.\n   */\n  fio_match_fn match;\n  /**\n   * The callback will be called for each message forwarded to the subscription.\n   */\n  void (*on_message)(fio_msg_s *msg);\n  /** An optional callback for when a subscription is fully canceled. */\n  void (*on_unsubscribe)(void *udata1, void *udata2);\n  /** The udata values are ignored and made available to the callback. */\n  void *udata1;\n  /** The udata values are ignored and made available to the callback. */\n  void *udata2;\n} subscribe_args_s;\n\n/** Publishing and on_message callback arguments. */\ntypedef struct fio_publish_args_s {\n  /** The pub/sub engine that should be used to forward this message. */\n  fio_pubsub_engine_s const *engine;\n  /** A unique message type. Negative values are reserved, 0 == pub/sub. */\n  int32_t filter;\n  /** The pub/sub target channnel. */\n  fio_str_info_s channel;\n  /** The pub/sub message. */\n  fio_str_info_s message;\n  /** flag indicating if the message is JSON data or binary/text. */\n  uint8_t is_json;\n} fio_publish_args_s;\n\n/**\n * Subscribes to either a filter OR a channel (never both).\n *\n * Returns a subscription pointer on success or NULL on failure.\n *\n * See `subscribe_args_s` for details.\n */\nsubscription_s *fio_subscribe(subscribe_args_s args);\n/**\n * Subscribes to either a filter OR a channel (never both).\n *\n * Returns a subscription pointer on success or NULL on failure.\n *\n * See `subscribe_args_s` for details.\n */\n#define fio_subscribe(...) fio_subscribe((subscribe_args_s){__VA_ARGS__})\n\n/**\n * Cancels an existing subscriptions - actual effects might be delayed, for\n * example, if the subscription's callback is running in another thread.\n */\nvoid fio_unsubscribe(subscription_s *subscription);\n\n/**\n * This helper returns a temporary String with the subscription's channel (or a\n * string representing the filter).\n *\n * To keep the string beyond the lifetime of the subscription, copy the string.\n */\nfio_str_info_s fio_subscription_channel(subscription_s *subscription);\n\n/**\n * Publishes a message to the relevant subscribers (if any).\n *\n * See `fio_publish_args_s` for details.\n *\n * By default the message is sent using the FIO_PUBSUB_CLUSTER engine (all\n * processes, including the calling process).\n *\n * To limit the message only to other processes (exclude the calling process),\n * use the FIO_PUBSUB_SIBLINGS engine.\n *\n * To limit the message only to the calling process, use the\n * FIO_PUBSUB_PROCESS engine.\n *\n * To publish messages to the pub/sub layer, the `.filter` argument MUST be\n * equal to 0 or missing.\n */\nvoid fio_publish(fio_publish_args_s args);\n/**\n * Publishes a message to the relevant subscribers (if any).\n *\n * See `fio_publish_args_s` for details.\n *\n * By default the message is sent using the FIO_PUBSUB_CLUSTER engine (all\n * processes, including the calling process).\n *\n * To limit the message only to other processes (exclude the calling process),\n * use the FIO_PUBSUB_SIBLINGS engine.\n *\n * To limit the message only to the calling process, use the\n * FIO_PUBSUB_PROCESS engine.\n *\n * To publish messages to the pub/sub layer, the `.filter` argument MUST be\n * equal to 0 or missing.\n */\n#define fio_publish(...) fio_publish((fio_publish_args_s){__VA_ARGS__})\n/** for backwards compatibility */\n#define pubsub_publish fio_publish\n\n/** Finds the message's metadata by it's type ID. Returns the data or NULL. */\nvoid *fio_message_metadata(fio_msg_s *msg, intptr_t type_id);\n\n/**\n * Defers the current callback, so it will be called again for the message.\n */\nvoid fio_message_defer(fio_msg_s *msg);\n\n/* *****************************************************************************\n * Cluster / Pub/Sub Middleware and Extensions (\"Engines\")\n **************************************************************************** */\n\n/** Contains message metadata, set by message extensions. */\ntypedef struct fio_msg_metadata_s fio_msg_metadata_s;\nstruct fio_msg_metadata_s {\n  /**\n   * The type ID should be used to identify the metadata's actual structure.\n   *\n   * Negative ID values are reserved for internal use.\n   */\n  intptr_t type_id;\n  /**\n   * This method will be called by facil.io to cleanup the metadata resources.\n   *\n   * Don't alter / call this method, this data is reserved.\n   */\n  void (*on_finish)(fio_msg_s *msg, void *metadata);\n  /** The pointer to be disclosed to the `fio_message_metadata` function. */\n  void *metadata;\n};\n\n/**\n * Pub/Sub Metadata callback type.\n */\ntypedef fio_msg_metadata_s (*fio_msg_metadata_fn)(fio_str_info_s ch,\n                                                  fio_str_info_s msg,\n                                                  uint8_t is_json);\n\n/**\n * It's possible to attach metadata to facil.io pub/sub messages (filter == 0)\n * before they are published.\n *\n * This allows, for example, messages to be encoded as network packets for\n * outgoing protocols (i.e., encoding for WebSocket transmissions), improving\n * performance in large network based broadcasting.\n *\n * The callback should return a valid metadata object. If the `.metadata` field\n * returned is NULL than the result will be ignored.\n *\n * To remove a callback, set the `enable` flag to false (`0`).\n *\n * The cluster messaging system allows some messages to be flagged as JSON and\n * this flag is available to the metadata callback.\n */\nvoid fio_message_metadata_callback_set(fio_msg_metadata_fn callback,\n                                       int enable);\n\n/**\n * facil.io can be linked with external Pub/Sub services using \"engines\".\n *\n * Only unfiltered messages and subscriptions (where filter == 0) will be\n * forwarded to external Pub/Sub services.\n *\n * Engines MUST provide the listed function pointers and should be attached\n * using the `fio_pubsub_attach` function.\n *\n * Engines should disconnect / detach, before being destroyed, by using the\n * `fio_pubsub_detach` function.\n *\n * When an engine received a message to publish, it should call the\n * `pubsub_publish` function with the engine to which the message is forwarded.\n * i.e.:\n *\n *       pubsub_publish(\n *           .engine = FIO_PROCESS_ENGINE,\n *           .channel = channel_name,\n *           .message = msg_body );\n *\n * IMPORTANT: The `subscribe` and `unsubscribe` callbacks are called from within\n *            an internal lock. They MUST NEVER call pub/sub functions except by\n *            exiting the lock using `fio_defer`.\n */\nstruct fio_pubsub_engine_s {\n  /** Should subscribe channel. Failures are ignored. */\n  void (*subscribe)(const fio_pubsub_engine_s *eng, fio_str_info_s channel,\n                    fio_match_fn match);\n  /** Should unsubscribe channel. Failures are ignored. */\n  void (*unsubscribe)(const fio_pubsub_engine_s *eng, fio_str_info_s channel,\n                      fio_match_fn match);\n  /** Should publish a message through the engine. Failures are ignored. */\n  void (*publish)(const fio_pubsub_engine_s *eng, fio_str_info_s channel,\n                  fio_str_info_s msg, uint8_t is_json);\n};\n\n/**\n * Attaches an engine, so it's callback can be called by facil.io.\n *\n * The `subscribe` callback will be called for every existing channel.\n *\n * NOTE: the root (master) process will call `subscribe` for any channel in any\n * process, while all the other processes will call `subscribe` only for their\n * own channels. This allows engines to use the root (master) process as an\n * exclusive subscription process.\n */\nvoid fio_pubsub_attach(fio_pubsub_engine_s *engine);\n\n/** Detaches an engine, so it could be safely destroyed. */\nvoid fio_pubsub_detach(fio_pubsub_engine_s *engine);\n\n/**\n * Engines can ask facil.io to call the `subscribe` callback for all active\n * channels.\n *\n * This allows engines that lost their connection to their Pub/Sub service to\n * resubscribe all the currently active channels with the new connection.\n *\n * CAUTION: This is an evented task... try not to free the engine's memory while\n * resubscriptions are under way...\n *\n * NOTE: the root (master) process will call `subscribe` for any channel in any\n * process, while all the other processes will call `subscribe` only for their\n * own channels. This allows engines to use the root (master) process as an\n * exclusive subscription process.\n */\nvoid fio_pubsub_reattach(fio_pubsub_engine_s *eng);\n\n/** Returns true (1) if the engine is attached to the system. */\nint fio_pubsub_is_attached(fio_pubsub_engine_s *engine);\n\n#endif /* FIO_PUBSUB_SUPPORT */\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n\n\n\n\n              Atomic Operations and Spin Locking Helper Functions\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/* C11 Atomics are defined? */\n#if defined(__ATOMIC_RELAXED)\n/** An atomic exchange operation, returns previous value */\n#define fio_atomic_xchange(p_obj, value)                                       \\\n  __atomic_exchange_n((p_obj), (value), __ATOMIC_SEQ_CST)\n/** An atomic addition operation */\n#define fio_atomic_add(p_obj, value)                                           \\\n  __atomic_add_fetch((p_obj), (value), __ATOMIC_SEQ_CST)\n/** An atomic subtraction operation */\n#define fio_atomic_sub(p_obj, value)                                           \\\n  __atomic_sub_fetch((p_obj), (value), __ATOMIC_SEQ_CST)\n/* Note: __ATOMIC_SEQ_CST is probably safer and __ATOMIC_ACQ_REL may be faster\n */\n\n/* Select the correct compiler builtin method. */\n#elif __has_builtin(__sync_add_and_fetch)\n/** An atomic exchange operation, ruturns previous value */\n#define fio_atomic_xchange(p_obj, value)                                       \\\n  __sync_val_compare_and_swap((p_obj), *(p_obj), (value))\n/** An atomic addition operation */\n#define fio_atomic_add(p_obj, value) __sync_add_and_fetch((p_obj), (value))\n/** An atomic subtraction operation */\n#define fio_atomic_sub(p_obj, value) __sync_sub_and_fetch((p_obj), (value))\n\n#elif __GNUC__ > 3\n/** An atomic exchange operation, ruturns previous value */\n#define fio_atomic_xchange(p_obj, value)                                       \\\n  __sync_val_compare_and_swap((p_obj), *(p_obj), (value))\n/** An atomic addition operation */\n#define fio_atomic_add(p_obj, value) __sync_add_and_fetch((p_obj), (value))\n/** An atomic subtraction operation */\n#define fio_atomic_sub(p_obj, value) __sync_sub_and_fetch((p_obj), (value))\n\n#else\n#error Required builtin \"__sync_add_and_fetch\" not found.\n#endif\n\n/** An atomic based spinlock. */\ntypedef uint8_t volatile fio_lock_i;\n\n/** The initail value of an unlocked spinlock. */\n#define FIO_LOCK_INIT 0\n\n/** returns 0 if the lock was acquired and a non-zero value on failure. */\nFIO_FUNC inline int fio_trylock(fio_lock_i *lock);\n\n/**\n * Releases a spinlock. Releasing an unacquired lock will break it.\n *\n * Returns a non-zero value on success, or 0 if the lock was in an unloacked\n * state.\n */\nFIO_FUNC inline int fio_unlock(fio_lock_i *lock);\n\n/** Returns a spinlock's state (non 0 == Busy). */\nFIO_FUNC inline int fio_is_locked(fio_lock_i *lock);\n\n/** Busy waits for the spinlock (CAREFUL). */\nFIO_FUNC inline void fio_lock(fio_lock_i *lock);\n\n/**\n * Nanosleep seems to be the most effective and efficient thread rescheduler.\n */\nFIO_FUNC inline void fio_reschedule_thread(void);\n\n/** Nanosleep the thread - a blocking throttle. */\nFIO_FUNC inline void fio_throttle_thread(size_t nano_sec);\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n\n\n\n                         Simple Constant Time Operations\n                         ( boolean true / false and if )\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/** Returns 1 if the expression is true (input isn't zero). */\nFIO_FUNC inline uintptr_t fio_ct_true(uintptr_t cond) {\n  // promise that the highest bit is set if any bits are set, than shift.\n  return ((cond | (0 - cond)) >> ((sizeof(cond) << 3) - 1));\n}\n\n/** Returns 1 if the expression is false (input is zero). */\nFIO_FUNC inline uintptr_t fio_ct_false(uintptr_t cond) {\n  // fio_ct_true returns only one bit, XOR will inverse that bit.\n  return fio_ct_true(cond) ^ 1;\n}\n\n/** Returns `a` if `cond` is boolean and true, returns b otherwise. */\nFIO_FUNC inline uintptr_t fio_ct_if(uint8_t cond, uintptr_t a, uintptr_t b) {\n  // b^(a^b) cancels b out. 0-1 => sets all bits.\n  return (b ^ ((0 - (cond & 1)) & (a ^ b)));\n}\n\n/** Returns `a` if `cond` isn't zero (uses fio_ct_true), returns b otherwise. */\nFIO_FUNC inline uintptr_t fio_ct_if2(uintptr_t cond, uintptr_t a, uintptr_t b) {\n  // b^(a^b) cancels b out. 0-1 => sets all bits.\n  return fio_ct_if(fio_ct_true(cond), a, b);\n}\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n\n\n\n                         Byte Swapping and Network Order\n                       (Big Endian v.s Little Endian etc')\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/** inplace byte swap 16 bit integer */\n#if __has_builtin(__builtin_bswap16)\n#define fio_bswap16(i) __builtin_bswap16((uint16_t)(i))\n#else\n#define fio_bswap16(i) ((((i)&0xFFU) << 8) | (((i)&0xFF00U) >> 8))\n#endif\n/** inplace byte swap 32 bit integer */\n#if __has_builtin(__builtin_bswap32)\n#define fio_bswap32(i) __builtin_bswap32((uint32_t)(i))\n#else\n#define fio_bswap32(i)                                                         \\\n  ((((i)&0xFFUL) << 24) | (((i)&0xFF00UL) << 8) | (((i)&0xFF0000UL) >> 8) |    \\\n   (((i)&0xFF000000UL) >> 24))\n#endif\n/** inplace byte swap 64 bit integer */\n#if __has_builtin(__builtin_bswap64)\n#define fio_bswap64(i) __builtin_bswap64((uint64_t)(i))\n#else\n#define fio_bswap64(i)                                                         \\\n  ((((i)&0xFFULL) << 56) | (((i)&0xFF00ULL) << 40) |                           \\\n   (((i)&0xFF0000ULL) << 24) | (((i)&0xFF000000ULL) << 8) |                    \\\n   (((i)&0xFF00000000ULL) >> 8) | (((i)&0xFF0000000000ULL) >> 24) |            \\\n   (((i)&0xFF000000000000ULL) >> 40) | (((i)&0xFF00000000000000ULL) >> 56))\n#endif\n\n/* Note: using BIG_ENDIAN invokes false positives on some systems */\n#if !defined(__BIG_ENDIAN__)\n/* nothing to do */\n#elif (defined(__LITTLE_ENDIAN__) && !__LITTLE_ENDIAN__) ||                    \\\n    (defined(__BYTE_ORDER__) && (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__))\n#define __BIG_ENDIAN__ 1\n#elif !defined(__BIG_ENDIAN__) && !defined(__BYTE_ORDER__) &&                  \\\n    !defined(__LITTLE_ENDIAN__)\n#error Could not detect byte order on this system.\n#endif\n\n#if __BIG_ENDIAN__\n\n/** Local byte order to Network byte order, 16 bit integer */\n#define fio_lton16(i) (i)\n/** Local byte order to Network byte order, 32 bit integer */\n#define fio_lton32(i) (i)\n/** Local byte order to Network byte order, 62 bit integer */\n#define fio_lton64(i) (i)\n\n/** Network byte order to Local byte order, 16 bit integer */\n#define fio_ntol16(i) (i)\n/** Network byte order to Local byte order, 32 bit integer */\n#define fio_ntol32(i) (i)\n/** Network byte order to Local byte order, 62 bit integer */\n#define fio_ntol64(i) (i)\n\n#else /* Little Endian */\n\n/** Local byte order to Network byte order, 16 bit integer */\n#define fio_lton16(i) fio_bswap16((i))\n/** Local byte order to Network byte order, 32 bit integer */\n#define fio_lton32(i) fio_bswap32((i))\n/** Local byte order to Network byte order, 62 bit integer */\n#define fio_lton64(i) fio_bswap64((i))\n\n/** Network byte order to Local byte order, 16 bit integer */\n#define fio_ntol16(i) fio_bswap16((i))\n/** Network byte order to Local byte order, 32 bit integer */\n#define fio_ntol32(i) fio_bswap32((i))\n/** Network byte order to Local byte order, 62 bit integer */\n#define fio_ntol64(i) fio_bswap64((i))\n\n#endif\n\n/** 32Bit left rotation, inlined. */\n#define fio_lrot32(i, bits)                                                    \\\n  (((uint32_t)(i) << ((bits)&31UL)) | ((uint32_t)(i) >> ((-(bits)) & 31UL)))\n/** 32Bit right rotation, inlined. */\n#define fio_rrot32(i, bits)                                                    \\\n  (((uint32_t)(i) >> ((bits)&31UL)) | ((uint32_t)(i) << ((-(bits)) & 31UL)))\n\n/** 64Bit left rotation, inlined. */\n#define fio_lrot64(i, bits)                                                    \\\n  (((uint64_t)(i) << ((bits)&63UL)) | ((uint64_t)(i) >> ((-(bits)) & 63UL)))\n/** 64Bit right rotation, inlined. */\n#define fio_rrot64(i, bits)                                                    \\\n  (((uint64_t)(i) >> ((bits)&63UL)) | ((uint64_t)(i) << ((-(bits)) & 63UL)))\n\n/** unknown size element - left rotation, inlined. */\n#define fio_lrot(i, bits)                                                      \\\n  (((i) << ((bits) & ((sizeof((i)) << 3) - 1))) |                              \\\n   ((i) >> ((-(bits)) & ((sizeof((i)) << 3) - 1))))\n/** unknown size element - right rotation, inlined. */\n#define fio_rrot(i, bits)                                                      \\\n  (((i) >> ((bits) & ((sizeof((i)) << 3) - 1))) |                              \\\n   ((i) << ((-(bits)) & ((sizeof((i)) << 3) - 1))))\n\n/** Converts an unaligned network ordered byte stream to a 16 bit number. */\n#define fio_str2u16(c)                                                         \\\n  ((uint16_t)(((uint16_t)(((uint8_t *)(c))[0]) << 8) |                         \\\n              (uint16_t)(((uint8_t *)(c))[1])))\n/** Converts an unaligned network ordered byte stream to a 32 bit number. */\n#define fio_str2u32(c)                                                         \\\n  ((uint32_t)(((uint32_t)(((uint8_t *)(c))[0]) << 24) |                        \\\n              ((uint32_t)(((uint8_t *)(c))[1]) << 16) |                        \\\n              ((uint32_t)(((uint8_t *)(c))[2]) << 8) |                         \\\n              (uint32_t)(((uint8_t *)(c))[3])))\n\n/** Converts an unaligned network ordered byte stream to a 64 bit number. */\n#define fio_str2u64(c)                                                         \\\n  ((uint64_t)((((uint64_t)((uint8_t *)(c))[0]) << 56) |                        \\\n              (((uint64_t)((uint8_t *)(c))[1]) << 48) |                        \\\n              (((uint64_t)((uint8_t *)(c))[2]) << 40) |                        \\\n              (((uint64_t)((uint8_t *)(c))[3]) << 32) |                        \\\n              (((uint64_t)((uint8_t *)(c))[4]) << 24) |                        \\\n              (((uint64_t)((uint8_t *)(c))[5]) << 16) |                        \\\n              (((uint64_t)((uint8_t *)(c))[6]) << 8) | (((uint8_t *)(c))[7])))\n\n/** Writes a local 16 bit number to an unaligned buffer in network order. */\n#define fio_u2str16(buffer, i)                                                 \\\n  do {                                                                         \\\n    ((uint8_t *)(buffer))[0] = ((uint16_t)(i) >> 8) & 0xFF;                    \\\n    ((uint8_t *)(buffer))[1] = ((uint16_t)(i)) & 0xFF;                         \\\n  } while (0);\n\n/** Writes a local 32 bit number to an unaligned buffer in network order. */\n#define fio_u2str32(buffer, i)                                                 \\\n  do {                                                                         \\\n    ((uint8_t *)(buffer))[0] = ((uint32_t)(i) >> 24) & 0xFF;                   \\\n    ((uint8_t *)(buffer))[1] = ((uint32_t)(i) >> 16) & 0xFF;                   \\\n    ((uint8_t *)(buffer))[2] = ((uint32_t)(i) >> 8) & 0xFF;                    \\\n    ((uint8_t *)(buffer))[3] = ((uint32_t)(i)) & 0xFF;                         \\\n  } while (0);\n\n/** Writes a local 64 bit number to an unaligned buffer in network order. */\n#define fio_u2str64(buffer, i)                                                 \\\n  do {                                                                         \\\n    ((uint8_t *)(buffer))[0] = (((uint64_t)(i) >> 56) & 0xFF);                 \\\n    ((uint8_t *)(buffer))[1] = (((uint64_t)(i) >> 48) & 0xFF);                 \\\n    ((uint8_t *)(buffer))[2] = (((uint64_t)(i) >> 40) & 0xFF);                 \\\n    ((uint8_t *)(buffer))[3] = (((uint64_t)(i) >> 32) & 0xFF);                 \\\n    ((uint8_t *)(buffer))[4] = (((uint64_t)(i) >> 24) & 0xFF);                 \\\n    ((uint8_t *)(buffer))[5] = (((uint64_t)(i) >> 16) & 0xFF);                 \\\n    ((uint8_t *)(buffer))[6] = (((uint64_t)(i) >> 8) & 0xFF);                  \\\n    ((uint8_t *)(buffer))[7] = (((uint64_t)(i)) & 0xFF);                       \\\n  } while (0);\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n\n\n\n                       Converting Numbers to Strings (and back)\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/* *****************************************************************************\nStrings to Numbers\n***************************************************************************** */\n\n/**\n * A helper function that converts between String data to a signed int64_t.\n *\n * Numbers are assumed to be in base 10. Octal (`0###`), Hex (`0x##`/`x##`) and\n * binary (`0b##`/ `b##`) are recognized as well. For binary Most Significant\n * Bit must come first.\n *\n * The most significant difference between this function and `strtol` (aside of\n * API design), is the added support for binary representations.\n */\nint64_t fio_atol(char **pstr);\n\n/** A helper function that converts between String data to a signed double. */\ndouble fio_atof(char **pstr);\n\n/* *****************************************************************************\nNumbers to Strings\n***************************************************************************** */\n\n/**\n * A helper function that writes a signed int64_t to a string.\n *\n * No overflow guard is provided, make sure there's at least 68 bytes\n * available (for base 2).\n *\n * Offers special support for base 2 (binary), base 8 (octal), base 10 and base\n * 16 (hex). An unsupported base will silently default to base 10. Prefixes\n * aren't added (i.e., no \"0x\" or \"0b\" at the beginning of the string).\n *\n * Returns the number of bytes actually written (excluding the NUL\n * terminator).\n */\nsize_t fio_ltoa(char *dest, int64_t num, uint8_t base);\n\n/**\n * A helper function that converts between a double to a string.\n *\n * No overflow guard is provided, make sure there's at least 130 bytes\n * available (for base 2).\n *\n * Supports base 2, base 10 and base 16. An unsupported base will silently\n * default to base 10. Prefixes aren't added (i.e., no \"0x\" or \"0b\" at the\n * beginning of the string).\n *\n * Returns the number of bytes actually written (excluding the NUL\n * terminator).\n */\nsize_t fio_ftoa(char *dest, double num, uint8_t base);\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n                      Random Generator Functions\n\n                  Probably not cryptographically safe\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/** Returns 64 psedo-random bits. Probably not cryptographically safe. */\nuint64_t fio_rand64(void);\n\n/** Writes `length` bytes of psedo-random bits to the target buffer. */\nvoid fio_rand_bytes(void *target, size_t length);\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n                              Hash Functions and Friends\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/* defines the secret seed to be used by keyd hashing functions*/\n#ifndef FIO_HASH_SECRET_SEED64_1\nuint8_t __attribute__((weak)) fio_hash_secret_marker1;\nuint8_t __attribute__((weak)) fio_hash_secret_marker2;\n#define FIO_HASH_SECRET_SEED64_1 ((uintptr_t)&fio_hash_secret_marker1)\n#define FIO_HASH_SECRET_SEED64_2 ((uintptr_t)&fio_hash_secret_marker2)\n#endif\n\n#if FIO_USE_RISKY_HASH\n#define FIO_HASH_FN(data, length, key1, key2)                                  \\\n  fio_risky_hash((data), (length),                                             \\\n                 ((uint64_t)(key1) >> 19) | ((uint64_t)(key2) << 27))\n#else\n#define FIO_HASH_FN(data, length, key1, key2)                                  \\\n  fio_siphash13((data), (length), (uint64_t)(key1), (uint64_t)(key2))\n#endif\n\n/* *****************************************************************************\nRisky Hash (always available, even if using only the fio.h header)\n***************************************************************************** */\n\n/* Risky Hash primes */\n#define RISKY_PRIME_0 0xFBBA3FA15B22113B\n#define RISKY_PRIME_1 0xAB137439982B86C9\n\n/* Risky Hash consumption round, accepts a state word s and an input word w */\n#define fio_risky_consume(v, w)                                                \\\n  (v) += (w);                                                                  \\\n  (v) = fio_lrot64((v), 33);                                                   \\\n  (v) += (w);                                                                  \\\n  (v) *= RISKY_PRIME_0;\n\n/*  Computes a facil.io Risky Hash. */\nFIO_FUNC inline uint64_t fio_risky_hash(const void *data_, size_t len,\n                                        uint64_t seed) {\n  /* reading position */\n  const uint8_t *data = (uint8_t *)data_;\n\n  /* The consumption vectors initialized state */\n  register uint64_t v0 = seed ^ RISKY_PRIME_1;\n  register uint64_t v1 = ~seed + RISKY_PRIME_1;\n  register uint64_t v2 =\n      fio_lrot64(seed, 17) ^ ((~RISKY_PRIME_1) + RISKY_PRIME_0);\n  register uint64_t v3 = fio_lrot64(seed, 33) + (~RISKY_PRIME_1);\n\n  /* consume 256 bit blocks */\n  for (size_t i = len >> 5; i; --i) {\n    fio_risky_consume(v0, fio_str2u64(data));\n    fio_risky_consume(v1, fio_str2u64(data + 8));\n    fio_risky_consume(v2, fio_str2u64(data + 16));\n    fio_risky_consume(v3, fio_str2u64(data + 24));\n    data += 32;\n  }\n\n  /* Consume any remaining 64 bit words. */\n  switch (len & 24) {\n  case 24:\n    fio_risky_consume(v2, fio_str2u64(data + 16));\n    /* fallthrough */\n  case 16:\n    fio_risky_consume(v1, fio_str2u64(data + 8));\n    /* fallthrough */\n  case 8:\n    fio_risky_consume(v0, fio_str2u64(data));\n    data += len & 24;\n  }\n\n  uint64_t tmp = 0;\n  /* consume leftover bytes, if any */\n  switch ((len & 7)) {\n  case 7:\n    tmp |= ((uint64_t)data[6]) << 8;\n    /* fallthrough */\n  case 6:\n    tmp |= ((uint64_t)data[5]) << 16;\n    /* fallthrough */\n  case 5:\n    tmp |= ((uint64_t)data[4]) << 24;\n    /* fallthrough */\n  case 4:\n    tmp |= ((uint64_t)data[3]) << 32;\n    /* fallthrough */\n  case 3:\n    tmp |= ((uint64_t)data[2]) << 40;\n    /* fallthrough */\n  case 2:\n    tmp |= ((uint64_t)data[1]) << 48;\n    /* fallthrough */\n  case 1:\n    tmp |= ((uint64_t)data[0]) << 56;\n    /* ((len >> 3) & 3) is a 0...3 value indicating consumption vector */\n    switch ((len >> 3) & 3) {\n    case 3:\n      fio_risky_consume(v3, tmp);\n      break;\n    case 2:\n      fio_risky_consume(v2, tmp);\n      break;\n    case 1:\n      fio_risky_consume(v1, tmp);\n      break;\n    case 0:\n      fio_risky_consume(v0, tmp);\n      break;\n    }\n  }\n\n  /* merge and mix */\n  uint64_t result = fio_lrot64(v0, 17) + fio_lrot64(v1, 13) +\n                    fio_lrot64(v2, 47) + fio_lrot64(v3, 57);\n\n  len ^= (len << 33);\n  result += len;\n\n  result += v0 * RISKY_PRIME_1;\n  result ^= fio_lrot64(result, 13);\n  result += v1 * RISKY_PRIME_1;\n  result ^= fio_lrot64(result, 29);\n  result += v2 * RISKY_PRIME_1;\n  result ^= fio_lrot64(result, 33);\n  result += v3 * RISKY_PRIME_1;\n  result ^= fio_lrot64(result, 51);\n\n  /* irreversible avalanche... I think */\n  result ^= (result >> 29) * RISKY_PRIME_0;\n  return result;\n}\n\n#undef fio_risky_consume\n#undef FIO_RISKY_PRIME_0\n#undef FIO_RISKY_PRIME_1\n\n/* *****************************************************************************\nSipHash\n***************************************************************************** */\n\n/**\n * A SipHash variation (2-4).\n */\nuint64_t fio_siphash24(const void *data, size_t len, uint64_t key1,\n                       uint64_t key2);\n\n/**\n * A SipHash 1-3 variation.\n */\nuint64_t fio_siphash13(const void *data, size_t len, uint64_t key1,\n                       uint64_t key2);\n\n/**\n * The Hashing function used by dynamic facil.io objects.\n *\n * Currently implemented using SipHash 1-3.\n */\n#define fio_siphash(data, length, k1, k2)                                      \\\n  fio_siphash13((data), (length), (k1), (k2))\n\n/* *****************************************************************************\nSHA-1\n***************************************************************************** */\n\n/**\nSHA-1 hashing container - you should ignore the contents of this struct.\n\nThe `sha1_s` type will contain all the sha1 data required to perform the\nhashing, managing it's encoding. If it's stack allocated, no freeing will be\nrequired.\n\nUse, for example:\n\n    fio_sha1_s sha1;\n    fio_sha1_init(&sha1);\n    fio_sha1_write(&sha1,\n                  \"The quick brown fox jumps over the lazy dog\", 43);\n    char *hashed_result = fio_sha1_result(&sha1);\n*/\ntypedef struct {\n  uint64_t length;\n  uint8_t buffer[64];\n  union {\n    uint32_t i[5];\n    unsigned char str[21];\n  } digest;\n} fio_sha1_s;\n\n/**\nInitialize or reset the `sha1` object. This must be performed before hashing\ndata using sha1.\n*/\nfio_sha1_s fio_sha1_init(void);\n/**\nWrites data to the sha1 buffer.\n*/\nvoid fio_sha1_write(fio_sha1_s *s, const void *data, size_t len);\n/**\nFinalizes the SHA1 hash, returning the Hashed data.\n\n`fio_sha1_result` can be called for the same object multiple times, but the\nfinalization will only be performed the first time this function is called.\n*/\nchar *fio_sha1_result(fio_sha1_s *s);\n\n/**\nAn SHA1 helper function that performs initialiation, writing and finalizing.\n*/\ninline FIO_FUNC char *fio_sha1(fio_sha1_s *s, const void *data, size_t len) {\n  *s = fio_sha1_init();\n  fio_sha1_write(s, data, len);\n  return fio_sha1_result(s);\n}\n\n/* *****************************************************************************\nSHA-2\n***************************************************************************** */\n\n/**\nSHA-2 function variants.\n\nThis enum states the different SHA-2 function variants. placing SHA_512 at the\nbeginning is meant to set this variant as the default (in case a 0 is passed).\n*/\ntypedef enum {\n  SHA_512 = 1,\n  SHA_512_256 = 3,\n  SHA_512_224 = 5,\n  SHA_384 = 7,\n  SHA_256 = 2,\n  SHA_224 = 4,\n} fio_sha2_variant_e;\n\n/**\nSHA-2 hashing container - you should ignore the contents of this struct.\n\nThe `sha2_s` type will contain all the SHA-2 data required to perform the\nhashing, managing it's encoding. If it's stack allocated, no freeing will be\nrequired.\n\nUse, for example:\n\n    fio_sha2_s sha2;\n    fio_sha2_init(&sha2, SHA_512);\n    fio_sha2_write(&sha2,\n                  \"The quick brown fox jumps over the lazy dog\", 43);\n    char *hashed_result = fio_sha2_result(&sha2);\n\n*/\ntypedef struct {\n  /* notice: we're counting bits, not bytes. max length: 2^128 bits */\n  union {\n    uint8_t bytes[16];\n    uint8_t matrix[4][4];\n    uint32_t words_small[4];\n    uint64_t words[2];\n#if defined(__SIZEOF_INT128__)\n    __uint128_t i;\n#endif\n  } length;\n  uint8_t buffer[128];\n  union {\n    uint32_t i32[16];\n    uint64_t i64[8];\n    uint8_t str[65]; /* added 64+1 for the NULL byte.*/\n  } digest;\n  fio_sha2_variant_e type;\n} fio_sha2_s;\n\n/**\nInitialize/reset the SHA-2 object.\n\nSHA-2 is actually a family of functions with different variants. When\ninitializing the SHA-2 container, you must select the variant you intend to\napply. The following are valid options (see the sha2_variant enum):\n\n- SHA_512 (== 0)\n- SHA_384\n- SHA_512_224\n- SHA_512_256\n- SHA_256\n- SHA_224\n\n*/\nfio_sha2_s fio_sha2_init(fio_sha2_variant_e variant);\n/**\nWrites data to the SHA-2 buffer.\n*/\nvoid fio_sha2_write(fio_sha2_s *s, const void *data, size_t len);\n/**\nFinalizes the SHA-2 hash, returning the Hashed data.\n\n`sha2_result` can be called for the same object multiple times, but the\nfinalization will only be performed the first time this function is called.\n*/\nchar *fio_sha2_result(fio_sha2_s *s);\n\n/**\nAn SHA2 helper function that performs initialiation, writing and finalizing.\nUses the SHA2 512 variant.\n*/\ninline FIO_FUNC char *fio_sha2_512(fio_sha2_s *s, const void *data,\n                                   size_t len) {\n  *s = fio_sha2_init(SHA_512);\n  fio_sha2_write(s, data, len);\n  return fio_sha2_result(s);\n}\n\n/**\nAn SHA2 helper function that performs initialiation, writing and finalizing.\nUses the SHA2 256 variant.\n*/\ninline FIO_FUNC char *fio_sha2_256(fio_sha2_s *s, const void *data,\n                                   size_t len) {\n  *s = fio_sha2_init(SHA_256);\n  fio_sha2_write(s, data, len);\n  return fio_sha2_result(s);\n}\n\n/**\nAn SHA2 helper function that performs initialiation, writing and finalizing.\nUses the SHA2 384 variant.\n*/\ninline FIO_FUNC char *fio_sha2_384(fio_sha2_s *s, const void *data,\n                                   size_t len) {\n  *s = fio_sha2_init(SHA_384);\n  fio_sha2_write(s, data, len);\n  return fio_sha2_result(s);\n}\n\n/* *****************************************************************************\nBase64 (URL) encoding\n***************************************************************************** */\n\n/**\nThis will encode a byte array (data) of a specified length (len) and\nplace the encoded data into the target byte buffer (target). The target buffer\nMUST have enough room for the expected data.\n\nBase64 encoding always requires 4 bytes for each 3 bytes. Padding is added if\nthe raw data's length isn't devisable by 3.\n\nAlways assume the target buffer should have room enough for (len*4/3 + 4)\nbytes.\n\nReturns the number of bytes actually written to the target buffer\n(including the Base64 required padding and excluding a NULL terminator).\n\nA NULL terminator char is NOT written to the target buffer.\n*/\nint fio_base64_encode(char *target, const char *data, int len);\n\n/**\nSame as fio_base64_encode, but using Base64URL encoding.\n*/\nint fio_base64url_encode(char *target, const char *data, int len);\n\n/**\nThis will decode a Base64 encoded string of a specified length (len) and\nplace the decoded data into the target byte buffer (target).\n\nThe target buffer MUST have enough room for 2 bytes in addition to the expected\ndata (NUL byte + padding test).\n\nA NUL byte will be appended to the target buffer. The function will return\nthe number of bytes written to the target buffer (excluding the NUL byte).\n\nIf the target buffer is NUL, the encoded string will be destructively edited\nand the decoded data will be placed in the original string's buffer.\n\nBase64 encoding always requires 4 bytes for each 3 bytes. Padding is added if\nthe raw data's length isn't devisable by 3. Hence, the target buffer should\nbe, at least, `base64_len/4*3 + 3` long.\n\nReturns the number of bytes actually written to the target buffer (excluding\nthe NUL terminator byte).\n\nNote:\n====\n\nThe decoder is variation agnostic (will decode Base64, Base64 URL and Base64 XML\nvariations) and will attempt it's best to ignore invalid data, (in order to\nsupport the MIME Base64 variation in RFC 2045).\n\nThis comes at the cost of error\nchecking, so the encoding isn't validated and invalid input might produce\nsurprising results.\n*/\nint fio_base64_decode(char *target, char *encoded, int base64_len);\n\n/* *****************************************************************************\nTesting\n***************************************************************************** */\n\n#if DEBUG\nvoid fio_test(void);\n#else\n#define fio_test()\n#endif\n\n/* *****************************************************************************\nC++ extern end\n***************************************************************************** */\n#ifdef __cplusplus\n} /* extern \"C\" */\n#endif\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n\n                             Memory Allocator Details\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/**\n * This is a custom memory allocator the utilizes memory pools to allow for\n * concurrent memory allocations across threads.\n *\n * Allocated memory is always zeroed out and aligned on a 16 byte boundary.\n *\n * Reallocated memory is always aligned on a 16 byte boundary but it might be\n * filled with junk data after the valid data (this is true also for\n * `fio_realloc2`).\n *\n * The memory allocator assumes multiple concurrent allocation/deallocation,\n * short life spans (memory is freed shortly, but not immediately, after it was\n * allocated) as well as small allocations (realloc almost always copies data).\n *\n * These assumptions allow the allocator to avoid lock contention by ignoring\n * fragmentation within a memory \"block\" and waiting for the whole \"block\" to be\n * freed before it's memory is recycled (no per-allocation \"free list\").\n *\n * An \"arena\" is allocated per-CPU core during initialization - there's no\n * dynamic allocation of arenas. This allows threads to minimize lock contention\n * by cycling through the arenas until a free arena is detected.\n *\n * There should be a free arena at any given time (statistically speaking) and\n * the thread will only be deferred in the unlikely event in which there's no\n * available arena.\n *\n * By avoiding the \"free-list\", the need for allocation \"headers\" is also\n * avoided and allocations are performed with practically zero overhead (about\n * 32 bytes overhead per 32KB memory, that's 1 bit per 1Kb).\n *\n * However, the lack of a \"free list\" means that memory \"leaks\" are more\n * expensive and small long-life allocations could cause fragmentation if\n * performed periodically (rather than performed during startup).\n *\n * This allocator should NOT be used for objects with a long life-span, because\n * even a single persistent object will prevent the re-use of the whole memory\n * block from which it was allocated (see FIO_MEMORY_BLOCK_SIZE for size).\n *\n * Some more details:\n *\n * Allocation and deallocations and (usually) managed by \"blocks\".\n *\n * A memory \"block\" can include any number of memory pages that are a multiple\n * of 2 (up to 1Mb of memory). However, the default value, set by the value of\n * FIO_MEMORY_BLOCK_SIZE_LOG, is 32Kb (see value at the end of this header).\n *\n * Each block includes a 32 byte header that uses reference counters and\n * position markers (24 bytes are required padding).\n *\n * The block's position marker (`pos`) marks the next available byte (counted in\n * multiples of 16 bytes).\n *\n * The block's reference counter (`ref`) counts how many allocations reference\n * memory in the block (including the \"arena\" that \"owns\" the block).\n *\n * Except for the position marker (`pos`) that acts the same as `sbrk`, there's\n * no way to know which \"slices\" are allocated and which \"slices\" are available.\n *\n * The allocator uses `mmap` when requesting memory from the system and for\n * allocations bigger than MEMORY_BLOCK_ALLOC_LIMIT (37.5% of the block).\n *\n * Small allocations are differentiated from big allocations by their memory\n * alignment.\n *\n * If a memory allocation is placed 16 bytes after whole block alignment (within\n * a block's padding zone), the memory was allocated directly using `mmap` as a\n * \"big allocation\". The 16 bytes include an 8 byte header and an 8 byte\n * padding.\n *\n * To replace the system's `malloc` function family compile with the\n * `FIO_OVERRIDE_MALLOC` defined (`-DFIO_OVERRIDE_MALLOC`).\n *\n * When using tcmalloc or jemalloc, it's possible to define `FIO_FORCE_MALLOC`\n * to prevent the facil.io allocator from compiling (`-DFIO_FORCE_MALLOC`).\n */\n\n#ifndef FIO_MEMORY_BLOCK_SIZE_LOG\n/**\n * The logarithmic value for a memory block, 15 == 32Kb, 16 == 64Kb, etc'\n *\n * By default, a block of memory is 32Kb silce from an 8Mb allocation.\n *\n * A value of 16 will make this a 64Kb silce from a 16Mb allocation.\n */\n#define FIO_MEMORY_BLOCK_SIZE_LOG (15)\n#endif\n\n#undef FIO_MEMORY_BLOCK_SIZE\n/** The resulting memoru block size, depends on `FIO_MEMORY_BLOCK_SIZE_LOG` */\n#define FIO_MEMORY_BLOCK_SIZE ((uintptr_t)1 << FIO_MEMORY_BLOCK_SIZE_LOG)\n\n/**\n * The maximum allocation size, after which `mmap` will be called instead of the\n * facil.io allocator.\n *\n * Defaults to 50% of the block (16Kb), after which `mmap` is used instead\n */\n#ifndef FIO_MEMORY_BLOCK_ALLOC_LIMIT\n#define FIO_MEMORY_BLOCK_ALLOC_LIMIT (FIO_MEMORY_BLOCK_SIZE >> 1)\n#endif\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n\n\n                           Spin locking Implementation\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/**\n * Nanosleep seems to be the most effective and efficient thread rescheduler.\n */\nFIO_FUNC inline void fio_reschedule_thread(void) {\n  const struct timespec tm = {.tv_nsec = 1};\n  nanosleep(&tm, NULL);\n}\n\n/** Nanosleep the thread - a blocking throttle. */\nFIO_FUNC inline void fio_throttle_thread(size_t nano_sec) {\n  const struct timespec tm = {.tv_nsec = (nano_sec % 1000000000),\n                              .tv_sec = (nano_sec / 1000000000)};\n  nanosleep(&tm, NULL);\n}\n\n/** returns 0 if the lock was acquired and another value on failure. */\nFIO_FUNC inline int fio_trylock(fio_lock_i *lock) {\n  __asm__ volatile(\"\" ::: \"memory\");\n  fio_lock_i ret = fio_atomic_xchange(lock, 1);\n  __asm__ volatile(\"\" ::: \"memory\");\n  return ret;\n}\n\n/**\n * Releases a spinlock. Releasing an unacquired lock will break it.\n *\n * Returns a non-zero value on success, or 0 if the lock was in an unloacked\n * state.\n */\nFIO_FUNC inline int fio_unlock(fio_lock_i *lock) {\n  __asm__ volatile(\"\" ::: \"memory\");\n  fio_lock_i ret = fio_atomic_xchange(lock, 0);\n  return ret;\n}\n\n/** Returns a spinlock's state (non 0 == Busy). */\nFIO_FUNC inline int fio_is_locked(fio_lock_i *lock) {\n  __asm__ volatile(\"\" ::: \"memory\");\n  return *lock;\n}\n\n/** Busy waits for the spinlock (CAREFUL). */\nFIO_FUNC inline void fio_lock(fio_lock_i *lock) {\n  while (fio_trylock(lock)) {\n    fio_reschedule_thread();\n  }\n}\n\n#if DEBUG_SPINLOCK\n/** Busy waits for a lock, reports contention. */\nFIO_FUNC inline void fio_lock_dbg(fio_lock_i *lock, const char *file,\n                                  int line) {\n  size_t lock_cycle_count = 0;\n  while (fio_trylock(lock)) {\n    if (lock_cycle_count >= 8 &&\n        (lock_cycle_count == 8 || !(lock_cycle_count & 511)))\n      fprintf(stderr, \"[DEBUG] fio-spinlock spin %s:%d round %zu\\n\", file, line,\n              lock_cycle_count);\n    ++lock_cycle_count;\n    fio_reschedule_thread();\n  }\n  if (lock_cycle_count >= 8)\n    fprintf(stderr, \"[DEBUG] fio-spinlock spin %s:%d total = %zu\\n\", file, line,\n            lock_cycle_count);\n}\n#define fio_lock(lock) fio_lock_dbg((lock), __FILE__, __LINE__)\n\nFIO_FUNC inline int fio_trylock_dbg(fio_lock_i *lock, const char *file,\n                                    int line) {\n  static int last_line = 0;\n  static size_t count = 0;\n  int result = fio_trylock(lock);\n  if (!result) {\n    count = 0;\n    last_line = 0;\n  } else if (line == last_line) {\n    ++count;\n    if (count >= 2)\n      fprintf(stderr, \"[DEBUG] trying fio-spinlock %s:%d attempt %zu\\n\", file,\n              line, count);\n  } else {\n    count = 0;\n    last_line = line;\n  }\n  return result;\n}\n#define fio_trylock(lock) fio_trylock_dbg((lock), __FILE__, __LINE__)\n#endif /* DEBUG_SPINLOCK */\n\n#endif /* H_FACIL_IO_H */\n\n/* *****************************************************************************\n\n\n\n\n\n\n                    Memory allocation macros for helper types\n\n\n\n\n\n\n***************************************************************************** */\n\n#undef FIO_MALLOC\n#undef FIO_CALLOC\n#undef FIO_REALLOC\n#undef FIO_FREE\n\n#if FIO_FORCE_MALLOC || FIO_FORCE_MALLOC_TMP\n#define FIO_MALLOC(size) calloc((size), 1)\n#define FIO_CALLOC(size, units) calloc((size), (units))\n#define FIO_REALLOC(ptr, new_length, existing_data_length)                     \\\n  realloc((ptr), (new_length))\n#define FIO_FREE free\n\n#else\n#define FIO_MALLOC(size) fio_malloc((size))\n#define FIO_CALLOC(size, units) fio_calloc((size), (units))\n#define FIO_REALLOC(ptr, new_length, existing_data_length)                     \\\n  fio_realloc2((ptr), (new_length), (existing_data_length))\n#define FIO_FREE fio_free\n#endif /* FIO_FORCE_MALLOC || FIO_FORCE_MALLOC_TMP */\n\n/* *****************************************************************************\n\n\n\n\n\n\n                           Linked List Helpers\n\n        exposes internally used inline helpers for linked lists\n\n\n\n\n\n\n***************************************************************************** */\n\n#if !defined(H_FIO_LINKED_LIST_H) && defined(FIO_INCLUDE_LINKED_LIST)\n\n#define H_FIO_LINKED_LIST_H\n#undef FIO_INCLUDE_LINKED_LIST\n/* *****************************************************************************\nData Structure and Initialization.\n***************************************************************************** */\n\n/** an embeded linked list. */\ntypedef struct fio_ls_embd_s {\n  struct fio_ls_embd_s *prev;\n  struct fio_ls_embd_s *next;\n} fio_ls_embd_s;\n\n/** an independent linked list. */\ntypedef struct fio_ls_s {\n  struct fio_ls_s *prev;\n  struct fio_ls_s *next;\n  const void *obj;\n} fio_ls_s;\n\n#define FIO_LS_INIT(name)                                                      \\\n  { .next = &(name), .prev = &(name) }\n\n/* *****************************************************************************\nEmbedded Linked List API\n***************************************************************************** */\n\n/** Adds a node to the list's head. */\nFIO_FUNC inline void fio_ls_embd_push(fio_ls_embd_s *dest, fio_ls_embd_s *node);\n\n/** Adds a node to the list's tail. */\nFIO_FUNC inline void fio_ls_embd_unshift(fio_ls_embd_s *dest,\n                                         fio_ls_embd_s *node);\n\n/** Removes a node from the list's head. */\nFIO_FUNC inline fio_ls_embd_s *fio_ls_embd_pop(fio_ls_embd_s *list);\n\n/** Removes a node from the list's tail. */\nFIO_FUNC inline fio_ls_embd_s *fio_ls_embd_shift(fio_ls_embd_s *list);\n\n/** Removes a node from the containing node. */\nFIO_FUNC inline fio_ls_embd_s *fio_ls_embd_remove(fio_ls_embd_s *node);\n\n/** Tests if the list is empty. */\nFIO_FUNC inline int fio_ls_embd_is_empty(fio_ls_embd_s *list);\n\n/** Tests if the list is NOT empty (contains any nodes). */\nFIO_FUNC inline int fio_ls_embd_any(fio_ls_embd_s *list);\n\n/**\n * Iterates through the list using a `for` loop.\n *\n * Access the data with `pos->obj` (`pos` can be named however you please).\n */\n#define FIO_LS_EMBD_FOR(list, node)\n\n/**\n * Takes a list pointer `plist` and returns a pointer to it's container.\n *\n * This uses pointer offset calculations and can be used to calculate any\n * struct's pointer (not just list containers) as an offset from a pointer of\n * one of it's members.\n *\n * Very useful.\n */\n#define FIO_LS_EMBD_OBJ(type, member, plist)                                   \\\n  ((type *)((uintptr_t)(plist) - (uintptr_t)(&(((type *)0)->member))))\n\n/* *****************************************************************************\nIndependent Linked List API\n***************************************************************************** */\n\n/** Adds an object to the list's head, returnin's the object's location. */\nFIO_FUNC inline fio_ls_s *fio_ls_push(fio_ls_s *pos, const void *obj);\n\n/** Adds an object to the list's tail, returnin's the object's location. */\nFIO_FUNC inline fio_ls_s *fio_ls_unshift(fio_ls_s *pos, const void *obj);\n\n/** Removes an object from the list's head. */\nFIO_FUNC inline void *fio_ls_pop(fio_ls_s *list);\n\n/** Removes an object from the list's tail. */\nFIO_FUNC inline void *fio_ls_shift(fio_ls_s *list);\n\n/** Removes a node from the list, returning the contained object. */\nFIO_FUNC inline void *fio_ls_remove(fio_ls_s *node);\n\n/** Tests if the list is empty. */\nFIO_FUNC inline int fio_ls_is_empty(fio_ls_s *list);\n\n/** Tests if the list is NOT empty (contains any nodes). */\nFIO_FUNC inline int fio_ls_any(fio_ls_s *list);\n\n/**\n * Iterates through the list using a `for` loop.\n *\n * Access the data with `pos->obj` (`pos` can be named however you please).\n */\n#define FIO_LS_FOR(list, pos)\n\n/* *****************************************************************************\n\n\n                             Linked List Helpers\n\n                               IMPLEMENTATION\n\n\n***************************************************************************** */\n\n/* *****************************************************************************\nEmbeded Linked List Implementation\n***************************************************************************** */\n\n/** Removes a node from the containing node. */\nFIO_FUNC inline fio_ls_embd_s *fio_ls_embd_remove(fio_ls_embd_s *node) {\n  if (!node->next || node->next == node) {\n    /* never remove the list's head */\n    return NULL;\n  }\n  node->next->prev = node->prev;\n  node->prev->next = node->next;\n  node->prev = node->next = node;\n  return node;\n}\n\n/** Adds a node to the list's head. */\nFIO_FUNC inline void fio_ls_embd_push(fio_ls_embd_s *dest,\n                                      fio_ls_embd_s *node) {\n  if (!dest || !node)\n    return;\n  node->prev = dest->prev;\n  node->next = dest;\n  dest->prev->next = node;\n  dest->prev = node;\n}\n\n/** Adds a node to the list's tail. */\nFIO_FUNC inline void fio_ls_embd_unshift(fio_ls_embd_s *dest,\n                                         fio_ls_embd_s *node) {\n  fio_ls_embd_push(dest->next, node);\n}\n\n/** Removes a node from the list's head. */\nFIO_FUNC inline fio_ls_embd_s *fio_ls_embd_pop(fio_ls_embd_s *list) {\n  return fio_ls_embd_remove(list->prev);\n}\n\n/** Removes a node from the list's tail. */\nFIO_FUNC inline fio_ls_embd_s *fio_ls_embd_shift(fio_ls_embd_s *list) {\n  return fio_ls_embd_remove(list->next);\n}\n\n/** Tests if the list is empty. */\nFIO_FUNC inline int fio_ls_embd_is_empty(fio_ls_embd_s *list) {\n  return list->next == list;\n}\n\n/** Tests if the list is NOT empty (contains any nodes). */\nFIO_FUNC inline int fio_ls_embd_any(fio_ls_embd_s *list) {\n  return list->next != list;\n}\n\n#undef FIO_LS_EMBD_FOR\n#define FIO_LS_EMBD_FOR(list, node)                                            \\\n  for (fio_ls_embd_s *node = (list)->next; node != (list); node = node->next)\n\n/* *****************************************************************************\nIndependent Linked List Implementation\n***************************************************************************** */\n\n/** Removes an object from the containing node. */\nFIO_FUNC inline void *fio_ls_remove(fio_ls_s *node) {\n  if (!node || node->next == node) {\n    /* never remove the list's head */\n    return NULL;\n  }\n  const void *ret = node->obj;\n  node->next->prev = node->prev;\n  node->prev->next = node->next;\n  FIO_FREE(node);\n  return (void *)ret;\n}\n\n/** Adds an object to the list's head. */\nFIO_FUNC inline fio_ls_s *fio_ls_push(fio_ls_s *pos, const void *obj) {\n  if (!pos)\n    return NULL;\n  /* prepare item */\n  fio_ls_s *item = (fio_ls_s *)FIO_MALLOC(sizeof(*item));\n  FIO_ASSERT_ALLOC(item);\n  *item = (fio_ls_s){.prev = pos->prev, .next = pos, .obj = obj};\n  /* inject item */\n  pos->prev->next = item;\n  pos->prev = item;\n  return item;\n}\n\n/** Adds an object to the list's tail. */\nFIO_FUNC inline fio_ls_s *fio_ls_unshift(fio_ls_s *pos, const void *obj) {\n  return fio_ls_push(pos->next, obj);\n}\n\n/** Removes an object from the list's head. */\nFIO_FUNC inline void *fio_ls_pop(fio_ls_s *list) {\n  return fio_ls_remove(list->prev);\n}\n\n/** Removes an object from the list's tail. */\nFIO_FUNC inline void *fio_ls_shift(fio_ls_s *list) {\n  return fio_ls_remove(list->next);\n}\n\n/** Tests if the list is empty. */\nFIO_FUNC inline int fio_ls_is_empty(fio_ls_s *list) {\n  return list->next == list;\n}\n\n/** Tests if the list is NOT empty (contains any nodes). */\nFIO_FUNC inline int fio_ls_any(fio_ls_s *list) { return list->next != list; }\n\n#undef FIO_LS_FOR\n#define FIO_LS_FOR(list, pos)                                                  \\\n  for (fio_ls_s *pos = (list)->next; pos != (list); pos = pos->next)\n\n#endif /* FIO_INCLUDE_LINKED_LIST */\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n                             String Helpers\n\n          exposes internally used inline helpers for binary Strings\n\n\n\n\n\n\n\n***************************************************************************** */\n\n#if !defined(H_FIO_STR_H) && defined(FIO_INCLUDE_STR)\n\n#define H_FIO_STR_H\n#undef FIO_INCLUDE_STR\n\n/* *****************************************************************************\nString API - Initialization and Destruction\n***************************************************************************** */\n\n/**\n * The `fio_str_s` type should be considered opaque.\n *\n * The type's attributes should be accessed ONLY through the accessor functions:\n * `fio_str_info`, `fio_str_len`, `fio_str_data`, `fio_str_capa`, etc'.\n *\n * Note: when the `small` flag is present, the structure is ignored and used as\n * raw memory for a small String (no additional allocation). This changes the\n * String's behavior drastically and requires that the accessor functions be\n * used.\n */\ntypedef struct {\n#ifndef FIO_STR_NO_REF\n  volatile uint32_t ref; /* reference counter for fio_str_dup */\n#endif\n  uint8_t small;  /* Flag indicating the String is small and self-contained */\n  uint8_t frozen; /* Flag indicating the String is frozen (don't edit) */\n#ifdef FIO_STR_NO_REF\n  uint8_t reserved[14]; /* Align struct on 16 byte allocator boundary */\n#else\n  uint8_t reserved[10]; /* Align struct on 16 byte allocator boundary */\n#endif\n  uint64_t capa;           /* Known capacity for longer Strings */\n  uint64_t len;            /* String length for longer Strings */\n  void (*dealloc)(void *); /* Data deallocation function (NULL for static) */\n  char *data;              /* Data for longer Strings */\n#if UINTPTR_MAX != UINT64_MAX\n  uint8_t padding[2 * (sizeof(uint64_t) -\n                       sizeof(void *))]; /* 16 byte  boundary for 32bit OS */\n#endif\n} fio_str_s;\n\n/**\n * This value should be used for initialization. For example:\n *\n *      // on the stack\n *      fio_str_s str = FIO_STR_INIT;\n *\n *      // or on the heap\n *      fio_str_s *str = malloc(sizeof(*str);\n *      *str = FIO_STR_INIT;\n *\n * Remember to cleanup:\n *\n *      // on the stack\n *      fio_str_free(&str);\n *\n *      // or on the heap\n *      fio_str_free(str);\n *      free(str);\n */\n#define FIO_STR_INIT ((fio_str_s){.data = NULL, .small = 1})\n\n/**\n * This macro allows the container to be initialized with existing data, as long\n * as it's memory was allocated using `fio_malloc`.\n *\n * The `capacity` value should exclude the NUL character (if exists).\n */\n#define FIO_STR_INIT_EXISTING(buffer, length, capacity)                        \\\n  ((fio_str_s){.data = (buffer),                                               \\\n               .len = (length),                                                \\\n               .capa = (capacity),                                             \\\n               .dealloc = FIO_FREE})\n\n/**\n * This macro allows the container to be initialized with existing static data,\n * that shouldn't be freed.\n */\n#define FIO_STR_INIT_STATIC(buffer)                                            \\\n  ((fio_str_s){                                                                \\\n      .data = (char *)(buffer), .len = strlen((buffer)), .dealloc = NULL})\n\n/**\n * This macro allows the container to be initialized with existing static data,\n * that shouldn't be freed.\n */\n#define FIO_STR_INIT_STATIC2(buffer, length)                                   \\\n  ((fio_str_s){.data = (char *)(buffer), .len = (length), .dealloc = NULL})\n\n/**\n * Allocates a new fio_str_s object on the heap and initializes it.\n *\n * Use `fio_str_free2` to free both the String data and the container.\n *\n * NOTE: This makes the allocation and reference counting logic more intuitive.\n */\ninline FIO_FUNC fio_str_s *fio_str_new2(void);\n\n/**\n * Allocates a new fio_str_s object on the heap, initializes it and copies the\n * original (`src`) string into the new string.\n *\n * Use `fio_str_free2` to free the new string's data and it's container.\n */\ninline FIO_FUNC fio_str_s *fio_str_new_copy2(fio_str_s *src);\n\n/**\n * Adds a references to the current String object and returns itself.\n *\n * If refecrence counting was disabled (FIO_STR_NO_REF was defined), returns a\n * copy of the String (free with `fio_str_free2`).\n *\n * NOTE: Nothing is copied, reference Strings are referencing the same String.\n *       Editing one reference will effect the other.\n *\n *       The original's String's container should remain in scope (if on the\n *       stack) or remain allocated (if on the heap) until all the references\n *       were freed using `fio_str_free` / `fio_str_free2` or discarded.\n */\ninline FIO_FUNC fio_str_s *fio_str_dup(fio_str_s *s);\n\n/**\n * Frees the String's resources and reinitializes the container.\n *\n * Note: if the container isn't allocated on the stack, it should be freed\n * separately using `free(s)`.\n *\n * Returns 0 if the data was freed and -1 if the String is NULL or has un-freed\n * references (see fio_str_dup).\n */\ninline FIO_FUNC int fio_str_free(fio_str_s *s);\n\n/**\n * Frees the String's resources AS WELL AS the container.\n *\n * Note: the container is freed using `fio_free`, make sure `fio_malloc` was\n * used to allocate it.\n */\nFIO_FUNC void fio_str_free2(fio_str_s *s);\n\n/**\n * `fio_str_send_free2` sends the fio_str_s using `fio_write2`, freeing both the\n * String and the container once the data was sent\n *\n * As the naming indicates, the String is assumed to have been allocated using\n * `fio_str_new2` or `fio_malloc`.\n */\ninline FIO_FUNC ssize_t fio_str_send_free2(const intptr_t uuid,\n                                           const fio_str_s *str);\n\n/**\n * Returns a C string with the existing data, clearing the `fio_str_s` object's\n * String.\n *\n * Note: the String data is removed from the container, but the container isn't\n * freed.\n *\n * Returns NULL if there's no String data.\n *\n * Remember to `fio_free` the returned data and - if required - `fio_str_free2`\n * the container.\n */\nFIO_FUNC char *fio_str_detach(fio_str_s *s);\n\n/* *****************************************************************************\nString API - String state (data pointers, length, capacity, etc')\n***************************************************************************** */\n\n/*\n * String state information, defined above as:\ntypedef struct {\n  size_t capa;\n  size_t len;\n  char *data;\n} fio_str_info_s;\n*/\n\n/** Returns the String's complete state (capacity, length and pointer).  */\ninline FIO_FUNC fio_str_info_s fio_str_info(const fio_str_s *s);\n\n/** Returns the String's length in bytes. */\ninline FIO_FUNC size_t fio_str_len(fio_str_s *s);\n\n/** Returns a pointer (`char *`) to the String's content. */\ninline FIO_FUNC char *fio_str_data(fio_str_s *s);\n\n/** Returns a byte pointer (`uint8_t *`) to the String's unsigned content. */\n#define fio_str_bytes(s) ((uint8_t *)fio_str_data((s)))\n\n/** Returns the String's existing capacity (total used & available memory). */\ninline FIO_FUNC size_t fio_str_capa(fio_str_s *s);\n\n/**\n * Sets the new String size without reallocating any memory (limited by\n * existing capacity).\n *\n * Returns the updated state of the String.\n *\n * Note: When shrinking, any existing data beyond the new size may be corrupted.\n */\ninline FIO_FUNC fio_str_info_s fio_str_resize(fio_str_s *s, size_t size);\n\n/**\n * Clears the string (retaining the existing capacity).\n */\n#define fio_str_clear(s) fio_str_resize((s), 0)\n\n/**\n * Returns the string's Risky Hash value.\n *\n * Note: Hash algorithm might change without notice.\n */\nFIO_FUNC uint64_t fio_str_hash(const fio_str_s *s);\n\n/* *****************************************************************************\nString API - Memory management\n***************************************************************************** */\n\n/**\n * Performs a best attempt at minimizing memory consumption.\n *\n * Actual effects depend on the underlying memory allocator and it's\n * implementation. Not all allocators will free any memory.\n */\nFIO_FUNC void fio_str_compact(fio_str_s *s);\n\n/**\n * Requires the String to have at least `needed` capacity. Returns the current\n * state of the String.\n */\nFIO_FUNC fio_str_info_s fio_str_capa_assert(fio_str_s *s, size_t needed);\n\n/* *****************************************************************************\nString API - UTF-8 State\n***************************************************************************** */\n\n/** Returns 1 if the String is UTF-8 valid and 0 if not. */\nFIO_FUNC size_t fio_str_utf8_valid(fio_str_s *s);\n\n/** Returns the String's length in UTF-8 characters. */\nFIO_FUNC size_t fio_str_utf8_len(fio_str_s *s);\n\n/**\n * Takes a UTF-8 character selection information (UTF-8 position and length) and\n * updates the same variables so they reference the raw byte slice information.\n *\n * If the String isn't UTF-8 valid up to the requested selection, than `pos`\n * will be updated to `-1` otherwise values are always positive.\n *\n * The returned `len` value may be shorter than the original if there wasn't\n * enough data left to accomodate the requested length. When a `len` value of\n * `0` is returned, this means that `pos` marks the end of the String.\n *\n * Returns -1 on error and 0 on success.\n */\nFIO_FUNC int fio_str_utf8_select(fio_str_s *s, intptr_t *pos, size_t *len);\n\n/**\n * Advances the `ptr` by one utf-8 character, placing the value of the UTF-8\n * character into the i32 variable (which must be a signed integer with 32bits\n * or more). On error, `i32` will be equal to `-1` and `ptr` will not step\n * forwards.\n *\n * The `end` value is only used for overflow protection.\n *\n * This helper macro is used internally but left exposed for external use.\n */\n#define FIO_STR_UTF8_CODE_POINT(ptr, end, i32)\n\n/* *****************************************************************************\nString API - Content Manipulation and Review\n***************************************************************************** */\n\n/**\n * Writes data at the end of the String (similar to `fio_str_insert` with the\n * argument `pos == -1`).\n */\ninline FIO_FUNC fio_str_info_s fio_str_write(fio_str_s *s, const void *src,\n                                             size_t src_len);\n\n/**\n * Writes a number at the end of the String using normal base 10 notation.\n */\ninline FIO_FUNC fio_str_info_s fio_str_write_i(fio_str_s *s, int64_t num);\n\n/**\n * Appens the `src` String to the end of the `dest` String.\n *\n * If `dest` is empty, the resulting Strings will be equal.\n */\ninline FIO_FUNC fio_str_info_s fio_str_concat(fio_str_s *dest,\n                                              fio_str_s const *src);\n\n/** Alias for fio_str_concat */\n#define fio_str_join(dest, src) fio_str_concat((dest), (src))\n\n/**\n * Replaces the data in the String - replacing `old_len` bytes starting at\n * `start_pos`, with the data at `src` (`src_len` bytes long).\n *\n * Negative `start_pos` values are calculated backwards, `-1` == end of String.\n *\n * When `old_len` is zero, the function will insert the data at `start_pos`.\n *\n * If `src_len == 0` than `src` will be ignored and the data marked for\n * replacement will be erased.\n */\nFIO_FUNC fio_str_info_s fio_str_replace(fio_str_s *s, intptr_t start_pos,\n                                        size_t old_len, const void *src,\n                                        size_t src_len);\n\n/**\n * Writes to the String using a vprintf like interface.\n *\n * Data is written to the end of the String.\n */\nFIO_FUNC fio_str_info_s fio_str_vprintf(fio_str_s *s, const char *format,\n                                        va_list argv);\n\n/**\n * Writes to the String using a printf like interface.\n *\n * Data is written to the end of the String.\n */\nFIO_FUNC fio_str_info_s fio_str_printf(fio_str_s *s, const char *format, ...);\n\n/**\n * Opens the file `filename` and pastes it's contents (or a slice ot it) at the\n * end of the String. If `limit == 0`, than the data will be read until EOF.\n *\n * If the file can't be located, opened or read, or if `start_at` is beyond\n * the EOF position, NULL is returned in the state's `data` field.\n *\n * Works on POSIX only.\n */\nFIO_FUNC fio_str_info_s fio_str_readfile(fio_str_s *s, const char *filename,\n                                         intptr_t start_at, intptr_t limit);\n\n/**\n * Prevents further manipulations to the String's content.\n */\ninline FIO_FUNC void fio_str_freeze(fio_str_s *s);\n\n/**\n * Binary comparison returns `1` if both strings are equal and `0` if not.\n */\ninline FIO_FUNC int fio_str_iseq(const fio_str_s *str1, const fio_str_s *str2);\n\n/* *****************************************************************************\n\n\n                             String Implementation\n\n                               IMPLEMENTATION\n\n\n***************************************************************************** */\n\n/* *****************************************************************************\nString Implementation - state (data pointers, length, capacity, etc')\n***************************************************************************** */\n\ntypedef struct {\n#ifndef FIO_STR_NO_REF\n  volatile uint32_t ref; /* reference counter for fio_str_dup */\n#endif\n  uint8_t small;  /* Flag indicating the String is small and self-contained */\n  uint8_t frozen; /* Flag indicating the String is frozen (don't edit) */\n} fio_str__small_s;\n\n#define FIO_STR_SMALL_DATA(s) ((char *)((&(s)->frozen) + 1))\n\n/* the capacity when the string is stored in the container itself */\n#define FIO_STR_SMALL_CAPA                                                     \\\n  (sizeof(fio_str_s) - (size_t)((&((fio_str_s *)0)->frozen) + 1))\n\n/** Returns the String's state (capacity, length and pointer). */\ninline FIO_FUNC fio_str_info_s fio_str_info(const fio_str_s *s) {\n  if (!s)\n    return (fio_str_info_s){.len = 0};\n  return (s->small || !s->data)\n             ? (fio_str_info_s){.capa =\n                                    (s->frozen ? 0 : (FIO_STR_SMALL_CAPA - 1)),\n                                .len = (size_t)(s->small >> 1),\n                                .data = FIO_STR_SMALL_DATA(s)}\n             : (fio_str_info_s){.capa = (s->frozen ? 0 : s->capa),\n                                .len = s->len,\n                                .data = s->data};\n}\n\n/**\n * Allocates a new fio_str_s object on the heap and initializes it.\n *\n * Use `fio_str_free2` to free both the String data and the container.\n *\n * NOTE: This makes the allocation and reference counting logic more intuitive.\n */\ninline FIO_FUNC fio_str_s *fio_str_new2(void) {\n  fio_str_s *str = FIO_MALLOC(sizeof(*str));\n  FIO_ASSERT_ALLOC(str);\n  *str = FIO_STR_INIT;\n  return str;\n}\n\n/**\n * Allocates a new fio_str_s object on the heap, initializes it and copies the\n * original (`src`) string into the new string.\n *\n * Use `fio_str_free2` to free the new string's data and it's container.\n */\ninline FIO_FUNC fio_str_s *fio_str_new_copy2(fio_str_s *src) {\n  fio_str_s *cpy = fio_str_new2();\n  fio_str_concat(cpy, src);\n  return cpy;\n}\n\n/**\n * Adds a references to the current String object and returns itself.\n *\n * If refecrence counting was disabled (FIO_STR_NO_REF was defined), returns a\n * copy of the String (free with `fio_str_free2`).\n *\n * NOTE: Nothing is copied, reference Strings are referencing the same String.\n *       Editing one reference will effect the other.\n *\n *       The original's String's container should remain in scope (if on the\n *       stack) or remain allocated (if on the heap) until all the references\n *       were freed using `fio_str_free` / `fio_str_free2` or discarded.\n */\ninline FIO_FUNC fio_str_s *fio_str_dup(fio_str_s *s) {\n#ifdef FIO_STR_NO_REF\n  fio_str_s *s2 = fio_str_new2();\n  fio_str_concat(s2, s);\n  return s2;\n#else\n  if (s)\n    fio_atomic_add(&s->ref, 1);\n  return s;\n#endif\n}\n\n/**\n * Frees the String's resources and reinitializes the container.\n *\n * Note: if the container isn't allocated on the stack, it should be freed\n * separately using `free(s)`.\n *\n * Returns 0 if the data was freed and -1 if the String is NULL or has un-freed\n * references (see fio_str_dup).\n */\ninline FIO_FUNC int fio_str_free(fio_str_s *s) {\n#ifndef FIO_STR_NO_REF\n  if (!s || fio_atomic_sub(&s->ref, 1) != (uint32_t)-1)\n    return -1;\n#endif\n  if (!s->small && s->dealloc)\n    s->dealloc(s->data);\n  *s = FIO_STR_INIT;\n  return 0;\n}\n\n/**\n * Frees the String's resources as well as the container.\n *\n * Note: the container is freed using `free`, make sure `malloc` was used to\n * allocate it.\n */\nFIO_FUNC void fio_str_free2(fio_str_s *s) {\n  if (fio_str_free(s)) {\n    return;\n  }\n  FIO_FREE(s);\n}\n\n/**\n * Returns a C string with the existing data, clearing the `fio_str_s` object's\n * String.\n *\n * Note: the String data is removed from the container, but the container isn't\n * freed.\n *\n * Returns NULL if there's no String data.\n *\n * Remember to `fio_free` the returned data and - if required - `fio_str_free2`\n * the container.\n */\nFIO_FUNC char *fio_str_detach(fio_str_s *s) {\n  if (!s)\n    return NULL;\n  fio_str_info_s i = fio_str_info(s);\n  if (s->small || !s->data) {\n    if (!i.len) {\n      i.data = NULL;\n      goto finish;\n    }\n    /* make a copy */\n    void *tmp = FIO_MALLOC(i.len + 1);\n    memcpy(tmp, i.data, i.len + 1);\n    i.data = tmp;\n  } else {\n    if (!i.len && s->data) {\n      if (s->dealloc)\n        s->dealloc(s->data);\n      i.data = NULL;\n    } else if (s->dealloc != FIO_FREE) {\n      /* make a copy */\n      void *tmp = FIO_MALLOC(i.len + 1);\n      memcpy(tmp, i.data, i.len + 1);\n      i.data = tmp;\n      if (s->dealloc)\n        s->dealloc(s->data);\n    }\n  }\nfinish:\n#ifdef FIO_STR_NO_REF\n  *s = (fio_str_s){.small = 1};\n\n#else\n  *s = (fio_str_s){\n      .small = s->small,\n      .ref = s->ref,\n  };\n#endif\n  return i.data;\n}\n\n/** Returns the String's length in bytes. */\ninline FIO_FUNC size_t fio_str_len(fio_str_s *s) {\n  return (s->small || !s->data) ? (s->small >> 1) : s->len;\n}\n\n/** Returns a pointer (`char *`) to the String's content. */\ninline FIO_FUNC char *fio_str_data(fio_str_s *s) {\n  return (s->small || !s->data) ? FIO_STR_SMALL_DATA(s) : s->data;\n}\n\n/** Returns the String's existing capacity (allocated memory). */\ninline FIO_FUNC size_t fio_str_capa(fio_str_s *s) {\n  if (s->frozen)\n    return 0;\n  return (s->small || !s->data) ? (FIO_STR_SMALL_CAPA - 1) : s->capa;\n}\n\n/**\n * Sets the new String size without reallocating any memory (limited by\n * existing capacity).\n *\n * Returns the updated state of the String.\n *\n * Note: When shrinking, any existing data beyond the new size may be corrupted.\n *\n * Note: When providing a new size that is grater then the current string\n * capacity, any data that was written beyond the current (previous) size might\n * be replaced with NUL bytes.\n */\ninline FIO_FUNC fio_str_info_s fio_str_resize(fio_str_s *s, size_t size) {\n  if (!s || s->frozen) {\n    return fio_str_info(s);\n  }\n  if (s->small || !s->data) {\n    if (size < FIO_STR_SMALL_CAPA) {\n      s->small = (uint8_t)(((size << 1) | 1) & 0xFF);\n      FIO_STR_SMALL_DATA(s)[size] = 0;\n      return (fio_str_info_s){.capa = (FIO_STR_SMALL_CAPA - 1),\n                              .len = size,\n                              .data = FIO_STR_SMALL_DATA(s)};\n    }\n    s->small = (uint8_t)((((FIO_STR_SMALL_CAPA - 1) << 1) | 1) & 0xFF);\n    fio_str_capa_assert(s, size);\n    goto big;\n  }\n  if (size >= s->capa) {\n    s->len = fio_ct_if2((uintptr_t)s->dealloc, s->capa, s->len);\n    fio_str_capa_assert(s, size);\n  }\n\nbig:\n  s->len = size;\n  s->data[size] = 0;\n  return (fio_str_info_s){.capa = s->capa, .len = size, .data = s->data};\n}\n\n/* *****************************************************************************\nString Implementation - Hashing\n***************************************************************************** */\n\n/**\n * Return's the String's Risky Hash (see fio_risky_hash).\n *\n * This value is machine/instance specific (hash seed is a memory address).\n *\n * NOTE: the hashing function might be changed at any time without notice. It\n * wasn't cryptographically analyzed and safety against malicious data can't be\n * guaranteed. Use fio_siphash13 or fio_siphash24 when hashing data from\n * external sources.\n */\nFIO_FUNC uint64_t fio_str_hash(const fio_str_s *s) {\n  fio_str_info_s state = fio_str_info(s);\n  return fio_risky_hash(state.data, state.len, FIO_HASH_SECRET_SEED64_1);\n}\n\n/* *****************************************************************************\nString Implementation - Memory management\n***************************************************************************** */\n\n/**\n * Rounds up allocated capacity to the closest 2 words byte boundary (leaving 1\n * byte space for the NUL byte).\n *\n * This shouldn't effect actual allocation size and should only minimize the\n * effects of the memory allocator's alignment rounding scheme.\n *\n * To clarify:\n *\n * Memory allocators are required to allocate memory on the minimal alignment\n * required by the largest type (`long double`), which usually results in memory\n * allocations using this alignment as a minimal spacing.\n *\n * For example, on 64 bit architectures, it's likely that `malloc(18)` will\n * allocate the same amount of memory as `malloc(32)` due to alignment concerns.\n *\n * In fact, with some allocators (i.e., jemalloc), spacing increases for larger\n * allocations - meaning the allocator will round up to more than 16 bytes, as\n * noted here: http://jemalloc.net/jemalloc.3.html#size_classes\n *\n * Note that this increased spacing, doesn't occure with facil.io's allocator,\n * since it uses 16 byte alignment right up until allocations are routed\n * directly to `mmap` (due to their size, usually over 12KB).\n */\n#define ROUND_UP_CAPA2WORDS(num) (((num) + 1) | (sizeof(long double) - 1))\n\n/**\n * Requires the String to have at least `needed` capacity. Returns the current\n * state of the String.\n */\nFIO_FUNC fio_str_info_s fio_str_capa_assert(fio_str_s *s, size_t needed) {\n  if (!s || s->frozen) {\n    return fio_str_info(s);\n  }\n  char *tmp;\n  if (s->small || !s->data) {\n    if (needed < FIO_STR_SMALL_CAPA) {\n      return (fio_str_info_s){.capa = (FIO_STR_SMALL_CAPA - 1),\n                              .len = (size_t)(s->small >> 1),\n                              .data = FIO_STR_SMALL_DATA(s)};\n    }\n    goto is_small;\n  }\n  if (needed < s->capa) {\n    return (fio_str_info_s){.capa = s->capa, .len = s->len, .data = s->data};\n  }\n  needed = ROUND_UP_CAPA2WORDS(needed);\n  if (s->dealloc == FIO_FREE) {\n    tmp = (char *)FIO_REALLOC(s->data, needed + 1, s->len + 1);\n    FIO_ASSERT_ALLOC(tmp);\n  } else {\n    tmp = (char *)FIO_MALLOC(needed + 1);\n    FIO_ASSERT_ALLOC(tmp);\n    memcpy(tmp, s->data, s->len + 1);\n    if (s->dealloc)\n      s->dealloc(s->data);\n    s->dealloc = FIO_FREE;\n  }\n  s->capa = needed;\n  s->data = tmp;\n  s->data[needed] = 0;\n  return (fio_str_info_s){.capa = s->capa, .len = s->len, .data = s->data};\n\nis_small:\n  /* small string (string data is within the container) */\n  needed = ROUND_UP_CAPA2WORDS(needed);\n  tmp = (char *)FIO_MALLOC(needed + 1);\n  FIO_ASSERT_ALLOC(tmp);\n  const size_t existing_len = (size_t)((s->small >> 1) & 0xFF);\n  if (existing_len) {\n    memcpy(tmp, FIO_STR_SMALL_DATA(s), existing_len + 1);\n  } else {\n    tmp[0] = 0;\n  }\n#ifdef FIO_STR_NO_REF\n  *s = (fio_str_s){\n      .small = 0,\n      .capa = needed,\n      .len = existing_len,\n      .dealloc = FIO_FREE,\n      .data = tmp,\n  };\n#else\n  *s = (fio_str_s){\n      .ref = s->ref,\n      .small = 0,\n      .capa = needed,\n      .len = existing_len,\n      .dealloc = FIO_FREE,\n      .data = tmp,\n  };\n#endif\n  return (fio_str_info_s){.capa = needed, .len = existing_len, .data = s->data};\n}\n\n/** Performs a best attempt at minimizing memory consumption. */\nFIO_FUNC void fio_str_compact(fio_str_s *s) {\n  if (!s || (s->small || !s->data))\n    return;\n  char *tmp;\n  if (s->len < FIO_STR_SMALL_CAPA)\n    goto shrink2small;\n  tmp = fio_realloc(s->data, s->len + 1);\n  FIO_ASSERT_ALLOC(tmp);\n  s->data = tmp;\n  s->capa = s->len;\n  return;\n\nshrink2small:\n  /* move the string into the container */\n  tmp = s->data;\n  size_t len = s->len;\n  *s = (fio_str_s){.small = (uint8_t)(((len << 1) | 1) & 0xFF),\n                   .frozen = s->frozen};\n  if (len) {\n    memcpy(FIO_STR_SMALL_DATA(s), tmp, len + 1);\n  }\n  FIO_FREE(tmp);\n}\n\n/* *****************************************************************************\nString Implementation - UTF-8 State\n***************************************************************************** */\n\n/**\n * Maps the first 5 bits in a byte (0b11111xxx) to a UTF-8 codepoint length.\n *\n * Codepoint length 0 == error.\n *\n * The first valid length can be any value between 1 to 4.\n *\n * A continuation byte (second, third or forth) valid length must be 5.\n *\n * To map was populated using the following Ruby script:\n *\n *      map = []; 32.times { map << 0 }; (0..0b1111).each {|i| map[i] = 1} ;\n *      (0b10000..0b10111).each {|i| map[i] = 5} ;\n *      (0b11000..0b11011).each {|i| map[i] = 2} ;\n *      (0b11100..0b11101).each {|i| map[i] = 3} ;\n *      map[0b11110] = 4; map;\n */\nstatic uint8_t fio_str_utf8_map[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                                     1, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5,\n                                     5, 5, 2, 2, 2, 2, 3, 3, 4, 0};\n\n#undef FIO_STR_UTF8_CODE_POINT\n/**\n * Advances the `ptr` by one utf-8 character, placing the value of the UTF-8\n * character into the i32 variable (which must be a signed integer with 32bits\n * or more). On error, `i32` will be equal to `-1` and `ptr` will not step\n * forwards.\n *\n * The `end` value is only used for overflow protection.\n */\n#define FIO_STR_UTF8_CODE_POINT(ptr, end, i32)                                 \\\n  do {                                                                         \\\n    switch (fio_str_utf8_map[((uint8_t *)(ptr))[0] >> 3]) {                    \\\n    case 1:                                                                    \\\n      (i32) = ((uint8_t *)(ptr))[0];                                           \\\n      ++(ptr);                                                                 \\\n      break;                                                                   \\\n    case 2:                                                                    \\\n      if (((ptr) + 2 > (end)) ||                                               \\\n          fio_str_utf8_map[((uint8_t *)(ptr))[1] >> 3] != 5) {                 \\\n        (i32) = -1;                                                            \\\n        break;                                                                 \\\n      }                                                                        \\\n      (i32) =                                                                  \\\n          ((((uint8_t *)(ptr))[0] & 31) << 6) | (((uint8_t *)(ptr))[1] & 63);  \\\n      (ptr) += 2;                                                              \\\n      break;                                                                   \\\n    case 3:                                                                    \\\n      if (((ptr) + 3 > (end)) ||                                               \\\n          fio_str_utf8_map[((uint8_t *)(ptr))[1] >> 3] != 5 ||                 \\\n          fio_str_utf8_map[((uint8_t *)(ptr))[2] >> 3] != 5) {                 \\\n        (i32) = -1;                                                            \\\n        break;                                                                 \\\n      }                                                                        \\\n      (i32) = ((((uint8_t *)(ptr))[0] & 15) << 12) |                           \\\n              ((((uint8_t *)(ptr))[1] & 63) << 6) |                            \\\n              (((uint8_t *)(ptr))[2] & 63);                                    \\\n      (ptr) += 3;                                                              \\\n      break;                                                                   \\\n    case 4:                                                                    \\\n      if (((ptr) + 4 > (end)) ||                                               \\\n          fio_str_utf8_map[((uint8_t *)(ptr))[1] >> 3] != 5 ||                 \\\n          fio_str_utf8_map[((uint8_t *)(ptr))[2] >> 3] != 5 ||                 \\\n          fio_str_utf8_map[((uint8_t *)(ptr))[3] >> 3] != 5) {                 \\\n        (i32) = -1;                                                            \\\n        break;                                                                 \\\n      }                                                                        \\\n      (i32) = ((((uint8_t *)(ptr))[0] & 7) << 18) |                            \\\n              ((((uint8_t *)(ptr))[1] & 63) << 12) |                           \\\n              ((((uint8_t *)(ptr))[2] & 63) << 6) |                            \\\n              (((uint8_t *)(ptr))[3] & 63);                                    \\\n      (ptr) += 4;                                                              \\\n      break;                                                                   \\\n    default:                                                                   \\\n      (i32) = -1;                                                              \\\n      break;                                                                   \\\n    }                                                                          \\\n  } while (0);\n\n/** Returns 1 if the String is UTF-8 valid and 0 if not. */\nFIO_FUNC size_t fio_str_utf8_valid(fio_str_s *s) {\n  if (!s)\n    return 0;\n  fio_str_info_s state = fio_str_info(s);\n  if (!state.len)\n    return 1;\n  char *const end = state.data + state.len;\n  int32_t c = 0;\n  do {\n    FIO_STR_UTF8_CODE_POINT(state.data, end, c);\n  } while (c > 0 && state.data < end);\n  return state.data == end && c >= 0;\n}\n\n/** Returns the String's length in UTF-8 characters. */\nFIO_FUNC size_t fio_str_utf8_len(fio_str_s *s) {\n  fio_str_info_s state = fio_str_info(s);\n  if (!state.len)\n    return 0;\n  char *end = state.data + state.len;\n  size_t utf8len = 0;\n  int32_t c = 0;\n  do {\n    ++utf8len;\n    FIO_STR_UTF8_CODE_POINT(state.data, end, c);\n  } while (c > 0 && state.data < end);\n  if (state.data != end || c == -1) {\n    /* invalid */\n    return 0;\n  }\n  return utf8len;\n}\n\n/**\n * Takes a UTF-8 character selection information (UTF-8 position and length) and\n * updates the same variables so they reference the raw byte slice information.\n *\n * If the String isn't UTF-8 valid up to the requested selection, than `pos`\n * will be updated to `-1` otherwise values are always positive.\n *\n * The returned `len` value may be shorter than the original if there wasn't\n * enough data left to accomodate the requested length. When a `len` value of\n * `0` is returned, this means that `pos` marks the end of the String.\n *\n * Returns -1 on error and 0 on success.\n */\nFIO_FUNC int fio_str_utf8_select(fio_str_s *s, intptr_t *pos, size_t *len) {\n  fio_str_info_s state = fio_str_info(s);\n  if (!state.data)\n    goto error;\n  if (!state.len || *pos == -1)\n    goto at_end;\n\n  int32_t c = 0;\n  char *p = state.data;\n  char *const end = state.data + state.len;\n  size_t start;\n\n  if (*pos) {\n    if ((*pos) > 0) {\n      start = *pos;\n      while (start && p < end && c >= 0) {\n        FIO_STR_UTF8_CODE_POINT(p, end, c);\n        --start;\n      }\n      if (c == -1)\n        goto error;\n      if (start || p >= end)\n        goto at_end;\n      *pos = p - state.data;\n    } else {\n      /* walk backwards */\n      p = state.data + state.len - 1;\n      c = 0;\n      ++*pos;\n      do {\n        switch (fio_str_utf8_map[((uint8_t *)p)[0] >> 3]) {\n        case 5:\n          ++c;\n          break;\n        case 4:\n          if (c != 3)\n            goto error;\n          c = 0;\n          ++(*pos);\n          break;\n        case 3:\n          if (c != 2)\n            goto error;\n          c = 0;\n          ++(*pos);\n          break;\n        case 2:\n          if (c != 1)\n            goto error;\n          c = 0;\n          ++(*pos);\n          break;\n        case 1:\n          if (c)\n            goto error;\n          ++(*pos);\n          break;\n        default:\n          goto error;\n        }\n        --p;\n      } while (p > state.data && *pos);\n      if (c)\n        goto error;\n      ++p; /* There's always an extra back-step */\n      *pos = (p - state.data);\n    }\n  }\n\n  /* find end */\n  start = *len;\n  while (start && p < end && c >= 0) {\n    FIO_STR_UTF8_CODE_POINT(p, end, c);\n    --start;\n  }\n  if (c == -1 || p > end)\n    goto error;\n  *len = p - (state.data + (*pos));\n  return 0;\n\nat_end:\n  *pos = state.len;\n  *len = 0;\n  return 0;\nerror:\n  *pos = -1;\n  *len = 0;\n  return -1;\n}\n\n/* *****************************************************************************\nString Implementation - Content Manipulation and Review\n***************************************************************************** */\n\n/**\n * Writes data at the end of the String (similar to `fio_str_insert` with the\n * argument `pos == -1`).\n */\ninline FIO_FUNC fio_str_info_s fio_str_write(fio_str_s *s, const void *src,\n                                             size_t src_len) {\n  if (!s || !src_len || !src || s->frozen)\n    return fio_str_info(s);\n  fio_str_info_s state = fio_str_resize(s, src_len + fio_str_len(s));\n  memcpy(state.data + (state.len - src_len), src, src_len);\n  return state;\n}\n\n/**\n * Writes a number at the end of the String using normal base 10 notation.\n */\ninline FIO_FUNC fio_str_info_s fio_str_write_i(fio_str_s *s, int64_t num) {\n  if (!s || s->frozen)\n    return fio_str_info(s);\n  fio_str_info_s i;\n  if (!num)\n    goto zero;\n  char buf[22];\n  uint64_t l = 0;\n  uint8_t neg;\n  if ((neg = (num < 0))) {\n    num = 0 - num;\n    neg = 1;\n  }\n  while (num) {\n    uint64_t t = num / 10;\n    buf[l++] = '0' + (num - (t * 10));\n    num = t;\n  }\n  if (neg) {\n    buf[l++] = '-';\n  }\n  i = fio_str_resize(s, fio_str_len(s) + l);\n\n  while (l) {\n    --l;\n    i.data[i.len - (l + 1)] = buf[l];\n  }\n  return i;\nzero:\n  i = fio_str_resize(s, fio_str_len(s) + 1);\n  i.data[i.len - 1] = '0';\n  return i;\n}\n\n/**\n * Appens the `src` String to the end of the `dest` String.\n */\ninline FIO_FUNC fio_str_info_s fio_str_concat(fio_str_s *dest,\n                                              fio_str_s const *src) {\n  if (!dest || !src || dest->frozen)\n    return fio_str_info(dest);\n  fio_str_info_s src_state = fio_str_info(src);\n  if (!src_state.len)\n    return fio_str_info(dest);\n  fio_str_info_s state =\n      fio_str_resize(dest, src_state.len + fio_str_len(dest));\n  memcpy(state.data + state.len - src_state.len, src_state.data, src_state.len);\n  return state;\n}\n\n/**\n * Replaces the data in the String - replacing `old_len` bytes starting at\n * `start_pos`, with the data at `src` (`src_len` bytes long).\n *\n * Negative `start_pos` values are calculated backwards, `-1` == end of String.\n *\n * When `old_len` is zero, the function will insert the data at `start_pos`.\n *\n * If `src_len == 0` than `src` will be ignored and the data marked for\n * replacement will be erased.\n */\nFIO_FUNC fio_str_info_s fio_str_replace(fio_str_s *s, intptr_t start_pos,\n                                        size_t old_len, const void *src,\n                                        size_t src_len) {\n  fio_str_info_s state = fio_str_info(s);\n  if (!s || s->frozen || (!old_len && !src_len))\n    return state;\n\n  if (start_pos < 0) {\n    /* backwards position indexing */\n    start_pos += s->len + 1;\n    if (start_pos < 0)\n      start_pos = 0;\n  }\n\n  if (start_pos + old_len >= state.len) {\n    /* old_len overflows the end of the String */\n    if (s->small || !s->data) {\n      s->small = 1 | ((size_t)((start_pos << 1) & 0xFF));\n    } else {\n      s->len = start_pos;\n    }\n    return fio_str_write(s, src, src_len);\n  }\n\n  /* data replacement is now always in the middle (or start) of the String */\n  const size_t new_size = state.len + (src_len - old_len);\n\n  if (old_len != src_len) {\n    /* there's an offset requiring an adjustment */\n    if (old_len < src_len) {\n      /* make room for new data */\n      const size_t offset = src_len - old_len;\n      state = fio_str_resize(s, state.len + offset);\n    }\n    memmove(state.data + start_pos + src_len, state.data + start_pos + old_len,\n            (state.len - start_pos) - old_len);\n  }\n  if (src_len) {\n    memcpy(state.data + start_pos, src, src_len);\n  }\n\n  return fio_str_resize(s, new_size);\n}\n\n/** Writes to the String using a vprintf like interface. */\nFIO_FUNC __attribute__((format(printf, 2, 0))) fio_str_info_s\nfio_str_vprintf(fio_str_s *s, const char *format, va_list argv) {\n  va_list argv_cpy;\n  va_copy(argv_cpy, argv);\n  int len = vsnprintf(NULL, 0, format, argv_cpy);\n  va_end(argv_cpy);\n  if (len <= 0)\n    return fio_str_info(s);\n  fio_str_info_s state = fio_str_resize(s, len + fio_str_len(s));\n  vsnprintf(state.data + (state.len - len), len + 1, format, argv);\n  return state;\n}\n\n/** Writes to the String using a printf like interface. */\nFIO_FUNC __attribute__((format(printf, 2, 3))) fio_str_info_s\nfio_str_printf(fio_str_s *s, const char *format, ...) {\n  va_list argv;\n  va_start(argv, format);\n  fio_str_info_s state = fio_str_vprintf(s, format, argv);\n  va_end(argv);\n  return state;\n}\n\n/**\n * Opens the file `filename` and pastes it's contents (or a slice ot it) at the\n * end of the String. If `limit == 0`, than the data will be read until EOF.\n *\n * If the file can't be located, opened or read, or if `start_at` is beyond\n * the EOF position, NULL is returned in the state's `data` field.\n */\nFIO_FUNC fio_str_info_s fio_str_readfile(fio_str_s *s, const char *filename,\n                                         intptr_t start_at, intptr_t limit) {\n  fio_str_info_s state = {.data = NULL};\n#if defined(__unix__) || defined(__linux__) || defined(__APPLE__) ||           \\\n    defined(__CYGWIN__)\n  /* POSIX implementations. */\n  if (filename == NULL || !s)\n    return state;\n  struct stat f_data;\n  int file = -1;\n  char *path = NULL;\n  size_t path_len = 0;\n\n  if (filename[0] == '~' && (filename[1] == '/' || filename[1] == '\\\\')) {\n    char *home = getenv(\"HOME\");\n    if (home) {\n      size_t filename_len = strlen(filename);\n      size_t home_len = strlen(home);\n      if ((home_len + filename_len) >= (1 << 16)) {\n        /* too long */\n        return state;\n      }\n      if (home[home_len - 1] == '/' || home[home_len - 1] == '\\\\')\n        --home_len;\n      path_len = home_len + filename_len - 1;\n      path = FIO_MALLOC(path_len + 1);\n      FIO_ASSERT_ALLOC(path);\n      memcpy(path, home, home_len);\n      memcpy(path + home_len, filename + 1, filename_len);\n      path[path_len] = 0;\n      filename = path;\n    }\n  }\n\n  if (stat(filename, &f_data)) {\n    goto finish;\n  }\n\n  if (f_data.st_size <= 0 || start_at >= f_data.st_size) {\n    state = fio_str_info(s);\n    goto finish;\n  }\n\n  file = open(filename, O_RDONLY);\n  if (-1 == file)\n    goto finish;\n\n  if (start_at < 0) {\n    start_at = f_data.st_size + start_at;\n    if (start_at < 0)\n      start_at = 0;\n  }\n\n  if (limit <= 0 || f_data.st_size < (limit + start_at))\n    limit = f_data.st_size - start_at;\n\n  const size_t org_len = fio_str_len(s);\n  state = fio_str_resize(s, org_len + limit);\n  if (pread(file, state.data + org_len, limit, start_at) != (ssize_t)limit) {\n    fio_str_resize(s, org_len);\n    state.data = NULL;\n    state.len = state.capa = 0;\n  }\n  close(file);\nfinish:\n  FIO_FREE(path);\n  return state;\n#else\n  /* TODO: consider adding non POSIX implementations. */\n  FIO_LOG_ERROR(\"File reading requires a posix system (ignored!).\\n\");\n  return state;\n#endif\n}\n\n/**\n * Prevents further manipulations to the String's content.\n */\ninline FIO_FUNC void fio_str_freeze(fio_str_s *s) {\n  if (!s)\n    return;\n  s->frozen = 1;\n}\n\n/**\n * Binary comparison returns `1` if both strings are equal and `0` if not.\n */\ninline FIO_FUNC int fio_str_iseq(const fio_str_s *str1, const fio_str_s *str2) {\n  if (str1 == str2)\n    return 1;\n  if (!str1 || !str2)\n    return 0;\n  fio_str_info_s s1 = fio_str_info(str1);\n  fio_str_info_s s2 = fio_str_info(str2);\n  return (s1.len == s2.len && !memcmp(s1.data, s2.data, s1.len));\n}\n\n/**\n * `fio_str_send_free2` sends the fio_str_s using `fio_write2`, freeing the\n * String once the data was sent\n *\n * As the naming indicates, the String is assumed to have been allocated using\n * `fio_str_new2` or `fio_malloc`.\n */\ninline FIO_FUNC ssize_t fio_str_send_free2(const intptr_t uuid,\n                                           const fio_str_s *str) {\n  if (!str)\n    return 0;\n  fio_str_info_s state = fio_str_info(str);\n  return fio_write2(uuid, .data.buffer = str, .length = state.len,\n                    .offset = ((uintptr_t)state.data - (uintptr_t)str),\n                    .after.dealloc = (void (*)(void *))fio_str_free2);\n}\n\n#undef ROUND_UP_CAPA2WORDS\n#undef FIO_STR_SMALL_DATA\n#undef FIO_STR_NO_REF\n\n#endif /* H_FIO_STR_H */\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n\n\n\n\n                               Dynamic Array Data-Store\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n#ifdef FIO_ARY_NAME\n/**\n * A simple typed dynamic array with a minimal API.\n *\n * To create an Array type, define the macro FIO_ARY_NAME. i.e.:\n *\n *         #define FIO_ARY_NAME fio_cstr_ary\n *         #define FIO_ARY_TYPE char *\n *         #define FIO_ARY_COMPARE(k1, k2) (!strcmp((k1), (k2)))\n *         #include <fio.h>\n *\n * It's possible to create a number of Array types by reincluding the fio.h\n * header. i.e.:\n *\n *\n *         #define FIO_INCLUDE_STR\n *         #include <fio.h> // adds the fio_str_s types and functions\n *\n *         #define FIO_ARY_NAME fio_int_ary\n *         #define FIO_ARY_TYPE int\n *         #include <fio.h> // creates the fio_int_ary_s Array and functions\n *\n *         #define FIO_ARY_NAME fio_str_ary\n *         #define FIO_ARY_TYPE fio_str_s *\n *         #define FIO_ARY_COMPARE(k1, k2) (fio_str_iseq((k1), (k2)))\n *         #define FIO_ARY_COPY(key) fio_str_dup((key))\n *         #define FIO_ARY_DESTROY(key) fio_str_free2((key))\n *         #include <fio.h> // creates the fio_str_ary_s Array and functions\n *\n * Note: Before freeing the Array, FIO_ARY_DESTROY will be automatically called\n *       for every existing object, including any invalid objects (if any).\n */\n\n/* Used for naming functions and types, prefixing FIO_ARY_NAME to the name */\n#define FIO_NAME_FROM_MACRO_STEP2(name, postfix) name##_##postfix\n#define FIO_NAME_FROM_MACRO_STEP1(name, postfix)                               \\\n  FIO_NAME_FROM_MACRO_STEP2(name, postfix)\n#define FIO_NAME(postfix) FIO_NAME_FROM_MACRO_STEP1(FIO_ARY_NAME, postfix)\n\n/* Used for naming the `free` function */\n#define FIO_NAME_FROM_MACRO_STEP4(name) name##_free\n#define FIO_NAME_FROM_MACRO_STEP3(name) FIO_NAME_FROM_MACRO_STEP4(name)\n#define FIO_NAME_FREE() FIO_NAME_FROM_MACRO_STEP3(FIO_ARY_NAME)\n\n/* The default Array object type is `void *` */\n#if !defined(FIO_ARY_TYPE)\n#define FIO_ARY_TYPE void *\n#endif\n\n/* An invalid object has all bytes set to 0 - a static constant will do. */\n#if !defined(FIO_ARY_INVALID)\nstatic FIO_ARY_TYPE const FIO_NAME(s___const_invalid_object);\n#define FIO_ARY_INVALID FIO_NAME(s___const_invalid_object)\n#endif\n\n/* The default Array comparison assumes a simple type */\n#if !defined(FIO_ARY_COMPARE)\n#define FIO_ARY_COMPARE(o1, o2) ((o1) == (o2))\n#endif\n\n/** object copy required? */\n#ifndef FIO_ARY_COPY\n#define FIO_ARY_COPY_IS_SIMPLE 1\n#define FIO_ARY_COPY(dest, obj) ((dest) = (obj))\n#endif\n\n/** object destruction required? */\n#ifndef FIO_ARY_DESTROY\n#define FIO_ARY_DESTROY(obj) ((void)0)\n#endif\n\n/* Customizable memory management */\n#ifndef FIO_ARY_MALLOC /* NULL ptr indicates new allocation */\n#define FIO_ARY_MALLOC(size) FIO_MALLOC((size))\n#endif\n\n/* Customizable memory management */\n#ifndef FIO_ARY_REALLOC /* NULL ptr indicates new allocation */\n#define FIO_ARY_REALLOC(ptr, original_size, new_size, valid_data_length)       \\\n  FIO_REALLOC((ptr), (new_size), (valid_data_length))\n#endif\n\n#ifndef FIO_ARY_DEALLOC\n#define FIO_ARY_DEALLOC(ptr, size) FIO_FREE((ptr))\n#endif\n\n/* padding to be assumed for future expansion. */\n#ifndef FIO_ARY_PADDING\n#define FIO_ARY_PADDING 4\n#endif\n\n/* minimizes allocation \"dead space\" by alligning allocated length to 16bytes */\n#undef FIO_ARY_SIZE2WORDS\n#define FIO_ARY_SIZE2WORDS(size)                                               \\\n  ((sizeof(FIO_ARY_TYPE) & 1)                                                  \\\n       ? (((size) & (~15)) + 16)                                               \\\n       : (sizeof(FIO_ARY_TYPE) & 2)                                            \\\n             ? (((size) & (~7)) + 8)                                           \\\n             : (sizeof(FIO_ARY_TYPE) & 4)                                      \\\n                   ? (((size) & (~3)) + 4)                                     \\\n                   : (sizeof(FIO_ARY_TYPE) & 8) ? (((size) & (~1)) + 2)        \\\n                                                : (size))\n\n/* *****************************************************************************\nArray API\n***************************************************************************** */\n\n/** The Array container type. */\ntypedef struct FIO_NAME(s) FIO_NAME(s);\n\n#ifndef FIO_ARY_INIT\n/** Initializes the Array */\n#define FIO_ARY_INIT                                                           \\\n  { .capa = 0 }\n#endif\n\n/** Frees the array's internal data. */\nFIO_FUNC inline void FIO_NAME_FREE()(FIO_NAME(s) * ary);\n\n/** Returns the number of elements in the Array. */\nFIO_FUNC inline size_t FIO_NAME(count)(FIO_NAME(s) * ary);\n\n/** Returns the current, temporary, array capacity (it's dynamic). */\nFIO_FUNC inline size_t FIO_NAME(capa)(FIO_NAME(s) * ary);\n\n/**\n * Adds all the items in the `src` Array to the end of the `dest` Array.\n *\n * The `src` Array remain untouched.\n */\nFIO_FUNC inline void FIO_NAME(concat)(FIO_NAME(s) * dest, FIO_NAME(s) * src);\n\n/**\n * Sets `index` to the value in `data`.\n *\n * If `index` is negative, it will be counted from the end of the Array (-1 ==\n * last element).\n *\n * If `old` isn't NULL, the existing data will be copied to the location pointed\n * to by `old` before the copy in the Array is destroyed.\n */\nFIO_FUNC inline void FIO_NAME(set)(FIO_NAME(s) * ary, intptr_t index,\n                                   FIO_ARY_TYPE data, FIO_ARY_TYPE *old);\n\n/**\n * Returns the value located at `index` (no copying is peformed).\n *\n * If `index` is negative, it will be counted from the end of the Array (-1 ==\n * last element).\n */\nFIO_FUNC inline FIO_ARY_TYPE FIO_NAME(get)(FIO_NAME(s) * ary, intptr_t index);\n\n/**\n * Returns the index of the object or -1 if the object wasn't found.\n */\nFIO_FUNC inline intptr_t FIO_NAME(find)(FIO_NAME(s) * ary, FIO_ARY_TYPE data);\n\n/**\n * Removes an object from the array, MOVING all the other objects to prevent\n * \"holes\" in the data.\n *\n * If `old` is set, the data is copied to the location pointed to by `old`\n * before the data in the array is destroyed.\n *\n * Returns 0 on success and -1 on error.\n */\nFIO_FUNC inline int FIO_NAME(remove)(FIO_NAME(s) * ary, intptr_t index,\n                                     FIO_ARY_TYPE *old);\n\n/**\n * Removes an object from the array, if it exists, MOVING all the other objects\n * to prevent \"holes\" in the data.\n *\n * Returns -1 if the object wasn't found or 0 if the object was successfully\n * removed.\n */\nFIO_FUNC inline int FIO_NAME(remove2)(FIO_NAME(s) * ary, FIO_ARY_TYPE data,\n                                      FIO_ARY_TYPE *old);\n\n/**\n * Returns a pointer to the C array containing the objects.\n */\nFIO_FUNC inline FIO_ARY_TYPE *FIO_NAME(to_a)(FIO_NAME(s) * ary);\n\n/**\n * Pushes an object to the end of the Array. Returns -1 on error.\n */\nFIO_FUNC inline int FIO_NAME(push)(FIO_NAME(s) * ary, FIO_ARY_TYPE data);\n\n/**\n * Removes an object from the end of the Array.\n *\n * If `old` is set, the data is copied to the location pointed to by `old`\n * before the data in the array is destroyed.\n *\n * Returns -1 on error (Array is empty) and 0 on success.\n */\nFIO_FUNC inline int FIO_NAME(pop)(FIO_NAME(s) * ary, FIO_ARY_TYPE *old);\n\n/**\n * Unshifts an object to the beginning of the Array. Returns -1 on error.\n *\n * This could be expensive, causing `memmove`.\n */\nFIO_FUNC inline int FIO_NAME(unshift)(FIO_NAME(s) * ary, FIO_ARY_TYPE data);\n\n/**\n * Removes an object from the beginning of the Array.\n *\n * If `old` is set, the data is copied to the location pointed to by `old`\n * before the data in the array is destroyed.\n *\n * Returns -1 on error (Array is empty) and 0 on success.\n */\nFIO_FUNC inline int FIO_NAME(shift)(FIO_NAME(s) * ary, FIO_ARY_TYPE *old);\n\n/**\n * Iteration using a callback for each entry in the array.\n *\n * The callback task function must accept an the entry data as well as an opaque\n * user pointer.\n *\n * If the callback returns -1, the loop is broken. Any other value is ignored.\n *\n * Returns the relative \"stop\" position, i.e., the number of items processed +\n * the starting point.\n */\nFIO_FUNC inline size_t FIO_NAME(each)(FIO_NAME(s) * ary, size_t start_at,\n                                      int (*task)(FIO_ARY_TYPE pt, void *arg),\n                                      void *arg);\n/**\n * Removes any FIO_ARY_TYPE_INVALID object from an Array (NULL pointers by\n * default), keeping all other data in the array.\n *\n * This action is O(n) where n in the length of the array.\n * It could get expensive.\n */\nFIO_FUNC inline void FIO_NAME(compact)(FIO_NAME(s) * ary);\n\n/**\n * Iterates through the list using a `for` loop.\n *\n * Access the object with the pointer `pos`. The `pos` variable can be named\n * however you please.\n *\n * Avoid editing the array during a FOR loop, although I hope it's possible, I\n * wouldn't count on it.\n */\n#ifndef FIO_ARY_FOR\n#define FIO_ARY_FOR(ary, pos)                                                  \\\n  if ((ary)->arry)                                                             \\\n    for (__typeof__((ary)->arry) start__tmp__ = (ary)->arry,                   \\\n                                 pos = ((ary)->arry + (ary)->start);           \\\n         pos < (ary)->arry + (ary)->end;                                       \\\n         (pos = (ary)->arry + (pos - start__tmp__) + 1),                       \\\n                                 (start__tmp__ = (ary)->arry))\n#endif\n\n/* *****************************************************************************\nArray Type\n***************************************************************************** */\n\nstruct FIO_NAME(s) {\n  size_t start;       /* first index where data was already written */\n  size_t end;         /* next spot to write at tail */\n  size_t capa;        /* existing capacity */\n  FIO_ARY_TYPE *arry; /* the actual array's memory, if any */\n};\n\n/* *****************************************************************************\nArray Memory Management\n***************************************************************************** */\n\nFIO_FUNC inline void FIO_NAME_FREE()(FIO_NAME(s) * ary) {\n  if (ary) {\n    const size_t count = ary->end;\n    for (size_t i = ary->start; i < count; ++i) {\n      FIO_ARY_DESTROY((ary->arry[i]));\n    }\n    FIO_ARY_DEALLOC(ary->arry, ary->capa * sizeof(*ary->arry));\n    *ary = (FIO_NAME(s))FIO_ARY_INIT;\n  }\n}\n\n/** Converts between a relative index to an absolute index. */\nFIO_FUNC inline intptr_t FIO_NAME(__rel2absolute)(FIO_NAME(s) * ary,\n                                                  intptr_t index) {\n  if (index >= 0)\n    return index;\n  index += ary->end - ary->start;\n  if (index >= 0)\n    return index;\n  return 0;\n}\n\n/** Makes sure that `len` positions are available at the Array's end. */\nFIO_FUNC void FIO_NAME(__require_on_top)(FIO_NAME(s) * ary, size_t len) {\n  if (ary->end + len < ary->capa)\n    return;\n  len = FIO_ARY_SIZE2WORDS((len + ary->end));\n  /* reallocate enough memory */\n  ary->arry = FIO_ARY_REALLOC(ary->arry, sizeof(*ary->arry) * ary->capa,\n                              (len) * sizeof(*ary->arry),\n                              ary->end * sizeof(*ary->arry));\n  FIO_ASSERT_ALLOC(ary->arry);\n  ary->capa = len;\n}\n\n/** Makes sure that `len` positions are available at the Array's head. */\nFIO_FUNC void FIO_NAME(__require_on_bottom)(FIO_NAME(s) * ary, size_t len) {\n  if (ary->start >= len)\n    return;\n  FIO_ARY_TYPE *tmp = ary->arry;\n  len = FIO_ARY_SIZE2WORDS((len - ary->start) + ary->end);\n  if (ary->capa <= len) {\n    /* no room - allocate and copy */\n    ary->arry = FIO_ARY_MALLOC(len * sizeof(*ary->arry));\n    FIO_ASSERT_ALLOC(ary->arry);\n    ary->capa = len;\n  }\n  /* move existing data to the end of the existing space */\n  len = ary->end - ary->start;\n  ary->end = ary->capa;\n  if (len)\n    memmove(ary->arry + (ary->capa - len), tmp + ary->start,\n            len * sizeof(*ary->arry));\n  ary->start = ary->end - len;\n  if (tmp != ary->arry) {\n    FIO_FREE(tmp);\n  }\n}\n\n/* *****************************************************************************\nArray API implementation\n***************************************************************************** */\n\n/** Returns the number of elements in the Array. */\nFIO_FUNC inline size_t FIO_NAME(count)(FIO_NAME(s) * ary) {\n  return ary ? (ary->end - ary->start) : 0;\n}\n\n/** Returns the current, temporary, array capacity (it's dynamic). */\nFIO_FUNC inline size_t FIO_NAME(capa)(FIO_NAME(s) * ary) {\n  return ary ? ary->capa : 0;\n}\n\n/**\n * Returns a pointer to the C array containing the objects.\n */\nFIO_FUNC inline FIO_ARY_TYPE *FIO_NAME(to_a)(FIO_NAME(s) * ary) {\n  return ary ? (ary->arry + ary->start) : NULL;\n}\n\n/**\n * Adds all the items in the `src` Array to the end of the `dest` Array.\n *\n * The `src` Array remain untouched.\n */\nFIO_FUNC inline void FIO_NAME(concat)(FIO_NAME(s) * dest, FIO_NAME(s) * src) {\n  if (!src)\n    return;\n  const size_t added = FIO_NAME(count)(src);\n  if (!added || !dest)\n    return;\n  FIO_NAME(__require_on_top)(dest, added);\n#if FIO_ARY_COPY_IS_SIMPLE\n  memcpy(dest->arry + dest->end, src->arry + src->start,\n         added * sizeof(*dest->arry));\n#else\n  /* don't use memcpy, in case copying has side-effects (see macro) */\n  for (size_t i = 0; i < added; ++i) {\n    FIO_ARY_COPY(((dest->arry + dest->end)[i]), ((src->arry + src->start)[i]));\n  }\n#endif\n  dest->end += added;\n}\n\n/**\n * Sets `index` to the value in `data`.\n *\n * If `index` is negative, it will be counted from the end of the Array (-1 ==\n * last element).\n *\n * If `old` isn't NULL, the existing data will be copied to the location pointed\n * to by `old` before the copy in the Array is destroyed.\n */\nFIO_FUNC inline void FIO_NAME(set)(FIO_NAME(s) * ary, intptr_t index,\n                                   FIO_ARY_TYPE data, FIO_ARY_TYPE *old) {\n  if (!ary)\n    return;\n  if (ary->start == ary->end) /* reset memory starting point? */\n    ary->start = ary->end = 0;\n\n  index = FIO_NAME(__rel2absolute)(ary, index);\n\n  const intptr_t spaces = index - (ary->end - ary->start);\n  if (spaces < 0) {\n    /* likely */\n    if (old)\n      FIO_ARY_COPY((*old), ((ary->arry + ary->start)[index]));\n    FIO_ARY_DESTROY(((ary->arry + ary->start)[index]));\n    FIO_ARY_COPY(((ary->arry + ary->start)[index]), data);\n    return;\n  }\n\n  /* fill empty spaces with zero */\n  FIO_NAME(__require_on_top)(ary, spaces + 1);\n  if (spaces) {\n    memset(ary->arry + ary->end, 0, sizeof(*ary->arry) * spaces);\n  }\n  FIO_ARY_COPY(((ary->arry + ary->start)[index]), data);\n  ary->end = index + 1;\n}\n\n/**\n * Returns the value located at `index` (no copying is peformed).\n *\n * If `index` is negative, it will be counted from the end of the Array (-1 ==\n * last element).\n */\nFIO_FUNC inline FIO_ARY_TYPE FIO_NAME(get)(FIO_NAME(s) * ary, intptr_t index) {\n  if (!ary)\n    return FIO_ARY_INVALID;\n  index = FIO_NAME(__rel2absolute)(ary, index);\n  if ((size_t)index >= ary->end - ary->start)\n    return FIO_ARY_INVALID;\n  return (ary->arry + ary->start)[index];\n}\n\n/**\n * Returns the index of the object or -1 if the object wasn't found.\n */\nFIO_FUNC inline intptr_t FIO_NAME(find)(FIO_NAME(s) * ary, FIO_ARY_TYPE data) {\n  const size_t count = FIO_NAME(count)(ary);\n  if (!count) {\n    return -1;\n  }\n  size_t pos = ary->start;\n  register const size_t end = ary->end;\n  while (pos < end && !FIO_ARY_COMPARE(data, ary->arry[pos])) {\n    ++pos;\n  }\n  if (pos == end)\n    return -1;\n  return (pos - ary->start);\n}\n\n/**\n * Removes an object from the array, MOVING all the other objects to prevent\n * \"holes\" in the data.\n *\n * If `old` is set, the data is copied to the location pointed to by `old`\n * before the data in the array is destroyed.\n *\n * Returns 0 on success and -1 on error.\n */\nFIO_FUNC inline int FIO_NAME(remove)(FIO_NAME(s) * ary, intptr_t index,\n                                     FIO_ARY_TYPE *old) {\n  index = FIO_NAME(__rel2absolute)(ary, index);\n  const size_t count = FIO_NAME(count)(ary);\n  if (!count || (size_t)index >= count) {\n    return -1;\n  }\n  index += ary->start;\n  if (old)\n    FIO_ARY_COPY((*old), (ary->arry[index]));\n  FIO_ARY_DESTROY((ary->arry[index]));\n  if ((size_t)index == ary->start) {\n    ++ary->start;\n    return 0;\n  }\n  --ary->end;\n  if ((size_t)index < ary->end) {\n    memmove(ary->arry + index, ary->arry + index + 1,\n            (ary->end - index) * sizeof(*ary->arry));\n  }\n  return 0;\n}\n\n/**\n * Removes an object from the array, if it exists, MOVING all the other objects\n * to prevent \"holes\" in the data.\n *\n * Returns -1 if the object wasn't found or 0 if the object was successfully\n * removed.\n */\nFIO_FUNC inline int FIO_NAME(remove2)(FIO_NAME(s) * ary, FIO_ARY_TYPE data,\n                                      FIO_ARY_TYPE *old) {\n  intptr_t index = FIO_NAME(find)(ary, data);\n  if (index == -1) {\n    return -1;\n  }\n  return FIO_NAME(remove)(ary, index, old);\n}\n\n/**\n * Pushes an object to the end of the Array. Returns -1 on error.\n */\nFIO_FUNC inline int FIO_NAME(push)(FIO_NAME(s) * ary, FIO_ARY_TYPE data) {\n  if (!ary)\n    return -1;\n  if (ary->capa <= ary->end)\n    FIO_NAME(__require_on_top)(ary, 1 + FIO_ARY_PADDING);\n  if (ary->start == ary->end) /* reset memory starting point? */\n    ary->start = ary->end = 0;\n  FIO_ARY_COPY(ary->arry[ary->end], data);\n  ++ary->end;\n  return 0;\n}\n\n/**\n * Removes an object from the end of the Array.\n *\n * If `old` is set, the data is copied to the location pointed to by `old`\n * before the data in the array is destroyed.\n *\n * Returns -1 on error (Array is empty) and 0 on success.\n */\nFIO_FUNC inline int FIO_NAME(pop)(FIO_NAME(s) * ary, FIO_ARY_TYPE *old) {\n  if (!FIO_NAME(count)(ary))\n    return -1;\n  --ary->end;\n  if (old)\n    FIO_ARY_COPY((*old), (ary->arry[ary->end]));\n  FIO_ARY_DESTROY((ary->arry[ary->end]));\n  return 0;\n}\n\n/**\n * Unshifts an object to the beginning of the Array. Returns -1 on error.\n *\n * This could be expensive, causing `memmove`.\n */\nFIO_FUNC inline int FIO_NAME(unshift)(FIO_NAME(s) * ary, FIO_ARY_TYPE data) {\n  if (!ary)\n    return -1;\n  if (ary->start == 0)\n    FIO_NAME(__require_on_bottom)(ary, 8);\n  --ary->start;\n  FIO_ARY_COPY(ary->arry[ary->start], data);\n  return 0;\n}\n\n/**\n * Removes an object from the beginning of the Array.\n *\n * If `old` is set, the data is copied to the location pointed to by `old`\n * before the data in the array is destroyed.\n *\n * Returns -1 on error (Array is empty) and 0 on success.\n */\nFIO_FUNC inline int FIO_NAME(shift)(FIO_NAME(s) * ary, FIO_ARY_TYPE *old) {\n  if (!FIO_NAME(count)(ary))\n    return -1;\n  if (old)\n    FIO_ARY_COPY((*old), (ary->arry[ary->start]));\n  FIO_ARY_DESTROY((ary->arry[ary->start]));\n  ++ary->start;\n  return 0;\n}\n\n/**\n * Iteration using a callback for each entry in the array.\n *\n * The callback task function must accept an the entry data as well as an opaque\n * user pointer.\n *\n * If the callback returns -1, the loop is broken. Any other value is ignored.\n *\n * Returns the relative \"stop\" position, i.e., the number of items processed +\n * the starting point.\n */\nFIO_FUNC inline size_t FIO_NAME(each)(FIO_NAME(s) * ary, size_t start_at,\n                                      int (*task)(FIO_ARY_TYPE pt, void *arg),\n                                      void *arg) {\n  const size_t count = FIO_NAME(count)(ary);\n  if (!count || start_at >= count) {\n    return count;\n  }\n  while (start_at < count &&\n         task(ary->arry[ary->start + (start_at++)], arg) != -1)\n    ;\n  return start_at;\n}\n/**\n * Removes any FIO_ARY_TYPE_INVALID object from an Array (NULL pointers by\n * default), keeping all other data in the array.\n *\n * This action is O(n) where n in the length of the array.\n * It could get expensive.\n */\nFIO_FUNC inline void FIO_NAME(compact)(FIO_NAME(s) * ary) {\n  const size_t count = FIO_NAME(count)(ary);\n  if (!count)\n    return;\n  register FIO_ARY_TYPE *pos = ary->arry + ary->start;\n  register FIO_ARY_TYPE *reader = ary->arry + ary->start;\n  register FIO_ARY_TYPE *stop = ary->arry + ary->end;\n  while (reader < stop) {\n    if (!FIO_ARY_COMPARE((*reader), FIO_ARY_INVALID)) {\n      *pos = *reader;\n      pos += 1;\n    }\n    reader += 1;\n  }\n  ary->end = (size_t)(pos - ary->arry);\n}\n\n/* *****************************************************************************\nArray Testing\n***************************************************************************** */\n\n#if DEBUG\n#include <stdio.h>\n#define TEST_LIMIT 1016\n/**\n * Removes any FIO_ARY_TYPE_INVALID  *pointers* from an Array, keeping all other\n * data in the array.\n *\n * This action is O(n) where n in the length of the array.\n * It could get expensive.\n */\nFIO_FUNC inline void FIO_NAME(_test)(void) {\n  union {\n    FIO_ARY_TYPE obj;\n    uintptr_t i;\n  } mem;\n  FIO_NAME(s) ary = FIO_ARY_INIT;\n  fprintf(stderr, \"=== Testing Core Array features for type \" FIO_MACRO2STR(\n                      FIO_ARY_TYPE) \"\\n\");\n\n  for (uintptr_t i = 0; i < TEST_LIMIT; ++i) {\n    mem.i = i + 1;\n    FIO_NAME(push)(&ary, mem.obj);\n  }\n  fprintf(stderr,\n          \"* Array populated using `push` with %zu items,\\n\"\n          \"  with capacity limit of %zu and start index %zu\\n\",\n          (size_t)FIO_NAME(count)(&ary), (size_t)FIO_NAME(capa)(&ary),\n          ary.start);\n  FIO_ASSERT(FIO_NAME(count)(&ary) == TEST_LIMIT,\n             \"Wrong object count for array %zu\", (size_t)FIO_NAME(count)(&ary));\n  for (uintptr_t i = 0; i < TEST_LIMIT; ++i) {\n    FIO_ASSERT(!FIO_NAME(shift)(&ary, &mem.obj), \"Array shift failed at %lu.\",\n               i);\n    FIO_ASSERT(mem.i == i + 1, \"Array shift value error %lu != %lu\", mem.i,\n               i + 1);\n    FIO_ARY_DESTROY(mem.obj);\n  }\n\n  FIO_NAME_FREE()(&ary);\n  FIO_ASSERT(!ary.arry, \"Array not reset after fio_ary_free\");\n\n  for (uintptr_t i = 0; i < TEST_LIMIT; ++i) {\n    mem.i = TEST_LIMIT - i;\n    FIO_NAME(unshift)(&ary, mem.obj);\n  }\n  fprintf(stderr,\n          \"* Array populated using `unshift` with %zu items,\\n\"\n          \"  with capacity limit of %zu and start index %zu\\n\",\n          (size_t)FIO_NAME(count)(&ary), (size_t)FIO_NAME(capa)(&ary),\n          ary.start);\n\n  FIO_ASSERT(FIO_NAME(count)(&ary) == TEST_LIMIT,\n             \"Wrong object count for array %zu\", (size_t)FIO_NAME(count)(&ary));\n  for (uintptr_t i = 0; i < TEST_LIMIT; ++i) {\n    FIO_NAME(pop)(&ary, &mem.obj);\n    FIO_ASSERT(mem.i == TEST_LIMIT - i, \"Array pop value error\");\n    FIO_ARY_DESTROY(mem.obj);\n  }\n  FIO_NAME_FREE()(&ary);\n  FIO_ASSERT(!ary.arry, \"Array not reset after fio_ary_free\");\n\n  for (uintptr_t i = 0; i < TEST_LIMIT; ++i) {\n    mem.i = TEST_LIMIT - i;\n    FIO_NAME(unshift)(&ary, mem.obj);\n  }\n\n  for (size_t i = 0; i < TEST_LIMIT; ++i) {\n    mem.i = i + 1;\n    FIO_ASSERT(FIO_NAME(find)(&ary, mem.obj) == (intptr_t)i,\n               \"Wrong object index - ary[%zd] != %zu\",\n               (ssize_t)FIO_NAME(find)(&ary, mem.obj), (size_t)mem.i);\n    mem.obj = FIO_NAME(get)(&ary, i);\n    FIO_ASSERT(mem.i == (uintptr_t)(i + 1),\n               \"Wrong object returned from fio_ary_index - ary[%zu] != %zu\", i,\n               i + 1);\n  }\n\n  FIO_ASSERT((FIO_NAME(count)(&ary) == TEST_LIMIT),\n             \"Wrong object count before pop %zu\",\n             (size_t)FIO_NAME(count)(&ary));\n  FIO_ASSERT(!FIO_NAME(pop)(&ary, &mem.obj), \"Couldn't pop element.\");\n  FIO_ASSERT(mem.i == TEST_LIMIT, \"Element value error (%zu).\", (size_t)mem.i);\n  FIO_ASSERT((FIO_NAME(count)(&ary) == TEST_LIMIT - 1),\n             \"Wrong object count after pop %zu\", (size_t)FIO_NAME(count)(&ary));\n  FIO_ARY_DESTROY(mem.obj);\n\n  mem.i = (TEST_LIMIT >> 1);\n  FIO_ASSERT(!FIO_NAME(remove2)(&ary, mem.obj, NULL),\n             \"Couldn't fio_ary_remove2 object from Array (%zu)\", (size_t)mem.i);\n  FIO_ASSERT(FIO_NAME(count)(&ary) == TEST_LIMIT - 2,\n             \"Wrong object count after remove2 %zu\",\n             (size_t)FIO_NAME(count)(&ary));\n  mem.i = (TEST_LIMIT >> 1) + 1;\n  FIO_ASSERT(FIO_NAME(find)(&ary, mem.obj) != (TEST_LIMIT >> 1) + 1,\n             \"fio_ary_remove2 didn't clear holes from Array (%zu)\",\n             (size_t)FIO_NAME(find)(&ary, mem.obj));\n  FIO_ARY_DESTROY(mem.obj);\n\n  FIO_ASSERT(!FIO_NAME(remove)(&ary, 0, &mem.obj),\n             \"fio_ary_remove failed (at %zd)\", (ssize_t)mem.i);\n  FIO_ASSERT(mem.i == 1, \"Couldn't fio_ary_remove object from Array (%zd)\",\n             (ssize_t)mem.i);\n  FIO_ASSERT(FIO_NAME(count)(&ary) == TEST_LIMIT - 3,\n             \"Wrong object count after remove %zu != %d\",\n             (size_t)FIO_NAME(count)(&ary), TEST_LIMIT - 3);\n  FIO_ASSERT(FIO_NAME(find)(&ary, mem.obj) == -1,\n             \"fio_ary_find should have failed after fio_ary_remove (%zd)\",\n             (ssize_t)FIO_NAME(find)(&ary, mem.obj));\n  FIO_ARY_DESTROY(mem.obj);\n\n  mem.i = 2;\n  FIO_ASSERT(FIO_NAME(find)(&ary, mem.obj) == 0,\n             \"fio_ary_remove didn't clear holes from Array (%zu)\",\n             (size_t)FIO_NAME(find)(&ary, mem.obj));\n\n  FIO_NAME_FREE()(&ary);\n\n  FIO_NAME(s) ary2 = FIO_ARY_INIT;\n  for (uintptr_t i = 0; i < (TEST_LIMIT >> 1); ++i) {\n    mem.i = ((TEST_LIMIT >> 1) << 1) - i;\n    FIO_NAME(unshift)(&ary2, mem.obj);\n    mem.i = (TEST_LIMIT >> 1) - i;\n    FIO_NAME(unshift)(&ary, mem.obj);\n  }\n  FIO_NAME(concat)(&ary, &ary2);\n  FIO_NAME_FREE()(&ary2);\n  FIO_ASSERT(FIO_NAME(count)(&ary) == ((TEST_LIMIT >> 1) << 1),\n             \"Wrong object count after fio_ary_concat %zu\",\n             (size_t)FIO_NAME(count)(&ary));\n  for (int i = 0; i < ((TEST_LIMIT >> 1) << 1); ++i) {\n    mem.obj = FIO_NAME(get)(&ary, i);\n    FIO_ASSERT(\n        mem.i == (uintptr_t)(i + 1),\n        \"Wrong object returned from fio_ary_index after concat - ary[%d] != %d\",\n        i, i + 1);\n  }\n  mem.i = 0;\n  while (FIO_NAME(pop)(&ary, &mem.obj)) {\n    ++mem.i;\n    FIO_ARY_DESTROY(mem.obj);\n  }\n  FIO_ASSERT(mem.i == ((TEST_LIMIT >> 1) << 1), \"fio_ary_pop overflow (%zu)?\",\n             (size_t)mem.i);\n  FIO_NAME_FREE()(&ary);\n}\n#undef TEST_LIMIT\n#else\nFIO_FUNC inline void FIO_NAME(_test)(void) {}\n#endif\n\n/* *****************************************************************************\nDone\n***************************************************************************** */\n\n#undef FIO_NAME_FROM_MACRO_STEP2\n#undef FIO_NAME_FROM_MACRO_STEP1\n#undef FIO_NAME\n#undef FIO_NAME_FROM_MACRO_STEP4\n#undef FIO_NAME_FROM_MACRO_STEP3\n#undef FIO_NAME_FREE\n#undef FIO_ARY_NAME\n#undef FIO_ARY_TYPE\n#undef FIO_ARY_INVALID\n#undef FIO_ARY_COMPARE\n#undef FIO_ARY_COPY\n#undef FIO_ARY_COPY_IS_SIMPLE\n#undef FIO_ARY_DESTROY\n#undef FIO_ARY_REALLOC\n#undef FIO_ARY_DEALLOC\n#undef FIO_ARY_SIZE2WORDS\n\n#endif\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n\n\n\n\n                               Set / Hash Map Data-Store\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n#ifdef FIO_SET_NAME\n\n/**\n * A simple ordered Set / Hash Map implementation, with a minimal API.\n *\n * A Set is basically a Hash Map where the keys are also the values, it's often\n * used for caching objects.\n *\n * The Set's object type and behavior is controlled by the FIO_SET_OBJ_* marcos.\n *\n * A Hash Map is basically a set where the objects in the Set are key-value\n * couplets and only the keys are tested when searching the Set.\n *\n * To create a Set or a Hash Map, the macro FIO_SET_NAME must be defined. i.e.:\n *\n *         #define FIO_SET_NAME cstr_set\n *         #define FIO_SET_OBJ_TYPE char *\n *         #define FIO_SET_OBJ_COMPARE(k1, k2) (!strcmp((k1), (k2)))\n *         #include <fio.h>\n *\n * To create a Hash Map, rather than a pure Set, the macro FIO_SET_KEY_TYPE must\n * be defined. i.e.:\n *\n *         #define FIO_SET_KEY_TYPE char *\n *\n * This allows the FIO_SET_KEY_* macros to be defined as well. For example:\n *\n *         #define FIO_SET_NAME cstr_hashmap\n *         #define FIO_SET_KEY_TYPE char *\n *         #define FIO_SET_KEY_COMPARE(k1, k2) (!strcmp((k1), (k2)))\n *         #define FIO_SET_OBJ_TYPE char *\n *         #include <fio.h>\n *\n * It's possible to create a number of Set or HasMap types by reincluding the\n * fio.h header. i.e.:\n *\n *\n *         #define FIO_INCLUDE_STR\n *         #include <fio.h> // adds the fio_str_s types and functions\n *\n *         #define FIO_SET_NAME fio_str_set\n *         #define FIO_SET_OBJ_TYPE fio_str_s *\n *         #define FIO_SET_OBJ_COMPARE(k1, k2) (fio_str_iseq((k1), (k2)))\n *         #define FIO_SET_OBJ_COPY(key) fio_str_dup((key))\n *         #define FIO_SET_OBJ_DESTROY(key) fio_str_free2((key))\n *         #include <fio.h> // creates the fio_str_set_s Set and functions\n *\n *         #define FIO_SET_NAME fio_str_hash\n *         #define FIO_SET_KEY_TYPE fio_str_s *\n *         #define FIO_SET_KEY_COMPARE(k1, k2) (fio_str_iseq((k1), (k2)))\n *         #define FIO_SET_KEY_COPY(key) fio_str_dup((key))\n *         #define FIO_SET_KEY_DESTROY(key) fio_str_free2((key))\n *         #define FIO_SET_OBJ_TYPE fio_str_s *\n *         #define FIO_SET_OBJ_COMPARE(k1, k2) (fio_str_iseq((k1), (k2)))\n *         #define FIO_SET_OBJ_COPY(key) fio_str_dup((key))\n *         #define FIO_SET_OBJ_DESTROY(key) fio_str_free2((key))\n *         #include <fio.h> // creates the fio_str_hash_s Hash Map and functions\n *\n * The default integer Hash used is a pointer length type (uintptr_t). This can\n * be changed by defining ALL of the following macros:\n * * FIO_SET_HASH_TYPE              - the type of the hash value.\n * * FIO_SET_HASH2UINTPTR(hash, i)  - converts the hash value to a uintptr_t.\n * * FIO_SET_HASH_COMPARE(h1, h2)   - compares two hash values (1 == equal).\n * * FIO_SET_HASH_INVALID           - an invalid Hash value, all bytes are 0.\n * * FIO_SET_HASH_FORCE             - an always valid Hash value, all bytes 0xFF\n *\n *\n * Note: FIO_SET_HASH_TYPE should, normaly be left alone (uintptr_t is\n *       enough). Also, the hash value 0 is reserved to indicate an empty slot.\n *\n * Note: the FIO_SET_OBJ_COMPARE for Sets or the FIO_SET_KEY_COMPARE will be\n *       used to compare against invalid as well as valid objects. Invalid\n *       objects have their bytes all zero. FIO_SET_*_DESTROY should somehow\n *       mark them as invalid.\n *\n * Note: Before freeing the Set, FIO_SET_OBJ_DESTROY will be automatically\n *       called for every existing object.\n */\n\n/* Used for naming functions and types, prefixing FIO_SET_NAME to the name */\n#define FIO_NAME_FROM_MACRO_STEP2(name, postfix) name##_##postfix\n#define FIO_NAME_FROM_MACRO_STEP1(name, postfix)                               \\\n  FIO_NAME_FROM_MACRO_STEP2(name, postfix)\n#define FIO_NAME(postfix) FIO_NAME_FROM_MACRO_STEP1(FIO_SET_NAME, postfix)\n\n/* Used for naming the `free` function */\n#define FIO_NAME_FROM_MACRO_STEP4(name) name##_free\n#define FIO_NAME_FROM_MACRO_STEP3(name) FIO_NAME_FROM_MACRO_STEP4(name)\n#define FIO_NAME_FREE() FIO_NAME_FROM_MACRO_STEP3(FIO_SET_NAME)\n\n/* The default Set object / value type is `void *` */\n#if !defined(FIO_SET_OBJ_TYPE)\n#define FIO_SET_OBJ_TYPE void *\n#elif !defined(FIO_SET_NO_TEST)\n#define FIO_SET_NO_TEST 1\n#endif\n\n/* The default Set has opaque objects that can't be compared */\n#if !defined(FIO_SET_OBJ_COMPARE)\n#define FIO_SET_OBJ_COMPARE(o1, o2) (1)\n#endif\n\n/** object copy required? */\n#ifndef FIO_SET_OBJ_COPY\n#define FIO_SET_OBJ_COPY(dest, obj) ((dest) = (obj))\n#endif\n\n/** object destruction required? */\n#ifndef FIO_SET_OBJ_DESTROY\n#define FIO_SET_OBJ_DESTROY(obj) ((void)0)\n#endif\n\n/** test for a pre-defined hash type, must be numerical (i.e. __int128_t)*/\n#ifndef FIO_SET_HASH_TYPE\n#define FIO_SET_HASH_TYPE uintptr_t\n#endif\n\n/** test for a pre-defined hash to integer conversion */\n#ifndef FIO_SET_HASH2UINTPTR\n#define FIO_SET_HASH2UINTPTR(hash, bits_used)                                  \\\n  (fio_rrot(hash, bits_used) ^ fio_ct_if2(bits_used, hash, 0))\n#endif\n\n/** test for a pre-defined hash to integer conversion */\n#ifndef FIO_SET_HASH_FORCE\n#define FIO_SET_HASH_FORCE (~(uintptr_t)0)\n#endif\n\n/** test for a pre-defined invalid hash value (all bytes are 0) */\n#ifndef FIO_SET_HASH_INVALID\n#define FIO_SET_HASH_INVALID ((FIO_SET_HASH_TYPE)0)\n#endif\n\n/** test for a pre-defined hash comparison */\n#ifndef FIO_SET_HASH_COMPARE\n#define FIO_SET_HASH_COMPARE(h1, h2) ((h1) == (h2))\n#endif\n\n/* Customizable memory management */\n#ifndef FIO_SET_REALLOC /* NULL ptr indicates new allocation */\n#define FIO_SET_REALLOC(ptr, original_size, new_size, valid_data_length)       \\\n  FIO_REALLOC((ptr), (new_size), (valid_data_length))\n#endif\n\n#ifndef FIO_SET_CALLOC\n#define FIO_SET_CALLOC(size, count) FIO_CALLOC((size), (count))\n#endif\n\n#ifndef FIO_SET_FREE\n#define FIO_SET_FREE(ptr, size) FIO_FREE((ptr))\n#endif\n\n/* The maximum number of bins to rotate when (partial/full) collisions occure */\n#ifndef FIO_SET_MAX_MAP_SEEK\n#define FIO_SET_MAX_MAP_SEEK (96)\n#endif\n\n/* The maximum number of full hash collisions that can be consumed */\n#ifndef FIO_SET_MAX_MAP_FULL_COLLISIONS\n#define FIO_SET_MAX_MAP_FULL_COLLISIONS (96)\n#endif\n\n/* Prime numbers are better */\n#ifndef FIO_SET_CUCKOO_STEPS\n#define FIO_SET_CUCKOO_STEPS 11\n#endif\n\n#ifdef FIO_SET_KEY_TYPE\ntypedef struct {\n  FIO_SET_KEY_TYPE key;\n  FIO_SET_OBJ_TYPE obj;\n} FIO_NAME(couplet_s);\n\n#define FIO_SET_TYPE FIO_NAME(couplet_s)\n\n/** key copy required? */\n#ifndef FIO_SET_KEY_COPY\n#define FIO_SET_KEY_COPY(dest, obj) ((dest) = (obj))\n#endif\n\n/** key destruction required? */\n#ifndef FIO_SET_KEY_DESTROY\n#define FIO_SET_KEY_DESTROY(obj) ((void)0)\n#endif\n\n/* The default Hash Map-Set has will use straight euqality operators */\n#if !defined(FIO_SET_KEY_COMPARE)\n#define FIO_SET_KEY_COMPARE(o1, o2) ((o1) == (o2))\n#endif\n\n/** Internal macros for object actions in Hash mode */\n#define FIO_SET_COMPARE(o1, o2) FIO_SET_KEY_COMPARE((o1).key, (o2).key)\n#define FIO_SET_COPY(dest, org)                                                \\\n  do {                                                                         \\\n    FIO_SET_OBJ_COPY((dest).obj, (org).obj);                                   \\\n    FIO_SET_KEY_COPY((dest).key, (org).key);                                   \\\n  } while (0);\n#define FIO_SET_DESTROY(couplet)                                               \\\n  do {                                                                         \\\n    FIO_SET_KEY_DESTROY((couplet).key);                                        \\\n    FIO_SET_OBJ_DESTROY((couplet).obj);                                        \\\n  } while (0);\n\n#else /* a pure Set, not a Hash Map*/\n/** Internal macros for object actions in Set mode */\n#define FIO_SET_COMPARE(o1, o2) FIO_SET_OBJ_COMPARE((o1), (o2))\n#define FIO_SET_COPY(dest, obj) FIO_SET_OBJ_COPY((dest), (obj))\n#define FIO_SET_DESTROY(obj) FIO_SET_OBJ_DESTROY((obj))\n#define FIO_SET_TYPE FIO_SET_OBJ_TYPE\n#endif\n\n/* *****************************************************************************\nSet / Hash Map API\n***************************************************************************** */\n\n/** The Set container type. By default: fio_ptr_set_s */\ntypedef struct FIO_NAME(s) FIO_NAME(s);\n\n#ifndef FIO_SET_INIT\n/** Initializes the set */\n#define FIO_SET_INIT                                                           \\\n  { .capa = 0 }\n#endif\n\n/** Frees all the objects in the set and deallocates any internal resources. */\nFIO_FUNC void FIO_NAME_FREE()(FIO_NAME(s) * set);\n\n#ifdef FIO_SET_KEY_TYPE\n\n/**\n * Locates an object in the Hash Map, if it exists.\n *\n * NOTE: This is the function's Hash Map variant. See FIO_SET_KEY_TYPE.\n */\nFIO_FUNC inline FIO_SET_OBJ_TYPE\n    FIO_NAME(find)(FIO_NAME(s) * set, const FIO_SET_HASH_TYPE hash_value,\n                   FIO_SET_KEY_TYPE key);\n\n/**\n * Inserts an object to the Hash Map, rehashing if required, returning the new\n * object's location using a pointer.\n *\n * If an object already exists in the Hash Map, it will be destroyed.\n *\n * If `old` is set, the existing object (if any) will be copied to the location\n * pointed to by `old` before it is destroyed.\n *\n * NOTE: This is the function's Hash Map variant. See FIO_SET_KEY_TYPE.\n */\nFIO_FUNC inline void FIO_NAME(insert)(FIO_NAME(s) * set,\n                                      const FIO_SET_HASH_TYPE hash_value,\n                                      FIO_SET_KEY_TYPE key,\n                                      FIO_SET_OBJ_TYPE obj,\n                                      FIO_SET_OBJ_TYPE *old);\n\n/**\n * Removes an object from the Hash Map, rehashing if required.\n *\n * Returns 0 on success and -1 if the object wasn't found.\n *\n * If `old` is set, the existing object (if any) will be copied to the location\n * pointed to by `old`.\n *\n * NOTE: This is the function's Hash Map variant. See FIO_SET_KEY_TYPE.\n */\nFIO_FUNC inline int FIO_NAME(remove)(FIO_NAME(s) * set,\n                                     const FIO_SET_HASH_TYPE hash_value,\n                                     FIO_SET_KEY_TYPE key,\n                                     FIO_SET_OBJ_TYPE *old);\n\n#else\n\n/**\n * Locates an object in the Set, if it exists.\n *\n * NOTE: This is the function's pure Set variant (no FIO_SET_KEY_TYPE).\n */\nFIO_FUNC inline FIO_SET_OBJ_TYPE\n    FIO_NAME(find)(FIO_NAME(s) * set, const FIO_SET_HASH_TYPE hash_value,\n                   FIO_SET_OBJ_TYPE obj);\n\n/**\n * Inserts an object to the Set only if it's missing, rehashing if required,\n * returning the new (or old) object.\n *\n * If the object already exists in the set, than the new object will be\n * destroyed and the old object will be returned.\n *\n * NOTE: This is the function's pure Set variant (no FIO_SET_KEY_TYPE).\n */\nFIO_FUNC inline FIO_SET_OBJ_TYPE\n    FIO_NAME(insert)(FIO_NAME(s) * set, const FIO_SET_HASH_TYPE hash_value,\n                     FIO_SET_OBJ_TYPE obj);\n\n/**\n * Inserts an object to the Set, rehashing if required, returning the new\n * object.\n *\n * If the object already exists in the set, it will be destroyed and\n * overwritten.\n *\n * When setting `old` to NULL, the function behaves the same as `overwrite`.\n */\nFIO_FUNC FIO_SET_OBJ_TYPE\n    FIO_NAME(overwrite)(FIO_NAME(s) * set, const FIO_SET_HASH_TYPE hash_value,\n                        FIO_SET_OBJ_TYPE obj, FIO_SET_OBJ_TYPE *old);\n\n/**\n * Removes an object from the Set, rehashing if required.\n *\n * Returns 0 on success and -1 if the object wasn't found.\n *\n * NOTE: This is the function's pure Set variant (no FIO_SET_KEY_TYPE).\n */\nFIO_FUNC inline int FIO_NAME(remove)(FIO_NAME(s) * set,\n                                     const FIO_SET_HASH_TYPE hash_value,\n                                     FIO_SET_OBJ_TYPE obj,\n                                     FIO_SET_OBJ_TYPE *old);\n\n#endif\n/**\n * Allows a peak at the Set's last element.\n *\n * Remember that objects might be destroyed if the Set is altered\n * (`FIO_SET_OBJ_DESTROY` / `FIO_SET_KEY_DESTROY`).\n */\nFIO_FUNC inline FIO_SET_TYPE FIO_NAME(last)(FIO_NAME(s) * set);\n\n/**\n * Allows the Hash to be momentarily used as a stack, destroying the last\n * object added (`FIO_SET_OBJ_DESTROY` / `FIO_SET_KEY_DESTROY`).\n */\nFIO_FUNC inline void FIO_NAME(pop)(FIO_NAME(s) * set);\n\n/** Returns the number of object currently in the Set. */\nFIO_FUNC inline size_t FIO_NAME(count)(const FIO_NAME(s) * set);\n\n/**\n * Returns a temporary theoretical Set capacity.\n * This could be used for testing performance and memory consumption.\n */\nFIO_FUNC inline size_t FIO_NAME(capa)(const FIO_NAME(s) * set);\n\n/**\n * Requires that a Set contains the minimal requested theoretical capacity.\n *\n * Returns the actual (temporary) theoretical capacity.\n */\nFIO_FUNC inline size_t FIO_NAME(capa_require)(FIO_NAME(s) * set,\n                                              size_t min_capa);\n\n/**\n * Returns non-zero if the Set is fragmented (more than 50% holes).\n */\nFIO_FUNC inline size_t FIO_NAME(is_fragmented)(const FIO_NAME(s) * set);\n\n/**\n * Attempts to minimize memory usage by removing empty spaces caused by deleted\n * items and rehashing the Set.\n *\n * Returns the updated Set capacity.\n */\nFIO_FUNC inline size_t FIO_NAME(compact)(FIO_NAME(s) * set);\n\n/** Forces a rehashing of the Set. */\nFIO_FUNC void FIO_NAME(rehash)(FIO_NAME(s) * set);\n\n#ifndef FIO_SET_FOR_LOOP\n/**\n * A macro for a `for` loop that iterates over all the Set's objects (in\n * order).\n *\n * `set` is a pointer to the Set variable and `pos` is a temporary variable\n * name to be created for iteration.\n *\n * `pos->hash` is the hashing value and `pos->obj` is the object's data.\n *\n * NOTICE: Since the Set might have \"holes\" (objects that were removed), it is\n * important to skip any `pos->hash == 0` or the equivalent of\n * `FIO_SET_HASH_COMPARE(pos->hash, FIO_SET_HASH_INVALID)`.\n */\n#define FIO_SET_FOR_LOOP(set, pos)\n#endif\n\n/* *****************************************************************************\nSet / Hash Map Internal Data Structures\n***************************************************************************** */\n\ntypedef struct FIO_NAME(_ordered_s_) {\n  FIO_SET_HASH_TYPE hash;\n  FIO_SET_TYPE obj;\n} FIO_NAME(_ordered_s_);\n\ntypedef struct FIO_NAME(_map_s_) {\n  FIO_SET_HASH_TYPE hash; /* another copy for memory cache locality */\n  FIO_NAME(_ordered_s_) * pos;\n} FIO_NAME(_map_s_);\n\n/* the information in the Hash Map structure should be considered READ ONLY. */\nstruct FIO_NAME(s) {\n  uintptr_t count;\n  uintptr_t capa;\n  uintptr_t pos;\n  FIO_NAME(_ordered_s_) * ordered;\n  FIO_NAME(_map_s_) * map;\n  uint8_t has_collisions;\n  uint8_t used_bits;\n  uint8_t under_attack;\n};\n\n#undef FIO_SET_FOR_LOOP\n#define FIO_SET_FOR_LOOP(set, container)                                       \\\n  for (__typeof__((set)->ordered) container = (set)->ordered;                  \\\n       container && (container < ((set)->ordered + (set)->pos)); ++container)\n\n/* *****************************************************************************\nSet / Hash Map Internal Helpers\n***************************************************************************** */\n\n/** Locates an object's map position in the Set, if it exists. */\nFIO_FUNC inline FIO_NAME(_map_s_) *\n    FIO_NAME(_find_map_pos_)(FIO_NAME(s) * set, FIO_SET_HASH_TYPE hash_value,\n                             FIO_SET_TYPE obj) {\n  if (FIO_SET_HASH_COMPARE(hash_value, FIO_SET_HASH_INVALID))\n    hash_value = FIO_SET_HASH_FORCE;\n  if (set->map) {\n    /* make sure collisions don't effect seeking */\n    if (set->has_collisions && set->pos != set->count) {\n      FIO_NAME(rehash)(set);\n    }\n    size_t full_collisions_counter = 0;\n    FIO_NAME(_map_s_) * pos;\n    /*\n     * Commonly, the hash is rotated, depending on it's state.\n     * Different bits are used for each mapping, instead of a single new bit.\n     */\n    const uintptr_t mask = (1ULL << set->used_bits) - 1;\n\n    uintptr_t i;\n    const uintptr_t hash_value_i = FIO_SET_HASH2UINTPTR(hash_value, 0);\n    uintptr_t hash_alt = FIO_SET_HASH2UINTPTR(hash_value, set->used_bits);\n\n    /* O(1) access to object */\n    pos = set->map + (hash_alt & mask);\n    if (FIO_SET_HASH_COMPARE(FIO_SET_HASH_INVALID, pos->hash))\n      return pos;\n    if (FIO_SET_HASH_COMPARE(pos->hash, hash_value_i)) {\n      if (!pos->pos || FIO_SET_COMPARE(pos->pos->obj, obj))\n        return pos;\n      /* full hash value collision detected */\n      set->has_collisions = 1;\n      ++full_collisions_counter;\n    }\n\n    /* Handle partial / full collisions with cuckoo steps O(x) access time */\n    i = 0;\n    const uintptr_t limit =\n        FIO_SET_CUCKOO_STEPS * (set->capa > (FIO_SET_MAX_MAP_SEEK << 2)\n                                    ? FIO_SET_MAX_MAP_SEEK\n                                    : (set->capa >> 2));\n    while (i < limit) {\n      i += FIO_SET_CUCKOO_STEPS;\n      pos = set->map + ((hash_alt + i) & mask);\n      if (FIO_SET_HASH_COMPARE(FIO_SET_HASH_INVALID, pos->hash))\n        return pos;\n      if (FIO_SET_HASH_COMPARE(pos->hash, hash_value_i)) {\n        if (!pos->pos || FIO_SET_COMPARE(pos->pos->obj, obj))\n          return pos;\n        /* full hash value collision detected */\n        set->has_collisions = 1;\n        if (++full_collisions_counter >= FIO_SET_MAX_MAP_FULL_COLLISIONS) {\n          /* is the hash under attack? */\n          FIO_LOG_WARNING(\n              \"(fio hash map) too many full collisions - under attack?\");\n          set->under_attack = 1;\n        }\n        if (set->under_attack) {\n          return pos;\n        }\n      }\n    }\n  }\n  return NULL;\n  (void)obj; /* in cases where FIO_SET_OBJ_COMPARE does nothing */\n}\n#undef FIO_SET_CUCKOO_STEPS\n\n/** Removes \"holes\" from the Set's internal Array - MUST re-hash afterwards.\n */\nFIO_FUNC inline void FIO_NAME(_compact_ordered_array_)(FIO_NAME(s) * set) {\n  if (set->count == set->pos)\n    return;\n  FIO_NAME(_ordered_s_) *reader = set->ordered;\n  FIO_NAME(_ordered_s_) *writer = set->ordered;\n  const FIO_NAME(_ordered_s_) *end = set->ordered + set->pos;\n  for (; reader && (reader < end); ++reader) {\n    if (FIO_SET_HASH_COMPARE(reader->hash, FIO_SET_HASH_INVALID)) {\n      continue;\n    }\n    *writer = *reader;\n    ++writer;\n  }\n  /* fix any possible counting errors as well as resetting position */\n  set->pos = set->count = (writer - set->ordered);\n}\n\n/** (Re)allocates the set's internal, invalidatint the mapping (must rehash) */\nFIO_FUNC inline void FIO_NAME(_reallocate_set_mem_)(FIO_NAME(s) * set) {\n  const uintptr_t new_capa = 1ULL << set->used_bits;\n  FIO_SET_FREE(set->map, set->capa * sizeof(*set->map));\n  set->map = (FIO_NAME(_map_s_) *)FIO_SET_CALLOC(sizeof(*set->map), new_capa);\n  set->ordered = (FIO_NAME(_ordered_s_) *)FIO_SET_REALLOC(\n      set->ordered, (set->capa * sizeof(*set->ordered)),\n      (new_capa * sizeof(*set->ordered)), (set->pos * sizeof(*set->ordered)));\n  if (!set->map || !set->ordered) {\n    perror(\"FATAL ERROR: couldn't allocate memory for Set data\");\n    exit(errno);\n  }\n  set->capa = new_capa;\n}\n\n/**\n * Inserts an object to the Set, rehashing if required, returning the new\n * object's pointer.\n *\n * If the object already exists in the set, it will be destroyed and\n * overwritten.\n */\nFIO_FUNC inline FIO_SET_TYPE\nFIO_NAME(_insert_or_overwrite_)(FIO_NAME(s) * set, FIO_SET_HASH_TYPE hash_value,\n                                FIO_SET_TYPE obj, int overwrite,\n                                FIO_SET_OBJ_TYPE *old) {\n  if (FIO_SET_HASH_COMPARE(hash_value, FIO_SET_HASH_INVALID))\n    hash_value = FIO_SET_HASH_FORCE;\n\n  /* automatic fragmentation protection */\n  if (FIO_NAME(is_fragmented)(set))\n    FIO_NAME(rehash)(set);\n  /* automatic capacity validation (we can never be at 100% capacity) */\n  else if (set->pos >= set->capa) {\n    ++set->used_bits;\n    FIO_NAME(rehash)(set);\n  }\n\n  /* locate future position */\n  FIO_NAME(_map_s_) *pos = FIO_NAME(_find_map_pos_)(set, hash_value, obj);\n\n  if (!pos) {\n    /* inserting a new object, with too many holes in the map */\n    FIO_SET_COPY(set->ordered[set->pos].obj, obj);\n    set->ordered[set->pos].hash = hash_value;\n    ++set->pos;\n    ++set->count;\n    FIO_NAME(rehash)(set);\n    return set->ordered[set->pos - 1].obj;\n  }\n\n  /* overwriting / new */\n  if (pos->pos) {\n    /* overwrite existing object */\n    if (!overwrite) {\n      FIO_SET_DESTROY(obj);\n      return pos->pos->obj;\n    }\n#ifdef FIO_SET_KEY_TYPE\n    if (old) {\n      FIO_SET_OBJ_COPY((*old), pos->pos->obj.obj);\n    }\n    /* no need to recreate the key object, just the value object */\n    FIO_SET_OBJ_DESTROY(pos->pos->obj.obj);\n    FIO_SET_OBJ_COPY(pos->pos->obj.obj, obj.obj);\n    return pos->pos->obj;\n#else\n    if (old) {\n      FIO_SET_COPY((*old), pos->pos->obj);\n    }\n    FIO_SET_DESTROY(pos->pos->obj);\n#endif\n  } else {\n    /* insert into new slot */\n    pos->pos = set->ordered + set->pos;\n    ++set->pos;\n    ++set->count;\n  }\n  /* store object at position */\n  pos->hash = hash_value;\n  pos->pos->hash = hash_value;\n  FIO_SET_COPY(pos->pos->obj, obj);\n\n  return pos->pos->obj;\n}\n\n/* *****************************************************************************\nSet / Hash Map Implementation\n***************************************************************************** */\n\n/** Frees all the objects in the set and deallocates any internal resources. */\nFIO_FUNC void FIO_NAME_FREE()(FIO_NAME(s) * s) {\n  /* destroy existing valid objects */\n  const FIO_NAME(_ordered_s_) *const end = s->ordered + s->pos;\n  if (s->ordered && s->ordered != end) {\n    for (FIO_NAME(_ordered_s_) *pos = s->ordered; pos < end; ++pos) {\n      if (!FIO_SET_HASH_COMPARE(FIO_SET_HASH_INVALID, pos->hash)) {\n        FIO_SET_DESTROY(pos->obj);\n      }\n    }\n  }\n  /* free ordered array and hash mapping */\n  FIO_SET_FREE(s->map, s->capa * sizeof(*s->map));\n  FIO_SET_FREE(s->ordered, s->capa * sizeof(*s->ordered));\n  *s = (FIO_NAME(s)){.map = NULL};\n}\n\n#ifdef FIO_SET_KEY_TYPE\n\n/* Hash Map unique implementation */\n\n/**\n * Locates an object in the Set, if it exists.\n *\n * NOTE: This is the function's Hash Map variant. See FIO_SET_KEY_TYPE.\n */\nFIO_FUNC FIO_SET_OBJ_TYPE FIO_NAME(find)(FIO_NAME(s) * set,\n                                         const FIO_SET_HASH_TYPE hash_value,\n                                         FIO_SET_KEY_TYPE key) {\n  FIO_NAME(_map_s_) *pos =\n      FIO_NAME(_find_map_pos_)(set, hash_value, (FIO_SET_TYPE){.key = key});\n  if (!pos || !pos->pos) {\n    FIO_SET_OBJ_TYPE empty;\n    memset(&empty, 0, sizeof(empty));\n    return empty;\n  }\n  return pos->pos->obj.obj;\n}\n\n/**\n * Inserts an object to the Hash Map, rehashing if required, returning the new\n * object's location using a pointer.\n *\n * If an object already exists in the Hash Map, it will be destroyed.\n *\n * If `old` is set, the existing object (if any) will be copied to the location\n * pointed to by `old` before it is destroyed.\n *\n * NOTE: This is the function's Hash Map variant. See FIO_SET_KEY_TYPE.\n */\nFIO_FUNC void FIO_NAME(insert)(FIO_NAME(s) * set,\n                               const FIO_SET_HASH_TYPE hash_value,\n                               FIO_SET_KEY_TYPE key, FIO_SET_OBJ_TYPE obj,\n                               FIO_SET_OBJ_TYPE *old) {\n  FIO_NAME(_insert_or_overwrite_)\n  (set, hash_value, (FIO_SET_TYPE){.key = key, .obj = obj}, 1, old);\n}\n\n/**\n * Removes an object from the Hash Map, rehashing if required.\n *\n * Returns 0 on success and -1 if the object wasn't found.\n *\n * If `old` is set, the existing object (if any) will be copied to the location\n * pointed to by `old`.\n *\n * NOTE: This is the function's Hash Map variant. See FIO_SET_KEY_TYPE.\n */\nFIO_FUNC inline int FIO_NAME(remove)(FIO_NAME(s) * set,\n                                     const FIO_SET_HASH_TYPE hash_value,\n                                     FIO_SET_KEY_TYPE key,\n                                     FIO_SET_OBJ_TYPE *old) {\n  FIO_NAME(_map_s_) *pos =\n      FIO_NAME(_find_map_pos_)(set, hash_value, (FIO_SET_TYPE){.key = key});\n  if (!pos || !pos->pos)\n    return -1;\n  if (old)\n    FIO_SET_OBJ_COPY((*old), pos->pos->obj.obj);\n  FIO_SET_DESTROY(pos->pos->obj);\n  --set->count;\n  pos->pos->hash = FIO_SET_HASH_INVALID;\n  if (pos->pos == set->pos + set->ordered - 1) {\n    /* removing last item inserted */\n    pos->hash = FIO_SET_HASH_INVALID; /* no need for a \"hole\" */\n    do {\n      --set->pos;\n    } while (set->pos && FIO_SET_HASH_COMPARE(set->ordered[set->pos - 1].hash,\n                                              FIO_SET_HASH_INVALID));\n  }\n  pos->pos = NULL; /* leave pos->hash set to mark \"hole\" */\n  return 0;\n}\n\n#else /* FIO_SET_KEY_TYPE */\n\n/* Set unique implementation */\n\n/** Locates an object in the Set, if it exists. */\nFIO_FUNC FIO_SET_OBJ_TYPE FIO_NAME(find)(FIO_NAME(s) * set,\n                                         const FIO_SET_HASH_TYPE hash_value,\n                                         FIO_SET_OBJ_TYPE obj) {\n  FIO_NAME(_map_s_) *pos = FIO_NAME(_find_map_pos_)(set, hash_value, obj);\n  if (!pos || !pos->pos) {\n    FIO_SET_OBJ_TYPE empty;\n    memset(&empty, 0, sizeof(empty));\n    return empty;\n  }\n  return pos->pos->obj;\n}\n\n/**\n * Inserts an object to the Set, rehashing if required, returning the new\n * object's pointer.\n *\n * If the object already exists in the set, than the new object will be\n * destroyed and the old object's address will be returned.\n */\nFIO_FUNC FIO_SET_OBJ_TYPE FIO_NAME(insert)(FIO_NAME(s) * set,\n                                           const FIO_SET_HASH_TYPE hash_value,\n                                           FIO_SET_OBJ_TYPE obj) {\n  return FIO_NAME(_insert_or_overwrite_)(set, hash_value, obj, 0, NULL);\n}\n\n/**\n * Inserts an object to the Set, rehashing if required, returning the new\n * object's pointer.\n *\n * If the object already exists in the set, it will be destroyed and\n * overwritten.\n *\n * When setting `old` to NULL, the function behaves the same as `overwrite`.\n */\nFIO_FUNC FIO_SET_OBJ_TYPE\nFIO_NAME(overwrite)(FIO_NAME(s) * set, const FIO_SET_HASH_TYPE hash_value,\n                    FIO_SET_OBJ_TYPE obj, FIO_SET_OBJ_TYPE *old) {\n  return FIO_NAME(_insert_or_overwrite_)(set, hash_value, obj, 1, old);\n}\n\n/**\n * Removes an object from the Set, rehashing if required.\n */\nFIO_FUNC int FIO_NAME(remove)(FIO_NAME(s) * set,\n                              const FIO_SET_HASH_TYPE hash_value,\n                              FIO_SET_OBJ_TYPE obj, FIO_SET_OBJ_TYPE *old) {\n  if (FIO_SET_HASH_COMPARE(hash_value, FIO_SET_HASH_INVALID))\n    return -1;\n  FIO_NAME(_map_s_) *pos = FIO_NAME(_find_map_pos_)(set, hash_value, obj);\n  if (!pos || !pos->pos)\n    return -1;\n  if (old)\n    FIO_SET_COPY((*old), pos->pos->obj);\n  FIO_SET_DESTROY(pos->pos->obj);\n  --set->count;\n  pos->pos->hash = FIO_SET_HASH_INVALID;\n  if (pos->pos == set->pos + set->ordered - 1) {\n    /* removing last item inserted */\n    pos->hash = FIO_SET_HASH_INVALID; /* no need for a \"hole\" */\n    do {\n      --set->pos;\n    } while (set->pos && FIO_SET_HASH_COMPARE(set->ordered[set->pos - 1].hash,\n                                              FIO_SET_HASH_INVALID));\n  }\n  pos->pos = NULL; /* leave pos->hash set to mark \"hole\" */\n  return 0;\n}\n\n#endif\n\n/**\n * Allows a peak at the Set's last element.\n *\n * Remember that objects might be destroyed if the Set is altered\n * (`FIO_SET_OBJ_DESTROY` / `FIO_SET_KEY_DESTROY`).\n */\nFIO_FUNC inline FIO_SET_TYPE FIO_NAME(last)(FIO_NAME(s) * set) {\n  if (!set->ordered || !set->pos) {\n    FIO_SET_TYPE empty;\n    memset(&empty, 0, sizeof(empty));\n    return empty;\n  }\n  return set->ordered[set->pos - 1].obj;\n}\n\n/**\n * Allows the Hash to be momentarily used as a stack, destroying the last\n * object added (`FIO_SET_OBJ_DESTROY` / `FIO_SET_KEY_DESTROY`).\n */\nFIO_FUNC void FIO_NAME(pop)(FIO_NAME(s) * set) {\n  if (!set->ordered || !set->pos)\n    return;\n  FIO_SET_DESTROY(set->ordered[set->pos - 1].obj);\n  set->ordered[set->pos - 1].hash = FIO_SET_HASH_INVALID;\n  --(set->count);\n  do {\n    --(set->pos);\n  } while (set->pos && FIO_SET_HASH_COMPARE(set->ordered[set->pos - 1].hash,\n                                            FIO_SET_HASH_INVALID));\n}\n\n/** Returns the number of objects currently in the Set. */\nFIO_FUNC inline size_t FIO_NAME(count)(const FIO_NAME(s) * set) {\n  return (size_t)set->count;\n}\n\n/**\n * Returns a temporary theoretical Set capacity.\n * This could be used for testing performance and memory consumption.\n */\nFIO_FUNC inline size_t FIO_NAME(capa)(const FIO_NAME(s) * set) {\n  return (size_t)set->capa;\n}\n\n/**\n * Requires that a Set contains the minimal requested theoretical capacity.\n *\n * Returns the actual (temporary) theoretical capacity.\n */\nFIO_FUNC inline size_t FIO_NAME(capa_require)(FIO_NAME(s) * set,\n                                              size_t min_capa) {\n  if (min_capa <= FIO_NAME(capa)(set))\n    return FIO_NAME(capa)(set);\n  set->used_bits = 2;\n  while (min_capa > (1ULL << set->used_bits)) {\n    ++set->used_bits;\n  }\n  FIO_NAME(rehash)(set);\n  return FIO_NAME(capa)(set);\n}\n\n/**\n * Returns non-zero if the Set is fragmented (more than 50% holes).\n */\nFIO_FUNC inline size_t FIO_NAME(is_fragmented)(const FIO_NAME(s) * set) {\n  return ((set->pos - set->count) > (set->count >> 1));\n}\n\n/**\n * Attempts to minimize memory usage by removing empty spaces caused by deleted\n * items and rehashing the Set.\n *\n * Returns the updated Set capacity.\n */\nFIO_FUNC inline size_t FIO_NAME(compact)(FIO_NAME(s) * set) {\n  FIO_NAME(_compact_ordered_array_)(set);\n  set->used_bits = 2;\n  while (set->count >= (1ULL << set->used_bits)) {\n    ++set->used_bits;\n  }\n  FIO_NAME(rehash)(set);\n  return FIO_NAME(capa)(set);\n}\n\n/** Forces a rehashing of the Set. */\nFIO_FUNC void FIO_NAME(rehash)(FIO_NAME(s) * set) {\n  FIO_NAME(_compact_ordered_array_)(set);\n  set->has_collisions = 0;\n  uint8_t attempts = 0;\nrestart:\n  if (set->used_bits >= 16 && ++attempts >= 3 && set->has_collisions) {\n    FIO_LOG_FATAL(\n        \"facil.io Set / Hash Map has too many collisions (%zu/%zu).\"\n        \"\\n\\t\\tthis is a fatal implementation error,\"\n        \"please report this issue at facio.io's open source project\"\n        \"\\n\\t\\tNote: hash maps and sets should never reach this point.\"\n        \"\\n\\t\\tThey should be guarded against collision attacks.\",\n        set->pos, set->capa);\n    exit(-1);\n  }\n  FIO_NAME(_reallocate_set_mem_)(set);\n  {\n    FIO_NAME(_ordered_s_) const *const end = set->ordered + set->pos;\n    for (FIO_NAME(_ordered_s_) *pos = set->ordered; pos < end; ++pos) {\n      FIO_NAME(_map_s_) *mp =\n          FIO_NAME(_find_map_pos_)(set, pos->hash, pos->obj);\n      if (!mp) {\n        ++set->used_bits;\n        goto restart;\n      }\n      mp->pos = pos;\n      mp->hash = pos->hash;\n    }\n  }\n}\n\n#undef FIO_SET_OBJ_TYPE\n#undef FIO_SET_OBJ_COMPARE\n#undef FIO_SET_OBJ_COPY\n#undef FIO_SET_OBJ_DESTROY\n#undef FIO_SET_HASH_TYPE\n#undef FIO_SET_HASH2UINTPTR\n#undef FIO_SET_HASH_COMPARE\n#undef FIO_SET_HASH_INVALID\n#undef FIO_SET_KEY_TYPE\n#undef FIO_SET_KEY_COPY\n#undef FIO_SET_KEY_DESTROY\n#undef FIO_SET_KEY_COMPARE\n#undef FIO_SET_TYPE\n#undef FIO_SET_COMPARE\n#undef FIO_SET_COPY\n#undef FIO_SET_DESTROY\n#undef FIO_SET_MAX_MAP_SEEK\n#undef FIO_SET_MAX_MAP_FULL_COLLISIONS\n#undef FIO_SET_REALLOC\n#undef FIO_SET_CALLOC\n#undef FIO_SET_FREE\n#undef FIO_NAME\n#undef FIO_NAME_FROM_MACRO_STEP2\n#undef FIO_NAME_FROM_MACRO_STEP1\n#undef FIO_NAME_FROM_MACRO_STEP4\n#undef FIO_NAME_FROM_MACRO_STEP3\n#undef FIO_NAME_FREE\n#undef FIO_SET_NAME\n#undef FIO_FORCE_MALLOC_TMP\n\n#endif\n", "/*\nCopyright: Boaz segev, 2017\nLicense: MIT\n\nFeel free to copy, use and enjoy according to the license provided.\n*/\n#include <fio.h>\n\n#include <fio_cli.h>\n\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n\n/* *****************************************************************************\nCLI Data Stores\n***************************************************************************** */\n\ntypedef struct {\n  size_t len;\n  const char *data;\n} cstr_s;\n\n#define FIO_SET_OBJ_TYPE const char *\n#define FIO_SET_KEY_TYPE cstr_s\n#define FIO_SET_KEY_COMPARE(o1, o2)                                            \\\n  (o1.len == o2.len &&                                                         \\\n   (o1.data == o2.data || !memcmp(o1.data, o2.data, o1.len)))\n#define FIO_SET_NAME fio_cli_hash\n#include <fio.h>\n\nstatic fio_cli_hash_s fio_aliases = FIO_SET_INIT;\nstatic fio_cli_hash_s fio_values = FIO_SET_INIT;\nstatic size_t fio_unnamed_count = 0;\n\ntypedef struct {\n  int unnamed_min;\n  int unnamed_max;\n  int pos;\n  int unnamed_count;\n  int argc;\n  char const **argv;\n  char const *description;\n  char const **names;\n} fio_cli_parser_data_s;\n\n/** this will allow the function definition fio_cli_start to avoid the MACRO */\n#define AVOID_MACRO\n\n#define FIO_CLI_HASH_VAL(s)                                                    \\\n  fio_risky_hash((s).data, (s).len, (uint64_t)fio_cli_start)\n\n/* *****************************************************************************\nCLI Parsing\n***************************************************************************** */\n\n/* *****************************************************************************\nCLI Parsing\n***************************************************************************** */\n\nstatic void fio_cli_map_line2alias(char const *line) {\n  cstr_s n = {.data = line};\n  while (n.data[0] == '-') {\n    while (n.data[n.len] && n.data[n.len] != ' ' && n.data[n.len] != ',') {\n      ++n.len;\n    }\n    const char *old = NULL;\n    fio_cli_hash_insert(&fio_aliases, FIO_CLI_HASH_VAL(n), n, (void *)line,\n                        &old);\n    if (old) {\n      FIO_LOG_WARNING(\"CLI argument name conflict detected\\n\"\n                      \"         The following two directives conflict:\\n\"\n                      \"\\t%s\\n\\t%s\\n\",\n                      old, line);\n    }\n\n    while (n.data[n.len] && (n.data[n.len] == ' ' || n.data[n.len] == ',')) {\n      ++n.len;\n    }\n    n.data += n.len;\n    n.len = 0;\n  }\n}\n\nstatic char const *fio_cli_get_line_type(fio_cli_parser_data_s *parser,\n                                         const char *line) {\n  if (!line) {\n    return NULL;\n  }\n  char const **pos = parser->names;\n  while (*pos) {\n    switch ((intptr_t)*pos) {\n    case FIO_CLI_STRING__TYPE_I:       /* fallthrough */\n    case FIO_CLI_BOOL__TYPE_I:         /* fallthrough */\n    case FIO_CLI_INT__TYPE_I:          /* fallthrough */\n    case FIO_CLI_PRINT__TYPE_I:        /* fallthrough */\n    case FIO_CLI_PRINT_HEADER__TYPE_I: /* fallthrough */\n      ++pos;\n      continue;\n    }\n    if (line == *pos) {\n      goto found;\n    }\n    ++pos;\n  }\n  return NULL;\nfound:\n  switch ((size_t)pos[1]) {\n  case FIO_CLI_STRING__TYPE_I:       /* fallthrough */\n  case FIO_CLI_BOOL__TYPE_I:         /* fallthrough */\n  case FIO_CLI_INT__TYPE_I:          /* fallthrough */\n  case FIO_CLI_PRINT__TYPE_I:        /* fallthrough */\n  case FIO_CLI_PRINT_HEADER__TYPE_I: /* fallthrough */\n    return pos[1];\n  }\n  return NULL;\n}\n\nstatic void fio_cli_set_arg(cstr_s arg, char const *value, char const *line,\n                            fio_cli_parser_data_s *parser) {\n  /* handle unnamed argument */\n  if (!line || !arg.len) {\n    if (!value) {\n      goto print_help;\n    }\n    if (!strcmp(value, \"-?\") || !strcasecmp(value, \"-h\") ||\n        !strcasecmp(value, \"-help\") || !strcasecmp(value, \"--help\")) {\n      goto print_help;\n    }\n    cstr_s n = {.len = ++parser->unnamed_count};\n    fio_cli_hash_insert(&fio_values, n.len, n, value, NULL);\n    if (parser->unnamed_max >= 0 &&\n        parser->unnamed_count > parser->unnamed_max) {\n      arg.len = 0;\n      goto error;\n    }\n    return;\n  }\n\n  /* validate data types */\n  char const *type = fio_cli_get_line_type(parser, line);\n  switch ((size_t)type) {\n  case FIO_CLI_BOOL__TYPE_I:\n    if (value && value != parser->argv[parser->pos + 1]) {\n      goto error;\n    }\n    value = \"1\";\n    break;\n  case FIO_CLI_INT__TYPE_I:\n    if (value) {\n      char const *tmp = value;\n      fio_atol((char **)&tmp);\n      if (*tmp) {\n        goto error;\n      }\n    }\n    /* fallthrough */\n  case FIO_CLI_STRING__TYPE_I:\n    if (!value)\n      goto error;\n    if (!value[0])\n      goto finish;\n    break;\n  }\n\n  /* add values using all aliases possible */\n  {\n    cstr_s n = {.data = line};\n    while (n.data[0] == '-') {\n      while (n.data[n.len] && n.data[n.len] != ' ' && n.data[n.len] != ',') {\n        ++n.len;\n      }\n      fio_cli_hash_insert(&fio_values, FIO_CLI_HASH_VAL(n), n, value, NULL);\n      while (n.data[n.len] && (n.data[n.len] == ' ' || n.data[n.len] == ',')) {\n        ++n.len;\n      }\n      n.data += n.len;\n      n.len = 0;\n    }\n  }\n\nfinish:\n\n  /* handle additional argv progress (if value is on separate argv) */\n  if (value && parser->pos < parser->argc &&\n      value == parser->argv[parser->pos + 1])\n    ++parser->pos;\n  return;\n\nerror: /* handle errors*/\n  /* TODO! */\n  fprintf(stderr, \"\\n\\r\\x1B[31mError:\\x1B[0m unknown argument %.*s %s %s\\n\\n\",\n          (int)arg.len, arg.data, arg.len ? \"with value\" : \"\",\n          value ? (value[0] ? value : \"(empty)\") : \"(null)\");\nprint_help:\n  fprintf(stderr, \"\\n%s\\n\",\n          parser->description ? parser->description\n                              : \"This application accepts any of the following \"\n                                \"possible arguments:\");\n  /* print out each line's arguments */\n  char const **pos = parser->names;\n  while (*pos) {\n    switch ((intptr_t)*pos) {\n    case FIO_CLI_STRING__TYPE_I: /* fallthrough */\n    case FIO_CLI_BOOL__TYPE_I:   /* fallthrough */\n    case FIO_CLI_INT__TYPE_I:    /* fallthrough */\n    case FIO_CLI_PRINT__TYPE_I:  /* fallthrough */\n    case FIO_CLI_PRINT_HEADER__TYPE_I:\n      ++pos;\n      continue;\n    }\n    type = (char *)FIO_CLI_STRING__TYPE_I;\n    switch ((intptr_t)pos[1]) {\n    case FIO_CLI_PRINT__TYPE_I:\n      fprintf(stderr, \"%s\\n\", pos[0]);\n      pos += 2;\n      continue;\n    case FIO_CLI_PRINT_HEADER__TYPE_I:\n      fprintf(stderr, \"\\n\\x1B[4m%s\\x1B[0m\\n\", pos[0]);\n      pos += 2;\n      continue;\n\n    case FIO_CLI_STRING__TYPE_I: /* fallthrough */\n    case FIO_CLI_BOOL__TYPE_I:   /* fallthrough */\n    case FIO_CLI_INT__TYPE_I:    /* fallthrough */\n      type = pos[1];\n    }\n    /* print line @ pos, starting with main argument name */\n    int alias_count = 0;\n    int first_len = 0;\n    size_t tmp = 0;\n    char const *const p = *pos;\n    while (p[tmp] == '-') {\n      while (p[tmp] && p[tmp] != ' ' && p[tmp] != ',') {\n        if (!alias_count)\n          ++first_len;\n        ++tmp;\n      }\n      ++alias_count;\n      while (p[tmp] && (p[tmp] == ' ' || p[tmp] == ',')) {\n        ++tmp;\n      }\n    }\n    switch ((size_t)type) {\n    case FIO_CLI_STRING__TYPE_I:\n      fprintf(stderr, \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m <>\\x1B[0m\\t%s\\n\", first_len,\n              p, p + tmp);\n      break;\n    case FIO_CLI_BOOL__TYPE_I:\n      fprintf(stderr, \" \\x1B[1m%.*s\\x1B[0m   \\t%s\\n\", first_len, p, p + tmp);\n      break;\n    case FIO_CLI_INT__TYPE_I:\n      fprintf(stderr, \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m ##\\x1B[0m\\t%s\\n\", first_len,\n              p, p + tmp);\n      break;\n    }\n    /* print aliase information */\n    tmp = first_len;\n    while (p[tmp] && (p[tmp] == ' ' || p[tmp] == ',')) {\n      ++tmp;\n    }\n    while (p[tmp] == '-') {\n      const size_t start = tmp;\n      while (p[tmp] && p[tmp] != ' ' && p[tmp] != ',') {\n        ++tmp;\n      }\n      int padding = first_len - (tmp - start);\n      if (padding < 0)\n        padding = 0;\n      switch ((size_t)type) {\n      case FIO_CLI_STRING__TYPE_I:\n        fprintf(stderr,\n                \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m <>\\x1B[0m%*s\\t\\x1B[2msame as \"\n                \"%.*s\\x1B[0m\\n\",\n                (int)(tmp - start), p + start, padding, \"\", first_len, p);\n        break;\n      case FIO_CLI_BOOL__TYPE_I:\n        fprintf(stderr,\n                \" \\x1B[1m%.*s\\x1B[0m   %*s\\t\\x1B[2msame as %.*s\\x1B[0m\\n\",\n                (int)(tmp - start), p + start, padding, \"\", first_len, p);\n        break;\n      case FIO_CLI_INT__TYPE_I:\n        fprintf(stderr,\n                \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m ##\\x1B[0m%*s\\t\\x1B[2msame as \"\n                \"%.*s\\x1B[0m\\n\",\n                (int)(tmp - start), p + start, padding, \"\", first_len, p);\n        break;\n      }\n    }\n\n    ++pos;\n  }\n  fprintf(stderr, \"\\nUse any of the following input formats:\\n\"\n                  \"\\t-arg <value>\\t-arg=<value>\\t-arg<value>\\n\"\n                  \"\\n\"\n                  \"Use the -h, -help or -? to get this information again.\\n\"\n                  \"\\n\");\n  fio_cli_end();\n  exit(0);\n}\n\nstatic void fio_cli_end_promise(void *ignr_) {\n  /* make sure fio_cli_end is called before facil.io exists. */\n  fio_cli_end();\n  (void)ignr_;\n}\n\nvoid fio_cli_start AVOID_MACRO(int argc, char const *argv[], int unnamed_min,\n                               int unnamed_max, char const *description,\n                               char const **names) {\n  static fio_lock_i run_once = FIO_LOCK_INIT;\n  if (!fio_trylock(&run_once))\n    fio_state_callback_add(FIO_CALL_AT_EXIT, fio_cli_end_promise, NULL);\n  if (unnamed_max >= 0 && unnamed_max < unnamed_min)\n    unnamed_max = unnamed_min;\n  fio_cli_parser_data_s parser = {\n      .unnamed_min = unnamed_min,\n      .unnamed_max = unnamed_max,\n      .description = description,\n      .argc = argc,\n      .argv = argv,\n      .names = names,\n      .pos = 0,\n  };\n\n  if (fio_cli_hash_count(&fio_values)) {\n    fio_cli_end();\n  }\n\n  /* prepare aliases hash map */\n\n  char const **line = names;\n  while (*line) {\n    switch ((intptr_t)*line) {\n    case FIO_CLI_STRING__TYPE_I:       /* fallthrough */\n    case FIO_CLI_BOOL__TYPE_I:         /* fallthrough */\n    case FIO_CLI_INT__TYPE_I:          /* fallthrough */\n    case FIO_CLI_PRINT__TYPE_I:        /* fallthrough */\n    case FIO_CLI_PRINT_HEADER__TYPE_I: /* fallthrough */\n      ++line;\n      continue;\n    }\n    if (line[1] != (char *)FIO_CLI_PRINT__TYPE_I &&\n        line[1] != (char *)FIO_CLI_PRINT_HEADER__TYPE_I)\n      fio_cli_map_line2alias(*line);\n    ++line;\n  }\n\n  /* parse existing arguments */\n\n  while ((++parser.pos) < argc) {\n    char const *value = NULL;\n    cstr_s n = {.data = argv[parser.pos], .len = strlen(argv[parser.pos])};\n    if (parser.pos + 1 < argc) {\n      value = argv[parser.pos + 1];\n    }\n    const char *l = NULL;\n    while (n.len &&\n           !(l = fio_cli_hash_find(&fio_aliases, FIO_CLI_HASH_VAL(n), n))) {\n      --n.len;\n      value = n.data + n.len;\n    }\n    if (n.len && value && value[0] == '=') {\n      ++value;\n    }\n    // fprintf(stderr, \"Setting %.*s to %s\\n\", (int)n.len, n.data, value);\n    fio_cli_set_arg(n, value, l, &parser);\n  }\n\n  /* Cleanup and save state for API */\n  fio_cli_hash_free(&fio_aliases);\n  fio_unnamed_count = parser.unnamed_count;\n  /* test for required unnamed arguments */\n  if (parser.unnamed_count < parser.unnamed_min)\n    fio_cli_set_arg((cstr_s){.len = 0}, NULL, NULL, &parser);\n}\n\nvoid fio_cli_end(void) {\n  fio_cli_hash_free(&fio_values);\n  fio_cli_hash_free(&fio_aliases);\n  fio_unnamed_count = 0;\n}\n/* *****************************************************************************\nCLI Data Access\n***************************************************************************** */\n\n/** Returns the argument's value as a NUL terminated C String. */\nchar const *fio_cli_get(char const *name) {\n  cstr_s n = {.data = name, .len = strlen(name)};\n  if (!fio_cli_hash_count(&fio_values)) {\n    return NULL;\n  }\n  char const *val = fio_cli_hash_find(&fio_values, FIO_CLI_HASH_VAL(n), n);\n  return val;\n}\n\n/** Returns the argument's value as an integer. */\nint fio_cli_get_i(char const *name) {\n  char const *val = fio_cli_get(name);\n  if (!val)\n    return 0;\n  int i = (int)fio_atol((char **)&val);\n  return i;\n}\n\n/** Returns the number of unrecognized argument. */\nunsigned int fio_cli_unnamed_count(void) {\n  return (unsigned int)fio_unnamed_count;\n}\n\n/** Returns the unrecognized argument using a 0 based `index`. */\nchar const *fio_cli_unnamed(unsigned int index) {\n  if (!fio_cli_hash_count(&fio_values) || !fio_unnamed_count) {\n    return NULL;\n  }\n  cstr_s n = {.data = NULL, .len = index + 1};\n  return fio_cli_hash_find(&fio_values, index + 1, n);\n}\n\n/**\n * Sets the argument's value as a NUL terminated C String (no copy!).\n *\n * Note: this does NOT copy the C strings to memory. Memory should be kept\n * alive until `fio_cli_end` is called.\n */\nvoid fio_cli_set(char const *name, char const *value) {\n  cstr_s n = (cstr_s){.data = name, .len = strlen(name)};\n  fio_cli_hash_insert(&fio_values, FIO_CLI_HASH_VAL(n), n, value, NULL);\n}\n", "/*\nCopyright: Boaz Segev, 2018-2019\nLicense: MIT\n\nFeel free to copy, use and enjoy according to the license provided.\n*/\n#include <fio.h>\n\n/**\n * This implementation of the facil.io SSL/TLS wrapper API is the default\n * implementation that will be used when no SSL/TLS library is available...\n *\n * ... without modification, this implementation crashes the program.\n *\n * The implementation can be USED AS A TEMPLATE for future implementations.\n *\n * This implementation is optimized for ease of development rather than memory\n * consumption.\n */\n#include \"fio_tls.h\"\n\n#if 1 /* TODO: place library compiler flags here */\n\n#define REQUIRE_LIBRARY()\n#define FIO_TLS_WEAK\n\n/* TODO: delete me! */\n#undef FIO_TLS_WEAK\n#define FIO_TLS_WEAK __attribute__((weak))\n#if !FIO_IGNORE_TLS_IF_MISSING\n#undef REQUIRE_LIBRARY\n#define REQUIRE_LIBRARY()                                                      \\\n  FIO_LOG_FATAL(\"No supported SSL/TLS library available.\");                    \\\n  exit(-1);\n#endif\n/* STOP deleting after this line */\n\n/* *****************************************************************************\nThe SSL/TLS helper data types (can be left as is)\n***************************************************************************** */\n#define FIO_INCLUDE_STR 1\n#define FIO_FORCE_MALLOC_TMP 1\n#include <fio.h>\n\ntypedef struct {\n  fio_str_s private_key;\n  fio_str_s public_key;\n  fio_str_s password;\n} cert_s;\n\nstatic inline int fio_tls_cert_cmp(const cert_s *dest, const cert_s *src) {\n  return fio_str_iseq(&dest->private_key, &src->private_key);\n}\nstatic inline void fio_tls_cert_copy(cert_s *dest, cert_s *src) {\n  *dest = (cert_s){\n      .private_key = FIO_STR_INIT,\n      .public_key = FIO_STR_INIT,\n      .password = FIO_STR_INIT,\n  };\n  fio_str_concat(&dest->private_key, &src->private_key);\n  fio_str_concat(&dest->public_key, &src->public_key);\n  fio_str_concat(&dest->password, &src->password);\n}\nstatic inline void fio_tls_cert_destroy(cert_s *obj) {\n  fio_str_free(&obj->private_key);\n  fio_str_free(&obj->public_key);\n  fio_str_free(&obj->password);\n}\n\n#define FIO_ARY_NAME cert_ary\n#define FIO_ARY_TYPE cert_s\n#define FIO_ARY_COMPARE(k1, k2) (fio_tls_cert_cmp(&(k1), &(k2)))\n#define FIO_ARY_COPY(dest, obj) fio_tls_cert_copy(&(dest), &(obj))\n#define FIO_ARY_DESTROY(key) fio_tls_cert_destroy(&(key))\n#define FIO_FORCE_MALLOC_TMP 1\n#include <fio.h>\n\ntypedef struct {\n  fio_str_s pem;\n} trust_s;\n\nstatic inline int fio_tls_trust_cmp(const trust_s *dest, const trust_s *src) {\n  return fio_str_iseq(&dest->pem, &src->pem);\n}\nstatic inline void fio_tls_trust_copy(trust_s *dest, trust_s *src) {\n  *dest = (trust_s){\n      .pem = FIO_STR_INIT,\n  };\n  fio_str_concat(&dest->pem, &src->pem);\n}\nstatic inline void fio_tls_trust_destroy(trust_s *obj) {\n  fio_str_free(&obj->pem);\n}\n\n#define FIO_ARY_NAME trust_ary\n#define FIO_ARY_TYPE trust_s\n#define FIO_ARY_COMPARE(k1, k2) (fio_tls_trust_cmp(&(k1), &(k2)))\n#define FIO_ARY_COPY(dest, obj) fio_tls_trust_copy(&(dest), &(obj))\n#define FIO_ARY_DESTROY(key) fio_tls_trust_destroy(&(key))\n#define FIO_FORCE_MALLOC_TMP 1\n#include <fio.h>\n\ntypedef struct {\n  fio_str_s name; /* fio_str_s provides cache locality for small strings */\n  void (*on_selected)(intptr_t uuid, void *udata_connection, void *udata_tls);\n  void *udata_tls;\n  void (*on_cleanup)(void *udata_tls);\n} alpn_s;\n\nstatic inline int fio_alpn_cmp(const alpn_s *dest, const alpn_s *src) {\n  return fio_str_iseq(&dest->name, &src->name);\n}\nstatic inline void fio_alpn_copy(alpn_s *dest, alpn_s *src) {\n  *dest = (alpn_s){\n      .name = FIO_STR_INIT,\n      .on_selected = src->on_selected,\n      .udata_tls = src->udata_tls,\n      .on_cleanup = src->on_cleanup,\n  };\n  fio_str_concat(&dest->name, &src->name);\n}\nstatic inline void fio_alpn_destroy(alpn_s *obj) {\n  if (obj->on_cleanup)\n    obj->on_cleanup(obj->udata_tls);\n  fio_str_free(&obj->name);\n}\n\n#define FIO_SET_NAME alpn_list\n#define FIO_SET_OBJ_TYPE alpn_s\n#define FIO_SET_OBJ_COMPARE(k1, k2) fio_alpn_cmp(&(k1), &(k2))\n#define FIO_SET_OBJ_COPY(dest, obj) fio_alpn_copy(&(dest), &(obj))\n#define FIO_SET_OBJ_DESTROY(key) fio_alpn_destroy(&(key))\n#define FIO_FORCE_MALLOC_TMP 1\n#include <fio.h>\n\n/* *****************************************************************************\nThe SSL/TLS Context type\n***************************************************************************** */\n\n/** An opaque type used for the SSL/TLS functions. */\nstruct fio_tls_s {\n  size_t ref;       /* Reference counter, to guards the ALPN registry */\n  alpn_list_s alpn; /* ALPN is the name for the protocol selection extension */\n\n  /*** the next two components could be optimized away with tweaking stuff ***/\n\n  cert_ary_s sni;    /* SNI (server name extension) stores ID certificates */\n  trust_ary_s trust; /* Trusted certificate registry (peer verification) */\n\n  /************ TODO: implementation data fields go here ******************/\n};\n\n/* *****************************************************************************\nALPN Helpers\n***************************************************************************** */\n\n/** Returns a pointer to the ALPN data (callback, etc') IF exists in the TLS. */\nFIO_FUNC inline alpn_s *alpn_find(fio_tls_s *tls, char *name, size_t len) {\n  alpn_s tmp = {.name = FIO_STR_INIT_STATIC2(name, len)};\n  alpn_list__map_s_ *pos =\n      alpn_list__find_map_pos_(&tls->alpn, fio_str_hash(&tmp.name), tmp);\n  if (!pos || !pos->pos)\n    return NULL;\n  return &pos->pos->obj;\n}\n\n/** Adds an ALPN data object to the ALPN \"list\" (set) */\nFIO_FUNC inline void alpn_add(\n    fio_tls_s *tls, const char *protocol_name,\n    void (*on_selected)(intptr_t uuid, void *udata_connection, void *udata_tls),\n    void *udata_tls, void (*on_cleanup)(void *udata_tls)) {\n  alpn_s tmp = {\n      .name = FIO_STR_INIT_STATIC(protocol_name),\n      .on_selected = on_selected,\n      .udata_tls = udata_tls,\n      .on_cleanup = on_cleanup,\n  };\n  if (fio_str_len(&tmp.name) > 255) {\n    FIO_LOG_ERROR(\"ALPN protocol names are limited to 255 bytes.\");\n    return;\n  }\n  alpn_list_overwrite(&tls->alpn, fio_str_hash(&tmp.name), tmp, NULL);\n  tmp.on_cleanup = NULL;\n  fio_alpn_destroy(&tmp);\n}\n\n/** Returns a pointer to the default (first) ALPN object in the TLS (if any). */\nFIO_FUNC inline alpn_s *alpn_default(fio_tls_s *tls) {\n  if (!tls || !alpn_list_count(&tls->alpn) || !tls->alpn.ordered)\n    return NULL;\n  return &tls->alpn.ordered[0].obj;\n}\n\ntypedef struct {\n  alpn_s alpn;\n  intptr_t uuid;\n  void *udata_connection;\n} alpn_task_s;\n\nFIO_FUNC inline void alpn_select___task(void *t_, void *ignr_) {\n  alpn_task_s *t = t_;\n  if (fio_is_valid(t->uuid))\n    t->alpn.on_selected(t->uuid, t->udata_connection, t->alpn.udata_tls);\n  fio_free(t);\n  (void)ignr_;\n}\n\n/** Schedules the ALPN protocol callback. */\nFIO_FUNC inline void alpn_select(alpn_s *alpn, intptr_t uuid,\n                                 void *udata_connection) {\n  if (!alpn || !alpn->on_selected)\n    return;\n  alpn_task_s *t = fio_malloc(sizeof(*t));\n  *t = (alpn_task_s){\n      .alpn = *alpn,\n      .uuid = uuid,\n      .udata_connection = udata_connection,\n  };\n  /* move task out of the socket's lock */\n  fio_defer(alpn_select___task, t, NULL);\n}\n\n/* *****************************************************************************\nSSL/TLS Context (re)-building - TODO: add implementation details\n***************************************************************************** */\n\n/** Called when the library specific data for the context should be destroyed */\nstatic void fio_tls_destroy_context(fio_tls_s *tls) {\n  /* TODO: Library specific implementation */\n  FIO_LOG_DEBUG(\"destroyed TLS context %p\", (void *)tls);\n}\n\n/** Called when the library specific data for the context should be built */\nstatic void fio_tls_build_context(fio_tls_s *tls) {\n  fio_tls_destroy_context(tls);\n  /* TODO: Library specific implementation */\n\n  /* Certificates */\n  FIO_ARY_FOR(&tls->sni, pos) {\n    fio_str_info_s k = fio_str_info(&pos->private_key);\n    fio_str_info_s p = fio_str_info(&pos->public_key);\n    fio_str_info_s pw = fio_str_info(&pos->password);\n    if (p.len && k.len) {\n      /* TODO: attache certificate */\n      (void)pw;\n    } else {\n      /* TODO: self signed certificate */\n    }\n  }\n\n  /* ALPN Protocols */\n  FIO_SET_FOR_LOOP(&tls->alpn, pos) {\n    fio_str_info_s name = fio_str_info(&pos->obj.name);\n    (void)name;\n    // map to pos->callback;\n  }\n\n  /* Peer Verification / Trust */\n  if (trust_ary_count(&tls->trust)) {\n    /* TODO: enable peer verification */\n\n    /* TODO: Add each ceriticate in the PEM to the trust \"store\" */\n    FIO_ARY_FOR(&tls->trust, pos) {\n      fio_str_info_s pem = fio_str_info(&pos->pem);\n      (void)pem;\n    }\n  }\n\n  FIO_LOG_DEBUG(\"(re)built TLS context %p\", (void *)tls);\n}\n\n/* *****************************************************************************\nSSL/TLS RW Hooks - TODO: add implementation details\n***************************************************************************** */\n\n/* TODO: this is an example implementation - fix for specific library. */\n\n#define TLS_BUFFER_LENGTH (1 << 15)\ntypedef struct {\n  fio_tls_s *tls;\n  size_t len;\n  uint8_t alpn_ok;\n  char buffer[TLS_BUFFER_LENGTH];\n} buffer_s;\n\n/**\n * Implement reading from a file descriptor. Should behave like the file\n * system `read` call, including the setup or errno to EAGAIN / EWOULDBLOCK.\n *\n * Note: facil.io library functions MUST NEVER be called by any r/w hook, or a\n * deadlock might occur.\n */\nstatic ssize_t fio_tls_read(intptr_t uuid, void *udata, void *buf,\n                            size_t count) {\n  ssize_t ret = read(fio_uuid2fd(uuid), buf, count);\n  if (ret > 0) {\n    FIO_LOG_DEBUG(\"Read %zd bytes from %p\", ret, (void *)uuid);\n  }\n  return ret;\n  (void)udata;\n}\n\n/**\n * When implemented, this function will be called to flush any data remaining\n * in the internal buffer.\n *\n * The function should return the number of bytes remaining in the internal\n * buffer (0 is a valid response) or -1 (on error).\n *\n * Note: facil.io library functions MUST NEVER be called by any r/w hook, or a\n * deadlock might occur.\n */\nstatic ssize_t fio_tls_flush(intptr_t uuid, void *udata) {\n  buffer_s *buffer = udata;\n  if (!buffer->len) {\n    FIO_LOG_DEBUG(\"Flush empty for %p\", (void *)uuid);\n    return 0;\n  }\n  ssize_t r = write(fio_uuid2fd(uuid), buffer->buffer, buffer->len);\n  if (r < 0)\n    return -1;\n  if (r == 0) {\n    errno = ECONNRESET;\n    return -1;\n  }\n  size_t len = buffer->len - r;\n  if (len)\n    memmove(buffer->buffer, buffer->buffer + r, len);\n  buffer->len = len;\n  FIO_LOG_DEBUG(\"Sent %zd bytes to %p\", r, (void *)uuid);\n  return r;\n}\n\n/**\n * Implement writing to a file descriptor. Should behave like the file system\n * `write` call.\n *\n * If an internal buffer is implemented and it is full, errno should be set to\n * EWOULDBLOCK and the function should return -1.\n *\n * Note: facil.io library functions MUST NEVER be called by any r/w hook, or a\n * deadlock might occur.\n */\nstatic ssize_t fio_tls_write(intptr_t uuid, void *udata, const void *buf,\n                             size_t count) {\n  buffer_s *buffer = udata;\n  size_t can_copy = TLS_BUFFER_LENGTH - buffer->len;\n  if (can_copy > count)\n    can_copy = count;\n  if (!can_copy)\n    goto would_block;\n  memcpy(buffer->buffer + buffer->len, buf, can_copy);\n  buffer->len += can_copy;\n  FIO_LOG_DEBUG(\"Copied %zu bytes to %p\", can_copy, (void *)uuid);\n  fio_tls_flush(uuid, udata);\n  return can_copy;\nwould_block:\n  errno = EWOULDBLOCK;\n  return -1;\n}\n\n/**\n * The `close` callback should close the underlying socket / file descriptor.\n *\n * If the function returns a non-zero value, it will be called again after an\n * attempt to flush the socket and any pending outgoing buffer.\n *\n * Note: facil.io library functions MUST NEVER be called by any r/w hook, or a\n * deadlock might occur.\n * */\nstatic ssize_t fio_tls_before_close(intptr_t uuid, void *udata) {\n  FIO_LOG_DEBUG(\"The `before_close` callback was called for %p\", (void *)uuid);\n  return 1;\n  (void)udata;\n}\n/**\n * Called to perform cleanup after the socket was closed.\n * */\nstatic void fio_tls_cleanup(void *udata) {\n  buffer_s *buffer = udata;\n  /* make sure the ALPN callback was called, just in case cleanup is required */\n  if (!buffer->alpn_ok) {\n    alpn_select(alpn_default(buffer->tls), -1, NULL /* ALPN udata */);\n  }\n  fio_tls_destroy(buffer->tls); /* manage reference count */\n  fio_free(udata);\n}\n\nstatic fio_rw_hook_s FIO_TLS_HOOKS = {\n    .read = fio_tls_read,\n    .write = fio_tls_write,\n    .before_close = fio_tls_before_close,\n    .flush = fio_tls_flush,\n    .cleanup = fio_tls_cleanup,\n};\n\nstatic size_t fio_tls_handshake(intptr_t uuid, void *udata) {\n  /*TODO: test for handshake completion */\n  if (0 /*handshake didn't complete */)\n    return 0;\n  if (fio_rw_hook_replace_unsafe(uuid, &FIO_TLS_HOOKS, udata) == 0) {\n    FIO_LOG_DEBUG(\"Completed TLS handshake for %p\", (void *)uuid);\n    /*\n     * make sure the connection is re-added to the reactor...\n     * in case, while waiting for ALPN, it was suspended for missing a protocol.\n     */\n    fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  } else {\n    FIO_LOG_DEBUG(\"Something went wrong during TLS handshake for %p\",\n                  (void *)uuid);\n  }\n  return 1;\n}\n\nstatic ssize_t fio_tls_read4handshake(intptr_t uuid, void *udata, void *buf,\n                                      size_t count) {\n  FIO_LOG_DEBUG(\"TLS handshake from read %p\", (void *)uuid);\n  if (fio_tls_handshake(uuid, udata))\n    return fio_tls_read(uuid, udata, buf, count);\n  errno = EWOULDBLOCK;\n  return -1;\n}\n\nstatic ssize_t fio_tls_write4handshake(intptr_t uuid, void *udata,\n                                       const void *buf, size_t count) {\n  FIO_LOG_DEBUG(\"TLS handshake from write %p\", (void *)uuid);\n  if (fio_tls_handshake(uuid, udata))\n    return fio_tls_write(uuid, udata, buf, count);\n  errno = EWOULDBLOCK;\n  return -1;\n}\n\nstatic ssize_t fio_tls_flush4handshake(intptr_t uuid, void *udata) {\n  FIO_LOG_DEBUG(\"TLS handshake from flush %p\", (void *)uuid);\n  if (fio_tls_handshake(uuid, udata))\n    return fio_tls_flush(uuid, udata);\n  /* TODO: return a positive value only if handshake requires a write */\n  return 1;\n}\nstatic fio_rw_hook_s FIO_TLS_HANDSHAKE_HOOKS = {\n    .read = fio_tls_read4handshake,\n    .write = fio_tls_write4handshake,\n    .before_close = fio_tls_before_close,\n    .flush = fio_tls_flush4handshake,\n    .cleanup = fio_tls_cleanup,\n};\n\nstatic inline void fio_tls_attach2uuid(intptr_t uuid, fio_tls_s *tls,\n                                       void *udata, uint8_t is_server) {\n  fio_atomic_add(&tls->ref, 1); /* manage reference count */\n  /* TODO: this is only an example implementation - fix for specific library */\n  if (is_server) {\n    /* Server mode (accept) */\n    FIO_LOG_DEBUG(\"Attaching TLS read/write hook for %p (server mode).\",\n                  (void *)uuid);\n  } else {\n    /* Client mode (connect) */\n    FIO_LOG_DEBUG(\"Attaching TLS read/write hook for %p (client mode).\",\n                  (void *)uuid);\n  }\n  /* common implementation (TODO) */\n  buffer_s *connection_data = fio_malloc(sizeof(*connection_data));\n  FIO_ASSERT_ALLOC(connection_data);\n  fio_rw_hook_set(uuid, &FIO_TLS_HANDSHAKE_HOOKS,\n                  connection_data); /* 32Kb buffer */\n  alpn_select(alpn_default(tls), uuid, udata);\n  connection_data->alpn_ok = 1;\n}\n\n/* *****************************************************************************\nSSL/TLS API implementation - this can be pretty much used as is...\n***************************************************************************** */\n\n/**\n * Creates a new SSL/TLS context / settings object with a default certificate\n * (if any).\n */\nfio_tls_s *FIO_TLS_WEAK fio_tls_new(const char *server_name, const char *cert,\n                                    const char *key, const char *pk_password) {\n  REQUIRE_LIBRARY();\n  fio_tls_s *tls = calloc(sizeof(*tls), 1);\n  tls->ref = 1;\n  fio_tls_cert_add(tls, server_name, key, cert, pk_password);\n  return tls;\n}\n\n/**\n * Adds a certificate  a new SSL/TLS context / settings object.\n */\nvoid FIO_TLS_WEAK fio_tls_cert_add(fio_tls_s *tls, const char *server_name,\n                                   const char *cert, const char *key,\n                                   const char *pk_password) {\n  REQUIRE_LIBRARY();\n  cert_s c = {\n      .private_key = FIO_STR_INIT,\n      .public_key = FIO_STR_INIT,\n      .password = FIO_STR_INIT_STATIC2(pk_password,\n                                       (pk_password ? strlen(pk_password) : 0)),\n  };\n  if (key && cert) {\n    if (fio_str_readfile(&c.private_key, key, 0, 0).data == NULL)\n      goto file_missing;\n    if (fio_str_readfile(&c.public_key, cert, 0, 0).data == NULL)\n      goto file_missing;\n    cert_ary_push(&tls->sni, c);\n  } else if (server_name) {\n    /* Self-Signed TLS Certificates */\n    c.private_key = FIO_STR_INIT_STATIC(server_name);\n    cert_ary_push(&tls->sni, c);\n  }\n  fio_tls_cert_destroy(&c);\n  fio_tls_build_context(tls);\n  return;\nfile_missing:\n  FIO_LOG_FATAL(\"TLS certificate file missing for either %s or %s or both.\",\n                key, cert);\n  exit(-1);\n}\n\n/**\n * Adds an ALPN protocol callback to the SSL/TLS context.\n *\n * The first protocol added will act as the default protocol to be selected.\n *\n * The callback should accept the `uuid`, the user data pointer passed to either\n * `fio_tls_accept` or `fio_tls_connect` (here: `udata_connetcion`) and the user\n * data pointer passed to the `fio_tls_alpn_add` function (`udata_tls`).\n *\n * The `on_cleanup` callback will be called when the TLS object is destroyed (or\n * `fio_tls_alpn_add` is called again with the same protocol name). The\n * `udata_tls` argumrnt will be passed along, as is, to the callback (if set).\n *\n * Except for the `tls` and `protocol_name` arguments, all arguments can be\n * NULL.\n */\nvoid FIO_TLS_WEAK fio_tls_alpn_add(\n    fio_tls_s *tls, const char *protocol_name,\n    void (*on_selected)(intptr_t uuid, void *udata_connection, void *udata_tls),\n    void *udata_tls, void (*on_cleanup)(void *udata_tls)) {\n  REQUIRE_LIBRARY();\n  alpn_add(tls, protocol_name, on_selected, udata_tls, on_cleanup);\n  fio_tls_build_context(tls);\n}\n\n/**\n * Returns the number of registered ALPN protocol names.\n *\n * This could be used when deciding if protocol selection should be delegated to\n * the ALPN mechanism, or whether a protocol should be immediately assigned.\n *\n * If no ALPN protocols are registered, zero (0) is returned.\n */\nuintptr_t FIO_TLS_WEAK fio_tls_alpn_count(fio_tls_s *tls) {\n  return tls ? alpn_list_count(&tls->alpn) : 0;\n}\n\n/**\n * Adds a certificate to the \"trust\" list, which automatically adds a peer\n * verification requirement.\n *\n *      fio_tls_trust(tls, \"google-ca.pem\" );\n */\nvoid FIO_TLS_WEAK fio_tls_trust(fio_tls_s *tls, const char *public_cert_file) {\n  REQUIRE_LIBRARY();\n  trust_s c = {\n      .pem = FIO_STR_INIT,\n  };\n  if (!public_cert_file)\n    return;\n  if (fio_str_readfile(&c.pem, public_cert_file, 0, 0).data == NULL)\n    goto file_missing;\n  trust_ary_push(&tls->trust, c);\n  fio_tls_trust_destroy(&c);\n  fio_tls_build_context(tls);\n  return;\nfile_missing:\n  FIO_LOG_FATAL(\"TLS certificate file missing for %s \", public_cert_file);\n  exit(-1);\n}\n\n/**\n * Establishes an SSL/TLS connection as an SSL/TLS Server, using the specified\n * context / settings object.\n *\n * The `uuid` should be a socket UUID that is already connected to a peer (i.e.,\n * the result of `fio_accept`).\n *\n * The `udata` is an opaque user data pointer that is passed along to the\n * protocol selected (if any protocols were added using `fio_tls_alpn_add`).\n */\nvoid FIO_TLS_WEAK fio_tls_accept(intptr_t uuid, fio_tls_s *tls, void *udata) {\n  REQUIRE_LIBRARY();\n  fio_tls_attach2uuid(uuid, tls, udata, 1);\n}\n\n/**\n * Establishes an SSL/TLS connection as an SSL/TLS Client, using the specified\n * context / settings object.\n *\n * The `uuid` should be a socket UUID that is already connected to a peer (i.e.,\n * one received by a `fio_connect` specified callback `on_connect`).\n *\n * The `udata` is an opaque user data pointer that is passed along to the\n * protocol selected (if any protocols were added using `fio_tls_alpn_add`).\n */\nvoid FIO_TLS_WEAK fio_tls_connect(intptr_t uuid, fio_tls_s *tls, void *udata) {\n  REQUIRE_LIBRARY();\n  fio_tls_attach2uuid(uuid, tls, udata, 0);\n}\n\n/**\n * Increase the reference count for the TLS object.\n *\n * Decrease with `fio_tls_destroy`.\n */\nvoid FIO_TLS_WEAK fio_tls_dup(fio_tls_s *tls) { fio_atomic_add(&tls->ref, 1); }\n\n/**\n * Destroys the SSL/TLS context / settings object and frees any related\n * resources / memory.\n */\nvoid FIO_TLS_WEAK fio_tls_destroy(fio_tls_s *tls) {\n  if (!tls)\n    return;\n  REQUIRE_LIBRARY();\n  if (fio_atomic_sub(&tls->ref, 1))\n    return;\n  fio_tls_destroy_context(tls);\n  alpn_list_free(&tls->alpn);\n  cert_ary_free(&tls->sni);\n  free(tls);\n}\n\n#endif /* Library compiler flags */\n", "/*\nCopyright: Boaz Segev, 2018-2019\nLicense: MIT\n\nFeel free to copy, use and enjoy according to the license provided.\n*/\n#include <fio.h>\n\n/**\n * This implementation of the facil.io SSL/TLS wrapper API wraps the OpenSSL API\n * to provide TLS 1.2 and TLS 1.3 to facil.io applications.\n *\n * The implementation requires `HAVE_OPENSSL` to be set.\n */\n#include \"fio_tls.h\"\n\n#if HAVE_OPENSSL\n#include <openssl/bio.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n\n#define REQUIRE_LIBRARY()\n#define FIO_TLS_WEAK\n\n/* *****************************************************************************\nThe SSL/TLS helper data types (can be left as is)\n***************************************************************************** */\n#define FIO_INCLUDE_STR 1\n#define FIO_FORCE_MALLOC_TMP 1\n#include <fio.h>\n\ntypedef struct {\n  fio_str_s private_key;\n  fio_str_s public_key;\n  fio_str_s password;\n} cert_s;\n\nstatic inline int fio_tls_cert_cmp(const cert_s *dest, const cert_s *src) {\n  return fio_str_iseq(&dest->private_key, &src->private_key);\n}\nstatic inline void fio_tls_cert_copy(cert_s *dest, cert_s *src) {\n  *dest = (cert_s){\n      .private_key = FIO_STR_INIT,\n      .public_key = FIO_STR_INIT,\n      .password = FIO_STR_INIT,\n  };\n  fio_str_concat(&dest->private_key, &src->private_key);\n  fio_str_concat(&dest->public_key, &src->public_key);\n  fio_str_concat(&dest->password, &src->password);\n}\nstatic inline void fio_tls_cert_destroy(cert_s *obj) {\n  fio_str_free(&obj->private_key);\n  fio_str_free(&obj->public_key);\n  fio_str_free(&obj->password);\n}\n\n#define FIO_ARY_NAME cert_ary\n#define FIO_ARY_TYPE cert_s\n#define FIO_ARY_COMPARE(k1, k2) (fio_tls_cert_cmp(&(k1), &(k2)))\n#define FIO_ARY_COPY(dest, obj) fio_tls_cert_copy(&(dest), &(obj))\n#define FIO_ARY_DESTROY(key) fio_tls_cert_destroy(&(key))\n#define FIO_FORCE_MALLOC_TMP 1\n#include <fio.h>\n\ntypedef struct {\n  fio_str_s pem;\n} trust_s;\n\nstatic inline int fio_tls_trust_cmp(const trust_s *dest, const trust_s *src) {\n  return fio_str_iseq(&dest->pem, &src->pem);\n}\nstatic inline void fio_tls_trust_copy(trust_s *dest, trust_s *src) {\n  *dest = (trust_s){\n      .pem = FIO_STR_INIT,\n  };\n  fio_str_concat(&dest->pem, &src->pem);\n}\nstatic inline void fio_tls_trust_destroy(trust_s *obj) {\n  fio_str_free(&obj->pem);\n}\n\n#define FIO_ARY_NAME trust_ary\n#define FIO_ARY_TYPE trust_s\n#define FIO_ARY_COMPARE(k1, k2) (fio_tls_trust_cmp(&(k1), &(k2)))\n#define FIO_ARY_COPY(dest, obj) fio_tls_trust_copy(&(dest), &(obj))\n#define FIO_ARY_DESTROY(key) fio_tls_trust_destroy(&(key))\n#define FIO_FORCE_MALLOC_TMP 1\n#include <fio.h>\n\ntypedef struct {\n  fio_str_s name; /* fio_str_s provides cache locality for small strings */\n  void (*on_selected)(intptr_t uuid, void *udata_connection, void *udata_tls);\n  void *udata_tls;\n  void (*on_cleanup)(void *udata_tls);\n} alpn_s;\n\nstatic inline int fio_alpn_cmp(const alpn_s *dest, const alpn_s *src) {\n  return fio_str_iseq(&dest->name, &src->name);\n}\nstatic inline void fio_alpn_copy(alpn_s *dest, alpn_s *src) {\n  *dest = (alpn_s){\n      .name = FIO_STR_INIT,\n      .on_selected = src->on_selected,\n      .udata_tls = src->udata_tls,\n      .on_cleanup = src->on_cleanup,\n  };\n  fio_str_concat(&dest->name, &src->name);\n}\nstatic inline void fio_alpn_destroy(alpn_s *obj) {\n  if (obj->on_cleanup)\n    obj->on_cleanup(obj->udata_tls);\n  fio_str_free(&obj->name);\n}\n\n#define FIO_SET_NAME alpn_list\n#define FIO_SET_OBJ_TYPE alpn_s\n#define FIO_SET_OBJ_COMPARE(k1, k2) fio_alpn_cmp(&(k1), &(k2))\n#define FIO_SET_OBJ_COPY(dest, obj) fio_alpn_copy(&(dest), &(obj))\n#define FIO_SET_OBJ_DESTROY(key) fio_alpn_destroy(&(key))\n#define FIO_FORCE_MALLOC_TMP 1\n#include <fio.h>\n\n/* *****************************************************************************\nThe SSL/TLS type\n***************************************************************************** */\n\n/** An opaque type used for the SSL/TLS functions. */\nstruct fio_tls_s {\n  size_t ref;       /* Reference counter, to guards the ALPN registry */\n  alpn_list_s alpn; /* ALPN is the name for the protocol selection extension */\n\n  /*** the next two components could be optimized away with tweaking stuff ***/\n\n  cert_ary_s sni;    /* SNI (server name extension) stores ID certificates */\n  trust_ary_s trust; /* Trusted certificate registry (peer verification) */\n\n  /************ TODO: implementation data fields go here ******************/\n\n  SSL_CTX *ctx;            /* The Open SSL context (updated each time). */\n  unsigned char *alpn_str; /* the computed server-format ALPN string */\n  int alpn_len;\n};\n\n/* *****************************************************************************\nALPN Helpers\n***************************************************************************** */\n\n/** Returns a pointer to the ALPN data (callback, etc') IF exists in the TLS. */\nFIO_FUNC inline alpn_s *alpn_find(fio_tls_s *tls, char *name, size_t len) {\n  alpn_s tmp = {.name = FIO_STR_INIT_STATIC2(name, len)};\n  alpn_list__map_s_ *pos =\n      alpn_list__find_map_pos_(&tls->alpn, fio_str_hash(&tmp.name), tmp);\n  if (!pos || !pos->pos)\n    return NULL;\n  return &pos->pos->obj;\n}\n\n/** Adds an ALPN data object to the ALPN \"list\" (set) */\nFIO_FUNC inline void alpn_add(\n    fio_tls_s *tls, const char *protocol_name,\n    void (*on_selected)(intptr_t uuid, void *udata_connection, void *udata_tls),\n    void *udata_tls, void (*on_cleanup)(void *udata_tls)) {\n  alpn_s tmp = {\n      .name = FIO_STR_INIT_STATIC(protocol_name),\n      .on_selected = on_selected,\n      .udata_tls = udata_tls,\n      .on_cleanup = on_cleanup,\n  };\n  if (fio_str_len(&tmp.name) > 255) {\n    FIO_LOG_ERROR(\"ALPN protocol names are limited to 255 bytes.\");\n    return;\n  }\n  alpn_list_overwrite(&tls->alpn, fio_str_hash(&tmp.name), tmp, NULL);\n  tmp.on_cleanup = NULL;\n  fio_alpn_destroy(&tmp);\n}\n\n/** Returns a pointer to the default (first) ALPN object in the TLS (if any). */\nFIO_FUNC inline alpn_s *alpn_default(fio_tls_s *tls) {\n  if (!tls || !alpn_list_count(&tls->alpn) || !tls->alpn.ordered)\n    return NULL;\n  return &tls->alpn.ordered[0].obj;\n}\n\ntypedef struct {\n  alpn_s alpn;\n  intptr_t uuid;\n  void *udata_connection;\n} alpn_task_s;\n\nFIO_FUNC inline void alpn_select___task(void *t_, void *ignr_) {\n  alpn_task_s *t = t_;\n  t->alpn.on_selected((fio_is_valid(t->uuid) ? t->uuid : -1),\n                      t->udata_connection, t->alpn.udata_tls);\n  fio_free(t);\n  (void)ignr_;\n}\n\n/** Schedules the ALPN protocol callback. */\nFIO_FUNC inline void alpn_select(alpn_s *alpn, intptr_t uuid,\n                                 void *udata_connection) {\n  if (!alpn || !alpn->on_selected)\n    return;\n  alpn_task_s *t = fio_malloc(sizeof(*t));\n  *t = (alpn_task_s){\n      .alpn = *alpn,\n      .uuid = uuid,\n      .udata_connection = udata_connection,\n  };\n  fio_defer(alpn_select___task, t, NULL);\n}\n\n/* *****************************************************************************\nOpenSSL Helpers\n***************************************************************************** */\n\nstatic EVP_PKEY *fio_tls_pkey = NULL;\n\nstatic void fio_tls_clear_root_key(void *key) {\n  EVP_PKEY_free(key);\n  fio_tls_pkey = NULL;\n}\n\nstatic void fio_tls_make_root_key(void) {\n  static fio_lock_i lock = FIO_LOCK_INIT;\n  fio_lock(&lock);\n  if (fio_tls_pkey)\n    goto finish;\n  /* create private key, free it at exit */\n  FIO_LOG_DEBUG(\"calculating a new TLS private key... might take a while.\");\n\n  fio_tls_pkey = EVP_PKEY_new();\n  FIO_ASSERT(fio_tls_pkey, \"OpenSSL failed to create private key.\");\n\n  /* TODO: replace RSA with something else? is there something else? */\n  RSA *rsa = RSA_new();\n  BIGNUM *e = BN_new();\n  BN_clear(e);\n  BN_add_word(e, 65537);\n  FIO_ASSERT_ALLOC(e);\n  FIO_ASSERT(RSA_generate_key_ex(rsa, 2048, e, NULL),\n             \"OpenSSL failed to create RSA key.\");\n  BN_free(e);\n  EVP_PKEY_assign_RSA(fio_tls_pkey, rsa);\n  fio_state_callback_add(FIO_CALL_AT_EXIT, fio_tls_clear_root_key,\n                         fio_tls_pkey);\nfinish:\n  fio_unlock(&lock);\n}\n\nstatic X509 *fio_tls_create_self_signed(char *server_name) {\n  X509 *cert = X509_new();\n  static uint32_t counter = 0;\n  FIO_ASSERT(cert,\n             \"OpenSSL failed to allocate memory for self-signed ceritifcate.\");\n  fio_tls_make_root_key();\n\n  /* serial number */\n  fio_atomic_add(&counter, 1);\n  ASN1_INTEGER_set(X509_get_serialNumber(cert), counter);\n\n  /* validity (180 days) */\n  X509_gmtime_adj(X509_get_notBefore(cert), 0);\n  X509_gmtime_adj(X509_get_notAfter(cert), 15552000L);\n\n  /* set (public) key */\n  X509_set_pubkey(cert, fio_tls_pkey);\n\n  /* set identity details */\n  X509_NAME *s = X509_get_subject_name(cert);\n  size_t srv_name_len = strlen(server_name);\n  X509_NAME_add_entry_by_txt(s, \"O\", MBSTRING_ASC, (unsigned char *)server_name,\n                             srv_name_len, -1, 0);\n  X509_NAME_add_entry_by_txt(s, \"CN\", MBSTRING_ASC,\n                             (unsigned char *)server_name, srv_name_len, -1, 0);\n  X509_NAME_add_entry_by_txt(s, \"CA\", MBSTRING_ASC,\n                             (unsigned char *)server_name, srv_name_len, -1, 0);\n  X509_set_issuer_name(cert, s);\n\n  /* sign certificate */\n  FIO_ASSERT(X509_sign(cert, fio_tls_pkey, EVP_sha512()),\n             \"OpenSSL failed to signe self-signed certificate\");\n  // FILE *fp = fopen(\"tmp.pem\", \"ab+\");\n  // if (fp) {\n  //   PEM_write_X509(fp, cert);\n  //   fclose(fp);\n  // }\n\n  return cert;\n}\n\n/* *****************************************************************************\nSSL/TLS Context (re)-building\n***************************************************************************** */\n\n#define TLS_BUFFER_LENGTH (1 << 15)\ntypedef struct {\n  SSL *ssl;\n  fio_tls_s *tls;\n  void *alpn_arg;\n  intptr_t uuid;\n  uint8_t is_server;\n  volatile uint8_t alpn_ok;\n} fio_tls_connection_s;\n\nstatic void fio_tls_alpn_fallback(fio_tls_connection_s *c) {\n  alpn_s *alpn = alpn_default(c->tls);\n  if (!alpn || !alpn->on_selected)\n    return;\n  /* set protocol to default protocol */\n  FIO_LOG_DEBUG(\"TLS ALPN handshake missing, falling back on %s for %p\",\n                fio_str_info(&alpn->name).data, (void *)c->uuid);\n  alpn_select(alpn, c->uuid, c->alpn_arg);\n}\nstatic int fio_tls_alpn_selector_cb(SSL *ssl, const unsigned char **out,\n                                    unsigned char *outlen,\n                                    const unsigned char *in, unsigned int inlen,\n                                    void *tls_) {\n  fio_tls_s *tls = tls_;\n  alpn_s *alpn;\n  /* TODO: select ALPN and call on_selected */\n  fio_tls_connection_s *c = SSL_get_ex_data(ssl, 0);\n  c->alpn_ok = 1;\n\n  if (alpn_list_count(&tls->alpn) == 0)\n    return SSL_TLSEXT_ERR_NOACK;\n  const unsigned char *end = in + inlen;\n  while (in < end) {\n    uint8_t l = in[0];\n    alpn = alpn_find(tls, (char *)in + 1, l);\n    in += l + 1;\n    if (!alpn)\n      continue;\n    fio_str_info_s info = fio_str_info(&alpn->name);\n    *out = (unsigned char *)info.data;\n    *outlen = (unsigned char)info.len;\n    FIO_LOG_DEBUG(\"TLS ALPN set to: %s for %p\", info.data, (void *)c->uuid);\n    alpn_select(alpn, c->uuid, c->alpn_arg);\n    return SSL_TLSEXT_ERR_OK;\n  }\n  /* set protocol to default protocol */\n  alpn = alpn_default(tls);\n  alpn_select(alpn, c->uuid, c->alpn_arg);\n  FIO_LOG_DEBUG(\n      \"TLS ALPN handshake failed, falling back on default (%s) for %p\",\n      fio_str_data(&alpn->name), (void *)c->uuid);\n  return SSL_TLSEXT_ERR_NOACK;\n  (void)ssl;\n  (void)out;\n  (void)outlen;\n  (void)in;\n  (void)inlen;\n  (void)tls;\n}\n\n/** Called when the library specific data for the context should be destroyed */\nstatic void fio_tls_destroy_context(fio_tls_s *tls) {\n  /* TODO: Library specific implementation */\n  SSL_CTX_free(tls->ctx);\n  free(tls->alpn_str);\n\n  tls->ctx = NULL;\n  tls->alpn_str = NULL;\n  tls->alpn_len = 0;\n  FIO_LOG_DEBUG(\"destroyed TLS context for OpenSSL %p\", (void *)tls);\n}\n\nstatic int fio_tls_pem_passwd_cb(char *buf, int size, int rwflag,\n                                 void *password) {\n  fio_str_info_s *p = password;\n  if (!p || !p->len || !size)\n    return 0;\n  int len = (size <= (int)p->len) ? (size - 1) : (int)p->len;\n  memcpy(buf, p->data, len);\n  buf[len] = 0;\n  return len;\n  (void)rwflag;\n}\n\n/** Called when the library specific data for the context should be built */\nstatic void fio_tls_build_context(fio_tls_s *tls) {\n  fio_tls_destroy_context(tls);\n  /* TODO: Library specific implementation */\n\n  /* create new context */\n  tls->ctx = SSL_CTX_new(TLS_method());\n  SSL_CTX_set_mode(tls->ctx, SSL_MODE_ENABLE_PARTIAL_WRITE);\n  /* see: https://caniuse.com/#search=tls */\n  SSL_CTX_set_min_proto_version(tls->ctx, TLS1_2_VERSION);\n  SSL_CTX_set_options(tls->ctx, SSL_OP_NO_COMPRESSION);\n\n  /* attach certificates */\n  FIO_ARY_FOR(&tls->sni, pos) {\n    fio_str_info_s keys[4] = {\n        fio_str_info(&pos->private_key), fio_str_info(&pos->public_key),\n        fio_str_info(&pos->password),\n        /* empty password slot for public key */\n    };\n    if (keys[0].len && keys[1].len) {\n      if (1) {\n        /* Extract private key from private key file */\n        BIO *bio = BIO_new_mem_buf(keys[0].data, keys[0].len);\n        if (bio) {\n          EVP_PKEY *k = PEM_read_bio_PrivateKey(\n              bio, NULL, fio_tls_pem_passwd_cb, keys + 2);\n          if (k) {\n            FIO_LOG_DEBUG(\"TLS read private key from PEM file.\");\n            SSL_CTX_use_PrivateKey(tls->ctx, k);\n          }\n          BIO_free(bio);\n        }\n      }\n      /* Certificate Files loaded */\n      for (int ki = 0; ki < 2; ++ki) {\n        /* Extract as much data as possible from each file */\n        BIO *bio = BIO_new_mem_buf(keys[ki].data, keys[ki].len);\n        FIO_ASSERT(bio, \"OpenSSL error allocating BIO.\");\n        STACK_OF(X509_INFO) *inf = PEM_X509_INFO_read_bio(\n            bio, NULL, fio_tls_pem_passwd_cb, keys + ki + 2);\n        if (inf) {\n          for (int i = 0; i < sk_X509_INFO_num(inf); ++i) {\n            /* for each element in PEM */\n            X509_INFO *tmp = sk_X509_INFO_value(inf, i);\n            if (tmp->x509) {\n              FIO_LOG_DEBUG(\"TLS adding certificate from PEM file.\");\n              SSL_CTX_use_certificate(tls->ctx, tmp->x509);\n            }\n            if (tmp->x_pkey) {\n              FIO_LOG_DEBUG(\"TLS adding private key from PEM file.\");\n              SSL_CTX_use_PrivateKey(tls->ctx, tmp->x_pkey->dec_pkey);\n            }\n          }\n          sk_X509_INFO_pop_free(inf, X509_INFO_free);\n        } else {\n          /* TODO: attempt DER format? */\n          // X509 *c;\n          // EVP_PKEY *k;\n          // const uint8_t *pdata = (uint8_t *)&keys[ki].data;\n          // d2i_X509(&c, &pdata, keys[ki].len);\n          // pdata = (uint8_t *)&keys[ki].data;\n          // d2i_AutoPrivateKey(&k, &pdata, keys[ki].len);\n        }\n        BIO_free(bio);\n      }\n    } else if (keys[0].len) {\n      /* Self Signed Certificates, only if server name is provided. */\n      SSL_CTX_use_certificate(tls->ctx,\n                              fio_tls_create_self_signed(keys[0].data));\n      SSL_CTX_use_PrivateKey(tls->ctx, fio_tls_pkey);\n    }\n  }\n\n  /* setup ALPN support */\n  if (1) {\n    size_t alpn_pos = 0;\n    /* looping twice is better than malloc fragmentation. */\n    FIO_SET_FOR_LOOP(&tls->alpn, pos) {\n      fio_str_info_s s = fio_str_info(&pos->obj.name);\n      if (!s.len)\n        continue;\n      alpn_pos += s.len + 1;\n    }\n    tls->alpn_str = malloc((alpn_pos | 15) + 1); /* round up to 16 + padding */\n    alpn_pos = 0;\n    FIO_SET_FOR_LOOP(&tls->alpn, pos) {\n      fio_str_info_s s = fio_str_info(&pos->obj.name);\n      if (!s.len)\n        continue;\n      tls->alpn_str[alpn_pos++] = (uint8_t)s.len;\n      memcpy(tls->alpn_str + alpn_pos, s.data, s.len);\n      alpn_pos += s.len;\n    }\n    tls->alpn_len = alpn_pos;\n    SSL_CTX_set_alpn_select_cb(tls->ctx, fio_tls_alpn_selector_cb, tls);\n    SSL_CTX_set_alpn_protos(tls->ctx, tls->alpn_str, tls->alpn_len);\n  }\n\n  /* Peer Verification / Trust */\n  if (trust_ary_count(&tls->trust)) {\n    /* TODO: enable peer verification */\n    X509_STORE *store = X509_STORE_new();\n    SSL_CTX_set_cert_store(tls->ctx, store);\n    SSL_CTX_set_verify(tls->ctx, SSL_VERIFY_PEER, NULL);\n    /* TODO: Add each ceriticate in the PEM to the trust \"store\" */\n    FIO_ARY_FOR(&tls->trust, pos) {\n      fio_str_info_s pem = fio_str_info(&pos->pem);\n      BIO *bio = BIO_new_mem_buf(pem.data, pem.len);\n      FIO_ASSERT(bio, \"OpenSSL error allocating BIO.\");\n      STACK_OF(X509_INFO) *inf = PEM_X509_INFO_read_bio(bio, NULL, NULL, NULL);\n      if (inf) {\n        for (int i = 0; i < sk_X509_INFO_num(inf); ++i) {\n          /* for each element in PEM */\n          X509_INFO *tmp = sk_X509_INFO_value(inf, i);\n          if (tmp->x509) {\n            FIO_LOG_DEBUG(\"TLS trusting certificate from PEM file.\");\n            X509_STORE_add_cert(store, tmp->x509);\n          }\n          if (tmp->crl) {\n            X509_STORE_add_crl(store, tmp->crl);\n          }\n        }\n        sk_X509_INFO_pop_free(inf, X509_INFO_free);\n      }\n      BIO_free(bio);\n    }\n  }\n\n  FIO_LOG_DEBUG(\"(re)built TLS context for OpenSSL %p\", (void *)tls);\n}\n\n/* *****************************************************************************\nSSL/TLS RW Hooks\n***************************************************************************** */\n\nstatic void fio_tls_delayed_close(void *uuid, void *ignr_) {\n  fio_close((intptr_t)uuid);\n  (void)ignr_;\n}\n\n/* TODO: this is an example implementation - fix for specific library. */\n\n/**\n * Implement reading from a file descriptor. Should behave like the file\n * system `read` call, including the setup or errno to EAGAIN / EWOULDBLOCK.\n *\n * Note: facil.io library functions MUST NEVER be called by any r/w hook, or a\n * deadlock might occur.\n */\nstatic ssize_t fio_tls_read(intptr_t uuid, void *udata, void *buf,\n                            size_t count) {\n  fio_tls_connection_s *c = udata;\n  ssize_t ret = SSL_read(c->ssl, buf, count);\n  if (ret > 0)\n    return ret;\n  ret = SSL_get_error(c->ssl, ret);\n  switch (ret) {\n  case SSL_ERROR_SSL: /* overflow */\n  case SSL_ERROR_ZERO_RETURN:\n    return 0;                      /* EOF */\n  case SSL_ERROR_NONE:             /* overflow */\n  case SSL_ERROR_WANT_CONNECT:     /* overflow */\n  case SSL_ERROR_WANT_ACCEPT:      /* overflow */\n  case SSL_ERROR_WANT_X509_LOOKUP: /* overflow */\n#ifdef SSL_ERROR_WANT_ASYNC\n  case SSL_ERROR_WANT_ASYNC: /* overflow */\n#endif\n  case SSL_ERROR_WANT_WRITE: /* overflow */\n  case SSL_ERROR_WANT_READ:\n  default:\n    break;\n  }\n  errno = EWOULDBLOCK;\n  return -1;\n  (void)uuid;\n}\n\n/**\n * When implemented, this function will be called to flush any data remaining\n * in the internal buffer.\n *\n * The function should return the number of bytes remaining in the internal\n * buffer (0 is a valid response) or -1 (on error).\n *\n * Note: facil.io library functions MUST NEVER be called by any r/w hook, or a\n * deadlock might occur.\n */\nstatic ssize_t fio_tls_flush(intptr_t uuid, void *udata) {\n  (void)uuid;\n  (void)udata;\n  return 0;\n}\n\n/**\n * Implement writing to a file descriptor. Should behave like the file system\n * `write` call.\n *\n * If an internal buffer is implemented and it is full, errno should be set to\n * EWOULDBLOCK and the function should return -1.\n *\n * Note: facil.io library functions MUST NEVER be called by any r/w hook, or a\n * deadlock might occur.\n */\nstatic ssize_t fio_tls_write(intptr_t uuid, void *udata, const void *buf,\n                             size_t count) {\n  fio_tls_connection_s *c = udata;\n  ssize_t ret = SSL_write(c->ssl, buf, count);\n  if (ret > 0)\n    return ret;\n  ret = SSL_get_error(c->ssl, ret);\n  switch (ret) {\n  case SSL_ERROR_SSL: /* overflow */\n  case SSL_ERROR_ZERO_RETURN:\n    return 0;                      /* EOF */\n  case SSL_ERROR_NONE:             /* overflow */\n  case SSL_ERROR_WANT_CONNECT:     /* overflow */\n  case SSL_ERROR_WANT_ACCEPT:      /* overflow */\n  case SSL_ERROR_WANT_X509_LOOKUP: /* overflow */\n#ifdef SSL_ERROR_WANT_ASYNC\n  case SSL_ERROR_WANT_ASYNC: /* overflow */\n#endif\n  case SSL_ERROR_WANT_WRITE: /* overflow */\n  case SSL_ERROR_WANT_READ:\n  default:\n    break;\n  }\n  errno = EWOULDBLOCK;\n  return -1;\n  (void)uuid;\n}\n\n/**\n * The `close` callback should close the underlying socket / file descriptor.\n *\n * If the function returns a non-zero value, it will be called again after an\n * attempt to flush the socket and any pending outgoing buffer.\n *\n * Note: facil.io library functions MUST NEVER be called by any r/w hook, or a\n * deadlock might occur.\n * */\nstatic ssize_t fio_tls_before_close(intptr_t uuid, void *udata) {\n  fio_tls_connection_s *c = udata;\n  SSL_shutdown(c->ssl);\n  return 1;\n  (void)uuid;\n}\n/**\n * Called to perform cleanup after the socket was closed.\n * */\nstatic void fio_tls_cleanup(void *udata) {\n  fio_tls_connection_s *c = udata;\n  if (!c->alpn_ok) {\n    alpn_select(alpn_default(c->tls), -1, c->alpn_arg);\n  }\n  SSL_free(c->ssl);\n  FIO_LOG_DEBUG(\"TLS cleanup for %p\", (void *)c->uuid);\n  fio_tls_destroy(c->tls); /* manage reference count */\n  free(udata);\n}\n\nstatic fio_rw_hook_s FIO_TLS_HOOKS = {\n    .read = fio_tls_read,\n    .write = fio_tls_write,\n    .before_close = fio_tls_before_close,\n    .flush = fio_tls_flush,\n    .cleanup = fio_tls_cleanup,\n};\n\nstatic size_t fio_tls_handshake(intptr_t uuid, void *udata) {\n  fio_tls_connection_s *c = udata;\n  int ri;\n  if (c->is_server) {\n    ri = SSL_accept(c->ssl);\n  } else {\n    ri = SSL_connect(c->ssl);\n  }\n  if (ri != 1) {\n    ri = SSL_get_error(c->ssl, ri);\n    switch (ri) {\n    case SSL_ERROR_NONE:\n      // FIO_LOG_DEBUG(\"SSL_accept/SSL_connect %p state: SSL_ERROR_NONE\",\n      //               (void *)uuid);\n      return 0;\n    case SSL_ERROR_WANT_WRITE:\n      // FIO_LOG_DEBUG(\"SSL_accept/SSL_connect %p state: SSL_ERROR_WANT_WRITE\",\n      //               (void *)uuid);\n      //   fio_force_event(uuid, FIO_EVENT_ON_READY);\n      return 0;\n    case SSL_ERROR_WANT_READ:\n      // FIO_LOG_DEBUG(\"SSL_accept/SSL_connect %p state: SSL_ERROR_WANT_READ\",\n      //               (void *)uuid);\n      // fio_force_event(uuid, FIO_EVENT_ON_DATA);\n      return 0;\n    case SSL_ERROR_SYSCALL:\n      FIO_LOG_DEBUG(\n          \"SSL_accept/SSL_connect %p error: SSL_ERROR_SYSCALL, errno: %s\",\n          (void *)uuid, strerror(errno));\n      // fio_force_event(uuid, FIO_EVENT_ON_DATA);\n      return 0;\n    case SSL_ERROR_SSL:\n      FIO_LOG_DEBUG(\"SSL_accept/SSL_connect %p error: SSL_ERROR_SSL\",\n                    (void *)uuid);\n      break;\n    case SSL_ERROR_ZERO_RETURN:\n      FIO_LOG_DEBUG(\"SSL_accept/SSL_connect %p error: SSL_ERROR_ZERO_RETURN\",\n                    (void *)uuid);\n      break;\n    case SSL_ERROR_WANT_CONNECT:\n      FIO_LOG_DEBUG(\"SSL_accept/SSL_connect %p error: SSL_ERROR_WANT_CONNECT\",\n                    (void *)uuid);\n      break;\n    case SSL_ERROR_WANT_ACCEPT:\n      FIO_LOG_DEBUG(\"SSL_accept/SSL_connect %p error: SSL_ERROR_WANT_ACCEPT\",\n                    (void *)uuid);\n      break;\n    case SSL_ERROR_WANT_X509_LOOKUP:\n      FIO_LOG_DEBUG(\n          \"SSL_accept/SSL_connect %p error: SSL_ERROR_WANT_X509_LOOKUP\",\n          (void *)uuid);\n      break;\n#ifdef SSL_ERROR_WANT_ASYNC\n    case SSL_ERROR_WANT_ASYNC:\n      FIO_LOG_DEBUG(\"SSL_accept/SSL_connect %p error: SSL_ERROR_WANT_ASYNC\",\n                    (void *)uuid);\n      break;\n#endif\n#ifdef SSL_ERROR_WANT_CLIENT_HELLO_CB\n    case SSL_ERROR_WANT_CLIENT_HELLO_CB:\n      FIO_LOG_DEBUG(\n          \"SSL_accept/SSL_connect %p error: SSL_ERROR_WANT_CLIENT_HELLO_CB\",\n          (void *)uuid);\n      break;\n#endif\n    default:\n      FIO_LOG_DEBUG(\"SSL_accept/SSL_connect %p error: unknown (%d).\",\n                    (void *)uuid, ri);\n      break;\n    }\n    fio_defer(fio_tls_delayed_close, (void *)uuid, NULL);\n    return 0;\n  }\n  if (!c->alpn_ok) {\n    c->alpn_ok = 1;\n    if (c->is_server) {\n      fio_tls_alpn_fallback(c);\n    } else {\n      const unsigned char *proto;\n      unsigned int proto_len;\n      SSL_get0_alpn_selected(c->ssl, &proto, &proto_len);\n      alpn_s *alpn = NULL;\n      if (proto_len > 0) {\n        alpn = alpn_find(c->tls, (char *)proto, proto_len);\n      }\n      if (!alpn) {\n        alpn = alpn_default(c->tls);\n        FIO_LOG_DEBUG(\"ALPN missing for TLS client %p\", (void *)uuid);\n      }\n      if (alpn)\n        FIO_LOG_DEBUG(\"setting ALPN %s for TLS client %p\",\n                      fio_str_data(&alpn->name), (void *)uuid);\n      alpn_select(alpn, c->uuid, c->alpn_arg);\n    }\n  }\n  if (fio_rw_hook_replace_unsafe(uuid, &FIO_TLS_HOOKS, udata) == 0) {\n    FIO_LOG_DEBUG(\"Completed TLS handshake for %p\", (void *)uuid);\n  } else {\n    FIO_LOG_DEBUG(\"Something went wrong during TLS handshake for %p\",\n                  (void *)uuid);\n    return 0;\n  }\n  /* make sure the connection is re-added to the reactor */\n  fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  /* log session ID for WireShark */\n#if FIO_TLS_PRINT_SECRET\n  if (FIO_LOG_LEVEL >= FIO_LOG_LEVEL_DEBUG) {\n    unsigned char buff[SSL_MAX_MASTER_KEY_LENGTH + 2];\n    size_t ret = SSL_SESSION_get_master_key(SSL_get_session(c->ssl), buff,\n                                            SSL_MAX_MASTER_KEY_LENGTH + 1);\n    buff[ret] = 0;\n    unsigned char buff2[(SSL_MAX_MASTER_KEY_LENGTH + 2) << 1];\n    for (size_t i = 0; i < ret; ++i) {\n      buff2[i] = ((buff[i] >> 4) >= 10) ? ('A' + (buff[i] >> 4) - 10)\n                                        : ('0' + (buff[i] >> 4));\n      buff2[i + 1] = ((buff[i] & 15) >= 10) ? ('A' + (buff[i] & 15) - 10)\n                                            : ('0' + (buff[i] & 15));\n    }\n    buff2[(ret << 1)] = 0;\n    FIO_LOG_DEBUG(\"OpenSSL Master Key for uuid %p:\\n\\t\\t%s\", (void *)uuid,\n                  buff2);\n  }\n#endif\n  return 1;\n}\n\nstatic ssize_t fio_tls_read4handshake(intptr_t uuid, void *udata, void *buf,\n                                      size_t count) {\n  // FIO_LOG_DEBUG(\"TLS handshake from read %p\", (void *)uuid);\n  if (fio_tls_handshake(uuid, udata))\n    return fio_tls_read(uuid, udata, buf, count);\n  errno = EWOULDBLOCK;\n  return -1;\n}\n\nstatic ssize_t fio_tls_write4handshake(intptr_t uuid, void *udata,\n                                       const void *buf, size_t count) {\n  // FIO_LOG_DEBUG(\"TLS handshake from write %p\", (void *)uuid);\n  if (fio_tls_handshake(uuid, udata))\n    return fio_tls_write(uuid, udata, buf, count);\n  errno = EWOULDBLOCK;\n  return -1;\n}\n\nstatic ssize_t fio_tls_flush4handshake(intptr_t uuid, void *udata) {\n  // FIO_LOG_DEBUG(\"TLS handshake from flush %p\", (void *)uuid);\n  if (fio_tls_handshake(uuid, udata)) {\n    return fio_tls_flush(uuid, udata);\n  }\n  errno = 0;\n  return 1;\n}\nstatic fio_rw_hook_s FIO_TLS_HANDSHAKE_HOOKS = {\n    .read = fio_tls_read4handshake,\n    .write = fio_tls_write4handshake,\n    .before_close = fio_tls_before_close,\n    .flush = fio_tls_flush4handshake,\n    .cleanup = fio_tls_cleanup,\n};\nstatic inline void fio_tls_attach2uuid(intptr_t uuid, fio_tls_s *tls,\n                                       void *udata, uint8_t is_server) {\n  fio_atomic_add(&tls->ref, 1);\n  /* create SSL connection context from global context */\n  fio_tls_connection_s *c = malloc(sizeof(*c));\n  FIO_ASSERT_ALLOC(c);\n  *c = (fio_tls_connection_s){\n      .alpn_arg = udata,\n      .tls = tls,\n      .uuid = uuid,\n      .ssl = SSL_new(tls->ctx),\n      .is_server = is_server,\n      .alpn_ok = 0,\n  };\n  FIO_ASSERT_ALLOC(c->ssl);\n  /* set facil.io data in the SSL object */\n  SSL_set_ex_data(c->ssl, 0, (void *)c);\n  /* attach socket - TODO: Switch to BIO socket */\n  BIO *bio = BIO_new_socket(fio_uuid2fd(uuid), 0);\n  BIO_up_ref(bio);\n  SSL_set0_rbio(c->ssl, bio);\n  SSL_set0_wbio(c->ssl, bio);\n  /* set RW hooks */\n  fio_rw_hook_set(uuid, &FIO_TLS_HANDSHAKE_HOOKS, c);\n  if (is_server) {\n    /* Server mode (accept) */\n    FIO_LOG_DEBUG(\"Attaching TLS read/write hook for %p (server mode).\",\n                  (void *)uuid);\n    SSL_set_accept_state(c->ssl);\n  } else {\n    /* Client mode (connect) */\n    FIO_LOG_DEBUG(\"Attaching TLS read/write hook for %p (client mode).\",\n                  (void *)uuid);\n    SSL_set_connect_state(c->ssl);\n  }\n  fio_force_event(uuid, FIO_EVENT_ON_READY);\n}\n\n/* *****************************************************************************\nSSL/TLS API implementation - this can be pretty much used as is...\n***************************************************************************** */\n\n/**\n * Creates a new SSL/TLS context / settings object with a default certificate\n * (if any).\n */\nfio_tls_s *FIO_TLS_WEAK fio_tls_new(const char *server_name, const char *cert,\n                                    const char *key, const char *pk_password) {\n  REQUIRE_LIBRARY();\n  fio_tls_s *tls = calloc(sizeof(*tls), 1);\n  tls->ref = 1;\n  fio_tls_cert_add(tls, server_name, key, cert, pk_password);\n  return tls;\n}\n\n/**\n * Adds a certificate  a new SSL/TLS context / settings object.\n */\nvoid FIO_TLS_WEAK fio_tls_cert_add(fio_tls_s *tls, const char *server_name,\n                                   const char *cert, const char *key,\n                                   const char *pk_password) {\n  REQUIRE_LIBRARY();\n  cert_s c = {\n      .private_key = FIO_STR_INIT,\n      .public_key = FIO_STR_INIT,\n      .password = FIO_STR_INIT_STATIC2(pk_password,\n                                       (pk_password ? strlen(pk_password) : 0)),\n  };\n  if (key && cert) {\n    if (fio_str_readfile(&c.private_key, key, 0, 0).data == NULL)\n      goto file_missing;\n    if (fio_str_readfile(&c.public_key, cert, 0, 0).data == NULL)\n      goto file_missing;\n    cert_ary_push(&tls->sni, c);\n  } else if (server_name) {\n    /* Self-Signed TLS Certificates */\n    c.private_key = FIO_STR_INIT_STATIC(server_name);\n    cert_ary_push(&tls->sni, c);\n  }\n  fio_tls_cert_destroy(&c);\n  fio_tls_build_context(tls);\n  return;\nfile_missing:\n  FIO_LOG_FATAL(\"TLS certificate file missing for either %s or %s or both.\",\n                key, cert);\n  exit(-1);\n}\n\n/**\n * Adds an ALPN protocol callback to the SSL/TLS context.\n *\n * The first protocol added will act as the default protocol to be selected.\n *\n * The callback should accept the `uuid`, the user data pointer passed to\n * either `fio_tls_accept` or `fio_tls_connect` (here: `udata_connetcion`) and\n * the user data pointer passed to the `fio_tls_alpn_add` function\n * (`udata_tls`).\n *\n * The `on_cleanup` callback will be called when the TLS object is destroyed\n * (or `fio_tls_alpn_add` is called again with the same protocol name). The\n * `udata_tls` argumrnt will be passed along, as is, to the callback (if set).\n *\n * Except for the `tls` and `protocol_name` arguments, all arguments can be\n * NULL.\n */\nvoid FIO_TLS_WEAK fio_tls_alpn_add(\n    fio_tls_s *tls, const char *protocol_name,\n    void (*on_selected)(intptr_t uuid, void *udata_connection, void *udata_tls),\n    void *udata_tls, void (*on_cleanup)(void *udata_tls)) {\n  REQUIRE_LIBRARY();\n  alpn_add(tls, protocol_name, on_selected, udata_tls, on_cleanup);\n  fio_tls_build_context(tls);\n}\n\n/**\n * Returns the number of registered ALPN protocol names.\n *\n * This could be used when deciding if protocol selection should be delegated\n * to the ALPN mechanism, or whether a protocol should be immediately\n * assigned.\n *\n * If no ALPN protocols are registered, zero (0) is returned.\n */\nuintptr_t FIO_TLS_WEAK fio_tls_alpn_count(fio_tls_s *tls) {\n  return tls ? alpn_list_count(&tls->alpn) : 0;\n}\n\n/**\n * Adds a certificate to the \"trust\" list, which automatically adds a peer\n * verification requirement.\n *\n *      fio_tls_trust(tls, \"google-ca.pem\" );\n */\nvoid FIO_TLS_WEAK fio_tls_trust(fio_tls_s *tls, const char *public_cert_file) {\n  REQUIRE_LIBRARY();\n  trust_s c = {\n      .pem = FIO_STR_INIT,\n  };\n  if (!public_cert_file)\n    return;\n  if (fio_str_readfile(&c.pem, public_cert_file, 0, 0).data == NULL)\n    goto file_missing;\n  trust_ary_push(&tls->trust, c);\n  fio_tls_trust_destroy(&c);\n  fio_tls_build_context(tls);\n  return;\nfile_missing:\n  FIO_LOG_FATAL(\"TLS certificate file missing for %s \", public_cert_file);\n  exit(-1);\n}\n\n/**\n * Establishes an SSL/TLS connection as an SSL/TLS Server, using the specified\n * context / settings object.\n *\n * The `uuid` should be a socket UUID that is already connected to a peer\n * (i.e., the result of `fio_accept`).\n *\n * The `udata` is an opaque user data pointer that is passed along to the\n * protocol selected (if any protocols were added using `fio_tls_alpn_add`).\n */\nvoid FIO_TLS_WEAK fio_tls_accept(intptr_t uuid, fio_tls_s *tls, void *udata) {\n  REQUIRE_LIBRARY();\n  fio_tls_attach2uuid(uuid, tls, udata, 1);\n}\n\n/**\n * Establishes an SSL/TLS connection as an SSL/TLS Client, using the specified\n * context / settings object.\n *\n * The `uuid` should be a socket UUID that is already connected to a peer\n * (i.e., one received by a `fio_connect` specified callback `on_connect`).\n *\n * The `udata` is an opaque user data pointer that is passed along to the\n * protocol selected (if any protocols were added using `fio_tls_alpn_add`).\n */\nvoid FIO_TLS_WEAK fio_tls_connect(intptr_t uuid, fio_tls_s *tls, void *udata) {\n  REQUIRE_LIBRARY();\n  fio_tls_attach2uuid(uuid, tls, udata, 0);\n}\n\n/**\n * Increase the reference count for the TLS object.\n *\n * Decrease with `fio_tls_destroy`.\n */\nvoid FIO_TLS_WEAK fio_tls_dup(fio_tls_s *tls) { fio_atomic_add(&tls->ref, 1); }\n\n/**\n * Destroys the SSL/TLS context / settings object and frees any related\n * resources / memory.\n */\nvoid FIO_TLS_WEAK fio_tls_destroy(fio_tls_s *tls) {\n  if (!tls)\n    return;\n  REQUIRE_LIBRARY();\n  if (fio_atomic_sub(&tls->ref, 1))\n    return;\n  fio_tls_destroy_context(tls);\n  alpn_list_free(&tls->alpn);\n  cert_ary_free(&tls->sni);\n  free(tls);\n}\n\n#endif /* Library compiler flags */\n", "#ifndef H_FIOBJ4SOCK_H\n#define H_FIOBJ4SOCK_H\n/**\n * Defines a helper for using fiobj with the sock library.\n */\n\n#include <fio.h>\n#include <fiobj.h>\n\nstatic void fiobj4sock_dealloc(void *o) { fiobj_free((FIOBJ)o); }\n\n/** send a FIOBJ  object through a socket. */\nstatic inline __attribute__((unused)) ssize_t fiobj_send_free(intptr_t uuid,\n                                                              FIOBJ o) {\n  fio_str_info_s s = fiobj_obj2cstr(o);\n  return fio_write2(uuid, .data.buffer = (void *)(o),\n                    .offset = (((intptr_t)s.data) - ((intptr_t)(o))),\n                    .length = s.len, .after.dealloc = fiobj4sock_dealloc);\n}\n\n#endif\n", "#ifndef H_FIOBJ_NUMBERS_H\n#define H_FIOBJ_NUMBERS_H\n/*\nCopyright: Boaz Segev, 2017-2019\nLicense: MIT\n*/\n\n#include <fiobject.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* *****************************************************************************\nNumbers API (Integers)\n***************************************************************************** */\n\n/** Creates a Number object. Remember to use `fiobj_free`. */\nFIO_INLINE FIOBJ fiobj_num_new(intptr_t num);\n\n/** Creates a temporary Number object. Avoid using `fiobj_free`. */\nFIOBJ fiobj_num_tmp(intptr_t num);\n\n/* *****************************************************************************\nFloat API (Double)\n***************************************************************************** */\n\n/** Creates a Float object. Remember to use `fiobj_free`.  */\nFIOBJ fiobj_float_new(double num);\n\n/** Mutates a Float object's value. Effects every object's reference!  */\nvoid fiobj_float_set(FIOBJ obj, double num);\n\n/** Creates a temporary Float object. Avoid using `fiobj_free`. */\nFIOBJ fiobj_float_tmp(double num);\n\n/* *****************************************************************************\nNumerical Helpers: not FIOBJ specific, but included as part of the library\n***************************************************************************** */\n\n/**\n * A helper function that converts between String data to a signed int64_t.\n *\n * Numbers are assumed to be in base 10.\n *\n * The `0x##` (or `x##`) and `0b##` (or `b##`) are recognized as base 16 and\n * base 2 (binary MSB first) respectively.\n *\n * The pointer will be updated to point to the first byte after the number.\n */\nint64_t fio_atol(char **pstr);\n\n/** A helper function that converts between String data to a signed double. */\ndouble fio_atof(char **pstr);\n\n/**\n * A helper function that converts between a signed int64_t to a string.\n *\n * No overflow guard is provided, make sure there's at least 66 bytes available\n * (for base 2).\n *\n * Supports base 2, base 10 and base 16. An unsupported base will silently\n * default to base 10. Prefixes aren't added (i.e., no \"0x\" or \"0b\" at the\n * beginning of the string).\n *\n * Returns the number of bytes actually written (excluding the NUL terminator).\n */\nsize_t fio_ltoa(char *dest, int64_t num, uint8_t base);\n\n/**\n * A helper function that converts between a double to a string.\n *\n * No overflow guard is provided, make sure there's at least 130 bytes available\n * (for base 2).\n *\n * Supports base 2, base 10 and base 16. An unsupported base will silently\n * default to base 10. Prefixes aren't added (i.e., no \"0x\" or \"0b\" at the\n * beginning of the string).\n *\n * Returns the number of bytes actually written (excluding the NUL terminator).\n */\nsize_t fio_ftoa(char *dest, double num, uint8_t base);\n\n/** Converts a number to a temporary, thread safe, C string object */\nfio_str_info_s fio_ltocstr(long);\n\n/** Converts a float to a temporary, thread safe, C string object */\nfio_str_info_s fio_ftocstr(double);\n\n/* *****************************************************************************\nPointer Wrapping Helper MACROs (uses integers)\n***************************************************************************** */\n\n#define fiobj_ptr_wrap(ptr) fiobj_num_new((uintptr_t)(ptr))\n#define fiobj_ptr_unwrap(obj) ((void *)fiobj_obj2num((obj)))\n\n/* *****************************************************************************\nInline Number Initialization\n***************************************************************************** */\n\nFIOBJ fiobj_num_new_bignum(intptr_t num);\n\n/** Creates a Number object. Remember to use `fiobj_free`. */\nFIO_INLINE FIOBJ fiobj_num_new(intptr_t num) {\n  if ((((uintptr_t)num &\n        (FIOBJ_NUMBER_SIGN_BIT | FIOBJ_NUMBER_SIGN_EXCLUDE_BIT)) == 0) ||\n      (((uintptr_t)num &\n        (FIOBJ_NUMBER_SIGN_BIT | FIOBJ_NUMBER_SIGN_EXCLUDE_BIT)) ==\n       (FIOBJ_NUMBER_SIGN_BIT | FIOBJ_NUMBER_SIGN_EXCLUDE_BIT))) {\n    const uintptr_t num_abs = (uintptr_t)num & FIOBJ_NUMBER_SIGN_MASK;\n    const uintptr_t num_sign = (uintptr_t)num & FIOBJ_NUMBER_SIGN_BIT;\n    return ((num_abs << 1) | num_sign | FIOBJECT_NUMBER_FLAG);\n  }\n  return fiobj_num_new_bignum(num);\n}\n\n#if DEBUG\nvoid fiobj_test_numbers(void);\n#endif\n\n#ifdef __cplusplus\n} /* extern \"C\" */\n#endif\n\n#endif\n", "/*\nCopyright: Boaz Segev, 2016-2019\nLicense: MIT\n\nFeel free to copy, use and enjoy according to the license provided.\n*/\n\n#include <fio.h>\n\n#include <http1.h>\n#include <http_internal.h>\n\n#include <ctype.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#ifndef HAVE_TM_TM_ZONE\n#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) ||     \\\n    defined(__DragonFly__) || defined(__bsdi__) || defined(__ultrix) ||        \\\n    (defined(__APPLE__) && defined(__MACH__)) ||                               \\\n    (defined(__sun) && !defined(__SVR4))\n/* Known BSD systems */\n#define HAVE_TM_TM_ZONE 1\n#elif defined(__GLIBC__) && defined(_BSD_SOURCE)\n/* GNU systems with _BSD_SOURCE */\n#define HAVE_TM_TM_ZONE 1\n#else\n#define HAVE_TM_TM_ZONE 0\n#endif\n#endif\n\n/* *****************************************************************************\nSSL/TLS patch\n***************************************************************************** */\n\n/**\n * Adds an ALPN protocol callback to the SSL/TLS context.\n *\n * The first protocol added will act as the default protocol to be selected.\n */\nvoid __attribute__((weak))\nfio_tls_alpn_add(void *tls, const char *protocol_name,\n                 void (*callback)(intptr_t uuid, void *udata_connection,\n                                  void *udata_tls),\n                 void *udata_tls, void (*on_cleanup)(void *udata_tls)) {\n  FIO_LOG_FATAL(\"HTTP SSL/TLS required but unavailable!\");\n  exit(-1);\n  (void)tls;\n  (void)protocol_name;\n  (void)callback;\n  (void)on_cleanup;\n  (void)udata_tls;\n}\n#pragma weak fio_tls_alpn_add\n\n/* *****************************************************************************\nSmall Helpers\n***************************************************************************** */\nstatic inline int hex2byte(uint8_t *dest, const uint8_t *source);\n\nstatic inline void add_content_length(http_s *r, uintptr_t length) {\n  static uint64_t cl_hash = 0;\n  if (!cl_hash)\n    cl_hash = fiobj_hash_string(\"content-length\", 14);\n  if (!fiobj_hash_get2(r->private_data.out_headers, cl_hash)) {\n    fiobj_hash_set(r->private_data.out_headers, HTTP_HEADER_CONTENT_LENGTH,\n                   fiobj_num_new(length));\n  }\n}\nstatic inline void add_content_type(http_s *r) {\n  static uint64_t ct_hash = 0;\n  if (!ct_hash)\n    ct_hash = fiobj_hash_string(\"content-type\", 12);\n  if (!fiobj_hash_get2(r->private_data.out_headers, ct_hash)) {\n    fiobj_hash_set(r->private_data.out_headers, HTTP_HEADER_CONTENT_TYPE,\n                   http_mimetype_find2(r->path));\n  }\n}\n\nstatic FIOBJ current_date;\nstatic time_t last_date_added;\nstatic fio_lock_i date_lock;\nstatic inline void add_date(http_s *r) {\n  static uint64_t date_hash = 0;\n  if (!date_hash)\n    date_hash = fiobj_hash_string(\"date\", 4);\n  static uint64_t mod_hash = 0;\n  if (!mod_hash)\n    mod_hash = fiobj_hash_string(\"last-modified\", 13);\n\n  if (fio_last_tick().tv_sec > last_date_added) {\n    fio_lock(&date_lock);\n    if (fio_last_tick().tv_sec > last_date_added) { /* retest inside lock */\n      FIOBJ tmp = fiobj_str_buf(32);\n      FIOBJ old = current_date;\n      fiobj_str_resize(\n          tmp, http_time2str(fiobj_obj2cstr(tmp).data, fio_last_tick().tv_sec));\n      last_date_added = fio_last_tick().tv_sec;\n      current_date = tmp;\n      fiobj_free(old);\n    }\n    fio_unlock(&date_lock);\n  }\n\n  if (!fiobj_hash_get2(r->private_data.out_headers, date_hash)) {\n    fiobj_hash_set(r->private_data.out_headers, HTTP_HEADER_DATE,\n                   fiobj_dup(current_date));\n  }\n  if (r->status_str == FIOBJ_INVALID &&\n      !fiobj_hash_get2(r->private_data.out_headers, mod_hash)) {\n    fiobj_hash_set(r->private_data.out_headers, HTTP_HEADER_LAST_MODIFIED,\n                   fiobj_dup(current_date));\n  }\n}\n\nstruct header_writer_s {\n  FIOBJ dest;\n  FIOBJ name;\n  FIOBJ value;\n};\n\nstatic int write_header(FIOBJ o, void *w_) {\n  struct header_writer_s *w = w_;\n  if (!o)\n    return 0;\n  if (fiobj_hash_key_in_loop()) {\n    w->name = fiobj_hash_key_in_loop();\n  }\n  if (FIOBJ_TYPE_IS(o, FIOBJ_T_ARRAY)) {\n    fiobj_each1(o, 0, write_header, w);\n    return 0;\n  }\n  fio_str_info_s name = fiobj_obj2cstr(w->name);\n  fio_str_info_s str = fiobj_obj2cstr(o);\n  if (!str.data)\n    return 0;\n  fiobj_str_write(w->dest, name.data, name.len);\n  fiobj_str_write(w->dest, \":\", 1);\n  fiobj_str_write(w->dest, str.data, str.len);\n  fiobj_str_write(w->dest, \"\\r\\n\", 2);\n  return 0;\n}\n\nstatic char invalid_cookie_name_char[256];\n\nstatic char invalid_cookie_value_char[256];\n/* *****************************************************************************\nThe Request / Response type and functions\n***************************************************************************** */\nstatic const char hex_chars[] = {'0', '1', '2', '3', '4', '5', '6', '7',\n                                 '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n\n/**\n * Sets a response header, taking ownership of the value object, but NOT the\n * name object (so name objects could be reused in future responses).\n *\n * Returns -1 on error and 0 on success.\n */\nint http_set_header(http_s *r, FIOBJ name, FIOBJ value) {\n  if (HTTP_INVALID_HANDLE(r) || !name) {\n    fiobj_free(value);\n    return -1;\n  }\n  set_header_add(r->private_data.out_headers, name, value);\n  return 0;\n}\n/**\n * Sets a response header.\n *\n * Returns -1 on error and 0 on success.\n */\nint http_set_header2(http_s *r, fio_str_info_s n, fio_str_info_s v) {\n  if (HTTP_INVALID_HANDLE(r) || !n.data || !n.len || (v.data && !v.len))\n    return -1;\n  FIOBJ tmp = fiobj_str_new(n.data, n.len);\n  int ret = http_set_header(r, tmp, fiobj_str_new(v.data, v.len));\n  fiobj_free(tmp);\n  return ret;\n}\n\n/**\n * Sets a response cookie, taking ownership of the value object, but NOT the\n * name object (so name objects could be reused in future responses).\n *\n * Returns -1 on error and 0 on success.\n */\n#undef http_set_cookie\nint http_set_cookie(http_s *h, http_cookie_args_s cookie) {\n#if DEBUG\n  FIO_ASSERT(h, \"Can't set cookie for NULL HTTP handler!\");\n#endif\n  if (HTTP_INVALID_HANDLE(h) || cookie.name_len >= 32768 ||\n      cookie.value_len >= 131072) {\n    return -1;\n  }\n\n  static int warn_illegal = 0;\n\n  /* write name and value while auto-correcting encoding issues */\n  size_t capa = cookie.name_len + cookie.value_len + 128;\n  size_t len = 0;\n  FIOBJ c = fiobj_str_buf(capa);\n  fio_str_info_s t = fiobj_obj2cstr(c);\n\n#define copy_cookie_ch(ch_var)                                                 \\\n  if (invalid_cookie_##ch_var##_char[(uint8_t)cookie.ch_var[tmp]]) {           \\\n    if (!warn_illegal) {                                                       \\\n      ++warn_illegal;                                                          \\\n      FIO_LOG_WARNING(\"illegal char 0x%.2x in cookie \" #ch_var \" (in %s)\\n\"    \\\n                      \"         automatic %% encoding applied\",                \\\n                      cookie.ch_var[tmp], cookie.ch_var);                      \\\n    }                                                                          \\\n    t.data[len++] = '%';                                                       \\\n    t.data[len++] = hex_chars[((uint8_t)cookie.ch_var[tmp] >> 4) & 0x0F];      \\\n    t.data[len++] = hex_chars[(uint8_t)cookie.ch_var[tmp] & 0x0F];             \\\n  } else {                                                                     \\\n    t.data[len++] = cookie.ch_var[tmp];                                        \\\n  }                                                                            \\\n  tmp += 1;                                                                    \\\n  if (capa <= len + 3) {                                                       \\\n    capa += 32;                                                                \\\n    fiobj_str_capa_assert(c, capa);                                            \\\n    t = fiobj_obj2cstr(c);                                                     \\\n  }\n\n  if (cookie.name) {\n    size_t tmp = 0;\n    if (cookie.name_len) {\n      while (tmp < cookie.name_len) {\n        copy_cookie_ch(name);\n      }\n    } else {\n      while (cookie.name[tmp]) {\n        copy_cookie_ch(name);\n      }\n    }\n  }\n  t.data[len++] = '=';\n  if (cookie.value) {\n    size_t tmp = 0;\n    if (cookie.value_len) {\n      while (tmp < cookie.value_len) {\n        copy_cookie_ch(value);\n      }\n    } else {\n      while (cookie.value[tmp]) {\n        copy_cookie_ch(value);\n      }\n    }\n  } else\n    cookie.max_age = -1;\n\n  if (http_settings(h) && http_settings(h)->is_client) {\n    if (!cookie.value) {\n      fiobj_free(c);\n      return -1;\n    }\n    set_header_add(h->private_data.out_headers, HTTP_HEADER_COOKIE, c);\n    return 0;\n  }\n\n  t.data[len++] = ';';\n  t.data[len++] = ' ';\n\n  if (h->status_str || !h->status) { /* on first request status == 0 */\n    static uint64_t cookie_hash;\n    if (!cookie_hash)\n      cookie_hash = fiobj_hash_string(\"cookie\", 6);\n    FIOBJ tmp = fiobj_hash_get2(h->private_data.out_headers, cookie_hash);\n    if (!tmp) {\n      set_header_add(h->private_data.out_headers, HTTP_HEADER_COOKIE, c);\n    } else {\n      fiobj_str_join(tmp, c);\n      fiobj_free(c);\n    }\n    return 0;\n  }\n\n  if (capa <= len + 40) {\n    capa = len + 40;\n    fiobj_str_capa_assert(c, capa);\n    t = fiobj_obj2cstr(c);\n  }\n  if (cookie.max_age) {\n    memcpy(t.data + len, \"Max-Age=\", 8);\n    len += 8;\n    len += fio_ltoa(t.data + len, cookie.max_age, 10);\n    t.data[len++] = ';';\n    t.data[len++] = ' ';\n  }\n  fiobj_str_resize(c, len);\n\n  if (cookie.domain && cookie.domain_len) {\n    fiobj_str_write(c, \"domain=\", 7);\n    fiobj_str_write(c, cookie.domain, cookie.domain_len);\n    fiobj_str_write(c, \";\", 1);\n    t.data[len++] = ' ';\n  }\n  if (cookie.path && cookie.path_len) {\n    fiobj_str_write(c, \"path=\", 5);\n    fiobj_str_write(c, cookie.path, cookie.path_len);\n    fiobj_str_write(c, \";\", 1);\n    t.data[len++] = ' ';\n  }\n  if (cookie.http_only) {\n    fiobj_str_write(c, \"HttpOnly;\", 9);\n  }\n  if (cookie.secure) {\n    fiobj_str_write(c, \"secure;\", 7);\n  }\n  set_header_add(h->private_data.out_headers, HTTP_HEADER_SET_COOKIE, c);\n  return 0;\n}\n#define http_set_cookie(http__req__, ...)                                      \\\n  http_set_cookie((http__req__), (http_cookie_args_s){__VA_ARGS__})\n\n/**\n * Sends the response headers and body.\n *\n * Returns -1 on error and 0 on success.\n *\n * AFTER THIS FUNCTION IS CALLED, THE `http_s` OBJECT IS NO LONGER VALID.\n */\nint http_send_body(http_s *r, void *data, uintptr_t length) {\n  if (HTTP_INVALID_HANDLE(r))\n    return -1;\n  if (!length || !data) {\n    http_finish(r);\n    return 0;\n  }\n  add_content_length(r, length);\n  // add_content_type(r);\n  add_date(r);\n  return ((http_vtable_s *)r->private_data.vtbl)\n      ->http_send_body(r, data, length);\n}\n/**\n * Sends the response headers and the specified file (the response's body).\n *\n * Returns -1 on error and 0 on success.\n *\n * AFTER THIS FUNCTION IS CALLED, THE `http_s` OBJECT IS NO LONGER VALID.\n */\nint http_sendfile(http_s *r, int fd, uintptr_t length, uintptr_t offset) {\n  if (HTTP_INVALID_HANDLE(r)) {\n    close(fd);\n    return -1;\n  };\n  add_content_length(r, length);\n  add_content_type(r);\n  add_date(r);\n  return ((http_vtable_s *)r->private_data.vtbl)\n      ->http_sendfile(r, fd, length, offset);\n}\n/**\n * Sends the response headers and the specified file (the response's body).\n *\n * Returns -1 eton error and 0 on success.\n *\n * AFTER THIS FUNCTION IS CALLED, THE `http_s` OBJECT IS NO LONGER VALID.\n */\nint http_sendfile2(http_s *h, const char *prefix, size_t prefix_len,\n                   const char *encoded, size_t encoded_len) {\n  if (HTTP_INVALID_HANDLE(h))\n    return -1;\n  struct stat file_data = {.st_size = 0};\n  static uint64_t accept_enc_hash = 0;\n  if (!accept_enc_hash)\n    accept_enc_hash = fiobj_hash_string(\"accept-encoding\", 15);\n  static uint64_t range_hash = 0;\n  if (!range_hash)\n    range_hash = fiobj_hash_string(\"range\", 5);\n\n  /* create filename string */\n  FIOBJ filename = fiobj_str_tmp();\n  if (prefix && prefix_len) {\n    /* start with prefix path */\n    if (encoded && prefix[prefix_len - 1] == '/' && encoded[0] == '/')\n      --prefix_len;\n    fiobj_str_capa_assert(filename, prefix_len + encoded_len + 4);\n    fiobj_str_write(filename, prefix, prefix_len);\n  }\n  {\n    /* decode filename in cases where it's URL encoded */\n    fio_str_info_s tmp = fiobj_obj2cstr(filename);\n    if (encoded) {\n      char *pos = (char *)encoded;\n      const char *end = encoded + encoded_len;\n      while (pos < end) {\n        /* test for path manipulations while decoding */\n        if (*pos == '/' && (pos[1] == '/' ||\n                            (((uintptr_t)end - (uintptr_t)pos >= 4) &&\n                             pos[1] == '.' && pos[2] == '.' && pos[3] == '/')))\n          return -1;\n        if (*pos == '%') {\n          // decode hex value\n          // this is a percent encoded value.\n          if (hex2byte((uint8_t *)tmp.data + tmp.len, (uint8_t *)pos + 1))\n            return -1;\n          tmp.len++;\n          pos += 3;\n        } else\n          tmp.data[tmp.len++] = *(pos++);\n      }\n      tmp.data[tmp.len] = 0;\n      fiobj_str_resize(filename, tmp.len);\n    }\n    if (tmp.data[tmp.len - 1] == '/')\n      fiobj_str_write(filename, \"index.html\", 10);\n  }\n  /* test for file existance  */\n\n  int file = -1;\n  uint8_t is_gz = 0;\n\n  fio_str_info_s s = fiobj_obj2cstr(filename);\n  {\n    FIOBJ tmp = fiobj_hash_get2(h->headers, accept_enc_hash);\n    if (!tmp)\n      goto no_gzip_support;\n    fio_str_info_s ac_str = fiobj_obj2cstr(tmp);\n    if (!ac_str.data || !strstr(ac_str.data, \"gzip\"))\n      goto no_gzip_support;\n    if (s.data[s.len - 3] != '.' || s.data[s.len - 2] != 'g' ||\n        s.data[s.len - 1] != 'z') {\n      fiobj_str_write(filename, \".gz\", 3);\n      s = fiobj_obj2cstr(filename);\n      if (!stat(s.data, &file_data) &&\n          (S_ISREG(file_data.st_mode) || S_ISLNK(file_data.st_mode))) {\n        is_gz = 1;\n        goto found_file;\n      }\n      fiobj_str_resize(filename, s.len - 3);\n    }\n  }\nno_gzip_support:\n  if (stat(s.data, &file_data) ||\n      !(S_ISREG(file_data.st_mode) || S_ISLNK(file_data.st_mode)))\n    return -1;\nfound_file:\n  /* set last-modified */\n  {\n    FIOBJ tmp = fiobj_str_buf(32);\n    fiobj_str_resize(\n        tmp, http_time2str(fiobj_obj2cstr(tmp).data, file_data.st_mtime));\n    http_set_header(h, HTTP_HEADER_LAST_MODIFIED, tmp);\n  }\n  /* set cache-control */\n  http_set_header(h, HTTP_HEADER_CACHE_CONTROL, fiobj_dup(HTTP_HVALUE_MAX_AGE));\n  /* set & test etag */\n  uint64_t etag = (uint64_t)file_data.st_size;\n  etag ^= (uint64_t)file_data.st_mtime;\n  etag = fiobj_hash_string(&etag, sizeof(uint64_t));\n  FIOBJ etag_str = fiobj_str_buf(32);\n  fiobj_str_resize(etag_str,\n                   fio_base64_encode(fiobj_obj2cstr(etag_str).data,\n                                     (void *)&etag, sizeof(uint64_t)));\n  /* set */\n  http_set_header(h, HTTP_HEADER_ETAG, etag_str);\n  /* test */\n  {\n    static uint64_t none_match_hash = 0;\n    if (!none_match_hash)\n      none_match_hash = fiobj_hash_string(\"if-none-match\", 13);\n    FIOBJ tmp2 = fiobj_hash_get2(h->headers, none_match_hash);\n    if (tmp2 && fiobj_iseq(tmp2, etag_str)) {\n      h->status = 304;\n      http_finish(h);\n      return 0;\n    }\n  }\n  /* handle range requests */\n  int64_t offset = 0;\n  int64_t length = file_data.st_size;\n  {\n    static uint64_t ifrange_hash = 0;\n    if (!ifrange_hash)\n      ifrange_hash = fiobj_hash_string(\"if-range\", 8);\n    FIOBJ tmp = fiobj_hash_get2(h->headers, ifrange_hash);\n    if (tmp && fiobj_iseq(tmp, etag_str)) {\n      fiobj_hash_delete2(h->headers, range_hash);\n    } else {\n      tmp = fiobj_hash_get2(h->headers, range_hash);\n      if (tmp) {\n        /* range ahead... */\n        if (FIOBJ_TYPE_IS(tmp, FIOBJ_T_ARRAY))\n          tmp = fiobj_ary_index(tmp, 0);\n        fio_str_info_s range = fiobj_obj2cstr(tmp);\n        if (!range.data || memcmp(\"bytes=\", range.data, 6))\n          goto open_file;\n        char *pos = range.data + 6;\n        int64_t start_at = 0, end_at = 0;\n        start_at = fio_atol(&pos);\n        if (start_at >= file_data.st_size)\n          goto open_file;\n        if (start_at >= 0) {\n          pos++;\n          end_at = fio_atol(&pos);\n          if (end_at <= 0)\n            goto open_file;\n        }\n        /* we ignore multimple ranges, only responding with the first range. */\n        if (start_at < 0) {\n          if (0 - start_at < file_data.st_size) {\n            offset = file_data.st_size - start_at;\n            length = 0 - start_at;\n          }\n        } else if (end_at) {\n          offset = start_at;\n          length = end_at - start_at + 1;\n          if (length + start_at > file_data.st_size || length <= 0)\n            length = length - start_at;\n        } else {\n          offset = start_at;\n          length = length - start_at;\n        }\n        h->status = 206;\n\n        {\n          FIOBJ cranges = fiobj_str_buf(1);\n          fiobj_str_printf(cranges, \"bytes %lu-%lu/%lu\",\n                           (unsigned long)start_at,\n                           (unsigned long)(start_at + length - 1),\n                           (unsigned long)file_data.st_size);\n          http_set_header(h, HTTP_HEADER_CONTENT_RANGE, cranges);\n        }\n        http_set_header(h, HTTP_HEADER_ACCEPT_RANGES,\n                        fiobj_dup(HTTP_HVALUE_BYTES));\n      }\n    }\n  }\n  /* test for an OPTIONS request or invalid methods */\n  s = fiobj_obj2cstr(h->method);\n  switch (s.len) {\n  case 7:\n    if (!strncasecmp(\"options\", s.data, 7)) {\n      http_set_header2(h, (fio_str_info_s){.data = (char *)\"allow\", .len = 5},\n                       (fio_str_info_s){.data = (char *)\"GET, HEAD\", .len = 9});\n      h->status = 200;\n      http_finish(h);\n      return 0;\n    }\n    break;\n  case 3:\n    if (!strncasecmp(\"get\", s.data, 3))\n      goto open_file;\n    break;\n  case 4:\n    if (!strncasecmp(\"head\", s.data, 4)) {\n      http_set_header(h, HTTP_HEADER_CONTENT_LENGTH, fiobj_num_new(length));\n      http_finish(h);\n      return 0;\n    }\n    break;\n  }\n  http_send_error(h, 403);\n  return 0;\nopen_file:\n  s = fiobj_obj2cstr(filename);\n  file = open(s.data, O_RDONLY);\n  if (file == -1) {\n    FIO_LOG_ERROR(\"(HTTP) couldn't open file %s!\\n\", s.data);\n    perror(\"     \");\n    http_send_error(h, 500);\n    return 0;\n  }\n  {\n    FIOBJ tmp = 0;\n    uintptr_t pos = 0;\n    if (is_gz) {\n      http_set_header(h, HTTP_HEADER_CONTENT_ENCODING,\n                      fiobj_dup(HTTP_HVALUE_GZIP));\n\n      pos = s.len - 4;\n      while (pos && s.data[pos] != '.')\n        pos--;\n      pos++; /* assuming, but that's fine. */\n      tmp = http_mimetype_find(s.data + pos, s.len - pos - 3);\n\n    } else {\n      pos = s.len - 1;\n      while (pos && s.data[pos] != '.')\n        pos--;\n      pos++; /* assuming, but that's fine. */\n      tmp = http_mimetype_find(s.data + pos, s.len - pos);\n    }\n    if (tmp)\n      http_set_header(h, HTTP_HEADER_CONTENT_TYPE, tmp);\n  }\n  http_sendfile(h, file, length, offset);\n  return 0;\n}\n\n/**\n * Sends an HTTP error response.\n *\n * Returns -1 on error and 0 on success.\n *\n * AFTER THIS FUNCTION IS CALLED, THE `http_s` OBJECT IS NO LONGER VALID.\n *\n * The `uuid` argument is optional and will be used only if the `http_s`\n * argument is set to NULL.\n */\nint http_send_error(http_s *r, size_t error) {\n  if (!r || !r->private_data.out_headers) {\n    return -1;\n  }\n  if (error < 100 || error >= 1000)\n    error = 500;\n  r->status = error;\n  char buffer[16];\n  buffer[0] = '/';\n  size_t pos = 1 + fio_ltoa(buffer + 1, error, 10);\n  buffer[pos++] = '.';\n  buffer[pos++] = 'h';\n  buffer[pos++] = 't';\n  buffer[pos++] = 'm';\n  buffer[pos++] = 'l';\n  buffer[pos] = 0;\n  if (http_sendfile2(r, http2protocol(r)->settings->public_folder,\n                     http2protocol(r)->settings->public_folder_length, buffer,\n                     pos)) {\n    http_set_header(r, HTTP_HEADER_CONTENT_TYPE,\n                    http_mimetype_find((char *)\"txt\", 3));\n    fio_str_info_s t = http_status2str(error);\n    http_send_body(r, t.data, t.len);\n  }\n  return 0;\n}\n\n/**\n * Sends the response headers for a header only response.\n *\n * AFTER THIS FUNCTION IS CALLED, THE `http_s` OBJECT IS NO LONGER VALID.\n */\nvoid http_finish(http_s *r) {\n  if (!r || !r->private_data.vtbl) {\n    return;\n  }\n  add_content_length(r, 0);\n  add_date(r);\n  ((http_vtable_s *)r->private_data.vtbl)->http_finish(r);\n}\n/**\n * Pushes a data response when supported (HTTP/2 only).\n *\n * Returns -1 on error and 0 on success.\n */\nint http_push_data(http_s *r, void *data, uintptr_t length, FIOBJ mime_type) {\n  if (!r || !(http_fio_protocol_s *)r->private_data.flag)\n    return -1;\n  return ((http_vtable_s *)r->private_data.vtbl)\n      ->http_push_data(r, data, length, mime_type);\n}\n/**\n * Pushes a file response when supported (HTTP/2 only).\n *\n * If `mime_type` is NULL, an attempt at automatic detection using\n * `filename` will be made.\n *\n * Returns -1 on error and 0 on success.\n */\nint http_push_file(http_s *h, FIOBJ filename, FIOBJ mime_type) {\n  if (HTTP_INVALID_HANDLE(h))\n    return -1;\n  return ((http_vtable_s *)h->private_data.vtbl)\n      ->http_push_file(h, filename, mime_type);\n}\n\n/**\n * Upgrades an HTTP/1.1 connection to a Websocket connection.\n */\n#undef http_upgrade2ws\nint http_upgrade2ws(http_s *h, websocket_settings_s args) {\n  if (!h) {\n    FIO_LOG_ERROR(\"`http_upgrade2ws` requires a valid `http_s` handle.\");\n    goto error;\n  }\n  if (HTTP_INVALID_HANDLE(h))\n    goto error;\n  return ((http_vtable_s *)h->private_data.vtbl)->http2websocket(h, &args);\nerror:\n  if (args.on_close)\n    args.on_close(-1, args.udata);\n  return -1;\n}\n\n/* *****************************************************************************\nPause / Resume\n***************************************************************************** */\nstruct http_pause_handle_s {\n  uintptr_t uuid;\n  http_s *h;\n  void *udata;\n  void (*task)(http_s *);\n  void (*fallback)(void *);\n};\n\n/** Returns the `udata` associated with the paused opaque handle */\nvoid *http_paused_udata_get(http_pause_handle_s *http) { return http->udata; }\n\n/**\n * Sets the `udata` associated with the paused opaque handle, returning the\n * old value.\n */\nvoid *http_paused_udata_set(http_pause_handle_s *http, void *udata) {\n  void *old = http->udata;\n  http->udata = udata;\n  return old;\n}\n\n/* perform the pause task outside of the connection's lock */\nstatic void http_pause_wrapper(void *h_, void *task_) {\n  void (*task)(void *h) = (void (*)(void *h))((uintptr_t)task_);\n  task(h_);\n}\n\n/* perform the resume task within of the connection's lock */\nstatic void http_resume_wrapper(intptr_t uuid, fio_protocol_s *p_, void *arg) {\n  http_fio_protocol_s *p = (http_fio_protocol_s *)p_;\n  http_pause_handle_s *http = arg;\n  http_s *h = http->h;\n  h->udata = http->udata;\n  http_vtable_s *vtbl = (http_vtable_s *)h->private_data.vtbl;\n  if (http->task)\n    http->task(h);\n  vtbl->http_on_resume(h, p);\n  fio_free(http);\n  (void)uuid;\n}\n\n/* perform the resume task fallback */\nstatic void http_resume_fallback_wrapper(intptr_t uuid, void *arg) {\n  http_pause_handle_s *http = arg;\n  if (http->fallback)\n    http->fallback(http->udata);\n  fio_free(http);\n  (void)uuid;\n}\n\n/**\n * Defers the request / response handling for later.\n */\nvoid http_pause(http_s *h, void (*task)(http_pause_handle_s *http)) {\n  if (HTTP_INVALID_HANDLE(h)) {\n    return;\n  }\n  http_fio_protocol_s *p = (http_fio_protocol_s *)h->private_data.flag;\n  http_vtable_s *vtbl = (http_vtable_s *)h->private_data.vtbl;\n  http_pause_handle_s *http = fio_malloc(sizeof(*http));\n  *http = (http_pause_handle_s){\n      .uuid = p->uuid,\n      .h = h,\n      .udata = h->udata,\n  };\n  vtbl->http_on_pause(h, p);\n  fio_defer(http_pause_wrapper, http, (void *)((uintptr_t)task));\n}\n\n/**\n * Defers the request / response handling for later.\n */\nvoid http_resume(http_pause_handle_s *http, void (*task)(http_s *h),\n                 void (*fallback)(void *udata)) {\n  if (!http)\n    return;\n  http->task = task;\n  http->fallback = fallback;\n  fio_defer_io_task(http->uuid, .udata = http, .type = FIO_PR_LOCK_TASK,\n                    .task = http_resume_wrapper,\n                    .fallback = http_resume_fallback_wrapper);\n}\n\n/**\n * Hijacks the socket away from the HTTP protocol and away from facil.io.\n */\nintptr_t http_hijack(http_s *h, fio_str_info_s *leftover) {\n  if (!h)\n    return -1;\n  return ((http_vtable_s *)h->private_data.vtbl)->http_hijack(h, leftover);\n}\n\n/* *****************************************************************************\nSetting the default settings and allocating a persistent copy\n***************************************************************************** */\n\nstatic void http_on_request_fallback(http_s *h) { http_send_error(h, 404); }\nstatic void http_on_upgrade_fallback(http_s *h, char *p, size_t i) {\n  http_send_error(h, 400);\n  (void)p;\n  (void)i;\n}\nstatic void http_on_response_fallback(http_s *h) { http_send_error(h, 400); }\n\nstatic http_settings_s *http_settings_new(http_settings_s arg_settings) {\n  /* TODO: improve locality by unifying malloc to a single call */\n  if (!arg_settings.on_request)\n    arg_settings.on_request = http_on_request_fallback;\n  if (!arg_settings.on_response)\n    arg_settings.on_response = http_on_response_fallback;\n  if (!arg_settings.on_upgrade)\n    arg_settings.on_upgrade = http_on_upgrade_fallback;\n\n  if (!arg_settings.max_body_size)\n    arg_settings.max_body_size = HTTP_DEFAULT_BODY_LIMIT;\n  if (!arg_settings.timeout)\n    arg_settings.timeout = 40;\n  if (!arg_settings.ws_max_msg_size)\n    arg_settings.ws_max_msg_size = 262144; /** defaults to ~250KB */\n  if (!arg_settings.ws_timeout)\n    arg_settings.ws_timeout = 40; /* defaults to 40 seconds */\n  if (!arg_settings.max_header_size)\n    arg_settings.max_header_size = 32 * 1024; /* defaults to 32Kib seconds */\n  if (arg_settings.max_clients <= 0 ||\n      (size_t)(arg_settings.max_clients + HTTP_BUSY_UNLESS_HAS_FDS) >\n          fio_capa()) {\n    arg_settings.max_clients = fio_capa();\n    if ((ssize_t)arg_settings.max_clients - HTTP_BUSY_UNLESS_HAS_FDS > 0)\n      arg_settings.max_clients -= HTTP_BUSY_UNLESS_HAS_FDS;\n  }\n\n  http_settings_s *settings = malloc(sizeof(*settings) + sizeof(void *));\n  *settings = arg_settings;\n\n  if (settings->public_folder) {\n    settings->public_folder_length = strlen(settings->public_folder);\n    if (settings->public_folder[0] == '~' &&\n        settings->public_folder[1] == '/' && getenv(\"HOME\")) {\n      char *home = getenv(\"HOME\");\n      size_t home_len = strlen(home);\n      char *tmp = malloc(settings->public_folder_length + home_len + 1);\n      memcpy(tmp, home, home_len);\n      if (home[home_len - 1] == '/')\n        --home_len;\n      memcpy(tmp + home_len, settings->public_folder + 1,\n             settings->public_folder_length); // copy also the NULL\n      settings->public_folder = tmp;\n      settings->public_folder_length = strlen(settings->public_folder);\n    } else {\n      settings->public_folder = malloc(settings->public_folder_length + 1);\n      memcpy((void *)settings->public_folder, arg_settings.public_folder,\n             settings->public_folder_length);\n      ((uint8_t *)settings->public_folder)[settings->public_folder_length] = 0;\n    }\n  }\n  return settings;\n}\n\nstatic void http_settings_free(http_settings_s *s) {\n  free((void *)s->public_folder);\n  free(s);\n}\n/* *****************************************************************************\nListening to HTTP connections\n***************************************************************************** */\n\nstatic uint8_t fio_http_at_capa = 0;\n\nstatic void http_on_server_protocol_http1(intptr_t uuid, void *set,\n                                          void *ignr_) {\n  fio_timeout_set(uuid, ((http_settings_s *)set)->timeout);\n  if (fio_uuid2fd(uuid) >= ((http_settings_s *)set)->max_clients) {\n    if (!fio_http_at_capa)\n      FIO_LOG_WARNING(\"HTTP server at capacity\");\n    fio_http_at_capa = 1;\n    http_send_error2(uuid, 503, set);\n    fio_close(uuid);\n    return;\n  }\n  fio_http_at_capa = 0;\n  fio_protocol_s *pr = http1_new(uuid, set, NULL, 0);\n  if (!pr)\n    fio_close(uuid);\n  (void)ignr_;\n}\n\nstatic void http_on_open(intptr_t uuid, void *set) {\n  http_on_server_protocol_http1(uuid, set, NULL);\n}\n\nstatic void http_on_finish(intptr_t uuid, void *set) {\n  http_settings_s *settings = set;\n\n  if (settings->on_finish)\n    settings->on_finish(settings);\n\n  http_settings_free(settings);\n  (void)uuid;\n}\n\n/**\n * Listens to HTTP connections at the specified `port`.\n *\n * Leave as NULL to ignore IP binding.\n *\n * Returns -1 on error and 0 on success.\n */\n#undef http_listen\nintptr_t http_listen(const char *port, const char *binding,\n                     struct http_settings_s arg_settings) {\n  if (arg_settings.on_request == NULL) {\n    FIO_LOG_ERROR(\"http_listen requires the .on_request parameter \"\n                  \"to be set\\n\");\n    kill(0, SIGINT);\n    exit(11);\n  }\n\n  http_settings_s *settings = http_settings_new(arg_settings);\n  settings->is_client = 0;\n  if (settings->tls) {\n    fio_tls_alpn_add(settings->tls, \"http/1.1\", http_on_server_protocol_http1,\n                     NULL, NULL);\n  }\n\n  return fio_listen(.port = port, .address = binding, .tls = arg_settings.tls,\n                    .on_finish = http_on_finish, .on_open = http_on_open,\n                    .udata = settings);\n}\n/** Listens to HTTP connections at the specified `port` and `binding`. */\n#define http_listen(port, binding, ...)                                        \\\n  http_listen((port), (binding), (struct http_settings_s)(__VA_ARGS__))\n\n/**\n * Returns the settings used to setup the connection.\n *\n * Returns NULL on error (i.e., connection was lost).\n */\nstruct http_settings_s *http_settings(http_s *r) {\n  return ((http_fio_protocol_s *)r->private_data.flag)->settings;\n}\n\n/**\n * Returns the direct address of the connected peer (likely an intermediary).\n */\nfio_str_info_s http_peer_addr(http_s *h) {\n  return fio_peer_addr(((http_fio_protocol_s *)h->private_data.flag)->uuid);\n}\n\n/* *****************************************************************************\nHTTP client connections\n***************************************************************************** */\n\nstatic void http_on_close_client(intptr_t uuid, fio_protocol_s *protocol) {\n  http_fio_protocol_s *p = (http_fio_protocol_s *)protocol;\n  http_settings_s *set = p->settings;\n  void (**original)(intptr_t, fio_protocol_s *) =\n      (void (**)(intptr_t, fio_protocol_s *))(set + 1);\n  if (set->on_finish)\n    set->on_finish(set);\n\n  original[0](uuid, protocol);\n  http_settings_free(set);\n}\n\nstatic void http_on_open_client_perform(http_settings_s *set) {\n  http_s *h = set->udata;\n  set->on_response(h);\n}\nstatic void http_on_open_client_http1(intptr_t uuid, void *set_,\n                                      void *ignore_) {\n  http_settings_s *set = set_;\n  http_s *h = set->udata;\n  fio_timeout_set(uuid, set->timeout);\n  fio_protocol_s *pr = http1_new(uuid, set, NULL, 0);\n  if (!pr) {\n    fio_close(uuid);\n    return;\n  }\n  { /* store the original on_close at the end of the struct, we wrap it. */\n    void (**original)(intptr_t, fio_protocol_s *) =\n        (void (**)(intptr_t, fio_protocol_s *))(set + 1);\n    *original = pr->on_close;\n    pr->on_close = http_on_close_client;\n  }\n  h->private_data.flag = (uintptr_t)pr;\n  h->private_data.vtbl = http1_vtable();\n  http_on_open_client_perform(set);\n  (void)ignore_;\n}\n\nstatic void http_on_open_client(intptr_t uuid, void *set_) {\n  http_on_open_client_http1(uuid, set_, NULL);\n}\n\nstatic void http_on_client_failed(intptr_t uuid, void *set_) {\n  http_settings_s *set = set_;\n  http_s *h = set->udata;\n  set->udata = h->udata;\n  http_s_destroy(h, 0);\n  fio_free(h);\n  if (set->on_finish)\n    set->on_finish(set);\n  http_settings_free(set);\n  (void)uuid;\n}\n\nintptr_t http_connect__(void); /* sublime text marker */\n/**\n * Connects to an HTTP server as a client.\n *\n * Upon a successful connection, the `on_response` callback is called with an\n * empty `http_s*` handler (status == 0). Use the same API to set it's content\n * and send the request to the server. The next`on_response` will contain the\n * response.\n *\n * `address` should contain a full URL style address for the server. i.e.:\n *           \"http:/www.example.com:8080/\"\n *\n * Returns -1 on error and 0 on success. the `on_finish` callback is always\n * called.\n */\nintptr_t http_connect FIO_IGNORE_MACRO(const char *url,\n                                       const char *unix_address,\n                                       struct http_settings_s arg_settings) {\n  if (!arg_settings.on_response && !arg_settings.on_upgrade) {\n    FIO_LOG_ERROR(\"http_connect requires either an on_response \"\n                  \" or an on_upgrade callback.\\n\");\n    errno = EINVAL;\n    goto on_error;\n  }\n  size_t len = 0, h_len = 0;\n  char *a = NULL, *p = NULL, *host = NULL;\n  uint8_t is_websocket = 0;\n  uint8_t is_secure = 0;\n  FIOBJ path = FIOBJ_INVALID;\n  if (!url && !unix_address) {\n    FIO_LOG_ERROR(\"http_connect requires a valid address.\");\n    errno = EINVAL;\n    goto on_error;\n  }\n  if (url) {\n    fio_url_s u = fio_url_parse(url, strlen(url));\n    if (u.scheme.data &&\n        (u.scheme.len == 2 || (u.scheme.len == 3 && u.scheme.data[2] == 's')) &&\n        u.scheme.data[0] == 'w' && u.scheme.data[1] == 's') {\n      is_websocket = 1;\n      is_secure = (u.scheme.len == 3);\n    } else if (u.scheme.data &&\n               (u.scheme.len == 4 ||\n                (u.scheme.len == 5 && u.scheme.data[4] == 's')) &&\n               u.scheme.data[0] == 'h' && u.scheme.data[1] == 't' &&\n               u.scheme.data[2] == 't' && u.scheme.data[3] == 'p') {\n      is_secure = (u.scheme.len == 5);\n    }\n    if (is_secure && !arg_settings.tls) {\n      FIO_LOG_ERROR(\"Secure connections (%.*s) require a TLS object.\",\n                    (int)u.scheme.len, u.scheme.data);\n      errno = EINVAL;\n      goto on_error;\n    }\n    if (u.path.data) {\n      path = fiobj_str_new(\n          u.path.data, strlen(u.path.data)); /* copy query and target as well */\n    }\n    if (unix_address) {\n      a = (char *)unix_address;\n      h_len = len = strlen(a);\n      host = a;\n    } else {\n      if (!u.host.data) {\n        FIO_LOG_ERROR(\"http_connect requires a valid address.\");\n        errno = EINVAL;\n        goto on_error;\n      }\n      /***** no more error handling, since memory is allocated *****/\n      /* copy address */\n      a = fio_malloc(u.host.len + 1);\n      memcpy(a, u.host.data, u.host.len);\n      a[u.host.len] = 0;\n      len = u.host.len;\n      /* copy port */\n      if (u.port.data) {\n        p = fio_malloc(u.port.len + 1);\n        memcpy(p, u.port.data, u.port.len);\n        p[u.port.len] = 0;\n      } else if (is_secure) {\n        p = fio_malloc(3 + 1);\n        memcpy(p, \"443\", 3);\n        p[3] = 0;\n      } else {\n        p = fio_malloc(2 + 1);\n        memcpy(p, \"80\", 2);\n        p[2] = 0;\n      }\n    }\n    if (u.host.data) {\n      host = u.host.data;\n      h_len = u.host.len;\n    }\n  }\n\n  /* set settings */\n  if (!arg_settings.timeout)\n    arg_settings.timeout = 30;\n  http_settings_s *settings = http_settings_new(arg_settings);\n  settings->is_client = 1;\n  // if (settings->tls) {\n  //   fio_tls_alpn_add(settings->tls, \"http/1.1\", http_on_open_client_http1,\n  //                     NULL, NULL);\n  // }\n\n  if (!arg_settings.ws_timeout)\n    settings->ws_timeout = 0; /* allow server to dictate timeout */\n  if (!arg_settings.timeout)\n    settings->timeout = 0; /* allow server to dictate timeout */\n  http_s *h = fio_malloc(sizeof(*h));\n  FIO_ASSERT(h, \"HTTP Client handler allocation failed\");\n  http_s_new(h, 0, http1_vtable());\n  h->udata = arg_settings.udata;\n  h->status = 0;\n  h->path = path;\n  settings->udata = h;\n  settings->tls = arg_settings.tls;\n  if (host)\n    http_set_header2(h, (fio_str_info_s){.data = (char *)\"host\", .len = 4},\n                     (fio_str_info_s){.data = host, .len = h_len});\n  intptr_t ret;\n  if (is_websocket) {\n    /* force HTTP/1.1 */\n    ret = fio_connect(.address = a, .port = p, .on_fail = http_on_client_failed,\n                      .on_connect = http_on_open_client, .udata = settings,\n                      .tls = arg_settings.tls);\n    (void)0;\n  } else {\n    /* Allow for any HTTP version */\n    ret = fio_connect(.address = a, .port = p, .on_fail = http_on_client_failed,\n                      .on_connect = http_on_open_client, .udata = settings,\n                      .tls = arg_settings.tls);\n    (void)0;\n  }\n  if (a != unix_address)\n    fio_free(a);\n  fio_free(p);\n  return ret;\non_error:\n  if (arg_settings.on_finish)\n    arg_settings.on_finish(&arg_settings);\n  return -1;\n}\n\n/* *****************************************************************************\nHTTP Websocket Connect\n***************************************************************************** */\n\n#undef http_upgrade2ws\nstatic void on_websocket_http_connected(http_s *h) {\n  websocket_settings_s *s = h->udata;\n  h->udata = http_settings(h)->udata = NULL;\n  if (!h->path) {\n    FIO_LOG_WARNING(\"(websocket client) path not specified in \"\n                    \"address, assuming root!\");\n    h->path = fiobj_str_new(\"/\", 1);\n  }\n  http_upgrade2ws(h, *s);\n  fio_free(s);\n}\n\nstatic void on_websocket_http_connection_finished(http_settings_s *settings) {\n  websocket_settings_s *s = settings->udata;\n  if (s) {\n    if (s->on_close)\n      s->on_close(0, s->udata);\n    fio_free(s);\n  }\n}\n\n#undef websocket_connect\nint websocket_connect(const char *address, websocket_settings_s settings) {\n  websocket_settings_s *s = fio_malloc(sizeof(*s));\n  *s = settings;\n  return http_connect(address, NULL, .on_request = on_websocket_http_connected,\n                      .on_response = on_websocket_http_connected,\n                      .on_finish = on_websocket_http_connection_finished,\n                      .udata = s);\n}\n#define websocket_connect(address, ...)                                        \\\n  websocket_connect((address), (websocket_settings_s){__VA_ARGS__})\n\n/* *****************************************************************************\nEventSource Support (SSE)\n\nNote:\n\n* `http_sse_subscribe` and `http_sse_unsubscribe` are implemented in the\n  http_internal logical unit.\n\n***************************************************************************** */\n\nstatic inline void http_sse_copy2str(FIOBJ dest, char *prefix, size_t pre_len,\n                                     fio_str_info_s data) {\n  if (!data.len)\n    return;\n  const char *stop = data.data + data.len;\n  while (data.len) {\n    fiobj_str_write(dest, prefix, pre_len);\n    char *pos = data.data;\n    while (pos < stop && *pos != '\\n' && *pos != '\\r')\n      ++pos;\n    fiobj_str_write(dest, data.data, (uintptr_t)(pos - data.data));\n    fiobj_str_write(dest, \"\\r\\n\", 2);\n    if (*pos == '\\r')\n      ++pos;\n    if (*pos == '\\n')\n      ++pos;\n    data.len -= (uintptr_t)(pos - data.data);\n    data.data = pos;\n  }\n}\n\n/** The on message callback. the `*msg` pointer is to a temporary object. */\nstatic void http_sse_on_message(fio_msg_s *msg) {\n  http_sse_internal_s *sse = msg->udata1;\n  struct http_sse_subscribe_args *args = msg->udata2;\n  /* perform a callback */\n  fio_protocol_s *pr = fio_protocol_try_lock(sse->uuid, FIO_PR_LOCK_TASK);\n  if (!pr)\n    goto postpone;\n  args->on_message(&sse->sse, msg->channel, msg->msg, args->udata);\n  fio_protocol_unlock(pr, FIO_PR_LOCK_TASK);\n  return;\npostpone:\n  if (errno == EBADF)\n    return;\n  fio_message_defer(msg);\n  return;\n}\n\nstatic void http_sse_on_message__direct(http_sse_s *sse, fio_str_info_s channel,\n                                        fio_str_info_s msg, void *udata) {\n  http_sse_write(sse, .data = msg);\n  (void)udata;\n  (void)channel;\n}\n/** An optional callback for when a subscription is fully canceled. */\nstatic void http_sse_on_unsubscribe(void *sse_, void *args_) {\n  http_sse_internal_s *sse = sse_;\n  struct http_sse_subscribe_args *args = args_;\n  if (args->on_unsubscribe)\n    args->on_unsubscribe(args->udata);\n  fio_free(args);\n  http_sse_try_free(sse);\n}\n\n/** This macro allows easy access to the `http_sse_subscribe` function. */\n#undef http_sse_subscribe\n/**\n * Subscribes to a channel. See {struct http_sse_subscribe_args} for possible\n * arguments.\n *\n * Returns a subscription ID on success and 0 on failure.\n *\n * All subscriptions are automatically revoked once the connection is closed.\n *\n * If the connections subscribes to the same channel more than once, messages\n * will be merged. However, another subscription ID will be assigned, and two\n * calls to {http_sse_unsubscribe} will be required in order to unregister from\n * the channel.\n */\nuintptr_t http_sse_subscribe(http_sse_s *sse_,\n                             struct http_sse_subscribe_args args) {\n  http_sse_internal_s *sse = FIO_LS_EMBD_OBJ(http_sse_internal_s, sse, sse_);\n  if (sse->uuid == -1)\n    return 0;\n  if (!args.on_message)\n    args.on_message = http_sse_on_message__direct;\n  struct http_sse_subscribe_args *udata = fio_malloc(sizeof(*udata));\n  FIO_ASSERT_ALLOC(udata);\n  *udata = args;\n\n  fio_atomic_add(&sse->ref, 1);\n  subscription_s *sub =\n      fio_subscribe(.channel = args.channel, .on_message = http_sse_on_message,\n                    .on_unsubscribe = http_sse_on_unsubscribe, .udata1 = sse,\n                    .udata2 = udata, .match = args.match);\n  if (!sub)\n    return 0;\n\n  fio_lock(&sse->lock);\n  fio_ls_s *pos = fio_ls_push(&sse->subscriptions, sub);\n  fio_unlock(&sse->lock);\n  return (uintptr_t)pos;\n}\n\n/**\n * Cancels a subscription and invalidates the subscription object.\n */\nvoid http_sse_unsubscribe(http_sse_s *sse_, uintptr_t subscription) {\n  if (!sse_ || !subscription)\n    return;\n  http_sse_internal_s *sse = FIO_LS_EMBD_OBJ(http_sse_internal_s, sse, sse_);\n  subscription_s *sub = (subscription_s *)((fio_ls_s *)subscription)->obj;\n  fio_lock(&sse->lock);\n  fio_ls_remove((fio_ls_s *)subscription);\n  fio_unlock(&sse->lock);\n  fio_unsubscribe(sub);\n}\n\n#undef http_upgrade2sse\n/**\n * Upgrades an HTTP connection to an EventSource (SSE) connection.\n *\n * Thie `http_s` handle will be invalid after this call.\n *\n * On HTTP/1.1 connections, this will preclude future requests using the same\n * connection.\n */\nint http_upgrade2sse(http_s *h, http_sse_s sse) {\n  if (HTTP_INVALID_HANDLE(h)) {\n    if (sse.on_close)\n      sse.on_close(&sse);\n    return -1;\n  }\n  return ((http_vtable_s *)h->private_data.vtbl)->http_upgrade2sse(h, &sse);\n}\n\n/**\n * Sets the ping interval for SSE connections.\n */\nvoid http_sse_set_timout(http_sse_s *sse_, uint8_t timeout) {\n  if (!sse_)\n    return;\n  http_sse_internal_s *sse = FIO_LS_EMBD_OBJ(http_sse_internal_s, sse, sse_);\n  fio_timeout_set(sse->uuid, timeout);\n}\n\n#undef http_sse_write\n/**\n * Writes data to an EventSource (SSE) connection.\n */\nint http_sse_write(http_sse_s *sse, struct http_sse_write_args args) {\n  if (!sse || !(args.id.len + args.data.len + args.event.len) ||\n      fio_is_closed(FIO_LS_EMBD_OBJ(http_sse_internal_s, sse, sse)->uuid))\n    return -1;\n  FIOBJ buf;\n  {\n    /* best guess at data length, ignoring missing fields and multiline data */\n    const size_t total = 4 + args.id.len + 2 + 7 + args.event.len + 2 + 6 +\n                         args.data.len + 2 + 7 + 10 + 4;\n    buf = fiobj_str_buf(total);\n  }\n  http_sse_copy2str(buf, (char *)\"id: \", 4, args.id);\n  http_sse_copy2str(buf, (char *)\"event: \", 7, args.event);\n  if (args.retry) {\n    FIOBJ i = fiobj_num_new(args.retry);\n    fiobj_str_write(buf, (char *)\"retry: \", 7);\n    fiobj_str_join(buf, i);\n    fiobj_free(i);\n  }\n  http_sse_copy2str(buf, (char *)\"data: \", 6, args.data);\n  fiobj_str_write(buf, \"\\r\\n\", 2);\n  return FIO_LS_EMBD_OBJ(http_sse_internal_s, sse, sse)\n      ->vtable->http_sse_write(sse, buf);\n}\n\n/**\n * Get the connection's UUID (for fio_defer and similar use cases).\n */\nintptr_t http_sse2uuid(http_sse_s *sse) {\n  if (!sse ||\n      fio_is_closed(FIO_LS_EMBD_OBJ(http_sse_internal_s, sse, sse)->uuid))\n    return -1;\n  return FIO_LS_EMBD_OBJ(http_sse_internal_s, sse, sse)->uuid;\n}\n\n/**\n * Closes an EventSource (SSE) connection.\n */\nint http_sse_close(http_sse_s *sse) {\n  if (!sse ||\n      fio_is_closed(FIO_LS_EMBD_OBJ(http_sse_internal_s, sse, sse)->uuid))\n    return -1;\n  return FIO_LS_EMBD_OBJ(http_sse_internal_s, sse, sse)\n      ->vtable->http_sse_close(sse);\n}\n\n/**\n * Duplicates an SSE handle by reference, remember to http_sse_free.\n *\n * Returns the same object (increases a reference count, no allocation is made).\n */\nhttp_sse_s *http_sse_dup(http_sse_s *sse) {\n  fio_atomic_add(&FIO_LS_EMBD_OBJ(http_sse_internal_s, sse, sse)->ref, 1);\n  return sse;\n}\n\n/**\n * Frees an SSE handle by reference (decreases the reference count).\n */\nvoid http_sse_free(http_sse_s *sse) {\n  http_sse_try_free(FIO_LS_EMBD_OBJ(http_sse_internal_s, sse, sse));\n}\n\n/* *****************************************************************************\nHTTP GET and POST parsing helpers\n***************************************************************************** */\n\n/** URL decodes a string, returning a `FIOBJ`. */\nstatic inline FIOBJ http_urlstr2fiobj(char *s, size_t len) {\n  FIOBJ o = fiobj_str_buf(len);\n  ssize_t l = http_decode_url(fiobj_obj2cstr(o).data, s, len);\n  if (l < 0) {\n    fiobj_free(o);\n    return fiobj_str_new(NULL, 0); /* empty string */\n  }\n  fiobj_str_resize(o, (size_t)l);\n  return o;\n}\n\n/** converts a string into a `FIOBJ`. */\nstatic inline FIOBJ http_str2fiobj(char *s, size_t len, uint8_t encoded) {\n  switch (len) {\n  case 0:\n    return fiobj_str_new(NULL, 0); /* empty string */\n  case 4:\n    if (!strncasecmp(s, \"true\", 4))\n      return fiobj_true();\n    if (!strncasecmp(s, \"null\", 4))\n      return fiobj_null();\n    break;\n  case 5:\n    if (!strncasecmp(s, \"false\", 5))\n      return fiobj_false();\n  }\n  {\n    char *end = s;\n    const uint64_t tmp = fio_atol(&end);\n    if (end == s + len)\n      return fiobj_num_new(tmp);\n  }\n  {\n    char *end = s;\n    const double tmp = fio_atof(&end);\n    if (end == s + len)\n      return fiobj_float_new(tmp);\n  }\n  if (encoded)\n    return http_urlstr2fiobj(s, len);\n  return fiobj_str_new(s, len);\n}\n\n/** Parses the query part of an HTTP request/response. Uses `http_add2hash`. */\nvoid http_parse_query(http_s *h) {\n  if (!h->query)\n    return;\n  if (!h->params)\n    h->params = fiobj_hash_new();\n  fio_str_info_s q = fiobj_obj2cstr(h->query);\n  do {\n    char *cut = memchr(q.data, '&', q.len);\n    if (!cut)\n      cut = q.data + q.len;\n    char *cut2 = memchr(q.data, '=', (cut - q.data));\n    if (cut2) {\n      /* we only add named elements... */\n      http_add2hash(h->params, q.data, (size_t)(cut2 - q.data), (cut2 + 1),\n                    (size_t)(cut - (cut2 + 1)), 1);\n    }\n    if (cut[0] == '&') {\n      /* protecting against some ...less informed... clients */\n      if (cut[1] == 'a' && cut[2] == 'm' && cut[3] == 'p' && cut[4] == ';')\n        cut += 5;\n      else\n        cut += 1;\n    }\n    q.len -= (uintptr_t)(cut - q.data);\n    q.data = cut;\n  } while (q.len);\n}\n\nstatic inline void http_parse_cookies_cookie_str(FIOBJ dest, FIOBJ str,\n                                                 uint8_t is_url_encoded) {\n  if (!FIOBJ_TYPE_IS(str, FIOBJ_T_STRING))\n    return;\n  fio_str_info_s s = fiobj_obj2cstr(str);\n  while (s.len) {\n    if (s.data[0] == ' ') {\n      ++s.data;\n      --s.len;\n      continue;\n    }\n    char *cut = memchr(s.data, '=', s.len);\n    if (!cut)\n      cut = s.data;\n    char *cut2 = memchr(cut, ';', s.len - (cut - s.data));\n    if (!cut2)\n      cut2 = s.data + s.len;\n    http_add2hash(dest, s.data, cut - s.data, cut + 1, (cut2 - (cut + 1)),\n                  is_url_encoded);\n    if ((size_t)((cut2 + 1) - s.data) > s.len)\n      s.len = 0;\n    else\n      s.len -= ((cut2 + 1) - s.data);\n    s.data = cut2 + 1;\n  }\n}\nstatic inline void http_parse_cookies_setcookie_str(FIOBJ dest, FIOBJ str,\n                                                    uint8_t is_url_encoded) {\n  if (!FIOBJ_TYPE_IS(str, FIOBJ_T_STRING))\n    return;\n  fio_str_info_s s = fiobj_obj2cstr(str);\n  char *cut = memchr(s.data, '=', s.len);\n  if (!cut)\n    cut = s.data;\n  char *cut2 = memchr(cut, ';', s.len - (cut - s.data));\n  if (!cut2)\n    cut2 = s.data + s.len;\n  if (cut2 > cut)\n    http_add2hash(dest, s.data, cut - s.data, cut + 1, (cut2 - (cut + 1)),\n                  is_url_encoded);\n}\n\n/** Parses any Cookie / Set-Cookie headers, using the `http_add2hash` scheme. */\nvoid http_parse_cookies(http_s *h, uint8_t is_url_encoded) {\n  if (!h->headers)\n    return;\n  if (h->cookies && fiobj_hash_count(h->cookies)) {\n    FIO_LOG_WARNING(\"(http) attempting to parse cookies more than once.\");\n    return;\n  }\n  static uint64_t setcookie_header_hash;\n  if (!setcookie_header_hash)\n    setcookie_header_hash = fiobj_obj2hash(HTTP_HEADER_SET_COOKIE);\n  FIOBJ c = fiobj_hash_get2(h->headers, fiobj_obj2hash(HTTP_HEADER_COOKIE));\n  if (c) {\n    if (!h->cookies)\n      h->cookies = fiobj_hash_new();\n    if (FIOBJ_TYPE_IS(c, FIOBJ_T_ARRAY)) {\n      /* Array of Strings */\n      size_t count = fiobj_ary_count(c);\n      for (size_t i = 0; i < count; ++i) {\n        http_parse_cookies_cookie_str(\n            h->cookies, fiobj_ary_index(c, (int64_t)i), is_url_encoded);\n      }\n    } else {\n      /* single string */\n      http_parse_cookies_cookie_str(h->cookies, c, is_url_encoded);\n    }\n  }\n  c = fiobj_hash_get2(h->headers, fiobj_obj2hash(HTTP_HEADER_SET_COOKIE));\n  if (c) {\n    if (!h->cookies)\n      h->cookies = fiobj_hash_new();\n    if (FIOBJ_TYPE_IS(c, FIOBJ_T_ARRAY)) {\n      /* Array of Strings */\n      size_t count = fiobj_ary_count(c);\n      for (size_t i = 0; i < count; ++i) {\n        http_parse_cookies_setcookie_str(\n            h->cookies, fiobj_ary_index(c, (int64_t)i), is_url_encoded);\n      }\n    } else {\n      /* single string */\n      http_parse_cookies_setcookie_str(h->cookies, c, is_url_encoded);\n    }\n  }\n}\n\n/**\n * Adds a named parameter to the hash, resolving nesting references.\n *\n * i.e.:\n *\n * * \"name[]\" references a nested Array (nested in the Hash).\n * * \"name[key]\" references a nested Hash.\n * * \"name[][key]\" references a nested Hash within an array. Hash keys will be\n *   unique (repeating a key advances the hash).\n * * These rules can be nested (i.e. \"name[][key1][][key2]...\")\n * * \"name[][]\" is an error (there's no way for the parser to analyze\n *    dimensions)\n *\n * Note: names can't begin with \"[\" or end with \"]\" as these are reserved\n *       characters.\n */\nint http_add2hash2(FIOBJ dest, char *name, size_t name_len, FIOBJ val,\n                   uint8_t encoded) {\n  if (!name)\n    goto error;\n  FIOBJ nested_ary = FIOBJ_INVALID;\n  char *cut1;\n  /* we can't start with an empty object name */\n  while (name_len && name[0] == '[') {\n    --name_len;\n    ++name;\n  }\n  if (!name_len) {\n    /* an empty name is an error */\n    goto error;\n  }\n  uint32_t nesting = ((uint32_t)~0);\nrebase:\n  /* test for nesting level limit (limit at 32) */\n  if (!nesting)\n    goto error;\n  /* start clearing away bits. */\n  nesting >>= 1;\n  /* since we might be rebasing, notice that \"name\" might be \"name]\" */\n  cut1 = memchr(name, '[', name_len);\n  if (!cut1)\n    goto place_in_hash;\n  /* simple case \"name=\" (the \"=\" was already removed) */\n  if (cut1 == name) {\n    /* an empty name is an error */\n    goto error;\n  }\n  if (cut1 + 1 == name + name_len) {\n    /* we have name[= ... autocorrect */\n    name_len -= 1;\n    goto place_in_array;\n  }\n\n  if (cut1[1] == ']') {\n    /* Nested Array \"name[]...\" */\n\n    /* Test for name[]= */\n    if ((cut1 + 2) == name + name_len) {\n      name_len -= 2;\n      goto place_in_array;\n    }\n\n    /* Test for a nested Array format error */\n    if (cut1[2] != '[' || cut1[3] == ']') { /* error, we can't parse this */\n      goto error;\n    }\n\n    /* we have name[][key...= */\n\n    /* ensure array exists and it's an array + set nested_ary */\n    const size_t len = ((cut1[-1] == ']') ? (size_t)((cut1 - 1) - name)\n                                          : (size_t)(cut1 - name));\n    const uint64_t hash =\n        fiobj_hash_string(name, len); /* hash the current name */\n    nested_ary = fiobj_hash_get2(dest, hash);\n    if (!nested_ary) {\n      /* create a new nested array */\n      FIOBJ key =\n          encoded ? http_urlstr2fiobj(name, len) : fiobj_str_new(name, len);\n      nested_ary = fiobj_ary_new2(4);\n      fiobj_hash_set(dest, key, nested_ary);\n      fiobj_free(key);\n    } else if (!FIOBJ_TYPE_IS(nested_ary, FIOBJ_T_ARRAY)) {\n      /* convert existing object to an array - auto error correction */\n      FIOBJ key =\n          encoded ? http_urlstr2fiobj(name, len) : fiobj_str_new(name, len);\n      FIOBJ tmp = fiobj_ary_new2(4);\n      fiobj_ary_push(tmp, nested_ary);\n      nested_ary = tmp;\n      fiobj_hash_set(dest, key, nested_ary);\n      fiobj_free(key);\n    }\n\n    /* test if last object in the array is a hash - create hash if not */\n    dest = fiobj_ary_index(nested_ary, -1);\n    if (!dest || !FIOBJ_TYPE_IS(dest, FIOBJ_T_HASH)) {\n      dest = fiobj_hash_new();\n      fiobj_ary_push(nested_ary, dest);\n    }\n\n    /* rebase `name` to `key` and restart. */\n    cut1 += 3; /* consume \"[][\" */\n    name_len -= (size_t)(cut1 - name);\n    name = cut1;\n    goto rebase;\n\n  } else {\n    /* we have name[key]... */\n    const size_t len = ((cut1[-1] == ']') ? (size_t)((cut1 - 1) - name)\n                                          : (size_t)(cut1 - name));\n    const uint64_t hash =\n        fiobj_hash_string(name, len); /* hash the current name */\n    FIOBJ tmp = fiobj_hash_get2(dest, hash);\n    if (!tmp) {\n      /* hash doesn't exist, create it */\n      FIOBJ key =\n          encoded ? http_urlstr2fiobj(name, len) : fiobj_str_new(name, len);\n      tmp = fiobj_hash_new();\n      fiobj_hash_set(dest, key, tmp);\n      fiobj_free(key);\n    } else if (!FIOBJ_TYPE_IS(tmp, FIOBJ_T_HASH)) {\n      /* type error, referencing an existing object that isn't a Hash */\n      goto error;\n    }\n    dest = tmp;\n    /* no rollback is possible once we enter the new nesting level... */\n    nested_ary = FIOBJ_INVALID;\n    /* rebase `name` to `key` and restart. */\n    cut1 += 1; /* consume \"[\" */\n    name_len -= (size_t)(cut1 - name);\n    name = cut1;\n    goto rebase;\n  }\n\nplace_in_hash:\n  if (name[name_len - 1] == ']')\n    --name_len;\n  {\n    FIOBJ key = encoded ? http_urlstr2fiobj(name, name_len)\n                        : fiobj_str_new(name, name_len);\n    FIOBJ old = fiobj_hash_replace(dest, key, val);\n    if (old) {\n      if (nested_ary) {\n        fiobj_hash_replace(dest, key, old);\n        old = fiobj_hash_new();\n        fiobj_hash_set(old, key, val);\n        fiobj_ary_push(nested_ary, old);\n      } else {\n        if (!FIOBJ_TYPE_IS(old, FIOBJ_T_ARRAY)) {\n          FIOBJ tmp = fiobj_ary_new2(4);\n          fiobj_ary_push(tmp, old);\n          old = tmp;\n        }\n        fiobj_ary_push(old, val);\n        fiobj_hash_replace(dest, key, old);\n      }\n    }\n    fiobj_free(key);\n  }\n  return 0;\n\nplace_in_array:\n  if (name[name_len - 1] == ']')\n    --name_len;\n  {\n    uint64_t hash = fiobj_hash_string(name, name_len);\n    FIOBJ ary = fiobj_hash_get2(dest, hash);\n    if (!ary) {\n      FIOBJ key = encoded ? http_urlstr2fiobj(name, name_len)\n                          : fiobj_str_new(name, name_len);\n      ary = fiobj_ary_new2(4);\n      fiobj_hash_set(dest, key, ary);\n      fiobj_free(key);\n    } else if (!FIOBJ_TYPE_IS(ary, FIOBJ_T_ARRAY)) {\n      FIOBJ tmp = fiobj_ary_new2(4);\n      fiobj_ary_push(tmp, ary);\n      ary = tmp;\n      FIOBJ key = encoded ? http_urlstr2fiobj(name, name_len)\n                          : fiobj_str_new(name, name_len);\n      fiobj_hash_replace(dest, key, ary);\n      fiobj_free(key);\n    }\n    fiobj_ary_push(ary, val);\n  }\n  return 0;\nerror:\n  fiobj_free(val);\n  errno = EOPNOTSUPP;\n  return -1;\n}\n\n/**\n * Adds a named parameter to the hash, resolving nesting references.\n *\n * i.e.:\n *\n * * \"name[]\" references a nested Array (nested in the Hash).\n * * \"name[key]\" references a nested Hash.\n * * \"name[][key]\" references a nested Hash within an array. Hash keys will be\n *   unique (repeating a key advances the hash).\n * * These rules can be nested (i.e. \"name[][key1][][key2]...\")\n * * \"name[][]\" is an error (there's no way for the parser to analyze\n *    dimensions)\n *\n * Note: names can't begin with \"[\" or end with \"]\" as these are reserved\n *       characters.\n */\nint http_add2hash(FIOBJ dest, char *name, size_t name_len, char *value,\n                  size_t value_len, uint8_t encoded) {\n  return http_add2hash2(dest, name, name_len,\n                        http_str2fiobj(value, value_len, encoded), encoded);\n}\n\n/* *****************************************************************************\nHTTP Body Parsing\n***************************************************************************** */\n#include <http_mime_parser.h>\n\ntypedef struct {\n  http_mime_parser_s p;\n  http_s *h;\n  fio_str_info_s buffer;\n  size_t pos;\n  size_t partial_offset;\n  size_t partial_length;\n  FIOBJ partial_name;\n} http_fio_mime_s;\n\n#define http_mime_parser2fio(parser) ((http_fio_mime_s *)(parser))\n\n/** Called when all the data is available at once. */\nstatic void http_mime_parser_on_data(http_mime_parser_s *parser, void *name,\n                                     size_t name_len, void *filename,\n                                     size_t filename_len, void *mimetype,\n                                     size_t mimetype_len, void *value,\n                                     size_t value_len) {\n  if (!filename_len) {\n    http_add2hash(http_mime_parser2fio(parser)->h->params, name, name_len,\n                  value, value_len, 0);\n    return;\n  }\n  FIOBJ n = fiobj_str_new(name, name_len);\n  fiobj_str_write(n, \"[data]\", 6);\n  fio_str_info_s tmp = fiobj_obj2cstr(n);\n  http_add2hash(http_mime_parser2fio(parser)->h->params, tmp.data, tmp.len,\n                value, value_len, 0);\n  fiobj_str_resize(n, name_len);\n  fiobj_str_write(n, \"[name]\", 6);\n  tmp = fiobj_obj2cstr(n);\n  http_add2hash(http_mime_parser2fio(parser)->h->params, tmp.data, tmp.len,\n                filename, filename_len, 0);\n  if (mimetype_len) {\n    fiobj_str_resize(n, name_len);\n    fiobj_str_write(n, \"[type]\", 6);\n    tmp = fiobj_obj2cstr(n);\n    http_add2hash(http_mime_parser2fio(parser)->h->params, tmp.data, tmp.len,\n                  mimetype, mimetype_len, 0);\n  }\n  fiobj_free(n);\n}\n\n/** Called when the data didn't fit in the buffer. Data will be streamed. */\nstatic void http_mime_parser_on_partial_start(\n    http_mime_parser_s *parser, void *name, size_t name_len, void *filename,\n    size_t filename_len, void *mimetype, size_t mimetype_len) {\n  http_mime_parser2fio(parser)->partial_length = 0;\n  http_mime_parser2fio(parser)->partial_offset = 0;\n  http_mime_parser2fio(parser)->partial_name = fiobj_str_new(name, name_len);\n\n  if (!filename)\n    return;\n\n  fiobj_str_write(http_mime_parser2fio(parser)->partial_name, \"[type]\", 6);\n  fio_str_info_s tmp =\n      fiobj_obj2cstr(http_mime_parser2fio(parser)->partial_name);\n  http_add2hash(http_mime_parser2fio(parser)->h->params, tmp.data, tmp.len,\n                mimetype, mimetype_len, 0);\n\n  fiobj_str_resize(http_mime_parser2fio(parser)->partial_name, name_len);\n  fiobj_str_write(http_mime_parser2fio(parser)->partial_name, \"[name]\", 6);\n  tmp = fiobj_obj2cstr(http_mime_parser2fio(parser)->partial_name);\n  http_add2hash(http_mime_parser2fio(parser)->h->params, tmp.data, tmp.len,\n                filename, filename_len, 0);\n\n  fiobj_str_resize(http_mime_parser2fio(parser)->partial_name, name_len);\n  fiobj_str_write(http_mime_parser2fio(parser)->partial_name, \"[data]\", 6);\n}\n\n/** Called when partial data is available. */\nstatic void http_mime_parser_on_partial_data(http_mime_parser_s *parser,\n                                             void *value, size_t value_len) {\n  if (!http_mime_parser2fio(parser)->partial_offset)\n    http_mime_parser2fio(parser)->partial_offset =\n        http_mime_parser2fio(parser)->pos +\n        ((uintptr_t)value -\n         (uintptr_t)http_mime_parser2fio(parser)->buffer.data);\n  http_mime_parser2fio(parser)->partial_length += value_len;\n  (void)value;\n}\n\n/** Called when the partial data is complete. */\nstatic void http_mime_parser_on_partial_end(http_mime_parser_s *parser) {\n\n  fio_str_info_s tmp =\n      fiobj_obj2cstr(http_mime_parser2fio(parser)->partial_name);\n  FIOBJ o = FIOBJ_INVALID;\n  if (!http_mime_parser2fio(parser)->partial_length)\n    return;\n  if (http_mime_parser2fio(parser)->partial_length < 42) {\n    /* short data gets a new object */\n    o = fiobj_str_new(http_mime_parser2fio(parser)->buffer.data +\n                          http_mime_parser2fio(parser)->partial_offset,\n                      http_mime_parser2fio(parser)->partial_length);\n  } else {\n    /* longer data gets a reference object (memory collision concerns) */\n    o = fiobj_data_slice(http_mime_parser2fio(parser)->h->body,\n                         http_mime_parser2fio(parser)->partial_offset,\n                         http_mime_parser2fio(parser)->partial_length);\n  }\n  http_add2hash2(http_mime_parser2fio(parser)->h->params, tmp.data, tmp.len, o,\n                 0);\n  fiobj_free(http_mime_parser2fio(parser)->partial_name);\n  http_mime_parser2fio(parser)->partial_name = FIOBJ_INVALID;\n  http_mime_parser2fio(parser)->partial_offset = 0;\n}\n\n/**\n * Called when URL decoding is required.\n *\n * Should support inplace decoding (`dest == encoded`).\n *\n * Should return the length of the decoded string.\n */\nstatic inline size_t http_mime_decode_url(char *dest, const char *encoded,\n                                          size_t length) {\n  return http_decode_url(dest, encoded, length);\n}\n\n/**\n * Attempts to decode the request's body.\n *\n * Supported Types include:\n * * application/x-www-form-urlencoded\n * * application/json\n * * multipart/form-data\n */\nint http_parse_body(http_s *h) {\n  static uint64_t content_type_hash;\n  if (!h->body)\n    return -1;\n  if (!content_type_hash)\n    content_type_hash = fiobj_hash_string(\"content-type\", 12);\n  FIOBJ ct = fiobj_hash_get2(h->headers, content_type_hash);\n  fio_str_info_s content_type = fiobj_obj2cstr(ct);\n  if (content_type.len < 16)\n    return -1;\n  if (content_type.len >= 33 &&\n      !strncasecmp(\"application/x-www-form-urlencoded\", content_type.data,\n                   33)) {\n    if (!h->params)\n      h->params = fiobj_hash_new();\n    FIOBJ tmp = h->query;\n    h->query = h->body;\n    http_parse_query(h);\n    h->query = tmp;\n    return 0;\n  }\n  if (content_type.len >= 16 &&\n      !strncasecmp(\"application/json\", content_type.data, 16)) {\n    content_type = fiobj_obj2cstr(h->body);\n    if (h->params)\n      return -1;\n    if (fiobj_json2obj(&h->params, content_type.data, content_type.len) == 0)\n      return -1;\n    if (FIOBJ_TYPE_IS(h->params, FIOBJ_T_HASH))\n      return 0;\n    FIOBJ tmp = h->params;\n    FIOBJ key = fiobj_str_new(\"JSON\", 4);\n    h->params = fiobj_hash_new2(4);\n    fiobj_hash_set(h->params, key, tmp);\n    fiobj_free(key);\n    return 0;\n  }\n\n  http_fio_mime_s p = {.h = h};\n  if (http_mime_parser_init(&p.p, content_type.data, content_type.len))\n    return -1;\n  if (!h->params)\n    h->params = fiobj_hash_new();\n\n  do {\n    size_t cons = http_mime_parse(&p.p, p.buffer.data, p.buffer.len);\n    p.pos += cons;\n    p.buffer = fiobj_data_pread(h->body, p.pos, 4096);\n  } while (p.buffer.data && !p.p.done && !p.p.error);\n  fiobj_free(p.partial_name);\n  p.partial_name = FIOBJ_INVALID;\n  return 0;\n}\n\n/* *****************************************************************************\nHTTP Helper functions that could be used globally\n***************************************************************************** */\n\n/**\n * Returns a String object representing the unparsed HTTP request (HTTP\n * version is capped at HTTP/1.1). Mostly usable for proxy usage and\n * debugging.\n */\nFIOBJ http_req2str(http_s *h) {\n  if (HTTP_INVALID_HANDLE(h) || !fiobj_hash_count(h->headers))\n    return FIOBJ_INVALID;\n\n  struct header_writer_s w;\n  w.dest = fiobj_str_buf(0);\n  if (h->status_str) {\n    fiobj_str_join(w.dest, h->version);\n    fiobj_str_write(w.dest, \" \", 1);\n    fiobj_str_join(w.dest, fiobj_num_tmp(h->status));\n    fiobj_str_write(w.dest, \" \", 1);\n    fiobj_str_join(w.dest, h->status_str);\n    fiobj_str_write(w.dest, \"\\r\\n\", 2);\n  } else {\n    fiobj_str_join(w.dest, h->method);\n    fiobj_str_write(w.dest, \" \", 1);\n    fiobj_str_join(w.dest, h->path);\n    if (h->query) {\n      fiobj_str_write(w.dest, \"?\", 1);\n      fiobj_str_join(w.dest, h->query);\n    }\n    {\n      fio_str_info_s t = fiobj_obj2cstr(h->version);\n      if (t.len < 6 || t.data[5] != '1')\n        fiobj_str_write(w.dest, \" HTTP/1.1\\r\\n\", 10);\n      else {\n        fiobj_str_write(w.dest, \" \", 1);\n        fiobj_str_join(w.dest, h->version);\n        fiobj_str_write(w.dest, \"\\r\\n\", 2);\n      }\n    }\n  }\n\n  fiobj_each1(h->headers, 0, write_header, &w);\n  fiobj_str_write(w.dest, \"\\r\\n\", 2);\n  if (h->body) {\n    // fiobj_data_seek(h->body, 0);\n    // fio_str_info_s t = fiobj_data_read(h->body, 0);\n    // fiobj_str_write(w.dest, t.data, t.len);\n    fiobj_str_join(w.dest, h->body);\n  }\n  return w.dest;\n}\n\nvoid http_write_log(http_s *h) {\n  FIOBJ l = fiobj_str_buf(128);\n\n  intptr_t bytes_sent = fiobj_obj2num(fiobj_hash_get2(\n      h->private_data.out_headers, fiobj_obj2hash(HTTP_HEADER_CONTENT_LENGTH)));\n\n  struct timespec start, end;\n  clock_gettime(CLOCK_REALTIME, &end);\n  start = h->received_at;\n\n  {\n    // TODO Guess IP address from headers (forwarded) where possible\n    fio_str_info_s peer = fio_peer_addr(http2protocol(h)->uuid);\n    fiobj_str_write(l, peer.data, peer.len);\n  }\n  fio_str_info_s buff = fiobj_obj2cstr(l);\n\n  if (buff.len == 0) {\n    memcpy(buff.data, \"[unknown]\", 9);\n    buff.len = 9;\n  }\n  memcpy(buff.data + buff.len, \" - - [\", 6);\n  buff.len += 6;\n  fiobj_str_resize(l, buff.len);\n  {\n    FIOBJ date;\n    fio_lock(&date_lock);\n    date = fiobj_dup(current_date);\n    fio_unlock(&date_lock);\n    fiobj_str_join(l, current_date);\n    fiobj_free(date);\n  }\n  fiobj_str_write(l, \"] \\\"\", 3);\n  fiobj_str_join(l, h->method);\n  fiobj_str_write(l, \" \", 1);\n  fiobj_str_join(l, h->path);\n  fiobj_str_write(l, \" \", 1);\n  fiobj_str_join(l, h->version);\n  fiobj_str_write(l, \"\\\" \", 2);\n  if (bytes_sent > 0) {\n    fiobj_str_write_i(l, h->status);\n    fiobj_str_write(l, \" \", 1);\n    fiobj_str_write_i(l, bytes_sent);\n    fiobj_str_write(l, \"b \", 2);\n  } else {\n    fiobj_str_join(l, fiobj_num_tmp(h->status));\n    fiobj_str_write(l, \" -- \", 4);\n  }\n\n  bytes_sent = ((end.tv_sec - start.tv_sec) * 1000) +\n               ((end.tv_nsec - start.tv_nsec) / 1000000);\n  fiobj_str_write_i(l, bytes_sent);\n  fiobj_str_write(l, \"ms\\r\\n\", 4);\n\n  buff = fiobj_obj2cstr(l);\n  fwrite(buff.data, 1, buff.len, stderr);\n  fiobj_free(l);\n}\n\n/**\nA faster (yet less localized) alternative to `gmtime_r`.\n\nSee the libc `gmtime_r` documentation for details.\n\nFalls back to `gmtime_r` for dates before epoch.\n*/\nstruct tm *http_gmtime(time_t timer, struct tm *tmbuf) {\n  // static char* DAYS[] = {\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\",\n  // \"Sat\"}; static char * Months = {  \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\",\n  // \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\n  static const uint8_t month_len[] = {\n      31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, // nonleap year\n      31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31  // leap year\n  };\n  if (timer < 0)\n    return gmtime_r(&timer, tmbuf);\n  ssize_t a, b;\n#if HAVE_TM_TM_ZONE\n  *tmbuf = (struct tm){\n      .tm_isdst = 0,\n      .tm_year = 70, // tm_year == The number of years since 1900\n      .tm_mon = 0,\n      .tm_zone = \"UTC\",\n  };\n#else\n  *tmbuf = (struct tm){\n      .tm_isdst = 0,\n      .tm_year = 70, // tm_year == The number of years since 1900\n      .tm_mon = 0,\n  };\n#endif\n  // for seconds up to weekdays, we build up, as small values clean up\n  // larger values.\n  a = (ssize_t)timer;\n  b = a / 60;\n  tmbuf->tm_sec = a - (b * 60);\n  a = b / 60;\n  tmbuf->tm_min = b - (a * 60);\n  b = a / 24;\n  tmbuf->tm_hour = a - (b * 24);\n  // day of epoch was a thursday. Add + 4 so sunday == 0...\n  tmbuf->tm_wday = (b + 4) % 7;\n// tmp == number of days since epoch\n#define DAYS_PER_400_YEARS ((400 * 365) + 97)\n  while (b >= DAYS_PER_400_YEARS) {\n    tmbuf->tm_year += 400;\n    b -= DAYS_PER_400_YEARS;\n  }\n#undef DAYS_PER_400_YEARS\n#define DAYS_PER_100_YEARS ((100 * 365) + 24)\n  while (b >= DAYS_PER_100_YEARS) {\n    tmbuf->tm_year += 100;\n    b -= DAYS_PER_100_YEARS;\n    if (((tmbuf->tm_year / 100) & 3) ==\n        0) // leap century divisable by 400 => add leap\n      --b;\n  }\n#undef DAYS_PER_100_YEARS\n#define DAYS_PER_32_YEARS ((32 * 365) + 8)\n  while (b >= DAYS_PER_32_YEARS) {\n    tmbuf->tm_year += 32;\n    b -= DAYS_PER_32_YEARS;\n  }\n#undef DAYS_PER_32_YEARS\n#define DAYS_PER_8_YEARS ((8 * 365) + 2)\n  while (b >= DAYS_PER_8_YEARS) {\n    tmbuf->tm_year += 8;\n    b -= DAYS_PER_8_YEARS;\n  }\n#undef DAYS_PER_8_YEARS\n#define DAYS_PER_4_YEARS ((4 * 365) + 1)\n  while (b >= DAYS_PER_4_YEARS) {\n    tmbuf->tm_year += 4;\n    b -= DAYS_PER_4_YEARS;\n  }\n#undef DAYS_PER_4_YEARS\n  while (b >= 365) {\n    tmbuf->tm_year += 1;\n    b -= 365;\n    if ((tmbuf->tm_year & 3) == 0) { // leap year\n      if (b > 0) {\n        --b;\n        continue;\n      } else {\n        b += 365;\n        --tmbuf->tm_year;\n        break;\n      }\n    }\n  }\n  b++; /* day 1 of the year is 1, not 0. */\n  tmbuf->tm_yday = b;\n  if ((tmbuf->tm_year & 3) == 1) {\n    // regular year\n    for (size_t i = 0; i < 12; i++) {\n      if (b <= month_len[i])\n        break;\n      b -= month_len[i];\n      ++tmbuf->tm_mon;\n    }\n  } else {\n    // leap year\n    for (size_t i = 12; i < 24; i++) {\n      if (b <= month_len[i])\n        break;\n      b -= month_len[i];\n      ++tmbuf->tm_mon;\n    }\n  }\n  tmbuf->tm_mday = b;\n  return tmbuf;\n}\n\nstatic const char *DAY_NAMES[] = {\"Sun\", \"Mon\", \"Tue\", \"Wed\",\n                                  \"Thu\", \"Fri\", \"Sat\"};\nstatic const char *MONTH_NAMES[] = {\"Jan \", \"Feb \", \"Mar \", \"Apr \",\n                                    \"May \", \"Jun \", \"Jul \", \"Aug \",\n                                    \"Sep \", \"Oct \", \"Nov \", \"Dec \"};\nstatic const char *GMT_STR = \"GMT\";\n\nsize_t http_date2rfc7231(char *target, struct tm *tmbuf) {\n  /* note: day of month is always 2 digits */\n  char *pos = target;\n  uint16_t tmp;\n  pos[0] = DAY_NAMES[tmbuf->tm_wday][0];\n  pos[1] = DAY_NAMES[tmbuf->tm_wday][1];\n  pos[2] = DAY_NAMES[tmbuf->tm_wday][2];\n  pos[3] = ',';\n  pos[4] = ' ';\n  pos += 5;\n  tmp = tmbuf->tm_mday / 10;\n  pos[0] = '0' + tmp;\n  pos[1] = '0' + (tmbuf->tm_mday - (tmp * 10));\n  pos += 2;\n  *(pos++) = ' ';\n  pos[0] = MONTH_NAMES[tmbuf->tm_mon][0];\n  pos[1] = MONTH_NAMES[tmbuf->tm_mon][1];\n  pos[2] = MONTH_NAMES[tmbuf->tm_mon][2];\n  pos[3] = ' ';\n  pos += 4;\n  // write year.\n  pos += fio_ltoa(pos, tmbuf->tm_year + 1900, 10);\n  *(pos++) = ' ';\n  tmp = tmbuf->tm_hour / 10;\n  pos[0] = '0' + tmp;\n  pos[1] = '0' + (tmbuf->tm_hour - (tmp * 10));\n  pos[2] = ':';\n  tmp = tmbuf->tm_min / 10;\n  pos[3] = '0' + tmp;\n  pos[4] = '0' + (tmbuf->tm_min - (tmp * 10));\n  pos[5] = ':';\n  tmp = tmbuf->tm_sec / 10;\n  pos[6] = '0' + tmp;\n  pos[7] = '0' + (tmbuf->tm_sec - (tmp * 10));\n  pos += 8;\n  pos[0] = ' ';\n  pos[1] = GMT_STR[0];\n  pos[2] = GMT_STR[1];\n  pos[3] = GMT_STR[2];\n  pos[4] = 0;\n  pos += 4;\n  return pos - target;\n}\n\nsize_t http_date2str(char *target, struct tm *tmbuf);\n\nsize_t http_date2rfc2822(char *target, struct tm *tmbuf) {\n  /* note: day of month is either 1 or 2 digits */\n  char *pos = target;\n  uint16_t tmp;\n  pos[0] = DAY_NAMES[tmbuf->tm_wday][0];\n  pos[1] = DAY_NAMES[tmbuf->tm_wday][1];\n  pos[2] = DAY_NAMES[tmbuf->tm_wday][2];\n  pos[3] = ',';\n  pos[4] = ' ';\n  pos += 5;\n  if (tmbuf->tm_mday < 10) {\n    *pos = '0' + tmbuf->tm_mday;\n    ++pos;\n  } else {\n    tmp = tmbuf->tm_mday / 10;\n    pos[0] = '0' + tmp;\n    pos[1] = '0' + (tmbuf->tm_mday - (tmp * 10));\n    pos += 2;\n  }\n  *(pos++) = '-';\n  pos[0] = MONTH_NAMES[tmbuf->tm_mon][0];\n  pos[1] = MONTH_NAMES[tmbuf->tm_mon][1];\n  pos[2] = MONTH_NAMES[tmbuf->tm_mon][2];\n  pos += 3;\n  *(pos++) = '-';\n  // write year.\n  pos += fio_ltoa(pos, tmbuf->tm_year + 1900, 10);\n  *(pos++) = ' ';\n  tmp = tmbuf->tm_hour / 10;\n  pos[0] = '0' + tmp;\n  pos[1] = '0' + (tmbuf->tm_hour - (tmp * 10));\n  pos[2] = ':';\n  tmp = tmbuf->tm_min / 10;\n  pos[3] = '0' + tmp;\n  pos[4] = '0' + (tmbuf->tm_min - (tmp * 10));\n  pos[5] = ':';\n  tmp = tmbuf->tm_sec / 10;\n  pos[6] = '0' + tmp;\n  pos[7] = '0' + (tmbuf->tm_sec - (tmp * 10));\n  pos += 8;\n  pos[0] = ' ';\n  pos[1] = GMT_STR[0];\n  pos[2] = GMT_STR[1];\n  pos[3] = GMT_STR[2];\n  pos[4] = 0;\n  pos += 4;\n  return pos - target;\n}\n\n/* HTTP header format for Cookie ages */\nsize_t http_date2rfc2109(char *target, struct tm *tmbuf) {\n  /* note: day of month is always 2 digits */\n  char *pos = target;\n  uint16_t tmp;\n  pos[0] = DAY_NAMES[tmbuf->tm_wday][0];\n  pos[1] = DAY_NAMES[tmbuf->tm_wday][1];\n  pos[2] = DAY_NAMES[tmbuf->tm_wday][2];\n  pos[3] = ',';\n  pos[4] = ' ';\n  pos += 5;\n  tmp = tmbuf->tm_mday / 10;\n  pos[0] = '0' + tmp;\n  pos[1] = '0' + (tmbuf->tm_mday - (tmp * 10));\n  pos += 2;\n  *(pos++) = ' ';\n  pos[0] = MONTH_NAMES[tmbuf->tm_mon][0];\n  pos[1] = MONTH_NAMES[tmbuf->tm_mon][1];\n  pos[2] = MONTH_NAMES[tmbuf->tm_mon][2];\n  pos[3] = ' ';\n  pos += 4;\n  // write year.\n  pos += fio_ltoa(pos, tmbuf->tm_year + 1900, 10);\n  *(pos++) = ' ';\n  tmp = tmbuf->tm_hour / 10;\n  pos[0] = '0' + tmp;\n  pos[1] = '0' + (tmbuf->tm_hour - (tmp * 10));\n  pos[2] = ':';\n  tmp = tmbuf->tm_min / 10;\n  pos[3] = '0' + tmp;\n  pos[4] = '0' + (tmbuf->tm_min - (tmp * 10));\n  pos[5] = ':';\n  tmp = tmbuf->tm_sec / 10;\n  pos[6] = '0' + tmp;\n  pos[7] = '0' + (tmbuf->tm_sec - (tmp * 10));\n  pos += 8;\n  *pos++ = ' ';\n  *pos++ = '-';\n  *pos++ = '0';\n  *pos++ = '0';\n  *pos++ = '0';\n  *pos++ = '0';\n  *pos = 0;\n  return pos - target;\n}\n\n/**\n * Prints Unix time to a HTTP time formatted string.\n *\n * This variation implements cached results for faster processing, at the\n * price of a less accurate string.\n */\nsize_t http_time2str(char *target, const time_t t) {\n  /* pre-print time every 1 or 2 seconds or so. */\n  static __thread time_t cached_tick;\n  static __thread char cached_httpdate[48];\n  static __thread size_t cached_len;\n  time_t last_tick = fio_last_tick().tv_sec;\n  if ((t | 7) < last_tick) {\n    /* this is a custom time, not \"now\", pass through */\n    struct tm tm;\n    http_gmtime(t, &tm);\n    return http_date2str(target, &tm);\n  }\n  if (last_tick > cached_tick) {\n    struct tm tm;\n    cached_tick = last_tick; /* refresh every second */\n    http_gmtime(last_tick, &tm);\n    cached_len = http_date2str(cached_httpdate, &tm);\n  }\n  memcpy(target, cached_httpdate, cached_len);\n  return cached_len;\n}\n\n/* Credit to Jonathan Leffler for the idea of a unified conditional */\n#define hex_val(c)                                                             \\\n  (((c) >= '0' && (c) <= '9')                                                  \\\n       ? ((c)-48)                                                              \\\n       : (((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))            \\\n             ? (((c) | 32) - 87)                                               \\\n             : ({                                                              \\\n                 return -1;                                                    \\\n                 0;                                                            \\\n               }))\nstatic inline int hex2byte(uint8_t *dest, const uint8_t *source) {\n  if (source[0] >= '0' && source[0] <= '9')\n    *dest = (source[0] - '0');\n  else if ((source[0] >= 'a' && source[0] <= 'f') ||\n           (source[0] >= 'A' && source[0] <= 'F'))\n    *dest = (source[0] | 32) - 87;\n  else\n    return -1;\n  *dest <<= 4;\n  if (source[1] >= '0' && source[1] <= '9')\n    *dest |= (source[1] - '0');\n  else if ((source[1] >= 'a' && source[1] <= 'f') ||\n           (source[1] >= 'A' && source[1] <= 'F'))\n    *dest |= (source[1] | 32) - 87;\n  else\n    return -1;\n  return 0;\n}\n\nssize_t http_decode_url(char *dest, const char *url_data, size_t length) {\n  char *pos = dest;\n  const char *end = url_data + length;\n  while (url_data < end) {\n    if (*url_data == '+') {\n      // decode space\n      *(pos++) = ' ';\n      ++url_data;\n    } else if (*url_data == '%') {\n      // decode hex value\n      // this is a percent encoded value.\n      if (hex2byte((uint8_t *)pos, (uint8_t *)&url_data[1]))\n        return -1;\n      pos++;\n      url_data += 3;\n    } else\n      *(pos++) = *(url_data++);\n  }\n  *pos = 0;\n  return pos - dest;\n}\n\nssize_t http_decode_url_unsafe(char *dest, const char *url_data) {\n  char *pos = dest;\n  while (*url_data) {\n    if (*url_data == '+') {\n      // decode space\n      *(pos++) = ' ';\n      ++url_data;\n    } else if (*url_data == '%') {\n      // decode hex value\n      // this is a percent encoded value.\n      if (hex2byte((uint8_t *)pos, (uint8_t *)&url_data[1]))\n        return -1;\n      pos++;\n      url_data += 3;\n    } else\n      *(pos++) = *(url_data++);\n  }\n  *pos = 0;\n  return pos - dest;\n}\n\nssize_t http_decode_path(char *dest, const char *url_data, size_t length) {\n  char *pos = dest;\n  const char *end = url_data + length;\n  while (url_data < end) {\n    if (*url_data == '%') {\n      // decode hex value\n      // this is a percent encoded value.\n      if (hex2byte((uint8_t *)pos, (uint8_t *)&url_data[1]))\n        return -1;\n      pos++;\n      url_data += 3;\n    } else\n      *(pos++) = *(url_data++);\n  }\n  *pos = 0;\n  return pos - dest;\n}\n\nssize_t http_decode_path_unsafe(char *dest, const char *url_data) {\n  char *pos = dest;\n  while (*url_data) {\n    if (*url_data == '%') {\n      // decode hex value\n      // this is a percent encoded value.\n      if (hex2byte((uint8_t *)pos, (uint8_t *)&url_data[1]))\n        return -1;\n      pos++;\n      url_data += 3;\n    } else\n      *(pos++) = *(url_data++);\n  }\n  *pos = 0;\n  return pos - dest;\n}\n\n/* *****************************************************************************\nLookup Tables / functions\n***************************************************************************** */\n\n#define FIO_FORCE_MALLOC_TMP 1 /* use malloc for the mime registry */\n#define FIO_SET_NAME fio_mime_set\n#define FIO_SET_OBJ_TYPE FIOBJ\n#define FIO_SET_OBJ_COMPARE(o1, o2) (1)\n#define FIO_SET_OBJ_COPY(dest, o) (dest) = fiobj_dup((o))\n#define FIO_SET_OBJ_DESTROY(o) fiobj_free((o))\n\n#include <fio.h>\n\nstatic fio_mime_set_s fio_http_mime_types = FIO_SET_INIT;\n\n#define LONGEST_FILE_EXTENSION_LENGTH 15\n\n/** Registers a Mime-Type to be associated with the file extension. */\nvoid http_mimetype_register(char *file_ext, size_t file_ext_len,\n                            FIOBJ mime_type_str) {\n  uintptr_t hash = FIO_HASH_FN(file_ext, file_ext_len, 0, 0);\n  if (mime_type_str == FIOBJ_INVALID) {\n    fio_mime_set_remove(&fio_http_mime_types, hash, FIOBJ_INVALID, NULL);\n  } else {\n    FIOBJ old = FIOBJ_INVALID;\n    fio_mime_set_overwrite(&fio_http_mime_types, hash, mime_type_str, &old);\n    if (old != FIOBJ_INVALID) {\n      FIO_LOG_WARNING(\"mime-type collision: %.*s was %s, now %s\",\n                      (int)file_ext_len, file_ext, fiobj_obj2cstr(old).data,\n                      fiobj_obj2cstr(mime_type_str).data);\n      fiobj_free(old);\n    }\n    fiobj_free(mime_type_str); /* move ownership to the registry */\n  }\n}\n\n/** Registers a Mime-Type to be associated with the file extension. */\nvoid http_mimetype_stats(void) {\n  FIO_LOG_DEBUG(\"HTTP MIME hash storage count/capa: %zu / %zu\",\n                fio_mime_set_count(&fio_http_mime_types),\n                fio_mime_set_capa(&fio_http_mime_types));\n}\n\n/**\n * Finds the mime-type associated with the file extension.\n *  Remember to call `fiobj_free`.\n */\nFIOBJ http_mimetype_find(char *file_ext, size_t file_ext_len) {\n  uintptr_t hash = FIO_HASH_FN(file_ext, file_ext_len, 0, 0);\n  return fiobj_dup(\n      fio_mime_set_find(&fio_http_mime_types, hash, FIOBJ_INVALID));\n}\n\n/**\n * Finds the mime-type associated with the URL.\n *  Remember to call `fiobj_free`.\n */\nFIOBJ http_mimetype_find2(FIOBJ url) {\n  static __thread char buffer[LONGEST_FILE_EXTENSION_LENGTH + 1];\n  fio_str_info_s ext = {.data = NULL};\n  FIOBJ mimetype;\n  if (!url)\n    goto finish;\n  fio_str_info_s tmp = fiobj_obj2cstr(url);\n  uint8_t steps = 1;\n  while (tmp.len > steps || steps >= LONGEST_FILE_EXTENSION_LENGTH) {\n    switch (tmp.data[tmp.len - steps]) {\n    case '.':\n      --steps;\n      if (steps) {\n        ext.len = steps;\n        ext.data = buffer;\n        buffer[steps] = 0;\n        for (size_t i = 1; i <= steps; ++i) {\n          buffer[steps - i] = tolower(tmp.data[tmp.len - i]);\n        }\n      }\n    /* fallthrough */\n    case '/':\n      goto finish;\n      break;\n    }\n    ++steps;\n  }\nfinish:\n  mimetype = http_mimetype_find(ext.data, ext.len);\n  if (!mimetype)\n    mimetype = fiobj_dup(HTTP_HVALUE_CONTENT_TYPE_DEFAULT);\n  return mimetype;\n}\n\n/** Clears the Mime-Type registry (it will be empty afterthis call). */\nvoid http_mimetype_clear(void) {\n  fio_mime_set_free(&fio_http_mime_types);\n  fiobj_free(current_date);\n  current_date = FIOBJ_INVALID;\n  last_date_added = 0;\n}\n\n/**\n* Create with Ruby using:\n\na = []\n256.times {|i| a[i] = 1;}\n('a'.ord..'z'.ord).each {|i| a[i] = 0;}\n('A'.ord..'Z'.ord).each {|i| a[i] = 0;}\n('0'.ord..'9'.ord).each {|i| a[i] = 0;}\n\"!#$%&'*+-.^_`|~\".bytes.each {|i| a[i] = 0;}\np a; nil\n\"!#$%&'()*+-./:<=>?@[]^_`{|}~\".bytes.each {|i| a[i] = 0;} # for values\np a; nil\n*/\nstatic char invalid_cookie_name_char[256] = {\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n\nstatic char invalid_cookie_value_char[256] = {\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n\n// clang-format off\n#define HTTP_SET_STATUS_STR(status, str) [status-100] = { .data = (char *)(str), .len = (sizeof(str) - 1) }\n// clang-format on\n\n/** Returns the status as a C string struct */\nfio_str_info_s http_status2str(uintptr_t status) {\n  static const fio_str_info_s status2str[] = {\n      HTTP_SET_STATUS_STR(100, \"Continue\"),\n      HTTP_SET_STATUS_STR(101, \"Switching Protocols\"),\n      HTTP_SET_STATUS_STR(102, \"Processing\"),\n      HTTP_SET_STATUS_STR(103, \"Early Hints\"),\n      HTTP_SET_STATUS_STR(200, \"OK\"),\n      HTTP_SET_STATUS_STR(201, \"Created\"),\n      HTTP_SET_STATUS_STR(202, \"Accepted\"),\n      HTTP_SET_STATUS_STR(203, \"Non-Authoritative Information\"),\n      HTTP_SET_STATUS_STR(204, \"No Content\"),\n      HTTP_SET_STATUS_STR(205, \"Reset Content\"),\n      HTTP_SET_STATUS_STR(206, \"Partial Content\"),\n      HTTP_SET_STATUS_STR(207, \"Multi-Status\"),\n      HTTP_SET_STATUS_STR(208, \"Already Reported\"),\n      HTTP_SET_STATUS_STR(226, \"IM Used\"),\n      HTTP_SET_STATUS_STR(300, \"Multiple Choices\"),\n      HTTP_SET_STATUS_STR(301, \"Moved Permanently\"),\n      HTTP_SET_STATUS_STR(302, \"Found\"),\n      HTTP_SET_STATUS_STR(303, \"See Other\"),\n      HTTP_SET_STATUS_STR(304, \"Not Modified\"),\n      HTTP_SET_STATUS_STR(305, \"Use Proxy\"),\n      HTTP_SET_STATUS_STR(306, \"(Unused), \"),\n      HTTP_SET_STATUS_STR(307, \"Temporary Redirect\"),\n      HTTP_SET_STATUS_STR(308, \"Permanent Redirect\"),\n      HTTP_SET_STATUS_STR(400, \"Bad Request\"),\n      HTTP_SET_STATUS_STR(403, \"Forbidden\"),\n      HTTP_SET_STATUS_STR(404, \"Not Found\"),\n      HTTP_SET_STATUS_STR(401, \"Unauthorized\"),\n      HTTP_SET_STATUS_STR(402, \"Payment Required\"),\n      HTTP_SET_STATUS_STR(405, \"Method Not Allowed\"),\n      HTTP_SET_STATUS_STR(406, \"Not Acceptable\"),\n      HTTP_SET_STATUS_STR(407, \"Proxy Authentication Required\"),\n      HTTP_SET_STATUS_STR(408, \"Request Timeout\"),\n      HTTP_SET_STATUS_STR(409, \"Conflict\"),\n      HTTP_SET_STATUS_STR(410, \"Gone\"),\n      HTTP_SET_STATUS_STR(411, \"Length Required\"),\n      HTTP_SET_STATUS_STR(412, \"Precondition Failed\"),\n      HTTP_SET_STATUS_STR(413, \"Payload Too Large\"),\n      HTTP_SET_STATUS_STR(414, \"URI Too Long\"),\n      HTTP_SET_STATUS_STR(415, \"Unsupported Media Type\"),\n      HTTP_SET_STATUS_STR(416, \"Range Not Satisfiable\"),\n      HTTP_SET_STATUS_STR(417, \"Expectation Failed\"),\n      HTTP_SET_STATUS_STR(421, \"Misdirected Request\"),\n      HTTP_SET_STATUS_STR(422, \"Unprocessable Entity\"),\n      HTTP_SET_STATUS_STR(423, \"Locked\"),\n      HTTP_SET_STATUS_STR(424, \"Failed Dependency\"),\n      HTTP_SET_STATUS_STR(425, \"Unassigned\"),\n      HTTP_SET_STATUS_STR(426, \"Upgrade Required\"),\n      HTTP_SET_STATUS_STR(427, \"Unassigned\"),\n      HTTP_SET_STATUS_STR(428, \"Precondition Required\"),\n      HTTP_SET_STATUS_STR(429, \"Too Many Requests\"),\n      HTTP_SET_STATUS_STR(430, \"Unassigned\"),\n      HTTP_SET_STATUS_STR(431, \"Request Header Fields Too Large\"),\n      HTTP_SET_STATUS_STR(500, \"Internal Server Error\"),\n      HTTP_SET_STATUS_STR(501, \"Not Implemented\"),\n      HTTP_SET_STATUS_STR(502, \"Bad Gateway\"),\n      HTTP_SET_STATUS_STR(503, \"Service Unavailable\"),\n      HTTP_SET_STATUS_STR(504, \"Gateway Timeout\"),\n      HTTP_SET_STATUS_STR(505, \"HTTP Version Not Supported\"),\n      HTTP_SET_STATUS_STR(506, \"Variant Also Negotiates\"),\n      HTTP_SET_STATUS_STR(507, \"Insufficient Storage\"),\n      HTTP_SET_STATUS_STR(508, \"Loop Detected\"),\n      HTTP_SET_STATUS_STR(509, \"Unassigned\"),\n      HTTP_SET_STATUS_STR(510, \"Not Extended\"),\n      HTTP_SET_STATUS_STR(511, \"Network Authentication Required\"),\n  };\n  fio_str_info_s ret = (fio_str_info_s){.len = 0, .data = NULL};\n  if (status >= 100 &&\n      (status - 100) < sizeof(status2str) / sizeof(status2str[0]))\n    ret = status2str[status - 100];\n  if (!ret.data) {\n    ret = status2str[400];\n  }\n  return ret;\n}\n#undef HTTP_SET_STATUS_STR\n\n#if DEBUG\nvoid http_tests(void) {\n  fprintf(stderr, \"=== Testing HTTP helpers\\n\");\n  FIOBJ html_mime = http_mimetype_find(\"html\", 4);\n  FIO_ASSERT(html_mime,\n             \"HTML mime-type not found! Mime-Type registry invalid!\\n\");\n  fiobj_free(html_mime);\n}\n#endif\n", "#ifndef H_HTTP_H\n/*\nCopyright: Boaz Segev, 2016-2019\nLicense: MIT\n\nFeel free to copy, use and enjoy according to the license provided.\n*/\n#define H_HTTP_H\n\n#include <fio.h>\n\n#include <fiobj.h>\n\n#include <time.h>\n\n/* support C++ */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* *****************************************************************************\nCompile Time Settings\n***************************************************************************** */\n\n/** When a new connection is accepted, it will be immediately declined with a\n * 503 service unavailable (server busy) response unless the following number of\n * file descriptors is available.*/\n#ifndef HTTP_BUSY_UNLESS_HAS_FDS\n#define HTTP_BUSY_UNLESS_HAS_FDS 64\n#endif\n\n#ifndef HTTP_DEFAULT_BODY_LIMIT\n#define HTTP_DEFAULT_BODY_LIMIT (1024 * 1024 * 50)\n#endif\n\n#ifndef HTTP_MAX_HEADER_COUNT\n#define HTTP_MAX_HEADER_COUNT 128\n#endif\n\n#ifndef HTTP_MAX_HEADER_LENGTH\n/** the default maximum length for a single header line */\n#define HTTP_MAX_HEADER_LENGTH 8192\n#endif\n\n#ifndef FIO_HTTP_EXACT_LOGGING\n/**\n * By default, facil.io logs the HTTP request cycle using a fuzzy starting point\n * (a close enough timestamp).\n *\n * The fuzzy timestamp includes delays that aren't related to the HTTP request,\n * sometimes including time that was spent waiting on the client. On the other\n * hand, `FIO_HTTP_EXACT_LOGGING` excludes time that the client might have been\n * waiting for facil.io to read data from the network.\n *\n * Due to the preference to err on the side of causion, fuzzy time-stamping is\n * the default.\n */\n#define FIO_HTTP_EXACT_LOGGING 0\n#endif\n\n/** the `http_listen settings, see details in the struct definition. */\ntypedef struct http_settings_s http_settings_s;\n\n/* *****************************************************************************\nThe Request / Response type and functions\n***************************************************************************** */\n\n/**\n * A generic HTTP handle used for HTTP request/response data.\n *\n * The `http_s` data can only be accessed safely from within the `on_request`\n * HTTP callback OR an `http_defer` callback.\n */\ntypedef struct {\n  /** the HTTP request's \"head\" starts with a private data used by facil.io */\n  struct {\n    /** the function touting table - used by facil.io, don't use directly! */\n    void *vtbl;\n    /** the connection's owner / uuid - used by facil.io, don't use directly! */\n    uintptr_t flag;\n    /** The response headers, if they weren't sent. Don't access directly. */\n    FIOBJ out_headers;\n  } private_data;\n  /** a time merker indicating when the request was received. */\n  struct timespec received_at;\n  /** a String containing the method data (supports non-standard methods. */\n  FIOBJ method;\n  /** The status string, for response objects (client mode response). */\n  FIOBJ status_str;\n  /** The HTTP version string, if any. */\n  FIOBJ version;\n  /** The status used for the response (or if the object is a response).\n   *\n   * When sending a request, the status should be set to 0.\n   */\n  uintptr_t status;\n  /** The request path, if any. */\n  FIOBJ path;\n  /** The request query, if any. */\n  FIOBJ query;\n  /** a hash of general header data. When a header is set multiple times (such\n   * as cookie headers), an Array will be used instead of a String. */\n  FIOBJ headers;\n  /**\n   * a placeholder for a hash of cookie data.\n   * the hash will be initialized when parsing the request.\n   */\n  FIOBJ cookies;\n  /**\n   * a placeholder for a hash of request data.\n   * the hash will be initialized when parsing the request.\n   */\n  FIOBJ params;\n  /**\n   * a reader for body data (might be a temporary file or a string or NULL).\n   * see fiobj_data.h for details.\n   */\n  FIOBJ body;\n  /** an opaque user data pointer, to be used BEFORE calling `http_defer`. */\n  void *udata;\n} http_s;\n\n/**\n* This is a helper for setting cookie data.\n\nThis struct is used together with the `http_response_set_cookie`. i.e.:\n\n      http_response_set_cookie(response,\n        .name = \"my_cookie\",\n        .value = \"data\" );\n\n*/\ntypedef struct {\n  /** The cookie's name (Symbol). */\n  const char *name;\n  /** The cookie's value (leave blank to delete cookie). */\n  const char *value;\n  /** The cookie's domain (optional). */\n  const char *domain;\n  /** The cookie's path (optional). */\n  const char *path;\n  /** The cookie name's size in bytes or a terminating NUL will be assumed.*/\n  size_t name_len;\n  /** The cookie value's size in bytes or a terminating NUL will be assumed.*/\n  size_t value_len;\n  /** The cookie domain's size in bytes or a terminating NUL will be assumed.*/\n  size_t domain_len;\n  /** The cookie path's size in bytes or a terminating NULL will be assumed.*/\n  size_t path_len;\n  /** Max Age (how long should the cookie persist), in seconds (0 == session).*/\n  int max_age;\n  /** Limit cookie to secure connections.*/\n  unsigned secure : 1;\n  /** Limit cookie to HTTP (intended to prevent javascript access/hijacking).*/\n  unsigned http_only : 1;\n} http_cookie_args_s;\n\n/**\n * Sets a response header, taking ownership of the value object, but NOT the\n * name object (so name objects could be reused in future responses).\n *\n * Returns -1 on error and 0 on success.\n */\nint http_set_header(http_s *h, FIOBJ name, FIOBJ value);\n\n/**\n * Sets a response header.\n *\n * Returns -1 on error and 0 on success.\n */\nint http_set_header2(http_s *h, fio_str_info_s name, fio_str_info_s value);\n\n/**\n * Sets a response cookie.\n *\n * Returns -1 on error and 0 on success.\n *\n * Note: Long cookie names and long cookie values will be considered a security\n * violation and an error will be returned. It should be noted that most\n * proxies and servers will refuse long cookie names or values and many impose\n * total header lengths (including cookies) of ~8Kib.\n */\nint http_set_cookie(http_s *h, http_cookie_args_s);\n#define http_set_cookie(http___handle, ...)                                    \\\n  http_set_cookie((http___handle), (http_cookie_args_s){__VA_ARGS__})\n\n/**\n * Sends the response headers and body.\n *\n * **Note**: The body is *copied* to the HTTP stream and it's memory should be\n * freed by the calling function.\n *\n * Returns -1 on error and 0 on success.\n *\n * AFTER THIS FUNCTION IS CALLED, THE `http_s` OBJECT IS NO LONGER VALID.\n */\nint http_send_body(http_s *h, void *data, uintptr_t length);\n\n/**\n * Sends the response headers and the specified file (the response's body).\n *\n * The file is closed automatically.\n *\n * Returns -1 on error and 0 on success.\n *\n * AFTER THIS FUNCTION IS CALLED, THE `http_s` OBJECT IS NO LONGER VALID.\n */\nint http_sendfile(http_s *h, int fd, uintptr_t length, uintptr_t offset);\n\n/**\n * Sends the response headers and the specified file (the response's body).\n *\n * The `local` and `encoded` strings will be joined into a single string that\n * represent the file name. Either or both of these strings can be empty.\n *\n * The `encoded` string will be URL decoded while the `local` string will used\n * as is.\n *\n * Returns 0 on success. A success value WILL CONSUME the `http_s` handle (it\n * will become invalid).\n *\n * Returns -1 on error (The `http_s` handle should still be used).\n */\nint http_sendfile2(http_s *h, const char *prefix, size_t prefix_len,\n                   const char *encoded, size_t encoded_len);\n\n/**\n * Sends an HTTP error response.\n *\n * Returns -1 on error and 0 on success.\n *\n * AFTER THIS FUNCTION IS CALLED, THE `http_s` OBJECT IS NO LONGER VALID.\n *\n * The `uuid` and `settings` arguments are only required if the `http_s` handle\n * is NULL.\n */\nint http_send_error(http_s *h, size_t error_code);\n\n/**\n * Sends the response headers for a header only response.\n *\n * AFTER THIS FUNCTION IS CALLED, THE `http_s` OBJECT IS NO LONGER VALID.\n */\nvoid http_finish(http_s *h);\n\n/**\n * Pushes a data response when supported (HTTP/2 only).\n *\n * Returns -1 on error and 0 on success.\n */\nint http_push_data(http_s *h, void *data, uintptr_t length, FIOBJ mime_type);\n\n/**\n * Pushes a file response when supported (HTTP/2 only).\n *\n * If `mime_type` is NULL, an attempt at automatic detection using `filename`\n * will be made.\n *\n * Returns -1 on error and 0 on success.\n */\nint http_push_file(http_s *h, FIOBJ filename, FIOBJ mime_type);\n\n/* *****************************************************************************\nHTTP evented API (pause / resume HTTp handling)\n***************************************************************************** */\n\ntypedef struct http_pause_handle_s http_pause_handle_s;\n/**\n * Pauses the request / response handling and INVALIDATES the current `http_s`\n * handle (no `http` functions can be called).\n *\n * The `http_resume` function MUST be called (at some point) using the opaque\n * `http` pointer given to the callback `task`.\n *\n * The opaque `http` pointer is only valid for a single call to `http_resume`\n * and can't be used by any other `http` function (it's a different data type).\n *\n * Note: the current `http_s` handle will become invalid once this function is\n *    called and it's data might be deallocated, invalid or used by a different\n *    thread.\n */\nvoid http_pause(http_s *h, void (*task)(http_pause_handle_s *http));\n\n/**\n * Resumes a request / response handling within a task and INVALIDATES the\n * current `http_s` handle.\n *\n * The `task` MUST call one of the `http_send_*`, `http_finish`, or\n * `http_pause`functions.\n *\n * The (optional) `fallback` will receive the opaque `udata` that was stored in\n * the HTTP handle and can be used for cleanup.\n *\n * Note: `http_resume` can only be called after calling `http_pause` and\n * entering it's task.\n *\n * Note: the current `http_s` handle will become invalid once this function is\n *    called and it's data might be deallocated, invalidated or used by a\n *    different thread.\n */\nvoid http_resume(http_pause_handle_s *http, void (*task)(http_s *h),\n                 void (*fallback)(void *udata));\n\n/** Returns the `udata` associated with the paused opaque handle */\nvoid *http_paused_udata_get(http_pause_handle_s *http);\n\n/**\n * Sets the `udata` associated with the paused opaque handle, returning the\n * old value.\n */\nvoid *http_paused_udata_set(http_pause_handle_s *http, void *udata);\n\n/* *****************************************************************************\nHTTP Connections - Listening / Connecting / Hijacking\n***************************************************************************** */\n\n/** The HTTP settings. */\nstruct http_settings_s {\n  /** Callback for normal HTTP requests. */\n  void (*on_request)(http_s *request);\n  /**\n   * Callback for Upgrade and EventSource (SSE) requests.\n   *\n   * SSE/EventSource requests set the `requested_protocol` string to `\"sse\"`.\n   */\n  void (*on_upgrade)(http_s *request, char *requested_protocol, size_t len);\n  /** CLIENT REQUIRED: a callback for the HTTP response. */\n  void (*on_response)(http_s *response);\n  /** (optional) the callback to be performed when the HTTP service closes. */\n  void (*on_finish)(struct http_settings_s *settings);\n  /** Opaque user data. Facil.io will ignore this field, but you can use it. */\n  void *udata;\n  /**\n   * A public folder for file transfers - allows to circumvent any application\n   * layer logic and simply serve static files.\n   *\n   * Supports automatic `gz` pre-compressed alternatives.\n   */\n  const char *public_folder;\n  /**\n   * The length of the public_folder string.\n   */\n  size_t public_folder_length;\n  /**\n   * The maximum number of bytes allowed for the request string (method, path,\n   * query), header names and fields.\n   *\n   * Defaults to 32Kib (which is about 4 times more than I would recommend).\n   *\n   * This reflects the total overall size. On HTTP/1.1, each header line (name +\n   * value pair) is also limitied to a hardcoded HTTP_MAX_HEADER_LENGTH bytes.\n   */\n  size_t max_header_size;\n  /**\n   * The maximum size of an HTTP request's body (posting / downloading).\n   *\n   * Defaults to ~ 50Mb.\n   */\n  size_t max_body_size;\n  /**\n   * The maximum number of clients that are allowed to connect concurrently.\n   *\n   * This value's default setting is usually for the best.\n   *\n   * The default value is computed according to the server's capacity, leaving\n   * some breathing room for other network and disk operations.\n   *\n   * Note: clients, by the nature of socket programming, are counted according\n   *       to their internal file descriptor (`fd`) value. Open files and other\n   *       sockets count towards a server's limit.\n   */\n  intptr_t max_clients;\n  /** reserved for future SSL/TLS support. */\n  void *tls;\n  /** reserved for future use. */\n  intptr_t reserved1;\n  /** reserved for future use. */\n  intptr_t reserved2;\n  /** reserved for future use. */\n  intptr_t reserved3;\n  /**\n   * The maximum websocket message size/buffer (in bytes) for Websocket\n   * connections. Defaults to ~250KB.\n   */\n  size_t ws_max_msg_size;\n  /**\n   * An HTTP/1.x connection timeout.\n   *\n   * `http_listen` defaults to ~40s and `http_connect` defaults to ~30s.\n   *\n   * Note: the connection might be closed (by other side) before timeout occurs.\n   */\n  uint8_t timeout;\n  /**\n   * Timeout for the websocket connections, a ping will be sent whenever the\n   * timeout is reached. Defaults to 40 seconds.\n   *\n   * Connections are only closed when a ping cannot be sent (the network layer\n   * fails). Pongs are ignored.\n   */\n  uint8_t ws_timeout;\n  /** Logging flag - set to TRUE to log HTTP requests. */\n  uint8_t log;\n  /** a read only flag set automatically to indicate the protocol's mode. */\n  uint8_t is_client;\n};\n\n/**\n * Listens to HTTP connections at the specified `port`.\n *\n * Leave as NULL to ignore IP binding.\n *\n * Returns -1 on error and the socket's uuid on success.\n *\n * the `on_finish` callback is always called.\n */\nintptr_t http_listen(const char *port, const char *binding,\n                     struct http_settings_s);\n/** Listens to HTTP connections at the specified `port` and `binding`. */\n#define http_listen(port, binding, ...)                                        \\\n  http_listen((port), (binding), (struct http_settings_s){__VA_ARGS__})\n\n/**\n * Connects to an HTTP server as a client.\n *\n * Upon a successful connection, the `on_response` callback is called with an\n * empty `http_s*` handler (status == 0). Use the same API to set it's content\n * and send the request to the server. The next`on_response` will contain the\n * response.\n *\n * `address` should contain a full URL style address for the server. i.e.:\n *\n *           \"http:/www.example.com:8080/\"\n *\n * If an `address` includes a path or query data, they will be automatically\n * attached (both of them) to the HTTP handl'es `path` property. i.e.\n *\n *           \"http:/www.example.com:8080/my_path?foo=bar\"\n *           // will result in:\n *           fiobj_obj2cstr(h->path).data; //=> \"/my_path?foo=bar\"\n *\n * To open a Websocket connection, it's possible to use the `ws` protocol\n * signature. However, it would be better to use the `websocket_connect`\n * function instead.\n *\n * Returns -1 on error and the socket's uuid on success.\n *\n * The `on_finish` callback is always called.\n */\nintptr_t http_connect(const char *url, const char *unix_address,\n                      struct http_settings_s);\n#define http_connect(url, unix_address, ...)                                   \\\n  http_connect((url), (unix_address), (struct http_settings_s){__VA_ARGS__})\n\n/**\n * Returns the settings used to setup the connection or NULL on error.\n */\nstruct http_settings_s *http_settings(http_s *h);\n\n/**\n * Returns the direct address of the connected peer (likely an intermediary).\n */\nfio_str_info_s http_peer_addr(http_s *h);\n\n/**\n * Hijacks the socket away from the HTTP protocol and away from facil.io.\n *\n * It's possible to hijack the socket and than reconnect it to a new protocol\n * object.\n *\n * It's possible to call `http_finish` immediately after calling `http_hijack`\n * in order to send the outgoing headers.\n *\n * If any additional HTTP functions are called after the hijacking, the protocol\n * object might attempt to continue reading data from the buffer.\n *\n * Returns the underlining socket connection's uuid. If `leftover` isn't NULL,\n * it will be populated with any remaining data in the HTTP buffer (the data\n * will be automatically deallocated, so copy the data when in need).\n *\n * WARNING: this isn't a good way to handle HTTP connections, especially as\n * HTTP/2 enters the picture.\n */\nintptr_t http_hijack(http_s *h, fio_str_info_s *leftover);\n\n/* *****************************************************************************\nWebsocket Upgrade (Server and Client connection establishment)\n***************************************************************************** */\n\n/**\n * The type for a Websocket handle, used to identify a Websocket connection.\n *\n * Similar to an `http_s` handle, it is only valid within the scope of the\n * specific connection (the callbacks / tasks) and shouldn't be stored or\n * accessed otherwise.\n */\ntypedef struct ws_s ws_s;\n\n/**\n * This struct is used for the named arguments in the `http_upgrade2ws`\n * function and macro.\n */\ntypedef struct {\n  /**\n   * The (optional) on_message callback will be called whenever a websocket\n   * message is received for this connection.\n   *\n   * The data received points to the websocket's message buffer and it will be\n   * overwritten once the function exits (it cannot be saved for later, but it\n   * can be copied).\n   */\n  void (*on_message)(ws_s *ws, fio_str_info_s msg, uint8_t is_text);\n  /**\n   * The (optional) on_open callback will be called once the websocket\n   * connection is established and before is is registered with `facil`, so no\n   * `on_message` events are raised before `on_open` returns.\n   */\n  void (*on_open)(ws_s *ws);\n  /**\n   * The (optional) on_ready callback will be after a the underlying socket's\n   * buffer changes it's state from full to empty.\n   *\n   * If the socket's buffer is never used, the callback is never called.\n   */\n  void (*on_ready)(ws_s *ws);\n  /**\n   * The (optional) on_shutdown callback will be called if a websocket\n   * connection is still open while the server is shutting down (called before\n   * `on_close`).\n   */\n  void (*on_shutdown)(ws_s *ws);\n  /**\n   * The (optional) on_close callback will be called once a websocket connection\n   * is terminated or failed to be established.\n   *\n   * The `uuid` is the connection's unique ID that can identify the Websocket. A\n   * value of `uuid == 0` indicates the Websocket connection wasn't established\n   * (an error occurred).\n   *\n   * The `udata` is the user data as set during the upgrade or using the\n   * `websocket_udata_set` function.\n   */\n  void (*on_close)(intptr_t uuid, void *udata);\n  /** Opaque user data. */\n  void *udata;\n} websocket_settings_s;\n\n/**\n * Upgrades an HTTP/1.1 connection to a Websocket connection.\n *\n * This function will end the HTTP stage of the connection and attempt to\n * \"upgrade\" to a Websockets connection.\n *\n * Thie `http_s` handle will be invalid after this call and the `udata` will be\n * set to the new Websocket `udata`.\n *\n * A client connection's `on_finish` callback will be called (since the HTTP\n * stage has finished).\n */\nint http_upgrade2ws(http_s *http, websocket_settings_s);\n\n/** This macro allows easy access to the `http_upgrade2ws` function. The macro\n * allows the use of named arguments, using the `websocket_settings_s` struct\n * members. i.e.:\n *\n *     on_message(ws_s * ws, char * data, size_t size, int is_text) {\n *        ; // ... this is the websocket on_message callback\n *        websocket_write(ws, data, size, is_text); // a simple echo example\n *     }\n *\n *     on_upgrade(http_s* h) {\n *        http_upgrade2ws( .http = h, .on_message = on_message);\n *     }\n */\n#define http_upgrade2ws(http, ...)                                             \\\n  http_upgrade2ws((http), (websocket_settings_s){__VA_ARGS__})\n\n/**\n * Connects to a Websocket service according to the provided address.\n *\n * This is a somewhat naive connector object, it doesn't perform any\n * authentication or other logical handling. However, it's quire easy to author\n * a complext authentication logic using a combination of `http_connect` and\n * `http_upgrade2ws`.\n *\n * Returns the uuid for the future websocket on success.\n *\n * Returns -1 on error;\n */\nint websocket_connect(const char *url, websocket_settings_s settings);\n#define websocket_connect(url, ...)                                            \\\n  websocket_connect((url), (websocket_settings_s){__VA_ARGS__})\n\n#include <websockets.h>\n\n/* *****************************************************************************\nEventSource Support (SSE)\n***************************************************************************** */\n\n/**\n * The type for the EventSource (SSE) handle, used to identify an SSE\n * connection.\n */\ntypedef struct http_sse_s http_sse_s;\n\n/**\n * This struct is used for the named arguments in the `http_upgrade2sse`\n * function and macro.\n */\nstruct http_sse_s {\n  /**\n   * The (optional) on_open callback will be called once the EventSource\n   * connection is established.\n   */\n  void (*on_open)(http_sse_s *sse);\n  /**\n   * The (optional) on_ready callback will be after a the underlying socket's\n   * buffer changes it's state to empty.\n   *\n   * If the socket's buffer is never used, the callback is never called.\n   */\n  void (*on_ready)(http_sse_s *sse);\n  /**\n   * The (optional) on_shutdown callback will be called if a connection is still\n   * open while the server is shutting down (called before `on_close`).\n   */\n  void (*on_shutdown)(http_sse_s *sse);\n  /**\n   * The (optional) on_close callback will be called once a connection is\n   * terminated or failed to be established.\n   *\n   * The `udata` passed to the `http_upgrade2sse` function is available\n   * through the `http_sse_s` pointer (`sse->udata`).\n   */\n  void (*on_close)(http_sse_s *sse);\n  /** Opaque user data. */\n  void *udata;\n};\n\n/**\n * Upgrades an HTTP connection to an EventSource (SSE) connection.\n *\n * The `http_s` handle will be invalid after this call.\n *\n * On HTTP/1.1 connections, this will preclude future requests using the same\n * connection.\n */\nint http_upgrade2sse(http_s *h, http_sse_s);\n\n/** This macro allows easy access to the `http_upgrade2sse` function. The macro\n * allows the use of named arguments, using the `websocket_settings_s` struct\n * members. i.e.:\n *\n *     on_open_sse(sse_s * sse) {\n *        http_sse_subscribe(sse, .channel = CHANNEL_NAME);\n *     }\n *\n *     on_upgrade(http_s* h) {\n *        http_upgrade2sse(h, .on_open = on_open_sse);\n *     }\n */\n#define http_upgrade2sse(h, ...)                                               \\\n  http_upgrade2sse((h), (http_sse_s){__VA_ARGS__})\n\n/**\n * Sets the ping interval for SSE connections.\n */\nvoid http_sse_set_timout(http_sse_s *sse, uint8_t timeout);\n\nstruct http_sse_subscribe_args {\n  /** The channel name used for the subscription. */\n  fio_str_info_s channel;\n  /** The optional on message callback. If missing, Data is directly writen. */\n  void (*on_message)(http_sse_s *sse, fio_str_info_s channel,\n                     fio_str_info_s msg, void *udata);\n  /** An optional callback for when a subscription is fully canceled. */\n  void (*on_unsubscribe)(void *udata);\n  /** Opaque user */\n  void *udata;\n  /** A callback for pattern matching. */\n  fio_match_fn match;\n};\n\n/**\n * Subscribes to a channel for direct message deliverance. See {struct\n * http_sse_subscribe_args} for possible arguments.\n *\n * Returns a subscription ID on success and 0 on failure.\n *\n * To unsubscripbe from the channel, use `http_sse_unsubscribe` (NOT\n * `fio_unsubscribe`).\n *\n * All subscriptions are automatically cleared once the connection is closed.\n */\nuintptr_t http_sse_subscribe(http_sse_s *sse,\n                             struct http_sse_subscribe_args args);\n\n/** This macro allows easy access to the `http_sse_subscribe` function. */\n#define http_sse_subscribe(sse, ...)                                           \\\n  http_sse_subscribe((sse), (struct http_sse_subscribe_args){__VA_ARGS__})\n\n/**\n * Cancels a subscription and invalidates the subscription object.\n */\nvoid http_sse_unsubscribe(http_sse_s *sse, uintptr_t subscription);\n\n/**\n * Named arguments for the {http_sse_write} function.\n *\n * These arguments list the possible fields for the SSE event.\n *\n * Event fields listed here:\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events\n */\nstruct http_sse_write_args {\n  fio_str_info_s id;    /* (optional) sets the `id` event property. */\n  fio_str_info_s event; /* (optional) sets the `event` event property. */\n  fio_str_info_s data;  /* (optional) sets the `data` event property. */\n  intptr_t retry;       /* (optional) sets the `retry` event property. */\n};\n\n/**\n * Writes data to an EventSource (SSE) connection.\n *\n * See the {struct http_sse_write_args} for possible named arguments.\n */\nint http_sse_write(http_sse_s *sse, struct http_sse_write_args);\n#define http_sse_write(sse, ...)                                               \\\n  http_sse_write((sse), (struct http_sse_write_args){__VA_ARGS__})\n\n/**\n * Get the connection's UUID (for `fio_defer_io_task`, pub/sub, etc').\n */\nintptr_t http_sse2uuid(http_sse_s *sse);\n\n/**\n * Closes an EventSource (SSE) connection.\n */\nint http_sse_close(http_sse_s *sse);\n\n/**\n * Duplicates an SSE handle by reference, remember to http_sse_free.\n *\n * Returns the same object (increases a reference count, no allocation is made).\n */\nhttp_sse_s *http_sse_dup(http_sse_s *sse);\n\n/**\n * Frees an SSE handle by reference (decreases the reference count).\n */\nvoid http_sse_free(http_sse_s *sse);\n\n/* *****************************************************************************\nHTTP GET and POST parsing helpers\n***************************************************************************** */\n\n/**\n * Attempts to decode the request's body.\n *\n * Supported Types include:\n * * application/x-www-form-urlencoded\n * * application/json\n * * multipart/form-data\n *\n * This should be called before `http_parse_query`, in order to support JSON\n * data.\n *\n * If the JSON data isn't an object, it will be saved under the key \"JSON\" in\n * the `params` hash.\n *\n * If the `multipart/form-data` type contains JSON files, they will NOT be\n * parsed (they will behave like any other file, with `data`, `type` and\n * `filename` keys assigned). This allows non-object JSON data (such as array)\n * to be handled by the app.\n */\nint http_parse_body(http_s *h);\n\n/**\n * Parses the query part of an HTTP request/response. Uses `http_add2hash`.\n *\n * This should be called after the `http_parse_body` function, just in case the\n * body is JSON that doesn't have an object at it's root.\n */\nvoid http_parse_query(http_s *h);\n\n/** Parses any Cookie / Set-Cookie headers, using the `http_add2hash` scheme. */\nvoid http_parse_cookies(http_s *h, uint8_t is_url_encoded);\n\n/**\n * Adds a named parameter to the hash, converting a string to an object and\n * resolving nesting references and URL decoding if required.\n *\n * i.e.:\n *\n * * \"name[]\" references a nested Array (nested in the Hash).\n * * \"name[key]\" references a nested Hash.\n * * \"name[][key]\" references a nested Hash within an array. Hash keys will be\n *   unique (repeating a key advances the hash).\n * * These rules can be nested (i.e. \"name[][key1][][key2]...\")\n * * \"name[][]\" is an error (there's no way for the parser to analyze\n *    dimensions)\n *\n * Note: names can't begin with \"[\" or end with \"]\" as these are reserved\n *       characters.\n */\nint http_add2hash(FIOBJ dest, char *name, size_t name_len, char *value,\n                  size_t value_len, uint8_t encoded);\n\n/**\n * Adds a named parameter to the hash, using an existing object and resolving\n * nesting references.\n *\n * i.e.:\n *\n * * \"name[]\" references a nested Array (nested in the Hash).\n * * \"name[key]\" references a nested Hash.\n * * \"name[][key]\" references a nested Hash within an array. Hash keys will be\n *   unique (repeating a key advances the array).\n * * These rules can be nested (i.e. \"name[][key1][][key2]...\")\n * * \"name[][]\" is an error (there's no way for the parser to analyze\n *    dimensions)\n *\n * Note: names can't begin with \"[\" or end with \"]\" as these are reserved\n *       characters.\n */\nint http_add2hash2(FIOBJ dest, char *name, size_t name_len, FIOBJ value,\n                   uint8_t encoded);\n\n/* *****************************************************************************\nHTTP Status Strings and Mime-Type helpers\n***************************************************************************** */\n\n/** Returns a human readable string related to the HTTP status number. */\nfio_str_info_s http_status2str(uintptr_t status);\n\n/** Registers a Mime-Type to be associated with the file extension. */\nvoid http_mimetype_register(char *file_ext, size_t file_ext_len,\n                            FIOBJ mime_type_str);\n\n/**\n * Finds the mime-type associated with the file extension, returning a String on\n * success and FIOBJ_INVALID on failure.\n *\n * Remember to call `fiobj_free`.\n */\nFIOBJ http_mimetype_find(char *file_ext, size_t file_ext_len);\n\n/**\n * Returns the mime-type associated with the URL or the default mime-type for\n * HTTP.\n *\n * Remember to call `fiobj_free`.\n */\nFIOBJ http_mimetype_find2(FIOBJ url);\n\n/** Clears the Mime-Type registry (it will be empty after this call). */\nvoid http_mimetype_clear(void);\n\n/* *****************************************************************************\nCommonly used headers (fiobj Symbol objects)\n***************************************************************************** */\n\nextern FIOBJ HTTP_HEADER_ACCEPT;\nextern FIOBJ HTTP_HEADER_CACHE_CONTROL;\nextern FIOBJ HTTP_HEADER_CONNECTION;\nextern FIOBJ HTTP_HEADER_CONTENT_ENCODING;\nextern FIOBJ HTTP_HEADER_CONTENT_LENGTH;\nextern FIOBJ HTTP_HEADER_CONTENT_RANGE;\nextern FIOBJ HTTP_HEADER_CONTENT_TYPE;\nextern FIOBJ HTTP_HEADER_COOKIE;\nextern FIOBJ HTTP_HEADER_DATE;\nextern FIOBJ HTTP_HEADER_ETAG;\nextern FIOBJ HTTP_HEADER_HOST;\nextern FIOBJ HTTP_HEADER_LAST_MODIFIED;\nextern FIOBJ HTTP_HEADER_ORIGIN;\nextern FIOBJ HTTP_HEADER_SET_COOKIE;\nextern FIOBJ HTTP_HEADER_UPGRADE;\n\n/* *****************************************************************************\nHTTP General Helper functions that could be used globally\n***************************************************************************** */\n\n/**\n * Returns a String object representing the unparsed HTTP request (HTTP version\n * is capped at HTTP/1.1). Mostly usable for proxy usage and debugging.\n */\nFIOBJ http_req2str(http_s *h);\n\n/**\n * Writes a log line to `stderr` about the request / response object.\n *\n * This function is called automatically if the `.log` setting is enabled.\n */\nvoid http_write_log(http_s *h);\n/* *****************************************************************************\nHTTP Time related helper functions that could be used globally\n***************************************************************************** */\n\n/**\nA faster (yet less localized) alternative to `gmtime_r`.\n\nSee the libc `gmtime_r` documentation for details.\n\nFalls back to `gmtime_r` for dates before epoch.\n*/\nstruct tm *http_gmtime(time_t timer, struct tm *tmbuf);\n\n/** Writes an RFC 7231 date representation (HTTP date format) to target. */\nsize_t http_date2rfc7231(char *target, struct tm *tmbuf);\n/** Writes an RFC 2109 date representation to target. */\nsize_t http_date2rfc2109(char *target, struct tm *tmbuf);\n/** Writes an RFC 2822 date representation to target. */\nsize_t http_date2rfc2822(char *target, struct tm *tmbuf);\n/**\nWrites an HTTP date string to the `target` buffer.\n\nThis requires ~32 bytes of space to be available at the target buffer (unless\nit's a super funky year, 32 bytes is about 3 more than you need).\n\nReturns the number of bytes actually written.\n*/\nstatic inline size_t http_date2str(char *target, struct tm *tmbuf) {\n  return http_date2rfc7231(target, tmbuf);\n}\n\n/**\n * Prints Unix time to a HTTP time formatted string.\n *\n * This variation implements cached results for faster processing, at the\n * price of a less accurate string.\n */\nsize_t http_time2str(char *target, const time_t t);\n\n/* *****************************************************************************\nHTTP URL decoding helper functions that might be used globally\n***************************************************************************** */\n\n/** Decodes a URL encoded string, no buffer overflow protection. */\nssize_t http_decode_url_unsafe(char *dest, const char *url_data);\n\n/** Decodes a URL encoded string (query / form data). */\nssize_t http_decode_url(char *dest, const char *url_data, size_t length);\n\n/** Decodes the \"path\" part of a request, no buffer overflow protection. */\nssize_t http_decode_path_unsafe(char *dest, const char *url_data);\n\n/**\n * Decodes the \"path\" part of an HTTP request, no buffer overflow protection.\n */\nssize_t http_decode_path(char *dest, const char *url_data, size_t length);\n\n/* *****************************************************************************\nHTTP URL parsing\n***************************************************************************** */\n\n/** the result returned by `http_url_parse` */\ntypedef fio_url_s http_url_s\n    __attribute__((deprecated(\"use fio_url_s instead\")));\n\n/**\n * Parses the URI returning it's components and their lengths (no decoding\n * performed, doesn't accept decoded URIs).\n *\n * The returned string are NOT NUL terminated, they are merely locations within\n * the original string.\n *\n * This function expects any of the following formats:\n *\n * * `/complete_path?query#target`\n *\n *   i.e.: /index.html?page=1#list\n *\n * * `host:port/complete_path?query#target`\n *\n *   i.e.:\n *      example.com\n *      example.com/index.html\n *      example.com:8080/index.html\n *      example.com:8080/index.html?key=val#target\n *\n * * `user:password@host:port/path?query#target`\n *\n *   i.e.: user:1234@example.com:8080/index.html\n *\n * * `schema://user:password@host:port/path?query#target`\n *\n *   i.e.: http://example.com/index.html?page=1#list\n *\n * Invalid formats might produce unexpected results. No error testing performed.\n */\n#define http_url_parse(url, len) fio_url_parse((url), (len))\n\n#if DEBUG\nvoid http_tests(void);\n#endif\n\n/* support C++ */\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* H_HTTP_H */\n", "/*\nCopyright: Boaz Segev, 2017-2019\nLicense: MIT\n*/\n#include <fio.h>\n\n#include <http1.h>\n#include <http1_parser.h>\n#include <http_internal.h>\n#include <websockets.h>\n\n#include <fiobj.h>\n\n#include <assert.h>\n#include <stddef.h>\n\n/* *****************************************************************************\nThe HTTP/1.1 Protocol Object\n***************************************************************************** */\n\ntypedef struct http1pr_s {\n  http_fio_protocol_s p;\n  http1_parser_s parser;\n  http_s request;\n  uintptr_t buf_len;\n  uintptr_t max_header_size;\n  uintptr_t header_size;\n  uint8_t close;\n  uint8_t is_client;\n  uint8_t stop;\n  uint8_t buf[];\n} http1pr_s;\n\nstruct http_vtable_s HTTP1_VTABLE; /* initialized later on */\n\n/* *****************************************************************************\nInternal Helpers\n***************************************************************************** */\n\n#define parser2http(x)                                                         \\\n  ((http1pr_s *)((uintptr_t)(x) - (uintptr_t)(&((http1pr_s *)0)->parser)))\n\ninline static void h1_reset(http1pr_s *p) { p->header_size = 0; }\n\n#define http1_pr2handle(pr) (((http1pr_s *)(pr))->request)\n#define handle2pr(h) ((http1pr_s *)h->private_data.flag)\n\nstatic fio_str_info_s http1pr_status2str(uintptr_t status);\n\n/* cleanup an HTTP/1.1 handler object */\nstatic inline void http1_after_finish(http_s *h) {\n  http1pr_s *p = handle2pr(h);\n  p->stop = p->stop & (~1UL);\n  if (h != &p->request) {\n    http_s_destroy(h, 0);\n    fio_free(h);\n  } else {\n    http_s_clear(h, p->p.settings->log);\n  }\n  if (p->close)\n    fio_close(p->p.uuid);\n}\n\n/* *****************************************************************************\nHTTP Request / Response (Virtual) Functions\n***************************************************************************** */\nstruct header_writer_s {\n  FIOBJ dest;\n  FIOBJ name;\n  FIOBJ value;\n};\n\nstatic int write_header(FIOBJ o, void *w_) {\n  struct header_writer_s *w = w_;\n  if (!o)\n    return 0;\n  if (fiobj_hash_key_in_loop()) {\n    w->name = fiobj_hash_key_in_loop();\n  }\n  if (FIOBJ_TYPE_IS(o, FIOBJ_T_ARRAY)) {\n    fiobj_each1(o, 0, write_header, w);\n    return 0;\n  }\n  fio_str_info_s name = fiobj_obj2cstr(w->name);\n  fio_str_info_s str = fiobj_obj2cstr(o);\n  if (!str.data)\n    return 0;\n  // fiobj_str_capa_assert(w->dest,\n  //                       fiobj_obj2cstr(w->dest).len + name.len + str.len +\n  //                       5);\n  fiobj_str_write(w->dest, name.data, name.len);\n  fiobj_str_write(w->dest, \":\", 1);\n  fiobj_str_write(w->dest, str.data, str.len);\n  fiobj_str_write(w->dest, \"\\r\\n\", 2);\n  return 0;\n}\n\nstatic FIOBJ headers2str(http_s *h, uintptr_t padding) {\n  if (!h->method && !!h->status_str)\n    return FIOBJ_INVALID;\n\n  static uintptr_t connection_hash;\n  if (!connection_hash)\n    connection_hash = fiobj_hash_string(\"connection\", 10);\n\n  struct header_writer_s w;\n  {\n    const uintptr_t header_length_guess =\n        fiobj_hash_count(h->private_data.out_headers) * 64;\n    w.dest = fiobj_str_buf(header_length_guess + padding);\n  }\n  http1pr_s *p = handle2pr(h);\n\n  if (p->is_client == 0) {\n    fio_str_info_s t = http1pr_status2str(h->status);\n    fiobj_str_write(w.dest, t.data, t.len);\n    FIOBJ tmp = fiobj_hash_get2(h->private_data.out_headers, connection_hash);\n    if (tmp) {\n      t = fiobj_obj2cstr(tmp);\n      if (t.data[0] == 'c' || t.data[0] == 'C')\n        p->close = 1;\n    } else {\n      tmp = fiobj_hash_get2(h->headers, connection_hash);\n      if (tmp) {\n        t = fiobj_obj2cstr(tmp);\n        if (!t.data || !t.len || t.data[0] == 'k' || t.data[0] == 'K')\n          fiobj_str_write(w.dest, \"connection:keep-alive\\r\\n\", 23);\n        else {\n          fiobj_str_write(w.dest, \"connection:close\\r\\n\", 18);\n          p->close = 1;\n        }\n      } else {\n        t = fiobj_obj2cstr(h->version);\n        if (!p->close && t.len > 7 && t.data && t.data[5] == '1' &&\n            t.data[6] == '.' && t.data[7] == '1')\n          fiobj_str_write(w.dest, \"connection:keep-alive\\r\\n\", 23);\n        else {\n          fiobj_str_write(w.dest, \"connection:close\\r\\n\", 18);\n          p->close = 1;\n        }\n      }\n    }\n  } else {\n    if (h->method) {\n      fiobj_str_join(w.dest, h->method);\n      fiobj_str_write(w.dest, \" \", 1);\n    } else {\n      fiobj_str_write(w.dest, \"GET \", 4);\n    }\n    fiobj_str_join(w.dest, h->path);\n    if (h->query) {\n      fiobj_str_write(w.dest, \"?\", 1);\n      fiobj_str_join(w.dest, h->query);\n    }\n    fiobj_str_write(w.dest, \" HTTP/1.1\\r\\n\", 11);\n    /* make sure we have a host header? */\n    static uint64_t host_hash;\n    if (!host_hash)\n      host_hash = fiobj_hash_string(\"host\", 4);\n    FIOBJ tmp;\n    if (!fiobj_hash_get2(h->private_data.out_headers, host_hash) &&\n        (tmp = fiobj_hash_get2(h->headers, host_hash))) {\n      fiobj_str_write(w.dest, \"host:\", 5);\n      fiobj_str_join(w.dest, tmp);\n      fiobj_str_write(w.dest, \"\\r\\n\", 2);\n    }\n    if (!fiobj_hash_get2(h->private_data.out_headers, connection_hash))\n      fiobj_str_write(w.dest, \"connection:keep-alive\\r\\n\", 23);\n  }\n\n  fiobj_each1(h->private_data.out_headers, 0, write_header, &w);\n  fiobj_str_write(w.dest, \"\\r\\n\", 2);\n  return w.dest;\n}\n\n/** Should send existing headers and data */\nstatic int http1_send_body(http_s *h, void *data, uintptr_t length) {\n\n  FIOBJ packet = headers2str(h, length);\n  if (!packet) {\n    http1_after_finish(h);\n    return -1;\n  }\n  fiobj_str_write(packet, data, length);\n  fiobj_send_free((handle2pr(h)->p.uuid), packet);\n  http1_after_finish(h);\n  return 0;\n}\n/** Should send existing headers and file */\nstatic int http1_sendfile(http_s *h, int fd, uintptr_t length,\n                          uintptr_t offset) {\n  FIOBJ packet = headers2str(h, 0);\n  if (!packet) {\n    close(fd);\n    http1_after_finish(h);\n    return -1;\n  }\n  if (length < HTTP_MAX_HEADER_LENGTH) {\n    /* optimize away small files */\n    fio_str_info_s s = fiobj_obj2cstr(packet);\n    fiobj_str_capa_assert(packet, s.len + length);\n    s = fiobj_obj2cstr(packet);\n    intptr_t i = pread(fd, s.data + s.len, length, offset);\n    if (i < 0) {\n      close(fd);\n      fiobj_send_free((handle2pr(h)->p.uuid), packet);\n      fio_close((handle2pr(h)->p.uuid));\n      return -1;\n    }\n    close(fd);\n    fiobj_str_resize(packet, s.len + i);\n    fiobj_send_free((handle2pr(h)->p.uuid), packet);\n    http1_after_finish(h);\n    return 0;\n  }\n  fiobj_send_free((handle2pr(h)->p.uuid), packet);\n  fio_sendfile((handle2pr(h)->p.uuid), fd, offset, length);\n  http1_after_finish(h);\n  return 0;\n}\n\n/** Should send existing headers or complete streaming */\nstatic void htt1p_finish(http_s *h) {\n  FIOBJ packet = headers2str(h, 0);\n  if (packet)\n    fiobj_send_free((handle2pr(h)->p.uuid), packet);\n  else {\n    // fprintf(stderr, \"WARNING: invalid call to `htt1p_finish`\\n\");\n  }\n  http1_after_finish(h);\n}\n/** Push for data - unsupported. */\nstatic int http1_push_data(http_s *h, void *data, uintptr_t length,\n                           FIOBJ mime_type) {\n  return -1;\n  (void)h;\n  (void)data;\n  (void)length;\n  (void)mime_type;\n}\n/** Push for files - unsupported. */\nstatic int http1_push_file(http_s *h, FIOBJ filename, FIOBJ mime_type) {\n  return -1;\n  (void)h;\n  (void)filename;\n  (void)mime_type;\n}\n\n/**\n * Called befor a pause task,\n */\nstatic void http1_on_pause(http_s *h, http_fio_protocol_s *pr) {\n  ((http1pr_s *)pr)->stop = 1;\n  fio_suspend(pr->uuid);\n  (void)h;\n}\n\n/**\n * called after the resume task had completed.\n */\nstatic void http1_on_resume(http_s *h, http_fio_protocol_s *pr) {\n  if (!((http1pr_s *)pr)->stop) {\n    fio_force_event(pr->uuid, FIO_EVENT_ON_DATA);\n  }\n  (void)h;\n}\n\nstatic intptr_t http1_hijack(http_s *h, fio_str_info_s *leftover) {\n  if (leftover) {\n    intptr_t len =\n        handle2pr(h)->buf_len -\n        (intptr_t)(handle2pr(h)->parser.state.next - handle2pr(h)->buf);\n    if (len) {\n      *leftover = (fio_str_info_s){\n          .len = len, .data = (char *)handle2pr(h)->parser.state.next};\n    } else {\n      *leftover = (fio_str_info_s){.len = 0, .data = NULL};\n    }\n  }\n\n  handle2pr(h)->stop = 3;\n  intptr_t uuid = handle2pr(h)->p.uuid;\n  fio_attach(uuid, NULL);\n  return uuid;\n}\n\n/* *****************************************************************************\nWebsockets Upgrading\n***************************************************************************** */\n\nstatic void http1_websocket_client_on_upgrade(http_s *h, char *proto,\n                                              size_t len) {\n  http1pr_s *p = handle2pr(h);\n  websocket_settings_s *args = h->udata;\n  const intptr_t uuid = handle2pr(h)->p.uuid;\n  http_settings_s *set = handle2pr(h)->p.settings;\n  set->udata = NULL;\n  http_finish(h);\n  p->stop = 1;\n  websocket_attach(uuid, set, args, p->parser.state.next,\n                   p->buf_len - (intptr_t)(p->parser.state.next - p->buf));\n  fio_free(args);\n  (void)proto;\n  (void)len;\n}\nstatic void http1_websocket_client_on_failed(http_s *h) {\n  websocket_settings_s *s = h->udata;\n  if (s->on_close)\n    s->on_close(0, s->udata);\n  fio_free(h->udata);\n  h->udata = http_settings(h)->udata = NULL;\n}\nstatic void http1_websocket_client_on_hangup(http_settings_s *settings) {\n  websocket_settings_s *s = settings->udata;\n  if (s) {\n    if (s->on_close)\n      s->on_close(0, s->udata);\n    fio_free(settings->udata);\n    settings->udata = NULL;\n  }\n}\n\nstatic int http1_http2websocket_server(http_s *h, websocket_settings_s *args) {\n  // A static data used for all websocket connections.\n  static char ws_key_accpt_str[] = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n  static uintptr_t sec_version = 0;\n  static uintptr_t sec_key = 0;\n  if (!sec_version)\n    sec_version = fiobj_hash_string(\"sec-websocket-version\", 21);\n  if (!sec_key)\n    sec_key = fiobj_hash_string(\"sec-websocket-key\", 17);\n\n  FIOBJ tmp = fiobj_hash_get2(h->headers, sec_version);\n  if (!tmp)\n    goto bad_request;\n  fio_str_info_s stmp = fiobj_obj2cstr(tmp);\n  if (stmp.len != 2 || stmp.data[0] != '1' || stmp.data[1] != '3')\n    goto bad_request;\n\n  tmp = fiobj_hash_get2(h->headers, sec_key);\n  if (!tmp)\n    goto bad_request;\n  stmp = fiobj_obj2cstr(tmp);\n\n  fio_sha1_s sha1 = fio_sha1_init();\n  fio_sha1_write(&sha1, stmp.data, stmp.len);\n  fio_sha1_write(&sha1, ws_key_accpt_str, sizeof(ws_key_accpt_str) - 1);\n  tmp = fiobj_str_buf(32);\n  stmp = fiobj_obj2cstr(tmp);\n  fiobj_str_resize(tmp,\n                   fio_base64_encode(stmp.data, fio_sha1_result(&sha1), 20));\n  http_set_header(h, HTTP_HEADER_CONNECTION, fiobj_dup(HTTP_HVALUE_WS_UPGRADE));\n  http_set_header(h, HTTP_HEADER_UPGRADE, fiobj_dup(HTTP_HVALUE_WEBSOCKET));\n  http_set_header(h, HTTP_HEADER_WS_SEC_KEY, tmp);\n  h->status = 101;\n  http1pr_s *pr = handle2pr(h);\n  const intptr_t uuid = handle2pr(h)->p.uuid;\n  http_settings_s *set = handle2pr(h)->p.settings;\n  http_finish(h);\n  pr->stop = 1;\n  websocket_attach(uuid, set, args, pr->parser.state.next,\n                   pr->buf_len - (intptr_t)(pr->parser.state.next - pr->buf));\n  return 0;\nbad_request:\n  http_send_error(h, 400);\n  if (args->on_close)\n    args->on_close(0, args->udata);\n  return -1;\n}\n\nstatic int http1_http2websocket_client(http_s *h, websocket_settings_s *args) {\n  http1pr_s *p = handle2pr(h);\n  /* We're done with the HTTP stage, so we call the `on_finish` */\n  if (p->p.settings->on_finish)\n    p->p.settings->on_finish(p->p.settings);\n  /* Copy the Websocket setting arguments to the HTTP settings `udata` */\n  p->p.settings->udata = fio_malloc(sizeof(*args));\n  ((websocket_settings_s *)(p->p.settings->udata))[0] = *args;\n  /* Set callbacks */\n  p->p.settings->on_finish = http1_websocket_client_on_hangup;   /* unknown */\n  p->p.settings->on_upgrade = http1_websocket_client_on_upgrade; /* sucess */\n  p->p.settings->on_response = http1_websocket_client_on_failed; /* failed */\n  p->p.settings->on_request = http1_websocket_client_on_failed;  /* failed */\n  /* Set headers */\n  http_set_header(h, HTTP_HEADER_CONNECTION, fiobj_dup(HTTP_HVALUE_WS_UPGRADE));\n  http_set_header(h, HTTP_HEADER_UPGRADE, fiobj_dup(HTTP_HVALUE_WEBSOCKET));\n  http_set_header(h, HTTP_HVALUE_WS_SEC_VERSION,\n                  fiobj_dup(HTTP_HVALUE_WS_VERSION));\n\n  /* we don't set the Origin header since we're not a browser... should we? */\n  // http_set_header(\n  //     h, HTTP_HEADER_ORIGIN,\n  //     fiobj_dup(fiobj_hash_get2(h->private_data.out_headers,\n  //                               fiobj_obj2hash(HTTP_HEADER_HOST))));\n\n  /* create nonce */\n  uint64_t key[2]; /* 16 bytes */\n  key[0] = (uintptr_t)h ^ (uint64_t)fio_last_tick().tv_sec;\n  key[1] = (uintptr_t)args->udata ^ (uint64_t)fio_last_tick().tv_nsec;\n  FIOBJ encoded = fiobj_str_buf(26); /* we need 24 really. */\n  fio_str_info_s tmp = fiobj_obj2cstr(encoded);\n  tmp.len = fio_base64_encode(tmp.data, (char *)key, 16);\n  fiobj_str_resize(encoded, tmp.len);\n  http_set_header(h, HTTP_HEADER_WS_SEC_CLIENT_KEY, encoded);\n  http_finish(h);\n  return 0;\n}\n\nstatic int http1_http2websocket(http_s *h, websocket_settings_s *args) {\n  assert(h);\n  http1pr_s *p = handle2pr(h);\n\n  if (p->is_client == 0) {\n    return http1_http2websocket_server(h, args);\n  }\n  return http1_http2websocket_client(h, args);\n}\n\n/* *****************************************************************************\nEventSource Support (SSE)\n***************************************************************************** */\n\n#undef http_upgrade2sse\n\ntypedef struct {\n  fio_protocol_s p;\n  http_sse_internal_s *sse;\n} http1_sse_fio_protocol_s;\n\nstatic void http1_sse_on_ready(intptr_t uuid, fio_protocol_s *p_) {\n  http1_sse_fio_protocol_s *p = (http1_sse_fio_protocol_s *)p_;\n  if (p->sse->sse.on_ready)\n    p->sse->sse.on_ready(&p->sse->sse);\n  (void)uuid;\n}\nstatic uint8_t http1_sse_on_shutdown(intptr_t uuid, fio_protocol_s *p_) {\n  http1_sse_fio_protocol_s *p = (http1_sse_fio_protocol_s *)p_;\n  if (p->sse->sse.on_shutdown)\n    p->sse->sse.on_shutdown(&p->sse->sse);\n  return 0;\n  (void)uuid;\n}\nstatic void http1_sse_on_close(intptr_t uuid, fio_protocol_s *p_) {\n  http1_sse_fio_protocol_s *p = (http1_sse_fio_protocol_s *)p_;\n  http_sse_destroy(p->sse);\n  fio_free(p);\n  (void)uuid;\n}\nstatic void http1_sse_ping(intptr_t uuid, fio_protocol_s *p_) {\n  fio_write2(uuid, .data.buffer = \": ping\\n\\n\", .length = 8,\n             .after.dealloc = FIO_DEALLOC_NOOP);\n  (void)p_;\n}\n\n/**\n * Upgrades an HTTP connection to an EventSource (SSE) connection.\n *\n * Thie `http_s` handle will be invalid after this call.\n *\n * On HTTP/1.1 connections, this will preclude future requests using the same\n * connection.\n */\nstatic int http1_upgrade2sse(http_s *h, http_sse_s *sse) {\n  const intptr_t uuid = handle2pr(h)->p.uuid;\n  /* send response */\n  h->status = 200;\n  http_set_header(h, HTTP_HEADER_CONTENT_TYPE, fiobj_dup(HTTP_HVALUE_SSE_MIME));\n  http_set_header(h, HTTP_HEADER_CACHE_CONTROL,\n                  fiobj_dup(HTTP_HVALUE_NO_CACHE));\n  http_set_header(h, HTTP_HEADER_CONTENT_ENCODING,\n                  fiobj_str_new(\"identity\", 8));\n  handle2pr(h)->stop = 1;\n  htt1p_finish(h); /* avoid the enforced content length in http_finish */\n\n  /* switch protocol to SSE */\n  http1_sse_fio_protocol_s *sse_pr = fio_malloc(sizeof(*sse_pr));\n  if (!sse_pr)\n    goto failed;\n  *sse_pr = (http1_sse_fio_protocol_s){\n      .p =\n          {\n              .on_ready = http1_sse_on_ready,\n              .on_shutdown = http1_sse_on_shutdown,\n              .on_close = http1_sse_on_close,\n              .ping = http1_sse_ping,\n          },\n      .sse = fio_malloc(sizeof(*(sse_pr->sse))),\n  };\n\n  if (!sse_pr->sse)\n    goto failed;\n\n  http_sse_init(sse_pr->sse, uuid, &HTTP1_VTABLE, sse);\n  fio_timeout_set(uuid, handle2pr(h)->p.settings->ws_timeout);\n  if (sse->on_open)\n    sse->on_open(&sse_pr->sse->sse);\n  fio_attach(uuid, &sse_pr->p);\n  return 0;\n\nfailed:\n  fio_close(handle2pr(h)->p.uuid);\n  if (sse->on_close)\n    sse->on_close(sse);\n  return -1;\n  (void)sse;\n}\n\n#undef http_sse_write\n/**\n * Writes data to an EventSource (SSE) connection.\n *\n * See the {struct http_sse_write_args} for possible named arguments.\n */\nstatic int http1_sse_write(http_sse_s *sse, FIOBJ str) {\n  return fiobj_send_free(((http_sse_internal_s *)sse)->uuid, str);\n}\n\n/**\n * Closes an EventSource (SSE) connection.\n */\nstatic int http1_sse_close(http_sse_s *sse) {\n  fio_close(((http_sse_internal_s *)sse)->uuid);\n  return 0;\n}\n/* *****************************************************************************\nVirtual Table Decleration\n***************************************************************************** */\n\nstruct http_vtable_s HTTP1_VTABLE = {\n    .http_send_body = http1_send_body,\n    .http_sendfile = http1_sendfile,\n    .http_finish = htt1p_finish,\n    .http_push_data = http1_push_data,\n    .http_push_file = http1_push_file,\n    .http_on_pause = http1_on_pause,\n    .http_on_resume = http1_on_resume,\n    .http_hijack = http1_hijack,\n    .http2websocket = http1_http2websocket,\n    .http_upgrade2sse = http1_upgrade2sse,\n    .http_sse_write = http1_sse_write,\n    .http_sse_close = http1_sse_close,\n};\n\nvoid *http1_vtable(void) { return (void *)&HTTP1_VTABLE; }\n\n/* *****************************************************************************\nParser Callbacks\n***************************************************************************** */\n\n/** called when a request was received. */\nstatic int http1_on_request(http1_parser_s *parser) {\n  http1pr_s *p = parser2http(parser);\n  http_on_request_handler______internal(&http1_pr2handle(p), p->p.settings);\n  if (p->request.method && !p->stop)\n    http_finish(&p->request);\n  h1_reset(p);\n  return !p->close && fio_is_closed(p->p.uuid);\n}\n/** called when a response was received. */\nstatic int http1_on_response(http1_parser_s *parser) {\n  http1pr_s *p = parser2http(parser);\n  http_on_response_handler______internal(&http1_pr2handle(p), p->p.settings);\n  if (p->request.status_str && !p->stop)\n    http_finish(&p->request);\n  h1_reset(p);\n  return !p->close && fio_is_closed(p->p.uuid);\n}\n/** called when a request method is parsed. */\nstatic int http1_on_method(http1_parser_s *parser, char *method,\n                           size_t method_len) {\n  http1_pr2handle(parser2http(parser)).method =\n      fiobj_str_new(method, method_len);\n  parser2http(parser)->header_size += method_len;\n  return 0;\n}\n\n/** called when a response status is parsed. the status_str is the string\n * without the prefixed numerical status indicator.*/\nstatic int http1_on_status(http1_parser_s *parser, size_t status,\n                           char *status_str, size_t len) {\n  http1_pr2handle(parser2http(parser)).status_str =\n      fiobj_str_new(status_str, len);\n  http1_pr2handle(parser2http(parser)).status = status;\n  parser2http(parser)->header_size += len;\n  return 0;\n}\n\n/** called when a request path (excluding query) is parsed. */\nstatic int http1_on_path(http1_parser_s *parser, char *path, size_t len) {\n  http1_pr2handle(parser2http(parser)).path = fiobj_str_new(path, len);\n  parser2http(parser)->header_size += len;\n  return 0;\n}\n\n/** called when a request path (excluding query) is parsed. */\nstatic int http1_on_query(http1_parser_s *parser, char *query, size_t len) {\n  http1_pr2handle(parser2http(parser)).query = fiobj_str_new(query, len);\n  parser2http(parser)->header_size += len;\n  return 0;\n}\n/** called when a the HTTP/1.x version is parsed. */\nstatic int http1_on_http_version(http1_parser_s *parser, char *version,\n                                 size_t len) {\n  http1_pr2handle(parser2http(parser)).version = fiobj_str_new(version, len);\n  parser2http(parser)->header_size += len;\n/* start counting - occurs on the first line of both requests and responses */\n#if FIO_HTTP_EXACT_LOGGING\n  clock_gettime(CLOCK_REALTIME,\n                &http1_pr2handle(parser2http(parser)).received_at);\n#else\n  http1_pr2handle(parser2http(parser)).received_at = fio_last_tick();\n#endif\n  return 0;\n}\n/** called when a header is parsed. */\nstatic int http1_on_header(http1_parser_s *parser, char *name, size_t name_len,\n                           char *data, size_t data_len) {\n  FIOBJ sym;\n  FIOBJ obj;\n  if (!http1_pr2handle(parser2http(parser)).headers) {\n    FIO_LOG_ERROR(\"(http1 parse ordering error) missing HashMap for header \"\n                  \"%s: %s\",\n                  name, data);\n    http_send_error2(500, parser2http(parser)->p.uuid,\n                     parser2http(parser)->p.settings);\n    return -1;\n  }\n  parser2http(parser)->header_size += name_len + data_len;\n  if (parser2http(parser)->header_size >=\n          parser2http(parser)->max_header_size ||\n      fiobj_hash_count(http1_pr2handle(parser2http(parser)).headers) >\n          HTTP_MAX_HEADER_COUNT) {\n    if (parser2http(parser)->p.settings->log) {\n      FIO_LOG_WARNING(\"(HTTP) security alert - header flood detected.\");\n    }\n    http_send_error(&http1_pr2handle(parser2http(parser)), 413);\n    return -1;\n  }\n  sym = fiobj_str_new(name, name_len);\n  obj = fiobj_str_new(data, data_len);\n  set_header_add(http1_pr2handle(parser2http(parser)).headers, sym, obj);\n  fiobj_free(sym);\n  return 0;\n}\n/** called when a body chunk is parsed. */\nstatic int http1_on_body_chunk(http1_parser_s *parser, char *data,\n                               size_t data_len) {\n  if (parser->state.content_length >\n          (ssize_t)parser2http(parser)->p.settings->max_body_size ||\n      parser->state.read >\n          (ssize_t)parser2http(parser)->p.settings->max_body_size) {\n    http_send_error(&http1_pr2handle(parser2http(parser)), 413);\n    return -1; /* test every time, in case of chunked data */\n  }\n  if (!parser->state.read) {\n    if (parser->state.content_length > 0 &&\n        parser->state.content_length <= HTTP_MAX_HEADER_LENGTH) {\n      http1_pr2handle(parser2http(parser)).body = fiobj_data_newstr();\n    } else {\n      http1_pr2handle(parser2http(parser)).body = fiobj_data_newtmpfile();\n    }\n  }\n  fiobj_data_write(http1_pr2handle(parser2http(parser)).body, data, data_len);\n  return 0;\n}\n\n/** called when a protocol error occurred. */\nstatic int http1_on_error(http1_parser_s *parser) {\n  FIO_LOG_DEBUG(\"HTTP parser error at HTTP/1.1 buffer position %zu/%zu\",\n                parser->state.next - parser2http(parser)->buf,\n                parser2http(parser)->buf_len);\n  fio_close(parser2http(parser)->p.uuid);\n  return -1;\n}\n\n/* *****************************************************************************\nConnection Callbacks\n***************************************************************************** */\n\nstatic inline void http1_consume_data(intptr_t uuid, http1pr_s *p) {\n  if (fio_pending(uuid) > 4) {\n    goto throttle;\n  }\n  ssize_t i = 0;\n  size_t org_len = p->buf_len;\n  int pipeline_limit = 8;\n  if (!p->buf_len)\n    return;\n  do {\n    i = http1_fio_parser(.parser = &p->parser,\n                         .buffer = p->buf + (org_len - p->buf_len),\n                         .length = p->buf_len, .on_request = http1_on_request,\n                         .on_response = http1_on_response,\n                         .on_method = http1_on_method,\n                         .on_status = http1_on_status, .on_path = http1_on_path,\n                         .on_query = http1_on_query,\n                         .on_http_version = http1_on_http_version,\n                         .on_header = http1_on_header,\n                         .on_body_chunk = http1_on_body_chunk,\n                         .on_error = http1_on_error);\n    p->buf_len -= i;\n    --pipeline_limit;\n  } while (i && p->buf_len && pipeline_limit && !p->stop);\n\n  if (p->buf_len && org_len != p->buf_len) {\n    memmove(p->buf, p->buf + (org_len - p->buf_len), p->buf_len);\n  }\n\n  if (p->buf_len == HTTP_MAX_HEADER_LENGTH) {\n    /* no room to read... parser not consuming data */\n    if (p->request.method)\n      http_send_error(&p->request, 413);\n    else {\n      p->request.method = fiobj_str_tmp();\n      http_send_error(&p->request, 413);\n    }\n  }\n\n  if (!pipeline_limit) {\n    fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  }\n  return;\n\nthrottle:\n  /* throttle busy clients (slowloris) */\n  fio_suspend(uuid);\n  p->stop |= 4;\n  FIO_LOG_DEBUG(\"(HTTP/1,1) throttling client at %.*s\",\n                (int)fio_peer_addr(uuid).len, fio_peer_addr(uuid).data);\n}\n\n/** called when a data is available, but will not run concurrently */\nstatic void http1_on_data(intptr_t uuid, fio_protocol_s *protocol) {\n  http1pr_s *p = (http1pr_s *)protocol;\n  if (p->stop) {\n    fio_suspend(uuid);\n    return;\n  }\n  ssize_t i = 0;\n  if (HTTP_MAX_HEADER_LENGTH - p->buf_len)\n    i = fio_read(uuid, p->buf + p->buf_len,\n                 HTTP_MAX_HEADER_LENGTH - p->buf_len);\n  if (i > 0) {\n    p->buf_len += i;\n  }\n  http1_consume_data(uuid, p);\n}\n\n/** called when the connection was closed, but will not run concurrently */\nstatic void http1_on_close(intptr_t uuid, fio_protocol_s *protocol) {\n  http1_destroy(protocol);\n  (void)uuid;\n}\n\n/** called when the connection was closed, but will not run concurrently */\nstatic void http1_on_ready(intptr_t uuid, fio_protocol_s *protocol) {\n  /* resume slow clients from suspension */\n  http1pr_s *p = (http1pr_s *)protocol;\n  if ((p->stop & 4)) {\n    p->stop ^= 4;\n    fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  }\n  (void)protocol;\n}\n\n/** called when a data is available for the first time */\nstatic void http1_on_data_first_time(intptr_t uuid, fio_protocol_s *protocol) {\n  http1pr_s *p = (http1pr_s *)protocol;\n  ssize_t i;\n\n  i = fio_read(uuid, p->buf + p->buf_len, HTTP_MAX_HEADER_LENGTH - p->buf_len);\n\n  if (i <= 0)\n    return;\n  p->buf_len += i;\n\n  /* ensure future reads skip this first time HTTP/2.0 test */\n  p->p.protocol.on_data = http1_on_data;\n  /* Test fot HTTP/2.0 pre-knowledge */\n  if (i >= 24 && !memcmp(p->buf, \"PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n\", 24)) {\n    FIO_LOG_WARNING(\"client claimed unsupported HTTP/2 prior knowledge.\");\n    fio_close(uuid);\n    return;\n  }\n\n  /* Finish handling the same way as the normal `on_data` */\n  http1_consume_data(uuid, p);\n}\n\n/* *****************************************************************************\nPublic API\n***************************************************************************** */\n\n/** Creates an HTTP1 protocol object and handles any unread data in the buffer\n * (if any). */\nfio_protocol_s *http1_new(uintptr_t uuid, http_settings_s *settings,\n                          void *unread_data, size_t unread_length) {\n  if (unread_data && unread_length > HTTP_MAX_HEADER_LENGTH)\n    return NULL;\n  http1pr_s *p = fio_malloc(sizeof(*p) + HTTP_MAX_HEADER_LENGTH);\n  // FIO_LOG_DEBUG(\"Allocated HTTP/1.1 protocol at. %p\", (void *)p);\n  FIO_ASSERT_ALLOC(p);\n  *p = (http1pr_s){\n      .p.protocol =\n          {\n              .on_data = http1_on_data_first_time,\n              .on_close = http1_on_close,\n              .on_ready = http1_on_ready,\n          },\n      .p.uuid = uuid,\n      .p.settings = settings,\n      .max_header_size = settings->max_header_size,\n      .is_client = settings->is_client,\n  };\n  http_s_new(&p->request, &p->p, &HTTP1_VTABLE);\n  if (unread_data && unread_length <= HTTP_MAX_HEADER_LENGTH) {\n    memcpy(p->buf, unread_data, unread_length);\n    p->buf_len = unread_length;\n  }\n  fio_attach(uuid, &p->p.protocol);\n  if (unread_data && unread_length <= HTTP_MAX_HEADER_LENGTH) {\n    fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  }\n  return &p->p.protocol;\n}\n\n/** Manually destroys the HTTP1 protocol object. */\nvoid http1_destroy(fio_protocol_s *pr) {\n  http1pr_s *p = (http1pr_s *)pr;\n  http1_pr2handle(p).status = 0;\n  http_s_destroy(&http1_pr2handle(p), 0);\n  fio_free(p);\n  // FIO_LOG_DEBUG(\"Deallocated HTTP/1.1 protocol at. %p\", (void *)p);\n}\n\n/* *****************************************************************************\nProtocol Data\n***************************************************************************** */\n\n// clang-format off\n#define HTTP_SET_STATUS_STR(status, str) [((status)-100)] = { .data = (char*)(\"HTTP/1.1 \" #status \" \" str \"\\r\\n\"), .len = (sizeof(\"HTTP/1.1 \" #status \" \" str \"\\r\\n\") - 1) }\n// #undef HTTP_SET_STATUS_STR\n// clang-format on\n\nstatic fio_str_info_s http1pr_status2str(uintptr_t status) {\n  static fio_str_info_s status2str[] = {\n      HTTP_SET_STATUS_STR(100, \"Continue\"),\n      HTTP_SET_STATUS_STR(101, \"Switching Protocols\"),\n      HTTP_SET_STATUS_STR(102, \"Processing\"),\n      HTTP_SET_STATUS_STR(103, \"Early Hints\"),\n      HTTP_SET_STATUS_STR(200, \"OK\"),\n      HTTP_SET_STATUS_STR(201, \"Created\"),\n      HTTP_SET_STATUS_STR(202, \"Accepted\"),\n      HTTP_SET_STATUS_STR(203, \"Non-Authoritative Information\"),\n      HTTP_SET_STATUS_STR(204, \"No Content\"),\n      HTTP_SET_STATUS_STR(205, \"Reset Content\"),\n      HTTP_SET_STATUS_STR(206, \"Partial Content\"),\n      HTTP_SET_STATUS_STR(207, \"Multi-Status\"),\n      HTTP_SET_STATUS_STR(208, \"Already Reported\"),\n      HTTP_SET_STATUS_STR(226, \"IM Used\"),\n      HTTP_SET_STATUS_STR(300, \"Multiple Choices\"),\n      HTTP_SET_STATUS_STR(301, \"Moved Permanently\"),\n      HTTP_SET_STATUS_STR(302, \"Found\"),\n      HTTP_SET_STATUS_STR(303, \"See Other\"),\n      HTTP_SET_STATUS_STR(304, \"Not Modified\"),\n      HTTP_SET_STATUS_STR(305, \"Use Proxy\"),\n      HTTP_SET_STATUS_STR(306, \"(Unused), \"),\n      HTTP_SET_STATUS_STR(307, \"Temporary Redirect\"),\n      HTTP_SET_STATUS_STR(308, \"Permanent Redirect\"),\n      HTTP_SET_STATUS_STR(400, \"Bad Request\"),\n      HTTP_SET_STATUS_STR(403, \"Forbidden\"),\n      HTTP_SET_STATUS_STR(404, \"Not Found\"),\n      HTTP_SET_STATUS_STR(401, \"Unauthorized\"),\n      HTTP_SET_STATUS_STR(402, \"Payment Required\"),\n      HTTP_SET_STATUS_STR(405, \"Method Not Allowed\"),\n      HTTP_SET_STATUS_STR(406, \"Not Acceptable\"),\n      HTTP_SET_STATUS_STR(407, \"Proxy Authentication Required\"),\n      HTTP_SET_STATUS_STR(408, \"Request Timeout\"),\n      HTTP_SET_STATUS_STR(409, \"Conflict\"),\n      HTTP_SET_STATUS_STR(410, \"Gone\"),\n      HTTP_SET_STATUS_STR(411, \"Length Required\"),\n      HTTP_SET_STATUS_STR(412, \"Precondition Failed\"),\n      HTTP_SET_STATUS_STR(413, \"Payload Too Large\"),\n      HTTP_SET_STATUS_STR(414, \"URI Too Long\"),\n      HTTP_SET_STATUS_STR(415, \"Unsupported Media Type\"),\n      HTTP_SET_STATUS_STR(416, \"Range Not Satisfiable\"),\n      HTTP_SET_STATUS_STR(417, \"Expectation Failed\"),\n      HTTP_SET_STATUS_STR(421, \"Misdirected Request\"),\n      HTTP_SET_STATUS_STR(422, \"Unprocessable Entity\"),\n      HTTP_SET_STATUS_STR(423, \"Locked\"),\n      HTTP_SET_STATUS_STR(424, \"Failed Dependency\"),\n      HTTP_SET_STATUS_STR(425, \"Unassigned\"),\n      HTTP_SET_STATUS_STR(426, \"Upgrade Required\"),\n      HTTP_SET_STATUS_STR(427, \"Unassigned\"),\n      HTTP_SET_STATUS_STR(428, \"Precondition Required\"),\n      HTTP_SET_STATUS_STR(429, \"Too Many Requests\"),\n      HTTP_SET_STATUS_STR(430, \"Unassigned\"),\n      HTTP_SET_STATUS_STR(431, \"Request Header Fields Too Large\"),\n      HTTP_SET_STATUS_STR(500, \"Internal Server Error\"),\n      HTTP_SET_STATUS_STR(501, \"Not Implemented\"),\n      HTTP_SET_STATUS_STR(502, \"Bad Gateway\"),\n      HTTP_SET_STATUS_STR(503, \"Service Unavailable\"),\n      HTTP_SET_STATUS_STR(504, \"Gateway Timeout\"),\n      HTTP_SET_STATUS_STR(505, \"HTTP Version Not Supported\"),\n      HTTP_SET_STATUS_STR(506, \"Variant Also Negotiates\"),\n      HTTP_SET_STATUS_STR(507, \"Insufficient Storage\"),\n      HTTP_SET_STATUS_STR(508, \"Loop Detected\"),\n      HTTP_SET_STATUS_STR(509, \"Unassigned\"),\n      HTTP_SET_STATUS_STR(510, \"Not Extended\"),\n      HTTP_SET_STATUS_STR(511, \"Network Authentication Required\"),\n  };\n  fio_str_info_s ret = (fio_str_info_s){.len = 0, .data = NULL};\n  if (status >= 100 &&\n      (status - 100) < sizeof(status2str) / sizeof(status2str[0]))\n    ret = status2str[status - 100];\n  if (!ret.data) {\n    ret = status2str[400];\n  }\n  return ret;\n}\n#undef HTTP_SET_STATUS_STR\n", "#include <ruby.h>\n#define INCLUDE_MUSTACHE_IMPLEMENTATION 1\n#include \"mustache_parser.h\"\n\n#include \"iodine.h\"\n\n#define FIO_INCLUDE_STR\n#include <fio.h>\n\nstatic ID call_func_id;\nstatic ID to_s_func_id;\nstatic VALUE filename_id;\nstatic VALUE data_id;\nstatic VALUE template_id;\n/* *****************************************************************************\nC <=> Ruby Data allocation\n***************************************************************************** */\n\nstatic size_t iodine_mustache_data_size(const void *c_) {\n  return sizeof(mustache_s *);\n  (void)c_;\n}\n\nstatic void iodine_mustache_data_free(void *c_) {\n  mustache_free(((mustache_s **)c_)[0]);\n  free((void *)c_);\n  (void)c_;\n}\n\nstatic const rb_data_type_t iodine_mustache_data_type = {\n    .wrap_struct_name = \"IodineMustacheData\",\n    .function =\n        {\n            .dmark = NULL,\n            .dfree = iodine_mustache_data_free,\n            .dsize = iodine_mustache_data_size,\n        },\n    .data = NULL,\n    // .flags = RUBY_TYPED_FREE_IMMEDIATELY,\n};\n\n/* Iodine::PubSub::Engine.allocate */\nstatic VALUE iodine_mustache_data_alloc_c(VALUE self) {\n  void *m = malloc(sizeof(mustache_s *));\n  ((mustache_s **)m)[0] = NULL;\n  return TypedData_Wrap_Struct(self, &iodine_mustache_data_type, m);\n}\n\n/* *****************************************************************************\nParser Callbacks\n***************************************************************************** */\n\nstatic inline VALUE fiobj_mustache_find_obj_absolute(VALUE udata,\n                                                     const char *name,\n                                                     uint32_t name_len) {\n  VALUE tmp;\n  if (!RB_TYPE_P(udata, T_HASH)) {\n    if (name_len == 1 && name[0] == '.')\n      return udata;\n    /* search by method */\n    ID name_id = rb_intern2(name, name_len);\n    if (rb_respond_to(udata, name_id)) {\n      return IodineCaller.call(udata, name_id);\n    }\n    return Qnil;\n  }\n  /* search by Symbol */\n  ID name_id = rb_intern2(name, name_len);\n  VALUE key = ID2SYM(name_id);\n  tmp = rb_hash_lookup2(udata, key, Qundef);\n  if (tmp != Qundef)\n    return tmp;\n  /* search by String */\n  key = rb_sym2str(key);\n  tmp = rb_hash_lookup2(udata, key, Qundef);\n  if (tmp != Qundef)\n    return tmp;\n  /* search by method */\n  tmp = Qnil;\n  if (rb_respond_to(udata, name_id)) {\n    tmp = IodineCaller.call(udata, name_id);\n  }\n\n  return tmp;\n}\n\nstatic inline VALUE fiobj_mustache_find_obj_tree(mustache_section_s *section,\n                                                 const char *name,\n                                                 uint32_t name_len) {\n  do {\n    VALUE tmp = fiobj_mustache_find_obj_absolute((VALUE)section->udata2, name,\n                                                 name_len);\n    if (tmp != Qnil) {\n      return tmp;\n    }\n  } while ((section = mustache_section_parent(section)));\n  return Qnil;\n}\n\nstatic inline VALUE fiobj_mustache_find_obj(mustache_section_s *section,\n                                            const char *name,\n                                            uint32_t name_len) {\n  VALUE tmp = fiobj_mustache_find_obj_tree(section, name, name_len);\n  if (tmp != Qnil)\n    return tmp;\n  /* interpolate sections... */\n  uint32_t dot = 0;\n  while (dot < name_len && name[dot] != '.')\n    ++dot;\n  if (dot == name_len)\n    return Qnil;\n  tmp = fiobj_mustache_find_obj_tree(section, name, dot);\n  if (!tmp) {\n    return Qnil;\n  }\n  ++dot;\n  for (;;) {\n    VALUE obj =\n        fiobj_mustache_find_obj_absolute(tmp, name + dot, name_len - dot);\n    if (obj != Qnil)\n      return obj;\n    name += dot;\n    name_len -= dot;\n    dot = 0;\n    while (dot < name_len && name[dot] != '.')\n      ++dot;\n    if (dot == name_len) {\n      return Qnil;\n    }\n    tmp = fiobj_mustache_find_obj_absolute(tmp, name, dot);\n    if (tmp == Qnil)\n      return Qnil;\n    ++dot;\n  }\n}\n/**\n * Called when an argument name was detected in the current section.\n *\n * A conforming implementation will search for the named argument both in the\n * existing section and all of it's parents (walking backwards towards the root)\n * until a value is detected.\n *\n * A missing value should be treated the same as an empty string.\n *\n * A conforming implementation will output the named argument's value (either\n * HTML escaped or not, depending on the `escape` flag) as a string.\n */\nstatic int mustache_on_arg(mustache_section_s *section, const char *name,\n                           uint32_t name_len, unsigned char escape) {\n  VALUE o = fiobj_mustache_find_obj(section, name, name_len);\n  switch (o) {\n  case Qnil:\n  case Qfalse:\n    return 0;\n  case Qtrue:\n    fio_str_write(section->udata1, \"true\", 4);\n    break;\n  }\n  if (!RB_TYPE_P(o, T_STRING)) {\n    if (rb_respond_to(o, call_func_id))\n      o = IodineCaller.call(o, call_func_id);\n    if (!RB_TYPE_P(o, T_STRING))\n      o = IodineCaller.call(o, to_s_func_id);\n  }\n  if (!RB_TYPE_P(o, T_STRING) || !RSTRING_LEN(o))\n    return 0;\n  return mustache_write_text(section, RSTRING_PTR(o), RSTRING_LEN(o), escape);\n}\n\n/**\n * Called when simple template text (string) is detected.\n *\n * A conforming implementation will output data as a string (no escaping).\n */\nstatic int mustache_on_text(mustache_section_s *section, const char *data,\n                            uint32_t data_len) {\n  fio_str_write(section->udata1, data, data_len);\n  return 0;\n}\n\n/**\n * Called for nested sections, must return the number of objects in the new\n * subsection (depending on the argument's name).\n *\n * Arrays should return the number of objects in the array.\n *\n * `true` values should return 1.\n *\n * `false` values should return 0.\n *\n * A return value of -1 will stop processing with an error.\n *\n * Please note, this will handle both normal and inverted sections.\n */\nstatic int32_t mustache_on_section_test(mustache_section_s *section,\n                                        const char *name, uint32_t name_len,\n                                        uint8_t callable) {\n  VALUE o = fiobj_mustache_find_obj(section, name, name_len);\n  if (o == Qnil || o == Qfalse) {\n    return 0;\n  }\n  if (RB_TYPE_P(o, T_ARRAY)) {\n    return RARRAY_LEN(o);\n  }\n  if (callable && rb_respond_to(o, call_func_id)) {\n    size_t len;\n    const char *txt = mustache_section_text(section, &len);\n    VALUE str = Qnil;\n    if (txt && len) {\n      str = rb_str_new(txt, len);\n    }\n    o = IodineCaller.call2(o, call_func_id, 1, &str);\n    if (!RB_TYPE_P(o, T_STRING))\n      o = rb_funcall2(o, to_s_func_id, 0, NULL);\n    if (RB_TYPE_P(o, T_STRING) && RSTRING_LEN(o))\n      mustache_write_text(section, RSTRING_PTR(o), RSTRING_LEN(o), 0);\n    return 0;\n  }\n  return 1;\n}\n\n/**\n * Called when entering a nested section.\n *\n * `index` is a zero based index indicating the number of repetitions that\n * occurred so far (same as the array index for arrays).\n *\n * A return value of -1 will stop processing with an error.\n *\n * Note: this is a good time to update the subsection's `udata` with the value\n * of the array index. The `udata` will always contain the value or the parent's\n * `udata`.\n */\nstatic int mustache_on_section_start(mustache_section_s *section,\n                                     char const *name, uint32_t name_len,\n                                     uint32_t index) {\n  VALUE o = fiobj_mustache_find_obj(section, name, name_len);\n  if (RB_TYPE_P(o, T_ARRAY))\n    section->udata2 = (void *)rb_ary_entry(o, index);\n  else if (RB_TYPE_P(o, T_HASH))\n    section->udata2 = (void *)o;\n  return 0;\n}\n\n/**\n * Called for cleanup in case of error.\n */\nstatic void mustache_on_formatting_error(void *udata1, void *udata2) {\n  (void)udata1;\n  (void)udata2;\n}\n\n/* *****************************************************************************\nLoading the template\n***************************************************************************** */\n\n/**\nLoads the mustache template found in `:filename`. If `:template` is provided it\nwill be used instead of reading the file's content.\n\n    Iodine::Mustache.new(filename, template = nil)\n\nWhen template data is provided, filename (if any) will only be used for partial\ntemplate path resolution and the template data will be used for the template's\ncontent. This allows, for example, for front matter to be extracted before\nparsing the template.\n\nOnce a template was loaded, it could be rendered using {render}.\n\nAccepts named arguments as well:\n\n    Iodine::Mustache.new(filename: \"foo.mustache\", template: \"{{ bar }}\")\n\n*/\nstatic VALUE iodine_mustache_new(int argc, VALUE *argv, VALUE self) {\n  VALUE filename = Qnil, template = Qnil;\n  if (argc == 1 && RB_TYPE_P(argv[0], T_HASH)) {\n    /* named arguments */\n    filename = rb_hash_aref(argv[0], filename_id);\n    template = rb_hash_aref(argv[0], template_id);\n  } else {\n    /* regular arguments */\n    if (argc == 0 || argc > 2)\n      rb_raise(rb_eArgError, \"expecting 1..2 arguments or named arguments.\");\n    filename = argv[0];\n    if (argc > 1) {\n      template = argv[1];\n    }\n  }\n  if (filename == Qnil && template == Qnil)\n    rb_raise(rb_eArgError, \"need either template contents or file name.\");\n\n  if (template != Qnil)\n    Check_Type(template, T_STRING);\n  if (filename != Qnil)\n    Check_Type(filename, T_STRING);\n\n  fio_str_s str = FIO_STR_INIT;\n\n  mustache_s **m = NULL;\n  TypedData_Get_Struct(self, mustache_s *, &iodine_mustache_data_type, m);\n  if (!m) {\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache allocation error.\");\n  }\n\n  mustache_error_en err;\n  *m = mustache_load(.filename =\n                         (filename == Qnil ? NULL : RSTRING_PTR(filename)),\n                     .filename_len =\n                         (filename == Qnil ? 0 : RSTRING_LEN(filename)),\n                     .data = (template == Qnil ? NULL : RSTRING_PTR(template)),\n                     .data_len = (template == Qnil ? 0 : RSTRING_LEN(template)),\n                     .err = &err);\n\n  if (!*m)\n    goto error;\n  return self;\nerror:\n  switch (err) {\n  case MUSTACHE_OK:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache template ok, unknown error.\");\n    break;\n  case MUSTACHE_ERR_TOO_DEEP:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache element nesting too deep.\");\n    break;\n  case MUSTACHE_ERR_CLOSURE_MISMATCH:\n    rb_raise(rb_eRuntimeError,\n             \"Iodine::Mustache template error, closure mismatch.\");\n    break;\n  case MUSTACHE_ERR_FILE_NOT_FOUND:\n    rb_raise(rb_eLoadError, \"Iodine::Mustache template not found.\");\n    break;\n  case MUSTACHE_ERR_FILE_TOO_BIG:\n    rb_raise(rb_eLoadError, \"Iodine::Mustache template too big.\");\n    break;\n  case MUSTACHE_ERR_FILE_NAME_TOO_LONG:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache template name too long.\");\n    break;\n  case MUSTACHE_ERR_EMPTY_TEMPLATE:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache template is empty.\");\n    break;\n  case MUSTACHE_ERR_UNKNOWN:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache unknown error.\");\n    break;\n  case MUSTACHE_ERR_USER_ERROR:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache internal error.\");\n    break;\n  case MUSTACHE_ERR_FILE_NAME_TOO_SHORT:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache template file name too long.\");\n\n    break;\n  case MUSTACHE_ERR_DELIMITER_TOO_LONG:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache new delimiter is too long.\");\n\n    break;\n  case MUSTACHE_ERR_NAME_TOO_LONG:\n    rb_raise(rb_eRuntimeError,\n             \"Iodine::Mustache section name in template is too long.\");\n  default:\n    break;\n  }\n  return self;\n}\n\n/* *****************************************************************************\nRendering\n***************************************************************************** */\n\n/**\nRenders the mustache template using the data provided in the `data` argument.\n\nReturns a String with the rendered template.\n\nRaises an exception on error.\n\nNOTE:\n\nAs one might notice, no binding is provided. Instead, a `data` Hash is assumed.\nIodine will search the Hash for any data while protecting against code\nexecution.\n*/\nstatic VALUE iodine_mustache_render(VALUE self, VALUE data) {\n  fio_str_s str = FIO_STR_INIT;\n  mustache_s **m = NULL;\n  TypedData_Get_Struct(self, mustache_s *, &iodine_mustache_data_type, m);\n  if (!m) {\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache allocation error.\");\n  }\n  if (mustache_build(*m, .udata1 = &str, .udata2 = (void *)data))\n    goto error;\n  fio_str_info_s i = fio_str_info(&str);\n  VALUE ret = rb_str_new(i.data, i.len);\n  fio_str_free(&str);\n  return ret;\n\nerror:\n  fio_str_free(&str);\n  rb_raise(rb_eRuntimeError, \"Couldn't build template frome data.\");\n}\n\n/**\nRenders the mustache template found in `filename`, using the data provided in\nthe `data` argument. If `template` is provided it will be used instead of\nreading the file's content.\n\n    Iodine::Mustache.render(filename, data, template = nil)\n\nReturns a String with the rendered template.\n\nRaises an exception on error.\n\n    template = \"<h1>{{title}}</h1>\"\n    filename = \"templates/index\"\n    data = {title: \"Home\"}\n    result = Iodine::Mustache.render(filename, data)\n\n    # filename will be used to resolve the path to any partials:\n    result = Iodine::Mustache.render(filename, data, template)\n\n    # OR, if we don't need partial template path resolution\n    result = Iodine::Mustache.render(template: template, data: data)\n\nNOTE 1:\n\nThis function doesn't cache the template data.\n\nThe more complext the template the higher the cost of the template parsing\nstage.\n\nConsider creating a persistent template object using a new object and using the\ninstance {#render} method.\n\nNOTE 2:\n\nAs one might notice, no binding is provided. Instead, a `data` Hash is assumed.\nIodine will search the Hash for any data while protecting against code\nexecution.\n*/\nstatic VALUE iodine_mustache_render_klass(int argc, VALUE *argv, VALUE self) {\n  VALUE filename = Qnil, data = Qnil, template = Qnil;\n  if (argc == 1) {\n    /* named arguments */\n    Check_Type(argv[0], T_HASH);\n    filename = rb_hash_aref(argv[0], filename_id);\n    data = rb_hash_aref(argv[0], data_id);\n    template = rb_hash_aref(argv[0], template_id);\n  } else {\n    /* regular arguments */\n    if (argc < 2 || argc > 3)\n      rb_raise(rb_eArgError, \"expecting 2..3 arguments or named arguments.\");\n    filename = argv[0];\n    data = argv[1];\n    if (argc > 2) {\n      template = argv[2];\n    }\n  }\n  if (filename == Qnil && template == Qnil)\n    rb_raise(rb_eArgError, \"need either template contents or file name.\");\n\n  if (template != Qnil)\n    Check_Type(template, T_STRING);\n  if (filename != Qnil)\n    Check_Type(filename, T_STRING);\n\n  fio_str_s str = FIO_STR_INIT;\n\n  mustache_s *m = NULL;\n  mustache_error_en err;\n  m = mustache_load(.filename =\n                        (filename == Qnil ? NULL : RSTRING_PTR(filename)),\n                    .filename_len =\n                        (filename == Qnil ? 0 : RSTRING_LEN(filename)),\n                    .data = (template == Qnil ? NULL : RSTRING_PTR(template)),\n                    .data_len = (template == Qnil ? 0 : RSTRING_LEN(template)),\n                    .err = &err);\n  if (!m)\n    goto error;\n  int e = mustache_build(m, .udata1 = &str, .udata2 = (void *)data);\n  mustache_free(m);\n  if (e)\n    goto render_error;\n  fio_str_info_s i = fio_str_info(&str);\n  VALUE ret = rb_str_new(i.data, i.len);\n  fio_str_free(&str);\n  return ret;\n\nerror:\n  switch (err) {\n  case MUSTACHE_OK:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache template ok, unknown error.\");\n    break;\n  case MUSTACHE_ERR_TOO_DEEP:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache element nesting too deep.\");\n    break;\n  case MUSTACHE_ERR_CLOSURE_MISMATCH:\n    rb_raise(rb_eRuntimeError,\n             \"Iodine::Mustache template error, closure mismatch.\");\n    break;\n  case MUSTACHE_ERR_FILE_NOT_FOUND:\n    rb_raise(rb_eLoadError, \"Iodine::Mustache template not found.\");\n    break;\n  case MUSTACHE_ERR_FILE_TOO_BIG:\n    rb_raise(rb_eLoadError, \"Iodine::Mustache template too big.\");\n    break;\n  case MUSTACHE_ERR_FILE_NAME_TOO_LONG:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache template name too long.\");\n    break;\n  case MUSTACHE_ERR_EMPTY_TEMPLATE:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache template is empty.\");\n    break;\n  case MUSTACHE_ERR_UNKNOWN:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache unknown error.\");\n    break;\n  case MUSTACHE_ERR_USER_ERROR:\n    rb_raise(rb_eRuntimeError,\n             \"Iodine::Mustache internal error or unexpected data structure.\");\n    break;\n  case MUSTACHE_ERR_FILE_NAME_TOO_SHORT:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache template file name too long.\");\n\n    break;\n  case MUSTACHE_ERR_DELIMITER_TOO_LONG:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache new delimiter is too long.\");\n\n    break;\n  case MUSTACHE_ERR_NAME_TOO_LONG:\n    rb_raise(rb_eRuntimeError,\n             \"Iodine::Mustache section name in template is too long.\");\n\n    break;\n  default:\n    break;\n  }\n  return Qnil;\n\nrender_error:\n  fio_str_free(&str);\n  rb_raise(rb_eRuntimeError, \"Couldn't build template frome data.\");\n}\n\n/* *****************************************************************************\nInitialize Iodine::Mustache\n***************************************************************************** */\n\nvoid iodine_init_mustache(void) {\n  call_func_id = rb_intern2(\"call\", 4);\n  to_s_func_id = rb_intern2(\"to_s\", 4);\n  filename_id = rb_id2sym(rb_intern2(\"filename\", 8));\n  data_id = rb_id2sym(rb_intern2(\"data\", 4));\n  template_id = rb_id2sym(rb_intern2(\"template\", 8));\n  rb_global_variable(&filename_id);\n  rb_global_variable(&data_id);\n  rb_global_variable(&template_id);\n  VALUE tmp = rb_define_class_under(IodineModule, \"Mustache\", rb_cData);\n  rb_define_alloc_func(tmp, iodine_mustache_data_alloc_c);\n  rb_define_method(tmp, \"initialize\", iodine_mustache_new, -1);\n  rb_define_method(tmp, \"render\", iodine_mustache_render, 1);\n  rb_define_singleton_method(tmp, \"render\", iodine_mustache_render_klass, -1);\n  // rb_define_module_function(tmp, \"render\", iodine_mustache_render_klass, 2);\n}\n", "# coding: utf-8\nlib = File.expand_path('../lib', __FILE__)\n$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)\nrequire 'iodine/version'\n\nGem::Specification.new do |spec|\n  spec.name          = 'iodine'\n  spec.version       = Iodine::VERSION\n  spec.authors       = ['Boaz Segev']\n  spec.email         = ['bo@plezi.io']\n\n  spec.summary       = 'iodine - a fast HTTP / Websocket Server with Pub/Sub support, optimized for Ruby MRI on Linux / BSD'\n  spec.description   = 'A fast HTTP / Websocket Server with built-in Pub/Sub support (with or without Redis), static file support and many other features, optimized for Ruby MRI on Linux / BSD / macOS'\n  spec.homepage      = 'https://github.com/boazsegev/iodine'\n  spec.license       = 'MIT'\n\n  # Prevent pushing this gem to RubyGems.org by setting 'allowed_push_host', or\n  # delete this section to allow pushing this gem to any host.\n  if spec.respond_to?(:metadata)\n    spec.metadata['allowed_push_host'] = 'https://rubygems.org'\n  else\n    raise 'RubyGems 2.0 or newer is required to protect against public gem pushes.'\n  end\n\n  spec.files         = `git ls-files -z`.split(\"\\x0\").reject { |f| f.match(%r{^(test|spec|features)/}) }\n  spec.bindir        = 'exe'\n  spec.executables   = spec.files.grep(%r{^exe/}) { |f| File.basename(f) }\n  spec.require_paths = %w(lib ext)\n\n  spec.extensions = %w(ext/iodine/extconf.rb)\n\n  spec.required_ruby_version = '>= 2.2.2' # Because earlier versions had been discontinued\n\n  spec.requirements << 'A Unix based system: Linux / macOS / BSD.'\n  spec.requirements << 'An updated C compiler.'\n  spec.requirements << 'Ruby >= 2.2.2 required for Rack 2.'\n  spec.requirements << 'Ruby >= 2.5.0 recommended.'\n  spec.requirements << 'TLS requires OpenSSL >= 1.1.0'\n\n  # spec.add_development_dependency 'bundler', '>= 1.10', '< 2.0'\n  spec.add_development_dependency 'rake', '~> 12.0', '< 13.0'\n  spec.add_development_dependency 'minitest', '>=5', '< 6.0'\n  spec.add_development_dependency 'rake-compiler', '>= 1', '< 2.0'\n\n  spec.post_install_message = \"Thank you for installing Iodine #{Iodine::VERSION}.\\n\"\nend\n", "module Iodine\n  VERSION = '0.7.33'.freeze\nend\n"], "fixing_code": ["# Iodine\n[![Gem Version](https://badge.fury.io/rb/iodine.svg)](https://badge.fury.io/rb/iodine)\n[![Inline docs](http://inch-ci.org/github/boazsegev/iodine.svg?branch=master)](http://www.rubydoc.info/github/boazsegev/iodine/master/frames)\n\nPlease notice that this change log contains changes for upcoming releases as well. Please refer to the current gem version to review the current release.\n\n## Changes:\n\n#### Change log v.0.7.34\n\n**Security**: (`facil.io`, `http`) updated to facil.io 0.7.3, incorporating it's bug fixes and security updates.\n\n#### Change log v.0.7.33\n\n**Fix**: (`iodine`) exception protection would fail and crash if the exception throws wasn't of type `Exception`. I'm not sure how this would happen, but on some Ruby versions it appeared to have occur, maybe where a custom `raise` would be called with a non-exception type. The issue was fixed by testing for the availability of the `message` and `backtrace` functions. Credit to Jan Biedermann (@janbiedermann) for exposing this issue (#76).\n\n**Fix**: (`cli`) the CLI interface no longer requires Rack to be installed. If Rack is installed, it will be used. Otherwise, a copy of the Rack::Builder code will execute, licensed under the MIT license from the Rack source code (Copyright (C) 2007-2019 [Leah Neukirchen](http://leahneukirchen.org/infopage.html)).\n\n**Compatibility**: (`facil`) iodine would raise the signal `SIGINT` when shutting down in cluster mode, even if shutdown was initiated using `Iodine.stop`. Although this was designed to ensure worker processes would stop, this approach caused RSpec to stop testing and report an error. A temporary fix was applied and might be upstreamed to the facil.io repo. Credit to Jan Biedermann (@janbiedermann) for exposing this issue (#76).\n\n#### Change log v.0.7.32\n\n**Fix**: (`http1`) fixes a race-condition between the `on_ready` and `on_data` events, that could result in the `on_data` event being called twice instead of once (only possible with some clients). On multi-threaded workers, this could result in the CPU spinning while the task lock remains busy. Credit to N\u00e9stor Coppi (@Shelvak) for exposing the issue and providing an example application with detailed reports. Issue #75.\n\n#### Change log v.0.7.31\n\n**Security**: a heap-overflow vulnerability was fixed in the WebSocket parser. This attack could have been triggered remotely by a maliciously crafted message-header. Credit to Dane (4cad@silvertoque) for exposing this issue and providing a Python script demonstrating the attack. \n\nIt's recommended that all iodine users update to the latest version.\n\n#### Change log v.0.7.30\n\n**Update**: (`cli`) added support for the `-pid` flag - stores the master processes PID in a file.\n\n**Update**: (`cli`) added support for the `-config` (`-C`) flag - loads a configuration file immediately after loading iodine.\n\n#### Change log v.0.7.29\n\n**Fix**: fixed an issue where `env['rack.input'].read(nil, nil)` would return `nil` instead of `\"\"` on zero-content requests (i.e., an empty POST request). Credit to @thexa4 (Max Maton) for exposing this issue and providing a POC for debugging (issue #71).\n\n#### Change log v.0.7.28\n\n**Fix**: fixed an issue where iodine would crush (or hang) if unprotected exceptions were raised within a response body's `each` loop. This also fixes Fiber support when streaming with Roda (note: iodine will concat the body in a buffer before sending it). Credit to @adam12 (Adam Daniels) both for exposing the issue (#70) and testing possible solutions.\n\n#### Change log v.0.7.27\n\n**Compatibility**: (`iodine`) fixed the HTTP request `SCRIPT_NAME` variable (in the Rack `env`) to default to the global environment variable `SCRIPT_NAME` when `SCRIPT_NAME` isn't root (`/`). Credit to @thexa4 (Max Maton) for exposing this compatibility concern (issue #68).\n\n#### Change log v.0.7.26\n\n**Fix**: (`http`) fixed HTTP date format to force the day of the month to use two digits. Credit to @ianks (Ian Ker-Seymer) for exposing this issue (issue #64).\n\n**Fix**: (`iodine`) fixed static file service without an application (when using iodine as a stand-alone static file server).\n\n**Fix**: (`fio`) miscellaneous compatibility updates.\n\n#### Change log v.0.7.25\n\n**Fix**: (`iodine`) fixed host name binding when running `iodine` using `rackup` or through `Rack`. Credit to @adam12 (Adam Daniels) for PR #60.\n\n**Fix**: (`iodine`) removed bundler requirement in the `iodine.gemspec` file.\n\n#### Change log v.0.7.24\n\n**Fix**: (`fio`) fixed server shutdown on pub/sub stress, where internal pub/sub stress was mistakingly identified as a Slowloris attack. Credit to @moxgeek (Marouane Elmidaoui) for exposing this issue (plezi#32).\n\n**Fix**: (`fio`): fixed Slowloris detection for buffer attack variation.\n\n**Fix**: (`fio`): fixed `pending` result, where packet count wouldn't decrement until queue was drained.\n\n**Updates**: (`fio`) facil.io updates, including pub/sub memory improvements for cluster mode.\n\n#### Change log v.0.7.23\n\n**Fix**: (`fio`): fixed logging message for overflowing log messages. Credit to @weskerfoot (Wesley Kerfoot) and @adam12 (Adam Daniels) for exposing the issue (issue #56).\n\n**Updates**: (`fio`) facil.io updates.\n\n#### Change log v.0.7.22\n\n**Fix**: (`fio`, `redis`) fixed IPC messages between redis connections (in the master process) and callback blocks (executed in the worker processes). Credit to @moxgeek (Marouane Elmidaoui) for exposing this issue (plezi#31).\n\n#### Change log v.0.7.21\n\n**Fix**: (`iodine`, `redis`) Redis response was attempting to create Ruby objects outside the GIL. This is now fixed by entering the GIL earlier (before objects are created). Credit to @moxgeek (Marouane Elmidaoui) for exposing this issue (plezi#31).\n\n**Fix**: (`redis`) fixed Redis reconnection. Address and port data was mistakingly written at the wrong address, causing it to be overwritten by incoming (non-pub/sub) data.\n\n**Fix**: (`redis`) fixed a race condition in the Redis reconnection logic which might have caused more then a single pub/sub connection to be established and the first pending command to be sent again.\n\n#### Change log v.0.7.20\n\n**Security**: (`fio`) lower and smarter Slowloris detection limits (backlog limit is now 1,024 responses / messages per client). \n\n**Security**: (`http`) HTTP/1.1 slow client throttling - new requests will not be consumed until pending responses were sent. Since HTTP/1.1 is a response-request protocol, this protocol specific approach should protect the HTTP application against slow clients.\n\n**Fix**: (`iodine`) remove redundant Content-Type printout. Credit to @giovannibonetti (Giovanni Bonetti) for exposing the issue (#53).\n\n**Fix**: (`fio`) fix capacity maximization log to accommodate issues where `getrlimit` would return a `rlim_max` that's too high for `rlim_cur` (macOS).\n\n**Fix**: (`fio`) fix uninitialized `kqueue` message in `fio_poll_remove_fd`.\n\n**Fix**: (`docs`) @giovannibonetti (Giovanni Bonetti) fixed an error in the Rails README section, PR #52.\n\n#### Change log v.0.7.19\n\n**Deprecation**: (`iodine`) deprecated the CLI option `-tls-password`, use `-tls-pass` instead.\n\n**Security**: (`fio`) Slowloris mitigation is now part of the core library, where `FIO_SLOWLORIS_LIMIT` pending calls to `write` (currently 4,096 backlogged calls) will flag the connection as an attacker and close the connection. This protocol independent approach improves security.\n\n**Fix**: (`iodine`) log open file / socket limit per worker on startup.\n\n**Fix**: (`iodine`) application warm-up error was fixed. Deprecation warnings will still print for deprecated symbols loaded due to the warm-up sequence.\n\n**Update**: (`iodine`, `cli`) Support the environment variables `\"WORKERS\"` and `\"THREADS\"` out of the box (jury is out regarding `\"PORT\"` and `\"ADDRESS\"`, just use CLI for now).\n\n#### Change log v.0.7.18\n\n**Fix** (`pubsub`) fixed pub/sub for longer WebSocket messages. Issue where network byte ordering wasn't always respected and integer bit size was wrong for larger payloads. Credit to Marouane Elmidaoui (@moxgeek) for exposing the issue.\n\n#### Change log v.0.7.17\n\n**Security**: (`fio`) improved security against hash flooding attacks.\n\n**Update**: (`iodine`) SSL/TLS support!\n\n**Update**: (`iodine`) WebSocket client connections are now supported using `Iodine.connect` (both `ws://` and `wss://`)!\n\n**Deprecation**: (`iodine`) deprecated `DEFAULT_HTTP_ARGS` in favor of `DEFAULT_SETTEINGS`.\n\n**Deprecation**: (`iodine`) deprecated `Iodine.listen2http` in favor of `Iodine.listen service: :http`.\n\n**Fix**: (`iodine` / `pubsub`) fixed possible issue with global subscriptions (non-connection bound subscriptions).\n\n**Fix**: (`Iodine::Mustache`) fixed support for named argument, documentation and loading template from memory (rather than file) when creating a new `Iodine::Mustache` object.\n\n**Fix**: (`redis`) fixed an issue where destroying the Redis engine and exiting pre-maturely, could cause a segmentation fault during cleanup.\n\n**Fix**: (`iodine`, `fio`) fixed logging message when listening to Unix Sockets.\n\n**Fix**: (`iodine`) fixed CLI argument recognition for WebSocket message limits and HTTP header limits. Typos in the CLI argument names prevented the CLI from effecting the default values.\n\n**Fix**: (`fio`) fixed unaligned memory access in SipHash implementation and added secret randomization for each application restart.\n\n**Optimization**: (`iodine`) caching common header names to decrease Ruby memory allocations per request.\n\n#### Change log v.0.7.16\n\n**Security**: (`fio`) security fixes from the facil.io core library (updated to 0.7.0.beta6).\n\n**Update**: (`iodine`) better Redis support from CLI and environment (by setting the `IODINE_REDIS_URL` environment variable).\n\n**Optimization**: (`Iodine::Mustache`) optimized worst case scenario seeking by seeking Symbols before Strings, which improved seeking times.\n\n#### Change log v.0.7.15\n\n**Fix**: (`fio`) fixed a minor memory leak in cluster mode, caused by the root process not freeing the hash map used for child process subscription monitoring (only effected hot restarts).\n\n**Fix**: (`fio`) fixed superfluous and potentially erroneous pub/sub engine callback calls to `unsubscribe`, caused by (mistakingly) reporting filter channel closure.\n\n**Fix**: (`http/1.1`) avoid processing further requests if the connection was closed.\n\n**Fix**: (`iodine`) fixed some errors in the documentation and added a missing deprecation notice.\n\n**Update**: (`fio`) updated the automatic concurrency calculations to leave resources for the system when a negative value is provided (was only available for worker count calculations, now available for thread count as well).\n\n#### Change log v.0.7.14\n\n**Fix**: (`facil.io`) fixed superfluous ping event.\n\n**Fix**: (`iodine_tcp`) fixed responsiveness to the argument name `timeout` (a spelling mistake was testing for `timout`).\n\n**Fix**: (`iodine_store`) fixed missing EOL marker in DEBUG messages when reporting iodine's GC guard activity.\n\n**Update**: (`iodine`) added support for dynamic (hot) connection callback switching.\n\n#### Change log v.0.7.13\n\n**Fix**: (`mustache`) added support for padding in template partials.\n\n**Fix**: (`mustache`) added support for method names as keys (i.e., `{{user.to_json}}` or `{{#user}}{{to_json}}{{/user}}`). Note: no arguments may be passed (no Ruby code parsing, just testing against method names).\n\n#### Change log v.0.7.12\n\n**Fix**: (`mustache`) fixed multiple issues with `Iodine::Mustache` and added lambda support for mustache templates.\n\n#### Change log v.0.7.11\n\n**Fix**: (`fio`) Deletes Unix sockets once done listening. Fixes an issue where the files would remain intact.\n\n**Optimization**: (`fio`) significant memory allocation optimizations. The facil.io allocator (included with iodine) helps to protect against heap fragmentation and improves speed for concurrent memory allocations when forking / multi-threading.\n\n#### Change log v.0.7.10\n\n**Fix**: (pub/sub) fixed connection lock for pub/sub tasks. Now pub/sub Ruby tasks will lock the connection, protecting the user's code against concurrent access to the connection's data.\n\n**Fix**: (installation) fixed `CFLAGS` compilation value to allow for pre-existing values set by Ruby.\n\n**Fix**: (installation) fixed possible issues than could occur when installing iodine with  `FIO_FORCE_MALLOC`.\n\n**Optimization**: (pub/sub) leverages facil.io broadcasting optimizations, minimizing memory allocations when broadcasting pub/sub messages directly to multiple WebSocket clients.\n\n**Update**: (fio) updated the facil.io code to leverage it's urgent task queue for outbound IO, which minimizes reliance on the IO backup thread.\n\n**Update**: (IO) minor tweaks to the IO backup thread and CLI output format.\n\n#### Change log v.0.7.9\n\n**Fix**: fixed the background IO backup thread initialization and sleep interval. This thread isn't critical. It's only used to (slowly) flush sockets when all the actual threads are blocked by long running Ruby application code.\n\n**Feature**: added the `Iodine.worker?` and `Iodine.master?` methods, for process identification.\n\n**Update**: Updated the automatic ActiveRecord `fork` handling code and added automatic Sequel `fork` handling, to protect against possible database communication errors related to the risk of connection sharing across worker processes.\n\n**Update**: Moved the command line option parsing code, to leverage facil.io's `fio_cli`... It appears more flexible than Ruby's `optparse` (where command line naming is concerned).\n\n**Deprecation**: deprecated the global namespace DSL (`after_fork`, etc'). Use the new `Iodine.on_state(:after_fork)` method instead.\n\n#### Change log v.0.7.8\n\n**Fix**: `unsubscribe` possibly wouldn't unsubscribe from a connection-bound subscription when instructed to do so. This was discovered during a review of a issue #45 submitted by @ojab.\n\n**Fix**: Documentation typo fixed by @ojab in PR#46.\n\n**Fix**: Documentation errors exposed by @ojab regarding the pub/sub specification draft and the WebSocket/SSE specification draft.\n\n#### Change log v.0.7.7\n\n**Fix**: (facil.io) fixed critical issue with cookies, where no more than a single cookie could be set (duplicate headers would be zeroed out before being set). Credit to @ojab for exposing the issue.\n\n#### Change log v.0.7.6\n\n**Fix**: (facil.io edge) timeout review was experiencing some errors that could cause timeouts to be ignored. This was fixed in the facil.io edge branch.\n\n**Fix**: (Ruby 2.2) fixed a possible error with the Mustache parser on Ruby 2.2. I don't run Ruby 2.2, but this came up as a warning during CI tests.\n\n**Fix**: `on_worker_boot` was mistakenly updated to a pre-fork callback (instead of a post fork callback) when attempting to fix the `on_worker_fork` behavior. This timing issue is now fixed and `on_worker_boot` is called **after** forking (both on the master process and the worker).\n\n#### Change log v.0.7.5\n\n**Fix**: fixed issue with direct calls to `publish` in the pre-defined pub/sub engines. These direct calls are used by custom engines when the default engine was replaced and would attempt (erroneously) direct engine access rather than use the `fio_publish` function.\n\n**Fix**: fixed possible Array overflow risk that could result in memory corruption in some cases.\n\n**Fix**: fixed more missing `static` keywords in the code. these should have little or no effect on the namespace (they were using long unique names with the `iodine` prefix).\n\n#### Change log v.0.7.4\n\n**Fix**: fixed a missing `static` keyword in the Ruby<=>C storage bridge which caused performance degradation and introduced namespace conflict risks.\n\n**Fix**: fixed the `on_worker_fork` callback timing, to be performed before forking the process (Puma compatibility).\n\n**Fix**: fixes to minor issues are included in the facil.io edge update.\n\n**Optimize**: minor optimization to memory use, included in facil.io edge updates.\n\n#### Change log v.0.7.3\n\n**Fix**: (facil.io) updating facil.io fixes a channel name memory leak that was fixed in facil.io's edge version.\n\n**Updated**: Improved logging for server data, allowing for total log silencing - this doesn't effect HTTP logging, only iodine's core logging system.\n\n#### Change log v.0.7.2\n\n**Updated**: updated the logging for HTTP services startup, to minimize log clutter.\n\n**Feature**: (mustache) added features to `Iodine::Mustache`, to expose more of the functionality offered by facil.io.\n\n**Fix**: (facil.io) updated from the facil.io edge (master) branch. This should fix some exposed symbols (that should have been private), minimize name-collision risks, and fix an unknown issue with the mime-type registry cleanup and other possible issues.\n\n#### Change log v.0.7.1\n\n**Fix**: Fixed compilation issues with older `gcc` compilers.\n\n#### Change log v.0.7.0\n\nThis version bump is performed because the internal engine changed significantly and might be considered less mature. The public API remains unbroken. \n\n**Fix**: Fixed a documentation error. Credit to @Fonsan (Erik Fonselius) for PR #41.\n\n**Feature**: (mustache) Added a bridge to facil.io's mustache template rendering engine. This isn't really a server concern, but [facil.io's C code](http://facil.io) includes this functionality anyway and it offers increased XSS protection by utilizing aggressive HTML escaping (and it's also faster than the Ruby canonical version).\n\n**Update**: (facil.io) Updated to facil.io version 0.7.0 (edge). This could effect memory consumption behavior but otherwise shouldn't effect iodine all that much.\n\n\n#### Change log v.0.6.5\n\n**Fix**: (facil.io - logging) Fix typo in log output. Credit to @bjeanes (Bo Jeanes) for PR #39.\n\n#### Change log v.0.6.4\n\n**Fix**: (HTTP/WebSockets) fixed an issue where negative status return values (such as ActionCable's `-1` status code) could cause iodine to assume an abnormal error and shut down the connection. Credit to @mdesantis (Maurizio De Santis) for opening issue #38.\n\n#### Change log v.0.6.3\n\n**Fix**: (WebSockets) fixed an issue where WebSocket message events would attempt to create a String object outside the GVL.\n\n**Fix**: (`Iodine::Connection`) minor updated to the documentation and memory validation system.\n\n#### Change log v.0.6.2\n\n**Fix**: (`Iodine::PubSub`) fixed an issue where lazy initialization would cause the shutdown process to crash if no Pub/Sub engines were ever registered (fixes an attempt to seek within an uninitialized data structure). Credit to @sj26 (Samuel Cochran) for reporting the issue.\n\n#### Change log v.0.6.1\n\n**Fix**: (`Iodine::PubSub`) fixed typo, `Iodine::PubSub.detach` is now correctly spelled.\n\n**Fix**: (`Iodine::PubSub`) fix issue #37 where iodine would crash after the server's shutdown process due to Ruby Pub/Sub engines still being attached (or set as default) even after the Ruby interpreter freed all the Ruby objects. Credit to @sj26 (Samuel Cochran) for reporting the issue.\n\n#### Change log v.0.6.0\n\nI apologize to all my amazing early adopters for the rapid changes in the API for connection objects (SSE / WebSockets) and Pub/Sub. This was a result of an attempt to create a de-facto standard with other server authors. Hopefully the API in the 0.6.0 release will see the last of the changes.\n\n**API BREAKING CHANGE**: The API for persistent connections (SSE / WebSockets) was drastically changed in accordance with the Rack specification discussion that required each callback to accept a \"client\" object (replacing the `extend` approach). Please see the documentation.\n\n**API BREAKING CHANGE**: `Iodine.attach` was removed due to instability and issues regarding TLS/SSL and file system IO. I hope to fix these issues in a future release. For now the `Iodine.attach_fd` can be used for clear-text sockets and pipes.\n\n**API BREAKING CHANGE**: Pub/Sub API was changed, replacing the previously suggested pub/sub object with an updated `unsubscribe` method. This means there's no need for the client to map channel names to specific subscriptions (Iodine will perform this housekeeping task for the client).\n\n**Fix**: Iodine should now build correctly on FreeBSD. Credit to @adam12 (Adam Daniels) for detecting the issue.\n\n---\n\n#### Change log v.0.5.2\n\n**Fix**: fixed compilation issues on FreeBSD. Credit to @adam12 (Adam Daniels) for opening issue #35 and offering a patch.\n\n#### Change log v.0.5.1\n\n**Fix**: fixed compilation issues on OS X version < 10.12 and Alpine Linux. Credit to @jdickey (Jeff Dickey) for opening issue #32.\n\n**Fix**: fixed some documentation errors. Credit to @janko-m (Janko Marohni\u0107) for catching typos in the README.\n\n#### Change log v.0.5.0\n\nChanged... everything. At least all the internal bits and some of the API.\n\nIodine 0.5.0 is a stability oriented release. It also supports the updated Rack specification draft for WebSocket and SSE connections (yes, iodine 0.5.0 brings about SSE support).\n\nDeprecated the `each` function family in favor of the more scalable pub/sub approach.\n\nMoved the HTTP network layer outside of the GIL, more robust pub/sub (using Unix Sockets instead of pipes), hot restart (in cluster mode) and more.\n\nLarger header support. The total headers length now defaults to 32Kb, but can be adjusted. A hard coded limit of 8Kb per header line is still enforced (to minimize network buffer).\n\nImproved concurrency and energy consumption (idling CPU cycles reduced).\n\nHigher overall memory consumption might be observed (some security and network features now perform data copying rather than allowing for direct data access).\n\nImproved automatic header completion for missing `Content-Length`, `Date` and `Last-Modified`.\n\nSupport for the Unicorn style `before_fork` and `after_fork` DSL as well as the Puma style `on_worker_boot` DSL.\n\nCredit to Anatoly Nosov (@jomei) for fixing some typos in the documentation.\n\n---\n\n#### Change log v.0.4.19\n\n**Feature**: (`iodine`) added requested feature in issue #27, `Iodine.running?` will return Iodine's state.\n\n#### Change log v.0.4.18\n\n**Fix**: (`iodine pub/bus`) fixed issue #27 (?) where the `block` used for subscriptions would be recycled by the GC and the memory address (retained by `iodine`) would point at invalid Ruby objects (at worst) or become invalid (at best). Credit to Dmitry Davydov (@haukot) for exposing this issue.\n\n**Fix**: (`facil pub/bus`) fixed issue #27 (?) where the `memcpy` was used instead of `memmove`, resulting in possibly corrupt data in cluster messaging system. Credit to Dmitry Davydov (@haukot) for exposing this issue.\n\n#### Change log v.0.4.17\n\n**Fix**: (`iodine RubyCaller`) fixed issue #26 that exposed an issue in the exception handling logic. This fix enforces exception handling whenever entering the Ruby GVL (GIL), allowing C functions to safely enter the user's Ruby code (where before C functions were assumed to be safe and user code would be executed unprotected when routed through certain functions). Credit to Dmitry Davydov (@haukot) for exposing this issue (issue #26).\n\n#### Change log v.0.4.16\n\n**Fix**: (`websocket_parser`) The websocket parser had a memory offset and alignment handling issue in it's unmasking (XOR) logic and the new memory alignment protection code. The issue would impact the parser in rare occasions when multiple messages where pipelined in the internal buffer and their length produced an odd alignment (the issue would occur with very fast clients, or a very stressed server).\n\n#### Change log v.0.4.15\n\n**Update**: (`facil.io`) updating the facil.io library version to use the 0.5.8 released version.\n\nThis includes the following changes (as well as other minor changes), as detailed in facil.io's CHANGELOG:\n\n**Compatibility**: (`websocket_parser`) removed unaligned memory access from the XOR logic in the parser, making it more compatible with older CPU systems that don't support unaligned memory access or 64 bit word lengths.\n\n**Optimization**: (`defer`) rewrote the data structure to use a hybrid cyclic buffer and linked list for the task queue (instead of a simple linked list), optimizing locality and minimizing memory allocations.\n\n**Compatibility**: (`gcc-6`) Fix some compatibility concerns with `gcc` version 6, as well as some warnings that were exposed when testing with `gcc`.\n\n---\n\n#### Change log v.0.4.14\n\n**Fix**: (`facil.io`) fixes an issue where timer monitoring would report failure when the timer exists and is being monitored.\n\n---\n\n#### Change log v.0.4.12\n\n**Fix**: (`facil.io`) fixes some lingering issues with the new Websocket parser, namely an issue where certain network packet lengths would cause the parser to fail. Credit to Tom Lahti (@uidzip) for exposing the issue.\n\n---\n\n#### Change log v.0.4.11\n\n**Fix**: (`iodine`) use Ruby `fork` instead of system `fork`, allowing Ruby hooks to run before and after forking. This also fixes an issue where the Ruby timer thread isn't (re)initialized.\n\n---\n\n#### Change log v.0.4.10\n\n**Portability**: (`mac OS High Sierra`) iodine will load the Objective C library on macOS machines before starting up the server - this will prevent `fork` from crashing the server on macOS High Sierra, see [discussion here](https://github.com/puma/puma/issues/1421).\n\n**Fix**: (`facil.io`) fixes an error with the new Websocket parser (introduced in v. 0.4.9) that caused medium sized messages (127 Bytes - 64Kib) to be parsed incorrectly. Apologies. The test program I used seems to have validated messages using length comparison (instead of data comparison). Credit to Tom Lahti (@uidzip) for exposing the issue.\n\n---\n\n#### Change log v.0.4.9\n\n**Change**: (`facil.io`) the internal Websocket parser was replaced with something easier to read, for maintainability reasons. Performance seems to be mostly unaffected (sometimes it's faster and sometimes it's slower, common case is slightly optimized).\n\n**Change**: (`facil.io`) iodine will compile facil.io with the `NO_CHILD_REAPER` flag, in order to workaround the Rails ExecJS gem that [assumes no child reaping is performed](https://github.com/rails/execjs/issues/68). This workaround is, hopefully, temporary. Credit to @jerryshen for exposing the issue.\n\n**Fix**: (`Iodine`) test for timer creation error in `run_after` and `run_every`.\n\n**Fix**: (`facil.io`) timer creation now correctly detects if the reactor was stopped, allowing the creation of new timers before the reactor's reactivation.\n\n**Fix**: (`facil.io`) timer timeout review is now correctly ignored, preventing the timer from being shut down prematurely.\n\n---\n\n#### Change log v.0.4.8\n\n**Change**: (`facil.io`) the internal HTTP parser was replaced with something easier to read, for maintainability reasons. Performance seems to be unaffected.\n\n**Fix**: HTTP request logging included an extra info line which was a debug/testing message inherited from `facil.io` v.0.5.3-pre-release. This is now removed.\n\n**Performance**: The `now` HTTP Date string is now cached for up to 2 seconds, improving performance for `Date`, `Last-Modified` and Iodine logging messages that relate to the current time. However, it's likely that Rack will write it's own date string, masking this feature.\n\n---\n\n#### Change log v.0.4.7\n\n**Update**: Now using `facil.io` edge (stripped down v.0.5.3).\n\n**Fix**: (`websocket`) fix #21, where a client's first message could have been lost due to long `on_open` processing times. This was fixed by fragmenting the `upgrade` event into two events, adding the `facil_attach_locked` feature and attaching the new protocol before sending the response. Credit to @madsheep and @nilclass for exposing the issue and tracking it down to the `on_open` callbacks.\n\n**Fix**: (`sock`) sockets created using the TCP/IP `sock` library now use `TCP_NODELAY` as the new default. This shouldn't be considered a breaking change as much as it should be considered a fix.\n\n**Fix**: (`http1`) HTTP/1.x now correctly initializes the `udata` pointer to NULL fore each new request.\n\n**Fix**: (`defer`) a shutdown issue in `defer_perform_in_fork` was detected by @cdkrot and his fix was implemented.\n\n---\n\n#### Change log v.0.4.6\n\n**Update**: Now using `facil.io` v.0.5.2.\n\n**Fix**: (from `facil.io`) fix `SIGTERM` handling, make sure sibling processes exit when a sibling dies.\n\n---\n\n#### Change log v.0.4.5\n\n**Fix**: fix static file service for `X-Sendfile` as well as static error file fallback pages (404.html etc').\n\n---\n\n#### Change log v.0.4.4\n\n**Fix**: fixed an issue related to Ruby 2.3 optimizations of String management (an issue that didn't seem to effect Ruby 2.4). This fix disables the recyclable buffer implemented for the `on_message` Websocket callback. The callback will now receive a copy of the buffer (not the buffer itself), so there is no risk of collisions between the network buffer (managed in C) and the `on_message(data)` String (managed by Ruby).\n\n---\n\n#### Change log v.0.4.3\n\n**Fix**: fixed a possible issue in fragmented pipelined Websocket messages.\n\n---\n\n#### Change log v.0.4.2\n\n**Fix**: fixed an issue where Websocket `ping` timeouts were being ignored for the default `Iodine::Rack` server, causing the default (40 seconds) to persist over specified valued.\n\n**Fix**: fixed a possible issue with high-jacking which might cause the server to hang.\n\n---\n\n#### Change log v.0.4.1\n\n**Fix**: postpone warmup in fear of abuse and collisions when using `fork`. i.e., during warmup, an application might perform actions that conflict with `fork` and worker initialization, such as creating a database connection pool during warmup, or maybe spawning a thread. Now `warmup` is postponed until *after* worker processes are up and running, resulting in a per-process warmup rather than a per-cluster warmup.\n\n**Fix** move the `rake-compiler` dependency to \"development\" instead of \"runtime\". Credit to Luis Lavena (@luislavena) for exposing the issue (#19).\n\n---\n\n#### Change log v.0.4.0\n\n**Braking change**: Some of the API was changed / updated, hopefully simplified.\n\n**DEPRECTAION / Braking change**: The `websocket#write_each` function is gone. Future (planned) support for a Pub/Sub API would have caused confusion and since it's barely used (probably only there as a benchmarking proof of concept) it was removed.\n\n**Update**: Now using `facil.io` v.0.5.0 The extended features include the following listed features.\n\n**Fixes**: This was such a big rewrite, I suspect half the fixes I want to list are things I broke during the rewrite... but there were plenty of fixes.\n\n**Feature**: Iodine now support native Websocket Pub/Sub, with [an example in the `examples` folder](./examples/redis.ru). i.e.:\n\n```ruby\n# Within a Websocket connection:\nsubscribe \"chat\"\npublish \"chat\", \"Iodine is here!\"\n```\n\n**Feature**: Iodine's Pub/Sub API supports both direct client messages and server filtered messages. i.e.\n\n```ruby\n# Within a Websocket connection:\nsubscribe(\"chat-server\") {|msg| write \"Notice: #{msg}\" }\n# v.s\nsubscribe(\"chat-client\")\n\npublish \"chat-server\", \"Iodine is here!\"\n```\n\n**Feature**: Iodine's Pub/Sub API includes support for home made Pub/Sub Engines connecting Iodine to your Pub/Sub service of choice.\n\n**Feature**: Iodine's Pub/Sub support includes a Process Cluster engine (pub/sub to all Websockets sharing the process cluster) as well as a Single Process engine (pub/sub to all websockets supporting a single process).\n\n**Feature**: Iodine's Pub/Sub support includes a native Redis Pub/Sub engine. The parser is written from the ground up in C to keep the Iodine licensing as MIT. It's young, so keep your eyes pealed and submit any issues you encounter.\n\n**Feature + Breaking Change**: Iodine now support multiple HTTP servers at once. i.e.:\n\n```ruby\n# `Iodine::HTTP.listen` initializes an HTTP service in the C and system levels, so it can't be changed once initialized.\nIodine::HTTP.listen port: 3000, app: my_app1\nIodine::HTTP.listen port: 3000, app: my_app2, public: \"./www\"\nIodine.start\n```\n\n---\n\n#### Change log v.0.3.6\n\n**Update**: Now using `facil.io` v.0.4.3. This fixes some delays in websocket packet flushing (latency), as well as other internal polishes. It also promises some possible future feature extensions that could add a major performance boost.\n\n---\n\n#### Change log v.0.3.5\n\n**Fix**: (`sock`) Fixed an issue with the `sendfile` implementation on macOS and BSD, where medium to large files wouldn't be sent correctly.\n\n**Minor changes**: This release incorporates some more minor changes from the [`facil.io` 0.4.2 update](https://github.com/boazsegev/facil.io/releases/tag/v.0.4.2).\n\n---\n\n#### Change log v.0.3.4\n\n**Fix**: (`sock`, `facil`, bscrypt) Add missing `static` keywords to prevent state collisions with other libraries.\n\n---\n\n#### Change log v.0.3.3\n\n**Update**: Now using `facil.io` v.0.4.1\n\n**Fix**: (from `facil.io`) fixed the default response `Date` (should have been \"now\", but wasn't initialized).\n\n**Compatibility**: (from `facil.io`) Now checks for HTTP/1.0 clients to determine connection persistence.\n\n**Compatibility**: (from `facil.io`) Added spaces after header names (`:` => `: `), since some parsers don't seem to read the RFC.\n\n---\n\n#### Change log v.0.3.2\n\n**Fix**: (from `facil.io`) fixed thread throttling for better energy conservation.\n\n**Fix**: (from `facil.io`) fixed stream response logging.\n\n---\n\n#### Change log v.0.3.1\n\n**Update**: Follow `facil.io`'s update for healthier thread throttling and energy consumption.\n---\n\n#### Change log v.0.3.1\n\n**Fix**: Fixed a minor issue with the logging of responses where the size of the response is unknown (streamed).\n\n**Gem Specification update**: We updated the gem specification to allow for Rack 1.x users and to update the gem description.\n\n---\n\n#### Change log v.0.3.0\n\n**`facil.io` C Core Update**: The C library core that drives Iodine [`facil.io`](http://facil.io) was updated to version 0.4.0 and Iodine follows closely on the heels of this update. The transition was easy enough and the API remains unchanged... but because the performance gain was so big and because it's a new code base, we opted to bump the minor release version.\n\n---\n\n#### Change log v.0.2.17\n\n**Performance**: Enhanced Performance for single threaded / blocking applications by adding a dedicated IO thread. This is related to issue #14.\n\n---\n\n#### Change log v.0.2.16\n\n**Update**: iodine can now run as a basic HTTP static file server without a Ruby application (no `config.ru`) when the `-www` option is used from the command line.\n\n---\n\n#### Change log v.0.2.15\n\n**Fix**: Fixed typo in logging and code comments, credit to @jmoriau in PR #13.\n\n---\n\n#### Change log v.0.2.14\n\n**Fix**: fixed the experimental `each_write`. An issue was found where passing a block might crash Iodine, since the block will be freed by the GC before Iodine was done with it. Now the block is correctly added to the object Registry, preventing premature memory deallocation.\n\n**Fix**: fixed another issue with `each_write` where a race condition review was performed outside the protected critical section, in some cases this would caused memory to be freed twice and crash the server. This issue is now resolved.\n\n**Deprecation**: In version 0.2.1 we have notified that the the Websocket method `uuid` was deprecated in favor of `conn_id`, as suggested by the [Rack Websocket Draft](https://github.com/rack/rack/pull/1107). This deprecation is now enforced.\n\n---\n\n#### Change log v.0.2.13\n\n**Fix**: Fixed an issue presented in the C layer, where big fragmented Websocket messages sent by the client could cause parsing errors and potentially, in some cases, cause a server thread to spin in a loop (DoS). Credit to @Filly for exposing the issue in the [`facil.io`](https://github.com/boazsegev/facil.io) layer. It should be noted that Chrome is the only browser where this issue could be invoked for testing.\n\n**Credit**: credit to Elia Schito (@elia) and Augusts Bautra (@Epigene) for fixing parts of the documentation (PR #11 , #12).\n\n---\n\n#### Change log v.0.2.12\n\n**Fix**: removed `mempool` after it failed some stress and concurrency tests.\n\n---\n\n#### Change log v.0.2.11\n\n**Fix**: C layer memory pool had a race-condition that could have caused, in some unlikely events, memory allocation failure for Websocket protocol handlers. This had now been addressed and fixed.\n\n**Experimental feature**: added an `each_write` feature to allow direct `write` operations that write data to all open Websocket connections sharing the same process (worker). When this method is called without the optional block, the data will be sent without the need to acquire the Ruby GIL.\n\n**Update**: lessons learned from `facil.io` have been implemented for better compatibility of Iodine's core C layer.\n\n---\n\n#### Change log v.0.2.10\n\n**Update**: added documentation and an extra helper method to set a connection's timeout when using custom protocols (Iodine as an EventMachine alternative).\n\n**C Layer Update** updated the [`facil.io`](http://facil.io) library used, to incorporate the following fixes / update:\n\n* Better cross platform compilation by avoiding some name-space clashes. i.e, fixes a name clash with the `__used` directive / macro, where some OSs (i.e. CentOS) used a similar directive with different semantics.\n\n* Reviewed and fixed some signed vs. unsigned integer comparisons.\n\n* Smoother event scheduling by increasing the event-node's pool size.\n\n* Smoother thread concurrency growth by managing thread `nanosleep` times as thread count dependent.\n\n* Cleared out \"unused variable\" warnings.\n\n* Streamlined the `accept` process to remove a double socket's data clean-up.\n\n* `SERVER_DELAY_IO` is now implemented as an event instead of a stack frame.\n\n* Fixed a possible Linux `sendfile` implementation issue where sometimes errors wouldn't be caught or `sendfile` would be called past a file's limit (edge case handling).\n\n* `bscrypt` random generator (where `dev/random` is unavailable) should now provide more entropy.\n\n\n---\n\n#### Change log v.0.2.9\n\n**Fix**: fixed a gcc-4.8 compatibility issue that prevented iodine 0.2.8 from compiling on Heroku's cedar-14 stack. This was related to missing system include files in gcc-4.8. It should be noted that Heroku's stack and compiler (which utilizes Ubuntu 14) has known issues and / or limited support for some of it's published features... but I should have remembered that before releasing version 0.2.8... sorry about that.\n\n---\n\n#### Change log v.0.2.8\n\n**Memory Performance**: The Websocket connection Protocol now utilizes both a C level memory pool and a local thread storage for temporary data. This helps mitigate possible memory fragmentation issues related to long running processes and long-lived objects. In addition, the socket `read` buffer was moved from the protocol object to a local thread storage (assumes pthreads and not green threads). This minimizes the memory footprint for each connection (at the expense of memory locality) and should allow Iodine to support more concurrent connections using less system resources. Last, but not least, the default message buffer per connection starts at 4Kb instead of 16Kb (grows as needed, up to `Iodine::Rack.max_msg_size`), assuming smaller messages are the norm.\n\n**Housekeeping**: Cleaned up some code, removed old files, copied over the latest [`facil.io`](http://facil.io) library. There's probably some more housekeeping left to perform, especially anywhere where documentation is concerned. I welcome help with documentation.\n\n---\n\n#### Change log v.0.2.7\n\n**Minor Fix**: fixed an issue where a negative number of processes or threads would initiate a very large number of forks, promoting a system resource choke. Limited the number of threads (1023) and processes (127).\n\n**Update**: Automated the number of processes (forks) and threads used when these are not explicitly specified. These follow the number of cores / 2.\n\n---\n\n#### Change log v.0.2.6\n\n**Update**: The IO reactor review will now be delayed until all events scheduled are done. This means that is events schedule future events, no IO data will be reviewed until all scheduled data is done. Foolish use might cause infinite loops that skip the IO reactor, but otherwise performance is improved (since the IO reactor might cause a thread to \"sleep\", delaying event execution).\n\n---\n\n#### Change log v.0.2.5\n\n**Fix:**: fix for issue #9 (credit to Jack Christensen for exposing the issue) caused by an unlocked critical section's \"window of opportunity\" that allowed asynchronous Websocket `each` blocks to run during the tail of the Websocket handshake (while the `on_open` callback was running in parallel).\n\n**Minor Fix**: Fix Iodine::Rack's startup message's `fprintf` call to fit correct argument sizes (Linux warnings).\n\n---\n\n#### Change log v.0.2.4\n\n**Minor Fix**: Patched Iodine against Apple's broken `getrlimit` on macOS. This allows correct auto-setting of open file limits for the socket layer.\n\n**Minor Fix**: Fixed the processor under-utilization warning, where \"0\" might be shown for the number processes instead of \"1\".\n\n**Update**: Added support for the `env` keys `HTTP_VERSION` and `SERVER_PROTOCOL` to indicate the HTTP protocol version. Iodine implements an HTTP/1.1 server, so versions aren't expected to be higher than 1.x.\n\n**Update**: Iodine::Rack startup messages now include details regarding open file limits imposed by the OS (open file limits control the maximum allowed concurrent connections and other resource limits).\n\n---\n\n#### Change log v.0.2.3\n\n**Update**: The `write` system call is now deferred when resources allow, meaning that (as long as the `write` buffer isn't full) `write` is not only non-blocking, but it's performed as a separate event, outside of the Ruby GIL.\n\n**Update**: The global socket `write` buffer was increased to ~16Mb (from ~4Mb), allowing for more concurrent `write` operations. However, the `write` buffer is still limited and `write` might block while the buffer is full. Blocking and \"hanging\" the server until there's enough room in the buffer for the requested `write` will slow the server down while keeping it healthy and more secure. IMHO, it is the lesser of two evils.\n\n---\n\n#### Change log v.0.2.2\n\n**Update** The static file service now supports `ETag` caching, sending a 304 (not changed) response for valid ETags.\n\n**Update**: A performance warning now shows if the CPUs are significantly under-utilized (less than half are used) of if too many are utilized (more than double the amount of CPUs), warning against under-utilization or excessive context switching (respectively).\n\n---\n\n#### Change log v.0.2.1\n\n**Notice**: The [Rack Websocket Draft](https://github.com/rack/rack/pull/1107) does not support the `each` and `defer` methods. Although I tried to maintain these as part of the draft, the community preferred to leave the implementation of these to the client (rather then the server). If collisions occur, these methods might be removed in the future.\n\n**Update**: Websockets now support the `has_pending?` method and `on_ready` callback, as suggested by the [Rack Websocket Draft](https://github.com/rack/rack/pull/1107).\n\n**Update**: deprecated the Websocket method `uuid` in favor of `conn_id`, as suggested by the [Rack Websocket Draft](https://github.com/rack/rack/pull/1107).\n\n**Fix**: fixed an issue were the server would crash when attempting to send a long enough websocket message.\n\n---\n\n#### Change log v.0.2.0\n\nThis version is a total rewrite. The API is totally changed, nothing stayed.\n\nIodine is now written in C, as a C extension for Ruby. The little, if any, ruby code written is just the fluff and feathers.\n\n---\n\n### deprecation of the 0.1.x version line\n\n#### Change log v.0.1.21\n\n**Optimization**: Minor optimizations. i.e. - creates 1 less Time object per request (The logging still creates a Time object unless disabled using `Iodine.logger = nil`).\n\n**Security**: HTTP/1 now reviews the Body's size as it grows (similar to HTTP/2), mitigating any potential attacks related to the size of the data sent.\n\n**Logs**: Log the number of threads utilized when starting up the server.\n\n---\n\n#### Change log v.0.1.20\n\n**Update/Fix**: Updated the `x-forwarded-for` header recognition, to accommodate an Array formatting sometimes used (`[\"ip1\", \"ip2\", ...]`).\n\n**Update**: native support for the `Forwarded` header HTTP.\n\n**API Changes**: `Iodine::HTTP.max_http_buffer` was replaced with `Iodine::HTTP.max_body_size`, for a better understanding of the method's result.\n\n---\n\n#### Change log v.0.1.19\n\n**Update**: added the `go_away` method to the HTTP/1 protocol, for seamless connection closeing across HTTP/2, HTTP/1 and Websockets.\n\n---\n\n#### Change log v.0.1.18\n\n**Update**: The request now has the shortcut method `Request#host_name` for accessing the host's name (without the port part of the string).\n\n---\n\n#### Change log v.0.1.17\n\n**Credit**: thanks you @frozenfoxx for going through the readme and fixing my broken grammar.\n\n**Fix**: fixed an issue where multiple Pings might get sent when pinging takes time. Now pings are exclusive (run within their own Mutex).\n\n**Fix**: HTTP/2 is back... sorry about breaking it in the 0.1.16 version. When I updated the write buffer I forgot to write the status of the response, causing a protocol error related with the headers. It's now working again.\n\n**Update**: by default and for security reasons, session id's created through a secure connection (SSL) will NOT be available on a non secure connection (SSL/TLS). However, while upgrading to the encrypted connection, the non_encrypted session storage is now available for review using the `Response#session_old` method.\n\n* Remember that sessions are never really safe, no matter how much we guard them. Session hijacking is far too easy. This is why Iodine stores the session data locally and not within the session cookie. This is also why you should review any authentication before performing sensitive tasks based on session stored authentication data.\n\n---\n\n#### Change log v.0.1.16\n\n**Performance**: HTTP/1 and HTTP/2 connections now share and recycle their write buffer when while reading the response body and writing it to the IO. This (hopefully) prevents excess `malloc` calls by the interpreter.\n\n---\n\n#### Change log v.0.1.15\n\n**Update**: IO reactor will now update IO status even when tasks are pending. IO will still be read only when there are no more tasks to handle, but this allows chained tasks to relate to the updated IO status. i.e. this should improve Websocket availability for broadcasting (delay from connection to availability might occur until IO is registered).\n\n**Update**: Websockets now support the `on_ping` callback, which will be called whenever a ping was sent without error.\n\n---\n\n#### Change log v.0.1.14\n\n**Update**: the Response now supports `redirect_to` for both permanent and temporary redirection, with an optional `flash` cookie setup.\n\n**Performance**: the Protocol class now recycles the data string as a thread global socket buffer (different threads have different buffer strings), preventing excessive `malloc` calls by the Ruby interpreter. To keep the `data` (in `on_message(data)`) past the `on_message` method's scope, be sure to duplicate it using `data.dup`, or the string's buffer will be recycled.\n\n---\n\n#### Change log v.0.1.13\n\n**Change**: Session cookie lifetime is now limited to the browser's session. The local data will still persist until the tmp-folder is cleared (when using session file storage).\n\n**Fix**: renamed the SSL session token so that the SSL session id isn't lost when a non-secure session is used.\n\n**Fix**: The `flash` cookie-jar will now actively prevent Symbol and String keys from overlapping.\n\n**Compatibility**: minor fixes and changes in preparation for Ruby 2.3.0. These may affect performance due to slower String initialization times.\n\n---\n\n#### Change log v.0.1.12\n\n**Update**: Passing a hash as the cookie value will allow to set cookie parameters using the {Response#set_cookie} options. i.e.: `cookies['key']= {value: \"lock\", max_age: 20}`.\n\n**Security**: set the HTTPOnly flag for session id cookies.\n\n---\n\n#### Change log v.0.1.11\n\n**Fix**: fixed the Rack server Handler, which was broken in version 0.1.10.\n\n---\n\n#### Change log v.0.1.10\n\n**Fix**: make sure the WebsocketClient doesn't automatically renew the connection when the connection was manually closed by the client.\n\n**Performance**: faster TimedEvent clearing when manually stopped. Minor improvements to direct big-file sending (recycle buffer to avoid `malloc`).\n\n---\n\n#### Change log v.0.1.9\n\n**Fix**: WebsocketClient connection renewal will now keep the same WebsocketClient instance object.\n\n**Update** Creating a TimedEvent before Iodine starts running will automatically 'nudge' Iodine into \"Task polling\" mode, cycling until the user signals a stop.\n\n**Update**: repeatedly calling `Iodine.force_start!` will now be ignored, as might have been expected. Once Iodine had started, `force_start!` cannot be called until Iodine had finished (and even than, Iodine might never be as fresh nor as young as it was).\n\n---\n\n#### Change log v.0.1.8\n\n**Fix**: Websocket broadcasts are now correctly executed within the IO's mutex locker. This maintains the idea that only one thread at a time should be executing code on behalf of any given Protocol object (\"yes\" to concurrency between objects but \"no\" to concurrency within objects).\n\n**Fix** fixed an issue where manually setting the number of threads for Rack applications (when using Iodine as a Rack server), the setting was mistakenly ignored.\n\n**Fix** fixed an issue where sometimes extracting the HTTP response's body would fail (if body is `nil`).\n\n**Feature**: session objects are now aware of the session id. The session id is available by calling `response.session.id`\n\n**Fix** fixed an issue where HTTP streaming wasn't chunk encoding after connection error handling update.\n\n**Fix** fixed an issue where HTTP streaming would disconnect while still processing. Streaming timeout now extended to 15 seconds between response writes.\n\n---\n\n#### Change log v.0.1.7\n\nRemoved a deprecation notice for blocking API. Client API will remain blocking due to use-case requirements.\n\n---\n\n#### Change log v.0.1.6\n\n**Fix**: fixed an issue where a session key-value pair might not get deleted when using `session.delete key` and the `key` is not a String object. Also, now setting a key's value to `nil` should delete the key-value pair.\n\n**Fix**: fixed an issue where WebsocketClient wouldn't mask outgoing data, causing some servers to respond badly.\n\n**Performance**: minor performance improvements to the Websocket parser, for unmasking messages.\n\n**Deprecation notice**:\n\n(removed after reviewing use-cases).\n\n---\n\n#### Change log v.0.1.5\n\n**Feature**: The Response#body can now be set to a File object, allowing Iodine to preserve memory when serving large static files from disc. Limited Range requests are also supported - together, these changes allow Iodine to serve media files (such as movies) while suffering a smaller memory penalty and supporting a wider variety of players (Safari requires Range request support for it's media player).\n\n**Fix**: Fixed an issue where Iodine might take a long time to shut down after a Fatal Error during the server initialization.\n\n---\n\n#### Change log v.0.1.4\n\n**Fix**: fixed an issue with where the WebsocketClient#on_close wouldn't be called for a renewable Websocket connection during shutdown.\n\n**Fix**: fixed an issue where a protocol's #on_close callback wouldn't be called if the Iodine server receives a shutdown signal.\n\n**Fix**: fixed an issue where HTTP2 header size limit condition was not recognized by the Ruby parser (a double space issue, might be an issue with the 2.2.3 Ruby parser).\n\n---\n\n#### Change log v.0.1.3\n\n**Fix**: fixed an issue with the new form/multipart parser, where the '+' sign would be converted to spaces on form fields (not uploaded files), causing in-advert potential change to the original POSTed data.\n\n---\n\n#### Change log v.0.1.2\n\n**Fix**: fixed an issue where the default implementation of `ping` did not reset the timeout if the connection wasn't being closed (the default implementation checks if the Protocol is working on existing data and either resets the timer allowing the work to complete or closes the connection if no work is being done).\n\n---\n\n#### Change log v.0.1.1\n\n**Fix**: Fixed an issue where slow processing of HTTP/1 requests could cause timeout disconnections to occur while the request is being processed.\n\n**Change/Security**: Uploads now use temporary files. Aceessing the data for file uploads should be done throught the `:file` property of the params hash (i.e. `params[:upload_field_name][:file]`). Using the `:data` property (old API) would cause the whole file to be dumped to the memory and the file's content will be returned as a String.\n\n**Change/Security**: HTTP upload limits are now enforced. The current default limit is about ~0.5GB.\n\n**Feature**: WebsocketClient now supports both an auto-connection-renewal and a polling machanism built in to the `WebsocketClient.connect` API. The polling feature is mostly a handy helper for testing, as it is assumed that connection renewal and pub/sub offer a better design than polling.\n\n**Logging**: Better HTTP error logging and recognition.\n\n---\n\n#### Change log v.0.1.0\n\n**First actual release**:\n\nWe learn, we evolve, we change... but we remember our past and do our best to help with the transition and make it worth the toll it takes on our resources.\n\nI took much of the code used for GRHTTP and GReactor, changed it, morphed it and united it into the singular Iodine gem. This includes Major API changes, refactoring of code, bug fixes and changes to the core approach of how a task/io based application should behave or be constructed.\n\nFor example, Iodine kicks in automatically when the setup script is done, so that all code is run from within tasks and IO connections and no code is run in parallel to the Iodine engine.\n\nAnother example, Iodine now favors Object Oriented code, so that some actions - such as writing a network service - require classes of objects to be declared or inherited (i.e. the Protocol class).\n\nThis allows objects to manage their data as if they were in a single thread environment, unless the objects themselves are calling asynchronous code. For example, the Protocol class makes sure that the `on_open` and `on_message(data)` callbacks are executed within a Mutex (`on_close` is an exception to the rule since it is assumed that objects should be prepared to loose network connection at any moment).\n\nAnother example is that real-life deployment preferences were favored over adjustability or features. This means that some command-line arguments are automatically recognized (such as the `-p <port>` argument) and that Iodine assumes a single web service per script/process (whereas GReactor and GRHTTP allowed multiple listening sockets).\n\nI tested this new gem during the 0.0.x version releases, and I feel that version 0.1.0 is stable enough to work with. For instance, I left the Iodine server running all night under stress (repeatedly benchmarking it)... millions of requests later, under heavy load, a restart wasn't required and memory consumption didn't show any increase after the warmup period.\n\n\n\n## License\n\nThe gem is available as open source under the terms of the [MIT License](http://opensource.org/licenses/MIT).\n", "/* *****************************************************************************\nCopyright: Boaz Segev, 2018-2019\nLicense: MIT\n\nFeel free to copy, use and enjoy according to the license provided.\n***************************************************************************** */\n\n#include <fio.h>\n\n#define FIO_INCLUDE_STR\n#include <fio.h>\n\n#define FIO_FORCE_MALLOC_TMP 1\n#define FIO_INCLUDE_LINKED_LIST\n#include <fio.h>\n\n#include <ctype.h>\n#include <errno.h>\n#include <limits.h>\n#include <pthread.h>\n#include <sys/mman.h>\n#include <unistd.h>\n\n#include <netdb.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n\n#include <poll.h>\n#include <sys/ioctl.h>\n#include <sys/resource.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <sys/un.h>\n#include <sys/wait.h>\n\n#include <arpa/inet.h>\n\n/* force poll for testing? */\n#ifndef FIO_ENGINE_POLL\n#define FIO_ENGINE_POLL 0\n#endif\n\n#if !FIO_ENGINE_POLL && !FIO_ENGINE_EPOLL && !FIO_ENGINE_KQUEUE\n#if defined(__linux__)\n#define FIO_ENGINE_EPOLL 1\n#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__NetBSD__) ||     \\\n    defined(__OpenBSD__) || defined(__bsdi__) || defined(__DragonFly__)\n#define FIO_ENGINE_KQUEUE 1\n#else\n#define FIO_ENGINE_POLL 1\n#endif\n#endif\n\n/* for kqueue and epoll only */\n#ifndef FIO_POLL_MAX_EVENTS\n#define FIO_POLL_MAX_EVENTS 64\n#endif\n\n#ifndef FIO_POLL_TICK\n#define FIO_POLL_TICK 1000\n#endif\n\n#ifndef FIO_USE_URGENT_QUEUE\n#define FIO_USE_URGENT_QUEUE 1\n#endif\n\n#ifndef DEBUG_SPINLOCK\n#define DEBUG_SPINLOCK 0\n#endif\n\n/* Slowloris mitigation  (must be less than 1<<16) */\n#ifndef FIO_SLOWLORIS_LIMIT\n#define FIO_SLOWLORIS_LIMIT (1 << 10)\n#endif\n\n#if !defined(__clang__) && !defined(__GNUC__)\n#define __thread _Thread_value\n#endif\n\n#ifndef FIO_TLS_WEAK\n#define FIO_TLS_WEAK __attribute__((weak))\n#endif\n\n/* Mitigates MAP_ANONYMOUS not being defined on older versions of MacOS */\n#if !defined(MAP_ANONYMOUS)\n#if defined(MAP_ANON)\n#define MAP_ANONYMOUS MAP_ANON\n#else\n#define MAP_ANONYMOUS 0\n#endif\n#endif\n\n/* *****************************************************************************\nEvent deferring (declarations)\n***************************************************************************** */\n\nstatic void deferred_on_close(void *uuid_, void *pr_);\nstatic void deferred_on_shutdown(void *arg, void *arg2);\nstatic void deferred_on_ready(void *arg, void *arg2);\nstatic void deferred_on_data(void *uuid, void *arg2);\nstatic void deferred_ping(void *arg, void *arg2);\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n                       Main State Machine Data Structures\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\ntypedef void (*fio_uuid_link_fn)(void *);\n#define FIO_SET_NAME fio_uuid_links\n#define FIO_SET_OBJ_TYPE fio_uuid_link_fn\n#define FIO_SET_OBJ_COMPARE(o1, o2) 1\n#include <fio.h>\n\n/** User-space socket buffer data */\ntypedef struct fio_packet_s fio_packet_s;\nstruct fio_packet_s {\n  fio_packet_s *next;\n  int (*write_func)(int fd, struct fio_packet_s *packet);\n  void (*dealloc)(void *buffer);\n  union {\n    void *buffer;\n    intptr_t fd;\n  } data;\n  uintptr_t offset;\n  uintptr_t length;\n};\n\n/** Connection data (fd_data) */\ntypedef struct {\n  /* current data to be send */\n  fio_packet_s *packet;\n  /** the last packet in the queue. */\n  fio_packet_s **packet_last;\n  /* Data sent so far */\n  size_t sent;\n  /* fd protocol */\n  fio_protocol_s *protocol;\n  /* timer handler */\n  time_t active;\n  /** The number of pending packets that are in the queue. */\n  uint16_t packet_count;\n  /* timeout settings */\n  uint8_t timeout;\n  /* indicates that the fd should be considered scheduled (added to poll) */\n  fio_lock_i scheduled;\n  /* protocol lock */\n  fio_lock_i protocol_lock;\n  /* used to convert `fd` to `uuid` and validate connections */\n  uint8_t counter;\n  /* socket lock */\n  fio_lock_i sock_lock;\n  /** Connection is open */\n  uint8_t open;\n  /** indicated that the connection should be closed. */\n  uint8_t close;\n  /** peer address length */\n  uint8_t addr_len;\n  /** peer address length */\n  uint8_t addr[48];\n  /** RW hooks. */\n  fio_rw_hook_s *rw_hooks;\n  /** RW udata. */\n  void *rw_udata;\n  /* Objects linked to the UUID */\n  fio_uuid_links_s links;\n} fio_fd_data_s;\n\ntypedef struct {\n  struct timespec last_cycle;\n  /* connection capacity */\n  uint32_t capa;\n  /* connections counted towards shutdown (NOT while running) */\n  uint32_t connection_count;\n  /* thread list */\n  fio_ls_s thread_ids;\n  /* active workers */\n  uint16_t workers;\n  /* timer handler */\n  uint16_t threads;\n  /* timeout review loop flag */\n  uint8_t need_review;\n  /* spinning down process */\n  uint8_t volatile active;\n  /* worker process flag - true also for single process */\n  uint8_t is_worker;\n  /* polling and global lock */\n  fio_lock_i lock;\n  /* The highest active fd with a protocol object */\n  uint32_t max_protocol_fd;\n  /* timer handler */\n  pid_t parent;\n#if FIO_ENGINE_POLL\n  struct pollfd *poll;\n#endif\n  fio_fd_data_s info[];\n} fio_data_s;\n\n/** The logging level */\n#if DEBUG\nint FIO_LOG_LEVEL = FIO_LOG_LEVEL_DEBUG;\n#else\nint FIO_LOG_LEVEL = FIO_LOG_LEVEL_INFO;\n#endif\nstatic fio_data_s *fio_data = NULL;\n\n/* used for protocol locking by task type. */\ntypedef struct {\n  fio_lock_i locks[3];\n  unsigned rsv : 8;\n} protocol_metadata_s;\n\n/* used for accessing the protocol locking in a safe byte aligned way. */\nunion protocol_metadata_union_u {\n  size_t opaque;\n  protocol_metadata_s meta;\n};\n\n#define fd_data(fd) (fio_data->info[(uintptr_t)(fd)])\n#define uuid_data(uuid) fd_data(fio_uuid2fd((uuid)))\n#define fd2uuid(fd)                                                            \\\n  ((intptr_t)((((uintptr_t)(fd)) << 8) | fd_data((fd)).counter))\n\n/**\n * Returns the maximum number of open files facil.io can handle per worker\n * process.\n *\n * Total OS limits might apply as well but aren't shown.\n *\n * The value of 0 indicates either that the facil.io library wasn't initialized\n * yet or that it's resources were released.\n */\nsize_t fio_capa(void) {\n  if (fio_data)\n    return fio_data->capa;\n  return 0;\n}\n\n/* *****************************************************************************\nPacket allocation (for socket's user-buffer)\n***************************************************************************** */\n\nstatic inline void fio_packet_free(fio_packet_s *packet) {\n  packet->dealloc(packet->data.buffer);\n  fio_free(packet);\n}\nstatic inline fio_packet_s *fio_packet_alloc(void) {\n  fio_packet_s *packet = fio_malloc(sizeof(*packet));\n  FIO_ASSERT_ALLOC(packet);\n  return packet;\n}\n\n/* *****************************************************************************\nCore Connection Data Clearing\n***************************************************************************** */\n\n/* set the minimal max_protocol_fd */\nstatic void fio_max_fd_min(uint32_t fd) {\n  if (fio_data->max_protocol_fd > fd)\n    return;\n  fio_lock(&fio_data->lock);\n  if (fio_data->max_protocol_fd < fd)\n    fio_data->max_protocol_fd = fd;\n  fio_unlock(&fio_data->lock);\n}\n\n/* set the minimal max_protocol_fd */\nstatic void fio_max_fd_shrink(void) {\n  fio_lock(&fio_data->lock);\n  uint32_t fd = fio_data->max_protocol_fd;\n  while (fd && fd_data(fd).protocol == NULL)\n    --fd;\n  fio_data->max_protocol_fd = fd;\n  fio_unlock(&fio_data->lock);\n}\n\n/* resets connection data, marking it as either open or closed. */\nstatic inline int fio_clear_fd(intptr_t fd, uint8_t is_open) {\n  fio_packet_s *packet;\n  fio_protocol_s *protocol;\n  fio_rw_hook_s *rw_hooks;\n  void *rw_udata;\n  fio_uuid_links_s links;\n  fio_lock(&(fd_data(fd).sock_lock));\n  links = fd_data(fd).links;\n  packet = fd_data(fd).packet;\n  protocol = fd_data(fd).protocol;\n  rw_hooks = fd_data(fd).rw_hooks;\n  rw_udata = fd_data(fd).rw_udata;\n  fd_data(fd) = (fio_fd_data_s){\n      .open = is_open,\n      .sock_lock = fd_data(fd).sock_lock,\n      .protocol_lock = fd_data(fd).protocol_lock,\n      .rw_hooks = (fio_rw_hook_s *)&FIO_DEFAULT_RW_HOOKS,\n      .counter = fd_data(fd).counter + 1,\n      .packet_last = &fd_data(fd).packet,\n  };\n  fio_unlock(&(fd_data(fd).sock_lock));\n  if (rw_hooks && rw_hooks->cleanup)\n    rw_hooks->cleanup(rw_udata);\n  while (packet) {\n    fio_packet_s *tmp = packet;\n    packet = packet->next;\n    fio_packet_free(tmp);\n  }\n  if (fio_uuid_links_count(&links)) {\n    FIO_SET_FOR_LOOP(&links, pos) {\n      if (pos->hash)\n        pos->obj((void *)pos->hash);\n    }\n  }\n  fio_uuid_links_free(&links);\n  if (protocol && protocol->on_close) {\n    fio_defer(deferred_on_close, (void *)fd2uuid(fd), protocol);\n  }\n  if (is_open)\n    fio_max_fd_min(fd);\n  return 0;\n}\n\nstatic inline void fio_force_close_in_poll(intptr_t uuid) {\n  uuid_data(uuid).close = 2;\n  fio_force_close(uuid);\n}\n\n/* *****************************************************************************\nProtocol Locking and UUID validation\n***************************************************************************** */\n\n/* Macro for accessing the protocol locking / metadata. */\n#define prt_meta(prt) (((union protocol_metadata_union_u *)(&(prt)->rsv))->meta)\n\n/** locks a connection's protocol returns a pointer that need to be unlocked. */\ninline static fio_protocol_s *protocol_try_lock(intptr_t fd,\n                                                enum fio_protocol_lock_e type) {\n  errno = 0;\n  if (fio_trylock(&fd_data(fd).protocol_lock))\n    goto would_block;\n  fio_protocol_s *pr = fd_data(fd).protocol;\n  if (!pr) {\n    fio_unlock(&fd_data(fd).protocol_lock);\n    goto invalid;\n  }\n  if (fio_trylock(&prt_meta(pr).locks[type])) {\n    fio_unlock(&fd_data(fd).protocol_lock);\n    goto would_block;\n  }\n  fio_unlock(&fd_data(fd).protocol_lock);\n  return pr;\nwould_block:\n  errno = EWOULDBLOCK;\n  return NULL;\ninvalid:\n  errno = EBADF;\n  return NULL;\n}\n/** See `fio_protocol_try_lock` for details. */\ninline static void protocol_unlock(fio_protocol_s *pr,\n                                   enum fio_protocol_lock_e type) {\n  fio_unlock(&prt_meta(pr).locks[type]);\n}\n\n/** returns 1 if the UUID is valid and 0 if it isn't. */\n#define uuid_is_valid(uuid)                                                    \\\n  ((intptr_t)(uuid) >= 0 &&                                                    \\\n   ((uint32_t)fio_uuid2fd((uuid))) < fio_data->capa &&                         \\\n   ((uintptr_t)(uuid)&0xFF) == uuid_data((uuid)).counter)\n\n/* public API. */\nfio_protocol_s *fio_protocol_try_lock(intptr_t uuid,\n                                      enum fio_protocol_lock_e type) {\n  if (!uuid_is_valid(uuid)) {\n    errno = EBADF;\n    return NULL;\n  }\n  return protocol_try_lock(fio_uuid2fd(uuid), type);\n}\n\n/* public API. */\nvoid fio_protocol_unlock(fio_protocol_s *pr, enum fio_protocol_lock_e type) {\n  protocol_unlock(pr, type);\n}\n\n/* *****************************************************************************\nUUID validation and state\n***************************************************************************** */\n\n/* public API. */\nintptr_t fio_fd2uuid(int fd) {\n  if (fd < 0 || (size_t)fd >= fio_data->capa)\n    return -1;\n  if (!fd_data(fd).open) {\n    fio_lock(&fd_data(fd).protocol_lock);\n    fio_clear_fd(fd, 1);\n    fio_unlock(&fd_data(fd).protocol_lock);\n  }\n  return fd2uuid(fd);\n}\n\n/* public API. */\nint fio_is_valid(intptr_t uuid) { return uuid_is_valid(uuid); }\n\n/* public API. */\nint fio_is_closed(intptr_t uuid) {\n  return !uuid_is_valid(uuid) || !uuid_data(uuid).open || uuid_data(uuid).close;\n}\n\nvoid fio_stop(void) {\n  if (fio_data)\n    fio_data->active = 0;\n}\n\n/* public API. */\nint16_t fio_is_running(void) { return fio_data && fio_data->active; }\n\n/* public API. */\nstruct timespec fio_last_tick(void) {\n  return fio_data->last_cycle;\n}\n\n#define touchfd(fd) fd_data((fd)).active = fio_data->last_cycle.tv_sec\n\n/* public API. */\nvoid fio_touch(intptr_t uuid) {\n  if (uuid_is_valid(uuid))\n    touchfd(fio_uuid2fd(uuid));\n}\n\n/* public API. */\nfio_str_info_s fio_peer_addr(intptr_t uuid) {\n  if (fio_is_closed(uuid) || !uuid_data(uuid).addr_len)\n    return (fio_str_info_s){.data = NULL, .len = 0, .capa = 0};\n  return (fio_str_info_s){.data = (char *)uuid_data(uuid).addr,\n                          .len = uuid_data(uuid).addr_len,\n                          .capa = 0};\n}\n\n/**\n * Writes the local machine address (qualified host name) to the buffer.\n *\n * Returns the amount of data written (excluding the NUL byte).\n *\n * `limit` is the maximum number of bytes in the buffer, including the NUL byte.\n *\n * If the returned value == limit - 1, the result might have been truncated.\n *\n * If 0 is returned, an erro might have occured (see `errno`) and the contents\n * of `dest` is undefined.\n */\nsize_t fio_local_addr(char *dest, size_t limit) {\n  if (gethostname(dest, limit))\n    return 0;\n\n  struct addrinfo hints, *info;\n  memset(&hints, 0, sizeof hints);\n  hints.ai_family = AF_UNSPEC;     // don't care IPv4 or IPv6\n  hints.ai_socktype = SOCK_STREAM; // TCP stream sockets\n  hints.ai_flags = AI_CANONNAME;   // get cannonical name\n\n  if (getaddrinfo(dest, \"http\", &hints, &info) != 0)\n    return 0;\n\n  for (struct addrinfo *pos = info; pos; pos = pos->ai_next) {\n    if (pos->ai_canonname) {\n      size_t len = strlen(pos->ai_canonname);\n      if (len >= limit)\n        len = limit - 1;\n      memcpy(dest, pos->ai_canonname, len);\n      dest[len] = 0;\n      freeaddrinfo(info);\n      return len;\n    }\n  }\n\n  freeaddrinfo(info);\n  return 0;\n}\n\n/* *****************************************************************************\nUUID attachments (linking objects to the UUID's lifetime)\n***************************************************************************** */\n\n/* public API. */\nvoid fio_uuid_link(intptr_t uuid, void *obj, void (*on_close)(void *obj)) {\n  if (!uuid_is_valid(uuid))\n    goto invalid;\n  fio_lock(&uuid_data(uuid).sock_lock);\n  if (!uuid_is_valid(uuid))\n    goto locked_invalid;\n  fio_uuid_links_overwrite(&uuid_data(uuid).links, (uintptr_t)obj, on_close,\n                           NULL);\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  return;\nlocked_invalid:\n  fio_unlock(&uuid_data(uuid).sock_lock);\ninvalid:\n  errno = EBADF;\n  on_close(obj);\n}\n\n/* public API. */\nint fio_uuid_unlink(intptr_t uuid, void *obj) {\n  if (!uuid_is_valid(uuid))\n    goto invalid;\n  fio_lock(&uuid_data(uuid).sock_lock);\n  if (!uuid_is_valid(uuid))\n    goto locked_invalid;\n  /* default object comparison is always true */\n  int ret =\n      fio_uuid_links_remove(&uuid_data(uuid).links, (uintptr_t)obj, NULL, NULL);\n  if (ret)\n    errno = ENOTCONN;\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  return ret;\nlocked_invalid:\n  fio_unlock(&uuid_data(uuid).sock_lock);\ninvalid:\n  errno = EBADF;\n  return -1;\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n                         Default Thread / Fork handler\n\n                           And Concurrency Helpers\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/**\nOVERRIDE THIS to replace the default `fork` implementation.\n\nBehaves like the system's `fork`.\n*/\n#pragma weak fio_fork\nint __attribute__((weak)) fio_fork(void) { return fork(); }\n\n/**\n * OVERRIDE THIS to replace the default pthread implementation.\n *\n * Accepts a pointer to a function and a single argument that should be executed\n * within a new thread.\n *\n * The function should allocate memory for the thread object and return a\n * pointer to the allocated memory that identifies the thread.\n *\n * On error NULL should be returned.\n */\n#pragma weak fio_thread_new\nvoid *__attribute__((weak))\nfio_thread_new(void *(*thread_func)(void *), void *arg) {\n  pthread_t *thread = malloc(sizeof(*thread));\n  FIO_ASSERT_ALLOC(thread);\n  if (pthread_create(thread, NULL, thread_func, arg))\n    goto error;\n  return thread;\nerror:\n  free(thread);\n  return NULL;\n}\n\n/**\n * OVERRIDE THIS to replace the default pthread implementation.\n *\n * Frees the memory associated with a thread identifier (allows the thread to\n * run it's course, just the identifier is freed).\n */\n#pragma weak fio_thread_free\nvoid __attribute__((weak)) fio_thread_free(void *p_thr) {\n  if (*((pthread_t *)p_thr)) {\n    pthread_detach(*((pthread_t *)p_thr));\n  }\n  free(p_thr);\n}\n\n/**\n * OVERRIDE THIS to replace the default pthread implementation.\n *\n * Accepts a pointer returned from `fio_thread_new` (should also free any\n * allocated memory) and joins the associated thread.\n *\n * Return value is ignored.\n */\n#pragma weak fio_thread_join\nint __attribute__((weak)) fio_thread_join(void *p_thr) {\n  if (!p_thr || !(*((pthread_t *)p_thr)))\n    return -1;\n  pthread_join(*((pthread_t *)p_thr), NULL);\n  *((pthread_t *)p_thr) = (pthread_t)NULL;\n  free(p_thr);\n  return 0;\n}\n\n/* *****************************************************************************\nSuspending and renewing thread execution (signaling events)\n***************************************************************************** */\n\n#ifndef DEFER_THROTTLE\n#define DEFER_THROTTLE 2097148UL\n#endif\n#ifndef FIO_DEFER_THROTTLE_LIMIT\n#define FIO_DEFER_THROTTLE_LIMIT 134217472UL\n#endif\n\n/**\n * The polling throttling model will use pipes to suspend and resume threads...\n *\n * However, it seems the approach is currently broken, at least on macOS.\n * I don't know why.\n *\n * If polling is disabled, the progressive throttling model will be used.\n *\n * The progressive throttling makes concurrency and parallelism likely, but uses\n * progressive nano-sleep throttling system that is less exact.\n */\n#ifndef FIO_DEFER_THROTTLE_POLL\n#define FIO_DEFER_THROTTLE_POLL 0\n#endif\n\ntypedef struct fio_thread_queue_s {\n  fio_ls_embd_s node;\n  int fd_wait;   /* used for weaiting (read signal) */\n  int fd_signal; /* used for signalling (write) */\n} fio_thread_queue_s;\n\nfio_ls_embd_s fio_thread_queue = FIO_LS_INIT(fio_thread_queue);\nfio_lock_i fio_thread_lock = FIO_LOCK_INIT;\nstatic __thread fio_thread_queue_s fio_thread_data = {.fd_wait = -1,\n                                                      .fd_signal = -1};\n\nFIO_FUNC inline void fio_thread_make_suspendable(void) {\n  if (fio_thread_data.fd_signal >= 0)\n    return;\n  int fd[2] = {0, 0};\n  int ret = pipe(fd);\n  FIO_ASSERT(ret == 0, \"`pipe` failed.\");\n  FIO_ASSERT(fio_set_non_block(fd[0]) == 0,\n             \"(fio) couldn't set internal pipe to non-blocking mode.\");\n  FIO_ASSERT(fio_set_non_block(fd[1]) == 0,\n             \"(fio) couldn't set internal pipe to non-blocking mode.\");\n  fio_thread_data.fd_wait = fd[0];\n  fio_thread_data.fd_signal = fd[1];\n}\n\nFIO_FUNC inline void fio_thread_cleanup(void) {\n  if (fio_thread_data.fd_signal < 0)\n    return;\n  close(fio_thread_data.fd_wait);\n  close(fio_thread_data.fd_signal);\n  fio_thread_data.fd_wait = -1;\n  fio_thread_data.fd_signal = -1;\n}\n\n/* suspend thread execution (might be resumed unexpectedly) */\nFIO_FUNC void fio_thread_suspend(void) {\n  fio_lock(&fio_thread_lock);\n  fio_ls_embd_push(&fio_thread_queue, &fio_thread_data.node);\n  fio_unlock(&fio_thread_lock);\n  struct pollfd list = {\n      .events = (POLLPRI | POLLIN),\n      .fd = fio_thread_data.fd_wait,\n  };\n  if (poll(&list, 1, 5000) > 0) {\n    /* thread was removed from the list through signal */\n    uint64_t data;\n    int r = read(fio_thread_data.fd_wait, &data, sizeof(data));\n    (void)r;\n  } else {\n    /* remove self from list */\n    fio_lock(&fio_thread_lock);\n    fio_ls_embd_remove(&fio_thread_data.node);\n    fio_unlock(&fio_thread_lock);\n  }\n}\n\n/* wake up a single thread */\nFIO_FUNC void fio_thread_signal(void) {\n  fio_thread_queue_s *t;\n  int fd = -2;\n  fio_lock(&fio_thread_lock);\n  t = (fio_thread_queue_s *)fio_ls_embd_shift(&fio_thread_queue);\n  if (t)\n    fd = t->fd_signal;\n  fio_unlock(&fio_thread_lock);\n  if (fd >= 0) {\n    uint64_t data = 1;\n    int r = write(fd, (void *)&data, sizeof(data));\n    (void)r;\n  } else if (fd == -1) {\n    /* hardly the best way, but there's a thread sleeping on air */\n    kill(getpid(), SIGCONT);\n  }\n}\n\n/* wake up all threads */\nFIO_FUNC void fio_thread_broadcast(void) {\n  while (fio_ls_embd_any(&fio_thread_queue)) {\n    fio_thread_signal();\n  }\n}\n\nstatic size_t fio_poll(void);\n/**\n * A thread entering this function should wait for new evennts.\n */\nstatic void fio_defer_thread_wait(void) {\n#if FIO_ENGINE_POLL\n  fio_poll();\n  return;\n#endif\n  if (FIO_DEFER_THROTTLE_POLL) {\n    fio_thread_suspend();\n  } else {\n    /* keeps threads active (concurrent), but reduces performance */\n    static __thread size_t static_throttle = 262143UL;\n    fio_throttle_thread(static_throttle);\n    if (fio_defer_has_queue())\n      static_throttle = 1;\n    else if (static_throttle < FIO_DEFER_THROTTLE_LIMIT)\n      static_throttle = (static_throttle << 1);\n  }\n}\n\nstatic inline void fio_defer_on_thread_start(void) {\n  if (FIO_DEFER_THROTTLE_POLL)\n    fio_thread_make_suspendable();\n}\nstatic inline void fio_defer_thread_signal(void) {\n  if (FIO_DEFER_THROTTLE_POLL)\n    fio_thread_signal();\n}\nstatic inline void fio_defer_on_thread_end(void) {\n  if (FIO_DEFER_THROTTLE_POLL) {\n    fio_thread_broadcast();\n    fio_thread_cleanup();\n  }\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                             Task Management\n\n                  Task / Event schduling and execution\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n#ifndef DEFER_QUEUE_BLOCK_COUNT\n#if UINTPTR_MAX <= 0xFFFFFFFF\n/* Almost a page of memory on most 32 bit machines: ((4096/4)-8)/3 */\n#define DEFER_QUEUE_BLOCK_COUNT 338\n#else\n/* Almost a page of memory on most 64 bit machines: ((4096/8)-8)/3 */\n#define DEFER_QUEUE_BLOCK_COUNT 168\n#endif\n#endif\n\n/* task node data */\ntypedef struct {\n  void (*func)(void *, void *);\n  void *arg1;\n  void *arg2;\n} fio_defer_task_s;\n\n/* task queue block */\ntypedef struct fio_defer_queue_block_s fio_defer_queue_block_s;\nstruct fio_defer_queue_block_s {\n  fio_defer_task_s tasks[DEFER_QUEUE_BLOCK_COUNT];\n  fio_defer_queue_block_s *next;\n  size_t write;\n  size_t read;\n  unsigned char state;\n};\n\n/* task queue object */\ntypedef struct { /* a lock for the state machine, used for multi-threading\n                    support */\n  fio_lock_i lock;\n  /* current active block to pop tasks */\n  fio_defer_queue_block_s *reader;\n  /* current active block to push tasks */\n  fio_defer_queue_block_s *writer;\n  /* static, built-in, queue */\n  fio_defer_queue_block_s static_queue;\n} fio_task_queue_s;\n\n/* the state machine - this holds all the data about the task queue and pool */\nstatic fio_task_queue_s task_queue_normal = {\n    .reader = &task_queue_normal.static_queue,\n    .writer = &task_queue_normal.static_queue};\n\nstatic fio_task_queue_s task_queue_urgent = {\n    .reader = &task_queue_urgent.static_queue,\n    .writer = &task_queue_urgent.static_queue};\n\n/* *****************************************************************************\nInternal Task API\n***************************************************************************** */\n\n#if DEBUG\nstatic size_t fio_defer_count_alloc, fio_defer_count_dealloc;\n#define COUNT_ALLOC fio_atomic_add(&fio_defer_count_alloc, 1)\n#define COUNT_DEALLOC fio_atomic_add(&fio_defer_count_dealloc, 1)\n#define COUNT_RESET                                                            \\\n  do {                                                                         \\\n    fio_defer_count_alloc = fio_defer_count_dealloc = 0;                       \\\n  } while (0)\n#else\n#define COUNT_ALLOC\n#define COUNT_DEALLOC\n#define COUNT_RESET\n#endif\n\nstatic inline void fio_defer_push_task_fn(fio_defer_task_s task,\n                                          fio_task_queue_s *queue) {\n  fio_lock(&queue->lock);\n\n  /* test if full */\n  if (queue->writer->state && queue->writer->write == queue->writer->read) {\n    /* return to static buffer or allocate new buffer */\n    if (queue->static_queue.state == 2) {\n      queue->writer->next = &queue->static_queue;\n    } else {\n      queue->writer->next = fio_malloc(sizeof(*queue->writer->next));\n      COUNT_ALLOC;\n      if (!queue->writer->next)\n        goto critical_error;\n    }\n    queue->writer = queue->writer->next;\n    queue->writer->write = 0;\n    queue->writer->read = 0;\n    queue->writer->state = 0;\n    queue->writer->next = NULL;\n  }\n\n  /* place task and finish */\n  queue->writer->tasks[queue->writer->write++] = task;\n  /* cycle buffer */\n  if (queue->writer->write == DEFER_QUEUE_BLOCK_COUNT) {\n    queue->writer->write = 0;\n    queue->writer->state = 1;\n  }\n  fio_unlock(&queue->lock);\n  return;\n\ncritical_error:\n  fio_unlock(&queue->lock);\n  FIO_ASSERT_ALLOC(NULL)\n}\n\n#define fio_defer_push_task(func_, arg1_, arg2_)                               \\\n  do {                                                                         \\\n    fio_defer_push_task_fn(                                                    \\\n        (fio_defer_task_s){.func = func_, .arg1 = arg1_, .arg2 = arg2_},       \\\n        &task_queue_normal);                                                   \\\n    fio_defer_thread_signal();                                                 \\\n  } while (0)\n\n#if FIO_USE_URGENT_QUEUE\n#define fio_defer_push_urgent(func_, arg1_, arg2_)                             \\\n  fio_defer_push_task_fn(                                                      \\\n      (fio_defer_task_s){.func = func_, .arg1 = arg1_, .arg2 = arg2_},         \\\n      &task_queue_urgent)\n#else\n#define fio_defer_push_urgent(func_, arg1_, arg2_)                             \\\n  fio_defer_push_task(func_, arg1_, arg2_)\n#endif\n\nstatic inline fio_defer_task_s fio_defer_pop_task(fio_task_queue_s *queue) {\n  fio_defer_task_s ret = (fio_defer_task_s){.func = NULL};\n  fio_defer_queue_block_s *to_free = NULL;\n  /* lock the state machine, grab/create a task and place it at the tail */\n  fio_lock(&queue->lock);\n\n  /* empty? */\n  if (queue->reader->write == queue->reader->read && !queue->reader->state)\n    goto finish;\n  /* collect task */\n  ret = queue->reader->tasks[queue->reader->read++];\n  /* cycle */\n  if (queue->reader->read == DEFER_QUEUE_BLOCK_COUNT) {\n    queue->reader->read = 0;\n    queue->reader->state = 0;\n  }\n  /* did we finish the queue in the buffer? */\n  if (queue->reader->write == queue->reader->read) {\n    if (queue->reader->next) {\n      to_free = queue->reader;\n      queue->reader = queue->reader->next;\n    } else {\n      if (queue->reader != &queue->static_queue &&\n          queue->static_queue.state == 2) {\n        to_free = queue->reader;\n        queue->writer = &queue->static_queue;\n        queue->reader = &queue->static_queue;\n      }\n      queue->reader->write = queue->reader->read = queue->reader->state = 0;\n    }\n  }\n\nfinish:\n  if (to_free == &queue->static_queue) {\n    queue->static_queue.state = 2;\n    queue->static_queue.next = NULL;\n  }\n  fio_unlock(&queue->lock);\n\n  if (to_free && to_free != &queue->static_queue) {\n    fio_free(to_free);\n    COUNT_DEALLOC;\n  }\n  return ret;\n}\n\n/* same as fio_defer_clear_queue , just inlined */\nstatic inline void fio_defer_clear_tasks_for_queue(fio_task_queue_s *queue) {\n  fio_lock(&queue->lock);\n  while (queue->reader) {\n    fio_defer_queue_block_s *tmp = queue->reader;\n    queue->reader = queue->reader->next;\n    if (tmp != &queue->static_queue) {\n      COUNT_DEALLOC;\n      free(tmp);\n    }\n  }\n  queue->static_queue = (fio_defer_queue_block_s){.next = NULL};\n  queue->reader = queue->writer = &queue->static_queue;\n  fio_unlock(&queue->lock);\n}\n\n/**\n * Performs a single task from the queue, returning -1 if the queue was empty.\n */\nstatic inline int\nfio_defer_perform_single_task_for_queue(fio_task_queue_s *queue) {\n  fio_defer_task_s task = fio_defer_pop_task(queue);\n  if (!task.func)\n    return -1;\n  task.func(task.arg1, task.arg2);\n  return 0;\n}\n\nstatic inline void fio_defer_clear_tasks(void) {\n  fio_defer_clear_tasks_for_queue(&task_queue_normal);\n#if FIO_USE_URGENT_QUEUE\n  fio_defer_clear_tasks_for_queue(&task_queue_urgent);\n#endif\n}\n\nstatic void fio_defer_on_fork(void) {\n  task_queue_normal.lock = FIO_LOCK_INIT;\n#if FIO_USE_URGENT_QUEUE\n  task_queue_urgent.lock = FIO_LOCK_INIT;\n#endif\n}\n\n/* *****************************************************************************\nExternal Task API\n***************************************************************************** */\n\n/** Defer an execution of a function for later. */\nint fio_defer(void (*func)(void *, void *), void *arg1, void *arg2) {\n  /* must have a task to defer */\n  if (!func)\n    goto call_error;\n  fio_defer_push_task(func, arg1, arg2);\n  return 0;\n\ncall_error:\n  return -1;\n}\n\n/** Performs all deferred functions until the queue had been depleted. */\nvoid fio_defer_perform(void) {\n#if FIO_USE_URGENT_QUEUE\n  while (fio_defer_perform_single_task_for_queue(&task_queue_urgent) == 0 ||\n         fio_defer_perform_single_task_for_queue(&task_queue_normal) == 0)\n    ;\n#else\n  while (fio_defer_perform_single_task_for_queue(&task_queue_normal) == 0)\n    ;\n#endif\n  //   for (;;) {\n  // #if FIO_USE_URGENT_QUEUE\n  //     fio_defer_task_s task = fio_defer_pop_task(&task_queue_urgent);\n  //     if (!task.func)\n  //       task = fio_defer_pop_task(&task_queue_normal);\n  // #else\n  //     fio_defer_task_s task = fio_defer_pop_task(&task_queue_normal);\n  // #endif\n  //     if (!task.func)\n  //       return;\n  //     task.func(task.arg1, task.arg2);\n  //   }\n}\n\n/** Returns true if there are deferred functions waiting for execution. */\nint fio_defer_has_queue(void) {\n#if FIO_USE_URGENT_QUEUE\n  return task_queue_urgent.reader != task_queue_urgent.writer ||\n         task_queue_urgent.reader->write != task_queue_urgent.reader->read ||\n         task_queue_normal.reader != task_queue_normal.writer ||\n         task_queue_normal.reader->write != task_queue_normal.reader->read;\n#else\n  return task_queue_normal.reader != task_queue_normal.writer ||\n         task_queue_normal.reader->write != task_queue_normal.reader->read;\n#endif\n}\n\n/** Clears the queue. */\nvoid fio_defer_clear_queue(void) { fio_defer_clear_tasks(); }\n\n/* Thread pool task */\nstatic void *fio_defer_cycle(void *ignr) {\n  fio_defer_on_thread_start();\n  for (;;) {\n    fio_defer_perform();\n    if (!fio_is_running())\n      break;\n    fio_defer_thread_wait();\n  }\n  fio_defer_on_thread_end();\n  return ignr;\n}\n\n/* thread pool type */\ntypedef struct {\n  size_t thread_count;\n  void *threads[];\n} fio_defer_thread_pool_s;\n\n/* joins a thread pool */\nstatic void fio_defer_thread_pool_join(fio_defer_thread_pool_s *pool) {\n  for (size_t i = 0; i < pool->thread_count; ++i) {\n    fio_thread_join(pool->threads[i]);\n  }\n  free(pool);\n}\n\n/* creates a thread pool */\nstatic fio_defer_thread_pool_s *fio_defer_thread_pool_new(size_t count) {\n  if (!count)\n    count = 1;\n  fio_defer_thread_pool_s *pool =\n      malloc(sizeof(*pool) + (count * sizeof(void *)));\n  FIO_ASSERT_ALLOC(pool);\n  pool->thread_count = count;\n  for (size_t i = 0; i < count; ++i) {\n    pool->threads[i] = fio_thread_new(fio_defer_cycle, NULL);\n    if (!pool->threads[i]) {\n      pool->thread_count = i;\n      goto error;\n    }\n  }\n  return pool;\nerror:\n  FIO_LOG_FATAL(\"couldn't spawn threads for thread pool, attempting shutdown.\");\n  fio_stop();\n  fio_defer_thread_pool_join(pool);\n  return NULL;\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n                                     Timers\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\ntypedef struct {\n  fio_ls_embd_s node;\n  struct timespec due;\n  size_t interval; /*in ms */\n  size_t repetitions;\n  void (*task)(void *);\n  void *arg;\n  void (*on_finish)(void *);\n} fio_timer_s;\n\nstatic fio_ls_embd_s fio_timers = FIO_LS_INIT(fio_timers);\n\nstatic fio_lock_i fio_timer_lock = FIO_LOCK_INIT;\n\n/** Marks the current time as facil.io's cycle time */\nstatic inline void fio_mark_time(void) {\n  clock_gettime(CLOCK_REALTIME, &fio_data->last_cycle);\n}\n\n/** Calculates the due time for a task, given it's interval */\nstatic struct timespec fio_timer_calc_due(size_t interval) {\n  struct timespec now = fio_last_tick();\n  if (interval >= 1000) {\n    unsigned long long secs = interval / 1000;\n    now.tv_sec += secs;\n    interval -= secs * 1000;\n  }\n  now.tv_nsec += (interval * 1000000UL);\n  if (now.tv_nsec >= 1000000000L) {\n    now.tv_nsec -= 1000000000L;\n    now.tv_sec += 1;\n  }\n  return now;\n}\n\n/** Returns the number of miliseconds until the next event, up to FIO_POLL_TICK\n */\nstatic size_t fio_timer_calc_first_interval(void) {\n  if (fio_defer_has_queue())\n    return 0;\n  if (fio_ls_embd_is_empty(&fio_timers)) {\n    return FIO_POLL_TICK;\n  }\n  struct timespec now = fio_last_tick();\n  struct timespec due =\n      FIO_LS_EMBD_OBJ(fio_timer_s, node, fio_timers.next)->due;\n  if (due.tv_sec < now.tv_sec ||\n      (due.tv_sec == now.tv_sec && due.tv_nsec <= now.tv_nsec))\n    return 0;\n  size_t interval = 1000L * (due.tv_sec - now.tv_sec);\n  if (due.tv_nsec >= now.tv_nsec) {\n    interval += (due.tv_nsec - now.tv_nsec) / 1000000L;\n  } else {\n    interval -= (now.tv_nsec - due.tv_nsec) / 1000000L;\n  }\n  if (interval > FIO_POLL_TICK)\n    interval = FIO_POLL_TICK;\n  return interval;\n}\n\n/* simple a<=>b if \"a\" is bigger a negative result is returned, eq == 0. */\nstatic int fio_timer_compare(struct timespec a, struct timespec b) {\n  if (a.tv_sec == b.tv_sec) {\n    if (a.tv_nsec < b.tv_nsec)\n      return 1;\n    if (a.tv_nsec > b.tv_nsec)\n      return -1;\n    return 0;\n  }\n  if (a.tv_sec < b.tv_sec)\n    return 1;\n  return -1;\n}\n\n/** Places a timer in an ordered linked list. */\nstatic void fio_timer_add_order(fio_timer_s *timer) {\n  timer->due = fio_timer_calc_due(timer->interval);\n  // fio_ls_embd_s *pos = &fio_timers;\n  fio_lock(&fio_timer_lock);\n  FIO_LS_EMBD_FOR(&fio_timers, node) {\n    fio_timer_s *t2 = FIO_LS_EMBD_OBJ(fio_timer_s, node, node);\n    if (fio_timer_compare(timer->due, t2->due) >= 0) {\n      fio_ls_embd_push(node, &timer->node);\n      goto finish;\n    }\n  }\n  fio_ls_embd_push(&fio_timers, &timer->node);\nfinish:\n  fio_unlock(&fio_timer_lock);\n}\n\n/** Performs a timer task and re-adds it to the queue (or cleans it up) */\nstatic void fio_timer_perform_single(void *timer_, void *ignr) {\n  fio_timer_s *timer = timer_;\n  timer->task(timer->arg);\n  if (!timer->repetitions || fio_atomic_sub(&timer->repetitions, 1))\n    goto reschedule;\n  if (timer->on_finish)\n    timer->on_finish(timer->arg);\n  free(timer);\n  return;\n  (void)ignr;\nreschedule:\n  fio_timer_add_order(timer);\n}\n\n/** schedules all timers that are due to be performed. */\nstatic void fio_timer_schedule(void) {\n  struct timespec now = fio_last_tick();\n  fio_lock(&fio_timer_lock);\n  while (fio_ls_embd_any(&fio_timers) &&\n         fio_timer_compare(\n             FIO_LS_EMBD_OBJ(fio_timer_s, node, fio_timers.next)->due, now) >=\n             0) {\n    fio_ls_embd_s *tmp = fio_ls_embd_remove(fio_timers.next);\n    fio_defer(fio_timer_perform_single, FIO_LS_EMBD_OBJ(fio_timer_s, node, tmp),\n              NULL);\n  }\n  fio_unlock(&fio_timer_lock);\n}\n\nstatic void fio_timer_clear_all(void) {\n  fio_lock(&fio_timer_lock);\n  while (fio_ls_embd_any(&fio_timers)) {\n    fio_timer_s *timer =\n        FIO_LS_EMBD_OBJ(fio_timer_s, node, fio_ls_embd_pop(&fio_timers));\n    if (timer->on_finish)\n      timer->on_finish(timer->arg);\n    free(timer);\n  }\n  fio_unlock(&fio_timer_lock);\n}\n\n/**\n * Creates a timer to run a task at the specified interval.\n *\n * The task will repeat `repetitions` times. If `repetitions` is set to 0, task\n * will repeat forever.\n *\n * Returns -1 on error.\n *\n * The `on_finish` handler is always called (even on error).\n */\nint fio_run_every(size_t milliseconds, size_t repetitions, void (*task)(void *),\n                  void *arg, void (*on_finish)(void *)) {\n  if (!task || (milliseconds == 0 && !repetitions))\n    return -1;\n  fio_timer_s *timer = malloc(sizeof(*timer));\n  FIO_ASSERT_ALLOC(timer);\n  fio_mark_time();\n  *timer = (fio_timer_s){\n      .due = fio_timer_calc_due(milliseconds),\n      .interval = milliseconds,\n      .repetitions = repetitions,\n      .task = task,\n      .arg = arg,\n      .on_finish = on_finish,\n  };\n  fio_timer_add_order(timer);\n  return 0;\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n                               Concurrency Helpers\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\nvolatile uint8_t fio_signal_children_flag = 0;\nvolatile fio_lock_i fio_signal_set_flag = 0;\n/* store old signal handlers to propegate signal handling */\nstatic struct sigaction fio_old_sig_chld;\nstatic struct sigaction fio_old_sig_pipe;\nstatic struct sigaction fio_old_sig_term;\nstatic struct sigaction fio_old_sig_int;\n#if !FIO_DISABLE_HOT_RESTART\nstatic struct sigaction fio_old_sig_usr1;\n#endif\n\n/*\n * Zombie Reaping\n * With thanks to Dr Graham D Shaw.\n * http://www.microhowto.info/howto/reap_zombie_processes_using_a_sigchld_handler.html\n */\nstatic void reap_child_handler(int sig) {\n  (void)(sig);\n  int old_errno = errno;\n  while (waitpid(-1, NULL, WNOHANG) > 0)\n    ;\n  errno = old_errno;\n  if (fio_old_sig_chld.sa_handler != SIG_IGN &&\n      fio_old_sig_chld.sa_handler != SIG_DFL)\n    fio_old_sig_chld.sa_handler(sig);\n}\n\n/* initializes zombie reaping for the process */\nvoid fio_reap_children(void) {\n  struct sigaction sa;\n  if (fio_old_sig_chld.sa_handler)\n    return;\n  sa.sa_handler = reap_child_handler;\n  sigemptyset(&sa.sa_mask);\n  sa.sa_flags = SA_RESTART | SA_NOCLDSTOP;\n  if (sigaction(SIGCHLD, &sa, &fio_old_sig_chld) == -1) {\n    perror(\"Child reaping initialization failed\");\n    kill(0, SIGINT);\n    exit(errno);\n  }\n}\n\n/* handles the SIGUSR1, SIGINT and SIGTERM signals. */\nstatic void sig_int_handler(int sig) {\n  struct sigaction *old = NULL;\n  switch (sig) {\n#if !FIO_DISABLE_HOT_RESTART\n  case SIGUSR1:\n    fio_signal_children_flag = 1;\n    old = &fio_old_sig_usr1;\n    break;\n#endif\n    /* fallthrough */\n  case SIGINT:\n    if (!old)\n      old = &fio_old_sig_int;\n    /* fallthrough */\n  case SIGTERM:\n    if (!old)\n      old = &fio_old_sig_term;\n    fio_stop();\n    break;\n  case SIGPIPE:\n    if (!old)\n      old = &fio_old_sig_pipe;\n  /* fallthrough */\n  default:\n    break;\n  }\n  /* propagate signale handling to previous existing handler (if any) */\n  if (old && old->sa_handler != SIG_IGN && old->sa_handler != SIG_DFL)\n    old->sa_handler(sig);\n}\n\n/* setup handling for the SIGUSR1, SIGPIPE, SIGINT and SIGTERM signals. */\nstatic void fio_signal_handler_setup(void) {\n  /* setup signal handling */\n  struct sigaction act;\n  if (fio_trylock(&fio_signal_set_flag))\n    return;\n\n  memset(&act, 0, sizeof(act));\n\n  act.sa_handler = sig_int_handler;\n  sigemptyset(&act.sa_mask);\n  act.sa_flags = SA_RESTART | SA_NOCLDSTOP;\n\n  if (sigaction(SIGINT, &act, &fio_old_sig_int)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n\n  if (sigaction(SIGTERM, &act, &fio_old_sig_term)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n#if !FIO_DISABLE_HOT_RESTART\n  if (sigaction(SIGUSR1, &act, &fio_old_sig_usr1)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n#endif\n\n  act.sa_handler = SIG_IGN;\n  if (sigaction(SIGPIPE, &act, &fio_old_sig_pipe)) {\n    perror(\"couldn't set signal handler\");\n    return;\n  };\n}\n\nvoid fio_signal_handler_reset(void) {\n  struct sigaction old;\n  if (fio_signal_set_flag)\n    return;\n  fio_unlock(&fio_signal_set_flag);\n  memset(&old, 0, sizeof(old));\n  sigaction(SIGINT, &fio_old_sig_int, &old);\n  sigaction(SIGTERM, &fio_old_sig_term, &old);\n  sigaction(SIGPIPE, &fio_old_sig_pipe, &old);\n  if (fio_old_sig_chld.sa_handler)\n    sigaction(SIGCHLD, &fio_old_sig_chld, &old);\n#if !FIO_DISABLE_HOT_RESTART\n  sigaction(SIGUSR1, &fio_old_sig_usr1, &old);\n  memset(&fio_old_sig_usr1, 0, sizeof(fio_old_sig_usr1));\n#endif\n  memset(&fio_old_sig_int, 0, sizeof(fio_old_sig_int));\n  memset(&fio_old_sig_term, 0, sizeof(fio_old_sig_term));\n  memset(&fio_old_sig_pipe, 0, sizeof(fio_old_sig_pipe));\n  memset(&fio_old_sig_chld, 0, sizeof(fio_old_sig_chld));\n}\n\n/**\n * Returns 1 if the current process is a worker process or a single process.\n *\n * Otherwise returns 0.\n *\n * NOTE: When cluster mode is off, the root process is also the worker process.\n *       This means that single process instances don't automatically respawn\n *       after critical errors.\n */\nint fio_is_worker(void) { return fio_data->is_worker; }\n\n/**\n * Returns 1 if the current process is the master (root) process.\n *\n * Otherwise returns 0.\n */\nint fio_is_master(void) {\n  return fio_data->is_worker == 0 || fio_data->workers == 1;\n}\n\n/** returns facil.io's parent (root) process pid. */\npid_t fio_parent_pid(void) { return fio_data->parent; }\n\nstatic inline size_t fio_detect_cpu_cores(void) {\n  ssize_t cpu_count = 0;\n#ifdef _SC_NPROCESSORS_ONLN\n  cpu_count = sysconf(_SC_NPROCESSORS_ONLN);\n  if (cpu_count < 0) {\n    FIO_LOG_WARNING(\"CPU core count auto-detection failed.\");\n    return 0;\n  }\n#else\n  FIO_LOG_WARNING(\"CPU core count auto-detection failed.\");\n#endif\n  return cpu_count;\n}\n\n/**\n * Returns the number of expected threads / processes to be used by facil.io.\n *\n * The pointers should start with valid values that match the expected threads /\n * processes values passed to `fio_run`.\n *\n * The data in the pointers will be overwritten with the result.\n */\nvoid fio_expected_concurrency(int16_t *threads, int16_t *processes) {\n  if (!threads || !processes)\n    return;\n  if (!*threads && !*processes) {\n    /* both options set to 0 - default to cores*cores matrix */\n    ssize_t cpu_count = fio_detect_cpu_cores();\n#if FIO_CPU_CORES_LIMIT\n    if (cpu_count > FIO_CPU_CORES_LIMIT) {\n      static int print_cores_warning = 1;\n      if (print_cores_warning) {\n        FIO_LOG_WARNING(\n            \"Detected %zu cores. Capping auto-detection of cores to %zu.\\n\"\n            \"      Avoid this message by setting threads / workers manually.\\n\"\n            \"      To increase auto-detection limit, recompile with:\\n\"\n            \"             -DFIO_CPU_CORES_LIMIT=%zu\",\n            (size_t)cpu_count, (size_t)FIO_CPU_CORES_LIMIT, (size_t)cpu_count);\n        print_cores_warning = 0;\n      }\n      cpu_count = FIO_CPU_CORES_LIMIT;\n    }\n#endif\n    *threads = *processes = (int16_t)cpu_count;\n    if (cpu_count > 3) {\n      /* leave a core available for the kernel */\n      --(*processes);\n    }\n  } else if (*threads < 0 || *processes < 0) {\n    /* Set any option that is less than 0 be equal to cores/value */\n    /* Set any option equal to 0 be equal to the other option in value */\n    ssize_t cpu_count = fio_detect_cpu_cores();\n    size_t thread_cpu_adjust = (*threads <= 0 ? 1 : 0);\n    size_t worker_cpu_adjust = (*processes <= 0 ? 1 : 0);\n\n    if (cpu_count > 0) {\n      int16_t tmp = 0;\n      if (*threads < 0)\n        tmp = (int16_t)(cpu_count / (*threads * -1));\n      else if (*threads == 0) {\n        tmp = -1 * *processes;\n        thread_cpu_adjust = 0;\n      } else\n        tmp = *threads;\n      if (*processes < 0)\n        *processes = (int16_t)(cpu_count / (*processes * -1));\n      else if (*processes == 0) {\n        *processes = -1 * *threads;\n        worker_cpu_adjust = 0;\n      }\n      *threads = tmp;\n      tmp = *processes;\n      if (worker_cpu_adjust && (*processes * *threads) >= cpu_count &&\n          cpu_count > 3) {\n        /* leave a resources available for the kernel */\n        --*processes;\n      }\n      if (thread_cpu_adjust && (*threads * tmp) >= cpu_count && cpu_count > 3) {\n        /* leave a resources available for the kernel */\n        --*threads;\n      }\n    }\n  }\n\n  /* make sure we have at least one process and at least one thread */\n  if (*processes <= 0)\n    *processes = 1;\n  if (*threads <= 0)\n    *threads = 1;\n}\n\nstatic fio_lock_i fio_fork_lock = FIO_LOCK_INIT;\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n\n                       Polling State Machine - epoll\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n#if FIO_ENGINE_EPOLL\n#include <sys/epoll.h>\n\n/**\n * Returns a C string detailing the IO engine selected during compilation.\n *\n * Valid values are \"kqueue\", \"epoll\" and \"poll\".\n */\nchar const *fio_engine(void) { return \"epoll\"; }\n\n/* epoll tester, in and out */\nstatic int evio_fd[3] = {-1, -1, -1};\n\nstatic void fio_poll_close(void) {\n  for (int i = 0; i < 3; ++i) {\n    if (evio_fd[i] != -1) {\n      close(evio_fd[i]);\n      evio_fd[i] = -1;\n    }\n  }\n}\n\nstatic void fio_poll_init(void) {\n  fio_poll_close();\n  for (int i = 0; i < 3; ++i) {\n    evio_fd[i] = epoll_create1(EPOLL_CLOEXEC);\n    if (evio_fd[i] == -1)\n      goto error;\n  }\n  for (int i = 1; i < 3; ++i) {\n    struct epoll_event chevent = {\n        .events = (EPOLLOUT | EPOLLIN),\n        .data.fd = evio_fd[i],\n    };\n    if (epoll_ctl(evio_fd[0], EPOLL_CTL_ADD, evio_fd[i], &chevent) == -1)\n      goto error;\n  }\n  return;\nerror:\n  FIO_LOG_FATAL(\"couldn't initialize epoll.\");\n  fio_poll_close();\n  exit(errno);\n  return;\n}\n\nstatic inline int fio_poll_add2(int fd, uint32_t events, int ep_fd) {\n  struct epoll_event chevent;\n  int ret;\n  do {\n    errno = 0;\n    chevent = (struct epoll_event){\n        .events = events,\n        .data.fd = fd,\n    };\n    ret = epoll_ctl(ep_fd, EPOLL_CTL_MOD, fd, &chevent);\n    if (ret == -1 && errno == ENOENT) {\n      errno = 0;\n      chevent = (struct epoll_event){\n          .events = events,\n          .data.fd = fd,\n      };\n      ret = epoll_ctl(ep_fd, EPOLL_CTL_ADD, fd, &chevent);\n    }\n  } while (errno == EINTR);\n\n  return ret;\n}\n\nstatic inline void fio_poll_add_read(intptr_t fd) {\n  fio_poll_add2(fd, (EPOLLIN | EPOLLRDHUP | EPOLLHUP | EPOLLONESHOT),\n                evio_fd[1]);\n  return;\n}\n\nstatic inline void fio_poll_add_write(intptr_t fd) {\n  fio_poll_add2(fd, (EPOLLOUT | EPOLLRDHUP | EPOLLHUP | EPOLLONESHOT),\n                evio_fd[2]);\n  return;\n}\n\nstatic inline void fio_poll_add(intptr_t fd) {\n  if (fio_poll_add2(fd, (EPOLLIN | EPOLLRDHUP | EPOLLHUP | EPOLLONESHOT),\n                    evio_fd[1]) == -1)\n    return;\n  fio_poll_add2(fd, (EPOLLOUT | EPOLLRDHUP | EPOLLHUP | EPOLLONESHOT),\n                evio_fd[2]);\n  return;\n}\n\nFIO_FUNC inline void fio_poll_remove_fd(intptr_t fd) {\n  struct epoll_event chevent = {.events = (EPOLLOUT | EPOLLIN), .data.fd = fd};\n  epoll_ctl(evio_fd[1], EPOLL_CTL_DEL, fd, &chevent);\n  epoll_ctl(evio_fd[2], EPOLL_CTL_DEL, fd, &chevent);\n}\n\nstatic size_t fio_poll(void) {\n  int timeout_millisec = fio_timer_calc_first_interval();\n  struct epoll_event internal[2];\n  struct epoll_event events[FIO_POLL_MAX_EVENTS];\n  int total = 0;\n  /* wait for events and handle them */\n  int internal_count = epoll_wait(evio_fd[0], internal, 2, timeout_millisec);\n  if (internal_count == 0)\n    return internal_count;\n  for (int j = 0; j < internal_count; ++j) {\n    int active_count =\n        epoll_wait(internal[j].data.fd, events, FIO_POLL_MAX_EVENTS, 0);\n    if (active_count > 0) {\n      for (int i = 0; i < active_count; i++) {\n        if (events[i].events & (~(EPOLLIN | EPOLLOUT))) {\n          // errors are hendled as disconnections (on_close)\n          fio_force_close_in_poll(fd2uuid(events[i].data.fd));\n        } else {\n          // no error, then it's an active event(s)\n          if (events[i].events & EPOLLOUT) {\n            fio_defer_push_urgent(deferred_on_ready,\n                                  (void *)fd2uuid(events[i].data.fd), NULL);\n          }\n          if (events[i].events & EPOLLIN)\n            fio_defer_push_task(deferred_on_data,\n                                (void *)fd2uuid(events[i].data.fd), NULL);\n        }\n      } // end for loop\n      total += active_count;\n    }\n  }\n  return total;\n}\n\n#endif\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n\n                       Polling State Machine - kqueue\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n#if FIO_ENGINE_KQUEUE\n#include <sys/event.h>\n\n/**\n * Returns a C string detailing the IO engine selected during compilation.\n *\n * Valid values are \"kqueue\", \"epoll\" and \"poll\".\n */\nchar const *fio_engine(void) { return \"kqueue\"; }\n\nstatic int evio_fd = -1;\n\nstatic void fio_poll_close(void) { close(evio_fd); }\n\nstatic void fio_poll_init(void) {\n  fio_poll_close();\n  evio_fd = kqueue();\n  if (evio_fd == -1) {\n    FIO_LOG_FATAL(\"couldn't open kqueue.\\n\");\n    exit(errno);\n  }\n}\n\nstatic inline void fio_poll_add_read(intptr_t fd) {\n  struct kevent chevent[1];\n  EV_SET(chevent, fd, EVFILT_READ, EV_ADD | EV_ENABLE | EV_CLEAR | EV_ONESHOT,\n         0, 0, ((void *)fd));\n  do {\n    errno = 0;\n    kevent(evio_fd, chevent, 1, NULL, 0, NULL);\n  } while (errno == EINTR);\n  return;\n}\n\nstatic inline void fio_poll_add_write(intptr_t fd) {\n  struct kevent chevent[1];\n  EV_SET(chevent, fd, EVFILT_WRITE, EV_ADD | EV_ENABLE | EV_CLEAR | EV_ONESHOT,\n         0, 0, ((void *)fd));\n  do {\n    errno = 0;\n    kevent(evio_fd, chevent, 1, NULL, 0, NULL);\n  } while (errno == EINTR);\n  return;\n}\n\nstatic inline void fio_poll_add(intptr_t fd) {\n  struct kevent chevent[2];\n  EV_SET(chevent, fd, EVFILT_READ, EV_ADD | EV_ENABLE | EV_CLEAR | EV_ONESHOT,\n         0, 0, ((void *)fd));\n  EV_SET(chevent + 1, fd, EVFILT_WRITE,\n         EV_ADD | EV_ENABLE | EV_CLEAR | EV_ONESHOT, 0, 0, ((void *)fd));\n  do {\n    errno = 0;\n    kevent(evio_fd, chevent, 2, NULL, 0, NULL);\n  } while (errno == EINTR);\n  return;\n}\n\nFIO_FUNC inline void fio_poll_remove_fd(intptr_t fd) {\n  if (evio_fd < 0)\n    return;\n  struct kevent chevent[2];\n  EV_SET(chevent, fd, EVFILT_READ, EV_DELETE, 0, 0, NULL);\n  EV_SET(chevent + 1, fd, EVFILT_WRITE, EV_DELETE, 0, 0, NULL);\n  do {\n    errno = 0;\n    kevent(evio_fd, chevent, 2, NULL, 0, NULL);\n  } while (errno == EINTR);\n}\n\nstatic size_t fio_poll(void) {\n  if (evio_fd < 0)\n    return -1;\n  int timeout_millisec = fio_timer_calc_first_interval();\n  struct kevent events[FIO_POLL_MAX_EVENTS] = {{0}};\n\n  const struct timespec timeout = {\n      .tv_sec = (timeout_millisec / 1000),\n      .tv_nsec = ((timeout_millisec & (~1023UL)) * 1000000)};\n  /* wait for events and handle them */\n  int active_count =\n      kevent(evio_fd, NULL, 0, events, FIO_POLL_MAX_EVENTS, &timeout);\n\n  if (active_count > 0) {\n    for (int i = 0; i < active_count; i++) {\n      // test for event(s) type\n      if (events[i].filter == EVFILT_WRITE) {\n        fio_defer_push_urgent(deferred_on_ready,\n                              ((void *)fd2uuid(events[i].udata)), NULL);\n      } else if (events[i].filter == EVFILT_READ) {\n        fio_defer_push_task(deferred_on_data, (void *)fd2uuid(events[i].udata),\n                            NULL);\n      }\n      if (events[i].flags & (EV_EOF | EV_ERROR)) {\n        fio_force_close_in_poll(fd2uuid(events[i].udata));\n      }\n    }\n  } else if (active_count < 0) {\n    if (errno == EINTR)\n      return 0;\n    return -1;\n  }\n  return active_count;\n}\n\n#endif\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n\n                       Polling State Machine - poll\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n#if FIO_ENGINE_POLL\n\n/**\n * Returns a C string detailing the IO engine selected during compilation.\n *\n * Valid values are \"kqueue\", \"epoll\" and \"poll\".\n */\nchar const *fio_engine(void) { return \"poll\"; }\n\n#define FIO_POLL_READ_EVENTS (POLLPRI | POLLIN)\n#define FIO_POLL_WRITE_EVENTS (POLLOUT)\n\nstatic void fio_poll_close(void) {}\n\nstatic void fio_poll_init(void) {}\n\nstatic inline void fio_poll_remove_fd(int fd) {\n  fio_data->poll[fd].fd = -1;\n  fio_data->poll[fd].events = 0;\n}\n\nstatic inline void fio_poll_add_read(int fd) {\n  fio_data->poll[fd].fd = fd;\n  fio_data->poll[fd].events |= FIO_POLL_READ_EVENTS;\n}\n\nstatic inline void fio_poll_add_write(int fd) {\n  fio_data->poll[fd].fd = fd;\n  fio_data->poll[fd].events |= FIO_POLL_WRITE_EVENTS;\n}\n\nstatic inline void fio_poll_add(int fd) {\n  fio_data->poll[fd].fd = fd;\n  fio_data->poll[fd].events = FIO_POLL_READ_EVENTS | FIO_POLL_WRITE_EVENTS;\n}\n\nstatic inline void fio_poll_remove_read(int fd) {\n  fio_lock(&fio_data->lock);\n  if (fio_data->poll[fd].events & FIO_POLL_WRITE_EVENTS)\n    fio_data->poll[fd].events = FIO_POLL_WRITE_EVENTS;\n  else {\n    fio_poll_remove_fd(fd);\n  }\n  fio_unlock(&fio_data->lock);\n}\n\nstatic inline void fio_poll_remove_write(int fd) {\n  fio_lock(&fio_data->lock);\n  if (fio_data->poll[fd].events & FIO_POLL_READ_EVENTS)\n    fio_data->poll[fd].events = FIO_POLL_READ_EVENTS;\n  else {\n    fio_poll_remove_fd(fd);\n  }\n  fio_unlock(&fio_data->lock);\n}\n\n/** returns non-zero if events were scheduled, 0 if idle */\nstatic size_t fio_poll(void) {\n  /* shrink fd poll range */\n  size_t end = fio_data->capa; // max_protocol_fd might break TLS\n  size_t start = 0;\n  struct pollfd *list = NULL;\n  fio_lock(&fio_data->lock);\n  while (start < end && fio_data->poll[start].fd == -1)\n    ++start;\n  while (start < end && fio_data->poll[end - 1].fd == -1)\n    --end;\n  if (start != end) {\n    /* copy poll list for multi-threaded poll */\n    list = fio_malloc(sizeof(struct pollfd) * end);\n    memcpy(list + start, fio_data->poll + start,\n           (sizeof(struct pollfd)) * (end - start));\n  }\n  fio_unlock(&fio_data->lock);\n\n  int timeout = fio_timer_calc_first_interval();\n  size_t count = 0;\n\n  if (start == end) {\n    fio_throttle_thread((timeout * 1000000UL));\n  } else if (poll(list + start, end - start, timeout) == -1) {\n    goto finish;\n  }\n  for (size_t i = start; i < end; ++i) {\n    if (list[i].revents) {\n      touchfd(i);\n      ++count;\n      if (list[i].revents & FIO_POLL_WRITE_EVENTS) {\n        // FIO_LOG_DEBUG(\"Poll Write %zu => %p\", i, (void *)fd2uuid(i));\n        fio_poll_remove_write(i);\n        fio_defer_push_urgent(deferred_on_ready, (void *)fd2uuid(i), NULL);\n      }\n      if (list[i].revents & FIO_POLL_READ_EVENTS) {\n        // FIO_LOG_DEBUG(\"Poll Read %zu => %p\", i, (void *)fd2uuid(i));\n        fio_poll_remove_read(i);\n        fio_defer_push_task(deferred_on_data, (void *)fd2uuid(i), NULL);\n      }\n      if (list[i].revents & (POLLHUP | POLLERR)) {\n        // FIO_LOG_DEBUG(\"Poll Hangup %zu => %p\", i, (void *)fd2uuid(i));\n        fio_poll_remove_fd(i);\n        fio_force_close_in_poll(fd2uuid(i));\n      }\n      if (list[i].revents & POLLNVAL) {\n        // FIO_LOG_DEBUG(\"Poll Invalid %zu => %p\", i, (void *)fd2uuid(i));\n        fio_poll_remove_fd(i);\n        fio_lock(&fd_data(i).protocol_lock);\n        fio_clear_fd(i, 0);\n        fio_unlock(&fd_data(i).protocol_lock);\n      }\n    }\n  }\nfinish:\n  fio_free(list);\n  return count;\n}\n\n#endif /* FIO_ENGINE_POLL */\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n                         IO Callbacks / Event Handling\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/* *****************************************************************************\nMock Protocol Callbacks and Service Funcions\n***************************************************************************** */\nstatic void mock_on_ev(intptr_t uuid, fio_protocol_s *protocol) {\n  (void)uuid;\n  (void)protocol;\n}\n\nstatic void mock_on_data(intptr_t uuid, fio_protocol_s *protocol) {\n  fio_suspend(uuid);\n  (void)protocol;\n}\n\nstatic uint8_t mock_on_shutdown(intptr_t uuid, fio_protocol_s *protocol) {\n  return 0;\n  (void)protocol;\n  (void)uuid;\n}\n\nstatic uint8_t mock_on_shutdown_eternal(intptr_t uuid,\n                                        fio_protocol_s *protocol) {\n  return 255;\n  (void)protocol;\n  (void)uuid;\n}\n\nstatic void mock_ping(intptr_t uuid, fio_protocol_s *protocol) {\n  (void)protocol;\n  fio_force_close(uuid);\n}\nstatic void mock_ping2(intptr_t uuid, fio_protocol_s *protocol) {\n  (void)protocol;\n  touchfd(fio_uuid2fd(uuid));\n  if (uuid_data(uuid).timeout == 255)\n    return;\n  protocol->ping = mock_ping;\n  uuid_data(uuid).timeout = 8;\n  fio_close(uuid);\n}\n\nFIO_FUNC void mock_ping_eternal(intptr_t uuid, fio_protocol_s *protocol) {\n  (void)protocol;\n  fio_touch(uuid);\n}\n\n/* *****************************************************************************\nDeferred event handlers - these tasks safely forward the events to the Protocol\n***************************************************************************** */\n\nstatic void deferred_on_close(void *uuid_, void *pr_) {\n  fio_protocol_s *pr = pr_;\n  if (pr->rsv)\n    goto postpone;\n  pr->on_close((intptr_t)uuid_, pr);\n  return;\npostpone:\n  fio_defer_push_task(deferred_on_close, uuid_, pr_);\n}\n\nstatic void deferred_on_shutdown(void *arg, void *arg2) {\n  if (!uuid_data(arg).protocol) {\n    return;\n  }\n  fio_protocol_s *pr = protocol_try_lock(fio_uuid2fd(arg), FIO_PR_LOCK_TASK);\n  if (!pr) {\n    if (errno == EBADF)\n      return;\n    goto postpone;\n  }\n  touchfd(fio_uuid2fd(arg));\n  uint8_t r = pr->on_shutdown ? pr->on_shutdown((intptr_t)arg, pr) : 0;\n  if (r) {\n    if (r == 255) {\n      uuid_data(arg).timeout = 0;\n    } else {\n      fio_atomic_add(&fio_data->connection_count, 1);\n      uuid_data(arg).timeout = r;\n    }\n    pr->ping = mock_ping2;\n    protocol_unlock(pr, FIO_PR_LOCK_TASK);\n  } else {\n    fio_atomic_add(&fio_data->connection_count, 1);\n    uuid_data(arg).timeout = 8;\n    pr->ping = mock_ping;\n    protocol_unlock(pr, FIO_PR_LOCK_TASK);\n    fio_close((intptr_t)arg);\n  }\n  return;\npostpone:\n  fio_defer_push_task(deferred_on_shutdown, arg, NULL);\n  (void)arg2;\n}\n\nstatic void deferred_on_ready_usr(void *arg, void *arg2) {\n  errno = 0;\n  fio_protocol_s *pr = protocol_try_lock(fio_uuid2fd(arg), FIO_PR_LOCK_WRITE);\n  if (!pr) {\n    if (errno == EBADF)\n      return;\n    goto postpone;\n  }\n  pr->on_ready((intptr_t)arg, pr);\n  protocol_unlock(pr, FIO_PR_LOCK_WRITE);\n  return;\npostpone:\n  fio_defer_push_task(deferred_on_ready, arg, NULL);\n  (void)arg2;\n}\n\nstatic void deferred_on_ready(void *arg, void *arg2) {\n  errno = 0;\n  if (fio_flush((intptr_t)arg) > 0 || errno == EWOULDBLOCK || errno == EAGAIN) {\n    if (arg2)\n      fio_defer_push_urgent(deferred_on_ready, arg, NULL);\n    else\n      fio_poll_add_write(fio_uuid2fd(arg));\n    return;\n  }\n  if (!uuid_data(arg).protocol) {\n    return;\n  }\n\n  fio_defer_push_task(deferred_on_ready_usr, arg, NULL);\n}\n\nstatic void deferred_on_data(void *uuid, void *arg2) {\n  if (fio_is_closed((intptr_t)uuid)) {\n    return;\n  }\n  if (!uuid_data(uuid).protocol)\n    goto no_protocol;\n  fio_protocol_s *pr = protocol_try_lock(fio_uuid2fd(uuid), FIO_PR_LOCK_TASK);\n  if (!pr) {\n    if (errno == EBADF) {\n      return;\n    }\n    goto postpone;\n  }\n  fio_unlock(&uuid_data(uuid).scheduled);\n  pr->on_data((intptr_t)uuid, pr);\n  protocol_unlock(pr, FIO_PR_LOCK_TASK);\n  if (!fio_trylock(&uuid_data(uuid).scheduled)) {\n    fio_poll_add_read(fio_uuid2fd((intptr_t)uuid));\n  }\n  return;\n\npostpone:\n  if (arg2) {\n    /* the event is being forced, so force rescheduling */\n    fio_defer_push_task(deferred_on_data, (void *)uuid, (void *)1);\n  } else {\n    /* the protocol was locked, so there might not be any need for the event */\n    fio_poll_add_read(fio_uuid2fd((intptr_t)uuid));\n  }\n  return;\n\nno_protocol:\n  /* a missing protocol might still want to invoke the RW hook flush */\n  deferred_on_ready(uuid, arg2);\n  return;\n}\n\nstatic void deferred_ping(void *arg, void *arg2) {\n  if (!uuid_data(arg).protocol ||\n      (uuid_data(arg).timeout &&\n       (uuid_data(arg).timeout + uuid_data(arg).active >\n        (fio_data->last_cycle.tv_sec)))) {\n    return;\n  }\n  fio_protocol_s *pr = protocol_try_lock(fio_uuid2fd(arg), FIO_PR_LOCK_WRITE);\n  if (!pr)\n    goto postpone;\n  pr->ping((intptr_t)arg, pr);\n  protocol_unlock(pr, FIO_PR_LOCK_WRITE);\n  return;\npostpone:\n  fio_defer_push_task(deferred_ping, arg, NULL);\n  (void)arg2;\n}\n\n/* *****************************************************************************\nForcing / Suspending IO events\n***************************************************************************** */\n\nvoid fio_force_event(intptr_t uuid, enum fio_io_event ev) {\n  if (!uuid_is_valid(uuid))\n    return;\n  switch (ev) {\n  case FIO_EVENT_ON_DATA:\n    fio_trylock(&uuid_data(uuid).scheduled);\n    fio_defer_push_task(deferred_on_data, (void *)uuid, (void *)1);\n    break;\n  case FIO_EVENT_ON_TIMEOUT:\n    fio_defer_push_task(deferred_ping, (void *)uuid, NULL);\n    break;\n  case FIO_EVENT_ON_READY:\n    fio_defer_push_urgent(deferred_on_ready, (void *)uuid, NULL);\n    break;\n  }\n}\n\nvoid fio_suspend(intptr_t uuid) {\n  if (uuid_is_valid(uuid))\n    fio_trylock(&uuid_data(uuid).scheduled);\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n                               IO Socket Layer\n\n                     Read / Write / Accept / Connect / etc'\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/* *****************************************************************************\nInternal socket initialization functions\n***************************************************************************** */\n\n/**\nSets a socket to non blocking state.\n\nThis function is called automatically for the new socket, when using\n`fio_accept` or `fio_connect`.\n*/\nint fio_set_non_block(int fd) {\n/* If they have O_NONBLOCK, use the Posix way to do it */\n#if defined(O_NONBLOCK)\n  /* Fixme: O_NONBLOCK is defined but broken on SunOS 4.1.x and AIX 3.2.5. */\n  int flags;\n  if (-1 == (flags = fcntl(fd, F_GETFL, 0)))\n    flags = 0;\n#ifdef O_CLOEXEC\n  return fcntl(fd, F_SETFL, flags | O_NONBLOCK | O_CLOEXEC);\n#else\n  return fcntl(fd, F_SETFL, flags | O_NONBLOCK);\n#endif\n#elif defined(FIONBIO)\n  /* Otherwise, use the old way of doing it */\n  static int flags = 1;\n  return ioctl(fd, FIONBIO, &flags);\n#else\n#error No functions / argumnet macros for non-blocking sockets.\n#endif\n}\n\nstatic void fio_tcp_addr_cpy(int fd, int family, struct sockaddr *addrinfo) {\n  const char *result =\n      inet_ntop(family,\n                family == AF_INET\n                    ? (void *)&(((struct sockaddr_in *)addrinfo)->sin_addr)\n                    : (void *)&(((struct sockaddr_in6 *)addrinfo)->sin6_addr),\n                (char *)fd_data(fd).addr, sizeof(fd_data(fd).addr));\n  if (result) {\n    fd_data(fd).addr_len = strlen((char *)fd_data(fd).addr);\n  } else {\n    fd_data(fd).addr_len = 0;\n    fd_data(fd).addr[0] = 0;\n  }\n}\n\n/**\n * `fio_accept` accepts a new socket connection from a server socket - see the\n * server flag on `fio_socket`.\n *\n * NOTE: this function does NOT attach the socket to the IO reactor -see\n * `fio_attach`.\n */\nintptr_t fio_accept(intptr_t srv_uuid) {\n  struct sockaddr_in6 addrinfo[2]; /* grab a slice of stack (aligned) */\n  socklen_t addrlen = sizeof(addrinfo);\n  int client;\n#ifdef SOCK_NONBLOCK\n  client = accept4(fio_uuid2fd(srv_uuid), (struct sockaddr *)addrinfo, &addrlen,\n                   SOCK_NONBLOCK | SOCK_CLOEXEC);\n  if (client <= 0)\n    return -1;\n#else\n  client = accept(fio_uuid2fd(srv_uuid), (struct sockaddr *)addrinfo, &addrlen);\n  if (client <= 0)\n    return -1;\n  if (fio_set_non_block(client) == -1) {\n    close(client);\n    return -1;\n  }\n#endif\n  // avoid the TCP delay algorithm.\n  {\n    int optval = 1;\n    setsockopt(client, IPPROTO_TCP, TCP_NODELAY, &optval, sizeof(optval));\n  }\n  // handle socket buffers.\n  {\n    int optval = 0;\n    socklen_t size = (socklen_t)sizeof(optval);\n    if (!getsockopt(client, SOL_SOCKET, SO_SNDBUF, &optval, &size) &&\n        optval <= 131072) {\n      optval = 131072;\n      setsockopt(client, SOL_SOCKET, SO_SNDBUF, &optval, sizeof(optval));\n      optval = 131072;\n      setsockopt(client, SOL_SOCKET, SO_RCVBUF, &optval, sizeof(optval));\n    }\n  }\n\n  fio_lock(&fd_data(client).protocol_lock);\n  fio_clear_fd(client, 1);\n  fio_unlock(&fd_data(client).protocol_lock);\n  /* copy peer address */\n  if (((struct sockaddr *)addrinfo)->sa_family == AF_UNIX) {\n    fd_data(client).addr_len = uuid_data(srv_uuid).addr_len;\n    if (uuid_data(srv_uuid).addr_len) {\n      memcpy(fd_data(client).addr, uuid_data(srv_uuid).addr,\n             uuid_data(srv_uuid).addr_len + 1);\n    }\n  } else {\n    fio_tcp_addr_cpy(client, ((struct sockaddr *)addrinfo)->sa_family,\n                     (struct sockaddr *)addrinfo);\n  }\n\n  return fd2uuid(client);\n}\n\n/* Creates a Unix socket - returning it's uuid (or -1) */\nstatic intptr_t fio_unix_socket(const char *address, uint8_t server) {\n  /* Unix socket */\n  struct sockaddr_un addr = {0};\n  size_t addr_len = strlen(address);\n  if (addr_len >= sizeof(addr.sun_path)) {\n    FIO_LOG_ERROR(\"(fio_unix_socket) address too long (%zu bytes > %zu bytes).\",\n                  addr_len, sizeof(addr.sun_path) - 1);\n    errno = ENAMETOOLONG;\n    return -1;\n  }\n  addr.sun_family = AF_UNIX;\n  memcpy(addr.sun_path, address, addr_len + 1); /* copy the NUL byte. */\n#if defined(__APPLE__)\n  addr.sun_len = addr_len;\n#endif\n  // get the file descriptor\n  int fd = socket(AF_UNIX, SOCK_STREAM, 0);\n  if (fd == -1) {\n    return -1;\n  }\n  if (fio_set_non_block(fd) == -1) {\n    close(fd);\n    return -1;\n  }\n  if (server) {\n    unlink(addr.sun_path);\n    if (bind(fd, (struct sockaddr *)&addr, sizeof(addr)) == -1) {\n      // perror(\"couldn't bind unix socket\");\n      close(fd);\n      return -1;\n    }\n    if (listen(fd, SOMAXCONN) < 0) {\n      // perror(\"couldn't start listening to unix socket\");\n      close(fd);\n      return -1;\n    }\n    /* chmod for foriegn connections */\n    fchmod(fd, 0777);\n  } else {\n    if (connect(fd, (struct sockaddr *)&addr, sizeof(addr)) == -1 &&\n        errno != EINPROGRESS) {\n      close(fd);\n      return -1;\n    }\n  }\n  fio_lock(&fd_data(fd).protocol_lock);\n  fio_clear_fd(fd, 1);\n  fio_unlock(&fd_data(fd).protocol_lock);\n  if (addr_len < sizeof(fd_data(fd).addr)) {\n    memcpy(fd_data(fd).addr, address, addr_len + 1); /* copy the NUL byte. */\n    fd_data(fd).addr_len = addr_len;\n  }\n  return fd2uuid(fd);\n}\n\n/* Creates a TCP/IP socket - returning it's uuid (or -1) */\nstatic intptr_t fio_tcp_socket(const char *address, const char *port,\n                               uint8_t server) {\n  /* TCP/IP socket */\n  // setup the address\n  struct addrinfo hints = {0};\n  struct addrinfo *addrinfo;       // will point to the results\n  memset(&hints, 0, sizeof hints); // make sure the struct is empty\n  hints.ai_family = AF_UNSPEC;     // don't care IPv4 or IPv6\n  hints.ai_socktype = SOCK_STREAM; // TCP stream sockets\n  hints.ai_flags = AI_PASSIVE;     // fill in my IP for me\n  if (getaddrinfo(address, port, &hints, &addrinfo)) {\n    // perror(\"addr err\");\n    return -1;\n  }\n  // get the file descriptor\n  int fd =\n      socket(addrinfo->ai_family, addrinfo->ai_socktype, addrinfo->ai_protocol);\n  if (fd <= 0) {\n    freeaddrinfo(addrinfo);\n    return -1;\n  }\n  // make sure the socket is non-blocking\n  if (fio_set_non_block(fd) < 0) {\n    freeaddrinfo(addrinfo);\n    close(fd);\n    return -1;\n  }\n  if (server) {\n    {\n      // avoid the \"address taken\"\n      int optval = 1;\n      setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, &optval, sizeof(optval));\n    }\n    // bind the address to the socket\n    int bound = 0;\n    for (struct addrinfo *i = addrinfo; i != NULL; i = i->ai_next) {\n      if (!bind(fd, i->ai_addr, i->ai_addrlen))\n        bound = 1;\n    }\n    if (!bound) {\n      // perror(\"bind err\");\n      freeaddrinfo(addrinfo);\n      close(fd);\n      return -1;\n    }\n#ifdef TCP_FASTOPEN\n    {\n      // support TCP Fast Open when available\n      int optval = 128;\n      setsockopt(fd, addrinfo->ai_protocol, TCP_FASTOPEN, &optval,\n                 sizeof(optval));\n    }\n#endif\n    if (listen(fd, SOMAXCONN) < 0) {\n      freeaddrinfo(addrinfo);\n      close(fd);\n      return -1;\n    }\n  } else {\n    int one = 1;\n    setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, &one, sizeof(one));\n    errno = 0;\n    for (struct addrinfo *i = addrinfo; i; i = i->ai_next) {\n      if (connect(fd, i->ai_addr, i->ai_addrlen) == 0 || errno == EINPROGRESS)\n        goto socket_okay;\n    }\n    freeaddrinfo(addrinfo);\n    close(fd);\n    return -1;\n  }\nsocket_okay:\n  fio_lock(&fd_data(fd).protocol_lock);\n  fio_clear_fd(fd, 1);\n  fio_unlock(&fd_data(fd).protocol_lock);\n  fio_tcp_addr_cpy(fd, addrinfo->ai_family, (void *)addrinfo);\n  freeaddrinfo(addrinfo);\n  return fd2uuid(fd);\n}\n\n/* PUBLIC API: opens a server or client socket */\nintptr_t fio_socket(const char *address, const char *port, uint8_t server) {\n  intptr_t uuid;\n  if (port) {\n    char *pos = (char *)port;\n    int64_t n = fio_atol(&pos);\n    /* make sure port is only numerical */\n    if (*pos) {\n      FIO_LOG_ERROR(\"(fio_socket) port %s is not a number.\", port);\n      errno = EINVAL;\n      return -1;\n    }\n    /* a negative port number will revert to a Unix socket. */\n    if (n <= 0) {\n      if (n < -1)\n        FIO_LOG_WARNING(\"(fio_socket) negative port number %s is ignored.\",\n                        port);\n      port = NULL;\n    }\n  }\n  if (!address && !port) {\n    FIO_LOG_ERROR(\"(fio_socket) both address and port are missing or invalid.\");\n    errno = EINVAL;\n    return -1;\n  }\n  if (!port) {\n    do {\n      errno = 0;\n      uuid = fio_unix_socket(address, server);\n    } while (errno == EINTR);\n  } else {\n    do {\n      errno = 0;\n      uuid = fio_tcp_socket(address, port, server);\n    } while (errno == EINTR);\n  }\n  return uuid;\n}\n\n/* *****************************************************************************\nInternal socket flushing related functions\n***************************************************************************** */\n\n#ifndef BUFFER_FILE_READ_SIZE\n#define BUFFER_FILE_READ_SIZE 49152\n#endif\n\n#if !defined(USE_SENDFILE) && !defined(USE_SENDFILE_LINUX) &&                  \\\n    !defined(USE_SENDFILE_BSD) && !defined(USE_SENDFILE_APPLE)\n#if defined(__linux__) /* linux sendfile works  */\n#define USE_SENDFILE_LINUX 1\n#elif defined(__FreeBSD__) /* FreeBSD sendfile should work - not tested */\n#define USE_SENDFILE_BSD 1\n#elif defined(__APPLE__) /* Is the apple sendfile still broken? */\n#define USE_SENDFILE_APPLE 2\n#else /* sendfile might not be available - always set to 0 */\n#define USE_SENDFILE 0\n#endif\n\n#endif\n\nstatic void fio_sock_perform_close_fd(intptr_t fd) { close(fd); }\n\nstatic inline void fio_sock_packet_rotate_unsafe(uintptr_t fd) {\n  fio_packet_s *packet = fd_data(fd).packet;\n  fd_data(fd).packet = packet->next;\n  fio_atomic_sub(&fd_data(fd).packet_count, 1);\n  if (!packet->next) {\n    fd_data(fd).packet_last = &fd_data(fd).packet;\n    fd_data(fd).packet_count = 0;\n  } else if (&packet->next == fd_data(fd).packet_last) {\n    fd_data(fd).packet_last = &fd_data(fd).packet;\n  }\n  fio_packet_free(packet);\n}\n\nstatic int fio_sock_write_buffer(int fd, fio_packet_s *packet) {\n  int written = fd_data(fd).rw_hooks->write(\n      fd2uuid(fd), fd_data(fd).rw_udata,\n      ((uint8_t *)packet->data.buffer + packet->offset), packet->length);\n  if (written > 0) {\n    packet->length -= written;\n    packet->offset += written;\n    if (!packet->length) {\n      fio_sock_packet_rotate_unsafe(fd);\n    }\n  }\n  return written;\n}\n\nstatic int fio_sock_write_from_fd(int fd, fio_packet_s *packet) {\n  ssize_t asked = 0;\n  ssize_t sent = 0;\n  ssize_t total = 0;\n  char buff[BUFFER_FILE_READ_SIZE];\n  do {\n    packet->offset += sent;\n    packet->length -= sent;\n  retry:\n    asked = pread(packet->data.fd, buff,\n                  ((packet->length < BUFFER_FILE_READ_SIZE)\n                       ? packet->length\n                       : BUFFER_FILE_READ_SIZE),\n                  packet->offset);\n    if (asked <= 0)\n      goto read_error;\n    sent = fd_data(fd).rw_hooks->write(fd2uuid(fd), fd_data(fd).rw_udata, buff,\n                                       asked);\n  } while (sent == asked && packet->length);\n  if (sent >= 0) {\n    packet->offset += sent;\n    packet->length -= sent;\n    total += sent;\n    if (!packet->length) {\n      fio_sock_packet_rotate_unsafe(fd);\n      return 1;\n    }\n  }\n  return total;\n\nread_error:\n  if (sent == 0) {\n    fio_sock_packet_rotate_unsafe(fd);\n    return 1;\n  }\n  if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR)\n    goto retry;\n  return -1;\n}\n\n#if USE_SENDFILE_LINUX /* linux sendfile API */\n#include <sys/sendfile.h>\n\nstatic int fio_sock_sendfile_from_fd(int fd, fio_packet_s *packet) {\n  ssize_t sent;\n  sent =\n      sendfile64(fd, packet->data.fd, (off_t *)&packet->offset, packet->length);\n  if (sent < 0)\n    return -1;\n  packet->length -= sent;\n  if (!packet->length)\n    fio_sock_packet_rotate_unsafe(fd);\n  return sent;\n}\n\n#elif USE_SENDFILE_BSD || USE_SENDFILE_APPLE /* FreeBSD / Apple API */\n#include <sys/uio.h>\n\nstatic int fio_sock_sendfile_from_fd(int fd, fio_packet_s *packet) {\n  off_t act_sent = 0;\n  ssize_t ret = 0;\n  while (packet->length) {\n    act_sent = packet->length;\n#if USE_SENDFILE_APPLE\n    ret = sendfile(packet->data.fd, fd, packet->offset, &act_sent, NULL, 0);\n#else\n    ret = sendfile(packet->data.fd, fd, packet->offset, (size_t)act_sent, NULL,\n                   &act_sent, 0);\n#endif\n    if (ret < 0)\n      goto error;\n    packet->length -= act_sent;\n    packet->offset += act_sent;\n  }\n  fio_sock_packet_rotate_unsafe(fd);\n  return act_sent;\nerror:\n  if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR) {\n    packet->length -= act_sent;\n    packet->offset += act_sent;\n  }\n  return -1;\n}\n\n#else\nstatic int (*fio_sock_sendfile_from_fd)(int fd, fio_packet_s *packet) =\n    fio_sock_write_from_fd;\n\n#endif\n\n/* *****************************************************************************\nSocket / Connection Functions\n***************************************************************************** */\n\n/**\n * Returns the information available about the socket's peer address.\n *\n * If no information is available, the struct will be initialized with zero\n * (`addr == NULL`).\n * The information is only available when the socket was accepted using\n * `fio_accept` or opened using `fio_connect`.\n */\n\n/**\n * `fio_read` attempts to read up to count bytes from the socket into the\n * buffer starting at `buffer`.\n *\n * `fio_read`'s return values are wildly different then the native return\n * values and they aim at making far simpler sense.\n *\n * `fio_read` returns the number of bytes read (0 is a valid return value which\n * simply means that no bytes were read from the buffer).\n *\n * On a fatal connection error that leads to the connection being closed (or if\n * the connection is already closed), `fio_read` returns -1.\n *\n * The value 0 is the valid value indicating no data was read.\n *\n * Data might be available in the kernel's buffer while it is not available to\n * be read using `fio_read` (i.e., when using a transport layer, such as TLS).\n */\nssize_t fio_read(intptr_t uuid, void *buffer, size_t count) {\n  if (!uuid_is_valid(uuid) || !uuid_data(uuid).open) {\n    errno = EBADF;\n    return -1;\n  }\n  if (count == 0)\n    return 0;\n  fio_lock(&uuid_data(uuid).sock_lock);\n  ssize_t (*rw_read)(intptr_t, void *, void *, size_t) =\n      uuid_data(uuid).rw_hooks->read;\n  void *udata = uuid_data(uuid).rw_udata;\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  int old_errno = errno;\n  ssize_t ret;\nretry_int:\n  ret = rw_read(uuid, udata, buffer, count);\n  if (ret > 0) {\n    fio_touch(uuid);\n    return ret;\n  }\n  if (ret < 0 && errno == EINTR)\n    goto retry_int;\n  if (ret < 0 &&\n      (errno == EWOULDBLOCK || errno == EAGAIN || errno == ENOTCONN)) {\n    errno = old_errno;\n    return 0;\n  }\n  fio_force_close(uuid);\n  return -1;\n}\n\n/**\n * `fio_write2_fn` is the actual function behind the macro `fio_write2`.\n */\nssize_t fio_write2_fn(intptr_t uuid, fio_write_args_s options) {\n  if (!uuid_is_valid(uuid))\n    goto error;\n\n  /* create packet */\n  fio_packet_s *packet = fio_packet_alloc();\n  *packet = (fio_packet_s){\n      .length = options.length,\n      .offset = options.offset,\n      .data.buffer = (void *)options.data.buffer,\n  };\n  if (options.is_fd) {\n    packet->write_func = (uuid_data(uuid).rw_hooks == &FIO_DEFAULT_RW_HOOKS)\n                             ? fio_sock_sendfile_from_fd\n                             : fio_sock_write_from_fd;\n    packet->dealloc =\n        (options.after.dealloc ? options.after.dealloc\n                               : (void (*)(void *))fio_sock_perform_close_fd);\n  } else {\n    packet->write_func = fio_sock_write_buffer;\n    packet->dealloc = (options.after.dealloc ? options.after.dealloc : free);\n  }\n  /* add packet to outgoing list */\n  uint8_t was_empty = 1;\n  fio_lock(&uuid_data(uuid).sock_lock);\n  if (!uuid_is_valid(uuid)) {\n    goto locked_error;\n  }\n  if (uuid_data(uuid).packet)\n    was_empty = 0;\n  if (options.urgent == 0) {\n    *uuid_data(uuid).packet_last = packet;\n    uuid_data(uuid).packet_last = &packet->next;\n  } else {\n    fio_packet_s **pos = &uuid_data(uuid).packet;\n    if (*pos)\n      pos = &(*pos)->next;\n    packet->next = *pos;\n    *pos = packet;\n    if (!packet->next) {\n      uuid_data(uuid).packet_last = &packet->next;\n    }\n  }\n  fio_atomic_add(&uuid_data(uuid).packet_count, 1);\n  fio_unlock(&uuid_data(uuid).sock_lock);\n\n  if (was_empty) {\n    touchfd(fio_uuid2fd(uuid));\n    deferred_on_ready((void *)uuid, (void *)1);\n  }\n  return 0;\nlocked_error:\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  fio_packet_free(packet);\n  errno = EBADF;\n  return -1;\nerror:\n  if (options.after.dealloc) {\n    options.after.dealloc((void *)options.data.buffer);\n  }\n  errno = EBADF;\n  return -1;\n}\n\n/** A noop function for fio_write2 in cases not deallocation is required. */\nvoid FIO_DEALLOC_NOOP(void *arg) { (void)arg; }\n\n/**\n * Returns the number of `fio_write` calls that are waiting in the socket's\n * queue and haven't been processed.\n */\nsize_t fio_pending(intptr_t uuid) {\n  if (!uuid_is_valid(uuid))\n    return 0;\n  return uuid_data(uuid).packet_count;\n}\n\n/**\n * `fio_close` marks the connection for disconnection once all the data was\n * sent. The actual disconnection will be managed by the `fio_flush` function.\n *\n * `fio_flash` will be automatically scheduled.\n */\nvoid fio_close(intptr_t uuid) {\n  if (!uuid_is_valid(uuid)) {\n    errno = EBADF;\n    return;\n  }\n  if (uuid_data(uuid).packet || uuid_data(uuid).sock_lock) {\n    uuid_data(uuid).close = 1;\n    fio_poll_add_write(fio_uuid2fd(uuid));\n    return;\n  }\n  fio_force_close(uuid);\n}\n\n/**\n * `fio_force_close` closes the connection immediately, without adhering to any\n * protocol restrictions and without sending any remaining data in the\n * connection buffer.\n */\nvoid fio_force_close(intptr_t uuid) {\n  if (!uuid_is_valid(uuid)) {\n    errno = EBADF;\n    return;\n  }\n  // FIO_LOG_DEBUG(\"fio_force_close called for uuid %p\", (void *)uuid);\n  /* make sure the close marker is set */\n  if (!uuid_data(uuid).close)\n    uuid_data(uuid).close = 1;\n  /* clear away any packets in case we want to cut the connection short. */\n  fio_packet_s *packet = NULL;\n  fio_lock(&uuid_data(uuid).sock_lock);\n  packet = uuid_data(uuid).packet;\n  uuid_data(uuid).packet = NULL;\n  uuid_data(uuid).packet_last = &uuid_data(uuid).packet;\n  uuid_data(uuid).sent = 0;\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  while (packet) {\n    fio_packet_s *tmp = packet;\n    packet = packet->next;\n    fio_packet_free(tmp);\n  }\n  /* check for rw-hooks termination packet */\n  if (uuid_data(uuid).open && (uuid_data(uuid).close & 1) &&\n      uuid_data(uuid).rw_hooks->before_close(uuid, uuid_data(uuid).rw_udata)) {\n    uuid_data(uuid).close = 2; /* don't repeat the before_close callback */\n    fio_touch(uuid);\n    fio_poll_add_write(fio_uuid2fd(uuid));\n    return;\n  }\n  fio_lock(&uuid_data(uuid).protocol_lock);\n  fio_clear_fd(fio_uuid2fd(uuid), 0);\n  fio_unlock(&uuid_data(uuid).protocol_lock);\n  close(fio_uuid2fd(uuid));\n#if FIO_ENGINE_POLL\n  fio_poll_remove_fd(fio_uuid2fd(uuid));\n#endif\n  if (fio_data->connection_count)\n    fio_atomic_sub(&fio_data->connection_count, 1);\n}\n\n/**\n * `fio_flush` attempts to write any remaining data in the internal buffer to\n * the underlying file descriptor and closes the underlying file descriptor once\n * if it's marked for closure (and all the data was sent).\n *\n * Return values: 1 will be returned if data remains in the buffer. 0\n * will be returned if the buffer was fully drained. -1 will be returned on an\n * error or when the connection is closed.\n */\nssize_t fio_flush(intptr_t uuid) {\n  if (!uuid_is_valid(uuid))\n    goto invalid;\n  errno = 0;\n  ssize_t flushed = 0;\n  int tmp;\n  /* start critical section */\n  if (fio_trylock(&uuid_data(uuid).sock_lock))\n    goto would_block;\n\n  if (!uuid_data(uuid).packet)\n    goto flush_rw_hook;\n\n  const fio_packet_s *old_packet = uuid_data(uuid).packet;\n  const size_t old_sent = uuid_data(uuid).sent;\n\n  tmp = uuid_data(uuid).packet->write_func(fio_uuid2fd(uuid),\n                                           uuid_data(uuid).packet);\n  if (tmp <= 0) {\n    goto test_errno;\n  }\n\n  if (uuid_data(uuid).packet_count >= FIO_SLOWLORIS_LIMIT &&\n      uuid_data(uuid).packet == old_packet &&\n      uuid_data(uuid).sent >= old_sent &&\n      (uuid_data(uuid).sent - old_sent) < 32768) {\n    /* Slowloris attack assumed */\n    goto attacked;\n  }\n\n  /* end critical section */\n  fio_unlock(&uuid_data(uuid).sock_lock);\n\n  /* test for fio_close marker */\n  if (!uuid_data(uuid).packet && uuid_data(uuid).close)\n    goto closed;\n\n  /* return state */\n  return uuid_data(uuid).open && uuid_data(uuid).packet != NULL;\n\nwould_block:\n  errno = EWOULDBLOCK;\n  return -1;\n\nclosed:\n  fio_force_close(uuid);\n  return -1;\n\nflush_rw_hook:\n  flushed = uuid_data(uuid).rw_hooks->flush(uuid, uuid_data(uuid).rw_udata);\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  if (!flushed)\n    return 0;\n  if (flushed < 0) {\n    goto test_errno;\n  }\n  touchfd(fio_uuid2fd(uuid));\n  return 1;\n\ntest_errno:\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  switch (errno) {\n  case EWOULDBLOCK: /* fallthrough */\n#if EWOULDBLOCK != EAGAIN\n  case EAGAIN: /* fallthrough */\n#endif\n  case ENOTCONN:      /* fallthrough */\n  case EINPROGRESS:   /* fallthrough */\n  case ENOSPC:        /* fallthrough */\n  case EADDRNOTAVAIL: /* fallthrough */\n  case EINTR:\n    return 1;\n  case EFAULT:\n    FIO_LOG_ERROR(\"fio_flush EFAULT - possible memory address error sent to \"\n                  \"Unix socket.\");\n    /* fallthrough */\n  case EPIPE:  /* fallthrough */\n  case EIO:    /* fallthrough */\n  case EINVAL: /* fallthrough */\n  case EBADF:\n    uuid_data(uuid).close = 1;\n    fio_force_close(uuid);\n    return -1;\n  }\n  fprintf(stderr, \"UUID error: %p (%d)\\n\", (void *)uuid, errno);\n  perror(\"No errno handler\");\n  return 0;\n\ninvalid:\n  /* bad UUID */\n  errno = EBADF;\n  return -1;\n\nattacked:\n  /* don't close, just detach from facil.io and mark uuid as invalid */\n  FIO_LOG_WARNING(\"(facil.io) possible Slowloris attack from %.*s\",\n                  (int)fio_peer_addr(uuid).len, fio_peer_addr(uuid).data);\n  fio_unlock(&uuid_data(uuid).sock_lock);\n  fio_clear_fd(fio_uuid2fd(uuid), 0);\n  return -1;\n}\n\n/** `fio_flush_all` attempts flush all the open connections. */\nsize_t fio_flush_all(void) {\n  if (!fio_data)\n    return 0;\n  size_t count = 0;\n  for (uintptr_t i = 0; i <= fio_data->max_protocol_fd; ++i) {\n    if ((fd_data(i).open || fd_data(i).packet) && fio_flush(fd2uuid(i)) > 0)\n      ++count;\n  }\n  return count;\n}\n\n/* *****************************************************************************\nConnection Read / Write Hooks, for overriding the system calls\n***************************************************************************** */\n\nstatic ssize_t fio_hooks_default_read(intptr_t uuid, void *udata, void *buf,\n                                      size_t count) {\n  return read(fio_uuid2fd(uuid), buf, count);\n  (void)(udata);\n}\nstatic ssize_t fio_hooks_default_write(intptr_t uuid, void *udata,\n                                       const void *buf, size_t count) {\n  return write(fio_uuid2fd(uuid), buf, count);\n  (void)(udata);\n}\n\nstatic ssize_t fio_hooks_default_before_close(intptr_t uuid, void *udata) {\n  return 0;\n  (void)udata;\n  (void)uuid;\n}\n\nstatic ssize_t fio_hooks_default_flush(intptr_t uuid, void *udata) {\n  return 0;\n  (void)(uuid);\n  (void)(udata);\n}\n\nstatic void fio_hooks_default_cleanup(void *udata) { (void)(udata); }\n\nconst fio_rw_hook_s FIO_DEFAULT_RW_HOOKS = {\n    .read = fio_hooks_default_read,\n    .write = fio_hooks_default_write,\n    .flush = fio_hooks_default_flush,\n    .before_close = fio_hooks_default_before_close,\n    .cleanup = fio_hooks_default_cleanup,\n};\n\n/**\n * Replaces an existing read/write hook with another from within a read/write\n * hook callback.\n *\n * Does NOT call any cleanup callbacks.\n *\n * Returns -1 on error, 0 on success.\n */\nint fio_rw_hook_replace_unsafe(intptr_t uuid, fio_rw_hook_s *rw_hooks,\n                               void *udata) {\n  int replaced = -1;\n  uint8_t was_locked;\n  intptr_t fd = fio_uuid2fd(uuid);\n  if (!rw_hooks->read)\n    rw_hooks->read = fio_hooks_default_read;\n  if (!rw_hooks->write)\n    rw_hooks->write = fio_hooks_default_write;\n  if (!rw_hooks->flush)\n    rw_hooks->flush = fio_hooks_default_flush;\n  if (!rw_hooks->before_close)\n    rw_hooks->before_close = fio_hooks_default_before_close;\n  if (!rw_hooks->cleanup)\n    rw_hooks->cleanup = fio_hooks_default_cleanup;\n  /* protect against some fulishness... but not all of it. */\n  was_locked = fio_trylock(&fd_data(fd).sock_lock);\n  if (fd2uuid(fd) == uuid) {\n    fd_data(fd).rw_hooks = rw_hooks;\n    fd_data(fd).rw_udata = udata;\n    replaced = 0;\n  }\n  if (!was_locked)\n    fio_unlock(&fd_data(fd).sock_lock);\n  return replaced;\n}\n\n/** Sets a socket hook state (a pointer to the struct). */\nint fio_rw_hook_set(intptr_t uuid, fio_rw_hook_s *rw_hooks, void *udata) {\n  if (fio_is_closed(uuid))\n    goto invalid_uuid;\n  if (!rw_hooks->read)\n    rw_hooks->read = fio_hooks_default_read;\n  if (!rw_hooks->write)\n    rw_hooks->write = fio_hooks_default_write;\n  if (!rw_hooks->flush)\n    rw_hooks->flush = fio_hooks_default_flush;\n  if (!rw_hooks->before_close)\n    rw_hooks->before_close = fio_hooks_default_before_close;\n  if (!rw_hooks->cleanup)\n    rw_hooks->cleanup = fio_hooks_default_cleanup;\n  intptr_t fd = fio_uuid2fd(uuid);\n  fio_rw_hook_s *old_rw_hooks;\n  void *old_udata;\n  fio_lock(&fd_data(fd).sock_lock);\n  if (fd2uuid(fd) != uuid) {\n    fio_unlock(&fd_data(fd).sock_lock);\n    goto invalid_uuid;\n  }\n  old_rw_hooks = fd_data(fd).rw_hooks;\n  old_udata = fd_data(fd).rw_udata;\n  fd_data(fd).rw_hooks = rw_hooks;\n  fd_data(fd).rw_udata = udata;\n  fio_unlock(&fd_data(fd).sock_lock);\n  if (old_rw_hooks && old_rw_hooks->cleanup)\n    old_rw_hooks->cleanup(old_udata);\n  return 0;\ninvalid_uuid:\n  if (!rw_hooks->cleanup)\n    rw_hooks->cleanup(udata);\n  return -1;\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n                           IO Protocols and Attachment\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/* *****************************************************************************\nSetting the protocol\n***************************************************************************** */\n\n/* managing the protocol pointer array and the `on_close` callback */\nstatic int fio_attach__internal(void *uuid_, void *protocol_) {\n  intptr_t uuid = (intptr_t)uuid_;\n  fio_protocol_s *protocol = (fio_protocol_s *)protocol_;\n  if (protocol) {\n    if (!protocol->on_close) {\n      protocol->on_close = mock_on_ev;\n    }\n    if (!protocol->on_data) {\n      protocol->on_data = mock_on_data;\n    }\n    if (!protocol->on_ready) {\n      protocol->on_ready = mock_on_ev;\n    }\n    if (!protocol->ping) {\n      protocol->ping = mock_ping;\n    }\n    if (!protocol->on_shutdown) {\n      protocol->on_shutdown = mock_on_shutdown;\n    }\n    prt_meta(protocol) = (protocol_metadata_s){.rsv = 0};\n  }\n  if (!uuid_is_valid(uuid))\n    goto invalid_uuid_unlocked;\n  fio_lock(&uuid_data(uuid).protocol_lock);\n  if (!uuid_is_valid(uuid)) {\n    goto invalid_uuid;\n  }\n  fio_protocol_s *old_pr = uuid_data(uuid).protocol;\n  uuid_data(uuid).open = 1;\n  uuid_data(uuid).protocol = protocol;\n  touchfd(fio_uuid2fd(uuid));\n  fio_unlock(&uuid_data(uuid).protocol_lock);\n  if (old_pr) {\n    /* protocol replacement */\n    fio_defer_push_task(deferred_on_close, (void *)uuid, old_pr);\n    if (!protocol) {\n      /* hijacking */\n      fio_poll_remove_fd(fio_uuid2fd(uuid));\n      fio_poll_add_write(fio_uuid2fd(uuid));\n    }\n  } else if (protocol) {\n    /* adding a new uuid to the reactor */\n    fio_poll_add(fio_uuid2fd(uuid));\n  }\n  fio_max_fd_min(fio_uuid2fd(uuid));\n  return 0;\n\ninvalid_uuid:\n  fio_unlock(&uuid_data(uuid).protocol_lock);\ninvalid_uuid_unlocked:\n  // FIO_LOG_DEBUG(\"fio_attach failed for invalid uuid %p\", (void *)uuid);\n  if (protocol)\n    fio_defer_push_task(deferred_on_close, (void *)uuid, protocol);\n  if (uuid == -1)\n    errno = EBADF;\n  else\n    errno = ENOTCONN;\n  return -1;\n}\n\n/**\n * Attaches (or updates) a protocol object to a socket UUID.\n * Returns -1 on error and 0 on success.\n */\nvoid fio_attach(intptr_t uuid, fio_protocol_s *protocol) {\n  fio_attach__internal((void *)uuid, protocol);\n}\n/** Attaches (or updates) a protocol object to a socket UUID.\n * Returns -1 on error and 0 on success.\n */\nvoid fio_attach_fd(int fd, fio_protocol_s *protocol) {\n  fio_attach__internal((void *)fio_fd2uuid(fd), protocol);\n}\n\n/** Sets a timeout for a specific connection (only when running and valid). */\nvoid fio_timeout_set(intptr_t uuid, uint8_t timeout) {\n  if (uuid_is_valid(uuid)) {\n    touchfd(fio_uuid2fd(uuid));\n    uuid_data(uuid).timeout = timeout;\n  } else {\n    FIO_LOG_DEBUG(\"Called fio_timeout_set for invalid uuid %p\", (void *)uuid);\n  }\n}\n/** Gets a timeout for a specific connection. Returns 0 if there's no set\n * timeout or the connection is inactive. */\nuint8_t fio_timeout_get(intptr_t uuid) { return uuid_data(uuid).timeout; }\n\n/* *****************************************************************************\nCore Callbacks for forking / starting up / cleaning up\n***************************************************************************** */\n\ntypedef struct {\n  fio_ls_embd_s node;\n  void (*func)(void *);\n  void *arg;\n} callback_data_s;\n\ntypedef struct {\n  fio_lock_i lock;\n  fio_ls_embd_s callbacks;\n} callback_collection_s;\n\nstatic callback_collection_s callback_collection[FIO_CALL_NEVER + 1];\n\nstatic void fio_state_on_idle_perform(void *task, void *arg) {\n  ((void (*)(void *))(uintptr_t)task)(arg);\n}\n\nstatic inline void fio_state_callback_ensure(callback_collection_s *c) {\n  if (c->callbacks.next)\n    return;\n  c->callbacks = (fio_ls_embd_s)FIO_LS_INIT(c->callbacks);\n}\n\n/** Adds a callback to the list of callbacks to be called for the event. */\nvoid fio_state_callback_add(callback_type_e c_type, void (*func)(void *),\n                            void *arg) {\n  if (c_type == FIO_CALL_ON_INITIALIZE && fio_data) {\n    func(arg);\n    return;\n  }\n  if (!func || (int)c_type < 0 || c_type > FIO_CALL_NEVER)\n    return;\n  fio_lock(&callback_collection[c_type].lock);\n  fio_state_callback_ensure(&callback_collection[c_type]);\n  callback_data_s *tmp = malloc(sizeof(*tmp));\n  FIO_ASSERT_ALLOC(tmp);\n  *tmp = (callback_data_s){.func = func, .arg = arg};\n  fio_ls_embd_push(&callback_collection[c_type].callbacks, &tmp->node);\n  fio_unlock(&callback_collection[c_type].lock);\n}\n\n/** Removes a callback from the list of callbacks to be called for the event. */\nint fio_state_callback_remove(callback_type_e c_type, void (*func)(void *),\n                              void *arg) {\n  if ((int)c_type < 0 || c_type > FIO_CALL_NEVER)\n    return -1;\n  fio_lock(&callback_collection[c_type].lock);\n  FIO_LS_EMBD_FOR(&callback_collection[c_type].callbacks, pos) {\n    callback_data_s *tmp = (FIO_LS_EMBD_OBJ(callback_data_s, node, pos));\n    if (tmp->func == func && tmp->arg == arg) {\n      fio_ls_embd_remove(&tmp->node);\n      free(tmp);\n      goto success;\n    }\n  }\n  fio_unlock(&callback_collection[c_type].lock);\n  return -1;\nsuccess:\n  fio_unlock(&callback_collection[c_type].lock);\n  return -0;\n}\n\n/** Forces all the existing callbacks to run, as if the event occurred. */\nvoid fio_state_callback_force(callback_type_e c_type) {\n  if ((int)c_type < 0 || c_type > FIO_CALL_NEVER)\n    return;\n  /* copy collection */\n  fio_ls_embd_s copy = FIO_LS_INIT(copy);\n  fio_lock(&callback_collection[c_type].lock);\n  fio_state_callback_ensure(&callback_collection[c_type]);\n  switch (c_type) {            /* the difference between `unshift` and `push` */\n  case FIO_CALL_ON_INITIALIZE: /* fallthrough */\n  case FIO_CALL_PRE_START:     /* fallthrough */\n  case FIO_CALL_BEFORE_FORK:   /* fallthrough */\n  case FIO_CALL_AFTER_FORK:    /* fallthrough */\n  case FIO_CALL_IN_CHILD:      /* fallthrough */\n  case FIO_CALL_IN_MASTER:     /* fallthrough */\n  case FIO_CALL_ON_START:      /* fallthrough */\n    FIO_LS_EMBD_FOR(&callback_collection[c_type].callbacks, pos) {\n      callback_data_s *tmp = fio_malloc(sizeof(*tmp));\n      FIO_ASSERT_ALLOC(tmp);\n      *tmp = *(FIO_LS_EMBD_OBJ(callback_data_s, node, pos));\n      fio_ls_embd_unshift(&copy, &tmp->node);\n    }\n    break;\n\n  case FIO_CALL_ON_IDLE: /* idle callbacks are orderless and evented */\n    FIO_LS_EMBD_FOR(&callback_collection[c_type].callbacks, pos) {\n      callback_data_s *tmp = FIO_LS_EMBD_OBJ(callback_data_s, node, pos);\n      fio_defer_push_task(fio_state_on_idle_perform,\n                          (void *)(uintptr_t)tmp->func, tmp->arg);\n    }\n    break;\n\n  case FIO_CALL_ON_SHUTDOWN:     /* fallthrough */\n  case FIO_CALL_ON_FINISH:       /* fallthrough */\n  case FIO_CALL_ON_PARENT_CRUSH: /* fallthrough */\n  case FIO_CALL_ON_CHILD_CRUSH:  /* fallthrough */\n  case FIO_CALL_AT_EXIT:         /* fallthrough */\n  case FIO_CALL_NEVER:           /* fallthrough */\n  default:\n    FIO_LS_EMBD_FOR(&callback_collection[c_type].callbacks, pos) {\n      callback_data_s *tmp = fio_malloc(sizeof(*tmp));\n      FIO_ASSERT_ALLOC(tmp);\n      *tmp = *(FIO_LS_EMBD_OBJ(callback_data_s, node, pos));\n      fio_ls_embd_push(&copy, &tmp->node);\n    }\n    break;\n  }\n\n  fio_unlock(&callback_collection[c_type].lock);\n  /* run callbacks + free data */\n  while (fio_ls_embd_any(&copy)) {\n    callback_data_s *tmp =\n        FIO_LS_EMBD_OBJ(callback_data_s, node, fio_ls_embd_pop(&copy));\n    if (tmp->func) {\n      tmp->func(tmp->arg);\n    }\n    fio_free(tmp);\n  }\n}\n\n/** Clears all the existing callbacks for the event. */\nvoid fio_state_callback_clear(callback_type_e c_type) {\n  if ((int)c_type < 0 || c_type > FIO_CALL_NEVER)\n    return;\n  fio_lock(&callback_collection[c_type].lock);\n  fio_state_callback_ensure(&callback_collection[c_type]);\n  while (fio_ls_embd_any(&callback_collection[c_type].callbacks)) {\n    callback_data_s *tmp = FIO_LS_EMBD_OBJ(\n        callback_data_s, node,\n        fio_ls_embd_shift(&callback_collection[c_type].callbacks));\n    free(tmp);\n  }\n  fio_unlock(&callback_collection[c_type].lock);\n}\n\nvoid fio_state_callback_on_fork(void) {\n  for (size_t i = 0; i < (FIO_CALL_NEVER + 1); ++i) {\n    callback_collection[i].lock = FIO_LOCK_INIT;\n  }\n}\nvoid fio_state_callback_clear_all(void) {\n  for (size_t i = 0; i < (FIO_CALL_NEVER + 1); ++i) {\n    fio_state_callback_clear((callback_type_e)i);\n  }\n}\n\n/* *****************************************************************************\nIO bound tasks\n***************************************************************************** */\n\n// typedef struct {\n//   enum fio_protocol_lock_e type;\n//   void (*task)(intptr_t uuid, fio_protocol_s *, void *udata);\n//   void *udata;\n//   void (*fallback)(intptr_t uuid, void *udata);\n// } fio_defer_iotask_args_s;\n\nstatic void fio_io_task_perform(void *uuid_, void *args_) {\n  fio_defer_iotask_args_s *args = args_;\n  intptr_t uuid = (intptr_t)uuid_;\n  fio_protocol_s *pr = fio_protocol_try_lock(uuid, args->type);\n  if (!pr)\n    goto postpone;\n  args->task(uuid, pr, args->udata);\n  fio_protocol_unlock(pr, args->type);\n  fio_free(args);\n  return;\npostpone:\n  if (errno == EBADF) {\n    if (args->fallback)\n      args->fallback(uuid, args->udata);\n    fio_free(args);\n    return;\n  }\n  fio_defer_push_task(fio_io_task_perform, uuid_, args_);\n}\n/**\n * Schedules a protected connection task. The task will run within the\n * connection's lock.\n *\n * If an error ocuurs or the connection is closed before the task can run, the\n * `fallback` task wil be called instead, allowing for resource cleanup.\n */\nvoid fio_defer_io_task FIO_IGNORE_MACRO(intptr_t uuid,\n                                        fio_defer_iotask_args_s args) {\n  if (!args.task) {\n    if (args.fallback)\n      fio_defer_push_task((void (*)(void *, void *))args.fallback, (void *)uuid,\n                          args.udata);\n    return;\n  }\n  fio_defer_iotask_args_s *cpy = fio_malloc(sizeof(*cpy));\n  FIO_ASSERT_ALLOC(cpy);\n  *cpy = args;\n  fio_defer_push_task(fio_io_task_perform, (void *)uuid, cpy);\n}\n\n/* *****************************************************************************\nInitialize the library\n***************************************************************************** */\n\nstatic void fio_pubsub_on_fork(void);\n\n/* Called within a child process after it starts. */\nstatic void fio_on_fork(void) {\n  fio_timer_lock = FIO_LOCK_INIT;\n  fio_data->lock = FIO_LOCK_INIT;\n  fio_defer_on_fork();\n  fio_malloc_after_fork();\n  fio_poll_init();\n  fio_state_callback_on_fork();\n\n  const size_t limit = fio_data->capa;\n  for (size_t i = 0; i < limit; ++i) {\n    fd_data(i).sock_lock = FIO_LOCK_INIT;\n    fd_data(i).protocol_lock = FIO_LOCK_INIT;\n    if (fd_data(i).protocol) {\n      fd_data(i).protocol->rsv = 0;\n      fio_force_close(fd2uuid(i));\n    }\n  }\n\n  fio_pubsub_on_fork();\n  fio_max_fd_shrink();\n  uint16_t old_active = fio_data->active;\n  fio_data->active = 0;\n  fio_defer_perform();\n  fio_data->active = old_active;\n  fio_data->is_worker = 1;\n}\n\nstatic void fio_mem_destroy(void);\nstatic void __attribute__((destructor)) fio_lib_destroy(void) {\n  uint8_t add_eol = fio_is_master();\n  fio_data->active = 0;\n  fio_on_fork();\n  fio_defer_perform();\n  fio_timer_clear_all();\n  fio_defer_perform();\n  fio_state_callback_force(FIO_CALL_AT_EXIT);\n  fio_state_callback_clear_all();\n  fio_defer_perform();\n  fio_poll_close();\n  fio_free(fio_data);\n  /* memory library destruction must be last */\n  fio_mem_destroy();\n  FIO_LOG_DEBUG(\"(%d) facil.io resources released, exit complete.\",\n                (int)getpid());\n  if (add_eol)\n    fprintf(stderr, \"\\n\"); /* add EOL to logs (logging adds EOL before text */\n}\n\nstatic void fio_mem_init(void);\nstatic void fio_cluster_init(void);\nstatic void fio_pubsub_initialize(void);\nstatic void __attribute__((constructor)) fio_lib_init(void) {\n  /* detect socket capacity - MUST be first...*/\n  ssize_t capa = 0;\n  {\n#ifdef _SC_OPEN_MAX\n    capa = sysconf(_SC_OPEN_MAX);\n#elif defined(FOPEN_MAX)\n    capa = FOPEN_MAX;\n#endif\n    // try to maximize limits - collect max and set to max\n    struct rlimit rlim = {.rlim_max = 0};\n    if (getrlimit(RLIMIT_NOFILE, &rlim) == -1) {\n      FIO_LOG_WARNING(\"`getrlimit` failed in `fio_lib_init`.\");\n      perror(\"\\terrno:\");\n    } else {\n      rlim_t original = rlim.rlim_cur;\n      rlim.rlim_cur = rlim.rlim_max;\n      if (rlim.rlim_cur > FIO_MAX_SOCK_CAPACITY) {\n        rlim.rlim_cur = rlim.rlim_max = FIO_MAX_SOCK_CAPACITY;\n      }\n      while (setrlimit(RLIMIT_NOFILE, &rlim) == -1 && rlim.rlim_cur > original)\n        --rlim.rlim_cur;\n      getrlimit(RLIMIT_NOFILE, &rlim);\n      capa = rlim.rlim_cur;\n      if (capa > 1024) /* leave a slice of room */\n        capa -= 16;\n    }\n    /* initialize memory allocator */\n    fio_mem_init();\n    /* initialize polling engine */\n    fio_poll_init();\n    /* initialize the cluster engine */\n    fio_pubsub_initialize();\n#if DEBUG\n#if FIO_ENGINE_POLL\n    FIO_LOG_INFO(\"facil.io \" FIO_VERSION_STRING \" capacity initialization:\\n\"\n                 \"*    Meximum open files %zu out of %zu\\n\"\n                 \"*    Allocating %zu bytes for state handling.\\n\"\n                 \"*    %zu bytes per connection + %zu for state handling.\",\n                 capa, (size_t)rlim.rlim_max,\n                 (sizeof(*fio_data) + (capa * (sizeof(*fio_data->poll))) +\n                  (capa * (sizeof(*fio_data->info)))),\n                 (sizeof(*fio_data->poll) + sizeof(*fio_data->info)),\n                 sizeof(*fio_data));\n#else\n    FIO_LOG_INFO(\"facil.io \" FIO_VERSION_STRING \" capacity initialization:\\n\"\n                 \"*    Meximum open files %zu out of %zu\\n\"\n                 \"*    Allocating %zu bytes for state handling.\\n\"\n                 \"*    %zu bytes per connection + %zu for state handling.\",\n                 capa, (size_t)rlim.rlim_max,\n                 (sizeof(*fio_data) + (capa * (sizeof(*fio_data->info)))),\n                 (sizeof(*fio_data->info)), sizeof(*fio_data));\n#endif\n#endif\n  }\n\n#if FIO_ENGINE_POLL\n  /* allocate and initialize main data structures by detected capacity */\n  fio_data = fio_mmap(sizeof(*fio_data) + (capa * (sizeof(*fio_data->poll))) +\n                      (capa * (sizeof(*fio_data->info))));\n  FIO_ASSERT_ALLOC(fio_data);\n  fio_data->capa = capa;\n  fio_data->poll =\n      (void *)((uintptr_t)(fio_data + 1) + (sizeof(fio_data->info[0]) * capa));\n#else\n  /* allocate and initialize main data structures by detected capacity */\n  fio_data = fio_mmap(sizeof(*fio_data) + (capa * (sizeof(*fio_data->info))));\n  FIO_ASSERT_ALLOC(fio_data);\n  fio_data->capa = capa;\n#endif\n  fio_data->parent = getpid();\n  fio_data->connection_count = 0;\n  fio_mark_time();\n\n  for (ssize_t i = 0; i < capa; ++i) {\n    fio_clear_fd(i, 0);\n#if FIO_ENGINE_POLL\n    fio_data->poll[i].fd = -1;\n#endif\n  }\n\n  /* call initialization callbacks */\n  fio_state_callback_force(FIO_CALL_ON_INITIALIZE);\n  fio_state_callback_clear(FIO_CALL_ON_INITIALIZE);\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n                             Running the IO Reactor\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\nstatic void fio_cluster_signal_children(void);\n\nstatic void fio_review_timeout(void *arg, void *ignr) {\n  // TODO: Fix review for connections with no protocol?\n  (void)ignr;\n  fio_protocol_s *tmp;\n  time_t review = fio_data->last_cycle.tv_sec;\n  intptr_t fd = (intptr_t)arg;\n\n  uint16_t timeout = fd_data(fd).timeout;\n  if (!timeout)\n    timeout = 300; /* enforced timout settings */\n  if (!fd_data(fd).protocol || (fd_data(fd).active + timeout >= review))\n    goto finish;\n  tmp = protocol_try_lock(fd, FIO_PR_LOCK_STATE);\n  if (!tmp) {\n    if (errno == EBADF)\n      goto finish;\n    goto reschedule;\n  }\n  if (prt_meta(tmp).locks[FIO_PR_LOCK_TASK] ||\n      prt_meta(tmp).locks[FIO_PR_LOCK_WRITE])\n    goto unlock;\n  fio_defer_push_task(deferred_ping, (void *)fio_fd2uuid((int)fd), NULL);\nunlock:\n  protocol_unlock(tmp, FIO_PR_LOCK_STATE);\nfinish:\n  do {\n    fd++;\n  } while (!fd_data(fd).protocol && (fd <= fio_data->max_protocol_fd));\n\n  if (fio_data->max_protocol_fd < fd) {\n    fio_data->need_review = 1;\n    return;\n  }\nreschedule:\n  fio_defer_push_task(fio_review_timeout, (void *)fd, NULL);\n}\n\n/* reactor pattern cycling - common actions */\nstatic void fio_cycle_schedule_events(void) {\n  static int idle = 0;\n  static time_t last_to_review = 0;\n  fio_mark_time();\n  fio_timer_schedule();\n  fio_max_fd_shrink();\n  if (fio_signal_children_flag) {\n    /* hot restart support */\n    fio_signal_children_flag = 0;\n    fio_cluster_signal_children();\n  }\n  int events = fio_poll();\n  if (events < 0) {\n    return;\n  }\n  if (events > 0) {\n    idle = 1;\n  } else {\n    /* events == 0 */\n    if (idle) {\n      fio_state_callback_force(FIO_CALL_ON_IDLE);\n      idle = 0;\n    }\n  }\n  if (fio_data->need_review && fio_data->last_cycle.tv_sec != last_to_review) {\n    last_to_review = fio_data->last_cycle.tv_sec;\n    fio_data->need_review = 0;\n    fio_defer_push_task(fio_review_timeout, (void *)0, NULL);\n  }\n}\n\n/* reactor pattern cycling during cleanup */\nstatic void fio_cycle_unwind(void *ignr, void *ignr2) {\n  if (fio_data->connection_count) {\n    fio_cycle_schedule_events();\n    fio_defer_push_task(fio_cycle_unwind, ignr, ignr2);\n    return;\n  }\n  fio_stop();\n  return;\n}\n\n/* reactor pattern cycling */\nstatic void fio_cycle(void *ignr, void *ignr2) {\n  fio_cycle_schedule_events();\n  if (fio_data->active) {\n    fio_defer_push_task(fio_cycle, ignr, ignr2);\n    return;\n  }\n  return;\n}\n\n/* TODO: fixme */\nstatic void fio_worker_startup(void) {\n  /* Call the on_start callbacks for worker processes. */\n  if (fio_data->workers == 1 || fio_data->is_worker) {\n    fio_state_callback_force(FIO_CALL_ON_START);\n    fio_state_callback_clear(FIO_CALL_ON_START);\n  }\n\n  if (fio_data->workers == 1) {\n    /* Single Process - the root is also a worker */\n    fio_data->is_worker = 1;\n  } else if (fio_data->is_worker) {\n    /* Worker Process */\n    FIO_LOG_INFO(\"%d is running.\", (int)getpid());\n  } else {\n    /* Root Process should run in single thread mode */\n    fio_data->threads = 1;\n  }\n\n  /* require timeout review */\n  fio_data->need_review = 1;\n\n  /* the cycle task will loop by re-scheduling until it's time to finish */\n  fio_defer_push_task(fio_cycle, NULL, NULL);\n\n  /* A single thread doesn't need a pool. */\n  if (fio_data->threads > 1) {\n    fio_defer_thread_pool_join(fio_defer_thread_pool_new(fio_data->threads));\n  } else {\n    fio_defer_perform();\n  }\n}\n\n/* performs all clean-up / shutdown requirements except for the exit sequence */\nstatic void fio_worker_cleanup(void) {\n  /* switch to winding down */\n  if (fio_data->is_worker)\n    FIO_LOG_INFO(\"(%d) detected exit signal.\", (int)getpid());\n  else\n    FIO_LOG_INFO(\"Server Detected exit signal.\");\n  fio_state_callback_force(FIO_CALL_ON_SHUTDOWN);\n  for (size_t i = 0; i <= fio_data->max_protocol_fd; ++i) {\n    if (fd_data(i).protocol) {\n      fio_defer_push_task(deferred_on_shutdown, (void *)fd2uuid(i), NULL);\n    }\n  }\n  fio_defer_push_task(fio_cycle_unwind, NULL, NULL);\n  fio_defer_perform();\n  for (size_t i = 0; i <= fio_data->max_protocol_fd; ++i) {\n    if (fd_data(i).protocol || fd_data(i).open) {\n      fio_force_close(fd2uuid(i));\n    }\n  }\n  fio_timer_clear_all();\n  fio_defer_perform();\n  if (!fio_data->is_worker) {\n    kill(0, SIGINT);\n    while (wait(NULL) != -1)\n      ;\n  }\n  fio_defer_perform();\n  fio_state_callback_force(FIO_CALL_ON_FINISH);\n  fio_defer_perform();\n  fio_signal_handler_reset();\n  if (fio_data->parent == getpid()) {\n    FIO_LOG_INFO(\"   ---  Shutdown Complete  ---\\n\");\n  } else {\n    FIO_LOG_INFO(\"(%d) cleanup complete.\", (int)getpid());\n  }\n}\n\nstatic void fio_sentinel_task(void *arg1, void *arg2);\nstatic void *fio_sentinel_worker_thread(void *arg) {\n  errno = 0;\n  pid_t child = fio_fork();\n  /* release fork lock. */\n  fio_unlock(&fio_fork_lock);\n  if (child == -1) {\n    FIO_LOG_FATAL(\"couldn't spawn worker.\");\n    perror(\"\\n           errno\");\n    kill(fio_parent_pid(), SIGINT);\n    fio_stop();\n    return NULL;\n  } else if (child) {\n    int status;\n    waitpid(child, &status, 0);\n#if DEBUG\n    if (fio_data->active) { /* !WIFEXITED(status) || WEXITSTATUS(status) */\n      if (!WIFEXITED(status) || WEXITSTATUS(status)) {\n        FIO_LOG_FATAL(\"Child worker (%d) crashed. Stopping services.\", child);\n        fio_state_callback_force(FIO_CALL_ON_CHILD_CRUSH);\n      } else {\n        FIO_LOG_FATAL(\"Child worker (%d) shutdown. Stopping services.\", child);\n      }\n      kill(0, SIGINT);\n    }\n#else\n    if (fio_data->active) {\n      /* don't call any functions while forking. */\n      fio_lock(&fio_fork_lock);\n      if (!WIFEXITED(status) || WEXITSTATUS(status)) {\n        FIO_LOG_ERROR(\"Child worker (%d) crashed. Respawning worker.\",\n                      (int)child);\n        fio_state_callback_force(FIO_CALL_ON_CHILD_CRUSH);\n      } else {\n        FIO_LOG_WARNING(\"Child worker (%d) shutdown. Respawning worker.\",\n                        (int)child);\n      }\n      fio_defer_push_task(fio_sentinel_task, NULL, NULL);\n      fio_unlock(&fio_fork_lock);\n    }\n#endif\n  } else {\n    fio_on_fork();\n    fio_state_callback_force(FIO_CALL_AFTER_FORK);\n    fio_state_callback_force(FIO_CALL_IN_CHILD);\n    fio_worker_startup();\n    fio_worker_cleanup();\n    exit(0);\n  }\n  return NULL;\n  (void)arg;\n}\n\nstatic void fio_sentinel_task(void *arg1, void *arg2) {\n  if (!fio_data->active)\n    return;\n  fio_state_callback_force(FIO_CALL_BEFORE_FORK);\n  fio_lock(&fio_fork_lock); /* will wait for worker thread to release lock. */\n  void *thrd =\n      fio_thread_new(fio_sentinel_worker_thread, (void *)&fio_fork_lock);\n  fio_thread_free(thrd);\n  fio_lock(&fio_fork_lock);   /* will wait for worker thread to release lock. */\n  fio_unlock(&fio_fork_lock); /* release lock for next fork. */\n  fio_state_callback_force(FIO_CALL_AFTER_FORK);\n  fio_state_callback_force(FIO_CALL_IN_MASTER);\n  (void)arg1;\n  (void)arg2;\n}\n\nFIO_FUNC void fio_start_(void) {} /* marker for SublimeText3 jump feature */\n\n/**\n * Starts the facil.io event loop. This function will return after facil.io is\n * done (after shutdown).\n *\n * See the `struct fio_start_args` details for any possible named arguments.\n *\n * This method blocks the current thread until the server is stopped (when a\n * SIGINT/SIGTERM is received).\n */\nvoid fio_start FIO_IGNORE_MACRO(struct fio_start_args args) {\n  fio_expected_concurrency(&args.threads, &args.workers);\n  fio_signal_handler_setup();\n\n  fio_data->workers = (uint16_t)args.workers;\n  fio_data->threads = (uint16_t)args.threads;\n  fio_data->active = 1;\n  fio_data->is_worker = 0;\n\n  fio_state_callback_force(FIO_CALL_PRE_START);\n\n  FIO_LOG_INFO(\n      \"Server is running %u %s X %u %s with facil.io \" FIO_VERSION_STRING\n      \" (%s)\\n\"\n      \"* Detected capacity: %d open file limit\\n\"\n      \"* Root pid: %d\\n\"\n      \"* Press ^C to stop\\n\",\n      fio_data->workers, fio_data->workers > 1 ? \"workers\" : \"worker\",\n      fio_data->threads, fio_data->threads > 1 ? \"threads\" : \"thread\",\n      fio_engine(), fio_data->capa, (int)fio_data->parent);\n\n  if (args.workers > 1) {\n    for (int i = 0; i < args.workers && fio_data->active; ++i) {\n      fio_sentinel_task(NULL, NULL);\n    }\n  }\n  fio_worker_startup();\n  fio_worker_cleanup();\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                       Converting Numbers to Strings (and back)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/* *****************************************************************************\nStrings to Numbers\n***************************************************************************** */\n\nFIO_FUNC inline size_t fio_atol_skip_zero(char **pstr) {\n  char *const start = *pstr;\n  while (**pstr == '0') {\n    ++(*pstr);\n  }\n  return (size_t)(*pstr - *start);\n}\n\n/* consumes any digits in the string (base 2-10), returning their value */\nFIO_FUNC inline uint64_t fio_atol_consume(char **pstr, uint8_t base) {\n  uint64_t result = 0;\n  const uint64_t limit = UINT64_MAX - (base * base);\n  while (**pstr >= '0' && **pstr < ('0' + base) && result <= (limit)) {\n    result = (result * base) + (**pstr - '0');\n    ++(*pstr);\n  }\n  return result;\n}\n\n/* returns true if there's data to be skipped */\nFIO_FUNC inline uint8_t fio_atol_skip_test(char **pstr, uint8_t base) {\n  return (**pstr >= '0' && **pstr < ('0' + base));\n}\n\n/* consumes any digits in the string (base 2-10), returning the count skipped */\nFIO_FUNC inline uint64_t fio_atol_skip(char **pstr, uint8_t base) {\n  uint64_t result = 0;\n  while (fio_atol_skip_test(pstr, base)) {\n    ++result;\n    ++(*pstr);\n  }\n  return result;\n}\n\n/* consumes any hex data in the string, returning their value */\nFIO_FUNC inline uint64_t fio_atol_consume_hex(char **pstr) {\n  uint64_t result = 0;\n  const uint64_t limit = UINT64_MAX - (16 * 16);\n  for (; result <= limit;) {\n    uint8_t tmp;\n    if (**pstr >= '0' && **pstr <= '9')\n      tmp = **pstr - '0';\n    else if (**pstr >= 'A' && **pstr <= 'F')\n      tmp = **pstr - ('A' - 10);\n    else if (**pstr >= 'a' && **pstr <= 'f')\n      tmp = **pstr - ('a' - 10);\n    else\n      return result;\n    result = (result << 4) | tmp;\n    ++(*pstr);\n  }\n  return result;\n}\n\n/* returns true if there's data to be skipped */\nFIO_FUNC inline uint8_t fio_atol_skip_hex_test(char **pstr) {\n  return (**pstr >= '0' && **pstr <= '9') || (**pstr >= 'A' && **pstr <= 'F') ||\n         (**pstr >= 'a' && **pstr <= 'f');\n}\n\n/* consumes any digits in the string (base 2-10), returning the count skipped */\nFIO_FUNC inline uint64_t fio_atol_skip_hex(char **pstr) {\n  uint64_t result = 0;\n  while (fio_atol_skip_hex_test(pstr)) {\n    ++result;\n    ++(*pstr);\n  }\n  return result;\n}\n\n/* caches a up to 8*8 */\n// static inline fio_atol_pow_10_cache(size_t ex) {}\n\n/**\n * A helper function that converts between String data to a signed int64_t.\n *\n * Numbers are assumed to be in base 10. Octal (`0###`), Hex (`0x##`/`x##`) and\n * binary (`0b##`/ `b##`) are recognized as well. For binary Most Significant\n * Bit must come first.\n *\n * The most significant difference between this function and `strtol` (aside of\n * API design), is the added support for binary representations.\n */\nint64_t fio_atol(char **pstr) {\n  /* No binary representation in strtol */\n  char *str = *pstr;\n  uint64_t result = 0;\n  uint8_t invert = 0;\n  while (isspace(*str))\n    ++(str);\n  if (str[0] == '-') {\n    invert ^= 1;\n    ++str;\n  } else if (*str == '+') {\n    ++(str);\n  }\n\n  if (str[0] == 'B' || str[0] == 'b' ||\n      (str[0] == '0' && (str[1] == 'b' || str[1] == 'B'))) {\n    /* base 2 */\n    if (str[0] == '0')\n      str++;\n    str++;\n    fio_atol_skip_zero(&str);\n    while (str[0] == '0' || str[0] == '1') {\n      result = (result << 1) | (str[0] - '0');\n      str++;\n    }\n    goto sign; /* no overlow protection, since sign might be embedded */\n\n  } else if (str[0] == 'x' || str[0] == 'X' ||\n             (str[0] == '0' && (str[1] == 'x' || str[1] == 'X'))) {\n    /* base 16 */\n    if (str[0] == '0')\n      str++;\n    str++;\n    fio_atol_skip_zero(&str);\n    result = fio_atol_consume_hex(&str);\n    if (fio_atol_skip_hex_test(&str)) /* too large for a number */\n      return 0;\n    goto sign; /* no overlow protection, since sign might be embedded */\n  } else if (str[0] == '0') {\n    fio_atol_skip_zero(&str);\n    /* base 8 */\n    result = fio_atol_consume(&str, 8);\n    if (fio_atol_skip_test(&str, 8)) /* too large for a number */\n      return 0;\n  } else {\n    /* base 10 */\n    result = fio_atol_consume(&str, 10);\n    if (fio_atol_skip_test(&str, 10)) /* too large for a number */\n      return 0;\n  }\n  if (result & ((uint64_t)1 << 63))\n    result = INT64_MAX; /* signed overflow protection */\nsign:\n  if (invert)\n    result = 0 - result;\n  *pstr = str;\n  return (int64_t)result;\n}\n\n/** A helper function that converts between String data to a signed double. */\ndouble fio_atof(char **pstr) { return strtold(*pstr, pstr); }\n\n/* *****************************************************************************\nNumbers to Strings\n***************************************************************************** */\n\n/**\n * A helper function that writes a signed int64_t to a string.\n *\n * No overflow guard is provided, make sure there's at least 68 bytes\n * available (for base 2).\n *\n * Offers special support for base 2 (binary), base 8 (octal), base 10 and base\n * 16 (hex). An unsupported base will silently default to base 10. Prefixes\n * are automatically added (i.e., \"0x\" for hex and \"0b\" for base 2).\n *\n * Returns the number of bytes actually written (excluding the NUL\n * terminator).\n */\nsize_t fio_ltoa(char *dest, int64_t num, uint8_t base) {\n  const char notation[] = {'0', '1', '2', '3', '4', '5', '6', '7',\n                           '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n\n  size_t len = 0;\n  char buf[48]; /* we only need up to 20 for base 10, but base 3 needs 41... */\n\n  if (!num)\n    goto zero;\n\n  switch (base) {\n  case 1: /* fallthrough */\n  case 2:\n    /* Base 2 */\n    {\n      uint64_t n = num; /* avoid bit shifting inconsistencies with signed bit */\n      uint8_t i = 0;    /* counting bits */\n      dest[len++] = '0';\n      dest[len++] = 'b';\n\n      while ((i < 64) && (n & 0x8000000000000000) == 0) {\n        n = n << 1;\n        i++;\n      }\n      /* make sure the Binary representation doesn't appear signed. */\n      if (i) {\n        dest[len++] = '0';\n      }\n      /* write to dest. */\n      while (i < 64) {\n        dest[len++] = ((n & 0x8000000000000000) ? '1' : '0');\n        n = n << 1;\n        i++;\n      }\n      dest[len] = 0;\n      return len;\n    }\n  case 8:\n    /* Base 8 */\n    {\n      uint64_t l = 0;\n      if (num < 0) {\n        dest[len++] = '-';\n        num = 0 - num;\n      }\n      dest[len++] = '0';\n\n      while (num) {\n        buf[l++] = '0' + (num & 7);\n        num = num >> 3;\n      }\n      while (l) {\n        --l;\n        dest[len++] = buf[l];\n      }\n      dest[len] = 0;\n      return len;\n    }\n\n  case 16:\n    /* Base 16 */\n    {\n      uint64_t n = num; /* avoid bit shifting inconsistencies with signed bit */\n      uint8_t i = 0;    /* counting bits */\n      dest[len++] = '0';\n      dest[len++] = 'x';\n      while (i < 8 && (n & 0xFF00000000000000) == 0) {\n        n = n << 8;\n        i++;\n      }\n      /* make sure the Hex representation doesn't appear misleadingly signed. */\n      if (i && (n & 0x8000000000000000)) {\n        dest[len++] = '0';\n        dest[len++] = '0';\n      }\n      /* write the damn thing, high to low */\n      while (i < 8) {\n        uint8_t tmp = (n & 0xF000000000000000) >> 60;\n        dest[len++] = notation[tmp];\n        tmp = (n & 0x0F00000000000000) >> 56;\n        dest[len++] = notation[tmp];\n        i++;\n        n = n << 8;\n      }\n      dest[len] = 0;\n      return len;\n    }\n  case 3: /* fallthrough */\n  case 4: /* fallthrough */\n  case 5: /* fallthrough */\n  case 6: /* fallthrough */\n  case 7: /* fallthrough */\n  case 9: /* fallthrough */\n    /* rare bases */\n    if (num < 0) {\n      dest[len++] = '-';\n      num = 0 - num;\n    }\n    uint64_t l = 0;\n    while (num) {\n      uint64_t t = num / base;\n      buf[l++] = '0' + (num - (t * base));\n      num = t;\n    }\n    while (l) {\n      --l;\n      dest[len++] = buf[l];\n    }\n    dest[len] = 0;\n    return len;\n\n  default:\n    break;\n  }\n  /* Base 10, the default base */\n\n  if (num < 0) {\n    dest[len++] = '-';\n    num = 0 - num;\n  }\n  uint64_t l = 0;\n  while (num) {\n    uint64_t t = num / 10;\n    buf[l++] = '0' + (num - (t * 10));\n    num = t;\n  }\n  while (l) {\n    --l;\n    dest[len++] = buf[l];\n  }\n  dest[len] = 0;\n  return len;\n\nzero:\n  switch (base) {\n  case 1:\n  case 2:\n    dest[len++] = '0';\n    dest[len++] = 'b';\n    break;\n  case 8:\n    dest[len++] = '0';\n    break;\n  case 16:\n    dest[len++] = '0';\n    dest[len++] = 'x';\n    dest[len++] = '0';\n    break;\n  }\n  dest[len++] = '0';\n  dest[len] = 0;\n  return len;\n}\n\n/**\n * A helper function that converts between a double to a string.\n *\n * No overflow guard is provided, make sure there's at least 130 bytes\n * available (for base 2).\n *\n * Supports base 2, base 10 and base 16. An unsupported base will silently\n * default to base 10. Prefixes aren't added (i.e., no \"0x\" or \"0b\" at the\n * beginning of the string).\n *\n * Returns the number of bytes actually written (excluding the NUL\n * terminator).\n */\nsize_t fio_ftoa(char *dest, double num, uint8_t base) {\n  if (base == 2 || base == 16) {\n    /* handle the binary / Hex representation the same as if it were an\n     * int64_t\n     */\n    int64_t *i = (void *)&num;\n    return fio_ltoa(dest, *i, base);\n  }\n\n  size_t written = sprintf(dest, \"%g\", num);\n  uint8_t need_zero = 1;\n  char *start = dest;\n  while (*start) {\n    if (*start == ',') // locale issues?\n      *start = '.';\n    if (*start == '.' || *start == 'e') {\n      need_zero = 0;\n      break;\n    }\n    start++;\n  }\n  if (need_zero) {\n    dest[written++] = '.';\n    dest[written++] = '0';\n  }\n  return written;\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n                       SSL/TLS Weak Symbols for TLS Support\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/**\n * Returns the number of registered ALPN protocol names.\n *\n * This could be used when deciding if protocol selection should be delegated to\n * the ALPN mechanism, or whether a protocol should be immediately assigned.\n *\n * If no ALPN protocols are registered, zero (0) is returned.\n */\nuintptr_t FIO_TLS_WEAK fio_tls_alpn_count(void *tls) {\n  return 0;\n  (void)tls;\n}\n\n/**\n * Establishes an SSL/TLS connection as an SSL/TLS Server, using the specified\n * context / settings object.\n *\n * The `uuid` should be a socket UUID that is already connected to a peer (i.e.,\n * the result of `fio_accept`).\n *\n * The `udata` is an opaque user data pointer that is passed along to the\n * protocol selected (if any protocols were added using `fio_tls_alpn_add`).\n */\nvoid FIO_TLS_WEAK fio_tls_accept(intptr_t uuid, void *tls, void *udata) {\n  FIO_LOG_FATAL(\"No supported SSL/TLS library available.\");\n  exit(-1);\n  return;\n  (void)uuid;\n  (void)tls;\n  (void)udata;\n}\n\n/**\n * Establishes an SSL/TLS connection as an SSL/TLS Client, using the specified\n * context / settings object.\n *\n * The `uuid` should be a socket UUID that is already connected to a peer (i.e.,\n * one received by a `fio_connect` specified callback `on_connect`).\n *\n * The `udata` is an opaque user data pointer that is passed along to the\n * protocol selected (if any protocols were added using `fio_tls_alpn_add`).\n */\nvoid FIO_TLS_WEAK fio_tls_connect(intptr_t uuid, void *tls, void *udata) {\n  FIO_LOG_FATAL(\"No supported SSL/TLS library available.\");\n  exit(-1);\n  return;\n  (void)uuid;\n  (void)tls;\n  (void)udata;\n}\n\n/**\n * Increase the reference count for the TLS object.\n *\n * Decrease with `fio_tls_destroy`.\n */\nvoid FIO_TLS_WEAK fio_tls_dup(void *tls) {\n  FIO_LOG_FATAL(\"No supported SSL/TLS library available.\");\n  exit(-1);\n  return;\n  (void)tls;\n}\n\n/**\n * Destroys the SSL/TLS context / settings object and frees any related\n * resources / memory.\n */\nvoid FIO_TLS_WEAK fio_tls_destroy(void *tls) {\n  FIO_LOG_FATAL(\"No supported SSL/TLS library available.\");\n  exit(-1);\n  return;\n  (void)tls;\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                       Listening to Incoming Connections\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/* *****************************************************************************\nThe listening protocol (use the facil.io API to make a socket and attach it)\n***************************************************************************** */\n\ntypedef struct {\n  fio_protocol_s pr;\n  intptr_t uuid;\n  void *udata;\n  void (*on_open)(intptr_t uuid, void *udata);\n  void (*on_start)(intptr_t uuid, void *udata);\n  void (*on_finish)(intptr_t uuid, void *udata);\n  char *port;\n  char *addr;\n  size_t port_len;\n  size_t addr_len;\n  void *tls;\n} fio_listen_protocol_s;\n\nstatic void fio_listen_cleanup_task(void *pr_) {\n  fio_listen_protocol_s *pr = pr_;\n  if (pr->tls)\n    fio_tls_destroy(pr->tls);\n  if (pr->on_finish) {\n    pr->on_finish(pr->uuid, pr->udata);\n  }\n  fio_force_close(pr->uuid);\n  if (pr->addr &&\n      (!pr->port || *pr->port == 0 ||\n       (pr->port[0] == '0' && pr->port[1] == 0)) &&\n      fio_is_master()) {\n    /* delete Unix sockets */\n    unlink(pr->addr);\n  }\n  free(pr_);\n}\n\nstatic void fio_listen_on_startup(void *pr_) {\n  fio_state_callback_remove(FIO_CALL_ON_SHUTDOWN, fio_listen_cleanup_task, pr_);\n  fio_listen_protocol_s *pr = pr_;\n  fio_attach(pr->uuid, &pr->pr);\n  if (pr->port_len)\n    FIO_LOG_DEBUG(\"(%d) started listening on port %s\", (int)getpid(), pr->port);\n  else\n    FIO_LOG_DEBUG(\"(%d) started listening on Unix Socket at %s\", (int)getpid(),\n                  pr->addr);\n}\n\nstatic void fio_listen_on_close(intptr_t uuid, fio_protocol_s *pr_) {\n  fio_listen_cleanup_task(pr_);\n  (void)uuid;\n}\n\nstatic void fio_listen_on_data(intptr_t uuid, fio_protocol_s *pr_) {\n  fio_listen_protocol_s *pr = (fio_listen_protocol_s *)pr_;\n  for (int i = 0; i < 4; ++i) {\n    intptr_t client = fio_accept(uuid);\n    if (client == -1)\n      return;\n    pr->on_open(client, pr->udata);\n  }\n}\n\nstatic void fio_listen_on_data_tls(intptr_t uuid, fio_protocol_s *pr_) {\n  fio_listen_protocol_s *pr = (fio_listen_protocol_s *)pr_;\n  for (int i = 0; i < 4; ++i) {\n    intptr_t client = fio_accept(uuid);\n    if (client == -1)\n      return;\n    fio_tls_accept(client, pr->tls, pr->udata);\n    pr->on_open(client, pr->udata);\n  }\n}\n\nstatic void fio_listen_on_data_tls_alpn(intptr_t uuid, fio_protocol_s *pr_) {\n  fio_listen_protocol_s *pr = (fio_listen_protocol_s *)pr_;\n  for (int i = 0; i < 4; ++i) {\n    intptr_t client = fio_accept(uuid);\n    if (client == -1)\n      return;\n    fio_tls_accept(client, pr->tls, pr->udata);\n  }\n}\n\n/* stub for editor - unused */\nvoid fio_listen____(void);\n/**\n * Schedule a network service on a listening socket.\n *\n * Returns the listening socket or -1 (on error).\n */\nintptr_t fio_listen FIO_IGNORE_MACRO(struct fio_listen_args args) {\n  // ...\n  if ((!args.on_open && (!args.tls || !fio_tls_alpn_count(args.tls))) ||\n      (!args.address && !args.port)) {\n    errno = EINVAL;\n    goto error;\n  }\n\n  size_t addr_len = 0;\n  size_t port_len = 0;\n  if (args.address)\n    addr_len = strlen(args.address);\n  if (args.port) {\n    port_len = strlen(args.port);\n    char *tmp = (char *)args.port;\n    if (!fio_atol(&tmp)) {\n      port_len = 0;\n      args.port = NULL;\n    }\n    if (*tmp) {\n      /* port format was invalid, should be only numerals */\n      errno = EINVAL;\n      goto error;\n    }\n  }\n  const intptr_t uuid = fio_socket(args.address, args.port, 1);\n  if (uuid == -1)\n    goto error;\n\n  fio_listen_protocol_s *pr = malloc(sizeof(*pr) + addr_len + port_len +\n                                     ((addr_len + port_len) ? 2 : 0));\n  FIO_ASSERT_ALLOC(pr);\n\n  if (args.tls)\n    fio_tls_dup(args.tls);\n\n  *pr = (fio_listen_protocol_s){\n      .pr =\n          {\n              .on_close = fio_listen_on_close,\n              .ping = mock_ping_eternal,\n              .on_data = (args.tls ? (fio_tls_alpn_count(args.tls)\n                                          ? fio_listen_on_data_tls_alpn\n                                          : fio_listen_on_data_tls)\n                                   : fio_listen_on_data),\n          },\n      .uuid = uuid,\n      .udata = args.udata,\n      .on_open = args.on_open,\n      .on_start = args.on_start,\n      .on_finish = args.on_finish,\n      .tls = args.tls,\n      .addr_len = addr_len,\n      .port_len = port_len,\n      .addr = (char *)(pr + 1),\n      .port = ((char *)(pr + 1) + addr_len + 1),\n  };\n\n  if (addr_len)\n    memcpy(pr->addr, args.address, addr_len + 1);\n  if (port_len)\n    memcpy(pr->port, args.port, port_len + 1);\n\n  if (fio_is_running()) {\n    fio_attach(pr->uuid, &pr->pr);\n  } else {\n    fio_state_callback_add(FIO_CALL_ON_START, fio_listen_on_startup, pr);\n    fio_state_callback_add(FIO_CALL_ON_SHUTDOWN, fio_listen_cleanup_task, pr);\n  }\n\n  if (args.port)\n    FIO_LOG_INFO(\"Listening on port %s\", args.port);\n  else\n    FIO_LOG_INFO(\"Listening on Unix Socket at %s\", args.address);\n\n  return uuid;\nerror:\n  if (args.on_finish) {\n    args.on_finish(-1, args.udata);\n  }\n  return -1;\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                   Connecting to remote servers as a client\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/* *****************************************************************************\nThe connection protocol (use the facil.io API to make a socket and attach it)\n***************************************************************************** */\n\ntypedef struct {\n  fio_protocol_s pr;\n  intptr_t uuid;\n  void *udata;\n  void *tls;\n  void (*on_connect)(intptr_t uuid, void *udata);\n  void (*on_fail)(intptr_t uuid, void *udata);\n} fio_connect_protocol_s;\n\nstatic void fio_connect_on_close(intptr_t uuid, fio_protocol_s *pr_) {\n  fio_connect_protocol_s *pr = (fio_connect_protocol_s *)pr_;\n  if (pr->on_fail)\n    pr->on_fail(uuid, pr->udata);\n  if (pr->tls)\n    fio_tls_destroy(pr->tls);\n  fio_free(pr);\n  (void)uuid;\n}\n\nstatic void fio_connect_on_ready(intptr_t uuid, fio_protocol_s *pr_) {\n  fio_connect_protocol_s *pr = (fio_connect_protocol_s *)pr_;\n  if (pr->pr.on_ready == mock_on_ev)\n    return; /* Don't call on_connect more than once */\n  pr->pr.on_ready = mock_on_ev;\n  pr->on_fail = NULL;\n  pr->on_connect(uuid, pr->udata);\n  fio_poll_add(fio_uuid2fd(uuid));\n  (void)uuid;\n}\n\nstatic void fio_connect_on_ready_tls(intptr_t uuid, fio_protocol_s *pr_) {\n  fio_connect_protocol_s *pr = (fio_connect_protocol_s *)pr_;\n  if (pr->pr.on_ready == mock_on_ev)\n    return; /* Don't call on_connect more than once */\n  pr->pr.on_ready = mock_on_ev;\n  pr->on_fail = NULL;\n  fio_tls_connect(uuid, pr->tls, pr->udata);\n  pr->on_connect(uuid, pr->udata);\n  fio_poll_add(fio_uuid2fd(uuid));\n  (void)uuid;\n}\n\nstatic void fio_connect_on_ready_tls_alpn(intptr_t uuid, fio_protocol_s *pr_) {\n  fio_connect_protocol_s *pr = (fio_connect_protocol_s *)pr_;\n  if (pr->pr.on_ready == mock_on_ev)\n    return; /* Don't call on_connect more than once */\n  pr->pr.on_ready = mock_on_ev;\n  pr->on_fail = NULL;\n  fio_tls_connect(uuid, pr->tls, pr->udata);\n  fio_poll_add(fio_uuid2fd(uuid));\n  (void)uuid;\n}\n\n/* stub for sublime text function navigation */\nintptr_t fio_connect___(struct fio_connect_args args);\n\nintptr_t fio_connect FIO_IGNORE_MACRO(struct fio_connect_args args) {\n  if ((!args.on_connect && (!args.tls || !fio_tls_alpn_count(args.tls))) ||\n      (!args.address && !args.port)) {\n    errno = EINVAL;\n    goto error;\n  }\n  const intptr_t uuid = fio_socket(args.address, args.port, 0);\n  if (uuid == -1)\n    goto error;\n  fio_timeout_set(uuid, args.timeout);\n\n  fio_connect_protocol_s *pr = fio_malloc(sizeof(*pr));\n  FIO_ASSERT_ALLOC(pr);\n\n  if (args.tls)\n    fio_tls_dup(args.tls);\n\n  *pr = (fio_connect_protocol_s){\n      .pr =\n          {\n              .on_ready = (args.tls ? (fio_tls_alpn_count(args.tls)\n                                           ? fio_connect_on_ready_tls_alpn\n                                           : fio_connect_on_ready_tls)\n                                    : fio_connect_on_ready),\n              .on_close = fio_connect_on_close,\n          },\n      .uuid = uuid,\n      .tls = args.tls,\n      .udata = args.udata,\n      .on_connect = args.on_connect,\n      .on_fail = args.on_fail,\n  };\n  fio_attach(uuid, &pr->pr);\n  return uuid;\nerror:\n  if (args.on_fail)\n    args.on_fail(-1, args.udata);\n  return -1;\n}\n\n/* *****************************************************************************\nURL address parsing\n***************************************************************************** */\n\n/**\n * Parses the URI returning it's components and their lengths (no decoding\n * performed, doesn't accept decoded URIs).\n *\n * The returned string are NOT NUL terminated, they are merely locations within\n * the original string.\n *\n * This function expects any of the following formats:\n *\n * * `/complete_path?query#target`\n *\n *   i.e.: /index.html?page=1#list\n *\n * * `host:port/complete_path?query#target`\n *\n *   i.e.:\n *      example.com/index.html\n *      example.com:8080/index.html\n *\n * * `schema://user:password@host:port/path?query#target`\n *\n *   i.e.: http://example.com/index.html?page=1#list\n *\n * Invalid formats might produce unexpected results. No error testing performed.\n */\nfio_url_s fio_url_parse(const char *url, size_t length) {\n  /*\n  Intention:\n  [schema://][user[:]][password[@]][host.com[:/]][:port/][/path][?quary][#target]\n  */\n  const char *end = url + length;\n  const char *pos = url;\n  fio_url_s r = {.scheme = {.data = (char *)url}};\n  if (length == 0) {\n    goto finish;\n  }\n\n  if (pos[0] == '/') {\n    /* start at path */\n    goto start_path;\n  }\n\n  while (pos < end && pos[0] != ':' && pos[0] != '/' && pos[0] != '@' &&\n         pos[0] != '#' && pos[0] != '?')\n    ++pos;\n\n  if (pos == end) {\n    /* was only host (path starts with '/') */\n    r.host = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n    goto finish;\n  }\n  switch (pos[0]) {\n  case '@':\n    /* username@[host] */\n    r.user = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n    ++pos;\n    goto start_host;\n  case '/':\n    /* host[/path] */\n    r.host = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n    goto start_path;\n  case '?':\n    /* host?[query] */\n    r.host = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n    ++pos;\n    goto start_query;\n  case '#':\n    /* host#[target] */\n    r.host = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n    ++pos;\n    goto start_target;\n  case ':':\n    if (pos + 2 <= end && pos[1] == '/' && pos[2] == '/') {\n      /* scheme:// */\n      r.scheme.len = pos - url;\n      pos += 3;\n    } else {\n      /* username:[password] OR */\n      /* host:[port] */\n      r.user = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n      ++pos;\n      goto start_password;\n    }\n    break;\n  }\n\n  // start_username:\n  url = pos;\n  while (pos < end && pos[0] != ':' && pos[0] != '/' && pos[0] != '@'\n         /* && pos[0] != '#' && pos[0] != '?' */)\n    ++pos;\n\n  if (pos >= end) { /* scheme://host */\n    r.host = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n    goto finish;\n  }\n\n  switch (pos[0]) {\n  case '/':\n    /* scheme://host[/path] */\n    r.host = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n    goto start_path;\n  case '@':\n    /* scheme://username@[host]... */\n    r.user = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n    ++pos;\n    goto start_host;\n  case ':':\n    /* scheme://username:[password]@[host]... OR */\n    /* scheme://host:[port][/...] */\n    r.user = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n    ++pos;\n    break;\n  }\n\nstart_password:\n  url = pos;\n  while (pos < end && pos[0] != '/' && pos[0] != '@')\n    ++pos;\n\n  if (pos >= end) {\n    /* was host:port */\n    r.port = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n    r.host = r.user;\n    r.user.len = 0;\n    goto finish;\n    ;\n  }\n\n  switch (pos[0]) {\n  case '/':\n    r.port = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n    r.host = r.user;\n    r.user.len = 0;\n    goto start_path;\n  case '@':\n    r.password = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n    ++pos;\n    break;\n  }\n\nstart_host:\n  url = pos;\n  while (pos < end && pos[0] != '/' && pos[0] != ':' && pos[0] != '#' &&\n         pos[0] != '?')\n    ++pos;\n\n  r.host = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n  if (pos >= end) {\n    goto finish;\n  }\n  switch (pos[0]) {\n  case '/':\n    /* scheme://[...@]host[/path] */\n    goto start_path;\n  case '?':\n    /* scheme://[...@]host?[query] (bad)*/\n    ++pos;\n    goto start_query;\n  case '#':\n    /* scheme://[...@]host#[target] (bad)*/\n    ++pos;\n    goto start_target;\n    // case ':':\n    /* scheme://[...@]host:[port] */\n  }\n  ++pos;\n\n  // start_port:\n  url = pos;\n  while (pos < end && pos[0] != '/' && pos[0] != '#' && pos[0] != '?')\n    ++pos;\n\n  r.port = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n\n  if (pos >= end) {\n    /* scheme://[...@]host:port */\n    goto finish;\n  }\n  switch (pos[0]) {\n  case '?':\n    /* scheme://[...@]host:port?[query] (bad)*/\n    ++pos;\n    goto start_query;\n  case '#':\n    /* scheme://[...@]host:port#[target] (bad)*/\n    ++pos;\n    goto start_target;\n    // case '/':\n    /* scheme://[...@]host:port[/path] */\n  }\n\nstart_path:\n  url = pos;\n  while (pos < end && pos[0] != '#' && pos[0] != '?')\n    ++pos;\n\n  r.path = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n\n  if (pos >= end) {\n    goto finish;\n  }\n  ++pos;\n  if (pos[-1] == '#')\n    goto start_target;\n\nstart_query:\n  url = pos;\n  while (pos < end && pos[0] != '#')\n    ++pos;\n\n  r.query = (fio_str_info_s){.data = (char *)url, .len = pos - url};\n  ++pos;\n\n  if (pos >= end)\n    goto finish;\n\nstart_target:\n  r.target = (fio_str_info_s){.data = (char *)pos, .len = end - pos};\n\nfinish:\n\n  /* set any empty values to NULL */\n  if (!r.scheme.len)\n    r.scheme.data = NULL;\n  if (!r.user.len)\n    r.user.data = NULL;\n  if (!r.password.len)\n    r.password.data = NULL;\n  if (!r.host.len)\n    r.host.data = NULL;\n  if (!r.port.len)\n    r.port.data = NULL;\n  if (!r.path.len)\n    r.path.data = NULL;\n  if (!r.query.len)\n    r.query.data = NULL;\n  if (!r.target.len)\n    r.target.data = NULL;\n\n  return r;\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                       Cluster Messaging Implementation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n#if FIO_PUBSUB_SUPPORT\n\n/* *****************************************************************************\n * Data Structures - Channel / Subscriptions data\n **************************************************************************** */\n\ntypedef enum fio_cluster_message_type_e {\n  FIO_CLUSTER_MSG_FORWARD,\n  FIO_CLUSTER_MSG_JSON,\n  FIO_CLUSTER_MSG_ROOT,\n  FIO_CLUSTER_MSG_ROOT_JSON,\n  FIO_CLUSTER_MSG_PUBSUB_SUB,\n  FIO_CLUSTER_MSG_PUBSUB_UNSUB,\n  FIO_CLUSTER_MSG_PATTERN_SUB,\n  FIO_CLUSTER_MSG_PATTERN_UNSUB,\n  FIO_CLUSTER_MSG_SHUTDOWN,\n  FIO_CLUSTER_MSG_ERROR,\n  FIO_CLUSTER_MSG_PING,\n} fio_cluster_message_type_e;\n\ntypedef struct fio_collection_s fio_collection_s;\n\n#ifndef __clang__ /* clang might misbehave by assumming non-alignment */\n#pragma pack(1)   /* https://gitter.im/halide/Halide/archives/2018/07/24 */\n#endif\ntypedef struct {\n  size_t name_len;\n  char *name;\n  volatile size_t ref;\n  fio_ls_embd_s subscriptions;\n  fio_collection_s *parent;\n  fio_match_fn match;\n  fio_lock_i lock;\n} channel_s;\n#ifndef __clang__\n#pragma pack()\n#endif\n\nstruct subscription_s {\n  fio_ls_embd_s node;\n  channel_s *parent;\n  void (*on_message)(fio_msg_s *msg);\n  void (*on_unsubscribe)(void *udata1, void *udata2);\n  void *udata1;\n  void *udata2;\n  /** reference counter. */\n  volatile uintptr_t ref;\n  /** prevents the callback from running concurrently for multiple messages. */\n  fio_lock_i lock;\n  fio_lock_i unsubscribed;\n};\n\n/* Use `malloc` / `free`, because channles might have a long life. */\n\n/** Used internally by the Set object to create a new channel. */\nstatic channel_s *fio_channel_copy(channel_s *src) {\n  channel_s *dest = malloc(sizeof(*dest) + src->name_len + 1);\n  FIO_ASSERT_ALLOC(dest);\n  dest->name_len = src->name_len;\n  dest->match = src->match;\n  dest->parent = src->parent;\n  dest->name = (char *)(dest + 1);\n  if (src->name_len)\n    memcpy(dest->name, src->name, src->name_len);\n  dest->name[src->name_len] = 0;\n  dest->subscriptions = (fio_ls_embd_s)FIO_LS_INIT(dest->subscriptions);\n  dest->ref = 1;\n  dest->lock = FIO_LOCK_INIT;\n  return dest;\n}\n/** Frees a channel (reference counting). */\nstatic void fio_channel_free(channel_s *ch) {\n  if (!ch)\n    return;\n  if (fio_atomic_sub(&ch->ref, 1))\n    return;\n  free(ch);\n}\n/** Increases a channel's reference count. */\nstatic void fio_channel_dup(channel_s *ch) {\n  if (!ch)\n    return;\n  fio_atomic_add(&ch->ref, 1);\n}\n/** Tests if two channels are equal. */\nstatic int fio_channel_cmp(channel_s *ch1, channel_s *ch2) {\n  return ch1->name_len == ch2->name_len && ch1->match == ch2->match &&\n         !memcmp(ch1->name, ch2->name, ch1->name_len);\n}\n/* pub/sub channels and core data sets have a long life, so avoid fio_malloc */\n#define FIO_FORCE_MALLOC_TMP 1\n#define FIO_SET_NAME fio_ch_set\n#define FIO_SET_OBJ_TYPE channel_s *\n#define FIO_SET_OBJ_COMPARE(o1, o2) fio_channel_cmp((o1), (o2))\n#define FIO_SET_OBJ_DESTROY(obj) fio_channel_free((obj))\n#define FIO_SET_OBJ_COPY(dest, src) ((dest) = fio_channel_copy((src)))\n#include <fio.h>\n\n#define FIO_FORCE_MALLOC_TMP 1\n#define FIO_ARY_NAME fio_meta_ary\n#define FIO_ARY_TYPE fio_msg_metadata_fn\n#include <fio.h>\n\n#define FIO_FORCE_MALLOC_TMP 1\n#define FIO_SET_NAME fio_engine_set\n#define FIO_SET_OBJ_TYPE fio_pubsub_engine_s *\n#define FIO_SET_OBJ_COMPARE(k1, k2) ((k1) == (k2))\n#include <fio.h>\n\nstruct fio_collection_s {\n  fio_ch_set_s channels;\n  fio_lock_i lock;\n};\n\n#define COLLECTION_INIT                                                        \\\n  { .channels = FIO_SET_INIT, .lock = FIO_LOCK_INIT }\n\nstatic struct {\n  fio_collection_s filters;\n  fio_collection_s pubsub;\n  fio_collection_s patterns;\n  struct {\n    fio_engine_set_s set;\n    fio_lock_i lock;\n  } engines;\n  struct {\n    fio_meta_ary_s ary;\n    fio_lock_i lock;\n  } meta;\n} fio_postoffice = {\n    .filters = COLLECTION_INIT,\n    .pubsub = COLLECTION_INIT,\n    .patterns = COLLECTION_INIT,\n    .engines.lock = FIO_LOCK_INIT,\n    .meta.lock = FIO_LOCK_INIT,\n};\n\n/** used to contain the message before it's passed to the handler */\ntypedef struct {\n  fio_msg_s msg;\n  size_t marker;\n  size_t meta_len;\n  fio_msg_metadata_s *meta;\n} fio_msg_client_s;\n\n/** used to contain the message internally while publishing */\ntypedef struct {\n  fio_str_info_s channel;\n  fio_str_info_s data;\n  uintptr_t ref; /* internal reference counter */\n  int32_t filter;\n  int8_t is_json;\n  size_t meta_len;\n  fio_msg_metadata_s meta[];\n} fio_msg_internal_s;\n\n/** The default engine (settable). */\nfio_pubsub_engine_s *FIO_PUBSUB_DEFAULT = FIO_PUBSUB_CLUSTER;\n\n/* *****************************************************************************\nInternal message object creation\n***************************************************************************** */\n\n/** returns a temporary fio_meta_ary_s with a copy of the metadata array */\nstatic fio_meta_ary_s fio_postoffice_meta_copy_new(void) {\n  fio_meta_ary_s t = FIO_ARY_INIT;\n  if (!fio_meta_ary_count(&fio_postoffice.meta.ary)) {\n    return t;\n  }\n  fio_lock(&fio_postoffice.meta.lock);\n  fio_meta_ary_concat(&t, &fio_postoffice.meta.ary);\n  fio_unlock(&fio_postoffice.meta.lock);\n  return t;\n}\n\n/** frees a temporary copy created by postoffice_meta_copy_new */\nstatic inline void fio_postoffice_meta_copy_free(fio_meta_ary_s *cpy) {\n  fio_meta_ary_free(cpy);\n}\n\nstatic void fio_postoffice_meta_update(fio_msg_internal_s *m) {\n  if (m->filter || !m->meta_len)\n    return;\n  fio_meta_ary_s t = fio_postoffice_meta_copy_new();\n  if (t.end > m->meta_len)\n    t.end = m->meta_len;\n  m->meta_len = t.end;\n  while (t.end) {\n    --t.end;\n    m->meta[t.end] = t.arry[t.end](m->channel, m->data, m->is_json);\n  }\n  fio_postoffice_meta_copy_free(&t);\n}\n\nstatic fio_msg_internal_s *\nfio_msg_internal_create(int32_t filter, uint32_t type, fio_str_info_s ch,\n                        fio_str_info_s data, int8_t is_json, int8_t cpy) {\n  fio_meta_ary_s t = FIO_ARY_INIT;\n  if (!filter)\n    t = fio_postoffice_meta_copy_new();\n  fio_msg_internal_s *m = fio_malloc(sizeof(*m) + (sizeof(*m->meta) * t.end) +\n                                     (ch.len) + (data.len) + 16 + 2);\n  FIO_ASSERT_ALLOC(m);\n  *m = (fio_msg_internal_s){\n      .filter = filter,\n      .channel = (fio_str_info_s){.data = (char *)(m->meta + t.end) + 16,\n                                  .len = ch.len},\n      .data = (fio_str_info_s){.data = ((char *)(m->meta + t.end) + ch.len +\n                                        16 + 1),\n                               .len = data.len},\n      .is_json = is_json,\n      .ref = 1,\n      .meta_len = t.end,\n  };\n  fio_u2str32((uint8_t *)(m + 1) + (sizeof(*m->meta) * t.end), ch.len);\n  fio_u2str32((uint8_t *)(m + 1) + (sizeof(*m->meta) * t.end) + 4, data.len);\n  fio_u2str32((uint8_t *)(m + 1) + (sizeof(*m->meta) * t.end) + 8, type);\n  fio_u2str32((uint8_t *)(m + 1) + (sizeof(*m->meta) * t.end) + 12,\n              (uint32_t)filter);\n  // m->channel.data[ch.len] = 0; /* redundant, fio_malloc is all zero */\n  // m->data.data[data.len] = 0; /* redundant, fio_malloc is all zero */\n  if (cpy) {\n    memcpy(m->channel.data, ch.data, ch.len);\n    memcpy(m->data.data, data.data, data.len);\n    while (t.end) {\n      --t.end;\n      m->meta[t.end] = t.arry[t.end](m->channel, m->data, is_json);\n    }\n  }\n  fio_postoffice_meta_copy_free(&t);\n  return m;\n}\n\n/** frees the internal message data */\nstatic inline void fio_msg_internal_finalize(fio_msg_internal_s *m) {\n  if (!m->channel.len)\n    m->channel.data = NULL;\n  if (!m->data.len)\n    m->data.data = NULL;\n}\n\n/** frees the internal message data */\nstatic inline void fio_msg_internal_free(fio_msg_internal_s *m) {\n  if (fio_atomic_sub(&m->ref, 1))\n    return;\n  while (m->meta_len) {\n    --m->meta_len;\n    if (m->meta[m->meta_len].on_finish) {\n      fio_msg_s tmp_msg = {\n          .channel = m->channel,\n          .msg = m->data,\n      };\n      m->meta[m->meta_len].on_finish(&tmp_msg, m->meta[m->meta_len].metadata);\n    }\n  }\n  fio_free(m);\n}\n\nstatic void fio_msg_internal_free2(void *m) { fio_msg_internal_free(m); }\n\n/* add reference count to fio_msg_internal_s */\nstatic inline fio_msg_internal_s *fio_msg_internal_dup(fio_msg_internal_s *m) {\n  fio_atomic_add(&m->ref, 1);\n  return m;\n}\n\n/** internal helper */\n\nstatic inline ssize_t fio_msg_internal_send_dup(intptr_t uuid,\n                                                fio_msg_internal_s *m) {\n  return fio_write2(uuid, .data.buffer = fio_msg_internal_dup(m),\n                    .offset = (sizeof(*m) + (m->meta_len * sizeof(*m->meta))),\n                    .length = 16 + m->data.len + m->channel.len + 2,\n                    .after.dealloc = fio_msg_internal_free2);\n}\n\n/**\n * A mock pub/sub callback for external subscriptions.\n */\nstatic void fio_mock_on_message(fio_msg_s *msg) { (void)msg; }\n\n/* *****************************************************************************\nChannel Subscription Management\n***************************************************************************** */\n\nstatic void fio_pubsub_on_channel_create(channel_s *ch);\nstatic void fio_pubsub_on_channel_destroy(channel_s *ch);\n\n/* some comon tasks extracted */\nstatic inline channel_s *fio_filter_dup_lock_internal(channel_s *ch,\n                                                      uint64_t hashed,\n                                                      fio_collection_s *c) {\n  fio_lock(&c->lock);\n  ch = fio_ch_set_insert(&c->channels, hashed, ch);\n  fio_channel_dup(ch);\n  fio_lock(&ch->lock);\n  fio_unlock(&c->lock);\n  return ch;\n}\n\n/** Creates / finds a filter channel, adds a reference count and locks it. */\nstatic channel_s *fio_filter_dup_lock(uint32_t filter) {\n  channel_s ch = (channel_s){\n      .name = (char *)&filter,\n      .name_len = (sizeof(filter)),\n      .parent = &fio_postoffice.filters,\n      .ref = 8, /* avoid freeing stack memory */\n  };\n  return fio_filter_dup_lock_internal(&ch, filter, &fio_postoffice.filters);\n}\n\n/** Creates / finds a pubsub channel, adds a reference count and locks it. */\nstatic channel_s *fio_channel_dup_lock(fio_str_info_s name) {\n  channel_s ch = (channel_s){\n      .name = name.data,\n      .name_len = name.len,\n      .parent = &fio_postoffice.pubsub,\n      .ref = 8, /* avoid freeing stack memory */\n  };\n  uint64_t hashed_name = FIO_HASH_FN(\n      name.data, name.len, &fio_postoffice.pubsub, &fio_postoffice.pubsub);\n  channel_s *ch_p =\n      fio_filter_dup_lock_internal(&ch, hashed_name, &fio_postoffice.pubsub);\n  if (fio_ls_embd_is_empty(&ch_p->subscriptions)) {\n    fio_pubsub_on_channel_create(ch_p);\n  }\n  return ch_p;\n}\n\n/** Creates / finds a pattern channel, adds a reference count and locks it. */\nstatic channel_s *fio_channel_match_dup_lock(fio_str_info_s name,\n                                             fio_match_fn match) {\n  channel_s ch = (channel_s){\n      .name = name.data,\n      .name_len = name.len,\n      .parent = &fio_postoffice.patterns,\n      .match = match,\n      .ref = 8, /* avoid freeing stack memory */\n  };\n  uint64_t hashed_name = FIO_HASH_FN(\n      name.data, name.len, &fio_postoffice.pubsub, &fio_postoffice.pubsub);\n  channel_s *ch_p =\n      fio_filter_dup_lock_internal(&ch, hashed_name, &fio_postoffice.patterns);\n  if (fio_ls_embd_is_empty(&ch_p->subscriptions)) {\n    fio_pubsub_on_channel_create(ch_p);\n  }\n  return ch_p;\n}\n\n/* to be used for reference counting (subtructing) */\nstatic inline void fio_subscription_free(subscription_s *s) {\n  if (fio_atomic_sub(&s->ref, 1)) {\n    return;\n  }\n  if (s->on_unsubscribe) {\n    s->on_unsubscribe(s->udata1, s->udata2);\n  }\n  fio_channel_free(s->parent);\n  fio_free(s);\n}\n\n/** SublimeText 3 marker */\nsubscription_s *fio_subscribe___(subscribe_args_s args);\n\n/** Subscribes to a filter, pub/sub channle or patten */\nsubscription_s *fio_subscribe FIO_IGNORE_MACRO(subscribe_args_s args) {\n  if (!args.on_message)\n    goto error;\n  channel_s *ch;\n  subscription_s *s = fio_malloc(sizeof(*s));\n  FIO_ASSERT_ALLOC(s);\n  *s = (subscription_s){\n      .on_message = args.on_message,\n      .on_unsubscribe = args.on_unsubscribe,\n      .udata1 = args.udata1,\n      .udata2 = args.udata2,\n      .ref = 1,\n      .lock = FIO_LOCK_INIT,\n  };\n  if (args.filter) {\n    ch = fio_filter_dup_lock(args.filter);\n  } else if (args.match) {\n    ch = fio_channel_match_dup_lock(args.channel, args.match);\n  } else {\n    ch = fio_channel_dup_lock(args.channel);\n  }\n  s->parent = ch;\n  fio_ls_embd_push(&ch->subscriptions, &s->node);\n  fio_unlock((&ch->lock));\n  return s;\nerror:\n  if (args.on_unsubscribe)\n    args.on_unsubscribe(args.udata1, args.udata2);\n  return NULL;\n}\n\n/** Unsubscribes from a filter, pub/sub channle or patten */\nvoid fio_unsubscribe(subscription_s *s) {\n  if (!s)\n    return;\n  if (fio_trylock(&s->unsubscribed))\n    goto finish;\n  fio_lock(&s->lock);\n  channel_s *ch = s->parent;\n  uint8_t removed = 0;\n  fio_lock(&ch->lock);\n  fio_ls_embd_remove(&s->node);\n  /* check if channel is done for */\n  if (fio_ls_embd_is_empty(&ch->subscriptions)) {\n    fio_collection_s *c = ch->parent;\n    uint64_t hashed = FIO_HASH_FN(\n        ch->name, ch->name_len, &fio_postoffice.pubsub, &fio_postoffice.pubsub);\n    /* lock collection */\n    fio_lock(&c->lock);\n    /* test again within lock */\n    if (fio_ls_embd_is_empty(&ch->subscriptions)) {\n      fio_ch_set_remove(&c->channels, hashed, ch, NULL);\n      removed = (c != &fio_postoffice.filters);\n    }\n    fio_unlock(&c->lock);\n  }\n  fio_unlock(&ch->lock);\n  if (removed) {\n    fio_pubsub_on_channel_destroy(ch);\n  }\n\n  /* promise the subscription will be inactive */\n  s->on_message = NULL;\n  fio_unlock(&s->lock);\nfinish:\n  fio_subscription_free(s);\n}\n\n/**\n * This helper returns a temporary String with the subscription's channel (or a\n * string representing the filter).\n *\n * To keep the string beyond the lifetime of the subscription, copy the string.\n */\nfio_str_info_s fio_subscription_channel(subscription_s *subscription) {\n  return (fio_str_info_s){.data = subscription->parent->name,\n                          .len = subscription->parent->name_len};\n}\n\n/* *****************************************************************************\nEngine handling and Management\n***************************************************************************** */\n\n/* implemented later, informs root process about pub/sub subscriptions */\nstatic inline void fio_cluster_inform_root_about_channel(channel_s *ch,\n                                                         int add);\n\n/* runs in lock(!) let'm all know */\nstatic void fio_pubsub_on_channel_create(channel_s *ch) {\n  fio_lock(&fio_postoffice.engines.lock);\n  FIO_SET_FOR_LOOP(&fio_postoffice.engines.set, pos) {\n    if (!pos->hash)\n      continue;\n    pos->obj->subscribe(pos->obj,\n                        (fio_str_info_s){.data = ch->name, .len = ch->name_len},\n                        ch->match);\n  }\n  fio_unlock(&fio_postoffice.engines.lock);\n  fio_cluster_inform_root_about_channel(ch, 1);\n}\n\n/* runs in lock(!) let'm all know */\nstatic void fio_pubsub_on_channel_destroy(channel_s *ch) {\n  fio_lock(&fio_postoffice.engines.lock);\n  FIO_SET_FOR_LOOP(&fio_postoffice.engines.set, pos) {\n    if (!pos->hash)\n      continue;\n    pos->obj->unsubscribe(\n        pos->obj, (fio_str_info_s){.data = ch->name, .len = ch->name_len},\n        ch->match);\n  }\n  fio_unlock(&fio_postoffice.engines.lock);\n  fio_cluster_inform_root_about_channel(ch, 0);\n}\n\n/**\n * Attaches an engine, so it's callback can be called by facil.io.\n *\n * The `subscribe` callback will be called for every existing channel.\n *\n * NOTE: the root (master) process will call `subscribe` for any channel in any\n * process, while all the other processes will call `subscribe` only for their\n * own channels. This allows engines to use the root (master) process as an\n * exclusive subscription process.\n */\nvoid fio_pubsub_attach(fio_pubsub_engine_s *engine) {\n  fio_lock(&fio_postoffice.engines.lock);\n  fio_engine_set_insert(&fio_postoffice.engines.set, (uintptr_t)engine, engine);\n  fio_unlock(&fio_postoffice.engines.lock);\n  fio_pubsub_reattach(engine);\n}\n\n/** Detaches an engine, so it could be safely destroyed. */\nvoid fio_pubsub_detach(fio_pubsub_engine_s *engine) {\n  fio_lock(&fio_postoffice.engines.lock);\n  fio_engine_set_remove(&fio_postoffice.engines.set, (uintptr_t)engine, engine,\n                        NULL);\n  fio_unlock(&fio_postoffice.engines.lock);\n}\n\n/** Returns true (1) if the engine is attached to the system. */\nint fio_pubsub_is_attached(fio_pubsub_engine_s *engine) {\n  fio_pubsub_engine_s *addr;\n  fio_lock(&fio_postoffice.engines.lock);\n  addr = fio_engine_set_find(&fio_postoffice.engines.set, (uintptr_t)engine,\n                             engine);\n  fio_unlock(&fio_postoffice.engines.lock);\n  return addr != NULL;\n}\n\n/**\n * Engines can ask facil.io to call the `subscribe` callback for all active\n * channels.\n *\n * This allows engines that lost their connection to their Pub/Sub service to\n * resubscribe all the currently active channels with the new connection.\n *\n * CAUTION: This is an evented task... try not to free the engine's memory while\n * resubscriptions are under way...\n *\n * NOTE: the root (master) process will call `subscribe` for any channel in any\n * process, while all the other processes will call `subscribe` only for their\n * own channels. This allows engines to use the root (master) process as an\n * exclusive subscription process.\n */\nvoid fio_pubsub_reattach(fio_pubsub_engine_s *eng) {\n  fio_lock(&fio_postoffice.pubsub.lock);\n  FIO_SET_FOR_LOOP(&fio_postoffice.pubsub.channels, pos) {\n    if (!pos->hash)\n      continue;\n    eng->subscribe(\n        eng,\n        (fio_str_info_s){.data = pos->obj->name, .len = pos->obj->name_len},\n        NULL);\n  }\n  fio_unlock(&fio_postoffice.pubsub.lock);\n  fio_lock(&fio_postoffice.patterns.lock);\n  FIO_SET_FOR_LOOP(&fio_postoffice.patterns.channels, pos) {\n    if (!pos->hash)\n      continue;\n    eng->subscribe(\n        eng,\n        (fio_str_info_s){.data = pos->obj->name, .len = pos->obj->name_len},\n        pos->obj->match);\n  }\n  fio_unlock(&fio_postoffice.patterns.lock);\n}\n\n/* *****************************************************************************\n * Message Metadata handling\n **************************************************************************** */\n\nvoid fio_message_metadata_callback_set(fio_msg_metadata_fn callback,\n                                       int enable) {\n  if (!callback)\n    return;\n  fio_lock(&fio_postoffice.meta.lock);\n  fio_meta_ary_remove2(&fio_postoffice.meta.ary, callback, NULL);\n  if (enable)\n    fio_meta_ary_push(&fio_postoffice.meta.ary, callback);\n  fio_unlock(&fio_postoffice.meta.lock);\n}\n\n/** Finds the message's metadata by it's type ID. */\nvoid *fio_message_metadata(fio_msg_s *msg, intptr_t type_id) {\n  fio_msg_metadata_s *meta = ((fio_msg_client_s *)msg)->meta;\n  size_t len = ((fio_msg_client_s *)msg)->meta_len;\n  while (len) {\n    --len;\n    if (meta[len].type_id == type_id)\n      return meta[len].metadata;\n  }\n  return NULL;\n}\n\n/* *****************************************************************************\n * Publishing to the subsriptions\n **************************************************************************** */\n\n/* common internal tasks */\nstatic channel_s *fio_channel_find_dup_internal(channel_s *ch_tmp,\n                                                uint64_t hashed,\n                                                fio_collection_s *c) {\n  fio_lock(&c->lock);\n  channel_s *ch = fio_ch_set_find(&c->channels, hashed, ch_tmp);\n  if (!ch) {\n    fio_unlock(&c->lock);\n    return NULL;\n  }\n  fio_channel_dup(ch);\n  fio_unlock(&c->lock);\n  return ch;\n}\n\n/** Finds a filter channel, increasing it's reference count if it exists. */\nstatic channel_s *fio_filter_find_dup(uint32_t filter) {\n  channel_s tmp = {.name = (char *)(&filter), .name_len = sizeof(filter)};\n  channel_s *ch =\n      fio_channel_find_dup_internal(&tmp, filter, &fio_postoffice.filters);\n  return ch;\n}\n\n/** Finds a pubsub channel, increasing it's reference count if it exists. */\nstatic channel_s *fio_channel_find_dup(fio_str_info_s name) {\n  channel_s tmp = {.name = name.data, .name_len = name.len};\n  uint64_t hashed_name = FIO_HASH_FN(\n      name.data, name.len, &fio_postoffice.pubsub, &fio_postoffice.pubsub);\n  channel_s *ch =\n      fio_channel_find_dup_internal(&tmp, hashed_name, &fio_postoffice.pubsub);\n  return ch;\n}\n\n/* defers the callback (mark only) */\nvoid fio_message_defer(fio_msg_s *msg_) {\n  fio_msg_client_s *cl = (fio_msg_client_s *)msg_;\n  cl->marker = 1;\n}\n\n/* performs the actual callback */\nstatic void fio_perform_subscription_callback(void *s_, void *msg_) {\n  subscription_s *s = s_;\n  if (fio_trylock(&s->lock)) {\n    fio_defer_push_task(fio_perform_subscription_callback, s_, msg_);\n    return;\n  }\n  fio_msg_internal_s *msg = (fio_msg_internal_s *)msg_;\n  fio_msg_client_s m = {\n      .msg =\n          {\n              .channel = msg->channel,\n              .msg = msg->data,\n              .filter = msg->filter,\n              .udata1 = s->udata1,\n              .udata2 = s->udata2,\n          },\n      .meta_len = msg->meta_len,\n      .meta = msg->meta,\n      .marker = 0,\n  };\n  if (s->on_message) {\n    /* the on_message callback is removed when a subscription is canceled. */\n    s->on_message(&m.msg);\n  }\n  fio_unlock(&s->lock);\n  if (m.marker) {\n    fio_defer_push_task(fio_perform_subscription_callback, s_, msg_);\n    return;\n  }\n  fio_msg_internal_free(msg);\n  fio_subscription_free(s);\n}\n\n/** UNSAFE! publishes a message to a channel, managing the reference counts */\nstatic void fio_publish2channel(channel_s *ch, fio_msg_internal_s *msg) {\n  FIO_LS_EMBD_FOR(&ch->subscriptions, pos) {\n    subscription_s *s = FIO_LS_EMBD_OBJ(subscription_s, node, pos);\n    if (!s || s->on_message == fio_mock_on_message) {\n      continue;\n    }\n    fio_atomic_add(&s->ref, 1);\n    fio_atomic_add(&msg->ref, 1);\n    fio_defer_push_task(fio_perform_subscription_callback, s, msg);\n  }\n  fio_msg_internal_free(msg);\n}\nstatic void fio_publish2channel_task(void *ch_, void *msg) {\n  channel_s *ch = ch_;\n  if (!ch_)\n    return;\n  if (!msg)\n    goto finish;\n  if (fio_trylock(&ch->lock)) {\n    fio_defer_push_urgent(fio_publish2channel_task, ch, msg);\n    return;\n  }\n  fio_publish2channel(ch, msg);\n  fio_unlock(&ch->lock);\nfinish:\n  fio_channel_free(ch);\n}\n\n/** Publishes the message to the current process and frees the strings. */\nstatic void fio_publish2process(fio_msg_internal_s *m) {\n  fio_msg_internal_finalize(m);\n  channel_s *ch;\n  if (m->filter) {\n    ch = fio_filter_find_dup(m->filter);\n    if (!ch) {\n      goto finish;\n    }\n  } else {\n    ch = fio_channel_find_dup(m->channel);\n  }\n  /* exact match */\n  if (ch) {\n    fio_defer_push_urgent(fio_publish2channel_task, ch,\n                          fio_msg_internal_dup(m));\n  }\n  if (m->filter == 0) {\n    /* pattern matching match */\n    fio_lock(&fio_postoffice.patterns.lock);\n    FIO_SET_FOR_LOOP(&fio_postoffice.patterns.channels, p) {\n      if (!p->hash) {\n        continue;\n      }\n\n      if (p->obj->match(\n              (fio_str_info_s){.data = p->obj->name, .len = p->obj->name_len},\n              m->channel)) {\n        fio_channel_dup(p->obj);\n        fio_defer_push_urgent(fio_publish2channel_task, p->obj,\n                              fio_msg_internal_dup(m));\n      }\n    }\n    fio_unlock(&fio_postoffice.patterns.lock);\n  }\nfinish:\n  fio_msg_internal_free(m);\n}\n\n/* *****************************************************************************\n * Data Structures - Core Structures\n **************************************************************************** */\n\n#define CLUSTER_READ_BUFFER 16384\n\n#define FIO_SET_NAME fio_sub_hash\n#define FIO_SET_OBJ_TYPE subscription_s *\n#define FIO_SET_KEY_TYPE fio_str_s\n#define FIO_SET_KEY_COPY(k1, k2)                                               \\\n  (k1) = FIO_STR_INIT;                                                         \\\n  fio_str_concat(&(k1), &(k2))\n#define FIO_SET_KEY_COMPARE(k1, k2) fio_str_iseq(&(k1), &(k2))\n#define FIO_SET_KEY_DESTROY(key) fio_str_free(&(key))\n#define FIO_SET_OBJ_DESTROY(obj) fio_unsubscribe(obj)\n#include <fio.h>\n\n#define FIO_CLUSTER_NAME_LIMIT 255\n\ntypedef struct cluster_pr_s {\n  fio_protocol_s protocol;\n  fio_msg_internal_s *msg;\n  void (*handler)(struct cluster_pr_s *pr);\n  void (*sender)(void *data, intptr_t avoid_uuid);\n  fio_sub_hash_s pubsub;\n  fio_sub_hash_s patterns;\n  intptr_t uuid;\n  uint32_t exp_channel;\n  uint32_t exp_msg;\n  uint32_t type;\n  int32_t filter;\n  uint32_t length;\n  fio_lock_i lock;\n  uint8_t buffer[CLUSTER_READ_BUFFER];\n} cluster_pr_s;\n\nstatic struct cluster_data_s {\n  intptr_t uuid;\n  fio_ls_s clients;\n  fio_lock_i lock;\n  char name[FIO_CLUSTER_NAME_LIMIT + 1];\n} cluster_data = {.clients = FIO_LS_INIT(cluster_data.clients),\n                  .lock = FIO_LOCK_INIT};\n\nstatic void fio_cluster_data_cleanup(int delete_file) {\n  if (delete_file && cluster_data.name[0]) {\n#if DEBUG\n    FIO_LOG_DEBUG(\"(%d) unlinking cluster's Unix socket.\", (int)getpid());\n#endif\n    unlink(cluster_data.name);\n  }\n  while (fio_ls_any(&cluster_data.clients)) {\n    intptr_t uuid = (intptr_t)fio_ls_pop(&cluster_data.clients);\n    if (uuid > 0) {\n      fio_close(uuid);\n    }\n  }\n  cluster_data.uuid = 0;\n  cluster_data.lock = FIO_LOCK_INIT;\n  cluster_data.clients = (fio_ls_s)FIO_LS_INIT(cluster_data.clients);\n}\n\nstatic void fio_cluster_cleanup(void *ignore) {\n  /* cleanup the cluster data */\n  fio_cluster_data_cleanup(fio_parent_pid() == getpid());\n  (void)ignore;\n}\n\nstatic void fio_cluster_init(void) {\n  fio_cluster_data_cleanup(0);\n  /* create a unique socket name */\n  char *tmp_folder = getenv(\"TMPDIR\");\n  uint32_t tmp_folder_len = 0;\n  if (!tmp_folder || ((tmp_folder_len = (uint32_t)strlen(tmp_folder)) >\n                      (FIO_CLUSTER_NAME_LIMIT - 28))) {\n#ifdef P_tmpdir\n    tmp_folder = (char *)P_tmpdir;\n    if (tmp_folder)\n      tmp_folder_len = (uint32_t)strlen(tmp_folder);\n#else\n    tmp_folder = \"/tmp/\";\n    tmp_folder_len = 5;\n#endif\n  }\n  if (tmp_folder_len >= (FIO_CLUSTER_NAME_LIMIT - 28)) {\n    tmp_folder_len = 0;\n  }\n  if (tmp_folder_len) {\n    memcpy(cluster_data.name, tmp_folder, tmp_folder_len);\n    if (cluster_data.name[tmp_folder_len - 1] != '/')\n      cluster_data.name[tmp_folder_len++] = '/';\n  }\n  memcpy(cluster_data.name + tmp_folder_len, \"facil-io-sock-\", 14);\n  tmp_folder_len += 14;\n  tmp_folder_len +=\n      snprintf(cluster_data.name + tmp_folder_len,\n               FIO_CLUSTER_NAME_LIMIT - tmp_folder_len, \"%d\", (int)getpid());\n  cluster_data.name[tmp_folder_len] = 0;\n\n  /* remove if existing */\n  unlink(cluster_data.name);\n  /* add cleanup callback */\n  fio_state_callback_add(FIO_CALL_AT_EXIT, fio_cluster_cleanup, NULL);\n}\n\n/* *****************************************************************************\n * Cluster Protocol callbacks\n **************************************************************************** */\n\nstatic inline void fio_cluster_protocol_free(void *pr) { fio_free(pr); }\n\nstatic uint8_t fio_cluster_on_shutdown(intptr_t uuid, fio_protocol_s *pr_) {\n  cluster_pr_s *p = (cluster_pr_s *)pr_;\n  p->sender(fio_msg_internal_create(0, FIO_CLUSTER_MSG_SHUTDOWN,\n                                    (fio_str_info_s){.len = 0},\n                                    (fio_str_info_s){.len = 0}, 0, 1),\n            -1);\n  return 255;\n  (void)pr_;\n  (void)uuid;\n}\n\nstatic void fio_cluster_on_data(intptr_t uuid, fio_protocol_s *pr_) {\n  cluster_pr_s *c = (cluster_pr_s *)pr_;\n  ssize_t i =\n      fio_read(uuid, c->buffer + c->length, CLUSTER_READ_BUFFER - c->length);\n  if (i <= 0)\n    return;\n  c->length += i;\n  i = 0;\n  do {\n    if (!c->exp_channel && !c->exp_msg) {\n      if (c->length - i < 16)\n        break;\n      c->exp_channel = fio_str2u32(c->buffer + i) + 1;\n      c->exp_msg = fio_str2u32(c->buffer + i + 4) + 1;\n      c->type = fio_str2u32(c->buffer + i + 8);\n      c->filter = (int32_t)fio_str2u32(c->buffer + i + 12);\n      if (c->exp_channel) {\n        if (c->exp_channel >= (1024 * 1024 * 16) + 1) {\n          FIO_LOG_FATAL(\"(%d) cluster message name too long (16Mb limit): %u\\n\",\n                        (int)getpid(), (unsigned int)c->exp_channel);\n          exit(1);\n          return;\n        }\n      }\n      if (c->exp_msg) {\n        if (c->exp_msg >= (1024 * 1024 * 64) + 1) {\n          FIO_LOG_FATAL(\"(%d) cluster message data too long (64Mb limit): %u\\n\",\n                        (int)getpid(), (unsigned int)c->exp_msg);\n          exit(1);\n          return;\n        }\n      }\n      c->msg = fio_msg_internal_create(\n          c->filter, c->type,\n          (fio_str_info_s){.data = (char *)(c->msg + 1),\n                           .len = c->exp_channel - 1},\n          (fio_str_info_s){.data = ((char *)(c->msg + 1) + c->exp_channel + 1),\n                           .len = c->exp_msg - 1},\n          (int8_t)(c->type == FIO_CLUSTER_MSG_JSON ||\n                   c->type == FIO_CLUSTER_MSG_ROOT_JSON),\n          0);\n      i += 16;\n    }\n    if (c->exp_channel) {\n      if (c->exp_channel + i > c->length) {\n        memcpy(c->msg->channel.data +\n                   ((c->msg->channel.len + 1) - c->exp_channel),\n               (char *)c->buffer + i, (size_t)(c->length - i));\n        c->exp_channel -= (c->length - i);\n        i = c->length;\n        break;\n      } else {\n        memcpy(c->msg->channel.data +\n                   ((c->msg->channel.len + 1) - c->exp_channel),\n               (char *)c->buffer + i, (size_t)(c->exp_channel));\n        i += c->exp_channel;\n        c->exp_channel = 0;\n      }\n    }\n    if (c->exp_msg) {\n      if (c->exp_msg + i > c->length) {\n        memcpy(c->msg->data.data + ((c->msg->data.len + 1) - c->exp_msg),\n               (char *)c->buffer + i, (size_t)(c->length - i));\n        c->exp_msg -= (c->length - i);\n        i = c->length;\n        break;\n      } else {\n        memcpy(c->msg->data.data + ((c->msg->data.len + 1) - c->exp_msg),\n               (char *)c->buffer + i, (size_t)(c->exp_msg));\n        i += c->exp_msg;\n        c->exp_msg = 0;\n      }\n    }\n    fio_postoffice_meta_update(c->msg);\n    c->handler(c);\n    fio_msg_internal_free(c->msg);\n    c->msg = NULL;\n  } while (c->length > i);\n  c->length -= i;\n  if (c->length && i) {\n    memmove(c->buffer, c->buffer + i, c->length);\n  }\n  (void)pr_;\n}\n\nstatic void fio_cluster_ping(intptr_t uuid, fio_protocol_s *pr_) {\n  fio_msg_internal_s *m = fio_msg_internal_create(\n      0, FIO_CLUSTER_MSG_PING, (fio_str_info_s){.len = 0},\n      (fio_str_info_s){.len = 0}, 0, 1);\n  fio_msg_internal_send_dup(uuid, m);\n  fio_msg_internal_free(m);\n  (void)pr_;\n}\n\nstatic void fio_cluster_on_close(intptr_t uuid, fio_protocol_s *pr_) {\n  cluster_pr_s *c = (cluster_pr_s *)pr_;\n  if (!fio_data->is_worker) {\n    /* a child was lost, respawning is handled elsewhere. */\n    fio_lock(&cluster_data.lock);\n    FIO_LS_FOR(&cluster_data.clients, pos) {\n      if (pos->obj == (void *)uuid) {\n        fio_ls_remove(pos);\n        break;\n      }\n    }\n    fio_unlock(&cluster_data.lock);\n  } else if (fio_data->active) {\n    /* no shutdown message received - parent crashed. */\n    if (c->type != FIO_CLUSTER_MSG_SHUTDOWN && fio_is_running()) {\n      FIO_LOG_FATAL(\"(%d) Parent Process crash detected!\", (int)getpid());\n      fio_state_callback_force(FIO_CALL_ON_PARENT_CRUSH);\n      fio_state_callback_clear(FIO_CALL_ON_PARENT_CRUSH);\n      fio_cluster_data_cleanup(1);\n      kill(getpid(), SIGINT);\n    }\n  }\n  if (c->msg)\n    fio_msg_internal_free(c->msg);\n  c->msg = NULL;\n  fio_sub_hash_free(&c->pubsub);\n  fio_cluster_protocol_free(c);\n  (void)uuid;\n}\n\nstatic inline fio_protocol_s *\nfio_cluster_protocol_alloc(intptr_t uuid,\n                           void (*handler)(struct cluster_pr_s *pr),\n                           void (*sender)(void *data, intptr_t auuid)) {\n  cluster_pr_s *p = fio_mmap(sizeof(*p));\n  if (!p) {\n    FIO_LOG_FATAL(\"Cluster protocol allocation failed.\");\n    exit(errno);\n  }\n  p->protocol = (fio_protocol_s){\n      .ping = fio_cluster_ping,\n      .on_close = fio_cluster_on_close,\n      .on_shutdown = fio_cluster_on_shutdown,\n      .on_data = fio_cluster_on_data,\n  };\n  p->uuid = uuid;\n  p->handler = handler;\n  p->sender = sender;\n  p->pubsub = (fio_sub_hash_s)FIO_SET_INIT;\n  p->patterns = (fio_sub_hash_s)FIO_SET_INIT;\n  p->lock = FIO_LOCK_INIT;\n  return &p->protocol;\n}\n\n/* *****************************************************************************\n * Master (server) IPC Connections\n **************************************************************************** */\n\nstatic void fio_cluster_server_sender(void *m_, intptr_t avoid_uuid) {\n  fio_msg_internal_s *m = m_;\n  fio_lock(&cluster_data.lock);\n  FIO_LS_FOR(&cluster_data.clients, pos) {\n    if ((intptr_t)pos->obj != -1) {\n      if ((intptr_t)pos->obj != avoid_uuid) {\n        fio_msg_internal_send_dup((intptr_t)pos->obj, m);\n      }\n    }\n  }\n  fio_unlock(&cluster_data.lock);\n  fio_msg_internal_free(m);\n}\n\nstatic void fio_cluster_server_handler(struct cluster_pr_s *pr) {\n  /* what to do? */\n  // fprintf(stderr, \"-\");\n  switch ((fio_cluster_message_type_e)pr->type) {\n\n  case FIO_CLUSTER_MSG_FORWARD: /* fallthrough */\n  case FIO_CLUSTER_MSG_JSON: {\n    fio_cluster_server_sender(fio_msg_internal_dup(pr->msg), pr->uuid);\n    fio_publish2process(fio_msg_internal_dup(pr->msg));\n    break;\n  }\n\n  case FIO_CLUSTER_MSG_PUBSUB_SUB: {\n    subscription_s *s =\n        fio_subscribe(.on_message = fio_mock_on_message, .match = NULL,\n                      .channel = pr->msg->channel);\n    fio_str_s tmp = FIO_STR_INIT_EXISTING(\n        pr->msg->channel.data, pr->msg->channel.len, 0); // don't free\n    fio_lock(&pr->lock);\n    fio_sub_hash_insert(&pr->pubsub,\n                        FIO_HASH_FN(pr->msg->channel.data, pr->msg->channel.len,\n                                    &fio_postoffice.pubsub,\n                                    &fio_postoffice.pubsub),\n                        tmp, s, NULL);\n    fio_unlock(&pr->lock);\n    break;\n  }\n  case FIO_CLUSTER_MSG_PUBSUB_UNSUB: {\n    fio_str_s tmp = FIO_STR_INIT_EXISTING(\n        pr->msg->channel.data, pr->msg->channel.len, 0); // don't free\n    fio_lock(&pr->lock);\n    fio_sub_hash_remove(&pr->pubsub,\n                        FIO_HASH_FN(pr->msg->channel.data, pr->msg->channel.len,\n                                    &fio_postoffice.pubsub,\n                                    &fio_postoffice.pubsub),\n                        tmp, NULL);\n    fio_unlock(&pr->lock);\n    break;\n  }\n\n  case FIO_CLUSTER_MSG_PATTERN_SUB: {\n    uintptr_t match = fio_str2u64(pr->msg->data.data);\n    subscription_s *s = fio_subscribe(.on_message = fio_mock_on_message,\n                                      .match = (fio_match_fn)match,\n                                      .channel = pr->msg->channel);\n    fio_str_s tmp = FIO_STR_INIT_EXISTING(\n        pr->msg->channel.data, pr->msg->channel.len, 0); // don't free\n    fio_lock(&pr->lock);\n    fio_sub_hash_insert(&pr->patterns,\n                        FIO_HASH_FN(pr->msg->channel.data, pr->msg->channel.len,\n                                    &fio_postoffice.pubsub,\n                                    &fio_postoffice.pubsub),\n                        tmp, s, NULL);\n    fio_unlock(&pr->lock);\n    break;\n  }\n\n  case FIO_CLUSTER_MSG_PATTERN_UNSUB: {\n    fio_str_s tmp = FIO_STR_INIT_EXISTING(\n        pr->msg->channel.data, pr->msg->channel.len, 0); // don't free\n    fio_lock(&pr->lock);\n    fio_sub_hash_remove(&pr->patterns,\n                        FIO_HASH_FN(pr->msg->channel.data, pr->msg->channel.len,\n                                    &fio_postoffice.pubsub,\n                                    &fio_postoffice.pubsub),\n                        tmp, NULL);\n    fio_unlock(&pr->lock);\n    break;\n  }\n\n  case FIO_CLUSTER_MSG_ROOT_JSON:\n    pr->type = FIO_CLUSTER_MSG_JSON; /* fallthrough */\n  case FIO_CLUSTER_MSG_ROOT:\n    fio_publish2process(fio_msg_internal_dup(pr->msg));\n    break;\n\n  case FIO_CLUSTER_MSG_SHUTDOWN: /* fallthrough */\n  case FIO_CLUSTER_MSG_ERROR:    /* fallthrough */\n  case FIO_CLUSTER_MSG_PING:     /* fallthrough */\n  default:\n    break;\n  }\n}\n\n/** Called when a ne client is available */\nstatic void fio_cluster_listen_accept(intptr_t uuid, fio_protocol_s *protocol) {\n  (void)protocol;\n  /* prevent `accept` backlog in parent */\n  intptr_t client;\n  while ((client = fio_accept(uuid)) != -1) {\n    fio_attach(client,\n               fio_cluster_protocol_alloc(client, fio_cluster_server_handler,\n                                          fio_cluster_server_sender));\n    fio_lock(&cluster_data.lock);\n    fio_ls_push(&cluster_data.clients, (void *)client);\n    fio_unlock(&cluster_data.lock);\n  }\n}\n\n/** Called when the connection was closed, but will not run concurrently */\nstatic void fio_cluster_listen_on_close(intptr_t uuid,\n                                        fio_protocol_s *protocol) {\n  free(protocol);\n  cluster_data.uuid = -1;\n  if (fio_parent_pid() == getpid()) {\n#if DEBUG\n    FIO_LOG_DEBUG(\"(%d) stopped listening for cluster connections\",\n                  (int)getpid());\n#endif\n    if (fio_data->active)\n      kill(0, SIGINT);\n  }\n  (void)uuid;\n}\n\nstatic void fio_listen2cluster(void *ignore) {\n  /* this is called for each `fork`, but we only need this to run once. */\n  fio_lock(&cluster_data.lock);\n  cluster_data.uuid = fio_socket(cluster_data.name, NULL, 1);\n  fio_unlock(&cluster_data.lock);\n  if (cluster_data.uuid < 0) {\n    FIO_LOG_FATAL(\"(facil.io cluster) failed to open cluster socket.\");\n    perror(\"             check file permissions. errno:\");\n    exit(errno);\n  }\n  fio_protocol_s *p = malloc(sizeof(*p));\n  FIO_ASSERT_ALLOC(p);\n  *p = (fio_protocol_s){\n      .on_data = fio_cluster_listen_accept,\n      .on_shutdown = mock_on_shutdown_eternal,\n      .ping = mock_ping_eternal,\n      .on_close = fio_cluster_listen_on_close,\n  };\n  FIO_LOG_DEBUG(\"(%d) Listening to cluster: %s\", (int)getpid(),\n                cluster_data.name);\n  fio_attach(cluster_data.uuid, p);\n  (void)ignore;\n}\n\n/* *****************************************************************************\n * Worker (client) IPC connections\n **************************************************************************** */\n\nstatic void fio_cluster_client_handler(struct cluster_pr_s *pr) {\n  /* what to do? */\n  switch ((fio_cluster_message_type_e)pr->type) {\n  case FIO_CLUSTER_MSG_FORWARD: /* fallthrough */\n  case FIO_CLUSTER_MSG_JSON:\n    fio_publish2process(fio_msg_internal_dup(pr->msg));\n    break;\n  case FIO_CLUSTER_MSG_SHUTDOWN:\n    fio_stop();\n    kill(getpid(), SIGINT);\n  case FIO_CLUSTER_MSG_ERROR:         /* fallthrough */\n  case FIO_CLUSTER_MSG_PING:          /* fallthrough */\n  case FIO_CLUSTER_MSG_ROOT:          /* fallthrough */\n  case FIO_CLUSTER_MSG_ROOT_JSON:     /* fallthrough */\n  case FIO_CLUSTER_MSG_PUBSUB_SUB:    /* fallthrough */\n  case FIO_CLUSTER_MSG_PUBSUB_UNSUB:  /* fallthrough */\n  case FIO_CLUSTER_MSG_PATTERN_SUB:   /* fallthrough */\n  case FIO_CLUSTER_MSG_PATTERN_UNSUB: /* fallthrough */\n\n  default:\n    break;\n  }\n}\nstatic void fio_cluster_client_sender(void *m_, intptr_t ignr_) {\n  fio_msg_internal_s *m = m_;\n  if (!uuid_is_valid(cluster_data.uuid) && fio_data->active) {\n    /* delay message delivery until we have a vaild uuid */\n    fio_defer_push_task((void (*)(void *, void *))fio_cluster_client_sender, m_,\n                        (void *)ignr_);\n    return;\n  }\n  fio_msg_internal_send_dup(cluster_data.uuid, m);\n  fio_msg_internal_free(m);\n}\n\n/** The address of the server we are connecting to. */\n// char *address;\n/** The port on the server we are connecting to. */\n// char *port;\n/**\n * The `on_connect` callback should return a pointer to a protocol object\n * that will handle any connection related events.\n *\n * Should either call `facil_attach` or close the connection.\n */\nstatic void fio_cluster_on_connect(intptr_t uuid, void *udata) {\n  cluster_data.uuid = uuid;\n\n  /* inform root about all existing channels */\n  fio_lock(&fio_postoffice.pubsub.lock);\n  FIO_SET_FOR_LOOP(&fio_postoffice.pubsub.channels, pos) {\n    if (!pos->hash) {\n      continue;\n    }\n    fio_cluster_inform_root_about_channel(pos->obj, 1);\n  }\n  fio_unlock(&fio_postoffice.pubsub.lock);\n  fio_lock(&fio_postoffice.patterns.lock);\n  FIO_SET_FOR_LOOP(&fio_postoffice.patterns.channels, pos) {\n    if (!pos->hash) {\n      continue;\n    }\n    fio_cluster_inform_root_about_channel(pos->obj, 1);\n  }\n  fio_unlock(&fio_postoffice.patterns.lock);\n\n  fio_attach(uuid, fio_cluster_protocol_alloc(uuid, fio_cluster_client_handler,\n                                              fio_cluster_client_sender));\n  (void)udata;\n}\n/**\n * The `on_fail` is called when a socket fails to connect. The old sock UUID\n * is passed along.\n */\nstatic void fio_cluster_on_fail(intptr_t uuid, void *udata) {\n  FIO_LOG_FATAL(\"(facil.io) unknown cluster connection error\");\n  perror(\"       errno\");\n  kill(fio_parent_pid(), SIGINT);\n  fio_stop();\n  // exit(errno ? errno : 1);\n  (void)udata;\n  (void)uuid;\n}\n\nstatic void fio_connect2cluster(void *ignore) {\n  if (cluster_data.uuid)\n    fio_force_close(cluster_data.uuid);\n  cluster_data.uuid = 0;\n  /* this is called for each child, but not for single a process worker. */\n  fio_connect(.address = cluster_data.name, .port = NULL,\n              .on_connect = fio_cluster_on_connect,\n              .on_fail = fio_cluster_on_fail);\n  (void)ignore;\n}\n\nstatic void fio_send2cluster(fio_msg_internal_s *m) {\n  if (!fio_is_running()) {\n    FIO_LOG_ERROR(\"facio.io cluster inactive, can't send message.\");\n    return;\n  }\n  if (fio_data->workers == 1) {\n    /* nowhere to send to */\n    return;\n  }\n  if (fio_is_master()) {\n    fio_cluster_server_sender(fio_msg_internal_dup(m), -1);\n  } else {\n    fio_cluster_client_sender(fio_msg_internal_dup(m), -1);\n  }\n}\n\n/* *****************************************************************************\n * Propegation\n **************************************************************************** */\n\nstatic inline void fio_cluster_inform_root_about_channel(channel_s *ch,\n                                                         int add) {\n  if (!fio_data->is_worker || fio_data->workers == 1 || !cluster_data.uuid ||\n      !ch)\n    return;\n  fio_str_info_s ch_name = {.data = ch->name, .len = ch->name_len};\n  fio_str_info_s msg = {.data = NULL, .len = 0};\n#if DEBUG\n  FIO_LOG_DEBUG(\"(%d) informing root about: %s (%zu) msg type %d\",\n                (int)getpid(), ch_name.data, ch_name.len,\n                (ch->match ? (add ? FIO_CLUSTER_MSG_PATTERN_SUB\n                                  : FIO_CLUSTER_MSG_PATTERN_UNSUB)\n                           : (add ? FIO_CLUSTER_MSG_PUBSUB_SUB\n                                  : FIO_CLUSTER_MSG_PUBSUB_UNSUB)));\n#endif\n  char buf[8] = {0};\n  if (ch->match) {\n    fio_u2str64(buf, (uint64_t)ch->match);\n    msg.data = buf;\n    msg.len = sizeof(ch->match);\n  }\n\n  fio_cluster_client_sender(\n      fio_msg_internal_create(0,\n                              (ch->match\n                                   ? (add ? FIO_CLUSTER_MSG_PATTERN_SUB\n                                          : FIO_CLUSTER_MSG_PATTERN_UNSUB)\n                                   : (add ? FIO_CLUSTER_MSG_PUBSUB_SUB\n                                          : FIO_CLUSTER_MSG_PUBSUB_UNSUB)),\n                              ch_name, msg, 0, 1),\n      -1);\n}\n\n/* *****************************************************************************\n * Initialization\n **************************************************************************** */\n\nstatic void fio_accept_after_fork(void *ignore) {\n  /* prevent `accept` backlog in parent */\n  fio_cluster_listen_accept(cluster_data.uuid, NULL);\n  (void)ignore;\n}\n\nstatic void fio_cluster_at_exit(void *ignore) {\n  /* unlock all */\n  fio_pubsub_on_fork();\n  /* clear subscriptions of all types */\n  while (fio_ch_set_count(&fio_postoffice.patterns.channels)) {\n    channel_s *ch = fio_ch_set_last(&fio_postoffice.patterns.channels);\n    while (fio_ls_embd_any(&ch->subscriptions)) {\n      subscription_s *sub =\n          FIO_LS_EMBD_OBJ(subscription_s, node, ch->subscriptions.next);\n      fio_unsubscribe(sub);\n    }\n    fio_ch_set_pop(&fio_postoffice.patterns.channels);\n  }\n\n  while (fio_ch_set_count(&fio_postoffice.pubsub.channels)) {\n    channel_s *ch = fio_ch_set_last(&fio_postoffice.pubsub.channels);\n    while (fio_ls_embd_any(&ch->subscriptions)) {\n      subscription_s *sub =\n          FIO_LS_EMBD_OBJ(subscription_s, node, ch->subscriptions.next);\n      fio_unsubscribe(sub);\n    }\n    fio_ch_set_pop(&fio_postoffice.pubsub.channels);\n  }\n\n  while (fio_ch_set_count(&fio_postoffice.filters.channels)) {\n    channel_s *ch = fio_ch_set_last(&fio_postoffice.filters.channels);\n    while (fio_ls_embd_any(&ch->subscriptions)) {\n      subscription_s *sub =\n          FIO_LS_EMBD_OBJ(subscription_s, node, ch->subscriptions.next);\n      fio_unsubscribe(sub);\n    }\n    fio_ch_set_pop(&fio_postoffice.filters.channels);\n  }\n  fio_ch_set_free(&fio_postoffice.filters.channels);\n  fio_ch_set_free(&fio_postoffice.patterns.channels);\n  fio_ch_set_free(&fio_postoffice.pubsub.channels);\n\n  /* clear engines */\n  FIO_PUBSUB_DEFAULT = FIO_PUBSUB_CLUSTER;\n  while (fio_engine_set_count(&fio_postoffice.engines.set)) {\n    fio_pubsub_detach(fio_engine_set_last(&fio_postoffice.engines.set));\n    fio_engine_set_last(&fio_postoffice.engines.set);\n  }\n  fio_engine_set_free(&fio_postoffice.engines.set);\n\n  /* clear meta hooks */\n  fio_meta_ary_free(&fio_postoffice.meta.ary);\n  /* perform newly created tasks */\n  fio_defer_perform();\n  (void)ignore;\n}\n\nstatic void fio_pubsub_initialize(void) {\n  fio_cluster_init();\n  fio_state_callback_add(FIO_CALL_PRE_START, fio_listen2cluster, NULL);\n  fio_state_callback_add(FIO_CALL_IN_MASTER, fio_accept_after_fork, NULL);\n  fio_state_callback_add(FIO_CALL_IN_CHILD, fio_connect2cluster, NULL);\n  fio_state_callback_add(FIO_CALL_ON_FINISH, fio_cluster_cleanup, NULL);\n  fio_state_callback_add(FIO_CALL_AT_EXIT, fio_cluster_at_exit, NULL);\n}\n\n/* *****************************************************************************\nCluster forking handler\n***************************************************************************** */\n\nstatic void fio_pubsub_on_fork(void) {\n  fio_postoffice.filters.lock = FIO_LOCK_INIT;\n  fio_postoffice.pubsub.lock = FIO_LOCK_INIT;\n  fio_postoffice.patterns.lock = FIO_LOCK_INIT;\n  fio_postoffice.engines.lock = FIO_LOCK_INIT;\n  fio_postoffice.meta.lock = FIO_LOCK_INIT;\n  cluster_data.lock = FIO_LOCK_INIT;\n  cluster_data.uuid = 0;\n  FIO_SET_FOR_LOOP(&fio_postoffice.filters.channels, pos) {\n    if (!pos->hash)\n      continue;\n    pos->obj->lock = FIO_LOCK_INIT;\n    FIO_LS_EMBD_FOR(&pos->obj->subscriptions, n) {\n      FIO_LS_EMBD_OBJ(subscription_s, node, n)->lock = FIO_LOCK_INIT;\n    }\n  }\n  FIO_SET_FOR_LOOP(&fio_postoffice.pubsub.channels, pos) {\n    if (!pos->hash)\n      continue;\n    pos->obj->lock = FIO_LOCK_INIT;\n    FIO_LS_EMBD_FOR(&pos->obj->subscriptions, n) {\n      FIO_LS_EMBD_OBJ(subscription_s, node, n)->lock = FIO_LOCK_INIT;\n    }\n  }\n  FIO_SET_FOR_LOOP(&fio_postoffice.patterns.channels, pos) {\n    if (!pos->hash)\n      continue;\n    pos->obj->lock = FIO_LOCK_INIT;\n    FIO_LS_EMBD_FOR(&pos->obj->subscriptions, n) {\n      FIO_LS_EMBD_OBJ(subscription_s, node, n)->lock = FIO_LOCK_INIT;\n    }\n  }\n}\n\n/* *****************************************************************************\n * External API\n **************************************************************************** */\n\n/** Signals children (or self) to shutdown) - NOT signal safe. */\nstatic void fio_cluster_signal_children(void) {\n  if (fio_parent_pid() != getpid()) {\n    kill(getpid(), SIGINT);\n    return;\n  }\n  fio_cluster_server_sender(fio_msg_internal_create(0, FIO_CLUSTER_MSG_SHUTDOWN,\n                                                    (fio_str_info_s){.len = 0},\n                                                    (fio_str_info_s){.len = 0},\n                                                    0, 1),\n                            -1);\n}\n\n/* Sublime Text marker */\nvoid fio_publish___(fio_publish_args_s args);\n/**\n * Publishes a message to the relevant subscribers (if any).\n *\n * See `facil_publish_args_s` for details.\n *\n * By default the message is sent using the FIO_PUBSUB_CLUSTER engine (all\n * processes, including the calling process).\n *\n * To limit the message only to other processes (exclude the calling process),\n * use the FIO_PUBSUB_SIBLINGS engine.\n *\n * To limit the message only to the calling process, use the\n * FIO_PUBSUB_PROCESS engine.\n *\n * To publish messages to the pub/sub layer, the `.filter` argument MUST be\n * equal to 0 or missing.\n */\nvoid fio_publish FIO_IGNORE_MACRO(fio_publish_args_s args) {\n  if (args.filter && !args.engine) {\n    args.engine = FIO_PUBSUB_CLUSTER;\n  } else if (!args.engine) {\n    args.engine = FIO_PUBSUB_DEFAULT;\n  }\n  fio_msg_internal_s *m = NULL;\n  switch ((uintptr_t)args.engine) {\n  case 0UL: /* fallthrough (missing default) */\n  case 1UL: // ((uintptr_t)FIO_PUBSUB_CLUSTER):\n    m = fio_msg_internal_create(\n        args.filter,\n        (args.is_json ? FIO_CLUSTER_MSG_JSON : FIO_CLUSTER_MSG_FORWARD),\n        args.channel, args.message, args.is_json, 1);\n    fio_send2cluster(m);\n    fio_publish2process(m);\n    break;\n  case 2UL: // ((uintptr_t)FIO_PUBSUB_PROCESS):\n    m = fio_msg_internal_create(args.filter, 0, args.channel, args.message,\n                                args.is_json, 1);\n    fio_publish2process(m);\n    break;\n  case 3UL: // ((uintptr_t)FIO_PUBSUB_SIBLINGS):\n    m = fio_msg_internal_create(\n        args.filter,\n        (args.is_json ? FIO_CLUSTER_MSG_JSON : FIO_CLUSTER_MSG_FORWARD),\n        args.channel, args.message, args.is_json, 1);\n    fio_send2cluster(m);\n    fio_msg_internal_free(m);\n    m = NULL;\n    break;\n  case 4UL: // ((uintptr_t)FIO_PUBSUB_ROOT):\n    m = fio_msg_internal_create(\n        args.filter,\n        (args.is_json ? FIO_CLUSTER_MSG_ROOT_JSON : FIO_CLUSTER_MSG_ROOT),\n        args.channel, args.message, args.is_json, 1);\n    if (fio_data->is_worker == 0 || fio_data->workers == 1) {\n      fio_publish2process(m);\n    } else {\n      fio_cluster_client_sender(m, -1);\n    }\n    break;\n  default:\n    if (args.filter != 0) {\n      FIO_LOG_ERROR(\"(pub/sub) pub/sub engines can only be used for \"\n                    \"pub/sub messages (no filter).\");\n      return;\n    }\n    args.engine->publish(args.engine, args.channel, args.message, args.is_json);\n  }\n  return;\n}\n\n/* *****************************************************************************\n * Glob Matching\n **************************************************************************** */\n\n/** A binary glob matching helper. Returns 1 on match, otherwise returns 0. */\nstatic int fio_glob_match(fio_str_info_s pat, fio_str_info_s ch) {\n  /* adapted and rewritten, with thankfulness, from the code at:\n   * https://github.com/opnfv/kvmfornfv/blob/master/kernel/lib/glob.c\n   *\n   * Original version's copyright:\n   * Copyright 2015 Open Platform for NFV Project, Inc. and its contributors\n   * Under the MIT license.\n   */\n\n  /*\n   * Backtrack to previous * on mismatch and retry starting one\n   * character later in the string.  Because * matches all characters,\n   * there's never a need to backtrack multiple levels.\n   */\n  uint8_t *back_pat = NULL, *back_str = (uint8_t *)ch.data;\n  size_t back_pat_len = 0, back_str_len = ch.len;\n\n  /*\n   * Loop over each token (character or class) in pat, matching\n   * it against the remaining unmatched tail of str.  Return false\n   * on mismatch, or true after matching the trailing nul bytes.\n   */\n  while (ch.len) {\n    uint8_t c = *(uint8_t *)ch.data++;\n    uint8_t d = *(uint8_t *)pat.data++;\n    ch.len--;\n    pat.len--;\n\n    switch (d) {\n    case '?': /* Wildcard: anything goes */\n      break;\n\n    case '*':       /* Any-length wildcard */\n      if (!pat.len) /* Optimize trailing * case */\n        return 1;\n      back_pat = (uint8_t *)pat.data;\n      back_pat_len = pat.len;\n      back_str = (uint8_t *)--ch.data; /* Allow zero-length match */\n      back_str_len = ++ch.len;\n      break;\n\n    case '[': { /* Character class */\n      uint8_t match = 0, inverted = (*(uint8_t *)pat.data == '^');\n      uint8_t *cls = (uint8_t *)pat.data + inverted;\n      uint8_t a = *cls++;\n\n      /*\n       * Iterate over each span in the character class.\n       * A span is either a single character a, or a\n       * range a-b.  The first span may begin with ']'.\n       */\n      do {\n        uint8_t b = a;\n\n        if (cls[0] == '-' && cls[1] != ']') {\n          b = cls[1];\n\n          cls += 2;\n          if (a > b) {\n            uint8_t tmp = a;\n            a = b;\n            b = tmp;\n          }\n        }\n        match |= (a <= c && c <= b);\n      } while ((a = *cls++) != ']');\n\n      if (match == inverted)\n        goto backtrack;\n      pat.len -= cls - (uint8_t *)pat.data;\n      pat.data = (char *)cls;\n\n    } break;\n    case '\\\\':\n      d = *(uint8_t *)pat.data++;\n      pat.len--;\n    /* fallthrough */\n    default: /* Literal character */\n      if (c == d)\n        break;\n    backtrack:\n      if (!back_pat)\n        return 0; /* No point continuing */\n      /* Try again from last *, one character later in str. */\n      pat.data = (char *)back_pat;\n      ch.data = (char *)++back_str;\n      ch.len = --back_str_len;\n      pat.len = back_pat_len;\n    }\n  }\n  return !ch.len && !pat.len;\n}\n\nfio_match_fn FIO_MATCH_GLOB = fio_glob_match;\n\n#else /* FIO_PUBSUB_SUPPORT */\n\nstatic void fio_pubsub_on_fork(void) {}\nstatic void fio_cluster_init(void) {}\nstatic void fio_cluster_signal_children(void) {}\n\n#endif /* FIO_PUBSUB_SUPPORT */\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                   Memory Allocator Details & Implementation\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/* *****************************************************************************\nAllocator default settings\n***************************************************************************** */\n\n/* doun't change these */\n#undef FIO_MEMORY_BLOCK_SLICES\n#undef FIO_MEMORY_BLOCK_HEADER_SIZE\n#undef FIO_MEMORY_BLOCK_START_POS\n#undef FIO_MEMORY_MAX_SLICES_PER_BLOCK\n#undef FIO_MEMORY_BLOCK_MASK\n\n/* The number of blocks pre-allocated each system call, 256 ==8Mb */\n#ifndef FIO_MEMORY_BLOCKS_PER_ALLOCATION\n#define FIO_MEMORY_BLOCKS_PER_ALLOCATION 256\n#endif\n\n#define FIO_MEMORY_BLOCK_MASK (FIO_MEMORY_BLOCK_SIZE - 1) /* 0b0...1... */\n\n#define FIO_MEMORY_BLOCK_SLICES (FIO_MEMORY_BLOCK_SIZE >> 4) /* 16B slices */\n\n/* must be divisable by 16 bytes, bigger than min(sizeof(block_s), 16) */\n#define FIO_MEMORY_BLOCK_HEADER_SIZE 32\n\n/* allocation counter position (start) */\n#define FIO_MEMORY_BLOCK_START_POS (FIO_MEMORY_BLOCK_HEADER_SIZE >> 4)\n\n#define FIO_MEMORY_MAX_SLICES_PER_BLOCK                                        \\\n  (FIO_MEMORY_BLOCK_SLICES - FIO_MEMORY_BLOCK_START_POS)\n\n/* *****************************************************************************\nFIO_FORCE_MALLOC handler\n***************************************************************************** */\n\n#if FIO_FORCE_MALLOC\n\nvoid *fio_malloc(size_t size) { return calloc(size, 1); }\n\nvoid *fio_calloc(size_t size_per_unit, size_t unit_count) {\n  return calloc(size_per_unit, unit_count);\n}\n\nvoid fio_free(void *ptr) { free(ptr); }\n\nvoid *fio_realloc(void *ptr, size_t new_size) {\n  return realloc((ptr), (new_size));\n}\n\nvoid *fio_realloc2(void *ptr, size_t new_size, size_t copy_length) {\n  return realloc((ptr), (new_size));\n  (void)copy_length;\n}\n\nvoid *fio_mmap(size_t size) { return calloc(size, 1); }\n\nvoid fio_malloc_after_fork(void) {}\nvoid fio_mem_destroy(void) {}\nvoid fio_mem_init(void) {}\n\n#else\n\n/* *****************************************************************************\nMemory Copying by 16 byte units\n***************************************************************************** */\n\n/** used internally, only when memory addresses are known to be aligned */\nstatic inline void fio_memcpy(void *__restrict dest_, void *__restrict src_,\n                              size_t units) {\n#if __SIZEOF_INT128__ == 9 /* a 128bit type exists... but tests favor 64bit */\n  register __uint128_t *dest = dest_;\n  register __uint128_t *src = src_;\n#elif SIZE_MAX == 0xFFFFFFFFFFFFFFFF /* 64 bit size_t */\n  register size_t *dest = dest_;\n  register size_t *src = src_;\n  units = units << 1;\n#elif SIZE_MAX == 0xFFFFFFFF         /* 32 bit size_t */\n  register size_t *dest = dest_;\n  register size_t *src = src_;\n  units = units << 2;\n#else                                /* unknow... assume 16 bit? */\n  register size_t *dest = dest_;\n  register size_t *src = src_;\n  units = units << 3;\n#endif\n  while (units >= 16) { /* unroll loop */\n    dest[0] = src[0];\n    dest[1] = src[1];\n    dest[2] = src[2];\n    dest[3] = src[3];\n    dest[4] = src[4];\n    dest[5] = src[5];\n    dest[6] = src[6];\n    dest[7] = src[7];\n    dest[8] = src[8];\n    dest[9] = src[9];\n    dest[10] = src[10];\n    dest[11] = src[11];\n    dest[12] = src[12];\n    dest[13] = src[13];\n    dest[14] = src[14];\n    dest[15] = src[15];\n    dest += 16;\n    src += 16;\n    units -= 16;\n  }\n  switch (units) {\n  case 15:\n    *(dest++) = *(src++); /* fallthrough */\n  case 14:\n    *(dest++) = *(src++); /* fallthrough */\n  case 13:\n    *(dest++) = *(src++); /* fallthrough */\n  case 12:\n    *(dest++) = *(src++); /* fallthrough */\n  case 11:\n    *(dest++) = *(src++); /* fallthrough */\n  case 10:\n    *(dest++) = *(src++); /* fallthrough */\n  case 9:\n    *(dest++) = *(src++); /* fallthrough */\n  case 8:\n    *(dest++) = *(src++); /* fallthrough */\n  case 7:\n    *(dest++) = *(src++); /* fallthrough */\n  case 6:\n    *(dest++) = *(src++); /* fallthrough */\n  case 5:\n    *(dest++) = *(src++); /* fallthrough */\n  case 4:\n    *(dest++) = *(src++); /* fallthrough */\n  case 3:\n    *(dest++) = *(src++); /* fallthrough */\n  case 2:\n    *(dest++) = *(src++); /* fallthrough */\n  case 1:\n    *(dest++) = *(src++);\n  }\n}\n\n/* *****************************************************************************\nSystem Memory wrappers\n***************************************************************************** */\n\n/*\n * allocates memory using `mmap`, but enforces block size alignment.\n * requires page aligned `len`.\n *\n * `align_shift` is used to move the memory page alignment to allow for a single\n * page allocation header. align_shift MUST be either 0 (normal) or 1 (single\n * page header). Other values might cause errors.\n */\nstatic inline void *sys_alloc(size_t len, uint8_t is_indi) {\n  void *result;\n  static void *next_alloc = NULL;\n/* hope for the best? */\n#ifdef MAP_ALIGNED\n  result =\n      mmap(next_alloc, len, PROT_READ | PROT_WRITE,\n           MAP_PRIVATE | MAP_ANONYMOUS | MAP_ALIGNED(FIO_MEMORY_BLOCK_SIZE_LOG),\n           -1, 0);\n#else\n  result = mmap(next_alloc, len, PROT_READ | PROT_WRITE,\n                MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n#endif\n  if (result == MAP_FAILED)\n    return NULL;\n  if (((uintptr_t)result & FIO_MEMORY_BLOCK_MASK)) {\n    munmap(result, len);\n    result = mmap(NULL, len + FIO_MEMORY_BLOCK_SIZE, PROT_READ | PROT_WRITE,\n                  MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    if (result == MAP_FAILED) {\n      return NULL;\n    }\n    const uintptr_t offset =\n        (FIO_MEMORY_BLOCK_SIZE - ((uintptr_t)result & FIO_MEMORY_BLOCK_MASK));\n    if (offset) {\n      munmap(result, offset);\n      result = (void *)((uintptr_t)result + offset);\n    }\n    munmap((void *)((uintptr_t)result + len), FIO_MEMORY_BLOCK_SIZE - offset);\n  }\n  if (is_indi ==\n      0) /* advance by a block's allocation size for next allocation */\n    next_alloc =\n        (void *)((uintptr_t)result +\n                 (FIO_MEMORY_BLOCK_SIZE * (FIO_MEMORY_BLOCKS_PER_ALLOCATION)));\n  else /* add 1TB for realloc */\n    next_alloc = (void *)((uintptr_t)result + (is_indi * ((uintptr_t)1 << 30)));\n  return result;\n}\n\n/* frees memory using `munmap`. requires exact, page aligned, `len` */\nstatic inline void sys_free(void *mem, size_t len) { munmap(mem, len); }\n\nstatic void *sys_realloc(void *mem, size_t prev_len, size_t new_len) {\n  if (new_len > prev_len) {\n    void *result;\n#if defined(__linux__)\n    result = mremap(mem, prev_len, new_len, 0);\n    if (result != MAP_FAILED)\n      return result;\n#endif\n    result = mmap((void *)((uintptr_t)mem + prev_len), new_len - prev_len,\n                  PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n    if (result == (void *)((uintptr_t)mem + prev_len)) {\n      result = mem;\n    } else {\n      /* copy and free */\n      munmap(result, new_len - prev_len); /* free the failed attempt */\n      result = sys_alloc(new_len, 1);     /* allocate new memory */\n      if (!result) {\n        return NULL;\n      }\n      fio_memcpy(result, mem, prev_len >> 4); /* copy data */\n      // memcpy(result, mem, prev_len);\n      munmap(mem, prev_len); /* free original memory */\n    }\n    return result;\n  }\n  if (new_len + 4096 < prev_len) /* more than a single dangling page */\n    munmap((void *)((uintptr_t)mem + new_len), prev_len - new_len);\n  return mem;\n}\n\n/** Rounds up any size to the nearest page alignment (assumes 4096 bytes per\n * page) */\nstatic inline size_t sys_round_size(size_t size) {\n  return (size & (~4095)) + (4096 * (!!(size & 4095)));\n}\n\n/* *****************************************************************************\nData Types\n***************************************************************************** */\n\n/* The basic block header. Starts a 32Kib memory block */\ntypedef struct block_s block_s;\n\nstruct block_s {\n  block_s *parent;   /* REQUIRED, root == point to self */\n  uint16_t ref;      /* reference count (per memory page) */\n  uint16_t pos;      /* position into the block */\n  uint16_t max;      /* available memory count */\n  uint16_t root_ref; /* root reference memory padding */\n};\n\ntypedef struct block_node_s block_node_s;\nstruct block_node_s {\n  block_s dont_touch; /* prevent block internal data from being corrupted */\n  fio_ls_embd_s node; /* next block */\n};\n\n/* a per-CPU core \"arena\" for memory allocations  */\ntypedef struct {\n  block_s *block;\n  fio_lock_i lock;\n} arena_s;\n\n/* The memory allocators persistent state */\nstatic struct {\n  fio_ls_embd_s available; /* free list for memory blocks */\n  // intptr_t count;          /* free list counter */\n  size_t cores;    /* the number of detected CPU cores*/\n  fio_lock_i lock; /* a global lock */\n  uint8_t forked;  /* a forked collection indicator. */\n} memory = {\n    .cores = 1,\n    .lock = FIO_LOCK_INIT,\n    .available = FIO_LS_INIT(memory.available),\n};\n\n/* The per-CPU arena array. */\nstatic arena_s *arenas;\n\n/* The per-CPU arena array. */\nstatic long double on_malloc_zero;\n\n#if DEBUG\n/* The per-CPU arena array. */\nstatic size_t fio_mem_block_count_max;\n/* The per-CPU arena array. */\nstatic size_t fio_mem_block_count;\n#define FIO_MEMORY_ON_BLOCK_ALLOC()                                            \\\n  do {                                                                         \\\n    fio_atomic_add(&fio_mem_block_count, 1);                                   \\\n    if (fio_mem_block_count > fio_mem_block_count_max)                         \\\n      fio_mem_block_count_max = fio_mem_block_count;                           \\\n  } while (0)\n#define FIO_MEMORY_ON_BLOCK_FREE()                                             \\\n  do {                                                                         \\\n    fio_atomic_sub(&fio_mem_block_count, 1);                                   \\\n  } while (0)\n#define FIO_MEMORY_PRINT_BLOCK_STAT()                                          \\\n  FIO_LOG_INFO(                                                                \\\n      \"(fio) Total memory blocks allocated before cleanup %zu\\n\"               \\\n      \"       Maximum memory blocks allocated at a single time %zu\\n\",         \\\n      fio_mem_block_count, fio_mem_block_count_max)\n#define FIO_MEMORY_PRINT_BLOCK_STAT_END()                                      \\\n  FIO_LOG_INFO(\"(fio) Total memory blocks allocated \"                          \\\n               \"after cleanup (possible leak) %zu\\n\",                          \\\n               fio_mem_block_count)\n#else\n#define FIO_MEMORY_ON_BLOCK_ALLOC()\n#define FIO_MEMORY_ON_BLOCK_FREE()\n#define FIO_MEMORY_PRINT_BLOCK_STAT()\n#define FIO_MEMORY_PRINT_BLOCK_STAT_END()\n#endif\n/* *****************************************************************************\nPer-CPU Arena management\n***************************************************************************** */\n\n/* returned a locked arena. Attempts the preffered arena first. */\nstatic inline arena_s *arena_lock(arena_s *preffered) {\n  if (!preffered)\n    preffered = arenas;\n  if (!fio_trylock(&preffered->lock))\n    return preffered;\n  do {\n    arena_s *arena = preffered;\n    for (size_t i = (size_t)(arena - arenas); i < memory.cores; ++i) {\n      if ((preffered == arenas || arena != preffered) &&\n          !fio_trylock(&arena->lock))\n        return arena;\n      ++arena;\n    }\n    if (preffered == arenas)\n      fio_reschedule_thread();\n    preffered = arenas;\n  } while (1);\n}\n\nstatic __thread arena_s *arena_last_used;\n\nstatic void arena_enter(void) { arena_last_used = arena_lock(arena_last_used); }\n\nstatic inline void arena_exit(void) { fio_unlock(&arena_last_used->lock); }\n\n/** Clears any memory locks, in case of a system call to `fork`. */\nvoid fio_malloc_after_fork(void) {\n  arena_last_used = NULL;\n  if (!arenas) {\n    return;\n  }\n  memory.lock = FIO_LOCK_INIT;\n  memory.forked = 1;\n  for (size_t i = 0; i < memory.cores; ++i) {\n    arenas[i].lock = FIO_LOCK_INIT;\n  }\n}\n\n/* *****************************************************************************\nBlock management / allocation\n***************************************************************************** */\n\nstatic inline void block_init_root(block_s *blk, block_s *parent) {\n  *blk = (block_s){\n      .parent = parent,\n      .ref = 1,\n      .pos = FIO_MEMORY_BLOCK_START_POS,\n      .root_ref = 1,\n  };\n}\n\n/* intializes the block header for an available block of memory. */\nstatic inline void block_init(block_s *blk) {\n  /* initialization shouldn't effect `parent` or `root_ref`*/\n  blk->ref = 1;\n  blk->pos = FIO_MEMORY_BLOCK_START_POS;\n  /* zero out linked list memory (everything else is already zero) */\n  ((block_node_s *)blk)->node.next = NULL;\n  ((block_node_s *)blk)->node.prev = NULL;\n  /* bump parent reference count */\n  fio_atomic_add(&blk->parent->root_ref, 1);\n}\n\n/* intializes the block header for an available block of memory. */\nstatic inline void block_free(block_s *blk) {\n  if (fio_atomic_sub(&blk->ref, 1))\n    return;\n\n  memset(blk + 1, 0, (FIO_MEMORY_BLOCK_SIZE - sizeof(*blk)));\n  fio_lock(&memory.lock);\n  fio_ls_embd_push(&memory.available, &((block_node_s *)blk)->node);\n\n  blk = blk->parent;\n\n  if (fio_atomic_sub(&blk->root_ref, 1)) {\n    fio_unlock(&memory.lock);\n    return;\n  }\n  // fio_unlock(&memory.lock);\n  // return;\n\n  /* remove all of the root block's children (slices) from the memory pool */\n  for (size_t i = 0; i < FIO_MEMORY_BLOCKS_PER_ALLOCATION; ++i) {\n    block_node_s *pos =\n        (block_node_s *)((uintptr_t)blk + (i * FIO_MEMORY_BLOCK_SIZE));\n    fio_ls_embd_remove(&pos->node);\n  }\n\n  fio_unlock(&memory.lock);\n  sys_free(blk, FIO_MEMORY_BLOCK_SIZE * FIO_MEMORY_BLOCKS_PER_ALLOCATION);\n  FIO_LOG_DEBUG(\"memory allocator returned %p to the system\", (void *)blk);\n  FIO_MEMORY_ON_BLOCK_FREE();\n}\n\n/* intializes the block header for an available block of memory. */\nstatic inline block_s *block_new(void) {\n  block_s *blk = NULL;\n\n  fio_lock(&memory.lock);\n  blk = (block_s *)fio_ls_embd_pop(&memory.available);\n  if (blk) {\n    blk = (block_s *)FIO_LS_EMBD_OBJ(block_node_s, node, blk);\n    FIO_ASSERT(((uintptr_t)blk & FIO_MEMORY_BLOCK_MASK) == 0,\n               \"Memory allocator error! double `fio_free`?\\n\");\n    block_init(blk); /* must be performed within lock */\n    fio_unlock(&memory.lock);\n    return blk;\n  }\n  /* collect memory from the system */\n  blk = sys_alloc(FIO_MEMORY_BLOCK_SIZE * FIO_MEMORY_BLOCKS_PER_ALLOCATION, 0);\n  if (!blk) {\n    fio_unlock(&memory.lock);\n    return NULL;\n  }\n  FIO_LOG_DEBUG(\"memory allocator allocated %p from the system\", (void *)blk);\n  FIO_MEMORY_ON_BLOCK_ALLOC();\n  block_init_root(blk, blk);\n  /* the extra memory goes into the memory pool. initialize + linke-list. */\n  block_node_s *tmp = (block_node_s *)blk;\n  for (int i = 1; i < FIO_MEMORY_BLOCKS_PER_ALLOCATION; ++i) {\n    tmp = (block_node_s *)((uintptr_t)tmp + FIO_MEMORY_BLOCK_SIZE);\n    block_init_root((block_s *)tmp, blk);\n    fio_ls_embd_push(&memory.available, &tmp->node);\n  }\n  fio_unlock(&memory.lock);\n  /* return the root block (which isn't in the memory pool). */\n  return blk;\n}\n\n/* allocates memory from within a block - called within an arena's lock */\nstatic inline void *block_slice(uint16_t units) {\n  block_s *blk = arena_last_used->block;\n  if (!blk) {\n    /* arena is empty */\n    blk = block_new();\n    arena_last_used->block = blk;\n  } else if (blk->pos + units > FIO_MEMORY_MAX_SLICES_PER_BLOCK) {\n    /* not enough memory in the block - rotate */\n    block_free(blk);\n    blk = block_new();\n    arena_last_used->block = blk;\n  }\n  if (!blk) {\n    /* no system memory available? */\n    errno = ENOMEM;\n    return NULL;\n  }\n  /* slice block starting at blk->pos and increase reference count */\n  const void *mem = (void *)((uintptr_t)blk + ((uintptr_t)blk->pos << 4));\n  fio_atomic_add(&blk->ref, 1);\n  blk->pos += units;\n  if (blk->pos >= FIO_MEMORY_MAX_SLICES_PER_BLOCK) {\n    /* ... the block was fully utilized, clear arena */\n    block_free(blk);\n    arena_last_used->block = NULL;\n  }\n  return (void *)mem;\n}\n\n/* handle's a bock's reference count - called without a lock */\nstatic inline void block_slice_free(void *mem) {\n  /* locate block boundary */\n  block_s *blk = (block_s *)((uintptr_t)mem & (~FIO_MEMORY_BLOCK_MASK));\n  block_free(blk);\n}\n\n/* *****************************************************************************\nNon-Block allocations (direct from the system)\n***************************************************************************** */\n\n/* allocates directly from the system adding size header - no lock required. */\nstatic inline void *big_alloc(size_t size) {\n  size = sys_round_size(size + 16);\n  size_t *mem = sys_alloc(size, 1);\n  if (!mem)\n    goto error;\n  *mem = size;\n  return (void *)(((uintptr_t)mem) + 16);\nerror:\n  return NULL;\n}\n\n/* reads size header and frees memory back to the system */\nstatic inline void big_free(void *ptr) {\n  size_t *mem = (void *)(((uintptr_t)ptr) - 16);\n  sys_free(mem, *mem);\n}\n\n/* reallocates memory using the system, resetting the size header */\nstatic inline void *big_realloc(void *ptr, size_t new_size) {\n  size_t *mem = (void *)(((uintptr_t)ptr) - 16);\n  new_size = sys_round_size(new_size + 16);\n  mem = sys_realloc(mem, *mem, new_size);\n  if (!mem)\n    goto error;\n  *mem = new_size;\n  return (void *)(((uintptr_t)mem) + 16);\nerror:\n  return NULL;\n}\n\n/* *****************************************************************************\nAllocator Initialization (initialize arenas and allocate a block for each CPU)\n***************************************************************************** */\n\n#if DEBUG\nvoid fio_memory_dump_missing(void) {\n  fprintf(stderr, \"\\n ==== Attempting Memory Dump (will crash) ====\\n\");\n  if (fio_ls_embd_is_empty(&memory.available)) {\n    fprintf(stderr, \"- Memory dump attempt canceled\\n\");\n    return;\n  }\n  block_node_s *smallest =\n      FIO_LS_EMBD_OBJ(block_node_s, node, memory.available.next);\n  FIO_LS_EMBD_FOR(&memory.available, node) {\n    block_node_s *tmp = FIO_LS_EMBD_OBJ(block_node_s, node, node);\n    if (smallest > tmp)\n      smallest = tmp;\n  }\n\n  for (size_t i = 0;\n       i < FIO_MEMORY_BLOCK_SIZE * FIO_MEMORY_BLOCKS_PER_ALLOCATION; ++i) {\n    if ((((uintptr_t)smallest + i) & FIO_MEMORY_BLOCK_MASK) == 0) {\n      i += 32;\n      fprintf(stderr, \"---block jump---\\n\");\n      continue;\n    }\n    if (((char *)smallest)[i])\n      fprintf(stderr, \"%c\", ((char *)smallest)[i]);\n  }\n}\n#else\n#define fio_memory_dump_missing()\n#endif\n\nstatic void fio_mem_init(void) {\n  if (arenas)\n    return;\n\n  ssize_t cpu_count = 0;\n#ifdef _SC_NPROCESSORS_ONLN\n  cpu_count = sysconf(_SC_NPROCESSORS_ONLN);\n#else\n#warning Dynamic CPU core count is unavailable - assuming 8 cores for memory allocation pools.\n#endif\n  if (cpu_count <= 0)\n    cpu_count = 8;\n  memory.cores = cpu_count;\n  arenas = big_alloc(sizeof(*arenas) * cpu_count);\n  FIO_ASSERT_ALLOC(arenas);\n  block_free(block_new());\n  pthread_atfork(NULL, NULL, fio_malloc_after_fork);\n}\n\nstatic void fio_mem_destroy(void) {\n  if (!arenas)\n    return;\n\n  FIO_MEMORY_PRINT_BLOCK_STAT();\n\n  for (size_t i = 0; i < memory.cores; ++i) {\n    if (arenas[i].block)\n      block_free(arenas[i].block);\n    arenas[i].block = NULL;\n  }\n  if (!memory.forked && fio_ls_embd_any(&memory.available)) {\n    FIO_LOG_WARNING(\"facil.io detected memory traces remaining after cleanup\"\n                    \" - memory leak?\");\n    FIO_MEMORY_PRINT_BLOCK_STAT_END();\n    size_t count = 0;\n    FIO_LS_EMBD_FOR(&memory.available, node) { ++count; }\n    FIO_LOG_DEBUG(\"Memory blocks in pool: %zu (%zu blocks per allocation).\",\n                  count, (size_t)FIO_MEMORY_BLOCKS_PER_ALLOCATION);\n#if FIO_MEM_DUMP\n    fio_memory_dump_missing();\n#endif\n  }\n  big_free(arenas);\n  arenas = NULL;\n}\n/* *****************************************************************************\nMemory allocation / deacclocation API\n***************************************************************************** */\n\nvoid *fio_malloc(size_t size) {\n#if FIO_OVERRIDE_MALLOC\n  if (!arenas)\n    fio_mem_init();\n#endif\n  if (!size) {\n    /* changed behavior prevents \"allocation failed\" test for `malloc(0)` */\n    return (void *)(&on_malloc_zero);\n  }\n  if (size >= FIO_MEMORY_BLOCK_ALLOC_LIMIT) {\n    /* system allocation - must be block aligned */\n    // FIO_LOG_WARNING(\"fio_malloc re-routed to mmap - big allocation\");\n    return big_alloc(size);\n  }\n  /* ceiling for 16 byte alignement, translated to 16 byte units */\n  size = (size >> 4) + (!!(size & 15));\n  arena_enter();\n  void *mem = block_slice(size);\n  arena_exit();\n  return mem;\n}\n\nvoid *fio_calloc(size_t size, size_t count) {\n  return fio_malloc(size * count); // memory is pre-initialized by mmap or pool.\n}\n\nvoid fio_free(void *ptr) {\n  if (!ptr || ptr == (void *)&on_malloc_zero)\n    return;\n  if (((uintptr_t)ptr & FIO_MEMORY_BLOCK_MASK) == 16) {\n    /* big allocation - direct from the system */\n    big_free(ptr);\n    return;\n  }\n  /* allocated within block */\n  block_slice_free(ptr);\n}\n\n/**\n * Re-allocates memory. An attept to avoid copying the data is made only for big\n * memory allocations.\n *\n * This variation is slightly faster as it might copy less data\n */\nvoid *fio_realloc2(void *ptr, size_t new_size, size_t copy_length) {\n  if (!ptr || ptr == (void *)&on_malloc_zero) {\n    return fio_malloc(new_size);\n  }\n  if (!new_size) {\n    goto zero_size;\n  }\n  if (((uintptr_t)ptr & FIO_MEMORY_BLOCK_MASK) == 16) {\n    /* big reallocation - direct from the system */\n    return big_realloc(ptr, new_size);\n  }\n  /* allocated within block - don't even try to expand the allocation */\n  /* ceiling for 16 byte alignement, translated to 16 byte units */\n  void *new_mem = fio_malloc(new_size);\n  if (!new_mem)\n    return NULL;\n  new_size = ((new_size >> 4) + (!!(new_size & 15)));\n  copy_length = ((copy_length >> 4) + (!!(copy_length & 15)));\n  fio_memcpy(new_mem, ptr, copy_length > new_size ? new_size : copy_length);\n\n  block_slice_free(ptr);\n  return new_mem;\nzero_size:\n  fio_free(ptr);\n  return fio_malloc(0);\n}\n\nvoid *fio_realloc(void *ptr, size_t new_size) {\n  const size_t max_old =\n      FIO_MEMORY_BLOCK_SIZE - ((uintptr_t)ptr & FIO_MEMORY_BLOCK_MASK);\n  return fio_realloc2(ptr, new_size, max_old);\n}\n\n/**\n * Allocates memory directly using `mmap`, this is prefered for larger objects\n * that have a long lifetime.\n *\n * `fio_free` can be used for deallocating the memory.\n */\nvoid *fio_mmap(size_t size) {\n  if (!size) {\n    return NULL;\n  }\n  return big_alloc(size);\n}\n\n/* *****************************************************************************\nFIO_OVERRIDE_MALLOC - override glibc / library malloc\n***************************************************************************** */\n#if FIO_OVERRIDE_MALLOC\nvoid *malloc(size_t size) { return fio_malloc(size); }\nvoid *calloc(size_t size, size_t count) { return fio_calloc(size, count); }\nvoid free(void *ptr) { fio_free(ptr); }\nvoid *realloc(void *ptr, size_t new_size) { return fio_realloc(ptr, new_size); }\n#endif\n\n#endif\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n                      Random Generator Functions\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/* tested for randomness using code from: http://xoshiro.di.unimi.it/hwd.php */\nuint64_t fio_rand64(void) {\n  /* modeled after xoroshiro128+, by David Blackman and Sebastiano Vigna */\n  static __thread uint64_t s[2]; /* random state */\n  static __thread uint16_t c;    /* seed counter */\n  const uint64_t P[] = {0x37701261ED6C16C7ULL, 0x764DBBB75F3B3E0DULL};\n  if (c++ == 0) {\n    /* re-seed state every 65,536 requests */\n#ifdef RUSAGE_SELF\n    struct rusage rusage;\n    getrusage(RUSAGE_SELF, &rusage);\n    s[0] = fio_risky_hash(&rusage, sizeof(rusage), s[0]);\n    s[1] = fio_risky_hash(&rusage, sizeof(rusage), s[0]);\n#else\n    struct timespec clk;\n    clock_gettime(CLOCK_REALTIME, &clk);\n    s[0] = fio_risky_hash(&clk, sizeof(clk), s[0]);\n    s[1] = fio_risky_hash(&clk, sizeof(clk), s[0]);\n#endif\n  }\n  s[0] += fio_lrot64(s[0], 33) * P[0];\n  s[1] += fio_lrot64(s[1], 33) * P[1];\n  return fio_lrot64(s[0], 31) + fio_lrot64(s[1], 29);\n}\n\n/* copies 64 bits of randomness (8 bytes) repeatedly... */\nvoid fio_rand_bytes(void *data_, size_t len) {\n  if (!data_ || !len)\n    return;\n  uint8_t *data = data_;\n  /* unroll 32 bytes / 256 bit writes */\n  for (size_t i = (len >> 5); i; --i) {\n    const uint64_t t0 = fio_rand64();\n    const uint64_t t1 = fio_rand64();\n    const uint64_t t2 = fio_rand64();\n    const uint64_t t3 = fio_rand64();\n    fio_u2str64(data, t0);\n    fio_u2str64(data + 8, t1);\n    fio_u2str64(data + 16, t2);\n    fio_u2str64(data + 24, t3);\n    data += 32;\n  }\n  uint64_t tmp;\n  /* 64 bit steps  */\n  switch (len & 24) {\n  case 24:\n    tmp = fio_rand64();\n    fio_u2str64(data + 16, tmp);\n    /* fallthrough */\n  case 16:\n    tmp = fio_rand64();\n    fio_u2str64(data + 8, tmp);\n    /* fallthrough */\n  case 8:\n    tmp = fio_rand64();\n    fio_u2str64(data, tmp);\n    data += len & 24;\n  }\n  if ((len & 7)) {\n    tmp = fio_rand64();\n    /* leftover bytes */\n    switch ((len & 7)) {\n    case 7:\n      data[6] = (tmp >> 8) & 0xFF;\n      /* fallthrough */\n    case 6:\n      data[5] = (tmp >> 16) & 0xFF;\n      /* fallthrough */\n    case 5:\n      data[4] = (tmp >> 24) & 0xFF;\n      /* fallthrough */\n    case 4:\n      data[3] = (tmp >> 32) & 0xFF;\n      /* fallthrough */\n    case 3:\n      data[2] = (tmp >> 40) & 0xFF;\n      /* fallthrough */\n    case 2:\n      data[1] = (tmp >> 48) & 0xFF;\n      /* fallthrough */\n    case 1:\n      data[0] = (tmp >> 56) & 0xFF;\n    }\n  }\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n                             Hash Functions and Base64\n\n                  SipHash / SHA-1 / SHA-2 / Base64 / Hex encoding\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/* *****************************************************************************\nSipHash\n***************************************************************************** */\n\n#if __BIG_ENDIAN__ /* SipHash is Little Endian */\n#define sip_local64(i) fio_bswap64((i))\n#else\n#define sip_local64(i) (i)\n#endif\n\nstatic inline uint64_t fio_siphash_xy(const void *data, size_t len, size_t x,\n                                      size_t y, uint64_t key1, uint64_t key2) {\n  /* initialize the 4 words */\n  uint64_t v0 = (0x0706050403020100ULL ^ 0x736f6d6570736575ULL) ^ key1;\n  uint64_t v1 = (0x0f0e0d0c0b0a0908ULL ^ 0x646f72616e646f6dULL) ^ key2;\n  uint64_t v2 = (0x0706050403020100ULL ^ 0x6c7967656e657261ULL) ^ key1;\n  uint64_t v3 = (0x0f0e0d0c0b0a0908ULL ^ 0x7465646279746573ULL) ^ key2;\n  const uint8_t *w8 = data;\n  uint8_t len_mod = len & 255;\n  union {\n    uint64_t i;\n    uint8_t str[8];\n  } word;\n\n#define hash_map_SipRound                                                      \\\n  do {                                                                         \\\n    v2 += v3;                                                                  \\\n    v3 = fio_lrot64(v3, 16) ^ v2;                                              \\\n    v0 += v1;                                                                  \\\n    v1 = fio_lrot64(v1, 13) ^ v0;                                              \\\n    v0 = fio_lrot64(v0, 32);                                                   \\\n    v2 += v1;                                                                  \\\n    v0 += v3;                                                                  \\\n    v1 = fio_lrot64(v1, 17) ^ v2;                                              \\\n    v3 = fio_lrot64(v3, 21) ^ v0;                                              \\\n    v2 = fio_lrot64(v2, 32);                                                   \\\n  } while (0);\n\n  while (len >= 8) {\n    word.i = sip_local64(fio_str2u64(w8));\n    v3 ^= word.i;\n    /* Sip Rounds */\n    for (size_t i = 0; i < x; ++i) {\n      hash_map_SipRound;\n    }\n    v0 ^= word.i;\n    w8 += 8;\n    len -= 8;\n  }\n  word.i = 0;\n  uint8_t *pos = word.str;\n  switch (len) { /* fallthrough is intentional */\n  case 7:\n    pos[6] = w8[6];\n    /* fallthrough */\n  case 6:\n    pos[5] = w8[5];\n    /* fallthrough */\n  case 5:\n    pos[4] = w8[4];\n    /* fallthrough */\n  case 4:\n    pos[3] = w8[3];\n    /* fallthrough */\n  case 3:\n    pos[2] = w8[2];\n    /* fallthrough */\n  case 2:\n    pos[1] = w8[1];\n    /* fallthrough */\n  case 1:\n    pos[0] = w8[0];\n  }\n  word.str[7] = len_mod;\n\n  /* last round */\n  v3 ^= word.i;\n  hash_map_SipRound;\n  hash_map_SipRound;\n  v0 ^= word.i;\n  /* Finalization */\n  v2 ^= 0xff;\n  /* d iterations of SipRound */\n  for (size_t i = 0; i < y; ++i) {\n    hash_map_SipRound;\n  }\n  hash_map_SipRound;\n  hash_map_SipRound;\n  hash_map_SipRound;\n  hash_map_SipRound;\n  /* XOR it all together */\n  v0 ^= v1 ^ v2 ^ v3;\n#undef hash_map_SipRound\n  return v0;\n}\n\nuint64_t fio_siphash24(const void *data, size_t len, uint64_t key1,\n                       uint64_t key2) {\n  return fio_siphash_xy(data, len, 2, 4, key1, key2);\n}\n\nuint64_t fio_siphash13(const void *data, size_t len, uint64_t key1,\n                       uint64_t key2) {\n  return fio_siphash_xy(data, len, 1, 3, key1, key2);\n}\n\n/* *****************************************************************************\nSHA-1\n***************************************************************************** */\n\nstatic const uint8_t sha1_padding[64] = {0x80, 0};\n\n/**\nProcess the buffer once full.\n*/\nstatic inline void fio_sha1_perform_all_rounds(fio_sha1_s *s,\n                                               const uint8_t *buffer) {\n  /* collect data */\n  uint32_t a = s->digest.i[0];\n  uint32_t b = s->digest.i[1];\n  uint32_t c = s->digest.i[2];\n  uint32_t d = s->digest.i[3];\n  uint32_t e = s->digest.i[4];\n  uint32_t t, w[16];\n  /* copy data to words, performing byte swapping as needed */\n  w[0] = fio_str2u32(buffer);\n  w[1] = fio_str2u32(buffer + 4);\n  w[2] = fio_str2u32(buffer + 8);\n  w[3] = fio_str2u32(buffer + 12);\n  w[4] = fio_str2u32(buffer + 16);\n  w[5] = fio_str2u32(buffer + 20);\n  w[6] = fio_str2u32(buffer + 24);\n  w[7] = fio_str2u32(buffer + 28);\n  w[8] = fio_str2u32(buffer + 32);\n  w[9] = fio_str2u32(buffer + 36);\n  w[10] = fio_str2u32(buffer + 40);\n  w[11] = fio_str2u32(buffer + 44);\n  w[12] = fio_str2u32(buffer + 48);\n  w[13] = fio_str2u32(buffer + 52);\n  w[14] = fio_str2u32(buffer + 56);\n  w[15] = fio_str2u32(buffer + 60);\n  /* perform rounds */\n#undef perform_single_round\n#define perform_single_round(num)                                              \\\n  t = fio_lrot32(a, 5) + e + w[num] + ((b & c) | ((~b) & d)) + 0x5A827999;     \\\n  e = d;                                                                       \\\n  d = c;                                                                       \\\n  c = fio_lrot32(b, 30);                                                       \\\n  b = a;                                                                       \\\n  a = t;\n\n#define perform_four_rounds(i)                                                 \\\n  perform_single_round(i);                                                     \\\n  perform_single_round(i + 1);                                                 \\\n  perform_single_round(i + 2);                                                 \\\n  perform_single_round(i + 3);\n\n  perform_four_rounds(0);\n  perform_four_rounds(4);\n  perform_four_rounds(8);\n  perform_four_rounds(12);\n\n#undef perform_single_round\n#define perform_single_round(i)                                                \\\n  w[(i)&15] = fio_lrot32((w[(i - 3) & 15] ^ w[(i - 8) & 15] ^                  \\\n                          w[(i - 14) & 15] ^ w[(i - 16) & 15]),                \\\n                         1);                                                   \\\n  t = fio_lrot32(a, 5) + e + w[(i)&15] + ((b & c) | ((~b) & d)) + 0x5A827999;  \\\n  e = d;                                                                       \\\n  d = c;                                                                       \\\n  c = fio_lrot32(b, 30);                                                       \\\n  b = a;                                                                       \\\n  a = t;\n\n  perform_four_rounds(16);\n\n#undef perform_single_round\n#define perform_single_round(i)                                                \\\n  w[(i)&15] = fio_lrot32((w[(i - 3) & 15] ^ w[(i - 8) & 15] ^                  \\\n                          w[(i - 14) & 15] ^ w[(i - 16) & 15]),                \\\n                         1);                                                   \\\n  t = fio_lrot32(a, 5) + e + w[(i)&15] + (b ^ c ^ d) + 0x6ED9EBA1;             \\\n  e = d;                                                                       \\\n  d = c;                                                                       \\\n  c = fio_lrot32(b, 30);                                                       \\\n  b = a;                                                                       \\\n  a = t;\n\n  perform_four_rounds(20);\n  perform_four_rounds(24);\n  perform_four_rounds(28);\n  perform_four_rounds(32);\n  perform_four_rounds(36);\n\n#undef perform_single_round\n#define perform_single_round(i)                                                \\\n  w[(i)&15] = fio_lrot32((w[(i - 3) & 15] ^ w[(i - 8) & 15] ^                  \\\n                          w[(i - 14) & 15] ^ w[(i - 16) & 15]),                \\\n                         1);                                                   \\\n  t = fio_lrot32(a, 5) + e + w[(i)&15] + ((b & (c | d)) | (c & d)) +           \\\n      0x8F1BBCDC;                                                              \\\n  e = d;                                                                       \\\n  d = c;                                                                       \\\n  c = fio_lrot32(b, 30);                                                       \\\n  b = a;                                                                       \\\n  a = t;\n\n  perform_four_rounds(40);\n  perform_four_rounds(44);\n  perform_four_rounds(48);\n  perform_four_rounds(52);\n  perform_four_rounds(56);\n#undef perform_single_round\n#define perform_single_round(i)                                                \\\n  w[(i)&15] = fio_lrot32((w[(i - 3) & 15] ^ w[(i - 8) & 15] ^                  \\\n                          w[(i - 14) & 15] ^ w[(i - 16) & 15]),                \\\n                         1);                                                   \\\n  t = fio_lrot32(a, 5) + e + w[(i)&15] + (b ^ c ^ d) + 0xCA62C1D6;             \\\n  e = d;                                                                       \\\n  d = c;                                                                       \\\n  c = fio_lrot32(b, 30);                                                       \\\n  b = a;                                                                       \\\n  a = t;\n  perform_four_rounds(60);\n  perform_four_rounds(64);\n  perform_four_rounds(68);\n  perform_four_rounds(72);\n  perform_four_rounds(76);\n\n  /* store data */\n  s->digest.i[4] += e;\n  s->digest.i[3] += d;\n  s->digest.i[2] += c;\n  s->digest.i[1] += b;\n  s->digest.i[0] += a;\n}\n\n/**\nInitialize or reset the `sha1` object. This must be performed before hashing\ndata using sha1.\n*/\nfio_sha1_s fio_sha1_init(void) {\n  return (fio_sha1_s){.digest.i[0] = 0x67452301,\n                      .digest.i[1] = 0xefcdab89,\n                      .digest.i[2] = 0x98badcfe,\n                      .digest.i[3] = 0x10325476,\n                      .digest.i[4] = 0xc3d2e1f0};\n}\n\n/**\nWrites data to the sha1 buffer.\n*/\nvoid fio_sha1_write(fio_sha1_s *s, const void *data, size_t len) {\n  size_t in_buffer = s->length & 63;\n  size_t partial = 64 - in_buffer;\n  s->length += len;\n  if (partial > len) {\n    memcpy(s->buffer + in_buffer, data, len);\n    return;\n  }\n  if (in_buffer) {\n    memcpy(s->buffer + in_buffer, data, partial);\n    len -= partial;\n    data = (void *)((uintptr_t)data + partial);\n    fio_sha1_perform_all_rounds(s, s->buffer);\n  }\n  while (len >= 64) {\n    fio_sha1_perform_all_rounds(s, data);\n    data = (void *)((uintptr_t)data + 64);\n    len -= 64;\n  }\n  if (len) {\n    memcpy(s->buffer + in_buffer, data, len);\n  }\n  return;\n}\n\nchar *fio_sha1_result(fio_sha1_s *s) {\n  size_t in_buffer = s->length & 63;\n  if (in_buffer > 55) {\n    memcpy(s->buffer + in_buffer, sha1_padding, 64 - in_buffer);\n    fio_sha1_perform_all_rounds(s, s->buffer);\n    memcpy(s->buffer, sha1_padding + 1, 56);\n  } else if (in_buffer != 55) {\n    memcpy(s->buffer + in_buffer, sha1_padding, 56 - in_buffer);\n  } else {\n    s->buffer[55] = sha1_padding[0];\n  }\n  /* store the length in BITS - alignment should be promised by struct */\n  /* this must the number in BITS, encoded as a BIG ENDIAN 64 bit number */\n  uint64_t *len = (uint64_t *)(s->buffer + 56);\n  *len = s->length << 3;\n  *len = fio_lton64(*len);\n  fio_sha1_perform_all_rounds(s, s->buffer);\n\n  /* change back to little endian */\n  s->digest.i[0] = fio_ntol32(s->digest.i[0]);\n  s->digest.i[1] = fio_ntol32(s->digest.i[1]);\n  s->digest.i[2] = fio_ntol32(s->digest.i[2]);\n  s->digest.i[3] = fio_ntol32(s->digest.i[3]);\n  s->digest.i[4] = fio_ntol32(s->digest.i[4]);\n\n  return (char *)s->digest.str;\n}\n\n#undef perform_single_round\n\n/* *****************************************************************************\nSHA-2\n***************************************************************************** */\n\nstatic const uint8_t sha2_padding[128] = {0x80, 0};\n\n/* SHA-224 and SHA-256 constants */\nstatic uint32_t sha2_256_words[] = {\n    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1,\n    0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n    0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786,\n    0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n    0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,\n    0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n    0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b,\n    0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n    0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a,\n    0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2};\n\n/* SHA-512 and friends constants */\nstatic uint64_t sha2_512_words[] = {\n    0x428a2f98d728ae22, 0x7137449123ef65cd, 0xb5c0fbcfec4d3b2f,\n    0xe9b5dba58189dbbc, 0x3956c25bf348b538, 0x59f111f1b605d019,\n    0x923f82a4af194f9b, 0xab1c5ed5da6d8118, 0xd807aa98a3030242,\n    0x12835b0145706fbe, 0x243185be4ee4b28c, 0x550c7dc3d5ffb4e2,\n    0x72be5d74f27b896f, 0x80deb1fe3b1696b1, 0x9bdc06a725c71235,\n    0xc19bf174cf692694, 0xe49b69c19ef14ad2, 0xefbe4786384f25e3,\n    0x0fc19dc68b8cd5b5, 0x240ca1cc77ac9c65, 0x2de92c6f592b0275,\n    0x4a7484aa6ea6e483, 0x5cb0a9dcbd41fbd4, 0x76f988da831153b5,\n    0x983e5152ee66dfab, 0xa831c66d2db43210, 0xb00327c898fb213f,\n    0xbf597fc7beef0ee4, 0xc6e00bf33da88fc2, 0xd5a79147930aa725,\n    0x06ca6351e003826f, 0x142929670a0e6e70, 0x27b70a8546d22ffc,\n    0x2e1b21385c26c926, 0x4d2c6dfc5ac42aed, 0x53380d139d95b3df,\n    0x650a73548baf63de, 0x766a0abb3c77b2a8, 0x81c2c92e47edaee6,\n    0x92722c851482353b, 0xa2bfe8a14cf10364, 0xa81a664bbc423001,\n    0xc24b8b70d0f89791, 0xc76c51a30654be30, 0xd192e819d6ef5218,\n    0xd69906245565a910, 0xf40e35855771202a, 0x106aa07032bbd1b8,\n    0x19a4c116b8d2d0c8, 0x1e376c085141ab53, 0x2748774cdf8eeb99,\n    0x34b0bcb5e19b48a8, 0x391c0cb3c5c95a63, 0x4ed8aa4ae3418acb,\n    0x5b9cca4f7763e373, 0x682e6ff3d6b2b8a3, 0x748f82ee5defb2fc,\n    0x78a5636f43172f60, 0x84c87814a1f0ab72, 0x8cc702081a6439ec,\n    0x90befffa23631e28, 0xa4506cebde82bde9, 0xbef9a3f7b2c67915,\n    0xc67178f2e372532b, 0xca273eceea26619c, 0xd186b8c721c0c207,\n    0xeada7dd6cde0eb1e, 0xf57d4f7fee6ed178, 0x06f067aa72176fba,\n    0x0a637dc5a2c898a6, 0x113f9804bef90dae, 0x1b710b35131c471b,\n    0x28db77f523047d84, 0x32caab7b40c72493, 0x3c9ebe0a15c9bebc,\n    0x431d67c49c100d4c, 0x4cc5d4becb3e42b6, 0x597f299cfc657e2a,\n    0x5fcb6fab3ad6faec, 0x6c44198c4a475817};\n\n/* Specific Macros for the SHA-2 processing */\n\n#define Ch(x, y, z) (((x) & (y)) ^ ((~(x)) & z))\n#define Maj(x, y, z) (((x) & (y)) ^ ((x) & (z)) ^ ((y) & (z)))\n\n#define Eps0_32(x)                                                             \\\n  (fio_rrot32((x), 2) ^ fio_rrot32((x), 13) ^ fio_rrot32((x), 22))\n#define Eps1_32(x)                                                             \\\n  (fio_rrot32((x), 6) ^ fio_rrot32((x), 11) ^ fio_rrot32((x), 25))\n#define Omg0_32(x) (fio_rrot32((x), 7) ^ fio_rrot32((x), 18) ^ (((x) >> 3)))\n#define Omg1_32(x) (fio_rrot32((x), 17) ^ fio_rrot32((x), 19) ^ (((x) >> 10)))\n\n#define Eps0_64(x)                                                             \\\n  (fio_rrot64((x), 28) ^ fio_rrot64((x), 34) ^ fio_rrot64((x), 39))\n#define Eps1_64(x)                                                             \\\n  (fio_rrot64((x), 14) ^ fio_rrot64((x), 18) ^ fio_rrot64((x), 41))\n#define Omg0_64(x) (fio_rrot64((x), 1) ^ fio_rrot64((x), 8) ^ (((x) >> 7)))\n#define Omg1_64(x) (fio_rrot64((x), 19) ^ fio_rrot64((x), 61) ^ (((x) >> 6)))\n\n/**\nProcess the buffer once full.\n*/\nstatic inline void fio_sha2_perform_all_rounds(fio_sha2_s *s,\n                                               const uint8_t *data) {\n  if (s->type & 1) { /* 512 derived type */\n    // process values for the 64bit words\n    uint64_t a = s->digest.i64[0];\n    uint64_t b = s->digest.i64[1];\n    uint64_t c = s->digest.i64[2];\n    uint64_t d = s->digest.i64[3];\n    uint64_t e = s->digest.i64[4];\n    uint64_t f = s->digest.i64[5];\n    uint64_t g = s->digest.i64[6];\n    uint64_t h = s->digest.i64[7];\n    uint64_t t1, t2, w[80];\n    w[0] = fio_str2u64(data);\n    w[1] = fio_str2u64(data + 8);\n    w[2] = fio_str2u64(data + 16);\n    w[3] = fio_str2u64(data + 24);\n    w[4] = fio_str2u64(data + 32);\n    w[5] = fio_str2u64(data + 40);\n    w[6] = fio_str2u64(data + 48);\n    w[7] = fio_str2u64(data + 56);\n    w[8] = fio_str2u64(data + 64);\n    w[9] = fio_str2u64(data + 72);\n    w[10] = fio_str2u64(data + 80);\n    w[11] = fio_str2u64(data + 88);\n    w[12] = fio_str2u64(data + 96);\n    w[13] = fio_str2u64(data + 104);\n    w[14] = fio_str2u64(data + 112);\n    w[15] = fio_str2u64(data + 120);\n\n#undef perform_single_round\n#define perform_single_round(i)                                                \\\n  t1 = h + Eps1_64(e) + Ch(e, f, g) + sha2_512_words[i] + w[i];                \\\n  t2 = Eps0_64(a) + Maj(a, b, c);                                              \\\n  h = g;                                                                       \\\n  g = f;                                                                       \\\n  f = e;                                                                       \\\n  e = d + t1;                                                                  \\\n  d = c;                                                                       \\\n  c = b;                                                                       \\\n  b = a;                                                                       \\\n  a = t1 + t2;\n\n#define perform_4rounds(i)                                                     \\\n  perform_single_round(i);                                                     \\\n  perform_single_round(i + 1);                                                 \\\n  perform_single_round(i + 2);                                                 \\\n  perform_single_round(i + 3);\n\n    perform_4rounds(0);\n    perform_4rounds(4);\n    perform_4rounds(8);\n    perform_4rounds(12);\n\n#undef perform_single_round\n#define perform_single_round(i)                                                \\\n  w[i] = Omg1_64(w[i - 2]) + w[i - 7] + Omg0_64(w[i - 15]) + w[i - 16];        \\\n  t1 = h + Eps1_64(e) + Ch(e, f, g) + sha2_512_words[i] + w[i];                \\\n  t2 = Eps0_64(a) + Maj(a, b, c);                                              \\\n  h = g;                                                                       \\\n  g = f;                                                                       \\\n  f = e;                                                                       \\\n  e = d + t1;                                                                  \\\n  d = c;                                                                       \\\n  c = b;                                                                       \\\n  b = a;                                                                       \\\n  a = t1 + t2;\n\n    perform_4rounds(16);\n    perform_4rounds(20);\n    perform_4rounds(24);\n    perform_4rounds(28);\n    perform_4rounds(32);\n    perform_4rounds(36);\n    perform_4rounds(40);\n    perform_4rounds(44);\n    perform_4rounds(48);\n    perform_4rounds(52);\n    perform_4rounds(56);\n    perform_4rounds(60);\n    perform_4rounds(64);\n    perform_4rounds(68);\n    perform_4rounds(72);\n    perform_4rounds(76);\n\n    s->digest.i64[0] += a;\n    s->digest.i64[1] += b;\n    s->digest.i64[2] += c;\n    s->digest.i64[3] += d;\n    s->digest.i64[4] += e;\n    s->digest.i64[5] += f;\n    s->digest.i64[6] += g;\n    s->digest.i64[7] += h;\n    return;\n  } else {\n    // process values for the 32bit words\n    uint32_t a = s->digest.i32[0];\n    uint32_t b = s->digest.i32[1];\n    uint32_t c = s->digest.i32[2];\n    uint32_t d = s->digest.i32[3];\n    uint32_t e = s->digest.i32[4];\n    uint32_t f = s->digest.i32[5];\n    uint32_t g = s->digest.i32[6];\n    uint32_t h = s->digest.i32[7];\n    uint32_t t1, t2, w[64];\n\n    w[0] = fio_str2u32(data);\n    w[1] = fio_str2u32(data + 4);\n    w[2] = fio_str2u32(data + 8);\n    w[3] = fio_str2u32(data + 12);\n    w[4] = fio_str2u32(data + 16);\n    w[5] = fio_str2u32(data + 20);\n    w[6] = fio_str2u32(data + 24);\n    w[7] = fio_str2u32(data + 28);\n    w[8] = fio_str2u32(data + 32);\n    w[9] = fio_str2u32(data + 36);\n    w[10] = fio_str2u32(data + 40);\n    w[11] = fio_str2u32(data + 44);\n    w[12] = fio_str2u32(data + 48);\n    w[13] = fio_str2u32(data + 52);\n    w[14] = fio_str2u32(data + 56);\n    w[15] = fio_str2u32(data + 60);\n\n#undef perform_single_round\n#define perform_single_round(i)                                                \\\n  t1 = h + Eps1_32(e) + Ch(e, f, g) + sha2_256_words[i] + w[i];                \\\n  t2 = Eps0_32(a) + Maj(a, b, c);                                              \\\n  h = g;                                                                       \\\n  g = f;                                                                       \\\n  f = e;                                                                       \\\n  e = d + t1;                                                                  \\\n  d = c;                                                                       \\\n  c = b;                                                                       \\\n  b = a;                                                                       \\\n  a = t1 + t2;\n\n    perform_4rounds(0);\n    perform_4rounds(4);\n    perform_4rounds(8);\n    perform_4rounds(12);\n\n#undef perform_single_round\n#define perform_single_round(i)                                                \\\n  w[i] = Omg1_32(w[i - 2]) + w[i - 7] + Omg0_32(w[i - 15]) + w[i - 16];        \\\n  t1 = h + Eps1_32(e) + Ch(e, f, g) + sha2_256_words[i] + w[i];                \\\n  t2 = Eps0_32(a) + Maj(a, b, c);                                              \\\n  h = g;                                                                       \\\n  g = f;                                                                       \\\n  f = e;                                                                       \\\n  e = d + t1;                                                                  \\\n  d = c;                                                                       \\\n  c = b;                                                                       \\\n  b = a;                                                                       \\\n  a = t1 + t2;\n\n    perform_4rounds(16);\n    perform_4rounds(20);\n    perform_4rounds(24);\n    perform_4rounds(28);\n    perform_4rounds(32);\n    perform_4rounds(36);\n    perform_4rounds(40);\n    perform_4rounds(44);\n    perform_4rounds(48);\n    perform_4rounds(52);\n    perform_4rounds(56);\n    perform_4rounds(60);\n\n    s->digest.i32[0] += a;\n    s->digest.i32[1] += b;\n    s->digest.i32[2] += c;\n    s->digest.i32[3] += d;\n    s->digest.i32[4] += e;\n    s->digest.i32[5] += f;\n    s->digest.i32[6] += g;\n    s->digest.i32[7] += h;\n  }\n}\n\n/**\nInitialize/reset the SHA-2 object.\n\nSHA-2 is actually a family of functions with different variants. When\ninitializing the SHA-2 container, you must select the variant you intend to\napply. The following are valid options (see the fio_sha2_variant_e enum):\n\n- SHA_512 (== 0)\n- SHA_384\n- SHA_512_224\n- SHA_512_256\n- SHA_256\n- SHA_224\n\n*/\nfio_sha2_s fio_sha2_init(fio_sha2_variant_e variant) {\n  if (variant == SHA_256) {\n    return (fio_sha2_s){\n        .type = SHA_256,\n        .digest.i32[0] = 0x6a09e667,\n        .digest.i32[1] = 0xbb67ae85,\n        .digest.i32[2] = 0x3c6ef372,\n        .digest.i32[3] = 0xa54ff53a,\n        .digest.i32[4] = 0x510e527f,\n        .digest.i32[5] = 0x9b05688c,\n        .digest.i32[6] = 0x1f83d9ab,\n        .digest.i32[7] = 0x5be0cd19,\n    };\n  } else if (variant == SHA_384) {\n    return (fio_sha2_s){\n        .type = SHA_384,\n        .digest.i64[0] = 0xcbbb9d5dc1059ed8,\n        .digest.i64[1] = 0x629a292a367cd507,\n        .digest.i64[2] = 0x9159015a3070dd17,\n        .digest.i64[3] = 0x152fecd8f70e5939,\n        .digest.i64[4] = 0x67332667ffc00b31,\n        .digest.i64[5] = 0x8eb44a8768581511,\n        .digest.i64[6] = 0xdb0c2e0d64f98fa7,\n        .digest.i64[7] = 0x47b5481dbefa4fa4,\n    };\n  } else if (variant == SHA_512) {\n    return (fio_sha2_s){\n        .type = SHA_512,\n        .digest.i64[0] = 0x6a09e667f3bcc908,\n        .digest.i64[1] = 0xbb67ae8584caa73b,\n        .digest.i64[2] = 0x3c6ef372fe94f82b,\n        .digest.i64[3] = 0xa54ff53a5f1d36f1,\n        .digest.i64[4] = 0x510e527fade682d1,\n        .digest.i64[5] = 0x9b05688c2b3e6c1f,\n        .digest.i64[6] = 0x1f83d9abfb41bd6b,\n        .digest.i64[7] = 0x5be0cd19137e2179,\n    };\n  } else if (variant == SHA_224) {\n    return (fio_sha2_s){\n        .type = SHA_224,\n        .digest.i32[0] = 0xc1059ed8,\n        .digest.i32[1] = 0x367cd507,\n        .digest.i32[2] = 0x3070dd17,\n        .digest.i32[3] = 0xf70e5939,\n        .digest.i32[4] = 0xffc00b31,\n        .digest.i32[5] = 0x68581511,\n        .digest.i32[6] = 0x64f98fa7,\n        .digest.i32[7] = 0xbefa4fa4,\n    };\n  } else if (variant == SHA_512_224) {\n    return (fio_sha2_s){\n        .type = SHA_512_224,\n        .digest.i64[0] = 0x8c3d37c819544da2,\n        .digest.i64[1] = 0x73e1996689dcd4d6,\n        .digest.i64[2] = 0x1dfab7ae32ff9c82,\n        .digest.i64[3] = 0x679dd514582f9fcf,\n        .digest.i64[4] = 0x0f6d2b697bd44da8,\n        .digest.i64[5] = 0x77e36f7304c48942,\n        .digest.i64[6] = 0x3f9d85a86a1d36c8,\n        .digest.i64[7] = 0x1112e6ad91d692a1,\n    };\n  } else if (variant == SHA_512_256) {\n    return (fio_sha2_s){\n        .type = SHA_512_256,\n        .digest.i64[0] = 0x22312194fc2bf72c,\n        .digest.i64[1] = 0x9f555fa3c84c64c2,\n        .digest.i64[2] = 0x2393b86b6f53b151,\n        .digest.i64[3] = 0x963877195940eabd,\n        .digest.i64[4] = 0x96283ee2a88effe3,\n        .digest.i64[5] = 0xbe5e1e2553863992,\n        .digest.i64[6] = 0x2b0199fc2c85b8aa,\n        .digest.i64[7] = 0x0eb72ddc81c52ca2,\n    };\n  }\n  FIO_LOG_FATAL(\"SHA-2 ERROR - variant unknown\");\n  exit(2);\n}\n\n/**\nWrites data to the SHA-2 buffer.\n*/\nvoid fio_sha2_write(fio_sha2_s *s, const void *data, size_t len) {\n  size_t in_buffer;\n  size_t partial;\n  if (s->type & 1) { /* 512 type derived */\n    in_buffer = s->length.words[0] & 127;\n    if (s->length.words[0] + len < s->length.words[0]) {\n      /* we are at wraping around the 64bit limit */\n      s->length.words[1] = (s->length.words[1] << 1) | 1;\n    }\n    s->length.words[0] += len;\n    partial = 128 - in_buffer;\n\n    if (partial > len) {\n      memcpy(s->buffer + in_buffer, data, len);\n      return;\n    }\n    if (in_buffer) {\n      memcpy(s->buffer + in_buffer, data, partial);\n      len -= partial;\n      data = (void *)((uintptr_t)data + partial);\n      fio_sha2_perform_all_rounds(s, s->buffer);\n    }\n    while (len >= 128) {\n      fio_sha2_perform_all_rounds(s, data);\n      data = (void *)((uintptr_t)data + 128);\n      len -= 128;\n    }\n    if (len) {\n      memcpy(s->buffer + in_buffer, data, len);\n    }\n    return;\n  }\n  /* else... NOT 512 bits derived (64bit base) */\n\n  in_buffer = s->length.words[0] & 63;\n  partial = 64 - in_buffer;\n\n  s->length.words[0] += len;\n\n  if (partial > len) {\n    memcpy(s->buffer + in_buffer, data, len);\n    return;\n  }\n  if (in_buffer) {\n    memcpy(s->buffer + in_buffer, data, partial);\n    len -= partial;\n    data = (void *)((uintptr_t)data + partial);\n    fio_sha2_perform_all_rounds(s, s->buffer);\n  }\n  while (len >= 64) {\n    fio_sha2_perform_all_rounds(s, data);\n    data = (void *)((uintptr_t)data + 64);\n    len -= 64;\n  }\n  if (len) {\n    memcpy(s->buffer + in_buffer, data, len);\n  }\n  return;\n}\n\n/**\nFinalizes the SHA-2 hash, returning the Hashed data.\n\n`sha2_result` can be called for the same object multiple times, but the\nfinalization will only be performed the first time this function is called.\n*/\nchar *fio_sha2_result(fio_sha2_s *s) {\n  if (s->type & 1) {\n    /* 512 bits derived hashing */\n\n    size_t in_buffer = s->length.words[0] & 127;\n\n    if (in_buffer > 111) {\n      memcpy(s->buffer + in_buffer, sha2_padding, 128 - in_buffer);\n      fio_sha2_perform_all_rounds(s, s->buffer);\n      memcpy(s->buffer, sha2_padding + 1, 112);\n    } else if (in_buffer != 111) {\n      memcpy(s->buffer + in_buffer, sha2_padding, 112 - in_buffer);\n    } else {\n      s->buffer[111] = sha2_padding[0];\n    }\n    /* store the length in BITS - alignment should be promised by struct */\n    /* this must the number in BITS, encoded as a BIG ENDIAN 64 bit number */\n\n    s->length.words[1] = (s->length.words[1] << 3) | (s->length.words[0] >> 61);\n    s->length.words[0] = s->length.words[0] << 3;\n    s->length.words[0] = fio_lton64(s->length.words[0]);\n    s->length.words[1] = fio_lton64(s->length.words[1]);\n\n#if !__BIG_ENDIAN__\n    {\n      uint_fast64_t tmp = s->length.words[0];\n      s->length.words[0] = s->length.words[1];\n      s->length.words[1] = tmp;\n    }\n#endif\n\n    uint64_t *len = (uint64_t *)(s->buffer + 112);\n    len[0] = s->length.words[0];\n    len[1] = s->length.words[1];\n    fio_sha2_perform_all_rounds(s, s->buffer);\n\n    /* change back to little endian */\n    s->digest.i64[0] = fio_ntol64(s->digest.i64[0]);\n    s->digest.i64[1] = fio_ntol64(s->digest.i64[1]);\n    s->digest.i64[2] = fio_ntol64(s->digest.i64[2]);\n    s->digest.i64[3] = fio_ntol64(s->digest.i64[3]);\n    s->digest.i64[4] = fio_ntol64(s->digest.i64[4]);\n    s->digest.i64[5] = fio_ntol64(s->digest.i64[5]);\n    s->digest.i64[6] = fio_ntol64(s->digest.i64[6]);\n    s->digest.i64[7] = fio_ntol64(s->digest.i64[7]);\n    // set NULL bytes for SHA-2 Type\n    switch (s->type) {\n    case SHA_512_224:\n      s->digest.str[28] = 0;\n      break;\n    case SHA_512_256:\n      s->digest.str[32] = 0;\n      break;\n    case SHA_384:\n      s->digest.str[48] = 0;\n      break;\n    default:\n      s->digest.str[64] =\n          0; /* sometimes the optimizer messes the NUL sequence */\n      break;\n    }\n    // fprintf(stderr, \"result requested, in hex, is:\");\n    // for (size_t i = 0; i < ((s->type & 1) ? 64 : 32); i++)\n    //   fprintf(stderr, \"%02x\", (unsigned int)(s->digest.str[i] & 0xFF));\n    // fprintf(stderr, \"\\r\\n\");\n    return (char *)s->digest.str;\n  }\n\n  size_t in_buffer = s->length.words[0] & 63;\n  if (in_buffer > 55) {\n    memcpy(s->buffer + in_buffer, sha2_padding, 64 - in_buffer);\n    fio_sha2_perform_all_rounds(s, s->buffer);\n    memcpy(s->buffer, sha2_padding + 1, 56);\n  } else if (in_buffer != 55) {\n    memcpy(s->buffer + in_buffer, sha2_padding, 56 - in_buffer);\n  } else {\n    s->buffer[55] = sha2_padding[0];\n  }\n  /* store the length in BITS - alignment should be promised by struct */\n  /* this must the number in BITS, encoded as a BIG ENDIAN 64 bit number */\n  uint64_t *len = (uint64_t *)(s->buffer + 56);\n  *len = s->length.words[0] << 3;\n  *len = fio_lton64(*len);\n  fio_sha2_perform_all_rounds(s, s->buffer);\n\n  /* change back to little endian, if required */\n\n  s->digest.i32[0] = fio_ntol32(s->digest.i32[0]);\n  s->digest.i32[1] = fio_ntol32(s->digest.i32[1]);\n  s->digest.i32[2] = fio_ntol32(s->digest.i32[2]);\n  s->digest.i32[3] = fio_ntol32(s->digest.i32[3]);\n  s->digest.i32[4] = fio_ntol32(s->digest.i32[4]);\n  s->digest.i32[5] = fio_ntol32(s->digest.i32[5]);\n  s->digest.i32[6] = fio_ntol32(s->digest.i32[6]);\n  s->digest.i32[7] = fio_ntol32(s->digest.i32[7]);\n\n  // set NULL bytes for SHA_224\n  if (s->type == SHA_224)\n    s->digest.str[28] = 0;\n  // fprintf(stderr, \"SHA-2 result requested, in hex, is:\");\n  // for (size_t i = 0; i < ((s->type & 1) ? 64 : 32); i++)\n  //   fprintf(stderr, \"%02x\", (unsigned int)(s->digest.str[i] & 0xFF));\n  // fprintf(stderr, \"\\r\\n\");\n  return (char *)s->digest.str;\n}\n\n#undef perform_single_round\n\n/* ****************************************************************************\nBase64 encoding\n***************************************************************************** */\n\n/** the base64 encoding array */\nstatic const char base64_encodes_original[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n\n/** the base64 encoding array */\nstatic const char base64_encodes_url[] =\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_=\";\n\n/**\nA base64 decoding array.\n\nGeneration script (Ruby):\n\na = []; a[255] = 0\ns = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\".bytes;\ns.length.times {|i| a[s[i]] = i };\ns = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+,\".bytes;\ns.length.times {|i| a[s[i]] = i };\ns = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\".bytes;\ns.length.times {|i| a[s[i]] = i }; a.map!{ |i| i.to_i }; a\n\n*/\nstatic unsigned base64_decodes[] = {\n    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n    0,  0,  0,  0,  0,  62, 63, 62, 0,  63, 52, 53, 54, 55, 56, 57, 58, 59, 60,\n    61, 0,  0,  0,  64, 0,  0,  0,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9,  10,\n    11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0,  0,  0,  0,\n    63, 0,  26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,\n    43, 44, 45, 46, 47, 48, 49, 50, 51, 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n    0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n    0,  0,  0,  0,  0,  0,  0,  0,  0,\n};\n#define BITVAL(x) (base64_decodes[(x)] & 63)\n\n/*\n * The actual encoding logic. The map can be switched for encoding variations.\n */\nstatic inline int fio_base64_encode_internal(char *target, const char *data,\n                                             int len,\n                                             const char *base64_encodes) {\n  /* walk backwards, allowing fo inplace decoding (target == data) */\n  int groups = len / 3;\n  const int mod = len - (groups * 3);\n  const int target_size = (groups + (mod != 0)) * 4;\n  char *writer = target + target_size - 1;\n  const char *reader = data + len - 1;\n  writer[1] = 0;\n  switch (mod) {\n  case 2: {\n    char tmp2 = *(reader--);\n    char tmp1 = *(reader--);\n    *(writer--) = '=';\n    *(writer--) = base64_encodes[((tmp2 & 15) << 2)];\n    *(writer--) = base64_encodes[((tmp1 & 3) << 4) | ((tmp2 >> 4) & 15)];\n    *(writer--) = base64_encodes[(tmp1 >> 2) & 63];\n  } break;\n  case 1: {\n    char tmp1 = *(reader--);\n    *(writer--) = '=';\n    *(writer--) = '=';\n    *(writer--) = base64_encodes[(tmp1 & 3) << 4];\n    *(writer--) = base64_encodes[(tmp1 >> 2) & 63];\n  } break;\n  }\n  while (groups) {\n    groups--;\n    const char tmp3 = *(reader--);\n    const char tmp2 = *(reader--);\n    const char tmp1 = *(reader--);\n    *(writer--) = base64_encodes[tmp3 & 63];\n    *(writer--) = base64_encodes[((tmp2 & 15) << 2) | ((tmp3 >> 6) & 3)];\n    *(writer--) = base64_encodes[(((tmp1 & 3) << 4) | ((tmp2 >> 4) & 15))];\n    *(writer--) = base64_encodes[(tmp1 >> 2) & 63];\n  }\n  return target_size;\n}\n\n/**\nThis will encode a byte array (data) of a specified length (len) and\nplace the encoded data into the target byte buffer (target). The target buffer\nMUST have enough room for the expected data.\n\nBase64 encoding always requires 4 bytes for each 3 bytes. Padding is added if\nthe raw data's length isn't devisable by 3.\n\nAlways assume the target buffer should have room enough for (len*4/3 + 4)\nbytes.\n\nReturns the number of bytes actually written to the target buffer\n(including the Base64 required padding and excluding a NULL terminator).\n\nA NULL terminator char is NOT written to the target buffer.\n*/\nint fio_base64_encode(char *target, const char *data, int len) {\n  return fio_base64_encode_internal(target, data, len, base64_encodes_original);\n}\n\n/**\nSame as fio_base64_encode, but using Base64URL encoding.\n*/\nint fio_base64url_encode(char *target, const char *data, int len) {\n  return fio_base64_encode_internal(target, data, len, base64_encodes_url);\n}\n\n/**\nThis will decode a Base64 encoded string of a specified length (len) and\nplace the decoded data into the target byte buffer (target).\n\nThe target buffer MUST have enough room for the expected data.\n\nA NULL byte will be appended to the target buffer. The function will return\nthe number of bytes written to the target buffer.\n\nIf the target buffer is NULL, the encoded string will be destructively edited\nand the decoded data will be placed in the original string's buffer.\n\nBase64 encoding always requires 4 bytes for each 3 bytes. Padding is added if\nthe raw data's length isn't devisable by 3. Hence, the target buffer should\nbe, at least, `base64_len/4*3 + 3` long.\n\nReturns the number of bytes actually written to the target buffer (excluding\nthe NULL terminator byte).\n\nIf an error occurred, returns the number of bytes written up to the error. Test\n`errno` for error (will be set to ERANGE).\n*/\nint fio_base64_decode(char *target, char *encoded, int base64_len) {\n  if (!target)\n    target = encoded;\n  if (base64_len <= 0) {\n    target[0] = 0;\n    return 0;\n  }\n  int written = 0;\n  uint8_t tmp1, tmp2, tmp3, tmp4;\n  // skip unknown data at end\n  while (base64_len &&\n         !base64_decodes[*(uint8_t *)(encoded + (base64_len - 1))]) {\n    base64_len--;\n  }\n  // skip white space\n  while (base64_len && isspace((*(uint8_t *)encoded))) {\n    base64_len--;\n    encoded++;\n  }\n  while (base64_len >= 4) {\n    if (!base64_len) {\n      return written;\n    }\n    tmp1 = *(uint8_t *)(encoded++);\n    tmp2 = *(uint8_t *)(encoded++);\n    tmp3 = *(uint8_t *)(encoded++);\n    tmp4 = *(uint8_t *)(encoded++);\n    if (!base64_decodes[tmp1] || !base64_decodes[tmp2] ||\n        !base64_decodes[tmp3] || !base64_decodes[tmp4]) {\n      errno = ERANGE;\n      goto finish;\n    }\n    *(target++) = (BITVAL(tmp1) << 2) | (BITVAL(tmp2) >> 4);\n    *(target++) = (BITVAL(tmp2) << 4) | (BITVAL(tmp3) >> 2);\n    *(target++) = (BITVAL(tmp3) << 6) | (BITVAL(tmp4));\n    // make sure we don't loop forever.\n    base64_len -= 4;\n    // count written bytes\n    written += 3;\n    // skip white space\n    while (base64_len && isspace((*encoded))) {\n      base64_len--;\n      encoded++;\n    }\n  }\n  // deal with the \"tail\" of the mis-encoded stream - this shouldn't happen\n  tmp1 = 0;\n  tmp2 = 0;\n  tmp3 = 0;\n  tmp4 = 0;\n  switch (base64_len) {\n  case 1:\n    tmp1 = *(uint8_t *)(encoded++);\n    if (!base64_decodes[tmp1]) {\n      errno = ERANGE;\n      goto finish;\n    }\n    *(target++) = BITVAL(tmp1);\n    written += 1;\n    break;\n  case 2:\n    tmp1 = *(uint8_t *)(encoded++);\n    tmp2 = *(uint8_t *)(encoded++);\n    if (!base64_decodes[tmp1] || !base64_decodes[tmp2]) {\n      errno = ERANGE;\n      goto finish;\n    }\n    *(target++) = (BITVAL(tmp1) << 2) | (BITVAL(tmp2) >> 6);\n    *(target++) = (BITVAL(tmp2) << 4);\n    written += 2;\n    break;\n  case 3:\n    tmp1 = *(uint8_t *)(encoded++);\n    tmp2 = *(uint8_t *)(encoded++);\n    tmp3 = *(uint8_t *)(encoded++);\n    if (!base64_decodes[tmp1] || !base64_decodes[tmp2] ||\n        !base64_decodes[tmp3]) {\n      errno = ERANGE;\n      goto finish;\n    }\n    *(target++) = (BITVAL(tmp1) << 2) | (BITVAL(tmp2) >> 6);\n    *(target++) = (BITVAL(tmp2) << 4) | (BITVAL(tmp3) >> 2);\n    *(target++) = BITVAL(tmp3) << 6;\n    written += 3;\n    break;\n  }\nfinish:\n  if (encoded[-1] == '=') {\n    target--;\n    written--;\n    if (encoded[-2] == '=') {\n      target--;\n      written--;\n    }\n    if (written < 0)\n      written = 0;\n  }\n  *target = 0;\n  return written;\n}\n\n/* *****************************************************************************\nSection Start Marker\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n                                     Testing\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n#if DEBUG\n\n// clang-format off\n#if defined(HAVE_OPENSSL)\n#  include <openssl/sha.h>\n#endif\n// clang-format on\n\n/* *****************************************************************************\nTesting Linked Lists\n***************************************************************************** */\n\n#define FIO_LLIST_TEST_LIMIT 1016\n\n/**\n * Tests linked list functionality.\n */\n#ifndef H_FIO_LINKED_LIST_H\n#define fio_llist_test()\n#else\nFIO_FUNC inline void fio_llist_test(void) {\n  fio_ls_s list = FIO_LS_INIT(list);\n  size_t counter;\n  fprintf(stderr, \"=== Testing Core Linked List features (fio_ls and \"\n                  \"fio_ls_embs functions)\\n\");\n  /* test push/shift */\n  for (uintptr_t i = 0; i < FIO_LLIST_TEST_LIMIT; ++i) {\n    fio_ls_push(&list, (void *)i);\n  }\n  FIO_ASSERT(fio_ls_any(&list), \"List should be populated after fio_ls_push\");\n  counter = 0;\n  FIO_LS_FOR(&list, pos) {\n    FIO_ASSERT((size_t)pos->obj == counter,\n               \"`FIO_LS_FOR` value error (%zu != %zu)\", (size_t)pos->obj,\n               counter);\n    ++counter;\n  }\n  counter = 0;\n  while (fio_ls_any(&list)) {\n    FIO_ASSERT(counter < FIO_LLIST_TEST_LIMIT,\n               \"`fio_ls_any` didn't return false when expected %p<=%p=>%p\",\n               (void *)list.prev, (void *)&list, (void *)list.next);\n    size_t tmp = (size_t)fio_ls_shift(&list);\n    FIO_ASSERT(tmp == counter, \"`fio_ls_shift` value error (%zu != %zu)\", tmp,\n               counter);\n    ++counter;\n  }\n  FIO_ASSERT(counter == FIO_LLIST_TEST_LIMIT,\n             \"List item count error (%zu != %zu)\", counter,\n             (size_t)FIO_LLIST_TEST_LIMIT);\n  /* test unshift/pop */\n  for (uintptr_t i = 0; i < FIO_LLIST_TEST_LIMIT; ++i) {\n    fio_ls_unshift(&list, (void *)i);\n  }\n  FIO_ASSERT(fio_ls_any(&list),\n             \"List should be populated after fio_ls_unshift\");\n  counter = 0;\n  while (!fio_ls_is_empty(&list)) {\n    FIO_ASSERT(counter < FIO_LLIST_TEST_LIMIT,\n               \"`fio_ls_is_empty` didn't return true when expected %p<=%p=>%p\",\n               (void *)list.prev, (void *)&list, (void *)list.next);\n    size_t tmp = (size_t)fio_ls_pop(&list);\n    FIO_ASSERT(tmp == counter, \"`fio_ls_pop` value error (%zu != %zu)\", tmp,\n               counter);\n    ++counter;\n  }\n  FIO_ASSERT(counter == FIO_LLIST_TEST_LIMIT,\n             \"List item count error (%zu != %zu)\", counter,\n             (size_t)FIO_LLIST_TEST_LIMIT);\n\n  /* Re-test for embeded list */\n\n  struct fio_ls_test_s {\n    size_t i;\n    fio_ls_embd_s node;\n  };\n\n  fio_ls_embd_s emlist = FIO_LS_INIT(emlist);\n\n  /* test push/shift */\n  for (uintptr_t i = 0; i < FIO_LLIST_TEST_LIMIT; ++i) {\n    struct fio_ls_test_s *n = malloc(sizeof(*n));\n    FIO_ASSERT_ALLOC(n);\n    n->i = i;\n    fio_ls_embd_push(&emlist, &n->node);\n    FIO_ASSERT(FIO_LS_EMBD_OBJ(struct fio_ls_test_s, node, emlist.next)->i == 0,\n               \"fio_ls_embd_push should push to the end.\");\n  }\n  FIO_ASSERT(fio_ls_embd_any(&emlist),\n             \"List should be populated after fio_ls_embd_push\");\n  counter = 0;\n  FIO_LS_EMBD_FOR(&emlist, pos) {\n    FIO_ASSERT(FIO_LS_EMBD_OBJ(struct fio_ls_test_s, node, pos)->i == counter,\n               \"`FIO_LS_EMBD_FOR` value error (%zu != %zu)\",\n               FIO_LS_EMBD_OBJ(struct fio_ls_test_s, node, pos)->i, counter);\n    ++counter;\n  }\n  counter = 0;\n  while (fio_ls_embd_any(&emlist)) {\n    FIO_ASSERT(counter < FIO_LLIST_TEST_LIMIT,\n               \"`fio_ls_embd_any` didn't return false when expected %p<=%p=>%p\",\n               (void *)emlist.prev, (void *)&emlist, (void *)emlist.next);\n    struct fio_ls_test_s *n =\n        FIO_LS_EMBD_OBJ(struct fio_ls_test_s, node, fio_ls_embd_shift(&emlist));\n    FIO_ASSERT(n->i == counter, \"`fio_ls_embd_shift` value error (%zu != %zu)\",\n               n->i, counter);\n    free(n);\n    ++counter;\n  }\n  FIO_ASSERT(counter == FIO_LLIST_TEST_LIMIT,\n             \"List item count error (%zu != %zu)\", counter,\n             (size_t)FIO_LLIST_TEST_LIMIT);\n  /* test shift/unshift */\n  for (uintptr_t i = 0; i < FIO_LLIST_TEST_LIMIT; ++i) {\n    struct fio_ls_test_s *n = malloc(sizeof(*n));\n    FIO_ASSERT_ALLOC(n)\n    n->i = i;\n    fio_ls_embd_unshift(&emlist, &n->node);\n    FIO_ASSERT(FIO_LS_EMBD_OBJ(struct fio_ls_test_s, node, emlist.next)->i == i,\n               \"fio_ls_embd_unshift should push to the start.\");\n  }\n  FIO_ASSERT(fio_ls_embd_any(&emlist),\n             \"List should be populated after fio_ls_embd_unshift\");\n  counter = 0;\n  while (!fio_ls_embd_is_empty(&emlist)) {\n    FIO_ASSERT(\n        counter < FIO_LLIST_TEST_LIMIT,\n        \"`fio_ls_embd_is_empty` didn't return true when expected %p<=%p=>%p\",\n        (void *)emlist.prev, (void *)&emlist, (void *)emlist.next);\n    struct fio_ls_test_s *n =\n        FIO_LS_EMBD_OBJ(struct fio_ls_test_s, node, fio_ls_embd_pop(&emlist));\n    FIO_ASSERT(n->i == counter, \"`fio_ls_embd_pop` value error (%zu != %zu)\",\n               n->i, counter);\n    free(n);\n    ++counter;\n  }\n  FIO_ASSERT(counter == FIO_LLIST_TEST_LIMIT,\n             \"List item count error (%zu != %zu)\", counter,\n             (size_t)FIO_LLIST_TEST_LIMIT);\n  fprintf(stderr, \"* passed.\\n\");\n}\n#endif\n\n/* *****************************************************************************\nTesting Strings\n***************************************************************************** */\n\n#ifndef H_FIO_STR_H\n#define fio_str_test()\n#else\n\nstatic int fio_str_test_dealloc_counter = 0;\n\nFIO_FUNC void fio_str_test_dealloc(void *s) {\n  FIO_ASSERT(!fio_str_test_dealloc_counter,\n             \"fio_str_s reference count error!\\n\");\n  fio_free(s);\n  fprintf(stderr, \"* reference counting `fio_str_free2` pass.\\n\");\n}\n\n/**\n * Tests the fio_str functionality.\n */\nFIO_FUNC inline void fio_str_test(void) {\n#define ROUND_UP_CAPA_2WORDS(num)                                              \\\n  (((num + 1) & (sizeof(long double) - 1))                                     \\\n       ? ((num + 1) | (sizeof(long double) - 1))                               \\\n       : (num))\n  fprintf(stderr, \"=== Testing Core String features (fio_str_s functions)\\n\");\n  fprintf(stderr, \"* String container size: %zu\\n\", sizeof(fio_str_s));\n  fprintf(stderr,\n          \"* Self-Contained String Capacity (FIO_STR_SMALL_CAPA): %zu\\n\",\n          FIO_STR_SMALL_CAPA);\n  fio_str_s str = {.small = 0}; /* test zeroed out memory */\n  FIO_ASSERT(fio_str_capa(&str) == FIO_STR_SMALL_CAPA - 1,\n             \"Small String capacity reporting error!\");\n  FIO_ASSERT(fio_str_len(&str) == 0, \"Small String length reporting error!\");\n  FIO_ASSERT(fio_str_data(&str) ==\n                 (char *)((uintptr_t)(&str + 1) - FIO_STR_SMALL_CAPA),\n             \"Small String pointer reporting error (%zd offset)!\",\n             (ssize_t)(((char *)((uintptr_t)(&str + 1) - FIO_STR_SMALL_CAPA)) -\n                       fio_str_data(&str)));\n  fio_str_write(&str, \"World\", 4);\n  FIO_ASSERT(str.small,\n             \"Small String writing error - not small on small write!\");\n  FIO_ASSERT(fio_str_capa(&str) == FIO_STR_SMALL_CAPA - 1,\n             \"Small String capacity reporting error after write!\");\n  FIO_ASSERT(fio_str_len(&str) == 4,\n             \"Small String length reporting error after write!\");\n  FIO_ASSERT(fio_str_data(&str) ==\n                 (char *)((uintptr_t)(&str + 1) - FIO_STR_SMALL_CAPA),\n             \"Small String pointer reporting error after write!\");\n  FIO_ASSERT(strlen(fio_str_data(&str)) == 4,\n             \"Small String NUL missing after write (%zu)!\",\n             strlen(fio_str_data(&str)));\n  FIO_ASSERT(!strcmp(fio_str_data(&str), \"Worl\"),\n             \"Small String write error (%s)!\", fio_str_data(&str));\n  FIO_ASSERT(fio_str_data(&str) == fio_str_info(&str).data,\n             \"Small String `fio_str_data` != `fio_str_info(s).data` (%p != %p)\",\n             (void *)fio_str_data(&str), (void *)fio_str_info(&str).data);\n\n  fio_str_capa_assert(&str, sizeof(fio_str_s) - 1);\n  FIO_ASSERT(!str.small,\n             \"Long String reporting as small after capacity update!\");\n  FIO_ASSERT(fio_str_capa(&str) >= sizeof(fio_str_s) - 1,\n             \"Long String capacity update error (%zu != %zu)!\",\n             fio_str_capa(&str), sizeof(fio_str_s));\n  FIO_ASSERT(fio_str_data(&str) == fio_str_info(&str).data,\n             \"Long String `fio_str_data` !>= `fio_str_info(s).data` (%p != %p)\",\n             (void *)fio_str_data(&str), (void *)fio_str_info(&str).data);\n\n  FIO_ASSERT(\n      fio_str_len(&str) == 4,\n      \"Long String length changed during conversion from small string (%zu)!\",\n      fio_str_len(&str));\n  FIO_ASSERT(fio_str_data(&str) == str.data,\n             \"Long String pointer reporting error after capacity update!\");\n  FIO_ASSERT(strlen(fio_str_data(&str)) == 4,\n             \"Long String NUL missing after capacity update (%zu)!\",\n             strlen(fio_str_data(&str)));\n  FIO_ASSERT(!strcmp(fio_str_data(&str), \"Worl\"),\n             \"Long String value changed after capacity update (%s)!\",\n             fio_str_data(&str));\n\n  fio_str_write(&str, \"d!\", 2);\n  FIO_ASSERT(!strcmp(fio_str_data(&str), \"World!\"),\n             \"Long String `write` error (%s)!\", fio_str_data(&str));\n\n  fio_str_replace(&str, 0, 0, \"Hello \", 6);\n  FIO_ASSERT(!strcmp(fio_str_data(&str), \"Hello World!\"),\n             \"Long String `insert` error (%s)!\", fio_str_data(&str));\n\n  fio_str_resize(&str, 6);\n  FIO_ASSERT(!strcmp(fio_str_data(&str), \"Hello \"),\n             \"Long String `resize` clipping error (%s)!\", fio_str_data(&str));\n\n  fio_str_replace(&str, 6, 0, \"My World!\", 9);\n  FIO_ASSERT(!strcmp(fio_str_data(&str), \"Hello My World!\"),\n             \"Long String `replace` error when testing overflow (%s)!\",\n             fio_str_data(&str));\n\n  str.capa = str.len;\n  fio_str_replace(&str, -10, 2, \"Big\", 3);\n  FIO_ASSERT(!strcmp(fio_str_data(&str), \"Hello Big World!\"),\n             \"Long String `replace` error when testing splicing (%s)!\",\n             fio_str_data(&str));\n\n  FIO_ASSERT(\n      fio_str_capa(&str) == ROUND_UP_CAPA_2WORDS(strlen(\"Hello Big World!\")),\n      \"Long String `fio_str_replace` capacity update error (%zu != %zu)!\",\n      fio_str_capa(&str), ROUND_UP_CAPA_2WORDS(strlen(\"Hello Big World!\")));\n\n  if (str.len < FIO_STR_SMALL_CAPA) {\n    fio_str_compact(&str);\n    FIO_ASSERT(str.small, \"Compacting didn't change String to small!\");\n    FIO_ASSERT(fio_str_len(&str) == strlen(\"Hello Big World!\"),\n               \"Compacting altered String length! (%zu != %zu)!\",\n               fio_str_len(&str), strlen(\"Hello Big World!\"));\n    FIO_ASSERT(!strcmp(fio_str_data(&str), \"Hello Big World!\"),\n               \"Compact data error (%s)!\", fio_str_data(&str));\n    FIO_ASSERT(fio_str_capa(&str) == FIO_STR_SMALL_CAPA - 1,\n               \"Compacted String capacity reporting error!\");\n  } else {\n    fprintf(stderr, \"* skipped `compact` test!\\n\");\n  }\n\n  {\n    fio_str_freeze(&str);\n    fio_str_info_s old_state = fio_str_info(&str);\n    fio_str_write(&str, \"more data to be written here\", 28);\n    fio_str_replace(&str, 2, 1, \"more data to be written here\", 28);\n    fio_str_info_s new_state = fio_str_info(&str);\n    FIO_ASSERT(old_state.len == new_state.len, \"Frozen String length changed!\");\n    FIO_ASSERT(old_state.data == new_state.data,\n               \"Frozen String pointer changed!\");\n    FIO_ASSERT(\n        old_state.capa == new_state.capa,\n        \"Frozen String capacity changed (allowed, but shouldn't happen)!\");\n    str.frozen = 0;\n  }\n  fio_str_printf(&str, \" %u\", 42);\n  FIO_ASSERT(!strcmp(fio_str_data(&str), \"Hello Big World! 42\"),\n             \"`fio_str_printf` data error (%s)!\", fio_str_data(&str));\n\n  {\n    fio_str_s str2 = FIO_STR_INIT;\n    fio_str_concat(&str2, &str);\n    FIO_ASSERT(fio_str_iseq(&str, &str2),\n               \"`fio_str_concat` error, strings not equal (%s != %s)!\",\n               fio_str_data(&str), fio_str_data(&str2));\n    fio_str_write(&str2, \":extra data\", 11);\n    FIO_ASSERT(\n        !fio_str_iseq(&str, &str2),\n        \"`fio_str_write` error after copy, strings equal ((%zu)%s == (%zu)%s)!\",\n        fio_str_len(&str), fio_str_data(&str), fio_str_len(&str2),\n        fio_str_data(&str2));\n\n    fio_str_free(&str2);\n  }\n\n  fio_str_free(&str);\n\n  fio_str_write_i(&str, -42);\n  FIO_ASSERT(fio_str_len(&str) == 3 && !memcmp(\"-42\", fio_str_data(&str), 3),\n             \"fio_str_write_i output error ((%zu) %s != -42)\",\n             fio_str_len(&str), fio_str_data(&str));\n  fio_str_free(&str);\n\n  {\n    fprintf(stderr, \"* testing `fio_str_readfile`, and reference counting.\\n\");\n    fio_str_s *s = fio_str_new2();\n    FIO_ASSERT(s && s->small,\n               \"`fio_str_new2` error, string not initialized (%p)!\", (void *)s);\n    fio_str_s *s2 = fio_str_dup(s);\n\n    ++fio_str_test_dealloc_counter;\n\n    FIO_ASSERT(s2 == s, \"`fio_str_dup` error, should return self!\");\n    FIO_ASSERT(s->ref == 1,\n               \"`fio_str_dup` error, reference counter not incremented!\");\n\n    fprintf(stderr, \"* reading a file.\\n\");\n    fio_str_info_s state = fio_str_readfile(s, __FILE__, 0, 0);\n    if (!s->small) /* attach deallocation test */\n      s->dealloc = fio_str_test_dealloc;\n\n    FIO_ASSERT(state.data,\n               \"`fio_str_readfile` error, no data was read for file %s!\",\n               __FILE__);\n\n    FIO_ASSERT(!memcmp(state.data,\n                       \"/* \"\n                       \"******************************************************\"\n                       \"***********************\",\n                       80),\n               \"`fio_str_readfile` content error, header mismatch!\\n %s\",\n               state.data);\n    fprintf(stderr, \"* testing UTF-8 validation and length.\\n\");\n    FIO_ASSERT(\n        fio_str_utf8_valid(s),\n        \"`fio_str_utf8_valid` error, code in this file should be valid!\");\n    FIO_ASSERT(fio_str_utf8_len(s) && (fio_str_utf8_len(s) <= fio_str_len(s)) &&\n                   (fio_str_utf8_len(s) >= (fio_str_len(s)) >> 1),\n               \"`fio_str_utf8_len` error, invalid value (%zu / %zu!\",\n               fio_str_utf8_len(s), fio_str_len(s));\n\n    fprintf(stderr, \"* reviewing reference counting `fio_str_free2` (1/2).\\n\");\n    fio_str_free2(s2);\n    --fio_str_test_dealloc_counter;\n    FIO_ASSERT(s->ref == 0,\n               \"`fio_str_free2` error, reference counter not subtracted!\");\n    FIO_ASSERT(s->small == 0, \"`fio_str_free2` error, strring reinitialized!\");\n    FIO_ASSERT(\n        fio_str_data(s) == state.data,\n        \"`fio_str_free2` error, data freed while references exist! (%p != %p)\",\n        (void *)fio_str_data(s), (void *)state.data);\n\n    if (1) {\n      /* String content == whole file (this file) */\n      intptr_t pos = -11;\n      size_t len = 20;\n      fprintf(stderr, \"* testing UTF-8 positioning.\\n\");\n\n      FIO_ASSERT(\n          fio_str_utf8_select(s, &pos, &len) == 0,\n          \"`fio_str_utf8_select` returned error for negative pos! (%zd, %zu)\",\n          (ssize_t)pos, len);\n      FIO_ASSERT(\n          pos == (intptr_t)state.len - 10, /* no UTF-8 bytes in this file */\n          \"`fio_str_utf8_select` error, negative position invalid! (%zd)\",\n          (ssize_t)pos);\n      FIO_ASSERT(len == 10,\n                 \"`fio_str_utf8_select` error, trancated length invalid! (%zd)\",\n                 (ssize_t)len);\n      pos = 10;\n      len = 20;\n      FIO_ASSERT(fio_str_utf8_select(s, &pos, &len) == 0,\n                 \"`fio_str_utf8_select` returned error! (%zd, %zu)\",\n                 (ssize_t)pos, len);\n      FIO_ASSERT(pos == 10,\n                 \"`fio_str_utf8_select` error, position invalid! (%zd)\",\n                 (ssize_t)pos);\n      FIO_ASSERT(len == 20,\n                 \"`fio_str_utf8_select` error, length invalid! (%zd)\",\n                 (ssize_t)len);\n    }\n    fprintf(stderr, \"* reviewing reference counting `fio_str_free2` (2/2).\\n\");\n    fio_str_free2(s);\n    fprintf(stderr, \"* finished reference counting test.\\n\");\n  }\n  fio_str_free(&str);\n  if (1) {\n\n    const char *utf8_sample = /* three hearts, small-big-small*/\n        \"\\xf0\\x9f\\x92\\x95\\xe2\\x9d\\xa4\\xef\\xb8\\x8f\\xf0\\x9f\\x92\\x95\";\n    fio_str_write(&str, utf8_sample, strlen(utf8_sample));\n    intptr_t pos = -2;\n    size_t len = 2;\n    FIO_ASSERT(fio_str_utf8_select(&str, &pos, &len) == 0,\n               \"`fio_str_utf8_select` returned error for negative pos on \"\n               \"UTF-8 data! (%zd, %zu)\",\n               (ssize_t)pos, len);\n    FIO_ASSERT(pos == (intptr_t)fio_str_len(&str) - 4, /* 4 byte emoji */\n               \"`fio_str_utf8_select` error, negative position invalid on \"\n               \"UTF-8 data! (%zd)\",\n               (ssize_t)pos);\n    FIO_ASSERT(len == 4, /* last utf-8 char is 4 byte long */\n               \"`fio_str_utf8_select` error, trancated length invalid on \"\n               \"UTF-8 data! (%zd)\",\n               (ssize_t)len);\n    pos = 1;\n    len = 20;\n    FIO_ASSERT(fio_str_utf8_select(&str, &pos, &len) == 0,\n               \"`fio_str_utf8_select` returned error on UTF-8 data! (%zd, %zu)\",\n               (ssize_t)pos, len);\n    FIO_ASSERT(\n        pos == 4,\n        \"`fio_str_utf8_select` error, position invalid on UTF-8 data! (%zd)\",\n        (ssize_t)pos);\n    FIO_ASSERT(\n        len == 10,\n        \"`fio_str_utf8_select` error, length invalid on UTF-8 data! (%zd)\",\n        (ssize_t)len);\n    pos = 1;\n    len = 3;\n    FIO_ASSERT(\n        fio_str_utf8_select(&str, &pos, &len) == 0,\n        \"`fio_str_utf8_select` returned error on UTF-8 data (2)! (%zd, %zu)\",\n        (ssize_t)pos, len);\n    FIO_ASSERT(\n        len == 10, /* 3 UTF-8 chars: 4 byte + 4 byte + 2 byte codes == 10 */\n        \"`fio_str_utf8_select` error, length invalid on UTF-8 data! (%zd)\",\n        (ssize_t)len);\n  }\n  fio_str_free(&str);\n  if (1) {\n    str = FIO_STR_INIT_STATIC(\"Welcome\");\n    FIO_ASSERT(fio_str_capa(&str) == 0, \"Static string capacity non-zero.\");\n    FIO_ASSERT(fio_str_len(&str) > 0,\n               \"Static string length should be automatically calculated.\");\n    FIO_ASSERT(str.dealloc == NULL,\n               \"Static string deallocation function should be NULL.\");\n    fio_str_free(&str);\n    str = FIO_STR_INIT_STATIC(\"Welcome\");\n    fio_str_info_s state = fio_str_write(&str, \" Home\", 5);\n    FIO_ASSERT(state.capa > 0, \"Static string not converted to non-static.\");\n    FIO_ASSERT(str.dealloc, \"Missing static string deallocation function\"\n                            \" after `fio_str_write`.\");\n\n    fprintf(stderr, \"* reviewing `fio_str_detach`.\\n   (%zu): %s\\n\",\n            fio_str_info(&str).len, fio_str_info(&str).data);\n    char *cstr = fio_str_detach(&str);\n    FIO_ASSERT(cstr, \"`fio_str_detach` returned NULL\");\n    FIO_ASSERT(!memcmp(cstr, \"Welcome Home\\0\", 13),\n               \"`fio_str_detach` string error: %s\", cstr);\n    fio_free(cstr);\n    FIO_ASSERT(fio_str_len(&str) == 0, \"`fio_str_detach` data wasn't cleared.\");\n    // fio_str_free(&str);\n  }\n  fprintf(stderr, \"* passed.\\n\");\n}\n#endif\n\n/* *****************************************************************************\nTesting Memory Allocator\n***************************************************************************** */\n\n#if FIO_FORCE_MALLOC\n#define fio_malloc_test()                                                      \\\n  fprintf(stderr, \"\\n=== SKIPPED facil.io memory allocator (bypassed)\\n\");\n#else\nFIO_FUNC void fio_malloc_test(void) {\n  fprintf(stderr, \"\\n=== Testing facil.io memory allocator's system calls\\n\");\n  char *mem = sys_alloc(FIO_MEMORY_BLOCK_SIZE, 0);\n  FIO_ASSERT(mem, \"sys_alloc failed to allocate memory!\\n\");\n  FIO_ASSERT(!((uintptr_t)mem & FIO_MEMORY_BLOCK_MASK),\n             \"Memory allocation not aligned to FIO_MEMORY_BLOCK_SIZE!\");\n  mem[0] = 'a';\n  mem[FIO_MEMORY_BLOCK_SIZE - 1] = 'z';\n  fprintf(stderr, \"* Testing reallocation from %p\\n\", (void *)mem);\n  char *mem2 =\n      sys_realloc(mem, FIO_MEMORY_BLOCK_SIZE, FIO_MEMORY_BLOCK_SIZE * 2);\n  if (mem == mem2)\n    fprintf(stderr, \"* Performed system realloc without copy :-)\\n\");\n  FIO_ASSERT(mem2[0] == 'a' && mem2[FIO_MEMORY_BLOCK_SIZE - 1] == 'z',\n             \"Reaclloc data was lost!\");\n  sys_free(mem2, FIO_MEMORY_BLOCK_SIZE * 2);\n  fprintf(stderr, \"=== Testing facil.io memory allocator's internal data.\\n\");\n  FIO_ASSERT(arenas, \"Missing arena data - library not initialized!\");\n  fio_free(NULL); /* fio_free(NULL) shouldn't crash... */\n  mem = fio_malloc(1);\n  FIO_ASSERT(mem, \"fio_malloc failed to allocate memory!\\n\");\n  FIO_ASSERT(!((uintptr_t)mem & 15), \"fio_malloc memory not aligned!\\n\");\n  FIO_ASSERT(((uintptr_t)mem & FIO_MEMORY_BLOCK_MASK) != 16,\n             \"small fio_malloc memory indicates system allocation!\\n\");\n  mem[0] = 'a';\n  FIO_ASSERT(mem[0] == 'a', \"allocate memory wasn't written to!\\n\");\n  mem = fio_realloc(mem, 1);\n  FIO_ASSERT(mem, \"fio_realloc failed!\\n\");\n  FIO_ASSERT(mem[0] == 'a', \"fio_realloc memory wasn't copied!\\n\");\n  FIO_ASSERT(arena_last_used, \"arena_last_used wasn't initialized!\\n\");\n  fio_free(mem);\n  block_s *b = arena_last_used->block;\n\n  /* move arena to block's start */\n  while (arena_last_used->block == b) {\n    mem = fio_malloc(1);\n    FIO_ASSERT(mem, \"fio_malloc failed to allocate memory!\\n\");\n    fio_free(mem);\n  }\n  /* make sure a block is assigned */\n  fio_free(fio_malloc(1));\n  b = arena_last_used->block;\n  size_t count = 1;\n  /* count allocations within block */\n  do {\n    FIO_ASSERT(mem, \"fio_malloc failed to allocate memory!\\n\");\n    FIO_ASSERT(!((uintptr_t)mem & 15),\n               \"fio_malloc memory not aligned at allocation #%zu!\\n\", count);\n    FIO_ASSERT((((uintptr_t)mem & FIO_MEMORY_BLOCK_MASK) != 16),\n               \"fio_malloc memory indicates system allocation!\\n\");\n#if __x86_64__\n    fio_memcpy((size_t *)mem, (size_t *)\"0123456789abcdefg\", 1);\n#else\n    mem[0] = 'a';\n#endif\n    fio_free(mem); /* make sure we hold on to the block, so it rotates */\n    mem = fio_malloc(1);\n    ++count;\n  } while (arena_last_used->block == b);\n  {\n    fprintf(stderr, \"* Confirm block address: %p, last allocation was %p\\n\",\n            (void *)arena_last_used->block, (void *)mem);\n    fprintf(\n        stderr,\n        \"* Performed %zu allocations out of expected %zu allocations per \"\n        \"block.\\n\",\n        count,\n        (size_t)((FIO_MEMORY_BLOCK_SLICES - 2) - (sizeof(block_s) >> 4) - 1));\n    fio_ls_embd_s old_memory_list = memory.available;\n    fio_free(mem);\n    FIO_ASSERT(fio_ls_embd_any(&memory.available),\n               \"memory pool empty (memory block wasn't freed)!\\n\");\n    FIO_ASSERT(old_memory_list.next != memory.available.next ||\n                   memory.available.prev != old_memory_list.prev,\n               \"memory pool not updated after block being freed!\\n\");\n  }\n  /* rotate block again */\n  b = arena_last_used->block;\n  mem = fio_realloc(mem, 1);\n  do {\n    mem2 = mem;\n    mem = fio_malloc(1);\n    fio_free(mem2); /* make sure we hold on to the block, so it rotates */\n    FIO_ASSERT(mem, \"fio_malloc failed to allocate memory!\\n\");\n    FIO_ASSERT(!((uintptr_t)mem & 15),\n               \"fio_malloc memory not aligned at allocation #%zu!\\n\", count);\n    FIO_ASSERT((((uintptr_t)mem & FIO_MEMORY_BLOCK_MASK) != 16),\n               \"fio_malloc memory indicates system allocation!\\n\");\n#if __x86_64__\n    fio_memcpy((size_t *)mem, (size_t *)\"0123456789abcdefg\", 1);\n#else\n    mem[0] = 'a';\n#endif\n    ++count;\n  } while (arena_last_used->block == b);\n\n  mem2 = mem;\n  mem = fio_calloc(FIO_MEMORY_BLOCK_ALLOC_LIMIT - 64, 1);\n  fio_free(mem2);\n  FIO_ASSERT(mem,\n             \"failed to allocate FIO_MEMORY_BLOCK_ALLOC_LIMIT - 64 bytes!\\n\");\n  FIO_ASSERT(((uintptr_t)mem & FIO_MEMORY_BLOCK_MASK) != 16,\n             \"fio_calloc (under limit) memory alignment error!\\n\");\n  mem2 = fio_malloc(1);\n  FIO_ASSERT(mem2, \"fio_malloc(1) failed to allocate memory!\\n\");\n  mem2[0] = 'a';\n\n  for (uintptr_t i = 0; i < (FIO_MEMORY_BLOCK_ALLOC_LIMIT - 64); ++i) {\n    FIO_ASSERT(mem[i] == 0,\n               \"calloc returned memory that wasn't initialized?!\\n\");\n  }\n  fio_free(mem);\n\n  mem = fio_malloc(FIO_MEMORY_BLOCK_SIZE);\n  FIO_ASSERT(mem, \"fio_malloc failed to FIO_MEMORY_BLOCK_SIZE bytes!\\n\");\n  FIO_ASSERT(((uintptr_t)mem & FIO_MEMORY_BLOCK_MASK) == 16,\n             \"fio_malloc (big) memory isn't aligned!\\n\");\n  mem = fio_realloc(mem, FIO_MEMORY_BLOCK_SIZE * 2);\n  FIO_ASSERT(mem,\n             \"fio_realloc (big) failed on FIO_MEMORY_BLOCK_SIZE X2 bytes!\\n\");\n  fio_free(mem);\n  FIO_ASSERT(((uintptr_t)mem & FIO_MEMORY_BLOCK_MASK) == 16,\n             \"fio_realloc (big) memory isn't aligned!\\n\");\n\n  {\n    void *m0 = fio_malloc(0);\n    void *rm0 = fio_realloc(m0, 16);\n    FIO_ASSERT(m0 != rm0, \"fio_realloc(fio_malloc(0), 16) failed!\\n\");\n    fio_free(rm0);\n  }\n  {\n    size_t pool_size = 0;\n    FIO_LS_EMBD_FOR(&memory.available, node) { ++pool_size; }\n    mem = fio_mmap(512);\n    FIO_ASSERT(mem, \"fio_mmap allocation failed!\\n\");\n    fio_free(mem);\n    size_t new_pool_size = 0;\n    FIO_LS_EMBD_FOR(&memory.available, node) { ++new_pool_size; }\n    FIO_ASSERT(new_pool_size == pool_size,\n               \"fio_free of fio_mmap went to memory pool!\\n\");\n  }\n\n  fprintf(stderr, \"* passed.\\n\");\n}\n#endif\n\n/* *****************************************************************************\nTesting Core Callback add / remove / ensure\n***************************************************************************** */\n\nFIO_FUNC void fio_state_callback_test_task(void *pi) {\n  ((uintptr_t *)pi)[0] += 1;\n}\n\n#define FIO_STATE_TEST_COUNT 10\nFIO_FUNC void fio_state_callback_order_test_task(void *pi) {\n  static uintptr_t start = FIO_STATE_TEST_COUNT;\n  --start;\n  FIO_ASSERT((uintptr_t)pi == start,\n             \"Callback order error, expecting %zu, got %zu\", (size_t)start,\n             (size_t)pi);\n}\n\nFIO_FUNC void fio_state_callback_test(void) {\n  fprintf(stderr, \"=== Testing facil.io workflow state callback system\\n\");\n  uintptr_t result = 0;\n  uintptr_t other = 0;\n  fio_state_callback_add(FIO_CALL_NEVER, fio_state_callback_test_task, &result);\n  FIO_ASSERT(callback_collection[FIO_CALL_NEVER].callbacks.next,\n             \"Callback list failed to initialize.\");\n  fio_state_callback_force(FIO_CALL_NEVER);\n  FIO_ASSERT(result == 1, \"Callback wasn't called!\");\n  fio_state_callback_force(FIO_CALL_NEVER);\n  FIO_ASSERT(result == 2, \"Callback wasn't called (second time)!\");\n  fio_state_callback_remove(FIO_CALL_NEVER, fio_state_callback_test_task,\n                            &result);\n  fio_state_callback_force(FIO_CALL_NEVER);\n  FIO_ASSERT(result == 2, \"Callback wasn't removed!\");\n  fio_state_callback_add(FIO_CALL_NEVER, fio_state_callback_test_task, &result);\n  fio_state_callback_add(FIO_CALL_NEVER, fio_state_callback_test_task, &other);\n  fio_state_callback_clear(FIO_CALL_NEVER);\n  fio_state_callback_force(FIO_CALL_NEVER);\n  FIO_ASSERT(result == 2 && other == 0, \"Callbacks werent cleared!\");\n  for (uintptr_t i = 0; i < FIO_STATE_TEST_COUNT; ++i) {\n    fio_state_callback_add(FIO_CALL_NEVER, fio_state_callback_order_test_task,\n                           (void *)i);\n  }\n  fio_state_callback_force(FIO_CALL_NEVER);\n  fio_state_callback_clear(FIO_CALL_NEVER);\n  fprintf(stderr, \"* passed.\\n\");\n}\n#undef FIO_STATE_TEST_COUNT\n/* *****************************************************************************\nTesting fio_timers\n***************************************************************************** */\n\nFIO_FUNC void fio_timer_test_task(void *arg) { ++(((size_t *)arg)[0]); }\n\nFIO_FUNC void fio_timer_test(void) {\n  fprintf(stderr, \"=== Testing facil.io timer system\\n\");\n  size_t result = 0;\n  const size_t total = 5;\n  fio_data->active = 1;\n  FIO_ASSERT(fio_timers.next, \"Timers not initialized!\");\n  FIO_ASSERT(fio_run_every(0, 0, fio_timer_test_task, NULL, NULL) == -1,\n             \"Timers without an interval should be an error.\");\n  FIO_ASSERT(fio_run_every(1000, 0, NULL, NULL, NULL) == -1,\n             \"Timers without a task should be an error.\");\n  FIO_ASSERT(fio_run_every(900, total, fio_timer_test_task, &result,\n                           fio_timer_test_task) == 0,\n             \"Timer creation failure.\");\n  FIO_ASSERT(fio_ls_embd_any(&fio_timers),\n             \"Timer scheduling failure - no timer in list.\");\n  FIO_ASSERT(fio_timer_calc_first_interval() >= 898 &&\n                 fio_timer_calc_first_interval() <= 902,\n             \"next timer calculation error %zu\",\n             fio_timer_calc_first_interval());\n\n  fio_ls_embd_s *first = fio_timers.next;\n  FIO_ASSERT(fio_run_every(10000, total, fio_timer_test_task, &result,\n                           fio_timer_test_task) == 0,\n             \"Timer creation failure (second timer).\");\n  FIO_ASSERT(fio_timers.next == first, \"Timer Ordering error!\");\n\n  FIO_ASSERT(fio_timer_calc_first_interval() >= 898 &&\n                 fio_timer_calc_first_interval() <= 902,\n             \"next timer calculation error (after added timer) %zu\",\n             fio_timer_calc_first_interval());\n\n  fio_data->last_cycle.tv_nsec += 800;\n  fio_timer_schedule();\n  fio_defer_perform();\n  FIO_ASSERT(result == 0, \"Timer filtering error (%zu != 0)\\n\", result);\n\n  for (size_t i = 0; i < total; ++i) {\n    fio_data->last_cycle.tv_sec += 1;\n    // fio_data->last_cycle.tv_nsec += 1;\n    fio_timer_schedule();\n    fio_defer_perform();\n    FIO_ASSERT(((i != total - 1 && result == i + 1) ||\n                (i == total - 1 && result == total + 1)),\n               \"Timer running and rescheduling error (%zu != %zu)\\n\", result,\n               i + 1);\n    FIO_ASSERT(fio_timers.next == first || i == total - 1,\n               \"Timer Ordering error on cycle %zu!\", i);\n  }\n\n  fio_data->last_cycle.tv_sec += 10;\n  fio_timer_schedule();\n  fio_defer_perform();\n  FIO_ASSERT(result == total + 2, \"Timer # 2 error (%zu != %zu)\\n\", result,\n             total + 2);\n  fio_data->active = 0;\n  fio_timer_clear_all();\n  fio_defer_clear_tasks();\n  fprintf(stderr, \"* passed.\\n\");\n}\n\n/* *****************************************************************************\nTesting listening socket\n***************************************************************************** */\n\nFIO_FUNC void fio_socket_test(void) {\n  /* initialize unix socket name */\n  fio_str_s sock_name = FIO_STR_INIT;\n#ifdef P_tmpdir\n  fio_str_write(&sock_name, P_tmpdir, strlen(P_tmpdir));\n  if (fio_str_len(&sock_name) &&\n      fio_str_data(&sock_name)[fio_str_len(&sock_name) - 1] == '/')\n    fio_str_resize(&sock_name, fio_str_len(&sock_name) - 1);\n#else\n  fio_str_write(&sock_name, \"/tmp\", 4);\n#endif\n  fio_str_printf(&sock_name, \"/fio_test_sock-%d.sock\", (int)getpid());\n\n  fprintf(stderr, \"=== Testing facil.io listening socket creation (partial \"\n                  \"testing only).\\n\");\n  fprintf(stderr, \"* testing on TCP/IP port 8765 and Unix socket: %s\\n\",\n          fio_str_data(&sock_name));\n  intptr_t uuid = fio_socket(fio_str_data(&sock_name), NULL, 1);\n  FIO_ASSERT(uuid != -1, \"Failed to open unix socket\\n\");\n  FIO_ASSERT(uuid_data(uuid).open, \"Unix socket not initialized\");\n  intptr_t client1 = fio_socket(fio_str_data(&sock_name), NULL, 0);\n  FIO_ASSERT(client1 != -1, \"Failed to connect to unix socket.\");\n  intptr_t client2 = fio_accept(uuid);\n  FIO_ASSERT(client2 != -1, \"Failed to accept unix socket connection.\");\n  fprintf(stderr, \"* Unix server addr %s\\n\", fio_peer_addr(uuid).data);\n  fprintf(stderr, \"* Unix client1 addr %s\\n\", fio_peer_addr(client1).data);\n  fprintf(stderr, \"* Unix client2 addr %s\\n\", fio_peer_addr(client2).data);\n  {\n    char tmp_buf[28];\n    ssize_t r = -1;\n    ssize_t timer_junk;\n    fio_write(client1, \"Hello World\", 11);\n    if (0) {\n      /* packet may have been sent synchronously, don't test */\n      if (!uuid_data(client1).packet)\n        unlink(__FILE__ \".sock\");\n      FIO_ASSERT(uuid_data(client1).packet, \"fio_write error, no packet!\")\n    }\n    /* prevent poll from hanging */\n    fio_run_every(5, 1, fio_timer_test_task, &timer_junk, fio_timer_test_task);\n    errno = EAGAIN;\n    for (size_t i = 0; i < 100 && r <= 0 &&\n                       (r == 0 || errno == EAGAIN || errno == EWOULDBLOCK);\n         ++i) {\n      fio_poll();\n      fio_defer_perform();\n      fio_reschedule_thread();\n      errno = 0;\n      r = fio_read(client2, tmp_buf, 28);\n    }\n    if (!(r > 0 && r <= 28) || memcmp(\"Hello World\", tmp_buf, r)) {\n      perror(\"* ernno\");\n      unlink(__FILE__ \".sock\");\n    }\n    FIO_ASSERT(r > 0 && r <= 28,\n               \"Failed to read from unix socket \" __FILE__ \".sock %zd\", r);\n    FIO_ASSERT(!memcmp(\"Hello World\", tmp_buf, r),\n               \"Unix socket Read/Write cycle error (%zd: %.*s)\", r, (int)r,\n               tmp_buf);\n    fprintf(stderr, \"* Unix socket Read/Write cycle passed: %.*s\\n\", (int)r,\n            tmp_buf);\n    fio_data->last_cycle.tv_sec += 10;\n    fio_timer_clear_all();\n  }\n\n  fio_force_close(client1);\n  fio_force_close(client2);\n  fio_force_close(uuid);\n  unlink(fio_str_data(&sock_name));\n  /* free unix socket name */\n  fio_str_free(&sock_name);\n\n  uuid = fio_socket(NULL, \"8765\", 1);\n  FIO_ASSERT(uuid != -1, \"Failed to open TCP/IP socket on port 8765\");\n  FIO_ASSERT(uuid_data(uuid).open, \"TCP/IP socket not initialized\");\n  fprintf(stderr, \"* TCP/IP server addr %s\\n\", fio_peer_addr(uuid).data);\n  client1 = fio_socket(\"Localhost\", \"8765\", 0);\n  FIO_ASSERT(client1 != -1, \"Failed to connect to TCP/IP socket on port 8765\");\n  fprintf(stderr, \"* TCP/IP client1 addr %s\\n\", fio_peer_addr(client1).data);\n  errno = EAGAIN;\n  for (size_t i = 0; i < 100 && (errno == EAGAIN || errno == EWOULDBLOCK);\n       ++i) {\n    errno = 0;\n    fio_reschedule_thread();\n    client2 = fio_accept(uuid);\n  }\n  if (client2 == -1)\n    perror(\"accept error\");\n  FIO_ASSERT(client2 != -1,\n             \"Failed to accept TCP/IP socket connection on port 8765\");\n  fprintf(stderr, \"* TCP/IP client2 addr %s\\n\", fio_peer_addr(client2).data);\n  fio_force_close(client1);\n  fio_force_close(client2);\n  fio_force_close(uuid);\n  fio_timer_clear_all();\n  fio_defer_clear_tasks();\n  fprintf(stderr, \"* passed.\\n\");\n}\n\n/* *****************************************************************************\nTesting listening socket\n***************************************************************************** */\n\nFIO_FUNC void fio_cycle_test_task(void *arg) {\n  fio_stop();\n  (void)arg;\n}\nFIO_FUNC void fio_cycle_test_task2(void *arg) {\n  fprintf(stderr, \"* facil.io cycling test fatal error!\\n\");\n  exit(-1);\n  (void)arg;\n}\n\nFIO_FUNC void fio_cycle_test(void) {\n  fprintf(stderr,\n          \"=== Testing facil.io cycling logic (partial - only tests timers)\\n\");\n  fio_mark_time();\n  fio_timer_clear_all();\n  struct timespec start = fio_last_tick();\n  fio_run_every(1000, 1, fio_cycle_test_task, NULL, NULL);\n  fio_run_every(10000, 1, fio_cycle_test_task2, NULL, NULL);\n  fio_start(.threads = 1, .workers = 1);\n  struct timespec end = fio_last_tick();\n  fio_timer_clear_all();\n  FIO_ASSERT(end.tv_sec == start.tv_sec + 1 || end.tv_sec == start.tv_sec + 2,\n             \"facil.io cycling error?\");\n  fprintf(stderr, \"* passed.\\n\");\n}\n/* *****************************************************************************\nTesting fio_defer task system\n***************************************************************************** */\n\n#define FIO_DEFER_TOTAL_COUNT (512 * 1024)\n\n#ifndef FIO_DEFER_TEST_PRINT\n#define FIO_DEFER_TEST_PRINT 0\n#endif\n\nFIO_FUNC void sample_task(void *i_count, void *unused2) {\n  (void)(unused2);\n  fio_atomic_add((uintptr_t *)i_count, 1);\n}\n\nFIO_FUNC void sched_sample_task(void *count, void *i_count) {\n  for (size_t i = 0; i < (uintptr_t)count; i++) {\n    fio_defer(sample_task, i_count, NULL);\n  }\n}\n\nFIO_FUNC void fio_defer_test(void) {\n  const size_t cpu_cores = fio_detect_cpu_cores();\n  FIO_ASSERT(cpu_cores, \"couldn't detect CPU cores!\");\n  uintptr_t i_count;\n  clock_t start, end;\n  fprintf(stderr, \"=== Testing facil.io task scheduling (fio_defer)\\n\");\n  FIO_ASSERT(!fio_defer_has_queue(), \"facil.io queue always active.\")\n  i_count = 0;\n  start = clock();\n  for (size_t i = 0; i < FIO_DEFER_TOTAL_COUNT; i++) {\n    sample_task(&i_count, NULL);\n  }\n  end = clock();\n  if (FIO_DEFER_TEST_PRINT) {\n    fprintf(stderr,\n            \"Deferless (direct call) counter: %lu cycles with i_count = %lu, \"\n            \"%lu/%lu free/malloc\\n\",\n            (unsigned long)(end - start), (unsigned long)i_count,\n            (unsigned long)fio_defer_count_dealloc,\n            (unsigned long)fio_defer_count_alloc);\n  }\n  size_t i_count_should_be = i_count;\n\n  if (FIO_DEFER_TEST_PRINT) {\n    fprintf(stderr, \"\\n\");\n  }\n\n  for (size_t i = 1; FIO_DEFER_TOTAL_COUNT >> i; ++i) {\n    i_count = 0;\n    const size_t per_task = FIO_DEFER_TOTAL_COUNT >> i;\n    const size_t tasks = 1 << i;\n    start = clock();\n    for (size_t j = 0; j < tasks; ++j) {\n      fio_defer(sched_sample_task, (void *)per_task, &i_count);\n    }\n    FIO_ASSERT(fio_defer_has_queue(), \"facil.io queue not marked.\")\n    fio_defer_thread_pool_join(fio_defer_thread_pool_new((i % cpu_cores) + 1));\n    end = clock();\n    if (FIO_DEFER_TEST_PRINT) {\n      fprintf(stderr,\n              \"- Defer %zu threads, %zu scheduling loops (%zu each):\\n\"\n              \"    %lu cycles with i_count = %lu, %lu/%lu \"\n              \"free/malloc\\n\",\n              ((i % cpu_cores) + 1), tasks, per_task,\n              (unsigned long)(end - start), (unsigned long)i_count,\n              (unsigned long)fio_defer_count_dealloc,\n              (unsigned long)fio_defer_count_alloc);\n    } else {\n      fprintf(stderr, \".\");\n    }\n    FIO_ASSERT(i_count == i_count_should_be, \"ERROR: defer count invalid\\n\");\n    FIO_ASSERT(fio_defer_count_dealloc == fio_defer_count_alloc,\n               \"defer deallocation vs. allocation error, %zu != %zu\",\n               fio_defer_count_dealloc, fio_defer_count_alloc);\n  }\n  FIO_ASSERT(task_queue_normal.writer == &task_queue_normal.static_queue,\n             \"defer library didn't release dynamic queue (should be static)\");\n  fprintf(stderr, \"\\n* passed.\\n\");\n}\n\n/* *****************************************************************************\nArray data-structure Testing\n***************************************************************************** */\n\ntypedef struct {\n  int i;\n  char c;\n} fio_ary_test_type_s;\n\n#define FIO_ARY_NAME fio_i_ary\n#define FIO_ARY_TYPE uintptr_t\n#include \"fio.h\"\n\nFIO_FUNC intptr_t ary_alloc_counter = 0;\nFIO_FUNC void copy_s(fio_ary_test_type_s *d, fio_ary_test_type_s *s) {\n  ++ary_alloc_counter;\n  *d = *s;\n}\n\n#define FIO_ARY_NAME fio_s_ary\n#define FIO_ARY_TYPE fio_ary_test_type_s\n#define FIO_ARY_COPY(dest, src) copy_s(&(dest), &(src))\n#define FIO_ARY_COMPARE(dest, src) ((dest).i == (src).i && (dest).c == (src).c)\n#define FIO_ARY_DESTROY(obj) (--ary_alloc_counter)\n#include \"fio.h\"\n\nFIO_FUNC void fio_ary_test(void) {\n  /* code */\n  fio_i_ary__test();\n  fio_s_ary__test();\n  FIO_ASSERT(!ary_alloc_counter, \"array object deallocation error, %ld != 0\",\n             ary_alloc_counter);\n}\n\n/* *****************************************************************************\nSet data-structure Testing\n***************************************************************************** */\n\n#define FIO_SET_TEST_COUNT 524288UL\n\n#define FIO_SET_NAME fio_set_test\n#define FIO_SET_OBJ_TYPE uintptr_t\n#include <fio.h>\n\n#define FIO_SET_NAME fio_hash_test\n#define FIO_SET_KEY_TYPE uintptr_t\n#define FIO_SET_OBJ_TYPE uintptr_t\n#include <fio.h>\n\n#define FIO_SET_NAME fio_set_attack\n#define FIO_SET_OBJ_COMPARE(a, b) ((a) == (b))\n#define FIO_SET_OBJ_TYPE uintptr_t\n#include <fio.h>\n\nFIO_FUNC void fio_set_test(void) {\n  fio_set_test_s s = FIO_SET_INIT;\n  fio_hash_test_s h = FIO_SET_INIT;\n  fprintf(\n      stderr,\n      \"=== Testing Core ordered Set (re-including fio.h with FIO_SET_NAME)\\n\");\n  fprintf(stderr, \"* Inserting %lu items\\n\", FIO_SET_TEST_COUNT);\n\n  FIO_ASSERT(fio_set_test_count(&s) == 0, \"empty set should have zero objects\");\n  FIO_ASSERT(fio_set_test_capa(&s) == 0, \"empty set should have no capacity\");\n  FIO_ASSERT(fio_hash_test_capa(&h) == 0, \"empty hash should have no capacity\");\n  FIO_ASSERT(!fio_set_test_is_fragmented(&s),\n             \"empty set shouldn't be considered fragmented\");\n  FIO_ASSERT(!fio_hash_test_is_fragmented(&h),\n             \"empty hash shouldn't be considered fragmented\");\n  FIO_ASSERT(!fio_set_test_last(&s), \"empty set shouldn't have a last object\");\n  FIO_ASSERT(!fio_hash_test_last(&h).key && !fio_hash_test_last(&h).obj,\n             \"empty hash shouldn't have a last object\");\n\n  for (uintptr_t i = 1; i < FIO_SET_TEST_COUNT; ++i) {\n    fio_set_test_insert(&s, i, i);\n    fio_hash_test_insert(&h, i, i, i + 1, NULL);\n    FIO_ASSERT(fio_set_test_find(&s, i, i), \"set find failed after insert\");\n    FIO_ASSERT(fio_hash_test_find(&h, i, i), \"hash find failed after insert\");\n    FIO_ASSERT(i == fio_set_test_find(&s, i, i), \"set insertion != find\");\n    FIO_ASSERT(i + 1 == fio_hash_test_find(&h, i, i), \"hash insertion != find\");\n  }\n  fprintf(stderr, \"* Seeking %lu items\\n\", FIO_SET_TEST_COUNT);\n  for (unsigned long i = 1; i < FIO_SET_TEST_COUNT; ++i) {\n    FIO_ASSERT((i == fio_set_test_find(&s, i, i)),\n               \"set insertion != find (seek)\");\n    FIO_ASSERT((i + 1 == fio_hash_test_find(&h, i, i)),\n               \"hash insertion != find (seek)\");\n  }\n  {\n    fprintf(stderr, \"* Testing order for %lu items in set\\n\",\n            FIO_SET_TEST_COUNT);\n    uintptr_t i = 1;\n    FIO_SET_FOR_LOOP(&s, pos) {\n      FIO_ASSERT(pos->obj == i, \"object order mismatch %lu != %lu.\",\n                 (unsigned long)i, (unsigned long)pos->obj);\n      ++i;\n    }\n  }\n  {\n    fprintf(stderr, \"* Testing order for %lu items in hash\\n\",\n            FIO_SET_TEST_COUNT);\n    uintptr_t i = 1;\n    FIO_SET_FOR_LOOP(&h, pos) {\n      FIO_ASSERT(pos->obj.obj == i + 1 && pos->obj.key == i,\n                 \"object order mismatch %lu != %lu.\", (unsigned long)i,\n                 (unsigned long)pos->obj.key);\n      ++i;\n    }\n  }\n\n  fprintf(stderr, \"* Removing odd items from %lu items\\n\", FIO_SET_TEST_COUNT);\n  for (unsigned long i = 1; i < FIO_SET_TEST_COUNT; i += 2) {\n    fio_set_test_remove(&s, i, i, NULL);\n    fio_hash_test_remove(&h, i, i, NULL);\n    FIO_ASSERT(!(fio_set_test_find(&s, i, i)),\n               \"Removal failed in set (still exists).\");\n    FIO_ASSERT(!(fio_hash_test_find(&h, i, i)),\n               \"Removal failed in hash (still exists).\");\n  }\n  {\n    fprintf(stderr, \"* Testing for %lu / 2 holes\\n\", FIO_SET_TEST_COUNT);\n    uintptr_t i = 1;\n    FIO_SET_FOR_LOOP(&s, pos) {\n      if (pos->hash == 0) {\n        FIO_ASSERT((i & 1) == 1, \"deleted object wasn't odd\");\n      } else {\n        FIO_ASSERT(pos->obj == i, \"deleted object value mismatch %lu != %lu\",\n                   (unsigned long)i, (unsigned long)pos->obj);\n      }\n      ++i;\n    }\n    i = 1;\n    FIO_SET_FOR_LOOP(&h, pos) {\n      if (pos->hash == 0) {\n        FIO_ASSERT((i & 1) == 1, \"deleted object wasn't odd\");\n      } else {\n        FIO_ASSERT(pos->obj.key == i,\n                   \"deleted object value mismatch %lu != %lu\", (unsigned long)i,\n                   (unsigned long)pos->obj.key);\n      }\n      ++i;\n    }\n    {\n      fprintf(stderr, \"* Poping two elements (testing pop through holes)\\n\");\n      FIO_ASSERT(fio_set_test_last(&s), \"Pop `last` 1 failed - no last object\");\n      uintptr_t tmp = fio_set_test_last(&s);\n      FIO_ASSERT(tmp, \"Pop set `last` 1 failed to collect object\");\n      fio_set_test_pop(&s);\n      FIO_ASSERT(\n          fio_set_test_last(&s) != tmp,\n          \"Pop `last` 2 in set same as `last` 1 - failed to collect object\");\n      tmp = fio_hash_test_last(&h).key;\n      FIO_ASSERT(tmp, \"Pop hash `last` 1 failed to collect object\");\n      fio_hash_test_pop(&h);\n      FIO_ASSERT(\n          fio_hash_test_last(&h).key != tmp,\n          \"Pop `last` 2 in hash same as `last` 1 - failed to collect object\");\n      FIO_ASSERT(fio_set_test_last(&s), \"Pop `last` 2 failed - no last object\");\n      FIO_ASSERT(fio_hash_test_last(&h).obj,\n                 \"Pop `last` 2 failed in hash - no last object\");\n      fio_set_test_pop(&s);\n      fio_hash_test_pop(&h);\n    }\n    if (1) {\n      uintptr_t tmp = 1;\n      fio_set_test_remove(&s, tmp, tmp, NULL);\n      fio_hash_test_remove(&h, tmp, tmp, NULL);\n      size_t count = s.count;\n      fio_set_test_overwrite(&s, tmp, tmp, NULL);\n      FIO_ASSERT(\n          count + 1 == s.count,\n          \"Re-adding a removed item in set should increase count by 1 (%zu + \"\n          \"1 != %zu).\",\n          count, (size_t)s.count);\n      count = h.count;\n      fio_hash_test_insert(&h, tmp, tmp, tmp, NULL);\n      FIO_ASSERT(\n          count + 1 == h.count,\n          \"Re-adding a removed item in hash should increase count by 1 (%zu + \"\n          \"1 != %zu).\",\n          count, (size_t)s.count);\n      tmp = fio_set_test_find(&s, tmp, tmp);\n      FIO_ASSERT(tmp == 1,\n                 \"Re-adding a removed item should update the item in the set \"\n                 \"(%lu != 1)!\",\n                 (unsigned long)fio_set_test_find(&s, tmp, tmp));\n      fio_set_test_remove(&s, tmp, tmp, NULL);\n      fio_hash_test_remove(&h, tmp, tmp, NULL);\n      FIO_ASSERT(count == h.count,\n                 \"Re-removing an item should decrease count (%zu != %zu).\",\n                 count, (size_t)s.count);\n      FIO_ASSERT(!fio_set_test_find(&s, tmp, tmp),\n                 \"Re-removing a re-added item should update the item!\");\n    }\n  }\n  fprintf(stderr, \"* Compacting HashMap to %lu\\n\", FIO_SET_TEST_COUNT >> 1);\n  fio_set_test_compact(&s);\n  {\n    fprintf(stderr, \"* Testing that %lu items are continuous\\n\",\n            FIO_SET_TEST_COUNT >> 1);\n    uintptr_t i = 0;\n    FIO_SET_FOR_LOOP(&s, pos) {\n      FIO_ASSERT(pos->hash != 0, \"Found a hole after compact.\");\n      ++i;\n    }\n    FIO_ASSERT(i == s.count, \"count error (%lu != %lu).\", i, s.count);\n  }\n\n  fio_set_test_free(&s);\n  fio_hash_test_free(&h);\n  FIO_ASSERT(!s.map && !s.ordered && !s.pos && !s.capa,\n             \"HashMap not re-initialized after free.\");\n\n  fio_set_test_capa_require(&s, FIO_SET_TEST_COUNT);\n\n  FIO_ASSERT(\n      s.map && s.ordered && !s.pos && s.capa >= FIO_SET_TEST_COUNT,\n      \"capa_require changes state in a bad way (%p, %p, %zu, %zu ?>= %zu)\",\n      (void *)s.map, (void *)s.ordered, s.pos, s.capa, FIO_SET_TEST_COUNT);\n\n  for (unsigned long i = 1; i < FIO_SET_TEST_COUNT; ++i) {\n    fio_set_test_insert(&s, i, i);\n    FIO_ASSERT(fio_set_test_find(&s, i, i),\n               \"find failed after insert (2nd round)\");\n    FIO_ASSERT(i == fio_set_test_find(&s, i, i),\n               \"insertion (2nd round) != find\");\n    FIO_ASSERT(i == s.count, \"count error (%lu != %lu) post insertion.\", i,\n               s.count);\n  }\n  fio_set_test_free(&s);\n  /* full/partial collision attack against set and test response */\n  if (1) {\n    fio_set_attack_s as = FIO_SET_INIT;\n    time_t start_ok = clock();\n    for (uintptr_t i = 0; i < FIO_SET_TEST_COUNT; ++i) {\n      fio_set_attack_insert(&as, i, i + 1);\n      FIO_ASSERT(fio_set_attack_find(&as, i, i + 1) == i + 1,\n                 \"set attack verctor failed sanity test (seek != insert)\");\n    }\n    time_t end_ok = clock();\n    FIO_ASSERT(fio_set_attack_count(&as) == FIO_SET_TEST_COUNT,\n               \"set attack verctor failed sanity test (count error %zu != %zu)\",\n               fio_set_attack_count(&as), FIO_SET_TEST_COUNT);\n    fio_set_attack_free(&as);\n\n    /* full collision attack */\n    time_t start_bad = clock();\n    for (uintptr_t i = 0; i < FIO_SET_TEST_COUNT; ++i) {\n      fio_set_attack_insert(&as, 1, i + 1);\n    }\n    time_t end_bad = clock();\n    FIO_ASSERT(fio_set_attack_count(&as) != FIO_SET_TEST_COUNT,\n               \"set attack success! too many full-collisions inserts!\");\n    FIO_LOG_DEBUG(\"set full-collision attack final count/capa = %zu / %zu\",\n                  fio_set_attack_count(&as), fio_set_attack_capa(&as));\n    FIO_LOG_DEBUG(\"set full-collision attack timing impact (attack vs. normal) \"\n                  \"%zu vs. %zu\",\n                  end_bad - start_bad, end_ok - start_ok);\n    fio_set_attack_free(&as);\n\n    /* partial collision attack */\n    start_bad = clock();\n    for (uintptr_t i = 0; i < FIO_SET_TEST_COUNT; ++i) {\n      fio_set_attack_insert(&as, ((i << 20) | 1), i + 1);\n    }\n    end_bad = clock();\n    FIO_ASSERT(fio_set_attack_count(&as) == FIO_SET_TEST_COUNT,\n               \"partial collision resolusion failed, not enough inserts!\");\n    FIO_LOG_DEBUG(\"set partial collision attack final count/capa = %zu / %zu\",\n                  fio_set_attack_count(&as), fio_set_attack_capa(&as));\n    FIO_LOG_DEBUG(\"set partial collision attack timing impact (attack vs. \"\n                  \"normal) %zu vs. %zu\",\n                  end_bad - start_bad, end_ok - start_ok);\n    fio_set_attack_free(&as);\n  }\n}\n\n/* *****************************************************************************\nBad Hash (risky hash) tests\n***************************************************************************** */\n\nFIO_FUNC void fio_riskyhash_speed_test(void) {\n  /* test based on code from BearSSL with credit to Thomas Pornin */\n  uint8_t buffer[8192];\n  memset(buffer, 'T', sizeof(buffer));\n  /* warmup */\n  uint64_t hash = 0;\n  for (size_t i = 0; i < 4; i++) {\n    hash += fio_risky_hash(buffer, 8192, 1);\n    memcpy(buffer, &hash, sizeof(hash));\n  }\n  /* loop until test runs for more than 2 seconds */\n  for (uint64_t cycles = 8192;;) {\n    clock_t start, end;\n    start = clock();\n    for (size_t i = cycles; i > 0; i--) {\n      hash += fio_risky_hash(buffer, 8192, 1);\n      __asm__ volatile(\"\" ::: \"memory\");\n    }\n    end = clock();\n    memcpy(buffer, &hash, sizeof(hash));\n    if ((end - start) >= (2 * CLOCKS_PER_SEC) ||\n        cycles >= ((uint64_t)1 << 62)) {\n      fprintf(stderr, \"%-20s %8.2f MB/s\\n\", \"fio_risky_hash\",\n              (double)(sizeof(buffer) * cycles) /\n                  (((end - start) * 1000000.0 / CLOCKS_PER_SEC)));\n      break;\n    }\n    cycles <<= 2;\n  }\n}\n\nFIO_FUNC void fio_riskyhash_test(void) {\n  fprintf(stderr, \"===================================\\n\");\n#if NODEBUG\n  fio_riskyhash_speed_test();\n#else\n  fprintf(stderr, \"fio_risky_hash speed test skipped (debug mode is slow)\\n\");\n  fio_str_info_s str1 =\n      (fio_str_info_s){.data = \"nothing_is_really_here1\", .len = 23};\n  fio_str_info_s str2 =\n      (fio_str_info_s){.data = \"nothing_is_really_here2\", .len = 23};\n  fio_str_s copy = FIO_STR_INIT;\n  FIO_ASSERT(fio_risky_hash(str1.data, str1.len, 1) !=\n                 fio_risky_hash(str2.data, str2.len, 1),\n             \"Different strings should have a different risky hash\");\n  fio_str_write(&copy, str1.data, str1.len);\n  FIO_ASSERT(fio_risky_hash(str1.data, str1.len, 1) ==\n                 fio_risky_hash(fio_str_data(&copy), fio_str_len(&copy), 1),\n             \"Same string values should have the same risky hash\");\n  fio_str_free(&copy);\n  (void)fio_riskyhash_speed_test;\n#endif\n}\n\n/* *****************************************************************************\nSipHash tests\n***************************************************************************** */\n\nFIO_FUNC void fio_siphash_speed_test(void) {\n  /* test based on code from BearSSL with credit to Thomas Pornin */\n  uint8_t buffer[8192];\n  memset(buffer, 'T', sizeof(buffer));\n  /* warmup */\n  uint64_t hash = 0;\n  for (size_t i = 0; i < 4; i++) {\n    hash += fio_siphash24(buffer, sizeof(buffer), 0, 0);\n    memcpy(buffer, &hash, sizeof(hash));\n  }\n  /* loop until test runs for more than 2 seconds */\n  for (uint64_t cycles = 8192;;) {\n    clock_t start, end;\n    start = clock();\n    for (size_t i = cycles; i > 0; i--) {\n      hash += fio_siphash24(buffer, sizeof(buffer), 0, 0);\n      __asm__ volatile(\"\" ::: \"memory\");\n    }\n    end = clock();\n    memcpy(buffer, &hash, sizeof(hash));\n    if ((end - start) >= (2 * CLOCKS_PER_SEC) ||\n        cycles >= ((uint64_t)1 << 62)) {\n      fprintf(stderr, \"%-20s %8.2f MB/s\\n\", \"fio SipHash24\",\n              (double)(sizeof(buffer) * cycles) /\n                  (((end - start) * 1000000.0 / CLOCKS_PER_SEC)));\n      break;\n    }\n    cycles <<= 2;\n  }\n  /* loop until test runs for more than 2 seconds */\n  for (uint64_t cycles = 8192;;) {\n    clock_t start, end;\n    start = clock();\n    for (size_t i = cycles; i > 0; i--) {\n      hash += fio_siphash13(buffer, sizeof(buffer), 0, 0);\n      __asm__ volatile(\"\" ::: \"memory\");\n    }\n    end = clock();\n    memcpy(buffer, &hash, sizeof(hash));\n    if ((end - start) >= (2 * CLOCKS_PER_SEC) ||\n        cycles >= ((uint64_t)1 << 62)) {\n      fprintf(stderr, \"%-20s %8.2f MB/s\\n\", \"fio SipHash13\",\n              (double)(sizeof(buffer) * cycles) /\n                  (((end - start) * 1000000.0 / CLOCKS_PER_SEC)));\n      break;\n    }\n    cycles <<= 2;\n  }\n}\n\nFIO_FUNC void fio_siphash_test(void) {\n  fprintf(stderr, \"===================================\\n\");\n#if NODEBUG\n  fio_siphash_speed_test();\n#else\n  fprintf(stderr, \"fio SipHash speed test skipped (debug mode is slow)\\n\");\n  (void)fio_siphash_speed_test;\n#endif\n}\n/* *****************************************************************************\nSHA-1 tests\n***************************************************************************** */\n\nFIO_FUNC void fio_sha1_speed_test(void) {\n  /* test based on code from BearSSL with credit to Thomas Pornin */\n  uint8_t buffer[8192];\n  uint8_t result[21];\n  fio_sha1_s sha1;\n  memset(buffer, 'T', sizeof(buffer));\n  /* warmup */\n  for (size_t i = 0; i < 4; i++) {\n    sha1 = fio_sha1_init();\n    fio_sha1_write(&sha1, buffer, sizeof(buffer));\n    memcpy(result, fio_sha1_result(&sha1), 21);\n  }\n  /* loop until test runs for more than 2 seconds */\n  for (size_t cycles = 8192;;) {\n    clock_t start, end;\n    sha1 = fio_sha1_init();\n    start = clock();\n    for (size_t i = cycles; i > 0; i--) {\n      fio_sha1_write(&sha1, buffer, sizeof(buffer));\n      __asm__ volatile(\"\" ::: \"memory\");\n    }\n    end = clock();\n    fio_sha1_result(&sha1);\n    if ((end - start) >= (2 * CLOCKS_PER_SEC)) {\n      fprintf(stderr, \"%-20s %8.2f MB/s\\n\", \"fio SHA-1\",\n              (double)(sizeof(buffer) * cycles) /\n                  (((end - start) * 1000000.0 / CLOCKS_PER_SEC)));\n      break;\n    }\n    cycles <<= 1;\n  }\n}\n\n#ifdef HAVE_OPENSSL\nFIO_FUNC void fio_sha1_open_ssl_speed_test(void) {\n  /* test based on code from BearSSL with credit to Thomas Pornin */\n  uint8_t buffer[8192];\n  uint8_t result[21];\n  SHA_CTX o_sh1;\n  memset(buffer, 'T', sizeof(buffer));\n  /* warmup */\n  for (size_t i = 0; i < 4; i++) {\n    SHA1_Init(&o_sh1);\n    SHA1_Update(&o_sh1, buffer, sizeof(buffer));\n    SHA1_Final(result, &o_sh1);\n  }\n  /* loop until test runs for more than 2 seconds */\n  for (size_t cycles = 8192;;) {\n    clock_t start, end;\n    SHA1_Init(&o_sh1);\n    start = clock();\n    for (size_t i = cycles; i > 0; i--) {\n      SHA1_Update(&o_sh1, buffer, sizeof(buffer));\n      __asm__ volatile(\"\" ::: \"memory\");\n    }\n    end = clock();\n    SHA1_Final(result, &o_sh1);\n    if ((end - start) >= (2 * CLOCKS_PER_SEC)) {\n      fprintf(stderr, \"%-20s %8.2f MB/s\\n\", \"OpenSSL SHA-1\",\n              (double)(sizeof(buffer) * cycles) /\n                  (((end - start) * 1000000.0 / CLOCKS_PER_SEC)));\n      break;\n    }\n    cycles <<= 1;\n  }\n}\n#endif\n\nFIO_FUNC void fio_sha1_test(void) {\n  // clang-format off\n  struct {\n    char *str;\n    uint8_t hash[21];\n  } sets[] = {\n      {\"The quick brown fox jumps over the lazy dog\",\n       {0x2f, 0xd4, 0xe1, 0xc6, 0x7a, 0x2d, 0x28, 0xfc, 0xed, 0x84, 0x9e,\n        0xe1, 0xbb, 0x76, 0xe7, 0x39, 0x1b, 0x93, 0xeb, 0x12, 0}}, // a set with\n                                                                   // a string\n      {\"\",\n       {\n           0xda, 0x39, 0xa3, 0xee, 0x5e, 0x6b, 0x4b, 0x0d, 0x32, 0x55,\n           0xbf, 0xef, 0x95, 0x60, 0x18, 0x90, 0xaf, 0xd8, 0x07, 0x09,\n       }},        // an empty set\n      {NULL, {0}} // Stop\n  };\n  // clang-format on\n  int i = 0;\n  fio_sha1_s sha1;\n  fprintf(stderr, \"===================================\\n\");\n  fprintf(stderr, \"fio SHA-1 struct size: %zu\\n\", sizeof(fio_sha1_s));\n  fprintf(stderr, \"+ fio\");\n  while (sets[i].str) {\n    sha1 = fio_sha1_init();\n    fio_sha1_write(&sha1, sets[i].str, strlen(sets[i].str));\n    if (strcmp(fio_sha1_result(&sha1), (char *)sets[i].hash)) {\n      fprintf(stderr, \":\\n--- fio SHA-1 Test FAILED!\\nstring: %s\\nexpected: \",\n              sets[i].str);\n      char *p = (char *)sets[i].hash;\n      while (*p)\n        fprintf(stderr, \"%02x\", *(p++) & 0xFF);\n      fprintf(stderr, \"\\ngot: \");\n      p = fio_sha1_result(&sha1);\n      while (*p)\n        fprintf(stderr, \"%02x\", *(p++) & 0xFF);\n      fprintf(stderr, \"\\n\");\n      FIO_ASSERT(0, \"SHA-1 failure.\");\n      return;\n    }\n    i++;\n  }\n  fprintf(stderr, \" SHA-1 passed.\\n\");\n#if NODEBUG\n  fio_sha1_speed_test();\n#else\n  fprintf(stderr, \"fio SHA1 speed test skipped (debug mode is slow)\\n\");\n  (void)fio_sha1_speed_test;\n#endif\n\n#ifdef HAVE_OPENSSL\n\n#if NODEBUG\n  fio_sha1_open_ssl_speed_test();\n#else\n  fprintf(stderr, \"OpenSSL SHA1 speed test skipped (debug mode is slow)\\n\");\n  (void)fio_sha1_open_ssl_speed_test;\n#endif\n  fprintf(stderr, \"===================================\\n\");\n  fprintf(stderr, \"fio SHA-1 struct size: %lu\\n\",\n          (unsigned long)sizeof(fio_sha1_s));\n  fprintf(stderr, \"OpenSSL SHA-1 struct size: %lu\\n\",\n          (unsigned long)sizeof(SHA_CTX));\n  fprintf(stderr, \"===================================\\n\");\n#endif /* HAVE_OPENSSL */\n}\n\n/* *****************************************************************************\nSHA-2 tests\n***************************************************************************** */\n\nFIO_FUNC char *sha2_variant_names[] = {\n    \"unknown\", \"SHA_512\",     \"SHA_256\", \"SHA_512_256\",\n    \"SHA_224\", \"SHA_512_224\", \"none\",    \"SHA_384\",\n};\n\nFIO_FUNC void fio_sha2_speed_test(fio_sha2_variant_e var,\n                                  const char *var_name) {\n  /* test based on code from BearSSL with credit to Thomas Pornin */\n  uint8_t buffer[8192];\n  uint8_t result[65];\n  fio_sha2_s sha2;\n  memset(buffer, 'T', sizeof(buffer));\n  /* warmup */\n  for (size_t i = 0; i < 4; i++) {\n    sha2 = fio_sha2_init(var);\n    fio_sha2_write(&sha2, buffer, sizeof(buffer));\n    memcpy(result, fio_sha2_result(&sha2), 65);\n  }\n  /* loop until test runs for more than 2 seconds */\n  for (size_t cycles = 8192;;) {\n    clock_t start, end;\n    sha2 = fio_sha2_init(var);\n    start = clock();\n    for (size_t i = cycles; i > 0; i--) {\n      fio_sha2_write(&sha2, buffer, sizeof(buffer));\n      __asm__ volatile(\"\" ::: \"memory\");\n    }\n    end = clock();\n    fio_sha2_result(&sha2);\n    if ((end - start) >= (2 * CLOCKS_PER_SEC)) {\n      fprintf(stderr, \"%-20s %8.2f MB/s\\n\", var_name,\n              (double)(sizeof(buffer) * cycles) /\n                  (((end - start) * 1000000.0 / CLOCKS_PER_SEC)));\n      break;\n    }\n    cycles <<= 1;\n  }\n}\n\nFIO_FUNC void fio_sha2_openssl_speed_test(const char *var_name, int (*init)(),\n                                          int (*update)(), int (*final)(),\n                                          void *sha) {\n  /* test adapted from BearSSL code with credit to Thomas Pornin */\n  uint8_t buffer[8192];\n  uint8_t result[1024];\n  memset(buffer, 'T', sizeof(buffer));\n  /* warmup */\n  for (size_t i = 0; i < 4; i++) {\n    init(sha);\n    update(sha, buffer, sizeof(buffer));\n    final(result, sha);\n  }\n  /* loop until test runs for more than 2 seconds */\n  for (size_t cycles = 2048;;) {\n    clock_t start, end;\n    init(sha);\n    start = clock();\n    for (size_t i = cycles; i > 0; i--) {\n      update(sha, buffer, sizeof(buffer));\n      __asm__ volatile(\"\" ::: \"memory\");\n    }\n    end = clock();\n    final(result, sha);\n    if ((end - start) >= (2 * CLOCKS_PER_SEC)) {\n      fprintf(stderr, \"%-20s %8.2f MB/s\\n\", var_name,\n              (double)(sizeof(buffer) * cycles) /\n                  (((end - start) * 1000000.0 / CLOCKS_PER_SEC)));\n      break;\n    }\n    cycles <<= 1;\n  }\n}\nFIO_FUNC void fio_sha2_test(void) {\n  fio_sha2_s s;\n  char *expect;\n  char *got;\n  char *str = \"\";\n  fprintf(stderr, \"===================================\\n\");\n  fprintf(stderr, \"fio SHA-2 struct size: %zu\\n\", sizeof(fio_sha2_s));\n  fprintf(stderr, \"+ fio\");\n  // start tests\n  s = fio_sha2_init(SHA_224);\n  fio_sha2_write(&s, str, 0);\n  expect = \"\\xd1\\x4a\\x02\\x8c\\x2a\\x3a\\x2b\\xc9\\x47\\x61\\x02\\xbb\\x28\\x82\\x34\\xc4\"\n           \"\\x15\\xa2\\xb0\\x1f\\x82\\x8e\\xa6\\x2a\\xc5\\xb3\\xe4\\x2f\";\n  got = fio_sha2_result(&s);\n  if (strcmp(expect, got))\n    goto error;\n\n  s = fio_sha2_init(SHA_256);\n  fio_sha2_write(&s, str, 0);\n  expect =\n      \"\\xe3\\xb0\\xc4\\x42\\x98\\xfc\\x1c\\x14\\x9a\\xfb\\xf4\\xc8\\x99\\x6f\\xb9\\x24\\x27\"\n      \"\\xae\\x41\\xe4\\x64\\x9b\\x93\\x4c\\xa4\\x95\\x99\\x1b\\x78\\x52\\xb8\\x55\";\n  got = fio_sha2_result(&s);\n  if (strcmp(expect, got))\n    goto error;\n\n  s = fio_sha2_init(SHA_512);\n  fio_sha2_write(&s, str, 0);\n  expect = \"\\xcf\\x83\\xe1\\x35\\x7e\\xef\\xb8\\xbd\\xf1\\x54\\x28\\x50\\xd6\\x6d\"\n           \"\\x80\\x07\\xd6\\x20\\xe4\\x05\\x0b\\x57\\x15\\xdc\\x83\\xf4\\xa9\\x21\"\n           \"\\xd3\\x6c\\xe9\\xce\\x47\\xd0\\xd1\\x3c\\x5d\\x85\\xf2\\xb0\\xff\\x83\"\n           \"\\x18\\xd2\\x87\\x7e\\xec\\x2f\\x63\\xb9\\x31\\xbd\\x47\\x41\\x7a\\x81\"\n           \"\\xa5\\x38\\x32\\x7a\\xf9\\x27\\xda\\x3e\";\n  got = fio_sha2_result(&s);\n  if (strcmp(expect, got))\n    goto error;\n\n  s = fio_sha2_init(SHA_384);\n  fio_sha2_write(&s, str, 0);\n  expect = \"\\x38\\xb0\\x60\\xa7\\x51\\xac\\x96\\x38\\x4c\\xd9\\x32\\x7e\"\n           \"\\xb1\\xb1\\xe3\\x6a\\x21\\xfd\\xb7\\x11\\x14\\xbe\\x07\\x43\\x4c\\x0c\"\n           \"\\xc7\\xbf\\x63\\xf6\\xe1\\xda\\x27\\x4e\\xde\\xbf\\xe7\\x6f\\x65\\xfb\"\n           \"\\xd5\\x1a\\xd2\\xf1\\x48\\x98\\xb9\\x5b\";\n  got = fio_sha2_result(&s);\n  if (strcmp(expect, got))\n    goto error;\n\n  s = fio_sha2_init(SHA_512_224);\n  fio_sha2_write(&s, str, 0);\n  expect = \"\\x6e\\xd0\\xdd\\x02\\x80\\x6f\\xa8\\x9e\\x25\\xde\\x06\\x0c\\x19\\xd3\"\n           \"\\xac\\x86\\xca\\xbb\\x87\\xd6\\xa0\\xdd\\xd0\\x5c\\x33\\x3b\\x84\\xf4\";\n  got = fio_sha2_result(&s);\n  if (strcmp(expect, got))\n    goto error;\n\n  s = fio_sha2_init(SHA_512_256);\n  fio_sha2_write(&s, str, 0);\n  expect = \"\\xc6\\x72\\xb8\\xd1\\xef\\x56\\xed\\x28\\xab\\x87\\xc3\\x62\\x2c\\x51\\x14\\x06\"\n           \"\\x9b\\xdd\\x3a\\xd7\\xb8\\xf9\\x73\\x74\\x98\\xd0\\xc0\\x1e\\xce\\xf0\\x96\\x7a\";\n  got = fio_sha2_result(&s);\n  if (strcmp(expect, got))\n    goto error;\n\n  s = fio_sha2_init(SHA_512);\n  str = \"god is a rotten tomato\";\n  fio_sha2_write(&s, str, strlen(str));\n  expect = \"\\x61\\x97\\x4d\\x41\\x9f\\x77\\x45\\x21\\x09\\x4e\\x95\\xa3\\xcb\\x4d\\xe4\\x79\"\n           \"\\x26\\x32\\x2f\\x2b\\xe2\\x62\\x64\\x5a\\xb4\\x5d\\x3f\\x73\\x69\\xef\\x46\\x20\"\n           \"\\xb2\\xd3\\xce\\xda\\xa9\\xc2\\x2c\\xac\\xe3\\xf9\\x02\\xb2\\x20\\x5d\\x2e\\xfd\"\n           \"\\x40\\xca\\xa0\\xc1\\x67\\xe0\\xdc\\xdf\\x60\\x04\\x3e\\x4e\\x76\\x87\\x82\\x74\";\n  got = fio_sha2_result(&s);\n  if (strcmp(expect, got))\n    goto error;\n\n  // s = fio_sha2_init(SHA_256);\n  // str = \"The quick brown fox jumps over the lazy dog\";\n  // fio_sha2_write(&s, str, strlen(str));\n  // expect =\n  //     \"\\xd7\\xa8\\xfb\\xb3\\x07\\xd7\\x80\\x94\\x69\\xca\\x9a\\xbc\\xb0\\x08\\x2e\\x4f\"\n  //     \"\\x8d\\x56\\x51\\xe4\\x6d\\x3c\\xdb\\x76\\x2d\\x02\\xd0\\xbf\\x37\\xc9\\xe5\\x92\";\n  // got = fio_sha2_result(&s);\n  // if (strcmp(expect, got))\n  //   goto error;\n\n  s = fio_sha2_init(SHA_224);\n  str = \"The quick brown fox jumps over the lazy dog\";\n  fio_sha2_write(&s, str, strlen(str));\n  expect = \"\\x73\\x0e\\x10\\x9b\\xd7\\xa8\\xa3\\x2b\\x1c\\xb9\\xd9\\xa0\\x9a\\xa2\"\n           \"\\x32\\x5d\\x24\\x30\\x58\\x7d\\xdb\\xc0\\xc3\\x8b\\xad\\x91\\x15\\x25\";\n  got = fio_sha2_result(&s);\n  if (strcmp(expect, got))\n    goto error;\n  fprintf(stderr, \" SHA-2 passed.\\n\");\n\n#if NODEBUG\n  fio_sha2_speed_test(SHA_224, \"fio SHA-224\");\n  fio_sha2_speed_test(SHA_256, \"fio SHA-256\");\n  fio_sha2_speed_test(SHA_384, \"fio SHA-384\");\n  fio_sha2_speed_test(SHA_512, \"fio SHA-512\");\n#else\n  fprintf(stderr, \"fio SHA-2 speed test skipped (debug mode is slow)\\n\");\n#endif\n\n#ifdef HAVE_OPENSSL\n\n#if NODEBUG\n  {\n    SHA512_CTX s2;\n    SHA256_CTX s3;\n    fio_sha2_openssl_speed_test(\"OpenSSL SHA512\", SHA512_Init, SHA512_Update,\n                                SHA512_Final, &s2);\n    fio_sha2_openssl_speed_test(\"OpenSSL SHA256\", SHA256_Init, SHA256_Update,\n                                SHA256_Final, &s3);\n  }\n#endif\n  fprintf(stderr, \"===================================\\n\");\n  fprintf(stderr, \"fio SHA-2 struct size: %zu\\n\", sizeof(fio_sha2_s));\n  fprintf(stderr, \"OpenSSL SHA-2/256 struct size: %zu\\n\", sizeof(SHA256_CTX));\n  fprintf(stderr, \"OpenSSL SHA-2/512 struct size: %zu\\n\", sizeof(SHA512_CTX));\n  fprintf(stderr, \"===================================\\n\");\n#endif /* HAVE_OPENSSL */\n\n  return;\n\nerror:\n  fprintf(stderr,\n          \":\\n--- fio SHA-2 Test FAILED!\\ntype: \"\n          \"%s (%d)\\nstring %s\\nexpected:\\n\",\n          sha2_variant_names[s.type], s.type, str);\n  while (*expect)\n    fprintf(stderr, \"%02x\", *(expect++) & 0xFF);\n  fprintf(stderr, \"\\ngot:\\n\");\n  while (*got)\n    fprintf(stderr, \"%02x\", *(got++) & 0xFF);\n  fprintf(stderr, \"\\n\");\n  (void)fio_sha2_speed_test;\n  (void)fio_sha2_openssl_speed_test;\n  FIO_ASSERT(0, \"SHA-2 failure.\");\n}\n\n/* *****************************************************************************\nBase64 tests\n***************************************************************************** */\n\nFIO_FUNC void fio_base64_speed_test(void) {\n  /* test based on code from BearSSL with credit to Thomas Pornin */\n  char buffer[8192];\n  char result[8192 * 2];\n  memset(buffer, 'T', sizeof(buffer));\n  /* warmup */\n  for (size_t i = 0; i < 4; i++) {\n    fio_base64_encode(result, buffer, sizeof(buffer));\n    memcpy(buffer, result, sizeof(buffer));\n  }\n  /* loop until test runs for more than 2 seconds */\n  for (size_t cycles = 8192;;) {\n    clock_t start, end;\n    start = clock();\n    for (size_t i = cycles; i > 0; i--) {\n      fio_base64_encode(result, buffer, sizeof(buffer));\n      __asm__ volatile(\"\" ::: \"memory\");\n    }\n    end = clock();\n    if ((end - start) >= (2 * CLOCKS_PER_SEC)) {\n      fprintf(stderr, \"%-20s %8.2f MB/s\\n\", \"fio Base64 Encode\",\n              (double)(sizeof(buffer) * cycles) /\n                  (((end - start) * 1000000.0 / CLOCKS_PER_SEC)));\n      break;\n    }\n    cycles <<= 2;\n  }\n\n  /* speed test decoding */\n  const int encoded_len =\n      fio_base64_encode(result, buffer, (int)(sizeof(buffer) - 2));\n  /* warmup */\n  for (size_t i = 0; i < 4; i++) {\n    fio_base64_decode(buffer, result, encoded_len);\n    __asm__ volatile(\"\" ::: \"memory\");\n  }\n  /* loop until test runs for more than 2 seconds */\n  for (size_t cycles = 8192;;) {\n    clock_t start, end;\n    start = clock();\n    for (size_t i = cycles; i > 0; i--) {\n      fio_base64_decode(buffer, result, encoded_len);\n      __asm__ volatile(\"\" ::: \"memory\");\n    }\n    end = clock();\n    if ((end - start) >= (2 * CLOCKS_PER_SEC)) {\n      fprintf(stderr, \"%-20s %8.2f MB/s\\n\", \"fio Base64 Decode\",\n              (double)(encoded_len * cycles) /\n                  (((end - start) * 1000000.0 / CLOCKS_PER_SEC)));\n      break;\n    }\n    cycles <<= 2;\n  }\n}\n\nFIO_FUNC void fio_base64_test(void) {\n  struct {\n    char *str;\n    char *base64;\n  } sets[] = {\n      {\"Man is distinguished, not only by his reason, but by this singular \"\n       \"passion from other animals, which is a lust of the mind, that by a \"\n       \"perseverance of delight in the continued \"\n       \"and indefatigable generation \"\n       \"of knowledge, exceeds the short vehemence of any carnal pleasure.\",\n       \"TWFuIGlzIGRpc3Rpbmd1aXNoZWQsIG5vdCBvbmx5IGJ5IGhpcyByZWFzb24sIGJ1dCBieSB\"\n       \"0aGlzIHNpbmd1bGFyIHBhc3Npb24gZnJvbSBvdGhlciBhbmltYWxzLCB3aGljaCBpcyBhIG\"\n       \"x1c3Qgb2YgdGhlIG1pbmQsIHRoYXQgYnkgYSBwZXJzZXZlcmFuY2Ugb2YgZGVsaWdodCBpb\"\n       \"iB0aGUgY29udGludWVkIGFuZCBpbmRlZmF0aWdhYmxlIGdlbmVyYXRpb24gb2Yga25vd2xl\"\n       \"ZGdlLCBleGNlZWRzIHRoZSBzaG9ydCB2ZWhlbWVuY2Ugb2YgYW55IGNhcm5hbCBwbGVhc3V\"\n       \"yZS4=\"},\n      {\"any carnal pleasure.\", \"YW55IGNhcm5hbCBwbGVhc3VyZS4=\"},\n      {\"any carnal pleasure\", \"YW55IGNhcm5hbCBwbGVhc3VyZQ==\"},\n      {\"any carnal pleasur\", \"YW55IGNhcm5hbCBwbGVhc3Vy\"},\n      {\"\", \"\"},\n      {\"f\", \"Zg==\"},\n      {\"fo\", \"Zm8=\"},\n      {\"foo\", \"Zm9v\"},\n      {\"foob\", \"Zm9vYg==\"},\n      {\"fooba\", \"Zm9vYmE=\"},\n      {\"foobar\", \"Zm9vYmFy\"},\n      {NULL, NULL} // Stop\n  };\n  int i = 0;\n  char buffer[1024];\n  fprintf(stderr, \"===================================\\n\");\n  fprintf(stderr, \"+ fio\");\n  while (sets[i].str) {\n    fio_base64_encode(buffer, sets[i].str, strlen(sets[i].str));\n    if (strcmp(buffer, sets[i].base64)) {\n      fprintf(stderr,\n              \":\\n--- fio Base64 Test FAILED!\\nstring: %s\\nlength: %lu\\n \"\n              \"expected: %s\\ngot: %s\\n\\n\",\n              sets[i].str, strlen(sets[i].str), sets[i].base64, buffer);\n      FIO_ASSERT(0, \"Base64 failure.\");\n    }\n    i++;\n  }\n  if (!sets[i].str)\n    fprintf(stderr, \" Base64 encode passed.\\n\");\n\n  i = 0;\n  fprintf(stderr, \"+ fio\");\n  while (sets[i].str) {\n    fio_base64_decode(buffer, sets[i].base64, strlen(sets[i].base64));\n    if (strcmp(buffer, sets[i].str)) {\n      fprintf(stderr,\n              \":\\n--- fio Base64 Test FAILED!\\nbase64: %s\\nexpected: \"\n              \"%s\\ngot: %s\\n\\n\",\n              sets[i].base64, sets[i].str, buffer);\n      FIO_ASSERT(0, \"Base64 failure.\");\n    }\n    i++;\n  }\n  fprintf(stderr, \" Base64 decode passed.\\n\");\n\n#if NODEBUG\n  fio_base64_speed_test();\n#else\n  fprintf(stderr,\n          \"* Base64 speed test skipped (debug speeds are always slow).\\n\");\n  (void)fio_base64_speed_test;\n#endif\n}\n\n/*******************************************************************************\nRandom Testing\n***************************************************************************** */\n\nFIO_FUNC void fio_test_random(void) {\n  fprintf(stderr, \"=== Testing random generator\\n\");\n  uint64_t rnd = fio_rand64();\n  FIO_ASSERT((rnd != fio_rand64() && rnd != fio_rand64()),\n             \"fio_rand64 returned the same result three times in a row.\");\n#if NODEBUG\n  uint64_t buffer1[8];\n  uint8_t buffer2[8192];\n  clock_t start, end;\n  start = clock();\n  for (size_t i = 0; i < (8388608 / (64 / 8)); i++) {\n    buffer1[i & 7] = fio_rand64();\n    __asm__ volatile(\"\" ::: \"memory\");\n  }\n  end = clock();\n  fprintf(stderr,\n          \"+ Random generator available\\n+ created 8Mb using 64bits \"\n          \"Random %lu CPU clock count ~%.2fMb/s\\n\",\n          end - start, (8.0) / (((double)(end - start)) / CLOCKS_PER_SEC));\n  start = clock();\n  for (size_t i = 0; i < (8388608 / (8192)); i++) {\n    fio_rand_bytes(buffer2, 8192);\n    __asm__ volatile(\"\" ::: \"memory\");\n  }\n  end = clock();\n  fprintf(stderr,\n          \"+ created 8Mb using 8,192 Bytes \"\n          \"Random %lu CPU clock count ~%.2fMb/s\\n\",\n          end - start, (8.0) / (((double)(end - start)) / CLOCKS_PER_SEC));\n  (void)buffer1;\n  (void)buffer2;\n#endif\n}\n\n/* *****************************************************************************\nPoll (not kqueue or epoll) tests\n***************************************************************************** */\n#if FIO_ENGINE_POLL\nFIO_FUNC void fio_poll_test(void) {\n  fprintf(stderr, \"=== Testing poll add / remove fd\\n\");\n  fio_poll_add(5);\n  FIO_ASSERT(fio_data->poll[5].fd == 5, \"fio_poll_add didn't set used fd data\");\n  FIO_ASSERT(fio_data->poll[5].events ==\n                 (FIO_POLL_READ_EVENTS | FIO_POLL_WRITE_EVENTS),\n             \"fio_poll_add didn't set used fd flags\");\n  fio_poll_add(7);\n  FIO_ASSERT(fio_data->poll[6].fd == -1,\n             \"fio_poll_add didn't reset unused fd data %d\",\n             fio_data->poll[6].fd);\n  fio_poll_add(6);\n  fio_poll_remove_fd(6);\n  FIO_ASSERT(fio_data->poll[6].fd == -1,\n             \"fio_poll_remove_fd didn't reset unused fd data\");\n  FIO_ASSERT(fio_data->poll[6].events == 0,\n             \"fio_poll_remove_fd didn't reset unused fd flags\");\n  fio_poll_remove_read(7);\n  FIO_ASSERT(fio_data->poll[7].events == (FIO_POLL_WRITE_EVENTS),\n             \"fio_poll_remove_read didn't remove read flags\");\n  fio_poll_add_read(7);\n  fio_poll_remove_write(7);\n  FIO_ASSERT(fio_data->poll[7].events == (FIO_POLL_READ_EVENTS),\n             \"fio_poll_remove_write didn't remove read flags\");\n  fio_poll_add_write(7);\n  fio_poll_remove_read(7);\n  FIO_ASSERT(fio_data->poll[7].events == (FIO_POLL_WRITE_EVENTS),\n             \"fio_poll_add_write didn't add the write flag?\");\n  fio_poll_remove_write(7);\n  FIO_ASSERT(fio_data->poll[7].fd == -1,\n             \"fio_poll_remove (both) didn't reset unused fd data\");\n  FIO_ASSERT(fio_data->poll[7].events == 0,\n             \"fio_poll_remove (both) didn't reset unused fd flags\");\n  fio_poll_remove_fd(5);\n  fprintf(stderr, \"\\n* passed.\\n\");\n}\n#else\n#define fio_poll_test()\n#endif\n\n/* *****************************************************************************\nTest UUID Linking\n***************************************************************************** */\n\nFIO_FUNC void fio_uuid_link_test_on_close(void *obj) {\n  fio_atomic_add((uintptr_t *)obj, 1);\n}\n\nFIO_FUNC void fio_uuid_link_test(void) {\n  fprintf(stderr, \"=== Testing fio_uuid_link\\n\");\n  uintptr_t called = 0;\n  uintptr_t removed = 0;\n  intptr_t uuid = fio_socket(NULL, \"8765\", 1);\n  FIO_ASSERT(uuid != -1, \"fio_uuid_link_test failed to create a socket!\");\n  fio_uuid_link(uuid, &called, fio_uuid_link_test_on_close);\n  FIO_ASSERT(called == 0,\n             \"fio_uuid_link failed - on_close callback called too soon!\");\n  fio_uuid_link(uuid, &removed, fio_uuid_link_test_on_close);\n  fio_uuid_unlink(uuid, &removed);\n  fio_close(uuid);\n  fio_defer_perform();\n  FIO_ASSERT(called, \"fio_uuid_link failed - on_close callback wasn't called!\");\n  FIO_ASSERT(called, \"fio_uuid_unlink failed - on_close callback was called \"\n                     \"(wasn't removed)!\");\n  fprintf(stderr, \"* passed.\\n\");\n}\n\n/* *****************************************************************************\nByte Order Testing\n***************************************************************************** */\n\nFIO_FUNC void fio_str2u_test(void) {\n  fprintf(stderr, \"=== Testing fio_u2strX and fio_u2strX functions.\\n\");\n  char buffer[32];\n  for (int64_t i = -1024; i < 1024; ++i) {\n    fio_u2str64(buffer, i);\n    __asm__ volatile(\"\" ::: \"memory\");\n    FIO_ASSERT((int64_t)fio_str2u64(buffer) == i,\n               \"fio_u2str64 / fio_str2u64  mismatch %zd != %zd\",\n               (ssize_t)fio_str2u64(buffer), (ssize_t)i);\n  }\n  for (int32_t i = -1024; i < 1024; ++i) {\n    fio_u2str32(buffer, i);\n    __asm__ volatile(\"\" ::: \"memory\");\n    FIO_ASSERT((int32_t)fio_str2u32(buffer) == i,\n               \"fio_u2str32 / fio_str2u32  mismatch %zd != %zd\",\n               (ssize_t)(fio_str2u32(buffer)), (ssize_t)i);\n  }\n  for (int16_t i = -1024; i < 1024; ++i) {\n    fio_u2str16(buffer, i);\n    __asm__ volatile(\"\" ::: \"memory\");\n    FIO_ASSERT((int16_t)fio_str2u16(buffer) == i,\n               \"fio_u2str16 / fio_str2u16  mismatch %zd != %zd\",\n               (ssize_t)(fio_str2u16(buffer)), (ssize_t)i);\n  }\n  fprintf(stderr, \"* passed.\\n\");\n}\n\n/* *****************************************************************************\nPub/Sub partial tests\n***************************************************************************** */\n\n#if FIO_PUBSUB_SUPPORT\n\nFIO_FUNC void fio_pubsub_test_on_message(fio_msg_s *msg) {\n  fio_atomic_add((uintptr_t *)msg->udata1, 1);\n}\nFIO_FUNC void fio_pubsub_test_on_unsubscribe(void *udata1, void *udata2) {\n  fio_atomic_add((uintptr_t *)udata1, 1);\n  (void)udata2;\n}\n\nFIO_FUNC void fio_pubsub_test(void) {\n  fprintf(stderr, \"=== Testing pub/sub (partial)\\n\");\n  fio_data->active = 1;\n  fio_data->is_worker = 1;\n  fio_data->workers = 1;\n  subscription_s *s = fio_subscribe(.filter = 1, .on_message = NULL);\n  uintptr_t counter = 0;\n  uintptr_t expect = 0;\n  FIO_ASSERT(!s, \"fio_subscribe should fail without a callback!\");\n  char buffer[8];\n  fio_u2str32((uint8_t *)buffer + 1, 42);\n  FIO_ASSERT(fio_str2u32((uint8_t *)buffer + 1) == 42,\n             \"fio_u2str32 / fio_str2u32 not reversible (42)!\");\n  fio_u2str32((uint8_t *)buffer, 4);\n  FIO_ASSERT(fio_str2u32((uint8_t *)buffer) == 4,\n             \"fio_u2str32 / fio_str2u32 not reversible (4)!\");\n  subscription_s *s2 =\n      fio_subscribe(.filter = 1, .udata1 = &counter,\n                    .on_message = fio_pubsub_test_on_message,\n                    .on_unsubscribe = fio_pubsub_test_on_unsubscribe);\n  FIO_ASSERT(s2, \"fio_subscribe FAILED on filtered subscription.\");\n  fio_publish(.filter = 1);\n  ++expect;\n  fio_defer_perform();\n  FIO_ASSERT(counter == expect, \"publishing failed to filter 1!\");\n  fio_publish(.filter = 2);\n  fio_defer_perform();\n  FIO_ASSERT(counter == expect, \"publishing to filter 2 arrived at filter 1!\");\n  fio_unsubscribe(s);\n  fio_unsubscribe(s2);\n  ++expect;\n  fio_defer_perform();\n  FIO_ASSERT(counter == expect, \"unsubscribe wasn't called for filter 1!\");\n  s = fio_subscribe(.channel = {0, 4, \"name\"}, .udata1 = &counter,\n                    .on_message = fio_pubsub_test_on_message,\n                    .on_unsubscribe = fio_pubsub_test_on_unsubscribe);\n  FIO_ASSERT(s, \"fio_subscribe FAILED on named subscription.\");\n  fio_publish(.channel = {0, 4, \"name\"});\n  ++expect;\n  fio_defer_perform();\n  FIO_ASSERT(counter == expect, \"publishing failed to named channel!\");\n  fio_publish(.channel = {0, 4, \"none\"});\n  fio_defer_perform();\n  FIO_ASSERT(counter == expect,\n             \"publishing arrived to named channel with wrong name!\");\n  fio_unsubscribe(s);\n  ++expect;\n  fio_defer_perform();\n  FIO_ASSERT(counter == expect, \"unsubscribe wasn't called for named channel!\");\n  fio_data->is_worker = 0;\n  fio_data->active = 0;\n  fio_data->workers = 0;\n  fio_defer_perform();\n  (void)fio_pubsub_test_on_message;\n  (void)fio_pubsub_test_on_unsubscribe;\n  fprintf(stderr, \"* passed.\\n\");\n}\n#else\n#define fio_pubsub_test()\n#endif\n\n/* *****************************************************************************\nString 2 Number and Number 2 String (partial) testing\n***************************************************************************** */\n\n#if NODEBUG\n#define FIO_ATOL_TEST_MAX_CYCLES 3145728\n#else\n#define FIO_ATOL_TEST_MAX_CYCLES 4096\n#endif\nFIO_FUNC void fio_atol_test(void) {\n  fprintf(stderr, \"=== Testing fio_ltoa and fio_atol (partial)\\n\");\n#ifndef NODEBUG\n  fprintf(stderr,\n          \"Note: No optimizations - facil.io performance will be slow.\\n\");\n#endif\n  fprintf(stderr,\n          \"      Test with make test/optimized for realistic results.\\n\");\n  time_t start, end;\n\n#define TEST_ATOL(s, n)                                                        \\\n  do {                                                                         \\\n    char *p = (char *)(s);                                                     \\\n    int64_t r = fio_atol(&p);                                                  \\\n    FIO_ASSERT(r == (n), \"fio_atol test error! %s => %zd (not %zd)\",           \\\n               ((char *)(s)), (size_t)r, (size_t)n);                           \\\n    FIO_ASSERT((s) + strlen((s)) == p,                                         \\\n               \"fio_atol test error! %s reading position not at end (%zu)\",    \\\n               (s), (size_t)(p - (s)));                                        \\\n    char buf[72];                                                              \\\n    buf[fio_ltoa(buf, n, 2)] = 0;                                              \\\n    p = buf;                                                                   \\\n    FIO_ASSERT(fio_atol(&p) == (n),                                            \\\n               \"fio_ltoa base 2 test error! \"                                  \\\n               \"%s != %s (%zd)\",                                               \\\n               buf, ((char *)(s)), (size_t)((p = buf), fio_atol(&p)));         \\\n    buf[fio_ltoa(buf, n, 8)] = 0;                                              \\\n    p = buf;                                                                   \\\n    FIO_ASSERT(fio_atol(&p) == (n),                                            \\\n               \"fio_ltoa base 8 test error! \"                                  \\\n               \"%s != %s (%zd)\",                                               \\\n               buf, ((char *)(s)), (size_t)((p = buf), fio_atol(&p)));         \\\n    buf[fio_ltoa(buf, n, 10)] = 0;                                             \\\n    p = buf;                                                                   \\\n    FIO_ASSERT(fio_atol(&p) == (n),                                            \\\n               \"fio_ltoa base 10 test error! \"                                 \\\n               \"%s != %s (%zd)\",                                               \\\n               buf, ((char *)(s)), (size_t)((p = buf), fio_atol(&p)));         \\\n    buf[fio_ltoa(buf, n, 16)] = 0;                                             \\\n    p = buf;                                                                   \\\n    FIO_ASSERT(fio_atol(&p) == (n),                                            \\\n               \"fio_ltoa base 16 test error! \"                                 \\\n               \"%s != %s (%zd)\",                                               \\\n               buf, ((char *)(s)), (size_t)((p = buf), fio_atol(&p)));         \\\n  } while (0)\n  TEST_ATOL(\"0x1\", 1);\n  TEST_ATOL(\"-0x1\", -1);\n  TEST_ATOL(\"-0xa\", -10);                                /* sign before hex */\n  TEST_ATOL(\"0xe5d4c3b2a1908770\", -1885667171979196560); /* sign within hex */\n  TEST_ATOL(\"0b00000000000011\", 3);\n  TEST_ATOL(\"-0b00000000000011\", -3);\n  TEST_ATOL(\"0b0000000000000000000000000000000000000000000000000\", 0);\n  TEST_ATOL(\"0\", 0);\n  TEST_ATOL(\"1\", 1);\n  TEST_ATOL(\"2\", 2);\n  TEST_ATOL(\"-2\", -2);\n  TEST_ATOL(\"0000000000000000000000000000000000000000000000042\", 34); /* oct */\n  TEST_ATOL(\"9223372036854775807\", 9223372036854775807LL); /* INT64_MAX */\n  TEST_ATOL(\"9223372036854775808\",\n            9223372036854775807LL); /* INT64_MAX overflow protection */\n  TEST_ATOL(\"9223372036854775999\",\n            9223372036854775807LL); /* INT64_MAX overflow protection */\n\n  char number_hex[128] = \"0xe5d4c3b2a1908770\"; /* hex with embedded sign */\n  // char number_hex[128] = \"-0x1a2b3c4d5e6f7890\";\n  char number[128] = \"-1885667171979196560\";\n  intptr_t expect = -1885667171979196560;\n  intptr_t result = 0;\n\n  result = 0;\n\n  start = clock();\n  for (size_t i = 0; i < FIO_ATOL_TEST_MAX_CYCLES; ++i) {\n    __asm__ volatile(\"\" ::: \"memory\");\n    char *pos = number;\n    result = fio_atol(&pos);\n    __asm__ volatile(\"\" ::: \"memory\");\n  }\n  end = clock();\n  fprintf(stderr, \"fio_atol base 10 (%ld): %zd CPU cycles\\n\", result,\n          end - start);\n\n  result = 0;\n  start = clock();\n  for (size_t i = 0; i < FIO_ATOL_TEST_MAX_CYCLES; ++i) {\n    __asm__ volatile(\"\" ::: \"memory\");\n    result = strtol(number, NULL, 0);\n    __asm__ volatile(\"\" ::: \"memory\");\n  }\n  end = clock();\n  fprintf(stderr, \"native strtol base 10 (%ld): %zd CPU cycles\\n\", result,\n          end - start);\n\n  result = 0;\n  start = clock();\n  for (size_t i = 0; i < FIO_ATOL_TEST_MAX_CYCLES; ++i) {\n    __asm__ volatile(\"\" ::: \"memory\");\n    char *pos = number_hex;\n    result = fio_atol(&pos);\n    __asm__ volatile(\"\" ::: \"memory\");\n  }\n  end = clock();\n  fprintf(stderr, \"fio_atol base 16 (%ld): %zd CPU cycles\\n\", result,\n          end - start);\n\n  result = 0;\n  start = clock();\n  for (size_t i = 0; i < FIO_ATOL_TEST_MAX_CYCLES; ++i) {\n    __asm__ volatile(\"\" ::: \"memory\");\n    result = strtol(number_hex, NULL, 0);\n    __asm__ volatile(\"\" ::: \"memory\");\n  }\n  end = clock();\n  fprintf(stderr, \"native strtol base 16 (%ld): %zd CPU cycles%s\\n\", result,\n          end - start, (result != expect ? \" (!?stdlib overflow?!)\" : \"\"));\n\n  result = 0;\n  start = clock();\n  for (size_t i = 0; i < FIO_ATOL_TEST_MAX_CYCLES; ++i) {\n    __asm__ volatile(\"\" ::: \"memory\");\n    fio_ltoa(number, expect, 10);\n    __asm__ volatile(\"\" ::: \"memory\");\n  }\n  end = clock();\n  {\n    char *buf = number;\n    FIO_ASSERT(fio_atol(&buf) == expect,\n               \"fio_ltoa with base 10 returned wrong result (%s != %ld)\",\n               number, expect);\n  }\n  fprintf(stderr, \"fio_ltoa base 10 (%s): %zd CPU cycles\\n\", number,\n          end - start);\n\n  result = 0;\n  start = clock();\n  for (size_t i = 0; i < FIO_ATOL_TEST_MAX_CYCLES; ++i) {\n    __asm__ volatile(\"\" ::: \"memory\");\n    sprintf(number, \"%ld\", expect);\n    __asm__ volatile(\"\" ::: \"memory\");\n  }\n  end = clock();\n  fprintf(stderr, \"native sprintf base 10 (%s): %zd CPU cycles\\n\", number,\n          end - start);\n  FIO_ASSERT(fio_ltoa(number, 0, 0) == 1,\n             \"base 10 zero should be single char.\");\n  FIO_ASSERT(memcmp(number, \"0\", 2) == 0, \"base 10 zero should be \\\"0\\\" (%s).\",\n             number);\n  fprintf(stderr, \"* passed.\\n\");\n#undef TEST_ATOL\n}\n\n/* *****************************************************************************\nString 2 Float and Float 2 String (partial) testing\n***************************************************************************** */\n\nFIO_FUNC void fio_atof_test(void) {\n  fprintf(stderr, \"=== Testing fio_ftoa and fio_ftoa (partial)\\n\");\n#define TEST_DOUBLE(s, d, must)                                                \\\n  do {                                                                         \\\n    char *p = (char *)(s);                                                     \\\n    double r = fio_atof(&p);                                                   \\\n    if (r != (d)) {                                                            \\\n      FIO_LOG_DEBUG(\"Double Test Error! %s => %.19g (not %.19g)\",              \\\n                    ((char *)(s)), r, d);                                      \\\n      if (must) {                                                              \\\n        FIO_ASSERT(0, \"double test failed on %s\", ((char *)(s)));              \\\n        exit(-1);                                                              \\\n      }                                                                        \\\n    }                                                                          \\\n  } while (0)\n  /* The numbers were copied from https://github.com/miloyip/rapidjson */\n  TEST_DOUBLE(\"0.0\", 0.0, 1);\n  TEST_DOUBLE(\"-0.0\", -0.0, 1);\n  TEST_DOUBLE(\"1.0\", 1.0, 1);\n  TEST_DOUBLE(\"-1.0\", -1.0, 1);\n  TEST_DOUBLE(\"1.5\", 1.5, 1);\n  TEST_DOUBLE(\"-1.5\", -1.5, 1);\n  TEST_DOUBLE(\"3.1416\", 3.1416, 1);\n  TEST_DOUBLE(\"1E10\", 1E10, 1);\n  TEST_DOUBLE(\"1e10\", 1e10, 1);\n  TEST_DOUBLE(\"1E+10\", 1E+10, 1);\n  TEST_DOUBLE(\"1E-10\", 1E-10, 1);\n  TEST_DOUBLE(\"-1E10\", -1E10, 1);\n  TEST_DOUBLE(\"-1e10\", -1e10, 1);\n  TEST_DOUBLE(\"-1E+10\", -1E+10, 1);\n  TEST_DOUBLE(\"-1E-10\", -1E-10, 1);\n  TEST_DOUBLE(\"1.234E+10\", 1.234E+10, 1);\n  TEST_DOUBLE(\"1.234E-10\", 1.234E-10, 1);\n  TEST_DOUBLE(\"1.79769e+308\", 1.79769e+308, 1);\n  TEST_DOUBLE(\"2.22507e-308\", 2.22507e-308, 1);\n  TEST_DOUBLE(\"-1.79769e+308\", -1.79769e+308, 1);\n  TEST_DOUBLE(\"-2.22507e-308\", -2.22507e-308, 1);\n  TEST_DOUBLE(\"4.9406564584124654e-324\", 4.9406564584124654e-324, 0);\n  TEST_DOUBLE(\"2.2250738585072009e-308\", 2.2250738585072009e-308, 0);\n  TEST_DOUBLE(\"2.2250738585072014e-308\", 2.2250738585072014e-308, 1);\n  TEST_DOUBLE(\"1.7976931348623157e+308\", 1.7976931348623157e+308, 1);\n  TEST_DOUBLE(\"1e-10000\", 0.0, 0);\n  TEST_DOUBLE(\"18446744073709551616\", 18446744073709551616.0, 0);\n\n  TEST_DOUBLE(\"-9223372036854775809\", -9223372036854775809.0, 0);\n\n  TEST_DOUBLE(\"0.9868011474609375\", 0.9868011474609375, 0);\n  TEST_DOUBLE(\"123e34\", 123e34, 1);\n  TEST_DOUBLE(\"45913141877270640000.0\", 45913141877270640000.0, 1);\n  TEST_DOUBLE(\"2.2250738585072011e-308\", 2.2250738585072011e-308, 0);\n  TEST_DOUBLE(\"1e-214748363\", 0.0, 1);\n  TEST_DOUBLE(\"1e-214748364\", 0.0, 1);\n  TEST_DOUBLE(\"0.017976931348623157e+310, 1\", 1.7976931348623157e+308, 0);\n\n  TEST_DOUBLE(\"2.2250738585072012e-308\", 2.2250738585072014e-308, 0);\n  TEST_DOUBLE(\"2.22507385850720113605740979670913197593481954635164565e-308\",\n              2.2250738585072014e-308, 0);\n\n  TEST_DOUBLE(\"0.999999999999999944488848768742172978818416595458984375\", 1.0,\n              0);\n  TEST_DOUBLE(\"0.999999999999999944488848768742172978818416595458984376\", 1.0,\n              0);\n  TEST_DOUBLE(\"1.00000000000000011102230246251565404236316680908203125\", 1.0,\n              0);\n  TEST_DOUBLE(\"1.00000000000000011102230246251565404236316680908203124\", 1.0,\n              0);\n\n  TEST_DOUBLE(\"72057594037927928.0\", 72057594037927928.0, 0);\n  TEST_DOUBLE(\"72057594037927936.0\", 72057594037927936.0, 0);\n  TEST_DOUBLE(\"72057594037927932.0\", 72057594037927936.0, 0);\n  TEST_DOUBLE(\"7205759403792793200001e-5\", 72057594037927936.0, 0);\n\n  TEST_DOUBLE(\"9223372036854774784.0\", 9223372036854774784.0, 0);\n  TEST_DOUBLE(\"9223372036854775808.0\", 9223372036854775808.0, 0);\n  TEST_DOUBLE(\"9223372036854775296.0\", 9223372036854775808.0, 0);\n  TEST_DOUBLE(\"922337203685477529600001e-5\", 9223372036854775808.0, 0);\n\n  TEST_DOUBLE(\"10141204801825834086073718800384\",\n              10141204801825834086073718800384.0, 0);\n  TEST_DOUBLE(\"10141204801825835211973625643008\",\n              10141204801825835211973625643008.0, 0);\n  TEST_DOUBLE(\"10141204801825834649023672221696\",\n              10141204801825835211973625643008.0, 0);\n  TEST_DOUBLE(\"1014120480182583464902367222169600001e-5\",\n              10141204801825835211973625643008.0, 0);\n\n  TEST_DOUBLE(\"5708990770823838890407843763683279797179383808\",\n              5708990770823838890407843763683279797179383808.0, 0);\n  TEST_DOUBLE(\"5708990770823839524233143877797980545530986496\",\n              5708990770823839524233143877797980545530986496.0, 0);\n  TEST_DOUBLE(\"5708990770823839207320493820740630171355185152\",\n              5708990770823839524233143877797980545530986496.0, 0);\n  TEST_DOUBLE(\"5708990770823839207320493820740630171355185152001e-3\",\n              5708990770823839524233143877797980545530986496.0, 0);\n  fprintf(stderr, \"\\n* passed.\\n\");\n}\n/* *****************************************************************************\nRun all tests\n***************************************************************************** */\n\nvoid fio_test(void) {\n  FIO_ASSERT(fio_capa(), \"facil.io initialization error!\");\n  fio_malloc_test();\n  fio_state_callback_test();\n  fio_str_test();\n  fio_atol_test();\n  fio_atof_test();\n  fio_str2u_test();\n  fio_llist_test();\n  fio_ary_test();\n  fio_set_test();\n  fio_defer_test();\n  fio_timer_test();\n  fio_poll_test();\n  fio_socket_test();\n  fio_uuid_link_test();\n  fio_cycle_test();\n  fio_riskyhash_test();\n  fio_siphash_test();\n  fio_sha1_test();\n  fio_sha2_test();\n  fio_base64_test();\n  fio_test_random();\n  fio_pubsub_test();\n  (void)fio_sentinel_task;\n  (void)deferred_on_shutdown;\n  (void)fio_poll;\n}\n\n#endif /* DEBUG */\n", "/*\nCopyright: Boaz Segev, 2018-2019\nLicense: MIT\n\nFeel free to copy, use and enjoy according to the license provided.\n*/\n\n#ifndef H_FACIL_IO_H\n/**\n\"facil.h\" is the main header for the facil.io server platform.\n*/\n#define H_FACIL_IO_H\n\n/* *****************************************************************************\n * Table of contents (find by subject):\n * =================\n * Version and helper macros\n * Helper String Information Type\n * Memory pool / custom allocator for short lived objects\n * Logging and testing helpers\n *\n * Connection Callback (Protocol) Management\n * Listening to Incoming Connections\n * Connecting to remote servers as a client\n * Starting the IO reactor and reviewing it's state\n * Socket / Connection Functions\n * Connection Read / Write Hooks, for overriding the system calls\n * Concurrency overridable functions\n * Connection Task scheduling\n * Event / Task scheduling\n * Startup / State Callbacks (fork, start up, idle, etc')\n * Lower Level API - for special circumstances, use with care under\n *\n * Pub/Sub / Cluster Messages API\n * Cluster Messages and Pub/Sub\n * Cluster / Pub/Sub Middleware and Extensions (\"Engines\")\n *\n * Atomic Operations and Spin Locking Helper Functions\n * Simple Constant Time Operations\n * Byte Swapping and Network Order\n *\n * Converting Numbers to Strings (and back)\n * Strings to Numbers\n * Numbers to Strings* Random Generator Functions\n *\n * SipHash\n * SHA-1\n * SHA-2\n * Base64 (URL) encoding\n *\n * Memory Allocator Details\n *\n * Spin locking Implementation\n *\n ******** facil.io Data Types (String, Set / Hash Map, Linked Lists, etc')\n *\n * These types can be included by defining the macros and (re)including fio.h.\n *\n *\n *\n *                      #ifdef FIO_INCLUDE_LINKED_LIST\n *\n * Linked List Helpers\n * Independent Linked List API\n * Embedded Linked List API* Independent Linked List Implementation\n * Embeded Linked List Implementation\n *\n *\n *\n *                      #ifdef FIO_INCLUDE_STR\n *\n * String Helpers\n * String API - Initialization and Destruction\n * String API - String state (data pointers, length, capacity, etc')\n * String API - Memory management\n * String API - UTF-8 State\n * String Implementation - state (data pointers, length, capacity, etc')\n * String Implementation - Memory management\n * String Implementation - UTF-8 State\n * String Implementation - Content Manipulation and Review\n *\n *\n *\n *            #ifdef FIO_ARY_NAME - can be included more than once\n *\n * Dynamic Array Data-Store\n * Array API\n * Array Type\n * Array Memory Management\n * Array API implementation\n * Array Testing\n *\n *\n *\n *            #ifdef FIO_SET_NAME - can be included more than once\n *\n * Set / Hash Map Data-Store\n * Set / Hash Map API\n * Set / Hash Map Internal Data Structures\n * Set / Hash Map Internal Helpers\n * Set / Hash Map Implementation\n *\n *****************************************************************************\n */\n\n/* *****************************************************************************\nVersion and helper macros\n***************************************************************************** */\n\n#define FIO_VERSION_MAJOR 0\n#define FIO_VERSION_MINOR 7\n#define FIO_VERSION_PATCH 3\n#define FIO_VERSION_BETA 0\n\n/* Automatically convert version data to a string constant - ignore these two */\n#define FIO_MACRO2STR_STEP2(macro) #macro\n#define FIO_MACRO2STR(macro) FIO_MACRO2STR_STEP2(macro)\n\n/** The facil.io version as a String literal */\n#if FIO_VERSION_BETA\n#define FIO_VERSION_STRING                                                     \\\n  FIO_MACRO2STR(FIO_VERSION_MAJOR)                                             \\\n  \".\" FIO_MACRO2STR(FIO_VERSION_MINOR) \".\" FIO_MACRO2STR(                      \\\n      FIO_VERSION_PATCH) \".beta\" FIO_MACRO2STR(FIO_VERSION_BETA)\n#else\n#define FIO_VERSION_STRING                                                     \\\n  FIO_MACRO2STR(FIO_VERSION_MAJOR)                                             \\\n  \".\" FIO_MACRO2STR(FIO_VERSION_MINOR) \".\" FIO_MACRO2STR(FIO_VERSION_PATCH)\n#endif\n\n#ifndef FIO_MAX_SOCK_CAPACITY\n/**\n * The maximum number of connections per worker process.\n */\n#define FIO_MAX_SOCK_CAPACITY 131072\n#endif\n\n#ifndef FIO_CPU_CORES_LIMIT\n/**\n * If facil.io detects more CPU cores than the number of cores stated in the\n * FIO_CPU_CORES_LIMIT, it will assume an error and cap the number of cores\n * detected to the assigned limit.\n *\n * This is only relevant to automated values, when running facil.io with zero\n * threads and processes, which invokes a large matrix of workers and threads\n * (see {facil_run})\n *\n * The default auto-detection cap is set at 8 cores. The number is arbitrary\n * (historically the number 7 was used after testing `malloc` race conditions on\n * a MacBook Pro).\n *\n * This does NOT effect manually set (non-zero) worker/thread values.\n */\n#define FIO_CPU_CORES_LIMIT 8\n#endif\n\n#ifndef FIO_DEFER_THROTTLE_PROGRESSIVE\n/**\n * The progressive throttling model makes concurrency and parallelism more\n * likely.\n *\n * Otherwise threads are assumed to be intended for \"fallback\" in case of slow\n * user code, where a single thread should be active most of the time and other\n * threads are activated only when that single thread is slow to perform.\n */\n#define FIO_DEFER_THROTTLE_PROGRESSIVE 1\n#endif\n\n#ifndef FIO_PRINT_STATE\n/**\n * Enables the depraceted FIO_LOG_STATE(msg,...) macro, which prints information\n * level messages to stderr.\n */\n#define FIO_PRINT_STATE 0\n#endif\n\n#ifndef FIO_PUBSUB_SUPPORT\n/**\n * If true (1), compiles the facil.io pub/sub API.\n */\n#define FIO_PUBSUB_SUPPORT 1\n#endif\n\n#ifndef FIO_LOG_LENGTH_LIMIT\n/**\n * Since logging uses stack memory rather than dynamic allocation, it's memory\n * usage must be limited to avoid exploding the stack. The following sets the\n * memory used for a logging event.\n */\n#define FIO_LOG_LENGTH_LIMIT 2048\n#endif\n\n#ifndef FIO_IGNORE_MACRO\n/**\n * This is used internally to ignore macros that shadow functions (avoiding\n * named arguments when required).\n */\n#define FIO_IGNORE_MACRO\n#endif\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n\n#include <errno.h>\n#include <limits.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n#include <time.h>\n\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <unistd.h>\n\n#if !defined(__GNUC__) && !defined(__clang__) && !defined(FIO_GNUC_BYPASS)\n#define __attribute__(...)\n#define __has_include(...) 0\n#define __has_builtin(...) 0\n#define FIO_GNUC_BYPASS 1\n#elif !defined(__clang__) && !defined(__has_builtin)\n/* E.g: GCC < 6.0 doesn't support __has_builtin */\n#define __has_builtin(...) 0\n#define FIO_GNUC_BYPASS 1\n#endif\n\n#if defined(__GNUC__) && (__GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 5))\n/* GCC < 4.5 doesn't support deprecation reason string */\n#define deprecated(reason) deprecated\n#endif\n\n#ifndef FIO_FUNC\n#define FIO_FUNC static __attribute__((unused))\n#endif\n\n#if defined(__FreeBSD__)\n#include <netinet/in.h>\n#include <sys/socket.h>\n#endif\n\n/* *****************************************************************************\nPatch for OSX version < 10.12 from https://stackoverflow.com/a/9781275/4025095\n***************************************************************************** */\n#if defined(__MACH__) && !defined(CLOCK_REALTIME)\n#include <sys/time.h>\n#define CLOCK_REALTIME 0\n#define clock_gettime patch_clock_gettime\n// clock_gettime is not implemented on older versions of OS X (< 10.12).\n// If implemented, CLOCK_REALTIME will have already been defined.\nstatic inline int patch_clock_gettime(int clk_id, struct timespec *t) {\n  struct timeval now;\n  int rv = gettimeofday(&now, NULL);\n  if (rv)\n    return rv;\n  t->tv_sec = now.tv_sec;\n  t->tv_nsec = now.tv_usec * 1000;\n  return 0;\n  (void)clk_id;\n}\n#endif\n\n/* *****************************************************************************\nC++ extern start\n***************************************************************************** */\n/* support C++ */\n#ifdef __cplusplus\nextern \"C\" {\n/* C++ keyword was deprecated */\n#define register\n#endif\n\n/* *****************************************************************************\nHelper String Information Type\n***************************************************************************** */\n\n#ifndef FIO_STR_INFO_TYPE\n/** A string information type, reports information about a C string. */\ntypedef struct fio_str_info_s {\n  size_t capa; /* Buffer capacity, if the string is writable. */\n  size_t len;  /* String length. */\n  char *data;  /* String's first byte. */\n} fio_str_info_s;\n#define FIO_STR_INFO_TYPE\n#endif\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n\n\n\n\n\nMemory pool / custom allocator for short lived objects\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/* inform the compiler that the returned value is aligned on 16 byte marker */\n#if FIO_FORCE_MALLOC\n#define FIO_ALIGN\n#define FIO_ALIGN_NEW\n#elif __clang__ || __GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ > 8)\n#define FIO_ALIGN __attribute__((assume_aligned(16)))\n#define FIO_ALIGN_NEW __attribute__((malloc, assume_aligned(16)))\n#else\n#define FIO_ALIGN\n#define FIO_ALIGN_NEW\n#endif\n\n/**\n * Allocates memory using a per-CPU core block memory pool.\n * Memory is zeroed out.\n *\n * Allocations above FIO_MEMORY_BLOCK_ALLOC_LIMIT (16Kb when using 32Kb blocks)\n * will be redirected to `mmap`, as if `fio_mmap` was called.\n */\nvoid *FIO_ALIGN_NEW fio_malloc(size_t size);\n\n/**\n * same as calling `fio_malloc(size_per_unit * unit_count)`;\n *\n * Allocations above FIO_MEMORY_BLOCK_ALLOC_LIMIT (16Kb when using 32Kb blocks)\n * will be redirected to `mmap`, as if `fio_mmap` was called.\n */\nvoid *FIO_ALIGN_NEW fio_calloc(size_t size_per_unit, size_t unit_count);\n\n/** Frees memory that was allocated using this library. */\nvoid fio_free(void *ptr);\n\n/**\n * Re-allocates memory. An attempt to avoid copying the data is made only for\n * big memory allocations (larger than FIO_MEMORY_BLOCK_ALLOC_LIMIT).\n */\nvoid *FIO_ALIGN fio_realloc(void *ptr, size_t new_size);\n\n/**\n * Re-allocates memory. An attempt to avoid copying the data is made only for\n * big memory allocations (larger than FIO_MEMORY_BLOCK_ALLOC_LIMIT).\n *\n * This variation is slightly faster as it might copy less data.\n */\nvoid *FIO_ALIGN fio_realloc2(void *ptr, size_t new_size, size_t copy_length);\n\n/**\n * Allocates memory directly using `mmap`, this is prefered for objects that\n * both require almost a page of memory (or more) and expect a long lifetime.\n *\n * However, since this allocation will invoke the system call (`mmap`), it will\n * be inherently slower.\n *\n * `fio_free` can be used for deallocating the memory.\n */\nvoid *FIO_ALIGN_NEW fio_mmap(size_t size);\n\n/**\n * When forking is called manually, call this function to reset the facil.io\n * memory allocator's locks.\n */\nvoid fio_malloc_after_fork(void);\n\n#undef FIO_ALIGN\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n\n\n\n\n\nLogging and testing helpers\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/** Logging level of zero (no logging). */\n#define FIO_LOG_LEVEL_NONE 0\n/** Log fatal errors. */\n#define FIO_LOG_LEVEL_FATAL 1\n/** Log errors and fatal errors. */\n#define FIO_LOG_LEVEL_ERROR 2\n/** Log warnings, errors and fatal errors. */\n#define FIO_LOG_LEVEL_WARNING 3\n/** Log every message (info, warnings, errors and fatal errors). */\n#define FIO_LOG_LEVEL_INFO 4\n/** Log everything, including debug messages. */\n#define FIO_LOG_LEVEL_DEBUG 5\n\n#if FIO_LOG_LENGTH_LIMIT > 128\n#define FIO_LOG____LENGTH_ON_STACK FIO_LOG_LENGTH_LIMIT\n#define FIO_LOG____LENGTH_BORDER (FIO_LOG_LENGTH_LIMIT - 32)\n#else\n#define FIO_LOG____LENGTH_ON_STACK (FIO_LOG_LENGTH_LIMIT + 32)\n#define FIO_LOG____LENGTH_BORDER FIO_LOG_LENGTH_LIMIT\n#endif\n/** The logging level */\nint __attribute__((weak)) FIO_LOG_LEVEL;\n\n#pragma weak FIO_LOG2STDERR\nvoid __attribute__((format(printf, 1, 0), weak))\nFIO_LOG2STDERR(const char *format, ...) {\n  char tmp___log[FIO_LOG____LENGTH_ON_STACK];\n  va_list argv;\n  va_start(argv, format);\n  int len___log = vsnprintf(tmp___log, FIO_LOG_LENGTH_LIMIT - 2, format, argv);\n  va_end(argv);\n  if (len___log <= 0 || len___log >= FIO_LOG_LENGTH_LIMIT - 2) {\n    if (len___log >= FIO_LOG_LENGTH_LIMIT - 2) {\n      memcpy(tmp___log + FIO_LOG____LENGTH_BORDER, \"... (warning: truncated).\",\n             25);\n      len___log = FIO_LOG____LENGTH_BORDER + 25;\n    } else {\n      fwrite(\"ERROR: log output error (can't write).\\n\", 39, 1, stderr);\n      return;\n    }\n  }\n  tmp___log[len___log++] = '\\n';\n  tmp___log[len___log] = '0';\n  fwrite(tmp___log, len___log, 1, stderr);\n}\n\n#ifndef FIO_LOG_PRINT\n#define FIO_LOG_PRINT(level, ...)                                              \\\n  do {                                                                         \\\n    if (level <= FIO_LOG_LEVEL) {                                              \\\n      FIO_LOG2STDERR(__VA_ARGS__);                                             \\\n    }                                                                          \\\n  } while (0)\n#define FIO_LOG_DEBUG(...)                                                     \\\n  FIO_LOG_PRINT(FIO_LOG_LEVEL_DEBUG,                                           \\\n                \"DEBUG (\"__FILE__                                              \\\n                \":\" FIO_MACRO2STR(__LINE__) \"): \" __VA_ARGS__)\n#define FIO_LOG_INFO(...)                                                      \\\n  FIO_LOG_PRINT(FIO_LOG_LEVEL_INFO, \"INFO: \" __VA_ARGS__)\n#define FIO_LOG_WARNING(...)                                                   \\\n  FIO_LOG_PRINT(FIO_LOG_LEVEL_WARNING, \"WARNING: \" __VA_ARGS__)\n#define FIO_LOG_ERROR(...)                                                     \\\n  FIO_LOG_PRINT(FIO_LOG_LEVEL_ERROR, \"ERROR: \" __VA_ARGS__)\n#define FIO_LOG_FATAL(...)                                                     \\\n  FIO_LOG_PRINT(FIO_LOG_LEVEL_FATAL, \"FATAL: \" __VA_ARGS__)\n#endif\n\n#if FIO_PRINT_STATE\n#define FIO_LOG_STATE(...)                                                     \\\n  FIO_LOG_PRINT(FIO_LOG_LEVEL_INFO,                                            \\\n                \"WARNING: FIO_LOG_STATE is deprecated\\n\" __VA_ARGS__)\n#else\n#define FIO_LOG_STATE(...)\n#endif\n\n#define FIO_ASSERT(cond, ...)                                                  \\\n  if (!(cond)) {                                                               \\\n    FIO_LOG_FATAL(\"(\" __FILE__ \":\" FIO_MACRO2STR(__LINE__) \") \"__VA_ARGS__);   \\\n    perror(\"     errno\");                                                      \\\n    exit(-1);                                                                  \\\n  }\n\n#ifndef FIO_ASSERT_ALLOC\n/** Tests for an allocation failure. The behavior can be overridden. */\n#define FIO_ASSERT_ALLOC(ptr)                                                  \\\n  if (!(ptr)) {                                                                \\\n    FIO_LOG_FATAL(\"memory allocation error \"__FILE__                           \\\n                  \":\" FIO_MACRO2STR(__LINE__));                                \\\n    kill(0, SIGINT);                                                           \\\n    exit(errno);                                                               \\\n  }\n#endif\n\n#if DEBUG\n#define FIO_ASSERT_DEBUG(cond, ...)                                            \\\n  if (!(cond)) {                                                               \\\n    FIO_LOG_DEBUG(__VA_ARGS__);                                                \\\n    perror(\"     errno\");                                                      \\\n    exit(-1);                                                                  \\\n  }\n#else\n#define FIO_ASSERT_DEBUG(...)\n#endif\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n\n\n\n\n\nConnection Callback (Protocol) Management\n\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\ntypedef struct fio_protocol_s fio_protocol_s;\n/**************************************************************************/ /**\n* The Protocol\n\nThe Protocol struct defines the callbacks used for the connection and sets it's\nbehaviour. The Protocol struct is part of facil.io's core design.\n\nFor concurrency reasons, a protocol instance SHOULD be unique to each\nconnections. Different connections shouldn't share a single protocol object\n(callbacks and data can obviously be shared).\n\nAll the callbacks receive a unique connection ID (a localized UUID) that can be\nconverted to the original file descriptor when in need.\n\nThis allows facil.io to prevent old connection handles from sending data\nto new connections after a file descriptor is \"recycled\" by the OS.\n*/\nstruct fio_protocol_s {\n  /** Called when a data is available, but will not run concurrently */\n  void (*on_data)(intptr_t uuid, fio_protocol_s *protocol);\n  /** called once all pending `fio_write` calls are finished. */\n  void (*on_ready)(intptr_t uuid, fio_protocol_s *protocol);\n  /**\n   * Called when the server is shutting down, immediately before closing the\n   * connection.\n   *\n   * The callback runs within a {FIO_PR_LOCK_TASK} lock, so it will never run\n   * concurrently with {on_data} or other connection specific tasks.\n   *\n   * The `on_shutdown` callback should return 0 to close the socket or a number\n   * between 1..254 to delay the socket closure by that amount of time.\n   *\n   * Once the socket wass marked for closure, facil.io will allow 8 seconds for\n   * all the data to be sent before forcfully closing the socket (regardless of\n   * state).\n   *\n   * If the `on_shutdown` returns 255, the socket is ignored and it will be\n   * abruptly terminated when all other sockets have finished their graceful\n   * shutdown procedure.\n   */\n  uint8_t (*on_shutdown)(intptr_t uuid, fio_protocol_s *protocol);\n  /** Called when the connection was closed, but will not run concurrently */\n  void (*on_close)(intptr_t uuid, fio_protocol_s *protocol);\n  /** called when a connection's timeout was reached */\n  void (*ping)(intptr_t uuid, fio_protocol_s *protocol);\n  /** private metadata used by facil. */\n  size_t rsv;\n};\n\n/**\n * Attaches (or updates) a protocol object to a socket UUID.\n *\n * The new protocol object can be NULL, which will detach (\"hijack\"), the\n * socket .\n *\n * The old protocol's `on_close` (if any) will be scheduled.\n *\n * On error, the new protocol's `on_close` callback will be called immediately.\n */\nvoid fio_attach(intptr_t uuid, fio_protocol_s *protocol);\n\n/**\n * Attaches (or updates) a protocol object to a file descriptor (fd).\n *\n * The new protocol object can be NULL, which will detach (\"hijack\"), the\n * socket and the `fd` can be one created outside of facil.io.\n *\n * The old protocol's `on_close` (if any) will be scheduled.\n *\n * On error, the new protocol's `on_close` callback will be called immediately.\n *\n * NOTE: before attaching a file descriptor that was created outside of\n * facil.io's library, make sure it is set to non-blocking mode (see\n * `fio_set_non_block`). facil.io file descriptors are all non-blocking and it\n * will assumes this is the case for the attached fd.\n */\nvoid fio_attach_fd(int fd, fio_protocol_s *protocol);\n\n/**\n * Sets a socket to non blocking state.\n *\n * This will also set the O_CLOEXEC flag for the file descriptor.\n *\n * This function is called automatically for the new socket, when using\n * `fio_accept` or `fio_connect`.\n */\nint fio_set_non_block(int fd);\n\n/**\n * Returns the maximum number of open files facil.io can handle per worker\n * process.\n *\n * Total OS limits might apply as well but aren't shown.\n *\n * The value of 0 indicates either that the facil.io library wasn't initialized\n * yet or that it's resources were released.\n */\nsize_t fio_capa(void);\n\n/** Sets a timeout for a specific connection (only when running and valid). */\nvoid fio_timeout_set(intptr_t uuid, uint8_t timeout);\n\n/** Gets a timeout for a specific connection. Returns 0 if none. */\nuint8_t fio_timeout_get(intptr_t uuid);\n\n/**\n * \"Touches\" a socket connection, resetting it's timeout counter.\n */\nvoid fio_touch(intptr_t uuid);\n\nenum fio_io_event {\n  FIO_EVENT_ON_DATA,\n  FIO_EVENT_ON_READY,\n  FIO_EVENT_ON_TIMEOUT\n};\n/** Schedules an IO event, even if it did not occur. */\nvoid fio_force_event(intptr_t uuid, enum fio_io_event);\n\n/**\n * Temporarily prevents `on_data` events from firing.\n *\n * The `on_data` event will be automatically rescheduled when (if) the socket's\n * outgoing buffer fills up or when `fio_force_event` is called with\n * `FIO_EVENT_ON_DATA`.\n *\n * Note: the function will work as expected when called within the protocol's\n * `on_data` callback and the `uuid` refers to a valid socket. Otherwise the\n * function might quietly fail.\n */\nvoid fio_suspend(intptr_t uuid);\n\n/* *****************************************************************************\nListening to Incoming Connections\n***************************************************************************** */\n\n/* Arguments for the fio_listen function */\nstruct fio_listen_args {\n  /**\n   * Called whenever a new connection is accepted.\n   *\n   * Should either call `fio_attach` or close the connection.\n   */\n  void (*on_open)(intptr_t uuid, void *udata);\n  /** The network service / port. Defaults to \"3000\". */\n  const char *port;\n  /** The socket binding address. Defaults to the recommended NULL. */\n  const char *address;\n  /** a pointer to a `fio_tls_s` object, for SSL/TLS support (fio_tls.h). */\n  void *tls;\n  /** Opaque user data. */\n  void *udata;\n  /**\n   * Called when the server starts (or a worker process is respawned), allowing\n   * for further initialization, such as timed event scheduling or VM\n   * initialization.\n   *\n   * This will be called separately for every worker process whenever it is\n   * spawned.\n   */\n  void (*on_start)(intptr_t uuid, void *udata);\n  /**\n   * Called when the server is done, usable for cleanup.\n   *\n   * This will be called separately for every process. */\n  void (*on_finish)(intptr_t uuid, void *udata);\n};\n\n/**\n * Sets up a network service on a listening socket.\n *\n * Returns the listening socket's uuid or -1 (on error).\n *\n * See the `fio_listen` Macro for details.\n */\nintptr_t fio_listen(struct fio_listen_args args);\n\n/************************************************************************ */ /**\nListening to Incoming Connections\n===\n\nListening to incoming connections is pretty straight forward.\n\nAfter a new connection is accepted, the `on_open` callback is called. `on_open`\nshould allocate the new connection's protocol and call `fio_attach` to attach\nthe protocol to the connection's uuid.\n\nThe protocol's `on_close` callback is expected to handle any cleanup required.\n\nThe following is an example echo server using facil.io:\n\n```c\n#include <fio.h>\n\n// A callback to be called whenever data is available on the socket\nstatic void echo_on_data(intptr_t uuid, fio_protocol_s *prt) {\n  (void)prt; // we can ignore the unused argument\n  // echo buffer\n  char buffer[1024] = {'E', 'c', 'h', 'o', ':', ' '};\n  ssize_t len;\n  // Read to the buffer, starting after the \"Echo: \"\n  while ((len = fio_read(uuid, buffer + 6, 1018)) > 0) {\n    fprintf(stderr, \"Read: %.*s\", (int)len, buffer + 6);\n    // Write back the message\n    fio_write(uuid, buffer, len + 6);\n    // Handle goodbye\n    if ((buffer[6] | 32) == 'b' && (buffer[7] | 32) == 'y' &&\n        (buffer[8] | 32) == 'e') {\n      fio_write(uuid, \"Goodbye.\\n\", 9);\n      fio_close(uuid);\n      return;\n    }\n  }\n}\n\n// A callback called whenever a timeout is reach\nstatic void echo_ping(intptr_t uuid, fio_protocol_s *prt) {\n  (void)prt; // we can ignore the unused argument\n  fio_write(uuid, \"Server: Are you there?\\n\", 23);\n}\n\n// A callback called if the server is shutting down...\n// ... while the connection is still open\nstatic uint8_t echo_on_shutdown(intptr_t uuid, fio_protocol_s *prt) {\n  (void)prt; // we can ignore the unused argument\n  fio_write(uuid, \"Echo server shutting down\\nGoodbye.\\n\", 35);\n  return 0;\n}\n\nstatic void echo_on_close(intptr_t uuid, fio_protocol_s *proto) {\n  fprintf(stderr, \"Connection %p closed.\\n\", (void *)proto);\n  free(proto);\n  (void)uuid;\n}\n\n// A callback called for new connections\nstatic void echo_on_open(intptr_t uuid, void *udata) {\n  (void)udata; // ignore this\n  // Protocol objects MUST be dynamically allocated when multi-threading.\n  fio_protocol_s *echo_proto = malloc(sizeof(*echo_proto));\n  *echo_proto = (fio_protocol_s){.service = \"echo\",\n                                 .on_data = echo_on_data,\n                                 .on_shutdown = echo_on_shutdown,\n                                 .on_close = echo_on_close,\n                                 .ping = echo_ping};\n  fprintf(stderr, \"New Connection %p received from %s\\n\", (void *)echo_proto,\n          fio_peer_addr(uuid).data);\n  fio_attach(uuid, echo_proto);\n  fio_write2(uuid, .data.buffer = \"Echo Service: Welcome\\n\", .length = 22,\n             .after.dealloc = FIO_DEALLOC_NOOP);\n  fio_timeout_set(uuid, 5);\n}\n\nint main() {\n  // Setup a listening socket\n  if (fio_listen(.port = \"3000\", .on_open = echo_on_open) == -1) {\n    perror(\"No listening socket available on port 3000\");\n    exit(-1);\n  }\n  // Run the server and hang until a stop signal is received.\n  fio_start(.threads = 4, .workers = 1);\n}\n```\n*/\n#define fio_listen(...) fio_listen((struct fio_listen_args){__VA_ARGS__})\n\n/* *****************************************************************************\nConnecting to remote servers as a client\n***************************************************************************** */\n\n/**\nNamed arguments for the `fio_connect` function, that allows non-blocking\nconnections to be established.\n*/\nstruct fio_connect_args {\n  /** The address of the server we are connecting to. */\n  const char *address;\n  /** The port on the server we are connecting to. */\n  const char *port;\n  /**\n   * The `on_connect` callback either call `fio_attach` or close the connection.\n   */\n  void (*on_connect)(intptr_t uuid, void *udata);\n  /**\n   * The `on_fail` is called when a socket fails to connect. The old sock UUID\n   * is passed along.\n   */\n  void (*on_fail)(intptr_t uuid, void *udata);\n  /** a pointer to a `fio_tls_s` object, for SSL/TLS support (fio_tls.h). */\n  void *tls;\n  /** Opaque user data. */\n  void *udata;\n  /** A non-system timeout after which connection is assumed to have failed. */\n  uint8_t timeout;\n};\n\n/**\nCreates a client connection (in addition or instead of the server).\n\nSee the `struct fio_connect_args` details for any possible named arguments.\n\n* `.address` should be the address of the server.\n\n* `.port` the server's port.\n\n* `.udata`opaque user data.\n\n* `.on_connect` called once a connection was established.\n\n    Should return a pointer to a `fio_protocol_s` object, to handle connection\n    callbacks.\n\n* `.on_fail` called if a connection failed to establish.\n\n(experimental: untested)\n*/\nintptr_t fio_connect(struct fio_connect_args);\n#define fio_connect(...) fio_connect((struct fio_connect_args){__VA_ARGS__})\n\n/* *****************************************************************************\nURL address parsing\n***************************************************************************** */\n\n/** the result returned by `fio_url_parse` */\ntypedef struct {\n  fio_str_info_s scheme;\n  fio_str_info_s user;\n  fio_str_info_s password;\n  fio_str_info_s host;\n  fio_str_info_s port;\n  fio_str_info_s path;\n  fio_str_info_s query;\n  fio_str_info_s target;\n} fio_url_s;\n\n/**\n * Parses the URI returning it's components and their lengths (no decoding\n * performed, doesn't accept decoded URIs).\n *\n * The returned string are NOT NUL terminated, they are merely locations within\n * the original string.\n *\n * This function attempts to accept many different formats, including any of the\n * following:\n *\n * * `/complete_path?query#target`\n *\n *   i.e.: /index.html?page=1#list\n *\n * * `host:port/complete_path?query#target`\n *\n *   i.e.:\n *      example.com\n *      example.com:8080\n *      example.com/index.html\n *      example.com:8080/index.html\n *      example.com:8080/index.html?key=val#target\n *\n * * `user:password@host:port/path?query#target`\n *\n *   i.e.: user:1234@example.com:8080/index.html\n *\n * * `username[:password]@host[:port][...]`\n *\n *   i.e.: john:1234@example.com\n *\n * * `schema://user:password@host:port/path?query#target`\n *\n *   i.e.: http://example.com/index.html?page=1#list\n *\n * Invalid formats might produce unexpected results. No error testing performed.\n */\nfio_url_s fio_url_parse(const char *url, size_t length);\n/* *****************************************************************************\nStarting the IO reactor and reviewing it's state\n***************************************************************************** */\n\nstruct fio_start_args {\n  /**\n   * The number of threads to run in the thread pool. Has \"smart\" defaults.\n   *\n   *\n   * A positive value will indicate a set number of threads (or workers).\n   *\n   * Zeros and negative values are fun and include an interesting shorthand:\n   *\n   * * Negative values indicate a fraction of the number of CPU cores. i.e.\n   *   -2 will normally indicate \"half\" (1/2) the number of cores.\n   *\n   * * If the other option (i.e. `.workers` when setting `.threads`) is zero,\n   *   it will be automatically updated to reflect the option's absolute value.\n   *   i.e.:\n   *   if .threads == -2 and .workers == 0,\n   *   than facil.io will run 2 worker processes with (cores/2) threads per\n   *   process.\n   */\n  int16_t threads;\n  /** The number of worker processes to run. See `threads`. */\n  int16_t workers;\n};\n\n/**\n * Starts the facil.io event loop. This function will return after facil.io is\n * done (after shutdown).\n *\n * See the `struct fio_start_args` details for any possible named arguments.\n *\n * This method blocks the current thread until the server is stopped (when a\n * SIGINT/SIGTERM is received).\n */\nvoid fio_start(struct fio_start_args args);\n#define fio_start(...) fio_start((struct fio_start_args){__VA_ARGS__})\n\n/**\n * Attempts to stop the facil.io application. This only works within the Root\n * process. A worker process will simply respawn itself.\n */\nvoid fio_stop(void);\n\n/**\n * Returns the number of expected threads / processes to be used by facil.io.\n *\n * The pointers should start with valid values that match the expected threads /\n * processes values passed to `fio_start`.\n *\n * The data in the pointers will be overwritten with the result.\n */\nvoid fio_expected_concurrency(int16_t *threads, int16_t *workers);\n\n/**\n * Returns the number of worker processes if facil.io is running.\n *\n * (1 is returned when in single process mode, otherwise the number of workers)\n */\nint16_t fio_is_running(void);\n\n/**\n * Returns 1 if the current process is a worker process or a single process.\n *\n * Otherwise returns 0.\n *\n * NOTE: When cluster mode is off, the root process is also the worker process.\n *       This means that single process instances don't automatically respawn\n *       after critical errors.\n */\nint fio_is_worker(void);\n\n/**\n * Returns 1 if the current process is the master (root) process.\n *\n * Otherwise returns 0.\n */\nint fio_is_master(void);\n\n/** Returns facil.io's parent (root) process pid. */\npid_t fio_parent_pid(void);\n\n/**\n * Initializes zombie reaping for the process. Call before `fio_start` to enable\n * global zombie reaping.\n */\nvoid fio_reap_children(void);\n\n/**\n * Resets any existing signal handlers, restoring their state to before they\n * were set by facil.io.\n *\n * This stops both child reaping (`fio_reap_children`) and the default facil.io\n * signal handlers (i.e., CTRL-C).\n *\n * This function will be called automatically by facil.io whenever facil.io\n * stops.\n */\nvoid fio_signal_handler_reset(void);\n\n/**\n * Returns the last time the server reviewed any pending IO events.\n */\nstruct timespec fio_last_tick(void);\n\n/**\n * Returns a C string detailing the IO engine selected during compilation.\n *\n * Valid values are \"kqueue\", \"epoll\" and \"poll\".\n */\nchar const *fio_engine(void);\n\n/* *****************************************************************************\nSocket / Connection Functions\n***************************************************************************** */\n\n/**\n * Creates a Unix or a TCP/IP socket and returns it's unique identifier.\n *\n * For TCP/IP server sockets (`is_server` is `1`), a NULL `address` variable is\n * recommended. Use \"localhost\" or \"127.0.0.1\" to limit access to the server\n * application.\n *\n * For TCP/IP client sockets (`is_server` is `0`), a remote `address` and `port`\n * combination will be required\n *\n * For Unix server or client sockets, set the `port` variable to NULL or `0`.\n *\n * Returns -1 on error. Any other value is a valid unique identifier.\n *\n * Note: facil.io uses unique identifiers to protect sockets from collisions.\n *       However these identifiers can be converted to the underlying file\n *       descriptor using the `fio_uuid2fd` macro.\n */\nintptr_t fio_socket(const char *address, const char *port, uint8_t is_server);\n\n/**\n * `fio_accept` accepts a new socket connection from a server socket - see the\n * server flag on `fio_socket`.\n *\n * Accepted connection are automatically set to non-blocking mode and the\n * O_CLOEXEC flag is set.\n *\n * NOTE: this function does NOT attach the socket to the IO reactor - see\n * `fio_attach`.\n */\nintptr_t fio_accept(intptr_t srv_uuid);\n\n/**\n * Returns 1 if the uuid refers to a valid and open, socket.\n *\n * Returns 0 if not.\n */\nint fio_is_valid(intptr_t uuid);\n\n/**\n * Returns 1 if the uuid is invalid or the socket is flagged to be closed.\n *\n * Returns 0 if the socket is valid, open and isn't flagged to be closed.\n */\nint fio_is_closed(intptr_t uuid);\n\n/**\n * `fio_close` marks the connection for disconnection once all the data was\n * sent. The actual disconnection will be managed by the `fio_flush` function.\n *\n * `fio_flash` will be automatically scheduled.\n */\nvoid fio_close(intptr_t uuid);\n\n/**\n * `fio_force_close` closes the connection immediately, without adhering to any\n * protocol restrictions and without sending any remaining data in the\n * connection buffer.\n */\nvoid fio_force_close(intptr_t uuid);\n\n/**\n * Returns the information available about the socket's peer address.\n *\n * If no information is available, the struct will be initialized with zero\n * (`addr == NULL`).\n * The information is only available when the socket was accepted using\n * `fio_accept` or opened using `fio_connect`.\n */\nfio_str_info_s fio_peer_addr(intptr_t uuid);\n\n/**\n * Writes the local machine address (qualified host name) to the buffer.\n *\n * Returns the amount of data written (excluding the NUL byte).\n *\n * `limit` is the maximum number of bytes in the buffer, including the NUL byte.\n *\n * If the returned value == limit - 1, the result might have been truncated.\n *\n * If 0 is returned, an erro might have occured (see `errno`) and the contents\n * of `dest` is undefined.\n */\nsize_t fio_local_addr(char *dest, size_t limit);\n\n/**\n * `fio_read` attempts to read up to count bytes from the socket into the\n * buffer starting at `buffer`.\n *\n * `fio_read`'s return values are wildly different then the native return\n * values and they aim at making far simpler sense.\n *\n * `fio_read` returns the number of bytes read (0 is a valid return value which\n * simply means that no bytes were read from the buffer).\n *\n * On a fatal connection error that leads to the connection being closed (or if\n * the connection is already closed), `fio_read` returns -1.\n *\n * The value 0 is the valid value indicating no data was read.\n *\n * Data might be available in the kernel's buffer while it is not available to\n * be read using `fio_read` (i.e., when using a transport layer, such as TLS).\n */\nssize_t fio_read(intptr_t uuid, void *buffer, size_t count);\n\n/** The following structure is used for `fio_write2_fn` function arguments. */\ntypedef struct {\n  union {\n    /** The in-memory data to be sent. */\n    const void *buffer;\n    /** The data to be sent, if this is a file. */\n    const intptr_t fd;\n  } data;\n  union {\n    /**\n     * This deallocation callback will be called when the packet is finished\n     * with the buffer.\n     *\n     * If no deallocation callback is set, `free` (or `close`) will be used.\n     *\n     * Note: socket library functions MUST NEVER be called by a callback, or a\n     * deadlock might occur.\n     */\n    void (*dealloc)(void *buffer);\n    /**\n     * This is an alternative deallocation callback accessor (same memory space\n     * as `dealloc`) for conveniently setting the file `close` callback.\n     *\n     * Note: `sock` library functions MUST NEVER be called by a callback, or a\n     * deadlock might occur.\n     */\n    void (*close)(intptr_t fd);\n  } after;\n  /** The length (size) of the buffer, or the amount of data to be sent from the\n   * file descriptor.\n   */\n  uintptr_t length;\n  /** Starting point offset from the buffer or file descriptor's beginning. */\n  uintptr_t offset;\n  /** The packet will be sent as soon as possible. */\n  unsigned urgent : 1;\n  /**\n   * The data union contains the value of a file descriptor (`int`). i.e.:\n   *  `.data.fd = fd` or `.data.buffer = (void*)fd;`\n   */\n  unsigned is_fd : 1;\n  /** for internal use */\n  unsigned rsv : 1;\n  /** for internal use */\n  unsigned rsv2 : 1;\n} fio_write_args_s;\n\n/**\n * `fio_write2_fn` is the actual function behind the macro `fio_write2`.\n */\nssize_t fio_write2_fn(intptr_t uuid, fio_write_args_s options);\n\n/**\n * Schedules data to be written to the socket.\n *\n * `fio_write2` is similar to `fio_write`, except that it allows far more\n * flexibility.\n *\n * On error, -1 will be returned. Otherwise returns 0.\n *\n * See the `fio_write_args_s` structure for details.\n *\n * NOTE: The data is \"moved\" to the ownership of the socket, not copied. The\n * data will be deallocated according to the `.after.dealloc` function.\n */\n#define fio_write2(uuid, ...)                                                  \\\n  fio_write2_fn(uuid, (fio_write_args_s){__VA_ARGS__})\n\n/** A noop function for fio_write2 in cases not deallocation is required. */\nvoid FIO_DEALLOC_NOOP(void *arg);\n#define FIO_CLOSE_NOOP ((void (*)(intptr_t))FIO_DEALLOC_NOOP)\n\n/**\n * `fio_write` copies `legnth` data from the buffer and schedules the data to\n * be sent over the socket.\n *\n * The data isn't necessarily written to the socket. The actual writing to the\n * socket is handled by the IO reactor.\n *\n * On error, -1 will be returned. Otherwise returns 0.\n *\n * Returns the same values as `fio_write2`.\n */\n// ssize_t fio_write(uintptr_t uuid, void *buffer, size_t legnth);\ninline FIO_FUNC ssize_t fio_write(const intptr_t uuid, const void *buffer,\n                                  const size_t length) {\n  if (!length || !buffer)\n    return 0;\n  void *cpy = fio_malloc(length);\n  if (!cpy)\n    return -1;\n  memcpy(cpy, buffer, length);\n  return fio_write2(uuid, .data.buffer = cpy, .length = length,\n                    .after.dealloc = fio_free);\n}\n\n/**\n * Sends data from a file as if it were a single atomic packet (sends up to\n * length bytes or until EOF is reached).\n *\n * Once the file was sent, the `source_fd` will be closed using `close`.\n *\n * The file will be buffered to the socket chunk by chunk, so that memory\n * consumption is capped. The system's `sendfile` might be used if conditions\n * permit.\n *\n * `offset` dictates the starting point for the data to be sent and length sets\n * the maximum amount of data to be sent.\n *\n * Returns -1 and closes the file on error. Returns 0 on success.\n */\ninline FIO_FUNC ssize_t fio_sendfile(intptr_t uuid, intptr_t source_fd,\n                                     off_t offset, size_t length) {\n  return fio_write2(uuid, .data.fd = source_fd, .length = length, .is_fd = 1,\n                    .offset = (uintptr_t)offset);\n}\n\n/**\n * Returns the number of `fio_write` calls that are waiting in the socket's\n * queue and haven't been processed.\n */\nsize_t fio_pending(intptr_t uuid);\n\n/**\n * `fio_flush` attempts to write any remaining data in the internal buffer to\n * the underlying file descriptor and closes the underlying file descriptor once\n * if it's marked for closure (and all the data was sent).\n *\n * Return values: 1 will be returned if data remains in the buffer. 0\n * will be returned if the buffer was fully drained. -1 will be returned on an\n * error or when the connection is closed.\n *\n * errno will be set to EWOULDBLOCK if the socket's lock is busy.\n */\nssize_t fio_flush(intptr_t uuid);\n\n/** Blocks until all the data was flushed from the buffer */\n#define fio_flush_strong(uuid)                                                 \\\n  do {                                                                         \\\n    errno = 0;                                                                 \\\n  } while (fio_flush(uuid) > 0 || errno == EWOULDBLOCK)\n\n/**\n * `fio_flush_all` attempts flush all the open connections.\n *\n * Returns the number of sockets still in need to be flushed.\n */\nsize_t fio_flush_all(void);\n\n/**\n * Convert between a facil.io connection's identifier (uuid) and system's fd.\n */\n#define fio_uuid2fd(uuid) ((int)((uintptr_t)uuid >> 8))\n\n/**\n * `fio_fd2uuid` takes an existing file decriptor `fd` and returns it's active\n * `uuid`.\n *\n * If the file descriptor was closed, __it will be registered as open__.\n *\n * If the file descriptor was closed directly (not using `fio_close`) or the\n * closure event hadn't been processed, a false positive will be possible. This\n * is not an issue, since the use of an invalid fd will result in the registry\n * being updated and the fd being closed.\n *\n * Returns -1 on error. Returns a valid socket (non-random) UUID.\n */\nintptr_t fio_fd2uuid(int fd);\n\n/**\n * `fio_fd2uuid` takes an existing file decriptor `fd` and returns it's active\n * `uuid`.\n *\n * If the file descriptor is marked as closed (wasn't opened / registered with\n * facil.io) the function returns -1;\n *\n * If the file descriptor was closed directly (not using `fio_close`) or the\n * closure event hadn't been processed, a false positive will be possible. This\n * is not an issue, since the use of an invalid fd will result in the registry\n * being updated and the fd being closed.\n *\n * Returns -1 on error. Returns a valid socket (non-random) UUID.\n */\nintptr_t fio_fd2uuid(int fd);\n\n/* *****************************************************************************\nConnection Object Links\n***************************************************************************** */\n\n/**\n * Links an object to a connection's lifetime, calling the `on_close` callback\n * once the connection has died.\n *\n * If the `uuid` is invalid, the `on_close` callback will be called immediately.\n *\n * NOTE: the `on_close` callback will be called with high priority. Long tasks\n * should be deferred.\n */\nvoid fio_uuid_link(intptr_t uuid, void *obj, void (*on_close)(void *obj));\n\n/**\n * Un-links an object from the connection's lifetime, so it's `on_close`\n * callback will NOT be called.\n *\n * Returns 0 on success and -1 if the object couldn't be found, setting `errno`\n * to `EBADF` if the `uuid` was invalid and `ENOTCONN` if the object wasn't\n * found (wasn't linked).\n *\n * NOTICE: a failure likely means that the object's `on_close` callback was\n * already called!\n */\nint fio_uuid_unlink(intptr_t uuid, void *obj);\n\n/* *****************************************************************************\nConnection Read / Write Hooks, for overriding the system calls\n***************************************************************************** */\n\n/**\n * The following struct is used for setting a the read/write hooks that will\n * replace the default system calls to `recv` and `write`.\n *\n * Note: facil.io library functions MUST NEVER be called by any r/w hook, or a\n * deadlock might occur.\n */\ntypedef struct fio_rw_hook_s {\n  /**\n   * Implement reading from a file descriptor. Should behave like the file\n   * system `read` call, including the setup or errno to EAGAIN / EWOULDBLOCK.\n   *\n   * Note: facil.io library functions MUST NEVER be called by any r/w hook, or a\n   * deadlock might occur.\n   */\n  ssize_t (*read)(intptr_t uuid, void *udata, void *buf, size_t count);\n  /**\n   * Implement writing to a file descriptor. Should behave like the file system\n   * `write` call.\n   *\n   * If an internal buffer is implemented and it is full, errno should be set to\n   * EWOULDBLOCK and the function should return -1.\n   *\n   * The function is expected to call the `flush` callback (or it's logic)\n   * internally. Either `write` OR `flush` are called.\n   *\n   * Note: facil.io library functions MUST NEVER be called by any r/w hook, or a\n   * deadlock might occur.\n   */\n  ssize_t (*write)(intptr_t uuid, void *udata, const void *buf, size_t count);\n  /**\n   * When implemented, this function will be called to flush any data remaining\n   * in the internal buffer.\n   *\n   * The function should return the number of bytes remaining in the internal\n   * buffer (0 is a valid response) or -1 (on error).\n   *\n   * Note: facil.io library functions MUST NEVER be called by any r/w hook, or a\n   * deadlock might occur.\n   */\n  ssize_t (*flush)(intptr_t uuid, void *udata);\n  /**\n   * The `before_close` callback is called only once before closing the `uuid`\n   * and it might not get called at all if an abnormal closure is detected.\n   *\n   * If the function returns a non-zero value, than closure will be delayed\n   * until the `flush` returns 0 (or less). This allows a closure signal to be\n   * sent by the read/write hook when such a signal is required.\n   *\n   * Note: facil.io library functions MUST NEVER be called by any r/w hook, or a\n   * deadlock might occur.\n   * */\n  ssize_t (*before_close)(intptr_t uuid, void *udata);\n  /**\n   * Called to perform cleanup after the socket was closed or a new read/write\n   * hook was set using `fio_rw_hook_set`.\n   *\n   * This callback is always called, even if `fio_rw_hook_set` fails.\n   * */\n  void (*cleanup)(void *udata);\n} fio_rw_hook_s;\n\n/** Sets a socket hook state (a pointer to the struct). */\nint fio_rw_hook_set(intptr_t uuid, fio_rw_hook_s *rw_hooks, void *udata);\n\n/**\n * Replaces an existing read/write hook with another from within a read/write\n * hook callback.\n *\n * Does NOT call any cleanup callbacks.\n *\n * Replaces existing udata. Call with the existing udata to keep it.\n *\n * Returns -1 on error, 0 on success.\n *\n * Note: this function is marked as unsafe, since it should only be called from\n *       within an existing read/write hook callback. Otherwise, data corruption\n *       might occur.\n */\nint fio_rw_hook_replace_unsafe(intptr_t uuid, fio_rw_hook_s *rw_hooks,\n                               void *udata);\n\n/** The default Read/Write hooks used for system Read/Write (udata == NULL). */\nextern const fio_rw_hook_s FIO_DEFAULT_RW_HOOKS;\n\n/* *****************************************************************************\nConcurrency overridable functions\n\nThese functions can be overridden so as to adjust for different environments.\n***************************************************************************** */\n\n/**\nOVERRIDE THIS to replace the default `fork` implementation.\n\nBehaves like the system's `fork`.\n*/\nint fio_fork(void);\n\n/**\n * OVERRIDE THIS to replace the default pthread implementation.\n *\n * Accepts a pointer to a function and a single argument that should be executed\n * within a new thread.\n *\n * The function should allocate memory for the thread object and return a\n * pointer to the allocated memory that identifies the thread.\n *\n * On error NULL should be returned.\n */\nvoid *fio_thread_new(void *(*thread_func)(void *), void *arg);\n\n/**\n * OVERRIDE THIS to replace the default pthread implementation.\n *\n * Frees the memory associated with a thread identifier (allows the thread to\n * run it's course, just the identifier is freed).\n */\nvoid fio_thread_free(void *p_thr);\n\n/**\n * OVERRIDE THIS to replace the default pthread implementation.\n *\n * Accepts a pointer returned from `fio_thread_new` (should also free any\n * allocated memory) and joins the associated thread.\n *\n * Return value is ignored.\n */\nint fio_thread_join(void *p_thr);\n\n/* *****************************************************************************\nConnection Task scheduling\n***************************************************************************** */\n\n/**\n * This is used to lock the protocol againste concurrency collisions and\n * concurrent memory deallocation.\n *\n * However, there are three levels of protection that allow non-coliding tasks\n * to protect the protocol object from being deallocated while in use:\n *\n * * `FIO_PR_LOCK_TASK` - a task lock locks might change data owned by the\n *    protocol object. This task is used for tasks such as `on_data`.\n *\n * * `FIO_PR_LOCK_WRITE` - a lock that promises only to use static data (data\n *    that tasks never changes) in order to write to the underlying socket.\n *    This lock is used for tasks such as `on_ready` and `ping`\n *\n * * `FIO_PR_LOCK_STATE` - a lock that promises only to retrieve static data\n *    (data that tasks never changes), performing no actions. This usually\n *    isn't used for client side code (used internally by facil) and is only\n *     meant for very short locks.\n */\nenum fio_protocol_lock_e {\n  FIO_PR_LOCK_TASK = 0,\n  FIO_PR_LOCK_WRITE = 1,\n  FIO_PR_LOCK_STATE = 2\n};\n\n/** Named arguments for the `fio_defer` function. */\ntypedef struct {\n  /** The type of task to be performed. Defaults to `FIO_PR_LOCK_TASK` but could\n   * also be seto to `FIO_PR_LOCK_WRITE`. */\n  enum fio_protocol_lock_e type;\n  /** The task (function) to be performed. This is required. */\n  void (*task)(intptr_t uuid, fio_protocol_s *, void *udata);\n  /** An opaque user data that will be passed along to the task. */\n  void *udata;\n  /** A fallback task, in case the connection was lost. Good for cleanup. */\n  void (*fallback)(intptr_t uuid, void *udata);\n} fio_defer_iotask_args_s;\n\n/**\n * Schedules a protected connection task. The task will run within the\n * connection's lock.\n *\n * If an error ocuurs or the connection is closed before the task can run, the\n * `fallback` task wil be called instead, allowing for resource cleanup.\n */\nvoid fio_defer_io_task(intptr_t uuid, fio_defer_iotask_args_s args);\n#define fio_defer_io_task(uuid, ...)                                           \\\n  fio_defer_io_task((uuid), (fio_defer_iotask_args_s){__VA_ARGS__})\n\n/* *****************************************************************************\nEvent / Task scheduling\n***************************************************************************** */\n\n/**\n * Defers a task's execution.\n *\n * Tasks are functions of the type `void task(void *, void *)`, they return\n * nothing (void) and accept two opaque `void *` pointers, user-data 1\n * (`udata1`) and user-data 2 (`udata2`).\n *\n * Returns -1 or error, 0 on success.\n */\nint fio_defer(void (*task)(void *, void *), void *udata1, void *udata2);\n\n/**\n * Creates a timer to run a task at the specified interval.\n *\n * The task will repeat `repetitions` times. If `repetitions` is set to 0, task\n * will repeat forever.\n *\n * Returns -1 on error.\n *\n * The `on_finish` handler is always called (even on error).\n */\nint fio_run_every(size_t milliseconds, size_t repetitions, void (*task)(void *),\n                  void *arg, void (*on_finish)(void *));\n\n/**\n * Performs all deferred tasks.\n */\nvoid fio_defer_perform(void);\n\n/** Returns true if there are deferred functions waiting for execution. */\nint fio_defer_has_queue(void);\n\n/* *****************************************************************************\nStartup / State Callbacks (fork, start up, idle, etc')\n***************************************************************************** */\n\n/** a callback type signifier */\ntypedef enum {\n  /** Called once during library initialization. */\n  FIO_CALL_ON_INITIALIZE,\n  /** Called once before starting up the IO reactor. */\n  FIO_CALL_PRE_START,\n  /** Called before each time the IO reactor forks a new worker. */\n  FIO_CALL_BEFORE_FORK,\n  /** Called after each fork (both in parent and workers). */\n  FIO_CALL_AFTER_FORK,\n  /** Called by a worker process right after forking. */\n  FIO_CALL_IN_CHILD,\n  /** Called by the master process after spawning a worker (after forking). */\n  FIO_CALL_IN_MASTER,\n  /** Called every time a *Worker* proceess starts. */\n  FIO_CALL_ON_START,\n  /** Called when facil.io enters idling mode. */\n  FIO_CALL_ON_IDLE,\n  /** Called before starting the shutdown sequence. */\n  FIO_CALL_ON_SHUTDOWN,\n  /** Called just before finishing up (both on chlid and parent processes). */\n  FIO_CALL_ON_FINISH,\n  /** Called by each worker the moment it detects the master process crashed. */\n  FIO_CALL_ON_PARENT_CRUSH,\n  /** Called by the parent (master) after a worker process crashed. */\n  FIO_CALL_ON_CHILD_CRUSH,\n  /** An alternative to the system's at_exit. */\n  FIO_CALL_AT_EXIT,\n  /** used for testing. */\n  FIO_CALL_NEVER\n} callback_type_e;\n\n/** Adds a callback to the list of callbacks to be called for the event. */\nvoid fio_state_callback_add(callback_type_e, void (*func)(void *), void *arg);\n\n/** Removes a callback from the list of callbacks to be called for the event. */\nint fio_state_callback_remove(callback_type_e, void (*func)(void *), void *arg);\n\n/**\n * Forces all the existing callbacks to run, as if the event occurred.\n *\n * Callbacks are called from last to first (last callback executes first).\n *\n * During an event, changes to the callback list are ignored (callbacks can't\n * remove other callbacks for the same event).\n */\nvoid fio_state_callback_force(callback_type_e);\n\n/** Clears all the existing callbacks for the event. */\nvoid fio_state_callback_clear(callback_type_e);\n\n/* *****************************************************************************\nLower Level API - for special circumstances, use with care.\n***************************************************************************** */\n\n/**\n * This function allows out-of-task access to a connection's `fio_protocol_s`\n * object by attempting to acquire a locked pointer.\n *\n * CAREFUL: mostly, the protocol object will be locked and a pointer will be\n * sent to the connection event's callback. However, if you need access to the\n * protocol object from outside a running connection task, you might need to\n * lock the protocol to prevent it from being closed / freed in the background.\n *\n * facil.io uses three different locks:\n *\n * * FIO_PR_LOCK_TASK locks the protocol for normal tasks (i.e. `on_data`,\n * `fio_defer`, `fio_every`).\n *\n * * FIO_PR_LOCK_WRITE locks the protocol for high priority `fio_write`\n * oriented tasks (i.e. `ping`, `on_ready`).\n *\n * * FIO_PR_LOCK_STATE locks the protocol for quick operations that need to copy\n * data from the protocol's data structure.\n *\n * IMPORTANT: Remember to call `fio_protocol_unlock` using the same lock type.\n *\n * Returns NULL on error (lock busy == EWOULDBLOCK, connection invalid == EBADF)\n * and a pointer to a protocol object on success.\n *\n * On error, consider calling `fio_defer` or `defer` instead of busy waiting.\n * Busy waiting SHOULD be avoided whenever possible.\n */\nfio_protocol_s *fio_protocol_try_lock(intptr_t uuid, enum fio_protocol_lock_e);\n/** Don't unlock what you don't own... see `fio_protocol_try_lock` for\n * details. */\nvoid fio_protocol_unlock(fio_protocol_s *pr, enum fio_protocol_lock_e);\n\n/* *****************************************************************************\n * Pub/Sub / Cluster Messages API\n *\n * Facil supports a message oriented API for use for Inter Process Communication\n * (IPC), publish/subscribe patterns, horizontal scaling and similar use-cases.\n *\n **************************************************************************** */\n#if FIO_PUBSUB_SUPPORT\n\n/* *****************************************************************************\n * Cluster Messages and Pub/Sub\n **************************************************************************** */\n\n/** An opaque subscription type. */\ntypedef struct subscription_s subscription_s;\n\n/** A pub/sub engine data structure. See details later on. */\ntypedef struct fio_pubsub_engine_s fio_pubsub_engine_s;\n\n/** The default engine (settable). Initial default is FIO_PUBSUB_CLUSTER. */\nextern fio_pubsub_engine_s *FIO_PUBSUB_DEFAULT;\n/** Used to publish the message to all clients in the cluster. */\n#define FIO_PUBSUB_CLUSTER ((fio_pubsub_engine_s *)1)\n/** Used to publish the message only within the current process. */\n#define FIO_PUBSUB_PROCESS ((fio_pubsub_engine_s *)2)\n/** Used to publish the message except within the current process. */\n#define FIO_PUBSUB_SIBLINGS ((fio_pubsub_engine_s *)3)\n/** Used to publish the message exclusively to the root / master process. */\n#define FIO_PUBSUB_ROOT ((fio_pubsub_engine_s *)4)\n\n/** Message structure, with an integer filter as well as a channel filter. */\ntypedef struct fio_msg_s {\n  /** A unique message type. Negative values are reserved, 0 == pub/sub. */\n  int32_t filter;\n  /**\n   * A channel name, allowing for pub/sub patterns.\n   *\n   * NOTE: the channel and msg strings should be considered immutable. The .capa\n   * field might be used for internal data.\n   */\n  fio_str_info_s channel;\n  /**\n   * The actual message.\n   *\n   * NOTE: the channel and msg strings should be considered immutable. The .capa\n   *field might be used for internal data.\n   **/\n  fio_str_info_s msg;\n  /** The `udata1` argument associated with the subscription. */\n  void *udata1;\n  /** The `udata1` argument associated with the subscription. */\n  void *udata2;\n  /** flag indicating if the message is JSON data or binary/text. */\n  uint8_t is_json;\n} fio_msg_s;\n\n/**\n * Pattern matching callback type - should return 0 unless channel matches\n * pattern.\n */\ntypedef int (*fio_match_fn)(fio_str_info_s pattern, fio_str_info_s channel);\n\nextern fio_match_fn FIO_MATCH_GLOB;\n\n/**\n * Possible arguments for the fio_subscribe method.\n *\n * NOTICE: passing protocol objects to the `udata` is not safe. This is because\n * protocol objects might be destroyed or invalidated according to both network\n * events (socket closure) and internal changes (i.e., `fio_attach` being\n * called). The preferred way is to add the `uuid` to the `udata` field and call\n * `fio_protocol_try_lock`.\n */\ntypedef struct {\n  /**\n   * If `filter` is set, all messages that match the filter's numerical value\n   * will be forwarded to the subscription's callback.\n   *\n   * Subscriptions can either require a match by filter or match by channel.\n   * This will match the subscription by filter.\n   */\n  int32_t filter;\n  /**\n   * If `channel` is set, all messages where `filter == 0` and the channel is an\n   * exact match will be forwarded to the subscription's callback.\n   *\n   * Subscriptions can either require a match by filter or match by channel.\n   * This will match the subscription by channel (only messages with no `filter`\n   * will be received.\n   */\n  fio_str_info_s channel;\n  /**\n   * The the `match` function allows pattern matching for channel names.\n   *\n   * When using a match function, the channel name is considered to be a pattern\n   * and each pub/sub message (a message where filter == 0) will be tested\n   * against that pattern.\n   *\n   * Using pattern subscriptions extensively could become a performance concern,\n   * since channel names are tested against each distinct pattern rather than\n   * leveraging a hashmap for possible name matching.\n   */\n  fio_match_fn match;\n  /**\n   * The callback will be called for each message forwarded to the subscription.\n   */\n  void (*on_message)(fio_msg_s *msg);\n  /** An optional callback for when a subscription is fully canceled. */\n  void (*on_unsubscribe)(void *udata1, void *udata2);\n  /** The udata values are ignored and made available to the callback. */\n  void *udata1;\n  /** The udata values are ignored and made available to the callback. */\n  void *udata2;\n} subscribe_args_s;\n\n/** Publishing and on_message callback arguments. */\ntypedef struct fio_publish_args_s {\n  /** The pub/sub engine that should be used to forward this message. */\n  fio_pubsub_engine_s const *engine;\n  /** A unique message type. Negative values are reserved, 0 == pub/sub. */\n  int32_t filter;\n  /** The pub/sub target channnel. */\n  fio_str_info_s channel;\n  /** The pub/sub message. */\n  fio_str_info_s message;\n  /** flag indicating if the message is JSON data or binary/text. */\n  uint8_t is_json;\n} fio_publish_args_s;\n\n/**\n * Subscribes to either a filter OR a channel (never both).\n *\n * Returns a subscription pointer on success or NULL on failure.\n *\n * See `subscribe_args_s` for details.\n */\nsubscription_s *fio_subscribe(subscribe_args_s args);\n/**\n * Subscribes to either a filter OR a channel (never both).\n *\n * Returns a subscription pointer on success or NULL on failure.\n *\n * See `subscribe_args_s` for details.\n */\n#define fio_subscribe(...) fio_subscribe((subscribe_args_s){__VA_ARGS__})\n\n/**\n * Cancels an existing subscriptions - actual effects might be delayed, for\n * example, if the subscription's callback is running in another thread.\n */\nvoid fio_unsubscribe(subscription_s *subscription);\n\n/**\n * This helper returns a temporary String with the subscription's channel (or a\n * string representing the filter).\n *\n * To keep the string beyond the lifetime of the subscription, copy the string.\n */\nfio_str_info_s fio_subscription_channel(subscription_s *subscription);\n\n/**\n * Publishes a message to the relevant subscribers (if any).\n *\n * See `fio_publish_args_s` for details.\n *\n * By default the message is sent using the FIO_PUBSUB_CLUSTER engine (all\n * processes, including the calling process).\n *\n * To limit the message only to other processes (exclude the calling process),\n * use the FIO_PUBSUB_SIBLINGS engine.\n *\n * To limit the message only to the calling process, use the\n * FIO_PUBSUB_PROCESS engine.\n *\n * To publish messages to the pub/sub layer, the `.filter` argument MUST be\n * equal to 0 or missing.\n */\nvoid fio_publish(fio_publish_args_s args);\n/**\n * Publishes a message to the relevant subscribers (if any).\n *\n * See `fio_publish_args_s` for details.\n *\n * By default the message is sent using the FIO_PUBSUB_CLUSTER engine (all\n * processes, including the calling process).\n *\n * To limit the message only to other processes (exclude the calling process),\n * use the FIO_PUBSUB_SIBLINGS engine.\n *\n * To limit the message only to the calling process, use the\n * FIO_PUBSUB_PROCESS engine.\n *\n * To publish messages to the pub/sub layer, the `.filter` argument MUST be\n * equal to 0 or missing.\n */\n#define fio_publish(...) fio_publish((fio_publish_args_s){__VA_ARGS__})\n/** for backwards compatibility */\n#define pubsub_publish fio_publish\n\n/** Finds the message's metadata by it's type ID. Returns the data or NULL. */\nvoid *fio_message_metadata(fio_msg_s *msg, intptr_t type_id);\n\n/**\n * Defers the current callback, so it will be called again for the message.\n */\nvoid fio_message_defer(fio_msg_s *msg);\n\n/* *****************************************************************************\n * Cluster / Pub/Sub Middleware and Extensions (\"Engines\")\n **************************************************************************** */\n\n/** Contains message metadata, set by message extensions. */\ntypedef struct fio_msg_metadata_s fio_msg_metadata_s;\nstruct fio_msg_metadata_s {\n  /**\n   * The type ID should be used to identify the metadata's actual structure.\n   *\n   * Negative ID values are reserved for internal use.\n   */\n  intptr_t type_id;\n  /**\n   * This method will be called by facil.io to cleanup the metadata resources.\n   *\n   * Don't alter / call this method, this data is reserved.\n   */\n  void (*on_finish)(fio_msg_s *msg, void *metadata);\n  /** The pointer to be disclosed to the `fio_message_metadata` function. */\n  void *metadata;\n};\n\n/**\n * Pub/Sub Metadata callback type.\n */\ntypedef fio_msg_metadata_s (*fio_msg_metadata_fn)(fio_str_info_s ch,\n                                                  fio_str_info_s msg,\n                                                  uint8_t is_json);\n\n/**\n * It's possible to attach metadata to facil.io pub/sub messages (filter == 0)\n * before they are published.\n *\n * This allows, for example, messages to be encoded as network packets for\n * outgoing protocols (i.e., encoding for WebSocket transmissions), improving\n * performance in large network based broadcasting.\n *\n * The callback should return a valid metadata object. If the `.metadata` field\n * returned is NULL than the result will be ignored.\n *\n * To remove a callback, set the `enable` flag to false (`0`).\n *\n * The cluster messaging system allows some messages to be flagged as JSON and\n * this flag is available to the metadata callback.\n */\nvoid fio_message_metadata_callback_set(fio_msg_metadata_fn callback,\n                                       int enable);\n\n/**\n * facil.io can be linked with external Pub/Sub services using \"engines\".\n *\n * Only unfiltered messages and subscriptions (where filter == 0) will be\n * forwarded to external Pub/Sub services.\n *\n * Engines MUST provide the listed function pointers and should be attached\n * using the `fio_pubsub_attach` function.\n *\n * Engines should disconnect / detach, before being destroyed, by using the\n * `fio_pubsub_detach` function.\n *\n * When an engine received a message to publish, it should call the\n * `pubsub_publish` function with the engine to which the message is forwarded.\n * i.e.:\n *\n *       pubsub_publish(\n *           .engine = FIO_PROCESS_ENGINE,\n *           .channel = channel_name,\n *           .message = msg_body );\n *\n * IMPORTANT: The `subscribe` and `unsubscribe` callbacks are called from within\n *            an internal lock. They MUST NEVER call pub/sub functions except by\n *            exiting the lock using `fio_defer`.\n */\nstruct fio_pubsub_engine_s {\n  /** Should subscribe channel. Failures are ignored. */\n  void (*subscribe)(const fio_pubsub_engine_s *eng, fio_str_info_s channel,\n                    fio_match_fn match);\n  /** Should unsubscribe channel. Failures are ignored. */\n  void (*unsubscribe)(const fio_pubsub_engine_s *eng, fio_str_info_s channel,\n                      fio_match_fn match);\n  /** Should publish a message through the engine. Failures are ignored. */\n  void (*publish)(const fio_pubsub_engine_s *eng, fio_str_info_s channel,\n                  fio_str_info_s msg, uint8_t is_json);\n};\n\n/**\n * Attaches an engine, so it's callback can be called by facil.io.\n *\n * The `subscribe` callback will be called for every existing channel.\n *\n * NOTE: the root (master) process will call `subscribe` for any channel in any\n * process, while all the other processes will call `subscribe` only for their\n * own channels. This allows engines to use the root (master) process as an\n * exclusive subscription process.\n */\nvoid fio_pubsub_attach(fio_pubsub_engine_s *engine);\n\n/** Detaches an engine, so it could be safely destroyed. */\nvoid fio_pubsub_detach(fio_pubsub_engine_s *engine);\n\n/**\n * Engines can ask facil.io to call the `subscribe` callback for all active\n * channels.\n *\n * This allows engines that lost their connection to their Pub/Sub service to\n * resubscribe all the currently active channels with the new connection.\n *\n * CAUTION: This is an evented task... try not to free the engine's memory while\n * resubscriptions are under way...\n *\n * NOTE: the root (master) process will call `subscribe` for any channel in any\n * process, while all the other processes will call `subscribe` only for their\n * own channels. This allows engines to use the root (master) process as an\n * exclusive subscription process.\n */\nvoid fio_pubsub_reattach(fio_pubsub_engine_s *eng);\n\n/** Returns true (1) if the engine is attached to the system. */\nint fio_pubsub_is_attached(fio_pubsub_engine_s *engine);\n\n#endif /* FIO_PUBSUB_SUPPORT */\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n\n\n\n\n              Atomic Operations and Spin Locking Helper Functions\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/* C11 Atomics are defined? */\n#if defined(__ATOMIC_RELAXED)\n/** An atomic exchange operation, returns previous value */\n#define fio_atomic_xchange(p_obj, value)                                       \\\n  __atomic_exchange_n((p_obj), (value), __ATOMIC_SEQ_CST)\n/** An atomic addition operation */\n#define fio_atomic_add(p_obj, value)                                           \\\n  __atomic_add_fetch((p_obj), (value), __ATOMIC_SEQ_CST)\n/** An atomic subtraction operation */\n#define fio_atomic_sub(p_obj, value)                                           \\\n  __atomic_sub_fetch((p_obj), (value), __ATOMIC_SEQ_CST)\n/* Note: __ATOMIC_SEQ_CST is probably safer and __ATOMIC_ACQ_REL may be faster\n */\n\n/* Select the correct compiler builtin method. */\n#elif __has_builtin(__sync_add_and_fetch)\n/** An atomic exchange operation, ruturns previous value */\n#define fio_atomic_xchange(p_obj, value)                                       \\\n  __sync_val_compare_and_swap((p_obj), *(p_obj), (value))\n/** An atomic addition operation */\n#define fio_atomic_add(p_obj, value) __sync_add_and_fetch((p_obj), (value))\n/** An atomic subtraction operation */\n#define fio_atomic_sub(p_obj, value) __sync_sub_and_fetch((p_obj), (value))\n\n#elif __GNUC__ > 3\n/** An atomic exchange operation, ruturns previous value */\n#define fio_atomic_xchange(p_obj, value)                                       \\\n  __sync_val_compare_and_swap((p_obj), *(p_obj), (value))\n/** An atomic addition operation */\n#define fio_atomic_add(p_obj, value) __sync_add_and_fetch((p_obj), (value))\n/** An atomic subtraction operation */\n#define fio_atomic_sub(p_obj, value) __sync_sub_and_fetch((p_obj), (value))\n\n#else\n#error Required builtin \"__sync_add_and_fetch\" not found.\n#endif\n\n/** An atomic based spinlock. */\ntypedef uint8_t volatile fio_lock_i;\n\n/** The initail value of an unlocked spinlock. */\n#define FIO_LOCK_INIT 0\n\n/** returns 0 if the lock was acquired and a non-zero value on failure. */\nFIO_FUNC inline int fio_trylock(fio_lock_i *lock);\n\n/**\n * Releases a spinlock. Releasing an unacquired lock will break it.\n *\n * Returns a non-zero value on success, or 0 if the lock was in an unloacked\n * state.\n */\nFIO_FUNC inline int fio_unlock(fio_lock_i *lock);\n\n/** Returns a spinlock's state (non 0 == Busy). */\nFIO_FUNC inline int fio_is_locked(fio_lock_i *lock);\n\n/** Busy waits for the spinlock (CAREFUL). */\nFIO_FUNC inline void fio_lock(fio_lock_i *lock);\n\n/**\n * Nanosleep seems to be the most effective and efficient thread rescheduler.\n */\nFIO_FUNC inline void fio_reschedule_thread(void);\n\n/** Nanosleep the thread - a blocking throttle. */\nFIO_FUNC inline void fio_throttle_thread(size_t nano_sec);\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n\n\n\n                         Simple Constant Time Operations\n                         ( boolean true / false and if )\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/** Returns 1 if the expression is true (input isn't zero). */\nFIO_FUNC inline uintptr_t fio_ct_true(uintptr_t cond) {\n  // promise that the highest bit is set if any bits are set, than shift.\n  return ((cond | (0 - cond)) >> ((sizeof(cond) << 3) - 1));\n}\n\n/** Returns 1 if the expression is false (input is zero). */\nFIO_FUNC inline uintptr_t fio_ct_false(uintptr_t cond) {\n  // fio_ct_true returns only one bit, XOR will inverse that bit.\n  return fio_ct_true(cond) ^ 1;\n}\n\n/** Returns `a` if `cond` is boolean and true, returns b otherwise. */\nFIO_FUNC inline uintptr_t fio_ct_if(uint8_t cond, uintptr_t a, uintptr_t b) {\n  // b^(a^b) cancels b out. 0-1 => sets all bits.\n  return (b ^ ((0 - (cond & 1)) & (a ^ b)));\n}\n\n/** Returns `a` if `cond` isn't zero (uses fio_ct_true), returns b otherwise. */\nFIO_FUNC inline uintptr_t fio_ct_if2(uintptr_t cond, uintptr_t a, uintptr_t b) {\n  // b^(a^b) cancels b out. 0-1 => sets all bits.\n  return fio_ct_if(fio_ct_true(cond), a, b);\n}\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n\n\n\n                         Byte Swapping and Network Order\n                       (Big Endian v.s Little Endian etc')\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/** inplace byte swap 16 bit integer */\n#if __has_builtin(__builtin_bswap16)\n#define fio_bswap16(i) __builtin_bswap16((uint16_t)(i))\n#else\n#define fio_bswap16(i) ((((i)&0xFFU) << 8) | (((i)&0xFF00U) >> 8))\n#endif\n/** inplace byte swap 32 bit integer */\n#if __has_builtin(__builtin_bswap32)\n#define fio_bswap32(i) __builtin_bswap32((uint32_t)(i))\n#else\n#define fio_bswap32(i)                                                         \\\n  ((((i)&0xFFUL) << 24) | (((i)&0xFF00UL) << 8) | (((i)&0xFF0000UL) >> 8) |    \\\n   (((i)&0xFF000000UL) >> 24))\n#endif\n/** inplace byte swap 64 bit integer */\n#if __has_builtin(__builtin_bswap64)\n#define fio_bswap64(i) __builtin_bswap64((uint64_t)(i))\n#else\n#define fio_bswap64(i)                                                         \\\n  ((((i)&0xFFULL) << 56) | (((i)&0xFF00ULL) << 40) |                           \\\n   (((i)&0xFF0000ULL) << 24) | (((i)&0xFF000000ULL) << 8) |                    \\\n   (((i)&0xFF00000000ULL) >> 8) | (((i)&0xFF0000000000ULL) >> 24) |            \\\n   (((i)&0xFF000000000000ULL) >> 40) | (((i)&0xFF00000000000000ULL) >> 56))\n#endif\n\n/* Note: using BIG_ENDIAN invokes false positives on some systems */\n#if !defined(__BIG_ENDIAN__)\n/* nothing to do */\n#elif (defined(__LITTLE_ENDIAN__) && !__LITTLE_ENDIAN__) ||                    \\\n    (defined(__BYTE_ORDER__) && (__BYTE_ORDER__ == __ORDER_BIG_ENDIAN__))\n#define __BIG_ENDIAN__ 1\n#elif !defined(__BIG_ENDIAN__) && !defined(__BYTE_ORDER__) &&                  \\\n    !defined(__LITTLE_ENDIAN__)\n#error Could not detect byte order on this system.\n#endif\n\n#if __BIG_ENDIAN__\n\n/** Local byte order to Network byte order, 16 bit integer */\n#define fio_lton16(i) (i)\n/** Local byte order to Network byte order, 32 bit integer */\n#define fio_lton32(i) (i)\n/** Local byte order to Network byte order, 62 bit integer */\n#define fio_lton64(i) (i)\n\n/** Network byte order to Local byte order, 16 bit integer */\n#define fio_ntol16(i) (i)\n/** Network byte order to Local byte order, 32 bit integer */\n#define fio_ntol32(i) (i)\n/** Network byte order to Local byte order, 62 bit integer */\n#define fio_ntol64(i) (i)\n\n#else /* Little Endian */\n\n/** Local byte order to Network byte order, 16 bit integer */\n#define fio_lton16(i) fio_bswap16((i))\n/** Local byte order to Network byte order, 32 bit integer */\n#define fio_lton32(i) fio_bswap32((i))\n/** Local byte order to Network byte order, 62 bit integer */\n#define fio_lton64(i) fio_bswap64((i))\n\n/** Network byte order to Local byte order, 16 bit integer */\n#define fio_ntol16(i) fio_bswap16((i))\n/** Network byte order to Local byte order, 32 bit integer */\n#define fio_ntol32(i) fio_bswap32((i))\n/** Network byte order to Local byte order, 62 bit integer */\n#define fio_ntol64(i) fio_bswap64((i))\n\n#endif\n\n/** 32Bit left rotation, inlined. */\n#define fio_lrot32(i, bits)                                                    \\\n  (((uint32_t)(i) << ((bits)&31UL)) | ((uint32_t)(i) >> ((-(bits)) & 31UL)))\n/** 32Bit right rotation, inlined. */\n#define fio_rrot32(i, bits)                                                    \\\n  (((uint32_t)(i) >> ((bits)&31UL)) | ((uint32_t)(i) << ((-(bits)) & 31UL)))\n\n/** 64Bit left rotation, inlined. */\n#define fio_lrot64(i, bits)                                                    \\\n  (((uint64_t)(i) << ((bits)&63UL)) | ((uint64_t)(i) >> ((-(bits)) & 63UL)))\n/** 64Bit right rotation, inlined. */\n#define fio_rrot64(i, bits)                                                    \\\n  (((uint64_t)(i) >> ((bits)&63UL)) | ((uint64_t)(i) << ((-(bits)) & 63UL)))\n\n/** unknown size element - left rotation, inlined. */\n#define fio_lrot(i, bits)                                                      \\\n  (((i) << ((bits) & ((sizeof((i)) << 3) - 1))) |                              \\\n   ((i) >> ((-(bits)) & ((sizeof((i)) << 3) - 1))))\n/** unknown size element - right rotation, inlined. */\n#define fio_rrot(i, bits)                                                      \\\n  (((i) >> ((bits) & ((sizeof((i)) << 3) - 1))) |                              \\\n   ((i) << ((-(bits)) & ((sizeof((i)) << 3) - 1))))\n\n/** Converts an unaligned network ordered byte stream to a 16 bit number. */\n#define fio_str2u16(c)                                                         \\\n  ((uint16_t)(((uint16_t)(((uint8_t *)(c))[0]) << 8) |                         \\\n              (uint16_t)(((uint8_t *)(c))[1])))\n/** Converts an unaligned network ordered byte stream to a 32 bit number. */\n#define fio_str2u32(c)                                                         \\\n  ((uint32_t)(((uint32_t)(((uint8_t *)(c))[0]) << 24) |                        \\\n              ((uint32_t)(((uint8_t *)(c))[1]) << 16) |                        \\\n              ((uint32_t)(((uint8_t *)(c))[2]) << 8) |                         \\\n              (uint32_t)(((uint8_t *)(c))[3])))\n\n/** Converts an unaligned network ordered byte stream to a 64 bit number. */\n#define fio_str2u64(c)                                                         \\\n  ((uint64_t)((((uint64_t)((uint8_t *)(c))[0]) << 56) |                        \\\n              (((uint64_t)((uint8_t *)(c))[1]) << 48) |                        \\\n              (((uint64_t)((uint8_t *)(c))[2]) << 40) |                        \\\n              (((uint64_t)((uint8_t *)(c))[3]) << 32) |                        \\\n              (((uint64_t)((uint8_t *)(c))[4]) << 24) |                        \\\n              (((uint64_t)((uint8_t *)(c))[5]) << 16) |                        \\\n              (((uint64_t)((uint8_t *)(c))[6]) << 8) | (((uint8_t *)(c))[7])))\n\n/** Writes a local 16 bit number to an unaligned buffer in network order. */\n#define fio_u2str16(buffer, i)                                                 \\\n  do {                                                                         \\\n    ((uint8_t *)(buffer))[0] = ((uint16_t)(i) >> 8) & 0xFF;                    \\\n    ((uint8_t *)(buffer))[1] = ((uint16_t)(i)) & 0xFF;                         \\\n  } while (0);\n\n/** Writes a local 32 bit number to an unaligned buffer in network order. */\n#define fio_u2str32(buffer, i)                                                 \\\n  do {                                                                         \\\n    ((uint8_t *)(buffer))[0] = ((uint32_t)(i) >> 24) & 0xFF;                   \\\n    ((uint8_t *)(buffer))[1] = ((uint32_t)(i) >> 16) & 0xFF;                   \\\n    ((uint8_t *)(buffer))[2] = ((uint32_t)(i) >> 8) & 0xFF;                    \\\n    ((uint8_t *)(buffer))[3] = ((uint32_t)(i)) & 0xFF;                         \\\n  } while (0);\n\n/** Writes a local 64 bit number to an unaligned buffer in network order. */\n#define fio_u2str64(buffer, i)                                                 \\\n  do {                                                                         \\\n    ((uint8_t *)(buffer))[0] = (((uint64_t)(i) >> 56) & 0xFF);                 \\\n    ((uint8_t *)(buffer))[1] = (((uint64_t)(i) >> 48) & 0xFF);                 \\\n    ((uint8_t *)(buffer))[2] = (((uint64_t)(i) >> 40) & 0xFF);                 \\\n    ((uint8_t *)(buffer))[3] = (((uint64_t)(i) >> 32) & 0xFF);                 \\\n    ((uint8_t *)(buffer))[4] = (((uint64_t)(i) >> 24) & 0xFF);                 \\\n    ((uint8_t *)(buffer))[5] = (((uint64_t)(i) >> 16) & 0xFF);                 \\\n    ((uint8_t *)(buffer))[6] = (((uint64_t)(i) >> 8) & 0xFF);                  \\\n    ((uint8_t *)(buffer))[7] = (((uint64_t)(i)) & 0xFF);                       \\\n  } while (0);\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n\n\n\n                       Converting Numbers to Strings (and back)\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/* *****************************************************************************\nStrings to Numbers\n***************************************************************************** */\n\n/**\n * A helper function that converts between String data to a signed int64_t.\n *\n * Numbers are assumed to be in base 10. Octal (`0###`), Hex (`0x##`/`x##`) and\n * binary (`0b##`/ `b##`) are recognized as well. For binary Most Significant\n * Bit must come first.\n *\n * The most significant difference between this function and `strtol` (aside of\n * API design), is the added support for binary representations.\n */\nint64_t fio_atol(char **pstr);\n\n/** A helper function that converts between String data to a signed double. */\ndouble fio_atof(char **pstr);\n\n/* *****************************************************************************\nNumbers to Strings\n***************************************************************************** */\n\n/**\n * A helper function that writes a signed int64_t to a string.\n *\n * No overflow guard is provided, make sure there's at least 68 bytes\n * available (for base 2).\n *\n * Offers special support for base 2 (binary), base 8 (octal), base 10 and base\n * 16 (hex). An unsupported base will silently default to base 10. Prefixes\n * aren't added (i.e., no \"0x\" or \"0b\" at the beginning of the string).\n *\n * Returns the number of bytes actually written (excluding the NUL\n * terminator).\n */\nsize_t fio_ltoa(char *dest, int64_t num, uint8_t base);\n\n/**\n * A helper function that converts between a double to a string.\n *\n * No overflow guard is provided, make sure there's at least 130 bytes\n * available (for base 2).\n *\n * Supports base 2, base 10 and base 16. An unsupported base will silently\n * default to base 10. Prefixes aren't added (i.e., no \"0x\" or \"0b\" at the\n * beginning of the string).\n *\n * Returns the number of bytes actually written (excluding the NUL\n * terminator).\n */\nsize_t fio_ftoa(char *dest, double num, uint8_t base);\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n                      Random Generator Functions\n\n                  Probably not cryptographically safe\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/** Returns 64 psedo-random bits. Probably not cryptographically safe. */\nuint64_t fio_rand64(void);\n\n/** Writes `length` bytes of psedo-random bits to the target buffer. */\nvoid fio_rand_bytes(void *target, size_t length);\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n                              Hash Functions and Friends\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/* defines the secret seed to be used by keyd hashing functions*/\n#ifndef FIO_HASH_SECRET_SEED64_1\nuint8_t __attribute__((weak)) fio_hash_secret_marker1;\nuint8_t __attribute__((weak)) fio_hash_secret_marker2;\n#define FIO_HASH_SECRET_SEED64_1 ((uintptr_t)&fio_hash_secret_marker1)\n#define FIO_HASH_SECRET_SEED64_2 ((uintptr_t)&fio_hash_secret_marker2)\n#endif\n\n#if FIO_USE_RISKY_HASH\n#define FIO_HASH_FN(data, length, key1, key2)                                  \\\n  fio_risky_hash((data), (length),                                             \\\n                 ((uint64_t)(key1) >> 19) | ((uint64_t)(key2) << 27))\n#else\n#define FIO_HASH_FN(data, length, key1, key2)                                  \\\n  fio_siphash13((data), (length), (uint64_t)(key1), (uint64_t)(key2))\n#endif\n\n/* *****************************************************************************\nRisky Hash (always available, even if using only the fio.h header)\n***************************************************************************** */\n\n/* Risky Hash primes */\n#define RISKY_PRIME_0 0xFBBA3FA15B22113B\n#define RISKY_PRIME_1 0xAB137439982B86C9\n\n/* Risky Hash consumption round, accepts a state word s and an input word w */\n#define fio_risky_consume(v, w)                                                \\\n  (v) += (w);                                                                  \\\n  (v) = fio_lrot64((v), 33);                                                   \\\n  (v) += (w);                                                                  \\\n  (v) *= RISKY_PRIME_0;\n\n/*  Computes a facil.io Risky Hash. */\nFIO_FUNC inline uint64_t fio_risky_hash(const void *data_, size_t len,\n                                        uint64_t seed) {\n  /* reading position */\n  const uint8_t *data = (uint8_t *)data_;\n\n  /* The consumption vectors initialized state */\n  register uint64_t v0 = seed ^ RISKY_PRIME_1;\n  register uint64_t v1 = ~seed + RISKY_PRIME_1;\n  register uint64_t v2 =\n      fio_lrot64(seed, 17) ^ ((~RISKY_PRIME_1) + RISKY_PRIME_0);\n  register uint64_t v3 = fio_lrot64(seed, 33) + (~RISKY_PRIME_1);\n\n  /* consume 256 bit blocks */\n  for (size_t i = len >> 5; i; --i) {\n    fio_risky_consume(v0, fio_str2u64(data));\n    fio_risky_consume(v1, fio_str2u64(data + 8));\n    fio_risky_consume(v2, fio_str2u64(data + 16));\n    fio_risky_consume(v3, fio_str2u64(data + 24));\n    data += 32;\n  }\n\n  /* Consume any remaining 64 bit words. */\n  switch (len & 24) {\n  case 24:\n    fio_risky_consume(v2, fio_str2u64(data + 16));\n    /* fallthrough */\n  case 16:\n    fio_risky_consume(v1, fio_str2u64(data + 8));\n    /* fallthrough */\n  case 8:\n    fio_risky_consume(v0, fio_str2u64(data));\n    data += len & 24;\n  }\n\n  uint64_t tmp = 0;\n  /* consume leftover bytes, if any */\n  switch ((len & 7)) {\n  case 7:\n    tmp |= ((uint64_t)data[6]) << 8;\n    /* fallthrough */\n  case 6:\n    tmp |= ((uint64_t)data[5]) << 16;\n    /* fallthrough */\n  case 5:\n    tmp |= ((uint64_t)data[4]) << 24;\n    /* fallthrough */\n  case 4:\n    tmp |= ((uint64_t)data[3]) << 32;\n    /* fallthrough */\n  case 3:\n    tmp |= ((uint64_t)data[2]) << 40;\n    /* fallthrough */\n  case 2:\n    tmp |= ((uint64_t)data[1]) << 48;\n    /* fallthrough */\n  case 1:\n    tmp |= ((uint64_t)data[0]) << 56;\n    /* ((len >> 3) & 3) is a 0...3 value indicating consumption vector */\n    switch ((len >> 3) & 3) {\n    case 3:\n      fio_risky_consume(v3, tmp);\n      break;\n    case 2:\n      fio_risky_consume(v2, tmp);\n      break;\n    case 1:\n      fio_risky_consume(v1, tmp);\n      break;\n    case 0:\n      fio_risky_consume(v0, tmp);\n      break;\n    }\n  }\n\n  /* merge and mix */\n  uint64_t result = fio_lrot64(v0, 17) + fio_lrot64(v1, 13) +\n                    fio_lrot64(v2, 47) + fio_lrot64(v3, 57);\n\n  len ^= (len << 33);\n  result += len;\n\n  result += v0 * RISKY_PRIME_1;\n  result ^= fio_lrot64(result, 13);\n  result += v1 * RISKY_PRIME_1;\n  result ^= fio_lrot64(result, 29);\n  result += v2 * RISKY_PRIME_1;\n  result ^= fio_lrot64(result, 33);\n  result += v3 * RISKY_PRIME_1;\n  result ^= fio_lrot64(result, 51);\n\n  /* irreversible avalanche... I think */\n  result ^= (result >> 29) * RISKY_PRIME_0;\n  return result;\n}\n\n#undef fio_risky_consume\n#undef FIO_RISKY_PRIME_0\n#undef FIO_RISKY_PRIME_1\n\n/* *****************************************************************************\nSipHash\n***************************************************************************** */\n\n/**\n * A SipHash variation (2-4).\n */\nuint64_t fio_siphash24(const void *data, size_t len, uint64_t key1,\n                       uint64_t key2);\n\n/**\n * A SipHash 1-3 variation.\n */\nuint64_t fio_siphash13(const void *data, size_t len, uint64_t key1,\n                       uint64_t key2);\n\n/**\n * The Hashing function used by dynamic facil.io objects.\n *\n * Currently implemented using SipHash 1-3.\n */\n#define fio_siphash(data, length, k1, k2)                                      \\\n  fio_siphash13((data), (length), (k1), (k2))\n\n/* *****************************************************************************\nSHA-1\n***************************************************************************** */\n\n/**\nSHA-1 hashing container - you should ignore the contents of this struct.\n\nThe `sha1_s` type will contain all the sha1 data required to perform the\nhashing, managing it's encoding. If it's stack allocated, no freeing will be\nrequired.\n\nUse, for example:\n\n    fio_sha1_s sha1;\n    fio_sha1_init(&sha1);\n    fio_sha1_write(&sha1,\n                  \"The quick brown fox jumps over the lazy dog\", 43);\n    char *hashed_result = fio_sha1_result(&sha1);\n*/\ntypedef struct {\n  uint64_t length;\n  uint8_t buffer[64];\n  union {\n    uint32_t i[5];\n    unsigned char str[21];\n  } digest;\n} fio_sha1_s;\n\n/**\nInitialize or reset the `sha1` object. This must be performed before hashing\ndata using sha1.\n*/\nfio_sha1_s fio_sha1_init(void);\n/**\nWrites data to the sha1 buffer.\n*/\nvoid fio_sha1_write(fio_sha1_s *s, const void *data, size_t len);\n/**\nFinalizes the SHA1 hash, returning the Hashed data.\n\n`fio_sha1_result` can be called for the same object multiple times, but the\nfinalization will only be performed the first time this function is called.\n*/\nchar *fio_sha1_result(fio_sha1_s *s);\n\n/**\nAn SHA1 helper function that performs initialiation, writing and finalizing.\n*/\ninline FIO_FUNC char *fio_sha1(fio_sha1_s *s, const void *data, size_t len) {\n  *s = fio_sha1_init();\n  fio_sha1_write(s, data, len);\n  return fio_sha1_result(s);\n}\n\n/* *****************************************************************************\nSHA-2\n***************************************************************************** */\n\n/**\nSHA-2 function variants.\n\nThis enum states the different SHA-2 function variants. placing SHA_512 at the\nbeginning is meant to set this variant as the default (in case a 0 is passed).\n*/\ntypedef enum {\n  SHA_512 = 1,\n  SHA_512_256 = 3,\n  SHA_512_224 = 5,\n  SHA_384 = 7,\n  SHA_256 = 2,\n  SHA_224 = 4,\n} fio_sha2_variant_e;\n\n/**\nSHA-2 hashing container - you should ignore the contents of this struct.\n\nThe `sha2_s` type will contain all the SHA-2 data required to perform the\nhashing, managing it's encoding. If it's stack allocated, no freeing will be\nrequired.\n\nUse, for example:\n\n    fio_sha2_s sha2;\n    fio_sha2_init(&sha2, SHA_512);\n    fio_sha2_write(&sha2,\n                  \"The quick brown fox jumps over the lazy dog\", 43);\n    char *hashed_result = fio_sha2_result(&sha2);\n\n*/\ntypedef struct {\n  /* notice: we're counting bits, not bytes. max length: 2^128 bits */\n  union {\n    uint8_t bytes[16];\n    uint8_t matrix[4][4];\n    uint32_t words_small[4];\n    uint64_t words[2];\n#if defined(__SIZEOF_INT128__)\n    __uint128_t i;\n#endif\n  } length;\n  uint8_t buffer[128];\n  union {\n    uint32_t i32[16];\n    uint64_t i64[8];\n    uint8_t str[65]; /* added 64+1 for the NULL byte.*/\n  } digest;\n  fio_sha2_variant_e type;\n} fio_sha2_s;\n\n/**\nInitialize/reset the SHA-2 object.\n\nSHA-2 is actually a family of functions with different variants. When\ninitializing the SHA-2 container, you must select the variant you intend to\napply. The following are valid options (see the sha2_variant enum):\n\n- SHA_512 (== 0)\n- SHA_384\n- SHA_512_224\n- SHA_512_256\n- SHA_256\n- SHA_224\n\n*/\nfio_sha2_s fio_sha2_init(fio_sha2_variant_e variant);\n/**\nWrites data to the SHA-2 buffer.\n*/\nvoid fio_sha2_write(fio_sha2_s *s, const void *data, size_t len);\n/**\nFinalizes the SHA-2 hash, returning the Hashed data.\n\n`sha2_result` can be called for the same object multiple times, but the\nfinalization will only be performed the first time this function is called.\n*/\nchar *fio_sha2_result(fio_sha2_s *s);\n\n/**\nAn SHA2 helper function that performs initialiation, writing and finalizing.\nUses the SHA2 512 variant.\n*/\ninline FIO_FUNC char *fio_sha2_512(fio_sha2_s *s, const void *data,\n                                   size_t len) {\n  *s = fio_sha2_init(SHA_512);\n  fio_sha2_write(s, data, len);\n  return fio_sha2_result(s);\n}\n\n/**\nAn SHA2 helper function that performs initialiation, writing and finalizing.\nUses the SHA2 256 variant.\n*/\ninline FIO_FUNC char *fio_sha2_256(fio_sha2_s *s, const void *data,\n                                   size_t len) {\n  *s = fio_sha2_init(SHA_256);\n  fio_sha2_write(s, data, len);\n  return fio_sha2_result(s);\n}\n\n/**\nAn SHA2 helper function that performs initialiation, writing and finalizing.\nUses the SHA2 384 variant.\n*/\ninline FIO_FUNC char *fio_sha2_384(fio_sha2_s *s, const void *data,\n                                   size_t len) {\n  *s = fio_sha2_init(SHA_384);\n  fio_sha2_write(s, data, len);\n  return fio_sha2_result(s);\n}\n\n/* *****************************************************************************\nBase64 (URL) encoding\n***************************************************************************** */\n\n/**\nThis will encode a byte array (data) of a specified length (len) and\nplace the encoded data into the target byte buffer (target). The target buffer\nMUST have enough room for the expected data.\n\nBase64 encoding always requires 4 bytes for each 3 bytes. Padding is added if\nthe raw data's length isn't devisable by 3.\n\nAlways assume the target buffer should have room enough for (len*4/3 + 4)\nbytes.\n\nReturns the number of bytes actually written to the target buffer\n(including the Base64 required padding and excluding a NULL terminator).\n\nA NULL terminator char is NOT written to the target buffer.\n*/\nint fio_base64_encode(char *target, const char *data, int len);\n\n/**\nSame as fio_base64_encode, but using Base64URL encoding.\n*/\nint fio_base64url_encode(char *target, const char *data, int len);\n\n/**\nThis will decode a Base64 encoded string of a specified length (len) and\nplace the decoded data into the target byte buffer (target).\n\nThe target buffer MUST have enough room for 2 bytes in addition to the expected\ndata (NUL byte + padding test).\n\nA NUL byte will be appended to the target buffer. The function will return\nthe number of bytes written to the target buffer (excluding the NUL byte).\n\nIf the target buffer is NUL, the encoded string will be destructively edited\nand the decoded data will be placed in the original string's buffer.\n\nBase64 encoding always requires 4 bytes for each 3 bytes. Padding is added if\nthe raw data's length isn't devisable by 3. Hence, the target buffer should\nbe, at least, `base64_len/4*3 + 3` long.\n\nReturns the number of bytes actually written to the target buffer (excluding\nthe NUL terminator byte).\n\nNote:\n====\n\nThe decoder is variation agnostic (will decode Base64, Base64 URL and Base64 XML\nvariations) and will attempt it's best to ignore invalid data, (in order to\nsupport the MIME Base64 variation in RFC 2045).\n\nThis comes at the cost of error\nchecking, so the encoding isn't validated and invalid input might produce\nsurprising results.\n*/\nint fio_base64_decode(char *target, char *encoded, int base64_len);\n\n/* *****************************************************************************\nTesting\n***************************************************************************** */\n\n#if DEBUG\nvoid fio_test(void);\n#else\n#define fio_test()\n#endif\n\n/* *****************************************************************************\nC++ extern end\n***************************************************************************** */\n#ifdef __cplusplus\n} /* extern \"C\" */\n#endif\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n\n                             Memory Allocator Details\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/**\n * This is a custom memory allocator the utilizes memory pools to allow for\n * concurrent memory allocations across threads.\n *\n * Allocated memory is always zeroed out and aligned on a 16 byte boundary.\n *\n * Reallocated memory is always aligned on a 16 byte boundary but it might be\n * filled with junk data after the valid data (this is true also for\n * `fio_realloc2`).\n *\n * The memory allocator assumes multiple concurrent allocation/deallocation,\n * short life spans (memory is freed shortly, but not immediately, after it was\n * allocated) as well as small allocations (realloc almost always copies data).\n *\n * These assumptions allow the allocator to avoid lock contention by ignoring\n * fragmentation within a memory \"block\" and waiting for the whole \"block\" to be\n * freed before it's memory is recycled (no per-allocation \"free list\").\n *\n * An \"arena\" is allocated per-CPU core during initialization - there's no\n * dynamic allocation of arenas. This allows threads to minimize lock contention\n * by cycling through the arenas until a free arena is detected.\n *\n * There should be a free arena at any given time (statistically speaking) and\n * the thread will only be deferred in the unlikely event in which there's no\n * available arena.\n *\n * By avoiding the \"free-list\", the need for allocation \"headers\" is also\n * avoided and allocations are performed with practically zero overhead (about\n * 32 bytes overhead per 32KB memory, that's 1 bit per 1Kb).\n *\n * However, the lack of a \"free list\" means that memory \"leaks\" are more\n * expensive and small long-life allocations could cause fragmentation if\n * performed periodically (rather than performed during startup).\n *\n * This allocator should NOT be used for objects with a long life-span, because\n * even a single persistent object will prevent the re-use of the whole memory\n * block from which it was allocated (see FIO_MEMORY_BLOCK_SIZE for size).\n *\n * Some more details:\n *\n * Allocation and deallocations and (usually) managed by \"blocks\".\n *\n * A memory \"block\" can include any number of memory pages that are a multiple\n * of 2 (up to 1Mb of memory). However, the default value, set by the value of\n * FIO_MEMORY_BLOCK_SIZE_LOG, is 32Kb (see value at the end of this header).\n *\n * Each block includes a 32 byte header that uses reference counters and\n * position markers (24 bytes are required padding).\n *\n * The block's position marker (`pos`) marks the next available byte (counted in\n * multiples of 16 bytes).\n *\n * The block's reference counter (`ref`) counts how many allocations reference\n * memory in the block (including the \"arena\" that \"owns\" the block).\n *\n * Except for the position marker (`pos`) that acts the same as `sbrk`, there's\n * no way to know which \"slices\" are allocated and which \"slices\" are available.\n *\n * The allocator uses `mmap` when requesting memory from the system and for\n * allocations bigger than MEMORY_BLOCK_ALLOC_LIMIT (37.5% of the block).\n *\n * Small allocations are differentiated from big allocations by their memory\n * alignment.\n *\n * If a memory allocation is placed 16 bytes after whole block alignment (within\n * a block's padding zone), the memory was allocated directly using `mmap` as a\n * \"big allocation\". The 16 bytes include an 8 byte header and an 8 byte\n * padding.\n *\n * To replace the system's `malloc` function family compile with the\n * `FIO_OVERRIDE_MALLOC` defined (`-DFIO_OVERRIDE_MALLOC`).\n *\n * When using tcmalloc or jemalloc, it's possible to define `FIO_FORCE_MALLOC`\n * to prevent the facil.io allocator from compiling (`-DFIO_FORCE_MALLOC`).\n */\n\n#ifndef FIO_MEMORY_BLOCK_SIZE_LOG\n/**\n * The logarithmic value for a memory block, 15 == 32Kb, 16 == 64Kb, etc'\n *\n * By default, a block of memory is 32Kb silce from an 8Mb allocation.\n *\n * A value of 16 will make this a 64Kb silce from a 16Mb allocation.\n */\n#define FIO_MEMORY_BLOCK_SIZE_LOG (15)\n#endif\n\n#undef FIO_MEMORY_BLOCK_SIZE\n/** The resulting memoru block size, depends on `FIO_MEMORY_BLOCK_SIZE_LOG` */\n#define FIO_MEMORY_BLOCK_SIZE ((uintptr_t)1 << FIO_MEMORY_BLOCK_SIZE_LOG)\n\n/**\n * The maximum allocation size, after which `mmap` will be called instead of the\n * facil.io allocator.\n *\n * Defaults to 50% of the block (16Kb), after which `mmap` is used instead\n */\n#ifndef FIO_MEMORY_BLOCK_ALLOC_LIMIT\n#define FIO_MEMORY_BLOCK_ALLOC_LIMIT (FIO_MEMORY_BLOCK_SIZE >> 1)\n#endif\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n\n\n                           Spin locking Implementation\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n/**\n * Nanosleep seems to be the most effective and efficient thread rescheduler.\n */\nFIO_FUNC inline void fio_reschedule_thread(void) {\n  const struct timespec tm = {.tv_nsec = 1};\n  nanosleep(&tm, NULL);\n}\n\n/** Nanosleep the thread - a blocking throttle. */\nFIO_FUNC inline void fio_throttle_thread(size_t nano_sec) {\n  const struct timespec tm = {.tv_nsec = (long)(nano_sec % 1000000000),\n                              .tv_sec = (time_t)(nano_sec / 1000000000)};\n  nanosleep(&tm, NULL);\n}\n\n/** returns 0 if the lock was acquired and another value on failure. */\nFIO_FUNC inline int fio_trylock(fio_lock_i *lock) {\n  __asm__ volatile(\"\" ::: \"memory\");\n  fio_lock_i ret = fio_atomic_xchange(lock, 1);\n  __asm__ volatile(\"\" ::: \"memory\");\n  return ret;\n}\n\n/**\n * Releases a spinlock. Releasing an unacquired lock will break it.\n *\n * Returns a non-zero value on success, or 0 if the lock was in an unloacked\n * state.\n */\nFIO_FUNC inline int fio_unlock(fio_lock_i *lock) {\n  __asm__ volatile(\"\" ::: \"memory\");\n  fio_lock_i ret = fio_atomic_xchange(lock, 0);\n  return ret;\n}\n\n/** Returns a spinlock's state (non 0 == Busy). */\nFIO_FUNC inline int fio_is_locked(fio_lock_i *lock) {\n  __asm__ volatile(\"\" ::: \"memory\");\n  return *lock;\n}\n\n/** Busy waits for the spinlock (CAREFUL). */\nFIO_FUNC inline void fio_lock(fio_lock_i *lock) {\n  while (fio_trylock(lock)) {\n    fio_reschedule_thread();\n  }\n}\n\n#if DEBUG_SPINLOCK\n/** Busy waits for a lock, reports contention. */\nFIO_FUNC inline void fio_lock_dbg(fio_lock_i *lock, const char *file,\n                                  int line) {\n  size_t lock_cycle_count = 0;\n  while (fio_trylock(lock)) {\n    if (lock_cycle_count >= 8 &&\n        (lock_cycle_count == 8 || !(lock_cycle_count & 511)))\n      fprintf(stderr, \"[DEBUG] fio-spinlock spin %s:%d round %zu\\n\", file, line,\n              lock_cycle_count);\n    ++lock_cycle_count;\n    fio_reschedule_thread();\n  }\n  if (lock_cycle_count >= 8)\n    fprintf(stderr, \"[DEBUG] fio-spinlock spin %s:%d total = %zu\\n\", file, line,\n            lock_cycle_count);\n}\n#define fio_lock(lock) fio_lock_dbg((lock), __FILE__, __LINE__)\n\nFIO_FUNC inline int fio_trylock_dbg(fio_lock_i *lock, const char *file,\n                                    int line) {\n  static int last_line = 0;\n  static size_t count = 0;\n  int result = fio_trylock(lock);\n  if (!result) {\n    count = 0;\n    last_line = 0;\n  } else if (line == last_line) {\n    ++count;\n    if (count >= 2)\n      fprintf(stderr, \"[DEBUG] trying fio-spinlock %s:%d attempt %zu\\n\", file,\n              line, count);\n  } else {\n    count = 0;\n    last_line = line;\n  }\n  return result;\n}\n#define fio_trylock(lock) fio_trylock_dbg((lock), __FILE__, __LINE__)\n#endif /* DEBUG_SPINLOCK */\n\n#endif /* H_FACIL_IO_H */\n\n/* *****************************************************************************\n\n\n\n\n\n\n                    Memory allocation macros for helper types\n\n\n\n\n\n\n***************************************************************************** */\n\n#undef FIO_MALLOC\n#undef FIO_CALLOC\n#undef FIO_REALLOC\n#undef FIO_FREE\n\n#if FIO_FORCE_MALLOC || FIO_FORCE_MALLOC_TMP\n#define FIO_MALLOC(size) calloc((size), 1)\n#define FIO_CALLOC(size, units) calloc((size), (units))\n#define FIO_REALLOC(ptr, new_length, existing_data_length)                     \\\n  realloc((ptr), (new_length))\n#define FIO_FREE free\n\n#else\n#define FIO_MALLOC(size) fio_malloc((size))\n#define FIO_CALLOC(size, units) fio_calloc((size), (units))\n#define FIO_REALLOC(ptr, new_length, existing_data_length)                     \\\n  fio_realloc2((ptr), (new_length), (existing_data_length))\n#define FIO_FREE fio_free\n#endif /* FIO_FORCE_MALLOC || FIO_FORCE_MALLOC_TMP */\n\n/* *****************************************************************************\n\n\n\n\n\n\n                           Linked List Helpers\n\n        exposes internally used inline helpers for linked lists\n\n\n\n\n\n\n***************************************************************************** */\n\n#if !defined(H_FIO_LINKED_LIST_H) && defined(FIO_INCLUDE_LINKED_LIST)\n\n#define H_FIO_LINKED_LIST_H\n#undef FIO_INCLUDE_LINKED_LIST\n/* *****************************************************************************\nData Structure and Initialization.\n***************************************************************************** */\n\n/** an embeded linked list. */\ntypedef struct fio_ls_embd_s {\n  struct fio_ls_embd_s *prev;\n  struct fio_ls_embd_s *next;\n} fio_ls_embd_s;\n\n/** an independent linked list. */\ntypedef struct fio_ls_s {\n  struct fio_ls_s *prev;\n  struct fio_ls_s *next;\n  const void *obj;\n} fio_ls_s;\n\n#define FIO_LS_INIT(name)                                                      \\\n  { .next = &(name), .prev = &(name) }\n\n/* *****************************************************************************\nEmbedded Linked List API\n***************************************************************************** */\n\n/** Adds a node to the list's head. */\nFIO_FUNC inline void fio_ls_embd_push(fio_ls_embd_s *dest, fio_ls_embd_s *node);\n\n/** Adds a node to the list's tail. */\nFIO_FUNC inline void fio_ls_embd_unshift(fio_ls_embd_s *dest,\n                                         fio_ls_embd_s *node);\n\n/** Removes a node from the list's head. */\nFIO_FUNC inline fio_ls_embd_s *fio_ls_embd_pop(fio_ls_embd_s *list);\n\n/** Removes a node from the list's tail. */\nFIO_FUNC inline fio_ls_embd_s *fio_ls_embd_shift(fio_ls_embd_s *list);\n\n/** Removes a node from the containing node. */\nFIO_FUNC inline fio_ls_embd_s *fio_ls_embd_remove(fio_ls_embd_s *node);\n\n/** Tests if the list is empty. */\nFIO_FUNC inline int fio_ls_embd_is_empty(fio_ls_embd_s *list);\n\n/** Tests if the list is NOT empty (contains any nodes). */\nFIO_FUNC inline int fio_ls_embd_any(fio_ls_embd_s *list);\n\n/**\n * Iterates through the list using a `for` loop.\n *\n * Access the data with `pos->obj` (`pos` can be named however you please).\n */\n#define FIO_LS_EMBD_FOR(list, node)\n\n/**\n * Takes a list pointer `plist` and returns a pointer to it's container.\n *\n * This uses pointer offset calculations and can be used to calculate any\n * struct's pointer (not just list containers) as an offset from a pointer of\n * one of it's members.\n *\n * Very useful.\n */\n#define FIO_LS_EMBD_OBJ(type, member, plist)                                   \\\n  ((type *)((uintptr_t)(plist) - (uintptr_t)(&(((type *)0)->member))))\n\n/* *****************************************************************************\nIndependent Linked List API\n***************************************************************************** */\n\n/** Adds an object to the list's head, returnin's the object's location. */\nFIO_FUNC inline fio_ls_s *fio_ls_push(fio_ls_s *pos, const void *obj);\n\n/** Adds an object to the list's tail, returnin's the object's location. */\nFIO_FUNC inline fio_ls_s *fio_ls_unshift(fio_ls_s *pos, const void *obj);\n\n/** Removes an object from the list's head. */\nFIO_FUNC inline void *fio_ls_pop(fio_ls_s *list);\n\n/** Removes an object from the list's tail. */\nFIO_FUNC inline void *fio_ls_shift(fio_ls_s *list);\n\n/** Removes a node from the list, returning the contained object. */\nFIO_FUNC inline void *fio_ls_remove(fio_ls_s *node);\n\n/** Tests if the list is empty. */\nFIO_FUNC inline int fio_ls_is_empty(fio_ls_s *list);\n\n/** Tests if the list is NOT empty (contains any nodes). */\nFIO_FUNC inline int fio_ls_any(fio_ls_s *list);\n\n/**\n * Iterates through the list using a `for` loop.\n *\n * Access the data with `pos->obj` (`pos` can be named however you please).\n */\n#define FIO_LS_FOR(list, pos)\n\n/* *****************************************************************************\n\n\n                             Linked List Helpers\n\n                               IMPLEMENTATION\n\n\n***************************************************************************** */\n\n/* *****************************************************************************\nEmbeded Linked List Implementation\n***************************************************************************** */\n\n/** Removes a node from the containing node. */\nFIO_FUNC inline fio_ls_embd_s *fio_ls_embd_remove(fio_ls_embd_s *node) {\n  if (!node->next || node->next == node) {\n    /* never remove the list's head */\n    return NULL;\n  }\n  node->next->prev = node->prev;\n  node->prev->next = node->next;\n  node->prev = node->next = node;\n  return node;\n}\n\n/** Adds a node to the list's head. */\nFIO_FUNC inline void fio_ls_embd_push(fio_ls_embd_s *dest,\n                                      fio_ls_embd_s *node) {\n  if (!dest || !node)\n    return;\n  node->prev = dest->prev;\n  node->next = dest;\n  dest->prev->next = node;\n  dest->prev = node;\n}\n\n/** Adds a node to the list's tail. */\nFIO_FUNC inline void fio_ls_embd_unshift(fio_ls_embd_s *dest,\n                                         fio_ls_embd_s *node) {\n  fio_ls_embd_push(dest->next, node);\n}\n\n/** Removes a node from the list's head. */\nFIO_FUNC inline fio_ls_embd_s *fio_ls_embd_pop(fio_ls_embd_s *list) {\n  return fio_ls_embd_remove(list->prev);\n}\n\n/** Removes a node from the list's tail. */\nFIO_FUNC inline fio_ls_embd_s *fio_ls_embd_shift(fio_ls_embd_s *list) {\n  return fio_ls_embd_remove(list->next);\n}\n\n/** Tests if the list is empty. */\nFIO_FUNC inline int fio_ls_embd_is_empty(fio_ls_embd_s *list) {\n  return list->next == list;\n}\n\n/** Tests if the list is NOT empty (contains any nodes). */\nFIO_FUNC inline int fio_ls_embd_any(fio_ls_embd_s *list) {\n  return list->next != list;\n}\n\n#undef FIO_LS_EMBD_FOR\n#define FIO_LS_EMBD_FOR(list, node)                                            \\\n  for (fio_ls_embd_s *node = (list)->next; node != (list); node = node->next)\n\n/* *****************************************************************************\nIndependent Linked List Implementation\n***************************************************************************** */\n\n/** Removes an object from the containing node. */\nFIO_FUNC inline void *fio_ls_remove(fio_ls_s *node) {\n  if (!node || node->next == node) {\n    /* never remove the list's head */\n    return NULL;\n  }\n  const void *ret = node->obj;\n  node->next->prev = node->prev;\n  node->prev->next = node->next;\n  FIO_FREE(node);\n  return (void *)ret;\n}\n\n/** Adds an object to the list's head. */\nFIO_FUNC inline fio_ls_s *fio_ls_push(fio_ls_s *pos, const void *obj) {\n  if (!pos)\n    return NULL;\n  /* prepare item */\n  fio_ls_s *item = (fio_ls_s *)FIO_MALLOC(sizeof(*item));\n  FIO_ASSERT_ALLOC(item);\n  *item = (fio_ls_s){.prev = pos->prev, .next = pos, .obj = obj};\n  /* inject item */\n  pos->prev->next = item;\n  pos->prev = item;\n  return item;\n}\n\n/** Adds an object to the list's tail. */\nFIO_FUNC inline fio_ls_s *fio_ls_unshift(fio_ls_s *pos, const void *obj) {\n  return fio_ls_push(pos->next, obj);\n}\n\n/** Removes an object from the list's head. */\nFIO_FUNC inline void *fio_ls_pop(fio_ls_s *list) {\n  return fio_ls_remove(list->prev);\n}\n\n/** Removes an object from the list's tail. */\nFIO_FUNC inline void *fio_ls_shift(fio_ls_s *list) {\n  return fio_ls_remove(list->next);\n}\n\n/** Tests if the list is empty. */\nFIO_FUNC inline int fio_ls_is_empty(fio_ls_s *list) {\n  return list->next == list;\n}\n\n/** Tests if the list is NOT empty (contains any nodes). */\nFIO_FUNC inline int fio_ls_any(fio_ls_s *list) { return list->next != list; }\n\n#undef FIO_LS_FOR\n#define FIO_LS_FOR(list, pos)                                                  \\\n  for (fio_ls_s *pos = (list)->next; pos != (list); pos = pos->next)\n\n#endif /* FIO_INCLUDE_LINKED_LIST */\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n                             String Helpers\n\n          exposes internally used inline helpers for binary Strings\n\n\n\n\n\n\n\n***************************************************************************** */\n\n#if !defined(H_FIO_STR_H) && defined(FIO_INCLUDE_STR)\n\n#define H_FIO_STR_H\n#undef FIO_INCLUDE_STR\n\n/* *****************************************************************************\nString API - Initialization and Destruction\n***************************************************************************** */\n\n/**\n * The `fio_str_s` type should be considered opaque.\n *\n * The type's attributes should be accessed ONLY through the accessor functions:\n * `fio_str_info`, `fio_str_len`, `fio_str_data`, `fio_str_capa`, etc'.\n *\n * Note: when the `small` flag is present, the structure is ignored and used as\n * raw memory for a small String (no additional allocation). This changes the\n * String's behavior drastically and requires that the accessor functions be\n * used.\n */\ntypedef struct {\n#ifndef FIO_STR_NO_REF\n  volatile uint32_t ref; /* reference counter for fio_str_dup */\n#endif\n  uint8_t small;  /* Flag indicating the String is small and self-contained */\n  uint8_t frozen; /* Flag indicating the String is frozen (don't edit) */\n#ifdef FIO_STR_NO_REF\n  uint8_t reserved[14]; /* Align struct on 16 byte allocator boundary */\n#else\n  uint8_t reserved[10]; /* Align struct on 16 byte allocator boundary */\n#endif\n  uint64_t capa;           /* Known capacity for longer Strings */\n  uint64_t len;            /* String length for longer Strings */\n  void (*dealloc)(void *); /* Data deallocation function (NULL for static) */\n  char *data;              /* Data for longer Strings */\n#if UINTPTR_MAX != UINT64_MAX\n  uint8_t padding[2 * (sizeof(uint64_t) -\n                       sizeof(void *))]; /* 16 byte  boundary for 32bit OS */\n#endif\n} fio_str_s;\n\n/**\n * This value should be used for initialization. For example:\n *\n *      // on the stack\n *      fio_str_s str = FIO_STR_INIT;\n *\n *      // or on the heap\n *      fio_str_s *str = malloc(sizeof(*str);\n *      *str = FIO_STR_INIT;\n *\n * Remember to cleanup:\n *\n *      // on the stack\n *      fio_str_free(&str);\n *\n *      // or on the heap\n *      fio_str_free(str);\n *      free(str);\n */\n#define FIO_STR_INIT ((fio_str_s){.data = NULL, .small = 1})\n\n/**\n * This macro allows the container to be initialized with existing data, as long\n * as it's memory was allocated using `fio_malloc`.\n *\n * The `capacity` value should exclude the NUL character (if exists).\n */\n#define FIO_STR_INIT_EXISTING(buffer, length, capacity)                        \\\n  ((fio_str_s){.data = (buffer),                                               \\\n               .len = (length),                                                \\\n               .capa = (capacity),                                             \\\n               .dealloc = FIO_FREE})\n\n/**\n * This macro allows the container to be initialized with existing static data,\n * that shouldn't be freed.\n */\n#define FIO_STR_INIT_STATIC(buffer)                                            \\\n  ((fio_str_s){                                                                \\\n      .data = (char *)(buffer), .len = strlen((buffer)), .dealloc = NULL})\n\n/**\n * This macro allows the container to be initialized with existing static data,\n * that shouldn't be freed.\n */\n#define FIO_STR_INIT_STATIC2(buffer, length)                                   \\\n  ((fio_str_s){.data = (char *)(buffer), .len = (length), .dealloc = NULL})\n\n/**\n * Allocates a new fio_str_s object on the heap and initializes it.\n *\n * Use `fio_str_free2` to free both the String data and the container.\n *\n * NOTE: This makes the allocation and reference counting logic more intuitive.\n */\ninline FIO_FUNC fio_str_s *fio_str_new2(void);\n\n/**\n * Allocates a new fio_str_s object on the heap, initializes it and copies the\n * original (`src`) string into the new string.\n *\n * Use `fio_str_free2` to free the new string's data and it's container.\n */\ninline FIO_FUNC fio_str_s *fio_str_new_copy2(fio_str_s *src);\n\n/**\n * Adds a references to the current String object and returns itself.\n *\n * If refecrence counting was disabled (FIO_STR_NO_REF was defined), returns a\n * copy of the String (free with `fio_str_free2`).\n *\n * NOTE: Nothing is copied, reference Strings are referencing the same String.\n *       Editing one reference will effect the other.\n *\n *       The original's String's container should remain in scope (if on the\n *       stack) or remain allocated (if on the heap) until all the references\n *       were freed using `fio_str_free` / `fio_str_free2` or discarded.\n */\ninline FIO_FUNC fio_str_s *fio_str_dup(fio_str_s *s);\n\n/**\n * Frees the String's resources and reinitializes the container.\n *\n * Note: if the container isn't allocated on the stack, it should be freed\n * separately using `free(s)`.\n *\n * Returns 0 if the data was freed and -1 if the String is NULL or has un-freed\n * references (see fio_str_dup).\n */\ninline FIO_FUNC int fio_str_free(fio_str_s *s);\n\n/**\n * Frees the String's resources AS WELL AS the container.\n *\n * Note: the container is freed using `fio_free`, make sure `fio_malloc` was\n * used to allocate it.\n */\nFIO_FUNC void fio_str_free2(fio_str_s *s);\n\n/**\n * `fio_str_send_free2` sends the fio_str_s using `fio_write2`, freeing both the\n * String and the container once the data was sent\n *\n * As the naming indicates, the String is assumed to have been allocated using\n * `fio_str_new2` or `fio_malloc`.\n */\ninline FIO_FUNC ssize_t fio_str_send_free2(const intptr_t uuid,\n                                           const fio_str_s *str);\n\n/**\n * Returns a C string with the existing data, clearing the `fio_str_s` object's\n * String.\n *\n * Note: the String data is removed from the container, but the container isn't\n * freed.\n *\n * Returns NULL if there's no String data.\n *\n * Remember to `fio_free` the returned data and - if required - `fio_str_free2`\n * the container.\n */\nFIO_FUNC char *fio_str_detach(fio_str_s *s);\n\n/* *****************************************************************************\nString API - String state (data pointers, length, capacity, etc')\n***************************************************************************** */\n\n/*\n * String state information, defined above as:\ntypedef struct {\n  size_t capa;\n  size_t len;\n  char *data;\n} fio_str_info_s;\n*/\n\n/** Returns the String's complete state (capacity, length and pointer).  */\ninline FIO_FUNC fio_str_info_s fio_str_info(const fio_str_s *s);\n\n/** Returns the String's length in bytes. */\ninline FIO_FUNC size_t fio_str_len(fio_str_s *s);\n\n/** Returns a pointer (`char *`) to the String's content. */\ninline FIO_FUNC char *fio_str_data(fio_str_s *s);\n\n/** Returns a byte pointer (`uint8_t *`) to the String's unsigned content. */\n#define fio_str_bytes(s) ((uint8_t *)fio_str_data((s)))\n\n/** Returns the String's existing capacity (total used & available memory). */\ninline FIO_FUNC size_t fio_str_capa(fio_str_s *s);\n\n/**\n * Sets the new String size without reallocating any memory (limited by\n * existing capacity).\n *\n * Returns the updated state of the String.\n *\n * Note: When shrinking, any existing data beyond the new size may be corrupted.\n */\ninline FIO_FUNC fio_str_info_s fio_str_resize(fio_str_s *s, size_t size);\n\n/**\n * Clears the string (retaining the existing capacity).\n */\n#define fio_str_clear(s) fio_str_resize((s), 0)\n\n/**\n * Returns the string's Risky Hash value.\n *\n * Note: Hash algorithm might change without notice.\n */\nFIO_FUNC uint64_t fio_str_hash(const fio_str_s *s);\n\n/* *****************************************************************************\nString API - Memory management\n***************************************************************************** */\n\n/**\n * Performs a best attempt at minimizing memory consumption.\n *\n * Actual effects depend on the underlying memory allocator and it's\n * implementation. Not all allocators will free any memory.\n */\nFIO_FUNC void fio_str_compact(fio_str_s *s);\n\n/**\n * Requires the String to have at least `needed` capacity. Returns the current\n * state of the String.\n */\nFIO_FUNC fio_str_info_s fio_str_capa_assert(fio_str_s *s, size_t needed);\n\n/* *****************************************************************************\nString API - UTF-8 State\n***************************************************************************** */\n\n/** Returns 1 if the String is UTF-8 valid and 0 if not. */\nFIO_FUNC size_t fio_str_utf8_valid(fio_str_s *s);\n\n/** Returns the String's length in UTF-8 characters. */\nFIO_FUNC size_t fio_str_utf8_len(fio_str_s *s);\n\n/**\n * Takes a UTF-8 character selection information (UTF-8 position and length) and\n * updates the same variables so they reference the raw byte slice information.\n *\n * If the String isn't UTF-8 valid up to the requested selection, than `pos`\n * will be updated to `-1` otherwise values are always positive.\n *\n * The returned `len` value may be shorter than the original if there wasn't\n * enough data left to accomodate the requested length. When a `len` value of\n * `0` is returned, this means that `pos` marks the end of the String.\n *\n * Returns -1 on error and 0 on success.\n */\nFIO_FUNC int fio_str_utf8_select(fio_str_s *s, intptr_t *pos, size_t *len);\n\n/**\n * Advances the `ptr` by one utf-8 character, placing the value of the UTF-8\n * character into the i32 variable (which must be a signed integer with 32bits\n * or more). On error, `i32` will be equal to `-1` and `ptr` will not step\n * forwards.\n *\n * The `end` value is only used for overflow protection.\n *\n * This helper macro is used internally but left exposed for external use.\n */\n#define FIO_STR_UTF8_CODE_POINT(ptr, end, i32)\n\n/* *****************************************************************************\nString API - Content Manipulation and Review\n***************************************************************************** */\n\n/**\n * Writes data at the end of the String (similar to `fio_str_insert` with the\n * argument `pos == -1`).\n */\ninline FIO_FUNC fio_str_info_s fio_str_write(fio_str_s *s, const void *src,\n                                             size_t src_len);\n\n/**\n * Writes a number at the end of the String using normal base 10 notation.\n */\ninline FIO_FUNC fio_str_info_s fio_str_write_i(fio_str_s *s, int64_t num);\n\n/**\n * Appens the `src` String to the end of the `dest` String.\n *\n * If `dest` is empty, the resulting Strings will be equal.\n */\ninline FIO_FUNC fio_str_info_s fio_str_concat(fio_str_s *dest,\n                                              fio_str_s const *src);\n\n/** Alias for fio_str_concat */\n#define fio_str_join(dest, src) fio_str_concat((dest), (src))\n\n/**\n * Replaces the data in the String - replacing `old_len` bytes starting at\n * `start_pos`, with the data at `src` (`src_len` bytes long).\n *\n * Negative `start_pos` values are calculated backwards, `-1` == end of String.\n *\n * When `old_len` is zero, the function will insert the data at `start_pos`.\n *\n * If `src_len == 0` than `src` will be ignored and the data marked for\n * replacement will be erased.\n */\nFIO_FUNC fio_str_info_s fio_str_replace(fio_str_s *s, intptr_t start_pos,\n                                        size_t old_len, const void *src,\n                                        size_t src_len);\n\n/**\n * Writes to the String using a vprintf like interface.\n *\n * Data is written to the end of the String.\n */\nFIO_FUNC fio_str_info_s fio_str_vprintf(fio_str_s *s, const char *format,\n                                        va_list argv);\n\n/**\n * Writes to the String using a printf like interface.\n *\n * Data is written to the end of the String.\n */\nFIO_FUNC fio_str_info_s fio_str_printf(fio_str_s *s, const char *format, ...);\n\n/**\n * Opens the file `filename` and pastes it's contents (or a slice ot it) at the\n * end of the String. If `limit == 0`, than the data will be read until EOF.\n *\n * If the file can't be located, opened or read, or if `start_at` is beyond\n * the EOF position, NULL is returned in the state's `data` field.\n *\n * Works on POSIX only.\n */\nFIO_FUNC fio_str_info_s fio_str_readfile(fio_str_s *s, const char *filename,\n                                         intptr_t start_at, intptr_t limit);\n\n/**\n * Prevents further manipulations to the String's content.\n */\ninline FIO_FUNC void fio_str_freeze(fio_str_s *s);\n\n/**\n * Binary comparison returns `1` if both strings are equal and `0` if not.\n */\ninline FIO_FUNC int fio_str_iseq(const fio_str_s *str1, const fio_str_s *str2);\n\n/* *****************************************************************************\n\n\n                             String Implementation\n\n                               IMPLEMENTATION\n\n\n***************************************************************************** */\n\n/* *****************************************************************************\nString Implementation - state (data pointers, length, capacity, etc')\n***************************************************************************** */\n\ntypedef struct {\n#ifndef FIO_STR_NO_REF\n  volatile uint32_t ref; /* reference counter for fio_str_dup */\n#endif\n  uint8_t small;  /* Flag indicating the String is small and self-contained */\n  uint8_t frozen; /* Flag indicating the String is frozen (don't edit) */\n} fio_str__small_s;\n\n#define FIO_STR_SMALL_DATA(s) ((char *)((&(s)->frozen) + 1))\n\n/* the capacity when the string is stored in the container itself */\n#define FIO_STR_SMALL_CAPA                                                     \\\n  (sizeof(fio_str_s) - (size_t)((&((fio_str_s *)0)->frozen) + 1))\n\n/** Returns the String's state (capacity, length and pointer). */\ninline FIO_FUNC fio_str_info_s fio_str_info(const fio_str_s *s) {\n  if (!s)\n    return (fio_str_info_s){.len = 0};\n  return (s->small || !s->data)\n             ? (fio_str_info_s){.capa =\n                                    (s->frozen ? 0 : (FIO_STR_SMALL_CAPA - 1)),\n                                .len = (size_t)(s->small >> 1),\n                                .data = FIO_STR_SMALL_DATA(s)}\n             : (fio_str_info_s){.capa = (s->frozen ? 0 : s->capa),\n                                .len = s->len,\n                                .data = s->data};\n}\n\n/**\n * Allocates a new fio_str_s object on the heap and initializes it.\n *\n * Use `fio_str_free2` to free both the String data and the container.\n *\n * NOTE: This makes the allocation and reference counting logic more intuitive.\n */\ninline FIO_FUNC fio_str_s *fio_str_new2(void) {\n  fio_str_s *str = FIO_MALLOC(sizeof(*str));\n  FIO_ASSERT_ALLOC(str);\n  *str = FIO_STR_INIT;\n  return str;\n}\n\n/**\n * Allocates a new fio_str_s object on the heap, initializes it and copies the\n * original (`src`) string into the new string.\n *\n * Use `fio_str_free2` to free the new string's data and it's container.\n */\ninline FIO_FUNC fio_str_s *fio_str_new_copy2(fio_str_s *src) {\n  fio_str_s *cpy = fio_str_new2();\n  fio_str_concat(cpy, src);\n  return cpy;\n}\n\n/**\n * Adds a references to the current String object and returns itself.\n *\n * If refecrence counting was disabled (FIO_STR_NO_REF was defined), returns a\n * copy of the String (free with `fio_str_free2`).\n *\n * NOTE: Nothing is copied, reference Strings are referencing the same String.\n *       Editing one reference will effect the other.\n *\n *       The original's String's container should remain in scope (if on the\n *       stack) or remain allocated (if on the heap) until all the references\n *       were freed using `fio_str_free` / `fio_str_free2` or discarded.\n */\ninline FIO_FUNC fio_str_s *fio_str_dup(fio_str_s *s) {\n#ifdef FIO_STR_NO_REF\n  fio_str_s *s2 = fio_str_new2();\n  fio_str_concat(s2, s);\n  return s2;\n#else\n  if (s)\n    fio_atomic_add(&s->ref, 1);\n  return s;\n#endif\n}\n\n/**\n * Frees the String's resources and reinitializes the container.\n *\n * Note: if the container isn't allocated on the stack, it should be freed\n * separately using `free(s)`.\n *\n * Returns 0 if the data was freed and -1 if the String is NULL or has un-freed\n * references (see fio_str_dup).\n */\ninline FIO_FUNC int fio_str_free(fio_str_s *s) {\n#ifndef FIO_STR_NO_REF\n  if (!s || fio_atomic_sub(&s->ref, 1) != (uint32_t)-1)\n    return -1;\n#endif\n  if (!s->small && s->dealloc)\n    s->dealloc(s->data);\n  *s = FIO_STR_INIT;\n  return 0;\n}\n\n/**\n * Frees the String's resources as well as the container.\n *\n * Note: the container is freed using `free`, make sure `malloc` was used to\n * allocate it.\n */\nFIO_FUNC void fio_str_free2(fio_str_s *s) {\n  if (fio_str_free(s)) {\n    return;\n  }\n  FIO_FREE(s);\n}\n\n/**\n * Returns a C string with the existing data, clearing the `fio_str_s` object's\n * String.\n *\n * Note: the String data is removed from the container, but the container isn't\n * freed.\n *\n * Returns NULL if there's no String data.\n *\n * Remember to `fio_free` the returned data and - if required - `fio_str_free2`\n * the container.\n */\nFIO_FUNC char *fio_str_detach(fio_str_s *s) {\n  if (!s)\n    return NULL;\n  fio_str_info_s i = fio_str_info(s);\n  if (s->small || !s->data) {\n    if (!i.len) {\n      i.data = NULL;\n      goto finish;\n    }\n    /* make a copy */\n    void *tmp = FIO_MALLOC(i.len + 1);\n    memcpy(tmp, i.data, i.len + 1);\n    i.data = tmp;\n  } else {\n    if (!i.len && s->data) {\n      if (s->dealloc)\n        s->dealloc(s->data);\n      i.data = NULL;\n    } else if (s->dealloc != FIO_FREE) {\n      /* make a copy */\n      void *tmp = FIO_MALLOC(i.len + 1);\n      memcpy(tmp, i.data, i.len + 1);\n      i.data = tmp;\n      if (s->dealloc)\n        s->dealloc(s->data);\n    }\n  }\nfinish:\n#ifdef FIO_STR_NO_REF\n  *s = (fio_str_s){.small = 1};\n\n#else\n  *s = (fio_str_s){\n      .small = s->small,\n      .ref = s->ref,\n  };\n#endif\n  return i.data;\n}\n\n/** Returns the String's length in bytes. */\ninline FIO_FUNC size_t fio_str_len(fio_str_s *s) {\n  return (s->small || !s->data) ? (s->small >> 1) : s->len;\n}\n\n/** Returns a pointer (`char *`) to the String's content. */\ninline FIO_FUNC char *fio_str_data(fio_str_s *s) {\n  return (s->small || !s->data) ? FIO_STR_SMALL_DATA(s) : s->data;\n}\n\n/** Returns the String's existing capacity (allocated memory). */\ninline FIO_FUNC size_t fio_str_capa(fio_str_s *s) {\n  if (s->frozen)\n    return 0;\n  return (s->small || !s->data) ? (FIO_STR_SMALL_CAPA - 1) : s->capa;\n}\n\n/**\n * Sets the new String size without reallocating any memory (limited by\n * existing capacity).\n *\n * Returns the updated state of the String.\n *\n * Note: When shrinking, any existing data beyond the new size may be corrupted.\n *\n * Note: When providing a new size that is grater then the current string\n * capacity, any data that was written beyond the current (previous) size might\n * be replaced with NUL bytes.\n */\ninline FIO_FUNC fio_str_info_s fio_str_resize(fio_str_s *s, size_t size) {\n  if (!s || s->frozen) {\n    return fio_str_info(s);\n  }\n  if (s->small || !s->data) {\n    if (size < FIO_STR_SMALL_CAPA) {\n      s->small = (uint8_t)(((size << 1) | 1) & 0xFF);\n      FIO_STR_SMALL_DATA(s)[size] = 0;\n      return (fio_str_info_s){.capa = (FIO_STR_SMALL_CAPA - 1),\n                              .len = size,\n                              .data = FIO_STR_SMALL_DATA(s)};\n    }\n    s->small = (uint8_t)((((FIO_STR_SMALL_CAPA - 1) << 1) | 1) & 0xFF);\n    fio_str_capa_assert(s, size);\n    goto big;\n  }\n  if (size >= s->capa) {\n    s->len = fio_ct_if2((uintptr_t)s->dealloc, s->capa, s->len);\n    fio_str_capa_assert(s, size);\n  }\n\nbig:\n  s->len = size;\n  s->data[size] = 0;\n  return (fio_str_info_s){.capa = s->capa, .len = size, .data = s->data};\n}\n\n/* *****************************************************************************\nString Implementation - Hashing\n***************************************************************************** */\n\n/**\n * Return's the String's Risky Hash (see fio_risky_hash).\n *\n * This value is machine/instance specific (hash seed is a memory address).\n *\n * NOTE: the hashing function might be changed at any time without notice. It\n * wasn't cryptographically analyzed and safety against malicious data can't be\n * guaranteed. Use fio_siphash13 or fio_siphash24 when hashing data from\n * external sources.\n */\nFIO_FUNC uint64_t fio_str_hash(const fio_str_s *s) {\n  fio_str_info_s state = fio_str_info(s);\n  return fio_risky_hash(state.data, state.len, FIO_HASH_SECRET_SEED64_1);\n}\n\n/* *****************************************************************************\nString Implementation - Memory management\n***************************************************************************** */\n\n/**\n * Rounds up allocated capacity to the closest 2 words byte boundary (leaving 1\n * byte space for the NUL byte).\n *\n * This shouldn't effect actual allocation size and should only minimize the\n * effects of the memory allocator's alignment rounding scheme.\n *\n * To clarify:\n *\n * Memory allocators are required to allocate memory on the minimal alignment\n * required by the largest type (`long double`), which usually results in memory\n * allocations using this alignment as a minimal spacing.\n *\n * For example, on 64 bit architectures, it's likely that `malloc(18)` will\n * allocate the same amount of memory as `malloc(32)` due to alignment concerns.\n *\n * In fact, with some allocators (i.e., jemalloc), spacing increases for larger\n * allocations - meaning the allocator will round up to more than 16 bytes, as\n * noted here: http://jemalloc.net/jemalloc.3.html#size_classes\n *\n * Note that this increased spacing, doesn't occure with facil.io's allocator,\n * since it uses 16 byte alignment right up until allocations are routed\n * directly to `mmap` (due to their size, usually over 12KB).\n */\n#define ROUND_UP_CAPA2WORDS(num) (((num) + 1) | (sizeof(long double) - 1))\n\n/**\n * Requires the String to have at least `needed` capacity. Returns the current\n * state of the String.\n */\nFIO_FUNC fio_str_info_s fio_str_capa_assert(fio_str_s *s, size_t needed) {\n  if (!s || s->frozen) {\n    return fio_str_info(s);\n  }\n  char *tmp;\n  if (s->small || !s->data) {\n    if (needed < FIO_STR_SMALL_CAPA) {\n      return (fio_str_info_s){.capa = (FIO_STR_SMALL_CAPA - 1),\n                              .len = (size_t)(s->small >> 1),\n                              .data = FIO_STR_SMALL_DATA(s)};\n    }\n    goto is_small;\n  }\n  if (needed < s->capa) {\n    return (fio_str_info_s){.capa = s->capa, .len = s->len, .data = s->data};\n  }\n  needed = ROUND_UP_CAPA2WORDS(needed);\n  if (s->dealloc == FIO_FREE) {\n    tmp = (char *)FIO_REALLOC(s->data, needed + 1, s->len + 1);\n    FIO_ASSERT_ALLOC(tmp);\n  } else {\n    tmp = (char *)FIO_MALLOC(needed + 1);\n    FIO_ASSERT_ALLOC(tmp);\n    memcpy(tmp, s->data, s->len + 1);\n    if (s->dealloc)\n      s->dealloc(s->data);\n    s->dealloc = FIO_FREE;\n  }\n  s->capa = needed;\n  s->data = tmp;\n  s->data[needed] = 0;\n  return (fio_str_info_s){.capa = s->capa, .len = s->len, .data = s->data};\n\nis_small:\n  /* small string (string data is within the container) */\n  needed = ROUND_UP_CAPA2WORDS(needed);\n  tmp = (char *)FIO_MALLOC(needed + 1);\n  FIO_ASSERT_ALLOC(tmp);\n  const size_t existing_len = (size_t)((s->small >> 1) & 0xFF);\n  if (existing_len) {\n    memcpy(tmp, FIO_STR_SMALL_DATA(s), existing_len + 1);\n  } else {\n    tmp[0] = 0;\n  }\n#ifdef FIO_STR_NO_REF\n  *s = (fio_str_s){\n      .small = 0,\n      .capa = needed,\n      .len = existing_len,\n      .dealloc = FIO_FREE,\n      .data = tmp,\n  };\n#else\n  *s = (fio_str_s){\n      .ref = s->ref,\n      .small = 0,\n      .capa = needed,\n      .len = existing_len,\n      .dealloc = FIO_FREE,\n      .data = tmp,\n  };\n#endif\n  return (fio_str_info_s){.capa = needed, .len = existing_len, .data = s->data};\n}\n\n/** Performs a best attempt at minimizing memory consumption. */\nFIO_FUNC void fio_str_compact(fio_str_s *s) {\n  if (!s || (s->small || !s->data))\n    return;\n  char *tmp;\n  if (s->len < FIO_STR_SMALL_CAPA)\n    goto shrink2small;\n  tmp = fio_realloc(s->data, s->len + 1);\n  FIO_ASSERT_ALLOC(tmp);\n  s->data = tmp;\n  s->capa = s->len;\n  return;\n\nshrink2small:\n  /* move the string into the container */\n  tmp = s->data;\n  size_t len = s->len;\n  *s = (fio_str_s){.small = (uint8_t)(((len << 1) | 1) & 0xFF),\n                   .frozen = s->frozen};\n  if (len) {\n    memcpy(FIO_STR_SMALL_DATA(s), tmp, len + 1);\n  }\n  FIO_FREE(tmp);\n}\n\n/* *****************************************************************************\nString Implementation - UTF-8 State\n***************************************************************************** */\n\n/**\n * Maps the first 5 bits in a byte (0b11111xxx) to a UTF-8 codepoint length.\n *\n * Codepoint length 0 == error.\n *\n * The first valid length can be any value between 1 to 4.\n *\n * A continuation byte (second, third or forth) valid length must be 5.\n *\n * To map was populated using the following Ruby script:\n *\n *      map = []; 32.times { map << 0 }; (0..0b1111).each {|i| map[i] = 1} ;\n *      (0b10000..0b10111).each {|i| map[i] = 5} ;\n *      (0b11000..0b11011).each {|i| map[i] = 2} ;\n *      (0b11100..0b11101).each {|i| map[i] = 3} ;\n *      map[0b11110] = 4; map;\n */\nstatic uint8_t fio_str_utf8_map[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n                                     1, 1, 1, 1, 1, 5, 5, 5, 5, 5, 5,\n                                     5, 5, 2, 2, 2, 2, 3, 3, 4, 0};\n\n#undef FIO_STR_UTF8_CODE_POINT\n/**\n * Advances the `ptr` by one utf-8 character, placing the value of the UTF-8\n * character into the i32 variable (which must be a signed integer with 32bits\n * or more). On error, `i32` will be equal to `-1` and `ptr` will not step\n * forwards.\n *\n * The `end` value is only used for overflow protection.\n */\n#define FIO_STR_UTF8_CODE_POINT(ptr, end, i32)                                 \\\n  do {                                                                         \\\n    switch (fio_str_utf8_map[((uint8_t *)(ptr))[0] >> 3]) {                    \\\n    case 1:                                                                    \\\n      (i32) = ((uint8_t *)(ptr))[0];                                           \\\n      ++(ptr);                                                                 \\\n      break;                                                                   \\\n    case 2:                                                                    \\\n      if (((ptr) + 2 > (end)) ||                                               \\\n          fio_str_utf8_map[((uint8_t *)(ptr))[1] >> 3] != 5) {                 \\\n        (i32) = -1;                                                            \\\n        break;                                                                 \\\n      }                                                                        \\\n      (i32) =                                                                  \\\n          ((((uint8_t *)(ptr))[0] & 31) << 6) | (((uint8_t *)(ptr))[1] & 63);  \\\n      (ptr) += 2;                                                              \\\n      break;                                                                   \\\n    case 3:                                                                    \\\n      if (((ptr) + 3 > (end)) ||                                               \\\n          fio_str_utf8_map[((uint8_t *)(ptr))[1] >> 3] != 5 ||                 \\\n          fio_str_utf8_map[((uint8_t *)(ptr))[2] >> 3] != 5) {                 \\\n        (i32) = -1;                                                            \\\n        break;                                                                 \\\n      }                                                                        \\\n      (i32) = ((((uint8_t *)(ptr))[0] & 15) << 12) |                           \\\n              ((((uint8_t *)(ptr))[1] & 63) << 6) |                            \\\n              (((uint8_t *)(ptr))[2] & 63);                                    \\\n      (ptr) += 3;                                                              \\\n      break;                                                                   \\\n    case 4:                                                                    \\\n      if (((ptr) + 4 > (end)) ||                                               \\\n          fio_str_utf8_map[((uint8_t *)(ptr))[1] >> 3] != 5 ||                 \\\n          fio_str_utf8_map[((uint8_t *)(ptr))[2] >> 3] != 5 ||                 \\\n          fio_str_utf8_map[((uint8_t *)(ptr))[3] >> 3] != 5) {                 \\\n        (i32) = -1;                                                            \\\n        break;                                                                 \\\n      }                                                                        \\\n      (i32) = ((((uint8_t *)(ptr))[0] & 7) << 18) |                            \\\n              ((((uint8_t *)(ptr))[1] & 63) << 12) |                           \\\n              ((((uint8_t *)(ptr))[2] & 63) << 6) |                            \\\n              (((uint8_t *)(ptr))[3] & 63);                                    \\\n      (ptr) += 4;                                                              \\\n      break;                                                                   \\\n    default:                                                                   \\\n      (i32) = -1;                                                              \\\n      break;                                                                   \\\n    }                                                                          \\\n  } while (0);\n\n/** Returns 1 if the String is UTF-8 valid and 0 if not. */\nFIO_FUNC size_t fio_str_utf8_valid(fio_str_s *s) {\n  if (!s)\n    return 0;\n  fio_str_info_s state = fio_str_info(s);\n  if (!state.len)\n    return 1;\n  char *const end = state.data + state.len;\n  int32_t c = 0;\n  do {\n    FIO_STR_UTF8_CODE_POINT(state.data, end, c);\n  } while (c > 0 && state.data < end);\n  return state.data == end && c >= 0;\n}\n\n/** Returns the String's length in UTF-8 characters. */\nFIO_FUNC size_t fio_str_utf8_len(fio_str_s *s) {\n  fio_str_info_s state = fio_str_info(s);\n  if (!state.len)\n    return 0;\n  char *end = state.data + state.len;\n  size_t utf8len = 0;\n  int32_t c = 0;\n  do {\n    ++utf8len;\n    FIO_STR_UTF8_CODE_POINT(state.data, end, c);\n  } while (c > 0 && state.data < end);\n  if (state.data != end || c == -1) {\n    /* invalid */\n    return 0;\n  }\n  return utf8len;\n}\n\n/**\n * Takes a UTF-8 character selection information (UTF-8 position and length) and\n * updates the same variables so they reference the raw byte slice information.\n *\n * If the String isn't UTF-8 valid up to the requested selection, than `pos`\n * will be updated to `-1` otherwise values are always positive.\n *\n * The returned `len` value may be shorter than the original if there wasn't\n * enough data left to accomodate the requested length. When a `len` value of\n * `0` is returned, this means that `pos` marks the end of the String.\n *\n * Returns -1 on error and 0 on success.\n */\nFIO_FUNC int fio_str_utf8_select(fio_str_s *s, intptr_t *pos, size_t *len) {\n  fio_str_info_s state = fio_str_info(s);\n  if (!state.data)\n    goto error;\n  if (!state.len || *pos == -1)\n    goto at_end;\n\n  int32_t c = 0;\n  char *p = state.data;\n  char *const end = state.data + state.len;\n  size_t start;\n\n  if (*pos) {\n    if ((*pos) > 0) {\n      start = *pos;\n      while (start && p < end && c >= 0) {\n        FIO_STR_UTF8_CODE_POINT(p, end, c);\n        --start;\n      }\n      if (c == -1)\n        goto error;\n      if (start || p >= end)\n        goto at_end;\n      *pos = p - state.data;\n    } else {\n      /* walk backwards */\n      p = state.data + state.len - 1;\n      c = 0;\n      ++*pos;\n      do {\n        switch (fio_str_utf8_map[((uint8_t *)p)[0] >> 3]) {\n        case 5:\n          ++c;\n          break;\n        case 4:\n          if (c != 3)\n            goto error;\n          c = 0;\n          ++(*pos);\n          break;\n        case 3:\n          if (c != 2)\n            goto error;\n          c = 0;\n          ++(*pos);\n          break;\n        case 2:\n          if (c != 1)\n            goto error;\n          c = 0;\n          ++(*pos);\n          break;\n        case 1:\n          if (c)\n            goto error;\n          ++(*pos);\n          break;\n        default:\n          goto error;\n        }\n        --p;\n      } while (p > state.data && *pos);\n      if (c)\n        goto error;\n      ++p; /* There's always an extra back-step */\n      *pos = (p - state.data);\n    }\n  }\n\n  /* find end */\n  start = *len;\n  while (start && p < end && c >= 0) {\n    FIO_STR_UTF8_CODE_POINT(p, end, c);\n    --start;\n  }\n  if (c == -1 || p > end)\n    goto error;\n  *len = p - (state.data + (*pos));\n  return 0;\n\nat_end:\n  *pos = state.len;\n  *len = 0;\n  return 0;\nerror:\n  *pos = -1;\n  *len = 0;\n  return -1;\n}\n\n/* *****************************************************************************\nString Implementation - Content Manipulation and Review\n***************************************************************************** */\n\n/**\n * Writes data at the end of the String (similar to `fio_str_insert` with the\n * argument `pos == -1`).\n */\ninline FIO_FUNC fio_str_info_s fio_str_write(fio_str_s *s, const void *src,\n                                             size_t src_len) {\n  if (!s || !src_len || !src || s->frozen)\n    return fio_str_info(s);\n  fio_str_info_s state = fio_str_resize(s, src_len + fio_str_len(s));\n  memcpy(state.data + (state.len - src_len), src, src_len);\n  return state;\n}\n\n/**\n * Writes a number at the end of the String using normal base 10 notation.\n */\ninline FIO_FUNC fio_str_info_s fio_str_write_i(fio_str_s *s, int64_t num) {\n  if (!s || s->frozen)\n    return fio_str_info(s);\n  fio_str_info_s i;\n  if (!num)\n    goto zero;\n  char buf[22];\n  uint64_t l = 0;\n  uint8_t neg;\n  if ((neg = (num < 0))) {\n    num = 0 - num;\n    neg = 1;\n  }\n  while (num) {\n    uint64_t t = num / 10;\n    buf[l++] = '0' + (num - (t * 10));\n    num = t;\n  }\n  if (neg) {\n    buf[l++] = '-';\n  }\n  i = fio_str_resize(s, fio_str_len(s) + l);\n\n  while (l) {\n    --l;\n    i.data[i.len - (l + 1)] = buf[l];\n  }\n  return i;\nzero:\n  i = fio_str_resize(s, fio_str_len(s) + 1);\n  i.data[i.len - 1] = '0';\n  return i;\n}\n\n/**\n * Appens the `src` String to the end of the `dest` String.\n */\ninline FIO_FUNC fio_str_info_s fio_str_concat(fio_str_s *dest,\n                                              fio_str_s const *src) {\n  if (!dest || !src || dest->frozen)\n    return fio_str_info(dest);\n  fio_str_info_s src_state = fio_str_info(src);\n  if (!src_state.len)\n    return fio_str_info(dest);\n  fio_str_info_s state =\n      fio_str_resize(dest, src_state.len + fio_str_len(dest));\n  memcpy(state.data + state.len - src_state.len, src_state.data, src_state.len);\n  return state;\n}\n\n/**\n * Replaces the data in the String - replacing `old_len` bytes starting at\n * `start_pos`, with the data at `src` (`src_len` bytes long).\n *\n * Negative `start_pos` values are calculated backwards, `-1` == end of String.\n *\n * When `old_len` is zero, the function will insert the data at `start_pos`.\n *\n * If `src_len == 0` than `src` will be ignored and the data marked for\n * replacement will be erased.\n */\nFIO_FUNC fio_str_info_s fio_str_replace(fio_str_s *s, intptr_t start_pos,\n                                        size_t old_len, const void *src,\n                                        size_t src_len) {\n  fio_str_info_s state = fio_str_info(s);\n  if (!s || s->frozen || (!old_len && !src_len))\n    return state;\n\n  if (start_pos < 0) {\n    /* backwards position indexing */\n    start_pos += s->len + 1;\n    if (start_pos < 0)\n      start_pos = 0;\n  }\n\n  if (start_pos + old_len >= state.len) {\n    /* old_len overflows the end of the String */\n    if (s->small || !s->data) {\n      s->small = 1 | ((size_t)((start_pos << 1) & 0xFF));\n    } else {\n      s->len = start_pos;\n    }\n    return fio_str_write(s, src, src_len);\n  }\n\n  /* data replacement is now always in the middle (or start) of the String */\n  const size_t new_size = state.len + (src_len - old_len);\n\n  if (old_len != src_len) {\n    /* there's an offset requiring an adjustment */\n    if (old_len < src_len) {\n      /* make room for new data */\n      const size_t offset = src_len - old_len;\n      state = fio_str_resize(s, state.len + offset);\n    }\n    memmove(state.data + start_pos + src_len, state.data + start_pos + old_len,\n            (state.len - start_pos) - old_len);\n  }\n  if (src_len) {\n    memcpy(state.data + start_pos, src, src_len);\n  }\n\n  return fio_str_resize(s, new_size);\n}\n\n/** Writes to the String using a vprintf like interface. */\nFIO_FUNC __attribute__((format(printf, 2, 0))) fio_str_info_s\nfio_str_vprintf(fio_str_s *s, const char *format, va_list argv) {\n  va_list argv_cpy;\n  va_copy(argv_cpy, argv);\n  int len = vsnprintf(NULL, 0, format, argv_cpy);\n  va_end(argv_cpy);\n  if (len <= 0)\n    return fio_str_info(s);\n  fio_str_info_s state = fio_str_resize(s, len + fio_str_len(s));\n  vsnprintf(state.data + (state.len - len), len + 1, format, argv);\n  return state;\n}\n\n/** Writes to the String using a printf like interface. */\nFIO_FUNC __attribute__((format(printf, 2, 3))) fio_str_info_s\nfio_str_printf(fio_str_s *s, const char *format, ...) {\n  va_list argv;\n  va_start(argv, format);\n  fio_str_info_s state = fio_str_vprintf(s, format, argv);\n  va_end(argv);\n  return state;\n}\n\n/**\n * Opens the file `filename` and pastes it's contents (or a slice ot it) at the\n * end of the String. If `limit == 0`, than the data will be read until EOF.\n *\n * If the file can't be located, opened or read, or if `start_at` is beyond\n * the EOF position, NULL is returned in the state's `data` field.\n */\nFIO_FUNC fio_str_info_s fio_str_readfile(fio_str_s *s, const char *filename,\n                                         intptr_t start_at, intptr_t limit) {\n  fio_str_info_s state = {.data = NULL};\n#if defined(__unix__) || defined(__linux__) || defined(__APPLE__) ||           \\\n    defined(__CYGWIN__)\n  /* POSIX implementations. */\n  if (filename == NULL || !s)\n    return state;\n  struct stat f_data;\n  int file = -1;\n  char *path = NULL;\n  size_t path_len = 0;\n\n  if (filename[0] == '~' && (filename[1] == '/' || filename[1] == '\\\\')) {\n    char *home = getenv(\"HOME\");\n    if (home) {\n      size_t filename_len = strlen(filename);\n      size_t home_len = strlen(home);\n      if ((home_len + filename_len) >= (1 << 16)) {\n        /* too long */\n        return state;\n      }\n      if (home[home_len - 1] == '/' || home[home_len - 1] == '\\\\')\n        --home_len;\n      path_len = home_len + filename_len - 1;\n      path = FIO_MALLOC(path_len + 1);\n      FIO_ASSERT_ALLOC(path);\n      memcpy(path, home, home_len);\n      memcpy(path + home_len, filename + 1, filename_len);\n      path[path_len] = 0;\n      filename = path;\n    }\n  }\n\n  if (stat(filename, &f_data)) {\n    goto finish;\n  }\n\n  if (f_data.st_size <= 0 || start_at >= f_data.st_size) {\n    state = fio_str_info(s);\n    goto finish;\n  }\n\n  file = open(filename, O_RDONLY);\n  if (-1 == file)\n    goto finish;\n\n  if (start_at < 0) {\n    start_at = f_data.st_size + start_at;\n    if (start_at < 0)\n      start_at = 0;\n  }\n\n  if (limit <= 0 || f_data.st_size < (limit + start_at))\n    limit = f_data.st_size - start_at;\n\n  const size_t org_len = fio_str_len(s);\n  state = fio_str_resize(s, org_len + limit);\n  if (pread(file, state.data + org_len, limit, start_at) != (ssize_t)limit) {\n    fio_str_resize(s, org_len);\n    state.data = NULL;\n    state.len = state.capa = 0;\n  }\n  close(file);\nfinish:\n  FIO_FREE(path);\n  return state;\n#else\n  /* TODO: consider adding non POSIX implementations. */\n  FIO_LOG_ERROR(\"File reading requires a posix system (ignored!).\\n\");\n  return state;\n#endif\n}\n\n/**\n * Prevents further manipulations to the String's content.\n */\ninline FIO_FUNC void fio_str_freeze(fio_str_s *s) {\n  if (!s)\n    return;\n  s->frozen = 1;\n}\n\n/**\n * Binary comparison returns `1` if both strings are equal and `0` if not.\n */\ninline FIO_FUNC int fio_str_iseq(const fio_str_s *str1, const fio_str_s *str2) {\n  if (str1 == str2)\n    return 1;\n  if (!str1 || !str2)\n    return 0;\n  fio_str_info_s s1 = fio_str_info(str1);\n  fio_str_info_s s2 = fio_str_info(str2);\n  return (s1.len == s2.len && !memcmp(s1.data, s2.data, s1.len));\n}\n\n/**\n * `fio_str_send_free2` sends the fio_str_s using `fio_write2`, freeing the\n * String once the data was sent\n *\n * As the naming indicates, the String is assumed to have been allocated using\n * `fio_str_new2` or `fio_malloc`.\n */\ninline FIO_FUNC ssize_t fio_str_send_free2(const intptr_t uuid,\n                                           const fio_str_s *str) {\n  if (!str)\n    return 0;\n  fio_str_info_s state = fio_str_info(str);\n  return fio_write2(uuid, .data.buffer = str, .length = state.len,\n                    .offset = ((uintptr_t)state.data - (uintptr_t)str),\n                    .after.dealloc = (void (*)(void *))fio_str_free2);\n}\n\n#undef ROUND_UP_CAPA2WORDS\n#undef FIO_STR_SMALL_DATA\n#undef FIO_STR_NO_REF\n\n#endif /* H_FIO_STR_H */\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n\n\n\n\n                               Dynamic Array Data-Store\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n#ifdef FIO_ARY_NAME\n/**\n * A simple typed dynamic array with a minimal API.\n *\n * To create an Array type, define the macro FIO_ARY_NAME. i.e.:\n *\n *         #define FIO_ARY_NAME fio_cstr_ary\n *         #define FIO_ARY_TYPE char *\n *         #define FIO_ARY_COMPARE(k1, k2) (!strcmp((k1), (k2)))\n *         #include <fio.h>\n *\n * It's possible to create a number of Array types by reincluding the fio.h\n * header. i.e.:\n *\n *\n *         #define FIO_INCLUDE_STR\n *         #include <fio.h> // adds the fio_str_s types and functions\n *\n *         #define FIO_ARY_NAME fio_int_ary\n *         #define FIO_ARY_TYPE int\n *         #include <fio.h> // creates the fio_int_ary_s Array and functions\n *\n *         #define FIO_ARY_NAME fio_str_ary\n *         #define FIO_ARY_TYPE fio_str_s *\n *         #define FIO_ARY_COMPARE(k1, k2) (fio_str_iseq((k1), (k2)))\n *         #define FIO_ARY_COPY(key) fio_str_dup((key))\n *         #define FIO_ARY_DESTROY(key) fio_str_free2((key))\n *         #include <fio.h> // creates the fio_str_ary_s Array and functions\n *\n * Note: Before freeing the Array, FIO_ARY_DESTROY will be automatically called\n *       for every existing object, including any invalid objects (if any).\n */\n\n/* Used for naming functions and types, prefixing FIO_ARY_NAME to the name */\n#define FIO_NAME_FROM_MACRO_STEP2(name, postfix) name##_##postfix\n#define FIO_NAME_FROM_MACRO_STEP1(name, postfix)                               \\\n  FIO_NAME_FROM_MACRO_STEP2(name, postfix)\n#define FIO_NAME(postfix) FIO_NAME_FROM_MACRO_STEP1(FIO_ARY_NAME, postfix)\n\n/* Used for naming the `free` function */\n#define FIO_NAME_FROM_MACRO_STEP4(name) name##_free\n#define FIO_NAME_FROM_MACRO_STEP3(name) FIO_NAME_FROM_MACRO_STEP4(name)\n#define FIO_NAME_FREE() FIO_NAME_FROM_MACRO_STEP3(FIO_ARY_NAME)\n\n/* The default Array object type is `void *` */\n#if !defined(FIO_ARY_TYPE)\n#define FIO_ARY_TYPE void *\n#endif\n\n/* An invalid object has all bytes set to 0 - a static constant will do. */\n#if !defined(FIO_ARY_INVALID)\nstatic FIO_ARY_TYPE const FIO_NAME(s___const_invalid_object);\n#define FIO_ARY_INVALID FIO_NAME(s___const_invalid_object)\n#endif\n\n/* The default Array comparison assumes a simple type */\n#if !defined(FIO_ARY_COMPARE)\n#define FIO_ARY_COMPARE(o1, o2) ((o1) == (o2))\n#endif\n\n/** object copy required? */\n#ifndef FIO_ARY_COPY\n#define FIO_ARY_COPY_IS_SIMPLE 1\n#define FIO_ARY_COPY(dest, obj) ((dest) = (obj))\n#endif\n\n/** object destruction required? */\n#ifndef FIO_ARY_DESTROY\n#define FIO_ARY_DESTROY(obj) ((void)0)\n#endif\n\n/* Customizable memory management */\n#ifndef FIO_ARY_MALLOC /* NULL ptr indicates new allocation */\n#define FIO_ARY_MALLOC(size) FIO_MALLOC((size))\n#endif\n\n/* Customizable memory management */\n#ifndef FIO_ARY_REALLOC /* NULL ptr indicates new allocation */\n#define FIO_ARY_REALLOC(ptr, original_size, new_size, valid_data_length)       \\\n  FIO_REALLOC((ptr), (new_size), (valid_data_length))\n#endif\n\n#ifndef FIO_ARY_DEALLOC\n#define FIO_ARY_DEALLOC(ptr, size) FIO_FREE((ptr))\n#endif\n\n/* padding to be assumed for future expansion. */\n#ifndef FIO_ARY_PADDING\n#define FIO_ARY_PADDING 4\n#endif\n\n/* minimizes allocation \"dead space\" by alligning allocated length to 16bytes */\n#undef FIO_ARY_SIZE2WORDS\n#define FIO_ARY_SIZE2WORDS(size)                                               \\\n  ((sizeof(FIO_ARY_TYPE) & 1)                                                  \\\n       ? (((size) & (~15)) + 16)                                               \\\n       : (sizeof(FIO_ARY_TYPE) & 2)                                            \\\n             ? (((size) & (~7)) + 8)                                           \\\n             : (sizeof(FIO_ARY_TYPE) & 4)                                      \\\n                   ? (((size) & (~3)) + 4)                                     \\\n                   : (sizeof(FIO_ARY_TYPE) & 8) ? (((size) & (~1)) + 2)        \\\n                                                : (size))\n\n/* *****************************************************************************\nArray API\n***************************************************************************** */\n\n/** The Array container type. */\ntypedef struct FIO_NAME(s) FIO_NAME(s);\n\n#ifndef FIO_ARY_INIT\n/** Initializes the Array */\n#define FIO_ARY_INIT                                                           \\\n  { .capa = 0 }\n#endif\n\n/** Frees the array's internal data. */\nFIO_FUNC inline void FIO_NAME_FREE()(FIO_NAME(s) * ary);\n\n/** Returns the number of elements in the Array. */\nFIO_FUNC inline size_t FIO_NAME(count)(FIO_NAME(s) * ary);\n\n/** Returns the current, temporary, array capacity (it's dynamic). */\nFIO_FUNC inline size_t FIO_NAME(capa)(FIO_NAME(s) * ary);\n\n/**\n * Adds all the items in the `src` Array to the end of the `dest` Array.\n *\n * The `src` Array remain untouched.\n */\nFIO_FUNC inline void FIO_NAME(concat)(FIO_NAME(s) * dest, FIO_NAME(s) * src);\n\n/**\n * Sets `index` to the value in `data`.\n *\n * If `index` is negative, it will be counted from the end of the Array (-1 ==\n * last element).\n *\n * If `old` isn't NULL, the existing data will be copied to the location pointed\n * to by `old` before the copy in the Array is destroyed.\n */\nFIO_FUNC inline void FIO_NAME(set)(FIO_NAME(s) * ary, intptr_t index,\n                                   FIO_ARY_TYPE data, FIO_ARY_TYPE *old);\n\n/**\n * Returns the value located at `index` (no copying is peformed).\n *\n * If `index` is negative, it will be counted from the end of the Array (-1 ==\n * last element).\n */\nFIO_FUNC inline FIO_ARY_TYPE FIO_NAME(get)(FIO_NAME(s) * ary, intptr_t index);\n\n/**\n * Returns the index of the object or -1 if the object wasn't found.\n */\nFIO_FUNC inline intptr_t FIO_NAME(find)(FIO_NAME(s) * ary, FIO_ARY_TYPE data);\n\n/**\n * Removes an object from the array, MOVING all the other objects to prevent\n * \"holes\" in the data.\n *\n * If `old` is set, the data is copied to the location pointed to by `old`\n * before the data in the array is destroyed.\n *\n * Returns 0 on success and -1 on error.\n */\nFIO_FUNC inline int FIO_NAME(remove)(FIO_NAME(s) * ary, intptr_t index,\n                                     FIO_ARY_TYPE *old);\n\n/**\n * Removes an object from the array, if it exists, MOVING all the other objects\n * to prevent \"holes\" in the data.\n *\n * Returns -1 if the object wasn't found or 0 if the object was successfully\n * removed.\n */\nFIO_FUNC inline int FIO_NAME(remove2)(FIO_NAME(s) * ary, FIO_ARY_TYPE data,\n                                      FIO_ARY_TYPE *old);\n\n/**\n * Returns a pointer to the C array containing the objects.\n */\nFIO_FUNC inline FIO_ARY_TYPE *FIO_NAME(to_a)(FIO_NAME(s) * ary);\n\n/**\n * Pushes an object to the end of the Array. Returns -1 on error.\n */\nFIO_FUNC inline int FIO_NAME(push)(FIO_NAME(s) * ary, FIO_ARY_TYPE data);\n\n/**\n * Removes an object from the end of the Array.\n *\n * If `old` is set, the data is copied to the location pointed to by `old`\n * before the data in the array is destroyed.\n *\n * Returns -1 on error (Array is empty) and 0 on success.\n */\nFIO_FUNC inline int FIO_NAME(pop)(FIO_NAME(s) * ary, FIO_ARY_TYPE *old);\n\n/**\n * Unshifts an object to the beginning of the Array. Returns -1 on error.\n *\n * This could be expensive, causing `memmove`.\n */\nFIO_FUNC inline int FIO_NAME(unshift)(FIO_NAME(s) * ary, FIO_ARY_TYPE data);\n\n/**\n * Removes an object from the beginning of the Array.\n *\n * If `old` is set, the data is copied to the location pointed to by `old`\n * before the data in the array is destroyed.\n *\n * Returns -1 on error (Array is empty) and 0 on success.\n */\nFIO_FUNC inline int FIO_NAME(shift)(FIO_NAME(s) * ary, FIO_ARY_TYPE *old);\n\n/**\n * Iteration using a callback for each entry in the array.\n *\n * The callback task function must accept an the entry data as well as an opaque\n * user pointer.\n *\n * If the callback returns -1, the loop is broken. Any other value is ignored.\n *\n * Returns the relative \"stop\" position, i.e., the number of items processed +\n * the starting point.\n */\nFIO_FUNC inline size_t FIO_NAME(each)(FIO_NAME(s) * ary, size_t start_at,\n                                      int (*task)(FIO_ARY_TYPE pt, void *arg),\n                                      void *arg);\n/**\n * Removes any FIO_ARY_TYPE_INVALID object from an Array (NULL pointers by\n * default), keeping all other data in the array.\n *\n * This action is O(n) where n in the length of the array.\n * It could get expensive.\n */\nFIO_FUNC inline void FIO_NAME(compact)(FIO_NAME(s) * ary);\n\n/**\n * Iterates through the list using a `for` loop.\n *\n * Access the object with the pointer `pos`. The `pos` variable can be named\n * however you please.\n *\n * Avoid editing the array during a FOR loop, although I hope it's possible, I\n * wouldn't count on it.\n */\n#ifndef FIO_ARY_FOR\n#define FIO_ARY_FOR(ary, pos)                                                  \\\n  if ((ary)->arry)                                                             \\\n    for (__typeof__((ary)->arry) start__tmp__ = (ary)->arry,                   \\\n                                 pos = ((ary)->arry + (ary)->start);           \\\n         pos < (ary)->arry + (ary)->end;                                       \\\n         (pos = (ary)->arry + (pos - start__tmp__) + 1),                       \\\n                                 (start__tmp__ = (ary)->arry))\n#endif\n\n/* *****************************************************************************\nArray Type\n***************************************************************************** */\n\nstruct FIO_NAME(s) {\n  size_t start;       /* first index where data was already written */\n  size_t end;         /* next spot to write at tail */\n  size_t capa;        /* existing capacity */\n  FIO_ARY_TYPE *arry; /* the actual array's memory, if any */\n};\n\n/* *****************************************************************************\nArray Memory Management\n***************************************************************************** */\n\nFIO_FUNC inline void FIO_NAME_FREE()(FIO_NAME(s) * ary) {\n  if (ary) {\n    const size_t count = ary->end;\n    for (size_t i = ary->start; i < count; ++i) {\n      FIO_ARY_DESTROY((ary->arry[i]));\n    }\n    FIO_ARY_DEALLOC(ary->arry, ary->capa * sizeof(*ary->arry));\n    *ary = (FIO_NAME(s))FIO_ARY_INIT;\n  }\n}\n\n/** Converts between a relative index to an absolute index. */\nFIO_FUNC inline intptr_t FIO_NAME(__rel2absolute)(FIO_NAME(s) * ary,\n                                                  intptr_t index) {\n  if (index >= 0)\n    return index;\n  index += ary->end - ary->start;\n  if (index >= 0)\n    return index;\n  return 0;\n}\n\n/** Makes sure that `len` positions are available at the Array's end. */\nFIO_FUNC void FIO_NAME(__require_on_top)(FIO_NAME(s) * ary, size_t len) {\n  if (ary->end + len < ary->capa)\n    return;\n  len = FIO_ARY_SIZE2WORDS((len + ary->end));\n  /* reallocate enough memory */\n  ary->arry = FIO_ARY_REALLOC(ary->arry, sizeof(*ary->arry) * ary->capa,\n                              (len) * sizeof(*ary->arry),\n                              ary->end * sizeof(*ary->arry));\n  FIO_ASSERT_ALLOC(ary->arry);\n  ary->capa = len;\n}\n\n/** Makes sure that `len` positions are available at the Array's head. */\nFIO_FUNC void FIO_NAME(__require_on_bottom)(FIO_NAME(s) * ary, size_t len) {\n  if (ary->start >= len)\n    return;\n  FIO_ARY_TYPE *tmp = ary->arry;\n  len = FIO_ARY_SIZE2WORDS((len - ary->start) + ary->end);\n  if (ary->capa <= len) {\n    /* no room - allocate and copy */\n    ary->arry = FIO_ARY_MALLOC(len * sizeof(*ary->arry));\n    FIO_ASSERT_ALLOC(ary->arry);\n    ary->capa = len;\n  }\n  /* move existing data to the end of the existing space */\n  len = ary->end - ary->start;\n  ary->end = ary->capa;\n  if (len)\n    memmove(ary->arry + (ary->capa - len), tmp + ary->start,\n            len * sizeof(*ary->arry));\n  ary->start = ary->end - len;\n  if (tmp != ary->arry) {\n    FIO_FREE(tmp);\n  }\n}\n\n/* *****************************************************************************\nArray API implementation\n***************************************************************************** */\n\n/** Returns the number of elements in the Array. */\nFIO_FUNC inline size_t FIO_NAME(count)(FIO_NAME(s) * ary) {\n  return ary ? (ary->end - ary->start) : 0;\n}\n\n/** Returns the current, temporary, array capacity (it's dynamic). */\nFIO_FUNC inline size_t FIO_NAME(capa)(FIO_NAME(s) * ary) {\n  return ary ? ary->capa : 0;\n}\n\n/**\n * Returns a pointer to the C array containing the objects.\n */\nFIO_FUNC inline FIO_ARY_TYPE *FIO_NAME(to_a)(FIO_NAME(s) * ary) {\n  return ary ? (ary->arry + ary->start) : NULL;\n}\n\n/**\n * Adds all the items in the `src` Array to the end of the `dest` Array.\n *\n * The `src` Array remain untouched.\n */\nFIO_FUNC inline void FIO_NAME(concat)(FIO_NAME(s) * dest, FIO_NAME(s) * src) {\n  if (!src)\n    return;\n  const size_t added = FIO_NAME(count)(src);\n  if (!added || !dest)\n    return;\n  FIO_NAME(__require_on_top)(dest, added);\n#if FIO_ARY_COPY_IS_SIMPLE\n  memcpy(dest->arry + dest->end, src->arry + src->start,\n         added * sizeof(*dest->arry));\n#else\n  /* don't use memcpy, in case copying has side-effects (see macro) */\n  for (size_t i = 0; i < added; ++i) {\n    FIO_ARY_COPY(((dest->arry + dest->end)[i]), ((src->arry + src->start)[i]));\n  }\n#endif\n  dest->end += added;\n}\n\n/**\n * Sets `index` to the value in `data`.\n *\n * If `index` is negative, it will be counted from the end of the Array (-1 ==\n * last element).\n *\n * If `old` isn't NULL, the existing data will be copied to the location pointed\n * to by `old` before the copy in the Array is destroyed.\n */\nFIO_FUNC inline void FIO_NAME(set)(FIO_NAME(s) * ary, intptr_t index,\n                                   FIO_ARY_TYPE data, FIO_ARY_TYPE *old) {\n  if (!ary)\n    return;\n  if (ary->start == ary->end) /* reset memory starting point? */\n    ary->start = ary->end = 0;\n\n  index = FIO_NAME(__rel2absolute)(ary, index);\n\n  const intptr_t spaces = index - (ary->end - ary->start);\n  if (spaces < 0) {\n    /* likely */\n    if (old)\n      FIO_ARY_COPY((*old), ((ary->arry + ary->start)[index]));\n    FIO_ARY_DESTROY(((ary->arry + ary->start)[index]));\n    FIO_ARY_COPY(((ary->arry + ary->start)[index]), data);\n    return;\n  }\n\n  /* fill empty spaces with zero */\n  FIO_NAME(__require_on_top)(ary, spaces + 1);\n  if (spaces) {\n    memset(ary->arry + ary->end, 0, sizeof(*ary->arry) * spaces);\n  }\n  FIO_ARY_COPY(((ary->arry + ary->start)[index]), data);\n  ary->end = index + 1;\n}\n\n/**\n * Returns the value located at `index` (no copying is peformed).\n *\n * If `index` is negative, it will be counted from the end of the Array (-1 ==\n * last element).\n */\nFIO_FUNC inline FIO_ARY_TYPE FIO_NAME(get)(FIO_NAME(s) * ary, intptr_t index) {\n  if (!ary)\n    return FIO_ARY_INVALID;\n  index = FIO_NAME(__rel2absolute)(ary, index);\n  if ((size_t)index >= ary->end - ary->start)\n    return FIO_ARY_INVALID;\n  return (ary->arry + ary->start)[index];\n}\n\n/**\n * Returns the index of the object or -1 if the object wasn't found.\n */\nFIO_FUNC inline intptr_t FIO_NAME(find)(FIO_NAME(s) * ary, FIO_ARY_TYPE data) {\n  const size_t count = FIO_NAME(count)(ary);\n  if (!count) {\n    return -1;\n  }\n  size_t pos = ary->start;\n  register const size_t end = ary->end;\n  while (pos < end && !FIO_ARY_COMPARE(data, ary->arry[pos])) {\n    ++pos;\n  }\n  if (pos == end)\n    return -1;\n  return (pos - ary->start);\n}\n\n/**\n * Removes an object from the array, MOVING all the other objects to prevent\n * \"holes\" in the data.\n *\n * If `old` is set, the data is copied to the location pointed to by `old`\n * before the data in the array is destroyed.\n *\n * Returns 0 on success and -1 on error.\n */\nFIO_FUNC inline int FIO_NAME(remove)(FIO_NAME(s) * ary, intptr_t index,\n                                     FIO_ARY_TYPE *old) {\n  index = FIO_NAME(__rel2absolute)(ary, index);\n  const size_t count = FIO_NAME(count)(ary);\n  if (!count || (size_t)index >= count) {\n    return -1;\n  }\n  index += ary->start;\n  if (old)\n    FIO_ARY_COPY((*old), (ary->arry[index]));\n  FIO_ARY_DESTROY((ary->arry[index]));\n  if ((size_t)index == ary->start) {\n    ++ary->start;\n    return 0;\n  }\n  --ary->end;\n  if ((size_t)index < ary->end) {\n    memmove(ary->arry + index, ary->arry + index + 1,\n            (ary->end - index) * sizeof(*ary->arry));\n  }\n  return 0;\n}\n\n/**\n * Removes an object from the array, if it exists, MOVING all the other objects\n * to prevent \"holes\" in the data.\n *\n * Returns -1 if the object wasn't found or 0 if the object was successfully\n * removed.\n */\nFIO_FUNC inline int FIO_NAME(remove2)(FIO_NAME(s) * ary, FIO_ARY_TYPE data,\n                                      FIO_ARY_TYPE *old) {\n  intptr_t index = FIO_NAME(find)(ary, data);\n  if (index == -1) {\n    return -1;\n  }\n  return FIO_NAME(remove)(ary, index, old);\n}\n\n/**\n * Pushes an object to the end of the Array. Returns -1 on error.\n */\nFIO_FUNC inline int FIO_NAME(push)(FIO_NAME(s) * ary, FIO_ARY_TYPE data) {\n  if (!ary)\n    return -1;\n  if (ary->capa <= ary->end)\n    FIO_NAME(__require_on_top)(ary, 1 + FIO_ARY_PADDING);\n  if (ary->start == ary->end) /* reset memory starting point? */\n    ary->start = ary->end = 0;\n  FIO_ARY_COPY(ary->arry[ary->end], data);\n  ++ary->end;\n  return 0;\n}\n\n/**\n * Removes an object from the end of the Array.\n *\n * If `old` is set, the data is copied to the location pointed to by `old`\n * before the data in the array is destroyed.\n *\n * Returns -1 on error (Array is empty) and 0 on success.\n */\nFIO_FUNC inline int FIO_NAME(pop)(FIO_NAME(s) * ary, FIO_ARY_TYPE *old) {\n  if (!FIO_NAME(count)(ary))\n    return -1;\n  --ary->end;\n  if (old)\n    FIO_ARY_COPY((*old), (ary->arry[ary->end]));\n  FIO_ARY_DESTROY((ary->arry[ary->end]));\n  return 0;\n}\n\n/**\n * Unshifts an object to the beginning of the Array. Returns -1 on error.\n *\n * This could be expensive, causing `memmove`.\n */\nFIO_FUNC inline int FIO_NAME(unshift)(FIO_NAME(s) * ary, FIO_ARY_TYPE data) {\n  if (!ary)\n    return -1;\n  if (ary->start == 0)\n    FIO_NAME(__require_on_bottom)(ary, 8);\n  --ary->start;\n  FIO_ARY_COPY(ary->arry[ary->start], data);\n  return 0;\n}\n\n/**\n * Removes an object from the beginning of the Array.\n *\n * If `old` is set, the data is copied to the location pointed to by `old`\n * before the data in the array is destroyed.\n *\n * Returns -1 on error (Array is empty) and 0 on success.\n */\nFIO_FUNC inline int FIO_NAME(shift)(FIO_NAME(s) * ary, FIO_ARY_TYPE *old) {\n  if (!FIO_NAME(count)(ary))\n    return -1;\n  if (old)\n    FIO_ARY_COPY((*old), (ary->arry[ary->start]));\n  FIO_ARY_DESTROY((ary->arry[ary->start]));\n  ++ary->start;\n  return 0;\n}\n\n/**\n * Iteration using a callback for each entry in the array.\n *\n * The callback task function must accept an the entry data as well as an opaque\n * user pointer.\n *\n * If the callback returns -1, the loop is broken. Any other value is ignored.\n *\n * Returns the relative \"stop\" position, i.e., the number of items processed +\n * the starting point.\n */\nFIO_FUNC inline size_t FIO_NAME(each)(FIO_NAME(s) * ary, size_t start_at,\n                                      int (*task)(FIO_ARY_TYPE pt, void *arg),\n                                      void *arg) {\n  const size_t count = FIO_NAME(count)(ary);\n  if (!count || start_at >= count) {\n    return count;\n  }\n  while (start_at < count &&\n         task(ary->arry[ary->start + (start_at++)], arg) != -1)\n    ;\n  return start_at;\n}\n/**\n * Removes any FIO_ARY_TYPE_INVALID object from an Array (NULL pointers by\n * default), keeping all other data in the array.\n *\n * This action is O(n) where n in the length of the array.\n * It could get expensive.\n */\nFIO_FUNC inline void FIO_NAME(compact)(FIO_NAME(s) * ary) {\n  const size_t count = FIO_NAME(count)(ary);\n  if (!count)\n    return;\n  register FIO_ARY_TYPE *pos = ary->arry + ary->start;\n  register FIO_ARY_TYPE *reader = ary->arry + ary->start;\n  register FIO_ARY_TYPE *stop = ary->arry + ary->end;\n  while (reader < stop) {\n    if (!FIO_ARY_COMPARE((*reader), FIO_ARY_INVALID)) {\n      *pos = *reader;\n      pos += 1;\n    }\n    reader += 1;\n  }\n  ary->end = (size_t)(pos - ary->arry);\n}\n\n/* *****************************************************************************\nArray Testing\n***************************************************************************** */\n\n#if DEBUG\n#include <stdio.h>\n#define TEST_LIMIT 1016\n/**\n * Removes any FIO_ARY_TYPE_INVALID  *pointers* from an Array, keeping all other\n * data in the array.\n *\n * This action is O(n) where n in the length of the array.\n * It could get expensive.\n */\nFIO_FUNC inline void FIO_NAME(_test)(void) {\n  union {\n    FIO_ARY_TYPE obj;\n    uintptr_t i;\n  } mem;\n  FIO_NAME(s) ary = FIO_ARY_INIT;\n  fprintf(stderr, \"=== Testing Core Array features for type \" FIO_MACRO2STR(\n                      FIO_ARY_TYPE) \"\\n\");\n\n  for (uintptr_t i = 0; i < TEST_LIMIT; ++i) {\n    mem.i = i + 1;\n    FIO_NAME(push)(&ary, mem.obj);\n  }\n  fprintf(stderr,\n          \"* Array populated using `push` with %zu items,\\n\"\n          \"  with capacity limit of %zu and start index %zu\\n\",\n          (size_t)FIO_NAME(count)(&ary), (size_t)FIO_NAME(capa)(&ary),\n          ary.start);\n  FIO_ASSERT(FIO_NAME(count)(&ary) == TEST_LIMIT,\n             \"Wrong object count for array %zu\", (size_t)FIO_NAME(count)(&ary));\n  for (uintptr_t i = 0; i < TEST_LIMIT; ++i) {\n    FIO_ASSERT(!FIO_NAME(shift)(&ary, &mem.obj), \"Array shift failed at %lu.\",\n               i);\n    FIO_ASSERT(mem.i == i + 1, \"Array shift value error %lu != %lu\", mem.i,\n               i + 1);\n    FIO_ARY_DESTROY(mem.obj);\n  }\n\n  FIO_NAME_FREE()(&ary);\n  FIO_ASSERT(!ary.arry, \"Array not reset after fio_ary_free\");\n\n  for (uintptr_t i = 0; i < TEST_LIMIT; ++i) {\n    mem.i = TEST_LIMIT - i;\n    FIO_NAME(unshift)(&ary, mem.obj);\n  }\n  fprintf(stderr,\n          \"* Array populated using `unshift` with %zu items,\\n\"\n          \"  with capacity limit of %zu and start index %zu\\n\",\n          (size_t)FIO_NAME(count)(&ary), (size_t)FIO_NAME(capa)(&ary),\n          ary.start);\n\n  FIO_ASSERT(FIO_NAME(count)(&ary) == TEST_LIMIT,\n             \"Wrong object count for array %zu\", (size_t)FIO_NAME(count)(&ary));\n  for (uintptr_t i = 0; i < TEST_LIMIT; ++i) {\n    FIO_NAME(pop)(&ary, &mem.obj);\n    FIO_ASSERT(mem.i == TEST_LIMIT - i, \"Array pop value error\");\n    FIO_ARY_DESTROY(mem.obj);\n  }\n  FIO_NAME_FREE()(&ary);\n  FIO_ASSERT(!ary.arry, \"Array not reset after fio_ary_free\");\n\n  for (uintptr_t i = 0; i < TEST_LIMIT; ++i) {\n    mem.i = TEST_LIMIT - i;\n    FIO_NAME(unshift)(&ary, mem.obj);\n  }\n\n  for (size_t i = 0; i < TEST_LIMIT; ++i) {\n    mem.i = i + 1;\n    FIO_ASSERT(FIO_NAME(find)(&ary, mem.obj) == (intptr_t)i,\n               \"Wrong object index - ary[%zd] != %zu\",\n               (ssize_t)FIO_NAME(find)(&ary, mem.obj), (size_t)mem.i);\n    mem.obj = FIO_NAME(get)(&ary, i);\n    FIO_ASSERT(mem.i == (uintptr_t)(i + 1),\n               \"Wrong object returned from fio_ary_index - ary[%zu] != %zu\", i,\n               i + 1);\n  }\n\n  FIO_ASSERT((FIO_NAME(count)(&ary) == TEST_LIMIT),\n             \"Wrong object count before pop %zu\",\n             (size_t)FIO_NAME(count)(&ary));\n  FIO_ASSERT(!FIO_NAME(pop)(&ary, &mem.obj), \"Couldn't pop element.\");\n  FIO_ASSERT(mem.i == TEST_LIMIT, \"Element value error (%zu).\", (size_t)mem.i);\n  FIO_ASSERT((FIO_NAME(count)(&ary) == TEST_LIMIT - 1),\n             \"Wrong object count after pop %zu\", (size_t)FIO_NAME(count)(&ary));\n  FIO_ARY_DESTROY(mem.obj);\n\n  mem.i = (TEST_LIMIT >> 1);\n  FIO_ASSERT(!FIO_NAME(remove2)(&ary, mem.obj, NULL),\n             \"Couldn't fio_ary_remove2 object from Array (%zu)\", (size_t)mem.i);\n  FIO_ASSERT(FIO_NAME(count)(&ary) == TEST_LIMIT - 2,\n             \"Wrong object count after remove2 %zu\",\n             (size_t)FIO_NAME(count)(&ary));\n  mem.i = (TEST_LIMIT >> 1) + 1;\n  FIO_ASSERT(FIO_NAME(find)(&ary, mem.obj) != (TEST_LIMIT >> 1) + 1,\n             \"fio_ary_remove2 didn't clear holes from Array (%zu)\",\n             (size_t)FIO_NAME(find)(&ary, mem.obj));\n  FIO_ARY_DESTROY(mem.obj);\n\n  FIO_ASSERT(!FIO_NAME(remove)(&ary, 0, &mem.obj),\n             \"fio_ary_remove failed (at %zd)\", (ssize_t)mem.i);\n  FIO_ASSERT(mem.i == 1, \"Couldn't fio_ary_remove object from Array (%zd)\",\n             (ssize_t)mem.i);\n  FIO_ASSERT(FIO_NAME(count)(&ary) == TEST_LIMIT - 3,\n             \"Wrong object count after remove %zu != %d\",\n             (size_t)FIO_NAME(count)(&ary), TEST_LIMIT - 3);\n  FIO_ASSERT(FIO_NAME(find)(&ary, mem.obj) == -1,\n             \"fio_ary_find should have failed after fio_ary_remove (%zd)\",\n             (ssize_t)FIO_NAME(find)(&ary, mem.obj));\n  FIO_ARY_DESTROY(mem.obj);\n\n  mem.i = 2;\n  FIO_ASSERT(FIO_NAME(find)(&ary, mem.obj) == 0,\n             \"fio_ary_remove didn't clear holes from Array (%zu)\",\n             (size_t)FIO_NAME(find)(&ary, mem.obj));\n\n  FIO_NAME_FREE()(&ary);\n\n  FIO_NAME(s) ary2 = FIO_ARY_INIT;\n  for (uintptr_t i = 0; i < (TEST_LIMIT >> 1); ++i) {\n    mem.i = ((TEST_LIMIT >> 1) << 1) - i;\n    FIO_NAME(unshift)(&ary2, mem.obj);\n    mem.i = (TEST_LIMIT >> 1) - i;\n    FIO_NAME(unshift)(&ary, mem.obj);\n  }\n  FIO_NAME(concat)(&ary, &ary2);\n  FIO_NAME_FREE()(&ary2);\n  FIO_ASSERT(FIO_NAME(count)(&ary) == ((TEST_LIMIT >> 1) << 1),\n             \"Wrong object count after fio_ary_concat %zu\",\n             (size_t)FIO_NAME(count)(&ary));\n  for (int i = 0; i < ((TEST_LIMIT >> 1) << 1); ++i) {\n    mem.obj = FIO_NAME(get)(&ary, i);\n    FIO_ASSERT(\n        mem.i == (uintptr_t)(i + 1),\n        \"Wrong object returned from fio_ary_index after concat - ary[%d] != %d\",\n        i, i + 1);\n  }\n  mem.i = 0;\n  while (FIO_NAME(pop)(&ary, &mem.obj)) {\n    ++mem.i;\n    FIO_ARY_DESTROY(mem.obj);\n  }\n  FIO_ASSERT(mem.i == ((TEST_LIMIT >> 1) << 1), \"fio_ary_pop overflow (%zu)?\",\n             (size_t)mem.i);\n  FIO_NAME_FREE()(&ary);\n}\n#undef TEST_LIMIT\n#else\nFIO_FUNC inline void FIO_NAME(_test)(void) {}\n#endif\n\n/* *****************************************************************************\nDone\n***************************************************************************** */\n\n#undef FIO_NAME_FROM_MACRO_STEP2\n#undef FIO_NAME_FROM_MACRO_STEP1\n#undef FIO_NAME\n#undef FIO_NAME_FROM_MACRO_STEP4\n#undef FIO_NAME_FROM_MACRO_STEP3\n#undef FIO_NAME_FREE\n#undef FIO_ARY_NAME\n#undef FIO_ARY_TYPE\n#undef FIO_ARY_INVALID\n#undef FIO_ARY_COMPARE\n#undef FIO_ARY_COPY\n#undef FIO_ARY_COPY_IS_SIMPLE\n#undef FIO_ARY_DESTROY\n#undef FIO_ARY_REALLOC\n#undef FIO_ARY_DEALLOC\n#undef FIO_ARY_SIZE2WORDS\n\n#endif\n\n/* *****************************************************************************\n\n\n\n\n\n\n\n\n\n\n\n                               Set / Hash Map Data-Store\n\n\n\n\n\n\n\n\n\n\n\n***************************************************************************** */\n\n#ifdef FIO_SET_NAME\n\n/**\n * A simple ordered Set / Hash Map implementation, with a minimal API.\n *\n * A Set is basically a Hash Map where the keys are also the values, it's often\n * used for caching objects.\n *\n * The Set's object type and behavior is controlled by the FIO_SET_OBJ_* marcos.\n *\n * A Hash Map is basically a set where the objects in the Set are key-value\n * couplets and only the keys are tested when searching the Set.\n *\n * To create a Set or a Hash Map, the macro FIO_SET_NAME must be defined. i.e.:\n *\n *         #define FIO_SET_NAME cstr_set\n *         #define FIO_SET_OBJ_TYPE char *\n *         #define FIO_SET_OBJ_COMPARE(k1, k2) (!strcmp((k1), (k2)))\n *         #include <fio.h>\n *\n * To create a Hash Map, rather than a pure Set, the macro FIO_SET_KEY_TYPE must\n * be defined. i.e.:\n *\n *         #define FIO_SET_KEY_TYPE char *\n *\n * This allows the FIO_SET_KEY_* macros to be defined as well. For example:\n *\n *         #define FIO_SET_NAME cstr_hashmap\n *         #define FIO_SET_KEY_TYPE char *\n *         #define FIO_SET_KEY_COMPARE(k1, k2) (!strcmp((k1), (k2)))\n *         #define FIO_SET_OBJ_TYPE char *\n *         #include <fio.h>\n *\n * It's possible to create a number of Set or HasMap types by reincluding the\n * fio.h header. i.e.:\n *\n *\n *         #define FIO_INCLUDE_STR\n *         #include <fio.h> // adds the fio_str_s types and functions\n *\n *         #define FIO_SET_NAME fio_str_set\n *         #define FIO_SET_OBJ_TYPE fio_str_s *\n *         #define FIO_SET_OBJ_COMPARE(k1, k2) (fio_str_iseq((k1), (k2)))\n *         #define FIO_SET_OBJ_COPY(key) fio_str_dup((key))\n *         #define FIO_SET_OBJ_DESTROY(key) fio_str_free2((key))\n *         #include <fio.h> // creates the fio_str_set_s Set and functions\n *\n *         #define FIO_SET_NAME fio_str_hash\n *         #define FIO_SET_KEY_TYPE fio_str_s *\n *         #define FIO_SET_KEY_COMPARE(k1, k2) (fio_str_iseq((k1), (k2)))\n *         #define FIO_SET_KEY_COPY(key) fio_str_dup((key))\n *         #define FIO_SET_KEY_DESTROY(key) fio_str_free2((key))\n *         #define FIO_SET_OBJ_TYPE fio_str_s *\n *         #define FIO_SET_OBJ_COMPARE(k1, k2) (fio_str_iseq((k1), (k2)))\n *         #define FIO_SET_OBJ_COPY(key) fio_str_dup((key))\n *         #define FIO_SET_OBJ_DESTROY(key) fio_str_free2((key))\n *         #include <fio.h> // creates the fio_str_hash_s Hash Map and functions\n *\n * The default integer Hash used is a pointer length type (uintptr_t). This can\n * be changed by defining ALL of the following macros:\n * * FIO_SET_HASH_TYPE              - the type of the hash value.\n * * FIO_SET_HASH2UINTPTR(hash, i)  - converts the hash value to a uintptr_t.\n * * FIO_SET_HASH_COMPARE(h1, h2)   - compares two hash values (1 == equal).\n * * FIO_SET_HASH_INVALID           - an invalid Hash value, all bytes are 0.\n * * FIO_SET_HASH_FORCE             - an always valid Hash value, all bytes 0xFF\n *\n *\n * Note: FIO_SET_HASH_TYPE should, normaly be left alone (uintptr_t is\n *       enough). Also, the hash value 0 is reserved to indicate an empty slot.\n *\n * Note: the FIO_SET_OBJ_COMPARE or the FIO_SET_KEY_COMPARE will be used to\n *       compare against invalid as well as valid objects. Invalid objects have\n *       their bytes all zero. FIO_SET_*_DESTROY should somehow mark them as\n *       invalid.\n *\n * Note: Before freeing the Set, FIO_SET_OBJ_DESTROY will be automatically\n *       called for every existing object.\n */\n\n/* Used for naming functions and types, prefixing FIO_SET_NAME to the name */\n#define FIO_NAME_FROM_MACRO_STEP2(name, postfix) name##_##postfix\n#define FIO_NAME_FROM_MACRO_STEP1(name, postfix)                               \\\n  FIO_NAME_FROM_MACRO_STEP2(name, postfix)\n#define FIO_NAME(postfix) FIO_NAME_FROM_MACRO_STEP1(FIO_SET_NAME, postfix)\n\n/* Used for naming the `free` function */\n#define FIO_NAME_FROM_MACRO_STEP4(name) name##_free\n#define FIO_NAME_FROM_MACRO_STEP3(name) FIO_NAME_FROM_MACRO_STEP4(name)\n#define FIO_NAME_FREE() FIO_NAME_FROM_MACRO_STEP3(FIO_SET_NAME)\n\n/* The default Set object / value type is `void *` */\n#if !defined(FIO_SET_OBJ_TYPE)\n#define FIO_SET_OBJ_TYPE void *\n#elif !defined(FIO_SET_NO_TEST)\n#define FIO_SET_NO_TEST 1\n#endif\n\n/* The default Set has opaque objects that can't be compared */\n#if !defined(FIO_SET_OBJ_COMPARE)\n#define FIO_SET_OBJ_COMPARE(o1, o2) (1)\n#endif\n\n/** object copy required? */\n#ifndef FIO_SET_OBJ_COPY\n#define FIO_SET_OBJ_COPY(dest, obj) ((dest) = (obj))\n#endif\n\n/** object destruction required? */\n#ifndef FIO_SET_OBJ_DESTROY\n#define FIO_SET_OBJ_DESTROY(obj) ((void)0)\n#endif\n\n/** test for a pre-defined hash type, must be numerical (i.e. __int128_t)*/\n#ifndef FIO_SET_HASH_TYPE\n#define FIO_SET_HASH_TYPE uintptr_t\n#endif\n\n/** test for a pre-defined hash to integer conversion */\n#ifndef FIO_SET_HASH2UINTPTR\n#define FIO_SET_HASH2UINTPTR(hash, bits_used)                                  \\\n  (fio_rrot(hash, bits_used) ^ fio_ct_if2(bits_used, hash, 0))\n#endif\n\n/** test for a pre-defined hash to integer conversion */\n#ifndef FIO_SET_HASH_FORCE\n#define FIO_SET_HASH_FORCE (~(uintptr_t)0)\n#endif\n\n/** test for a pre-defined invalid hash value (all bytes are 0) */\n#ifndef FIO_SET_HASH_INVALID\n#define FIO_SET_HASH_INVALID ((FIO_SET_HASH_TYPE)0)\n#endif\n\n/** test for a pre-defined hash comparison */\n#ifndef FIO_SET_HASH_COMPARE\n#define FIO_SET_HASH_COMPARE(h1, h2) ((h1) == (h2))\n#endif\n\n/* Customizable memory management */\n#ifndef FIO_SET_REALLOC /* NULL ptr indicates new allocation */\n#define FIO_SET_REALLOC(ptr, original_size, new_size, valid_data_length)       \\\n  FIO_REALLOC((ptr), (new_size), (valid_data_length))\n#endif\n\n#ifndef FIO_SET_CALLOC\n#define FIO_SET_CALLOC(size, count) FIO_CALLOC((size), (count))\n#endif\n\n#ifndef FIO_SET_FREE\n#define FIO_SET_FREE(ptr, size) FIO_FREE((ptr))\n#endif\n\n/* The maximum number of bins to rotate when (partial/full) collisions occure */\n#ifndef FIO_SET_MAX_MAP_SEEK\n#define FIO_SET_MAX_MAP_SEEK (96)\n#endif\n\n/* The maximum number of full hash collisions that can be consumed */\n#ifndef FIO_SET_MAX_MAP_FULL_COLLISIONS\n#define FIO_SET_MAX_MAP_FULL_COLLISIONS (96)\n#endif\n\n/* Prime numbers are better */\n#ifndef FIO_SET_CUCKOO_STEPS\n#define FIO_SET_CUCKOO_STEPS 11\n#endif\n\n#ifdef FIO_SET_KEY_TYPE\ntypedef struct {\n  FIO_SET_KEY_TYPE key;\n  FIO_SET_OBJ_TYPE obj;\n} FIO_NAME(couplet_s);\n\n#define FIO_SET_TYPE FIO_NAME(couplet_s)\n\n/** key copy required? */\n#ifndef FIO_SET_KEY_COPY\n#define FIO_SET_KEY_COPY(dest, obj) ((dest) = (obj))\n#endif\n\n/** key destruction required? */\n#ifndef FIO_SET_KEY_DESTROY\n#define FIO_SET_KEY_DESTROY(obj) ((void)0)\n#endif\n\n/* The default Hash Map-Set has will use straight euqality operators */\n#ifndef FIO_SET_KEY_COMPARE\n#define FIO_SET_KEY_COMPARE(o1, o2) ((o1) == (o2))\n#endif\n\n/** Internal macros for object actions in Hash mode */\n#define FIO_SET_COMPARE(o1, o2) FIO_SET_KEY_COMPARE((o1).key, (o2).key)\n#define FIO_SET_COPY(dest, src)                                                \\\n  do {                                                                         \\\n    FIO_SET_OBJ_COPY((dest).obj, (src).obj);                                   \\\n    FIO_SET_KEY_COPY((dest).key, (src).key);                                   \\\n  } while (0);\n#define FIO_SET_DESTROY(couplet)                                               \\\n  do {                                                                         \\\n    FIO_SET_KEY_DESTROY((couplet).key);                                        \\\n    FIO_SET_OBJ_DESTROY((couplet).obj);                                        \\\n  } while (0);\n\n#else /* a pure Set, not a Hash Map*/\n/** Internal macros for object actions in Set mode */\n#define FIO_SET_COMPARE(o1, o2) FIO_SET_OBJ_COMPARE((o1), (o2))\n#define FIO_SET_COPY(dest, obj) FIO_SET_OBJ_COPY((dest), (obj))\n#define FIO_SET_DESTROY(obj) FIO_SET_OBJ_DESTROY((obj))\n#define FIO_SET_TYPE FIO_SET_OBJ_TYPE\n#endif\n\n/* *****************************************************************************\nSet / Hash Map API\n***************************************************************************** */\n\n/** The Set container type. By default: fio_ptr_set_s */\ntypedef struct FIO_NAME(s) FIO_NAME(s);\n\n#ifndef FIO_SET_INIT\n/** Initializes the set */\n#define FIO_SET_INIT                                                           \\\n  { .capa = 0 }\n#endif\n\n/** Frees all the objects in the set and deallocates any internal resources. */\nFIO_FUNC void FIO_NAME_FREE()(FIO_NAME(s) * set);\n\n#ifdef FIO_SET_KEY_TYPE\n\n/**\n * Locates an object in the Hash Map, if it exists.\n *\n * NOTE: This is the function's Hash Map variant. See FIO_SET_KEY_TYPE.\n */\nFIO_FUNC inline FIO_SET_OBJ_TYPE\n    FIO_NAME(find)(FIO_NAME(s) * set, const FIO_SET_HASH_TYPE hash_value,\n                   FIO_SET_KEY_TYPE key);\n\n/**\n * Inserts an object to the Hash Map, rehashing if required, returning the new\n * object's location using a pointer.\n *\n * If an object already exists in the Hash Map, it will be destroyed.\n *\n * If `old` is set, the existing object (if any) will be copied to the location\n * pointed to by `old` before it is destroyed.\n *\n * NOTE: This is the function's Hash Map variant. See FIO_SET_KEY_TYPE.\n */\nFIO_FUNC inline void FIO_NAME(insert)(FIO_NAME(s) * set,\n                                      const FIO_SET_HASH_TYPE hash_value,\n                                      FIO_SET_KEY_TYPE key,\n                                      FIO_SET_OBJ_TYPE obj,\n                                      FIO_SET_OBJ_TYPE *old);\n\n/**\n * Removes an object from the Hash Map, rehashing if required.\n *\n * Returns 0 on success and -1 if the object wasn't found.\n *\n * If `old` is set, the existing object (if any) will be copied to the location\n * pointed to by `old`.\n *\n * NOTE: This is the function's Hash Map variant. See FIO_SET_KEY_TYPE.\n */\nFIO_FUNC inline int FIO_NAME(remove)(FIO_NAME(s) * set,\n                                     const FIO_SET_HASH_TYPE hash_value,\n                                     FIO_SET_KEY_TYPE key,\n                                     FIO_SET_OBJ_TYPE *old);\n\n#else\n\n/**\n * Locates an object in the Set, if it exists.\n *\n * NOTE: This is the function's pure Set variant (no FIO_SET_KEY_TYPE).\n */\nFIO_FUNC inline FIO_SET_OBJ_TYPE\n    FIO_NAME(find)(FIO_NAME(s) * set, const FIO_SET_HASH_TYPE hash_value,\n                   FIO_SET_OBJ_TYPE obj);\n\n/**\n * Inserts an object to the Set only if it's missing, rehashing if required,\n * returning the new (or old) object.\n *\n * If the object already exists in the set, than the new object will be\n * destroyed and the old object will be returned.\n *\n * NOTE: This is the function's pure Set variant (no FIO_SET_KEY_TYPE).\n */\nFIO_FUNC inline FIO_SET_OBJ_TYPE\n    FIO_NAME(insert)(FIO_NAME(s) * set, const FIO_SET_HASH_TYPE hash_value,\n                     FIO_SET_OBJ_TYPE obj);\n\n/**\n * Inserts an object to the Set, rehashing if required, returning the new\n * object.\n *\n * If the object already exists in the set, it will be destroyed and\n * overwritten.\n *\n * When setting `old` to NULL, the function behaves the same as `overwrite`.\n */\nFIO_FUNC FIO_SET_OBJ_TYPE\n    FIO_NAME(overwrite)(FIO_NAME(s) * set, const FIO_SET_HASH_TYPE hash_value,\n                        FIO_SET_OBJ_TYPE obj, FIO_SET_OBJ_TYPE *old);\n\n/**\n * Removes an object from the Set, rehashing if required.\n *\n * Returns 0 on success and -1 if the object wasn't found.\n *\n * NOTE: This is the function's pure Set variant (no FIO_SET_KEY_TYPE).\n */\nFIO_FUNC inline int FIO_NAME(remove)(FIO_NAME(s) * set,\n                                     const FIO_SET_HASH_TYPE hash_value,\n                                     FIO_SET_OBJ_TYPE obj,\n                                     FIO_SET_OBJ_TYPE *old);\n\n#endif\n/**\n * Allows a peak at the Set's last element.\n *\n * Remember that objects might be destroyed if the Set is altered\n * (`FIO_SET_OBJ_DESTROY` / `FIO_SET_KEY_DESTROY`).\n */\nFIO_FUNC inline FIO_SET_TYPE FIO_NAME(last)(FIO_NAME(s) * set);\n\n/**\n * Allows the Hash to be momentarily used as a stack, destroying the last\n * object added (`FIO_SET_OBJ_DESTROY` / `FIO_SET_KEY_DESTROY`).\n */\nFIO_FUNC inline void FIO_NAME(pop)(FIO_NAME(s) * set);\n\n/** Returns the number of object currently in the Set. */\nFIO_FUNC inline size_t FIO_NAME(count)(const FIO_NAME(s) * set);\n\n/**\n * Returns a temporary theoretical Set capacity.\n * This could be used for testing performance and memory consumption.\n */\nFIO_FUNC inline size_t FIO_NAME(capa)(const FIO_NAME(s) * set);\n\n/**\n * Requires that a Set contains the minimal requested theoretical capacity.\n *\n * Returns the actual (temporary) theoretical capacity.\n */\nFIO_FUNC inline size_t FIO_NAME(capa_require)(FIO_NAME(s) * set,\n                                              size_t min_capa);\n\n/**\n * Returns non-zero if the Set is fragmented (more than 50% holes).\n */\nFIO_FUNC inline size_t FIO_NAME(is_fragmented)(const FIO_NAME(s) * set);\n\n/**\n * Attempts to minimize memory usage by removing empty spaces caused by deleted\n * items and rehashing the Set.\n *\n * Returns the updated Set capacity.\n */\nFIO_FUNC inline size_t FIO_NAME(compact)(FIO_NAME(s) * set);\n\n/** Forces a rehashing of the Set. */\nFIO_FUNC void FIO_NAME(rehash)(FIO_NAME(s) * set);\n\n#ifndef FIO_SET_FOR_LOOP\n/**\n * A macro for a `for` loop that iterates over all the Set's objects (in\n * order).\n *\n * `set` is a pointer to the Set variable and `pos` is a temporary variable\n * name to be created for iteration.\n *\n * `pos->hash` is the hashing value and `pos->obj` is the object's data.\n *\n * NOTICE: Since the Set might have \"holes\" (objects that were removed), it is\n * important to skip any `pos->hash == 0` or the equivalent of\n * `FIO_SET_HASH_COMPARE(pos->hash, FIO_SET_HASH_INVALID)`.\n */\n#define FIO_SET_FOR_LOOP(set, pos)\n#endif\n\n/* *****************************************************************************\nSet / Hash Map Internal Data Structures\n***************************************************************************** */\n\ntypedef struct FIO_NAME(_ordered_s_) {\n  FIO_SET_HASH_TYPE hash;\n  FIO_SET_TYPE obj;\n} FIO_NAME(_ordered_s_);\n\ntypedef struct FIO_NAME(_map_s_) {\n  FIO_SET_HASH_TYPE hash; /* another copy for memory cache locality */\n  FIO_NAME(_ordered_s_) * pos;\n} FIO_NAME(_map_s_);\n\n/* the information in the Hash Map structure should be considered READ ONLY. */\nstruct FIO_NAME(s) {\n  uintptr_t count;\n  uintptr_t capa;\n  uintptr_t pos;\n  FIO_NAME(_ordered_s_) * ordered;\n  FIO_NAME(_map_s_) * map;\n  uint8_t has_collisions;\n  uint8_t used_bits;\n  uint8_t under_attack;\n};\n\n#undef FIO_SET_FOR_LOOP\n#define FIO_SET_FOR_LOOP(set, container)                                       \\\n  for (__typeof__((set)->ordered) container = (set)->ordered;                  \\\n       container && (container < ((set)->ordered + (set)->pos)); ++container)\n\n/* *****************************************************************************\nSet / Hash Map Internal Helpers\n***************************************************************************** */\n\n/** Locates an object's map position in the Set, if it exists. */\nFIO_FUNC inline FIO_NAME(_map_s_) *\n    FIO_NAME(_find_map_pos_)(FIO_NAME(s) * set, FIO_SET_HASH_TYPE hash_value,\n                             FIO_SET_TYPE obj) {\n  if (FIO_SET_HASH_COMPARE(hash_value, FIO_SET_HASH_INVALID))\n    hash_value = FIO_SET_HASH_FORCE;\n  if (set->map) {\n    /* make sure collisions don't effect seeking */\n    if (set->has_collisions && set->pos != set->count) {\n      FIO_NAME(rehash)(set);\n    }\n    size_t full_collisions_counter = 0;\n    FIO_NAME(_map_s_) * pos;\n    /*\n     * Commonly, the hash is rotated, depending on it's state.\n     * Different bits are used for each mapping, instead of a single new bit.\n     */\n    const uintptr_t mask = (1ULL << set->used_bits) - 1;\n\n    uintptr_t i;\n    const uintptr_t hash_value_i = FIO_SET_HASH2UINTPTR(hash_value, 0);\n    uintptr_t hash_alt = FIO_SET_HASH2UINTPTR(hash_value, set->used_bits);\n\n    /* O(1) access to object */\n    pos = set->map + (hash_alt & mask);\n    if (FIO_SET_HASH_COMPARE(FIO_SET_HASH_INVALID, pos->hash))\n      return pos;\n    if (FIO_SET_HASH_COMPARE(pos->hash, hash_value_i)) {\n      if (!pos->pos || (FIO_SET_COMPARE(pos->pos->obj, obj)))\n        return pos;\n      /* full hash value collision detected */\n      set->has_collisions = 1;\n      ++full_collisions_counter;\n    }\n\n    /* Handle partial / full collisions with cuckoo steps O(x) access time */\n    i = 0;\n    const uintptr_t limit =\n        FIO_SET_CUCKOO_STEPS * (set->capa > (FIO_SET_MAX_MAP_SEEK << 2)\n                                    ? FIO_SET_MAX_MAP_SEEK\n                                    : (set->capa >> 2));\n    while (i < limit) {\n      i += FIO_SET_CUCKOO_STEPS;\n      pos = set->map + ((hash_alt + i) & mask);\n      if (FIO_SET_HASH_COMPARE(FIO_SET_HASH_INVALID, pos->hash))\n        return pos;\n      if (FIO_SET_HASH_COMPARE(pos->hash, hash_value_i)) {\n        if (!pos->pos || (FIO_SET_COMPARE(pos->pos->obj, obj)))\n          return pos;\n        /* full hash value collision detected */\n        set->has_collisions = 1;\n        if (++full_collisions_counter >= FIO_SET_MAX_MAP_FULL_COLLISIONS) {\n          /* is the hash under attack? */\n          FIO_LOG_WARNING(\n              \"(fio hash map) too many full collisions - under attack?\");\n          set->under_attack = 1;\n        }\n        if (set->under_attack) {\n          return pos;\n        }\n      }\n    }\n  }\n  return NULL;\n  (void)obj; /* in cases where FIO_SET_OBJ_COMPARE does nothing */\n}\n#undef FIO_SET_CUCKOO_STEPS\n\n/** Removes \"holes\" from the Set's internal Array - MUST re-hash afterwards.\n */\nFIO_FUNC inline void FIO_NAME(_compact_ordered_array_)(FIO_NAME(s) * set) {\n  if (set->count == set->pos)\n    return;\n  FIO_NAME(_ordered_s_) *reader = set->ordered;\n  FIO_NAME(_ordered_s_) *writer = set->ordered;\n  const FIO_NAME(_ordered_s_) *end = set->ordered + set->pos;\n  for (; reader && (reader < end); ++reader) {\n    if (FIO_SET_HASH_COMPARE(reader->hash, FIO_SET_HASH_INVALID)) {\n      continue;\n    }\n    *writer = *reader;\n    ++writer;\n  }\n  /* fix any possible counting errors as well as resetting position */\n  set->pos = set->count = (writer - set->ordered);\n}\n\n/** (Re)allocates the set's internal, invalidatint the mapping (must rehash) */\nFIO_FUNC inline void FIO_NAME(_reallocate_set_mem_)(FIO_NAME(s) * set) {\n  const uintptr_t new_capa = 1ULL << set->used_bits;\n  FIO_SET_FREE(set->map, set->capa * sizeof(*set->map));\n  set->map = (FIO_NAME(_map_s_) *)FIO_SET_CALLOC(sizeof(*set->map), new_capa);\n  set->ordered = (FIO_NAME(_ordered_s_) *)FIO_SET_REALLOC(\n      set->ordered, (set->capa * sizeof(*set->ordered)),\n      (new_capa * sizeof(*set->ordered)), (set->pos * sizeof(*set->ordered)));\n  if (!set->map || !set->ordered) {\n    perror(\"FATAL ERROR: couldn't allocate memory for Set data\");\n    exit(errno);\n  }\n  set->capa = new_capa;\n}\n\n/**\n * Inserts an object to the Set, rehashing if required, returning the new\n * object's pointer.\n *\n * If the object already exists in the set, it will be destroyed and\n * overwritten.\n */\nFIO_FUNC inline FIO_SET_TYPE\nFIO_NAME(_insert_or_overwrite_)(FIO_NAME(s) * set, FIO_SET_HASH_TYPE hash_value,\n                                FIO_SET_TYPE obj, int overwrite,\n                                FIO_SET_OBJ_TYPE *old) {\n  if (FIO_SET_HASH_COMPARE(hash_value, FIO_SET_HASH_INVALID))\n    hash_value = FIO_SET_HASH_FORCE;\n\n  /* automatic fragmentation protection */\n  if (FIO_NAME(is_fragmented)(set))\n    FIO_NAME(rehash)(set);\n  /* automatic capacity validation (we can never be at 100% capacity) */\n  else if (set->pos >= set->capa) {\n    ++set->used_bits;\n    FIO_NAME(rehash)(set);\n  }\n\n  /* locate future position */\n  FIO_NAME(_map_s_) *pos = FIO_NAME(_find_map_pos_)(set, hash_value, obj);\n\n  if (!pos) {\n    /* inserting a new object, with too many holes in the map */\n    FIO_SET_COPY(set->ordered[set->pos].obj, obj);\n    set->ordered[set->pos].hash = hash_value;\n    ++set->pos;\n    ++set->count;\n    FIO_NAME(rehash)(set);\n    return set->ordered[set->pos - 1].obj;\n  }\n\n  /* overwriting / new */\n  if (pos->pos) {\n    /* overwrite existing object */\n    if (!overwrite) {\n      FIO_SET_DESTROY(obj);\n      return pos->pos->obj;\n    }\n#ifdef FIO_SET_KEY_TYPE\n    if (old) {\n      FIO_SET_OBJ_COPY((*old), pos->pos->obj.obj);\n    }\n    /* no need to recreate the key object, just the value object */\n    FIO_SET_OBJ_DESTROY(pos->pos->obj.obj);\n    FIO_SET_OBJ_COPY(pos->pos->obj.obj, obj.obj);\n    return pos->pos->obj;\n#else\n    if (old) {\n      FIO_SET_COPY((*old), pos->pos->obj);\n    }\n    FIO_SET_DESTROY(pos->pos->obj);\n#endif\n  } else {\n    /* insert into new slot */\n    pos->pos = set->ordered + set->pos;\n    ++set->pos;\n    ++set->count;\n  }\n  /* store object at position */\n  pos->hash = hash_value;\n  pos->pos->hash = hash_value;\n  FIO_SET_COPY(pos->pos->obj, obj);\n\n  return pos->pos->obj;\n}\n\n/* *****************************************************************************\nSet / Hash Map Implementation\n***************************************************************************** */\n\n/** Frees all the objects in the set and deallocates any internal resources. */\nFIO_FUNC void FIO_NAME_FREE()(FIO_NAME(s) * s) {\n  /* destroy existing valid objects */\n  const FIO_NAME(_ordered_s_) *const end = s->ordered + s->pos;\n  if (s->ordered && s->ordered != end) {\n    for (FIO_NAME(_ordered_s_) *pos = s->ordered; pos < end; ++pos) {\n      if (!FIO_SET_HASH_COMPARE(FIO_SET_HASH_INVALID, pos->hash)) {\n        FIO_SET_DESTROY(pos->obj);\n      }\n    }\n  }\n  /* free ordered array and hash mapping */\n  FIO_SET_FREE(s->map, s->capa * sizeof(*s->map));\n  FIO_SET_FREE(s->ordered, s->capa * sizeof(*s->ordered));\n  *s = (FIO_NAME(s)){.map = NULL};\n}\n\n#ifdef FIO_SET_KEY_TYPE\n\n/* Hash Map unique implementation */\n\n/**\n * Locates an object in the Set, if it exists.\n *\n * NOTE: This is the function's Hash Map variant. See FIO_SET_KEY_TYPE.\n */\nFIO_FUNC FIO_SET_OBJ_TYPE FIO_NAME(find)(FIO_NAME(s) * set,\n                                         const FIO_SET_HASH_TYPE hash_value,\n                                         FIO_SET_KEY_TYPE key) {\n  FIO_NAME(_map_s_) *pos =\n      FIO_NAME(_find_map_pos_)(set, hash_value, (FIO_SET_TYPE){.key = key});\n  if (!pos || !pos->pos) {\n    FIO_SET_OBJ_TYPE empty;\n    memset(&empty, 0, sizeof(empty));\n    return empty;\n  }\n  return pos->pos->obj.obj;\n}\n\n/**\n * Inserts an object to the Hash Map, rehashing if required, returning the new\n * object's location using a pointer.\n *\n * If an object already exists in the Hash Map, it will be destroyed.\n *\n * If `old` is set, the existing object (if any) will be copied to the location\n * pointed to by `old` before it is destroyed.\n *\n * NOTE: This is the function's Hash Map variant. See FIO_SET_KEY_TYPE.\n */\nFIO_FUNC void FIO_NAME(insert)(FIO_NAME(s) * set,\n                               const FIO_SET_HASH_TYPE hash_value,\n                               FIO_SET_KEY_TYPE key, FIO_SET_OBJ_TYPE obj,\n                               FIO_SET_OBJ_TYPE *old) {\n  FIO_NAME(_insert_or_overwrite_)\n  (set, hash_value, (FIO_SET_TYPE){.key = key, .obj = obj}, 1, old);\n}\n\n/**\n * Removes an object from the Hash Map, rehashing if required.\n *\n * Returns 0 on success and -1 if the object wasn't found.\n *\n * If `old` is set, the existing object (if any) will be copied to the location\n * pointed to by `old`.\n *\n * NOTE: This is the function's Hash Map variant. See FIO_SET_KEY_TYPE.\n */\nFIO_FUNC inline int FIO_NAME(remove)(FIO_NAME(s) * set,\n                                     const FIO_SET_HASH_TYPE hash_value,\n                                     FIO_SET_KEY_TYPE key,\n                                     FIO_SET_OBJ_TYPE *old) {\n  FIO_NAME(_map_s_) *pos =\n      FIO_NAME(_find_map_pos_)(set, hash_value, (FIO_SET_TYPE){.key = key});\n  if (!pos || !pos->pos)\n    return -1;\n  if (old)\n    FIO_SET_OBJ_COPY((*old), pos->pos->obj.obj);\n  FIO_SET_DESTROY(pos->pos->obj);\n  --set->count;\n  pos->pos->hash = FIO_SET_HASH_INVALID;\n  if (pos->pos == set->pos + set->ordered - 1) {\n    /* removing last item inserted */\n    pos->hash = FIO_SET_HASH_INVALID; /* no need for a \"hole\" */\n    do {\n      --set->pos;\n    } while (set->pos && FIO_SET_HASH_COMPARE(set->ordered[set->pos - 1].hash,\n                                              FIO_SET_HASH_INVALID));\n  }\n  pos->pos = NULL; /* leave pos->hash set to mark \"hole\" */\n  return 0;\n}\n\n#else /* FIO_SET_KEY_TYPE */\n\n/* Set unique implementation */\n\n/** Locates an object in the Set, if it exists. */\nFIO_FUNC FIO_SET_OBJ_TYPE FIO_NAME(find)(FIO_NAME(s) * set,\n                                         const FIO_SET_HASH_TYPE hash_value,\n                                         FIO_SET_OBJ_TYPE obj) {\n  FIO_NAME(_map_s_) *pos = FIO_NAME(_find_map_pos_)(set, hash_value, obj);\n  if (!pos || !pos->pos) {\n    FIO_SET_OBJ_TYPE empty;\n    memset(&empty, 0, sizeof(empty));\n    return empty;\n  }\n  return pos->pos->obj;\n}\n\n/**\n * Inserts an object to the Set, rehashing if required, returning the new\n * object's pointer.\n *\n * If the object already exists in the set, than the new object will be\n * destroyed and the old object's address will be returned.\n */\nFIO_FUNC FIO_SET_OBJ_TYPE FIO_NAME(insert)(FIO_NAME(s) * set,\n                                           const FIO_SET_HASH_TYPE hash_value,\n                                           FIO_SET_OBJ_TYPE obj) {\n  return FIO_NAME(_insert_or_overwrite_)(set, hash_value, obj, 0, NULL);\n}\n\n/**\n * Inserts an object to the Set, rehashing if required, returning the new\n * object's pointer.\n *\n * If the object already exists in the set, it will be destroyed and\n * overwritten.\n *\n * When setting `old` to NULL, the function behaves the same as `overwrite`.\n */\nFIO_FUNC FIO_SET_OBJ_TYPE\nFIO_NAME(overwrite)(FIO_NAME(s) * set, const FIO_SET_HASH_TYPE hash_value,\n                    FIO_SET_OBJ_TYPE obj, FIO_SET_OBJ_TYPE *old) {\n  return FIO_NAME(_insert_or_overwrite_)(set, hash_value, obj, 1, old);\n}\n\n/**\n * Removes an object from the Set, rehashing if required.\n */\nFIO_FUNC int FIO_NAME(remove)(FIO_NAME(s) * set,\n                              const FIO_SET_HASH_TYPE hash_value,\n                              FIO_SET_OBJ_TYPE obj, FIO_SET_OBJ_TYPE *old) {\n  if (FIO_SET_HASH_COMPARE(hash_value, FIO_SET_HASH_INVALID))\n    return -1;\n  FIO_NAME(_map_s_) *pos = FIO_NAME(_find_map_pos_)(set, hash_value, obj);\n  if (!pos || !pos->pos)\n    return -1;\n  if (old)\n    FIO_SET_COPY((*old), pos->pos->obj);\n  FIO_SET_DESTROY(pos->pos->obj);\n  --set->count;\n  pos->pos->hash = FIO_SET_HASH_INVALID;\n  if (pos->pos == set->pos + set->ordered - 1) {\n    /* removing last item inserted */\n    pos->hash = FIO_SET_HASH_INVALID; /* no need for a \"hole\" */\n    do {\n      --set->pos;\n    } while (set->pos && FIO_SET_HASH_COMPARE(set->ordered[set->pos - 1].hash,\n                                              FIO_SET_HASH_INVALID));\n  }\n  pos->pos = NULL; /* leave pos->hash set to mark \"hole\" */\n  return 0;\n}\n\n#endif\n\n/**\n * Allows a peak at the Set's last element.\n *\n * Remember that objects might be destroyed if the Set is altered\n * (`FIO_SET_OBJ_DESTROY` / `FIO_SET_KEY_DESTROY`).\n */\nFIO_FUNC inline FIO_SET_TYPE FIO_NAME(last)(FIO_NAME(s) * set) {\n  if (!set->ordered || !set->pos) {\n    FIO_SET_TYPE empty;\n    memset(&empty, 0, sizeof(empty));\n    return empty;\n  }\n  return set->ordered[set->pos - 1].obj;\n}\n\n/**\n * Allows the Hash to be momentarily used as a stack, destroying the last\n * object added (`FIO_SET_OBJ_DESTROY` / `FIO_SET_KEY_DESTROY`).\n */\nFIO_FUNC void FIO_NAME(pop)(FIO_NAME(s) * set) {\n  if (!set->ordered || !set->pos)\n    return;\n  FIO_SET_DESTROY(set->ordered[set->pos - 1].obj);\n  set->ordered[set->pos - 1].hash = FIO_SET_HASH_INVALID;\n  --(set->count);\n  do {\n    --(set->pos);\n  } while (set->pos && FIO_SET_HASH_COMPARE(set->ordered[set->pos - 1].hash,\n                                            FIO_SET_HASH_INVALID));\n}\n\n/** Returns the number of objects currently in the Set. */\nFIO_FUNC inline size_t FIO_NAME(count)(const FIO_NAME(s) * set) {\n  return (size_t)set->count;\n}\n\n/**\n * Returns a temporary theoretical Set capacity.\n * This could be used for testing performance and memory consumption.\n */\nFIO_FUNC inline size_t FIO_NAME(capa)(const FIO_NAME(s) * set) {\n  return (size_t)set->capa;\n}\n\n/**\n * Requires that a Set contains the minimal requested theoretical capacity.\n *\n * Returns the actual (temporary) theoretical capacity.\n */\nFIO_FUNC inline size_t FIO_NAME(capa_require)(FIO_NAME(s) * set,\n                                              size_t min_capa) {\n  if (min_capa <= FIO_NAME(capa)(set))\n    return FIO_NAME(capa)(set);\n  set->used_bits = 2;\n  while (min_capa > (1ULL << set->used_bits)) {\n    ++set->used_bits;\n  }\n  FIO_NAME(rehash)(set);\n  return FIO_NAME(capa)(set);\n}\n\n/**\n * Returns non-zero if the Set is fragmented (more than 50% holes).\n */\nFIO_FUNC inline size_t FIO_NAME(is_fragmented)(const FIO_NAME(s) * set) {\n  return ((set->pos - set->count) > (set->count >> 1));\n}\n\n/**\n * Attempts to minimize memory usage by removing empty spaces caused by deleted\n * items and rehashing the Set.\n *\n * Returns the updated Set capacity.\n */\nFIO_FUNC inline size_t FIO_NAME(compact)(FIO_NAME(s) * set) {\n  FIO_NAME(_compact_ordered_array_)(set);\n  set->used_bits = 2;\n  while (set->count >= (1ULL << set->used_bits)) {\n    ++set->used_bits;\n  }\n  FIO_NAME(rehash)(set);\n  return FIO_NAME(capa)(set);\n}\n\n/** Forces a rehashing of the Set. */\nFIO_FUNC void FIO_NAME(rehash)(FIO_NAME(s) * set) {\n  FIO_NAME(_compact_ordered_array_)(set);\n  set->has_collisions = 0;\n  uint8_t attempts = 0;\nrestart:\n  if (set->used_bits >= 16 && ++attempts >= 3 && set->has_collisions) {\n    FIO_LOG_FATAL(\n        \"facil.io Set / Hash Map has too many collisions (%zu/%zu).\"\n        \"\\n\\t\\tthis is a fatal implementation error,\"\n        \"please report this issue at facio.io's open source project\"\n        \"\\n\\t\\tNote: hash maps and sets should never reach this point.\"\n        \"\\n\\t\\tThey should be guarded against collision attacks.\",\n        set->pos, set->capa);\n    exit(-1);\n  }\n  FIO_NAME(_reallocate_set_mem_)(set);\n  {\n    FIO_NAME(_ordered_s_) const *const end = set->ordered + set->pos;\n    for (FIO_NAME(_ordered_s_) *pos = set->ordered; pos < end; ++pos) {\n      FIO_NAME(_map_s_) *mp =\n          FIO_NAME(_find_map_pos_)(set, pos->hash, pos->obj);\n      if (!mp) {\n        ++set->used_bits;\n        goto restart;\n      }\n      mp->pos = pos;\n      mp->hash = pos->hash;\n    }\n  }\n}\n\n#undef FIO_SET_OBJ_TYPE\n#undef FIO_SET_OBJ_COMPARE\n#undef FIO_SET_OBJ_COPY\n#undef FIO_SET_OBJ_DESTROY\n#undef FIO_SET_HASH_TYPE\n#undef FIO_SET_HASH2UINTPTR\n#undef FIO_SET_HASH_COMPARE\n#undef FIO_SET_HASH_INVALID\n#undef FIO_SET_KEY_TYPE\n#undef FIO_SET_KEY_COPY\n#undef FIO_SET_KEY_DESTROY\n#undef FIO_SET_KEY_COMPARE\n#undef FIO_SET_TYPE\n#undef FIO_SET_COMPARE\n#undef FIO_SET_COPY\n#undef FIO_SET_DESTROY\n#undef FIO_SET_MAX_MAP_SEEK\n#undef FIO_SET_MAX_MAP_FULL_COLLISIONS\n#undef FIO_SET_REALLOC\n#undef FIO_SET_CALLOC\n#undef FIO_SET_FREE\n#undef FIO_NAME\n#undef FIO_NAME_FROM_MACRO_STEP2\n#undef FIO_NAME_FROM_MACRO_STEP1\n#undef FIO_NAME_FROM_MACRO_STEP4\n#undef FIO_NAME_FROM_MACRO_STEP3\n#undef FIO_NAME_FREE\n#undef FIO_SET_NAME\n#undef FIO_FORCE_MALLOC_TMP\n\n#endif\n", "/*\nCopyright: Boaz segev, 2017\nLicense: MIT\n\nFeel free to copy, use and enjoy according to the license provided.\n*/\n#include <fio.h>\n\n#include <fio_cli.h>\n\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <strings.h>\n\n/* *****************************************************************************\nCLI Data Stores\n***************************************************************************** */\n\ntypedef struct {\n  size_t len;\n  const char *data;\n} cstr_s;\n\n#define FIO_SET_OBJ_TYPE const char *\n#define FIO_SET_KEY_TYPE cstr_s\n#define FIO_SET_KEY_COMPARE(o1, o2)                                            \\\n  (o1.len == o2.len &&                                                         \\\n   (o1.data == o2.data || !memcmp(o1.data, o2.data, o1.len)))\n#define FIO_SET_NAME fio_cli_hash\n#include <fio.h>\n\nstatic fio_cli_hash_s fio_aliases = FIO_SET_INIT;\nstatic fio_cli_hash_s fio_values = FIO_SET_INIT;\nstatic size_t fio_unnamed_count = 0;\n\ntypedef struct {\n  int unnamed_min;\n  int unnamed_max;\n  int pos;\n  int unnamed_count;\n  int argc;\n  char const **argv;\n  char const *description;\n  char const **names;\n} fio_cli_parser_data_s;\n\n/** this will allow the function definition fio_cli_start to avoid the MACRO */\n#define AVOID_MACRO\n\n#define FIO_CLI_HASH_VAL(s)                                                    \\\n  fio_risky_hash((s).data, (s).len, (uint64_t)fio_cli_start)\n\n/* *****************************************************************************\nCLI Parsing\n***************************************************************************** */\n\n/* *****************************************************************************\nCLI Parsing\n***************************************************************************** */\n\nstatic void fio_cli_map_line2alias(char const *line) {\n  cstr_s n = {.data = line};\n  while (n.data[0] == '-') {\n    while (n.data[n.len] && n.data[n.len] != ' ' && n.data[n.len] != ',') {\n      ++n.len;\n    }\n    const char *old = NULL;\n    fio_cli_hash_insert(&fio_aliases, FIO_CLI_HASH_VAL(n), n, (void *)line,\n                        &old);\n    if (old) {\n      FIO_LOG_WARNING(\"CLI argument name conflict detected\\n\"\n                      \"         The following two directives conflict:\\n\"\n                      \"\\t%s\\n\\t%s\\n\",\n                      old, line);\n    }\n\n    while (n.data[n.len] && (n.data[n.len] == ' ' || n.data[n.len] == ',')) {\n      ++n.len;\n    }\n    n.data += n.len;\n    n.len = 0;\n  }\n}\n\nstatic char const *fio_cli_get_line_type(fio_cli_parser_data_s *parser,\n                                         const char *line) {\n  if (!line) {\n    return NULL;\n  }\n  char const **pos = parser->names;\n  while (*pos) {\n    switch ((intptr_t)*pos) {\n    case FIO_CLI_STRING__TYPE_I:       /* fallthrough */\n    case FIO_CLI_BOOL__TYPE_I:         /* fallthrough */\n    case FIO_CLI_INT__TYPE_I:          /* fallthrough */\n    case FIO_CLI_PRINT__TYPE_I:        /* fallthrough */\n    case FIO_CLI_PRINT_HEADER__TYPE_I: /* fallthrough */\n      ++pos;\n      continue;\n    }\n    if (line == *pos) {\n      goto found;\n    }\n    ++pos;\n  }\n  return NULL;\nfound:\n  switch ((size_t)pos[1]) {\n  case FIO_CLI_STRING__TYPE_I:       /* fallthrough */\n  case FIO_CLI_BOOL__TYPE_I:         /* fallthrough */\n  case FIO_CLI_INT__TYPE_I:          /* fallthrough */\n  case FIO_CLI_PRINT__TYPE_I:        /* fallthrough */\n  case FIO_CLI_PRINT_HEADER__TYPE_I: /* fallthrough */\n    return pos[1];\n  }\n  return NULL;\n}\n\nstatic void fio_cli_set_arg(cstr_s arg, char const *value, char const *line,\n                            fio_cli_parser_data_s *parser) {\n  /* handle unnamed argument */\n  if (!line || !arg.len) {\n    if (!value) {\n      goto print_help;\n    }\n    if (!strcmp(value, \"-?\") || !strcasecmp(value, \"-h\") ||\n        !strcasecmp(value, \"-help\") || !strcasecmp(value, \"--help\")) {\n      goto print_help;\n    }\n    cstr_s n = {.len = ++parser->unnamed_count};\n    fio_cli_hash_insert(&fio_values, n.len, n, value, NULL);\n    if (parser->unnamed_max >= 0 &&\n        parser->unnamed_count > parser->unnamed_max) {\n      arg.len = 0;\n      goto error;\n    }\n    return;\n  }\n\n  /* validate data types */\n  char const *type = fio_cli_get_line_type(parser, line);\n  switch ((size_t)type) {\n  case FIO_CLI_BOOL__TYPE_I:\n    if (value && value != parser->argv[parser->pos + 1]) {\n      goto error;\n    }\n    value = \"1\";\n    break;\n  case FIO_CLI_INT__TYPE_I:\n    if (value) {\n      char const *tmp = value;\n      fio_atol((char **)&tmp);\n      if (*tmp) {\n        goto error;\n      }\n    }\n    /* fallthrough */\n  case FIO_CLI_STRING__TYPE_I:\n    if (!value)\n      goto error;\n    if (!value[0])\n      goto finish;\n    break;\n  }\n\n  /* add values using all aliases possible */\n  {\n    cstr_s n = {.data = line};\n    while (n.data[0] == '-') {\n      while (n.data[n.len] && n.data[n.len] != ' ' && n.data[n.len] != ',') {\n        ++n.len;\n      }\n      fio_cli_hash_insert(&fio_values, FIO_CLI_HASH_VAL(n), n, value, NULL);\n      while (n.data[n.len] && (n.data[n.len] == ' ' || n.data[n.len] == ',')) {\n        ++n.len;\n      }\n      n.data += n.len;\n      n.len = 0;\n    }\n  }\n\nfinish:\n\n  /* handle additional argv progress (if value is on separate argv) */\n  if (value && parser->pos < parser->argc &&\n      value == parser->argv[parser->pos + 1])\n    ++parser->pos;\n  return;\n\nerror: /* handle errors*/\n  /* TODO! */\n  fprintf(stderr, \"\\n\\r\\x1B[31mError:\\x1B[0m unknown argument %.*s %s %s\\n\\n\",\n          (int)arg.len, arg.data, arg.len ? \"with value\" : \"\",\n          value ? (value[0] ? value : \"(empty)\") : \"(null)\");\nprint_help:\n  fprintf(stderr, \"\\n%s\\n\",\n          parser->description ? parser->description\n                              : \"This application accepts any of the following \"\n                                \"possible arguments:\");\n  /* print out each line's arguments */\n  char const **pos = parser->names;\n  while (*pos) {\n    switch ((intptr_t)*pos) {\n    case FIO_CLI_STRING__TYPE_I: /* fallthrough */\n    case FIO_CLI_BOOL__TYPE_I:   /* fallthrough */\n    case FIO_CLI_INT__TYPE_I:    /* fallthrough */\n    case FIO_CLI_PRINT__TYPE_I:  /* fallthrough */\n    case FIO_CLI_PRINT_HEADER__TYPE_I:\n      ++pos;\n      continue;\n    }\n    type = (char *)FIO_CLI_STRING__TYPE_I;\n    switch ((intptr_t)pos[1]) {\n    case FIO_CLI_PRINT__TYPE_I:\n      fprintf(stderr, \"%s\\n\", pos[0]);\n      pos += 2;\n      continue;\n    case FIO_CLI_PRINT_HEADER__TYPE_I:\n      fprintf(stderr, \"\\n\\x1B[4m%s\\x1B[0m\\n\", pos[0]);\n      pos += 2;\n      continue;\n\n    case FIO_CLI_STRING__TYPE_I: /* fallthrough */\n    case FIO_CLI_BOOL__TYPE_I:   /* fallthrough */\n    case FIO_CLI_INT__TYPE_I:    /* fallthrough */\n      type = pos[1];\n    }\n    /* print line @ pos, starting with main argument name */\n    int alias_count = 0;\n    int first_len = 0;\n    size_t tmp = 0;\n    char const *const p = *pos;\n    while (p[tmp] == '-') {\n      while (p[tmp] && p[tmp] != ' ' && p[tmp] != ',') {\n        if (!alias_count)\n          ++first_len;\n        ++tmp;\n      }\n      ++alias_count;\n      while (p[tmp] && (p[tmp] == ' ' || p[tmp] == ',')) {\n        ++tmp;\n      }\n    }\n    switch ((size_t)type) {\n    case FIO_CLI_STRING__TYPE_I:\n      fprintf(stderr, \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m <>\\x1B[0m\\t%s\\n\", first_len,\n              p, p + tmp);\n      break;\n    case FIO_CLI_BOOL__TYPE_I:\n      fprintf(stderr, \" \\x1B[1m%.*s\\x1B[0m   \\t%s\\n\", first_len, p, p + tmp);\n      break;\n    case FIO_CLI_INT__TYPE_I:\n      fprintf(stderr, \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m ##\\x1B[0m\\t%s\\n\", first_len,\n              p, p + tmp);\n      break;\n    }\n    /* print aliase information */\n    tmp = first_len;\n    while (p[tmp] && (p[tmp] == ' ' || p[tmp] == ',')) {\n      ++tmp;\n    }\n    while (p[tmp] == '-') {\n      const size_t start = tmp;\n      while (p[tmp] && p[tmp] != ' ' && p[tmp] != ',') {\n        ++tmp;\n      }\n      int padding = first_len - (tmp - start);\n      if (padding < 0)\n        padding = 0;\n      switch ((size_t)type) {\n      case FIO_CLI_STRING__TYPE_I:\n        fprintf(stderr,\n                \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m <>\\x1B[0m%*s\\t(same as \"\n                \"\\x1B[1m%.*s\\x1B[0m)\\n\",\n                (int)(tmp - start), p + start, padding, \"\", first_len, p);\n        break;\n      case FIO_CLI_BOOL__TYPE_I:\n        fprintf(stderr,\n                \" \\x1B[1m%.*s\\x1B[0m   %*s\\t(same as \\x1B[1m%.*s\\x1B[0m)\\n\",\n                (int)(tmp - start), p + start, padding, \"\", first_len, p);\n        break;\n      case FIO_CLI_INT__TYPE_I:\n        fprintf(stderr,\n                \" \\x1B[1m%.*s\\x1B[0m\\x1B[2m ##\\x1B[0m%*s\\t(same as \"\n                \"\\x1B[1m%.*s\\x1B[0m)\\n\",\n                (int)(tmp - start), p + start, padding, \"\", first_len, p);\n        break;\n      }\n    }\n\n    ++pos;\n  }\n  fprintf(stderr, \"\\nUse any of the following input formats:\\n\"\n                  \"\\t-arg <value>\\t-arg=<value>\\t-arg<value>\\n\"\n                  \"\\n\"\n                  \"Use the -h, -help or -? to get this information again.\\n\"\n                  \"\\n\");\n  fio_cli_end();\n  exit(0);\n}\n\nstatic void fio_cli_end_promise(void *ignr_) {\n  /* make sure fio_cli_end is called before facil.io exists. */\n  fio_cli_end();\n  (void)ignr_;\n}\n\nvoid fio_cli_start AVOID_MACRO(int argc, char const *argv[], int unnamed_min,\n                               int unnamed_max, char const *description,\n                               char const **names) {\n  static fio_lock_i run_once = FIO_LOCK_INIT;\n  if (!fio_trylock(&run_once))\n    fio_state_callback_add(FIO_CALL_AT_EXIT, fio_cli_end_promise, NULL);\n  if (unnamed_max >= 0 && unnamed_max < unnamed_min)\n    unnamed_max = unnamed_min;\n  fio_cli_parser_data_s parser = {\n      .unnamed_min = unnamed_min,\n      .unnamed_max = unnamed_max,\n      .description = description,\n      .argc = argc,\n      .argv = argv,\n      .names = names,\n      .pos = 0,\n  };\n\n  if (fio_cli_hash_count(&fio_values)) {\n    fio_cli_end();\n  }\n\n  /* prepare aliases hash map */\n\n  char const **line = names;\n  while (*line) {\n    switch ((intptr_t)*line) {\n    case FIO_CLI_STRING__TYPE_I:       /* fallthrough */\n    case FIO_CLI_BOOL__TYPE_I:         /* fallthrough */\n    case FIO_CLI_INT__TYPE_I:          /* fallthrough */\n    case FIO_CLI_PRINT__TYPE_I:        /* fallthrough */\n    case FIO_CLI_PRINT_HEADER__TYPE_I: /* fallthrough */\n      ++line;\n      continue;\n    }\n    if (line[1] != (char *)FIO_CLI_PRINT__TYPE_I &&\n        line[1] != (char *)FIO_CLI_PRINT_HEADER__TYPE_I)\n      fio_cli_map_line2alias(*line);\n    ++line;\n  }\n\n  /* parse existing arguments */\n\n  while ((++parser.pos) < argc) {\n    char const *value = NULL;\n    cstr_s n = {.data = argv[parser.pos], .len = strlen(argv[parser.pos])};\n    if (parser.pos + 1 < argc) {\n      value = argv[parser.pos + 1];\n    }\n    const char *l = NULL;\n    while (n.len &&\n           !(l = fio_cli_hash_find(&fio_aliases, FIO_CLI_HASH_VAL(n), n))) {\n      --n.len;\n      value = n.data + n.len;\n    }\n    if (n.len && value && value[0] == '=') {\n      ++value;\n    }\n    // fprintf(stderr, \"Setting %.*s to %s\\n\", (int)n.len, n.data, value);\n    fio_cli_set_arg(n, value, l, &parser);\n  }\n\n  /* Cleanup and save state for API */\n  fio_cli_hash_free(&fio_aliases);\n  fio_unnamed_count = parser.unnamed_count;\n  /* test for required unnamed arguments */\n  if (parser.unnamed_count < parser.unnamed_min)\n    fio_cli_set_arg((cstr_s){.len = 0}, NULL, NULL, &parser);\n}\n\nvoid fio_cli_end(void) {\n  fio_cli_hash_free(&fio_values);\n  fio_cli_hash_free(&fio_aliases);\n  fio_unnamed_count = 0;\n}\n/* *****************************************************************************\nCLI Data Access\n***************************************************************************** */\n\n/** Returns the argument's value as a NUL terminated C String. */\nchar const *fio_cli_get(char const *name) {\n  cstr_s n = {.data = name, .len = strlen(name)};\n  if (!fio_cli_hash_count(&fio_values)) {\n    return NULL;\n  }\n  char const *val = fio_cli_hash_find(&fio_values, FIO_CLI_HASH_VAL(n), n);\n  return val;\n}\n\n/** Returns the argument's value as an integer. */\nint fio_cli_get_i(char const *name) {\n  char const *val = fio_cli_get(name);\n  if (!val)\n    return 0;\n  int i = (int)fio_atol((char **)&val);\n  return i;\n}\n\n/** Returns the number of unrecognized argument. */\nunsigned int fio_cli_unnamed_count(void) {\n  return (unsigned int)fio_unnamed_count;\n}\n\n/** Returns the unrecognized argument using a 0 based `index`. */\nchar const *fio_cli_unnamed(unsigned int index) {\n  if (!fio_cli_hash_count(&fio_values) || !fio_unnamed_count) {\n    return NULL;\n  }\n  cstr_s n = {.data = NULL, .len = index + 1};\n  return fio_cli_hash_find(&fio_values, index + 1, n);\n}\n\n/**\n * Sets the argument's value as a NUL terminated C String (no copy!).\n *\n * Note: this does NOT copy the C strings to memory. Memory should be kept\n * alive until `fio_cli_end` is called.\n */\nvoid fio_cli_set(char const *name, char const *value) {\n  cstr_s n = (cstr_s){.data = name, .len = strlen(name)};\n  fio_cli_hash_insert(&fio_values, FIO_CLI_HASH_VAL(n), n, value, NULL);\n}\n", "/*\nCopyright: Boaz Segev, 2018-2019\nLicense: MIT\n\nFeel free to copy, use and enjoy according to the license provided.\n*/\n#include <fio.h>\n\n/**\n * This implementation of the facil.io SSL/TLS wrapper API is the default\n * implementation that will be used when no SSL/TLS library is available...\n *\n * ... without modification, this implementation crashes the program.\n *\n * The implementation can be USED AS A TEMPLATE for future implementations.\n *\n * This implementation is optimized for ease of development rather than memory\n * consumption.\n */\n#include \"fio_tls.h\"\n\n#if !defined(FIO_TLS_FOUND) /* Library compiler flags */\n\n#define REQUIRE_LIBRARY()\n#define FIO_TLS_WEAK\n\n/* TODO: delete me! */\n#undef FIO_TLS_WEAK\n#define FIO_TLS_WEAK __attribute__((weak))\n#if !FIO_IGNORE_TLS_IF_MISSING\n#undef REQUIRE_LIBRARY\n#define REQUIRE_LIBRARY()                                                      \\\n  FIO_LOG_FATAL(\"No supported SSL/TLS library available.\");                    \\\n  exit(-1);\n#endif\n/* STOP deleting after this line */\n\n/* *****************************************************************************\nThe SSL/TLS helper data types (can be left as is)\n***************************************************************************** */\n#define FIO_INCLUDE_STR 1\n#define FIO_FORCE_MALLOC_TMP 1\n#include <fio.h>\n\ntypedef struct {\n  fio_str_s private_key;\n  fio_str_s public_key;\n  fio_str_s password;\n} cert_s;\n\nstatic inline int fio_tls_cert_cmp(const cert_s *dest, const cert_s *src) {\n  return fio_str_iseq(&dest->private_key, &src->private_key);\n}\nstatic inline void fio_tls_cert_copy(cert_s *dest, cert_s *src) {\n  *dest = (cert_s){\n      .private_key = FIO_STR_INIT,\n      .public_key = FIO_STR_INIT,\n      .password = FIO_STR_INIT,\n  };\n  fio_str_concat(&dest->private_key, &src->private_key);\n  fio_str_concat(&dest->public_key, &src->public_key);\n  fio_str_concat(&dest->password, &src->password);\n}\nstatic inline void fio_tls_cert_destroy(cert_s *obj) {\n  fio_str_free(&obj->private_key);\n  fio_str_free(&obj->public_key);\n  fio_str_free(&obj->password);\n}\n\n#define FIO_ARY_NAME cert_ary\n#define FIO_ARY_TYPE cert_s\n#define FIO_ARY_COMPARE(k1, k2) (fio_tls_cert_cmp(&(k1), &(k2)))\n#define FIO_ARY_COPY(dest, obj) fio_tls_cert_copy(&(dest), &(obj))\n#define FIO_ARY_DESTROY(key) fio_tls_cert_destroy(&(key))\n#define FIO_FORCE_MALLOC_TMP 1\n#include <fio.h>\n\ntypedef struct {\n  fio_str_s pem;\n} trust_s;\n\nstatic inline int fio_tls_trust_cmp(const trust_s *dest, const trust_s *src) {\n  return fio_str_iseq(&dest->pem, &src->pem);\n}\nstatic inline void fio_tls_trust_copy(trust_s *dest, trust_s *src) {\n  *dest = (trust_s){\n      .pem = FIO_STR_INIT,\n  };\n  fio_str_concat(&dest->pem, &src->pem);\n}\nstatic inline void fio_tls_trust_destroy(trust_s *obj) {\n  fio_str_free(&obj->pem);\n}\n\n#define FIO_ARY_NAME trust_ary\n#define FIO_ARY_TYPE trust_s\n#define FIO_ARY_COMPARE(k1, k2) (fio_tls_trust_cmp(&(k1), &(k2)))\n#define FIO_ARY_COPY(dest, obj) fio_tls_trust_copy(&(dest), &(obj))\n#define FIO_ARY_DESTROY(key) fio_tls_trust_destroy(&(key))\n#define FIO_FORCE_MALLOC_TMP 1\n#include <fio.h>\n\ntypedef struct {\n  fio_str_s name; /* fio_str_s provides cache locality for small strings */\n  void (*on_selected)(intptr_t uuid, void *udata_connection, void *udata_tls);\n  void *udata_tls;\n  void (*on_cleanup)(void *udata_tls);\n} alpn_s;\n\nstatic inline int fio_alpn_cmp(const alpn_s *dest, const alpn_s *src) {\n  return fio_str_iseq(&dest->name, &src->name);\n}\nstatic inline void fio_alpn_copy(alpn_s *dest, alpn_s *src) {\n  *dest = (alpn_s){\n      .name = FIO_STR_INIT,\n      .on_selected = src->on_selected,\n      .udata_tls = src->udata_tls,\n      .on_cleanup = src->on_cleanup,\n  };\n  fio_str_concat(&dest->name, &src->name);\n}\nstatic inline void fio_alpn_destroy(alpn_s *obj) {\n  if (obj->on_cleanup)\n    obj->on_cleanup(obj->udata_tls);\n  fio_str_free(&obj->name);\n}\n\n#define FIO_SET_NAME alpn_list\n#define FIO_SET_OBJ_TYPE alpn_s\n#define FIO_SET_OBJ_COMPARE(k1, k2) fio_alpn_cmp(&(k1), &(k2))\n#define FIO_SET_OBJ_COPY(dest, obj) fio_alpn_copy(&(dest), &(obj))\n#define FIO_SET_OBJ_DESTROY(key) fio_alpn_destroy(&(key))\n#define FIO_FORCE_MALLOC_TMP 1\n#include <fio.h>\n\n/* *****************************************************************************\nThe SSL/TLS Context type\n***************************************************************************** */\n\n/** An opaque type used for the SSL/TLS functions. */\nstruct fio_tls_s {\n  size_t ref;       /* Reference counter, to guards the ALPN registry */\n  alpn_list_s alpn; /* ALPN is the name for the protocol selection extension */\n\n  /*** the next two components could be optimized away with tweaking stuff ***/\n\n  cert_ary_s sni;    /* SNI (server name extension) stores ID certificates */\n  trust_ary_s trust; /* Trusted certificate registry (peer verification) */\n\n  /************ TODO: implementation data fields go here ******************/\n};\n\n/* *****************************************************************************\nALPN Helpers\n***************************************************************************** */\n\n/** Returns a pointer to the ALPN data (callback, etc') IF exists in the TLS. */\nFIO_FUNC inline alpn_s *alpn_find(fio_tls_s *tls, char *name, size_t len) {\n  alpn_s tmp = {.name = FIO_STR_INIT_STATIC2(name, len)};\n  alpn_list__map_s_ *pos =\n      alpn_list__find_map_pos_(&tls->alpn, fio_str_hash(&tmp.name), tmp);\n  if (!pos || !pos->pos)\n    return NULL;\n  return &pos->pos->obj;\n}\n\n/** Adds an ALPN data object to the ALPN \"list\" (set) */\nFIO_FUNC inline void alpn_add(\n    fio_tls_s *tls, const char *protocol_name,\n    void (*on_selected)(intptr_t uuid, void *udata_connection, void *udata_tls),\n    void *udata_tls, void (*on_cleanup)(void *udata_tls)) {\n  alpn_s tmp = {\n      .name = FIO_STR_INIT_STATIC(protocol_name),\n      .on_selected = on_selected,\n      .udata_tls = udata_tls,\n      .on_cleanup = on_cleanup,\n  };\n  if (fio_str_len(&tmp.name) > 255) {\n    FIO_LOG_ERROR(\"ALPN protocol names are limited to 255 bytes.\");\n    return;\n  }\n  alpn_list_overwrite(&tls->alpn, fio_str_hash(&tmp.name), tmp, NULL);\n  tmp.on_cleanup = NULL;\n  fio_alpn_destroy(&tmp);\n}\n\n/** Returns a pointer to the default (first) ALPN object in the TLS (if any). */\nFIO_FUNC inline alpn_s *alpn_default(fio_tls_s *tls) {\n  if (!tls || !alpn_list_count(&tls->alpn) || !tls->alpn.ordered)\n    return NULL;\n  return &tls->alpn.ordered[0].obj;\n}\n\ntypedef struct {\n  alpn_s alpn;\n  intptr_t uuid;\n  void *udata_connection;\n} alpn_task_s;\n\nFIO_FUNC inline void alpn_select___task(void *t_, void *ignr_) {\n  alpn_task_s *t = t_;\n  if (fio_is_valid(t->uuid))\n    t->alpn.on_selected(t->uuid, t->udata_connection, t->alpn.udata_tls);\n  fio_free(t);\n  (void)ignr_;\n}\n\n/** Schedules the ALPN protocol callback. */\nFIO_FUNC inline void alpn_select(alpn_s *alpn, intptr_t uuid,\n                                 void *udata_connection) {\n  if (!alpn || !alpn->on_selected)\n    return;\n  alpn_task_s *t = fio_malloc(sizeof(*t));\n  *t = (alpn_task_s){\n      .alpn = *alpn,\n      .uuid = uuid,\n      .udata_connection = udata_connection,\n  };\n  /* move task out of the socket's lock */\n  fio_defer(alpn_select___task, t, NULL);\n}\n\n/* *****************************************************************************\nSSL/TLS Context (re)-building - TODO: add implementation details\n***************************************************************************** */\n\n/** Called when the library specific data for the context should be destroyed */\nstatic void fio_tls_destroy_context(fio_tls_s *tls) {\n  /* TODO: Library specific implementation */\n  FIO_LOG_DEBUG(\"destroyed TLS context %p\", (void *)tls);\n}\n\n/** Called when the library specific data for the context should be built */\nstatic void fio_tls_build_context(fio_tls_s *tls) {\n  fio_tls_destroy_context(tls);\n  /* TODO: Library specific implementation */\n\n  /* Certificates */\n  FIO_ARY_FOR(&tls->sni, pos) {\n    fio_str_info_s k = fio_str_info(&pos->private_key);\n    fio_str_info_s p = fio_str_info(&pos->public_key);\n    fio_str_info_s pw = fio_str_info(&pos->password);\n    if (p.len && k.len) {\n      /* TODO: attache certificate */\n      (void)pw;\n    } else {\n      /* TODO: self signed certificate */\n    }\n  }\n\n  /* ALPN Protocols */\n  FIO_SET_FOR_LOOP(&tls->alpn, pos) {\n    fio_str_info_s name = fio_str_info(&pos->obj.name);\n    (void)name;\n    // map to pos->callback;\n  }\n\n  /* Peer Verification / Trust */\n  if (trust_ary_count(&tls->trust)) {\n    /* TODO: enable peer verification */\n\n    /* TODO: Add each ceriticate in the PEM to the trust \"store\" */\n    FIO_ARY_FOR(&tls->trust, pos) {\n      fio_str_info_s pem = fio_str_info(&pos->pem);\n      (void)pem;\n    }\n  }\n\n  FIO_LOG_DEBUG(\"(re)built TLS context %p\", (void *)tls);\n}\n\n/* *****************************************************************************\nSSL/TLS RW Hooks - TODO: add implementation details\n***************************************************************************** */\n\n/* TODO: this is an example implementation - fix for specific library. */\n\n#define TLS_BUFFER_LENGTH (1 << 15)\ntypedef struct {\n  fio_tls_s *tls;\n  size_t len;\n  uint8_t alpn_ok;\n  char buffer[TLS_BUFFER_LENGTH];\n} buffer_s;\n\n/**\n * Implement reading from a file descriptor. Should behave like the file\n * system `read` call, including the setup or errno to EAGAIN / EWOULDBLOCK.\n *\n * Note: facil.io library functions MUST NEVER be called by any r/w hook, or a\n * deadlock might occur.\n */\nstatic ssize_t fio_tls_read(intptr_t uuid, void *udata, void *buf,\n                            size_t count) {\n  ssize_t ret = read(fio_uuid2fd(uuid), buf, count);\n  if (ret > 0) {\n    FIO_LOG_DEBUG(\"Read %zd bytes from %p\", ret, (void *)uuid);\n  }\n  return ret;\n  (void)udata;\n}\n\n/**\n * When implemented, this function will be called to flush any data remaining\n * in the internal buffer.\n *\n * The function should return the number of bytes remaining in the internal\n * buffer (0 is a valid response) or -1 (on error).\n *\n * Note: facil.io library functions MUST NEVER be called by any r/w hook, or a\n * deadlock might occur.\n */\nstatic ssize_t fio_tls_flush(intptr_t uuid, void *udata) {\n  buffer_s *buffer = udata;\n  if (!buffer->len) {\n    FIO_LOG_DEBUG(\"Flush empty for %p\", (void *)uuid);\n    return 0;\n  }\n  ssize_t r = write(fio_uuid2fd(uuid), buffer->buffer, buffer->len);\n  if (r < 0)\n    return -1;\n  if (r == 0) {\n    errno = ECONNRESET;\n    return -1;\n  }\n  size_t len = buffer->len - r;\n  if (len)\n    memmove(buffer->buffer, buffer->buffer + r, len);\n  buffer->len = len;\n  FIO_LOG_DEBUG(\"Sent %zd bytes to %p\", r, (void *)uuid);\n  return r;\n}\n\n/**\n * Implement writing to a file descriptor. Should behave like the file system\n * `write` call.\n *\n * If an internal buffer is implemented and it is full, errno should be set to\n * EWOULDBLOCK and the function should return -1.\n *\n * Note: facil.io library functions MUST NEVER be called by any r/w hook, or a\n * deadlock might occur.\n */\nstatic ssize_t fio_tls_write(intptr_t uuid, void *udata, const void *buf,\n                             size_t count) {\n  buffer_s *buffer = udata;\n  size_t can_copy = TLS_BUFFER_LENGTH - buffer->len;\n  if (can_copy > count)\n    can_copy = count;\n  if (!can_copy)\n    goto would_block;\n  memcpy(buffer->buffer + buffer->len, buf, can_copy);\n  buffer->len += can_copy;\n  FIO_LOG_DEBUG(\"Copied %zu bytes to %p\", can_copy, (void *)uuid);\n  fio_tls_flush(uuid, udata);\n  return can_copy;\nwould_block:\n  errno = EWOULDBLOCK;\n  return -1;\n}\n\n/**\n * The `close` callback should close the underlying socket / file descriptor.\n *\n * If the function returns a non-zero value, it will be called again after an\n * attempt to flush the socket and any pending outgoing buffer.\n *\n * Note: facil.io library functions MUST NEVER be called by any r/w hook, or a\n * deadlock might occur.\n * */\nstatic ssize_t fio_tls_before_close(intptr_t uuid, void *udata) {\n  FIO_LOG_DEBUG(\"The `before_close` callback was called for %p\", (void *)uuid);\n  return 1;\n  (void)udata;\n}\n/**\n * Called to perform cleanup after the socket was closed.\n * */\nstatic void fio_tls_cleanup(void *udata) {\n  buffer_s *buffer = udata;\n  /* make sure the ALPN callback was called, just in case cleanup is required */\n  if (!buffer->alpn_ok) {\n    alpn_select(alpn_default(buffer->tls), -1, NULL /* ALPN udata */);\n  }\n  fio_tls_destroy(buffer->tls); /* manage reference count */\n  fio_free(udata);\n}\n\nstatic fio_rw_hook_s FIO_TLS_HOOKS = {\n    .read = fio_tls_read,\n    .write = fio_tls_write,\n    .before_close = fio_tls_before_close,\n    .flush = fio_tls_flush,\n    .cleanup = fio_tls_cleanup,\n};\n\nstatic size_t fio_tls_handshake(intptr_t uuid, void *udata) {\n  /*TODO: test for handshake completion */\n  if (0 /*handshake didn't complete */)\n    return 0;\n  if (fio_rw_hook_replace_unsafe(uuid, &FIO_TLS_HOOKS, udata) == 0) {\n    FIO_LOG_DEBUG(\"Completed TLS handshake for %p\", (void *)uuid);\n    /*\n     * make sure the connection is re-added to the reactor...\n     * in case, while waiting for ALPN, it was suspended for missing a protocol.\n     */\n    fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  } else {\n    FIO_LOG_DEBUG(\"Something went wrong during TLS handshake for %p\",\n                  (void *)uuid);\n  }\n  return 1;\n}\n\nstatic ssize_t fio_tls_read4handshake(intptr_t uuid, void *udata, void *buf,\n                                      size_t count) {\n  FIO_LOG_DEBUG(\"TLS handshake from read %p\", (void *)uuid);\n  if (fio_tls_handshake(uuid, udata))\n    return fio_tls_read(uuid, udata, buf, count);\n  errno = EWOULDBLOCK;\n  return -1;\n}\n\nstatic ssize_t fio_tls_write4handshake(intptr_t uuid, void *udata,\n                                       const void *buf, size_t count) {\n  FIO_LOG_DEBUG(\"TLS handshake from write %p\", (void *)uuid);\n  if (fio_tls_handshake(uuid, udata))\n    return fio_tls_write(uuid, udata, buf, count);\n  errno = EWOULDBLOCK;\n  return -1;\n}\n\nstatic ssize_t fio_tls_flush4handshake(intptr_t uuid, void *udata) {\n  FIO_LOG_DEBUG(\"TLS handshake from flush %p\", (void *)uuid);\n  if (fio_tls_handshake(uuid, udata))\n    return fio_tls_flush(uuid, udata);\n  /* TODO: return a positive value only if handshake requires a write */\n  return 1;\n}\nstatic fio_rw_hook_s FIO_TLS_HANDSHAKE_HOOKS = {\n    .read = fio_tls_read4handshake,\n    .write = fio_tls_write4handshake,\n    .before_close = fio_tls_before_close,\n    .flush = fio_tls_flush4handshake,\n    .cleanup = fio_tls_cleanup,\n};\n\nstatic inline void fio_tls_attach2uuid(intptr_t uuid, fio_tls_s *tls,\n                                       void *udata, uint8_t is_server) {\n  fio_atomic_add(&tls->ref, 1); /* manage reference count */\n  /* TODO: this is only an example implementation - fix for specific library */\n  if (is_server) {\n    /* Server mode (accept) */\n    FIO_LOG_DEBUG(\"Attaching TLS read/write hook for %p (server mode).\",\n                  (void *)uuid);\n  } else {\n    /* Client mode (connect) */\n    FIO_LOG_DEBUG(\"Attaching TLS read/write hook for %p (client mode).\",\n                  (void *)uuid);\n  }\n  /* common implementation (TODO) */\n  buffer_s *connection_data = fio_malloc(sizeof(*connection_data));\n  FIO_ASSERT_ALLOC(connection_data);\n  fio_rw_hook_set(uuid, &FIO_TLS_HANDSHAKE_HOOKS,\n                  connection_data); /* 32Kb buffer */\n  alpn_select(alpn_default(tls), uuid, udata);\n  connection_data->alpn_ok = 1;\n}\n\n/* *****************************************************************************\nSSL/TLS API implementation - this can be pretty much used as is...\n***************************************************************************** */\n\n/**\n * Creates a new SSL/TLS context / settings object with a default certificate\n * (if any).\n */\nfio_tls_s *FIO_TLS_WEAK fio_tls_new(const char *server_name, const char *cert,\n                                    const char *key, const char *pk_password) {\n  REQUIRE_LIBRARY();\n  fio_tls_s *tls = calloc(sizeof(*tls), 1);\n  tls->ref = 1;\n  fio_tls_cert_add(tls, server_name, key, cert, pk_password);\n  return tls;\n}\n\n/**\n * Adds a certificate  a new SSL/TLS context / settings object.\n */\nvoid FIO_TLS_WEAK fio_tls_cert_add(fio_tls_s *tls, const char *server_name,\n                                   const char *cert, const char *key,\n                                   const char *pk_password) {\n  REQUIRE_LIBRARY();\n  cert_s c = {\n      .private_key = FIO_STR_INIT,\n      .public_key = FIO_STR_INIT,\n      .password = FIO_STR_INIT_STATIC2(pk_password,\n                                       (pk_password ? strlen(pk_password) : 0)),\n  };\n  if (key && cert) {\n    if (fio_str_readfile(&c.private_key, key, 0, 0).data == NULL)\n      goto file_missing;\n    if (fio_str_readfile(&c.public_key, cert, 0, 0).data == NULL)\n      goto file_missing;\n    cert_ary_push(&tls->sni, c);\n  } else if (server_name) {\n    /* Self-Signed TLS Certificates */\n    c.private_key = FIO_STR_INIT_STATIC(server_name);\n    cert_ary_push(&tls->sni, c);\n  }\n  fio_tls_cert_destroy(&c);\n  fio_tls_build_context(tls);\n  return;\nfile_missing:\n  FIO_LOG_FATAL(\"TLS certificate file missing for either %s or %s or both.\",\n                key, cert);\n  exit(-1);\n}\n\n/**\n * Adds an ALPN protocol callback to the SSL/TLS context.\n *\n * The first protocol added will act as the default protocol to be selected.\n *\n * The callback should accept the `uuid`, the user data pointer passed to either\n * `fio_tls_accept` or `fio_tls_connect` (here: `udata_connetcion`) and the user\n * data pointer passed to the `fio_tls_alpn_add` function (`udata_tls`).\n *\n * The `on_cleanup` callback will be called when the TLS object is destroyed (or\n * `fio_tls_alpn_add` is called again with the same protocol name). The\n * `udata_tls` argumrnt will be passed along, as is, to the callback (if set).\n *\n * Except for the `tls` and `protocol_name` arguments, all arguments can be\n * NULL.\n */\nvoid FIO_TLS_WEAK fio_tls_alpn_add(\n    fio_tls_s *tls, const char *protocol_name,\n    void (*on_selected)(intptr_t uuid, void *udata_connection, void *udata_tls),\n    void *udata_tls, void (*on_cleanup)(void *udata_tls)) {\n  REQUIRE_LIBRARY();\n  alpn_add(tls, protocol_name, on_selected, udata_tls, on_cleanup);\n  fio_tls_build_context(tls);\n}\n\n/**\n * Returns the number of registered ALPN protocol names.\n *\n * This could be used when deciding if protocol selection should be delegated to\n * the ALPN mechanism, or whether a protocol should be immediately assigned.\n *\n * If no ALPN protocols are registered, zero (0) is returned.\n */\nuintptr_t FIO_TLS_WEAK fio_tls_alpn_count(fio_tls_s *tls) {\n  return tls ? alpn_list_count(&tls->alpn) : 0;\n}\n\n/**\n * Adds a certificate to the \"trust\" list, which automatically adds a peer\n * verification requirement.\n *\n *      fio_tls_trust(tls, \"google-ca.pem\" );\n */\nvoid FIO_TLS_WEAK fio_tls_trust(fio_tls_s *tls, const char *public_cert_file) {\n  REQUIRE_LIBRARY();\n  trust_s c = {\n      .pem = FIO_STR_INIT,\n  };\n  if (!public_cert_file)\n    return;\n  if (fio_str_readfile(&c.pem, public_cert_file, 0, 0).data == NULL)\n    goto file_missing;\n  trust_ary_push(&tls->trust, c);\n  fio_tls_trust_destroy(&c);\n  fio_tls_build_context(tls);\n  return;\nfile_missing:\n  FIO_LOG_FATAL(\"TLS certificate file missing for %s \", public_cert_file);\n  exit(-1);\n}\n\n/**\n * Establishes an SSL/TLS connection as an SSL/TLS Server, using the specified\n * context / settings object.\n *\n * The `uuid` should be a socket UUID that is already connected to a peer (i.e.,\n * the result of `fio_accept`).\n *\n * The `udata` is an opaque user data pointer that is passed along to the\n * protocol selected (if any protocols were added using `fio_tls_alpn_add`).\n */\nvoid FIO_TLS_WEAK fio_tls_accept(intptr_t uuid, fio_tls_s *tls, void *udata) {\n  REQUIRE_LIBRARY();\n  fio_tls_attach2uuid(uuid, tls, udata, 1);\n}\n\n/**\n * Establishes an SSL/TLS connection as an SSL/TLS Client, using the specified\n * context / settings object.\n *\n * The `uuid` should be a socket UUID that is already connected to a peer (i.e.,\n * one received by a `fio_connect` specified callback `on_connect`).\n *\n * The `udata` is an opaque user data pointer that is passed along to the\n * protocol selected (if any protocols were added using `fio_tls_alpn_add`).\n */\nvoid FIO_TLS_WEAK fio_tls_connect(intptr_t uuid, fio_tls_s *tls, void *udata) {\n  REQUIRE_LIBRARY();\n  fio_tls_attach2uuid(uuid, tls, udata, 0);\n}\n\n/**\n * Increase the reference count for the TLS object.\n *\n * Decrease with `fio_tls_destroy`.\n */\nvoid FIO_TLS_WEAK fio_tls_dup(fio_tls_s *tls) { fio_atomic_add(&tls->ref, 1); }\n\n/**\n * Destroys the SSL/TLS context / settings object and frees any related\n * resources / memory.\n */\nvoid FIO_TLS_WEAK fio_tls_destroy(fio_tls_s *tls) {\n  if (!tls)\n    return;\n  REQUIRE_LIBRARY();\n  if (fio_atomic_sub(&tls->ref, 1))\n    return;\n  fio_tls_destroy_context(tls);\n  alpn_list_free(&tls->alpn);\n  cert_ary_free(&tls->sni);\n  trust_ary_free(&tls->trust);\n  free(tls);\n}\n\n#endif /* Library compiler flags */\n", "/*\nCopyright: Boaz Segev, 2018-2019\nLicense: MIT\n\nFeel free to copy, use and enjoy according to the license provided.\n*/\n#include <fio.h>\n\n/**\n * This implementation of the facil.io SSL/TLS wrapper API wraps the OpenSSL API\n * to provide TLS 1.2 and TLS 1.3 to facil.io applications.\n *\n * The implementation requires `HAVE_OPENSSL` to be set.\n */\n#include \"fio_tls.h\"\n\n#if HAVE_OPENSSL\n#include <openssl/bio.h>\n#include <openssl/err.h>\n#include <openssl/ssl.h>\n\n#define REQUIRE_LIBRARY()\n#define FIO_TLS_WEAK\n\n/* *****************************************************************************\nThe SSL/TLS helper data types (can be left as is)\n***************************************************************************** */\n#define FIO_INCLUDE_STR 1\n#define FIO_FORCE_MALLOC_TMP 1\n#include <fio.h>\n\ntypedef struct {\n  fio_str_s private_key;\n  fio_str_s public_key;\n  fio_str_s password;\n} cert_s;\n\nstatic inline int fio_tls_cert_cmp(const cert_s *dest, const cert_s *src) {\n  return fio_str_iseq(&dest->private_key, &src->private_key);\n}\nstatic inline void fio_tls_cert_copy(cert_s *dest, cert_s *src) {\n  *dest = (cert_s){\n      .private_key = FIO_STR_INIT,\n      .public_key = FIO_STR_INIT,\n      .password = FIO_STR_INIT,\n  };\n  fio_str_concat(&dest->private_key, &src->private_key);\n  fio_str_concat(&dest->public_key, &src->public_key);\n  fio_str_concat(&dest->password, &src->password);\n}\nstatic inline void fio_tls_cert_destroy(cert_s *obj) {\n  fio_str_free(&obj->private_key);\n  fio_str_free(&obj->public_key);\n  fio_str_free(&obj->password);\n}\n\n#define FIO_ARY_NAME cert_ary\n#define FIO_ARY_TYPE cert_s\n#define FIO_ARY_COMPARE(k1, k2) (fio_tls_cert_cmp(&(k1), &(k2)))\n#define FIO_ARY_COPY(dest, obj) fio_tls_cert_copy(&(dest), &(obj))\n#define FIO_ARY_DESTROY(key) fio_tls_cert_destroy(&(key))\n#define FIO_FORCE_MALLOC_TMP 1\n#include <fio.h>\n\ntypedef struct {\n  fio_str_s pem;\n} trust_s;\n\nstatic inline int fio_tls_trust_cmp(const trust_s *dest, const trust_s *src) {\n  return fio_str_iseq(&dest->pem, &src->pem);\n}\nstatic inline void fio_tls_trust_copy(trust_s *dest, trust_s *src) {\n  *dest = (trust_s){\n      .pem = FIO_STR_INIT,\n  };\n  fio_str_concat(&dest->pem, &src->pem);\n}\nstatic inline void fio_tls_trust_destroy(trust_s *obj) {\n  fio_str_free(&obj->pem);\n}\n\n#define FIO_ARY_NAME trust_ary\n#define FIO_ARY_TYPE trust_s\n#define FIO_ARY_COMPARE(k1, k2) (fio_tls_trust_cmp(&(k1), &(k2)))\n#define FIO_ARY_COPY(dest, obj) fio_tls_trust_copy(&(dest), &(obj))\n#define FIO_ARY_DESTROY(key) fio_tls_trust_destroy(&(key))\n#define FIO_FORCE_MALLOC_TMP 1\n#include <fio.h>\n\ntypedef struct {\n  fio_str_s name; /* fio_str_s provides cache locality for small strings */\n  void (*on_selected)(intptr_t uuid, void *udata_connection, void *udata_tls);\n  void *udata_tls;\n  void (*on_cleanup)(void *udata_tls);\n} alpn_s;\n\nstatic inline int fio_alpn_cmp(const alpn_s *dest, const alpn_s *src) {\n  return fio_str_iseq(&dest->name, &src->name);\n}\nstatic inline void fio_alpn_copy(alpn_s *dest, alpn_s *src) {\n  *dest = (alpn_s){\n      .name = FIO_STR_INIT,\n      .on_selected = src->on_selected,\n      .udata_tls = src->udata_tls,\n      .on_cleanup = src->on_cleanup,\n  };\n  fio_str_concat(&dest->name, &src->name);\n}\nstatic inline void fio_alpn_destroy(alpn_s *obj) {\n  if (obj->on_cleanup)\n    obj->on_cleanup(obj->udata_tls);\n  fio_str_free(&obj->name);\n}\n\n#define FIO_SET_NAME alpn_list\n#define FIO_SET_OBJ_TYPE alpn_s\n#define FIO_SET_OBJ_COMPARE(k1, k2) fio_alpn_cmp(&(k1), &(k2))\n#define FIO_SET_OBJ_COPY(dest, obj) fio_alpn_copy(&(dest), &(obj))\n#define FIO_SET_OBJ_DESTROY(key) fio_alpn_destroy(&(key))\n#define FIO_FORCE_MALLOC_TMP 1\n#include <fio.h>\n\n/* *****************************************************************************\nThe SSL/TLS type\n***************************************************************************** */\n\n/** An opaque type used for the SSL/TLS functions. */\nstruct fio_tls_s {\n  size_t ref;       /* Reference counter, to guards the ALPN registry */\n  alpn_list_s alpn; /* ALPN is the name for the protocol selection extension */\n\n  /*** the next two components could be optimized away with tweaking stuff ***/\n\n  cert_ary_s sni;    /* SNI (server name extension) stores ID certificates */\n  trust_ary_s trust; /* Trusted certificate registry (peer verification) */\n\n  /************ TODO: implementation data fields go here ******************/\n\n  SSL_CTX *ctx;            /* The Open SSL context (updated each time). */\n  unsigned char *alpn_str; /* the computed server-format ALPN string */\n  int alpn_len;\n};\n\n/* *****************************************************************************\nALPN Helpers\n***************************************************************************** */\n\n/** Returns a pointer to the ALPN data (callback, etc') IF exists in the TLS. */\nFIO_FUNC inline alpn_s *alpn_find(fio_tls_s *tls, char *name, size_t len) {\n  alpn_s tmp = {.name = FIO_STR_INIT_STATIC2(name, len)};\n  alpn_list__map_s_ *pos =\n      alpn_list__find_map_pos_(&tls->alpn, fio_str_hash(&tmp.name), tmp);\n  if (!pos || !pos->pos)\n    return NULL;\n  return &pos->pos->obj;\n}\n\n/** Adds an ALPN data object to the ALPN \"list\" (set) */\nFIO_FUNC inline void alpn_add(\n    fio_tls_s *tls, const char *protocol_name,\n    void (*on_selected)(intptr_t uuid, void *udata_connection, void *udata_tls),\n    void *udata_tls, void (*on_cleanup)(void *udata_tls)) {\n  alpn_s tmp = {\n      .name = FIO_STR_INIT_STATIC(protocol_name),\n      .on_selected = on_selected,\n      .udata_tls = udata_tls,\n      .on_cleanup = on_cleanup,\n  };\n  if (fio_str_len(&tmp.name) > 255) {\n    FIO_LOG_ERROR(\"ALPN protocol names are limited to 255 bytes.\");\n    return;\n  }\n  alpn_list_overwrite(&tls->alpn, fio_str_hash(&tmp.name), tmp, NULL);\n  tmp.on_cleanup = NULL;\n  fio_alpn_destroy(&tmp);\n}\n\n/** Returns a pointer to the default (first) ALPN object in the TLS (if any). */\nFIO_FUNC inline alpn_s *alpn_default(fio_tls_s *tls) {\n  if (!tls || !alpn_list_count(&tls->alpn) || !tls->alpn.ordered)\n    return NULL;\n  return &tls->alpn.ordered[0].obj;\n}\n\ntypedef struct {\n  alpn_s alpn;\n  intptr_t uuid;\n  void *udata_connection;\n} alpn_task_s;\n\nFIO_FUNC inline void alpn_select___task(void *t_, void *ignr_) {\n  alpn_task_s *t = t_;\n  t->alpn.on_selected((fio_is_valid(t->uuid) ? t->uuid : -1),\n                      t->udata_connection, t->alpn.udata_tls);\n  fio_free(t);\n  (void)ignr_;\n}\n\n/** Schedules the ALPN protocol callback. */\nFIO_FUNC inline void alpn_select(alpn_s *alpn, intptr_t uuid,\n                                 void *udata_connection) {\n  if (!alpn || !alpn->on_selected)\n    return;\n  alpn_task_s *t = fio_malloc(sizeof(*t));\n  *t = (alpn_task_s){\n      .alpn = *alpn,\n      .uuid = uuid,\n      .udata_connection = udata_connection,\n  };\n  fio_defer(alpn_select___task, t, NULL);\n}\n\n/* *****************************************************************************\nOpenSSL Helpers\n***************************************************************************** */\n\nstatic EVP_PKEY *fio_tls_pkey = NULL;\n\nstatic void fio_tls_clear_root_key(void *key) {\n  EVP_PKEY_free(key);\n  fio_tls_pkey = NULL;\n}\n\nstatic void fio_tls_make_root_key(void) {\n  static fio_lock_i lock = FIO_LOCK_INIT;\n  fio_lock(&lock);\n  if (fio_tls_pkey)\n    goto finish;\n  /* create private key, free it at exit */\n  FIO_LOG_DEBUG(\"calculating a new TLS private key... might take a while.\");\n\n  fio_tls_pkey = EVP_PKEY_new();\n  FIO_ASSERT(fio_tls_pkey, \"OpenSSL failed to create private key.\");\n\n  /* TODO: replace RSA with something else? is there something else? */\n  RSA *rsa = RSA_new();\n  BIGNUM *e = BN_new();\n  BN_clear(e);\n  BN_add_word(e, 65537);\n  FIO_ASSERT_ALLOC(e);\n  FIO_ASSERT(RSA_generate_key_ex(rsa, 2048, e, NULL),\n             \"OpenSSL failed to create RSA key.\");\n  BN_free(e);\n  EVP_PKEY_assign_RSA(fio_tls_pkey, rsa);\n  fio_state_callback_add(FIO_CALL_AT_EXIT, fio_tls_clear_root_key,\n                         fio_tls_pkey);\nfinish:\n  fio_unlock(&lock);\n}\n\nstatic X509 *fio_tls_create_self_signed(char *server_name) {\n  X509 *cert = X509_new();\n  static uint32_t counter = 0;\n  FIO_ASSERT(cert,\n             \"OpenSSL failed to allocate memory for self-signed ceritifcate.\");\n  fio_tls_make_root_key();\n\n  /* serial number */\n  fio_atomic_add(&counter, 1);\n  ASN1_INTEGER_set(X509_get_serialNumber(cert), counter);\n\n  /* validity (180 days) */\n  X509_gmtime_adj(X509_get_notBefore(cert), 0);\n  X509_gmtime_adj(X509_get_notAfter(cert), 15552000L);\n\n  /* set (public) key */\n  X509_set_pubkey(cert, fio_tls_pkey);\n\n  /* set identity details */\n  X509_NAME *s = X509_get_subject_name(cert);\n  size_t srv_name_len = strlen(server_name);\n  X509_NAME_add_entry_by_txt(s, \"O\", MBSTRING_ASC, (unsigned char *)server_name,\n                             srv_name_len, -1, 0);\n  X509_NAME_add_entry_by_txt(s, \"CN\", MBSTRING_ASC,\n                             (unsigned char *)server_name, srv_name_len, -1, 0);\n  X509_NAME_add_entry_by_txt(s, \"CA\", MBSTRING_ASC,\n                             (unsigned char *)server_name, srv_name_len, -1, 0);\n  X509_set_issuer_name(cert, s);\n\n  /* sign certificate */\n  FIO_ASSERT(X509_sign(cert, fio_tls_pkey, EVP_sha512()),\n             \"OpenSSL failed to signe self-signed certificate\");\n  // FILE *fp = fopen(\"tmp.pem\", \"ab+\");\n  // if (fp) {\n  //   PEM_write_X509(fp, cert);\n  //   fclose(fp);\n  // }\n\n  return cert;\n}\n\n/* *****************************************************************************\nSSL/TLS Context (re)-building\n***************************************************************************** */\n\n#define TLS_BUFFER_LENGTH (1 << 15)\ntypedef struct {\n  SSL *ssl;\n  fio_tls_s *tls;\n  void *alpn_arg;\n  intptr_t uuid;\n  uint8_t is_server;\n  volatile uint8_t alpn_ok;\n} fio_tls_connection_s;\n\nstatic void fio_tls_alpn_fallback(fio_tls_connection_s *c) {\n  alpn_s *alpn = alpn_default(c->tls);\n  if (!alpn || !alpn->on_selected)\n    return;\n  /* set protocol to default protocol */\n  FIO_LOG_DEBUG(\"TLS ALPN handshake missing, falling back on %s for %p\",\n                fio_str_info(&alpn->name).data, (void *)c->uuid);\n  alpn_select(alpn, c->uuid, c->alpn_arg);\n}\nstatic int fio_tls_alpn_selector_cb(SSL *ssl, const unsigned char **out,\n                                    unsigned char *outlen,\n                                    const unsigned char *in, unsigned int inlen,\n                                    void *tls_) {\n  fio_tls_s *tls = tls_;\n  alpn_s *alpn;\n  /* TODO: select ALPN and call on_selected */\n  fio_tls_connection_s *c = SSL_get_ex_data(ssl, 0);\n  c->alpn_ok = 1;\n\n  if (alpn_list_count(&tls->alpn) == 0)\n    return SSL_TLSEXT_ERR_NOACK;\n  const unsigned char *end = in + inlen;\n  while (in < end) {\n    uint8_t l = in[0];\n    alpn = alpn_find(tls, (char *)in + 1, l);\n    in += l + 1;\n    if (!alpn)\n      continue;\n    fio_str_info_s info = fio_str_info(&alpn->name);\n    *out = (unsigned char *)info.data;\n    *outlen = (unsigned char)info.len;\n    FIO_LOG_DEBUG(\"TLS ALPN set to: %s for %p\", info.data, (void *)c->uuid);\n    alpn_select(alpn, c->uuid, c->alpn_arg);\n    return SSL_TLSEXT_ERR_OK;\n  }\n  /* set protocol to default protocol */\n  alpn = alpn_default(tls);\n  alpn_select(alpn, c->uuid, c->alpn_arg);\n  FIO_LOG_DEBUG(\n      \"TLS ALPN handshake failed, falling back on default (%s) for %p\",\n      fio_str_data(&alpn->name), (void *)c->uuid);\n  return SSL_TLSEXT_ERR_NOACK;\n  (void)ssl;\n  (void)out;\n  (void)outlen;\n  (void)in;\n  (void)inlen;\n  (void)tls;\n}\n\n/** Called when the library specific data for the context should be destroyed */\nstatic void fio_tls_destroy_context(fio_tls_s *tls) {\n  /* TODO: Library specific implementation */\n  SSL_CTX_free(tls->ctx);\n  free(tls->alpn_str);\n\n  tls->ctx = NULL;\n  tls->alpn_str = NULL;\n  tls->alpn_len = 0;\n  FIO_LOG_DEBUG(\"destroyed TLS context for OpenSSL %p\", (void *)tls);\n}\n\nstatic int fio_tls_pem_passwd_cb(char *buf, int size, int rwflag,\n                                 void *password) {\n  fio_str_info_s *p = password;\n  if (!p || !p->len || !size)\n    return 0;\n  int len = (size <= (int)p->len) ? (size - 1) : (int)p->len;\n  memcpy(buf, p->data, len);\n  buf[len] = 0;\n  return len;\n  (void)rwflag;\n}\n\n/** Called when the library specific data for the context should be built */\nstatic void fio_tls_build_context(fio_tls_s *tls) {\n  fio_tls_destroy_context(tls);\n  /* TODO: Library specific implementation */\n\n  /* create new context */\n  tls->ctx = SSL_CTX_new(TLS_method());\n  SSL_CTX_set_mode(tls->ctx, SSL_MODE_ENABLE_PARTIAL_WRITE);\n  /* see: https://caniuse.com/#search=tls */\n  SSL_CTX_set_min_proto_version(tls->ctx, TLS1_2_VERSION);\n  SSL_CTX_set_options(tls->ctx, SSL_OP_NO_COMPRESSION);\n\n  /* attach certificates */\n  FIO_ARY_FOR(&tls->sni, pos) {\n    fio_str_info_s keys[4] = {\n        fio_str_info(&pos->private_key), fio_str_info(&pos->public_key),\n        fio_str_info(&pos->password),\n        /* empty password slot for public key */\n    };\n    if (keys[0].len && keys[1].len) {\n      if (1) {\n        /* Extract private key from private key file */\n        BIO *bio = BIO_new_mem_buf(keys[0].data, keys[0].len);\n        if (bio) {\n          EVP_PKEY *k = PEM_read_bio_PrivateKey(\n              bio, NULL, fio_tls_pem_passwd_cb, keys + 2);\n          if (k) {\n            FIO_LOG_DEBUG(\"TLS read private key from PEM file.\");\n            SSL_CTX_use_PrivateKey(tls->ctx, k);\n          }\n          BIO_free(bio);\n        }\n      }\n      /* Certificate Files loaded */\n      for (int ki = 0; ki < 2; ++ki) {\n        /* Extract as much data as possible from each file */\n        BIO *bio = BIO_new_mem_buf(keys[ki].data, keys[ki].len);\n        FIO_ASSERT(bio, \"OpenSSL error allocating BIO.\");\n        STACK_OF(X509_INFO) *inf = PEM_X509_INFO_read_bio(\n            bio, NULL, fio_tls_pem_passwd_cb, keys + ki + 2);\n        if (inf) {\n          for (int i = 0; i < sk_X509_INFO_num(inf); ++i) {\n            /* for each element in PEM */\n            X509_INFO *tmp = sk_X509_INFO_value(inf, i);\n            if (tmp->x509) {\n              FIO_LOG_DEBUG(\"TLS adding certificate from PEM file.\");\n              SSL_CTX_use_certificate(tls->ctx, tmp->x509);\n            }\n            if (tmp->x_pkey) {\n              FIO_LOG_DEBUG(\"TLS adding private key from PEM file.\");\n              SSL_CTX_use_PrivateKey(tls->ctx, tmp->x_pkey->dec_pkey);\n            }\n          }\n          sk_X509_INFO_pop_free(inf, X509_INFO_free);\n        } else {\n          /* TODO: attempt DER format? */\n          // X509 *c;\n          // EVP_PKEY *k;\n          // const uint8_t *pdata = (uint8_t *)&keys[ki].data;\n          // d2i_X509(&c, &pdata, keys[ki].len);\n          // pdata = (uint8_t *)&keys[ki].data;\n          // d2i_AutoPrivateKey(&k, &pdata, keys[ki].len);\n        }\n        BIO_free(bio);\n      }\n    } else if (keys[0].len) {\n      /* Self Signed Certificates, only if server name is provided. */\n      SSL_CTX_use_certificate(tls->ctx,\n                              fio_tls_create_self_signed(keys[0].data));\n      SSL_CTX_use_PrivateKey(tls->ctx, fio_tls_pkey);\n    }\n  }\n\n  /* setup ALPN support */\n  if (1) {\n    size_t alpn_pos = 0;\n    /* looping twice is better than malloc fragmentation. */\n    FIO_SET_FOR_LOOP(&tls->alpn, pos) {\n      fio_str_info_s s = fio_str_info(&pos->obj.name);\n      if (!s.len)\n        continue;\n      alpn_pos += s.len + 1;\n    }\n    tls->alpn_str = malloc((alpn_pos | 15) + 1); /* round up to 16 + padding */\n    alpn_pos = 0;\n    FIO_SET_FOR_LOOP(&tls->alpn, pos) {\n      fio_str_info_s s = fio_str_info(&pos->obj.name);\n      if (!s.len)\n        continue;\n      tls->alpn_str[alpn_pos++] = (uint8_t)s.len;\n      memcpy(tls->alpn_str + alpn_pos, s.data, s.len);\n      alpn_pos += s.len;\n    }\n    tls->alpn_len = alpn_pos;\n    SSL_CTX_set_alpn_select_cb(tls->ctx, fio_tls_alpn_selector_cb, tls);\n    SSL_CTX_set_alpn_protos(tls->ctx, tls->alpn_str, tls->alpn_len);\n  }\n\n  /* Peer Verification / Trust */\n  if (trust_ary_count(&tls->trust)) {\n    /* TODO: enable peer verification */\n    X509_STORE *store = X509_STORE_new();\n    SSL_CTX_set_cert_store(tls->ctx, store);\n    SSL_CTX_set_verify(tls->ctx, SSL_VERIFY_PEER, NULL);\n    /* TODO: Add each ceriticate in the PEM to the trust \"store\" */\n    FIO_ARY_FOR(&tls->trust, pos) {\n      fio_str_info_s pem = fio_str_info(&pos->pem);\n      BIO *bio = BIO_new_mem_buf(pem.data, pem.len);\n      FIO_ASSERT(bio, \"OpenSSL error allocating BIO.\");\n      STACK_OF(X509_INFO) *inf = PEM_X509_INFO_read_bio(bio, NULL, NULL, NULL);\n      if (inf) {\n        for (int i = 0; i < sk_X509_INFO_num(inf); ++i) {\n          /* for each element in PEM */\n          X509_INFO *tmp = sk_X509_INFO_value(inf, i);\n          if (tmp->x509) {\n            FIO_LOG_DEBUG(\"TLS trusting certificate from PEM file.\");\n            X509_STORE_add_cert(store, tmp->x509);\n          }\n          if (tmp->crl) {\n            X509_STORE_add_crl(store, tmp->crl);\n          }\n        }\n        sk_X509_INFO_pop_free(inf, X509_INFO_free);\n      }\n      BIO_free(bio);\n    }\n  }\n\n  FIO_LOG_DEBUG(\"(re)built TLS context for OpenSSL %p\", (void *)tls);\n}\n\n/* *****************************************************************************\nSSL/TLS RW Hooks\n***************************************************************************** */\n\nstatic void fio_tls_delayed_close(void *uuid, void *ignr_) {\n  fio_close((intptr_t)uuid);\n  (void)ignr_;\n}\n\n/* TODO: this is an example implementation - fix for specific library. */\n\n/**\n * Implement reading from a file descriptor. Should behave like the file\n * system `read` call, including the setup or errno to EAGAIN / EWOULDBLOCK.\n *\n * Note: facil.io library functions MUST NEVER be called by any r/w hook, or a\n * deadlock might occur.\n */\nstatic ssize_t fio_tls_read(intptr_t uuid, void *udata, void *buf,\n                            size_t count) {\n  fio_tls_connection_s *c = udata;\n  ssize_t ret = SSL_read(c->ssl, buf, count);\n  if (ret > 0)\n    return ret;\n  ret = SSL_get_error(c->ssl, ret);\n  switch (ret) {\n  case SSL_ERROR_SSL: /* overflow */\n  case SSL_ERROR_ZERO_RETURN:\n    return 0;                      /* EOF */\n  case SSL_ERROR_NONE:             /* overflow */\n  case SSL_ERROR_WANT_CONNECT:     /* overflow */\n  case SSL_ERROR_WANT_ACCEPT:      /* overflow */\n  case SSL_ERROR_WANT_X509_LOOKUP: /* overflow */\n#ifdef SSL_ERROR_WANT_ASYNC\n  case SSL_ERROR_WANT_ASYNC: /* overflow */\n#endif\n  case SSL_ERROR_WANT_WRITE: /* overflow */\n  case SSL_ERROR_WANT_READ:\n  default:\n    break;\n  }\n  errno = EWOULDBLOCK;\n  return -1;\n  (void)uuid;\n}\n\n/**\n * When implemented, this function will be called to flush any data remaining\n * in the internal buffer.\n *\n * The function should return the number of bytes remaining in the internal\n * buffer (0 is a valid response) or -1 (on error).\n *\n * Note: facil.io library functions MUST NEVER be called by any r/w hook, or a\n * deadlock might occur.\n */\nstatic ssize_t fio_tls_flush(intptr_t uuid, void *udata) {\n  (void)uuid;\n  (void)udata;\n  return 0;\n}\n\n/**\n * Implement writing to a file descriptor. Should behave like the file system\n * `write` call.\n *\n * If an internal buffer is implemented and it is full, errno should be set to\n * EWOULDBLOCK and the function should return -1.\n *\n * Note: facil.io library functions MUST NEVER be called by any r/w hook, or a\n * deadlock might occur.\n */\nstatic ssize_t fio_tls_write(intptr_t uuid, void *udata, const void *buf,\n                             size_t count) {\n  fio_tls_connection_s *c = udata;\n  ssize_t ret = SSL_write(c->ssl, buf, count);\n  if (ret > 0)\n    return ret;\n  ret = SSL_get_error(c->ssl, ret);\n  switch (ret) {\n  case SSL_ERROR_SSL: /* overflow */\n  case SSL_ERROR_ZERO_RETURN:\n    return 0;                      /* EOF */\n  case SSL_ERROR_NONE:             /* overflow */\n  case SSL_ERROR_WANT_CONNECT:     /* overflow */\n  case SSL_ERROR_WANT_ACCEPT:      /* overflow */\n  case SSL_ERROR_WANT_X509_LOOKUP: /* overflow */\n#ifdef SSL_ERROR_WANT_ASYNC\n  case SSL_ERROR_WANT_ASYNC: /* overflow */\n#endif\n  case SSL_ERROR_WANT_WRITE: /* overflow */\n  case SSL_ERROR_WANT_READ:\n  default:\n    break;\n  }\n  errno = EWOULDBLOCK;\n  return -1;\n  (void)uuid;\n}\n\n/**\n * The `close` callback should close the underlying socket / file descriptor.\n *\n * If the function returns a non-zero value, it will be called again after an\n * attempt to flush the socket and any pending outgoing buffer.\n *\n * Note: facil.io library functions MUST NEVER be called by any r/w hook, or a\n * deadlock might occur.\n * */\nstatic ssize_t fio_tls_before_close(intptr_t uuid, void *udata) {\n  fio_tls_connection_s *c = udata;\n  SSL_shutdown(c->ssl);\n  return 1;\n  (void)uuid;\n}\n/**\n * Called to perform cleanup after the socket was closed.\n * */\nstatic void fio_tls_cleanup(void *udata) {\n  fio_tls_connection_s *c = udata;\n  if (!c->alpn_ok) {\n    alpn_select(alpn_default(c->tls), -1, c->alpn_arg);\n  }\n  SSL_free(c->ssl);\n  FIO_LOG_DEBUG(\"TLS cleanup for %p\", (void *)c->uuid);\n  fio_tls_destroy(c->tls); /* manage reference count */\n  free(udata);\n}\n\nstatic fio_rw_hook_s FIO_TLS_HOOKS = {\n    .read = fio_tls_read,\n    .write = fio_tls_write,\n    .before_close = fio_tls_before_close,\n    .flush = fio_tls_flush,\n    .cleanup = fio_tls_cleanup,\n};\n\nstatic size_t fio_tls_handshake(intptr_t uuid, void *udata) {\n  fio_tls_connection_s *c = udata;\n  int ri;\n  if (c->is_server) {\n    ri = SSL_accept(c->ssl);\n  } else {\n    ri = SSL_connect(c->ssl);\n  }\n  if (ri != 1) {\n    ri = SSL_get_error(c->ssl, ri);\n    switch (ri) {\n    case SSL_ERROR_NONE:\n      // FIO_LOG_DEBUG(\"SSL_accept/SSL_connect %p state: SSL_ERROR_NONE\",\n      //               (void *)uuid);\n      return 0;\n    case SSL_ERROR_WANT_WRITE:\n      // FIO_LOG_DEBUG(\"SSL_accept/SSL_connect %p state: SSL_ERROR_WANT_WRITE\",\n      //               (void *)uuid);\n      //   fio_force_event(uuid, FIO_EVENT_ON_READY);\n      return 0;\n    case SSL_ERROR_WANT_READ:\n      // FIO_LOG_DEBUG(\"SSL_accept/SSL_connect %p state: SSL_ERROR_WANT_READ\",\n      //               (void *)uuid);\n      // fio_force_event(uuid, FIO_EVENT_ON_DATA);\n      return 0;\n    case SSL_ERROR_SYSCALL:\n      FIO_LOG_DEBUG(\n          \"SSL_accept/SSL_connect %p error: SSL_ERROR_SYSCALL, errno: %s\",\n          (void *)uuid, strerror(errno));\n      // fio_force_event(uuid, FIO_EVENT_ON_DATA);\n      return 0;\n    case SSL_ERROR_SSL:\n      FIO_LOG_DEBUG(\"SSL_accept/SSL_connect %p error: SSL_ERROR_SSL\",\n                    (void *)uuid);\n      break;\n    case SSL_ERROR_ZERO_RETURN:\n      FIO_LOG_DEBUG(\"SSL_accept/SSL_connect %p error: SSL_ERROR_ZERO_RETURN\",\n                    (void *)uuid);\n      break;\n    case SSL_ERROR_WANT_CONNECT:\n      FIO_LOG_DEBUG(\"SSL_accept/SSL_connect %p error: SSL_ERROR_WANT_CONNECT\",\n                    (void *)uuid);\n      break;\n    case SSL_ERROR_WANT_ACCEPT:\n      FIO_LOG_DEBUG(\"SSL_accept/SSL_connect %p error: SSL_ERROR_WANT_ACCEPT\",\n                    (void *)uuid);\n      break;\n    case SSL_ERROR_WANT_X509_LOOKUP:\n      FIO_LOG_DEBUG(\n          \"SSL_accept/SSL_connect %p error: SSL_ERROR_WANT_X509_LOOKUP\",\n          (void *)uuid);\n      break;\n#ifdef SSL_ERROR_WANT_ASYNC\n    case SSL_ERROR_WANT_ASYNC:\n      FIO_LOG_DEBUG(\"SSL_accept/SSL_connect %p error: SSL_ERROR_WANT_ASYNC\",\n                    (void *)uuid);\n      break;\n#endif\n#ifdef SSL_ERROR_WANT_CLIENT_HELLO_CB\n    case SSL_ERROR_WANT_CLIENT_HELLO_CB:\n      FIO_LOG_DEBUG(\n          \"SSL_accept/SSL_connect %p error: SSL_ERROR_WANT_CLIENT_HELLO_CB\",\n          (void *)uuid);\n      break;\n#endif\n    default:\n      FIO_LOG_DEBUG(\"SSL_accept/SSL_connect %p error: unknown (%d).\",\n                    (void *)uuid, ri);\n      break;\n    }\n    fio_defer(fio_tls_delayed_close, (void *)uuid, NULL);\n    return 0;\n  }\n  if (!c->alpn_ok) {\n    c->alpn_ok = 1;\n    if (c->is_server) {\n      fio_tls_alpn_fallback(c);\n    } else {\n      const unsigned char *proto;\n      unsigned int proto_len;\n      SSL_get0_alpn_selected(c->ssl, &proto, &proto_len);\n      alpn_s *alpn = NULL;\n      if (proto_len > 0) {\n        alpn = alpn_find(c->tls, (char *)proto, proto_len);\n      }\n      if (!alpn) {\n        alpn = alpn_default(c->tls);\n        FIO_LOG_DEBUG(\"ALPN missing for TLS client %p\", (void *)uuid);\n      }\n      if (alpn)\n        FIO_LOG_DEBUG(\"setting ALPN %s for TLS client %p\",\n                      fio_str_data(&alpn->name), (void *)uuid);\n      alpn_select(alpn, c->uuid, c->alpn_arg);\n    }\n  }\n  if (fio_rw_hook_replace_unsafe(uuid, &FIO_TLS_HOOKS, udata) == 0) {\n    FIO_LOG_DEBUG(\"Completed TLS handshake for %p\", (void *)uuid);\n  } else {\n    FIO_LOG_DEBUG(\"Something went wrong during TLS handshake for %p\",\n                  (void *)uuid);\n    return 0;\n  }\n  /* make sure the connection is re-added to the reactor */\n  fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  /* log session ID for WireShark */\n#if FIO_TLS_PRINT_SECRET\n  if (FIO_LOG_LEVEL >= FIO_LOG_LEVEL_DEBUG) {\n    unsigned char buff[SSL_MAX_MASTER_KEY_LENGTH + 2];\n    size_t ret = SSL_SESSION_get_master_key(SSL_get_session(c->ssl), buff,\n                                            SSL_MAX_MASTER_KEY_LENGTH + 1);\n    buff[ret] = 0;\n    unsigned char buff2[(SSL_MAX_MASTER_KEY_LENGTH + 2) << 1];\n    for (size_t i = 0; i < ret; ++i) {\n      buff2[i] = ((buff[i] >> 4) >= 10) ? ('A' + (buff[i] >> 4) - 10)\n                                        : ('0' + (buff[i] >> 4));\n      buff2[i + 1] = ((buff[i] & 15) >= 10) ? ('A' + (buff[i] & 15) - 10)\n                                            : ('0' + (buff[i] & 15));\n    }\n    buff2[(ret << 1)] = 0;\n    FIO_LOG_DEBUG(\"OpenSSL Master Key for uuid %p:\\n\\t\\t%s\", (void *)uuid,\n                  buff2);\n  }\n#endif\n  return 1;\n}\n\nstatic ssize_t fio_tls_read4handshake(intptr_t uuid, void *udata, void *buf,\n                                      size_t count) {\n  // FIO_LOG_DEBUG(\"TLS handshake from read %p\", (void *)uuid);\n  if (fio_tls_handshake(uuid, udata))\n    return fio_tls_read(uuid, udata, buf, count);\n  errno = EWOULDBLOCK;\n  return -1;\n}\n\nstatic ssize_t fio_tls_write4handshake(intptr_t uuid, void *udata,\n                                       const void *buf, size_t count) {\n  // FIO_LOG_DEBUG(\"TLS handshake from write %p\", (void *)uuid);\n  if (fio_tls_handshake(uuid, udata))\n    return fio_tls_write(uuid, udata, buf, count);\n  errno = EWOULDBLOCK;\n  return -1;\n}\n\nstatic ssize_t fio_tls_flush4handshake(intptr_t uuid, void *udata) {\n  // FIO_LOG_DEBUG(\"TLS handshake from flush %p\", (void *)uuid);\n  if (fio_tls_handshake(uuid, udata)) {\n    return fio_tls_flush(uuid, udata);\n  }\n  errno = 0;\n  return 1;\n}\nstatic fio_rw_hook_s FIO_TLS_HANDSHAKE_HOOKS = {\n    .read = fio_tls_read4handshake,\n    .write = fio_tls_write4handshake,\n    .before_close = fio_tls_before_close,\n    .flush = fio_tls_flush4handshake,\n    .cleanup = fio_tls_cleanup,\n};\nstatic inline void fio_tls_attach2uuid(intptr_t uuid, fio_tls_s *tls,\n                                       void *udata, uint8_t is_server) {\n  fio_atomic_add(&tls->ref, 1);\n  /* create SSL connection context from global context */\n  fio_tls_connection_s *c = malloc(sizeof(*c));\n  FIO_ASSERT_ALLOC(c);\n  *c = (fio_tls_connection_s){\n      .alpn_arg = udata,\n      .tls = tls,\n      .uuid = uuid,\n      .ssl = SSL_new(tls->ctx),\n      .is_server = is_server,\n      .alpn_ok = 0,\n  };\n  FIO_ASSERT_ALLOC(c->ssl);\n  /* set facil.io data in the SSL object */\n  SSL_set_ex_data(c->ssl, 0, (void *)c);\n  /* attach socket - TODO: Switch to BIO socket */\n  BIO *bio = BIO_new_socket(fio_uuid2fd(uuid), 0);\n  BIO_up_ref(bio);\n  SSL_set0_rbio(c->ssl, bio);\n  SSL_set0_wbio(c->ssl, bio);\n  /* set RW hooks */\n  fio_rw_hook_set(uuid, &FIO_TLS_HANDSHAKE_HOOKS, c);\n  if (is_server) {\n    /* Server mode (accept) */\n    FIO_LOG_DEBUG(\"Attaching TLS read/write hook for %p (server mode).\",\n                  (void *)uuid);\n    SSL_set_accept_state(c->ssl);\n  } else {\n    /* Client mode (connect) */\n    FIO_LOG_DEBUG(\"Attaching TLS read/write hook for %p (client mode).\",\n                  (void *)uuid);\n    SSL_set_connect_state(c->ssl);\n  }\n  fio_force_event(uuid, FIO_EVENT_ON_READY);\n}\n\n/* *****************************************************************************\nSSL/TLS API implementation - this can be pretty much used as is...\n***************************************************************************** */\n\n/**\n * Creates a new SSL/TLS context / settings object with a default certificate\n * (if any).\n */\nfio_tls_s *FIO_TLS_WEAK fio_tls_new(const char *server_name, const char *cert,\n                                    const char *key, const char *pk_password) {\n  REQUIRE_LIBRARY();\n  fio_tls_s *tls = calloc(sizeof(*tls), 1);\n  tls->ref = 1;\n  fio_tls_cert_add(tls, server_name, key, cert, pk_password);\n  return tls;\n}\n\n/**\n * Adds a certificate  a new SSL/TLS context / settings object.\n */\nvoid FIO_TLS_WEAK fio_tls_cert_add(fio_tls_s *tls, const char *server_name,\n                                   const char *cert, const char *key,\n                                   const char *pk_password) {\n  REQUIRE_LIBRARY();\n  cert_s c = {\n      .private_key = FIO_STR_INIT,\n      .public_key = FIO_STR_INIT,\n      .password = FIO_STR_INIT_STATIC2(pk_password,\n                                       (pk_password ? strlen(pk_password) : 0)),\n  };\n  if (key && cert) {\n    if (fio_str_readfile(&c.private_key, key, 0, 0).data == NULL)\n      goto file_missing;\n    if (fio_str_readfile(&c.public_key, cert, 0, 0).data == NULL)\n      goto file_missing;\n    cert_ary_push(&tls->sni, c);\n  } else if (server_name) {\n    /* Self-Signed TLS Certificates */\n    c.private_key = FIO_STR_INIT_STATIC(server_name);\n    cert_ary_push(&tls->sni, c);\n  }\n  fio_tls_cert_destroy(&c);\n  fio_tls_build_context(tls);\n  return;\nfile_missing:\n  FIO_LOG_FATAL(\"TLS certificate file missing for either %s or %s or both.\",\n                key, cert);\n  exit(-1);\n}\n\n/**\n * Adds an ALPN protocol callback to the SSL/TLS context.\n *\n * The first protocol added will act as the default protocol to be selected.\n *\n * The callback should accept the `uuid`, the user data pointer passed to\n * either `fio_tls_accept` or `fio_tls_connect` (here: `udata_connetcion`) and\n * the user data pointer passed to the `fio_tls_alpn_add` function\n * (`udata_tls`).\n *\n * The `on_cleanup` callback will be called when the TLS object is destroyed\n * (or `fio_tls_alpn_add` is called again with the same protocol name). The\n * `udata_tls` argumrnt will be passed along, as is, to the callback (if set).\n *\n * Except for the `tls` and `protocol_name` arguments, all arguments can be\n * NULL.\n */\nvoid FIO_TLS_WEAK fio_tls_alpn_add(\n    fio_tls_s *tls, const char *protocol_name,\n    void (*on_selected)(intptr_t uuid, void *udata_connection, void *udata_tls),\n    void *udata_tls, void (*on_cleanup)(void *udata_tls)) {\n  REQUIRE_LIBRARY();\n  alpn_add(tls, protocol_name, on_selected, udata_tls, on_cleanup);\n  fio_tls_build_context(tls);\n}\n\n/**\n * Returns the number of registered ALPN protocol names.\n *\n * This could be used when deciding if protocol selection should be delegated\n * to the ALPN mechanism, or whether a protocol should be immediately\n * assigned.\n *\n * If no ALPN protocols are registered, zero (0) is returned.\n */\nuintptr_t FIO_TLS_WEAK fio_tls_alpn_count(fio_tls_s *tls) {\n  return tls ? alpn_list_count(&tls->alpn) : 0;\n}\n\n/**\n * Adds a certificate to the \"trust\" list, which automatically adds a peer\n * verification requirement.\n *\n *      fio_tls_trust(tls, \"google-ca.pem\" );\n */\nvoid FIO_TLS_WEAK fio_tls_trust(fio_tls_s *tls, const char *public_cert_file) {\n  REQUIRE_LIBRARY();\n  trust_s c = {\n      .pem = FIO_STR_INIT,\n  };\n  if (!public_cert_file)\n    return;\n  if (fio_str_readfile(&c.pem, public_cert_file, 0, 0).data == NULL)\n    goto file_missing;\n  trust_ary_push(&tls->trust, c);\n  fio_tls_trust_destroy(&c);\n  fio_tls_build_context(tls);\n  return;\nfile_missing:\n  FIO_LOG_FATAL(\"TLS certificate file missing for %s \", public_cert_file);\n  exit(-1);\n}\n\n/**\n * Establishes an SSL/TLS connection as an SSL/TLS Server, using the specified\n * context / settings object.\n *\n * The `uuid` should be a socket UUID that is already connected to a peer\n * (i.e., the result of `fio_accept`).\n *\n * The `udata` is an opaque user data pointer that is passed along to the\n * protocol selected (if any protocols were added using `fio_tls_alpn_add`).\n */\nvoid FIO_TLS_WEAK fio_tls_accept(intptr_t uuid, fio_tls_s *tls, void *udata) {\n  REQUIRE_LIBRARY();\n  fio_tls_attach2uuid(uuid, tls, udata, 1);\n}\n\n/**\n * Establishes an SSL/TLS connection as an SSL/TLS Client, using the specified\n * context / settings object.\n *\n * The `uuid` should be a socket UUID that is already connected to a peer\n * (i.e., one received by a `fio_connect` specified callback `on_connect`).\n *\n * The `udata` is an opaque user data pointer that is passed along to the\n * protocol selected (if any protocols were added using `fio_tls_alpn_add`).\n */\nvoid FIO_TLS_WEAK fio_tls_connect(intptr_t uuid, fio_tls_s *tls, void *udata) {\n  REQUIRE_LIBRARY();\n  fio_tls_attach2uuid(uuid, tls, udata, 0);\n}\n\n/**\n * Increase the reference count for the TLS object.\n *\n * Decrease with `fio_tls_destroy`.\n */\nvoid FIO_TLS_WEAK fio_tls_dup(fio_tls_s *tls) { fio_atomic_add(&tls->ref, 1); }\n\n/**\n * Destroys the SSL/TLS context / settings object and frees any related\n * resources / memory.\n */\nvoid FIO_TLS_WEAK fio_tls_destroy(fio_tls_s *tls) {\n  if (!tls)\n    return;\n  REQUIRE_LIBRARY();\n  if (fio_atomic_sub(&tls->ref, 1))\n    return;\n  fio_tls_destroy_context(tls);\n  alpn_list_free(&tls->alpn);\n  cert_ary_free(&tls->sni);\n  trust_ary_free(&tls->trust);\n  free(tls);\n}\n\n#endif /* Library compiler flags */\n", "#ifndef H_FIOBJ4SOCK_H\n#define H_FIOBJ4SOCK_H\n/**\n * Defines a helper for using fiobj with the sock library.\n */\n\n#include <fio.h>\n#include <fiobj.h>\n\nstatic void fiobj4sock_dealloc(void *o) { fiobj_free((FIOBJ)o); }\n\n/** send a FIOBJ  object through a socket. */\nstatic inline __attribute__((unused)) ssize_t fiobj_send_free(intptr_t uuid,\n                                                              FIOBJ o) {\n  fio_str_info_s s = fiobj_obj2cstr(o);\n  return fio_write2(uuid, .data.buffer = (void *)(o),\n                    .offset = (uintptr_t)(((intptr_t)s.data) - ((intptr_t)(o))),\n                    .length = s.len, .after.dealloc = fiobj4sock_dealloc);\n}\n\n#endif\n", "#ifndef H_FIOBJ_NUMBERS_H\n#define H_FIOBJ_NUMBERS_H\n/*\nCopyright: Boaz Segev, 2017-2019\nLicense: MIT\n*/\n\n#include <fiobject.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* *****************************************************************************\nNumbers API (Integers)\n***************************************************************************** */\n\n/** Creates a Number object. Remember to use `fiobj_free`. */\nFIO_INLINE FIOBJ fiobj_num_new(intptr_t num);\n\n/** Creates a temporary Number object. Avoid using `fiobj_free`. */\nFIOBJ fiobj_num_tmp(intptr_t num);\n\n/* *****************************************************************************\nFloat API (Double)\n***************************************************************************** */\n\n/** Creates a Float object. Remember to use `fiobj_free`.  */\nFIOBJ fiobj_float_new(double num);\n\n/** Mutates a Float object's value. Effects every object's reference!  */\nvoid fiobj_float_set(FIOBJ obj, double num);\n\n/** Creates a temporary Float object. Avoid using `fiobj_free`. */\nFIOBJ fiobj_float_tmp(double num);\n\n/* *****************************************************************************\nNumerical Helpers: not FIOBJ specific, but included as part of the library\n***************************************************************************** */\n\n/**\n * A helper function that converts between String data to a signed int64_t.\n *\n * Numbers are assumed to be in base 10.\n *\n * The `0x##` (or `x##`) and `0b##` (or `b##`) are recognized as base 16 and\n * base 2 (binary MSB first) respectively.\n *\n * The pointer will be updated to point to the first byte after the number.\n */\nint64_t fio_atol(char **pstr);\n\n/** A helper function that converts between String data to a signed double. */\ndouble fio_atof(char **pstr);\n\n/**\n * A helper function that converts between a signed int64_t to a string.\n *\n * No overflow guard is provided, make sure there's at least 66 bytes available\n * (for base 2).\n *\n * Supports base 2, base 10 and base 16. An unsupported base will silently\n * default to base 10. Prefixes aren't added (i.e., no \"0x\" or \"0b\" at the\n * beginning of the string).\n *\n * Returns the number of bytes actually written (excluding the NUL terminator).\n */\nsize_t fio_ltoa(char *dest, int64_t num, uint8_t base);\n\n/**\n * A helper function that converts between a double to a string.\n *\n * No overflow guard is provided, make sure there's at least 130 bytes available\n * (for base 2).\n *\n * Supports base 2, base 10 and base 16. An unsupported base will silently\n * default to base 10. Prefixes aren't added (i.e., no \"0x\" or \"0b\" at the\n * beginning of the string).\n *\n * Returns the number of bytes actually written (excluding the NUL terminator).\n */\nsize_t fio_ftoa(char *dest, double num, uint8_t base);\n\n/** Converts a number to a temporary, thread safe, C string object */\nfio_str_info_s __attribute__((deprecated(\"use local buffer with fio_ltoa\")))\nfio_ltocstr(long);\n\n/** Converts a float to a temporary, thread safe, C string object */\nfio_str_info_s __attribute__((deprecated(\"use local buffer with fio_ftoa\")))\nfio_ftocstr(double);\n\n/* *****************************************************************************\nPointer Wrapping Helper MACROs (uses integers)\n***************************************************************************** */\n\n#define fiobj_ptr_wrap(ptr) fiobj_num_new((uintptr_t)(ptr))\n#define fiobj_ptr_unwrap(obj) ((void *)fiobj_obj2num((obj)))\n\n/* *****************************************************************************\nInline Number Initialization\n***************************************************************************** */\n\nFIOBJ fiobj_num_new_bignum(intptr_t num);\n\n/** Creates a Number object. Remember to use `fiobj_free`. */\nFIO_INLINE FIOBJ fiobj_num_new(intptr_t num) {\n  if ((((uintptr_t)num &\n        (FIOBJ_NUMBER_SIGN_BIT | FIOBJ_NUMBER_SIGN_EXCLUDE_BIT)) == 0) ||\n      (((uintptr_t)num &\n        (FIOBJ_NUMBER_SIGN_BIT | FIOBJ_NUMBER_SIGN_EXCLUDE_BIT)) ==\n       (FIOBJ_NUMBER_SIGN_BIT | FIOBJ_NUMBER_SIGN_EXCLUDE_BIT))) {\n    const uintptr_t num_abs = (uintptr_t)num & FIOBJ_NUMBER_SIGN_MASK;\n    const uintptr_t num_sign = (uintptr_t)num & FIOBJ_NUMBER_SIGN_BIT;\n    return ((num_abs << 1) | num_sign | FIOBJECT_NUMBER_FLAG);\n  }\n  return fiobj_num_new_bignum(num);\n}\n\n#if DEBUG\nvoid fiobj_test_numbers(void);\n#endif\n\n#ifdef __cplusplus\n} /* extern \"C\" */\n#endif\n\n#endif\n", "/*\nCopyright: Boaz Segev, 2016-2019\nLicense: MIT\n\nFeel free to copy, use and enjoy according to the license provided.\n*/\n\n#include <fio.h>\n\n#include <http1.h>\n#include <http_internal.h>\n\n#include <ctype.h>\n#include <fcntl.h>\n#include <signal.h>\n#include <string.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#ifndef HAVE_TM_TM_ZONE\n#if defined(__FreeBSD__) || defined(__NetBSD__) || defined(__OpenBSD__) ||     \\\n    defined(__DragonFly__) || defined(__bsdi__) || defined(__ultrix) ||        \\\n    (defined(__APPLE__) && defined(__MACH__)) ||                               \\\n    (defined(__sun) && !defined(__SVR4))\n/* Known BSD systems */\n#define HAVE_TM_TM_ZONE 1\n#elif defined(__GLIBC__) && defined(_BSD_SOURCE)\n/* GNU systems with _BSD_SOURCE */\n#define HAVE_TM_TM_ZONE 1\n#else\n#define HAVE_TM_TM_ZONE 0\n#endif\n#endif\n\n/* *****************************************************************************\nSSL/TLS patch\n***************************************************************************** */\n\n/**\n * Adds an ALPN protocol callback to the SSL/TLS context.\n *\n * The first protocol added will act as the default protocol to be selected.\n */\nvoid __attribute__((weak))\nfio_tls_alpn_add(void *tls, const char *protocol_name,\n                 void (*callback)(intptr_t uuid, void *udata_connection,\n                                  void *udata_tls),\n                 void *udata_tls, void (*on_cleanup)(void *udata_tls)) {\n  FIO_LOG_FATAL(\"HTTP SSL/TLS required but unavailable!\");\n  exit(-1);\n  (void)tls;\n  (void)protocol_name;\n  (void)callback;\n  (void)on_cleanup;\n  (void)udata_tls;\n}\n#pragma weak fio_tls_alpn_add\n\n/* *****************************************************************************\nSmall Helpers\n***************************************************************************** */\nstatic inline int hex2byte(uint8_t *dest, const uint8_t *source);\n\nstatic inline void add_content_length(http_s *r, uintptr_t length) {\n  static uint64_t cl_hash = 0;\n  if (!cl_hash)\n    cl_hash = fiobj_hash_string(\"content-length\", 14);\n  if (!fiobj_hash_get2(r->private_data.out_headers, cl_hash)) {\n    fiobj_hash_set(r->private_data.out_headers, HTTP_HEADER_CONTENT_LENGTH,\n                   fiobj_num_new(length));\n  }\n}\nstatic inline void add_content_type(http_s *r) {\n  static uint64_t ct_hash = 0;\n  if (!ct_hash)\n    ct_hash = fiobj_hash_string(\"content-type\", 12);\n  if (!fiobj_hash_get2(r->private_data.out_headers, ct_hash)) {\n    fiobj_hash_set(r->private_data.out_headers, HTTP_HEADER_CONTENT_TYPE,\n                   http_mimetype_find2(r->path));\n  }\n}\n\nstatic FIOBJ current_date;\nstatic time_t last_date_added;\nstatic fio_lock_i date_lock;\nstatic inline void add_date(http_s *r) {\n  static uint64_t date_hash = 0;\n  if (!date_hash)\n    date_hash = fiobj_hash_string(\"date\", 4);\n  static uint64_t mod_hash = 0;\n  if (!mod_hash)\n    mod_hash = fiobj_hash_string(\"last-modified\", 13);\n\n  if (fio_last_tick().tv_sec > last_date_added) {\n    fio_lock(&date_lock);\n    if (fio_last_tick().tv_sec > last_date_added) { /* retest inside lock */\n      FIOBJ tmp = fiobj_str_buf(32);\n      FIOBJ old = current_date;\n      fiobj_str_resize(\n          tmp, http_time2str(fiobj_obj2cstr(tmp).data, fio_last_tick().tv_sec));\n      last_date_added = fio_last_tick().tv_sec;\n      current_date = tmp;\n      fiobj_free(old);\n    }\n    fio_unlock(&date_lock);\n  }\n\n  if (!fiobj_hash_get2(r->private_data.out_headers, date_hash)) {\n    fiobj_hash_set(r->private_data.out_headers, HTTP_HEADER_DATE,\n                   fiobj_dup(current_date));\n  }\n  if (r->status_str == FIOBJ_INVALID &&\n      !fiobj_hash_get2(r->private_data.out_headers, mod_hash)) {\n    fiobj_hash_set(r->private_data.out_headers, HTTP_HEADER_LAST_MODIFIED,\n                   fiobj_dup(current_date));\n  }\n}\n\nstruct header_writer_s {\n  FIOBJ dest;\n  FIOBJ name;\n  FIOBJ value;\n};\n\nstatic int write_header(FIOBJ o, void *w_) {\n  struct header_writer_s *w = w_;\n  if (!o)\n    return 0;\n  if (fiobj_hash_key_in_loop()) {\n    w->name = fiobj_hash_key_in_loop();\n  }\n  if (FIOBJ_TYPE_IS(o, FIOBJ_T_ARRAY)) {\n    fiobj_each1(o, 0, write_header, w);\n    return 0;\n  }\n  fio_str_info_s name = fiobj_obj2cstr(w->name);\n  fio_str_info_s str = fiobj_obj2cstr(o);\n  if (!str.data)\n    return 0;\n  fiobj_str_write(w->dest, name.data, name.len);\n  fiobj_str_write(w->dest, \":\", 1);\n  fiobj_str_write(w->dest, str.data, str.len);\n  fiobj_str_write(w->dest, \"\\r\\n\", 2);\n  return 0;\n}\n\nstatic char invalid_cookie_name_char[256];\n\nstatic char invalid_cookie_value_char[256];\n/* *****************************************************************************\nThe Request / Response type and functions\n***************************************************************************** */\nstatic const char hex_chars[] = {'0', '1', '2', '3', '4', '5', '6', '7',\n                                 '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};\n\n/**\n * Sets a response header, taking ownership of the value object, but NOT the\n * name object (so name objects could be reused in future responses).\n *\n * Returns -1 on error and 0 on success.\n */\nint http_set_header(http_s *r, FIOBJ name, FIOBJ value) {\n  if (HTTP_INVALID_HANDLE(r) || !name) {\n    fiobj_free(value);\n    return -1;\n  }\n  set_header_add(r->private_data.out_headers, name, value);\n  return 0;\n}\n/**\n * Sets a response header.\n *\n * Returns -1 on error and 0 on success.\n */\nint http_set_header2(http_s *r, fio_str_info_s n, fio_str_info_s v) {\n  if (HTTP_INVALID_HANDLE(r) || !n.data || !n.len || (v.data && !v.len))\n    return -1;\n  FIOBJ tmp = fiobj_str_new(n.data, n.len);\n  int ret = http_set_header(r, tmp, fiobj_str_new(v.data, v.len));\n  fiobj_free(tmp);\n  return ret;\n}\n\n/**\n * Sets a response cookie, taking ownership of the value object, but NOT the\n * name object (so name objects could be reused in future responses).\n *\n * Returns -1 on error and 0 on success.\n */\n#undef http_set_cookie\nint http_set_cookie(http_s *h, http_cookie_args_s cookie) {\n#if DEBUG\n  FIO_ASSERT(h, \"Can't set cookie for NULL HTTP handler!\");\n#endif\n  if (HTTP_INVALID_HANDLE(h) || cookie.name_len >= 32768 ||\n      cookie.value_len >= 131072) {\n    return -1;\n  }\n\n  static int warn_illegal = 0;\n\n  /* write name and value while auto-correcting encoding issues */\n  size_t capa = cookie.name_len + cookie.value_len + 128;\n  size_t len = 0;\n  FIOBJ c = fiobj_str_buf(capa);\n  fio_str_info_s t = fiobj_obj2cstr(c);\n\n#define copy_cookie_ch(ch_var)                                                 \\\n  if (invalid_cookie_##ch_var##_char[(uint8_t)cookie.ch_var[tmp]]) {           \\\n    if (!warn_illegal) {                                                       \\\n      ++warn_illegal;                                                          \\\n      FIO_LOG_WARNING(\"illegal char 0x%.2x in cookie \" #ch_var \" (in %s)\\n\"    \\\n                      \"         automatic %% encoding applied\",                \\\n                      cookie.ch_var[tmp], cookie.ch_var);                      \\\n    }                                                                          \\\n    t.data[len++] = '%';                                                       \\\n    t.data[len++] = hex_chars[((uint8_t)cookie.ch_var[tmp] >> 4) & 0x0F];      \\\n    t.data[len++] = hex_chars[(uint8_t)cookie.ch_var[tmp] & 0x0F];             \\\n  } else {                                                                     \\\n    t.data[len++] = cookie.ch_var[tmp];                                        \\\n  }                                                                            \\\n  tmp += 1;                                                                    \\\n  if (capa <= len + 3) {                                                       \\\n    capa += 32;                                                                \\\n    fiobj_str_capa_assert(c, capa);                                            \\\n    t = fiobj_obj2cstr(c);                                                     \\\n  }\n\n  if (cookie.name) {\n    size_t tmp = 0;\n    if (cookie.name_len) {\n      while (tmp < cookie.name_len) {\n        copy_cookie_ch(name);\n      }\n    } else {\n      while (cookie.name[tmp]) {\n        copy_cookie_ch(name);\n      }\n    }\n  }\n  t.data[len++] = '=';\n  if (cookie.value) {\n    size_t tmp = 0;\n    if (cookie.value_len) {\n      while (tmp < cookie.value_len) {\n        copy_cookie_ch(value);\n      }\n    } else {\n      while (cookie.value[tmp]) {\n        copy_cookie_ch(value);\n      }\n    }\n  } else\n    cookie.max_age = -1;\n\n  if (http_settings(h) && http_settings(h)->is_client) {\n    if (!cookie.value) {\n      fiobj_free(c);\n      return -1;\n    }\n    set_header_add(h->private_data.out_headers, HTTP_HEADER_COOKIE, c);\n    return 0;\n  }\n\n  t.data[len++] = ';';\n  t.data[len++] = ' ';\n\n  if (h->status_str || !h->status) { /* on first request status == 0 */\n    static uint64_t cookie_hash;\n    if (!cookie_hash)\n      cookie_hash = fiobj_hash_string(\"cookie\", 6);\n    FIOBJ tmp = fiobj_hash_get2(h->private_data.out_headers, cookie_hash);\n    if (!tmp) {\n      set_header_add(h->private_data.out_headers, HTTP_HEADER_COOKIE, c);\n    } else {\n      fiobj_str_join(tmp, c);\n      fiobj_free(c);\n    }\n    return 0;\n  }\n\n  if (capa <= len + 40) {\n    capa = len + 40;\n    fiobj_str_capa_assert(c, capa);\n    t = fiobj_obj2cstr(c);\n  }\n  if (cookie.max_age) {\n    memcpy(t.data + len, \"Max-Age=\", 8);\n    len += 8;\n    len += fio_ltoa(t.data + len, cookie.max_age, 10);\n    t.data[len++] = ';';\n    t.data[len++] = ' ';\n  }\n  fiobj_str_resize(c, len);\n\n  if (cookie.domain && cookie.domain_len) {\n    fiobj_str_write(c, \"domain=\", 7);\n    fiobj_str_write(c, cookie.domain, cookie.domain_len);\n    fiobj_str_write(c, \";\", 1);\n    t.data[len++] = ' ';\n  }\n  if (cookie.path && cookie.path_len) {\n    fiobj_str_write(c, \"path=\", 5);\n    fiobj_str_write(c, cookie.path, cookie.path_len);\n    fiobj_str_write(c, \";\", 1);\n    t.data[len++] = ' ';\n  }\n  if (cookie.http_only) {\n    fiobj_str_write(c, \"HttpOnly;\", 9);\n  }\n  if (cookie.secure) {\n    fiobj_str_write(c, \"secure;\", 7);\n  }\n  set_header_add(h->private_data.out_headers, HTTP_HEADER_SET_COOKIE, c);\n  return 0;\n}\n#define http_set_cookie(http__req__, ...)                                      \\\n  http_set_cookie((http__req__), (http_cookie_args_s){__VA_ARGS__})\n\n/**\n * Sends the response headers and body.\n *\n * Returns -1 on error and 0 on success.\n *\n * AFTER THIS FUNCTION IS CALLED, THE `http_s` OBJECT IS NO LONGER VALID.\n */\nint http_send_body(http_s *r, void *data, uintptr_t length) {\n  if (HTTP_INVALID_HANDLE(r))\n    return -1;\n  if (!length || !data) {\n    http_finish(r);\n    return 0;\n  }\n  add_content_length(r, length);\n  // add_content_type(r);\n  add_date(r);\n  return ((http_vtable_s *)r->private_data.vtbl)\n      ->http_send_body(r, data, length);\n}\n/**\n * Sends the response headers and the specified file (the response's body).\n *\n * Returns -1 on error and 0 on success.\n *\n * AFTER THIS FUNCTION IS CALLED, THE `http_s` OBJECT IS NO LONGER VALID.\n */\nint http_sendfile(http_s *r, int fd, uintptr_t length, uintptr_t offset) {\n  if (HTTP_INVALID_HANDLE(r)) {\n    close(fd);\n    return -1;\n  };\n  add_content_length(r, length);\n  add_content_type(r);\n  add_date(r);\n  return ((http_vtable_s *)r->private_data.vtbl)\n      ->http_sendfile(r, fd, length, offset);\n}\n\nstatic inline int http_test_encoded_path(const char *mem, size_t len) {\n  const char *pos = NULL;\n  const char *end = mem + len;\n  while (mem < end && (pos = memchr(mem, '/', (size_t)len))) {\n    len = end - pos;\n    mem = pos + 1;\n    if (pos[1] == '/')\n      return -1;\n    if (len > 3 && pos[1] == '.' && pos[2] == '.' && pos[3] == '/')\n      return -1;\n  }\n  return 0;\n}\n\n/**\n * Sends the response headers and the specified file (the response's body).\n *\n * Returns -1 eton error and 0 on success.\n *\n * AFTER THIS FUNCTION IS CALLED, THE `http_s` OBJECT IS NO LONGER VALID.\n */\nint http_sendfile2(http_s *h, const char *prefix, size_t prefix_len,\n                   const char *encoded, size_t encoded_len) {\n  if (HTTP_INVALID_HANDLE(h))\n    return -1;\n  struct stat file_data = {.st_size = 0};\n  static uint64_t accept_enc_hash = 0;\n  if (!accept_enc_hash)\n    accept_enc_hash = fiobj_hash_string(\"accept-encoding\", 15);\n  static uint64_t range_hash = 0;\n  if (!range_hash)\n    range_hash = fiobj_hash_string(\"range\", 5);\n\n  /* create filename string */\n  FIOBJ filename = fiobj_str_tmp();\n  if (prefix && prefix_len) {\n    /* start with prefix path */\n    if (encoded && prefix[prefix_len - 1] == '/' && encoded[0] == '/')\n      --prefix_len;\n    fiobj_str_capa_assert(filename, prefix_len + encoded_len + 4);\n    fiobj_str_write(filename, prefix, prefix_len);\n  }\n  {\n    /* decode filename in cases where it's URL encoded */\n    fio_str_info_s tmp = fiobj_obj2cstr(filename);\n    if (encoded) {\n      char *pos = (char *)encoded;\n      const char *end = encoded + encoded_len;\n      while (pos < end) {\n        if (*pos == '%') {\n          // decode hex value (this is a percent encoded value).\n          if (hex2byte((uint8_t *)tmp.data + tmp.len, (uint8_t *)pos + 1))\n            return -1;\n          tmp.len++;\n          pos += 3;\n        } else\n          tmp.data[tmp.len++] = *(pos++);\n      }\n      tmp.data[tmp.len] = 0;\n      fiobj_str_resize(filename, tmp.len);\n      /* test for path manipulations after decoding */\n      if (http_test_encoded_path(tmp.data + prefix_len, tmp.len - prefix_len))\n        return -1;\n    }\n    if (tmp.data[tmp.len - 1] == '/')\n      fiobj_str_write(filename, \"index.html\", 10);\n  }\n  /* test for file existance  */\n\n  int file = -1;\n  uint8_t is_gz = 0;\n\n  fio_str_info_s s = fiobj_obj2cstr(filename);\n  {\n    FIOBJ tmp = fiobj_hash_get2(h->headers, accept_enc_hash);\n    if (!tmp)\n      goto no_gzip_support;\n    fio_str_info_s ac_str = fiobj_obj2cstr(tmp);\n    if (!ac_str.data || !strstr(ac_str.data, \"gzip\"))\n      goto no_gzip_support;\n    if (s.data[s.len - 3] != '.' || s.data[s.len - 2] != 'g' ||\n        s.data[s.len - 1] != 'z') {\n      fiobj_str_write(filename, \".gz\", 3);\n      s = fiobj_obj2cstr(filename);\n      if (!stat(s.data, &file_data) &&\n          (S_ISREG(file_data.st_mode) || S_ISLNK(file_data.st_mode))) {\n        is_gz = 1;\n        goto found_file;\n      }\n      fiobj_str_resize(filename, s.len - 3);\n    }\n  }\nno_gzip_support:\n  if (stat(s.data, &file_data) ||\n      !(S_ISREG(file_data.st_mode) || S_ISLNK(file_data.st_mode)))\n    return -1;\nfound_file:\n  /* set last-modified */\n  {\n    FIOBJ tmp = fiobj_str_buf(32);\n    fiobj_str_resize(\n        tmp, http_time2str(fiobj_obj2cstr(tmp).data, file_data.st_mtime));\n    http_set_header(h, HTTP_HEADER_LAST_MODIFIED, tmp);\n  }\n  /* set cache-control */\n  http_set_header(h, HTTP_HEADER_CACHE_CONTROL, fiobj_dup(HTTP_HVALUE_MAX_AGE));\n  /* set & test etag */\n  uint64_t etag = (uint64_t)file_data.st_size;\n  etag ^= (uint64_t)file_data.st_mtime;\n  etag = fiobj_hash_string(&etag, sizeof(uint64_t));\n  FIOBJ etag_str = fiobj_str_buf(32);\n  fiobj_str_resize(etag_str,\n                   fio_base64_encode(fiobj_obj2cstr(etag_str).data,\n                                     (void *)&etag, sizeof(uint64_t)));\n  /* set */\n  http_set_header(h, HTTP_HEADER_ETAG, etag_str);\n  /* test */\n  {\n    static uint64_t none_match_hash = 0;\n    if (!none_match_hash)\n      none_match_hash = fiobj_hash_string(\"if-none-match\", 13);\n    FIOBJ tmp2 = fiobj_hash_get2(h->headers, none_match_hash);\n    if (tmp2 && fiobj_iseq(tmp2, etag_str)) {\n      h->status = 304;\n      http_finish(h);\n      return 0;\n    }\n  }\n  /* handle range requests */\n  int64_t offset = 0;\n  int64_t length = file_data.st_size;\n  {\n    static uint64_t ifrange_hash = 0;\n    if (!ifrange_hash)\n      ifrange_hash = fiobj_hash_string(\"if-range\", 8);\n    FIOBJ tmp = fiobj_hash_get2(h->headers, ifrange_hash);\n    if (tmp && fiobj_iseq(tmp, etag_str)) {\n      fiobj_hash_delete2(h->headers, range_hash);\n    } else {\n      tmp = fiobj_hash_get2(h->headers, range_hash);\n      if (tmp) {\n        /* range ahead... */\n        if (FIOBJ_TYPE_IS(tmp, FIOBJ_T_ARRAY))\n          tmp = fiobj_ary_index(tmp, 0);\n        fio_str_info_s range = fiobj_obj2cstr(tmp);\n        if (!range.data || memcmp(\"bytes=\", range.data, 6))\n          goto open_file;\n        char *pos = range.data + 6;\n        int64_t start_at = 0, end_at = 0;\n        start_at = fio_atol(&pos);\n        if (start_at >= file_data.st_size)\n          goto open_file;\n        if (start_at >= 0) {\n          pos++;\n          end_at = fio_atol(&pos);\n          if (end_at <= 0)\n            goto open_file;\n        }\n        /* we ignore multimple ranges, only responding with the first range. */\n        if (start_at < 0) {\n          if (0 - start_at < file_data.st_size) {\n            offset = file_data.st_size - start_at;\n            length = 0 - start_at;\n          }\n        } else if (end_at) {\n          offset = start_at;\n          length = end_at - start_at + 1;\n          if (length + start_at > file_data.st_size || length <= 0)\n            length = length - start_at;\n        } else {\n          offset = start_at;\n          length = length - start_at;\n        }\n        h->status = 206;\n\n        {\n          FIOBJ cranges = fiobj_str_buf(1);\n          fiobj_str_printf(cranges, \"bytes %lu-%lu/%lu\",\n                           (unsigned long)start_at,\n                           (unsigned long)(start_at + length - 1),\n                           (unsigned long)file_data.st_size);\n          http_set_header(h, HTTP_HEADER_CONTENT_RANGE, cranges);\n        }\n        http_set_header(h, HTTP_HEADER_ACCEPT_RANGES,\n                        fiobj_dup(HTTP_HVALUE_BYTES));\n      }\n    }\n  }\n  /* test for an OPTIONS request or invalid methods */\n  s = fiobj_obj2cstr(h->method);\n  switch (s.len) {\n  case 7:\n    if (!strncasecmp(\"options\", s.data, 7)) {\n      http_set_header2(h, (fio_str_info_s){.data = (char *)\"allow\", .len = 5},\n                       (fio_str_info_s){.data = (char *)\"GET, HEAD\", .len = 9});\n      h->status = 200;\n      http_finish(h);\n      return 0;\n    }\n    break;\n  case 3:\n    if (!strncasecmp(\"get\", s.data, 3))\n      goto open_file;\n    break;\n  case 4:\n    if (!strncasecmp(\"head\", s.data, 4)) {\n      http_set_header(h, HTTP_HEADER_CONTENT_LENGTH, fiobj_num_new(length));\n      http_finish(h);\n      return 0;\n    }\n    break;\n  }\n  http_send_error(h, 403);\n  return 0;\nopen_file:\n  s = fiobj_obj2cstr(filename);\n  file = open(s.data, O_RDONLY);\n  if (file == -1) {\n    FIO_LOG_ERROR(\"(HTTP) couldn't open file %s!\\n\", s.data);\n    perror(\"     \");\n    http_send_error(h, 500);\n    return 0;\n  }\n  {\n    FIOBJ tmp = 0;\n    uintptr_t pos = 0;\n    if (is_gz) {\n      http_set_header(h, HTTP_HEADER_CONTENT_ENCODING,\n                      fiobj_dup(HTTP_HVALUE_GZIP));\n\n      pos = s.len - 4;\n      while (pos && s.data[pos] != '.')\n        pos--;\n      pos++; /* assuming, but that's fine. */\n      tmp = http_mimetype_find(s.data + pos, s.len - pos - 3);\n\n    } else {\n      pos = s.len - 1;\n      while (pos && s.data[pos] != '.')\n        pos--;\n      pos++; /* assuming, but that's fine. */\n      tmp = http_mimetype_find(s.data + pos, s.len - pos);\n    }\n    if (tmp)\n      http_set_header(h, HTTP_HEADER_CONTENT_TYPE, tmp);\n  }\n  http_sendfile(h, file, length, offset);\n  return 0;\n}\n\n/**\n * Sends an HTTP error response.\n *\n * Returns -1 on error and 0 on success.\n *\n * AFTER THIS FUNCTION IS CALLED, THE `http_s` OBJECT IS NO LONGER VALID.\n *\n * The `uuid` argument is optional and will be used only if the `http_s`\n * argument is set to NULL.\n */\nint http_send_error(http_s *r, size_t error) {\n  if (!r || !r->private_data.out_headers) {\n    return -1;\n  }\n  if (error < 100 || error >= 1000)\n    error = 500;\n  r->status = error;\n  char buffer[16];\n  buffer[0] = '/';\n  size_t pos = 1 + fio_ltoa(buffer + 1, error, 10);\n  buffer[pos++] = '.';\n  buffer[pos++] = 'h';\n  buffer[pos++] = 't';\n  buffer[pos++] = 'm';\n  buffer[pos++] = 'l';\n  buffer[pos] = 0;\n  if (http_sendfile2(r, http2protocol(r)->settings->public_folder,\n                     http2protocol(r)->settings->public_folder_length, buffer,\n                     pos)) {\n    http_set_header(r, HTTP_HEADER_CONTENT_TYPE,\n                    http_mimetype_find((char *)\"txt\", 3));\n    fio_str_info_s t = http_status2str(error);\n    http_send_body(r, t.data, t.len);\n  }\n  return 0;\n}\n\n/**\n * Sends the response headers for a header only response.\n *\n * AFTER THIS FUNCTION IS CALLED, THE `http_s` OBJECT IS NO LONGER VALID.\n */\nvoid http_finish(http_s *r) {\n  if (!r || !r->private_data.vtbl) {\n    return;\n  }\n  add_content_length(r, 0);\n  add_date(r);\n  ((http_vtable_s *)r->private_data.vtbl)->http_finish(r);\n}\n/**\n * Pushes a data response when supported (HTTP/2 only).\n *\n * Returns -1 on error and 0 on success.\n */\nint http_push_data(http_s *r, void *data, uintptr_t length, FIOBJ mime_type) {\n  if (!r || !(http_fio_protocol_s *)r->private_data.flag)\n    return -1;\n  return ((http_vtable_s *)r->private_data.vtbl)\n      ->http_push_data(r, data, length, mime_type);\n}\n/**\n * Pushes a file response when supported (HTTP/2 only).\n *\n * If `mime_type` is NULL, an attempt at automatic detection using\n * `filename` will be made.\n *\n * Returns -1 on error and 0 on success.\n */\nint http_push_file(http_s *h, FIOBJ filename, FIOBJ mime_type) {\n  if (HTTP_INVALID_HANDLE(h))\n    return -1;\n  return ((http_vtable_s *)h->private_data.vtbl)\n      ->http_push_file(h, filename, mime_type);\n}\n\n/**\n * Upgrades an HTTP/1.1 connection to a Websocket connection.\n */\n#undef http_upgrade2ws\nint http_upgrade2ws(http_s *h, websocket_settings_s args) {\n  if (!h) {\n    FIO_LOG_ERROR(\"`http_upgrade2ws` requires a valid `http_s` handle.\");\n    goto error;\n  }\n  if (HTTP_INVALID_HANDLE(h))\n    goto error;\n  return ((http_vtable_s *)h->private_data.vtbl)->http2websocket(h, &args);\nerror:\n  if (args.on_close)\n    args.on_close(-1, args.udata);\n  return -1;\n}\n\n/* *****************************************************************************\nPause / Resume\n***************************************************************************** */\nstruct http_pause_handle_s {\n  uintptr_t uuid;\n  http_s *h;\n  void *udata;\n  void (*task)(http_s *);\n  void (*fallback)(void *);\n};\n\n/** Returns the `udata` associated with the paused opaque handle */\nvoid *http_paused_udata_get(http_pause_handle_s *http) { return http->udata; }\n\n/**\n * Sets the `udata` associated with the paused opaque handle, returning the\n * old value.\n */\nvoid *http_paused_udata_set(http_pause_handle_s *http, void *udata) {\n  void *old = http->udata;\n  http->udata = udata;\n  return old;\n}\n\n/* perform the pause task outside of the connection's lock */\nstatic void http_pause_wrapper(void *h_, void *task_) {\n  void (*task)(void *h) = (void (*)(void *h))((uintptr_t)task_);\n  task(h_);\n}\n\n/* perform the resume task within of the connection's lock */\nstatic void http_resume_wrapper(intptr_t uuid, fio_protocol_s *p_, void *arg) {\n  http_fio_protocol_s *p = (http_fio_protocol_s *)p_;\n  http_pause_handle_s *http = arg;\n  http_s *h = http->h;\n  h->udata = http->udata;\n  http_vtable_s *vtbl = (http_vtable_s *)h->private_data.vtbl;\n  if (http->task)\n    http->task(h);\n  vtbl->http_on_resume(h, p);\n  fio_free(http);\n  (void)uuid;\n}\n\n/* perform the resume task fallback */\nstatic void http_resume_fallback_wrapper(intptr_t uuid, void *arg) {\n  http_pause_handle_s *http = arg;\n  if (http->fallback)\n    http->fallback(http->udata);\n  fio_free(http);\n  (void)uuid;\n}\n\n/**\n * Defers the request / response handling for later.\n */\nvoid http_pause(http_s *h, void (*task)(http_pause_handle_s *http)) {\n  if (HTTP_INVALID_HANDLE(h)) {\n    return;\n  }\n  http_fio_protocol_s *p = (http_fio_protocol_s *)h->private_data.flag;\n  http_vtable_s *vtbl = (http_vtable_s *)h->private_data.vtbl;\n  http_pause_handle_s *http = fio_malloc(sizeof(*http));\n  *http = (http_pause_handle_s){\n      .uuid = p->uuid,\n      .h = h,\n      .udata = h->udata,\n  };\n  vtbl->http_on_pause(h, p);\n  fio_defer(http_pause_wrapper, http, (void *)((uintptr_t)task));\n}\n\n/**\n * Defers the request / response handling for later.\n */\nvoid http_resume(http_pause_handle_s *http, void (*task)(http_s *h),\n                 void (*fallback)(void *udata)) {\n  if (!http)\n    return;\n  http->task = task;\n  http->fallback = fallback;\n  fio_defer_io_task(http->uuid, .udata = http, .type = FIO_PR_LOCK_TASK,\n                    .task = http_resume_wrapper,\n                    .fallback = http_resume_fallback_wrapper);\n}\n\n/**\n * Hijacks the socket away from the HTTP protocol and away from facil.io.\n */\nintptr_t http_hijack(http_s *h, fio_str_info_s *leftover) {\n  if (!h)\n    return -1;\n  return ((http_vtable_s *)h->private_data.vtbl)->http_hijack(h, leftover);\n}\n\n/* *****************************************************************************\nSetting the default settings and allocating a persistent copy\n***************************************************************************** */\n\nstatic void http_on_request_fallback(http_s *h) { http_send_error(h, 404); }\nstatic void http_on_upgrade_fallback(http_s *h, char *p, size_t i) {\n  http_send_error(h, 400);\n  (void)p;\n  (void)i;\n}\nstatic void http_on_response_fallback(http_s *h) { http_send_error(h, 400); }\n\nstatic http_settings_s *http_settings_new(http_settings_s arg_settings) {\n  /* TODO: improve locality by unifying malloc to a single call */\n  if (!arg_settings.on_request)\n    arg_settings.on_request = http_on_request_fallback;\n  if (!arg_settings.on_response)\n    arg_settings.on_response = http_on_response_fallback;\n  if (!arg_settings.on_upgrade)\n    arg_settings.on_upgrade = http_on_upgrade_fallback;\n\n  if (!arg_settings.max_body_size)\n    arg_settings.max_body_size = HTTP_DEFAULT_BODY_LIMIT;\n  if (!arg_settings.timeout)\n    arg_settings.timeout = 40;\n  if (!arg_settings.ws_max_msg_size)\n    arg_settings.ws_max_msg_size = 262144; /** defaults to ~250KB */\n  if (!arg_settings.ws_timeout)\n    arg_settings.ws_timeout = 40; /* defaults to 40 seconds */\n  if (!arg_settings.max_header_size)\n    arg_settings.max_header_size = 32 * 1024; /* defaults to 32Kib seconds */\n  if (arg_settings.max_clients <= 0 ||\n      (size_t)(arg_settings.max_clients + HTTP_BUSY_UNLESS_HAS_FDS) >\n          fio_capa()) {\n    arg_settings.max_clients = fio_capa();\n    if ((ssize_t)arg_settings.max_clients - HTTP_BUSY_UNLESS_HAS_FDS > 0)\n      arg_settings.max_clients -= HTTP_BUSY_UNLESS_HAS_FDS;\n  }\n\n  http_settings_s *settings = malloc(sizeof(*settings) + sizeof(void *));\n  *settings = arg_settings;\n\n  if (settings->public_folder) {\n    settings->public_folder_length = strlen(settings->public_folder);\n    if (settings->public_folder[0] == '~' &&\n        settings->public_folder[1] == '/' && getenv(\"HOME\")) {\n      char *home = getenv(\"HOME\");\n      size_t home_len = strlen(home);\n      char *tmp = malloc(settings->public_folder_length + home_len + 1);\n      memcpy(tmp, home, home_len);\n      if (home[home_len - 1] == '/')\n        --home_len;\n      memcpy(tmp + home_len, settings->public_folder + 1,\n             settings->public_folder_length); // copy also the NULL\n      settings->public_folder = tmp;\n      settings->public_folder_length = strlen(settings->public_folder);\n    } else {\n      settings->public_folder = malloc(settings->public_folder_length + 1);\n      memcpy((void *)settings->public_folder, arg_settings.public_folder,\n             settings->public_folder_length);\n      ((uint8_t *)settings->public_folder)[settings->public_folder_length] = 0;\n    }\n  }\n  return settings;\n}\n\nstatic void http_settings_free(http_settings_s *s) {\n  free((void *)s->public_folder);\n  free(s);\n}\n/* *****************************************************************************\nListening to HTTP connections\n***************************************************************************** */\n\nstatic uint8_t fio_http_at_capa = 0;\n\nstatic void http_on_server_protocol_http1(intptr_t uuid, void *set,\n                                          void *ignr_) {\n  fio_timeout_set(uuid, ((http_settings_s *)set)->timeout);\n  if (fio_uuid2fd(uuid) >= ((http_settings_s *)set)->max_clients) {\n    if (!fio_http_at_capa)\n      FIO_LOG_WARNING(\"HTTP server at capacity\");\n    fio_http_at_capa = 1;\n    http_send_error2(uuid, 503, set);\n    fio_close(uuid);\n    return;\n  }\n  fio_http_at_capa = 0;\n  fio_protocol_s *pr = http1_new(uuid, set, NULL, 0);\n  if (!pr)\n    fio_close(uuid);\n  (void)ignr_;\n}\n\nstatic void http_on_open(intptr_t uuid, void *set) {\n  http_on_server_protocol_http1(uuid, set, NULL);\n}\n\nstatic void http_on_finish(intptr_t uuid, void *set) {\n  http_settings_s *settings = set;\n\n  if (settings->on_finish)\n    settings->on_finish(settings);\n\n  http_settings_free(settings);\n  (void)uuid;\n}\n\n/**\n * Listens to HTTP connections at the specified `port`.\n *\n * Leave as NULL to ignore IP binding.\n *\n * Returns -1 on error and 0 on success.\n */\n#undef http_listen\nintptr_t http_listen(const char *port, const char *binding,\n                     struct http_settings_s arg_settings) {\n  if (arg_settings.on_request == NULL) {\n    FIO_LOG_ERROR(\"http_listen requires the .on_request parameter \"\n                  \"to be set\\n\");\n    kill(0, SIGINT);\n    exit(11);\n  }\n\n  http_settings_s *settings = http_settings_new(arg_settings);\n  settings->is_client = 0;\n  if (settings->tls) {\n    fio_tls_alpn_add(settings->tls, \"http/1.1\", http_on_server_protocol_http1,\n                     NULL, NULL);\n  }\n\n  return fio_listen(.port = port, .address = binding, .tls = arg_settings.tls,\n                    .on_finish = http_on_finish, .on_open = http_on_open,\n                    .udata = settings);\n}\n/** Listens to HTTP connections at the specified `port` and `binding`. */\n#define http_listen(port, binding, ...)                                        \\\n  http_listen((port), (binding), (struct http_settings_s)(__VA_ARGS__))\n\n/**\n * Returns the settings used to setup the connection.\n *\n * Returns NULL on error (i.e., connection was lost).\n */\nstruct http_settings_s *http_settings(http_s *r) {\n  return ((http_fio_protocol_s *)r->private_data.flag)->settings;\n}\n\n/**\n * Returns the direct address of the connected peer (likely an intermediary).\n */\nfio_str_info_s http_peer_addr(http_s *h) {\n  return fio_peer_addr(((http_fio_protocol_s *)h->private_data.flag)->uuid);\n}\n\n/* *****************************************************************************\nHTTP client connections\n***************************************************************************** */\n\nstatic void http_on_close_client(intptr_t uuid, fio_protocol_s *protocol) {\n  http_fio_protocol_s *p = (http_fio_protocol_s *)protocol;\n  http_settings_s *set = p->settings;\n  void (**original)(intptr_t, fio_protocol_s *) =\n      (void (**)(intptr_t, fio_protocol_s *))(set + 1);\n  if (set->on_finish)\n    set->on_finish(set);\n\n  original[0](uuid, protocol);\n  http_settings_free(set);\n}\n\nstatic void http_on_open_client_perform(http_settings_s *set) {\n  http_s *h = set->udata;\n  set->on_response(h);\n}\nstatic void http_on_open_client_http1(intptr_t uuid, void *set_,\n                                      void *ignore_) {\n  http_settings_s *set = set_;\n  http_s *h = set->udata;\n  fio_timeout_set(uuid, set->timeout);\n  fio_protocol_s *pr = http1_new(uuid, set, NULL, 0);\n  if (!pr) {\n    fio_close(uuid);\n    return;\n  }\n  { /* store the original on_close at the end of the struct, we wrap it. */\n    void (**original)(intptr_t, fio_protocol_s *) =\n        (void (**)(intptr_t, fio_protocol_s *))(set + 1);\n    *original = pr->on_close;\n    pr->on_close = http_on_close_client;\n  }\n  h->private_data.flag = (uintptr_t)pr;\n  h->private_data.vtbl = http1_vtable();\n  http_on_open_client_perform(set);\n  (void)ignore_;\n}\n\nstatic void http_on_open_client(intptr_t uuid, void *set_) {\n  http_on_open_client_http1(uuid, set_, NULL);\n}\n\nstatic void http_on_client_failed(intptr_t uuid, void *set_) {\n  http_settings_s *set = set_;\n  http_s *h = set->udata;\n  set->udata = h->udata;\n  http_s_destroy(h, 0);\n  fio_free(h);\n  if (set->on_finish)\n    set->on_finish(set);\n  http_settings_free(set);\n  (void)uuid;\n}\n\nintptr_t http_connect__(void); /* sublime text marker */\n/**\n * Connects to an HTTP server as a client.\n *\n * Upon a successful connection, the `on_response` callback is called with an\n * empty `http_s*` handler (status == 0). Use the same API to set it's content\n * and send the request to the server. The next`on_response` will contain the\n * response.\n *\n * `address` should contain a full URL style address for the server. i.e.:\n *           \"http:/www.example.com:8080/\"\n *\n * Returns -1 on error and 0 on success. the `on_finish` callback is always\n * called.\n */\nintptr_t http_connect FIO_IGNORE_MACRO(const char *url,\n                                       const char *unix_address,\n                                       struct http_settings_s arg_settings) {\n  if (!arg_settings.on_response && !arg_settings.on_upgrade) {\n    FIO_LOG_ERROR(\"http_connect requires either an on_response \"\n                  \" or an on_upgrade callback.\\n\");\n    errno = EINVAL;\n    goto on_error;\n  }\n  size_t len = 0, h_len = 0;\n  char *a = NULL, *p = NULL, *host = NULL;\n  uint8_t is_websocket = 0;\n  uint8_t is_secure = 0;\n  FIOBJ path = FIOBJ_INVALID;\n  if (!url && !unix_address) {\n    FIO_LOG_ERROR(\"http_connect requires a valid address.\");\n    errno = EINVAL;\n    goto on_error;\n  }\n  if (url) {\n    fio_url_s u = fio_url_parse(url, strlen(url));\n    if (u.scheme.data &&\n        (u.scheme.len == 2 || (u.scheme.len == 3 && u.scheme.data[2] == 's')) &&\n        u.scheme.data[0] == 'w' && u.scheme.data[1] == 's') {\n      is_websocket = 1;\n      is_secure = (u.scheme.len == 3);\n    } else if (u.scheme.data &&\n               (u.scheme.len == 4 ||\n                (u.scheme.len == 5 && u.scheme.data[4] == 's')) &&\n               u.scheme.data[0] == 'h' && u.scheme.data[1] == 't' &&\n               u.scheme.data[2] == 't' && u.scheme.data[3] == 'p') {\n      is_secure = (u.scheme.len == 5);\n    }\n    if (is_secure && !arg_settings.tls) {\n      FIO_LOG_ERROR(\"Secure connections (%.*s) require a TLS object.\",\n                    (int)u.scheme.len, u.scheme.data);\n      errno = EINVAL;\n      goto on_error;\n    }\n    if (u.path.data) {\n      path = fiobj_str_new(\n          u.path.data, strlen(u.path.data)); /* copy query and target as well */\n    }\n    if (unix_address) {\n      a = (char *)unix_address;\n      h_len = len = strlen(a);\n      host = a;\n    } else {\n      if (!u.host.data) {\n        FIO_LOG_ERROR(\"http_connect requires a valid address.\");\n        errno = EINVAL;\n        goto on_error;\n      }\n      /***** no more error handling, since memory is allocated *****/\n      /* copy address */\n      a = fio_malloc(u.host.len + 1);\n      memcpy(a, u.host.data, u.host.len);\n      a[u.host.len] = 0;\n      len = u.host.len;\n      /* copy port */\n      if (u.port.data) {\n        p = fio_malloc(u.port.len + 1);\n        memcpy(p, u.port.data, u.port.len);\n        p[u.port.len] = 0;\n      } else if (is_secure) {\n        p = fio_malloc(3 + 1);\n        memcpy(p, \"443\", 3);\n        p[3] = 0;\n      } else {\n        p = fio_malloc(2 + 1);\n        memcpy(p, \"80\", 2);\n        p[2] = 0;\n      }\n    }\n    if (u.host.data) {\n      host = u.host.data;\n      h_len = u.host.len;\n    }\n  }\n\n  /* set settings */\n  if (!arg_settings.timeout)\n    arg_settings.timeout = 30;\n  http_settings_s *settings = http_settings_new(arg_settings);\n  settings->is_client = 1;\n  // if (settings->tls) {\n  //   fio_tls_alpn_add(settings->tls, \"http/1.1\", http_on_open_client_http1,\n  //                     NULL, NULL);\n  // }\n\n  if (!arg_settings.ws_timeout)\n    settings->ws_timeout = 0; /* allow server to dictate timeout */\n  if (!arg_settings.timeout)\n    settings->timeout = 0; /* allow server to dictate timeout */\n  http_s *h = fio_malloc(sizeof(*h));\n  FIO_ASSERT(h, \"HTTP Client handler allocation failed\");\n  http_s_new(h, 0, http1_vtable());\n  h->udata = arg_settings.udata;\n  h->status = 0;\n  h->path = path;\n  settings->udata = h;\n  settings->tls = arg_settings.tls;\n  if (host)\n    http_set_header2(h, (fio_str_info_s){.data = (char *)\"host\", .len = 4},\n                     (fio_str_info_s){.data = host, .len = h_len});\n  intptr_t ret;\n  if (is_websocket) {\n    /* force HTTP/1.1 */\n    ret = fio_connect(.address = a, .port = p, .on_fail = http_on_client_failed,\n                      .on_connect = http_on_open_client, .udata = settings,\n                      .tls = arg_settings.tls);\n    (void)0;\n  } else {\n    /* Allow for any HTTP version */\n    ret = fio_connect(.address = a, .port = p, .on_fail = http_on_client_failed,\n                      .on_connect = http_on_open_client, .udata = settings,\n                      .tls = arg_settings.tls);\n    (void)0;\n  }\n  if (a != unix_address)\n    fio_free(a);\n  fio_free(p);\n  return ret;\non_error:\n  if (arg_settings.on_finish)\n    arg_settings.on_finish(&arg_settings);\n  return -1;\n}\n\n/* *****************************************************************************\nHTTP Websocket Connect\n***************************************************************************** */\n\n#undef http_upgrade2ws\nstatic void on_websocket_http_connected(http_s *h) {\n  websocket_settings_s *s = h->udata;\n  h->udata = http_settings(h)->udata = NULL;\n  if (!h->path) {\n    FIO_LOG_WARNING(\"(websocket client) path not specified in \"\n                    \"address, assuming root!\");\n    h->path = fiobj_str_new(\"/\", 1);\n  }\n  http_upgrade2ws(h, *s);\n  fio_free(s);\n}\n\nstatic void on_websocket_http_connection_finished(http_settings_s *settings) {\n  websocket_settings_s *s = settings->udata;\n  if (s) {\n    if (s->on_close)\n      s->on_close(0, s->udata);\n    fio_free(s);\n  }\n}\n\n#undef websocket_connect\nint websocket_connect(const char *address, websocket_settings_s settings) {\n  websocket_settings_s *s = fio_malloc(sizeof(*s));\n  *s = settings;\n  return http_connect(address, NULL, .on_request = on_websocket_http_connected,\n                      .on_response = on_websocket_http_connected,\n                      .on_finish = on_websocket_http_connection_finished,\n                      .udata = s);\n}\n#define websocket_connect(address, ...)                                        \\\n  websocket_connect((address), (websocket_settings_s){__VA_ARGS__})\n\n/* *****************************************************************************\nEventSource Support (SSE)\n\nNote:\n\n* `http_sse_subscribe` and `http_sse_unsubscribe` are implemented in the\n  http_internal logical unit.\n\n***************************************************************************** */\n\nstatic inline void http_sse_copy2str(FIOBJ dest, char *prefix, size_t pre_len,\n                                     fio_str_info_s data) {\n  if (!data.len)\n    return;\n  const char *stop = data.data + data.len;\n  while (data.len) {\n    fiobj_str_write(dest, prefix, pre_len);\n    char *pos = data.data;\n    while (pos < stop && *pos != '\\n' && *pos != '\\r')\n      ++pos;\n    fiobj_str_write(dest, data.data, (uintptr_t)(pos - data.data));\n    fiobj_str_write(dest, \"\\r\\n\", 2);\n    if (*pos == '\\r')\n      ++pos;\n    if (*pos == '\\n')\n      ++pos;\n    data.len -= (uintptr_t)(pos - data.data);\n    data.data = pos;\n  }\n}\n\n/** The on message callback. the `*msg` pointer is to a temporary object. */\nstatic void http_sse_on_message(fio_msg_s *msg) {\n  http_sse_internal_s *sse = msg->udata1;\n  struct http_sse_subscribe_args *args = msg->udata2;\n  /* perform a callback */\n  fio_protocol_s *pr = fio_protocol_try_lock(sse->uuid, FIO_PR_LOCK_TASK);\n  if (!pr)\n    goto postpone;\n  args->on_message(&sse->sse, msg->channel, msg->msg, args->udata);\n  fio_protocol_unlock(pr, FIO_PR_LOCK_TASK);\n  return;\npostpone:\n  if (errno == EBADF)\n    return;\n  fio_message_defer(msg);\n  return;\n}\n\nstatic void http_sse_on_message__direct(http_sse_s *sse, fio_str_info_s channel,\n                                        fio_str_info_s msg, void *udata) {\n  http_sse_write(sse, .data = msg);\n  (void)udata;\n  (void)channel;\n}\n/** An optional callback for when a subscription is fully canceled. */\nstatic void http_sse_on_unsubscribe(void *sse_, void *args_) {\n  http_sse_internal_s *sse = sse_;\n  struct http_sse_subscribe_args *args = args_;\n  if (args->on_unsubscribe)\n    args->on_unsubscribe(args->udata);\n  fio_free(args);\n  http_sse_try_free(sse);\n}\n\n/** This macro allows easy access to the `http_sse_subscribe` function. */\n#undef http_sse_subscribe\n/**\n * Subscribes to a channel. See {struct http_sse_subscribe_args} for possible\n * arguments.\n *\n * Returns a subscription ID on success and 0 on failure.\n *\n * All subscriptions are automatically revoked once the connection is closed.\n *\n * If the connections subscribes to the same channel more than once, messages\n * will be merged. However, another subscription ID will be assigned, and two\n * calls to {http_sse_unsubscribe} will be required in order to unregister from\n * the channel.\n */\nuintptr_t http_sse_subscribe(http_sse_s *sse_,\n                             struct http_sse_subscribe_args args) {\n  http_sse_internal_s *sse = FIO_LS_EMBD_OBJ(http_sse_internal_s, sse, sse_);\n  if (sse->uuid == -1)\n    return 0;\n  if (!args.on_message)\n    args.on_message = http_sse_on_message__direct;\n  struct http_sse_subscribe_args *udata = fio_malloc(sizeof(*udata));\n  FIO_ASSERT_ALLOC(udata);\n  *udata = args;\n\n  fio_atomic_add(&sse->ref, 1);\n  subscription_s *sub =\n      fio_subscribe(.channel = args.channel, .on_message = http_sse_on_message,\n                    .on_unsubscribe = http_sse_on_unsubscribe, .udata1 = sse,\n                    .udata2 = udata, .match = args.match);\n  if (!sub)\n    return 0;\n\n  fio_lock(&sse->lock);\n  fio_ls_s *pos = fio_ls_push(&sse->subscriptions, sub);\n  fio_unlock(&sse->lock);\n  return (uintptr_t)pos;\n}\n\n/**\n * Cancels a subscription and invalidates the subscription object.\n */\nvoid http_sse_unsubscribe(http_sse_s *sse_, uintptr_t subscription) {\n  if (!sse_ || !subscription)\n    return;\n  http_sse_internal_s *sse = FIO_LS_EMBD_OBJ(http_sse_internal_s, sse, sse_);\n  subscription_s *sub = (subscription_s *)((fio_ls_s *)subscription)->obj;\n  fio_lock(&sse->lock);\n  fio_ls_remove((fio_ls_s *)subscription);\n  fio_unlock(&sse->lock);\n  fio_unsubscribe(sub);\n}\n\n#undef http_upgrade2sse\n/**\n * Upgrades an HTTP connection to an EventSource (SSE) connection.\n *\n * Thie `http_s` handle will be invalid after this call.\n *\n * On HTTP/1.1 connections, this will preclude future requests using the same\n * connection.\n */\nint http_upgrade2sse(http_s *h, http_sse_s sse) {\n  if (HTTP_INVALID_HANDLE(h)) {\n    if (sse.on_close)\n      sse.on_close(&sse);\n    return -1;\n  }\n  return ((http_vtable_s *)h->private_data.vtbl)->http_upgrade2sse(h, &sse);\n}\n\n/**\n * Sets the ping interval for SSE connections.\n */\nvoid http_sse_set_timout(http_sse_s *sse_, uint8_t timeout) {\n  if (!sse_)\n    return;\n  http_sse_internal_s *sse = FIO_LS_EMBD_OBJ(http_sse_internal_s, sse, sse_);\n  fio_timeout_set(sse->uuid, timeout);\n}\n\n#undef http_sse_write\n/**\n * Writes data to an EventSource (SSE) connection.\n */\nint http_sse_write(http_sse_s *sse, struct http_sse_write_args args) {\n  if (!sse || !(args.id.len + args.data.len + args.event.len) ||\n      fio_is_closed(FIO_LS_EMBD_OBJ(http_sse_internal_s, sse, sse)->uuid))\n    return -1;\n  FIOBJ buf;\n  {\n    /* best guess at data length, ignoring missing fields and multiline data */\n    const size_t total = 4 + args.id.len + 2 + 7 + args.event.len + 2 + 6 +\n                         args.data.len + 2 + 7 + 10 + 4;\n    buf = fiobj_str_buf(total);\n  }\n  http_sse_copy2str(buf, (char *)\"id: \", 4, args.id);\n  http_sse_copy2str(buf, (char *)\"event: \", 7, args.event);\n  if (args.retry) {\n    FIOBJ i = fiobj_num_new(args.retry);\n    fiobj_str_write(buf, (char *)\"retry: \", 7);\n    fiobj_str_join(buf, i);\n    fiobj_free(i);\n  }\n  http_sse_copy2str(buf, (char *)\"data: \", 6, args.data);\n  fiobj_str_write(buf, \"\\r\\n\", 2);\n  return FIO_LS_EMBD_OBJ(http_sse_internal_s, sse, sse)\n      ->vtable->http_sse_write(sse, buf);\n}\n\n/**\n * Get the connection's UUID (for fio_defer and similar use cases).\n */\nintptr_t http_sse2uuid(http_sse_s *sse) {\n  if (!sse ||\n      fio_is_closed(FIO_LS_EMBD_OBJ(http_sse_internal_s, sse, sse)->uuid))\n    return -1;\n  return FIO_LS_EMBD_OBJ(http_sse_internal_s, sse, sse)->uuid;\n}\n\n/**\n * Closes an EventSource (SSE) connection.\n */\nint http_sse_close(http_sse_s *sse) {\n  if (!sse ||\n      fio_is_closed(FIO_LS_EMBD_OBJ(http_sse_internal_s, sse, sse)->uuid))\n    return -1;\n  return FIO_LS_EMBD_OBJ(http_sse_internal_s, sse, sse)\n      ->vtable->http_sse_close(sse);\n}\n\n/**\n * Duplicates an SSE handle by reference, remember to http_sse_free.\n *\n * Returns the same object (increases a reference count, no allocation is made).\n */\nhttp_sse_s *http_sse_dup(http_sse_s *sse) {\n  fio_atomic_add(&FIO_LS_EMBD_OBJ(http_sse_internal_s, sse, sse)->ref, 1);\n  return sse;\n}\n\n/**\n * Frees an SSE handle by reference (decreases the reference count).\n */\nvoid http_sse_free(http_sse_s *sse) {\n  http_sse_try_free(FIO_LS_EMBD_OBJ(http_sse_internal_s, sse, sse));\n}\n\n/* *****************************************************************************\nHTTP GET and POST parsing helpers\n***************************************************************************** */\n\n/** URL decodes a string, returning a `FIOBJ`. */\nstatic inline FIOBJ http_urlstr2fiobj(char *s, size_t len) {\n  FIOBJ o = fiobj_str_buf(len);\n  ssize_t l = http_decode_url(fiobj_obj2cstr(o).data, s, len);\n  if (l < 0) {\n    fiobj_free(o);\n    return fiobj_str_new(NULL, 0); /* empty string */\n  }\n  fiobj_str_resize(o, (size_t)l);\n  return o;\n}\n\n/** converts a string into a `FIOBJ`. */\nstatic inline FIOBJ http_str2fiobj(char *s, size_t len, uint8_t encoded) {\n  switch (len) {\n  case 0:\n    return fiobj_str_new(NULL, 0); /* empty string */\n  case 4:\n    if (!strncasecmp(s, \"true\", 4))\n      return fiobj_true();\n    if (!strncasecmp(s, \"null\", 4))\n      return fiobj_null();\n    break;\n  case 5:\n    if (!strncasecmp(s, \"false\", 5))\n      return fiobj_false();\n  }\n  {\n    char *end = s;\n    const uint64_t tmp = fio_atol(&end);\n    if (end == s + len)\n      return fiobj_num_new(tmp);\n  }\n  {\n    char *end = s;\n    const double tmp = fio_atof(&end);\n    if (end == s + len)\n      return fiobj_float_new(tmp);\n  }\n  if (encoded)\n    return http_urlstr2fiobj(s, len);\n  return fiobj_str_new(s, len);\n}\n\n/** Parses the query part of an HTTP request/response. Uses `http_add2hash`. */\nvoid http_parse_query(http_s *h) {\n  if (!h->query)\n    return;\n  if (!h->params)\n    h->params = fiobj_hash_new();\n  fio_str_info_s q = fiobj_obj2cstr(h->query);\n  do {\n    char *cut = memchr(q.data, '&', q.len);\n    if (!cut)\n      cut = q.data + q.len;\n    char *cut2 = memchr(q.data, '=', (cut - q.data));\n    if (cut2) {\n      /* we only add named elements... */\n      http_add2hash(h->params, q.data, (size_t)(cut2 - q.data), (cut2 + 1),\n                    (size_t)(cut - (cut2 + 1)), 1);\n    }\n    if (cut[0] == '&') {\n      /* protecting against some ...less informed... clients */\n      if (cut[1] == 'a' && cut[2] == 'm' && cut[3] == 'p' && cut[4] == ';')\n        cut += 5;\n      else\n        cut += 1;\n    }\n    q.len -= (uintptr_t)(cut - q.data);\n    q.data = cut;\n  } while (q.len);\n}\n\nstatic inline void http_parse_cookies_cookie_str(FIOBJ dest, FIOBJ str,\n                                                 uint8_t is_url_encoded) {\n  if (!FIOBJ_TYPE_IS(str, FIOBJ_T_STRING))\n    return;\n  fio_str_info_s s = fiobj_obj2cstr(str);\n  while (s.len) {\n    if (s.data[0] == ' ') {\n      ++s.data;\n      --s.len;\n      continue;\n    }\n    char *cut = memchr(s.data, '=', s.len);\n    if (!cut)\n      cut = s.data;\n    char *cut2 = memchr(cut, ';', s.len - (cut - s.data));\n    if (!cut2)\n      cut2 = s.data + s.len;\n    http_add2hash(dest, s.data, cut - s.data, cut + 1, (cut2 - (cut + 1)),\n                  is_url_encoded);\n    if ((size_t)((cut2 + 1) - s.data) > s.len)\n      s.len = 0;\n    else\n      s.len -= ((cut2 + 1) - s.data);\n    s.data = cut2 + 1;\n  }\n}\nstatic inline void http_parse_cookies_setcookie_str(FIOBJ dest, FIOBJ str,\n                                                    uint8_t is_url_encoded) {\n  if (!FIOBJ_TYPE_IS(str, FIOBJ_T_STRING))\n    return;\n  fio_str_info_s s = fiobj_obj2cstr(str);\n  char *cut = memchr(s.data, '=', s.len);\n  if (!cut)\n    cut = s.data;\n  char *cut2 = memchr(cut, ';', s.len - (cut - s.data));\n  if (!cut2)\n    cut2 = s.data + s.len;\n  if (cut2 > cut)\n    http_add2hash(dest, s.data, cut - s.data, cut + 1, (cut2 - (cut + 1)),\n                  is_url_encoded);\n}\n\n/** Parses any Cookie / Set-Cookie headers, using the `http_add2hash` scheme. */\nvoid http_parse_cookies(http_s *h, uint8_t is_url_encoded) {\n  if (!h->headers)\n    return;\n  if (h->cookies && fiobj_hash_count(h->cookies)) {\n    FIO_LOG_WARNING(\"(http) attempting to parse cookies more than once.\");\n    return;\n  }\n  static uint64_t setcookie_header_hash;\n  if (!setcookie_header_hash)\n    setcookie_header_hash = fiobj_obj2hash(HTTP_HEADER_SET_COOKIE);\n  FIOBJ c = fiobj_hash_get2(h->headers, fiobj_obj2hash(HTTP_HEADER_COOKIE));\n  if (c) {\n    if (!h->cookies)\n      h->cookies = fiobj_hash_new();\n    if (FIOBJ_TYPE_IS(c, FIOBJ_T_ARRAY)) {\n      /* Array of Strings */\n      size_t count = fiobj_ary_count(c);\n      for (size_t i = 0; i < count; ++i) {\n        http_parse_cookies_cookie_str(\n            h->cookies, fiobj_ary_index(c, (int64_t)i), is_url_encoded);\n      }\n    } else {\n      /* single string */\n      http_parse_cookies_cookie_str(h->cookies, c, is_url_encoded);\n    }\n  }\n  c = fiobj_hash_get2(h->headers, fiobj_obj2hash(HTTP_HEADER_SET_COOKIE));\n  if (c) {\n    if (!h->cookies)\n      h->cookies = fiobj_hash_new();\n    if (FIOBJ_TYPE_IS(c, FIOBJ_T_ARRAY)) {\n      /* Array of Strings */\n      size_t count = fiobj_ary_count(c);\n      for (size_t i = 0; i < count; ++i) {\n        http_parse_cookies_setcookie_str(\n            h->cookies, fiobj_ary_index(c, (int64_t)i), is_url_encoded);\n      }\n    } else {\n      /* single string */\n      http_parse_cookies_setcookie_str(h->cookies, c, is_url_encoded);\n    }\n  }\n}\n\n/**\n * Adds a named parameter to the hash, resolving nesting references.\n *\n * i.e.:\n *\n * * \"name[]\" references a nested Array (nested in the Hash).\n * * \"name[key]\" references a nested Hash.\n * * \"name[][key]\" references a nested Hash within an array. Hash keys will be\n *   unique (repeating a key advances the hash).\n * * These rules can be nested (i.e. \"name[][key1][][key2]...\")\n * * \"name[][]\" is an error (there's no way for the parser to analyze\n *    dimensions)\n *\n * Note: names can't begin with \"[\" or end with \"]\" as these are reserved\n *       characters.\n */\nint http_add2hash2(FIOBJ dest, char *name, size_t name_len, FIOBJ val,\n                   uint8_t encoded) {\n  if (!name)\n    goto error;\n  FIOBJ nested_ary = FIOBJ_INVALID;\n  char *cut1;\n  /* we can't start with an empty object name */\n  while (name_len && name[0] == '[') {\n    --name_len;\n    ++name;\n  }\n  if (!name_len) {\n    /* an empty name is an error */\n    goto error;\n  }\n  uint32_t nesting = ((uint32_t)~0);\nrebase:\n  /* test for nesting level limit (limit at 32) */\n  if (!nesting)\n    goto error;\n  /* start clearing away bits. */\n  nesting >>= 1;\n  /* since we might be rebasing, notice that \"name\" might be \"name]\" */\n  cut1 = memchr(name, '[', name_len);\n  if (!cut1)\n    goto place_in_hash;\n  /* simple case \"name=\" (the \"=\" was already removed) */\n  if (cut1 == name) {\n    /* an empty name is an error */\n    goto error;\n  }\n  if (cut1 + 1 == name + name_len) {\n    /* we have name[= ... autocorrect */\n    name_len -= 1;\n    goto place_in_array;\n  }\n\n  if (cut1[1] == ']') {\n    /* Nested Array \"name[]...\" */\n\n    /* Test for name[]= */\n    if ((cut1 + 2) == name + name_len) {\n      name_len -= 2;\n      goto place_in_array;\n    }\n\n    /* Test for a nested Array format error */\n    if (cut1[2] != '[' || cut1[3] == ']') { /* error, we can't parse this */\n      goto error;\n    }\n\n    /* we have name[][key...= */\n\n    /* ensure array exists and it's an array + set nested_ary */\n    const size_t len = ((cut1[-1] == ']') ? (size_t)((cut1 - 1) - name)\n                                          : (size_t)(cut1 - name));\n    const uint64_t hash =\n        fiobj_hash_string(name, len); /* hash the current name */\n    nested_ary = fiobj_hash_get2(dest, hash);\n    if (!nested_ary) {\n      /* create a new nested array */\n      FIOBJ key =\n          encoded ? http_urlstr2fiobj(name, len) : fiobj_str_new(name, len);\n      nested_ary = fiobj_ary_new2(4);\n      fiobj_hash_set(dest, key, nested_ary);\n      fiobj_free(key);\n    } else if (!FIOBJ_TYPE_IS(nested_ary, FIOBJ_T_ARRAY)) {\n      /* convert existing object to an array - auto error correction */\n      FIOBJ key =\n          encoded ? http_urlstr2fiobj(name, len) : fiobj_str_new(name, len);\n      FIOBJ tmp = fiobj_ary_new2(4);\n      fiobj_ary_push(tmp, nested_ary);\n      nested_ary = tmp;\n      fiobj_hash_set(dest, key, nested_ary);\n      fiobj_free(key);\n    }\n\n    /* test if last object in the array is a hash - create hash if not */\n    dest = fiobj_ary_index(nested_ary, -1);\n    if (!dest || !FIOBJ_TYPE_IS(dest, FIOBJ_T_HASH)) {\n      dest = fiobj_hash_new();\n      fiobj_ary_push(nested_ary, dest);\n    }\n\n    /* rebase `name` to `key` and restart. */\n    cut1 += 3; /* consume \"[][\" */\n    name_len -= (size_t)(cut1 - name);\n    name = cut1;\n    goto rebase;\n\n  } else {\n    /* we have name[key]... */\n    const size_t len = ((cut1[-1] == ']') ? (size_t)((cut1 - 1) - name)\n                                          : (size_t)(cut1 - name));\n    const uint64_t hash =\n        fiobj_hash_string(name, len); /* hash the current name */\n    FIOBJ tmp = fiobj_hash_get2(dest, hash);\n    if (!tmp) {\n      /* hash doesn't exist, create it */\n      FIOBJ key =\n          encoded ? http_urlstr2fiobj(name, len) : fiobj_str_new(name, len);\n      tmp = fiobj_hash_new();\n      fiobj_hash_set(dest, key, tmp);\n      fiobj_free(key);\n    } else if (!FIOBJ_TYPE_IS(tmp, FIOBJ_T_HASH)) {\n      /* type error, referencing an existing object that isn't a Hash */\n      goto error;\n    }\n    dest = tmp;\n    /* no rollback is possible once we enter the new nesting level... */\n    nested_ary = FIOBJ_INVALID;\n    /* rebase `name` to `key` and restart. */\n    cut1 += 1; /* consume \"[\" */\n    name_len -= (size_t)(cut1 - name);\n    name = cut1;\n    goto rebase;\n  }\n\nplace_in_hash:\n  if (name[name_len - 1] == ']')\n    --name_len;\n  {\n    FIOBJ key = encoded ? http_urlstr2fiobj(name, name_len)\n                        : fiobj_str_new(name, name_len);\n    FIOBJ old = fiobj_hash_replace(dest, key, val);\n    if (old) {\n      if (nested_ary) {\n        fiobj_hash_replace(dest, key, old);\n        old = fiobj_hash_new();\n        fiobj_hash_set(old, key, val);\n        fiobj_ary_push(nested_ary, old);\n      } else {\n        if (!FIOBJ_TYPE_IS(old, FIOBJ_T_ARRAY)) {\n          FIOBJ tmp = fiobj_ary_new2(4);\n          fiobj_ary_push(tmp, old);\n          old = tmp;\n        }\n        fiobj_ary_push(old, val);\n        fiobj_hash_replace(dest, key, old);\n      }\n    }\n    fiobj_free(key);\n  }\n  return 0;\n\nplace_in_array:\n  if (name[name_len - 1] == ']')\n    --name_len;\n  {\n    uint64_t hash = fiobj_hash_string(name, name_len);\n    FIOBJ ary = fiobj_hash_get2(dest, hash);\n    if (!ary) {\n      FIOBJ key = encoded ? http_urlstr2fiobj(name, name_len)\n                          : fiobj_str_new(name, name_len);\n      ary = fiobj_ary_new2(4);\n      fiobj_hash_set(dest, key, ary);\n      fiobj_free(key);\n    } else if (!FIOBJ_TYPE_IS(ary, FIOBJ_T_ARRAY)) {\n      FIOBJ tmp = fiobj_ary_new2(4);\n      fiobj_ary_push(tmp, ary);\n      ary = tmp;\n      FIOBJ key = encoded ? http_urlstr2fiobj(name, name_len)\n                          : fiobj_str_new(name, name_len);\n      fiobj_hash_replace(dest, key, ary);\n      fiobj_free(key);\n    }\n    fiobj_ary_push(ary, val);\n  }\n  return 0;\nerror:\n  fiobj_free(val);\n  errno = EOPNOTSUPP;\n  return -1;\n}\n\n/**\n * Adds a named parameter to the hash, resolving nesting references.\n *\n * i.e.:\n *\n * * \"name[]\" references a nested Array (nested in the Hash).\n * * \"name[key]\" references a nested Hash.\n * * \"name[][key]\" references a nested Hash within an array. Hash keys will be\n *   unique (repeating a key advances the hash).\n * * These rules can be nested (i.e. \"name[][key1][][key2]...\")\n * * \"name[][]\" is an error (there's no way for the parser to analyze\n *    dimensions)\n *\n * Note: names can't begin with \"[\" or end with \"]\" as these are reserved\n *       characters.\n */\nint http_add2hash(FIOBJ dest, char *name, size_t name_len, char *value,\n                  size_t value_len, uint8_t encoded) {\n  return http_add2hash2(dest, name, name_len,\n                        http_str2fiobj(value, value_len, encoded), encoded);\n}\n\n/* *****************************************************************************\nHTTP Body Parsing\n***************************************************************************** */\n#include <http_mime_parser.h>\n\ntypedef struct {\n  http_mime_parser_s p;\n  http_s *h;\n  fio_str_info_s buffer;\n  size_t pos;\n  size_t partial_offset;\n  size_t partial_length;\n  FIOBJ partial_name;\n} http_fio_mime_s;\n\n#define http_mime_parser2fio(parser) ((http_fio_mime_s *)(parser))\n\n/** Called when all the data is available at once. */\nstatic void http_mime_parser_on_data(http_mime_parser_s *parser, void *name,\n                                     size_t name_len, void *filename,\n                                     size_t filename_len, void *mimetype,\n                                     size_t mimetype_len, void *value,\n                                     size_t value_len) {\n  if (!filename_len) {\n    http_add2hash(http_mime_parser2fio(parser)->h->params, name, name_len,\n                  value, value_len, 0);\n    return;\n  }\n  FIOBJ n = fiobj_str_new(name, name_len);\n  fiobj_str_write(n, \"[data]\", 6);\n  fio_str_info_s tmp = fiobj_obj2cstr(n);\n  http_add2hash(http_mime_parser2fio(parser)->h->params, tmp.data, tmp.len,\n                value, value_len, 0);\n  fiobj_str_resize(n, name_len);\n  fiobj_str_write(n, \"[name]\", 6);\n  tmp = fiobj_obj2cstr(n);\n  http_add2hash(http_mime_parser2fio(parser)->h->params, tmp.data, tmp.len,\n                filename, filename_len, 0);\n  if (mimetype_len) {\n    fiobj_str_resize(n, name_len);\n    fiobj_str_write(n, \"[type]\", 6);\n    tmp = fiobj_obj2cstr(n);\n    http_add2hash(http_mime_parser2fio(parser)->h->params, tmp.data, tmp.len,\n                  mimetype, mimetype_len, 0);\n  }\n  fiobj_free(n);\n}\n\n/** Called when the data didn't fit in the buffer. Data will be streamed. */\nstatic void http_mime_parser_on_partial_start(\n    http_mime_parser_s *parser, void *name, size_t name_len, void *filename,\n    size_t filename_len, void *mimetype, size_t mimetype_len) {\n  http_mime_parser2fio(parser)->partial_length = 0;\n  http_mime_parser2fio(parser)->partial_offset = 0;\n  http_mime_parser2fio(parser)->partial_name = fiobj_str_new(name, name_len);\n\n  if (!filename)\n    return;\n\n  fiobj_str_write(http_mime_parser2fio(parser)->partial_name, \"[type]\", 6);\n  fio_str_info_s tmp =\n      fiobj_obj2cstr(http_mime_parser2fio(parser)->partial_name);\n  http_add2hash(http_mime_parser2fio(parser)->h->params, tmp.data, tmp.len,\n                mimetype, mimetype_len, 0);\n\n  fiobj_str_resize(http_mime_parser2fio(parser)->partial_name, name_len);\n  fiobj_str_write(http_mime_parser2fio(parser)->partial_name, \"[name]\", 6);\n  tmp = fiobj_obj2cstr(http_mime_parser2fio(parser)->partial_name);\n  http_add2hash(http_mime_parser2fio(parser)->h->params, tmp.data, tmp.len,\n                filename, filename_len, 0);\n\n  fiobj_str_resize(http_mime_parser2fio(parser)->partial_name, name_len);\n  fiobj_str_write(http_mime_parser2fio(parser)->partial_name, \"[data]\", 6);\n}\n\n/** Called when partial data is available. */\nstatic void http_mime_parser_on_partial_data(http_mime_parser_s *parser,\n                                             void *value, size_t value_len) {\n  if (!http_mime_parser2fio(parser)->partial_offset)\n    http_mime_parser2fio(parser)->partial_offset =\n        http_mime_parser2fio(parser)->pos +\n        ((uintptr_t)value -\n         (uintptr_t)http_mime_parser2fio(parser)->buffer.data);\n  http_mime_parser2fio(parser)->partial_length += value_len;\n  (void)value;\n}\n\n/** Called when the partial data is complete. */\nstatic void http_mime_parser_on_partial_end(http_mime_parser_s *parser) {\n\n  fio_str_info_s tmp =\n      fiobj_obj2cstr(http_mime_parser2fio(parser)->partial_name);\n  FIOBJ o = FIOBJ_INVALID;\n  if (!http_mime_parser2fio(parser)->partial_length)\n    return;\n  if (http_mime_parser2fio(parser)->partial_length < 42) {\n    /* short data gets a new object */\n    o = fiobj_str_new(http_mime_parser2fio(parser)->buffer.data +\n                          http_mime_parser2fio(parser)->partial_offset,\n                      http_mime_parser2fio(parser)->partial_length);\n  } else {\n    /* longer data gets a reference object (memory collision concerns) */\n    o = fiobj_data_slice(http_mime_parser2fio(parser)->h->body,\n                         http_mime_parser2fio(parser)->partial_offset,\n                         http_mime_parser2fio(parser)->partial_length);\n  }\n  http_add2hash2(http_mime_parser2fio(parser)->h->params, tmp.data, tmp.len, o,\n                 0);\n  fiobj_free(http_mime_parser2fio(parser)->partial_name);\n  http_mime_parser2fio(parser)->partial_name = FIOBJ_INVALID;\n  http_mime_parser2fio(parser)->partial_offset = 0;\n}\n\n/**\n * Called when URL decoding is required.\n *\n * Should support inplace decoding (`dest == encoded`).\n *\n * Should return the length of the decoded string.\n */\nstatic inline size_t http_mime_decode_url(char *dest, const char *encoded,\n                                          size_t length) {\n  return http_decode_url(dest, encoded, length);\n}\n\n/**\n * Attempts to decode the request's body.\n *\n * Supported Types include:\n * * application/x-www-form-urlencoded\n * * application/json\n * * multipart/form-data\n */\nint http_parse_body(http_s *h) {\n  static uint64_t content_type_hash;\n  if (!h->body)\n    return -1;\n  if (!content_type_hash)\n    content_type_hash = fiobj_hash_string(\"content-type\", 12);\n  FIOBJ ct = fiobj_hash_get2(h->headers, content_type_hash);\n  fio_str_info_s content_type = fiobj_obj2cstr(ct);\n  if (content_type.len < 16)\n    return -1;\n  if (content_type.len >= 33 &&\n      !strncasecmp(\"application/x-www-form-urlencoded\", content_type.data,\n                   33)) {\n    if (!h->params)\n      h->params = fiobj_hash_new();\n    FIOBJ tmp = h->query;\n    h->query = h->body;\n    http_parse_query(h);\n    h->query = tmp;\n    return 0;\n  }\n  if (content_type.len >= 16 &&\n      !strncasecmp(\"application/json\", content_type.data, 16)) {\n    content_type = fiobj_obj2cstr(h->body);\n    if (h->params)\n      return -1;\n    if (fiobj_json2obj(&h->params, content_type.data, content_type.len) == 0)\n      return -1;\n    if (FIOBJ_TYPE_IS(h->params, FIOBJ_T_HASH))\n      return 0;\n    FIOBJ tmp = h->params;\n    FIOBJ key = fiobj_str_new(\"JSON\", 4);\n    h->params = fiobj_hash_new2(4);\n    fiobj_hash_set(h->params, key, tmp);\n    fiobj_free(key);\n    return 0;\n  }\n\n  http_fio_mime_s p = {.h = h};\n  if (http_mime_parser_init(&p.p, content_type.data, content_type.len))\n    return -1;\n  if (!h->params)\n    h->params = fiobj_hash_new();\n\n  do {\n    size_t cons = http_mime_parse(&p.p, p.buffer.data, p.buffer.len);\n    p.pos += cons;\n    p.buffer = fiobj_data_pread(h->body, p.pos, 4096);\n  } while (p.buffer.data && !p.p.done && !p.p.error);\n  fiobj_free(p.partial_name);\n  p.partial_name = FIOBJ_INVALID;\n  return 0;\n}\n\n/* *****************************************************************************\nHTTP Helper functions that could be used globally\n***************************************************************************** */\n\n/**\n * Returns a String object representing the unparsed HTTP request (HTTP\n * version is capped at HTTP/1.1). Mostly usable for proxy usage and\n * debugging.\n */\nFIOBJ http_req2str(http_s *h) {\n  if (HTTP_INVALID_HANDLE(h) || !fiobj_hash_count(h->headers))\n    return FIOBJ_INVALID;\n\n  struct header_writer_s w;\n  w.dest = fiobj_str_buf(0);\n  if (h->status_str) {\n    fiobj_str_join(w.dest, h->version);\n    fiobj_str_write(w.dest, \" \", 1);\n    fiobj_str_join(w.dest, fiobj_num_tmp(h->status));\n    fiobj_str_write(w.dest, \" \", 1);\n    fiobj_str_join(w.dest, h->status_str);\n    fiobj_str_write(w.dest, \"\\r\\n\", 2);\n  } else {\n    fiobj_str_join(w.dest, h->method);\n    fiobj_str_write(w.dest, \" \", 1);\n    fiobj_str_join(w.dest, h->path);\n    if (h->query) {\n      fiobj_str_write(w.dest, \"?\", 1);\n      fiobj_str_join(w.dest, h->query);\n    }\n    {\n      fio_str_info_s t = fiobj_obj2cstr(h->version);\n      if (t.len < 6 || t.data[5] != '1')\n        fiobj_str_write(w.dest, \" HTTP/1.1\\r\\n\", 10);\n      else {\n        fiobj_str_write(w.dest, \" \", 1);\n        fiobj_str_join(w.dest, h->version);\n        fiobj_str_write(w.dest, \"\\r\\n\", 2);\n      }\n    }\n  }\n\n  fiobj_each1(h->headers, 0, write_header, &w);\n  fiobj_str_write(w.dest, \"\\r\\n\", 2);\n  if (h->body) {\n    // fiobj_data_seek(h->body, 0);\n    // fio_str_info_s t = fiobj_data_read(h->body, 0);\n    // fiobj_str_write(w.dest, t.data, t.len);\n    fiobj_str_join(w.dest, h->body);\n  }\n  return w.dest;\n}\n\nvoid http_write_log(http_s *h) {\n  FIOBJ l = fiobj_str_buf(128);\n\n  intptr_t bytes_sent = fiobj_obj2num(fiobj_hash_get2(\n      h->private_data.out_headers, fiobj_obj2hash(HTTP_HEADER_CONTENT_LENGTH)));\n\n  struct timespec start, end;\n  clock_gettime(CLOCK_REALTIME, &end);\n  start = h->received_at;\n\n  {\n    // TODO Guess IP address from headers (forwarded) where possible\n    fio_str_info_s peer = fio_peer_addr(http2protocol(h)->uuid);\n    fiobj_str_write(l, peer.data, peer.len);\n  }\n  fio_str_info_s buff = fiobj_obj2cstr(l);\n\n  if (buff.len == 0) {\n    memcpy(buff.data, \"[unknown]\", 9);\n    buff.len = 9;\n  }\n  memcpy(buff.data + buff.len, \" - - [\", 6);\n  buff.len += 6;\n  fiobj_str_resize(l, buff.len);\n  {\n    FIOBJ date;\n    fio_lock(&date_lock);\n    date = fiobj_dup(current_date);\n    fio_unlock(&date_lock);\n    fiobj_str_join(l, current_date);\n    fiobj_free(date);\n  }\n  fiobj_str_write(l, \"] \\\"\", 3);\n  fiobj_str_join(l, h->method);\n  fiobj_str_write(l, \" \", 1);\n  fiobj_str_join(l, h->path);\n  fiobj_str_write(l, \" \", 1);\n  fiobj_str_join(l, h->version);\n  fiobj_str_write(l, \"\\\" \", 2);\n  if (bytes_sent > 0) {\n    fiobj_str_write_i(l, h->status);\n    fiobj_str_write(l, \" \", 1);\n    fiobj_str_write_i(l, bytes_sent);\n    fiobj_str_write(l, \"b \", 2);\n  } else {\n    fiobj_str_join(l, fiobj_num_tmp(h->status));\n    fiobj_str_write(l, \" -- \", 4);\n  }\n\n  bytes_sent = ((end.tv_sec - start.tv_sec) * 1000) +\n               ((end.tv_nsec - start.tv_nsec) / 1000000);\n  fiobj_str_write_i(l, bytes_sent);\n  fiobj_str_write(l, \"ms\\r\\n\", 4);\n\n  buff = fiobj_obj2cstr(l);\n  fwrite(buff.data, 1, buff.len, stderr);\n  fiobj_free(l);\n}\n\n/**\nA faster (yet less localized) alternative to `gmtime_r`.\n\nSee the libc `gmtime_r` documentation for details.\n\nFalls back to `gmtime_r` for dates before epoch.\n*/\nstruct tm *http_gmtime(time_t timer, struct tm *tmbuf) {\n  // static char* DAYS[] = {\"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\",\n  // \"Sat\"}; static char * Months = {  \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\",\n  // \"Jun\", \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\"};\n  static const uint8_t month_len[] = {\n      31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, // nonleap year\n      31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31  // leap year\n  };\n  if (timer < 0)\n    return gmtime_r(&timer, tmbuf);\n  ssize_t a, b;\n#if HAVE_TM_TM_ZONE\n  *tmbuf = (struct tm){\n      .tm_isdst = 0,\n      .tm_year = 70, // tm_year == The number of years since 1900\n      .tm_mon = 0,\n      .tm_zone = \"UTC\",\n  };\n#else\n  *tmbuf = (struct tm){\n      .tm_isdst = 0,\n      .tm_year = 70, // tm_year == The number of years since 1900\n      .tm_mon = 0,\n  };\n#endif\n  // for seconds up to weekdays, we build up, as small values clean up\n  // larger values.\n  a = (ssize_t)timer;\n  b = a / 60;\n  tmbuf->tm_sec = a - (b * 60);\n  a = b / 60;\n  tmbuf->tm_min = b - (a * 60);\n  b = a / 24;\n  tmbuf->tm_hour = a - (b * 24);\n  // day of epoch was a thursday. Add + 4 so sunday == 0...\n  tmbuf->tm_wday = (b + 4) % 7;\n// tmp == number of days since epoch\n#define DAYS_PER_400_YEARS ((400 * 365) + 97)\n  while (b >= DAYS_PER_400_YEARS) {\n    tmbuf->tm_year += 400;\n    b -= DAYS_PER_400_YEARS;\n  }\n#undef DAYS_PER_400_YEARS\n#define DAYS_PER_100_YEARS ((100 * 365) + 24)\n  while (b >= DAYS_PER_100_YEARS) {\n    tmbuf->tm_year += 100;\n    b -= DAYS_PER_100_YEARS;\n    if (((tmbuf->tm_year / 100) & 3) ==\n        0) // leap century divisable by 400 => add leap\n      --b;\n  }\n#undef DAYS_PER_100_YEARS\n#define DAYS_PER_32_YEARS ((32 * 365) + 8)\n  while (b >= DAYS_PER_32_YEARS) {\n    tmbuf->tm_year += 32;\n    b -= DAYS_PER_32_YEARS;\n  }\n#undef DAYS_PER_32_YEARS\n#define DAYS_PER_8_YEARS ((8 * 365) + 2)\n  while (b >= DAYS_PER_8_YEARS) {\n    tmbuf->tm_year += 8;\n    b -= DAYS_PER_8_YEARS;\n  }\n#undef DAYS_PER_8_YEARS\n#define DAYS_PER_4_YEARS ((4 * 365) + 1)\n  while (b >= DAYS_PER_4_YEARS) {\n    tmbuf->tm_year += 4;\n    b -= DAYS_PER_4_YEARS;\n  }\n#undef DAYS_PER_4_YEARS\n  while (b >= 365) {\n    tmbuf->tm_year += 1;\n    b -= 365;\n    if ((tmbuf->tm_year & 3) == 0) { // leap year\n      if (b > 0) {\n        --b;\n        continue;\n      } else {\n        b += 365;\n        --tmbuf->tm_year;\n        break;\n      }\n    }\n  }\n  b++; /* day 1 of the year is 1, not 0. */\n  tmbuf->tm_yday = b;\n  if ((tmbuf->tm_year & 3) == 1) {\n    // regular year\n    for (size_t i = 0; i < 12; i++) {\n      if (b <= month_len[i])\n        break;\n      b -= month_len[i];\n      ++tmbuf->tm_mon;\n    }\n  } else {\n    // leap year\n    for (size_t i = 12; i < 24; i++) {\n      if (b <= month_len[i])\n        break;\n      b -= month_len[i];\n      ++tmbuf->tm_mon;\n    }\n  }\n  tmbuf->tm_mday = b;\n  return tmbuf;\n}\n\nstatic const char *DAY_NAMES[] = {\"Sun\", \"Mon\", \"Tue\", \"Wed\",\n                                  \"Thu\", \"Fri\", \"Sat\"};\nstatic const char *MONTH_NAMES[] = {\"Jan \", \"Feb \", \"Mar \", \"Apr \",\n                                    \"May \", \"Jun \", \"Jul \", \"Aug \",\n                                    \"Sep \", \"Oct \", \"Nov \", \"Dec \"};\nstatic const char *GMT_STR = \"GMT\";\n\nsize_t http_date2rfc7231(char *target, struct tm *tmbuf) {\n  /* note: day of month is always 2 digits */\n  char *pos = target;\n  uint16_t tmp;\n  pos[0] = DAY_NAMES[tmbuf->tm_wday][0];\n  pos[1] = DAY_NAMES[tmbuf->tm_wday][1];\n  pos[2] = DAY_NAMES[tmbuf->tm_wday][2];\n  pos[3] = ',';\n  pos[4] = ' ';\n  pos += 5;\n  tmp = tmbuf->tm_mday / 10;\n  pos[0] = '0' + tmp;\n  pos[1] = '0' + (tmbuf->tm_mday - (tmp * 10));\n  pos += 2;\n  *(pos++) = ' ';\n  pos[0] = MONTH_NAMES[tmbuf->tm_mon][0];\n  pos[1] = MONTH_NAMES[tmbuf->tm_mon][1];\n  pos[2] = MONTH_NAMES[tmbuf->tm_mon][2];\n  pos[3] = ' ';\n  pos += 4;\n  // write year.\n  pos += fio_ltoa(pos, tmbuf->tm_year + 1900, 10);\n  *(pos++) = ' ';\n  tmp = tmbuf->tm_hour / 10;\n  pos[0] = '0' + tmp;\n  pos[1] = '0' + (tmbuf->tm_hour - (tmp * 10));\n  pos[2] = ':';\n  tmp = tmbuf->tm_min / 10;\n  pos[3] = '0' + tmp;\n  pos[4] = '0' + (tmbuf->tm_min - (tmp * 10));\n  pos[5] = ':';\n  tmp = tmbuf->tm_sec / 10;\n  pos[6] = '0' + tmp;\n  pos[7] = '0' + (tmbuf->tm_sec - (tmp * 10));\n  pos += 8;\n  pos[0] = ' ';\n  pos[1] = GMT_STR[0];\n  pos[2] = GMT_STR[1];\n  pos[3] = GMT_STR[2];\n  pos[4] = 0;\n  pos += 4;\n  return pos - target;\n}\n\nsize_t http_date2str(char *target, struct tm *tmbuf);\n\nsize_t http_date2rfc2822(char *target, struct tm *tmbuf) {\n  /* note: day of month is either 1 or 2 digits */\n  char *pos = target;\n  uint16_t tmp;\n  pos[0] = DAY_NAMES[tmbuf->tm_wday][0];\n  pos[1] = DAY_NAMES[tmbuf->tm_wday][1];\n  pos[2] = DAY_NAMES[tmbuf->tm_wday][2];\n  pos[3] = ',';\n  pos[4] = ' ';\n  pos += 5;\n  if (tmbuf->tm_mday < 10) {\n    *pos = '0' + tmbuf->tm_mday;\n    ++pos;\n  } else {\n    tmp = tmbuf->tm_mday / 10;\n    pos[0] = '0' + tmp;\n    pos[1] = '0' + (tmbuf->tm_mday - (tmp * 10));\n    pos += 2;\n  }\n  *(pos++) = '-';\n  pos[0] = MONTH_NAMES[tmbuf->tm_mon][0];\n  pos[1] = MONTH_NAMES[tmbuf->tm_mon][1];\n  pos[2] = MONTH_NAMES[tmbuf->tm_mon][2];\n  pos += 3;\n  *(pos++) = '-';\n  // write year.\n  pos += fio_ltoa(pos, tmbuf->tm_year + 1900, 10);\n  *(pos++) = ' ';\n  tmp = tmbuf->tm_hour / 10;\n  pos[0] = '0' + tmp;\n  pos[1] = '0' + (tmbuf->tm_hour - (tmp * 10));\n  pos[2] = ':';\n  tmp = tmbuf->tm_min / 10;\n  pos[3] = '0' + tmp;\n  pos[4] = '0' + (tmbuf->tm_min - (tmp * 10));\n  pos[5] = ':';\n  tmp = tmbuf->tm_sec / 10;\n  pos[6] = '0' + tmp;\n  pos[7] = '0' + (tmbuf->tm_sec - (tmp * 10));\n  pos += 8;\n  pos[0] = ' ';\n  pos[1] = GMT_STR[0];\n  pos[2] = GMT_STR[1];\n  pos[3] = GMT_STR[2];\n  pos[4] = 0;\n  pos += 4;\n  return pos - target;\n}\n\n/* HTTP header format for Cookie ages */\nsize_t http_date2rfc2109(char *target, struct tm *tmbuf) {\n  /* note: day of month is always 2 digits */\n  char *pos = target;\n  uint16_t tmp;\n  pos[0] = DAY_NAMES[tmbuf->tm_wday][0];\n  pos[1] = DAY_NAMES[tmbuf->tm_wday][1];\n  pos[2] = DAY_NAMES[tmbuf->tm_wday][2];\n  pos[3] = ',';\n  pos[4] = ' ';\n  pos += 5;\n  tmp = tmbuf->tm_mday / 10;\n  pos[0] = '0' + tmp;\n  pos[1] = '0' + (tmbuf->tm_mday - (tmp * 10));\n  pos += 2;\n  *(pos++) = ' ';\n  pos[0] = MONTH_NAMES[tmbuf->tm_mon][0];\n  pos[1] = MONTH_NAMES[tmbuf->tm_mon][1];\n  pos[2] = MONTH_NAMES[tmbuf->tm_mon][2];\n  pos[3] = ' ';\n  pos += 4;\n  // write year.\n  pos += fio_ltoa(pos, tmbuf->tm_year + 1900, 10);\n  *(pos++) = ' ';\n  tmp = tmbuf->tm_hour / 10;\n  pos[0] = '0' + tmp;\n  pos[1] = '0' + (tmbuf->tm_hour - (tmp * 10));\n  pos[2] = ':';\n  tmp = tmbuf->tm_min / 10;\n  pos[3] = '0' + tmp;\n  pos[4] = '0' + (tmbuf->tm_min - (tmp * 10));\n  pos[5] = ':';\n  tmp = tmbuf->tm_sec / 10;\n  pos[6] = '0' + tmp;\n  pos[7] = '0' + (tmbuf->tm_sec - (tmp * 10));\n  pos += 8;\n  *pos++ = ' ';\n  *pos++ = '-';\n  *pos++ = '0';\n  *pos++ = '0';\n  *pos++ = '0';\n  *pos++ = '0';\n  *pos = 0;\n  return pos - target;\n}\n\n/**\n * Prints Unix time to a HTTP time formatted string.\n *\n * This variation implements cached results for faster processing, at the\n * price of a less accurate string.\n */\nsize_t http_time2str(char *target, const time_t t) {\n  /* pre-print time every 1 or 2 seconds or so. */\n  static __thread time_t cached_tick;\n  static __thread char cached_httpdate[48];\n  static __thread size_t cached_len;\n  time_t last_tick = fio_last_tick().tv_sec;\n  if ((t | 7) < last_tick) {\n    /* this is a custom time, not \"now\", pass through */\n    struct tm tm;\n    http_gmtime(t, &tm);\n    return http_date2str(target, &tm);\n  }\n  if (last_tick > cached_tick) {\n    struct tm tm;\n    cached_tick = last_tick; /* refresh every second */\n    http_gmtime(last_tick, &tm);\n    cached_len = http_date2str(cached_httpdate, &tm);\n  }\n  memcpy(target, cached_httpdate, cached_len);\n  return cached_len;\n}\n\n/* Credit to Jonathan Leffler for the idea of a unified conditional */\n#define hex_val(c)                                                             \\\n  (((c) >= '0' && (c) <= '9')                                                  \\\n       ? ((c)-48)                                                              \\\n       : (((c) >= 'a' && (c) <= 'f') || ((c) >= 'A' && (c) <= 'F'))            \\\n             ? (((c) | 32) - 87)                                               \\\n             : ({                                                              \\\n                 return -1;                                                    \\\n                 0;                                                            \\\n               }))\nstatic inline int hex2byte(uint8_t *dest, const uint8_t *source) {\n  if (source[0] >= '0' && source[0] <= '9')\n    *dest = (source[0] - '0');\n  else if ((source[0] >= 'a' && source[0] <= 'f') ||\n           (source[0] >= 'A' && source[0] <= 'F'))\n    *dest = (source[0] | 32) - 87;\n  else\n    return -1;\n  *dest <<= 4;\n  if (source[1] >= '0' && source[1] <= '9')\n    *dest |= (source[1] - '0');\n  else if ((source[1] >= 'a' && source[1] <= 'f') ||\n           (source[1] >= 'A' && source[1] <= 'F'))\n    *dest |= (source[1] | 32) - 87;\n  else\n    return -1;\n  return 0;\n}\n\nssize_t http_decode_url(char *dest, const char *url_data, size_t length) {\n  char *pos = dest;\n  const char *end = url_data + length;\n  while (url_data < end) {\n    if (*url_data == '+') {\n      // decode space\n      *(pos++) = ' ';\n      ++url_data;\n    } else if (*url_data == '%') {\n      // decode hex value\n      // this is a percent encoded value.\n      if (hex2byte((uint8_t *)pos, (uint8_t *)&url_data[1]))\n        return -1;\n      pos++;\n      url_data += 3;\n    } else\n      *(pos++) = *(url_data++);\n  }\n  *pos = 0;\n  return pos - dest;\n}\n\nssize_t http_decode_url_unsafe(char *dest, const char *url_data) {\n  char *pos = dest;\n  while (*url_data) {\n    if (*url_data == '+') {\n      // decode space\n      *(pos++) = ' ';\n      ++url_data;\n    } else if (*url_data == '%') {\n      // decode hex value\n      // this is a percent encoded value.\n      if (hex2byte((uint8_t *)pos, (uint8_t *)&url_data[1]))\n        return -1;\n      pos++;\n      url_data += 3;\n    } else\n      *(pos++) = *(url_data++);\n  }\n  *pos = 0;\n  return pos - dest;\n}\n\nssize_t http_decode_path(char *dest, const char *url_data, size_t length) {\n  char *pos = dest;\n  const char *end = url_data + length;\n  while (url_data < end) {\n    if (*url_data == '%') {\n      // decode hex value\n      // this is a percent encoded value.\n      if (hex2byte((uint8_t *)pos, (uint8_t *)&url_data[1]))\n        return -1;\n      pos++;\n      url_data += 3;\n    } else\n      *(pos++) = *(url_data++);\n  }\n  *pos = 0;\n  return pos - dest;\n}\n\nssize_t http_decode_path_unsafe(char *dest, const char *url_data) {\n  char *pos = dest;\n  while (*url_data) {\n    if (*url_data == '%') {\n      // decode hex value\n      // this is a percent encoded value.\n      if (hex2byte((uint8_t *)pos, (uint8_t *)&url_data[1]))\n        return -1;\n      pos++;\n      url_data += 3;\n    } else\n      *(pos++) = *(url_data++);\n  }\n  *pos = 0;\n  return pos - dest;\n}\n\n/* *****************************************************************************\nLookup Tables / functions\n***************************************************************************** */\n\n#define FIO_FORCE_MALLOC_TMP 1 /* use malloc for the mime registry */\n#define FIO_SET_NAME fio_mime_set\n#define FIO_SET_OBJ_TYPE FIOBJ\n#define FIO_SET_OBJ_COMPARE(o1, o2) (1)\n#define FIO_SET_OBJ_COPY(dest, o) (dest) = fiobj_dup((o))\n#define FIO_SET_OBJ_DESTROY(o) fiobj_free((o))\n\n#include <fio.h>\n\nstatic fio_mime_set_s fio_http_mime_types = FIO_SET_INIT;\n\n#define LONGEST_FILE_EXTENSION_LENGTH 15\n\n/** Registers a Mime-Type to be associated with the file extension. */\nvoid http_mimetype_register(char *file_ext, size_t file_ext_len,\n                            FIOBJ mime_type_str) {\n  uintptr_t hash = FIO_HASH_FN(file_ext, file_ext_len, 0, 0);\n  if (mime_type_str == FIOBJ_INVALID) {\n    fio_mime_set_remove(&fio_http_mime_types, hash, FIOBJ_INVALID, NULL);\n  } else {\n    FIOBJ old = FIOBJ_INVALID;\n    fio_mime_set_overwrite(&fio_http_mime_types, hash, mime_type_str, &old);\n    if (old != FIOBJ_INVALID) {\n      FIO_LOG_WARNING(\"mime-type collision: %.*s was %s, now %s\",\n                      (int)file_ext_len, file_ext, fiobj_obj2cstr(old).data,\n                      fiobj_obj2cstr(mime_type_str).data);\n      fiobj_free(old);\n    }\n    fiobj_free(mime_type_str); /* move ownership to the registry */\n  }\n}\n\n/** Registers a Mime-Type to be associated with the file extension. */\nvoid http_mimetype_stats(void) {\n  FIO_LOG_DEBUG(\"HTTP MIME hash storage count/capa: %zu / %zu\",\n                fio_mime_set_count(&fio_http_mime_types),\n                fio_mime_set_capa(&fio_http_mime_types));\n}\n\n/**\n * Finds the mime-type associated with the file extension.\n *  Remember to call `fiobj_free`.\n */\nFIOBJ http_mimetype_find(char *file_ext, size_t file_ext_len) {\n  uintptr_t hash = FIO_HASH_FN(file_ext, file_ext_len, 0, 0);\n  return fiobj_dup(\n      fio_mime_set_find(&fio_http_mime_types, hash, FIOBJ_INVALID));\n}\n\n/**\n * Finds the mime-type associated with the URL.\n *  Remember to call `fiobj_free`.\n */\nFIOBJ http_mimetype_find2(FIOBJ url) {\n  static __thread char buffer[LONGEST_FILE_EXTENSION_LENGTH + 1];\n  fio_str_info_s ext = {.data = NULL};\n  FIOBJ mimetype;\n  if (!url)\n    goto finish;\n  fio_str_info_s tmp = fiobj_obj2cstr(url);\n  uint8_t steps = 1;\n  while (tmp.len > steps || steps >= LONGEST_FILE_EXTENSION_LENGTH) {\n    switch (tmp.data[tmp.len - steps]) {\n    case '.':\n      --steps;\n      if (steps) {\n        ext.len = steps;\n        ext.data = buffer;\n        buffer[steps] = 0;\n        for (size_t i = 1; i <= steps; ++i) {\n          buffer[steps - i] = tolower(tmp.data[tmp.len - i]);\n        }\n      }\n    /* fallthrough */\n    case '/':\n      goto finish;\n      break;\n    }\n    ++steps;\n  }\nfinish:\n  mimetype = http_mimetype_find(ext.data, ext.len);\n  if (!mimetype)\n    mimetype = fiobj_dup(HTTP_HVALUE_CONTENT_TYPE_DEFAULT);\n  return mimetype;\n}\n\n/** Clears the Mime-Type registry (it will be empty afterthis call). */\nvoid http_mimetype_clear(void) {\n  fio_mime_set_free(&fio_http_mime_types);\n  fiobj_free(current_date);\n  current_date = FIOBJ_INVALID;\n  last_date_added = 0;\n}\n\n/**\n* Create with Ruby using:\n\na = []\n256.times {|i| a[i] = 1;}\n('a'.ord..'z'.ord).each {|i| a[i] = 0;}\n('A'.ord..'Z'.ord).each {|i| a[i] = 0;}\n('0'.ord..'9'.ord).each {|i| a[i] = 0;}\n\"!#$%&'*+-.^_`|~\".bytes.each {|i| a[i] = 0;}\np a; nil\n\"!#$%&'()*+-./:<=>?@[]^_`{|}~\".bytes.each {|i| a[i] = 0;} # for values\np a; nil\n*/\nstatic char invalid_cookie_name_char[256] = {\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n\nstatic char invalid_cookie_value_char[256] = {\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n\n// clang-format off\n#define HTTP_SET_STATUS_STR(status, str) [status-100] = { .data = (char *)(str), .len = (sizeof(str) - 1) }\n// clang-format on\n\n/** Returns the status as a C string struct */\nfio_str_info_s http_status2str(uintptr_t status) {\n  static const fio_str_info_s status2str[] = {\n      HTTP_SET_STATUS_STR(100, \"Continue\"),\n      HTTP_SET_STATUS_STR(101, \"Switching Protocols\"),\n      HTTP_SET_STATUS_STR(102, \"Processing\"),\n      HTTP_SET_STATUS_STR(103, \"Early Hints\"),\n      HTTP_SET_STATUS_STR(200, \"OK\"),\n      HTTP_SET_STATUS_STR(201, \"Created\"),\n      HTTP_SET_STATUS_STR(202, \"Accepted\"),\n      HTTP_SET_STATUS_STR(203, \"Non-Authoritative Information\"),\n      HTTP_SET_STATUS_STR(204, \"No Content\"),\n      HTTP_SET_STATUS_STR(205, \"Reset Content\"),\n      HTTP_SET_STATUS_STR(206, \"Partial Content\"),\n      HTTP_SET_STATUS_STR(207, \"Multi-Status\"),\n      HTTP_SET_STATUS_STR(208, \"Already Reported\"),\n      HTTP_SET_STATUS_STR(226, \"IM Used\"),\n      HTTP_SET_STATUS_STR(300, \"Multiple Choices\"),\n      HTTP_SET_STATUS_STR(301, \"Moved Permanently\"),\n      HTTP_SET_STATUS_STR(302, \"Found\"),\n      HTTP_SET_STATUS_STR(303, \"See Other\"),\n      HTTP_SET_STATUS_STR(304, \"Not Modified\"),\n      HTTP_SET_STATUS_STR(305, \"Use Proxy\"),\n      HTTP_SET_STATUS_STR(306, \"(Unused), \"),\n      HTTP_SET_STATUS_STR(307, \"Temporary Redirect\"),\n      HTTP_SET_STATUS_STR(308, \"Permanent Redirect\"),\n      HTTP_SET_STATUS_STR(400, \"Bad Request\"),\n      HTTP_SET_STATUS_STR(403, \"Forbidden\"),\n      HTTP_SET_STATUS_STR(404, \"Not Found\"),\n      HTTP_SET_STATUS_STR(401, \"Unauthorized\"),\n      HTTP_SET_STATUS_STR(402, \"Payment Required\"),\n      HTTP_SET_STATUS_STR(405, \"Method Not Allowed\"),\n      HTTP_SET_STATUS_STR(406, \"Not Acceptable\"),\n      HTTP_SET_STATUS_STR(407, \"Proxy Authentication Required\"),\n      HTTP_SET_STATUS_STR(408, \"Request Timeout\"),\n      HTTP_SET_STATUS_STR(409, \"Conflict\"),\n      HTTP_SET_STATUS_STR(410, \"Gone\"),\n      HTTP_SET_STATUS_STR(411, \"Length Required\"),\n      HTTP_SET_STATUS_STR(412, \"Precondition Failed\"),\n      HTTP_SET_STATUS_STR(413, \"Payload Too Large\"),\n      HTTP_SET_STATUS_STR(414, \"URI Too Long\"),\n      HTTP_SET_STATUS_STR(415, \"Unsupported Media Type\"),\n      HTTP_SET_STATUS_STR(416, \"Range Not Satisfiable\"),\n      HTTP_SET_STATUS_STR(417, \"Expectation Failed\"),\n      HTTP_SET_STATUS_STR(421, \"Misdirected Request\"),\n      HTTP_SET_STATUS_STR(422, \"Unprocessable Entity\"),\n      HTTP_SET_STATUS_STR(423, \"Locked\"),\n      HTTP_SET_STATUS_STR(424, \"Failed Dependency\"),\n      HTTP_SET_STATUS_STR(425, \"Unassigned\"),\n      HTTP_SET_STATUS_STR(426, \"Upgrade Required\"),\n      HTTP_SET_STATUS_STR(427, \"Unassigned\"),\n      HTTP_SET_STATUS_STR(428, \"Precondition Required\"),\n      HTTP_SET_STATUS_STR(429, \"Too Many Requests\"),\n      HTTP_SET_STATUS_STR(430, \"Unassigned\"),\n      HTTP_SET_STATUS_STR(431, \"Request Header Fields Too Large\"),\n      HTTP_SET_STATUS_STR(500, \"Internal Server Error\"),\n      HTTP_SET_STATUS_STR(501, \"Not Implemented\"),\n      HTTP_SET_STATUS_STR(502, \"Bad Gateway\"),\n      HTTP_SET_STATUS_STR(503, \"Service Unavailable\"),\n      HTTP_SET_STATUS_STR(504, \"Gateway Timeout\"),\n      HTTP_SET_STATUS_STR(505, \"HTTP Version Not Supported\"),\n      HTTP_SET_STATUS_STR(506, \"Variant Also Negotiates\"),\n      HTTP_SET_STATUS_STR(507, \"Insufficient Storage\"),\n      HTTP_SET_STATUS_STR(508, \"Loop Detected\"),\n      HTTP_SET_STATUS_STR(509, \"Unassigned\"),\n      HTTP_SET_STATUS_STR(510, \"Not Extended\"),\n      HTTP_SET_STATUS_STR(511, \"Network Authentication Required\"),\n  };\n  fio_str_info_s ret = (fio_str_info_s){.len = 0, .data = NULL};\n  if (status >= 100 &&\n      (status - 100) < sizeof(status2str) / sizeof(status2str[0]))\n    ret = status2str[status - 100];\n  if (!ret.data) {\n    ret = status2str[400];\n  }\n  return ret;\n}\n#undef HTTP_SET_STATUS_STR\n\n#if DEBUG\nvoid http_tests(void) {\n  fprintf(stderr, \"=== Testing HTTP helpers\\n\");\n  FIOBJ html_mime = http_mimetype_find(\"html\", 4);\n  FIO_ASSERT(html_mime,\n             \"HTML mime-type not found! Mime-Type registry invalid!\\n\");\n  fiobj_free(html_mime);\n}\n#endif\n", "#ifndef H_HTTP_H\n/*\nCopyright: Boaz Segev, 2016-2019\nLicense: MIT\n\nFeel free to copy, use and enjoy according to the license provided.\n*/\n#define H_HTTP_H\n\n#include <fio.h>\n\n#include <fiobj.h>\n\n#include <time.h>\n\n/* support C++ */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* *****************************************************************************\nCompile Time Settings\n***************************************************************************** */\n\n/** When a new connection is accepted, it will be immediately declined with a\n * 503 service unavailable (server busy) response unless the following number of\n * file descriptors is available.*/\n#ifndef HTTP_BUSY_UNLESS_HAS_FDS\n#define HTTP_BUSY_UNLESS_HAS_FDS 64\n#endif\n\n#ifndef HTTP_DEFAULT_BODY_LIMIT\n#define HTTP_DEFAULT_BODY_LIMIT (1024 * 1024 * 50)\n#endif\n\n#ifndef HTTP_MAX_HEADER_COUNT\n#define HTTP_MAX_HEADER_COUNT 128\n#endif\n\n#ifndef HTTP_MAX_HEADER_LENGTH\n/** the default maximum length for a single header line */\n#define HTTP_MAX_HEADER_LENGTH 8192\n#endif\n\n#ifndef FIO_HTTP_EXACT_LOGGING\n/**\n * By default, facil.io logs the HTTP request cycle using a fuzzy starting point\n * (a close enough timestamp).\n *\n * The fuzzy timestamp includes delays that aren't related to the HTTP request,\n * sometimes including time that was spent waiting on the client. On the other\n * hand, `FIO_HTTP_EXACT_LOGGING` excludes time that the client might have been\n * waiting for facil.io to read data from the network.\n *\n * Due to the preference to err on the side of causion, fuzzy time-stamping is\n * the default.\n */\n#define FIO_HTTP_EXACT_LOGGING 0\n#endif\n\n/** the `http_listen settings, see details in the struct definition. */\ntypedef struct http_settings_s http_settings_s;\n\n/* *****************************************************************************\nThe Request / Response type and functions\n***************************************************************************** */\n\n/**\n * A generic HTTP handle used for HTTP request/response data.\n *\n * The `http_s` data can only be accessed safely from within the `on_request`\n * HTTP callback OR an `http_defer` callback.\n */\ntypedef struct {\n  /** the HTTP request's \"head\" starts with a private data used by facil.io */\n  struct {\n    /** the function touting table - used by facil.io, don't use directly! */\n    void *vtbl;\n    /** the connection's owner / uuid - used by facil.io, don't use directly! */\n    uintptr_t flag;\n    /** The response headers, if they weren't sent. Don't access directly. */\n    FIOBJ out_headers;\n  } private_data;\n  /** a time merker indicating when the request was received. */\n  struct timespec received_at;\n  /** a String containing the method data (supports non-standard methods. */\n  FIOBJ method;\n  /** The status string, for response objects (client mode response). */\n  FIOBJ status_str;\n  /** The HTTP version string, if any. */\n  FIOBJ version;\n  /** The status used for the response (or if the object is a response).\n   *\n   * When sending a request, the status should be set to 0.\n   */\n  uintptr_t status;\n  /** The request path, if any. */\n  FIOBJ path;\n  /** The request query, if any. */\n  FIOBJ query;\n  /** a hash of general header data. When a header is set multiple times (such\n   * as cookie headers), an Array will be used instead of a String. */\n  FIOBJ headers;\n  /**\n   * a placeholder for a hash of cookie data.\n   * the hash will be initialized when parsing the request.\n   */\n  FIOBJ cookies;\n  /**\n   * a placeholder for a hash of request data.\n   * the hash will be initialized when parsing the request.\n   */\n  FIOBJ params;\n  /**\n   * a reader for body data (might be a temporary file or a string or NULL).\n   * see fiobj_data.h for details.\n   */\n  FIOBJ body;\n  /** an opaque user data pointer, to be used BEFORE calling `http_defer`. */\n  void *udata;\n} http_s;\n\n/**\n* This is a helper for setting cookie data.\n\nThis struct is used together with the `http_response_set_cookie`. i.e.:\n\n      http_response_set_cookie(response,\n        .name = \"my_cookie\",\n        .value = \"data\" );\n\n*/\ntypedef struct {\n  /** The cookie's name (Symbol). */\n  const char *name;\n  /** The cookie's value (leave blank to delete cookie). */\n  const char *value;\n  /** The cookie's domain (optional). */\n  const char *domain;\n  /** The cookie's path (optional). */\n  const char *path;\n  /** The cookie name's size in bytes or a terminating NUL will be assumed.*/\n  size_t name_len;\n  /** The cookie value's size in bytes or a terminating NUL will be assumed.*/\n  size_t value_len;\n  /** The cookie domain's size in bytes or a terminating NUL will be assumed.*/\n  size_t domain_len;\n  /** The cookie path's size in bytes or a terminating NULL will be assumed.*/\n  size_t path_len;\n  /** Max Age (how long should the cookie persist), in seconds (0 == session).*/\n  int max_age;\n  /** Limit cookie to secure connections.*/\n  unsigned secure : 1;\n  /** Limit cookie to HTTP (intended to prevent javascript access/hijacking).*/\n  unsigned http_only : 1;\n} http_cookie_args_s;\n\n/**\n * Sets a response header, taking ownership of the value object, but NOT the\n * name object (so name objects could be reused in future responses).\n *\n * Returns -1 on error and 0 on success.\n */\nint http_set_header(http_s *h, FIOBJ name, FIOBJ value);\n\n/**\n * Sets a response header.\n *\n * Returns -1 on error and 0 on success.\n */\nint http_set_header2(http_s *h, fio_str_info_s name, fio_str_info_s value);\n\n/**\n * Sets a response cookie.\n *\n * Returns -1 on error and 0 on success.\n *\n * Note: Long cookie names and long cookie values will be considered a security\n * violation and an error will be returned. It should be noted that most\n * proxies and servers will refuse long cookie names or values and many impose\n * total header lengths (including cookies) of ~8Kib.\n */\nint http_set_cookie(http_s *h, http_cookie_args_s);\n#define http_set_cookie(http___handle, ...)                                    \\\n  http_set_cookie((http___handle), (http_cookie_args_s){__VA_ARGS__})\n\n/**\n * Sends the response headers and body.\n *\n * **Note**: The body is *copied* to the HTTP stream and it's memory should be\n * freed by the calling function.\n *\n * Returns -1 on error and 0 on success.\n *\n * AFTER THIS FUNCTION IS CALLED, THE `http_s` OBJECT IS NO LONGER VALID.\n */\nint http_send_body(http_s *h, void *data, uintptr_t length);\n\n/**\n * Sends the response headers and the specified file (the response's body).\n *\n * The file is closed automatically.\n *\n * Returns -1 on error and 0 on success.\n *\n * AFTER THIS FUNCTION IS CALLED, THE `http_s` OBJECT IS NO LONGER VALID.\n */\nint http_sendfile(http_s *h, int fd, uintptr_t length, uintptr_t offset);\n\n/**\n * Sends the response headers and the specified file (the response's body).\n *\n * The `local` and `encoded` strings will be joined into a single string that\n * represent the file name. Either or both of these strings can be empty.\n *\n * The `encoded` string will be URL decoded while the `local` string will used\n * as is.\n *\n * Returns 0 on success. A success value WILL CONSUME the `http_s` handle (it\n * will become invalid).\n *\n * Returns -1 on error (The `http_s` handle should still be used).\n */\nint http_sendfile2(http_s *h, const char *prefix, size_t prefix_len,\n                   const char *encoded, size_t encoded_len);\n\n/**\n * Sends an HTTP error response.\n *\n * Returns -1 on error and 0 on success.\n *\n * AFTER THIS FUNCTION IS CALLED, THE `http_s` OBJECT IS NO LONGER VALID.\n *\n * The `uuid` and `settings` arguments are only required if the `http_s` handle\n * is NULL.\n */\nint http_send_error(http_s *h, size_t error_code);\n\n/**\n * Sends the response headers for a header only response.\n *\n * AFTER THIS FUNCTION IS CALLED, THE `http_s` OBJECT IS NO LONGER VALID.\n */\nvoid http_finish(http_s *h);\n\n/**\n * Pushes a data response when supported (HTTP/2 only).\n *\n * Returns -1 on error and 0 on success.\n */\nint http_push_data(http_s *h, void *data, uintptr_t length, FIOBJ mime_type);\n\n/**\n * Pushes a file response when supported (HTTP/2 only).\n *\n * If `mime_type` is NULL, an attempt at automatic detection using `filename`\n * will be made.\n *\n * Returns -1 on error and 0 on success.\n */\nint http_push_file(http_s *h, FIOBJ filename, FIOBJ mime_type);\n\n/* *****************************************************************************\nHTTP evented API (pause / resume HTTp handling)\n***************************************************************************** */\n\ntypedef struct http_pause_handle_s http_pause_handle_s;\n/**\n * Pauses the request / response handling and INVALIDATES the current `http_s`\n * handle (no `http` functions can be called).\n *\n * The `http_resume` function MUST be called (at some point) using the opaque\n * `http` pointer given to the callback `task`.\n *\n * The opaque `http` pointer is only valid for a single call to `http_resume`\n * and can't be used by any other `http` function (it's a different data type).\n *\n * Note: the current `http_s` handle will become invalid once this function is\n *    called and it's data might be deallocated, invalid or used by a different\n *    thread.\n */\nvoid http_pause(http_s *h, void (*task)(http_pause_handle_s *http));\n\n/**\n * Resumes a request / response handling within a task and INVALIDATES the\n * current `http_s` handle.\n *\n * The `task` MUST call one of the `http_send_*`, `http_finish`, or\n * `http_pause`functions.\n *\n * The (optional) `fallback` will receive the opaque `udata` that was stored in\n * the HTTP handle and can be used for cleanup.\n *\n * Note: `http_resume` can only be called after calling `http_pause` and\n * entering it's task.\n *\n * Note: the current `http_s` handle will become invalid once this function is\n *    called and it's data might be deallocated, invalidated or used by a\n *    different thread.\n */\nvoid http_resume(http_pause_handle_s *http, void (*task)(http_s *h),\n                 void (*fallback)(void *udata));\n\n/** Returns the `udata` associated with the paused opaque handle */\nvoid *http_paused_udata_get(http_pause_handle_s *http);\n\n/**\n * Sets the `udata` associated with the paused opaque handle, returning the\n * old value.\n */\nvoid *http_paused_udata_set(http_pause_handle_s *http, void *udata);\n\n/* *****************************************************************************\nHTTP Connections - Listening / Connecting / Hijacking\n***************************************************************************** */\n\n/** The HTTP settings. */\nstruct http_settings_s {\n  /** Callback for normal HTTP requests. */\n  void (*on_request)(http_s *request);\n  /**\n   * Callback for Upgrade and EventSource (SSE) requests.\n   *\n   * SSE/EventSource requests set the `requested_protocol` string to `\"sse\"`.\n   */\n  void (*on_upgrade)(http_s *request, char *requested_protocol, size_t len);\n  /** CLIENT REQUIRED: a callback for the HTTP response. */\n  void (*on_response)(http_s *response);\n  /** (optional) the callback to be performed when the HTTP service closes. */\n  void (*on_finish)(struct http_settings_s *settings);\n  /** Opaque user data. Facil.io will ignore this field, but you can use it. */\n  void *udata;\n  /**\n   * A public folder for file transfers - allows to circumvent any application\n   * layer logic and simply serve static files.\n   *\n   * Supports automatic `gz` pre-compressed alternatives.\n   */\n  const char *public_folder;\n  /**\n   * The length of the public_folder string.\n   */\n  size_t public_folder_length;\n  /**\n   * The maximum number of bytes allowed for the request string (method, path,\n   * query), header names and fields.\n   *\n   * Defaults to 32Kib (which is about 4 times more than I would recommend).\n   *\n   * This reflects the total overall size. On HTTP/1.1, each header line (name +\n   * value pair) is also limitied to a hardcoded HTTP_MAX_HEADER_LENGTH bytes.\n   */\n  size_t max_header_size;\n  /**\n   * The maximum size of an HTTP request's body (posting / downloading).\n   *\n   * Defaults to ~ 50Mb.\n   */\n  size_t max_body_size;\n  /**\n   * The maximum number of clients that are allowed to connect concurrently.\n   *\n   * This value's default setting is usually for the best.\n   *\n   * The default value is computed according to the server's capacity, leaving\n   * some breathing room for other network and disk operations.\n   *\n   * Note: clients, by the nature of socket programming, are counted according\n   *       to their internal file descriptor (`fd`) value. Open files and other\n   *       sockets count towards a server's limit.\n   */\n  intptr_t max_clients;\n  /** SSL/TLS support. */\n  void *tls;\n  /** reserved for future use. */\n  intptr_t reserved1;\n  /** reserved for future use. */\n  intptr_t reserved2;\n  /** reserved for future use. */\n  intptr_t reserved3;\n  /**\n   * The maximum websocket message size/buffer (in bytes) for Websocket\n   * connections. Defaults to ~250KB.\n   */\n  size_t ws_max_msg_size;\n  /**\n   * An HTTP/1.x connection timeout.\n   *\n   * `http_listen` defaults to ~40s and `http_connect` defaults to ~30s.\n   *\n   * Note: the connection might be closed (by other side) before timeout occurs.\n   */\n  uint8_t timeout;\n  /**\n   * Timeout for the websocket connections, a ping will be sent whenever the\n   * timeout is reached. Defaults to 40 seconds.\n   *\n   * Connections are only closed when a ping cannot be sent (the network layer\n   * fails). Pongs are ignored.\n   */\n  uint8_t ws_timeout;\n  /** Logging flag - set to TRUE to log HTTP requests. */\n  uint8_t log;\n  /** a read only flag set automatically to indicate the protocol's mode. */\n  uint8_t is_client;\n};\n\n/**\n * Listens to HTTP connections at the specified `port`.\n *\n * Leave as NULL to ignore IP binding.\n *\n * Returns -1 on error and the socket's uuid on success.\n *\n * the `on_finish` callback is always called.\n */\nintptr_t http_listen(const char *port, const char *binding,\n                     struct http_settings_s);\n/** Listens to HTTP connections at the specified `port` and `binding`. */\n#define http_listen(port, binding, ...)                                        \\\n  http_listen((port), (binding), (struct http_settings_s){__VA_ARGS__})\n\n/**\n * Connects to an HTTP server as a client.\n *\n * Upon a successful connection, the `on_response` callback is called with an\n * empty `http_s*` handler (status == 0). Use the same API to set it's content\n * and send the request to the server. The next`on_response` will contain the\n * response.\n *\n * `address` should contain a full URL style address for the server. i.e.:\n *\n *           \"http:/www.example.com:8080/\"\n *\n * If an `address` includes a path or query data, they will be automatically\n * attached (both of them) to the HTTP handl'es `path` property. i.e.\n *\n *           \"http:/www.example.com:8080/my_path?foo=bar\"\n *           // will result in:\n *           fiobj_obj2cstr(h->path).data; //=> \"/my_path?foo=bar\"\n *\n * To open a Websocket connection, it's possible to use the `ws` protocol\n * signature. However, it would be better to use the `websocket_connect`\n * function instead.\n *\n * Returns -1 on error and the socket's uuid on success.\n *\n * The `on_finish` callback is always called.\n */\nintptr_t http_connect(const char *url, const char *unix_address,\n                      struct http_settings_s);\n#define http_connect(url, unix_address, ...)                                   \\\n  http_connect((url), (unix_address), (struct http_settings_s){__VA_ARGS__})\n\n/**\n * Returns the settings used to setup the connection or NULL on error.\n */\nstruct http_settings_s *http_settings(http_s *h);\n\n/**\n * Returns the direct address of the connected peer (likely an intermediary).\n */\nfio_str_info_s http_peer_addr(http_s *h);\n\n/**\n * Hijacks the socket away from the HTTP protocol and away from facil.io.\n *\n * It's possible to hijack the socket and than reconnect it to a new protocol\n * object.\n *\n * It's possible to call `http_finish` immediately after calling `http_hijack`\n * in order to send the outgoing headers.\n *\n * If any additional HTTP functions are called after the hijacking, the protocol\n * object might attempt to continue reading data from the buffer.\n *\n * Returns the underlining socket connection's uuid. If `leftover` isn't NULL,\n * it will be populated with any remaining data in the HTTP buffer (the data\n * will be automatically deallocated, so copy the data when in need).\n *\n * WARNING: this isn't a good way to handle HTTP connections, especially as\n * HTTP/2 enters the picture.\n */\nintptr_t http_hijack(http_s *h, fio_str_info_s *leftover);\n\n/* *****************************************************************************\nWebsocket Upgrade (Server and Client connection establishment)\n***************************************************************************** */\n\n/**\n * The type for a Websocket handle, used to identify a Websocket connection.\n *\n * Similar to an `http_s` handle, it is only valid within the scope of the\n * specific connection (the callbacks / tasks) and shouldn't be stored or\n * accessed otherwise.\n */\ntypedef struct ws_s ws_s;\n\n/**\n * This struct is used for the named arguments in the `http_upgrade2ws`\n * function and macro.\n */\ntypedef struct {\n  /**\n   * The (optional) on_message callback will be called whenever a websocket\n   * message is received for this connection.\n   *\n   * The data received points to the websocket's message buffer and it will be\n   * overwritten once the function exits (it cannot be saved for later, but it\n   * can be copied).\n   */\n  void (*on_message)(ws_s *ws, fio_str_info_s msg, uint8_t is_text);\n  /**\n   * The (optional) on_open callback will be called once the websocket\n   * connection is established and before is is registered with `facil`, so no\n   * `on_message` events are raised before `on_open` returns.\n   */\n  void (*on_open)(ws_s *ws);\n  /**\n   * The (optional) on_ready callback will be after a the underlying socket's\n   * buffer changes it's state from full to empty.\n   *\n   * If the socket's buffer is never used, the callback is never called.\n   */\n  void (*on_ready)(ws_s *ws);\n  /**\n   * The (optional) on_shutdown callback will be called if a websocket\n   * connection is still open while the server is shutting down (called before\n   * `on_close`).\n   */\n  void (*on_shutdown)(ws_s *ws);\n  /**\n   * The (optional) on_close callback will be called once a websocket connection\n   * is terminated or failed to be established.\n   *\n   * The `uuid` is the connection's unique ID that can identify the Websocket. A\n   * value of `uuid == 0` indicates the Websocket connection wasn't established\n   * (an error occurred).\n   *\n   * The `udata` is the user data as set during the upgrade or using the\n   * `websocket_udata_set` function.\n   */\n  void (*on_close)(intptr_t uuid, void *udata);\n  /** Opaque user data. */\n  void *udata;\n} websocket_settings_s;\n\n/**\n * Upgrades an HTTP/1.1 connection to a Websocket connection.\n *\n * This function will end the HTTP stage of the connection and attempt to\n * \"upgrade\" to a Websockets connection.\n *\n * Thie `http_s` handle will be invalid after this call and the `udata` will be\n * set to the new Websocket `udata`.\n *\n * A client connection's `on_finish` callback will be called (since the HTTP\n * stage has finished).\n */\nint http_upgrade2ws(http_s *http, websocket_settings_s);\n\n/** This macro allows easy access to the `http_upgrade2ws` function. The macro\n * allows the use of named arguments, using the `websocket_settings_s` struct\n * members. i.e.:\n *\n *     on_message(ws_s * ws, char * data, size_t size, int is_text) {\n *        ; // ... this is the websocket on_message callback\n *        websocket_write(ws, data, size, is_text); // a simple echo example\n *     }\n *\n *     on_upgrade(http_s* h) {\n *        http_upgrade2ws( .http = h, .on_message = on_message);\n *     }\n */\n#define http_upgrade2ws(http, ...)                                             \\\n  http_upgrade2ws((http), (websocket_settings_s){__VA_ARGS__})\n\n/**\n * Connects to a Websocket service according to the provided address.\n *\n * This is a somewhat naive connector object, it doesn't perform any\n * authentication or other logical handling. However, it's quire easy to author\n * a complext authentication logic using a combination of `http_connect` and\n * `http_upgrade2ws`.\n *\n * Returns the uuid for the future websocket on success.\n *\n * Returns -1 on error;\n */\nint websocket_connect(const char *url, websocket_settings_s settings);\n#define websocket_connect(url, ...)                                            \\\n  websocket_connect((url), (websocket_settings_s){__VA_ARGS__})\n\n#include <websockets.h>\n\n/* *****************************************************************************\nEventSource Support (SSE)\n***************************************************************************** */\n\n/**\n * The type for the EventSource (SSE) handle, used to identify an SSE\n * connection.\n */\ntypedef struct http_sse_s http_sse_s;\n\n/**\n * This struct is used for the named arguments in the `http_upgrade2sse`\n * function and macro.\n */\nstruct http_sse_s {\n  /**\n   * The (optional) on_open callback will be called once the EventSource\n   * connection is established.\n   */\n  void (*on_open)(http_sse_s *sse);\n  /**\n   * The (optional) on_ready callback will be after a the underlying socket's\n   * buffer changes it's state to empty.\n   *\n   * If the socket's buffer is never used, the callback is never called.\n   */\n  void (*on_ready)(http_sse_s *sse);\n  /**\n   * The (optional) on_shutdown callback will be called if a connection is still\n   * open while the server is shutting down (called before `on_close`).\n   */\n  void (*on_shutdown)(http_sse_s *sse);\n  /**\n   * The (optional) on_close callback will be called once a connection is\n   * terminated or failed to be established.\n   *\n   * The `udata` passed to the `http_upgrade2sse` function is available\n   * through the `http_sse_s` pointer (`sse->udata`).\n   */\n  void (*on_close)(http_sse_s *sse);\n  /** Opaque user data. */\n  void *udata;\n};\n\n/**\n * Upgrades an HTTP connection to an EventSource (SSE) connection.\n *\n * The `http_s` handle will be invalid after this call.\n *\n * On HTTP/1.1 connections, this will preclude future requests using the same\n * connection.\n */\nint http_upgrade2sse(http_s *h, http_sse_s);\n\n/** This macro allows easy access to the `http_upgrade2sse` function. The macro\n * allows the use of named arguments, using the `websocket_settings_s` struct\n * members. i.e.:\n *\n *     on_open_sse(sse_s * sse) {\n *        http_sse_subscribe(sse, .channel = CHANNEL_NAME);\n *     }\n *\n *     on_upgrade(http_s* h) {\n *        http_upgrade2sse(h, .on_open = on_open_sse);\n *     }\n */\n#define http_upgrade2sse(h, ...)                                               \\\n  http_upgrade2sse((h), (http_sse_s){__VA_ARGS__})\n\n/**\n * Sets the ping interval for SSE connections.\n */\nvoid http_sse_set_timout(http_sse_s *sse, uint8_t timeout);\n\nstruct http_sse_subscribe_args {\n  /** The channel name used for the subscription. */\n  fio_str_info_s channel;\n  /** The optional on message callback. If missing, Data is directly writen. */\n  void (*on_message)(http_sse_s *sse, fio_str_info_s channel,\n                     fio_str_info_s msg, void *udata);\n  /** An optional callback for when a subscription is fully canceled. */\n  void (*on_unsubscribe)(void *udata);\n  /** Opaque user */\n  void *udata;\n  /** A callback for pattern matching. */\n  fio_match_fn match;\n};\n\n/**\n * Subscribes to a channel for direct message deliverance. See {struct\n * http_sse_subscribe_args} for possible arguments.\n *\n * Returns a subscription ID on success and 0 on failure.\n *\n * To unsubscripbe from the channel, use `http_sse_unsubscribe` (NOT\n * `fio_unsubscribe`).\n *\n * All subscriptions are automatically cleared once the connection is closed.\n */\nuintptr_t http_sse_subscribe(http_sse_s *sse,\n                             struct http_sse_subscribe_args args);\n\n/** This macro allows easy access to the `http_sse_subscribe` function. */\n#define http_sse_subscribe(sse, ...)                                           \\\n  http_sse_subscribe((sse), (struct http_sse_subscribe_args){__VA_ARGS__})\n\n/**\n * Cancels a subscription and invalidates the subscription object.\n */\nvoid http_sse_unsubscribe(http_sse_s *sse, uintptr_t subscription);\n\n/**\n * Named arguments for the {http_sse_write} function.\n *\n * These arguments list the possible fields for the SSE event.\n *\n * Event fields listed here:\n * https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events\n */\nstruct http_sse_write_args {\n  fio_str_info_s id;    /* (optional) sets the `id` event property. */\n  fio_str_info_s event; /* (optional) sets the `event` event property. */\n  fio_str_info_s data;  /* (optional) sets the `data` event property. */\n  intptr_t retry;       /* (optional) sets the `retry` event property. */\n};\n\n/**\n * Writes data to an EventSource (SSE) connection.\n *\n * See the {struct http_sse_write_args} for possible named arguments.\n */\nint http_sse_write(http_sse_s *sse, struct http_sse_write_args);\n#define http_sse_write(sse, ...)                                               \\\n  http_sse_write((sse), (struct http_sse_write_args){__VA_ARGS__})\n\n/**\n * Get the connection's UUID (for `fio_defer_io_task`, pub/sub, etc').\n */\nintptr_t http_sse2uuid(http_sse_s *sse);\n\n/**\n * Closes an EventSource (SSE) connection.\n */\nint http_sse_close(http_sse_s *sse);\n\n/**\n * Duplicates an SSE handle by reference, remember to http_sse_free.\n *\n * Returns the same object (increases a reference count, no allocation is made).\n */\nhttp_sse_s *http_sse_dup(http_sse_s *sse);\n\n/**\n * Frees an SSE handle by reference (decreases the reference count).\n */\nvoid http_sse_free(http_sse_s *sse);\n\n/* *****************************************************************************\nHTTP GET and POST parsing helpers\n***************************************************************************** */\n\n/**\n * Attempts to decode the request's body.\n *\n * Supported Types include:\n * * application/x-www-form-urlencoded\n * * application/json\n * * multipart/form-data\n *\n * This should be called before `http_parse_query`, in order to support JSON\n * data.\n *\n * If the JSON data isn't an object, it will be saved under the key \"JSON\" in\n * the `params` hash.\n *\n * If the `multipart/form-data` type contains JSON files, they will NOT be\n * parsed (they will behave like any other file, with `data`, `type` and\n * `filename` keys assigned). This allows non-object JSON data (such as array)\n * to be handled by the app.\n */\nint http_parse_body(http_s *h);\n\n/**\n * Parses the query part of an HTTP request/response. Uses `http_add2hash`.\n *\n * This should be called after the `http_parse_body` function, just in case the\n * body is JSON that doesn't have an object at it's root.\n */\nvoid http_parse_query(http_s *h);\n\n/** Parses any Cookie / Set-Cookie headers, using the `http_add2hash` scheme. */\nvoid http_parse_cookies(http_s *h, uint8_t is_url_encoded);\n\n/**\n * Adds a named parameter to the hash, converting a string to an object and\n * resolving nesting references and URL decoding if required.\n *\n * i.e.:\n *\n * * \"name[]\" references a nested Array (nested in the Hash).\n * * \"name[key]\" references a nested Hash.\n * * \"name[][key]\" references a nested Hash within an array. Hash keys will be\n *   unique (repeating a key advances the hash).\n * * These rules can be nested (i.e. \"name[][key1][][key2]...\")\n * * \"name[][]\" is an error (there's no way for the parser to analyze\n *    dimensions)\n *\n * Note: names can't begin with \"[\" or end with \"]\" as these are reserved\n *       characters.\n */\nint http_add2hash(FIOBJ dest, char *name, size_t name_len, char *value,\n                  size_t value_len, uint8_t encoded);\n\n/**\n * Adds a named parameter to the hash, using an existing object and resolving\n * nesting references.\n *\n * i.e.:\n *\n * * \"name[]\" references a nested Array (nested in the Hash).\n * * \"name[key]\" references a nested Hash.\n * * \"name[][key]\" references a nested Hash within an array. Hash keys will be\n *   unique (repeating a key advances the array).\n * * These rules can be nested (i.e. \"name[][key1][][key2]...\")\n * * \"name[][]\" is an error (there's no way for the parser to analyze\n *    dimensions)\n *\n * Note: names can't begin with \"[\" or end with \"]\" as these are reserved\n *       characters.\n */\nint http_add2hash2(FIOBJ dest, char *name, size_t name_len, FIOBJ value,\n                   uint8_t encoded);\n\n/* *****************************************************************************\nHTTP Status Strings and Mime-Type helpers\n***************************************************************************** */\n\n/** Returns a human readable string related to the HTTP status number. */\nfio_str_info_s http_status2str(uintptr_t status);\n\n/** Registers a Mime-Type to be associated with the file extension. */\nvoid http_mimetype_register(char *file_ext, size_t file_ext_len,\n                            FIOBJ mime_type_str);\n\n/**\n * Finds the mime-type associated with the file extension, returning a String on\n * success and FIOBJ_INVALID on failure.\n *\n * Remember to call `fiobj_free`.\n */\nFIOBJ http_mimetype_find(char *file_ext, size_t file_ext_len);\n\n/**\n * Returns the mime-type associated with the URL or the default mime-type for\n * HTTP.\n *\n * Remember to call `fiobj_free`.\n */\nFIOBJ http_mimetype_find2(FIOBJ url);\n\n/** Clears the Mime-Type registry (it will be empty after this call). */\nvoid http_mimetype_clear(void);\n\n/* *****************************************************************************\nCommonly used headers (fiobj Symbol objects)\n***************************************************************************** */\n\nextern FIOBJ HTTP_HEADER_ACCEPT;\nextern FIOBJ HTTP_HEADER_CACHE_CONTROL;\nextern FIOBJ HTTP_HEADER_CONNECTION;\nextern FIOBJ HTTP_HEADER_CONTENT_ENCODING;\nextern FIOBJ HTTP_HEADER_CONTENT_LENGTH;\nextern FIOBJ HTTP_HEADER_CONTENT_RANGE;\nextern FIOBJ HTTP_HEADER_CONTENT_TYPE;\nextern FIOBJ HTTP_HEADER_COOKIE;\nextern FIOBJ HTTP_HEADER_DATE;\nextern FIOBJ HTTP_HEADER_ETAG;\nextern FIOBJ HTTP_HEADER_HOST;\nextern FIOBJ HTTP_HEADER_LAST_MODIFIED;\nextern FIOBJ HTTP_HEADER_ORIGIN;\nextern FIOBJ HTTP_HEADER_SET_COOKIE;\nextern FIOBJ HTTP_HEADER_UPGRADE;\n\n/* *****************************************************************************\nHTTP General Helper functions that could be used globally\n***************************************************************************** */\n\n/**\n * Returns a String object representing the unparsed HTTP request (HTTP version\n * is capped at HTTP/1.1). Mostly usable for proxy usage and debugging.\n */\nFIOBJ http_req2str(http_s *h);\n\n/**\n * Writes a log line to `stderr` about the request / response object.\n *\n * This function is called automatically if the `.log` setting is enabled.\n */\nvoid http_write_log(http_s *h);\n/* *****************************************************************************\nHTTP Time related helper functions that could be used globally\n***************************************************************************** */\n\n/**\nA faster (yet less localized) alternative to `gmtime_r`.\n\nSee the libc `gmtime_r` documentation for details.\n\nFalls back to `gmtime_r` for dates before epoch.\n*/\nstruct tm *http_gmtime(time_t timer, struct tm *tmbuf);\n\n/** Writes an RFC 7231 date representation (HTTP date format) to target. */\nsize_t http_date2rfc7231(char *target, struct tm *tmbuf);\n/** Writes an RFC 2109 date representation to target. */\nsize_t http_date2rfc2109(char *target, struct tm *tmbuf);\n/** Writes an RFC 2822 date representation to target. */\nsize_t http_date2rfc2822(char *target, struct tm *tmbuf);\n/**\nWrites an HTTP date string to the `target` buffer.\n\nThis requires ~32 bytes of space to be available at the target buffer (unless\nit's a super funky year, 32 bytes is about 3 more than you need).\n\nReturns the number of bytes actually written.\n*/\nstatic inline size_t http_date2str(char *target, struct tm *tmbuf) {\n  return http_date2rfc7231(target, tmbuf);\n}\n\n/**\n * Prints Unix time to a HTTP time formatted string.\n *\n * This variation implements cached results for faster processing, at the\n * price of a less accurate string.\n */\nsize_t http_time2str(char *target, const time_t t);\n\n/* *****************************************************************************\nHTTP URL decoding helper functions that might be used globally\n***************************************************************************** */\n\n/** Decodes a URL encoded string, no buffer overflow protection. */\nssize_t http_decode_url_unsafe(char *dest, const char *url_data);\n\n/** Decodes a URL encoded string (query / form data). */\nssize_t http_decode_url(char *dest, const char *url_data, size_t length);\n\n/** Decodes the \"path\" part of a request, no buffer overflow protection. */\nssize_t http_decode_path_unsafe(char *dest, const char *url_data);\n\n/**\n * Decodes the \"path\" part of an HTTP request, no buffer overflow protection.\n */\nssize_t http_decode_path(char *dest, const char *url_data, size_t length);\n\n/* *****************************************************************************\nHTTP URL parsing\n***************************************************************************** */\n\n/** the result returned by `http_url_parse` */\ntypedef fio_url_s http_url_s\n    __attribute__((deprecated(\"use fio_url_s instead\")));\n\n/**\n * Parses the URI returning it's components and their lengths (no decoding\n * performed, doesn't accept decoded URIs).\n *\n * The returned string are NOT NUL terminated, they are merely locations within\n * the original string.\n *\n * This function expects any of the following formats:\n *\n * * `/complete_path?query#target`\n *\n *   i.e.: /index.html?page=1#list\n *\n * * `host:port/complete_path?query#target`\n *\n *   i.e.:\n *      example.com\n *      example.com/index.html\n *      example.com:8080/index.html\n *      example.com:8080/index.html?key=val#target\n *\n * * `user:password@host:port/path?query#target`\n *\n *   i.e.: user:1234@example.com:8080/index.html\n *\n * * `schema://user:password@host:port/path?query#target`\n *\n *   i.e.: http://example.com/index.html?page=1#list\n *\n * Invalid formats might produce unexpected results. No error testing performed.\n */\n#define http_url_parse(url, len) fio_url_parse((url), (len))\n\n#if DEBUG\nvoid http_tests(void);\n#endif\n\n/* support C++ */\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* H_HTTP_H */\n", "/*\nCopyright: Boaz Segev, 2017-2019\nLicense: MIT\n*/\n#include <fio.h>\n\n#include <http1.h>\n#include <http1_parser.h>\n#include <http_internal.h>\n#include <websockets.h>\n\n#include <fiobj.h>\n\n#include <assert.h>\n#include <stddef.h>\n\n/* *****************************************************************************\nThe HTTP/1.1 Protocol Object\n***************************************************************************** */\n\ntypedef struct http1pr_s {\n  http_fio_protocol_s p;\n  http1_parser_s parser;\n  http_s request;\n  uintptr_t buf_len;\n  uintptr_t max_header_size;\n  uintptr_t header_size;\n  uint8_t close;\n  uint8_t is_client;\n  uint8_t stop;\n  uint8_t buf[];\n} http1pr_s;\n\nstruct http_vtable_s HTTP1_VTABLE; /* initialized later on */\n\n/* *****************************************************************************\nInternal Helpers\n***************************************************************************** */\n\n#define parser2http(x)                                                         \\\n  ((http1pr_s *)((uintptr_t)(x) - (uintptr_t)(&((http1pr_s *)0)->parser)))\n\ninline static void h1_reset(http1pr_s *p) { p->header_size = 0; }\n\n#define http1_pr2handle(pr) (((http1pr_s *)(pr))->request)\n#define handle2pr(h) ((http1pr_s *)h->private_data.flag)\n\nstatic fio_str_info_s http1pr_status2str(uintptr_t status);\n\n/* cleanup an HTTP/1.1 handler object */\nstatic inline void http1_after_finish(http_s *h) {\n  http1pr_s *p = handle2pr(h);\n  p->stop = p->stop & (~1UL);\n  if (h != &p->request) {\n    http_s_destroy(h, 0);\n    fio_free(h);\n  } else {\n    http_s_clear(h, p->p.settings->log);\n  }\n  if (p->close)\n    fio_close(p->p.uuid);\n}\n\n/* *****************************************************************************\nHTTP Request / Response (Virtual) Functions\n***************************************************************************** */\nstruct header_writer_s {\n  FIOBJ dest;\n  FIOBJ name;\n  FIOBJ value;\n};\n\nstatic int write_header(FIOBJ o, void *w_) {\n  struct header_writer_s *w = w_;\n  if (!o)\n    return 0;\n  if (fiobj_hash_key_in_loop()) {\n    w->name = fiobj_hash_key_in_loop();\n  }\n  if (FIOBJ_TYPE_IS(o, FIOBJ_T_ARRAY)) {\n    fiobj_each1(o, 0, write_header, w);\n    return 0;\n  }\n  fio_str_info_s name = fiobj_obj2cstr(w->name);\n  fio_str_info_s str = fiobj_obj2cstr(o);\n  if (!str.data)\n    return 0;\n  // fiobj_str_capa_assert(w->dest,\n  //                       fiobj_obj2cstr(w->dest).len + name.len + str.len +\n  //                       5);\n  fiobj_str_write(w->dest, name.data, name.len);\n  fiobj_str_write(w->dest, \":\", 1);\n  fiobj_str_write(w->dest, str.data, str.len);\n  fiobj_str_write(w->dest, \"\\r\\n\", 2);\n  return 0;\n}\n\nstatic FIOBJ headers2str(http_s *h, uintptr_t padding) {\n  if (!h->method && !!h->status_str)\n    return FIOBJ_INVALID;\n\n  static uintptr_t connection_hash;\n  if (!connection_hash)\n    connection_hash = fiobj_hash_string(\"connection\", 10);\n\n  struct header_writer_s w;\n  {\n    const uintptr_t header_length_guess =\n        fiobj_hash_count(h->private_data.out_headers) * 64;\n    w.dest = fiobj_str_buf(header_length_guess + padding);\n  }\n  http1pr_s *p = handle2pr(h);\n\n  if (p->is_client == 0) {\n    fio_str_info_s t = http1pr_status2str(h->status);\n    fiobj_str_write(w.dest, t.data, t.len);\n    FIOBJ tmp = fiobj_hash_get2(h->private_data.out_headers, connection_hash);\n    if (tmp) {\n      t = fiobj_obj2cstr(tmp);\n      if (t.data[0] == 'c' || t.data[0] == 'C')\n        p->close = 1;\n    } else {\n      tmp = fiobj_hash_get2(h->headers, connection_hash);\n      if (tmp) {\n        t = fiobj_obj2cstr(tmp);\n        if (!t.data || !t.len || t.data[0] == 'k' || t.data[0] == 'K')\n          fiobj_str_write(w.dest, \"connection:keep-alive\\r\\n\", 23);\n        else {\n          fiobj_str_write(w.dest, \"connection:close\\r\\n\", 18);\n          p->close = 1;\n        }\n      } else {\n        t = fiobj_obj2cstr(h->version);\n        if (!p->close && t.len > 7 && t.data && t.data[5] == '1' &&\n            t.data[6] == '.' && t.data[7] == '1')\n          fiobj_str_write(w.dest, \"connection:keep-alive\\r\\n\", 23);\n        else {\n          fiobj_str_write(w.dest, \"connection:close\\r\\n\", 18);\n          p->close = 1;\n        }\n      }\n    }\n  } else {\n    if (h->method) {\n      fiobj_str_join(w.dest, h->method);\n      fiobj_str_write(w.dest, \" \", 1);\n    } else {\n      fiobj_str_write(w.dest, \"GET \", 4);\n    }\n    fiobj_str_join(w.dest, h->path);\n    if (h->query) {\n      fiobj_str_write(w.dest, \"?\", 1);\n      fiobj_str_join(w.dest, h->query);\n    }\n    fiobj_str_write(w.dest, \" HTTP/1.1\\r\\n\", 11);\n    /* make sure we have a host header? */\n    static uint64_t host_hash;\n    if (!host_hash)\n      host_hash = fiobj_hash_string(\"host\", 4);\n    FIOBJ tmp;\n    if (!fiobj_hash_get2(h->private_data.out_headers, host_hash) &&\n        (tmp = fiobj_hash_get2(h->headers, host_hash))) {\n      fiobj_str_write(w.dest, \"host:\", 5);\n      fiobj_str_join(w.dest, tmp);\n      fiobj_str_write(w.dest, \"\\r\\n\", 2);\n    }\n    if (!fiobj_hash_get2(h->private_data.out_headers, connection_hash))\n      fiobj_str_write(w.dest, \"connection:keep-alive\\r\\n\", 23);\n  }\n\n  fiobj_each1(h->private_data.out_headers, 0, write_header, &w);\n  fiobj_str_write(w.dest, \"\\r\\n\", 2);\n  return w.dest;\n}\n\n/** Should send existing headers and data */\nstatic int http1_send_body(http_s *h, void *data, uintptr_t length) {\n\n  FIOBJ packet = headers2str(h, length);\n  if (!packet) {\n    http1_after_finish(h);\n    return -1;\n  }\n  fiobj_str_write(packet, data, length);\n  fiobj_send_free((handle2pr(h)->p.uuid), packet);\n  http1_after_finish(h);\n  return 0;\n}\n/** Should send existing headers and file */\nstatic int http1_sendfile(http_s *h, int fd, uintptr_t length,\n                          uintptr_t offset) {\n  FIOBJ packet = headers2str(h, 0);\n  if (!packet) {\n    close(fd);\n    http1_after_finish(h);\n    return -1;\n  }\n  if (length < HTTP_MAX_HEADER_LENGTH) {\n    /* optimize away small files */\n    fio_str_info_s s = fiobj_obj2cstr(packet);\n    fiobj_str_capa_assert(packet, s.len + length);\n    s = fiobj_obj2cstr(packet);\n    intptr_t i = pread(fd, s.data + s.len, length, offset);\n    if (i < 0) {\n      close(fd);\n      fiobj_send_free((handle2pr(h)->p.uuid), packet);\n      fio_close((handle2pr(h)->p.uuid));\n      return -1;\n    }\n    close(fd);\n    fiobj_str_resize(packet, s.len + i);\n    fiobj_send_free((handle2pr(h)->p.uuid), packet);\n    http1_after_finish(h);\n    return 0;\n  }\n  fiobj_send_free((handle2pr(h)->p.uuid), packet);\n  fio_sendfile((handle2pr(h)->p.uuid), fd, offset, length);\n  http1_after_finish(h);\n  return 0;\n}\n\n/** Should send existing headers or complete streaming */\nstatic void htt1p_finish(http_s *h) {\n  FIOBJ packet = headers2str(h, 0);\n  if (packet)\n    fiobj_send_free((handle2pr(h)->p.uuid), packet);\n  else {\n    // fprintf(stderr, \"WARNING: invalid call to `htt1p_finish`\\n\");\n  }\n  http1_after_finish(h);\n}\n/** Push for data - unsupported. */\nstatic int http1_push_data(http_s *h, void *data, uintptr_t length,\n                           FIOBJ mime_type) {\n  return -1;\n  (void)h;\n  (void)data;\n  (void)length;\n  (void)mime_type;\n}\n/** Push for files - unsupported. */\nstatic int http1_push_file(http_s *h, FIOBJ filename, FIOBJ mime_type) {\n  return -1;\n  (void)h;\n  (void)filename;\n  (void)mime_type;\n}\n\n/**\n * Called befor a pause task,\n */\nstatic void http1_on_pause(http_s *h, http_fio_protocol_s *pr) {\n  ((http1pr_s *)pr)->stop = 1;\n  fio_suspend(pr->uuid);\n  (void)h;\n}\n\n/**\n * called after the resume task had completed.\n */\nstatic void http1_on_resume(http_s *h, http_fio_protocol_s *pr) {\n  if (!((http1pr_s *)pr)->stop) {\n    fio_force_event(pr->uuid, FIO_EVENT_ON_DATA);\n  }\n  (void)h;\n}\n\nstatic intptr_t http1_hijack(http_s *h, fio_str_info_s *leftover) {\n  if (leftover) {\n    intptr_t len =\n        handle2pr(h)->buf_len -\n        (intptr_t)(handle2pr(h)->parser.state.next - handle2pr(h)->buf);\n    if (len) {\n      *leftover = (fio_str_info_s){\n          .len = len, .data = (char *)handle2pr(h)->parser.state.next};\n    } else {\n      *leftover = (fio_str_info_s){.len = 0, .data = NULL};\n    }\n  }\n\n  handle2pr(h)->stop = 3;\n  intptr_t uuid = handle2pr(h)->p.uuid;\n  fio_attach(uuid, NULL);\n  return uuid;\n}\n\n/* *****************************************************************************\nWebsockets Upgrading\n***************************************************************************** */\n\nstatic void http1_websocket_client_on_upgrade(http_s *h, char *proto,\n                                              size_t len) {\n  http1pr_s *p = handle2pr(h);\n  websocket_settings_s *args = h->udata;\n  const intptr_t uuid = handle2pr(h)->p.uuid;\n  http_settings_s *set = handle2pr(h)->p.settings;\n  set->udata = NULL;\n  http_finish(h);\n  p->stop = 1;\n  websocket_attach(uuid, set, args, p->parser.state.next,\n                   p->buf_len - (intptr_t)(p->parser.state.next - p->buf));\n  fio_free(args);\n  (void)proto;\n  (void)len;\n}\nstatic void http1_websocket_client_on_failed(http_s *h) {\n  websocket_settings_s *s = h->udata;\n  if (s->on_close)\n    s->on_close(0, s->udata);\n  fio_free(h->udata);\n  h->udata = http_settings(h)->udata = NULL;\n}\nstatic void http1_websocket_client_on_hangup(http_settings_s *settings) {\n  websocket_settings_s *s = settings->udata;\n  if (s) {\n    if (s->on_close)\n      s->on_close(0, s->udata);\n    fio_free(settings->udata);\n    settings->udata = NULL;\n  }\n}\n\nstatic int http1_http2websocket_server(http_s *h, websocket_settings_s *args) {\n  // A static data used for all websocket connections.\n  static char ws_key_accpt_str[] = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n  static uintptr_t sec_version = 0;\n  static uintptr_t sec_key = 0;\n  if (!sec_version)\n    sec_version = fiobj_hash_string(\"sec-websocket-version\", 21);\n  if (!sec_key)\n    sec_key = fiobj_hash_string(\"sec-websocket-key\", 17);\n\n  FIOBJ tmp = fiobj_hash_get2(h->headers, sec_version);\n  if (!tmp)\n    goto bad_request;\n  fio_str_info_s stmp = fiobj_obj2cstr(tmp);\n  if (stmp.len != 2 || stmp.data[0] != '1' || stmp.data[1] != '3')\n    goto bad_request;\n\n  tmp = fiobj_hash_get2(h->headers, sec_key);\n  if (!tmp)\n    goto bad_request;\n  stmp = fiobj_obj2cstr(tmp);\n\n  fio_sha1_s sha1 = fio_sha1_init();\n  fio_sha1_write(&sha1, stmp.data, stmp.len);\n  fio_sha1_write(&sha1, ws_key_accpt_str, sizeof(ws_key_accpt_str) - 1);\n  tmp = fiobj_str_buf(32);\n  stmp = fiobj_obj2cstr(tmp);\n  fiobj_str_resize(tmp,\n                   fio_base64_encode(stmp.data, fio_sha1_result(&sha1), 20));\n  http_set_header(h, HTTP_HEADER_CONNECTION, fiobj_dup(HTTP_HVALUE_WS_UPGRADE));\n  http_set_header(h, HTTP_HEADER_UPGRADE, fiobj_dup(HTTP_HVALUE_WEBSOCKET));\n  http_set_header(h, HTTP_HEADER_WS_SEC_KEY, tmp);\n  h->status = 101;\n  http1pr_s *pr = handle2pr(h);\n  const intptr_t uuid = handle2pr(h)->p.uuid;\n  http_settings_s *set = handle2pr(h)->p.settings;\n  http_finish(h);\n  pr->stop = 1;\n  websocket_attach(uuid, set, args, pr->parser.state.next,\n                   pr->buf_len - (intptr_t)(pr->parser.state.next - pr->buf));\n  return 0;\nbad_request:\n  http_send_error(h, 400);\n  if (args->on_close)\n    args->on_close(0, args->udata);\n  return -1;\n}\n\nstatic int http1_http2websocket_client(http_s *h, websocket_settings_s *args) {\n  http1pr_s *p = handle2pr(h);\n  /* We're done with the HTTP stage, so we call the `on_finish` */\n  if (p->p.settings->on_finish)\n    p->p.settings->on_finish(p->p.settings);\n  /* Copy the Websocket setting arguments to the HTTP settings `udata` */\n  p->p.settings->udata = fio_malloc(sizeof(*args));\n  ((websocket_settings_s *)(p->p.settings->udata))[0] = *args;\n  /* Set callbacks */\n  p->p.settings->on_finish = http1_websocket_client_on_hangup;   /* unknown */\n  p->p.settings->on_upgrade = http1_websocket_client_on_upgrade; /* sucess */\n  p->p.settings->on_response = http1_websocket_client_on_failed; /* failed */\n  p->p.settings->on_request = http1_websocket_client_on_failed;  /* failed */\n  /* Set headers */\n  http_set_header(h, HTTP_HEADER_CONNECTION, fiobj_dup(HTTP_HVALUE_WS_UPGRADE));\n  http_set_header(h, HTTP_HEADER_UPGRADE, fiobj_dup(HTTP_HVALUE_WEBSOCKET));\n  http_set_header(h, HTTP_HVALUE_WS_SEC_VERSION,\n                  fiobj_dup(HTTP_HVALUE_WS_VERSION));\n\n  /* we don't set the Origin header since we're not a browser... should we? */\n  // http_set_header(\n  //     h, HTTP_HEADER_ORIGIN,\n  //     fiobj_dup(fiobj_hash_get2(h->private_data.out_headers,\n  //                               fiobj_obj2hash(HTTP_HEADER_HOST))));\n\n  /* create nonce */\n  uint64_t key[2]; /* 16 bytes */\n  key[0] = (uintptr_t)h ^ (uint64_t)fio_last_tick().tv_sec;\n  key[1] = (uintptr_t)args->udata ^ (uint64_t)fio_last_tick().tv_nsec;\n  FIOBJ encoded = fiobj_str_buf(26); /* we need 24 really. */\n  fio_str_info_s tmp = fiobj_obj2cstr(encoded);\n  tmp.len = fio_base64_encode(tmp.data, (char *)key, 16);\n  fiobj_str_resize(encoded, tmp.len);\n  http_set_header(h, HTTP_HEADER_WS_SEC_CLIENT_KEY, encoded);\n  http_finish(h);\n  return 0;\n}\n\nstatic int http1_http2websocket(http_s *h, websocket_settings_s *args) {\n  assert(h);\n  http1pr_s *p = handle2pr(h);\n\n  if (p->is_client == 0) {\n    return http1_http2websocket_server(h, args);\n  }\n  return http1_http2websocket_client(h, args);\n}\n\n/* *****************************************************************************\nEventSource Support (SSE)\n***************************************************************************** */\n\n#undef http_upgrade2sse\n\ntypedef struct {\n  fio_protocol_s p;\n  http_sse_internal_s *sse;\n} http1_sse_fio_protocol_s;\n\nstatic void http1_sse_on_ready(intptr_t uuid, fio_protocol_s *p_) {\n  http1_sse_fio_protocol_s *p = (http1_sse_fio_protocol_s *)p_;\n  if (p->sse->sse.on_ready)\n    p->sse->sse.on_ready(&p->sse->sse);\n  (void)uuid;\n}\nstatic uint8_t http1_sse_on_shutdown(intptr_t uuid, fio_protocol_s *p_) {\n  http1_sse_fio_protocol_s *p = (http1_sse_fio_protocol_s *)p_;\n  if (p->sse->sse.on_shutdown)\n    p->sse->sse.on_shutdown(&p->sse->sse);\n  return 0;\n  (void)uuid;\n}\nstatic void http1_sse_on_close(intptr_t uuid, fio_protocol_s *p_) {\n  http1_sse_fio_protocol_s *p = (http1_sse_fio_protocol_s *)p_;\n  http_sse_destroy(p->sse);\n  fio_free(p);\n  (void)uuid;\n}\nstatic void http1_sse_ping(intptr_t uuid, fio_protocol_s *p_) {\n  fio_write2(uuid, .data.buffer = \": ping\\n\\n\", .length = 8,\n             .after.dealloc = FIO_DEALLOC_NOOP);\n  (void)p_;\n}\n\n/**\n * Upgrades an HTTP connection to an EventSource (SSE) connection.\n *\n * Thie `http_s` handle will be invalid after this call.\n *\n * On HTTP/1.1 connections, this will preclude future requests using the same\n * connection.\n */\nstatic int http1_upgrade2sse(http_s *h, http_sse_s *sse) {\n  const intptr_t uuid = handle2pr(h)->p.uuid;\n  /* send response */\n  h->status = 200;\n  http_set_header(h, HTTP_HEADER_CONTENT_TYPE, fiobj_dup(HTTP_HVALUE_SSE_MIME));\n  http_set_header(h, HTTP_HEADER_CACHE_CONTROL,\n                  fiobj_dup(HTTP_HVALUE_NO_CACHE));\n  http_set_header(h, HTTP_HEADER_CONTENT_ENCODING,\n                  fiobj_str_new(\"identity\", 8));\n  handle2pr(h)->stop = 1;\n  htt1p_finish(h); /* avoid the enforced content length in http_finish */\n\n  /* switch protocol to SSE */\n  http1_sse_fio_protocol_s *sse_pr = fio_malloc(sizeof(*sse_pr));\n  if (!sse_pr)\n    goto failed;\n  *sse_pr = (http1_sse_fio_protocol_s){\n      .p =\n          {\n              .on_ready = http1_sse_on_ready,\n              .on_shutdown = http1_sse_on_shutdown,\n              .on_close = http1_sse_on_close,\n              .ping = http1_sse_ping,\n          },\n      .sse = fio_malloc(sizeof(*(sse_pr->sse))),\n  };\n\n  if (!sse_pr->sse)\n    goto failed;\n\n  http_sse_init(sse_pr->sse, uuid, &HTTP1_VTABLE, sse);\n  fio_timeout_set(uuid, handle2pr(h)->p.settings->ws_timeout);\n  if (sse->on_open)\n    sse->on_open(&sse_pr->sse->sse);\n  fio_attach(uuid, &sse_pr->p);\n  return 0;\n\nfailed:\n  fio_close(handle2pr(h)->p.uuid);\n  if (sse->on_close)\n    sse->on_close(sse);\n  return -1;\n  (void)sse;\n}\n\n#undef http_sse_write\n/**\n * Writes data to an EventSource (SSE) connection.\n *\n * See the {struct http_sse_write_args} for possible named arguments.\n */\nstatic int http1_sse_write(http_sse_s *sse, FIOBJ str) {\n  return fiobj_send_free(((http_sse_internal_s *)sse)->uuid, str);\n}\n\n/**\n * Closes an EventSource (SSE) connection.\n */\nstatic int http1_sse_close(http_sse_s *sse) {\n  fio_close(((http_sse_internal_s *)sse)->uuid);\n  return 0;\n}\n/* *****************************************************************************\nVirtual Table Decleration\n***************************************************************************** */\n\nstruct http_vtable_s HTTP1_VTABLE = {\n    .http_send_body = http1_send_body,\n    .http_sendfile = http1_sendfile,\n    .http_finish = htt1p_finish,\n    .http_push_data = http1_push_data,\n    .http_push_file = http1_push_file,\n    .http_on_pause = http1_on_pause,\n    .http_on_resume = http1_on_resume,\n    .http_hijack = http1_hijack,\n    .http2websocket = http1_http2websocket,\n    .http_upgrade2sse = http1_upgrade2sse,\n    .http_sse_write = http1_sse_write,\n    .http_sse_close = http1_sse_close,\n};\n\nvoid *http1_vtable(void) { return (void *)&HTTP1_VTABLE; }\n\n/* *****************************************************************************\nParser Callbacks\n***************************************************************************** */\n\n/** called when a request was received. */\nstatic int http1_on_request(http1_parser_s *parser) {\n  http1pr_s *p = parser2http(parser);\n  http_on_request_handler______internal(&http1_pr2handle(p), p->p.settings);\n  if (p->request.method && !p->stop)\n    http_finish(&p->request);\n  h1_reset(p);\n  return fio_is_closed(p->p.uuid);\n}\n/** called when a response was received. */\nstatic int http1_on_response(http1_parser_s *parser) {\n  http1pr_s *p = parser2http(parser);\n  http_on_response_handler______internal(&http1_pr2handle(p), p->p.settings);\n  if (p->request.status_str && !p->stop)\n    http_finish(&p->request);\n  h1_reset(p);\n  return fio_is_closed(p->p.uuid);\n}\n/** called when a request method is parsed. */\nstatic int http1_on_method(http1_parser_s *parser, char *method,\n                           size_t method_len) {\n  http1_pr2handle(parser2http(parser)).method =\n      fiobj_str_new(method, method_len);\n  parser2http(parser)->header_size += method_len;\n  return 0;\n}\n\n/** called when a response status is parsed. the status_str is the string\n * without the prefixed numerical status indicator.*/\nstatic int http1_on_status(http1_parser_s *parser, size_t status,\n                           char *status_str, size_t len) {\n  http1_pr2handle(parser2http(parser)).status_str =\n      fiobj_str_new(status_str, len);\n  http1_pr2handle(parser2http(parser)).status = status;\n  parser2http(parser)->header_size += len;\n  return 0;\n}\n\n/** called when a request path (excluding query) is parsed. */\nstatic int http1_on_path(http1_parser_s *parser, char *path, size_t len) {\n  http1_pr2handle(parser2http(parser)).path = fiobj_str_new(path, len);\n  parser2http(parser)->header_size += len;\n  return 0;\n}\n\n/** called when a request path (excluding query) is parsed. */\nstatic int http1_on_query(http1_parser_s *parser, char *query, size_t len) {\n  http1_pr2handle(parser2http(parser)).query = fiobj_str_new(query, len);\n  parser2http(parser)->header_size += len;\n  return 0;\n}\n/** called when a the HTTP/1.x version is parsed. */\nstatic int http1_on_http_version(http1_parser_s *parser, char *version,\n                                 size_t len) {\n  http1_pr2handle(parser2http(parser)).version = fiobj_str_new(version, len);\n  parser2http(parser)->header_size += len;\n/* start counting - occurs on the first line of both requests and responses */\n#if FIO_HTTP_EXACT_LOGGING\n  clock_gettime(CLOCK_REALTIME,\n                &http1_pr2handle(parser2http(parser)).received_at);\n#else\n  http1_pr2handle(parser2http(parser)).received_at = fio_last_tick();\n#endif\n  return 0;\n}\n/** called when a header is parsed. */\nstatic int http1_on_header(http1_parser_s *parser, char *name, size_t name_len,\n                           char *data, size_t data_len) {\n  FIOBJ sym;\n  FIOBJ obj;\n  if (!http1_pr2handle(parser2http(parser)).headers) {\n    FIO_LOG_ERROR(\"(http1 parse ordering error) missing HashMap for header \"\n                  \"%s: %s\",\n                  name, data);\n    http_send_error2(500, parser2http(parser)->p.uuid,\n                     parser2http(parser)->p.settings);\n    return -1;\n  }\n  parser2http(parser)->header_size += name_len + data_len;\n  if (parser2http(parser)->header_size >=\n          parser2http(parser)->max_header_size ||\n      fiobj_hash_count(http1_pr2handle(parser2http(parser)).headers) >\n          HTTP_MAX_HEADER_COUNT) {\n    if (parser2http(parser)->p.settings->log) {\n      FIO_LOG_WARNING(\"(HTTP) security alert - header flood detected.\");\n    }\n    http_send_error(&http1_pr2handle(parser2http(parser)), 413);\n    return -1;\n  }\n  sym = fiobj_str_new(name, name_len);\n  obj = fiobj_str_new(data, data_len);\n  set_header_add(http1_pr2handle(parser2http(parser)).headers, sym, obj);\n  fiobj_free(sym);\n  return 0;\n}\n/** called when a body chunk is parsed. */\nstatic int http1_on_body_chunk(http1_parser_s *parser, char *data,\n                               size_t data_len) {\n  if (parser->state.content_length >\n          (ssize_t)parser2http(parser)->p.settings->max_body_size ||\n      parser->state.read >\n          (ssize_t)parser2http(parser)->p.settings->max_body_size) {\n    http_send_error(&http1_pr2handle(parser2http(parser)), 413);\n    return -1; /* test every time, in case of chunked data */\n  }\n  if (!parser->state.read) {\n    if (parser->state.content_length > 0 &&\n        parser->state.content_length <= HTTP_MAX_HEADER_LENGTH) {\n      http1_pr2handle(parser2http(parser)).body = fiobj_data_newstr();\n    } else {\n      http1_pr2handle(parser2http(parser)).body = fiobj_data_newtmpfile();\n    }\n  }\n  fiobj_data_write(http1_pr2handle(parser2http(parser)).body, data, data_len);\n  return 0;\n}\n\n/** called when a protocol error occurred. */\nstatic int http1_on_error(http1_parser_s *parser) {\n  if (parser2http(parser)->close)\n    return -1;\n  FIO_LOG_DEBUG(\"HTTP parser error.\");\n  fio_close(parser2http(parser)->p.uuid);\n  return -1;\n}\n\n/* *****************************************************************************\nConnection Callbacks\n***************************************************************************** */\n\nstatic inline void http1_consume_data(intptr_t uuid, http1pr_s *p) {\n  if (fio_pending(uuid) > 4) {\n    goto throttle;\n  }\n  ssize_t i = 0;\n  size_t org_len = p->buf_len;\n  int pipeline_limit = 8;\n  if (!p->buf_len)\n    return;\n  do {\n    i = http1_fio_parser(.parser = &p->parser,\n                         .buffer = p->buf + (org_len - p->buf_len),\n                         .length = p->buf_len, .on_request = http1_on_request,\n                         .on_response = http1_on_response,\n                         .on_method = http1_on_method,\n                         .on_status = http1_on_status, .on_path = http1_on_path,\n                         .on_query = http1_on_query,\n                         .on_http_version = http1_on_http_version,\n                         .on_header = http1_on_header,\n                         .on_body_chunk = http1_on_body_chunk,\n                         .on_error = http1_on_error);\n    p->buf_len -= i;\n    --pipeline_limit;\n  } while (i && p->buf_len && pipeline_limit && !p->stop);\n\n  if (p->buf_len && org_len != p->buf_len) {\n    memmove(p->buf, p->buf + (org_len - p->buf_len), p->buf_len);\n  }\n\n  if (p->buf_len == HTTP_MAX_HEADER_LENGTH) {\n    /* no room to read... parser not consuming data */\n    if (p->request.method)\n      http_send_error(&p->request, 413);\n    else {\n      p->request.method = fiobj_str_tmp();\n      http_send_error(&p->request, 413);\n    }\n  }\n\n  if (!pipeline_limit) {\n    fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  }\n  return;\n\nthrottle:\n  /* throttle busy clients (slowloris) */\n  p->stop |= 4;\n  fio_suspend(uuid);\n  FIO_LOG_DEBUG(\"(HTTP/1,1) throttling client at %.*s\",\n                (int)fio_peer_addr(uuid).len, fio_peer_addr(uuid).data);\n}\n\n/** called when a data is available, but will not run concurrently */\nstatic void http1_on_data(intptr_t uuid, fio_protocol_s *protocol) {\n  http1pr_s *p = (http1pr_s *)protocol;\n  if (p->stop) {\n    fio_suspend(uuid);\n    return;\n  }\n  ssize_t i = 0;\n  if (HTTP_MAX_HEADER_LENGTH - p->buf_len)\n    i = fio_read(uuid, p->buf + p->buf_len,\n                 HTTP_MAX_HEADER_LENGTH - p->buf_len);\n  if (i > 0) {\n    p->buf_len += i;\n  }\n  http1_consume_data(uuid, p);\n}\n\n/** called when the connection was closed, but will not run concurrently */\nstatic void http1_on_close(intptr_t uuid, fio_protocol_s *protocol) {\n  http1_destroy(protocol);\n  (void)uuid;\n}\n\n/** called when the connection was closed, but will not run concurrently */\nstatic void http1_on_ready(intptr_t uuid, fio_protocol_s *protocol) {\n  /* resume slow clients from suspension */\n  http1pr_s *p = (http1pr_s *)protocol;\n  if (p->stop & 4) {\n    p->stop ^= 4; /* flip back the bit, so it's zero */\n    fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  }\n  (void)protocol;\n}\n\n/** called when a data is available for the first time */\nstatic void http1_on_data_first_time(intptr_t uuid, fio_protocol_s *protocol) {\n  http1pr_s *p = (http1pr_s *)protocol;\n  ssize_t i;\n\n  i = fio_read(uuid, p->buf + p->buf_len, HTTP_MAX_HEADER_LENGTH - p->buf_len);\n\n  if (i <= 0)\n    return;\n  p->buf_len += i;\n\n  /* ensure future reads skip this first time HTTP/2.0 test */\n  p->p.protocol.on_data = http1_on_data;\n  if (i >= 24 && !memcmp(p->buf, \"PRI * HTTP/2.0\\r\\n\\r\\nSM\\r\\n\\r\\n\", 24)) {\n    FIO_LOG_WARNING(\"client claimed unsupported HTTP/2 prior knowledge.\");\n    fio_close(uuid);\n    return;\n  }\n\n  /* Finish handling the same way as the normal `on_data` */\n  http1_consume_data(uuid, p);\n}\n\n/* *****************************************************************************\nPublic API\n***************************************************************************** */\n\n/** Creates an HTTP1 protocol object and handles any unread data in the buffer\n * (if any). */\nfio_protocol_s *http1_new(uintptr_t uuid, http_settings_s *settings,\n                          void *unread_data, size_t unread_length) {\n  if (unread_data && unread_length > HTTP_MAX_HEADER_LENGTH)\n    return NULL;\n  http1pr_s *p = fio_malloc(sizeof(*p) + HTTP_MAX_HEADER_LENGTH);\n  // FIO_LOG_DEBUG(\"Allocated HTTP/1.1 protocol at. %p\", (void *)p);\n  FIO_ASSERT_ALLOC(p);\n  *p = (http1pr_s){\n      .p.protocol =\n          {\n              .on_data = http1_on_data_first_time,\n              .on_close = http1_on_close,\n              .on_ready = http1_on_ready,\n          },\n      .p.uuid = uuid,\n      .p.settings = settings,\n      .max_header_size = settings->max_header_size,\n      .is_client = settings->is_client,\n  };\n  http_s_new(&p->request, &p->p, &HTTP1_VTABLE);\n  if (unread_data && unread_length <= HTTP_MAX_HEADER_LENGTH) {\n    memcpy(p->buf, unread_data, unread_length);\n    p->buf_len = unread_length;\n  }\n  fio_attach(uuid, &p->p.protocol);\n  if (unread_data && unread_length <= HTTP_MAX_HEADER_LENGTH) {\n    fio_force_event(uuid, FIO_EVENT_ON_DATA);\n  }\n  return &p->p.protocol;\n}\n\n/** Manually destroys the HTTP1 protocol object. */\nvoid http1_destroy(fio_protocol_s *pr) {\n  http1pr_s *p = (http1pr_s *)pr;\n  http1_pr2handle(p).status = 0;\n  http_s_destroy(&http1_pr2handle(p), 0);\n  fio_free(p);\n  // FIO_LOG_DEBUG(\"Deallocated HTTP/1.1 protocol at. %p\", (void *)p);\n}\n\n/* *****************************************************************************\nProtocol Data\n***************************************************************************** */\n\n// clang-format off\n#define HTTP_SET_STATUS_STR(status, str) [((status)-100)] = { .data = (char*)(\"HTTP/1.1 \" #status \" \" str \"\\r\\n\"), .len = (sizeof(\"HTTP/1.1 \" #status \" \" str \"\\r\\n\") - 1) }\n// #undef HTTP_SET_STATUS_STR\n// clang-format on\n\nstatic fio_str_info_s http1pr_status2str(uintptr_t status) {\n  static fio_str_info_s status2str[] = {\n      HTTP_SET_STATUS_STR(100, \"Continue\"),\n      HTTP_SET_STATUS_STR(101, \"Switching Protocols\"),\n      HTTP_SET_STATUS_STR(102, \"Processing\"),\n      HTTP_SET_STATUS_STR(103, \"Early Hints\"),\n      HTTP_SET_STATUS_STR(200, \"OK\"),\n      HTTP_SET_STATUS_STR(201, \"Created\"),\n      HTTP_SET_STATUS_STR(202, \"Accepted\"),\n      HTTP_SET_STATUS_STR(203, \"Non-Authoritative Information\"),\n      HTTP_SET_STATUS_STR(204, \"No Content\"),\n      HTTP_SET_STATUS_STR(205, \"Reset Content\"),\n      HTTP_SET_STATUS_STR(206, \"Partial Content\"),\n      HTTP_SET_STATUS_STR(207, \"Multi-Status\"),\n      HTTP_SET_STATUS_STR(208, \"Already Reported\"),\n      HTTP_SET_STATUS_STR(226, \"IM Used\"),\n      HTTP_SET_STATUS_STR(300, \"Multiple Choices\"),\n      HTTP_SET_STATUS_STR(301, \"Moved Permanently\"),\n      HTTP_SET_STATUS_STR(302, \"Found\"),\n      HTTP_SET_STATUS_STR(303, \"See Other\"),\n      HTTP_SET_STATUS_STR(304, \"Not Modified\"),\n      HTTP_SET_STATUS_STR(305, \"Use Proxy\"),\n      HTTP_SET_STATUS_STR(306, \"(Unused), \"),\n      HTTP_SET_STATUS_STR(307, \"Temporary Redirect\"),\n      HTTP_SET_STATUS_STR(308, \"Permanent Redirect\"),\n      HTTP_SET_STATUS_STR(400, \"Bad Request\"),\n      HTTP_SET_STATUS_STR(403, \"Forbidden\"),\n      HTTP_SET_STATUS_STR(404, \"Not Found\"),\n      HTTP_SET_STATUS_STR(401, \"Unauthorized\"),\n      HTTP_SET_STATUS_STR(402, \"Payment Required\"),\n      HTTP_SET_STATUS_STR(405, \"Method Not Allowed\"),\n      HTTP_SET_STATUS_STR(406, \"Not Acceptable\"),\n      HTTP_SET_STATUS_STR(407, \"Proxy Authentication Required\"),\n      HTTP_SET_STATUS_STR(408, \"Request Timeout\"),\n      HTTP_SET_STATUS_STR(409, \"Conflict\"),\n      HTTP_SET_STATUS_STR(410, \"Gone\"),\n      HTTP_SET_STATUS_STR(411, \"Length Required\"),\n      HTTP_SET_STATUS_STR(412, \"Precondition Failed\"),\n      HTTP_SET_STATUS_STR(413, \"Payload Too Large\"),\n      HTTP_SET_STATUS_STR(414, \"URI Too Long\"),\n      HTTP_SET_STATUS_STR(415, \"Unsupported Media Type\"),\n      HTTP_SET_STATUS_STR(416, \"Range Not Satisfiable\"),\n      HTTP_SET_STATUS_STR(417, \"Expectation Failed\"),\n      HTTP_SET_STATUS_STR(421, \"Misdirected Request\"),\n      HTTP_SET_STATUS_STR(422, \"Unprocessable Entity\"),\n      HTTP_SET_STATUS_STR(423, \"Locked\"),\n      HTTP_SET_STATUS_STR(424, \"Failed Dependency\"),\n      HTTP_SET_STATUS_STR(425, \"Unassigned\"),\n      HTTP_SET_STATUS_STR(426, \"Upgrade Required\"),\n      HTTP_SET_STATUS_STR(427, \"Unassigned\"),\n      HTTP_SET_STATUS_STR(428, \"Precondition Required\"),\n      HTTP_SET_STATUS_STR(429, \"Too Many Requests\"),\n      HTTP_SET_STATUS_STR(430, \"Unassigned\"),\n      HTTP_SET_STATUS_STR(431, \"Request Header Fields Too Large\"),\n      HTTP_SET_STATUS_STR(500, \"Internal Server Error\"),\n      HTTP_SET_STATUS_STR(501, \"Not Implemented\"),\n      HTTP_SET_STATUS_STR(502, \"Bad Gateway\"),\n      HTTP_SET_STATUS_STR(503, \"Service Unavailable\"),\n      HTTP_SET_STATUS_STR(504, \"Gateway Timeout\"),\n      HTTP_SET_STATUS_STR(505, \"HTTP Version Not Supported\"),\n      HTTP_SET_STATUS_STR(506, \"Variant Also Negotiates\"),\n      HTTP_SET_STATUS_STR(507, \"Insufficient Storage\"),\n      HTTP_SET_STATUS_STR(508, \"Loop Detected\"),\n      HTTP_SET_STATUS_STR(509, \"Unassigned\"),\n      HTTP_SET_STATUS_STR(510, \"Not Extended\"),\n      HTTP_SET_STATUS_STR(511, \"Network Authentication Required\"),\n  };\n  fio_str_info_s ret = (fio_str_info_s){.len = 0, .data = NULL};\n  if (status >= 100 &&\n      (status - 100) < sizeof(status2str) / sizeof(status2str[0]))\n    ret = status2str[status - 100];\n  if (!ret.data) {\n    ret = status2str[400];\n  }\n  return ret;\n}\n#undef HTTP_SET_STATUS_STR\n", "#include <ruby.h>\n#define INCLUDE_MUSTACHE_IMPLEMENTATION 1\n#include \"mustache_parser.h\"\n\n#include \"iodine.h\"\n\n#define FIO_INCLUDE_STR\n#include <fio.h>\n\nstatic ID call_func_id;\nstatic ID to_s_func_id;\nstatic VALUE filename_id;\nstatic VALUE data_id;\nstatic VALUE template_id;\n/* *****************************************************************************\nC <=> Ruby Data allocation\n***************************************************************************** */\n\nstatic size_t iodine_mustache_data_size(const void *c_) {\n  return sizeof(mustache_s *);\n  (void)c_;\n}\n\nstatic void iodine_mustache_data_free(void *c_) {\n  mustache_free(((mustache_s **)c_)[0]);\n  free((void *)c_);\n  (void)c_;\n}\n\nstatic const rb_data_type_t iodine_mustache_data_type = {\n    .wrap_struct_name = \"IodineMustacheData\",\n    .function =\n        {\n            .dmark = NULL,\n            .dfree = iodine_mustache_data_free,\n            .dsize = iodine_mustache_data_size,\n        },\n    .data = NULL,\n    // .flags = RUBY_TYPED_FREE_IMMEDIATELY,\n};\n\n/* Iodine::PubSub::Engine.allocate */\nstatic VALUE iodine_mustache_data_alloc_c(VALUE self) {\n  void *m = malloc(sizeof(mustache_s *));\n  ((mustache_s **)m)[0] = NULL;\n  return TypedData_Wrap_Struct(self, &iodine_mustache_data_type, m);\n}\n\n/* *****************************************************************************\nParser Callbacks\n***************************************************************************** */\n\nstatic inline VALUE fiobj_mustache_find_obj_absolute(VALUE udata,\n                                                     const char *name,\n                                                     uint32_t name_len) {\n  VALUE tmp;\n  if (!RB_TYPE_P(udata, T_HASH)) {\n    if (name_len == 1 && name[0] == '.')\n      return udata;\n    /* search by method */\n    ID name_id = rb_intern2(name, name_len);\n    if (rb_respond_to(udata, name_id)) {\n      return IodineCaller.call(udata, name_id);\n    }\n    return Qnil;\n  }\n  /* search by Symbol */\n  ID name_id = rb_intern2(name, name_len);\n  VALUE key = ID2SYM(name_id);\n  tmp = rb_hash_lookup2(udata, key, Qundef);\n  if (tmp != Qundef)\n    return tmp;\n  /* search by String */\n  key = rb_sym2str(key);\n  tmp = rb_hash_lookup2(udata, key, Qundef);\n  rb_str_free(key);\n  if (tmp != Qundef)\n    return tmp;\n  /* search by method */\n  tmp = Qnil;\n  if (rb_respond_to(udata, name_id)) {\n    tmp = IodineCaller.call(udata, name_id);\n  }\n\n  return tmp;\n}\n\nstatic inline VALUE fiobj_mustache_find_obj_tree(mustache_section_s *section,\n                                                 const char *name,\n                                                 uint32_t name_len) {\n  do {\n    VALUE tmp = fiobj_mustache_find_obj_absolute((VALUE)section->udata2, name,\n                                                 name_len);\n    if (tmp != Qnil) {\n      return tmp;\n    }\n  } while ((section = mustache_section_parent(section)));\n  return Qnil;\n}\n\nstatic inline VALUE fiobj_mustache_find_obj(mustache_section_s *section,\n                                            const char *name,\n                                            uint32_t name_len) {\n  VALUE tmp = fiobj_mustache_find_obj_tree(section, name, name_len);\n  if (tmp != Qnil)\n    return tmp;\n  /* interpolate sections... */\n  uint32_t dot = 0;\n  while (dot < name_len && name[dot] != '.')\n    ++dot;\n  if (dot == name_len)\n    return Qnil;\n  tmp = fiobj_mustache_find_obj_tree(section, name, dot);\n  if (!tmp) {\n    return Qnil;\n  }\n  ++dot;\n  for (;;) {\n    VALUE obj =\n        fiobj_mustache_find_obj_absolute(tmp, name + dot, name_len - dot);\n    if (obj != Qnil)\n      return obj;\n    name += dot;\n    name_len -= dot;\n    dot = 0;\n    while (dot < name_len && name[dot] != '.')\n      ++dot;\n    if (dot == name_len) {\n      return Qnil;\n    }\n    tmp = fiobj_mustache_find_obj_absolute(tmp, name, dot);\n    if (tmp == Qnil)\n      return Qnil;\n    ++dot;\n  }\n}\n/**\n * Called when an argument name was detected in the current section.\n *\n * A conforming implementation will search for the named argument both in the\n * existing section and all of it's parents (walking backwards towards the root)\n * until a value is detected.\n *\n * A missing value should be treated the same as an empty string.\n *\n * A conforming implementation will output the named argument's value (either\n * HTML escaped or not, depending on the `escape` flag) as a string.\n */\nstatic int mustache_on_arg(mustache_section_s *section, const char *name,\n                           uint32_t name_len, unsigned char escape) {\n  VALUE o = fiobj_mustache_find_obj(section, name, name_len);\n  switch (o) {\n  case Qnil:\n  case Qfalse:\n    return 0;\n  case Qtrue:\n    fio_str_write(section->udata1, \"true\", 4);\n    break;\n  }\n  if (!RB_TYPE_P(o, T_STRING)) {\n    if (rb_respond_to(o, call_func_id))\n      o = IodineCaller.call(o, call_func_id);\n    if (!RB_TYPE_P(o, T_STRING))\n      o = IodineCaller.call(o, to_s_func_id);\n  }\n  if (!RB_TYPE_P(o, T_STRING) || !RSTRING_LEN(o))\n    return 0;\n  return mustache_write_text(section, RSTRING_PTR(o), RSTRING_LEN(o), escape);\n}\n\n/**\n * Called when simple template text (string) is detected.\n *\n * A conforming implementation will output data as a string (no escaping).\n */\nstatic int mustache_on_text(mustache_section_s *section, const char *data,\n                            uint32_t data_len) {\n  fio_str_write(section->udata1, data, data_len);\n  return 0;\n}\n\n/**\n * Called for nested sections, must return the number of objects in the new\n * subsection (depending on the argument's name).\n *\n * Arrays should return the number of objects in the array.\n *\n * `true` values should return 1.\n *\n * `false` values should return 0.\n *\n * A return value of -1 will stop processing with an error.\n *\n * Please note, this will handle both normal and inverted sections.\n */\nstatic int32_t mustache_on_section_test(mustache_section_s *section,\n                                        const char *name, uint32_t name_len,\n                                        uint8_t callable) {\n  VALUE o = fiobj_mustache_find_obj(section, name, name_len);\n  if (o == Qnil || o == Qfalse) {\n    return 0;\n  }\n  if (RB_TYPE_P(o, T_ARRAY)) {\n    return RARRAY_LEN(o);\n  }\n  if (callable && rb_respond_to(o, call_func_id)) {\n    size_t len;\n    const char *txt = mustache_section_text(section, &len);\n    VALUE str = Qnil;\n    if (txt && len) {\n      str = rb_str_new(txt, len);\n    }\n    o = IodineCaller.call2(o, call_func_id, 1, &str);\n    if (!RB_TYPE_P(o, T_STRING))\n      o = rb_funcall2(o, to_s_func_id, 0, NULL);\n    if (RB_TYPE_P(o, T_STRING) && RSTRING_LEN(o))\n      mustache_write_text(section, RSTRING_PTR(o), RSTRING_LEN(o), 0);\n    return 0;\n  }\n  return 1;\n}\n\n/**\n * Called when entering a nested section.\n *\n * `index` is a zero based index indicating the number of repetitions that\n * occurred so far (same as the array index for arrays).\n *\n * A return value of -1 will stop processing with an error.\n *\n * Note: this is a good time to update the subsection's `udata` with the value\n * of the array index. The `udata` will always contain the value or the parent's\n * `udata`.\n */\nstatic int mustache_on_section_start(mustache_section_s *section,\n                                     char const *name, uint32_t name_len,\n                                     uint32_t index) {\n  VALUE o = fiobj_mustache_find_obj(section, name, name_len);\n  if (RB_TYPE_P(o, T_ARRAY))\n    section->udata2 = (void *)rb_ary_entry(o, index);\n  else if (RB_TYPE_P(o, T_HASH))\n    section->udata2 = (void *)o;\n  return 0;\n}\n\n/**\n * Called for cleanup in case of error.\n */\nstatic void mustache_on_formatting_error(void *udata1, void *udata2) {\n  (void)udata1;\n  (void)udata2;\n}\n\n/* *****************************************************************************\nLoading the template\n***************************************************************************** */\n\n/**\nLoads the mustache template found in `:filename`. If `:template` is provided it\nwill be used instead of reading the file's content.\n\n    Iodine::Mustache.new(filename, template = nil)\n\nWhen template data is provided, filename (if any) will only be used for partial\ntemplate path resolution and the template data will be used for the template's\ncontent. This allows, for example, for front matter to be extracted before\nparsing the template.\n\nOnce a template was loaded, it could be rendered using {render}.\n\nAccepts named arguments as well:\n\n    Iodine::Mustache.new(filename: \"foo.mustache\", template: \"{{ bar }}\")\n\n*/\nstatic VALUE iodine_mustache_new(int argc, VALUE *argv, VALUE self) {\n  VALUE filename = Qnil, template = Qnil;\n  if (argc == 1 && RB_TYPE_P(argv[0], T_HASH)) {\n    /* named arguments */\n    filename = rb_hash_aref(argv[0], filename_id);\n    template = rb_hash_aref(argv[0], template_id);\n  } else {\n    /* regular arguments */\n    if (argc == 0 || argc > 2)\n      rb_raise(rb_eArgError, \"expecting 1..2 arguments or named arguments.\");\n    filename = argv[0];\n    if (argc > 1) {\n      template = argv[1];\n    }\n  }\n  if (filename == Qnil && template == Qnil)\n    rb_raise(rb_eArgError, \"need either template contents or file name.\");\n\n  if (template != Qnil)\n    Check_Type(template, T_STRING);\n  if (filename != Qnil)\n    Check_Type(filename, T_STRING);\n\n  mustache_s **m = NULL;\n  TypedData_Get_Struct(self, mustache_s *, &iodine_mustache_data_type, m);\n  if (!m) {\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache allocation error.\");\n  }\n\n  mustache_error_en err;\n  *m = mustache_load(.filename =\n                         (filename == Qnil ? NULL : RSTRING_PTR(filename)),\n                     .filename_len =\n                         (filename == Qnil ? 0 : RSTRING_LEN(filename)),\n                     .data = (template == Qnil ? NULL : RSTRING_PTR(template)),\n                     .data_len = (template == Qnil ? 0 : RSTRING_LEN(template)),\n                     .err = &err);\n\n  if (!*m)\n    goto error;\n  return self;\nerror:\n  switch (err) {\n  case MUSTACHE_OK:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache template ok, unknown error.\");\n    break;\n  case MUSTACHE_ERR_TOO_DEEP:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache element nesting too deep.\");\n    break;\n  case MUSTACHE_ERR_CLOSURE_MISMATCH:\n    rb_raise(rb_eRuntimeError,\n             \"Iodine::Mustache template error, closure mismatch.\");\n    break;\n  case MUSTACHE_ERR_FILE_NOT_FOUND:\n    rb_raise(rb_eLoadError, \"Iodine::Mustache template not found.\");\n    break;\n  case MUSTACHE_ERR_FILE_TOO_BIG:\n    rb_raise(rb_eLoadError, \"Iodine::Mustache template too big.\");\n    break;\n  case MUSTACHE_ERR_FILE_NAME_TOO_LONG:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache template name too long.\");\n    break;\n  case MUSTACHE_ERR_EMPTY_TEMPLATE:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache template is empty.\");\n    break;\n  case MUSTACHE_ERR_UNKNOWN:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache unknown error.\");\n    break;\n  case MUSTACHE_ERR_USER_ERROR:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache internal error.\");\n    break;\n  case MUSTACHE_ERR_FILE_NAME_TOO_SHORT:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache template file name too long.\");\n\n    break;\n  case MUSTACHE_ERR_DELIMITER_TOO_LONG:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache new delimiter is too long.\");\n\n    break;\n  case MUSTACHE_ERR_NAME_TOO_LONG:\n    rb_raise(rb_eRuntimeError,\n             \"Iodine::Mustache section name in template is too long.\");\n  default:\n    break;\n  }\n  return self;\n}\n\n/* *****************************************************************************\nRendering\n***************************************************************************** */\n\n/**\nRenders the mustache template using the data provided in the `data` argument.\n\nReturns a String with the rendered template.\n\nRaises an exception on error.\n\nNOTE:\n\nAs one might notice, no binding is provided. Instead, a `data` Hash is assumed.\nIodine will search the Hash for any data while protecting against code\nexecution.\n*/\nstatic VALUE iodine_mustache_render(VALUE self, VALUE data) {\n  fio_str_s str = FIO_STR_INIT;\n  mustache_s **m = NULL;\n  TypedData_Get_Struct(self, mustache_s *, &iodine_mustache_data_type, m);\n  if (!m) {\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache allocation error.\");\n  }\n  if (mustache_build(*m, .udata1 = &str, .udata2 = (void *)data))\n    goto error;\n  fio_str_info_s i = fio_str_info(&str);\n  VALUE ret = rb_str_new(i.data, i.len);\n  fio_str_free(&str);\n  return ret;\n\nerror:\n  fio_str_free(&str);\n  rb_raise(rb_eRuntimeError, \"Couldn't build template frome data.\");\n}\n\n/**\nRenders the mustache template found in `filename`, using the data provided in\nthe `data` argument. If `template` is provided it will be used instead of\nreading the file's content.\n\n    Iodine::Mustache.render(filename, data, template = nil)\n\nReturns a String with the rendered template.\n\nRaises an exception on error.\n\n    template = \"<h1>{{title}}</h1>\"\n    filename = \"templates/index\"\n    data = {title: \"Home\"}\n    result = Iodine::Mustache.render(filename, data)\n\n    # filename will be used to resolve the path to any partials:\n    result = Iodine::Mustache.render(filename, data, template)\n\n    # OR, if we don't need partial template path resolution\n    result = Iodine::Mustache.render(template: template, data: data)\n\nNOTE 1:\n\nThis function doesn't cache the template data.\n\nThe more complext the template the higher the cost of the template parsing\nstage.\n\nConsider creating a persistent template object using a new object and using the\ninstance {#render} method.\n\nNOTE 2:\n\nAs one might notice, no binding is provided. Instead, a `data` Hash is assumed.\nIodine will search the Hash for any data while protecting against code\nexecution.\n*/\nstatic VALUE iodine_mustache_render_klass(int argc, VALUE *argv, VALUE self) {\n  VALUE filename = Qnil, data = Qnil, template = Qnil;\n  if (argc == 1) {\n    /* named arguments */\n    Check_Type(argv[0], T_HASH);\n    filename = rb_hash_aref(argv[0], filename_id);\n    data = rb_hash_aref(argv[0], data_id);\n    template = rb_hash_aref(argv[0], template_id);\n  } else {\n    /* regular arguments */\n    if (argc < 2 || argc > 3)\n      rb_raise(rb_eArgError, \"expecting 2..3 arguments or named arguments.\");\n    filename = argv[0];\n    data = argv[1];\n    if (argc > 2) {\n      template = argv[2];\n    }\n  }\n  if (filename == Qnil && template == Qnil)\n    rb_raise(rb_eArgError, \"need either template contents or file name.\");\n\n  if (template != Qnil)\n    Check_Type(template, T_STRING);\n  if (filename != Qnil)\n    Check_Type(filename, T_STRING);\n\n  fio_str_s str = FIO_STR_INIT;\n\n  mustache_s *m = NULL;\n  mustache_error_en err;\n  m = mustache_load(.filename =\n                        (filename == Qnil ? NULL : RSTRING_PTR(filename)),\n                    .filename_len =\n                        (filename == Qnil ? 0 : RSTRING_LEN(filename)),\n                    .data = (template == Qnil ? NULL : RSTRING_PTR(template)),\n                    .data_len = (template == Qnil ? 0 : RSTRING_LEN(template)),\n                    .err = &err);\n  if (!m)\n    goto error;\n  int e = mustache_build(m, .udata1 = &str, .udata2 = (void *)data);\n  mustache_free(m);\n  if (e)\n    goto render_error;\n  fio_str_info_s i = fio_str_info(&str);\n  VALUE ret = rb_str_new(i.data, i.len);\n  fio_str_free(&str);\n  return ret;\n\nerror:\n  switch (err) {\n  case MUSTACHE_OK:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache template ok, unknown error.\");\n    break;\n  case MUSTACHE_ERR_TOO_DEEP:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache element nesting too deep.\");\n    break;\n  case MUSTACHE_ERR_CLOSURE_MISMATCH:\n    rb_raise(rb_eRuntimeError,\n             \"Iodine::Mustache template error, closure mismatch.\");\n    break;\n  case MUSTACHE_ERR_FILE_NOT_FOUND:\n    rb_raise(rb_eLoadError, \"Iodine::Mustache template not found.\");\n    break;\n  case MUSTACHE_ERR_FILE_TOO_BIG:\n    rb_raise(rb_eLoadError, \"Iodine::Mustache template too big.\");\n    break;\n  case MUSTACHE_ERR_FILE_NAME_TOO_LONG:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache template name too long.\");\n    break;\n  case MUSTACHE_ERR_EMPTY_TEMPLATE:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache template is empty.\");\n    break;\n  case MUSTACHE_ERR_UNKNOWN:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache unknown error.\");\n    break;\n  case MUSTACHE_ERR_USER_ERROR:\n    rb_raise(rb_eRuntimeError,\n             \"Iodine::Mustache internal error or unexpected data structure.\");\n    break;\n  case MUSTACHE_ERR_FILE_NAME_TOO_SHORT:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache template file name too long.\");\n\n    break;\n  case MUSTACHE_ERR_DELIMITER_TOO_LONG:\n    rb_raise(rb_eRuntimeError, \"Iodine::Mustache new delimiter is too long.\");\n\n    break;\n  case MUSTACHE_ERR_NAME_TOO_LONG:\n    rb_raise(rb_eRuntimeError,\n             \"Iodine::Mustache section name in template is too long.\");\n\n    break;\n  default:\n    break;\n  }\n  return Qnil;\n\nrender_error:\n  fio_str_free(&str);\n  rb_raise(rb_eRuntimeError, \"Couldn't build template frome data.\");\n}\n\n/* *****************************************************************************\nInitialize Iodine::Mustache\n***************************************************************************** */\n\nvoid iodine_init_mustache(void) {\n  call_func_id = rb_intern2(\"call\", 4);\n  to_s_func_id = rb_intern2(\"to_s\", 4);\n  filename_id = rb_id2sym(rb_intern2(\"filename\", 8));\n  data_id = rb_id2sym(rb_intern2(\"data\", 4));\n  template_id = rb_id2sym(rb_intern2(\"template\", 8));\n  rb_global_variable(&filename_id);\n  rb_global_variable(&data_id);\n  rb_global_variable(&template_id);\n  VALUE tmp = rb_define_class_under(IodineModule, \"Mustache\", rb_cData);\n  rb_define_alloc_func(tmp, iodine_mustache_data_alloc_c);\n  rb_define_method(tmp, \"initialize\", iodine_mustache_new, -1);\n  rb_define_method(tmp, \"render\", iodine_mustache_render, 1);\n  rb_define_singleton_method(tmp, \"render\", iodine_mustache_render_klass, -1);\n  // rb_define_module_function(tmp, \"render\", iodine_mustache_render_klass, 2);\n}\n", "# coding: utf-8\nlib = File.expand_path('../lib', __FILE__)\n$LOAD_PATH.unshift(lib) unless $LOAD_PATH.include?(lib)\nrequire 'iodine/version'\n\nGem::Specification.new do |spec|\n  spec.name          = 'iodine'\n  spec.version       = Iodine::VERSION\n  spec.authors       = ['Boaz Segev']\n  spec.email         = ['bo@plezi.io']\n\n  spec.summary       = 'iodine - a fast HTTP / Websocket Server with Pub/Sub support, optimized for Ruby MRI on Linux / BSD'\n  spec.description   = 'A fast HTTP / Websocket Server with built-in Pub/Sub support (with or without Redis), static file support and many other features, optimized for Ruby MRI on Linux / BSD / macOS'\n  spec.homepage      = 'https://github.com/boazsegev/iodine'\n  spec.license       = 'MIT'\n\n  # Prevent pushing this gem to RubyGems.org by setting 'allowed_push_host', or\n  # delete this section to allow pushing this gem to any host.\n  if spec.respond_to?(:metadata)\n    spec.metadata['allowed_push_host'] = 'https://rubygems.org'\n  else\n    raise 'RubyGems 2.0 or newer is required to protect against public gem pushes.'\n  end\n\n  spec.files         = `git ls-files -z`.split(\"\\x0\").reject { |f| f.match(%r{^(test|spec|features)/}) }\n  spec.bindir        = 'exe'\n  spec.executables   = spec.files.grep(%r{^exe/}) { |f| File.basename(f) }\n  spec.require_paths = %w(lib ext)\n\n  spec.extensions = %w(ext/iodine/extconf.rb)\n\n  spec.required_ruby_version = '>= 2.2.2' # Because earlier versions had been discontinued\n\n  spec.requirements << 'A Unix based system: Linux / macOS / BSD.'\n  spec.requirements << 'An updated C compiler.'\n  spec.requirements << 'Ruby >= 2.2.2 required for Rack 2.'\n  spec.requirements << 'Ruby >= 2.5.0 recommended.'\n  spec.requirements << 'TLS requires OpenSSL >= 1.1.0'\n\n  # spec.add_development_dependency 'bundler', '>= 1.10', '< 2.0'\n  spec.add_development_dependency 'rake', '~> 12.0', '< 13.0'\n  spec.add_development_dependency 'minitest', '>=5', '< 6.0'\n  spec.add_development_dependency 'rake-compiler', '>= 1', '< 2.0'\n\n  spec.post_install_message = \"Thank you for installing Iodine #{Iodine::VERSION}.\\n\" +\n                              \"Remember: if iodine supports your business, it's is only fair to give value back (code contributions / donations).\"\nend\n", "module Iodine\n  VERSION = '0.7.34'.freeze\nend\n"], "filenames": ["CHANGELOG.md", "ext/iodine/fio.c", "ext/iodine/fio.h", "ext/iodine/fio_cli.c", "ext/iodine/fio_tls_missing.c", "ext/iodine/fio_tls_openssl.c", "ext/iodine/fiobj4fio.h", "ext/iodine/fiobj_numbers.h", "ext/iodine/http.c", "ext/iodine/http.h", "ext/iodine/http1.c", "ext/iodine/iodine_mustache.c", "iodine.gemspec", "lib/iodine/version.rb"], "buggy_code_start_loc": [7, 1181, 112, 275, 22, 1007, 17, 85, 358, 373, 557, 75, 45, 2], "buggy_code_end_loc": [7, 6502, 5894, 288, 630, 1007, 18, 89, 410, 374, 780, 299, 46, 3], "fixing_code_start_loc": [8, 1181, 112, 275, 22, 1008, 17, 85, 359, 373, 557, 76, 45, 2], "fixing_code_end_loc": [12, 6507, 5894, 288, 632, 1009, 18, 91, 423, 374, 778, 297, 47, 3], "type": "CWE-22", "message": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n", "other": {"cve": {"id": "CVE-2024-22050", "sourceIdentifier": "disclosure@vulncheck.com", "published": "2024-01-04T21:15:10.100", "lastModified": "2024-01-10T15:10:36.697", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Path traversal in the static file service in Iodine less than 0.7.33 allows an unauthenticated, remote attacker to read files outside the public folder via malicious URLs.\n\n"}, {"lang": "es", "value": "Path traversal en el servicio de archivos est\u00e1ticos en Iodine inferior a 0.7.33 permite a un atacante remoto no autenticado leer archivos fuera de la carpeta p\u00fablica a trav\u00e9s de URL maliciosas."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "disclosure@vulncheck.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:boazsegev:iodine:*:*:*:*:*:ruby:*:*", "versionEndIncluding": "0.7.33", "matchCriteriaId": "259C2480-6121-490C-8B3A-911E14C61AC7"}]}]}], "references": [{"url": "https://github.com/advisories/GHSA-85rf-xh54-whp3", "source": "disclosure@vulncheck.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889", "source": "disclosure@vulncheck.com", "tags": ["Patch"]}, {"url": "https://github.com/boazsegev/iodine/security/advisories/GHSA-85rf-xh54-whp3", "source": "disclosure@vulncheck.com", "tags": ["Vendor Advisory"]}, {"url": "https://vulncheck.com/advisories/vc-advisory-GHSA-85rf-xh54-whp3", "source": "disclosure@vulncheck.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/boazsegev/iodine/commit/5558233fb7defda706b4f9c87c17759705949889"}}