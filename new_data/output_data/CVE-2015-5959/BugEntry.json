{"buggy_code": ["<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * For the full copyright and license information, please view the COPYING\n * file that was distributed with this source code. You can also view the\n * COPYING file online at http://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  (c) the authors\n * @author     Michael Kaufmann <mkaufmann@nutime.de>\n * @author     Froxlor team <team@froxlor.org> (2010-)\n * @license    GPLv2 http://files.froxlor.org/misc/COPYING.txt\n * @package    Classes\n *\n * @since      0.9.31\n *\n */\n\n/**\n * Class Database\n *\n * Wrapper-class for PHP-PDO\n *\n * @copyright  (c) the authors\n * @author     Michael Kaufmann <mkaufmann@nutime.de>\n * @author     Froxlor team <team@froxlor.org> (2010-)\n * @license    GPLv2 http://files.froxlor.org/misc/COPYING.txt\n * @package    Classes\n */\nclass Database {\n\n\t/**\n\t * current database link\n\t *\n\t * @var object\n\t */\n\tprivate static $_link = null ;\n\n\t/**\n\t * indicator whether to use root-connection or not\n\t */\n\tprivate static $_needroot = false;\n\n\t/**\n\t * indicator which database-server we're on (not really used)\n\t */\n\tprivate static $_dbserver = 0;\n\n\t/**\n\t * used database-name\n\t */\n\tprivate static $_dbname = null;\n\n\t/**\n\t * sql-access data\n\t */\n\tprivate static $_needsqldata = false;\n\tprivate static $_sqldata = null;\n\n\t/**\n\t * Wrapper for PDOStatement::execute so we can catch the PDOException\n\t * and display the error nicely on the panel\n\t *\n\t * @param PDOStatement $stmt\n\t * @param array $params (optional)\n\t * @param bool $showerror suppress errordisplay (default true)\n\t */\n\tpublic static function pexecute(&$stmt, $params = null, $showerror = true) {\n\t\ttry {\n\t\t\t$stmt->execute($params);\n\t\t} catch (PDOException $e) {\n\t\t\tself::_showerror($e, $showerror);\n\t\t}\n\t}\n\n\t/**\n\t * Wrapper for PDOStatement::execute so we can catch the PDOException\n\t * and display the error nicely on the panel - also fetches the\n\t * result from the statement and returns the resulting array\n\t *\n\t * @param PDOStatement $stmt\n\t * @param array $params (optional)\n\t * @param bool $showerror suppress errordisplay (default true)\n\t *\n\t * @return array\n\t */\n\tpublic static function pexecute_first(&$stmt, $params = null, $showerror = true) {\n\t\tself::pexecute($stmt, $params, $showerror);\n\t\treturn $stmt->fetch(PDO::FETCH_ASSOC);\n\t}\n\n\t/**\n\t * returns the number of found rows of the last select query\n\t *\n\t * @return int\n\t */\n\tpublic static function num_rows() {\n\t\treturn Database::query(\"SELECT FOUND_ROWS()\")->fetchColumn();\n\t}\n\n\t/**\n\t * returns the database-name which is used\n\t *\n\t * @return string\n\t */\n\tpublic static function getDbName() {\n\t\treturn self::$_dbname;\n\t}\n\n\t/**\n\t * enabled the usage of a root-connection to the database\n\t * Note: must be called *before* any prepare/query/etc.\n\t * and should be called again with 'false'-parameter to resume\n\t * the 'normal' database-connection\n\t *\n\t * @param bool $needroot\n\t * @param int $dbserver optional\n\t */\n\tpublic static function needRoot($needroot = false, $dbserver = 0) {\n\t\t// force re-connecting to the db with corresponding user\n\t\t// and set the $dbserver (mostly to 0 = default)\n\t\tself::_setServer($dbserver);\n\t\tself::$_needroot = $needroot;\n\t}\n\n\t/**\n\t * enable the temporary access to sql-access data\n\t * note: if you want root-sqldata you need to\n\t * call needRoot(true) first. Also, this will\n\t * only give you the data ONCE as it disable itself\n\t * after the first access to the data\n\t *\n\t */\n\tpublic static function needSqlData() {\n\t\tself::$_needsqldata = true;\n\t\tself::$_sqldata = array();\n\t\tself::$_link = null;\n\t\t// we need a connection here because\n\t\t// if getSqlData() is called RIGHT after\n\t\t// this function and no \"real\" PDO\n\t\t// function was called, getDB() wasn't\n\t\t// involved and no data collected\n\t\tself::getDB();\n\t}\n\n\t/**\n\t * returns the sql-access data as array using indeces\n\t * 'user', 'passwd' and 'host'. Returns false if not enabled\n\t *\n\t * @return array|bool\n\t */\n\tpublic static function getSqlData() {\n\t\t$return = false;\n\t\tif (self::$_sqldata !== null\n\t\t\t\t&& is_array(self::$_sqldata)\n\t\t\t\t&& isset(self::$_sqldata['user'])\n\t\t) {\n\t\t\t$return = self::$_sqldata;\n\t\t\t// automatically disable sql-data\n\t\t\tself::$_sqldata = null;\n\t\t\tself::$_needsqldata = false;\n\t\t}\n\t\treturn $return;\n\t}\n\n\t/**\n\t * let's us interact with the PDO-Object by using static\n\t * call like \"Database::function()\"\n\t *\n\t * @param string $name\n\t * @param mixed $args\n\t *\n\t * @return mixed\n\t */\n\tpublic static function __callStatic($name, $args) {\n\t\t$callback = array(self::getDB(), $name);\n\t\t$result = null;\n\t\ttry {\n\t\t\t$result = call_user_func_array($callback, $args );\n\t\t} catch (PDOException $e) {\n\t\t\tself::_showerror($e);\n\t\t}\n\t\treturn $result;\n\t}\n\n\t/**\n\t * set the database-server (relevant for root-connection)\n\t *\n\t * @param int $dbserver\n\t */\n\tprivate static function _setServer($dbserver = 0) {\n\t\tself::$_dbserver = $dbserver;\n\t\tself::$_link = null;\n\t}\n\n\t/**\n\t * function that will be called on every static call\n\t * which connects to the database if necessary\n\t *\n\t * @param bool $root\n\t *\n\t * @return object\n\t */\n\tprivate static function getDB() {\n\n\t\tif (!extension_loaded('pdo') || in_array(\"mysql\", PDO::getAvailableDrivers()) == false) {\n\t\t\tself::_showerror(new Exception(\"The php PDO extension or PDO-MySQL driver is not available\"));\n\t\t}\n\n\t\t// do we got a connection already?\n\t\tif (self::$_link) {\n\t\t\t// return it\n\t\t\treturn self::$_link;\n\t\t}\n\n\t\t// include userdata.inc.php\n\t\trequire FROXLOR_INSTALL_DIR.\"/lib/userdata.inc.php\";\n\n\t\t// le format\n\t\tif (self::$_needroot == true\n\t\t\t\t&& isset($sql['root_user'])\n\t\t\t\t&& isset($sql['root_password'])\n\t\t\t\t&& (!isset($sql_root) || !is_array($sql_root))\n\t\t) {\n\t\t\t$sql_root = array(0 => array('caption' => 'Default', 'host' => $sql['host'], 'socket' => (isset($sql['socket']) ? $sql['socket'] : null), 'user' => $sql['root_user'], 'password' => $sql['root_password']));\n\t\t\tunset($sql['root_user']);\n\t\t\tunset($sql['root_password']);\n\t\t}\n\n\t\t// either root or unprivileged user\n\t\tif (self::$_needroot) {\n\t\t\t$caption = $sql_root[self::$_dbserver]['caption'];\n\t\t\t$user = $sql_root[self::$_dbserver]['user'];\n\t\t\t$password = $sql_root[self::$_dbserver]['password'];\n\t\t\t$host = $sql_root[self::$_dbserver]['host'];\n\t\t\t$socket = isset($sql_root[self::$_dbserver]['socket']) ? $sql_root[self::$_dbserver]['socket'] : null;\n\t\t\t$port = isset($sql_root[self::$_dbserver]['port']) ? $sql_root[self::$_dbserver]['port'] : '3306';\n\t\t} else {\n\t\t\t$caption = 'localhost';\n\t\t\t$user = $sql[\"user\"];\n\t\t\t$password = $sql[\"password\"];\n\t\t\t$host = $sql[\"host\"];\n\t\t\t$socket = isset($sql['socket']) ? $sql['socket'] : null;\n\t\t\t$port = isset($sql['port']) ? $sql['port'] : '3306';\n\t\t}\n\n\t\t// save sql-access-data if needed\n\t\tif (self::$_needsqldata) {\n\t\t\tself::$_sqldata = array(\n\t\t\t\t\t'user' => $user,\n\t\t\t\t\t'passwd' => $password,\n\t\t\t\t\t'host' => $host,\n\t\t\t\t\t'port' => $port,\n\t\t\t\t\t'socket' => $socket,\n\t\t\t\t\t'db' => $sql[\"db\"],\n\t\t\t\t\t'caption' => $caption\n\t\t\t);\n\t\t}\n\n\t\t// build up connection string\n\t\t$driver = 'mysql';\n\t\t$dsn = $driver.\":\";\n\t\t$options = array(PDO::MYSQL_ATTR_INIT_COMMAND => 'set names utf8');\n\t\t$attributes = array('ATTR_ERRMODE' => 'ERRMODE_EXCEPTION');\n\n\t\t$dbconf[\"dsn\"] = array(\n\t\t\t\t'dbname' => $sql[\"db\"],\n\t\t\t\t'charset' => 'utf8'\n\t\t);\n\n\t\tif ($socket != null) {\n\t\t\t$dbconf[\"dsn\"]['unix_socket'] = makeCorrectFile($socket);\n\t\t} else {\n\t\t\t$dbconf[\"dsn\"]['host'] = $host;\n\t\t\t$dbconf[\"dsn\"]['port'] = $port;\n\t\t}\n\n\t\tself::$_dbname = $sql[\"db\"];\n\n\t\t// add options to dsn-string\n\t\tforeach ($dbconf[\"dsn\"] as $k => $v) {\n\t\t\t$dsn .= $k.\"=\".$v.\";\";\n\t\t}\n\n\t\t// clean up\n\t\tunset($dbconf);\n\n\t\t// try to connect\n\t\ttry {\n\t\t\tself::$_link = new PDO($dsn, $user, $password, $options);\n\t\t} catch (PDOException $e) {\n\t\t\tself::_showerror($e);\n\t\t}\n\n\t\t// set attributes\n\t\tforeach ($attributes as $k => $v) {\n\t\t\tself::$_link->setAttribute(constant(\"PDO::\".$k), constant(\"PDO::\".$v));\n\t\t}\n\n\t\t// return PDO instance\n\t\treturn self::$_link;\n\t}\n\n\t/**\n\t * display a nice error if it occurs and log everything\n\t *\n\t * @param PDOException $error\n\t * @param bool $showerror if set to false, the error will be logged but we go on\n\t */\n\tprivate static function _showerror($error, $showerror = true) {\n\t\tglobal $userinfo, $theme, $linker;\n\n\t\t/**\n\t\t * log to a file, so we can actually ask people for the error\n\t\t * (no one seems to find the stuff in the syslog)\n\t\t */\n\t\t$sl_dir = makeCorrectDir(FROXLOR_INSTALL_DIR.\"/logs/\");\n\t\tif (!file_exists($sl_dir)) {\n\t\t\t@mkdir($sl_dir, 0755);\n\t\t}\n\t\t$sl_file = makeCorrectFile($sl_dir.\"/sql-error.log\");\n\t\t$sqllog = @fopen($sl_file, 'a');\n\t\t@fwrite($sqllog, date('d.m.Y H:i', time()).\" --- \".str_replace(\"\\n\", \" \", $error->getMessage()).\"\\n\");\n\t\t@fwrite($sqllog, date('d.m.Y H:i', time()).\" --- DEBUG: \\n\".$error->getTraceAsString().\"\\n\");\n\t\t@fclose($sqllog);\n\n\t\t/**\n\t\t * log error for reporting\n\t\t*/\n\t\t$errid = substr(md5(microtime()), 5, 5);\n\t\t$err_file = makeCorrectFile($sl_dir.\"/\".$errid.\"_sql-error.log\");\n\t\t$errlog = @fopen($err_file, 'w');\n\t\t@fwrite($errlog, \"|CODE \".$error->getCode().\"\\n\");\n\t\t@fwrite($errlog, \"|MSG \".$error->getMessage().\"\\n\");\n\t\t@fwrite($errlog, \"|FILE \".$error->getFile().\"\\n\");\n\t\t@fwrite($errlog, \"|LINE \".$error->getLine().\"\\n\");\n\t\t@fwrite($errlog, \"|TRACE\\n\".$error->getTraceAsString().\"\\n\");\n\t\t@fclose($errlog);\n\n\t\tif ($showerror) {\n\n\t\t\t// include userdata.inc.php\n\t\t\trequire FROXLOR_INSTALL_DIR.\"/lib/userdata.inc.php\";\n\n\t\t\t// fallback\n\t\t\t$theme = 'Sparkle';\n\n\t\t\t// le format\n\t\t\tif (isset($sql['root_user'])\n\t\t\t\t&& isset($sql['root_password'])\n\t\t\t\t&& (!isset($sql_root) || !is_array($sql_root))\n\t\t\t) {\n\t\t\t\t$sql_root = array(0 => array('caption' => 'Default', 'host' => $sql['host'], 'socket' => (isset($sql['socket']) ? $sql['socket'] : null), 'user' => $sql['root_user'], 'password' => $sql['root_password']));\n\t\t\t}\n\n\t\t\t// hide username/password in messages\n\t\t\t$error_message = $error->getMessage();\n\t\t\t$error_trace = $error->getTraceAsString();\n\t\t\t// error-message\n\t\t\t$error_message = str_replace($sql['password'], 'DB_UNPRIV_PWD', $error_message);\n\t\t\t$error_message = str_replace($sql_root[0]['password'], 'DB_ROOT_PWD', $error_message);\n\t\t\t// error-trace\n\t\t\t$error_trace = str_replace($sql['password'], 'DB_UNPRIV_PWD', $error_trace);\n\t\t\t$error_trace = str_replace($sql_root[0]['password'], 'DB_ROOT_PWD', $error_trace);\n\n\t\t\tif ($error->getCode() == 2003) {\n\t\t\t    $error_message = \"Unable to connect to database. Either the mysql-server is not running or your user/password is wrong.\";\n\t\t\t    $error_trace = \"\";\n\t\t\t}\n\n\t\t\t// clean up sensitive data\n\t\t\tunset($sql);\n\t\t\tunset($sql_root);\n\n\t\t\tif ((isset($theme) && $theme != '')\n\t\t\t\t\t&& !isset($_SERVER['SHELL']) || (isset($_SERVER['SHELL']) && $_SERVER['SHELL'] == '')\n\t\t\t) {\n\t\t\t\t// if we're not on the shell, output a nice error\n\t\t\t\t$_errtpl = dirname($sl_dir).'/templates/'.$theme.'/misc/dberrornice.tpl';\n\t\t\t\tif (file_exists($_errtpl)) {\n\t\t\t\t\t$err_hint = file_get_contents($_errtpl);\n\t\t\t\t\t// replace values\n\t\t\t\t\t$err_hint = str_replace(\"<TEXT>\", $error_message, $err_hint);\n\t\t\t\t\t$err_hint = str_replace(\"<DEBUG>\", $error_trace, $err_hint);\n\t\t\t\t\t$err_hint = str_replace(\"<CURRENT_YEAR>\", date('Y', time()), $err_hint);\n\n\t\t\t\t\t$err_report_html = '';\n\t\t\t\t\tif (is_array($userinfo) && (\n\t\t\t\t\t\t\t($userinfo['adminsession'] == '1' && Settings::Get('system.allow_error_report_admin') == '1')\n\t\t\t\t\t\t\t|| ($userinfo['adminsession'] == '0' && Settings::Get('system.allow_error_report_customer') == '1'))\n\t\t\t\t\t) {\n\t\t\t\t\t\t$err_report_html = '<a href=\"<LINK>\" title=\"Click here to report error\">Report error</a>';\n\t\t\t\t\t\t$err_report_html = str_replace(\"<LINK>\", $linker->getLink(array('section' => 'index', 'page' => 'send_error_report', 'errorid' => $errid)), $err_report_html);\n\t\t\t\t\t}\n\t\t\t\t\t$err_hint = str_replace(\"<REPORT>\", $err_report_html, $err_hint);\n\n\t\t\t\t\t// show\n\t\t\t\t\tdie($err_hint);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdie(\"We are sorry, but a MySQL - error occurred. The administrator may find more information in in the sql-error.log in the logs/ directory\");\n\t\t}\n\t}\n}\n"], "fixing_code": ["<?php\n\n/**\n * This file is part of the Froxlor project.\n * Copyright (c) 2010 the Froxlor Team (see authors).\n *\n * For the full copyright and license information, please view the COPYING\n * file that was distributed with this source code. You can also view the\n * COPYING file online at http://files.froxlor.org/misc/COPYING.txt\n *\n * @copyright  (c) the authors\n * @author     Michael Kaufmann <mkaufmann@nutime.de>\n * @author     Froxlor team <team@froxlor.org> (2010-)\n * @license    GPLv2 http://files.froxlor.org/misc/COPYING.txt\n * @package    Classes\n *\n * @since      0.9.31\n *\n */\n\n/**\n * Class Database\n *\n * Wrapper-class for PHP-PDO\n *\n * @copyright  (c) the authors\n * @author     Michael Kaufmann <mkaufmann@nutime.de>\n * @author     Froxlor team <team@froxlor.org> (2010-)\n * @license    GPLv2 http://files.froxlor.org/misc/COPYING.txt\n * @package    Classes\n */\nclass Database {\n\n\t/**\n\t * current database link\n\t *\n\t * @var object\n\t */\n\tprivate static $_link = null ;\n\n\t/**\n\t * indicator whether to use root-connection or not\n\t */\n\tprivate static $_needroot = false;\n\n\t/**\n\t * indicator which database-server we're on (not really used)\n\t */\n\tprivate static $_dbserver = 0;\n\n\t/**\n\t * used database-name\n\t */\n\tprivate static $_dbname = null;\n\n\t/**\n\t * sql-access data\n\t */\n\tprivate static $_needsqldata = false;\n\tprivate static $_sqldata = null;\n\n\t/**\n\t * Wrapper for PDOStatement::execute so we can catch the PDOException\n\t * and display the error nicely on the panel\n\t *\n\t * @param PDOStatement $stmt\n\t * @param array $params (optional)\n\t * @param bool $showerror suppress errordisplay (default true)\n\t */\n\tpublic static function pexecute(&$stmt, $params = null, $showerror = true) {\n\t\ttry {\n\t\t\t$stmt->execute($params);\n\t\t} catch (PDOException $e) {\n\t\t\tself::_showerror($e, $showerror);\n\t\t}\n\t}\n\n\t/**\n\t * Wrapper for PDOStatement::execute so we can catch the PDOException\n\t * and display the error nicely on the panel - also fetches the\n\t * result from the statement and returns the resulting array\n\t *\n\t * @param PDOStatement $stmt\n\t * @param array $params (optional)\n\t * @param bool $showerror suppress errordisplay (default true)\n\t *\n\t * @return array\n\t */\n\tpublic static function pexecute_first(&$stmt, $params = null, $showerror = true) {\n\t\tself::pexecute($stmt, $params, $showerror);\n\t\treturn $stmt->fetch(PDO::FETCH_ASSOC);\n\t}\n\n\t/**\n\t * returns the number of found rows of the last select query\n\t *\n\t * @return int\n\t */\n\tpublic static function num_rows() {\n\t\treturn Database::query(\"SELECT FOUND_ROWS()\")->fetchColumn();\n\t}\n\n\t/**\n\t * returns the database-name which is used\n\t *\n\t * @return string\n\t */\n\tpublic static function getDbName() {\n\t\treturn self::$_dbname;\n\t}\n\n\t/**\n\t * enabled the usage of a root-connection to the database\n\t * Note: must be called *before* any prepare/query/etc.\n\t * and should be called again with 'false'-parameter to resume\n\t * the 'normal' database-connection\n\t *\n\t * @param bool $needroot\n\t * @param int $dbserver optional\n\t */\n\tpublic static function needRoot($needroot = false, $dbserver = 0) {\n\t\t// force re-connecting to the db with corresponding user\n\t\t// and set the $dbserver (mostly to 0 = default)\n\t\tself::_setServer($dbserver);\n\t\tself::$_needroot = $needroot;\n\t}\n\n\t/**\n\t * enable the temporary access to sql-access data\n\t * note: if you want root-sqldata you need to\n\t * call needRoot(true) first. Also, this will\n\t * only give you the data ONCE as it disable itself\n\t * after the first access to the data\n\t *\n\t */\n\tpublic static function needSqlData() {\n\t\tself::$_needsqldata = true;\n\t\tself::$_sqldata = array();\n\t\tself::$_link = null;\n\t\t// we need a connection here because\n\t\t// if getSqlData() is called RIGHT after\n\t\t// this function and no \"real\" PDO\n\t\t// function was called, getDB() wasn't\n\t\t// involved and no data collected\n\t\tself::getDB();\n\t}\n\n\t/**\n\t * returns the sql-access data as array using indeces\n\t * 'user', 'passwd' and 'host'. Returns false if not enabled\n\t *\n\t * @return array|bool\n\t */\n\tpublic static function getSqlData() {\n\t\t$return = false;\n\t\tif (self::$_sqldata !== null\n\t\t\t\t&& is_array(self::$_sqldata)\n\t\t\t\t&& isset(self::$_sqldata['user'])\n\t\t) {\n\t\t\t$return = self::$_sqldata;\n\t\t\t// automatically disable sql-data\n\t\t\tself::$_sqldata = null;\n\t\t\tself::$_needsqldata = false;\n\t\t}\n\t\treturn $return;\n\t}\n\n\t/**\n\t * let's us interact with the PDO-Object by using static\n\t * call like \"Database::function()\"\n\t *\n\t * @param string $name\n\t * @param mixed $args\n\t *\n\t * @return mixed\n\t */\n\tpublic static function __callStatic($name, $args) {\n\t\t$callback = array(self::getDB(), $name);\n\t\t$result = null;\n\t\ttry {\n\t\t\t$result = call_user_func_array($callback, $args );\n\t\t} catch (PDOException $e) {\n\t\t\tself::_showerror($e);\n\t\t}\n\t\treturn $result;\n\t}\n\n\t/**\n\t * set the database-server (relevant for root-connection)\n\t *\n\t * @param int $dbserver\n\t */\n\tprivate static function _setServer($dbserver = 0) {\n\t\tself::$_dbserver = $dbserver;\n\t\tself::$_link = null;\n\t}\n\n\t/**\n\t * function that will be called on every static call\n\t * which connects to the database if necessary\n\t *\n\t * @param bool $root\n\t *\n\t * @return object\n\t */\n\tprivate static function getDB() {\n\n\t\tif (!extension_loaded('pdo') || in_array(\"mysql\", PDO::getAvailableDrivers()) == false) {\n\t\t\tself::_showerror(new Exception(\"The php PDO extension or PDO-MySQL driver is not available\"));\n\t\t}\n\n\t\t// do we got a connection already?\n\t\tif (self::$_link) {\n\t\t\t// return it\n\t\t\treturn self::$_link;\n\t\t}\n\n\t\t// include userdata.inc.php\n\t\trequire FROXLOR_INSTALL_DIR.\"/lib/userdata.inc.php\";\n\n\t\t// le format\n\t\tif (self::$_needroot == true\n\t\t\t\t&& isset($sql['root_user'])\n\t\t\t\t&& isset($sql['root_password'])\n\t\t\t\t&& (!isset($sql_root) || !is_array($sql_root))\n\t\t) {\n\t\t\t$sql_root = array(0 => array('caption' => 'Default', 'host' => $sql['host'], 'socket' => (isset($sql['socket']) ? $sql['socket'] : null), 'user' => $sql['root_user'], 'password' => $sql['root_password']));\n\t\t\tunset($sql['root_user']);\n\t\t\tunset($sql['root_password']);\n\t\t}\n\n\t\t// either root or unprivileged user\n\t\tif (self::$_needroot) {\n\t\t\t$caption = $sql_root[self::$_dbserver]['caption'];\n\t\t\t$user = $sql_root[self::$_dbserver]['user'];\n\t\t\t$password = $sql_root[self::$_dbserver]['password'];\n\t\t\t$host = $sql_root[self::$_dbserver]['host'];\n\t\t\t$socket = isset($sql_root[self::$_dbserver]['socket']) ? $sql_root[self::$_dbserver]['socket'] : null;\n\t\t\t$port = isset($sql_root[self::$_dbserver]['port']) ? $sql_root[self::$_dbserver]['port'] : '3306';\n\t\t} else {\n\t\t\t$caption = 'localhost';\n\t\t\t$user = $sql[\"user\"];\n\t\t\t$password = $sql[\"password\"];\n\t\t\t$host = $sql[\"host\"];\n\t\t\t$socket = isset($sql['socket']) ? $sql['socket'] : null;\n\t\t\t$port = isset($sql['port']) ? $sql['port'] : '3306';\n\t\t}\n\n\t\t// save sql-access-data if needed\n\t\tif (self::$_needsqldata) {\n\t\t\tself::$_sqldata = array(\n\t\t\t\t\t'user' => $user,\n\t\t\t\t\t'passwd' => $password,\n\t\t\t\t\t'host' => $host,\n\t\t\t\t\t'port' => $port,\n\t\t\t\t\t'socket' => $socket,\n\t\t\t\t\t'db' => $sql[\"db\"],\n\t\t\t\t\t'caption' => $caption\n\t\t\t);\n\t\t}\n\n\t\t// build up connection string\n\t\t$driver = 'mysql';\n\t\t$dsn = $driver.\":\";\n\t\t$options = array(PDO::MYSQL_ATTR_INIT_COMMAND => 'set names utf8');\n\t\t$attributes = array('ATTR_ERRMODE' => 'ERRMODE_EXCEPTION');\n\n\t\t$dbconf[\"dsn\"] = array(\n\t\t\t\t'dbname' => $sql[\"db\"],\n\t\t\t\t'charset' => 'utf8'\n\t\t);\n\n\t\tif ($socket != null) {\n\t\t\t$dbconf[\"dsn\"]['unix_socket'] = makeCorrectFile($socket);\n\t\t} else {\n\t\t\t$dbconf[\"dsn\"]['host'] = $host;\n\t\t\t$dbconf[\"dsn\"]['port'] = $port;\n\t\t}\n\n\t\tself::$_dbname = $sql[\"db\"];\n\n\t\t// add options to dsn-string\n\t\tforeach ($dbconf[\"dsn\"] as $k => $v) {\n\t\t\t$dsn .= $k.\"=\".$v.\";\";\n\t\t}\n\n\t\t// clean up\n\t\tunset($dbconf);\n\n\t\t// try to connect\n\t\ttry {\n\t\t\tself::$_link = new PDO($dsn, $user, $password, $options);\n\t\t} catch (PDOException $e) {\n\t\t\tself::_showerror($e);\n\t\t}\n\n\t\t// set attributes\n\t\tforeach ($attributes as $k => $v) {\n\t\t\tself::$_link->setAttribute(constant(\"PDO::\".$k), constant(\"PDO::\".$v));\n\t\t}\n\n\t\t// return PDO instance\n\t\treturn self::$_link;\n\t}\n\n\t/**\n\t * display a nice error if it occurs and log everything\n\t *\n\t * @param PDOException $error\n\t * @param bool $showerror if set to false, the error will be logged but we go on\n\t */\n\tprivate static function _showerror($error, $showerror = true) {\n\t\tglobal $userinfo, $theme, $linker;\n\n\t\t// include userdata.inc.php\n\t\trequire FROXLOR_INSTALL_DIR.\"/lib/userdata.inc.php\";\n\n\t\t// le format\n\t\tif (isset($sql['root_user'])\n\t\t    && isset($sql['root_password'])\n\t\t    && (!isset($sql_root) || !is_array($sql_root))\n\t\t) {\n\t\t    $sql_root = array(0 => array('caption' => 'Default', 'host' => $sql['host'], 'socket' => (isset($sql['socket']) ? $sql['socket'] : null), 'user' => $sql['root_user'], 'password' => $sql['root_password']));\n\t\t}\n\n\t\t// hide username/password in messages\n\t\t$error_message = $error->getMessage();\n\t\t$error_trace = $error->getTraceAsString();\n\t\t// error-message\n\t\t$error_message = str_replace($sql['password'], 'DB_UNPRIV_PWD', $error_message);\n\t\t$error_message = str_replace($sql_root[0]['password'], 'DB_ROOT_PWD', $error_message);\n\t\t// error-trace\n\t\t$error_trace = str_replace($sql['password'], 'DB_UNPRIV_PWD', $error_trace);\n\t\t$error_trace = str_replace($sql_root[0]['password'], 'DB_ROOT_PWD', $error_trace);\n\n\t\tif ($error->getCode() == 2003) {\n\t\t    $error_message = \"Unable to connect to database. Either the mysql-server is not running or your user/password is wrong.\";\n\t\t    $error_trace = \"\";\n\t\t}\n\n\t\t/**\n\t\t * log to a file, so we can actually ask people for the error\n\t\t * (no one seems to find the stuff in the syslog)\n\t\t */\n\t\t$sl_dir = makeCorrectDir(FROXLOR_INSTALL_DIR.\"/logs/\");\n\t\tif (!file_exists($sl_dir)) {\n\t\t\t@mkdir($sl_dir, 0755);\n\t\t}\n\t\t$sl_file = makeCorrectFile($sl_dir.\"/sql-error.log\");\n\t\t$sqllog = @fopen($sl_file, 'a');\n\t\t@fwrite($sqllog, date('d.m.Y H:i', time()).\" --- \".str_replace(\"\\n\", \" \", $error_message).\"\\n\");\n\t\t@fwrite($sqllog, date('d.m.Y H:i', time()).\" --- DEBUG: \\n\".$error_trace.\"\\n\");\n\t\t@fclose($sqllog);\n\n\t\t/**\n\t\t * log error for reporting\n\t\t*/\n\t\t$errid = substr(md5(microtime()), 5, 5);\n\t\t$err_file = makeCorrectFile($sl_dir.\"/\".$errid.\"_sql-error.log\");\n\t\t$errlog = @fopen($err_file, 'w');\n\t\t@fwrite($errlog, \"|CODE \".$error->getCode().\"\\n\");\n\t\t@fwrite($errlog, \"|MSG \".$error_message.\"\\n\");\n\t\t@fwrite($errlog, \"|FILE \".$error->getFile().\"\\n\");\n\t\t@fwrite($errlog, \"|LINE \".$error->getLine().\"\\n\");\n\t\t@fwrite($errlog, \"|TRACE\\n\".$error_trace.\"\\n\");\n\t\t@fclose($errlog);\n\n\t\tif ($showerror) {\n\n\t\t\t// fallback\n\t\t\t$theme = 'Sparkle';\n\n\t\t\t// clean up sensitive data\n\t\t\tunset($sql);\n\t\t\tunset($sql_root);\n\n\t\t\tif ((isset($theme) && $theme != '')\n\t\t\t\t\t&& !isset($_SERVER['SHELL']) || (isset($_SERVER['SHELL']) && $_SERVER['SHELL'] == '')\n\t\t\t) {\n\t\t\t\t// if we're not on the shell, output a nice error\n\t\t\t\t$_errtpl = dirname($sl_dir).'/templates/'.$theme.'/misc/dberrornice.tpl';\n\t\t\t\tif (file_exists($_errtpl)) {\n\t\t\t\t\t$err_hint = file_get_contents($_errtpl);\n\t\t\t\t\t// replace values\n\t\t\t\t\t$err_hint = str_replace(\"<TEXT>\", $error_message, $err_hint);\n\t\t\t\t\t$err_hint = str_replace(\"<DEBUG>\", $error_trace, $err_hint);\n\t\t\t\t\t$err_hint = str_replace(\"<CURRENT_YEAR>\", date('Y', time()), $err_hint);\n\n\t\t\t\t\t$err_report_html = '';\n\t\t\t\t\tif (is_array($userinfo) && (\n\t\t\t\t\t\t\t($userinfo['adminsession'] == '1' && Settings::Get('system.allow_error_report_admin') == '1')\n\t\t\t\t\t\t\t|| ($userinfo['adminsession'] == '0' && Settings::Get('system.allow_error_report_customer') == '1'))\n\t\t\t\t\t) {\n\t\t\t\t\t\t$err_report_html = '<a href=\"<LINK>\" title=\"Click here to report error\">Report error</a>';\n\t\t\t\t\t\t$err_report_html = str_replace(\"<LINK>\", $linker->getLink(array('section' => 'index', 'page' => 'send_error_report', 'errorid' => $errid)), $err_report_html);\n\t\t\t\t\t}\n\t\t\t\t\t$err_hint = str_replace(\"<REPORT>\", $err_report_html, $err_hint);\n\n\t\t\t\t\t// show\n\t\t\t\t\tdie($err_hint);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdie(\"We are sorry, but a MySQL - error occurred. The administrator may find more information in in the sql-error.log in the logs/ directory\");\n\t\t}\n\t}\n}\n"], "filenames": ["lib/classes/database/class.Database.php"], "buggy_code_start_loc": [314], "buggy_code_end_loc": [372], "fixing_code_start_loc": [315], "fixing_code_end_loc": [371], "type": "CWE-200", "message": "Froxlor before 0.9.33.2 with the default configuration/setup might allow remote attackers to obtain the database password by reading /logs/sql-error.log.", "other": {"cve": {"id": "CVE-2015-5959", "sourceIdentifier": "cve@mitre.org", "published": "2017-09-06T21:29:00.880", "lastModified": "2017-09-07T19:53:56.520", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Froxlor before 0.9.33.2 with the default configuration/setup might allow remote attackers to obtain the database password by reading /logs/sql-error.log."}, {"lang": "es", "value": "Cuando se utiliza la configuraci\u00f3n por defecto de Froxlor, en versiones anteriores a la 0.9.33.2, puede permitir que atacantes remotos obtengan la contrase\u00f1a de la base de datos leyendo /logs/sql-error.log."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:froxlor:froxlor:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.9.33.1", "matchCriteriaId": "3C875F4A-D163-4794-9CC8-2AB59B00C641"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2015/08/07/2", "source": "cve@mitre.org", "tags": ["Mailing List"]}, {"url": "http://www.securityfocus.com/bid/76097", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/Froxlor/Froxlor/commit/8558533a9148a2a0302c9c177abff8e4e4075b92", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/Froxlor/Froxlor/commit/8558533a9148a2a0302c9c177abff8e4e4075b92"}}