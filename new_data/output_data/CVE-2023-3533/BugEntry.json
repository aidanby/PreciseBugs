{"buggy_code": ["<?php\n\n/* For licensing terms, see /license.txt */\n\nuse Chamilo\\CoreBundle\\Component\\HTMLPurifier\\Filter\\AllowIframes;\nuse ChamiloSession as Session;\n\n/**\n * This is the security library for Chamilo.\n *\n * This library is based on recommendations found in the PHP5 Certification\n * Guide published at PHP|Architect, and other recommendations found on\n * http://www.phpsec.org/\n * The principles here are that all data is tainted (most scripts of Chamilo are\n * open to the public or at least to a certain public that could be malicious\n * under specific circumstances). We use the white list approach, where as we\n * consider that data can only be used in the database or in a file if it has\n * been filtered.\n *\n * For session fixation, use ...\n * For session hijacking, use get_ua() and check_ua()\n * For Cross-Site Request Forgeries, use get_token() and check_tocken()\n * For basic filtering, use filter()\n * For files inclusions (using dynamic paths) use check_rel_path() and check_abs_path()\n *\n * @author Yannick Warnier <ywarnier@beeznest.org>\n */\n\n/**\n * Security class.\n *\n * Include/require it in your code and call Security::function()\n * to use its functionalities.\n *\n * This class can also be used as a container for filtered data, by creating\n * a new Security object and using $secure->filter($new_var,[more options])\n * and then using $secure->clean['var'] as a filtered equivalent, although\n * this is *not* mandatory at all.\n */\nclass Security\n{\n    public const CHAR_UPPER = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    public const CHAR_LOWER = 'abcdefghijklmnopqrstuvwxyz';\n    public const CHAR_DIGITS = '0123456789';\n    public const CHAR_SYMBOLS = '!\"#$%&\\'()*+,-./:;<=>?@[\\]^_`{|}~';\n\n    public static $clean = [];\n\n    /**\n     * Checks if the absolute path (directory) given is really under the\n     * checker path (directory).\n     *\n     * @param string    Absolute path to be checked (with trailing slash)\n     * @param string    Checker path under which the path\n     * should be (absolute path, with trailing slash, get it from api_get_path(SYS_COURSE_PATH))\n     *\n     * @return bool True if the path is under the checker, false otherwise\n     */\n    public static function check_abs_path($abs_path, $checker_path)\n    {\n        // The checker path must be set.\n        if (empty($checker_path)) {\n            return false;\n        }\n\n        // Clean $abs_path.\n        $abs_path = str_replace(['//', '../'], ['/', ''], $abs_path);\n        $true_path = str_replace(\"\\\\\", '/', realpath($abs_path));\n        $checker_path = str_replace(\"\\\\\", '/', realpath($checker_path));\n\n        if (empty($checker_path)) {\n            return false;\n        }\n\n        $found = strpos($true_path.'/', $checker_path);\n\n        if ($found === 0) {\n            return true;\n        } else {\n            // Code specific to Windows and case-insensitive behaviour\n            if (api_is_windows_os()) {\n                $found = stripos($true_path.'/', $checker_path);\n                if ($found === 0) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks if the relative path (directory) given is really under the\n     * checker path (directory).\n     *\n     * @param string    Relative path to be checked (relative to the current directory) (with trailing slash)\n     * @param string    Checker path under which the path\n     * should be (absolute path, with trailing slash, get it from api_get_path(SYS_COURSE_PATH))\n     *\n     * @return bool True if the path is under the checker, false otherwise\n     */\n    public static function check_rel_path($rel_path, $checker_path)\n    {\n        // The checker path must be set.\n        if (empty($checker_path)) {\n            return false;\n        }\n        $current_path = getcwd(); // No trailing slash.\n        if (substr($rel_path, -1, 1) != '/') {\n            $rel_path = '/'.$rel_path;\n        }\n        $abs_path = $current_path.$rel_path;\n        $true_path = str_replace(\"\\\\\", '/', realpath($abs_path));\n        $found = strpos($true_path.'/', $checker_path);\n        if ($found === 0) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Filters dangerous filenames (*.php[.]?* and .htaccess) and returns it in\n     * a non-executable form (for PHP and htaccess, this is still vulnerable to\n     * other languages' files extensions).\n     *\n     * @param string $filename Unfiltered filename\n     *\n     * @return string\n     */\n    public static function filter_filename($filename)\n    {\n        return disable_dangerous_file($filename);\n    }\n\n    /**\n     * @return string\n     */\n    public static function getTokenFromSession(string $prefix = '')\n    {\n        $secTokenVariable = self::generateSecTokenVariable($prefix);\n\n        return Session::read($secTokenVariable);\n    }\n\n    /**\n     * This function checks that the token generated in get_token() has been kept (prevents\n     * Cross-Site Request Forgeries attacks).\n     *\n     * @param    string    The array in which to get the token ('get' or 'post')\n     *\n     * @return bool True if it's the right token, false otherwise\n     */\n    public static function check_token($requestType = 'post', FormValidator $form = null, string $prefix = '')\n    {\n        $secTokenVariable = self::generateSecTokenVariable($prefix);\n        $sessionToken = Session::read($secTokenVariable);\n        switch ($requestType) {\n            case 'request':\n                if (!empty($sessionToken) && isset($_REQUEST[$secTokenVariable]) && $sessionToken === $_REQUEST[$secTokenVariable]) {\n                    return true;\n                }\n\n                return false;\n            case 'get':\n                if (!empty($sessionToken) && isset($_GET[$secTokenVariable]) && $sessionToken === $_GET[$secTokenVariable]) {\n                    return true;\n                }\n\n                return false;\n            case 'post':\n                if (!empty($sessionToken) && isset($_POST[$secTokenVariable]) && $sessionToken === $_POST[$secTokenVariable]) {\n                    return true;\n                }\n\n                return false;\n            case 'form':\n                $token = $form->getSubmitValue('protect_token');\n\n                if (!empty($sessionToken) && !empty($token) && $sessionToken === $token) {\n                    return true;\n                }\n\n                return false;\n            default:\n                if (!empty($sessionToken) && isset($requestType) && $sessionToken === $requestType) {\n                    return true;\n                }\n\n                return false;\n        }\n\n        return false; // Just in case, don't let anything slip.\n    }\n\n    /**\n     * Checks the user agent of the client as recorder by get_ua() to prevent\n     * most session hijacking attacks.\n     *\n     * @return bool True if the user agent is the same, false otherwise\n     */\n    public static function check_ua()\n    {\n        $security = Session::read('sec_ua');\n        $securitySeed = Session::read('sec_ua_seed');\n\n        if ($security === $_SERVER['HTTP_USER_AGENT'].$securitySeed) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Clear the security token from the session.\n     */\n    public static function clear_token(string $prefix = '')\n    {\n        $secTokenVariable = self::generateSecTokenVariable($prefix);\n\n        Session::erase($secTokenVariable);\n    }\n\n    /**\n     * This function sets a random token to be included in a form as a hidden field\n     * and saves it into the user's session. Returns an HTML form element\n     * This later prevents Cross-Site Request Forgeries by checking that the user is really\n     * the one that sent this form in knowingly (this form hasn't been generated from\n     * another website visited by the user at the same time).\n     * Check the token with check_token().\n     *\n     * @return string Hidden-type input ready to insert into a form\n     */\n    public static function get_HTML_token(string $prefix = '')\n    {\n        $secTokenVariable = self::generateSecTokenVariable($prefix);\n        $token = md5(uniqid(rand(), true));\n        $string = '<input type=\"hidden\" name=\"'.$secTokenVariable.'\" value=\"'.$token.'\" />';\n        Session::write($secTokenVariable, $token);\n\n        return $string;\n    }\n\n    /**\n     * This function sets a random token to be included in a form as a hidden field\n     * and saves it into the user's session.\n     * This later prevents Cross-Site Request Forgeries by checking that the user is really\n     * the one that sent this form in knowingly (this form hasn't been generated from\n     * another website visited by the user at the same time).\n     * Check the token with check_token().\n     *\n     * @return string Token\n     */\n    public static function get_token($prefix = '')\n    {\n        $secTokenVariable = self::generateSecTokenVariable($prefix);\n        $token = md5(uniqid(rand(), true));\n        Session::write($secTokenVariable, $token);\n\n        return $token;\n    }\n\n    /**\n     * @return string\n     */\n    public static function get_existing_token(string $prefix = '')\n    {\n        $secTokenVariable = self::generateSecTokenVariable($prefix);\n        $token = Session::read($secTokenVariable);\n        if (!empty($token)) {\n            return $token;\n        } else {\n            return self::get_token($prefix);\n        }\n    }\n\n    /**\n     * Gets the user agent in the session to later check it with check_ua() to prevent\n     * most cases of session hijacking.\n     */\n    public static function get_ua()\n    {\n        $seed = uniqid(rand(), true);\n        Session::write('sec_ua_seed', $seed);\n        Session::write('sec_ua', $_SERVER['HTTP_USER_AGENT'].$seed);\n    }\n\n    /**\n     * This function returns a variable from the clean array. If the variable doesn't exist,\n     * it returns null.\n     *\n     * @param string    Variable name\n     *\n     * @return mixed Variable or NULL on error\n     */\n    public static function get($varname)\n    {\n        if (isset(self::$clean[$varname])) {\n            return self::$clean[$varname];\n        }\n\n        return null;\n    }\n\n    /**\n     * This function tackles the XSS injections.\n     * Filtering for XSS is very easily done by using the htmlentities() function.\n     * This kind of filtering prevents JavaScript snippets to be understood as such.\n     *\n     * @param string The variable to filter for XSS, this params can be a string or an array (example : array(x,y))\n     * @param int The user status,constant allowed (STUDENT, COURSEMANAGER, ANONYMOUS, COURSEMANAGERLOWSECURITY)\n     * @param bool $filter_terms\n     *\n     * @return mixed Filtered string or array\n     */\n    public static function remove_XSS($var, $user_status = null, $filter_terms = false)\n    {\n        if ($filter_terms) {\n            $var = self::filter_terms($var);\n        }\n\n        if (empty($user_status)) {\n            if (api_is_anonymous()) {\n                $user_status = ANONYMOUS;\n            } else {\n                if (api_is_allowed_to_edit()) {\n                    $user_status = COURSEMANAGER;\n                } else {\n                    $user_status = STUDENT;\n                }\n            }\n        }\n\n        if ($user_status == COURSEMANAGERLOWSECURITY) {\n            return $var; // No filtering.\n        }\n\n        static $purifier = [];\n        if (!isset($purifier[$user_status])) {\n            $cache_dir = api_get_path(SYS_ARCHIVE_PATH).'Serializer';\n            if (!file_exists($cache_dir)) {\n                $mode = api_get_permissions_for_new_directories();\n                mkdir($cache_dir, $mode);\n            }\n            $config = HTMLPurifier_Config::createDefault();\n            $config->set('Cache.SerializerPath', $cache_dir);\n            $config->set('Core.Encoding', api_get_system_encoding());\n            $config->set('HTML.Doctype', 'XHTML 1.0 Transitional');\n            $config->set('HTML.MaxImgLength', '2560');\n            $config->set('HTML.TidyLevel', 'light');\n            $config->set('Core.ConvertDocumentToFragment', false);\n            $config->set('Core.RemoveProcessingInstructions', true);\n\n            if (api_get_setting('enable_iframe_inclusion') == 'true') {\n                $config->set('Filter.Custom', [new AllowIframes()]);\n            }\n\n            // Shows _target attribute in anchors\n            $config->set('Attr.AllowedFrameTargets', ['_blank', '_top', '_self', '_parent']);\n\n            if ($user_status == STUDENT) {\n                global $allowed_html_student;\n                $config->set('HTML.SafeEmbed', true);\n                $config->set('HTML.SafeObject', true);\n                $config->set('Filter.YouTube', true);\n                $config->set('HTML.FlashAllowFullScreen', true);\n                $config->set('HTML.Allowed', $allowed_html_student);\n            } elseif ($user_status == COURSEMANAGER) {\n                global $allowed_html_teacher;\n                $config->set('HTML.SafeEmbed', true);\n                $config->set('HTML.SafeObject', true);\n                $config->set('Filter.YouTube', true);\n                $config->set('HTML.FlashAllowFullScreen', true);\n                $config->set('HTML.Allowed', $allowed_html_teacher);\n            } else {\n                global $allowed_html_anonymous;\n                $config->set('HTML.Allowed', $allowed_html_anonymous);\n            }\n\n            // We need it for example for the flv player (ids of surrounding div-tags have to be preserved).\n            $config->set('Attr.EnableID', true);\n            $config->set('CSS.AllowImportant', true);\n            // We need for the flv player the css definition display: none;\n            $config->set('CSS.AllowTricky', true);\n            $config->set('CSS.Proprietary', true);\n\n            // Allow uri scheme.\n            $config->set('URI.AllowedSchemes', [\n                'http' => true,\n                'https' => true,\n                'mailto' => true,\n                'ftp' => true,\n                'nntp' => true,\n                'news' => true,\n                'data' => true,\n            ]);\n\n            // Allow <video> tag\n            //$config->set('HTML.Doctype', 'HTML 4.01 Transitional');\n            $config->set('HTML.SafeIframe', true);\n\n            // Set some HTML5 properties\n            $config->set('HTML.DefinitionID', 'html5-definitions'); // unqiue id\n            $config->set('HTML.DefinitionRev', 1);\n            if ($def = $config->maybeGetRawHTMLDefinition()) {\n                // https://html.spec.whatwg.org/dev/media.html#the-video-element\n                $def->addElement(\n                    'video',\n                    'Block',\n                    'Optional: (source, Flow) | (Flow, source) | Flow',\n                    'Common',\n                    [\n                        'src' => 'URI',\n                        'type' => 'Text',\n                        'width' => 'Length',\n                        'height' => 'Length',\n                        'poster' => 'URI',\n                        'preload' => 'Enum#auto,metadata,none',\n                        'controls' => 'Bool',\n                    ]\n                );\n                // https://html.spec.whatwg.org/dev/media.html#the-audio-element\n                $def->addElement(\n                    'audio',\n                    'Block',\n                    'Optional: (source, Flow) | (Flow, source) | Flow',\n                    'Common',\n                    [\n                        'autoplay' => 'Bool',\n                        'src' => 'URI',\n                        'loop' => 'Bool',\n                        'preload' => 'Enum#auto,metadata,none',\n                        'controls' => 'Bool',\n                        'muted' => 'Bool',\n                    ]\n                );\n                $def->addElement(\n                    'source',\n                    'Block',\n                    'Flow',\n                    'Common',\n                    ['src' => 'URI', 'type' => 'Text']\n                );\n            }\n\n            $purifier[$user_status] = new HTMLPurifier($config);\n        }\n\n        if (is_array($var)) {\n            return $purifier[$user_status]->purifyArray($var);\n        } else {\n            return $purifier[$user_status]->purify($var);\n        }\n    }\n\n    /**\n     * Filter content.\n     *\n     * @param string $text to be filter\n     *\n     * @return string\n     */\n    public static function filter_terms($text)\n    {\n        static $bad_terms = [];\n\n        if (empty($bad_terms)) {\n            $list = api_get_setting('filter_terms');\n            if (!empty($list)) {\n                $list = explode(\"\\n\", $list);\n                $list = array_filter($list);\n                if (!empty($list)) {\n                    foreach ($list as $term) {\n                        $term = str_replace([\"\\r\\n\", \"\\r\", \"\\n\", \"\\t\"], '', $term);\n                        $html_entities_value = api_htmlentities($term, ENT_QUOTES, api_get_system_encoding());\n                        $bad_terms[] = $term;\n                        if ($term != $html_entities_value) {\n                            $bad_terms[] = $html_entities_value;\n                        }\n                    }\n                }\n                $bad_terms = array_filter($bad_terms);\n            }\n        }\n\n        $replace = '***';\n        if (!empty($bad_terms)) {\n            // Fast way\n            $new_text = str_ireplace($bad_terms, $replace, $text, $count);\n            $text = $new_text;\n        }\n\n        return $text;\n    }\n\n    /**\n     * This method provides specific protection (against XSS and other kinds of attacks)\n     * for static images (icons) used by the system.\n     * Image paths are supposed to be given by programmers - people who know what they do, anyway,\n     * this method encourages a safe practice for generating icon paths, without using heavy solutions\n     * based on HTMLPurifier for example.\n     *\n     * @param string $image_path the input path of the image, it could be relative or absolute URL\n     *\n     * @return string returns sanitized image path or an empty string when the image path is not secure\n     *\n     * @author Ivan Tcholakov, March 2011\n     */\n    public static function filter_img_path($image_path)\n    {\n        static $allowed_extensions = ['png', 'gif', 'jpg', 'jpeg', 'svg', 'webp'];\n        $image_path = htmlspecialchars(trim($image_path)); // No html code is allowed.\n        // We allow static images only, query strings are forbidden.\n        if (strpos($image_path, '?') !== false) {\n            return '';\n        }\n        if (($pos = strpos($image_path, ':')) !== false) {\n            // Protocol has been specified, let's check it.\n            if (stripos($image_path, 'javascript:') !== false) {\n                // Javascript everywhere in the path is not allowed.\n                return '';\n            }\n            // We allow only http: and https: protocols for now.\n            //if (!preg_match('/^https?:\\/\\//i', $image_path)) {\n            //    return '';\n            //}\n            if (stripos($image_path, 'http://') !== 0 && stripos($image_path, 'https://') !== 0) {\n                return '';\n            }\n        }\n        // We allow file extensions for images only.\n        //if (!preg_match('/.+\\.(png|gif|jpg|jpeg)$/i', $image_path)) {\n        //    return '';\n        //}\n        if (($pos = strrpos($image_path, '.')) !== false) {\n            if (!in_array(strtolower(substr($image_path, $pos + 1)), $allowed_extensions)) {\n                return '';\n            }\n        } else {\n            return '';\n        }\n\n        return $image_path;\n    }\n\n    /**\n     * Get password requirements\n     * It checks config value 'password_requirements' or uses the \"classic\"\n     * Chamilo password requirements.\n     *\n     * @return array\n     */\n    public static function getPasswordRequirements()\n    {\n        // Default\n        $requirements = [\n            'min' => [\n                'lowercase' => 0,\n                'uppercase' => 0,\n                'numeric' => 2,\n                'length' => 5,\n                'specials' => 1,\n            ],\n        ];\n\n        $passwordRequirements = api_get_configuration_value('password_requirements');\n        if (!empty($passwordRequirements)) {\n            $requirements = $passwordRequirements;\n        }\n\n        return ['min' => $requirements['min']];\n    }\n\n    /**\n     * Gets password requirements in the platform language using get_lang\n     * based in platform settings. See function 'self::getPasswordRequirements'.\n     */\n    public static function getPasswordRequirementsToString(array $evaluatedConditions = []): string\n    {\n        $output = '';\n        $setting = self::getPasswordRequirements();\n\n        $passedIcon = Display::returnFontAwesomeIcon(\n            'check',\n            '',\n            true,\n            'text-success',\n            get_lang('PasswordRequirementPassed')\n        );\n        $pendingIcon = Display::returnFontAwesomeIcon(\n            'times',\n            '',\n            true,\n            'text-danger',\n            get_lang('PasswordRequirementPending')\n        );\n\n        foreach ($setting as $type => $rules) {\n            foreach ($rules as $rule => $parameter) {\n                if (empty($parameter)) {\n                    continue;\n                }\n\n                $evaluatedCondition = $type.'_'.$rule;\n                $icon = $passedIcon;\n\n                if (array_key_exists($evaluatedCondition, $evaluatedConditions)\n                    && false === $evaluatedConditions[$evaluatedCondition]\n                ) {\n                    $icon = $pendingIcon;\n                }\n\n                $output .= empty($evaluatedConditions) ? '' : $icon;\n                $output .= sprintf(\n                    get_lang(\n                        'NewPasswordRequirement'.ucfirst($type).'X'.ucfirst($rule)\n                    ),\n                    $parameter\n                );\n                $output .= '<br />';\n            }\n        }\n\n        return $output;\n    }\n\n    /**\n     * Sanitize a string, so it can be used in the exec() command without\n     * \"jail-breaking\" to execute other commands.\n     *\n     * @param string $param The string to filter\n     */\n    public static function sanitizeExecParam(string $param): string\n    {\n        return preg_replace('/[`;&|]/', '', $param);\n    }\n\n    private static function generateSecTokenVariable(string $prefix = ''): string\n    {\n        if (empty($prefix)) {\n            return 'sec_token';\n        }\n\n        return $prefix.'_sec_token';\n    }\n}\n", "<?php\n/* For licensing terms, see /license.txt */\n/**\n * @package chamilo.webservices\n *\n * @author Francis Gonzales\n */\nrequire_once __DIR__.'/../inc/global.inc.php';\n\napi_protect_webservices();\n\n/**\n * Function to convert from ppt to png\n * This function is used from Chamilo Rapid Lesson.\n *\n * @param array $pptData\n *\n * @return string\n */\nfunction wsConvertPpt($pptData)\n{\n    global $_configuration;\n    $ip = trim($_SERVER['REMOTE_ADDR']);\n    // If an IP filter array is defined in configuration.php,\n    // check if this IP is allowed\n    if (!empty($_configuration['ppt2lp_ip_filter'])) {\n        if (!in_array($ip, $_configuration['ppt2lp_ip_filter'])) {\n            return false;\n        }\n    }\n    $fileData = $pptData['file_data'];\n    // Clean filename to avoid hacks. Prevents \"&\" and \";\" to be used in filename, notably\n    $sanitizedFileName = Security::sanitizeExecParam($pptData['file_name']);\n    $dataInfo = pathinfo($sanitizedFileName);\n    $fileName = basename($sanitizedFileName, '.'.$dataInfo['extension']);\n    // Add additional cleaning of .php and .htaccess files\n    $fullFileName = Security::filter_filename($sanitizedFileName);\n    $size = Security::sanitizeExecParam($pptData['service_ppt2lp_size']);\n    $w = '800';\n    $h = '600';\n    if (!empty($size)) {\n        list($w, $h) = explode('x', $size);\n    }\n\n    $tempArchivePath = api_get_path(SYS_ARCHIVE_PATH);\n    $tempPath = $tempArchivePath.'wsConvert/'.$fileName.'/';\n    $tempPathNewFiles = $tempArchivePath.'wsConvert/'.$fileName.'-n/';\n\n    $oldumask = umask(0);\n    //$perms = api_get_permissions_for_new_directories();\n    // Set permissions the most permissively possible: these files will\n    // be deleted below and we need a parallel process to be able to write them\n    $perms = api_get_permissions_for_new_directories();\n    pptConverterDirectoriesCreate($tempPath, $tempPathNewFiles, $fileName, $perms);\n\n    $file = base64_decode($fileData);\n    file_put_contents($tempPath.$fullFileName, $file);\n\n    $cmd = pptConverterGetCommandBaseParams();\n    $cmd .= ' -w '.$w.' -h '.$h.' -d oogie \"'.$tempPath.$fullFileName.'\"  \"'.$tempPathNewFiles.$fileName.'.html\"';\n\n    //$perms = api_get_permissions_for_new_files();\n    chmod($tempPathNewFiles.$fileName, $perms);\n\n    $files = [];\n    $return = 0;\n    $shell = exec($cmd, $files, $return);\n    umask($oldumask);\n\n    if ($return === 0) {\n        $images = [];\n        if (is_array($files) && !empty($files)) {\n            foreach ($files as $file) {\n                $imageData = explode('||', $file);\n                $images[$imageData[1]] = base64_encode(file_get_contents($tempPathNewFiles.$fileName.'/'.$imageData[1]));\n            }\n        }\n        $data = [\n            'files' => $files,\n            'images' => $images,\n        ];\n\n        deleteDirectory($tempPath);\n        deleteDirectory($tempPathNewFiles);\n\n        return serialize($data);\n    } else {\n        deleteDirectory($tempPath);\n        deleteDirectory($tempPathNewFiles);\n\n        return false;\n    }\n}\n\n/**\n * @param $directoryPath\n *\n * @return bool\n */\nfunction deleteDirectory($directoryPath)\n{\n    $files = array_diff(scandir($directoryPath), ['.', '..']);\n    foreach ($files as $file) {\n        if (is_dir(\"$directoryPath/$file\")) {\n            deleteDirectory(\"$directoryPath/$file\");\n        } else {\n            unlink(\"$directoryPath/$file\");\n        }\n    }\n\n    return rmdir($directoryPath);\n}\n\n/**\n * Helper function to create the directory structure for the PPT converter.\n *\n * @param string $tempPath\n * @param string $tempPathNewFiles\n * @param string $fileName\n * @param string $perms\n */\nfunction pptConverterDirectoriesCreate($tempPath, $tempPathNewFiles, $fileName, $perms)\n{\n    if (!is_dir($tempPath)) {\n        mkdir($tempPath, $perms, true);\n    }\n    if (!is_dir($tempPathNewFiles)) {\n        mkdir($tempPathNewFiles, $perms, true);\n    }\n    if (!is_dir($tempPathNewFiles.$fileName)) {\n        mkdir($tempPathNewFiles.$fileName, $perms, true);\n    }\n}\n\n/**\n * Helper function to build the command line parameters for the converter.\n *\n * @return string $cmd\n */\nfunction pptConverterGetCommandBaseParams()\n{\n    if (IS_WINDOWS_OS) { // IS_WINDOWS_OS has been defined in main_api.lib.php\n        $converterPath = str_replace('/', '\\\\', api_get_path(SYS_PATH).'main/inc/lib/ppt2png');\n        $classPath = $converterPath.';'.$converterPath.'/jodconverter-2.2.2.jar;'.$converterPath.'/jodconverter-cli-2.2.2.jar';\n        $cmd = 'java -Dfile.encoding=UTF-8 -cp \"'.$classPath.'\" DokeosConverter';\n    } else {\n        $converterPath = api_get_path(SYS_PATH).'main/inc/lib/ppt2png';\n        $classPath = ' -Dfile.encoding=UTF-8 -cp .:jodconverter-2.2.2.jar:jodconverter-cli-2.2.2.jar';\n        $cmd = 'cd '.$converterPath.' && java '.$classPath.' DokeosConverter';\n    }\n\n    $cmd .= ' -p '.api_get_setting('service_ppt2lp', 'port');\n\n    return $cmd;\n}\n\n$uri = api_get_path(WEB_CODE_PATH).'webservices/';\n$server = new SoapServer(null, ['uri' => $uri]);\n$server->addFunction(\"wsConvertPpt\");\n$server->handle();\n"], "fixing_code": ["<?php\n\n/* For licensing terms, see /license.txt */\n\nuse Chamilo\\CoreBundle\\Component\\HTMLPurifier\\Filter\\AllowIframes;\nuse ChamiloSession as Session;\n\n/**\n * This is the security library for Chamilo.\n *\n * This library is based on recommendations found in the PHP5 Certification\n * Guide published at PHP|Architect, and other recommendations found on\n * http://www.phpsec.org/\n * The principles here are that all data is tainted (most scripts of Chamilo are\n * open to the public or at least to a certain public that could be malicious\n * under specific circumstances). We use the white list approach, where as we\n * consider that data can only be used in the database or in a file if it has\n * been filtered.\n *\n * For session fixation, use ...\n * For session hijacking, use get_ua() and check_ua()\n * For Cross-Site Request Forgeries, use get_token() and check_tocken()\n * For basic filtering, use filter()\n * For files inclusions (using dynamic paths) use check_rel_path() and check_abs_path()\n *\n * @author Yannick Warnier <ywarnier@beeznest.org>\n */\n\n/**\n * Security class.\n *\n * Include/require it in your code and call Security::function()\n * to use its functionalities.\n *\n * This class can also be used as a container for filtered data, by creating\n * a new Security object and using $secure->filter($new_var,[more options])\n * and then using $secure->clean['var'] as a filtered equivalent, although\n * this is *not* mandatory at all.\n */\nclass Security\n{\n    public const CHAR_UPPER = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    public const CHAR_LOWER = 'abcdefghijklmnopqrstuvwxyz';\n    public const CHAR_DIGITS = '0123456789';\n    public const CHAR_SYMBOLS = '!\"#$%&\\'()*+,-./:;<=>?@[\\]^_`{|}~';\n\n    public static $clean = [];\n\n    /**\n     * Checks if the absolute path (directory) given is really under the\n     * checker path (directory).\n     *\n     * @param string    Absolute path to be checked (with trailing slash)\n     * @param string    Checker path under which the path\n     * should be (absolute path, with trailing slash, get it from api_get_path(SYS_COURSE_PATH))\n     *\n     * @return bool True if the path is under the checker, false otherwise\n     */\n    public static function check_abs_path($abs_path, $checker_path)\n    {\n        // The checker path must be set.\n        if (empty($checker_path)) {\n            return false;\n        }\n\n        // Clean $abs_path.\n        $abs_path = str_replace(['//', '../'], ['/', ''], $abs_path);\n        $true_path = str_replace(\"\\\\\", '/', realpath($abs_path));\n        $checker_path = str_replace(\"\\\\\", '/', realpath($checker_path));\n\n        if (empty($checker_path)) {\n            return false;\n        }\n\n        $found = strpos($true_path.'/', $checker_path);\n\n        if ($found === 0) {\n            return true;\n        } else {\n            // Code specific to Windows and case-insensitive behaviour\n            if (api_is_windows_os()) {\n                $found = stripos($true_path.'/', $checker_path);\n                if ($found === 0) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks if the relative path (directory) given is really under the\n     * checker path (directory).\n     *\n     * @param string    Relative path to be checked (relative to the current directory) (with trailing slash)\n     * @param string    Checker path under which the path\n     * should be (absolute path, with trailing slash, get it from api_get_path(SYS_COURSE_PATH))\n     *\n     * @return bool True if the path is under the checker, false otherwise\n     */\n    public static function check_rel_path($rel_path, $checker_path)\n    {\n        // The checker path must be set.\n        if (empty($checker_path)) {\n            return false;\n        }\n        $current_path = getcwd(); // No trailing slash.\n        if (substr($rel_path, -1, 1) != '/') {\n            $rel_path = '/'.$rel_path;\n        }\n        $abs_path = $current_path.$rel_path;\n        $true_path = str_replace(\"\\\\\", '/', realpath($abs_path));\n        $found = strpos($true_path.'/', $checker_path);\n        if ($found === 0) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Filters dangerous filenames (*.php[.]?* and .htaccess) and returns it in\n     * a non-executable form (for PHP and htaccess, this is still vulnerable to\n     * other languages' files extensions).\n     *\n     * @param string $filename Unfiltered filename\n     *\n     * @return string\n     */\n    public static function filter_filename($filename)\n    {\n        return disable_dangerous_file($filename);\n    }\n\n    /**\n     * @return string\n     */\n    public static function getTokenFromSession(string $prefix = '')\n    {\n        $secTokenVariable = self::generateSecTokenVariable($prefix);\n\n        return Session::read($secTokenVariable);\n    }\n\n    /**\n     * This function checks that the token generated in get_token() has been kept (prevents\n     * Cross-Site Request Forgeries attacks).\n     *\n     * @param    string    The array in which to get the token ('get' or 'post')\n     *\n     * @return bool True if it's the right token, false otherwise\n     */\n    public static function check_token($requestType = 'post', FormValidator $form = null, string $prefix = '')\n    {\n        $secTokenVariable = self::generateSecTokenVariable($prefix);\n        $sessionToken = Session::read($secTokenVariable);\n        switch ($requestType) {\n            case 'request':\n                if (!empty($sessionToken) && isset($_REQUEST[$secTokenVariable]) && $sessionToken === $_REQUEST[$secTokenVariable]) {\n                    return true;\n                }\n\n                return false;\n            case 'get':\n                if (!empty($sessionToken) && isset($_GET[$secTokenVariable]) && $sessionToken === $_GET[$secTokenVariable]) {\n                    return true;\n                }\n\n                return false;\n            case 'post':\n                if (!empty($sessionToken) && isset($_POST[$secTokenVariable]) && $sessionToken === $_POST[$secTokenVariable]) {\n                    return true;\n                }\n\n                return false;\n            case 'form':\n                $token = $form->getSubmitValue('protect_token');\n\n                if (!empty($sessionToken) && !empty($token) && $sessionToken === $token) {\n                    return true;\n                }\n\n                return false;\n            default:\n                if (!empty($sessionToken) && isset($requestType) && $sessionToken === $requestType) {\n                    return true;\n                }\n\n                return false;\n        }\n\n        return false; // Just in case, don't let anything slip.\n    }\n\n    /**\n     * Checks the user agent of the client as recorder by get_ua() to prevent\n     * most session hijacking attacks.\n     *\n     * @return bool True if the user agent is the same, false otherwise\n     */\n    public static function check_ua()\n    {\n        $security = Session::read('sec_ua');\n        $securitySeed = Session::read('sec_ua_seed');\n\n        if ($security === $_SERVER['HTTP_USER_AGENT'].$securitySeed) {\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Clear the security token from the session.\n     */\n    public static function clear_token(string $prefix = '')\n    {\n        $secTokenVariable = self::generateSecTokenVariable($prefix);\n\n        Session::erase($secTokenVariable);\n    }\n\n    /**\n     * This function sets a random token to be included in a form as a hidden field\n     * and saves it into the user's session. Returns an HTML form element\n     * This later prevents Cross-Site Request Forgeries by checking that the user is really\n     * the one that sent this form in knowingly (this form hasn't been generated from\n     * another website visited by the user at the same time).\n     * Check the token with check_token().\n     *\n     * @return string Hidden-type input ready to insert into a form\n     */\n    public static function get_HTML_token(string $prefix = '')\n    {\n        $secTokenVariable = self::generateSecTokenVariable($prefix);\n        $token = md5(uniqid(rand(), true));\n        $string = '<input type=\"hidden\" name=\"'.$secTokenVariable.'\" value=\"'.$token.'\" />';\n        Session::write($secTokenVariable, $token);\n\n        return $string;\n    }\n\n    /**\n     * This function sets a random token to be included in a form as a hidden field\n     * and saves it into the user's session.\n     * This later prevents Cross-Site Request Forgeries by checking that the user is really\n     * the one that sent this form in knowingly (this form hasn't been generated from\n     * another website visited by the user at the same time).\n     * Check the token with check_token().\n     *\n     * @return string Token\n     */\n    public static function get_token($prefix = '')\n    {\n        $secTokenVariable = self::generateSecTokenVariable($prefix);\n        $token = md5(uniqid(rand(), true));\n        Session::write($secTokenVariable, $token);\n\n        return $token;\n    }\n\n    /**\n     * @return string\n     */\n    public static function get_existing_token(string $prefix = '')\n    {\n        $secTokenVariable = self::generateSecTokenVariable($prefix);\n        $token = Session::read($secTokenVariable);\n        if (!empty($token)) {\n            return $token;\n        } else {\n            return self::get_token($prefix);\n        }\n    }\n\n    /**\n     * Gets the user agent in the session to later check it with check_ua() to prevent\n     * most cases of session hijacking.\n     */\n    public static function get_ua()\n    {\n        $seed = uniqid(rand(), true);\n        Session::write('sec_ua_seed', $seed);\n        Session::write('sec_ua', $_SERVER['HTTP_USER_AGENT'].$seed);\n    }\n\n    /**\n     * This function returns a variable from the clean array. If the variable doesn't exist,\n     * it returns null.\n     *\n     * @param string    Variable name\n     *\n     * @return mixed Variable or NULL on error\n     */\n    public static function get($varname)\n    {\n        if (isset(self::$clean[$varname])) {\n            return self::$clean[$varname];\n        }\n\n        return null;\n    }\n\n    /**\n     * This function tackles the XSS injections.\n     * Filtering for XSS is very easily done by using the htmlentities() function.\n     * This kind of filtering prevents JavaScript snippets to be understood as such.\n     *\n     * @param string The variable to filter for XSS, this params can be a string or an array (example : array(x,y))\n     * @param int The user status,constant allowed (STUDENT, COURSEMANAGER, ANONYMOUS, COURSEMANAGERLOWSECURITY)\n     * @param bool $filter_terms\n     *\n     * @return mixed Filtered string or array\n     */\n    public static function remove_XSS($var, $user_status = null, $filter_terms = false)\n    {\n        if ($filter_terms) {\n            $var = self::filter_terms($var);\n        }\n\n        if (empty($user_status)) {\n            if (api_is_anonymous()) {\n                $user_status = ANONYMOUS;\n            } else {\n                if (api_is_allowed_to_edit()) {\n                    $user_status = COURSEMANAGER;\n                } else {\n                    $user_status = STUDENT;\n                }\n            }\n        }\n\n        if ($user_status == COURSEMANAGERLOWSECURITY) {\n            return $var; // No filtering.\n        }\n\n        static $purifier = [];\n        if (!isset($purifier[$user_status])) {\n            $cache_dir = api_get_path(SYS_ARCHIVE_PATH).'Serializer';\n            if (!file_exists($cache_dir)) {\n                $mode = api_get_permissions_for_new_directories();\n                mkdir($cache_dir, $mode);\n            }\n            $config = HTMLPurifier_Config::createDefault();\n            $config->set('Cache.SerializerPath', $cache_dir);\n            $config->set('Core.Encoding', api_get_system_encoding());\n            $config->set('HTML.Doctype', 'XHTML 1.0 Transitional');\n            $config->set('HTML.MaxImgLength', '2560');\n            $config->set('HTML.TidyLevel', 'light');\n            $config->set('Core.ConvertDocumentToFragment', false);\n            $config->set('Core.RemoveProcessingInstructions', true);\n\n            if (api_get_setting('enable_iframe_inclusion') == 'true') {\n                $config->set('Filter.Custom', [new AllowIframes()]);\n            }\n\n            // Shows _target attribute in anchors\n            $config->set('Attr.AllowedFrameTargets', ['_blank', '_top', '_self', '_parent']);\n\n            if ($user_status == STUDENT) {\n                global $allowed_html_student;\n                $config->set('HTML.SafeEmbed', true);\n                $config->set('HTML.SafeObject', true);\n                $config->set('Filter.YouTube', true);\n                $config->set('HTML.FlashAllowFullScreen', true);\n                $config->set('HTML.Allowed', $allowed_html_student);\n            } elseif ($user_status == COURSEMANAGER) {\n                global $allowed_html_teacher;\n                $config->set('HTML.SafeEmbed', true);\n                $config->set('HTML.SafeObject', true);\n                $config->set('Filter.YouTube', true);\n                $config->set('HTML.FlashAllowFullScreen', true);\n                $config->set('HTML.Allowed', $allowed_html_teacher);\n            } else {\n                global $allowed_html_anonymous;\n                $config->set('HTML.Allowed', $allowed_html_anonymous);\n            }\n\n            // We need it for example for the flv player (ids of surrounding div-tags have to be preserved).\n            $config->set('Attr.EnableID', true);\n            $config->set('CSS.AllowImportant', true);\n            // We need for the flv player the css definition display: none;\n            $config->set('CSS.AllowTricky', true);\n            $config->set('CSS.Proprietary', true);\n\n            // Allow uri scheme.\n            $config->set('URI.AllowedSchemes', [\n                'http' => true,\n                'https' => true,\n                'mailto' => true,\n                'ftp' => true,\n                'nntp' => true,\n                'news' => true,\n                'data' => true,\n            ]);\n\n            // Allow <video> tag\n            //$config->set('HTML.Doctype', 'HTML 4.01 Transitional');\n            $config->set('HTML.SafeIframe', true);\n\n            // Set some HTML5 properties\n            $config->set('HTML.DefinitionID', 'html5-definitions'); // unqiue id\n            $config->set('HTML.DefinitionRev', 1);\n            if ($def = $config->maybeGetRawHTMLDefinition()) {\n                // https://html.spec.whatwg.org/dev/media.html#the-video-element\n                $def->addElement(\n                    'video',\n                    'Block',\n                    'Optional: (source, Flow) | (Flow, source) | Flow',\n                    'Common',\n                    [\n                        'src' => 'URI',\n                        'type' => 'Text',\n                        'width' => 'Length',\n                        'height' => 'Length',\n                        'poster' => 'URI',\n                        'preload' => 'Enum#auto,metadata,none',\n                        'controls' => 'Bool',\n                    ]\n                );\n                // https://html.spec.whatwg.org/dev/media.html#the-audio-element\n                $def->addElement(\n                    'audio',\n                    'Block',\n                    'Optional: (source, Flow) | (Flow, source) | Flow',\n                    'Common',\n                    [\n                        'autoplay' => 'Bool',\n                        'src' => 'URI',\n                        'loop' => 'Bool',\n                        'preload' => 'Enum#auto,metadata,none',\n                        'controls' => 'Bool',\n                        'muted' => 'Bool',\n                    ]\n                );\n                $def->addElement(\n                    'source',\n                    'Block',\n                    'Flow',\n                    'Common',\n                    ['src' => 'URI', 'type' => 'Text']\n                );\n            }\n\n            $purifier[$user_status] = new HTMLPurifier($config);\n        }\n\n        if (is_array($var)) {\n            return $purifier[$user_status]->purifyArray($var);\n        } else {\n            return $purifier[$user_status]->purify($var);\n        }\n    }\n\n    /**\n     * Filter content.\n     *\n     * @param string $text to be filter\n     *\n     * @return string\n     */\n    public static function filter_terms($text)\n    {\n        static $bad_terms = [];\n\n        if (empty($bad_terms)) {\n            $list = api_get_setting('filter_terms');\n            if (!empty($list)) {\n                $list = explode(\"\\n\", $list);\n                $list = array_filter($list);\n                if (!empty($list)) {\n                    foreach ($list as $term) {\n                        $term = str_replace([\"\\r\\n\", \"\\r\", \"\\n\", \"\\t\"], '', $term);\n                        $html_entities_value = api_htmlentities($term, ENT_QUOTES, api_get_system_encoding());\n                        $bad_terms[] = $term;\n                        if ($term != $html_entities_value) {\n                            $bad_terms[] = $html_entities_value;\n                        }\n                    }\n                }\n                $bad_terms = array_filter($bad_terms);\n            }\n        }\n\n        $replace = '***';\n        if (!empty($bad_terms)) {\n            // Fast way\n            $new_text = str_ireplace($bad_terms, $replace, $text, $count);\n            $text = $new_text;\n        }\n\n        return $text;\n    }\n\n    /**\n     * This method provides specific protection (against XSS and other kinds of attacks)\n     * for static images (icons) used by the system.\n     * Image paths are supposed to be given by programmers - people who know what they do, anyway,\n     * this method encourages a safe practice for generating icon paths, without using heavy solutions\n     * based on HTMLPurifier for example.\n     *\n     * @param string $image_path the input path of the image, it could be relative or absolute URL\n     *\n     * @return string returns sanitized image path or an empty string when the image path is not secure\n     *\n     * @author Ivan Tcholakov, March 2011\n     */\n    public static function filter_img_path($image_path)\n    {\n        static $allowed_extensions = ['png', 'gif', 'jpg', 'jpeg', 'svg', 'webp'];\n        $image_path = htmlspecialchars(trim($image_path)); // No html code is allowed.\n        // We allow static images only, query strings are forbidden.\n        if (strpos($image_path, '?') !== false) {\n            return '';\n        }\n        if (($pos = strpos($image_path, ':')) !== false) {\n            // Protocol has been specified, let's check it.\n            if (stripos($image_path, 'javascript:') !== false) {\n                // Javascript everywhere in the path is not allowed.\n                return '';\n            }\n            // We allow only http: and https: protocols for now.\n            //if (!preg_match('/^https?:\\/\\//i', $image_path)) {\n            //    return '';\n            //}\n            if (stripos($image_path, 'http://') !== 0 && stripos($image_path, 'https://') !== 0) {\n                return '';\n            }\n        }\n        // We allow file extensions for images only.\n        //if (!preg_match('/.+\\.(png|gif|jpg|jpeg)$/i', $image_path)) {\n        //    return '';\n        //}\n        if (($pos = strrpos($image_path, '.')) !== false) {\n            if (!in_array(strtolower(substr($image_path, $pos + 1)), $allowed_extensions)) {\n                return '';\n            }\n        } else {\n            return '';\n        }\n\n        return $image_path;\n    }\n\n    /**\n     * Get password requirements\n     * It checks config value 'password_requirements' or uses the \"classic\"\n     * Chamilo password requirements.\n     *\n     * @return array\n     */\n    public static function getPasswordRequirements()\n    {\n        // Default\n        $requirements = [\n            'min' => [\n                'lowercase' => 0,\n                'uppercase' => 0,\n                'numeric' => 2,\n                'length' => 5,\n                'specials' => 1,\n            ],\n        ];\n\n        $passwordRequirements = api_get_configuration_value('password_requirements');\n        if (!empty($passwordRequirements)) {\n            $requirements = $passwordRequirements;\n        }\n\n        return ['min' => $requirements['min']];\n    }\n\n    /**\n     * Gets password requirements in the platform language using get_lang\n     * based in platform settings. See function 'self::getPasswordRequirements'.\n     */\n    public static function getPasswordRequirementsToString(array $evaluatedConditions = []): string\n    {\n        $output = '';\n        $setting = self::getPasswordRequirements();\n\n        $passedIcon = Display::returnFontAwesomeIcon(\n            'check',\n            '',\n            true,\n            'text-success',\n            get_lang('PasswordRequirementPassed')\n        );\n        $pendingIcon = Display::returnFontAwesomeIcon(\n            'times',\n            '',\n            true,\n            'text-danger',\n            get_lang('PasswordRequirementPending')\n        );\n\n        foreach ($setting as $type => $rules) {\n            foreach ($rules as $rule => $parameter) {\n                if (empty($parameter)) {\n                    continue;\n                }\n\n                $evaluatedCondition = $type.'_'.$rule;\n                $icon = $passedIcon;\n\n                if (array_key_exists($evaluatedCondition, $evaluatedConditions)\n                    && false === $evaluatedConditions[$evaluatedCondition]\n                ) {\n                    $icon = $pendingIcon;\n                }\n\n                $output .= empty($evaluatedConditions) ? '' : $icon;\n                $output .= sprintf(\n                    get_lang(\n                        'NewPasswordRequirement'.ucfirst($type).'X'.ucfirst($rule)\n                    ),\n                    $parameter\n                );\n                $output .= '<br />';\n            }\n        }\n\n        return $output;\n    }\n\n    /**\n     * Sanitize a string, so it can be used in the exec() command without\n     * \"jail-breaking\" to execute other commands.\n     *\n     * @param string $param The string to filter\n     */\n    public static function sanitizeExecParam(string $param): string\n    {\n        $param = preg_replace('/[`;&|]/', '', $param);\n\n        return escapeshellarg($param);\n    }\n\n    private static function generateSecTokenVariable(string $prefix = ''): string\n    {\n        if (empty($prefix)) {\n            return 'sec_token';\n        }\n\n        return $prefix.'_sec_token';\n    }\n}\n", "<?php\n/* For licensing terms, see /license.txt */\n/**\n * @package chamilo.webservices\n *\n * @author Francis Gonzales\n */\nrequire_once __DIR__.'/../inc/global.inc.php';\n\napi_protect_webservices();\n\n/**\n * Function to convert from ppt to png\n * This function is used from Chamilo Rapid Lesson.\n *\n * @param array $pptData\n *\n * @return string\n */\nfunction wsConvertPpt($pptData)\n{\n    global $_configuration;\n    $ip = trim($_SERVER['REMOTE_ADDR']);\n    // If an IP filter array is defined in configuration.php,\n    // check if this IP is allowed\n    if (!empty($_configuration['ppt2lp_ip_filter'])) {\n        if (!in_array($ip, $_configuration['ppt2lp_ip_filter'])) {\n            return false;\n        }\n    }\n    $fileData = $pptData['file_data'];\n    // Clean filename to avoid hacks. Prevents \"&\" and \";\" to be used in filename, notably\n\n    if (strpos($pptData['file_name'], '..') !== false) {\n        return false;\n    }\n\n    $sanitizedFileName = $pptData['file_name'];\n    $dataInfo = pathinfo($sanitizedFileName);\n    $fileName = basename($sanitizedFileName, '.'.$dataInfo['extension']);\n    // Add additional cleaning of .php and .htaccess files\n    $fullFileName = Security::filter_filename($sanitizedFileName);\n    $size = $pptData['service_ppt2lp_size'];\n    $w = '800';\n    $h = '600';\n    if (!empty($size)) {\n        list($w, $h) = explode('x', $size);\n    }\n\n    $w = (int) $w;\n    $h = (int) $h;\n\n    $tempArchivePath = api_get_path(SYS_ARCHIVE_PATH);\n    $tempPath = $tempArchivePath.'wsConvert/'.$fileName.'/';\n    $tempPathNewFiles = $tempArchivePath.'wsConvert/'.$fileName.'-n/';\n\n    $oldumask = umask(0);\n    //$perms = api_get_permissions_for_new_directories();\n    // Set permissions the most permissively possible: these files will\n    // be deleted below and we need a parallel process to be able to write them\n    $perms = api_get_permissions_for_new_directories();\n    pptConverterDirectoriesCreate($tempPath, $tempPathNewFiles, $fileName, $perms);\n\n    $file = base64_decode($fileData);\n    file_put_contents($tempPath.$fullFileName, $file);\n\n    $cmd = pptConverterGetCommandBaseParams(\n        $w,\n        $h,\n        $tempPath.$fullFileName,\n        $tempPathNewFiles.$fileName.'.html'\n    );\n\n    //$perms = api_get_permissions_for_new_files();\n    chmod($tempPathNewFiles.$fileName, $perms);\n\n    $files = [];\n    $return = 0;\n    $shell = exec($cmd, $files, $return);\n    umask($oldumask);\n\n    if ($return === 0) {\n        $images = [];\n        if (is_array($files) && !empty($files)) {\n            foreach ($files as $file) {\n                $imageData = explode('||', $file);\n                $images[$imageData[1]] = base64_encode(file_get_contents($tempPathNewFiles.$fileName.'/'.$imageData[1]));\n            }\n        }\n        $data = [\n            'files' => $files,\n            'images' => $images,\n        ];\n\n        deleteDirectory($tempPath);\n        deleteDirectory($tempPathNewFiles);\n\n        return serialize($data);\n    } else {\n        deleteDirectory($tempPath);\n        deleteDirectory($tempPathNewFiles);\n\n        return false;\n    }\n}\n\n/**\n * @param $directoryPath\n *\n * @return bool\n */\nfunction deleteDirectory($directoryPath)\n{\n    $files = array_diff(scandir($directoryPath), ['.', '..']);\n    foreach ($files as $file) {\n        if (is_dir(\"$directoryPath/$file\")) {\n            deleteDirectory(\"$directoryPath/$file\");\n        } else {\n            unlink(\"$directoryPath/$file\");\n        }\n    }\n\n    return rmdir($directoryPath);\n}\n\n/**\n * Helper function to create the directory structure for the PPT converter.\n *\n * @param string $tempPath\n * @param string $tempPathNewFiles\n * @param string $fileName\n * @param string $perms\n */\nfunction pptConverterDirectoriesCreate($tempPath, $tempPathNewFiles, $fileName, $perms)\n{\n    if (!is_dir($tempPath)) {\n        mkdir($tempPath, $perms, true);\n    }\n    if (!is_dir($tempPathNewFiles)) {\n        mkdir($tempPathNewFiles, $perms, true);\n    }\n    if (!is_dir($tempPathNewFiles.$fileName)) {\n        mkdir($tempPathNewFiles.$fileName, $perms, true);\n    }\n}\n\n/**\n * Helper function to build the command line parameters for the converter.\n *\n * @return string $cmd\n */\nfunction pptConverterGetCommandBaseParams(int $w, int $h, string $inputPath, string $outputPath)\n{\n    $cd = '';\n\n    if (IS_WINDOWS_OS) { // IS_WINDOWS_OS has been defined in main_api.lib.php\n        $converterPath = str_replace('/', '\\\\', api_get_path(SYS_PATH).'main/inc/lib/ppt2png');\n        $classPath = $converterPath.';'.$converterPath.'/jodconverter-2.2.2.jar;'.$converterPath.'/jodconverter-cli-2.2.2.jar';\n        $cmd = 'java -Dfile.encoding=UTF-8 -cp \"'.$classPath.'\"';\n    } else {\n        $converterPath = api_get_path(SYS_PATH).'main/inc/lib/ppt2png';\n        $classPath = ' -Dfile.encoding=UTF-8 -cp .:jodconverter-2.2.2.jar:jodconverter-cli-2.2.2.jar';\n        $cd = 'cd '.$converterPath.' && ';\n        $cmd = 'java '.$classPath;\n    }\n\n    $cmd .= ' DokeosConverter';\n    $cmd .= ' -p '.api_get_setting('service_ppt2lp', 'port');\n    $cmd .= ' -w '.$w.' -h '.$h;\n    $cmd .= ' -d oogie '.Security::sanitizeExecParam($inputPath).' '.Security::sanitizeExecParam($outputPath);\n\n    return $cd.escapeshellcmd($cmd);\n}\n\n$uri = api_get_path(WEB_CODE_PATH).'webservices/';\n$server = new SoapServer(null, ['uri' => $uri]);\n$server->addFunction(\"wsConvertPpt\");\n$server->handle();\n"], "filenames": ["main/inc/lib/security.lib.php", "main/webservices/additional_webservices.php"], "buggy_code_start_loc": [635, 33], "buggy_code_end_loc": [636, 155], "fixing_code_start_loc": [635, 33], "fixing_code_end_loc": [638, 173], "type": "CWE-22", "message": "Path traversal in file upload functionality in `/main/webservices/additional_webservices.php` in Chamilo LMS <= v1.11.20 allows unauthenticated attackers to perform stored cross-site scripting attacks and obtain remote code execution via arbitrary file write.", "other": {"cve": {"id": "CVE-2023-3533", "sourceIdentifier": "info@starlabs.sg", "published": "2023-11-28T07:15:42.377", "lastModified": "2023-12-05T19:08:09.277", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Path traversal in file upload functionality in `/main/webservices/additional_webservices.php` in Chamilo LMS <= v1.11.20 allows unauthenticated attackers to perform stored cross-site scripting attacks and obtain remote code execution via arbitrary file write."}, {"lang": "es", "value": "Path Traversal en la funcionalidad de carga de archivos en `/main/webservices/additional_webservices.php` en Chamilo LMS en versiones &lt;= 1.11.20 permite a atacantes no autenticados realizar ataques de Cross Site Scripting Almacenados y obtener ejecuci\u00f3n remota de c\u00f3digo mediante escritura de archivos arbitrarios."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}, {"source": "info@starlabs.sg", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-22"}]}, {"source": "info@starlabs.sg", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-22"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:chamilo:chamilo:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.11.20", "matchCriteriaId": "FF883FF3-A05D-4939-9777-9FCC16A9AFBB"}]}]}], "references": [{"url": "https://github.com/chamilo/chamilo-lms/commit/37be9ce7243a30259047dd4517c48ff8b21d657a", "source": "info@starlabs.sg", "tags": ["Patch"]}, {"url": "https://starlabs.sg/advisories/23/23-3533/", "source": "info@starlabs.sg", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://support.chamilo.org/projects/chamilo-18/wiki/security_issues#Issue-124-2023-07-13-Critical-impact-High-risk-Unauthenticated-Arbitrary-File-Write-RCE-CVE-2023-3533", "source": "info@starlabs.sg", "tags": ["Issue Tracking", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/chamilo/chamilo-lms/commit/37be9ce7243a30259047dd4517c48ff8b21d657a"}}