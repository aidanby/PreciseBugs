{"buggy_code": ["class ConversationFinder\n  attr_reader :current_user, :current_account, :params\n\n  DEFAULT_STATUS = 'open'.freeze\n\n  # assumptions\n  # inbox_id if not given, take from all conversations, else specific to inbox\n  # assignee_type if not given, take 'all'\n  # conversation_status if not given, take 'open'\n\n  # response of this class will be of type\n  # {conversations: [array of conversations], count: {open: count, resolved: count}}\n\n  # params\n  # assignee_type, inbox_id, :status\n\n  def initialize(current_user, params)\n    @current_user = current_user\n    @current_account = current_user.account\n    @params = params\n  end\n\n  def perform\n    set_up\n\n    mine_count, unassigned_count, all_count, = set_count_for_all_conversations\n    assigned_count = all_count - unassigned_count\n\n    filter_by_assignee_type\n\n    {\n      conversations: conversations,\n      count: {\n        mine_count: mine_count,\n        assigned_count: assigned_count,\n        unassigned_count: unassigned_count,\n        all_count: all_count\n      }\n    }\n  end\n\n  private\n\n  def set_up\n    set_inboxes\n    set_team\n    set_assignee_type\n\n    find_all_conversations\n    filter_by_status unless params[:q]\n    filter_by_team if @team\n    filter_by_labels if params[:labels]\n    filter_by_query if params[:q]\n  end\n\n  def set_inboxes\n    @inbox_ids = if params[:inbox_id]\n                   current_account.inboxes.where(id: params[:inbox_id])\n                 else\n                   @current_user.assigned_inboxes.pluck(:id)\n                 end\n  end\n\n  def set_assignee_type\n    @assignee_type = params[:assignee_type]\n  end\n\n  def set_team\n    @team = current_account.teams.find(params[:team_id]) if params[:team_id]\n  end\n\n  def find_all_conversations\n    if params[:conversation_type] == 'mention'\n      conversation_ids = current_account.mentions.where(user: current_user).pluck(:conversation_id)\n      @conversations = current_account.conversations.where(id: conversation_ids)\n    else\n      @conversations = current_account.conversations.where(inbox_id: @inbox_ids)\n    end\n  end\n\n  def filter_by_assignee_type\n    case @assignee_type\n    when 'me'\n      @conversations = @conversations.assigned_to(current_user)\n    when 'unassigned'\n      @conversations = @conversations.unassigned\n    when 'assigned'\n      @conversations = @conversations.assigned\n    end\n    @conversations\n  end\n\n  def filter_by_query\n    allowed_message_types = [Message.message_types[:incoming], Message.message_types[:outgoing]]\n    @conversations = conversations.joins(:messages).where('messages.content ILIKE :search', search: \"%#{params[:q]}%\")\n                                  .where(messages: { message_type: allowed_message_types }).includes(:messages)\n                                  .where('messages.content ILIKE :search', search: \"%#{params[:q]}%\")\n                                  .where(messages: { message_type: allowed_message_types })\n  end\n\n  def filter_by_status\n    return if params[:status] == 'all'\n\n    @conversations = @conversations.where(status: params[:status] || DEFAULT_STATUS)\n  end\n\n  def filter_by_team\n    @conversations = @conversations.where(team: @team)\n  end\n\n  def filter_by_labels\n    @conversations = @conversations.tagged_with(params[:labels], any: true)\n  end\n\n  def set_count_for_all_conversations\n    [\n      @conversations.assigned_to(current_user).count,\n      @conversations.unassigned.count,\n      @conversations.count\n    ]\n  end\n\n  def current_page\n    params[:page] || 1\n  end\n\n  def conversations\n    @conversations = @conversations.includes(\n      :taggings, :inbox, { assignee: { avatar_attachment: [:blob] } }, { contact: { avatar_attachment: [:blob] } }, :team, :contact_inbox\n    )\n    if params[:conversation_type] == 'mention'\n      @conversations.page(current_page)\n    else\n      @conversations.latest.page(current_page)\n    end\n  end\nend\n", "require 'rails_helper'\n\ndescribe ::ConversationFinder do\n  subject(:conversation_finder) { described_class.new(user_1, params) }\n\n  let!(:account) { create(:account) }\n  let!(:user_1) { create(:user, account: account) }\n  let!(:user_2) { create(:user, account: account) }\n  let!(:inbox) { create(:inbox, account: account, enable_auto_assignment: false) }\n\n  before do\n    create(:inbox_member, user: user_1, inbox: inbox)\n    create(:inbox_member, user: user_2, inbox: inbox)\n    create(:conversation, account: account, inbox: inbox, assignee: user_1)\n    create(:conversation, account: account, inbox: inbox, assignee: user_1)\n    create(:conversation, account: account, inbox: inbox, assignee: user_1, status: 'resolved')\n    create(:conversation, account: account, inbox: inbox, assignee: user_2)\n    # unassigned conversation\n    create(:conversation, account: account, inbox: inbox)\n    Current.account = account\n  end\n\n  describe '#perform' do\n    context 'with status' do\n      let(:params) { { status: 'open', assignee_type: 'me' } }\n\n      it 'filter conversations by status' do\n        result = conversation_finder.perform\n        expect(result[:conversations].length).to be 2\n      end\n    end\n\n    context 'with assignee_type all' do\n      let(:params) { { assignee_type: 'all' } }\n\n      it 'filter conversations by assignee type all' do\n        result = conversation_finder.perform\n        expect(result[:conversations].length).to be 4\n      end\n    end\n\n    context 'with assignee_type unassigned' do\n      let(:params) { { assignee_type: 'unassigned' } }\n\n      it 'filter conversations by assignee type unassigned' do\n        result = conversation_finder.perform\n        expect(result[:conversations].length).to be 1\n      end\n    end\n\n    context 'with status all' do\n      let(:params) { { status: 'all' } }\n\n      it 'returns all conversations' do\n        result = conversation_finder.perform\n        expect(result[:conversations].length).to be 5\n      end\n    end\n\n    context 'with assignee_type assigned' do\n      let(:params) { { assignee_type: 'assigned' } }\n\n      it 'filter conversations by assignee type assigned' do\n        result = conversation_finder.perform\n        expect(result[:conversations].length).to be 3\n      end\n\n      it 'returns the correct meta' do\n        result = conversation_finder.perform\n        expect(result[:count]).to eq({\n                                       mine_count: 2,\n                                       assigned_count: 3,\n                                       unassigned_count: 1,\n                                       all_count: 4\n                                     })\n      end\n    end\n\n    context 'with team' do\n      let(:team) { create(:team, account: account) }\n      let(:params) { { team_id: team.id } }\n\n      it 'filter conversations by team' do\n        create(:conversation, account: account, inbox: inbox, team: team)\n        result = conversation_finder.perform\n        expect(result[:conversations].length).to be 1\n      end\n    end\n\n    context 'with labels' do\n      let(:params) { { labels: ['resolved'] } }\n\n      it 'filter conversations by labels' do\n        conversation = inbox.conversations.first\n        conversation.update_labels('resolved')\n\n        result = conversation_finder.perform\n        expect(result[:conversations].length).to be 1\n      end\n    end\n\n    context 'with pagination' do\n      let(:params) { { status: 'open', assignee_type: 'me', page: 1 } }\n\n      it 'returns paginated conversations' do\n        create_list(:conversation, 50, account: account, inbox: inbox, assignee: user_1)\n        result = conversation_finder.perform\n        expect(result[:conversations].length).to be 25\n      end\n    end\n  end\nend\n"], "fixing_code": ["class ConversationFinder\n  attr_reader :current_user, :current_account, :params\n\n  DEFAULT_STATUS = 'open'.freeze\n\n  # assumptions\n  # inbox_id if not given, take from all conversations, else specific to inbox\n  # assignee_type if not given, take 'all'\n  # conversation_status if not given, take 'open'\n\n  # response of this class will be of type\n  # {conversations: [array of conversations], count: {open: count, resolved: count}}\n\n  # params\n  # assignee_type, inbox_id, :status\n\n  def initialize(current_user, params)\n    @current_user = current_user\n    @current_account = current_user.account\n    @params = params\n  end\n\n  def perform\n    set_up\n\n    mine_count, unassigned_count, all_count, = set_count_for_all_conversations\n    assigned_count = all_count - unassigned_count\n\n    filter_by_assignee_type\n\n    {\n      conversations: conversations,\n      count: {\n        mine_count: mine_count,\n        assigned_count: assigned_count,\n        unassigned_count: unassigned_count,\n        all_count: all_count\n      }\n    }\n  end\n\n  private\n\n  def set_up\n    set_inboxes\n    set_team\n    set_assignee_type\n\n    find_all_conversations\n    filter_by_status unless params[:q]\n    filter_by_team if @team\n    filter_by_labels if params[:labels]\n    filter_by_query if params[:q]\n  end\n\n  def set_inboxes\n    @inbox_ids = if params[:inbox_id]\n                   @current_user.assigned_inboxes.where(id: params[:inbox_id])\n                 else\n                   @current_user.assigned_inboxes.pluck(:id)\n                 end\n  end\n\n  def set_assignee_type\n    @assignee_type = params[:assignee_type]\n  end\n\n  def set_team\n    @team = current_account.teams.find(params[:team_id]) if params[:team_id]\n  end\n\n  def find_all_conversations\n    if params[:conversation_type] == 'mention'\n      conversation_ids = current_account.mentions.where(user: current_user).pluck(:conversation_id)\n      @conversations = current_account.conversations.where(id: conversation_ids)\n    else\n      @conversations = current_account.conversations.where(inbox_id: @inbox_ids)\n    end\n  end\n\n  def filter_by_assignee_type\n    case @assignee_type\n    when 'me'\n      @conversations = @conversations.assigned_to(current_user)\n    when 'unassigned'\n      @conversations = @conversations.unassigned\n    when 'assigned'\n      @conversations = @conversations.assigned\n    end\n    @conversations\n  end\n\n  def filter_by_query\n    allowed_message_types = [Message.message_types[:incoming], Message.message_types[:outgoing]]\n    @conversations = conversations.joins(:messages).where('messages.content ILIKE :search', search: \"%#{params[:q]}%\")\n                                  .where(messages: { message_type: allowed_message_types }).includes(:messages)\n                                  .where('messages.content ILIKE :search', search: \"%#{params[:q]}%\")\n                                  .where(messages: { message_type: allowed_message_types })\n  end\n\n  def filter_by_status\n    return if params[:status] == 'all'\n\n    @conversations = @conversations.where(status: params[:status] || DEFAULT_STATUS)\n  end\n\n  def filter_by_team\n    @conversations = @conversations.where(team: @team)\n  end\n\n  def filter_by_labels\n    @conversations = @conversations.tagged_with(params[:labels], any: true)\n  end\n\n  def set_count_for_all_conversations\n    [\n      @conversations.assigned_to(current_user).count,\n      @conversations.unassigned.count,\n      @conversations.count\n    ]\n  end\n\n  def current_page\n    params[:page] || 1\n  end\n\n  def conversations\n    @conversations = @conversations.includes(\n      :taggings, :inbox, { assignee: { avatar_attachment: [:blob] } }, { contact: { avatar_attachment: [:blob] } }, :team, :contact_inbox\n    )\n    if params[:conversation_type] == 'mention'\n      @conversations.page(current_page)\n    else\n      @conversations.latest.page(current_page)\n    end\n  end\nend\n", "require 'rails_helper'\n\ndescribe ::ConversationFinder do\n  subject(:conversation_finder) { described_class.new(user_1, params) }\n\n  let!(:account) { create(:account) }\n  let!(:user_1) { create(:user, account: account) }\n  let!(:user_2) { create(:user, account: account) }\n  let!(:admin) { create(:user, account: account, role: :administrator) }\n  let!(:inbox) { create(:inbox, account: account, enable_auto_assignment: false) }\n  let!(:restricted_inbox) { create(:inbox, account: account) }\n\n  before do\n    create(:inbox_member, user: user_1, inbox: inbox)\n    create(:inbox_member, user: user_2, inbox: inbox)\n    create(:conversation, account: account, inbox: inbox, assignee: user_1)\n    create(:conversation, account: account, inbox: inbox, assignee: user_1)\n    create(:conversation, account: account, inbox: inbox, assignee: user_1, status: 'resolved')\n    create(:conversation, account: account, inbox: inbox, assignee: user_2)\n    # unassigned conversation\n    create(:conversation, account: account, inbox: inbox)\n    Current.account = account\n  end\n\n  describe '#perform' do\n    context 'with status' do\n      let(:params) { { status: 'open', assignee_type: 'me' } }\n\n      it 'filter conversations by status' do\n        result = conversation_finder.perform\n        expect(result[:conversations].length).to be 2\n      end\n    end\n\n    context 'with inbox' do\n      let!(:restricted_conversation) { create(:conversation, account: account, inbox_id: restricted_inbox.id) }\n\n      it 'returns conversation from any inbox if its admin' do\n        params = { inbox_id: restricted_inbox.id }\n        result = described_class.new(admin, params).perform\n\n        expect(result[:conversations].map(&:id)).to include(restricted_conversation.id)\n      end\n\n      it 'returns conversation from inbox if agent is its member' do\n        params = { inbox_id: restricted_inbox.id }\n        create(:inbox_member, user: user_1, inbox: restricted_inbox)\n        result = described_class.new(user_1, params).perform\n\n        expect(result[:conversations].map(&:id)).to include(restricted_conversation.id)\n      end\n\n      it 'does not return conversations from inboxes where agent is not a member' do\n        params = { inbox_id: restricted_inbox.id }\n        result = described_class.new(user_1, params).perform\n\n        expect(result[:conversations].map(&:id)).not_to include(restricted_conversation.id)\n      end\n    end\n\n    context 'with assignee_type all' do\n      let(:params) { { assignee_type: 'all' } }\n\n      it 'filter conversations by assignee type all' do\n        result = conversation_finder.perform\n        expect(result[:conversations].length).to be 4\n      end\n    end\n\n    context 'with assignee_type unassigned' do\n      let(:params) { { assignee_type: 'unassigned' } }\n\n      it 'filter conversations by assignee type unassigned' do\n        result = conversation_finder.perform\n        expect(result[:conversations].length).to be 1\n      end\n    end\n\n    context 'with status all' do\n      let(:params) { { status: 'all' } }\n\n      it 'returns all conversations' do\n        result = conversation_finder.perform\n        expect(result[:conversations].length).to be 5\n      end\n    end\n\n    context 'with assignee_type assigned' do\n      let(:params) { { assignee_type: 'assigned' } }\n\n      it 'filter conversations by assignee type assigned' do\n        result = conversation_finder.perform\n        expect(result[:conversations].length).to be 3\n      end\n\n      it 'returns the correct meta' do\n        result = conversation_finder.perform\n        expect(result[:count]).to eq({\n                                       mine_count: 2,\n                                       assigned_count: 3,\n                                       unassigned_count: 1,\n                                       all_count: 4\n                                     })\n      end\n    end\n\n    context 'with team' do\n      let(:team) { create(:team, account: account) }\n      let(:params) { { team_id: team.id } }\n\n      it 'filter conversations by team' do\n        create(:conversation, account: account, inbox: inbox, team: team)\n        result = conversation_finder.perform\n        expect(result[:conversations].length).to be 1\n      end\n    end\n\n    context 'with labels' do\n      let(:params) { { labels: ['resolved'] } }\n\n      it 'filter conversations by labels' do\n        conversation = inbox.conversations.first\n        conversation.update_labels('resolved')\n\n        result = conversation_finder.perform\n        expect(result[:conversations].length).to be 1\n      end\n    end\n\n    context 'with pagination' do\n      let(:params) { { status: 'open', assignee_type: 'me', page: 1 } }\n\n      it 'returns paginated conversations' do\n        create_list(:conversation, 50, account: account, inbox: inbox, assignee: user_1)\n        result = conversation_finder.perform\n        expect(result[:conversations].length).to be 25\n      end\n    end\n  end\nend\n"], "filenames": ["app/finders/conversation_finder.rb", "spec/finders/conversation_finder_spec.rb"], "buggy_code_start_loc": [58, 8], "buggy_code_end_loc": [59, 29], "fixing_code_start_loc": [58, 9], "fixing_code_end_loc": [59, 58], "type": "CWE-639", "message": "Improper Privilege Management in GitHub repository chatwoot/chatwoot prior to v2.2.", "other": {"cve": {"id": "CVE-2021-3813", "sourceIdentifier": "security@huntr.dev", "published": "2022-02-09T15:15:07.977", "lastModified": "2022-10-27T11:53:48.567", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Improper Privilege Management in GitHub repository chatwoot/chatwoot prior to v2.2."}, {"lang": "es", "value": "Una Administraci\u00f3n Inapropiada de Privilegios en el repositorio de GitHub chatwoot/chatwoot versiones anteriores a v2.2"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-639"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-269"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:chatwoot:chatwoot:*:*:*:*:*:*:*:*", "versionEndIncluding": "2.1.1", "matchCriteriaId": "63F871A4-BAE5-45C7-913E-BA49749D4C7A"}]}]}], "references": [{"url": "https://github.com/chatwoot/chatwoot/commit/9454c6b14f75e778ef98cf84bdafdf0ed8ae5705", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/36f02c4f-cf1c-479e-a1ad-091a1ac7cb56", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/chatwoot/chatwoot/commit/9454c6b14f75e778ef98cf84bdafdf0ed8ae5705"}}