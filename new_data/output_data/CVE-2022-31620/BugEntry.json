{"buggy_code": ["This project implements a complete(!) JPEG (Rec. ITU-T T.81 | ISO/IEC\r\n10918-1) codec, plus a library that can be used to encode and decode\r\nJPEG streams.  It also implements ISO/IEC 18477 aka JPEG XT which is\r\nan extension towards intermediate, high-dynamic-range lossy and\r\nlossless coding of JPEG. In specific, it supports ISO/IEC\r\n18477-3/-6/-7/-8/-9 encoding.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nUnlike many other implementations, libjpeg also implements:\r\n\r\n- 12 bpp image coding for the lossy DCT process,\r\n- the predictive lossless mode of Rec. ITU-T T.81 | ISO/IEC 10918-1,\r\n- the hierarchical process of Rec. ITU-T T.81 | ISO/IEC 10918-1,\r\n- the arithmetic coding option of Rec. ITU-T T.81 | ISO/IEC 10918-1,\r\n- coding of up to 256 component images\r\n- upsampling of images for all factors from 1x1 to 4x4\r\n\r\nStandard features are of course also supported, such as\r\nsequential and progressive mode in 8bpp.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nIn addition, this codec provides methods to encode images\r\n\r\n- with a bit depth between 8 and 16 bits per sample, fully backwards\r\n  compatible to Rec. ITU-T T.81 | ISO/IEC 10918 baseline coding.\r\n\r\n- consisting of floating point samples, specifically images with \r\n  high dynamic range.\r\n\r\n- to encode images without loss, regardless of their bit-depth and their\r\n  sample data type.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nExample usage:\r\n\r\nStandard JPEG compression, with 444 (aka \"no\") subsampling:\r\n\r\n$ jpeg -q <quality> infile.ppm outfile.jpg\r\n\r\nStandard JPEG compression, with 422 subsampling:\r\n\r\n$ jpeg -q <quality> -s 1x1,2x2,2x2 infile.ppm outfile.jpg\r\n\r\nIntermediate dynamic range compression, i.e. compression of images\r\nof a bit-depth between 8 and 16 bits:\r\n\r\n$ jpeg -r -q <base-quality> -Q <extension-quality> -h -r12 infile.ppm outfile.jpg\r\n\r\nThis type of encoding uses a technology known as \"residual scans\" which \r\nincrease the bit-depths in the spatial domain which is enabled by the -r\r\ncommand line switch. The -Q parameter sets the quality of the residual image. \r\nTo improve the precision in the frequency domain, \"refinement scans\" can be used. \r\nThe following encodes a 12-bit image with  four additional refinement scans,\r\nenabled by the \"-R 4\" parameter.\r\n\r\n$ jpeg -q <quality> -R 4 -h infile.ppm outfile.jpg\r\n\r\nBoth technologies can be combined, and the precision of the residual scan\r\ncan also be enlarged by using residual refinement scans with the -rR option.\r\nThe following command line with use a 12-bit residual scan with four refinement\r\nscans:\r\n\r\n$ jpeg -r -q <base-quality> -Q <extension-quality> -h -rR 4 infile.ppm outfile.jpg\r\n\r\nHigh-dynamic range compression allows three different profiles of varying\r\ncomplexity and performance. The profiles are denoted by \"-profile <X>\" where\r\n<X> is a,b or c. The following encodes an HDR image in profile C:\r\n\r\n$ jpeg -r -q <base-quality> -Q <extension-quality> -h -profile c -rR 4 infile.pfm outfile.jpg\r\n\r\nHDR images here have to be fed into the command line in \"pfm\" format. \r\nexr or hdr is not supported as input format and requires conversion to \r\npfm first. pfm is the floating-point equivalent of ppm and encodes each\r\npixel by three 32-bit floating point numbers.\r\n\r\nEncoding in profiles a and b works likewise, though it is generally advisable to\r\nuse \"open loop\" rather than \"closed loop\" coding for these two profiles by\r\nadditionally providing the \"-ol\" parameter. This also works for profile C:\r\n\r\n$ jpeg -ol -r -profile a -q <base-quality> -Q <extension-quality> -h infile.pfm out.jpg\r\n\r\nsimilar for profile B.\r\n\r\nWhat is common to profiles A and C is that you may optionally also specify \r\nthe LDR image, i.e. the image that a legacy JPEG decoder will show. By default, \r\na simple tone mapping algorithm (\"global Reinhard\") will be used to derive a\r\nsuitable LDR image from the input image:\r\n\r\n$ jpeg -ldr infile.ppm -q <base-quality> -Q <extension-quality> -h -rR 4 infile.pfm out.jpg\r\n\r\nThe profile is by default profile c, but it also works for profile a:\r\n\r\n$ jpeg -ol profile a -ldr infile.ppm -q <base-quality> -Q <extension-quality> infile.pfm out.jpg\r\n\r\nIt is in general advisable for profile c encoding to enable residual refinement scans,\r\nprofiles a or b do not require them.\r\n\r\n\r\nThe following options exist for lossless coding integer:\r\n\r\npredictive Rec. ITU-T T.81 | ISO/IEC 10918-1 coding. Note, however,\r\nthat not many implementations are capable of decoding such stream,\r\nthus this is probably not a good option for all-day purposes.\r\n\r\n$ jpeg -p -c infile.ppm out.jpg\r\n\r\nWhile the result is a valid Rec. ITU-T T.81 | ISO/IEC 10918-1 stream,\r\nmost other implementations will hick up and break, thus it is not\r\nadvisable to use it.\r\n\r\nA second option for lossless coding is residual coding within profile c:\r\n\r\n$ jpeg -q <quality> -Q 100 -h -r infile.ppm out.jpg\r\n\r\nThis also works for floating point coding. Note that lossless coding is enabled\r\nby setting the extension quality to 100.\r\n\r\n$ jpeg -q <quality> -Q 100 -h -r infile.pfm out.jpg\r\n\r\nHowever, this is only lossless for 16 bit input samples, i.e. there is a precision\r\nloss due to down-converting the 32-bit input to 16 bit. If samples are out of the\r\n601 gamut, the problem also exists that clamping will happen. To avoid that,\r\nencode in the XYZ color space (profile C only, currently):\r\n\r\n$ jpeg -xyz -q <quality> -Q 100 -h -r infile.pfm out.jpg\r\n\r\nA second option for lossless integer coding is to use a lossless 1-1 DCT\r\nprocess. This is enabled with the -l command line option:\r\n\r\n$ jpeg -l -q 100 -c infile.ppm out.jpg\r\n\r\nRefinement scans can be used to increase the sample precision to up to 12\r\nbits. The \"-c\" command line option disables the lossy color transformation.\r\n\r\nAdditionally, this implementation also supports JPEG LS, which is\r\noutside of Rec. ITU-T T.81 | ISO/IEC 10918-1 and ISO/IEC 18477. For\r\nthat, use the command line option -ls:\r\n\r\n$ jpeg -ls -c infile.ppm out.jpg\r\n\r\nThe \"-c\" command line switch is necessary to disable the color transformation\r\nas JPEG LS typically encodes in RGB and not YCbCr space.\r\n\r\nOptionally, you may specify the JPEG LS \"near\" parameter (maximum error) with\r\nthe -m command line switch:\r\n\r\n$ jpeg -ls -m 2 -c infile.ppm out.jpg\r\n\r\nJPEG LS also specifies a lossless color transformation that is enabled with\r\n-cls:\r\n\r\n$ jpeg -ls -cls infile.ppm out.jpg\r\n\r\n\r\nTo encode images with an alpha channel, specify the source image that \r\ncontains the alpha channel with -al. The alpha channel is a one-component\r\ngrey-scale image, either integer or floating point. The quality of the\r\nalpha channel is specified with -aq, that of the regular image with -q:\r\n\r\n$ jpeg -al alpha.pgm -aq 80 -q 85 input.ppm output.jpg\r\n\r\nAlpha channels can be larger than 8bpp or can be floating point. In both\r\ncases, residual coding is required. To enable residual coding in the alpha\r\nchannel, use the -ar command line option. Similar to the regular image,\r\nwhere residual coding requires two parameters, -q for the base quality and\r\n-Q for the extension quality, an alpha channel that uses residual coding\r\nalso requires a base and extension quality, the former is given by -aq,\r\nthe latter with -aQ:\r\n\r\n$ jpeg -ar -al alphahigh.pgm -q 85 -Q 90 -aq 80 -aQ 90 input.ppm out.jpg\r\n\r\nThe alpha channel can be encoded without loss if desired. For that, enable\r\nresidual coding with -ar and specify an extension quality of 100:\r\n\r\n$ jpeg -ar -al alphahigh.pgm -q 85 -Q 90 -aq 80 -aQ 100 input.ppm out.jpg\r\n\r\nThe alpha channel can use the same technology extensions as the image,\r\nnamely refinement scans in the base or extension image, or 12-bit residual\r\nimages. The number of refinement scans is selected with -aR and -arR for\r\nthe base and residual image, a 12-bit residual image is selected with -ar12.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nDecoding is much simpler:\r\n\r\n$ jpeg infile.jpg out.ppm\r\n\r\nor, for floating point images:\r\n\r\n$ jpeg infile.jpg out.pfm\r\n\r\n\r\nIf you want to decode a JPEG LS image, then you may want to tell the\r\ndecoder explicitly to disable the color transformation even though the\r\ncorresponding marker signalling coding in RGB space is typically missing\r\nfor JPEG LS:\r\n\r\n$ jpeg -c infile.jpg out.ppm\r\n\r\n\r\nIf an alpha channel is included in the image, the decoder does not\r\nreconstruct this automatically, nor does it attempt to merge the alpha\r\nimage into the file. Instead, it may optionally be instructed to write the\r\nalpha channel into a separate 1-component (grey-scale) file:\r\n\r\n$ jpeg -al alpha.pgm infile.jpg outfile.ppm\r\n\r\nThe -al option for the decoder provides the target file for the alpha\r\nchannel.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nStarting with release 1.30, libjpeg will include a couple of optimization\r\nparameters to improve the performance of JPEG and JPEG XT. In this\r\nrelease, the following additional command line switches are available:\r\n\r\n-qt <n> : Selects a different quantization table. The default table,\r\nalso enabled by -qt 0, is the one in the legacy JPEG standard\r\n(Rec. ITU-T T.81 | ISO/IEC 10918-1). -qt 1 is the \"flat\" table for\r\nPSNR-optimal performance. It is not recommended for real-life usage as\r\nits visual performance is non-ideal, it just generates \"nice\r\nnumbers\". -qt 2 is MS-SSIM ideal, but similarly, not necessarily a\r\ngood recommendation for all-day use. -qt 3 is a good compromize and\r\nusually works better than -qt 0.\r\n\r\n-dz : This option enables a deadzone quantizer that shifts the buckets\r\nby 1/8th of their size to the outside. This is (almost) the ideal choice\r\nfor Laplacian sources which would require a shift of 1/12th. Nevertheless,\r\nthis option improves the rate-distortion performance by about 0.3dB on\r\naverage and works pretty consistent over many images.\r\n\r\nAdditional options are planned for future releases.\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.40:\r\n\r\nIn this release, we included additional support for \"full profile\" encoding, i.e.\r\nencoding parameters that do not fit any of the four profiles specified in 18477-7.\r\nUsing such encoding parameters will generate a warning on the command line, but\r\nencoding will proceed anyhow, generating a bitstream that conforms to 18477-7, but\r\nnot to any of the profiles in this standard.\r\n\r\nWith \"-profile a -g 0\" or \"-profile b -g 0\" the encoder will generate a file that\r\nuses an inverse TMO lookup similar to profile C with other encoding parameters\r\nidentical to those defined by profiles A and B.\r\n\r\nThe command line option \"-lr\" will use a logarithmic encoding instead of the gamma\r\nencoding for profile B. Again, this will leave the profile, but will be within the\r\nbounds of 18477-7.\r\n\r\nOther than that, a couple of bug fixes have been made. Profile A and B setup could\r\nnot reset the toe value for the inverse gamma map, due to a typo of one of the\r\nparameters. Profile B accepted a different gamma value than the default, but never\r\ncommunicated it to the core code, i.e. it was simply ignored. Profile B setup ignored\r\nthe epsilon values for numerator and denomiator, and they were communicated wrongly\r\ninto the core code. This was corrected, and epsilons can now be specified on the\r\ncommand line.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.50:\r\n\r\nThis release fixes encoding of ISO/IEC 18477-8 if the IDCT was selected as\r\ntransformation in the extension layer and refinement scans were added, i.e.\r\nthe command line options -rl -rR 4 created invalid codestreams. Previous\r\nreleases used the wrong type of refinement scan (dct bypass refinement instead\r\nof regular refinement) and hence broke reconstruction. Furthermore, previous\r\nreleases no longer allowed near lossless coding with DCT bypass. Instead, regular\r\nDCT coding conforming to ISO/IEC 18477-7 was used. To enable the near-lossless\r\nDCT bypass mode, use the new option \"-ro\" now.\r\n\r\nProfile B encoding could potentially create codestreams that run into\r\nclipping of the extension channel; this always happens if the denominator is\r\nlarger than 1, and has to happen according to Annex C of ISO/IEC 18477-3.\r\nThis release avoids this issue by adjusting the exposure value such that\r\nthe denominator always remains smaller than 1.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.51:\r\n\r\nIf the JPEG-XT markers were delayed to the frame-header intead the global\r\nheader, the previous code did not built up the necessary infrastructure\r\nto compute the checksum and hence could not verify the checksum in such\r\na condition. The 1.51 release fixes this problem.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.52:\r\n\r\nThis file is an updated/enhanced version of the 1.51 release of\r\nthe JPEG XT demo software found on https://github.com/thorfdbg/. It\r\nincludes additional features presented in the paper\r\n\"JPEG on Steroids : Common Optimization Techniques for JPEG Image Compression\"\r\nby the same author.\r\n\r\nIn specific, the following command line flags are *NEW* to this version and\r\nare available only as a contribution to ICIP 2016:\r\n\r\n-oz:          This enables the dynamic programming algorithm to enhance\r\nthe rate-distortion performance by soft-threshold quantization. It has been\r\nused for the tests in section 3.3 of the paper.\r\n\r\n-dr:         This enables the smart de-ringing algorithm that has been used\r\nin section 3.6.\r\n\r\nAdditionally, the following switches have been used for other subsections\r\nof the paper; they are not new to this distribution but available as\r\npart of the regular libjpeg distribution at github or www.jpeg.org:\r\n\r\n-s 1x1,2x2,2x2:     Enable 420 subsampling (444 is default)\r\n-s 1x1,2x1,2x1:     Enable 422 subsampling (444 is default)\r\n-qt n (n=0..8)      Use quantization matrix n.\r\n                    In the paper, n=1 (flat) was used for PSNR-optimized\r\n                    coding, unless otherwise noted.\r\n-dz                 The deadzone quantizer in section 3.3\r\n                    (simpler than -oz)\r\n-v                  Enable coding in processive mode (section 3.5)\r\n-v -qv              Optimized progressive mode (section 3.5)\r\n-h                  Optimized Huffman coding (always used, unless noted\r\n                    otherwise, see section 3.4)\r\n\t\t    \r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.53:\r\n\r\nThis release includes additional functionality to inject markers, or\r\nretrieve markers from a codestream while reading. For that, set\r\nthe JPGTAG_ENCODER_STOP tag of the JPEG::Write() call to a bitmask\r\nwhere the encoder should interrupt writing data (this flag already\r\nexisted before) then write custom data with JPEG::WriteMarker(), then\r\ncontinue with JPEG::Write(). On decoding, set JPGTAG_DECODER_STOP to\r\na bitmask where to stop for markers, then identify markers with\r\nJPEG::PeekMarker(), and retrieve them with JPEG::ReadMarker(). Details\r\ncan be found in cmd/encodec.cpp for encoding, and cmd/reconstruct.cpp.\r\n\r\nOtherwise, no functional changes.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.54:\r\n\r\nIn this release, upsampling has been made conforming to the latest\r\ncorrigendum of 18477-1 and 18477-8. In particular, upsampling is now\r\nby design always centered and never co-sited. The co-sited upsampling\r\nprocedure is still included in the source code, but never executed.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.55:\r\n\r\nThis release only addresses some minor formulation issues of the\r\ncommand line such that references are formatted properly to make this\r\nsoftware package acceptable as a JPEG reference software.\r\nNo functional changes.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.56:\r\n\r\nEncoding and reconstruction of 2-component images was actually never\r\nsupported, as it was considered a rather exotic use-case. Now that a\r\nrequest was made, support for 2-components was added and should\r\nhopefully work ok.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.57:\r\n\r\nNewer g++ compiler versions warned about implicit fall-throughs in switch/\r\ncase constructs that are actually harmless. This release adds an autoconf\r\ndetection of such compiler versions, adds consistent comments throughout\r\nthe code.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.58:\r\n\r\nThis release fixes multiple spelling errors in the file, thanks to\r\nMathieu Mmalaterre for finding and fixing them. The release also\r\naddresses multiple race conditions and improves stability and robustness\r\non invalid streams. Thanks to seviezhou for providing codestreams that\r\ntriggered these defects. In particular, the following defects have\r\nbeen found:\r\n\r\n- when a codestream with unsupported upsampling specification (beyond\r\n  18477-1) was found, the code crashed.\r\n- JPEG LS single component scans did not check whether there is actually\r\n  only a single component referenced in the scan.\r\n- An invalid DC category in the sequential scan could have caused a\r\n  crash in the follow-up decoding.\r\n- AC-coded lossless JPEG scans with horizontal subsampling factors\r\n  trashed memory.\r\n- MCU sizes of 0 remained undetected and caused crashes due to a\r\n  division-by-zero exception.\r\n- The code did not check whether a scan references the same component\r\n  more than once and could have failed with strange effects then.\r\n- The code did not handle EOF conditions in the frame header\r\n  gracefully.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.59:\r\n\r\nThis release addresses a defect in the MCU handling for JPEG LS scans.\r\nThe previous code forgot to reset the JPEG LS state variables on MCU\r\nscan boundaries, thus defeating the independent decodability of MCUs\r\nif restart markers are inserted into the stream. Thanks to Spyros for\r\ndetecting this defect.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.60:\r\n\r\nA specially crafted bitstream depending on line-based JPEG processes\r\ncould trigger a segfault because source data the reconstruction\r\nprocess depended upon were not available. This has been fixed.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.61:\r\n\r\nThe restart interval for JPEG LS streams, specifically, is allowed to\r\nbe larger than 2^16. Modified the DRI marker accordingly. Unfortunately,\r\nas the initial tables section of a codestream of JPEG and JPEG LS is\r\nidentical, JPEG files with an invalid DRI marker size will also be\r\naccepted as valid.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.62:\r\n\r\nThe quantization table could contain entries larger than 255 for the 8-bit\r\nDCT process, even though the standard prohibits this. Now the quantization\r\ntable entries are clipped to the allowed range.\r\nAdded an option -bl to force encoding in the baseline sequential process.\r\nAdded options to read the quantization tables from files rather than using\r\nthe built-in defaults.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.63:\r\n\r\nIn case the decoder was started with an image containing an alpha channel,\r\ni.e. a 18477-9 image, and no output file for the alpha channel was\r\nprovided, the decoder crashed. This issue was fixed, the alpha channel is\r\nnow in this case simply disregarded. Note that you can define the output\r\nfile for the alpha channel with the \"-al\" command line option.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nFor license conditions, please check the file README.license in this\r\ndirectory.\r\n\r\nFinally, I want to thank Accusoft and the Computing Center of the University of\r\nStuttgart and Fraunhofer IIS for sponsoring this project.\r\n\r\nThomas Richter, February 2022\r\n\r\n-------------------------------------------------------------------------------------\r\n", "Revision 0.10\r\n-----------------------------\r\n\r\nFirst release of libjpeg to the public.\r\n\r\n\r\nRevision 0.11\r\n-----------------------------\r\n\r\nApparently, the demo frontend code used the \r\nnon-binary mode to open the output files,\r\ncreating corrupt files under platforms where\r\nsuch modes include a text conversion. Fixed.\r\n\r\nThe configure script that tested for the avail-\r\nibility of setjmp did not work on those platforms\r\nwhere setjmp is a macro rather than a function.\r\nThe test for setjmp is now omitted, depending solely\r\non the availibility of longjmp.\r\n\r\n\r\nRevision 0.20\r\n-----------------------------\r\n\r\nThis release fixes a bug in the residual huffman decoder\r\nscan where I forgot to multiply the residuals with the\r\nquantization size. This did not affect lossless coding,\r\nbut only near-lossless coding.\r\nFurthermore, this release adds coding of high-bitdepth\r\nimages with a standard 8bpp JPEG fallback stream. For\r\nthat, simply supply the image to be coded on the command\r\nline and add the \"-r\" option to enable residual coding.\r\nTo use the conforming, but typically ill-supported 12bpp\r\nmode of JPEG, do not use \"-r\".\r\n\r\n\r\nRevision 0.30\r\n-----------------------------\r\n\r\nThis release introduces a new coding strategy for lossless\r\nand high-dynamic range coding. Unlike former releases,\r\nthis release runs an additional reversible color transformation\r\non the residual data, followed by a lossless (scaled) Hadamard\r\ntransformation to avoid color banding in extreme cases. It\r\nalso adds an additional tone mapping curve (or curves) to be\r\nspecified on encoding that allow a higher quality of the\r\nLDR base layer.\r\n\r\nRevision 0.50\r\n-----------------------------\r\n\r\nThe new features in this version are a refined residual coding algorithm that\r\nincludes a runlength scan to improve coding efficiency for low-quality extensions\r\nlayers. This release also features a new HDR compression in the DCT domain that\r\nuses the known JPEG refinement scans of progressive coding to improve the resolution\r\nfrom 8 bit to 12 bit in a completely backwards compatible way. Additionally, the\r\nsoftware was unit-tested with the 10918-2 (JPEG part 2) test streams and various\r\nbugs of the lossless predictive arithmetic coding and lossless predictive coding\r\nwere removed. New command line switches allow the encoding of pfm images (floating\r\npoint, for high-dynamic range) and the number of extension refinement scans.\r\n\r\nRevision 0.60\r\n-----------------------------\r\n\r\nOnly minor modifications were made in this release. The Huffman coder now fills\r\nundefined bits at the end of the entropy coded segment by ones, and potentially\r\ninserts a stuffed zero byte. Note that the standard defines this only in an\r\ninformative note, so it is likely not required. The insertion of a stuffed zero\r\nbyte at this position might also be unnecessary as a parser should identify the\r\nfirst 0xff byte ahead of the marker as \"fill byte\".\r\n\r\nResidual coding has been reworked and uses now a simple progressive scan with the\r\nspecial DC case removed. The performance does not differ significantly, and it\r\nmakes integration into legacy software or hardware easier. \r\n\r\nDefault Huffman tables are now also provided for progressive and lossless scans,\r\nthus optimizing the Huffman tables just for these scan types is no longer \r\nnecessary. Residual or refinement scans still require this argument, though.\r\n\r\nUsage of the codec does not differ from previous releases, though codestreams\r\nusing the residual coding mode are not compatible to those generated by 0.5.\r\nNote that this is still experimental software and the codestream might still\r\nchange until the ISO committee decides on the technology.\r\n\r\nFinally, a couple of workarounds for earlier releases of the g++ compiler have\r\nbeen added.\r\n\r\n\r\nRelease 0.7:\r\n-----------------------------\r\n\r\nThis is a major release of the software which adds a lot of missing\r\nfunctionality and brings it up to date to the latest working draft of\r\n18477-2. In specific, boxes are now written according to the latest\r\nspecification, and three proposals to encode HDR data are now\r\nimplemented: mult1 (quotient method), mult2 (overflow/truncation\r\nmethod) and residual coding. The HDR to LDR non-linear point\r\ntransformation can now be explicitly specified giving a file name on\r\nthe command line (-gf option) which must contain 256 lines, one line\r\nper LDR input sample value. Each line shall contain an ASCII encoded\r\ndecimal number, the output value a reconstructed LDR sample value is\r\nmapped to.\r\n\r\nThis release also supports (finally) subsampling in residual and\r\nmultiplicative coding, just specify the subsampling factors. In this\r\nrelease, the frontend only allows the same subsampling factors for\r\nboth images (legacy and residual) though the back-end is more powerful\r\nand would allow arbitrary combinations.  Lossless coding by residuals\r\nis also supported, residual image subsampling factors are set to 1:1:1\r\nin case the quality of the residual is 100.\r\n\r\nThe SERMS DCT that was removed in the earlier releases is now back and\r\ncan be enabled by the \"-l\" option. Note well that you also need to\r\nspecify \"-c\" to disable the YCbCr transformation.\r\n\r\nThe experimental VESA coding modes that have been part of this code\r\nare now gone for good as they are not part of the specification.\r\n\r\nA huge number of bugs have been fixed, in specific for the handling of\r\ngrey-only images. These should work fine now.\r\n\r\nThis release supports now two variations of the encoding mode,\r\nopen-loop and closed-loop.  In closed-loop coding, which was the\r\ndefault so far, the residual/multiplicative encoder is feed by the\r\nresidual (additive or multiplicative) of the reconstructed LDR and\r\noriginal image. For openloop coding, the encoder does not need to go\r\nthrough a full encoding/decoding cycle of the legacy stream and feeds\r\nin the legacy image derived from the original image to the residual\r\ncoder right away. NOTE THAT THIS MEANS THAT LOSSLESS CODING WILL NOT\r\nOPERATIONAL IN OPEN LOOP MODE, and additive residual coding will be\r\nrather pointless. However, this mode does make sense for the\r\nmultiplicative modes. Regardless of whether open or closed loop coding\r\nis used, the encoded codestream is conforming, though coding results\r\nmay be different.\r\n\r\n\r\nRelease 0.71:\r\n-----------------------------\r\n\r\nThis is a minor bugfix release which also adds one functionality, namely\r\nthe encodign of HDR images in the floating point domain via -mult1.\r\nPrevious versions took a round-trip through the integer domain and\r\nhence required output clipping. The direct-float mode can now be enabled\r\nby disabling the output-clipping process with \"-oc\". \r\n\r\nAdditionally, this release fixes two bugs, mostly related to the internal\r\nstream management. Due to an oversight, the marker-peek-ahead logic for\r\nresidual streams did not work, causing a potential race condition\r\nwhen a marker was overlapping a chunk-boundary of the internal stream\r\nrepresentation. Length computation of the internal stream representation\r\nwas also broken on encoding, causing a potential race condition when the\r\nhuffman table marker was overlapping with a chunk boundary. A third\r\nbug, namely a missing EOC at the end of the residual codestream, was\r\nfixed, too.\r\n\r\nRelease 0.72:\r\n-----------------------------\r\n\r\nThis release fixes a one-line oversight in the handling of subsampled \"residual\" coding,\r\nnamely the quantization output buffer did not advance, causing an assertion failure.\r\nThis release fixes the issue.\r\n\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 0.8:\r\n\r\nThis is again an update of the software in order to synchronize it with\r\nthe latest Working Draft (proposed CD text) document; that is, boxes\r\nare written now according to the latest specifications. Furthermore, support\r\nfor refinement scans in the residual domain have been added (with -rR),\r\nresidual data is DCT transformed unless lossless coding is desired.\r\nThis release also adds the checksum box, computes the checksum on encoding\r\nand tests it on decoding. In case it does not fit, a warning is generated.\r\n\r\nQuantization setup changed a bit, using now smaller buckets in the residual\r\nstream which avoids the paradoxical situation that a finer base layer\r\nquantization can cause a quality drop for the overall image.\r\n\r\nA serious bug in legacy coding modes was removed that caused the encoder\r\nor decoder to crash if no residual image was present.\r\n\r\nThis version of the encoder also supports encoding and decoding of images\r\nin wider color spaces; for demonstration purposes, it encodes images in the\r\nXYZ colorspace using the command line option -xyz, or -cxyz where the latter\r\nuses a slightly less efficient method how to represent the images.\r\n\r\nAt this time, the text based format is not supported, and support for the\r\ntwo other profiles (-mult1, -mult2) has been temporarely removed until the\r\nstandardization committee provides a clean solution how to integrate them.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 0.9:\r\n\r\nThis is just another update. This update introduces new DCTs, the Z0 DCT from\r\nISO/IEC 23002-2, the Z1a DCT from the same authors and the CD document of this\r\nstandard, and a lifting-based DCT. Tests show that Z0 and the lifting DCT do not \r\nperform very well, so the default is current Z1 and SERMS.\r\nFurthermore, processing of RCT has changed slightly to ensure that the output\r\nis always in-range, not only for 16 bit output.\r\nDCT-bypass entropy coding was extended to use the full Huffman table, and includes\r\nnow special handling for the race-condition of having to code the value 0x8000\r\nwhich was simply not possible before.\r\nThe codestream syntax has been modified again to reflect the latest edition of\r\nthe standard document, namely the CD of 18477-3.\r\nLots of other minor fixes have been made, as for example in the selection and\r\nencoding of the precision of the residual frame and the computation of the\r\nchecksum.\r\n\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 0.91:\r\n\r\nThis release fixes a wrong DC offset in the residual coding path that compromized\r\ncompression efficiency, and a wrong computation in the residual bits.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 0.92:\r\n\r\nThis release improves the computation of the LDR to HDR inverse TMO computation for\r\nprofile C and gains by that sometimes up to 2dB in PSNR. It also provides a \"-sp\"\r\ncommand line switch to use separate separate tables, one per component. This may\r\nhelp in case the image contains some extreme colors.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.00alpha1:\r\n\r\nThis is the first complete release of the demo software. It adds again support\r\nfor profiles a and b for lossy HDR image coding and follows the new box-based\r\ndesign of 18477-3.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.00beta1:\r\n\r\nThis is a fully verified version of the software, i.e. all modes of operation have\r\nbeen tested by an automatic unit test. This of course does not exclude any bugs,\r\nor any modifications before the finalization of the standard.\r\n\r\nIn comparison to the alpha1 release, the following bugs have been fixed:\r\n\r\n- Predictive lossless mode with restart markers forgot to reconstruct the last line\r\nin some configurations.\r\n- Due to an oversight, hierarchical mode did not work in combination with AC coding.\r\n- Hierarchical mode did not work in the \"semi-lossless\" configuration where the finest\r\nframe is defined by a lossless predictive scan.\r\n- Predictive lossless could have forgotten the last line on streams using the DNL marker\r\nto signal the height of the image.\r\n- JPEG LS restart markers did not work in plane and sample interleaved mode. Note,\r\nhowever, that restart marker handling in the JPEG LS reference software is broken and\r\ndoes not follow the specifications. (Defect report is pending.)\r\n- Grey scale coding in profiles A and B did not work.\r\n- Coding in RGB-colorspace did not work in profiles A and B.\r\n- Encoding in JPEG-LS erraneously inserted JPEG XT boxes into the codestream. While this\r\nis harmless, it increases the rate unnecessarily.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.00beta2:\r\n\r\nThis release includes the changes made on the standard in the Strasbourg meeting\r\nof the JPEG committee, in particular it includes a rounding mode specifier of\r\nthe CURV boxes. Additionally, it allows now the inclusion of an arbitrary LDR image\r\nwithin profile B. Previous releases only supported the gamma-plus-clamping tone\r\nmapper which was built into the source. In addition to the new features, this\r\nrelease also includes an improved Huffman decoder that should be considerably\r\nfaster than the previous trivial bit-by-bit decoder.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.00beta2.2:\r\n\r\nOnly a short fix in the handling of lossless JPEG scans: This release fixes one\r\nissue, namely correct decoding of 16-bit images where the carry-over was not\r\ncomputed correctly. This change required a careful distinction between differential\r\npredictive and regular-predictive mode, which is interestingly not mentioned in\r\nthe specs (probably nobody tested). A second race was fixed in JPEG-LS handling\r\nwhere bit-stuffing could have left a single isolated zero at the end of a JPEG-LS\r\nscan, causing a warning in the upwards marker parser (though no corrupt reconstruction).\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.20:\r\n\r\nThis version adds support for alpha channels as defined by ISO/IEC 18477-9\r\nto the code. Alpha channels are specified by one-component grey-scale images,\r\nof bit depths between 8 and 16 bits per sample. They may also consist of\r\nfloating point samples between 0 and 1. To add an alpha channel, use the command\r\nline options -al <filename> -aq <quality> for simple alpha channels of 8 bits per\r\nsample. For more precise alpha channels, residual coding in the alpha domain\r\nmust be enabled with -ar, and an alpha channel residual quality must be specified\r\nwith -aQ <ext-quality>. The coding tools for alpha channels are otherwise identical\r\nfor that of the base image. Alpha coding can be combined with any other coding\r\ntools, i.e. parts 6,7 and 8.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.21:\r\n\r\nThis is only a minor maintenance release which removes three experimental DCT\r\nimplementations that are no longer required, fixes two possible un-initialized\r\nvariables and fixes a bug in the box enumeration. Release 1.20 and above started\r\nfor some boxes the box enumeration at zero even though it should start at one.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.30:\r\n\r\nThis release fixes a bug in the line-based operation mode that is not available from\r\nthe front end and only works for baseline sequential. Unlike other modes, it does\r\nnot require full internal buffering of the image. It is also synchronized again to\r\nthe latest edition of the standard, offering the additional upscaling in the residual\r\npath for parts 6 and part 7 profile C. It has been cross-tested with other \r\nimplementations, thus interoperability is granted. Clipping for floating-point output\r\nhas been corrected to avoid the representations of NAN and INF.\r\nLast but not least, this release offers the possibility to select between nine different\r\nquantization matrices (-qt 0 to -qt 9), of which -qt 1 is PSNR-optimal and -qt 3 is\r\na good candidate for high visual compression. See the command line parameters for\r\ndetails. Furthermore, the -dz parameter enables a deadzone quantizer that improves\r\nthe compression performance by 0.3 dB on average.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.31:\r\n\r\nThis release includes two minor changes that have been made to the specs at the last \r\nWarsaw meeting in June 2015. The order of the FDCT (fixed point DCT) has been adjusted\r\nto match the order of ISO/IEC 23002-2 (MPEG C) and to be consistent with the order of\r\nthe IDCT (integer DCT). Second, the specs allow now Integer Table Lookup boxes with\r\nsample size > 16 bits to allow the usage of a Table lookup in the residual coding\r\npath for part 8 of the specs.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.40:\r\n\r\nIn this release, we included additional support for \"full profile\" encoding, i.e.\r\nencoding parameters that do not fit any of the four profiles specified in 18477-7.\r\nUsing such encoding parameters will generate a warning on the command line, but\r\nencoding will proceed anyhow, generating a bitstream that conforms to 18477-7, but\r\nnot to any of the profiles in this standard.\r\n\r\nWith \"-profile a -g 0\" or \"-profile b -g 0\" the encoder will generate a file that\r\nuses an inverse TMO lookup similar to profile C with other encoding parameters\r\nidentical to those defined by profiles A and B.\r\n\r\nThe command line option \"-lr\" will use a logarithmic encoding instead of the gamma\r\nencoding for profile B. Again, this will leave the profile, but will be within the\r\nbounds of 18477-7.\r\n\r\nOther than that, a couple of bug fixes have been made. Profile A and B setup could\r\nnot reset the toe value for the inverse gamma map, due to a typo of one of the\r\nparameters. Profile B accepted a different gamma value than the default, but never\r\ncommunicated it to the core code, i.e. it was simply ignored. Profile B setup ignored\r\nthe epsilon values for numerator and denomiator, and they were communicated wrongly\r\ninto the core code. This was corrected, and epsilons can now be specified on the\r\ncommand line. The JPEG LS part-2 encoder was broken due to a modification of the\r\ncolor transformer factory, and the (non-standardized, proprietary) residual\r\nrefinement arithmetic coding scan mode did not work correctly by depending on a non-\r\nexisting context.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.50:\r\n\r\nThis release fixes encoding of ISO/IEC 18477-8 if the IDCT was selected as\r\ntransformation in the extension layer and refinement scans were added, i.e.\r\nthe command line options -rl -rR 4 created invalid codestreams. Previous\r\nreleases used the wrong type of refinement scan (dct bypass refinement instead\r\nof regular refinement) and hence broke reconstruction. Furthermore, previous\r\nreleases no longer allowed near lossless coding with DCT bypass. Instead, regular\r\nDCT coding conforming to ISO/IEC 18477-7 was used. To enable the near-lossless\r\nDCT bypass mode, use the new option \"-ro\" now.\r\n\r\nProfile B encoding could potentially create codestreams that run into\r\nclipping of the extension channel; this always happens if the denominator is\r\nlarger than 1, and has to happen according to Annex C of ISO/IEC 18477-3:2015.\r\nThis release avoids this issue by adjusting the exposure value such that\r\nthe denominator always remains smaller than 1.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.51:\r\n\r\nIf the JPEG-XT markers were delayed to the frame-header intead the global\r\nheader, the previous code did not built up the necessary infrastructure\r\nto compute the checksum and hence could not verify the checksum in such\r\na condition. The 1.51 release fixes this problem.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.52:\r\n\r\nThis file is an updated/enhanced version of the 1.50 release of\r\nthe JPEG XT demo software found on https://github.com/thorfdbg/. It\r\nincludes additional features presented in the paper\r\n\"JPEG on Steroids : Common Optimization Techniques for JPEG Image Compression\"\r\nby the same author.\r\n\r\nIn specific, the following command line flags are *NEW* to this version and\r\nare available only as a contribution to ICIP 2016:\r\n\r\n-oz:\t      This enables the dynamic programming algorithm to enhance\r\nthe rate-distortion performance by soft-threshold quantization. It has been\r\nused for the tests in section 3.3 of the paper.\r\n\r\n-dr: \t     This enables the smart de-ringing algorithm that has been used\r\nin section 3.6.\r\n\r\nAdditionally, the following switches have been used for other subsections\r\nof the paper; they are not new to this distribution but available as\r\npart of the regular libjpeg distribution at github or www.jpeg.org:\r\n\r\n-s 1x1,2x2,2x2:\t    Enable 420 subsampling (444 is default)\r\n-s 1x1,2x1,2x1:\t    Enable 422 subsampling (444 is default)\r\n-qt n (n=0..8)\t    Use quantization matrix n.\r\n      \t\t    In the paper, n=1 (flat) was used for PSNR-optimized\r\n\t\t    coding, unless otherwise noted.\r\n-dz\t\t    The deadzone quantizer in section 3.3\r\n\t\t    (simpler than -oz)\r\n-v\t\t    Enable coding in processive mode (section 3.5)\r\n-v -qv\t\t    Optimized progressive mode (section 3.5)\r\n-h \t\t    Optimized Huffman coding (always used, unless noted\r\n\t\t    otherwise, see section 3.4)\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.53:\r\n\r\nThis release includes additional functionality to inject markers, or\r\nretrieve markers from a codestream while reading. For that, set\r\nthe JPGTAG_ENCODER_STOP tag of the JPEG::Write() call to a bitmask\r\nwhere the encoder should interrupt writing data (this flag already\r\nexisted before) then write custom data with JPEG::WriteMarker(), then\r\ncontinue with JPEG::Write(). On decoding, set JPGTAG_DECODER_STOP to\r\na bitmask where to stop for markers, then identify markers with\r\nJPEG::PeekMarker(), and retrieve them with JPEG::ReadMarker(). Details\r\ncan be found in cmd/encodec.cpp for encoding, and cmd/reconstruct.cpp.\r\n\r\nOtherwise, no functional changes.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.54:\r\n\r\nIn this release, upsampling has been made conforming to the latest\r\ncorrigendum of 18477-1 and 18477-8. In particular, upsampling is now\r\nby design always centered and never co-sited. The co-sited upsampling\r\nprocedure is still included in the source code, but never executed.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.55:\r\n\r\nThis release only addresses some minor formulation issues of the\r\ncommand line such that references are formatted properly to make this\r\nsoftware package acceptable as a JPEG reference software.\r\nNo functional changes.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.56:\r\n\r\nEncoding and reconstruction of 2-component images was actually never\r\nsupported, as it was considered a rather exotic use-case. Now that a\r\nrequest was made, support for 2-components was added and should\r\nhopefully work ok.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.57:\r\n\r\nNewer g++ compiler versions warned about implicit fall-throughs in switch/\r\ncase constructs that are actually harmless. This release adds an autoconf\r\ndetection of such compiler versions, adds consistent comments throughout\r\nthe code, and disables the compiler warning were necessary.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.58:\r\n\r\nThis release fixes multiple spelling errors in the file, thanks to\r\nMathieu Mmalaterre for finding and fixing them. The release also\r\naddresses multiple race conditions and improves stability and robustness\r\non invalid streams. Thanks to seviezhou for providing codestreams that\r\ntriggered these defects. In particular, the following defects have\r\nbeen found:\r\n\r\n- when a codestream with unsupported upsampling specification (beyond\r\n  18477-1) was found, the code crashed.\r\n- JPEG LS single component scans did not check whether there is actually\r\n  only a single component referenced in the scan.\r\n- An invalid DC category in the sequential scan could have caused a\r\n  crash in the follow-up decoding.\r\n- AC-coded lossless JPEG scans with horizontal subsampling factors\r\n  trashed memory.\r\n- MCU sizes of 0 remained undetected and caused crashes due to a\r\n  division-by-zero exception.\r\n- The code did not check whether a scan references the same component\r\n  more than once and could have failed with strange effects then.\r\n- The code did not handle EOF conditions in the frame header\r\n  gracefully.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.59:\r\n\r\nThis release addresses a defect in the MCU handling for JPEG LS scans.\r\nThe previous code forgot to reset the JPEG LS state variables on MCU\r\nscan boundaries, thus defeating the independent decodability of MCUs\r\nif restart markers are inserted into the stream. Thanks to Spyros for\r\ndetecting this defect.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.60:\r\n\r\nA specially crafted bitstream depending on line-based JPEG processes\r\ncould trigger a segfault because source data the reconstruction\r\nprocess depended upon were not available. This has been fixed.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.61:\r\n\r\nThe restart interval for JPEG LS streams, specifically, is allowed to\r\nbe larger than 2^16. Modified the DRI marker accordingly. Unfortunately,\r\nas the initial tables section of a codestream of JPEG and JPEG LS is\r\nidentical, JPEG files with an invalid DRI marker size will also be\r\naccepted as valid.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.62:\r\n\r\nThe quantization table could contain entries larger than 255 for the 8-bit\r\nDCT process, even though the standard prohibits this. Now the quantization\r\ntable entries are clipped to the allowed range.\r\nAdded an option -bl to force encoding in the baseline sequential process.\r\nAdded options to read the quantization tables from files rather than using\r\nthe built-in defaults.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.63:\r\n\r\nIn case the decoder was started with an image containing an alpha channel,\r\ni.e. a 18477-9 image, and no output file for the alpha channel was\r\nprovided, the decoder crashed. This issue was fixed, the alpha channel is\r\nnow in this case simply disregarded. Note that you can define the output\r\nfile for the alpha channel with the \"-al\" command line option.\r\n\r\n--------------------------------------------------------------------------\r\n", "/*************************************************************************\n\n    This project implements a complete(!) JPEG (Recommendation ITU-T\n    T.81 | ISO/IEC 10918-1) codec, plus a library that can be used to\n    encode and decode JPEG streams. \n    It also implements ISO/IEC 18477 aka JPEG XT which is an extension\n    towards intermediate, high-dynamic-range lossy and lossless coding\n    of JPEG. In specific, it supports ISO/IEC 18477-3/-6/-7/-8 encoding.\n\n    Note that only Profiles C and D of ISO/IEC 18477-7 are supported\n    here. Check the JPEG XT reference software for a full implementation\n    of ISO/IEC 18477-7.\n\n    Copyright (C) 2012-2018 Thomas Richter, University of Stuttgart and\n    Accusoft. (C) 2019-2020 Thomas Richter, Fraunhofer IIS.\n\n    This program is available under two licenses, GPLv3 and the ITU\n    Software licence Annex A Option 2, RAND conditions.\n\n    For the full text of the GPU license option, see README.license.gpl.\n    For the full text of the ITU license option, see README.license.itu.\n    \n    You may freely select between these two options.\n\n    For the GPL option, please note the following:\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*************************************************************************/\n/*\n**\n** Represents the scan including the scan header.\n**\n** $Id: aclosslessscan.cpp,v 1.42 2020/08/31 07:50:43 thor Exp $\n**\n*/\n\n/// Includes\n#include \"codestream/aclosslessscan.hpp\"\n#include \"io/bytestream.hpp\"\n#include \"control/linebuffer.hpp\"\n#include \"control/linebitmaprequester.hpp\"\n#include \"control/lineadapter.hpp\"\n#include \"marker/frame.hpp\"\n#include \"marker/scan.hpp\"\n#include \"marker/component.hpp\"\n#include \"codestream/tables.hpp\"\n#include \"coding/qmcoder.hpp\"\n#include \"coding/actemplate.hpp\"\n#include \"codestream/tables.hpp\"\n#include \"codestream/predictorbase.hpp\"\n#include \"tools/line.hpp\"\n#include \"std/string.hpp\"\n///\n\n/// ACLosslessScan::ACLosslessScan\nACLosslessScan::ACLosslessScan(class Frame *frame,class Scan *scan,UBYTE predictor,UBYTE lowbit,bool differential)\n  : PredictiveScan(frame,scan,predictor,lowbit,differential)\n{ \n#if ACCUSOFT_CODE\n  m_ucCount = scan->ComponentsInScan();\n  \n  for(int i = 0;i < m_ucCount;i++) {\n    m_ucSmall[i]     = 0;\n    m_ucLarge[i]     = 1;\n  }\n\n  memset(m_plDa,0,sizeof(m_plDa));\n  memset(m_plDb,0,sizeof(m_plDb));\n#endif\n}\n///\n\n/// ACLosslessScan::~ACLosslessScan\nACLosslessScan::~ACLosslessScan(void)\n{\n#if ACCUSOFT_CODE\n  UBYTE i;\n  \n  for(i = 0;i < m_ucCount;i++) {\n    if (m_plDa[i])\n      m_pEnviron->FreeMem(m_plDa[i],sizeof(LONG) * m_ucMCUHeight[i]);\n    if (m_plDb[i])\n      m_pEnviron->FreeMem(m_plDb[i],sizeof(LONG) * m_ucMCUWidth[i] * m_ulWidth[i]);\n  }\n#endif\n}\n///\n\n/// ACLosslessScan::WriteFrameType\n// Write the marker that indicates the frame type fitting to this scan.\nvoid ACLosslessScan::WriteFrameType(class ByteStream *io)\n{\n#if ACCUSOFT_CODE\n  if (m_bDifferential) {\n    io->PutWord(0xffcf); // differential lossless sequential AC coded\n  } else {\n    io->PutWord(0xffcb); // lossless sequential AC coded\n  }\n#else\n  NOREF(io);\n#endif\n}\n///\n\n/// ACLosslessScan::FindComponentDimensions\n// Common setup for encoding and decoding.\n#if ACCUSOFT_CODE\nvoid ACLosslessScan::FindComponentDimensions(void)\n{\n  UBYTE i;\n\n  PredictiveScan::FindComponentDimensions();\n\n  for(i = 0;i < m_ucCount;i++) {\n    assert(m_plDa[i] == NULL && m_plDb[i] == NULL);\n\n    m_plDa[i] = (LONG *)(m_pEnviron->AllocMem(sizeof(LONG) * m_ucMCUHeight[i]));\n    m_plDb[i] = (LONG *)(m_pEnviron->AllocMem(sizeof(LONG) * m_ucMCUWidth[i] * m_ulWidth[i]));\n  }\n}\n#endif\n///\n\n/// ACLosslessScan::StartParseScan\nvoid ACLosslessScan::StartParseScan(class ByteStream *io,class Checksum *chk,class BufferCtrl *ctrl)\n{\n#if ACCUSOFT_CODE\n  class ACTemplate *dc;\n  int i;\n\n  FindComponentDimensions();\n\n  for(i = 0;i < m_ucCount;i++) {\n    dc = m_pScan->DCConditionerOf(i);\n    if (dc) {\n      m_ucSmall[i]    = dc->LowerThresholdOf();\n      m_ucLarge[i]    = dc->UpperThresholdOf();\n    } else {\n      m_ucSmall[i]    = 0;\n      m_ucLarge[i]    = 1;\n    }\n    memset(m_plDa[i],0,sizeof(LONG) * m_ucMCUHeight[i]); \n    memset(m_plDb[i],0,sizeof(LONG) * m_ucMCUWidth[i] * m_ulWidth[i]);\n    m_ucContext[i]    = m_pScan->DCTableIndexOf(i); \n  }\n  for(i = 0;i < 4;i++) {\n    m_Context[i].Init();\n  }\n  \n  assert(ctrl->isLineBased());\n  m_pLineCtrl = dynamic_cast<LineBuffer *>(ctrl);\n  m_pLineCtrl->ResetToStartOfScan(m_pScan);\n  m_Coder.OpenForRead(io,chk);\n#else\n  NOREF(io);\n  NOREF(chk);\n  NOREF(ctrl);\n  JPG_THROW(NOT_IMPLEMENTED,\"ACLosslessScan::StartParseScan\",\n            \"JPEG lossless not available your code release, please contact Accusoft for a full version\");\n#endif\n}\n///\n\n/// ACLosslessScan::StartWriteScan\nvoid ACLosslessScan::StartWriteScan(class ByteStream *io,class Checksum *chk,class BufferCtrl *ctrl)\n{\n#if ACCUSOFT_CODE\n  class ACTemplate *dc;\n  int i;\n\n  FindComponentDimensions();\n\n  for(i = 0;i < m_ucCount;i++) {\n    dc = m_pScan->DCConditionerOf(i);\n\n    if (dc) {\n      m_ucSmall[i]    = dc->LowerThresholdOf();\n      m_ucLarge[i]    = dc->UpperThresholdOf();\n    } else {\n      m_ucSmall[i]    = 0;\n      m_ucLarge[i]    = 1;\n    }  \n    memset(m_plDa[i],0,sizeof(LONG) * m_ucMCUHeight[i]);\n    memset(m_plDb[i],0,sizeof(LONG) * m_ucMCUWidth[i] * m_ulWidth[i]);\n    m_ucContext[i]    = m_pScan->DCTableIndexOf(i); \n  }\n  for(i = 0;i < 4;i++) {\n    m_Context[i].Init();\n  }\n    \n  assert(ctrl->isLineBased());\n  m_pLineCtrl = dynamic_cast<LineBuffer *>(ctrl);\n  m_pLineCtrl->ResetToStartOfScan(m_pScan); \n\n  EntropyParser::StartWriteScan(io,chk,ctrl);\n  \n  m_pScan->WriteMarker(io);\n  m_Coder.OpenForWrite(io,chk);\n#else \n  NOREF(io);\n  NOREF(chk);\n  NOREF(ctrl);\n  JPG_THROW(NOT_IMPLEMENTED,\"ACLosslessScan::StartWriteScan\",\n            \"JPEG lossless not available your code release, please contact Accusoft for a full version\");\n#endif\n}\n///\n\n/// ACLosslessScan::StartMeasureScan\nvoid ACLosslessScan::StartMeasureScan(class BufferCtrl *)\n{\n  JPG_THROW(NOT_IMPLEMENTED,\"ACLosslessScan::StartMeasureScan\",\n            \"arithmetic coding is always adaptive and does not require a measurement phase\");\n}\n///\n\n/// ACLosslessScan::WriteMCU\n// This is actually the true MCU-writer, not the interface that reads\n// a full line.\nvoid ACLosslessScan::WriteMCU(struct Line **prev,struct Line **top)\n{ \n#if ACCUSOFT_CODE\n  UBYTE c;\n  //\n  // Parse a single MCU, which is now a group of pixels.\n  for(c = 0;c < m_ucCount;c++) {\n    struct QMContextSet &contextset = m_Context[m_ucContext[c]];\n    struct Line *line = top[c];\n    struct Line *pline= prev[c];\n    UBYTE ym = m_ucMCUHeight[c];\n    class PredictorBase *mcupred = m_pPredict[c];\n    ULONG  x = m_ulX[c];\n    LONG *lp = line->m_pData + x;\n    LONG *pp = (pline)?(pline->m_pData + x):(NULL);\n    //\n    // Write MCUwidth * MCUheight coefficients starting at the line top.\n    do {\n      class PredictorBase *pred = mcupred;\n      UBYTE xm = m_ucMCUWidth[c];\n      do {\n        // Decode now the difference between the predicted value and\n        // the real value.\n        LONG v = pred->EncodeSample(lp,pp);\n        //\n        // Get the sign coding context.\n        struct QMContextSet::ContextZeroSet &zset = contextset.ClassifySignZero(m_plDa[c][ym-1],m_plDb[c][x],\n                                                                                m_ucSmall[c],m_ucLarge[c]);\n        // \n        if (v) {\n          LONG sz;\n          m_Coder.Put(zset.S0,true);\n          //\n          if (v < 0) {\n            m_Coder.Put(zset.SS,true);\n            sz = -(v + 1);\n          } else {\n            m_Coder.Put(zset.SS,false);\n            sz =   v - 1;\n          }\n          //\n          if (sz >= 1) {\n            struct QMContextSet::MagnitudeSet &mset = contextset.ClassifyMagnitude(m_plDb[c][x],m_ucLarge[c]);\n            int  i = 0;\n            LONG m = 2;\n            //\n            m_Coder.Put((v > 0)?(zset.SP):(zset.SN),true);\n            //\n            while(sz >= m) {\n              m_Coder.Put(mset.X[i],true);\n              m <<= 1;\n              i++;\n            }\n            m_Coder.Put(mset.X[i],false);\n            //\n            m >>= 1;\n            while((m >>= 1)) {\n              m_Coder.Put(mset.M[i],(m & sz)?(true):(false));\n            }\n          } else {\n            m_Coder.Put((v > 0)?(zset.SP):(zset.SN),false);\n          }\n        } else {\n          m_Coder.Put(zset.S0,false);\n        }\n        //\n        // Update Da and Db.\n        // Is this a bug? 32768 does not exist, but -32768 does. \n        // The reference streams use -32768, so let's stick to that.\n        m_plDb[c][x]    = v;\n        m_plDa[c][ym-1] = v;\n        //\n        // One pixel done. Proceed to the next in the MCU. Note that\n        // the lines have been extended such that always a complete MCU is present.\n      } while(--xm && (lp++,pp++,x++,pred = pred->MoveRight(),true));\n      //\n      // Go to the next line.\n    } while(--ym && (pp = line->m_pData + (x = m_ulX[c]),line = (line->m_pNext)?(line->m_pNext):(line),\n                     lp = line->m_pData + x,mcupred = mcupred->MoveDown(),true));\n  }\n#else\n  NOREF(prev);\n  NOREF(top);\n#endif\n}\n///\n\n/// ACLosslessScan::ParseMCU\n// The actual MCU-parser, write a single group of pixels to the stream,\n// or measure their statistics.\nvoid ACLosslessScan::ParseMCU(struct Line **prev,struct Line **top)\n{ \n#if ACCUSOFT_CODE\n  UBYTE c;\n  //\n  // Parse a single MCU, which is now a group of pixels.\n  for(c = 0;c < m_ucCount;c++) {\n    struct QMContextSet &contextset = m_Context[m_ucContext[c]];\n    struct Line *line = top[c];\n    struct Line *pline= prev[c];\n    UBYTE ym = m_ucMCUHeight[c];\n    ULONG  x = m_ulX[c];\n    class PredictorBase *mcupred = m_pPredict[c];\n    LONG *lp = line->m_pData + x;\n    LONG *pp = (pline)?(pline->m_pData + x):(NULL);\n    //\n    // Parse MCUwidth * MCUheight coefficients starting at the line top.\n    do {\n      class PredictorBase *pred = mcupred;\n      UBYTE xm = m_ucMCUWidth[c];\n      do {\n        // Decode now the difference between the predicted value and\n        // the real value.\n        LONG v;\n        //\n        // Get the sign coding context.\n        struct QMContextSet::ContextZeroSet &zset = contextset.ClassifySignZero(m_plDa[c][ym-1],m_plDb[c][x],\n                                                                                m_ucSmall[c],m_ucLarge[c]);\n        //\n        if (m_Coder.Get(zset.S0)) {\n          LONG sz   = 0;\n          bool sign = m_Coder.Get(zset.SS); // true for negative.\n          //\n          if (m_Coder.Get((sign)?(zset.SN):(zset.SP))) {\n            struct QMContextSet::MagnitudeSet &mset = contextset.ClassifyMagnitude(m_plDb[c][x],m_ucLarge[c]);\n            int  i = 0;\n            LONG m = 2;\n            //\n            while(m_Coder.Get(mset.X[i])) {\n              m <<= 1;\n              i++;\n            }\n            //\n            m >>= 1;\n            sz  = m;\n            while((m >>= 1)) {\n              if (m_Coder.Get(mset.M[i])) {\n                sz |= m;\n              }\n            }\n          }\n          //\n          if (sign) {\n            v = -sz - 1;\n          } else {\n            v =  sz + 1;\n          }\n        } else {\n          v = 0;\n        }\n        //\n        // Use the prediction to fill in the sample.\n        lp[0] = pred->DecodeSample(v,lp,pp);\n        // Update Da and Db.\n        // Is this a bug? 32768 does not exist, but -32768 does. The streams\n        // seem to use -32768 instead.\n        m_plDb[c][x]    = v;\n        m_plDa[c][ym-1] = v;\n        //\n        // One pixel done. Proceed to the next in the MCU. Note that\n        // the lines have been extended such that always a complete MCU is present.\n      } while(--xm && (lp++,pp++,x++,pred = pred->MoveRight(),true));\n      //\n      // Go to the next line.\n    } while(--ym && (pp = line->m_pData + (x = m_ulX[c]),line = (line->m_pNext)?(line->m_pNext):(line),\n                     lp = line->m_pData + x,mcupred = mcupred->MoveDown(),true));\n  }\n#else\n  NOREF(prev);\n  NOREF(top);\n#endif\n}\n///\n\n/// ACLosslessScan::WriteMCU\n// Write a single MCU in this scan. Actually, this is not quite true,\n// as we write an entire group of eight lines of pixels, as a MCU is\n// here a group of pixels. But it is more practical this way.\nbool ACLosslessScan::WriteMCU(void)\n{\n#if ACCUSOFT_CODE\n  int i;\n  struct Line *top[4],*prev[4];\n  int lines      = 8; // total number of MCU lines processed.\n  \n  for(i = 0;i < m_ucCount;i++) {\n    class Component *comp = ComponentOf(i);\n    UBYTE idx       = comp->IndexOf();\n    top[i]          = m_pLineCtrl->CurrentLineOf(idx);\n    prev[i]         = m_pLineCtrl->PreviousLineOf(idx);\n    m_ulX[i]        = 0;\n    m_ulY[i]        = m_pLineCtrl->CurrentYOf(idx);\n  }\n\n  // Loop over lines and columns\n  do {\n    do {\n      BeginWriteMCU(m_Coder.ByteStreamOf());\n      //\n      WriteMCU(prev,top);\n    } while(AdvanceToTheRight());\n    //\n    // Reset conditioning to the left\n    for(i = 0;i < m_ucCount;i++) {\n      memset(m_plDa[i],0,sizeof(LONG) * m_ucMCUHeight[i]);\n    }\n    //\n    // Advance to the next line.\n  } while(AdvanceToTheNextLine(prev,top) && --lines);\n#endif\n  return false;\n}\n///\n\n/// ACLosslessScan::ParseMCU\n// Parse a single MCU in this scan. Actually, this is not quite true,\n// as we write an entire group of eight lines of pixels, as a MCU is\n// here a group of pixels. But it is more practical this way.\nbool ACLosslessScan::ParseMCU(void)\n{\n#if ACCUSOFT_CODE\n  int i;\n  struct Line *top[4],*prev[4];\n  int lines      = 8; // total number of MCU lines processed.\n\n  for(i = 0;i < m_ucCount;i++) {\n    class Component *comp = ComponentOf(i);\n    UBYTE idx       = comp->IndexOf();\n    top[i]          = m_pLineCtrl->CurrentLineOf(idx);\n    prev[i]         = m_pLineCtrl->PreviousLineOf(idx);\n    m_ulX[i]        = 0;\n    m_ulY[i]        = m_pLineCtrl->CurrentYOf(idx);\n  }\n\n  // Loop over lines and columns\n  do {\n    bool startofline = true;\n    do {\n      if (BeginReadMCU(m_Coder.ByteStreamOf())) {\n        ParseMCU(prev,top);\n      } else {\n        // Only if this is not due to a DNL marker that has been detected.\n        if (m_ulPixelHeight != 0 && !hasFoundDNL()) {\n          ClearMCU(top);\n        } else if (!startofline) {\n          // The problem is here that the DNL marker might have been detected, even though decoding\n          // is not yet done completely. This may be because there are still just enough bits in the\n          // AC coding engine present to run a single decode. Big Outch! Just continue decoding in\n          // this case.\n          ParseMCU(prev,top);\n        } else break;\n      }\n      startofline = false;\n    } while(AdvanceToTheRight());\n    //\n    // Reset conditioning to the left\n    for(i = 0;i < m_ucCount;i++) {\n      memset(m_plDa[i],0,sizeof(LONG) * m_ucMCUHeight[i]);\n    }\n    // Advance to the next line.\n  } while(AdvanceToTheNextLine(prev,top) && --lines);\n#endif\n  return false; // no further blocks here.\n}\n///\n\n/// ACLosslessScan::StartMCURow\n// Start a MCU scan. Returns true if there are more rows.\nbool ACLosslessScan::StartMCURow(void)\n{\n#if ACCUSOFT_CODE\n  return m_pLineCtrl->StartMCUQuantizerRow(m_pScan);\n#else\n  return false;\n#endif\n}\n///\n\n/// ACLosslessScan::Flush\nvoid ACLosslessScan::Flush(bool)\n{\n#if ACCUSOFT_CODE\n  int i;\n  \n  m_Coder.Flush();\n\n  for(i = 0;i < m_ucCount;i++) {\n    memset(m_plDa[i],0,sizeof(LONG) * m_ucMCUHeight[i]);\n    memset(m_plDb[i],0,sizeof(LONG) * m_ucMCUWidth[i] * m_ulWidth[i]); // Reset conditioning to the top\n  }\n  for(i = 0;i < 4;i++) {\n    m_Context[i].Init();\n  }\n  \n  PredictiveScan::FlushOnMarker();\n  \n  m_Coder.OpenForWrite(m_Coder.ByteStreamOf(),m_Coder.ChecksumOf());\n#endif\n}\n///\n\n/// ACLosslessScan::Restart\n// Restart the parser at the next restart interval\nvoid ACLosslessScan::Restart(void)\n{ \n#if ACCUSOFT_CODE\n  int i;\n  \n  for(i = 0;i < m_ucCount;i++) {\n    memset(m_plDa[i],0,sizeof(LONG) * m_ucMCUHeight[i]);\n    memset(m_plDb[i],0,sizeof(LONG) * m_ucMCUWidth[i] * m_ulWidth[i]);\n  }\n  for(i = 0;i < 4;i++) {\n    m_Context[i].Init();\n  }\n  \n  PredictiveScan::RestartOnMarker();\n\n  m_Coder.OpenForRead(m_Coder.ByteStreamOf(),m_Coder.ChecksumOf());\n#endif\n}\n///\n", "/*************************************************************************\n\n    This project implements a complete(!) JPEG (Recommendation ITU-T\n    T.81 | ISO/IEC 10918-1) codec, plus a library that can be used to\n    encode and decode JPEG streams. \n    It also implements ISO/IEC 18477 aka JPEG XT which is an extension\n    towards intermediate, high-dynamic-range lossy and lossless coding\n    of JPEG. In specific, it supports ISO/IEC 18477-3/-6/-7/-8 encoding.\n\n    Note that only Profiles C and D of ISO/IEC 18477-7 are supported\n    here. Check the JPEG XT reference software for a full implementation\n    of ISO/IEC 18477-7.\n\n    Copyright (C) 2012-2018 Thomas Richter, University of Stuttgart and\n    Accusoft. (C) 2019-2020 Thomas Richter, Fraunhofer IIS.\n\n    This program is available under two licenses, GPLv3 and the ITU\n    Software licence Annex A Option 2, RAND conditions.\n\n    For the full text of the GPU license option, see README.license.gpl.\n    For the full text of the ITU license option, see README.license.itu.\n    \n    You may freely select between these two options.\n\n    For the GPL option, please note the following:\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*************************************************************************/\n/*\n**\n** Represents the lossless scan - lines are coded directly with predictive\n** coding, though here residuals are encoded with the arithmetic encoder.\n**\n** $Id: aclosslessscan.hpp,v 1.28 2014/11/16 15:49:58 thor Exp $\n**\n*/\n\n#ifndef CODESTREAM_ACLOSSLESSSCAN_HPP\n#define CODESTREAM_ACLOSSLESSSCAN_HPP\n\n/// Includes\n#include \"tools/environment.hpp\"\n#include \"coding/qmcoder.hpp\"\n#include \"codestream/entropyparser.hpp\"\n#include \"codestream/predictivescan.hpp\"\n///\n\n/// Forwards\nclass Frame;\nclass LineCtrl;\nclass ByteStream;\nclass LineBitmapRequester;\nclass LineBuffer;\nclass BitmaCtrl;\nclass Scan;\n///\n\n/// class LosslessScan\n// Represents the lossless scan - lines are coded directly with predictive\n// coding, though here residuals are encoded with the arithmetic encoder.\nclass ACLosslessScan : public PredictiveScan {\n  //\n#if ACCUSOFT_CODE\n  // The class used for pulling and pushing data.\n  class LineBuffer          *m_pLineCtrl;\n  //\n  // Small DC threshold value ('L' in the standard)\n  UBYTE                      m_ucSmall[4];\n  //\n  // Large DC threshold value ('U' in the specs)\n  UBYTE                      m_ucLarge[4];\n  //\n  // The context index to use.\n  UBYTE                      m_ucContext[4];\n  //\n  // Differentials from the above and left, used\n  // for prediction.\n  LONG                      *m_plDa[4];\n  LONG                      *m_plDb[4];\n  //\n  // The real worker class.\n  class QMCoder              m_Coder;\n  //\n  // Context information.\n  struct QMContextSet {\n    //\n    // The Zero-Sign coding contexts - this is a 5x5 set.\n    struct ContextZeroSet {\n      QMContext S0,SS,SP,SN;\n      //\n      void Init(void)\n      {\n        S0.Init();\n        SS.Init();\n        SP.Init();\n        SN.Init();\n      }\n    } SignZeroCoding[5][5];\n    //\n    // The Magnitude/refinement coding contexts.\n    struct MagnitudeSet {\n      QMContext X[15];\n      QMContext M[15];\n      //\n      void Init(void)\n      {\n        for(int i = 0;i < 15;i++) {\n          X[i].Init();\n          M[i].Init();\n        }\n      }\n    } MagnitudeLow,MagnitudeHigh;\n    //\n    void Init(void)\n    {\n      for(int i = 0;i <5;i++) {\n        for(int j = 0;j < 5;j++) {\n          SignZeroCoding[i][j].Init();\n        }\n      }\n      MagnitudeLow.Init();\n      MagnitudeHigh.Init();\n    }\n    //\n    // Classify and return the sign/zero coding context to encode the difference in.\n    // Requires the differences in both directions.\n    struct ContextZeroSet &ClassifySignZero(LONG Da,LONG Db,UBYTE l,UBYTE u)\n    {\n      return SignZeroCoding[Classify(Da,l,u) + 2][Classify(Db,l,u) + 2];\n    }\n    //\n    // Classify the Magnitude context \n    struct MagnitudeSet &ClassifyMagnitude(LONG Db,UBYTE u)\n    {\n      if (Db > (1 << u) || -Db > (1 << u)) {\n        return MagnitudeHigh;\n      } else {\n        return MagnitudeLow;\n      }\n    }\n    //\n    // Classifier in one direction.\n    static int Classify(LONG diff,UBYTE l,UBYTE u)\n    {\n      LONG abs = (diff > 0)?(diff):(-diff);\n  \n      if (abs <= ((1 << l) >> 1)) {\n        // the zero cathegory.\n        return 0;\n      }\n      if (abs <= (1 << u)) {\n        if (diff < 0) {\n          return -1;\n        } else {\n          return 1;\n        }\n      }\n      if (diff < 0) {\n        return -2;\n      } else {\n        return 2;\n      }\n    }\n    //\n  } m_Context[4];\n  //\n  // Common setup for encoding and decoding.\n  void FindComponentDimensions(void);\n  //\n#endif\n  // This is actually the true MCU-parser, not the interface that reads\n  // a full line.\n  void ParseMCU(struct Line **prev,struct Line **top);\n  //\n  // The actual MCU-writer, write a single group of pixels to the stream,\n  // or measure their statistics.\n  void WriteMCU(struct Line **prev,struct Line **top);\n  //\n  // Flush the remaining bits out to the stream on writing.\n  virtual void Flush(bool final); \n  // \n  // Restart the parser at the next restart interval\n  virtual void Restart(void);\n  //\n  //\npublic:\n  ACLosslessScan(class Frame *frame,class Scan *scan,UBYTE predictor,UBYTE lobit,\n                 bool differential = false);\n  //\n  virtual ~ACLosslessScan(void);\n  //\n  // Write the marker that indicates the frame type fitting to this scan.\n  virtual void WriteFrameType(class ByteStream *io);\n  //\n  // Fill in the tables for decoding and decoding parameters in general.\n  virtual void StartParseScan(class ByteStream *io,class Checksum *chk,class BufferCtrl *ctrl);\n  //\n  // Write the default tables for encoding\n  virtual void StartWriteScan(class ByteStream *io,class Checksum *chk,class BufferCtrl *ctrl);\n  //\n  // Start the measurement run - not required here.\n  virtual void StartMeasureScan(class BufferCtrl *ctrl);\n  //\n  // Start a MCU scan. Returns true if there are more rows. False otherwise.\n  // Note that we emulate here that MCUs are multiples of eight lines high\n  // even though from a JPEG perspective a MCU is a single pixel in the\n  // lossless coding case.\n  virtual bool StartMCURow(void);\n  //\n  // Parse a single MCU in this scan. Return true if there are more\n  // MCUs in this row.\n  virtual bool ParseMCU(void);\n  //\n  // Write a single MCU in this scan.\n  virtual bool WriteMCU(void);  \n};\n///\n\n\n///\n#endif\n", "/*************************************************************************\n\n    This project implements a complete(!) JPEG (Recommendation ITU-T\n    T.81 | ISO/IEC 10918-1) codec, plus a library that can be used to\n    encode and decode JPEG streams. \n    It also implements ISO/IEC 18477 aka JPEG XT which is an extension\n    towards intermediate, high-dynamic-range lossy and lossless coding\n    of JPEG. In specific, it supports ISO/IEC 18477-3/-6/-7/-8 encoding.\n\n    Note that only Profiles C and D of ISO/IEC 18477-7 are supported\n    here. Check the JPEG XT reference software for a full implementation\n    of ISO/IEC 18477-7.\n\n    Copyright (C) 2012-2018 Thomas Richter, University of Stuttgart and\n    Accusoft. (C) 2019-2020 Thomas Richter, Fraunhofer IIS.\n\n    This program is available under two licenses, GPLv3 and the ITU\n    Software licence Annex A Option 2, RAND conditions.\n\n    For the full text of the GPU license option, see README.license.gpl.\n    For the full text of the ITU license option, see README.license.itu.\n    \n    You may freely select between these two options.\n\n    For the GPL option, please note the following:\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*************************************************************************/\n/*\n**\n** Represents the scan including the scan header.\n**\n** $Id: acsequentialscan.cpp,v 1.51 2016/10/28 13:58:53 thor Exp $\n**\n*/\n\n/// Includes\n#include \"codestream/acsequentialscan.hpp\"\n#include \"codestream/tables.hpp\"\n#include \"marker/frame.hpp\"\n#include \"marker/scan.hpp\"\n#include \"marker/component.hpp\"\n#include \"coding/quantizedrow.hpp\"\n#include \"codestream/rectanglerequest.hpp\"\n#include \"dct/dct.hpp\"\n#include \"std/assert.hpp\"\n#include \"interface/bitmaphook.hpp\"\n#include \"interface/imagebitmap.hpp\"\n#include \"colortrafo/colortrafo.hpp\"\n#include \"tools/traits.hpp\"\n#include \"control/blockbitmaprequester.hpp\"\n#include \"control/blockbuffer.hpp\"\n#include \"control/blocklineadapter.hpp\"\n#include \"coding/actemplate.hpp\"\n#include \"marker/actable.hpp\"\n///\n\n/// ACSequentialScan::ACSequentialScan\nACSequentialScan::ACSequentialScan(class Frame *frame,class Scan *scan,\n                                   UBYTE start,UBYTE stop,UBYTE lowbit,UBYTE,\n                                   bool differential,bool residual,bool large)\n  : EntropyParser(frame,scan)\n#if ACCUSOFT_CODE\n  , m_pBlockCtrl(NULL),\n    m_ucScanStart(start), m_ucScanStop(stop), m_ucLowBit(lowbit),\n    m_bMeasure(false), m_bDifferential(differential), m_bResidual(residual), m_bLargeRange(large)\n#endif\n{\n#if ACCUSOFT_CODE\n  m_ucCount = scan->ComponentsInScan();\n  \n  for(UBYTE i = 0;i < m_ucCount;i++) {\n    m_ucSmall[i]     = 0;\n    m_ucLarge[i]     = 1;\n    m_ucBlockEnd[i]  = 5;\n  }\n#else\n  NOREF(start);\n  NOREF(stop);\n  NOREF(lowbit);\n  NOREF(differential);\n  NOREF(residual);\n  NOREF(large);\n#endif\n}\n///\n\n/// ACSequentialScan::~ACSequentialScan\nACSequentialScan::~ACSequentialScan(void)\n{\n}\n///\n\n/// ACSequentialScan::StartParseScan\nvoid ACSequentialScan::StartParseScan(class ByteStream *io,class Checksum *chk,class BufferCtrl *ctrl)\n{ \n#if ACCUSOFT_CODE\n  class ACTemplate *ac,*dc;\n  int i;\n\n  for(i = 0;i < m_ucCount;i++) {\n    dc = m_pScan->DCConditionerOf(i);\n    ac = m_pScan->ACConditionerOf(i); \n    \n    m_ucDCContext[i]  = m_pScan->DCTableIndexOf(i);\n    m_ucACContext[i]  = m_pScan->ACTableIndexOf(i);\n\n    if (dc) {\n      m_ucSmall[i]    = dc->LowerThresholdOf();\n      m_ucLarge[i]    = dc->UpperThresholdOf();\n    } else {\n      m_ucSmall[i]    = 0;\n      m_ucLarge[i]    = 1;\n    }\n\n    if (ac) {\n      m_ucBlockEnd[i] = ac->BandDiscriminatorOf();\n    } else {\n      m_ucBlockEnd[i] = 5;\n    }\n\n    m_lDC[i]         = 0; \n    m_lDiff[i]       = 0;\n    m_ulX[i]         = 0;\n  }\n  \n  for(i = 0;i < 4;i++) {\n    m_Context[i].Init();\n  }\n  \n  assert(!ctrl->isLineBased());\n  m_pBlockCtrl = dynamic_cast<BlockCtrl *>(ctrl);\n  m_pBlockCtrl->ResetToStartOfScan(m_pScan);\n  m_Coder.OpenForRead(io,chk);\n#else\n  NOREF(io);\n  NOREF(chk);\n  NOREF(ctrl);\n  JPG_THROW(NOT_IMPLEMENTED,\"ACSequentialScan::StartParseScan\",\n            \"Lossless JPEG not available in your code release, please contact Accusoft for a full version\");\n#endif\n}\n///\n\n/// ACSequentialScan::StartWriteScan\nvoid ACSequentialScan::StartWriteScan(class ByteStream *io,class Checksum *chk,class BufferCtrl *ctrl)\n{ \n#if ACCUSOFT_CODE\n  class ACTemplate *ac,*dc;\n  int i;\n\n  for(i = 0;i < m_ucCount;i++) {\n    dc = m_pScan->DCConditionerOf(i);\n    ac = m_pScan->ACConditionerOf(i);\n   \n    m_ucDCContext[i]  = m_pScan->DCTableIndexOf(i);\n    m_ucACContext[i]  = m_pScan->ACTableIndexOf(i);\n\n    if (dc) {\n      m_ucSmall[i]    = dc->LowerThresholdOf();\n      m_ucLarge[i]    = dc->UpperThresholdOf();\n    } else {\n      m_ucSmall[i]    = 0;\n      m_ucLarge[i]    = 1;\n    }\n\n    if (ac) {\n      m_ucBlockEnd[i] = ac->BandDiscriminatorOf();\n    } else {\n      m_ucBlockEnd[i] = 5;\n    }\n\n    m_lDC[i]           = 0;\n    m_lDiff[i]         = 0;\n    m_ulX[i]           = 0;\n  }\n  for(i = 0;i < 4;i++) {\n    m_Context[i].Init();\n  }\n\n  assert(!ctrl->isLineBased());\n  m_pBlockCtrl = dynamic_cast<BlockCtrl *>(ctrl);\n  m_pBlockCtrl->ResetToStartOfScan(m_pScan);\n\n  EntropyParser::StartWriteScan(io,chk,ctrl);\n\n  m_pScan->WriteMarker(io);\n  m_Coder.OpenForWrite(io,chk);\n#else\n  NOREF(io);\n  NOREF(chk);\n  NOREF(ctrl);\n  JPG_THROW(NOT_IMPLEMENTED,\"ACSequentialScan::StartWriteScan\",\n            \"Lossless JPEG not available in your code release, please contact Accusoft for a full version\");\n#endif\n}\n///\n\n/// ACSequentialScan::StartMeasureScan\n// Measure scan statistics.\nvoid ACSequentialScan::StartMeasureScan(class BufferCtrl *)\n{ \n  //\n  // This is not required.\n  JPG_THROW(NOT_IMPLEMENTED,\"ACSequentialScan::StartMeasureScan\",\n            \"arithmetic coding is always adaptive and does not require \"\n            \"to measure the statistics\");\n}\n///\n\n/// ACSequentialScan::StartMCURow\n// Start a MCU scan. Returns true if there are more rows.\nbool ACSequentialScan::StartMCURow(void)\n{\n#if ACCUSOFT_CODE\n  bool more = m_pBlockCtrl->StartMCUQuantizerRow(m_pScan);\n\n  for(int i = 0;i < m_ucCount;i++) {\n    m_ulX[i]   = 0;\n  }\n\n  return more;\n#else\n  return false;\n#endif\n}\n///\n\n/// ACSequentialScan::WriteMCU\n// Write a single MCU in this scan. Return true if there are more blocks in this row.\nbool ACSequentialScan::WriteMCU(void)\n{ \n#if ACCUSOFT_CODE\n  bool more = true;\n  int c;\n\n  assert(m_pBlockCtrl);\n  \n  BeginWriteMCU(m_Coder.ByteStreamOf());\n\n  for(c = 0;c < m_ucCount;c++) {\n    class Component *comp    = m_pComponent[c];\n    class QuantizedRow *q    = m_pBlockCtrl->CurrentQuantizedRow(comp->IndexOf());\n    LONG &prevdc             = m_lDC[c];\n    LONG &prevdiff           = m_lDiff[c];\n    UBYTE l                  = m_ucSmall[c];\n    UBYTE u                  = m_ucLarge[c];\n    UBYTE kx                 = m_ucBlockEnd[c];\n    UBYTE mcux               = (m_ucCount > 1)?(comp->MCUWidthOf() ):(1);\n    UBYTE mcuy               = (m_ucCount > 1)?(comp->MCUHeightOf()):(1);\n    ULONG xmin               = m_ulX[c];\n    ULONG xmax               = xmin + mcux;\n    ULONG x,y; \n    if (xmax >= q->WidthOf()) {\n      more     = false;\n    }\n    for(y = 0;y < mcuy;y++) {\n      for(x = xmin;x < xmax;x++) {\n        LONG *block,dummy[64];\n        if (q && x < q->WidthOf()) {\n          block  = q->BlockAt(x)->m_Data;\n        } else {\n          block  = dummy;\n          memset(dummy ,0,sizeof(dummy) );\n          block[0] = prevdc;\n        }\n        EncodeBlock(block,prevdc,prevdiff,l,u,kx,m_ucDCContext[c],m_ucACContext[c]);\n      }\n      if (q) q = q->NextOf();\n    }\n    // Done with this component, advance the block.\n    m_ulX[c] = xmax;\n  }\n\n  return more;\n#else\n  return false;\n#endif\n}\n///\n\n/// ACSequentialScan::Restart\n// Restart the parser at the next restart interval\nvoid ACSequentialScan::Restart(void)\n{\n#if ACCUSOFT_CODE\n  int i;\n  \n  for(i = 0;i < m_ucCount;i++) {\n    m_lDC[i]         = 0; \n    m_lDiff[i]       = 0;\n  }\n  for(i = 0;i < 4;i++) {\n    m_Context[i].Init();\n  }\n  \n  m_Coder.OpenForRead(m_Coder.ByteStreamOf(),m_Coder.ChecksumOf());\n#endif\n}\n///\n\n/// ACSequentialScan::ParseMCU\n// Parse a single MCU in this scan. Return true if there are more blocks in this row.\nbool ACSequentialScan::ParseMCU(void)\n{\n#if ACCUSOFT_CODE\n  bool more = true;\n  int c;\n\n  assert(m_pBlockCtrl);\n\n  bool valid = BeginReadMCU(m_Coder.ByteStreamOf());\n  \n  for(c = 0;c < m_ucCount;c++) {\n    class Component *comp    = m_pComponent[c];\n    class QuantizedRow *q    = m_pBlockCtrl->CurrentQuantizedRow(comp->IndexOf());\n    LONG &prevdc             = m_lDC[c];\n    LONG &prevdiff           = m_lDiff[c];\n    UBYTE l                  = m_ucSmall[c];\n    UBYTE u                  = m_ucLarge[c];\n    UBYTE kx                 = m_ucBlockEnd[c];\n    UBYTE mcux               = (m_ucCount > 1)?(comp->MCUWidthOf() ):(1);\n    UBYTE mcuy               = (m_ucCount > 1)?(comp->MCUHeightOf()):(1);\n    ULONG xmin               = m_ulX[c];\n    ULONG xmax               = xmin + mcux;\n    ULONG x,y;\n    if (xmax >= q->WidthOf()) {\n      more     = false;\n    }\n    for(y = 0;y < mcuy;y++) {\n      for(x = xmin;x < xmax;x++) {\n        LONG *block,dummy[64];\n        if (q && x < q->WidthOf()) {\n          block  = q->BlockAt(x)->m_Data;\n        } else {\n          block  = dummy;\n        }\n        if (valid) {\n          DecodeBlock(block,prevdc,prevdiff,l,u,kx,m_ucDCContext[c],m_ucACContext[c]);\n        } else {\n          for(UBYTE i = m_ucScanStart;i <= m_ucScanStop;i++) {\n            block[i] = 0;\n          }\n        }\n      }\n      if (q) q = q->NextOf();\n    }\n    // Done with this component, advance the block.\n    m_ulX[c] = xmax;\n  }\n\n  return more;\n#else\n  return false;\n#endif\n}\n///\n\n/// ACSequentialScan::Classify\n// Find the DC context class depending on the previous DC and\n// the values of L and U given in the conditioner.\n#if ACCUSOFT_CODE\nstruct ACSequentialScan::QMContextSet::DCContextZeroSet &ACSequentialScan::QMContextSet::Classify(LONG diff,UBYTE l,UBYTE u)\n{\n  LONG abs = (diff > 0)?(diff):(-diff);\n  \n  if (abs <= ((1 << l) >> 1)) {\n    // the zero cathegory.\n    return DCZero;\n  }\n  if (abs <= (1 << u)) {\n    if (diff < 0) {\n      return DCSmallNegative;\n    } else {\n      return DCSmallPositive;\n    }\n  }\n  if (diff < 0) {\n    return DCLargeNegative;\n  } else {\n    return DCLargePositive;\n  }\n}\n#endif\n///\n\n/// ACSequentialScan::EncodeBlock\n// Encode a single block\n#if ACCUSOFT_CODE\nvoid ACSequentialScan::EncodeBlock(const LONG *block,\n                                   LONG &prevdc,LONG &prevdiff,\n                                   UBYTE small,UBYTE large,UBYTE kx,UBYTE dc,UBYTE ac)\n{\n  // DC coding\n  if (m_ucScanStart == 0 && m_bResidual == false) {\n    struct QMContextSet::DCContextZeroSet &cz = m_Context[dc].Classify(prevdiff,small,large);\n    LONG diff;\n    // DPCM coding of the DC coefficient.\n    diff   = block[0] >> m_ucLowBit; // only correct for two's completement machines\n    diff  -= prevdc;\n    if (m_bDifferential) {\n      prevdc = 0;\n    } else {\n      prevdc = block[0] >> m_ucLowBit;\n    }\n\n    if (diff) {\n      LONG sz;\n      //\n      // Nonzero, encode a one in context zero.\n      m_Coder.Put(cz.S0,true);\n      //\n      // Sign coding. Encode a zero for positive and a 1 for\n      // negative.\n      if (diff < 0) {\n        m_Coder.Put(cz.SS,true);\n        sz = -diff - 1;\n      } else {\n        m_Coder.Put(cz.SS,false);\n        sz = diff - 1;\n      }\n      //\n      // Code the magnitude.\n      if (sz >= 1) {\n        int  i = 0;\n        LONG m = 2;\n        m_Coder.Put((diff > 0)?(cz.SP):(cz.SN),true);\n        //\n        // Magnitude category coding.\n        while(sz >= m) {\n          m_Coder.Put(m_Context[dc].DCMagnitude.X[i],true);\n          m <<= 1;\n          i++;\n        } \n        // Terminate magnitude cathegory coding.\n        m_Coder.Put(m_Context[dc].DCMagnitude.X[i],false);\n        //\n        // Get the MSB to code.\n        m >>= 1;\n        // Refinement bits: Depend on the magnitude category.\n        while((m >>= 1)) {\n          m_Coder.Put(m_Context[dc].DCMagnitude.M[i],(m & sz)?(true):(false));\n        }\n      } else {\n        m_Coder.Put((diff > 0)?(cz.SP):(cz.SN),false);\n      }\n    } else {\n      // Difference is zero. Encode a zero in context zero.\n      m_Coder.Put(cz.S0,false);\n    }\n    // Keep the difference for the next block.\n    prevdiff = diff;\n  }\n\n  if (m_ucScanStop) {\n    LONG data;\n    int eob,k;\n    // AC coding. Part one. Find the end of block.\n    // eob is the index of the first zero coefficient from\n    // which point on this, and all following coefficients\n    // up to coefficient with index 63 are zero.\n    eob = m_ucScanStop;\n    k   = (m_ucScanStart)?(m_ucScanStart):((m_bResidual)?0:1);\n    //\n    while(eob >= k) {\n      data = block[DCT::ScanOrder[eob]];\n      if ((data >= 0)?(data >> m_ucLowBit):((-data) >> m_ucLowBit))\n        break;\n      eob--;\n    }\n    // The coefficient at eob is now nonzero, but eob+1 is\n    // a zero coefficient or beyond the block end.\n    eob++; // the first coefficient *not* to code.\n\n    do {\n      LONG data,sz;\n      //\n      if (k == eob) {\n        m_Coder.Put(m_Context[ac].ACZero[k-1].SE,true); // Code EOB.\n        break;\n      }\n      // Not EOB.\n      m_Coder.Put(m_Context[ac].ACZero[k-1].SE,false);\n      //\n      // Run coding in S0. Since k is not the eob, at least\n      // one non-zero coefficient must follow, so we cannot\n      // run over the end of the block.\n      do {\n        data = block[DCT::ScanOrder[k]];\n        data = (data >= 0)?(data >> m_ucLowBit):(-((-data) >> m_ucLowBit));\n        if (data == 0) {\n          m_Coder.Put(m_Context[ac].ACZero[k-1].S0,false);\n          k++;\n        }\n      } while(data == 0);\n      m_Coder.Put(m_Context[ac].ACZero[k-1].S0,true);\n      //\n      // The coefficient at k is now nonzero. First code\n      // the sign. This context is the uniform.\n      if (data < 0) {\n        m_Coder.Put(m_Context[ac].Uniform,true);\n        sz = -data - 1;\n      } else {\n        m_Coder.Put(m_Context[ac].Uniform,false);\n        sz =  data - 1;\n      }\n      //\n      // Code the magnitude category. \n      if (sz >= 1) {\n        m_Coder.Put(m_Context[ac].ACZero[k-1].SP,true); // SP or SN coding.\n        if (sz >= 2) {\n          int  i = 0;\n          LONG m = 4;\n          struct QMContextSet::ACContextMagnitudeSet &acm = (k > kx)?(m_Context[ac].ACMagnitudeHigh):(m_Context[ac].ACMagnitudeLow);\n          //\n          m_Coder.Put(m_Context[ac].ACZero[k-1].SP,true); // X1 coding, identical to SN and SP.\n          // Note that AC_SN,AC_SP and AC_X1 are all the same context\n          // all following decisions are not conditioned on k directly.\n          while(sz >= m) {\n            m_Coder.Put(acm.X[i],true);\n            m <<= 1;\n            i++;\n          }\n          m_Coder.Put(acm.X[i],false);\n          //\n          // Get the MSB to code.\n          m >>= 1;\n          //\n          // Magnitude refinement coding.\n          while((m >>= 1)) {\n            m_Coder.Put(acm.M[i],(m & sz)?true:false);\n          }\n        } else {\n          m_Coder.Put(m_Context[ac].ACZero[k-1].SP,false);\n        }\n      } else {\n        m_Coder.Put(m_Context[ac].ACZero[k-1].SP,false);\n      }\n      //\n      // Encode the next coefficient. Note that this bails out early without an\n      // S0 encoding if the end is reached.\n    } while(++k <= m_ucScanStop);\n  }\n}\n#endif\n///\n\n/// ACSequentialScan::DecodeBlock\n// Decode a single block.\n#if ACCUSOFT_CODE\nvoid ACSequentialScan::DecodeBlock(LONG *block,\n                                   LONG &prevdc,LONG &prevdiff,\n                                   UBYTE small,UBYTE large,UBYTE kx,UBYTE dc,UBYTE ac)\n{\n  // DC coding\n  if (m_ucScanStart == 0 && m_bResidual == false) {\n    LONG diff;\n    struct QMContextSet::DCContextZeroSet &cz = m_Context[dc].Classify(prevdiff,small,large);\n    // Check whether the difference is nonzero.\n    if (m_Coder.Get(cz.S0)) {\n      LONG sz;\n      bool sign = m_Coder.Get(cz.SS); // sign coding, is true for negative.\n      //\n      //\n      // Positive and negative are encoded in different contexts.\n      // Decode the magnitude cathegory.\n      if (m_Coder.Get((sign)?(cz.SN):(cz.SP))) {\n        int  i = 0;\n        LONG m = 2;\n        \n        while(m_Coder.Get(m_Context[dc].DCMagnitude.X[i])) {\n          m <<= 1;\n          i++;\n          if (m == 0) \n            JPG_THROW(MALFORMED_STREAM,\"ACSequentialScan::DecodeBlock\",\n                      \"QMDecoder is out of sync\");\n        }\n        //\n        // Get the MSB to decode.\n        m >>= 1;\n        sz  = m;\n        //\n        // Refinement coding of remaining bits.\n        while((m >>= 1)) {\n          if (m_Coder.Get(m_Context[dc].DCMagnitude.M[i])) {\n            sz |= m;\n          }\n        }\n      } else {\n        sz = 0;\n      }\n      //\n      // Done, finally, include the sign and the offset.\n      if (sign) {\n        diff = -sz - 1;\n      } else {\n        diff = sz + 1;\n      }\n    } else {\n      // Difference is zero.\n      diff = 0;\n    }\n\n    prevdiff = diff;\n    if (m_bDifferential) {\n      prevdc   = diff;\n    } else {\n      prevdc  += diff;\n    }\n    block[0] = prevdc << m_ucLowBit; // point transformation\n  }\n\n  if (m_ucScanStop) {\n    // AC coding. No block skipping used here.\n    int k = (m_ucScanStart)?(m_ucScanStart):((m_bResidual)?0:1);\n    //\n    // EOB decoding.\n    while(k <= m_ucScanStop && !m_Coder.Get(m_Context[ac].ACZero[k-1].SE)) {\n      LONG sz;\n      bool sign;\n      //\n      // Not yet EOB. Run coding in S0: Skip over zeros.\n      while(!m_Coder.Get(m_Context[ac].ACZero[k-1].S0)) {\n        k++;\n        if (k > m_ucScanStop)\n          JPG_THROW(MALFORMED_STREAM,\"ACSequentialScan::DecodeBlock\",\n                    \"QMDecoder is out of sync\");\n      }\n      //\n      // Now decode the sign of the coefficient.\n      // This happens in the uniform context.\n      sign = m_Coder.Get(m_Context[ac].Uniform);\n      //\n      // Decode the magnitude.\n      if (m_Coder.Get(m_Context[ac].ACZero[k-1].SP)) {\n        // X1 coding, identical to SN and SP.\n        if (m_Coder.Get(m_Context[ac].ACZero[k-1].SP)) {\n          int  i = 0;\n          LONG m = 4;\n          struct QMContextSet::ACContextMagnitudeSet &acm = (k > kx)?(m_Context[ac].ACMagnitudeHigh):(m_Context[ac].ACMagnitudeLow);\n          \n          while(m_Coder.Get(acm.X[i])) {\n            m <<= 1;\n            i++;\n            if (m == 0)\n              JPG_THROW(MALFORMED_STREAM,\"ACSequentialScan::DecodeBlock\",\n                        \"QMDecoder is out of sync\");\n          }\n          //\n          // Get the MSB to decode\n          m >>= 1;\n          sz  = m;\n          //\n          // Proceed to refinement.\n          while((m >>= 1)) {\n            if (m_Coder.Get(acm.M[i])) {\n              sz |= m;\n            }\n          }\n        } else {\n          sz = 1;\n        }\n      } else {\n        sz = 0;\n      }\n      //\n      // Done. Finally, include sign and offset.\n      sz++;\n      if (sign) \n        sz = -sz;\n      block[DCT::ScanOrder[k]] = sz << m_ucLowBit;\n      //\n      // Proceed to the next block.\n      k++;\n    }\n  }\n}\n#endif\n///\n\n/// ACSequentialScan::WriteFrameType\n// Write the marker that indicates the frame type fitting to this scan.\nvoid ACSequentialScan::WriteFrameType(class ByteStream *io)\n{\n#if ACCUSOFT_CODE\n  UBYTE hidden = m_pFrame->TablesOf()->HiddenDCTBitsOf();\n\n  if (m_ucScanStart > 0 || m_ucScanStop < 63 || m_ucLowBit > hidden) {\n    // is progressive.\n    if (m_bResidual) {\n      io->PutWord(0xffba); // progressive sequential\n    } else {\n      if (m_bDifferential) {\n        io->PutWord(0xffce);\n      } else {\n        io->PutWord(0xffca);\n      }\n    }\n  } else {\n    if (m_bResidual) {\n      io->PutWord(0xffb9); // residual AC sequential\n    } else if (m_bDifferential) {\n      io->PutWord(0xffcd); // AC differential sequential\n    } else if (m_bLargeRange) {\n      io->PutWord(0xffbb);\n    } else {\n      io->PutWord(0xffc9); // AC sequential\n    }\n  }\n#else\n  NOREF(io);\n#endif\n}\n///\n\n/// ACSequentialScan::Flush\n// Flush the remaining bits out to the stream on writing.\nvoid ACSequentialScan::Flush(bool)\n{\n#if ACCUSOFT_CODE\n  int i;\n  \n  m_Coder.Flush();\n\n  for(i = 0;i < m_ucCount;i++) {\n    m_lDC[i]    = 0;\n    m_lDiff[i]  = 0;\n  }\n  for(i = 0;i < 4;i++) {\n    m_Context[i].Init();\n  }\n  \n  m_Coder.OpenForWrite(m_Coder.ByteStreamOf(),m_Coder.ChecksumOf());\n#endif\n}\n///\n\n/// ACSequentialScan::OptimizeBlock\n// Make an R/D optimization for the given scan by potentially pushing\n// coefficients into other bins. \nvoid ACSequentialScan::OptimizeBlock(LONG, LONG, UBYTE ,double ,\n                                     class DCT *,LONG [64])\n{\n  JPG_THROW(NOT_IMPLEMENTED,\"ACSequentialScan::OptimizeBlock\",\n            \"Rate-distortion optimization is not implemented for arithmetic coding\");\n}\n///\n\n/// ACSequentialScan::OptimizeDC\n// Make an R/D optimization for the given scan by potentially pushing\n// coefficients into other bins. \nvoid ACSequentialScan::OptimizeDC(void)\n{\n  JPG_THROW(NOT_IMPLEMENTED,\"ACSequentialScan::OptimizeDC\",\n            \"Rate-distortion optimization is not implemented for arithmetic coding\");\n}\n///\n\n/// ACSequentialScan::StartOptimizeScan\n// Start making an optimization run to adjust the coefficients.\nvoid ACSequentialScan::StartOptimizeScan(class BufferCtrl *)\n{  \n  JPG_THROW(NOT_IMPLEMENTED,\"ACSequentialScan::StartOptimizeScan\",\n            \"Rate-distortion optimization is not implemented for arithmetic coding\");\n}\n///\n", "/*************************************************************************\n\n    This project implements a complete(!) JPEG (Recommendation ITU-T\n    T.81 | ISO/IEC 10918-1) codec, plus a library that can be used to\n    encode and decode JPEG streams. \n    It also implements ISO/IEC 18477 aka JPEG XT which is an extension\n    towards intermediate, high-dynamic-range lossy and lossless coding\n    of JPEG. In specific, it supports ISO/IEC 18477-3/-6/-7/-8 encoding.\n\n    Note that only Profiles C and D of ISO/IEC 18477-7 are supported\n    here. Check the JPEG XT reference software for a full implementation\n    of ISO/IEC 18477-7.\n\n    Copyright (C) 2012-2018 Thomas Richter, University of Stuttgart and\n    Accusoft. (C) 2019-2020 Thomas Richter, Fraunhofer IIS.\n\n    This program is available under two licenses, GPLv3 and the ITU\n    Software licence Annex A Option 2, RAND conditions.\n\n    For the full text of the GPU license option, see README.license.gpl.\n    For the full text of the ITU license option, see README.license.itu.\n    \n    You may freely select between these two options.\n\n    For the GPL option, please note the following:\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*************************************************************************/\n/*\n**\n** Represents the scan including the scan header for the\n** arithmetic coding procedure.\n**\n** $Id: acsequentialscan.hpp,v 1.38 2016/10/28 13:58:53 thor Exp $\n**\n*/\n\n#ifndef CODESTREAM_ACSEQUENTIALSCAN_HPP\n#define CODESTREAM_ACSEQUENTIALSCAN_HPP\n\n/// Includes\n#include \"tools/environment.hpp\"\n#include \"coding/qmcoder.hpp\"\n#include \"coding/quantizedrow.hpp\"\n#include \"codestream/entropyparser.hpp\"\n///\n\n/// Forwards\nclass Tables;\nclass ByteStream;\nclass DCT;\nclass Frame;\nstruct RectangleRequest;\nclass BitmapCtrl;\nclass LineAdapter;\nclass BufferCtrl;\nclass BlockBuffer;\nclass BlockCtrl;\n///\n\n/// class ACSequentialScan\nclass ACSequentialScan : public EntropyParser {\n  //\n#if ACCUSOFT_CODE\n  //\n  // The QM coder doing the main work here.\n  class QMCoder            m_Coder;\n  //\n  // Last DC value, required for the DPCM coder.\n  LONG                     m_lDC[4];\n  //\n  // Last difference value, required for selecting the\n  // AC coding context.\n  LONG                     m_lDiff[4];\n  //\n  // Context information\n  struct QMContextSet {\n    //\n    // The DC Coding context set.\n    struct DCContextZeroSet {\n      QMContext S0,SS,SP,SN;\n      //\n      // Initialize\n#ifdef DEBUG_QMCODER  \n      void Init(const char *base)\n      {\n        char string[5] = \"Z0S0\";\n        memcpy(string,base,2);\n        S0.Init(string);\n        string[3] = 'S';\n        SS.Init(string);\n        string[3] = 'P';\n        SP.Init(string);\n        string[3] = 'N';\n        SN.Init(string);\n      }\n#else\n      void Init(void)\n      {\n        S0.Init();\n        SS.Init();\n        SP.Init();\n        SN.Init();\n      }\n#endif\n      //\n    } DCZero,DCSmallPositive,DCSmallNegative,DCLargePositive,DCLargeNegative;\n    //\n    // The DC Magnitude coding contexts.\n    struct DCContextMagnitudeSet {\n      QMContext X[19];\n      QMContext M[19];\n      //\n      // Initialize\n      void Init(void)\n      {\n        for(int i = 0;i < 19;i++) {\n#ifdef DEBUG_QMCODER\n          char string[5] = \"X0  \";\n          string[1] = (i / 10) + '0';\n          string[2] = (i % 10) + '0';\n          X[i].Init(string);\n          string[0] = 'M';\n          M[i].Init(string);\n#else\n          X[i].Init();\n          M[i].Init();\n#endif\n        }\n      }\n    } DCMagnitude;\n    //\n    // The AC Coding Contexts.\n    struct ACContextZeroSet {\n      QMContext SE,S0,SP;\n      //\n      // Initialize.\n#ifdef DEBUG_QMCODER\n      void Init(int i)\n      {\n        char string[5] = \"se00\";\n        string[2] = (i / 10) + '0';\n        string[3] = (i % 10) + '0';\n        SE.Init(string);\n        string[1] = '0';\n        S0.Init(string);\n        string[1] = 'p';\n        SP.Init(string);\n      }\n#else\n      void Init(void)\n      {\n        SE.Init();\n        S0.Init();\n        SP.Init();\n      }\n#endif\n    } ACZero[63];\n    //\n    // The AC Magnitude coder.\n    struct ACContextMagnitudeSet {\n      QMContext X[18];\n      QMContext M[18];\n      //\n\n#ifdef DEBUG_QMCODER\n      void Init(bool hi) \n      {\n        for(int i = 0;i < 18;i++) {\n          char string[5] = \"xl00\";\n          string[1] = (hi)?('h'):('l');\n          string[2] = (i / 10) + '0';\n          string[3] = (i % 10) + '0';\n          X[i].Init(string);\n          string[0] = 'm';\n          M[i].Init(string);\n        }\n      }\n#else\n      void Init(void)\n      {\n        for(int i = 0;i < 18;i++) {\n          X[i].Init();\n          M[i].Init();\n        }\n      }\n#endif\n    } ACMagnitudeLow,ACMagnitudeHigh; // Exists only twice.\n    //\n    // The uniform context.\n    QMContext Uniform;\n    //\n    // Initialize the full beast.\n    void Init(void)\n    {\n#ifdef DEBUG_QMCODER \n      DCZero.Init(\"Z0\");\n      DCSmallPositive.Init(\"L+\");\n      DCSmallNegative.Init(\"L-\");\n      DCLargePositive.Init(\"U+\");\n      DCLargeNegative.Init(\"U-\");      \n#else\n      DCZero.Init();\n      DCSmallPositive.Init();\n      DCSmallNegative.Init();\n      DCLargePositive.Init();\n      DCLargeNegative.Init();\n#endif\n      DCMagnitude.Init();\n      DCMagnitude.Init();\n      for(int i = 0;i < 63;i++) {\n#ifdef DEBUG_QMCODER\n        ACZero[i].Init(i);\n#else\n        ACZero[i].Init();\n#endif\n      }\n#ifdef DEBUG_QMCODER\n      ACMagnitudeLow.Init(false);\n      ACMagnitudeHigh.Init(true);\n#else\n      ACMagnitudeLow.Init();\n      ACMagnitudeHigh.Init();\n#endif\n#ifdef DEBUG_QMCODER\n      Uniform.Init(QMCoder::Uniform_State,\"uni \");\n#else\n      Uniform.Init(QMCoder::Uniform_State);\n#endif\n    }  \n    //\n    // Classify the DC difference into five categories, return it.\n    struct DCContextZeroSet &Classify(LONG diff,UBYTE l,UBYTE u);\n    //\n  } m_Context[4];\n  //\n  // \nprotected:\n  //\n  // The block control helper that maintains all the request/release\n  // logic and the interface to the user.\n  class BlockCtrl            *m_pBlockCtrl;\n  //\n  // Scan positions.\n  ULONG                       m_ulX[4];\n  //\n  // Scan parameters.\n  UBYTE                       m_ucScanStart;\n  UBYTE                       m_ucScanStop;\n  UBYTE                       m_ucLowBit; \n  //\n  // AC conditioners, one per component.\n  //\n  // Context numbers to use for the conditional.\n  UBYTE                       m_ucDCContext[4];\n  UBYTE                       m_ucACContext[4];\n  //\n  // Small DC threshold value ('L' in the standard)\n  UBYTE                       m_ucSmall[4];\n  //\n  // Large DC threshold value ('U' in the specs)\n  UBYTE                       m_ucLarge[4];\n  //\n  // Higher block index discrimination ('kx' in the specs)\n  UBYTE                       m_ucBlockEnd[4]; \n  //\n  // Will always be false as there is no reason to measure anything.\n  // This is only here to satisfy the expected interface of the\n  // residual scan.\n  bool                        m_bMeasure;\n  //\n  // Set if this is a differential scan.\n  bool                        m_bDifferential;\n  //\n  // Set if this is a residual scan.\n  bool                        m_bResidual;\n  //\n  // Set if this is a large range scan.\n  bool                        m_bLargeRange;\n  //\n  // Encode a single block\n  void EncodeBlock(const LONG *block,\n                   LONG &prevdc,LONG &prevdiff,\n                   UBYTE small,UBYTE large,UBYTE blockup,\n                   UBYTE dctable,UBYTE actable);\n  //\n  // Decode a single block.\n  void DecodeBlock(LONG *block,\n                   LONG &prevdc,LONG &prevdiff,\n                   UBYTE small,UBYTE large,UBYTE blockup,\n                   UBYTE dctable,UBYTE actable);\n  //\n#endif\n  //\n  // Flush the remaining bits out to the stream on writing.\n  virtual void Flush(bool final);\n  // \n  // Restart the parser at the next restart interval\n  virtual void Restart(void);\n  //\nprivate:\n  //\n  // Write the marker that indicates the frame type fitting to this scan.\n  virtual void WriteFrameType(class ByteStream *io);\n  //\n  //\npublic:\n  // Create an arithmetically coded sequential scan. The highbit is always\n  // ignored as this setting only exists for progressive refinement scans.\n  ACSequentialScan(class Frame *frame,class Scan *scan,UBYTE start,UBYTE stop,\n                   UBYTE lowbit,UBYTE highbit,\n                   bool differential = false,bool residual = false,bool largerange = false);\n  //\n  ~ACSequentialScan(void);\n  // \n  // Fill in the tables for decoding and decoding parameters in general.\n  virtual void StartParseScan(class ByteStream *io,class Checksum *chk,class BufferCtrl *ctrl);\n  //\n  // Write the default tables for encoding \n  virtual void StartWriteScan(class ByteStream *io,class Checksum *chk,class BufferCtrl *ctrl);\n  //\n  // Measure scan statistics. Not implemented here since it is not\n  // required. The AC coder is adaptive.\n  virtual void StartMeasureScan(class BufferCtrl *ctrl);\n  //\n  // Start making an optimization run to adjust the coefficients.\n  virtual void StartOptimizeScan(class BufferCtrl *ctrl);\n  //\n  // Start a MCU scan. Returns true if there are more rows. False otherwise.\n  virtual bool StartMCURow(void);\n  //\n  // Parse a single MCU in this scan. Return true if there are more\n  // MCUs in this row.\n  virtual bool ParseMCU(void);  \n  //\n  // Write a single MCU in this scan.\n  virtual bool WriteMCU(void);\n  //\n  // Make an R/D optimization for the given scan by potentially pushing\n  // coefficients into other bins. \n  virtual void OptimizeBlock(LONG bx,LONG by,UBYTE component,double critical,\n                             class DCT *dct,LONG quantized[64]); \n  //\n  // Make an R/D optimization of the DC scan. This includes all DC blocks in\n  // total, not just a single block. This is because the coefficients are not\n  // coded independently.\n  virtual void OptimizeDC(void);\n};\n///\n\n\n///\n#endif\n", "/*************************************************************************\n\n    This project implements a complete(!) JPEG (Recommendation ITU-T\n    T.81 | ISO/IEC 10918-1) codec, plus a library that can be used to\n    encode and decode JPEG streams. \n    It also implements ISO/IEC 18477 aka JPEG XT which is an extension\n    towards intermediate, high-dynamic-range lossy and lossless coding\n    of JPEG. In specific, it supports ISO/IEC 18477-3/-6/-7/-8 encoding.\n\n    Note that only Profiles C and D of ISO/IEC 18477-7 are supported\n    here. Check the JPEG XT reference software for a full implementation\n    of ISO/IEC 18477-7.\n\n    Copyright (C) 2012-2018 Thomas Richter, University of Stuttgart and\n    Accusoft. (C) 2019-2020 Thomas Richter, Fraunhofer IIS.\n\n    This program is available under two licenses, GPLv3 and the ITU\n    Software licence Annex A Option 2, RAND conditions.\n\n    For the full text of the GPU license option, see README.license.gpl.\n    For the full text of the ITU license option, see README.license.itu.\n    \n    You may freely select between these two options.\n\n    For the GPL option, please note the following:\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*************************************************************************/\n/*\n**\n** Represents the scan including the scan header.\n**\n** $Id: losslessscan.cpp,v 1.50 2015/03/25 08:45:43 thor Exp $\n**\n*/\n\n/// Includes\n#include \"codestream/losslessscan.hpp\"\n#include \"io/bytestream.hpp\"\n#include \"control/linebuffer.hpp\"\n#include \"control/linebitmaprequester.hpp\"\n#include \"control/lineadapter.hpp\"\n#include \"marker/frame.hpp\"\n#include \"marker/scan.hpp\"\n#include \"marker/component.hpp\"\n#include \"codestream/tables.hpp\"\n#include \"io/bitstream.hpp\"\n#include \"coding/huffmantemplate.hpp\"\n#include \"coding/huffmancoder.hpp\"\n#include \"coding/huffmandecoder.hpp\"\n#include \"coding/huffmanstatistics.hpp\"\n#include \"codestream/tables.hpp\"\n#include \"codestream/predictorbase.hpp\"\n#include \"tools/line.hpp\"\n///\n\n/// LosslessScan::LosslessScan\nLosslessScan::LosslessScan(class Frame *frame,class Scan *scan,UBYTE predictor,UBYTE lowbit,bool differential)\n  : PredictiveScan(frame,scan,predictor,lowbit,differential)\n{ \n#if ACCUSOFT_CODE\n  for(int i = 0;i < 4;i++) {\n    m_pDCDecoder[i]    = NULL;\n    m_pDCCoder[i]      = NULL;\n    m_pDCStatistics[i] = NULL;\n  }\n#endif\n}\n///\n\n/// LosslessScan::~LosslessScan\nLosslessScan::~LosslessScan(void)\n{\n}\n///\n\n/// LosslessScan::WriteFrameType\n// Write the marker that indicates the frame type fitting to this scan.\nvoid LosslessScan::WriteFrameType(class ByteStream *io)\n{\n#if ACCUSOFT_CODE\n  if (m_bDifferential) {\n    io->PutWord(0xffc7); // differential lossless sequential\n  } else {\n    io->PutWord(0xffc3); // lossless sequential\n  }\n#else\n  NOREF(io);\n#endif\n}\n///\n\n/// LosslessScan::StartParseScan\nvoid LosslessScan::StartParseScan(class ByteStream *io,class Checksum *chk,class BufferCtrl *ctrl)\n{\n#if ACCUSOFT_CODE\n  int i;\n\n  FindComponentDimensions();\n  \n  for(i = 0;i < m_ucCount;i++) {\n    m_pDCDecoder[i]       = m_pScan->DCHuffmanDecoderOf(i);\n  }\n  \n  assert(ctrl->isLineBased());\n  m_pLineCtrl = dynamic_cast<LineBuffer *>(ctrl);\n  m_pLineCtrl->ResetToStartOfScan(m_pScan);\n  m_Stream.OpenForRead(io,chk);\n#else\n  NOREF(io);\n  NOREF(chk);\n  NOREF(ctrl);\n  JPG_THROW(NOT_IMPLEMENTED,\"LosslessScan::StartParseScan\",\n            \"Lossless JPEG not available in your code release, please contact Accusoft for a full version\");\n#endif\n}\n///\n\n/// LosslessScan::StartWriteScan\nvoid LosslessScan::StartWriteScan(class ByteStream *io,class Checksum *chk,class BufferCtrl *ctrl)\n{\n#if ACCUSOFT_CODE\n  int i;\n\n  FindComponentDimensions();\n  \n  for(i = 0;i < m_ucCount;i++) {\n    m_pDCCoder[i]       = m_pScan->DCHuffmanCoderOf(i);\n    m_pDCStatistics[i]  = NULL;\n  }\n  \n  assert(ctrl->isLineBased());\n  m_pLineCtrl = dynamic_cast<LineBuffer *>(ctrl);\n  m_pLineCtrl->ResetToStartOfScan(m_pScan); \n\n  EntropyParser::StartWriteScan(io,chk,ctrl);\n  \n  m_pScan->WriteMarker(io);\n  m_Stream.OpenForWrite(io,chk); \n\n  m_bMeasure = false;\n#else\n  NOREF(io);\n  NOREF(chk);\n  NOREF(ctrl);\n  JPG_THROW(NOT_IMPLEMENTED,\"LosslessScan::StartWriteScan\",\n            \"Lossless JPEG not available in your code release, please contact Accusoft for a full version\");\n#endif\n}\n///\n\n/// LosslessScan::StartMeasureScan\nvoid LosslessScan::StartMeasureScan(class BufferCtrl *ctrl)\n{\n#if ACCUSOFT_CODE\n  int i;\n\n  FindComponentDimensions();\n  \n  for(i = 0;i < m_ucCount;i++) {\n    m_pDCCoder[i]       = NULL;\n    m_pDCStatistics[i]  = m_pScan->DCHuffmanStatisticsOf(i);\n  }\n \n  assert(ctrl->isLineBased());\n  m_pLineCtrl = dynamic_cast<LineBuffer *>(ctrl);\n  m_pLineCtrl->ResetToStartOfScan(m_pScan);\n  \n  m_Stream.OpenForWrite(NULL,NULL);\n  \n  m_bMeasure = true;\n#else\n  NOREF(ctrl);\n#endif\n}\n///\n\n/// LosslessScan::WriteMCU\n// Write a single MCU in this scan. Actually, this is not quite true,\n// as we write an entire group of eight lines of pixels, as a MCU is\n// here a group of pixels. But it is more practical this way.\nbool LosslessScan::WriteMCU(void)\n{\n#if ACCUSOFT_CODE\n  int i;\n  struct Line *top[4],*prev[4];\n  int lines      = 8; // total number of MCU lines processed.\n  \n  for(i = 0;i < m_ucCount;i++) {\n    class Component *comp = ComponentOf(i);\n    UBYTE idx       = comp->IndexOf();\n    top[i]          = m_pLineCtrl->CurrentLineOf(idx);\n    prev[i]         = m_pLineCtrl->PreviousLineOf(idx);\n    m_ulX[i]        = 0;\n    m_ulY[i]        = m_pLineCtrl->CurrentYOf(idx);\n  }\n  \n  // Loop over lines and columns\n  do {\n    do {\n      BeginWriteMCU(m_Stream.ByteStreamOf());    \n      //\n      if (m_bMeasure) {\n        MeasureMCU(prev,top);\n      } else {\n        WriteMCU(prev,top);\n      }\n    } while(AdvanceToTheRight());\n    //\n    // Advance to the next line.\n  } while(AdvanceToTheNextLine(prev,top) && --lines);\n#endif\n  return false;\n}\n///\n\n/// LosslessScan::WriteMCU\n// The actual MCU-writer, write a single group of pixels to the stream,\n// or measure their statistics.\nvoid LosslessScan::WriteMCU(struct Line **prev,struct Line **top)\n{\n#if ACCUSOFT_CODE\n  UBYTE i;\n  //\n  // Parse a single MCU, which is now a group of pixels.\n  for(i = 0;i < m_ucCount;i++) {\n    class HuffmanCoder *dc = m_pDCCoder[i];\n    struct Line *line = top[i];\n    struct Line *pline= prev[i];\n    class PredictorBase *mcupred = m_pPredict[i];\n    UBYTE ym = m_ucMCUHeight[i];\n    LONG *lp = line->m_pData + m_ulX[i];\n    LONG *pp = (pline)?(pline->m_pData + m_ulX[i]):(NULL);\n    //\n    // Write MCUwidth * MCUheight coefficients starting at the line top.\n    do {\n      class PredictorBase *pred = mcupred;\n      UBYTE xm = m_ucMCUWidth[i];\n      do {\n        // Decode now the difference between the predicted value and\n        // the real value.\n        LONG v = pred->EncodeSample(lp,pp);\n        //\n        if (v == 0) {\n          dc->Put(&m_Stream,0);\n        } else if (v == MIN_WORD) {\n          dc->Put(&m_Stream,16); // Do not append bits\n        } else {\n          UBYTE symbol = 0;\n          do {\n            symbol++;\n            if (v > -(1 << symbol) && v < (1 << symbol)) {\n              dc->Put(&m_Stream,symbol);\n              if (v >= 0) {\n                m_Stream.Put(symbol,v);\n              } else {\n                m_Stream.Put(symbol,v - 1);\n              }\n              break;\n            }\n          } while(true);\n        }\n        //\n        // One pixel done. Proceed to the next in the MCU. Note that\n        // the lines have been extended such that always a complete MCU is present.\n      } while(--xm && (lp++,pp++,pred = pred->MoveRight(),true));\n      //\n      // Go to the next line.\n    } while(--ym && (pp = line->m_pData + m_ulX[i],line = (line->m_pNext)?(line->m_pNext):(line),\n                     lp = line->m_pData + m_ulX[i],mcupred = mcupred->MoveDown(),true));\n  }\n#else\n  NOREF(prev);\n  NOREF(top);\n#endif\n}\n///\n\n/// LosslessScan::MeasureMCU\n// The actual MCU-writer, write a single group of pixels to the stream,\n// or measure their statistics. This here only measures the statistics\n// to design an optimal Huffman table\nvoid LosslessScan::MeasureMCU(struct Line **prev,struct Line **top)\n{\n#if ACCUSOFT_CODE\n  UBYTE i;\n  //\n  // Parse a single MCU, which is now a group of pixels.\n  for(i = 0;i < m_ucCount;i++) {\n    class HuffmanStatistics *dcstat = m_pDCStatistics[i];\n    struct Line *line = top[i];\n    struct Line *pline= prev[i];\n    class PredictorBase *mcupred = m_pPredict[i];\n    UBYTE ym = m_ucMCUHeight[i];\n    LONG *lp = line->m_pData + m_ulX[i];\n    LONG *pp = (pline)?(pline->m_pData + m_ulX[i]):(NULL);\n    //\n    //\n    // Write MCUwidth * MCUheight coefficients starting at the line top.\n    do {\n      class PredictorBase *pred = mcupred;\n      UBYTE xm = m_ucMCUWidth[i];\n      do {\n        // Decode now the difference between the predicted value and\n        // the real value.\n        LONG v = pred->EncodeSample(lp,pp);\n        //\n        if (v == 0) {\n          dcstat->Put(0);\n        } else if (v == -32768) {\n          dcstat->Put(16); // Do not append bits\n        } else {\n          UBYTE symbol = 0;\n          do {\n            symbol++;\n            if (v > -(1 << symbol) && v < (1 << symbol)) {\n              dcstat->Put(symbol);\n              break;\n            }\n          } while(true);\n        }\n        //\n        // One pixel done. Proceed to the next in the MCU. Note that\n        // the lines have been extended such that always a complete MCU is present.\n      } while(--xm && (lp++,pp++,pred = pred->MoveRight(),true));\n      //\n      // Go to the next line.\n    } while(--ym && (pp = line->m_pData + m_ulX[i],line = (line->m_pNext)?(line->m_pNext):(line),\n                     lp = line->m_pData + m_ulX[i],mcupred = mcupred->MoveDown(),true));\n  }\n#else\n  NOREF(prev);\n  NOREF(top);\n#endif\n}\n///\n\n/// LosslessScan::ParseMCU\n// This is actually the true MCU-parser, not the interface that reads\n// a full line.\nvoid LosslessScan::ParseMCU(struct Line **prev,struct Line **top)\n{ \n#if ACCUSOFT_CODE\n  UBYTE i;\n  //\n  // Parse a single MCU, which is now a group of pixels.\n  for(i = 0;i < m_ucCount;i++) {\n    class HuffmanDecoder *dc = m_pDCDecoder[i];\n    struct Line *line = top[i];\n    struct Line *pline= prev[i];\n    UBYTE ym = m_ucMCUHeight[i];\n    class PredictorBase *mcupred = m_pPredict[i];\n    LONG *lp = line->m_pData + m_ulX[i];\n    LONG *pp = (pline)?(pline->m_pData + m_ulX[i]):(NULL);\n    //\n    // Parse MCUwidth * MCUheight coefficients starting at the line top.\n    do {\n      class PredictorBase *pred = mcupred;\n      UBYTE xm = m_ucMCUWidth[i];\n      do {\n        LONG v;\n        UBYTE symbol = dc->Get(&m_Stream);\n        \n        if (symbol == 0) {\n          v = 0;\n        } else if (symbol == 16) {\n          v = -32768;\n        } else {\n          LONG thre = 1L << (symbol - 1);\n          LONG diff = m_Stream.Get(symbol); // get the number of bits \n          if (diff < thre) {\n            diff += (-1L << symbol) + 1;\n          }\n          v = diff;\n        }\n        //\n        // Set the current pixel, do the inverse pointwise transformation.\n        lp[0] = pred->DecodeSample(v,lp,pp);\n        //\n        // One pixel done. Proceed to the next in the MCU. Note that\n        // the lines have been extended such that always a complete MCU is present.\n      } while(--xm && (lp++,pp++,pred = pred->MoveRight(),true));\n      //\n      // Go to the next line.\n    } while(--ym && (pp = line->m_pData + m_ulX[i],line = (line->m_pNext)?(line->m_pNext):(line),\n                     lp = line->m_pData + m_ulX[i],mcupred = mcupred->MoveDown(),true));\n  }\n#else\n  NOREF(prev);\n  NOREF(top);\n#endif\n}\n///\n\n/// LosslessScan::ParseMCU\n// Parse a single MCU in this scan. Actually, this is not quite true,\n// as we write an entire group of eight lines of pixels, as a MCU is\n// here a group of pixels. But it is more practical this way.\nbool LosslessScan::ParseMCU(void)\n{\n#if ACCUSOFT_CODE\n  int i;\n  struct Line *top[4],*prev[4];\n  int lines      = 8; // total number of MCU lines processed.\n \n  for(i = 0;i < m_ucCount;i++) {\n    class Component *comp = ComponentOf(i);\n    UBYTE idx       = comp->IndexOf();\n    top[i]          = m_pLineCtrl->CurrentLineOf(idx);\n    prev[i]         = m_pLineCtrl->PreviousLineOf(idx);\n    m_ulX[i]        = 0;\n    m_ulY[i]        = m_pLineCtrl->CurrentYOf(idx);\n  }\n\n  // Loop over lines and columns\n  do {\n    bool startofline = true;\n    do {\n      if (BeginReadMCU(m_Stream.ByteStreamOf())) {\n        ParseMCU(prev,top);\n      } else {\n        // Only if this is not due to a DNL marker that has been detected.\n        if (m_ulPixelHeight != 0 && !hasFoundDNL()) {\n          ClearMCU(top);\n        } else if (!startofline) {\n          // The problem is here that the DNL marker might have been detected, even though decoding\n          // is not yet done completely. This may be because there are still just enough bits in the\n          // bitream present to run a single decode. Big Outch! Just continue decoding in this case.\n          ParseMCU(prev,top);\n        } else break;\n      }\n      startofline = false;\n    } while(AdvanceToTheRight());\n    //\n    // Advance to the next line.\n  } while(AdvanceToTheNextLine(prev,top) && --lines);\n#endif  \n  return false; // no further blocks here.\n}\n///\n\n/// LosslessScan::StartMCURow\n// Start a MCU scan. Returns true if there are more rows.\nbool LosslessScan::StartMCURow(void)\n{\n#if ACCUSOFT_CODE\n  return m_pLineCtrl->StartMCUQuantizerRow(m_pScan);\n#else\n  return false;\n#endif\n}\n///\n\n/// LosslessScan::Flush\n// Flush the remaining bits out to the stream on writing.\nvoid LosslessScan::Flush(bool)\n{  \n#if ACCUSOFT_CODE\n  if (!m_bMeasure)\n    m_Stream.Flush();\n\n  PredictiveScan::FlushOnMarker();\n#endif\n}\n///\n\n/// LosslessScan::Restart\n// Restart the parser at the next restart interval\nvoid LosslessScan::Restart(void)\n{ \n#if ACCUSOFT_CODE\n  m_Stream.OpenForRead(m_Stream.ByteStreamOf(),m_Stream.ChecksumOf());\n\n  PredictiveScan::RestartOnMarker();\n#endif\n}\n///\n", "/*************************************************************************\n\n    This project implements a complete(!) JPEG (Recommendation ITU-T\n    T.81 | ISO/IEC 10918-1) codec, plus a library that can be used to\n    encode and decode JPEG streams. \n    It also implements ISO/IEC 18477 aka JPEG XT which is an extension\n    towards intermediate, high-dynamic-range lossy and lossless coding\n    of JPEG. In specific, it supports ISO/IEC 18477-3/-6/-7/-8 encoding.\n\n    Note that only Profiles C and D of ISO/IEC 18477-7 are supported\n    here. Check the JPEG XT reference software for a full implementation\n    of ISO/IEC 18477-7.\n\n    Copyright (C) 2012-2018 Thomas Richter, University of Stuttgart and\n    Accusoft. (C) 2019-2020 Thomas Richter, Fraunhofer IIS.\n\n    This program is available under two licenses, GPLv3 and the ITU\n    Software licence Annex A Option 2, RAND conditions.\n\n    For the full text of the GPU license option, see README.license.gpl.\n    For the full text of the ITU license option, see README.license.itu.\n    \n    You may freely select between these two options.\n\n    For the GPL option, please note the following:\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*************************************************************************/\n/*\n * Definition of how to request a given rectangle for display,\n * for load or for checking for a necessary update.\n * \n * $Id: rectanglerequest.hpp,v 1.12 2017/11/28 13:08:07 thor Exp $\n *\n */\n\n#ifndef CODESTREAM_RECTANGLEREQUEST_HPP\n#define CODESTREAM_RECTANGLEREQUEST_HPP\n\n/// Includes\n#include \"interface/types.hpp\"\n#include \"tools/rectangle.hpp\"\n#include \"tools/environment.hpp\"\n#include \"std/string.hpp\"\n///\n\n/// Forward references\nstruct JPG_TagItem;\nclass Image;\n///\n\n/// Design\n/** Design\n******************************************************************\n** struct RectangleRequest                                      **\n** Super Class: none                                            **\n** Sub Classes: none                                            **\n** Friends:                                                     **\n******************************************************************\n\nDefines a rectangular image domain that is requested from the\nuser to be loaded or to be previewed. Hence, the purpose of\nthis helper class is to pass parameters about the user request\ninformation down the jpeg stream.\n\nThis structure is constructed by the decoder, and sent down\nto the band class which will generate the requests for each\ncode block. On its way, more and more components gets parsed\nand get interpreted.\n* */\n///\n\n/// RectangleRequest\n// This structure defines the sub-image requested by DisplayRectangle()\n// and similar functions. It is consistently used to define an image\n// area and as such forwarded to the canvas and all its sub-structures\nstruct RectangleRequest : public JObject, private Explicit { \n  //\n  struct RectangleRequest *rr_pNext;\n  RectAngle<LONG>          rr_Request;\n  UWORD                    rr_usFirstComponent; // starting component\n  UWORD                    rr_usLastComponent;  // inclusive end component\n  BYTE                     rr_cPriority;        // order of rectangles\n  bool                     rr_bIncludeAlpha;    // include the alpha channel in the request\n  bool                     rr_bUpsampling;      // disable or enable upsampling. Default is to upsample\n  bool                     rr_bColorTrafo;      // disable or enable the output color transformation. Default is to run it.\n  //\n  RectangleRequest(void)\n    : rr_pNext(NULL)\n  { }\n  //\n  // Copy constructor.\n  RectangleRequest(const struct RectangleRequest &req)\n    : Explicit()\n  {\n    // Not nice, but this is really faster and simpler\n    memcpy(this,&req,sizeof(struct RectangleRequest));\n    // Not linked in any way if this is new.\n    rr_pNext = NULL;\n  }\n  //\n  // Assignment operator.\n  RectangleRequest &operator=(const struct RectangleRequest &req)\n  { \n    // Not nice, but this is really faster and simpler\n    memcpy(this,&req,sizeof(struct RectangleRequest));\n    // Not linked in any way if this is new.\n    rr_pNext = NULL;\n    //\n    return *this;\n  }\n  //\n  //\n  // Queues the request in the rectangle request structure.\n  void ParseTags(const struct JPG_TagItem *tags,const class Image *image);\n  //\n  // Check whether this request contains the argument as sub-request, i.e.\n  // whether requesting this request first and then the sub-request as\n  // argument does nothing.\n  bool Contains(const struct RectangleRequest *sub) const;\n  // \n  // Check whether this rectangle intersects with another\n  // rectangle. Returns true if so.\n  bool Intersects(const RectAngle<LONG> &cmp) const\n  {\n    return rr_Request.Intersects(cmp);\n  }\n  //\n  // Returns the next rectangle in a singly linked list\n  struct RectangleRequest *NextOf(void) const \n  {\n    return rr_pNext;\n  }\n  //\n  // Enqueue a rectangle into a list according to its priority.\n  void Enqueue(struct RectangleRequest *&first);\n};\n///\n\n///\n#endif\n"], "fixing_code": ["This project implements a complete(!) JPEG (Rec. ITU-T T.81 | ISO/IEC\r\n10918-1) codec, plus a library that can be used to encode and decode\r\nJPEG streams.  It also implements ISO/IEC 18477 aka JPEG XT which is\r\nan extension towards intermediate, high-dynamic-range lossy and\r\nlossless coding of JPEG. In specific, it supports ISO/IEC\r\n18477-3/-6/-7/-8/-9 encoding.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nUnlike many other implementations, libjpeg also implements:\r\n\r\n- 12 bpp image coding for the lossy DCT process,\r\n- the predictive lossless mode of Rec. ITU-T T.81 | ISO/IEC 10918-1,\r\n- the hierarchical process of Rec. ITU-T T.81 | ISO/IEC 10918-1,\r\n- the arithmetic coding option of Rec. ITU-T T.81 | ISO/IEC 10918-1,\r\n- coding of up to 256 component images\r\n- upsampling of images for all factors from 1x1 to 4x4\r\n\r\nStandard features are of course also supported, such as\r\nsequential and progressive mode in 8bpp.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nIn addition, this codec provides methods to encode images\r\n\r\n- with a bit depth between 8 and 16 bits per sample, fully backwards\r\n  compatible to Rec. ITU-T T.81 | ISO/IEC 10918 baseline coding.\r\n\r\n- consisting of floating point samples, specifically images with \r\n  high dynamic range.\r\n\r\n- to encode images without loss, regardless of their bit-depth and their\r\n  sample data type.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nExample usage:\r\n\r\nStandard JPEG compression, with 444 (aka \"no\") subsampling:\r\n\r\n$ jpeg -q <quality> infile.ppm outfile.jpg\r\n\r\nStandard JPEG compression, with 422 subsampling:\r\n\r\n$ jpeg -q <quality> -s 1x1,2x2,2x2 infile.ppm outfile.jpg\r\n\r\nIntermediate dynamic range compression, i.e. compression of images\r\nof a bit-depth between 8 and 16 bits:\r\n\r\n$ jpeg -r -q <base-quality> -Q <extension-quality> -h -r12 infile.ppm outfile.jpg\r\n\r\nThis type of encoding uses a technology known as \"residual scans\" which \r\nincrease the bit-depths in the spatial domain which is enabled by the -r\r\ncommand line switch. The -Q parameter sets the quality of the residual image. \r\nTo improve the precision in the frequency domain, \"refinement scans\" can be used. \r\nThe following encodes a 12-bit image with  four additional refinement scans,\r\nenabled by the \"-R 4\" parameter.\r\n\r\n$ jpeg -q <quality> -R 4 -h infile.ppm outfile.jpg\r\n\r\nBoth technologies can be combined, and the precision of the residual scan\r\ncan also be enlarged by using residual refinement scans with the -rR option.\r\nThe following command line with use a 12-bit residual scan with four refinement\r\nscans:\r\n\r\n$ jpeg -r -q <base-quality> -Q <extension-quality> -h -rR 4 infile.ppm outfile.jpg\r\n\r\nHigh-dynamic range compression allows three different profiles of varying\r\ncomplexity and performance. The profiles are denoted by \"-profile <X>\" where\r\n<X> is a,b or c. The following encodes an HDR image in profile C:\r\n\r\n$ jpeg -r -q <base-quality> -Q <extension-quality> -h -profile c -rR 4 infile.pfm outfile.jpg\r\n\r\nHDR images here have to be fed into the command line in \"pfm\" format. \r\nexr or hdr is not supported as input format and requires conversion to \r\npfm first. pfm is the floating-point equivalent of ppm and encodes each\r\npixel by three 32-bit floating point numbers.\r\n\r\nEncoding in profiles a and b works likewise, though it is generally advisable to\r\nuse \"open loop\" rather than \"closed loop\" coding for these two profiles by\r\nadditionally providing the \"-ol\" parameter. This also works for profile C:\r\n\r\n$ jpeg -ol -r -profile a -q <base-quality> -Q <extension-quality> -h infile.pfm out.jpg\r\n\r\nsimilar for profile B.\r\n\r\nWhat is common to profiles A and C is that you may optionally also specify \r\nthe LDR image, i.e. the image that a legacy JPEG decoder will show. By default, \r\na simple tone mapping algorithm (\"global Reinhard\") will be used to derive a\r\nsuitable LDR image from the input image:\r\n\r\n$ jpeg -ldr infile.ppm -q <base-quality> -Q <extension-quality> -h -rR 4 infile.pfm out.jpg\r\n\r\nThe profile is by default profile c, but it also works for profile a:\r\n\r\n$ jpeg -ol profile a -ldr infile.ppm -q <base-quality> -Q <extension-quality> infile.pfm out.jpg\r\n\r\nIt is in general advisable for profile c encoding to enable residual refinement scans,\r\nprofiles a or b do not require them.\r\n\r\n\r\nThe following options exist for lossless coding integer:\r\n\r\npredictive Rec. ITU-T T.81 | ISO/IEC 10918-1 coding. Note, however,\r\nthat not many implementations are capable of decoding such stream,\r\nthus this is probably not a good option for all-day purposes.\r\n\r\n$ jpeg -p -c infile.ppm out.jpg\r\n\r\nWhile the result is a valid Rec. ITU-T T.81 | ISO/IEC 10918-1 stream,\r\nmost other implementations will hick up and break, thus it is not\r\nadvisable to use it.\r\n\r\nA second option for lossless coding is residual coding within profile c:\r\n\r\n$ jpeg -q <quality> -Q 100 -h -r infile.ppm out.jpg\r\n\r\nThis also works for floating point coding. Note that lossless coding is enabled\r\nby setting the extension quality to 100.\r\n\r\n$ jpeg -q <quality> -Q 100 -h -r infile.pfm out.jpg\r\n\r\nHowever, this is only lossless for 16 bit input samples, i.e. there is a precision\r\nloss due to down-converting the 32-bit input to 16 bit. If samples are out of the\r\n601 gamut, the problem also exists that clamping will happen. To avoid that,\r\nencode in the XYZ color space (profile C only, currently):\r\n\r\n$ jpeg -xyz -q <quality> -Q 100 -h -r infile.pfm out.jpg\r\n\r\nA second option for lossless integer coding is to use a lossless 1-1 DCT\r\nprocess. This is enabled with the -l command line option:\r\n\r\n$ jpeg -l -q 100 -c infile.ppm out.jpg\r\n\r\nRefinement scans can be used to increase the sample precision to up to 12\r\nbits. The \"-c\" command line option disables the lossy color transformation.\r\n\r\nAdditionally, this implementation also supports JPEG LS, which is\r\noutside of Rec. ITU-T T.81 | ISO/IEC 10918-1 and ISO/IEC 18477. For\r\nthat, use the command line option -ls:\r\n\r\n$ jpeg -ls -c infile.ppm out.jpg\r\n\r\nThe \"-c\" command line switch is necessary to disable the color transformation\r\nas JPEG LS typically encodes in RGB and not YCbCr space.\r\n\r\nOptionally, you may specify the JPEG LS \"near\" parameter (maximum error) with\r\nthe -m command line switch:\r\n\r\n$ jpeg -ls -m 2 -c infile.ppm out.jpg\r\n\r\nJPEG LS also specifies a lossless color transformation that is enabled with\r\n-cls:\r\n\r\n$ jpeg -ls -cls infile.ppm out.jpg\r\n\r\n\r\nTo encode images with an alpha channel, specify the source image that \r\ncontains the alpha channel with -al. The alpha channel is a one-component\r\ngrey-scale image, either integer or floating point. The quality of the\r\nalpha channel is specified with -aq, that of the regular image with -q:\r\n\r\n$ jpeg -al alpha.pgm -aq 80 -q 85 input.ppm output.jpg\r\n\r\nAlpha channels can be larger than 8bpp or can be floating point. In both\r\ncases, residual coding is required. To enable residual coding in the alpha\r\nchannel, use the -ar command line option. Similar to the regular image,\r\nwhere residual coding requires two parameters, -q for the base quality and\r\n-Q for the extension quality, an alpha channel that uses residual coding\r\nalso requires a base and extension quality, the former is given by -aq,\r\nthe latter with -aQ:\r\n\r\n$ jpeg -ar -al alphahigh.pgm -q 85 -Q 90 -aq 80 -aQ 90 input.ppm out.jpg\r\n\r\nThe alpha channel can be encoded without loss if desired. For that, enable\r\nresidual coding with -ar and specify an extension quality of 100:\r\n\r\n$ jpeg -ar -al alphahigh.pgm -q 85 -Q 90 -aq 80 -aQ 100 input.ppm out.jpg\r\n\r\nThe alpha channel can use the same technology extensions as the image,\r\nnamely refinement scans in the base or extension image, or 12-bit residual\r\nimages. The number of refinement scans is selected with -aR and -arR for\r\nthe base and residual image, a 12-bit residual image is selected with -ar12.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nDecoding is much simpler:\r\n\r\n$ jpeg infile.jpg out.ppm\r\n\r\nor, for floating point images:\r\n\r\n$ jpeg infile.jpg out.pfm\r\n\r\n\r\nIf you want to decode a JPEG LS image, then you may want to tell the\r\ndecoder explicitly to disable the color transformation even though the\r\ncorresponding marker signalling coding in RGB space is typically missing\r\nfor JPEG LS:\r\n\r\n$ jpeg -c infile.jpg out.ppm\r\n\r\n\r\nIf an alpha channel is included in the image, the decoder does not\r\nreconstruct this automatically, nor does it attempt to merge the alpha\r\nimage into the file. Instead, it may optionally be instructed to write the\r\nalpha channel into a separate 1-component (grey-scale) file:\r\n\r\n$ jpeg -al alpha.pgm infile.jpg outfile.ppm\r\n\r\nThe -al option for the decoder provides the target file for the alpha\r\nchannel.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nStarting with release 1.30, libjpeg will include a couple of optimization\r\nparameters to improve the performance of JPEG and JPEG XT. In this\r\nrelease, the following additional command line switches are available:\r\n\r\n-qt <n> : Selects a different quantization table. The default table,\r\nalso enabled by -qt 0, is the one in the legacy JPEG standard\r\n(Rec. ITU-T T.81 | ISO/IEC 10918-1). -qt 1 is the \"flat\" table for\r\nPSNR-optimal performance. It is not recommended for real-life usage as\r\nits visual performance is non-ideal, it just generates \"nice\r\nnumbers\". -qt 2 is MS-SSIM ideal, but similarly, not necessarily a\r\ngood recommendation for all-day use. -qt 3 is a good compromize and\r\nusually works better than -qt 0.\r\n\r\n-dz : This option enables a deadzone quantizer that shifts the buckets\r\nby 1/8th of their size to the outside. This is (almost) the ideal choice\r\nfor Laplacian sources which would require a shift of 1/12th. Nevertheless,\r\nthis option improves the rate-distortion performance by about 0.3dB on\r\naverage and works pretty consistent over many images.\r\n\r\nAdditional options are planned for future releases.\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.40:\r\n\r\nIn this release, we included additional support for \"full profile\" encoding, i.e.\r\nencoding parameters that do not fit any of the four profiles specified in 18477-7.\r\nUsing such encoding parameters will generate a warning on the command line, but\r\nencoding will proceed anyhow, generating a bitstream that conforms to 18477-7, but\r\nnot to any of the profiles in this standard.\r\n\r\nWith \"-profile a -g 0\" or \"-profile b -g 0\" the encoder will generate a file that\r\nuses an inverse TMO lookup similar to profile C with other encoding parameters\r\nidentical to those defined by profiles A and B.\r\n\r\nThe command line option \"-lr\" will use a logarithmic encoding instead of the gamma\r\nencoding for profile B. Again, this will leave the profile, but will be within the\r\nbounds of 18477-7.\r\n\r\nOther than that, a couple of bug fixes have been made. Profile A and B setup could\r\nnot reset the toe value for the inverse gamma map, due to a typo of one of the\r\nparameters. Profile B accepted a different gamma value than the default, but never\r\ncommunicated it to the core code, i.e. it was simply ignored. Profile B setup ignored\r\nthe epsilon values for numerator and denomiator, and they were communicated wrongly\r\ninto the core code. This was corrected, and epsilons can now be specified on the\r\ncommand line.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.50:\r\n\r\nThis release fixes encoding of ISO/IEC 18477-8 if the IDCT was selected as\r\ntransformation in the extension layer and refinement scans were added, i.e.\r\nthe command line options -rl -rR 4 created invalid codestreams. Previous\r\nreleases used the wrong type of refinement scan (dct bypass refinement instead\r\nof regular refinement) and hence broke reconstruction. Furthermore, previous\r\nreleases no longer allowed near lossless coding with DCT bypass. Instead, regular\r\nDCT coding conforming to ISO/IEC 18477-7 was used. To enable the near-lossless\r\nDCT bypass mode, use the new option \"-ro\" now.\r\n\r\nProfile B encoding could potentially create codestreams that run into\r\nclipping of the extension channel; this always happens if the denominator is\r\nlarger than 1, and has to happen according to Annex C of ISO/IEC 18477-3.\r\nThis release avoids this issue by adjusting the exposure value such that\r\nthe denominator always remains smaller than 1.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.51:\r\n\r\nIf the JPEG-XT markers were delayed to the frame-header intead the global\r\nheader, the previous code did not built up the necessary infrastructure\r\nto compute the checksum and hence could not verify the checksum in such\r\na condition. The 1.51 release fixes this problem.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.52:\r\n\r\nThis file is an updated/enhanced version of the 1.51 release of\r\nthe JPEG XT demo software found on https://github.com/thorfdbg/. It\r\nincludes additional features presented in the paper\r\n\"JPEG on Steroids : Common Optimization Techniques for JPEG Image Compression\"\r\nby the same author.\r\n\r\nIn specific, the following command line flags are *NEW* to this version and\r\nare available only as a contribution to ICIP 2016:\r\n\r\n-oz:          This enables the dynamic programming algorithm to enhance\r\nthe rate-distortion performance by soft-threshold quantization. It has been\r\nused for the tests in section 3.3 of the paper.\r\n\r\n-dr:         This enables the smart de-ringing algorithm that has been used\r\nin section 3.6.\r\n\r\nAdditionally, the following switches have been used for other subsections\r\nof the paper; they are not new to this distribution but available as\r\npart of the regular libjpeg distribution at github or www.jpeg.org:\r\n\r\n-s 1x1,2x2,2x2:     Enable 420 subsampling (444 is default)\r\n-s 1x1,2x1,2x1:     Enable 422 subsampling (444 is default)\r\n-qt n (n=0..8)      Use quantization matrix n.\r\n                    In the paper, n=1 (flat) was used for PSNR-optimized\r\n                    coding, unless otherwise noted.\r\n-dz                 The deadzone quantizer in section 3.3\r\n                    (simpler than -oz)\r\n-v                  Enable coding in processive mode (section 3.5)\r\n-v -qv              Optimized progressive mode (section 3.5)\r\n-h                  Optimized Huffman coding (always used, unless noted\r\n                    otherwise, see section 3.4)\r\n\t\t    \r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.53:\r\n\r\nThis release includes additional functionality to inject markers, or\r\nretrieve markers from a codestream while reading. For that, set\r\nthe JPGTAG_ENCODER_STOP tag of the JPEG::Write() call to a bitmask\r\nwhere the encoder should interrupt writing data (this flag already\r\nexisted before) then write custom data with JPEG::WriteMarker(), then\r\ncontinue with JPEG::Write(). On decoding, set JPGTAG_DECODER_STOP to\r\na bitmask where to stop for markers, then identify markers with\r\nJPEG::PeekMarker(), and retrieve them with JPEG::ReadMarker(). Details\r\ncan be found in cmd/encodec.cpp for encoding, and cmd/reconstruct.cpp.\r\n\r\nOtherwise, no functional changes.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.54:\r\n\r\nIn this release, upsampling has been made conforming to the latest\r\ncorrigendum of 18477-1 and 18477-8. In particular, upsampling is now\r\nby design always centered and never co-sited. The co-sited upsampling\r\nprocedure is still included in the source code, but never executed.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.55:\r\n\r\nThis release only addresses some minor formulation issues of the\r\ncommand line such that references are formatted properly to make this\r\nsoftware package acceptable as a JPEG reference software.\r\nNo functional changes.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.56:\r\n\r\nEncoding and reconstruction of 2-component images was actually never\r\nsupported, as it was considered a rather exotic use-case. Now that a\r\nrequest was made, support for 2-components was added and should\r\nhopefully work ok.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.57:\r\n\r\nNewer g++ compiler versions warned about implicit fall-throughs in switch/\r\ncase constructs that are actually harmless. This release adds an autoconf\r\ndetection of such compiler versions, adds consistent comments throughout\r\nthe code.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.58:\r\n\r\nThis release fixes multiple spelling errors in the file, thanks to\r\nMathieu Mmalaterre for finding and fixing them. The release also\r\naddresses multiple race conditions and improves stability and robustness\r\non invalid streams. Thanks to seviezhou for providing codestreams that\r\ntriggered these defects. In particular, the following defects have\r\nbeen found:\r\n\r\n- when a codestream with unsupported upsampling specification (beyond\r\n  18477-1) was found, the code crashed.\r\n- JPEG LS single component scans did not check whether there is actually\r\n  only a single component referenced in the scan.\r\n- An invalid DC category in the sequential scan could have caused a\r\n  crash in the follow-up decoding.\r\n- AC-coded lossless JPEG scans with horizontal subsampling factors\r\n  trashed memory.\r\n- MCU sizes of 0 remained undetected and caused crashes due to a\r\n  division-by-zero exception.\r\n- The code did not check whether a scan references the same component\r\n  more than once and could have failed with strange effects then.\r\n- The code did not handle EOF conditions in the frame header\r\n  gracefully.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.59:\r\n\r\nThis release addresses a defect in the MCU handling for JPEG LS scans.\r\nThe previous code forgot to reset the JPEG LS state variables on MCU\r\nscan boundaries, thus defeating the independent decodability of MCUs\r\nif restart markers are inserted into the stream. Thanks to Spyros for\r\ndetecting this defect.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.60:\r\n\r\nA specially crafted bitstream depending on line-based JPEG processes\r\ncould trigger a segfault because source data the reconstruction\r\nprocess depended upon were not available. This has been fixed.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.61:\r\n\r\nThe restart interval for JPEG LS streams, specifically, is allowed to\r\nbe larger than 2^16. Modified the DRI marker accordingly. Unfortunately,\r\nas the initial tables section of a codestream of JPEG and JPEG LS is\r\nidentical, JPEG files with an invalid DRI marker size will also be\r\naccepted as valid.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.62:\r\n\r\nThe quantization table could contain entries larger than 255 for the 8-bit\r\nDCT process, even though the standard prohibits this. Now the quantization\r\ntable entries are clipped to the allowed range.\r\nAdded an option -bl to force encoding in the baseline sequential process.\r\nAdded options to read the quantization tables from files rather than using\r\nthe built-in defaults.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.63:\r\n\r\nIn case the decoder was started with an image containing an alpha channel,\r\ni.e. a 18477-9 image, and no output file for the alpha channel was\r\nprovided, the decoder crashed. This issue was fixed, the alpha channel is\r\nnow in this case simply disregarded. Note that you can define the output\r\nfile for the alpha channel with the \"-al\" command line option.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.64:\r\n\r\nThe lossless scan, the arithmetically coded lossless scan and the\r\narithmetically coded sequential scan could run into cases where an\r\nout-of-bounds symbol triggered and out-of-bounds array access and could\r\nhave crashed the decoder. The code is now more carefully changing the\r\nvalidity of the symbols and aborts with an error if it finds illegal\r\ncodes.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nFor license conditions, please check the file README.license in this\r\ndirectory.\r\n\r\nFinally, I want to thank Accusoft and the Computing Center of the University of\r\nStuttgart and Fraunhofer IIS for sponsoring this project.\r\n\r\nThomas Richter, February 2022\r\n\r\n-------------------------------------------------------------------------------------\r\n", "Revision 0.10\r\n-----------------------------\r\n\r\nFirst release of libjpeg to the public.\r\n\r\n\r\nRevision 0.11\r\n-----------------------------\r\n\r\nApparently, the demo frontend code used the \r\nnon-binary mode to open the output files,\r\ncreating corrupt files under platforms where\r\nsuch modes include a text conversion. Fixed.\r\n\r\nThe configure script that tested for the avail-\r\nibility of setjmp did not work on those platforms\r\nwhere setjmp is a macro rather than a function.\r\nThe test for setjmp is now omitted, depending solely\r\non the availibility of longjmp.\r\n\r\n\r\nRevision 0.20\r\n-----------------------------\r\n\r\nThis release fixes a bug in the residual huffman decoder\r\nscan where I forgot to multiply the residuals with the\r\nquantization size. This did not affect lossless coding,\r\nbut only near-lossless coding.\r\nFurthermore, this release adds coding of high-bitdepth\r\nimages with a standard 8bpp JPEG fallback stream. For\r\nthat, simply supply the image to be coded on the command\r\nline and add the \"-r\" option to enable residual coding.\r\nTo use the conforming, but typically ill-supported 12bpp\r\nmode of JPEG, do not use \"-r\".\r\n\r\n\r\nRevision 0.30\r\n-----------------------------\r\n\r\nThis release introduces a new coding strategy for lossless\r\nand high-dynamic range coding. Unlike former releases,\r\nthis release runs an additional reversible color transformation\r\non the residual data, followed by a lossless (scaled) Hadamard\r\ntransformation to avoid color banding in extreme cases. It\r\nalso adds an additional tone mapping curve (or curves) to be\r\nspecified on encoding that allow a higher quality of the\r\nLDR base layer.\r\n\r\nRevision 0.50\r\n-----------------------------\r\n\r\nThe new features in this version are a refined residual coding algorithm that\r\nincludes a runlength scan to improve coding efficiency for low-quality extensions\r\nlayers. This release also features a new HDR compression in the DCT domain that\r\nuses the known JPEG refinement scans of progressive coding to improve the resolution\r\nfrom 8 bit to 12 bit in a completely backwards compatible way. Additionally, the\r\nsoftware was unit-tested with the 10918-2 (JPEG part 2) test streams and various\r\nbugs of the lossless predictive arithmetic coding and lossless predictive coding\r\nwere removed. New command line switches allow the encoding of pfm images (floating\r\npoint, for high-dynamic range) and the number of extension refinement scans.\r\n\r\nRevision 0.60\r\n-----------------------------\r\n\r\nOnly minor modifications were made in this release. The Huffman coder now fills\r\nundefined bits at the end of the entropy coded segment by ones, and potentially\r\ninserts a stuffed zero byte. Note that the standard defines this only in an\r\ninformative note, so it is likely not required. The insertion of a stuffed zero\r\nbyte at this position might also be unnecessary as a parser should identify the\r\nfirst 0xff byte ahead of the marker as \"fill byte\".\r\n\r\nResidual coding has been reworked and uses now a simple progressive scan with the\r\nspecial DC case removed. The performance does not differ significantly, and it\r\nmakes integration into legacy software or hardware easier. \r\n\r\nDefault Huffman tables are now also provided for progressive and lossless scans,\r\nthus optimizing the Huffman tables just for these scan types is no longer \r\nnecessary. Residual or refinement scans still require this argument, though.\r\n\r\nUsage of the codec does not differ from previous releases, though codestreams\r\nusing the residual coding mode are not compatible to those generated by 0.5.\r\nNote that this is still experimental software and the codestream might still\r\nchange until the ISO committee decides on the technology.\r\n\r\nFinally, a couple of workarounds for earlier releases of the g++ compiler have\r\nbeen added.\r\n\r\n\r\nRelease 0.7:\r\n-----------------------------\r\n\r\nThis is a major release of the software which adds a lot of missing\r\nfunctionality and brings it up to date to the latest working draft of\r\n18477-2. In specific, boxes are now written according to the latest\r\nspecification, and three proposals to encode HDR data are now\r\nimplemented: mult1 (quotient method), mult2 (overflow/truncation\r\nmethod) and residual coding. The HDR to LDR non-linear point\r\ntransformation can now be explicitly specified giving a file name on\r\nthe command line (-gf option) which must contain 256 lines, one line\r\nper LDR input sample value. Each line shall contain an ASCII encoded\r\ndecimal number, the output value a reconstructed LDR sample value is\r\nmapped to.\r\n\r\nThis release also supports (finally) subsampling in residual and\r\nmultiplicative coding, just specify the subsampling factors. In this\r\nrelease, the frontend only allows the same subsampling factors for\r\nboth images (legacy and residual) though the back-end is more powerful\r\nand would allow arbitrary combinations.  Lossless coding by residuals\r\nis also supported, residual image subsampling factors are set to 1:1:1\r\nin case the quality of the residual is 100.\r\n\r\nThe SERMS DCT that was removed in the earlier releases is now back and\r\ncan be enabled by the \"-l\" option. Note well that you also need to\r\nspecify \"-c\" to disable the YCbCr transformation.\r\n\r\nThe experimental VESA coding modes that have been part of this code\r\nare now gone for good as they are not part of the specification.\r\n\r\nA huge number of bugs have been fixed, in specific for the handling of\r\ngrey-only images. These should work fine now.\r\n\r\nThis release supports now two variations of the encoding mode,\r\nopen-loop and closed-loop.  In closed-loop coding, which was the\r\ndefault so far, the residual/multiplicative encoder is feed by the\r\nresidual (additive or multiplicative) of the reconstructed LDR and\r\noriginal image. For openloop coding, the encoder does not need to go\r\nthrough a full encoding/decoding cycle of the legacy stream and feeds\r\nin the legacy image derived from the original image to the residual\r\ncoder right away. NOTE THAT THIS MEANS THAT LOSSLESS CODING WILL NOT\r\nOPERATIONAL IN OPEN LOOP MODE, and additive residual coding will be\r\nrather pointless. However, this mode does make sense for the\r\nmultiplicative modes. Regardless of whether open or closed loop coding\r\nis used, the encoded codestream is conforming, though coding results\r\nmay be different.\r\n\r\n\r\nRelease 0.71:\r\n-----------------------------\r\n\r\nThis is a minor bugfix release which also adds one functionality, namely\r\nthe encodign of HDR images in the floating point domain via -mult1.\r\nPrevious versions took a round-trip through the integer domain and\r\nhence required output clipping. The direct-float mode can now be enabled\r\nby disabling the output-clipping process with \"-oc\". \r\n\r\nAdditionally, this release fixes two bugs, mostly related to the internal\r\nstream management. Due to an oversight, the marker-peek-ahead logic for\r\nresidual streams did not work, causing a potential race condition\r\nwhen a marker was overlapping a chunk-boundary of the internal stream\r\nrepresentation. Length computation of the internal stream representation\r\nwas also broken on encoding, causing a potential race condition when the\r\nhuffman table marker was overlapping with a chunk boundary. A third\r\nbug, namely a missing EOC at the end of the residual codestream, was\r\nfixed, too.\r\n\r\nRelease 0.72:\r\n-----------------------------\r\n\r\nThis release fixes a one-line oversight in the handling of subsampled \"residual\" coding,\r\nnamely the quantization output buffer did not advance, causing an assertion failure.\r\nThis release fixes the issue.\r\n\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 0.8:\r\n\r\nThis is again an update of the software in order to synchronize it with\r\nthe latest Working Draft (proposed CD text) document; that is, boxes\r\nare written now according to the latest specifications. Furthermore, support\r\nfor refinement scans in the residual domain have been added (with -rR),\r\nresidual data is DCT transformed unless lossless coding is desired.\r\nThis release also adds the checksum box, computes the checksum on encoding\r\nand tests it on decoding. In case it does not fit, a warning is generated.\r\n\r\nQuantization setup changed a bit, using now smaller buckets in the residual\r\nstream which avoids the paradoxical situation that a finer base layer\r\nquantization can cause a quality drop for the overall image.\r\n\r\nA serious bug in legacy coding modes was removed that caused the encoder\r\nor decoder to crash if no residual image was present.\r\n\r\nThis version of the encoder also supports encoding and decoding of images\r\nin wider color spaces; for demonstration purposes, it encodes images in the\r\nXYZ colorspace using the command line option -xyz, or -cxyz where the latter\r\nuses a slightly less efficient method how to represent the images.\r\n\r\nAt this time, the text based format is not supported, and support for the\r\ntwo other profiles (-mult1, -mult2) has been temporarely removed until the\r\nstandardization committee provides a clean solution how to integrate them.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 0.9:\r\n\r\nThis is just another update. This update introduces new DCTs, the Z0 DCT from\r\nISO/IEC 23002-2, the Z1a DCT from the same authors and the CD document of this\r\nstandard, and a lifting-based DCT. Tests show that Z0 and the lifting DCT do not \r\nperform very well, so the default is current Z1 and SERMS.\r\nFurthermore, processing of RCT has changed slightly to ensure that the output\r\nis always in-range, not only for 16 bit output.\r\nDCT-bypass entropy coding was extended to use the full Huffman table, and includes\r\nnow special handling for the race-condition of having to code the value 0x8000\r\nwhich was simply not possible before.\r\nThe codestream syntax has been modified again to reflect the latest edition of\r\nthe standard document, namely the CD of 18477-3.\r\nLots of other minor fixes have been made, as for example in the selection and\r\nencoding of the precision of the residual frame and the computation of the\r\nchecksum.\r\n\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 0.91:\r\n\r\nThis release fixes a wrong DC offset in the residual coding path that compromized\r\ncompression efficiency, and a wrong computation in the residual bits.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 0.92:\r\n\r\nThis release improves the computation of the LDR to HDR inverse TMO computation for\r\nprofile C and gains by that sometimes up to 2dB in PSNR. It also provides a \"-sp\"\r\ncommand line switch to use separate separate tables, one per component. This may\r\nhelp in case the image contains some extreme colors.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.00alpha1:\r\n\r\nThis is the first complete release of the demo software. It adds again support\r\nfor profiles a and b for lossy HDR image coding and follows the new box-based\r\ndesign of 18477-3.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.00beta1:\r\n\r\nThis is a fully verified version of the software, i.e. all modes of operation have\r\nbeen tested by an automatic unit test. This of course does not exclude any bugs,\r\nor any modifications before the finalization of the standard.\r\n\r\nIn comparison to the alpha1 release, the following bugs have been fixed:\r\n\r\n- Predictive lossless mode with restart markers forgot to reconstruct the last line\r\nin some configurations.\r\n- Due to an oversight, hierarchical mode did not work in combination with AC coding.\r\n- Hierarchical mode did not work in the \"semi-lossless\" configuration where the finest\r\nframe is defined by a lossless predictive scan.\r\n- Predictive lossless could have forgotten the last line on streams using the DNL marker\r\nto signal the height of the image.\r\n- JPEG LS restart markers did not work in plane and sample interleaved mode. Note,\r\nhowever, that restart marker handling in the JPEG LS reference software is broken and\r\ndoes not follow the specifications. (Defect report is pending.)\r\n- Grey scale coding in profiles A and B did not work.\r\n- Coding in RGB-colorspace did not work in profiles A and B.\r\n- Encoding in JPEG-LS erraneously inserted JPEG XT boxes into the codestream. While this\r\nis harmless, it increases the rate unnecessarily.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.00beta2:\r\n\r\nThis release includes the changes made on the standard in the Strasbourg meeting\r\nof the JPEG committee, in particular it includes a rounding mode specifier of\r\nthe CURV boxes. Additionally, it allows now the inclusion of an arbitrary LDR image\r\nwithin profile B. Previous releases only supported the gamma-plus-clamping tone\r\nmapper which was built into the source. In addition to the new features, this\r\nrelease also includes an improved Huffman decoder that should be considerably\r\nfaster than the previous trivial bit-by-bit decoder.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.00beta2.2:\r\n\r\nOnly a short fix in the handling of lossless JPEG scans: This release fixes one\r\nissue, namely correct decoding of 16-bit images where the carry-over was not\r\ncomputed correctly. This change required a careful distinction between differential\r\npredictive and regular-predictive mode, which is interestingly not mentioned in\r\nthe specs (probably nobody tested). A second race was fixed in JPEG-LS handling\r\nwhere bit-stuffing could have left a single isolated zero at the end of a JPEG-LS\r\nscan, causing a warning in the upwards marker parser (though no corrupt reconstruction).\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.20:\r\n\r\nThis version adds support for alpha channels as defined by ISO/IEC 18477-9\r\nto the code. Alpha channels are specified by one-component grey-scale images,\r\nof bit depths between 8 and 16 bits per sample. They may also consist of\r\nfloating point samples between 0 and 1. To add an alpha channel, use the command\r\nline options -al <filename> -aq <quality> for simple alpha channels of 8 bits per\r\nsample. For more precise alpha channels, residual coding in the alpha domain\r\nmust be enabled with -ar, and an alpha channel residual quality must be specified\r\nwith -aQ <ext-quality>. The coding tools for alpha channels are otherwise identical\r\nfor that of the base image. Alpha coding can be combined with any other coding\r\ntools, i.e. parts 6,7 and 8.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.21:\r\n\r\nThis is only a minor maintenance release which removes three experimental DCT\r\nimplementations that are no longer required, fixes two possible un-initialized\r\nvariables and fixes a bug in the box enumeration. Release 1.20 and above started\r\nfor some boxes the box enumeration at zero even though it should start at one.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.30:\r\n\r\nThis release fixes a bug in the line-based operation mode that is not available from\r\nthe front end and only works for baseline sequential. Unlike other modes, it does\r\nnot require full internal buffering of the image. It is also synchronized again to\r\nthe latest edition of the standard, offering the additional upscaling in the residual\r\npath for parts 6 and part 7 profile C. It has been cross-tested with other \r\nimplementations, thus interoperability is granted. Clipping for floating-point output\r\nhas been corrected to avoid the representations of NAN and INF.\r\nLast but not least, this release offers the possibility to select between nine different\r\nquantization matrices (-qt 0 to -qt 9), of which -qt 1 is PSNR-optimal and -qt 3 is\r\na good candidate for high visual compression. See the command line parameters for\r\ndetails. Furthermore, the -dz parameter enables a deadzone quantizer that improves\r\nthe compression performance by 0.3 dB on average.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.31:\r\n\r\nThis release includes two minor changes that have been made to the specs at the last \r\nWarsaw meeting in June 2015. The order of the FDCT (fixed point DCT) has been adjusted\r\nto match the order of ISO/IEC 23002-2 (MPEG C) and to be consistent with the order of\r\nthe IDCT (integer DCT). Second, the specs allow now Integer Table Lookup boxes with\r\nsample size > 16 bits to allow the usage of a Table lookup in the residual coding\r\npath for part 8 of the specs.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.40:\r\n\r\nIn this release, we included additional support for \"full profile\" encoding, i.e.\r\nencoding parameters that do not fit any of the four profiles specified in 18477-7.\r\nUsing such encoding parameters will generate a warning on the command line, but\r\nencoding will proceed anyhow, generating a bitstream that conforms to 18477-7, but\r\nnot to any of the profiles in this standard.\r\n\r\nWith \"-profile a -g 0\" or \"-profile b -g 0\" the encoder will generate a file that\r\nuses an inverse TMO lookup similar to profile C with other encoding parameters\r\nidentical to those defined by profiles A and B.\r\n\r\nThe command line option \"-lr\" will use a logarithmic encoding instead of the gamma\r\nencoding for profile B. Again, this will leave the profile, but will be within the\r\nbounds of 18477-7.\r\n\r\nOther than that, a couple of bug fixes have been made. Profile A and B setup could\r\nnot reset the toe value for the inverse gamma map, due to a typo of one of the\r\nparameters. Profile B accepted a different gamma value than the default, but never\r\ncommunicated it to the core code, i.e. it was simply ignored. Profile B setup ignored\r\nthe epsilon values for numerator and denomiator, and they were communicated wrongly\r\ninto the core code. This was corrected, and epsilons can now be specified on the\r\ncommand line. The JPEG LS part-2 encoder was broken due to a modification of the\r\ncolor transformer factory, and the (non-standardized, proprietary) residual\r\nrefinement arithmetic coding scan mode did not work correctly by depending on a non-\r\nexisting context.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.50:\r\n\r\nThis release fixes encoding of ISO/IEC 18477-8 if the IDCT was selected as\r\ntransformation in the extension layer and refinement scans were added, i.e.\r\nthe command line options -rl -rR 4 created invalid codestreams. Previous\r\nreleases used the wrong type of refinement scan (dct bypass refinement instead\r\nof regular refinement) and hence broke reconstruction. Furthermore, previous\r\nreleases no longer allowed near lossless coding with DCT bypass. Instead, regular\r\nDCT coding conforming to ISO/IEC 18477-7 was used. To enable the near-lossless\r\nDCT bypass mode, use the new option \"-ro\" now.\r\n\r\nProfile B encoding could potentially create codestreams that run into\r\nclipping of the extension channel; this always happens if the denominator is\r\nlarger than 1, and has to happen according to Annex C of ISO/IEC 18477-3:2015.\r\nThis release avoids this issue by adjusting the exposure value such that\r\nthe denominator always remains smaller than 1.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.51:\r\n\r\nIf the JPEG-XT markers were delayed to the frame-header intead the global\r\nheader, the previous code did not built up the necessary infrastructure\r\nto compute the checksum and hence could not verify the checksum in such\r\na condition. The 1.51 release fixes this problem.\r\n\r\n-------------------------------------------------------------------------------------\r\n\r\nRelease 1.52:\r\n\r\nThis file is an updated/enhanced version of the 1.50 release of\r\nthe JPEG XT demo software found on https://github.com/thorfdbg/. It\r\nincludes additional features presented in the paper\r\n\"JPEG on Steroids : Common Optimization Techniques for JPEG Image Compression\"\r\nby the same author.\r\n\r\nIn specific, the following command line flags are *NEW* to this version and\r\nare available only as a contribution to ICIP 2016:\r\n\r\n-oz:\t      This enables the dynamic programming algorithm to enhance\r\nthe rate-distortion performance by soft-threshold quantization. It has been\r\nused for the tests in section 3.3 of the paper.\r\n\r\n-dr: \t     This enables the smart de-ringing algorithm that has been used\r\nin section 3.6.\r\n\r\nAdditionally, the following switches have been used for other subsections\r\nof the paper; they are not new to this distribution but available as\r\npart of the regular libjpeg distribution at github or www.jpeg.org:\r\n\r\n-s 1x1,2x2,2x2:\t    Enable 420 subsampling (444 is default)\r\n-s 1x1,2x1,2x1:\t    Enable 422 subsampling (444 is default)\r\n-qt n (n=0..8)\t    Use quantization matrix n.\r\n      \t\t    In the paper, n=1 (flat) was used for PSNR-optimized\r\n\t\t    coding, unless otherwise noted.\r\n-dz\t\t    The deadzone quantizer in section 3.3\r\n\t\t    (simpler than -oz)\r\n-v\t\t    Enable coding in processive mode (section 3.5)\r\n-v -qv\t\t    Optimized progressive mode (section 3.5)\r\n-h \t\t    Optimized Huffman coding (always used, unless noted\r\n\t\t    otherwise, see section 3.4)\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.53:\r\n\r\nThis release includes additional functionality to inject markers, or\r\nretrieve markers from a codestream while reading. For that, set\r\nthe JPGTAG_ENCODER_STOP tag of the JPEG::Write() call to a bitmask\r\nwhere the encoder should interrupt writing data (this flag already\r\nexisted before) then write custom data with JPEG::WriteMarker(), then\r\ncontinue with JPEG::Write(). On decoding, set JPGTAG_DECODER_STOP to\r\na bitmask where to stop for markers, then identify markers with\r\nJPEG::PeekMarker(), and retrieve them with JPEG::ReadMarker(). Details\r\ncan be found in cmd/encodec.cpp for encoding, and cmd/reconstruct.cpp.\r\n\r\nOtherwise, no functional changes.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.54:\r\n\r\nIn this release, upsampling has been made conforming to the latest\r\ncorrigendum of 18477-1 and 18477-8. In particular, upsampling is now\r\nby design always centered and never co-sited. The co-sited upsampling\r\nprocedure is still included in the source code, but never executed.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.55:\r\n\r\nThis release only addresses some minor formulation issues of the\r\ncommand line such that references are formatted properly to make this\r\nsoftware package acceptable as a JPEG reference software.\r\nNo functional changes.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.56:\r\n\r\nEncoding and reconstruction of 2-component images was actually never\r\nsupported, as it was considered a rather exotic use-case. Now that a\r\nrequest was made, support for 2-components was added and should\r\nhopefully work ok.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.57:\r\n\r\nNewer g++ compiler versions warned about implicit fall-throughs in switch/\r\ncase constructs that are actually harmless. This release adds an autoconf\r\ndetection of such compiler versions, adds consistent comments throughout\r\nthe code, and disables the compiler warning were necessary.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.58:\r\n\r\nThis release fixes multiple spelling errors in the file, thanks to\r\nMathieu Mmalaterre for finding and fixing them. The release also\r\naddresses multiple race conditions and improves stability and robustness\r\non invalid streams. Thanks to seviezhou for providing codestreams that\r\ntriggered these defects. In particular, the following defects have\r\nbeen found:\r\n\r\n- when a codestream with unsupported upsampling specification (beyond\r\n  18477-1) was found, the code crashed.\r\n- JPEG LS single component scans did not check whether there is actually\r\n  only a single component referenced in the scan.\r\n- An invalid DC category in the sequential scan could have caused a\r\n  crash in the follow-up decoding.\r\n- AC-coded lossless JPEG scans with horizontal subsampling factors\r\n  trashed memory.\r\n- MCU sizes of 0 remained undetected and caused crashes due to a\r\n  division-by-zero exception.\r\n- The code did not check whether a scan references the same component\r\n  more than once and could have failed with strange effects then.\r\n- The code did not handle EOF conditions in the frame header\r\n  gracefully.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.59:\r\n\r\nThis release addresses a defect in the MCU handling for JPEG LS scans.\r\nThe previous code forgot to reset the JPEG LS state variables on MCU\r\nscan boundaries, thus defeating the independent decodability of MCUs\r\nif restart markers are inserted into the stream. Thanks to Spyros for\r\ndetecting this defect.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.60:\r\n\r\nA specially crafted bitstream depending on line-based JPEG processes\r\ncould trigger a segfault because source data the reconstruction\r\nprocess depended upon were not available. This has been fixed.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.61:\r\n\r\nThe restart interval for JPEG LS streams, specifically, is allowed to\r\nbe larger than 2^16. Modified the DRI marker accordingly. Unfortunately,\r\nas the initial tables section of a codestream of JPEG and JPEG LS is\r\nidentical, JPEG files with an invalid DRI marker size will also be\r\naccepted as valid.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.62:\r\n\r\nThe quantization table could contain entries larger than 255 for the 8-bit\r\nDCT process, even though the standard prohibits this. Now the quantization\r\ntable entries are clipped to the allowed range.\r\nAdded an option -bl to force encoding in the baseline sequential process.\r\nAdded options to read the quantization tables from files rather than using\r\nthe built-in defaults.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.63:\r\n\r\nIn case the decoder was started with an image containing an alpha channel,\r\ni.e. a 18477-9 image, and no output file for the alpha channel was\r\nprovided, the decoder crashed. This issue was fixed, the alpha channel is\r\nnow in this case simply disregarded. Note that you can define the output\r\nfile for the alpha channel with the \"-al\" command line option.\r\n\r\n--------------------------------------------------------------------------\r\n\r\nRelease 1.64:\r\n\r\nThe lossless scan, the arithmetically coded lossless scan and the\r\narithmetically coded sequential scan could run into cases where an\r\nout-of-bounds symbol triggered and out-of-bounds array access and could\r\nhave crashed the decoder. The code is now more carefully changing the\r\nvalidity of the symbols and aborts with an error if it finds illegal\r\ncodes.\r\n\r\n--------------------------------------------------------------------------\r\n", "/*************************************************************************\n\n    This project implements a complete(!) JPEG (Recommendation ITU-T\n    T.81 | ISO/IEC 10918-1) codec, plus a library that can be used to\n    encode and decode JPEG streams. \n    It also implements ISO/IEC 18477 aka JPEG XT which is an extension\n    towards intermediate, high-dynamic-range lossy and lossless coding\n    of JPEG. In specific, it supports ISO/IEC 18477-3/-6/-7/-8 encoding.\n\n    Note that only Profiles C and D of ISO/IEC 18477-7 are supported\n    here. Check the JPEG XT reference software for a full implementation\n    of ISO/IEC 18477-7.\n\n    Copyright (C) 2012-2018 Thomas Richter, University of Stuttgart and\n    Accusoft. (C) 2019-2020 Thomas Richter, Fraunhofer IIS.\n\n    This program is available under two licenses, GPLv3 and the ITU\n    Software licence Annex A Option 2, RAND conditions.\n\n    For the full text of the GPU license option, see README.license.gpl.\n    For the full text of the ITU license option, see README.license.itu.\n    \n    You may freely select between these two options.\n\n    For the GPL option, please note the following:\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*************************************************************************/\n/*\n**\n** Represents the scan including the scan header.\n**\n** $Id: aclosslessscan.cpp,v 1.43 2022/05/23 05:56:51 thor Exp $\n**\n*/\n\n/// Includes\n#include \"codestream/aclosslessscan.hpp\"\n#include \"io/bytestream.hpp\"\n#include \"control/linebuffer.hpp\"\n#include \"control/linebitmaprequester.hpp\"\n#include \"control/lineadapter.hpp\"\n#include \"marker/frame.hpp\"\n#include \"marker/scan.hpp\"\n#include \"marker/component.hpp\"\n#include \"codestream/tables.hpp\"\n#include \"coding/qmcoder.hpp\"\n#include \"coding/actemplate.hpp\"\n#include \"codestream/tables.hpp\"\n#include \"codestream/predictorbase.hpp\"\n#include \"tools/line.hpp\"\n#include \"std/string.hpp\"\n///\n\n/// ACLosslessScan::ACLosslessScan\nACLosslessScan::ACLosslessScan(class Frame *frame,class Scan *scan,UBYTE predictor,UBYTE lowbit,bool differential)\n  : PredictiveScan(frame,scan,predictor,lowbit,differential)\n{ \n#if ACCUSOFT_CODE\n  m_ucCount = scan->ComponentsInScan();\n  \n  for(int i = 0;i < m_ucCount;i++) {\n    m_ucSmall[i]     = 0;\n    m_ucLarge[i]     = 1;\n  }\n\n  memset(m_plDa,0,sizeof(m_plDa));\n  memset(m_plDb,0,sizeof(m_plDb));\n#endif\n}\n///\n\n/// ACLosslessScan::~ACLosslessScan\nACLosslessScan::~ACLosslessScan(void)\n{\n#if ACCUSOFT_CODE\n  UBYTE i;\n  \n  for(i = 0;i < m_ucCount;i++) {\n    if (m_plDa[i])\n      m_pEnviron->FreeMem(m_plDa[i],sizeof(LONG) * m_ucMCUHeight[i]);\n    if (m_plDb[i])\n      m_pEnviron->FreeMem(m_plDb[i],sizeof(LONG) * m_ucMCUWidth[i] * m_ulWidth[i]);\n  }\n#endif\n}\n///\n\n/// ACLosslessScan::WriteFrameType\n// Write the marker that indicates the frame type fitting to this scan.\nvoid ACLosslessScan::WriteFrameType(class ByteStream *io)\n{\n#if ACCUSOFT_CODE\n  if (m_bDifferential) {\n    io->PutWord(0xffcf); // differential lossless sequential AC coded\n  } else {\n    io->PutWord(0xffcb); // lossless sequential AC coded\n  }\n#else\n  NOREF(io);\n#endif\n}\n///\n\n/// ACLosslessScan::FindComponentDimensions\n// Common setup for encoding and decoding.\n#if ACCUSOFT_CODE\nvoid ACLosslessScan::FindComponentDimensions(void)\n{\n  UBYTE i;\n\n  PredictiveScan::FindComponentDimensions();\n\n  for(i = 0;i < m_ucCount;i++) {\n    assert(m_plDa[i] == NULL && m_plDb[i] == NULL);\n\n    m_plDa[i] = (LONG *)(m_pEnviron->AllocMem(sizeof(LONG) * m_ucMCUHeight[i]));\n    m_plDb[i] = (LONG *)(m_pEnviron->AllocMem(sizeof(LONG) * m_ucMCUWidth[i] * m_ulWidth[i]));\n  }\n}\n#endif\n///\n\n/// ACLosslessScan::StartParseScan\nvoid ACLosslessScan::StartParseScan(class ByteStream *io,class Checksum *chk,class BufferCtrl *ctrl)\n{\n#if ACCUSOFT_CODE\n  class ACTemplate *dc;\n  int i;\n\n  FindComponentDimensions();\n\n  for(i = 0;i < m_ucCount;i++) {\n    dc = m_pScan->DCConditionerOf(i);\n    if (dc) {\n      m_ucSmall[i]    = dc->LowerThresholdOf();\n      m_ucLarge[i]    = dc->UpperThresholdOf();\n    } else {\n      m_ucSmall[i]    = 0;\n      m_ucLarge[i]    = 1;\n    }\n    memset(m_plDa[i],0,sizeof(LONG) * m_ucMCUHeight[i]); \n    memset(m_plDb[i],0,sizeof(LONG) * m_ucMCUWidth[i] * m_ulWidth[i]);\n    m_ucContext[i]    = m_pScan->DCTableIndexOf(i); \n  }\n  for(i = 0;i < 4;i++) {\n    m_Context[i].Init();\n  }\n  \n  assert(ctrl->isLineBased());\n  m_pLineCtrl = dynamic_cast<LineBuffer *>(ctrl);\n  m_pLineCtrl->ResetToStartOfScan(m_pScan);\n  m_Coder.OpenForRead(io,chk);\n#else\n  NOREF(io);\n  NOREF(chk);\n  NOREF(ctrl);\n  JPG_THROW(NOT_IMPLEMENTED,\"ACLosslessScan::StartParseScan\",\n            \"JPEG lossless not available your code release, please contact Accusoft for a full version\");\n#endif\n}\n///\n\n/// ACLosslessScan::StartWriteScan\nvoid ACLosslessScan::StartWriteScan(class ByteStream *io,class Checksum *chk,class BufferCtrl *ctrl)\n{\n#if ACCUSOFT_CODE\n  class ACTemplate *dc;\n  int i;\n\n  FindComponentDimensions();\n\n  for(i = 0;i < m_ucCount;i++) {\n    dc = m_pScan->DCConditionerOf(i);\n\n    if (dc) {\n      m_ucSmall[i]    = dc->LowerThresholdOf();\n      m_ucLarge[i]    = dc->UpperThresholdOf();\n    } else {\n      m_ucSmall[i]    = 0;\n      m_ucLarge[i]    = 1;\n    }  \n    memset(m_plDa[i],0,sizeof(LONG) * m_ucMCUHeight[i]);\n    memset(m_plDb[i],0,sizeof(LONG) * m_ucMCUWidth[i] * m_ulWidth[i]);\n    m_ucContext[i]    = m_pScan->DCTableIndexOf(i); \n  }\n  for(i = 0;i < 4;i++) {\n    m_Context[i].Init();\n  }\n    \n  assert(ctrl->isLineBased());\n  m_pLineCtrl = dynamic_cast<LineBuffer *>(ctrl);\n  m_pLineCtrl->ResetToStartOfScan(m_pScan); \n\n  EntropyParser::StartWriteScan(io,chk,ctrl);\n  \n  m_pScan->WriteMarker(io);\n  m_Coder.OpenForWrite(io,chk);\n#else \n  NOREF(io);\n  NOREF(chk);\n  NOREF(ctrl);\n  JPG_THROW(NOT_IMPLEMENTED,\"ACLosslessScan::StartWriteScan\",\n            \"JPEG lossless not available your code release, please contact Accusoft for a full version\");\n#endif\n}\n///\n\n/// ACLosslessScan::StartMeasureScan\nvoid ACLosslessScan::StartMeasureScan(class BufferCtrl *)\n{\n  JPG_THROW(NOT_IMPLEMENTED,\"ACLosslessScan::StartMeasureScan\",\n            \"arithmetic coding is always adaptive and does not require a measurement phase\");\n}\n///\n\n/// ACLosslessScan::WriteMCU\n// This is actually the true MCU-writer, not the interface that reads\n// a full line.\nvoid ACLosslessScan::WriteMCU(struct Line **prev,struct Line **top)\n{ \n#if ACCUSOFT_CODE\n  UBYTE c;\n  //\n  // Parse a single MCU, which is now a group of pixels.\n  for(c = 0;c < m_ucCount;c++) {\n    struct QMContextSet &contextset = m_Context[m_ucContext[c]];\n    struct Line *line = top[c];\n    struct Line *pline= prev[c];\n    UBYTE ym = m_ucMCUHeight[c];\n    class PredictorBase *mcupred = m_pPredict[c];\n    ULONG  x = m_ulX[c];\n    LONG *lp = line->m_pData + x;\n    LONG *pp = (pline)?(pline->m_pData + x):(NULL);\n    //\n    // Write MCUwidth * MCUheight coefficients starting at the line top.\n    do {\n      class PredictorBase *pred = mcupred;\n      UBYTE xm = m_ucMCUWidth[c];\n      do {\n        // Decode now the difference between the predicted value and\n        // the real value.\n        LONG v = pred->EncodeSample(lp,pp);\n        //\n        // Get the sign coding context.\n        struct QMContextSet::ContextZeroSet &zset = contextset.ClassifySignZero(m_plDa[c][ym-1],m_plDb[c][x],\n                                                                                m_ucSmall[c],m_ucLarge[c]);\n        // \n        if (v) {\n          LONG sz;\n          m_Coder.Put(zset.S0,true);\n          //\n          if (v < 0) {\n            m_Coder.Put(zset.SS,true);\n            sz = -(v + 1);\n          } else {\n            m_Coder.Put(zset.SS,false);\n            sz =   v - 1;\n          }\n          //\n          if (sz >= 1) {\n            struct QMContextSet::MagnitudeSet &mset = contextset.ClassifyMagnitude(m_plDb[c][x],m_ucLarge[c]);\n            int  i = 0;\n            LONG m = 2;\n            //\n            m_Coder.Put((v > 0)?(zset.SP):(zset.SN),true);\n            //\n            while(sz >= m) {\n              m_Coder.Put(mset.X[i],true);\n              m <<= 1;\n              i++;\n            }\n            m_Coder.Put(mset.X[i],false);\n            //\n            m >>= 1;\n            while((m >>= 1)) {\n              m_Coder.Put(mset.M[i],(m & sz)?(true):(false));\n            }\n          } else {\n            m_Coder.Put((v > 0)?(zset.SP):(zset.SN),false);\n          }\n        } else {\n          m_Coder.Put(zset.S0,false);\n        }\n        //\n        // Update Da and Db.\n        // Is this a bug? 32768 does not exist, but -32768 does. \n        // The reference streams use -32768, so let's stick to that.\n        m_plDb[c][x]    = v;\n        m_plDa[c][ym-1] = v;\n        //\n        // One pixel done. Proceed to the next in the MCU. Note that\n        // the lines have been extended such that always a complete MCU is present.\n      } while(--xm && (lp++,pp++,x++,pred = pred->MoveRight(),true));\n      //\n      // Go to the next line.\n    } while(--ym && (pp = line->m_pData + (x = m_ulX[c]),line = (line->m_pNext)?(line->m_pNext):(line),\n                     lp = line->m_pData + x,mcupred = mcupred->MoveDown(),true));\n  }\n#else\n  NOREF(prev);\n  NOREF(top);\n#endif\n}\n///\n\n/// ACLosslessScan::ParseMCU\n// The actual MCU-parser, write a single group of pixels to the stream,\n// or measure their statistics.\nvoid ACLosslessScan::ParseMCU(struct Line **prev,struct Line **top)\n{ \n#if ACCUSOFT_CODE\n  UBYTE c;\n  //\n  // Parse a single MCU, which is now a group of pixels.\n  for(c = 0;c < m_ucCount;c++) {\n    struct QMContextSet &contextset = m_Context[m_ucContext[c]];\n    struct Line *line = top[c];\n    struct Line *pline= prev[c];\n    UBYTE ym = m_ucMCUHeight[c];\n    ULONG  x = m_ulX[c];\n    class PredictorBase *mcupred = m_pPredict[c];\n    LONG *lp = line->m_pData + x;\n    LONG *pp = (pline)?(pline->m_pData + x):(NULL);\n    //\n    // Parse MCUwidth * MCUheight coefficients starting at the line top.\n    do {\n      class PredictorBase *pred = mcupred;\n      UBYTE xm = m_ucMCUWidth[c];\n      do {\n        // Decode now the difference between the predicted value and\n        // the real value.\n        LONG v;\n        //\n        // Get the sign coding context.\n        struct QMContextSet::ContextZeroSet &zset = contextset.ClassifySignZero(m_plDa[c][ym-1],m_plDb[c][x],\n                                                                                m_ucSmall[c],m_ucLarge[c]);\n        //\n        if (m_Coder.Get(zset.S0)) {\n          LONG sz   = 0;\n          bool sign = m_Coder.Get(zset.SS); // true for negative.\n          //\n          if (m_Coder.Get((sign)?(zset.SN):(zset.SP))) {\n            struct QMContextSet::MagnitudeSet &mset = contextset.ClassifyMagnitude(m_plDb[c][x],m_ucLarge[c]);\n            int  i = 0;\n            LONG m = 2;\n            //\n            while(m_Coder.Get(mset.X[i])) {\n              m <<= 1;\n              if (++i >= QMContextSet::MagnitudeSet::MagnitudeContexts)\n                JPG_THROW(MALFORMED_STREAM,\"ACLosslessScan::ParseMCU\",\n                          \"received an out-of-bounds signal while parsing an AC-coded lossless symbol\");\n            }\n            //\n            m >>= 1;\n            sz  = m;\n            while((m >>= 1)) {\n              if (m_Coder.Get(mset.M[i])) {\n                sz |= m;\n              }\n            }\n          }\n          //\n          if (sign) {\n            v = -sz - 1;\n          } else {\n            v =  sz + 1;\n          }\n        } else {\n          v = 0;\n        }\n        //\n        // Use the prediction to fill in the sample.\n        lp[0] = pred->DecodeSample(v,lp,pp);\n        // Update Da and Db.\n        // Is this a bug? 32768 does not exist, but -32768 does. The streams\n        // seem to use -32768 instead.\n        m_plDb[c][x]    = v;\n        m_plDa[c][ym-1] = v;\n        //\n        // One pixel done. Proceed to the next in the MCU. Note that\n        // the lines have been extended such that always a complete MCU is present.\n      } while(--xm && (lp++,pp++,x++,pred = pred->MoveRight(),true));\n      //\n      // Go to the next line.\n    } while(--ym && (pp = line->m_pData + (x = m_ulX[c]),line = (line->m_pNext)?(line->m_pNext):(line),\n                     lp = line->m_pData + x,mcupred = mcupred->MoveDown(),true));\n  }\n#else\n  NOREF(prev);\n  NOREF(top);\n#endif\n}\n///\n\n/// ACLosslessScan::WriteMCU\n// Write a single MCU in this scan. Actually, this is not quite true,\n// as we write an entire group of eight lines of pixels, as a MCU is\n// here a group of pixels. But it is more practical this way.\nbool ACLosslessScan::WriteMCU(void)\n{\n#if ACCUSOFT_CODE\n  int i;\n  struct Line *top[4],*prev[4];\n  int lines      = 8; // total number of MCU lines processed.\n  \n  for(i = 0;i < m_ucCount;i++) {\n    class Component *comp = ComponentOf(i);\n    UBYTE idx       = comp->IndexOf();\n    top[i]          = m_pLineCtrl->CurrentLineOf(idx);\n    prev[i]         = m_pLineCtrl->PreviousLineOf(idx);\n    m_ulX[i]        = 0;\n    m_ulY[i]        = m_pLineCtrl->CurrentYOf(idx);\n  }\n\n  // Loop over lines and columns\n  do {\n    do {\n      BeginWriteMCU(m_Coder.ByteStreamOf());\n      //\n      WriteMCU(prev,top);\n    } while(AdvanceToTheRight());\n    //\n    // Reset conditioning to the left\n    for(i = 0;i < m_ucCount;i++) {\n      memset(m_plDa[i],0,sizeof(LONG) * m_ucMCUHeight[i]);\n    }\n    //\n    // Advance to the next line.\n  } while(AdvanceToTheNextLine(prev,top) && --lines);\n#endif\n  return false;\n}\n///\n\n/// ACLosslessScan::ParseMCU\n// Parse a single MCU in this scan. Actually, this is not quite true,\n// as we write an entire group of eight lines of pixels, as a MCU is\n// here a group of pixels. But it is more practical this way.\nbool ACLosslessScan::ParseMCU(void)\n{\n#if ACCUSOFT_CODE\n  int i;\n  struct Line *top[4],*prev[4];\n  int lines      = 8; // total number of MCU lines processed.\n\n  for(i = 0;i < m_ucCount;i++) {\n    class Component *comp = ComponentOf(i);\n    UBYTE idx       = comp->IndexOf();\n    top[i]          = m_pLineCtrl->CurrentLineOf(idx);\n    prev[i]         = m_pLineCtrl->PreviousLineOf(idx);\n    m_ulX[i]        = 0;\n    m_ulY[i]        = m_pLineCtrl->CurrentYOf(idx);\n  }\n\n  // Loop over lines and columns\n  do {\n    bool startofline = true;\n    do {\n      if (BeginReadMCU(m_Coder.ByteStreamOf())) {\n        ParseMCU(prev,top);\n      } else {\n        // Only if this is not due to a DNL marker that has been detected.\n        if (m_ulPixelHeight != 0 && !hasFoundDNL()) {\n          ClearMCU(top);\n        } else if (!startofline) {\n          // The problem is here that the DNL marker might have been detected, even though decoding\n          // is not yet done completely. This may be because there are still just enough bits in the\n          // AC coding engine present to run a single decode. Big Outch! Just continue decoding in\n          // this case.\n          ParseMCU(prev,top);\n        } else break;\n      }\n      startofline = false;\n    } while(AdvanceToTheRight());\n    //\n    // Reset conditioning to the left\n    for(i = 0;i < m_ucCount;i++) {\n      memset(m_plDa[i],0,sizeof(LONG) * m_ucMCUHeight[i]);\n    }\n    // Advance to the next line.\n  } while(AdvanceToTheNextLine(prev,top) && --lines);\n#endif\n  return false; // no further blocks here.\n}\n///\n\n/// ACLosslessScan::StartMCURow\n// Start a MCU scan. Returns true if there are more rows.\nbool ACLosslessScan::StartMCURow(void)\n{\n#if ACCUSOFT_CODE\n  return m_pLineCtrl->StartMCUQuantizerRow(m_pScan);\n#else\n  return false;\n#endif\n}\n///\n\n/// ACLosslessScan::Flush\nvoid ACLosslessScan::Flush(bool)\n{\n#if ACCUSOFT_CODE\n  int i;\n  \n  m_Coder.Flush();\n\n  for(i = 0;i < m_ucCount;i++) {\n    memset(m_plDa[i],0,sizeof(LONG) * m_ucMCUHeight[i]);\n    memset(m_plDb[i],0,sizeof(LONG) * m_ucMCUWidth[i] * m_ulWidth[i]); // Reset conditioning to the top\n  }\n  for(i = 0;i < 4;i++) {\n    m_Context[i].Init();\n  }\n  \n  PredictiveScan::FlushOnMarker();\n  \n  m_Coder.OpenForWrite(m_Coder.ByteStreamOf(),m_Coder.ChecksumOf());\n#endif\n}\n///\n\n/// ACLosslessScan::Restart\n// Restart the parser at the next restart interval\nvoid ACLosslessScan::Restart(void)\n{ \n#if ACCUSOFT_CODE\n  int i;\n  \n  for(i = 0;i < m_ucCount;i++) {\n    memset(m_plDa[i],0,sizeof(LONG) * m_ucMCUHeight[i]);\n    memset(m_plDb[i],0,sizeof(LONG) * m_ucMCUWidth[i] * m_ulWidth[i]);\n  }\n  for(i = 0;i < 4;i++) {\n    m_Context[i].Init();\n  }\n  \n  PredictiveScan::RestartOnMarker();\n\n  m_Coder.OpenForRead(m_Coder.ByteStreamOf(),m_Coder.ChecksumOf());\n#endif\n}\n///\n", "/*************************************************************************\n\n    This project implements a complete(!) JPEG (Recommendation ITU-T\n    T.81 | ISO/IEC 10918-1) codec, plus a library that can be used to\n    encode and decode JPEG streams. \n    It also implements ISO/IEC 18477 aka JPEG XT which is an extension\n    towards intermediate, high-dynamic-range lossy and lossless coding\n    of JPEG. In specific, it supports ISO/IEC 18477-3/-6/-7/-8 encoding.\n\n    Note that only Profiles C and D of ISO/IEC 18477-7 are supported\n    here. Check the JPEG XT reference software for a full implementation\n    of ISO/IEC 18477-7.\n\n    Copyright (C) 2012-2018 Thomas Richter, University of Stuttgart and\n    Accusoft. (C) 2019-2020 Thomas Richter, Fraunhofer IIS.\n\n    This program is available under two licenses, GPLv3 and the ITU\n    Software licence Annex A Option 2, RAND conditions.\n\n    For the full text of the GPU license option, see README.license.gpl.\n    For the full text of the ITU license option, see README.license.itu.\n    \n    You may freely select between these two options.\n\n    For the GPL option, please note the following:\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*************************************************************************/\n/*\n**\n** Represents the lossless scan - lines are coded directly with predictive\n** coding, though here residuals are encoded with the arithmetic encoder.\n**\n** $Id: aclosslessscan.hpp,v 1.29 2022/05/23 05:56:51 thor Exp $\n**\n*/\n\n#ifndef CODESTREAM_ACLOSSLESSSCAN_HPP\n#define CODESTREAM_ACLOSSLESSSCAN_HPP\n\n/// Includes\n#include \"tools/environment.hpp\"\n#include \"coding/qmcoder.hpp\"\n#include \"codestream/entropyparser.hpp\"\n#include \"codestream/predictivescan.hpp\"\n///\n\n/// Forwards\nclass Frame;\nclass LineCtrl;\nclass ByteStream;\nclass LineBitmapRequester;\nclass LineBuffer;\nclass BitmaCtrl;\nclass Scan;\n///\n\n/// class LosslessScan\n// Represents the lossless scan - lines are coded directly with predictive\n// coding, though here residuals are encoded with the arithmetic encoder.\nclass ACLosslessScan : public PredictiveScan {\n  //\n#if ACCUSOFT_CODE\n  // The class used for pulling and pushing data.\n  class LineBuffer          *m_pLineCtrl;\n  //\n  // Small DC threshold value ('L' in the standard)\n  UBYTE                      m_ucSmall[4];\n  //\n  // Large DC threshold value ('U' in the specs)\n  UBYTE                      m_ucLarge[4];\n  //\n  // The context index to use.\n  UBYTE                      m_ucContext[4];\n  //\n  // Differentials from the above and left, used\n  // for prediction.\n  LONG                      *m_plDa[4];\n  LONG                      *m_plDb[4];\n  //\n  // The real worker class.\n  class QMCoder              m_Coder;\n  //\n  // Context information.\n  struct QMContextSet {\n    //\n    // The Zero-Sign coding contexts - this is a 5x5 set.\n    struct ContextZeroSet {\n      QMContext S0,SS,SP,SN;\n      //\n      void Init(void)\n      {\n        S0.Init();\n        SS.Init();\n        SP.Init();\n        SN.Init();\n      }\n    } SignZeroCoding[5][5];\n    //\n    // The Magnitude/refinement coding contexts.\n    struct MagnitudeSet {\n      enum {\n        MagnitudeContexts = 15\n      };\n      //\n      QMContext X[MagnitudeContexts];\n      QMContext M[MagnitudeContexts];\n      //\n      void Init(void)\n      {\n        for(int i = 0;i < MagnitudeContexts;i++) {\n          X[i].Init();\n          M[i].Init();\n        }\n      }\n    } MagnitudeLow,MagnitudeHigh;\n    //\n    void Init(void)\n    {\n      for(int i = 0;i <5;i++) {\n        for(int j = 0;j < 5;j++) {\n          SignZeroCoding[i][j].Init();\n        }\n      }\n      MagnitudeLow.Init();\n      MagnitudeHigh.Init();\n    }\n    //\n    // Classify and return the sign/zero coding context to encode the difference in.\n    // Requires the differences in both directions.\n    struct ContextZeroSet &ClassifySignZero(LONG Da,LONG Db,UBYTE l,UBYTE u)\n    {\n      return SignZeroCoding[Classify(Da,l,u) + 2][Classify(Db,l,u) + 2];\n    }\n    //\n    // Classify the Magnitude context \n    struct MagnitudeSet &ClassifyMagnitude(LONG Db,UBYTE u)\n    {\n      if (Db > (1 << u) || -Db > (1 << u)) {\n        return MagnitudeHigh;\n      } else {\n        return MagnitudeLow;\n      }\n    }\n    //\n    // Classifier in one direction.\n    static int Classify(LONG diff,UBYTE l,UBYTE u)\n    {\n      LONG abs = (diff > 0)?(diff):(-diff);\n  \n      if (abs <= ((1 << l) >> 1)) {\n        // the zero cathegory.\n        return 0;\n      }\n      if (abs <= (1 << u)) {\n        if (diff < 0) {\n          return -1;\n        } else {\n          return 1;\n        }\n      }\n      if (diff < 0) {\n        return -2;\n      } else {\n        return 2;\n      }\n    }\n    //\n  } m_Context[4];\n  //\n  // Common setup for encoding and decoding.\n  void FindComponentDimensions(void);\n  //\n#endif\n  // This is actually the true MCU-parser, not the interface that reads\n  // a full line.\n  void ParseMCU(struct Line **prev,struct Line **top);\n  //\n  // The actual MCU-writer, write a single group of pixels to the stream,\n  // or measure their statistics.\n  void WriteMCU(struct Line **prev,struct Line **top);\n  //\n  // Flush the remaining bits out to the stream on writing.\n  virtual void Flush(bool final); \n  // \n  // Restart the parser at the next restart interval\n  virtual void Restart(void);\n  //\n  //\npublic:\n  ACLosslessScan(class Frame *frame,class Scan *scan,UBYTE predictor,UBYTE lobit,\n                 bool differential = false);\n  //\n  virtual ~ACLosslessScan(void);\n  //\n  // Write the marker that indicates the frame type fitting to this scan.\n  virtual void WriteFrameType(class ByteStream *io);\n  //\n  // Fill in the tables for decoding and decoding parameters in general.\n  virtual void StartParseScan(class ByteStream *io,class Checksum *chk,class BufferCtrl *ctrl);\n  //\n  // Write the default tables for encoding\n  virtual void StartWriteScan(class ByteStream *io,class Checksum *chk,class BufferCtrl *ctrl);\n  //\n  // Start the measurement run - not required here.\n  virtual void StartMeasureScan(class BufferCtrl *ctrl);\n  //\n  // Start a MCU scan. Returns true if there are more rows. False otherwise.\n  // Note that we emulate here that MCUs are multiples of eight lines high\n  // even though from a JPEG perspective a MCU is a single pixel in the\n  // lossless coding case.\n  virtual bool StartMCURow(void);\n  //\n  // Parse a single MCU in this scan. Return true if there are more\n  // MCUs in this row.\n  virtual bool ParseMCU(void);\n  //\n  // Write a single MCU in this scan.\n  virtual bool WriteMCU(void);  \n};\n///\n\n\n///\n#endif\n", "/*************************************************************************\n\n    This project implements a complete(!) JPEG (Recommendation ITU-T\n    T.81 | ISO/IEC 10918-1) codec, plus a library that can be used to\n    encode and decode JPEG streams. \n    It also implements ISO/IEC 18477 aka JPEG XT which is an extension\n    towards intermediate, high-dynamic-range lossy and lossless coding\n    of JPEG. In specific, it supports ISO/IEC 18477-3/-6/-7/-8 encoding.\n\n    Note that only Profiles C and D of ISO/IEC 18477-7 are supported\n    here. Check the JPEG XT reference software for a full implementation\n    of ISO/IEC 18477-7.\n\n    Copyright (C) 2012-2018 Thomas Richter, University of Stuttgart and\n    Accusoft. (C) 2019-2020 Thomas Richter, Fraunhofer IIS.\n\n    This program is available under two licenses, GPLv3 and the ITU\n    Software licence Annex A Option 2, RAND conditions.\n\n    For the full text of the GPU license option, see README.license.gpl.\n    For the full text of the ITU license option, see README.license.itu.\n    \n    You may freely select between these two options.\n\n    For the GPL option, please note the following:\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*************************************************************************/\n/*\n**\n** Represents the scan including the scan header.\n**\n** $Id: acsequentialscan.cpp,v 1.52 2022/05/23 05:56:51 thor Exp $\n**\n*/\n\n/// Includes\n#include \"codestream/acsequentialscan.hpp\"\n#include \"codestream/tables.hpp\"\n#include \"marker/frame.hpp\"\n#include \"marker/scan.hpp\"\n#include \"marker/component.hpp\"\n#include \"coding/quantizedrow.hpp\"\n#include \"codestream/rectanglerequest.hpp\"\n#include \"dct/dct.hpp\"\n#include \"std/assert.hpp\"\n#include \"interface/bitmaphook.hpp\"\n#include \"interface/imagebitmap.hpp\"\n#include \"colortrafo/colortrafo.hpp\"\n#include \"tools/traits.hpp\"\n#include \"control/blockbitmaprequester.hpp\"\n#include \"control/blockbuffer.hpp\"\n#include \"control/blocklineadapter.hpp\"\n#include \"coding/actemplate.hpp\"\n#include \"marker/actable.hpp\"\n///\n\n/// ACSequentialScan::ACSequentialScan\nACSequentialScan::ACSequentialScan(class Frame *frame,class Scan *scan,\n                                   UBYTE start,UBYTE stop,UBYTE lowbit,UBYTE,\n                                   bool differential,bool residual,bool large)\n  : EntropyParser(frame,scan)\n#if ACCUSOFT_CODE\n  , m_pBlockCtrl(NULL),\n    m_ucScanStart(start), m_ucScanStop(stop), m_ucLowBit(lowbit),\n    m_bMeasure(false), m_bDifferential(differential), m_bResidual(residual), m_bLargeRange(large)\n#endif\n{\n#if ACCUSOFT_CODE\n  m_ucCount = scan->ComponentsInScan();\n  \n  for(UBYTE i = 0;i < m_ucCount;i++) {\n    m_ucSmall[i]     = 0;\n    m_ucLarge[i]     = 1;\n    m_ucBlockEnd[i]  = 5;\n  }\n#else\n  NOREF(start);\n  NOREF(stop);\n  NOREF(lowbit);\n  NOREF(differential);\n  NOREF(residual);\n  NOREF(large);\n#endif\n}\n///\n\n/// ACSequentialScan::~ACSequentialScan\nACSequentialScan::~ACSequentialScan(void)\n{\n}\n///\n\n/// ACSequentialScan::StartParseScan\nvoid ACSequentialScan::StartParseScan(class ByteStream *io,class Checksum *chk,class BufferCtrl *ctrl)\n{ \n#if ACCUSOFT_CODE\n  class ACTemplate *ac,*dc;\n  int i;\n\n  for(i = 0;i < m_ucCount;i++) {\n    dc = m_pScan->DCConditionerOf(i);\n    ac = m_pScan->ACConditionerOf(i); \n    \n    m_ucDCContext[i]  = m_pScan->DCTableIndexOf(i);\n    m_ucACContext[i]  = m_pScan->ACTableIndexOf(i);\n\n    if (dc) {\n      m_ucSmall[i]    = dc->LowerThresholdOf();\n      m_ucLarge[i]    = dc->UpperThresholdOf();\n    } else {\n      m_ucSmall[i]    = 0;\n      m_ucLarge[i]    = 1;\n    }\n\n    if (ac) {\n      m_ucBlockEnd[i] = ac->BandDiscriminatorOf();\n    } else {\n      m_ucBlockEnd[i] = 5;\n    }\n\n    m_lDC[i]         = 0; \n    m_lDiff[i]       = 0;\n    m_ulX[i]         = 0;\n  }\n  \n  for(i = 0;i < 4;i++) {\n    m_Context[i].Init();\n  }\n  \n  assert(!ctrl->isLineBased());\n  m_pBlockCtrl = dynamic_cast<BlockCtrl *>(ctrl);\n  m_pBlockCtrl->ResetToStartOfScan(m_pScan);\n  m_Coder.OpenForRead(io,chk);\n#else\n  NOREF(io);\n  NOREF(chk);\n  NOREF(ctrl);\n  JPG_THROW(NOT_IMPLEMENTED,\"ACSequentialScan::StartParseScan\",\n            \"Lossless JPEG not available in your code release, please contact Accusoft for a full version\");\n#endif\n}\n///\n\n/// ACSequentialScan::StartWriteScan\nvoid ACSequentialScan::StartWriteScan(class ByteStream *io,class Checksum *chk,class BufferCtrl *ctrl)\n{ \n#if ACCUSOFT_CODE\n  class ACTemplate *ac,*dc;\n  int i;\n\n  for(i = 0;i < m_ucCount;i++) {\n    dc = m_pScan->DCConditionerOf(i);\n    ac = m_pScan->ACConditionerOf(i);\n   \n    m_ucDCContext[i]  = m_pScan->DCTableIndexOf(i);\n    m_ucACContext[i]  = m_pScan->ACTableIndexOf(i);\n\n    if (dc) {\n      m_ucSmall[i]    = dc->LowerThresholdOf();\n      m_ucLarge[i]    = dc->UpperThresholdOf();\n    } else {\n      m_ucSmall[i]    = 0;\n      m_ucLarge[i]    = 1;\n    }\n\n    if (ac) {\n      m_ucBlockEnd[i] = ac->BandDiscriminatorOf();\n    } else {\n      m_ucBlockEnd[i] = 5;\n    }\n\n    m_lDC[i]           = 0;\n    m_lDiff[i]         = 0;\n    m_ulX[i]           = 0;\n  }\n  for(i = 0;i < 4;i++) {\n    m_Context[i].Init();\n  }\n\n  assert(!ctrl->isLineBased());\n  m_pBlockCtrl = dynamic_cast<BlockCtrl *>(ctrl);\n  m_pBlockCtrl->ResetToStartOfScan(m_pScan);\n\n  EntropyParser::StartWriteScan(io,chk,ctrl);\n\n  m_pScan->WriteMarker(io);\n  m_Coder.OpenForWrite(io,chk);\n#else\n  NOREF(io);\n  NOREF(chk);\n  NOREF(ctrl);\n  JPG_THROW(NOT_IMPLEMENTED,\"ACSequentialScan::StartWriteScan\",\n            \"Lossless JPEG not available in your code release, please contact Accusoft for a full version\");\n#endif\n}\n///\n\n/// ACSequentialScan::StartMeasureScan\n// Measure scan statistics.\nvoid ACSequentialScan::StartMeasureScan(class BufferCtrl *)\n{ \n  //\n  // This is not required.\n  JPG_THROW(NOT_IMPLEMENTED,\"ACSequentialScan::StartMeasureScan\",\n            \"arithmetic coding is always adaptive and does not require \"\n            \"to measure the statistics\");\n}\n///\n\n/// ACSequentialScan::StartMCURow\n// Start a MCU scan. Returns true if there are more rows.\nbool ACSequentialScan::StartMCURow(void)\n{\n#if ACCUSOFT_CODE\n  bool more = m_pBlockCtrl->StartMCUQuantizerRow(m_pScan);\n\n  for(int i = 0;i < m_ucCount;i++) {\n    m_ulX[i]   = 0;\n  }\n\n  return more;\n#else\n  return false;\n#endif\n}\n///\n\n/// ACSequentialScan::WriteMCU\n// Write a single MCU in this scan. Return true if there are more blocks in this row.\nbool ACSequentialScan::WriteMCU(void)\n{ \n#if ACCUSOFT_CODE\n  bool more = true;\n  int c;\n\n  assert(m_pBlockCtrl);\n  \n  BeginWriteMCU(m_Coder.ByteStreamOf());\n\n  for(c = 0;c < m_ucCount;c++) {\n    class Component *comp    = m_pComponent[c];\n    class QuantizedRow *q    = m_pBlockCtrl->CurrentQuantizedRow(comp->IndexOf());\n    LONG &prevdc             = m_lDC[c];\n    LONG &prevdiff           = m_lDiff[c];\n    UBYTE l                  = m_ucSmall[c];\n    UBYTE u                  = m_ucLarge[c];\n    UBYTE kx                 = m_ucBlockEnd[c];\n    UBYTE mcux               = (m_ucCount > 1)?(comp->MCUWidthOf() ):(1);\n    UBYTE mcuy               = (m_ucCount > 1)?(comp->MCUHeightOf()):(1);\n    ULONG xmin               = m_ulX[c];\n    ULONG xmax               = xmin + mcux;\n    ULONG x,y; \n    if (xmax >= q->WidthOf()) {\n      more     = false;\n    }\n    for(y = 0;y < mcuy;y++) {\n      for(x = xmin;x < xmax;x++) {\n        LONG *block,dummy[64];\n        if (q && x < q->WidthOf()) {\n          block  = q->BlockAt(x)->m_Data;\n        } else {\n          block  = dummy;\n          memset(dummy ,0,sizeof(dummy) );\n          block[0] = prevdc;\n        }\n        EncodeBlock(block,prevdc,prevdiff,l,u,kx,m_ucDCContext[c],m_ucACContext[c]);\n      }\n      if (q) q = q->NextOf();\n    }\n    // Done with this component, advance the block.\n    m_ulX[c] = xmax;\n  }\n\n  return more;\n#else\n  return false;\n#endif\n}\n///\n\n/// ACSequentialScan::Restart\n// Restart the parser at the next restart interval\nvoid ACSequentialScan::Restart(void)\n{\n#if ACCUSOFT_CODE\n  int i;\n  \n  for(i = 0;i < m_ucCount;i++) {\n    m_lDC[i]         = 0; \n    m_lDiff[i]       = 0;\n  }\n  for(i = 0;i < 4;i++) {\n    m_Context[i].Init();\n  }\n  \n  m_Coder.OpenForRead(m_Coder.ByteStreamOf(),m_Coder.ChecksumOf());\n#endif\n}\n///\n\n/// ACSequentialScan::ParseMCU\n// Parse a single MCU in this scan. Return true if there are more blocks in this row.\nbool ACSequentialScan::ParseMCU(void)\n{\n#if ACCUSOFT_CODE\n  bool more = true;\n  int c;\n\n  assert(m_pBlockCtrl);\n\n  bool valid = BeginReadMCU(m_Coder.ByteStreamOf());\n  \n  for(c = 0;c < m_ucCount;c++) {\n    class Component *comp    = m_pComponent[c];\n    class QuantizedRow *q    = m_pBlockCtrl->CurrentQuantizedRow(comp->IndexOf());\n    LONG &prevdc             = m_lDC[c];\n    LONG &prevdiff           = m_lDiff[c];\n    UBYTE l                  = m_ucSmall[c];\n    UBYTE u                  = m_ucLarge[c];\n    UBYTE kx                 = m_ucBlockEnd[c];\n    UBYTE mcux               = (m_ucCount > 1)?(comp->MCUWidthOf() ):(1);\n    UBYTE mcuy               = (m_ucCount > 1)?(comp->MCUHeightOf()):(1);\n    ULONG xmin               = m_ulX[c];\n    ULONG xmax               = xmin + mcux;\n    ULONG x,y;\n    if (xmax >= q->WidthOf()) {\n      more     = false;\n    }\n    for(y = 0;y < mcuy;y++) {\n      for(x = xmin;x < xmax;x++) {\n        LONG *block,dummy[64];\n        if (q && x < q->WidthOf()) {\n          block  = q->BlockAt(x)->m_Data;\n        } else {\n          block  = dummy;\n        }\n        if (valid) {\n          DecodeBlock(block,prevdc,prevdiff,l,u,kx,m_ucDCContext[c],m_ucACContext[c]);\n        } else {\n          for(UBYTE i = m_ucScanStart;i <= m_ucScanStop;i++) {\n            block[i] = 0;\n          }\n        }\n      }\n      if (q) q = q->NextOf();\n    }\n    // Done with this component, advance the block.\n    m_ulX[c] = xmax;\n  }\n\n  return more;\n#else\n  return false;\n#endif\n}\n///\n\n/// ACSequentialScan::Classify\n// Find the DC context class depending on the previous DC and\n// the values of L and U given in the conditioner.\n#if ACCUSOFT_CODE\nstruct ACSequentialScan::QMContextSet::DCContextZeroSet &ACSequentialScan::QMContextSet::Classify(LONG diff,UBYTE l,UBYTE u)\n{\n  LONG abs = (diff > 0)?(diff):(-diff);\n  \n  if (abs <= ((1 << l) >> 1)) {\n    // the zero cathegory.\n    return DCZero;\n  }\n  if (abs <= (1 << u)) {\n    if (diff < 0) {\n      return DCSmallNegative;\n    } else {\n      return DCSmallPositive;\n    }\n  }\n  if (diff < 0) {\n    return DCLargeNegative;\n  } else {\n    return DCLargePositive;\n  }\n}\n#endif\n///\n\n/// ACSequentialScan::EncodeBlock\n// Encode a single block\n#if ACCUSOFT_CODE\nvoid ACSequentialScan::EncodeBlock(const LONG *block,\n                                   LONG &prevdc,LONG &prevdiff,\n                                   UBYTE small,UBYTE large,UBYTE kx,UBYTE dc,UBYTE ac)\n{\n  // DC coding\n  if (m_ucScanStart == 0 && m_bResidual == false) {\n    struct QMContextSet::DCContextZeroSet &cz = m_Context[dc].Classify(prevdiff,small,large);\n    LONG diff;\n    // DPCM coding of the DC coefficient.\n    diff   = block[0] >> m_ucLowBit; // only correct for two's completement machines\n    diff  -= prevdc;\n    if (m_bDifferential) {\n      prevdc = 0;\n    } else {\n      prevdc = block[0] >> m_ucLowBit;\n    }\n\n    if (diff) {\n      LONG sz;\n      //\n      // Nonzero, encode a one in context zero.\n      m_Coder.Put(cz.S0,true);\n      //\n      // Sign coding. Encode a zero for positive and a 1 for\n      // negative.\n      if (diff < 0) {\n        m_Coder.Put(cz.SS,true);\n        sz = -diff - 1;\n      } else {\n        m_Coder.Put(cz.SS,false);\n        sz = diff - 1;\n      }\n      //\n      // Code the magnitude.\n      if (sz >= 1) {\n        int  i = 0;\n        LONG m = 2;\n        m_Coder.Put((diff > 0)?(cz.SP):(cz.SN),true);\n        //\n        // Magnitude category coding.\n        while(sz >= m) {\n          m_Coder.Put(m_Context[dc].DCMagnitude.X[i],true);\n          m <<= 1;\n          i++;\n        } \n        // Terminate magnitude cathegory coding.\n        m_Coder.Put(m_Context[dc].DCMagnitude.X[i],false);\n        //\n        // Get the MSB to code.\n        m >>= 1;\n        // Refinement bits: Depend on the magnitude category.\n        while((m >>= 1)) {\n          m_Coder.Put(m_Context[dc].DCMagnitude.M[i],(m & sz)?(true):(false));\n        }\n      } else {\n        m_Coder.Put((diff > 0)?(cz.SP):(cz.SN),false);\n      }\n    } else {\n      // Difference is zero. Encode a zero in context zero.\n      m_Coder.Put(cz.S0,false);\n    }\n    // Keep the difference for the next block.\n    prevdiff = diff;\n  }\n\n  if (m_ucScanStop) {\n    LONG data;\n    int eob,k;\n    // AC coding. Part one. Find the end of block.\n    // eob is the index of the first zero coefficient from\n    // which point on this, and all following coefficients\n    // up to coefficient with index 63 are zero.\n    eob = m_ucScanStop;\n    k   = (m_ucScanStart)?(m_ucScanStart):((m_bResidual)?0:1);\n    //\n    while(eob >= k) {\n      data = block[DCT::ScanOrder[eob]];\n      if ((data >= 0)?(data >> m_ucLowBit):((-data) >> m_ucLowBit))\n        break;\n      eob--;\n    }\n    // The coefficient at eob is now nonzero, but eob+1 is\n    // a zero coefficient or beyond the block end.\n    eob++; // the first coefficient *not* to code.\n\n    do {\n      LONG data,sz;\n      //\n      if (k == eob) {\n        m_Coder.Put(m_Context[ac].ACZero[k-1].SE,true); // Code EOB.\n        break;\n      }\n      // Not EOB.\n      m_Coder.Put(m_Context[ac].ACZero[k-1].SE,false);\n      //\n      // Run coding in S0. Since k is not the eob, at least\n      // one non-zero coefficient must follow, so we cannot\n      // run over the end of the block.\n      do {\n        data = block[DCT::ScanOrder[k]];\n        data = (data >= 0)?(data >> m_ucLowBit):(-((-data) >> m_ucLowBit));\n        if (data == 0) {\n          m_Coder.Put(m_Context[ac].ACZero[k-1].S0,false);\n          k++;\n        }\n      } while(data == 0);\n      m_Coder.Put(m_Context[ac].ACZero[k-1].S0,true);\n      //\n      // The coefficient at k is now nonzero. First code\n      // the sign. This context is the uniform.\n      if (data < 0) {\n        m_Coder.Put(m_Context[ac].Uniform,true);\n        sz = -data - 1;\n      } else {\n        m_Coder.Put(m_Context[ac].Uniform,false);\n        sz =  data - 1;\n      }\n      //\n      // Code the magnitude category. \n      if (sz >= 1) {\n        m_Coder.Put(m_Context[ac].ACZero[k-1].SP,true); // SP or SN coding.\n        if (sz >= 2) {\n          int  i = 0;\n          LONG m = 4;\n          struct QMContextSet::ACContextMagnitudeSet &acm = (k > kx)?(m_Context[ac].ACMagnitudeHigh):(m_Context[ac].ACMagnitudeLow);\n          //\n          m_Coder.Put(m_Context[ac].ACZero[k-1].SP,true); // X1 coding, identical to SN and SP.\n          // Note that AC_SN,AC_SP and AC_X1 are all the same context\n          // all following decisions are not conditioned on k directly.\n          while(sz >= m) {\n            m_Coder.Put(acm.X[i],true);\n            m <<= 1;\n            i++;\n          }\n          m_Coder.Put(acm.X[i],false);\n          //\n          // Get the MSB to code.\n          m >>= 1;\n          //\n          // Magnitude refinement coding.\n          while((m >>= 1)) {\n            m_Coder.Put(acm.M[i],(m & sz)?true:false);\n          }\n        } else {\n          m_Coder.Put(m_Context[ac].ACZero[k-1].SP,false);\n        }\n      } else {\n        m_Coder.Put(m_Context[ac].ACZero[k-1].SP,false);\n      }\n      //\n      // Encode the next coefficient. Note that this bails out early without an\n      // S0 encoding if the end is reached.\n    } while(++k <= m_ucScanStop);\n  }\n}\n#endif\n///\n\n/// ACSequentialScan::DecodeBlock\n// Decode a single block.\n#if ACCUSOFT_CODE\nvoid ACSequentialScan::DecodeBlock(LONG *block,\n                                   LONG &prevdc,LONG &prevdiff,\n                                   UBYTE small,UBYTE large,UBYTE kx,UBYTE dc,UBYTE ac)\n{\n  // DC coding\n  if (m_ucScanStart == 0 && m_bResidual == false) {\n    LONG diff;\n    struct QMContextSet::DCContextZeroSet &cz = m_Context[dc].Classify(prevdiff,small,large);\n    // Check whether the difference is nonzero.\n    if (m_Coder.Get(cz.S0)) {\n      LONG sz;\n      bool sign = m_Coder.Get(cz.SS); // sign coding, is true for negative.\n      //\n      //\n      // Positive and negative are encoded in different contexts.\n      // Decode the magnitude cathegory.\n      if (m_Coder.Get((sign)?(cz.SN):(cz.SP))) {\n        int  i = 0;\n        LONG m = 2;\n        \n        while(m_Coder.Get(m_Context[dc].DCMagnitude.X[i])) {\n          m <<= 1;\n          if(++i >= QMContextSet::DCContextMagnitudeSet::MagnitudeContexts)\n            JPG_THROW(MALFORMED_STREAM,\"ACSequentialScan::DecodeBlock\",\n                      \"QMDecoder is out of sync\");\n        }\n        //\n        // Get the MSB to decode.\n        m >>= 1;\n        sz  = m;\n        //\n        // Refinement coding of remaining bits.\n        while((m >>= 1)) {\n          if (m_Coder.Get(m_Context[dc].DCMagnitude.M[i])) {\n            sz |= m;\n          }\n        }\n      } else {\n        sz = 0;\n      }\n      //\n      // Done, finally, include the sign and the offset.\n      if (sign) {\n        diff = -sz - 1;\n      } else {\n        diff = sz + 1;\n      }\n    } else {\n      // Difference is zero.\n      diff = 0;\n    }\n\n    prevdiff = diff;\n    if (m_bDifferential) {\n      prevdc   = diff;\n    } else {\n      prevdc  += diff;\n    }\n    block[0] = prevdc << m_ucLowBit; // point transformation\n  }\n\n  if (m_ucScanStop) {\n    // AC coding. No block skipping used here.\n    int k = (m_ucScanStart)?(m_ucScanStart):((m_bResidual)?0:1);\n    //\n    // EOB decoding.\n    while(k <= m_ucScanStop && !m_Coder.Get(m_Context[ac].ACZero[k-1].SE)) {\n      LONG sz;\n      bool sign;\n      //\n      // Not yet EOB. Run coding in S0: Skip over zeros.\n      while(!m_Coder.Get(m_Context[ac].ACZero[k-1].S0)) {\n        k++;\n        if (k > m_ucScanStop)\n          JPG_THROW(MALFORMED_STREAM,\"ACSequentialScan::DecodeBlock\",\n                    \"QMDecoder is out of sync\");\n      }\n      //\n      // Now decode the sign of the coefficient.\n      // This happens in the uniform context.\n      sign = m_Coder.Get(m_Context[ac].Uniform);\n      //\n      // Decode the magnitude.\n      if (m_Coder.Get(m_Context[ac].ACZero[k-1].SP)) {\n        // X1 coding, identical to SN and SP.\n        if (m_Coder.Get(m_Context[ac].ACZero[k-1].SP)) {\n          int  i = 0;\n          LONG m = 4;\n          struct QMContextSet::ACContextMagnitudeSet &acm = (k > kx)?(m_Context[ac].ACMagnitudeHigh):(m_Context[ac].ACMagnitudeLow);\n          \n          while(m_Coder.Get(acm.X[i])) {\n            m <<= 1;\n            if(++i >= QMContextSet::ACContextMagnitudeSet::MagnitudeContexts)\n              JPG_THROW(MALFORMED_STREAM,\"ACSequentialScan::DecodeBlock\",\n                        \"QMDecoder is out of sync\");\n          }\n          //\n          // Get the MSB to decode\n          m >>= 1;\n          sz  = m;\n          //\n          // Proceed to refinement.\n          while((m >>= 1)) {\n            if (m_Coder.Get(acm.M[i])) {\n              sz |= m;\n            }\n          }\n        } else {\n          sz = 1;\n        }\n      } else {\n        sz = 0;\n      }\n      //\n      // Done. Finally, include sign and offset.\n      sz++;\n      if (sign) \n        sz = -sz;\n      block[DCT::ScanOrder[k]] = sz << m_ucLowBit;\n      //\n      // Proceed to the next block.\n      k++;\n    }\n  }\n}\n#endif\n///\n\n/// ACSequentialScan::WriteFrameType\n// Write the marker that indicates the frame type fitting to this scan.\nvoid ACSequentialScan::WriteFrameType(class ByteStream *io)\n{\n#if ACCUSOFT_CODE\n  UBYTE hidden = m_pFrame->TablesOf()->HiddenDCTBitsOf();\n\n  if (m_ucScanStart > 0 || m_ucScanStop < 63 || m_ucLowBit > hidden) {\n    // is progressive.\n    if (m_bResidual) {\n      io->PutWord(0xffba); // progressive sequential\n    } else {\n      if (m_bDifferential) {\n        io->PutWord(0xffce);\n      } else {\n        io->PutWord(0xffca);\n      }\n    }\n  } else {\n    if (m_bResidual) {\n      io->PutWord(0xffb9); // residual AC sequential\n    } else if (m_bDifferential) {\n      io->PutWord(0xffcd); // AC differential sequential\n    } else if (m_bLargeRange) {\n      io->PutWord(0xffbb);\n    } else {\n      io->PutWord(0xffc9); // AC sequential\n    }\n  }\n#else\n  NOREF(io);\n#endif\n}\n///\n\n/// ACSequentialScan::Flush\n// Flush the remaining bits out to the stream on writing.\nvoid ACSequentialScan::Flush(bool)\n{\n#if ACCUSOFT_CODE\n  int i;\n  \n  m_Coder.Flush();\n\n  for(i = 0;i < m_ucCount;i++) {\n    m_lDC[i]    = 0;\n    m_lDiff[i]  = 0;\n  }\n  for(i = 0;i < 4;i++) {\n    m_Context[i].Init();\n  }\n  \n  m_Coder.OpenForWrite(m_Coder.ByteStreamOf(),m_Coder.ChecksumOf());\n#endif\n}\n///\n\n/// ACSequentialScan::OptimizeBlock\n// Make an R/D optimization for the given scan by potentially pushing\n// coefficients into other bins. \nvoid ACSequentialScan::OptimizeBlock(LONG, LONG, UBYTE ,double ,\n                                     class DCT *,LONG [64])\n{\n  JPG_THROW(NOT_IMPLEMENTED,\"ACSequentialScan::OptimizeBlock\",\n            \"Rate-distortion optimization is not implemented for arithmetic coding\");\n}\n///\n\n/// ACSequentialScan::OptimizeDC\n// Make an R/D optimization for the given scan by potentially pushing\n// coefficients into other bins. \nvoid ACSequentialScan::OptimizeDC(void)\n{\n  JPG_THROW(NOT_IMPLEMENTED,\"ACSequentialScan::OptimizeDC\",\n            \"Rate-distortion optimization is not implemented for arithmetic coding\");\n}\n///\n\n/// ACSequentialScan::StartOptimizeScan\n// Start making an optimization run to adjust the coefficients.\nvoid ACSequentialScan::StartOptimizeScan(class BufferCtrl *)\n{  \n  JPG_THROW(NOT_IMPLEMENTED,\"ACSequentialScan::StartOptimizeScan\",\n            \"Rate-distortion optimization is not implemented for arithmetic coding\");\n}\n///\n", "/*************************************************************************\n\n    This project implements a complete(!) JPEG (Recommendation ITU-T\n    T.81 | ISO/IEC 10918-1) codec, plus a library that can be used to\n    encode and decode JPEG streams. \n    It also implements ISO/IEC 18477 aka JPEG XT which is an extension\n    towards intermediate, high-dynamic-range lossy and lossless coding\n    of JPEG. In specific, it supports ISO/IEC 18477-3/-6/-7/-8 encoding.\n\n    Note that only Profiles C and D of ISO/IEC 18477-7 are supported\n    here. Check the JPEG XT reference software for a full implementation\n    of ISO/IEC 18477-7.\n\n    Copyright (C) 2012-2018 Thomas Richter, University of Stuttgart and\n    Accusoft. (C) 2019-2020 Thomas Richter, Fraunhofer IIS.\n\n    This program is available under two licenses, GPLv3 and the ITU\n    Software licence Annex A Option 2, RAND conditions.\n\n    For the full text of the GPU license option, see README.license.gpl.\n    For the full text of the ITU license option, see README.license.itu.\n    \n    You may freely select between these two options.\n\n    For the GPL option, please note the following:\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*************************************************************************/\n/*\n**\n** Represents the scan including the scan header for the\n** arithmetic coding procedure.\n**\n** $Id: acsequentialscan.hpp,v 1.39 2022/05/23 05:56:51 thor Exp $\n**\n*/\n\n#ifndef CODESTREAM_ACSEQUENTIALSCAN_HPP\n#define CODESTREAM_ACSEQUENTIALSCAN_HPP\n\n/// Includes\n#include \"tools/environment.hpp\"\n#include \"coding/qmcoder.hpp\"\n#include \"coding/quantizedrow.hpp\"\n#include \"codestream/entropyparser.hpp\"\n///\n\n/// Forwards\nclass Tables;\nclass ByteStream;\nclass DCT;\nclass Frame;\nstruct RectangleRequest;\nclass BitmapCtrl;\nclass LineAdapter;\nclass BufferCtrl;\nclass BlockBuffer;\nclass BlockCtrl;\n///\n\n/// class ACSequentialScan\nclass ACSequentialScan : public EntropyParser {\n  //\n#if ACCUSOFT_CODE\n  //\n  // The QM coder doing the main work here.\n  class QMCoder            m_Coder;\n  //\n  // Last DC value, required for the DPCM coder.\n  LONG                     m_lDC[4];\n  //\n  // Last difference value, required for selecting the\n  // AC coding context.\n  LONG                     m_lDiff[4];\n  //\n  // Context information\n  struct QMContextSet {\n    //\n    // The DC Coding context set.\n    struct DCContextZeroSet {\n      QMContext S0,SS,SP,SN;\n      //\n      // Initialize\n#ifdef DEBUG_QMCODER  \n      void Init(const char *base)\n      {\n        char string[5] = \"Z0S0\";\n        memcpy(string,base,2);\n        S0.Init(string);\n        string[3] = 'S';\n        SS.Init(string);\n        string[3] = 'P';\n        SP.Init(string);\n        string[3] = 'N';\n        SN.Init(string);\n      }\n#else\n      void Init(void)\n      {\n        S0.Init();\n        SS.Init();\n        SP.Init();\n        SN.Init();\n      }\n#endif\n      //\n    } DCZero,DCSmallPositive,DCSmallNegative,DCLargePositive,DCLargeNegative;\n    //\n    // The DC Magnitude coding contexts.\n    struct DCContextMagnitudeSet {\n      enum {\n        MagnitudeContexts = 19\n      };\n      //\n      QMContext X[MagnitudeContexts];\n      QMContext M[MagnitudeContexts];\n      //\n      // Initialize\n      void Init(void)\n      {\n        for(int i = 0;i < MagnitudeContexts;i++) {\n#ifdef DEBUG_QMCODER\n          char string[5] = \"X0  \";\n          string[1] = (i / 10) + '0';\n          string[2] = (i % 10) + '0';\n          X[i].Init(string);\n          string[0] = 'M';\n          M[i].Init(string);\n#else\n          X[i].Init();\n          M[i].Init();\n#endif\n        }\n      }\n    } DCMagnitude;\n    //\n    // The AC Coding Contexts.\n    struct ACContextZeroSet {\n      QMContext SE,S0,SP;\n      //\n      // Initialize.\n#ifdef DEBUG_QMCODER\n      void Init(int i)\n      {\n        char string[5] = \"se00\";\n        string[2] = (i / 10) + '0';\n        string[3] = (i % 10) + '0';\n        SE.Init(string);\n        string[1] = '0';\n        S0.Init(string);\n        string[1] = 'p';\n        SP.Init(string);\n      }\n#else\n      void Init(void)\n      {\n        SE.Init();\n        S0.Init();\n        SP.Init();\n      }\n#endif\n    } ACZero[63];\n    //\n    // The AC Magnitude coder.\n    struct ACContextMagnitudeSet {\n      enum {\n        MagnitudeContexts = 18\n      };\n      //\n      QMContext X[MagnitudeContexts];\n      QMContext M[MagnitudeContexts];\n      //\n#ifdef DEBUG_QMCODER\n      void Init(bool hi) \n      {\n        for(int i = 0;i < MagnitudeContexts;i++) {\n          char string[5] = \"xl00\";\n          string[1] = (hi)?('h'):('l');\n          string[2] = (i / 10) + '0';\n          string[3] = (i % 10) + '0';\n          X[i].Init(string);\n          string[0] = 'm';\n          M[i].Init(string);\n        }\n      }\n#else\n      void Init(void)\n      {\n        for(int i = 0;i < MagnitudeContexts;i++) {\n          X[i].Init();\n          M[i].Init();\n        }\n      }\n#endif\n    } ACMagnitudeLow,ACMagnitudeHigh; // Exists only twice.\n    //\n    // The uniform context.\n    QMContext Uniform;\n    //\n    // Initialize the full beast.\n    void Init(void)\n    {\n#ifdef DEBUG_QMCODER \n      DCZero.Init(\"Z0\");\n      DCSmallPositive.Init(\"L+\");\n      DCSmallNegative.Init(\"L-\");\n      DCLargePositive.Init(\"U+\");\n      DCLargeNegative.Init(\"U-\");      \n#else\n      DCZero.Init();\n      DCSmallPositive.Init();\n      DCSmallNegative.Init();\n      DCLargePositive.Init();\n      DCLargeNegative.Init();\n#endif\n      DCMagnitude.Init();\n      DCMagnitude.Init();\n      for(int i = 0;i < 63;i++) {\n#ifdef DEBUG_QMCODER\n        ACZero[i].Init(i);\n#else\n        ACZero[i].Init();\n#endif\n      }\n#ifdef DEBUG_QMCODER\n      ACMagnitudeLow.Init(false);\n      ACMagnitudeHigh.Init(true);\n#else\n      ACMagnitudeLow.Init();\n      ACMagnitudeHigh.Init();\n#endif\n#ifdef DEBUG_QMCODER\n      Uniform.Init(QMCoder::Uniform_State,\"uni \");\n#else\n      Uniform.Init(QMCoder::Uniform_State);\n#endif\n    }  \n    //\n    // Classify the DC difference into five categories, return it.\n    struct DCContextZeroSet &Classify(LONG diff,UBYTE l,UBYTE u);\n    //\n  } m_Context[4];\n  //\n  // \nprotected:\n  //\n  // The block control helper that maintains all the request/release\n  // logic and the interface to the user.\n  class BlockCtrl            *m_pBlockCtrl;\n  //\n  // Scan positions.\n  ULONG                       m_ulX[4];\n  //\n  // Scan parameters.\n  UBYTE                       m_ucScanStart;\n  UBYTE                       m_ucScanStop;\n  UBYTE                       m_ucLowBit; \n  //\n  // AC conditioners, one per component.\n  //\n  // Context numbers to use for the conditional.\n  UBYTE                       m_ucDCContext[4];\n  UBYTE                       m_ucACContext[4];\n  //\n  // Small DC threshold value ('L' in the standard)\n  UBYTE                       m_ucSmall[4];\n  //\n  // Large DC threshold value ('U' in the specs)\n  UBYTE                       m_ucLarge[4];\n  //\n  // Higher block index discrimination ('kx' in the specs)\n  UBYTE                       m_ucBlockEnd[4]; \n  //\n  // Will always be false as there is no reason to measure anything.\n  // This is only here to satisfy the expected interface of the\n  // residual scan.\n  bool                        m_bMeasure;\n  //\n  // Set if this is a differential scan.\n  bool                        m_bDifferential;\n  //\n  // Set if this is a residual scan.\n  bool                        m_bResidual;\n  //\n  // Set if this is a large range scan.\n  bool                        m_bLargeRange;\n  //\n  // Encode a single block\n  void EncodeBlock(const LONG *block,\n                   LONG &prevdc,LONG &prevdiff,\n                   UBYTE small,UBYTE large,UBYTE blockup,\n                   UBYTE dctable,UBYTE actable);\n  //\n  // Decode a single block.\n  void DecodeBlock(LONG *block,\n                   LONG &prevdc,LONG &prevdiff,\n                   UBYTE small,UBYTE large,UBYTE blockup,\n                   UBYTE dctable,UBYTE actable);\n  //\n#endif\n  //\n  // Flush the remaining bits out to the stream on writing.\n  virtual void Flush(bool final);\n  // \n  // Restart the parser at the next restart interval\n  virtual void Restart(void);\n  //\nprivate:\n  //\n  // Write the marker that indicates the frame type fitting to this scan.\n  virtual void WriteFrameType(class ByteStream *io);\n  //\n  //\npublic:\n  // Create an arithmetically coded sequential scan. The highbit is always\n  // ignored as this setting only exists for progressive refinement scans.\n  ACSequentialScan(class Frame *frame,class Scan *scan,UBYTE start,UBYTE stop,\n                   UBYTE lowbit,UBYTE highbit,\n                   bool differential = false,bool residual = false,bool largerange = false);\n  //\n  ~ACSequentialScan(void);\n  // \n  // Fill in the tables for decoding and decoding parameters in general.\n  virtual void StartParseScan(class ByteStream *io,class Checksum *chk,class BufferCtrl *ctrl);\n  //\n  // Write the default tables for encoding \n  virtual void StartWriteScan(class ByteStream *io,class Checksum *chk,class BufferCtrl *ctrl);\n  //\n  // Measure scan statistics. Not implemented here since it is not\n  // required. The AC coder is adaptive.\n  virtual void StartMeasureScan(class BufferCtrl *ctrl);\n  //\n  // Start making an optimization run to adjust the coefficients.\n  virtual void StartOptimizeScan(class BufferCtrl *ctrl);\n  //\n  // Start a MCU scan. Returns true if there are more rows. False otherwise.\n  virtual bool StartMCURow(void);\n  //\n  // Parse a single MCU in this scan. Return true if there are more\n  // MCUs in this row.\n  virtual bool ParseMCU(void);  \n  //\n  // Write a single MCU in this scan.\n  virtual bool WriteMCU(void);\n  //\n  // Make an R/D optimization for the given scan by potentially pushing\n  // coefficients into other bins. \n  virtual void OptimizeBlock(LONG bx,LONG by,UBYTE component,double critical,\n                             class DCT *dct,LONG quantized[64]); \n  //\n  // Make an R/D optimization of the DC scan. This includes all DC blocks in\n  // total, not just a single block. This is because the coefficients are not\n  // coded independently.\n  virtual void OptimizeDC(void);\n};\n///\n\n\n///\n#endif\n", "/*************************************************************************\n\n    This project implements a complete(!) JPEG (Recommendation ITU-T\n    T.81 | ISO/IEC 10918-1) codec, plus a library that can be used to\n    encode and decode JPEG streams. \n    It also implements ISO/IEC 18477 aka JPEG XT which is an extension\n    towards intermediate, high-dynamic-range lossy and lossless coding\n    of JPEG. In specific, it supports ISO/IEC 18477-3/-6/-7/-8 encoding.\n\n    Note that only Profiles C and D of ISO/IEC 18477-7 are supported\n    here. Check the JPEG XT reference software for a full implementation\n    of ISO/IEC 18477-7.\n\n    Copyright (C) 2012-2018 Thomas Richter, University of Stuttgart and\n    Accusoft. (C) 2019-2020 Thomas Richter, Fraunhofer IIS.\n\n    This program is available under two licenses, GPLv3 and the ITU\n    Software licence Annex A Option 2, RAND conditions.\n\n    For the full text of the GPU license option, see README.license.gpl.\n    For the full text of the ITU license option, see README.license.itu.\n    \n    You may freely select between these two options.\n\n    For the GPL option, please note the following:\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*************************************************************************/\n/*\n**\n** Represents the scan including the scan header.\n**\n** $Id: losslessscan.cpp,v 1.51 2022/05/23 05:56:51 thor Exp $\n**\n*/\n\n/// Includes\n#include \"codestream/losslessscan.hpp\"\n#include \"io/bytestream.hpp\"\n#include \"control/linebuffer.hpp\"\n#include \"control/linebitmaprequester.hpp\"\n#include \"control/lineadapter.hpp\"\n#include \"marker/frame.hpp\"\n#include \"marker/scan.hpp\"\n#include \"marker/component.hpp\"\n#include \"codestream/tables.hpp\"\n#include \"io/bitstream.hpp\"\n#include \"coding/huffmantemplate.hpp\"\n#include \"coding/huffmancoder.hpp\"\n#include \"coding/huffmandecoder.hpp\"\n#include \"coding/huffmanstatistics.hpp\"\n#include \"codestream/tables.hpp\"\n#include \"codestream/predictorbase.hpp\"\n#include \"tools/line.hpp\"\n///\n\n/// LosslessScan::LosslessScan\nLosslessScan::LosslessScan(class Frame *frame,class Scan *scan,UBYTE predictor,UBYTE lowbit,bool differential)\n  : PredictiveScan(frame,scan,predictor,lowbit,differential)\n{ \n#if ACCUSOFT_CODE\n  for(int i = 0;i < 4;i++) {\n    m_pDCDecoder[i]    = NULL;\n    m_pDCCoder[i]      = NULL;\n    m_pDCStatistics[i] = NULL;\n  }\n#endif\n}\n///\n\n/// LosslessScan::~LosslessScan\nLosslessScan::~LosslessScan(void)\n{\n}\n///\n\n/// LosslessScan::WriteFrameType\n// Write the marker that indicates the frame type fitting to this scan.\nvoid LosslessScan::WriteFrameType(class ByteStream *io)\n{\n#if ACCUSOFT_CODE\n  if (m_bDifferential) {\n    io->PutWord(0xffc7); // differential lossless sequential\n  } else {\n    io->PutWord(0xffc3); // lossless sequential\n  }\n#else\n  NOREF(io);\n#endif\n}\n///\n\n/// LosslessScan::StartParseScan\nvoid LosslessScan::StartParseScan(class ByteStream *io,class Checksum *chk,class BufferCtrl *ctrl)\n{\n#if ACCUSOFT_CODE\n  int i;\n\n  FindComponentDimensions();\n  \n  for(i = 0;i < m_ucCount;i++) {\n    m_pDCDecoder[i]       = m_pScan->DCHuffmanDecoderOf(i);\n  }\n  \n  assert(ctrl->isLineBased());\n  m_pLineCtrl = dynamic_cast<LineBuffer *>(ctrl);\n  m_pLineCtrl->ResetToStartOfScan(m_pScan);\n  m_Stream.OpenForRead(io,chk);\n#else\n  NOREF(io);\n  NOREF(chk);\n  NOREF(ctrl);\n  JPG_THROW(NOT_IMPLEMENTED,\"LosslessScan::StartParseScan\",\n            \"Lossless JPEG not available in your code release, please contact Accusoft for a full version\");\n#endif\n}\n///\n\n/// LosslessScan::StartWriteScan\nvoid LosslessScan::StartWriteScan(class ByteStream *io,class Checksum *chk,class BufferCtrl *ctrl)\n{\n#if ACCUSOFT_CODE\n  int i;\n\n  FindComponentDimensions();\n  \n  for(i = 0;i < m_ucCount;i++) {\n    m_pDCCoder[i]       = m_pScan->DCHuffmanCoderOf(i);\n    m_pDCStatistics[i]  = NULL;\n  }\n  \n  assert(ctrl->isLineBased());\n  m_pLineCtrl = dynamic_cast<LineBuffer *>(ctrl);\n  m_pLineCtrl->ResetToStartOfScan(m_pScan); \n\n  EntropyParser::StartWriteScan(io,chk,ctrl);\n  \n  m_pScan->WriteMarker(io);\n  m_Stream.OpenForWrite(io,chk); \n\n  m_bMeasure = false;\n#else\n  NOREF(io);\n  NOREF(chk);\n  NOREF(ctrl);\n  JPG_THROW(NOT_IMPLEMENTED,\"LosslessScan::StartWriteScan\",\n            \"Lossless JPEG not available in your code release, please contact Accusoft for a full version\");\n#endif\n}\n///\n\n/// LosslessScan::StartMeasureScan\nvoid LosslessScan::StartMeasureScan(class BufferCtrl *ctrl)\n{\n#if ACCUSOFT_CODE\n  int i;\n\n  FindComponentDimensions();\n  \n  for(i = 0;i < m_ucCount;i++) {\n    m_pDCCoder[i]       = NULL;\n    m_pDCStatistics[i]  = m_pScan->DCHuffmanStatisticsOf(i);\n  }\n \n  assert(ctrl->isLineBased());\n  m_pLineCtrl = dynamic_cast<LineBuffer *>(ctrl);\n  m_pLineCtrl->ResetToStartOfScan(m_pScan);\n  \n  m_Stream.OpenForWrite(NULL,NULL);\n  \n  m_bMeasure = true;\n#else\n  NOREF(ctrl);\n#endif\n}\n///\n\n/// LosslessScan::WriteMCU\n// Write a single MCU in this scan. Actually, this is not quite true,\n// as we write an entire group of eight lines of pixels, as a MCU is\n// here a group of pixels. But it is more practical this way.\nbool LosslessScan::WriteMCU(void)\n{\n#if ACCUSOFT_CODE\n  int i;\n  struct Line *top[4],*prev[4];\n  int lines      = 8; // total number of MCU lines processed.\n  \n  for(i = 0;i < m_ucCount;i++) {\n    class Component *comp = ComponentOf(i);\n    UBYTE idx       = comp->IndexOf();\n    top[i]          = m_pLineCtrl->CurrentLineOf(idx);\n    prev[i]         = m_pLineCtrl->PreviousLineOf(idx);\n    m_ulX[i]        = 0;\n    m_ulY[i]        = m_pLineCtrl->CurrentYOf(idx);\n  }\n  \n  // Loop over lines and columns\n  do {\n    do {\n      BeginWriteMCU(m_Stream.ByteStreamOf());    \n      //\n      if (m_bMeasure) {\n        MeasureMCU(prev,top);\n      } else {\n        WriteMCU(prev,top);\n      }\n    } while(AdvanceToTheRight());\n    //\n    // Advance to the next line.\n  } while(AdvanceToTheNextLine(prev,top) && --lines);\n#endif\n  return false;\n}\n///\n\n/// LosslessScan::WriteMCU\n// The actual MCU-writer, write a single group of pixels to the stream,\n// or measure their statistics.\nvoid LosslessScan::WriteMCU(struct Line **prev,struct Line **top)\n{\n#if ACCUSOFT_CODE\n  UBYTE i;\n  //\n  // Parse a single MCU, which is now a group of pixels.\n  for(i = 0;i < m_ucCount;i++) {\n    class HuffmanCoder *dc = m_pDCCoder[i];\n    struct Line *line = top[i];\n    struct Line *pline= prev[i];\n    class PredictorBase *mcupred = m_pPredict[i];\n    UBYTE ym = m_ucMCUHeight[i];\n    LONG *lp = line->m_pData + m_ulX[i];\n    LONG *pp = (pline)?(pline->m_pData + m_ulX[i]):(NULL);\n    //\n    // Write MCUwidth * MCUheight coefficients starting at the line top.\n    do {\n      class PredictorBase *pred = mcupred;\n      UBYTE xm = m_ucMCUWidth[i];\n      do {\n        // Decode now the difference between the predicted value and\n        // the real value.\n        LONG v = pred->EncodeSample(lp,pp);\n        //\n        if (v == 0) {\n          dc->Put(&m_Stream,0);\n        } else if (v == MIN_WORD) {\n          dc->Put(&m_Stream,16); // Do not append bits\n        } else {\n          UBYTE symbol = 0;\n          do {\n            symbol++;\n            if (v > -(1 << symbol) && v < (1 << symbol)) {\n              dc->Put(&m_Stream,symbol);\n              if (v >= 0) {\n                m_Stream.Put(symbol,v);\n              } else {\n                m_Stream.Put(symbol,v - 1);\n              }\n              break;\n            }\n          } while(true);\n        }\n        //\n        // One pixel done. Proceed to the next in the MCU. Note that\n        // the lines have been extended such that always a complete MCU is present.\n      } while(--xm && (lp++,pp++,pred = pred->MoveRight(),true));\n      //\n      // Go to the next line.\n    } while(--ym && (pp = line->m_pData + m_ulX[i],line = (line->m_pNext)?(line->m_pNext):(line),\n                     lp = line->m_pData + m_ulX[i],mcupred = mcupred->MoveDown(),true));\n  }\n#else\n  NOREF(prev);\n  NOREF(top);\n#endif\n}\n///\n\n/// LosslessScan::MeasureMCU\n// The actual MCU-writer, write a single group of pixels to the stream,\n// or measure their statistics. This here only measures the statistics\n// to design an optimal Huffman table\nvoid LosslessScan::MeasureMCU(struct Line **prev,struct Line **top)\n{\n#if ACCUSOFT_CODE\n  UBYTE i;\n  //\n  // Parse a single MCU, which is now a group of pixels.\n  for(i = 0;i < m_ucCount;i++) {\n    class HuffmanStatistics *dcstat = m_pDCStatistics[i];\n    struct Line *line = top[i];\n    struct Line *pline= prev[i];\n    class PredictorBase *mcupred = m_pPredict[i];\n    UBYTE ym = m_ucMCUHeight[i];\n    LONG *lp = line->m_pData + m_ulX[i];\n    LONG *pp = (pline)?(pline->m_pData + m_ulX[i]):(NULL);\n    //\n    //\n    // Write MCUwidth * MCUheight coefficients starting at the line top.\n    do {\n      class PredictorBase *pred = mcupred;\n      UBYTE xm = m_ucMCUWidth[i];\n      do {\n        // Decode now the difference between the predicted value and\n        // the real value.\n        LONG v = pred->EncodeSample(lp,pp);\n        //\n        if (v == 0) {\n          dcstat->Put(0);\n        } else if (v == -32768) {\n          dcstat->Put(16); // Do not append bits\n        } else {\n          UBYTE symbol = 0;\n          do {\n            symbol++;\n            if (v > -(1 << symbol) && v < (1 << symbol)) {\n              dcstat->Put(symbol);\n              break;\n            }\n          } while(true);\n        }\n        //\n        // One pixel done. Proceed to the next in the MCU. Note that\n        // the lines have been extended such that always a complete MCU is present.\n      } while(--xm && (lp++,pp++,pred = pred->MoveRight(),true));\n      //\n      // Go to the next line.\n    } while(--ym && (pp = line->m_pData + m_ulX[i],line = (line->m_pNext)?(line->m_pNext):(line),\n                     lp = line->m_pData + m_ulX[i],mcupred = mcupred->MoveDown(),true));\n  }\n#else\n  NOREF(prev);\n  NOREF(top);\n#endif\n}\n///\n\n/// LosslessScan::ParseMCU\n// This is actually the true MCU-parser, not the interface that reads\n// a full line.\nvoid LosslessScan::ParseMCU(struct Line **prev,struct Line **top)\n{ \n#if ACCUSOFT_CODE\n  UBYTE i;\n  //\n  // Parse a single MCU, which is now a group of pixels.\n  for(i = 0;i < m_ucCount;i++) {\n    class HuffmanDecoder *dc = m_pDCDecoder[i];\n    struct Line *line = top[i];\n    struct Line *pline= prev[i];\n    UBYTE ym = m_ucMCUHeight[i];\n    class PredictorBase *mcupred = m_pPredict[i];\n    LONG *lp = line->m_pData + m_ulX[i];\n    LONG *pp = (pline)?(pline->m_pData + m_ulX[i]):(NULL);\n    //\n    // Parse MCUwidth * MCUheight coefficients starting at the line top.\n    do {\n      class PredictorBase *pred = mcupred;\n      UBYTE xm = m_ucMCUWidth[i];\n      do {\n        LONG v;\n        UBYTE symbol = dc->Get(&m_Stream);\n        \n        if (symbol == 0) {\n          v = 0;\n        } else if (symbol == 16) {\n          v = -32768;\n        } else if (symbol > 16) {\n          JPG_THROW(MALFORMED_STREAM,\"LosslessScan::ParseMCU\",\n                    \"received an out-of-bounds symbol in a lossless JPEG scan\");\n        } else {\n          LONG thre = 1L << (symbol - 1);\n          LONG diff = m_Stream.Get(symbol); // get the number of bits \n          if (diff < thre) {\n            diff += (-1L << symbol) + 1;\n          }\n          v = diff;\n        }\n        //\n        // Set the current pixel, do the inverse pointwise transformation.\n        lp[0] = pred->DecodeSample(v,lp,pp);\n        //\n        // One pixel done. Proceed to the next in the MCU. Note that\n        // the lines have been extended such that always a complete MCU is present.\n      } while(--xm && (lp++,pp++,pred = pred->MoveRight(),true));\n      //\n      // Go to the next line.\n    } while(--ym && (pp = line->m_pData + m_ulX[i],line = (line->m_pNext)?(line->m_pNext):(line),\n                     lp = line->m_pData + m_ulX[i],mcupred = mcupred->MoveDown(),true));\n  }\n#else\n  NOREF(prev);\n  NOREF(top);\n#endif\n}\n///\n\n/// LosslessScan::ParseMCU\n// Parse a single MCU in this scan. Actually, this is not quite true,\n// as we write an entire group of eight lines of pixels, as a MCU is\n// here a group of pixels. But it is more practical this way.\nbool LosslessScan::ParseMCU(void)\n{\n#if ACCUSOFT_CODE\n  int i;\n  struct Line *top[4],*prev[4];\n  int lines      = 8; // total number of MCU lines processed.\n \n  for(i = 0;i < m_ucCount;i++) {\n    class Component *comp = ComponentOf(i);\n    UBYTE idx       = comp->IndexOf();\n    top[i]          = m_pLineCtrl->CurrentLineOf(idx);\n    prev[i]         = m_pLineCtrl->PreviousLineOf(idx);\n    m_ulX[i]        = 0;\n    m_ulY[i]        = m_pLineCtrl->CurrentYOf(idx);\n  }\n\n  // Loop over lines and columns\n  do {\n    bool startofline = true;\n    do {\n      if (BeginReadMCU(m_Stream.ByteStreamOf())) {\n        ParseMCU(prev,top);\n      } else {\n        // Only if this is not due to a DNL marker that has been detected.\n        if (m_ulPixelHeight != 0 && !hasFoundDNL()) {\n          ClearMCU(top);\n        } else if (!startofline) {\n          // The problem is here that the DNL marker might have been detected, even though decoding\n          // is not yet done completely. This may be because there are still just enough bits in the\n          // bitream present to run a single decode. Big Outch! Just continue decoding in this case.\n          ParseMCU(prev,top);\n        } else break;\n      }\n      startofline = false;\n    } while(AdvanceToTheRight());\n    //\n    // Advance to the next line.\n  } while(AdvanceToTheNextLine(prev,top) && --lines);\n#endif  \n  return false; // no further blocks here.\n}\n///\n\n/// LosslessScan::StartMCURow\n// Start a MCU scan. Returns true if there are more rows.\nbool LosslessScan::StartMCURow(void)\n{\n#if ACCUSOFT_CODE\n  return m_pLineCtrl->StartMCUQuantizerRow(m_pScan);\n#else\n  return false;\n#endif\n}\n///\n\n/// LosslessScan::Flush\n// Flush the remaining bits out to the stream on writing.\nvoid LosslessScan::Flush(bool)\n{  \n#if ACCUSOFT_CODE\n  if (!m_bMeasure)\n    m_Stream.Flush();\n\n  PredictiveScan::FlushOnMarker();\n#endif\n}\n///\n\n/// LosslessScan::Restart\n// Restart the parser at the next restart interval\nvoid LosslessScan::Restart(void)\n{ \n#if ACCUSOFT_CODE\n  m_Stream.OpenForRead(m_Stream.ByteStreamOf(),m_Stream.ChecksumOf());\n\n  PredictiveScan::RestartOnMarker();\n#endif\n}\n///\n", "/*************************************************************************\n\n    This project implements a complete(!) JPEG (Recommendation ITU-T\n    T.81 | ISO/IEC 10918-1) codec, plus a library that can be used to\n    encode and decode JPEG streams. \n    It also implements ISO/IEC 18477 aka JPEG XT which is an extension\n    towards intermediate, high-dynamic-range lossy and lossless coding\n    of JPEG. In specific, it supports ISO/IEC 18477-3/-6/-7/-8 encoding.\n\n    Note that only Profiles C and D of ISO/IEC 18477-7 are supported\n    here. Check the JPEG XT reference software for a full implementation\n    of ISO/IEC 18477-7.\n\n    Copyright (C) 2012-2018 Thomas Richter, University of Stuttgart and\n    Accusoft. (C) 2019-2020 Thomas Richter, Fraunhofer IIS.\n\n    This program is available under two licenses, GPLv3 and the ITU\n    Software licence Annex A Option 2, RAND conditions.\n\n    For the full text of the GPU license option, see README.license.gpl.\n    For the full text of the ITU license option, see README.license.itu.\n    \n    You may freely select between these two options.\n\n    For the GPL option, please note the following:\n\n    This program is free software: you can redistribute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\n\n*************************************************************************/\n/*\n * Definition of how to request a given rectangle for display,\n * for load or for checking for a necessary update.\n * \n * $Id: rectanglerequest.hpp,v 1.13 2022/05/23 05:56:51 thor Exp $\n *\n */\n\n#ifndef CODESTREAM_RECTANGLEREQUEST_HPP\n#define CODESTREAM_RECTANGLEREQUEST_HPP\n\n/// Includes\n#include \"interface/types.hpp\"\n#include \"tools/rectangle.hpp\"\n#include \"tools/environment.hpp\"\n#include \"std/string.hpp\"\n///\n\n/// Forward references\nstruct JPG_TagItem;\nclass Image;\n///\n\n/// Design\n/** Design\n******************************************************************\n** struct RectangleRequest                                      **\n** Super Class: none                                            **\n** Sub Classes: none                                            **\n** Friends:                                                     **\n******************************************************************\n\nDefines a rectangular image domain that is requested from the\nuser to be loaded or to be previewed. Hence, the purpose of\nthis helper class is to pass parameters about the user request\ninformation down the jpeg stream.\n\nThis structure is constructed by the decoder, and sent down\nto the band class which will generate the requests for each\ncode block. On its way, more and more components gets parsed\nand get interpreted.\n* */\n///\n\n/// RectangleRequest\n// This structure defines the sub-image requested by DisplayRectangle()\n// and similar functions. It is consistently used to define an image\n// area and as such forwarded to the canvas and all its sub-structures\nstruct RectangleRequest : public JObject, private Explicit { \n  //\n  struct RectangleRequest *rr_pNext;\n  RectAngle<LONG>          rr_Request;\n  UWORD                    rr_usFirstComponent; // starting component\n  UWORD                    rr_usLastComponent;  // inclusive end component\n  BYTE                     rr_cPriority;        // order of rectangles\n  bool                     rr_bIncludeAlpha;    // include the alpha channel in the request\n  bool                     rr_bUpsampling;      // disable or enable upsampling. Default is to upsample\n  bool                     rr_bColorTrafo;      // disable or enable the output color transformation. Default is to run it.\n  //\n  RectangleRequest(void)\n    : rr_pNext(NULL)\n  { }\n  //\n  // Copy constructor.\n  RectangleRequest(const struct RectangleRequest &req)\n    : Explicit()\n  {\n    // Not linked in any way if this is new.\n    rr_pNext            = NULL;\n    rr_Request          = req.rr_Request;\n    rr_usFirstComponent = req.rr_usFirstComponent;\n    rr_usLastComponent  = req.rr_usLastComponent;\n    rr_cPriority        = req.rr_cPriority;\n    rr_bIncludeAlpha    = req.rr_bIncludeAlpha;\n    rr_bUpsampling      = req.rr_bUpsampling;\n    rr_bColorTrafo      = req.rr_bColorTrafo;\n  }\n  //\n  // Assignment operator.\n  RectangleRequest &operator=(const struct RectangleRequest &req)\n  { \n   // Not linked in any way if this is new.\n    rr_pNext            = NULL;\n    rr_Request          = req.rr_Request;\n    rr_usFirstComponent = req.rr_usFirstComponent;\n    rr_usLastComponent  = req.rr_usLastComponent;\n    rr_cPriority        = req.rr_cPriority;\n    rr_bIncludeAlpha    = req.rr_bIncludeAlpha;\n    rr_bUpsampling      = req.rr_bUpsampling;\n    rr_bColorTrafo      = req.rr_bColorTrafo;\n    //\n    return *this;\n  }\n  //\n  //\n  // Queues the request in the rectangle request structure.\n  void ParseTags(const struct JPG_TagItem *tags,const class Image *image);\n  //\n  // Check whether this request contains the argument as sub-request, i.e.\n  // whether requesting this request first and then the sub-request as\n  // argument does nothing.\n  bool Contains(const struct RectangleRequest *sub) const;\n  // \n  // Check whether this rectangle intersects with another\n  // rectangle. Returns true if so.\n  bool Intersects(const RectAngle<LONG> &cmp) const\n  {\n    return rr_Request.Intersects(cmp);\n  }\n  //\n  // Returns the next rectangle in a singly linked list\n  struct RectangleRequest *NextOf(void) const \n  {\n    return rr_pNext;\n  }\n  //\n  // Enqueue a rectangle into a list according to its priority.\n  void Enqueue(struct RectangleRequest *&first);\n};\n///\n\n///\n#endif\n"], "filenames": ["README", "README.history", "codestream/aclosslessscan.cpp", "codestream/aclosslessscan.hpp", "codestream/acsequentialscan.cpp", "codestream/acsequentialscan.hpp", "codestream/losslessscan.cpp", "codestream/rectanglerequest.hpp"], "buggy_code_start_loc": [454, 557, 45, 46, 45, 46, 45, 45], "buggy_code_end_loc": [454, 557, 363, 120, 658, 195, 379, 121], "fixing_code_start_loc": [455, 558, 45, 46, 45, 46, 45, 45], "fixing_code_end_loc": [466, 569, 365, 124, 656, 202, 383, 131], "type": "CWE-119", "message": "In libjpeg before 1.64, BitStream<false>::Get in bitstream.hpp has an assertion failure that may cause denial of service. This is related to out-of-bounds array access during arithmetically coded lossless scan or arithmetically coded sequential scan.", "other": {"cve": {"id": "CVE-2022-31620", "sourceIdentifier": "cve@mitre.org", "published": "2022-05-25T21:15:08.530", "lastModified": "2022-07-19T17:15:16.803", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In libjpeg before 1.64, BitStream<false>::Get in bitstream.hpp has an assertion failure that may cause denial of service. This is related to out-of-bounds array access during arithmetically coded lossless scan or arithmetically coded sequential scan."}, {"lang": "es", "value": "En libjpeg versiones anteriores a 1.64, La funci\u00f3n BitStream(false)::Get en el archivo bitstream.hpp presenta un fallo de aserci\u00f3n que puede causar una denegaci\u00f3n de servicio. Esto est\u00e1 relacionado con el acceso a matrices fuera de l\u00edmites durante la exploraci\u00f3n sin p\u00e9rdida codificada aritm\u00e9ticamente o la exploraci\u00f3n secuencial codificada aritm\u00e9ticamente"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-119"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libjpeg_project:libjpeg:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.64", "matchCriteriaId": "4C0D08AF-7C1C-4EFD-8252-E8BE092C1827"}]}]}], "references": [{"url": "https://github.com/thorfdbg/libjpeg/commit/ef4a29a62ab48b8dc235f4af52cfd6319eda9a6a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/thorfdbg/libjpeg/issues/70", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/thorfdbg/libjpeg/commit/ef4a29a62ab48b8dc235f4af52cfd6319eda9a6a"}}