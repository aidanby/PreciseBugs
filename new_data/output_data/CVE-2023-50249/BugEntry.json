{"buggy_code": ["import {\n  captureException,\n  configureScope,\n  continueTrace,\n  getCurrentHub,\n  runWithAsyncContext,\n  startSpan,\n} from '@sentry/node';\nimport type { Hub, Span } from '@sentry/types';\nimport {\n  addNonEnumerableProperty,\n  objectify,\n  stripUrlQueryAndFragment,\n  tracingContextFromHeaders,\n} from '@sentry/utils';\nimport type { APIContext, MiddlewareResponseHandler } from 'astro';\n\nimport { getTracingMetaTags } from './meta';\n\ntype MiddlewareOptions = {\n  /**\n   * If true, the client IP will be attached to the event by calling `setUser`.\n   *\n   * Important: Only enable this option if your Astro app is configured for (hybrid) SSR\n   * via the `output: 'server' | 'hybrid'` option in your `astro.config.mjs` file.\n   * Otherwise, Astro will throw an error when starting the server.\n   *\n   * Only set this to `true` if you're fine with collecting potentially personally identifiable information (PII).\n   *\n   * @default false (recommended)\n   */\n  trackClientIp?: boolean;\n\n  /**\n   * If true, the headers from the request will be attached to the event by calling `setExtra`.\n   *\n   * Only set this to `true` if you're fine with collecting potentially personally identifiable information (PII).\n   *\n   * @default false (recommended)\n   */\n  trackHeaders?: boolean;\n};\n\nfunction sendErrorToSentry(e: unknown): unknown {\n  // In case we have a primitive, wrap it in the equivalent wrapper class (string -> String, etc.) so that we can\n  // store a seen flag on it.\n  const objectifiedErr = objectify(e);\n\n  captureException(objectifiedErr, {\n    mechanism: {\n      type: 'astro',\n      handled: false,\n      data: {\n        function: 'astroMiddleware',\n      },\n    },\n  });\n\n  return objectifiedErr;\n}\n\ntype AstroLocalsWithSentry = Record<string, unknown> & {\n  __sentry_wrapped__?: boolean;\n};\n\nexport const handleRequest: (options?: MiddlewareOptions) => MiddlewareResponseHandler = options => {\n  const handlerOptions = { trackClientIp: false, trackHeaders: false, ...options };\n\n  return async (ctx, next) => {\n    // if there is an active span, we know that this handle call is nested and hence\n    // we don't create a new domain for it. If we created one, nested server calls would\n    // create new transactions instead of adding a child span to the currently active span.\n    if (getCurrentHub().getScope().getSpan()) {\n      return instrumentRequest(ctx, next, handlerOptions);\n    }\n    return runWithAsyncContext(() => {\n      return instrumentRequest(ctx, next, handlerOptions);\n    });\n  };\n};\n\nasync function instrumentRequest(\n  ctx: Parameters<MiddlewareResponseHandler>[0],\n  next: Parameters<MiddlewareResponseHandler>[1],\n  options: MiddlewareOptions,\n): Promise<Response> {\n  // Make sure we don't accidentally double wrap (e.g. user added middleware and integration auto added it)\n  const locals = ctx.locals as AstroLocalsWithSentry;\n  if (locals && locals.__sentry_wrapped__) {\n    return next();\n  }\n  addNonEnumerableProperty(locals, '__sentry_wrapped__', true);\n\n  const { method, headers } = ctx.request;\n\n  const traceCtx = continueTrace({\n    sentryTrace: headers.get('sentry-trace') || undefined,\n    baggage: headers.get('baggage'),\n  });\n\n  const allHeaders: Record<string, string> = {};\n\n  if (options.trackHeaders) {\n    headers.forEach((value, key) => {\n      allHeaders[key] = value;\n    });\n  }\n\n  if (options.trackClientIp) {\n    configureScope(scope => {\n      scope.setUser({ ip_address: ctx.clientAddress });\n    });\n  }\n\n  try {\n    // storing res in a variable instead of directly returning is necessary to\n    // invoke the catch block if next() throws\n    const res = await startSpan(\n      {\n        ...traceCtx,\n        name: `${method} ${interpolateRouteFromUrlAndParams(ctx.url.pathname, ctx.params)}`,\n        op: 'http.server',\n        origin: 'auto.http.astro',\n        status: 'ok',\n        metadata: {\n          ...traceCtx?.metadata,\n          source: 'route',\n        },\n        data: {\n          method,\n          url: stripUrlQueryAndFragment(ctx.url.href),\n          ...(ctx.url.search && { 'http.query': ctx.url.search }),\n          ...(ctx.url.hash && { 'http.fragment': ctx.url.hash }),\n          ...(options.trackHeaders && { headers: allHeaders }),\n        },\n      },\n      async span => {\n        const originalResponse = await next();\n\n        if (span && originalResponse.status) {\n          span.setHttpStatus(originalResponse.status);\n        }\n\n        const hub = getCurrentHub();\n        const client = hub.getClient();\n        const contentType = originalResponse.headers.get('content-type');\n\n        const isPageloadRequest = contentType && contentType.startsWith('text/html');\n        if (!isPageloadRequest || !client) {\n          return originalResponse;\n        }\n\n        // Type case necessary b/c the body's ReadableStream type doesn't include\n        // the async iterator that is actually available in Node\n        // We later on use the async iterator to read the body chunks\n        // see https://github.com/microsoft/TypeScript/issues/39051\n        const originalBody = originalResponse.body as NodeJS.ReadableStream | null;\n        if (!originalBody) {\n          return originalResponse;\n        }\n\n        const decoder = new TextDecoder();\n\n        const newResponseStream = new ReadableStream({\n          start: async controller => {\n            for await (const chunk of originalBody) {\n              const html = typeof chunk === 'string' ? chunk : decoder.decode(chunk);\n              const modifiedHtml = addMetaTagToHead(html, hub, span);\n              controller.enqueue(new TextEncoder().encode(modifiedHtml));\n            }\n            controller.close();\n          },\n        });\n\n        return new Response(newResponseStream, originalResponse);\n      },\n    );\n    return res;\n  } catch (e) {\n    sendErrorToSentry(e);\n    throw e;\n  }\n  // TODO: flush if serverless (first extract function)\n}\n\n/**\n * This function optimistically assumes that the HTML coming in chunks will not be split\n * within the <head> tag. If this still happens, we simply won't replace anything.\n */\nfunction addMetaTagToHead(htmlChunk: string, hub: Hub, span?: Span): string {\n  if (typeof htmlChunk !== 'string') {\n    return htmlChunk;\n  }\n\n  const { sentryTrace, baggage } = getTracingMetaTags(span, hub);\n  const content = `<head>\\n${sentryTrace}\\n${baggage}\\n`;\n  return htmlChunk.replace('<head>', content);\n}\n\n/**\n * Interpolates the route from the URL and the passed params.\n * Best we can do to get a route name instead of a raw URL.\n *\n * exported for testing\n */\nexport function interpolateRouteFromUrlAndParams(rawUrl: string, params: APIContext['params']): string {\n  return Object.entries(params).reduce((interpolateRoute, value) => {\n    const [paramId, paramValue] = value;\n    return interpolateRoute.replace(new RegExp(`(/|-)${paramValue}(/|-|$)`), `$1[${paramId}]$2`);\n  }, rawUrl);\n}\n", "import * as SentryNode from '@sentry/node';\nimport { vi } from 'vitest';\n\nimport { handleRequest, interpolateRouteFromUrlAndParams } from '../../src/server/middleware';\n\nvi.mock('../../src/server/meta', () => ({\n  getTracingMetaTags: () => ({\n    sentryTrace: '<meta name=\"sentry-trace\" content=\"123\">',\n    baggage: '<meta name=\"baggage\" content=\"abc\">',\n  }),\n}));\n\ndescribe('sentryMiddleware', () => {\n  const startSpanSpy = vi.spyOn(SentryNode, 'startSpan');\n\n  const getSpanMock = vi.fn(() => {});\n  // @ts-expect-error only returning a partial hub here\n  vi.spyOn(SentryNode, 'getCurrentHub').mockImplementation(() => {\n    return {\n      getScope: () => ({\n        getSpan: getSpanMock,\n      }),\n      getClient: () => ({}),\n    };\n  });\n\n  const nextResult = Promise.resolve(new Response(null, { status: 200, headers: new Headers() }));\n\n  afterEach(() => {\n    vi.clearAllMocks();\n  });\n\n  it('creates a span for an incoming request', async () => {\n    const middleware = handleRequest();\n    const ctx = {\n      request: {\n        method: 'GET',\n        url: '/users/123/details',\n        headers: new Headers(),\n      },\n      url: new URL('https://myDomain.io/users/123/details'),\n      params: {\n        id: '123',\n      },\n    };\n    const next = vi.fn(() => nextResult);\n\n    // @ts-expect-error, a partial ctx object is fine here\n    const resultFromNext = middleware(ctx, next);\n\n    expect(startSpanSpy).toHaveBeenCalledWith(\n      {\n        data: {\n          method: 'GET',\n          url: 'https://mydomain.io/users/123/details',\n        },\n        metadata: {\n          source: 'route',\n        },\n        name: 'GET /users/[id]/details',\n        op: 'http.server',\n        origin: 'auto.http.astro',\n        status: 'ok',\n      },\n      expect.any(Function), // the `next` function\n    );\n\n    expect(next).toHaveBeenCalled();\n    expect(resultFromNext).toStrictEqual(nextResult);\n  });\n\n  it('throws and sends an error to sentry if `next()` throws', async () => {\n    const captureExceptionSpy = vi.spyOn(SentryNode, 'captureException');\n\n    const middleware = handleRequest();\n    const ctx = {\n      request: {\n        method: 'GET',\n        url: '/users',\n        headers: new Headers(),\n      },\n      url: new URL('https://myDomain.io/users/'),\n      params: {},\n    };\n\n    const error = new Error('Something went wrong');\n\n    const next = vi.fn(() => {\n      throw error;\n    });\n\n    // @ts-expect-error, a partial ctx object is fine here\n    await expect(async () => middleware(ctx, next)).rejects.toThrowError();\n\n    expect(captureExceptionSpy).toHaveBeenCalledWith(error, {\n      mechanism: { handled: false, type: 'astro', data: { function: 'astroMiddleware' } },\n    });\n  });\n\n  it('attaches tracing headers', async () => {\n    const middleware = handleRequest();\n    const ctx = {\n      request: {\n        method: 'GET',\n        url: '/users',\n        headers: new Headers({\n          'sentry-trace': '12345678901234567890123456789012-1234567890123456-1',\n          baggage: 'sentry-release=1.0.0',\n        }),\n      },\n      params: {},\n      url: new URL('https://myDomain.io/users/'),\n    };\n    const next = vi.fn(() => nextResult);\n\n    // @ts-expect-error, a partial ctx object is fine here\n    await middleware(ctx, next);\n\n    expect(startSpanSpy).toHaveBeenCalledWith(\n      expect.objectContaining({\n        metadata: {\n          source: 'route',\n          dynamicSamplingContext: {\n            release: '1.0.0',\n          },\n        },\n        parentSampled: true,\n        parentSpanId: '1234567890123456',\n        traceId: '12345678901234567890123456789012',\n      }),\n      expect.any(Function), // the `next` function\n    );\n  });\n\n  it('attaches client IP and request headers if options are set', async () => {\n    const scope = { setUser: vi.fn(), setPropagationContext: vi.fn() };\n    // @ts-expect-error, only passing a partial Scope object\n    const configureScopeSpy = vi.spyOn(SentryNode, 'configureScope').mockImplementation(cb => cb(scope));\n\n    const middleware = handleRequest({ trackClientIp: true, trackHeaders: true });\n    const ctx = {\n      request: {\n        method: 'GET',\n        url: '/users',\n        headers: new Headers({\n          'some-header': 'some-value',\n        }),\n      },\n      clientAddress: '192.168.0.1',\n      params: {},\n      url: new URL('https://myDomain.io/users/'),\n    };\n    const next = vi.fn(() => nextResult);\n\n    // @ts-expect-error, a partial ctx object is fine here\n    await middleware(ctx, next);\n\n    expect(configureScopeSpy).toHaveBeenCalledTimes(1);\n    expect(scope.setUser).toHaveBeenCalledWith({ ip_address: '192.168.0.1' });\n\n    expect(startSpanSpy).toHaveBeenCalledWith(\n      expect.objectContaining({\n        data: expect.objectContaining({\n          headers: {\n            'some-header': 'some-value',\n          },\n        }),\n      }),\n      expect.any(Function), // the `next` function\n    );\n  });\n\n  it('injects tracing <meta> tags into the HTML of a pageload response', async () => {\n    const middleware = handleRequest();\n\n    const ctx = {\n      request: {\n        method: 'GET',\n        url: '/users',\n        headers: new Headers(),\n      },\n      params: {},\n      url: new URL('https://myDomain.io/users/'),\n    };\n    const next = vi.fn(() =>\n      Promise.resolve(\n        new Response('<head><meta name=\"something\" content=\"\"/></head>', {\n          headers: new Headers({ 'content-type': 'text/html' }),\n        }),\n      ),\n    );\n\n    // @ts-expect-error, a partial ctx object is fine here\n    const resultFromNext = await middleware(ctx, next);\n\n    expect(resultFromNext?.headers.get('content-type')).toEqual('text/html');\n\n    const html = await resultFromNext?.text();\n\n    expect(html).toContain('<meta name=\"sentry-trace\" content=\"');\n    expect(html).toContain('<meta name=\"baggage\" content=\"');\n  });\n\n  it(\"no-ops if the response isn't HTML\", async () => {\n    const middleware = handleRequest();\n\n    const ctx = {\n      request: {\n        method: 'GET',\n        url: '/users',\n        headers: new Headers(),\n      },\n      params: {},\n      url: new URL('https://myDomain.io/users/'),\n    };\n\n    const originalResponse = new Response('{\"foo\": \"bar\"}', {\n      headers: new Headers({ 'content-type': 'application/json' }),\n    });\n    const next = vi.fn(() => Promise.resolve(originalResponse));\n\n    // @ts-expect-error, a partial ctx object is fine here\n    const resultFromNext = await middleware(ctx, next);\n\n    expect(resultFromNext).toBe(originalResponse);\n  });\n\n  it(\"no-ops if there's no <head> tag in the response\", async () => {\n    const middleware = handleRequest();\n\n    const ctx = {\n      request: {\n        method: 'GET',\n        url: '/users',\n        headers: new Headers(),\n      },\n      params: {},\n      url: new URL('https://myDomain.io/users/'),\n    };\n\n    const originalHtml = '<p>no head</p>';\n    const originalResponse = new Response(originalHtml, {\n      headers: new Headers({ 'content-type': 'text/html' }),\n    });\n    const next = vi.fn(() => Promise.resolve(originalResponse));\n\n    // @ts-expect-error, a partial ctx object is fine here\n    const resultFromNext = await middleware(ctx, next);\n\n    expect(resultFromNext?.headers.get('content-type')).toEqual('text/html');\n\n    const html = await resultFromNext?.text();\n\n    expect(html).toBe(originalHtml);\n  });\n\n  describe('async context isolation', () => {\n    const runWithAsyncContextSpy = vi.spyOn(SentryNode, 'runWithAsyncContext');\n    afterEach(() => {\n      vi.clearAllMocks();\n      runWithAsyncContextSpy.mockRestore();\n    });\n\n    it('starts a new async context if no span is active', async () => {\n      getSpanMock.mockReturnValueOnce(undefined);\n      const handler = handleRequest();\n      const ctx = {};\n      const next = vi.fn();\n\n      try {\n        // @ts-expect-error, a partial ctx object is fine here\n        await handler(ctx, next);\n      } catch {\n        // this is fine, it's not required to pass in this test\n      }\n\n      expect(runWithAsyncContextSpy).toHaveBeenCalledTimes(1);\n    });\n\n    it(\"doesn't start a new async context if a span is active\", async () => {\n      // @ts-expect-error, a empty span is fine here\n      getSpanMock.mockReturnValueOnce({});\n\n      const handler = handleRequest();\n      const ctx = {};\n      const next = vi.fn();\n\n      try {\n        // @ts-expect-error, a partial ctx object is fine here\n        await handler(ctx, next);\n      } catch {\n        // this is fine, it's not required to pass in this test\n      }\n\n      expect(runWithAsyncContextSpy).not.toHaveBeenCalled();\n    });\n  });\n});\n\ndescribe('interpolateRouteFromUrlAndParams', () => {\n  it.each([\n    ['/foo/bar', {}, '/foo/bar'],\n    ['/users/123', { id: '123' }, '/users/[id]'],\n    ['/users/123', { id: '123', foo: 'bar' }, '/users/[id]'],\n    ['/lang/en-US', { lang: 'en', region: 'US' }, '/lang/[lang]-[region]'],\n    ['/lang/en-US/posts', { lang: 'en', region: 'US' }, '/lang/[lang]-[region]/posts'],\n  ])('interpolates route from URL and params %s', (rawUrl, params, expectedRoute) => {\n    expect(interpolateRouteFromUrlAndParams(rawUrl, params)).toEqual(expectedRoute);\n  });\n\n  it('handles params across multiple URL segments in catchall routes', () => {\n    // Ideally, Astro would let us know that this is a catchall route so we can make the param [...catchall] but it doesn't\n    expect(\n      interpolateRouteFromUrlAndParams('/someroute/catchall-123/params/foo/bar', {\n        catchall: 'catchall-123/params/foo',\n        params: 'foo',\n      }),\n    ).toEqual('/someroute/[catchall]/bar');\n  });\n\n  it(\"doesn't replace partially matching route segments\", () => {\n    const rawUrl = '/usernames/username';\n    const params = { name: 'username' };\n    const expectedRoute = '/usernames/[name]';\n    expect(interpolateRouteFromUrlAndParams(rawUrl, params)).toEqual(expectedRoute);\n  });\n});\n"], "fixing_code": ["import {\n  captureException,\n  configureScope,\n  continueTrace,\n  getCurrentHub,\n  runWithAsyncContext,\n  startSpan,\n} from '@sentry/node';\nimport type { Hub, Span } from '@sentry/types';\nimport { addNonEnumerableProperty, objectify, stripUrlQueryAndFragment } from '@sentry/utils';\nimport type { APIContext, MiddlewareResponseHandler } from 'astro';\n\nimport { getTracingMetaTags } from './meta';\n\ntype MiddlewareOptions = {\n  /**\n   * If true, the client IP will be attached to the event by calling `setUser`.\n   *\n   * Important: Only enable this option if your Astro app is configured for (hybrid) SSR\n   * via the `output: 'server' | 'hybrid'` option in your `astro.config.mjs` file.\n   * Otherwise, Astro will throw an error when starting the server.\n   *\n   * Only set this to `true` if you're fine with collecting potentially personally identifiable information (PII).\n   *\n   * @default false (recommended)\n   */\n  trackClientIp?: boolean;\n\n  /**\n   * If true, the headers from the request will be attached to the event by calling `setExtra`.\n   *\n   * Only set this to `true` if you're fine with collecting potentially personally identifiable information (PII).\n   *\n   * @default false (recommended)\n   */\n  trackHeaders?: boolean;\n};\n\nfunction sendErrorToSentry(e: unknown): unknown {\n  // In case we have a primitive, wrap it in the equivalent wrapper class (string -> String, etc.) so that we can\n  // store a seen flag on it.\n  const objectifiedErr = objectify(e);\n\n  captureException(objectifiedErr, {\n    mechanism: {\n      type: 'astro',\n      handled: false,\n      data: {\n        function: 'astroMiddleware',\n      },\n    },\n  });\n\n  return objectifiedErr;\n}\n\ntype AstroLocalsWithSentry = Record<string, unknown> & {\n  __sentry_wrapped__?: boolean;\n};\n\nexport const handleRequest: (options?: MiddlewareOptions) => MiddlewareResponseHandler = options => {\n  const handlerOptions = {\n    trackClientIp: false,\n    trackHeaders: false,\n    ...options,\n  };\n\n  return async (ctx, next) => {\n    // if there is an active span, we know that this handle call is nested and hence\n    // we don't create a new domain for it. If we created one, nested server calls would\n    // create new transactions instead of adding a child span to the currently active span.\n    if (getCurrentHub().getScope().getSpan()) {\n      return instrumentRequest(ctx, next, handlerOptions);\n    }\n    return runWithAsyncContext(() => {\n      return instrumentRequest(ctx, next, handlerOptions);\n    });\n  };\n};\n\nasync function instrumentRequest(\n  ctx: Parameters<MiddlewareResponseHandler>[0],\n  next: Parameters<MiddlewareResponseHandler>[1],\n  options: MiddlewareOptions,\n): Promise<Response> {\n  // Make sure we don't accidentally double wrap (e.g. user added middleware and integration auto added it)\n  const locals = ctx.locals as AstroLocalsWithSentry;\n  if (locals && locals.__sentry_wrapped__) {\n    return next();\n  }\n  addNonEnumerableProperty(locals, '__sentry_wrapped__', true);\n\n  const { method, headers } = ctx.request;\n\n  const traceCtx = continueTrace({\n    sentryTrace: headers.get('sentry-trace') || undefined,\n    baggage: headers.get('baggage'),\n  });\n\n  const allHeaders: Record<string, string> = {};\n\n  if (options.trackHeaders) {\n    headers.forEach((value, key) => {\n      allHeaders[key] = value;\n    });\n  }\n\n  if (options.trackClientIp) {\n    configureScope(scope => {\n      scope.setUser({ ip_address: ctx.clientAddress });\n    });\n  }\n\n  try {\n    const interpolatedRoute = interpolateRouteFromUrlAndParams(ctx.url.pathname, ctx.params);\n    // storing res in a variable instead of directly returning is necessary to\n    // invoke the catch block if next() throws\n    const res = await startSpan(\n      {\n        ...traceCtx,\n        name: `${method} ${interpolatedRoute || ctx.url.pathname}`,\n        op: 'http.server',\n        origin: 'auto.http.astro',\n        status: 'ok',\n        metadata: {\n          ...traceCtx?.metadata,\n          source: interpolatedRoute ? 'route' : 'url',\n        },\n        data: {\n          method,\n          url: stripUrlQueryAndFragment(ctx.url.href),\n          ...(ctx.url.search && { 'http.query': ctx.url.search }),\n          ...(ctx.url.hash && { 'http.fragment': ctx.url.hash }),\n          ...(options.trackHeaders && { headers: allHeaders }),\n        },\n      },\n      async span => {\n        const originalResponse = await next();\n\n        if (span && originalResponse.status) {\n          span.setHttpStatus(originalResponse.status);\n        }\n\n        const hub = getCurrentHub();\n        const client = hub.getClient();\n        const contentType = originalResponse.headers.get('content-type');\n\n        const isPageloadRequest = contentType && contentType.startsWith('text/html');\n        if (!isPageloadRequest || !client) {\n          return originalResponse;\n        }\n\n        // Type case necessary b/c the body's ReadableStream type doesn't include\n        // the async iterator that is actually available in Node\n        // We later on use the async iterator to read the body chunks\n        // see https://github.com/microsoft/TypeScript/issues/39051\n        const originalBody = originalResponse.body as NodeJS.ReadableStream | null;\n        if (!originalBody) {\n          return originalResponse;\n        }\n\n        const decoder = new TextDecoder();\n\n        const newResponseStream = new ReadableStream({\n          start: async controller => {\n            for await (const chunk of originalBody) {\n              const html = typeof chunk === 'string' ? chunk : decoder.decode(chunk);\n              const modifiedHtml = addMetaTagToHead(html, hub, span);\n              controller.enqueue(new TextEncoder().encode(modifiedHtml));\n            }\n            controller.close();\n          },\n        });\n\n        return new Response(newResponseStream, originalResponse);\n      },\n    );\n    return res;\n  } catch (e) {\n    sendErrorToSentry(e);\n    throw e;\n  }\n  // TODO: flush if serverless (first extract function)\n}\n\n/**\n * This function optimistically assumes that the HTML coming in chunks will not be split\n * within the <head> tag. If this still happens, we simply won't replace anything.\n */\nfunction addMetaTagToHead(htmlChunk: string, hub: Hub, span?: Span): string {\n  if (typeof htmlChunk !== 'string') {\n    return htmlChunk;\n  }\n\n  const { sentryTrace, baggage } = getTracingMetaTags(span, hub);\n  const content = `<head>\\n${sentryTrace}\\n${baggage}\\n`;\n  return htmlChunk.replace('<head>', content);\n}\n\n/**\n * Interpolates the route from the URL and the passed params.\n * Best we can do to get a route name instead of a raw URL.\n *\n * exported for testing\n *\n * @param rawUrlPathname - The raw URL pathname, e.g. '/users/123/details'\n * @param params - The params object, e.g. `{ userId: '123' }`\n *\n * @returns The interpolated route, e.g. '/users/[userId]/details'\n */\nexport function interpolateRouteFromUrlAndParams(\n  rawUrlPathname: string,\n  params: APIContext['params'],\n): string | undefined {\n  const decodedUrlPathname = tryDecodeUrl(rawUrlPathname);\n  if (!decodedUrlPathname) {\n    return undefined;\n  }\n\n  // Invert params map so that the param values are the keys\n  // differentiate between rest params spanning multiple url segments\n  // and normal, single-segment params.\n  const valuesToMultiSegmentParams: Record<string, string> = {};\n  const valuesToParams: Record<string, string> = {};\n  Object.entries(params).forEach(([key, value]) => {\n    if (!value) {\n      return;\n    }\n    if (value.includes('/')) {\n      valuesToMultiSegmentParams[value] = key;\n      return;\n    }\n    valuesToParams[value] = key;\n  });\n\n  function replaceWithParamName(segment: string): string {\n    const param = valuesToParams[segment];\n    if (param) {\n      return `[${param}]`;\n    }\n    return segment;\n  }\n\n  // before we match single-segment params, we first replace multi-segment params\n  const urlWithReplacedMultiSegmentParams = Object.keys(valuesToMultiSegmentParams).reduce((acc, key) => {\n    return acc.replace(key, `[${valuesToMultiSegmentParams[key]}]`);\n  }, decodedUrlPathname);\n\n  return urlWithReplacedMultiSegmentParams\n    .split('/')\n    .map(segment => {\n      if (!segment) {\n        return '';\n      }\n\n      if (valuesToParams[segment]) {\n        return replaceWithParamName(segment);\n      }\n\n      // astro permits multiple params in a single path segment, e.g. /[foo]-[bar]/\n      const segmentParts = segment.split('-');\n      if (segmentParts.length > 1) {\n        return segmentParts.map(part => replaceWithParamName(part)).join('-');\n      }\n\n      return segment;\n    })\n    .join('/');\n}\n\nfunction tryDecodeUrl(url: string): string | undefined {\n  try {\n    return decodeURI(url);\n  } catch {\n    return undefined;\n  }\n}\n", "import * as SentryNode from '@sentry/node';\nimport { vi } from 'vitest';\n\nimport { handleRequest, interpolateRouteFromUrlAndParams } from '../../src/server/middleware';\n\nvi.mock('../../src/server/meta', () => ({\n  getTracingMetaTags: () => ({\n    sentryTrace: '<meta name=\"sentry-trace\" content=\"123\">',\n    baggage: '<meta name=\"baggage\" content=\"abc\">',\n  }),\n}));\n\ndescribe('sentryMiddleware', () => {\n  const startSpanSpy = vi.spyOn(SentryNode, 'startSpan');\n\n  const getSpanMock = vi.fn(() => {});\n  // @ts-expect-error only returning a partial hub here\n  vi.spyOn(SentryNode, 'getCurrentHub').mockImplementation(() => {\n    return {\n      getScope: () => ({\n        getSpan: getSpanMock,\n      }),\n      getClient: () => ({}),\n    };\n  });\n\n  const nextResult = Promise.resolve(new Response(null, { status: 200, headers: new Headers() }));\n\n  afterEach(() => {\n    vi.clearAllMocks();\n  });\n\n  it('creates a span for an incoming request', async () => {\n    const middleware = handleRequest();\n    const ctx = {\n      request: {\n        method: 'GET',\n        url: '/users/123/details',\n        headers: new Headers(),\n      },\n      url: new URL('https://myDomain.io/users/123/details'),\n      params: {\n        id: '123',\n      },\n    };\n    const next = vi.fn(() => nextResult);\n\n    // @ts-expect-error, a partial ctx object is fine here\n    const resultFromNext = middleware(ctx, next);\n\n    expect(startSpanSpy).toHaveBeenCalledWith(\n      {\n        data: {\n          method: 'GET',\n          url: 'https://mydomain.io/users/123/details',\n        },\n        metadata: {\n          source: 'route',\n        },\n        name: 'GET /users/[id]/details',\n        op: 'http.server',\n        origin: 'auto.http.astro',\n        status: 'ok',\n      },\n      expect.any(Function), // the `next` function\n    );\n\n    expect(next).toHaveBeenCalled();\n    expect(resultFromNext).toStrictEqual(nextResult);\n  });\n\n  it(\"sets source route if the url couldn't be decoded correctly\", async () => {\n    const middleware = handleRequest();\n    const ctx = {\n      request: {\n        method: 'GET',\n        url: '/a%xx',\n        headers: new Headers(),\n      },\n      url: { pathname: 'a%xx', href: 'http://localhost:1234/a%xx' },\n      params: {},\n    };\n    const next = vi.fn(() => nextResult);\n\n    // @ts-expect-error, a partial ctx object is fine here\n    const resultFromNext = middleware(ctx, next);\n\n    expect(startSpanSpy).toHaveBeenCalledWith(\n      {\n        data: {\n          method: 'GET',\n          url: 'http://localhost:1234/a%xx',\n        },\n        metadata: {\n          source: 'url',\n        },\n        name: 'GET a%xx',\n        op: 'http.server',\n        origin: 'auto.http.astro',\n        status: 'ok',\n      },\n      expect.any(Function), // the `next` function\n    );\n\n    expect(next).toHaveBeenCalled();\n    expect(resultFromNext).toStrictEqual(nextResult);\n  });\n\n  it('throws and sends an error to sentry if `next()` throws', async () => {\n    const captureExceptionSpy = vi.spyOn(SentryNode, 'captureException');\n\n    const middleware = handleRequest();\n    const ctx = {\n      request: {\n        method: 'GET',\n        url: '/users',\n        headers: new Headers(),\n      },\n      url: new URL('https://myDomain.io/users/'),\n      params: {},\n    };\n\n    const error = new Error('Something went wrong');\n\n    const next = vi.fn(() => {\n      throw error;\n    });\n\n    // @ts-expect-error, a partial ctx object is fine here\n    await expect(async () => middleware(ctx, next)).rejects.toThrowError();\n\n    expect(captureExceptionSpy).toHaveBeenCalledWith(error, {\n      mechanism: { handled: false, type: 'astro', data: { function: 'astroMiddleware' } },\n    });\n  });\n\n  it('attaches tracing headers', async () => {\n    const middleware = handleRequest();\n    const ctx = {\n      request: {\n        method: 'GET',\n        url: '/users',\n        headers: new Headers({\n          'sentry-trace': '12345678901234567890123456789012-1234567890123456-1',\n          baggage: 'sentry-release=1.0.0',\n        }),\n      },\n      params: {},\n      url: new URL('https://myDomain.io/users/'),\n    };\n    const next = vi.fn(() => nextResult);\n\n    // @ts-expect-error, a partial ctx object is fine here\n    await middleware(ctx, next);\n\n    expect(startSpanSpy).toHaveBeenCalledWith(\n      expect.objectContaining({\n        metadata: {\n          source: 'route',\n          dynamicSamplingContext: {\n            release: '1.0.0',\n          },\n        },\n        parentSampled: true,\n        parentSpanId: '1234567890123456',\n        traceId: '12345678901234567890123456789012',\n      }),\n      expect.any(Function), // the `next` function\n    );\n  });\n\n  it('attaches client IP and request headers if options are set', async () => {\n    const scope = { setUser: vi.fn(), setPropagationContext: vi.fn() };\n    // @ts-expect-error, only passing a partial Scope object\n    const configureScopeSpy = vi.spyOn(SentryNode, 'configureScope').mockImplementation(cb => cb(scope));\n\n    const middleware = handleRequest({ trackClientIp: true, trackHeaders: true });\n    const ctx = {\n      request: {\n        method: 'GET',\n        url: '/users',\n        headers: new Headers({\n          'some-header': 'some-value',\n        }),\n      },\n      clientAddress: '192.168.0.1',\n      params: {},\n      url: new URL('https://myDomain.io/users/'),\n    };\n    const next = vi.fn(() => nextResult);\n\n    // @ts-expect-error, a partial ctx object is fine here\n    await middleware(ctx, next);\n\n    expect(configureScopeSpy).toHaveBeenCalledTimes(1);\n    expect(scope.setUser).toHaveBeenCalledWith({ ip_address: '192.168.0.1' });\n\n    expect(startSpanSpy).toHaveBeenCalledWith(\n      expect.objectContaining({\n        data: expect.objectContaining({\n          headers: {\n            'some-header': 'some-value',\n          },\n        }),\n      }),\n      expect.any(Function), // the `next` function\n    );\n  });\n\n  it('injects tracing <meta> tags into the HTML of a pageload response', async () => {\n    const middleware = handleRequest();\n\n    const ctx = {\n      request: {\n        method: 'GET',\n        url: '/users',\n        headers: new Headers(),\n      },\n      params: {},\n      url: new URL('https://myDomain.io/users/'),\n    };\n    const next = vi.fn(() =>\n      Promise.resolve(\n        new Response('<head><meta name=\"something\" content=\"\"/></head>', {\n          headers: new Headers({ 'content-type': 'text/html' }),\n        }),\n      ),\n    );\n\n    // @ts-expect-error, a partial ctx object is fine here\n    const resultFromNext = await middleware(ctx, next);\n\n    expect(resultFromNext?.headers.get('content-type')).toEqual('text/html');\n\n    const html = await resultFromNext?.text();\n\n    expect(html).toContain('<meta name=\"sentry-trace\" content=\"');\n    expect(html).toContain('<meta name=\"baggage\" content=\"');\n  });\n\n  it(\"no-ops if the response isn't HTML\", async () => {\n    const middleware = handleRequest();\n\n    const ctx = {\n      request: {\n        method: 'GET',\n        url: '/users',\n        headers: new Headers(),\n      },\n      params: {},\n      url: new URL('https://myDomain.io/users/'),\n    };\n\n    const originalResponse = new Response('{\"foo\": \"bar\"}', {\n      headers: new Headers({ 'content-type': 'application/json' }),\n    });\n    const next = vi.fn(() => Promise.resolve(originalResponse));\n\n    // @ts-expect-error, a partial ctx object is fine here\n    const resultFromNext = await middleware(ctx, next);\n\n    expect(resultFromNext).toBe(originalResponse);\n  });\n\n  it(\"no-ops if there's no <head> tag in the response\", async () => {\n    const middleware = handleRequest();\n\n    const ctx = {\n      request: {\n        method: 'GET',\n        url: '/users',\n        headers: new Headers(),\n      },\n      params: {},\n      url: new URL('https://myDomain.io/users/'),\n    };\n\n    const originalHtml = '<p>no head</p>';\n    const originalResponse = new Response(originalHtml, {\n      headers: new Headers({ 'content-type': 'text/html' }),\n    });\n    const next = vi.fn(() => Promise.resolve(originalResponse));\n\n    // @ts-expect-error, a partial ctx object is fine here\n    const resultFromNext = await middleware(ctx, next);\n\n    expect(resultFromNext?.headers.get('content-type')).toEqual('text/html');\n\n    const html = await resultFromNext?.text();\n\n    expect(html).toBe(originalHtml);\n  });\n\n  describe('async context isolation', () => {\n    const runWithAsyncContextSpy = vi.spyOn(SentryNode, 'runWithAsyncContext');\n    afterEach(() => {\n      vi.clearAllMocks();\n      runWithAsyncContextSpy.mockRestore();\n    });\n\n    it('starts a new async context if no span is active', async () => {\n      getSpanMock.mockReturnValueOnce(undefined);\n      const handler = handleRequest();\n      const ctx = {};\n      const next = vi.fn();\n\n      try {\n        // @ts-expect-error, a partial ctx object is fine here\n        await handler(ctx, next);\n      } catch {\n        // this is fine, it's not required to pass in this test\n      }\n\n      expect(runWithAsyncContextSpy).toHaveBeenCalledTimes(1);\n    });\n\n    it(\"doesn't start a new async context if a span is active\", async () => {\n      // @ts-expect-error, a empty span is fine here\n      getSpanMock.mockReturnValueOnce({});\n\n      const handler = handleRequest();\n      const ctx = {};\n      const next = vi.fn();\n\n      try {\n        // @ts-expect-error, a partial ctx object is fine here\n        await handler(ctx, next);\n      } catch {\n        // this is fine, it's not required to pass in this test\n      }\n\n      expect(runWithAsyncContextSpy).not.toHaveBeenCalled();\n    });\n  });\n});\n\ndescribe('interpolateRouteFromUrlAndParams', () => {\n  it.each([\n    ['/', {}, '/'],\n    ['/foo/bar', {}, '/foo/bar'],\n    ['/users/123', { id: '123' }, '/users/[id]'],\n    ['/users/123', { id: '123', foo: 'bar' }, '/users/[id]'],\n    ['/lang/en-US', { lang: 'en', region: 'US' }, '/lang/[lang]-[region]'],\n    ['/lang/en-US/posts', { lang: 'en', region: 'US' }, '/lang/[lang]-[region]/posts'],\n    // edge cases that astro doesn't support\n    ['/lang/-US', { region: 'US' }, '/lang/-[region]'],\n    ['/lang/en-', { lang: 'en' }, '/lang/[lang]-'],\n  ])('interpolates route from URL and params %s', (rawUrl, params, expectedRoute) => {\n    expect(interpolateRouteFromUrlAndParams(rawUrl, params)).toEqual(expectedRoute);\n  });\n\n  it.each([\n    ['/(a+)+/aaaaaaaaa!', { id: '(a+)+', slug: 'aaaaaaaaa!' }, '/[id]/[slug]'],\n    ['/([a-zA-Z]+)*/aaaaaaaaa!', { id: '([a-zA-Z]+)*', slug: 'aaaaaaaaa!' }, '/[id]/[slug]'],\n    ['/(a|aa)+/aaaaaaaaa!', { id: '(a|aa)+', slug: 'aaaaaaaaa!' }, '/[id]/[slug]'],\n    ['/(a|a?)+/aaaaaaaaa!', { id: '(a|a?)+', slug: 'aaaaaaaaa!' }, '/[id]/[slug]'],\n    // with URL encoding\n    ['/(a%7Caa)+/aaaaaaaaa!', { id: '(a|aa)+', slug: 'aaaaaaaaa!' }, '/[id]/[slug]'],\n    ['/(a%7Ca?)+/aaaaaaaaa!', { id: '(a|a?)+', slug: 'aaaaaaaaa!' }, '/[id]/[slug]'],\n  ])('handles regex characters in param values correctly %s', (rawUrl, params, expectedRoute) => {\n    expect(interpolateRouteFromUrlAndParams(rawUrl, params)).toEqual(expectedRoute);\n  });\n\n  it('handles params across multiple URL segments in catchall routes', () => {\n    // Ideally, Astro would let us know that this is a catchall route so we can make the param [...catchall] but it doesn't\n    expect(\n      interpolateRouteFromUrlAndParams('/someroute/catchall-123/params/foo/bar', {\n        catchall: 'catchall-123/params/foo',\n        params: 'foo',\n      }),\n    ).toEqual('/someroute/[catchall]/bar');\n  });\n\n  it(\"doesn't replace partially matching route segments\", () => {\n    const rawUrl = '/usernames/username';\n    const params = { name: 'username' };\n    const expectedRoute = '/usernames/[name]';\n    expect(interpolateRouteFromUrlAndParams(rawUrl, params)).toEqual(expectedRoute);\n  });\n\n  it('handles set but undefined params', () => {\n    const rawUrl = '/usernames/user';\n    const params = { name: undefined, name2: '' };\n    const expectedRoute = '/usernames/user';\n    expect(interpolateRouteFromUrlAndParams(rawUrl, params)).toEqual(expectedRoute);\n  });\n});\n"], "filenames": ["packages/astro/src/server/middleware.ts", "packages/astro/test/server/middleware.test.ts"], "buggy_code_start_loc": [10, 60], "buggy_code_end_loc": [212, 326], "fixing_code_start_loc": [10, 61], "fixing_code_end_loc": [278, 387], "type": "CWE-1333", "message": "Sentry-Javascript is official Sentry SDKs for JavaScript. A ReDoS (Regular expression Denial of Service) vulnerability has been identified in Sentry's Astro SDK 7.78.0-7.86.0. Under certain conditions, this vulnerability allows an attacker to cause excessive computation times on the server, leading to denial of service (DoS). This vulnerability has been patched in sentry/astro version 7.87.0.", "other": {"cve": {"id": "CVE-2023-50249", "sourceIdentifier": "security-advisories@github.com", "published": "2023-12-20T14:15:21.350", "lastModified": "2023-12-28T20:11:56.530", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Sentry-Javascript is official Sentry SDKs for JavaScript. A ReDoS (Regular expression Denial of Service) vulnerability has been identified in Sentry's Astro SDK 7.78.0-7.86.0. Under certain conditions, this vulnerability allows an attacker to cause excessive computation times on the server, leading to denial of service (DoS). This vulnerability has been patched in sentry/astro version 7.87.0."}, {"lang": "es", "value": "Sentry-Javascript es el SDK oficial de Sentry para JavaScript. Se ha identificado una vulnerabilidad ReDoS (Denegaci\u00f3n de servicio de expresi\u00f3n regular) en Astro SDK 7.78.0-7.86.0 de Sentry. Bajo ciertas condiciones, esta vulnerabilidad permite que un atacante provoque tiempos de c\u00e1lculo excesivos en el servidor, lo que lleva a una denegaci\u00f3n de servicio (DoS). Esta vulnerabilidad ha sido parcheada en sentry/astro versi\u00f3n 7.87.0."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-1333"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sentry:astro:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "7.78.0", "versionEndExcluding": "7.87.0", "matchCriteriaId": "AAA3C0C0-98ED-4031-91A3-40B43CFD8370"}]}]}], "references": [{"url": "https://github.com/getsentry/sentry-javascript/commit/fe24eb5eefa9d27b14b2b6f9ebd1debca1c208fb", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/getsentry/sentry-javascript/pull/9815", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/getsentry/sentry-javascript/security/advisories/GHSA-x3v3-8xg8-8v72", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/getsentry/sentry-javascript/commit/fe24eb5eefa9d27b14b2b6f9ebd1debca1c208fb"}}