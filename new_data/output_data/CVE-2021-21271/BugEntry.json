{"buggy_code": ["package consensus\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"path\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\tdbm \"github.com/tendermint/tm-db\"\n\n\tabcicli \"github.com/tendermint/tendermint/abci/client\"\n\tabci \"github.com/tendermint/tendermint/abci/types\"\n\t\"github.com/tendermint/tendermint/evidence\"\n\t\"github.com/tendermint/tendermint/libs/log\"\n\t\"github.com/tendermint/tendermint/libs/service\"\n\ttmsync \"github.com/tendermint/tendermint/libs/sync\"\n\tmempl \"github.com/tendermint/tendermint/mempool\"\n\t\"github.com/tendermint/tendermint/p2p\"\n\ttmproto \"github.com/tendermint/tendermint/proto/tendermint/types\"\n\tsm \"github.com/tendermint/tendermint/state\"\n\t\"github.com/tendermint/tendermint/store\"\n\t\"github.com/tendermint/tendermint/types\"\n)\n\n//----------------------------------------------\n// byzantine failures\n\n// Byzantine node sends two different prevotes (nil and blockID) to the same validator\nfunc TestByzantinePrevoteEquivocation(t *testing.T) {\n\tconst nValidators = 4\n\tconst byzantineNode = 0\n\tconst prevoteHeight = int64(2)\n\ttestName := \"consensus_byzantine_test\"\n\ttickerFunc := newMockTickerFunc(true)\n\tappFunc := newCounter\n\n\tgenDoc, privVals := randGenesisDoc(nValidators, false, 30)\n\tcss := make([]*State, nValidators)\n\n\tfor i := 0; i < nValidators; i++ {\n\t\tlogger := consensusLogger().With(\"test\", \"byzantine\", \"validator\", i)\n\t\tstateDB := dbm.NewMemDB() // each state needs its own db\n\t\tstateStore := sm.NewStore(stateDB)\n\t\tstate, _ := stateStore.LoadFromDBOrGenesisDoc(genDoc)\n\t\tthisConfig := ResetConfig(fmt.Sprintf(\"%s_%d\", testName, i))\n\t\tdefer os.RemoveAll(thisConfig.RootDir)\n\t\tensureDir(path.Dir(thisConfig.Consensus.WalFile()), 0700) // dir for wal\n\t\tapp := appFunc()\n\t\tvals := types.TM2PB.ValidatorUpdates(state.Validators)\n\t\tapp.InitChain(abci.RequestInitChain{Validators: vals})\n\n\t\tblockDB := dbm.NewMemDB()\n\t\tblockStore := store.NewBlockStore(blockDB)\n\n\t\t// one for mempool, one for consensus\n\t\tmtx := new(tmsync.Mutex)\n\t\tproxyAppConnMem := abcicli.NewLocalClient(mtx, app)\n\t\tproxyAppConnCon := abcicli.NewLocalClient(mtx, app)\n\n\t\t// Make Mempool\n\t\tmempool := mempl.NewCListMempool(thisConfig.Mempool, proxyAppConnMem, 0)\n\t\tmempool.SetLogger(log.TestingLogger().With(\"module\", \"mempool\"))\n\t\tif thisConfig.Consensus.WaitForTxs() {\n\t\t\tmempool.EnableTxsAvailable()\n\t\t}\n\n\t\t// Make a full instance of the evidence pool\n\t\tevidenceDB := dbm.NewMemDB()\n\t\tevpool, err := evidence.NewPool(evidenceDB, stateStore, blockStore)\n\t\trequire.NoError(t, err)\n\t\tevpool.SetLogger(logger.With(\"module\", \"evidence\"))\n\n\t\t// Make State\n\t\tblockExec := sm.NewBlockExecutor(stateStore, log.TestingLogger(), proxyAppConnCon, mempool, evpool)\n\t\tcs := NewState(thisConfig.Consensus, state, blockExec, blockStore, mempool, evpool)\n\t\tcs.SetLogger(cs.Logger)\n\t\t// set private validator\n\t\tpv := privVals[i]\n\t\tcs.SetPrivValidator(pv)\n\n\t\teventBus := types.NewEventBus()\n\t\teventBus.SetLogger(log.TestingLogger().With(\"module\", \"events\"))\n\t\terr = eventBus.Start()\n\t\trequire.NoError(t, err)\n\t\tcs.SetEventBus(eventBus)\n\n\t\tcs.SetTimeoutTicker(tickerFunc())\n\t\tcs.SetLogger(logger)\n\n\t\tcss[i] = cs\n\t}\n\n\t// initialize the reactors for each of the validators\n\treactors := make([]*Reactor, nValidators)\n\tblocksSubs := make([]types.Subscription, 0)\n\teventBuses := make([]*types.EventBus, nValidators)\n\tfor i := 0; i < nValidators; i++ {\n\t\treactors[i] = NewReactor(css[i], true) // so we dont start the consensus states\n\t\treactors[i].SetLogger(css[i].Logger)\n\n\t\t// eventBus is already started with the cs\n\t\teventBuses[i] = css[i].eventBus\n\t\treactors[i].SetEventBus(eventBuses[i])\n\n\t\tblocksSub, err := eventBuses[i].Subscribe(context.Background(), testSubscriber, types.EventQueryNewBlock, 100)\n\t\trequire.NoError(t, err)\n\t\tblocksSubs = append(blocksSubs, blocksSub)\n\n\t\tif css[i].state.LastBlockHeight == 0 { // simulate handle initChain in handshake\n\t\t\terr = css[i].blockExec.Store().Save(css[i].state)\n\t\t\trequire.NoError(t, err)\n\t\t}\n\t}\n\t// make connected switches and start all reactors\n\tp2p.MakeConnectedSwitches(config.P2P, nValidators, func(i int, s *p2p.Switch) *p2p.Switch {\n\t\ts.AddReactor(\"CONSENSUS\", reactors[i])\n\t\ts.SetLogger(reactors[i].conS.Logger.With(\"module\", \"p2p\"))\n\t\treturn s\n\t}, p2p.Connect2Switches)\n\n\t// create byzantine validator\n\tbcs := css[byzantineNode]\n\n\t// alter prevote so that the byzantine node double votes when height is 2\n\tbcs.doPrevote = func(height int64, round int32) {\n\t\t// allow first height to happen normally so that byzantine validator is no longer proposer\n\t\tif height == prevoteHeight {\n\t\t\tbcs.Logger.Info(\"Sending two votes\")\n\t\t\tprevote1, err := bcs.signVote(tmproto.PrevoteType, bcs.ProposalBlock.Hash(), bcs.ProposalBlockParts.Header())\n\t\t\trequire.NoError(t, err)\n\t\t\tprevote2, err := bcs.signVote(tmproto.PrevoteType, nil, types.PartSetHeader{})\n\t\t\trequire.NoError(t, err)\n\t\t\tpeerList := reactors[byzantineNode].Switch.Peers().List()\n\t\t\tbcs.Logger.Info(\"Getting peer list\", \"peers\", peerList)\n\t\t\t// send two votes to all peers (1st to one half, 2nd to another half)\n\t\t\tfor i, peer := range peerList {\n\t\t\t\tif i < len(peerList)/2 {\n\t\t\t\t\tbcs.Logger.Info(\"Signed and pushed vote\", \"vote\", prevote1, \"peer\", peer)\n\t\t\t\t\tpeer.Send(VoteChannel, MustEncode(&VoteMessage{prevote1}))\n\t\t\t\t} else {\n\t\t\t\t\tbcs.Logger.Info(\"Signed and pushed vote\", \"vote\", prevote2, \"peer\", peer)\n\t\t\t\t\tpeer.Send(VoteChannel, MustEncode(&VoteMessage{prevote2}))\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tbcs.Logger.Info(\"Behaving normally\")\n\t\t\tbcs.defaultDoPrevote(height, round)\n\t\t}\n\t}\n\n\t// start the consensus reactors\n\tfor i := 0; i < nValidators; i++ {\n\t\ts := reactors[i].conS.GetState()\n\t\treactors[i].SwitchToConsensus(s, false)\n\t}\n\tdefer stopConsensusNet(log.TestingLogger(), reactors, eventBuses)\n\n\t// Evidence should be submitted and committed at the third height but\n\t// we will check the first six just in case\n\tevidenceFromEachValidator := make([]types.Evidence, nValidators)\n\n\twg := new(sync.WaitGroup)\n\tfor i := 0; i < nValidators; i++ {\n\t\twg.Add(1)\n\t\tgo func(i int) {\n\t\t\tdefer wg.Done()\n\t\t\tfor msg := range blocksSubs[i].Out() {\n\t\t\t\tblock := msg.Data().(types.EventDataNewBlock).Block\n\t\t\t\tif len(block.Evidence.Evidence) != 0 {\n\t\t\t\t\tevidenceFromEachValidator[i] = block.Evidence.Evidence[0]\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\n\tdone := make(chan struct{})\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(done)\n\t}()\n\n\tpubkey, err := bcs.privValidator.GetPubKey()\n\trequire.NoError(t, err)\n\n\tselect {\n\tcase <-done:\n\t\tfor idx, ev := range evidenceFromEachValidator {\n\t\t\tif assert.NotNil(t, ev, idx) {\n\t\t\t\tev, ok := ev.(*types.DuplicateVoteEvidence)\n\t\t\t\tassert.True(t, ok)\n\t\t\t\tassert.Equal(t, pubkey.Address(), ev.VoteA.ValidatorAddress)\n\t\t\t\tassert.Equal(t, prevoteHeight, ev.Height())\n\t\t\t}\n\t\t}\n\tcase <-time.After(20 * time.Second):\n\t\tfor i, reactor := range reactors {\n\t\t\tt.Logf(\"Consensus Reactor %d\\n%v\", i, reactor)\n\t\t}\n\t\tt.Fatalf(\"Timed out waiting for validators to commit evidence\")\n\t}\n}\n\n// 4 validators. 1 is byzantine. The other three are partitioned into A (1 val) and B (2 vals).\n// byzantine validator sends conflicting proposals into A and B,\n// and prevotes/precommits on both of them.\n// B sees a commit, A doesn't.\n// Heal partition and ensure A sees the commit\nfunc TestByzantineConflictingProposalsWithPartition(t *testing.T) {\n\tN := 4\n\tlogger := consensusLogger().With(\"test\", \"byzantine\")\n\tapp := newCounter\n\tcss, cleanup := randConsensusNet(N, \"consensus_byzantine_test\", newMockTickerFunc(false), app)\n\tdefer cleanup()\n\n\t// give the byzantine validator a normal ticker\n\tticker := NewTimeoutTicker()\n\tticker.SetLogger(css[0].Logger)\n\tcss[0].SetTimeoutTicker(ticker)\n\n\tswitches := make([]*p2p.Switch, N)\n\tp2pLogger := logger.With(\"module\", \"p2p\")\n\tfor i := 0; i < N; i++ {\n\t\tswitches[i] = p2p.MakeSwitch(\n\t\t\tconfig.P2P,\n\t\t\ti,\n\t\t\t\"foo\", \"1.0.0\",\n\t\t\tfunc(i int, sw *p2p.Switch) *p2p.Switch {\n\t\t\t\treturn sw\n\t\t\t})\n\t\tswitches[i].SetLogger(p2pLogger.With(\"validator\", i))\n\t}\n\n\tblocksSubs := make([]types.Subscription, N)\n\treactors := make([]p2p.Reactor, N)\n\tfor i := 0; i < N; i++ {\n\n\t\t// enable txs so we can create different proposals\n\t\tassertMempool(css[i].txNotifier).EnableTxsAvailable()\n\t\t// make first val byzantine\n\t\tif i == 0 {\n\t\t\t// NOTE: Now, test validators are MockPV, which by default doesn't\n\t\t\t// do any safety checks.\n\t\t\tcss[i].privValidator.(types.MockPV).DisableChecks()\n\t\t\tcss[i].decideProposal = func(j int32) func(int64, int32) {\n\t\t\t\treturn func(height int64, round int32) {\n\t\t\t\t\tbyzantineDecideProposalFunc(t, height, round, css[j], switches[j])\n\t\t\t\t}\n\t\t\t}(int32(i))\n\t\t\t// We are setting the prevote function to do nothing because the prevoting\n\t\t\t// and precommitting are done alongside the proposal.\n\t\t\tcss[i].doPrevote = func(height int64, round int32) {}\n\t\t}\n\n\t\teventBus := css[i].eventBus\n\t\teventBus.SetLogger(logger.With(\"module\", \"events\", \"validator\", i))\n\n\t\tvar err error\n\t\tblocksSubs[i], err = eventBus.Subscribe(context.Background(), testSubscriber, types.EventQueryNewBlock)\n\t\trequire.NoError(t, err)\n\n\t\tconR := NewReactor(css[i], true) // so we don't start the consensus states\n\t\tconR.SetLogger(logger.With(\"validator\", i))\n\t\tconR.SetEventBus(eventBus)\n\n\t\tvar conRI p2p.Reactor = conR\n\n\t\t// make first val byzantine\n\t\tif i == 0 {\n\t\t\tconRI = NewByzantineReactor(conR)\n\t\t}\n\n\t\treactors[i] = conRI\n\t\terr = css[i].blockExec.Store().Save(css[i].state) // for save height 1's validators info\n\t\trequire.NoError(t, err)\n\t}\n\n\tdefer func() {\n\t\tfor _, r := range reactors {\n\t\t\tif rr, ok := r.(*ByzantineReactor); ok {\n\t\t\t\terr := rr.reactor.Switch.Stop()\n\t\t\t\trequire.NoError(t, err)\n\t\t\t} else {\n\t\t\t\terr := r.(*Reactor).Switch.Stop()\n\t\t\t\trequire.NoError(t, err)\n\t\t\t}\n\t\t}\n\t}()\n\n\tp2p.MakeConnectedSwitches(config.P2P, N, func(i int, s *p2p.Switch) *p2p.Switch {\n\t\t// ignore new switch s, we already made ours\n\t\tswitches[i].AddReactor(\"CONSENSUS\", reactors[i])\n\t\treturn switches[i]\n\t}, func(sws []*p2p.Switch, i, j int) {\n\t\t// the network starts partitioned with globally active adversary\n\t\tif i != 0 {\n\t\t\treturn\n\t\t}\n\t\tp2p.Connect2Switches(sws, i, j)\n\t})\n\n\t// start the non-byz state machines.\n\t// note these must be started before the byz\n\tfor i := 1; i < N; i++ {\n\t\tcr := reactors[i].(*Reactor)\n\t\tcr.SwitchToConsensus(cr.conS.GetState(), false)\n\t}\n\n\t// start the byzantine state machine\n\tbyzR := reactors[0].(*ByzantineReactor)\n\ts := byzR.reactor.conS.GetState()\n\tbyzR.reactor.SwitchToConsensus(s, false)\n\n\t// byz proposer sends one block to peers[0]\n\t// and the other block to peers[1] and peers[2].\n\t// note peers and switches order don't match.\n\tpeers := switches[0].Peers().List()\n\n\t// partition A\n\tind0 := getSwitchIndex(switches, peers[0])\n\n\t// partition B\n\tind1 := getSwitchIndex(switches, peers[1])\n\tind2 := getSwitchIndex(switches, peers[2])\n\tp2p.Connect2Switches(switches, ind1, ind2)\n\n\t// wait for someone in the big partition (B) to make a block\n\t<-blocksSubs[ind2].Out()\n\n\tt.Log(\"A block has been committed. Healing partition\")\n\tp2p.Connect2Switches(switches, ind0, ind1)\n\tp2p.Connect2Switches(switches, ind0, ind2)\n\n\t// wait till everyone makes the first new block\n\t// (one of them already has)\n\twg := new(sync.WaitGroup)\n\tfor i := 1; i < N-1; i++ {\n\t\twg.Add(1)\n\t\tgo func(j int) {\n\t\t\t<-blocksSubs[j].Out()\n\t\t\twg.Done()\n\t\t}(i)\n\t}\n\n\tdone := make(chan struct{})\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(done)\n\t}()\n\n\ttick := time.NewTicker(time.Second * 10)\n\tselect {\n\tcase <-done:\n\tcase <-tick.C:\n\t\tfor i, reactor := range reactors {\n\t\t\tt.Log(fmt.Sprintf(\"Consensus Reactor %v\", i))\n\t\t\tt.Log(fmt.Sprintf(\"%v\", reactor))\n\t\t}\n\t\tt.Fatalf(\"Timed out waiting for all validators to commit first block\")\n\t}\n}\n\n//-------------------------------\n// byzantine consensus functions\n\nfunc byzantineDecideProposalFunc(t *testing.T, height int64, round int32, cs *State, sw *p2p.Switch) {\n\t// byzantine user should create two proposals and try to split the vote.\n\t// Avoid sending on internalMsgQueue and running consensus state.\n\n\t// Create a new proposal block from state/txs from the mempool.\n\tblock1, blockParts1 := cs.createProposalBlock()\n\tpolRound, propBlockID := cs.ValidRound, types.BlockID{Hash: block1.Hash(), PartSetHeader: blockParts1.Header()}\n\tproposal1 := types.NewProposal(height, round, polRound, propBlockID)\n\tp1 := proposal1.ToProto()\n\tif err := cs.privValidator.SignProposal(cs.state.ChainID, p1); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tproposal1.Signature = p1.Signature\n\n\t// some new transactions come in (this ensures that the proposals are different)\n\tdeliverTxsRange(cs, 0, 1)\n\n\t// Create a new proposal block from state/txs from the mempool.\n\tblock2, blockParts2 := cs.createProposalBlock()\n\tpolRound, propBlockID = cs.ValidRound, types.BlockID{Hash: block2.Hash(), PartSetHeader: blockParts2.Header()}\n\tproposal2 := types.NewProposal(height, round, polRound, propBlockID)\n\tp2 := proposal2.ToProto()\n\tif err := cs.privValidator.SignProposal(cs.state.ChainID, p2); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tproposal2.Signature = p2.Signature\n\n\tblock1Hash := block1.Hash()\n\tblock2Hash := block2.Hash()\n\n\t// broadcast conflicting proposals/block parts to peers\n\tpeers := sw.Peers().List()\n\tt.Logf(\"Byzantine: broadcasting conflicting proposals to %d peers\", len(peers))\n\tfor i, peer := range peers {\n\t\tif i < len(peers)/2 {\n\t\t\tgo sendProposalAndParts(height, round, cs, peer, proposal1, block1Hash, blockParts1)\n\t\t} else {\n\t\t\tgo sendProposalAndParts(height, round, cs, peer, proposal2, block2Hash, blockParts2)\n\t\t}\n\t}\n}\n\nfunc sendProposalAndParts(\n\theight int64,\n\tround int32,\n\tcs *State,\n\tpeer p2p.Peer,\n\tproposal *types.Proposal,\n\tblockHash []byte,\n\tparts *types.PartSet,\n) {\n\t// proposal\n\tmsg := &ProposalMessage{Proposal: proposal}\n\tpeer.Send(DataChannel, MustEncode(msg))\n\n\t// parts\n\tfor i := 0; i < int(parts.Total()); i++ {\n\t\tpart := parts.GetPart(i)\n\t\tmsg := &BlockPartMessage{\n\t\t\tHeight: height, // This tells peer that this part applies to us.\n\t\t\tRound:  round,  // This tells peer that this part applies to us.\n\t\t\tPart:   part,\n\t\t}\n\t\tpeer.Send(DataChannel, MustEncode(msg))\n\t}\n\n\t// votes\n\tcs.mtx.Lock()\n\tprevote, _ := cs.signVote(tmproto.PrevoteType, blockHash, parts.Header())\n\tprecommit, _ := cs.signVote(tmproto.PrecommitType, blockHash, parts.Header())\n\tcs.mtx.Unlock()\n\n\tpeer.Send(VoteChannel, MustEncode(&VoteMessage{prevote}))\n\tpeer.Send(VoteChannel, MustEncode(&VoteMessage{precommit}))\n}\n\n//----------------------------------------\n// byzantine consensus reactor\n\ntype ByzantineReactor struct {\n\tservice.Service\n\treactor *Reactor\n}\n\nfunc NewByzantineReactor(conR *Reactor) *ByzantineReactor {\n\treturn &ByzantineReactor{\n\t\tService: conR,\n\t\treactor: conR,\n\t}\n}\n\nfunc (br *ByzantineReactor) SetSwitch(s *p2p.Switch)               { br.reactor.SetSwitch(s) }\nfunc (br *ByzantineReactor) GetChannels() []*p2p.ChannelDescriptor { return br.reactor.GetChannels() }\nfunc (br *ByzantineReactor) AddPeer(peer p2p.Peer) {\n\tif !br.reactor.IsRunning() {\n\t\treturn\n\t}\n\n\t// Create peerState for peer\n\tpeerState := NewPeerState(peer).SetLogger(br.reactor.Logger)\n\tpeer.Set(types.PeerStateKey, peerState)\n\n\t// Send our state to peer.\n\t// If we're syncing, broadcast a RoundStepMessage later upon SwitchToConsensus().\n\tif !br.reactor.waitSync {\n\t\tbr.reactor.sendNewRoundStepMessage(peer)\n\t}\n}\nfunc (br *ByzantineReactor) RemovePeer(peer p2p.Peer, reason interface{}) {\n\tbr.reactor.RemovePeer(peer, reason)\n}\nfunc (br *ByzantineReactor) Receive(chID byte, peer p2p.Peer, msgBytes []byte) {\n\tbr.reactor.Receive(chID, peer, msgBytes)\n}\nfunc (br *ByzantineReactor) InitPeer(peer p2p.Peer) p2p.Peer { return peer }\n", "package consensus\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"reflect\"\n\t\"runtime/debug\"\n\t\"time\"\n\n\t\"github.com/gogo/protobuf/proto\"\n\n\tcfg \"github.com/tendermint/tendermint/config\"\n\tcstypes \"github.com/tendermint/tendermint/consensus/types\"\n\t\"github.com/tendermint/tendermint/crypto\"\n\ttmevents \"github.com/tendermint/tendermint/libs/events\"\n\t\"github.com/tendermint/tendermint/libs/fail\"\n\ttmjson \"github.com/tendermint/tendermint/libs/json\"\n\t\"github.com/tendermint/tendermint/libs/log\"\n\ttmmath \"github.com/tendermint/tendermint/libs/math\"\n\ttmos \"github.com/tendermint/tendermint/libs/os\"\n\t\"github.com/tendermint/tendermint/libs/service\"\n\ttmsync \"github.com/tendermint/tendermint/libs/sync\"\n\t\"github.com/tendermint/tendermint/p2p\"\n\ttmproto \"github.com/tendermint/tendermint/proto/tendermint/types\"\n\tsm \"github.com/tendermint/tendermint/state\"\n\t\"github.com/tendermint/tendermint/types\"\n\ttmtime \"github.com/tendermint/tendermint/types/time\"\n)\n\n//-----------------------------------------------------------------------------\n// Errors\n\nvar (\n\tErrInvalidProposalSignature   = errors.New(\"error invalid proposal signature\")\n\tErrInvalidProposalPOLRound    = errors.New(\"error invalid proposal POL round\")\n\tErrAddingVote                 = errors.New(\"error adding vote\")\n\tErrSignatureFoundInPastBlocks = errors.New(\"found signature from the same key\")\n\n\terrPubKeyIsNotSet = errors.New(\"pubkey is not set. Look for \\\"Can't get private validator pubkey\\\" errors\")\n)\n\n//-----------------------------------------------------------------------------\n\nvar (\n\tmsgQueueSize = 1000\n)\n\n// msgs from the reactor which may update the state\ntype msgInfo struct {\n\tMsg    Message `json:\"msg\"`\n\tPeerID p2p.ID  `json:\"peer_key\"`\n}\n\n// internally generated messages which may update the state\ntype timeoutInfo struct {\n\tDuration time.Duration         `json:\"duration\"`\n\tHeight   int64                 `json:\"height\"`\n\tRound    int32                 `json:\"round\"`\n\tStep     cstypes.RoundStepType `json:\"step\"`\n}\n\nfunc (ti *timeoutInfo) String() string {\n\treturn fmt.Sprintf(\"%v ; %d/%d %v\", ti.Duration, ti.Height, ti.Round, ti.Step)\n}\n\n// interface to the mempool\ntype txNotifier interface {\n\tTxsAvailable() <-chan struct{}\n}\n\n// interface to the evidence pool\ntype evidencePool interface {\n\t// Adds consensus based evidence to the evidence pool. This function differs to\n\t// AddEvidence by bypassing verification and adding it immediately to the pool\n\tAddEvidenceFromConsensus(types.Evidence) error\n}\n\n// State handles execution of the consensus algorithm.\n// It processes votes and proposals, and upon reaching agreement,\n// commits blocks to the chain and executes them against the application.\n// The internal state machine receives input from peers, the internal validator, and from a timer.\ntype State struct {\n\tservice.BaseService\n\n\t// config details\n\tconfig        *cfg.ConsensusConfig\n\tprivValidator types.PrivValidator // for signing votes\n\n\t// store blocks and commits\n\tblockStore sm.BlockStore\n\n\t// create and execute blocks\n\tblockExec *sm.BlockExecutor\n\n\t// notify us if txs are available\n\ttxNotifier txNotifier\n\n\t// add evidence to the pool\n\t// when it's detected\n\tevpool evidencePool\n\n\t// internal state\n\tmtx tmsync.RWMutex\n\tcstypes.RoundState\n\tstate sm.State // State until height-1.\n\t// privValidator pubkey, memoized for the duration of one block\n\t// to avoid extra requests to HSM\n\tprivValidatorPubKey crypto.PubKey\n\n\t// state changes may be triggered by: msgs from peers,\n\t// msgs from ourself, or by timeouts\n\tpeerMsgQueue     chan msgInfo\n\tinternalMsgQueue chan msgInfo\n\ttimeoutTicker    TimeoutTicker\n\n\t// information about about added votes and block parts are written on this channel\n\t// so statistics can be computed by reactor\n\tstatsMsgQueue chan msgInfo\n\n\t// we use eventBus to trigger msg broadcasts in the reactor,\n\t// and to notify external subscribers, eg. through a websocket\n\teventBus *types.EventBus\n\n\t// a Write-Ahead Log ensures we can recover from any kind of crash\n\t// and helps us avoid signing conflicting votes\n\twal          WAL\n\treplayMode   bool // so we don't log signing errors during replay\n\tdoWALCatchup bool // determines if we even try to do the catchup\n\n\t// for tests where we want to limit the number of transitions the state makes\n\tnSteps int\n\n\t// some functions can be overwritten for testing\n\tdecideProposal func(height int64, round int32)\n\tdoPrevote      func(height int64, round int32)\n\tsetProposal    func(proposal *types.Proposal) error\n\n\t// closed when we finish shutting down\n\tdone chan struct{}\n\n\t// synchronous pubsub between consensus state and reactor.\n\t// state only emits EventNewRoundStep and EventVote\n\tevsw tmevents.EventSwitch\n\n\t// for reporting metrics\n\tmetrics *Metrics\n}\n\n// StateOption sets an optional parameter on the State.\ntype StateOption func(*State)\n\n// NewState returns a new State.\nfunc NewState(\n\tconfig *cfg.ConsensusConfig,\n\tstate sm.State,\n\tblockExec *sm.BlockExecutor,\n\tblockStore sm.BlockStore,\n\ttxNotifier txNotifier,\n\tevpool evidencePool,\n\toptions ...StateOption,\n) *State {\n\tcs := &State{\n\t\tconfig:           config,\n\t\tblockExec:        blockExec,\n\t\tblockStore:       blockStore,\n\t\ttxNotifier:       txNotifier,\n\t\tpeerMsgQueue:     make(chan msgInfo, msgQueueSize),\n\t\tinternalMsgQueue: make(chan msgInfo, msgQueueSize),\n\t\ttimeoutTicker:    NewTimeoutTicker(),\n\t\tstatsMsgQueue:    make(chan msgInfo, msgQueueSize),\n\t\tdone:             make(chan struct{}),\n\t\tdoWALCatchup:     true,\n\t\twal:              nilWAL{},\n\t\tevpool:           evpool,\n\t\tevsw:             tmevents.NewEventSwitch(),\n\t\tmetrics:          NopMetrics(),\n\t}\n\t// set function defaults (may be overwritten before calling Start)\n\tcs.decideProposal = cs.defaultDecideProposal\n\tcs.doPrevote = cs.defaultDoPrevote\n\tcs.setProposal = cs.defaultSetProposal\n\n\t// We have no votes, so reconstruct LastCommit from SeenCommit.\n\tif state.LastBlockHeight > 0 {\n\t\tcs.reconstructLastCommit(state)\n\t}\n\n\tcs.updateToState(state)\n\n\t// Don't call scheduleRound0 yet.\n\t// We do that upon Start().\n\n\tcs.BaseService = *service.NewBaseService(nil, \"State\", cs)\n\tfor _, option := range options {\n\t\toption(cs)\n\t}\n\treturn cs\n}\n\n//----------------------------------------\n// Public interface\n\n// SetLogger implements Service.\nfunc (cs *State) SetLogger(l log.Logger) {\n\tcs.BaseService.Logger = l\n\tcs.timeoutTicker.SetLogger(l)\n}\n\n// SetEventBus sets event bus.\nfunc (cs *State) SetEventBus(b *types.EventBus) {\n\tcs.eventBus = b\n\tcs.blockExec.SetEventBus(b)\n}\n\n// StateMetrics sets the metrics.\nfunc StateMetrics(metrics *Metrics) StateOption {\n\treturn func(cs *State) { cs.metrics = metrics }\n}\n\n// String returns a string.\nfunc (cs *State) String() string {\n\t// better not to access shared variables\n\treturn \"ConsensusState\"\n}\n\n// GetState returns a copy of the chain state.\nfunc (cs *State) GetState() sm.State {\n\tcs.mtx.RLock()\n\tdefer cs.mtx.RUnlock()\n\treturn cs.state.Copy()\n}\n\n// GetLastHeight returns the last height committed.\n// If there were no blocks, returns 0.\nfunc (cs *State) GetLastHeight() int64 {\n\tcs.mtx.RLock()\n\tdefer cs.mtx.RUnlock()\n\treturn cs.RoundState.Height - 1\n}\n\n// GetRoundState returns a shallow copy of the internal consensus state.\nfunc (cs *State) GetRoundState() *cstypes.RoundState {\n\tcs.mtx.RLock()\n\trs := cs.RoundState // copy\n\tcs.mtx.RUnlock()\n\treturn &rs\n}\n\n// GetRoundStateJSON returns a json of RoundState.\nfunc (cs *State) GetRoundStateJSON() ([]byte, error) {\n\tcs.mtx.RLock()\n\tdefer cs.mtx.RUnlock()\n\treturn tmjson.Marshal(cs.RoundState)\n}\n\n// GetRoundStateSimpleJSON returns a json of RoundStateSimple\nfunc (cs *State) GetRoundStateSimpleJSON() ([]byte, error) {\n\tcs.mtx.RLock()\n\tdefer cs.mtx.RUnlock()\n\treturn tmjson.Marshal(cs.RoundState.RoundStateSimple())\n}\n\n// GetValidators returns a copy of the current validators.\nfunc (cs *State) GetValidators() (int64, []*types.Validator) {\n\tcs.mtx.RLock()\n\tdefer cs.mtx.RUnlock()\n\treturn cs.state.LastBlockHeight, cs.state.Validators.Copy().Validators\n}\n\n// SetPrivValidator sets the private validator account for signing votes. It\n// immediately requests pubkey and caches it.\nfunc (cs *State) SetPrivValidator(priv types.PrivValidator) {\n\tcs.mtx.Lock()\n\tdefer cs.mtx.Unlock()\n\n\tcs.privValidator = priv\n\n\tif err := cs.updatePrivValidatorPubKey(); err != nil {\n\t\tcs.Logger.Error(\"Can't get private validator pubkey\", \"err\", err)\n\t}\n}\n\n// SetTimeoutTicker sets the local timer. It may be useful to overwrite for testing.\nfunc (cs *State) SetTimeoutTicker(timeoutTicker TimeoutTicker) {\n\tcs.mtx.Lock()\n\tcs.timeoutTicker = timeoutTicker\n\tcs.mtx.Unlock()\n}\n\n// LoadCommit loads the commit for a given height.\nfunc (cs *State) LoadCommit(height int64) *types.Commit {\n\tcs.mtx.RLock()\n\tdefer cs.mtx.RUnlock()\n\tif height == cs.blockStore.Height() {\n\t\treturn cs.blockStore.LoadSeenCommit(height)\n\t}\n\treturn cs.blockStore.LoadBlockCommit(height)\n}\n\n// OnStart loads the latest state via the WAL, and starts the timeout and\n// receive routines.\nfunc (cs *State) OnStart() error {\n\t// We may set the WAL in testing before calling Start, so only OpenWAL if its\n\t// still the nilWAL.\n\tif _, ok := cs.wal.(nilWAL); ok {\n\t\tif err := cs.loadWalFile(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// We may have lost some votes if the process crashed reload from consensus\n\t// log to catchup.\n\tif cs.doWALCatchup {\n\t\trepairAttempted := false\n\tLOOP:\n\t\tfor {\n\t\t\terr := cs.catchupReplay(cs.Height)\n\t\t\tswitch {\n\t\t\tcase err == nil:\n\t\t\t\tbreak LOOP\n\t\t\tcase !IsDataCorruptionError(err):\n\t\t\t\tcs.Logger.Error(\"Error on catchup replay. Proceeding to start State anyway\", \"err\", err)\n\t\t\t\tbreak LOOP\n\t\t\tcase repairAttempted:\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tcs.Logger.Error(\"WAL file is corrupted, attempting repair\", \"err\", err)\n\n\t\t\t// 1) prep work\n\t\t\tif err := cs.wal.Stop(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\trepairAttempted = true\n\n\t\t\t// 2) backup original WAL file\n\t\t\tcorruptedFile := fmt.Sprintf(\"%s.CORRUPTED\", cs.config.WalFile())\n\t\t\tif err := tmos.CopyFile(cs.config.WalFile(), corruptedFile); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcs.Logger.Info(\"Backed up WAL file\", \"src\", cs.config.WalFile(), \"dst\", corruptedFile)\n\n\t\t\t// 3) try to repair (WAL file will be overwritten!)\n\t\t\tif err := repairWalFile(corruptedFile, cs.config.WalFile()); err != nil {\n\t\t\t\tcs.Logger.Error(\"WAL repair failed\", \"err\", err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcs.Logger.Info(\"Successful repair\")\n\n\t\t\t// reload WAL file\n\t\t\tif err := cs.loadWalFile(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif err := cs.evsw.Start(); err != nil {\n\t\treturn err\n\t}\n\n\t// we need the timeoutRoutine for replay so\n\t// we don't block on the tick chan.\n\t// NOTE: we will get a build up of garbage go routines\n\t// firing on the tockChan until the receiveRoutine is started\n\t// to deal with them (by that point, at most one will be valid)\n\tif err := cs.timeoutTicker.Start(); err != nil {\n\t\treturn err\n\t}\n\n\t// Double Signing Risk Reduction\n\tif err := cs.checkDoubleSigningRisk(cs.Height); err != nil {\n\t\treturn err\n\t}\n\n\t// now start the receiveRoutine\n\tgo cs.receiveRoutine(0)\n\n\t// schedule the first round!\n\t// use GetRoundState so we don't race the receiveRoutine for access\n\tcs.scheduleRound0(cs.GetRoundState())\n\n\treturn nil\n}\n\n// timeoutRoutine: receive requests for timeouts on tickChan and fire timeouts on tockChan\n// receiveRoutine: serializes processing of proposoals, block parts, votes; coordinates state transitions\nfunc (cs *State) startRoutines(maxSteps int) {\n\terr := cs.timeoutTicker.Start()\n\tif err != nil {\n\t\tcs.Logger.Error(\"Error starting timeout ticker\", \"err\", err)\n\t\treturn\n\t}\n\tgo cs.receiveRoutine(maxSteps)\n}\n\n// loadWalFile loads WAL data from file. It overwrites cs.wal.\nfunc (cs *State) loadWalFile() error {\n\twal, err := cs.OpenWAL(cs.config.WalFile())\n\tif err != nil {\n\t\tcs.Logger.Error(\"Error loading State wal\", \"err\", err)\n\t\treturn err\n\t}\n\tcs.wal = wal\n\treturn nil\n}\n\n// OnStop implements service.Service.\nfunc (cs *State) OnStop() {\n\tif err := cs.evsw.Stop(); err != nil {\n\t\tcs.Logger.Error(\"error trying to stop eventSwitch\", \"error\", err)\n\t}\n\tif err := cs.timeoutTicker.Stop(); err != nil {\n\t\tcs.Logger.Error(\"error trying to stop timeoutTicket\", \"error\", err)\n\t}\n\t// WAL is stopped in receiveRoutine.\n}\n\n// Wait waits for the the main routine to return.\n// NOTE: be sure to Stop() the event switch and drain\n// any event channels or this may deadlock\nfunc (cs *State) Wait() {\n\t<-cs.done\n}\n\n// OpenWAL opens a file to log all consensus messages and timeouts for\n// deterministic accountability.\nfunc (cs *State) OpenWAL(walFile string) (WAL, error) {\n\twal, err := NewWAL(walFile)\n\tif err != nil {\n\t\tcs.Logger.Error(\"Failed to open WAL\", \"file\", walFile, \"err\", err)\n\t\treturn nil, err\n\t}\n\twal.SetLogger(cs.Logger.With(\"wal\", walFile))\n\tif err := wal.Start(); err != nil {\n\t\tcs.Logger.Error(\"Failed to start WAL\", \"err\", err)\n\t\treturn nil, err\n\t}\n\treturn wal, nil\n}\n\n//------------------------------------------------------------\n// Public interface for passing messages into the consensus state, possibly causing a state transition.\n// If peerID == \"\", the msg is considered internal.\n// Messages are added to the appropriate queue (peer or internal).\n// If the queue is full, the function may block.\n// TODO: should these return anything or let callers just use events?\n\n// AddVote inputs a vote.\nfunc (cs *State) AddVote(vote *types.Vote, peerID p2p.ID) (added bool, err error) {\n\tif peerID == \"\" {\n\t\tcs.internalMsgQueue <- msgInfo{&VoteMessage{vote}, \"\"}\n\t} else {\n\t\tcs.peerMsgQueue <- msgInfo{&VoteMessage{vote}, peerID}\n\t}\n\n\t// TODO: wait for event?!\n\treturn false, nil\n}\n\n// SetProposal inputs a proposal.\nfunc (cs *State) SetProposal(proposal *types.Proposal, peerID p2p.ID) error {\n\n\tif peerID == \"\" {\n\t\tcs.internalMsgQueue <- msgInfo{&ProposalMessage{proposal}, \"\"}\n\t} else {\n\t\tcs.peerMsgQueue <- msgInfo{&ProposalMessage{proposal}, peerID}\n\t}\n\n\t// TODO: wait for event?!\n\treturn nil\n}\n\n// AddProposalBlockPart inputs a part of the proposal block.\nfunc (cs *State) AddProposalBlockPart(height int64, round int32, part *types.Part, peerID p2p.ID) error {\n\n\tif peerID == \"\" {\n\t\tcs.internalMsgQueue <- msgInfo{&BlockPartMessage{height, round, part}, \"\"}\n\t} else {\n\t\tcs.peerMsgQueue <- msgInfo{&BlockPartMessage{height, round, part}, peerID}\n\t}\n\n\t// TODO: wait for event?!\n\treturn nil\n}\n\n// SetProposalAndBlock inputs the proposal and all block parts.\nfunc (cs *State) SetProposalAndBlock(\n\tproposal *types.Proposal,\n\tblock *types.Block,\n\tparts *types.PartSet,\n\tpeerID p2p.ID,\n) error {\n\tif err := cs.SetProposal(proposal, peerID); err != nil {\n\t\treturn err\n\t}\n\tfor i := 0; i < int(parts.Total()); i++ {\n\t\tpart := parts.GetPart(i)\n\t\tif err := cs.AddProposalBlockPart(proposal.Height, proposal.Round, part, peerID); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n//------------------------------------------------------------\n// internal functions for managing the state\n\nfunc (cs *State) updateHeight(height int64) {\n\tcs.metrics.Height.Set(float64(height))\n\tcs.Height = height\n}\n\nfunc (cs *State) updateRoundStep(round int32, step cstypes.RoundStepType) {\n\tcs.Round = round\n\tcs.Step = step\n}\n\n// enterNewRound(height, 0) at cs.StartTime.\nfunc (cs *State) scheduleRound0(rs *cstypes.RoundState) {\n\t// cs.Logger.Info(\"scheduleRound0\", \"now\", tmtime.Now(), \"startTime\", cs.StartTime)\n\tsleepDuration := rs.StartTime.Sub(tmtime.Now())\n\tcs.scheduleTimeout(sleepDuration, rs.Height, 0, cstypes.RoundStepNewHeight)\n}\n\n// Attempt to schedule a timeout (by sending timeoutInfo on the tickChan)\nfunc (cs *State) scheduleTimeout(duration time.Duration, height int64, round int32, step cstypes.RoundStepType) {\n\tcs.timeoutTicker.ScheduleTimeout(timeoutInfo{duration, height, round, step})\n}\n\n// send a msg into the receiveRoutine regarding our own proposal, block part, or vote\nfunc (cs *State) sendInternalMessage(mi msgInfo) {\n\tselect {\n\tcase cs.internalMsgQueue <- mi:\n\tdefault:\n\t\t// NOTE: using the go-routine means our votes can\n\t\t// be processed out of order.\n\t\t// TODO: use CList here for strict determinism and\n\t\t// attempt push to internalMsgQueue in receiveRoutine\n\t\tcs.Logger.Info(\"Internal msg queue is full. Using a go-routine\")\n\t\tgo func() { cs.internalMsgQueue <- mi }()\n\t}\n}\n\n// Reconstruct LastCommit from SeenCommit, which we saved along with the block,\n// (which happens even before saving the state)\nfunc (cs *State) reconstructLastCommit(state sm.State) {\n\tseenCommit := cs.blockStore.LoadSeenCommit(state.LastBlockHeight)\n\tif seenCommit == nil {\n\t\tpanic(fmt.Sprintf(\"Failed to reconstruct LastCommit: seen commit for height %v not found\",\n\t\t\tstate.LastBlockHeight))\n\t}\n\n\tlastPrecommits := types.CommitToVoteSet(state.ChainID, seenCommit, state.LastValidators)\n\tif !lastPrecommits.HasTwoThirdsMajority() {\n\t\tpanic(\"Failed to reconstruct LastCommit: Does not have +2/3 maj\")\n\t}\n\n\tcs.LastCommit = lastPrecommits\n}\n\n// Updates State and increments height to match that of state.\n// The round becomes 0 and cs.Step becomes cstypes.RoundStepNewHeight.\nfunc (cs *State) updateToState(state sm.State) {\n\tif cs.CommitRound > -1 && 0 < cs.Height && cs.Height != state.LastBlockHeight {\n\t\tpanic(fmt.Sprintf(\"updateToState() expected state height of %v but found %v\",\n\t\t\tcs.Height, state.LastBlockHeight))\n\t}\n\tif !cs.state.IsEmpty() {\n\t\tif cs.state.LastBlockHeight > 0 && cs.state.LastBlockHeight+1 != cs.Height {\n\t\t\t// This might happen when someone else is mutating cs.state.\n\t\t\t// Someone forgot to pass in state.Copy() somewhere?!\n\t\t\tpanic(fmt.Sprintf(\"Inconsistent cs.state.LastBlockHeight+1 %v vs cs.Height %v\",\n\t\t\t\tcs.state.LastBlockHeight+1, cs.Height))\n\t\t}\n\t\tif cs.state.LastBlockHeight > 0 && cs.Height == cs.state.InitialHeight {\n\t\t\tpanic(fmt.Sprintf(\"Inconsistent cs.state.LastBlockHeight %v, expected 0 for initial height %v\",\n\t\t\t\tcs.state.LastBlockHeight, cs.state.InitialHeight))\n\t\t}\n\n\t\t// If state isn't further out than cs.state, just ignore.\n\t\t// This happens when SwitchToConsensus() is called in the reactor.\n\t\t// We don't want to reset e.g. the Votes, but we still want to\n\t\t// signal the new round step, because other services (eg. txNotifier)\n\t\t// depend on having an up-to-date peer state!\n\t\tif state.LastBlockHeight <= cs.state.LastBlockHeight {\n\t\t\tcs.Logger.Info(\n\t\t\t\t\"Ignoring updateToState()\",\n\t\t\t\t\"newHeight\",\n\t\t\t\tstate.LastBlockHeight+1,\n\t\t\t\t\"oldHeight\",\n\t\t\t\tcs.state.LastBlockHeight+1)\n\t\t\tcs.newStep()\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Reset fields based on state.\n\tvalidators := state.Validators\n\n\tswitch {\n\tcase state.LastBlockHeight == 0: // Very first commit should be empty.\n\t\tcs.LastCommit = (*types.VoteSet)(nil)\n\tcase cs.CommitRound > -1 && cs.Votes != nil: // Otherwise, use cs.Votes\n\t\tif !cs.Votes.Precommits(cs.CommitRound).HasTwoThirdsMajority() {\n\t\t\tpanic(fmt.Sprintf(\"Wanted to form a Commit, but Precommits (H/R: %d/%d) didn't have 2/3+: %v\",\n\t\t\t\tstate.LastBlockHeight,\n\t\t\t\tcs.CommitRound,\n\t\t\t\tcs.Votes.Precommits(cs.CommitRound)))\n\t\t}\n\t\tcs.LastCommit = cs.Votes.Precommits(cs.CommitRound)\n\tcase cs.LastCommit == nil:\n\t\t// NOTE: when Tendermint starts, it has no votes. reconstructLastCommit\n\t\t// must be called to reconstruct LastCommit from SeenCommit.\n\t\tpanic(fmt.Sprintf(\"LastCommit cannot be empty after initial block (H:%d)\",\n\t\t\tstate.LastBlockHeight+1,\n\t\t))\n\t}\n\n\t// Next desired block height\n\theight := state.LastBlockHeight + 1\n\tif height == 1 {\n\t\theight = state.InitialHeight\n\t}\n\n\t// RoundState fields\n\tcs.updateHeight(height)\n\tcs.updateRoundStep(0, cstypes.RoundStepNewHeight)\n\tif cs.CommitTime.IsZero() {\n\t\t// \"Now\" makes it easier to sync up dev nodes.\n\t\t// We add timeoutCommit to allow transactions\n\t\t// to be gathered for the first block.\n\t\t// And alternative solution that relies on clocks:\n\t\t// cs.StartTime = state.LastBlockTime.Add(timeoutCommit)\n\t\tcs.StartTime = cs.config.Commit(tmtime.Now())\n\t} else {\n\t\tcs.StartTime = cs.config.Commit(cs.CommitTime)\n\t}\n\n\tcs.Validators = validators\n\tcs.Proposal = nil\n\tcs.ProposalBlock = nil\n\tcs.ProposalBlockParts = nil\n\tcs.LockedRound = -1\n\tcs.LockedBlock = nil\n\tcs.LockedBlockParts = nil\n\tcs.ValidRound = -1\n\tcs.ValidBlock = nil\n\tcs.ValidBlockParts = nil\n\tcs.Votes = cstypes.NewHeightVoteSet(state.ChainID, height, validators)\n\tcs.CommitRound = -1\n\tcs.LastValidators = state.LastValidators\n\tcs.TriggeredTimeoutPrecommit = false\n\n\tcs.state = state\n\n\t// Finally, broadcast RoundState\n\tcs.newStep()\n}\n\nfunc (cs *State) newStep() {\n\trs := cs.RoundStateEvent()\n\tif err := cs.wal.Write(rs); err != nil {\n\t\tcs.Logger.Error(\"Error writing to wal\", \"err\", err)\n\t}\n\tcs.nSteps++\n\t// newStep is called by updateToState in NewState before the eventBus is set!\n\tif cs.eventBus != nil {\n\t\tif err := cs.eventBus.PublishEventNewRoundStep(rs); err != nil {\n\t\t\tcs.Logger.Error(\"Error publishing new round step\", \"err\", err)\n\t\t}\n\t\tcs.evsw.FireEvent(types.EventNewRoundStep, &cs.RoundState)\n\t}\n}\n\n//-----------------------------------------\n// the main go routines\n\n// receiveRoutine handles messages which may cause state transitions.\n// it's argument (n) is the number of messages to process before exiting - use 0 to run forever\n// It keeps the RoundState and is the only thing that updates it.\n// Updates (state transitions) happen on timeouts, complete proposals, and 2/3 majorities.\n// State must be locked before any internal state is updated.\nfunc (cs *State) receiveRoutine(maxSteps int) {\n\tonExit := func(cs *State) {\n\t\t// NOTE: the internalMsgQueue may have signed messages from our\n\t\t// priv_val that haven't hit the WAL, but its ok because\n\t\t// priv_val tracks LastSig\n\n\t\t// close wal now that we're done writing to it\n\t\tif err := cs.wal.Stop(); err != nil {\n\t\t\tcs.Logger.Error(\"error trying to stop wal\", \"error\", err)\n\t\t}\n\t\tcs.wal.Wait()\n\n\t\tclose(cs.done)\n\t}\n\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tcs.Logger.Error(\"CONSENSUS FAILURE!!!\", \"err\", r, \"stack\", string(debug.Stack()))\n\t\t\t// stop gracefully\n\t\t\t//\n\t\t\t// NOTE: We most probably shouldn't be running any further when there is\n\t\t\t// some unexpected panic. Some unknown error happened, and so we don't\n\t\t\t// know if that will result in the validator signing an invalid thing. It\n\t\t\t// might be worthwhile to explore a mechanism for manual resuming via\n\t\t\t// some console or secure RPC system, but for now, halting the chain upon\n\t\t\t// unexpected consensus bugs sounds like the better option.\n\t\t\tonExit(cs)\n\t\t}\n\t}()\n\n\tfor {\n\t\tif maxSteps > 0 {\n\t\t\tif cs.nSteps >= maxSteps {\n\t\t\t\tcs.Logger.Info(\"reached max steps. exiting receive routine\")\n\t\t\t\tcs.nSteps = 0\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\trs := cs.RoundState\n\t\tvar mi msgInfo\n\n\t\tselect {\n\t\tcase <-cs.txNotifier.TxsAvailable():\n\t\t\tcs.handleTxsAvailable()\n\t\tcase mi = <-cs.peerMsgQueue:\n\t\t\tif err := cs.wal.Write(mi); err != nil {\n\t\t\t\tcs.Logger.Error(\"Error writing to wal\", \"err\", err)\n\t\t\t}\n\t\t\t// handles proposals, block parts, votes\n\t\t\t// may generate internal events (votes, complete proposals, 2/3 majorities)\n\t\t\tcs.handleMsg(mi)\n\t\tcase mi = <-cs.internalMsgQueue:\n\t\t\terr := cs.wal.WriteSync(mi) // NOTE: fsync\n\t\t\tif err != nil {\n\t\t\t\tpanic(fmt.Sprintf(\"Failed to write %v msg to consensus wal due to %v. Check your FS and restart the node\", mi, err))\n\t\t\t}\n\n\t\t\tif _, ok := mi.Msg.(*VoteMessage); ok {\n\t\t\t\t// we actually want to simulate failing during\n\t\t\t\t// the previous WriteSync, but this isn't easy to do.\n\t\t\t\t// Equivalent would be to fail here and manually remove\n\t\t\t\t// some bytes from the end of the wal.\n\t\t\t\tfail.Fail() // XXX\n\t\t\t}\n\n\t\t\t// handles proposals, block parts, votes\n\t\t\tcs.handleMsg(mi)\n\t\tcase ti := <-cs.timeoutTicker.Chan(): // tockChan:\n\t\t\tif err := cs.wal.Write(ti); err != nil {\n\t\t\t\tcs.Logger.Error(\"Error writing to wal\", \"err\", err)\n\t\t\t}\n\t\t\t// if the timeout is relevant to the rs\n\t\t\t// go to the next step\n\t\t\tcs.handleTimeout(ti, rs)\n\t\tcase <-cs.Quit():\n\t\t\tonExit(cs)\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// state transitions on complete-proposal, 2/3-any, 2/3-one\nfunc (cs *State) handleMsg(mi msgInfo) {\n\tcs.mtx.Lock()\n\tdefer cs.mtx.Unlock()\n\n\tvar (\n\t\tadded bool\n\t\terr   error\n\t)\n\tmsg, peerID := mi.Msg, mi.PeerID\n\tswitch msg := msg.(type) {\n\tcase *ProposalMessage:\n\t\t// will not cause transition.\n\t\t// once proposal is set, we can receive block parts\n\t\terr = cs.setProposal(msg.Proposal)\n\tcase *BlockPartMessage:\n\t\t// if the proposal is complete, we'll enterPrevote or tryFinalizeCommit\n\t\tadded, err = cs.addProposalBlockPart(msg, peerID)\n\t\tif added {\n\t\t\tcs.statsMsgQueue <- mi\n\t\t}\n\n\t\tif err != nil && msg.Round != cs.Round {\n\t\t\tcs.Logger.Debug(\n\t\t\t\t\"Received block part from wrong round\",\n\t\t\t\t\"height\",\n\t\t\t\tcs.Height,\n\t\t\t\t\"csRound\",\n\t\t\t\tcs.Round,\n\t\t\t\t\"blockRound\",\n\t\t\t\tmsg.Round)\n\t\t\terr = nil\n\t\t}\n\tcase *VoteMessage:\n\t\t// attempt to add the vote and dupeout the validator if its a duplicate signature\n\t\t// if the vote gives us a 2/3-any or 2/3-one, we transition\n\t\tadded, err = cs.tryAddVote(msg.Vote, peerID)\n\t\tif added {\n\t\t\tcs.statsMsgQueue <- mi\n\t\t}\n\n\t\t// if err == ErrAddingVote {\n\t\t// TODO: punish peer\n\t\t// We probably don't want to stop the peer here. The vote does not\n\t\t// necessarily comes from a malicious peer but can be just broadcasted by\n\t\t// a typical peer.\n\t\t// https://github.com/tendermint/tendermint/issues/1281\n\t\t// }\n\n\t\t// NOTE: the vote is broadcast to peers by the reactor listening\n\t\t// for vote events\n\n\t\t// TODO: If rs.Height == vote.Height && rs.Round < vote.Round,\n\t\t// the peer is sending us CatchupCommit precommits.\n\t\t// We could make note of this and help filter in broadcastHasVoteMessage().\n\tdefault:\n\t\tcs.Logger.Error(\"Unknown msg type\", \"type\", reflect.TypeOf(msg))\n\t\treturn\n\t}\n\n\tif err != nil {\n\t\tcs.Logger.Error(\"Error with msg\", \"height\", cs.Height, \"round\", cs.Round,\n\t\t\t\"peer\", peerID, \"err\", err, \"msg\", msg)\n\t}\n}\n\nfunc (cs *State) handleTimeout(ti timeoutInfo, rs cstypes.RoundState) {\n\tcs.Logger.Debug(\"Received tock\", \"timeout\", ti.Duration, \"height\", ti.Height, \"round\", ti.Round, \"step\", ti.Step)\n\n\t// timeouts must be for current height, round, step\n\tif ti.Height != rs.Height || ti.Round < rs.Round || (ti.Round == rs.Round && ti.Step < rs.Step) {\n\t\tcs.Logger.Debug(\"Ignoring tock because we're ahead\", \"height\", rs.Height, \"round\", rs.Round, \"step\", rs.Step)\n\t\treturn\n\t}\n\n\t// the timeout will now cause a state transition\n\tcs.mtx.Lock()\n\tdefer cs.mtx.Unlock()\n\n\tswitch ti.Step {\n\tcase cstypes.RoundStepNewHeight:\n\t\t// NewRound event fired from enterNewRound.\n\t\t// XXX: should we fire timeout here (for timeout commit)?\n\t\tcs.enterNewRound(ti.Height, 0)\n\tcase cstypes.RoundStepNewRound:\n\t\tcs.enterPropose(ti.Height, 0)\n\tcase cstypes.RoundStepPropose:\n\t\tif err := cs.eventBus.PublishEventTimeoutPropose(cs.RoundStateEvent()); err != nil {\n\t\t\tcs.Logger.Error(\"Error publishing timeout propose\", \"err\", err)\n\t\t}\n\t\tcs.enterPrevote(ti.Height, ti.Round)\n\tcase cstypes.RoundStepPrevoteWait:\n\t\tif err := cs.eventBus.PublishEventTimeoutWait(cs.RoundStateEvent()); err != nil {\n\t\t\tcs.Logger.Error(\"Error publishing timeout wait\", \"err\", err)\n\t\t}\n\t\tcs.enterPrecommit(ti.Height, ti.Round)\n\tcase cstypes.RoundStepPrecommitWait:\n\t\tif err := cs.eventBus.PublishEventTimeoutWait(cs.RoundStateEvent()); err != nil {\n\t\t\tcs.Logger.Error(\"Error publishing timeout wait\", \"err\", err)\n\t\t}\n\t\tcs.enterPrecommit(ti.Height, ti.Round)\n\t\tcs.enterNewRound(ti.Height, ti.Round+1)\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"Invalid timeout step: %v\", ti.Step))\n\t}\n\n}\n\nfunc (cs *State) handleTxsAvailable() {\n\tcs.mtx.Lock()\n\tdefer cs.mtx.Unlock()\n\n\t// We only need to do this for round 0.\n\tif cs.Round != 0 {\n\t\treturn\n\t}\n\n\tswitch cs.Step {\n\tcase cstypes.RoundStepNewHeight: // timeoutCommit phase\n\t\tif cs.needProofBlock(cs.Height) {\n\t\t\t// enterPropose will be called by enterNewRound\n\t\t\treturn\n\t\t}\n\n\t\t// +1ms to ensure RoundStepNewRound timeout always happens after RoundStepNewHeight\n\t\ttimeoutCommit := cs.StartTime.Sub(tmtime.Now()) + 1*time.Millisecond\n\t\tcs.scheduleTimeout(timeoutCommit, cs.Height, 0, cstypes.RoundStepNewRound)\n\tcase cstypes.RoundStepNewRound: // after timeoutCommit\n\t\tcs.enterPropose(cs.Height, 0)\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// State functions\n// Used internally by handleTimeout and handleMsg to make state transitions\n\n// Enter: `timeoutNewHeight` by startTime (commitTime+timeoutCommit),\n// \tor, if SkipTimeoutCommit==true, after receiving all precommits from (height,round-1)\n// Enter: `timeoutPrecommits` after any +2/3 precommits from (height,round-1)\n// Enter: +2/3 precommits for nil at (height,round-1)\n// Enter: +2/3 prevotes any or +2/3 precommits for block or any from (height, round)\n// NOTE: cs.StartTime was already set for height.\nfunc (cs *State) enterNewRound(height int64, round int32) {\n\tlogger := cs.Logger.With(\"height\", height, \"round\", round)\n\n\tif cs.Height != height || round < cs.Round || (cs.Round == round && cs.Step != cstypes.RoundStepNewHeight) {\n\t\tlogger.Debug(fmt.Sprintf(\n\t\t\t\"enterNewRound(%v/%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tround,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\n\tif now := tmtime.Now(); cs.StartTime.After(now) {\n\t\tlogger.Info(\"Need to set a buffer and log message here for sanity.\", \"startTime\", cs.StartTime, \"now\", now)\n\t}\n\n\tlogger.Info(fmt.Sprintf(\"enterNewRound(%v/%v). Current: %v/%v/%v\", height, round, cs.Height, cs.Round, cs.Step))\n\n\t// Increment validators if necessary\n\tvalidators := cs.Validators\n\tif cs.Round < round {\n\t\tvalidators = validators.Copy()\n\t\tvalidators.IncrementProposerPriority(tmmath.SafeSubInt32(round, cs.Round))\n\t}\n\n\t// Setup new round\n\t// we don't fire newStep for this step,\n\t// but we fire an event, so update the round step first\n\tcs.updateRoundStep(round, cstypes.RoundStepNewRound)\n\tcs.Validators = validators\n\tif round == 0 {\n\t\t// We've already reset these upon new height,\n\t\t// and meanwhile we might have received a proposal\n\t\t// for round 0.\n\t} else {\n\t\tlogger.Info(\"Resetting Proposal info\")\n\t\tcs.Proposal = nil\n\t\tcs.ProposalBlock = nil\n\t\tcs.ProposalBlockParts = nil\n\t}\n\tcs.Votes.SetRound(tmmath.SafeAddInt32(round, 1)) // also track next round (round+1) to allow round-skipping\n\tcs.TriggeredTimeoutPrecommit = false\n\n\tif err := cs.eventBus.PublishEventNewRound(cs.NewRoundEvent()); err != nil {\n\t\tcs.Logger.Error(\"Error publishing new round\", \"err\", err)\n\t}\n\tcs.metrics.Rounds.Set(float64(round))\n\n\t// Wait for txs to be available in the mempool\n\t// before we enterPropose in round 0. If the last block changed the app hash,\n\t// we may need an empty \"proof\" block, and enterPropose immediately.\n\twaitForTxs := cs.config.WaitForTxs() && round == 0 && !cs.needProofBlock(height)\n\tif waitForTxs {\n\t\tif cs.config.CreateEmptyBlocksInterval > 0 {\n\t\t\tcs.scheduleTimeout(cs.config.CreateEmptyBlocksInterval, height, round,\n\t\t\t\tcstypes.RoundStepNewRound)\n\t\t}\n\t} else {\n\t\tcs.enterPropose(height, round)\n\t}\n}\n\n// needProofBlock returns true on the first height (so the genesis app hash is signed right away)\n// and where the last block (height-1) caused the app hash to change\nfunc (cs *State) needProofBlock(height int64) bool {\n\tif height == cs.state.InitialHeight {\n\t\treturn true\n\t}\n\n\tlastBlockMeta := cs.blockStore.LoadBlockMeta(height - 1)\n\tif lastBlockMeta == nil {\n\t\tpanic(fmt.Sprintf(\"needProofBlock: last block meta for height %d not found\", height-1))\n\t}\n\treturn !bytes.Equal(cs.state.AppHash, lastBlockMeta.Header.AppHash)\n}\n\n// Enter (CreateEmptyBlocks): from enterNewRound(height,round)\n// Enter (CreateEmptyBlocks, CreateEmptyBlocksInterval > 0 ):\n// \t\tafter enterNewRound(height,round), after timeout of CreateEmptyBlocksInterval\n// Enter (!CreateEmptyBlocks) : after enterNewRound(height,round), once txs are in the mempool\nfunc (cs *State) enterPropose(height int64, round int32) {\n\tlogger := cs.Logger.With(\"height\", height, \"round\", round)\n\n\tif cs.Height != height || round < cs.Round || (cs.Round == round && cstypes.RoundStepPropose <= cs.Step) {\n\t\tlogger.Debug(fmt.Sprintf(\n\t\t\t\"enterPropose(%v/%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tround,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\tlogger.Info(fmt.Sprintf(\"enterPropose(%v/%v). Current: %v/%v/%v\", height, round, cs.Height, cs.Round, cs.Step))\n\n\tdefer func() {\n\t\t// Done enterPropose:\n\t\tcs.updateRoundStep(round, cstypes.RoundStepPropose)\n\t\tcs.newStep()\n\n\t\t// If we have the whole proposal + POL, then goto Prevote now.\n\t\t// else, we'll enterPrevote when the rest of the proposal is received (in AddProposalBlockPart),\n\t\t// or else after timeoutPropose\n\t\tif cs.isProposalComplete() {\n\t\t\tcs.enterPrevote(height, cs.Round)\n\t\t}\n\t}()\n\n\t// If we don't get the proposal and all block parts quick enough, enterPrevote\n\tcs.scheduleTimeout(cs.config.Propose(round), height, round, cstypes.RoundStepPropose)\n\n\t// Nothing more to do if we're not a validator\n\tif cs.privValidator == nil {\n\t\tlogger.Debug(\"This node is not a validator\")\n\t\treturn\n\t}\n\tlogger.Debug(\"This node is a validator\")\n\n\tif cs.privValidatorPubKey == nil {\n\t\t// If this node is a validator & proposer in the current round, it will\n\t\t// miss the opportunity to create a block.\n\t\tlogger.Error(fmt.Sprintf(\"enterPropose: %v\", errPubKeyIsNotSet))\n\t\treturn\n\t}\n\taddress := cs.privValidatorPubKey.Address()\n\n\t// if not a validator, we're done\n\tif !cs.Validators.HasAddress(address) {\n\t\tlogger.Debug(\"This node is not a validator\", \"addr\", address, \"vals\", cs.Validators)\n\t\treturn\n\t}\n\n\tif cs.isProposer(address) {\n\t\tlogger.Info(\"enterPropose: Our turn to propose\",\n\t\t\t\"proposer\",\n\t\t\taddress,\n\t\t\t\"privValidator\",\n\t\t\tcs.privValidator)\n\t\tcs.decideProposal(height, round)\n\t} else {\n\t\tlogger.Info(\"enterPropose: Not our turn to propose\",\n\t\t\t\"proposer\",\n\t\t\tcs.Validators.GetProposer().Address,\n\t\t\t\"privValidator\",\n\t\t\tcs.privValidator)\n\t}\n}\n\nfunc (cs *State) isProposer(address []byte) bool {\n\treturn bytes.Equal(cs.Validators.GetProposer().Address, address)\n}\n\nfunc (cs *State) defaultDecideProposal(height int64, round int32) {\n\tvar block *types.Block\n\tvar blockParts *types.PartSet\n\n\t// Decide on block\n\tif cs.ValidBlock != nil {\n\t\t// If there is valid block, choose that.\n\t\tblock, blockParts = cs.ValidBlock, cs.ValidBlockParts\n\t} else {\n\t\t// Create a new proposal block from state/txs from the mempool.\n\t\tblock, blockParts = cs.createProposalBlock()\n\t\tif block == nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Flush the WAL. Otherwise, we may not recompute the same proposal to sign,\n\t// and the privValidator will refuse to sign anything.\n\tif err := cs.wal.FlushAndSync(); err != nil {\n\t\tcs.Logger.Error(\"Error flushing to disk\")\n\t}\n\n\t// Make proposal\n\tpropBlockID := types.BlockID{Hash: block.Hash(), PartSetHeader: blockParts.Header()}\n\tproposal := types.NewProposal(height, round, cs.ValidRound, propBlockID)\n\tp := proposal.ToProto()\n\tif err := cs.privValidator.SignProposal(cs.state.ChainID, p); err == nil {\n\t\tproposal.Signature = p.Signature\n\n\t\t// send proposal and block parts on internal msg queue\n\t\tcs.sendInternalMessage(msgInfo{&ProposalMessage{proposal}, \"\"})\n\t\tfor i := 0; i < int(blockParts.Total()); i++ {\n\t\t\tpart := blockParts.GetPart(i)\n\t\t\tcs.sendInternalMessage(msgInfo{&BlockPartMessage{cs.Height, cs.Round, part}, \"\"})\n\t\t}\n\t\tcs.Logger.Info(\"Signed proposal\", \"height\", height, \"round\", round, \"proposal\", proposal)\n\t\tcs.Logger.Debug(fmt.Sprintf(\"Signed proposal block: %v\", block))\n\t} else if !cs.replayMode {\n\t\tcs.Logger.Error(\"enterPropose: Error signing proposal\", \"height\", height, \"round\", round, \"err\", err)\n\t}\n}\n\n// Returns true if the proposal block is complete &&\n// (if POLRound was proposed, we have +2/3 prevotes from there).\nfunc (cs *State) isProposalComplete() bool {\n\tif cs.Proposal == nil || cs.ProposalBlock == nil {\n\t\treturn false\n\t}\n\t// we have the proposal. if there's a POLRound,\n\t// make sure we have the prevotes from it too\n\tif cs.Proposal.POLRound < 0 {\n\t\treturn true\n\t}\n\t// if this is false the proposer is lying or we haven't received the POL yet\n\treturn cs.Votes.Prevotes(cs.Proposal.POLRound).HasTwoThirdsMajority()\n\n}\n\n// Create the next block to propose and return it. Returns nil block upon error.\n//\n// We really only need to return the parts, but the block is returned for\n// convenience so we can log the proposal block.\n//\n// NOTE: keep it side-effect free for clarity.\n// CONTRACT: cs.privValidator is not nil.\nfunc (cs *State) createProposalBlock() (block *types.Block, blockParts *types.PartSet) {\n\tif cs.privValidator == nil {\n\t\tpanic(\"entered createProposalBlock with privValidator being nil\")\n\t}\n\n\tvar commit *types.Commit\n\tswitch {\n\tcase cs.Height == cs.state.InitialHeight:\n\t\t// We're creating a proposal for the first block.\n\t\t// The commit is empty, but not nil.\n\t\tcommit = types.NewCommit(0, 0, types.BlockID{}, nil)\n\tcase cs.LastCommit.HasTwoThirdsMajority():\n\t\t// Make the commit from LastCommit\n\t\tcommit = cs.LastCommit.MakeCommit()\n\tdefault: // This shouldn't happen.\n\t\tcs.Logger.Error(\"enterPropose: Cannot propose anything: No commit for the previous block\")\n\t\treturn\n\t}\n\n\tif cs.privValidatorPubKey == nil {\n\t\t// If this node is a validator & proposer in the current round, it will\n\t\t// miss the opportunity to create a block.\n\t\tcs.Logger.Error(fmt.Sprintf(\"enterPropose: %v\", errPubKeyIsNotSet))\n\t\treturn\n\t}\n\tproposerAddr := cs.privValidatorPubKey.Address()\n\n\treturn cs.blockExec.CreateProposalBlock(cs.Height, cs.state, commit, proposerAddr)\n}\n\n// Enter: `timeoutPropose` after entering Propose.\n// Enter: proposal block and POL is ready.\n// Prevote for LockedBlock if we're locked, or ProposalBlock if valid.\n// Otherwise vote nil.\nfunc (cs *State) enterPrevote(height int64, round int32) {\n\tif cs.Height != height || round < cs.Round || (cs.Round == round && cstypes.RoundStepPrevote <= cs.Step) {\n\t\tcs.Logger.Debug(fmt.Sprintf(\n\t\t\t\"enterPrevote(%v/%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tround,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\n\tdefer func() {\n\t\t// Done enterPrevote:\n\t\tcs.updateRoundStep(round, cstypes.RoundStepPrevote)\n\t\tcs.newStep()\n\t}()\n\n\tcs.Logger.Info(fmt.Sprintf(\"enterPrevote(%v/%v). Current: %v/%v/%v\", height, round, cs.Height, cs.Round, cs.Step))\n\n\t// Sign and broadcast vote as necessary\n\tcs.doPrevote(height, round)\n\n\t// Once `addVote` hits any +2/3 prevotes, we will go to PrevoteWait\n\t// (so we have more time to try and collect +2/3 prevotes for a single block)\n}\n\nfunc (cs *State) defaultDoPrevote(height int64, round int32) {\n\tlogger := cs.Logger.With(\"height\", height, \"round\", round)\n\n\t// If a block is locked, prevote that.\n\tif cs.LockedBlock != nil {\n\t\tlogger.Info(\"enterPrevote: Already locked on a block, prevoting locked block\")\n\t\tcs.signAddVote(tmproto.PrevoteType, cs.LockedBlock.Hash(), cs.LockedBlockParts.Header())\n\t\treturn\n\t}\n\n\t// If ProposalBlock is nil, prevote nil.\n\tif cs.ProposalBlock == nil {\n\t\tlogger.Info(\"enterPrevote: ProposalBlock is nil\")\n\t\tcs.signAddVote(tmproto.PrevoteType, nil, types.PartSetHeader{})\n\t\treturn\n\t}\n\n\t// Validate proposal block\n\terr := cs.blockExec.ValidateBlock(cs.state, cs.ProposalBlock)\n\tif err != nil {\n\t\t// ProposalBlock is invalid, prevote nil.\n\t\tlogger.Error(\"enterPrevote: ProposalBlock is invalid\", \"err\", err)\n\t\tcs.signAddVote(tmproto.PrevoteType, nil, types.PartSetHeader{})\n\t\treturn\n\t}\n\n\t// Prevote cs.ProposalBlock\n\t// NOTE: the proposal signature is validated when it is received,\n\t// and the proposal block parts are validated as they are received (against the merkle hash in the proposal)\n\tlogger.Info(\"enterPrevote: ProposalBlock is valid\")\n\tcs.signAddVote(tmproto.PrevoteType, cs.ProposalBlock.Hash(), cs.ProposalBlockParts.Header())\n}\n\n// Enter: any +2/3 prevotes at next round.\nfunc (cs *State) enterPrevoteWait(height int64, round int32) {\n\tlogger := cs.Logger.With(\"height\", height, \"round\", round)\n\n\tif cs.Height != height || round < cs.Round || (cs.Round == round && cstypes.RoundStepPrevoteWait <= cs.Step) {\n\t\tlogger.Debug(fmt.Sprintf(\n\t\t\t\"enterPrevoteWait(%v/%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tround,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\tif !cs.Votes.Prevotes(round).HasTwoThirdsAny() {\n\t\tpanic(fmt.Sprintf(\"enterPrevoteWait(%v/%v), but Prevotes does not have any +2/3 votes\", height, round))\n\t}\n\tlogger.Info(fmt.Sprintf(\"enterPrevoteWait(%v/%v). Current: %v/%v/%v\", height, round, cs.Height, cs.Round, cs.Step))\n\n\tdefer func() {\n\t\t// Done enterPrevoteWait:\n\t\tcs.updateRoundStep(round, cstypes.RoundStepPrevoteWait)\n\t\tcs.newStep()\n\t}()\n\n\t// Wait for some more prevotes; enterPrecommit\n\tcs.scheduleTimeout(cs.config.Prevote(round), height, round, cstypes.RoundStepPrevoteWait)\n}\n\n// Enter: `timeoutPrevote` after any +2/3 prevotes.\n// Enter: `timeoutPrecommit` after any +2/3 precommits.\n// Enter: +2/3 precomits for block or nil.\n// Lock & precommit the ProposalBlock if we have enough prevotes for it (a POL in this round)\n// else, unlock an existing lock and precommit nil if +2/3 of prevotes were nil,\n// else, precommit nil otherwise.\nfunc (cs *State) enterPrecommit(height int64, round int32) {\n\tlogger := cs.Logger.With(\"height\", height, \"round\", round)\n\n\tif cs.Height != height || round < cs.Round || (cs.Round == round && cstypes.RoundStepPrecommit <= cs.Step) {\n\t\tlogger.Debug(fmt.Sprintf(\n\t\t\t\"enterPrecommit(%v/%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tround,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\n\tlogger.Info(fmt.Sprintf(\"enterPrecommit(%v/%v). Current: %v/%v/%v\", height, round, cs.Height, cs.Round, cs.Step))\n\n\tdefer func() {\n\t\t// Done enterPrecommit:\n\t\tcs.updateRoundStep(round, cstypes.RoundStepPrecommit)\n\t\tcs.newStep()\n\t}()\n\n\t// check for a polka\n\tblockID, ok := cs.Votes.Prevotes(round).TwoThirdsMajority()\n\n\t// If we don't have a polka, we must precommit nil.\n\tif !ok {\n\t\tif cs.LockedBlock != nil {\n\t\t\tlogger.Info(\"enterPrecommit: No +2/3 prevotes during enterPrecommit while we're locked. Precommitting nil\")\n\t\t} else {\n\t\t\tlogger.Info(\"enterPrecommit: No +2/3 prevotes during enterPrecommit. Precommitting nil.\")\n\t\t}\n\t\tcs.signAddVote(tmproto.PrecommitType, nil, types.PartSetHeader{})\n\t\treturn\n\t}\n\n\t// At this point +2/3 prevoted for a particular block or nil.\n\tif err := cs.eventBus.PublishEventPolka(cs.RoundStateEvent()); err != nil {\n\t\tcs.Logger.Error(\"Error publishing polka\", \"err\", err)\n\t}\n\n\t// the latest POLRound should be this round.\n\tpolRound, _ := cs.Votes.POLInfo()\n\tif polRound < round {\n\t\tpanic(fmt.Sprintf(\"This POLRound should be %v but got %v\", round, polRound))\n\t}\n\n\t// +2/3 prevoted nil. Unlock and precommit nil.\n\tif len(blockID.Hash) == 0 {\n\t\tif cs.LockedBlock == nil {\n\t\t\tlogger.Info(\"enterPrecommit: +2/3 prevoted for nil.\")\n\t\t} else {\n\t\t\tlogger.Info(\"enterPrecommit: +2/3 prevoted for nil. Unlocking\")\n\t\t\tcs.LockedRound = -1\n\t\t\tcs.LockedBlock = nil\n\t\t\tcs.LockedBlockParts = nil\n\t\t\tif err := cs.eventBus.PublishEventUnlock(cs.RoundStateEvent()); err != nil {\n\t\t\t\tcs.Logger.Error(\"Error publishing event unlock\", \"err\", err)\n\t\t\t}\n\t\t}\n\t\tcs.signAddVote(tmproto.PrecommitType, nil, types.PartSetHeader{})\n\t\treturn\n\t}\n\n\t// At this point, +2/3 prevoted for a particular block.\n\n\t// If we're already locked on that block, precommit it, and update the LockedRound\n\tif cs.LockedBlock.HashesTo(blockID.Hash) {\n\t\tlogger.Info(\"enterPrecommit: +2/3 prevoted locked block. Relocking\")\n\t\tcs.LockedRound = round\n\t\tif err := cs.eventBus.PublishEventRelock(cs.RoundStateEvent()); err != nil {\n\t\t\tcs.Logger.Error(\"Error publishing event relock\", \"err\", err)\n\t\t}\n\t\tcs.signAddVote(tmproto.PrecommitType, blockID.Hash, blockID.PartSetHeader)\n\t\treturn\n\t}\n\n\t// If +2/3 prevoted for proposal block, stage and precommit it\n\tif cs.ProposalBlock.HashesTo(blockID.Hash) {\n\t\tlogger.Info(\"enterPrecommit: +2/3 prevoted proposal block. Locking\", \"hash\", blockID.Hash)\n\t\t// Validate the block.\n\t\tif err := cs.blockExec.ValidateBlock(cs.state, cs.ProposalBlock); err != nil {\n\t\t\tpanic(fmt.Sprintf(\"enterPrecommit: +2/3 prevoted for an invalid block: %v\", err))\n\t\t}\n\t\tcs.LockedRound = round\n\t\tcs.LockedBlock = cs.ProposalBlock\n\t\tcs.LockedBlockParts = cs.ProposalBlockParts\n\t\tif err := cs.eventBus.PublishEventLock(cs.RoundStateEvent()); err != nil {\n\t\t\tcs.Logger.Error(\"Error publishing event lock\", \"err\", err)\n\t\t}\n\t\tcs.signAddVote(tmproto.PrecommitType, blockID.Hash, blockID.PartSetHeader)\n\t\treturn\n\t}\n\n\t// There was a polka in this round for a block we don't have.\n\t// Fetch that block, unlock, and precommit nil.\n\t// The +2/3 prevotes for this round is the POL for our unlock.\n\tlogger.Info(\"enterPrecommit: +2/3 prevotes for a block we don't have. Voting nil\", \"blockID\", blockID)\n\tcs.LockedRound = -1\n\tcs.LockedBlock = nil\n\tcs.LockedBlockParts = nil\n\tif !cs.ProposalBlockParts.HasHeader(blockID.PartSetHeader) {\n\t\tcs.ProposalBlock = nil\n\t\tcs.ProposalBlockParts = types.NewPartSetFromHeader(blockID.PartSetHeader)\n\t}\n\tif err := cs.eventBus.PublishEventUnlock(cs.RoundStateEvent()); err != nil {\n\t\tcs.Logger.Error(\"Error publishing event unlock\", \"err\", err)\n\t}\n\tcs.signAddVote(tmproto.PrecommitType, nil, types.PartSetHeader{})\n}\n\n// Enter: any +2/3 precommits for next round.\nfunc (cs *State) enterPrecommitWait(height int64, round int32) {\n\tlogger := cs.Logger.With(\"height\", height, \"round\", round)\n\n\tif cs.Height != height || round < cs.Round || (cs.Round == round && cs.TriggeredTimeoutPrecommit) {\n\t\tlogger.Debug(\n\t\t\tfmt.Sprintf(\n\t\t\t\t\"enterPrecommitWait(%v/%v): Invalid args. \"+\n\t\t\t\t\t\"Current state is Height/Round: %v/%v/, TriggeredTimeoutPrecommit:%v\",\n\t\t\t\theight, round, cs.Height, cs.Round, cs.TriggeredTimeoutPrecommit))\n\t\treturn\n\t}\n\tif !cs.Votes.Precommits(round).HasTwoThirdsAny() {\n\t\tpanic(fmt.Sprintf(\"enterPrecommitWait(%v/%v), but Precommits does not have any +2/3 votes\", height, round))\n\t}\n\tlogger.Info(fmt.Sprintf(\"enterPrecommitWait(%v/%v). Current: %v/%v/%v\", height, round, cs.Height, cs.Round, cs.Step))\n\n\tdefer func() {\n\t\t// Done enterPrecommitWait:\n\t\tcs.TriggeredTimeoutPrecommit = true\n\t\tcs.newStep()\n\t}()\n\n\t// Wait for some more precommits; enterNewRound\n\tcs.scheduleTimeout(cs.config.Precommit(round), height, round, cstypes.RoundStepPrecommitWait)\n}\n\n// Enter: +2/3 precommits for block\nfunc (cs *State) enterCommit(height int64, commitRound int32) {\n\tlogger := cs.Logger.With(\"height\", height, \"commitRound\", commitRound)\n\n\tif cs.Height != height || cstypes.RoundStepCommit <= cs.Step {\n\t\tlogger.Debug(fmt.Sprintf(\n\t\t\t\"enterCommit(%v/%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tcommitRound,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\tlogger.Info(fmt.Sprintf(\"enterCommit(%v/%v). Current: %v/%v/%v\", height, commitRound, cs.Height, cs.Round, cs.Step))\n\n\tdefer func() {\n\t\t// Done enterCommit:\n\t\t// keep cs.Round the same, commitRound points to the right Precommits set.\n\t\tcs.updateRoundStep(cs.Round, cstypes.RoundStepCommit)\n\t\tcs.CommitRound = commitRound\n\t\tcs.CommitTime = tmtime.Now()\n\t\tcs.newStep()\n\n\t\t// Maybe finalize immediately.\n\t\tcs.tryFinalizeCommit(height)\n\t}()\n\n\tblockID, ok := cs.Votes.Precommits(commitRound).TwoThirdsMajority()\n\tif !ok {\n\t\tpanic(\"RunActionCommit() expects +2/3 precommits\")\n\t}\n\n\t// The Locked* fields no longer matter.\n\t// Move them over to ProposalBlock if they match the commit hash,\n\t// otherwise they'll be cleared in updateToState.\n\tif cs.LockedBlock.HashesTo(blockID.Hash) {\n\t\tlogger.Info(\"Commit is for locked block. Set ProposalBlock=LockedBlock\", \"blockHash\", blockID.Hash)\n\t\tcs.ProposalBlock = cs.LockedBlock\n\t\tcs.ProposalBlockParts = cs.LockedBlockParts\n\t}\n\n\t// If we don't have the block being committed, set up to get it.\n\tif !cs.ProposalBlock.HashesTo(blockID.Hash) {\n\t\tif !cs.ProposalBlockParts.HasHeader(blockID.PartSetHeader) {\n\t\t\tlogger.Info(\n\t\t\t\t\"Commit is for a block we don't know about. Set ProposalBlock=nil\",\n\t\t\t\t\"proposal\",\n\t\t\t\tcs.ProposalBlock.Hash(),\n\t\t\t\t\"commit\",\n\t\t\t\tblockID.Hash)\n\t\t\t// We're getting the wrong block.\n\t\t\t// Set up ProposalBlockParts and keep waiting.\n\t\t\tcs.ProposalBlock = nil\n\t\t\tcs.ProposalBlockParts = types.NewPartSetFromHeader(blockID.PartSetHeader)\n\t\t\tif err := cs.eventBus.PublishEventValidBlock(cs.RoundStateEvent()); err != nil {\n\t\t\t\tcs.Logger.Error(\"Error publishing valid block\", \"err\", err)\n\t\t\t}\n\t\t\tcs.evsw.FireEvent(types.EventValidBlock, &cs.RoundState)\n\t\t}\n\t\t// else {\n\t\t// We just need to keep waiting.\n\t\t// }\n\t}\n}\n\n// If we have the block AND +2/3 commits for it, finalize.\nfunc (cs *State) tryFinalizeCommit(height int64) {\n\tlogger := cs.Logger.With(\"height\", height)\n\n\tif cs.Height != height {\n\t\tpanic(fmt.Sprintf(\"tryFinalizeCommit() cs.Height: %v vs height: %v\", cs.Height, height))\n\t}\n\n\tblockID, ok := cs.Votes.Precommits(cs.CommitRound).TwoThirdsMajority()\n\tif !ok || len(blockID.Hash) == 0 {\n\t\tlogger.Error(\"Attempt to finalize failed. There was no +2/3 majority, or +2/3 was for <nil>.\")\n\t\treturn\n\t}\n\tif !cs.ProposalBlock.HashesTo(blockID.Hash) {\n\t\t// TODO: this happens every time if we're not a validator (ugly logs)\n\t\t// TODO: ^^ wait, why does it matter that we're a validator?\n\t\tlogger.Info(\n\t\t\t\"Attempt to finalize failed. We don't have the commit block.\",\n\t\t\t\"proposal-block\",\n\t\t\tcs.ProposalBlock.Hash(),\n\t\t\t\"commit-block\",\n\t\t\tblockID.Hash)\n\t\treturn\n\t}\n\n\t//\tgo\n\tcs.finalizeCommit(height)\n}\n\n// Increment height and goto cstypes.RoundStepNewHeight\nfunc (cs *State) finalizeCommit(height int64) {\n\tif cs.Height != height || cs.Step != cstypes.RoundStepCommit {\n\t\tcs.Logger.Debug(fmt.Sprintf(\n\t\t\t\"finalizeCommit(%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\n\tblockID, ok := cs.Votes.Precommits(cs.CommitRound).TwoThirdsMajority()\n\tblock, blockParts := cs.ProposalBlock, cs.ProposalBlockParts\n\n\tif !ok {\n\t\tpanic(\"Cannot finalizeCommit, commit does not have two thirds majority\")\n\t}\n\tif !blockParts.HasHeader(blockID.PartSetHeader) {\n\t\tpanic(\"Expected ProposalBlockParts header to be commit header\")\n\t}\n\tif !block.HashesTo(blockID.Hash) {\n\t\tpanic(\"Cannot finalizeCommit, ProposalBlock does not hash to commit hash\")\n\t}\n\tif err := cs.blockExec.ValidateBlock(cs.state, block); err != nil {\n\t\tpanic(fmt.Errorf(\"+2/3 committed an invalid block: %w\", err))\n\t}\n\n\tcs.Logger.Info(\"Finalizing commit of block with N txs\",\n\t\t\"height\", block.Height,\n\t\t\"hash\", block.Hash(),\n\t\t\"root\", block.AppHash,\n\t\t\"N\", len(block.Txs))\n\tcs.Logger.Info(fmt.Sprintf(\"%v\", block))\n\n\tfail.Fail() // XXX\n\n\t// Save to blockStore.\n\tif cs.blockStore.Height() < block.Height {\n\t\t// NOTE: the seenCommit is local justification to commit this block,\n\t\t// but may differ from the LastCommit included in the next block\n\t\tprecommits := cs.Votes.Precommits(cs.CommitRound)\n\t\tseenCommit := precommits.MakeCommit()\n\t\tcs.blockStore.SaveBlock(block, blockParts, seenCommit)\n\t} else {\n\t\t// Happens during replay if we already saved the block but didn't commit\n\t\tcs.Logger.Info(\"Calling finalizeCommit on already stored block\", \"height\", block.Height)\n\t}\n\n\tfail.Fail() // XXX\n\n\t// Write EndHeightMessage{} for this height, implying that the blockstore\n\t// has saved the block.\n\t//\n\t// If we crash before writing this EndHeightMessage{}, we will recover by\n\t// running ApplyBlock during the ABCI handshake when we restart.  If we\n\t// didn't save the block to the blockstore before writing\n\t// EndHeightMessage{}, we'd have to change WAL replay -- currently it\n\t// complains about replaying for heights where an #ENDHEIGHT entry already\n\t// exists.\n\t//\n\t// Either way, the State should not be resumed until we\n\t// successfully call ApplyBlock (ie. later here, or in Handshake after\n\t// restart).\n\tendMsg := EndHeightMessage{height}\n\tif err := cs.wal.WriteSync(endMsg); err != nil { // NOTE: fsync\n\t\tpanic(fmt.Sprintf(\"Failed to write %v msg to consensus wal due to %v. Check your FS and restart the node\",\n\t\t\tendMsg, err))\n\t}\n\n\tfail.Fail() // XXX\n\n\t// Create a copy of the state for staging and an event cache for txs.\n\tstateCopy := cs.state.Copy()\n\n\t// Execute and commit the block, update and save the state, and update the mempool.\n\t// NOTE The block.AppHash wont reflect these txs until the next block.\n\tvar err error\n\tvar retainHeight int64\n\tstateCopy, retainHeight, err = cs.blockExec.ApplyBlock(\n\t\tstateCopy,\n\t\ttypes.BlockID{Hash: block.Hash(), PartSetHeader: blockParts.Header()},\n\t\tblock)\n\tif err != nil {\n\t\tcs.Logger.Error(\"Error on ApplyBlock\", \"err\", err)\n\t\treturn\n\t}\n\n\tfail.Fail() // XXX\n\n\t// Prune old heights, if requested by ABCI app.\n\tif retainHeight > 0 {\n\t\tpruned, err := cs.pruneBlocks(retainHeight)\n\t\tif err != nil {\n\t\t\tcs.Logger.Error(\"Failed to prune blocks\", \"retainHeight\", retainHeight, \"err\", err)\n\t\t} else {\n\t\t\tcs.Logger.Info(\"Pruned blocks\", \"pruned\", pruned, \"retainHeight\", retainHeight)\n\t\t}\n\t}\n\n\t// must be called before we update state\n\tcs.recordMetrics(height, block)\n\n\t// NewHeightStep!\n\tcs.updateToState(stateCopy)\n\n\tfail.Fail() // XXX\n\n\t// Private validator might have changed it's key pair => refetch pubkey.\n\tif err := cs.updatePrivValidatorPubKey(); err != nil {\n\t\tcs.Logger.Error(\"Can't get private validator pubkey\", \"err\", err)\n\t}\n\n\t// cs.StartTime is already set.\n\t// Schedule Round0 to start soon.\n\tcs.scheduleRound0(&cs.RoundState)\n\n\t// By here,\n\t// * cs.Height has been increment to height+1\n\t// * cs.Step is now cstypes.RoundStepNewHeight\n\t// * cs.StartTime is set to when we will start round0.\n}\n\nfunc (cs *State) pruneBlocks(retainHeight int64) (uint64, error) {\n\tbase := cs.blockStore.Base()\n\tif retainHeight <= base {\n\t\treturn 0, nil\n\t}\n\tpruned, err := cs.blockStore.PruneBlocks(retainHeight)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to prune block store: %w\", err)\n\t}\n\terr = cs.blockExec.Store().PruneStates(base, retainHeight)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to prune state database: %w\", err)\n\t}\n\treturn pruned, nil\n}\n\nfunc (cs *State) recordMetrics(height int64, block *types.Block) {\n\tcs.metrics.Validators.Set(float64(cs.Validators.Size()))\n\tcs.metrics.ValidatorsPower.Set(float64(cs.Validators.TotalVotingPower()))\n\n\tvar (\n\t\tmissingValidators      int\n\t\tmissingValidatorsPower int64\n\t)\n\t// height=0 -> MissingValidators and MissingValidatorsPower are both 0.\n\t// Remember that the first LastCommit is intentionally empty, so it's not\n\t// fair to increment missing validators number.\n\tif height > cs.state.InitialHeight {\n\t\t// Sanity check that commit size matches validator set size - only applies\n\t\t// after first block.\n\t\tvar (\n\t\t\tcommitSize = block.LastCommit.Size()\n\t\t\tvalSetLen  = len(cs.LastValidators.Validators)\n\t\t\taddress    types.Address\n\t\t)\n\t\tif commitSize != valSetLen {\n\t\t\tpanic(fmt.Sprintf(\"commit size (%d) doesn't match valset length (%d) at height %d\\n\\n%v\\n\\n%v\",\n\t\t\t\tcommitSize, valSetLen, block.Height, block.LastCommit.Signatures, cs.LastValidators.Validators))\n\t\t}\n\n\t\tif cs.privValidator != nil {\n\t\t\tif cs.privValidatorPubKey == nil {\n\t\t\t\t// Metrics won't be updated, but it's not critical.\n\t\t\t\tcs.Logger.Error(fmt.Sprintf(\"recordMetrics: %v\", errPubKeyIsNotSet))\n\t\t\t} else {\n\t\t\t\taddress = cs.privValidatorPubKey.Address()\n\t\t\t}\n\t\t}\n\n\t\tfor i, val := range cs.LastValidators.Validators {\n\t\t\tcommitSig := block.LastCommit.Signatures[i]\n\t\t\tif commitSig.Absent() {\n\t\t\t\tmissingValidators++\n\t\t\t\tmissingValidatorsPower += val.VotingPower\n\t\t\t}\n\n\t\t\tif bytes.Equal(val.Address, address) {\n\t\t\t\tlabel := []string{\n\t\t\t\t\t\"validator_address\", val.Address.String(),\n\t\t\t\t}\n\t\t\t\tcs.metrics.ValidatorPower.With(label...).Set(float64(val.VotingPower))\n\t\t\t\tif commitSig.ForBlock() {\n\t\t\t\t\tcs.metrics.ValidatorLastSignedHeight.With(label...).Set(float64(height))\n\t\t\t\t} else {\n\t\t\t\t\tcs.metrics.ValidatorMissedBlocks.With(label...).Add(float64(1))\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\tcs.metrics.MissingValidators.Set(float64(missingValidators))\n\tcs.metrics.MissingValidatorsPower.Set(float64(missingValidatorsPower))\n\n\t// NOTE: byzantine validators power and count is only for consensus evidence i.e. duplicate vote\n\tvar (\n\t\tbyzantineValidatorsPower = int64(0)\n\t\tbyzantineValidatorsCount = int64(0)\n\t)\n\tfor _, ev := range block.Evidence.Evidence {\n\t\tif dve, ok := ev.(*types.DuplicateVoteEvidence); ok {\n\t\t\tif _, val := cs.Validators.GetByAddress(dve.VoteA.ValidatorAddress); val != nil {\n\t\t\t\tbyzantineValidatorsCount++\n\t\t\t\tbyzantineValidatorsPower += val.VotingPower\n\t\t\t}\n\t\t}\n\t}\n\tcs.metrics.ByzantineValidators.Set(float64(byzantineValidatorsCount))\n\tcs.metrics.ByzantineValidatorsPower.Set(float64(byzantineValidatorsPower))\n\n\tif height > 1 {\n\t\tlastBlockMeta := cs.blockStore.LoadBlockMeta(height - 1)\n\t\tif lastBlockMeta != nil {\n\t\t\tcs.metrics.BlockIntervalSeconds.Observe(\n\t\t\t\tblock.Time.Sub(lastBlockMeta.Header.Time).Seconds(),\n\t\t\t)\n\t\t}\n\t}\n\n\tcs.metrics.NumTxs.Set(float64(len(block.Data.Txs)))\n\tcs.metrics.TotalTxs.Add(float64(len(block.Data.Txs)))\n\tcs.metrics.BlockSizeBytes.Set(float64(block.Size()))\n\tcs.metrics.CommittedHeight.Set(float64(block.Height))\n}\n\n//-----------------------------------------------------------------------------\n\nfunc (cs *State) defaultSetProposal(proposal *types.Proposal) error {\n\t// Already have one\n\t// TODO: possibly catch double proposals\n\tif cs.Proposal != nil {\n\t\treturn nil\n\t}\n\n\t// Does not apply\n\tif proposal.Height != cs.Height || proposal.Round != cs.Round {\n\t\treturn nil\n\t}\n\n\t// Verify POLRound, which must be -1 or in range [0, proposal.Round).\n\tif proposal.POLRound < -1 ||\n\t\t(proposal.POLRound >= 0 && proposal.POLRound >= proposal.Round) {\n\t\treturn ErrInvalidProposalPOLRound\n\t}\n\n\tp := proposal.ToProto()\n\t// Verify signature\n\tif !cs.Validators.GetProposer().PubKey.VerifySignature(\n\t\ttypes.ProposalSignBytes(cs.state.ChainID, p), proposal.Signature,\n\t) {\n\t\treturn ErrInvalidProposalSignature\n\t}\n\n\tproposal.Signature = p.Signature\n\tcs.Proposal = proposal\n\t// We don't update cs.ProposalBlockParts if it is already set.\n\t// This happens if we're already in cstypes.RoundStepCommit or if there is a valid block in the current round.\n\t// TODO: We can check if Proposal is for a different block as this is a sign of misbehavior!\n\tif cs.ProposalBlockParts == nil {\n\t\tcs.ProposalBlockParts = types.NewPartSetFromHeader(proposal.BlockID.PartSetHeader)\n\t}\n\tcs.Logger.Info(\"Received proposal\", \"proposal\", proposal)\n\treturn nil\n}\n\n// NOTE: block is not necessarily valid.\n// Asynchronously triggers either enterPrevote (before we timeout of propose) or tryFinalizeCommit,\n// once we have the full block.\nfunc (cs *State) addProposalBlockPart(msg *BlockPartMessage, peerID p2p.ID) (added bool, err error) {\n\theight, round, part := msg.Height, msg.Round, msg.Part\n\n\t// Blocks might be reused, so round mismatch is OK\n\tif cs.Height != height {\n\t\tcs.Logger.Debug(\"Received block part from wrong height\", \"height\", height, \"round\", round)\n\t\treturn false, nil\n\t}\n\n\t// We're not expecting a block part.\n\tif cs.ProposalBlockParts == nil {\n\t\t// NOTE: this can happen when we've gone to a higher round and\n\t\t// then receive parts from the previous round - not necessarily a bad peer.\n\t\tcs.Logger.Info(\"Received a block part when we're not expecting any\",\n\t\t\t\"height\", height, \"round\", round, \"index\", part.Index, \"peer\", peerID)\n\t\treturn false, nil\n\t}\n\n\tadded, err = cs.ProposalBlockParts.AddPart(part)\n\tif err != nil {\n\t\treturn added, err\n\t}\n\tif cs.ProposalBlockParts.ByteSize() > cs.state.ConsensusParams.Block.MaxBytes {\n\t\treturn added, fmt.Errorf(\"total size of proposal block parts exceeds maximum block bytes (%d > %d)\",\n\t\t\tcs.ProposalBlockParts.ByteSize(), cs.state.ConsensusParams.Block.MaxBytes,\n\t\t)\n\t}\n\tif added && cs.ProposalBlockParts.IsComplete() {\n\t\tbz, err := ioutil.ReadAll(cs.ProposalBlockParts.GetReader())\n\t\tif err != nil {\n\t\t\treturn added, err\n\t\t}\n\n\t\tvar pbb = new(tmproto.Block)\n\t\terr = proto.Unmarshal(bz, pbb)\n\t\tif err != nil {\n\t\t\treturn added, err\n\t\t}\n\n\t\tblock, err := types.BlockFromProto(pbb)\n\t\tif err != nil {\n\t\t\treturn added, err\n\t\t}\n\n\t\tcs.ProposalBlock = block\n\t\t// NOTE: it's possible to receive complete proposal blocks for future rounds without having the proposal\n\t\tcs.Logger.Info(\"Received complete proposal block\", \"height\", cs.ProposalBlock.Height, \"hash\", cs.ProposalBlock.Hash())\n\t\tif err := cs.eventBus.PublishEventCompleteProposal(cs.CompleteProposalEvent()); err != nil {\n\t\t\tcs.Logger.Error(\"Error publishing event complete proposal\", \"err\", err)\n\t\t}\n\n\t\t// Update Valid* if we can.\n\t\tprevotes := cs.Votes.Prevotes(cs.Round)\n\t\tblockID, hasTwoThirds := prevotes.TwoThirdsMajority()\n\t\tif hasTwoThirds && !blockID.IsZero() && (cs.ValidRound < cs.Round) {\n\t\t\tif cs.ProposalBlock.HashesTo(blockID.Hash) {\n\t\t\t\tcs.Logger.Info(\"Updating valid block to new proposal block\",\n\t\t\t\t\t\"valid-round\", cs.Round, \"valid-block-hash\", cs.ProposalBlock.Hash())\n\t\t\t\tcs.ValidRound = cs.Round\n\t\t\t\tcs.ValidBlock = cs.ProposalBlock\n\t\t\t\tcs.ValidBlockParts = cs.ProposalBlockParts\n\t\t\t}\n\t\t\t// TODO: In case there is +2/3 majority in Prevotes set for some\n\t\t\t// block and cs.ProposalBlock contains different block, either\n\t\t\t// proposer is faulty or voting power of faulty processes is more\n\t\t\t// than 1/3. We should trigger in the future accountability\n\t\t\t// procedure at this point.\n\t\t}\n\n\t\tif cs.Step <= cstypes.RoundStepPropose && cs.isProposalComplete() {\n\t\t\t// Move onto the next step\n\t\t\tcs.enterPrevote(height, cs.Round)\n\t\t\tif hasTwoThirds { // this is optimisation as this will be triggered when prevote is added\n\t\t\t\tcs.enterPrecommit(height, cs.Round)\n\t\t\t}\n\t\t} else if cs.Step == cstypes.RoundStepCommit {\n\t\t\t// If we're waiting on the proposal block...\n\t\t\tcs.tryFinalizeCommit(height)\n\t\t}\n\t\treturn added, nil\n\t}\n\treturn added, nil\n}\n\n// Attempt to add the vote. if its a duplicate signature, dupeout the validator\nfunc (cs *State) tryAddVote(vote *types.Vote, peerID p2p.ID) (bool, error) {\n\tadded, err := cs.addVote(vote, peerID)\n\tif err != nil {\n\t\t// If the vote height is off, we'll just ignore it,\n\t\t// But if it's a conflicting sig, add it to the cs.evpool.\n\t\t// If it's otherwise invalid, punish peer.\n\t\t// nolint: gocritic\n\t\tif voteErr, ok := err.(*types.ErrVoteConflictingVotes); ok {\n\t\t\tif cs.privValidatorPubKey == nil {\n\t\t\t\treturn false, errPubKeyIsNotSet\n\t\t\t}\n\n\t\t\tif bytes.Equal(vote.ValidatorAddress, cs.privValidatorPubKey.Address()) {\n\t\t\t\tcs.Logger.Error(\n\t\t\t\t\t\"Found conflicting vote from ourselves. Did you unsafe_reset a validator?\",\n\t\t\t\t\t\"height\",\n\t\t\t\t\tvote.Height,\n\t\t\t\t\t\"round\",\n\t\t\t\t\tvote.Round,\n\t\t\t\t\t\"type\",\n\t\t\t\t\tvote.Type)\n\t\t\t\treturn added, err\n\t\t\t}\n\t\t\tvar timestamp time.Time\n\t\t\tif voteErr.VoteA.Height == cs.state.InitialHeight {\n\t\t\t\ttimestamp = cs.state.LastBlockTime // genesis time\n\t\t\t} else {\n\t\t\t\ttimestamp = sm.MedianTime(cs.LastCommit.MakeCommit(), cs.LastValidators)\n\t\t\t}\n\t\t\t// form duplicate vote evidence from the conflicting votes and send it across to the\n\t\t\t// evidence pool\n\t\t\tev := types.NewDuplicateVoteEvidence(voteErr.VoteA, voteErr.VoteB, timestamp, cs.Validators)\n\t\t\tevidenceErr := cs.evpool.AddEvidenceFromConsensus(ev)\n\t\t\tif evidenceErr != nil {\n\t\t\t\tcs.Logger.Error(\"Failed to add evidence to the evidence pool\", \"err\", evidenceErr)\n\t\t\t} else {\n\t\t\t\tcs.Logger.Debug(\"Added evidence to the evidence pool\", \"ev\", ev)\n\t\t\t}\n\t\t\treturn added, err\n\t\t} else if err == types.ErrVoteNonDeterministicSignature {\n\t\t\tcs.Logger.Debug(\"Vote has non-deterministic signature\", \"err\", err)\n\t\t} else {\n\t\t\t// Either\n\t\t\t// 1) bad peer OR\n\t\t\t// 2) not a bad peer? this can also err sometimes with \"Unexpected step\" OR\n\t\t\t// 3) tmkms use with multiple validators connecting to a single tmkms instance\n\t\t\t// \t\t(https://github.com/tendermint/tendermint/issues/3839).\n\t\t\tcs.Logger.Info(\"Error attempting to add vote\", \"err\", err)\n\t\t\treturn added, ErrAddingVote\n\t\t}\n\t}\n\treturn added, nil\n}\n\n//-----------------------------------------------------------------------------\n\nfunc (cs *State) addVote(\n\tvote *types.Vote,\n\tpeerID p2p.ID) (added bool, err error) {\n\tcs.Logger.Debug(\n\t\t\"addVote\",\n\t\t\"voteHeight\",\n\t\tvote.Height,\n\t\t\"voteType\",\n\t\tvote.Type,\n\t\t\"valIndex\",\n\t\tvote.ValidatorIndex,\n\t\t\"csHeight\",\n\t\tcs.Height,\n\t)\n\n\t// A precommit for the previous height?\n\t// These come in while we wait timeoutCommit\n\tif vote.Height+1 == cs.Height && vote.Type == tmproto.PrecommitType {\n\t\tif cs.Step != cstypes.RoundStepNewHeight {\n\t\t\t// Late precommit at prior height is ignored\n\t\t\tcs.Logger.Debug(\"Precommit vote came in after commit timeout and has been ignored\", \"vote\", vote)\n\t\t\treturn\n\t\t}\n\t\tadded, err = cs.LastCommit.AddVote(vote)\n\t\tif !added {\n\t\t\treturn\n\t\t}\n\n\t\tcs.Logger.Info(fmt.Sprintf(\"Added to lastPrecommits: %v\", cs.LastCommit.StringShort()))\n\t\tif err := cs.eventBus.PublishEventVote(types.EventDataVote{Vote: vote}); err != nil {\n\t\t\treturn added, err\n\t\t}\n\t\tcs.evsw.FireEvent(types.EventVote, vote)\n\n\t\t// if we can skip timeoutCommit and have all the votes now,\n\t\tif cs.config.SkipTimeoutCommit && cs.LastCommit.HasAll() {\n\t\t\t// go straight to new round (skip timeout commit)\n\t\t\t// cs.scheduleTimeout(time.Duration(0), cs.Height, 0, cstypes.RoundStepNewHeight)\n\t\t\tcs.enterNewRound(cs.Height, 0)\n\t\t}\n\n\t\treturn\n\t}\n\n\t// Height mismatch is ignored.\n\t// Not necessarily a bad peer, but not favourable behaviour.\n\tif vote.Height != cs.Height {\n\t\tcs.Logger.Info(\"Vote ignored and not added\", \"voteHeight\", vote.Height, \"csHeight\", cs.Height, \"peerID\", peerID)\n\t\treturn\n\t}\n\n\theight := cs.Height\n\tadded, err = cs.Votes.AddVote(vote, peerID)\n\tif !added {\n\t\t// Either duplicate, or error upon cs.Votes.AddByIndex()\n\t\treturn\n\t}\n\n\tif err := cs.eventBus.PublishEventVote(types.EventDataVote{Vote: vote}); err != nil {\n\t\treturn added, err\n\t}\n\tcs.evsw.FireEvent(types.EventVote, vote)\n\n\tswitch vote.Type {\n\tcase tmproto.PrevoteType:\n\t\tprevotes := cs.Votes.Prevotes(vote.Round)\n\t\tcs.Logger.Info(\"Added to prevote\", \"vote\", vote, \"prevotes\", prevotes.StringShort())\n\n\t\t// If +2/3 prevotes for a block or nil for *any* round:\n\t\tif blockID, ok := prevotes.TwoThirdsMajority(); ok {\n\n\t\t\t// There was a polka!\n\t\t\t// If we're locked but this is a recent polka, unlock.\n\t\t\t// If it matches our ProposalBlock, update the ValidBlock\n\n\t\t\t// Unlock if `cs.LockedRound < vote.Round <= cs.Round`\n\t\t\t// NOTE: If vote.Round > cs.Round, we'll deal with it when we get to vote.Round\n\t\t\tif (cs.LockedBlock != nil) &&\n\t\t\t\t(cs.LockedRound < vote.Round) &&\n\t\t\t\t(vote.Round <= cs.Round) &&\n\t\t\t\t!cs.LockedBlock.HashesTo(blockID.Hash) {\n\n\t\t\t\tcs.Logger.Info(\"Unlocking because of POL.\", \"lockedRound\", cs.LockedRound, \"POLRound\", vote.Round)\n\t\t\t\tcs.LockedRound = -1\n\t\t\t\tcs.LockedBlock = nil\n\t\t\t\tcs.LockedBlockParts = nil\n\t\t\t\tif err := cs.eventBus.PublishEventUnlock(cs.RoundStateEvent()); err != nil {\n\t\t\t\t\treturn added, err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update Valid* if we can.\n\t\t\t// NOTE: our proposal block may be nil or not what received a polka..\n\t\t\tif len(blockID.Hash) != 0 && (cs.ValidRound < vote.Round) && (vote.Round == cs.Round) {\n\n\t\t\t\tif cs.ProposalBlock.HashesTo(blockID.Hash) {\n\t\t\t\t\tcs.Logger.Info(\n\t\t\t\t\t\t\"Updating ValidBlock because of POL.\", \"validRound\", cs.ValidRound, \"POLRound\", vote.Round)\n\t\t\t\t\tcs.ValidRound = vote.Round\n\t\t\t\t\tcs.ValidBlock = cs.ProposalBlock\n\t\t\t\t\tcs.ValidBlockParts = cs.ProposalBlockParts\n\t\t\t\t} else {\n\t\t\t\t\tcs.Logger.Info(\n\t\t\t\t\t\t\"Valid block we don't know about. Set ProposalBlock=nil\",\n\t\t\t\t\t\t\"proposal\", cs.ProposalBlock.Hash(), \"blockID\", blockID.Hash)\n\t\t\t\t\t// We're getting the wrong block.\n\t\t\t\t\tcs.ProposalBlock = nil\n\t\t\t\t}\n\t\t\t\tif !cs.ProposalBlockParts.HasHeader(blockID.PartSetHeader) {\n\t\t\t\t\tcs.ProposalBlockParts = types.NewPartSetFromHeader(blockID.PartSetHeader)\n\t\t\t\t}\n\t\t\t\tcs.evsw.FireEvent(types.EventValidBlock, &cs.RoundState)\n\t\t\t\tif err := cs.eventBus.PublishEventValidBlock(cs.RoundStateEvent()); err != nil {\n\t\t\t\t\treturn added, err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If +2/3 prevotes for *anything* for future round:\n\t\tswitch {\n\t\tcase cs.Round < vote.Round && prevotes.HasTwoThirdsAny():\n\t\t\t// Round-skip if there is any 2/3+ of votes ahead of us\n\t\t\tcs.enterNewRound(height, vote.Round)\n\t\tcase cs.Round == vote.Round && cstypes.RoundStepPrevote <= cs.Step: // current round\n\t\t\tblockID, ok := prevotes.TwoThirdsMajority()\n\t\t\tif ok && (cs.isProposalComplete() || len(blockID.Hash) == 0) {\n\t\t\t\tcs.enterPrecommit(height, vote.Round)\n\t\t\t} else if prevotes.HasTwoThirdsAny() {\n\t\t\t\tcs.enterPrevoteWait(height, vote.Round)\n\t\t\t}\n\t\tcase cs.Proposal != nil && 0 <= cs.Proposal.POLRound && cs.Proposal.POLRound == vote.Round:\n\t\t\t// If the proposal is now complete, enter prevote of cs.Round.\n\t\t\tif cs.isProposalComplete() {\n\t\t\t\tcs.enterPrevote(height, cs.Round)\n\t\t\t}\n\t\t}\n\n\tcase tmproto.PrecommitType:\n\t\tprecommits := cs.Votes.Precommits(vote.Round)\n\t\tcs.Logger.Info(\"Added to precommit\", \"vote\", vote, \"precommits\", precommits.StringShort())\n\n\t\tblockID, ok := precommits.TwoThirdsMajority()\n\t\tif ok {\n\t\t\t// Executed as TwoThirdsMajority could be from a higher round\n\t\t\tcs.enterNewRound(height, vote.Round)\n\t\t\tcs.enterPrecommit(height, vote.Round)\n\t\t\tif len(blockID.Hash) != 0 {\n\t\t\t\tcs.enterCommit(height, vote.Round)\n\t\t\t\tif cs.config.SkipTimeoutCommit && precommits.HasAll() {\n\t\t\t\t\tcs.enterNewRound(cs.Height, 0)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcs.enterPrecommitWait(height, vote.Round)\n\t\t\t}\n\t\t} else if cs.Round <= vote.Round && precommits.HasTwoThirdsAny() {\n\t\t\tcs.enterNewRound(height, vote.Round)\n\t\t\tcs.enterPrecommitWait(height, vote.Round)\n\t\t}\n\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"Unexpected vote type %v\", vote.Type))\n\t}\n\n\treturn added, err\n}\n\n// CONTRACT: cs.privValidator is not nil.\nfunc (cs *State) signVote(\n\tmsgType tmproto.SignedMsgType,\n\thash []byte,\n\theader types.PartSetHeader,\n) (*types.Vote, error) {\n\t// Flush the WAL. Otherwise, we may not recompute the same vote to sign,\n\t// and the privValidator will refuse to sign anything.\n\tif err := cs.wal.FlushAndSync(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif cs.privValidatorPubKey == nil {\n\t\treturn nil, errPubKeyIsNotSet\n\t}\n\taddr := cs.privValidatorPubKey.Address()\n\tvalIdx, _ := cs.Validators.GetByAddress(addr)\n\n\tvote := &types.Vote{\n\t\tValidatorAddress: addr,\n\t\tValidatorIndex:   valIdx,\n\t\tHeight:           cs.Height,\n\t\tRound:            cs.Round,\n\t\tTimestamp:        cs.voteTime(),\n\t\tType:             msgType,\n\t\tBlockID:          types.BlockID{Hash: hash, PartSetHeader: header},\n\t}\n\tv := vote.ToProto()\n\terr := cs.privValidator.SignVote(cs.state.ChainID, v)\n\tvote.Signature = v.Signature\n\n\treturn vote, err\n}\n\nfunc (cs *State) voteTime() time.Time {\n\tnow := tmtime.Now()\n\tminVoteTime := now\n\t// TODO: We should remove next line in case we don't vote for v in case cs.ProposalBlock == nil,\n\t// even if cs.LockedBlock != nil. See https://docs.tendermint.com/master/spec/.\n\ttimeIota := time.Duration(cs.state.ConsensusParams.Block.TimeIotaMs) * time.Millisecond\n\tif cs.LockedBlock != nil {\n\t\t// See the BFT time spec https://docs.tendermint.com/master/spec/consensus/bft-time.html\n\t\tminVoteTime = cs.LockedBlock.Time.Add(timeIota)\n\t} else if cs.ProposalBlock != nil {\n\t\tminVoteTime = cs.ProposalBlock.Time.Add(timeIota)\n\t}\n\n\tif now.After(minVoteTime) {\n\t\treturn now\n\t}\n\treturn minVoteTime\n}\n\n// sign the vote and publish on internalMsgQueue\nfunc (cs *State) signAddVote(msgType tmproto.SignedMsgType, hash []byte, header types.PartSetHeader) *types.Vote {\n\tif cs.privValidator == nil { // the node does not have a key\n\t\treturn nil\n\t}\n\n\tif cs.privValidatorPubKey == nil {\n\t\t// Vote won't be signed, but it's not critical.\n\t\tcs.Logger.Error(fmt.Sprintf(\"signAddVote: %v\", errPubKeyIsNotSet))\n\t\treturn nil\n\t}\n\n\t// If the node not in the validator set, do nothing.\n\tif !cs.Validators.HasAddress(cs.privValidatorPubKey.Address()) {\n\t\treturn nil\n\t}\n\n\t// TODO: pass pubKey to signVote\n\tvote, err := cs.signVote(msgType, hash, header)\n\tif err == nil {\n\t\tcs.sendInternalMessage(msgInfo{&VoteMessage{vote}, \"\"})\n\t\tcs.Logger.Info(\"Signed and pushed vote\", \"height\", cs.Height, \"round\", cs.Round, \"vote\", vote, \"err\", err)\n\t\treturn vote\n\t}\n\t// if !cs.replayMode {\n\tcs.Logger.Error(\"Error signing vote\", \"height\", cs.Height, \"round\", cs.Round, \"vote\", vote, \"err\", err)\n\t// }\n\treturn nil\n}\n\n// updatePrivValidatorPubKey get's the private validator public key and\n// memoizes it. This func returns an error if the private validator is not\n// responding or responds with an error.\nfunc (cs *State) updatePrivValidatorPubKey() error {\n\tif cs.privValidator == nil {\n\t\treturn nil\n\t}\n\n\tpubKey, err := cs.privValidator.GetPubKey()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcs.privValidatorPubKey = pubKey\n\treturn nil\n}\n\n// look back to check existence of the node's consensus votes before joining consensus\nfunc (cs *State) checkDoubleSigningRisk(height int64) error {\n\tif cs.privValidator != nil && cs.privValidatorPubKey != nil && cs.config.DoubleSignCheckHeight > 0 && height > 0 {\n\t\tvalAddr := cs.privValidatorPubKey.Address()\n\t\tdoubleSignCheckHeight := cs.config.DoubleSignCheckHeight\n\t\tif doubleSignCheckHeight > height {\n\t\t\tdoubleSignCheckHeight = height\n\t\t}\n\t\tfor i := int64(1); i < doubleSignCheckHeight; i++ {\n\t\t\tlastCommit := cs.blockStore.LoadSeenCommit(height - i)\n\t\t\tif lastCommit != nil {\n\t\t\t\tfor sigIdx, s := range lastCommit.Signatures {\n\t\t\t\t\tif s.BlockIDFlag == types.BlockIDFlagCommit && bytes.Equal(s.ValidatorAddress, valAddr) {\n\t\t\t\t\t\tcs.Logger.Info(\"Found signature from the same key\", \"sig\", s, \"idx\", sigIdx, \"height\", height-i)\n\t\t\t\t\t\treturn ErrSignatureFoundInPastBlocks\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n//---------------------------------------------------------\n\nfunc CompareHRS(h1 int64, r1 int32, s1 cstypes.RoundStepType, h2 int64, r2 int32, s2 cstypes.RoundStepType) int {\n\tif h1 < h2 {\n\t\treturn -1\n\t} else if h1 > h2 {\n\t\treturn 1\n\t}\n\tif r1 < r2 {\n\t\treturn -1\n\t} else if r1 > r2 {\n\t\treturn 1\n\t}\n\tif s1 < s2 {\n\t\treturn -1\n\t} else if s1 > s2 {\n\t\treturn 1\n\t}\n\treturn 0\n}\n\n// repairWalFile decodes messages from src (until the decoder errors) and\n// writes them to dst.\nfunc repairWalFile(src, dst string) error {\n\tin, err := os.Open(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer in.Close()\n\n\tout, err := os.Create(dst)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer out.Close()\n\n\tvar (\n\t\tdec = NewWALDecoder(in)\n\t\tenc = NewWALEncoder(out)\n\t)\n\n\t// best-case repair (until first error is encountered)\n\tfor {\n\t\tmsg, err := dec.Decode()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\terr = enc.Encode(msg)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to encode msg: %w\", err)\n\t\t}\n\t}\n\n\treturn nil\n}\n", "package evidence\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"sort\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/gogo/protobuf/proto\"\n\tgogotypes \"github.com/gogo/protobuf/types\"\n\tdbm \"github.com/tendermint/tm-db\"\n\n\tclist \"github.com/tendermint/tendermint/libs/clist\"\n\t\"github.com/tendermint/tendermint/libs/log\"\n\ttmproto \"github.com/tendermint/tendermint/proto/tendermint/types\"\n\tsm \"github.com/tendermint/tendermint/state\"\n\t\"github.com/tendermint/tendermint/types\"\n)\n\nconst (\n\tbaseKeyCommitted = byte(0x00)\n\tbaseKeyPending   = byte(0x01)\n)\n\n// Pool maintains a pool of valid evidence to be broadcasted and committed\ntype Pool struct {\n\tlogger log.Logger\n\n\tevidenceStore dbm.DB\n\tevidenceList  *clist.CList // concurrent linked-list of evidence\n\tevidenceSize  uint32       // amount of pending evidence\n\n\t// needed to load validators to verify evidence\n\tstateDB sm.Store\n\t// needed to load headers and commits to verify evidence\n\tblockStore BlockStore\n\n\tmtx sync.Mutex\n\t// latest state\n\tstate sm.State\n\t// evidence from consensus if buffered to this slice, awaiting until the next height\n\t// before being flushed to the pool. This prevents broadcasting and proposing of\n\t// evidence before the height with which the evidence happened is finished.\n\tconsensusBuffer []types.Evidence\n\n\tpruningHeight int64\n\tpruningTime   time.Time\n}\n\n// NewPool creates an evidence pool. If using an existing evidence store,\n// it will add all pending evidence to the concurrent list.\nfunc NewPool(evidenceDB dbm.DB, stateDB sm.Store, blockStore BlockStore) (*Pool, error) {\n\n\tstate, err := stateDB.Load()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot load state: %w\", err)\n\t}\n\n\tpool := &Pool{\n\t\tstateDB:         stateDB,\n\t\tblockStore:      blockStore,\n\t\tstate:           state,\n\t\tlogger:          log.NewNopLogger(),\n\t\tevidenceStore:   evidenceDB,\n\t\tevidenceList:    clist.New(),\n\t\tconsensusBuffer: make([]types.Evidence, 0),\n\t}\n\n\t// if pending evidence already in db, in event of prior failure, then check for expiration,\n\t// update the size and load it back to the evidenceList\n\tpool.pruningHeight, pool.pruningTime = pool.removeExpiredPendingEvidence()\n\tevList, _, err := pool.listEvidence(baseKeyPending, -1)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tatomic.StoreUint32(&pool.evidenceSize, uint32(len(evList)))\n\tfor _, ev := range evList {\n\t\tpool.evidenceList.PushBack(ev)\n\t}\n\n\treturn pool, nil\n}\n\n// PendingEvidence is used primarily as part of block proposal and returns up to maxNum of uncommitted evidence.\nfunc (evpool *Pool) PendingEvidence(maxBytes int64) ([]types.Evidence, int64) {\n\tif evpool.Size() == 0 {\n\t\treturn []types.Evidence{}, 0\n\t}\n\tevidence, size, err := evpool.listEvidence(baseKeyPending, maxBytes)\n\tif err != nil {\n\t\tevpool.logger.Error(\"Unable to retrieve pending evidence\", \"err\", err)\n\t}\n\treturn evidence, size\n}\n\n// Update pulls the latest state to be used for expiration and evidence params and then prunes all expired evidence\nfunc (evpool *Pool) Update(state sm.State, ev types.EvidenceList) {\n\t// sanity check\n\tif state.LastBlockHeight <= evpool.state.LastBlockHeight {\n\t\tpanic(fmt.Sprintf(\n\t\t\t\"Failed EvidencePool.Update new state height is less than or equal to previous state height: %d <= %d\",\n\t\t\tstate.LastBlockHeight,\n\t\t\tevpool.state.LastBlockHeight,\n\t\t))\n\t}\n\tevpool.logger.Info(\"Updating evidence pool\", \"last_block_height\", state.LastBlockHeight,\n\t\t\"last_block_time\", state.LastBlockTime)\n\n\tevpool.logger.Info(\n\t\t\"updating evidence pool\",\n\t\t\"last_block_height\", state.LastBlockHeight,\n\t\t\"last_block_time\", state.LastBlockTime,\n\t)\n\n\tevpool.mtx.Lock()\n\t// flush awaiting evidence from consensus into pool\n\tevpool.flushConsensusBuffer()\n\t// update state\n\tevpool.state = state\n\tevpool.mtx.Unlock()\n\n\t// move committed evidence out from the pending pool and into the committed pool\n\tevpool.markEvidenceAsCommitted(ev)\n\n\t// prune pending evidence when it has expired. This also updates when the next evidence will expire\n\tif evpool.Size() > 0 && state.LastBlockHeight > evpool.pruningHeight &&\n\t\tstate.LastBlockTime.After(evpool.pruningTime) {\n\t\tevpool.pruningHeight, evpool.pruningTime = evpool.removeExpiredPendingEvidence()\n\t}\n}\n\n// AddEvidence checks the evidence is valid and adds it to the pool.\nfunc (evpool *Pool) AddEvidence(ev types.Evidence) error {\n\tevpool.logger.Debug(\"Attempting to add evidence\", \"ev\", ev)\n\n\t// We have already verified this piece of evidence - no need to do it again\n\tif evpool.isPending(ev) {\n\t\tevpool.logger.Info(\"Evidence already pending, ignoring this one\", \"ev\", ev)\n\t\treturn nil\n\t}\n\n\t// check that the evidence isn't already committed\n\tif evpool.isCommitted(ev) {\n\t\t// this can happen if the peer that sent us the evidence is behind so we shouldn't\n\t\t// punish the peer.\n\t\tevpool.logger.Debug(\"Evidence was already committed, ignoring this one\", \"ev\", ev)\n\t\treturn nil\n\t}\n\n\t// 1) Verify against state.\n\terr := evpool.verify(ev)\n\tif err != nil {\n\t\treturn types.NewErrInvalidEvidence(ev, err)\n\t}\n\n\t// 2) Save to store.\n\tif err := evpool.addPendingEvidence(ev); err != nil {\n\t\treturn fmt.Errorf(\"can't add evidence to pending list: %w\", err)\n\t}\n\n\t// 3) Add evidence to clist.\n\tevpool.evidenceList.PushBack(ev)\n\n\tevpool.logger.Info(\"Verified new evidence of byzantine behavior\", \"evidence\", ev)\n\n\treturn nil\n}\n\n// AddEvidenceFromConsensus should be exposed only to the consensus reactor so it can add evidence\n// to the pool directly without the need for verification.\nfunc (evpool *Pool) AddEvidenceFromConsensus(ev types.Evidence) error {\n\n\t// we already have this evidence, log this but don't return an error.\n\tif evpool.isPending(ev) {\n\t\tevpool.logger.Info(\"Evidence already pending, ignoring this one\", \"ev\", ev)\n\t\treturn nil\n\t}\n\n\t// add evidence to a buffer which will pass the evidence to the pool at the following height.\n\t// This avoids the issue of some nodes verifying and proposing evidence at a height where the\n\t// block hasn't been committed on cause others to potentially fail.\n\tevpool.mtx.Lock()\n\tdefer evpool.mtx.Unlock()\n\tevpool.consensusBuffer = append(evpool.consensusBuffer, ev)\n\tevpool.logger.Info(\"received new evidence of byzantine behavior from consensus\", \"evidence\", ev)\n\n\treturn nil\n}\n\n// CheckEvidence takes an array of evidence from a block and verifies all the evidence there.\n// If it has already verified the evidence then it jumps to the next one. It ensures that no\n// evidence has already been committed or is being proposed twice. It also adds any\n// evidence that it doesn't currently have so that it can quickly form ABCI Evidence later.\nfunc (evpool *Pool) CheckEvidence(evList types.EvidenceList) error {\n\thashes := make([][]byte, len(evList))\n\tfor idx, ev := range evList {\n\n\t\tok := evpool.fastCheck(ev)\n\n\t\tif !ok {\n\t\t\t// check that the evidence isn't already committed\n\t\t\tif evpool.isCommitted(ev) {\n\t\t\t\treturn &types.ErrInvalidEvidence{Evidence: ev, Reason: errors.New(\"evidence was already committed\")}\n\t\t\t}\n\n\t\t\terr := evpool.verify(ev)\n\t\t\tif err != nil {\n\t\t\t\treturn &types.ErrInvalidEvidence{Evidence: ev, Reason: err}\n\t\t\t}\n\n\t\t\tif err := evpool.addPendingEvidence(ev); err != nil {\n\t\t\t\t// Something went wrong with adding the evidence but we already know it is valid\n\t\t\t\t// hence we log an error and continue\n\t\t\t\tevpool.logger.Error(\"Can't add evidence to pending list\", \"err\", err, \"ev\", ev)\n\t\t\t}\n\n\t\t\tevpool.logger.Info(\"Verified new evidence of byzantine behavior\", \"evidence\", ev)\n\t\t}\n\n\t\t// check for duplicate evidence. We cache hashes so we don't have to work them out again.\n\t\thashes[idx] = ev.Hash()\n\t\tfor i := idx - 1; i >= 0; i-- {\n\t\t\tif bytes.Equal(hashes[i], hashes[idx]) {\n\t\t\t\treturn &types.ErrInvalidEvidence{Evidence: ev, Reason: errors.New(\"duplicate evidence\")}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// EvidenceFront goes to the first evidence in the clist\nfunc (evpool *Pool) EvidenceFront() *clist.CElement {\n\treturn evpool.evidenceList.Front()\n}\n\n// EvidenceWaitChan is a channel that closes once the first evidence in the list is there. i.e Front is not nil\nfunc (evpool *Pool) EvidenceWaitChan() <-chan struct{} {\n\treturn evpool.evidenceList.WaitChan()\n}\n\n// SetLogger sets the Logger.\nfunc (evpool *Pool) SetLogger(l log.Logger) {\n\tevpool.logger = l\n}\n\n// Size returns the number of evidence in the pool.\nfunc (evpool *Pool) Size() uint32 {\n\treturn atomic.LoadUint32(&evpool.evidenceSize)\n}\n\n// State returns the current state of the evpool.\nfunc (evpool *Pool) State() sm.State {\n\tevpool.mtx.Lock()\n\tdefer evpool.mtx.Unlock()\n\treturn evpool.state\n}\n\n//--------------------------------------------------------------------------\n\n// fastCheck leverages the fact that the evidence pool may have already verified the evidence to see if it can\n// quickly conclude that the evidence is already valid.\nfunc (evpool *Pool) fastCheck(ev types.Evidence) bool {\n\tif lcae, ok := ev.(*types.LightClientAttackEvidence); ok {\n\t\tkey := keyPending(ev)\n\t\tevBytes, err := evpool.evidenceStore.Get(key)\n\t\tif evBytes == nil { // the evidence is not in the nodes pending list\n\t\t\treturn false\n\t\t}\n\t\tif err != nil {\n\t\t\tevpool.logger.Error(\"Failed to load light client attack evidence\", \"err\", err, \"key(height/hash)\", key)\n\t\t\treturn false\n\t\t}\n\t\tvar trustedPb tmproto.LightClientAttackEvidence\n\t\terr = trustedPb.Unmarshal(evBytes)\n\t\tif err != nil {\n\t\t\tevpool.logger.Error(\"Failed to convert light client attack evidence from bytes\",\n\t\t\t\t\"err\", err, \"key(height/hash)\", key)\n\t\t\treturn false\n\t\t}\n\t\ttrustedEv, err := types.LightClientAttackEvidenceFromProto(&trustedPb)\n\t\tif err != nil {\n\t\t\tevpool.logger.Error(\"Failed to convert light client attack evidence from protobuf\",\n\t\t\t\t\"err\", err, \"key(height/hash)\", key)\n\t\t\treturn false\n\t\t}\n\t\t// ensure that all the byzantine validators that the evidence pool has match the byzantine validators\n\t\t// in this evidence\n\t\tif trustedEv.ByzantineValidators == nil && lcae.ByzantineValidators != nil {\n\t\t\treturn false\n\t\t}\n\n\t\tif len(trustedEv.ByzantineValidators) != len(lcae.ByzantineValidators) {\n\t\t\treturn false\n\t\t}\n\n\t\tbyzValsCopy := make([]*types.Validator, len(lcae.ByzantineValidators))\n\t\tfor i, v := range lcae.ByzantineValidators {\n\t\t\tbyzValsCopy[i] = v.Copy()\n\t\t}\n\n\t\t// ensure that both validator arrays are in the same order\n\t\tsort.Sort(types.ValidatorsByVotingPower(byzValsCopy))\n\n\t\tfor idx, val := range trustedEv.ByzantineValidators {\n\t\t\tif !bytes.Equal(byzValsCopy[idx].Address, val.Address) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif byzValsCopy[idx].VotingPower != val.VotingPower {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\treturn true\n\t}\n\n\t// for all other evidence the evidence pool just checks if it is already in the pending db\n\treturn evpool.isPending(ev)\n}\n\n// IsExpired checks whether evidence or a polc is expired by checking whether a height and time is older\n// than set by the evidence consensus parameters\nfunc (evpool *Pool) isExpired(height int64, time time.Time) bool {\n\tvar (\n\t\tparams       = evpool.State().ConsensusParams.Evidence\n\t\tageDuration  = evpool.State().LastBlockTime.Sub(time)\n\t\tageNumBlocks = evpool.State().LastBlockHeight - height\n\t)\n\treturn ageNumBlocks > params.MaxAgeNumBlocks &&\n\t\tageDuration > params.MaxAgeDuration\n}\n\n// IsCommitted returns true if we have already seen this exact evidence and it is already marked as committed.\nfunc (evpool *Pool) isCommitted(evidence types.Evidence) bool {\n\tkey := keyCommitted(evidence)\n\tok, err := evpool.evidenceStore.Has(key)\n\tif err != nil {\n\t\tevpool.logger.Error(\"Unable to find committed evidence\", \"err\", err)\n\t}\n\treturn ok\n}\n\n// IsPending checks whether the evidence is already pending. DB errors are passed to the logger.\nfunc (evpool *Pool) isPending(evidence types.Evidence) bool {\n\tkey := keyPending(evidence)\n\tok, err := evpool.evidenceStore.Has(key)\n\tif err != nil {\n\t\tevpool.logger.Error(\"Unable to find pending evidence\", \"err\", err)\n\t}\n\treturn ok\n}\n\nfunc (evpool *Pool) addPendingEvidence(ev types.Evidence) error {\n\tevpb, err := types.EvidenceToProto(ev)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to convert to proto, err: %w\", err)\n\t}\n\n\tevBytes, err := evpb.Marshal()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to marshal evidence: %w\", err)\n\t}\n\n\tkey := keyPending(ev)\n\n\terr = evpool.evidenceStore.Set(key, evBytes)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"can't persist evidence: %w\", err)\n\t}\n\tatomic.AddUint32(&evpool.evidenceSize, 1)\n\treturn nil\n}\n\nfunc (evpool *Pool) removePendingEvidence(evidence types.Evidence) {\n\tkey := keyPending(evidence)\n\tif err := evpool.evidenceStore.Delete(key); err != nil {\n\t\tevpool.logger.Error(\"Unable to delete pending evidence\", \"err\", err)\n\t} else {\n\t\tatomic.AddUint32(&evpool.evidenceSize, ^uint32(0))\n\t\tevpool.logger.Info(\"Deleted pending evidence\", \"evidence\", evidence)\n\t}\n}\n\n// markEvidenceAsCommitted processes all the evidence in the block, marking it as\n// committed and removing it from the pending database.\nfunc (evpool *Pool) markEvidenceAsCommitted(evidence types.EvidenceList) {\n\tblockEvidenceMap := make(map[string]struct{}, len(evidence))\n\tfor _, ev := range evidence {\n\t\tif evpool.isPending(ev) {\n\t\t\tevpool.removePendingEvidence(ev)\n\t\t\tblockEvidenceMap[evMapKey(ev)] = struct{}{}\n\t\t}\n\n\t\t// Add evidence to the committed list. As the evidence is stored in the block store\n\t\t// we only need to record the height that it was saved at.\n\t\tkey := keyCommitted(ev)\n\n\t\th := gogotypes.Int64Value{Value: ev.Height()}\n\t\tevBytes, err := proto.Marshal(&h)\n\t\tif err != nil {\n\t\t\tevpool.logger.Error(\"failed to marshal committed evidence\", \"err\", err, \"key(height/hash)\", key)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err := evpool.evidenceStore.Set(key, evBytes); err != nil {\n\t\t\tevpool.logger.Error(\"Unable to save committed evidence\", \"err\", err, \"key(height/hash)\", key)\n\t\t}\n\t}\n\n\t// remove committed evidence from the clist\n\tif len(blockEvidenceMap) != 0 {\n\t\tevpool.removeEvidenceFromList(blockEvidenceMap)\n\t}\n}\n\n// listEvidence retrieves lists evidence from oldest to newest within maxBytes.\n// If maxBytes is -1, there's no cap on the size of returned evidence.\nfunc (evpool *Pool) listEvidence(prefixKey byte, maxBytes int64) ([]types.Evidence, int64, error) {\n\tvar (\n\t\tevSize    int64\n\t\ttotalSize int64\n\t\tevidence  []types.Evidence\n\t\tevList    tmproto.EvidenceList // used for calculating the bytes size\n\t)\n\n\titer, err := dbm.IteratePrefix(evpool.evidenceStore, []byte{prefixKey})\n\tif err != nil {\n\t\treturn nil, totalSize, fmt.Errorf(\"database error: %v\", err)\n\t}\n\tdefer iter.Close()\n\tfor ; iter.Valid(); iter.Next() {\n\t\tvar evpb tmproto.Evidence\n\t\terr := evpb.Unmarshal(iter.Value())\n\t\tif err != nil {\n\t\t\treturn evidence, totalSize, err\n\t\t}\n\t\tevList.Evidence = append(evList.Evidence, evpb)\n\t\tevSize = int64(evList.Size())\n\t\tif maxBytes != -1 && evSize > maxBytes {\n\t\t\tif err := iter.Error(); err != nil {\n\t\t\t\treturn evidence, totalSize, err\n\t\t\t}\n\t\t\treturn evidence, totalSize, nil\n\t\t}\n\n\t\tev, err := types.EvidenceFromProto(&evpb)\n\t\tif err != nil {\n\t\t\treturn nil, totalSize, err\n\t\t}\n\n\t\ttotalSize = evSize\n\t\tevidence = append(evidence, ev)\n\t}\n\n\tif err := iter.Error(); err != nil {\n\t\treturn evidence, totalSize, err\n\t}\n\treturn evidence, totalSize, nil\n}\n\nfunc (evpool *Pool) removeExpiredPendingEvidence() (int64, time.Time) {\n\titer, err := dbm.IteratePrefix(evpool.evidenceStore, []byte{baseKeyPending})\n\tif err != nil {\n\t\tevpool.logger.Error(\"Unable to iterate over pending evidence\", \"err\", err)\n\t\treturn evpool.State().LastBlockHeight, evpool.State().LastBlockTime\n\t}\n\tdefer iter.Close()\n\tblockEvidenceMap := make(map[string]struct{})\n\tfor ; iter.Valid(); iter.Next() {\n\t\tev, err := bytesToEv(iter.Value())\n\t\tif err != nil {\n\t\t\tevpool.logger.Error(\"Error in transition evidence from protobuf\", \"err\", err)\n\t\t\tcontinue\n\t\t}\n\t\tif !evpool.isExpired(ev.Height(), ev.Time()) {\n\t\t\tif len(blockEvidenceMap) != 0 {\n\t\t\t\tevpool.removeEvidenceFromList(blockEvidenceMap)\n\t\t\t}\n\n\t\t\t// return the height and time with which this evidence will have expired so we know when to prune next\n\t\t\treturn ev.Height() + evpool.State().ConsensusParams.Evidence.MaxAgeNumBlocks + 1,\n\t\t\t\tev.Time().Add(evpool.State().ConsensusParams.Evidence.MaxAgeDuration).Add(time.Second)\n\t\t}\n\t\tevpool.removePendingEvidence(ev)\n\t\tblockEvidenceMap[evMapKey(ev)] = struct{}{}\n\t}\n\t// We either have no pending evidence or all evidence has expired\n\tif len(blockEvidenceMap) != 0 {\n\t\tevpool.removeEvidenceFromList(blockEvidenceMap)\n\t}\n\treturn evpool.State().LastBlockHeight, evpool.State().LastBlockTime\n}\n\nfunc (evpool *Pool) removeEvidenceFromList(\n\tblockEvidenceMap map[string]struct{}) {\n\n\tfor e := evpool.evidenceList.Front(); e != nil; e = e.Next() {\n\t\t// Remove from clist\n\t\tev := e.Value.(types.Evidence)\n\t\tif _, ok := blockEvidenceMap[evMapKey(ev)]; ok {\n\t\t\tevpool.evidenceList.Remove(e)\n\t\t\te.DetachPrev()\n\t\t}\n\t}\n}\n\n// flushConsensusBuffer moves the evidence produced from consensus into the evidence pool\n// and list so that it can be broadcasted and proposed\nfunc (evpool *Pool) flushConsensusBuffer() {\n\tfor _, ev := range evpool.consensusBuffer {\n\t\tif err := evpool.addPendingEvidence(ev); err != nil {\n\t\t\tevpool.logger.Error(\"failed to flush evidence from consensus buffer to pending list: %w\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tevpool.evidenceList.PushBack(ev)\n\t}\n\t// reset consensus buffer\n\tevpool.consensusBuffer = make([]types.Evidence, 0)\n}\n\nfunc bytesToEv(evBytes []byte) (types.Evidence, error) {\n\tvar evpb tmproto.Evidence\n\terr := evpb.Unmarshal(evBytes)\n\tif err != nil {\n\t\treturn &types.DuplicateVoteEvidence{}, err\n\t}\n\n\treturn types.EvidenceFromProto(&evpb)\n}\n\nfunc evMapKey(ev types.Evidence) string {\n\treturn string(ev.Hash())\n}\n\n// big endian padded hex\nfunc bE(h int64) string {\n\treturn fmt.Sprintf(\"%0.16X\", h)\n}\n\nfunc keyCommitted(evidence types.Evidence) []byte {\n\treturn append([]byte{baseKeyCommitted}, keySuffix(evidence)...)\n}\n\nfunc keyPending(evidence types.Evidence) []byte {\n\treturn append([]byte{baseKeyPending}, keySuffix(evidence)...)\n}\n\nfunc keySuffix(evidence types.Evidence) []byte {\n\treturn []byte(fmt.Sprintf(\"%s/%X\", bE(evidence.Height()), evidence.Hash()))\n}\n", "package evidence_test\n\nimport (\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/mock\"\n\t\"github.com/stretchr/testify/require\"\n\n\tdbm \"github.com/tendermint/tm-db\"\n\n\t\"github.com/tendermint/tendermint/evidence\"\n\t\"github.com/tendermint/tendermint/evidence/mocks\"\n\t\"github.com/tendermint/tendermint/libs/log\"\n\ttmproto \"github.com/tendermint/tendermint/proto/tendermint/types\"\n\ttmversion \"github.com/tendermint/tendermint/proto/tendermint/version\"\n\tsm \"github.com/tendermint/tendermint/state\"\n\tsmmocks \"github.com/tendermint/tendermint/state/mocks\"\n\t\"github.com/tendermint/tendermint/store\"\n\t\"github.com/tendermint/tendermint/types\"\n\t\"github.com/tendermint/tendermint/version\"\n)\n\nfunc TestMain(m *testing.M) {\n\n\tcode := m.Run()\n\tos.Exit(code)\n}\n\nconst evidenceChainID = \"test_chain\"\n\nvar (\n\tdefaultEvidenceTime           = time.Date(2019, 1, 1, 0, 0, 0, 0, time.UTC)\n\tdefaultEvidenceMaxBytes int64 = 1000\n)\n\nfunc TestEvidencePoolBasic(t *testing.T) {\n\tvar (\n\t\theight     = int64(1)\n\t\tstateStore = &smmocks.Store{}\n\t\tevidenceDB = dbm.NewMemDB()\n\t\tblockStore = &mocks.BlockStore{}\n\t)\n\n\tvalSet, privVals := types.RandValidatorSet(1, 10)\n\n\tblockStore.On(\"LoadBlockMeta\", mock.AnythingOfType(\"int64\")).Return(\n\t\t&types.BlockMeta{Header: types.Header{Time: defaultEvidenceTime}},\n\t)\n\tstateStore.On(\"LoadValidators\", mock.AnythingOfType(\"int64\")).Return(valSet, nil)\n\tstateStore.On(\"Load\").Return(createState(height+1, valSet), nil)\n\n\tpool, err := evidence.NewPool(evidenceDB, stateStore, blockStore)\n\trequire.NoError(t, err)\n\tpool.SetLogger(log.TestingLogger())\n\n\t// evidence not seen yet:\n\tevs, size := pool.PendingEvidence(defaultEvidenceMaxBytes)\n\tassert.Equal(t, 0, len(evs))\n\tassert.Zero(t, size)\n\n\tev := types.NewMockDuplicateVoteEvidenceWithValidator(height, defaultEvidenceTime, privVals[0], evidenceChainID)\n\n\t// good evidence\n\tevAdded := make(chan struct{})\n\tgo func() {\n\t\t<-pool.EvidenceWaitChan()\n\t\tclose(evAdded)\n\t}()\n\n\t// evidence seen but not yet committed:\n\tassert.NoError(t, pool.AddEvidence(ev))\n\n\tselect {\n\tcase <-evAdded:\n\tcase <-time.After(5 * time.Second):\n\t\tt.Fatal(\"evidence was not added to list after 5s\")\n\t}\n\n\tnext := pool.EvidenceFront()\n\tassert.Equal(t, ev, next.Value.(types.Evidence))\n\n\tconst evidenceBytes int64 = 372\n\tevs, size = pool.PendingEvidence(evidenceBytes)\n\tassert.Equal(t, 1, len(evs))\n\tassert.Equal(t, evidenceBytes, size) // check that the size of the single evidence in bytes is correct\n\n\t// shouldn't be able to add evidence twice\n\tassert.NoError(t, pool.AddEvidence(ev))\n\tevs, _ = pool.PendingEvidence(defaultEvidenceMaxBytes)\n\tassert.Equal(t, 1, len(evs))\n\n}\n\n// Tests inbound evidence for the right time and height\nfunc TestAddExpiredEvidence(t *testing.T) {\n\tvar (\n\t\tval                 = types.NewMockPV()\n\t\theight              = int64(30)\n\t\tstateStore          = initializeValidatorState(val, height)\n\t\tevidenceDB          = dbm.NewMemDB()\n\t\tblockStore          = &mocks.BlockStore{}\n\t\texpiredEvidenceTime = time.Date(2018, 1, 1, 0, 0, 0, 0, time.UTC)\n\t\texpiredHeight       = int64(2)\n\t)\n\n\tblockStore.On(\"LoadBlockMeta\", mock.AnythingOfType(\"int64\")).Return(func(h int64) *types.BlockMeta {\n\t\tif h == height || h == expiredHeight {\n\t\t\treturn &types.BlockMeta{Header: types.Header{Time: defaultEvidenceTime}}\n\t\t}\n\t\treturn &types.BlockMeta{Header: types.Header{Time: expiredEvidenceTime}}\n\t})\n\n\tpool, err := evidence.NewPool(evidenceDB, stateStore, blockStore)\n\trequire.NoError(t, err)\n\n\ttestCases := []struct {\n\t\tevHeight      int64\n\t\tevTime        time.Time\n\t\texpErr        bool\n\t\tevDescription string\n\t}{\n\t\t{height, defaultEvidenceTime, false, \"valid evidence\"},\n\t\t{expiredHeight, defaultEvidenceTime, false, \"valid evidence (despite old height)\"},\n\t\t{height - 1, expiredEvidenceTime, false, \"valid evidence (despite old time)\"},\n\t\t{expiredHeight - 1, expiredEvidenceTime, true,\n\t\t\t\"evidence from height 1 (created at: 2019-01-01 00:00:00 +0000 UTC) is too old\"},\n\t\t{height, defaultEvidenceTime.Add(1 * time.Minute), true, \"evidence time and block time is different\"},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tt.Run(tc.evDescription, func(t *testing.T) {\n\t\t\tev := types.NewMockDuplicateVoteEvidenceWithValidator(tc.evHeight, tc.evTime, val, evidenceChainID)\n\t\t\terr := pool.AddEvidence(ev)\n\t\t\tif tc.expErr {\n\t\t\t\tassert.Error(t, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestAddEvidenceFromConsensus(t *testing.T) {\n\tvar height int64 = 10\n\tpool, val := defaultTestPool(height)\n\tev := types.NewMockDuplicateVoteEvidenceWithValidator(height, defaultEvidenceTime, val, evidenceChainID)\n\n\trequire.NoError(t, pool.AddEvidenceFromConsensus(ev))\n\n\t// evidence from consensus should not be added immediately but reside in the consensus buffer\n\tevList, evSize := pool.PendingEvidence(defaultEvidenceMaxBytes)\n\trequire.Empty(t, evList)\n\trequire.Zero(t, evSize)\n\n\tnext := pool.EvidenceFront()\n\trequire.Nil(t, next)\n\n\t// move to next height and update state and evidence pool\n\tstate := pool.State()\n\tstate.LastBlockHeight++\n\tpool.Update(state, []types.Evidence{})\n\n\t// should be able to retrieve evidence from pool\n\tevList, _ = pool.PendingEvidence(defaultEvidenceMaxBytes)\n\trequire.Equal(t, []types.Evidence{ev}, evList)\n\n\t// shouldn't be able to submit the same evidence twice\n\trequire.NoError(t, pool.AddEvidenceFromConsensus(ev))\n\tstate = pool.State()\n\tstate.LastBlockHeight++\n\tpool.Update(state, []types.Evidence{})\n\tevList2, _ := pool.PendingEvidence(defaultEvidenceMaxBytes)\n\trequire.Equal(t, evList, evList2)\n}\n\nfunc TestEvidencePoolUpdate(t *testing.T) {\n\theight := int64(21)\n\tpool, val := defaultTestPool(height)\n\tstate := pool.State()\n\n\t// create new block (no need to save it to blockStore)\n\tprunedEv := types.NewMockDuplicateVoteEvidenceWithValidator(1, defaultEvidenceTime.Add(1*time.Minute),\n\t\tval, evidenceChainID)\n\terr := pool.AddEvidence(prunedEv)\n\trequire.NoError(t, err)\n\tev := types.NewMockDuplicateVoteEvidenceWithValidator(height, defaultEvidenceTime.Add(21*time.Minute),\n\t\tval, evidenceChainID)\n\tlastCommit := makeCommit(height, val.PrivKey.PubKey().Address())\n\tblock := types.MakeBlock(height+1, []types.Tx{}, lastCommit, []types.Evidence{ev})\n\t// update state (partially)\n\tstate.LastBlockHeight = height + 1\n\tstate.LastBlockTime = defaultEvidenceTime.Add(22 * time.Minute)\n\terr = pool.CheckEvidence(types.EvidenceList{ev})\n\trequire.NoError(t, err)\n\n\tpool.Update(state, block.Evidence.Evidence)\n\t// a) Update marks evidence as committed so pending evidence should be empty\n\tevList, evSize := pool.PendingEvidence(defaultEvidenceMaxBytes)\n\tassert.Empty(t, evList)\n\tassert.Zero(t, evSize)\n\n\t// b) If we try to check this evidence again it should fail because it has already been committed\n\terr = pool.CheckEvidence(types.EvidenceList{ev})\n\tif assert.Error(t, err) {\n\t\tassert.Equal(t, \"evidence was already committed\", err.(*types.ErrInvalidEvidence).Reason.Error())\n\t}\n}\n\nfunc TestVerifyPendingEvidencePasses(t *testing.T) {\n\tvar height int64 = 1\n\tpool, val := defaultTestPool(height)\n\tev := types.NewMockDuplicateVoteEvidenceWithValidator(height, defaultEvidenceTime.Add(1*time.Minute),\n\t\tval, evidenceChainID)\n\terr := pool.AddEvidence(ev)\n\trequire.NoError(t, err)\n\n\terr = pool.CheckEvidence(types.EvidenceList{ev})\n\tassert.NoError(t, err)\n}\n\nfunc TestVerifyDuplicatedEvidenceFails(t *testing.T) {\n\tvar height int64 = 1\n\tpool, val := defaultTestPool(height)\n\tev := types.NewMockDuplicateVoteEvidenceWithValidator(height, defaultEvidenceTime.Add(1*time.Minute),\n\t\tval, evidenceChainID)\n\terr := pool.CheckEvidence(types.EvidenceList{ev, ev})\n\tif assert.Error(t, err) {\n\t\tassert.Equal(t, \"duplicate evidence\", err.(*types.ErrInvalidEvidence).Reason.Error())\n\t}\n}\n\n// check that valid light client evidence is correctly validated and stored in\n// evidence pool\nfunc TestCheckEvidenceWithLightClientAttack(t *testing.T) {\n\tvar (\n\t\tnValidators          = 5\n\t\tvalidatorPower int64 = 10\n\t\theight         int64 = 10\n\t)\n\tconflictingVals, conflictingPrivVals := types.RandValidatorSet(nValidators, validatorPower)\n\ttrustedHeader := makeHeaderRandom(height)\n\ttrustedHeader.Time = defaultEvidenceTime\n\n\tconflictingHeader := makeHeaderRandom(height)\n\tconflictingHeader.ValidatorsHash = conflictingVals.Hash()\n\n\ttrustedHeader.ValidatorsHash = conflictingHeader.ValidatorsHash\n\ttrustedHeader.NextValidatorsHash = conflictingHeader.NextValidatorsHash\n\ttrustedHeader.ConsensusHash = conflictingHeader.ConsensusHash\n\ttrustedHeader.AppHash = conflictingHeader.AppHash\n\ttrustedHeader.LastResultsHash = conflictingHeader.LastResultsHash\n\n\t// for simplicity we are simulating a duplicate vote attack where all the validators in the\n\t// conflictingVals set voted twice\n\tblockID := makeBlockID(conflictingHeader.Hash(), 1000, []byte(\"partshash\"))\n\tvoteSet := types.NewVoteSet(evidenceChainID, height, 1, tmproto.SignedMsgType(2), conflictingVals)\n\tcommit, err := types.MakeCommit(blockID, height, 1, voteSet, conflictingPrivVals, defaultEvidenceTime)\n\trequire.NoError(t, err)\n\tev := &types.LightClientAttackEvidence{\n\t\tConflictingBlock: &types.LightBlock{\n\t\t\tSignedHeader: &types.SignedHeader{\n\t\t\t\tHeader: conflictingHeader,\n\t\t\t\tCommit: commit,\n\t\t\t},\n\t\t\tValidatorSet: conflictingVals,\n\t\t},\n\t\tCommonHeight:        10,\n\t\tTotalVotingPower:    int64(nValidators) * validatorPower,\n\t\tByzantineValidators: conflictingVals.Validators,\n\t\tTimestamp:           defaultEvidenceTime,\n\t}\n\n\ttrustedBlockID := makeBlockID(trustedHeader.Hash(), 1000, []byte(\"partshash\"))\n\ttrustedVoteSet := types.NewVoteSet(evidenceChainID, height, 1, tmproto.SignedMsgType(2), conflictingVals)\n\ttrustedCommit, err := types.MakeCommit(trustedBlockID, height, 1, trustedVoteSet, conflictingPrivVals,\n\t\tdefaultEvidenceTime)\n\trequire.NoError(t, err)\n\n\tstate := sm.State{\n\t\tLastBlockTime:   defaultEvidenceTime.Add(1 * time.Minute),\n\t\tLastBlockHeight: 11,\n\t\tConsensusParams: *types.DefaultConsensusParams(),\n\t}\n\tstateStore := &smmocks.Store{}\n\tstateStore.On(\"LoadValidators\", height).Return(conflictingVals, nil)\n\tstateStore.On(\"Load\").Return(state, nil)\n\tblockStore := &mocks.BlockStore{}\n\tblockStore.On(\"LoadBlockMeta\", height).Return(&types.BlockMeta{Header: *trustedHeader})\n\tblockStore.On(\"LoadBlockCommit\", height).Return(trustedCommit)\n\n\tpool, err := evidence.NewPool(dbm.NewMemDB(), stateStore, blockStore)\n\trequire.NoError(t, err)\n\tpool.SetLogger(log.TestingLogger())\n\n\terr = pool.AddEvidence(ev)\n\tassert.NoError(t, err)\n\n\terr = pool.CheckEvidence(types.EvidenceList{ev})\n\tassert.NoError(t, err)\n\n\t// take away the last signature -> there are less validators then what we have detected,\n\t// hence this should fail\n\tcommit.Signatures = append(commit.Signatures[:nValidators-1], types.NewCommitSigAbsent())\n\terr = pool.CheckEvidence(types.EvidenceList{ev})\n\tassert.Error(t, err)\n}\n\n// Tests that restarting the evidence pool after a potential failure will recover the\n// pending evidence and continue to gossip it\nfunc TestRecoverPendingEvidence(t *testing.T) {\n\theight := int64(10)\n\tval := types.NewMockPV()\n\tvalAddress := val.PrivKey.PubKey().Address()\n\tevidenceDB := dbm.NewMemDB()\n\tstateStore := initializeValidatorState(val, height)\n\tstate, err := stateStore.Load()\n\trequire.NoError(t, err)\n\tblockStore := initializeBlockStore(dbm.NewMemDB(), state, valAddress)\n\t// create previous pool and populate it\n\tpool, err := evidence.NewPool(evidenceDB, stateStore, blockStore)\n\trequire.NoError(t, err)\n\tpool.SetLogger(log.TestingLogger())\n\tgoodEvidence := types.NewMockDuplicateVoteEvidenceWithValidator(height,\n\t\tdefaultEvidenceTime.Add(10*time.Minute), val, evidenceChainID)\n\texpiredEvidence := types.NewMockDuplicateVoteEvidenceWithValidator(int64(1),\n\t\tdefaultEvidenceTime.Add(1*time.Minute), val, evidenceChainID)\n\terr = pool.AddEvidence(goodEvidence)\n\trequire.NoError(t, err)\n\terr = pool.AddEvidence(expiredEvidence)\n\trequire.NoError(t, err)\n\n\t// now recover from the previous pool at a different time\n\tnewStateStore := &smmocks.Store{}\n\tnewStateStore.On(\"Load\").Return(sm.State{\n\t\tLastBlockTime:   defaultEvidenceTime.Add(25 * time.Minute),\n\t\tLastBlockHeight: height + 15,\n\t\tConsensusParams: tmproto.ConsensusParams{\n\t\t\tBlock: tmproto.BlockParams{\n\t\t\t\tMaxBytes: 22020096,\n\t\t\t\tMaxGas:   -1,\n\t\t\t},\n\t\t\tEvidence: tmproto.EvidenceParams{\n\t\t\t\tMaxAgeNumBlocks: 20,\n\t\t\t\tMaxAgeDuration:  20 * time.Minute,\n\t\t\t\tMaxBytes:        1000,\n\t\t\t},\n\t\t},\n\t}, nil)\n\tnewPool, err := evidence.NewPool(evidenceDB, newStateStore, blockStore)\n\tassert.NoError(t, err)\n\tevList, _ := newPool.PendingEvidence(defaultEvidenceMaxBytes)\n\tassert.Equal(t, 1, len(evList))\n\tnext := newPool.EvidenceFront()\n\tassert.Equal(t, goodEvidence, next.Value.(types.Evidence))\n\n}\n\nfunc initializeStateFromValidatorSet(valSet *types.ValidatorSet, height int64) sm.Store {\n\tstateDB := dbm.NewMemDB()\n\tstateStore := sm.NewStore(stateDB)\n\tstate := sm.State{\n\t\tChainID:                     evidenceChainID,\n\t\tInitialHeight:               1,\n\t\tLastBlockHeight:             height,\n\t\tLastBlockTime:               defaultEvidenceTime,\n\t\tValidators:                  valSet,\n\t\tNextValidators:              valSet.CopyIncrementProposerPriority(1),\n\t\tLastValidators:              valSet,\n\t\tLastHeightValidatorsChanged: 1,\n\t\tConsensusParams: tmproto.ConsensusParams{\n\t\t\tBlock: tmproto.BlockParams{\n\t\t\t\tMaxBytes: 22020096,\n\t\t\t\tMaxGas:   -1,\n\t\t\t},\n\t\t\tEvidence: tmproto.EvidenceParams{\n\t\t\t\tMaxAgeNumBlocks: 20,\n\t\t\t\tMaxAgeDuration:  20 * time.Minute,\n\t\t\t\tMaxBytes:        1000,\n\t\t\t},\n\t\t},\n\t}\n\n\t// save all states up to height\n\tfor i := int64(0); i <= height; i++ {\n\t\tstate.LastBlockHeight = i\n\t\tif err := stateStore.Save(state); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\treturn stateStore\n}\n\nfunc initializeValidatorState(privVal types.PrivValidator, height int64) sm.Store {\n\n\tpubKey, _ := privVal.GetPubKey()\n\tvalidator := &types.Validator{Address: pubKey.Address(), VotingPower: 10, PubKey: pubKey}\n\n\t// create validator set and state\n\tvalSet := &types.ValidatorSet{\n\t\tValidators: []*types.Validator{validator},\n\t\tProposer:   validator,\n\t}\n\n\treturn initializeStateFromValidatorSet(valSet, height)\n}\n\n// initializeBlockStore creates a block storage and populates it w/ a dummy\n// block at +height+.\nfunc initializeBlockStore(db dbm.DB, state sm.State, valAddr []byte) *store.BlockStore {\n\tblockStore := store.NewBlockStore(db)\n\n\tfor i := int64(1); i <= state.LastBlockHeight; i++ {\n\t\tlastCommit := makeCommit(i-1, valAddr)\n\t\tblock, _ := state.MakeBlock(i, []types.Tx{}, lastCommit, nil,\n\t\t\tstate.Validators.GetProposer().Address)\n\t\tblock.Header.Time = defaultEvidenceTime.Add(time.Duration(i) * time.Minute)\n\t\tblock.Header.Version = tmversion.Consensus{Block: version.BlockProtocol, App: 1}\n\t\tconst parts = 1\n\t\tpartSet := block.MakePartSet(parts)\n\n\t\tseenCommit := makeCommit(i, valAddr)\n\t\tblockStore.SaveBlock(block, partSet, seenCommit)\n\t}\n\n\treturn blockStore\n}\n\nfunc makeCommit(height int64, valAddr []byte) *types.Commit {\n\tcommitSigs := []types.CommitSig{{\n\t\tBlockIDFlag:      types.BlockIDFlagCommit,\n\t\tValidatorAddress: valAddr,\n\t\tTimestamp:        defaultEvidenceTime,\n\t\tSignature:        []byte(\"Signature\"),\n\t}}\n\treturn types.NewCommit(height, 0, types.BlockID{}, commitSigs)\n}\n\nfunc defaultTestPool(height int64) (*evidence.Pool, types.MockPV) {\n\tval := types.NewMockPV()\n\tvalAddress := val.PrivKey.PubKey().Address()\n\tevidenceDB := dbm.NewMemDB()\n\tstateStore := initializeValidatorState(val, height)\n\tstate, _ := stateStore.Load()\n\tblockStore := initializeBlockStore(dbm.NewMemDB(), state, valAddress)\n\tpool, err := evidence.NewPool(evidenceDB, stateStore, blockStore)\n\tif err != nil {\n\t\tpanic(\"test evidence pool could not be created\")\n\t}\n\tpool.SetLogger(log.TestingLogger())\n\treturn pool, val\n}\n\nfunc createState(height int64, valSet *types.ValidatorSet) sm.State {\n\treturn sm.State{\n\t\tChainID:         evidenceChainID,\n\t\tLastBlockHeight: height,\n\t\tLastBlockTime:   defaultEvidenceTime,\n\t\tValidators:      valSet,\n\t\tConsensusParams: *types.DefaultConsensusParams(),\n\t}\n}\n", "package node\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"syscall\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\tdbm \"github.com/tendermint/tm-db\"\n\n\t\"github.com/tendermint/tendermint/abci/example/kvstore\"\n\tcfg \"github.com/tendermint/tendermint/config\"\n\t\"github.com/tendermint/tendermint/crypto/ed25519\"\n\t\"github.com/tendermint/tendermint/evidence\"\n\t\"github.com/tendermint/tendermint/libs/log\"\n\ttmrand \"github.com/tendermint/tendermint/libs/rand\"\n\tmempl \"github.com/tendermint/tendermint/mempool\"\n\t\"github.com/tendermint/tendermint/p2p\"\n\tp2pmock \"github.com/tendermint/tendermint/p2p/mock\"\n\t\"github.com/tendermint/tendermint/privval\"\n\t\"github.com/tendermint/tendermint/proxy\"\n\tsm \"github.com/tendermint/tendermint/state\"\n\t\"github.com/tendermint/tendermint/store\"\n\t\"github.com/tendermint/tendermint/types\"\n\ttmtime \"github.com/tendermint/tendermint/types/time\"\n)\n\nfunc TestNodeStartStop(t *testing.T) {\n\tconfig := cfg.ResetTestRoot(\"node_node_test\")\n\tdefer os.RemoveAll(config.RootDir)\n\n\t// create & start node\n\tn, err := DefaultNewNode(config, log.TestingLogger())\n\trequire.NoError(t, err)\n\terr = n.Start()\n\trequire.NoError(t, err)\n\n\tt.Logf(\"Started node %v\", n.sw.NodeInfo())\n\n\t// wait for the node to produce a block\n\tblocksSub, err := n.EventBus().Subscribe(context.Background(), \"node_test\", types.EventQueryNewBlock)\n\trequire.NoError(t, err)\n\tselect {\n\tcase <-blocksSub.Out():\n\tcase <-blocksSub.Cancelled():\n\t\tt.Fatal(\"blocksSub was cancelled\")\n\tcase <-time.After(10 * time.Second):\n\t\tt.Fatal(\"timed out waiting for the node to produce a block\")\n\t}\n\n\t// stop the node\n\tgo func() {\n\t\terr = n.Stop()\n\t\trequire.NoError(t, err)\n\t}()\n\n\tselect {\n\tcase <-n.Quit():\n\tcase <-time.After(5 * time.Second):\n\t\tpid := os.Getpid()\n\t\tp, err := os.FindProcess(pid)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\terr = p.Signal(syscall.SIGABRT)\n\t\tfmt.Println(err)\n\t\tt.Fatal(\"timed out waiting for shutdown\")\n\t}\n}\n\nfunc TestSplitAndTrimEmpty(t *testing.T) {\n\ttestCases := []struct {\n\t\ts        string\n\t\tsep      string\n\t\tcutset   string\n\t\texpected []string\n\t}{\n\t\t{\"a,b,c\", \",\", \" \", []string{\"a\", \"b\", \"c\"}},\n\t\t{\" a , b , c \", \",\", \" \", []string{\"a\", \"b\", \"c\"}},\n\t\t{\" a, b, c \", \",\", \" \", []string{\"a\", \"b\", \"c\"}},\n\t\t{\" a, \", \",\", \" \", []string{\"a\"}},\n\t\t{\"   \", \",\", \" \", []string{}},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tassert.Equal(t, tc.expected, splitAndTrimEmpty(tc.s, tc.sep, tc.cutset), \"%s\", tc.s)\n\t}\n}\n\nfunc TestNodeDelayedStart(t *testing.T) {\n\tconfig := cfg.ResetTestRoot(\"node_delayed_start_test\")\n\tdefer os.RemoveAll(config.RootDir)\n\tnow := tmtime.Now()\n\n\t// create & start node\n\tn, err := DefaultNewNode(config, log.TestingLogger())\n\tn.GenesisDoc().GenesisTime = now.Add(2 * time.Second)\n\trequire.NoError(t, err)\n\n\terr = n.Start()\n\trequire.NoError(t, err)\n\tdefer n.Stop() //nolint:errcheck // ignore for tests\n\n\tstartTime := tmtime.Now()\n\tassert.Equal(t, true, startTime.After(n.GenesisDoc().GenesisTime))\n}\n\nfunc TestNodeSetAppVersion(t *testing.T) {\n\tconfig := cfg.ResetTestRoot(\"node_app_version_test\")\n\tdefer os.RemoveAll(config.RootDir)\n\n\t// create & start node\n\tn, err := DefaultNewNode(config, log.TestingLogger())\n\trequire.NoError(t, err)\n\n\t// default config uses the kvstore app\n\tvar appVersion uint64 = kvstore.ProtocolVersion\n\n\t// check version is set in state\n\tstate, err := n.stateStore.Load()\n\trequire.NoError(t, err)\n\tassert.Equal(t, state.Version.Consensus.App, appVersion)\n\n\t// check version is set in node info\n\tassert.Equal(t, n.nodeInfo.(p2p.DefaultNodeInfo).ProtocolVersion.App, appVersion)\n}\n\nfunc TestNodeSetPrivValTCP(t *testing.T) {\n\taddr := \"tcp://\" + testFreeAddr(t)\n\n\tconfig := cfg.ResetTestRoot(\"node_priv_val_tcp_test\")\n\tdefer os.RemoveAll(config.RootDir)\n\tconfig.BaseConfig.PrivValidatorListenAddr = addr\n\n\tdialer := privval.DialTCPFn(addr, 100*time.Millisecond, ed25519.GenPrivKey())\n\tdialerEndpoint := privval.NewSignerDialerEndpoint(\n\t\tlog.TestingLogger(),\n\t\tdialer,\n\t)\n\tprivval.SignerDialerEndpointTimeoutReadWrite(100 * time.Millisecond)(dialerEndpoint)\n\n\tsignerServer := privval.NewSignerServer(\n\t\tdialerEndpoint,\n\t\tconfig.ChainID(),\n\t\ttypes.NewMockPV(),\n\t)\n\n\tgo func() {\n\t\terr := signerServer.Start()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\tdefer signerServer.Stop() //nolint:errcheck // ignore for tests\n\n\tn, err := DefaultNewNode(config, log.TestingLogger())\n\trequire.NoError(t, err)\n\tassert.IsType(t, &privval.RetrySignerClient{}, n.PrivValidator())\n}\n\n// address without a protocol must result in error\nfunc TestPrivValidatorListenAddrNoProtocol(t *testing.T) {\n\taddrNoPrefix := testFreeAddr(t)\n\n\tconfig := cfg.ResetTestRoot(\"node_priv_val_tcp_test\")\n\tdefer os.RemoveAll(config.RootDir)\n\tconfig.BaseConfig.PrivValidatorListenAddr = addrNoPrefix\n\n\t_, err := DefaultNewNode(config, log.TestingLogger())\n\tassert.Error(t, err)\n}\n\nfunc TestNodeSetPrivValIPC(t *testing.T) {\n\ttmpfile := \"/tmp/kms.\" + tmrand.Str(6) + \".sock\"\n\tdefer os.Remove(tmpfile) // clean up\n\n\tconfig := cfg.ResetTestRoot(\"node_priv_val_tcp_test\")\n\tdefer os.RemoveAll(config.RootDir)\n\tconfig.BaseConfig.PrivValidatorListenAddr = \"unix://\" + tmpfile\n\n\tdialer := privval.DialUnixFn(tmpfile)\n\tdialerEndpoint := privval.NewSignerDialerEndpoint(\n\t\tlog.TestingLogger(),\n\t\tdialer,\n\t)\n\tprivval.SignerDialerEndpointTimeoutReadWrite(100 * time.Millisecond)(dialerEndpoint)\n\n\tpvsc := privval.NewSignerServer(\n\t\tdialerEndpoint,\n\t\tconfig.ChainID(),\n\t\ttypes.NewMockPV(),\n\t)\n\n\tgo func() {\n\t\terr := pvsc.Start()\n\t\trequire.NoError(t, err)\n\t}()\n\tdefer pvsc.Stop() //nolint:errcheck // ignore for tests\n\n\tn, err := DefaultNewNode(config, log.TestingLogger())\n\trequire.NoError(t, err)\n\tassert.IsType(t, &privval.RetrySignerClient{}, n.PrivValidator())\n}\n\n// testFreeAddr claims a free port so we don't block on listener being ready.\nfunc testFreeAddr(t *testing.T) string {\n\tln, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\trequire.NoError(t, err)\n\tdefer ln.Close()\n\n\treturn fmt.Sprintf(\"127.0.0.1:%d\", ln.Addr().(*net.TCPAddr).Port)\n}\n\n// create a proposal block using real and full\n// mempool and evidence pool and validate it.\nfunc TestCreateProposalBlock(t *testing.T) {\n\tconfig := cfg.ResetTestRoot(\"node_create_proposal\")\n\tdefer os.RemoveAll(config.RootDir)\n\tcc := proxy.NewLocalClientCreator(kvstore.NewApplication())\n\tproxyApp := proxy.NewAppConns(cc)\n\terr := proxyApp.Start()\n\trequire.Nil(t, err)\n\tdefer proxyApp.Stop() //nolint:errcheck // ignore for tests\n\n\tlogger := log.TestingLogger()\n\n\tvar height int64 = 1\n\tstate, stateDB, privVals := state(1, height)\n\tstateStore := sm.NewStore(stateDB)\n\tmaxBytes := 16384\n\tvar partSize uint32 = 256\n\tmaxEvidenceBytes := int64(maxBytes / 2)\n\tstate.ConsensusParams.Block.MaxBytes = int64(maxBytes)\n\tstate.ConsensusParams.Evidence.MaxBytes = maxEvidenceBytes\n\tproposerAddr, _ := state.Validators.GetByIndex(0)\n\n\t// Make Mempool\n\tmemplMetrics := mempl.PrometheusMetrics(\"node_test_1\")\n\tmempool := mempl.NewCListMempool(\n\t\tconfig.Mempool,\n\t\tproxyApp.Mempool(),\n\t\tstate.LastBlockHeight,\n\t\tmempl.WithMetrics(memplMetrics),\n\t\tmempl.WithPreCheck(sm.TxPreCheck(state)),\n\t\tmempl.WithPostCheck(sm.TxPostCheck(state)),\n\t)\n\tmempool.SetLogger(logger)\n\n\t// Make EvidencePool\n\tevidenceDB := dbm.NewMemDB()\n\tblockStore := store.NewBlockStore(dbm.NewMemDB())\n\tevidencePool, err := evidence.NewPool(evidenceDB, stateStore, blockStore)\n\trequire.NoError(t, err)\n\tevidencePool.SetLogger(logger)\n\n\t// fill the evidence pool with more evidence\n\t// than can fit in a block\n\tvar currentBytes int64 = 0\n\tfor currentBytes <= maxEvidenceBytes {\n\t\tev := types.NewMockDuplicateVoteEvidenceWithValidator(height, time.Now(), privVals[0], \"test-chain\")\n\t\tcurrentBytes += int64(len(ev.Bytes()))\n\t\terr := evidencePool.AddEvidenceFromConsensus(ev)\n\t\trequire.NoError(t, err)\n\t}\n\n\tevList, size := evidencePool.PendingEvidence(state.ConsensusParams.Evidence.MaxBytes)\n\trequire.Less(t, size, state.ConsensusParams.Evidence.MaxBytes+1)\n\tevData := &types.EvidenceData{Evidence: evList}\n\trequire.EqualValues(t, size, evData.ByteSize())\n\n\t// fill the mempool with more txs\n\t// than can fit in a block\n\ttxLength := 100\n\tfor i := 0; i <= maxBytes/txLength; i++ {\n\t\ttx := tmrand.Bytes(txLength)\n\t\terr := mempool.CheckTx(tx, nil, mempl.TxInfo{})\n\t\tassert.NoError(t, err)\n\t}\n\n\tblockExec := sm.NewBlockExecutor(\n\t\tstateStore,\n\t\tlogger,\n\t\tproxyApp.Consensus(),\n\t\tmempool,\n\t\tevidencePool,\n\t)\n\n\tcommit := types.NewCommit(height-1, 0, types.BlockID{}, nil)\n\tblock, _ := blockExec.CreateProposalBlock(\n\t\theight,\n\t\tstate, commit,\n\t\tproposerAddr,\n\t)\n\n\t// check that the part set does not exceed the maximum block size\n\tpartSet := block.MakePartSet(partSize)\n\tassert.Less(t, partSet.ByteSize(), int64(maxBytes))\n\n\tpartSetFromHeader := types.NewPartSetFromHeader(partSet.Header())\n\tfor partSetFromHeader.Count() < partSetFromHeader.Total() {\n\t\tadded, err := partSetFromHeader.AddPart(partSet.GetPart(int(partSetFromHeader.Count())))\n\t\trequire.NoError(t, err)\n\t\trequire.True(t, added)\n\t}\n\tassert.EqualValues(t, partSetFromHeader.ByteSize(), partSet.ByteSize())\n\n\terr = blockExec.ValidateBlock(state, block)\n\tassert.NoError(t, err)\n}\n\nfunc TestMaxProposalBlockSize(t *testing.T) {\n\tconfig := cfg.ResetTestRoot(\"node_create_proposal\")\n\tdefer os.RemoveAll(config.RootDir)\n\tcc := proxy.NewLocalClientCreator(kvstore.NewApplication())\n\tproxyApp := proxy.NewAppConns(cc)\n\terr := proxyApp.Start()\n\trequire.Nil(t, err)\n\tdefer proxyApp.Stop() //nolint:errcheck // ignore for tests\n\n\tlogger := log.TestingLogger()\n\n\tvar height int64 = 1\n\tstate, stateDB, _ := state(1, height)\n\tstateStore := sm.NewStore(stateDB)\n\tvar maxBytes int64 = 16384\n\tvar partSize uint32 = 256\n\tstate.ConsensusParams.Block.MaxBytes = maxBytes\n\tproposerAddr, _ := state.Validators.GetByIndex(0)\n\n\t// Make Mempool\n\tmemplMetrics := mempl.PrometheusMetrics(\"node_test_2\")\n\tmempool := mempl.NewCListMempool(\n\t\tconfig.Mempool,\n\t\tproxyApp.Mempool(),\n\t\tstate.LastBlockHeight,\n\t\tmempl.WithMetrics(memplMetrics),\n\t\tmempl.WithPreCheck(sm.TxPreCheck(state)),\n\t\tmempl.WithPostCheck(sm.TxPostCheck(state)),\n\t)\n\tmempool.SetLogger(logger)\n\n\t// fill the mempool with one txs just below the maximum size\n\ttxLength := int(types.MaxDataBytesNoEvidence(maxBytes, 1))\n\ttx := tmrand.Bytes(txLength - 4) // to account for the varint\n\terr = mempool.CheckTx(tx, nil, mempl.TxInfo{})\n\tassert.NoError(t, err)\n\n\tblockExec := sm.NewBlockExecutor(\n\t\tstateStore,\n\t\tlogger,\n\t\tproxyApp.Consensus(),\n\t\tmempool,\n\t\tsm.EmptyEvidencePool{},\n\t)\n\n\tcommit := types.NewCommit(height-1, 0, types.BlockID{}, nil)\n\tblock, _ := blockExec.CreateProposalBlock(\n\t\theight,\n\t\tstate, commit,\n\t\tproposerAddr,\n\t)\n\n\tpb, err := block.ToProto()\n\trequire.NoError(t, err)\n\tassert.Less(t, int64(pb.Size()), maxBytes)\n\n\t// check that the part set does not exceed the maximum block size\n\tpartSet := block.MakePartSet(partSize)\n\tassert.EqualValues(t, partSet.ByteSize(), int64(pb.Size()))\n}\n\nfunc TestNodeNewNodeCustomReactors(t *testing.T) {\n\tconfig := cfg.ResetTestRoot(\"node_new_node_custom_reactors_test\")\n\tdefer os.RemoveAll(config.RootDir)\n\n\tcr := p2pmock.NewReactor()\n\tcustomBlockchainReactor := p2pmock.NewReactor()\n\n\tnodeKey, err := p2p.LoadOrGenNodeKey(config.NodeKeyFile())\n\trequire.NoError(t, err)\n\n\tn, err := NewNode(config,\n\t\tprivval.LoadOrGenFilePV(config.PrivValidatorKeyFile(), config.PrivValidatorStateFile()),\n\t\tnodeKey,\n\t\tproxy.DefaultClientCreator(config.ProxyApp, config.ABCI, config.DBDir()),\n\t\tDefaultGenesisDocProviderFunc(config),\n\t\tDefaultDBProvider,\n\t\tDefaultMetricsProvider(config.Instrumentation),\n\t\tlog.TestingLogger(),\n\t\tCustomReactors(map[string]p2p.Reactor{\"FOO\": cr, \"BLOCKCHAIN\": customBlockchainReactor}),\n\t)\n\trequire.NoError(t, err)\n\n\terr = n.Start()\n\trequire.NoError(t, err)\n\tdefer n.Stop() //nolint:errcheck // ignore for tests\n\n\tassert.True(t, cr.IsRunning())\n\tassert.Equal(t, cr, n.Switch().Reactor(\"FOO\"))\n\n\tassert.True(t, customBlockchainReactor.IsRunning())\n\tassert.Equal(t, customBlockchainReactor, n.Switch().Reactor(\"BLOCKCHAIN\"))\n}\n\nfunc state(nVals int, height int64) (sm.State, dbm.DB, []types.PrivValidator) {\n\tprivVals := make([]types.PrivValidator, nVals)\n\tvals := make([]types.GenesisValidator, nVals)\n\tfor i := 0; i < nVals; i++ {\n\t\tprivVal := types.NewMockPV()\n\t\tprivVals[i] = privVal\n\t\tvals[i] = types.GenesisValidator{\n\t\t\tAddress: privVal.PrivKey.PubKey().Address(),\n\t\t\tPubKey:  privVal.PrivKey.PubKey(),\n\t\t\tPower:   1000,\n\t\t\tName:    fmt.Sprintf(\"test%d\", i),\n\t\t}\n\t}\n\ts, _ := sm.MakeGenesisState(&types.GenesisDoc{\n\t\tChainID:    \"test-chain\",\n\t\tValidators: vals,\n\t\tAppHash:    nil,\n\t})\n\n\t// save validators to db for 2 heights\n\tstateDB := dbm.NewMemDB()\n\tstateStore := sm.NewStore(stateDB)\n\tif err := stateStore.Save(s); err != nil {\n\t\tpanic(err)\n\t}\n\n\tfor i := 1; i < int(height); i++ {\n\t\ts.LastBlockHeight++\n\t\ts.LastValidators = s.Validators.Copy()\n\t\tif err := stateStore.Save(s); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\treturn s, stateDB, privVals\n}\n", "package state\n\nimport (\n\t\"github.com/tendermint/tendermint/types\"\n)\n\n//------------------------------------------------------\n// blockchain services types\n// NOTE: Interfaces used by RPC must be thread safe!\n//------------------------------------------------------\n\n//------------------------------------------------------\n// blockstore\n\n// BlockStore defines the interface used by the ConsensusState.\ntype BlockStore interface {\n\tBase() int64\n\tHeight() int64\n\tSize() int64\n\n\tLoadBaseMeta() *types.BlockMeta\n\tLoadBlockMeta(height int64) *types.BlockMeta\n\tLoadBlock(height int64) *types.Block\n\n\tSaveBlock(block *types.Block, blockParts *types.PartSet, seenCommit *types.Commit)\n\n\tPruneBlocks(height int64) (uint64, error)\n\n\tLoadBlockByHash(hash []byte) *types.Block\n\tLoadBlockPart(height int64, index int) *types.Part\n\n\tLoadBlockCommit(height int64) *types.Commit\n\tLoadSeenCommit(height int64) *types.Commit\n}\n\n//-----------------------------------------------------------------------------\n// evidence pool\n\n//go:generate mockery --case underscore --name EvidencePool\n\n// EvidencePool defines the EvidencePool interface used by State.\ntype EvidencePool interface {\n\tPendingEvidence(maxBytes int64) (ev []types.Evidence, size int64)\n\tAddEvidence(types.Evidence) error\n\tUpdate(State, types.EvidenceList)\n\tCheckEvidence(types.EvidenceList) error\n}\n\n// EmptyEvidencePool is an empty implementation of EvidencePool, useful for testing. It also complies\n// to the consensus evidence pool interface\ntype EmptyEvidencePool struct{}\n\nfunc (EmptyEvidencePool) PendingEvidence(maxBytes int64) (ev []types.Evidence, size int64) {\n\treturn nil, 0\n}\nfunc (EmptyEvidencePool) AddEvidence(types.Evidence) error              { return nil }\nfunc (EmptyEvidencePool) Update(State, types.EvidenceList)              {}\nfunc (EmptyEvidencePool) CheckEvidence(evList types.EvidenceList) error { return nil }\nfunc (EmptyEvidencePool) AddEvidenceFromConsensus(evidence types.Evidence) error {\n\treturn nil\n}\n", "package consensus\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"reflect\"\n\t\"runtime/debug\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gogo/protobuf/proto\"\n\n\tcfg \"github.com/tendermint/tendermint/config\"\n\tcstypes \"github.com/tendermint/tendermint/consensus/types\"\n\t\"github.com/tendermint/tendermint/crypto\"\n\ttmevents \"github.com/tendermint/tendermint/libs/events\"\n\t\"github.com/tendermint/tendermint/libs/fail\"\n\ttmjson \"github.com/tendermint/tendermint/libs/json\"\n\t\"github.com/tendermint/tendermint/libs/log\"\n\ttmmath \"github.com/tendermint/tendermint/libs/math\"\n\ttmos \"github.com/tendermint/tendermint/libs/os\"\n\t\"github.com/tendermint/tendermint/libs/service\"\n\t\"github.com/tendermint/tendermint/p2p\"\n\ttmproto \"github.com/tendermint/tendermint/proto/tendermint/types\"\n\tsm \"github.com/tendermint/tendermint/state\"\n\t\"github.com/tendermint/tendermint/types\"\n\ttmtime \"github.com/tendermint/tendermint/types/time\"\n)\n\n// State handles execution of the consensus algorithm.\n// It processes votes and proposals, and upon reaching agreement,\n// commits blocks to the chain and executes them against the application.\n// The internal state machine receives input from peers, the internal validator, and from a timer.\ntype State struct {\n\tservice.BaseService\n\n\t// config details\n\tconfig        *cfg.ConsensusConfig\n\tprivValidator types.PrivValidator // for signing votes\n\n\t// store blocks and commits\n\tblockStore sm.BlockStore\n\n\t// create and execute blocks\n\tblockExec *sm.BlockExecutor\n\n\t// notify us if txs are available\n\ttxNotifier txNotifier\n\n\t// add evidence to the pool\n\t// when it's detected\n\tevpool evidencePool\n\n\t// internal state\n\tmtx sync.RWMutex\n\tcstypes.RoundState\n\tstate sm.State // State until height-1.\n\n\t// state changes may be triggered by: msgs from peers,\n\t// msgs from ourself, or by timeouts\n\tpeerMsgQueue     chan msgInfo\n\tinternalMsgQueue chan msgInfo\n\ttimeoutTicker    TimeoutTicker\n\t// privValidator pubkey, memoized for the duration of one block\n\t// to avoid extra requests to HSM\n\tprivValidatorPubKey crypto.PubKey\n\n\t// information about about added votes and block parts are written on this channel\n\t// so statistics can be computed by reactor\n\tstatsMsgQueue chan msgInfo\n\n\t// we use eventBus to trigger msg broadcasts in the reactor,\n\t// and to notify external subscribers, eg. through a websocket\n\teventBus *types.EventBus\n\n\t// a Write-Ahead Log ensures we can recover from any kind of crash\n\t// and helps us avoid signing conflicting votes\n\twal          WAL\n\treplayMode   bool // so we don't log signing errors during replay\n\tdoWALCatchup bool // determines if we even try to do the catchup\n\n\t// for tests where we want to limit the number of transitions the state makes\n\tnSteps int\n\n\t// some functions can be overwritten for testing\n\tdecideProposal func(height int64, round int32)\n\n\t// closed when we finish shutting down\n\tdone chan struct{}\n\n\t// synchronous pubsub between consensus state and reactor.\n\t// state only emits EventNewRoundStep and EventVote\n\tevsw tmevents.EventSwitch\n\n\t// for reporting metrics\n\tmetrics *Metrics\n\n\t// misbehaviors mapped for each height (can't have more than one misbehavior per height)\n\tmisbehaviors map[int64]Misbehavior\n\n\t// the switch is passed to the state so that maveick misbehaviors can directly control which\n\t// information they send to which nodes\n\tsw *p2p.Switch\n}\n\n// StateOption sets an optional parameter on the State.\ntype StateOption func(*State)\n\n// NewState returns a new State.\nfunc NewState(\n\tconfig *cfg.ConsensusConfig,\n\tstate sm.State,\n\tblockExec *sm.BlockExecutor,\n\tblockStore sm.BlockStore,\n\ttxNotifier txNotifier,\n\tevpool evidencePool,\n\tmisbehaviors map[int64]Misbehavior,\n\toptions ...StateOption,\n) *State {\n\tcs := &State{\n\t\tconfig:           config,\n\t\tblockExec:        blockExec,\n\t\tblockStore:       blockStore,\n\t\ttxNotifier:       txNotifier,\n\t\tpeerMsgQueue:     make(chan msgInfo, msgQueueSize),\n\t\tinternalMsgQueue: make(chan msgInfo, msgQueueSize),\n\t\ttimeoutTicker:    NewTimeoutTicker(),\n\t\tstatsMsgQueue:    make(chan msgInfo, msgQueueSize),\n\t\tdone:             make(chan struct{}),\n\t\tdoWALCatchup:     true,\n\t\twal:              nilWAL{},\n\t\tevpool:           evpool,\n\t\tevsw:             tmevents.NewEventSwitch(),\n\t\tmetrics:          NopMetrics(),\n\t\tmisbehaviors:     misbehaviors,\n\t}\n\t// set function defaults (may be overwritten before calling Start)\n\tcs.decideProposal = cs.defaultDecideProposal\n\n\t// We have no votes, so reconstruct LastCommit from SeenCommit.\n\tif state.LastBlockHeight > 0 {\n\t\tcs.reconstructLastCommit(state)\n\t}\n\n\tcs.updateToState(state)\n\n\t// Don't call scheduleRound0 yet.\n\t// We do that upon Start().\n\n\tcs.BaseService = *service.NewBaseService(nil, \"State\", cs)\n\tfor _, option := range options {\n\t\toption(cs)\n\t}\n\treturn cs\n}\n\n// I know this is not great but the maverick consensus state needs access to the peers\nfunc (cs *State) SetSwitch(sw *p2p.Switch) {\n\tcs.sw = sw\n}\n\n// state transitions on complete-proposal, 2/3-any, 2/3-one\nfunc (cs *State) handleMsg(mi msgInfo) {\n\tcs.mtx.Lock()\n\tdefer cs.mtx.Unlock()\n\n\tvar (\n\t\tadded bool\n\t\terr   error\n\t)\n\tmsg, peerID := mi.Msg, mi.PeerID\n\tswitch msg := msg.(type) {\n\tcase *ProposalMessage:\n\t\t// will not cause transition.\n\t\t// once proposal is set, we can receive block parts\n\t\t// err = cs.setProposal(msg.Proposal)\n\t\tif b, ok := cs.misbehaviors[cs.Height]; ok {\n\t\t\terr = b.ReceiveProposal(cs, msg.Proposal)\n\t\t} else {\n\t\t\terr = defaultReceiveProposal(cs, msg.Proposal)\n\t\t}\n\tcase *BlockPartMessage:\n\t\t// if the proposal is complete, we'll enterPrevote or tryFinalizeCommit\n\t\tadded, err = cs.addProposalBlockPart(msg, peerID)\n\t\tif added {\n\t\t\tcs.statsMsgQueue <- mi\n\t\t}\n\n\t\tif err != nil && msg.Round != cs.Round {\n\t\t\tcs.Logger.Debug(\n\t\t\t\t\"Received block part from wrong round\",\n\t\t\t\t\"height\",\n\t\t\t\tcs.Height,\n\t\t\t\t\"csRound\",\n\t\t\t\tcs.Round,\n\t\t\t\t\"blockRound\",\n\t\t\t\tmsg.Round)\n\t\t\terr = nil\n\t\t}\n\tcase *VoteMessage:\n\t\t// attempt to add the vote and dupeout the validator if its a duplicate signature\n\t\t// if the vote gives us a 2/3-any or 2/3-one, we transition\n\t\tadded, err = cs.tryAddVote(msg.Vote, peerID)\n\t\tif added {\n\t\t\tcs.statsMsgQueue <- mi\n\t\t}\n\n\t\t// if err == ErrAddingVote {\n\t\t// TODO: punish peer\n\t\t// We probably don't want to stop the peer here. The vote does not\n\t\t// necessarily comes from a malicious peer but can be just broadcasted by\n\t\t// a typical peer.\n\t\t// https://github.com/tendermint/tendermint/issues/1281\n\t\t// }\n\n\t\t// NOTE: the vote is broadcast to peers by the reactor listening\n\t\t// for vote events\n\n\t\t// TODO: If rs.Height == vote.Height && rs.Round < vote.Round,\n\t\t// the peer is sending us CatchupCommit precommits.\n\t\t// We could make note of this and help filter in broadcastHasVoteMessage().\n\tdefault:\n\t\tcs.Logger.Error(\"Unknown msg type\", \"type\", reflect.TypeOf(msg))\n\t\treturn\n\t}\n\n\tif err != nil {\n\t\tcs.Logger.Error(\"Error with msg\", \"height\", cs.Height, \"round\", cs.Round,\n\t\t\t\"peer\", peerID, \"err\", err, \"msg\", msg)\n\t}\n}\n\n// Enter (CreateEmptyBlocks): from enterNewRound(height,round)\n// Enter (CreateEmptyBlocks, CreateEmptyBlocksInterval > 0 ):\n// \t\tafter enterNewRound(height,round), after timeout of CreateEmptyBlocksInterval\n// Enter (!CreateEmptyBlocks) : after enterNewRound(height,round), once txs are in the mempool\nfunc (cs *State) enterPropose(height int64, round int32) {\n\tlogger := cs.Logger.With(\"height\", height, \"round\", round)\n\n\tif cs.Height != height || round < cs.Round || (cs.Round == round && cstypes.RoundStepPropose <= cs.Step) {\n\t\tlogger.Debug(fmt.Sprintf(\n\t\t\t\"enterPropose(%v/%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tround,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\tlogger.Info(fmt.Sprintf(\"enterPropose(%v/%v). Current: %v/%v/%v\", height, round, cs.Height, cs.Round, cs.Step))\n\n\tdefer func() {\n\t\t// Done enterPropose:\n\t\tcs.updateRoundStep(round, cstypes.RoundStepPropose)\n\t\tcs.newStep()\n\n\t\t// If we have the whole proposal + POL, then goto Prevote now.\n\t\t// else, we'll enterPrevote when the rest of the proposal is received (in AddProposalBlockPart),\n\t\t// or else after timeoutPropose\n\t\tif cs.isProposalComplete() {\n\t\t\tcs.enterPrevote(height, cs.Round)\n\t\t}\n\t}()\n\n\tif b, ok := cs.misbehaviors[cs.Height]; ok {\n\t\tb.EnterPropose(cs, height, round)\n\t} else {\n\t\tdefaultEnterPropose(cs, height, round)\n\t}\n}\n\n// Enter: `timeoutPropose` after entering Propose.\n// Enter: proposal block and POL is ready.\n// Prevote for LockedBlock if we're locked, or ProposalBlock if valid.\n// Otherwise vote nil.\nfunc (cs *State) enterPrevote(height int64, round int32) {\n\tif cs.Height != height || round < cs.Round || (cs.Round == round && cstypes.RoundStepPrevote <= cs.Step) {\n\t\tcs.Logger.Debug(fmt.Sprintf(\n\t\t\t\"enterPrevote(%v/%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tround,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\n\tdefer func() {\n\t\t// Done enterPrevote:\n\t\tcs.updateRoundStep(round, cstypes.RoundStepPrevote)\n\t\tcs.newStep()\n\t}()\n\n\tcs.Logger.Info(fmt.Sprintf(\"enterPrevote(%v/%v). Current: %v/%v/%v\", height, round, cs.Height, cs.Round, cs.Step))\n\n\t// Sign and broadcast vote as necessary\n\tif b, ok := cs.misbehaviors[cs.Height]; ok {\n\t\tb.EnterPrevote(cs, height, round)\n\t} else {\n\t\tdefaultEnterPrevote(cs, height, round)\n\t}\n\n\t// Once `addVote` hits any +2/3 prevotes, we will go to PrevoteWait\n\t// (so we have more time to try and collect +2/3 prevotes for a single block)\n}\n\n// Enter: `timeoutPrevote` after any +2/3 prevotes.\n// Enter: `timeoutPrecommit` after any +2/3 precommits.\n// Enter: +2/3 precomits for block or nil.\n// Lock & precommit the ProposalBlock if we have enough prevotes for it (a POL in this round)\n// else, unlock an existing lock and precommit nil if +2/3 of prevotes were nil,\n// else, precommit nil otherwise.\nfunc (cs *State) enterPrecommit(height int64, round int32) {\n\tlogger := cs.Logger.With(\"height\", height, \"round\", round)\n\n\tif cs.Height != height || round < cs.Round || (cs.Round == round && cstypes.RoundStepPrecommit <= cs.Step) {\n\t\tlogger.Debug(fmt.Sprintf(\n\t\t\t\"enterPrecommit(%v/%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tround,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\n\tlogger.Info(fmt.Sprintf(\"enterPrecommit(%v/%v). Current: %v/%v/%v\", height, round, cs.Height, cs.Round, cs.Step))\n\n\tdefer func() {\n\t\t// Done enterPrecommit:\n\t\tcs.updateRoundStep(round, cstypes.RoundStepPrecommit)\n\t\tcs.newStep()\n\t}()\n\n\tif b, ok := cs.misbehaviors[cs.Height]; ok {\n\t\tb.EnterPrecommit(cs, height, round)\n\t} else {\n\t\tdefaultEnterPrecommit(cs, height, round)\n\t}\n\n}\n\nfunc (cs *State) addVote(\n\tvote *types.Vote,\n\tpeerID p2p.ID) (added bool, err error) {\n\tcs.Logger.Debug(\n\t\t\"addVote\",\n\t\t\"voteHeight\",\n\t\tvote.Height,\n\t\t\"voteType\",\n\t\tvote.Type,\n\t\t\"valIndex\",\n\t\tvote.ValidatorIndex,\n\t\t\"csHeight\",\n\t\tcs.Height,\n\t)\n\n\t// A precommit for the previous height?\n\t// These come in while we wait timeoutCommit\n\tif vote.Height+1 == cs.Height && vote.Type == tmproto.PrecommitType {\n\t\tif cs.Step != cstypes.RoundStepNewHeight {\n\t\t\t// Late precommit at prior height is ignored\n\t\t\tcs.Logger.Debug(\"Precommit vote came in after commit timeout and has been ignored\", \"vote\", vote)\n\t\t\treturn\n\t\t}\n\t\tadded, err = cs.LastCommit.AddVote(vote)\n\t\tif !added {\n\t\t\treturn\n\t\t}\n\n\t\tcs.Logger.Info(fmt.Sprintf(\"Added to lastPrecommits: %v\", cs.LastCommit.StringShort()))\n\t\t_ = cs.eventBus.PublishEventVote(types.EventDataVote{Vote: vote})\n\t\tcs.evsw.FireEvent(types.EventVote, vote)\n\n\t\t// if we can skip timeoutCommit and have all the votes now,\n\t\tif cs.config.SkipTimeoutCommit && cs.LastCommit.HasAll() {\n\t\t\t// go straight to new round (skip timeout commit)\n\t\t\t// cs.scheduleTimeout(time.Duration(0), cs.Height, 0, cstypes.RoundStepNewHeight)\n\t\t\tcs.enterNewRound(cs.Height, 0)\n\t\t}\n\n\t\treturn\n\t}\n\n\t// Height mismatch is ignored.\n\t// Not necessarily a bad peer, but not favourable behaviour.\n\tif vote.Height != cs.Height {\n\t\tcs.Logger.Info(\"Vote ignored and not added\", \"voteHeight\", vote.Height, \"csHeight\", cs.Height, \"peerID\", peerID)\n\t\treturn\n\t}\n\n\tadded, err = cs.Votes.AddVote(vote, peerID)\n\tif !added {\n\t\t// Either duplicate, or error upon cs.Votes.AddByIndex()\n\t\treturn\n\t}\n\n\t_ = cs.eventBus.PublishEventVote(types.EventDataVote{Vote: vote})\n\tcs.evsw.FireEvent(types.EventVote, vote)\n\n\tswitch vote.Type {\n\tcase tmproto.PrevoteType:\n\t\tif b, ok := cs.misbehaviors[cs.Height]; ok {\n\t\t\tb.ReceivePrevote(cs, vote)\n\t\t} else {\n\t\t\tdefaultReceivePrevote(cs, vote)\n\t\t}\n\n\tcase tmproto.PrecommitType:\n\t\tif b, ok := cs.misbehaviors[cs.Height]; ok {\n\t\t\tb.ReceivePrecommit(cs, vote)\n\t\t}\n\t\tdefaultReceivePrecommit(cs, vote)\n\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"Unexpected vote type %v\", vote.Type))\n\t}\n\n\treturn added, err\n}\n\n//-----------------------------------------------------------------------------\n// Errors\n\nvar (\n\tErrInvalidProposalSignature   = errors.New(\"error invalid proposal signature\")\n\tErrInvalidProposalPOLRound    = errors.New(\"error invalid proposal POL round\")\n\tErrAddingVote                 = errors.New(\"error adding vote\")\n\tErrSignatureFoundInPastBlocks = errors.New(\"found signature from the same key\")\n\n\terrPubKeyIsNotSet = errors.New(\"pubkey is not set. Look for \\\"Can't get private validator pubkey\\\" errors\")\n)\n\n//-----------------------------------------------------------------------------\n\nvar (\n\tmsgQueueSize = 1000\n)\n\n// msgs from the reactor which may update the state\ntype msgInfo struct {\n\tMsg    Message `json:\"msg\"`\n\tPeerID p2p.ID  `json:\"peer_key\"`\n}\n\n// internally generated messages which may update the state\ntype timeoutInfo struct {\n\tDuration time.Duration         `json:\"duration\"`\n\tHeight   int64                 `json:\"height\"`\n\tRound    int32                 `json:\"round\"`\n\tStep     cstypes.RoundStepType `json:\"step\"`\n}\n\nfunc (ti *timeoutInfo) String() string {\n\treturn fmt.Sprintf(\"%v ; %d/%d %v\", ti.Duration, ti.Height, ti.Round, ti.Step)\n}\n\n// interface to the mempool\ntype txNotifier interface {\n\tTxsAvailable() <-chan struct{}\n}\n\n// interface to the evidence pool\ntype evidencePool interface {\n\t// Adds consensus based evidence to the evidence pool where time is the time\n\t// of the block where the offense occurred and the validator set is the current one.\n\tAddEvidenceFromConsensus(evidence types.Evidence) error\n}\n\n//----------------------------------------\n// Public interface\n\n// SetLogger implements Service.\nfunc (cs *State) SetLogger(l log.Logger) {\n\tcs.BaseService.Logger = l\n\tcs.timeoutTicker.SetLogger(l)\n}\n\n// SetEventBus sets event bus.\nfunc (cs *State) SetEventBus(b *types.EventBus) {\n\tcs.eventBus = b\n\tcs.blockExec.SetEventBus(b)\n}\n\n// StateMetrics sets the metrics.\nfunc StateMetrics(metrics *Metrics) StateOption {\n\treturn func(cs *State) { cs.metrics = metrics }\n}\n\n// String returns a string.\nfunc (cs *State) String() string {\n\t// better not to access shared variables\n\treturn \"ConsensusState\"\n}\n\n// GetState returns a copy of the chain state.\nfunc (cs *State) GetState() sm.State {\n\tcs.mtx.RLock()\n\tdefer cs.mtx.RUnlock()\n\treturn cs.state.Copy()\n}\n\n// GetLastHeight returns the last height committed.\n// If there were no blocks, returns 0.\nfunc (cs *State) GetLastHeight() int64 {\n\tcs.mtx.RLock()\n\tdefer cs.mtx.RUnlock()\n\treturn cs.RoundState.Height - 1\n}\n\n// GetRoundState returns a shallow copy of the internal consensus state.\nfunc (cs *State) GetRoundState() *cstypes.RoundState {\n\tcs.mtx.RLock()\n\trs := cs.RoundState // copy\n\tcs.mtx.RUnlock()\n\treturn &rs\n}\n\n// GetRoundStateJSON returns a json of RoundState.\nfunc (cs *State) GetRoundStateJSON() ([]byte, error) {\n\tcs.mtx.RLock()\n\tdefer cs.mtx.RUnlock()\n\treturn tmjson.Marshal(cs.RoundState)\n}\n\n// GetRoundStateSimpleJSON returns a json of RoundStateSimple\nfunc (cs *State) GetRoundStateSimpleJSON() ([]byte, error) {\n\tcs.mtx.RLock()\n\tdefer cs.mtx.RUnlock()\n\treturn tmjson.Marshal(cs.RoundState.RoundStateSimple())\n}\n\n// GetValidators returns a copy of the current validators.\nfunc (cs *State) GetValidators() (int64, []*types.Validator) {\n\tcs.mtx.RLock()\n\tdefer cs.mtx.RUnlock()\n\treturn cs.state.LastBlockHeight, cs.state.Validators.Copy().Validators\n}\n\n// SetPrivValidator sets the private validator account for signing votes. It\n// immediately requests pubkey and caches it.\nfunc (cs *State) SetPrivValidator(priv types.PrivValidator) {\n\tcs.mtx.Lock()\n\tdefer cs.mtx.Unlock()\n\n\tcs.privValidator = priv\n\n\tif err := cs.updatePrivValidatorPubKey(); err != nil {\n\t\tcs.Logger.Error(\"Can't get private validator pubkey\", \"err\", err)\n\t}\n}\n\n// SetTimeoutTicker sets the local timer. It may be useful to overwrite for testing.\nfunc (cs *State) SetTimeoutTicker(timeoutTicker TimeoutTicker) {\n\tcs.mtx.Lock()\n\tcs.timeoutTicker = timeoutTicker\n\tcs.mtx.Unlock()\n}\n\n// LoadCommit loads the commit for a given height.\nfunc (cs *State) LoadCommit(height int64) *types.Commit {\n\tcs.mtx.RLock()\n\tdefer cs.mtx.RUnlock()\n\tif height == cs.blockStore.Height() {\n\t\treturn cs.blockStore.LoadSeenCommit(height)\n\t}\n\treturn cs.blockStore.LoadBlockCommit(height)\n}\n\n// OnStart loads the latest state via the WAL, and starts the timeout and\n// receive routines.\nfunc (cs *State) OnStart() error {\n\t// We may set the WAL in testing before calling Start, so only OpenWAL if its\n\t// still the nilWAL.\n\tif _, ok := cs.wal.(nilWAL); ok {\n\t\tif err := cs.loadWalFile(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// We may have lost some votes if the process crashed reload from consensus\n\t// log to catchup.\n\tif cs.doWALCatchup {\n\t\trepairAttempted := false\n\tLOOP:\n\t\tfor {\n\t\t\terr := cs.catchupReplay(cs.Height)\n\t\t\tswitch {\n\t\t\tcase err == nil:\n\t\t\t\tbreak LOOP\n\t\t\tcase !IsDataCorruptionError(err):\n\t\t\t\tcs.Logger.Error(\"Error on catchup replay. Proceeding to start State anyway\", \"err\", err)\n\t\t\t\tbreak LOOP\n\t\t\tcase repairAttempted:\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tcs.Logger.Info(\"WAL file is corrupted. Attempting repair\", \"err\", err)\n\n\t\t\t// 1) prep work\n\t\t\tif err := cs.wal.Stop(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\trepairAttempted = true\n\n\t\t\t// 2) backup original WAL file\n\t\t\tcorruptedFile := fmt.Sprintf(\"%s.CORRUPTED\", cs.config.WalFile())\n\t\t\tif err := tmos.CopyFile(cs.config.WalFile(), corruptedFile); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcs.Logger.Info(\"Backed up WAL file\", \"src\", cs.config.WalFile(), \"dst\", corruptedFile)\n\n\t\t\t// 3) try to repair (WAL file will be overwritten!)\n\t\t\tif err := repairWalFile(corruptedFile, cs.config.WalFile()); err != nil {\n\t\t\t\tcs.Logger.Error(\"Repair failed\", \"err\", err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcs.Logger.Info(\"Successful repair\")\n\n\t\t\t// reload WAL file\n\t\t\tif err := cs.loadWalFile(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif err := cs.evsw.Start(); err != nil {\n\t\treturn err\n\t}\n\n\t// we need the timeoutRoutine for replay so\n\t// we don't block on the tick chan.\n\t// NOTE: we will get a build up of garbage go routines\n\t// firing on the tockChan until the receiveRoutine is started\n\t// to deal with them (by that point, at most one will be valid)\n\tif err := cs.timeoutTicker.Start(); err != nil {\n\t\treturn err\n\t}\n\n\t// Double Signing Risk Reduction\n\tif err := cs.checkDoubleSigningRisk(cs.Height); err != nil {\n\t\treturn err\n\t}\n\n\t// now start the receiveRoutine\n\tgo cs.receiveRoutine(0)\n\n\t// schedule the first round!\n\t// use GetRoundState so we don't race the receiveRoutine for access\n\tcs.scheduleRound0(cs.GetRoundState())\n\n\treturn nil\n}\n\n// loadWalFile loads WAL data from file. It overwrites cs.wal.\nfunc (cs *State) loadWalFile() error {\n\twal, err := cs.OpenWAL(cs.config.WalFile())\n\tif err != nil {\n\t\tcs.Logger.Error(\"Error loading State wal\", \"err\", err)\n\t\treturn err\n\t}\n\tcs.wal = wal\n\treturn nil\n}\n\n// OnStop implements service.Service.\nfunc (cs *State) OnStop() {\n\tif err := cs.evsw.Stop(); err != nil {\n\t\tcs.Logger.Error(\"error trying to stop eventSwitch\", \"error\", err)\n\t}\n\tif err := cs.timeoutTicker.Stop(); err != nil {\n\t\tcs.Logger.Error(\"error trying to stop timeoutTicket\", \"error\", err)\n\t}\n\t// WAL is stopped in receiveRoutine.\n}\n\n// Wait waits for the the main routine to return.\n// NOTE: be sure to Stop() the event switch and drain\n// any event channels or this may deadlock\nfunc (cs *State) Wait() {\n\t<-cs.done\n}\n\n// OpenWAL opens a file to log all consensus messages and timeouts for\n// deterministic accountability.\nfunc (cs *State) OpenWAL(walFile string) (WAL, error) {\n\twal, err := NewWAL(walFile)\n\tif err != nil {\n\t\tcs.Logger.Error(\"Failed to open WAL\", \"file\", walFile, \"err\", err)\n\t\treturn nil, err\n\t}\n\twal.SetLogger(cs.Logger.With(\"wal\", walFile))\n\tif err := wal.Start(); err != nil {\n\t\tcs.Logger.Error(\"Failed to start WAL\", \"err\", err)\n\t\treturn nil, err\n\t}\n\treturn wal, nil\n}\n\n//------------------------------------------------------------\n// Public interface for passing messages into the consensus state, possibly causing a state transition.\n// If peerID == \"\", the msg is considered internal.\n// Messages are added to the appropriate queue (peer or internal).\n// If the queue is full, the function may block.\n// TODO: should these return anything or let callers just use events?\n\n// AddVote inputs a vote.\nfunc (cs *State) AddVote(vote *types.Vote, peerID p2p.ID) (added bool, err error) {\n\tif peerID == \"\" {\n\t\tcs.internalMsgQueue <- msgInfo{&VoteMessage{vote}, \"\"}\n\t} else {\n\t\tcs.peerMsgQueue <- msgInfo{&VoteMessage{vote}, peerID}\n\t}\n\n\t// TODO: wait for event?!\n\treturn false, nil\n}\n\n// SetProposal inputs a proposal.\nfunc (cs *State) SetProposal(proposal *types.Proposal, peerID p2p.ID) error {\n\n\tif peerID == \"\" {\n\t\tcs.internalMsgQueue <- msgInfo{&ProposalMessage{proposal}, \"\"}\n\t} else {\n\t\tcs.peerMsgQueue <- msgInfo{&ProposalMessage{proposal}, peerID}\n\t}\n\n\t// TODO: wait for event?!\n\treturn nil\n}\n\n// AddProposalBlockPart inputs a part of the proposal block.\nfunc (cs *State) AddProposalBlockPart(height int64, round int32, part *types.Part, peerID p2p.ID) error {\n\n\tif peerID == \"\" {\n\t\tcs.internalMsgQueue <- msgInfo{&BlockPartMessage{height, round, part}, \"\"}\n\t} else {\n\t\tcs.peerMsgQueue <- msgInfo{&BlockPartMessage{height, round, part}, peerID}\n\t}\n\n\t// TODO: wait for event?!\n\treturn nil\n}\n\n// SetProposalAndBlock inputs the proposal and all block parts.\nfunc (cs *State) SetProposalAndBlock(\n\tproposal *types.Proposal,\n\tblock *types.Block,\n\tparts *types.PartSet,\n\tpeerID p2p.ID,\n) error {\n\tif err := cs.SetProposal(proposal, peerID); err != nil {\n\t\treturn err\n\t}\n\tfor i := 0; i < int(parts.Total()); i++ {\n\t\tpart := parts.GetPart(i)\n\t\tif err := cs.AddProposalBlockPart(proposal.Height, proposal.Round, part, peerID); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n//------------------------------------------------------------\n// internal functions for managing the state\n\nfunc (cs *State) updateHeight(height int64) {\n\tcs.metrics.Height.Set(float64(height))\n\tcs.Height = height\n}\n\nfunc (cs *State) updateRoundStep(round int32, step cstypes.RoundStepType) {\n\tcs.Round = round\n\tcs.Step = step\n}\n\n// enterNewRound(height, 0) at cs.StartTime.\nfunc (cs *State) scheduleRound0(rs *cstypes.RoundState) {\n\t// cs.Logger.Info(\"scheduleRound0\", \"now\", tmtime.Now(), \"startTime\", cs.StartTime)\n\tsleepDuration := rs.StartTime.Sub(tmtime.Now())\n\tcs.scheduleTimeout(sleepDuration, rs.Height, 0, cstypes.RoundStepNewHeight)\n}\n\n// Attempt to schedule a timeout (by sending timeoutInfo on the tickChan)\nfunc (cs *State) scheduleTimeout(duration time.Duration, height int64, round int32, step cstypes.RoundStepType) {\n\tcs.timeoutTicker.ScheduleTimeout(timeoutInfo{duration, height, round, step})\n}\n\n// send a msg into the receiveRoutine regarding our own proposal, block part, or vote\nfunc (cs *State) sendInternalMessage(mi msgInfo) {\n\tselect {\n\tcase cs.internalMsgQueue <- mi:\n\tdefault:\n\t\t// NOTE: using the go-routine means our votes can\n\t\t// be processed out of order.\n\t\t// TODO: use CList here for strict determinism and\n\t\t// attempt push to internalMsgQueue in receiveRoutine\n\t\tcs.Logger.Info(\"Internal msg queue is full. Using a go-routine\")\n\t\tgo func() { cs.internalMsgQueue <- mi }()\n\t}\n}\n\n// Reconstruct LastCommit from SeenCommit, which we saved along with the block,\n// (which happens even before saving the state)\nfunc (cs *State) reconstructLastCommit(state sm.State) {\n\tseenCommit := cs.blockStore.LoadSeenCommit(state.LastBlockHeight)\n\tif seenCommit == nil {\n\t\tpanic(fmt.Sprintf(\"Failed to reconstruct LastCommit: seen commit for height %v not found\",\n\t\t\tstate.LastBlockHeight))\n\t}\n\n\tlastPrecommits := types.CommitToVoteSet(state.ChainID, seenCommit, state.LastValidators)\n\tif !lastPrecommits.HasTwoThirdsMajority() {\n\t\tpanic(\"Failed to reconstruct LastCommit: Does not have +2/3 maj\")\n\t}\n\n\tcs.LastCommit = lastPrecommits\n}\n\n// Updates State and increments height to match that of state.\n// The round becomes 0 and cs.Step becomes cstypes.RoundStepNewHeight.\nfunc (cs *State) updateToState(state sm.State) {\n\tif cs.CommitRound > -1 && 0 < cs.Height && cs.Height != state.LastBlockHeight {\n\t\tpanic(fmt.Sprintf(\"updateToState() expected state height of %v but found %v\",\n\t\t\tcs.Height, state.LastBlockHeight))\n\t}\n\tif !cs.state.IsEmpty() {\n\t\tif cs.state.LastBlockHeight > 0 && cs.state.LastBlockHeight+1 != cs.Height {\n\t\t\t// This might happen when someone else is mutating cs.state.\n\t\t\t// Someone forgot to pass in state.Copy() somewhere?!\n\t\t\tpanic(fmt.Sprintf(\"Inconsistent cs.state.LastBlockHeight+1 %v vs cs.Height %v\",\n\t\t\t\tcs.state.LastBlockHeight+1, cs.Height))\n\t\t}\n\t\tif cs.state.LastBlockHeight > 0 && cs.Height == cs.state.InitialHeight {\n\t\t\tpanic(fmt.Sprintf(\"Inconsistent cs.state.LastBlockHeight %v, expected 0 for initial height %v\",\n\t\t\t\tcs.state.LastBlockHeight, cs.state.InitialHeight))\n\t\t}\n\n\t\t// If state isn't further out than cs.state, just ignore.\n\t\t// This happens when SwitchToConsensus() is called in the reactor.\n\t\t// We don't want to reset e.g. the Votes, but we still want to\n\t\t// signal the new round step, because other services (eg. txNotifier)\n\t\t// depend on having an up-to-date peer state!\n\t\tif state.LastBlockHeight <= cs.state.LastBlockHeight {\n\t\t\tcs.Logger.Info(\n\t\t\t\t\"Ignoring updateToState()\",\n\t\t\t\t\"newHeight\",\n\t\t\t\tstate.LastBlockHeight+1,\n\t\t\t\t\"oldHeight\",\n\t\t\t\tcs.state.LastBlockHeight+1)\n\t\t\tcs.newStep()\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Reset fields based on state.\n\tvalidators := state.Validators\n\n\tswitch {\n\tcase state.LastBlockHeight == 0: // Very first commit should be empty.\n\t\tcs.LastCommit = (*types.VoteSet)(nil)\n\tcase cs.CommitRound > -1 && cs.Votes != nil: // Otherwise, use cs.Votes\n\t\tif !cs.Votes.Precommits(cs.CommitRound).HasTwoThirdsMajority() {\n\t\t\tpanic(fmt.Sprintf(\"Wanted to form a Commit, but Precommits (H/R: %d/%d) didn't have 2/3+: %v\",\n\t\t\t\tstate.LastBlockHeight,\n\t\t\t\tcs.CommitRound,\n\t\t\t\tcs.Votes.Precommits(cs.CommitRound)))\n\t\t}\n\t\tcs.LastCommit = cs.Votes.Precommits(cs.CommitRound)\n\tcase cs.LastCommit == nil:\n\t\t// NOTE: when Tendermint starts, it has no votes. reconstructLastCommit\n\t\t// must be called to reconstruct LastCommit from SeenCommit.\n\t\tpanic(fmt.Sprintf(\"LastCommit cannot be empty after initial block (H:%d)\",\n\t\t\tstate.LastBlockHeight+1,\n\t\t))\n\t}\n\n\t// Next desired block height\n\theight := state.LastBlockHeight + 1\n\tif height == 1 {\n\t\theight = state.InitialHeight\n\t}\n\n\t// RoundState fields\n\tcs.updateHeight(height)\n\tcs.updateRoundStep(0, cstypes.RoundStepNewHeight)\n\tif cs.CommitTime.IsZero() {\n\t\t// \"Now\" makes it easier to sync up dev nodes.\n\t\t// We add timeoutCommit to allow transactions\n\t\t// to be gathered for the first block.\n\t\t// And alternative solution that relies on clocks:\n\t\t// cs.StartTime = state.LastBlockTime.Add(timeoutCommit)\n\t\tcs.StartTime = cs.config.Commit(tmtime.Now())\n\t} else {\n\t\tcs.StartTime = cs.config.Commit(cs.CommitTime)\n\t}\n\n\tcs.Validators = validators\n\tcs.Proposal = nil\n\tcs.ProposalBlock = nil\n\tcs.ProposalBlockParts = nil\n\tcs.LockedRound = -1\n\tcs.LockedBlock = nil\n\tcs.LockedBlockParts = nil\n\tcs.ValidRound = -1\n\tcs.ValidBlock = nil\n\tcs.ValidBlockParts = nil\n\tcs.Votes = cstypes.NewHeightVoteSet(state.ChainID, height, validators)\n\tcs.CommitRound = -1\n\tcs.LastValidators = state.LastValidators\n\tcs.TriggeredTimeoutPrecommit = false\n\n\tcs.state = state\n\n\t// Finally, broadcast RoundState\n\tcs.newStep()\n}\n\nfunc (cs *State) newStep() {\n\trs := cs.RoundStateEvent()\n\tif err := cs.wal.Write(rs); err != nil {\n\t\tcs.Logger.Error(\"Error writing to wal\", \"err\", err)\n\t}\n\tcs.nSteps++\n\t// newStep is called by updateToState in NewState before the eventBus is set!\n\tif cs.eventBus != nil {\n\t\tif err := cs.eventBus.PublishEventNewRoundStep(rs); err != nil {\n\t\t\tcs.Logger.Error(\"Error publishing new round step\", \"err\", err)\n\t\t}\n\t\tcs.evsw.FireEvent(types.EventNewRoundStep, &cs.RoundState)\n\t}\n}\n\n//-----------------------------------------\n// the main go routines\n\n// receiveRoutine handles messages which may cause state transitions.\n// it's argument (n) is the number of messages to process before exiting - use 0 to run forever\n// It keeps the RoundState and is the only thing that updates it.\n// Updates (state transitions) happen on timeouts, complete proposals, and 2/3 majorities.\n// State must be locked before any internal state is updated.\nfunc (cs *State) receiveRoutine(maxSteps int) {\n\tonExit := func(cs *State) {\n\t\t// NOTE: the internalMsgQueue may have signed messages from our\n\t\t// priv_val that haven't hit the WAL, but its ok because\n\t\t// priv_val tracks LastSig\n\n\t\t// close wal now that we're done writing to it\n\t\tif err := cs.wal.Stop(); err != nil {\n\t\t\tcs.Logger.Error(\"error trying to stop wal\", \"error\", err)\n\t\t}\n\t\tcs.wal.Wait()\n\n\t\tclose(cs.done)\n\t}\n\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tcs.Logger.Error(\"CONSENSUS FAILURE!!!\", \"err\", r, \"stack\", string(debug.Stack()))\n\t\t\t// stop gracefully\n\t\t\t//\n\t\t\t// NOTE: We most probably shouldn't be running any further when there is\n\t\t\t// some unexpected panic. Some unknown error happened, and so we don't\n\t\t\t// know if that will result in the validator signing an invalid thing. It\n\t\t\t// might be worthwhile to explore a mechanism for manual resuming via\n\t\t\t// some console or secure RPC system, but for now, halting the chain upon\n\t\t\t// unexpected consensus bugs sounds like the better option.\n\t\t\tonExit(cs)\n\t\t}\n\t}()\n\n\tfor {\n\t\tif maxSteps > 0 {\n\t\t\tif cs.nSteps >= maxSteps {\n\t\t\t\tcs.Logger.Info(\"reached max steps. exiting receive routine\")\n\t\t\t\tcs.nSteps = 0\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\trs := cs.RoundState\n\t\tvar mi msgInfo\n\n\t\tselect {\n\t\tcase <-cs.txNotifier.TxsAvailable():\n\t\t\tcs.handleTxsAvailable()\n\t\tcase mi = <-cs.peerMsgQueue:\n\t\t\tif err := cs.wal.Write(mi); err != nil {\n\t\t\t\tcs.Logger.Error(\"Error writing to wal\", \"err\", err)\n\t\t\t}\n\t\t\t// handles proposals, block parts, votes\n\t\t\t// may generate internal events (votes, complete proposals, 2/3 majorities)\n\t\t\tcs.handleMsg(mi)\n\t\tcase mi = <-cs.internalMsgQueue:\n\t\t\terr := cs.wal.WriteSync(mi) // NOTE: fsync\n\t\t\tif err != nil {\n\t\t\t\tpanic(fmt.Sprintf(\"Failed to write %v msg to consensus wal due to %v. Check your FS and restart the node\", mi, err))\n\t\t\t}\n\n\t\t\tif _, ok := mi.Msg.(*VoteMessage); ok {\n\t\t\t\t// we actually want to simulate failing during\n\t\t\t\t// the previous WriteSync, but this isn't easy to do.\n\t\t\t\t// Equivalent would be to fail here and manually remove\n\t\t\t\t// some bytes from the end of the wal.\n\t\t\t\tfail.Fail() // XXX\n\t\t\t}\n\n\t\t\t// handles proposals, block parts, votes\n\t\t\tcs.handleMsg(mi)\n\t\tcase ti := <-cs.timeoutTicker.Chan(): // tockChan:\n\t\t\tif err := cs.wal.Write(ti); err != nil {\n\t\t\t\tcs.Logger.Error(\"Error writing to wal\", \"err\", err)\n\t\t\t}\n\t\t\t// if the timeout is relevant to the rs\n\t\t\t// go to the next step\n\t\t\tcs.handleTimeout(ti, rs)\n\t\tcase <-cs.Quit():\n\t\t\tonExit(cs)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (cs *State) handleTimeout(ti timeoutInfo, rs cstypes.RoundState) {\n\tcs.Logger.Debug(\"Received tock\", \"timeout\", ti.Duration, \"height\", ti.Height, \"round\", ti.Round, \"step\", ti.Step)\n\n\t// timeouts must be for current height, round, step\n\tif ti.Height != rs.Height || ti.Round < rs.Round || (ti.Round == rs.Round && ti.Step < rs.Step) {\n\t\tcs.Logger.Debug(\"Ignoring tock because we're ahead\", \"height\", rs.Height, \"round\", rs.Round, \"step\", rs.Step)\n\t\treturn\n\t}\n\n\t// the timeout will now cause a state transition\n\tcs.mtx.Lock()\n\tdefer cs.mtx.Unlock()\n\n\tswitch ti.Step {\n\tcase cstypes.RoundStepNewHeight:\n\t\t// NewRound event fired from enterNewRound.\n\t\t// XXX: should we fire timeout here (for timeout commit)?\n\t\tcs.enterNewRound(ti.Height, 0)\n\tcase cstypes.RoundStepNewRound:\n\t\tcs.enterPropose(ti.Height, 0)\n\tcase cstypes.RoundStepPropose:\n\t\tif err := cs.eventBus.PublishEventTimeoutPropose(cs.RoundStateEvent()); err != nil {\n\t\t\tcs.Logger.Error(\"Error publishing timeout propose\", \"err\", err)\n\t\t}\n\t\tcs.enterPrevote(ti.Height, ti.Round)\n\tcase cstypes.RoundStepPrevoteWait:\n\t\tif err := cs.eventBus.PublishEventTimeoutWait(cs.RoundStateEvent()); err != nil {\n\t\t\tcs.Logger.Error(\"Error publishing timeout wait\", \"err\", err)\n\t\t}\n\t\tcs.enterPrecommit(ti.Height, ti.Round)\n\tcase cstypes.RoundStepPrecommitWait:\n\t\tif err := cs.eventBus.PublishEventTimeoutWait(cs.RoundStateEvent()); err != nil {\n\t\t\tcs.Logger.Error(\"Error publishing timeout wait\", \"err\", err)\n\t\t}\n\t\tcs.enterPrecommit(ti.Height, ti.Round)\n\t\tcs.enterNewRound(ti.Height, ti.Round+1)\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"Invalid timeout step: %v\", ti.Step))\n\t}\n\n}\n\nfunc (cs *State) handleTxsAvailable() {\n\tcs.mtx.Lock()\n\tdefer cs.mtx.Unlock()\n\n\t// We only need to do this for round 0.\n\tif cs.Round != 0 {\n\t\treturn\n\t}\n\n\tswitch cs.Step {\n\tcase cstypes.RoundStepNewHeight: // timeoutCommit phase\n\t\tif cs.needProofBlock(cs.Height) {\n\t\t\t// enterPropose will be called by enterNewRound\n\t\t\treturn\n\t\t}\n\n\t\t// +1ms to ensure RoundStepNewRound timeout always happens after RoundStepNewHeight\n\t\ttimeoutCommit := cs.StartTime.Sub(tmtime.Now()) + 1*time.Millisecond\n\t\tcs.scheduleTimeout(timeoutCommit, cs.Height, 0, cstypes.RoundStepNewRound)\n\tcase cstypes.RoundStepNewRound: // after timeoutCommit\n\t\tcs.enterPropose(cs.Height, 0)\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// State functions\n// Used internally by handleTimeout and handleMsg to make state transitions\n\n// Enter: `timeoutNewHeight` by startTime (commitTime+timeoutCommit),\n// \tor, if SkipTimeoutCommit==true, after receiving all precommits from (height,round-1)\n// Enter: `timeoutPrecommits` after any +2/3 precommits from (height,round-1)\n// Enter: +2/3 precommits for nil at (height,round-1)\n// Enter: +2/3 prevotes any or +2/3 precommits for block or any from (height, round)\n// NOTE: cs.StartTime was already set for height.\nfunc (cs *State) enterNewRound(height int64, round int32) {\n\tlogger := cs.Logger.With(\"height\", height, \"round\", round)\n\n\tif cs.Height != height || round < cs.Round || (cs.Round == round && cs.Step != cstypes.RoundStepNewHeight) {\n\t\tlogger.Debug(fmt.Sprintf(\n\t\t\t\"enterNewRound(%v/%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tround,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\n\tif now := tmtime.Now(); cs.StartTime.After(now) {\n\t\tlogger.Info(\"Need to set a buffer and log message here for sanity.\", \"startTime\", cs.StartTime, \"now\", now)\n\t}\n\n\tlogger.Info(fmt.Sprintf(\"enterNewRound(%v/%v). Current: %v/%v/%v\", height, round, cs.Height, cs.Round, cs.Step))\n\n\t// Increment validators if necessary\n\tvalidators := cs.Validators\n\tif cs.Round < round {\n\t\tvalidators = validators.Copy()\n\t\tvalidators.IncrementProposerPriority(tmmath.SafeSubInt32(round, cs.Round))\n\t}\n\n\t// Setup new round\n\t// we don't fire newStep for this step,\n\t// but we fire an event, so update the round step first\n\tcs.updateRoundStep(round, cstypes.RoundStepNewRound)\n\tcs.Validators = validators\n\tif round == 0 {\n\t\t// We've already reset these upon new height,\n\t\t// and meanwhile we might have received a proposal\n\t\t// for round 0.\n\t} else {\n\t\tlogger.Info(\"Resetting Proposal info\")\n\t\tcs.Proposal = nil\n\t\tcs.ProposalBlock = nil\n\t\tcs.ProposalBlockParts = nil\n\t}\n\tcs.Votes.SetRound(tmmath.SafeAddInt32(round, 1)) // also track next round (round+1) to allow round-skipping\n\tcs.TriggeredTimeoutPrecommit = false\n\n\tif err := cs.eventBus.PublishEventNewRound(cs.NewRoundEvent()); err != nil {\n\t\tcs.Logger.Error(\"Error publishing new round\", \"err\", err)\n\t}\n\tcs.metrics.Rounds.Set(float64(round))\n\n\t// Wait for txs to be available in the mempool\n\t// before we enterPropose in round 0. If the last block changed the app hash,\n\t// we may need an empty \"proof\" block, and enterPropose immediately.\n\twaitForTxs := cs.config.WaitForTxs() && round == 0 && !cs.needProofBlock(height)\n\tif waitForTxs {\n\t\tif cs.config.CreateEmptyBlocksInterval > 0 {\n\t\t\tcs.scheduleTimeout(cs.config.CreateEmptyBlocksInterval, height, round,\n\t\t\t\tcstypes.RoundStepNewRound)\n\t\t}\n\t} else {\n\t\tcs.enterPropose(height, round)\n\t}\n}\n\n// needProofBlock returns true on the first height (so the genesis app hash is signed right away)\n// and where the last block (height-1) caused the app hash to change\nfunc (cs *State) needProofBlock(height int64) bool {\n\tif height == cs.state.InitialHeight {\n\t\treturn true\n\t}\n\n\tlastBlockMeta := cs.blockStore.LoadBlockMeta(height - 1)\n\tif lastBlockMeta == nil {\n\t\tpanic(fmt.Sprintf(\"needProofBlock: last block meta for height %d not found\", height-1))\n\t}\n\treturn !bytes.Equal(cs.state.AppHash, lastBlockMeta.Header.AppHash)\n}\n\nfunc (cs *State) isProposer(address []byte) bool {\n\treturn bytes.Equal(cs.Validators.GetProposer().Address, address)\n}\n\nfunc (cs *State) defaultDecideProposal(height int64, round int32) {\n\tvar block *types.Block\n\tvar blockParts *types.PartSet\n\n\t// Decide on block\n\tif cs.ValidBlock != nil {\n\t\t// If there is valid block, choose that.\n\t\tblock, blockParts = cs.ValidBlock, cs.ValidBlockParts\n\t} else {\n\t\t// Create a new proposal block from state/txs from the mempool.\n\t\tblock, blockParts = cs.createProposalBlock()\n\t\tif block == nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Flush the WAL. Otherwise, we may not recompute the same proposal to sign,\n\t// and the privValidator will refuse to sign anything.\n\tif err := cs.wal.FlushAndSync(); err != nil {\n\t\tcs.Logger.Error(\"Error flushing to disk\")\n\t}\n\n\t// Make proposal\n\tpropBlockID := types.BlockID{Hash: block.Hash(), PartSetHeader: blockParts.Header()}\n\tproposal := types.NewProposal(height, round, cs.ValidRound, propBlockID)\n\tp := proposal.ToProto()\n\tif err := cs.privValidator.SignProposal(cs.state.ChainID, p); err == nil {\n\t\tproposal.Signature = p.Signature\n\n\t\t// send proposal and block parts on internal msg queue\n\t\tcs.sendInternalMessage(msgInfo{&ProposalMessage{proposal}, \"\"})\n\t\tfor i := 0; i < int(blockParts.Total()); i++ {\n\t\t\tpart := blockParts.GetPart(i)\n\t\t\tcs.sendInternalMessage(msgInfo{&BlockPartMessage{cs.Height, cs.Round, part}, \"\"})\n\t\t}\n\t\tcs.Logger.Info(\"Signed proposal\", \"height\", height, \"round\", round, \"proposal\", proposal)\n\t\tcs.Logger.Debug(fmt.Sprintf(\"Signed proposal block: %v\", block))\n\t} else if !cs.replayMode {\n\t\tcs.Logger.Error(\"enterPropose: Error signing proposal\", \"height\", height, \"round\", round, \"err\", err)\n\t}\n}\n\n// Returns true if the proposal block is complete &&\n// (if POLRound was proposed, we have +2/3 prevotes from there).\nfunc (cs *State) isProposalComplete() bool {\n\tif cs.Proposal == nil || cs.ProposalBlock == nil {\n\t\treturn false\n\t}\n\t// we have the proposal. if there's a POLRound,\n\t// make sure we have the prevotes from it too\n\tif cs.Proposal.POLRound < 0 {\n\t\treturn true\n\t}\n\t// if this is false the proposer is lying or we haven't received the POL yet\n\treturn cs.Votes.Prevotes(cs.Proposal.POLRound).HasTwoThirdsMajority()\n\n}\n\n// Create the next block to propose and return it. Returns nil block upon error.\n//\n// We really only need to return the parts, but the block is returned for\n// convenience so we can log the proposal block.\n//\n// NOTE: keep it side-effect free for clarity.\n// CONTRACT: cs.privValidator is not nil.\nfunc (cs *State) createProposalBlock() (block *types.Block, blockParts *types.PartSet) {\n\tif cs.privValidator == nil {\n\t\tpanic(\"entered createProposalBlock with privValidator being nil\")\n\t}\n\n\tvar commit *types.Commit\n\tswitch {\n\tcase cs.Height == cs.state.InitialHeight:\n\t\t// We're creating a proposal for the first block.\n\t\t// The commit is empty, but not nil.\n\t\tcommit = types.NewCommit(0, 0, types.BlockID{}, nil)\n\tcase cs.LastCommit.HasTwoThirdsMajority():\n\t\t// Make the commit from LastCommit\n\t\tcommit = cs.LastCommit.MakeCommit()\n\tdefault: // This shouldn't happen.\n\t\tcs.Logger.Error(\"enterPropose: Cannot propose anything: No commit for the previous block\")\n\t\treturn\n\t}\n\n\tif cs.privValidatorPubKey == nil {\n\t\t// If this node is a validator & proposer in the current round, it will\n\t\t// miss the opportunity to create a block.\n\t\tcs.Logger.Error(fmt.Sprintf(\"enterPropose: %v\", errPubKeyIsNotSet))\n\t\treturn\n\t}\n\tproposerAddr := cs.privValidatorPubKey.Address()\n\n\treturn cs.blockExec.CreateProposalBlock(cs.Height, cs.state, commit, proposerAddr)\n}\n\n// Enter: any +2/3 prevotes at next round.\nfunc (cs *State) enterPrevoteWait(height int64, round int32) {\n\tlogger := cs.Logger.With(\"height\", height, \"round\", round)\n\n\tif cs.Height != height || round < cs.Round || (cs.Round == round && cstypes.RoundStepPrevoteWait <= cs.Step) {\n\t\tlogger.Debug(fmt.Sprintf(\n\t\t\t\"enterPrevoteWait(%v/%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tround,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\tif !cs.Votes.Prevotes(round).HasTwoThirdsAny() {\n\t\tpanic(fmt.Sprintf(\"enterPrevoteWait(%v/%v), but Prevotes does not have any +2/3 votes\", height, round))\n\t}\n\tlogger.Info(fmt.Sprintf(\"enterPrevoteWait(%v/%v). Current: %v/%v/%v\", height, round, cs.Height, cs.Round, cs.Step))\n\n\tdefer func() {\n\t\t// Done enterPrevoteWait:\n\t\tcs.updateRoundStep(round, cstypes.RoundStepPrevoteWait)\n\t\tcs.newStep()\n\t}()\n\n\t// Wait for some more prevotes; enterPrecommit\n\tcs.scheduleTimeout(cs.config.Prevote(round), height, round, cstypes.RoundStepPrevoteWait)\n}\n\n// Enter: any +2/3 precommits for next round.\nfunc (cs *State) enterPrecommitWait(height int64, round int32) {\n\tlogger := cs.Logger.With(\"height\", height, \"round\", round)\n\n\tif cs.Height != height || round < cs.Round || (cs.Round == round && cs.TriggeredTimeoutPrecommit) {\n\t\tlogger.Debug(\n\t\t\tfmt.Sprintf(\n\t\t\t\t\"enterPrecommitWait(%v/%v): Invalid args. \"+\n\t\t\t\t\t\"Current state is Height/Round: %v/%v/, TriggeredTimeoutPrecommit:%v\",\n\t\t\t\theight, round, cs.Height, cs.Round, cs.TriggeredTimeoutPrecommit))\n\t\treturn\n\t}\n\tif !cs.Votes.Precommits(round).HasTwoThirdsAny() {\n\t\tpanic(fmt.Sprintf(\"enterPrecommitWait(%v/%v), but Precommits does not have any +2/3 votes\", height, round))\n\t}\n\tlogger.Info(fmt.Sprintf(\"enterPrecommitWait(%v/%v). Current: %v/%v/%v\", height, round, cs.Height, cs.Round, cs.Step))\n\n\tdefer func() {\n\t\t// Done enterPrecommitWait:\n\t\tcs.TriggeredTimeoutPrecommit = true\n\t\tcs.newStep()\n\t}()\n\n\t// Wait for some more precommits; enterNewRound\n\tcs.scheduleTimeout(cs.config.Precommit(round), height, round, cstypes.RoundStepPrecommitWait)\n}\n\n// Enter: +2/3 precommits for block\nfunc (cs *State) enterCommit(height int64, commitRound int32) {\n\tlogger := cs.Logger.With(\"height\", height, \"commitRound\", commitRound)\n\n\tif cs.Height != height || cstypes.RoundStepCommit <= cs.Step {\n\t\tlogger.Debug(fmt.Sprintf(\n\t\t\t\"enterCommit(%v/%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tcommitRound,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\tlogger.Info(fmt.Sprintf(\"enterCommit(%v/%v). Current: %v/%v/%v\", height, commitRound, cs.Height, cs.Round, cs.Step))\n\n\tdefer func() {\n\t\t// Done enterCommit:\n\t\t// keep cs.Round the same, commitRound points to the right Precommits set.\n\t\tcs.updateRoundStep(cs.Round, cstypes.RoundStepCommit)\n\t\tcs.CommitRound = commitRound\n\t\tcs.CommitTime = tmtime.Now()\n\t\tcs.newStep()\n\n\t\t// Maybe finalize immediately.\n\t\tcs.tryFinalizeCommit(height)\n\t}()\n\n\tblockID, ok := cs.Votes.Precommits(commitRound).TwoThirdsMajority()\n\tif !ok {\n\t\tpanic(\"RunActionCommit() expects +2/3 precommits\")\n\t}\n\n\t// The Locked* fields no longer matter.\n\t// Move them over to ProposalBlock if they match the commit hash,\n\t// otherwise they'll be cleared in updateToState.\n\tif cs.LockedBlock.HashesTo(blockID.Hash) {\n\t\tlogger.Info(\"Commit is for locked block. Set ProposalBlock=LockedBlock\", \"blockHash\", blockID.Hash)\n\t\tcs.ProposalBlock = cs.LockedBlock\n\t\tcs.ProposalBlockParts = cs.LockedBlockParts\n\t}\n\n\t// If we don't have the block being committed, set up to get it.\n\tif !cs.ProposalBlock.HashesTo(blockID.Hash) {\n\t\tif !cs.ProposalBlockParts.HasHeader(blockID.PartSetHeader) {\n\t\t\tlogger.Info(\n\t\t\t\t\"Commit is for a block we don't know about. Set ProposalBlock=nil\",\n\t\t\t\t\"proposal\",\n\t\t\t\tcs.ProposalBlock.Hash(),\n\t\t\t\t\"commit\",\n\t\t\t\tblockID.Hash)\n\t\t\t// We're getting the wrong block.\n\t\t\t// Set up ProposalBlockParts and keep waiting.\n\t\t\tcs.ProposalBlock = nil\n\t\t\tcs.ProposalBlockParts = types.NewPartSetFromHeader(blockID.PartSetHeader)\n\t\t\tif err := cs.eventBus.PublishEventValidBlock(cs.RoundStateEvent()); err != nil {\n\t\t\t\tcs.Logger.Error(\"Error publishing valid block\", \"err\", err)\n\t\t\t}\n\t\t\tcs.evsw.FireEvent(types.EventValidBlock, &cs.RoundState)\n\t\t}\n\t\t// else {\n\t\t// We just need to keep waiting.\n\t\t// }\n\t}\n}\n\n// If we have the block AND +2/3 commits for it, finalize.\nfunc (cs *State) tryFinalizeCommit(height int64) {\n\tlogger := cs.Logger.With(\"height\", height)\n\n\tif cs.Height != height {\n\t\tpanic(fmt.Sprintf(\"tryFinalizeCommit() cs.Height: %v vs height: %v\", cs.Height, height))\n\t}\n\n\tblockID, ok := cs.Votes.Precommits(cs.CommitRound).TwoThirdsMajority()\n\tif !ok || len(blockID.Hash) == 0 {\n\t\tlogger.Error(\"Attempt to finalize failed. There was no +2/3 majority, or +2/3 was for <nil>.\")\n\t\treturn\n\t}\n\tif !cs.ProposalBlock.HashesTo(blockID.Hash) {\n\t\t// TODO: this happens every time if we're not a validator (ugly logs)\n\t\t// TODO: ^^ wait, why does it matter that we're a validator?\n\t\tlogger.Info(\n\t\t\t\"Attempt to finalize failed. We don't have the commit block.\",\n\t\t\t\"proposal-block\",\n\t\t\tcs.ProposalBlock.Hash(),\n\t\t\t\"commit-block\",\n\t\t\tblockID.Hash)\n\t\treturn\n\t}\n\n\t//\tgo\n\tcs.finalizeCommit(height)\n}\n\n// Increment height and goto cstypes.RoundStepNewHeight\nfunc (cs *State) finalizeCommit(height int64) {\n\tif cs.Height != height || cs.Step != cstypes.RoundStepCommit {\n\t\tcs.Logger.Debug(fmt.Sprintf(\n\t\t\t\"finalizeCommit(%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\n\tblockID, ok := cs.Votes.Precommits(cs.CommitRound).TwoThirdsMajority()\n\tblock, blockParts := cs.ProposalBlock, cs.ProposalBlockParts\n\n\tif !ok {\n\t\tpanic(\"Cannot finalizeCommit, commit does not have two thirds majority\")\n\t}\n\tif !blockParts.HasHeader(blockID.PartSetHeader) {\n\t\tpanic(\"Expected ProposalBlockParts header to be commit header\")\n\t}\n\tif !block.HashesTo(blockID.Hash) {\n\t\tpanic(\"Cannot finalizeCommit, ProposalBlock does not hash to commit hash\")\n\t}\n\tif err := cs.blockExec.ValidateBlock(cs.state, block); err != nil {\n\t\tpanic(fmt.Errorf(\"+2/3 committed an invalid block: %w\", err))\n\t}\n\n\tcs.Logger.Info(\"Finalizing commit of block with N txs\",\n\t\t\"height\", block.Height,\n\t\t\"hash\", block.Hash(),\n\t\t\"root\", block.AppHash,\n\t\t\"N\", len(block.Txs))\n\tcs.Logger.Info(fmt.Sprintf(\"%v\", block))\n\n\tfail.Fail() // XXX\n\n\t// Save to blockStore.\n\tif cs.blockStore.Height() < block.Height {\n\t\t// NOTE: the seenCommit is local justification to commit this block,\n\t\t// but may differ from the LastCommit included in the next block\n\t\tprecommits := cs.Votes.Precommits(cs.CommitRound)\n\t\tseenCommit := precommits.MakeCommit()\n\t\tcs.blockStore.SaveBlock(block, blockParts, seenCommit)\n\t} else {\n\t\t// Happens during replay if we already saved the block but didn't commit\n\t\tcs.Logger.Info(\"Calling finalizeCommit on already stored block\", \"height\", block.Height)\n\t}\n\n\tfail.Fail() // XXX\n\n\t// Write EndHeightMessage{} for this height, implying that the blockstore\n\t// has saved the block.\n\t//\n\t// If we crash before writing this EndHeightMessage{}, we will recover by\n\t// running ApplyBlock during the ABCI handshake when we restart.  If we\n\t// didn't save the block to the blockstore before writing\n\t// EndHeightMessage{}, we'd have to change WAL replay -- currently it\n\t// complains about replaying for heights where an #ENDHEIGHT entry already\n\t// exists.\n\t//\n\t// Either way, the State should not be resumed until we\n\t// successfully call ApplyBlock (ie. later here, or in Handshake after\n\t// restart).\n\tendMsg := EndHeightMessage{height}\n\tif err := cs.wal.WriteSync(endMsg); err != nil { // NOTE: fsync\n\t\tpanic(fmt.Sprintf(\"Failed to write %v msg to consensus wal due to %v. Check your FS and restart the node\",\n\t\t\tendMsg, err))\n\t}\n\n\tfail.Fail() // XXX\n\n\t// Create a copy of the state for staging and an event cache for txs.\n\tstateCopy := cs.state.Copy()\n\n\t// Execute and commit the block, update and save the state, and update the mempool.\n\t// NOTE The block.AppHash wont reflect these txs until the next block.\n\tvar err error\n\tvar retainHeight int64\n\tstateCopy, retainHeight, err = cs.blockExec.ApplyBlock(\n\t\tstateCopy,\n\t\ttypes.BlockID{Hash: block.Hash(), PartSetHeader: blockParts.Header()},\n\t\tblock)\n\tif err != nil {\n\t\tcs.Logger.Error(\"Error on ApplyBlock\", \"err\", err)\n\t\treturn\n\t}\n\n\tfail.Fail() // XXX\n\n\t// Prune old heights, if requested by ABCI app.\n\tif retainHeight > 0 {\n\t\tpruned, err := cs.pruneBlocks(retainHeight)\n\t\tif err != nil {\n\t\t\tcs.Logger.Error(\"Failed to prune blocks\", \"retainHeight\", retainHeight, \"err\", err)\n\t\t} else {\n\t\t\tcs.Logger.Info(\"Pruned blocks\", \"pruned\", pruned, \"retainHeight\", retainHeight)\n\t\t}\n\t}\n\n\t// must be called before we update state\n\tcs.recordMetrics(height, block)\n\n\t// NewHeightStep!\n\tcs.updateToState(stateCopy)\n\n\tfail.Fail() // XXX\n\n\t// Private validator might have changed it's key pair => refetch pubkey.\n\tif err := cs.updatePrivValidatorPubKey(); err != nil {\n\t\tcs.Logger.Error(\"Can't get private validator pubkey\", \"err\", err)\n\t}\n\n\t// cs.StartTime is already set.\n\t// Schedule Round0 to start soon.\n\tcs.scheduleRound0(&cs.RoundState)\n\n\t// By here,\n\t// * cs.Height has been increment to height+1\n\t// * cs.Step is now cstypes.RoundStepNewHeight\n\t// * cs.StartTime is set to when we will start round0.\n}\n\nfunc (cs *State) pruneBlocks(retainHeight int64) (uint64, error) {\n\tbase := cs.blockStore.Base()\n\tif retainHeight <= base {\n\t\treturn 0, nil\n\t}\n\tpruned, err := cs.blockStore.PruneBlocks(retainHeight)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to prune block store: %w\", err)\n\t}\n\terr = cs.blockExec.Store().PruneStates(base, retainHeight)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to prune state database: %w\", err)\n\t}\n\treturn pruned, nil\n}\n\nfunc (cs *State) recordMetrics(height int64, block *types.Block) {\n\tcs.metrics.Validators.Set(float64(cs.Validators.Size()))\n\tcs.metrics.ValidatorsPower.Set(float64(cs.Validators.TotalVotingPower()))\n\n\tvar (\n\t\tmissingValidators      int\n\t\tmissingValidatorsPower int64\n\t)\n\t// height=0 -> MissingValidators and MissingValidatorsPower are both 0.\n\t// Remember that the first LastCommit is intentionally empty, so it's not\n\t// fair to increment missing validators number.\n\tif height > cs.state.InitialHeight {\n\t\t// Sanity check that commit size matches validator set size - only applies\n\t\t// after first block.\n\t\tvar (\n\t\t\tcommitSize = block.LastCommit.Size()\n\t\t\tvalSetLen  = len(cs.LastValidators.Validators)\n\t\t\taddress    types.Address\n\t\t)\n\t\tif commitSize != valSetLen {\n\t\t\tpanic(fmt.Sprintf(\"commit size (%d) doesn't match valset length (%d) at height %d\\n\\n%v\\n\\n%v\",\n\t\t\t\tcommitSize, valSetLen, block.Height, block.LastCommit.Signatures, cs.LastValidators.Validators))\n\t\t}\n\n\t\tif cs.privValidator != nil {\n\t\t\tif cs.privValidatorPubKey == nil {\n\t\t\t\t// Metrics won't be updated, but it's not critical.\n\t\t\t\tcs.Logger.Error(fmt.Sprintf(\"recordMetrics: %v\", errPubKeyIsNotSet))\n\t\t\t} else {\n\t\t\t\taddress = cs.privValidatorPubKey.Address()\n\t\t\t}\n\t\t}\n\n\t\tfor i, val := range cs.LastValidators.Validators {\n\t\t\tcommitSig := block.LastCommit.Signatures[i]\n\t\t\tif commitSig.Absent() {\n\t\t\t\tmissingValidators++\n\t\t\t\tmissingValidatorsPower += val.VotingPower\n\t\t\t}\n\n\t\t\tif bytes.Equal(val.Address, address) {\n\t\t\t\tlabel := []string{\n\t\t\t\t\t\"validator_address\", val.Address.String(),\n\t\t\t\t}\n\t\t\t\tcs.metrics.ValidatorPower.With(label...).Set(float64(val.VotingPower))\n\t\t\t\tif commitSig.ForBlock() {\n\t\t\t\t\tcs.metrics.ValidatorLastSignedHeight.With(label...).Set(float64(height))\n\t\t\t\t} else {\n\t\t\t\t\tcs.metrics.ValidatorMissedBlocks.With(label...).Add(float64(1))\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\tcs.metrics.MissingValidators.Set(float64(missingValidators))\n\tcs.metrics.MissingValidatorsPower.Set(float64(missingValidatorsPower))\n\n\t// NOTE: byzantine validators power and count is only for consensus evidence i.e. duplicate vote\n\tvar (\n\t\tbyzantineValidatorsPower = int64(0)\n\t\tbyzantineValidatorsCount = int64(0)\n\t)\n\tfor _, ev := range block.Evidence.Evidence {\n\t\tif dve, ok := ev.(*types.DuplicateVoteEvidence); ok {\n\t\t\tif _, val := cs.Validators.GetByAddress(dve.VoteA.ValidatorAddress); val != nil {\n\t\t\t\tbyzantineValidatorsCount++\n\t\t\t\tbyzantineValidatorsPower += val.VotingPower\n\t\t\t}\n\t\t}\n\t}\n\tcs.metrics.ByzantineValidators.Set(float64(byzantineValidatorsCount))\n\tcs.metrics.ByzantineValidatorsPower.Set(float64(byzantineValidatorsPower))\n\n\tif height > 1 {\n\t\tlastBlockMeta := cs.blockStore.LoadBlockMeta(height - 1)\n\t\tif lastBlockMeta != nil {\n\t\t\tcs.metrics.BlockIntervalSeconds.Observe(\n\t\t\t\tblock.Time.Sub(lastBlockMeta.Header.Time).Seconds(),\n\t\t\t)\n\t\t}\n\t}\n\n\tcs.metrics.NumTxs.Set(float64(len(block.Data.Txs)))\n\tcs.metrics.TotalTxs.Add(float64(len(block.Data.Txs)))\n\tcs.metrics.BlockSizeBytes.Set(float64(block.Size()))\n\tcs.metrics.CommittedHeight.Set(float64(block.Height))\n}\n\n//-----------------------------------------------------------------------------\n\n// NOTE: block is not necessarily valid.\n// Asynchronously triggers either enterPrevote (before we timeout of propose) or tryFinalizeCommit,\n// once we have the full block.\nfunc (cs *State) addProposalBlockPart(msg *BlockPartMessage, peerID p2p.ID) (added bool, err error) {\n\theight, round, part := msg.Height, msg.Round, msg.Part\n\n\t// Blocks might be reused, so round mismatch is OK\n\tif cs.Height != height {\n\t\tcs.Logger.Debug(\"Received block part from wrong height\", \"height\", height, \"round\", round)\n\t\treturn false, nil\n\t}\n\n\t// We're not expecting a block part.\n\tif cs.ProposalBlockParts == nil {\n\t\t// NOTE: this can happen when we've gone to a higher round and\n\t\t// then receive parts from the previous round - not necessarily a bad peer.\n\t\tcs.Logger.Info(\"Received a block part when we're not expecting any\",\n\t\t\t\"height\", height, \"round\", round, \"index\", part.Index, \"peer\", peerID)\n\t\treturn false, nil\n\t}\n\n\tadded, err = cs.ProposalBlockParts.AddPart(part)\n\tif err != nil {\n\t\treturn added, err\n\t}\n\tif cs.ProposalBlockParts.ByteSize() > cs.state.ConsensusParams.Block.MaxBytes {\n\t\treturn added, fmt.Errorf(\"total size of proposal block parts exceeds maximum block bytes (%d > %d)\",\n\t\t\tcs.ProposalBlockParts.ByteSize(), cs.state.ConsensusParams.Block.MaxBytes,\n\t\t)\n\t}\n\tif added && cs.ProposalBlockParts.IsComplete() {\n\t\tbz, err := ioutil.ReadAll(cs.ProposalBlockParts.GetReader())\n\t\tif err != nil {\n\t\t\treturn added, err\n\t\t}\n\n\t\tvar pbb = new(tmproto.Block)\n\t\terr = proto.Unmarshal(bz, pbb)\n\t\tif err != nil {\n\t\t\treturn added, err\n\t\t}\n\n\t\tblock, err := types.BlockFromProto(pbb)\n\t\tif err != nil {\n\t\t\treturn added, err\n\t\t}\n\n\t\tcs.ProposalBlock = block\n\t\t// NOTE: it's possible to receive complete proposal blocks for future rounds without having the proposal\n\t\tcs.Logger.Info(\"Received complete proposal block\", \"height\", cs.ProposalBlock.Height, \"hash\", cs.ProposalBlock.Hash())\n\t\tif err := cs.eventBus.PublishEventCompleteProposal(cs.CompleteProposalEvent()); err != nil {\n\t\t\tcs.Logger.Error(\"Error publishing event complete proposal\", \"err\", err)\n\t\t}\n\n\t\t// Update Valid* if we can.\n\t\tprevotes := cs.Votes.Prevotes(cs.Round)\n\t\tblockID, hasTwoThirds := prevotes.TwoThirdsMajority()\n\t\tif hasTwoThirds && !blockID.IsZero() && (cs.ValidRound < cs.Round) {\n\t\t\tif cs.ProposalBlock.HashesTo(blockID.Hash) {\n\t\t\t\tcs.Logger.Info(\"Updating valid block to new proposal block\",\n\t\t\t\t\t\"valid-round\", cs.Round, \"valid-block-hash\", cs.ProposalBlock.Hash())\n\t\t\t\tcs.ValidRound = cs.Round\n\t\t\t\tcs.ValidBlock = cs.ProposalBlock\n\t\t\t\tcs.ValidBlockParts = cs.ProposalBlockParts\n\t\t\t}\n\t\t\t// TODO: In case there is +2/3 majority in Prevotes set for some\n\t\t\t// block and cs.ProposalBlock contains different block, either\n\t\t\t// proposer is faulty or voting power of faulty processes is more\n\t\t\t// than 1/3. We should trigger in the future accountability\n\t\t\t// procedure at this point.\n\t\t}\n\n\t\tif cs.Step <= cstypes.RoundStepPropose && cs.isProposalComplete() {\n\t\t\t// Move onto the next step\n\t\t\tcs.enterPrevote(height, cs.Round)\n\t\t\tif hasTwoThirds { // this is optimisation as this will be triggered when prevote is added\n\t\t\t\tcs.enterPrecommit(height, cs.Round)\n\t\t\t}\n\t\t} else if cs.Step == cstypes.RoundStepCommit {\n\t\t\t// If we're waiting on the proposal block...\n\t\t\tcs.tryFinalizeCommit(height)\n\t\t}\n\t\treturn added, nil\n\t}\n\treturn added, nil\n}\n\n// Attempt to add the vote. if its a duplicate signature, dupeout the validator\nfunc (cs *State) tryAddVote(vote *types.Vote, peerID p2p.ID) (bool, error) {\n\tadded, err := cs.addVote(vote, peerID)\n\tif err != nil {\n\t\t// If the vote height is off, we'll just ignore it,\n\t\t// But if it's a conflicting sig, add it to the cs.evpool.\n\t\t// If it's otherwise invalid, punish peer.\n\t\t// nolint: gocritic\n\t\tif voteErr, ok := err.(*types.ErrVoteConflictingVotes); ok {\n\t\t\tif cs.privValidatorPubKey == nil {\n\t\t\t\treturn false, errPubKeyIsNotSet\n\t\t\t}\n\n\t\t\tif bytes.Equal(vote.ValidatorAddress, cs.privValidatorPubKey.Address()) {\n\t\t\t\tcs.Logger.Error(\n\t\t\t\t\t\"Found conflicting vote from ourselves. Did you unsafe_reset a validator?\",\n\t\t\t\t\t\"height\",\n\t\t\t\t\tvote.Height,\n\t\t\t\t\t\"round\",\n\t\t\t\t\tvote.Round,\n\t\t\t\t\t\"type\",\n\t\t\t\t\tvote.Type)\n\t\t\t\treturn added, err\n\t\t\t}\n\t\t\tvar timestamp time.Time\n\t\t\tif voteErr.VoteA.Height == cs.state.InitialHeight {\n\t\t\t\ttimestamp = cs.state.LastBlockTime // genesis time\n\t\t\t} else {\n\t\t\t\ttimestamp = sm.MedianTime(cs.LastCommit.MakeCommit(), cs.LastValidators)\n\t\t\t}\n\t\t\tev := types.NewDuplicateVoteEvidence(voteErr.VoteA, voteErr.VoteB, timestamp, cs.Validators)\n\t\t\tevidenceErr := cs.evpool.AddEvidenceFromConsensus(ev)\n\t\t\tif evidenceErr != nil {\n\t\t\t\tcs.Logger.Error(\"Failed to add evidence to the evidence pool\", \"err\", evidenceErr)\n\t\t\t}\n\t\t\treturn added, err\n\t\t} else if err == types.ErrVoteNonDeterministicSignature {\n\t\t\tcs.Logger.Debug(\"Vote has non-deterministic signature\", \"err\", err)\n\t\t} else {\n\t\t\t// Either\n\t\t\t// 1) bad peer OR\n\t\t\t// 2) not a bad peer? this can also err sometimes with \"Unexpected step\" OR\n\t\t\t// 3) tmkms use with multiple validators connecting to a single tmkms instance\n\t\t\t// \t\t(https://github.com/tendermint/tendermint/issues/3839).\n\t\t\tcs.Logger.Info(\"Error attempting to add vote\", \"err\", err)\n\t\t\treturn added, ErrAddingVote\n\t\t}\n\t}\n\treturn added, nil\n}\n\n//-----------------------------------------------------------------------------\n\n// CONTRACT: cs.privValidator is not nil.\nfunc (cs *State) signVote(\n\tmsgType tmproto.SignedMsgType,\n\thash []byte,\n\theader types.PartSetHeader,\n) (*types.Vote, error) {\n\t// Flush the WAL. Otherwise, we may not recompute the same vote to sign,\n\t// and the privValidator will refuse to sign anything.\n\tif err := cs.wal.FlushAndSync(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif cs.privValidatorPubKey == nil {\n\t\treturn nil, errPubKeyIsNotSet\n\t}\n\taddr := cs.privValidatorPubKey.Address()\n\tvalIdx, _ := cs.Validators.GetByAddress(addr)\n\n\tvote := &types.Vote{\n\t\tValidatorAddress: addr,\n\t\tValidatorIndex:   valIdx,\n\t\tHeight:           cs.Height,\n\t\tRound:            cs.Round,\n\t\tTimestamp:        cs.voteTime(),\n\t\tType:             msgType,\n\t\tBlockID:          types.BlockID{Hash: hash, PartSetHeader: header},\n\t}\n\tv := vote.ToProto()\n\terr := cs.privValidator.SignVote(cs.state.ChainID, v)\n\tvote.Signature = v.Signature\n\n\treturn vote, err\n}\n\nfunc (cs *State) voteTime() time.Time {\n\tnow := tmtime.Now()\n\tminVoteTime := now\n\t// TODO: We should remove next line in case we don't vote for v in case cs.ProposalBlock == nil,\n\t// even if cs.LockedBlock != nil. See https://docs.tendermint.com/master/spec/.\n\ttimeIota := time.Duration(cs.state.ConsensusParams.Block.TimeIotaMs) * time.Millisecond\n\tif cs.LockedBlock != nil {\n\t\t// See the BFT time spec https://docs.tendermint.com/master/spec/consensus/bft-time.html\n\t\tminVoteTime = cs.LockedBlock.Time.Add(timeIota)\n\t} else if cs.ProposalBlock != nil {\n\t\tminVoteTime = cs.ProposalBlock.Time.Add(timeIota)\n\t}\n\n\tif now.After(minVoteTime) {\n\t\treturn now\n\t}\n\treturn minVoteTime\n}\n\n// sign the vote and publish on internalMsgQueue\nfunc (cs *State) signAddVote(msgType tmproto.SignedMsgType, hash []byte, header types.PartSetHeader) *types.Vote {\n\tif cs.privValidator == nil { // the node does not have a key\n\t\treturn nil\n\t}\n\n\tif cs.privValidatorPubKey == nil {\n\t\t// Vote won't be signed, but it's not critical.\n\t\tcs.Logger.Error(fmt.Sprintf(\"signAddVote: %v\", errPubKeyIsNotSet))\n\t\treturn nil\n\t}\n\n\t// If the node not in the validator set, do nothing.\n\tif !cs.Validators.HasAddress(cs.privValidatorPubKey.Address()) {\n\t\treturn nil\n\t}\n\n\t// TODO: pass pubKey to signVote\n\tvote, err := cs.signVote(msgType, hash, header)\n\tif err == nil {\n\t\tcs.sendInternalMessage(msgInfo{&VoteMessage{vote}, \"\"})\n\t\tcs.Logger.Info(\"Signed and pushed vote\", \"height\", cs.Height, \"round\", cs.Round, \"vote\", vote)\n\t\treturn vote\n\t}\n\t// if !cs.replayMode {\n\tcs.Logger.Error(\"Error signing vote\", \"height\", cs.Height, \"round\", cs.Round, \"vote\", vote, \"err\", err)\n\t//}\n\treturn nil\n}\n\n// updatePrivValidatorPubKey get's the private validator public key and\n// memoizes it. This func returns an error if the private validator is not\n// responding or responds with an error.\nfunc (cs *State) updatePrivValidatorPubKey() error {\n\tif cs.privValidator == nil {\n\t\treturn nil\n\t}\n\n\tpubKey, err := cs.privValidator.GetPubKey()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcs.privValidatorPubKey = pubKey\n\treturn nil\n}\n\n// look back to check existence of the node's consensus votes before joining consensus\nfunc (cs *State) checkDoubleSigningRisk(height int64) error {\n\tif cs.privValidator != nil && cs.privValidatorPubKey != nil && cs.config.DoubleSignCheckHeight > 0 && height > 0 {\n\t\tvalAddr := cs.privValidatorPubKey.Address()\n\t\tdoubleSignCheckHeight := cs.config.DoubleSignCheckHeight\n\t\tif doubleSignCheckHeight > height {\n\t\t\tdoubleSignCheckHeight = height\n\t\t}\n\t\tfor i := int64(1); i < doubleSignCheckHeight; i++ {\n\t\t\tlastCommit := cs.blockStore.LoadSeenCommit(height - i)\n\t\t\tif lastCommit != nil {\n\t\t\t\tfor sigIdx, s := range lastCommit.Signatures {\n\t\t\t\t\tif s.BlockIDFlag == types.BlockIDFlagCommit && bytes.Equal(s.ValidatorAddress, valAddr) {\n\t\t\t\t\t\tcs.Logger.Info(\"Found signature from the same key\", \"sig\", s, \"idx\", sigIdx, \"height\", height-i)\n\t\t\t\t\t\treturn ErrSignatureFoundInPastBlocks\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n//---------------------------------------------------------\n\nfunc CompareHRS(h1 int64, r1 int32, s1 cstypes.RoundStepType, h2 int64, r2 int32, s2 cstypes.RoundStepType) int {\n\tif h1 < h2 {\n\t\treturn -1\n\t} else if h1 > h2 {\n\t\treturn 1\n\t}\n\tif r1 < r2 {\n\t\treturn -1\n\t} else if r1 > r2 {\n\t\treturn 1\n\t}\n\tif s1 < s2 {\n\t\treturn -1\n\t} else if s1 > s2 {\n\t\treturn 1\n\t}\n\treturn 0\n}\n\n// repairWalFile decodes messages from src (until the decoder errors) and\n// writes them to dst.\nfunc repairWalFile(src, dst string) error {\n\tin, err := os.Open(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer in.Close()\n\n\tout, err := os.Open(dst)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer out.Close()\n\n\tvar (\n\t\tdec = NewWALDecoder(in)\n\t\tenc = NewWALEncoder(out)\n\t)\n\n\t// best-case repair (until first error is encountered)\n\tfor {\n\t\tmsg, err := dec.Decode()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\terr = enc.Encode(msg)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to encode msg: %w\", err)\n\t\t}\n\t}\n\n\treturn nil\n}\n"], "fixing_code": ["package consensus\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"path\"\n\t\"sync\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\tdbm \"github.com/tendermint/tm-db\"\n\n\tabcicli \"github.com/tendermint/tendermint/abci/client\"\n\tabci \"github.com/tendermint/tendermint/abci/types\"\n\t\"github.com/tendermint/tendermint/evidence\"\n\t\"github.com/tendermint/tendermint/libs/log\"\n\t\"github.com/tendermint/tendermint/libs/service\"\n\ttmsync \"github.com/tendermint/tendermint/libs/sync\"\n\tmempl \"github.com/tendermint/tendermint/mempool\"\n\t\"github.com/tendermint/tendermint/p2p\"\n\ttmproto \"github.com/tendermint/tendermint/proto/tendermint/types\"\n\tsm \"github.com/tendermint/tendermint/state\"\n\t\"github.com/tendermint/tendermint/store\"\n\t\"github.com/tendermint/tendermint/types\"\n)\n\n//----------------------------------------------\n// byzantine failures\n\n// Byzantine node sends two different prevotes (nil and blockID) to the same validator\nfunc TestByzantinePrevoteEquivocation(t *testing.T) {\n\tconst nValidators = 4\n\tconst byzantineNode = 0\n\tconst prevoteHeight = int64(2)\n\ttestName := \"consensus_byzantine_test\"\n\ttickerFunc := newMockTickerFunc(true)\n\tappFunc := newCounter\n\n\tgenDoc, privVals := randGenesisDoc(nValidators, false, 30)\n\tcss := make([]*State, nValidators)\n\n\tfor i := 0; i < nValidators; i++ {\n\t\tlogger := consensusLogger().With(\"test\", \"byzantine\", \"validator\", i)\n\t\tstateDB := dbm.NewMemDB() // each state needs its own db\n\t\tstateStore := sm.NewStore(stateDB)\n\t\tstate, _ := stateStore.LoadFromDBOrGenesisDoc(genDoc)\n\t\tthisConfig := ResetConfig(fmt.Sprintf(\"%s_%d\", testName, i))\n\t\tdefer os.RemoveAll(thisConfig.RootDir)\n\t\tensureDir(path.Dir(thisConfig.Consensus.WalFile()), 0700) // dir for wal\n\t\tapp := appFunc()\n\t\tvals := types.TM2PB.ValidatorUpdates(state.Validators)\n\t\tapp.InitChain(abci.RequestInitChain{Validators: vals})\n\n\t\tblockDB := dbm.NewMemDB()\n\t\tblockStore := store.NewBlockStore(blockDB)\n\n\t\t// one for mempool, one for consensus\n\t\tmtx := new(tmsync.Mutex)\n\t\tproxyAppConnMem := abcicli.NewLocalClient(mtx, app)\n\t\tproxyAppConnCon := abcicli.NewLocalClient(mtx, app)\n\n\t\t// Make Mempool\n\t\tmempool := mempl.NewCListMempool(thisConfig.Mempool, proxyAppConnMem, 0)\n\t\tmempool.SetLogger(log.TestingLogger().With(\"module\", \"mempool\"))\n\t\tif thisConfig.Consensus.WaitForTxs() {\n\t\t\tmempool.EnableTxsAvailable()\n\t\t}\n\n\t\t// Make a full instance of the evidence pool\n\t\tevidenceDB := dbm.NewMemDB()\n\t\tevpool, err := evidence.NewPool(evidenceDB, stateStore, blockStore)\n\t\trequire.NoError(t, err)\n\t\tevpool.SetLogger(logger.With(\"module\", \"evidence\"))\n\n\t\t// Make State\n\t\tblockExec := sm.NewBlockExecutor(stateStore, log.TestingLogger(), proxyAppConnCon, mempool, evpool)\n\t\tcs := NewState(thisConfig.Consensus, state, blockExec, blockStore, mempool, evpool)\n\t\tcs.SetLogger(cs.Logger)\n\t\t// set private validator\n\t\tpv := privVals[i]\n\t\tcs.SetPrivValidator(pv)\n\n\t\teventBus := types.NewEventBus()\n\t\teventBus.SetLogger(log.TestingLogger().With(\"module\", \"events\"))\n\t\terr = eventBus.Start()\n\t\trequire.NoError(t, err)\n\t\tcs.SetEventBus(eventBus)\n\n\t\tcs.SetTimeoutTicker(tickerFunc())\n\t\tcs.SetLogger(logger)\n\n\t\tcss[i] = cs\n\t}\n\n\t// initialize the reactors for each of the validators\n\treactors := make([]*Reactor, nValidators)\n\tblocksSubs := make([]types.Subscription, 0)\n\teventBuses := make([]*types.EventBus, nValidators)\n\tfor i := 0; i < nValidators; i++ {\n\t\treactors[i] = NewReactor(css[i], true) // so we dont start the consensus states\n\t\treactors[i].SetLogger(css[i].Logger)\n\n\t\t// eventBus is already started with the cs\n\t\teventBuses[i] = css[i].eventBus\n\t\treactors[i].SetEventBus(eventBuses[i])\n\n\t\tblocksSub, err := eventBuses[i].Subscribe(context.Background(), testSubscriber, types.EventQueryNewBlock, 100)\n\t\trequire.NoError(t, err)\n\t\tblocksSubs = append(blocksSubs, blocksSub)\n\n\t\tif css[i].state.LastBlockHeight == 0 { // simulate handle initChain in handshake\n\t\t\terr = css[i].blockExec.Store().Save(css[i].state)\n\t\t\trequire.NoError(t, err)\n\t\t}\n\t}\n\t// make connected switches and start all reactors\n\tp2p.MakeConnectedSwitches(config.P2P, nValidators, func(i int, s *p2p.Switch) *p2p.Switch {\n\t\ts.AddReactor(\"CONSENSUS\", reactors[i])\n\t\ts.SetLogger(reactors[i].conS.Logger.With(\"module\", \"p2p\"))\n\t\treturn s\n\t}, p2p.Connect2Switches)\n\n\t// create byzantine validator\n\tbcs := css[byzantineNode]\n\n\t// alter prevote so that the byzantine node double votes when height is 2\n\tbcs.doPrevote = func(height int64, round int32) {\n\t\t// allow first height to happen normally so that byzantine validator is no longer proposer\n\t\tif height == prevoteHeight {\n\t\t\tbcs.Logger.Info(\"Sending two votes\")\n\t\t\tprevote1, err := bcs.signVote(tmproto.PrevoteType, bcs.ProposalBlock.Hash(), bcs.ProposalBlockParts.Header())\n\t\t\trequire.NoError(t, err)\n\t\t\tprevote2, err := bcs.signVote(tmproto.PrevoteType, nil, types.PartSetHeader{})\n\t\t\trequire.NoError(t, err)\n\t\t\tpeerList := reactors[byzantineNode].Switch.Peers().List()\n\t\t\tbcs.Logger.Info(\"Getting peer list\", \"peers\", peerList)\n\t\t\t// send two votes to all peers (1st to one half, 2nd to another half)\n\t\t\tfor i, peer := range peerList {\n\t\t\t\tif i < len(peerList)/2 {\n\t\t\t\t\tbcs.Logger.Info(\"Signed and pushed vote\", \"vote\", prevote1, \"peer\", peer)\n\t\t\t\t\tpeer.Send(VoteChannel, MustEncode(&VoteMessage{prevote1}))\n\t\t\t\t} else {\n\t\t\t\t\tbcs.Logger.Info(\"Signed and pushed vote\", \"vote\", prevote2, \"peer\", peer)\n\t\t\t\t\tpeer.Send(VoteChannel, MustEncode(&VoteMessage{prevote2}))\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tbcs.Logger.Info(\"Behaving normally\")\n\t\t\tbcs.defaultDoPrevote(height, round)\n\t\t}\n\t}\n\n\t// introducing a lazy proposer means that the time of the block committed is different to the\n\t// timestamp that the other nodes have. This tests to ensure that the evidence that finally gets\n\t// proposed will have a valid timestamp\n\tlazyProposer := css[1]\n\n\tlazyProposer.decideProposal = func(height int64, round int32) {\n\t\tlazyProposer.Logger.Info(\"Lazy Proposer proposing condensed commit\")\n\t\tif lazyProposer.privValidator == nil {\n\t\t\tpanic(\"entered createProposalBlock with privValidator being nil\")\n\t\t}\n\n\t\tvar commit *types.Commit\n\t\tswitch {\n\t\tcase lazyProposer.Height == lazyProposer.state.InitialHeight:\n\t\t\t// We're creating a proposal for the first block.\n\t\t\t// The commit is empty, but not nil.\n\t\t\tcommit = types.NewCommit(0, 0, types.BlockID{}, nil)\n\t\tcase lazyProposer.LastCommit.HasTwoThirdsMajority():\n\t\t\t// Make the commit from LastCommit\n\t\t\tcommit = lazyProposer.LastCommit.MakeCommit()\n\t\tdefault: // This shouldn't happen.\n\t\t\tlazyProposer.Logger.Error(\"enterPropose: Cannot propose anything: No commit for the previous block\")\n\t\t\treturn\n\t\t}\n\n\t\t// omit the last signature in the commit\n\t\tcommit.Signatures[len(commit.Signatures)-1] = types.NewCommitSigAbsent()\n\n\t\tif lazyProposer.privValidatorPubKey == nil {\n\t\t\t// If this node is a validator & proposer in the current round, it will\n\t\t\t// miss the opportunity to create a block.\n\t\t\tlazyProposer.Logger.Error(fmt.Sprintf(\"enterPropose: %v\", errPubKeyIsNotSet))\n\t\t\treturn\n\t\t}\n\t\tproposerAddr := lazyProposer.privValidatorPubKey.Address()\n\n\t\tblock, blockParts := lazyProposer.blockExec.CreateProposalBlock(\n\t\t\tlazyProposer.Height, lazyProposer.state, commit, proposerAddr,\n\t\t)\n\n\t\t// Flush the WAL. Otherwise, we may not recompute the same proposal to sign,\n\t\t// and the privValidator will refuse to sign anything.\n\t\tif err := lazyProposer.wal.FlushAndSync(); err != nil {\n\t\t\tlazyProposer.Logger.Error(\"Error flushing to disk\")\n\t\t}\n\n\t\t// Make proposal\n\t\tpropBlockID := types.BlockID{Hash: block.Hash(), PartSetHeader: blockParts.Header()}\n\t\tproposal := types.NewProposal(height, round, lazyProposer.ValidRound, propBlockID)\n\t\tp := proposal.ToProto()\n\t\tif err := lazyProposer.privValidator.SignProposal(lazyProposer.state.ChainID, p); err == nil {\n\t\t\tproposal.Signature = p.Signature\n\n\t\t\t// send proposal and block parts on internal msg queue\n\t\t\tlazyProposer.sendInternalMessage(msgInfo{&ProposalMessage{proposal}, \"\"})\n\t\t\tfor i := 0; i < int(blockParts.Total()); i++ {\n\t\t\t\tpart := blockParts.GetPart(i)\n\t\t\t\tlazyProposer.sendInternalMessage(msgInfo{&BlockPartMessage{lazyProposer.Height, lazyProposer.Round, part}, \"\"})\n\t\t\t}\n\t\t\tlazyProposer.Logger.Info(\"Signed proposal\", \"height\", height, \"round\", round, \"proposal\", proposal)\n\t\t\tlazyProposer.Logger.Debug(fmt.Sprintf(\"Signed proposal block: %v\", block))\n\t\t} else if !lazyProposer.replayMode {\n\t\t\tlazyProposer.Logger.Error(\"enterPropose: Error signing proposal\", \"height\", height, \"round\", round, \"err\", err)\n\t\t}\n\t}\n\n\t// start the consensus reactors\n\tfor i := 0; i < nValidators; i++ {\n\t\ts := reactors[i].conS.GetState()\n\t\treactors[i].SwitchToConsensus(s, false)\n\t}\n\tdefer stopConsensusNet(log.TestingLogger(), reactors, eventBuses)\n\n\t// Evidence should be submitted and committed at the third height but\n\t// we will check the first six just in case\n\tevidenceFromEachValidator := make([]types.Evidence, nValidators)\n\n\twg := new(sync.WaitGroup)\n\tfor i := 0; i < nValidators; i++ {\n\t\twg.Add(1)\n\t\tgo func(i int) {\n\t\t\tdefer wg.Done()\n\t\t\tfor msg := range blocksSubs[i].Out() {\n\t\t\t\tblock := msg.Data().(types.EventDataNewBlock).Block\n\t\t\t\tif len(block.Evidence.Evidence) != 0 {\n\t\t\t\t\tevidenceFromEachValidator[i] = block.Evidence.Evidence[0]\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t}(i)\n\t}\n\n\tdone := make(chan struct{})\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(done)\n\t}()\n\n\tpubkey, err := bcs.privValidator.GetPubKey()\n\trequire.NoError(t, err)\n\n\tselect {\n\tcase <-done:\n\t\tfor idx, ev := range evidenceFromEachValidator {\n\t\t\tif assert.NotNil(t, ev, idx) {\n\t\t\t\tev, ok := ev.(*types.DuplicateVoteEvidence)\n\t\t\t\tassert.True(t, ok)\n\t\t\t\tassert.Equal(t, pubkey.Address(), ev.VoteA.ValidatorAddress)\n\t\t\t\tassert.Equal(t, prevoteHeight, ev.Height())\n\t\t\t}\n\t\t}\n\tcase <-time.After(20 * time.Second):\n\t\tfor i, reactor := range reactors {\n\t\t\tt.Logf(\"Consensus Reactor %d\\n%v\", i, reactor)\n\t\t}\n\t\tt.Fatalf(\"Timed out waiting for validators to commit evidence\")\n\t}\n}\n\n// 4 validators. 1 is byzantine. The other three are partitioned into A (1 val) and B (2 vals).\n// byzantine validator sends conflicting proposals into A and B,\n// and prevotes/precommits on both of them.\n// B sees a commit, A doesn't.\n// Heal partition and ensure A sees the commit\nfunc TestByzantineConflictingProposalsWithPartition(t *testing.T) {\n\tN := 4\n\tlogger := consensusLogger().With(\"test\", \"byzantine\")\n\tapp := newCounter\n\tcss, cleanup := randConsensusNet(N, \"consensus_byzantine_test\", newMockTickerFunc(false), app)\n\tdefer cleanup()\n\n\t// give the byzantine validator a normal ticker\n\tticker := NewTimeoutTicker()\n\tticker.SetLogger(css[0].Logger)\n\tcss[0].SetTimeoutTicker(ticker)\n\n\tswitches := make([]*p2p.Switch, N)\n\tp2pLogger := logger.With(\"module\", \"p2p\")\n\tfor i := 0; i < N; i++ {\n\t\tswitches[i] = p2p.MakeSwitch(\n\t\t\tconfig.P2P,\n\t\t\ti,\n\t\t\t\"foo\", \"1.0.0\",\n\t\t\tfunc(i int, sw *p2p.Switch) *p2p.Switch {\n\t\t\t\treturn sw\n\t\t\t})\n\t\tswitches[i].SetLogger(p2pLogger.With(\"validator\", i))\n\t}\n\n\tblocksSubs := make([]types.Subscription, N)\n\treactors := make([]p2p.Reactor, N)\n\tfor i := 0; i < N; i++ {\n\n\t\t// enable txs so we can create different proposals\n\t\tassertMempool(css[i].txNotifier).EnableTxsAvailable()\n\t\t// make first val byzantine\n\t\tif i == 0 {\n\t\t\t// NOTE: Now, test validators are MockPV, which by default doesn't\n\t\t\t// do any safety checks.\n\t\t\tcss[i].privValidator.(types.MockPV).DisableChecks()\n\t\t\tcss[i].decideProposal = func(j int32) func(int64, int32) {\n\t\t\t\treturn func(height int64, round int32) {\n\t\t\t\t\tbyzantineDecideProposalFunc(t, height, round, css[j], switches[j])\n\t\t\t\t}\n\t\t\t}(int32(i))\n\t\t\t// We are setting the prevote function to do nothing because the prevoting\n\t\t\t// and precommitting are done alongside the proposal.\n\t\t\tcss[i].doPrevote = func(height int64, round int32) {}\n\t\t}\n\n\t\teventBus := css[i].eventBus\n\t\teventBus.SetLogger(logger.With(\"module\", \"events\", \"validator\", i))\n\n\t\tvar err error\n\t\tblocksSubs[i], err = eventBus.Subscribe(context.Background(), testSubscriber, types.EventQueryNewBlock)\n\t\trequire.NoError(t, err)\n\n\t\tconR := NewReactor(css[i], true) // so we don't start the consensus states\n\t\tconR.SetLogger(logger.With(\"validator\", i))\n\t\tconR.SetEventBus(eventBus)\n\n\t\tvar conRI p2p.Reactor = conR\n\n\t\t// make first val byzantine\n\t\tif i == 0 {\n\t\t\tconRI = NewByzantineReactor(conR)\n\t\t}\n\n\t\treactors[i] = conRI\n\t\terr = css[i].blockExec.Store().Save(css[i].state) // for save height 1's validators info\n\t\trequire.NoError(t, err)\n\t}\n\n\tdefer func() {\n\t\tfor _, r := range reactors {\n\t\t\tif rr, ok := r.(*ByzantineReactor); ok {\n\t\t\t\terr := rr.reactor.Switch.Stop()\n\t\t\t\trequire.NoError(t, err)\n\t\t\t} else {\n\t\t\t\terr := r.(*Reactor).Switch.Stop()\n\t\t\t\trequire.NoError(t, err)\n\t\t\t}\n\t\t}\n\t}()\n\n\tp2p.MakeConnectedSwitches(config.P2P, N, func(i int, s *p2p.Switch) *p2p.Switch {\n\t\t// ignore new switch s, we already made ours\n\t\tswitches[i].AddReactor(\"CONSENSUS\", reactors[i])\n\t\treturn switches[i]\n\t}, func(sws []*p2p.Switch, i, j int) {\n\t\t// the network starts partitioned with globally active adversary\n\t\tif i != 0 {\n\t\t\treturn\n\t\t}\n\t\tp2p.Connect2Switches(sws, i, j)\n\t})\n\n\t// start the non-byz state machines.\n\t// note these must be started before the byz\n\tfor i := 1; i < N; i++ {\n\t\tcr := reactors[i].(*Reactor)\n\t\tcr.SwitchToConsensus(cr.conS.GetState(), false)\n\t}\n\n\t// start the byzantine state machine\n\tbyzR := reactors[0].(*ByzantineReactor)\n\ts := byzR.reactor.conS.GetState()\n\tbyzR.reactor.SwitchToConsensus(s, false)\n\n\t// byz proposer sends one block to peers[0]\n\t// and the other block to peers[1] and peers[2].\n\t// note peers and switches order don't match.\n\tpeers := switches[0].Peers().List()\n\n\t// partition A\n\tind0 := getSwitchIndex(switches, peers[0])\n\n\t// partition B\n\tind1 := getSwitchIndex(switches, peers[1])\n\tind2 := getSwitchIndex(switches, peers[2])\n\tp2p.Connect2Switches(switches, ind1, ind2)\n\n\t// wait for someone in the big partition (B) to make a block\n\t<-blocksSubs[ind2].Out()\n\n\tt.Log(\"A block has been committed. Healing partition\")\n\tp2p.Connect2Switches(switches, ind0, ind1)\n\tp2p.Connect2Switches(switches, ind0, ind2)\n\n\t// wait till everyone makes the first new block\n\t// (one of them already has)\n\twg := new(sync.WaitGroup)\n\tfor i := 1; i < N-1; i++ {\n\t\twg.Add(1)\n\t\tgo func(j int) {\n\t\t\t<-blocksSubs[j].Out()\n\t\t\twg.Done()\n\t\t}(i)\n\t}\n\n\tdone := make(chan struct{})\n\tgo func() {\n\t\twg.Wait()\n\t\tclose(done)\n\t}()\n\n\ttick := time.NewTicker(time.Second * 10)\n\tselect {\n\tcase <-done:\n\tcase <-tick.C:\n\t\tfor i, reactor := range reactors {\n\t\t\tt.Log(fmt.Sprintf(\"Consensus Reactor %v\", i))\n\t\t\tt.Log(fmt.Sprintf(\"%v\", reactor))\n\t\t}\n\t\tt.Fatalf(\"Timed out waiting for all validators to commit first block\")\n\t}\n}\n\n//-------------------------------\n// byzantine consensus functions\n\nfunc byzantineDecideProposalFunc(t *testing.T, height int64, round int32, cs *State, sw *p2p.Switch) {\n\t// byzantine user should create two proposals and try to split the vote.\n\t// Avoid sending on internalMsgQueue and running consensus state.\n\n\t// Create a new proposal block from state/txs from the mempool.\n\tblock1, blockParts1 := cs.createProposalBlock()\n\tpolRound, propBlockID := cs.ValidRound, types.BlockID{Hash: block1.Hash(), PartSetHeader: blockParts1.Header()}\n\tproposal1 := types.NewProposal(height, round, polRound, propBlockID)\n\tp1 := proposal1.ToProto()\n\tif err := cs.privValidator.SignProposal(cs.state.ChainID, p1); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tproposal1.Signature = p1.Signature\n\n\t// some new transactions come in (this ensures that the proposals are different)\n\tdeliverTxsRange(cs, 0, 1)\n\n\t// Create a new proposal block from state/txs from the mempool.\n\tblock2, blockParts2 := cs.createProposalBlock()\n\tpolRound, propBlockID = cs.ValidRound, types.BlockID{Hash: block2.Hash(), PartSetHeader: blockParts2.Header()}\n\tproposal2 := types.NewProposal(height, round, polRound, propBlockID)\n\tp2 := proposal2.ToProto()\n\tif err := cs.privValidator.SignProposal(cs.state.ChainID, p2); err != nil {\n\t\tt.Error(err)\n\t}\n\n\tproposal2.Signature = p2.Signature\n\n\tblock1Hash := block1.Hash()\n\tblock2Hash := block2.Hash()\n\n\t// broadcast conflicting proposals/block parts to peers\n\tpeers := sw.Peers().List()\n\tt.Logf(\"Byzantine: broadcasting conflicting proposals to %d peers\", len(peers))\n\tfor i, peer := range peers {\n\t\tif i < len(peers)/2 {\n\t\t\tgo sendProposalAndParts(height, round, cs, peer, proposal1, block1Hash, blockParts1)\n\t\t} else {\n\t\t\tgo sendProposalAndParts(height, round, cs, peer, proposal2, block2Hash, blockParts2)\n\t\t}\n\t}\n}\n\nfunc sendProposalAndParts(\n\theight int64,\n\tround int32,\n\tcs *State,\n\tpeer p2p.Peer,\n\tproposal *types.Proposal,\n\tblockHash []byte,\n\tparts *types.PartSet,\n) {\n\t// proposal\n\tmsg := &ProposalMessage{Proposal: proposal}\n\tpeer.Send(DataChannel, MustEncode(msg))\n\n\t// parts\n\tfor i := 0; i < int(parts.Total()); i++ {\n\t\tpart := parts.GetPart(i)\n\t\tmsg := &BlockPartMessage{\n\t\t\tHeight: height, // This tells peer that this part applies to us.\n\t\t\tRound:  round,  // This tells peer that this part applies to us.\n\t\t\tPart:   part,\n\t\t}\n\t\tpeer.Send(DataChannel, MustEncode(msg))\n\t}\n\n\t// votes\n\tcs.mtx.Lock()\n\tprevote, _ := cs.signVote(tmproto.PrevoteType, blockHash, parts.Header())\n\tprecommit, _ := cs.signVote(tmproto.PrecommitType, blockHash, parts.Header())\n\tcs.mtx.Unlock()\n\n\tpeer.Send(VoteChannel, MustEncode(&VoteMessage{prevote}))\n\tpeer.Send(VoteChannel, MustEncode(&VoteMessage{precommit}))\n}\n\n//----------------------------------------\n// byzantine consensus reactor\n\ntype ByzantineReactor struct {\n\tservice.Service\n\treactor *Reactor\n}\n\nfunc NewByzantineReactor(conR *Reactor) *ByzantineReactor {\n\treturn &ByzantineReactor{\n\t\tService: conR,\n\t\treactor: conR,\n\t}\n}\n\nfunc (br *ByzantineReactor) SetSwitch(s *p2p.Switch)               { br.reactor.SetSwitch(s) }\nfunc (br *ByzantineReactor) GetChannels() []*p2p.ChannelDescriptor { return br.reactor.GetChannels() }\nfunc (br *ByzantineReactor) AddPeer(peer p2p.Peer) {\n\tif !br.reactor.IsRunning() {\n\t\treturn\n\t}\n\n\t// Create peerState for peer\n\tpeerState := NewPeerState(peer).SetLogger(br.reactor.Logger)\n\tpeer.Set(types.PeerStateKey, peerState)\n\n\t// Send our state to peer.\n\t// If we're syncing, broadcast a RoundStepMessage later upon SwitchToConsensus().\n\tif !br.reactor.waitSync {\n\t\tbr.reactor.sendNewRoundStepMessage(peer)\n\t}\n}\nfunc (br *ByzantineReactor) RemovePeer(peer p2p.Peer, reason interface{}) {\n\tbr.reactor.RemovePeer(peer, reason)\n}\nfunc (br *ByzantineReactor) Receive(chID byte, peer p2p.Peer, msgBytes []byte) {\n\tbr.reactor.Receive(chID, peer, msgBytes)\n}\nfunc (br *ByzantineReactor) InitPeer(peer p2p.Peer) p2p.Peer { return peer }\n", "package consensus\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"reflect\"\n\t\"runtime/debug\"\n\t\"time\"\n\n\t\"github.com/gogo/protobuf/proto\"\n\n\tcfg \"github.com/tendermint/tendermint/config\"\n\tcstypes \"github.com/tendermint/tendermint/consensus/types\"\n\t\"github.com/tendermint/tendermint/crypto\"\n\ttmevents \"github.com/tendermint/tendermint/libs/events\"\n\t\"github.com/tendermint/tendermint/libs/fail\"\n\ttmjson \"github.com/tendermint/tendermint/libs/json\"\n\t\"github.com/tendermint/tendermint/libs/log\"\n\ttmmath \"github.com/tendermint/tendermint/libs/math\"\n\ttmos \"github.com/tendermint/tendermint/libs/os\"\n\t\"github.com/tendermint/tendermint/libs/service\"\n\ttmsync \"github.com/tendermint/tendermint/libs/sync\"\n\t\"github.com/tendermint/tendermint/p2p\"\n\ttmproto \"github.com/tendermint/tendermint/proto/tendermint/types\"\n\tsm \"github.com/tendermint/tendermint/state\"\n\t\"github.com/tendermint/tendermint/types\"\n\ttmtime \"github.com/tendermint/tendermint/types/time\"\n)\n\n//-----------------------------------------------------------------------------\n// Errors\n\nvar (\n\tErrInvalidProposalSignature   = errors.New(\"error invalid proposal signature\")\n\tErrInvalidProposalPOLRound    = errors.New(\"error invalid proposal POL round\")\n\tErrAddingVote                 = errors.New(\"error adding vote\")\n\tErrSignatureFoundInPastBlocks = errors.New(\"found signature from the same key\")\n\n\terrPubKeyIsNotSet = errors.New(\"pubkey is not set. Look for \\\"Can't get private validator pubkey\\\" errors\")\n)\n\n//-----------------------------------------------------------------------------\n\nvar (\n\tmsgQueueSize = 1000\n)\n\n// msgs from the reactor which may update the state\ntype msgInfo struct {\n\tMsg    Message `json:\"msg\"`\n\tPeerID p2p.ID  `json:\"peer_key\"`\n}\n\n// internally generated messages which may update the state\ntype timeoutInfo struct {\n\tDuration time.Duration         `json:\"duration\"`\n\tHeight   int64                 `json:\"height\"`\n\tRound    int32                 `json:\"round\"`\n\tStep     cstypes.RoundStepType `json:\"step\"`\n}\n\nfunc (ti *timeoutInfo) String() string {\n\treturn fmt.Sprintf(\"%v ; %d/%d %v\", ti.Duration, ti.Height, ti.Round, ti.Step)\n}\n\n// interface to the mempool\ntype txNotifier interface {\n\tTxsAvailable() <-chan struct{}\n}\n\n// interface to the evidence pool\ntype evidencePool interface {\n\t// reports conflicting votes to the evidence pool to be processed into evidence\n\tReportConflictingVotes(voteA, voteB *types.Vote)\n}\n\n// State handles execution of the consensus algorithm.\n// It processes votes and proposals, and upon reaching agreement,\n// commits blocks to the chain and executes them against the application.\n// The internal state machine receives input from peers, the internal validator, and from a timer.\ntype State struct {\n\tservice.BaseService\n\n\t// config details\n\tconfig        *cfg.ConsensusConfig\n\tprivValidator types.PrivValidator // for signing votes\n\n\t// store blocks and commits\n\tblockStore sm.BlockStore\n\n\t// create and execute blocks\n\tblockExec *sm.BlockExecutor\n\n\t// notify us if txs are available\n\ttxNotifier txNotifier\n\n\t// add evidence to the pool\n\t// when it's detected\n\tevpool evidencePool\n\n\t// internal state\n\tmtx tmsync.RWMutex\n\tcstypes.RoundState\n\tstate sm.State // State until height-1.\n\t// privValidator pubkey, memoized for the duration of one block\n\t// to avoid extra requests to HSM\n\tprivValidatorPubKey crypto.PubKey\n\n\t// state changes may be triggered by: msgs from peers,\n\t// msgs from ourself, or by timeouts\n\tpeerMsgQueue     chan msgInfo\n\tinternalMsgQueue chan msgInfo\n\ttimeoutTicker    TimeoutTicker\n\n\t// information about about added votes and block parts are written on this channel\n\t// so statistics can be computed by reactor\n\tstatsMsgQueue chan msgInfo\n\n\t// we use eventBus to trigger msg broadcasts in the reactor,\n\t// and to notify external subscribers, eg. through a websocket\n\teventBus *types.EventBus\n\n\t// a Write-Ahead Log ensures we can recover from any kind of crash\n\t// and helps us avoid signing conflicting votes\n\twal          WAL\n\treplayMode   bool // so we don't log signing errors during replay\n\tdoWALCatchup bool // determines if we even try to do the catchup\n\n\t// for tests where we want to limit the number of transitions the state makes\n\tnSteps int\n\n\t// some functions can be overwritten for testing\n\tdecideProposal func(height int64, round int32)\n\tdoPrevote      func(height int64, round int32)\n\tsetProposal    func(proposal *types.Proposal) error\n\n\t// closed when we finish shutting down\n\tdone chan struct{}\n\n\t// synchronous pubsub between consensus state and reactor.\n\t// state only emits EventNewRoundStep and EventVote\n\tevsw tmevents.EventSwitch\n\n\t// for reporting metrics\n\tmetrics *Metrics\n}\n\n// StateOption sets an optional parameter on the State.\ntype StateOption func(*State)\n\n// NewState returns a new State.\nfunc NewState(\n\tconfig *cfg.ConsensusConfig,\n\tstate sm.State,\n\tblockExec *sm.BlockExecutor,\n\tblockStore sm.BlockStore,\n\ttxNotifier txNotifier,\n\tevpool evidencePool,\n\toptions ...StateOption,\n) *State {\n\tcs := &State{\n\t\tconfig:           config,\n\t\tblockExec:        blockExec,\n\t\tblockStore:       blockStore,\n\t\ttxNotifier:       txNotifier,\n\t\tpeerMsgQueue:     make(chan msgInfo, msgQueueSize),\n\t\tinternalMsgQueue: make(chan msgInfo, msgQueueSize),\n\t\ttimeoutTicker:    NewTimeoutTicker(),\n\t\tstatsMsgQueue:    make(chan msgInfo, msgQueueSize),\n\t\tdone:             make(chan struct{}),\n\t\tdoWALCatchup:     true,\n\t\twal:              nilWAL{},\n\t\tevpool:           evpool,\n\t\tevsw:             tmevents.NewEventSwitch(),\n\t\tmetrics:          NopMetrics(),\n\t}\n\t// set function defaults (may be overwritten before calling Start)\n\tcs.decideProposal = cs.defaultDecideProposal\n\tcs.doPrevote = cs.defaultDoPrevote\n\tcs.setProposal = cs.defaultSetProposal\n\n\t// We have no votes, so reconstruct LastCommit from SeenCommit.\n\tif state.LastBlockHeight > 0 {\n\t\tcs.reconstructLastCommit(state)\n\t}\n\n\tcs.updateToState(state)\n\n\t// Don't call scheduleRound0 yet.\n\t// We do that upon Start().\n\n\tcs.BaseService = *service.NewBaseService(nil, \"State\", cs)\n\tfor _, option := range options {\n\t\toption(cs)\n\t}\n\treturn cs\n}\n\n//----------------------------------------\n// Public interface\n\n// SetLogger implements Service.\nfunc (cs *State) SetLogger(l log.Logger) {\n\tcs.BaseService.Logger = l\n\tcs.timeoutTicker.SetLogger(l)\n}\n\n// SetEventBus sets event bus.\nfunc (cs *State) SetEventBus(b *types.EventBus) {\n\tcs.eventBus = b\n\tcs.blockExec.SetEventBus(b)\n}\n\n// StateMetrics sets the metrics.\nfunc StateMetrics(metrics *Metrics) StateOption {\n\treturn func(cs *State) { cs.metrics = metrics }\n}\n\n// String returns a string.\nfunc (cs *State) String() string {\n\t// better not to access shared variables\n\treturn \"ConsensusState\"\n}\n\n// GetState returns a copy of the chain state.\nfunc (cs *State) GetState() sm.State {\n\tcs.mtx.RLock()\n\tdefer cs.mtx.RUnlock()\n\treturn cs.state.Copy()\n}\n\n// GetLastHeight returns the last height committed.\n// If there were no blocks, returns 0.\nfunc (cs *State) GetLastHeight() int64 {\n\tcs.mtx.RLock()\n\tdefer cs.mtx.RUnlock()\n\treturn cs.RoundState.Height - 1\n}\n\n// GetRoundState returns a shallow copy of the internal consensus state.\nfunc (cs *State) GetRoundState() *cstypes.RoundState {\n\tcs.mtx.RLock()\n\trs := cs.RoundState // copy\n\tcs.mtx.RUnlock()\n\treturn &rs\n}\n\n// GetRoundStateJSON returns a json of RoundState.\nfunc (cs *State) GetRoundStateJSON() ([]byte, error) {\n\tcs.mtx.RLock()\n\tdefer cs.mtx.RUnlock()\n\treturn tmjson.Marshal(cs.RoundState)\n}\n\n// GetRoundStateSimpleJSON returns a json of RoundStateSimple\nfunc (cs *State) GetRoundStateSimpleJSON() ([]byte, error) {\n\tcs.mtx.RLock()\n\tdefer cs.mtx.RUnlock()\n\treturn tmjson.Marshal(cs.RoundState.RoundStateSimple())\n}\n\n// GetValidators returns a copy of the current validators.\nfunc (cs *State) GetValidators() (int64, []*types.Validator) {\n\tcs.mtx.RLock()\n\tdefer cs.mtx.RUnlock()\n\treturn cs.state.LastBlockHeight, cs.state.Validators.Copy().Validators\n}\n\n// SetPrivValidator sets the private validator account for signing votes. It\n// immediately requests pubkey and caches it.\nfunc (cs *State) SetPrivValidator(priv types.PrivValidator) {\n\tcs.mtx.Lock()\n\tdefer cs.mtx.Unlock()\n\n\tcs.privValidator = priv\n\n\tif err := cs.updatePrivValidatorPubKey(); err != nil {\n\t\tcs.Logger.Error(\"Can't get private validator pubkey\", \"err\", err)\n\t}\n}\n\n// SetTimeoutTicker sets the local timer. It may be useful to overwrite for testing.\nfunc (cs *State) SetTimeoutTicker(timeoutTicker TimeoutTicker) {\n\tcs.mtx.Lock()\n\tcs.timeoutTicker = timeoutTicker\n\tcs.mtx.Unlock()\n}\n\n// LoadCommit loads the commit for a given height.\nfunc (cs *State) LoadCommit(height int64) *types.Commit {\n\tcs.mtx.RLock()\n\tdefer cs.mtx.RUnlock()\n\tif height == cs.blockStore.Height() {\n\t\treturn cs.blockStore.LoadSeenCommit(height)\n\t}\n\treturn cs.blockStore.LoadBlockCommit(height)\n}\n\n// OnStart loads the latest state via the WAL, and starts the timeout and\n// receive routines.\nfunc (cs *State) OnStart() error {\n\t// We may set the WAL in testing before calling Start, so only OpenWAL if its\n\t// still the nilWAL.\n\tif _, ok := cs.wal.(nilWAL); ok {\n\t\tif err := cs.loadWalFile(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// We may have lost some votes if the process crashed reload from consensus\n\t// log to catchup.\n\tif cs.doWALCatchup {\n\t\trepairAttempted := false\n\tLOOP:\n\t\tfor {\n\t\t\terr := cs.catchupReplay(cs.Height)\n\t\t\tswitch {\n\t\t\tcase err == nil:\n\t\t\t\tbreak LOOP\n\t\t\tcase !IsDataCorruptionError(err):\n\t\t\t\tcs.Logger.Error(\"Error on catchup replay. Proceeding to start State anyway\", \"err\", err)\n\t\t\t\tbreak LOOP\n\t\t\tcase repairAttempted:\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tcs.Logger.Error(\"WAL file is corrupted, attempting repair\", \"err\", err)\n\n\t\t\t// 1) prep work\n\t\t\tif err := cs.wal.Stop(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\trepairAttempted = true\n\n\t\t\t// 2) backup original WAL file\n\t\t\tcorruptedFile := fmt.Sprintf(\"%s.CORRUPTED\", cs.config.WalFile())\n\t\t\tif err := tmos.CopyFile(cs.config.WalFile(), corruptedFile); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcs.Logger.Info(\"Backed up WAL file\", \"src\", cs.config.WalFile(), \"dst\", corruptedFile)\n\n\t\t\t// 3) try to repair (WAL file will be overwritten!)\n\t\t\tif err := repairWalFile(corruptedFile, cs.config.WalFile()); err != nil {\n\t\t\t\tcs.Logger.Error(\"WAL repair failed\", \"err\", err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcs.Logger.Info(\"Successful repair\")\n\n\t\t\t// reload WAL file\n\t\t\tif err := cs.loadWalFile(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif err := cs.evsw.Start(); err != nil {\n\t\treturn err\n\t}\n\n\t// we need the timeoutRoutine for replay so\n\t// we don't block on the tick chan.\n\t// NOTE: we will get a build up of garbage go routines\n\t// firing on the tockChan until the receiveRoutine is started\n\t// to deal with them (by that point, at most one will be valid)\n\tif err := cs.timeoutTicker.Start(); err != nil {\n\t\treturn err\n\t}\n\n\t// Double Signing Risk Reduction\n\tif err := cs.checkDoubleSigningRisk(cs.Height); err != nil {\n\t\treturn err\n\t}\n\n\t// now start the receiveRoutine\n\tgo cs.receiveRoutine(0)\n\n\t// schedule the first round!\n\t// use GetRoundState so we don't race the receiveRoutine for access\n\tcs.scheduleRound0(cs.GetRoundState())\n\n\treturn nil\n}\n\n// timeoutRoutine: receive requests for timeouts on tickChan and fire timeouts on tockChan\n// receiveRoutine: serializes processing of proposoals, block parts, votes; coordinates state transitions\nfunc (cs *State) startRoutines(maxSteps int) {\n\terr := cs.timeoutTicker.Start()\n\tif err != nil {\n\t\tcs.Logger.Error(\"Error starting timeout ticker\", \"err\", err)\n\t\treturn\n\t}\n\tgo cs.receiveRoutine(maxSteps)\n}\n\n// loadWalFile loads WAL data from file. It overwrites cs.wal.\nfunc (cs *State) loadWalFile() error {\n\twal, err := cs.OpenWAL(cs.config.WalFile())\n\tif err != nil {\n\t\tcs.Logger.Error(\"Error loading State wal\", \"err\", err)\n\t\treturn err\n\t}\n\tcs.wal = wal\n\treturn nil\n}\n\n// OnStop implements service.Service.\nfunc (cs *State) OnStop() {\n\tif err := cs.evsw.Stop(); err != nil {\n\t\tcs.Logger.Error(\"error trying to stop eventSwitch\", \"error\", err)\n\t}\n\tif err := cs.timeoutTicker.Stop(); err != nil {\n\t\tcs.Logger.Error(\"error trying to stop timeoutTicket\", \"error\", err)\n\t}\n\t// WAL is stopped in receiveRoutine.\n}\n\n// Wait waits for the the main routine to return.\n// NOTE: be sure to Stop() the event switch and drain\n// any event channels or this may deadlock\nfunc (cs *State) Wait() {\n\t<-cs.done\n}\n\n// OpenWAL opens a file to log all consensus messages and timeouts for\n// deterministic accountability.\nfunc (cs *State) OpenWAL(walFile string) (WAL, error) {\n\twal, err := NewWAL(walFile)\n\tif err != nil {\n\t\tcs.Logger.Error(\"Failed to open WAL\", \"file\", walFile, \"err\", err)\n\t\treturn nil, err\n\t}\n\twal.SetLogger(cs.Logger.With(\"wal\", walFile))\n\tif err := wal.Start(); err != nil {\n\t\tcs.Logger.Error(\"Failed to start WAL\", \"err\", err)\n\t\treturn nil, err\n\t}\n\treturn wal, nil\n}\n\n//------------------------------------------------------------\n// Public interface for passing messages into the consensus state, possibly causing a state transition.\n// If peerID == \"\", the msg is considered internal.\n// Messages are added to the appropriate queue (peer or internal).\n// If the queue is full, the function may block.\n// TODO: should these return anything or let callers just use events?\n\n// AddVote inputs a vote.\nfunc (cs *State) AddVote(vote *types.Vote, peerID p2p.ID) (added bool, err error) {\n\tif peerID == \"\" {\n\t\tcs.internalMsgQueue <- msgInfo{&VoteMessage{vote}, \"\"}\n\t} else {\n\t\tcs.peerMsgQueue <- msgInfo{&VoteMessage{vote}, peerID}\n\t}\n\n\t// TODO: wait for event?!\n\treturn false, nil\n}\n\n// SetProposal inputs a proposal.\nfunc (cs *State) SetProposal(proposal *types.Proposal, peerID p2p.ID) error {\n\n\tif peerID == \"\" {\n\t\tcs.internalMsgQueue <- msgInfo{&ProposalMessage{proposal}, \"\"}\n\t} else {\n\t\tcs.peerMsgQueue <- msgInfo{&ProposalMessage{proposal}, peerID}\n\t}\n\n\t// TODO: wait for event?!\n\treturn nil\n}\n\n// AddProposalBlockPart inputs a part of the proposal block.\nfunc (cs *State) AddProposalBlockPart(height int64, round int32, part *types.Part, peerID p2p.ID) error {\n\n\tif peerID == \"\" {\n\t\tcs.internalMsgQueue <- msgInfo{&BlockPartMessage{height, round, part}, \"\"}\n\t} else {\n\t\tcs.peerMsgQueue <- msgInfo{&BlockPartMessage{height, round, part}, peerID}\n\t}\n\n\t// TODO: wait for event?!\n\treturn nil\n}\n\n// SetProposalAndBlock inputs the proposal and all block parts.\nfunc (cs *State) SetProposalAndBlock(\n\tproposal *types.Proposal,\n\tblock *types.Block,\n\tparts *types.PartSet,\n\tpeerID p2p.ID,\n) error {\n\tif err := cs.SetProposal(proposal, peerID); err != nil {\n\t\treturn err\n\t}\n\tfor i := 0; i < int(parts.Total()); i++ {\n\t\tpart := parts.GetPart(i)\n\t\tif err := cs.AddProposalBlockPart(proposal.Height, proposal.Round, part, peerID); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n//------------------------------------------------------------\n// internal functions for managing the state\n\nfunc (cs *State) updateHeight(height int64) {\n\tcs.metrics.Height.Set(float64(height))\n\tcs.Height = height\n}\n\nfunc (cs *State) updateRoundStep(round int32, step cstypes.RoundStepType) {\n\tcs.Round = round\n\tcs.Step = step\n}\n\n// enterNewRound(height, 0) at cs.StartTime.\nfunc (cs *State) scheduleRound0(rs *cstypes.RoundState) {\n\t// cs.Logger.Info(\"scheduleRound0\", \"now\", tmtime.Now(), \"startTime\", cs.StartTime)\n\tsleepDuration := rs.StartTime.Sub(tmtime.Now())\n\tcs.scheduleTimeout(sleepDuration, rs.Height, 0, cstypes.RoundStepNewHeight)\n}\n\n// Attempt to schedule a timeout (by sending timeoutInfo on the tickChan)\nfunc (cs *State) scheduleTimeout(duration time.Duration, height int64, round int32, step cstypes.RoundStepType) {\n\tcs.timeoutTicker.ScheduleTimeout(timeoutInfo{duration, height, round, step})\n}\n\n// send a msg into the receiveRoutine regarding our own proposal, block part, or vote\nfunc (cs *State) sendInternalMessage(mi msgInfo) {\n\tselect {\n\tcase cs.internalMsgQueue <- mi:\n\tdefault:\n\t\t// NOTE: using the go-routine means our votes can\n\t\t// be processed out of order.\n\t\t// TODO: use CList here for strict determinism and\n\t\t// attempt push to internalMsgQueue in receiveRoutine\n\t\tcs.Logger.Info(\"Internal msg queue is full. Using a go-routine\")\n\t\tgo func() { cs.internalMsgQueue <- mi }()\n\t}\n}\n\n// Reconstruct LastCommit from SeenCommit, which we saved along with the block,\n// (which happens even before saving the state)\nfunc (cs *State) reconstructLastCommit(state sm.State) {\n\tseenCommit := cs.blockStore.LoadSeenCommit(state.LastBlockHeight)\n\tif seenCommit == nil {\n\t\tpanic(fmt.Sprintf(\"Failed to reconstruct LastCommit: seen commit for height %v not found\",\n\t\t\tstate.LastBlockHeight))\n\t}\n\n\tlastPrecommits := types.CommitToVoteSet(state.ChainID, seenCommit, state.LastValidators)\n\tif !lastPrecommits.HasTwoThirdsMajority() {\n\t\tpanic(\"Failed to reconstruct LastCommit: Does not have +2/3 maj\")\n\t}\n\n\tcs.LastCommit = lastPrecommits\n}\n\n// Updates State and increments height to match that of state.\n// The round becomes 0 and cs.Step becomes cstypes.RoundStepNewHeight.\nfunc (cs *State) updateToState(state sm.State) {\n\tif cs.CommitRound > -1 && 0 < cs.Height && cs.Height != state.LastBlockHeight {\n\t\tpanic(fmt.Sprintf(\"updateToState() expected state height of %v but found %v\",\n\t\t\tcs.Height, state.LastBlockHeight))\n\t}\n\tif !cs.state.IsEmpty() {\n\t\tif cs.state.LastBlockHeight > 0 && cs.state.LastBlockHeight+1 != cs.Height {\n\t\t\t// This might happen when someone else is mutating cs.state.\n\t\t\t// Someone forgot to pass in state.Copy() somewhere?!\n\t\t\tpanic(fmt.Sprintf(\"Inconsistent cs.state.LastBlockHeight+1 %v vs cs.Height %v\",\n\t\t\t\tcs.state.LastBlockHeight+1, cs.Height))\n\t\t}\n\t\tif cs.state.LastBlockHeight > 0 && cs.Height == cs.state.InitialHeight {\n\t\t\tpanic(fmt.Sprintf(\"Inconsistent cs.state.LastBlockHeight %v, expected 0 for initial height %v\",\n\t\t\t\tcs.state.LastBlockHeight, cs.state.InitialHeight))\n\t\t}\n\n\t\t// If state isn't further out than cs.state, just ignore.\n\t\t// This happens when SwitchToConsensus() is called in the reactor.\n\t\t// We don't want to reset e.g. the Votes, but we still want to\n\t\t// signal the new round step, because other services (eg. txNotifier)\n\t\t// depend on having an up-to-date peer state!\n\t\tif state.LastBlockHeight <= cs.state.LastBlockHeight {\n\t\t\tcs.Logger.Info(\n\t\t\t\t\"Ignoring updateToState()\",\n\t\t\t\t\"newHeight\",\n\t\t\t\tstate.LastBlockHeight+1,\n\t\t\t\t\"oldHeight\",\n\t\t\t\tcs.state.LastBlockHeight+1)\n\t\t\tcs.newStep()\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Reset fields based on state.\n\tvalidators := state.Validators\n\n\tswitch {\n\tcase state.LastBlockHeight == 0: // Very first commit should be empty.\n\t\tcs.LastCommit = (*types.VoteSet)(nil)\n\tcase cs.CommitRound > -1 && cs.Votes != nil: // Otherwise, use cs.Votes\n\t\tif !cs.Votes.Precommits(cs.CommitRound).HasTwoThirdsMajority() {\n\t\t\tpanic(fmt.Sprintf(\"Wanted to form a Commit, but Precommits (H/R: %d/%d) didn't have 2/3+: %v\",\n\t\t\t\tstate.LastBlockHeight,\n\t\t\t\tcs.CommitRound,\n\t\t\t\tcs.Votes.Precommits(cs.CommitRound)))\n\t\t}\n\t\tcs.LastCommit = cs.Votes.Precommits(cs.CommitRound)\n\tcase cs.LastCommit == nil:\n\t\t// NOTE: when Tendermint starts, it has no votes. reconstructLastCommit\n\t\t// must be called to reconstruct LastCommit from SeenCommit.\n\t\tpanic(fmt.Sprintf(\"LastCommit cannot be empty after initial block (H:%d)\",\n\t\t\tstate.LastBlockHeight+1,\n\t\t))\n\t}\n\n\t// Next desired block height\n\theight := state.LastBlockHeight + 1\n\tif height == 1 {\n\t\theight = state.InitialHeight\n\t}\n\n\t// RoundState fields\n\tcs.updateHeight(height)\n\tcs.updateRoundStep(0, cstypes.RoundStepNewHeight)\n\tif cs.CommitTime.IsZero() {\n\t\t// \"Now\" makes it easier to sync up dev nodes.\n\t\t// We add timeoutCommit to allow transactions\n\t\t// to be gathered for the first block.\n\t\t// And alternative solution that relies on clocks:\n\t\t// cs.StartTime = state.LastBlockTime.Add(timeoutCommit)\n\t\tcs.StartTime = cs.config.Commit(tmtime.Now())\n\t} else {\n\t\tcs.StartTime = cs.config.Commit(cs.CommitTime)\n\t}\n\n\tcs.Validators = validators\n\tcs.Proposal = nil\n\tcs.ProposalBlock = nil\n\tcs.ProposalBlockParts = nil\n\tcs.LockedRound = -1\n\tcs.LockedBlock = nil\n\tcs.LockedBlockParts = nil\n\tcs.ValidRound = -1\n\tcs.ValidBlock = nil\n\tcs.ValidBlockParts = nil\n\tcs.Votes = cstypes.NewHeightVoteSet(state.ChainID, height, validators)\n\tcs.CommitRound = -1\n\tcs.LastValidators = state.LastValidators\n\tcs.TriggeredTimeoutPrecommit = false\n\n\tcs.state = state\n\n\t// Finally, broadcast RoundState\n\tcs.newStep()\n}\n\nfunc (cs *State) newStep() {\n\trs := cs.RoundStateEvent()\n\tif err := cs.wal.Write(rs); err != nil {\n\t\tcs.Logger.Error(\"Error writing to wal\", \"err\", err)\n\t}\n\tcs.nSteps++\n\t// newStep is called by updateToState in NewState before the eventBus is set!\n\tif cs.eventBus != nil {\n\t\tif err := cs.eventBus.PublishEventNewRoundStep(rs); err != nil {\n\t\t\tcs.Logger.Error(\"Error publishing new round step\", \"err\", err)\n\t\t}\n\t\tcs.evsw.FireEvent(types.EventNewRoundStep, &cs.RoundState)\n\t}\n}\n\n//-----------------------------------------\n// the main go routines\n\n// receiveRoutine handles messages which may cause state transitions.\n// it's argument (n) is the number of messages to process before exiting - use 0 to run forever\n// It keeps the RoundState and is the only thing that updates it.\n// Updates (state transitions) happen on timeouts, complete proposals, and 2/3 majorities.\n// State must be locked before any internal state is updated.\nfunc (cs *State) receiveRoutine(maxSteps int) {\n\tonExit := func(cs *State) {\n\t\t// NOTE: the internalMsgQueue may have signed messages from our\n\t\t// priv_val that haven't hit the WAL, but its ok because\n\t\t// priv_val tracks LastSig\n\n\t\t// close wal now that we're done writing to it\n\t\tif err := cs.wal.Stop(); err != nil {\n\t\t\tcs.Logger.Error(\"error trying to stop wal\", \"error\", err)\n\t\t}\n\t\tcs.wal.Wait()\n\n\t\tclose(cs.done)\n\t}\n\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tcs.Logger.Error(\"CONSENSUS FAILURE!!!\", \"err\", r, \"stack\", string(debug.Stack()))\n\t\t\t// stop gracefully\n\t\t\t//\n\t\t\t// NOTE: We most probably shouldn't be running any further when there is\n\t\t\t// some unexpected panic. Some unknown error happened, and so we don't\n\t\t\t// know if that will result in the validator signing an invalid thing. It\n\t\t\t// might be worthwhile to explore a mechanism for manual resuming via\n\t\t\t// some console or secure RPC system, but for now, halting the chain upon\n\t\t\t// unexpected consensus bugs sounds like the better option.\n\t\t\tonExit(cs)\n\t\t}\n\t}()\n\n\tfor {\n\t\tif maxSteps > 0 {\n\t\t\tif cs.nSteps >= maxSteps {\n\t\t\t\tcs.Logger.Info(\"reached max steps. exiting receive routine\")\n\t\t\t\tcs.nSteps = 0\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\trs := cs.RoundState\n\t\tvar mi msgInfo\n\n\t\tselect {\n\t\tcase <-cs.txNotifier.TxsAvailable():\n\t\t\tcs.handleTxsAvailable()\n\t\tcase mi = <-cs.peerMsgQueue:\n\t\t\tif err := cs.wal.Write(mi); err != nil {\n\t\t\t\tcs.Logger.Error(\"Error writing to wal\", \"err\", err)\n\t\t\t}\n\t\t\t// handles proposals, block parts, votes\n\t\t\t// may generate internal events (votes, complete proposals, 2/3 majorities)\n\t\t\tcs.handleMsg(mi)\n\t\tcase mi = <-cs.internalMsgQueue:\n\t\t\terr := cs.wal.WriteSync(mi) // NOTE: fsync\n\t\t\tif err != nil {\n\t\t\t\tpanic(fmt.Sprintf(\"Failed to write %v msg to consensus wal due to %v. Check your FS and restart the node\", mi, err))\n\t\t\t}\n\n\t\t\tif _, ok := mi.Msg.(*VoteMessage); ok {\n\t\t\t\t// we actually want to simulate failing during\n\t\t\t\t// the previous WriteSync, but this isn't easy to do.\n\t\t\t\t// Equivalent would be to fail here and manually remove\n\t\t\t\t// some bytes from the end of the wal.\n\t\t\t\tfail.Fail() // XXX\n\t\t\t}\n\n\t\t\t// handles proposals, block parts, votes\n\t\t\tcs.handleMsg(mi)\n\t\tcase ti := <-cs.timeoutTicker.Chan(): // tockChan:\n\t\t\tif err := cs.wal.Write(ti); err != nil {\n\t\t\t\tcs.Logger.Error(\"Error writing to wal\", \"err\", err)\n\t\t\t}\n\t\t\t// if the timeout is relevant to the rs\n\t\t\t// go to the next step\n\t\t\tcs.handleTimeout(ti, rs)\n\t\tcase <-cs.Quit():\n\t\t\tonExit(cs)\n\t\t\treturn\n\t\t}\n\t}\n}\n\n// state transitions on complete-proposal, 2/3-any, 2/3-one\nfunc (cs *State) handleMsg(mi msgInfo) {\n\tcs.mtx.Lock()\n\tdefer cs.mtx.Unlock()\n\n\tvar (\n\t\tadded bool\n\t\terr   error\n\t)\n\tmsg, peerID := mi.Msg, mi.PeerID\n\tswitch msg := msg.(type) {\n\tcase *ProposalMessage:\n\t\t// will not cause transition.\n\t\t// once proposal is set, we can receive block parts\n\t\terr = cs.setProposal(msg.Proposal)\n\tcase *BlockPartMessage:\n\t\t// if the proposal is complete, we'll enterPrevote or tryFinalizeCommit\n\t\tadded, err = cs.addProposalBlockPart(msg, peerID)\n\t\tif added {\n\t\t\tcs.statsMsgQueue <- mi\n\t\t}\n\n\t\tif err != nil && msg.Round != cs.Round {\n\t\t\tcs.Logger.Debug(\n\t\t\t\t\"Received block part from wrong round\",\n\t\t\t\t\"height\",\n\t\t\t\tcs.Height,\n\t\t\t\t\"csRound\",\n\t\t\t\tcs.Round,\n\t\t\t\t\"blockRound\",\n\t\t\t\tmsg.Round)\n\t\t\terr = nil\n\t\t}\n\tcase *VoteMessage:\n\t\t// attempt to add the vote and dupeout the validator if its a duplicate signature\n\t\t// if the vote gives us a 2/3-any or 2/3-one, we transition\n\t\tadded, err = cs.tryAddVote(msg.Vote, peerID)\n\t\tif added {\n\t\t\tcs.statsMsgQueue <- mi\n\t\t}\n\n\t\t// if err == ErrAddingVote {\n\t\t// TODO: punish peer\n\t\t// We probably don't want to stop the peer here. The vote does not\n\t\t// necessarily comes from a malicious peer but can be just broadcasted by\n\t\t// a typical peer.\n\t\t// https://github.com/tendermint/tendermint/issues/1281\n\t\t// }\n\n\t\t// NOTE: the vote is broadcast to peers by the reactor listening\n\t\t// for vote events\n\n\t\t// TODO: If rs.Height == vote.Height && rs.Round < vote.Round,\n\t\t// the peer is sending us CatchupCommit precommits.\n\t\t// We could make note of this and help filter in broadcastHasVoteMessage().\n\tdefault:\n\t\tcs.Logger.Error(\"Unknown msg type\", \"type\", reflect.TypeOf(msg))\n\t\treturn\n\t}\n\n\tif err != nil {\n\t\tcs.Logger.Error(\"Error with msg\", \"height\", cs.Height, \"round\", cs.Round,\n\t\t\t\"peer\", peerID, \"err\", err, \"msg\", msg)\n\t}\n}\n\nfunc (cs *State) handleTimeout(ti timeoutInfo, rs cstypes.RoundState) {\n\tcs.Logger.Debug(\"Received tock\", \"timeout\", ti.Duration, \"height\", ti.Height, \"round\", ti.Round, \"step\", ti.Step)\n\n\t// timeouts must be for current height, round, step\n\tif ti.Height != rs.Height || ti.Round < rs.Round || (ti.Round == rs.Round && ti.Step < rs.Step) {\n\t\tcs.Logger.Debug(\"Ignoring tock because we're ahead\", \"height\", rs.Height, \"round\", rs.Round, \"step\", rs.Step)\n\t\treturn\n\t}\n\n\t// the timeout will now cause a state transition\n\tcs.mtx.Lock()\n\tdefer cs.mtx.Unlock()\n\n\tswitch ti.Step {\n\tcase cstypes.RoundStepNewHeight:\n\t\t// NewRound event fired from enterNewRound.\n\t\t// XXX: should we fire timeout here (for timeout commit)?\n\t\tcs.enterNewRound(ti.Height, 0)\n\tcase cstypes.RoundStepNewRound:\n\t\tcs.enterPropose(ti.Height, 0)\n\tcase cstypes.RoundStepPropose:\n\t\tif err := cs.eventBus.PublishEventTimeoutPropose(cs.RoundStateEvent()); err != nil {\n\t\t\tcs.Logger.Error(\"Error publishing timeout propose\", \"err\", err)\n\t\t}\n\t\tcs.enterPrevote(ti.Height, ti.Round)\n\tcase cstypes.RoundStepPrevoteWait:\n\t\tif err := cs.eventBus.PublishEventTimeoutWait(cs.RoundStateEvent()); err != nil {\n\t\t\tcs.Logger.Error(\"Error publishing timeout wait\", \"err\", err)\n\t\t}\n\t\tcs.enterPrecommit(ti.Height, ti.Round)\n\tcase cstypes.RoundStepPrecommitWait:\n\t\tif err := cs.eventBus.PublishEventTimeoutWait(cs.RoundStateEvent()); err != nil {\n\t\t\tcs.Logger.Error(\"Error publishing timeout wait\", \"err\", err)\n\t\t}\n\t\tcs.enterPrecommit(ti.Height, ti.Round)\n\t\tcs.enterNewRound(ti.Height, ti.Round+1)\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"Invalid timeout step: %v\", ti.Step))\n\t}\n\n}\n\nfunc (cs *State) handleTxsAvailable() {\n\tcs.mtx.Lock()\n\tdefer cs.mtx.Unlock()\n\n\t// We only need to do this for round 0.\n\tif cs.Round != 0 {\n\t\treturn\n\t}\n\n\tswitch cs.Step {\n\tcase cstypes.RoundStepNewHeight: // timeoutCommit phase\n\t\tif cs.needProofBlock(cs.Height) {\n\t\t\t// enterPropose will be called by enterNewRound\n\t\t\treturn\n\t\t}\n\n\t\t// +1ms to ensure RoundStepNewRound timeout always happens after RoundStepNewHeight\n\t\ttimeoutCommit := cs.StartTime.Sub(tmtime.Now()) + 1*time.Millisecond\n\t\tcs.scheduleTimeout(timeoutCommit, cs.Height, 0, cstypes.RoundStepNewRound)\n\tcase cstypes.RoundStepNewRound: // after timeoutCommit\n\t\tcs.enterPropose(cs.Height, 0)\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// State functions\n// Used internally by handleTimeout and handleMsg to make state transitions\n\n// Enter: `timeoutNewHeight` by startTime (commitTime+timeoutCommit),\n// \tor, if SkipTimeoutCommit==true, after receiving all precommits from (height,round-1)\n// Enter: `timeoutPrecommits` after any +2/3 precommits from (height,round-1)\n// Enter: +2/3 precommits for nil at (height,round-1)\n// Enter: +2/3 prevotes any or +2/3 precommits for block or any from (height, round)\n// NOTE: cs.StartTime was already set for height.\nfunc (cs *State) enterNewRound(height int64, round int32) {\n\tlogger := cs.Logger.With(\"height\", height, \"round\", round)\n\n\tif cs.Height != height || round < cs.Round || (cs.Round == round && cs.Step != cstypes.RoundStepNewHeight) {\n\t\tlogger.Debug(fmt.Sprintf(\n\t\t\t\"enterNewRound(%v/%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tround,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\n\tif now := tmtime.Now(); cs.StartTime.After(now) {\n\t\tlogger.Info(\"Need to set a buffer and log message here for sanity.\", \"startTime\", cs.StartTime, \"now\", now)\n\t}\n\n\tlogger.Info(fmt.Sprintf(\"enterNewRound(%v/%v). Current: %v/%v/%v\", height, round, cs.Height, cs.Round, cs.Step))\n\n\t// Increment validators if necessary\n\tvalidators := cs.Validators\n\tif cs.Round < round {\n\t\tvalidators = validators.Copy()\n\t\tvalidators.IncrementProposerPriority(tmmath.SafeSubInt32(round, cs.Round))\n\t}\n\n\t// Setup new round\n\t// we don't fire newStep for this step,\n\t// but we fire an event, so update the round step first\n\tcs.updateRoundStep(round, cstypes.RoundStepNewRound)\n\tcs.Validators = validators\n\tif round == 0 {\n\t\t// We've already reset these upon new height,\n\t\t// and meanwhile we might have received a proposal\n\t\t// for round 0.\n\t} else {\n\t\tlogger.Info(\"Resetting Proposal info\")\n\t\tcs.Proposal = nil\n\t\tcs.ProposalBlock = nil\n\t\tcs.ProposalBlockParts = nil\n\t}\n\tcs.Votes.SetRound(tmmath.SafeAddInt32(round, 1)) // also track next round (round+1) to allow round-skipping\n\tcs.TriggeredTimeoutPrecommit = false\n\n\tif err := cs.eventBus.PublishEventNewRound(cs.NewRoundEvent()); err != nil {\n\t\tcs.Logger.Error(\"Error publishing new round\", \"err\", err)\n\t}\n\tcs.metrics.Rounds.Set(float64(round))\n\n\t// Wait for txs to be available in the mempool\n\t// before we enterPropose in round 0. If the last block changed the app hash,\n\t// we may need an empty \"proof\" block, and enterPropose immediately.\n\twaitForTxs := cs.config.WaitForTxs() && round == 0 && !cs.needProofBlock(height)\n\tif waitForTxs {\n\t\tif cs.config.CreateEmptyBlocksInterval > 0 {\n\t\t\tcs.scheduleTimeout(cs.config.CreateEmptyBlocksInterval, height, round,\n\t\t\t\tcstypes.RoundStepNewRound)\n\t\t}\n\t} else {\n\t\tcs.enterPropose(height, round)\n\t}\n}\n\n// needProofBlock returns true on the first height (so the genesis app hash is signed right away)\n// and where the last block (height-1) caused the app hash to change\nfunc (cs *State) needProofBlock(height int64) bool {\n\tif height == cs.state.InitialHeight {\n\t\treturn true\n\t}\n\n\tlastBlockMeta := cs.blockStore.LoadBlockMeta(height - 1)\n\tif lastBlockMeta == nil {\n\t\tpanic(fmt.Sprintf(\"needProofBlock: last block meta for height %d not found\", height-1))\n\t}\n\treturn !bytes.Equal(cs.state.AppHash, lastBlockMeta.Header.AppHash)\n}\n\n// Enter (CreateEmptyBlocks): from enterNewRound(height,round)\n// Enter (CreateEmptyBlocks, CreateEmptyBlocksInterval > 0 ):\n// \t\tafter enterNewRound(height,round), after timeout of CreateEmptyBlocksInterval\n// Enter (!CreateEmptyBlocks) : after enterNewRound(height,round), once txs are in the mempool\nfunc (cs *State) enterPropose(height int64, round int32) {\n\tlogger := cs.Logger.With(\"height\", height, \"round\", round)\n\n\tif cs.Height != height || round < cs.Round || (cs.Round == round && cstypes.RoundStepPropose <= cs.Step) {\n\t\tlogger.Debug(fmt.Sprintf(\n\t\t\t\"enterPropose(%v/%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tround,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\tlogger.Info(fmt.Sprintf(\"enterPropose(%v/%v). Current: %v/%v/%v\", height, round, cs.Height, cs.Round, cs.Step))\n\n\tdefer func() {\n\t\t// Done enterPropose:\n\t\tcs.updateRoundStep(round, cstypes.RoundStepPropose)\n\t\tcs.newStep()\n\n\t\t// If we have the whole proposal + POL, then goto Prevote now.\n\t\t// else, we'll enterPrevote when the rest of the proposal is received (in AddProposalBlockPart),\n\t\t// or else after timeoutPropose\n\t\tif cs.isProposalComplete() {\n\t\t\tcs.enterPrevote(height, cs.Round)\n\t\t}\n\t}()\n\n\t// If we don't get the proposal and all block parts quick enough, enterPrevote\n\tcs.scheduleTimeout(cs.config.Propose(round), height, round, cstypes.RoundStepPropose)\n\n\t// Nothing more to do if we're not a validator\n\tif cs.privValidator == nil {\n\t\tlogger.Debug(\"This node is not a validator\")\n\t\treturn\n\t}\n\tlogger.Debug(\"This node is a validator\")\n\n\tif cs.privValidatorPubKey == nil {\n\t\t// If this node is a validator & proposer in the current round, it will\n\t\t// miss the opportunity to create a block.\n\t\tlogger.Error(fmt.Sprintf(\"enterPropose: %v\", errPubKeyIsNotSet))\n\t\treturn\n\t}\n\taddress := cs.privValidatorPubKey.Address()\n\n\t// if not a validator, we're done\n\tif !cs.Validators.HasAddress(address) {\n\t\tlogger.Debug(\"This node is not a validator\", \"addr\", address, \"vals\", cs.Validators)\n\t\treturn\n\t}\n\n\tif cs.isProposer(address) {\n\t\tlogger.Info(\"enterPropose: Our turn to propose\",\n\t\t\t\"proposer\",\n\t\t\taddress,\n\t\t\t\"privValidator\",\n\t\t\tcs.privValidator)\n\t\tcs.decideProposal(height, round)\n\t} else {\n\t\tlogger.Info(\"enterPropose: Not our turn to propose\",\n\t\t\t\"proposer\",\n\t\t\tcs.Validators.GetProposer().Address,\n\t\t\t\"privValidator\",\n\t\t\tcs.privValidator)\n\t}\n}\n\nfunc (cs *State) isProposer(address []byte) bool {\n\treturn bytes.Equal(cs.Validators.GetProposer().Address, address)\n}\n\nfunc (cs *State) defaultDecideProposal(height int64, round int32) {\n\tvar block *types.Block\n\tvar blockParts *types.PartSet\n\n\t// Decide on block\n\tif cs.ValidBlock != nil {\n\t\t// If there is valid block, choose that.\n\t\tblock, blockParts = cs.ValidBlock, cs.ValidBlockParts\n\t} else {\n\t\t// Create a new proposal block from state/txs from the mempool.\n\t\tblock, blockParts = cs.createProposalBlock()\n\t\tif block == nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Flush the WAL. Otherwise, we may not recompute the same proposal to sign,\n\t// and the privValidator will refuse to sign anything.\n\tif err := cs.wal.FlushAndSync(); err != nil {\n\t\tcs.Logger.Error(\"Error flushing to disk\")\n\t}\n\n\t// Make proposal\n\tpropBlockID := types.BlockID{Hash: block.Hash(), PartSetHeader: blockParts.Header()}\n\tproposal := types.NewProposal(height, round, cs.ValidRound, propBlockID)\n\tp := proposal.ToProto()\n\tif err := cs.privValidator.SignProposal(cs.state.ChainID, p); err == nil {\n\t\tproposal.Signature = p.Signature\n\n\t\t// send proposal and block parts on internal msg queue\n\t\tcs.sendInternalMessage(msgInfo{&ProposalMessage{proposal}, \"\"})\n\t\tfor i := 0; i < int(blockParts.Total()); i++ {\n\t\t\tpart := blockParts.GetPart(i)\n\t\t\tcs.sendInternalMessage(msgInfo{&BlockPartMessage{cs.Height, cs.Round, part}, \"\"})\n\t\t}\n\t\tcs.Logger.Info(\"Signed proposal\", \"height\", height, \"round\", round, \"proposal\", proposal)\n\t\tcs.Logger.Debug(fmt.Sprintf(\"Signed proposal block: %v\", block))\n\t} else if !cs.replayMode {\n\t\tcs.Logger.Error(\"enterPropose: Error signing proposal\", \"height\", height, \"round\", round, \"err\", err)\n\t}\n}\n\n// Returns true if the proposal block is complete &&\n// (if POLRound was proposed, we have +2/3 prevotes from there).\nfunc (cs *State) isProposalComplete() bool {\n\tif cs.Proposal == nil || cs.ProposalBlock == nil {\n\t\treturn false\n\t}\n\t// we have the proposal. if there's a POLRound,\n\t// make sure we have the prevotes from it too\n\tif cs.Proposal.POLRound < 0 {\n\t\treturn true\n\t}\n\t// if this is false the proposer is lying or we haven't received the POL yet\n\treturn cs.Votes.Prevotes(cs.Proposal.POLRound).HasTwoThirdsMajority()\n\n}\n\n// Create the next block to propose and return it. Returns nil block upon error.\n//\n// We really only need to return the parts, but the block is returned for\n// convenience so we can log the proposal block.\n//\n// NOTE: keep it side-effect free for clarity.\n// CONTRACT: cs.privValidator is not nil.\nfunc (cs *State) createProposalBlock() (block *types.Block, blockParts *types.PartSet) {\n\tif cs.privValidator == nil {\n\t\tpanic(\"entered createProposalBlock with privValidator being nil\")\n\t}\n\n\tvar commit *types.Commit\n\tswitch {\n\tcase cs.Height == cs.state.InitialHeight:\n\t\t// We're creating a proposal for the first block.\n\t\t// The commit is empty, but not nil.\n\t\tcommit = types.NewCommit(0, 0, types.BlockID{}, nil)\n\tcase cs.LastCommit.HasTwoThirdsMajority():\n\t\t// Make the commit from LastCommit\n\t\tcommit = cs.LastCommit.MakeCommit()\n\tdefault: // This shouldn't happen.\n\t\tcs.Logger.Error(\"enterPropose: Cannot propose anything: No commit for the previous block\")\n\t\treturn\n\t}\n\n\tif cs.privValidatorPubKey == nil {\n\t\t// If this node is a validator & proposer in the current round, it will\n\t\t// miss the opportunity to create a block.\n\t\tcs.Logger.Error(fmt.Sprintf(\"enterPropose: %v\", errPubKeyIsNotSet))\n\t\treturn\n\t}\n\tproposerAddr := cs.privValidatorPubKey.Address()\n\n\treturn cs.blockExec.CreateProposalBlock(cs.Height, cs.state, commit, proposerAddr)\n}\n\n// Enter: `timeoutPropose` after entering Propose.\n// Enter: proposal block and POL is ready.\n// Prevote for LockedBlock if we're locked, or ProposalBlock if valid.\n// Otherwise vote nil.\nfunc (cs *State) enterPrevote(height int64, round int32) {\n\tif cs.Height != height || round < cs.Round || (cs.Round == round && cstypes.RoundStepPrevote <= cs.Step) {\n\t\tcs.Logger.Debug(fmt.Sprintf(\n\t\t\t\"enterPrevote(%v/%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tround,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\n\tdefer func() {\n\t\t// Done enterPrevote:\n\t\tcs.updateRoundStep(round, cstypes.RoundStepPrevote)\n\t\tcs.newStep()\n\t}()\n\n\tcs.Logger.Info(fmt.Sprintf(\"enterPrevote(%v/%v). Current: %v/%v/%v\", height, round, cs.Height, cs.Round, cs.Step))\n\n\t// Sign and broadcast vote as necessary\n\tcs.doPrevote(height, round)\n\n\t// Once `addVote` hits any +2/3 prevotes, we will go to PrevoteWait\n\t// (so we have more time to try and collect +2/3 prevotes for a single block)\n}\n\nfunc (cs *State) defaultDoPrevote(height int64, round int32) {\n\tlogger := cs.Logger.With(\"height\", height, \"round\", round)\n\n\t// If a block is locked, prevote that.\n\tif cs.LockedBlock != nil {\n\t\tlogger.Info(\"enterPrevote: Already locked on a block, prevoting locked block\")\n\t\tcs.signAddVote(tmproto.PrevoteType, cs.LockedBlock.Hash(), cs.LockedBlockParts.Header())\n\t\treturn\n\t}\n\n\t// If ProposalBlock is nil, prevote nil.\n\tif cs.ProposalBlock == nil {\n\t\tlogger.Info(\"enterPrevote: ProposalBlock is nil\")\n\t\tcs.signAddVote(tmproto.PrevoteType, nil, types.PartSetHeader{})\n\t\treturn\n\t}\n\n\t// Validate proposal block\n\terr := cs.blockExec.ValidateBlock(cs.state, cs.ProposalBlock)\n\tif err != nil {\n\t\t// ProposalBlock is invalid, prevote nil.\n\t\tlogger.Error(\"enterPrevote: ProposalBlock is invalid\", \"err\", err)\n\t\tcs.signAddVote(tmproto.PrevoteType, nil, types.PartSetHeader{})\n\t\treturn\n\t}\n\n\t// Prevote cs.ProposalBlock\n\t// NOTE: the proposal signature is validated when it is received,\n\t// and the proposal block parts are validated as they are received (against the merkle hash in the proposal)\n\tlogger.Info(\"enterPrevote: ProposalBlock is valid\")\n\tcs.signAddVote(tmproto.PrevoteType, cs.ProposalBlock.Hash(), cs.ProposalBlockParts.Header())\n}\n\n// Enter: any +2/3 prevotes at next round.\nfunc (cs *State) enterPrevoteWait(height int64, round int32) {\n\tlogger := cs.Logger.With(\"height\", height, \"round\", round)\n\n\tif cs.Height != height || round < cs.Round || (cs.Round == round && cstypes.RoundStepPrevoteWait <= cs.Step) {\n\t\tlogger.Debug(fmt.Sprintf(\n\t\t\t\"enterPrevoteWait(%v/%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tround,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\tif !cs.Votes.Prevotes(round).HasTwoThirdsAny() {\n\t\tpanic(fmt.Sprintf(\"enterPrevoteWait(%v/%v), but Prevotes does not have any +2/3 votes\", height, round))\n\t}\n\tlogger.Info(fmt.Sprintf(\"enterPrevoteWait(%v/%v). Current: %v/%v/%v\", height, round, cs.Height, cs.Round, cs.Step))\n\n\tdefer func() {\n\t\t// Done enterPrevoteWait:\n\t\tcs.updateRoundStep(round, cstypes.RoundStepPrevoteWait)\n\t\tcs.newStep()\n\t}()\n\n\t// Wait for some more prevotes; enterPrecommit\n\tcs.scheduleTimeout(cs.config.Prevote(round), height, round, cstypes.RoundStepPrevoteWait)\n}\n\n// Enter: `timeoutPrevote` after any +2/3 prevotes.\n// Enter: `timeoutPrecommit` after any +2/3 precommits.\n// Enter: +2/3 precomits for block or nil.\n// Lock & precommit the ProposalBlock if we have enough prevotes for it (a POL in this round)\n// else, unlock an existing lock and precommit nil if +2/3 of prevotes were nil,\n// else, precommit nil otherwise.\nfunc (cs *State) enterPrecommit(height int64, round int32) {\n\tlogger := cs.Logger.With(\"height\", height, \"round\", round)\n\n\tif cs.Height != height || round < cs.Round || (cs.Round == round && cstypes.RoundStepPrecommit <= cs.Step) {\n\t\tlogger.Debug(fmt.Sprintf(\n\t\t\t\"enterPrecommit(%v/%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tround,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\n\tlogger.Info(fmt.Sprintf(\"enterPrecommit(%v/%v). Current: %v/%v/%v\", height, round, cs.Height, cs.Round, cs.Step))\n\n\tdefer func() {\n\t\t// Done enterPrecommit:\n\t\tcs.updateRoundStep(round, cstypes.RoundStepPrecommit)\n\t\tcs.newStep()\n\t}()\n\n\t// check for a polka\n\tblockID, ok := cs.Votes.Prevotes(round).TwoThirdsMajority()\n\n\t// If we don't have a polka, we must precommit nil.\n\tif !ok {\n\t\tif cs.LockedBlock != nil {\n\t\t\tlogger.Info(\"enterPrecommit: No +2/3 prevotes during enterPrecommit while we're locked. Precommitting nil\")\n\t\t} else {\n\t\t\tlogger.Info(\"enterPrecommit: No +2/3 prevotes during enterPrecommit. Precommitting nil.\")\n\t\t}\n\t\tcs.signAddVote(tmproto.PrecommitType, nil, types.PartSetHeader{})\n\t\treturn\n\t}\n\n\t// At this point +2/3 prevoted for a particular block or nil.\n\tif err := cs.eventBus.PublishEventPolka(cs.RoundStateEvent()); err != nil {\n\t\tcs.Logger.Error(\"Error publishing polka\", \"err\", err)\n\t}\n\n\t// the latest POLRound should be this round.\n\tpolRound, _ := cs.Votes.POLInfo()\n\tif polRound < round {\n\t\tpanic(fmt.Sprintf(\"This POLRound should be %v but got %v\", round, polRound))\n\t}\n\n\t// +2/3 prevoted nil. Unlock and precommit nil.\n\tif len(blockID.Hash) == 0 {\n\t\tif cs.LockedBlock == nil {\n\t\t\tlogger.Info(\"enterPrecommit: +2/3 prevoted for nil.\")\n\t\t} else {\n\t\t\tlogger.Info(\"enterPrecommit: +2/3 prevoted for nil. Unlocking\")\n\t\t\tcs.LockedRound = -1\n\t\t\tcs.LockedBlock = nil\n\t\t\tcs.LockedBlockParts = nil\n\t\t\tif err := cs.eventBus.PublishEventUnlock(cs.RoundStateEvent()); err != nil {\n\t\t\t\tcs.Logger.Error(\"Error publishing event unlock\", \"err\", err)\n\t\t\t}\n\t\t}\n\t\tcs.signAddVote(tmproto.PrecommitType, nil, types.PartSetHeader{})\n\t\treturn\n\t}\n\n\t// At this point, +2/3 prevoted for a particular block.\n\n\t// If we're already locked on that block, precommit it, and update the LockedRound\n\tif cs.LockedBlock.HashesTo(blockID.Hash) {\n\t\tlogger.Info(\"enterPrecommit: +2/3 prevoted locked block. Relocking\")\n\t\tcs.LockedRound = round\n\t\tif err := cs.eventBus.PublishEventRelock(cs.RoundStateEvent()); err != nil {\n\t\t\tcs.Logger.Error(\"Error publishing event relock\", \"err\", err)\n\t\t}\n\t\tcs.signAddVote(tmproto.PrecommitType, blockID.Hash, blockID.PartSetHeader)\n\t\treturn\n\t}\n\n\t// If +2/3 prevoted for proposal block, stage and precommit it\n\tif cs.ProposalBlock.HashesTo(blockID.Hash) {\n\t\tlogger.Info(\"enterPrecommit: +2/3 prevoted proposal block. Locking\", \"hash\", blockID.Hash)\n\t\t// Validate the block.\n\t\tif err := cs.blockExec.ValidateBlock(cs.state, cs.ProposalBlock); err != nil {\n\t\t\tpanic(fmt.Sprintf(\"enterPrecommit: +2/3 prevoted for an invalid block: %v\", err))\n\t\t}\n\t\tcs.LockedRound = round\n\t\tcs.LockedBlock = cs.ProposalBlock\n\t\tcs.LockedBlockParts = cs.ProposalBlockParts\n\t\tif err := cs.eventBus.PublishEventLock(cs.RoundStateEvent()); err != nil {\n\t\t\tcs.Logger.Error(\"Error publishing event lock\", \"err\", err)\n\t\t}\n\t\tcs.signAddVote(tmproto.PrecommitType, blockID.Hash, blockID.PartSetHeader)\n\t\treturn\n\t}\n\n\t// There was a polka in this round for a block we don't have.\n\t// Fetch that block, unlock, and precommit nil.\n\t// The +2/3 prevotes for this round is the POL for our unlock.\n\tlogger.Info(\"enterPrecommit: +2/3 prevotes for a block we don't have. Voting nil\", \"blockID\", blockID)\n\tcs.LockedRound = -1\n\tcs.LockedBlock = nil\n\tcs.LockedBlockParts = nil\n\tif !cs.ProposalBlockParts.HasHeader(blockID.PartSetHeader) {\n\t\tcs.ProposalBlock = nil\n\t\tcs.ProposalBlockParts = types.NewPartSetFromHeader(blockID.PartSetHeader)\n\t}\n\tif err := cs.eventBus.PublishEventUnlock(cs.RoundStateEvent()); err != nil {\n\t\tcs.Logger.Error(\"Error publishing event unlock\", \"err\", err)\n\t}\n\tcs.signAddVote(tmproto.PrecommitType, nil, types.PartSetHeader{})\n}\n\n// Enter: any +2/3 precommits for next round.\nfunc (cs *State) enterPrecommitWait(height int64, round int32) {\n\tlogger := cs.Logger.With(\"height\", height, \"round\", round)\n\n\tif cs.Height != height || round < cs.Round || (cs.Round == round && cs.TriggeredTimeoutPrecommit) {\n\t\tlogger.Debug(\n\t\t\tfmt.Sprintf(\n\t\t\t\t\"enterPrecommitWait(%v/%v): Invalid args. \"+\n\t\t\t\t\t\"Current state is Height/Round: %v/%v/, TriggeredTimeoutPrecommit:%v\",\n\t\t\t\theight, round, cs.Height, cs.Round, cs.TriggeredTimeoutPrecommit))\n\t\treturn\n\t}\n\tif !cs.Votes.Precommits(round).HasTwoThirdsAny() {\n\t\tpanic(fmt.Sprintf(\"enterPrecommitWait(%v/%v), but Precommits does not have any +2/3 votes\", height, round))\n\t}\n\tlogger.Info(fmt.Sprintf(\"enterPrecommitWait(%v/%v). Current: %v/%v/%v\", height, round, cs.Height, cs.Round, cs.Step))\n\n\tdefer func() {\n\t\t// Done enterPrecommitWait:\n\t\tcs.TriggeredTimeoutPrecommit = true\n\t\tcs.newStep()\n\t}()\n\n\t// Wait for some more precommits; enterNewRound\n\tcs.scheduleTimeout(cs.config.Precommit(round), height, round, cstypes.RoundStepPrecommitWait)\n}\n\n// Enter: +2/3 precommits for block\nfunc (cs *State) enterCommit(height int64, commitRound int32) {\n\tlogger := cs.Logger.With(\"height\", height, \"commitRound\", commitRound)\n\n\tif cs.Height != height || cstypes.RoundStepCommit <= cs.Step {\n\t\tlogger.Debug(fmt.Sprintf(\n\t\t\t\"enterCommit(%v/%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tcommitRound,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\tlogger.Info(fmt.Sprintf(\"enterCommit(%v/%v). Current: %v/%v/%v\", height, commitRound, cs.Height, cs.Round, cs.Step))\n\n\tdefer func() {\n\t\t// Done enterCommit:\n\t\t// keep cs.Round the same, commitRound points to the right Precommits set.\n\t\tcs.updateRoundStep(cs.Round, cstypes.RoundStepCommit)\n\t\tcs.CommitRound = commitRound\n\t\tcs.CommitTime = tmtime.Now()\n\t\tcs.newStep()\n\n\t\t// Maybe finalize immediately.\n\t\tcs.tryFinalizeCommit(height)\n\t}()\n\n\tblockID, ok := cs.Votes.Precommits(commitRound).TwoThirdsMajority()\n\tif !ok {\n\t\tpanic(\"RunActionCommit() expects +2/3 precommits\")\n\t}\n\n\t// The Locked* fields no longer matter.\n\t// Move them over to ProposalBlock if they match the commit hash,\n\t// otherwise they'll be cleared in updateToState.\n\tif cs.LockedBlock.HashesTo(blockID.Hash) {\n\t\tlogger.Info(\"Commit is for locked block. Set ProposalBlock=LockedBlock\", \"blockHash\", blockID.Hash)\n\t\tcs.ProposalBlock = cs.LockedBlock\n\t\tcs.ProposalBlockParts = cs.LockedBlockParts\n\t}\n\n\t// If we don't have the block being committed, set up to get it.\n\tif !cs.ProposalBlock.HashesTo(blockID.Hash) {\n\t\tif !cs.ProposalBlockParts.HasHeader(blockID.PartSetHeader) {\n\t\t\tlogger.Info(\n\t\t\t\t\"Commit is for a block we don't know about. Set ProposalBlock=nil\",\n\t\t\t\t\"proposal\",\n\t\t\t\tcs.ProposalBlock.Hash(),\n\t\t\t\t\"commit\",\n\t\t\t\tblockID.Hash)\n\t\t\t// We're getting the wrong block.\n\t\t\t// Set up ProposalBlockParts and keep waiting.\n\t\t\tcs.ProposalBlock = nil\n\t\t\tcs.ProposalBlockParts = types.NewPartSetFromHeader(blockID.PartSetHeader)\n\t\t\tif err := cs.eventBus.PublishEventValidBlock(cs.RoundStateEvent()); err != nil {\n\t\t\t\tcs.Logger.Error(\"Error publishing valid block\", \"err\", err)\n\t\t\t}\n\t\t\tcs.evsw.FireEvent(types.EventValidBlock, &cs.RoundState)\n\t\t}\n\t\t// else {\n\t\t// We just need to keep waiting.\n\t\t// }\n\t}\n}\n\n// If we have the block AND +2/3 commits for it, finalize.\nfunc (cs *State) tryFinalizeCommit(height int64) {\n\tlogger := cs.Logger.With(\"height\", height)\n\n\tif cs.Height != height {\n\t\tpanic(fmt.Sprintf(\"tryFinalizeCommit() cs.Height: %v vs height: %v\", cs.Height, height))\n\t}\n\n\tblockID, ok := cs.Votes.Precommits(cs.CommitRound).TwoThirdsMajority()\n\tif !ok || len(blockID.Hash) == 0 {\n\t\tlogger.Error(\"Attempt to finalize failed. There was no +2/3 majority, or +2/3 was for <nil>.\")\n\t\treturn\n\t}\n\tif !cs.ProposalBlock.HashesTo(blockID.Hash) {\n\t\t// TODO: this happens every time if we're not a validator (ugly logs)\n\t\t// TODO: ^^ wait, why does it matter that we're a validator?\n\t\tlogger.Info(\n\t\t\t\"Attempt to finalize failed. We don't have the commit block.\",\n\t\t\t\"proposal-block\",\n\t\t\tcs.ProposalBlock.Hash(),\n\t\t\t\"commit-block\",\n\t\t\tblockID.Hash)\n\t\treturn\n\t}\n\n\t//\tgo\n\tcs.finalizeCommit(height)\n}\n\n// Increment height and goto cstypes.RoundStepNewHeight\nfunc (cs *State) finalizeCommit(height int64) {\n\tif cs.Height != height || cs.Step != cstypes.RoundStepCommit {\n\t\tcs.Logger.Debug(fmt.Sprintf(\n\t\t\t\"finalizeCommit(%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\n\tblockID, ok := cs.Votes.Precommits(cs.CommitRound).TwoThirdsMajority()\n\tblock, blockParts := cs.ProposalBlock, cs.ProposalBlockParts\n\n\tif !ok {\n\t\tpanic(\"Cannot finalizeCommit, commit does not have two thirds majority\")\n\t}\n\tif !blockParts.HasHeader(blockID.PartSetHeader) {\n\t\tpanic(\"Expected ProposalBlockParts header to be commit header\")\n\t}\n\tif !block.HashesTo(blockID.Hash) {\n\t\tpanic(\"Cannot finalizeCommit, ProposalBlock does not hash to commit hash\")\n\t}\n\tif err := cs.blockExec.ValidateBlock(cs.state, block); err != nil {\n\t\tpanic(fmt.Errorf(\"+2/3 committed an invalid block: %w\", err))\n\t}\n\n\tcs.Logger.Info(\"Finalizing commit of block with N txs\",\n\t\t\"height\", block.Height,\n\t\t\"hash\", block.Hash(),\n\t\t\"root\", block.AppHash,\n\t\t\"N\", len(block.Txs))\n\tcs.Logger.Info(fmt.Sprintf(\"%v\", block))\n\n\tfail.Fail() // XXX\n\n\t// Save to blockStore.\n\tif cs.blockStore.Height() < block.Height {\n\t\t// NOTE: the seenCommit is local justification to commit this block,\n\t\t// but may differ from the LastCommit included in the next block\n\t\tprecommits := cs.Votes.Precommits(cs.CommitRound)\n\t\tseenCommit := precommits.MakeCommit()\n\t\tcs.blockStore.SaveBlock(block, blockParts, seenCommit)\n\t} else {\n\t\t// Happens during replay if we already saved the block but didn't commit\n\t\tcs.Logger.Info(\"Calling finalizeCommit on already stored block\", \"height\", block.Height)\n\t}\n\n\tfail.Fail() // XXX\n\n\t// Write EndHeightMessage{} for this height, implying that the blockstore\n\t// has saved the block.\n\t//\n\t// If we crash before writing this EndHeightMessage{}, we will recover by\n\t// running ApplyBlock during the ABCI handshake when we restart.  If we\n\t// didn't save the block to the blockstore before writing\n\t// EndHeightMessage{}, we'd have to change WAL replay -- currently it\n\t// complains about replaying for heights where an #ENDHEIGHT entry already\n\t// exists.\n\t//\n\t// Either way, the State should not be resumed until we\n\t// successfully call ApplyBlock (ie. later here, or in Handshake after\n\t// restart).\n\tendMsg := EndHeightMessage{height}\n\tif err := cs.wal.WriteSync(endMsg); err != nil { // NOTE: fsync\n\t\tpanic(fmt.Sprintf(\"Failed to write %v msg to consensus wal due to %v. Check your FS and restart the node\",\n\t\t\tendMsg, err))\n\t}\n\n\tfail.Fail() // XXX\n\n\t// Create a copy of the state for staging and an event cache for txs.\n\tstateCopy := cs.state.Copy()\n\n\t// Execute and commit the block, update and save the state, and update the mempool.\n\t// NOTE The block.AppHash wont reflect these txs until the next block.\n\tvar err error\n\tvar retainHeight int64\n\tstateCopy, retainHeight, err = cs.blockExec.ApplyBlock(\n\t\tstateCopy,\n\t\ttypes.BlockID{Hash: block.Hash(), PartSetHeader: blockParts.Header()},\n\t\tblock)\n\tif err != nil {\n\t\tcs.Logger.Error(\"Error on ApplyBlock\", \"err\", err)\n\t\treturn\n\t}\n\n\tfail.Fail() // XXX\n\n\t// Prune old heights, if requested by ABCI app.\n\tif retainHeight > 0 {\n\t\tpruned, err := cs.pruneBlocks(retainHeight)\n\t\tif err != nil {\n\t\t\tcs.Logger.Error(\"Failed to prune blocks\", \"retainHeight\", retainHeight, \"err\", err)\n\t\t} else {\n\t\t\tcs.Logger.Info(\"Pruned blocks\", \"pruned\", pruned, \"retainHeight\", retainHeight)\n\t\t}\n\t}\n\n\t// must be called before we update state\n\tcs.recordMetrics(height, block)\n\n\t// NewHeightStep!\n\tcs.updateToState(stateCopy)\n\n\tfail.Fail() // XXX\n\n\t// Private validator might have changed it's key pair => refetch pubkey.\n\tif err := cs.updatePrivValidatorPubKey(); err != nil {\n\t\tcs.Logger.Error(\"Can't get private validator pubkey\", \"err\", err)\n\t}\n\n\t// cs.StartTime is already set.\n\t// Schedule Round0 to start soon.\n\tcs.scheduleRound0(&cs.RoundState)\n\n\t// By here,\n\t// * cs.Height has been increment to height+1\n\t// * cs.Step is now cstypes.RoundStepNewHeight\n\t// * cs.StartTime is set to when we will start round0.\n}\n\nfunc (cs *State) pruneBlocks(retainHeight int64) (uint64, error) {\n\tbase := cs.blockStore.Base()\n\tif retainHeight <= base {\n\t\treturn 0, nil\n\t}\n\tpruned, err := cs.blockStore.PruneBlocks(retainHeight)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to prune block store: %w\", err)\n\t}\n\terr = cs.blockExec.Store().PruneStates(base, retainHeight)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to prune state database: %w\", err)\n\t}\n\treturn pruned, nil\n}\n\nfunc (cs *State) recordMetrics(height int64, block *types.Block) {\n\tcs.metrics.Validators.Set(float64(cs.Validators.Size()))\n\tcs.metrics.ValidatorsPower.Set(float64(cs.Validators.TotalVotingPower()))\n\n\tvar (\n\t\tmissingValidators      int\n\t\tmissingValidatorsPower int64\n\t)\n\t// height=0 -> MissingValidators and MissingValidatorsPower are both 0.\n\t// Remember that the first LastCommit is intentionally empty, so it's not\n\t// fair to increment missing validators number.\n\tif height > cs.state.InitialHeight {\n\t\t// Sanity check that commit size matches validator set size - only applies\n\t\t// after first block.\n\t\tvar (\n\t\t\tcommitSize = block.LastCommit.Size()\n\t\t\tvalSetLen  = len(cs.LastValidators.Validators)\n\t\t\taddress    types.Address\n\t\t)\n\t\tif commitSize != valSetLen {\n\t\t\tpanic(fmt.Sprintf(\"commit size (%d) doesn't match valset length (%d) at height %d\\n\\n%v\\n\\n%v\",\n\t\t\t\tcommitSize, valSetLen, block.Height, block.LastCommit.Signatures, cs.LastValidators.Validators))\n\t\t}\n\n\t\tif cs.privValidator != nil {\n\t\t\tif cs.privValidatorPubKey == nil {\n\t\t\t\t// Metrics won't be updated, but it's not critical.\n\t\t\t\tcs.Logger.Error(fmt.Sprintf(\"recordMetrics: %v\", errPubKeyIsNotSet))\n\t\t\t} else {\n\t\t\t\taddress = cs.privValidatorPubKey.Address()\n\t\t\t}\n\t\t}\n\n\t\tfor i, val := range cs.LastValidators.Validators {\n\t\t\tcommitSig := block.LastCommit.Signatures[i]\n\t\t\tif commitSig.Absent() {\n\t\t\t\tmissingValidators++\n\t\t\t\tmissingValidatorsPower += val.VotingPower\n\t\t\t}\n\n\t\t\tif bytes.Equal(val.Address, address) {\n\t\t\t\tlabel := []string{\n\t\t\t\t\t\"validator_address\", val.Address.String(),\n\t\t\t\t}\n\t\t\t\tcs.metrics.ValidatorPower.With(label...).Set(float64(val.VotingPower))\n\t\t\t\tif commitSig.ForBlock() {\n\t\t\t\t\tcs.metrics.ValidatorLastSignedHeight.With(label...).Set(float64(height))\n\t\t\t\t} else {\n\t\t\t\t\tcs.metrics.ValidatorMissedBlocks.With(label...).Add(float64(1))\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\tcs.metrics.MissingValidators.Set(float64(missingValidators))\n\tcs.metrics.MissingValidatorsPower.Set(float64(missingValidatorsPower))\n\n\t// NOTE: byzantine validators power and count is only for consensus evidence i.e. duplicate vote\n\tvar (\n\t\tbyzantineValidatorsPower = int64(0)\n\t\tbyzantineValidatorsCount = int64(0)\n\t)\n\tfor _, ev := range block.Evidence.Evidence {\n\t\tif dve, ok := ev.(*types.DuplicateVoteEvidence); ok {\n\t\t\tif _, val := cs.Validators.GetByAddress(dve.VoteA.ValidatorAddress); val != nil {\n\t\t\t\tbyzantineValidatorsCount++\n\t\t\t\tbyzantineValidatorsPower += val.VotingPower\n\t\t\t}\n\t\t}\n\t}\n\tcs.metrics.ByzantineValidators.Set(float64(byzantineValidatorsCount))\n\tcs.metrics.ByzantineValidatorsPower.Set(float64(byzantineValidatorsPower))\n\n\tif height > 1 {\n\t\tlastBlockMeta := cs.blockStore.LoadBlockMeta(height - 1)\n\t\tif lastBlockMeta != nil {\n\t\t\tcs.metrics.BlockIntervalSeconds.Observe(\n\t\t\t\tblock.Time.Sub(lastBlockMeta.Header.Time).Seconds(),\n\t\t\t)\n\t\t}\n\t}\n\n\tcs.metrics.NumTxs.Set(float64(len(block.Data.Txs)))\n\tcs.metrics.TotalTxs.Add(float64(len(block.Data.Txs)))\n\tcs.metrics.BlockSizeBytes.Set(float64(block.Size()))\n\tcs.metrics.CommittedHeight.Set(float64(block.Height))\n}\n\n//-----------------------------------------------------------------------------\n\nfunc (cs *State) defaultSetProposal(proposal *types.Proposal) error {\n\t// Already have one\n\t// TODO: possibly catch double proposals\n\tif cs.Proposal != nil {\n\t\treturn nil\n\t}\n\n\t// Does not apply\n\tif proposal.Height != cs.Height || proposal.Round != cs.Round {\n\t\treturn nil\n\t}\n\n\t// Verify POLRound, which must be -1 or in range [0, proposal.Round).\n\tif proposal.POLRound < -1 ||\n\t\t(proposal.POLRound >= 0 && proposal.POLRound >= proposal.Round) {\n\t\treturn ErrInvalidProposalPOLRound\n\t}\n\n\tp := proposal.ToProto()\n\t// Verify signature\n\tif !cs.Validators.GetProposer().PubKey.VerifySignature(\n\t\ttypes.ProposalSignBytes(cs.state.ChainID, p), proposal.Signature,\n\t) {\n\t\treturn ErrInvalidProposalSignature\n\t}\n\n\tproposal.Signature = p.Signature\n\tcs.Proposal = proposal\n\t// We don't update cs.ProposalBlockParts if it is already set.\n\t// This happens if we're already in cstypes.RoundStepCommit or if there is a valid block in the current round.\n\t// TODO: We can check if Proposal is for a different block as this is a sign of misbehavior!\n\tif cs.ProposalBlockParts == nil {\n\t\tcs.ProposalBlockParts = types.NewPartSetFromHeader(proposal.BlockID.PartSetHeader)\n\t}\n\tcs.Logger.Info(\"Received proposal\", \"proposal\", proposal)\n\treturn nil\n}\n\n// NOTE: block is not necessarily valid.\n// Asynchronously triggers either enterPrevote (before we timeout of propose) or tryFinalizeCommit,\n// once we have the full block.\nfunc (cs *State) addProposalBlockPart(msg *BlockPartMessage, peerID p2p.ID) (added bool, err error) {\n\theight, round, part := msg.Height, msg.Round, msg.Part\n\n\t// Blocks might be reused, so round mismatch is OK\n\tif cs.Height != height {\n\t\tcs.Logger.Debug(\"Received block part from wrong height\", \"height\", height, \"round\", round)\n\t\treturn false, nil\n\t}\n\n\t// We're not expecting a block part.\n\tif cs.ProposalBlockParts == nil {\n\t\t// NOTE: this can happen when we've gone to a higher round and\n\t\t// then receive parts from the previous round - not necessarily a bad peer.\n\t\tcs.Logger.Info(\"Received a block part when we're not expecting any\",\n\t\t\t\"height\", height, \"round\", round, \"index\", part.Index, \"peer\", peerID)\n\t\treturn false, nil\n\t}\n\n\tadded, err = cs.ProposalBlockParts.AddPart(part)\n\tif err != nil {\n\t\treturn added, err\n\t}\n\tif cs.ProposalBlockParts.ByteSize() > cs.state.ConsensusParams.Block.MaxBytes {\n\t\treturn added, fmt.Errorf(\"total size of proposal block parts exceeds maximum block bytes (%d > %d)\",\n\t\t\tcs.ProposalBlockParts.ByteSize(), cs.state.ConsensusParams.Block.MaxBytes,\n\t\t)\n\t}\n\tif added && cs.ProposalBlockParts.IsComplete() {\n\t\tbz, err := ioutil.ReadAll(cs.ProposalBlockParts.GetReader())\n\t\tif err != nil {\n\t\t\treturn added, err\n\t\t}\n\n\t\tvar pbb = new(tmproto.Block)\n\t\terr = proto.Unmarshal(bz, pbb)\n\t\tif err != nil {\n\t\t\treturn added, err\n\t\t}\n\n\t\tblock, err := types.BlockFromProto(pbb)\n\t\tif err != nil {\n\t\t\treturn added, err\n\t\t}\n\n\t\tcs.ProposalBlock = block\n\t\t// NOTE: it's possible to receive complete proposal blocks for future rounds without having the proposal\n\t\tcs.Logger.Info(\"Received complete proposal block\", \"height\", cs.ProposalBlock.Height, \"hash\", cs.ProposalBlock.Hash())\n\t\tif err := cs.eventBus.PublishEventCompleteProposal(cs.CompleteProposalEvent()); err != nil {\n\t\t\tcs.Logger.Error(\"Error publishing event complete proposal\", \"err\", err)\n\t\t}\n\n\t\t// Update Valid* if we can.\n\t\tprevotes := cs.Votes.Prevotes(cs.Round)\n\t\tblockID, hasTwoThirds := prevotes.TwoThirdsMajority()\n\t\tif hasTwoThirds && !blockID.IsZero() && (cs.ValidRound < cs.Round) {\n\t\t\tif cs.ProposalBlock.HashesTo(blockID.Hash) {\n\t\t\t\tcs.Logger.Info(\"Updating valid block to new proposal block\",\n\t\t\t\t\t\"valid-round\", cs.Round, \"valid-block-hash\", cs.ProposalBlock.Hash())\n\t\t\t\tcs.ValidRound = cs.Round\n\t\t\t\tcs.ValidBlock = cs.ProposalBlock\n\t\t\t\tcs.ValidBlockParts = cs.ProposalBlockParts\n\t\t\t}\n\t\t\t// TODO: In case there is +2/3 majority in Prevotes set for some\n\t\t\t// block and cs.ProposalBlock contains different block, either\n\t\t\t// proposer is faulty or voting power of faulty processes is more\n\t\t\t// than 1/3. We should trigger in the future accountability\n\t\t\t// procedure at this point.\n\t\t}\n\n\t\tif cs.Step <= cstypes.RoundStepPropose && cs.isProposalComplete() {\n\t\t\t// Move onto the next step\n\t\t\tcs.enterPrevote(height, cs.Round)\n\t\t\tif hasTwoThirds { // this is optimisation as this will be triggered when prevote is added\n\t\t\t\tcs.enterPrecommit(height, cs.Round)\n\t\t\t}\n\t\t} else if cs.Step == cstypes.RoundStepCommit {\n\t\t\t// If we're waiting on the proposal block...\n\t\t\tcs.tryFinalizeCommit(height)\n\t\t}\n\t\treturn added, nil\n\t}\n\treturn added, nil\n}\n\n// Attempt to add the vote. if its a duplicate signature, dupeout the validator\nfunc (cs *State) tryAddVote(vote *types.Vote, peerID p2p.ID) (bool, error) {\n\tadded, err := cs.addVote(vote, peerID)\n\tif err != nil {\n\t\t// If the vote height is off, we'll just ignore it,\n\t\t// But if it's a conflicting sig, add it to the cs.evpool.\n\t\t// If it's otherwise invalid, punish peer.\n\t\t// nolint: gocritic\n\t\tif voteErr, ok := err.(*types.ErrVoteConflictingVotes); ok {\n\t\t\tif cs.privValidatorPubKey == nil {\n\t\t\t\treturn false, errPubKeyIsNotSet\n\t\t\t}\n\n\t\t\tif bytes.Equal(vote.ValidatorAddress, cs.privValidatorPubKey.Address()) {\n\t\t\t\tcs.Logger.Error(\n\t\t\t\t\t\"Found conflicting vote from ourselves. Did you unsafe_reset a validator?\",\n\t\t\t\t\t\"height\",\n\t\t\t\t\tvote.Height,\n\t\t\t\t\t\"round\",\n\t\t\t\t\tvote.Round,\n\t\t\t\t\t\"type\",\n\t\t\t\t\tvote.Type)\n\t\t\t\treturn added, err\n\t\t\t}\n\t\t\t// report conflicting votes to the evidence pool\n\t\t\tcs.evpool.ReportConflictingVotes(voteErr.VoteA, voteErr.VoteB)\n\t\t\tcs.Logger.Info(\"Found and sent conflicting votes to the evidence pool\",\n\t\t\t\t\"VoteA\", voteErr.VoteA,\n\t\t\t\t\"VoteB\", voteErr.VoteB,\n\t\t\t)\n\t\t\treturn added, err\n\t\t} else if err == types.ErrVoteNonDeterministicSignature {\n\t\t\tcs.Logger.Debug(\"Vote has non-deterministic signature\", \"err\", err)\n\t\t} else {\n\t\t\t// Either\n\t\t\t// 1) bad peer OR\n\t\t\t// 2) not a bad peer? this can also err sometimes with \"Unexpected step\" OR\n\t\t\t// 3) tmkms use with multiple validators connecting to a single tmkms instance\n\t\t\t// \t\t(https://github.com/tendermint/tendermint/issues/3839).\n\t\t\tcs.Logger.Info(\"Error attempting to add vote\", \"err\", err)\n\t\t\treturn added, ErrAddingVote\n\t\t}\n\t}\n\treturn added, nil\n}\n\n//-----------------------------------------------------------------------------\n\nfunc (cs *State) addVote(\n\tvote *types.Vote,\n\tpeerID p2p.ID) (added bool, err error) {\n\tcs.Logger.Debug(\n\t\t\"addVote\",\n\t\t\"voteHeight\",\n\t\tvote.Height,\n\t\t\"voteType\",\n\t\tvote.Type,\n\t\t\"valIndex\",\n\t\tvote.ValidatorIndex,\n\t\t\"csHeight\",\n\t\tcs.Height,\n\t)\n\n\t// A precommit for the previous height?\n\t// These come in while we wait timeoutCommit\n\tif vote.Height+1 == cs.Height && vote.Type == tmproto.PrecommitType {\n\t\tif cs.Step != cstypes.RoundStepNewHeight {\n\t\t\t// Late precommit at prior height is ignored\n\t\t\tcs.Logger.Debug(\"Precommit vote came in after commit timeout and has been ignored\", \"vote\", vote)\n\t\t\treturn\n\t\t}\n\t\tadded, err = cs.LastCommit.AddVote(vote)\n\t\tif !added {\n\t\t\treturn\n\t\t}\n\n\t\tcs.Logger.Info(fmt.Sprintf(\"Added to lastPrecommits: %v\", cs.LastCommit.StringShort()))\n\t\tif err := cs.eventBus.PublishEventVote(types.EventDataVote{Vote: vote}); err != nil {\n\t\t\treturn added, err\n\t\t}\n\t\tcs.evsw.FireEvent(types.EventVote, vote)\n\n\t\t// if we can skip timeoutCommit and have all the votes now,\n\t\tif cs.config.SkipTimeoutCommit && cs.LastCommit.HasAll() {\n\t\t\t// go straight to new round (skip timeout commit)\n\t\t\t// cs.scheduleTimeout(time.Duration(0), cs.Height, 0, cstypes.RoundStepNewHeight)\n\t\t\tcs.enterNewRound(cs.Height, 0)\n\t\t}\n\n\t\treturn\n\t}\n\n\t// Height mismatch is ignored.\n\t// Not necessarily a bad peer, but not favourable behaviour.\n\tif vote.Height != cs.Height {\n\t\tcs.Logger.Info(\"Vote ignored and not added\", \"voteHeight\", vote.Height, \"csHeight\", cs.Height, \"peerID\", peerID)\n\t\treturn\n\t}\n\n\theight := cs.Height\n\tadded, err = cs.Votes.AddVote(vote, peerID)\n\tif !added {\n\t\t// Either duplicate, or error upon cs.Votes.AddByIndex()\n\t\treturn\n\t}\n\n\tif err := cs.eventBus.PublishEventVote(types.EventDataVote{Vote: vote}); err != nil {\n\t\treturn added, err\n\t}\n\tcs.evsw.FireEvent(types.EventVote, vote)\n\n\tswitch vote.Type {\n\tcase tmproto.PrevoteType:\n\t\tprevotes := cs.Votes.Prevotes(vote.Round)\n\t\tcs.Logger.Info(\"Added to prevote\", \"vote\", vote, \"prevotes\", prevotes.StringShort())\n\n\t\t// If +2/3 prevotes for a block or nil for *any* round:\n\t\tif blockID, ok := prevotes.TwoThirdsMajority(); ok {\n\n\t\t\t// There was a polka!\n\t\t\t// If we're locked but this is a recent polka, unlock.\n\t\t\t// If it matches our ProposalBlock, update the ValidBlock\n\n\t\t\t// Unlock if `cs.LockedRound < vote.Round <= cs.Round`\n\t\t\t// NOTE: If vote.Round > cs.Round, we'll deal with it when we get to vote.Round\n\t\t\tif (cs.LockedBlock != nil) &&\n\t\t\t\t(cs.LockedRound < vote.Round) &&\n\t\t\t\t(vote.Round <= cs.Round) &&\n\t\t\t\t!cs.LockedBlock.HashesTo(blockID.Hash) {\n\n\t\t\t\tcs.Logger.Info(\"Unlocking because of POL.\", \"lockedRound\", cs.LockedRound, \"POLRound\", vote.Round)\n\t\t\t\tcs.LockedRound = -1\n\t\t\t\tcs.LockedBlock = nil\n\t\t\t\tcs.LockedBlockParts = nil\n\t\t\t\tif err := cs.eventBus.PublishEventUnlock(cs.RoundStateEvent()); err != nil {\n\t\t\t\t\treturn added, err\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Update Valid* if we can.\n\t\t\t// NOTE: our proposal block may be nil or not what received a polka..\n\t\t\tif len(blockID.Hash) != 0 && (cs.ValidRound < vote.Round) && (vote.Round == cs.Round) {\n\n\t\t\t\tif cs.ProposalBlock.HashesTo(blockID.Hash) {\n\t\t\t\t\tcs.Logger.Info(\n\t\t\t\t\t\t\"Updating ValidBlock because of POL.\", \"validRound\", cs.ValidRound, \"POLRound\", vote.Round)\n\t\t\t\t\tcs.ValidRound = vote.Round\n\t\t\t\t\tcs.ValidBlock = cs.ProposalBlock\n\t\t\t\t\tcs.ValidBlockParts = cs.ProposalBlockParts\n\t\t\t\t} else {\n\t\t\t\t\tcs.Logger.Info(\n\t\t\t\t\t\t\"Valid block we don't know about. Set ProposalBlock=nil\",\n\t\t\t\t\t\t\"proposal\", cs.ProposalBlock.Hash(), \"blockID\", blockID.Hash)\n\t\t\t\t\t// We're getting the wrong block.\n\t\t\t\t\tcs.ProposalBlock = nil\n\t\t\t\t}\n\t\t\t\tif !cs.ProposalBlockParts.HasHeader(blockID.PartSetHeader) {\n\t\t\t\t\tcs.ProposalBlockParts = types.NewPartSetFromHeader(blockID.PartSetHeader)\n\t\t\t\t}\n\t\t\t\tcs.evsw.FireEvent(types.EventValidBlock, &cs.RoundState)\n\t\t\t\tif err := cs.eventBus.PublishEventValidBlock(cs.RoundStateEvent()); err != nil {\n\t\t\t\t\treturn added, err\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If +2/3 prevotes for *anything* for future round:\n\t\tswitch {\n\t\tcase cs.Round < vote.Round && prevotes.HasTwoThirdsAny():\n\t\t\t// Round-skip if there is any 2/3+ of votes ahead of us\n\t\t\tcs.enterNewRound(height, vote.Round)\n\t\tcase cs.Round == vote.Round && cstypes.RoundStepPrevote <= cs.Step: // current round\n\t\t\tblockID, ok := prevotes.TwoThirdsMajority()\n\t\t\tif ok && (cs.isProposalComplete() || len(blockID.Hash) == 0) {\n\t\t\t\tcs.enterPrecommit(height, vote.Round)\n\t\t\t} else if prevotes.HasTwoThirdsAny() {\n\t\t\t\tcs.enterPrevoteWait(height, vote.Round)\n\t\t\t}\n\t\tcase cs.Proposal != nil && 0 <= cs.Proposal.POLRound && cs.Proposal.POLRound == vote.Round:\n\t\t\t// If the proposal is now complete, enter prevote of cs.Round.\n\t\t\tif cs.isProposalComplete() {\n\t\t\t\tcs.enterPrevote(height, cs.Round)\n\t\t\t}\n\t\t}\n\n\tcase tmproto.PrecommitType:\n\t\tprecommits := cs.Votes.Precommits(vote.Round)\n\t\tcs.Logger.Info(\"Added to precommit\", \"vote\", vote, \"precommits\", precommits.StringShort())\n\n\t\tblockID, ok := precommits.TwoThirdsMajority()\n\t\tif ok {\n\t\t\t// Executed as TwoThirdsMajority could be from a higher round\n\t\t\tcs.enterNewRound(height, vote.Round)\n\t\t\tcs.enterPrecommit(height, vote.Round)\n\t\t\tif len(blockID.Hash) != 0 {\n\t\t\t\tcs.enterCommit(height, vote.Round)\n\t\t\t\tif cs.config.SkipTimeoutCommit && precommits.HasAll() {\n\t\t\t\t\tcs.enterNewRound(cs.Height, 0)\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcs.enterPrecommitWait(height, vote.Round)\n\t\t\t}\n\t\t} else if cs.Round <= vote.Round && precommits.HasTwoThirdsAny() {\n\t\t\tcs.enterNewRound(height, vote.Round)\n\t\t\tcs.enterPrecommitWait(height, vote.Round)\n\t\t}\n\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"Unexpected vote type %v\", vote.Type))\n\t}\n\n\treturn added, err\n}\n\n// CONTRACT: cs.privValidator is not nil.\nfunc (cs *State) signVote(\n\tmsgType tmproto.SignedMsgType,\n\thash []byte,\n\theader types.PartSetHeader,\n) (*types.Vote, error) {\n\t// Flush the WAL. Otherwise, we may not recompute the same vote to sign,\n\t// and the privValidator will refuse to sign anything.\n\tif err := cs.wal.FlushAndSync(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif cs.privValidatorPubKey == nil {\n\t\treturn nil, errPubKeyIsNotSet\n\t}\n\taddr := cs.privValidatorPubKey.Address()\n\tvalIdx, _ := cs.Validators.GetByAddress(addr)\n\n\tvote := &types.Vote{\n\t\tValidatorAddress: addr,\n\t\tValidatorIndex:   valIdx,\n\t\tHeight:           cs.Height,\n\t\tRound:            cs.Round,\n\t\tTimestamp:        cs.voteTime(),\n\t\tType:             msgType,\n\t\tBlockID:          types.BlockID{Hash: hash, PartSetHeader: header},\n\t}\n\tv := vote.ToProto()\n\terr := cs.privValidator.SignVote(cs.state.ChainID, v)\n\tvote.Signature = v.Signature\n\n\treturn vote, err\n}\n\nfunc (cs *State) voteTime() time.Time {\n\tnow := tmtime.Now()\n\tminVoteTime := now\n\t// TODO: We should remove next line in case we don't vote for v in case cs.ProposalBlock == nil,\n\t// even if cs.LockedBlock != nil. See https://docs.tendermint.com/master/spec/.\n\ttimeIota := time.Duration(cs.state.ConsensusParams.Block.TimeIotaMs) * time.Millisecond\n\tif cs.LockedBlock != nil {\n\t\t// See the BFT time spec https://docs.tendermint.com/master/spec/consensus/bft-time.html\n\t\tminVoteTime = cs.LockedBlock.Time.Add(timeIota)\n\t} else if cs.ProposalBlock != nil {\n\t\tminVoteTime = cs.ProposalBlock.Time.Add(timeIota)\n\t}\n\n\tif now.After(minVoteTime) {\n\t\treturn now\n\t}\n\treturn minVoteTime\n}\n\n// sign the vote and publish on internalMsgQueue\nfunc (cs *State) signAddVote(msgType tmproto.SignedMsgType, hash []byte, header types.PartSetHeader) *types.Vote {\n\tif cs.privValidator == nil { // the node does not have a key\n\t\treturn nil\n\t}\n\n\tif cs.privValidatorPubKey == nil {\n\t\t// Vote won't be signed, but it's not critical.\n\t\tcs.Logger.Error(fmt.Sprintf(\"signAddVote: %v\", errPubKeyIsNotSet))\n\t\treturn nil\n\t}\n\n\t// If the node not in the validator set, do nothing.\n\tif !cs.Validators.HasAddress(cs.privValidatorPubKey.Address()) {\n\t\treturn nil\n\t}\n\n\t// TODO: pass pubKey to signVote\n\tvote, err := cs.signVote(msgType, hash, header)\n\tif err == nil {\n\t\tcs.sendInternalMessage(msgInfo{&VoteMessage{vote}, \"\"})\n\t\tcs.Logger.Info(\"Signed and pushed vote\", \"height\", cs.Height, \"round\", cs.Round, \"vote\", vote, \"err\", err)\n\t\treturn vote\n\t}\n\t// if !cs.replayMode {\n\tcs.Logger.Error(\"Error signing vote\", \"height\", cs.Height, \"round\", cs.Round, \"vote\", vote, \"err\", err)\n\t// }\n\treturn nil\n}\n\n// updatePrivValidatorPubKey get's the private validator public key and\n// memoizes it. This func returns an error if the private validator is not\n// responding or responds with an error.\nfunc (cs *State) updatePrivValidatorPubKey() error {\n\tif cs.privValidator == nil {\n\t\treturn nil\n\t}\n\n\tpubKey, err := cs.privValidator.GetPubKey()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcs.privValidatorPubKey = pubKey\n\treturn nil\n}\n\n// look back to check existence of the node's consensus votes before joining consensus\nfunc (cs *State) checkDoubleSigningRisk(height int64) error {\n\tif cs.privValidator != nil && cs.privValidatorPubKey != nil && cs.config.DoubleSignCheckHeight > 0 && height > 0 {\n\t\tvalAddr := cs.privValidatorPubKey.Address()\n\t\tdoubleSignCheckHeight := cs.config.DoubleSignCheckHeight\n\t\tif doubleSignCheckHeight > height {\n\t\t\tdoubleSignCheckHeight = height\n\t\t}\n\t\tfor i := int64(1); i < doubleSignCheckHeight; i++ {\n\t\t\tlastCommit := cs.blockStore.LoadSeenCommit(height - i)\n\t\t\tif lastCommit != nil {\n\t\t\t\tfor sigIdx, s := range lastCommit.Signatures {\n\t\t\t\t\tif s.BlockIDFlag == types.BlockIDFlagCommit && bytes.Equal(s.ValidatorAddress, valAddr) {\n\t\t\t\t\t\tcs.Logger.Info(\"Found signature from the same key\", \"sig\", s, \"idx\", sigIdx, \"height\", height-i)\n\t\t\t\t\t\treturn ErrSignatureFoundInPastBlocks\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n//---------------------------------------------------------\n\nfunc CompareHRS(h1 int64, r1 int32, s1 cstypes.RoundStepType, h2 int64, r2 int32, s2 cstypes.RoundStepType) int {\n\tif h1 < h2 {\n\t\treturn -1\n\t} else if h1 > h2 {\n\t\treturn 1\n\t}\n\tif r1 < r2 {\n\t\treturn -1\n\t} else if r1 > r2 {\n\t\treturn 1\n\t}\n\tif s1 < s2 {\n\t\treturn -1\n\t} else if s1 > s2 {\n\t\treturn 1\n\t}\n\treturn 0\n}\n\n// repairWalFile decodes messages from src (until the decoder errors) and\n// writes them to dst.\nfunc repairWalFile(src, dst string) error {\n\tin, err := os.Open(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer in.Close()\n\n\tout, err := os.Create(dst)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer out.Close()\n\n\tvar (\n\t\tdec = NewWALDecoder(in)\n\t\tenc = NewWALEncoder(out)\n\t)\n\n\t// best-case repair (until first error is encountered)\n\tfor {\n\t\tmsg, err := dec.Decode()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\terr = enc.Encode(msg)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to encode msg: %w\", err)\n\t\t}\n\t}\n\n\treturn nil\n}\n", "package evidence\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"sort\"\n\t\"sync\"\n\t\"sync/atomic\"\n\t\"time\"\n\n\t\"github.com/gogo/protobuf/proto\"\n\tgogotypes \"github.com/gogo/protobuf/types\"\n\tdbm \"github.com/tendermint/tm-db\"\n\n\tclist \"github.com/tendermint/tendermint/libs/clist\"\n\t\"github.com/tendermint/tendermint/libs/log\"\n\ttmproto \"github.com/tendermint/tendermint/proto/tendermint/types\"\n\tsm \"github.com/tendermint/tendermint/state\"\n\t\"github.com/tendermint/tendermint/types\"\n)\n\nconst (\n\tbaseKeyCommitted = byte(0x00)\n\tbaseKeyPending   = byte(0x01)\n)\n\n// Pool maintains a pool of valid evidence to be broadcasted and committed\ntype Pool struct {\n\tlogger log.Logger\n\n\tevidenceStore dbm.DB\n\tevidenceList  *clist.CList // concurrent linked-list of evidence\n\tevidenceSize  uint32       // amount of pending evidence\n\n\t// needed to load validators to verify evidence\n\tstateDB sm.Store\n\t// needed to load headers and commits to verify evidence\n\tblockStore BlockStore\n\n\tmtx sync.Mutex\n\t// latest state\n\tstate sm.State\n\t// evidence from consensus is buffered to this slice, awaiting until the next height\n\t// before being flushed to the pool. This prevents broadcasting and proposing of\n\t// evidence before the height with which the evidence happened is finished.\n\tconsensusBuffer []duplicateVoteSet\n\n\tpruningHeight int64\n\tpruningTime   time.Time\n}\n\n// NewPool creates an evidence pool. If using an existing evidence store,\n// it will add all pending evidence to the concurrent list.\nfunc NewPool(evidenceDB dbm.DB, stateDB sm.Store, blockStore BlockStore) (*Pool, error) {\n\n\tstate, err := stateDB.Load()\n\tif err != nil {\n\t\treturn nil, fmt.Errorf(\"cannot load state: %w\", err)\n\t}\n\n\tpool := &Pool{\n\t\tstateDB:         stateDB,\n\t\tblockStore:      blockStore,\n\t\tstate:           state,\n\t\tlogger:          log.NewNopLogger(),\n\t\tevidenceStore:   evidenceDB,\n\t\tevidenceList:    clist.New(),\n\t\tconsensusBuffer: make([]duplicateVoteSet, 0),\n\t}\n\n\t// if pending evidence already in db, in event of prior failure, then check for expiration,\n\t// update the size and load it back to the evidenceList\n\tpool.pruningHeight, pool.pruningTime = pool.removeExpiredPendingEvidence()\n\tevList, _, err := pool.listEvidence(baseKeyPending, -1)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tatomic.StoreUint32(&pool.evidenceSize, uint32(len(evList)))\n\tfor _, ev := range evList {\n\t\tpool.evidenceList.PushBack(ev)\n\t}\n\n\treturn pool, nil\n}\n\n// PendingEvidence is used primarily as part of block proposal and returns up to maxNum of uncommitted evidence.\nfunc (evpool *Pool) PendingEvidence(maxBytes int64) ([]types.Evidence, int64) {\n\tif evpool.Size() == 0 {\n\t\treturn []types.Evidence{}, 0\n\t}\n\tevidence, size, err := evpool.listEvidence(baseKeyPending, maxBytes)\n\tif err != nil {\n\t\tevpool.logger.Error(\"Unable to retrieve pending evidence\", \"err\", err)\n\t}\n\treturn evidence, size\n}\n\n// Update takes both the new state and the evidence committed at that height and performs\n// the following operations:\n// 1. Take any conflicting votes from consensus and use the state's LastBlockTime to form\n//    DuplicateVoteEvidence and add it to the pool.\n// 2. Update the pool's state which contains evidence params relating to expiry.\n// 3. Moves pending evidence that has now been committed into the committed pool.\n// 4. Removes any expired evidence based on both height and time.\nfunc (evpool *Pool) Update(state sm.State, ev types.EvidenceList) {\n\t// sanity check\n\tif state.LastBlockHeight <= evpool.state.LastBlockHeight {\n\t\tpanic(fmt.Sprintf(\n\t\t\t\"failed EvidencePool.Update new state height is less than or equal to previous state height: %d <= %d\",\n\t\t\tstate.LastBlockHeight,\n\t\t\tevpool.state.LastBlockHeight,\n\t\t))\n\t}\n\tevpool.logger.Debug(\"Updating evidence pool\", \"last_block_height\", state.LastBlockHeight,\n\t\t\"last_block_time\", state.LastBlockTime)\n\n\t// flush conflicting vote pairs from the buffer, producing DuplicateVoteEvidence and\n\t// adding it to the pool\n\tevpool.processConsensusBuffer(state)\n\t// update state\n\tevpool.updateState(state)\n\n\t// move committed evidence out from the pending pool and into the committed pool\n\tevpool.markEvidenceAsCommitted(ev)\n\n\t// prune pending evidence when it has expired. This also updates when the next evidence will expire\n\tif evpool.Size() > 0 && state.LastBlockHeight > evpool.pruningHeight &&\n\t\tstate.LastBlockTime.After(evpool.pruningTime) {\n\t\tevpool.pruningHeight, evpool.pruningTime = evpool.removeExpiredPendingEvidence()\n\t}\n}\n\n// AddEvidence checks the evidence is valid and adds it to the pool.\nfunc (evpool *Pool) AddEvidence(ev types.Evidence) error {\n\tevpool.logger.Debug(\"Attempting to add evidence\", \"ev\", ev)\n\n\t// We have already verified this piece of evidence - no need to do it again\n\tif evpool.isPending(ev) {\n\t\tevpool.logger.Debug(\"Evidence already pending, ignoring this one\", \"ev\", ev)\n\t\treturn nil\n\t}\n\n\t// check that the evidence isn't already committed\n\tif evpool.isCommitted(ev) {\n\t\t// this can happen if the peer that sent us the evidence is behind so we shouldn't\n\t\t// punish the peer.\n\t\tevpool.logger.Debug(\"Evidence was already committed, ignoring this one\", \"ev\", ev)\n\t\treturn nil\n\t}\n\n\t// 1) Verify against state.\n\terr := evpool.verify(ev)\n\tif err != nil {\n\t\treturn types.NewErrInvalidEvidence(ev, err)\n\t}\n\n\t// 2) Save to store.\n\tif err := evpool.addPendingEvidence(ev); err != nil {\n\t\treturn fmt.Errorf(\"can't add evidence to pending list: %w\", err)\n\t}\n\n\t// 3) Add evidence to clist.\n\tevpool.evidenceList.PushBack(ev)\n\n\tevpool.logger.Info(\"Verified new evidence of byzantine behavior\", \"evidence\", ev)\n\n\treturn nil\n}\n\n// ReportConflictingVotes takes two conflicting votes and forms duplicate vote evidence,\n// adding it eventually to the evidence pool.\n//\n// Duplicate vote attacks happen before the block is committed and the timestamp is\n// finalized, thus the evidence pool holds these votes in a buffer, forming the\n// evidence from them once consensus at that height has been reached and `Update()` with\n// the new state called.\n//\n// Votes are not verified.\nfunc (evpool *Pool) ReportConflictingVotes(voteA, voteB *types.Vote) {\n\tevpool.mtx.Lock()\n\tdefer evpool.mtx.Unlock()\n\tevpool.consensusBuffer = append(evpool.consensusBuffer, duplicateVoteSet{\n\t\tVoteA: voteA,\n\t\tVoteB: voteB,\n\t})\n}\n\n// CheckEvidence takes an array of evidence from a block and verifies all the evidence there.\n// If it has already verified the evidence then it jumps to the next one. It ensures that no\n// evidence has already been committed or is being proposed twice. It also adds any\n// evidence that it doesn't currently have so that it can quickly form ABCI Evidence later.\nfunc (evpool *Pool) CheckEvidence(evList types.EvidenceList) error {\n\thashes := make([][]byte, len(evList))\n\tfor idx, ev := range evList {\n\n\t\tok := evpool.fastCheck(ev)\n\n\t\tif !ok {\n\t\t\t// check that the evidence isn't already committed\n\t\t\tif evpool.isCommitted(ev) {\n\t\t\t\treturn &types.ErrInvalidEvidence{Evidence: ev, Reason: errors.New(\"evidence was already committed\")}\n\t\t\t}\n\n\t\t\terr := evpool.verify(ev)\n\t\t\tif err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tif err := evpool.addPendingEvidence(ev); err != nil {\n\t\t\t\t// Something went wrong with adding the evidence but we already know it is valid\n\t\t\t\t// hence we log an error and continue\n\t\t\t\tevpool.logger.Error(\"Can't add evidence to pending list\", \"err\", err, \"ev\", ev)\n\t\t\t}\n\n\t\t\tevpool.logger.Info(\"Verified new evidence of byzantine behavior\", \"evidence\", ev)\n\t\t}\n\n\t\t// check for duplicate evidence. We cache hashes so we don't have to work them out again.\n\t\thashes[idx] = ev.Hash()\n\t\tfor i := idx - 1; i >= 0; i-- {\n\t\t\tif bytes.Equal(hashes[i], hashes[idx]) {\n\t\t\t\treturn &types.ErrInvalidEvidence{Evidence: ev, Reason: errors.New(\"duplicate evidence\")}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn nil\n}\n\n// EvidenceFront goes to the first evidence in the clist\nfunc (evpool *Pool) EvidenceFront() *clist.CElement {\n\treturn evpool.evidenceList.Front()\n}\n\n// EvidenceWaitChan is a channel that closes once the first evidence in the list is there. i.e Front is not nil\nfunc (evpool *Pool) EvidenceWaitChan() <-chan struct{} {\n\treturn evpool.evidenceList.WaitChan()\n}\n\n// SetLogger sets the Logger.\nfunc (evpool *Pool) SetLogger(l log.Logger) {\n\tevpool.logger = l\n}\n\n// Size returns the number of evidence in the pool.\nfunc (evpool *Pool) Size() uint32 {\n\treturn atomic.LoadUint32(&evpool.evidenceSize)\n}\n\n// State returns the current state of the evpool.\nfunc (evpool *Pool) State() sm.State {\n\tevpool.mtx.Lock()\n\tdefer evpool.mtx.Unlock()\n\treturn evpool.state\n}\n\n//--------------------------------------------------------------------------\n\n// fastCheck leverages the fact that the evidence pool may have already verified the evidence to see if it can\n// quickly conclude that the evidence is already valid.\nfunc (evpool *Pool) fastCheck(ev types.Evidence) bool {\n\tif lcae, ok := ev.(*types.LightClientAttackEvidence); ok {\n\t\tkey := keyPending(ev)\n\t\tevBytes, err := evpool.evidenceStore.Get(key)\n\t\tif evBytes == nil { // the evidence is not in the nodes pending list\n\t\t\treturn false\n\t\t}\n\t\tif err != nil {\n\t\t\tevpool.logger.Error(\"Failed to load light client attack evidence\", \"err\", err, \"key(height/hash)\", key)\n\t\t\treturn false\n\t\t}\n\t\tvar trustedPb tmproto.LightClientAttackEvidence\n\t\terr = trustedPb.Unmarshal(evBytes)\n\t\tif err != nil {\n\t\t\tevpool.logger.Error(\"Failed to convert light client attack evidence from bytes\",\n\t\t\t\t\"err\", err, \"key(height/hash)\", key)\n\t\t\treturn false\n\t\t}\n\t\ttrustedEv, err := types.LightClientAttackEvidenceFromProto(&trustedPb)\n\t\tif err != nil {\n\t\t\tevpool.logger.Error(\"Failed to convert light client attack evidence from protobuf\",\n\t\t\t\t\"err\", err, \"key(height/hash)\", key)\n\t\t\treturn false\n\t\t}\n\t\t// ensure that all the byzantine validators that the evidence pool has match the byzantine validators\n\t\t// in this evidence\n\t\tif trustedEv.ByzantineValidators == nil && lcae.ByzantineValidators != nil {\n\t\t\treturn false\n\t\t}\n\n\t\tif len(trustedEv.ByzantineValidators) != len(lcae.ByzantineValidators) {\n\t\t\treturn false\n\t\t}\n\n\t\tbyzValsCopy := make([]*types.Validator, len(lcae.ByzantineValidators))\n\t\tfor i, v := range lcae.ByzantineValidators {\n\t\t\tbyzValsCopy[i] = v.Copy()\n\t\t}\n\n\t\t// ensure that both validator arrays are in the same order\n\t\tsort.Sort(types.ValidatorsByVotingPower(byzValsCopy))\n\n\t\tfor idx, val := range trustedEv.ByzantineValidators {\n\t\t\tif !bytes.Equal(byzValsCopy[idx].Address, val.Address) {\n\t\t\t\treturn false\n\t\t\t}\n\t\t\tif byzValsCopy[idx].VotingPower != val.VotingPower {\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\treturn true\n\t}\n\n\t// for all other evidence the evidence pool just checks if it is already in the pending db\n\treturn evpool.isPending(ev)\n}\n\n// IsExpired checks whether evidence or a polc is expired by checking whether a height and time is older\n// than set by the evidence consensus parameters\nfunc (evpool *Pool) isExpired(height int64, time time.Time) bool {\n\tvar (\n\t\tparams       = evpool.State().ConsensusParams.Evidence\n\t\tageDuration  = evpool.State().LastBlockTime.Sub(time)\n\t\tageNumBlocks = evpool.State().LastBlockHeight - height\n\t)\n\treturn ageNumBlocks > params.MaxAgeNumBlocks &&\n\t\tageDuration > params.MaxAgeDuration\n}\n\n// IsCommitted returns true if we have already seen this exact evidence and it is already marked as committed.\nfunc (evpool *Pool) isCommitted(evidence types.Evidence) bool {\n\tkey := keyCommitted(evidence)\n\tok, err := evpool.evidenceStore.Has(key)\n\tif err != nil {\n\t\tevpool.logger.Error(\"Unable to find committed evidence\", \"err\", err)\n\t}\n\treturn ok\n}\n\n// IsPending checks whether the evidence is already pending. DB errors are passed to the logger.\nfunc (evpool *Pool) isPending(evidence types.Evidence) bool {\n\tkey := keyPending(evidence)\n\tok, err := evpool.evidenceStore.Has(key)\n\tif err != nil {\n\t\tevpool.logger.Error(\"Unable to find pending evidence\", \"err\", err)\n\t}\n\treturn ok\n}\n\nfunc (evpool *Pool) addPendingEvidence(ev types.Evidence) error {\n\tevpb, err := types.EvidenceToProto(ev)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to convert to proto, err: %w\", err)\n\t}\n\n\tevBytes, err := evpb.Marshal()\n\tif err != nil {\n\t\treturn fmt.Errorf(\"unable to marshal evidence: %w\", err)\n\t}\n\n\tkey := keyPending(ev)\n\n\terr = evpool.evidenceStore.Set(key, evBytes)\n\tif err != nil {\n\t\treturn fmt.Errorf(\"can't persist evidence: %w\", err)\n\t}\n\tatomic.AddUint32(&evpool.evidenceSize, 1)\n\treturn nil\n}\n\nfunc (evpool *Pool) removePendingEvidence(evidence types.Evidence) {\n\tkey := keyPending(evidence)\n\tif err := evpool.evidenceStore.Delete(key); err != nil {\n\t\tevpool.logger.Error(\"Unable to delete pending evidence\", \"err\", err)\n\t} else {\n\t\tatomic.AddUint32(&evpool.evidenceSize, ^uint32(0))\n\t\tevpool.logger.Debug(\"Deleted pending evidence\", \"evidence\", evidence)\n\t}\n}\n\n// markEvidenceAsCommitted processes all the evidence in the block, marking it as\n// committed and removing it from the pending database.\nfunc (evpool *Pool) markEvidenceAsCommitted(evidence types.EvidenceList) {\n\tblockEvidenceMap := make(map[string]struct{}, len(evidence))\n\tfor _, ev := range evidence {\n\t\tif evpool.isPending(ev) {\n\t\t\tevpool.removePendingEvidence(ev)\n\t\t\tblockEvidenceMap[evMapKey(ev)] = struct{}{}\n\t\t}\n\n\t\t// Add evidence to the committed list. As the evidence is stored in the block store\n\t\t// we only need to record the height that it was saved at.\n\t\tkey := keyCommitted(ev)\n\n\t\th := gogotypes.Int64Value{Value: ev.Height()}\n\t\tevBytes, err := proto.Marshal(&h)\n\t\tif err != nil {\n\t\t\tevpool.logger.Error(\"failed to marshal committed evidence\", \"err\", err, \"key(height/hash)\", key)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err := evpool.evidenceStore.Set(key, evBytes); err != nil {\n\t\t\tevpool.logger.Error(\"Unable to save committed evidence\", \"err\", err, \"key(height/hash)\", key)\n\t\t}\n\t}\n\n\t// remove committed evidence from the clist\n\tif len(blockEvidenceMap) != 0 {\n\t\tevpool.removeEvidenceFromList(blockEvidenceMap)\n\t}\n}\n\n// listEvidence retrieves lists evidence from oldest to newest within maxBytes.\n// If maxBytes is -1, there's no cap on the size of returned evidence.\nfunc (evpool *Pool) listEvidence(prefixKey byte, maxBytes int64) ([]types.Evidence, int64, error) {\n\tvar (\n\t\tevSize    int64\n\t\ttotalSize int64\n\t\tevidence  []types.Evidence\n\t\tevList    tmproto.EvidenceList // used for calculating the bytes size\n\t)\n\n\titer, err := dbm.IteratePrefix(evpool.evidenceStore, []byte{prefixKey})\n\tif err != nil {\n\t\treturn nil, totalSize, fmt.Errorf(\"database error: %v\", err)\n\t}\n\tdefer iter.Close()\n\tfor ; iter.Valid(); iter.Next() {\n\t\tvar evpb tmproto.Evidence\n\t\terr := evpb.Unmarshal(iter.Value())\n\t\tif err != nil {\n\t\t\treturn evidence, totalSize, err\n\t\t}\n\t\tevList.Evidence = append(evList.Evidence, evpb)\n\t\tevSize = int64(evList.Size())\n\t\tif maxBytes != -1 && evSize > maxBytes {\n\t\t\tif err := iter.Error(); err != nil {\n\t\t\t\treturn evidence, totalSize, err\n\t\t\t}\n\t\t\treturn evidence, totalSize, nil\n\t\t}\n\n\t\tev, err := types.EvidenceFromProto(&evpb)\n\t\tif err != nil {\n\t\t\treturn nil, totalSize, err\n\t\t}\n\n\t\ttotalSize = evSize\n\t\tevidence = append(evidence, ev)\n\t}\n\n\tif err := iter.Error(); err != nil {\n\t\treturn evidence, totalSize, err\n\t}\n\treturn evidence, totalSize, nil\n}\n\nfunc (evpool *Pool) removeExpiredPendingEvidence() (int64, time.Time) {\n\titer, err := dbm.IteratePrefix(evpool.evidenceStore, []byte{baseKeyPending})\n\tif err != nil {\n\t\tevpool.logger.Error(\"Unable to iterate over pending evidence\", \"err\", err)\n\t\treturn evpool.State().LastBlockHeight, evpool.State().LastBlockTime\n\t}\n\tdefer iter.Close()\n\tblockEvidenceMap := make(map[string]struct{})\n\tfor ; iter.Valid(); iter.Next() {\n\t\tev, err := bytesToEv(iter.Value())\n\t\tif err != nil {\n\t\t\tevpool.logger.Error(\"Error in transition evidence from protobuf\", \"err\", err)\n\t\t\tcontinue\n\t\t}\n\t\tif !evpool.isExpired(ev.Height(), ev.Time()) {\n\t\t\tif len(blockEvidenceMap) != 0 {\n\t\t\t\tevpool.removeEvidenceFromList(blockEvidenceMap)\n\t\t\t}\n\n\t\t\t// return the height and time with which this evidence will have expired so we know when to prune next\n\t\t\treturn ev.Height() + evpool.State().ConsensusParams.Evidence.MaxAgeNumBlocks + 1,\n\t\t\t\tev.Time().Add(evpool.State().ConsensusParams.Evidence.MaxAgeDuration).Add(time.Second)\n\t\t}\n\t\tevpool.removePendingEvidence(ev)\n\t\tblockEvidenceMap[evMapKey(ev)] = struct{}{}\n\t}\n\t// We either have no pending evidence or all evidence has expired\n\tif len(blockEvidenceMap) != 0 {\n\t\tevpool.removeEvidenceFromList(blockEvidenceMap)\n\t}\n\treturn evpool.State().LastBlockHeight, evpool.State().LastBlockTime\n}\n\nfunc (evpool *Pool) removeEvidenceFromList(\n\tblockEvidenceMap map[string]struct{}) {\n\n\tfor e := evpool.evidenceList.Front(); e != nil; e = e.Next() {\n\t\t// Remove from clist\n\t\tev := e.Value.(types.Evidence)\n\t\tif _, ok := blockEvidenceMap[evMapKey(ev)]; ok {\n\t\t\tevpool.evidenceList.Remove(e)\n\t\t\te.DetachPrev()\n\t\t}\n\t}\n}\n\nfunc (evpool *Pool) updateState(state sm.State) {\n\tevpool.mtx.Lock()\n\tdefer evpool.mtx.Unlock()\n\tevpool.state = state\n}\n\n// processConsensusBuffer converts all the duplicate votes witnessed from consensus\n// into DuplicateVoteEvidence. It sets the evidence timestamp to the block height\n// from the most recently committed block.\n// Evidence is then added to the pool so as to be ready to be broadcasted and proposed.\nfunc (evpool *Pool) processConsensusBuffer(state sm.State) {\n\tevpool.mtx.Lock()\n\tdefer evpool.mtx.Unlock()\n\tfor _, voteSet := range evpool.consensusBuffer {\n\n\t\t// Check the height of the conflicting votes and fetch the corresponding time and validator set\n\t\t// to produce the valid evidence\n\t\tvar dve *types.DuplicateVoteEvidence\n\t\tswitch {\n\t\tcase voteSet.VoteA.Height == state.LastBlockHeight:\n\t\t\tdve = types.NewDuplicateVoteEvidence(\n\t\t\t\tvoteSet.VoteA,\n\t\t\t\tvoteSet.VoteB,\n\t\t\t\tstate.LastBlockTime,\n\t\t\t\tstate.LastValidators,\n\t\t\t)\n\n\t\tcase voteSet.VoteA.Height < state.LastBlockHeight:\n\t\t\tvalSet, err := evpool.stateDB.LoadValidators(voteSet.VoteA.Height)\n\t\t\tif err != nil {\n\t\t\t\tevpool.logger.Error(\"failed to load validator set for conflicting votes\", \"height\",\n\t\t\t\t\tvoteSet.VoteA.Height, \"err\", err,\n\t\t\t\t)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tblockMeta := evpool.blockStore.LoadBlockMeta(voteSet.VoteA.Height)\n\t\t\tif blockMeta == nil {\n\t\t\t\tevpool.logger.Error(\"failed to load block time for conflicting votes\", \"height\", voteSet.VoteA.Height)\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tdve = types.NewDuplicateVoteEvidence(\n\t\t\t\tvoteSet.VoteA,\n\t\t\t\tvoteSet.VoteB,\n\t\t\t\tblockMeta.Header.Time,\n\t\t\t\tvalSet,\n\t\t\t)\n\n\t\tdefault:\n\t\t\t// evidence pool shouldn't expect to get votes from consensus of a height that is above the current\n\t\t\t// state. If this error is seen then perhaps consider keeping the votes in the buffer and retry\n\t\t\t// in following heights\n\t\t\tevpool.logger.Error(\"inbound duplicate votes from consensus are of a greater height than current state\",\n\t\t\t\t\"duplicate vote height\", voteSet.VoteA.Height,\n\t\t\t\t\"state.LastBlockHeight\", state.LastBlockHeight)\n\t\t\tcontinue\n\t\t}\n\n\t\t// check if we already have this evidence\n\t\tif evpool.isPending(dve) {\n\t\t\tevpool.logger.Debug(\"evidence already pending; ignoring\", \"evidence\", dve)\n\t\t\tcontinue\n\t\t}\n\n\t\t// check that the evidence is not already committed on chain\n\t\tif evpool.isCommitted(dve) {\n\t\t\tevpool.logger.Debug(\"evidence already committed; ignoring\", \"evidence\", dve)\n\t\t\tcontinue\n\t\t}\n\n\t\tif err := evpool.addPendingEvidence(dve); err != nil {\n\t\t\tevpool.logger.Error(\"failed to flush evidence from consensus buffer to pending list: %w\", err)\n\t\t\tcontinue\n\t\t}\n\n\t\tevpool.evidenceList.PushBack(dve)\n\n\t\tevpool.logger.Info(\"verified new evidence of byzantine behavior\", \"evidence\", dve)\n\t}\n\t// reset consensus buffer\n\tevpool.consensusBuffer = make([]duplicateVoteSet, 0)\n}\n\ntype duplicateVoteSet struct {\n\tVoteA *types.Vote\n\tVoteB *types.Vote\n}\n\nfunc bytesToEv(evBytes []byte) (types.Evidence, error) {\n\tvar evpb tmproto.Evidence\n\terr := evpb.Unmarshal(evBytes)\n\tif err != nil {\n\t\treturn &types.DuplicateVoteEvidence{}, err\n\t}\n\n\treturn types.EvidenceFromProto(&evpb)\n}\n\nfunc evMapKey(ev types.Evidence) string {\n\treturn string(ev.Hash())\n}\n\n// big endian padded hex\nfunc bE(h int64) string {\n\treturn fmt.Sprintf(\"%0.16X\", h)\n}\n\nfunc keyCommitted(evidence types.Evidence) []byte {\n\treturn append([]byte{baseKeyCommitted}, keySuffix(evidence)...)\n}\n\nfunc keyPending(evidence types.Evidence) []byte {\n\treturn append([]byte{baseKeyPending}, keySuffix(evidence)...)\n}\n\nfunc keySuffix(evidence types.Evidence) []byte {\n\treturn []byte(fmt.Sprintf(\"%s/%X\", bE(evidence.Height()), evidence.Hash()))\n}\n", "package evidence_test\n\nimport (\n\t\"os\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/mock\"\n\t\"github.com/stretchr/testify/require\"\n\n\tdbm \"github.com/tendermint/tm-db\"\n\n\t\"github.com/tendermint/tendermint/evidence\"\n\t\"github.com/tendermint/tendermint/evidence/mocks\"\n\t\"github.com/tendermint/tendermint/libs/log\"\n\ttmproto \"github.com/tendermint/tendermint/proto/tendermint/types\"\n\ttmversion \"github.com/tendermint/tendermint/proto/tendermint/version\"\n\tsm \"github.com/tendermint/tendermint/state\"\n\tsmmocks \"github.com/tendermint/tendermint/state/mocks\"\n\t\"github.com/tendermint/tendermint/store\"\n\t\"github.com/tendermint/tendermint/types\"\n\t\"github.com/tendermint/tendermint/version\"\n)\n\nfunc TestMain(m *testing.M) {\n\n\tcode := m.Run()\n\tos.Exit(code)\n}\n\nconst evidenceChainID = \"test_chain\"\n\nvar (\n\tdefaultEvidenceTime           = time.Date(2019, 1, 1, 0, 0, 0, 0, time.UTC)\n\tdefaultEvidenceMaxBytes int64 = 1000\n)\n\nfunc TestEvidencePoolBasic(t *testing.T) {\n\tvar (\n\t\theight     = int64(1)\n\t\tstateStore = &smmocks.Store{}\n\t\tevidenceDB = dbm.NewMemDB()\n\t\tblockStore = &mocks.BlockStore{}\n\t)\n\n\tvalSet, privVals := types.RandValidatorSet(1, 10)\n\n\tblockStore.On(\"LoadBlockMeta\", mock.AnythingOfType(\"int64\")).Return(\n\t\t&types.BlockMeta{Header: types.Header{Time: defaultEvidenceTime}},\n\t)\n\tstateStore.On(\"LoadValidators\", mock.AnythingOfType(\"int64\")).Return(valSet, nil)\n\tstateStore.On(\"Load\").Return(createState(height+1, valSet), nil)\n\n\tpool, err := evidence.NewPool(evidenceDB, stateStore, blockStore)\n\trequire.NoError(t, err)\n\tpool.SetLogger(log.TestingLogger())\n\n\t// evidence not seen yet:\n\tevs, size := pool.PendingEvidence(defaultEvidenceMaxBytes)\n\tassert.Equal(t, 0, len(evs))\n\tassert.Zero(t, size)\n\n\tev := types.NewMockDuplicateVoteEvidenceWithValidator(height, defaultEvidenceTime, privVals[0], evidenceChainID)\n\n\t// good evidence\n\tevAdded := make(chan struct{})\n\tgo func() {\n\t\t<-pool.EvidenceWaitChan()\n\t\tclose(evAdded)\n\t}()\n\n\t// evidence seen but not yet committed:\n\tassert.NoError(t, pool.AddEvidence(ev))\n\n\tselect {\n\tcase <-evAdded:\n\tcase <-time.After(5 * time.Second):\n\t\tt.Fatal(\"evidence was not added to list after 5s\")\n\t}\n\n\tnext := pool.EvidenceFront()\n\tassert.Equal(t, ev, next.Value.(types.Evidence))\n\n\tconst evidenceBytes int64 = 372\n\tevs, size = pool.PendingEvidence(evidenceBytes)\n\tassert.Equal(t, 1, len(evs))\n\tassert.Equal(t, evidenceBytes, size) // check that the size of the single evidence in bytes is correct\n\n\t// shouldn't be able to add evidence twice\n\tassert.NoError(t, pool.AddEvidence(ev))\n\tevs, _ = pool.PendingEvidence(defaultEvidenceMaxBytes)\n\tassert.Equal(t, 1, len(evs))\n\n}\n\n// Tests inbound evidence for the right time and height\nfunc TestAddExpiredEvidence(t *testing.T) {\n\tvar (\n\t\tval                 = types.NewMockPV()\n\t\theight              = int64(30)\n\t\tstateStore          = initializeValidatorState(val, height)\n\t\tevidenceDB          = dbm.NewMemDB()\n\t\tblockStore          = &mocks.BlockStore{}\n\t\texpiredEvidenceTime = time.Date(2018, 1, 1, 0, 0, 0, 0, time.UTC)\n\t\texpiredHeight       = int64(2)\n\t)\n\n\tblockStore.On(\"LoadBlockMeta\", mock.AnythingOfType(\"int64\")).Return(func(h int64) *types.BlockMeta {\n\t\tif h == height || h == expiredHeight {\n\t\t\treturn &types.BlockMeta{Header: types.Header{Time: defaultEvidenceTime}}\n\t\t}\n\t\treturn &types.BlockMeta{Header: types.Header{Time: expiredEvidenceTime}}\n\t})\n\n\tpool, err := evidence.NewPool(evidenceDB, stateStore, blockStore)\n\trequire.NoError(t, err)\n\n\ttestCases := []struct {\n\t\tevHeight      int64\n\t\tevTime        time.Time\n\t\texpErr        bool\n\t\tevDescription string\n\t}{\n\t\t{height, defaultEvidenceTime, false, \"valid evidence\"},\n\t\t{expiredHeight, defaultEvidenceTime, false, \"valid evidence (despite old height)\"},\n\t\t{height - 1, expiredEvidenceTime, false, \"valid evidence (despite old time)\"},\n\t\t{expiredHeight - 1, expiredEvidenceTime, true,\n\t\t\t\"evidence from height 1 (created at: 2019-01-01 00:00:00 +0000 UTC) is too old\"},\n\t\t{height, defaultEvidenceTime.Add(1 * time.Minute), true, \"evidence time and block time is different\"},\n\t}\n\n\tfor _, tc := range testCases {\n\t\ttc := tc\n\t\tt.Run(tc.evDescription, func(t *testing.T) {\n\t\t\tev := types.NewMockDuplicateVoteEvidenceWithValidator(tc.evHeight, tc.evTime, val, evidenceChainID)\n\t\t\terr := pool.AddEvidence(ev)\n\t\t\tif tc.expErr {\n\t\t\t\tassert.Error(t, err)\n\t\t\t} else {\n\t\t\t\tassert.NoError(t, err)\n\t\t\t}\n\t\t})\n\t}\n}\n\nfunc TestReportConflictingVotes(t *testing.T) {\n\tvar height int64 = 10\n\n\tpool, pv := defaultTestPool(height)\n\tval := types.NewValidator(pv.PrivKey.PubKey(), 10)\n\tev := types.NewMockDuplicateVoteEvidenceWithValidator(height+1, defaultEvidenceTime, pv, evidenceChainID)\n\n\tpool.ReportConflictingVotes(ev.VoteA, ev.VoteB)\n\n\t// shouldn't be able to submit the same evidence twice\n\tpool.ReportConflictingVotes(ev.VoteA, ev.VoteB)\n\n\t// evidence from consensus should not be added immediately but reside in the consensus buffer\n\tevList, evSize := pool.PendingEvidence(defaultEvidenceMaxBytes)\n\trequire.Empty(t, evList)\n\trequire.Zero(t, evSize)\n\n\tnext := pool.EvidenceFront()\n\trequire.Nil(t, next)\n\n\t// move to next height and update state and evidence pool\n\tstate := pool.State()\n\tstate.LastBlockHeight++\n\tstate.LastBlockTime = ev.Time()\n\tstate.LastValidators = types.NewValidatorSet([]*types.Validator{val})\n\tpool.Update(state, []types.Evidence{})\n\n\t// should be able to retrieve evidence from pool\n\tevList, _ = pool.PendingEvidence(defaultEvidenceMaxBytes)\n\trequire.Equal(t, []types.Evidence{ev}, evList)\n}\n\nfunc TestEvidencePoolUpdate(t *testing.T) {\n\theight := int64(21)\n\tpool, val := defaultTestPool(height)\n\tstate := pool.State()\n\n\t// create new block (no need to save it to blockStore)\n\tprunedEv := types.NewMockDuplicateVoteEvidenceWithValidator(1, defaultEvidenceTime.Add(1*time.Minute),\n\t\tval, evidenceChainID)\n\terr := pool.AddEvidence(prunedEv)\n\trequire.NoError(t, err)\n\tev := types.NewMockDuplicateVoteEvidenceWithValidator(height, defaultEvidenceTime.Add(21*time.Minute),\n\t\tval, evidenceChainID)\n\tlastCommit := makeCommit(height, val.PrivKey.PubKey().Address())\n\tblock := types.MakeBlock(height+1, []types.Tx{}, lastCommit, []types.Evidence{ev})\n\t// update state (partially)\n\tstate.LastBlockHeight = height + 1\n\tstate.LastBlockTime = defaultEvidenceTime.Add(22 * time.Minute)\n\terr = pool.CheckEvidence(types.EvidenceList{ev})\n\trequire.NoError(t, err)\n\n\tpool.Update(state, block.Evidence.Evidence)\n\t// a) Update marks evidence as committed so pending evidence should be empty\n\tevList, evSize := pool.PendingEvidence(defaultEvidenceMaxBytes)\n\tassert.Empty(t, evList)\n\tassert.Zero(t, evSize)\n\n\t// b) If we try to check this evidence again it should fail because it has already been committed\n\terr = pool.CheckEvidence(types.EvidenceList{ev})\n\tif assert.Error(t, err) {\n\t\tassert.Equal(t, \"evidence was already committed\", err.(*types.ErrInvalidEvidence).Reason.Error())\n\t}\n}\n\nfunc TestVerifyPendingEvidencePasses(t *testing.T) {\n\tvar height int64 = 1\n\tpool, val := defaultTestPool(height)\n\tev := types.NewMockDuplicateVoteEvidenceWithValidator(height, defaultEvidenceTime.Add(1*time.Minute),\n\t\tval, evidenceChainID)\n\terr := pool.AddEvidence(ev)\n\trequire.NoError(t, err)\n\n\terr = pool.CheckEvidence(types.EvidenceList{ev})\n\tassert.NoError(t, err)\n}\n\nfunc TestVerifyDuplicatedEvidenceFails(t *testing.T) {\n\tvar height int64 = 1\n\tpool, val := defaultTestPool(height)\n\tev := types.NewMockDuplicateVoteEvidenceWithValidator(height, defaultEvidenceTime.Add(1*time.Minute),\n\t\tval, evidenceChainID)\n\terr := pool.CheckEvidence(types.EvidenceList{ev, ev})\n\tif assert.Error(t, err) {\n\t\tassert.Equal(t, \"duplicate evidence\", err.(*types.ErrInvalidEvidence).Reason.Error())\n\t}\n}\n\n// check that valid light client evidence is correctly validated and stored in\n// evidence pool\nfunc TestCheckEvidenceWithLightClientAttack(t *testing.T) {\n\tvar (\n\t\tnValidators          = 5\n\t\tvalidatorPower int64 = 10\n\t\theight         int64 = 10\n\t)\n\tconflictingVals, conflictingPrivVals := types.RandValidatorSet(nValidators, validatorPower)\n\ttrustedHeader := makeHeaderRandom(height)\n\ttrustedHeader.Time = defaultEvidenceTime\n\n\tconflictingHeader := makeHeaderRandom(height)\n\tconflictingHeader.ValidatorsHash = conflictingVals.Hash()\n\n\ttrustedHeader.ValidatorsHash = conflictingHeader.ValidatorsHash\n\ttrustedHeader.NextValidatorsHash = conflictingHeader.NextValidatorsHash\n\ttrustedHeader.ConsensusHash = conflictingHeader.ConsensusHash\n\ttrustedHeader.AppHash = conflictingHeader.AppHash\n\ttrustedHeader.LastResultsHash = conflictingHeader.LastResultsHash\n\n\t// for simplicity we are simulating a duplicate vote attack where all the validators in the\n\t// conflictingVals set voted twice\n\tblockID := makeBlockID(conflictingHeader.Hash(), 1000, []byte(\"partshash\"))\n\tvoteSet := types.NewVoteSet(evidenceChainID, height, 1, tmproto.SignedMsgType(2), conflictingVals)\n\tcommit, err := types.MakeCommit(blockID, height, 1, voteSet, conflictingPrivVals, defaultEvidenceTime)\n\trequire.NoError(t, err)\n\tev := &types.LightClientAttackEvidence{\n\t\tConflictingBlock: &types.LightBlock{\n\t\t\tSignedHeader: &types.SignedHeader{\n\t\t\t\tHeader: conflictingHeader,\n\t\t\t\tCommit: commit,\n\t\t\t},\n\t\t\tValidatorSet: conflictingVals,\n\t\t},\n\t\tCommonHeight:        10,\n\t\tTotalVotingPower:    int64(nValidators) * validatorPower,\n\t\tByzantineValidators: conflictingVals.Validators,\n\t\tTimestamp:           defaultEvidenceTime,\n\t}\n\n\ttrustedBlockID := makeBlockID(trustedHeader.Hash(), 1000, []byte(\"partshash\"))\n\ttrustedVoteSet := types.NewVoteSet(evidenceChainID, height, 1, tmproto.SignedMsgType(2), conflictingVals)\n\ttrustedCommit, err := types.MakeCommit(trustedBlockID, height, 1, trustedVoteSet, conflictingPrivVals,\n\t\tdefaultEvidenceTime)\n\trequire.NoError(t, err)\n\n\tstate := sm.State{\n\t\tLastBlockTime:   defaultEvidenceTime.Add(1 * time.Minute),\n\t\tLastBlockHeight: 11,\n\t\tConsensusParams: *types.DefaultConsensusParams(),\n\t}\n\tstateStore := &smmocks.Store{}\n\tstateStore.On(\"LoadValidators\", height).Return(conflictingVals, nil)\n\tstateStore.On(\"Load\").Return(state, nil)\n\tblockStore := &mocks.BlockStore{}\n\tblockStore.On(\"LoadBlockMeta\", height).Return(&types.BlockMeta{Header: *trustedHeader})\n\tblockStore.On(\"LoadBlockCommit\", height).Return(trustedCommit)\n\n\tpool, err := evidence.NewPool(dbm.NewMemDB(), stateStore, blockStore)\n\trequire.NoError(t, err)\n\tpool.SetLogger(log.TestingLogger())\n\n\terr = pool.AddEvidence(ev)\n\tassert.NoError(t, err)\n\n\terr = pool.CheckEvidence(types.EvidenceList{ev})\n\tassert.NoError(t, err)\n\n\t// take away the last signature -> there are less validators then what we have detected,\n\t// hence this should fail\n\tcommit.Signatures = append(commit.Signatures[:nValidators-1], types.NewCommitSigAbsent())\n\terr = pool.CheckEvidence(types.EvidenceList{ev})\n\tassert.Error(t, err)\n}\n\n// Tests that restarting the evidence pool after a potential failure will recover the\n// pending evidence and continue to gossip it\nfunc TestRecoverPendingEvidence(t *testing.T) {\n\theight := int64(10)\n\tval := types.NewMockPV()\n\tvalAddress := val.PrivKey.PubKey().Address()\n\tevidenceDB := dbm.NewMemDB()\n\tstateStore := initializeValidatorState(val, height)\n\tstate, err := stateStore.Load()\n\trequire.NoError(t, err)\n\tblockStore := initializeBlockStore(dbm.NewMemDB(), state, valAddress)\n\t// create previous pool and populate it\n\tpool, err := evidence.NewPool(evidenceDB, stateStore, blockStore)\n\trequire.NoError(t, err)\n\tpool.SetLogger(log.TestingLogger())\n\tgoodEvidence := types.NewMockDuplicateVoteEvidenceWithValidator(height,\n\t\tdefaultEvidenceTime.Add(10*time.Minute), val, evidenceChainID)\n\texpiredEvidence := types.NewMockDuplicateVoteEvidenceWithValidator(int64(1),\n\t\tdefaultEvidenceTime.Add(1*time.Minute), val, evidenceChainID)\n\terr = pool.AddEvidence(goodEvidence)\n\trequire.NoError(t, err)\n\terr = pool.AddEvidence(expiredEvidence)\n\trequire.NoError(t, err)\n\n\t// now recover from the previous pool at a different time\n\tnewStateStore := &smmocks.Store{}\n\tnewStateStore.On(\"Load\").Return(sm.State{\n\t\tLastBlockTime:   defaultEvidenceTime.Add(25 * time.Minute),\n\t\tLastBlockHeight: height + 15,\n\t\tConsensusParams: tmproto.ConsensusParams{\n\t\t\tBlock: tmproto.BlockParams{\n\t\t\t\tMaxBytes: 22020096,\n\t\t\t\tMaxGas:   -1,\n\t\t\t},\n\t\t\tEvidence: tmproto.EvidenceParams{\n\t\t\t\tMaxAgeNumBlocks: 20,\n\t\t\t\tMaxAgeDuration:  20 * time.Minute,\n\t\t\t\tMaxBytes:        1000,\n\t\t\t},\n\t\t},\n\t}, nil)\n\tnewPool, err := evidence.NewPool(evidenceDB, newStateStore, blockStore)\n\tassert.NoError(t, err)\n\tevList, _ := newPool.PendingEvidence(defaultEvidenceMaxBytes)\n\tassert.Equal(t, 1, len(evList))\n\tnext := newPool.EvidenceFront()\n\tassert.Equal(t, goodEvidence, next.Value.(types.Evidence))\n\n}\n\nfunc initializeStateFromValidatorSet(valSet *types.ValidatorSet, height int64) sm.Store {\n\tstateDB := dbm.NewMemDB()\n\tstateStore := sm.NewStore(stateDB)\n\tstate := sm.State{\n\t\tChainID:                     evidenceChainID,\n\t\tInitialHeight:               1,\n\t\tLastBlockHeight:             height,\n\t\tLastBlockTime:               defaultEvidenceTime,\n\t\tValidators:                  valSet,\n\t\tNextValidators:              valSet.CopyIncrementProposerPriority(1),\n\t\tLastValidators:              valSet,\n\t\tLastHeightValidatorsChanged: 1,\n\t\tConsensusParams: tmproto.ConsensusParams{\n\t\t\tBlock: tmproto.BlockParams{\n\t\t\t\tMaxBytes: 22020096,\n\t\t\t\tMaxGas:   -1,\n\t\t\t},\n\t\t\tEvidence: tmproto.EvidenceParams{\n\t\t\t\tMaxAgeNumBlocks: 20,\n\t\t\t\tMaxAgeDuration:  20 * time.Minute,\n\t\t\t\tMaxBytes:        1000,\n\t\t\t},\n\t\t},\n\t}\n\n\t// save all states up to height\n\tfor i := int64(0); i <= height; i++ {\n\t\tstate.LastBlockHeight = i\n\t\tif err := stateStore.Save(state); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\n\treturn stateStore\n}\n\nfunc initializeValidatorState(privVal types.PrivValidator, height int64) sm.Store {\n\n\tpubKey, _ := privVal.GetPubKey()\n\tvalidator := &types.Validator{Address: pubKey.Address(), VotingPower: 10, PubKey: pubKey}\n\n\t// create validator set and state\n\tvalSet := &types.ValidatorSet{\n\t\tValidators: []*types.Validator{validator},\n\t\tProposer:   validator,\n\t}\n\n\treturn initializeStateFromValidatorSet(valSet, height)\n}\n\n// initializeBlockStore creates a block storage and populates it w/ a dummy\n// block at +height+.\nfunc initializeBlockStore(db dbm.DB, state sm.State, valAddr []byte) *store.BlockStore {\n\tblockStore := store.NewBlockStore(db)\n\n\tfor i := int64(1); i <= state.LastBlockHeight; i++ {\n\t\tlastCommit := makeCommit(i-1, valAddr)\n\t\tblock, _ := state.MakeBlock(i, []types.Tx{}, lastCommit, nil,\n\t\t\tstate.Validators.GetProposer().Address)\n\t\tblock.Header.Time = defaultEvidenceTime.Add(time.Duration(i) * time.Minute)\n\t\tblock.Header.Version = tmversion.Consensus{Block: version.BlockProtocol, App: 1}\n\t\tconst parts = 1\n\t\tpartSet := block.MakePartSet(parts)\n\n\t\tseenCommit := makeCommit(i, valAddr)\n\t\tblockStore.SaveBlock(block, partSet, seenCommit)\n\t}\n\n\treturn blockStore\n}\n\nfunc makeCommit(height int64, valAddr []byte) *types.Commit {\n\tcommitSigs := []types.CommitSig{{\n\t\tBlockIDFlag:      types.BlockIDFlagCommit,\n\t\tValidatorAddress: valAddr,\n\t\tTimestamp:        defaultEvidenceTime,\n\t\tSignature:        []byte(\"Signature\"),\n\t}}\n\treturn types.NewCommit(height, 0, types.BlockID{}, commitSigs)\n}\n\nfunc defaultTestPool(height int64) (*evidence.Pool, types.MockPV) {\n\tval := types.NewMockPV()\n\tvalAddress := val.PrivKey.PubKey().Address()\n\tevidenceDB := dbm.NewMemDB()\n\tstateStore := initializeValidatorState(val, height)\n\tstate, _ := stateStore.Load()\n\tblockStore := initializeBlockStore(dbm.NewMemDB(), state, valAddress)\n\tpool, err := evidence.NewPool(evidenceDB, stateStore, blockStore)\n\tif err != nil {\n\t\tpanic(\"test evidence pool could not be created\")\n\t}\n\tpool.SetLogger(log.TestingLogger())\n\treturn pool, val\n}\n\nfunc createState(height int64, valSet *types.ValidatorSet) sm.State {\n\treturn sm.State{\n\t\tChainID:         evidenceChainID,\n\t\tLastBlockHeight: height,\n\t\tLastBlockTime:   defaultEvidenceTime,\n\t\tValidators:      valSet,\n\t\tConsensusParams: *types.DefaultConsensusParams(),\n\t}\n}\n", "package node\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"net\"\n\t\"os\"\n\t\"syscall\"\n\t\"testing\"\n\t\"time\"\n\n\t\"github.com/stretchr/testify/assert\"\n\t\"github.com/stretchr/testify/require\"\n\n\tdbm \"github.com/tendermint/tm-db\"\n\n\t\"github.com/tendermint/tendermint/abci/example/kvstore\"\n\tcfg \"github.com/tendermint/tendermint/config\"\n\t\"github.com/tendermint/tendermint/crypto/ed25519\"\n\t\"github.com/tendermint/tendermint/evidence\"\n\t\"github.com/tendermint/tendermint/libs/log\"\n\ttmrand \"github.com/tendermint/tendermint/libs/rand\"\n\tmempl \"github.com/tendermint/tendermint/mempool\"\n\t\"github.com/tendermint/tendermint/p2p\"\n\tp2pmock \"github.com/tendermint/tendermint/p2p/mock\"\n\t\"github.com/tendermint/tendermint/privval\"\n\t\"github.com/tendermint/tendermint/proxy\"\n\tsm \"github.com/tendermint/tendermint/state\"\n\t\"github.com/tendermint/tendermint/store\"\n\t\"github.com/tendermint/tendermint/types\"\n\ttmtime \"github.com/tendermint/tendermint/types/time\"\n)\n\nfunc TestNodeStartStop(t *testing.T) {\n\tconfig := cfg.ResetTestRoot(\"node_node_test\")\n\tdefer os.RemoveAll(config.RootDir)\n\n\t// create & start node\n\tn, err := DefaultNewNode(config, log.TestingLogger())\n\trequire.NoError(t, err)\n\terr = n.Start()\n\trequire.NoError(t, err)\n\n\tt.Logf(\"Started node %v\", n.sw.NodeInfo())\n\n\t// wait for the node to produce a block\n\tblocksSub, err := n.EventBus().Subscribe(context.Background(), \"node_test\", types.EventQueryNewBlock)\n\trequire.NoError(t, err)\n\tselect {\n\tcase <-blocksSub.Out():\n\tcase <-blocksSub.Cancelled():\n\t\tt.Fatal(\"blocksSub was cancelled\")\n\tcase <-time.After(10 * time.Second):\n\t\tt.Fatal(\"timed out waiting for the node to produce a block\")\n\t}\n\n\t// stop the node\n\tgo func() {\n\t\terr = n.Stop()\n\t\trequire.NoError(t, err)\n\t}()\n\n\tselect {\n\tcase <-n.Quit():\n\tcase <-time.After(5 * time.Second):\n\t\tpid := os.Getpid()\n\t\tp, err := os.FindProcess(pid)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t\terr = p.Signal(syscall.SIGABRT)\n\t\tfmt.Println(err)\n\t\tt.Fatal(\"timed out waiting for shutdown\")\n\t}\n}\n\nfunc TestSplitAndTrimEmpty(t *testing.T) {\n\ttestCases := []struct {\n\t\ts        string\n\t\tsep      string\n\t\tcutset   string\n\t\texpected []string\n\t}{\n\t\t{\"a,b,c\", \",\", \" \", []string{\"a\", \"b\", \"c\"}},\n\t\t{\" a , b , c \", \",\", \" \", []string{\"a\", \"b\", \"c\"}},\n\t\t{\" a, b, c \", \",\", \" \", []string{\"a\", \"b\", \"c\"}},\n\t\t{\" a, \", \",\", \" \", []string{\"a\"}},\n\t\t{\"   \", \",\", \" \", []string{}},\n\t}\n\n\tfor _, tc := range testCases {\n\t\tassert.Equal(t, tc.expected, splitAndTrimEmpty(tc.s, tc.sep, tc.cutset), \"%s\", tc.s)\n\t}\n}\n\nfunc TestNodeDelayedStart(t *testing.T) {\n\tconfig := cfg.ResetTestRoot(\"node_delayed_start_test\")\n\tdefer os.RemoveAll(config.RootDir)\n\tnow := tmtime.Now()\n\n\t// create & start node\n\tn, err := DefaultNewNode(config, log.TestingLogger())\n\tn.GenesisDoc().GenesisTime = now.Add(2 * time.Second)\n\trequire.NoError(t, err)\n\n\terr = n.Start()\n\trequire.NoError(t, err)\n\tdefer n.Stop() //nolint:errcheck // ignore for tests\n\n\tstartTime := tmtime.Now()\n\tassert.Equal(t, true, startTime.After(n.GenesisDoc().GenesisTime))\n}\n\nfunc TestNodeSetAppVersion(t *testing.T) {\n\tconfig := cfg.ResetTestRoot(\"node_app_version_test\")\n\tdefer os.RemoveAll(config.RootDir)\n\n\t// create & start node\n\tn, err := DefaultNewNode(config, log.TestingLogger())\n\trequire.NoError(t, err)\n\n\t// default config uses the kvstore app\n\tvar appVersion uint64 = kvstore.ProtocolVersion\n\n\t// check version is set in state\n\tstate, err := n.stateStore.Load()\n\trequire.NoError(t, err)\n\tassert.Equal(t, state.Version.Consensus.App, appVersion)\n\n\t// check version is set in node info\n\tassert.Equal(t, n.nodeInfo.(p2p.DefaultNodeInfo).ProtocolVersion.App, appVersion)\n}\n\nfunc TestNodeSetPrivValTCP(t *testing.T) {\n\taddr := \"tcp://\" + testFreeAddr(t)\n\n\tconfig := cfg.ResetTestRoot(\"node_priv_val_tcp_test\")\n\tdefer os.RemoveAll(config.RootDir)\n\tconfig.BaseConfig.PrivValidatorListenAddr = addr\n\n\tdialer := privval.DialTCPFn(addr, 100*time.Millisecond, ed25519.GenPrivKey())\n\tdialerEndpoint := privval.NewSignerDialerEndpoint(\n\t\tlog.TestingLogger(),\n\t\tdialer,\n\t)\n\tprivval.SignerDialerEndpointTimeoutReadWrite(100 * time.Millisecond)(dialerEndpoint)\n\n\tsignerServer := privval.NewSignerServer(\n\t\tdialerEndpoint,\n\t\tconfig.ChainID(),\n\t\ttypes.NewMockPV(),\n\t)\n\n\tgo func() {\n\t\terr := signerServer.Start()\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}()\n\tdefer signerServer.Stop() //nolint:errcheck // ignore for tests\n\n\tn, err := DefaultNewNode(config, log.TestingLogger())\n\trequire.NoError(t, err)\n\tassert.IsType(t, &privval.RetrySignerClient{}, n.PrivValidator())\n}\n\n// address without a protocol must result in error\nfunc TestPrivValidatorListenAddrNoProtocol(t *testing.T) {\n\taddrNoPrefix := testFreeAddr(t)\n\n\tconfig := cfg.ResetTestRoot(\"node_priv_val_tcp_test\")\n\tdefer os.RemoveAll(config.RootDir)\n\tconfig.BaseConfig.PrivValidatorListenAddr = addrNoPrefix\n\n\t_, err := DefaultNewNode(config, log.TestingLogger())\n\tassert.Error(t, err)\n}\n\nfunc TestNodeSetPrivValIPC(t *testing.T) {\n\ttmpfile := \"/tmp/kms.\" + tmrand.Str(6) + \".sock\"\n\tdefer os.Remove(tmpfile) // clean up\n\n\tconfig := cfg.ResetTestRoot(\"node_priv_val_tcp_test\")\n\tdefer os.RemoveAll(config.RootDir)\n\tconfig.BaseConfig.PrivValidatorListenAddr = \"unix://\" + tmpfile\n\n\tdialer := privval.DialUnixFn(tmpfile)\n\tdialerEndpoint := privval.NewSignerDialerEndpoint(\n\t\tlog.TestingLogger(),\n\t\tdialer,\n\t)\n\tprivval.SignerDialerEndpointTimeoutReadWrite(100 * time.Millisecond)(dialerEndpoint)\n\n\tpvsc := privval.NewSignerServer(\n\t\tdialerEndpoint,\n\t\tconfig.ChainID(),\n\t\ttypes.NewMockPV(),\n\t)\n\n\tgo func() {\n\t\terr := pvsc.Start()\n\t\trequire.NoError(t, err)\n\t}()\n\tdefer pvsc.Stop() //nolint:errcheck // ignore for tests\n\n\tn, err := DefaultNewNode(config, log.TestingLogger())\n\trequire.NoError(t, err)\n\tassert.IsType(t, &privval.RetrySignerClient{}, n.PrivValidator())\n}\n\n// testFreeAddr claims a free port so we don't block on listener being ready.\nfunc testFreeAddr(t *testing.T) string {\n\tln, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n\trequire.NoError(t, err)\n\tdefer ln.Close()\n\n\treturn fmt.Sprintf(\"127.0.0.1:%d\", ln.Addr().(*net.TCPAddr).Port)\n}\n\n// create a proposal block using real and full\n// mempool and evidence pool and validate it.\nfunc TestCreateProposalBlock(t *testing.T) {\n\tconfig := cfg.ResetTestRoot(\"node_create_proposal\")\n\tdefer os.RemoveAll(config.RootDir)\n\tcc := proxy.NewLocalClientCreator(kvstore.NewApplication())\n\tproxyApp := proxy.NewAppConns(cc)\n\terr := proxyApp.Start()\n\trequire.Nil(t, err)\n\tdefer proxyApp.Stop() //nolint:errcheck // ignore for tests\n\n\tlogger := log.TestingLogger()\n\n\tvar height int64 = 1\n\tstate, stateDB, privVals := state(1, height)\n\tstateStore := sm.NewStore(stateDB)\n\tmaxBytes := 16384\n\tvar partSize uint32 = 256\n\tmaxEvidenceBytes := int64(maxBytes / 2)\n\tstate.ConsensusParams.Block.MaxBytes = int64(maxBytes)\n\tstate.ConsensusParams.Evidence.MaxBytes = maxEvidenceBytes\n\tproposerAddr, _ := state.Validators.GetByIndex(0)\n\n\t// Make Mempool\n\tmemplMetrics := mempl.PrometheusMetrics(\"node_test_1\")\n\tmempool := mempl.NewCListMempool(\n\t\tconfig.Mempool,\n\t\tproxyApp.Mempool(),\n\t\tstate.LastBlockHeight,\n\t\tmempl.WithMetrics(memplMetrics),\n\t\tmempl.WithPreCheck(sm.TxPreCheck(state)),\n\t\tmempl.WithPostCheck(sm.TxPostCheck(state)),\n\t)\n\tmempool.SetLogger(logger)\n\n\t// Make EvidencePool\n\tevidenceDB := dbm.NewMemDB()\n\tblockStore := store.NewBlockStore(dbm.NewMemDB())\n\tevidencePool, err := evidence.NewPool(evidenceDB, stateStore, blockStore)\n\trequire.NoError(t, err)\n\tevidencePool.SetLogger(logger)\n\n\t// fill the evidence pool with more evidence\n\t// than can fit in a block\n\tvar currentBytes int64 = 0\n\tfor currentBytes <= maxEvidenceBytes {\n\t\tev := types.NewMockDuplicateVoteEvidenceWithValidator(height, time.Now(), privVals[0], \"test-chain\")\n\t\tcurrentBytes += int64(len(ev.Bytes()))\n\t\tevidencePool.ReportConflictingVotes(ev.VoteA, ev.VoteB)\n\t}\n\n\tevList, size := evidencePool.PendingEvidence(state.ConsensusParams.Evidence.MaxBytes)\n\trequire.Less(t, size, state.ConsensusParams.Evidence.MaxBytes+1)\n\tevData := &types.EvidenceData{Evidence: evList}\n\trequire.EqualValues(t, size, evData.ByteSize())\n\n\t// fill the mempool with more txs\n\t// than can fit in a block\n\ttxLength := 100\n\tfor i := 0; i <= maxBytes/txLength; i++ {\n\t\ttx := tmrand.Bytes(txLength)\n\t\terr := mempool.CheckTx(tx, nil, mempl.TxInfo{})\n\t\tassert.NoError(t, err)\n\t}\n\n\tblockExec := sm.NewBlockExecutor(\n\t\tstateStore,\n\t\tlogger,\n\t\tproxyApp.Consensus(),\n\t\tmempool,\n\t\tevidencePool,\n\t)\n\n\tcommit := types.NewCommit(height-1, 0, types.BlockID{}, nil)\n\tblock, _ := blockExec.CreateProposalBlock(\n\t\theight,\n\t\tstate, commit,\n\t\tproposerAddr,\n\t)\n\n\t// check that the part set does not exceed the maximum block size\n\tpartSet := block.MakePartSet(partSize)\n\tassert.Less(t, partSet.ByteSize(), int64(maxBytes))\n\n\tpartSetFromHeader := types.NewPartSetFromHeader(partSet.Header())\n\tfor partSetFromHeader.Count() < partSetFromHeader.Total() {\n\t\tadded, err := partSetFromHeader.AddPart(partSet.GetPart(int(partSetFromHeader.Count())))\n\t\trequire.NoError(t, err)\n\t\trequire.True(t, added)\n\t}\n\tassert.EqualValues(t, partSetFromHeader.ByteSize(), partSet.ByteSize())\n\n\terr = blockExec.ValidateBlock(state, block)\n\tassert.NoError(t, err)\n}\n\nfunc TestMaxProposalBlockSize(t *testing.T) {\n\tconfig := cfg.ResetTestRoot(\"node_create_proposal\")\n\tdefer os.RemoveAll(config.RootDir)\n\tcc := proxy.NewLocalClientCreator(kvstore.NewApplication())\n\tproxyApp := proxy.NewAppConns(cc)\n\terr := proxyApp.Start()\n\trequire.Nil(t, err)\n\tdefer proxyApp.Stop() //nolint:errcheck // ignore for tests\n\n\tlogger := log.TestingLogger()\n\n\tvar height int64 = 1\n\tstate, stateDB, _ := state(1, height)\n\tstateStore := sm.NewStore(stateDB)\n\tvar maxBytes int64 = 16384\n\tvar partSize uint32 = 256\n\tstate.ConsensusParams.Block.MaxBytes = maxBytes\n\tproposerAddr, _ := state.Validators.GetByIndex(0)\n\n\t// Make Mempool\n\tmemplMetrics := mempl.PrometheusMetrics(\"node_test_2\")\n\tmempool := mempl.NewCListMempool(\n\t\tconfig.Mempool,\n\t\tproxyApp.Mempool(),\n\t\tstate.LastBlockHeight,\n\t\tmempl.WithMetrics(memplMetrics),\n\t\tmempl.WithPreCheck(sm.TxPreCheck(state)),\n\t\tmempl.WithPostCheck(sm.TxPostCheck(state)),\n\t)\n\tmempool.SetLogger(logger)\n\n\t// fill the mempool with one txs just below the maximum size\n\ttxLength := int(types.MaxDataBytesNoEvidence(maxBytes, 1))\n\ttx := tmrand.Bytes(txLength - 4) // to account for the varint\n\terr = mempool.CheckTx(tx, nil, mempl.TxInfo{})\n\tassert.NoError(t, err)\n\n\tblockExec := sm.NewBlockExecutor(\n\t\tstateStore,\n\t\tlogger,\n\t\tproxyApp.Consensus(),\n\t\tmempool,\n\t\tsm.EmptyEvidencePool{},\n\t)\n\n\tcommit := types.NewCommit(height-1, 0, types.BlockID{}, nil)\n\tblock, _ := blockExec.CreateProposalBlock(\n\t\theight,\n\t\tstate, commit,\n\t\tproposerAddr,\n\t)\n\n\tpb, err := block.ToProto()\n\trequire.NoError(t, err)\n\tassert.Less(t, int64(pb.Size()), maxBytes)\n\n\t// check that the part set does not exceed the maximum block size\n\tpartSet := block.MakePartSet(partSize)\n\tassert.EqualValues(t, partSet.ByteSize(), int64(pb.Size()))\n}\n\nfunc TestNodeNewNodeCustomReactors(t *testing.T) {\n\tconfig := cfg.ResetTestRoot(\"node_new_node_custom_reactors_test\")\n\tdefer os.RemoveAll(config.RootDir)\n\n\tcr := p2pmock.NewReactor()\n\tcustomBlockchainReactor := p2pmock.NewReactor()\n\n\tnodeKey, err := p2p.LoadOrGenNodeKey(config.NodeKeyFile())\n\trequire.NoError(t, err)\n\n\tn, err := NewNode(config,\n\t\tprivval.LoadOrGenFilePV(config.PrivValidatorKeyFile(), config.PrivValidatorStateFile()),\n\t\tnodeKey,\n\t\tproxy.DefaultClientCreator(config.ProxyApp, config.ABCI, config.DBDir()),\n\t\tDefaultGenesisDocProviderFunc(config),\n\t\tDefaultDBProvider,\n\t\tDefaultMetricsProvider(config.Instrumentation),\n\t\tlog.TestingLogger(),\n\t\tCustomReactors(map[string]p2p.Reactor{\"FOO\": cr, \"BLOCKCHAIN\": customBlockchainReactor}),\n\t)\n\trequire.NoError(t, err)\n\n\terr = n.Start()\n\trequire.NoError(t, err)\n\tdefer n.Stop() //nolint:errcheck // ignore for tests\n\n\tassert.True(t, cr.IsRunning())\n\tassert.Equal(t, cr, n.Switch().Reactor(\"FOO\"))\n\n\tassert.True(t, customBlockchainReactor.IsRunning())\n\tassert.Equal(t, customBlockchainReactor, n.Switch().Reactor(\"BLOCKCHAIN\"))\n}\n\nfunc state(nVals int, height int64) (sm.State, dbm.DB, []types.PrivValidator) {\n\tprivVals := make([]types.PrivValidator, nVals)\n\tvals := make([]types.GenesisValidator, nVals)\n\tfor i := 0; i < nVals; i++ {\n\t\tprivVal := types.NewMockPV()\n\t\tprivVals[i] = privVal\n\t\tvals[i] = types.GenesisValidator{\n\t\t\tAddress: privVal.PrivKey.PubKey().Address(),\n\t\t\tPubKey:  privVal.PrivKey.PubKey(),\n\t\t\tPower:   1000,\n\t\t\tName:    fmt.Sprintf(\"test%d\", i),\n\t\t}\n\t}\n\ts, _ := sm.MakeGenesisState(&types.GenesisDoc{\n\t\tChainID:    \"test-chain\",\n\t\tValidators: vals,\n\t\tAppHash:    nil,\n\t})\n\n\t// save validators to db for 2 heights\n\tstateDB := dbm.NewMemDB()\n\tstateStore := sm.NewStore(stateDB)\n\tif err := stateStore.Save(s); err != nil {\n\t\tpanic(err)\n\t}\n\n\tfor i := 1; i < int(height); i++ {\n\t\ts.LastBlockHeight++\n\t\ts.LastValidators = s.Validators.Copy()\n\t\tif err := stateStore.Save(s); err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n\treturn s, stateDB, privVals\n}\n", "package state\n\nimport (\n\t\"github.com/tendermint/tendermint/types\"\n)\n\n//------------------------------------------------------\n// blockchain services types\n// NOTE: Interfaces used by RPC must be thread safe!\n//------------------------------------------------------\n\n//------------------------------------------------------\n// blockstore\n\n// BlockStore defines the interface used by the ConsensusState.\ntype BlockStore interface {\n\tBase() int64\n\tHeight() int64\n\tSize() int64\n\n\tLoadBaseMeta() *types.BlockMeta\n\tLoadBlockMeta(height int64) *types.BlockMeta\n\tLoadBlock(height int64) *types.Block\n\n\tSaveBlock(block *types.Block, blockParts *types.PartSet, seenCommit *types.Commit)\n\n\tPruneBlocks(height int64) (uint64, error)\n\n\tLoadBlockByHash(hash []byte) *types.Block\n\tLoadBlockPart(height int64, index int) *types.Part\n\n\tLoadBlockCommit(height int64) *types.Commit\n\tLoadSeenCommit(height int64) *types.Commit\n}\n\n//-----------------------------------------------------------------------------\n// evidence pool\n\n//go:generate mockery --case underscore --name EvidencePool\n\n// EvidencePool defines the EvidencePool interface used by State.\ntype EvidencePool interface {\n\tPendingEvidence(maxBytes int64) (ev []types.Evidence, size int64)\n\tAddEvidence(types.Evidence) error\n\tUpdate(State, types.EvidenceList)\n\tCheckEvidence(types.EvidenceList) error\n}\n\n// EmptyEvidencePool is an empty implementation of EvidencePool, useful for testing. It also complies\n// to the consensus evidence pool interface\ntype EmptyEvidencePool struct{}\n\nfunc (EmptyEvidencePool) PendingEvidence(maxBytes int64) (ev []types.Evidence, size int64) {\n\treturn nil, 0\n}\nfunc (EmptyEvidencePool) AddEvidence(types.Evidence) error                { return nil }\nfunc (EmptyEvidencePool) Update(State, types.EvidenceList)                {}\nfunc (EmptyEvidencePool) CheckEvidence(evList types.EvidenceList) error   { return nil }\nfunc (EmptyEvidencePool) ReportConflictingVotes(voteA, voteB *types.Vote) {}\n", "package consensus\n\nimport (\n\t\"bytes\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"os\"\n\t\"reflect\"\n\t\"runtime/debug\"\n\t\"sync\"\n\t\"time\"\n\n\t\"github.com/gogo/protobuf/proto\"\n\n\tcfg \"github.com/tendermint/tendermint/config\"\n\tcstypes \"github.com/tendermint/tendermint/consensus/types\"\n\t\"github.com/tendermint/tendermint/crypto\"\n\ttmevents \"github.com/tendermint/tendermint/libs/events\"\n\t\"github.com/tendermint/tendermint/libs/fail\"\n\ttmjson \"github.com/tendermint/tendermint/libs/json\"\n\t\"github.com/tendermint/tendermint/libs/log\"\n\ttmmath \"github.com/tendermint/tendermint/libs/math\"\n\ttmos \"github.com/tendermint/tendermint/libs/os\"\n\t\"github.com/tendermint/tendermint/libs/service\"\n\t\"github.com/tendermint/tendermint/p2p\"\n\ttmproto \"github.com/tendermint/tendermint/proto/tendermint/types\"\n\tsm \"github.com/tendermint/tendermint/state\"\n\t\"github.com/tendermint/tendermint/types\"\n\ttmtime \"github.com/tendermint/tendermint/types/time\"\n)\n\n// State handles execution of the consensus algorithm.\n// It processes votes and proposals, and upon reaching agreement,\n// commits blocks to the chain and executes them against the application.\n// The internal state machine receives input from peers, the internal validator, and from a timer.\ntype State struct {\n\tservice.BaseService\n\n\t// config details\n\tconfig        *cfg.ConsensusConfig\n\tprivValidator types.PrivValidator // for signing votes\n\n\t// store blocks and commits\n\tblockStore sm.BlockStore\n\n\t// create and execute blocks\n\tblockExec *sm.BlockExecutor\n\n\t// notify us if txs are available\n\ttxNotifier txNotifier\n\n\t// add evidence to the pool\n\t// when it's detected\n\tevpool evidencePool\n\n\t// internal state\n\tmtx sync.RWMutex\n\tcstypes.RoundState\n\tstate sm.State // State until height-1.\n\n\t// state changes may be triggered by: msgs from peers,\n\t// msgs from ourself, or by timeouts\n\tpeerMsgQueue     chan msgInfo\n\tinternalMsgQueue chan msgInfo\n\ttimeoutTicker    TimeoutTicker\n\t// privValidator pubkey, memoized for the duration of one block\n\t// to avoid extra requests to HSM\n\tprivValidatorPubKey crypto.PubKey\n\n\t// information about about added votes and block parts are written on this channel\n\t// so statistics can be computed by reactor\n\tstatsMsgQueue chan msgInfo\n\n\t// we use eventBus to trigger msg broadcasts in the reactor,\n\t// and to notify external subscribers, eg. through a websocket\n\teventBus *types.EventBus\n\n\t// a Write-Ahead Log ensures we can recover from any kind of crash\n\t// and helps us avoid signing conflicting votes\n\twal          WAL\n\treplayMode   bool // so we don't log signing errors during replay\n\tdoWALCatchup bool // determines if we even try to do the catchup\n\n\t// for tests where we want to limit the number of transitions the state makes\n\tnSteps int\n\n\t// some functions can be overwritten for testing\n\tdecideProposal func(height int64, round int32)\n\n\t// closed when we finish shutting down\n\tdone chan struct{}\n\n\t// synchronous pubsub between consensus state and reactor.\n\t// state only emits EventNewRoundStep and EventVote\n\tevsw tmevents.EventSwitch\n\n\t// for reporting metrics\n\tmetrics *Metrics\n\n\t// misbehaviors mapped for each height (can't have more than one misbehavior per height)\n\tmisbehaviors map[int64]Misbehavior\n\n\t// the switch is passed to the state so that maveick misbehaviors can directly control which\n\t// information they send to which nodes\n\tsw *p2p.Switch\n}\n\n// StateOption sets an optional parameter on the State.\ntype StateOption func(*State)\n\n// NewState returns a new State.\nfunc NewState(\n\tconfig *cfg.ConsensusConfig,\n\tstate sm.State,\n\tblockExec *sm.BlockExecutor,\n\tblockStore sm.BlockStore,\n\ttxNotifier txNotifier,\n\tevpool evidencePool,\n\tmisbehaviors map[int64]Misbehavior,\n\toptions ...StateOption,\n) *State {\n\tcs := &State{\n\t\tconfig:           config,\n\t\tblockExec:        blockExec,\n\t\tblockStore:       blockStore,\n\t\ttxNotifier:       txNotifier,\n\t\tpeerMsgQueue:     make(chan msgInfo, msgQueueSize),\n\t\tinternalMsgQueue: make(chan msgInfo, msgQueueSize),\n\t\ttimeoutTicker:    NewTimeoutTicker(),\n\t\tstatsMsgQueue:    make(chan msgInfo, msgQueueSize),\n\t\tdone:             make(chan struct{}),\n\t\tdoWALCatchup:     true,\n\t\twal:              nilWAL{},\n\t\tevpool:           evpool,\n\t\tevsw:             tmevents.NewEventSwitch(),\n\t\tmetrics:          NopMetrics(),\n\t\tmisbehaviors:     misbehaviors,\n\t}\n\t// set function defaults (may be overwritten before calling Start)\n\tcs.decideProposal = cs.defaultDecideProposal\n\n\t// We have no votes, so reconstruct LastCommit from SeenCommit.\n\tif state.LastBlockHeight > 0 {\n\t\tcs.reconstructLastCommit(state)\n\t}\n\n\tcs.updateToState(state)\n\n\t// Don't call scheduleRound0 yet.\n\t// We do that upon Start().\n\n\tcs.BaseService = *service.NewBaseService(nil, \"State\", cs)\n\tfor _, option := range options {\n\t\toption(cs)\n\t}\n\treturn cs\n}\n\n// I know this is not great but the maverick consensus state needs access to the peers\nfunc (cs *State) SetSwitch(sw *p2p.Switch) {\n\tcs.sw = sw\n}\n\n// state transitions on complete-proposal, 2/3-any, 2/3-one\nfunc (cs *State) handleMsg(mi msgInfo) {\n\tcs.mtx.Lock()\n\tdefer cs.mtx.Unlock()\n\n\tvar (\n\t\tadded bool\n\t\terr   error\n\t)\n\tmsg, peerID := mi.Msg, mi.PeerID\n\tswitch msg := msg.(type) {\n\tcase *ProposalMessage:\n\t\t// will not cause transition.\n\t\t// once proposal is set, we can receive block parts\n\t\t// err = cs.setProposal(msg.Proposal)\n\t\tif b, ok := cs.misbehaviors[cs.Height]; ok {\n\t\t\terr = b.ReceiveProposal(cs, msg.Proposal)\n\t\t} else {\n\t\t\terr = defaultReceiveProposal(cs, msg.Proposal)\n\t\t}\n\tcase *BlockPartMessage:\n\t\t// if the proposal is complete, we'll enterPrevote or tryFinalizeCommit\n\t\tadded, err = cs.addProposalBlockPart(msg, peerID)\n\t\tif added {\n\t\t\tcs.statsMsgQueue <- mi\n\t\t}\n\n\t\tif err != nil && msg.Round != cs.Round {\n\t\t\tcs.Logger.Debug(\n\t\t\t\t\"Received block part from wrong round\",\n\t\t\t\t\"height\",\n\t\t\t\tcs.Height,\n\t\t\t\t\"csRound\",\n\t\t\t\tcs.Round,\n\t\t\t\t\"blockRound\",\n\t\t\t\tmsg.Round)\n\t\t\terr = nil\n\t\t}\n\tcase *VoteMessage:\n\t\t// attempt to add the vote and dupeout the validator if its a duplicate signature\n\t\t// if the vote gives us a 2/3-any or 2/3-one, we transition\n\t\tadded, err = cs.tryAddVote(msg.Vote, peerID)\n\t\tif added {\n\t\t\tcs.statsMsgQueue <- mi\n\t\t}\n\n\t\t// if err == ErrAddingVote {\n\t\t// TODO: punish peer\n\t\t// We probably don't want to stop the peer here. The vote does not\n\t\t// necessarily comes from a malicious peer but can be just broadcasted by\n\t\t// a typical peer.\n\t\t// https://github.com/tendermint/tendermint/issues/1281\n\t\t// }\n\n\t\t// NOTE: the vote is broadcast to peers by the reactor listening\n\t\t// for vote events\n\n\t\t// TODO: If rs.Height == vote.Height && rs.Round < vote.Round,\n\t\t// the peer is sending us CatchupCommit precommits.\n\t\t// We could make note of this and help filter in broadcastHasVoteMessage().\n\tdefault:\n\t\tcs.Logger.Error(\"Unknown msg type\", \"type\", reflect.TypeOf(msg))\n\t\treturn\n\t}\n\n\tif err != nil {\n\t\tcs.Logger.Error(\"Error with msg\", \"height\", cs.Height, \"round\", cs.Round,\n\t\t\t\"peer\", peerID, \"err\", err, \"msg\", msg)\n\t}\n}\n\n// Enter (CreateEmptyBlocks): from enterNewRound(height,round)\n// Enter (CreateEmptyBlocks, CreateEmptyBlocksInterval > 0 ):\n// \t\tafter enterNewRound(height,round), after timeout of CreateEmptyBlocksInterval\n// Enter (!CreateEmptyBlocks) : after enterNewRound(height,round), once txs are in the mempool\nfunc (cs *State) enterPropose(height int64, round int32) {\n\tlogger := cs.Logger.With(\"height\", height, \"round\", round)\n\n\tif cs.Height != height || round < cs.Round || (cs.Round == round && cstypes.RoundStepPropose <= cs.Step) {\n\t\tlogger.Debug(fmt.Sprintf(\n\t\t\t\"enterPropose(%v/%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tround,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\tlogger.Info(fmt.Sprintf(\"enterPropose(%v/%v). Current: %v/%v/%v\", height, round, cs.Height, cs.Round, cs.Step))\n\n\tdefer func() {\n\t\t// Done enterPropose:\n\t\tcs.updateRoundStep(round, cstypes.RoundStepPropose)\n\t\tcs.newStep()\n\n\t\t// If we have the whole proposal + POL, then goto Prevote now.\n\t\t// else, we'll enterPrevote when the rest of the proposal is received (in AddProposalBlockPart),\n\t\t// or else after timeoutPropose\n\t\tif cs.isProposalComplete() {\n\t\t\tcs.enterPrevote(height, cs.Round)\n\t\t}\n\t}()\n\n\tif b, ok := cs.misbehaviors[cs.Height]; ok {\n\t\tb.EnterPropose(cs, height, round)\n\t} else {\n\t\tdefaultEnterPropose(cs, height, round)\n\t}\n}\n\n// Enter: `timeoutPropose` after entering Propose.\n// Enter: proposal block and POL is ready.\n// Prevote for LockedBlock if we're locked, or ProposalBlock if valid.\n// Otherwise vote nil.\nfunc (cs *State) enterPrevote(height int64, round int32) {\n\tif cs.Height != height || round < cs.Round || (cs.Round == round && cstypes.RoundStepPrevote <= cs.Step) {\n\t\tcs.Logger.Debug(fmt.Sprintf(\n\t\t\t\"enterPrevote(%v/%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tround,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\n\tdefer func() {\n\t\t// Done enterPrevote:\n\t\tcs.updateRoundStep(round, cstypes.RoundStepPrevote)\n\t\tcs.newStep()\n\t}()\n\n\tcs.Logger.Info(fmt.Sprintf(\"enterPrevote(%v/%v). Current: %v/%v/%v\", height, round, cs.Height, cs.Round, cs.Step))\n\n\t// Sign and broadcast vote as necessary\n\tif b, ok := cs.misbehaviors[cs.Height]; ok {\n\t\tb.EnterPrevote(cs, height, round)\n\t} else {\n\t\tdefaultEnterPrevote(cs, height, round)\n\t}\n\n\t// Once `addVote` hits any +2/3 prevotes, we will go to PrevoteWait\n\t// (so we have more time to try and collect +2/3 prevotes for a single block)\n}\n\n// Enter: `timeoutPrevote` after any +2/3 prevotes.\n// Enter: `timeoutPrecommit` after any +2/3 precommits.\n// Enter: +2/3 precomits for block or nil.\n// Lock & precommit the ProposalBlock if we have enough prevotes for it (a POL in this round)\n// else, unlock an existing lock and precommit nil if +2/3 of prevotes were nil,\n// else, precommit nil otherwise.\nfunc (cs *State) enterPrecommit(height int64, round int32) {\n\tlogger := cs.Logger.With(\"height\", height, \"round\", round)\n\n\tif cs.Height != height || round < cs.Round || (cs.Round == round && cstypes.RoundStepPrecommit <= cs.Step) {\n\t\tlogger.Debug(fmt.Sprintf(\n\t\t\t\"enterPrecommit(%v/%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tround,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\n\tlogger.Info(fmt.Sprintf(\"enterPrecommit(%v/%v). Current: %v/%v/%v\", height, round, cs.Height, cs.Round, cs.Step))\n\n\tdefer func() {\n\t\t// Done enterPrecommit:\n\t\tcs.updateRoundStep(round, cstypes.RoundStepPrecommit)\n\t\tcs.newStep()\n\t}()\n\n\tif b, ok := cs.misbehaviors[cs.Height]; ok {\n\t\tb.EnterPrecommit(cs, height, round)\n\t} else {\n\t\tdefaultEnterPrecommit(cs, height, round)\n\t}\n\n}\n\nfunc (cs *State) addVote(\n\tvote *types.Vote,\n\tpeerID p2p.ID) (added bool, err error) {\n\tcs.Logger.Debug(\n\t\t\"addVote\",\n\t\t\"voteHeight\",\n\t\tvote.Height,\n\t\t\"voteType\",\n\t\tvote.Type,\n\t\t\"valIndex\",\n\t\tvote.ValidatorIndex,\n\t\t\"csHeight\",\n\t\tcs.Height,\n\t)\n\n\t// A precommit for the previous height?\n\t// These come in while we wait timeoutCommit\n\tif vote.Height+1 == cs.Height && vote.Type == tmproto.PrecommitType {\n\t\tif cs.Step != cstypes.RoundStepNewHeight {\n\t\t\t// Late precommit at prior height is ignored\n\t\t\tcs.Logger.Debug(\"Precommit vote came in after commit timeout and has been ignored\", \"vote\", vote)\n\t\t\treturn\n\t\t}\n\t\tadded, err = cs.LastCommit.AddVote(vote)\n\t\tif !added {\n\t\t\treturn\n\t\t}\n\n\t\tcs.Logger.Info(fmt.Sprintf(\"Added to lastPrecommits: %v\", cs.LastCommit.StringShort()))\n\t\t_ = cs.eventBus.PublishEventVote(types.EventDataVote{Vote: vote})\n\t\tcs.evsw.FireEvent(types.EventVote, vote)\n\n\t\t// if we can skip timeoutCommit and have all the votes now,\n\t\tif cs.config.SkipTimeoutCommit && cs.LastCommit.HasAll() {\n\t\t\t// go straight to new round (skip timeout commit)\n\t\t\t// cs.scheduleTimeout(time.Duration(0), cs.Height, 0, cstypes.RoundStepNewHeight)\n\t\t\tcs.enterNewRound(cs.Height, 0)\n\t\t}\n\n\t\treturn\n\t}\n\n\t// Height mismatch is ignored.\n\t// Not necessarily a bad peer, but not favourable behaviour.\n\tif vote.Height != cs.Height {\n\t\tcs.Logger.Info(\"Vote ignored and not added\", \"voteHeight\", vote.Height, \"csHeight\", cs.Height, \"peerID\", peerID)\n\t\treturn\n\t}\n\n\tadded, err = cs.Votes.AddVote(vote, peerID)\n\tif !added {\n\t\t// Either duplicate, or error upon cs.Votes.AddByIndex()\n\t\treturn\n\t}\n\n\t_ = cs.eventBus.PublishEventVote(types.EventDataVote{Vote: vote})\n\tcs.evsw.FireEvent(types.EventVote, vote)\n\n\tswitch vote.Type {\n\tcase tmproto.PrevoteType:\n\t\tif b, ok := cs.misbehaviors[cs.Height]; ok {\n\t\t\tb.ReceivePrevote(cs, vote)\n\t\t} else {\n\t\t\tdefaultReceivePrevote(cs, vote)\n\t\t}\n\n\tcase tmproto.PrecommitType:\n\t\tif b, ok := cs.misbehaviors[cs.Height]; ok {\n\t\t\tb.ReceivePrecommit(cs, vote)\n\t\t}\n\t\tdefaultReceivePrecommit(cs, vote)\n\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"Unexpected vote type %v\", vote.Type))\n\t}\n\n\treturn added, err\n}\n\n//-----------------------------------------------------------------------------\n// Errors\n\nvar (\n\tErrInvalidProposalSignature   = errors.New(\"error invalid proposal signature\")\n\tErrInvalidProposalPOLRound    = errors.New(\"error invalid proposal POL round\")\n\tErrAddingVote                 = errors.New(\"error adding vote\")\n\tErrSignatureFoundInPastBlocks = errors.New(\"found signature from the same key\")\n\n\terrPubKeyIsNotSet = errors.New(\"pubkey is not set. Look for \\\"Can't get private validator pubkey\\\" errors\")\n)\n\n//-----------------------------------------------------------------------------\n\nvar (\n\tmsgQueueSize = 1000\n)\n\n// msgs from the reactor which may update the state\ntype msgInfo struct {\n\tMsg    Message `json:\"msg\"`\n\tPeerID p2p.ID  `json:\"peer_key\"`\n}\n\n// internally generated messages which may update the state\ntype timeoutInfo struct {\n\tDuration time.Duration         `json:\"duration\"`\n\tHeight   int64                 `json:\"height\"`\n\tRound    int32                 `json:\"round\"`\n\tStep     cstypes.RoundStepType `json:\"step\"`\n}\n\nfunc (ti *timeoutInfo) String() string {\n\treturn fmt.Sprintf(\"%v ; %d/%d %v\", ti.Duration, ti.Height, ti.Round, ti.Step)\n}\n\n// interface to the mempool\ntype txNotifier interface {\n\tTxsAvailable() <-chan struct{}\n}\n\n// interface to the evidence pool\ntype evidencePool interface {\n\t// reports conflicting votes to the evidence pool to be processed into evidence\n\tReportConflictingVotes(voteA, voteB *types.Vote)\n}\n\n//----------------------------------------\n// Public interface\n\n// SetLogger implements Service.\nfunc (cs *State) SetLogger(l log.Logger) {\n\tcs.BaseService.Logger = l\n\tcs.timeoutTicker.SetLogger(l)\n}\n\n// SetEventBus sets event bus.\nfunc (cs *State) SetEventBus(b *types.EventBus) {\n\tcs.eventBus = b\n\tcs.blockExec.SetEventBus(b)\n}\n\n// StateMetrics sets the metrics.\nfunc StateMetrics(metrics *Metrics) StateOption {\n\treturn func(cs *State) { cs.metrics = metrics }\n}\n\n// String returns a string.\nfunc (cs *State) String() string {\n\t// better not to access shared variables\n\treturn \"ConsensusState\"\n}\n\n// GetState returns a copy of the chain state.\nfunc (cs *State) GetState() sm.State {\n\tcs.mtx.RLock()\n\tdefer cs.mtx.RUnlock()\n\treturn cs.state.Copy()\n}\n\n// GetLastHeight returns the last height committed.\n// If there were no blocks, returns 0.\nfunc (cs *State) GetLastHeight() int64 {\n\tcs.mtx.RLock()\n\tdefer cs.mtx.RUnlock()\n\treturn cs.RoundState.Height - 1\n}\n\n// GetRoundState returns a shallow copy of the internal consensus state.\nfunc (cs *State) GetRoundState() *cstypes.RoundState {\n\tcs.mtx.RLock()\n\trs := cs.RoundState // copy\n\tcs.mtx.RUnlock()\n\treturn &rs\n}\n\n// GetRoundStateJSON returns a json of RoundState.\nfunc (cs *State) GetRoundStateJSON() ([]byte, error) {\n\tcs.mtx.RLock()\n\tdefer cs.mtx.RUnlock()\n\treturn tmjson.Marshal(cs.RoundState)\n}\n\n// GetRoundStateSimpleJSON returns a json of RoundStateSimple\nfunc (cs *State) GetRoundStateSimpleJSON() ([]byte, error) {\n\tcs.mtx.RLock()\n\tdefer cs.mtx.RUnlock()\n\treturn tmjson.Marshal(cs.RoundState.RoundStateSimple())\n}\n\n// GetValidators returns a copy of the current validators.\nfunc (cs *State) GetValidators() (int64, []*types.Validator) {\n\tcs.mtx.RLock()\n\tdefer cs.mtx.RUnlock()\n\treturn cs.state.LastBlockHeight, cs.state.Validators.Copy().Validators\n}\n\n// SetPrivValidator sets the private validator account for signing votes. It\n// immediately requests pubkey and caches it.\nfunc (cs *State) SetPrivValidator(priv types.PrivValidator) {\n\tcs.mtx.Lock()\n\tdefer cs.mtx.Unlock()\n\n\tcs.privValidator = priv\n\n\tif err := cs.updatePrivValidatorPubKey(); err != nil {\n\t\tcs.Logger.Error(\"Can't get private validator pubkey\", \"err\", err)\n\t}\n}\n\n// SetTimeoutTicker sets the local timer. It may be useful to overwrite for testing.\nfunc (cs *State) SetTimeoutTicker(timeoutTicker TimeoutTicker) {\n\tcs.mtx.Lock()\n\tcs.timeoutTicker = timeoutTicker\n\tcs.mtx.Unlock()\n}\n\n// LoadCommit loads the commit for a given height.\nfunc (cs *State) LoadCommit(height int64) *types.Commit {\n\tcs.mtx.RLock()\n\tdefer cs.mtx.RUnlock()\n\tif height == cs.blockStore.Height() {\n\t\treturn cs.blockStore.LoadSeenCommit(height)\n\t}\n\treturn cs.blockStore.LoadBlockCommit(height)\n}\n\n// OnStart loads the latest state via the WAL, and starts the timeout and\n// receive routines.\nfunc (cs *State) OnStart() error {\n\t// We may set the WAL in testing before calling Start, so only OpenWAL if its\n\t// still the nilWAL.\n\tif _, ok := cs.wal.(nilWAL); ok {\n\t\tif err := cs.loadWalFile(); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\n\t// We may have lost some votes if the process crashed reload from consensus\n\t// log to catchup.\n\tif cs.doWALCatchup {\n\t\trepairAttempted := false\n\tLOOP:\n\t\tfor {\n\t\t\terr := cs.catchupReplay(cs.Height)\n\t\t\tswitch {\n\t\t\tcase err == nil:\n\t\t\t\tbreak LOOP\n\t\t\tcase !IsDataCorruptionError(err):\n\t\t\t\tcs.Logger.Error(\"Error on catchup replay. Proceeding to start State anyway\", \"err\", err)\n\t\t\t\tbreak LOOP\n\t\t\tcase repairAttempted:\n\t\t\t\treturn err\n\t\t\t}\n\n\t\t\tcs.Logger.Info(\"WAL file is corrupted. Attempting repair\", \"err\", err)\n\n\t\t\t// 1) prep work\n\t\t\tif err := cs.wal.Stop(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\trepairAttempted = true\n\n\t\t\t// 2) backup original WAL file\n\t\t\tcorruptedFile := fmt.Sprintf(\"%s.CORRUPTED\", cs.config.WalFile())\n\t\t\tif err := tmos.CopyFile(cs.config.WalFile(), corruptedFile); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcs.Logger.Info(\"Backed up WAL file\", \"src\", cs.config.WalFile(), \"dst\", corruptedFile)\n\n\t\t\t// 3) try to repair (WAL file will be overwritten!)\n\t\t\tif err := repairWalFile(corruptedFile, cs.config.WalFile()); err != nil {\n\t\t\t\tcs.Logger.Error(\"Repair failed\", \"err\", err)\n\t\t\t\treturn err\n\t\t\t}\n\t\t\tcs.Logger.Info(\"Successful repair\")\n\n\t\t\t// reload WAL file\n\t\t\tif err := cs.loadWalFile(); err != nil {\n\t\t\t\treturn err\n\t\t\t}\n\t\t}\n\t}\n\n\tif err := cs.evsw.Start(); err != nil {\n\t\treturn err\n\t}\n\n\t// we need the timeoutRoutine for replay so\n\t// we don't block on the tick chan.\n\t// NOTE: we will get a build up of garbage go routines\n\t// firing on the tockChan until the receiveRoutine is started\n\t// to deal with them (by that point, at most one will be valid)\n\tif err := cs.timeoutTicker.Start(); err != nil {\n\t\treturn err\n\t}\n\n\t// Double Signing Risk Reduction\n\tif err := cs.checkDoubleSigningRisk(cs.Height); err != nil {\n\t\treturn err\n\t}\n\n\t// now start the receiveRoutine\n\tgo cs.receiveRoutine(0)\n\n\t// schedule the first round!\n\t// use GetRoundState so we don't race the receiveRoutine for access\n\tcs.scheduleRound0(cs.GetRoundState())\n\n\treturn nil\n}\n\n// loadWalFile loads WAL data from file. It overwrites cs.wal.\nfunc (cs *State) loadWalFile() error {\n\twal, err := cs.OpenWAL(cs.config.WalFile())\n\tif err != nil {\n\t\tcs.Logger.Error(\"Error loading State wal\", \"err\", err)\n\t\treturn err\n\t}\n\tcs.wal = wal\n\treturn nil\n}\n\n// OnStop implements service.Service.\nfunc (cs *State) OnStop() {\n\tif err := cs.evsw.Stop(); err != nil {\n\t\tcs.Logger.Error(\"error trying to stop eventSwitch\", \"error\", err)\n\t}\n\tif err := cs.timeoutTicker.Stop(); err != nil {\n\t\tcs.Logger.Error(\"error trying to stop timeoutTicket\", \"error\", err)\n\t}\n\t// WAL is stopped in receiveRoutine.\n}\n\n// Wait waits for the the main routine to return.\n// NOTE: be sure to Stop() the event switch and drain\n// any event channels or this may deadlock\nfunc (cs *State) Wait() {\n\t<-cs.done\n}\n\n// OpenWAL opens a file to log all consensus messages and timeouts for\n// deterministic accountability.\nfunc (cs *State) OpenWAL(walFile string) (WAL, error) {\n\twal, err := NewWAL(walFile)\n\tif err != nil {\n\t\tcs.Logger.Error(\"Failed to open WAL\", \"file\", walFile, \"err\", err)\n\t\treturn nil, err\n\t}\n\twal.SetLogger(cs.Logger.With(\"wal\", walFile))\n\tif err := wal.Start(); err != nil {\n\t\tcs.Logger.Error(\"Failed to start WAL\", \"err\", err)\n\t\treturn nil, err\n\t}\n\treturn wal, nil\n}\n\n//------------------------------------------------------------\n// Public interface for passing messages into the consensus state, possibly causing a state transition.\n// If peerID == \"\", the msg is considered internal.\n// Messages are added to the appropriate queue (peer or internal).\n// If the queue is full, the function may block.\n// TODO: should these return anything or let callers just use events?\n\n// AddVote inputs a vote.\nfunc (cs *State) AddVote(vote *types.Vote, peerID p2p.ID) (added bool, err error) {\n\tif peerID == \"\" {\n\t\tcs.internalMsgQueue <- msgInfo{&VoteMessage{vote}, \"\"}\n\t} else {\n\t\tcs.peerMsgQueue <- msgInfo{&VoteMessage{vote}, peerID}\n\t}\n\n\t// TODO: wait for event?!\n\treturn false, nil\n}\n\n// SetProposal inputs a proposal.\nfunc (cs *State) SetProposal(proposal *types.Proposal, peerID p2p.ID) error {\n\n\tif peerID == \"\" {\n\t\tcs.internalMsgQueue <- msgInfo{&ProposalMessage{proposal}, \"\"}\n\t} else {\n\t\tcs.peerMsgQueue <- msgInfo{&ProposalMessage{proposal}, peerID}\n\t}\n\n\t// TODO: wait for event?!\n\treturn nil\n}\n\n// AddProposalBlockPart inputs a part of the proposal block.\nfunc (cs *State) AddProposalBlockPart(height int64, round int32, part *types.Part, peerID p2p.ID) error {\n\n\tif peerID == \"\" {\n\t\tcs.internalMsgQueue <- msgInfo{&BlockPartMessage{height, round, part}, \"\"}\n\t} else {\n\t\tcs.peerMsgQueue <- msgInfo{&BlockPartMessage{height, round, part}, peerID}\n\t}\n\n\t// TODO: wait for event?!\n\treturn nil\n}\n\n// SetProposalAndBlock inputs the proposal and all block parts.\nfunc (cs *State) SetProposalAndBlock(\n\tproposal *types.Proposal,\n\tblock *types.Block,\n\tparts *types.PartSet,\n\tpeerID p2p.ID,\n) error {\n\tif err := cs.SetProposal(proposal, peerID); err != nil {\n\t\treturn err\n\t}\n\tfor i := 0; i < int(parts.Total()); i++ {\n\t\tpart := parts.GetPart(i)\n\t\tif err := cs.AddProposalBlockPart(proposal.Height, proposal.Round, part, peerID); err != nil {\n\t\t\treturn err\n\t\t}\n\t}\n\treturn nil\n}\n\n//------------------------------------------------------------\n// internal functions for managing the state\n\nfunc (cs *State) updateHeight(height int64) {\n\tcs.metrics.Height.Set(float64(height))\n\tcs.Height = height\n}\n\nfunc (cs *State) updateRoundStep(round int32, step cstypes.RoundStepType) {\n\tcs.Round = round\n\tcs.Step = step\n}\n\n// enterNewRound(height, 0) at cs.StartTime.\nfunc (cs *State) scheduleRound0(rs *cstypes.RoundState) {\n\t// cs.Logger.Info(\"scheduleRound0\", \"now\", tmtime.Now(), \"startTime\", cs.StartTime)\n\tsleepDuration := rs.StartTime.Sub(tmtime.Now())\n\tcs.scheduleTimeout(sleepDuration, rs.Height, 0, cstypes.RoundStepNewHeight)\n}\n\n// Attempt to schedule a timeout (by sending timeoutInfo on the tickChan)\nfunc (cs *State) scheduleTimeout(duration time.Duration, height int64, round int32, step cstypes.RoundStepType) {\n\tcs.timeoutTicker.ScheduleTimeout(timeoutInfo{duration, height, round, step})\n}\n\n// send a msg into the receiveRoutine regarding our own proposal, block part, or vote\nfunc (cs *State) sendInternalMessage(mi msgInfo) {\n\tselect {\n\tcase cs.internalMsgQueue <- mi:\n\tdefault:\n\t\t// NOTE: using the go-routine means our votes can\n\t\t// be processed out of order.\n\t\t// TODO: use CList here for strict determinism and\n\t\t// attempt push to internalMsgQueue in receiveRoutine\n\t\tcs.Logger.Info(\"Internal msg queue is full. Using a go-routine\")\n\t\tgo func() { cs.internalMsgQueue <- mi }()\n\t}\n}\n\n// Reconstruct LastCommit from SeenCommit, which we saved along with the block,\n// (which happens even before saving the state)\nfunc (cs *State) reconstructLastCommit(state sm.State) {\n\tseenCommit := cs.blockStore.LoadSeenCommit(state.LastBlockHeight)\n\tif seenCommit == nil {\n\t\tpanic(fmt.Sprintf(\"Failed to reconstruct LastCommit: seen commit for height %v not found\",\n\t\t\tstate.LastBlockHeight))\n\t}\n\n\tlastPrecommits := types.CommitToVoteSet(state.ChainID, seenCommit, state.LastValidators)\n\tif !lastPrecommits.HasTwoThirdsMajority() {\n\t\tpanic(\"Failed to reconstruct LastCommit: Does not have +2/3 maj\")\n\t}\n\n\tcs.LastCommit = lastPrecommits\n}\n\n// Updates State and increments height to match that of state.\n// The round becomes 0 and cs.Step becomes cstypes.RoundStepNewHeight.\nfunc (cs *State) updateToState(state sm.State) {\n\tif cs.CommitRound > -1 && 0 < cs.Height && cs.Height != state.LastBlockHeight {\n\t\tpanic(fmt.Sprintf(\"updateToState() expected state height of %v but found %v\",\n\t\t\tcs.Height, state.LastBlockHeight))\n\t}\n\tif !cs.state.IsEmpty() {\n\t\tif cs.state.LastBlockHeight > 0 && cs.state.LastBlockHeight+1 != cs.Height {\n\t\t\t// This might happen when someone else is mutating cs.state.\n\t\t\t// Someone forgot to pass in state.Copy() somewhere?!\n\t\t\tpanic(fmt.Sprintf(\"Inconsistent cs.state.LastBlockHeight+1 %v vs cs.Height %v\",\n\t\t\t\tcs.state.LastBlockHeight+1, cs.Height))\n\t\t}\n\t\tif cs.state.LastBlockHeight > 0 && cs.Height == cs.state.InitialHeight {\n\t\t\tpanic(fmt.Sprintf(\"Inconsistent cs.state.LastBlockHeight %v, expected 0 for initial height %v\",\n\t\t\t\tcs.state.LastBlockHeight, cs.state.InitialHeight))\n\t\t}\n\n\t\t// If state isn't further out than cs.state, just ignore.\n\t\t// This happens when SwitchToConsensus() is called in the reactor.\n\t\t// We don't want to reset e.g. the Votes, but we still want to\n\t\t// signal the new round step, because other services (eg. txNotifier)\n\t\t// depend on having an up-to-date peer state!\n\t\tif state.LastBlockHeight <= cs.state.LastBlockHeight {\n\t\t\tcs.Logger.Info(\n\t\t\t\t\"Ignoring updateToState()\",\n\t\t\t\t\"newHeight\",\n\t\t\t\tstate.LastBlockHeight+1,\n\t\t\t\t\"oldHeight\",\n\t\t\t\tcs.state.LastBlockHeight+1)\n\t\t\tcs.newStep()\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Reset fields based on state.\n\tvalidators := state.Validators\n\n\tswitch {\n\tcase state.LastBlockHeight == 0: // Very first commit should be empty.\n\t\tcs.LastCommit = (*types.VoteSet)(nil)\n\tcase cs.CommitRound > -1 && cs.Votes != nil: // Otherwise, use cs.Votes\n\t\tif !cs.Votes.Precommits(cs.CommitRound).HasTwoThirdsMajority() {\n\t\t\tpanic(fmt.Sprintf(\"Wanted to form a Commit, but Precommits (H/R: %d/%d) didn't have 2/3+: %v\",\n\t\t\t\tstate.LastBlockHeight,\n\t\t\t\tcs.CommitRound,\n\t\t\t\tcs.Votes.Precommits(cs.CommitRound)))\n\t\t}\n\t\tcs.LastCommit = cs.Votes.Precommits(cs.CommitRound)\n\tcase cs.LastCommit == nil:\n\t\t// NOTE: when Tendermint starts, it has no votes. reconstructLastCommit\n\t\t// must be called to reconstruct LastCommit from SeenCommit.\n\t\tpanic(fmt.Sprintf(\"LastCommit cannot be empty after initial block (H:%d)\",\n\t\t\tstate.LastBlockHeight+1,\n\t\t))\n\t}\n\n\t// Next desired block height\n\theight := state.LastBlockHeight + 1\n\tif height == 1 {\n\t\theight = state.InitialHeight\n\t}\n\n\t// RoundState fields\n\tcs.updateHeight(height)\n\tcs.updateRoundStep(0, cstypes.RoundStepNewHeight)\n\tif cs.CommitTime.IsZero() {\n\t\t// \"Now\" makes it easier to sync up dev nodes.\n\t\t// We add timeoutCommit to allow transactions\n\t\t// to be gathered for the first block.\n\t\t// And alternative solution that relies on clocks:\n\t\t// cs.StartTime = state.LastBlockTime.Add(timeoutCommit)\n\t\tcs.StartTime = cs.config.Commit(tmtime.Now())\n\t} else {\n\t\tcs.StartTime = cs.config.Commit(cs.CommitTime)\n\t}\n\n\tcs.Validators = validators\n\tcs.Proposal = nil\n\tcs.ProposalBlock = nil\n\tcs.ProposalBlockParts = nil\n\tcs.LockedRound = -1\n\tcs.LockedBlock = nil\n\tcs.LockedBlockParts = nil\n\tcs.ValidRound = -1\n\tcs.ValidBlock = nil\n\tcs.ValidBlockParts = nil\n\tcs.Votes = cstypes.NewHeightVoteSet(state.ChainID, height, validators)\n\tcs.CommitRound = -1\n\tcs.LastValidators = state.LastValidators\n\tcs.TriggeredTimeoutPrecommit = false\n\n\tcs.state = state\n\n\t// Finally, broadcast RoundState\n\tcs.newStep()\n}\n\nfunc (cs *State) newStep() {\n\trs := cs.RoundStateEvent()\n\tif err := cs.wal.Write(rs); err != nil {\n\t\tcs.Logger.Error(\"Error writing to wal\", \"err\", err)\n\t}\n\tcs.nSteps++\n\t// newStep is called by updateToState in NewState before the eventBus is set!\n\tif cs.eventBus != nil {\n\t\tif err := cs.eventBus.PublishEventNewRoundStep(rs); err != nil {\n\t\t\tcs.Logger.Error(\"Error publishing new round step\", \"err\", err)\n\t\t}\n\t\tcs.evsw.FireEvent(types.EventNewRoundStep, &cs.RoundState)\n\t}\n}\n\n//-----------------------------------------\n// the main go routines\n\n// receiveRoutine handles messages which may cause state transitions.\n// it's argument (n) is the number of messages to process before exiting - use 0 to run forever\n// It keeps the RoundState and is the only thing that updates it.\n// Updates (state transitions) happen on timeouts, complete proposals, and 2/3 majorities.\n// State must be locked before any internal state is updated.\nfunc (cs *State) receiveRoutine(maxSteps int) {\n\tonExit := func(cs *State) {\n\t\t// NOTE: the internalMsgQueue may have signed messages from our\n\t\t// priv_val that haven't hit the WAL, but its ok because\n\t\t// priv_val tracks LastSig\n\n\t\t// close wal now that we're done writing to it\n\t\tif err := cs.wal.Stop(); err != nil {\n\t\t\tcs.Logger.Error(\"error trying to stop wal\", \"error\", err)\n\t\t}\n\t\tcs.wal.Wait()\n\n\t\tclose(cs.done)\n\t}\n\n\tdefer func() {\n\t\tif r := recover(); r != nil {\n\t\t\tcs.Logger.Error(\"CONSENSUS FAILURE!!!\", \"err\", r, \"stack\", string(debug.Stack()))\n\t\t\t// stop gracefully\n\t\t\t//\n\t\t\t// NOTE: We most probably shouldn't be running any further when there is\n\t\t\t// some unexpected panic. Some unknown error happened, and so we don't\n\t\t\t// know if that will result in the validator signing an invalid thing. It\n\t\t\t// might be worthwhile to explore a mechanism for manual resuming via\n\t\t\t// some console or secure RPC system, but for now, halting the chain upon\n\t\t\t// unexpected consensus bugs sounds like the better option.\n\t\t\tonExit(cs)\n\t\t}\n\t}()\n\n\tfor {\n\t\tif maxSteps > 0 {\n\t\t\tif cs.nSteps >= maxSteps {\n\t\t\t\tcs.Logger.Info(\"reached max steps. exiting receive routine\")\n\t\t\t\tcs.nSteps = 0\n\t\t\t\treturn\n\t\t\t}\n\t\t}\n\t\trs := cs.RoundState\n\t\tvar mi msgInfo\n\n\t\tselect {\n\t\tcase <-cs.txNotifier.TxsAvailable():\n\t\t\tcs.handleTxsAvailable()\n\t\tcase mi = <-cs.peerMsgQueue:\n\t\t\tif err := cs.wal.Write(mi); err != nil {\n\t\t\t\tcs.Logger.Error(\"Error writing to wal\", \"err\", err)\n\t\t\t}\n\t\t\t// handles proposals, block parts, votes\n\t\t\t// may generate internal events (votes, complete proposals, 2/3 majorities)\n\t\t\tcs.handleMsg(mi)\n\t\tcase mi = <-cs.internalMsgQueue:\n\t\t\terr := cs.wal.WriteSync(mi) // NOTE: fsync\n\t\t\tif err != nil {\n\t\t\t\tpanic(fmt.Sprintf(\"Failed to write %v msg to consensus wal due to %v. Check your FS and restart the node\", mi, err))\n\t\t\t}\n\n\t\t\tif _, ok := mi.Msg.(*VoteMessage); ok {\n\t\t\t\t// we actually want to simulate failing during\n\t\t\t\t// the previous WriteSync, but this isn't easy to do.\n\t\t\t\t// Equivalent would be to fail here and manually remove\n\t\t\t\t// some bytes from the end of the wal.\n\t\t\t\tfail.Fail() // XXX\n\t\t\t}\n\n\t\t\t// handles proposals, block parts, votes\n\t\t\tcs.handleMsg(mi)\n\t\tcase ti := <-cs.timeoutTicker.Chan(): // tockChan:\n\t\t\tif err := cs.wal.Write(ti); err != nil {\n\t\t\t\tcs.Logger.Error(\"Error writing to wal\", \"err\", err)\n\t\t\t}\n\t\t\t// if the timeout is relevant to the rs\n\t\t\t// go to the next step\n\t\t\tcs.handleTimeout(ti, rs)\n\t\tcase <-cs.Quit():\n\t\t\tonExit(cs)\n\t\t\treturn\n\t\t}\n\t}\n}\n\nfunc (cs *State) handleTimeout(ti timeoutInfo, rs cstypes.RoundState) {\n\tcs.Logger.Debug(\"Received tock\", \"timeout\", ti.Duration, \"height\", ti.Height, \"round\", ti.Round, \"step\", ti.Step)\n\n\t// timeouts must be for current height, round, step\n\tif ti.Height != rs.Height || ti.Round < rs.Round || (ti.Round == rs.Round && ti.Step < rs.Step) {\n\t\tcs.Logger.Debug(\"Ignoring tock because we're ahead\", \"height\", rs.Height, \"round\", rs.Round, \"step\", rs.Step)\n\t\treturn\n\t}\n\n\t// the timeout will now cause a state transition\n\tcs.mtx.Lock()\n\tdefer cs.mtx.Unlock()\n\n\tswitch ti.Step {\n\tcase cstypes.RoundStepNewHeight:\n\t\t// NewRound event fired from enterNewRound.\n\t\t// XXX: should we fire timeout here (for timeout commit)?\n\t\tcs.enterNewRound(ti.Height, 0)\n\tcase cstypes.RoundStepNewRound:\n\t\tcs.enterPropose(ti.Height, 0)\n\tcase cstypes.RoundStepPropose:\n\t\tif err := cs.eventBus.PublishEventTimeoutPropose(cs.RoundStateEvent()); err != nil {\n\t\t\tcs.Logger.Error(\"Error publishing timeout propose\", \"err\", err)\n\t\t}\n\t\tcs.enterPrevote(ti.Height, ti.Round)\n\tcase cstypes.RoundStepPrevoteWait:\n\t\tif err := cs.eventBus.PublishEventTimeoutWait(cs.RoundStateEvent()); err != nil {\n\t\t\tcs.Logger.Error(\"Error publishing timeout wait\", \"err\", err)\n\t\t}\n\t\tcs.enterPrecommit(ti.Height, ti.Round)\n\tcase cstypes.RoundStepPrecommitWait:\n\t\tif err := cs.eventBus.PublishEventTimeoutWait(cs.RoundStateEvent()); err != nil {\n\t\t\tcs.Logger.Error(\"Error publishing timeout wait\", \"err\", err)\n\t\t}\n\t\tcs.enterPrecommit(ti.Height, ti.Round)\n\t\tcs.enterNewRound(ti.Height, ti.Round+1)\n\tdefault:\n\t\tpanic(fmt.Sprintf(\"Invalid timeout step: %v\", ti.Step))\n\t}\n\n}\n\nfunc (cs *State) handleTxsAvailable() {\n\tcs.mtx.Lock()\n\tdefer cs.mtx.Unlock()\n\n\t// We only need to do this for round 0.\n\tif cs.Round != 0 {\n\t\treturn\n\t}\n\n\tswitch cs.Step {\n\tcase cstypes.RoundStepNewHeight: // timeoutCommit phase\n\t\tif cs.needProofBlock(cs.Height) {\n\t\t\t// enterPropose will be called by enterNewRound\n\t\t\treturn\n\t\t}\n\n\t\t// +1ms to ensure RoundStepNewRound timeout always happens after RoundStepNewHeight\n\t\ttimeoutCommit := cs.StartTime.Sub(tmtime.Now()) + 1*time.Millisecond\n\t\tcs.scheduleTimeout(timeoutCommit, cs.Height, 0, cstypes.RoundStepNewRound)\n\tcase cstypes.RoundStepNewRound: // after timeoutCommit\n\t\tcs.enterPropose(cs.Height, 0)\n\t}\n}\n\n//-----------------------------------------------------------------------------\n// State functions\n// Used internally by handleTimeout and handleMsg to make state transitions\n\n// Enter: `timeoutNewHeight` by startTime (commitTime+timeoutCommit),\n// \tor, if SkipTimeoutCommit==true, after receiving all precommits from (height,round-1)\n// Enter: `timeoutPrecommits` after any +2/3 precommits from (height,round-1)\n// Enter: +2/3 precommits for nil at (height,round-1)\n// Enter: +2/3 prevotes any or +2/3 precommits for block or any from (height, round)\n// NOTE: cs.StartTime was already set for height.\nfunc (cs *State) enterNewRound(height int64, round int32) {\n\tlogger := cs.Logger.With(\"height\", height, \"round\", round)\n\n\tif cs.Height != height || round < cs.Round || (cs.Round == round && cs.Step != cstypes.RoundStepNewHeight) {\n\t\tlogger.Debug(fmt.Sprintf(\n\t\t\t\"enterNewRound(%v/%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tround,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\n\tif now := tmtime.Now(); cs.StartTime.After(now) {\n\t\tlogger.Info(\"Need to set a buffer and log message here for sanity.\", \"startTime\", cs.StartTime, \"now\", now)\n\t}\n\n\tlogger.Info(fmt.Sprintf(\"enterNewRound(%v/%v). Current: %v/%v/%v\", height, round, cs.Height, cs.Round, cs.Step))\n\n\t// Increment validators if necessary\n\tvalidators := cs.Validators\n\tif cs.Round < round {\n\t\tvalidators = validators.Copy()\n\t\tvalidators.IncrementProposerPriority(tmmath.SafeSubInt32(round, cs.Round))\n\t}\n\n\t// Setup new round\n\t// we don't fire newStep for this step,\n\t// but we fire an event, so update the round step first\n\tcs.updateRoundStep(round, cstypes.RoundStepNewRound)\n\tcs.Validators = validators\n\tif round == 0 {\n\t\t// We've already reset these upon new height,\n\t\t// and meanwhile we might have received a proposal\n\t\t// for round 0.\n\t} else {\n\t\tlogger.Info(\"Resetting Proposal info\")\n\t\tcs.Proposal = nil\n\t\tcs.ProposalBlock = nil\n\t\tcs.ProposalBlockParts = nil\n\t}\n\tcs.Votes.SetRound(tmmath.SafeAddInt32(round, 1)) // also track next round (round+1) to allow round-skipping\n\tcs.TriggeredTimeoutPrecommit = false\n\n\tif err := cs.eventBus.PublishEventNewRound(cs.NewRoundEvent()); err != nil {\n\t\tcs.Logger.Error(\"Error publishing new round\", \"err\", err)\n\t}\n\tcs.metrics.Rounds.Set(float64(round))\n\n\t// Wait for txs to be available in the mempool\n\t// before we enterPropose in round 0. If the last block changed the app hash,\n\t// we may need an empty \"proof\" block, and enterPropose immediately.\n\twaitForTxs := cs.config.WaitForTxs() && round == 0 && !cs.needProofBlock(height)\n\tif waitForTxs {\n\t\tif cs.config.CreateEmptyBlocksInterval > 0 {\n\t\t\tcs.scheduleTimeout(cs.config.CreateEmptyBlocksInterval, height, round,\n\t\t\t\tcstypes.RoundStepNewRound)\n\t\t}\n\t} else {\n\t\tcs.enterPropose(height, round)\n\t}\n}\n\n// needProofBlock returns true on the first height (so the genesis app hash is signed right away)\n// and where the last block (height-1) caused the app hash to change\nfunc (cs *State) needProofBlock(height int64) bool {\n\tif height == cs.state.InitialHeight {\n\t\treturn true\n\t}\n\n\tlastBlockMeta := cs.blockStore.LoadBlockMeta(height - 1)\n\tif lastBlockMeta == nil {\n\t\tpanic(fmt.Sprintf(\"needProofBlock: last block meta for height %d not found\", height-1))\n\t}\n\treturn !bytes.Equal(cs.state.AppHash, lastBlockMeta.Header.AppHash)\n}\n\nfunc (cs *State) isProposer(address []byte) bool {\n\treturn bytes.Equal(cs.Validators.GetProposer().Address, address)\n}\n\nfunc (cs *State) defaultDecideProposal(height int64, round int32) {\n\tvar block *types.Block\n\tvar blockParts *types.PartSet\n\n\t// Decide on block\n\tif cs.ValidBlock != nil {\n\t\t// If there is valid block, choose that.\n\t\tblock, blockParts = cs.ValidBlock, cs.ValidBlockParts\n\t} else {\n\t\t// Create a new proposal block from state/txs from the mempool.\n\t\tblock, blockParts = cs.createProposalBlock()\n\t\tif block == nil {\n\t\t\treturn\n\t\t}\n\t}\n\n\t// Flush the WAL. Otherwise, we may not recompute the same proposal to sign,\n\t// and the privValidator will refuse to sign anything.\n\tif err := cs.wal.FlushAndSync(); err != nil {\n\t\tcs.Logger.Error(\"Error flushing to disk\")\n\t}\n\n\t// Make proposal\n\tpropBlockID := types.BlockID{Hash: block.Hash(), PartSetHeader: blockParts.Header()}\n\tproposal := types.NewProposal(height, round, cs.ValidRound, propBlockID)\n\tp := proposal.ToProto()\n\tif err := cs.privValidator.SignProposal(cs.state.ChainID, p); err == nil {\n\t\tproposal.Signature = p.Signature\n\n\t\t// send proposal and block parts on internal msg queue\n\t\tcs.sendInternalMessage(msgInfo{&ProposalMessage{proposal}, \"\"})\n\t\tfor i := 0; i < int(blockParts.Total()); i++ {\n\t\t\tpart := blockParts.GetPart(i)\n\t\t\tcs.sendInternalMessage(msgInfo{&BlockPartMessage{cs.Height, cs.Round, part}, \"\"})\n\t\t}\n\t\tcs.Logger.Info(\"Signed proposal\", \"height\", height, \"round\", round, \"proposal\", proposal)\n\t\tcs.Logger.Debug(fmt.Sprintf(\"Signed proposal block: %v\", block))\n\t} else if !cs.replayMode {\n\t\tcs.Logger.Error(\"enterPropose: Error signing proposal\", \"height\", height, \"round\", round, \"err\", err)\n\t}\n}\n\n// Returns true if the proposal block is complete &&\n// (if POLRound was proposed, we have +2/3 prevotes from there).\nfunc (cs *State) isProposalComplete() bool {\n\tif cs.Proposal == nil || cs.ProposalBlock == nil {\n\t\treturn false\n\t}\n\t// we have the proposal. if there's a POLRound,\n\t// make sure we have the prevotes from it too\n\tif cs.Proposal.POLRound < 0 {\n\t\treturn true\n\t}\n\t// if this is false the proposer is lying or we haven't received the POL yet\n\treturn cs.Votes.Prevotes(cs.Proposal.POLRound).HasTwoThirdsMajority()\n\n}\n\n// Create the next block to propose and return it. Returns nil block upon error.\n//\n// We really only need to return the parts, but the block is returned for\n// convenience so we can log the proposal block.\n//\n// NOTE: keep it side-effect free for clarity.\n// CONTRACT: cs.privValidator is not nil.\nfunc (cs *State) createProposalBlock() (block *types.Block, blockParts *types.PartSet) {\n\tif cs.privValidator == nil {\n\t\tpanic(\"entered createProposalBlock with privValidator being nil\")\n\t}\n\n\tvar commit *types.Commit\n\tswitch {\n\tcase cs.Height == cs.state.InitialHeight:\n\t\t// We're creating a proposal for the first block.\n\t\t// The commit is empty, but not nil.\n\t\tcommit = types.NewCommit(0, 0, types.BlockID{}, nil)\n\tcase cs.LastCommit.HasTwoThirdsMajority():\n\t\t// Make the commit from LastCommit\n\t\tcommit = cs.LastCommit.MakeCommit()\n\tdefault: // This shouldn't happen.\n\t\tcs.Logger.Error(\"enterPropose: Cannot propose anything: No commit for the previous block\")\n\t\treturn\n\t}\n\n\tif cs.privValidatorPubKey == nil {\n\t\t// If this node is a validator & proposer in the current round, it will\n\t\t// miss the opportunity to create a block.\n\t\tcs.Logger.Error(fmt.Sprintf(\"enterPropose: %v\", errPubKeyIsNotSet))\n\t\treturn\n\t}\n\tproposerAddr := cs.privValidatorPubKey.Address()\n\n\treturn cs.blockExec.CreateProposalBlock(cs.Height, cs.state, commit, proposerAddr)\n}\n\n// Enter: any +2/3 prevotes at next round.\nfunc (cs *State) enterPrevoteWait(height int64, round int32) {\n\tlogger := cs.Logger.With(\"height\", height, \"round\", round)\n\n\tif cs.Height != height || round < cs.Round || (cs.Round == round && cstypes.RoundStepPrevoteWait <= cs.Step) {\n\t\tlogger.Debug(fmt.Sprintf(\n\t\t\t\"enterPrevoteWait(%v/%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tround,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\tif !cs.Votes.Prevotes(round).HasTwoThirdsAny() {\n\t\tpanic(fmt.Sprintf(\"enterPrevoteWait(%v/%v), but Prevotes does not have any +2/3 votes\", height, round))\n\t}\n\tlogger.Info(fmt.Sprintf(\"enterPrevoteWait(%v/%v). Current: %v/%v/%v\", height, round, cs.Height, cs.Round, cs.Step))\n\n\tdefer func() {\n\t\t// Done enterPrevoteWait:\n\t\tcs.updateRoundStep(round, cstypes.RoundStepPrevoteWait)\n\t\tcs.newStep()\n\t}()\n\n\t// Wait for some more prevotes; enterPrecommit\n\tcs.scheduleTimeout(cs.config.Prevote(round), height, round, cstypes.RoundStepPrevoteWait)\n}\n\n// Enter: any +2/3 precommits for next round.\nfunc (cs *State) enterPrecommitWait(height int64, round int32) {\n\tlogger := cs.Logger.With(\"height\", height, \"round\", round)\n\n\tif cs.Height != height || round < cs.Round || (cs.Round == round && cs.TriggeredTimeoutPrecommit) {\n\t\tlogger.Debug(\n\t\t\tfmt.Sprintf(\n\t\t\t\t\"enterPrecommitWait(%v/%v): Invalid args. \"+\n\t\t\t\t\t\"Current state is Height/Round: %v/%v/, TriggeredTimeoutPrecommit:%v\",\n\t\t\t\theight, round, cs.Height, cs.Round, cs.TriggeredTimeoutPrecommit))\n\t\treturn\n\t}\n\tif !cs.Votes.Precommits(round).HasTwoThirdsAny() {\n\t\tpanic(fmt.Sprintf(\"enterPrecommitWait(%v/%v), but Precommits does not have any +2/3 votes\", height, round))\n\t}\n\tlogger.Info(fmt.Sprintf(\"enterPrecommitWait(%v/%v). Current: %v/%v/%v\", height, round, cs.Height, cs.Round, cs.Step))\n\n\tdefer func() {\n\t\t// Done enterPrecommitWait:\n\t\tcs.TriggeredTimeoutPrecommit = true\n\t\tcs.newStep()\n\t}()\n\n\t// Wait for some more precommits; enterNewRound\n\tcs.scheduleTimeout(cs.config.Precommit(round), height, round, cstypes.RoundStepPrecommitWait)\n}\n\n// Enter: +2/3 precommits for block\nfunc (cs *State) enterCommit(height int64, commitRound int32) {\n\tlogger := cs.Logger.With(\"height\", height, \"commitRound\", commitRound)\n\n\tif cs.Height != height || cstypes.RoundStepCommit <= cs.Step {\n\t\tlogger.Debug(fmt.Sprintf(\n\t\t\t\"enterCommit(%v/%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tcommitRound,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\tlogger.Info(fmt.Sprintf(\"enterCommit(%v/%v). Current: %v/%v/%v\", height, commitRound, cs.Height, cs.Round, cs.Step))\n\n\tdefer func() {\n\t\t// Done enterCommit:\n\t\t// keep cs.Round the same, commitRound points to the right Precommits set.\n\t\tcs.updateRoundStep(cs.Round, cstypes.RoundStepCommit)\n\t\tcs.CommitRound = commitRound\n\t\tcs.CommitTime = tmtime.Now()\n\t\tcs.newStep()\n\n\t\t// Maybe finalize immediately.\n\t\tcs.tryFinalizeCommit(height)\n\t}()\n\n\tblockID, ok := cs.Votes.Precommits(commitRound).TwoThirdsMajority()\n\tif !ok {\n\t\tpanic(\"RunActionCommit() expects +2/3 precommits\")\n\t}\n\n\t// The Locked* fields no longer matter.\n\t// Move them over to ProposalBlock if they match the commit hash,\n\t// otherwise they'll be cleared in updateToState.\n\tif cs.LockedBlock.HashesTo(blockID.Hash) {\n\t\tlogger.Info(\"Commit is for locked block. Set ProposalBlock=LockedBlock\", \"blockHash\", blockID.Hash)\n\t\tcs.ProposalBlock = cs.LockedBlock\n\t\tcs.ProposalBlockParts = cs.LockedBlockParts\n\t}\n\n\t// If we don't have the block being committed, set up to get it.\n\tif !cs.ProposalBlock.HashesTo(blockID.Hash) {\n\t\tif !cs.ProposalBlockParts.HasHeader(blockID.PartSetHeader) {\n\t\t\tlogger.Info(\n\t\t\t\t\"Commit is for a block we don't know about. Set ProposalBlock=nil\",\n\t\t\t\t\"proposal\",\n\t\t\t\tcs.ProposalBlock.Hash(),\n\t\t\t\t\"commit\",\n\t\t\t\tblockID.Hash)\n\t\t\t// We're getting the wrong block.\n\t\t\t// Set up ProposalBlockParts and keep waiting.\n\t\t\tcs.ProposalBlock = nil\n\t\t\tcs.ProposalBlockParts = types.NewPartSetFromHeader(blockID.PartSetHeader)\n\t\t\tif err := cs.eventBus.PublishEventValidBlock(cs.RoundStateEvent()); err != nil {\n\t\t\t\tcs.Logger.Error(\"Error publishing valid block\", \"err\", err)\n\t\t\t}\n\t\t\tcs.evsw.FireEvent(types.EventValidBlock, &cs.RoundState)\n\t\t}\n\t\t// else {\n\t\t// We just need to keep waiting.\n\t\t// }\n\t}\n}\n\n// If we have the block AND +2/3 commits for it, finalize.\nfunc (cs *State) tryFinalizeCommit(height int64) {\n\tlogger := cs.Logger.With(\"height\", height)\n\n\tif cs.Height != height {\n\t\tpanic(fmt.Sprintf(\"tryFinalizeCommit() cs.Height: %v vs height: %v\", cs.Height, height))\n\t}\n\n\tblockID, ok := cs.Votes.Precommits(cs.CommitRound).TwoThirdsMajority()\n\tif !ok || len(blockID.Hash) == 0 {\n\t\tlogger.Error(\"Attempt to finalize failed. There was no +2/3 majority, or +2/3 was for <nil>.\")\n\t\treturn\n\t}\n\tif !cs.ProposalBlock.HashesTo(blockID.Hash) {\n\t\t// TODO: this happens every time if we're not a validator (ugly logs)\n\t\t// TODO: ^^ wait, why does it matter that we're a validator?\n\t\tlogger.Info(\n\t\t\t\"Attempt to finalize failed. We don't have the commit block.\",\n\t\t\t\"proposal-block\",\n\t\t\tcs.ProposalBlock.Hash(),\n\t\t\t\"commit-block\",\n\t\t\tblockID.Hash)\n\t\treturn\n\t}\n\n\t//\tgo\n\tcs.finalizeCommit(height)\n}\n\n// Increment height and goto cstypes.RoundStepNewHeight\nfunc (cs *State) finalizeCommit(height int64) {\n\tif cs.Height != height || cs.Step != cstypes.RoundStepCommit {\n\t\tcs.Logger.Debug(fmt.Sprintf(\n\t\t\t\"finalizeCommit(%v): Invalid args. Current step: %v/%v/%v\",\n\t\t\theight,\n\t\t\tcs.Height,\n\t\t\tcs.Round,\n\t\t\tcs.Step))\n\t\treturn\n\t}\n\n\tblockID, ok := cs.Votes.Precommits(cs.CommitRound).TwoThirdsMajority()\n\tblock, blockParts := cs.ProposalBlock, cs.ProposalBlockParts\n\n\tif !ok {\n\t\tpanic(\"Cannot finalizeCommit, commit does not have two thirds majority\")\n\t}\n\tif !blockParts.HasHeader(blockID.PartSetHeader) {\n\t\tpanic(\"Expected ProposalBlockParts header to be commit header\")\n\t}\n\tif !block.HashesTo(blockID.Hash) {\n\t\tpanic(\"Cannot finalizeCommit, ProposalBlock does not hash to commit hash\")\n\t}\n\tif err := cs.blockExec.ValidateBlock(cs.state, block); err != nil {\n\t\tpanic(fmt.Errorf(\"+2/3 committed an invalid block: %w\", err))\n\t}\n\n\tcs.Logger.Info(\"Finalizing commit of block with N txs\",\n\t\t\"height\", block.Height,\n\t\t\"hash\", block.Hash(),\n\t\t\"root\", block.AppHash,\n\t\t\"N\", len(block.Txs))\n\tcs.Logger.Info(fmt.Sprintf(\"%v\", block))\n\n\tfail.Fail() // XXX\n\n\t// Save to blockStore.\n\tif cs.blockStore.Height() < block.Height {\n\t\t// NOTE: the seenCommit is local justification to commit this block,\n\t\t// but may differ from the LastCommit included in the next block\n\t\tprecommits := cs.Votes.Precommits(cs.CommitRound)\n\t\tseenCommit := precommits.MakeCommit()\n\t\tcs.blockStore.SaveBlock(block, blockParts, seenCommit)\n\t} else {\n\t\t// Happens during replay if we already saved the block but didn't commit\n\t\tcs.Logger.Info(\"Calling finalizeCommit on already stored block\", \"height\", block.Height)\n\t}\n\n\tfail.Fail() // XXX\n\n\t// Write EndHeightMessage{} for this height, implying that the blockstore\n\t// has saved the block.\n\t//\n\t// If we crash before writing this EndHeightMessage{}, we will recover by\n\t// running ApplyBlock during the ABCI handshake when we restart.  If we\n\t// didn't save the block to the blockstore before writing\n\t// EndHeightMessage{}, we'd have to change WAL replay -- currently it\n\t// complains about replaying for heights where an #ENDHEIGHT entry already\n\t// exists.\n\t//\n\t// Either way, the State should not be resumed until we\n\t// successfully call ApplyBlock (ie. later here, or in Handshake after\n\t// restart).\n\tendMsg := EndHeightMessage{height}\n\tif err := cs.wal.WriteSync(endMsg); err != nil { // NOTE: fsync\n\t\tpanic(fmt.Sprintf(\"Failed to write %v msg to consensus wal due to %v. Check your FS and restart the node\",\n\t\t\tendMsg, err))\n\t}\n\n\tfail.Fail() // XXX\n\n\t// Create a copy of the state for staging and an event cache for txs.\n\tstateCopy := cs.state.Copy()\n\n\t// Execute and commit the block, update and save the state, and update the mempool.\n\t// NOTE The block.AppHash wont reflect these txs until the next block.\n\tvar err error\n\tvar retainHeight int64\n\tstateCopy, retainHeight, err = cs.blockExec.ApplyBlock(\n\t\tstateCopy,\n\t\ttypes.BlockID{Hash: block.Hash(), PartSetHeader: blockParts.Header()},\n\t\tblock)\n\tif err != nil {\n\t\tcs.Logger.Error(\"Error on ApplyBlock\", \"err\", err)\n\t\treturn\n\t}\n\n\tfail.Fail() // XXX\n\n\t// Prune old heights, if requested by ABCI app.\n\tif retainHeight > 0 {\n\t\tpruned, err := cs.pruneBlocks(retainHeight)\n\t\tif err != nil {\n\t\t\tcs.Logger.Error(\"Failed to prune blocks\", \"retainHeight\", retainHeight, \"err\", err)\n\t\t} else {\n\t\t\tcs.Logger.Info(\"Pruned blocks\", \"pruned\", pruned, \"retainHeight\", retainHeight)\n\t\t}\n\t}\n\n\t// must be called before we update state\n\tcs.recordMetrics(height, block)\n\n\t// NewHeightStep!\n\tcs.updateToState(stateCopy)\n\n\tfail.Fail() // XXX\n\n\t// Private validator might have changed it's key pair => refetch pubkey.\n\tif err := cs.updatePrivValidatorPubKey(); err != nil {\n\t\tcs.Logger.Error(\"Can't get private validator pubkey\", \"err\", err)\n\t}\n\n\t// cs.StartTime is already set.\n\t// Schedule Round0 to start soon.\n\tcs.scheduleRound0(&cs.RoundState)\n\n\t// By here,\n\t// * cs.Height has been increment to height+1\n\t// * cs.Step is now cstypes.RoundStepNewHeight\n\t// * cs.StartTime is set to when we will start round0.\n}\n\nfunc (cs *State) pruneBlocks(retainHeight int64) (uint64, error) {\n\tbase := cs.blockStore.Base()\n\tif retainHeight <= base {\n\t\treturn 0, nil\n\t}\n\tpruned, err := cs.blockStore.PruneBlocks(retainHeight)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to prune block store: %w\", err)\n\t}\n\terr = cs.blockExec.Store().PruneStates(base, retainHeight)\n\tif err != nil {\n\t\treturn 0, fmt.Errorf(\"failed to prune state database: %w\", err)\n\t}\n\treturn pruned, nil\n}\n\nfunc (cs *State) recordMetrics(height int64, block *types.Block) {\n\tcs.metrics.Validators.Set(float64(cs.Validators.Size()))\n\tcs.metrics.ValidatorsPower.Set(float64(cs.Validators.TotalVotingPower()))\n\n\tvar (\n\t\tmissingValidators      int\n\t\tmissingValidatorsPower int64\n\t)\n\t// height=0 -> MissingValidators and MissingValidatorsPower are both 0.\n\t// Remember that the first LastCommit is intentionally empty, so it's not\n\t// fair to increment missing validators number.\n\tif height > cs.state.InitialHeight {\n\t\t// Sanity check that commit size matches validator set size - only applies\n\t\t// after first block.\n\t\tvar (\n\t\t\tcommitSize = block.LastCommit.Size()\n\t\t\tvalSetLen  = len(cs.LastValidators.Validators)\n\t\t\taddress    types.Address\n\t\t)\n\t\tif commitSize != valSetLen {\n\t\t\tpanic(fmt.Sprintf(\"commit size (%d) doesn't match valset length (%d) at height %d\\n\\n%v\\n\\n%v\",\n\t\t\t\tcommitSize, valSetLen, block.Height, block.LastCommit.Signatures, cs.LastValidators.Validators))\n\t\t}\n\n\t\tif cs.privValidator != nil {\n\t\t\tif cs.privValidatorPubKey == nil {\n\t\t\t\t// Metrics won't be updated, but it's not critical.\n\t\t\t\tcs.Logger.Error(fmt.Sprintf(\"recordMetrics: %v\", errPubKeyIsNotSet))\n\t\t\t} else {\n\t\t\t\taddress = cs.privValidatorPubKey.Address()\n\t\t\t}\n\t\t}\n\n\t\tfor i, val := range cs.LastValidators.Validators {\n\t\t\tcommitSig := block.LastCommit.Signatures[i]\n\t\t\tif commitSig.Absent() {\n\t\t\t\tmissingValidators++\n\t\t\t\tmissingValidatorsPower += val.VotingPower\n\t\t\t}\n\n\t\t\tif bytes.Equal(val.Address, address) {\n\t\t\t\tlabel := []string{\n\t\t\t\t\t\"validator_address\", val.Address.String(),\n\t\t\t\t}\n\t\t\t\tcs.metrics.ValidatorPower.With(label...).Set(float64(val.VotingPower))\n\t\t\t\tif commitSig.ForBlock() {\n\t\t\t\t\tcs.metrics.ValidatorLastSignedHeight.With(label...).Set(float64(height))\n\t\t\t\t} else {\n\t\t\t\t\tcs.metrics.ValidatorMissedBlocks.With(label...).Add(float64(1))\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\tcs.metrics.MissingValidators.Set(float64(missingValidators))\n\tcs.metrics.MissingValidatorsPower.Set(float64(missingValidatorsPower))\n\n\t// NOTE: byzantine validators power and count is only for consensus evidence i.e. duplicate vote\n\tvar (\n\t\tbyzantineValidatorsPower = int64(0)\n\t\tbyzantineValidatorsCount = int64(0)\n\t)\n\tfor _, ev := range block.Evidence.Evidence {\n\t\tif dve, ok := ev.(*types.DuplicateVoteEvidence); ok {\n\t\t\tif _, val := cs.Validators.GetByAddress(dve.VoteA.ValidatorAddress); val != nil {\n\t\t\t\tbyzantineValidatorsCount++\n\t\t\t\tbyzantineValidatorsPower += val.VotingPower\n\t\t\t}\n\t\t}\n\t}\n\tcs.metrics.ByzantineValidators.Set(float64(byzantineValidatorsCount))\n\tcs.metrics.ByzantineValidatorsPower.Set(float64(byzantineValidatorsPower))\n\n\tif height > 1 {\n\t\tlastBlockMeta := cs.blockStore.LoadBlockMeta(height - 1)\n\t\tif lastBlockMeta != nil {\n\t\t\tcs.metrics.BlockIntervalSeconds.Observe(\n\t\t\t\tblock.Time.Sub(lastBlockMeta.Header.Time).Seconds(),\n\t\t\t)\n\t\t}\n\t}\n\n\tcs.metrics.NumTxs.Set(float64(len(block.Data.Txs)))\n\tcs.metrics.TotalTxs.Add(float64(len(block.Data.Txs)))\n\tcs.metrics.BlockSizeBytes.Set(float64(block.Size()))\n\tcs.metrics.CommittedHeight.Set(float64(block.Height))\n}\n\n//-----------------------------------------------------------------------------\n\n// NOTE: block is not necessarily valid.\n// Asynchronously triggers either enterPrevote (before we timeout of propose) or tryFinalizeCommit,\n// once we have the full block.\nfunc (cs *State) addProposalBlockPart(msg *BlockPartMessage, peerID p2p.ID) (added bool, err error) {\n\theight, round, part := msg.Height, msg.Round, msg.Part\n\n\t// Blocks might be reused, so round mismatch is OK\n\tif cs.Height != height {\n\t\tcs.Logger.Debug(\"Received block part from wrong height\", \"height\", height, \"round\", round)\n\t\treturn false, nil\n\t}\n\n\t// We're not expecting a block part.\n\tif cs.ProposalBlockParts == nil {\n\t\t// NOTE: this can happen when we've gone to a higher round and\n\t\t// then receive parts from the previous round - not necessarily a bad peer.\n\t\tcs.Logger.Info(\"Received a block part when we're not expecting any\",\n\t\t\t\"height\", height, \"round\", round, \"index\", part.Index, \"peer\", peerID)\n\t\treturn false, nil\n\t}\n\n\tadded, err = cs.ProposalBlockParts.AddPart(part)\n\tif err != nil {\n\t\treturn added, err\n\t}\n\tif cs.ProposalBlockParts.ByteSize() > cs.state.ConsensusParams.Block.MaxBytes {\n\t\treturn added, fmt.Errorf(\"total size of proposal block parts exceeds maximum block bytes (%d > %d)\",\n\t\t\tcs.ProposalBlockParts.ByteSize(), cs.state.ConsensusParams.Block.MaxBytes,\n\t\t)\n\t}\n\tif added && cs.ProposalBlockParts.IsComplete() {\n\t\tbz, err := ioutil.ReadAll(cs.ProposalBlockParts.GetReader())\n\t\tif err != nil {\n\t\t\treturn added, err\n\t\t}\n\n\t\tvar pbb = new(tmproto.Block)\n\t\terr = proto.Unmarshal(bz, pbb)\n\t\tif err != nil {\n\t\t\treturn added, err\n\t\t}\n\n\t\tblock, err := types.BlockFromProto(pbb)\n\t\tif err != nil {\n\t\t\treturn added, err\n\t\t}\n\n\t\tcs.ProposalBlock = block\n\t\t// NOTE: it's possible to receive complete proposal blocks for future rounds without having the proposal\n\t\tcs.Logger.Info(\"Received complete proposal block\", \"height\", cs.ProposalBlock.Height, \"hash\", cs.ProposalBlock.Hash())\n\t\tif err := cs.eventBus.PublishEventCompleteProposal(cs.CompleteProposalEvent()); err != nil {\n\t\t\tcs.Logger.Error(\"Error publishing event complete proposal\", \"err\", err)\n\t\t}\n\n\t\t// Update Valid* if we can.\n\t\tprevotes := cs.Votes.Prevotes(cs.Round)\n\t\tblockID, hasTwoThirds := prevotes.TwoThirdsMajority()\n\t\tif hasTwoThirds && !blockID.IsZero() && (cs.ValidRound < cs.Round) {\n\t\t\tif cs.ProposalBlock.HashesTo(blockID.Hash) {\n\t\t\t\tcs.Logger.Info(\"Updating valid block to new proposal block\",\n\t\t\t\t\t\"valid-round\", cs.Round, \"valid-block-hash\", cs.ProposalBlock.Hash())\n\t\t\t\tcs.ValidRound = cs.Round\n\t\t\t\tcs.ValidBlock = cs.ProposalBlock\n\t\t\t\tcs.ValidBlockParts = cs.ProposalBlockParts\n\t\t\t}\n\t\t\t// TODO: In case there is +2/3 majority in Prevotes set for some\n\t\t\t// block and cs.ProposalBlock contains different block, either\n\t\t\t// proposer is faulty or voting power of faulty processes is more\n\t\t\t// than 1/3. We should trigger in the future accountability\n\t\t\t// procedure at this point.\n\t\t}\n\n\t\tif cs.Step <= cstypes.RoundStepPropose && cs.isProposalComplete() {\n\t\t\t// Move onto the next step\n\t\t\tcs.enterPrevote(height, cs.Round)\n\t\t\tif hasTwoThirds { // this is optimisation as this will be triggered when prevote is added\n\t\t\t\tcs.enterPrecommit(height, cs.Round)\n\t\t\t}\n\t\t} else if cs.Step == cstypes.RoundStepCommit {\n\t\t\t// If we're waiting on the proposal block...\n\t\t\tcs.tryFinalizeCommit(height)\n\t\t}\n\t\treturn added, nil\n\t}\n\treturn added, nil\n}\n\n// Attempt to add the vote. if its a duplicate signature, dupeout the validator\nfunc (cs *State) tryAddVote(vote *types.Vote, peerID p2p.ID) (bool, error) {\n\tadded, err := cs.addVote(vote, peerID)\n\tif err != nil {\n\t\t// If the vote height is off, we'll just ignore it,\n\t\t// But if it's a conflicting sig, add it to the cs.evpool.\n\t\t// If it's otherwise invalid, punish peer.\n\t\t// nolint: gocritic\n\t\tif voteErr, ok := err.(*types.ErrVoteConflictingVotes); ok {\n\t\t\tif cs.privValidatorPubKey == nil {\n\t\t\t\treturn false, errPubKeyIsNotSet\n\t\t\t}\n\n\t\t\tif bytes.Equal(vote.ValidatorAddress, cs.privValidatorPubKey.Address()) {\n\t\t\t\tcs.Logger.Error(\n\t\t\t\t\t\"Found conflicting vote from ourselves. Did you unsafe_reset a validator?\",\n\t\t\t\t\t\"height\",\n\t\t\t\t\tvote.Height,\n\t\t\t\t\t\"round\",\n\t\t\t\t\tvote.Round,\n\t\t\t\t\t\"type\",\n\t\t\t\t\tvote.Type)\n\t\t\t\treturn added, err\n\t\t\t}\n\t\t\tcs.evpool.ReportConflictingVotes(voteErr.VoteA, voteErr.VoteB)\n\t\t\treturn added, err\n\t\t} else if err == types.ErrVoteNonDeterministicSignature {\n\t\t\tcs.Logger.Debug(\"Vote has non-deterministic signature\", \"err\", err)\n\t\t} else {\n\t\t\t// Either\n\t\t\t// 1) bad peer OR\n\t\t\t// 2) not a bad peer? this can also err sometimes with \"Unexpected step\" OR\n\t\t\t// 3) tmkms use with multiple validators connecting to a single tmkms instance\n\t\t\t// \t\t(https://github.com/tendermint/tendermint/issues/3839).\n\t\t\tcs.Logger.Info(\"Error attempting to add vote\", \"err\", err)\n\t\t\treturn added, ErrAddingVote\n\t\t}\n\t}\n\treturn added, nil\n}\n\n//-----------------------------------------------------------------------------\n\n// CONTRACT: cs.privValidator is not nil.\nfunc (cs *State) signVote(\n\tmsgType tmproto.SignedMsgType,\n\thash []byte,\n\theader types.PartSetHeader,\n) (*types.Vote, error) {\n\t// Flush the WAL. Otherwise, we may not recompute the same vote to sign,\n\t// and the privValidator will refuse to sign anything.\n\tif err := cs.wal.FlushAndSync(); err != nil {\n\t\treturn nil, err\n\t}\n\n\tif cs.privValidatorPubKey == nil {\n\t\treturn nil, errPubKeyIsNotSet\n\t}\n\taddr := cs.privValidatorPubKey.Address()\n\tvalIdx, _ := cs.Validators.GetByAddress(addr)\n\n\tvote := &types.Vote{\n\t\tValidatorAddress: addr,\n\t\tValidatorIndex:   valIdx,\n\t\tHeight:           cs.Height,\n\t\tRound:            cs.Round,\n\t\tTimestamp:        cs.voteTime(),\n\t\tType:             msgType,\n\t\tBlockID:          types.BlockID{Hash: hash, PartSetHeader: header},\n\t}\n\tv := vote.ToProto()\n\terr := cs.privValidator.SignVote(cs.state.ChainID, v)\n\tvote.Signature = v.Signature\n\n\treturn vote, err\n}\n\nfunc (cs *State) voteTime() time.Time {\n\tnow := tmtime.Now()\n\tminVoteTime := now\n\t// TODO: We should remove next line in case we don't vote for v in case cs.ProposalBlock == nil,\n\t// even if cs.LockedBlock != nil. See https://docs.tendermint.com/master/spec/.\n\ttimeIota := time.Duration(cs.state.ConsensusParams.Block.TimeIotaMs) * time.Millisecond\n\tif cs.LockedBlock != nil {\n\t\t// See the BFT time spec https://docs.tendermint.com/master/spec/consensus/bft-time.html\n\t\tminVoteTime = cs.LockedBlock.Time.Add(timeIota)\n\t} else if cs.ProposalBlock != nil {\n\t\tminVoteTime = cs.ProposalBlock.Time.Add(timeIota)\n\t}\n\n\tif now.After(minVoteTime) {\n\t\treturn now\n\t}\n\treturn minVoteTime\n}\n\n// sign the vote and publish on internalMsgQueue\nfunc (cs *State) signAddVote(msgType tmproto.SignedMsgType, hash []byte, header types.PartSetHeader) *types.Vote {\n\tif cs.privValidator == nil { // the node does not have a key\n\t\treturn nil\n\t}\n\n\tif cs.privValidatorPubKey == nil {\n\t\t// Vote won't be signed, but it's not critical.\n\t\tcs.Logger.Error(fmt.Sprintf(\"signAddVote: %v\", errPubKeyIsNotSet))\n\t\treturn nil\n\t}\n\n\t// If the node not in the validator set, do nothing.\n\tif !cs.Validators.HasAddress(cs.privValidatorPubKey.Address()) {\n\t\treturn nil\n\t}\n\n\t// TODO: pass pubKey to signVote\n\tvote, err := cs.signVote(msgType, hash, header)\n\tif err == nil {\n\t\tcs.sendInternalMessage(msgInfo{&VoteMessage{vote}, \"\"})\n\t\tcs.Logger.Info(\"Signed and pushed vote\", \"height\", cs.Height, \"round\", cs.Round, \"vote\", vote)\n\t\treturn vote\n\t}\n\t// if !cs.replayMode {\n\tcs.Logger.Error(\"Error signing vote\", \"height\", cs.Height, \"round\", cs.Round, \"vote\", vote, \"err\", err)\n\t//}\n\treturn nil\n}\n\n// updatePrivValidatorPubKey get's the private validator public key and\n// memoizes it. This func returns an error if the private validator is not\n// responding or responds with an error.\nfunc (cs *State) updatePrivValidatorPubKey() error {\n\tif cs.privValidator == nil {\n\t\treturn nil\n\t}\n\n\tpubKey, err := cs.privValidator.GetPubKey()\n\tif err != nil {\n\t\treturn err\n\t}\n\tcs.privValidatorPubKey = pubKey\n\treturn nil\n}\n\n// look back to check existence of the node's consensus votes before joining consensus\nfunc (cs *State) checkDoubleSigningRisk(height int64) error {\n\tif cs.privValidator != nil && cs.privValidatorPubKey != nil && cs.config.DoubleSignCheckHeight > 0 && height > 0 {\n\t\tvalAddr := cs.privValidatorPubKey.Address()\n\t\tdoubleSignCheckHeight := cs.config.DoubleSignCheckHeight\n\t\tif doubleSignCheckHeight > height {\n\t\t\tdoubleSignCheckHeight = height\n\t\t}\n\t\tfor i := int64(1); i < doubleSignCheckHeight; i++ {\n\t\t\tlastCommit := cs.blockStore.LoadSeenCommit(height - i)\n\t\t\tif lastCommit != nil {\n\t\t\t\tfor sigIdx, s := range lastCommit.Signatures {\n\t\t\t\t\tif s.BlockIDFlag == types.BlockIDFlagCommit && bytes.Equal(s.ValidatorAddress, valAddr) {\n\t\t\t\t\t\tcs.Logger.Info(\"Found signature from the same key\", \"sig\", s, \"idx\", sigIdx, \"height\", height-i)\n\t\t\t\t\t\treturn ErrSignatureFoundInPastBlocks\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn nil\n}\n\n//---------------------------------------------------------\n\nfunc CompareHRS(h1 int64, r1 int32, s1 cstypes.RoundStepType, h2 int64, r2 int32, s2 cstypes.RoundStepType) int {\n\tif h1 < h2 {\n\t\treturn -1\n\t} else if h1 > h2 {\n\t\treturn 1\n\t}\n\tif r1 < r2 {\n\t\treturn -1\n\t} else if r1 > r2 {\n\t\treturn 1\n\t}\n\tif s1 < s2 {\n\t\treturn -1\n\t} else if s1 > s2 {\n\t\treturn 1\n\t}\n\treturn 0\n}\n\n// repairWalFile decodes messages from src (until the decoder errors) and\n// writes them to dst.\nfunc repairWalFile(src, dst string) error {\n\tin, err := os.Open(src)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer in.Close()\n\n\tout, err := os.Open(dst)\n\tif err != nil {\n\t\treturn err\n\t}\n\tdefer out.Close()\n\n\tvar (\n\t\tdec = NewWALDecoder(in)\n\t\tenc = NewWALEncoder(out)\n\t)\n\n\t// best-case repair (until first error is encountered)\n\tfor {\n\t\tmsg, err := dec.Decode()\n\t\tif err != nil {\n\t\t\tbreak\n\t\t}\n\n\t\terr = enc.Encode(msg)\n\t\tif err != nil {\n\t\t\treturn fmt.Errorf(\"failed to encode msg: %w\", err)\n\t\t}\n\t}\n\n\treturn nil\n}\n"], "filenames": ["consensus/byzantine_test.go", "consensus/state.go", "evidence/pool.go", "evidence/pool_test.go", "node/node_test.go", "state/services.go", "test/maverick/consensus/state.go"], "buggy_code_start_loc": [156, 76, 44, 147, 268, 56, 468], "buggy_code_end_loc": [156, 1883, 523, 178, 270, 62, 1781], "fixing_code_start_loc": [157, 76, 44, 147, 268, 56, 468], "fixing_code_end_loc": [223, 1873, 591, 176, 269, 60, 1770], "type": "CWE-400", "message": "Tendermint Core is an open source Byzantine Fault Tolerant (BFT) middleware that takes a state transition machine - written in any programming language - and securely replicates it on many machines. Tendermint Core v0.34.0 introduced a new way of handling evidence of misbehavior. As part of this, we added a new Timestamp field to Evidence structs. This timestamp would be calculated using the same algorithm that is used when a block is created and proposed. (This algorithm relies on the timestamp of the last commit from this specific block.) In Tendermint Core v0.34.0-v0.34.2, the consensus reactor is responsible for forming DuplicateVoteEvidence whenever double signs are observed. However, the current block is still \u201cin flight\u201d when it is being formed by the consensus reactor. It hasn\u2019t been finalized through network consensus yet. This means that different nodes in the network may observe different \u201clast commits\u201d when assigning a timestamp to DuplicateVoteEvidence. In turn, different nodes could form DuplicateVoteEvidence objects at the same height but with different timestamps. One DuplicateVoteEvidence object (with one timestamp) will then eventually get finalized in the block, but this means that any DuplicateVoteEvidence with a different timestamp is considered invalid. Any node that formed invalid DuplicateVoteEvidence will continue to propose invalid evidence; its peers may see this, and choose to disconnect from this node. This bug means that double signs are DoS vectors in Tendermint Core v0.34.0-v0.34.2. Tendermint Core v0.34.3 is a security release which fixes this bug. As of v0.34.3, DuplicateVoteEvidence is no longer formed by the consensus reactor; rather, the consensus reactor passes the Votes themselves into the EvidencePool, which is now responsible for forming DuplicateVoteEvidence. The EvidencePool has timestamp info that should be consistent across the network, which means that DuplicateVoteEvidence formed in this reactor should have consistent timestamps. This release changes the API between the consensus and evidence reactors.", "other": {"cve": {"id": "CVE-2021-21271", "sourceIdentifier": "security-advisories@github.com", "published": "2021-01-26T21:15:12.503", "lastModified": "2021-02-08T21:23:08.820", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Tendermint Core is an open source Byzantine Fault Tolerant (BFT) middleware that takes a state transition machine - written in any programming language - and securely replicates it on many machines. Tendermint Core v0.34.0 introduced a new way of handling evidence of misbehavior. As part of this, we added a new Timestamp field to Evidence structs. This timestamp would be calculated using the same algorithm that is used when a block is created and proposed. (This algorithm relies on the timestamp of the last commit from this specific block.) In Tendermint Core v0.34.0-v0.34.2, the consensus reactor is responsible for forming DuplicateVoteEvidence whenever double signs are observed. However, the current block is still \u201cin flight\u201d when it is being formed by the consensus reactor. It hasn\u2019t been finalized through network consensus yet. This means that different nodes in the network may observe different \u201clast commits\u201d when assigning a timestamp to DuplicateVoteEvidence. In turn, different nodes could form DuplicateVoteEvidence objects at the same height but with different timestamps. One DuplicateVoteEvidence object (with one timestamp) will then eventually get finalized in the block, but this means that any DuplicateVoteEvidence with a different timestamp is considered invalid. Any node that formed invalid DuplicateVoteEvidence will continue to propose invalid evidence; its peers may see this, and choose to disconnect from this node. This bug means that double signs are DoS vectors in Tendermint Core v0.34.0-v0.34.2. Tendermint Core v0.34.3 is a security release which fixes this bug. As of v0.34.3, DuplicateVoteEvidence is no longer formed by the consensus reactor; rather, the consensus reactor passes the Votes themselves into the EvidencePool, which is now responsible for forming DuplicateVoteEvidence. The EvidencePool has timestamp info that should be consistent across the network, which means that DuplicateVoteEvidence formed in this reactor should have consistent timestamps. This release changes the API between the consensus and evidence reactors."}, {"lang": "es", "value": "Tendermint Core es un middleware Byzantine Fault Tolerant (BFT) de c\u00f3digo abierto que toma una m\u00e1quina de transici\u00f3n de estado, escrita en cualquier lenguaje de programaci\u00f3n, y la replica de forma segura en muchas m\u00e1quinas. Tendermint Core versi\u00f3n v0.34.0 introdujo una nueva forma de manejar la evidencia de mal comportamiento. Como parte de esto, agregamos un nuevo campo Timestamp a las estructuras Evidence. Esta marca de tiempo se calcular\u00eda usando el mismo algoritmo que se utiliza cuando un bloque sea creado y propuesto. (Este algoritmo se basa en la marca de tiempo del \u00faltimo commit de este bloque espec\u00edfico). En Tendermint Core versiones v0.34.0-v0.34.2, el reactor de consenso es responsable de formar un DuplicateVoteEvidence siempre que se observen signos dobles. Sin embargo, el bloque actual todav\u00eda est\u00e1 \"in flight\" cuando lo est\u00e1 formando el reactor de consenso. A\u00fan no se ha finalizado mediante el consenso de la red. Esto significa que diferentes nodos en la red pueden observar diferentes \"last commits\" al asignar una marca de tiempo a DuplicateVoteEvidence. A su vez, diferentes nodos podr\u00edan formar objetos DuplicateVoteEvidence a la misma altura pero con diferentes marcas de tiempo. Un objeto DuplicateVoteEvidence (con una marca de tiempo) finalmente se finalizar\u00e1 en el bloque, pero esto significa que cualquier DuplicateVoteEvidence con una marca de tiempo diferente se considera inv\u00e1lido. Cualquier nodo que form\u00f3 un DuplicateVoteEvidence inv\u00e1lido continuar\u00e1 proponiendo evidencia inv\u00e1lida; sus peers pueden visualizar esto y optar por desconectarse de este nodo. Este error significa que los signos dobles son vectores de DoS en Tendermint Core versiones v0.34.0-v0.34.2. Tendermint Core versi\u00f3n v0.34.3 es una versi\u00f3n de seguridad que corrige este error. A partir de la versi\u00f3n 0.34.3, DuplicateVoteEvidence ya no est\u00e1 formado por el reactor de consenso; m\u00e1s bien, el reactor de consenso pasa los Votos mismos al EvidencePool, que ahora es responsable de formar un DuplicateVoteEvidence. EvidencePool posee informaci\u00f3n de marca de tiempo que debe ser consistente en toda la red, lo que significa que un DuplicateVoteEvidence formado en este reactor debe tener marcas de tiempo consistentes. Esta versi\u00f3n cambia la API entre los reactores de consenso y evidencia"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tendermint:tendermint:*:*:*:*:*:*:*:*", "versionStartIncluding": "0.34.0", "versionEndIncluding": "0.34.2", "matchCriteriaId": "E506A553-4EE9-4251-8C60-DF2EA5EB2E98"}]}]}], "references": [{"url": "https://github.com/tendermint/tendermint/blob/v0.34.3/CHANGELOG.md#v0.34.3", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/tendermint/tendermint/commit/a2a6852ab99e4a0f9e79f0ea8c1726e262e25c76", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/tendermint/tendermint/security/advisories/GHSA-p658-8693-mhvg", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tendermint/tendermint/commit/a2a6852ab99e4a0f9e79f0ea8c1726e262e25c76"}}