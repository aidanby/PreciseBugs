{"buggy_code": ["package org.airsonic.player.security;\n\nimport org.airsonic.player.service.JWTSecurityService;\nimport org.airsonic.player.service.SecurityService;\nimport org.airsonic.player.service.SettingsService;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.security.SecurityProperties;\nimport org.springframework.context.ApplicationEventPublisher;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.authentication.configurers.GlobalAuthenticationConfigurerAdapter;\nimport org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.config.http.SessionCreationPolicy;\nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;\nimport org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter;\nimport org.springframework.security.web.util.matcher.AntPathRequestMatcher;\n\n@Configuration\n@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER)\n@EnableGlobalMethodSecurity(securedEnabled = true, prePostEnabled = true)\npublic class GlobalSecurityConfig extends GlobalAuthenticationConfigurerAdapter {\n\n    private static Logger logger = LoggerFactory.getLogger(GlobalSecurityConfig.class);\n\n    static final String FAILURE_URL = \"/login?error=1\";\n\n    @Autowired\n    private SecurityService securityService;\n\n    @Autowired\n    private CsrfSecurityRequestMatcher csrfSecurityRequestMatcher;\n\n    @Autowired\n    SettingsService settingsService;\n\n    @Autowired\n    CustomUserDetailsContextMapper customUserDetailsContextMapper;\n\n    @Autowired\n    ApplicationEventPublisher eventPublisher;\n\n    @Autowired\n    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {\n        if (settingsService.isLdapEnabled()) {\n            auth.ldapAuthentication()\n                    .contextSource()\n                        .managerDn(settingsService.getLdapManagerDn())\n                        .managerPassword(settingsService.getLdapManagerPassword())\n                        .url(settingsService.getLdapUrl())\n                    .and()\n                    .userSearchFilter(settingsService.getLdapSearchFilter())\n                    .userDetailsContextMapper(customUserDetailsContextMapper);\n        }\n        auth.userDetailsService(securityService);\n        String jwtKey = settingsService.getJWTKey();\n        if(StringUtils.isBlank(jwtKey)) {\n            logger.warn(\"Generating new jwt key\");\n            jwtKey = JWTSecurityService.generateKey();\n            settingsService.setJWTKey(jwtKey);\n            settingsService.save();\n        }\n        auth.authenticationProvider(new JWTAuthenticationProvider(jwtKey));\n    }\n\n\n    @Configuration\n    @Order(1)\n    public class ExtSecurityConfiguration extends WebSecurityConfigurerAdapter {\n\n        public ExtSecurityConfiguration() {\n            super(true);\n        }\n\n        @Bean(name = \"jwtAuthenticationFilter\")\n        public JWTRequestParameterProcessingFilter jwtAuthFilter() throws Exception {\n            return new JWTRequestParameterProcessingFilter(authenticationManager(), FAILURE_URL);\n        }\n\n        @Override\n        protected void configure(HttpSecurity http) throws Exception {\n\n            http = http.addFilter(new WebAsyncManagerIntegrationFilter());\n            http = http.addFilterBefore(jwtAuthFilter(), UsernamePasswordAuthenticationFilter.class);\n\n            http\n                    .antMatcher(\"/ext/**\")\n                    .csrf().requireCsrfProtectionMatcher(csrfSecurityRequestMatcher).and()\n                    .headers().frameOptions().sameOrigin().and()\n                    .authorizeRequests()\n                    .antMatchers(\"/ext/stream/**\", \"/ext/coverArt*\", \"/ext/share/**\", \"/ext/hls/**\")\n                    .hasAnyRole(\"TEMP\", \"USER\").and()\n                    .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()\n                    .exceptionHandling().and()\n                    .securityContext().and()\n                    .requestCache().and()\n                    .anonymous().and()\n                    .servletApi();\n        }\n    }\n\n    @Configuration\n    @Order(2)\n    public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n\n        @Override\n        protected void configure(HttpSecurity http) throws Exception {\n\n            RESTRequestParameterProcessingFilter restAuthenticationFilter = new RESTRequestParameterProcessingFilter();\n            restAuthenticationFilter.setAuthenticationManager(authenticationManagerBean());\n            restAuthenticationFilter.setSecurityService(securityService);\n            restAuthenticationFilter.setEventPublisher(eventPublisher);\n            http = http.addFilterBefore(restAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);\n\n            http\n                    .csrf()\n                    .requireCsrfProtectionMatcher(csrfSecurityRequestMatcher)\n                    .and().headers()\n                    .frameOptions()\n                    .sameOrigin()\n                    .and().authorizeRequests()\n                    .antMatchers(\"/recover*\", \"/accessDenied*\",\n                            \"/style/**\", \"/icons/**\", \"/flash/**\", \"/script/**\",\n                            \"/sonos/**\", \"/crossdomain.xml\", \"/login\", \"/error\")\n                    .permitAll()\n                    .antMatchers(\"/personalSettings*\", \"/passwordSettings*\",\n                            \"/playerSettings*\", \"/shareSettings*\", \"/passwordSettings*\")\n                    .hasRole(\"SETTINGS\")\n                    .antMatchers(\"/generalSettings*\", \"/advancedSettings*\", \"/userSettings*\",\n                            \"/musicFolderSettings*\", \"/databaseSettings*\", \"/transcodeSettings*\", \"/rest/startScan*\")\n                    .hasRole(\"ADMIN\")\n                    .antMatchers(\"/deletePlaylist*\", \"/savePlaylist*\", \"/db*\")\n                    .hasRole(\"PLAYLIST\")\n                    .antMatchers(\"/download*\")\n                    .hasRole(\"DOWNLOAD\")\n                    .antMatchers(\"/upload*\")\n                    .hasRole(\"UPLOAD\")\n                    .antMatchers(\"/createShare*\")\n                    .hasRole(\"SHARE\")\n                    .antMatchers(\"/changeCoverArt*\", \"/editTags*\")\n                    .hasRole(\"COVERART\")\n                    .antMatchers(\"/setMusicFileInfo*\")\n                    .hasRole(\"COMMENT\")\n                    .antMatchers(\"/podcastReceiverAdmin*\")\n                    .hasRole(\"PODCAST\")\n                    .antMatchers(\"/**\")\n                    .hasRole(\"USER\")\n                    .anyRequest().authenticated()\n                    .and().formLogin()\n                    .loginPage(\"/login\")\n                    .permitAll()\n                    .defaultSuccessUrl(\"/index\", true)\n                    .failureUrl(FAILURE_URL)\n                    .usernameParameter(\"j_username\")\n                    .passwordParameter(\"j_password\")\n                    // see http://docs.spring.io/spring-security/site/docs/3.2.4.RELEASE/reference/htmlsingle/#csrf-logout\n                    .and().logout().logoutRequestMatcher(new AntPathRequestMatcher(\"/logout\", \"GET\")).logoutSuccessUrl(\n                    \"/login?logout\")\n                    .and().rememberMe().key(\"airsonic\");\n        }\n\n    }\n}"], "fixing_code": ["package org.airsonic.player.security;\n\nimport org.airsonic.player.service.JWTSecurityService;\nimport org.airsonic.player.service.SecurityService;\nimport org.airsonic.player.service.SettingsService;\nimport org.apache.commons.lang3.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.autoconfigure.security.SecurityProperties;\nimport org.springframework.context.ApplicationEventPublisher;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.core.annotation.Order;\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.authentication.configurers.GlobalAuthenticationConfigurerAdapter;\nimport org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.config.http.SessionCreationPolicy;\nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;\nimport org.springframework.security.web.context.request.async.WebAsyncManagerIntegrationFilter;\nimport org.springframework.security.web.util.matcher.AntPathRequestMatcher;\n\nimport java.security.SecureRandom;\n\n@Configuration\n@Order(SecurityProperties.ACCESS_OVERRIDE_ORDER)\n@EnableGlobalMethodSecurity(securedEnabled = true, prePostEnabled = true)\npublic class GlobalSecurityConfig extends GlobalAuthenticationConfigurerAdapter {\n\n    private static Logger logger = LoggerFactory.getLogger(GlobalSecurityConfig.class);\n\n    static final String FAILURE_URL = \"/login?error=1\";\n\n    private static final String key;\n\n    static {\n      byte[] array = new byte[32];\n      new SecureRandom().nextBytes(array);\n      key = new String(array);\n    }\n\n    @Autowired\n    private SecurityService securityService;\n\n    @Autowired\n    private CsrfSecurityRequestMatcher csrfSecurityRequestMatcher;\n\n    @Autowired\n    SettingsService settingsService;\n\n    @Autowired\n    CustomUserDetailsContextMapper customUserDetailsContextMapper;\n\n    @Autowired\n    ApplicationEventPublisher eventPublisher;\n\n    @Autowired\n    public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {\n        if (settingsService.isLdapEnabled()) {\n            auth.ldapAuthentication()\n                    .contextSource()\n                        .managerDn(settingsService.getLdapManagerDn())\n                        .managerPassword(settingsService.getLdapManagerPassword())\n                        .url(settingsService.getLdapUrl())\n                    .and()\n                    .userSearchFilter(settingsService.getLdapSearchFilter())\n                    .userDetailsContextMapper(customUserDetailsContextMapper);\n        }\n        auth.userDetailsService(securityService);\n        String jwtKey = settingsService.getJWTKey();\n        if(StringUtils.isBlank(jwtKey)) {\n            logger.warn(\"Generating new jwt key\");\n            jwtKey = JWTSecurityService.generateKey();\n            settingsService.setJWTKey(jwtKey);\n            settingsService.save();\n        }\n        auth.authenticationProvider(new JWTAuthenticationProvider(jwtKey));\n    }\n\n\n    @Configuration\n    @Order(1)\n    public class ExtSecurityConfiguration extends WebSecurityConfigurerAdapter {\n\n        public ExtSecurityConfiguration() {\n            super(true);\n        }\n\n        @Bean(name = \"jwtAuthenticationFilter\")\n        public JWTRequestParameterProcessingFilter jwtAuthFilter() throws Exception {\n            return new JWTRequestParameterProcessingFilter(authenticationManager(), FAILURE_URL);\n        }\n\n        @Override\n        protected void configure(HttpSecurity http) throws Exception {\n\n            http = http.addFilter(new WebAsyncManagerIntegrationFilter());\n            http = http.addFilterBefore(jwtAuthFilter(), UsernamePasswordAuthenticationFilter.class);\n\n            http\n                    .antMatcher(\"/ext/**\")\n                    .csrf().requireCsrfProtectionMatcher(csrfSecurityRequestMatcher).and()\n                    .headers().frameOptions().sameOrigin().and()\n                    .authorizeRequests()\n                    .antMatchers(\"/ext/stream/**\", \"/ext/coverArt*\", \"/ext/share/**\", \"/ext/hls/**\")\n                    .hasAnyRole(\"TEMP\", \"USER\").and()\n                    .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()\n                    .exceptionHandling().and()\n                    .securityContext().and()\n                    .requestCache().and()\n                    .anonymous().and()\n                    .servletApi();\n        }\n    }\n\n    @Configuration\n    @Order(2)\n    public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n\n        @Override\n        protected void configure(HttpSecurity http) throws Exception {\n\n            RESTRequestParameterProcessingFilter restAuthenticationFilter = new RESTRequestParameterProcessingFilter();\n            restAuthenticationFilter.setAuthenticationManager(authenticationManagerBean());\n            restAuthenticationFilter.setSecurityService(securityService);\n            restAuthenticationFilter.setEventPublisher(eventPublisher);\n            http = http.addFilterBefore(restAuthenticationFilter, UsernamePasswordAuthenticationFilter.class);\n\n            http\n                    .csrf()\n                    .requireCsrfProtectionMatcher(csrfSecurityRequestMatcher)\n                    .and().headers()\n                    .frameOptions()\n                    .sameOrigin()\n                    .and().authorizeRequests()\n                    .antMatchers(\"/recover*\", \"/accessDenied*\",\n                            \"/style/**\", \"/icons/**\", \"/flash/**\", \"/script/**\",\n                            \"/sonos/**\", \"/crossdomain.xml\", \"/login\", \"/error\")\n                    .permitAll()\n                    .antMatchers(\"/personalSettings*\", \"/passwordSettings*\",\n                            \"/playerSettings*\", \"/shareSettings*\", \"/passwordSettings*\")\n                    .hasRole(\"SETTINGS\")\n                    .antMatchers(\"/generalSettings*\", \"/advancedSettings*\", \"/userSettings*\",\n                            \"/musicFolderSettings*\", \"/databaseSettings*\", \"/transcodeSettings*\", \"/rest/startScan*\")\n                    .hasRole(\"ADMIN\")\n                    .antMatchers(\"/deletePlaylist*\", \"/savePlaylist*\", \"/db*\")\n                    .hasRole(\"PLAYLIST\")\n                    .antMatchers(\"/download*\")\n                    .hasRole(\"DOWNLOAD\")\n                    .antMatchers(\"/upload*\")\n                    .hasRole(\"UPLOAD\")\n                    .antMatchers(\"/createShare*\")\n                    .hasRole(\"SHARE\")\n                    .antMatchers(\"/changeCoverArt*\", \"/editTags*\")\n                    .hasRole(\"COVERART\")\n                    .antMatchers(\"/setMusicFileInfo*\")\n                    .hasRole(\"COMMENT\")\n                    .antMatchers(\"/podcastReceiverAdmin*\")\n                    .hasRole(\"PODCAST\")\n                    .antMatchers(\"/**\")\n                    .hasRole(\"USER\")\n                    .anyRequest().authenticated()\n                    .and().formLogin()\n                    .loginPage(\"/login\")\n                    .permitAll()\n                    .defaultSuccessUrl(\"/index\", true)\n                    .failureUrl(FAILURE_URL)\n                    .usernameParameter(\"j_username\")\n                    .passwordParameter(\"j_password\")\n                    // see http://docs.spring.io/spring-security/site/docs/3.2.4.RELEASE/reference/htmlsingle/#csrf-logout\n                    .and().logout().logoutRequestMatcher(new AntPathRequestMatcher(\"/logout\", \"GET\")).logoutSuccessUrl(\n                    \"/login?logout\")\n                    .and().rememberMe().key(key);\n        }\n\n    }\n}\n"], "filenames": ["airsonic-main/src/main/java/org/airsonic/player/security/GlobalSecurityConfig.java"], "buggy_code_start_loc": [24], "buggy_code_end_loc": [170], "fixing_code_start_loc": [25], "fixing_code_end_loc": [180], "type": "CWE-326", "message": "Airsonic 10.2.1 uses Spring's default remember-me mechanism based on MD5, with a fixed key of airsonic in GlobalSecurityConfig.java. An attacker able to capture cookies might be able to trivially bruteforce offline the passwords of associated users.", "other": {"cve": {"id": "CVE-2019-10907", "sourceIdentifier": "cve@mitre.org", "published": "2019-04-07T14:29:00.237", "lastModified": "2020-08-24T17:37:01.140", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Airsonic 10.2.1 uses Spring's default remember-me mechanism based on MD5, with a fixed key of airsonic in GlobalSecurityConfig.java. An attacker able to capture cookies might be able to trivially bruteforce offline the passwords of associated users."}, {"lang": "es", "value": "Airsonic 10.2.1 utiliza por defecto el mecanismo remember-me basado en MD5 de Spring con una clave fija de airsonic en GlobalSecurityConfig.java. Un atacante capaz de capturar cookies podr\u00eda simplemente obtener las contrase\u00f1as offline de los usuarios asociados mediante el uso de fuerza bruta."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-326"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:airsonic_project:airsonic:10.2.1:*:*:*:*:*:*:*", "matchCriteriaId": "14222F88-F6AA-426E-B705-FB3B872E65CC"}]}]}], "references": [{"url": "https://github.com/airsonic/airsonic/commit/3e07ea52885f88d3fbec444dfd592f27bfb65647", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/airsonic/airsonic/commit/3e07ea52885f88d3fbec444dfd592f27bfb65647"}}