{"buggy_code": ["/*\n *  linux/fs/ext4/inode.c\n *\n * Copyright (C) 1992, 1993, 1994, 1995\n * Remy Card (card@masi.ibp.fr)\n * Laboratoire MASI - Institut Blaise Pascal\n * Universite Pierre et Marie Curie (Paris VI)\n *\n *  from\n *\n *  linux/fs/minix/inode.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n *\n *  64-bit file support on 64-bit platforms by Jakub Jelinek\n *\t(jj@sunsite.ms.mff.cuni.cz)\n *\n *  Assorted race fixes, rewrite of ext4_get_block() by Al Viro, 2000\n */\n\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/highuid.h>\n#include <linux/pagemap.h>\n#include <linux/dax.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/bio.h>\n#include <linux/workqueue.h>\n#include <linux/kernel.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\n#include \"ext4_jbd2.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"truncate.h\"\n\n#include <trace/events/ext4.h>\n\n#define MPAGE_DA_EXTENT_TAIL 0x01\n\nstatic __u32 ext4_inode_csum(struct inode *inode, struct ext4_inode *raw,\n\t\t\t      struct ext4_inode_info *ei)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u16 csum_lo;\n\t__u16 csum_hi = 0;\n\t__u32 csum;\n\n\tcsum_lo = le16_to_cpu(raw->i_checksum_lo);\n\traw->i_checksum_lo = 0;\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw, ei, i_checksum_hi)) {\n\t\tcsum_hi = le16_to_cpu(raw->i_checksum_hi);\n\t\traw->i_checksum_hi = 0;\n\t}\n\n\tcsum = ext4_chksum(sbi, ei->i_csum_seed, (__u8 *)raw,\n\t\t\t   EXT4_INODE_SIZE(inode->i_sb));\n\n\traw->i_checksum_lo = cpu_to_le16(csum_lo);\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw, ei, i_checksum_hi))\n\t\traw->i_checksum_hi = cpu_to_le16(csum_hi);\n\n\treturn csum;\n}\n\nstatic int ext4_inode_csum_verify(struct inode *inode, struct ext4_inode *raw,\n\t\t\t\t  struct ext4_inode_info *ei)\n{\n\t__u32 provided, calculated;\n\n\tif (EXT4_SB(inode->i_sb)->s_es->s_creator_os !=\n\t    cpu_to_le32(EXT4_OS_LINUX) ||\n\t    !ext4_has_metadata_csum(inode->i_sb))\n\t\treturn 1;\n\n\tprovided = le16_to_cpu(raw->i_checksum_lo);\n\tcalculated = ext4_inode_csum(inode, raw, ei);\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw, ei, i_checksum_hi))\n\t\tprovided |= ((__u32)le16_to_cpu(raw->i_checksum_hi)) << 16;\n\telse\n\t\tcalculated &= 0xFFFF;\n\n\treturn provided == calculated;\n}\n\nstatic void ext4_inode_csum_set(struct inode *inode, struct ext4_inode *raw,\n\t\t\t\tstruct ext4_inode_info *ei)\n{\n\t__u32 csum;\n\n\tif (EXT4_SB(inode->i_sb)->s_es->s_creator_os !=\n\t    cpu_to_le32(EXT4_OS_LINUX) ||\n\t    !ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\tcsum = ext4_inode_csum(inode, raw, ei);\n\traw->i_checksum_lo = cpu_to_le16(csum & 0xFFFF);\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw, ei, i_checksum_hi))\n\t\traw->i_checksum_hi = cpu_to_le16(csum >> 16);\n}\n\nstatic inline int ext4_begin_ordered_truncate(struct inode *inode,\n\t\t\t\t\t      loff_t new_size)\n{\n\ttrace_ext4_begin_ordered_truncate(inode, new_size);\n\t/*\n\t * If jinode is zero, then we never opened the file for\n\t * writing, so there's no need to call\n\t * jbd2_journal_begin_ordered_truncate() since there's no\n\t * outstanding writes we need to flush.\n\t */\n\tif (!EXT4_I(inode)->jinode)\n\t\treturn 0;\n\treturn jbd2_journal_begin_ordered_truncate(EXT4_JOURNAL(inode),\n\t\t\t\t\t\t   EXT4_I(inode)->jinode,\n\t\t\t\t\t\t   new_size);\n}\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\nstatic int ext4_meta_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t  int pextents);\n\n/*\n * Test whether an inode is a fast symlink.\n */\nint ext4_inode_is_fast_symlink(struct inode *inode)\n{\n        int ea_blocks = EXT4_I(inode)->i_file_acl ?\n\t\tEXT4_CLUSTER_SIZE(inode->i_sb) >> 9 : 0;\n\n\tif (ext4_has_inline_data(inode))\n\t\treturn 0;\n\n\treturn (S_ISLNK(inode->i_mode) && inode->i_blocks - ea_blocks == 0);\n}\n\n/*\n * Restart the transaction associated with *handle.  This does a commit,\n * so before we call here everything must be consistently dirtied against\n * this transaction.\n */\nint ext4_truncate_restart_trans(handle_t *handle, struct inode *inode,\n\t\t\t\t int nblocks)\n{\n\tint ret;\n\n\t/*\n\t * Drop i_data_sem to avoid deadlock with ext4_map_blocks.  At this\n\t * moment, get_block can be called only for blocks inside i_size since\n\t * page cache has been already dropped and writes are blocked by\n\t * i_mutex. So we can safely drop the i_data_sem here.\n\t */\n\tBUG_ON(EXT4_JOURNAL(inode) == NULL);\n\tjbd_debug(2, \"restarting handle %p\\n\", handle);\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tret = ext4_journal_restart(handle, nblocks);\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\treturn ret;\n}\n\n/*\n * Called at the last iput() if i_nlink is zero.\n */\nvoid ext4_evict_inode(struct inode *inode)\n{\n\thandle_t *handle;\n\tint err;\n\n\ttrace_ext4_evict_inode(inode);\n\n\tif (inode->i_nlink) {\n\t\t/*\n\t\t * When journalling data dirty buffers are tracked only in the\n\t\t * journal. So although mm thinks everything is clean and\n\t\t * ready for reaping the inode might still have some pages to\n\t\t * write in the running transaction or waiting to be\n\t\t * checkpointed. Thus calling jbd2_journal_invalidatepage()\n\t\t * (via truncate_inode_pages()) to discard these buffers can\n\t\t * cause data loss. Also even if we did not discard these\n\t\t * buffers, we would have no way to find them after the inode\n\t\t * is reaped and thus user could see stale data if he tries to\n\t\t * read them before the transaction is checkpointed. So be\n\t\t * careful and force everything to disk here... We use\n\t\t * ei->i_datasync_tid to store the newest transaction\n\t\t * containing inode's data.\n\t\t *\n\t\t * Note that directories do not have this problem because they\n\t\t * don't use page cache.\n\t\t */\n\t\tif (ext4_should_journal_data(inode) &&\n\t\t    (S_ISLNK(inode->i_mode) || S_ISREG(inode->i_mode)) &&\n\t\t    inode->i_ino != EXT4_JOURNAL_INO) {\n\t\t\tjournal_t *journal = EXT4_SB(inode->i_sb)->s_journal;\n\t\t\ttid_t commit_tid = EXT4_I(inode)->i_datasync_tid;\n\n\t\t\tjbd2_complete_transaction(journal, commit_tid);\n\t\t\tfilemap_write_and_wait(&inode->i_data);\n\t\t}\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\n\t\tgoto no_delete;\n\t}\n\n\tif (is_bad_inode(inode))\n\t\tgoto no_delete;\n\tdquot_initialize(inode);\n\n\tif (ext4_should_order_data(inode))\n\t\text4_begin_ordered_truncate(inode, 0);\n\ttruncate_inode_pages_final(&inode->i_data);\n\n\t/*\n\t * Protect us against freezing - iput() caller didn't have to have any\n\t * protection against it\n\t */\n\tsb_start_intwrite(inode->i_sb);\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE,\n\t\t\t\t    ext4_blocks_for_truncate(inode)+3);\n\tif (IS_ERR(handle)) {\n\t\text4_std_error(inode->i_sb, PTR_ERR(handle));\n\t\t/*\n\t\t * If we're going to skip the normal cleanup, we still need to\n\t\t * make sure that the in-core orphan linked list is properly\n\t\t * cleaned up.\n\t\t */\n\t\text4_orphan_del(NULL, inode);\n\t\tsb_end_intwrite(inode->i_sb);\n\t\tgoto no_delete;\n\t}\n\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\tinode->i_size = 0;\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (err) {\n\t\text4_warning(inode->i_sb,\n\t\t\t     \"couldn't mark inode dirty (err %d)\", err);\n\t\tgoto stop_handle;\n\t}\n\tif (inode->i_blocks)\n\t\text4_truncate(inode);\n\n\t/*\n\t * ext4_ext_truncate() doesn't reserve any slop when it\n\t * restarts journal transactions; therefore there may not be\n\t * enough credits left in the handle to remove the inode from\n\t * the orphan list and set the dtime field.\n\t */\n\tif (!ext4_handle_has_enough_credits(handle, 3)) {\n\t\terr = ext4_journal_extend(handle, 3);\n\t\tif (err > 0)\n\t\t\terr = ext4_journal_restart(handle, 3);\n\t\tif (err != 0) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"couldn't extend journal (err %d)\", err);\n\t\tstop_handle:\n\t\t\text4_journal_stop(handle);\n\t\t\text4_orphan_del(NULL, inode);\n\t\t\tsb_end_intwrite(inode->i_sb);\n\t\t\tgoto no_delete;\n\t\t}\n\t}\n\n\t/*\n\t * Kill off the orphan record which ext4_truncate created.\n\t * AKPM: I think this can be inside the above `if'.\n\t * Note that ext4_orphan_del() has to be able to cope with the\n\t * deletion of a non-existent orphan - this is because we don't\n\t * know if ext4_truncate() actually created an orphan record.\n\t * (Well, we could do this if we need to, but heck - it works)\n\t */\n\text4_orphan_del(handle, inode);\n\tEXT4_I(inode)->i_dtime\t= get_seconds();\n\n\t/*\n\t * One subtle ordering requirement: if anything has gone wrong\n\t * (transaction abort, IO errors, whatever), then we can still\n\t * do these next steps (the fs will already have been marked as\n\t * having errors), but we can't free the inode if the mark_dirty\n\t * fails.\n\t */\n\tif (ext4_mark_inode_dirty(handle, inode))\n\t\t/* If that failed, just do the required in-core inode clear. */\n\t\text4_clear_inode(inode);\n\telse\n\t\text4_free_inode(handle, inode);\n\text4_journal_stop(handle);\n\tsb_end_intwrite(inode->i_sb);\n\treturn;\nno_delete:\n\text4_clear_inode(inode);\t/* We must guarantee clearing of inode... */\n}\n\n#ifdef CONFIG_QUOTA\nqsize_t *ext4_get_reserved_space(struct inode *inode)\n{\n\treturn &EXT4_I(inode)->i_reserved_quota;\n}\n#endif\n\n/*\n * Called with i_data_sem down, which is important since we can call\n * ext4_discard_preallocations() from here.\n */\nvoid ext4_da_update_reserve_space(struct inode *inode,\n\t\t\t\t\tint used, int quota_claim)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tspin_lock(&ei->i_block_reservation_lock);\n\ttrace_ext4_da_update_reserve_space(inode, used, quota_claim);\n\tif (unlikely(used > ei->i_reserved_data_blocks)) {\n\t\text4_warning(inode->i_sb, \"%s: ino %lu, used %d \"\n\t\t\t \"with only %d reserved data blocks\",\n\t\t\t __func__, inode->i_ino, used,\n\t\t\t ei->i_reserved_data_blocks);\n\t\tWARN_ON(1);\n\t\tused = ei->i_reserved_data_blocks;\n\t}\n\n\t/* Update per-inode reservations */\n\tei->i_reserved_data_blocks -= used;\n\tpercpu_counter_sub(&sbi->s_dirtyclusters_counter, used);\n\n\tspin_unlock(&EXT4_I(inode)->i_block_reservation_lock);\n\n\t/* Update quota subsystem for data blocks */\n\tif (quota_claim)\n\t\tdquot_claim_block(inode, EXT4_C2B(sbi, used));\n\telse {\n\t\t/*\n\t\t * We did fallocate with an offset that is already delayed\n\t\t * allocated. So on delayed allocated writeback we should\n\t\t * not re-claim the quota for fallocated blocks.\n\t\t */\n\t\tdquot_release_reservation_block(inode, EXT4_C2B(sbi, used));\n\t}\n\n\t/*\n\t * If we have done all the pending block allocations and if\n\t * there aren't any writers on the inode, we can discard the\n\t * inode's preallocations.\n\t */\n\tif ((ei->i_reserved_data_blocks == 0) &&\n\t    (atomic_read(&inode->i_writecount) == 0))\n\t\text4_discard_preallocations(inode);\n}\n\nstatic int __check_block_validity(struct inode *inode, const char *func,\n\t\t\t\tunsigned int line,\n\t\t\t\tstruct ext4_map_blocks *map)\n{\n\tif (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,\n\t\t\t\t   map->m_len)) {\n\t\text4_error_inode(inode, func, line, map->m_pblk,\n\t\t\t\t \"lblock %lu mapped to illegal pblock \"\n\t\t\t\t \"(length %d)\", (unsigned long) map->m_lblk,\n\t\t\t\t map->m_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}\n\nint ext4_issue_zeroout(struct inode *inode, ext4_lblk_t lblk, ext4_fsblk_t pblk,\n\t\t       ext4_lblk_t len)\n{\n\tint ret;\n\n\tif (ext4_encrypted_inode(inode))\n\t\treturn ext4_encrypted_zeroout(inode, lblk, pblk, len);\n\n\tret = sb_issue_zeroout(inode->i_sb, pblk, len, GFP_NOFS);\n\tif (ret > 0)\n\t\tret = 0;\n\n\treturn ret;\n}\n\n#define check_block_validity(inode, map)\t\\\n\t__check_block_validity((inode), __func__, __LINE__, (map))\n\n#ifdef ES_AGGRESSIVE_TEST\nstatic void ext4_map_blocks_es_recheck(handle_t *handle,\n\t\t\t\t       struct inode *inode,\n\t\t\t\t       struct ext4_map_blocks *es_map,\n\t\t\t\t       struct ext4_map_blocks *map,\n\t\t\t\t       int flags)\n{\n\tint retval;\n\n\tmap->m_flags = 0;\n\t/*\n\t * There is a race window that the result is not the same.\n\t * e.g. xfstests #223 when dioread_nolock enables.  The reason\n\t * is that we lookup a block mapping in extent status tree with\n\t * out taking i_data_sem.  So at the time the unwritten extent\n\t * could be converted.\n\t */\n\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tup_read((&EXT4_I(inode)->i_data_sem));\n\n\t/*\n\t * We don't check m_len because extent will be collpased in status\n\t * tree.  So the m_len might not equal.\n\t */\n\tif (es_map->m_lblk != map->m_lblk ||\n\t    es_map->m_flags != map->m_flags ||\n\t    es_map->m_pblk != map->m_pblk) {\n\t\tprintk(\"ES cache assertion failed for inode: %lu \"\n\t\t       \"es_cached ex [%d/%d/%llu/%x] != \"\n\t\t       \"found ex [%d/%d/%llu/%x] retval %d flags %x\\n\",\n\t\t       inode->i_ino, es_map->m_lblk, es_map->m_len,\n\t\t       es_map->m_pblk, es_map->m_flags, map->m_lblk,\n\t\t       map->m_len, map->m_pblk, map->m_flags,\n\t\t       retval, flags);\n\t}\n}\n#endif /* ES_AGGRESSIVE_TEST */\n\n/*\n * The ext4_map_blocks() function tries to look up the requested blocks,\n * and returns if the blocks are already mapped.\n *\n * Otherwise it takes the write lock of the i_data_sem and allocate blocks\n * and store the allocated blocks in the result buffer head and mark it\n * mapped.\n *\n * If file type is extents based, it will call ext4_ext_map_blocks(),\n * Otherwise, call with ext4_ind_map_blocks() to handle indirect mapping\n * based files\n *\n * On success, it returns the number of blocks being mapped or allocated.  if\n * create==0 and the blocks are pre-allocated and unwritten, the resulting @map\n * is marked as unwritten. If the create == 1, it will mark @map as mapped.\n *\n * It returns 0 if plain look up failed (blocks have not been allocated), in\n * that case, @map is returned as unmapped but we still do fill map->m_len to\n * indicate the length of a hole starting at map->m_lblk.\n *\n * It returns the error in case of allocation failure.\n */\nint ext4_map_blocks(handle_t *handle, struct inode *inode,\n\t\t    struct ext4_map_blocks *map, int flags)\n{\n\tstruct extent_status es;\n\tint retval;\n\tint ret = 0;\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_map_blocks(): inode %lu, flag %d, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, flags, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/*\n\t * ext4_map_blocks returns an int, and m_len is an unsigned int\n\t */\n\tif (unlikely(map->m_len > INT_MAX))\n\t\tmap->m_len = INT_MAX;\n\n\t/* We can handle the block number less than EXT_MAX_BLOCKS */\n\tif (unlikely(map->m_lblk >= EXT_MAX_BLOCKS))\n\t\treturn -EFSCORRUPTED;\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\tif (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {\n\t\t\tmap->m_pblk = ext4_es_pblock(&es) +\n\t\t\t\t\tmap->m_lblk - es.es_lblk;\n\t\t\tmap->m_flags |= ext4_es_is_written(&es) ?\n\t\t\t\t\tEXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN;\n\t\t\tretval = es.es_len - (map->m_lblk - es.es_lblk);\n\t\t\tif (retval > map->m_len)\n\t\t\t\tretval = map->m_len;\n\t\t\tmap->m_len = retval;\n\t\t} else if (ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)) {\n\t\t\tmap->m_pblk = 0;\n\t\t\tretval = es.es_len - (map->m_lblk - es.es_lblk);\n\t\t\tif (retval > map->m_len)\n\t\t\t\tretval = map->m_len;\n\t\t\tmap->m_len = retval;\n\t\t\tretval = 0;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t}\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(handle, inode, map,\n\t\t\t\t\t   &orig_map, flags);\n#endif\n\t\tgoto found;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    !(status & EXTENT_STATUS_WRITTEN) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk,\n\t\t\t\t\t    map->m_len, map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\tup_read((&EXT4_I(inode)->i_data_sem));\n\nfound:\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t/* If it is only a block(s) look up */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0)\n\t\treturn retval;\n\n\t/*\n\t * Returns if the blocks have already allocated\n\t *\n\t * Note that if blocks have been preallocated\n\t * ext4_ext_get_block() returns the create = 0\n\t * with buffer head unmapped.\n\t */\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)\n\t\t/*\n\t\t * If we need to convert extent to unwritten\n\t\t * we continue and do the actual work in\n\t\t * ext4_ext_map_blocks()\n\t\t */\n\t\tif (!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN))\n\t\t\treturn retval;\n\n\t/*\n\t * Here we clear m_flags because after allocating an new extent,\n\t * it will be set again.\n\t */\n\tmap->m_flags &= ~EXT4_MAP_FLAGS;\n\n\t/*\n\t * New blocks allocate and/or writing to unwritten extent\n\t * will possibly result in updating i_data, so we take\n\t * the write lock of i_data_sem, and call get_block()\n\t * with create == 1 flag.\n\t */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\t/*\n\t * We need to check for EXT4 here because migrate\n\t * could have changed the inode type in between\n\t */\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags);\n\n\t\tif (retval > 0 && map->m_flags & EXT4_MAP_NEW) {\n\t\t\t/*\n\t\t\t * We allocated new blocks which will result in\n\t\t\t * i_data's format changing.  Force the migrate\n\t\t\t * to fail by clearing migrate flags\n\t\t\t */\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\t\t}\n\n\t\t/*\n\t\t * Update reserved blocks/metadata blocks after successful\n\t\t * block allocation which had been deferred till now. We don't\n\t\t * support fallocate for non extent files. So we can update\n\t\t * reserve space here.\n\t\t */\n\t\tif ((retval > 0) &&\n\t\t\t(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE))\n\t\t\text4_da_update_reserve_space(inode, retval, 1);\n\t}\n\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\t/*\n\t\t * We have to zeroout blocks before inserting them into extent\n\t\t * status tree. Otherwise someone could look them up there and\n\t\t * use them before they are really zeroed.\n\t\t */\n\t\tif (flags & EXT4_GET_BLOCKS_ZERO &&\n\t\t    map->m_flags & EXT4_MAP_MAPPED &&\n\t\t    map->m_flags & EXT4_MAP_NEW) {\n\t\t\tret = ext4_issue_zeroout(inode, map->m_lblk,\n\t\t\t\t\t\t map->m_pblk, map->m_len);\n\t\t\tif (ret) {\n\t\t\t\tretval = ret;\n\t\t\t\tgoto out_sem;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the extent has been zeroed out, we don't need to update\n\t\t * extent status tree.\n\t\t */\n\t\tif ((flags & EXT4_GET_BLOCKS_PRE_IO) &&\n\t\t    ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\t\tif (ext4_es_is_written(&es))\n\t\t\t\tgoto out_sem;\n\t\t}\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    !(status & EXTENT_STATUS_WRITTEN) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret < 0) {\n\t\t\tretval = ret;\n\t\t\tgoto out_sem;\n\t\t}\n\t}\n\nout_sem:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\treturn retval;\n}\n\n/*\n * Update EXT4_MAP_FLAGS in bh->b_state. For buffer heads attached to pages\n * we have to be careful as someone else may be manipulating b_state as well.\n */\nstatic void ext4_update_bh_state(struct buffer_head *bh, unsigned long flags)\n{\n\tunsigned long old_state;\n\tunsigned long new_state;\n\n\tflags &= EXT4_MAP_FLAGS;\n\n\t/* Dummy buffer_head? Set non-atomically. */\n\tif (!bh->b_page) {\n\t\tbh->b_state = (bh->b_state & ~EXT4_MAP_FLAGS) | flags;\n\t\treturn;\n\t}\n\t/*\n\t * Someone else may be modifying b_state. Be careful! This is ugly but\n\t * once we get rid of using bh as a container for mapping information\n\t * to pass to / from get_block functions, this can go away.\n\t */\n\tdo {\n\t\told_state = READ_ONCE(bh->b_state);\n\t\tnew_state = (old_state & ~EXT4_MAP_FLAGS) | flags;\n\t} while (unlikely(\n\t\t cmpxchg(&bh->b_state, old_state, new_state) != old_state));\n}\n\nstatic int _ext4_get_block(struct inode *inode, sector_t iblock,\n\t\t\t   struct buffer_head *bh, int flags)\n{\n\tstruct ext4_map_blocks map;\n\tint ret = 0;\n\n\tif (ext4_has_inline_data(inode))\n\t\treturn -ERANGE;\n\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\n\tret = ext4_map_blocks(ext4_journal_current_handle(), inode, &map,\n\t\t\t      flags);\n\tif (ret > 0) {\n\t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\t\text4_update_bh_state(bh, map.m_flags);\n\t\tbh->b_size = inode->i_sb->s_blocksize * map.m_len;\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\nint ext4_get_block(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh, int create)\n{\n\treturn _ext4_get_block(inode, iblock, bh,\n\t\t\t       create ? EXT4_GET_BLOCKS_CREATE : 0);\n}\n\n/*\n * Get block function used when preparing for buffered write if we require\n * creating an unwritten extent if blocks haven't been allocated.  The extent\n * will be converted to written after the IO is complete.\n */\nint ext4_get_block_unwritten(struct inode *inode, sector_t iblock,\n\t\t\t     struct buffer_head *bh_result, int create)\n{\n\text4_debug(\"ext4_get_block_unwritten: inode %lu, create flag %d\\n\",\n\t\t   inode->i_ino, create);\n\treturn _ext4_get_block(inode, iblock, bh_result,\n\t\t\t       EXT4_GET_BLOCKS_IO_CREATE_EXT);\n}\n\n/* Maximum number of blocks we map for direct IO at once. */\n#define DIO_MAX_BLOCKS 4096\n\n/*\n * Get blocks function for the cases that need to start a transaction -\n * generally difference cases of direct IO and DAX IO. It also handles retries\n * in case of ENOSPC.\n */\nstatic int ext4_get_block_trans(struct inode *inode, sector_t iblock,\n\t\t\t\tstruct buffer_head *bh_result, int flags)\n{\n\tint dio_credits;\n\thandle_t *handle;\n\tint retries = 0;\n\tint ret;\n\n\t/* Trim mapping request to maximum we can map at once for DIO */\n\tif (bh_result->b_size >> inode->i_blkbits > DIO_MAX_BLOCKS)\n\t\tbh_result->b_size = DIO_MAX_BLOCKS << inode->i_blkbits;\n\tdio_credits = ext4_chunk_trans_blocks(inode,\n\t\t\t\t      bh_result->b_size >> inode->i_blkbits);\nretry:\n\thandle = ext4_journal_start(inode, EXT4_HT_MAP_BLOCKS, dio_credits);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tret = _ext4_get_block(inode, iblock, bh_result, flags);\n\text4_journal_stop(handle);\n\n\tif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\n\treturn ret;\n}\n\n/* Get block function for DIO reads and writes to inodes without extents */\nint ext4_dio_get_block(struct inode *inode, sector_t iblock,\n\t\t       struct buffer_head *bh, int create)\n{\n\t/* We don't expect handle for direct IO */\n\tWARN_ON_ONCE(ext4_journal_current_handle());\n\n\tif (!create)\n\t\treturn _ext4_get_block(inode, iblock, bh, 0);\n\treturn ext4_get_block_trans(inode, iblock, bh, EXT4_GET_BLOCKS_CREATE);\n}\n\n/*\n * Get block function for AIO DIO writes when we create unwritten extent if\n * blocks are not allocated yet. The extent will be converted to written\n * after IO is complete.\n */\nstatic int ext4_dio_get_block_unwritten_async(struct inode *inode,\n\t\tsector_t iblock, struct buffer_head *bh_result,\tint create)\n{\n\tint ret;\n\n\t/* We don't expect handle for direct IO */\n\tWARN_ON_ONCE(ext4_journal_current_handle());\n\n\tret = ext4_get_block_trans(inode, iblock, bh_result,\n\t\t\t\t   EXT4_GET_BLOCKS_IO_CREATE_EXT);\n\n\t/*\n\t * When doing DIO using unwritten extents, we need io_end to convert\n\t * unwritten extents to written on IO completion. We allocate io_end\n\t * once we spot unwritten extent and store it in b_private. Generic\n\t * DIO code keeps b_private set and furthermore passes the value to\n\t * our completion callback in 'private' argument.\n\t */\n\tif (!ret && buffer_unwritten(bh_result)) {\n\t\tif (!bh_result->b_private) {\n\t\t\text4_io_end_t *io_end;\n\n\t\t\tio_end = ext4_init_io_end(inode, GFP_KERNEL);\n\t\t\tif (!io_end)\n\t\t\t\treturn -ENOMEM;\n\t\t\tbh_result->b_private = io_end;\n\t\t\text4_set_io_unwritten_flag(inode, io_end);\n\t\t}\n\t\tset_buffer_defer_completion(bh_result);\n\t}\n\n\treturn ret;\n}\n\n/*\n * Get block function for non-AIO DIO writes when we create unwritten extent if\n * blocks are not allocated yet. The extent will be converted to written\n * after IO is complete from ext4_ext_direct_IO() function.\n */\nstatic int ext4_dio_get_block_unwritten_sync(struct inode *inode,\n\t\tsector_t iblock, struct buffer_head *bh_result,\tint create)\n{\n\tint ret;\n\n\t/* We don't expect handle for direct IO */\n\tWARN_ON_ONCE(ext4_journal_current_handle());\n\n\tret = ext4_get_block_trans(inode, iblock, bh_result,\n\t\t\t\t   EXT4_GET_BLOCKS_IO_CREATE_EXT);\n\n\t/*\n\t * Mark inode as having pending DIO writes to unwritten extents.\n\t * ext4_ext_direct_IO() checks this flag and converts extents to\n\t * written.\n\t */\n\tif (!ret && buffer_unwritten(bh_result))\n\t\text4_set_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);\n\n\treturn ret;\n}\n\nstatic int ext4_dio_get_block_overwrite(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create)\n{\n\tint ret;\n\n\text4_debug(\"ext4_dio_get_block_overwrite: inode %lu, create flag %d\\n\",\n\t\t   inode->i_ino, create);\n\t/* We don't expect handle for direct IO */\n\tWARN_ON_ONCE(ext4_journal_current_handle());\n\n\tret = _ext4_get_block(inode, iblock, bh_result, 0);\n\t/*\n\t * Blocks should have been preallocated! ext4_file_write_iter() checks\n\t * that.\n\t */\n\tWARN_ON_ONCE(!buffer_mapped(bh_result) || buffer_unwritten(bh_result));\n\n\treturn ret;\n}\n\n\n/*\n * `handle' can be NULL if create is zero\n */\nstruct buffer_head *ext4_getblk(handle_t *handle, struct inode *inode,\n\t\t\t\text4_lblk_t block, int map_flags)\n{\n\tstruct ext4_map_blocks map;\n\tstruct buffer_head *bh;\n\tint create = map_flags & EXT4_GET_BLOCKS_CREATE;\n\tint err;\n\n\tJ_ASSERT(handle != NULL || create == 0);\n\n\tmap.m_lblk = block;\n\tmap.m_len = 1;\n\terr = ext4_map_blocks(handle, inode, &map, map_flags);\n\n\tif (err == 0)\n\t\treturn create ? ERR_PTR(-ENOSPC) : NULL;\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\tbh = sb_getblk(inode->i_sb, map.m_pblk);\n\tif (unlikely(!bh))\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (map.m_flags & EXT4_MAP_NEW) {\n\t\tJ_ASSERT(create != 0);\n\t\tJ_ASSERT(handle != NULL);\n\n\t\t/*\n\t\t * Now that we do not always journal data, we should\n\t\t * keep in mind whether this should always journal the\n\t\t * new buffer as metadata.  For now, regular file\n\t\t * writes use ext4_get_block instead, so it's not a\n\t\t * problem.\n\t\t */\n\t\tlock_buffer(bh);\n\t\tBUFFER_TRACE(bh, \"call get_create_access\");\n\t\terr = ext4_journal_get_create_access(handle, bh);\n\t\tif (unlikely(err)) {\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto errout;\n\t\t}\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tmemset(bh->b_data, 0, inode->i_sb->s_blocksize);\n\t\t\tset_buffer_uptodate(bh);\n\t\t}\n\t\tunlock_buffer(bh);\n\t\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\t\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\t\tif (unlikely(err))\n\t\t\tgoto errout;\n\t} else\n\t\tBUFFER_TRACE(bh, \"not a new buffer\");\n\treturn bh;\nerrout:\n\tbrelse(bh);\n\treturn ERR_PTR(err);\n}\n\nstruct buffer_head *ext4_bread(handle_t *handle, struct inode *inode,\n\t\t\t       ext4_lblk_t block, int map_flags)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_getblk(handle, inode, block, map_flags);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tif (!bh || buffer_uptodate(bh))\n\t\treturn bh;\n\tll_rw_block(READ | REQ_META | REQ_PRIO, 1, &bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\treturn ERR_PTR(-EIO);\n}\n\nint ext4_walk_page_buffers(handle_t *handle,\n\t\t\t   struct buffer_head *head,\n\t\t\t   unsigned from,\n\t\t\t   unsigned to,\n\t\t\t   int *partial,\n\t\t\t   int (*fn)(handle_t *handle,\n\t\t\t\t     struct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (bh = head, block_start = 0;\n\t     ret == 0 && (bh != head || !block_start);\n\t     block_start = block_end, bh = next) {\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}\n\n/*\n * To preserve ordering, it is essential that the hole instantiation and\n * the data write be encapsulated in a single transaction.  We cannot\n * close off a transaction and start a new one between the ext4_get_block()\n * and the commit_write().  So doing the jbd2_journal_start at the start of\n * prepare_write() is the right place.\n *\n * Also, this function can nest inside ext4_writepage().  In that case, we\n * *know* that ext4_writepage() has generated enough buffer credits to do the\n * whole page.  So we won't block on the journal in that case, which is good,\n * because the caller may be PF_MEMALLOC.\n *\n * By accident, ext4 can be reentered when a transaction is open via\n * quota file writes.  If we were to commit the transaction while thus\n * reentered, there can be a deadlock - we would be holding a quota\n * lock, and the commit would never complete if another thread had a\n * transaction open and was blocking on the quota lock - a ranking\n * violation.\n *\n * So what we do is to rely on the fact that jbd2_journal_stop/journal_start\n * will _not_ run commit under these circumstances because handle->h_ref\n * is elevated.  We'll still have enough credits for the tiny quotafile\n * write.\n */\nint do_journal_get_write_access(handle_t *handle,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tint dirty = buffer_dirty(bh);\n\tint ret;\n\n\tif (!buffer_mapped(bh) || buffer_freed(bh))\n\t\treturn 0;\n\t/*\n\t * __block_write_begin() could have dirtied some buffers. Clean\n\t * the dirty bit as jbd2_journal_get_write_access() could complain\n\t * otherwise about fs integrity issues. Setting of the dirty bit\n\t * by __block_write_begin() isn't a real problem here as we clear\n\t * the bit before releasing a page lock and thus writeback cannot\n\t * ever write the buffer.\n\t */\n\tif (dirty)\n\t\tclear_buffer_dirty(bh);\n\tBUFFER_TRACE(bh, \"get write access\");\n\tret = ext4_journal_get_write_access(handle, bh);\n\tif (!ret && dirty)\n\t\tret = ext4_handle_dirty_metadata(handle, NULL, bh);\n\treturn ret;\n}\n\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\nstatic int ext4_block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\t\t\t  get_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\tunsigned bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh = wait;\n\tbool decrypt = false;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_SIZE);\n\tBUG_ON(to > PAGE_SIZE);\n\tBUG_ON(from > to);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\thead = page_buffers(page);\n\tbbits = ilog2(blocksize);\n\tblock = (sector_t)page->index << (PAGE_SHIFT - bbits);\n\n\tfor (bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start = block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\t  bh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page, to, block_end,\n\t\t\t\t\t\t\t   block_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t    (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++ = bh;\n\t\t\tdecrypt = ext4_encrypted_inode(inode) &&\n\t\t\t\tS_ISREG(inode->i_mode);\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests, let them complete.\n\t */\n\twhile (wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\telse if (decrypt)\n\t\terr = ext4_decrypt(page);\n\treturn err;\n}\n#endif\n\nstatic int ext4_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, unsigned len, unsigned flags,\n\t\t\t    struct page **pagep, void **fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint ret, needed_blocks;\n\thandle_t *handle;\n\tint retries = 0;\n\tstruct page *page;\n\tpgoff_t index;\n\tunsigned from, to;\n\n\ttrace_ext4_write_begin(inode, pos, len, flags);\n\t/*\n\t * Reserve one block more for addition to orphan list in case\n\t * we allocate blocks but write fails for some reason\n\t */\n\tneeded_blocks = ext4_writepage_trans_blocks(inode) + 1;\n\tindex = pos >> PAGE_SHIFT;\n\tfrom = pos & (PAGE_SIZE - 1);\n\tto = from + len;\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA)) {\n\t\tret = ext4_try_to_write_inline_data(mapping, inode, pos, len,\n\t\t\t\t\t\t    flags, pagep);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 1)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * grab_cache_page_write_begin() can take a long time if the\n\t * system is thrashing due to memory pressure, or if the page\n\t * is being written back.  So grab it first before we start\n\t * the transaction handle.  This also allows us to allocate\n\t * the page (if needed) without using GFP_NOFS.\n\t */\nretry_grab:\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tunlock_page(page);\n\nretry_journal:\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE, needed_blocks);\n\tif (IS_ERR(handle)) {\n\t\tput_page(page);\n\t\treturn PTR_ERR(handle);\n\t}\n\n\tlock_page(page);\n\tif (page->mapping != mapping) {\n\t\t/* The page got truncated from under us */\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\text4_journal_stop(handle);\n\t\tgoto retry_grab;\n\t}\n\t/* In case writeback began while the page was unlocked */\n\twait_for_stable_page(page);\n\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tif (ext4_should_dioread_nolock(inode))\n\t\tret = ext4_block_write_begin(page, pos, len,\n\t\t\t\t\t     ext4_get_block_unwritten);\n\telse\n\t\tret = ext4_block_write_begin(page, pos, len,\n\t\t\t\t\t     ext4_get_block);\n#else\n\tif (ext4_should_dioread_nolock(inode))\n\t\tret = __block_write_begin(page, pos, len,\n\t\t\t\t\t  ext4_get_block_unwritten);\n\telse\n\t\tret = __block_write_begin(page, pos, len, ext4_get_block);\n#endif\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tret = ext4_walk_page_buffers(handle, page_buffers(page),\n\t\t\t\t\t     from, to, NULL,\n\t\t\t\t\t     do_journal_get_write_access);\n\t}\n\n\tif (ret) {\n\t\tunlock_page(page);\n\t\t/*\n\t\t * __block_write_begin may have instantiated a few blocks\n\t\t * outside i_size.  Trim these off again. Don't need\n\t\t * i_size_read because we hold i_mutex.\n\t\t *\n\t\t * Add inode to orphan list in case we crash before\n\t\t * truncate finishes\n\t\t */\n\t\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\t\text4_orphan_add(handle, inode);\n\n\t\text4_journal_stop(handle);\n\t\tif (pos + len > inode->i_size) {\n\t\t\text4_truncate_failed_write(inode);\n\t\t\t/*\n\t\t\t * If truncate failed early the inode might\n\t\t\t * still be on the orphan list; we need to\n\t\t\t * make sure the inode is removed from the\n\t\t\t * orphan list in that case.\n\t\t\t */\n\t\t\tif (inode->i_nlink)\n\t\t\t\text4_orphan_del(NULL, inode);\n\t\t}\n\n\t\tif (ret == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\t\tgoto retry_journal;\n\t\tput_page(page);\n\t\treturn ret;\n\t}\n\t*pagep = page;\n\treturn ret;\n}\n\n/* For write_end() in data=journal mode */\nstatic int write_end_fn(handle_t *handle, struct buffer_head *bh)\n{\n\tint ret;\n\tif (!buffer_mapped(bh) || buffer_freed(bh))\n\t\treturn 0;\n\tset_buffer_uptodate(bh);\n\tret = ext4_handle_dirty_metadata(handle, NULL, bh);\n\tclear_buffer_meta(bh);\n\tclear_buffer_prio(bh);\n\treturn ret;\n}\n\n/*\n * We need to pick up the new inode size which generic_commit_write gave us\n * `file' can be NULL - eg, when called from page_symlink().\n *\n * ext4 never places buffers on inode->i_mapping->private_list.  metadata\n * buffers are managed internally.\n */\nstatic int ext4_write_end(struct file *file,\n\t\t\t  struct address_space *mapping,\n\t\t\t  loff_t pos, unsigned len, unsigned copied,\n\t\t\t  struct page *page, void *fsdata)\n{\n\thandle_t *handle = ext4_journal_current_handle();\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint ret = 0, ret2;\n\tint i_size_changed = 0;\n\n\ttrace_ext4_write_end(inode, pos, len, copied);\n\tif (ext4_test_inode_state(inode, EXT4_STATE_ORDERED_MODE)) {\n\t\tret = ext4_jbd2_file_inode(handle, inode);\n\t\tif (ret) {\n\t\t\tunlock_page(page);\n\t\t\tput_page(page);\n\t\t\tgoto errout;\n\t\t}\n\t}\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tret = ext4_write_inline_data_end(inode, pos, len,\n\t\t\t\t\t\t copied, page);\n\t\tif (ret < 0)\n\t\t\tgoto errout;\n\t\tcopied = ret;\n\t} else\n\t\tcopied = block_write_end(file, mapping, pos,\n\t\t\t\t\t len, copied, page, fsdata);\n\t/*\n\t * it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\ti_size_changed = ext4_update_inode_size(inode, pos + copied);\n\tunlock_page(page);\n\tput_page(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\text4_mark_inode_dirty(handle, inode);\n\n\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\t/* if we have allocated more blocks and copied\n\t\t * less. We will have blocks allocated outside\n\t\t * inode->i_size. So truncate them\n\t\t */\n\t\text4_orphan_add(handle, inode);\nerrout:\n\tret2 = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = ret2;\n\n\tif (pos + len > inode->i_size) {\n\t\text4_truncate_failed_write(inode);\n\t\t/*\n\t\t * If truncate failed early the inode might still be\n\t\t * on the orphan list; we need to make sure the inode\n\t\t * is removed from the orphan list in that case.\n\t\t */\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\n\treturn ret ? ret : copied;\n}\n\n/*\n * This is a private version of page_zero_new_buffers() which doesn't\n * set the buffer to be dirty, since in data=journalled mode we need\n * to call ext4_handle_dirty_metadata() instead.\n */\nstatic void zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start = 0, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, size;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tsize = min(to, block_end) - start;\n\n\t\t\t\t\tzero_user(page, start, size);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t}\n\t\t}\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}\n\nstatic int ext4_journalled_write_end(struct file *file,\n\t\t\t\t     struct address_space *mapping,\n\t\t\t\t     loff_t pos, unsigned len, unsigned copied,\n\t\t\t\t     struct page *page, void *fsdata)\n{\n\thandle_t *handle = ext4_journal_current_handle();\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint ret = 0, ret2;\n\tint partial = 0;\n\tunsigned from, to;\n\tint size_changed = 0;\n\n\ttrace_ext4_journalled_write_end(inode, pos, len, copied);\n\tfrom = pos & (PAGE_SIZE - 1);\n\tto = from + len;\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\n\tif (ext4_has_inline_data(inode))\n\t\tcopied = ext4_write_inline_data_end(inode, pos, len,\n\t\t\t\t\t\t    copied, page);\n\telse {\n\t\tif (copied < len) {\n\t\t\tif (!PageUptodate(page))\n\t\t\t\tcopied = 0;\n\t\t\tzero_new_buffers(page, from+copied, to);\n\t\t}\n\n\t\tret = ext4_walk_page_buffers(handle, page_buffers(page), from,\n\t\t\t\t\t     to, &partial, write_end_fn);\n\t\tif (!partial)\n\t\t\tSetPageUptodate(page);\n\t}\n\tsize_changed = ext4_update_inode_size(inode, pos + copied);\n\text4_set_inode_state(inode, EXT4_STATE_JDATA);\n\tEXT4_I(inode)->i_datasync_tid = handle->h_transaction->t_tid;\n\tunlock_page(page);\n\tput_page(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\n\tif (size_changed) {\n\t\tret2 = ext4_mark_inode_dirty(handle, inode);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\t}\n\n\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\t/* if we have allocated more blocks and copied\n\t\t * less. We will have blocks allocated outside\n\t\t * inode->i_size. So truncate them\n\t\t */\n\t\text4_orphan_add(handle, inode);\n\n\tret2 = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = ret2;\n\tif (pos + len > inode->i_size) {\n\t\text4_truncate_failed_write(inode);\n\t\t/*\n\t\t * If truncate failed early the inode might still be\n\t\t * on the orphan list; we need to make sure the inode\n\t\t * is removed from the orphan list in that case.\n\t\t */\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\n\treturn ret ? ret : copied;\n}\n\n/*\n * Reserve space for a single cluster\n */\nstatic int ext4_da_reserve_space(struct inode *inode)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tint ret;\n\n\t/*\n\t * We will charge metadata quota at writeout time; this saves\n\t * us from metadata over-estimation, though we may go over by\n\t * a small amount in the end.  Here we just reserve for data.\n\t */\n\tret = dquot_reserve_block(inode, EXT4_C2B(sbi, 1));\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock(&ei->i_block_reservation_lock);\n\tif (ext4_claim_free_clusters(sbi, 1, 0)) {\n\t\tspin_unlock(&ei->i_block_reservation_lock);\n\t\tdquot_release_reservation_block(inode, EXT4_C2B(sbi, 1));\n\t\treturn -ENOSPC;\n\t}\n\tei->i_reserved_data_blocks++;\n\ttrace_ext4_da_reserve_space(inode);\n\tspin_unlock(&ei->i_block_reservation_lock);\n\n\treturn 0;       /* success */\n}\n\nstatic void ext4_da_release_space(struct inode *inode, int to_free)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tif (!to_free)\n\t\treturn;\t\t/* Nothing to release, exit */\n\n\tspin_lock(&EXT4_I(inode)->i_block_reservation_lock);\n\n\ttrace_ext4_da_release_space(inode, to_free);\n\tif (unlikely(to_free > ei->i_reserved_data_blocks)) {\n\t\t/*\n\t\t * if there aren't enough reserved blocks, then the\n\t\t * counter is messed up somewhere.  Since this\n\t\t * function is called from invalidate page, it's\n\t\t * harmless to return without any action.\n\t\t */\n\t\text4_warning(inode->i_sb, \"ext4_da_release_space: \"\n\t\t\t \"ino %lu, to_free %d with only %d reserved \"\n\t\t\t \"data blocks\", inode->i_ino, to_free,\n\t\t\t ei->i_reserved_data_blocks);\n\t\tWARN_ON(1);\n\t\tto_free = ei->i_reserved_data_blocks;\n\t}\n\tei->i_reserved_data_blocks -= to_free;\n\n\t/* update fs dirty data blocks counter */\n\tpercpu_counter_sub(&sbi->s_dirtyclusters_counter, to_free);\n\n\tspin_unlock(&EXT4_I(inode)->i_block_reservation_lock);\n\n\tdquot_release_reservation_block(inode, EXT4_C2B(sbi, to_free));\n}\n\nstatic void ext4_da_page_release_reservation(struct page *page,\n\t\t\t\t\t     unsigned int offset,\n\t\t\t\t\t     unsigned int length)\n{\n\tint to_release = 0, contiguous_blks = 0;\n\tstruct buffer_head *head, *bh;\n\tunsigned int curr_off = 0;\n\tstruct inode *inode = page->mapping->host;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tunsigned int stop = offset + length;\n\tint num_clusters;\n\text4_fsblk_t lblk;\n\n\tBUG_ON(stop > PAGE_SIZE || stop < length);\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\n\t\tif (next_off > stop)\n\t\t\tbreak;\n\n\t\tif ((offset <= curr_off) && (buffer_delay(bh))) {\n\t\t\tto_release++;\n\t\t\tcontiguous_blks++;\n\t\t\tclear_buffer_delay(bh);\n\t\t} else if (contiguous_blks) {\n\t\t\tlblk = page->index <<\n\t\t\t       (PAGE_SHIFT - inode->i_blkbits);\n\t\t\tlblk += (curr_off >> inode->i_blkbits) -\n\t\t\t\tcontiguous_blks;\n\t\t\text4_es_remove_extent(inode, lblk, contiguous_blks);\n\t\t\tcontiguous_blks = 0;\n\t\t}\n\t\tcurr_off = next_off;\n\t} while ((bh = bh->b_this_page) != head);\n\n\tif (contiguous_blks) {\n\t\tlblk = page->index << (PAGE_SHIFT - inode->i_blkbits);\n\t\tlblk += (curr_off >> inode->i_blkbits) - contiguous_blks;\n\t\text4_es_remove_extent(inode, lblk, contiguous_blks);\n\t}\n\n\t/* If we have released all the blocks belonging to a cluster, then we\n\t * need to release the reserved space for that cluster. */\n\tnum_clusters = EXT4_NUM_B2C(sbi, to_release);\n\twhile (num_clusters > 0) {\n\t\tlblk = (page->index << (PAGE_SHIFT - inode->i_blkbits)) +\n\t\t\t((num_clusters - 1) << sbi->s_cluster_bits);\n\t\tif (sbi->s_cluster_ratio == 1 ||\n\t\t    !ext4_find_delalloc_cluster(inode, lblk))\n\t\t\text4_da_release_space(inode, 1);\n\n\t\tnum_clusters--;\n\t}\n}\n\n/*\n * Delayed allocation stuff\n */\n\nstruct mpage_da_data {\n\tstruct inode *inode;\n\tstruct writeback_control *wbc;\n\n\tpgoff_t first_page;\t/* The first page to write */\n\tpgoff_t next_page;\t/* Current page to examine */\n\tpgoff_t last_page;\t/* Last page to examine */\n\t/*\n\t * Extent to map - this can be after first_page because that can be\n\t * fully mapped. We somewhat abuse m_flags to store whether the extent\n\t * is delalloc or unwritten.\n\t */\n\tstruct ext4_map_blocks map;\n\tstruct ext4_io_submit io_submit;\t/* IO submission data */\n};\n\nstatic void mpage_release_unused_pages(struct mpage_da_data *mpd,\n\t\t\t\t       bool invalidate)\n{\n\tint nr_pages, i;\n\tpgoff_t index, end;\n\tstruct pagevec pvec;\n\tstruct inode *inode = mpd->inode;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\t/* This is necessary when next_page == 0. */\n\tif (mpd->first_page >= mpd->next_page)\n\t\treturn;\n\n\tindex = mpd->first_page;\n\tend   = mpd->next_page - 1;\n\tif (invalidate) {\n\t\text4_lblk_t start, last;\n\t\tstart = index << (PAGE_SHIFT - inode->i_blkbits);\n\t\tlast = end << (PAGE_SHIFT - inode->i_blkbits);\n\t\text4_es_remove_extent(inode, start, last - start + 1);\n\t}\n\n\tpagevec_init(&pvec, 0);\n\twhile (index <= end) {\n\t\tnr_pages = pagevec_lookup(&pvec, mapping, index, PAGEVEC_SIZE);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tif (page->index > end)\n\t\t\t\tbreak;\n\t\t\tBUG_ON(!PageLocked(page));\n\t\t\tBUG_ON(PageWriteback(page));\n\t\t\tif (invalidate) {\n\t\t\t\tblock_invalidatepage(page, 0, PAGE_SIZE);\n\t\t\t\tClearPageUptodate(page);\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t\tindex = pvec.pages[nr_pages - 1]->index + 1;\n\t\tpagevec_release(&pvec);\n\t}\n}\n\nstatic void ext4_print_free_blocks(struct inode *inode)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\text4_msg(sb, KERN_CRIT, \"Total free blocks count %lld\",\n\t       EXT4_C2B(EXT4_SB(inode->i_sb),\n\t\t\text4_count_free_clusters(sb)));\n\text4_msg(sb, KERN_CRIT, \"Free/Dirty block details\");\n\text4_msg(sb, KERN_CRIT, \"free_blocks=%lld\",\n\t       (long long) EXT4_C2B(EXT4_SB(sb),\n\t\tpercpu_counter_sum(&sbi->s_freeclusters_counter)));\n\text4_msg(sb, KERN_CRIT, \"dirty_blocks=%lld\",\n\t       (long long) EXT4_C2B(EXT4_SB(sb),\n\t\tpercpu_counter_sum(&sbi->s_dirtyclusters_counter)));\n\text4_msg(sb, KERN_CRIT, \"Block reservation details\");\n\text4_msg(sb, KERN_CRIT, \"i_reserved_data_blocks=%u\",\n\t\t ei->i_reserved_data_blocks);\n\treturn;\n}\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh)\n{\n\treturn (buffer_delay(bh) || buffer_unwritten(bh)) && buffer_dirty(bh);\n}\n\n/*\n * This function is grabs code from the very beginning of\n * ext4_map_blocks, but assumes that the caller is from delayed write\n * time. This function looks up the requested blocks and sets the\n * buffer delay bit under the protection of i_data_sem.\n */\nstatic int ext4_da_map_blocks(struct inode *inode, sector_t iblock,\n\t\t\t      struct ext4_map_blocks *map,\n\t\t\t      struct buffer_head *bh)\n{\n\tstruct extent_status es;\n\tint retval;\n\tsector_t invalid_block = ~((sector_t) 0xffff);\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tif (invalid_block < ext4_blocks_count(EXT4_SB(inode->i_sb)->s_es))\n\t\tinvalid_block = ~0;\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_da_map_blocks(): inode %lu, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, iblock, &es)) {\n\t\tif (ext4_es_is_hole(&es)) {\n\t\t\tretval = 0;\n\t\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\t\t\tgoto add_delayed;\n\t\t}\n\n\t\t/*\n\t\t * Delayed extent could be allocated by fallocate.\n\t\t * So we need to check it.\n\t\t */\n\t\tif (ext4_es_is_delayed(&es) && !ext4_es_is_unwritten(&es)) {\n\t\t\tmap_bh(bh, inode->i_sb, invalid_block);\n\t\t\tset_buffer_new(bh);\n\t\t\tset_buffer_delay(bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tmap->m_pblk = ext4_es_pblock(&es) + iblock - es.es_lblk;\n\t\tretval = es.es_len - (iblock - es.es_lblk);\n\t\tif (retval > map->m_len)\n\t\t\tretval = map->m_len;\n\t\tmap->m_len = retval;\n\t\tif (ext4_es_is_written(&es))\n\t\t\tmap->m_flags |= EXT4_MAP_MAPPED;\n\t\telse if (ext4_es_is_unwritten(&es))\n\t\t\tmap->m_flags |= EXT4_MAP_UNWRITTEN;\n\t\telse\n\t\t\tBUG_ON(1);\n\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(NULL, inode, map, &orig_map, 0);\n#endif\n\t\treturn retval;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_has_inline_data(inode))\n\t\tretval = 0;\n\telse if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tretval = ext4_ext_map_blocks(NULL, inode, map, 0);\n\telse\n\t\tretval = ext4_ind_map_blocks(NULL, inode, map, 0);\n\nadd_delayed:\n\tif (retval == 0) {\n\t\tint ret;\n\t\t/*\n\t\t * XXX: __block_prepare_write() unmaps passed block,\n\t\t * is it OK?\n\t\t */\n\t\t/*\n\t\t * If the block was allocated from previously allocated cluster,\n\t\t * then we don't need to reserve it again. However we still need\n\t\t * to reserve metadata for every block we're going to write.\n\t\t */\n\t\tif (EXT4_SB(inode->i_sb)->s_cluster_ratio == 1 ||\n\t\t    !ext4_find_delalloc_cluster(inode, map->m_lblk)) {\n\t\t\tret = ext4_da_reserve_space(inode);\n\t\t\tif (ret) {\n\t\t\t\t/* not enough space to reserve */\n\t\t\t\tretval = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    ~0, EXTENT_STATUS_DELAYED);\n\t\tif (ret) {\n\t\t\tretval = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tmap_bh(bh, inode->i_sb, invalid_block);\n\t\tset_buffer_new(bh);\n\t\tset_buffer_delay(bh);\n\t} else if (retval > 0) {\n\t\tint ret;\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret != 0)\n\t\t\tretval = ret;\n\t}\n\nout_unlock:\n\tup_read((&EXT4_I(inode)->i_data_sem));\n\n\treturn retval;\n}\n\n/*\n * This is a special get_block_t callback which is used by\n * ext4_da_write_begin().  It will either return mapped block or\n * reserve space for a single block.\n *\n * For delayed buffer_head we have BH_Mapped, BH_New, BH_Delay set.\n * We also have b_blocknr = -1 and b_bdev initialized properly\n *\n * For unwritten buffer_head we have BH_Mapped, BH_New, BH_Unwritten set.\n * We also have b_blocknr = physicalblock mapping unwritten extent and b_bdev\n * initialized properly.\n */\nint ext4_da_get_block_prep(struct inode *inode, sector_t iblock,\n\t\t\t   struct buffer_head *bh, int create)\n{\n\tstruct ext4_map_blocks map;\n\tint ret = 0;\n\n\tBUG_ON(create == 0);\n\tBUG_ON(bh->b_size != inode->i_sb->s_blocksize);\n\n\tmap.m_lblk = iblock;\n\tmap.m_len = 1;\n\n\t/*\n\t * first, we need to know whether the block is allocated already\n\t * preallocated blocks are unmapped but should treated\n\t * the same as allocated blocks.\n\t */\n\tret = ext4_da_map_blocks(inode, iblock, &map, bh);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\text4_update_bh_state(bh, map.m_flags);\n\n\tif (buffer_unwritten(bh)) {\n\t\t/* A delayed write to unwritten bh should be marked\n\t\t * new and mapped.  Mapped ensures that we don't do\n\t\t * get_block multiple times when we write to the same\n\t\t * offset and new ensures that we do proper zero out\n\t\t * for partial write.\n\t\t */\n\t\tset_buffer_new(bh);\n\t\tset_buffer_mapped(bh);\n\t}\n\treturn 0;\n}\n\nstatic int bget_one(handle_t *handle, struct buffer_head *bh)\n{\n\tget_bh(bh);\n\treturn 0;\n}\n\nstatic int bput_one(handle_t *handle, struct buffer_head *bh)\n{\n\tput_bh(bh);\n\treturn 0;\n}\n\nstatic int __ext4_journalled_writepage(struct page *page,\n\t\t\t\t       unsigned int len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct buffer_head *page_bufs = NULL;\n\thandle_t *handle = NULL;\n\tint ret = 0, err = 0;\n\tint inline_data = ext4_has_inline_data(inode);\n\tstruct buffer_head *inode_bh = NULL;\n\n\tClearPageChecked(page);\n\n\tif (inline_data) {\n\t\tBUG_ON(page->index != 0);\n\t\tBUG_ON(len > ext4_get_max_inline_size(inode));\n\t\tinode_bh = ext4_journalled_write_inline_data(inode, len, page);\n\t\tif (inode_bh == NULL)\n\t\t\tgoto out;\n\t} else {\n\t\tpage_bufs = page_buffers(page);\n\t\tif (!page_bufs) {\n\t\t\tBUG();\n\t\t\tgoto out;\n\t\t}\n\t\text4_walk_page_buffers(handle, page_bufs, 0, len,\n\t\t\t\t       NULL, bget_one);\n\t}\n\t/*\n\t * We need to release the page lock before we start the\n\t * journal, so grab a reference so the page won't disappear\n\t * out from under us.\n\t */\n\tget_page(page);\n\tunlock_page(page);\n\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE,\n\t\t\t\t    ext4_writepage_trans_blocks(inode));\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tput_page(page);\n\t\tgoto out_no_pagelock;\n\t}\n\tBUG_ON(!ext4_handle_valid(handle));\n\n\tlock_page(page);\n\tput_page(page);\n\tif (page->mapping != mapping) {\n\t\t/* The page got truncated from under us */\n\t\text4_journal_stop(handle);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (inline_data) {\n\t\tBUFFER_TRACE(inode_bh, \"get write access\");\n\t\tret = ext4_journal_get_write_access(handle, inode_bh);\n\n\t\terr = ext4_handle_dirty_metadata(handle, inode, inode_bh);\n\n\t} else {\n\t\tret = ext4_walk_page_buffers(handle, page_bufs, 0, len, NULL,\n\t\t\t\t\t     do_journal_get_write_access);\n\n\t\terr = ext4_walk_page_buffers(handle, page_bufs, 0, len, NULL,\n\t\t\t\t\t     write_end_fn);\n\t}\n\tif (ret == 0)\n\t\tret = err;\n\tEXT4_I(inode)->i_datasync_tid = handle->h_transaction->t_tid;\n\terr = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\n\tif (!ext4_has_inline_data(inode))\n\t\text4_walk_page_buffers(NULL, page_bufs, 0, len,\n\t\t\t\t       NULL, bput_one);\n\text4_set_inode_state(inode, EXT4_STATE_JDATA);\nout:\n\tunlock_page(page);\nout_no_pagelock:\n\tbrelse(inode_bh);\n\treturn ret;\n}\n\n/*\n * Note that we don't need to start a transaction unless we're journaling data\n * because we should have holes filled from ext4_page_mkwrite(). We even don't\n * need to file the inode to the transaction's list in ordered mode because if\n * we are writing back data added by write(), the inode is already there and if\n * we are writing back data modified via mmap(), no one guarantees in which\n * transaction the data will hit the disk. In case we are journaling data, we\n * cannot start transaction directly because transaction start ranks above page\n * lock so we have to do some magic.\n *\n * This function can get called via...\n *   - ext4_writepages after taking page lock (have journal handle)\n *   - journal_submit_inode_data_buffers (no journal handle)\n *   - shrink_page_list via the kswapd/direct reclaim (no journal handle)\n *   - grab_page_cache when doing write_begin (have journal handle)\n *\n * We don't do any block allocation in this function. If we have page with\n * multiple blocks we need to write those buffer_heads that are mapped. This\n * is important for mmaped based write. So if we do with blocksize 1K\n * truncate(f, 1024);\n * a = mmap(f, 0, 4096);\n * a[0] = 'a';\n * truncate(f, 4096);\n * we have in the page first buffer_head mapped via page_mkwrite call back\n * but other buffer_heads would be unmapped but dirty (dirty done via the\n * do_wp_page). So writepage should write the first block. If we modify\n * the mmap area beyond 1024 we will again get a page_fault and the\n * page_mkwrite callback will do the block allocation and mark the\n * buffer_heads mapped.\n *\n * We redirty the page if we have any buffer_heads that is either delay or\n * unwritten in the page.\n *\n * We can get recursively called as show below.\n *\n *\text4_writepage() -> kmalloc() -> __alloc_pages() -> page_launder() ->\n *\t\text4_writepage()\n *\n * But since we don't do any block allocation we should not deadlock.\n * Page also have the dirty flag cleared so we don't get recurive page_lock.\n */\nstatic int ext4_writepage(struct page *page,\n\t\t\t  struct writeback_control *wbc)\n{\n\tint ret = 0;\n\tloff_t size;\n\tunsigned int len;\n\tstruct buffer_head *page_bufs = NULL;\n\tstruct inode *inode = page->mapping->host;\n\tstruct ext4_io_submit io_submit;\n\tbool keep_towrite = false;\n\n\ttrace_ext4_writepage(page);\n\tsize = i_size_read(inode);\n\tif (page->index == size >> PAGE_SHIFT)\n\t\tlen = size & ~PAGE_MASK;\n\telse\n\t\tlen = PAGE_SIZE;\n\n\tpage_bufs = page_buffers(page);\n\t/*\n\t * We cannot do block allocation or other extent handling in this\n\t * function. If there are buffers needing that, we have to redirty\n\t * the page. But we may reach here when we do a journal commit via\n\t * journal_submit_inode_data_buffers() and in that case we must write\n\t * allocated buffers to achieve data=ordered mode guarantees.\n\t *\n\t * Also, if there is only one buffer per page (the fs block\n\t * size == the page size), if one buffer needs block\n\t * allocation or needs to modify the extent tree to clear the\n\t * unwritten flag, we know that the page can't be written at\n\t * all, so we might as well refuse the write immediately.\n\t * Unfortunately if the block size != page size, we can't as\n\t * easily detect this case using ext4_walk_page_buffers(), but\n\t * for the extremely common case, this is an optimization that\n\t * skips a useless round trip through ext4_bio_write_page().\n\t */\n\tif (ext4_walk_page_buffers(NULL, page_bufs, 0, len, NULL,\n\t\t\t\t   ext4_bh_delay_or_unwritten)) {\n\t\tredirty_page_for_writepage(wbc, page);\n\t\tif ((current->flags & PF_MEMALLOC) ||\n\t\t    (inode->i_sb->s_blocksize == PAGE_SIZE)) {\n\t\t\t/*\n\t\t\t * For memory cleaning there's no point in writing only\n\t\t\t * some buffers. So just bail out. Warn if we came here\n\t\t\t * from direct reclaim.\n\t\t\t */\n\t\t\tWARN_ON_ONCE((current->flags & (PF_MEMALLOC|PF_KSWAPD))\n\t\t\t\t\t\t\t== PF_MEMALLOC);\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t\tkeep_towrite = true;\n\t}\n\n\tif (PageChecked(page) && ext4_should_journal_data(inode))\n\t\t/*\n\t\t * It's mmapped pagecache.  Add buffers and journal it.  There\n\t\t * doesn't seem much point in redirtying the page here.\n\t\t */\n\t\treturn __ext4_journalled_writepage(page, len);\n\n\text4_io_submit_init(&io_submit, wbc);\n\tio_submit.io_end = ext4_init_io_end(inode, GFP_NOFS);\n\tif (!io_submit.io_end) {\n\t\tredirty_page_for_writepage(wbc, page);\n\t\tunlock_page(page);\n\t\treturn -ENOMEM;\n\t}\n\tret = ext4_bio_write_page(&io_submit, page, len, wbc, keep_towrite);\n\text4_io_submit(&io_submit);\n\t/* Drop io_end reference we got from init */\n\text4_put_io_end_defer(io_submit.io_end);\n\treturn ret;\n}\n\nstatic int mpage_submit_page(struct mpage_da_data *mpd, struct page *page)\n{\n\tint len;\n\tloff_t size = i_size_read(mpd->inode);\n\tint err;\n\n\tBUG_ON(page->index != mpd->first_page);\n\tif (page->index == size >> PAGE_SHIFT)\n\t\tlen = size & ~PAGE_MASK;\n\telse\n\t\tlen = PAGE_SIZE;\n\tclear_page_dirty_for_io(page);\n\terr = ext4_bio_write_page(&mpd->io_submit, page, len, mpd->wbc, false);\n\tif (!err)\n\t\tmpd->wbc->nr_to_write--;\n\tmpd->first_page++;\n\n\treturn err;\n}\n\n#define BH_FLAGS ((1 << BH_Unwritten) | (1 << BH_Delay))\n\n/*\n * mballoc gives us at most this number of blocks...\n * XXX: That seems to be only a limitation of ext4_mb_normalize_request().\n * The rest of mballoc seems to handle chunks up to full group size.\n */\n#define MAX_WRITEPAGES_EXTENT_LEN 2048\n\n/*\n * mpage_add_bh_to_extent - try to add bh to extent of blocks to map\n *\n * @mpd - extent of blocks\n * @lblk - logical number of the block in the file\n * @bh - buffer head we want to add to the extent\n *\n * The function is used to collect contig. blocks in the same state. If the\n * buffer doesn't require mapping for writeback and we haven't started the\n * extent of buffers to map yet, the function returns 'true' immediately - the\n * caller can write the buffer right away. Otherwise the function returns true\n * if the block has been added to the extent, false if the block couldn't be\n * added.\n */\nstatic bool mpage_add_bh_to_extent(struct mpage_da_data *mpd, ext4_lblk_t lblk,\n\t\t\t\t   struct buffer_head *bh)\n{\n\tstruct ext4_map_blocks *map = &mpd->map;\n\n\t/* Buffer that doesn't need mapping for writeback? */\n\tif (!buffer_dirty(bh) || !buffer_mapped(bh) ||\n\t    (!buffer_delay(bh) && !buffer_unwritten(bh))) {\n\t\t/* So far no extent to map => we write the buffer right away */\n\t\tif (map->m_len == 0)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/* First block in the extent? */\n\tif (map->m_len == 0) {\n\t\tmap->m_lblk = lblk;\n\t\tmap->m_len = 1;\n\t\tmap->m_flags = bh->b_state & BH_FLAGS;\n\t\treturn true;\n\t}\n\n\t/* Don't go larger than mballoc is willing to allocate */\n\tif (map->m_len >= MAX_WRITEPAGES_EXTENT_LEN)\n\t\treturn false;\n\n\t/* Can we merge the block to our big extent? */\n\tif (lblk == map->m_lblk + map->m_len &&\n\t    (bh->b_state & BH_FLAGS) == map->m_flags) {\n\t\tmap->m_len++;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/*\n * mpage_process_page_bufs - submit page buffers for IO or add them to extent\n *\n * @mpd - extent of blocks for mapping\n * @head - the first buffer in the page\n * @bh - buffer we should start processing from\n * @lblk - logical number of the block in the file corresponding to @bh\n *\n * Walk through page buffers from @bh upto @head (exclusive) and either submit\n * the page for IO if all buffers in this page were mapped and there's no\n * accumulated extent of buffers to map or add buffers in the page to the\n * extent of buffers to map. The function returns 1 if the caller can continue\n * by processing the next page, 0 if it should stop adding buffers to the\n * extent to map because we cannot extend it anymore. It can also return value\n * < 0 in case of error during IO submission.\n */\nstatic int mpage_process_page_bufs(struct mpage_da_data *mpd,\n\t\t\t\t   struct buffer_head *head,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   ext4_lblk_t lblk)\n{\n\tstruct inode *inode = mpd->inode;\n\tint err;\n\text4_lblk_t blocks = (i_size_read(inode) + (1 << inode->i_blkbits) - 1)\n\t\t\t\t\t\t\t>> inode->i_blkbits;\n\n\tdo {\n\t\tBUG_ON(buffer_locked(bh));\n\n\t\tif (lblk >= blocks || !mpage_add_bh_to_extent(mpd, lblk, bh)) {\n\t\t\t/* Found extent to map? */\n\t\t\tif (mpd->map.m_len)\n\t\t\t\treturn 0;\n\t\t\t/* Everything mapped so far and we hit EOF */\n\t\t\tbreak;\n\t\t}\n\t} while (lblk++, (bh = bh->b_this_page) != head);\n\t/* So far everything mapped? Submit the page for IO. */\n\tif (mpd->map.m_len == 0) {\n\t\terr = mpage_submit_page(mpd, head->b_page);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn lblk < blocks;\n}\n\n/*\n * mpage_map_buffers - update buffers corresponding to changed extent and\n *\t\t       submit fully mapped pages for IO\n *\n * @mpd - description of extent to map, on return next extent to map\n *\n * Scan buffers corresponding to changed extent (we expect corresponding pages\n * to be already locked) and update buffer state according to new extent state.\n * We map delalloc buffers to their physical location, clear unwritten bits,\n * and mark buffers as uninit when we perform writes to unwritten extents\n * and do extent conversion after IO is finished. If the last page is not fully\n * mapped, we update @map to the next extent in the last page that needs\n * mapping. Otherwise we submit the page for IO.\n */\nstatic int mpage_map_and_submit_buffers(struct mpage_da_data *mpd)\n{\n\tstruct pagevec pvec;\n\tint nr_pages, i;\n\tstruct inode *inode = mpd->inode;\n\tstruct buffer_head *head, *bh;\n\tint bpp_bits = PAGE_SHIFT - inode->i_blkbits;\n\tpgoff_t start, end;\n\text4_lblk_t lblk;\n\tsector_t pblock;\n\tint err;\n\n\tstart = mpd->map.m_lblk >> bpp_bits;\n\tend = (mpd->map.m_lblk + mpd->map.m_len - 1) >> bpp_bits;\n\tlblk = start << bpp_bits;\n\tpblock = mpd->map.m_pblk;\n\n\tpagevec_init(&pvec, 0);\n\twhile (start <= end) {\n\t\tnr_pages = pagevec_lookup(&pvec, inode->i_mapping, start,\n\t\t\t\t\t  PAGEVEC_SIZE);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tif (page->index > end)\n\t\t\t\tbreak;\n\t\t\t/* Up to 'end' pages must be contiguous */\n\t\t\tBUG_ON(page->index != start);\n\t\t\tbh = head = page_buffers(page);\n\t\t\tdo {\n\t\t\t\tif (lblk < mpd->map.m_lblk)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (lblk >= mpd->map.m_lblk + mpd->map.m_len) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Buffer after end of mapped extent.\n\t\t\t\t\t * Find next buffer in the page to map.\n\t\t\t\t\t */\n\t\t\t\t\tmpd->map.m_len = 0;\n\t\t\t\t\tmpd->map.m_flags = 0;\n\t\t\t\t\t/*\n\t\t\t\t\t * FIXME: If dioread_nolock supports\n\t\t\t\t\t * blocksize < pagesize, we need to make\n\t\t\t\t\t * sure we add size mapped so far to\n\t\t\t\t\t * io_end->size as the following call\n\t\t\t\t\t * can submit the page for IO.\n\t\t\t\t\t */\n\t\t\t\t\terr = mpage_process_page_bufs(mpd, head,\n\t\t\t\t\t\t\t\t      bh, lblk);\n\t\t\t\t\tpagevec_release(&pvec);\n\t\t\t\t\tif (err > 0)\n\t\t\t\t\t\terr = 0;\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t\tif (buffer_delay(bh)) {\n\t\t\t\t\tclear_buffer_delay(bh);\n\t\t\t\t\tbh->b_blocknr = pblock++;\n\t\t\t\t}\n\t\t\t\tclear_buffer_unwritten(bh);\n\t\t\t} while (lblk++, (bh = bh->b_this_page) != head);\n\n\t\t\t/*\n\t\t\t * FIXME: This is going to break if dioread_nolock\n\t\t\t * supports blocksize < pagesize as we will try to\n\t\t\t * convert potentially unmapped parts of inode.\n\t\t\t */\n\t\t\tmpd->io_submit.io_end->size += PAGE_SIZE;\n\t\t\t/* Page fully mapped - let IO run! */\n\t\t\terr = mpage_submit_page(mpd, page);\n\t\t\tif (err < 0) {\n\t\t\t\tpagevec_release(&pvec);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tstart++;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t}\n\t/* Extent fully mapped and matches with page boundary. We are done. */\n\tmpd->map.m_len = 0;\n\tmpd->map.m_flags = 0;\n\treturn 0;\n}\n\nstatic int mpage_map_one_extent(handle_t *handle, struct mpage_da_data *mpd)\n{\n\tstruct inode *inode = mpd->inode;\n\tstruct ext4_map_blocks *map = &mpd->map;\n\tint get_blocks_flags;\n\tint err, dioread_nolock;\n\n\ttrace_ext4_da_write_pages_extent(inode, map);\n\t/*\n\t * Call ext4_map_blocks() to allocate any delayed allocation blocks, or\n\t * to convert an unwritten extent to be initialized (in the case\n\t * where we have written into one or more preallocated blocks).  It is\n\t * possible that we're going to need more metadata blocks than\n\t * previously reserved. However we must not fail because we're in\n\t * writeback and there is nothing we can do about it so it might result\n\t * in data loss.  So use reserved blocks to allocate metadata if\n\t * possible.\n\t *\n\t * We pass in the magic EXT4_GET_BLOCKS_DELALLOC_RESERVE if\n\t * the blocks in question are delalloc blocks.  This indicates\n\t * that the blocks and quotas has already been checked when\n\t * the data was copied into the page cache.\n\t */\n\tget_blocks_flags = EXT4_GET_BLOCKS_CREATE |\n\t\t\t   EXT4_GET_BLOCKS_METADATA_NOFAIL;\n\tdioread_nolock = ext4_should_dioread_nolock(inode);\n\tif (dioread_nolock)\n\t\tget_blocks_flags |= EXT4_GET_BLOCKS_IO_CREATE_EXT;\n\tif (map->m_flags & (1 << BH_Delay))\n\t\tget_blocks_flags |= EXT4_GET_BLOCKS_DELALLOC_RESERVE;\n\n\terr = ext4_map_blocks(handle, inode, map, get_blocks_flags);\n\tif (err < 0)\n\t\treturn err;\n\tif (dioread_nolock && (map->m_flags & EXT4_MAP_UNWRITTEN)) {\n\t\tif (!mpd->io_submit.io_end->handle &&\n\t\t    ext4_handle_valid(handle)) {\n\t\t\tmpd->io_submit.io_end->handle = handle->h_rsv_handle;\n\t\t\thandle->h_rsv_handle = NULL;\n\t\t}\n\t\text4_set_io_unwritten_flag(inode, mpd->io_submit.io_end);\n\t}\n\n\tBUG_ON(map->m_len == 0);\n\tif (map->m_flags & EXT4_MAP_NEW) {\n\t\tstruct block_device *bdev = inode->i_sb->s_bdev;\n\t\tint i;\n\n\t\tfor (i = 0; i < map->m_len; i++)\n\t\t\tunmap_underlying_metadata(bdev, map->m_pblk + i);\n\t}\n\treturn 0;\n}\n\n/*\n * mpage_map_and_submit_extent - map extent starting at mpd->lblk of length\n *\t\t\t\t mpd->len and submit pages underlying it for IO\n *\n * @handle - handle for journal operations\n * @mpd - extent to map\n * @give_up_on_write - we set this to true iff there is a fatal error and there\n *                     is no hope of writing the data. The caller should discard\n *                     dirty pages to avoid infinite loops.\n *\n * The function maps extent starting at mpd->lblk of length mpd->len. If it is\n * delayed, blocks are allocated, if it is unwritten, we may need to convert\n * them to initialized or split the described range from larger unwritten\n * extent. Note that we need not map all the described range since allocation\n * can return less blocks or the range is covered by more unwritten extents. We\n * cannot map more because we are limited by reserved transaction credits. On\n * the other hand we always make sure that the last touched page is fully\n * mapped so that it can be written out (and thus forward progress is\n * guaranteed). After mapping we submit all mapped pages for IO.\n */\nstatic int mpage_map_and_submit_extent(handle_t *handle,\n\t\t\t\t       struct mpage_da_data *mpd,\n\t\t\t\t       bool *give_up_on_write)\n{\n\tstruct inode *inode = mpd->inode;\n\tstruct ext4_map_blocks *map = &mpd->map;\n\tint err;\n\tloff_t disksize;\n\tint progress = 0;\n\n\tmpd->io_submit.io_end->offset =\n\t\t\t\t((loff_t)map->m_lblk) << inode->i_blkbits;\n\tdo {\n\t\terr = mpage_map_one_extent(handle, mpd);\n\t\tif (err < 0) {\n\t\t\tstruct super_block *sb = inode->i_sb;\n\n\t\t\tif (EXT4_SB(sb)->s_mount_flags & EXT4_MF_FS_ABORTED)\n\t\t\t\tgoto invalidate_dirty_pages;\n\t\t\t/*\n\t\t\t * Let the uper layers retry transient errors.\n\t\t\t * In the case of ENOSPC, if ext4_count_free_blocks()\n\t\t\t * is non-zero, a commit should free up blocks.\n\t\t\t */\n\t\t\tif ((err == -ENOMEM) ||\n\t\t\t    (err == -ENOSPC && ext4_count_free_clusters(sb))) {\n\t\t\t\tif (progress)\n\t\t\t\t\tgoto update_disksize;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\text4_msg(sb, KERN_CRIT,\n\t\t\t\t \"Delayed block allocation failed for \"\n\t\t\t\t \"inode %lu at logical offset %llu with\"\n\t\t\t\t \" max blocks %u with error %d\",\n\t\t\t\t inode->i_ino,\n\t\t\t\t (unsigned long long)map->m_lblk,\n\t\t\t\t (unsigned)map->m_len, -err);\n\t\t\text4_msg(sb, KERN_CRIT,\n\t\t\t\t \"This should not happen!! Data will \"\n\t\t\t\t \"be lost\\n\");\n\t\t\tif (err == -ENOSPC)\n\t\t\t\text4_print_free_blocks(inode);\n\t\tinvalidate_dirty_pages:\n\t\t\t*give_up_on_write = true;\n\t\t\treturn err;\n\t\t}\n\t\tprogress = 1;\n\t\t/*\n\t\t * Update buffer state, submit mapped pages, and get us new\n\t\t * extent to map\n\t\t */\n\t\terr = mpage_map_and_submit_buffers(mpd);\n\t\tif (err < 0)\n\t\t\tgoto update_disksize;\n\t} while (map->m_len);\n\nupdate_disksize:\n\t/*\n\t * Update on-disk size after IO is submitted.  Races with\n\t * truncate are avoided by checking i_size under i_data_sem.\n\t */\n\tdisksize = ((loff_t)mpd->first_page) << PAGE_SHIFT;\n\tif (disksize > EXT4_I(inode)->i_disksize) {\n\t\tint err2;\n\t\tloff_t i_size;\n\n\t\tdown_write(&EXT4_I(inode)->i_data_sem);\n\t\ti_size = i_size_read(inode);\n\t\tif (disksize > i_size)\n\t\t\tdisksize = i_size;\n\t\tif (disksize > EXT4_I(inode)->i_disksize)\n\t\t\tEXT4_I(inode)->i_disksize = disksize;\n\t\terr2 = ext4_mark_inode_dirty(handle, inode);\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tif (err2)\n\t\t\text4_error(inode->i_sb,\n\t\t\t\t   \"Failed to mark inode %lu dirty\",\n\t\t\t\t   inode->i_ino);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\treturn err;\n}\n\n/*\n * Calculate the total number of credits to reserve for one writepages\n * iteration. This is called from ext4_writepages(). We map an extent of\n * up to MAX_WRITEPAGES_EXTENT_LEN blocks and then we go on and finish mapping\n * the last partial page. So in total we can map MAX_WRITEPAGES_EXTENT_LEN +\n * bpp - 1 blocks in bpp different extents.\n */\nstatic int ext4_da_writepages_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\n\treturn ext4_meta_trans_blocks(inode,\n\t\t\t\tMAX_WRITEPAGES_EXTENT_LEN + bpp - 1, bpp);\n}\n\n/*\n * mpage_prepare_extent_to_map - find & lock contiguous range of dirty pages\n * \t\t\t\t and underlying extent to map\n *\n * @mpd - where to look for pages\n *\n * Walk dirty pages in the mapping. If they are fully mapped, submit them for\n * IO immediately. When we find a page which isn't mapped we start accumulating\n * extent of buffers underlying these pages that needs mapping (formed by\n * either delayed or unwritten buffers). We also lock the pages containing\n * these buffers. The extent found is returned in @mpd structure (starting at\n * mpd->lblk with length mpd->len blocks).\n *\n * Note that this function can attach bios to one io_end structure which are\n * neither logically nor physically contiguous. Although it may seem as an\n * unnecessary complication, it is actually inevitable in blocksize < pagesize\n * case as we need to track IO to all buffers underlying a page in one io_end.\n */\nstatic int mpage_prepare_extent_to_map(struct mpage_da_data *mpd)\n{\n\tstruct address_space *mapping = mpd->inode->i_mapping;\n\tstruct pagevec pvec;\n\tunsigned int nr_pages;\n\tlong left = mpd->wbc->nr_to_write;\n\tpgoff_t index = mpd->first_page;\n\tpgoff_t end = mpd->last_page;\n\tint tag;\n\tint i, err = 0;\n\tint blkbits = mpd->inode->i_blkbits;\n\text4_lblk_t lblk;\n\tstruct buffer_head *head;\n\n\tif (mpd->wbc->sync_mode == WB_SYNC_ALL || mpd->wbc->tagged_writepages)\n\t\ttag = PAGECACHE_TAG_TOWRITE;\n\telse\n\t\ttag = PAGECACHE_TAG_DIRTY;\n\n\tpagevec_init(&pvec, 0);\n\tmpd->map.m_len = 0;\n\tmpd->next_page = index;\n\twhile (index <= end) {\n\t\tnr_pages = pagevec_lookup_tag(&pvec, mapping, &index, tag,\n\t\t\t      min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tgoto out;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/*\n\t\t\t * At this point, the page may be truncated or\n\t\t\t * invalidated (changing page->mapping to NULL), or\n\t\t\t * even swizzled back from swapper_space to tmpfs file\n\t\t\t * mapping. However, page->index will not change\n\t\t\t * because we have a reference on the page.\n\t\t\t */\n\t\t\tif (page->index > end)\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t * Accumulated enough dirty pages? This doesn't apply\n\t\t\t * to WB_SYNC_ALL mode. For integrity sync we have to\n\t\t\t * keep going because someone may be concurrently\n\t\t\t * dirtying pages, and we might have synced a lot of\n\t\t\t * newly appeared dirty pages, but have not synced all\n\t\t\t * of the old dirty pages.\n\t\t\t */\n\t\t\tif (mpd->wbc->sync_mode == WB_SYNC_NONE && left <= 0)\n\t\t\t\tgoto out;\n\n\t\t\t/* If we can't merge this page, we are done. */\n\t\t\tif (mpd->map.m_len > 0 && mpd->next_page != page->index)\n\t\t\t\tgoto out;\n\n\t\t\tlock_page(page);\n\t\t\t/*\n\t\t\t * If the page is no longer dirty, or its mapping no\n\t\t\t * longer corresponds to inode we are writing (which\n\t\t\t * means it has been truncated or invalidated), or the\n\t\t\t * page is already under writeback and we are not doing\n\t\t\t * a data integrity writeback, skip the page\n\t\t\t */\n\t\t\tif (!PageDirty(page) ||\n\t\t\t    (PageWriteback(page) &&\n\t\t\t     (mpd->wbc->sync_mode == WB_SYNC_NONE)) ||\n\t\t\t    unlikely(page->mapping != mapping)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twait_on_page_writeback(page);\n\t\t\tBUG_ON(PageWriteback(page));\n\n\t\t\tif (mpd->map.m_len == 0)\n\t\t\t\tmpd->first_page = page->index;\n\t\t\tmpd->next_page = page->index + 1;\n\t\t\t/* Add all dirty buffers to mpd */\n\t\t\tlblk = ((ext4_lblk_t)page->index) <<\n\t\t\t\t(PAGE_SHIFT - blkbits);\n\t\t\thead = page_buffers(page);\n\t\t\terr = mpage_process_page_bufs(mpd, head, head, lblk);\n\t\t\tif (err <= 0)\n\t\t\t\tgoto out;\n\t\t\terr = 0;\n\t\t\tleft--;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\treturn 0;\nout:\n\tpagevec_release(&pvec);\n\treturn err;\n}\n\nstatic int __writepage(struct page *page, struct writeback_control *wbc,\n\t\t       void *data)\n{\n\tstruct address_space *mapping = data;\n\tint ret = ext4_writepage(page, wbc);\n\tmapping_set_error(mapping, ret);\n\treturn ret;\n}\n\nstatic int ext4_writepages(struct address_space *mapping,\n\t\t\t   struct writeback_control *wbc)\n{\n\tpgoff_t\twriteback_index = 0;\n\tlong nr_to_write = wbc->nr_to_write;\n\tint range_whole = 0;\n\tint cycled = 1;\n\thandle_t *handle = NULL;\n\tstruct mpage_da_data mpd;\n\tstruct inode *inode = mapping->host;\n\tint needed_blocks, rsv_blocks = 0, ret = 0;\n\tstruct ext4_sb_info *sbi = EXT4_SB(mapping->host->i_sb);\n\tbool done;\n\tstruct blk_plug plug;\n\tbool give_up_on_write = false;\n\n\ttrace_ext4_writepages(inode, wbc);\n\n\tif (dax_mapping(mapping))\n\t\treturn dax_writeback_mapping_range(mapping, inode->i_sb->s_bdev,\n\t\t\t\t\t\t   wbc);\n\n\t/*\n\t * No pages to write? This is mainly a kludge to avoid starting\n\t * a transaction for special inodes like journal inode on last iput()\n\t * because that could violate lock ordering on umount\n\t */\n\tif (!mapping->nrpages || !mapping_tagged(mapping, PAGECACHE_TAG_DIRTY))\n\t\tgoto out_writepages;\n\n\tif (ext4_should_journal_data(inode)) {\n\t\tstruct blk_plug plug;\n\n\t\tblk_start_plug(&plug);\n\t\tret = write_cache_pages(mapping, wbc, __writepage, mapping);\n\t\tblk_finish_plug(&plug);\n\t\tgoto out_writepages;\n\t}\n\n\t/*\n\t * If the filesystem has aborted, it is read-only, so return\n\t * right away instead of dumping stack traces later on that\n\t * will obscure the real source of the problem.  We test\n\t * EXT4_MF_FS_ABORTED instead of sb->s_flag's MS_RDONLY because\n\t * the latter could be true if the filesystem is mounted\n\t * read-only, and in that case, ext4_writepages should\n\t * *never* be called, so if that ever happens, we would want\n\t * the stack trace.\n\t */\n\tif (unlikely(sbi->s_mount_flags & EXT4_MF_FS_ABORTED)) {\n\t\tret = -EROFS;\n\t\tgoto out_writepages;\n\t}\n\n\tif (ext4_should_dioread_nolock(inode)) {\n\t\t/*\n\t\t * We may need to convert up to one extent per block in\n\t\t * the page and we may dirty the inode.\n\t\t */\n\t\trsv_blocks = 1 + (PAGE_SIZE >> inode->i_blkbits);\n\t}\n\n\t/*\n\t * If we have inline data and arrive here, it means that\n\t * we will soon create the block for the 1st page, so\n\t * we'd better clear the inline data here.\n\t */\n\tif (ext4_has_inline_data(inode)) {\n\t\t/* Just inode will be modified... */\n\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tgoto out_writepages;\n\t\t}\n\t\tBUG_ON(ext4_test_inode_state(inode,\n\t\t\t\tEXT4_STATE_MAY_INLINE_DATA));\n\t\text4_destroy_inline_data(handle, inode);\n\t\text4_journal_stop(handle);\n\t}\n\n\tif (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)\n\t\trange_whole = 1;\n\n\tif (wbc->range_cyclic) {\n\t\twriteback_index = mapping->writeback_index;\n\t\tif (writeback_index)\n\t\t\tcycled = 0;\n\t\tmpd.first_page = writeback_index;\n\t\tmpd.last_page = -1;\n\t} else {\n\t\tmpd.first_page = wbc->range_start >> PAGE_SHIFT;\n\t\tmpd.last_page = wbc->range_end >> PAGE_SHIFT;\n\t}\n\n\tmpd.inode = inode;\n\tmpd.wbc = wbc;\n\text4_io_submit_init(&mpd.io_submit, wbc);\nretry:\n\tif (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)\n\t\ttag_pages_for_writeback(mapping, mpd.first_page, mpd.last_page);\n\tdone = false;\n\tblk_start_plug(&plug);\n\twhile (!done && mpd.first_page <= mpd.last_page) {\n\t\t/* For each extent of pages we use new io_end */\n\t\tmpd.io_submit.io_end = ext4_init_io_end(inode, GFP_KERNEL);\n\t\tif (!mpd.io_submit.io_end) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We have two constraints: We find one extent to map and we\n\t\t * must always write out whole page (makes a difference when\n\t\t * blocksize < pagesize) so that we don't block on IO when we\n\t\t * try to write out the rest of the page. Journalled mode is\n\t\t * not supported by delalloc.\n\t\t */\n\t\tBUG_ON(ext4_should_journal_data(inode));\n\t\tneeded_blocks = ext4_da_writepages_trans_blocks(inode);\n\n\t\t/* start a new transaction */\n\t\thandle = ext4_journal_start_with_reserve(inode,\n\t\t\t\tEXT4_HT_WRITE_PAGE, needed_blocks, rsv_blocks);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\text4_msg(inode->i_sb, KERN_CRIT, \"%s: jbd2_start: \"\n\t\t\t       \"%ld pages, ino %lu; err %d\", __func__,\n\t\t\t\twbc->nr_to_write, inode->i_ino, ret);\n\t\t\t/* Release allocated io_end */\n\t\t\text4_put_io_end(mpd.io_submit.io_end);\n\t\t\tbreak;\n\t\t}\n\n\t\ttrace_ext4_da_write_pages(inode, mpd.first_page, mpd.wbc);\n\t\tret = mpage_prepare_extent_to_map(&mpd);\n\t\tif (!ret) {\n\t\t\tif (mpd.map.m_len)\n\t\t\t\tret = mpage_map_and_submit_extent(handle, &mpd,\n\t\t\t\t\t&give_up_on_write);\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * We scanned the whole range (or exhausted\n\t\t\t\t * nr_to_write), submitted what was mapped and\n\t\t\t\t * didn't find anything needing mapping. We are\n\t\t\t\t * done.\n\t\t\t\t */\n\t\t\t\tdone = true;\n\t\t\t}\n\t\t}\n\t\text4_journal_stop(handle);\n\t\t/* Submit prepared bio */\n\t\text4_io_submit(&mpd.io_submit);\n\t\t/* Unlock pages we didn't use */\n\t\tmpage_release_unused_pages(&mpd, give_up_on_write);\n\t\t/* Drop our io_end reference we got from init */\n\t\text4_put_io_end(mpd.io_submit.io_end);\n\n\t\tif (ret == -ENOSPC && sbi->s_journal) {\n\t\t\t/*\n\t\t\t * Commit the transaction which would\n\t\t\t * free blocks released in the transaction\n\t\t\t * and try again\n\t\t\t */\n\t\t\tjbd2_journal_force_commit_nested(sbi->s_journal);\n\t\t\tret = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Fatal error - ENOMEM, EIO... */\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tblk_finish_plug(&plug);\n\tif (!ret && !cycled && wbc->nr_to_write > 0) {\n\t\tcycled = 1;\n\t\tmpd.last_page = writeback_index - 1;\n\t\tmpd.first_page = 0;\n\t\tgoto retry;\n\t}\n\n\t/* Update index */\n\tif (wbc->range_cyclic || (range_whole && wbc->nr_to_write > 0))\n\t\t/*\n\t\t * Set the writeback_index so that range_cyclic\n\t\t * mode will write it back later\n\t\t */\n\t\tmapping->writeback_index = mpd.first_page;\n\nout_writepages:\n\ttrace_ext4_writepages_result(inode, wbc, ret,\n\t\t\t\t     nr_to_write - wbc->nr_to_write);\n\treturn ret;\n}\n\nstatic int ext4_nonda_switch(struct super_block *sb)\n{\n\ts64 free_clusters, dirty_clusters;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\t/*\n\t * switch to non delalloc mode if we are running low\n\t * on free block. The free block accounting via percpu\n\t * counters can get slightly wrong with percpu_counter_batch getting\n\t * accumulated on each CPU without updating global counters\n\t * Delalloc need an accurate free block accounting. So switch\n\t * to non delalloc when we are near to error range.\n\t */\n\tfree_clusters =\n\t\tpercpu_counter_read_positive(&sbi->s_freeclusters_counter);\n\tdirty_clusters =\n\t\tpercpu_counter_read_positive(&sbi->s_dirtyclusters_counter);\n\t/*\n\t * Start pushing delalloc when 1/2 of free blocks are dirty.\n\t */\n\tif (dirty_clusters && (free_clusters < 2 * dirty_clusters))\n\t\ttry_to_writeback_inodes_sb(sb, WB_REASON_FS_FREE_SPACE);\n\n\tif (2 * free_clusters < 3 * dirty_clusters ||\n\t    free_clusters < (dirty_clusters + EXT4_FREECLUSTERS_WATERMARK)) {\n\t\t/*\n\t\t * free block count is less than 150% of dirty blocks\n\t\t * or free blocks is less than watermark\n\t\t */\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/* We always reserve for an inode update; the superblock could be there too */\nstatic int ext4_da_write_credits(struct inode *inode, loff_t pos, unsigned len)\n{\n\tif (likely(ext4_has_feature_large_file(inode->i_sb)))\n\t\treturn 1;\n\n\tif (pos + len <= 0x7fffffffULL)\n\t\treturn 1;\n\n\t/* We might need to update the superblock to set LARGE_FILE */\n\treturn 2;\n}\n\nstatic int ext4_da_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t       loff_t pos, unsigned len, unsigned flags,\n\t\t\t       struct page **pagep, void **fsdata)\n{\n\tint ret, retries = 0;\n\tstruct page *page;\n\tpgoff_t index;\n\tstruct inode *inode = mapping->host;\n\thandle_t *handle;\n\n\tindex = pos >> PAGE_SHIFT;\n\n\tif (ext4_nonda_switch(inode->i_sb)) {\n\t\t*fsdata = (void *)FALL_BACK_TO_NONDELALLOC;\n\t\treturn ext4_write_begin(file, mapping, pos,\n\t\t\t\t\tlen, flags, pagep, fsdata);\n\t}\n\t*fsdata = (void *)0;\n\ttrace_ext4_da_write_begin(inode, pos, len, flags);\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA)) {\n\t\tret = ext4_da_write_inline_data_begin(mapping, inode,\n\t\t\t\t\t\t      pos, len, flags,\n\t\t\t\t\t\t      pagep, fsdata);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 1)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * grab_cache_page_write_begin() can take a long time if the\n\t * system is thrashing due to memory pressure, or if the page\n\t * is being written back.  So grab it first before we start\n\t * the transaction handle.  This also allows us to allocate\n\t * the page (if needed) without using GFP_NOFS.\n\t */\nretry_grab:\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tunlock_page(page);\n\n\t/*\n\t * With delayed allocation, we don't log the i_disksize update\n\t * if there is delayed block allocation. But we still need\n\t * to journalling the i_disksize update if writes to the end\n\t * of file which has an already mapped buffer.\n\t */\nretry_journal:\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE,\n\t\t\t\text4_da_write_credits(inode, pos, len));\n\tif (IS_ERR(handle)) {\n\t\tput_page(page);\n\t\treturn PTR_ERR(handle);\n\t}\n\n\tlock_page(page);\n\tif (page->mapping != mapping) {\n\t\t/* The page got truncated from under us */\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\text4_journal_stop(handle);\n\t\tgoto retry_grab;\n\t}\n\t/* In case writeback began while the page was unlocked */\n\twait_for_stable_page(page);\n\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tret = ext4_block_write_begin(page, pos, len,\n\t\t\t\t     ext4_da_get_block_prep);\n#else\n\tret = __block_write_begin(page, pos, len, ext4_da_get_block_prep);\n#endif\n\tif (ret < 0) {\n\t\tunlock_page(page);\n\t\text4_journal_stop(handle);\n\t\t/*\n\t\t * block_write_begin may have instantiated a few blocks\n\t\t * outside i_size.  Trim these off again. Don't need\n\t\t * i_size_read because we hold i_mutex.\n\t\t */\n\t\tif (pos + len > inode->i_size)\n\t\t\text4_truncate_failed_write(inode);\n\n\t\tif (ret == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\t\tgoto retry_journal;\n\n\t\tput_page(page);\n\t\treturn ret;\n\t}\n\n\t*pagep = page;\n\treturn ret;\n}\n\n/*\n * Check if we should update i_disksize\n * when write to the end of file but not require block allocation\n */\nstatic int ext4_da_should_update_i_disksize(struct page *page,\n\t\t\t\t\t    unsigned long offset)\n{\n\tstruct buffer_head *bh;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned int idx;\n\tint i;\n\n\tbh = page_buffers(page);\n\tidx = offset >> inode->i_blkbits;\n\n\tfor (i = 0; i < idx; i++)\n\t\tbh = bh->b_this_page;\n\n\tif (!buffer_mapped(bh) || (buffer_delay(bh)) || buffer_unwritten(bh))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int ext4_da_write_end(struct file *file,\n\t\t\t     struct address_space *mapping,\n\t\t\t     loff_t pos, unsigned len, unsigned copied,\n\t\t\t     struct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint ret = 0, ret2;\n\thandle_t *handle = ext4_journal_current_handle();\n\tloff_t new_i_size;\n\tunsigned long start, end;\n\tint write_mode = (int)(unsigned long)fsdata;\n\n\tif (write_mode == FALL_BACK_TO_NONDELALLOC)\n\t\treturn ext4_write_end(file, mapping, pos,\n\t\t\t\t      len, copied, page, fsdata);\n\n\ttrace_ext4_da_write_end(inode, pos, len, copied);\n\tstart = pos & (PAGE_SIZE - 1);\n\tend = start + copied - 1;\n\n\t/*\n\t * generic_write_end() will run mark_inode_dirty() if i_size\n\t * changes.  So let's piggyback the i_disksize mark_inode_dirty\n\t * into that.\n\t */\n\tnew_i_size = pos + copied;\n\tif (copied && new_i_size > EXT4_I(inode)->i_disksize) {\n\t\tif (ext4_has_inline_data(inode) ||\n\t\t    ext4_da_should_update_i_disksize(page, end)) {\n\t\t\text4_update_i_disksize(inode, new_i_size);\n\t\t\t/* We need to mark inode dirty even if\n\t\t\t * new_i_size is less that inode->i_size\n\t\t\t * bu greater than i_disksize.(hint delalloc)\n\t\t\t */\n\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t}\n\t}\n\n\tif (write_mode != CONVERT_INLINE_DATA &&\n\t    ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA) &&\n\t    ext4_has_inline_data(inode))\n\t\tret2 = ext4_da_write_inline_data_end(inode, pos, len, copied,\n\t\t\t\t\t\t     page);\n\telse\n\t\tret2 = generic_write_end(file, mapping, pos, len, copied,\n\t\t\t\t\t\t\tpage, fsdata);\n\n\tcopied = ret2;\n\tif (ret2 < 0)\n\t\tret = ret2;\n\tret2 = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = ret2;\n\n\treturn ret ? ret : copied;\n}\n\nstatic void ext4_da_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\t   unsigned int length)\n{\n\t/*\n\t * Drop reserved blocks\n\t */\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\tgoto out;\n\n\text4_da_page_release_reservation(page, offset, length);\n\nout:\n\text4_invalidatepage(page, offset, length);\n\n\treturn;\n}\n\n/*\n * Force all delayed allocation blocks to be allocated for a given inode.\n */\nint ext4_alloc_da_blocks(struct inode *inode)\n{\n\ttrace_ext4_alloc_da_blocks(inode);\n\n\tif (!EXT4_I(inode)->i_reserved_data_blocks)\n\t\treturn 0;\n\n\t/*\n\t * We do something simple for now.  The filemap_flush() will\n\t * also start triggering a write of the data blocks, which is\n\t * not strictly speaking necessary (and for users of\n\t * laptop_mode, not even desirable).  However, to do otherwise\n\t * would require replicating code paths in:\n\t *\n\t * ext4_writepages() ->\n\t *    write_cache_pages() ---> (via passed in callback function)\n\t *        __mpage_da_writepage() -->\n\t *           mpage_add_bh_to_extent()\n\t *           mpage_da_map_blocks()\n\t *\n\t * The problem is that write_cache_pages(), located in\n\t * mm/page-writeback.c, marks pages clean in preparation for\n\t * doing I/O, which is not desirable if we're not planning on\n\t * doing I/O at all.\n\t *\n\t * We could call write_cache_pages(), and then redirty all of\n\t * the pages by calling redirty_page_for_writepage() but that\n\t * would be ugly in the extreme.  So instead we would need to\n\t * replicate parts of the code in the above functions,\n\t * simplifying them because we wouldn't actually intend to\n\t * write out the pages, but rather only collect contiguous\n\t * logical block extents, call the multi-block allocator, and\n\t * then update the buffer heads with the block allocations.\n\t *\n\t * For now, though, we'll cheat by calling filemap_flush(),\n\t * which will map the blocks, and start the I/O, but not\n\t * actually wait for the I/O to complete.\n\t */\n\treturn filemap_flush(inode->i_mapping);\n}\n\n/*\n * bmap() is special.  It gets used by applications such as lilo and by\n * the swapper to find the on-disk block of a specific piece of data.\n *\n * Naturally, this is dangerous if the block concerned is still in the\n * journal.  If somebody makes a swapfile on an ext4 data-journaling\n * filesystem and enables swap, then they may get a nasty shock when the\n * data getting swapped to that swapfile suddenly gets overwritten by\n * the original zero's written out previously to the journal and\n * awaiting writeback in the kernel's buffer cache.\n *\n * So, if we see any bmap calls here on a modified, data-journaled file,\n * take extra steps to flush any blocks which might be in the cache.\n */\nstatic sector_t ext4_bmap(struct address_space *mapping, sector_t block)\n{\n\tstruct inode *inode = mapping->host;\n\tjournal_t *journal;\n\tint err;\n\n\t/*\n\t * We can get here for an inline file via the FIBMAP ioctl\n\t */\n\tif (ext4_has_inline_data(inode))\n\t\treturn 0;\n\n\tif (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY) &&\n\t\t\ttest_opt(inode->i_sb, DELALLOC)) {\n\t\t/*\n\t\t * With delalloc we want to sync the file\n\t\t * so that we can make sure we allocate\n\t\t * blocks for file\n\t\t */\n\t\tfilemap_write_and_wait(mapping);\n\t}\n\n\tif (EXT4_JOURNAL(inode) &&\n\t    ext4_test_inode_state(inode, EXT4_STATE_JDATA)) {\n\t\t/*\n\t\t * This is a REALLY heavyweight approach, but the use of\n\t\t * bmap on dirty files is expected to be extremely rare:\n\t\t * only if we run lilo or swapon on a freshly made file\n\t\t * do we expect this to happen.\n\t\t *\n\t\t * (bmap requires CAP_SYS_RAWIO so this does not\n\t\t * represent an unprivileged user DOS attack --- we'd be\n\t\t * in trouble if mortal users could trigger this path at\n\t\t * will.)\n\t\t *\n\t\t * NB. EXT4_STATE_JDATA is not set on files other than\n\t\t * regular files.  If somebody wants to bmap a directory\n\t\t * or symlink and gets confused because the buffer\n\t\t * hasn't yet been flushed to disk, they deserve\n\t\t * everything they get.\n\t\t */\n\n\t\text4_clear_inode_state(inode, EXT4_STATE_JDATA);\n\t\tjournal = EXT4_JOURNAL(inode);\n\t\tjbd2_journal_lock_updates(journal);\n\t\terr = jbd2_journal_flush(journal);\n\t\tjbd2_journal_unlock_updates(journal);\n\n\t\tif (err)\n\t\t\treturn 0;\n\t}\n\n\treturn generic_block_bmap(mapping, block, ext4_get_block);\n}\n\nstatic int ext4_readpage(struct file *file, struct page *page)\n{\n\tint ret = -EAGAIN;\n\tstruct inode *inode = page->mapping->host;\n\n\ttrace_ext4_readpage(page);\n\n\tif (ext4_has_inline_data(inode))\n\t\tret = ext4_readpage_inline(inode, page);\n\n\tif (ret == -EAGAIN)\n\t\treturn ext4_mpage_readpages(page->mapping, NULL, page, 1);\n\n\treturn ret;\n}\n\nstatic int\next4_readpages(struct file *file, struct address_space *mapping,\n\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\tstruct inode *inode = mapping->host;\n\n\t/* If the file has inline data, no need to do readpages. */\n\tif (ext4_has_inline_data(inode))\n\t\treturn 0;\n\n\treturn ext4_mpage_readpages(mapping, pages, NULL, nr_pages);\n}\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length)\n{\n\ttrace_ext4_invalidatepage(page, offset, length);\n\n\t/* No journalling happens on data buffers when this function is used */\n\tWARN_ON(page_has_buffers(page) && buffer_jbd(page_buffers(page)));\n\n\tblock_invalidatepage(page, offset, length);\n}\n\nstatic int __ext4_journalled_invalidatepage(struct page *page,\n\t\t\t\t\t    unsigned int offset,\n\t\t\t\t\t    unsigned int length)\n{\n\tjournal_t *journal = EXT4_JOURNAL(page->mapping->host);\n\n\ttrace_ext4_journalled_invalidatepage(page, offset, length);\n\n\t/*\n\t * If it's a full truncate we just forget about the pending dirtying\n\t */\n\tif (offset == 0 && length == PAGE_SIZE)\n\t\tClearPageChecked(page);\n\n\treturn jbd2_journal_invalidatepage(journal, page, offset, length);\n}\n\n/* Wrapper for aops... */\nstatic void ext4_journalled_invalidatepage(struct page *page,\n\t\t\t\t\t   unsigned int offset,\n\t\t\t\t\t   unsigned int length)\n{\n\tWARN_ON(__ext4_journalled_invalidatepage(page, offset, length) < 0);\n}\n\nstatic int ext4_releasepage(struct page *page, gfp_t wait)\n{\n\tjournal_t *journal = EXT4_JOURNAL(page->mapping->host);\n\n\ttrace_ext4_releasepage(page);\n\n\t/* Page has dirty journalled data -> cannot release */\n\tif (PageChecked(page))\n\t\treturn 0;\n\tif (journal)\n\t\treturn jbd2_journal_try_to_free_buffers(journal, page, wait);\n\telse\n\t\treturn try_to_free_buffers(page);\n}\n\n#ifdef CONFIG_FS_DAX\nint ext4_dax_mmap_get_block(struct inode *inode, sector_t iblock,\n\t\t\t    struct buffer_head *bh_result, int create)\n{\n\tint ret, err;\n\tint credits;\n\tstruct ext4_map_blocks map;\n\thandle_t *handle = NULL;\n\tint flags = 0;\n\n\text4_debug(\"ext4_dax_mmap_get_block: inode %lu, create flag %d\\n\",\n\t\t   inode->i_ino, create);\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh_result->b_size >> inode->i_blkbits;\n\tcredits = ext4_chunk_trans_blocks(inode, map.m_len);\n\tif (create) {\n\t\tflags |= EXT4_GET_BLOCKS_PRE_IO | EXT4_GET_BLOCKS_CREATE_ZERO;\n\t\thandle = ext4_journal_start(inode, EXT4_HT_MAP_BLOCKS, credits);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = ext4_map_blocks(handle, inode, &map, flags);\n\tif (create) {\n\t\terr = ext4_journal_stop(handle);\n\t\tif (ret >= 0 && err < 0)\n\t\t\tret = err;\n\t}\n\tif (ret <= 0)\n\t\tgoto out;\n\tif (map.m_flags & EXT4_MAP_UNWRITTEN) {\n\t\tint err2;\n\n\t\t/*\n\t\t * We are protected by i_mmap_sem so we know block cannot go\n\t\t * away from under us even though we dropped i_data_sem.\n\t\t * Convert extent to written and write zeros there.\n\t\t *\n\t\t * Note: We may get here even when create == 0.\n\t\t */\n\t\thandle = ext4_journal_start(inode, EXT4_HT_MAP_BLOCKS, credits);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ext4_map_blocks(handle, inode, &map,\n\t\t      EXT4_GET_BLOCKS_CONVERT | EXT4_GET_BLOCKS_CREATE_ZERO);\n\t\tif (err < 0)\n\t\t\tret = err;\n\t\terr2 = ext4_journal_stop(handle);\n\t\tif (err2 < 0 && ret > 0)\n\t\t\tret = err2;\n\t}\nout:\n\tWARN_ON_ONCE(ret == 0 && create);\n\tif (ret > 0) {\n\t\tmap_bh(bh_result, inode->i_sb, map.m_pblk);\n\t\t/*\n\t\t * At least for now we have to clear BH_New so that DAX code\n\t\t * doesn't attempt to zero blocks again in a racy way.\n\t\t */\n\t\tmap.m_flags &= ~EXT4_MAP_NEW;\n\t\text4_update_bh_state(bh_result, map.m_flags);\n\t\tbh_result->b_size = map.m_len << inode->i_blkbits;\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n#endif\n\nstatic int ext4_end_io_dio(struct kiocb *iocb, loff_t offset,\n\t\t\t    ssize_t size, void *private)\n{\n        ext4_io_end_t *io_end = private;\n\n\t/* if not async direct IO just return */\n\tif (!io_end)\n\t\treturn 0;\n\n\text_debug(\"ext4_end_io_dio(): io_end 0x%p \"\n\t\t  \"for inode %lu, iocb 0x%p, offset %llu, size %zd\\n\",\n\t\t  io_end, io_end->inode->i_ino, iocb, offset, size);\n\n\t/*\n\t * Error during AIO DIO. We cannot convert unwritten extents as the\n\t * data was not written. Just clear the unwritten flag and drop io_end.\n\t */\n\tif (size <= 0) {\n\t\text4_clear_io_unwritten_flag(io_end);\n\t\tsize = 0;\n\t}\n\tio_end->offset = offset;\n\tio_end->size = size;\n\text4_put_io_end(io_end);\n\n\treturn 0;\n}\n\n/*\n * For ext4 extent files, ext4 will do direct-io write to holes,\n * preallocated extents, and those write extend the file, no need to\n * fall back to buffered IO.\n *\n * For holes, we fallocate those blocks, mark them as unwritten\n * If those blocks were preallocated, we mark sure they are split, but\n * still keep the range to write as unwritten.\n *\n * The unwritten extents will be converted to written when DIO is completed.\n * For async direct IO, since the IO may still pending when return, we\n * set up an end_io call back function, which will do the conversion\n * when async direct IO completed.\n *\n * If the O_DIRECT write will extend the file then add this inode to the\n * orphan list.  So recovery will truncate it back to the original size\n * if the machine crashes during the write.\n *\n */\nstatic ssize_t ext4_ext_direct_IO(struct kiocb *iocb, struct iov_iter *iter,\n\t\t\t\t  loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tssize_t ret;\n\tsize_t count = iov_iter_count(iter);\n\tint overwrite = 0;\n\tget_block_t *get_block_func = NULL;\n\tint dio_flags = 0;\n\tloff_t final_size = offset + count;\n\n\t/* Use the old path for reads and writes beyond i_size. */\n\tif (iov_iter_rw(iter) != WRITE || final_size > inode->i_size)\n\t\treturn ext4_ind_direct_IO(iocb, iter, offset);\n\n\tBUG_ON(iocb->private == NULL);\n\n\t/*\n\t * Make all waiters for direct IO properly wait also for extent\n\t * conversion. This also disallows race between truncate() and\n\t * overwrite DIO as i_dio_count needs to be incremented under i_mutex.\n\t */\n\tif (iov_iter_rw(iter) == WRITE)\n\t\tinode_dio_begin(inode);\n\n\t/* If we do a overwrite dio, i_mutex locking can be released */\n\toverwrite = *((int *)iocb->private);\n\n\tif (overwrite)\n\t\tinode_unlock(inode);\n\n\t/*\n\t * We could direct write to holes and fallocate.\n\t *\n\t * Allocated blocks to fill the hole are marked as unwritten to prevent\n\t * parallel buffered read to expose the stale data before DIO complete\n\t * the data IO.\n\t *\n\t * As to previously fallocated extents, ext4 get_block will just simply\n\t * mark the buffer mapped but still keep the extents unwritten.\n\t *\n\t * For non AIO case, we will convert those unwritten extents to written\n\t * after return back from blockdev_direct_IO. That way we save us from\n\t * allocating io_end structure and also the overhead of offloading\n\t * the extent convertion to a workqueue.\n\t *\n\t * For async DIO, the conversion needs to be deferred when the\n\t * IO is completed. The ext4 end_io callback function will be\n\t * called to take care of the conversion work.  Here for async\n\t * case, we allocate an io_end structure to hook to the iocb.\n\t */\n\tiocb->private = NULL;\n\tif (overwrite)\n\t\tget_block_func = ext4_dio_get_block_overwrite;\n\telse if (is_sync_kiocb(iocb)) {\n\t\tget_block_func = ext4_dio_get_block_unwritten_sync;\n\t\tdio_flags = DIO_LOCKING;\n\t} else {\n\t\tget_block_func = ext4_dio_get_block_unwritten_async;\n\t\tdio_flags = DIO_LOCKING;\n\t}\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tBUG_ON(ext4_encrypted_inode(inode) && S_ISREG(inode->i_mode));\n#endif\n\tif (IS_DAX(inode))\n\t\tret = dax_do_io(iocb, inode, iter, offset, get_block_func,\n\t\t\t\text4_end_io_dio, dio_flags);\n\telse\n\t\tret = __blockdev_direct_IO(iocb, inode,\n\t\t\t\t\t   inode->i_sb->s_bdev, iter, offset,\n\t\t\t\t\t   get_block_func,\n\t\t\t\t\t   ext4_end_io_dio, NULL, dio_flags);\n\n\tif (ret > 0 && !overwrite && ext4_test_inode_state(inode,\n\t\t\t\t\t\tEXT4_STATE_DIO_UNWRITTEN)) {\n\t\tint err;\n\t\t/*\n\t\t * for non AIO case, since the IO is already\n\t\t * completed, we could do the conversion right here\n\t\t */\n\t\terr = ext4_convert_unwritten_extents(NULL, inode,\n\t\t\t\t\t\t     offset, ret);\n\t\tif (err < 0)\n\t\t\tret = err;\n\t\text4_clear_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);\n\t}\n\n\tif (iov_iter_rw(iter) == WRITE)\n\t\tinode_dio_end(inode);\n\t/* take i_mutex locking again if we do a ovewrite dio */\n\tif (overwrite)\n\t\tinode_lock(inode);\n\n\treturn ret;\n}\n\nstatic ssize_t ext4_direct_IO(struct kiocb *iocb, struct iov_iter *iter,\n\t\t\t      loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tif (ext4_encrypted_inode(inode) && S_ISREG(inode->i_mode))\n\t\treturn 0;\n#endif\n\n\t/*\n\t * If we are doing data journalling we don't support O_DIRECT\n\t */\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\n\t/* Let buffer I/O handle the inline data case. */\n\tif (ext4_has_inline_data(inode))\n\t\treturn 0;\n\n\ttrace_ext4_direct_IO_enter(inode, offset, count, iov_iter_rw(iter));\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tret = ext4_ext_direct_IO(iocb, iter, offset);\n\telse\n\t\tret = ext4_ind_direct_IO(iocb, iter, offset);\n\ttrace_ext4_direct_IO_exit(inode, offset, count, iov_iter_rw(iter), ret);\n\treturn ret;\n}\n\n/*\n * Pages can be marked dirty completely asynchronously from ext4's journalling\n * activity.  By filemap_sync_pte(), try_to_unmap_one(), etc.  We cannot do\n * much here because ->set_page_dirty is called under VFS locks.  The page is\n * not necessarily locked.\n *\n * We cannot just dirty the page and leave attached buffers clean, because the\n * buffers' dirty state is \"definitive\".  We cannot just set the buffers dirty\n * or jbddirty because all the journalling code will explode.\n *\n * So what we do is to mark the page \"pending dirty\" and next time writepage\n * is called, propagate that into the buffers appropriately.\n */\nstatic int ext4_journalled_set_page_dirty(struct page *page)\n{\n\tSetPageChecked(page);\n\treturn __set_page_dirty_nobuffers(page);\n}\n\nstatic const struct address_space_operations ext4_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\n\nstatic const struct address_space_operations ext4_journalled_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_journalled_write_end,\n\t.set_page_dirty\t\t= ext4_journalled_set_page_dirty,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_journalled_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\n\nstatic const struct address_space_operations ext4_da_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_da_write_begin,\n\t.write_end\t\t= ext4_da_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_da_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\n\nvoid ext4_set_aops(struct inode *inode)\n{\n\tswitch (ext4_inode_journal_mode(inode)) {\n\tcase EXT4_INODE_ORDERED_DATA_MODE:\n\t\text4_set_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_WRITEBACK_DATA_MODE:\n\t\text4_clear_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_JOURNAL_DATA_MODE:\n\t\tinode->i_mapping->a_ops = &ext4_journalled_aops;\n\t\treturn;\n\tdefault:\n\t\tBUG();\n\t}\n\tif (test_opt(inode->i_sb, DELALLOC))\n\t\tinode->i_mapping->a_ops = &ext4_da_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext4_aops;\n}\n\nstatic int __ext4_block_zero_page_range(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from, loff_t length)\n{\n\text4_fsblk_t index = from >> PAGE_SHIFT;\n\tunsigned offset = from & (PAGE_SIZE-1);\n\tunsigned blocksize, pos;\n\text4_lblk_t iblock;\n\tstruct inode *inode = mapping->host;\n\tstruct buffer_head *bh;\n\tstruct page *page;\n\tint err = 0;\n\n\tpage = find_or_create_page(mapping, from >> PAGE_SHIFT,\n\t\t\t\t   mapping_gfp_constraint(mapping, ~__GFP_FS));\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\n\tiblock = index << (PAGE_SHIFT - inode->i_sb->s_blocksize_bits);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\tif (buffer_freed(bh)) {\n\t\tBUFFER_TRACE(bh, \"freed: skip\");\n\t\tgoto unlock;\n\t}\n\tif (!buffer_mapped(bh)) {\n\t\tBUFFER_TRACE(bh, \"unmapped\");\n\t\text4_get_block(inode, iblock, bh, 0);\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tBUFFER_TRACE(bh, \"still unmapped\");\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\terr = -EIO;\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t\tif (S_ISREG(inode->i_mode) &&\n\t\t    ext4_encrypted_inode(inode)) {\n\t\t\t/* We expect the key to be set. */\n\t\t\tBUG_ON(!ext4_has_encryption_key(inode));\n\t\t\tBUG_ON(blocksize != PAGE_SIZE);\n\t\t\tWARN_ON_ONCE(ext4_decrypt(page));\n\t\t}\n\t}\n\tif (ext4_should_journal_data(inode)) {\n\t\tBUFFER_TRACE(bh, \"get write access\");\n\t\terr = ext4_journal_get_write_access(handle, bh);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\tzero_user(page, offset, length);\n\tBUFFER_TRACE(bh, \"zeroed end of block\");\n\n\tif (ext4_should_journal_data(inode)) {\n\t\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\t} else {\n\t\terr = 0;\n\t\tmark_buffer_dirty(bh);\n\t\tif (ext4_test_inode_state(inode, EXT4_STATE_ORDERED_MODE))\n\t\t\terr = ext4_jbd2_file_inode(handle, inode);\n\t}\n\nunlock:\n\tunlock_page(page);\n\tput_page(page);\n\treturn err;\n}\n\n/*\n * ext4_block_zero_page_range() zeros out a mapping of length 'length'\n * starting from file offset 'from'.  The range to be zero'd must\n * be contained with in one block.  If the specified range exceeds\n * the end of the block it will be shortened to end of the block\n * that cooresponds to 'from'\n */\nstatic int ext4_block_zero_page_range(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from, loff_t length)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned offset = from & (PAGE_SIZE-1);\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\tunsigned max = blocksize - (offset & (blocksize - 1));\n\n\t/*\n\t * correct length if it does not fall between\n\t * 'from' and the end of the block\n\t */\n\tif (length > max || length < 0)\n\t\tlength = max;\n\n\tif (IS_DAX(inode))\n\t\treturn dax_zero_page_range(inode, from, length, ext4_get_block);\n\treturn __ext4_block_zero_page_range(handle, mapping, from, length);\n}\n\n/*\n * ext4_block_truncate_page() zeroes out a mapping from file offset `from'\n * up to the end of the block which corresponds to `from'.\n * This required during truncate. We need to physically zero the tail end\n * of that block so it doesn't yield old data if the file is later grown.\n */\nstatic int ext4_block_truncate_page(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from)\n{\n\tunsigned offset = from & (PAGE_SIZE-1);\n\tunsigned length;\n\tunsigned blocksize;\n\tstruct inode *inode = mapping->host;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tlength = blocksize - (offset & (blocksize - 1));\n\n\treturn ext4_block_zero_page_range(handle, mapping, from, length);\n}\n\nint ext4_zero_partial_blocks(handle_t *handle, struct inode *inode,\n\t\t\t     loff_t lstart, loff_t length)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned partial_start, partial_end;\n\text4_fsblk_t start, end;\n\tloff_t byte_end = (lstart + length - 1);\n\tint err = 0;\n\n\tpartial_start = lstart & (sb->s_blocksize - 1);\n\tpartial_end = byte_end & (sb->s_blocksize - 1);\n\n\tstart = lstart >> sb->s_blocksize_bits;\n\tend = byte_end >> sb->s_blocksize_bits;\n\n\t/* Handle partial zero within the single block */\n\tif (start == end &&\n\t    (partial_start || (partial_end != sb->s_blocksize - 1))) {\n\t\terr = ext4_block_zero_page_range(handle, mapping,\n\t\t\t\t\t\t lstart, length);\n\t\treturn err;\n\t}\n\t/* Handle partial zero out on the start of the range */\n\tif (partial_start) {\n\t\terr = ext4_block_zero_page_range(handle, mapping,\n\t\t\t\t\t\t lstart, sb->s_blocksize);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\t/* Handle partial zero out on the end of the range */\n\tif (partial_end != sb->s_blocksize - 1)\n\t\terr = ext4_block_zero_page_range(handle, mapping,\n\t\t\t\t\t\t byte_end - partial_end,\n\t\t\t\t\t\t partial_end + 1);\n\treturn err;\n}\n\nint ext4_can_truncate(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn !ext4_inode_is_fast_symlink(inode);\n\treturn 0;\n}\n\n/*\n * We have to make sure i_disksize gets properly updated before we truncate\n * page cache due to hole punching or zero range. Otherwise i_disksize update\n * can get lost as it may have been postponed to submission of writeback but\n * that will never happen after we truncate page cache.\n */\nint ext4_update_disksize_before_punch(struct inode *inode, loff_t offset,\n\t\t\t\t      loff_t len)\n{\n\thandle_t *handle;\n\tloff_t size = i_size_read(inode);\n\n\tWARN_ON(!inode_is_locked(inode));\n\tif (offset > size || offset + len < size)\n\t\treturn 0;\n\n\tif (EXT4_I(inode)->i_disksize >= size)\n\t\treturn 0;\n\n\thandle = ext4_journal_start(inode, EXT4_HT_MISC, 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\text4_update_i_disksize(inode, size);\n\text4_mark_inode_dirty(handle, inode);\n\text4_journal_stop(handle);\n\n\treturn 0;\n}\n\n/*\n * ext4_punch_hole: punches a hole in a file by releaseing the blocks\n * associated with the given offset and length\n *\n * @inode:  File inode\n * @offset: The offset where the hole will begin\n * @len:    The length of the hole\n *\n * Returns: 0 on success or negative on failure\n */\n\nint ext4_punch_hole(struct inode *inode, loff_t offset, loff_t length)\n{\n\tstruct super_block *sb = inode->i_sb;\n\text4_lblk_t first_block, stop_block;\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t first_block_offset, last_block_offset;\n\thandle_t *handle;\n\tunsigned int credits;\n\tint ret = 0;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\ttrace_ext4_punch_hole(inode, offset, length, 0);\n\n\t/*\n\t * Write out all dirty pages to avoid race conditions\n\t * Then release them.\n\t */\n\tif (mapping->nrpages && mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {\n\t\tret = filemap_write_and_wait_range(mapping, offset,\n\t\t\t\t\t\t   offset + length - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tinode_lock(inode);\n\n\t/* No need to punch hole beyond i_size */\n\tif (offset >= inode->i_size)\n\t\tgoto out_mutex;\n\n\t/*\n\t * If the hole extends beyond i_size, set the hole\n\t * to end after the page that contains i_size\n\t */\n\tif (offset + length > inode->i_size) {\n\t\tlength = inode->i_size +\n\t\t   PAGE_SIZE - (inode->i_size & (PAGE_SIZE - 1)) -\n\t\t   offset;\n\t}\n\n\tif (offset & (sb->s_blocksize - 1) ||\n\t    (offset + length) & (sb->s_blocksize - 1)) {\n\t\t/*\n\t\t * Attach jinode to inode for jbd2 if we do any zeroing of\n\t\t * partial block\n\t\t */\n\t\tret = ext4_inode_attach_jinode(inode);\n\t\tif (ret < 0)\n\t\t\tgoto out_mutex;\n\n\t}\n\n\t/* Wait all existing dio workers, newcomers will block on i_mutex */\n\text4_inode_block_unlocked_dio(inode);\n\tinode_dio_wait(inode);\n\n\t/*\n\t * Prevent page faults from reinstantiating pages we have released from\n\t * page cache.\n\t */\n\tdown_write(&EXT4_I(inode)->i_mmap_sem);\n\tfirst_block_offset = round_up(offset, sb->s_blocksize);\n\tlast_block_offset = round_down((offset + length), sb->s_blocksize) - 1;\n\n\t/* Now release the pages and zero block aligned part of pages*/\n\tif (last_block_offset > first_block_offset) {\n\t\tret = ext4_update_disksize_before_punch(inode, offset, length);\n\t\tif (ret)\n\t\t\tgoto out_dio;\n\t\ttruncate_pagecache_range(inode, first_block_offset,\n\t\t\t\t\t last_block_offset);\n\t}\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tcredits = ext4_writepage_trans_blocks(inode);\n\telse\n\t\tcredits = ext4_blocks_for_truncate(inode);\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\text4_std_error(sb, ret);\n\t\tgoto out_dio;\n\t}\n\n\tret = ext4_zero_partial_blocks(handle, inode, offset,\n\t\t\t\t       length);\n\tif (ret)\n\t\tgoto out_stop;\n\n\tfirst_block = (offset + sb->s_blocksize - 1) >>\n\t\tEXT4_BLOCK_SIZE_BITS(sb);\n\tstop_block = (offset + length) >> EXT4_BLOCK_SIZE_BITS(sb);\n\n\t/* If there are no blocks to remove, return now */\n\tif (first_block >= stop_block)\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\tret = ext4_es_remove_extent(inode, first_block,\n\t\t\t\t    stop_block - first_block);\n\tif (ret) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tret = ext4_ext_remove_space(inode, first_block,\n\t\t\t\t\t    stop_block - 1);\n\telse\n\t\tret = ext4_ind_remove_space(handle, inode, first_block,\n\t\t\t\t\t    stop_block);\n\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\nout_stop:\n\text4_journal_stop(handle);\nout_dio:\n\tup_write(&EXT4_I(inode)->i_mmap_sem);\n\text4_inode_resume_unlocked_dio(inode);\nout_mutex:\n\tinode_unlock(inode);\n\treturn ret;\n}\n\nint ext4_inode_attach_jinode(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct jbd2_inode *jinode;\n\n\tif (ei->jinode || !EXT4_SB(inode->i_sb)->s_journal)\n\t\treturn 0;\n\n\tjinode = jbd2_alloc_inode(GFP_KERNEL);\n\tspin_lock(&inode->i_lock);\n\tif (!ei->jinode) {\n\t\tif (!jinode) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tei->jinode = jinode;\n\t\tjbd2_journal_init_jbd_inode(ei->jinode, inode);\n\t\tjinode = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\tif (unlikely(jinode != NULL))\n\t\tjbd2_free_inode(jinode);\n\treturn 0;\n}\n\n/*\n * ext4_truncate()\n *\n * We block out ext4_get_block() block instantiations across the entire\n * transaction, and VFS/VM ensures that ext4_truncate() cannot run\n * simultaneously on behalf of the same inode.\n *\n * As we work through the truncate and commit bits of it to the journal there\n * is one core, guiding principle: the file's tree must always be consistent on\n * disk.  We must be able to restart the truncate after a crash.\n *\n * The file's tree may be transiently inconsistent in memory (although it\n * probably isn't), but whenever we close off and commit a journal transaction,\n * the contents of (the filesystem + the journal) must be consistent and\n * restartable.  It's pretty simple, really: bottom up, right to left (although\n * left-to-right works OK too).\n *\n * Note that at recovery time, journal replay occurs *before* the restart of\n * truncate against the orphan inode list.\n *\n * The committed inode has the new, desired i_size (which is the same as\n * i_disksize in this case).  After a crash, ext4_orphan_cleanup() will see\n * that this inode's truncate did not complete and it will again call\n * ext4_truncate() to have another go.  So there will be instantiated blocks\n * to the right of the truncation point in a crashed ext4 filesystem.  But\n * that's fine - as long as they are linked from the inode, the post-crash\n * ext4_truncate() run will find them and release them.\n */\nvoid ext4_truncate(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tunsigned int credits;\n\thandle_t *handle;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\t/*\n\t * There is a possibility that we're either freeing the inode\n\t * or it's a completely new inode. In those cases we might not\n\t * have i_mutex locked because it's not necessary.\n\t */\n\tif (!(inode->i_state & (I_NEW|I_FREEING)))\n\t\tWARN_ON(!inode_is_locked(inode));\n\ttrace_ext4_truncate_enter(inode);\n\n\tif (!ext4_can_truncate(inode))\n\t\treturn;\n\n\text4_clear_inode_flag(inode, EXT4_INODE_EOFBLOCKS);\n\n\tif (inode->i_size == 0 && !test_opt(inode->i_sb, NO_AUTO_DA_ALLOC))\n\t\text4_set_inode_state(inode, EXT4_STATE_DA_ALLOC_CLOSE);\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tint has_inline = 1;\n\n\t\text4_inline_data_truncate(inode, &has_inline);\n\t\tif (has_inline)\n\t\t\treturn;\n\t}\n\n\t/* If we zero-out tail of the page, we have to create jinode for jbd2 */\n\tif (inode->i_size & (inode->i_sb->s_blocksize - 1)) {\n\t\tif (ext4_inode_attach_jinode(inode) < 0)\n\t\t\treturn;\n\t}\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tcredits = ext4_writepage_trans_blocks(inode);\n\telse\n\t\tcredits = ext4_blocks_for_truncate(inode);\n\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\text4_std_error(inode->i_sb, PTR_ERR(handle));\n\t\treturn;\n\t}\n\n\tif (inode->i_size & (inode->i_sb->s_blocksize - 1))\n\t\text4_block_truncate_page(handle, mapping, inode->i_size);\n\n\t/*\n\t * We add the inode to the orphan list, so that if this\n\t * truncate spans multiple transactions, and we crash, we will\n\t * resume the truncate when the filesystem recovers.  It also\n\t * marks the inode dirty, to catch the new size.\n\t *\n\t * Implication: the file must always be in a sane, consistent\n\t * truncatable state while each transaction commits.\n\t */\n\tif (ext4_orphan_add(handle, inode))\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\text4_discard_preallocations(inode);\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\text4_ext_truncate(handle, inode);\n\telse\n\t\text4_ind_truncate(handle, inode);\n\n\tup_write(&ei->i_data_sem);\n\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\nout_stop:\n\t/*\n\t * If this was a simple ftruncate() and the file will remain alive,\n\t * then we need to clear up the orphan record which we created above.\n\t * However, if this was a real unlink then we were called by\n\t * ext4_evict_inode(), and we allow that function to clean up the\n\t * orphan info for us.\n\t */\n\tif (inode->i_nlink)\n\t\text4_orphan_del(handle, inode);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\text4_journal_stop(handle);\n\n\ttrace_ext4_truncate_exit(inode);\n}\n\n/*\n * ext4_get_inode_loc returns with an extra refcount against the inode's\n * underlying buffer_head on success. If 'in_mem' is true, we have all\n * data in memory that is needed to recreate the on-disk version of this\n * inode.\n */\nstatic int __ext4_get_inode_loc(struct inode *inode,\n\t\t\t\tstruct ext4_iloc *iloc, int in_mem)\n{\n\tstruct ext4_group_desc\t*gdp;\n\tstruct buffer_head\t*bh;\n\tstruct super_block\t*sb = inode->i_sb;\n\text4_fsblk_t\t\tblock;\n\tint\t\t\tinodes_per_block, inode_offset;\n\n\tiloc->bh = NULL;\n\tif (!ext4_valid_inum(sb, inode->i_ino))\n\t\treturn -EFSCORRUPTED;\n\n\tiloc->block_group = (inode->i_ino - 1) / EXT4_INODES_PER_GROUP(sb);\n\tgdp = ext4_get_group_desc(sb, iloc->block_group, NULL);\n\tif (!gdp)\n\t\treturn -EIO;\n\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\tinodes_per_block = EXT4_SB(sb)->s_inodes_per_block;\n\tinode_offset = ((inode->i_ino - 1) %\n\t\t\tEXT4_INODES_PER_GROUP(sb));\n\tblock = ext4_inode_table(sb, gdp) + (inode_offset / inodes_per_block);\n\tiloc->offset = (inode_offset % inodes_per_block) * EXT4_INODE_SIZE(sb);\n\n\tbh = sb_getblk(sb, block);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\tif (!buffer_uptodate(bh)) {\n\t\tlock_buffer(bh);\n\n\t\t/*\n\t\t * If the buffer has the write error flag, we have failed\n\t\t * to write out another inode in the same block.  In this\n\t\t * case, we don't have to read the block because we may\n\t\t * read the old inode data successfully.\n\t\t */\n\t\tif (buffer_write_io_error(bh) && !buffer_uptodate(bh))\n\t\t\tset_buffer_uptodate(bh);\n\n\t\tif (buffer_uptodate(bh)) {\n\t\t\t/* someone brought it uptodate while we waited */\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto has_buffer;\n\t\t}\n\n\t\t/*\n\t\t * If we have all information of the inode in memory and this\n\t\t * is the only valid inode in the block, we need not read the\n\t\t * block.\n\t\t */\n\t\tif (in_mem) {\n\t\t\tstruct buffer_head *bitmap_bh;\n\t\t\tint i, start;\n\n\t\t\tstart = inode_offset & ~(inodes_per_block - 1);\n\n\t\t\t/* Is the inode bitmap in cache? */\n\t\t\tbitmap_bh = sb_getblk(sb, ext4_inode_bitmap(sb, gdp));\n\t\t\tif (unlikely(!bitmap_bh))\n\t\t\t\tgoto make_io;\n\n\t\t\t/*\n\t\t\t * If the inode bitmap isn't in cache then the\n\t\t\t * optimisation may end up performing two reads instead\n\t\t\t * of one, so skip it.\n\t\t\t */\n\t\t\tif (!buffer_uptodate(bitmap_bh)) {\n\t\t\t\tbrelse(bitmap_bh);\n\t\t\t\tgoto make_io;\n\t\t\t}\n\t\t\tfor (i = start; i < start + inodes_per_block; i++) {\n\t\t\t\tif (i == inode_offset)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ext4_test_bit(i, bitmap_bh->b_data))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbrelse(bitmap_bh);\n\t\t\tif (i == start + inodes_per_block) {\n\t\t\t\t/* all other inodes are free, so skip I/O */\n\t\t\t\tmemset(bh->b_data, 0, bh->b_size);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tgoto has_buffer;\n\t\t\t}\n\t\t}\n\nmake_io:\n\t\t/*\n\t\t * If we need to do any I/O, try to pre-readahead extra\n\t\t * blocks from the inode table.\n\t\t */\n\t\tif (EXT4_SB(sb)->s_inode_readahead_blks) {\n\t\t\text4_fsblk_t b, end, table;\n\t\t\tunsigned num;\n\t\t\t__u32 ra_blks = EXT4_SB(sb)->s_inode_readahead_blks;\n\n\t\t\ttable = ext4_inode_table(sb, gdp);\n\t\t\t/* s_inode_readahead_blks is always a power of 2 */\n\t\t\tb = block & ~((ext4_fsblk_t) ra_blks - 1);\n\t\t\tif (table > b)\n\t\t\t\tb = table;\n\t\t\tend = b + ra_blks;\n\t\t\tnum = EXT4_INODES_PER_GROUP(sb);\n\t\t\tif (ext4_has_group_desc_csum(sb))\n\t\t\t\tnum -= ext4_itable_unused_count(sb, gdp);\n\t\t\ttable += num / inodes_per_block;\n\t\t\tif (end > table)\n\t\t\t\tend = table;\n\t\t\twhile (b <= end)\n\t\t\t\tsb_breadahead(sb, b++);\n\t\t}\n\n\t\t/*\n\t\t * There are other valid inodes in the buffer, this inode\n\t\t * has in-inode xattrs, or we don't have this inode in memory.\n\t\t * Read the block from disk.\n\t\t */\n\t\ttrace_ext4_load_inode(inode);\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tEXT4_ERROR_INODE_BLOCK(inode, block,\n\t\t\t\t\t       \"unable to read itable block\");\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t}\nhas_buffer:\n\tiloc->bh = bh;\n\treturn 0;\n}\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}\n\nvoid ext4_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = EXT4_I(inode)->i_flags;\n\tunsigned int new_fl = 0;\n\n\tif (flags & EXT4_SYNC_FL)\n\t\tnew_fl |= S_SYNC;\n\tif (flags & EXT4_APPEND_FL)\n\t\tnew_fl |= S_APPEND;\n\tif (flags & EXT4_IMMUTABLE_FL)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (flags & EXT4_NOATIME_FL)\n\t\tnew_fl |= S_NOATIME;\n\tif (flags & EXT4_DIRSYNC_FL)\n\t\tnew_fl |= S_DIRSYNC;\n\tif (test_opt(inode->i_sb, DAX) && S_ISREG(inode->i_mode))\n\t\tnew_fl |= S_DAX;\n\tinode_set_flags(inode, new_fl,\n\t\t\tS_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC|S_DAX);\n}\n\n/* Propagate flags from i_flags to EXT4_I(inode)->i_flags */\nvoid ext4_get_inode_flags(struct ext4_inode_info *ei)\n{\n\tunsigned int vfs_fl;\n\tunsigned long old_fl, new_fl;\n\n\tdo {\n\t\tvfs_fl = ei->vfs_inode.i_flags;\n\t\told_fl = ei->i_flags;\n\t\tnew_fl = old_fl & ~(EXT4_SYNC_FL|EXT4_APPEND_FL|\n\t\t\t\tEXT4_IMMUTABLE_FL|EXT4_NOATIME_FL|\n\t\t\t\tEXT4_DIRSYNC_FL);\n\t\tif (vfs_fl & S_SYNC)\n\t\t\tnew_fl |= EXT4_SYNC_FL;\n\t\tif (vfs_fl & S_APPEND)\n\t\t\tnew_fl |= EXT4_APPEND_FL;\n\t\tif (vfs_fl & S_IMMUTABLE)\n\t\t\tnew_fl |= EXT4_IMMUTABLE_FL;\n\t\tif (vfs_fl & S_NOATIME)\n\t\t\tnew_fl |= EXT4_NOATIME_FL;\n\t\tif (vfs_fl & S_DIRSYNC)\n\t\t\tnew_fl |= EXT4_DIRSYNC_FL;\n\t} while (cmpxchg(&ei->i_flags, old_fl, new_fl) != old_fl);\n}\n\nstatic blkcnt_t ext4_inode_blocks(struct ext4_inode *raw_inode,\n\t\t\t\t  struct ext4_inode_info *ei)\n{\n\tblkcnt_t i_blocks ;\n\tstruct inode *inode = &(ei->vfs_inode);\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (ext4_has_feature_huge_file(sb)) {\n\t\t/* we are using combined 48 bit field */\n\t\ti_blocks = ((u64)le16_to_cpu(raw_inode->i_blocks_high)) << 32 |\n\t\t\t\t\tle32_to_cpu(raw_inode->i_blocks_lo);\n\t\tif (ext4_test_inode_flag(inode, EXT4_INODE_HUGE_FILE)) {\n\t\t\t/* i_blocks represent file system block size */\n\t\t\treturn i_blocks  << (inode->i_blkbits - 9);\n\t\t} else {\n\t\t\treturn i_blocks;\n\t\t}\n\t} else {\n\t\treturn le32_to_cpu(raw_inode->i_blocks_lo);\n\t}\n}\n\nstatic inline void ext4_iget_extra_inode(struct inode *inode,\n\t\t\t\t\t struct ext4_inode *raw_inode,\n\t\t\t\t\t struct ext4_inode_info *ei)\n{\n\t__le32 *magic = (void *)raw_inode +\n\t\t\tEXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize;\n\tif (*magic == cpu_to_le32(EXT4_XATTR_MAGIC)) {\n\t\text4_set_inode_state(inode, EXT4_STATE_XATTR);\n\t\text4_find_inline_data_nolock(inode);\n\t} else\n\t\tEXT4_I(inode)->i_inline_off = 0;\n}\n\nint ext4_get_projid(struct inode *inode, kprojid_t *projid)\n{\n\tif (!EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb, EXT4_FEATURE_RO_COMPAT_PROJECT))\n\t\treturn -EOPNOTSUPP;\n\t*projid = EXT4_I(inode)->i_projid;\n\treturn 0;\n}\n\nstruct inode *ext4_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_inode_info *ei;\n\tstruct inode *inode;\n\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\tlong ret;\n\tint block;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\tprojid_t i_projid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT4_I(inode);\n\tiloc.bh = NULL;\n\n\tret = __ext4_get_inode_loc(inode, &iloc, 0);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\traw_inode = ext4_raw_inode(&iloc);\n\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);\n\t\tif (EXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize >\n\t\t    EXT4_INODE_SIZE(inode->i_sb)) {\n\t\t\tEXT4_ERROR_INODE(inode, \"bad extra_isize (%u != %u)\",\n\t\t\t\tEXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize,\n\t\t\t\tEXT4_INODE_SIZE(inode->i_sb));\n\t\t\tret = -EFSCORRUPTED;\n\t\t\tgoto bad_inode;\n\t\t}\n\t} else\n\t\tei->i_extra_isize = 0;\n\n\t/* Precompute checksum seed for inode metadata */\n\tif (ext4_has_metadata_csum(sb)) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t\t__u32 csum;\n\t\t__le32 inum = cpu_to_le32(inode->i_ino);\n\t\t__le32 gen = raw_inode->i_generation;\n\t\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)&inum,\n\t\t\t\t   sizeof(inum));\n\t\tei->i_csum_seed = ext4_chksum(sbi, csum, (__u8 *)&gen,\n\t\t\t\t\t      sizeof(gen));\n\t}\n\n\tif (!ext4_inode_csum_verify(inode, raw_inode, ei)) {\n\t\tEXT4_ERROR_INODE(inode, \"checksum invalid\");\n\t\tret = -EFSBADCRC;\n\t\tgoto bad_inode;\n\t}\n\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_PROJECT) &&\n\t    EXT4_INODE_SIZE(sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw_inode, ei, i_projid))\n\t\ti_projid = (projid_t)le32_to_cpu(raw_inode->i_projid);\n\telse\n\t\ti_projid = EXT4_DEF_PROJID;\n\n\tif (!(test_opt(inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tei->i_projid = make_kprojid(&init_user_ns, i_projid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\n\text4_clear_state_flags(ei);\t/* Only relevant on 32-bit archs */\n\tei->i_inline_off = 0;\n\tei->i_dir_start_lookup = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0) {\n\t\tif ((inode->i_mode == 0 ||\n\t\t     !(EXT4_SB(inode->i_sb)->s_mount_state & EXT4_ORPHAN_FS)) &&\n\t\t    ino != EXT4_BOOT_LOADER_INO) {\n\t\t\t/* this inode is deleted */\n\t\t\tret = -ESTALE;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\t/* The only unlinked inodes we let through here have\n\t\t * valid i_mode and are being read by the orphan\n\t\t * recovery code: that's fine, we're about to complete\n\t\t * the process of deleting those.\n\t\t * OR it is the EXT4_BOOT_LOADER_INO which is\n\t\t * not initialized on a new filesystem. */\n\t}\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n\tinode->i_blocks = ext4_inode_blocks(raw_inode, ei);\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl_lo);\n\tif (ext4_has_feature_64bit(sb))\n\t\tei->i_file_acl |=\n\t\t\t((__u64)le16_to_cpu(raw_inode->i_file_acl_high)) << 32;\n\tinode->i_size = ext4_isize(raw_inode);\n\tei->i_disksize = inode->i_size;\n#ifdef CONFIG_QUOTA\n\tei->i_reserved_quota = 0;\n#endif\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_block_group = iloc.block_group;\n\tei->i_last_alloc_group = ~0;\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (block = 0; block < EXT4_N_BLOCKS; block++)\n\t\tei->i_data[block] = raw_inode->i_block[block];\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttransaction_t *transaction;\n\t\ttid_t tid;\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tread_unlock(&journal->j_state_lock);\n\t\tei->i_sync_tid = tid;\n\t\tei->i_datasync_tid = tid;\n\t}\n\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tif (ei->i_extra_isize == 0) {\n\t\t\t/* The extra space is currently unused. Use it. */\n\t\t\tei->i_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t    EXT4_GOOD_OLD_INODE_SIZE;\n\t\t} else {\n\t\t\text4_iget_extra_inode(inode, raw_inode, ei);\n\t\t}\n\t}\n\n\tEXT4_INODE_GET_XTIME(i_ctime, inode, raw_inode);\n\tEXT4_INODE_GET_XTIME(i_mtime, inode, raw_inode);\n\tEXT4_INODE_GET_XTIME(i_atime, inode, raw_inode);\n\tEXT4_EINODE_GET_XTIME(i_crtime, ei, raw_inode);\n\n\tif (likely(!test_opt2(inode->i_sb, HURD_COMPAT))) {\n\t\tinode->i_version = le32_to_cpu(raw_inode->i_disk_version);\n\t\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\t\tif (EXT4_FITS_IN_INODE(raw_inode, ei, i_version_hi))\n\t\t\t\tinode->i_version |=\n\t\t    (__u64)(le32_to_cpu(raw_inode->i_version_hi)) << 32;\n\t\t}\n\t}\n\n\tret = 0;\n\tif (ei->i_file_acl &&\n\t    !ext4_data_block_valid(EXT4_SB(sb), ei->i_file_acl, 1)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad extended attribute block %llu\",\n\t\t\t\t ei->i_file_acl);\n\t\tret = -EFSCORRUPTED;\n\t\tgoto bad_inode;\n\t} else if (!ext4_has_inline_data(inode)) {\n\t\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\t\tif ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t    (S_ISLNK(inode->i_mode) &&\n\t\t\t     !ext4_inode_is_fast_symlink(inode))))\n\t\t\t\t/* Validate extent which is part of inode */\n\t\t\t\tret = ext4_ext_check_inode(inode);\n\t\t} else if (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t   (S_ISLNK(inode->i_mode) &&\n\t\t\t    !ext4_inode_is_fast_symlink(inode))) {\n\t\t\t/* Validate block references which are part of inode */\n\t\t\tret = ext4_ind_check_inode(inode);\n\t\t}\n\t}\n\tif (ret)\n\t\tgoto bad_inode;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext4_file_inode_operations;\n\t\tinode->i_fop = &ext4_file_operations;\n\t\text4_set_aops(inode);\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext4_dir_inode_operations;\n\t\tinode->i_fop = &ext4_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext4_encrypted_inode(inode)) {\n\t\t\tinode->i_op = &ext4_encrypted_symlink_inode_operations;\n\t\t\text4_set_aops(inode);\n\t\t} else if (ext4_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_link = (char *)ei->i_data;\n\t\t\tinode->i_op = &ext4_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext4_symlink_inode_operations;\n\t\t\text4_set_aops(inode);\n\t\t}\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t      S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &ext4_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t} else if (ino == EXT4_BOOT_LOADER_INO) {\n\t\tmake_bad_inode(inode);\n\t} else {\n\t\tret = -EFSCORRUPTED;\n\t\tEXT4_ERROR_INODE(inode, \"bogus i_mode (%o)\", inode->i_mode);\n\t\tgoto bad_inode;\n\t}\n\tbrelse(iloc.bh);\n\text4_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tbrelse(iloc.bh);\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}\n\nstruct inode *ext4_iget_normal(struct super_block *sb, unsigned long ino)\n{\n\tif (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\treturn ext4_iget(sb, ino);\n}\n\nstatic int ext4_inode_blocks_set(handle_t *handle,\n\t\t\t\tstruct ext4_inode *raw_inode,\n\t\t\t\tstruct ext4_inode_info *ei)\n{\n\tstruct inode *inode = &(ei->vfs_inode);\n\tu64 i_blocks = inode->i_blocks;\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (i_blocks <= ~0U) {\n\t\t/*\n\t\t * i_blocks can be represented in a 32 bit variable\n\t\t * as multiple of 512 bytes\n\t\t */\n\t\traw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);\n\t\traw_inode->i_blocks_high = 0;\n\t\text4_clear_inode_flag(inode, EXT4_INODE_HUGE_FILE);\n\t\treturn 0;\n\t}\n\tif (!ext4_has_feature_huge_file(sb))\n\t\treturn -EFBIG;\n\n\tif (i_blocks <= 0xffffffffffffULL) {\n\t\t/*\n\t\t * i_blocks can be represented in a 48 bit variable\n\t\t * as multiple of 512 bytes\n\t\t */\n\t\traw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);\n\t\traw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);\n\t\text4_clear_inode_flag(inode, EXT4_INODE_HUGE_FILE);\n\t} else {\n\t\text4_set_inode_flag(inode, EXT4_INODE_HUGE_FILE);\n\t\t/* i_block is stored in file system block size */\n\t\ti_blocks = i_blocks >> (inode->i_blkbits - 9);\n\t\traw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);\n\t\traw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);\n\t}\n\treturn 0;\n}\n\nstruct other_inode {\n\tunsigned long\t\torig_ino;\n\tstruct ext4_inode\t*raw_inode;\n};\n\nstatic int other_inode_match(struct inode * inode, unsigned long ino,\n\t\t\t     void *data)\n{\n\tstruct other_inode *oi = (struct other_inode *) data;\n\n\tif ((inode->i_ino != ino) ||\n\t    (inode->i_state & (I_FREEING | I_WILL_FREE | I_NEW |\n\t\t\t       I_DIRTY_SYNC | I_DIRTY_DATASYNC)) ||\n\t    ((inode->i_state & I_DIRTY_TIME) == 0))\n\t\treturn 0;\n\tspin_lock(&inode->i_lock);\n\tif (((inode->i_state & (I_FREEING | I_WILL_FREE | I_NEW |\n\t\t\t\tI_DIRTY_SYNC | I_DIRTY_DATASYNC)) == 0) &&\n\t    (inode->i_state & I_DIRTY_TIME)) {\n\t\tstruct ext4_inode_info\t*ei = EXT4_I(inode);\n\n\t\tinode->i_state &= ~(I_DIRTY_TIME | I_DIRTY_TIME_EXPIRED);\n\t\tspin_unlock(&inode->i_lock);\n\n\t\tspin_lock(&ei->i_raw_lock);\n\t\tEXT4_INODE_SET_XTIME(i_ctime, inode, oi->raw_inode);\n\t\tEXT4_INODE_SET_XTIME(i_mtime, inode, oi->raw_inode);\n\t\tEXT4_INODE_SET_XTIME(i_atime, inode, oi->raw_inode);\n\t\text4_inode_csum_set(inode, oi->raw_inode, ei);\n\t\tspin_unlock(&ei->i_raw_lock);\n\t\ttrace_ext4_other_inode_update_time(inode, oi->orig_ino);\n\t\treturn -1;\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn -1;\n}\n\n/*\n * Opportunistically update the other time fields for other inodes in\n * the same inode table block.\n */\nstatic void ext4_update_other_inodes_time(struct super_block *sb,\n\t\t\t\t\t  unsigned long orig_ino, char *buf)\n{\n\tstruct other_inode oi;\n\tunsigned long ino;\n\tint i, inodes_per_block = EXT4_SB(sb)->s_inodes_per_block;\n\tint inode_size = EXT4_INODE_SIZE(sb);\n\n\toi.orig_ino = orig_ino;\n\t/*\n\t * Calculate the first inode in the inode table block.  Inode\n\t * numbers are one-based.  That is, the first inode in a block\n\t * (assuming 4k blocks and 256 byte inodes) is (n*16 + 1).\n\t */\n\tino = ((orig_ino - 1) & ~(inodes_per_block - 1)) + 1;\n\tfor (i = 0; i < inodes_per_block; i++, ino++, buf += inode_size) {\n\t\tif (ino == orig_ino)\n\t\t\tcontinue;\n\t\toi.raw_inode = (struct ext4_inode *) buf;\n\t\t(void) find_inode_nowait(sb, ino, other_inode_match, &oi);\n\t}\n}\n\n/*\n * Post the struct inode info into an on-disk inode location in the\n * buffer-cache.  This gobbles the caller's reference to the\n * buffer_head in the inode location struct.\n *\n * The caller must have write access to iloc->bh.\n */\nstatic int ext4_do_update_inode(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ext4_iloc *iloc)\n{\n\tstruct ext4_inode *raw_inode = ext4_raw_inode(iloc);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct buffer_head *bh = iloc->bh;\n\tstruct super_block *sb = inode->i_sb;\n\tint err = 0, rc, block;\n\tint need_datasync = 0, set_large_file = 0;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\tprojid_t i_projid;\n\n\tspin_lock(&ei->i_raw_lock);\n\n\t/* For fields not tracked in the in-memory inode,\n\t * initialise them to zero for new inodes. */\n\tif (ext4_test_inode_state(inode, EXT4_STATE_NEW))\n\t\tmemset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);\n\n\text4_get_inode_flags(ei);\n\traw_inode->i_mode = cpu_to_le16(inode->i_mode);\n\ti_uid = i_uid_read(inode);\n\ti_gid = i_gid_read(inode);\n\ti_projid = from_kprojid(&init_user_ns, ei->i_projid);\n\tif (!(test_opt(inode->i_sb, NO_UID32))) {\n\t\traw_inode->i_uid_low = cpu_to_le16(low_16_bits(i_uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(low_16_bits(i_gid));\n/*\n * Fix up interoperability with old kernels. Otherwise, old inodes get\n * re-used with the upper 16 bits of the uid/gid intact\n */\n\t\tif (!ei->i_dtime) {\n\t\t\traw_inode->i_uid_high =\n\t\t\t\tcpu_to_le16(high_16_bits(i_uid));\n\t\t\traw_inode->i_gid_high =\n\t\t\t\tcpu_to_le16(high_16_bits(i_gid));\n\t\t} else {\n\t\t\traw_inode->i_uid_high = 0;\n\t\t\traw_inode->i_gid_high = 0;\n\t\t}\n\t} else {\n\t\traw_inode->i_uid_low = cpu_to_le16(fs_high2lowuid(i_uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(fs_high2lowgid(i_gid));\n\t\traw_inode->i_uid_high = 0;\n\t\traw_inode->i_gid_high = 0;\n\t}\n\traw_inode->i_links_count = cpu_to_le16(inode->i_nlink);\n\n\tEXT4_INODE_SET_XTIME(i_ctime, inode, raw_inode);\n\tEXT4_INODE_SET_XTIME(i_mtime, inode, raw_inode);\n\tEXT4_INODE_SET_XTIME(i_atime, inode, raw_inode);\n\tEXT4_EINODE_SET_XTIME(i_crtime, ei, raw_inode);\n\n\terr = ext4_inode_blocks_set(handle, raw_inode, ei);\n\tif (err) {\n\t\tspin_unlock(&ei->i_raw_lock);\n\t\tgoto out_brelse;\n\t}\n\traw_inode->i_dtime = cpu_to_le32(ei->i_dtime);\n\traw_inode->i_flags = cpu_to_le32(ei->i_flags & 0xFFFFFFFF);\n\tif (likely(!test_opt2(inode->i_sb, HURD_COMPAT)))\n\t\traw_inode->i_file_acl_high =\n\t\t\tcpu_to_le16(ei->i_file_acl >> 32);\n\traw_inode->i_file_acl_lo = cpu_to_le32(ei->i_file_acl);\n\tif (ei->i_disksize != ext4_isize(raw_inode)) {\n\t\text4_isize_set(raw_inode, ei->i_disksize);\n\t\tneed_datasync = 1;\n\t}\n\tif (ei->i_disksize > 0x7fffffffULL) {\n\t\tif (!ext4_has_feature_large_file(sb) ||\n\t\t\t\tEXT4_SB(sb)->s_es->s_rev_level ==\n\t\t    cpu_to_le32(EXT4_GOOD_OLD_REV))\n\t\t\tset_large_file = 1;\n\t}\n\traw_inode->i_generation = cpu_to_le32(inode->i_generation);\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (old_valid_dev(inode->i_rdev)) {\n\t\t\traw_inode->i_block[0] =\n\t\t\t\tcpu_to_le32(old_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[1] = 0;\n\t\t} else {\n\t\t\traw_inode->i_block[0] = 0;\n\t\t\traw_inode->i_block[1] =\n\t\t\t\tcpu_to_le32(new_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[2] = 0;\n\t\t}\n\t} else if (!ext4_has_inline_data(inode)) {\n\t\tfor (block = 0; block < EXT4_N_BLOCKS; block++)\n\t\t\traw_inode->i_block[block] = ei->i_data[block];\n\t}\n\n\tif (likely(!test_opt2(inode->i_sb, HURD_COMPAT))) {\n\t\traw_inode->i_disk_version = cpu_to_le32(inode->i_version);\n\t\tif (ei->i_extra_isize) {\n\t\t\tif (EXT4_FITS_IN_INODE(raw_inode, ei, i_version_hi))\n\t\t\t\traw_inode->i_version_hi =\n\t\t\t\t\tcpu_to_le32(inode->i_version >> 32);\n\t\t\traw_inode->i_extra_isize =\n\t\t\t\tcpu_to_le16(ei->i_extra_isize);\n\t\t}\n\t}\n\n\tBUG_ON(!EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_PROJECT) &&\n\t       i_projid != EXT4_DEF_PROJID);\n\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw_inode, ei, i_projid))\n\t\traw_inode->i_projid = cpu_to_le32(i_projid);\n\n\text4_inode_csum_set(inode, raw_inode, ei);\n\tspin_unlock(&ei->i_raw_lock);\n\tif (inode->i_sb->s_flags & MS_LAZYTIME)\n\t\text4_update_other_inodes_time(inode->i_sb, inode->i_ino,\n\t\t\t\t\t      bh->b_data);\n\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\trc = ext4_handle_dirty_metadata(handle, NULL, bh);\n\tif (!err)\n\t\terr = rc;\n\text4_clear_inode_state(inode, EXT4_STATE_NEW);\n\tif (set_large_file) {\n\t\tBUFFER_TRACE(EXT4_SB(sb)->s_sbh, \"get write access\");\n\t\terr = ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\text4_update_dynamic_rev(sb);\n\t\text4_set_feature_large_file(sb);\n\t\text4_handle_sync(handle);\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t}\n\text4_update_inode_fsync_trans(handle, inode, need_datasync);\nout_brelse:\n\tbrelse(bh);\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}\n\n/*\n * ext4_write_inode()\n *\n * We are called from a few places:\n *\n * - Within generic_file_aio_write() -> generic_write_sync() for O_SYNC files.\n *   Here, there will be no transaction running. We wait for any running\n *   transaction to commit.\n *\n * - Within flush work (sys_sync(), kupdate and such).\n *   We wait on commit, if told to.\n *\n * - Within iput_final() -> write_inode_now()\n *   We wait on commit, if told to.\n *\n * In all cases it is actually safe for us to return without doing anything,\n * because the inode has been copied into a raw inode buffer in\n * ext4_mark_inode_dirty().  This is a correctness thing for WB_SYNC_ALL\n * writeback.\n *\n * Note that we are absolutely dependent upon all inode dirtiers doing the\n * right thing: they *must* call mark_inode_dirty() after dirtying info in\n * which we are interested.\n *\n * It would be a bug for them to not do this.  The code:\n *\n *\tmark_inode_dirty(inode)\n *\tstuff();\n *\tinode->i_size = expr;\n *\n * is in error because write_inode() could occur while `stuff()' is running,\n * and the new i_size will be lost.  Plus the inode will no longer be on the\n * superblock's dirty inode list.\n */\nint ext4_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err;\n\n\tif (WARN_ON_ONCE(current->flags & PF_MEMALLOC))\n\t\treturn 0;\n\n\tif (EXT4_SB(inode->i_sb)->s_journal) {\n\t\tif (ext4_journal_current_handle()) {\n\t\t\tjbd_debug(1, \"called recursively, non-PF_MEMALLOC!\\n\");\n\t\t\tdump_stack();\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/*\n\t\t * No need to force transaction in WB_SYNC_NONE mode. Also\n\t\t * ext4_sync_fs() will force the commit after everything is\n\t\t * written.\n\t\t */\n\t\tif (wbc->sync_mode != WB_SYNC_ALL || wbc->for_sync)\n\t\t\treturn 0;\n\n\t\terr = ext4_force_commit(inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc;\n\n\t\terr = __ext4_get_inode_loc(inode, &iloc, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t\t/*\n\t\t * sync(2) will flush the whole buffer cache. No need to do\n\t\t * it here separately for each inode.\n\t\t */\n\t\tif (wbc->sync_mode == WB_SYNC_ALL && !wbc->for_sync)\n\t\t\tsync_dirty_buffer(iloc.bh);\n\t\tif (buffer_req(iloc.bh) && !buffer_uptodate(iloc.bh)) {\n\t\t\tEXT4_ERROR_INODE_BLOCK(inode, iloc.bh->b_blocknr,\n\t\t\t\t\t \"IO error syncing inode\");\n\t\t\terr = -EIO;\n\t\t}\n\t\tbrelse(iloc.bh);\n\t}\n\treturn err;\n}\n\n/*\n * In data=journal mode ext4_journalled_invalidatepage() may fail to invalidate\n * buffers that are attached to a page stradding i_size and are undergoing\n * commit. In that case we have to wait for commit to finish and try again.\n */\nstatic void ext4_wait_for_tail_page_commit(struct inode *inode)\n{\n\tstruct page *page;\n\tunsigned offset;\n\tjournal_t *journal = EXT4_SB(inode->i_sb)->s_journal;\n\ttid_t commit_tid = 0;\n\tint ret;\n\n\toffset = inode->i_size & (PAGE_SIZE - 1);\n\t/*\n\t * All buffers in the last page remain valid? Then there's nothing to\n\t * do. We do the check mainly to optimize the common PAGE_SIZE ==\n\t * blocksize case\n\t */\n\tif (offset > PAGE_SIZE - (1 << inode->i_blkbits))\n\t\treturn;\n\twhile (1) {\n\t\tpage = find_lock_page(inode->i_mapping,\n\t\t\t\t      inode->i_size >> PAGE_SHIFT);\n\t\tif (!page)\n\t\t\treturn;\n\t\tret = __ext4_journalled_invalidatepage(page, offset,\n\t\t\t\t\t\tPAGE_SIZE - offset);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tif (ret != -EBUSY)\n\t\t\treturn;\n\t\tcommit_tid = 0;\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_committing_transaction)\n\t\t\tcommit_tid = journal->j_committing_transaction->t_tid;\n\t\tread_unlock(&journal->j_state_lock);\n\t\tif (commit_tid)\n\t\t\tjbd2_log_wait_commit(journal, commit_tid);\n\t}\n}\n\n/*\n * ext4_setattr()\n *\n * Called from notify_change.\n *\n * We want to trap VFS attempts to truncate the file as soon as\n * possible.  In particular, we want to make sure that when the VFS\n * shrinks i_size, we put the inode on the orphan list and modify\n * i_disksize immediately, so that during the subsequent flushing of\n * dirty pages and freeing of disk blocks, we can guarantee that any\n * commit will leave the blocks being flushed in an unused state on\n * disk.  (On recovery, the inode will get truncated and the blocks will\n * be freed, so we have a strong guarantee that no future commit will\n * leave these blocks visible to the user.)\n *\n * Another thing we have to assure is that if we are in ordered mode\n * and inode is still attached to the committing transaction, we must\n * we start writeout of all the dirty pages which are being truncated.\n * This way we are sure that all the data written in the previous\n * transaction are already on disk (truncate waits for pages under\n * writeback).\n *\n * Called with inode->i_mutex down.\n */\nint ext4_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint error, rc = 0;\n\tint orphan = 0;\n\tconst unsigned int ia_valid = attr->ia_valid;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif (is_quota_modification(inode, attr)) {\n\t\terror = dquot_initialize(inode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif ((ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)) ||\n\t    (ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid))) {\n\t\thandle_t *handle;\n\n\t\t/* (user+group)*(old+new) structure, inode write (sb,\n\t\t * inode block, ? - but truncate inode update has it) */\n\t\thandle = ext4_journal_start(inode, EXT4_HT_QUOTA,\n\t\t\t(EXT4_MAXQUOTAS_INIT_BLOCKS(inode->i_sb) +\n\t\t\t EXT4_MAXQUOTAS_DEL_BLOCKS(inode->i_sb)) + 3);\n\t\tif (IS_ERR(handle)) {\n\t\t\terror = PTR_ERR(handle);\n\t\t\tgoto err_out;\n\t\t}\n\t\terror = dquot_transfer(inode, attr);\n\t\tif (error) {\n\t\t\text4_journal_stop(handle);\n\t\t\treturn error;\n\t\t}\n\t\t/* Update corresponding info in inode so that everything is in\n\t\t * one transaction */\n\t\tif (attr->ia_valid & ATTR_UID)\n\t\t\tinode->i_uid = attr->ia_uid;\n\t\tif (attr->ia_valid & ATTR_GID)\n\t\t\tinode->i_gid = attr->ia_gid;\n\t\terror = ext4_mark_inode_dirty(handle, inode);\n\t\text4_journal_stop(handle);\n\t}\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\thandle_t *handle;\n\t\tloff_t oldsize = inode->i_size;\n\t\tint shrink = (attr->ia_size <= inode->i_size);\n\n\t\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {\n\t\t\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\t\t\tif (attr->ia_size > sbi->s_bitmap_maxbytes)\n\t\t\t\treturn -EFBIG;\n\t\t}\n\t\tif (!S_ISREG(inode->i_mode))\n\t\t\treturn -EINVAL;\n\n\t\tif (IS_I_VERSION(inode) && attr->ia_size != inode->i_size)\n\t\t\tinode_inc_iversion(inode);\n\n\t\tif (ext4_should_order_data(inode) &&\n\t\t    (attr->ia_size < inode->i_size)) {\n\t\t\terror = ext4_begin_ordered_truncate(inode,\n\t\t\t\t\t\t\t    attr->ia_size);\n\t\t\tif (error)\n\t\t\t\tgoto err_out;\n\t\t}\n\t\tif (attr->ia_size != inode->i_size) {\n\t\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 3);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\terror = PTR_ERR(handle);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tif (ext4_handle_valid(handle) && shrink) {\n\t\t\t\terror = ext4_orphan_add(handle, inode);\n\t\t\t\torphan = 1;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Update c/mtime on truncate up, ext4_truncate() will\n\t\t\t * update c/mtime in shrink case below\n\t\t\t */\n\t\t\tif (!shrink) {\n\t\t\t\tinode->i_mtime = ext4_current_time(inode);\n\t\t\t\tinode->i_ctime = inode->i_mtime;\n\t\t\t}\n\t\t\tdown_write(&EXT4_I(inode)->i_data_sem);\n\t\t\tEXT4_I(inode)->i_disksize = attr->ia_size;\n\t\t\trc = ext4_mark_inode_dirty(handle, inode);\n\t\t\tif (!error)\n\t\t\t\terror = rc;\n\t\t\t/*\n\t\t\t * We have to update i_size under i_data_sem together\n\t\t\t * with i_disksize to avoid races with writeback code\n\t\t\t * running ext4_wb_update_i_disksize().\n\t\t\t */\n\t\t\tif (!error)\n\t\t\t\ti_size_write(inode, attr->ia_size);\n\t\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\t\text4_journal_stop(handle);\n\t\t\tif (error) {\n\t\t\t\tif (orphan)\n\t\t\t\t\text4_orphan_del(NULL, inode);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t\tif (!shrink)\n\t\t\tpagecache_isize_extended(inode, oldsize, inode->i_size);\n\n\t\t/*\n\t\t * Blocks are going to be removed from the inode. Wait\n\t\t * for dio in flight.  Temporarily disable\n\t\t * dioread_nolock to prevent livelock.\n\t\t */\n\t\tif (orphan) {\n\t\t\tif (!ext4_should_journal_data(inode)) {\n\t\t\t\text4_inode_block_unlocked_dio(inode);\n\t\t\t\tinode_dio_wait(inode);\n\t\t\t\text4_inode_resume_unlocked_dio(inode);\n\t\t\t} else\n\t\t\t\text4_wait_for_tail_page_commit(inode);\n\t\t}\n\t\tdown_write(&EXT4_I(inode)->i_mmap_sem);\n\t\t/*\n\t\t * Truncate pagecache after we've waited for commit\n\t\t * in data=journal mode to make pages freeable.\n\t\t */\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tif (shrink)\n\t\t\text4_truncate(inode);\n\t\tup_write(&EXT4_I(inode)->i_mmap_sem);\n\t}\n\n\tif (!rc) {\n\t\tsetattr_copy(inode, attr);\n\t\tmark_inode_dirty(inode);\n\t}\n\n\t/*\n\t * If the call to ext4_truncate failed to get a transaction handle at\n\t * all, we need to clean up the in-core orphan list manually.\n\t */\n\tif (orphan && inode->i_nlink)\n\t\text4_orphan_del(NULL, inode);\n\n\tif (!rc && (ia_valid & ATTR_MODE))\n\t\trc = posix_acl_chmod(inode, inode->i_mode);\n\nerr_out:\n\text4_std_error(inode->i_sb, error);\n\tif (!error)\n\t\terror = rc;\n\treturn error;\n}\n\nint ext4_getattr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t struct kstat *stat)\n{\n\tstruct inode *inode;\n\tunsigned long long delalloc_blocks;\n\n\tinode = d_inode(dentry);\n\tgeneric_fillattr(inode, stat);\n\n\t/*\n\t * If there is inline data in the inode, the inode will normally not\n\t * have data blocks allocated (it may have an external xattr block).\n\t * Report at least one sector for such files, so tools like tar, rsync,\n\t * others doen't incorrectly think the file is completely sparse.\n\t */\n\tif (unlikely(ext4_has_inline_data(inode)))\n\t\tstat->blocks += (stat->size + 511) >> 9;\n\n\t/*\n\t * We can't update i_blocks if the block allocation is delayed\n\t * otherwise in the case of system crash before the real block\n\t * allocation is done, we will have i_blocks inconsistent with\n\t * on-disk file blocks.\n\t * We always keep i_blocks updated together with real\n\t * allocation. But to not confuse with user, stat\n\t * will return the blocks that include the delayed allocation\n\t * blocks for this file.\n\t */\n\tdelalloc_blocks = EXT4_C2B(EXT4_SB(inode->i_sb),\n\t\t\t\t   EXT4_I(inode)->i_reserved_data_blocks);\n\tstat->blocks += delalloc_blocks << (inode->i_sb->s_blocksize_bits - 9);\n\treturn 0;\n}\n\nstatic int ext4_index_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t   int pextents)\n{\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn ext4_ind_trans_blocks(inode, lblocks);\n\treturn ext4_ext_index_trans_blocks(inode, pextents);\n}\n\n/*\n * Account for index blocks, block groups bitmaps and block group\n * descriptor blocks if modify datablocks and index blocks\n * worse case, the indexs blocks spread over different block groups\n *\n * If datablocks are discontiguous, they are possible to spread over\n * different block groups too. If they are contiguous, with flexbg,\n * they could still across block group boundary.\n *\n * Also account for superblock, inode, quota and xattr blocks\n */\nstatic int ext4_meta_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t  int pextents)\n{\n\text4_group_t groups, ngroups = ext4_get_groups_count(inode->i_sb);\n\tint gdpblocks;\n\tint idxblocks;\n\tint ret = 0;\n\n\t/*\n\t * How many index blocks need to touch to map @lblocks logical blocks\n\t * to @pextents physical extents?\n\t */\n\tidxblocks = ext4_index_trans_blocks(inode, lblocks, pextents);\n\n\tret = idxblocks;\n\n\t/*\n\t * Now let's see how many group bitmaps and group descriptors need\n\t * to account\n\t */\n\tgroups = idxblocks + pextents;\n\tgdpblocks = groups;\n\tif (groups > ngroups)\n\t\tgroups = ngroups;\n\tif (groups > EXT4_SB(inode->i_sb)->s_gdb_count)\n\t\tgdpblocks = EXT4_SB(inode->i_sb)->s_gdb_count;\n\n\t/* bitmaps and block group descriptor blocks */\n\tret += groups + gdpblocks;\n\n\t/* Blocks for super block, inode, quota and xattr blocks */\n\tret += EXT4_META_TRANS_BLOCKS(inode->i_sb);\n\n\treturn ret;\n}\n\n/*\n * Calculate the total number of credits to reserve to fit\n * the modification of a single pages into a single transaction,\n * which may include multiple chunks of block allocations.\n *\n * This could be called via ext4_write_begin()\n *\n * We need to consider the worse case, when\n * one new block per extent.\n */\nint ext4_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\tint ret;\n\n\tret = ext4_meta_trans_blocks(inode, bpp, bpp);\n\n\t/* Account for data blocks for journalled mode */\n\tif (ext4_should_journal_data(inode))\n\t\tret += bpp;\n\treturn ret;\n}\n\n/*\n * Calculate the journal credits for a chunk of data modification.\n *\n * This is called from DIO, fallocate or whoever calling\n * ext4_map_blocks() to map/allocate a chunk of contiguous disk blocks.\n *\n * journal buffers for data blocks are not included here, as DIO\n * and fallocate do no need to journal data buffers.\n */\nint ext4_chunk_trans_blocks(struct inode *inode, int nrblocks)\n{\n\treturn ext4_meta_trans_blocks(inode, nrblocks, 1);\n}\n\n/*\n * The caller must have previously called ext4_reserve_inode_write().\n * Give this, we know that the caller already has write access to iloc->bh.\n */\nint ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext4_do_update_inode() does jbd2_journal_dirty_metadata */\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}\n\n/*\n * On success, We end up with an outstanding reference count against\n * iloc->bh.  This _must_ be cleaned up later.\n */\n\nint\next4_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext4_iloc *iloc)\n{\n\tint err;\n\n\terr = ext4_get_inode_loc(inode, iloc);\n\tif (!err) {\n\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, iloc->bh);\n\t\tif (err) {\n\t\t\tbrelse(iloc->bh);\n\t\t\tiloc->bh = NULL;\n\t\t}\n\t}\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}\n\n/*\n * Expand an inode by new_extra_isize bytes.\n * Returns 0 on success or negative error number on failure.\n */\nstatic int ext4_expand_extra_isize(struct inode *inode,\n\t\t\t\t   unsigned int new_extra_isize,\n\t\t\t\t   struct ext4_iloc iloc,\n\t\t\t\t   handle_t *handle)\n{\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_xattr_ibody_header *header;\n\n\tif (EXT4_I(inode)->i_extra_isize >= new_extra_isize)\n\t\treturn 0;\n\n\traw_inode = ext4_raw_inode(&iloc);\n\n\theader = IHDR(inode, raw_inode);\n\n\t/* No extended attributes present */\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR) ||\n\t    header->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC)) {\n\t\tmemset((void *)raw_inode + EXT4_GOOD_OLD_INODE_SIZE, 0,\n\t\t\tnew_extra_isize);\n\t\tEXT4_I(inode)->i_extra_isize = new_extra_isize;\n\t\treturn 0;\n\t}\n\n\t/* try to expand with EAs present */\n\treturn ext4_expand_extra_isize_ea(inode, new_extra_isize,\n\t\t\t\t\t  raw_inode, handle);\n}\n\n/*\n * What we do here is to mark the in-core inode as clean with respect to inode\n * dirtiness (it may still be data-dirty).\n * This means that the in-core inode may be reaped by prune_icache\n * without having to perform any I/O.  This is a very good thing,\n * because *any* task may call prune_icache - even ones which\n * have a transaction open against a different journal.\n *\n * Is this cheating?  Not really.  Sure, we haven't written the\n * inode out, but prune_icache isn't a user-visible syncing function.\n * Whenever the user wants stuff synced (sys_sync, sys_msync, sys_fsync)\n * we start and wait on commits.\n */\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\treturn err;\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ext4_mark_iloc_dirty(handle, inode, &iloc);\n}\n\n/*\n * ext4_dirty_inode() is called from __mark_inode_dirty()\n *\n * We're really interested in the case where a file is being extended.\n * i_size has been changed by generic_commit_write() and we thus need\n * to include the updated inode in the current transaction.\n *\n * Also, dquot_alloc_block() will always dirty the inode when blocks\n * are allocated to the file.\n *\n * If the inode is marked synchronous, we don't honour that here - doing\n * so would cause a commit on atime updates, which we don't bother doing.\n * We handle synchronous inodes at the highest possible level.\n *\n * If only the I_DIRTY_TIME flag is set, we can skip everything.  If\n * I_DIRTY_TIME and I_DIRTY_SYNC is set, the only inode fields we need\n * to copy into the on-disk inode structure are the timestamp files.\n */\nvoid ext4_dirty_inode(struct inode *inode, int flags)\n{\n\thandle_t *handle;\n\n\tif (flags == I_DIRTY_TIME)\n\t\treturn;\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 2);\n\tif (IS_ERR(handle))\n\t\tgoto out;\n\n\text4_mark_inode_dirty(handle, inode);\n\n\text4_journal_stop(handle);\nout:\n\treturn;\n}\n\n#if 0\n/*\n * Bind an inode's backing buffer_head into this transaction, to prevent\n * it from being flushed to disk early.  Unlike\n * ext4_reserve_inode_write, this leaves behind no bh reference and\n * returns no iloc structure, so the caller needs to repeat the iloc\n * lookup to mark the inode dirty later.\n */\nstatic int ext4_pin_inode(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\n\tint err = 0;\n\tif (handle) {\n\t\terr = ext4_get_inode_loc(inode, &iloc);\n\t\tif (!err) {\n\t\t\tBUFFER_TRACE(iloc.bh, \"get_write_access\");\n\t\t\terr = jbd2_journal_get_write_access(handle, iloc.bh);\n\t\t\tif (!err)\n\t\t\t\terr = ext4_handle_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t iloc.bh);\n\t\t\tbrelse(iloc.bh);\n\t\t}\n\t}\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}\n#endif\n\nint ext4_change_inode_journal_flag(struct inode *inode, int val)\n{\n\tjournal_t *journal;\n\thandle_t *handle;\n\tint err;\n\n\t/*\n\t * We have to be very careful here: changing a data block's\n\t * journaling status dynamically is dangerous.  If we write a\n\t * data block to the journal, change the status and then delete\n\t * that block, we risk forgetting to revoke the old log record\n\t * from the journal and so a subsequent replay can corrupt data.\n\t * So, first we make sure that the journal is empty and that\n\t * nobody is changing anything.\n\t */\n\n\tjournal = EXT4_JOURNAL(inode);\n\tif (!journal)\n\t\treturn 0;\n\tif (is_journal_aborted(journal))\n\t\treturn -EROFS;\n\t/* We have to allocate physical blocks for delalloc blocks\n\t * before flushing journal. otherwise delalloc blocks can not\n\t * be allocated any more. even more truncate on delalloc blocks\n\t * could trigger BUG by flushing delalloc blocks in journal.\n\t * There is no delalloc block in non-journal data mode.\n\t */\n\tif (val && test_opt(inode->i_sb, DELALLOC)) {\n\t\terr = ext4_alloc_da_blocks(inode);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t/* Wait for all existing dio workers */\n\text4_inode_block_unlocked_dio(inode);\n\tinode_dio_wait(inode);\n\n\tjbd2_journal_lock_updates(journal);\n\n\t/*\n\t * OK, there are no updates running now, and all cached data is\n\t * synced to disk.  We are now in a completely consistent state\n\t * which doesn't have anything in the journal, and we know that\n\t * no filesystem updates are running, so it is safe to modify\n\t * the inode's in-core data-journaling state flag now.\n\t */\n\n\tif (val)\n\t\text4_set_inode_flag(inode, EXT4_INODE_JOURNAL_DATA);\n\telse {\n\t\terr = jbd2_journal_flush(journal);\n\t\tif (err < 0) {\n\t\t\tjbd2_journal_unlock_updates(journal);\n\t\t\text4_inode_resume_unlocked_dio(inode);\n\t\t\treturn err;\n\t\t}\n\t\text4_clear_inode_flag(inode, EXT4_INODE_JOURNAL_DATA);\n\t}\n\text4_set_aops(inode);\n\n\tjbd2_journal_unlock_updates(journal);\n\text4_inode_resume_unlocked_dio(inode);\n\n\t/* Finally we can mark the inode as dirty. */\n\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\terr = ext4_mark_inode_dirty(handle, inode);\n\text4_handle_sync(handle);\n\text4_journal_stop(handle);\n\text4_std_error(inode->i_sb, err);\n\n\treturn err;\n}\n\nstatic int ext4_bh_unmapped(handle_t *handle, struct buffer_head *bh)\n{\n\treturn !buffer_mapped(bh);\n}\n\nint ext4_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tloff_t size;\n\tunsigned long len;\n\tint ret;\n\tstruct file *file = vma->vm_file;\n\tstruct inode *inode = file_inode(file);\n\tstruct address_space *mapping = inode->i_mapping;\n\thandle_t *handle;\n\tget_block_t *get_block;\n\tint retries = 0;\n\n\tsb_start_pagefault(inode->i_sb);\n\tfile_update_time(vma->vm_file);\n\n\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n\t/* Delalloc case is easy... */\n\tif (test_opt(inode->i_sb, DELALLOC) &&\n\t    !ext4_should_journal_data(inode) &&\n\t    !ext4_nonda_switch(inode->i_sb)) {\n\t\tdo {\n\t\t\tret = block_page_mkwrite(vma, vmf,\n\t\t\t\t\t\t   ext4_da_get_block_prep);\n\t\t} while (ret == -ENOSPC &&\n\t\t       ext4_should_retry_alloc(inode->i_sb, &retries));\n\t\tgoto out_ret;\n\t}\n\n\tlock_page(page);\n\tsize = i_size_read(inode);\n\t/* Page got truncated from under us? */\n\tif (page->mapping != mapping || page_offset(page) > size) {\n\t\tunlock_page(page);\n\t\tret = VM_FAULT_NOPAGE;\n\t\tgoto out;\n\t}\n\n\tif (page->index == size >> PAGE_SHIFT)\n\t\tlen = size & ~PAGE_MASK;\n\telse\n\t\tlen = PAGE_SIZE;\n\t/*\n\t * Return if we have all the buffers mapped. This avoids the need to do\n\t * journal_start/journal_stop which can block and take a long time\n\t */\n\tif (page_has_buffers(page)) {\n\t\tif (!ext4_walk_page_buffers(NULL, page_buffers(page),\n\t\t\t\t\t    0, len, NULL,\n\t\t\t\t\t    ext4_bh_unmapped)) {\n\t\t\t/* Wait so that we don't change page under IO */\n\t\t\twait_for_stable_page(page);\n\t\t\tret = VM_FAULT_LOCKED;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tunlock_page(page);\n\t/* OK, we need to fill the hole... */\n\tif (ext4_should_dioread_nolock(inode))\n\t\tget_block = ext4_get_block_unwritten;\n\telse\n\t\tget_block = ext4_get_block;\nretry_alloc:\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE,\n\t\t\t\t    ext4_writepage_trans_blocks(inode));\n\tif (IS_ERR(handle)) {\n\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto out;\n\t}\n\tret = block_page_mkwrite(vma, vmf, get_block);\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tif (ext4_walk_page_buffers(handle, page_buffers(page), 0,\n\t\t\t  PAGE_SIZE, NULL, do_journal_get_write_access)) {\n\t\t\tunlock_page(page);\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\t\text4_journal_stop(handle);\n\t\t\tgoto out;\n\t\t}\n\t\text4_set_inode_state(inode, EXT4_STATE_JDATA);\n\t}\n\text4_journal_stop(handle);\n\tif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry_alloc;\nout_ret:\n\tret = block_page_mkwrite_return(ret);\nout:\n\tup_read(&EXT4_I(inode)->i_mmap_sem);\n\tsb_end_pagefault(inode->i_sb);\n\treturn ret;\n}\n\nint ext4_filemap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tint err;\n\n\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n\terr = filemap_fault(vma, vmf);\n\tup_read(&EXT4_I(inode)->i_mmap_sem);\n\n\treturn err;\n}\n\n/*\n * Find the first extent at or after @lblk in an inode that is not a hole.\n * Search for @map_len blocks at most. The extent is returned in @result.\n *\n * The function returns 1 if we found an extent. The function returns 0 in\n * case there is no extent at or after @lblk and in that case also sets\n * @result->es_len to 0. In case of error, the error code is returned.\n */\nint ext4_get_next_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t unsigned int map_len, struct extent_status *result)\n{\n\tstruct ext4_map_blocks map;\n\tstruct extent_status es = {};\n\tint ret;\n\n\tmap.m_lblk = lblk;\n\tmap.m_len = map_len;\n\n\t/*\n\t * For non-extent based files this loop may iterate several times since\n\t * we do not determine full hole size.\n\t */\n\twhile (map.m_len > 0) {\n\t\tret = ext4_map_blocks(NULL, inode, &map, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t/* There's extent covering m_lblk? Just return it. */\n\t\tif (ret > 0) {\n\t\t\tint status;\n\n\t\t\text4_es_store_pblock(result, map.m_pblk);\n\t\t\tresult->es_lblk = map.m_lblk;\n\t\t\tresult->es_len = map.m_len;\n\t\t\tif (map.m_flags & EXT4_MAP_UNWRITTEN)\n\t\t\t\tstatus = EXTENT_STATUS_UNWRITTEN;\n\t\t\telse\n\t\t\t\tstatus = EXTENT_STATUS_WRITTEN;\n\t\t\text4_es_store_status(result, status);\n\t\t\treturn 1;\n\t\t}\n\t\text4_es_find_delayed_extent_range(inode, map.m_lblk,\n\t\t\t\t\t\t  map.m_lblk + map.m_len - 1,\n\t\t\t\t\t\t  &es);\n\t\t/* Is delalloc data before next block in extent tree? */\n\t\tif (es.es_len && es.es_lblk < map.m_lblk + map.m_len) {\n\t\t\text4_lblk_t offset = 0;\n\n\t\t\tif (es.es_lblk < lblk)\n\t\t\t\toffset = lblk - es.es_lblk;\n\t\t\tresult->es_lblk = es.es_lblk + offset;\n\t\t\text4_es_store_pblock(result,\n\t\t\t\t\t     ext4_es_pblock(&es) + offset);\n\t\t\tresult->es_len = es.es_len - offset;\n\t\t\text4_es_store_status(result, ext4_es_status(&es));\n\n\t\t\treturn 1;\n\t\t}\n\t\t/* There's a hole at m_lblk, advance us after it */\n\t\tmap.m_lblk += map.m_len;\n\t\tmap_len -= map.m_len;\n\t\tmap.m_len = map_len;\n\t\tcond_resched();\n\t}\n\tresult->es_len = 0;\n\treturn 0;\n}\n"], "fixing_code": ["/*\n *  linux/fs/ext4/inode.c\n *\n * Copyright (C) 1992, 1993, 1994, 1995\n * Remy Card (card@masi.ibp.fr)\n * Laboratoire MASI - Institut Blaise Pascal\n * Universite Pierre et Marie Curie (Paris VI)\n *\n *  from\n *\n *  linux/fs/minix/inode.c\n *\n *  Copyright (C) 1991, 1992  Linus Torvalds\n *\n *  64-bit file support on 64-bit platforms by Jakub Jelinek\n *\t(jj@sunsite.ms.mff.cuni.cz)\n *\n *  Assorted race fixes, rewrite of ext4_get_block() by Al Viro, 2000\n */\n\n#include <linux/fs.h>\n#include <linux/time.h>\n#include <linux/highuid.h>\n#include <linux/pagemap.h>\n#include <linux/dax.h>\n#include <linux/quotaops.h>\n#include <linux/string.h>\n#include <linux/buffer_head.h>\n#include <linux/writeback.h>\n#include <linux/pagevec.h>\n#include <linux/mpage.h>\n#include <linux/namei.h>\n#include <linux/uio.h>\n#include <linux/bio.h>\n#include <linux/workqueue.h>\n#include <linux/kernel.h>\n#include <linux/printk.h>\n#include <linux/slab.h>\n#include <linux/bitops.h>\n\n#include \"ext4_jbd2.h\"\n#include \"xattr.h\"\n#include \"acl.h\"\n#include \"truncate.h\"\n\n#include <trace/events/ext4.h>\n\n#define MPAGE_DA_EXTENT_TAIL 0x01\n\nstatic __u32 ext4_inode_csum(struct inode *inode, struct ext4_inode *raw,\n\t\t\t      struct ext4_inode_info *ei)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t__u16 csum_lo;\n\t__u16 csum_hi = 0;\n\t__u32 csum;\n\n\tcsum_lo = le16_to_cpu(raw->i_checksum_lo);\n\traw->i_checksum_lo = 0;\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw, ei, i_checksum_hi)) {\n\t\tcsum_hi = le16_to_cpu(raw->i_checksum_hi);\n\t\traw->i_checksum_hi = 0;\n\t}\n\n\tcsum = ext4_chksum(sbi, ei->i_csum_seed, (__u8 *)raw,\n\t\t\t   EXT4_INODE_SIZE(inode->i_sb));\n\n\traw->i_checksum_lo = cpu_to_le16(csum_lo);\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw, ei, i_checksum_hi))\n\t\traw->i_checksum_hi = cpu_to_le16(csum_hi);\n\n\treturn csum;\n}\n\nstatic int ext4_inode_csum_verify(struct inode *inode, struct ext4_inode *raw,\n\t\t\t\t  struct ext4_inode_info *ei)\n{\n\t__u32 provided, calculated;\n\n\tif (EXT4_SB(inode->i_sb)->s_es->s_creator_os !=\n\t    cpu_to_le32(EXT4_OS_LINUX) ||\n\t    !ext4_has_metadata_csum(inode->i_sb))\n\t\treturn 1;\n\n\tprovided = le16_to_cpu(raw->i_checksum_lo);\n\tcalculated = ext4_inode_csum(inode, raw, ei);\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw, ei, i_checksum_hi))\n\t\tprovided |= ((__u32)le16_to_cpu(raw->i_checksum_hi)) << 16;\n\telse\n\t\tcalculated &= 0xFFFF;\n\n\treturn provided == calculated;\n}\n\nstatic void ext4_inode_csum_set(struct inode *inode, struct ext4_inode *raw,\n\t\t\t\tstruct ext4_inode_info *ei)\n{\n\t__u32 csum;\n\n\tif (EXT4_SB(inode->i_sb)->s_es->s_creator_os !=\n\t    cpu_to_le32(EXT4_OS_LINUX) ||\n\t    !ext4_has_metadata_csum(inode->i_sb))\n\t\treturn;\n\n\tcsum = ext4_inode_csum(inode, raw, ei);\n\traw->i_checksum_lo = cpu_to_le16(csum & 0xFFFF);\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw, ei, i_checksum_hi))\n\t\traw->i_checksum_hi = cpu_to_le16(csum >> 16);\n}\n\nstatic inline int ext4_begin_ordered_truncate(struct inode *inode,\n\t\t\t\t\t      loff_t new_size)\n{\n\ttrace_ext4_begin_ordered_truncate(inode, new_size);\n\t/*\n\t * If jinode is zero, then we never opened the file for\n\t * writing, so there's no need to call\n\t * jbd2_journal_begin_ordered_truncate() since there's no\n\t * outstanding writes we need to flush.\n\t */\n\tif (!EXT4_I(inode)->jinode)\n\t\treturn 0;\n\treturn jbd2_journal_begin_ordered_truncate(EXT4_JOURNAL(inode),\n\t\t\t\t\t\t   EXT4_I(inode)->jinode,\n\t\t\t\t\t\t   new_size);\n}\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length);\nstatic int __ext4_journalled_writepage(struct page *page, unsigned int len);\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh);\nstatic int ext4_meta_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t  int pextents);\n\n/*\n * Test whether an inode is a fast symlink.\n */\nint ext4_inode_is_fast_symlink(struct inode *inode)\n{\n        int ea_blocks = EXT4_I(inode)->i_file_acl ?\n\t\tEXT4_CLUSTER_SIZE(inode->i_sb) >> 9 : 0;\n\n\tif (ext4_has_inline_data(inode))\n\t\treturn 0;\n\n\treturn (S_ISLNK(inode->i_mode) && inode->i_blocks - ea_blocks == 0);\n}\n\n/*\n * Restart the transaction associated with *handle.  This does a commit,\n * so before we call here everything must be consistently dirtied against\n * this transaction.\n */\nint ext4_truncate_restart_trans(handle_t *handle, struct inode *inode,\n\t\t\t\t int nblocks)\n{\n\tint ret;\n\n\t/*\n\t * Drop i_data_sem to avoid deadlock with ext4_map_blocks.  At this\n\t * moment, get_block can be called only for blocks inside i_size since\n\t * page cache has been already dropped and writes are blocked by\n\t * i_mutex. So we can safely drop the i_data_sem here.\n\t */\n\tBUG_ON(EXT4_JOURNAL(inode) == NULL);\n\tjbd_debug(2, \"restarting handle %p\\n\", handle);\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tret = ext4_journal_restart(handle, nblocks);\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\treturn ret;\n}\n\n/*\n * Called at the last iput() if i_nlink is zero.\n */\nvoid ext4_evict_inode(struct inode *inode)\n{\n\thandle_t *handle;\n\tint err;\n\n\ttrace_ext4_evict_inode(inode);\n\n\tif (inode->i_nlink) {\n\t\t/*\n\t\t * When journalling data dirty buffers are tracked only in the\n\t\t * journal. So although mm thinks everything is clean and\n\t\t * ready for reaping the inode might still have some pages to\n\t\t * write in the running transaction or waiting to be\n\t\t * checkpointed. Thus calling jbd2_journal_invalidatepage()\n\t\t * (via truncate_inode_pages()) to discard these buffers can\n\t\t * cause data loss. Also even if we did not discard these\n\t\t * buffers, we would have no way to find them after the inode\n\t\t * is reaped and thus user could see stale data if he tries to\n\t\t * read them before the transaction is checkpointed. So be\n\t\t * careful and force everything to disk here... We use\n\t\t * ei->i_datasync_tid to store the newest transaction\n\t\t * containing inode's data.\n\t\t *\n\t\t * Note that directories do not have this problem because they\n\t\t * don't use page cache.\n\t\t */\n\t\tif (ext4_should_journal_data(inode) &&\n\t\t    (S_ISLNK(inode->i_mode) || S_ISREG(inode->i_mode)) &&\n\t\t    inode->i_ino != EXT4_JOURNAL_INO) {\n\t\t\tjournal_t *journal = EXT4_SB(inode->i_sb)->s_journal;\n\t\t\ttid_t commit_tid = EXT4_I(inode)->i_datasync_tid;\n\n\t\t\tjbd2_complete_transaction(journal, commit_tid);\n\t\t\tfilemap_write_and_wait(&inode->i_data);\n\t\t}\n\t\ttruncate_inode_pages_final(&inode->i_data);\n\n\t\tgoto no_delete;\n\t}\n\n\tif (is_bad_inode(inode))\n\t\tgoto no_delete;\n\tdquot_initialize(inode);\n\n\tif (ext4_should_order_data(inode))\n\t\text4_begin_ordered_truncate(inode, 0);\n\ttruncate_inode_pages_final(&inode->i_data);\n\n\t/*\n\t * Protect us against freezing - iput() caller didn't have to have any\n\t * protection against it\n\t */\n\tsb_start_intwrite(inode->i_sb);\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE,\n\t\t\t\t    ext4_blocks_for_truncate(inode)+3);\n\tif (IS_ERR(handle)) {\n\t\text4_std_error(inode->i_sb, PTR_ERR(handle));\n\t\t/*\n\t\t * If we're going to skip the normal cleanup, we still need to\n\t\t * make sure that the in-core orphan linked list is properly\n\t\t * cleaned up.\n\t\t */\n\t\text4_orphan_del(NULL, inode);\n\t\tsb_end_intwrite(inode->i_sb);\n\t\tgoto no_delete;\n\t}\n\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\tinode->i_size = 0;\n\terr = ext4_mark_inode_dirty(handle, inode);\n\tif (err) {\n\t\text4_warning(inode->i_sb,\n\t\t\t     \"couldn't mark inode dirty (err %d)\", err);\n\t\tgoto stop_handle;\n\t}\n\tif (inode->i_blocks)\n\t\text4_truncate(inode);\n\n\t/*\n\t * ext4_ext_truncate() doesn't reserve any slop when it\n\t * restarts journal transactions; therefore there may not be\n\t * enough credits left in the handle to remove the inode from\n\t * the orphan list and set the dtime field.\n\t */\n\tif (!ext4_handle_has_enough_credits(handle, 3)) {\n\t\terr = ext4_journal_extend(handle, 3);\n\t\tif (err > 0)\n\t\t\terr = ext4_journal_restart(handle, 3);\n\t\tif (err != 0) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"couldn't extend journal (err %d)\", err);\n\t\tstop_handle:\n\t\t\text4_journal_stop(handle);\n\t\t\text4_orphan_del(NULL, inode);\n\t\t\tsb_end_intwrite(inode->i_sb);\n\t\t\tgoto no_delete;\n\t\t}\n\t}\n\n\t/*\n\t * Kill off the orphan record which ext4_truncate created.\n\t * AKPM: I think this can be inside the above `if'.\n\t * Note that ext4_orphan_del() has to be able to cope with the\n\t * deletion of a non-existent orphan - this is because we don't\n\t * know if ext4_truncate() actually created an orphan record.\n\t * (Well, we could do this if we need to, but heck - it works)\n\t */\n\text4_orphan_del(handle, inode);\n\tEXT4_I(inode)->i_dtime\t= get_seconds();\n\n\t/*\n\t * One subtle ordering requirement: if anything has gone wrong\n\t * (transaction abort, IO errors, whatever), then we can still\n\t * do these next steps (the fs will already have been marked as\n\t * having errors), but we can't free the inode if the mark_dirty\n\t * fails.\n\t */\n\tif (ext4_mark_inode_dirty(handle, inode))\n\t\t/* If that failed, just do the required in-core inode clear. */\n\t\text4_clear_inode(inode);\n\telse\n\t\text4_free_inode(handle, inode);\n\text4_journal_stop(handle);\n\tsb_end_intwrite(inode->i_sb);\n\treturn;\nno_delete:\n\text4_clear_inode(inode);\t/* We must guarantee clearing of inode... */\n}\n\n#ifdef CONFIG_QUOTA\nqsize_t *ext4_get_reserved_space(struct inode *inode)\n{\n\treturn &EXT4_I(inode)->i_reserved_quota;\n}\n#endif\n\n/*\n * Called with i_data_sem down, which is important since we can call\n * ext4_discard_preallocations() from here.\n */\nvoid ext4_da_update_reserve_space(struct inode *inode,\n\t\t\t\t\tint used, int quota_claim)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tspin_lock(&ei->i_block_reservation_lock);\n\ttrace_ext4_da_update_reserve_space(inode, used, quota_claim);\n\tif (unlikely(used > ei->i_reserved_data_blocks)) {\n\t\text4_warning(inode->i_sb, \"%s: ino %lu, used %d \"\n\t\t\t \"with only %d reserved data blocks\",\n\t\t\t __func__, inode->i_ino, used,\n\t\t\t ei->i_reserved_data_blocks);\n\t\tWARN_ON(1);\n\t\tused = ei->i_reserved_data_blocks;\n\t}\n\n\t/* Update per-inode reservations */\n\tei->i_reserved_data_blocks -= used;\n\tpercpu_counter_sub(&sbi->s_dirtyclusters_counter, used);\n\n\tspin_unlock(&EXT4_I(inode)->i_block_reservation_lock);\n\n\t/* Update quota subsystem for data blocks */\n\tif (quota_claim)\n\t\tdquot_claim_block(inode, EXT4_C2B(sbi, used));\n\telse {\n\t\t/*\n\t\t * We did fallocate with an offset that is already delayed\n\t\t * allocated. So on delayed allocated writeback we should\n\t\t * not re-claim the quota for fallocated blocks.\n\t\t */\n\t\tdquot_release_reservation_block(inode, EXT4_C2B(sbi, used));\n\t}\n\n\t/*\n\t * If we have done all the pending block allocations and if\n\t * there aren't any writers on the inode, we can discard the\n\t * inode's preallocations.\n\t */\n\tif ((ei->i_reserved_data_blocks == 0) &&\n\t    (atomic_read(&inode->i_writecount) == 0))\n\t\text4_discard_preallocations(inode);\n}\n\nstatic int __check_block_validity(struct inode *inode, const char *func,\n\t\t\t\tunsigned int line,\n\t\t\t\tstruct ext4_map_blocks *map)\n{\n\tif (!ext4_data_block_valid(EXT4_SB(inode->i_sb), map->m_pblk,\n\t\t\t\t   map->m_len)) {\n\t\text4_error_inode(inode, func, line, map->m_pblk,\n\t\t\t\t \"lblock %lu mapped to illegal pblock \"\n\t\t\t\t \"(length %d)\", (unsigned long) map->m_lblk,\n\t\t\t\t map->m_len);\n\t\treturn -EFSCORRUPTED;\n\t}\n\treturn 0;\n}\n\nint ext4_issue_zeroout(struct inode *inode, ext4_lblk_t lblk, ext4_fsblk_t pblk,\n\t\t       ext4_lblk_t len)\n{\n\tint ret;\n\n\tif (ext4_encrypted_inode(inode))\n\t\treturn ext4_encrypted_zeroout(inode, lblk, pblk, len);\n\n\tret = sb_issue_zeroout(inode->i_sb, pblk, len, GFP_NOFS);\n\tif (ret > 0)\n\t\tret = 0;\n\n\treturn ret;\n}\n\n#define check_block_validity(inode, map)\t\\\n\t__check_block_validity((inode), __func__, __LINE__, (map))\n\n#ifdef ES_AGGRESSIVE_TEST\nstatic void ext4_map_blocks_es_recheck(handle_t *handle,\n\t\t\t\t       struct inode *inode,\n\t\t\t\t       struct ext4_map_blocks *es_map,\n\t\t\t\t       struct ext4_map_blocks *map,\n\t\t\t\t       int flags)\n{\n\tint retval;\n\n\tmap->m_flags = 0;\n\t/*\n\t * There is a race window that the result is not the same.\n\t * e.g. xfstests #223 when dioread_nolock enables.  The reason\n\t * is that we lookup a block mapping in extent status tree with\n\t * out taking i_data_sem.  So at the time the unwritten extent\n\t * could be converted.\n\t */\n\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tup_read((&EXT4_I(inode)->i_data_sem));\n\n\t/*\n\t * We don't check m_len because extent will be collpased in status\n\t * tree.  So the m_len might not equal.\n\t */\n\tif (es_map->m_lblk != map->m_lblk ||\n\t    es_map->m_flags != map->m_flags ||\n\t    es_map->m_pblk != map->m_pblk) {\n\t\tprintk(\"ES cache assertion failed for inode: %lu \"\n\t\t       \"es_cached ex [%d/%d/%llu/%x] != \"\n\t\t       \"found ex [%d/%d/%llu/%x] retval %d flags %x\\n\",\n\t\t       inode->i_ino, es_map->m_lblk, es_map->m_len,\n\t\t       es_map->m_pblk, es_map->m_flags, map->m_lblk,\n\t\t       map->m_len, map->m_pblk, map->m_flags,\n\t\t       retval, flags);\n\t}\n}\n#endif /* ES_AGGRESSIVE_TEST */\n\n/*\n * The ext4_map_blocks() function tries to look up the requested blocks,\n * and returns if the blocks are already mapped.\n *\n * Otherwise it takes the write lock of the i_data_sem and allocate blocks\n * and store the allocated blocks in the result buffer head and mark it\n * mapped.\n *\n * If file type is extents based, it will call ext4_ext_map_blocks(),\n * Otherwise, call with ext4_ind_map_blocks() to handle indirect mapping\n * based files\n *\n * On success, it returns the number of blocks being mapped or allocated.  if\n * create==0 and the blocks are pre-allocated and unwritten, the resulting @map\n * is marked as unwritten. If the create == 1, it will mark @map as mapped.\n *\n * It returns 0 if plain look up failed (blocks have not been allocated), in\n * that case, @map is returned as unmapped but we still do fill map->m_len to\n * indicate the length of a hole starting at map->m_lblk.\n *\n * It returns the error in case of allocation failure.\n */\nint ext4_map_blocks(handle_t *handle, struct inode *inode,\n\t\t    struct ext4_map_blocks *map, int flags)\n{\n\tstruct extent_status es;\n\tint retval;\n\tint ret = 0;\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_map_blocks(): inode %lu, flag %d, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, flags, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/*\n\t * ext4_map_blocks returns an int, and m_len is an unsigned int\n\t */\n\tif (unlikely(map->m_len > INT_MAX))\n\t\tmap->m_len = INT_MAX;\n\n\t/* We can handle the block number less than EXT_MAX_BLOCKS */\n\tif (unlikely(map->m_lblk >= EXT_MAX_BLOCKS))\n\t\treturn -EFSCORRUPTED;\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\tif (ext4_es_is_written(&es) || ext4_es_is_unwritten(&es)) {\n\t\t\tmap->m_pblk = ext4_es_pblock(&es) +\n\t\t\t\t\tmap->m_lblk - es.es_lblk;\n\t\t\tmap->m_flags |= ext4_es_is_written(&es) ?\n\t\t\t\t\tEXT4_MAP_MAPPED : EXT4_MAP_UNWRITTEN;\n\t\t\tretval = es.es_len - (map->m_lblk - es.es_lblk);\n\t\t\tif (retval > map->m_len)\n\t\t\t\tretval = map->m_len;\n\t\t\tmap->m_len = retval;\n\t\t} else if (ext4_es_is_delayed(&es) || ext4_es_is_hole(&es)) {\n\t\t\tmap->m_pblk = 0;\n\t\t\tretval = es.es_len - (map->m_lblk - es.es_lblk);\n\t\t\tif (retval > map->m_len)\n\t\t\t\tretval = map->m_len;\n\t\t\tmap->m_len = retval;\n\t\t\tretval = 0;\n\t\t} else {\n\t\t\tBUG_ON(1);\n\t\t}\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(handle, inode, map,\n\t\t\t\t\t   &orig_map, flags);\n#endif\n\t\tgoto found;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags &\n\t\t\t\t\t     EXT4_GET_BLOCKS_KEEP_SIZE);\n\t}\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    !(status & EXTENT_STATUS_WRITTEN) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk,\n\t\t\t\t\t    map->m_len, map->m_pblk, status);\n\t\tif (ret < 0)\n\t\t\tretval = ret;\n\t}\n\tup_read((&EXT4_I(inode)->i_data_sem));\n\nfound:\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\t}\n\n\t/* If it is only a block(s) look up */\n\tif ((flags & EXT4_GET_BLOCKS_CREATE) == 0)\n\t\treturn retval;\n\n\t/*\n\t * Returns if the blocks have already allocated\n\t *\n\t * Note that if blocks have been preallocated\n\t * ext4_ext_get_block() returns the create = 0\n\t * with buffer head unmapped.\n\t */\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED)\n\t\t/*\n\t\t * If we need to convert extent to unwritten\n\t\t * we continue and do the actual work in\n\t\t * ext4_ext_map_blocks()\n\t\t */\n\t\tif (!(flags & EXT4_GET_BLOCKS_CONVERT_UNWRITTEN))\n\t\t\treturn retval;\n\n\t/*\n\t * Here we clear m_flags because after allocating an new extent,\n\t * it will be set again.\n\t */\n\tmap->m_flags &= ~EXT4_MAP_FLAGS;\n\n\t/*\n\t * New blocks allocate and/or writing to unwritten extent\n\t * will possibly result in updating i_data, so we take\n\t * the write lock of i_data_sem, and call get_block()\n\t * with create == 1 flag.\n\t */\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\t/*\n\t * We need to check for EXT4 here because migrate\n\t * could have changed the inode type in between\n\t */\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\tretval = ext4_ext_map_blocks(handle, inode, map, flags);\n\t} else {\n\t\tretval = ext4_ind_map_blocks(handle, inode, map, flags);\n\n\t\tif (retval > 0 && map->m_flags & EXT4_MAP_NEW) {\n\t\t\t/*\n\t\t\t * We allocated new blocks which will result in\n\t\t\t * i_data's format changing.  Force the migrate\n\t\t\t * to fail by clearing migrate flags\n\t\t\t */\n\t\t\text4_clear_inode_state(inode, EXT4_STATE_EXT_MIGRATE);\n\t\t}\n\n\t\t/*\n\t\t * Update reserved blocks/metadata blocks after successful\n\t\t * block allocation which had been deferred till now. We don't\n\t\t * support fallocate for non extent files. So we can update\n\t\t * reserve space here.\n\t\t */\n\t\tif ((retval > 0) &&\n\t\t\t(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE))\n\t\t\text4_da_update_reserve_space(inode, retval, 1);\n\t}\n\n\tif (retval > 0) {\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\t/*\n\t\t * We have to zeroout blocks before inserting them into extent\n\t\t * status tree. Otherwise someone could look them up there and\n\t\t * use them before they are really zeroed.\n\t\t */\n\t\tif (flags & EXT4_GET_BLOCKS_ZERO &&\n\t\t    map->m_flags & EXT4_MAP_MAPPED &&\n\t\t    map->m_flags & EXT4_MAP_NEW) {\n\t\t\tret = ext4_issue_zeroout(inode, map->m_lblk,\n\t\t\t\t\t\t map->m_pblk, map->m_len);\n\t\t\tif (ret) {\n\t\t\t\tretval = ret;\n\t\t\t\tgoto out_sem;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * If the extent has been zeroed out, we don't need to update\n\t\t * extent status tree.\n\t\t */\n\t\tif ((flags & EXT4_GET_BLOCKS_PRE_IO) &&\n\t\t    ext4_es_lookup_extent(inode, map->m_lblk, &es)) {\n\t\t\tif (ext4_es_is_written(&es))\n\t\t\t\tgoto out_sem;\n\t\t}\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tif (!(flags & EXT4_GET_BLOCKS_DELALLOC_RESERVE) &&\n\t\t    !(status & EXTENT_STATUS_WRITTEN) &&\n\t\t    ext4_find_delalloc_range(inode, map->m_lblk,\n\t\t\t\t\t     map->m_lblk + map->m_len - 1))\n\t\t\tstatus |= EXTENT_STATUS_DELAYED;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret < 0) {\n\t\t\tretval = ret;\n\t\t\tgoto out_sem;\n\t\t}\n\t}\n\nout_sem:\n\tup_write((&EXT4_I(inode)->i_data_sem));\n\tif (retval > 0 && map->m_flags & EXT4_MAP_MAPPED) {\n\t\tret = check_block_validity(inode, map);\n\t\tif (ret != 0)\n\t\t\treturn ret;\n\n\t\t/*\n\t\t * Inodes with freshly allocated blocks where contents will be\n\t\t * visible after transaction commit must be on transaction's\n\t\t * ordered data list.\n\t\t */\n\t\tif (map->m_flags & EXT4_MAP_NEW &&\n\t\t    !(map->m_flags & EXT4_MAP_UNWRITTEN) &&\n\t\t    !(flags & EXT4_GET_BLOCKS_ZERO) &&\n\t\t    !IS_NOQUOTA(inode) &&\n\t\t    ext4_should_order_data(inode)) {\n\t\t\tret = ext4_jbd2_file_inode(handle, inode);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t}\n\treturn retval;\n}\n\n/*\n * Update EXT4_MAP_FLAGS in bh->b_state. For buffer heads attached to pages\n * we have to be careful as someone else may be manipulating b_state as well.\n */\nstatic void ext4_update_bh_state(struct buffer_head *bh, unsigned long flags)\n{\n\tunsigned long old_state;\n\tunsigned long new_state;\n\n\tflags &= EXT4_MAP_FLAGS;\n\n\t/* Dummy buffer_head? Set non-atomically. */\n\tif (!bh->b_page) {\n\t\tbh->b_state = (bh->b_state & ~EXT4_MAP_FLAGS) | flags;\n\t\treturn;\n\t}\n\t/*\n\t * Someone else may be modifying b_state. Be careful! This is ugly but\n\t * once we get rid of using bh as a container for mapping information\n\t * to pass to / from get_block functions, this can go away.\n\t */\n\tdo {\n\t\told_state = READ_ONCE(bh->b_state);\n\t\tnew_state = (old_state & ~EXT4_MAP_FLAGS) | flags;\n\t} while (unlikely(\n\t\t cmpxchg(&bh->b_state, old_state, new_state) != old_state));\n}\n\nstatic int _ext4_get_block(struct inode *inode, sector_t iblock,\n\t\t\t   struct buffer_head *bh, int flags)\n{\n\tstruct ext4_map_blocks map;\n\tint ret = 0;\n\n\tif (ext4_has_inline_data(inode))\n\t\treturn -ERANGE;\n\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh->b_size >> inode->i_blkbits;\n\n\tret = ext4_map_blocks(ext4_journal_current_handle(), inode, &map,\n\t\t\t      flags);\n\tif (ret > 0) {\n\t\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\t\text4_update_bh_state(bh, map.m_flags);\n\t\tbh->b_size = inode->i_sb->s_blocksize * map.m_len;\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n\nint ext4_get_block(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh, int create)\n{\n\treturn _ext4_get_block(inode, iblock, bh,\n\t\t\t       create ? EXT4_GET_BLOCKS_CREATE : 0);\n}\n\n/*\n * Get block function used when preparing for buffered write if we require\n * creating an unwritten extent if blocks haven't been allocated.  The extent\n * will be converted to written after the IO is complete.\n */\nint ext4_get_block_unwritten(struct inode *inode, sector_t iblock,\n\t\t\t     struct buffer_head *bh_result, int create)\n{\n\text4_debug(\"ext4_get_block_unwritten: inode %lu, create flag %d\\n\",\n\t\t   inode->i_ino, create);\n\treturn _ext4_get_block(inode, iblock, bh_result,\n\t\t\t       EXT4_GET_BLOCKS_IO_CREATE_EXT);\n}\n\n/* Maximum number of blocks we map for direct IO at once. */\n#define DIO_MAX_BLOCKS 4096\n\n/*\n * Get blocks function for the cases that need to start a transaction -\n * generally difference cases of direct IO and DAX IO. It also handles retries\n * in case of ENOSPC.\n */\nstatic int ext4_get_block_trans(struct inode *inode, sector_t iblock,\n\t\t\t\tstruct buffer_head *bh_result, int flags)\n{\n\tint dio_credits;\n\thandle_t *handle;\n\tint retries = 0;\n\tint ret;\n\n\t/* Trim mapping request to maximum we can map at once for DIO */\n\tif (bh_result->b_size >> inode->i_blkbits > DIO_MAX_BLOCKS)\n\t\tbh_result->b_size = DIO_MAX_BLOCKS << inode->i_blkbits;\n\tdio_credits = ext4_chunk_trans_blocks(inode,\n\t\t\t\t      bh_result->b_size >> inode->i_blkbits);\nretry:\n\thandle = ext4_journal_start(inode, EXT4_HT_MAP_BLOCKS, dio_credits);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\tret = _ext4_get_block(inode, iblock, bh_result, flags);\n\text4_journal_stop(handle);\n\n\tif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry;\n\treturn ret;\n}\n\n/* Get block function for DIO reads and writes to inodes without extents */\nint ext4_dio_get_block(struct inode *inode, sector_t iblock,\n\t\t       struct buffer_head *bh, int create)\n{\n\t/* We don't expect handle for direct IO */\n\tWARN_ON_ONCE(ext4_journal_current_handle());\n\n\tif (!create)\n\t\treturn _ext4_get_block(inode, iblock, bh, 0);\n\treturn ext4_get_block_trans(inode, iblock, bh, EXT4_GET_BLOCKS_CREATE);\n}\n\n/*\n * Get block function for AIO DIO writes when we create unwritten extent if\n * blocks are not allocated yet. The extent will be converted to written\n * after IO is complete.\n */\nstatic int ext4_dio_get_block_unwritten_async(struct inode *inode,\n\t\tsector_t iblock, struct buffer_head *bh_result,\tint create)\n{\n\tint ret;\n\n\t/* We don't expect handle for direct IO */\n\tWARN_ON_ONCE(ext4_journal_current_handle());\n\n\tret = ext4_get_block_trans(inode, iblock, bh_result,\n\t\t\t\t   EXT4_GET_BLOCKS_IO_CREATE_EXT);\n\n\t/*\n\t * When doing DIO using unwritten extents, we need io_end to convert\n\t * unwritten extents to written on IO completion. We allocate io_end\n\t * once we spot unwritten extent and store it in b_private. Generic\n\t * DIO code keeps b_private set and furthermore passes the value to\n\t * our completion callback in 'private' argument.\n\t */\n\tif (!ret && buffer_unwritten(bh_result)) {\n\t\tif (!bh_result->b_private) {\n\t\t\text4_io_end_t *io_end;\n\n\t\t\tio_end = ext4_init_io_end(inode, GFP_KERNEL);\n\t\t\tif (!io_end)\n\t\t\t\treturn -ENOMEM;\n\t\t\tbh_result->b_private = io_end;\n\t\t\text4_set_io_unwritten_flag(inode, io_end);\n\t\t}\n\t\tset_buffer_defer_completion(bh_result);\n\t}\n\n\treturn ret;\n}\n\n/*\n * Get block function for non-AIO DIO writes when we create unwritten extent if\n * blocks are not allocated yet. The extent will be converted to written\n * after IO is complete from ext4_ext_direct_IO() function.\n */\nstatic int ext4_dio_get_block_unwritten_sync(struct inode *inode,\n\t\tsector_t iblock, struct buffer_head *bh_result,\tint create)\n{\n\tint ret;\n\n\t/* We don't expect handle for direct IO */\n\tWARN_ON_ONCE(ext4_journal_current_handle());\n\n\tret = ext4_get_block_trans(inode, iblock, bh_result,\n\t\t\t\t   EXT4_GET_BLOCKS_IO_CREATE_EXT);\n\n\t/*\n\t * Mark inode as having pending DIO writes to unwritten extents.\n\t * ext4_ext_direct_IO() checks this flag and converts extents to\n\t * written.\n\t */\n\tif (!ret && buffer_unwritten(bh_result))\n\t\text4_set_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);\n\n\treturn ret;\n}\n\nstatic int ext4_dio_get_block_overwrite(struct inode *inode, sector_t iblock,\n\t\t   struct buffer_head *bh_result, int create)\n{\n\tint ret;\n\n\text4_debug(\"ext4_dio_get_block_overwrite: inode %lu, create flag %d\\n\",\n\t\t   inode->i_ino, create);\n\t/* We don't expect handle for direct IO */\n\tWARN_ON_ONCE(ext4_journal_current_handle());\n\n\tret = _ext4_get_block(inode, iblock, bh_result, 0);\n\t/*\n\t * Blocks should have been preallocated! ext4_file_write_iter() checks\n\t * that.\n\t */\n\tWARN_ON_ONCE(!buffer_mapped(bh_result) || buffer_unwritten(bh_result));\n\n\treturn ret;\n}\n\n\n/*\n * `handle' can be NULL if create is zero\n */\nstruct buffer_head *ext4_getblk(handle_t *handle, struct inode *inode,\n\t\t\t\text4_lblk_t block, int map_flags)\n{\n\tstruct ext4_map_blocks map;\n\tstruct buffer_head *bh;\n\tint create = map_flags & EXT4_GET_BLOCKS_CREATE;\n\tint err;\n\n\tJ_ASSERT(handle != NULL || create == 0);\n\n\tmap.m_lblk = block;\n\tmap.m_len = 1;\n\terr = ext4_map_blocks(handle, inode, &map, map_flags);\n\n\tif (err == 0)\n\t\treturn create ? ERR_PTR(-ENOSPC) : NULL;\n\tif (err < 0)\n\t\treturn ERR_PTR(err);\n\n\tbh = sb_getblk(inode->i_sb, map.m_pblk);\n\tif (unlikely(!bh))\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (map.m_flags & EXT4_MAP_NEW) {\n\t\tJ_ASSERT(create != 0);\n\t\tJ_ASSERT(handle != NULL);\n\n\t\t/*\n\t\t * Now that we do not always journal data, we should\n\t\t * keep in mind whether this should always journal the\n\t\t * new buffer as metadata.  For now, regular file\n\t\t * writes use ext4_get_block instead, so it's not a\n\t\t * problem.\n\t\t */\n\t\tlock_buffer(bh);\n\t\tBUFFER_TRACE(bh, \"call get_create_access\");\n\t\terr = ext4_journal_get_create_access(handle, bh);\n\t\tif (unlikely(err)) {\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto errout;\n\t\t}\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tmemset(bh->b_data, 0, inode->i_sb->s_blocksize);\n\t\t\tset_buffer_uptodate(bh);\n\t\t}\n\t\tunlock_buffer(bh);\n\t\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\t\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\t\tif (unlikely(err))\n\t\t\tgoto errout;\n\t} else\n\t\tBUFFER_TRACE(bh, \"not a new buffer\");\n\treturn bh;\nerrout:\n\tbrelse(bh);\n\treturn ERR_PTR(err);\n}\n\nstruct buffer_head *ext4_bread(handle_t *handle, struct inode *inode,\n\t\t\t       ext4_lblk_t block, int map_flags)\n{\n\tstruct buffer_head *bh;\n\n\tbh = ext4_getblk(handle, inode, block, map_flags);\n\tif (IS_ERR(bh))\n\t\treturn bh;\n\tif (!bh || buffer_uptodate(bh))\n\t\treturn bh;\n\tll_rw_block(READ | REQ_META | REQ_PRIO, 1, &bh);\n\twait_on_buffer(bh);\n\tif (buffer_uptodate(bh))\n\t\treturn bh;\n\tput_bh(bh);\n\treturn ERR_PTR(-EIO);\n}\n\nint ext4_walk_page_buffers(handle_t *handle,\n\t\t\t   struct buffer_head *head,\n\t\t\t   unsigned from,\n\t\t\t   unsigned to,\n\t\t\t   int *partial,\n\t\t\t   int (*fn)(handle_t *handle,\n\t\t\t\t     struct buffer_head *bh))\n{\n\tstruct buffer_head *bh;\n\tunsigned block_start, block_end;\n\tunsigned blocksize = head->b_size;\n\tint err, ret = 0;\n\tstruct buffer_head *next;\n\n\tfor (bh = head, block_start = 0;\n\t     ret == 0 && (bh != head || !block_start);\n\t     block_start = block_end, bh = next) {\n\t\tnext = bh->b_this_page;\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (partial && !buffer_uptodate(bh))\n\t\t\t\t*partial = 1;\n\t\t\tcontinue;\n\t\t}\n\t\terr = (*fn)(handle, bh);\n\t\tif (!ret)\n\t\t\tret = err;\n\t}\n\treturn ret;\n}\n\n/*\n * To preserve ordering, it is essential that the hole instantiation and\n * the data write be encapsulated in a single transaction.  We cannot\n * close off a transaction and start a new one between the ext4_get_block()\n * and the commit_write().  So doing the jbd2_journal_start at the start of\n * prepare_write() is the right place.\n *\n * Also, this function can nest inside ext4_writepage().  In that case, we\n * *know* that ext4_writepage() has generated enough buffer credits to do the\n * whole page.  So we won't block on the journal in that case, which is good,\n * because the caller may be PF_MEMALLOC.\n *\n * By accident, ext4 can be reentered when a transaction is open via\n * quota file writes.  If we were to commit the transaction while thus\n * reentered, there can be a deadlock - we would be holding a quota\n * lock, and the commit would never complete if another thread had a\n * transaction open and was blocking on the quota lock - a ranking\n * violation.\n *\n * So what we do is to rely on the fact that jbd2_journal_stop/journal_start\n * will _not_ run commit under these circumstances because handle->h_ref\n * is elevated.  We'll still have enough credits for the tiny quotafile\n * write.\n */\nint do_journal_get_write_access(handle_t *handle,\n\t\t\t\tstruct buffer_head *bh)\n{\n\tint dirty = buffer_dirty(bh);\n\tint ret;\n\n\tif (!buffer_mapped(bh) || buffer_freed(bh))\n\t\treturn 0;\n\t/*\n\t * __block_write_begin() could have dirtied some buffers. Clean\n\t * the dirty bit as jbd2_journal_get_write_access() could complain\n\t * otherwise about fs integrity issues. Setting of the dirty bit\n\t * by __block_write_begin() isn't a real problem here as we clear\n\t * the bit before releasing a page lock and thus writeback cannot\n\t * ever write the buffer.\n\t */\n\tif (dirty)\n\t\tclear_buffer_dirty(bh);\n\tBUFFER_TRACE(bh, \"get write access\");\n\tret = ext4_journal_get_write_access(handle, bh);\n\tif (!ret && dirty)\n\t\tret = ext4_handle_dirty_metadata(handle, NULL, bh);\n\treturn ret;\n}\n\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\nstatic int ext4_block_write_begin(struct page *page, loff_t pos, unsigned len,\n\t\t\t\t  get_block_t *get_block)\n{\n\tunsigned from = pos & (PAGE_SIZE - 1);\n\tunsigned to = from + len;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned block_start, block_end;\n\tsector_t block;\n\tint err = 0;\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\tunsigned bbits;\n\tstruct buffer_head *bh, *head, *wait[2], **wait_bh = wait;\n\tbool decrypt = false;\n\n\tBUG_ON(!PageLocked(page));\n\tBUG_ON(from > PAGE_SIZE);\n\tBUG_ON(to > PAGE_SIZE);\n\tBUG_ON(from > to);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\thead = page_buffers(page);\n\tbbits = ilog2(blocksize);\n\tblock = (sector_t)page->index << (PAGE_SHIFT - bbits);\n\n\tfor (bh = head, block_start = 0; bh != head || !block_start;\n\t    block++, block_start = block_end, bh = bh->b_this_page) {\n\t\tblock_end = block_start + blocksize;\n\t\tif (block_end <= from || block_start >= to) {\n\t\t\tif (PageUptodate(page)) {\n\t\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (buffer_new(bh))\n\t\t\tclear_buffer_new(bh);\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tWARN_ON(bh->b_size != blocksize);\n\t\t\terr = get_block(inode, block, bh, 1);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (buffer_new(bh)) {\n\t\t\t\tunmap_underlying_metadata(bh->b_bdev,\n\t\t\t\t\t\t\t  bh->b_blocknr);\n\t\t\t\tif (PageUptodate(page)) {\n\t\t\t\t\tclear_buffer_new(bh);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t\tmark_buffer_dirty(bh);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (block_end > to || block_start < from)\n\t\t\t\t\tzero_user_segments(page, to, block_end,\n\t\t\t\t\t\t\t   block_start, from);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (PageUptodate(page)) {\n\t\t\tif (!buffer_uptodate(bh))\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\tcontinue;\n\t\t}\n\t\tif (!buffer_uptodate(bh) && !buffer_delay(bh) &&\n\t\t    !buffer_unwritten(bh) &&\n\t\t    (block_start < from || block_end > to)) {\n\t\t\tll_rw_block(READ, 1, &bh);\n\t\t\t*wait_bh++ = bh;\n\t\t\tdecrypt = ext4_encrypted_inode(inode) &&\n\t\t\t\tS_ISREG(inode->i_mode);\n\t\t}\n\t}\n\t/*\n\t * If we issued read requests, let them complete.\n\t */\n\twhile (wait_bh > wait) {\n\t\twait_on_buffer(*--wait_bh);\n\t\tif (!buffer_uptodate(*wait_bh))\n\t\t\terr = -EIO;\n\t}\n\tif (unlikely(err))\n\t\tpage_zero_new_buffers(page, from, to);\n\telse if (decrypt)\n\t\terr = ext4_decrypt(page);\n\treturn err;\n}\n#endif\n\nstatic int ext4_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t    loff_t pos, unsigned len, unsigned flags,\n\t\t\t    struct page **pagep, void **fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint ret, needed_blocks;\n\thandle_t *handle;\n\tint retries = 0;\n\tstruct page *page;\n\tpgoff_t index;\n\tunsigned from, to;\n\n\ttrace_ext4_write_begin(inode, pos, len, flags);\n\t/*\n\t * Reserve one block more for addition to orphan list in case\n\t * we allocate blocks but write fails for some reason\n\t */\n\tneeded_blocks = ext4_writepage_trans_blocks(inode) + 1;\n\tindex = pos >> PAGE_SHIFT;\n\tfrom = pos & (PAGE_SIZE - 1);\n\tto = from + len;\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA)) {\n\t\tret = ext4_try_to_write_inline_data(mapping, inode, pos, len,\n\t\t\t\t\t\t    flags, pagep);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 1)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * grab_cache_page_write_begin() can take a long time if the\n\t * system is thrashing due to memory pressure, or if the page\n\t * is being written back.  So grab it first before we start\n\t * the transaction handle.  This also allows us to allocate\n\t * the page (if needed) without using GFP_NOFS.\n\t */\nretry_grab:\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tunlock_page(page);\n\nretry_journal:\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE, needed_blocks);\n\tif (IS_ERR(handle)) {\n\t\tput_page(page);\n\t\treturn PTR_ERR(handle);\n\t}\n\n\tlock_page(page);\n\tif (page->mapping != mapping) {\n\t\t/* The page got truncated from under us */\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\text4_journal_stop(handle);\n\t\tgoto retry_grab;\n\t}\n\t/* In case writeback began while the page was unlocked */\n\twait_for_stable_page(page);\n\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tif (ext4_should_dioread_nolock(inode))\n\t\tret = ext4_block_write_begin(page, pos, len,\n\t\t\t\t\t     ext4_get_block_unwritten);\n\telse\n\t\tret = ext4_block_write_begin(page, pos, len,\n\t\t\t\t\t     ext4_get_block);\n#else\n\tif (ext4_should_dioread_nolock(inode))\n\t\tret = __block_write_begin(page, pos, len,\n\t\t\t\t\t  ext4_get_block_unwritten);\n\telse\n\t\tret = __block_write_begin(page, pos, len, ext4_get_block);\n#endif\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tret = ext4_walk_page_buffers(handle, page_buffers(page),\n\t\t\t\t\t     from, to, NULL,\n\t\t\t\t\t     do_journal_get_write_access);\n\t}\n\n\tif (ret) {\n\t\tunlock_page(page);\n\t\t/*\n\t\t * __block_write_begin may have instantiated a few blocks\n\t\t * outside i_size.  Trim these off again. Don't need\n\t\t * i_size_read because we hold i_mutex.\n\t\t *\n\t\t * Add inode to orphan list in case we crash before\n\t\t * truncate finishes\n\t\t */\n\t\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\t\text4_orphan_add(handle, inode);\n\n\t\text4_journal_stop(handle);\n\t\tif (pos + len > inode->i_size) {\n\t\t\text4_truncate_failed_write(inode);\n\t\t\t/*\n\t\t\t * If truncate failed early the inode might\n\t\t\t * still be on the orphan list; we need to\n\t\t\t * make sure the inode is removed from the\n\t\t\t * orphan list in that case.\n\t\t\t */\n\t\t\tif (inode->i_nlink)\n\t\t\t\text4_orphan_del(NULL, inode);\n\t\t}\n\n\t\tif (ret == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\t\tgoto retry_journal;\n\t\tput_page(page);\n\t\treturn ret;\n\t}\n\t*pagep = page;\n\treturn ret;\n}\n\n/* For write_end() in data=journal mode */\nstatic int write_end_fn(handle_t *handle, struct buffer_head *bh)\n{\n\tint ret;\n\tif (!buffer_mapped(bh) || buffer_freed(bh))\n\t\treturn 0;\n\tset_buffer_uptodate(bh);\n\tret = ext4_handle_dirty_metadata(handle, NULL, bh);\n\tclear_buffer_meta(bh);\n\tclear_buffer_prio(bh);\n\treturn ret;\n}\n\n/*\n * We need to pick up the new inode size which generic_commit_write gave us\n * `file' can be NULL - eg, when called from page_symlink().\n *\n * ext4 never places buffers on inode->i_mapping->private_list.  metadata\n * buffers are managed internally.\n */\nstatic int ext4_write_end(struct file *file,\n\t\t\t  struct address_space *mapping,\n\t\t\t  loff_t pos, unsigned len, unsigned copied,\n\t\t\t  struct page *page, void *fsdata)\n{\n\thandle_t *handle = ext4_journal_current_handle();\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint ret = 0, ret2;\n\tint i_size_changed = 0;\n\n\ttrace_ext4_write_end(inode, pos, len, copied);\n\tif (ext4_has_inline_data(inode)) {\n\t\tret = ext4_write_inline_data_end(inode, pos, len,\n\t\t\t\t\t\t copied, page);\n\t\tif (ret < 0)\n\t\t\tgoto errout;\n\t\tcopied = ret;\n\t} else\n\t\tcopied = block_write_end(file, mapping, pos,\n\t\t\t\t\t len, copied, page, fsdata);\n\t/*\n\t * it's important to update i_size while still holding page lock:\n\t * page writeout could otherwise come in and zero beyond i_size.\n\t */\n\ti_size_changed = ext4_update_inode_size(inode, pos + copied);\n\tunlock_page(page);\n\tput_page(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\t/*\n\t * Don't mark the inode dirty under page lock. First, it unnecessarily\n\t * makes the holding time of page lock longer. Second, it forces lock\n\t * ordering of page lock and transaction start for journaling\n\t * filesystems.\n\t */\n\tif (i_size_changed)\n\t\text4_mark_inode_dirty(handle, inode);\n\n\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\t/* if we have allocated more blocks and copied\n\t\t * less. We will have blocks allocated outside\n\t\t * inode->i_size. So truncate them\n\t\t */\n\t\text4_orphan_add(handle, inode);\nerrout:\n\tret2 = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = ret2;\n\n\tif (pos + len > inode->i_size) {\n\t\text4_truncate_failed_write(inode);\n\t\t/*\n\t\t * If truncate failed early the inode might still be\n\t\t * on the orphan list; we need to make sure the inode\n\t\t * is removed from the orphan list in that case.\n\t\t */\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\n\treturn ret ? ret : copied;\n}\n\n/*\n * This is a private version of page_zero_new_buffers() which doesn't\n * set the buffer to be dirty, since in data=journalled mode we need\n * to call ext4_handle_dirty_metadata() instead.\n */\nstatic void zero_new_buffers(struct page *page, unsigned from, unsigned to)\n{\n\tunsigned int block_start = 0, block_end;\n\tstruct buffer_head *head, *bh;\n\n\tbh = head = page_buffers(page);\n\tdo {\n\t\tblock_end = block_start + bh->b_size;\n\t\tif (buffer_new(bh)) {\n\t\t\tif (block_end > from && block_start < to) {\n\t\t\t\tif (!PageUptodate(page)) {\n\t\t\t\t\tunsigned start, size;\n\n\t\t\t\t\tstart = max(from, block_start);\n\t\t\t\t\tsize = min(to, block_end) - start;\n\n\t\t\t\t\tzero_user(page, start, size);\n\t\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\t}\n\t\t\t\tclear_buffer_new(bh);\n\t\t\t}\n\t\t}\n\t\tblock_start = block_end;\n\t\tbh = bh->b_this_page;\n\t} while (bh != head);\n}\n\nstatic int ext4_journalled_write_end(struct file *file,\n\t\t\t\t     struct address_space *mapping,\n\t\t\t\t     loff_t pos, unsigned len, unsigned copied,\n\t\t\t\t     struct page *page, void *fsdata)\n{\n\thandle_t *handle = ext4_journal_current_handle();\n\tstruct inode *inode = mapping->host;\n\tloff_t old_size = inode->i_size;\n\tint ret = 0, ret2;\n\tint partial = 0;\n\tunsigned from, to;\n\tint size_changed = 0;\n\n\ttrace_ext4_journalled_write_end(inode, pos, len, copied);\n\tfrom = pos & (PAGE_SIZE - 1);\n\tto = from + len;\n\n\tBUG_ON(!ext4_handle_valid(handle));\n\n\tif (ext4_has_inline_data(inode))\n\t\tcopied = ext4_write_inline_data_end(inode, pos, len,\n\t\t\t\t\t\t    copied, page);\n\telse {\n\t\tif (copied < len) {\n\t\t\tif (!PageUptodate(page))\n\t\t\t\tcopied = 0;\n\t\t\tzero_new_buffers(page, from+copied, to);\n\t\t}\n\n\t\tret = ext4_walk_page_buffers(handle, page_buffers(page), from,\n\t\t\t\t\t     to, &partial, write_end_fn);\n\t\tif (!partial)\n\t\t\tSetPageUptodate(page);\n\t}\n\tsize_changed = ext4_update_inode_size(inode, pos + copied);\n\text4_set_inode_state(inode, EXT4_STATE_JDATA);\n\tEXT4_I(inode)->i_datasync_tid = handle->h_transaction->t_tid;\n\tunlock_page(page);\n\tput_page(page);\n\n\tif (old_size < pos)\n\t\tpagecache_isize_extended(inode, old_size, pos);\n\n\tif (size_changed) {\n\t\tret2 = ext4_mark_inode_dirty(handle, inode);\n\t\tif (!ret)\n\t\t\tret = ret2;\n\t}\n\n\tif (pos + len > inode->i_size && ext4_can_truncate(inode))\n\t\t/* if we have allocated more blocks and copied\n\t\t * less. We will have blocks allocated outside\n\t\t * inode->i_size. So truncate them\n\t\t */\n\t\text4_orphan_add(handle, inode);\n\n\tret2 = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = ret2;\n\tif (pos + len > inode->i_size) {\n\t\text4_truncate_failed_write(inode);\n\t\t/*\n\t\t * If truncate failed early the inode might still be\n\t\t * on the orphan list; we need to make sure the inode\n\t\t * is removed from the orphan list in that case.\n\t\t */\n\t\tif (inode->i_nlink)\n\t\t\text4_orphan_del(NULL, inode);\n\t}\n\n\treturn ret ? ret : copied;\n}\n\n/*\n * Reserve space for a single cluster\n */\nstatic int ext4_da_reserve_space(struct inode *inode)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tint ret;\n\n\t/*\n\t * We will charge metadata quota at writeout time; this saves\n\t * us from metadata over-estimation, though we may go over by\n\t * a small amount in the end.  Here we just reserve for data.\n\t */\n\tret = dquot_reserve_block(inode, EXT4_C2B(sbi, 1));\n\tif (ret)\n\t\treturn ret;\n\n\tspin_lock(&ei->i_block_reservation_lock);\n\tif (ext4_claim_free_clusters(sbi, 1, 0)) {\n\t\tspin_unlock(&ei->i_block_reservation_lock);\n\t\tdquot_release_reservation_block(inode, EXT4_C2B(sbi, 1));\n\t\treturn -ENOSPC;\n\t}\n\tei->i_reserved_data_blocks++;\n\ttrace_ext4_da_reserve_space(inode);\n\tspin_unlock(&ei->i_block_reservation_lock);\n\n\treturn 0;       /* success */\n}\n\nstatic void ext4_da_release_space(struct inode *inode, int to_free)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\tif (!to_free)\n\t\treturn;\t\t/* Nothing to release, exit */\n\n\tspin_lock(&EXT4_I(inode)->i_block_reservation_lock);\n\n\ttrace_ext4_da_release_space(inode, to_free);\n\tif (unlikely(to_free > ei->i_reserved_data_blocks)) {\n\t\t/*\n\t\t * if there aren't enough reserved blocks, then the\n\t\t * counter is messed up somewhere.  Since this\n\t\t * function is called from invalidate page, it's\n\t\t * harmless to return without any action.\n\t\t */\n\t\text4_warning(inode->i_sb, \"ext4_da_release_space: \"\n\t\t\t \"ino %lu, to_free %d with only %d reserved \"\n\t\t\t \"data blocks\", inode->i_ino, to_free,\n\t\t\t ei->i_reserved_data_blocks);\n\t\tWARN_ON(1);\n\t\tto_free = ei->i_reserved_data_blocks;\n\t}\n\tei->i_reserved_data_blocks -= to_free;\n\n\t/* update fs dirty data blocks counter */\n\tpercpu_counter_sub(&sbi->s_dirtyclusters_counter, to_free);\n\n\tspin_unlock(&EXT4_I(inode)->i_block_reservation_lock);\n\n\tdquot_release_reservation_block(inode, EXT4_C2B(sbi, to_free));\n}\n\nstatic void ext4_da_page_release_reservation(struct page *page,\n\t\t\t\t\t     unsigned int offset,\n\t\t\t\t\t     unsigned int length)\n{\n\tint to_release = 0, contiguous_blks = 0;\n\tstruct buffer_head *head, *bh;\n\tunsigned int curr_off = 0;\n\tstruct inode *inode = page->mapping->host;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tunsigned int stop = offset + length;\n\tint num_clusters;\n\text4_fsblk_t lblk;\n\n\tBUG_ON(stop > PAGE_SIZE || stop < length);\n\n\thead = page_buffers(page);\n\tbh = head;\n\tdo {\n\t\tunsigned int next_off = curr_off + bh->b_size;\n\n\t\tif (next_off > stop)\n\t\t\tbreak;\n\n\t\tif ((offset <= curr_off) && (buffer_delay(bh))) {\n\t\t\tto_release++;\n\t\t\tcontiguous_blks++;\n\t\t\tclear_buffer_delay(bh);\n\t\t} else if (contiguous_blks) {\n\t\t\tlblk = page->index <<\n\t\t\t       (PAGE_SHIFT - inode->i_blkbits);\n\t\t\tlblk += (curr_off >> inode->i_blkbits) -\n\t\t\t\tcontiguous_blks;\n\t\t\text4_es_remove_extent(inode, lblk, contiguous_blks);\n\t\t\tcontiguous_blks = 0;\n\t\t}\n\t\tcurr_off = next_off;\n\t} while ((bh = bh->b_this_page) != head);\n\n\tif (contiguous_blks) {\n\t\tlblk = page->index << (PAGE_SHIFT - inode->i_blkbits);\n\t\tlblk += (curr_off >> inode->i_blkbits) - contiguous_blks;\n\t\text4_es_remove_extent(inode, lblk, contiguous_blks);\n\t}\n\n\t/* If we have released all the blocks belonging to a cluster, then we\n\t * need to release the reserved space for that cluster. */\n\tnum_clusters = EXT4_NUM_B2C(sbi, to_release);\n\twhile (num_clusters > 0) {\n\t\tlblk = (page->index << (PAGE_SHIFT - inode->i_blkbits)) +\n\t\t\t((num_clusters - 1) << sbi->s_cluster_bits);\n\t\tif (sbi->s_cluster_ratio == 1 ||\n\t\t    !ext4_find_delalloc_cluster(inode, lblk))\n\t\t\text4_da_release_space(inode, 1);\n\n\t\tnum_clusters--;\n\t}\n}\n\n/*\n * Delayed allocation stuff\n */\n\nstruct mpage_da_data {\n\tstruct inode *inode;\n\tstruct writeback_control *wbc;\n\n\tpgoff_t first_page;\t/* The first page to write */\n\tpgoff_t next_page;\t/* Current page to examine */\n\tpgoff_t last_page;\t/* Last page to examine */\n\t/*\n\t * Extent to map - this can be after first_page because that can be\n\t * fully mapped. We somewhat abuse m_flags to store whether the extent\n\t * is delalloc or unwritten.\n\t */\n\tstruct ext4_map_blocks map;\n\tstruct ext4_io_submit io_submit;\t/* IO submission data */\n};\n\nstatic void mpage_release_unused_pages(struct mpage_da_data *mpd,\n\t\t\t\t       bool invalidate)\n{\n\tint nr_pages, i;\n\tpgoff_t index, end;\n\tstruct pagevec pvec;\n\tstruct inode *inode = mpd->inode;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\t/* This is necessary when next_page == 0. */\n\tif (mpd->first_page >= mpd->next_page)\n\t\treturn;\n\n\tindex = mpd->first_page;\n\tend   = mpd->next_page - 1;\n\tif (invalidate) {\n\t\text4_lblk_t start, last;\n\t\tstart = index << (PAGE_SHIFT - inode->i_blkbits);\n\t\tlast = end << (PAGE_SHIFT - inode->i_blkbits);\n\t\text4_es_remove_extent(inode, start, last - start + 1);\n\t}\n\n\tpagevec_init(&pvec, 0);\n\twhile (index <= end) {\n\t\tnr_pages = pagevec_lookup(&pvec, mapping, index, PAGEVEC_SIZE);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\t\t\tif (page->index > end)\n\t\t\t\tbreak;\n\t\t\tBUG_ON(!PageLocked(page));\n\t\t\tBUG_ON(PageWriteback(page));\n\t\t\tif (invalidate) {\n\t\t\t\tblock_invalidatepage(page, 0, PAGE_SIZE);\n\t\t\t\tClearPageUptodate(page);\n\t\t\t}\n\t\t\tunlock_page(page);\n\t\t}\n\t\tindex = pvec.pages[nr_pages - 1]->index + 1;\n\t\tpagevec_release(&pvec);\n\t}\n}\n\nstatic void ext4_print_free_blocks(struct inode *inode)\n{\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstruct super_block *sb = inode->i_sb;\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\n\text4_msg(sb, KERN_CRIT, \"Total free blocks count %lld\",\n\t       EXT4_C2B(EXT4_SB(inode->i_sb),\n\t\t\text4_count_free_clusters(sb)));\n\text4_msg(sb, KERN_CRIT, \"Free/Dirty block details\");\n\text4_msg(sb, KERN_CRIT, \"free_blocks=%lld\",\n\t       (long long) EXT4_C2B(EXT4_SB(sb),\n\t\tpercpu_counter_sum(&sbi->s_freeclusters_counter)));\n\text4_msg(sb, KERN_CRIT, \"dirty_blocks=%lld\",\n\t       (long long) EXT4_C2B(EXT4_SB(sb),\n\t\tpercpu_counter_sum(&sbi->s_dirtyclusters_counter)));\n\text4_msg(sb, KERN_CRIT, \"Block reservation details\");\n\text4_msg(sb, KERN_CRIT, \"i_reserved_data_blocks=%u\",\n\t\t ei->i_reserved_data_blocks);\n\treturn;\n}\n\nstatic int ext4_bh_delay_or_unwritten(handle_t *handle, struct buffer_head *bh)\n{\n\treturn (buffer_delay(bh) || buffer_unwritten(bh)) && buffer_dirty(bh);\n}\n\n/*\n * This function is grabs code from the very beginning of\n * ext4_map_blocks, but assumes that the caller is from delayed write\n * time. This function looks up the requested blocks and sets the\n * buffer delay bit under the protection of i_data_sem.\n */\nstatic int ext4_da_map_blocks(struct inode *inode, sector_t iblock,\n\t\t\t      struct ext4_map_blocks *map,\n\t\t\t      struct buffer_head *bh)\n{\n\tstruct extent_status es;\n\tint retval;\n\tsector_t invalid_block = ~((sector_t) 0xffff);\n#ifdef ES_AGGRESSIVE_TEST\n\tstruct ext4_map_blocks orig_map;\n\n\tmemcpy(&orig_map, map, sizeof(*map));\n#endif\n\n\tif (invalid_block < ext4_blocks_count(EXT4_SB(inode->i_sb)->s_es))\n\t\tinvalid_block = ~0;\n\n\tmap->m_flags = 0;\n\text_debug(\"ext4_da_map_blocks(): inode %lu, max_blocks %u,\"\n\t\t  \"logical block %lu\\n\", inode->i_ino, map->m_len,\n\t\t  (unsigned long) map->m_lblk);\n\n\t/* Lookup extent status tree firstly */\n\tif (ext4_es_lookup_extent(inode, iblock, &es)) {\n\t\tif (ext4_es_is_hole(&es)) {\n\t\t\tretval = 0;\n\t\t\tdown_read(&EXT4_I(inode)->i_data_sem);\n\t\t\tgoto add_delayed;\n\t\t}\n\n\t\t/*\n\t\t * Delayed extent could be allocated by fallocate.\n\t\t * So we need to check it.\n\t\t */\n\t\tif (ext4_es_is_delayed(&es) && !ext4_es_is_unwritten(&es)) {\n\t\t\tmap_bh(bh, inode->i_sb, invalid_block);\n\t\t\tset_buffer_new(bh);\n\t\t\tset_buffer_delay(bh);\n\t\t\treturn 0;\n\t\t}\n\n\t\tmap->m_pblk = ext4_es_pblock(&es) + iblock - es.es_lblk;\n\t\tretval = es.es_len - (iblock - es.es_lblk);\n\t\tif (retval > map->m_len)\n\t\t\tretval = map->m_len;\n\t\tmap->m_len = retval;\n\t\tif (ext4_es_is_written(&es))\n\t\t\tmap->m_flags |= EXT4_MAP_MAPPED;\n\t\telse if (ext4_es_is_unwritten(&es))\n\t\t\tmap->m_flags |= EXT4_MAP_UNWRITTEN;\n\t\telse\n\t\t\tBUG_ON(1);\n\n#ifdef ES_AGGRESSIVE_TEST\n\t\text4_map_blocks_es_recheck(NULL, inode, map, &orig_map, 0);\n#endif\n\t\treturn retval;\n\t}\n\n\t/*\n\t * Try to see if we can get the block without requesting a new\n\t * file system block.\n\t */\n\tdown_read(&EXT4_I(inode)->i_data_sem);\n\tif (ext4_has_inline_data(inode))\n\t\tretval = 0;\n\telse if (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tretval = ext4_ext_map_blocks(NULL, inode, map, 0);\n\telse\n\t\tretval = ext4_ind_map_blocks(NULL, inode, map, 0);\n\nadd_delayed:\n\tif (retval == 0) {\n\t\tint ret;\n\t\t/*\n\t\t * XXX: __block_prepare_write() unmaps passed block,\n\t\t * is it OK?\n\t\t */\n\t\t/*\n\t\t * If the block was allocated from previously allocated cluster,\n\t\t * then we don't need to reserve it again. However we still need\n\t\t * to reserve metadata for every block we're going to write.\n\t\t */\n\t\tif (EXT4_SB(inode->i_sb)->s_cluster_ratio == 1 ||\n\t\t    !ext4_find_delalloc_cluster(inode, map->m_lblk)) {\n\t\t\tret = ext4_da_reserve_space(inode);\n\t\t\tif (ret) {\n\t\t\t\t/* not enough space to reserve */\n\t\t\t\tretval = ret;\n\t\t\t\tgoto out_unlock;\n\t\t\t}\n\t\t}\n\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    ~0, EXTENT_STATUS_DELAYED);\n\t\tif (ret) {\n\t\t\tretval = ret;\n\t\t\tgoto out_unlock;\n\t\t}\n\n\t\tmap_bh(bh, inode->i_sb, invalid_block);\n\t\tset_buffer_new(bh);\n\t\tset_buffer_delay(bh);\n\t} else if (retval > 0) {\n\t\tint ret;\n\t\tunsigned int status;\n\n\t\tif (unlikely(retval != map->m_len)) {\n\t\t\text4_warning(inode->i_sb,\n\t\t\t\t     \"ES len assertion failed for inode \"\n\t\t\t\t     \"%lu: retval %d != map->m_len %d\",\n\t\t\t\t     inode->i_ino, retval, map->m_len);\n\t\t\tWARN_ON(1);\n\t\t}\n\n\t\tstatus = map->m_flags & EXT4_MAP_UNWRITTEN ?\n\t\t\t\tEXTENT_STATUS_UNWRITTEN : EXTENT_STATUS_WRITTEN;\n\t\tret = ext4_es_insert_extent(inode, map->m_lblk, map->m_len,\n\t\t\t\t\t    map->m_pblk, status);\n\t\tif (ret != 0)\n\t\t\tretval = ret;\n\t}\n\nout_unlock:\n\tup_read((&EXT4_I(inode)->i_data_sem));\n\n\treturn retval;\n}\n\n/*\n * This is a special get_block_t callback which is used by\n * ext4_da_write_begin().  It will either return mapped block or\n * reserve space for a single block.\n *\n * For delayed buffer_head we have BH_Mapped, BH_New, BH_Delay set.\n * We also have b_blocknr = -1 and b_bdev initialized properly\n *\n * For unwritten buffer_head we have BH_Mapped, BH_New, BH_Unwritten set.\n * We also have b_blocknr = physicalblock mapping unwritten extent and b_bdev\n * initialized properly.\n */\nint ext4_da_get_block_prep(struct inode *inode, sector_t iblock,\n\t\t\t   struct buffer_head *bh, int create)\n{\n\tstruct ext4_map_blocks map;\n\tint ret = 0;\n\n\tBUG_ON(create == 0);\n\tBUG_ON(bh->b_size != inode->i_sb->s_blocksize);\n\n\tmap.m_lblk = iblock;\n\tmap.m_len = 1;\n\n\t/*\n\t * first, we need to know whether the block is allocated already\n\t * preallocated blocks are unmapped but should treated\n\t * the same as allocated blocks.\n\t */\n\tret = ext4_da_map_blocks(inode, iblock, &map, bh);\n\tif (ret <= 0)\n\t\treturn ret;\n\n\tmap_bh(bh, inode->i_sb, map.m_pblk);\n\text4_update_bh_state(bh, map.m_flags);\n\n\tif (buffer_unwritten(bh)) {\n\t\t/* A delayed write to unwritten bh should be marked\n\t\t * new and mapped.  Mapped ensures that we don't do\n\t\t * get_block multiple times when we write to the same\n\t\t * offset and new ensures that we do proper zero out\n\t\t * for partial write.\n\t\t */\n\t\tset_buffer_new(bh);\n\t\tset_buffer_mapped(bh);\n\t}\n\treturn 0;\n}\n\nstatic int bget_one(handle_t *handle, struct buffer_head *bh)\n{\n\tget_bh(bh);\n\treturn 0;\n}\n\nstatic int bput_one(handle_t *handle, struct buffer_head *bh)\n{\n\tput_bh(bh);\n\treturn 0;\n}\n\nstatic int __ext4_journalled_writepage(struct page *page,\n\t\t\t\t       unsigned int len)\n{\n\tstruct address_space *mapping = page->mapping;\n\tstruct inode *inode = mapping->host;\n\tstruct buffer_head *page_bufs = NULL;\n\thandle_t *handle = NULL;\n\tint ret = 0, err = 0;\n\tint inline_data = ext4_has_inline_data(inode);\n\tstruct buffer_head *inode_bh = NULL;\n\n\tClearPageChecked(page);\n\n\tif (inline_data) {\n\t\tBUG_ON(page->index != 0);\n\t\tBUG_ON(len > ext4_get_max_inline_size(inode));\n\t\tinode_bh = ext4_journalled_write_inline_data(inode, len, page);\n\t\tif (inode_bh == NULL)\n\t\t\tgoto out;\n\t} else {\n\t\tpage_bufs = page_buffers(page);\n\t\tif (!page_bufs) {\n\t\t\tBUG();\n\t\t\tgoto out;\n\t\t}\n\t\text4_walk_page_buffers(handle, page_bufs, 0, len,\n\t\t\t\t       NULL, bget_one);\n\t}\n\t/*\n\t * We need to release the page lock before we start the\n\t * journal, so grab a reference so the page won't disappear\n\t * out from under us.\n\t */\n\tget_page(page);\n\tunlock_page(page);\n\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE,\n\t\t\t\t    ext4_writepage_trans_blocks(inode));\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\tput_page(page);\n\t\tgoto out_no_pagelock;\n\t}\n\tBUG_ON(!ext4_handle_valid(handle));\n\n\tlock_page(page);\n\tput_page(page);\n\tif (page->mapping != mapping) {\n\t\t/* The page got truncated from under us */\n\t\text4_journal_stop(handle);\n\t\tret = 0;\n\t\tgoto out;\n\t}\n\n\tif (inline_data) {\n\t\tBUFFER_TRACE(inode_bh, \"get write access\");\n\t\tret = ext4_journal_get_write_access(handle, inode_bh);\n\n\t\terr = ext4_handle_dirty_metadata(handle, inode, inode_bh);\n\n\t} else {\n\t\tret = ext4_walk_page_buffers(handle, page_bufs, 0, len, NULL,\n\t\t\t\t\t     do_journal_get_write_access);\n\n\t\terr = ext4_walk_page_buffers(handle, page_bufs, 0, len, NULL,\n\t\t\t\t\t     write_end_fn);\n\t}\n\tif (ret == 0)\n\t\tret = err;\n\tEXT4_I(inode)->i_datasync_tid = handle->h_transaction->t_tid;\n\terr = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = err;\n\n\tif (!ext4_has_inline_data(inode))\n\t\text4_walk_page_buffers(NULL, page_bufs, 0, len,\n\t\t\t\t       NULL, bput_one);\n\text4_set_inode_state(inode, EXT4_STATE_JDATA);\nout:\n\tunlock_page(page);\nout_no_pagelock:\n\tbrelse(inode_bh);\n\treturn ret;\n}\n\n/*\n * Note that we don't need to start a transaction unless we're journaling data\n * because we should have holes filled from ext4_page_mkwrite(). We even don't\n * need to file the inode to the transaction's list in ordered mode because if\n * we are writing back data added by write(), the inode is already there and if\n * we are writing back data modified via mmap(), no one guarantees in which\n * transaction the data will hit the disk. In case we are journaling data, we\n * cannot start transaction directly because transaction start ranks above page\n * lock so we have to do some magic.\n *\n * This function can get called via...\n *   - ext4_writepages after taking page lock (have journal handle)\n *   - journal_submit_inode_data_buffers (no journal handle)\n *   - shrink_page_list via the kswapd/direct reclaim (no journal handle)\n *   - grab_page_cache when doing write_begin (have journal handle)\n *\n * We don't do any block allocation in this function. If we have page with\n * multiple blocks we need to write those buffer_heads that are mapped. This\n * is important for mmaped based write. So if we do with blocksize 1K\n * truncate(f, 1024);\n * a = mmap(f, 0, 4096);\n * a[0] = 'a';\n * truncate(f, 4096);\n * we have in the page first buffer_head mapped via page_mkwrite call back\n * but other buffer_heads would be unmapped but dirty (dirty done via the\n * do_wp_page). So writepage should write the first block. If we modify\n * the mmap area beyond 1024 we will again get a page_fault and the\n * page_mkwrite callback will do the block allocation and mark the\n * buffer_heads mapped.\n *\n * We redirty the page if we have any buffer_heads that is either delay or\n * unwritten in the page.\n *\n * We can get recursively called as show below.\n *\n *\text4_writepage() -> kmalloc() -> __alloc_pages() -> page_launder() ->\n *\t\text4_writepage()\n *\n * But since we don't do any block allocation we should not deadlock.\n * Page also have the dirty flag cleared so we don't get recurive page_lock.\n */\nstatic int ext4_writepage(struct page *page,\n\t\t\t  struct writeback_control *wbc)\n{\n\tint ret = 0;\n\tloff_t size;\n\tunsigned int len;\n\tstruct buffer_head *page_bufs = NULL;\n\tstruct inode *inode = page->mapping->host;\n\tstruct ext4_io_submit io_submit;\n\tbool keep_towrite = false;\n\n\ttrace_ext4_writepage(page);\n\tsize = i_size_read(inode);\n\tif (page->index == size >> PAGE_SHIFT)\n\t\tlen = size & ~PAGE_MASK;\n\telse\n\t\tlen = PAGE_SIZE;\n\n\tpage_bufs = page_buffers(page);\n\t/*\n\t * We cannot do block allocation or other extent handling in this\n\t * function. If there are buffers needing that, we have to redirty\n\t * the page. But we may reach here when we do a journal commit via\n\t * journal_submit_inode_data_buffers() and in that case we must write\n\t * allocated buffers to achieve data=ordered mode guarantees.\n\t *\n\t * Also, if there is only one buffer per page (the fs block\n\t * size == the page size), if one buffer needs block\n\t * allocation or needs to modify the extent tree to clear the\n\t * unwritten flag, we know that the page can't be written at\n\t * all, so we might as well refuse the write immediately.\n\t * Unfortunately if the block size != page size, we can't as\n\t * easily detect this case using ext4_walk_page_buffers(), but\n\t * for the extremely common case, this is an optimization that\n\t * skips a useless round trip through ext4_bio_write_page().\n\t */\n\tif (ext4_walk_page_buffers(NULL, page_bufs, 0, len, NULL,\n\t\t\t\t   ext4_bh_delay_or_unwritten)) {\n\t\tredirty_page_for_writepage(wbc, page);\n\t\tif ((current->flags & PF_MEMALLOC) ||\n\t\t    (inode->i_sb->s_blocksize == PAGE_SIZE)) {\n\t\t\t/*\n\t\t\t * For memory cleaning there's no point in writing only\n\t\t\t * some buffers. So just bail out. Warn if we came here\n\t\t\t * from direct reclaim.\n\t\t\t */\n\t\t\tWARN_ON_ONCE((current->flags & (PF_MEMALLOC|PF_KSWAPD))\n\t\t\t\t\t\t\t== PF_MEMALLOC);\n\t\t\tunlock_page(page);\n\t\t\treturn 0;\n\t\t}\n\t\tkeep_towrite = true;\n\t}\n\n\tif (PageChecked(page) && ext4_should_journal_data(inode))\n\t\t/*\n\t\t * It's mmapped pagecache.  Add buffers and journal it.  There\n\t\t * doesn't seem much point in redirtying the page here.\n\t\t */\n\t\treturn __ext4_journalled_writepage(page, len);\n\n\text4_io_submit_init(&io_submit, wbc);\n\tio_submit.io_end = ext4_init_io_end(inode, GFP_NOFS);\n\tif (!io_submit.io_end) {\n\t\tredirty_page_for_writepage(wbc, page);\n\t\tunlock_page(page);\n\t\treturn -ENOMEM;\n\t}\n\tret = ext4_bio_write_page(&io_submit, page, len, wbc, keep_towrite);\n\text4_io_submit(&io_submit);\n\t/* Drop io_end reference we got from init */\n\text4_put_io_end_defer(io_submit.io_end);\n\treturn ret;\n}\n\nstatic int mpage_submit_page(struct mpage_da_data *mpd, struct page *page)\n{\n\tint len;\n\tloff_t size = i_size_read(mpd->inode);\n\tint err;\n\n\tBUG_ON(page->index != mpd->first_page);\n\tif (page->index == size >> PAGE_SHIFT)\n\t\tlen = size & ~PAGE_MASK;\n\telse\n\t\tlen = PAGE_SIZE;\n\tclear_page_dirty_for_io(page);\n\terr = ext4_bio_write_page(&mpd->io_submit, page, len, mpd->wbc, false);\n\tif (!err)\n\t\tmpd->wbc->nr_to_write--;\n\tmpd->first_page++;\n\n\treturn err;\n}\n\n#define BH_FLAGS ((1 << BH_Unwritten) | (1 << BH_Delay))\n\n/*\n * mballoc gives us at most this number of blocks...\n * XXX: That seems to be only a limitation of ext4_mb_normalize_request().\n * The rest of mballoc seems to handle chunks up to full group size.\n */\n#define MAX_WRITEPAGES_EXTENT_LEN 2048\n\n/*\n * mpage_add_bh_to_extent - try to add bh to extent of blocks to map\n *\n * @mpd - extent of blocks\n * @lblk - logical number of the block in the file\n * @bh - buffer head we want to add to the extent\n *\n * The function is used to collect contig. blocks in the same state. If the\n * buffer doesn't require mapping for writeback and we haven't started the\n * extent of buffers to map yet, the function returns 'true' immediately - the\n * caller can write the buffer right away. Otherwise the function returns true\n * if the block has been added to the extent, false if the block couldn't be\n * added.\n */\nstatic bool mpage_add_bh_to_extent(struct mpage_da_data *mpd, ext4_lblk_t lblk,\n\t\t\t\t   struct buffer_head *bh)\n{\n\tstruct ext4_map_blocks *map = &mpd->map;\n\n\t/* Buffer that doesn't need mapping for writeback? */\n\tif (!buffer_dirty(bh) || !buffer_mapped(bh) ||\n\t    (!buffer_delay(bh) && !buffer_unwritten(bh))) {\n\t\t/* So far no extent to map => we write the buffer right away */\n\t\tif (map->m_len == 0)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\t/* First block in the extent? */\n\tif (map->m_len == 0) {\n\t\tmap->m_lblk = lblk;\n\t\tmap->m_len = 1;\n\t\tmap->m_flags = bh->b_state & BH_FLAGS;\n\t\treturn true;\n\t}\n\n\t/* Don't go larger than mballoc is willing to allocate */\n\tif (map->m_len >= MAX_WRITEPAGES_EXTENT_LEN)\n\t\treturn false;\n\n\t/* Can we merge the block to our big extent? */\n\tif (lblk == map->m_lblk + map->m_len &&\n\t    (bh->b_state & BH_FLAGS) == map->m_flags) {\n\t\tmap->m_len++;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/*\n * mpage_process_page_bufs - submit page buffers for IO or add them to extent\n *\n * @mpd - extent of blocks for mapping\n * @head - the first buffer in the page\n * @bh - buffer we should start processing from\n * @lblk - logical number of the block in the file corresponding to @bh\n *\n * Walk through page buffers from @bh upto @head (exclusive) and either submit\n * the page for IO if all buffers in this page were mapped and there's no\n * accumulated extent of buffers to map or add buffers in the page to the\n * extent of buffers to map. The function returns 1 if the caller can continue\n * by processing the next page, 0 if it should stop adding buffers to the\n * extent to map because we cannot extend it anymore. It can also return value\n * < 0 in case of error during IO submission.\n */\nstatic int mpage_process_page_bufs(struct mpage_da_data *mpd,\n\t\t\t\t   struct buffer_head *head,\n\t\t\t\t   struct buffer_head *bh,\n\t\t\t\t   ext4_lblk_t lblk)\n{\n\tstruct inode *inode = mpd->inode;\n\tint err;\n\text4_lblk_t blocks = (i_size_read(inode) + (1 << inode->i_blkbits) - 1)\n\t\t\t\t\t\t\t>> inode->i_blkbits;\n\n\tdo {\n\t\tBUG_ON(buffer_locked(bh));\n\n\t\tif (lblk >= blocks || !mpage_add_bh_to_extent(mpd, lblk, bh)) {\n\t\t\t/* Found extent to map? */\n\t\t\tif (mpd->map.m_len)\n\t\t\t\treturn 0;\n\t\t\t/* Everything mapped so far and we hit EOF */\n\t\t\tbreak;\n\t\t}\n\t} while (lblk++, (bh = bh->b_this_page) != head);\n\t/* So far everything mapped? Submit the page for IO. */\n\tif (mpd->map.m_len == 0) {\n\t\terr = mpage_submit_page(mpd, head->b_page);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\treturn lblk < blocks;\n}\n\n/*\n * mpage_map_buffers - update buffers corresponding to changed extent and\n *\t\t       submit fully mapped pages for IO\n *\n * @mpd - description of extent to map, on return next extent to map\n *\n * Scan buffers corresponding to changed extent (we expect corresponding pages\n * to be already locked) and update buffer state according to new extent state.\n * We map delalloc buffers to their physical location, clear unwritten bits,\n * and mark buffers as uninit when we perform writes to unwritten extents\n * and do extent conversion after IO is finished. If the last page is not fully\n * mapped, we update @map to the next extent in the last page that needs\n * mapping. Otherwise we submit the page for IO.\n */\nstatic int mpage_map_and_submit_buffers(struct mpage_da_data *mpd)\n{\n\tstruct pagevec pvec;\n\tint nr_pages, i;\n\tstruct inode *inode = mpd->inode;\n\tstruct buffer_head *head, *bh;\n\tint bpp_bits = PAGE_SHIFT - inode->i_blkbits;\n\tpgoff_t start, end;\n\text4_lblk_t lblk;\n\tsector_t pblock;\n\tint err;\n\n\tstart = mpd->map.m_lblk >> bpp_bits;\n\tend = (mpd->map.m_lblk + mpd->map.m_len - 1) >> bpp_bits;\n\tlblk = start << bpp_bits;\n\tpblock = mpd->map.m_pblk;\n\n\tpagevec_init(&pvec, 0);\n\twhile (start <= end) {\n\t\tnr_pages = pagevec_lookup(&pvec, inode->i_mapping, start,\n\t\t\t\t\t  PAGEVEC_SIZE);\n\t\tif (nr_pages == 0)\n\t\t\tbreak;\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\tif (page->index > end)\n\t\t\t\tbreak;\n\t\t\t/* Up to 'end' pages must be contiguous */\n\t\t\tBUG_ON(page->index != start);\n\t\t\tbh = head = page_buffers(page);\n\t\t\tdo {\n\t\t\t\tif (lblk < mpd->map.m_lblk)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (lblk >= mpd->map.m_lblk + mpd->map.m_len) {\n\t\t\t\t\t/*\n\t\t\t\t\t * Buffer after end of mapped extent.\n\t\t\t\t\t * Find next buffer in the page to map.\n\t\t\t\t\t */\n\t\t\t\t\tmpd->map.m_len = 0;\n\t\t\t\t\tmpd->map.m_flags = 0;\n\t\t\t\t\t/*\n\t\t\t\t\t * FIXME: If dioread_nolock supports\n\t\t\t\t\t * blocksize < pagesize, we need to make\n\t\t\t\t\t * sure we add size mapped so far to\n\t\t\t\t\t * io_end->size as the following call\n\t\t\t\t\t * can submit the page for IO.\n\t\t\t\t\t */\n\t\t\t\t\terr = mpage_process_page_bufs(mpd, head,\n\t\t\t\t\t\t\t\t      bh, lblk);\n\t\t\t\t\tpagevec_release(&pvec);\n\t\t\t\t\tif (err > 0)\n\t\t\t\t\t\terr = 0;\n\t\t\t\t\treturn err;\n\t\t\t\t}\n\t\t\t\tif (buffer_delay(bh)) {\n\t\t\t\t\tclear_buffer_delay(bh);\n\t\t\t\t\tbh->b_blocknr = pblock++;\n\t\t\t\t}\n\t\t\t\tclear_buffer_unwritten(bh);\n\t\t\t} while (lblk++, (bh = bh->b_this_page) != head);\n\n\t\t\t/*\n\t\t\t * FIXME: This is going to break if dioread_nolock\n\t\t\t * supports blocksize < pagesize as we will try to\n\t\t\t * convert potentially unmapped parts of inode.\n\t\t\t */\n\t\t\tmpd->io_submit.io_end->size += PAGE_SIZE;\n\t\t\t/* Page fully mapped - let IO run! */\n\t\t\terr = mpage_submit_page(mpd, page);\n\t\t\tif (err < 0) {\n\t\t\t\tpagevec_release(&pvec);\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\tstart++;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t}\n\t/* Extent fully mapped and matches with page boundary. We are done. */\n\tmpd->map.m_len = 0;\n\tmpd->map.m_flags = 0;\n\treturn 0;\n}\n\nstatic int mpage_map_one_extent(handle_t *handle, struct mpage_da_data *mpd)\n{\n\tstruct inode *inode = mpd->inode;\n\tstruct ext4_map_blocks *map = &mpd->map;\n\tint get_blocks_flags;\n\tint err, dioread_nolock;\n\n\ttrace_ext4_da_write_pages_extent(inode, map);\n\t/*\n\t * Call ext4_map_blocks() to allocate any delayed allocation blocks, or\n\t * to convert an unwritten extent to be initialized (in the case\n\t * where we have written into one or more preallocated blocks).  It is\n\t * possible that we're going to need more metadata blocks than\n\t * previously reserved. However we must not fail because we're in\n\t * writeback and there is nothing we can do about it so it might result\n\t * in data loss.  So use reserved blocks to allocate metadata if\n\t * possible.\n\t *\n\t * We pass in the magic EXT4_GET_BLOCKS_DELALLOC_RESERVE if\n\t * the blocks in question are delalloc blocks.  This indicates\n\t * that the blocks and quotas has already been checked when\n\t * the data was copied into the page cache.\n\t */\n\tget_blocks_flags = EXT4_GET_BLOCKS_CREATE |\n\t\t\t   EXT4_GET_BLOCKS_METADATA_NOFAIL;\n\tdioread_nolock = ext4_should_dioread_nolock(inode);\n\tif (dioread_nolock)\n\t\tget_blocks_flags |= EXT4_GET_BLOCKS_IO_CREATE_EXT;\n\tif (map->m_flags & (1 << BH_Delay))\n\t\tget_blocks_flags |= EXT4_GET_BLOCKS_DELALLOC_RESERVE;\n\n\terr = ext4_map_blocks(handle, inode, map, get_blocks_flags);\n\tif (err < 0)\n\t\treturn err;\n\tif (dioread_nolock && (map->m_flags & EXT4_MAP_UNWRITTEN)) {\n\t\tif (!mpd->io_submit.io_end->handle &&\n\t\t    ext4_handle_valid(handle)) {\n\t\t\tmpd->io_submit.io_end->handle = handle->h_rsv_handle;\n\t\t\thandle->h_rsv_handle = NULL;\n\t\t}\n\t\text4_set_io_unwritten_flag(inode, mpd->io_submit.io_end);\n\t}\n\n\tBUG_ON(map->m_len == 0);\n\tif (map->m_flags & EXT4_MAP_NEW) {\n\t\tstruct block_device *bdev = inode->i_sb->s_bdev;\n\t\tint i;\n\n\t\tfor (i = 0; i < map->m_len; i++)\n\t\t\tunmap_underlying_metadata(bdev, map->m_pblk + i);\n\t}\n\treturn 0;\n}\n\n/*\n * mpage_map_and_submit_extent - map extent starting at mpd->lblk of length\n *\t\t\t\t mpd->len and submit pages underlying it for IO\n *\n * @handle - handle for journal operations\n * @mpd - extent to map\n * @give_up_on_write - we set this to true iff there is a fatal error and there\n *                     is no hope of writing the data. The caller should discard\n *                     dirty pages to avoid infinite loops.\n *\n * The function maps extent starting at mpd->lblk of length mpd->len. If it is\n * delayed, blocks are allocated, if it is unwritten, we may need to convert\n * them to initialized or split the described range from larger unwritten\n * extent. Note that we need not map all the described range since allocation\n * can return less blocks or the range is covered by more unwritten extents. We\n * cannot map more because we are limited by reserved transaction credits. On\n * the other hand we always make sure that the last touched page is fully\n * mapped so that it can be written out (and thus forward progress is\n * guaranteed). After mapping we submit all mapped pages for IO.\n */\nstatic int mpage_map_and_submit_extent(handle_t *handle,\n\t\t\t\t       struct mpage_da_data *mpd,\n\t\t\t\t       bool *give_up_on_write)\n{\n\tstruct inode *inode = mpd->inode;\n\tstruct ext4_map_blocks *map = &mpd->map;\n\tint err;\n\tloff_t disksize;\n\tint progress = 0;\n\n\tmpd->io_submit.io_end->offset =\n\t\t\t\t((loff_t)map->m_lblk) << inode->i_blkbits;\n\tdo {\n\t\terr = mpage_map_one_extent(handle, mpd);\n\t\tif (err < 0) {\n\t\t\tstruct super_block *sb = inode->i_sb;\n\n\t\t\tif (EXT4_SB(sb)->s_mount_flags & EXT4_MF_FS_ABORTED)\n\t\t\t\tgoto invalidate_dirty_pages;\n\t\t\t/*\n\t\t\t * Let the uper layers retry transient errors.\n\t\t\t * In the case of ENOSPC, if ext4_count_free_blocks()\n\t\t\t * is non-zero, a commit should free up blocks.\n\t\t\t */\n\t\t\tif ((err == -ENOMEM) ||\n\t\t\t    (err == -ENOSPC && ext4_count_free_clusters(sb))) {\n\t\t\t\tif (progress)\n\t\t\t\t\tgoto update_disksize;\n\t\t\t\treturn err;\n\t\t\t}\n\t\t\text4_msg(sb, KERN_CRIT,\n\t\t\t\t \"Delayed block allocation failed for \"\n\t\t\t\t \"inode %lu at logical offset %llu with\"\n\t\t\t\t \" max blocks %u with error %d\",\n\t\t\t\t inode->i_ino,\n\t\t\t\t (unsigned long long)map->m_lblk,\n\t\t\t\t (unsigned)map->m_len, -err);\n\t\t\text4_msg(sb, KERN_CRIT,\n\t\t\t\t \"This should not happen!! Data will \"\n\t\t\t\t \"be lost\\n\");\n\t\t\tif (err == -ENOSPC)\n\t\t\t\text4_print_free_blocks(inode);\n\t\tinvalidate_dirty_pages:\n\t\t\t*give_up_on_write = true;\n\t\t\treturn err;\n\t\t}\n\t\tprogress = 1;\n\t\t/*\n\t\t * Update buffer state, submit mapped pages, and get us new\n\t\t * extent to map\n\t\t */\n\t\terr = mpage_map_and_submit_buffers(mpd);\n\t\tif (err < 0)\n\t\t\tgoto update_disksize;\n\t} while (map->m_len);\n\nupdate_disksize:\n\t/*\n\t * Update on-disk size after IO is submitted.  Races with\n\t * truncate are avoided by checking i_size under i_data_sem.\n\t */\n\tdisksize = ((loff_t)mpd->first_page) << PAGE_SHIFT;\n\tif (disksize > EXT4_I(inode)->i_disksize) {\n\t\tint err2;\n\t\tloff_t i_size;\n\n\t\tdown_write(&EXT4_I(inode)->i_data_sem);\n\t\ti_size = i_size_read(inode);\n\t\tif (disksize > i_size)\n\t\t\tdisksize = i_size;\n\t\tif (disksize > EXT4_I(inode)->i_disksize)\n\t\t\tEXT4_I(inode)->i_disksize = disksize;\n\t\terr2 = ext4_mark_inode_dirty(handle, inode);\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tif (err2)\n\t\t\text4_error(inode->i_sb,\n\t\t\t\t   \"Failed to mark inode %lu dirty\",\n\t\t\t\t   inode->i_ino);\n\t\tif (!err)\n\t\t\terr = err2;\n\t}\n\treturn err;\n}\n\n/*\n * Calculate the total number of credits to reserve for one writepages\n * iteration. This is called from ext4_writepages(). We map an extent of\n * up to MAX_WRITEPAGES_EXTENT_LEN blocks and then we go on and finish mapping\n * the last partial page. So in total we can map MAX_WRITEPAGES_EXTENT_LEN +\n * bpp - 1 blocks in bpp different extents.\n */\nstatic int ext4_da_writepages_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\n\treturn ext4_meta_trans_blocks(inode,\n\t\t\t\tMAX_WRITEPAGES_EXTENT_LEN + bpp - 1, bpp);\n}\n\n/*\n * mpage_prepare_extent_to_map - find & lock contiguous range of dirty pages\n * \t\t\t\t and underlying extent to map\n *\n * @mpd - where to look for pages\n *\n * Walk dirty pages in the mapping. If they are fully mapped, submit them for\n * IO immediately. When we find a page which isn't mapped we start accumulating\n * extent of buffers underlying these pages that needs mapping (formed by\n * either delayed or unwritten buffers). We also lock the pages containing\n * these buffers. The extent found is returned in @mpd structure (starting at\n * mpd->lblk with length mpd->len blocks).\n *\n * Note that this function can attach bios to one io_end structure which are\n * neither logically nor physically contiguous. Although it may seem as an\n * unnecessary complication, it is actually inevitable in blocksize < pagesize\n * case as we need to track IO to all buffers underlying a page in one io_end.\n */\nstatic int mpage_prepare_extent_to_map(struct mpage_da_data *mpd)\n{\n\tstruct address_space *mapping = mpd->inode->i_mapping;\n\tstruct pagevec pvec;\n\tunsigned int nr_pages;\n\tlong left = mpd->wbc->nr_to_write;\n\tpgoff_t index = mpd->first_page;\n\tpgoff_t end = mpd->last_page;\n\tint tag;\n\tint i, err = 0;\n\tint blkbits = mpd->inode->i_blkbits;\n\text4_lblk_t lblk;\n\tstruct buffer_head *head;\n\n\tif (mpd->wbc->sync_mode == WB_SYNC_ALL || mpd->wbc->tagged_writepages)\n\t\ttag = PAGECACHE_TAG_TOWRITE;\n\telse\n\t\ttag = PAGECACHE_TAG_DIRTY;\n\n\tpagevec_init(&pvec, 0);\n\tmpd->map.m_len = 0;\n\tmpd->next_page = index;\n\twhile (index <= end) {\n\t\tnr_pages = pagevec_lookup_tag(&pvec, mapping, &index, tag,\n\t\t\t      min(end - index, (pgoff_t)PAGEVEC_SIZE-1) + 1);\n\t\tif (nr_pages == 0)\n\t\t\tgoto out;\n\n\t\tfor (i = 0; i < nr_pages; i++) {\n\t\t\tstruct page *page = pvec.pages[i];\n\n\t\t\t/*\n\t\t\t * At this point, the page may be truncated or\n\t\t\t * invalidated (changing page->mapping to NULL), or\n\t\t\t * even swizzled back from swapper_space to tmpfs file\n\t\t\t * mapping. However, page->index will not change\n\t\t\t * because we have a reference on the page.\n\t\t\t */\n\t\t\tif (page->index > end)\n\t\t\t\tgoto out;\n\n\t\t\t/*\n\t\t\t * Accumulated enough dirty pages? This doesn't apply\n\t\t\t * to WB_SYNC_ALL mode. For integrity sync we have to\n\t\t\t * keep going because someone may be concurrently\n\t\t\t * dirtying pages, and we might have synced a lot of\n\t\t\t * newly appeared dirty pages, but have not synced all\n\t\t\t * of the old dirty pages.\n\t\t\t */\n\t\t\tif (mpd->wbc->sync_mode == WB_SYNC_NONE && left <= 0)\n\t\t\t\tgoto out;\n\n\t\t\t/* If we can't merge this page, we are done. */\n\t\t\tif (mpd->map.m_len > 0 && mpd->next_page != page->index)\n\t\t\t\tgoto out;\n\n\t\t\tlock_page(page);\n\t\t\t/*\n\t\t\t * If the page is no longer dirty, or its mapping no\n\t\t\t * longer corresponds to inode we are writing (which\n\t\t\t * means it has been truncated or invalidated), or the\n\t\t\t * page is already under writeback and we are not doing\n\t\t\t * a data integrity writeback, skip the page\n\t\t\t */\n\t\t\tif (!PageDirty(page) ||\n\t\t\t    (PageWriteback(page) &&\n\t\t\t     (mpd->wbc->sync_mode == WB_SYNC_NONE)) ||\n\t\t\t    unlikely(page->mapping != mapping)) {\n\t\t\t\tunlock_page(page);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\twait_on_page_writeback(page);\n\t\t\tBUG_ON(PageWriteback(page));\n\n\t\t\tif (mpd->map.m_len == 0)\n\t\t\t\tmpd->first_page = page->index;\n\t\t\tmpd->next_page = page->index + 1;\n\t\t\t/* Add all dirty buffers to mpd */\n\t\t\tlblk = ((ext4_lblk_t)page->index) <<\n\t\t\t\t(PAGE_SHIFT - blkbits);\n\t\t\thead = page_buffers(page);\n\t\t\terr = mpage_process_page_bufs(mpd, head, head, lblk);\n\t\t\tif (err <= 0)\n\t\t\t\tgoto out;\n\t\t\terr = 0;\n\t\t\tleft--;\n\t\t}\n\t\tpagevec_release(&pvec);\n\t\tcond_resched();\n\t}\n\treturn 0;\nout:\n\tpagevec_release(&pvec);\n\treturn err;\n}\n\nstatic int __writepage(struct page *page, struct writeback_control *wbc,\n\t\t       void *data)\n{\n\tstruct address_space *mapping = data;\n\tint ret = ext4_writepage(page, wbc);\n\tmapping_set_error(mapping, ret);\n\treturn ret;\n}\n\nstatic int ext4_writepages(struct address_space *mapping,\n\t\t\t   struct writeback_control *wbc)\n{\n\tpgoff_t\twriteback_index = 0;\n\tlong nr_to_write = wbc->nr_to_write;\n\tint range_whole = 0;\n\tint cycled = 1;\n\thandle_t *handle = NULL;\n\tstruct mpage_da_data mpd;\n\tstruct inode *inode = mapping->host;\n\tint needed_blocks, rsv_blocks = 0, ret = 0;\n\tstruct ext4_sb_info *sbi = EXT4_SB(mapping->host->i_sb);\n\tbool done;\n\tstruct blk_plug plug;\n\tbool give_up_on_write = false;\n\n\ttrace_ext4_writepages(inode, wbc);\n\n\tif (dax_mapping(mapping))\n\t\treturn dax_writeback_mapping_range(mapping, inode->i_sb->s_bdev,\n\t\t\t\t\t\t   wbc);\n\n\t/*\n\t * No pages to write? This is mainly a kludge to avoid starting\n\t * a transaction for special inodes like journal inode on last iput()\n\t * because that could violate lock ordering on umount\n\t */\n\tif (!mapping->nrpages || !mapping_tagged(mapping, PAGECACHE_TAG_DIRTY))\n\t\tgoto out_writepages;\n\n\tif (ext4_should_journal_data(inode)) {\n\t\tstruct blk_plug plug;\n\n\t\tblk_start_plug(&plug);\n\t\tret = write_cache_pages(mapping, wbc, __writepage, mapping);\n\t\tblk_finish_plug(&plug);\n\t\tgoto out_writepages;\n\t}\n\n\t/*\n\t * If the filesystem has aborted, it is read-only, so return\n\t * right away instead of dumping stack traces later on that\n\t * will obscure the real source of the problem.  We test\n\t * EXT4_MF_FS_ABORTED instead of sb->s_flag's MS_RDONLY because\n\t * the latter could be true if the filesystem is mounted\n\t * read-only, and in that case, ext4_writepages should\n\t * *never* be called, so if that ever happens, we would want\n\t * the stack trace.\n\t */\n\tif (unlikely(sbi->s_mount_flags & EXT4_MF_FS_ABORTED)) {\n\t\tret = -EROFS;\n\t\tgoto out_writepages;\n\t}\n\n\tif (ext4_should_dioread_nolock(inode)) {\n\t\t/*\n\t\t * We may need to convert up to one extent per block in\n\t\t * the page and we may dirty the inode.\n\t\t */\n\t\trsv_blocks = 1 + (PAGE_SIZE >> inode->i_blkbits);\n\t}\n\n\t/*\n\t * If we have inline data and arrive here, it means that\n\t * we will soon create the block for the 1st page, so\n\t * we'd better clear the inline data here.\n\t */\n\tif (ext4_has_inline_data(inode)) {\n\t\t/* Just inode will be modified... */\n\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tgoto out_writepages;\n\t\t}\n\t\tBUG_ON(ext4_test_inode_state(inode,\n\t\t\t\tEXT4_STATE_MAY_INLINE_DATA));\n\t\text4_destroy_inline_data(handle, inode);\n\t\text4_journal_stop(handle);\n\t}\n\n\tif (wbc->range_start == 0 && wbc->range_end == LLONG_MAX)\n\t\trange_whole = 1;\n\n\tif (wbc->range_cyclic) {\n\t\twriteback_index = mapping->writeback_index;\n\t\tif (writeback_index)\n\t\t\tcycled = 0;\n\t\tmpd.first_page = writeback_index;\n\t\tmpd.last_page = -1;\n\t} else {\n\t\tmpd.first_page = wbc->range_start >> PAGE_SHIFT;\n\t\tmpd.last_page = wbc->range_end >> PAGE_SHIFT;\n\t}\n\n\tmpd.inode = inode;\n\tmpd.wbc = wbc;\n\text4_io_submit_init(&mpd.io_submit, wbc);\nretry:\n\tif (wbc->sync_mode == WB_SYNC_ALL || wbc->tagged_writepages)\n\t\ttag_pages_for_writeback(mapping, mpd.first_page, mpd.last_page);\n\tdone = false;\n\tblk_start_plug(&plug);\n\twhile (!done && mpd.first_page <= mpd.last_page) {\n\t\t/* For each extent of pages we use new io_end */\n\t\tmpd.io_submit.io_end = ext4_init_io_end(inode, GFP_KERNEL);\n\t\tif (!mpd.io_submit.io_end) {\n\t\t\tret = -ENOMEM;\n\t\t\tbreak;\n\t\t}\n\n\t\t/*\n\t\t * We have two constraints: We find one extent to map and we\n\t\t * must always write out whole page (makes a difference when\n\t\t * blocksize < pagesize) so that we don't block on IO when we\n\t\t * try to write out the rest of the page. Journalled mode is\n\t\t * not supported by delalloc.\n\t\t */\n\t\tBUG_ON(ext4_should_journal_data(inode));\n\t\tneeded_blocks = ext4_da_writepages_trans_blocks(inode);\n\n\t\t/* start a new transaction */\n\t\thandle = ext4_journal_start_with_reserve(inode,\n\t\t\t\tEXT4_HT_WRITE_PAGE, needed_blocks, rsv_blocks);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\text4_msg(inode->i_sb, KERN_CRIT, \"%s: jbd2_start: \"\n\t\t\t       \"%ld pages, ino %lu; err %d\", __func__,\n\t\t\t\twbc->nr_to_write, inode->i_ino, ret);\n\t\t\t/* Release allocated io_end */\n\t\t\text4_put_io_end(mpd.io_submit.io_end);\n\t\t\tbreak;\n\t\t}\n\n\t\ttrace_ext4_da_write_pages(inode, mpd.first_page, mpd.wbc);\n\t\tret = mpage_prepare_extent_to_map(&mpd);\n\t\tif (!ret) {\n\t\t\tif (mpd.map.m_len)\n\t\t\t\tret = mpage_map_and_submit_extent(handle, &mpd,\n\t\t\t\t\t&give_up_on_write);\n\t\t\telse {\n\t\t\t\t/*\n\t\t\t\t * We scanned the whole range (or exhausted\n\t\t\t\t * nr_to_write), submitted what was mapped and\n\t\t\t\t * didn't find anything needing mapping. We are\n\t\t\t\t * done.\n\t\t\t\t */\n\t\t\t\tdone = true;\n\t\t\t}\n\t\t}\n\t\text4_journal_stop(handle);\n\t\t/* Submit prepared bio */\n\t\text4_io_submit(&mpd.io_submit);\n\t\t/* Unlock pages we didn't use */\n\t\tmpage_release_unused_pages(&mpd, give_up_on_write);\n\t\t/* Drop our io_end reference we got from init */\n\t\text4_put_io_end(mpd.io_submit.io_end);\n\n\t\tif (ret == -ENOSPC && sbi->s_journal) {\n\t\t\t/*\n\t\t\t * Commit the transaction which would\n\t\t\t * free blocks released in the transaction\n\t\t\t * and try again\n\t\t\t */\n\t\t\tjbd2_journal_force_commit_nested(sbi->s_journal);\n\t\t\tret = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Fatal error - ENOMEM, EIO... */\n\t\tif (ret)\n\t\t\tbreak;\n\t}\n\tblk_finish_plug(&plug);\n\tif (!ret && !cycled && wbc->nr_to_write > 0) {\n\t\tcycled = 1;\n\t\tmpd.last_page = writeback_index - 1;\n\t\tmpd.first_page = 0;\n\t\tgoto retry;\n\t}\n\n\t/* Update index */\n\tif (wbc->range_cyclic || (range_whole && wbc->nr_to_write > 0))\n\t\t/*\n\t\t * Set the writeback_index so that range_cyclic\n\t\t * mode will write it back later\n\t\t */\n\t\tmapping->writeback_index = mpd.first_page;\n\nout_writepages:\n\ttrace_ext4_writepages_result(inode, wbc, ret,\n\t\t\t\t     nr_to_write - wbc->nr_to_write);\n\treturn ret;\n}\n\nstatic int ext4_nonda_switch(struct super_block *sb)\n{\n\ts64 free_clusters, dirty_clusters;\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\n\t/*\n\t * switch to non delalloc mode if we are running low\n\t * on free block. The free block accounting via percpu\n\t * counters can get slightly wrong with percpu_counter_batch getting\n\t * accumulated on each CPU without updating global counters\n\t * Delalloc need an accurate free block accounting. So switch\n\t * to non delalloc when we are near to error range.\n\t */\n\tfree_clusters =\n\t\tpercpu_counter_read_positive(&sbi->s_freeclusters_counter);\n\tdirty_clusters =\n\t\tpercpu_counter_read_positive(&sbi->s_dirtyclusters_counter);\n\t/*\n\t * Start pushing delalloc when 1/2 of free blocks are dirty.\n\t */\n\tif (dirty_clusters && (free_clusters < 2 * dirty_clusters))\n\t\ttry_to_writeback_inodes_sb(sb, WB_REASON_FS_FREE_SPACE);\n\n\tif (2 * free_clusters < 3 * dirty_clusters ||\n\t    free_clusters < (dirty_clusters + EXT4_FREECLUSTERS_WATERMARK)) {\n\t\t/*\n\t\t * free block count is less than 150% of dirty blocks\n\t\t * or free blocks is less than watermark\n\t\t */\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n/* We always reserve for an inode update; the superblock could be there too */\nstatic int ext4_da_write_credits(struct inode *inode, loff_t pos, unsigned len)\n{\n\tif (likely(ext4_has_feature_large_file(inode->i_sb)))\n\t\treturn 1;\n\n\tif (pos + len <= 0x7fffffffULL)\n\t\treturn 1;\n\n\t/* We might need to update the superblock to set LARGE_FILE */\n\treturn 2;\n}\n\nstatic int ext4_da_write_begin(struct file *file, struct address_space *mapping,\n\t\t\t       loff_t pos, unsigned len, unsigned flags,\n\t\t\t       struct page **pagep, void **fsdata)\n{\n\tint ret, retries = 0;\n\tstruct page *page;\n\tpgoff_t index;\n\tstruct inode *inode = mapping->host;\n\thandle_t *handle;\n\n\tindex = pos >> PAGE_SHIFT;\n\n\tif (ext4_nonda_switch(inode->i_sb)) {\n\t\t*fsdata = (void *)FALL_BACK_TO_NONDELALLOC;\n\t\treturn ext4_write_begin(file, mapping, pos,\n\t\t\t\t\tlen, flags, pagep, fsdata);\n\t}\n\t*fsdata = (void *)0;\n\ttrace_ext4_da_write_begin(inode, pos, len, flags);\n\n\tif (ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA)) {\n\t\tret = ext4_da_write_inline_data_begin(mapping, inode,\n\t\t\t\t\t\t      pos, len, flags,\n\t\t\t\t\t\t      pagep, fsdata);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tif (ret == 1)\n\t\t\treturn 0;\n\t}\n\n\t/*\n\t * grab_cache_page_write_begin() can take a long time if the\n\t * system is thrashing due to memory pressure, or if the page\n\t * is being written back.  So grab it first before we start\n\t * the transaction handle.  This also allows us to allocate\n\t * the page (if needed) without using GFP_NOFS.\n\t */\nretry_grab:\n\tpage = grab_cache_page_write_begin(mapping, index, flags);\n\tif (!page)\n\t\treturn -ENOMEM;\n\tunlock_page(page);\n\n\t/*\n\t * With delayed allocation, we don't log the i_disksize update\n\t * if there is delayed block allocation. But we still need\n\t * to journalling the i_disksize update if writes to the end\n\t * of file which has an already mapped buffer.\n\t */\nretry_journal:\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE,\n\t\t\t\text4_da_write_credits(inode, pos, len));\n\tif (IS_ERR(handle)) {\n\t\tput_page(page);\n\t\treturn PTR_ERR(handle);\n\t}\n\n\tlock_page(page);\n\tif (page->mapping != mapping) {\n\t\t/* The page got truncated from under us */\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\text4_journal_stop(handle);\n\t\tgoto retry_grab;\n\t}\n\t/* In case writeback began while the page was unlocked */\n\twait_for_stable_page(page);\n\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tret = ext4_block_write_begin(page, pos, len,\n\t\t\t\t     ext4_da_get_block_prep);\n#else\n\tret = __block_write_begin(page, pos, len, ext4_da_get_block_prep);\n#endif\n\tif (ret < 0) {\n\t\tunlock_page(page);\n\t\text4_journal_stop(handle);\n\t\t/*\n\t\t * block_write_begin may have instantiated a few blocks\n\t\t * outside i_size.  Trim these off again. Don't need\n\t\t * i_size_read because we hold i_mutex.\n\t\t */\n\t\tif (pos + len > inode->i_size)\n\t\t\text4_truncate_failed_write(inode);\n\n\t\tif (ret == -ENOSPC &&\n\t\t    ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\t\tgoto retry_journal;\n\n\t\tput_page(page);\n\t\treturn ret;\n\t}\n\n\t*pagep = page;\n\treturn ret;\n}\n\n/*\n * Check if we should update i_disksize\n * when write to the end of file but not require block allocation\n */\nstatic int ext4_da_should_update_i_disksize(struct page *page,\n\t\t\t\t\t    unsigned long offset)\n{\n\tstruct buffer_head *bh;\n\tstruct inode *inode = page->mapping->host;\n\tunsigned int idx;\n\tint i;\n\n\tbh = page_buffers(page);\n\tidx = offset >> inode->i_blkbits;\n\n\tfor (i = 0; i < idx; i++)\n\t\tbh = bh->b_this_page;\n\n\tif (!buffer_mapped(bh) || (buffer_delay(bh)) || buffer_unwritten(bh))\n\t\treturn 0;\n\treturn 1;\n}\n\nstatic int ext4_da_write_end(struct file *file,\n\t\t\t     struct address_space *mapping,\n\t\t\t     loff_t pos, unsigned len, unsigned copied,\n\t\t\t     struct page *page, void *fsdata)\n{\n\tstruct inode *inode = mapping->host;\n\tint ret = 0, ret2;\n\thandle_t *handle = ext4_journal_current_handle();\n\tloff_t new_i_size;\n\tunsigned long start, end;\n\tint write_mode = (int)(unsigned long)fsdata;\n\n\tif (write_mode == FALL_BACK_TO_NONDELALLOC)\n\t\treturn ext4_write_end(file, mapping, pos,\n\t\t\t\t      len, copied, page, fsdata);\n\n\ttrace_ext4_da_write_end(inode, pos, len, copied);\n\tstart = pos & (PAGE_SIZE - 1);\n\tend = start + copied - 1;\n\n\t/*\n\t * generic_write_end() will run mark_inode_dirty() if i_size\n\t * changes.  So let's piggyback the i_disksize mark_inode_dirty\n\t * into that.\n\t */\n\tnew_i_size = pos + copied;\n\tif (copied && new_i_size > EXT4_I(inode)->i_disksize) {\n\t\tif (ext4_has_inline_data(inode) ||\n\t\t    ext4_da_should_update_i_disksize(page, end)) {\n\t\t\text4_update_i_disksize(inode, new_i_size);\n\t\t\t/* We need to mark inode dirty even if\n\t\t\t * new_i_size is less that inode->i_size\n\t\t\t * bu greater than i_disksize.(hint delalloc)\n\t\t\t */\n\t\t\text4_mark_inode_dirty(handle, inode);\n\t\t}\n\t}\n\n\tif (write_mode != CONVERT_INLINE_DATA &&\n\t    ext4_test_inode_state(inode, EXT4_STATE_MAY_INLINE_DATA) &&\n\t    ext4_has_inline_data(inode))\n\t\tret2 = ext4_da_write_inline_data_end(inode, pos, len, copied,\n\t\t\t\t\t\t     page);\n\telse\n\t\tret2 = generic_write_end(file, mapping, pos, len, copied,\n\t\t\t\t\t\t\tpage, fsdata);\n\n\tcopied = ret2;\n\tif (ret2 < 0)\n\t\tret = ret2;\n\tret2 = ext4_journal_stop(handle);\n\tif (!ret)\n\t\tret = ret2;\n\n\treturn ret ? ret : copied;\n}\n\nstatic void ext4_da_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\t   unsigned int length)\n{\n\t/*\n\t * Drop reserved blocks\n\t */\n\tBUG_ON(!PageLocked(page));\n\tif (!page_has_buffers(page))\n\t\tgoto out;\n\n\text4_da_page_release_reservation(page, offset, length);\n\nout:\n\text4_invalidatepage(page, offset, length);\n\n\treturn;\n}\n\n/*\n * Force all delayed allocation blocks to be allocated for a given inode.\n */\nint ext4_alloc_da_blocks(struct inode *inode)\n{\n\ttrace_ext4_alloc_da_blocks(inode);\n\n\tif (!EXT4_I(inode)->i_reserved_data_blocks)\n\t\treturn 0;\n\n\t/*\n\t * We do something simple for now.  The filemap_flush() will\n\t * also start triggering a write of the data blocks, which is\n\t * not strictly speaking necessary (and for users of\n\t * laptop_mode, not even desirable).  However, to do otherwise\n\t * would require replicating code paths in:\n\t *\n\t * ext4_writepages() ->\n\t *    write_cache_pages() ---> (via passed in callback function)\n\t *        __mpage_da_writepage() -->\n\t *           mpage_add_bh_to_extent()\n\t *           mpage_da_map_blocks()\n\t *\n\t * The problem is that write_cache_pages(), located in\n\t * mm/page-writeback.c, marks pages clean in preparation for\n\t * doing I/O, which is not desirable if we're not planning on\n\t * doing I/O at all.\n\t *\n\t * We could call write_cache_pages(), and then redirty all of\n\t * the pages by calling redirty_page_for_writepage() but that\n\t * would be ugly in the extreme.  So instead we would need to\n\t * replicate parts of the code in the above functions,\n\t * simplifying them because we wouldn't actually intend to\n\t * write out the pages, but rather only collect contiguous\n\t * logical block extents, call the multi-block allocator, and\n\t * then update the buffer heads with the block allocations.\n\t *\n\t * For now, though, we'll cheat by calling filemap_flush(),\n\t * which will map the blocks, and start the I/O, but not\n\t * actually wait for the I/O to complete.\n\t */\n\treturn filemap_flush(inode->i_mapping);\n}\n\n/*\n * bmap() is special.  It gets used by applications such as lilo and by\n * the swapper to find the on-disk block of a specific piece of data.\n *\n * Naturally, this is dangerous if the block concerned is still in the\n * journal.  If somebody makes a swapfile on an ext4 data-journaling\n * filesystem and enables swap, then they may get a nasty shock when the\n * data getting swapped to that swapfile suddenly gets overwritten by\n * the original zero's written out previously to the journal and\n * awaiting writeback in the kernel's buffer cache.\n *\n * So, if we see any bmap calls here on a modified, data-journaled file,\n * take extra steps to flush any blocks which might be in the cache.\n */\nstatic sector_t ext4_bmap(struct address_space *mapping, sector_t block)\n{\n\tstruct inode *inode = mapping->host;\n\tjournal_t *journal;\n\tint err;\n\n\t/*\n\t * We can get here for an inline file via the FIBMAP ioctl\n\t */\n\tif (ext4_has_inline_data(inode))\n\t\treturn 0;\n\n\tif (mapping_tagged(mapping, PAGECACHE_TAG_DIRTY) &&\n\t\t\ttest_opt(inode->i_sb, DELALLOC)) {\n\t\t/*\n\t\t * With delalloc we want to sync the file\n\t\t * so that we can make sure we allocate\n\t\t * blocks for file\n\t\t */\n\t\tfilemap_write_and_wait(mapping);\n\t}\n\n\tif (EXT4_JOURNAL(inode) &&\n\t    ext4_test_inode_state(inode, EXT4_STATE_JDATA)) {\n\t\t/*\n\t\t * This is a REALLY heavyweight approach, but the use of\n\t\t * bmap on dirty files is expected to be extremely rare:\n\t\t * only if we run lilo or swapon on a freshly made file\n\t\t * do we expect this to happen.\n\t\t *\n\t\t * (bmap requires CAP_SYS_RAWIO so this does not\n\t\t * represent an unprivileged user DOS attack --- we'd be\n\t\t * in trouble if mortal users could trigger this path at\n\t\t * will.)\n\t\t *\n\t\t * NB. EXT4_STATE_JDATA is not set on files other than\n\t\t * regular files.  If somebody wants to bmap a directory\n\t\t * or symlink and gets confused because the buffer\n\t\t * hasn't yet been flushed to disk, they deserve\n\t\t * everything they get.\n\t\t */\n\n\t\text4_clear_inode_state(inode, EXT4_STATE_JDATA);\n\t\tjournal = EXT4_JOURNAL(inode);\n\t\tjbd2_journal_lock_updates(journal);\n\t\terr = jbd2_journal_flush(journal);\n\t\tjbd2_journal_unlock_updates(journal);\n\n\t\tif (err)\n\t\t\treturn 0;\n\t}\n\n\treturn generic_block_bmap(mapping, block, ext4_get_block);\n}\n\nstatic int ext4_readpage(struct file *file, struct page *page)\n{\n\tint ret = -EAGAIN;\n\tstruct inode *inode = page->mapping->host;\n\n\ttrace_ext4_readpage(page);\n\n\tif (ext4_has_inline_data(inode))\n\t\tret = ext4_readpage_inline(inode, page);\n\n\tif (ret == -EAGAIN)\n\t\treturn ext4_mpage_readpages(page->mapping, NULL, page, 1);\n\n\treturn ret;\n}\n\nstatic int\next4_readpages(struct file *file, struct address_space *mapping,\n\t\tstruct list_head *pages, unsigned nr_pages)\n{\n\tstruct inode *inode = mapping->host;\n\n\t/* If the file has inline data, no need to do readpages. */\n\tif (ext4_has_inline_data(inode))\n\t\treturn 0;\n\n\treturn ext4_mpage_readpages(mapping, pages, NULL, nr_pages);\n}\n\nstatic void ext4_invalidatepage(struct page *page, unsigned int offset,\n\t\t\t\tunsigned int length)\n{\n\ttrace_ext4_invalidatepage(page, offset, length);\n\n\t/* No journalling happens on data buffers when this function is used */\n\tWARN_ON(page_has_buffers(page) && buffer_jbd(page_buffers(page)));\n\n\tblock_invalidatepage(page, offset, length);\n}\n\nstatic int __ext4_journalled_invalidatepage(struct page *page,\n\t\t\t\t\t    unsigned int offset,\n\t\t\t\t\t    unsigned int length)\n{\n\tjournal_t *journal = EXT4_JOURNAL(page->mapping->host);\n\n\ttrace_ext4_journalled_invalidatepage(page, offset, length);\n\n\t/*\n\t * If it's a full truncate we just forget about the pending dirtying\n\t */\n\tif (offset == 0 && length == PAGE_SIZE)\n\t\tClearPageChecked(page);\n\n\treturn jbd2_journal_invalidatepage(journal, page, offset, length);\n}\n\n/* Wrapper for aops... */\nstatic void ext4_journalled_invalidatepage(struct page *page,\n\t\t\t\t\t   unsigned int offset,\n\t\t\t\t\t   unsigned int length)\n{\n\tWARN_ON(__ext4_journalled_invalidatepage(page, offset, length) < 0);\n}\n\nstatic int ext4_releasepage(struct page *page, gfp_t wait)\n{\n\tjournal_t *journal = EXT4_JOURNAL(page->mapping->host);\n\n\ttrace_ext4_releasepage(page);\n\n\t/* Page has dirty journalled data -> cannot release */\n\tif (PageChecked(page))\n\t\treturn 0;\n\tif (journal)\n\t\treturn jbd2_journal_try_to_free_buffers(journal, page, wait);\n\telse\n\t\treturn try_to_free_buffers(page);\n}\n\n#ifdef CONFIG_FS_DAX\nint ext4_dax_mmap_get_block(struct inode *inode, sector_t iblock,\n\t\t\t    struct buffer_head *bh_result, int create)\n{\n\tint ret, err;\n\tint credits;\n\tstruct ext4_map_blocks map;\n\thandle_t *handle = NULL;\n\tint flags = 0;\n\n\text4_debug(\"ext4_dax_mmap_get_block: inode %lu, create flag %d\\n\",\n\t\t   inode->i_ino, create);\n\tmap.m_lblk = iblock;\n\tmap.m_len = bh_result->b_size >> inode->i_blkbits;\n\tcredits = ext4_chunk_trans_blocks(inode, map.m_len);\n\tif (create) {\n\t\tflags |= EXT4_GET_BLOCKS_PRE_IO | EXT4_GET_BLOCKS_CREATE_ZERO;\n\t\thandle = ext4_journal_start(inode, EXT4_HT_MAP_BLOCKS, credits);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\tret = ext4_map_blocks(handle, inode, &map, flags);\n\tif (create) {\n\t\terr = ext4_journal_stop(handle);\n\t\tif (ret >= 0 && err < 0)\n\t\t\tret = err;\n\t}\n\tif (ret <= 0)\n\t\tgoto out;\n\tif (map.m_flags & EXT4_MAP_UNWRITTEN) {\n\t\tint err2;\n\n\t\t/*\n\t\t * We are protected by i_mmap_sem so we know block cannot go\n\t\t * away from under us even though we dropped i_data_sem.\n\t\t * Convert extent to written and write zeros there.\n\t\t *\n\t\t * Note: We may get here even when create == 0.\n\t\t */\n\t\thandle = ext4_journal_start(inode, EXT4_HT_MAP_BLOCKS, credits);\n\t\tif (IS_ERR(handle)) {\n\t\t\tret = PTR_ERR(handle);\n\t\t\tgoto out;\n\t\t}\n\n\t\terr = ext4_map_blocks(handle, inode, &map,\n\t\t      EXT4_GET_BLOCKS_CONVERT | EXT4_GET_BLOCKS_CREATE_ZERO);\n\t\tif (err < 0)\n\t\t\tret = err;\n\t\terr2 = ext4_journal_stop(handle);\n\t\tif (err2 < 0 && ret > 0)\n\t\t\tret = err2;\n\t}\nout:\n\tWARN_ON_ONCE(ret == 0 && create);\n\tif (ret > 0) {\n\t\tmap_bh(bh_result, inode->i_sb, map.m_pblk);\n\t\t/*\n\t\t * At least for now we have to clear BH_New so that DAX code\n\t\t * doesn't attempt to zero blocks again in a racy way.\n\t\t */\n\t\tmap.m_flags &= ~EXT4_MAP_NEW;\n\t\text4_update_bh_state(bh_result, map.m_flags);\n\t\tbh_result->b_size = map.m_len << inode->i_blkbits;\n\t\tret = 0;\n\t}\n\treturn ret;\n}\n#endif\n\nstatic int ext4_end_io_dio(struct kiocb *iocb, loff_t offset,\n\t\t\t    ssize_t size, void *private)\n{\n        ext4_io_end_t *io_end = private;\n\n\t/* if not async direct IO just return */\n\tif (!io_end)\n\t\treturn 0;\n\n\text_debug(\"ext4_end_io_dio(): io_end 0x%p \"\n\t\t  \"for inode %lu, iocb 0x%p, offset %llu, size %zd\\n\",\n\t\t  io_end, io_end->inode->i_ino, iocb, offset, size);\n\n\t/*\n\t * Error during AIO DIO. We cannot convert unwritten extents as the\n\t * data was not written. Just clear the unwritten flag and drop io_end.\n\t */\n\tif (size <= 0) {\n\t\text4_clear_io_unwritten_flag(io_end);\n\t\tsize = 0;\n\t}\n\tio_end->offset = offset;\n\tio_end->size = size;\n\text4_put_io_end(io_end);\n\n\treturn 0;\n}\n\n/*\n * For ext4 extent files, ext4 will do direct-io write to holes,\n * preallocated extents, and those write extend the file, no need to\n * fall back to buffered IO.\n *\n * For holes, we fallocate those blocks, mark them as unwritten\n * If those blocks were preallocated, we mark sure they are split, but\n * still keep the range to write as unwritten.\n *\n * The unwritten extents will be converted to written when DIO is completed.\n * For async direct IO, since the IO may still pending when return, we\n * set up an end_io call back function, which will do the conversion\n * when async direct IO completed.\n *\n * If the O_DIRECT write will extend the file then add this inode to the\n * orphan list.  So recovery will truncate it back to the original size\n * if the machine crashes during the write.\n *\n */\nstatic ssize_t ext4_ext_direct_IO(struct kiocb *iocb, struct iov_iter *iter,\n\t\t\t\t  loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tssize_t ret;\n\tsize_t count = iov_iter_count(iter);\n\tint overwrite = 0;\n\tget_block_t *get_block_func = NULL;\n\tint dio_flags = 0;\n\tloff_t final_size = offset + count;\n\n\t/* Use the old path for reads and writes beyond i_size. */\n\tif (iov_iter_rw(iter) != WRITE || final_size > inode->i_size)\n\t\treturn ext4_ind_direct_IO(iocb, iter, offset);\n\n\tBUG_ON(iocb->private == NULL);\n\n\t/*\n\t * Make all waiters for direct IO properly wait also for extent\n\t * conversion. This also disallows race between truncate() and\n\t * overwrite DIO as i_dio_count needs to be incremented under i_mutex.\n\t */\n\tif (iov_iter_rw(iter) == WRITE)\n\t\tinode_dio_begin(inode);\n\n\t/* If we do a overwrite dio, i_mutex locking can be released */\n\toverwrite = *((int *)iocb->private);\n\n\tif (overwrite)\n\t\tinode_unlock(inode);\n\n\t/*\n\t * We could direct write to holes and fallocate.\n\t *\n\t * Allocated blocks to fill the hole are marked as unwritten to prevent\n\t * parallel buffered read to expose the stale data before DIO complete\n\t * the data IO.\n\t *\n\t * As to previously fallocated extents, ext4 get_block will just simply\n\t * mark the buffer mapped but still keep the extents unwritten.\n\t *\n\t * For non AIO case, we will convert those unwritten extents to written\n\t * after return back from blockdev_direct_IO. That way we save us from\n\t * allocating io_end structure and also the overhead of offloading\n\t * the extent convertion to a workqueue.\n\t *\n\t * For async DIO, the conversion needs to be deferred when the\n\t * IO is completed. The ext4 end_io callback function will be\n\t * called to take care of the conversion work.  Here for async\n\t * case, we allocate an io_end structure to hook to the iocb.\n\t */\n\tiocb->private = NULL;\n\tif (overwrite)\n\t\tget_block_func = ext4_dio_get_block_overwrite;\n\telse if (is_sync_kiocb(iocb)) {\n\t\tget_block_func = ext4_dio_get_block_unwritten_sync;\n\t\tdio_flags = DIO_LOCKING;\n\t} else {\n\t\tget_block_func = ext4_dio_get_block_unwritten_async;\n\t\tdio_flags = DIO_LOCKING;\n\t}\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tBUG_ON(ext4_encrypted_inode(inode) && S_ISREG(inode->i_mode));\n#endif\n\tif (IS_DAX(inode))\n\t\tret = dax_do_io(iocb, inode, iter, offset, get_block_func,\n\t\t\t\text4_end_io_dio, dio_flags);\n\telse\n\t\tret = __blockdev_direct_IO(iocb, inode,\n\t\t\t\t\t   inode->i_sb->s_bdev, iter, offset,\n\t\t\t\t\t   get_block_func,\n\t\t\t\t\t   ext4_end_io_dio, NULL, dio_flags);\n\n\tif (ret > 0 && !overwrite && ext4_test_inode_state(inode,\n\t\t\t\t\t\tEXT4_STATE_DIO_UNWRITTEN)) {\n\t\tint err;\n\t\t/*\n\t\t * for non AIO case, since the IO is already\n\t\t * completed, we could do the conversion right here\n\t\t */\n\t\terr = ext4_convert_unwritten_extents(NULL, inode,\n\t\t\t\t\t\t     offset, ret);\n\t\tif (err < 0)\n\t\t\tret = err;\n\t\text4_clear_inode_state(inode, EXT4_STATE_DIO_UNWRITTEN);\n\t}\n\n\tif (iov_iter_rw(iter) == WRITE)\n\t\tinode_dio_end(inode);\n\t/* take i_mutex locking again if we do a ovewrite dio */\n\tif (overwrite)\n\t\tinode_lock(inode);\n\n\treturn ret;\n}\n\nstatic ssize_t ext4_direct_IO(struct kiocb *iocb, struct iov_iter *iter,\n\t\t\t      loff_t offset)\n{\n\tstruct file *file = iocb->ki_filp;\n\tstruct inode *inode = file->f_mapping->host;\n\tsize_t count = iov_iter_count(iter);\n\tssize_t ret;\n\n#ifdef CONFIG_EXT4_FS_ENCRYPTION\n\tif (ext4_encrypted_inode(inode) && S_ISREG(inode->i_mode))\n\t\treturn 0;\n#endif\n\n\t/*\n\t * If we are doing data journalling we don't support O_DIRECT\n\t */\n\tif (ext4_should_journal_data(inode))\n\t\treturn 0;\n\n\t/* Let buffer I/O handle the inline data case. */\n\tif (ext4_has_inline_data(inode))\n\t\treturn 0;\n\n\ttrace_ext4_direct_IO_enter(inode, offset, count, iov_iter_rw(iter));\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tret = ext4_ext_direct_IO(iocb, iter, offset);\n\telse\n\t\tret = ext4_ind_direct_IO(iocb, iter, offset);\n\ttrace_ext4_direct_IO_exit(inode, offset, count, iov_iter_rw(iter), ret);\n\treturn ret;\n}\n\n/*\n * Pages can be marked dirty completely asynchronously from ext4's journalling\n * activity.  By filemap_sync_pte(), try_to_unmap_one(), etc.  We cannot do\n * much here because ->set_page_dirty is called under VFS locks.  The page is\n * not necessarily locked.\n *\n * We cannot just dirty the page and leave attached buffers clean, because the\n * buffers' dirty state is \"definitive\".  We cannot just set the buffers dirty\n * or jbddirty because all the journalling code will explode.\n *\n * So what we do is to mark the page \"pending dirty\" and next time writepage\n * is called, propagate that into the buffers appropriately.\n */\nstatic int ext4_journalled_set_page_dirty(struct page *page)\n{\n\tSetPageChecked(page);\n\treturn __set_page_dirty_nobuffers(page);\n}\n\nstatic const struct address_space_operations ext4_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\n\nstatic const struct address_space_operations ext4_journalled_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_write_begin,\n\t.write_end\t\t= ext4_journalled_write_end,\n\t.set_page_dirty\t\t= ext4_journalled_set_page_dirty,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_journalled_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\n\nstatic const struct address_space_operations ext4_da_aops = {\n\t.readpage\t\t= ext4_readpage,\n\t.readpages\t\t= ext4_readpages,\n\t.writepage\t\t= ext4_writepage,\n\t.writepages\t\t= ext4_writepages,\n\t.write_begin\t\t= ext4_da_write_begin,\n\t.write_end\t\t= ext4_da_write_end,\n\t.bmap\t\t\t= ext4_bmap,\n\t.invalidatepage\t\t= ext4_da_invalidatepage,\n\t.releasepage\t\t= ext4_releasepage,\n\t.direct_IO\t\t= ext4_direct_IO,\n\t.migratepage\t\t= buffer_migrate_page,\n\t.is_partially_uptodate  = block_is_partially_uptodate,\n\t.error_remove_page\t= generic_error_remove_page,\n};\n\nvoid ext4_set_aops(struct inode *inode)\n{\n\tswitch (ext4_inode_journal_mode(inode)) {\n\tcase EXT4_INODE_ORDERED_DATA_MODE:\n\t\text4_set_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_WRITEBACK_DATA_MODE:\n\t\text4_clear_inode_state(inode, EXT4_STATE_ORDERED_MODE);\n\t\tbreak;\n\tcase EXT4_INODE_JOURNAL_DATA_MODE:\n\t\tinode->i_mapping->a_ops = &ext4_journalled_aops;\n\t\treturn;\n\tdefault:\n\t\tBUG();\n\t}\n\tif (test_opt(inode->i_sb, DELALLOC))\n\t\tinode->i_mapping->a_ops = &ext4_da_aops;\n\telse\n\t\tinode->i_mapping->a_ops = &ext4_aops;\n}\n\nstatic int __ext4_block_zero_page_range(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from, loff_t length)\n{\n\text4_fsblk_t index = from >> PAGE_SHIFT;\n\tunsigned offset = from & (PAGE_SIZE-1);\n\tunsigned blocksize, pos;\n\text4_lblk_t iblock;\n\tstruct inode *inode = mapping->host;\n\tstruct buffer_head *bh;\n\tstruct page *page;\n\tint err = 0;\n\n\tpage = find_or_create_page(mapping, from >> PAGE_SHIFT,\n\t\t\t\t   mapping_gfp_constraint(mapping, ~__GFP_FS));\n\tif (!page)\n\t\treturn -ENOMEM;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\n\tiblock = index << (PAGE_SHIFT - inode->i_sb->s_blocksize_bits);\n\n\tif (!page_has_buffers(page))\n\t\tcreate_empty_buffers(page, blocksize, 0);\n\n\t/* Find the buffer that contains \"offset\" */\n\tbh = page_buffers(page);\n\tpos = blocksize;\n\twhile (offset >= pos) {\n\t\tbh = bh->b_this_page;\n\t\tiblock++;\n\t\tpos += blocksize;\n\t}\n\tif (buffer_freed(bh)) {\n\t\tBUFFER_TRACE(bh, \"freed: skip\");\n\t\tgoto unlock;\n\t}\n\tif (!buffer_mapped(bh)) {\n\t\tBUFFER_TRACE(bh, \"unmapped\");\n\t\text4_get_block(inode, iblock, bh, 0);\n\t\t/* unmapped? It's a hole - nothing to do */\n\t\tif (!buffer_mapped(bh)) {\n\t\t\tBUFFER_TRACE(bh, \"still unmapped\");\n\t\t\tgoto unlock;\n\t\t}\n\t}\n\n\t/* Ok, it's mapped. Make sure it's up-to-date */\n\tif (PageUptodate(page))\n\t\tset_buffer_uptodate(bh);\n\n\tif (!buffer_uptodate(bh)) {\n\t\terr = -EIO;\n\t\tll_rw_block(READ, 1, &bh);\n\t\twait_on_buffer(bh);\n\t\t/* Uhhuh. Read error. Complain and punt. */\n\t\tif (!buffer_uptodate(bh))\n\t\t\tgoto unlock;\n\t\tif (S_ISREG(inode->i_mode) &&\n\t\t    ext4_encrypted_inode(inode)) {\n\t\t\t/* We expect the key to be set. */\n\t\t\tBUG_ON(!ext4_has_encryption_key(inode));\n\t\t\tBUG_ON(blocksize != PAGE_SIZE);\n\t\t\tWARN_ON_ONCE(ext4_decrypt(page));\n\t\t}\n\t}\n\tif (ext4_should_journal_data(inode)) {\n\t\tBUFFER_TRACE(bh, \"get write access\");\n\t\terr = ext4_journal_get_write_access(handle, bh);\n\t\tif (err)\n\t\t\tgoto unlock;\n\t}\n\tzero_user(page, offset, length);\n\tBUFFER_TRACE(bh, \"zeroed end of block\");\n\n\tif (ext4_should_journal_data(inode)) {\n\t\terr = ext4_handle_dirty_metadata(handle, inode, bh);\n\t} else {\n\t\terr = 0;\n\t\tmark_buffer_dirty(bh);\n\t\tif (ext4_test_inode_state(inode, EXT4_STATE_ORDERED_MODE))\n\t\t\terr = ext4_jbd2_file_inode(handle, inode);\n\t}\n\nunlock:\n\tunlock_page(page);\n\tput_page(page);\n\treturn err;\n}\n\n/*\n * ext4_block_zero_page_range() zeros out a mapping of length 'length'\n * starting from file offset 'from'.  The range to be zero'd must\n * be contained with in one block.  If the specified range exceeds\n * the end of the block it will be shortened to end of the block\n * that cooresponds to 'from'\n */\nstatic int ext4_block_zero_page_range(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from, loff_t length)\n{\n\tstruct inode *inode = mapping->host;\n\tunsigned offset = from & (PAGE_SIZE-1);\n\tunsigned blocksize = inode->i_sb->s_blocksize;\n\tunsigned max = blocksize - (offset & (blocksize - 1));\n\n\t/*\n\t * correct length if it does not fall between\n\t * 'from' and the end of the block\n\t */\n\tif (length > max || length < 0)\n\t\tlength = max;\n\n\tif (IS_DAX(inode))\n\t\treturn dax_zero_page_range(inode, from, length, ext4_get_block);\n\treturn __ext4_block_zero_page_range(handle, mapping, from, length);\n}\n\n/*\n * ext4_block_truncate_page() zeroes out a mapping from file offset `from'\n * up to the end of the block which corresponds to `from'.\n * This required during truncate. We need to physically zero the tail end\n * of that block so it doesn't yield old data if the file is later grown.\n */\nstatic int ext4_block_truncate_page(handle_t *handle,\n\t\tstruct address_space *mapping, loff_t from)\n{\n\tunsigned offset = from & (PAGE_SIZE-1);\n\tunsigned length;\n\tunsigned blocksize;\n\tstruct inode *inode = mapping->host;\n\n\tblocksize = inode->i_sb->s_blocksize;\n\tlength = blocksize - (offset & (blocksize - 1));\n\n\treturn ext4_block_zero_page_range(handle, mapping, from, length);\n}\n\nint ext4_zero_partial_blocks(handle_t *handle, struct inode *inode,\n\t\t\t     loff_t lstart, loff_t length)\n{\n\tstruct super_block *sb = inode->i_sb;\n\tstruct address_space *mapping = inode->i_mapping;\n\tunsigned partial_start, partial_end;\n\text4_fsblk_t start, end;\n\tloff_t byte_end = (lstart + length - 1);\n\tint err = 0;\n\n\tpartial_start = lstart & (sb->s_blocksize - 1);\n\tpartial_end = byte_end & (sb->s_blocksize - 1);\n\n\tstart = lstart >> sb->s_blocksize_bits;\n\tend = byte_end >> sb->s_blocksize_bits;\n\n\t/* Handle partial zero within the single block */\n\tif (start == end &&\n\t    (partial_start || (partial_end != sb->s_blocksize - 1))) {\n\t\terr = ext4_block_zero_page_range(handle, mapping,\n\t\t\t\t\t\t lstart, length);\n\t\treturn err;\n\t}\n\t/* Handle partial zero out on the start of the range */\n\tif (partial_start) {\n\t\terr = ext4_block_zero_page_range(handle, mapping,\n\t\t\t\t\t\t lstart, sb->s_blocksize);\n\t\tif (err)\n\t\t\treturn err;\n\t}\n\t/* Handle partial zero out on the end of the range */\n\tif (partial_end != sb->s_blocksize - 1)\n\t\terr = ext4_block_zero_page_range(handle, mapping,\n\t\t\t\t\t\t byte_end - partial_end,\n\t\t\t\t\t\t partial_end + 1);\n\treturn err;\n}\n\nint ext4_can_truncate(struct inode *inode)\n{\n\tif (S_ISREG(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISDIR(inode->i_mode))\n\t\treturn 1;\n\tif (S_ISLNK(inode->i_mode))\n\t\treturn !ext4_inode_is_fast_symlink(inode);\n\treturn 0;\n}\n\n/*\n * We have to make sure i_disksize gets properly updated before we truncate\n * page cache due to hole punching or zero range. Otherwise i_disksize update\n * can get lost as it may have been postponed to submission of writeback but\n * that will never happen after we truncate page cache.\n */\nint ext4_update_disksize_before_punch(struct inode *inode, loff_t offset,\n\t\t\t\t      loff_t len)\n{\n\thandle_t *handle;\n\tloff_t size = i_size_read(inode);\n\n\tWARN_ON(!inode_is_locked(inode));\n\tif (offset > size || offset + len < size)\n\t\treturn 0;\n\n\tif (EXT4_I(inode)->i_disksize >= size)\n\t\treturn 0;\n\n\thandle = ext4_journal_start(inode, EXT4_HT_MISC, 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\text4_update_i_disksize(inode, size);\n\text4_mark_inode_dirty(handle, inode);\n\text4_journal_stop(handle);\n\n\treturn 0;\n}\n\n/*\n * ext4_punch_hole: punches a hole in a file by releaseing the blocks\n * associated with the given offset and length\n *\n * @inode:  File inode\n * @offset: The offset where the hole will begin\n * @len:    The length of the hole\n *\n * Returns: 0 on success or negative on failure\n */\n\nint ext4_punch_hole(struct inode *inode, loff_t offset, loff_t length)\n{\n\tstruct super_block *sb = inode->i_sb;\n\text4_lblk_t first_block, stop_block;\n\tstruct address_space *mapping = inode->i_mapping;\n\tloff_t first_block_offset, last_block_offset;\n\thandle_t *handle;\n\tunsigned int credits;\n\tint ret = 0;\n\n\tif (!S_ISREG(inode->i_mode))\n\t\treturn -EOPNOTSUPP;\n\n\ttrace_ext4_punch_hole(inode, offset, length, 0);\n\n\t/*\n\t * Write out all dirty pages to avoid race conditions\n\t * Then release them.\n\t */\n\tif (mapping->nrpages && mapping_tagged(mapping, PAGECACHE_TAG_DIRTY)) {\n\t\tret = filemap_write_and_wait_range(mapping, offset,\n\t\t\t\t\t\t   offset + length - 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tinode_lock(inode);\n\n\t/* No need to punch hole beyond i_size */\n\tif (offset >= inode->i_size)\n\t\tgoto out_mutex;\n\n\t/*\n\t * If the hole extends beyond i_size, set the hole\n\t * to end after the page that contains i_size\n\t */\n\tif (offset + length > inode->i_size) {\n\t\tlength = inode->i_size +\n\t\t   PAGE_SIZE - (inode->i_size & (PAGE_SIZE - 1)) -\n\t\t   offset;\n\t}\n\n\tif (offset & (sb->s_blocksize - 1) ||\n\t    (offset + length) & (sb->s_blocksize - 1)) {\n\t\t/*\n\t\t * Attach jinode to inode for jbd2 if we do any zeroing of\n\t\t * partial block\n\t\t */\n\t\tret = ext4_inode_attach_jinode(inode);\n\t\tif (ret < 0)\n\t\t\tgoto out_mutex;\n\n\t}\n\n\t/* Wait all existing dio workers, newcomers will block on i_mutex */\n\text4_inode_block_unlocked_dio(inode);\n\tinode_dio_wait(inode);\n\n\t/*\n\t * Prevent page faults from reinstantiating pages we have released from\n\t * page cache.\n\t */\n\tdown_write(&EXT4_I(inode)->i_mmap_sem);\n\tfirst_block_offset = round_up(offset, sb->s_blocksize);\n\tlast_block_offset = round_down((offset + length), sb->s_blocksize) - 1;\n\n\t/* Now release the pages and zero block aligned part of pages*/\n\tif (last_block_offset > first_block_offset) {\n\t\tret = ext4_update_disksize_before_punch(inode, offset, length);\n\t\tif (ret)\n\t\t\tgoto out_dio;\n\t\ttruncate_pagecache_range(inode, first_block_offset,\n\t\t\t\t\t last_block_offset);\n\t}\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tcredits = ext4_writepage_trans_blocks(inode);\n\telse\n\t\tcredits = ext4_blocks_for_truncate(inode);\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\tret = PTR_ERR(handle);\n\t\text4_std_error(sb, ret);\n\t\tgoto out_dio;\n\t}\n\n\tret = ext4_zero_partial_blocks(handle, inode, offset,\n\t\t\t\t       length);\n\tif (ret)\n\t\tgoto out_stop;\n\n\tfirst_block = (offset + sb->s_blocksize - 1) >>\n\t\tEXT4_BLOCK_SIZE_BITS(sb);\n\tstop_block = (offset + length) >> EXT4_BLOCK_SIZE_BITS(sb);\n\n\t/* If there are no blocks to remove, return now */\n\tif (first_block >= stop_block)\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\text4_discard_preallocations(inode);\n\n\tret = ext4_es_remove_extent(inode, first_block,\n\t\t\t\t    stop_block - first_block);\n\tif (ret) {\n\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\tgoto out_stop;\n\t}\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tret = ext4_ext_remove_space(inode, first_block,\n\t\t\t\t\t    stop_block - 1);\n\telse\n\t\tret = ext4_ind_remove_space(handle, inode, first_block,\n\t\t\t\t\t    stop_block);\n\n\tup_write(&EXT4_I(inode)->i_data_sem);\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\nout_stop:\n\text4_journal_stop(handle);\nout_dio:\n\tup_write(&EXT4_I(inode)->i_mmap_sem);\n\text4_inode_resume_unlocked_dio(inode);\nout_mutex:\n\tinode_unlock(inode);\n\treturn ret;\n}\n\nint ext4_inode_attach_jinode(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct jbd2_inode *jinode;\n\n\tif (ei->jinode || !EXT4_SB(inode->i_sb)->s_journal)\n\t\treturn 0;\n\n\tjinode = jbd2_alloc_inode(GFP_KERNEL);\n\tspin_lock(&inode->i_lock);\n\tif (!ei->jinode) {\n\t\tif (!jinode) {\n\t\t\tspin_unlock(&inode->i_lock);\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tei->jinode = jinode;\n\t\tjbd2_journal_init_jbd_inode(ei->jinode, inode);\n\t\tjinode = NULL;\n\t}\n\tspin_unlock(&inode->i_lock);\n\tif (unlikely(jinode != NULL))\n\t\tjbd2_free_inode(jinode);\n\treturn 0;\n}\n\n/*\n * ext4_truncate()\n *\n * We block out ext4_get_block() block instantiations across the entire\n * transaction, and VFS/VM ensures that ext4_truncate() cannot run\n * simultaneously on behalf of the same inode.\n *\n * As we work through the truncate and commit bits of it to the journal there\n * is one core, guiding principle: the file's tree must always be consistent on\n * disk.  We must be able to restart the truncate after a crash.\n *\n * The file's tree may be transiently inconsistent in memory (although it\n * probably isn't), but whenever we close off and commit a journal transaction,\n * the contents of (the filesystem + the journal) must be consistent and\n * restartable.  It's pretty simple, really: bottom up, right to left (although\n * left-to-right works OK too).\n *\n * Note that at recovery time, journal replay occurs *before* the restart of\n * truncate against the orphan inode list.\n *\n * The committed inode has the new, desired i_size (which is the same as\n * i_disksize in this case).  After a crash, ext4_orphan_cleanup() will see\n * that this inode's truncate did not complete and it will again call\n * ext4_truncate() to have another go.  So there will be instantiated blocks\n * to the right of the truncation point in a crashed ext4 filesystem.  But\n * that's fine - as long as they are linked from the inode, the post-crash\n * ext4_truncate() run will find them and release them.\n */\nvoid ext4_truncate(struct inode *inode)\n{\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tunsigned int credits;\n\thandle_t *handle;\n\tstruct address_space *mapping = inode->i_mapping;\n\n\t/*\n\t * There is a possibility that we're either freeing the inode\n\t * or it's a completely new inode. In those cases we might not\n\t * have i_mutex locked because it's not necessary.\n\t */\n\tif (!(inode->i_state & (I_NEW|I_FREEING)))\n\t\tWARN_ON(!inode_is_locked(inode));\n\ttrace_ext4_truncate_enter(inode);\n\n\tif (!ext4_can_truncate(inode))\n\t\treturn;\n\n\text4_clear_inode_flag(inode, EXT4_INODE_EOFBLOCKS);\n\n\tif (inode->i_size == 0 && !test_opt(inode->i_sb, NO_AUTO_DA_ALLOC))\n\t\text4_set_inode_state(inode, EXT4_STATE_DA_ALLOC_CLOSE);\n\n\tif (ext4_has_inline_data(inode)) {\n\t\tint has_inline = 1;\n\n\t\text4_inline_data_truncate(inode, &has_inline);\n\t\tif (has_inline)\n\t\t\treturn;\n\t}\n\n\t/* If we zero-out tail of the page, we have to create jinode for jbd2 */\n\tif (inode->i_size & (inode->i_sb->s_blocksize - 1)) {\n\t\tif (ext4_inode_attach_jinode(inode) < 0)\n\t\t\treturn;\n\t}\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\tcredits = ext4_writepage_trans_blocks(inode);\n\telse\n\t\tcredits = ext4_blocks_for_truncate(inode);\n\n\thandle = ext4_journal_start(inode, EXT4_HT_TRUNCATE, credits);\n\tif (IS_ERR(handle)) {\n\t\text4_std_error(inode->i_sb, PTR_ERR(handle));\n\t\treturn;\n\t}\n\n\tif (inode->i_size & (inode->i_sb->s_blocksize - 1))\n\t\text4_block_truncate_page(handle, mapping, inode->i_size);\n\n\t/*\n\t * We add the inode to the orphan list, so that if this\n\t * truncate spans multiple transactions, and we crash, we will\n\t * resume the truncate when the filesystem recovers.  It also\n\t * marks the inode dirty, to catch the new size.\n\t *\n\t * Implication: the file must always be in a sane, consistent\n\t * truncatable state while each transaction commits.\n\t */\n\tif (ext4_orphan_add(handle, inode))\n\t\tgoto out_stop;\n\n\tdown_write(&EXT4_I(inode)->i_data_sem);\n\n\text4_discard_preallocations(inode);\n\n\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))\n\t\text4_ext_truncate(handle, inode);\n\telse\n\t\text4_ind_truncate(handle, inode);\n\n\tup_write(&ei->i_data_sem);\n\n\tif (IS_SYNC(inode))\n\t\text4_handle_sync(handle);\n\nout_stop:\n\t/*\n\t * If this was a simple ftruncate() and the file will remain alive,\n\t * then we need to clear up the orphan record which we created above.\n\t * However, if this was a real unlink then we were called by\n\t * ext4_evict_inode(), and we allow that function to clean up the\n\t * orphan info for us.\n\t */\n\tif (inode->i_nlink)\n\t\text4_orphan_del(handle, inode);\n\n\tinode->i_mtime = inode->i_ctime = ext4_current_time(inode);\n\text4_mark_inode_dirty(handle, inode);\n\text4_journal_stop(handle);\n\n\ttrace_ext4_truncate_exit(inode);\n}\n\n/*\n * ext4_get_inode_loc returns with an extra refcount against the inode's\n * underlying buffer_head on success. If 'in_mem' is true, we have all\n * data in memory that is needed to recreate the on-disk version of this\n * inode.\n */\nstatic int __ext4_get_inode_loc(struct inode *inode,\n\t\t\t\tstruct ext4_iloc *iloc, int in_mem)\n{\n\tstruct ext4_group_desc\t*gdp;\n\tstruct buffer_head\t*bh;\n\tstruct super_block\t*sb = inode->i_sb;\n\text4_fsblk_t\t\tblock;\n\tint\t\t\tinodes_per_block, inode_offset;\n\n\tiloc->bh = NULL;\n\tif (!ext4_valid_inum(sb, inode->i_ino))\n\t\treturn -EFSCORRUPTED;\n\n\tiloc->block_group = (inode->i_ino - 1) / EXT4_INODES_PER_GROUP(sb);\n\tgdp = ext4_get_group_desc(sb, iloc->block_group, NULL);\n\tif (!gdp)\n\t\treturn -EIO;\n\n\t/*\n\t * Figure out the offset within the block group inode table\n\t */\n\tinodes_per_block = EXT4_SB(sb)->s_inodes_per_block;\n\tinode_offset = ((inode->i_ino - 1) %\n\t\t\tEXT4_INODES_PER_GROUP(sb));\n\tblock = ext4_inode_table(sb, gdp) + (inode_offset / inodes_per_block);\n\tiloc->offset = (inode_offset % inodes_per_block) * EXT4_INODE_SIZE(sb);\n\n\tbh = sb_getblk(sb, block);\n\tif (unlikely(!bh))\n\t\treturn -ENOMEM;\n\tif (!buffer_uptodate(bh)) {\n\t\tlock_buffer(bh);\n\n\t\t/*\n\t\t * If the buffer has the write error flag, we have failed\n\t\t * to write out another inode in the same block.  In this\n\t\t * case, we don't have to read the block because we may\n\t\t * read the old inode data successfully.\n\t\t */\n\t\tif (buffer_write_io_error(bh) && !buffer_uptodate(bh))\n\t\t\tset_buffer_uptodate(bh);\n\n\t\tif (buffer_uptodate(bh)) {\n\t\t\t/* someone brought it uptodate while we waited */\n\t\t\tunlock_buffer(bh);\n\t\t\tgoto has_buffer;\n\t\t}\n\n\t\t/*\n\t\t * If we have all information of the inode in memory and this\n\t\t * is the only valid inode in the block, we need not read the\n\t\t * block.\n\t\t */\n\t\tif (in_mem) {\n\t\t\tstruct buffer_head *bitmap_bh;\n\t\t\tint i, start;\n\n\t\t\tstart = inode_offset & ~(inodes_per_block - 1);\n\n\t\t\t/* Is the inode bitmap in cache? */\n\t\t\tbitmap_bh = sb_getblk(sb, ext4_inode_bitmap(sb, gdp));\n\t\t\tif (unlikely(!bitmap_bh))\n\t\t\t\tgoto make_io;\n\n\t\t\t/*\n\t\t\t * If the inode bitmap isn't in cache then the\n\t\t\t * optimisation may end up performing two reads instead\n\t\t\t * of one, so skip it.\n\t\t\t */\n\t\t\tif (!buffer_uptodate(bitmap_bh)) {\n\t\t\t\tbrelse(bitmap_bh);\n\t\t\t\tgoto make_io;\n\t\t\t}\n\t\t\tfor (i = start; i < start + inodes_per_block; i++) {\n\t\t\t\tif (i == inode_offset)\n\t\t\t\t\tcontinue;\n\t\t\t\tif (ext4_test_bit(i, bitmap_bh->b_data))\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbrelse(bitmap_bh);\n\t\t\tif (i == start + inodes_per_block) {\n\t\t\t\t/* all other inodes are free, so skip I/O */\n\t\t\t\tmemset(bh->b_data, 0, bh->b_size);\n\t\t\t\tset_buffer_uptodate(bh);\n\t\t\t\tunlock_buffer(bh);\n\t\t\t\tgoto has_buffer;\n\t\t\t}\n\t\t}\n\nmake_io:\n\t\t/*\n\t\t * If we need to do any I/O, try to pre-readahead extra\n\t\t * blocks from the inode table.\n\t\t */\n\t\tif (EXT4_SB(sb)->s_inode_readahead_blks) {\n\t\t\text4_fsblk_t b, end, table;\n\t\t\tunsigned num;\n\t\t\t__u32 ra_blks = EXT4_SB(sb)->s_inode_readahead_blks;\n\n\t\t\ttable = ext4_inode_table(sb, gdp);\n\t\t\t/* s_inode_readahead_blks is always a power of 2 */\n\t\t\tb = block & ~((ext4_fsblk_t) ra_blks - 1);\n\t\t\tif (table > b)\n\t\t\t\tb = table;\n\t\t\tend = b + ra_blks;\n\t\t\tnum = EXT4_INODES_PER_GROUP(sb);\n\t\t\tif (ext4_has_group_desc_csum(sb))\n\t\t\t\tnum -= ext4_itable_unused_count(sb, gdp);\n\t\t\ttable += num / inodes_per_block;\n\t\t\tif (end > table)\n\t\t\t\tend = table;\n\t\t\twhile (b <= end)\n\t\t\t\tsb_breadahead(sb, b++);\n\t\t}\n\n\t\t/*\n\t\t * There are other valid inodes in the buffer, this inode\n\t\t * has in-inode xattrs, or we don't have this inode in memory.\n\t\t * Read the block from disk.\n\t\t */\n\t\ttrace_ext4_load_inode(inode);\n\t\tget_bh(bh);\n\t\tbh->b_end_io = end_buffer_read_sync;\n\t\tsubmit_bh(READ | REQ_META | REQ_PRIO, bh);\n\t\twait_on_buffer(bh);\n\t\tif (!buffer_uptodate(bh)) {\n\t\t\tEXT4_ERROR_INODE_BLOCK(inode, block,\n\t\t\t\t\t       \"unable to read itable block\");\n\t\t\tbrelse(bh);\n\t\t\treturn -EIO;\n\t\t}\n\t}\nhas_buffer:\n\tiloc->bh = bh;\n\treturn 0;\n}\n\nint ext4_get_inode_loc(struct inode *inode, struct ext4_iloc *iloc)\n{\n\t/* We have all inode data except xattrs in memory here. */\n\treturn __ext4_get_inode_loc(inode, iloc,\n\t\t!ext4_test_inode_state(inode, EXT4_STATE_XATTR));\n}\n\nvoid ext4_set_inode_flags(struct inode *inode)\n{\n\tunsigned int flags = EXT4_I(inode)->i_flags;\n\tunsigned int new_fl = 0;\n\n\tif (flags & EXT4_SYNC_FL)\n\t\tnew_fl |= S_SYNC;\n\tif (flags & EXT4_APPEND_FL)\n\t\tnew_fl |= S_APPEND;\n\tif (flags & EXT4_IMMUTABLE_FL)\n\t\tnew_fl |= S_IMMUTABLE;\n\tif (flags & EXT4_NOATIME_FL)\n\t\tnew_fl |= S_NOATIME;\n\tif (flags & EXT4_DIRSYNC_FL)\n\t\tnew_fl |= S_DIRSYNC;\n\tif (test_opt(inode->i_sb, DAX) && S_ISREG(inode->i_mode))\n\t\tnew_fl |= S_DAX;\n\tinode_set_flags(inode, new_fl,\n\t\t\tS_SYNC|S_APPEND|S_IMMUTABLE|S_NOATIME|S_DIRSYNC|S_DAX);\n}\n\n/* Propagate flags from i_flags to EXT4_I(inode)->i_flags */\nvoid ext4_get_inode_flags(struct ext4_inode_info *ei)\n{\n\tunsigned int vfs_fl;\n\tunsigned long old_fl, new_fl;\n\n\tdo {\n\t\tvfs_fl = ei->vfs_inode.i_flags;\n\t\told_fl = ei->i_flags;\n\t\tnew_fl = old_fl & ~(EXT4_SYNC_FL|EXT4_APPEND_FL|\n\t\t\t\tEXT4_IMMUTABLE_FL|EXT4_NOATIME_FL|\n\t\t\t\tEXT4_DIRSYNC_FL);\n\t\tif (vfs_fl & S_SYNC)\n\t\t\tnew_fl |= EXT4_SYNC_FL;\n\t\tif (vfs_fl & S_APPEND)\n\t\t\tnew_fl |= EXT4_APPEND_FL;\n\t\tif (vfs_fl & S_IMMUTABLE)\n\t\t\tnew_fl |= EXT4_IMMUTABLE_FL;\n\t\tif (vfs_fl & S_NOATIME)\n\t\t\tnew_fl |= EXT4_NOATIME_FL;\n\t\tif (vfs_fl & S_DIRSYNC)\n\t\t\tnew_fl |= EXT4_DIRSYNC_FL;\n\t} while (cmpxchg(&ei->i_flags, old_fl, new_fl) != old_fl);\n}\n\nstatic blkcnt_t ext4_inode_blocks(struct ext4_inode *raw_inode,\n\t\t\t\t  struct ext4_inode_info *ei)\n{\n\tblkcnt_t i_blocks ;\n\tstruct inode *inode = &(ei->vfs_inode);\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (ext4_has_feature_huge_file(sb)) {\n\t\t/* we are using combined 48 bit field */\n\t\ti_blocks = ((u64)le16_to_cpu(raw_inode->i_blocks_high)) << 32 |\n\t\t\t\t\tle32_to_cpu(raw_inode->i_blocks_lo);\n\t\tif (ext4_test_inode_flag(inode, EXT4_INODE_HUGE_FILE)) {\n\t\t\t/* i_blocks represent file system block size */\n\t\t\treturn i_blocks  << (inode->i_blkbits - 9);\n\t\t} else {\n\t\t\treturn i_blocks;\n\t\t}\n\t} else {\n\t\treturn le32_to_cpu(raw_inode->i_blocks_lo);\n\t}\n}\n\nstatic inline void ext4_iget_extra_inode(struct inode *inode,\n\t\t\t\t\t struct ext4_inode *raw_inode,\n\t\t\t\t\t struct ext4_inode_info *ei)\n{\n\t__le32 *magic = (void *)raw_inode +\n\t\t\tEXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize;\n\tif (*magic == cpu_to_le32(EXT4_XATTR_MAGIC)) {\n\t\text4_set_inode_state(inode, EXT4_STATE_XATTR);\n\t\text4_find_inline_data_nolock(inode);\n\t} else\n\t\tEXT4_I(inode)->i_inline_off = 0;\n}\n\nint ext4_get_projid(struct inode *inode, kprojid_t *projid)\n{\n\tif (!EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb, EXT4_FEATURE_RO_COMPAT_PROJECT))\n\t\treturn -EOPNOTSUPP;\n\t*projid = EXT4_I(inode)->i_projid;\n\treturn 0;\n}\n\nstruct inode *ext4_iget(struct super_block *sb, unsigned long ino)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_inode_info *ei;\n\tstruct inode *inode;\n\tjournal_t *journal = EXT4_SB(sb)->s_journal;\n\tlong ret;\n\tint block;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\tprojid_t i_projid;\n\n\tinode = iget_locked(sb, ino);\n\tif (!inode)\n\t\treturn ERR_PTR(-ENOMEM);\n\tif (!(inode->i_state & I_NEW))\n\t\treturn inode;\n\n\tei = EXT4_I(inode);\n\tiloc.bh = NULL;\n\n\tret = __ext4_get_inode_loc(inode, &iloc, 0);\n\tif (ret < 0)\n\t\tgoto bad_inode;\n\traw_inode = ext4_raw_inode(&iloc);\n\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tei->i_extra_isize = le16_to_cpu(raw_inode->i_extra_isize);\n\t\tif (EXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize >\n\t\t    EXT4_INODE_SIZE(inode->i_sb)) {\n\t\t\tEXT4_ERROR_INODE(inode, \"bad extra_isize (%u != %u)\",\n\t\t\t\tEXT4_GOOD_OLD_INODE_SIZE + ei->i_extra_isize,\n\t\t\t\tEXT4_INODE_SIZE(inode->i_sb));\n\t\t\tret = -EFSCORRUPTED;\n\t\t\tgoto bad_inode;\n\t\t}\n\t} else\n\t\tei->i_extra_isize = 0;\n\n\t/* Precompute checksum seed for inode metadata */\n\tif (ext4_has_metadata_csum(sb)) {\n\t\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\t\t__u32 csum;\n\t\t__le32 inum = cpu_to_le32(inode->i_ino);\n\t\t__le32 gen = raw_inode->i_generation;\n\t\tcsum = ext4_chksum(sbi, sbi->s_csum_seed, (__u8 *)&inum,\n\t\t\t\t   sizeof(inum));\n\t\tei->i_csum_seed = ext4_chksum(sbi, csum, (__u8 *)&gen,\n\t\t\t\t\t      sizeof(gen));\n\t}\n\n\tif (!ext4_inode_csum_verify(inode, raw_inode, ei)) {\n\t\tEXT4_ERROR_INODE(inode, \"checksum invalid\");\n\t\tret = -EFSBADCRC;\n\t\tgoto bad_inode;\n\t}\n\n\tinode->i_mode = le16_to_cpu(raw_inode->i_mode);\n\ti_uid = (uid_t)le16_to_cpu(raw_inode->i_uid_low);\n\ti_gid = (gid_t)le16_to_cpu(raw_inode->i_gid_low);\n\tif (EXT4_HAS_RO_COMPAT_FEATURE(sb, EXT4_FEATURE_RO_COMPAT_PROJECT) &&\n\t    EXT4_INODE_SIZE(sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw_inode, ei, i_projid))\n\t\ti_projid = (projid_t)le32_to_cpu(raw_inode->i_projid);\n\telse\n\t\ti_projid = EXT4_DEF_PROJID;\n\n\tif (!(test_opt(inode->i_sb, NO_UID32))) {\n\t\ti_uid |= le16_to_cpu(raw_inode->i_uid_high) << 16;\n\t\ti_gid |= le16_to_cpu(raw_inode->i_gid_high) << 16;\n\t}\n\ti_uid_write(inode, i_uid);\n\ti_gid_write(inode, i_gid);\n\tei->i_projid = make_kprojid(&init_user_ns, i_projid);\n\tset_nlink(inode, le16_to_cpu(raw_inode->i_links_count));\n\n\text4_clear_state_flags(ei);\t/* Only relevant on 32-bit archs */\n\tei->i_inline_off = 0;\n\tei->i_dir_start_lookup = 0;\n\tei->i_dtime = le32_to_cpu(raw_inode->i_dtime);\n\t/* We now have enough fields to check if the inode was active or not.\n\t * This is needed because nfsd might try to access dead inodes\n\t * the test is that same one that e2fsck uses\n\t * NeilBrown 1999oct15\n\t */\n\tif (inode->i_nlink == 0) {\n\t\tif ((inode->i_mode == 0 ||\n\t\t     !(EXT4_SB(inode->i_sb)->s_mount_state & EXT4_ORPHAN_FS)) &&\n\t\t    ino != EXT4_BOOT_LOADER_INO) {\n\t\t\t/* this inode is deleted */\n\t\t\tret = -ESTALE;\n\t\t\tgoto bad_inode;\n\t\t}\n\t\t/* The only unlinked inodes we let through here have\n\t\t * valid i_mode and are being read by the orphan\n\t\t * recovery code: that's fine, we're about to complete\n\t\t * the process of deleting those.\n\t\t * OR it is the EXT4_BOOT_LOADER_INO which is\n\t\t * not initialized on a new filesystem. */\n\t}\n\tei->i_flags = le32_to_cpu(raw_inode->i_flags);\n\tinode->i_blocks = ext4_inode_blocks(raw_inode, ei);\n\tei->i_file_acl = le32_to_cpu(raw_inode->i_file_acl_lo);\n\tif (ext4_has_feature_64bit(sb))\n\t\tei->i_file_acl |=\n\t\t\t((__u64)le16_to_cpu(raw_inode->i_file_acl_high)) << 32;\n\tinode->i_size = ext4_isize(raw_inode);\n\tei->i_disksize = inode->i_size;\n#ifdef CONFIG_QUOTA\n\tei->i_reserved_quota = 0;\n#endif\n\tinode->i_generation = le32_to_cpu(raw_inode->i_generation);\n\tei->i_block_group = iloc.block_group;\n\tei->i_last_alloc_group = ~0;\n\t/*\n\t * NOTE! The in-memory inode i_data array is in little-endian order\n\t * even on big-endian machines: we do NOT byteswap the block numbers!\n\t */\n\tfor (block = 0; block < EXT4_N_BLOCKS; block++)\n\t\tei->i_data[block] = raw_inode->i_block[block];\n\tINIT_LIST_HEAD(&ei->i_orphan);\n\n\t/*\n\t * Set transaction id's of transactions that have to be committed\n\t * to finish f[data]sync. We set them to currently running transaction\n\t * as we cannot be sure that the inode or some of its metadata isn't\n\t * part of the transaction - the inode could have been reclaimed and\n\t * now it is reread from disk.\n\t */\n\tif (journal) {\n\t\ttransaction_t *transaction;\n\t\ttid_t tid;\n\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_running_transaction)\n\t\t\ttransaction = journal->j_running_transaction;\n\t\telse\n\t\t\ttransaction = journal->j_committing_transaction;\n\t\tif (transaction)\n\t\t\ttid = transaction->t_tid;\n\t\telse\n\t\t\ttid = journal->j_commit_sequence;\n\t\tread_unlock(&journal->j_state_lock);\n\t\tei->i_sync_tid = tid;\n\t\tei->i_datasync_tid = tid;\n\t}\n\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\tif (ei->i_extra_isize == 0) {\n\t\t\t/* The extra space is currently unused. Use it. */\n\t\t\tei->i_extra_isize = sizeof(struct ext4_inode) -\n\t\t\t\t\t    EXT4_GOOD_OLD_INODE_SIZE;\n\t\t} else {\n\t\t\text4_iget_extra_inode(inode, raw_inode, ei);\n\t\t}\n\t}\n\n\tEXT4_INODE_GET_XTIME(i_ctime, inode, raw_inode);\n\tEXT4_INODE_GET_XTIME(i_mtime, inode, raw_inode);\n\tEXT4_INODE_GET_XTIME(i_atime, inode, raw_inode);\n\tEXT4_EINODE_GET_XTIME(i_crtime, ei, raw_inode);\n\n\tif (likely(!test_opt2(inode->i_sb, HURD_COMPAT))) {\n\t\tinode->i_version = le32_to_cpu(raw_inode->i_disk_version);\n\t\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE) {\n\t\t\tif (EXT4_FITS_IN_INODE(raw_inode, ei, i_version_hi))\n\t\t\t\tinode->i_version |=\n\t\t    (__u64)(le32_to_cpu(raw_inode->i_version_hi)) << 32;\n\t\t}\n\t}\n\n\tret = 0;\n\tif (ei->i_file_acl &&\n\t    !ext4_data_block_valid(EXT4_SB(sb), ei->i_file_acl, 1)) {\n\t\tEXT4_ERROR_INODE(inode, \"bad extended attribute block %llu\",\n\t\t\t\t ei->i_file_acl);\n\t\tret = -EFSCORRUPTED;\n\t\tgoto bad_inode;\n\t} else if (!ext4_has_inline_data(inode)) {\n\t\tif (ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)) {\n\t\t\tif ((S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t    (S_ISLNK(inode->i_mode) &&\n\t\t\t     !ext4_inode_is_fast_symlink(inode))))\n\t\t\t\t/* Validate extent which is part of inode */\n\t\t\t\tret = ext4_ext_check_inode(inode);\n\t\t} else if (S_ISREG(inode->i_mode) || S_ISDIR(inode->i_mode) ||\n\t\t\t   (S_ISLNK(inode->i_mode) &&\n\t\t\t    !ext4_inode_is_fast_symlink(inode))) {\n\t\t\t/* Validate block references which are part of inode */\n\t\t\tret = ext4_ind_check_inode(inode);\n\t\t}\n\t}\n\tif (ret)\n\t\tgoto bad_inode;\n\n\tif (S_ISREG(inode->i_mode)) {\n\t\tinode->i_op = &ext4_file_inode_operations;\n\t\tinode->i_fop = &ext4_file_operations;\n\t\text4_set_aops(inode);\n\t} else if (S_ISDIR(inode->i_mode)) {\n\t\tinode->i_op = &ext4_dir_inode_operations;\n\t\tinode->i_fop = &ext4_dir_operations;\n\t} else if (S_ISLNK(inode->i_mode)) {\n\t\tif (ext4_encrypted_inode(inode)) {\n\t\t\tinode->i_op = &ext4_encrypted_symlink_inode_operations;\n\t\t\text4_set_aops(inode);\n\t\t} else if (ext4_inode_is_fast_symlink(inode)) {\n\t\t\tinode->i_link = (char *)ei->i_data;\n\t\t\tinode->i_op = &ext4_fast_symlink_inode_operations;\n\t\t\tnd_terminate_link(ei->i_data, inode->i_size,\n\t\t\t\tsizeof(ei->i_data) - 1);\n\t\t} else {\n\t\t\tinode->i_op = &ext4_symlink_inode_operations;\n\t\t\text4_set_aops(inode);\n\t\t}\n\t\tinode_nohighmem(inode);\n\t} else if (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode) ||\n\t      S_ISFIFO(inode->i_mode) || S_ISSOCK(inode->i_mode)) {\n\t\tinode->i_op = &ext4_special_inode_operations;\n\t\tif (raw_inode->i_block[0])\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   old_decode_dev(le32_to_cpu(raw_inode->i_block[0])));\n\t\telse\n\t\t\tinit_special_inode(inode, inode->i_mode,\n\t\t\t   new_decode_dev(le32_to_cpu(raw_inode->i_block[1])));\n\t} else if (ino == EXT4_BOOT_LOADER_INO) {\n\t\tmake_bad_inode(inode);\n\t} else {\n\t\tret = -EFSCORRUPTED;\n\t\tEXT4_ERROR_INODE(inode, \"bogus i_mode (%o)\", inode->i_mode);\n\t\tgoto bad_inode;\n\t}\n\tbrelse(iloc.bh);\n\text4_set_inode_flags(inode);\n\tunlock_new_inode(inode);\n\treturn inode;\n\nbad_inode:\n\tbrelse(iloc.bh);\n\tiget_failed(inode);\n\treturn ERR_PTR(ret);\n}\n\nstruct inode *ext4_iget_normal(struct super_block *sb, unsigned long ino)\n{\n\tif (ino < EXT4_FIRST_INO(sb) && ino != EXT4_ROOT_INO)\n\t\treturn ERR_PTR(-EFSCORRUPTED);\n\treturn ext4_iget(sb, ino);\n}\n\nstatic int ext4_inode_blocks_set(handle_t *handle,\n\t\t\t\tstruct ext4_inode *raw_inode,\n\t\t\t\tstruct ext4_inode_info *ei)\n{\n\tstruct inode *inode = &(ei->vfs_inode);\n\tu64 i_blocks = inode->i_blocks;\n\tstruct super_block *sb = inode->i_sb;\n\n\tif (i_blocks <= ~0U) {\n\t\t/*\n\t\t * i_blocks can be represented in a 32 bit variable\n\t\t * as multiple of 512 bytes\n\t\t */\n\t\traw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);\n\t\traw_inode->i_blocks_high = 0;\n\t\text4_clear_inode_flag(inode, EXT4_INODE_HUGE_FILE);\n\t\treturn 0;\n\t}\n\tif (!ext4_has_feature_huge_file(sb))\n\t\treturn -EFBIG;\n\n\tif (i_blocks <= 0xffffffffffffULL) {\n\t\t/*\n\t\t * i_blocks can be represented in a 48 bit variable\n\t\t * as multiple of 512 bytes\n\t\t */\n\t\traw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);\n\t\traw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);\n\t\text4_clear_inode_flag(inode, EXT4_INODE_HUGE_FILE);\n\t} else {\n\t\text4_set_inode_flag(inode, EXT4_INODE_HUGE_FILE);\n\t\t/* i_block is stored in file system block size */\n\t\ti_blocks = i_blocks >> (inode->i_blkbits - 9);\n\t\traw_inode->i_blocks_lo   = cpu_to_le32(i_blocks);\n\t\traw_inode->i_blocks_high = cpu_to_le16(i_blocks >> 32);\n\t}\n\treturn 0;\n}\n\nstruct other_inode {\n\tunsigned long\t\torig_ino;\n\tstruct ext4_inode\t*raw_inode;\n};\n\nstatic int other_inode_match(struct inode * inode, unsigned long ino,\n\t\t\t     void *data)\n{\n\tstruct other_inode *oi = (struct other_inode *) data;\n\n\tif ((inode->i_ino != ino) ||\n\t    (inode->i_state & (I_FREEING | I_WILL_FREE | I_NEW |\n\t\t\t       I_DIRTY_SYNC | I_DIRTY_DATASYNC)) ||\n\t    ((inode->i_state & I_DIRTY_TIME) == 0))\n\t\treturn 0;\n\tspin_lock(&inode->i_lock);\n\tif (((inode->i_state & (I_FREEING | I_WILL_FREE | I_NEW |\n\t\t\t\tI_DIRTY_SYNC | I_DIRTY_DATASYNC)) == 0) &&\n\t    (inode->i_state & I_DIRTY_TIME)) {\n\t\tstruct ext4_inode_info\t*ei = EXT4_I(inode);\n\n\t\tinode->i_state &= ~(I_DIRTY_TIME | I_DIRTY_TIME_EXPIRED);\n\t\tspin_unlock(&inode->i_lock);\n\n\t\tspin_lock(&ei->i_raw_lock);\n\t\tEXT4_INODE_SET_XTIME(i_ctime, inode, oi->raw_inode);\n\t\tEXT4_INODE_SET_XTIME(i_mtime, inode, oi->raw_inode);\n\t\tEXT4_INODE_SET_XTIME(i_atime, inode, oi->raw_inode);\n\t\text4_inode_csum_set(inode, oi->raw_inode, ei);\n\t\tspin_unlock(&ei->i_raw_lock);\n\t\ttrace_ext4_other_inode_update_time(inode, oi->orig_ino);\n\t\treturn -1;\n\t}\n\tspin_unlock(&inode->i_lock);\n\treturn -1;\n}\n\n/*\n * Opportunistically update the other time fields for other inodes in\n * the same inode table block.\n */\nstatic void ext4_update_other_inodes_time(struct super_block *sb,\n\t\t\t\t\t  unsigned long orig_ino, char *buf)\n{\n\tstruct other_inode oi;\n\tunsigned long ino;\n\tint i, inodes_per_block = EXT4_SB(sb)->s_inodes_per_block;\n\tint inode_size = EXT4_INODE_SIZE(sb);\n\n\toi.orig_ino = orig_ino;\n\t/*\n\t * Calculate the first inode in the inode table block.  Inode\n\t * numbers are one-based.  That is, the first inode in a block\n\t * (assuming 4k blocks and 256 byte inodes) is (n*16 + 1).\n\t */\n\tino = ((orig_ino - 1) & ~(inodes_per_block - 1)) + 1;\n\tfor (i = 0; i < inodes_per_block; i++, ino++, buf += inode_size) {\n\t\tif (ino == orig_ino)\n\t\t\tcontinue;\n\t\toi.raw_inode = (struct ext4_inode *) buf;\n\t\t(void) find_inode_nowait(sb, ino, other_inode_match, &oi);\n\t}\n}\n\n/*\n * Post the struct inode info into an on-disk inode location in the\n * buffer-cache.  This gobbles the caller's reference to the\n * buffer_head in the inode location struct.\n *\n * The caller must have write access to iloc->bh.\n */\nstatic int ext4_do_update_inode(handle_t *handle,\n\t\t\t\tstruct inode *inode,\n\t\t\t\tstruct ext4_iloc *iloc)\n{\n\tstruct ext4_inode *raw_inode = ext4_raw_inode(iloc);\n\tstruct ext4_inode_info *ei = EXT4_I(inode);\n\tstruct buffer_head *bh = iloc->bh;\n\tstruct super_block *sb = inode->i_sb;\n\tint err = 0, rc, block;\n\tint need_datasync = 0, set_large_file = 0;\n\tuid_t i_uid;\n\tgid_t i_gid;\n\tprojid_t i_projid;\n\n\tspin_lock(&ei->i_raw_lock);\n\n\t/* For fields not tracked in the in-memory inode,\n\t * initialise them to zero for new inodes. */\n\tif (ext4_test_inode_state(inode, EXT4_STATE_NEW))\n\t\tmemset(raw_inode, 0, EXT4_SB(inode->i_sb)->s_inode_size);\n\n\text4_get_inode_flags(ei);\n\traw_inode->i_mode = cpu_to_le16(inode->i_mode);\n\ti_uid = i_uid_read(inode);\n\ti_gid = i_gid_read(inode);\n\ti_projid = from_kprojid(&init_user_ns, ei->i_projid);\n\tif (!(test_opt(inode->i_sb, NO_UID32))) {\n\t\traw_inode->i_uid_low = cpu_to_le16(low_16_bits(i_uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(low_16_bits(i_gid));\n/*\n * Fix up interoperability with old kernels. Otherwise, old inodes get\n * re-used with the upper 16 bits of the uid/gid intact\n */\n\t\tif (!ei->i_dtime) {\n\t\t\traw_inode->i_uid_high =\n\t\t\t\tcpu_to_le16(high_16_bits(i_uid));\n\t\t\traw_inode->i_gid_high =\n\t\t\t\tcpu_to_le16(high_16_bits(i_gid));\n\t\t} else {\n\t\t\traw_inode->i_uid_high = 0;\n\t\t\traw_inode->i_gid_high = 0;\n\t\t}\n\t} else {\n\t\traw_inode->i_uid_low = cpu_to_le16(fs_high2lowuid(i_uid));\n\t\traw_inode->i_gid_low = cpu_to_le16(fs_high2lowgid(i_gid));\n\t\traw_inode->i_uid_high = 0;\n\t\traw_inode->i_gid_high = 0;\n\t}\n\traw_inode->i_links_count = cpu_to_le16(inode->i_nlink);\n\n\tEXT4_INODE_SET_XTIME(i_ctime, inode, raw_inode);\n\tEXT4_INODE_SET_XTIME(i_mtime, inode, raw_inode);\n\tEXT4_INODE_SET_XTIME(i_atime, inode, raw_inode);\n\tEXT4_EINODE_SET_XTIME(i_crtime, ei, raw_inode);\n\n\terr = ext4_inode_blocks_set(handle, raw_inode, ei);\n\tif (err) {\n\t\tspin_unlock(&ei->i_raw_lock);\n\t\tgoto out_brelse;\n\t}\n\traw_inode->i_dtime = cpu_to_le32(ei->i_dtime);\n\traw_inode->i_flags = cpu_to_le32(ei->i_flags & 0xFFFFFFFF);\n\tif (likely(!test_opt2(inode->i_sb, HURD_COMPAT)))\n\t\traw_inode->i_file_acl_high =\n\t\t\tcpu_to_le16(ei->i_file_acl >> 32);\n\traw_inode->i_file_acl_lo = cpu_to_le32(ei->i_file_acl);\n\tif (ei->i_disksize != ext4_isize(raw_inode)) {\n\t\text4_isize_set(raw_inode, ei->i_disksize);\n\t\tneed_datasync = 1;\n\t}\n\tif (ei->i_disksize > 0x7fffffffULL) {\n\t\tif (!ext4_has_feature_large_file(sb) ||\n\t\t\t\tEXT4_SB(sb)->s_es->s_rev_level ==\n\t\t    cpu_to_le32(EXT4_GOOD_OLD_REV))\n\t\t\tset_large_file = 1;\n\t}\n\traw_inode->i_generation = cpu_to_le32(inode->i_generation);\n\tif (S_ISCHR(inode->i_mode) || S_ISBLK(inode->i_mode)) {\n\t\tif (old_valid_dev(inode->i_rdev)) {\n\t\t\traw_inode->i_block[0] =\n\t\t\t\tcpu_to_le32(old_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[1] = 0;\n\t\t} else {\n\t\t\traw_inode->i_block[0] = 0;\n\t\t\traw_inode->i_block[1] =\n\t\t\t\tcpu_to_le32(new_encode_dev(inode->i_rdev));\n\t\t\traw_inode->i_block[2] = 0;\n\t\t}\n\t} else if (!ext4_has_inline_data(inode)) {\n\t\tfor (block = 0; block < EXT4_N_BLOCKS; block++)\n\t\t\traw_inode->i_block[block] = ei->i_data[block];\n\t}\n\n\tif (likely(!test_opt2(inode->i_sb, HURD_COMPAT))) {\n\t\traw_inode->i_disk_version = cpu_to_le32(inode->i_version);\n\t\tif (ei->i_extra_isize) {\n\t\t\tif (EXT4_FITS_IN_INODE(raw_inode, ei, i_version_hi))\n\t\t\t\traw_inode->i_version_hi =\n\t\t\t\t\tcpu_to_le32(inode->i_version >> 32);\n\t\t\traw_inode->i_extra_isize =\n\t\t\t\tcpu_to_le16(ei->i_extra_isize);\n\t\t}\n\t}\n\n\tBUG_ON(!EXT4_HAS_RO_COMPAT_FEATURE(inode->i_sb,\n\t\t\tEXT4_FEATURE_RO_COMPAT_PROJECT) &&\n\t       i_projid != EXT4_DEF_PROJID);\n\n\tif (EXT4_INODE_SIZE(inode->i_sb) > EXT4_GOOD_OLD_INODE_SIZE &&\n\t    EXT4_FITS_IN_INODE(raw_inode, ei, i_projid))\n\t\traw_inode->i_projid = cpu_to_le32(i_projid);\n\n\text4_inode_csum_set(inode, raw_inode, ei);\n\tspin_unlock(&ei->i_raw_lock);\n\tif (inode->i_sb->s_flags & MS_LAZYTIME)\n\t\text4_update_other_inodes_time(inode->i_sb, inode->i_ino,\n\t\t\t\t\t      bh->b_data);\n\n\tBUFFER_TRACE(bh, \"call ext4_handle_dirty_metadata\");\n\trc = ext4_handle_dirty_metadata(handle, NULL, bh);\n\tif (!err)\n\t\terr = rc;\n\text4_clear_inode_state(inode, EXT4_STATE_NEW);\n\tif (set_large_file) {\n\t\tBUFFER_TRACE(EXT4_SB(sb)->s_sbh, \"get write access\");\n\t\terr = ext4_journal_get_write_access(handle, EXT4_SB(sb)->s_sbh);\n\t\tif (err)\n\t\t\tgoto out_brelse;\n\t\text4_update_dynamic_rev(sb);\n\t\text4_set_feature_large_file(sb);\n\t\text4_handle_sync(handle);\n\t\terr = ext4_handle_dirty_super(handle, sb);\n\t}\n\text4_update_inode_fsync_trans(handle, inode, need_datasync);\nout_brelse:\n\tbrelse(bh);\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}\n\n/*\n * ext4_write_inode()\n *\n * We are called from a few places:\n *\n * - Within generic_file_aio_write() -> generic_write_sync() for O_SYNC files.\n *   Here, there will be no transaction running. We wait for any running\n *   transaction to commit.\n *\n * - Within flush work (sys_sync(), kupdate and such).\n *   We wait on commit, if told to.\n *\n * - Within iput_final() -> write_inode_now()\n *   We wait on commit, if told to.\n *\n * In all cases it is actually safe for us to return without doing anything,\n * because the inode has been copied into a raw inode buffer in\n * ext4_mark_inode_dirty().  This is a correctness thing for WB_SYNC_ALL\n * writeback.\n *\n * Note that we are absolutely dependent upon all inode dirtiers doing the\n * right thing: they *must* call mark_inode_dirty() after dirtying info in\n * which we are interested.\n *\n * It would be a bug for them to not do this.  The code:\n *\n *\tmark_inode_dirty(inode)\n *\tstuff();\n *\tinode->i_size = expr;\n *\n * is in error because write_inode() could occur while `stuff()' is running,\n * and the new i_size will be lost.  Plus the inode will no longer be on the\n * superblock's dirty inode list.\n */\nint ext4_write_inode(struct inode *inode, struct writeback_control *wbc)\n{\n\tint err;\n\n\tif (WARN_ON_ONCE(current->flags & PF_MEMALLOC))\n\t\treturn 0;\n\n\tif (EXT4_SB(inode->i_sb)->s_journal) {\n\t\tif (ext4_journal_current_handle()) {\n\t\t\tjbd_debug(1, \"called recursively, non-PF_MEMALLOC!\\n\");\n\t\t\tdump_stack();\n\t\t\treturn -EIO;\n\t\t}\n\n\t\t/*\n\t\t * No need to force transaction in WB_SYNC_NONE mode. Also\n\t\t * ext4_sync_fs() will force the commit after everything is\n\t\t * written.\n\t\t */\n\t\tif (wbc->sync_mode != WB_SYNC_ALL || wbc->for_sync)\n\t\t\treturn 0;\n\n\t\terr = ext4_force_commit(inode->i_sb);\n\t} else {\n\t\tstruct ext4_iloc iloc;\n\n\t\terr = __ext4_get_inode_loc(inode, &iloc, 0);\n\t\tif (err)\n\t\t\treturn err;\n\t\t/*\n\t\t * sync(2) will flush the whole buffer cache. No need to do\n\t\t * it here separately for each inode.\n\t\t */\n\t\tif (wbc->sync_mode == WB_SYNC_ALL && !wbc->for_sync)\n\t\t\tsync_dirty_buffer(iloc.bh);\n\t\tif (buffer_req(iloc.bh) && !buffer_uptodate(iloc.bh)) {\n\t\t\tEXT4_ERROR_INODE_BLOCK(inode, iloc.bh->b_blocknr,\n\t\t\t\t\t \"IO error syncing inode\");\n\t\t\terr = -EIO;\n\t\t}\n\t\tbrelse(iloc.bh);\n\t}\n\treturn err;\n}\n\n/*\n * In data=journal mode ext4_journalled_invalidatepage() may fail to invalidate\n * buffers that are attached to a page stradding i_size and are undergoing\n * commit. In that case we have to wait for commit to finish and try again.\n */\nstatic void ext4_wait_for_tail_page_commit(struct inode *inode)\n{\n\tstruct page *page;\n\tunsigned offset;\n\tjournal_t *journal = EXT4_SB(inode->i_sb)->s_journal;\n\ttid_t commit_tid = 0;\n\tint ret;\n\n\toffset = inode->i_size & (PAGE_SIZE - 1);\n\t/*\n\t * All buffers in the last page remain valid? Then there's nothing to\n\t * do. We do the check mainly to optimize the common PAGE_SIZE ==\n\t * blocksize case\n\t */\n\tif (offset > PAGE_SIZE - (1 << inode->i_blkbits))\n\t\treturn;\n\twhile (1) {\n\t\tpage = find_lock_page(inode->i_mapping,\n\t\t\t\t      inode->i_size >> PAGE_SHIFT);\n\t\tif (!page)\n\t\t\treturn;\n\t\tret = __ext4_journalled_invalidatepage(page, offset,\n\t\t\t\t\t\tPAGE_SIZE - offset);\n\t\tunlock_page(page);\n\t\tput_page(page);\n\t\tif (ret != -EBUSY)\n\t\t\treturn;\n\t\tcommit_tid = 0;\n\t\tread_lock(&journal->j_state_lock);\n\t\tif (journal->j_committing_transaction)\n\t\t\tcommit_tid = journal->j_committing_transaction->t_tid;\n\t\tread_unlock(&journal->j_state_lock);\n\t\tif (commit_tid)\n\t\t\tjbd2_log_wait_commit(journal, commit_tid);\n\t}\n}\n\n/*\n * ext4_setattr()\n *\n * Called from notify_change.\n *\n * We want to trap VFS attempts to truncate the file as soon as\n * possible.  In particular, we want to make sure that when the VFS\n * shrinks i_size, we put the inode on the orphan list and modify\n * i_disksize immediately, so that during the subsequent flushing of\n * dirty pages and freeing of disk blocks, we can guarantee that any\n * commit will leave the blocks being flushed in an unused state on\n * disk.  (On recovery, the inode will get truncated and the blocks will\n * be freed, so we have a strong guarantee that no future commit will\n * leave these blocks visible to the user.)\n *\n * Another thing we have to assure is that if we are in ordered mode\n * and inode is still attached to the committing transaction, we must\n * we start writeout of all the dirty pages which are being truncated.\n * This way we are sure that all the data written in the previous\n * transaction are already on disk (truncate waits for pages under\n * writeback).\n *\n * Called with inode->i_mutex down.\n */\nint ext4_setattr(struct dentry *dentry, struct iattr *attr)\n{\n\tstruct inode *inode = d_inode(dentry);\n\tint error, rc = 0;\n\tint orphan = 0;\n\tconst unsigned int ia_valid = attr->ia_valid;\n\n\terror = inode_change_ok(inode, attr);\n\tif (error)\n\t\treturn error;\n\n\tif (is_quota_modification(inode, attr)) {\n\t\terror = dquot_initialize(inode);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\tif ((ia_valid & ATTR_UID && !uid_eq(attr->ia_uid, inode->i_uid)) ||\n\t    (ia_valid & ATTR_GID && !gid_eq(attr->ia_gid, inode->i_gid))) {\n\t\thandle_t *handle;\n\n\t\t/* (user+group)*(old+new) structure, inode write (sb,\n\t\t * inode block, ? - but truncate inode update has it) */\n\t\thandle = ext4_journal_start(inode, EXT4_HT_QUOTA,\n\t\t\t(EXT4_MAXQUOTAS_INIT_BLOCKS(inode->i_sb) +\n\t\t\t EXT4_MAXQUOTAS_DEL_BLOCKS(inode->i_sb)) + 3);\n\t\tif (IS_ERR(handle)) {\n\t\t\terror = PTR_ERR(handle);\n\t\t\tgoto err_out;\n\t\t}\n\t\terror = dquot_transfer(inode, attr);\n\t\tif (error) {\n\t\t\text4_journal_stop(handle);\n\t\t\treturn error;\n\t\t}\n\t\t/* Update corresponding info in inode so that everything is in\n\t\t * one transaction */\n\t\tif (attr->ia_valid & ATTR_UID)\n\t\t\tinode->i_uid = attr->ia_uid;\n\t\tif (attr->ia_valid & ATTR_GID)\n\t\t\tinode->i_gid = attr->ia_gid;\n\t\terror = ext4_mark_inode_dirty(handle, inode);\n\t\text4_journal_stop(handle);\n\t}\n\n\tif (attr->ia_valid & ATTR_SIZE) {\n\t\thandle_t *handle;\n\t\tloff_t oldsize = inode->i_size;\n\t\tint shrink = (attr->ia_size <= inode->i_size);\n\n\t\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS))) {\n\t\t\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\n\t\t\tif (attr->ia_size > sbi->s_bitmap_maxbytes)\n\t\t\t\treturn -EFBIG;\n\t\t}\n\t\tif (!S_ISREG(inode->i_mode))\n\t\t\treturn -EINVAL;\n\n\t\tif (IS_I_VERSION(inode) && attr->ia_size != inode->i_size)\n\t\t\tinode_inc_iversion(inode);\n\n\t\tif (ext4_should_order_data(inode) &&\n\t\t    (attr->ia_size < inode->i_size)) {\n\t\t\terror = ext4_begin_ordered_truncate(inode,\n\t\t\t\t\t\t\t    attr->ia_size);\n\t\t\tif (error)\n\t\t\t\tgoto err_out;\n\t\t}\n\t\tif (attr->ia_size != inode->i_size) {\n\t\t\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 3);\n\t\t\tif (IS_ERR(handle)) {\n\t\t\t\terror = PTR_ERR(handle);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t\tif (ext4_handle_valid(handle) && shrink) {\n\t\t\t\terror = ext4_orphan_add(handle, inode);\n\t\t\t\torphan = 1;\n\t\t\t}\n\t\t\t/*\n\t\t\t * Update c/mtime on truncate up, ext4_truncate() will\n\t\t\t * update c/mtime in shrink case below\n\t\t\t */\n\t\t\tif (!shrink) {\n\t\t\t\tinode->i_mtime = ext4_current_time(inode);\n\t\t\t\tinode->i_ctime = inode->i_mtime;\n\t\t\t}\n\t\t\tdown_write(&EXT4_I(inode)->i_data_sem);\n\t\t\tEXT4_I(inode)->i_disksize = attr->ia_size;\n\t\t\trc = ext4_mark_inode_dirty(handle, inode);\n\t\t\tif (!error)\n\t\t\t\terror = rc;\n\t\t\t/*\n\t\t\t * We have to update i_size under i_data_sem together\n\t\t\t * with i_disksize to avoid races with writeback code\n\t\t\t * running ext4_wb_update_i_disksize().\n\t\t\t */\n\t\t\tif (!error)\n\t\t\t\ti_size_write(inode, attr->ia_size);\n\t\t\tup_write(&EXT4_I(inode)->i_data_sem);\n\t\t\text4_journal_stop(handle);\n\t\t\tif (error) {\n\t\t\t\tif (orphan)\n\t\t\t\t\text4_orphan_del(NULL, inode);\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t\tif (!shrink)\n\t\t\tpagecache_isize_extended(inode, oldsize, inode->i_size);\n\n\t\t/*\n\t\t * Blocks are going to be removed from the inode. Wait\n\t\t * for dio in flight.  Temporarily disable\n\t\t * dioread_nolock to prevent livelock.\n\t\t */\n\t\tif (orphan) {\n\t\t\tif (!ext4_should_journal_data(inode)) {\n\t\t\t\text4_inode_block_unlocked_dio(inode);\n\t\t\t\tinode_dio_wait(inode);\n\t\t\t\text4_inode_resume_unlocked_dio(inode);\n\t\t\t} else\n\t\t\t\text4_wait_for_tail_page_commit(inode);\n\t\t}\n\t\tdown_write(&EXT4_I(inode)->i_mmap_sem);\n\t\t/*\n\t\t * Truncate pagecache after we've waited for commit\n\t\t * in data=journal mode to make pages freeable.\n\t\t */\n\t\ttruncate_pagecache(inode, inode->i_size);\n\t\tif (shrink)\n\t\t\text4_truncate(inode);\n\t\tup_write(&EXT4_I(inode)->i_mmap_sem);\n\t}\n\n\tif (!rc) {\n\t\tsetattr_copy(inode, attr);\n\t\tmark_inode_dirty(inode);\n\t}\n\n\t/*\n\t * If the call to ext4_truncate failed to get a transaction handle at\n\t * all, we need to clean up the in-core orphan list manually.\n\t */\n\tif (orphan && inode->i_nlink)\n\t\text4_orphan_del(NULL, inode);\n\n\tif (!rc && (ia_valid & ATTR_MODE))\n\t\trc = posix_acl_chmod(inode, inode->i_mode);\n\nerr_out:\n\text4_std_error(inode->i_sb, error);\n\tif (!error)\n\t\terror = rc;\n\treturn error;\n}\n\nint ext4_getattr(struct vfsmount *mnt, struct dentry *dentry,\n\t\t struct kstat *stat)\n{\n\tstruct inode *inode;\n\tunsigned long long delalloc_blocks;\n\n\tinode = d_inode(dentry);\n\tgeneric_fillattr(inode, stat);\n\n\t/*\n\t * If there is inline data in the inode, the inode will normally not\n\t * have data blocks allocated (it may have an external xattr block).\n\t * Report at least one sector for such files, so tools like tar, rsync,\n\t * others doen't incorrectly think the file is completely sparse.\n\t */\n\tif (unlikely(ext4_has_inline_data(inode)))\n\t\tstat->blocks += (stat->size + 511) >> 9;\n\n\t/*\n\t * We can't update i_blocks if the block allocation is delayed\n\t * otherwise in the case of system crash before the real block\n\t * allocation is done, we will have i_blocks inconsistent with\n\t * on-disk file blocks.\n\t * We always keep i_blocks updated together with real\n\t * allocation. But to not confuse with user, stat\n\t * will return the blocks that include the delayed allocation\n\t * blocks for this file.\n\t */\n\tdelalloc_blocks = EXT4_C2B(EXT4_SB(inode->i_sb),\n\t\t\t\t   EXT4_I(inode)->i_reserved_data_blocks);\n\tstat->blocks += delalloc_blocks << (inode->i_sb->s_blocksize_bits - 9);\n\treturn 0;\n}\n\nstatic int ext4_index_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t   int pextents)\n{\n\tif (!(ext4_test_inode_flag(inode, EXT4_INODE_EXTENTS)))\n\t\treturn ext4_ind_trans_blocks(inode, lblocks);\n\treturn ext4_ext_index_trans_blocks(inode, pextents);\n}\n\n/*\n * Account for index blocks, block groups bitmaps and block group\n * descriptor blocks if modify datablocks and index blocks\n * worse case, the indexs blocks spread over different block groups\n *\n * If datablocks are discontiguous, they are possible to spread over\n * different block groups too. If they are contiguous, with flexbg,\n * they could still across block group boundary.\n *\n * Also account for superblock, inode, quota and xattr blocks\n */\nstatic int ext4_meta_trans_blocks(struct inode *inode, int lblocks,\n\t\t\t\t  int pextents)\n{\n\text4_group_t groups, ngroups = ext4_get_groups_count(inode->i_sb);\n\tint gdpblocks;\n\tint idxblocks;\n\tint ret = 0;\n\n\t/*\n\t * How many index blocks need to touch to map @lblocks logical blocks\n\t * to @pextents physical extents?\n\t */\n\tidxblocks = ext4_index_trans_blocks(inode, lblocks, pextents);\n\n\tret = idxblocks;\n\n\t/*\n\t * Now let's see how many group bitmaps and group descriptors need\n\t * to account\n\t */\n\tgroups = idxblocks + pextents;\n\tgdpblocks = groups;\n\tif (groups > ngroups)\n\t\tgroups = ngroups;\n\tif (groups > EXT4_SB(inode->i_sb)->s_gdb_count)\n\t\tgdpblocks = EXT4_SB(inode->i_sb)->s_gdb_count;\n\n\t/* bitmaps and block group descriptor blocks */\n\tret += groups + gdpblocks;\n\n\t/* Blocks for super block, inode, quota and xattr blocks */\n\tret += EXT4_META_TRANS_BLOCKS(inode->i_sb);\n\n\treturn ret;\n}\n\n/*\n * Calculate the total number of credits to reserve to fit\n * the modification of a single pages into a single transaction,\n * which may include multiple chunks of block allocations.\n *\n * This could be called via ext4_write_begin()\n *\n * We need to consider the worse case, when\n * one new block per extent.\n */\nint ext4_writepage_trans_blocks(struct inode *inode)\n{\n\tint bpp = ext4_journal_blocks_per_page(inode);\n\tint ret;\n\n\tret = ext4_meta_trans_blocks(inode, bpp, bpp);\n\n\t/* Account for data blocks for journalled mode */\n\tif (ext4_should_journal_data(inode))\n\t\tret += bpp;\n\treturn ret;\n}\n\n/*\n * Calculate the journal credits for a chunk of data modification.\n *\n * This is called from DIO, fallocate or whoever calling\n * ext4_map_blocks() to map/allocate a chunk of contiguous disk blocks.\n *\n * journal buffers for data blocks are not included here, as DIO\n * and fallocate do no need to journal data buffers.\n */\nint ext4_chunk_trans_blocks(struct inode *inode, int nrblocks)\n{\n\treturn ext4_meta_trans_blocks(inode, nrblocks, 1);\n}\n\n/*\n * The caller must have previously called ext4_reserve_inode_write().\n * Give this, we know that the caller already has write access to iloc->bh.\n */\nint ext4_mark_iloc_dirty(handle_t *handle,\n\t\t\t struct inode *inode, struct ext4_iloc *iloc)\n{\n\tint err = 0;\n\n\tif (IS_I_VERSION(inode))\n\t\tinode_inc_iversion(inode);\n\n\t/* the do_update_inode consumes one bh->b_count */\n\tget_bh(iloc->bh);\n\n\t/* ext4_do_update_inode() does jbd2_journal_dirty_metadata */\n\terr = ext4_do_update_inode(handle, inode, iloc);\n\tput_bh(iloc->bh);\n\treturn err;\n}\n\n/*\n * On success, We end up with an outstanding reference count against\n * iloc->bh.  This _must_ be cleaned up later.\n */\n\nint\next4_reserve_inode_write(handle_t *handle, struct inode *inode,\n\t\t\t struct ext4_iloc *iloc)\n{\n\tint err;\n\n\terr = ext4_get_inode_loc(inode, iloc);\n\tif (!err) {\n\t\tBUFFER_TRACE(iloc->bh, \"get_write_access\");\n\t\terr = ext4_journal_get_write_access(handle, iloc->bh);\n\t\tif (err) {\n\t\t\tbrelse(iloc->bh);\n\t\t\tiloc->bh = NULL;\n\t\t}\n\t}\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}\n\n/*\n * Expand an inode by new_extra_isize bytes.\n * Returns 0 on success or negative error number on failure.\n */\nstatic int ext4_expand_extra_isize(struct inode *inode,\n\t\t\t\t   unsigned int new_extra_isize,\n\t\t\t\t   struct ext4_iloc iloc,\n\t\t\t\t   handle_t *handle)\n{\n\tstruct ext4_inode *raw_inode;\n\tstruct ext4_xattr_ibody_header *header;\n\n\tif (EXT4_I(inode)->i_extra_isize >= new_extra_isize)\n\t\treturn 0;\n\n\traw_inode = ext4_raw_inode(&iloc);\n\n\theader = IHDR(inode, raw_inode);\n\n\t/* No extended attributes present */\n\tif (!ext4_test_inode_state(inode, EXT4_STATE_XATTR) ||\n\t    header->h_magic != cpu_to_le32(EXT4_XATTR_MAGIC)) {\n\t\tmemset((void *)raw_inode + EXT4_GOOD_OLD_INODE_SIZE, 0,\n\t\t\tnew_extra_isize);\n\t\tEXT4_I(inode)->i_extra_isize = new_extra_isize;\n\t\treturn 0;\n\t}\n\n\t/* try to expand with EAs present */\n\treturn ext4_expand_extra_isize_ea(inode, new_extra_isize,\n\t\t\t\t\t  raw_inode, handle);\n}\n\n/*\n * What we do here is to mark the in-core inode as clean with respect to inode\n * dirtiness (it may still be data-dirty).\n * This means that the in-core inode may be reaped by prune_icache\n * without having to perform any I/O.  This is a very good thing,\n * because *any* task may call prune_icache - even ones which\n * have a transaction open against a different journal.\n *\n * Is this cheating?  Not really.  Sure, we haven't written the\n * inode out, but prune_icache isn't a user-visible syncing function.\n * Whenever the user wants stuff synced (sys_sync, sys_msync, sys_fsync)\n * we start and wait on commits.\n */\nint ext4_mark_inode_dirty(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\tstruct ext4_sb_info *sbi = EXT4_SB(inode->i_sb);\n\tstatic unsigned int mnt_count;\n\tint err, ret;\n\n\tmight_sleep();\n\ttrace_ext4_mark_inode_dirty(inode, _RET_IP_);\n\terr = ext4_reserve_inode_write(handle, inode, &iloc);\n\tif (err)\n\t\treturn err;\n\tif (ext4_handle_valid(handle) &&\n\t    EXT4_I(inode)->i_extra_isize < sbi->s_want_extra_isize &&\n\t    !ext4_test_inode_state(inode, EXT4_STATE_NO_EXPAND)) {\n\t\t/*\n\t\t * We need extra buffer credits since we may write into EA block\n\t\t * with this same handle. If journal_extend fails, then it will\n\t\t * only result in a minor loss of functionality for that inode.\n\t\t * If this is felt to be critical, then e2fsck should be run to\n\t\t * force a large enough s_min_extra_isize.\n\t\t */\n\t\tif ((jbd2_journal_extend(handle,\n\t\t\t     EXT4_DATA_TRANS_BLOCKS(inode->i_sb))) == 0) {\n\t\t\tret = ext4_expand_extra_isize(inode,\n\t\t\t\t\t\t      sbi->s_want_extra_isize,\n\t\t\t\t\t\t      iloc, handle);\n\t\t\tif (ret) {\n\t\t\t\text4_set_inode_state(inode,\n\t\t\t\t\t\t     EXT4_STATE_NO_EXPAND);\n\t\t\t\tif (mnt_count !=\n\t\t\t\t\tle16_to_cpu(sbi->s_es->s_mnt_count)) {\n\t\t\t\t\text4_warning(inode->i_sb,\n\t\t\t\t\t\"Unable to expand inode %lu. Delete\"\n\t\t\t\t\t\" some EAs or run e2fsck.\",\n\t\t\t\t\tinode->i_ino);\n\t\t\t\t\tmnt_count =\n\t\t\t\t\t  le16_to_cpu(sbi->s_es->s_mnt_count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ext4_mark_iloc_dirty(handle, inode, &iloc);\n}\n\n/*\n * ext4_dirty_inode() is called from __mark_inode_dirty()\n *\n * We're really interested in the case where a file is being extended.\n * i_size has been changed by generic_commit_write() and we thus need\n * to include the updated inode in the current transaction.\n *\n * Also, dquot_alloc_block() will always dirty the inode when blocks\n * are allocated to the file.\n *\n * If the inode is marked synchronous, we don't honour that here - doing\n * so would cause a commit on atime updates, which we don't bother doing.\n * We handle synchronous inodes at the highest possible level.\n *\n * If only the I_DIRTY_TIME flag is set, we can skip everything.  If\n * I_DIRTY_TIME and I_DIRTY_SYNC is set, the only inode fields we need\n * to copy into the on-disk inode structure are the timestamp files.\n */\nvoid ext4_dirty_inode(struct inode *inode, int flags)\n{\n\thandle_t *handle;\n\n\tif (flags == I_DIRTY_TIME)\n\t\treturn;\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 2);\n\tif (IS_ERR(handle))\n\t\tgoto out;\n\n\text4_mark_inode_dirty(handle, inode);\n\n\text4_journal_stop(handle);\nout:\n\treturn;\n}\n\n#if 0\n/*\n * Bind an inode's backing buffer_head into this transaction, to prevent\n * it from being flushed to disk early.  Unlike\n * ext4_reserve_inode_write, this leaves behind no bh reference and\n * returns no iloc structure, so the caller needs to repeat the iloc\n * lookup to mark the inode dirty later.\n */\nstatic int ext4_pin_inode(handle_t *handle, struct inode *inode)\n{\n\tstruct ext4_iloc iloc;\n\n\tint err = 0;\n\tif (handle) {\n\t\terr = ext4_get_inode_loc(inode, &iloc);\n\t\tif (!err) {\n\t\t\tBUFFER_TRACE(iloc.bh, \"get_write_access\");\n\t\t\terr = jbd2_journal_get_write_access(handle, iloc.bh);\n\t\t\tif (!err)\n\t\t\t\terr = ext4_handle_dirty_metadata(handle,\n\t\t\t\t\t\t\t\t NULL,\n\t\t\t\t\t\t\t\t iloc.bh);\n\t\t\tbrelse(iloc.bh);\n\t\t}\n\t}\n\text4_std_error(inode->i_sb, err);\n\treturn err;\n}\n#endif\n\nint ext4_change_inode_journal_flag(struct inode *inode, int val)\n{\n\tjournal_t *journal;\n\thandle_t *handle;\n\tint err;\n\n\t/*\n\t * We have to be very careful here: changing a data block's\n\t * journaling status dynamically is dangerous.  If we write a\n\t * data block to the journal, change the status and then delete\n\t * that block, we risk forgetting to revoke the old log record\n\t * from the journal and so a subsequent replay can corrupt data.\n\t * So, first we make sure that the journal is empty and that\n\t * nobody is changing anything.\n\t */\n\n\tjournal = EXT4_JOURNAL(inode);\n\tif (!journal)\n\t\treturn 0;\n\tif (is_journal_aborted(journal))\n\t\treturn -EROFS;\n\t/* We have to allocate physical blocks for delalloc blocks\n\t * before flushing journal. otherwise delalloc blocks can not\n\t * be allocated any more. even more truncate on delalloc blocks\n\t * could trigger BUG by flushing delalloc blocks in journal.\n\t * There is no delalloc block in non-journal data mode.\n\t */\n\tif (val && test_opt(inode->i_sb, DELALLOC)) {\n\t\terr = ext4_alloc_da_blocks(inode);\n\t\tif (err < 0)\n\t\t\treturn err;\n\t}\n\n\t/* Wait for all existing dio workers */\n\text4_inode_block_unlocked_dio(inode);\n\tinode_dio_wait(inode);\n\n\tjbd2_journal_lock_updates(journal);\n\n\t/*\n\t * OK, there are no updates running now, and all cached data is\n\t * synced to disk.  We are now in a completely consistent state\n\t * which doesn't have anything in the journal, and we know that\n\t * no filesystem updates are running, so it is safe to modify\n\t * the inode's in-core data-journaling state flag now.\n\t */\n\n\tif (val)\n\t\text4_set_inode_flag(inode, EXT4_INODE_JOURNAL_DATA);\n\telse {\n\t\terr = jbd2_journal_flush(journal);\n\t\tif (err < 0) {\n\t\t\tjbd2_journal_unlock_updates(journal);\n\t\t\text4_inode_resume_unlocked_dio(inode);\n\t\t\treturn err;\n\t\t}\n\t\text4_clear_inode_flag(inode, EXT4_INODE_JOURNAL_DATA);\n\t}\n\text4_set_aops(inode);\n\n\tjbd2_journal_unlock_updates(journal);\n\text4_inode_resume_unlocked_dio(inode);\n\n\t/* Finally we can mark the inode as dirty. */\n\n\thandle = ext4_journal_start(inode, EXT4_HT_INODE, 1);\n\tif (IS_ERR(handle))\n\t\treturn PTR_ERR(handle);\n\n\terr = ext4_mark_inode_dirty(handle, inode);\n\text4_handle_sync(handle);\n\text4_journal_stop(handle);\n\text4_std_error(inode->i_sb, err);\n\n\treturn err;\n}\n\nstatic int ext4_bh_unmapped(handle_t *handle, struct buffer_head *bh)\n{\n\treturn !buffer_mapped(bh);\n}\n\nint ext4_page_mkwrite(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct page *page = vmf->page;\n\tloff_t size;\n\tunsigned long len;\n\tint ret;\n\tstruct file *file = vma->vm_file;\n\tstruct inode *inode = file_inode(file);\n\tstruct address_space *mapping = inode->i_mapping;\n\thandle_t *handle;\n\tget_block_t *get_block;\n\tint retries = 0;\n\n\tsb_start_pagefault(inode->i_sb);\n\tfile_update_time(vma->vm_file);\n\n\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n\t/* Delalloc case is easy... */\n\tif (test_opt(inode->i_sb, DELALLOC) &&\n\t    !ext4_should_journal_data(inode) &&\n\t    !ext4_nonda_switch(inode->i_sb)) {\n\t\tdo {\n\t\t\tret = block_page_mkwrite(vma, vmf,\n\t\t\t\t\t\t   ext4_da_get_block_prep);\n\t\t} while (ret == -ENOSPC &&\n\t\t       ext4_should_retry_alloc(inode->i_sb, &retries));\n\t\tgoto out_ret;\n\t}\n\n\tlock_page(page);\n\tsize = i_size_read(inode);\n\t/* Page got truncated from under us? */\n\tif (page->mapping != mapping || page_offset(page) > size) {\n\t\tunlock_page(page);\n\t\tret = VM_FAULT_NOPAGE;\n\t\tgoto out;\n\t}\n\n\tif (page->index == size >> PAGE_SHIFT)\n\t\tlen = size & ~PAGE_MASK;\n\telse\n\t\tlen = PAGE_SIZE;\n\t/*\n\t * Return if we have all the buffers mapped. This avoids the need to do\n\t * journal_start/journal_stop which can block and take a long time\n\t */\n\tif (page_has_buffers(page)) {\n\t\tif (!ext4_walk_page_buffers(NULL, page_buffers(page),\n\t\t\t\t\t    0, len, NULL,\n\t\t\t\t\t    ext4_bh_unmapped)) {\n\t\t\t/* Wait so that we don't change page under IO */\n\t\t\twait_for_stable_page(page);\n\t\t\tret = VM_FAULT_LOCKED;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tunlock_page(page);\n\t/* OK, we need to fill the hole... */\n\tif (ext4_should_dioread_nolock(inode))\n\t\tget_block = ext4_get_block_unwritten;\n\telse\n\t\tget_block = ext4_get_block;\nretry_alloc:\n\thandle = ext4_journal_start(inode, EXT4_HT_WRITE_PAGE,\n\t\t\t\t    ext4_writepage_trans_blocks(inode));\n\tif (IS_ERR(handle)) {\n\t\tret = VM_FAULT_SIGBUS;\n\t\tgoto out;\n\t}\n\tret = block_page_mkwrite(vma, vmf, get_block);\n\tif (!ret && ext4_should_journal_data(inode)) {\n\t\tif (ext4_walk_page_buffers(handle, page_buffers(page), 0,\n\t\t\t  PAGE_SIZE, NULL, do_journal_get_write_access)) {\n\t\t\tunlock_page(page);\n\t\t\tret = VM_FAULT_SIGBUS;\n\t\t\text4_journal_stop(handle);\n\t\t\tgoto out;\n\t\t}\n\t\text4_set_inode_state(inode, EXT4_STATE_JDATA);\n\t}\n\text4_journal_stop(handle);\n\tif (ret == -ENOSPC && ext4_should_retry_alloc(inode->i_sb, &retries))\n\t\tgoto retry_alloc;\nout_ret:\n\tret = block_page_mkwrite_return(ret);\nout:\n\tup_read(&EXT4_I(inode)->i_mmap_sem);\n\tsb_end_pagefault(inode->i_sb);\n\treturn ret;\n}\n\nint ext4_filemap_fault(struct vm_area_struct *vma, struct vm_fault *vmf)\n{\n\tstruct inode *inode = file_inode(vma->vm_file);\n\tint err;\n\n\tdown_read(&EXT4_I(inode)->i_mmap_sem);\n\terr = filemap_fault(vma, vmf);\n\tup_read(&EXT4_I(inode)->i_mmap_sem);\n\n\treturn err;\n}\n\n/*\n * Find the first extent at or after @lblk in an inode that is not a hole.\n * Search for @map_len blocks at most. The extent is returned in @result.\n *\n * The function returns 1 if we found an extent. The function returns 0 in\n * case there is no extent at or after @lblk and in that case also sets\n * @result->es_len to 0. In case of error, the error code is returned.\n */\nint ext4_get_next_extent(struct inode *inode, ext4_lblk_t lblk,\n\t\t\t unsigned int map_len, struct extent_status *result)\n{\n\tstruct ext4_map_blocks map;\n\tstruct extent_status es = {};\n\tint ret;\n\n\tmap.m_lblk = lblk;\n\tmap.m_len = map_len;\n\n\t/*\n\t * For non-extent based files this loop may iterate several times since\n\t * we do not determine full hole size.\n\t */\n\twhile (map.m_len > 0) {\n\t\tret = ext4_map_blocks(NULL, inode, &map, 0);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\t/* There's extent covering m_lblk? Just return it. */\n\t\tif (ret > 0) {\n\t\t\tint status;\n\n\t\t\text4_es_store_pblock(result, map.m_pblk);\n\t\t\tresult->es_lblk = map.m_lblk;\n\t\t\tresult->es_len = map.m_len;\n\t\t\tif (map.m_flags & EXT4_MAP_UNWRITTEN)\n\t\t\t\tstatus = EXTENT_STATUS_UNWRITTEN;\n\t\t\telse\n\t\t\t\tstatus = EXTENT_STATUS_WRITTEN;\n\t\t\text4_es_store_status(result, status);\n\t\t\treturn 1;\n\t\t}\n\t\text4_es_find_delayed_extent_range(inode, map.m_lblk,\n\t\t\t\t\t\t  map.m_lblk + map.m_len - 1,\n\t\t\t\t\t\t  &es);\n\t\t/* Is delalloc data before next block in extent tree? */\n\t\tif (es.es_len && es.es_lblk < map.m_lblk + map.m_len) {\n\t\t\text4_lblk_t offset = 0;\n\n\t\t\tif (es.es_lblk < lblk)\n\t\t\t\toffset = lblk - es.es_lblk;\n\t\t\tresult->es_lblk = es.es_lblk + offset;\n\t\t\text4_es_store_pblock(result,\n\t\t\t\t\t     ext4_es_pblock(&es) + offset);\n\t\t\tresult->es_len = es.es_len - offset;\n\t\t\text4_es_store_status(result, ext4_es_status(&es));\n\n\t\t\treturn 1;\n\t\t}\n\t\t/* There's a hole at m_lblk, advance us after it */\n\t\tmap.m_lblk += map.m_len;\n\t\tmap_len -= map.m_len;\n\t\tmap.m_len = map_len;\n\t\tcond_resched();\n\t}\n\tresult->es_len = 0;\n\treturn 0;\n}\n"], "filenames": ["fs/ext4/inode.c"], "buggy_code_start_loc": [686], "buggy_code_end_loc": [1301], "fixing_code_start_loc": [687], "fixing_code_end_loc": [1306], "type": "CWE-200", "message": "fs/ext4/inode.c in the Linux kernel before 4.6.2, when ext4 data=ordered mode is used, mishandles a needs-flushing-before-commit list, which allows local users to obtain sensitive information from other users' files in opportunistic circumstances by waiting for a hardware reset, creating a new file, making write system calls, and reading this file.", "other": {"cve": {"id": "CVE-2017-7495", "sourceIdentifier": "secalert@redhat.com", "published": "2017-05-15T18:29:00.373", "lastModified": "2023-02-12T23:30:13.627", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "fs/ext4/inode.c in the Linux kernel before 4.6.2, when ext4 data=ordered mode is used, mishandles a needs-flushing-before-commit list, which allows local users to obtain sensitive information from other users' files in opportunistic circumstances by waiting for a hardware reset, creating a new file, making write system calls, and reading this file."}, {"lang": "es", "value": "En el archivo fs/ext4/inode.c en el kernel de Linux anterior a versi\u00f3n 4.6.2, cuando es usado el modo data=ordered de ext4, maneja inapropiadamente una lista de necesidades de descarga antes de confirmar, lo que permite a los usuarios locales obtener informaci\u00f3n confidencial de los archivos de otros usuarios en circunstancias oportunistas al esperar un reinicio del hardware, crear un archivo nuevo, hacer llamadas al sistema de escritura y leer este archivo."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.6.1", "matchCriteriaId": "795D2A87-E785-47CB-80E2-388CCD1F5CF8"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=06bd3c36a733ac27962fea7d6f47168841376824", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.6.2", "source": "secalert@redhat.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2017/05/15/2", "source": "secalert@redhat.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/98491", "source": "secalert@redhat.com"}, {"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1450261", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://github.com/torvalds/linux/commit/06bd3c36a733ac27962fea7d6f47168841376824", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://source.android.com/security/bulletin/2017-09-01", "source": "secalert@redhat.com"}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/06bd3c36a733ac27962fea7d6f47168841376824"}}