{"buggy_code": ["/*\n * QEMU Executable loader\n *\n * Copyright (c) 2006 Fabrice Bellard\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * Gunzip functionality in this file is derived from u-boot:\n *\n * (C) Copyright 2008 Semihalf\n *\n * (C) Copyright 2000-2005\n * Wolfgang Denk, DENX Software Engineering, wd@denx.de.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of\n * the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"qemu/osdep.h\"\n#include \"qapi/error.h\"\n#include \"hw/hw.h\"\n#include \"disas/disas.h\"\n#include \"monitor/monitor.h\"\n#include \"sysemu/sysemu.h\"\n#include \"uboot_image.h\"\n#include \"hw/loader.h\"\n#include \"hw/nvram/fw_cfg.h\"\n#include \"exec/memory.h\"\n#include \"exec/address-spaces.h\"\n#include \"hw/boards.h\"\n#include \"qemu/cutils.h\"\n\n#include <zlib.h>\n\nstatic int roms_loaded;\n\n/* return the size or -1 if error */\nint64_t get_image_size(const char *filename)\n{\n    int fd;\n    int64_t size;\n    fd = open(filename, O_RDONLY | O_BINARY);\n    if (fd < 0)\n        return -1;\n    size = lseek(fd, 0, SEEK_END);\n    close(fd);\n    return size;\n}\n\n/* return the size or -1 if error */\nssize_t load_image_size(const char *filename, void *addr, size_t size)\n{\n    int fd;\n    ssize_t actsize, l = 0;\n\n    fd = open(filename, O_RDONLY | O_BINARY);\n    if (fd < 0) {\n        return -1;\n    }\n\n    while ((actsize = read(fd, addr + l, size - l)) > 0) {\n        l += actsize;\n    }\n\n    close(fd);\n\n    return actsize < 0 ? -1 : l;\n}\n\n/* read()-like version */\nssize_t read_targphys(const char *name,\n                      int fd, hwaddr dst_addr, size_t nbytes)\n{\n    uint8_t *buf;\n    ssize_t did;\n\n    buf = g_malloc(nbytes);\n    did = read(fd, buf, nbytes);\n    if (did > 0)\n        rom_add_blob_fixed(\"read\", buf, did, dst_addr);\n    g_free(buf);\n    return did;\n}\n\nint load_image_targphys(const char *filename,\n                        hwaddr addr, uint64_t max_sz)\n{\n    return load_image_targphys_as(filename, addr, max_sz, NULL);\n}\n\n/* return the size or -1 if error */\nint load_image_targphys_as(const char *filename,\n                           hwaddr addr, uint64_t max_sz, AddressSpace *as)\n{\n    int size;\n\n    size = get_image_size(filename);\n    if (size < 0 || size > max_sz) {\n        return -1;\n    }\n    if (size > 0) {\n        if (rom_add_file_fixed_as(filename, addr, -1, as) < 0) {\n            return -1;\n        }\n    }\n    return size;\n}\n\nint load_image_mr(const char *filename, MemoryRegion *mr)\n{\n    int size;\n\n    if (!memory_access_is_direct(mr, false)) {\n        /* Can only load an image into RAM or ROM */\n        return -1;\n    }\n\n    size = get_image_size(filename);\n\n    if (size < 0 || size > memory_region_size(mr)) {\n        return -1;\n    }\n    if (size > 0) {\n        if (rom_add_file_mr(filename, mr, -1) < 0) {\n            return -1;\n        }\n    }\n    return size;\n}\n\nvoid pstrcpy_targphys(const char *name, hwaddr dest, int buf_size,\n                      const char *source)\n{\n    const char *nulp;\n    char *ptr;\n\n    if (buf_size <= 0) return;\n    nulp = memchr(source, 0, buf_size);\n    if (nulp) {\n        rom_add_blob_fixed(name, source, (nulp - source) + 1, dest);\n    } else {\n        rom_add_blob_fixed(name, source, buf_size, dest);\n        ptr = rom_ptr(dest + buf_size - 1, sizeof(*ptr));\n        *ptr = 0;\n    }\n}\n\n/* A.OUT loader */\n\nstruct exec\n{\n  uint32_t a_info;   /* Use macros N_MAGIC, etc for access */\n  uint32_t a_text;   /* length of text, in bytes */\n  uint32_t a_data;   /* length of data, in bytes */\n  uint32_t a_bss;    /* length of uninitialized data area, in bytes */\n  uint32_t a_syms;   /* length of symbol table data in file, in bytes */\n  uint32_t a_entry;  /* start address */\n  uint32_t a_trsize; /* length of relocation info for text, in bytes */\n  uint32_t a_drsize; /* length of relocation info for data, in bytes */\n};\n\nstatic void bswap_ahdr(struct exec *e)\n{\n    bswap32s(&e->a_info);\n    bswap32s(&e->a_text);\n    bswap32s(&e->a_data);\n    bswap32s(&e->a_bss);\n    bswap32s(&e->a_syms);\n    bswap32s(&e->a_entry);\n    bswap32s(&e->a_trsize);\n    bswap32s(&e->a_drsize);\n}\n\n#define N_MAGIC(exec) ((exec).a_info & 0xffff)\n#define OMAGIC 0407\n#define NMAGIC 0410\n#define ZMAGIC 0413\n#define QMAGIC 0314\n#define _N_HDROFF(x) (1024 - sizeof (struct exec))\n#define N_TXTOFF(x)\t\t\t\t\t\t\t\\\n    (N_MAGIC(x) == ZMAGIC ? _N_HDROFF((x)) + sizeof (struct exec) :\t\\\n     (N_MAGIC(x) == QMAGIC ? 0 : sizeof (struct exec)))\n#define N_TXTADDR(x, target_page_size) (N_MAGIC(x) == QMAGIC ? target_page_size : 0)\n#define _N_SEGMENT_ROUND(x, target_page_size) (((x) + target_page_size - 1) & ~(target_page_size - 1))\n\n#define _N_TXTENDADDR(x, target_page_size) (N_TXTADDR(x, target_page_size)+(x).a_text)\n\n#define N_DATADDR(x, target_page_size) \\\n    (N_MAGIC(x)==OMAGIC? (_N_TXTENDADDR(x, target_page_size)) \\\n     : (_N_SEGMENT_ROUND (_N_TXTENDADDR(x, target_page_size), target_page_size)))\n\n\nint load_aout(const char *filename, hwaddr addr, int max_sz,\n              int bswap_needed, hwaddr target_page_size)\n{\n    int fd;\n    ssize_t size, ret;\n    struct exec e;\n    uint32_t magic;\n\n    fd = open(filename, O_RDONLY | O_BINARY);\n    if (fd < 0)\n        return -1;\n\n    size = read(fd, &e, sizeof(e));\n    if (size < 0)\n        goto fail;\n\n    if (bswap_needed) {\n        bswap_ahdr(&e);\n    }\n\n    magic = N_MAGIC(e);\n    switch (magic) {\n    case ZMAGIC:\n    case QMAGIC:\n    case OMAGIC:\n        if (e.a_text + e.a_data > max_sz)\n            goto fail;\n        lseek(fd, N_TXTOFF(e), SEEK_SET);\n        size = read_targphys(filename, fd, addr, e.a_text + e.a_data);\n        if (size < 0)\n            goto fail;\n        break;\n    case NMAGIC:\n        if (N_DATADDR(e, target_page_size) + e.a_data > max_sz)\n            goto fail;\n        lseek(fd, N_TXTOFF(e), SEEK_SET);\n        size = read_targphys(filename, fd, addr, e.a_text);\n        if (size < 0)\n            goto fail;\n        ret = read_targphys(filename, fd, addr + N_DATADDR(e, target_page_size),\n                            e.a_data);\n        if (ret < 0)\n            goto fail;\n        size += ret;\n        break;\n    default:\n        goto fail;\n    }\n    close(fd);\n    return size;\n fail:\n    close(fd);\n    return -1;\n}\n\n/* ELF loader */\n\nstatic void *load_at(int fd, off_t offset, size_t size)\n{\n    void *ptr;\n    if (lseek(fd, offset, SEEK_SET) < 0)\n        return NULL;\n    ptr = g_malloc(size);\n    if (read(fd, ptr, size) != size) {\n        g_free(ptr);\n        return NULL;\n    }\n    return ptr;\n}\n\n#ifdef ELF_CLASS\n#undef ELF_CLASS\n#endif\n\n#define ELF_CLASS   ELFCLASS32\n#include \"elf.h\"\n\n#define SZ\t\t32\n#define elf_word        uint32_t\n#define elf_sword        int32_t\n#define bswapSZs\tbswap32s\n#include \"hw/elf_ops.h\"\n\n#undef elfhdr\n#undef elf_phdr\n#undef elf_shdr\n#undef elf_sym\n#undef elf_rela\n#undef elf_note\n#undef elf_word\n#undef elf_sword\n#undef bswapSZs\n#undef SZ\n#define elfhdr\t\telf64_hdr\n#define elf_phdr\telf64_phdr\n#define elf_note\telf64_note\n#define elf_shdr\telf64_shdr\n#define elf_sym\t\telf64_sym\n#define elf_rela        elf64_rela\n#define elf_word        uint64_t\n#define elf_sword        int64_t\n#define bswapSZs\tbswap64s\n#define SZ\t\t64\n#include \"hw/elf_ops.h\"\n\nconst char *load_elf_strerror(int error)\n{\n    switch (error) {\n    case 0:\n        return \"No error\";\n    case ELF_LOAD_FAILED:\n        return \"Failed to load ELF\";\n    case ELF_LOAD_NOT_ELF:\n        return \"The image is not ELF\";\n    case ELF_LOAD_WRONG_ARCH:\n        return \"The image is from incompatible architecture\";\n    case ELF_LOAD_WRONG_ENDIAN:\n        return \"The image has incorrect endianness\";\n    default:\n        return \"Unknown error\";\n    }\n}\n\nvoid load_elf_hdr(const char *filename, void *hdr, bool *is64, Error **errp)\n{\n    int fd;\n    uint8_t e_ident_local[EI_NIDENT];\n    uint8_t *e_ident;\n    size_t hdr_size, off;\n    bool is64l;\n\n    if (!hdr) {\n        hdr = e_ident_local;\n    }\n    e_ident = hdr;\n\n    fd = open(filename, O_RDONLY | O_BINARY);\n    if (fd < 0) {\n        error_setg_errno(errp, errno, \"Failed to open file: %s\", filename);\n        return;\n    }\n    if (read(fd, hdr, EI_NIDENT) != EI_NIDENT) {\n        error_setg_errno(errp, errno, \"Failed to read file: %s\", filename);\n        goto fail;\n    }\n    if (e_ident[0] != ELFMAG0 ||\n        e_ident[1] != ELFMAG1 ||\n        e_ident[2] != ELFMAG2 ||\n        e_ident[3] != ELFMAG3) {\n        error_setg(errp, \"Bad ELF magic\");\n        goto fail;\n    }\n\n    is64l = e_ident[EI_CLASS] == ELFCLASS64;\n    hdr_size = is64l ? sizeof(Elf64_Ehdr) : sizeof(Elf32_Ehdr);\n    if (is64) {\n        *is64 = is64l;\n    }\n\n    off = EI_NIDENT;\n    while (hdr != e_ident_local && off < hdr_size) {\n        size_t br = read(fd, hdr + off, hdr_size - off);\n        switch (br) {\n        case 0:\n            error_setg(errp, \"File too short: %s\", filename);\n            goto fail;\n        case -1:\n            error_setg_errno(errp, errno, \"Failed to read file: %s\",\n                             filename);\n            goto fail;\n        }\n        off += br;\n    }\n\nfail:\n    close(fd);\n}\n\n/* return < 0 if error, otherwise the number of bytes loaded in memory */\nint load_elf(const char *filename,\n             uint64_t (*elf_note_fn)(void *, void *, bool),\n             uint64_t (*translate_fn)(void *, uint64_t),\n             void *translate_opaque, uint64_t *pentry, uint64_t *lowaddr,\n             uint64_t *highaddr, int big_endian, int elf_machine,\n             int clear_lsb, int data_swab)\n{\n    return load_elf_as(filename, elf_note_fn, translate_fn, translate_opaque,\n                       pentry, lowaddr, highaddr, big_endian, elf_machine,\n                       clear_lsb, data_swab, NULL);\n}\n\n/* return < 0 if error, otherwise the number of bytes loaded in memory */\nint load_elf_as(const char *filename,\n                uint64_t (*elf_note_fn)(void *, void *, bool),\n                uint64_t (*translate_fn)(void *, uint64_t),\n                void *translate_opaque, uint64_t *pentry, uint64_t *lowaddr,\n                uint64_t *highaddr, int big_endian, int elf_machine,\n                int clear_lsb, int data_swab, AddressSpace *as)\n{\n    return load_elf_ram(filename, elf_note_fn, translate_fn, translate_opaque,\n                        pentry, lowaddr, highaddr, big_endian, elf_machine,\n                        clear_lsb, data_swab, as, true);\n}\n\n/* return < 0 if error, otherwise the number of bytes loaded in memory */\nint load_elf_ram(const char *filename,\n                 uint64_t (*elf_note_fn)(void *, void *, bool),\n                 uint64_t (*translate_fn)(void *, uint64_t),\n                 void *translate_opaque, uint64_t *pentry, uint64_t *lowaddr,\n                 uint64_t *highaddr, int big_endian, int elf_machine,\n                 int clear_lsb, int data_swab, AddressSpace *as,\n                 bool load_rom)\n{\n    return load_elf_ram_sym(filename, elf_note_fn,\n                            translate_fn, translate_opaque,\n                            pentry, lowaddr, highaddr, big_endian,\n                            elf_machine, clear_lsb, data_swab, as,\n                            load_rom, NULL);\n}\n\n/* return < 0 if error, otherwise the number of bytes loaded in memory */\nint load_elf_ram_sym(const char *filename,\n                     uint64_t (*elf_note_fn)(void *, void *, bool),\n                     uint64_t (*translate_fn)(void *, uint64_t),\n                     void *translate_opaque, uint64_t *pentry,\n                     uint64_t *lowaddr, uint64_t *highaddr, int big_endian,\n                     int elf_machine, int clear_lsb, int data_swab,\n                     AddressSpace *as, bool load_rom, symbol_fn_t sym_cb)\n{\n    int fd, data_order, target_data_order, must_swab, ret = ELF_LOAD_FAILED;\n    uint8_t e_ident[EI_NIDENT];\n\n    fd = open(filename, O_RDONLY | O_BINARY);\n    if (fd < 0) {\n        perror(filename);\n        return -1;\n    }\n    if (read(fd, e_ident, sizeof(e_ident)) != sizeof(e_ident))\n        goto fail;\n    if (e_ident[0] != ELFMAG0 ||\n        e_ident[1] != ELFMAG1 ||\n        e_ident[2] != ELFMAG2 ||\n        e_ident[3] != ELFMAG3) {\n        ret = ELF_LOAD_NOT_ELF;\n        goto fail;\n    }\n#ifdef HOST_WORDS_BIGENDIAN\n    data_order = ELFDATA2MSB;\n#else\n    data_order = ELFDATA2LSB;\n#endif\n    must_swab = data_order != e_ident[EI_DATA];\n    if (big_endian) {\n        target_data_order = ELFDATA2MSB;\n    } else {\n        target_data_order = ELFDATA2LSB;\n    }\n\n    if (target_data_order != e_ident[EI_DATA]) {\n        ret = ELF_LOAD_WRONG_ENDIAN;\n        goto fail;\n    }\n\n    lseek(fd, 0, SEEK_SET);\n    if (e_ident[EI_CLASS] == ELFCLASS64) {\n        ret = load_elf64(filename, fd, elf_note_fn,\n                         translate_fn, translate_opaque, must_swab,\n                         pentry, lowaddr, highaddr, elf_machine, clear_lsb,\n                         data_swab, as, load_rom, sym_cb);\n    } else {\n        ret = load_elf32(filename, fd, elf_note_fn,\n                         translate_fn, translate_opaque, must_swab,\n                         pentry, lowaddr, highaddr, elf_machine, clear_lsb,\n                         data_swab, as, load_rom, sym_cb);\n    }\n\n fail:\n    close(fd);\n    return ret;\n}\n\nstatic void bswap_uboot_header(uboot_image_header_t *hdr)\n{\n#ifndef HOST_WORDS_BIGENDIAN\n    bswap32s(&hdr->ih_magic);\n    bswap32s(&hdr->ih_hcrc);\n    bswap32s(&hdr->ih_time);\n    bswap32s(&hdr->ih_size);\n    bswap32s(&hdr->ih_load);\n    bswap32s(&hdr->ih_ep);\n    bswap32s(&hdr->ih_dcrc);\n#endif\n}\n\n\n#define ZALLOC_ALIGNMENT\t16\n\nstatic void *zalloc(void *x, unsigned items, unsigned size)\n{\n    void *p;\n\n    size *= items;\n    size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);\n\n    p = g_malloc(size);\n\n    return (p);\n}\n\nstatic void zfree(void *x, void *addr)\n{\n    g_free(addr);\n}\n\n\n#define HEAD_CRC\t2\n#define EXTRA_FIELD\t4\n#define ORIG_NAME\t8\n#define COMMENT\t\t0x10\n#define RESERVED\t0xe0\n\n#define DEFLATED\t8\n\nssize_t gunzip(void *dst, size_t dstlen, uint8_t *src, size_t srclen)\n{\n    z_stream s;\n    ssize_t dstbytes;\n    int r, i, flags;\n\n    /* skip header */\n    i = 10;\n    flags = src[3];\n    if (src[2] != DEFLATED || (flags & RESERVED) != 0) {\n        puts (\"Error: Bad gzipped data\\n\");\n        return -1;\n    }\n    if ((flags & EXTRA_FIELD) != 0)\n        i = 12 + src[10] + (src[11] << 8);\n    if ((flags & ORIG_NAME) != 0)\n        while (src[i++] != 0)\n            ;\n    if ((flags & COMMENT) != 0)\n        while (src[i++] != 0)\n            ;\n    if ((flags & HEAD_CRC) != 0)\n        i += 2;\n    if (i >= srclen) {\n        puts (\"Error: gunzip out of data in header\\n\");\n        return -1;\n    }\n\n    s.zalloc = zalloc;\n    s.zfree = zfree;\n\n    r = inflateInit2(&s, -MAX_WBITS);\n    if (r != Z_OK) {\n        printf (\"Error: inflateInit2() returned %d\\n\", r);\n        return (-1);\n    }\n    s.next_in = src + i;\n    s.avail_in = srclen - i;\n    s.next_out = dst;\n    s.avail_out = dstlen;\n    r = inflate(&s, Z_FINISH);\n    if (r != Z_OK && r != Z_STREAM_END) {\n        printf (\"Error: inflate() returned %d\\n\", r);\n        return -1;\n    }\n    dstbytes = s.next_out - (unsigned char *) dst;\n    inflateEnd(&s);\n\n    return dstbytes;\n}\n\n/* Load a U-Boot image.  */\nstatic int load_uboot_image(const char *filename, hwaddr *ep, hwaddr *loadaddr,\n                            int *is_linux, uint8_t image_type,\n                            uint64_t (*translate_fn)(void *, uint64_t),\n                            void *translate_opaque, AddressSpace *as)\n{\n    int fd;\n    int size;\n    hwaddr address;\n    uboot_image_header_t h;\n    uboot_image_header_t *hdr = &h;\n    uint8_t *data = NULL;\n    int ret = -1;\n    int do_uncompress = 0;\n\n    fd = open(filename, O_RDONLY | O_BINARY);\n    if (fd < 0)\n        return -1;\n\n    size = read(fd, hdr, sizeof(uboot_image_header_t));\n    if (size < sizeof(uboot_image_header_t)) {\n        goto out;\n    }\n\n    bswap_uboot_header(hdr);\n\n    if (hdr->ih_magic != IH_MAGIC)\n        goto out;\n\n    if (hdr->ih_type != image_type) {\n        if (!(image_type == IH_TYPE_KERNEL &&\n            hdr->ih_type == IH_TYPE_KERNEL_NOLOAD)) {\n            fprintf(stderr, \"Wrong image type %d, expected %d\\n\", hdr->ih_type,\n                    image_type);\n            goto out;\n        }\n    }\n\n    /* TODO: Implement other image types.  */\n    switch (hdr->ih_type) {\n    case IH_TYPE_KERNEL_NOLOAD:\n        if (!loadaddr || *loadaddr == LOAD_UIMAGE_LOADADDR_INVALID) {\n            fprintf(stderr, \"this image format (kernel_noload) cannot be \"\n                    \"loaded on this machine type\");\n            goto out;\n        }\n\n        hdr->ih_load = *loadaddr + sizeof(*hdr);\n        hdr->ih_ep += hdr->ih_load;\n        /* fall through */\n    case IH_TYPE_KERNEL:\n        address = hdr->ih_load;\n        if (translate_fn) {\n            address = translate_fn(translate_opaque, address);\n        }\n        if (loadaddr) {\n            *loadaddr = hdr->ih_load;\n        }\n\n        switch (hdr->ih_comp) {\n        case IH_COMP_NONE:\n            break;\n        case IH_COMP_GZIP:\n            do_uncompress = 1;\n            break;\n        default:\n            fprintf(stderr,\n                    \"Unable to load u-boot images with compression type %d\\n\",\n                    hdr->ih_comp);\n            goto out;\n        }\n\n        if (ep) {\n            *ep = hdr->ih_ep;\n        }\n\n        /* TODO: Check CPU type.  */\n        if (is_linux) {\n            if (hdr->ih_os == IH_OS_LINUX) {\n                *is_linux = 1;\n            } else {\n                *is_linux = 0;\n            }\n        }\n\n        break;\n    case IH_TYPE_RAMDISK:\n        address = *loadaddr;\n        break;\n    default:\n        fprintf(stderr, \"Unsupported u-boot image type %d\\n\", hdr->ih_type);\n        goto out;\n    }\n\n    data = g_malloc(hdr->ih_size);\n\n    if (read(fd, data, hdr->ih_size) != hdr->ih_size) {\n        fprintf(stderr, \"Error reading file\\n\");\n        goto out;\n    }\n\n    if (do_uncompress) {\n        uint8_t *compressed_data;\n        size_t max_bytes;\n        ssize_t bytes;\n\n        compressed_data = data;\n        max_bytes = UBOOT_MAX_GUNZIP_BYTES;\n        data = g_malloc(max_bytes);\n\n        bytes = gunzip(data, max_bytes, compressed_data, hdr->ih_size);\n        g_free(compressed_data);\n        if (bytes < 0) {\n            fprintf(stderr, \"Unable to decompress gzipped image!\\n\");\n            goto out;\n        }\n        hdr->ih_size = bytes;\n    }\n\n    rom_add_blob_fixed_as(filename, data, hdr->ih_size, address, as);\n\n    ret = hdr->ih_size;\n\nout:\n    g_free(data);\n    close(fd);\n    return ret;\n}\n\nint load_uimage(const char *filename, hwaddr *ep, hwaddr *loadaddr,\n                int *is_linux,\n                uint64_t (*translate_fn)(void *, uint64_t),\n                void *translate_opaque)\n{\n    return load_uboot_image(filename, ep, loadaddr, is_linux, IH_TYPE_KERNEL,\n                            translate_fn, translate_opaque, NULL);\n}\n\nint load_uimage_as(const char *filename, hwaddr *ep, hwaddr *loadaddr,\n                   int *is_linux,\n                   uint64_t (*translate_fn)(void *, uint64_t),\n                   void *translate_opaque, AddressSpace *as)\n{\n    return load_uboot_image(filename, ep, loadaddr, is_linux, IH_TYPE_KERNEL,\n                            translate_fn, translate_opaque, as);\n}\n\n/* Load a ramdisk.  */\nint load_ramdisk(const char *filename, hwaddr addr, uint64_t max_sz)\n{\n    return load_ramdisk_as(filename, addr, max_sz, NULL);\n}\n\nint load_ramdisk_as(const char *filename, hwaddr addr, uint64_t max_sz,\n                    AddressSpace *as)\n{\n    return load_uboot_image(filename, NULL, &addr, NULL, IH_TYPE_RAMDISK,\n                            NULL, NULL, as);\n}\n\n/* Load a gzip-compressed kernel to a dynamically allocated buffer. */\nint load_image_gzipped_buffer(const char *filename, uint64_t max_sz,\n                              uint8_t **buffer)\n{\n    uint8_t *compressed_data = NULL;\n    uint8_t *data = NULL;\n    gsize len;\n    ssize_t bytes;\n    int ret = -1;\n\n    if (!g_file_get_contents(filename, (char **) &compressed_data, &len,\n                             NULL)) {\n        goto out;\n    }\n\n    /* Is it a gzip-compressed file? */\n    if (len < 2 ||\n        compressed_data[0] != 0x1f ||\n        compressed_data[1] != 0x8b) {\n        goto out;\n    }\n\n    if (max_sz > LOAD_IMAGE_MAX_GUNZIP_BYTES) {\n        max_sz = LOAD_IMAGE_MAX_GUNZIP_BYTES;\n    }\n\n    data = g_malloc(max_sz);\n    bytes = gunzip(data, max_sz, compressed_data, len);\n    if (bytes < 0) {\n        fprintf(stderr, \"%s: unable to decompress gzipped kernel file\\n\",\n                filename);\n        goto out;\n    }\n\n    /* trim to actual size and return to caller */\n    *buffer = g_realloc(data, bytes);\n    ret = bytes;\n    /* ownership has been transferred to caller */\n    data = NULL;\n\n out:\n    g_free(compressed_data);\n    g_free(data);\n    return ret;\n}\n\n/* Load a gzip-compressed kernel. */\nint load_image_gzipped(const char *filename, hwaddr addr, uint64_t max_sz)\n{\n    int bytes;\n    uint8_t *data;\n\n    bytes = load_image_gzipped_buffer(filename, max_sz, &data);\n    if (bytes != -1) {\n        rom_add_blob_fixed(filename, data, bytes, addr);\n        g_free(data);\n    }\n    return bytes;\n}\n\n/*\n * Functions for reboot-persistent memory regions.\n *  - used for vga bios and option roms.\n *  - also linux kernel (-kernel / -initrd).\n */\n\ntypedef struct Rom Rom;\n\nstruct Rom {\n    char *name;\n    char *path;\n\n    /* datasize is the amount of memory allocated in \"data\". If datasize is less\n     * than romsize, it means that the area from datasize to romsize is filled\n     * with zeros.\n     */\n    size_t romsize;\n    size_t datasize;\n\n    uint8_t *data;\n    MemoryRegion *mr;\n    AddressSpace *as;\n    int isrom;\n    char *fw_dir;\n    char *fw_file;\n\n    bool committed;\n\n    hwaddr addr;\n    QTAILQ_ENTRY(Rom) next;\n};\n\nstatic FWCfgState *fw_cfg;\nstatic QTAILQ_HEAD(, Rom) roms = QTAILQ_HEAD_INITIALIZER(roms);\n\n/* rom->data must be heap-allocated (do not use with rom_add_elf_program()) */\nstatic void rom_free(Rom *rom)\n{\n    g_free(rom->data);\n    g_free(rom->path);\n    g_free(rom->name);\n    g_free(rom->fw_dir);\n    g_free(rom->fw_file);\n    g_free(rom);\n}\n\nstatic inline bool rom_order_compare(Rom *rom, Rom *item)\n{\n    return ((uintptr_t)(void *)rom->as > (uintptr_t)(void *)item->as) ||\n           (rom->as == item->as && rom->addr >= item->addr);\n}\n\nstatic void rom_insert(Rom *rom)\n{\n    Rom *item;\n\n    if (roms_loaded) {\n        hw_error (\"ROM images must be loaded at startup\\n\");\n    }\n\n    /* The user didn't specify an address space, this is the default */\n    if (!rom->as) {\n        rom->as = &address_space_memory;\n    }\n\n    rom->committed = false;\n\n    /* List is ordered by load address in the same address space */\n    QTAILQ_FOREACH(item, &roms, next) {\n        if (rom_order_compare(rom, item)) {\n            continue;\n        }\n        QTAILQ_INSERT_BEFORE(item, rom, next);\n        return;\n    }\n    QTAILQ_INSERT_TAIL(&roms, rom, next);\n}\n\nstatic void fw_cfg_resized(const char *id, uint64_t length, void *host)\n{\n    if (fw_cfg) {\n        fw_cfg_modify_file(fw_cfg, id + strlen(\"/rom@\"), host, length);\n    }\n}\n\nstatic void *rom_set_mr(Rom *rom, Object *owner, const char *name, bool ro)\n{\n    void *data;\n\n    rom->mr = g_malloc(sizeof(*rom->mr));\n    memory_region_init_resizeable_ram(rom->mr, owner, name,\n                                      rom->datasize, rom->romsize,\n                                      fw_cfg_resized,\n                                      &error_fatal);\n    memory_region_set_readonly(rom->mr, ro);\n    vmstate_register_ram_global(rom->mr);\n\n    data = memory_region_get_ram_ptr(rom->mr);\n    memcpy(data, rom->data, rom->datasize);\n\n    return data;\n}\n\nint rom_add_file(const char *file, const char *fw_dir,\n                 hwaddr addr, int32_t bootindex,\n                 bool option_rom, MemoryRegion *mr,\n                 AddressSpace *as)\n{\n    MachineClass *mc = MACHINE_GET_CLASS(qdev_get_machine());\n    Rom *rom;\n    int rc, fd = -1;\n    char devpath[100];\n\n    if (as && mr) {\n        fprintf(stderr, \"Specifying an Address Space and Memory Region is \" \\\n                \"not valid when loading a rom\\n\");\n        /* We haven't allocated anything so we don't need any cleanup */\n        return -1;\n    }\n\n    rom = g_malloc0(sizeof(*rom));\n    rom->name = g_strdup(file);\n    rom->path = qemu_find_file(QEMU_FILE_TYPE_BIOS, rom->name);\n    rom->as = as;\n    if (rom->path == NULL) {\n        rom->path = g_strdup(file);\n    }\n\n    fd = open(rom->path, O_RDONLY | O_BINARY);\n    if (fd == -1) {\n        fprintf(stderr, \"Could not open option rom '%s': %s\\n\",\n                rom->path, strerror(errno));\n        goto err;\n    }\n\n    if (fw_dir) {\n        rom->fw_dir  = g_strdup(fw_dir);\n        rom->fw_file = g_strdup(file);\n    }\n    rom->addr     = addr;\n    rom->romsize  = lseek(fd, 0, SEEK_END);\n    if (rom->romsize == -1) {\n        fprintf(stderr, \"rom: file %-20s: get size error: %s\\n\",\n                rom->name, strerror(errno));\n        goto err;\n    }\n\n    rom->datasize = rom->romsize;\n    rom->data     = g_malloc0(rom->datasize);\n    lseek(fd, 0, SEEK_SET);\n    rc = read(fd, rom->data, rom->datasize);\n    if (rc != rom->datasize) {\n        fprintf(stderr, \"rom: file %-20s: read error: rc=%d (expected %zd)\\n\",\n                rom->name, rc, rom->datasize);\n        goto err;\n    }\n    close(fd);\n    rom_insert(rom);\n    if (rom->fw_file && fw_cfg) {\n        const char *basename;\n        char fw_file_name[FW_CFG_MAX_FILE_PATH];\n        void *data;\n\n        basename = strrchr(rom->fw_file, '/');\n        if (basename) {\n            basename++;\n        } else {\n            basename = rom->fw_file;\n        }\n        snprintf(fw_file_name, sizeof(fw_file_name), \"%s/%s\", rom->fw_dir,\n                 basename);\n        snprintf(devpath, sizeof(devpath), \"/rom@%s\", fw_file_name);\n\n        if ((!option_rom || mc->option_rom_has_mr) && mc->rom_file_has_mr) {\n            data = rom_set_mr(rom, OBJECT(fw_cfg), devpath, true);\n        } else {\n            data = rom->data;\n        }\n\n        fw_cfg_add_file(fw_cfg, fw_file_name, data, rom->romsize);\n    } else {\n        if (mr) {\n            rom->mr = mr;\n            snprintf(devpath, sizeof(devpath), \"/rom@%s\", file);\n        } else {\n            snprintf(devpath, sizeof(devpath), \"/rom@\" TARGET_FMT_plx, addr);\n        }\n    }\n\n    add_boot_device_path(bootindex, NULL, devpath);\n    return 0;\n\nerr:\n    if (fd != -1)\n        close(fd);\n\n    rom_free(rom);\n    return -1;\n}\n\nMemoryRegion *rom_add_blob(const char *name, const void *blob, size_t len,\n                   size_t max_len, hwaddr addr, const char *fw_file_name,\n                   FWCfgCallback fw_callback, void *callback_opaque,\n                   AddressSpace *as, bool read_only)\n{\n    MachineClass *mc = MACHINE_GET_CLASS(qdev_get_machine());\n    Rom *rom;\n    MemoryRegion *mr = NULL;\n\n    rom           = g_malloc0(sizeof(*rom));\n    rom->name     = g_strdup(name);\n    rom->as       = as;\n    rom->addr     = addr;\n    rom->romsize  = max_len ? max_len : len;\n    rom->datasize = len;\n    rom->data     = g_malloc0(rom->datasize);\n    memcpy(rom->data, blob, len);\n    rom_insert(rom);\n    if (fw_file_name && fw_cfg) {\n        char devpath[100];\n        void *data;\n\n        if (read_only) {\n            snprintf(devpath, sizeof(devpath), \"/rom@%s\", fw_file_name);\n        } else {\n            snprintf(devpath, sizeof(devpath), \"/ram@%s\", fw_file_name);\n        }\n\n        if (mc->rom_file_has_mr) {\n            data = rom_set_mr(rom, OBJECT(fw_cfg), devpath, read_only);\n            mr = rom->mr;\n        } else {\n            data = rom->data;\n        }\n\n        fw_cfg_add_file_callback(fw_cfg, fw_file_name,\n                                 fw_callback, NULL, callback_opaque,\n                                 data, rom->datasize, read_only);\n    }\n    return mr;\n}\n\n/* This function is specific for elf program because we don't need to allocate\n * all the rom. We just allocate the first part and the rest is just zeros. This\n * is why romsize and datasize are different. Also, this function seize the\n * memory ownership of \"data\", so we don't have to allocate and copy the buffer.\n */\nint rom_add_elf_program(const char *name, void *data, size_t datasize,\n                        size_t romsize, hwaddr addr, AddressSpace *as)\n{\n    Rom *rom;\n\n    rom           = g_malloc0(sizeof(*rom));\n    rom->name     = g_strdup(name);\n    rom->addr     = addr;\n    rom->datasize = datasize;\n    rom->romsize  = romsize;\n    rom->data     = data;\n    rom->as       = as;\n    rom_insert(rom);\n    return 0;\n}\n\nint rom_add_vga(const char *file)\n{\n    return rom_add_file(file, \"vgaroms\", 0, -1, true, NULL, NULL);\n}\n\nint rom_add_option(const char *file, int32_t bootindex)\n{\n    return rom_add_file(file, \"genroms\", 0, bootindex, true, NULL, NULL);\n}\n\nstatic void rom_reset(void *unused)\n{\n    Rom *rom;\n\n    QTAILQ_FOREACH(rom, &roms, next) {\n        if (rom->fw_file) {\n            continue;\n        }\n        if (rom->data == NULL) {\n            continue;\n        }\n        if (rom->mr) {\n            void *host = memory_region_get_ram_ptr(rom->mr);\n            memcpy(host, rom->data, rom->datasize);\n        } else {\n            address_space_write_rom(rom->as, rom->addr, MEMTXATTRS_UNSPECIFIED,\n                                    rom->data, rom->datasize);\n        }\n        if (rom->isrom) {\n            /* rom needs to be written only once */\n            g_free(rom->data);\n            rom->data = NULL;\n        }\n        /*\n         * The rom loader is really on the same level as firmware in the guest\n         * shadowing a ROM into RAM. Such a shadowing mechanism needs to ensure\n         * that the instruction cache for that new region is clear, so that the\n         * CPU definitely fetches its instructions from the just written data.\n         */\n        cpu_flush_icache_range(rom->addr, rom->datasize);\n    }\n}\n\nint rom_check_and_register_reset(void)\n{\n    hwaddr addr = 0;\n    MemoryRegionSection section;\n    Rom *rom;\n    AddressSpace *as = NULL;\n\n    QTAILQ_FOREACH(rom, &roms, next) {\n        if (rom->fw_file) {\n            continue;\n        }\n        if (!rom->mr) {\n            if ((addr > rom->addr) && (as == rom->as)) {\n                fprintf(stderr, \"rom: requested regions overlap \"\n                        \"(rom %s. free=0x\" TARGET_FMT_plx\n                        \", addr=0x\" TARGET_FMT_plx \")\\n\",\n                        rom->name, addr, rom->addr);\n                return -1;\n            }\n            addr  = rom->addr;\n            addr += rom->romsize;\n            as = rom->as;\n        }\n        section = memory_region_find(rom->mr ? rom->mr : get_system_memory(),\n                                     rom->addr, 1);\n        rom->isrom = int128_nz(section.size) && memory_region_is_rom(section.mr);\n        memory_region_unref(section.mr);\n    }\n    qemu_register_reset(rom_reset, NULL);\n    roms_loaded = 1;\n    return 0;\n}\n\nvoid rom_set_fw(FWCfgState *f)\n{\n    fw_cfg = f;\n}\n\nvoid rom_set_order_override(int order)\n{\n    if (!fw_cfg)\n        return;\n    fw_cfg_set_order_override(fw_cfg, order);\n}\n\nvoid rom_reset_order_override(void)\n{\n    if (!fw_cfg)\n        return;\n    fw_cfg_reset_order_override(fw_cfg);\n}\n\nvoid rom_transaction_begin(void)\n{\n    Rom *rom;\n\n    /* Ignore ROMs added without the transaction API */\n    QTAILQ_FOREACH(rom, &roms, next) {\n        rom->committed = true;\n    }\n}\n\nvoid rom_transaction_end(bool commit)\n{\n    Rom *rom;\n    Rom *tmp;\n\n    QTAILQ_FOREACH_SAFE(rom, &roms, next, tmp) {\n        if (rom->committed) {\n            continue;\n        }\n        if (commit) {\n            rom->committed = true;\n        } else {\n            QTAILQ_REMOVE(&roms, rom, next);\n            rom_free(rom);\n        }\n    }\n}\n\nstatic Rom *find_rom(hwaddr addr, size_t size)\n{\n    Rom *rom;\n\n    QTAILQ_FOREACH(rom, &roms, next) {\n        if (rom->fw_file) {\n            continue;\n        }\n        if (rom->mr) {\n            continue;\n        }\n        if (rom->addr > addr) {\n            continue;\n        }\n        if (rom->addr + rom->romsize < addr + size) {\n            continue;\n        }\n        return rom;\n    }\n    return NULL;\n}\n\n/*\n * Copies memory from registered ROMs to dest. Any memory that is contained in\n * a ROM between addr and addr + size is copied. Note that this can involve\n * multiple ROMs, which need not start at addr and need not end at addr + size.\n */\nint rom_copy(uint8_t *dest, hwaddr addr, size_t size)\n{\n    hwaddr end = addr + size;\n    uint8_t *s, *d = dest;\n    size_t l = 0;\n    Rom *rom;\n\n    QTAILQ_FOREACH(rom, &roms, next) {\n        if (rom->fw_file) {\n            continue;\n        }\n        if (rom->mr) {\n            continue;\n        }\n        if (rom->addr + rom->romsize < addr) {\n            continue;\n        }\n        if (rom->addr > end) {\n            break;\n        }\n\n        d = dest + (rom->addr - addr);\n        s = rom->data;\n        l = rom->datasize;\n\n        if ((d + l) > (dest + size)) {\n            l = dest - d;\n        }\n\n        if (l > 0) {\n            memcpy(d, s, l);\n        }\n\n        if (rom->romsize > rom->datasize) {\n            /* If datasize is less than romsize, it means that we didn't\n             * allocate all the ROM because the trailing data are only zeros.\n             */\n\n            d += l;\n            l = rom->romsize - rom->datasize;\n\n            if ((d + l) > (dest + size)) {\n                /* Rom size doesn't fit in the destination area. Adjust to avoid\n                 * overflow.\n                 */\n                l = dest - d;\n            }\n\n            if (l > 0) {\n                memset(d, 0x0, l);\n            }\n        }\n    }\n\n    return (d + l) - dest;\n}\n\nvoid *rom_ptr(hwaddr addr, size_t size)\n{\n    Rom *rom;\n\n    rom = find_rom(addr, size);\n    if (!rom || !rom->data)\n        return NULL;\n    return rom->data + (addr - rom->addr);\n}\n\nvoid hmp_info_roms(Monitor *mon, const QDict *qdict)\n{\n    Rom *rom;\n\n    QTAILQ_FOREACH(rom, &roms, next) {\n        if (rom->mr) {\n            monitor_printf(mon, \"%s\"\n                           \" size=0x%06zx name=\\\"%s\\\"\\n\",\n                           memory_region_name(rom->mr),\n                           rom->romsize,\n                           rom->name);\n        } else if (!rom->fw_file) {\n            monitor_printf(mon, \"addr=\" TARGET_FMT_plx\n                           \" size=0x%06zx mem=%s name=\\\"%s\\\"\\n\",\n                           rom->addr, rom->romsize,\n                           rom->isrom ? \"rom\" : \"ram\",\n                           rom->name);\n        } else {\n            monitor_printf(mon, \"fw=%s/%s\"\n                           \" size=0x%06zx name=\\\"%s\\\"\\n\",\n                           rom->fw_dir,\n                           rom->fw_file,\n                           rom->romsize,\n                           rom->name);\n        }\n    }\n}\n\ntypedef enum HexRecord HexRecord;\nenum HexRecord {\n    DATA_RECORD = 0,\n    EOF_RECORD,\n    EXT_SEG_ADDR_RECORD,\n    START_SEG_ADDR_RECORD,\n    EXT_LINEAR_ADDR_RECORD,\n    START_LINEAR_ADDR_RECORD,\n};\n\n/* Each record contains a 16-bit address which is combined with the upper 16\n * bits of the implicit \"next address\" to form a 32-bit address.\n */\n#define NEXT_ADDR_MASK 0xffff0000\n\n#define DATA_FIELD_MAX_LEN 0xff\n#define LEN_EXCEPT_DATA 0x5\n/* 0x5 = sizeof(byte_count) + sizeof(address) + sizeof(record_type) +\n *       sizeof(checksum) */\ntypedef struct {\n    uint8_t byte_count;\n    uint16_t address;\n    uint8_t record_type;\n    uint8_t data[DATA_FIELD_MAX_LEN];\n    uint8_t checksum;\n} HexLine;\n\n/* return 0 or -1 if error */\nstatic bool parse_record(HexLine *line, uint8_t *our_checksum, const uint8_t c,\n                         uint32_t *index, const bool in_process)\n{\n    /* +-------+---------------+-------+---------------------+--------+\n     * | byte  |               |record |                     |        |\n     * | count |    address    | type  |        data         |checksum|\n     * +-------+---------------+-------+---------------------+--------+\n     * ^       ^               ^       ^                     ^        ^\n     * |1 byte |    2 bytes    |1 byte |     0-255 bytes     | 1 byte |\n     */\n    uint8_t value = 0;\n    uint32_t idx = *index;\n    /* ignore space */\n    if (g_ascii_isspace(c)) {\n        return true;\n    }\n    if (!g_ascii_isxdigit(c) || !in_process) {\n        return false;\n    }\n    value = g_ascii_xdigit_value(c);\n    value = (idx & 0x1) ? (value & 0xf) : (value << 4);\n    if (idx < 2) {\n        line->byte_count |= value;\n    } else if (2 <= idx && idx < 6) {\n        line->address <<= 4;\n        line->address += g_ascii_xdigit_value(c);\n    } else if (6 <= idx && idx < 8) {\n        line->record_type |= value;\n    } else if (8 <= idx && idx < 8 + 2 * line->byte_count) {\n        line->data[(idx - 8) >> 1] |= value;\n    } else if (8 + 2 * line->byte_count <= idx &&\n               idx < 10 + 2 * line->byte_count) {\n        line->checksum |= value;\n    } else {\n        return false;\n    }\n    *our_checksum += value;\n    ++(*index);\n    return true;\n}\n\ntypedef struct {\n    const char *filename;\n    HexLine line;\n    uint8_t *bin_buf;\n    hwaddr *start_addr;\n    int total_size;\n    uint32_t next_address_to_write;\n    uint32_t current_address;\n    uint32_t current_rom_index;\n    uint32_t rom_start_address;\n    AddressSpace *as;\n} HexParser;\n\n/* return size or -1 if error */\nstatic int handle_record_type(HexParser *parser)\n{\n    HexLine *line = &(parser->line);\n    switch (line->record_type) {\n    case DATA_RECORD:\n        parser->current_address =\n            (parser->next_address_to_write & NEXT_ADDR_MASK) | line->address;\n        /* verify this is a contiguous block of memory */\n        if (parser->current_address != parser->next_address_to_write) {\n            if (parser->current_rom_index != 0) {\n                rom_add_blob_fixed_as(parser->filename, parser->bin_buf,\n                                      parser->current_rom_index,\n                                      parser->rom_start_address, parser->as);\n            }\n            parser->rom_start_address = parser->current_address;\n            parser->current_rom_index = 0;\n        }\n\n        /* copy from line buffer to output bin_buf */\n        memcpy(parser->bin_buf + parser->current_rom_index, line->data,\n               line->byte_count);\n        parser->current_rom_index += line->byte_count;\n        parser->total_size += line->byte_count;\n        /* save next address to write */\n        parser->next_address_to_write =\n            parser->current_address + line->byte_count;\n        break;\n\n    case EOF_RECORD:\n        if (parser->current_rom_index != 0) {\n            rom_add_blob_fixed_as(parser->filename, parser->bin_buf,\n                                  parser->current_rom_index,\n                                  parser->rom_start_address, parser->as);\n        }\n        return parser->total_size;\n    case EXT_SEG_ADDR_RECORD:\n    case EXT_LINEAR_ADDR_RECORD:\n        if (line->byte_count != 2 && line->address != 0) {\n            return -1;\n        }\n\n        if (parser->current_rom_index != 0) {\n            rom_add_blob_fixed_as(parser->filename, parser->bin_buf,\n                                  parser->current_rom_index,\n                                  parser->rom_start_address, parser->as);\n        }\n\n        /* save next address to write,\n         * in case of non-contiguous block of memory */\n        parser->next_address_to_write = (line->data[0] << 12) |\n                                        (line->data[1] << 4);\n        if (line->record_type == EXT_LINEAR_ADDR_RECORD) {\n            parser->next_address_to_write <<= 12;\n        }\n\n        parser->rom_start_address = parser->next_address_to_write;\n        parser->current_rom_index = 0;\n        break;\n\n    case START_SEG_ADDR_RECORD:\n        if (line->byte_count != 4 && line->address != 0) {\n            return -1;\n        }\n\n        /* x86 16-bit CS:IP segmented addressing */\n        *(parser->start_addr) = (((line->data[0] << 8) | line->data[1]) << 4) +\n                                ((line->data[2] << 8) | line->data[3]);\n        break;\n\n    case START_LINEAR_ADDR_RECORD:\n        if (line->byte_count != 4 && line->address != 0) {\n            return -1;\n        }\n\n        *(parser->start_addr) = ldl_be_p(line->data);\n        break;\n\n    default:\n        return -1;\n    }\n\n    return parser->total_size;\n}\n\n/* return size or -1 if error */\nstatic int parse_hex_blob(const char *filename, hwaddr *addr, uint8_t *hex_blob,\n                          size_t hex_blob_size, AddressSpace *as)\n{\n    bool in_process = false; /* avoid re-enter and\n                              * check whether record begin with ':' */\n    uint8_t *end = hex_blob + hex_blob_size;\n    uint8_t our_checksum = 0;\n    uint32_t record_index = 0;\n    HexParser parser = {\n        .filename = filename,\n        .bin_buf = g_malloc(hex_blob_size),\n        .start_addr = addr,\n        .as = as,\n    };\n\n    rom_transaction_begin();\n\n    for (; hex_blob < end; ++hex_blob) {\n        switch (*hex_blob) {\n        case '\\r':\n        case '\\n':\n            if (!in_process) {\n                break;\n            }\n\n            in_process = false;\n            if ((LEN_EXCEPT_DATA + parser.line.byte_count) * 2 !=\n                    record_index ||\n                our_checksum != 0) {\n                parser.total_size = -1;\n                goto out;\n            }\n\n            if (handle_record_type(&parser) == -1) {\n                parser.total_size = -1;\n                goto out;\n            }\n            break;\n\n        /* start of a new record. */\n        case ':':\n            memset(&parser.line, 0, sizeof(HexLine));\n            in_process = true;\n            record_index = 0;\n            break;\n\n        /* decoding lines */\n        default:\n            if (!parse_record(&parser.line, &our_checksum, *hex_blob,\n                              &record_index, in_process)) {\n                parser.total_size = -1;\n                goto out;\n            }\n            break;\n        }\n    }\n\nout:\n    g_free(parser.bin_buf);\n    rom_transaction_end(parser.total_size != -1);\n    return parser.total_size;\n}\n\n/* return size or -1 if error */\nint load_targphys_hex_as(const char *filename, hwaddr *entry, AddressSpace *as)\n{\n    gsize hex_blob_size;\n    gchar *hex_blob;\n    int total_size = 0;\n\n    if (!g_file_get_contents(filename, &hex_blob, &hex_blob_size, NULL)) {\n        return -1;\n    }\n\n    total_size = parse_hex_blob(filename, entry, (uint8_t *)hex_blob,\n                                hex_blob_size, as);\n\n    g_free(hex_blob);\n    return total_size;\n}\n"], "fixing_code": ["/*\n * QEMU Executable loader\n *\n * Copyright (c) 2006 Fabrice Bellard\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\n * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n *\n * Gunzip functionality in this file is derived from u-boot:\n *\n * (C) Copyright 2008 Semihalf\n *\n * (C) Copyright 2000-2005\n * Wolfgang Denk, DENX Software Engineering, wd@denx.de.\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License as\n * published by the Free Software Foundation; either version 2 of\n * the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"qemu/osdep.h\"\n#include \"qapi/error.h\"\n#include \"hw/hw.h\"\n#include \"disas/disas.h\"\n#include \"monitor/monitor.h\"\n#include \"sysemu/sysemu.h\"\n#include \"uboot_image.h\"\n#include \"hw/loader.h\"\n#include \"hw/nvram/fw_cfg.h\"\n#include \"exec/memory.h\"\n#include \"exec/address-spaces.h\"\n#include \"hw/boards.h\"\n#include \"qemu/cutils.h\"\n\n#include <zlib.h>\n\nstatic int roms_loaded;\n\n/* return the size or -1 if error */\nint64_t get_image_size(const char *filename)\n{\n    int fd;\n    int64_t size;\n    fd = open(filename, O_RDONLY | O_BINARY);\n    if (fd < 0)\n        return -1;\n    size = lseek(fd, 0, SEEK_END);\n    close(fd);\n    return size;\n}\n\n/* return the size or -1 if error */\nssize_t load_image_size(const char *filename, void *addr, size_t size)\n{\n    int fd;\n    ssize_t actsize, l = 0;\n\n    fd = open(filename, O_RDONLY | O_BINARY);\n    if (fd < 0) {\n        return -1;\n    }\n\n    while ((actsize = read(fd, addr + l, size - l)) > 0) {\n        l += actsize;\n    }\n\n    close(fd);\n\n    return actsize < 0 ? -1 : l;\n}\n\n/* read()-like version */\nssize_t read_targphys(const char *name,\n                      int fd, hwaddr dst_addr, size_t nbytes)\n{\n    uint8_t *buf;\n    ssize_t did;\n\n    buf = g_malloc(nbytes);\n    did = read(fd, buf, nbytes);\n    if (did > 0)\n        rom_add_blob_fixed(\"read\", buf, did, dst_addr);\n    g_free(buf);\n    return did;\n}\n\nint load_image_targphys(const char *filename,\n                        hwaddr addr, uint64_t max_sz)\n{\n    return load_image_targphys_as(filename, addr, max_sz, NULL);\n}\n\n/* return the size or -1 if error */\nint load_image_targphys_as(const char *filename,\n                           hwaddr addr, uint64_t max_sz, AddressSpace *as)\n{\n    int size;\n\n    size = get_image_size(filename);\n    if (size < 0 || size > max_sz) {\n        return -1;\n    }\n    if (size > 0) {\n        if (rom_add_file_fixed_as(filename, addr, -1, as) < 0) {\n            return -1;\n        }\n    }\n    return size;\n}\n\nint load_image_mr(const char *filename, MemoryRegion *mr)\n{\n    int size;\n\n    if (!memory_access_is_direct(mr, false)) {\n        /* Can only load an image into RAM or ROM */\n        return -1;\n    }\n\n    size = get_image_size(filename);\n\n    if (size < 0 || size > memory_region_size(mr)) {\n        return -1;\n    }\n    if (size > 0) {\n        if (rom_add_file_mr(filename, mr, -1) < 0) {\n            return -1;\n        }\n    }\n    return size;\n}\n\nvoid pstrcpy_targphys(const char *name, hwaddr dest, int buf_size,\n                      const char *source)\n{\n    const char *nulp;\n    char *ptr;\n\n    if (buf_size <= 0) return;\n    nulp = memchr(source, 0, buf_size);\n    if (nulp) {\n        rom_add_blob_fixed(name, source, (nulp - source) + 1, dest);\n    } else {\n        rom_add_blob_fixed(name, source, buf_size, dest);\n        ptr = rom_ptr(dest + buf_size - 1, sizeof(*ptr));\n        *ptr = 0;\n    }\n}\n\n/* A.OUT loader */\n\nstruct exec\n{\n  uint32_t a_info;   /* Use macros N_MAGIC, etc for access */\n  uint32_t a_text;   /* length of text, in bytes */\n  uint32_t a_data;   /* length of data, in bytes */\n  uint32_t a_bss;    /* length of uninitialized data area, in bytes */\n  uint32_t a_syms;   /* length of symbol table data in file, in bytes */\n  uint32_t a_entry;  /* start address */\n  uint32_t a_trsize; /* length of relocation info for text, in bytes */\n  uint32_t a_drsize; /* length of relocation info for data, in bytes */\n};\n\nstatic void bswap_ahdr(struct exec *e)\n{\n    bswap32s(&e->a_info);\n    bswap32s(&e->a_text);\n    bswap32s(&e->a_data);\n    bswap32s(&e->a_bss);\n    bswap32s(&e->a_syms);\n    bswap32s(&e->a_entry);\n    bswap32s(&e->a_trsize);\n    bswap32s(&e->a_drsize);\n}\n\n#define N_MAGIC(exec) ((exec).a_info & 0xffff)\n#define OMAGIC 0407\n#define NMAGIC 0410\n#define ZMAGIC 0413\n#define QMAGIC 0314\n#define _N_HDROFF(x) (1024 - sizeof (struct exec))\n#define N_TXTOFF(x)\t\t\t\t\t\t\t\\\n    (N_MAGIC(x) == ZMAGIC ? _N_HDROFF((x)) + sizeof (struct exec) :\t\\\n     (N_MAGIC(x) == QMAGIC ? 0 : sizeof (struct exec)))\n#define N_TXTADDR(x, target_page_size) (N_MAGIC(x) == QMAGIC ? target_page_size : 0)\n#define _N_SEGMENT_ROUND(x, target_page_size) (((x) + target_page_size - 1) & ~(target_page_size - 1))\n\n#define _N_TXTENDADDR(x, target_page_size) (N_TXTADDR(x, target_page_size)+(x).a_text)\n\n#define N_DATADDR(x, target_page_size) \\\n    (N_MAGIC(x)==OMAGIC? (_N_TXTENDADDR(x, target_page_size)) \\\n     : (_N_SEGMENT_ROUND (_N_TXTENDADDR(x, target_page_size), target_page_size)))\n\n\nint load_aout(const char *filename, hwaddr addr, int max_sz,\n              int bswap_needed, hwaddr target_page_size)\n{\n    int fd;\n    ssize_t size, ret;\n    struct exec e;\n    uint32_t magic;\n\n    fd = open(filename, O_RDONLY | O_BINARY);\n    if (fd < 0)\n        return -1;\n\n    size = read(fd, &e, sizeof(e));\n    if (size < 0)\n        goto fail;\n\n    if (bswap_needed) {\n        bswap_ahdr(&e);\n    }\n\n    magic = N_MAGIC(e);\n    switch (magic) {\n    case ZMAGIC:\n    case QMAGIC:\n    case OMAGIC:\n        if (e.a_text + e.a_data > max_sz)\n            goto fail;\n        lseek(fd, N_TXTOFF(e), SEEK_SET);\n        size = read_targphys(filename, fd, addr, e.a_text + e.a_data);\n        if (size < 0)\n            goto fail;\n        break;\n    case NMAGIC:\n        if (N_DATADDR(e, target_page_size) + e.a_data > max_sz)\n            goto fail;\n        lseek(fd, N_TXTOFF(e), SEEK_SET);\n        size = read_targphys(filename, fd, addr, e.a_text);\n        if (size < 0)\n            goto fail;\n        ret = read_targphys(filename, fd, addr + N_DATADDR(e, target_page_size),\n                            e.a_data);\n        if (ret < 0)\n            goto fail;\n        size += ret;\n        break;\n    default:\n        goto fail;\n    }\n    close(fd);\n    return size;\n fail:\n    close(fd);\n    return -1;\n}\n\n/* ELF loader */\n\nstatic void *load_at(int fd, off_t offset, size_t size)\n{\n    void *ptr;\n    if (lseek(fd, offset, SEEK_SET) < 0)\n        return NULL;\n    ptr = g_malloc(size);\n    if (read(fd, ptr, size) != size) {\n        g_free(ptr);\n        return NULL;\n    }\n    return ptr;\n}\n\n#ifdef ELF_CLASS\n#undef ELF_CLASS\n#endif\n\n#define ELF_CLASS   ELFCLASS32\n#include \"elf.h\"\n\n#define SZ\t\t32\n#define elf_word        uint32_t\n#define elf_sword        int32_t\n#define bswapSZs\tbswap32s\n#include \"hw/elf_ops.h\"\n\n#undef elfhdr\n#undef elf_phdr\n#undef elf_shdr\n#undef elf_sym\n#undef elf_rela\n#undef elf_note\n#undef elf_word\n#undef elf_sword\n#undef bswapSZs\n#undef SZ\n#define elfhdr\t\telf64_hdr\n#define elf_phdr\telf64_phdr\n#define elf_note\telf64_note\n#define elf_shdr\telf64_shdr\n#define elf_sym\t\telf64_sym\n#define elf_rela        elf64_rela\n#define elf_word        uint64_t\n#define elf_sword        int64_t\n#define bswapSZs\tbswap64s\n#define SZ\t\t64\n#include \"hw/elf_ops.h\"\n\nconst char *load_elf_strerror(int error)\n{\n    switch (error) {\n    case 0:\n        return \"No error\";\n    case ELF_LOAD_FAILED:\n        return \"Failed to load ELF\";\n    case ELF_LOAD_NOT_ELF:\n        return \"The image is not ELF\";\n    case ELF_LOAD_WRONG_ARCH:\n        return \"The image is from incompatible architecture\";\n    case ELF_LOAD_WRONG_ENDIAN:\n        return \"The image has incorrect endianness\";\n    default:\n        return \"Unknown error\";\n    }\n}\n\nvoid load_elf_hdr(const char *filename, void *hdr, bool *is64, Error **errp)\n{\n    int fd;\n    uint8_t e_ident_local[EI_NIDENT];\n    uint8_t *e_ident;\n    size_t hdr_size, off;\n    bool is64l;\n\n    if (!hdr) {\n        hdr = e_ident_local;\n    }\n    e_ident = hdr;\n\n    fd = open(filename, O_RDONLY | O_BINARY);\n    if (fd < 0) {\n        error_setg_errno(errp, errno, \"Failed to open file: %s\", filename);\n        return;\n    }\n    if (read(fd, hdr, EI_NIDENT) != EI_NIDENT) {\n        error_setg_errno(errp, errno, \"Failed to read file: %s\", filename);\n        goto fail;\n    }\n    if (e_ident[0] != ELFMAG0 ||\n        e_ident[1] != ELFMAG1 ||\n        e_ident[2] != ELFMAG2 ||\n        e_ident[3] != ELFMAG3) {\n        error_setg(errp, \"Bad ELF magic\");\n        goto fail;\n    }\n\n    is64l = e_ident[EI_CLASS] == ELFCLASS64;\n    hdr_size = is64l ? sizeof(Elf64_Ehdr) : sizeof(Elf32_Ehdr);\n    if (is64) {\n        *is64 = is64l;\n    }\n\n    off = EI_NIDENT;\n    while (hdr != e_ident_local && off < hdr_size) {\n        size_t br = read(fd, hdr + off, hdr_size - off);\n        switch (br) {\n        case 0:\n            error_setg(errp, \"File too short: %s\", filename);\n            goto fail;\n        case -1:\n            error_setg_errno(errp, errno, \"Failed to read file: %s\",\n                             filename);\n            goto fail;\n        }\n        off += br;\n    }\n\nfail:\n    close(fd);\n}\n\n/* return < 0 if error, otherwise the number of bytes loaded in memory */\nint load_elf(const char *filename,\n             uint64_t (*elf_note_fn)(void *, void *, bool),\n             uint64_t (*translate_fn)(void *, uint64_t),\n             void *translate_opaque, uint64_t *pentry, uint64_t *lowaddr,\n             uint64_t *highaddr, int big_endian, int elf_machine,\n             int clear_lsb, int data_swab)\n{\n    return load_elf_as(filename, elf_note_fn, translate_fn, translate_opaque,\n                       pentry, lowaddr, highaddr, big_endian, elf_machine,\n                       clear_lsb, data_swab, NULL);\n}\n\n/* return < 0 if error, otherwise the number of bytes loaded in memory */\nint load_elf_as(const char *filename,\n                uint64_t (*elf_note_fn)(void *, void *, bool),\n                uint64_t (*translate_fn)(void *, uint64_t),\n                void *translate_opaque, uint64_t *pentry, uint64_t *lowaddr,\n                uint64_t *highaddr, int big_endian, int elf_machine,\n                int clear_lsb, int data_swab, AddressSpace *as)\n{\n    return load_elf_ram(filename, elf_note_fn, translate_fn, translate_opaque,\n                        pentry, lowaddr, highaddr, big_endian, elf_machine,\n                        clear_lsb, data_swab, as, true);\n}\n\n/* return < 0 if error, otherwise the number of bytes loaded in memory */\nint load_elf_ram(const char *filename,\n                 uint64_t (*elf_note_fn)(void *, void *, bool),\n                 uint64_t (*translate_fn)(void *, uint64_t),\n                 void *translate_opaque, uint64_t *pentry, uint64_t *lowaddr,\n                 uint64_t *highaddr, int big_endian, int elf_machine,\n                 int clear_lsb, int data_swab, AddressSpace *as,\n                 bool load_rom)\n{\n    return load_elf_ram_sym(filename, elf_note_fn,\n                            translate_fn, translate_opaque,\n                            pentry, lowaddr, highaddr, big_endian,\n                            elf_machine, clear_lsb, data_swab, as,\n                            load_rom, NULL);\n}\n\n/* return < 0 if error, otherwise the number of bytes loaded in memory */\nint load_elf_ram_sym(const char *filename,\n                     uint64_t (*elf_note_fn)(void *, void *, bool),\n                     uint64_t (*translate_fn)(void *, uint64_t),\n                     void *translate_opaque, uint64_t *pentry,\n                     uint64_t *lowaddr, uint64_t *highaddr, int big_endian,\n                     int elf_machine, int clear_lsb, int data_swab,\n                     AddressSpace *as, bool load_rom, symbol_fn_t sym_cb)\n{\n    int fd, data_order, target_data_order, must_swab, ret = ELF_LOAD_FAILED;\n    uint8_t e_ident[EI_NIDENT];\n\n    fd = open(filename, O_RDONLY | O_BINARY);\n    if (fd < 0) {\n        perror(filename);\n        return -1;\n    }\n    if (read(fd, e_ident, sizeof(e_ident)) != sizeof(e_ident))\n        goto fail;\n    if (e_ident[0] != ELFMAG0 ||\n        e_ident[1] != ELFMAG1 ||\n        e_ident[2] != ELFMAG2 ||\n        e_ident[3] != ELFMAG3) {\n        ret = ELF_LOAD_NOT_ELF;\n        goto fail;\n    }\n#ifdef HOST_WORDS_BIGENDIAN\n    data_order = ELFDATA2MSB;\n#else\n    data_order = ELFDATA2LSB;\n#endif\n    must_swab = data_order != e_ident[EI_DATA];\n    if (big_endian) {\n        target_data_order = ELFDATA2MSB;\n    } else {\n        target_data_order = ELFDATA2LSB;\n    }\n\n    if (target_data_order != e_ident[EI_DATA]) {\n        ret = ELF_LOAD_WRONG_ENDIAN;\n        goto fail;\n    }\n\n    lseek(fd, 0, SEEK_SET);\n    if (e_ident[EI_CLASS] == ELFCLASS64) {\n        ret = load_elf64(filename, fd, elf_note_fn,\n                         translate_fn, translate_opaque, must_swab,\n                         pentry, lowaddr, highaddr, elf_machine, clear_lsb,\n                         data_swab, as, load_rom, sym_cb);\n    } else {\n        ret = load_elf32(filename, fd, elf_note_fn,\n                         translate_fn, translate_opaque, must_swab,\n                         pentry, lowaddr, highaddr, elf_machine, clear_lsb,\n                         data_swab, as, load_rom, sym_cb);\n    }\n\n fail:\n    close(fd);\n    return ret;\n}\n\nstatic void bswap_uboot_header(uboot_image_header_t *hdr)\n{\n#ifndef HOST_WORDS_BIGENDIAN\n    bswap32s(&hdr->ih_magic);\n    bswap32s(&hdr->ih_hcrc);\n    bswap32s(&hdr->ih_time);\n    bswap32s(&hdr->ih_size);\n    bswap32s(&hdr->ih_load);\n    bswap32s(&hdr->ih_ep);\n    bswap32s(&hdr->ih_dcrc);\n#endif\n}\n\n\n#define ZALLOC_ALIGNMENT\t16\n\nstatic void *zalloc(void *x, unsigned items, unsigned size)\n{\n    void *p;\n\n    size *= items;\n    size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);\n\n    p = g_malloc(size);\n\n    return (p);\n}\n\nstatic void zfree(void *x, void *addr)\n{\n    g_free(addr);\n}\n\n\n#define HEAD_CRC\t2\n#define EXTRA_FIELD\t4\n#define ORIG_NAME\t8\n#define COMMENT\t\t0x10\n#define RESERVED\t0xe0\n\n#define DEFLATED\t8\n\nssize_t gunzip(void *dst, size_t dstlen, uint8_t *src, size_t srclen)\n{\n    z_stream s;\n    ssize_t dstbytes;\n    int r, i, flags;\n\n    /* skip header */\n    i = 10;\n    flags = src[3];\n    if (src[2] != DEFLATED || (flags & RESERVED) != 0) {\n        puts (\"Error: Bad gzipped data\\n\");\n        return -1;\n    }\n    if ((flags & EXTRA_FIELD) != 0)\n        i = 12 + src[10] + (src[11] << 8);\n    if ((flags & ORIG_NAME) != 0)\n        while (src[i++] != 0)\n            ;\n    if ((flags & COMMENT) != 0)\n        while (src[i++] != 0)\n            ;\n    if ((flags & HEAD_CRC) != 0)\n        i += 2;\n    if (i >= srclen) {\n        puts (\"Error: gunzip out of data in header\\n\");\n        return -1;\n    }\n\n    s.zalloc = zalloc;\n    s.zfree = zfree;\n\n    r = inflateInit2(&s, -MAX_WBITS);\n    if (r != Z_OK) {\n        printf (\"Error: inflateInit2() returned %d\\n\", r);\n        return (-1);\n    }\n    s.next_in = src + i;\n    s.avail_in = srclen - i;\n    s.next_out = dst;\n    s.avail_out = dstlen;\n    r = inflate(&s, Z_FINISH);\n    if (r != Z_OK && r != Z_STREAM_END) {\n        printf (\"Error: inflate() returned %d\\n\", r);\n        return -1;\n    }\n    dstbytes = s.next_out - (unsigned char *) dst;\n    inflateEnd(&s);\n\n    return dstbytes;\n}\n\n/* Load a U-Boot image.  */\nstatic int load_uboot_image(const char *filename, hwaddr *ep, hwaddr *loadaddr,\n                            int *is_linux, uint8_t image_type,\n                            uint64_t (*translate_fn)(void *, uint64_t),\n                            void *translate_opaque, AddressSpace *as)\n{\n    int fd;\n    int size;\n    hwaddr address;\n    uboot_image_header_t h;\n    uboot_image_header_t *hdr = &h;\n    uint8_t *data = NULL;\n    int ret = -1;\n    int do_uncompress = 0;\n\n    fd = open(filename, O_RDONLY | O_BINARY);\n    if (fd < 0)\n        return -1;\n\n    size = read(fd, hdr, sizeof(uboot_image_header_t));\n    if (size < sizeof(uboot_image_header_t)) {\n        goto out;\n    }\n\n    bswap_uboot_header(hdr);\n\n    if (hdr->ih_magic != IH_MAGIC)\n        goto out;\n\n    if (hdr->ih_type != image_type) {\n        if (!(image_type == IH_TYPE_KERNEL &&\n            hdr->ih_type == IH_TYPE_KERNEL_NOLOAD)) {\n            fprintf(stderr, \"Wrong image type %d, expected %d\\n\", hdr->ih_type,\n                    image_type);\n            goto out;\n        }\n    }\n\n    /* TODO: Implement other image types.  */\n    switch (hdr->ih_type) {\n    case IH_TYPE_KERNEL_NOLOAD:\n        if (!loadaddr || *loadaddr == LOAD_UIMAGE_LOADADDR_INVALID) {\n            fprintf(stderr, \"this image format (kernel_noload) cannot be \"\n                    \"loaded on this machine type\");\n            goto out;\n        }\n\n        hdr->ih_load = *loadaddr + sizeof(*hdr);\n        hdr->ih_ep += hdr->ih_load;\n        /* fall through */\n    case IH_TYPE_KERNEL:\n        address = hdr->ih_load;\n        if (translate_fn) {\n            address = translate_fn(translate_opaque, address);\n        }\n        if (loadaddr) {\n            *loadaddr = hdr->ih_load;\n        }\n\n        switch (hdr->ih_comp) {\n        case IH_COMP_NONE:\n            break;\n        case IH_COMP_GZIP:\n            do_uncompress = 1;\n            break;\n        default:\n            fprintf(stderr,\n                    \"Unable to load u-boot images with compression type %d\\n\",\n                    hdr->ih_comp);\n            goto out;\n        }\n\n        if (ep) {\n            *ep = hdr->ih_ep;\n        }\n\n        /* TODO: Check CPU type.  */\n        if (is_linux) {\n            if (hdr->ih_os == IH_OS_LINUX) {\n                *is_linux = 1;\n            } else {\n                *is_linux = 0;\n            }\n        }\n\n        break;\n    case IH_TYPE_RAMDISK:\n        address = *loadaddr;\n        break;\n    default:\n        fprintf(stderr, \"Unsupported u-boot image type %d\\n\", hdr->ih_type);\n        goto out;\n    }\n\n    data = g_malloc(hdr->ih_size);\n\n    if (read(fd, data, hdr->ih_size) != hdr->ih_size) {\n        fprintf(stderr, \"Error reading file\\n\");\n        goto out;\n    }\n\n    if (do_uncompress) {\n        uint8_t *compressed_data;\n        size_t max_bytes;\n        ssize_t bytes;\n\n        compressed_data = data;\n        max_bytes = UBOOT_MAX_GUNZIP_BYTES;\n        data = g_malloc(max_bytes);\n\n        bytes = gunzip(data, max_bytes, compressed_data, hdr->ih_size);\n        g_free(compressed_data);\n        if (bytes < 0) {\n            fprintf(stderr, \"Unable to decompress gzipped image!\\n\");\n            goto out;\n        }\n        hdr->ih_size = bytes;\n    }\n\n    rom_add_blob_fixed_as(filename, data, hdr->ih_size, address, as);\n\n    ret = hdr->ih_size;\n\nout:\n    g_free(data);\n    close(fd);\n    return ret;\n}\n\nint load_uimage(const char *filename, hwaddr *ep, hwaddr *loadaddr,\n                int *is_linux,\n                uint64_t (*translate_fn)(void *, uint64_t),\n                void *translate_opaque)\n{\n    return load_uboot_image(filename, ep, loadaddr, is_linux, IH_TYPE_KERNEL,\n                            translate_fn, translate_opaque, NULL);\n}\n\nint load_uimage_as(const char *filename, hwaddr *ep, hwaddr *loadaddr,\n                   int *is_linux,\n                   uint64_t (*translate_fn)(void *, uint64_t),\n                   void *translate_opaque, AddressSpace *as)\n{\n    return load_uboot_image(filename, ep, loadaddr, is_linux, IH_TYPE_KERNEL,\n                            translate_fn, translate_opaque, as);\n}\n\n/* Load a ramdisk.  */\nint load_ramdisk(const char *filename, hwaddr addr, uint64_t max_sz)\n{\n    return load_ramdisk_as(filename, addr, max_sz, NULL);\n}\n\nint load_ramdisk_as(const char *filename, hwaddr addr, uint64_t max_sz,\n                    AddressSpace *as)\n{\n    return load_uboot_image(filename, NULL, &addr, NULL, IH_TYPE_RAMDISK,\n                            NULL, NULL, as);\n}\n\n/* Load a gzip-compressed kernel to a dynamically allocated buffer. */\nint load_image_gzipped_buffer(const char *filename, uint64_t max_sz,\n                              uint8_t **buffer)\n{\n    uint8_t *compressed_data = NULL;\n    uint8_t *data = NULL;\n    gsize len;\n    ssize_t bytes;\n    int ret = -1;\n\n    if (!g_file_get_contents(filename, (char **) &compressed_data, &len,\n                             NULL)) {\n        goto out;\n    }\n\n    /* Is it a gzip-compressed file? */\n    if (len < 2 ||\n        compressed_data[0] != 0x1f ||\n        compressed_data[1] != 0x8b) {\n        goto out;\n    }\n\n    if (max_sz > LOAD_IMAGE_MAX_GUNZIP_BYTES) {\n        max_sz = LOAD_IMAGE_MAX_GUNZIP_BYTES;\n    }\n\n    data = g_malloc(max_sz);\n    bytes = gunzip(data, max_sz, compressed_data, len);\n    if (bytes < 0) {\n        fprintf(stderr, \"%s: unable to decompress gzipped kernel file\\n\",\n                filename);\n        goto out;\n    }\n\n    /* trim to actual size and return to caller */\n    *buffer = g_realloc(data, bytes);\n    ret = bytes;\n    /* ownership has been transferred to caller */\n    data = NULL;\n\n out:\n    g_free(compressed_data);\n    g_free(data);\n    return ret;\n}\n\n/* Load a gzip-compressed kernel. */\nint load_image_gzipped(const char *filename, hwaddr addr, uint64_t max_sz)\n{\n    int bytes;\n    uint8_t *data;\n\n    bytes = load_image_gzipped_buffer(filename, max_sz, &data);\n    if (bytes != -1) {\n        rom_add_blob_fixed(filename, data, bytes, addr);\n        g_free(data);\n    }\n    return bytes;\n}\n\n/*\n * Functions for reboot-persistent memory regions.\n *  - used for vga bios and option roms.\n *  - also linux kernel (-kernel / -initrd).\n */\n\ntypedef struct Rom Rom;\n\nstruct Rom {\n    char *name;\n    char *path;\n\n    /* datasize is the amount of memory allocated in \"data\". If datasize is less\n     * than romsize, it means that the area from datasize to romsize is filled\n     * with zeros.\n     */\n    size_t romsize;\n    size_t datasize;\n\n    uint8_t *data;\n    MemoryRegion *mr;\n    AddressSpace *as;\n    int isrom;\n    char *fw_dir;\n    char *fw_file;\n\n    bool committed;\n\n    hwaddr addr;\n    QTAILQ_ENTRY(Rom) next;\n};\n\nstatic FWCfgState *fw_cfg;\nstatic QTAILQ_HEAD(, Rom) roms = QTAILQ_HEAD_INITIALIZER(roms);\n\n/* rom->data must be heap-allocated (do not use with rom_add_elf_program()) */\nstatic void rom_free(Rom *rom)\n{\n    g_free(rom->data);\n    g_free(rom->path);\n    g_free(rom->name);\n    g_free(rom->fw_dir);\n    g_free(rom->fw_file);\n    g_free(rom);\n}\n\nstatic inline bool rom_order_compare(Rom *rom, Rom *item)\n{\n    return ((uintptr_t)(void *)rom->as > (uintptr_t)(void *)item->as) ||\n           (rom->as == item->as && rom->addr >= item->addr);\n}\n\nstatic void rom_insert(Rom *rom)\n{\n    Rom *item;\n\n    if (roms_loaded) {\n        hw_error (\"ROM images must be loaded at startup\\n\");\n    }\n\n    /* The user didn't specify an address space, this is the default */\n    if (!rom->as) {\n        rom->as = &address_space_memory;\n    }\n\n    rom->committed = false;\n\n    /* List is ordered by load address in the same address space */\n    QTAILQ_FOREACH(item, &roms, next) {\n        if (rom_order_compare(rom, item)) {\n            continue;\n        }\n        QTAILQ_INSERT_BEFORE(item, rom, next);\n        return;\n    }\n    QTAILQ_INSERT_TAIL(&roms, rom, next);\n}\n\nstatic void fw_cfg_resized(const char *id, uint64_t length, void *host)\n{\n    if (fw_cfg) {\n        fw_cfg_modify_file(fw_cfg, id + strlen(\"/rom@\"), host, length);\n    }\n}\n\nstatic void *rom_set_mr(Rom *rom, Object *owner, const char *name, bool ro)\n{\n    void *data;\n\n    rom->mr = g_malloc(sizeof(*rom->mr));\n    memory_region_init_resizeable_ram(rom->mr, owner, name,\n                                      rom->datasize, rom->romsize,\n                                      fw_cfg_resized,\n                                      &error_fatal);\n    memory_region_set_readonly(rom->mr, ro);\n    vmstate_register_ram_global(rom->mr);\n\n    data = memory_region_get_ram_ptr(rom->mr);\n    memcpy(data, rom->data, rom->datasize);\n\n    return data;\n}\n\nint rom_add_file(const char *file, const char *fw_dir,\n                 hwaddr addr, int32_t bootindex,\n                 bool option_rom, MemoryRegion *mr,\n                 AddressSpace *as)\n{\n    MachineClass *mc = MACHINE_GET_CLASS(qdev_get_machine());\n    Rom *rom;\n    int rc, fd = -1;\n    char devpath[100];\n\n    if (as && mr) {\n        fprintf(stderr, \"Specifying an Address Space and Memory Region is \" \\\n                \"not valid when loading a rom\\n\");\n        /* We haven't allocated anything so we don't need any cleanup */\n        return -1;\n    }\n\n    rom = g_malloc0(sizeof(*rom));\n    rom->name = g_strdup(file);\n    rom->path = qemu_find_file(QEMU_FILE_TYPE_BIOS, rom->name);\n    rom->as = as;\n    if (rom->path == NULL) {\n        rom->path = g_strdup(file);\n    }\n\n    fd = open(rom->path, O_RDONLY | O_BINARY);\n    if (fd == -1) {\n        fprintf(stderr, \"Could not open option rom '%s': %s\\n\",\n                rom->path, strerror(errno));\n        goto err;\n    }\n\n    if (fw_dir) {\n        rom->fw_dir  = g_strdup(fw_dir);\n        rom->fw_file = g_strdup(file);\n    }\n    rom->addr     = addr;\n    rom->romsize  = lseek(fd, 0, SEEK_END);\n    if (rom->romsize == -1) {\n        fprintf(stderr, \"rom: file %-20s: get size error: %s\\n\",\n                rom->name, strerror(errno));\n        goto err;\n    }\n\n    rom->datasize = rom->romsize;\n    rom->data     = g_malloc0(rom->datasize);\n    lseek(fd, 0, SEEK_SET);\n    rc = read(fd, rom->data, rom->datasize);\n    if (rc != rom->datasize) {\n        fprintf(stderr, \"rom: file %-20s: read error: rc=%d (expected %zd)\\n\",\n                rom->name, rc, rom->datasize);\n        goto err;\n    }\n    close(fd);\n    rom_insert(rom);\n    if (rom->fw_file && fw_cfg) {\n        const char *basename;\n        char fw_file_name[FW_CFG_MAX_FILE_PATH];\n        void *data;\n\n        basename = strrchr(rom->fw_file, '/');\n        if (basename) {\n            basename++;\n        } else {\n            basename = rom->fw_file;\n        }\n        snprintf(fw_file_name, sizeof(fw_file_name), \"%s/%s\", rom->fw_dir,\n                 basename);\n        snprintf(devpath, sizeof(devpath), \"/rom@%s\", fw_file_name);\n\n        if ((!option_rom || mc->option_rom_has_mr) && mc->rom_file_has_mr) {\n            data = rom_set_mr(rom, OBJECT(fw_cfg), devpath, true);\n        } else {\n            data = rom->data;\n        }\n\n        fw_cfg_add_file(fw_cfg, fw_file_name, data, rom->romsize);\n    } else {\n        if (mr) {\n            rom->mr = mr;\n            snprintf(devpath, sizeof(devpath), \"/rom@%s\", file);\n        } else {\n            snprintf(devpath, sizeof(devpath), \"/rom@\" TARGET_FMT_plx, addr);\n        }\n    }\n\n    add_boot_device_path(bootindex, NULL, devpath);\n    return 0;\n\nerr:\n    if (fd != -1)\n        close(fd);\n\n    rom_free(rom);\n    return -1;\n}\n\nMemoryRegion *rom_add_blob(const char *name, const void *blob, size_t len,\n                   size_t max_len, hwaddr addr, const char *fw_file_name,\n                   FWCfgCallback fw_callback, void *callback_opaque,\n                   AddressSpace *as, bool read_only)\n{\n    MachineClass *mc = MACHINE_GET_CLASS(qdev_get_machine());\n    Rom *rom;\n    MemoryRegion *mr = NULL;\n\n    rom           = g_malloc0(sizeof(*rom));\n    rom->name     = g_strdup(name);\n    rom->as       = as;\n    rom->addr     = addr;\n    rom->romsize  = max_len ? max_len : len;\n    rom->datasize = len;\n    rom->data     = g_malloc0(rom->datasize);\n    memcpy(rom->data, blob, len);\n    rom_insert(rom);\n    if (fw_file_name && fw_cfg) {\n        char devpath[100];\n        void *data;\n\n        if (read_only) {\n            snprintf(devpath, sizeof(devpath), \"/rom@%s\", fw_file_name);\n        } else {\n            snprintf(devpath, sizeof(devpath), \"/ram@%s\", fw_file_name);\n        }\n\n        if (mc->rom_file_has_mr) {\n            data = rom_set_mr(rom, OBJECT(fw_cfg), devpath, read_only);\n            mr = rom->mr;\n        } else {\n            data = rom->data;\n        }\n\n        fw_cfg_add_file_callback(fw_cfg, fw_file_name,\n                                 fw_callback, NULL, callback_opaque,\n                                 data, rom->datasize, read_only);\n    }\n    return mr;\n}\n\n/* This function is specific for elf program because we don't need to allocate\n * all the rom. We just allocate the first part and the rest is just zeros. This\n * is why romsize and datasize are different. Also, this function seize the\n * memory ownership of \"data\", so we don't have to allocate and copy the buffer.\n */\nint rom_add_elf_program(const char *name, void *data, size_t datasize,\n                        size_t romsize, hwaddr addr, AddressSpace *as)\n{\n    Rom *rom;\n\n    rom           = g_malloc0(sizeof(*rom));\n    rom->name     = g_strdup(name);\n    rom->addr     = addr;\n    rom->datasize = datasize;\n    rom->romsize  = romsize;\n    rom->data     = data;\n    rom->as       = as;\n    rom_insert(rom);\n    return 0;\n}\n\nint rom_add_vga(const char *file)\n{\n    return rom_add_file(file, \"vgaroms\", 0, -1, true, NULL, NULL);\n}\n\nint rom_add_option(const char *file, int32_t bootindex)\n{\n    return rom_add_file(file, \"genroms\", 0, bootindex, true, NULL, NULL);\n}\n\nstatic void rom_reset(void *unused)\n{\n    Rom *rom;\n\n    QTAILQ_FOREACH(rom, &roms, next) {\n        if (rom->fw_file) {\n            continue;\n        }\n        if (rom->data == NULL) {\n            continue;\n        }\n        if (rom->mr) {\n            void *host = memory_region_get_ram_ptr(rom->mr);\n            memcpy(host, rom->data, rom->datasize);\n        } else {\n            address_space_write_rom(rom->as, rom->addr, MEMTXATTRS_UNSPECIFIED,\n                                    rom->data, rom->datasize);\n        }\n        if (rom->isrom) {\n            /* rom needs to be written only once */\n            g_free(rom->data);\n            rom->data = NULL;\n        }\n        /*\n         * The rom loader is really on the same level as firmware in the guest\n         * shadowing a ROM into RAM. Such a shadowing mechanism needs to ensure\n         * that the instruction cache for that new region is clear, so that the\n         * CPU definitely fetches its instructions from the just written data.\n         */\n        cpu_flush_icache_range(rom->addr, rom->datasize);\n    }\n}\n\nint rom_check_and_register_reset(void)\n{\n    hwaddr addr = 0;\n    MemoryRegionSection section;\n    Rom *rom;\n    AddressSpace *as = NULL;\n\n    QTAILQ_FOREACH(rom, &roms, next) {\n        if (rom->fw_file) {\n            continue;\n        }\n        if (!rom->mr) {\n            if ((addr > rom->addr) && (as == rom->as)) {\n                fprintf(stderr, \"rom: requested regions overlap \"\n                        \"(rom %s. free=0x\" TARGET_FMT_plx\n                        \", addr=0x\" TARGET_FMT_plx \")\\n\",\n                        rom->name, addr, rom->addr);\n                return -1;\n            }\n            addr  = rom->addr;\n            addr += rom->romsize;\n            as = rom->as;\n        }\n        section = memory_region_find(rom->mr ? rom->mr : get_system_memory(),\n                                     rom->addr, 1);\n        rom->isrom = int128_nz(section.size) && memory_region_is_rom(section.mr);\n        memory_region_unref(section.mr);\n    }\n    qemu_register_reset(rom_reset, NULL);\n    roms_loaded = 1;\n    return 0;\n}\n\nvoid rom_set_fw(FWCfgState *f)\n{\n    fw_cfg = f;\n}\n\nvoid rom_set_order_override(int order)\n{\n    if (!fw_cfg)\n        return;\n    fw_cfg_set_order_override(fw_cfg, order);\n}\n\nvoid rom_reset_order_override(void)\n{\n    if (!fw_cfg)\n        return;\n    fw_cfg_reset_order_override(fw_cfg);\n}\n\nvoid rom_transaction_begin(void)\n{\n    Rom *rom;\n\n    /* Ignore ROMs added without the transaction API */\n    QTAILQ_FOREACH(rom, &roms, next) {\n        rom->committed = true;\n    }\n}\n\nvoid rom_transaction_end(bool commit)\n{\n    Rom *rom;\n    Rom *tmp;\n\n    QTAILQ_FOREACH_SAFE(rom, &roms, next, tmp) {\n        if (rom->committed) {\n            continue;\n        }\n        if (commit) {\n            rom->committed = true;\n        } else {\n            QTAILQ_REMOVE(&roms, rom, next);\n            rom_free(rom);\n        }\n    }\n}\n\nstatic Rom *find_rom(hwaddr addr, size_t size)\n{\n    Rom *rom;\n\n    QTAILQ_FOREACH(rom, &roms, next) {\n        if (rom->fw_file) {\n            continue;\n        }\n        if (rom->mr) {\n            continue;\n        }\n        if (rom->addr > addr) {\n            continue;\n        }\n        if (rom->addr + rom->romsize < addr + size) {\n            continue;\n        }\n        return rom;\n    }\n    return NULL;\n}\n\n/*\n * Copies memory from registered ROMs to dest. Any memory that is contained in\n * a ROM between addr and addr + size is copied. Note that this can involve\n * multiple ROMs, which need not start at addr and need not end at addr + size.\n */\nint rom_copy(uint8_t *dest, hwaddr addr, size_t size)\n{\n    hwaddr end = addr + size;\n    uint8_t *s, *d = dest;\n    size_t l = 0;\n    Rom *rom;\n\n    QTAILQ_FOREACH(rom, &roms, next) {\n        if (rom->fw_file) {\n            continue;\n        }\n        if (rom->mr) {\n            continue;\n        }\n        if (rom->addr + rom->romsize < addr) {\n            continue;\n        }\n        if (rom->addr > end || rom->addr < addr) {\n            break;\n        }\n\n        d = dest + (rom->addr - addr);\n        s = rom->data;\n        l = rom->datasize;\n\n        if ((d + l) > (dest + size)) {\n            l = dest - d;\n        }\n\n        if (l > 0) {\n            memcpy(d, s, l);\n        }\n\n        if (rom->romsize > rom->datasize) {\n            /* If datasize is less than romsize, it means that we didn't\n             * allocate all the ROM because the trailing data are only zeros.\n             */\n\n            d += l;\n            l = rom->romsize - rom->datasize;\n\n            if ((d + l) > (dest + size)) {\n                /* Rom size doesn't fit in the destination area. Adjust to avoid\n                 * overflow.\n                 */\n                l = dest - d;\n            }\n\n            if (l > 0) {\n                memset(d, 0x0, l);\n            }\n        }\n    }\n\n    return (d + l) - dest;\n}\n\nvoid *rom_ptr(hwaddr addr, size_t size)\n{\n    Rom *rom;\n\n    rom = find_rom(addr, size);\n    if (!rom || !rom->data)\n        return NULL;\n    return rom->data + (addr - rom->addr);\n}\n\nvoid hmp_info_roms(Monitor *mon, const QDict *qdict)\n{\n    Rom *rom;\n\n    QTAILQ_FOREACH(rom, &roms, next) {\n        if (rom->mr) {\n            monitor_printf(mon, \"%s\"\n                           \" size=0x%06zx name=\\\"%s\\\"\\n\",\n                           memory_region_name(rom->mr),\n                           rom->romsize,\n                           rom->name);\n        } else if (!rom->fw_file) {\n            monitor_printf(mon, \"addr=\" TARGET_FMT_plx\n                           \" size=0x%06zx mem=%s name=\\\"%s\\\"\\n\",\n                           rom->addr, rom->romsize,\n                           rom->isrom ? \"rom\" : \"ram\",\n                           rom->name);\n        } else {\n            monitor_printf(mon, \"fw=%s/%s\"\n                           \" size=0x%06zx name=\\\"%s\\\"\\n\",\n                           rom->fw_dir,\n                           rom->fw_file,\n                           rom->romsize,\n                           rom->name);\n        }\n    }\n}\n\ntypedef enum HexRecord HexRecord;\nenum HexRecord {\n    DATA_RECORD = 0,\n    EOF_RECORD,\n    EXT_SEG_ADDR_RECORD,\n    START_SEG_ADDR_RECORD,\n    EXT_LINEAR_ADDR_RECORD,\n    START_LINEAR_ADDR_RECORD,\n};\n\n/* Each record contains a 16-bit address which is combined with the upper 16\n * bits of the implicit \"next address\" to form a 32-bit address.\n */\n#define NEXT_ADDR_MASK 0xffff0000\n\n#define DATA_FIELD_MAX_LEN 0xff\n#define LEN_EXCEPT_DATA 0x5\n/* 0x5 = sizeof(byte_count) + sizeof(address) + sizeof(record_type) +\n *       sizeof(checksum) */\ntypedef struct {\n    uint8_t byte_count;\n    uint16_t address;\n    uint8_t record_type;\n    uint8_t data[DATA_FIELD_MAX_LEN];\n    uint8_t checksum;\n} HexLine;\n\n/* return 0 or -1 if error */\nstatic bool parse_record(HexLine *line, uint8_t *our_checksum, const uint8_t c,\n                         uint32_t *index, const bool in_process)\n{\n    /* +-------+---------------+-------+---------------------+--------+\n     * | byte  |               |record |                     |        |\n     * | count |    address    | type  |        data         |checksum|\n     * +-------+---------------+-------+---------------------+--------+\n     * ^       ^               ^       ^                     ^        ^\n     * |1 byte |    2 bytes    |1 byte |     0-255 bytes     | 1 byte |\n     */\n    uint8_t value = 0;\n    uint32_t idx = *index;\n    /* ignore space */\n    if (g_ascii_isspace(c)) {\n        return true;\n    }\n    if (!g_ascii_isxdigit(c) || !in_process) {\n        return false;\n    }\n    value = g_ascii_xdigit_value(c);\n    value = (idx & 0x1) ? (value & 0xf) : (value << 4);\n    if (idx < 2) {\n        line->byte_count |= value;\n    } else if (2 <= idx && idx < 6) {\n        line->address <<= 4;\n        line->address += g_ascii_xdigit_value(c);\n    } else if (6 <= idx && idx < 8) {\n        line->record_type |= value;\n    } else if (8 <= idx && idx < 8 + 2 * line->byte_count) {\n        line->data[(idx - 8) >> 1] |= value;\n    } else if (8 + 2 * line->byte_count <= idx &&\n               idx < 10 + 2 * line->byte_count) {\n        line->checksum |= value;\n    } else {\n        return false;\n    }\n    *our_checksum += value;\n    ++(*index);\n    return true;\n}\n\ntypedef struct {\n    const char *filename;\n    HexLine line;\n    uint8_t *bin_buf;\n    hwaddr *start_addr;\n    int total_size;\n    uint32_t next_address_to_write;\n    uint32_t current_address;\n    uint32_t current_rom_index;\n    uint32_t rom_start_address;\n    AddressSpace *as;\n} HexParser;\n\n/* return size or -1 if error */\nstatic int handle_record_type(HexParser *parser)\n{\n    HexLine *line = &(parser->line);\n    switch (line->record_type) {\n    case DATA_RECORD:\n        parser->current_address =\n            (parser->next_address_to_write & NEXT_ADDR_MASK) | line->address;\n        /* verify this is a contiguous block of memory */\n        if (parser->current_address != parser->next_address_to_write) {\n            if (parser->current_rom_index != 0) {\n                rom_add_blob_fixed_as(parser->filename, parser->bin_buf,\n                                      parser->current_rom_index,\n                                      parser->rom_start_address, parser->as);\n            }\n            parser->rom_start_address = parser->current_address;\n            parser->current_rom_index = 0;\n        }\n\n        /* copy from line buffer to output bin_buf */\n        memcpy(parser->bin_buf + parser->current_rom_index, line->data,\n               line->byte_count);\n        parser->current_rom_index += line->byte_count;\n        parser->total_size += line->byte_count;\n        /* save next address to write */\n        parser->next_address_to_write =\n            parser->current_address + line->byte_count;\n        break;\n\n    case EOF_RECORD:\n        if (parser->current_rom_index != 0) {\n            rom_add_blob_fixed_as(parser->filename, parser->bin_buf,\n                                  parser->current_rom_index,\n                                  parser->rom_start_address, parser->as);\n        }\n        return parser->total_size;\n    case EXT_SEG_ADDR_RECORD:\n    case EXT_LINEAR_ADDR_RECORD:\n        if (line->byte_count != 2 && line->address != 0) {\n            return -1;\n        }\n\n        if (parser->current_rom_index != 0) {\n            rom_add_blob_fixed_as(parser->filename, parser->bin_buf,\n                                  parser->current_rom_index,\n                                  parser->rom_start_address, parser->as);\n        }\n\n        /* save next address to write,\n         * in case of non-contiguous block of memory */\n        parser->next_address_to_write = (line->data[0] << 12) |\n                                        (line->data[1] << 4);\n        if (line->record_type == EXT_LINEAR_ADDR_RECORD) {\n            parser->next_address_to_write <<= 12;\n        }\n\n        parser->rom_start_address = parser->next_address_to_write;\n        parser->current_rom_index = 0;\n        break;\n\n    case START_SEG_ADDR_RECORD:\n        if (line->byte_count != 4 && line->address != 0) {\n            return -1;\n        }\n\n        /* x86 16-bit CS:IP segmented addressing */\n        *(parser->start_addr) = (((line->data[0] << 8) | line->data[1]) << 4) +\n                                ((line->data[2] << 8) | line->data[3]);\n        break;\n\n    case START_LINEAR_ADDR_RECORD:\n        if (line->byte_count != 4 && line->address != 0) {\n            return -1;\n        }\n\n        *(parser->start_addr) = ldl_be_p(line->data);\n        break;\n\n    default:\n        return -1;\n    }\n\n    return parser->total_size;\n}\n\n/* return size or -1 if error */\nstatic int parse_hex_blob(const char *filename, hwaddr *addr, uint8_t *hex_blob,\n                          size_t hex_blob_size, AddressSpace *as)\n{\n    bool in_process = false; /* avoid re-enter and\n                              * check whether record begin with ':' */\n    uint8_t *end = hex_blob + hex_blob_size;\n    uint8_t our_checksum = 0;\n    uint32_t record_index = 0;\n    HexParser parser = {\n        .filename = filename,\n        .bin_buf = g_malloc(hex_blob_size),\n        .start_addr = addr,\n        .as = as,\n    };\n\n    rom_transaction_begin();\n\n    for (; hex_blob < end; ++hex_blob) {\n        switch (*hex_blob) {\n        case '\\r':\n        case '\\n':\n            if (!in_process) {\n                break;\n            }\n\n            in_process = false;\n            if ((LEN_EXCEPT_DATA + parser.line.byte_count) * 2 !=\n                    record_index ||\n                our_checksum != 0) {\n                parser.total_size = -1;\n                goto out;\n            }\n\n            if (handle_record_type(&parser) == -1) {\n                parser.total_size = -1;\n                goto out;\n            }\n            break;\n\n        /* start of a new record. */\n        case ':':\n            memset(&parser.line, 0, sizeof(HexLine));\n            in_process = true;\n            record_index = 0;\n            break;\n\n        /* decoding lines */\n        default:\n            if (!parse_record(&parser.line, &our_checksum, *hex_blob,\n                              &record_index, in_process)) {\n                parser.total_size = -1;\n                goto out;\n            }\n            break;\n        }\n    }\n\nout:\n    g_free(parser.bin_buf);\n    rom_transaction_end(parser.total_size != -1);\n    return parser.total_size;\n}\n\n/* return size or -1 if error */\nint load_targphys_hex_as(const char *filename, hwaddr *entry, AddressSpace *as)\n{\n    gsize hex_blob_size;\n    gchar *hex_blob;\n    int total_size = 0;\n\n    if (!g_file_get_contents(filename, &hex_blob, &hex_blob_size, NULL)) {\n        return -1;\n    }\n\n    total_size = parse_hex_blob(filename, entry, (uint8_t *)hex_blob,\n                                hex_blob_size, as);\n\n    g_free(hex_blob);\n    return total_size;\n}\n"], "filenames": ["hw/core/loader.c"], "buggy_code_start_loc": [1243], "buggy_code_end_loc": [1244], "fixing_code_start_loc": [1243], "fixing_code_end_loc": [1244], "type": "CWE-787", "message": "rom_copy() in hw/core/loader.c in QEMU 4.0 and 4.1.0 does not validate the relationship between two addresses, which allows attackers to trigger an invalid memory copy operation.", "other": {"cve": {"id": "CVE-2020-13765", "sourceIdentifier": "cve@mitre.org", "published": "2020-06-04T16:15:12.733", "lastModified": "2022-10-07T01:28:01.017", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "rom_copy() in hw/core/loader.c in QEMU 4.0 and 4.1.0 does not validate the relationship between two addresses, which allows attackers to trigger an invalid memory copy operation."}, {"lang": "es", "value": "La funci\u00f3n rom_copy() en el archivo hw/core/loader.c en QEMU versi\u00f3n 4.0 y versi\u00f3n 4.1.0, no comprueba la relaci\u00f3n entre dos direcciones, lo que permite a atacantes activar una operaci\u00f3n de copia de memoria no v\u00e1lida"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:qemu:qemu:4.0.0:*:*:*:*:*:*:*", "matchCriteriaId": "22ACD7F6-8BB8-4B86-94D0-1C584AB87EEF"}, {"vulnerable": true, "criteria": "cpe:2.3:a:qemu:qemu:4.1.0:*:*:*:*:*:*:*", "matchCriteriaId": "14EA5400-9958-43EF-91CA-FEB3231B9C97"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:16.04:*:*:*:esm:*:*:*", "matchCriteriaId": "7A5301BF-1402-4BE0-A0F8-69FBE79BC6D6"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:18.04:*:*:*:lts:*:*:*", "matchCriteriaId": "23A7C53F-B80F-4E6A-AFA9-58EEA84BE11D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:canonical:ubuntu_linux:20.04:*:*:*:lts:*:*:*", "matchCriteriaId": "902B8056-9E37-443B-8905-8AA93E2447FB"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "https://git.qemu.org/?p=qemu.git;a=commit;h=e423455c4f23a1a828901c78fe6d03b7dde79319", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/qemu/qemu/commit/4f1c6cb2f9afafda05eab150fd2bd284edce6676", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/06/msg00032.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/07/msg00020.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20200619-0006/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://usn.ubuntu.com/4467-1/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2020/06/03/6", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/qemu/qemu/commit/4f1c6cb2f9afafda05eab150fd2bd284edce6676"}}