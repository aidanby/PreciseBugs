{"buggy_code": ["#!/bin/bash\n\n#\n# This script contains common configuration settings and functions.\n#\n\n\n# export all variables to subshells\nset -a\n\n#######################################\n# configuration (can be modified)\n\n# the github project name\nclassname=\"ucr-cs100\"\n\n# tmp folder for all student repos\ntmpdir=\"$HOME/.gitlearn/$classname\"\n\n# branch of student git repository that stores the grades\ngradesbranch=\"grades\"\n\n# folder containing instructor pgp keys\ninstructorinfo=\"people/instructors\"\n\n# folder containing student information\nstudentinfo=\"people/students\"\n\n#######################################\n# initialization (do not modify!)\n\n# if gitlearn isn't installed as an env var, then run locally\nif [ -z \"$GITLEARN_CLASSDIR\" ]; then\n    echo \"running local gitlearn at location [$(pwd)]\" >&2\n\n    # verify that we are currently in a local gitlearn directory\n    # FIXME: make this a separate function and more robust\n    if [ ! -d \"assignments\" ] || [ ! -d \"people\" ]; then\n        echo \"error: this does not appear to be a valid gitlearn directory\" >&2\n    fi\n\n# otherwise, run in installed folder\nelse\n    echo \"running installed gitlearn: $GITLEARN_CLASSDIR\" >&2\n    # FIXME: validate the installed directory\n    cd $GITLEARN_CLASSDIR\nfi\n\n# let us quit the shell even if we're in a subshell\ntrap \"exit 1\" TERM\nexport TOP_PID=$$\n\nfunction failScript {\n    kill -s TERM $TOP_PID\n}\n\n#######################################\n# misc display functions\n\n# pad the input $1 with extra spaces so that is has exactly length $2\nfunction pad {\n    ret=\"${1:0:$2}                                                  \"\n    ret=\"${ret:0:$2}\"\n    echo \"$ret\"\n}\n\n# add the padding to the left\nfunction padPercent {\n    if [ ${#1} = 5 ]; then\n        printf \" \"\n    elif [ ${#1} = 4 ]; then\n        printf \"  \"\n    elif [ \"$1\" = 0 ]; then\n        printf \"  0.0\"\n    fi\n    printf \"$1\"\n}\n\n##########################################\n#colors\nred=\"\\x1b[31m\"\ngreen=\"\\x1b[32m\"\nyellow=\"\\x1b[33m\"\nblue=\"\\x1b[34m\"\nmag=\"\\x1b[35m\"\ncyn=\"\\x1b[36m\"\nendcolor=\"\\x1b[0m\"\n\n#colors for website\nwebred=\"<FONT COLOR=\\\"C20000\\\">\"\nwebgreen=\"<FONT COLOR=\\\"006400\\\">\"\nwebyellow=\"<FONT COLOR=\\\"BB8900\\\">\"\nwebblue=\"<FONT COLOR=\\\"0000FF\\\">\"\nwebmag=\"<FONT COLOR=\\\"FF00FF\\\">\"\nwebcyn=\"<FONT COLOR=\\\"0081A1\\\">\"\nwebendcolor=\"</FONT>\"\n\nfunction error {\n    echo -e \"$red ERROR: $@$endcolor\" >&2\n    failScript\n}\nfunction warning\n{\n    echo -e \"$yellow WARN: $@$endcolor\" >&2\n}\n\n#######################################\n# get student info\n\n# prints the names of the csaccount of each student on a separate line\nfunction getStudentList {\n    for file in $studentinfo/*; do\n        basename \"$file\"\n    done\n}\n\n# $1 = the student's csaccount (which is the name of file containing their info)\n# $2 = the attribute you want about the student\n# $3 = optional parameter to specify you want output for website version\nfunction getStudentInfo {\n    csaccount=\"$1\"\n    if [ -z \"$2\" ]; then\n        error \"attribute not given\"\n    fi\n\n    # FIXME: this matches any attribute that contains $2 rather than equals $2\n    ret=$(awk -F \"=\" \"/^$2/ {print \\$2}\" \"$studentinfo/$csaccount\" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')\n    if [ -z \"$ret\" ]; then\n        # if no third parameter, output message for terminal version\n        if [ -z \"$3\" ]; then\n            error \"student $csaccount does not have attribute $2 in their studentinfo file\"\n        # otherwise, output message for website version\n        else\n            echo \"student $csaccount does not have attribute $2 in their studentinfo file\" >&2\n        fi\n    fi\n    echo \"$ret\"\n}\n\n# $1 = the student's csaccount (which is the name of file containing their info)\n#      OR a string of the form \"github=XXX\" where XXX is the student's github account\n# output is the student's csaccount\nfunction simplifycsaccount {\n    local csaccount=\"$1\"\n    if [ $(echo \"$1\" | cut -d'=' -f 1) = \"github\" ]; then\n        csaccount=\"$(github2csaccount $(echo \"$1\" | cut -d'=' -f 2))\"\n    fi\n    echo \"$csaccount\"\n}\n\n# $1 = the student's github account\nfunction github2csaccount {\n    local student=$(grep -r \"^[[:space:]]*github[[:space:]]*=[[:space:]]*$1[[:space:]]*\\$\" \"$studentinfo\" | cut -d':' -f 1)\n    if [ ! -z \"$student\" ]; then\n        basename \"$student\"\n    else\n        error \"github account $1 is not registered\"\n    fi\n}\n\n#######################################\n# download/edit grades\n\nfunction downloadAllGrades {\n    downloadAllProjects \"$classname\" \"$gradesbranch\"\n}\n\n# $1 = csaccount of student to download grades for\nfunction downloadGrades {\n    giturl=\"$(getStudentInfo $1 giturl)\"\n    clonedir=\"$tmpdir/$classname-$1\"\n    downloadRepo \"$clonedir\" \"$giturl\" \"$gradesbranch\"\n}\n\n# $1 = the name of the repo on github that has the students' projects\n# $2 = [optional] branch of project to enter\nfunction downloadAllProjects {\n\n    # tells git to keep the username and password in memory for the next 15 minutes\n    git config credential.helper cache\n\n    echo \"downloading repos...\"\n    accountlist=$(getStudentList)\n\n    # we can only massively parallelize downloads if we've already cloned the repos previously\n    numReposAlreadyDownloaded=$(ls \"$tmpdir\" | grep \"$1\" | wc -l)\n    numStudents=$(ls \"$studentinfo\" | wc -l)\n    if [ \"$numReposAlreadyDownloaded\" -ge \"$numStudents\" ]; then\n        maxparallel=100\n    else\n        maxparallel=4\n    fi\n    maxparallel=1\n\n    # this weird xargs command runs all of the downloadProject functions in parallel\n    if ! (echo \"$accountlist\" | xargs -n 1 -P \"$maxparallel\" bash -c \"downloadProject $1 \\$1 $2\" -- ); then\n        echo \"ERROR: some repos failed to download;\"\n        echo \"sometimes we exceed github's connection limits due to parallel downloading;\"\n        echo \"trying again might work?\"\n        echo\n        exit 1\n    fi\n    echo \"done\"\n}\n\n# $1 = project name\n# $2 = csaccount of user\n# $3 = [optional] branch of project to enter\nfunction downloadProject {\n    github=$(getStudentInfo $2 github)\n    downloadRepo \"$tmpdir/$1-$2\" \"https://github.com/$github/$1.git\" \"$3\"\n}\n\n# $1 = the directory to place the repo\n# $2 = the repo's url (not necessarily on github)\n# $3 = [optional] branch to enter in the repo\nfunction downloadRepo {\n    local clonedir=\"$1\"\n    local giturl=\"$2\"\n    local branch=\"$3\"\n    local olddir=$(pwd)\n\n    # download repo\n    if [ ! -d \"$clonedir\" ]; then\n        echo \"  running git clone on [$giturl]\" >&2\n\t    git clone --quiet \"$giturl\" \"$clonedir\"\n\t    cd \"$clonedir\"\n\n        # checkout the branch if it's not the default branch\n        # (in that case, it would already be checked out)\n\t    local defaultbranch=`git branch -r | grep origin/HEAD | grep -o \"[a-zA-Z0-9_-]*$\"`\n        if [ ! -z \"$branch\" ] && [ \"$branch\" != \"$defaultbranch\" ]; then\n\n            # if the branch doesn't exist, create it\n            if [ -z \"$(git branch --list $branch)\" ]; then\n                echo \"  $branch doesn't exist in $clonedir... creating branch\" >&2\n                git checkout -b \"$branch\" --quiet\n\n            # the branch exists, so just check it out\n            else\n                echo \"  checked out branch $branch in $clonedir\" >&2\n                git checkout \"$branch\" --quiet\n                git pull origin \"$branch\" --quiet > /dev/null 2> /dev/null\n            fi\n        fi\n    else\n        echo \"  running git pull in [$clonedir]\" >&2\n        cd \"$clonedir\"\n        git fetch --all --quiet > /dev/null 2> /dev/null\n\n        if [ -z \"$branch\" ]; then\n            git checkout --quiet\n            git pull origin master\n        else\n            git checkout \"$branch\" --quiet\n            git pull origin \"$branch\" --quiet > /dev/null\n        fi\n\n        ## If branch is empty, assign to it the default branch.\n        ## This assignment cannot occur above as the folder might not even exist then.\n        #if [ -z \"$branch\" ]; then\n            #branch=`git branch -r | grep origin/HEAD | grep -o \"[a-zA-Z0-9_-]*$\"`\n        #fi\n        #git checkout \"$branch\" # --quiet\n        #git pull origin \"$branch\" # --quiet > /dev/null 2> /dev/null\n    fi\n\n    cd \"$olddir\"\n}\n\nfunction uploadAllGrades {\n    # tells git to keep the username and password in memory for the next 15 minutes\n    git config credential.helper cache\n\n    echo \"uploading repos...\"\n    accountlist=$(getStudentList)\n\n    # this weird xargs command runs all of the uploadGrades functions in parallel\n    maxparallel=1\n    if ! (echo \"$accountlist\" | xargs -n 1 -P \"$maxparallel\" bash -c \"uploadGrades \\$1\" -- ); then\n        error \"ERROR: some repos failed to upload; sometimes we exceed github's connection limits due to parallel uploading; trying again might work?\"\n    fi\n    echo \"done\"\n}\n\n# $1 = the cs account of the student to upload grades\nfunction uploadGrades {\n    clonedir=\"$tmpdir/$classname-$1\"\n    cd \"$clonedir\"\n    for file in `find . -name grade`; do\n        git add $file\n    done\n\n    git commit -S -m \"graded assignment for $1 using automatic scripts\"\n\n    echo \"changes committed... uploading to github\"\n    git push origin \"$gradesbranch\"\n    # FIXME: we should be reporting an error if git fails... but how?\n    #if [ $? ]; then\n        #echo \"upload successful :)\"\n    #else\n        #echo \"upload failed :( error code: $?\"\n    #fi\n    cd ../..\n}\n\n# $1 = the csaccount of the student\n# $2 = the assignment to grade\nfunction gradeAssignment {\n    local csaccount=\"$1\"\n    local assn=\"$2\"\n    local name=$(getStudentInfo \"$csaccount\" name)\n    local githubaccount=$(getStudentInfo \"$csaccount\" \"github\")\n\n    local file=\"$tmpdir/$classname-$csaccount/$assn/grade\"\n\n    mkdir -p `dirname $1`\n\n    # let the grader know who they're grading\n    echo \"#####################################\" >> \"$file\"\n    echo \"#\" >> \"$file\"\n    echo \"# $file\" >> \"$file\"\n    echo \"#\" >> \"$file\"\n    echo \"# name      = $name\" >> \"$file\"\n    echo \"# csaccount = $csaccount\" >> \"$file\"\n    echo \"# github    = $githubaccount\" >> \"$file\"\n    echo \"#\" >> \"$file\"\n    echo \"# any line that begins with a # is a comment and won't be written to the file\" >> \"$file\"\n    echo \"#\" >> \"$file\"\n    echo \"#####################################\" >> \"$file\"\n\n    vim \"$file\"\n\n    # delete all the comments from the file\n    sed -i \"/^\\#/d\" \"$file\"\n}\n\n#######################################\n# parsing grades\n\n# $1 = the grade file\nfunction isGraded {\n    # is the first word in the file $1 is \"/\", then it is not graded\n    return `! grep '^[[:blank:]]*/' -q \"$1\"`\n}\n\n# $1 = the grade file\nfunction getGrade {\n    head -n 1 \"$1\" | cut -d'/' -f1 | sed 's/ *//g'\n    #head -n 1 \"$1\" | sed 's/\\// /' | awk '{print $1;}'\n}\n\n# $1 = the grade file\nfunction getOutOf {\n    if isGraded $1; then\n        head -n 1 \"$1\" | sed 's/\\// /' | awk '{print $2;}'\n    else\n        head -n 1 \"$1\" | sed 's/\\// /' | awk '{print $1;}'\n    fi\n}\n\n# calculates the total points for user $1 in directory $2\nfunction totalGrade {\n    local totalgrade=0\n    local assn=\"$2\"\n    if [ -z \"$assn\" ]; then\n        assn=\".\"\n    fi\n    for f in `find \"$tmpdir/$classname-$1/$assn\" -name grade`; do\n        if isGraded \"$f\"; then\n            local grade=$(getGrade \"$f\")\n            totalgrade=$(bc <<< \"$totalgrade + $grade\")\n            #totalgrade=$[$totalgrade+$grade]\n        fi\n    done\n    echo $totalgrade\n}\n\n# calculates the total possible points for user $1 in directory $2 on submitted assignments only\nfunction runningTotalOutOf {\n    totaloutof=0\n    local assn=\"$2\"\n    if [ -z \"$assn\" ]; then\n        assn=\".\"\n    fi\n    for f in `find \"$tmpdir/$classname-$1/$assn\" -name grade`; do\n        if isGraded \"$f\"; then\n            local outof=$(getOutOf \"$f\")\n            totaloutof=$(bc <<< \"$totaloutof + $outof\")\n            #totaloutof=$[$totaloutof+$outof]\n        fi\n    done\n    echo \"$totaloutof\"\n}\n\n# calculates the total possible points for user $1 in directory $2 on all assignments\n# this function is used for calculating the final grade\nfunction totalOutOf {\n    totaloutof=0\n    if [ -z \"$assn\" ]; then\n        assn=\".\"\n    fi\n    for f in `find \"$tmpdir/$classname-$1/$assn\" -name grade`; do\n        local outof=$(getOutOf \"$f\")\n        totaloutof=$(bc <<< \"$totaloutof + $outof\")\n        #totaloutof=$[$totaloutof+$outof]\n    done\n    echo \"$totaloutof\"\n}\n\n# calculates the current percentage for user $1 in directory $2\nfunction runningTotalGradePercent {\n    mkPercent $(totalGrade $1 $2) $(runningTotalOutOf $1 $2)\n}\n\n# calculates the final percentage for user $1 in directory $2\nfunction totalGradePercent {\n    mkPercent $(totalGrade $1 $2) $(totalOutOf $1 $2)\n}\n\n#######################################\n# displaying grades\n\n# $1 = numerator\n# $2 = denominator\nfunction mkPercent {\n    if [ \"$2\" = \"0\" ]; then\n        #echo \"NaN\"\n        if [ \"$1\" = \"0\" ]; then\n            echo \"0.00\"\n        else\n            echo \"100.00\"\n        fi\n    else\n        bc <<< \"scale=2; 100 * $1/$2\"\n    fi\n}\n\n# $1 = percent\nfunction colorPercent {\n    local per=\"$1\"\n    if [[ -z $1 ]]; then\n        resetColor\n    elif ((`bc <<< \"$per>=90\"`)); then\n        printf \"$green\"\n    elif ((`bc <<< \"$per>=80\"`)); then\n        printf \"$cyn\"\n    elif ((`bc <<< \"$per>=70\"`)); then\n        printf \"$yellow\"\n    else\n        printf \"$red\"\n    fi\n}\n\n# $1 = percent\nfunction colorPercentLink {\n    local per=\"$1\"\n    if [[ -z $1 ]]; then\n        printf \"blacklink\"\n    elif ((`bc <<< \"$per>=90\"`)); then\n        printf \"greenlink\"\n    elif ((`bc <<< \"$per>=80\"`)); then\n        printf \"cynlink\"\n    elif ((`bc <<< \"$per>=70\"`)); then\n        printf \"yellowlink\"\n    else\n        printf \"redlink\"\n    fi\n}\n\n# $1 = percent\nfunction colorPercentWeb {\n    local per=\"$1\"\n    if [[ -z $1 ]]; then\n        printf \"$webendcolor\"\n    elif ((`bc <<< \"$per>=90\"`)); then\n        printf \"$webgreen\"\n    elif ((`bc <<< \"$per>=80\"`)); then\n        printf \"$webcyn\"\n    elif ((`bc <<< \"$per>=70\"`)); then\n        printf \"$webyellow\"\n    else\n        printf \"$webred\"\n    fi\n}\n\nfunction resetColor {\n    printf \"$endcolor\"\n}\n\nfunction resetColorWeb {\n    printf \"$webendcolor\"\n}\n\n# $1 = percent\nfunction dispPercent {\n    local per=\"$1\"\n    colorPercent \"$per\"\n    printf \"$(padPercent $per)\"\n    resetColor\n}\n\n# $1 = percent\nfunction dispPercentWeb {\n    local per=\"$1\"\n    colorPercentWeb \"$per\"\n    printf \"$(padPercent $per)\"\n    resetColorWeb\n}\n\n# $1 = percent\n# $2 = optional argument to make it format for website\nfunction percentToLetter {\n    per=\"$1\"\n\n    # if second arg is empty, color for terminal version\n    if [ -z \"$2\" ]; then\n        colorPercent \"$1\"\n\n    # otherwise, color for web version\n    else\n        colorPercentWeb \"$1\"\n    fi\n\n    if ((`bc <<< \"$per>=97\"`)); then\n        printf \"A+\"\n    elif ((`bc <<< \"$per>=93\"`)); then\n        printf \"A \"\n    elif ((`bc <<< \"$per>=90\"`)); then\n        printf \"A-\"\n    elif ((`bc <<< \"$per>=87\"`)); then\n        printf \"B+\"\n    elif ((`bc <<< \"$per>=83\"`)); then\n        printf \"B \"\n    elif ((`bc <<< \"$per>=80\"`)); then\n        printf \"B-\"\n    elif ((`bc <<< \"$per>=77\"`)); then\n        printf \"C+\"\n    elif ((`bc <<< \"$per>=73\"`)); then\n        printf \"C \"\n    elif ((`bc <<< \"$per>=70\"`)); then\n        printf \"C-\"\n    elif ((`bc <<< \"$per>=67\"`)); then\n        printf \"D+\"\n    elif ((`bc <<< \"$per>=63\"`)); then\n        printf \"D \"\n    elif ((`bc <<< \"$per>=60\"`)); then\n        printf \"D-\"\n    else\n        printf \"F \"\n    fi\n\n    # reset color depending on if it is terminal version or web version\n    if [ -z \"$2\" ]; then\n        resetColor\n    else\n        resetColorWeb\n    fi\n}\n\n##################################\n#checks if a public key is in the instructor files\n# $1 = file to check\n# $2 = key to compare\nfunction includesKey\n{\n    local instructor=$1\n    local key=$2\n\n    if [ ! -f $instructor ]; then\n        return 1\n    fi\n\n    local instructorKeys=$( gpg --with-fingerprint $instructor | sed -n '/pub/p' | cut -c 12,13,14,15,16,17,18,19 )\n\n    if [[ $instructorKeys == *$key* ]]; then\n        return 0\n    else\n        return 1\n    fi\n}\n\ninstallInstructorKeys()\n{\n    for file in \"$instructorinfo/*\"; do\n        gpg --import $file > /dev/null 2> /dev/null\n    done\n}\n\n"], "fixing_code": ["#!/bin/bash\n\n#\n# This script contains common configuration settings and functions.\n#\n\n\n# export all variables to subshells\nset -a\n\n#######################################\n# configuration (can be modified)\n\n# the github project name\nclassname=\"ucr-cs100\"\n\n# tmp folder for all student repos\ntmpdir=\"$HOME/.gitlearn/$classname\"\n\n# branch of student git repository that stores the grades\ngradesbranch=\"grades\"\n\n# folder containing instructor pgp keys\ninstructorinfo=\"people/instructors\"\n\n# folder containing student information\nstudentinfo=\"people/students\"\n\n#######################################\n# initialization (do not modify!)\n\n# if gitlearn isn't installed as an env var, then run locally\nif [ -z \"$GITLEARN_CLASSDIR\" ]; then\n    echo \"running local gitlearn at location [$(pwd)]\" >&2\n\n    # verify that we are currently in a local gitlearn directory\n    # FIXME: make this a separate function and more robust\n    if [ ! -d \"assignments\" ] || [ ! -d \"people\" ]; then\n        echo \"error: this does not appear to be a valid gitlearn directory\" >&2\n    fi\n\n# otherwise, run in installed folder\nelse\n    echo \"running installed gitlearn: $GITLEARN_CLASSDIR\" >&2\n    # FIXME: validate the installed directory\n    cd $GITLEARN_CLASSDIR\nfi\n\n# let us quit the shell even if we're in a subshell\ntrap \"exit 1\" TERM\nexport TOP_PID=$$\n\nfunction failScript {\n    kill -s TERM $TOP_PID\n}\n\n#######################################\n# misc display functions\n\n# pad the input $1 with extra spaces so that is has exactly length $2\nfunction pad {\n    ret=\"${1:0:$2}                                                  \"\n    ret=\"${ret:0:$2}\"\n    echo \"$ret\"\n}\n\n# add the padding to the left\nfunction padPercent {\n    if [ ${#1} = 5 ]; then\n        printf \" \"\n    elif [ ${#1} = 4 ]; then\n        printf \"  \"\n    elif [ \"$1\" = 0 ]; then\n        printf \"  0.0\"\n    fi\n    printf \"$1\"\n}\n\n##########################################\n#colors\nred=\"\\x1b[31m\"\ngreen=\"\\x1b[32m\"\nyellow=\"\\x1b[33m\"\nblue=\"\\x1b[34m\"\nmag=\"\\x1b[35m\"\ncyn=\"\\x1b[36m\"\nendcolor=\"\\x1b[0m\"\n\n#colors for website\nwebred=\"<FONT COLOR=\\\"C20000\\\">\"\nwebgreen=\"<FONT COLOR=\\\"006400\\\">\"\nwebyellow=\"<FONT COLOR=\\\"BB8900\\\">\"\nwebblue=\"<FONT COLOR=\\\"0000FF\\\">\"\nwebmag=\"<FONT COLOR=\\\"FF00FF\\\">\"\nwebcyn=\"<FONT COLOR=\\\"0081A1\\\">\"\nwebendcolor=\"</FONT>\"\n\nfunction error {\n    echo -e \"$red ERROR: $@$endcolor\" >&2\n    failScript\n}\nfunction warning\n{\n    echo -e \"$yellow WARN: $@$endcolor\" >&2\n}\n\n#######################################\n# get student info\n\n# prints the names of the csaccount of each student on a separate line\nfunction getStudentList {\n    for file in $studentinfo/*; do\n        basename \"$file\"\n    done\n}\n\n# $1 = the student's csaccount (which is the name of file containing their info)\n# $2 = the attribute you want about the student\n# $3 = optional parameter to specify you want output for website version\nfunction getStudentInfo {\n    csaccount=\"$1\"\n    if [ -z \"$2\" ]; then\n        error \"attribute not given\"\n    fi\n\n    # FIXME: this matches any attribute that contains $2 rather than equals $2\n    ret=$(awk -F \"=\" \"/^$2/ {print \\$2}\" \"$studentinfo/$csaccount\" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')\n    if [ -z \"$ret\" ]; then\n        # if no third parameter, output message for terminal version\n        if [ -z \"$3\" ]; then\n            error \"student $csaccount does not have attribute $2 in their studentinfo file\"\n        # otherwise, output message for website version\n        else\n            echo \"student $csaccount does not have attribute $2 in their studentinfo file\" >&2\n        fi\n    fi\n    echo \"$ret\"\n}\n\n# $1 = the student's csaccount (which is the name of file containing their info)\n#      OR a string of the form \"github=XXX\" where XXX is the student's github account\n# output is the student's csaccount\nfunction simplifycsaccount {\n    local csaccount=\"$1\"\n    if [ $(echo \"$1\" | cut -d'=' -f 1) = \"github\" ]; then\n        csaccount=\"$(github2csaccount $(echo \"$1\" | cut -d'=' -f 2))\"\n    fi\n    echo \"$csaccount\"\n}\n\n# $1 = the student's github account\nfunction github2csaccount {\n    local student=$(grep -r \"^[[:space:]]*github[[:space:]]*=[[:space:]]*$1[[:space:]]*\\$\" \"$studentinfo\" | cut -d':' -f 1)\n    if [ ! -z \"$student\" ]; then\n        basename \"$student\"\n    else\n        error \"github account $1 is not registered\"\n    fi\n}\n\n#######################################\n# download/edit grades\n\nfunction downloadAllGrades {\n    downloadAllProjects \"$classname\" \"$gradesbranch\"\n}\n\n# $1 = csaccount of student to download grades for\nfunction downloadGrades {\n    giturl=\"$(getStudentInfo $1 giturl)\"\n    clonedir=\"$tmpdir/$classname-$1\"\n    downloadRepo \"$clonedir\" \"$giturl\" \"$gradesbranch\"\n}\n\n# $1 = the name of the repo on github that has the students' projects\n# $2 = [optional] branch of project to enter\nfunction downloadAllProjects {\n\n    # tells git to keep the username and password in memory for the next 15 minutes\n    git config credential.helper cache\n\n    echo \"downloading repos...\"\n    accountlist=$(getStudentList)\n\n    # we can only massively parallelize downloads if we've already cloned the repos previously\n    numReposAlreadyDownloaded=$(ls \"$tmpdir\" | grep \"$1\" | wc -l)\n    numStudents=$(ls \"$studentinfo\" | wc -l)\n    if [ \"$numReposAlreadyDownloaded\" -ge \"$numStudents\" ]; then\n        maxparallel=100\n    else\n        maxparallel=4\n    fi\n    maxparallel=1\n\n    # this weird xargs command runs all of the downloadProject functions in parallel\n    if ! (echo \"$accountlist\" | xargs -n 1 -P \"$maxparallel\" bash -c \"downloadProject $1 \\$1 $2\" -- ); then\n        echo \"ERROR: some repos failed to download;\"\n        echo \"sometimes we exceed github's connection limits due to parallel downloading;\"\n        echo \"trying again might work?\"\n        echo\n        exit 1\n    fi\n    echo \"done\"\n}\n\n# $1 = project name\n# $2 = csaccount of user\n# $3 = [optional] branch of project to enter\nfunction downloadProject {\n    github=$(getStudentInfo $2 github)\n    downloadRepo \"$tmpdir/$1-$2\" \"https://github.com/$github/$1.git\" \"$3\"\n}\n\n# $1 = the directory to place the repo\n# $2 = the repo's url (not necessarily on github)\n# $3 = [optional] branch to enter in the repo\nfunction downloadRepo {\n    local clonedir=\"$1\"\n    local giturl=\"$2\"\n    local branch=\"$3\"\n    local olddir=$(pwd)\n\n    # download repo\n    if [ ! -d \"$clonedir\" ]; then\n        echo \"  running git clone on [$giturl]\" >&2\n\t    git clone --quiet \"$giturl\" \"$clonedir\"\n\t    cd \"$clonedir\"\n\n        # checkout the branch if it's not the default branch\n        # (in that case, it would already be checked out)\n\t    local defaultbranch=`git branch -r | grep origin/HEAD | grep -o \"[a-zA-Z0-9_-]*$\"`\n        if [ ! -z \"$branch\" ] && [ \"$branch\" != \"$defaultbranch\" ]; then\n\n            # if the branch doesn't exist, create it\n            if [ -z \"$(git branch --list $branch)\" ]; then\n                echo \"  $branch doesn't exist in $clonedir... creating branch\" >&2\n                git checkout -b \"$branch\" --quiet\n\n            # the branch exists, so just check it out\n            else\n                echo \"  checked out branch $branch in $clonedir\" >&2\n                git checkout \"$branch\" --quiet\n                git pull origin \"$branch\" --quiet > /dev/null 2> /dev/null\n            fi\n        fi\n    else\n        echo \"  running git pull in [$clonedir]\" >&2\n        cd \"$clonedir\"\n        git fetch --all --quiet > /dev/null 2> /dev/null\n\n        if [ -z \"$branch\" ]; then\n            git checkout --quiet\n            git pull origin master\n        else\n            git checkout \"$branch\" --quiet\n            git pull origin \"$branch\" --quiet > /dev/null\n        fi\n\n        ## If branch is empty, assign to it the default branch.\n        ## This assignment cannot occur above as the folder might not even exist then.\n        #if [ -z \"$branch\" ]; then\n            #branch=`git branch -r | grep origin/HEAD | grep -o \"[a-zA-Z0-9_-]*$\"`\n        #fi\n        #git checkout \"$branch\" # --quiet\n        #git pull origin \"$branch\" # --quiet > /dev/null 2> /dev/null\n    fi\n\n    cd \"$olddir\"\n}\n\nfunction uploadAllGrades {\n    # tells git to keep the username and password in memory for the next 15 minutes\n    git config credential.helper cache\n\n    echo \"uploading repos...\"\n    accountlist=$(getStudentList)\n\n    # this weird xargs command runs all of the uploadGrades functions in parallel\n    maxparallel=1\n    if ! (echo \"$accountlist\" | xargs -n 1 -P \"$maxparallel\" bash -c \"uploadGrades \\$1\" -- ); then\n        error \"ERROR: some repos failed to upload; sometimes we exceed github's connection limits due to parallel uploading; trying again might work?\"\n    fi\n    echo \"done\"\n}\n\n# $1 = the cs account of the student to upload grades\nfunction uploadGrades {\n    clonedir=\"$tmpdir/$classname-$1\"\n    cd \"$clonedir\"\n    for file in `find . -name grade`; do\n        git add $file\n    done\n\n    git commit -S -m \"graded assignment for $1 using automatic scripts\"\n\n    echo \"changes committed... uploading to github\"\n    git push origin \"$gradesbranch\"\n    # FIXME: we should be reporting an error if git fails... but how?\n    #if [ $? ]; then\n        #echo \"upload successful :)\"\n    #else\n        #echo \"upload failed :( error code: $?\"\n    #fi\n    cd ../..\n}\n\n# $1 = the csaccount of the student\n# $2 = the assignment to grade\nfunction gradeAssignment {\n    local csaccount=\"$1\"\n    local assn=\"$2\"\n    local name=$(getStudentInfo \"$csaccount\" name)\n    local githubaccount=$(getStudentInfo \"$csaccount\" \"github\")\n\n    local file=\"$tmpdir/$classname-$csaccount/$assn/grade\"\n\n    mkdir -p `dirname $1`\n\n    # let the grader know who they're grading\n    echo \"#####################################\" >> \"$file\"\n    echo \"#\" >> \"$file\"\n    echo \"# $file\" >> \"$file\"\n    echo \"#\" >> \"$file\"\n    echo \"# name      = $name\" >> \"$file\"\n    echo \"# csaccount = $csaccount\" >> \"$file\"\n    echo \"# github    = $githubaccount\" >> \"$file\"\n    echo \"#\" >> \"$file\"\n    echo \"# any line that begins with a # is a comment and won't be written to the file\" >> \"$file\"\n    echo \"#\" >> \"$file\"\n    echo \"#####################################\" >> \"$file\"\n\n    vim \"$file\"\n\n    # delete all the comments from the file\n    sed -i \"/^\\#/d\" \"$file\"\n}\n\n#######################################\n# parsing grades\n\n# $1 = the grade file\nfunction isGraded {\n    # is the first word in the file $1 is \"/\", then it is not graded\n    return `! grep '^[[:blank:]]*/' -q \"$1\"`\n}\n\n# $1 = the grade file\nfunction getGrade {\n    head -n 1 \"$1\" | cut -d'/' -f1 | sed 's/ *//g' | sed 's/[^[:digit:].]//g'\n    #head -n 1 \"$1\" | sed 's/\\// /' | awk '{print $1;}'\n}\n\n# $1 = the grade file\nfunction getOutOf {\n    if isGraded $1; then\n        head -n 1 \"$1\" | sed 's/\\// /' | awk '{print $2;}' | sed 's/[^[:digit:].]//g'\n    else\n        head -n 1 \"$1\" | sed 's/\\// /' | awk '{print $1;}' | sed 's/[^[:digit:].]//g'\n    fi\n}\n\n# calculates the total points for user $1 in directory $2\nfunction totalGrade {\n    local totalgrade=0\n    local assn=\"$2\"\n    if [ -z \"$assn\" ]; then\n        assn=\".\"\n    fi\n    for f in `find \"$tmpdir/$classname-$1/$assn\" -name grade`; do\n        if isGraded \"$f\"; then\n            local grade=$(getGrade \"$f\")\n            totalgrade=$(bc <<< \"$totalgrade + $grade\")\n            #totalgrade=$[$totalgrade+$grade]\n        fi\n    done\n    echo $totalgrade\n}\n\n# calculates the total possible points for user $1 in directory $2 on submitted assignments only\nfunction runningTotalOutOf {\n    totaloutof=0\n    local assn=\"$2\"\n    if [ -z \"$assn\" ]; then\n        assn=\".\"\n    fi\n    for f in `find \"$tmpdir/$classname-$1/$assn\" -name grade`; do\n        if isGraded \"$f\"; then\n            local outof=$(getOutOf \"$f\")\n            totaloutof=$(bc <<< \"$totaloutof + $outof\")\n            #totaloutof=$[$totaloutof+$outof]\n        fi\n    done\n    echo \"$totaloutof\"\n}\n\n# calculates the total possible points for user $1 in directory $2 on all assignments\n# this function is used for calculating the final grade\nfunction totalOutOf {\n    totaloutof=0\n    if [ -z \"$assn\" ]; then\n        assn=\".\"\n    fi\n    for f in `find \"$tmpdir/$classname-$1/$assn\" -name grade`; do\n        local outof=$(getOutOf \"$f\")\n        totaloutof=$(bc <<< \"$totaloutof + $outof\")\n        #totaloutof=$[$totaloutof+$outof]\n    done\n    echo \"$totaloutof\"\n}\n\n# calculates the current percentage for user $1 in directory $2\nfunction runningTotalGradePercent {\n    mkPercent $(totalGrade $1 $2) $(runningTotalOutOf $1 $2)\n}\n\n# calculates the final percentage for user $1 in directory $2\nfunction totalGradePercent {\n    mkPercent $(totalGrade $1 $2) $(totalOutOf $1 $2)\n}\n\n#######################################\n# displaying grades\n\n# $1 = numerator\n# $2 = denominator\nfunction mkPercent {\n    if [ \"$2\" = \"0\" ]; then\n        #echo \"NaN\"\n        if [ \"$1\" = \"0\" ]; then\n            echo \"0.00\"\n        else\n            echo \"100.00\"\n        fi\n    else\n        bc <<< \"scale=2; 100 * $1/$2\"\n    fi\n}\n\n# $1 = percent\nfunction colorPercent {\n    local per=\"$1\"\n    if [[ -z $1 ]]; then\n        resetColor\n    elif ((`bc <<< \"$per>=90\"`)); then\n        printf \"$green\"\n    elif ((`bc <<< \"$per>=80\"`)); then\n        printf \"$cyn\"\n    elif ((`bc <<< \"$per>=70\"`)); then\n        printf \"$yellow\"\n    else\n        printf \"$red\"\n    fi\n}\n\n# $1 = percent\nfunction colorPercentLink {\n    local per=\"$1\"\n    if [[ -z $1 ]]; then\n        printf \"blacklink\"\n    elif ((`bc <<< \"$per>=90\"`)); then\n        printf \"greenlink\"\n    elif ((`bc <<< \"$per>=80\"`)); then\n        printf \"cynlink\"\n    elif ((`bc <<< \"$per>=70\"`)); then\n        printf \"yellowlink\"\n    else\n        printf \"redlink\"\n    fi\n}\n\n# $1 = percent\nfunction colorPercentWeb {\n    local per=\"$1\"\n    if [[ -z $1 ]]; then\n        printf \"$webendcolor\"\n    elif ((`bc <<< \"$per>=90\"`)); then\n        printf \"$webgreen\"\n    elif ((`bc <<< \"$per>=80\"`)); then\n        printf \"$webcyn\"\n    elif ((`bc <<< \"$per>=70\"`)); then\n        printf \"$webyellow\"\n    else\n        printf \"$webred\"\n    fi\n}\n\nfunction resetColor {\n    printf \"$endcolor\"\n}\n\nfunction resetColorWeb {\n    printf \"$webendcolor\"\n}\n\n# $1 = percent\nfunction dispPercent {\n    local per=\"$1\"\n    colorPercent \"$per\"\n    printf \"$(padPercent $per)\"\n    resetColor\n}\n\n# $1 = percent\nfunction dispPercentWeb {\n    local per=\"$1\"\n    colorPercentWeb \"$per\"\n    printf \"$(padPercent $per)\"\n    resetColorWeb\n}\n\n# $1 = percent\n# $2 = optional argument to make it format for website\nfunction percentToLetter {\n    per=\"$1\"\n\n    # if second arg is empty, color for terminal version\n    if [ -z \"$2\" ]; then\n        colorPercent \"$1\"\n\n    # otherwise, color for web version\n    else\n        colorPercentWeb \"$1\"\n    fi\n\n    if ((`bc <<< \"$per>=97\"`)); then\n        printf \"A+\"\n    elif ((`bc <<< \"$per>=93\"`)); then\n        printf \"A \"\n    elif ((`bc <<< \"$per>=90\"`)); then\n        printf \"A-\"\n    elif ((`bc <<< \"$per>=87\"`)); then\n        printf \"B+\"\n    elif ((`bc <<< \"$per>=83\"`)); then\n        printf \"B \"\n    elif ((`bc <<< \"$per>=80\"`)); then\n        printf \"B-\"\n    elif ((`bc <<< \"$per>=77\"`)); then\n        printf \"C+\"\n    elif ((`bc <<< \"$per>=73\"`)); then\n        printf \"C \"\n    elif ((`bc <<< \"$per>=70\"`)); then\n        printf \"C-\"\n    elif ((`bc <<< \"$per>=67\"`)); then\n        printf \"D+\"\n    elif ((`bc <<< \"$per>=63\"`)); then\n        printf \"D \"\n    elif ((`bc <<< \"$per>=60\"`)); then\n        printf \"D-\"\n    else\n        printf \"F \"\n    fi\n\n    # reset color depending on if it is terminal version or web version\n    if [ -z \"$2\" ]; then\n        resetColor\n    else\n        resetColorWeb\n    fi\n}\n\n##################################\n#checks if a public key is in the instructor files\n# $1 = file to check\n# $2 = key to compare\nfunction includesKey\n{\n    local instructor=$1\n    local key=$2\n\n    if [ ! -f $instructor ]; then\n        return 1\n    fi\n\n    local instructorKeys=$( gpg --with-fingerprint $instructor | sed -n '/pub/p' | cut -c 12,13,14,15,16,17,18,19 )\n\n    if [[ $instructorKeys == *$key* ]]; then\n        return 0\n    else\n        return 1\n    fi\n}\n\ninstallInstructorKeys()\n{\n    for file in \"$instructorinfo/*\"; do\n        gpg --import $file > /dev/null 2> /dev/null\n    done\n}\n\n"], "filenames": ["scripts/config.sh"], "buggy_code_start_loc": [349], "buggy_code_end_loc": [359], "fixing_code_start_loc": [349], "fixing_code_end_loc": [359], "type": "CWE-116", "message": "A vulnerability was found in gitlearn. It has been declared as problematic. This vulnerability affects the function getGrade/getOutOf of the file scripts/config.sh of the component Escape Sequence Handler. The manipulation leads to injection. The attack can be initiated remotely. The name of the patch is 3faa5deaa509012069afe75cd03c21bda5050a64. It is recommended to apply a patch to fix this issue. VDB-218302 is the identifier assigned to this vulnerability.", "other": {"cve": {"id": "CVE-2015-10040", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-13T20:15:08.907", "lastModified": "2023-01-23T18:00:15.137", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in gitlearn. It has been declared as problematic. This vulnerability affects the function getGrade/getOutOf of the file scripts/config.sh of the component Escape Sequence Handler. The manipulation leads to injection. The attack can be initiated remotely. The name of the patch is 3faa5deaa509012069afe75cd03c21bda5050a64. It is recommended to apply a patch to fix this issue. VDB-218302 is the identifier assigned to this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 2.5}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:N/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 4.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-116"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-74"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:gitlearn_project:gitlearn:*:*:*:*:*:*:*:*", "versionEndExcluding": "2015-06-09", "matchCriteriaId": "F52899A9-4CB8-4B20-979F-FFD76C9E1CDD"}]}]}], "references": [{"url": "https://github.com/mikeizbicki/gitlearn/commit/3faa5deaa509012069afe75cd03c21bda5050a64", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/mikeizbicki/gitlearn/pull/31", "source": "cna@vuldb.com", "tags": ["Exploit", "Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.218302", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.218302", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/mikeizbicki/gitlearn/commit/3faa5deaa509012069afe75cd03c21bda5050a64"}}