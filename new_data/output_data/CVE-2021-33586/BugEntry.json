{"buggy_code": ["/*\n * InspIRCd -- Internet Relay Chat Daemon\n *\n *   Copyright (C) 2018, 2020 Sadie Powell <sadie@witchery.services>\n *   Copyright (C) 2018 Attila Molnar <attilamolnar@hush.com>\n *\n * This file is part of InspIRCd.  InspIRCd is free software: you can\n * redistribute it and/or modify it under the terms of the GNU General Public\n * License as published by the Free Software Foundation, version 2.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n\n#pragma once\n\nnamespace ClientProtocol\n{\n\tnamespace Messages\n\t{\n\t\tclass Numeric;\n\t\tclass Join;\n\t\tstruct Part;\n\t\tstruct Kick;\n\t\tstruct Quit;\n\t\tstruct Nick;\n\t\tclass Mode;\n\t\tstruct Topic;\n\t\tclass Privmsg;\n\t\tstruct Invite;\n\t\tstruct Ping;\n\t\tstruct Pong;\n\t\tstruct Error;\n\t}\n}\n\n/** Numeric message.\n * Doesn't have a fixed command name, it's always a 3 digit number padded with zeroes if necessary.\n * The first parameter is the target of the numeric which is almost always the nick of the user\n * the numeric will be sent to.\n */\nclass ClientProtocol::Messages::Numeric : public ClientProtocol::Message\n{\n\tchar numericstr[4];\n\n\tvoid InitCommand(unsigned int number)\n\t{\n\t\tsnprintf(numericstr, sizeof(numericstr), \"%03u\", number);\n\t\tSetCommand(numericstr);\n\t}\n\n\tvoid InitFromNumeric(const ::Numeric::Numeric& numeric)\n\t{\n\t\tInitCommand(numeric.GetNumeric());\n\t\tfor (std::vector<std::string>::const_iterator i = numeric.GetParams().begin(); i != numeric.GetParams().end(); ++i)\n\t\t\tPushParamRef(*i);\n\t}\n\n public:\n\t/** Constructor, target is a User.\n\t * @param num Numeric object to send. Must remain valid as long as this object is alive and must not be modified.\n\t * @param user User to send the numeric to. May be unregistered, must remain valid as long as this object is alive.\n\t */\n\tNumeric(const ::Numeric::Numeric& num, User* user)\n\t\t: ClientProtocol::Message(NULL, (num.GetServer() ? num.GetServer() : ServerInstance->FakeClient->server)->GetName())\n\t{\n\t\tif (user->registered & REG_NICK)\n\t\t\tPushParamRef(user->nick);\n\t\telse\n\t\t\tPushParam(\"*\");\n\t\tInitFromNumeric(num);\n\t}\n\n\t/** Constructor, target is a string.\n\t * @param num Numeric object to send. Must remain valid as long as this object is alive and must not be modified.\n\t * @param target Target string, must stay valid as long as this object is alive.\n\t */\n\tNumeric(const ::Numeric::Numeric& num, const std::string& target)\n\t\t: ClientProtocol::Message(NULL, (num.GetServer() ? num.GetServer() : ServerInstance->FakeClient->server)->GetName())\n\t{\n\t\tPushParamRef(target);\n\t\tInitFromNumeric(num);\n\t}\n\n\t/** Constructor. Only the numeric number has to be specified.\n\t * @param num Numeric number.\n\t */\n\tNumeric(unsigned int num)\n\t\t: ClientProtocol::Message(NULL, ServerInstance->Config->GetServerName())\n\t{\n\t\tInitCommand(num);\n\t\tPushParam(\"*\");\n\t}\n};\n\n/** JOIN message.\n * Sent when a user joins a channel.\n */\nclass ClientProtocol::Messages::Join : public ClientProtocol::Message\n{\n\tMembership* memb;\n\n public:\n\t/** Constructor. Does not populate parameters, call SetParams() before sending the message.\n\t */\n\tJoin()\n\t\t: ClientProtocol::Message(\"JOIN\")\n\t\t, memb(NULL)\n\t{\n\t}\n\n\t/** Constructor.\n\t * @param Memb Membership of the joining user.\n\t */\n\tJoin(Membership* Memb)\n\t\t: ClientProtocol::Message(\"JOIN\", Memb->user)\n\t{\n\t\tSetParams(Memb);\n\t}\n\n\t/** Constructor.\n\t * @param Memb Membership of the joining user.\n\t * @param sourcestrref Message source string, must remain valid as long as this object is alive.\n\t */\n\tJoin(Membership* Memb, const std::string& sourcestrref)\n\t\t: ClientProtocol::Message(\"JOIN\", sourcestrref, Memb->user)\n\t{\n\t\tSetParams(Memb);\n\t}\n\n\t/** Populate parameters from a Membership\n\t * @param Memb Membership of the joining user.\n\t */\n\tvoid SetParams(Membership* Memb)\n\t{\n\t\tmemb = Memb;\n\t\tPushParamRef(memb->chan->name);\n\t}\n\n\t/** Get the Membership of the joining user.\n\t * @return Membership of the joining user.\n\t */\n\tMembership* GetMember() const { return memb; }\n};\n\n/** PART message.\n * Sent when a user parts a channel.\n */\nstruct ClientProtocol::Messages::Part : public ClientProtocol::Message\n{\n\t/** Constructor.\n\t * @param memb Member parting.\n\t * @param reason Part reason, may be empty. If non-empty, must remain valid as long as this object is alive.\n\t */\n\tPart(Membership* memb, const std::string& reason)\n\t\t: ClientProtocol::Message(\"PART\", memb->user)\n\t{\n\t\tPushParamRef(memb->chan->name);\n\t\tif (!reason.empty())\n\t\t\tPushParamRef(reason);\n\t}\n};\n\n/** KICK message.\n * Sent when a user is kicked from a channel.\n */\nstruct ClientProtocol::Messages::Kick : public ClientProtocol::Message\n{\n\t/** Constructor.\n\t * @param source User that does the kick.\n\t * @param memb Membership of the user being kicked.\n\t * @param reason Kick reason. Must remain valid as long as this object is alive.\n\t */\n\tKick(User* source, Membership* memb, const std::string& reason)\n\t\t: ClientProtocol::Message(\"KICK\", source)\n\t{\n\t\tPushParamRef(memb->chan->name);\n\t\tPushParamRef(memb->user->nick);\n\t\tPushParamRef(reason);\n\t}\n};\n\n/** QUIT message.\n * Sent when a user quits.\n */\nstruct ClientProtocol::Messages::Quit : public ClientProtocol::Message\n{\n\t/** Constructor.\n\t * @param source User quitting.\n\t * @param reason Quit reason, may be empty. Must remain valid as long as this object is alive.\n\t */\n\tQuit(User* source, const std::string& reason)\n\t\t: ClientProtocol::Message(\"QUIT\", source)\n\t{\n\t\tif (!reason.empty())\n\t\t\tPushParamRef(reason);\n\t}\n};\n\n/** NICK message.\n * Sent when a user changes their nickname.\n */\nstruct ClientProtocol::Messages::Nick : public ClientProtocol::Message\n{\n\t/** Constructor.\n\t * @param source User changing nicks.\n\t * @param newnick New nickname. Must remain valid as long as this object is alive.\n\t */\n\tNick(User* source, const std::string& newnick)\n\t\t: ClientProtocol::Message(\"NICK\", source)\n\t{\n\t\tPushParamRef(newnick);\n\t}\n};\n\n/** MODE message.\n * Sent when modes are changed on a user or channel.\n */\nclass ClientProtocol::Messages::Mode : public ClientProtocol::Message\n{\n\tChannel* chantarget;\n\tUser* usertarget;\n\tModes::ChangeList::List::const_iterator beginit;\n\tModes::ChangeList::List::const_iterator lastit;\n\n\t/** Convert a range of a mode change list to mode letters and '+', '-' symbols.\n\t * @param list Mode change list.\n\t * @param maxlinelen Maximum output length.\n\t * @param beginit Iterator to the first element in 'list' to process.\n\t * @param lastit Iterator which is set to the first element not processed due to length limitations by the method.\n\t */\n\tstatic std::string ToModeLetters(const Modes::ChangeList::List& list, std::string::size_type maxlinelen, Modes::ChangeList::List::const_iterator beginit, Modes::ChangeList::List::const_iterator& lastit)\n\t{\n\t\tstd::string ret;\n\t\tstd::string::size_type paramlength = 0;\n\t\tchar output_pm = '\\0'; // current output state, '+' or '-'\n\n\t\tModes::ChangeList::List::const_iterator i;\n\t\tfor (i = beginit; i != list.end(); ++i)\n\t\t{\n\t\t\tconst Modes::Change& item = *i;\n\n\t\t\tconst char needed_pm = (item.adding ? '+' : '-');\n\t\t\tif (needed_pm != output_pm)\n\t\t\t{\n\t\t\t\toutput_pm = needed_pm;\n\t\t\t\tret.push_back(output_pm);\n\t\t\t}\n\n\t\t\tif (!item.param.empty())\n\t\t\t\tparamlength += item.param.length() + 1;\n\t\t\tif (ret.length() + 1 + paramlength > maxlinelen)\n\t\t\t{\n\t\t\t\t// Mode sequence is getting too long\n\t\t\t\tconst char c = *ret.rbegin();\n\t\t\t\tif ((c == '+') || (c == '-'))\n\t\t\t\t\tret.erase(ret.size()-1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tret.push_back(item.mh->GetModeChar());\n\t\t}\n\n\t\tlastit = i;\n\t\treturn ret;\n\t}\n\n\t/** Push mode parameters for modes that have one, starting at beginit to lastit (not including lastit).\n\t */\n\tvoid PushModeParams()\n\t{\n\t\tfor (Modes::ChangeList::List::const_iterator i = beginit; i != lastit; ++i)\n\t\t{\n\t\t\tconst Modes::Change& item = *i;\n\t\t\tif (!item.param.empty())\n\t\t\t\tPushParamRef(item.param);\n\t\t}\n\t}\n\n public:\n\t/** Convert an entire mode change list into mode letters and '+' and '-' characters.\n\t * @param changelist Mode change list to convert into mode letters.\n\t * @return Mode letters.\n\t */\n\tstatic std::string ToModeLetters(const Modes::ChangeList& changelist)\n\t{\n\t\t// TODO: This assumes that std::string::max_size() >= UINT_MAX\n\t\tModes::ChangeList::List::const_iterator dummy;\n\t\treturn ToModeLetters(changelist.getlist(), UINT_MAX, changelist.getlist().begin(), dummy);\n\t}\n\n\t/** Constructor, populate parameters starting from a given position in a mode change list.\n\t * @param source User doing the mode change.\n\t * @param Chantarget Channel target of the mode change. May be NULL if Usertarget is non-NULL.\n\t * @param Usertarget User target of the mode change. May be NULL if Chantarget is non-NULL.\n\t * @param changelist Mode change list. Must remain valid and unchanged as long as this object is alive or until the next SetParams() call.\n\t * @param beginiter Starting position of mode changes in 'changelist'.\n\t */\n\tMode(User* source, Channel* Chantarget, User* Usertarget, const Modes::ChangeList& changelist, Modes::ChangeList::List::const_iterator beginiter)\n\t\t: ClientProtocol::Message(\"MODE\", source)\n\t\t, chantarget(Chantarget)\n\t\t, usertarget(Usertarget)\n\t\t, beginit(beginiter)\n\t{\n\t\tPushParamRef(GetStrTarget());\n\t\tPushParam(ToModeLetters(changelist.getlist(), 450, beginit, lastit));\n\t\tPushModeParams();\n\t}\n\n\t/** Constructor, populate parameters starting from the beginning of a mode change list.\n\t * @param source User doing the mode change.\n\t * @param Chantarget Channel target of the mode change. May be NULL if Usertarget is non-NULL.\n\t * @param Usertarget User target of the mode change. May be NULL if Chantarget is non-NULL.\n\t * @param changelist Mode change list. Must remain valid and unchanged as long as this object is alive or until the next SetParams() call.\n\t */\n\tMode(User* source, Channel* Chantarget, User* Usertarget, const Modes::ChangeList& changelist)\n\t\t: ClientProtocol::Message(\"MODE\", source)\n\t\t, chantarget(Chantarget)\n\t\t, usertarget(Usertarget)\n\t\t, beginit(changelist.getlist().begin())\n\t{\n\t\tPushParamRef(GetStrTarget());\n\t\tPushParam(ToModeLetters(changelist.getlist(), 450, beginit, lastit));\n\t\tPushModeParams();\n\t}\n\n\t/** Constructor. Does not populate parameters, call SetParams() before sending the message.\n\t * The message source is set to the local server.\n\t */\n\tMode()\n\t\t: ClientProtocol::Message(\"MODE\", ServerInstance->FakeClient)\n\t\t, chantarget(NULL)\n\t\t, usertarget(NULL)\n\t{\n\t}\n\n\t/** Set parameters\n\t * @param Chantarget Channel target of the mode change. May be NULL if Usertarget is non-NULL.\n\t * @param Usertarget User target of the mode change. May be NULL if Chantarget is non-NULL.\n\t * @param changelist Mode change list. Must remain valid and unchanged as long as this object is alive or until the next SetParams() call.\n\t */\n\tvoid SetParams(Channel* Chantarget, User* Usertarget, const Modes::ChangeList& changelist)\n\t{\n\t\tClearParams();\n\n\t\tchantarget = Chantarget;\n\t\tusertarget = Usertarget;\n\t\tbeginit = changelist.getlist().begin();\n\n\t\tPushParamRef(GetStrTarget());\n\t\tPushParam(ToModeLetters(changelist.getlist(), 450, beginit, lastit));\n\t\tPushModeParams();\n\t}\n\n\t/** Get first mode change included in this MODE message.\n\t * @return Iterator to the first mode change that is included in this MODE message.\n\t */\n\tModes::ChangeList::List::const_iterator\tGetBeginIterator() const { return beginit; }\n\n\t/** Get first mode change not included in this MODE message.\n\t * @return Iterator to the first mode change that is not included in this MODE message.\n\t */\n\tModes::ChangeList::List::const_iterator GetEndIterator() const { return lastit; }\n\n\t/** Get mode change target as a string.\n\t * This is the name of the channel if the mode change targets a channel or the nickname of the user\n\t * if the target is a user.\n\t * @return Name of target as a string.\n\t */\n\tconst std::string& GetStrTarget() const { return (chantarget ? chantarget->name : usertarget->nick); }\n\n\t/** Get user target.\n\t * @return User target or NULL if the mode change targets a channel.\n\t */\n\tUser* GetUserTarget() const { return usertarget; }\n\n\t/** Get channel target.\n\t * @return Channel target or NULL if the mode change targets a user.\n\t */\n\tChannel* GetChanTarget() const { return chantarget; }\n};\n\n/** TOPIC message.\n */\nstruct ClientProtocol::Messages::Topic : public ClientProtocol::Message\n{\n\t/** Constructor.\n\t * @param source User changing the topic.\n\t * @param chan Channel the topic is being changed on.\n\t * @param newtopic New topic. May be empty, must remain valid as long as this object is alive.\n\t */\n\tTopic(User* source, const Channel* chan, const std::string& newtopic)\n\t\t: ClientProtocol::Message(\"TOPIC\", source)\n\t{\n\t\tPushParamRef(chan->name);\n\t\tPushParamRef(newtopic);\n\t}\n};\n\n/** PRIVMSG and NOTICE message.\n */\nclass ClientProtocol::Messages::Privmsg : public ClientProtocol::Message\n{\n\tvoid PushTargetChan(char status, const Channel* targetchan)\n\t{\n\t\tif (status)\n\t\t{\n\t\t\tstd::string rawtarget(1, status);\n\t\t\trawtarget.append(targetchan->name);\n\t\t\tPushParam(rawtarget);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPushParamRef(targetchan->name);\n\t\t}\n\t}\n\n\tvoid PushTargetUser(const User* targetuser)\n\t{\n\t\tif (targetuser->registered & REG_NICK)\n\t\t\tPushParamRef(targetuser->nick);\n\t\telse\n\t\t\tPushParam(\"*\");\n\t}\n\n public:\n\t/** Used to differentiate constructors that copy the text from constructors that do not.\n\t */\n\tenum NoCopy { nocopy };\n\n\t/** Get command name from MessageType.\n\t * @param mt Message type to get command name for.\n\t * @return Command name for the message type.\n\t */\n\tstatic const char* CommandStrFromMsgType(MessageType mt)\n\t{\n\t\treturn ((mt == MSG_PRIVMSG) ? \"PRIVMSG\" : \"NOTICE\");\n\t}\n\n\t/** Constructor, user source, string target, copies text.\n\t * @param source Source user.\n\t * @param target Privmsg target string.\n\t * @param text Privmsg text, will be copied.\n\t * @param mt Message type.\n\t */\n\tPrivmsg(User* source, const std::string& target, const std::string& text, MessageType mt = MSG_PRIVMSG)\n\t\t: ClientProtocol::Message(CommandStrFromMsgType(mt), source)\n\t{\n\t\tPushParam(target);\n\t\tPushParam(text);\n\t}\n\n\t/** Constructor, user source, user target, copies text.\n\t * @param source Source user.\n\t * @param targetchan Target channel.\n\t * @param text Privmsg text, will be copied.\n\t * @param mt Message type.\n\t * @param status Prefix character for status messages. If non-zero the message is a status message. Optional, defaults to 0.\n\t */\n\tPrivmsg(User* source, const Channel* targetchan, const std::string& text, MessageType mt = MSG_PRIVMSG, char status = 0)\n\t\t: ClientProtocol::Message(CommandStrFromMsgType(mt), source)\n\t{\n\t\tPushTargetChan(status, targetchan);\n\t\tPushParam(text);\n\t}\n\n\t/** Constructor, user source, user target, copies text.\n\t * @param source Source user.\n\t * @param targetuser Target user.\n\t * @param text Privmsg text, will be copied.\n\t * @param mt Message type.\n\t */\n\tPrivmsg(User* source, const User* targetuser, const std::string& text, MessageType mt = MSG_PRIVMSG)\n\t\t: ClientProtocol::Message(CommandStrFromMsgType(mt), source)\n\t{\n\t\tPushTargetUser(targetuser);\n\t\tPushParam(text);\n\t}\n\n\t/** Constructor, string source, string target, copies text.\n\t * @param source Source user.\n\t * @param target Target string.\n\t * @param text Privmsg text, will be copied.\n\t * @param mt Message type.\n\t * @param status Prefix character for status messages. If non-zero the message is a status message. Optional, defaults to 0.\n\t */\n\tPrivmsg(const std::string& source, const std::string& target, const std::string& text, MessageType mt = MSG_PRIVMSG, char status = 0)\n\t\t: ClientProtocol::Message(CommandStrFromMsgType(mt), source)\n\t{\n\t\tif (status)\n\t\t{\n\t\t\tstd::string rawtarget(1, status);\n\t\t\trawtarget.append(target);\n\t\t\tPushParam(rawtarget);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPushParam(target);\n\t\t}\n\t\tPushParam(text);\n\t}\n\n\t/** Constructor, string source, channel target, copies text.\n\t * @param source Source string.\n\t * @param targetchan Target channel.\n\t * @param text Privmsg text, will be copied.\n\t * @param status Prefix character for status messages. If non-zero the message is a status message. Optional, defaults to 0.\n\t * @param mt Message type.\n\t */\n\tPrivmsg(const std::string& source, const Channel* targetchan, const std::string& text, MessageType mt = MSG_PRIVMSG, char status = 0)\n\t\t: ClientProtocol::Message(CommandStrFromMsgType(mt), source)\n\t{\n\t\tPushTargetChan(status, targetchan);\n\t\tPushParam(text);\n\t}\n\n\t/** Constructor, string source, user target, copies text.\n\t * @param source Source string.\n\t * @param targetuser Target user.\n\t * @param text Privmsg text, will be copied.\n\t * @param mt Message type.\n\t */\n\tPrivmsg(const std::string& source, const User* targetuser, const std::string& text, MessageType mt = MSG_PRIVMSG)\n\t\t: ClientProtocol::Message(CommandStrFromMsgType(mt), source)\n\t{\n\t\tPushTargetUser(targetuser);\n\t\tPushParam(text);\n\t}\n\n\t/** Constructor, user source, string target, copies text.\n\t * @param source Source user.\n\t * @param target Target string.\n\t * @param text Privmsg text, will not be copied.\n\t * @param mt Message type.\n\t */\n\tPrivmsg(NoCopy, User* source, const std::string& target, const std::string& text, MessageType mt = MSG_PRIVMSG)\n\t\t: ClientProtocol::Message(CommandStrFromMsgType(mt), source)\n\t{\n\t\tPushParam(target);\n\t\tPushParamRef(text);\n\t}\n\n\t/** Constructor, user source, channel target, does not copy text.\n\t * @param source Source user.\n\t * @param targetchan Target channel.\n\t * @param text Privmsg text, will not be copied.\n\t * @param status Prefix character for status messages. If non-zero the message is a status message. Optional, defaults to 0.\n\t * @param mt Message type.\n\t */\n\tPrivmsg(NoCopy, User* source, const Channel* targetchan, const std::string& text, MessageType mt = MSG_PRIVMSG, char status = 0)\n\t\t: ClientProtocol::Message(CommandStrFromMsgType(mt), source)\n\t{\n\t\tPushTargetChan(status, targetchan);\n\t\tPushParamRef(text);\n\t}\n\n\t/** Constructor, user source, user target, does not copy text.\n\t * @param source Source user.\n\t * @param targetuser Target user.\n\t * @param text Privmsg text, will not be copied.\n\t * @param mt Message type.\n\t */\n\tPrivmsg(NoCopy, User* source, const User* targetuser, const std::string& text, MessageType mt = MSG_PRIVMSG)\n\t\t: ClientProtocol::Message(CommandStrFromMsgType(mt), source)\n\t{\n\t\tPushTargetUser(targetuser);\n\t\tPushParamRef(text);\n\t}\n\n\t/** Constructor, string source, string target, does not copy text.\n\t * @param source Source string.\n\t * @param target Target string.\n\t * @param text Privmsg text, will not be copied.\n\t * @param mt Message type.\n\t */\n\tPrivmsg(NoCopy, const std::string& source, const std::string& target, const std::string& text, MessageType mt = MSG_PRIVMSG)\n\t\t: ClientProtocol::Message(CommandStrFromMsgType(mt), source)\n\t{\n\t\tPushParam(target);\n\t\tPushParamRef(text);\n\t}\n\n\t/** Constructor, string source, channel target, does not copy text.\n\t * @param source Source string.\n\t * @param targetchan Target channel.\n\t * @param text Privmsg text, will not be copied.\n\t * @param status Prefix character for status messages. If non-zero the message is a status message. Optional, defaults to 0.\n\t * @param mt Message type.\n\t */\n\tPrivmsg(NoCopy, const std::string& source, const Channel* targetchan, const std::string& text, MessageType mt = MSG_PRIVMSG, char status = 0)\n\t\t: ClientProtocol::Message(CommandStrFromMsgType(mt), source)\n\t{\n\t\tPushTargetChan(status, targetchan);\n\t\tPushParamRef(text);\n\t}\n\n\t/** Constructor, string source, user target, does not copy text.\n\t * @param source Source string.\n\t * @param targetuser Target user.\n\t * @param text Privmsg text, will not be copied.\n\t * @param mt Message type.\n\t */\n\tPrivmsg(NoCopy, const std::string& source, const User* targetuser, const std::string& text, MessageType mt = MSG_PRIVMSG)\n\t\t: ClientProtocol::Message(CommandStrFromMsgType(mt), source)\n\t{\n\t\tPushTargetUser(targetuser);\n\t\tPushParamRef(text);\n\t}\n};\n\n/** INVITE message.\n * Sent when a user is invited to join a channel.\n */\nstruct ClientProtocol::Messages::Invite : public ClientProtocol::Message\n{\n\t/** Constructor.\n\t * @param source User inviting the target user.\n\t * @param target User being invited by source.\n\t * @param chan Channel the target user is being invited to.\n\t */\n\tInvite(User* source, User* target, Channel* chan)\n\t\t: ClientProtocol::Message(\"INVITE\", source)\n\t{\n\t\tPushParamRef(target->nick);\n\t\tPushParamRef(chan->name);\n\t}\n};\n\n/** PING message.\n * Used to check if a connection is still alive.\n */\nstruct ClientProtocol::Messages::Ping : public ClientProtocol::Message\n{\n\t/** Constructor.\n\t * The ping cookie is the name of the local server.\n\t */\n\tPing()\n\t\t: ClientProtocol::Message(\"PING\")\n\t{\n\t\tPushParamRef(ServerInstance->Config->GetServerName());\n\t}\n\n\t/** Constructor.\n\t * @param cookie Ping cookie. Must remain valid as long as this object is alive.\n\t */\n\tPing(const std::string& cookie)\n\t\t: ClientProtocol::Message(\"PING\")\n\t{\n\t\tPushParamRef(cookie);\n\t}\n};\n\n/** PONG message.\n * Sent as a reply to PING.\n */\nstruct ClientProtocol::Messages::Pong : public ClientProtocol::Message\n{\n\t/** Constructor.\n\t * @param cookie Ping cookie. Must remain valid as long as this object is alive.\n\t * @param server Pinged server. Must remain valid as long as this object is alive if non-empty.\n\t */\n\tPong(const std::string& cookie, const std::string& server = \"\")\n\t\t: ClientProtocol::Message(\"PONG\", ServerInstance->Config->GetServerName())\n\t{\n\t\tPushParamRef(ServerInstance->Config->GetServerName());\n\t\tif (!server.empty())\n\t\t\tPushParamRef(server);\n\t\tPushParamRef(cookie);\n\t}\n};\n\n/** ERROR message.\n * Sent to clients upon disconnection.\n */\nstruct ClientProtocol::Messages::Error : public ClientProtocol::Message\n{\n\t/** Constructor.\n\t * @param text Error text.\n\t */\n\tError(const std::string& text)\n\t\t\t: ClientProtocol::Message(\"ERROR\")\n\t{\n\t\tPushParam(text);\n\t}\n};\n", "/*\n * InspIRCd -- Internet Relay Chat Daemon\n *\n *   Copyright (C) 2017-2020 Sadie Powell <sadie@witchery.services>\n *   Copyright (C) 2014-2016, 2018 Attila Molnar <attilamolnar@hush.com>\n *\n * This file is part of InspIRCd.  InspIRCd is free software: you can\n * redistribute it and/or modify it under the terms of the GNU General Public\n * License as published by the Free Software Foundation, version 2.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n\n#include \"inspircd.h\"\n#include \"core_user.h\"\n\n/** Handle /PASS.\n */\nclass CommandPass : public SplitCommand\n{\n public:\n\t/** Constructor for pass.\n\t */\n\tCommandPass(Module* parent)\n\t\t: SplitCommand(parent, \"PASS\", 1, 1)\n\t{\n\t\tworks_before_reg = true;\n\t\tPenalty = 0;\n\t\tsyntax = \"<password>\";\n\t}\n\n\t/** Handle command.\n\t * @param parameters The parameters to the command\n\t * @param user The user issuing the command\n\t * @return A value from CmdResult to indicate command success or failure.\n\t */\n\tCmdResult HandleLocal(LocalUser* user, const Params& parameters) CXX11_OVERRIDE\n\t{\n\t\t// Check to make sure they haven't registered -- Fix by FCS\n\t\tif (user->registered == REG_ALL)\n\t\t{\n\t\t\tuser->CommandFloodPenalty += 1000;\n\t\t\tuser->WriteNumeric(ERR_ALREADYREGISTERED, \"You may not reregister\");\n\t\t\treturn CMD_FAILURE;\n\t\t}\n\t\tuser->password = parameters[0];\n\n\t\treturn CMD_SUCCESS;\n\t}\n};\n\n/** Handle /PING.\n */\nclass CommandPing : public SplitCommand\n{\n public:\n\t/** Constructor for ping.\n\t */\n\tCommandPing(Module* parent)\n\t\t: SplitCommand(parent, \"PING\", 1)\n\t{\n\t\tsyntax = \"<cookie> [<servername>]\";\n\t}\n\n\t/** Handle command.\n\t * @param parameters The parameters to the command\n\t * @param user The user issuing the command\n\t * @return A value from CmdResult to indicate command success or failure.\n\t */\n\tCmdResult HandleLocal(LocalUser* user, const Params& parameters) CXX11_OVERRIDE\n\t{\n\t\tsize_t origin = parameters.size() > 1 ? 1 : 0;\n\t\tif (parameters[origin].empty())\n\t\t{\n\t\t\tuser->WriteNumeric(ERR_NOORIGIN, \"No origin specified\");\n\t\t\treturn CMD_FAILURE;\n\t\t}\n\n\t\tClientProtocol::Messages::Pong pong(parameters[0], origin ? parameters[1] : \"\");\n\t\tuser->Send(ServerInstance->GetRFCEvents().pong, pong);\n\t\treturn CMD_SUCCESS;\n\t}\n};\n\n/** Handle /PONG.\n */\nclass CommandPong : public Command\n{\n public:\n\t/** Constructor for pong.\n\t */\n\tCommandPong(Module* parent)\n\t\t: Command(parent, \"PONG\", 1)\n\t{\n\t\tPenalty = 0;\n\t\tsyntax = \"<cookie> [<servername>]\";\n\t}\n\n\t/** Handle command.\n\t * @param parameters The parameters to the command\n\t * @param user The user issuing the command\n\t * @return A value from CmdResult to indicate command success or failure.\n\t */\n\tCmdResult Handle(User* user, const Params& parameters) CXX11_OVERRIDE\n\t{\n\t\tsize_t origin = parameters.size() > 1 ? 1 : 0;\n\t\tif (parameters[origin].empty())\n\t\t{\n\t\t\tuser->WriteNumeric(ERR_NOORIGIN, \"No origin specified\");\n\t\t\treturn CMD_FAILURE;\n\t\t}\n\n\t\t// set the user as alive so they survive to next ping\n\t\tLocalUser* localuser = IS_LOCAL(user);\n\t\tif (localuser)\n\t\t{\n\t\t\t// Increase penalty unless we've sent a PING and this is the reply\n\t\t\tif (localuser->lastping)\n\t\t\t\tlocaluser->CommandFloodPenalty += 1000;\n\t\t\telse\n\t\t\t\tlocaluser->lastping = 1;\n\t\t}\n\t\treturn CMD_SUCCESS;\n\t}\n};\n\nvoid MessageWrapper::Wrap(const std::string& message, std::string& out)\n{\n\t// If there is a fixed message, it is stored in prefix. Otherwise prefix contains\n\t// only the prefix, so append the message and the suffix\n\tout.assign(prefix);\n\tif (!fixed)\n\t\tout.append(message).append(suffix);\n}\n\nvoid MessageWrapper::ReadConfig(const char* prefixname, const char* suffixname, const char* fixedname)\n{\n\tConfigTag* tag = ServerInstance->Config->ConfValue(\"options\");\n\tprefix = tag->getString(fixedname);\n\tfixed = (!prefix.empty());\n\tif (!fixed)\n\t{\n\t\tprefix = tag->getString(prefixname);\n\t\tsuffix = tag->getString(suffixname);\n\t}\n}\n\nclass CoreModUser : public Module\n{\n\tCommandAway cmdaway;\n\tCommandNick cmdnick;\n\tCommandPart cmdpart;\n\tCommandPass cmdpass;\n\tCommandPing cmdping;\n\tCommandPong cmdpong;\n\tCommandQuit cmdquit;\n\tCommandUser cmduser;\n\tCommandIson cmdison;\n\tCommandUserhost cmduserhost;\n\tSimpleUserModeHandler invisiblemode;\n\tModeUserOperator operatormode;\n\tModeUserServerNoticeMask snomaskmode;\n\n public:\n\tCoreModUser()\n\t\t: cmdaway(this)\n\t\t, cmdnick(this)\n\t\t, cmdpart(this)\n\t\t, cmdpass(this)\n\t\t, cmdping(this)\n\t\t, cmdpong(this)\n\t\t, cmdquit(this)\n\t\t, cmduser(this)\n\t\t, cmdison(this)\n\t\t, cmduserhost(this)\n\t\t, invisiblemode(this, \"invisible\", 'i')\n\t\t, operatormode(this)\n\t\t, snomaskmode(this)\n\t{\n\t}\n\n\tvoid ReadConfig(ConfigStatus& status) CXX11_OVERRIDE\n\t{\n\t\tcmdpart.msgwrap.ReadConfig(\"prefixpart\", \"suffixpart\", \"fixedpart\");\n\t\tcmdquit.msgwrap.ReadConfig(\"prefixquit\", \"suffixquit\", \"fixedquit\");\n\t}\n\n\tVersion GetVersion() CXX11_OVERRIDE\n\t{\n\t\treturn Version(\"Provides the AWAY, ISON, NICK, PART, PASS, PING, PONG, QUIT, USERHOST, and USER commands\", VF_VENDOR|VF_CORE);\n\t}\n};\n\nMODULE_INIT(CoreModUser)\n"], "fixing_code": ["/*\n * InspIRCd -- Internet Relay Chat Daemon\n *\n *   Copyright (C) 2018, 2020 Sadie Powell <sadie@witchery.services>\n *   Copyright (C) 2018 Attila Molnar <attilamolnar@hush.com>\n *\n * This file is part of InspIRCd.  InspIRCd is free software: you can\n * redistribute it and/or modify it under the terms of the GNU General Public\n * License as published by the Free Software Foundation, version 2.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n\n#pragma once\n\nnamespace ClientProtocol\n{\n\tnamespace Messages\n\t{\n\t\tclass Numeric;\n\t\tclass Join;\n\t\tstruct Part;\n\t\tstruct Kick;\n\t\tstruct Quit;\n\t\tstruct Nick;\n\t\tclass Mode;\n\t\tstruct Topic;\n\t\tclass Privmsg;\n\t\tstruct Invite;\n\t\tstruct Ping;\n\t\tstruct Pong;\n\t\tstruct Error;\n\t}\n}\n\n/** Numeric message.\n * Doesn't have a fixed command name, it's always a 3 digit number padded with zeroes if necessary.\n * The first parameter is the target of the numeric which is almost always the nick of the user\n * the numeric will be sent to.\n */\nclass ClientProtocol::Messages::Numeric : public ClientProtocol::Message\n{\n\tchar numericstr[4];\n\n\tvoid InitCommand(unsigned int number)\n\t{\n\t\tsnprintf(numericstr, sizeof(numericstr), \"%03u\", number);\n\t\tSetCommand(numericstr);\n\t}\n\n\tvoid InitFromNumeric(const ::Numeric::Numeric& numeric)\n\t{\n\t\tInitCommand(numeric.GetNumeric());\n\t\tfor (std::vector<std::string>::const_iterator i = numeric.GetParams().begin(); i != numeric.GetParams().end(); ++i)\n\t\t\tPushParamRef(*i);\n\t}\n\n public:\n\t/** Constructor, target is a User.\n\t * @param num Numeric object to send. Must remain valid as long as this object is alive and must not be modified.\n\t * @param user User to send the numeric to. May be unregistered, must remain valid as long as this object is alive.\n\t */\n\tNumeric(const ::Numeric::Numeric& num, User* user)\n\t\t: ClientProtocol::Message(NULL, (num.GetServer() ? num.GetServer() : ServerInstance->FakeClient->server)->GetName())\n\t{\n\t\tif (user->registered & REG_NICK)\n\t\t\tPushParamRef(user->nick);\n\t\telse\n\t\t\tPushParam(\"*\");\n\t\tInitFromNumeric(num);\n\t}\n\n\t/** Constructor, target is a string.\n\t * @param num Numeric object to send. Must remain valid as long as this object is alive and must not be modified.\n\t * @param target Target string, must stay valid as long as this object is alive.\n\t */\n\tNumeric(const ::Numeric::Numeric& num, const std::string& target)\n\t\t: ClientProtocol::Message(NULL, (num.GetServer() ? num.GetServer() : ServerInstance->FakeClient->server)->GetName())\n\t{\n\t\tPushParamRef(target);\n\t\tInitFromNumeric(num);\n\t}\n\n\t/** Constructor. Only the numeric number has to be specified.\n\t * @param num Numeric number.\n\t */\n\tNumeric(unsigned int num)\n\t\t: ClientProtocol::Message(NULL, ServerInstance->Config->GetServerName())\n\t{\n\t\tInitCommand(num);\n\t\tPushParam(\"*\");\n\t}\n};\n\n/** JOIN message.\n * Sent when a user joins a channel.\n */\nclass ClientProtocol::Messages::Join : public ClientProtocol::Message\n{\n\tMembership* memb;\n\n public:\n\t/** Constructor. Does not populate parameters, call SetParams() before sending the message.\n\t */\n\tJoin()\n\t\t: ClientProtocol::Message(\"JOIN\")\n\t\t, memb(NULL)\n\t{\n\t}\n\n\t/** Constructor.\n\t * @param Memb Membership of the joining user.\n\t */\n\tJoin(Membership* Memb)\n\t\t: ClientProtocol::Message(\"JOIN\", Memb->user)\n\t{\n\t\tSetParams(Memb);\n\t}\n\n\t/** Constructor.\n\t * @param Memb Membership of the joining user.\n\t * @param sourcestrref Message source string, must remain valid as long as this object is alive.\n\t */\n\tJoin(Membership* Memb, const std::string& sourcestrref)\n\t\t: ClientProtocol::Message(\"JOIN\", sourcestrref, Memb->user)\n\t{\n\t\tSetParams(Memb);\n\t}\n\n\t/** Populate parameters from a Membership\n\t * @param Memb Membership of the joining user.\n\t */\n\tvoid SetParams(Membership* Memb)\n\t{\n\t\tmemb = Memb;\n\t\tPushParamRef(memb->chan->name);\n\t}\n\n\t/** Get the Membership of the joining user.\n\t * @return Membership of the joining user.\n\t */\n\tMembership* GetMember() const { return memb; }\n};\n\n/** PART message.\n * Sent when a user parts a channel.\n */\nstruct ClientProtocol::Messages::Part : public ClientProtocol::Message\n{\n\t/** Constructor.\n\t * @param memb Member parting.\n\t * @param reason Part reason, may be empty. If non-empty, must remain valid as long as this object is alive.\n\t */\n\tPart(Membership* memb, const std::string& reason)\n\t\t: ClientProtocol::Message(\"PART\", memb->user)\n\t{\n\t\tPushParamRef(memb->chan->name);\n\t\tif (!reason.empty())\n\t\t\tPushParamRef(reason);\n\t}\n};\n\n/** KICK message.\n * Sent when a user is kicked from a channel.\n */\nstruct ClientProtocol::Messages::Kick : public ClientProtocol::Message\n{\n\t/** Constructor.\n\t * @param source User that does the kick.\n\t * @param memb Membership of the user being kicked.\n\t * @param reason Kick reason. Must remain valid as long as this object is alive.\n\t */\n\tKick(User* source, Membership* memb, const std::string& reason)\n\t\t: ClientProtocol::Message(\"KICK\", source)\n\t{\n\t\tPushParamRef(memb->chan->name);\n\t\tPushParamRef(memb->user->nick);\n\t\tPushParamRef(reason);\n\t}\n};\n\n/** QUIT message.\n * Sent when a user quits.\n */\nstruct ClientProtocol::Messages::Quit : public ClientProtocol::Message\n{\n\t/** Constructor.\n\t * @param source User quitting.\n\t * @param reason Quit reason, may be empty. Must remain valid as long as this object is alive.\n\t */\n\tQuit(User* source, const std::string& reason)\n\t\t: ClientProtocol::Message(\"QUIT\", source)\n\t{\n\t\tif (!reason.empty())\n\t\t\tPushParamRef(reason);\n\t}\n};\n\n/** NICK message.\n * Sent when a user changes their nickname.\n */\nstruct ClientProtocol::Messages::Nick : public ClientProtocol::Message\n{\n\t/** Constructor.\n\t * @param source User changing nicks.\n\t * @param newnick New nickname. Must remain valid as long as this object is alive.\n\t */\n\tNick(User* source, const std::string& newnick)\n\t\t: ClientProtocol::Message(\"NICK\", source)\n\t{\n\t\tPushParamRef(newnick);\n\t}\n};\n\n/** MODE message.\n * Sent when modes are changed on a user or channel.\n */\nclass ClientProtocol::Messages::Mode : public ClientProtocol::Message\n{\n\tChannel* chantarget;\n\tUser* usertarget;\n\tModes::ChangeList::List::const_iterator beginit;\n\tModes::ChangeList::List::const_iterator lastit;\n\n\t/** Convert a range of a mode change list to mode letters and '+', '-' symbols.\n\t * @param list Mode change list.\n\t * @param maxlinelen Maximum output length.\n\t * @param beginit Iterator to the first element in 'list' to process.\n\t * @param lastit Iterator which is set to the first element not processed due to length limitations by the method.\n\t */\n\tstatic std::string ToModeLetters(const Modes::ChangeList::List& list, std::string::size_type maxlinelen, Modes::ChangeList::List::const_iterator beginit, Modes::ChangeList::List::const_iterator& lastit)\n\t{\n\t\tstd::string ret;\n\t\tstd::string::size_type paramlength = 0;\n\t\tchar output_pm = '\\0'; // current output state, '+' or '-'\n\n\t\tModes::ChangeList::List::const_iterator i;\n\t\tfor (i = beginit; i != list.end(); ++i)\n\t\t{\n\t\t\tconst Modes::Change& item = *i;\n\n\t\t\tconst char needed_pm = (item.adding ? '+' : '-');\n\t\t\tif (needed_pm != output_pm)\n\t\t\t{\n\t\t\t\toutput_pm = needed_pm;\n\t\t\t\tret.push_back(output_pm);\n\t\t\t}\n\n\t\t\tif (!item.param.empty())\n\t\t\t\tparamlength += item.param.length() + 1;\n\t\t\tif (ret.length() + 1 + paramlength > maxlinelen)\n\t\t\t{\n\t\t\t\t// Mode sequence is getting too long\n\t\t\t\tconst char c = *ret.rbegin();\n\t\t\t\tif ((c == '+') || (c == '-'))\n\t\t\t\t\tret.erase(ret.size()-1);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tret.push_back(item.mh->GetModeChar());\n\t\t}\n\n\t\tlastit = i;\n\t\treturn ret;\n\t}\n\n\t/** Push mode parameters for modes that have one, starting at beginit to lastit (not including lastit).\n\t */\n\tvoid PushModeParams()\n\t{\n\t\tfor (Modes::ChangeList::List::const_iterator i = beginit; i != lastit; ++i)\n\t\t{\n\t\t\tconst Modes::Change& item = *i;\n\t\t\tif (!item.param.empty())\n\t\t\t\tPushParamRef(item.param);\n\t\t}\n\t}\n\n public:\n\t/** Convert an entire mode change list into mode letters and '+' and '-' characters.\n\t * @param changelist Mode change list to convert into mode letters.\n\t * @return Mode letters.\n\t */\n\tstatic std::string ToModeLetters(const Modes::ChangeList& changelist)\n\t{\n\t\t// TODO: This assumes that std::string::max_size() >= UINT_MAX\n\t\tModes::ChangeList::List::const_iterator dummy;\n\t\treturn ToModeLetters(changelist.getlist(), UINT_MAX, changelist.getlist().begin(), dummy);\n\t}\n\n\t/** Constructor, populate parameters starting from a given position in a mode change list.\n\t * @param source User doing the mode change.\n\t * @param Chantarget Channel target of the mode change. May be NULL if Usertarget is non-NULL.\n\t * @param Usertarget User target of the mode change. May be NULL if Chantarget is non-NULL.\n\t * @param changelist Mode change list. Must remain valid and unchanged as long as this object is alive or until the next SetParams() call.\n\t * @param beginiter Starting position of mode changes in 'changelist'.\n\t */\n\tMode(User* source, Channel* Chantarget, User* Usertarget, const Modes::ChangeList& changelist, Modes::ChangeList::List::const_iterator beginiter)\n\t\t: ClientProtocol::Message(\"MODE\", source)\n\t\t, chantarget(Chantarget)\n\t\t, usertarget(Usertarget)\n\t\t, beginit(beginiter)\n\t{\n\t\tPushParamRef(GetStrTarget());\n\t\tPushParam(ToModeLetters(changelist.getlist(), 450, beginit, lastit));\n\t\tPushModeParams();\n\t}\n\n\t/** Constructor, populate parameters starting from the beginning of a mode change list.\n\t * @param source User doing the mode change.\n\t * @param Chantarget Channel target of the mode change. May be NULL if Usertarget is non-NULL.\n\t * @param Usertarget User target of the mode change. May be NULL if Chantarget is non-NULL.\n\t * @param changelist Mode change list. Must remain valid and unchanged as long as this object is alive or until the next SetParams() call.\n\t */\n\tMode(User* source, Channel* Chantarget, User* Usertarget, const Modes::ChangeList& changelist)\n\t\t: ClientProtocol::Message(\"MODE\", source)\n\t\t, chantarget(Chantarget)\n\t\t, usertarget(Usertarget)\n\t\t, beginit(changelist.getlist().begin())\n\t{\n\t\tPushParamRef(GetStrTarget());\n\t\tPushParam(ToModeLetters(changelist.getlist(), 450, beginit, lastit));\n\t\tPushModeParams();\n\t}\n\n\t/** Constructor. Does not populate parameters, call SetParams() before sending the message.\n\t * The message source is set to the local server.\n\t */\n\tMode()\n\t\t: ClientProtocol::Message(\"MODE\", ServerInstance->FakeClient)\n\t\t, chantarget(NULL)\n\t\t, usertarget(NULL)\n\t{\n\t}\n\n\t/** Set parameters\n\t * @param Chantarget Channel target of the mode change. May be NULL if Usertarget is non-NULL.\n\t * @param Usertarget User target of the mode change. May be NULL if Chantarget is non-NULL.\n\t * @param changelist Mode change list. Must remain valid and unchanged as long as this object is alive or until the next SetParams() call.\n\t */\n\tvoid SetParams(Channel* Chantarget, User* Usertarget, const Modes::ChangeList& changelist)\n\t{\n\t\tClearParams();\n\n\t\tchantarget = Chantarget;\n\t\tusertarget = Usertarget;\n\t\tbeginit = changelist.getlist().begin();\n\n\t\tPushParamRef(GetStrTarget());\n\t\tPushParam(ToModeLetters(changelist.getlist(), 450, beginit, lastit));\n\t\tPushModeParams();\n\t}\n\n\t/** Get first mode change included in this MODE message.\n\t * @return Iterator to the first mode change that is included in this MODE message.\n\t */\n\tModes::ChangeList::List::const_iterator\tGetBeginIterator() const { return beginit; }\n\n\t/** Get first mode change not included in this MODE message.\n\t * @return Iterator to the first mode change that is not included in this MODE message.\n\t */\n\tModes::ChangeList::List::const_iterator GetEndIterator() const { return lastit; }\n\n\t/** Get mode change target as a string.\n\t * This is the name of the channel if the mode change targets a channel or the nickname of the user\n\t * if the target is a user.\n\t * @return Name of target as a string.\n\t */\n\tconst std::string& GetStrTarget() const { return (chantarget ? chantarget->name : usertarget->nick); }\n\n\t/** Get user target.\n\t * @return User target or NULL if the mode change targets a channel.\n\t */\n\tUser* GetUserTarget() const { return usertarget; }\n\n\t/** Get channel target.\n\t * @return Channel target or NULL if the mode change targets a user.\n\t */\n\tChannel* GetChanTarget() const { return chantarget; }\n};\n\n/** TOPIC message.\n */\nstruct ClientProtocol::Messages::Topic : public ClientProtocol::Message\n{\n\t/** Constructor.\n\t * @param source User changing the topic.\n\t * @param chan Channel the topic is being changed on.\n\t * @param newtopic New topic. May be empty, must remain valid as long as this object is alive.\n\t */\n\tTopic(User* source, const Channel* chan, const std::string& newtopic)\n\t\t: ClientProtocol::Message(\"TOPIC\", source)\n\t{\n\t\tPushParamRef(chan->name);\n\t\tPushParamRef(newtopic);\n\t}\n};\n\n/** PRIVMSG and NOTICE message.\n */\nclass ClientProtocol::Messages::Privmsg : public ClientProtocol::Message\n{\n\tvoid PushTargetChan(char status, const Channel* targetchan)\n\t{\n\t\tif (status)\n\t\t{\n\t\t\tstd::string rawtarget(1, status);\n\t\t\trawtarget.append(targetchan->name);\n\t\t\tPushParam(rawtarget);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPushParamRef(targetchan->name);\n\t\t}\n\t}\n\n\tvoid PushTargetUser(const User* targetuser)\n\t{\n\t\tif (targetuser->registered & REG_NICK)\n\t\t\tPushParamRef(targetuser->nick);\n\t\telse\n\t\t\tPushParam(\"*\");\n\t}\n\n public:\n\t/** Used to differentiate constructors that copy the text from constructors that do not.\n\t */\n\tenum NoCopy { nocopy };\n\n\t/** Get command name from MessageType.\n\t * @param mt Message type to get command name for.\n\t * @return Command name for the message type.\n\t */\n\tstatic const char* CommandStrFromMsgType(MessageType mt)\n\t{\n\t\treturn ((mt == MSG_PRIVMSG) ? \"PRIVMSG\" : \"NOTICE\");\n\t}\n\n\t/** Constructor, user source, string target, copies text.\n\t * @param source Source user.\n\t * @param target Privmsg target string.\n\t * @param text Privmsg text, will be copied.\n\t * @param mt Message type.\n\t */\n\tPrivmsg(User* source, const std::string& target, const std::string& text, MessageType mt = MSG_PRIVMSG)\n\t\t: ClientProtocol::Message(CommandStrFromMsgType(mt), source)\n\t{\n\t\tPushParam(target);\n\t\tPushParam(text);\n\t}\n\n\t/** Constructor, user source, user target, copies text.\n\t * @param source Source user.\n\t * @param targetchan Target channel.\n\t * @param text Privmsg text, will be copied.\n\t * @param mt Message type.\n\t * @param status Prefix character for status messages. If non-zero the message is a status message. Optional, defaults to 0.\n\t */\n\tPrivmsg(User* source, const Channel* targetchan, const std::string& text, MessageType mt = MSG_PRIVMSG, char status = 0)\n\t\t: ClientProtocol::Message(CommandStrFromMsgType(mt), source)\n\t{\n\t\tPushTargetChan(status, targetchan);\n\t\tPushParam(text);\n\t}\n\n\t/** Constructor, user source, user target, copies text.\n\t * @param source Source user.\n\t * @param targetuser Target user.\n\t * @param text Privmsg text, will be copied.\n\t * @param mt Message type.\n\t */\n\tPrivmsg(User* source, const User* targetuser, const std::string& text, MessageType mt = MSG_PRIVMSG)\n\t\t: ClientProtocol::Message(CommandStrFromMsgType(mt), source)\n\t{\n\t\tPushTargetUser(targetuser);\n\t\tPushParam(text);\n\t}\n\n\t/** Constructor, string source, string target, copies text.\n\t * @param source Source user.\n\t * @param target Target string.\n\t * @param text Privmsg text, will be copied.\n\t * @param mt Message type.\n\t * @param status Prefix character for status messages. If non-zero the message is a status message. Optional, defaults to 0.\n\t */\n\tPrivmsg(const std::string& source, const std::string& target, const std::string& text, MessageType mt = MSG_PRIVMSG, char status = 0)\n\t\t: ClientProtocol::Message(CommandStrFromMsgType(mt), source)\n\t{\n\t\tif (status)\n\t\t{\n\t\t\tstd::string rawtarget(1, status);\n\t\t\trawtarget.append(target);\n\t\t\tPushParam(rawtarget);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tPushParam(target);\n\t\t}\n\t\tPushParam(text);\n\t}\n\n\t/** Constructor, string source, channel target, copies text.\n\t * @param source Source string.\n\t * @param targetchan Target channel.\n\t * @param text Privmsg text, will be copied.\n\t * @param status Prefix character for status messages. If non-zero the message is a status message. Optional, defaults to 0.\n\t * @param mt Message type.\n\t */\n\tPrivmsg(const std::string& source, const Channel* targetchan, const std::string& text, MessageType mt = MSG_PRIVMSG, char status = 0)\n\t\t: ClientProtocol::Message(CommandStrFromMsgType(mt), source)\n\t{\n\t\tPushTargetChan(status, targetchan);\n\t\tPushParam(text);\n\t}\n\n\t/** Constructor, string source, user target, copies text.\n\t * @param source Source string.\n\t * @param targetuser Target user.\n\t * @param text Privmsg text, will be copied.\n\t * @param mt Message type.\n\t */\n\tPrivmsg(const std::string& source, const User* targetuser, const std::string& text, MessageType mt = MSG_PRIVMSG)\n\t\t: ClientProtocol::Message(CommandStrFromMsgType(mt), source)\n\t{\n\t\tPushTargetUser(targetuser);\n\t\tPushParam(text);\n\t}\n\n\t/** Constructor, user source, string target, copies text.\n\t * @param source Source user.\n\t * @param target Target string.\n\t * @param text Privmsg text, will not be copied.\n\t * @param mt Message type.\n\t */\n\tPrivmsg(NoCopy, User* source, const std::string& target, const std::string& text, MessageType mt = MSG_PRIVMSG)\n\t\t: ClientProtocol::Message(CommandStrFromMsgType(mt), source)\n\t{\n\t\tPushParam(target);\n\t\tPushParamRef(text);\n\t}\n\n\t/** Constructor, user source, channel target, does not copy text.\n\t * @param source Source user.\n\t * @param targetchan Target channel.\n\t * @param text Privmsg text, will not be copied.\n\t * @param status Prefix character for status messages. If non-zero the message is a status message. Optional, defaults to 0.\n\t * @param mt Message type.\n\t */\n\tPrivmsg(NoCopy, User* source, const Channel* targetchan, const std::string& text, MessageType mt = MSG_PRIVMSG, char status = 0)\n\t\t: ClientProtocol::Message(CommandStrFromMsgType(mt), source)\n\t{\n\t\tPushTargetChan(status, targetchan);\n\t\tPushParamRef(text);\n\t}\n\n\t/** Constructor, user source, user target, does not copy text.\n\t * @param source Source user.\n\t * @param targetuser Target user.\n\t * @param text Privmsg text, will not be copied.\n\t * @param mt Message type.\n\t */\n\tPrivmsg(NoCopy, User* source, const User* targetuser, const std::string& text, MessageType mt = MSG_PRIVMSG)\n\t\t: ClientProtocol::Message(CommandStrFromMsgType(mt), source)\n\t{\n\t\tPushTargetUser(targetuser);\n\t\tPushParamRef(text);\n\t}\n\n\t/** Constructor, string source, string target, does not copy text.\n\t * @param source Source string.\n\t * @param target Target string.\n\t * @param text Privmsg text, will not be copied.\n\t * @param mt Message type.\n\t */\n\tPrivmsg(NoCopy, const std::string& source, const std::string& target, const std::string& text, MessageType mt = MSG_PRIVMSG)\n\t\t: ClientProtocol::Message(CommandStrFromMsgType(mt), source)\n\t{\n\t\tPushParam(target);\n\t\tPushParamRef(text);\n\t}\n\n\t/** Constructor, string source, channel target, does not copy text.\n\t * @param source Source string.\n\t * @param targetchan Target channel.\n\t * @param text Privmsg text, will not be copied.\n\t * @param status Prefix character for status messages. If non-zero the message is a status message. Optional, defaults to 0.\n\t * @param mt Message type.\n\t */\n\tPrivmsg(NoCopy, const std::string& source, const Channel* targetchan, const std::string& text, MessageType mt = MSG_PRIVMSG, char status = 0)\n\t\t: ClientProtocol::Message(CommandStrFromMsgType(mt), source)\n\t{\n\t\tPushTargetChan(status, targetchan);\n\t\tPushParamRef(text);\n\t}\n\n\t/** Constructor, string source, user target, does not copy text.\n\t * @param source Source string.\n\t * @param targetuser Target user.\n\t * @param text Privmsg text, will not be copied.\n\t * @param mt Message type.\n\t */\n\tPrivmsg(NoCopy, const std::string& source, const User* targetuser, const std::string& text, MessageType mt = MSG_PRIVMSG)\n\t\t: ClientProtocol::Message(CommandStrFromMsgType(mt), source)\n\t{\n\t\tPushTargetUser(targetuser);\n\t\tPushParamRef(text);\n\t}\n};\n\n/** INVITE message.\n * Sent when a user is invited to join a channel.\n */\nstruct ClientProtocol::Messages::Invite : public ClientProtocol::Message\n{\n\t/** Constructor.\n\t * @param source User inviting the target user.\n\t * @param target User being invited by source.\n\t * @param chan Channel the target user is being invited to.\n\t */\n\tInvite(User* source, User* target, Channel* chan)\n\t\t: ClientProtocol::Message(\"INVITE\", source)\n\t{\n\t\tPushParamRef(target->nick);\n\t\tPushParamRef(chan->name);\n\t}\n};\n\n/** PING message.\n * Used to check if a connection is still alive.\n */\nstruct ClientProtocol::Messages::Ping : public ClientProtocol::Message\n{\n\t/** Constructor.\n\t * The ping cookie is the name of the local server.\n\t */\n\tPing()\n\t\t: ClientProtocol::Message(\"PING\")\n\t{\n\t\tPushParamRef(ServerInstance->Config->GetServerName());\n\t}\n\n\t/** Constructor.\n\t * @param cookie Ping cookie. Must remain valid as long as this object is alive.\n\t */\n\tPing(const std::string& cookie)\n\t\t: ClientProtocol::Message(\"PING\")\n\t{\n\t\tPushParamRef(cookie);\n\t}\n};\n\n/** PONG message.\n * Sent as a reply to PING.\n */\nstruct ClientProtocol::Messages::Pong : public ClientProtocol::Message\n{\n\t/** Constructor.\n\t * @param cookie Ping cookie. Must remain valid as long as this object is alive.\n\t * @param server Pinged server. Must remain valid as long as this object is alive if non-empty.\n\t */\n\tPong(const std::string& cookie, const std::string& server = \"\")\n\t\t: ClientProtocol::Message(\"PONG\", ServerInstance->Config->GetServerName())\n\t{\n\t\tif (server.empty())\n\t\t\tPushParamRef(ServerInstance->Config->GetServerName());\n\t\telse\n\t\t\tPushParam(server);\n\t\tPushParamRef(cookie);\n\t}\n};\n\n/** ERROR message.\n * Sent to clients upon disconnection.\n */\nstruct ClientProtocol::Messages::Error : public ClientProtocol::Message\n{\n\t/** Constructor.\n\t * @param text Error text.\n\t */\n\tError(const std::string& text)\n\t\t\t: ClientProtocol::Message(\"ERROR\")\n\t{\n\t\tPushParam(text);\n\t}\n};\n", "/*\n * InspIRCd -- Internet Relay Chat Daemon\n *\n *   Copyright (C) 2017-2020 Sadie Powell <sadie@witchery.services>\n *   Copyright (C) 2014-2016, 2018 Attila Molnar <attilamolnar@hush.com>\n *\n * This file is part of InspIRCd.  InspIRCd is free software: you can\n * redistribute it and/or modify it under the terms of the GNU General Public\n * License as published by the Free Software Foundation, version 2.\n *\n * This program is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS\n * FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more\n * details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n\n#include \"inspircd.h\"\n#include \"core_user.h\"\n\n/** Handle /PASS.\n */\nclass CommandPass : public SplitCommand\n{\n public:\n\t/** Constructor for pass.\n\t */\n\tCommandPass(Module* parent)\n\t\t: SplitCommand(parent, \"PASS\", 1, 1)\n\t{\n\t\tworks_before_reg = true;\n\t\tPenalty = 0;\n\t\tsyntax = \"<password>\";\n\t}\n\n\t/** Handle command.\n\t * @param parameters The parameters to the command\n\t * @param user The user issuing the command\n\t * @return A value from CmdResult to indicate command success or failure.\n\t */\n\tCmdResult HandleLocal(LocalUser* user, const Params& parameters) CXX11_OVERRIDE\n\t{\n\t\t// Check to make sure they haven't registered -- Fix by FCS\n\t\tif (user->registered == REG_ALL)\n\t\t{\n\t\t\tuser->CommandFloodPenalty += 1000;\n\t\t\tuser->WriteNumeric(ERR_ALREADYREGISTERED, \"You may not reregister\");\n\t\t\treturn CMD_FAILURE;\n\t\t}\n\t\tuser->password = parameters[0];\n\n\t\treturn CMD_SUCCESS;\n\t}\n};\n\n/** Handle /PING.\n */\nclass CommandPing : public SplitCommand\n{\n public:\n\t/** Constructor for ping.\n\t */\n\tCommandPing(Module* parent)\n\t\t: SplitCommand(parent, \"PING\", 1)\n\t{\n\t\tsyntax = \"<cookie> [<servername>]\";\n\t}\n\n\t/** Handle command.\n\t * @param parameters The parameters to the command\n\t * @param user The user issuing the command\n\t * @return A value from CmdResult to indicate command success or failure.\n\t */\n\tCmdResult HandleLocal(LocalUser* user, const Params& parameters) CXX11_OVERRIDE\n\t{\n\t\tsize_t origin = parameters.size() > 1 ? 1 : 0;\n\t\tif (parameters[origin].empty())\n\t\t{\n\t\t\tuser->WriteNumeric(ERR_NOORIGIN, \"No origin specified\");\n\t\t\treturn CMD_FAILURE;\n\t\t}\n\n\t\tClientProtocol::Messages::Pong pong(parameters[0], origin ? parameters[1] : ServerInstance->Config->GetServerName());\n\t\tuser->Send(ServerInstance->GetRFCEvents().pong, pong);\n\t\treturn CMD_SUCCESS;\n\t}\n};\n\n/** Handle /PONG.\n */\nclass CommandPong : public Command\n{\n public:\n\t/** Constructor for pong.\n\t */\n\tCommandPong(Module* parent)\n\t\t: Command(parent, \"PONG\", 1)\n\t{\n\t\tPenalty = 0;\n\t\tsyntax = \"<cookie> [<servername>]\";\n\t}\n\n\t/** Handle command.\n\t * @param parameters The parameters to the command\n\t * @param user The user issuing the command\n\t * @return A value from CmdResult to indicate command success or failure.\n\t */\n\tCmdResult Handle(User* user, const Params& parameters) CXX11_OVERRIDE\n\t{\n\t\tsize_t origin = parameters.size() > 1 ? 1 : 0;\n\t\tif (parameters[origin].empty())\n\t\t{\n\t\t\tuser->WriteNumeric(ERR_NOORIGIN, \"No origin specified\");\n\t\t\treturn CMD_FAILURE;\n\t\t}\n\n\t\t// set the user as alive so they survive to next ping\n\t\tLocalUser* localuser = IS_LOCAL(user);\n\t\tif (localuser)\n\t\t{\n\t\t\t// Increase penalty unless we've sent a PING and this is the reply\n\t\t\tif (localuser->lastping)\n\t\t\t\tlocaluser->CommandFloodPenalty += 1000;\n\t\t\telse\n\t\t\t\tlocaluser->lastping = 1;\n\t\t}\n\t\treturn CMD_SUCCESS;\n\t}\n};\n\nvoid MessageWrapper::Wrap(const std::string& message, std::string& out)\n{\n\t// If there is a fixed message, it is stored in prefix. Otherwise prefix contains\n\t// only the prefix, so append the message and the suffix\n\tout.assign(prefix);\n\tif (!fixed)\n\t\tout.append(message).append(suffix);\n}\n\nvoid MessageWrapper::ReadConfig(const char* prefixname, const char* suffixname, const char* fixedname)\n{\n\tConfigTag* tag = ServerInstance->Config->ConfValue(\"options\");\n\tprefix = tag->getString(fixedname);\n\tfixed = (!prefix.empty());\n\tif (!fixed)\n\t{\n\t\tprefix = tag->getString(prefixname);\n\t\tsuffix = tag->getString(suffixname);\n\t}\n}\n\nclass CoreModUser : public Module\n{\n\tCommandAway cmdaway;\n\tCommandNick cmdnick;\n\tCommandPart cmdpart;\n\tCommandPass cmdpass;\n\tCommandPing cmdping;\n\tCommandPong cmdpong;\n\tCommandQuit cmdquit;\n\tCommandUser cmduser;\n\tCommandIson cmdison;\n\tCommandUserhost cmduserhost;\n\tSimpleUserModeHandler invisiblemode;\n\tModeUserOperator operatormode;\n\tModeUserServerNoticeMask snomaskmode;\n\n public:\n\tCoreModUser()\n\t\t: cmdaway(this)\n\t\t, cmdnick(this)\n\t\t, cmdpart(this)\n\t\t, cmdpass(this)\n\t\t, cmdping(this)\n\t\t, cmdpong(this)\n\t\t, cmdquit(this)\n\t\t, cmduser(this)\n\t\t, cmdison(this)\n\t\t, cmduserhost(this)\n\t\t, invisiblemode(this, \"invisible\", 'i')\n\t\t, operatormode(this)\n\t\t, snomaskmode(this)\n\t{\n\t}\n\n\tvoid ReadConfig(ConfigStatus& status) CXX11_OVERRIDE\n\t{\n\t\tcmdpart.msgwrap.ReadConfig(\"prefixpart\", \"suffixpart\", \"fixedpart\");\n\t\tcmdquit.msgwrap.ReadConfig(\"prefixquit\", \"suffixquit\", \"fixedquit\");\n\t}\n\n\tVersion GetVersion() CXX11_OVERRIDE\n\t{\n\t\treturn Version(\"Provides the AWAY, ISON, NICK, PART, PASS, PING, PONG, QUIT, USERHOST, and USER commands\", VF_VENDOR|VF_CORE);\n\t}\n};\n\nMODULE_INIT(CoreModUser)\n"], "filenames": ["include/clientprotocolmsg.h", "src/coremods/core_user/core_user.cpp"], "buggy_code_start_loc": [671, 86], "buggy_code_end_loc": [674, 87], "fixing_code_start_loc": [671, 86], "fixing_code_end_loc": [675, 87], "type": "CWE-732", "message": "InspIRCd 3.8.0 through 3.9.x before 3.10.0 allows any user (able to connect to the server) to access recently deallocated memory, aka the \"malformed PONG\" issue.", "other": {"cve": {"id": "CVE-2021-33586", "sourceIdentifier": "cve@mitre.org", "published": "2021-05-27T05:15:06.993", "lastModified": "2022-06-03T19:36:59.797", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "InspIRCd 3.8.0 through 3.9.x before 3.10.0 allows any user (able to connect to the server) to access recently deallocated memory, aka the \"malformed PONG\" issue."}, {"lang": "es", "value": "InspIRCd versiones 3.8.0 hasta 3.9.x anteriores a 3.10.0, permite que cualquier usuario (capaz de conectarse al servidor) acceder a la memoria desasignada recientemente, tambi\u00e9n se conoce como el problema \"malformed PONG\""}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:L/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-732"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:inspircd:inspircd:*:*:*:*:*:*:*:*", "versionStartIncluding": "3.8.0", "versionEndExcluding": "3.10.0", "matchCriteriaId": "B61FA336-73D2-4151-9436-B9320E867B0E"}]}]}], "references": [{"url": "https://docs.inspircd.org/security/2021-01/", "source": "cve@mitre.org", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://github.com/inspircd/inspircd/commit/4350a11c663b0d75f8119743bffb7736d87abd4d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202107-22", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/inspircd/inspircd/commit/4350a11c663b0d75f8119743bffb7736d87abd4d"}}