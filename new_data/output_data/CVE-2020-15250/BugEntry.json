{"buggy_code": ["package org.junit.rules;\n\nimport static org.junit.Assert.fail;\n\nimport java.io.File;\nimport java.io.IOException;\n\nimport org.junit.Rule;\n\n/**\n * The TemporaryFolder Rule allows creation of files and folders that should\n * be deleted when the test method finishes (whether it passes or\n * fails).\n * By default no exception will be thrown in case the deletion fails.\n *\n * <p>Example of usage:\n * <pre>\n * public static class HasTempFolder {\n *  &#064;Rule\n *  public TemporaryFolder folder= new TemporaryFolder();\n *\n *  &#064;Test\n *  public void testUsingTempFolder() throws IOException {\n *      File createdFile= folder.newFile(&quot;myfile.txt&quot;);\n *      File createdFolder= folder.newFolder(&quot;subfolder&quot;);\n *      // ...\n *     }\n * }\n * </pre>\n *\n * <p>TemporaryFolder rule supports assured deletion mode, which\n * will fail the test in case deletion fails with {@link AssertionError}.\n *\n * <p>Creating TemporaryFolder with assured deletion:\n * <pre>\n *  &#064;Rule\n *  public TemporaryFolder folder= TemporaryFolder.builder().assureDeletion().build();\n * </pre>\n *\n * @since 4.7\n */\npublic class TemporaryFolder extends ExternalResource {\n    private final File parentFolder;\n    private final boolean assureDeletion;\n    private File folder;\n\n    private static final int TEMP_DIR_ATTEMPTS = 10000;\n    private static final String TMP_PREFIX = \"junit\";\n\n    /**\n     * Create a temporary folder which uses system default temporary-file \n     * directory to create temporary resources.\n     */\n    public TemporaryFolder() {\n        this((File) null);\n    }\n\n    /**\n     * Create a temporary folder which uses the specified directory to create\n     * temporary resources.\n     *\n     * @param parentFolder folder where temporary resources will be created.\n     * If {@code null} then system default temporary-file directory is used.\n     */\n    public TemporaryFolder(File parentFolder) {\n        this.parentFolder = parentFolder;\n        this.assureDeletion = false;\n    }\n\n    /**\n     * Create a {@link TemporaryFolder} initialized with\n     * values from a builder.\n     */\n    protected TemporaryFolder(Builder builder) {\n        this.parentFolder = builder.parentFolder;\n        this.assureDeletion = builder.assureDeletion;\n    }\n\n    /**\n     * Returns a new builder for building an instance of {@link TemporaryFolder}.\n     *\n     * @since 4.13\n     */\n    public static Builder builder() {\n        return new Builder();\n    }\n\n    /**\n     * Builds an instance of {@link TemporaryFolder}.\n     * \n     * @since 4.13\n     */\n    public static class Builder {\n        private File parentFolder;\n        private boolean assureDeletion;\n\n        protected Builder() {}\n\n        /**\n         * Specifies which folder to use for creating temporary resources.\n         * If {@code null} then system default temporary-file directory is\n         * used.\n         *\n         * @return this\n         */\n        public Builder parentFolder(File parentFolder) {\n            this.parentFolder = parentFolder;\n            return this;\n        }\n\n        /**\n         * Setting this flag assures that no resources are left undeleted. Failure\n         * to fulfill the assurance results in failure of tests with an\n         * {@link AssertionError}.\n         *\n         * @return this\n         */\n        public Builder assureDeletion() {\n            this.assureDeletion = true;\n            return this;\n        }\n\n        /**\n         * Builds a {@link TemporaryFolder} instance using the values in this builder.\n         */\n        public TemporaryFolder build() {\n            return new TemporaryFolder(this);\n        }\n    }\n\n    @Override\n    protected void before() throws Throwable {\n        create();\n    }\n\n    @Override\n    protected void after() {\n        delete();\n    }\n\n    // testing purposes only\n\n    /**\n     * for testing purposes only. Do not use.\n     */\n    public void create() throws IOException {\n        folder = createTemporaryFolderIn(parentFolder);\n    }\n\n    /**\n     * Returns a new fresh file with the given name under the temporary folder.\n     */\n    public File newFile(String fileName) throws IOException {\n        File file = new File(getRoot(), fileName);\n        if (!file.createNewFile()) {\n            throw new IOException(\n                    \"a file with the name \\'\" + fileName + \"\\' already exists in the test folder\");\n        }\n        return file;\n    }\n\n    /**\n     * Returns a new fresh file with a random name under the temporary folder.\n     */\n    public File newFile() throws IOException {\n        return File.createTempFile(TMP_PREFIX, null, getRoot());\n    }\n\n    /**\n     * Returns a new fresh folder with the given path under the temporary\n     * folder.\n     */\n    public File newFolder(String path) throws IOException {\n        return newFolder(new String[]{path});\n    }\n\n    /**\n     * Returns a new fresh folder with the given paths under the temporary\n     * folder. For example, if you pass in the strings {@code \"parent\"} and {@code \"child\"}\n     * then a directory named {@code \"parent\"} will be created under the temporary folder\n     * and a directory named {@code \"child\"} will be created under the newly-created\n     * {@code \"parent\"} directory.\n     */\n    public File newFolder(String... paths) throws IOException {\n        if (paths.length == 0) {\n            throw new IllegalArgumentException(\"must pass at least one path\");\n        }\n\n        /*\n         * Before checking if the paths are absolute paths, check if create() was ever called,\n         * and if it wasn't, throw IllegalStateException.\n         */\n        File root = getRoot();\n        for (String path : paths) {\n            if (new File(path).isAbsolute()) {\n                throw new IOException(\"folder path \\'\" + path + \"\\' is not a relative path\");\n            }\n        }\n\n        File relativePath = null;\n        File file = root;\n        boolean lastMkdirsCallSuccessful = true;\n        for (String path : paths) {\n            relativePath = new File(relativePath, path);\n            file = new File(root, relativePath.getPath());\n\n            lastMkdirsCallSuccessful = file.mkdirs();\n            if (!lastMkdirsCallSuccessful && !file.isDirectory()) {\n                if (file.exists()) {\n                    throw new IOException(\n                            \"a file with the path \\'\" + relativePath.getPath() + \"\\' exists\");\n                } else {\n                    throw new IOException(\n                            \"could not create a folder with the path \\'\" + relativePath.getPath() + \"\\'\");\n                }\n            }\n        }\n        if (!lastMkdirsCallSuccessful) {\n            throw new IOException(\n                    \"a folder with the path \\'\" + relativePath.getPath() + \"\\' already exists\");\n        }\n        return file;\n    }\n\n    /**\n     * Returns a new fresh folder with a random name under the temporary folder.\n     */\n    public File newFolder() throws IOException {\n        return createTemporaryFolderIn(getRoot());\n    }\n\n    private File createTemporaryFolderIn(File parentFolder) throws IOException {\n        File createdFolder = null;\n        for (int i = 0; i < TEMP_DIR_ATTEMPTS; ++i) {\n            // Use createTempFile to get a suitable folder name.\n            String suffix = \".tmp\";\n            File tmpFile = File.createTempFile(TMP_PREFIX, suffix, parentFolder);\n            String tmpName = tmpFile.toString();\n            // Discard .tmp suffix of tmpName.\n            String folderName = tmpName.substring(0, tmpName.length() - suffix.length());\n            createdFolder = new File(folderName);\n            if (createdFolder.mkdir()) {\n                tmpFile.delete();\n                return createdFolder;\n            }\n            tmpFile.delete();\n        }\n        throw new IOException(\"Unable to create temporary directory in: \"\n            + parentFolder.toString() + \". Tried \" + TEMP_DIR_ATTEMPTS + \" times. \"\n            + \"Last attempted to create: \" + createdFolder.toString());\n    }\n\n    /**\n     * @return the location of this temporary folder.\n     */\n    public File getRoot() {\n        if (folder == null) {\n            throw new IllegalStateException(\n                    \"the temporary folder has not yet been created\");\n        }\n        return folder;\n    }\n\n    /**\n     * Delete all files and folders under the temporary folder. Usually not\n     * called directly, since it is automatically applied by the {@link Rule}.\n     *\n     * @throws AssertionError if unable to clean up resources\n     * and deletion of resources is assured.\n     */\n    public void delete() {\n        if (!tryDelete()) {\n            if (assureDeletion) {\n                fail(\"Unable to clean up temporary folder \" + folder);\n            }\n        }\n    }\n\n    /**\n     * Tries to delete all files and folders under the temporary folder and\n     * returns whether deletion was successful or not.\n     *\n     * @return {@code true} if all resources are deleted successfully,\n     *         {@code false} otherwise.\n     */\n    private boolean tryDelete() {\n        if (folder == null) {\n            return true;\n        }\n        \n        return recursiveDelete(folder);\n    }\n\n    private boolean recursiveDelete(File file) {\n        // Try deleting file before assuming file is a directory\n        // to prevent following symbolic links.\n        if (file.delete()) {\n            return true;\n        }\n        File[] files = file.listFiles();\n        if (files != null) {\n            for (File each : files) {\n                if (!recursiveDelete(each)) {\n                    return false;\n                }\n            }\n        }\n        return file.delete();\n    }\n}\n", "package org.junit.rules;\n\nimport static org.hamcrest.CoreMatchers.hasItem;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.core.IsNot.not;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.experimental.results.PrintableResult.testResult;\nimport static org.junit.experimental.results.ResultMatchers.failureCountIs;\nimport static org.junit.experimental.results.ResultMatchers.isSuccessful;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\n\nimport org.junit.After;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TemporaryFolder;\n\npublic class TempFolderRuleTest {\n    private static File[] createdFiles = new File[20];\n\n    public static class HasTempFolder {\n        @Rule\n        public TemporaryFolder folder = new TemporaryFolder();\n\n        @Test\n        public void testUsingTempFolder() throws IOException {\n            createdFiles[0] = folder.newFile(\"myfile.txt\");\n            assertTrue(createdFiles[0].exists());\n        }\n\n        @Test\n        public void testTempFolderLocation() throws IOException {\n            File folderRoot = folder.getRoot();\n            String tmpRoot = System.getProperty(\"java.io.tmpdir\");\n            assertTrue(folderRoot.toString().startsWith(tmpRoot));\n        }\n    }\n\n    @Test\n    public void tempFolderIsDeleted() {\n        assertThat(testResult(HasTempFolder.class), isSuccessful());\n        assertFalse(createdFiles[0].exists());\n    }\n\n    public static class CreatesSubFolder {\n        @Rule\n        public TemporaryFolder folder = new TemporaryFolder();\n\n        @Test\n        public void testUsingTempFolderStringReflection() throws Exception {\n            String subfolder = \"subfolder\";\n            String filename = \"a.txt\";\n            // force usage of folder.newFolder(String),\n            // check is available and works, to avoid a potential NoSuchMethodError with non-recompiled code.\n            Method method = folder.getClass().getMethod(\"newFolder\", new Class<?>[]{String.class});\n            createdFiles[0] = (File) method.invoke(folder, subfolder);\n            new File(createdFiles[0], filename).createNewFile();\n\n            File expectedFile = new File(folder.getRoot(), join(subfolder, filename));\n\n            assertTrue(expectedFile.exists());\n        }\n\n        @Test\n        public void testUsingTempFolderString() throws IOException {\n            String subfolder = \"subfolder\";\n            String filename = \"a.txt\";\n            // this uses newFolder(String), ensure that a single String works\n            createdFiles[0] = folder.newFolder(subfolder);\n            new File(createdFiles[0], filename).createNewFile();\n\n            File expectedFile = new File(folder.getRoot(), join(subfolder, filename));\n\n            assertTrue(expectedFile.exists());\n        }\n\n        @Test\n        public void testUsingTempTreeFolders() throws IOException {\n            String subfolder = \"subfolder\";\n            String anotherfolder = \"anotherfolder\";\n            String filename = \"a.txt\";\n\n            createdFiles[0] = folder.newFolder(subfolder, anotherfolder);\n            new File(createdFiles[0], filename).createNewFile();\n\n            File expectedFile = new File(folder.getRoot(), join(subfolder, anotherfolder, filename));\n\n            assertTrue(expectedFile.exists());\n        }\n\n        private String join(String... folderNames) {\n            StringBuilder path = new StringBuilder();\n            for (String folderName : folderNames) {\n                path.append(File.separator).append(folderName);\n            }\n            return path.toString();\n        }\n    }\n\n    @Test\n    public void subFolderIsDeleted() {\n        assertThat(testResult(CreatesSubFolder.class), isSuccessful());\n        assertFalse(createdFiles[0].exists());\n    }\n\n    public static class CreatesRandomSubFolders {\n        @Rule\n        public TemporaryFolder folder = new TemporaryFolder();\n\n        @Test\n        public void testUsingRandomTempFolders() throws IOException {\n            for (int i = 0; i < 20; i++) {\n                File newFolder = folder.newFolder();\n                assertThat(Arrays.asList(createdFiles), not(hasItem(newFolder)));\n                createdFiles[i] = newFolder;\n                new File(newFolder, \"a.txt\").createNewFile();\n                assertTrue(newFolder.exists());\n            }\n        }\n    }\n\n    @Test\n    public void randomSubFoldersAreDeleted() {\n        assertThat(testResult(CreatesRandomSubFolders.class), isSuccessful());\n        for (File f : createdFiles) {\n            assertFalse(f.exists());\n        }\n    }\n\n    public static class CreatesRandomFiles {\n        @Rule\n        public TemporaryFolder folder = new TemporaryFolder();\n\n        @Test\n        public void testUsingRandomTempFiles() throws IOException {\n            for (int i = 0; i < 20; i++) {\n                File newFile = folder.newFile();\n                assertThat(Arrays.asList(createdFiles), not(hasItem(newFile)));\n                createdFiles[i] = newFile;\n                assertTrue(newFile.exists());\n            }\n        }\n    }\n\n    @Test\n    public void randomFilesAreDeleted() {\n        assertThat(testResult(CreatesRandomFiles.class), isSuccessful());\n        for (File f : createdFiles) {\n            assertFalse(f.exists());\n        }\n    }\n\n    @Test\n    public void recursiveDeleteFolderWithOneElement() throws IOException {\n        TemporaryFolder folder = new TemporaryFolder();\n        folder.create();\n        File file = folder.newFile(\"a\");\n        folder.delete();\n        assertFalse(file.exists());\n        assertFalse(folder.getRoot().exists());\n    }\n\n    @Test\n    public void recursiveDeleteFolderWithOneRandomElement() throws IOException {\n        TemporaryFolder folder = new TemporaryFolder();\n        folder.create();\n        File file = folder.newFile();\n        folder.delete();\n        assertFalse(file.exists());\n        assertFalse(folder.getRoot().exists());\n    }\n\n    @Test\n    public void recursiveDeleteFolderWithZeroElements() throws IOException {\n        TemporaryFolder folder = new TemporaryFolder();\n        folder.create();\n        folder.delete();\n        assertFalse(folder.getRoot().exists());\n    }\n\n    public static class NameClashes {\n        @Rule\n        public TemporaryFolder folder = new TemporaryFolder();\n\n        @Test\n        public void fileWithFileClash() throws IOException {\n            folder.newFile(\"something.txt\");\n            folder.newFile(\"something.txt\");\n        }\n\n        @Test\n        public void fileWithFolderTest() throws IOException {\n            folder.newFolder(\"dummy\");\n            folder.newFile(\"dummy\");\n        }\n    }\n\n    @Test\n    public void nameClashesResultInTestFailures() {\n        assertThat(testResult(NameClashes.class), failureCountIs(2));\n    }\n\n    private static final String GET_ROOT_DUMMY = \"dummy-getRoot\";\n\n    private static final String NEW_FILE_DUMMY = \"dummy-newFile\";\n\n    private static final String NEW_FOLDER_DUMMY = \"dummy-newFolder\";\n\n    public static class IncorrectUsage {\n        public TemporaryFolder folder = new TemporaryFolder();\n\n        @Test\n        public void testGetRoot() throws IOException {\n            new File(folder.getRoot(), GET_ROOT_DUMMY).createNewFile();\n        }\n\n        @Test\n        public void testNewFile() throws IOException {\n            folder.newFile(NEW_FILE_DUMMY);\n        }\n\n        @Test\n        public void testNewFolder() throws IOException {\n            folder.newFolder(NEW_FOLDER_DUMMY);\n        }\n    }\n\n    @Test\n    public void incorrectUsageWithoutApplyingTheRuleShouldNotPolluteTheCurrentWorkingDirectory() {\n        assertThat(testResult(IncorrectUsage.class), failureCountIs(3));\n        assertFalse(\"getRoot should have failed early\", new File(GET_ROOT_DUMMY).exists());\n        assertFalse(\"newFile should have failed early\", new File(NEW_FILE_DUMMY).exists());\n        assertFalse(\"newFolder should have failed early\", new File(NEW_FOLDER_DUMMY).exists());\n    }\n\n    @After\n    public void cleanCurrentWorkingDirectory() {\n        new File(GET_ROOT_DUMMY).delete();\n        new File(NEW_FILE_DUMMY).delete();\n        new File(NEW_FOLDER_DUMMY).delete();\n    }\n}\n"], "fixing_code": ["package org.junit.rules;\n\nimport static org.junit.Assert.fail;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\n\nimport org.junit.Rule;\n\n/**\n * The TemporaryFolder Rule allows creation of files and folders that should\n * be deleted when the test method finishes (whether it passes or\n * fails).\n * By default no exception will be thrown in case the deletion fails.\n *\n * <p>Example of usage:\n * <pre>\n * public static class HasTempFolder {\n *  &#064;Rule\n *  public TemporaryFolder folder= new TemporaryFolder();\n *\n *  &#064;Test\n *  public void testUsingTempFolder() throws IOException {\n *      File createdFile= folder.newFile(&quot;myfile.txt&quot;);\n *      File createdFolder= folder.newFolder(&quot;subfolder&quot;);\n *      // ...\n *     }\n * }\n * </pre>\n *\n * <p>TemporaryFolder rule supports assured deletion mode, which\n * will fail the test in case deletion fails with {@link AssertionError}.\n *\n * <p>Creating TemporaryFolder with assured deletion:\n * <pre>\n *  &#064;Rule\n *  public TemporaryFolder folder= TemporaryFolder.builder().assureDeletion().build();\n * </pre>\n *\n * @since 4.7\n */\npublic class TemporaryFolder extends ExternalResource {\n    private final File parentFolder;\n    private final boolean assureDeletion;\n    private File folder;\n\n    private static final int TEMP_DIR_ATTEMPTS = 10000;\n    private static final String TMP_PREFIX = \"junit\";\n\n    /**\n     * Create a temporary folder which uses system default temporary-file \n     * directory to create temporary resources.\n     */\n    public TemporaryFolder() {\n        this((File) null);\n    }\n\n    /**\n     * Create a temporary folder which uses the specified directory to create\n     * temporary resources.\n     *\n     * @param parentFolder folder where temporary resources will be created.\n     * If {@code null} then system default temporary-file directory is used.\n     */\n    public TemporaryFolder(File parentFolder) {\n        this.parentFolder = parentFolder;\n        this.assureDeletion = false;\n    }\n\n    /**\n     * Create a {@link TemporaryFolder} initialized with\n     * values from a builder.\n     */\n    protected TemporaryFolder(Builder builder) {\n        this.parentFolder = builder.parentFolder;\n        this.assureDeletion = builder.assureDeletion;\n    }\n\n    /**\n     * Returns a new builder for building an instance of {@link TemporaryFolder}.\n     *\n     * @since 4.13\n     */\n    public static Builder builder() {\n        return new Builder();\n    }\n\n    /**\n     * Builds an instance of {@link TemporaryFolder}.\n     * \n     * @since 4.13\n     */\n    public static class Builder {\n        private File parentFolder;\n        private boolean assureDeletion;\n\n        protected Builder() {}\n\n        /**\n         * Specifies which folder to use for creating temporary resources.\n         * If {@code null} then system default temporary-file directory is\n         * used.\n         *\n         * @return this\n         */\n        public Builder parentFolder(File parentFolder) {\n            this.parentFolder = parentFolder;\n            return this;\n        }\n\n        /**\n         * Setting this flag assures that no resources are left undeleted. Failure\n         * to fulfill the assurance results in failure of tests with an\n         * {@link AssertionError}.\n         *\n         * @return this\n         */\n        public Builder assureDeletion() {\n            this.assureDeletion = true;\n            return this;\n        }\n\n        /**\n         * Builds a {@link TemporaryFolder} instance using the values in this builder.\n         */\n        public TemporaryFolder build() {\n            return new TemporaryFolder(this);\n        }\n    }\n\n    @Override\n    protected void before() throws Throwable {\n        create();\n    }\n\n    @Override\n    protected void after() {\n        delete();\n    }\n\n    // testing purposes only\n\n    /**\n     * for testing purposes only. Do not use.\n     */\n    public void create() throws IOException {\n        folder = createTemporaryFolderIn(parentFolder);\n    }\n\n    /**\n     * Returns a new fresh file with the given name under the temporary folder.\n     */\n    public File newFile(String fileName) throws IOException {\n        File file = new File(getRoot(), fileName);\n        if (!file.createNewFile()) {\n            throw new IOException(\n                    \"a file with the name \\'\" + fileName + \"\\' already exists in the test folder\");\n        }\n        return file;\n    }\n\n    /**\n     * Returns a new fresh file with a random name under the temporary folder.\n     */\n    public File newFile() throws IOException {\n        return File.createTempFile(TMP_PREFIX, null, getRoot());\n    }\n\n    /**\n     * Returns a new fresh folder with the given path under the temporary\n     * folder.\n     */\n    public File newFolder(String path) throws IOException {\n        return newFolder(new String[]{path});\n    }\n\n    /**\n     * Returns a new fresh folder with the given paths under the temporary\n     * folder. For example, if you pass in the strings {@code \"parent\"} and {@code \"child\"}\n     * then a directory named {@code \"parent\"} will be created under the temporary folder\n     * and a directory named {@code \"child\"} will be created under the newly-created\n     * {@code \"parent\"} directory.\n     */\n    public File newFolder(String... paths) throws IOException {\n        if (paths.length == 0) {\n            throw new IllegalArgumentException(\"must pass at least one path\");\n        }\n\n        /*\n         * Before checking if the paths are absolute paths, check if create() was ever called,\n         * and if it wasn't, throw IllegalStateException.\n         */\n        File root = getRoot();\n        for (String path : paths) {\n            if (new File(path).isAbsolute()) {\n                throw new IOException(\"folder path \\'\" + path + \"\\' is not a relative path\");\n            }\n        }\n\n        File relativePath = null;\n        File file = root;\n        boolean lastMkdirsCallSuccessful = true;\n        for (String path : paths) {\n            relativePath = new File(relativePath, path);\n            file = new File(root, relativePath.getPath());\n\n            lastMkdirsCallSuccessful = file.mkdirs();\n            if (!lastMkdirsCallSuccessful && !file.isDirectory()) {\n                if (file.exists()) {\n                    throw new IOException(\n                            \"a file with the path \\'\" + relativePath.getPath() + \"\\' exists\");\n                } else {\n                    throw new IOException(\n                            \"could not create a folder with the path \\'\" + relativePath.getPath() + \"\\'\");\n                }\n            }\n        }\n        if (!lastMkdirsCallSuccessful) {\n            throw new IOException(\n                    \"a folder with the path \\'\" + relativePath.getPath() + \"\\' already exists\");\n        }\n        return file;\n    }\n\n    /**\n     * Returns a new fresh folder with a random name under the temporary folder.\n     */\n    public File newFolder() throws IOException {\n        return createTemporaryFolderIn(getRoot());\n    }\n\n    private static File createTemporaryFolderIn(File parentFolder) throws IOException {\n        try {\n            return createTemporaryFolderWithNioApi(parentFolder);\n        } catch (ClassNotFoundException ignore) {\n            // Fallback for Java 5 and 6\n            return createTemporaryFolderWithFileApi(parentFolder);\n        } catch (InvocationTargetException e) {\n            Throwable cause = e.getCause();\n            if (cause instanceof IOException) {\n                throw (IOException) cause;\n            }\n            if (cause instanceof RuntimeException) {\n                throw (RuntimeException) cause;\n            }\n            IOException exception = new IOException(\"Failed to create temporary folder in \" + parentFolder);\n            exception.initCause(cause);\n            throw exception;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Failed to create temporary folder in \" + parentFolder, e);\n        }\n    }\n\n    private static File createTemporaryFolderWithNioApi(File parentFolder) throws ClassNotFoundException, NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n        Class<?> filesClass = Class.forName(\"java.nio.file.Files\");\n        Object fileAttributeArray = Array.newInstance(Class.forName(\"java.nio.file.attribute.FileAttribute\"), 0);\n        Class<?> pathClass = Class.forName(\"java.nio.file.Path\");\n        Object tempDir;\n        if (parentFolder != null) {\n            Method createTempDirectoryMethod = filesClass.getDeclaredMethod(\"createTempDirectory\", pathClass, String.class, fileAttributeArray.getClass());\n            Object parentPath = File.class.getDeclaredMethod(\"toPath\").invoke(parentFolder);\n            tempDir = createTempDirectoryMethod.invoke(null, parentPath, TMP_PREFIX, fileAttributeArray);\n        } else {\n            Method createTempDirectoryMethod = filesClass.getDeclaredMethod(\"createTempDirectory\", String.class, fileAttributeArray.getClass());\n            tempDir = createTempDirectoryMethod.invoke(null, TMP_PREFIX, fileAttributeArray);\n        }\n        return (File) pathClass.getDeclaredMethod(\"toFile\").invoke(tempDir);\n    }\n\n    private static File createTemporaryFolderWithFileApi(File parentFolder) throws IOException {\n        File createdFolder = null;\n        for (int i = 0; i < TEMP_DIR_ATTEMPTS; ++i) {\n            // Use createTempFile to get a suitable folder name.\n            String suffix = \".tmp\";\n            File tmpFile = File.createTempFile(TMP_PREFIX, suffix, parentFolder);\n            String tmpName = tmpFile.toString();\n            // Discard .tmp suffix of tmpName.\n            String folderName = tmpName.substring(0, tmpName.length() - suffix.length());\n            createdFolder = new File(folderName);\n            if (createdFolder.mkdir()) {\n                tmpFile.delete();\n                return createdFolder;\n            }\n            tmpFile.delete();\n        }\n        throw new IOException(\"Unable to create temporary directory in: \"\n            + parentFolder.toString() + \". Tried \" + TEMP_DIR_ATTEMPTS + \" times. \"\n            + \"Last attempted to create: \" + createdFolder.toString());\n    }\n\n    /**\n     * @return the location of this temporary folder.\n     */\n    public File getRoot() {\n        if (folder == null) {\n            throw new IllegalStateException(\n                    \"the temporary folder has not yet been created\");\n        }\n        return folder;\n    }\n\n    /**\n     * Delete all files and folders under the temporary folder. Usually not\n     * called directly, since it is automatically applied by the {@link Rule}.\n     *\n     * @throws AssertionError if unable to clean up resources\n     * and deletion of resources is assured.\n     */\n    public void delete() {\n        if (!tryDelete()) {\n            if (assureDeletion) {\n                fail(\"Unable to clean up temporary folder \" + folder);\n            }\n        }\n    }\n\n    /**\n     * Tries to delete all files and folders under the temporary folder and\n     * returns whether deletion was successful or not.\n     *\n     * @return {@code true} if all resources are deleted successfully,\n     *         {@code false} otherwise.\n     */\n    private boolean tryDelete() {\n        if (folder == null) {\n            return true;\n        }\n        \n        return recursiveDelete(folder);\n    }\n\n    private boolean recursiveDelete(File file) {\n        // Try deleting file before assuming file is a directory\n        // to prevent following symbolic links.\n        if (file.delete()) {\n            return true;\n        }\n        File[] files = file.listFiles();\n        if (files != null) {\n            for (File each : files) {\n                if (!recursiveDelete(each)) {\n                    return false;\n                }\n            }\n        }\n        return file.delete();\n    }\n}\n", "package org.junit.rules;\n\nimport static org.hamcrest.CoreMatchers.hasItem;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.core.IsNot.not;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assume.assumeTrue;\nimport static org.junit.experimental.results.PrintableResult.testResult;\nimport static org.junit.experimental.results.ResultMatchers.failureCountIs;\nimport static org.junit.experimental.results.ResultMatchers.isSuccessful;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.lang.reflect.Array;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\n\nimport org.junit.After;\nimport org.junit.AssumptionViolatedException;\nimport org.junit.Rule;\nimport org.junit.Test;\n\npublic class TempFolderRuleTest {\n    private static File[] createdFiles = new File[20];\n\n    public static class HasTempFolder {\n        @Rule\n        public TemporaryFolder folder = new TemporaryFolder();\n\n        @Test\n        public void testUsingTempFolder() throws IOException {\n            createdFiles[0] = folder.newFile(\"myfile.txt\");\n            assertTrue(createdFiles[0].exists());\n        }\n\n        @Test\n        public void testTempFolderLocation() throws IOException {\n            File folderRoot = folder.getRoot();\n            String tmpRoot = System.getProperty(\"java.io.tmpdir\");\n            assertTrue(folderRoot.toString().startsWith(tmpRoot));\n        }\n    }\n\n    @Test\n    public void tempFolderIsDeleted() {\n        assertThat(testResult(HasTempFolder.class), isSuccessful());\n        assertFalse(createdFiles[0].exists());\n    }\n\n    public static class CreatesSubFolder {\n        @Rule\n        public TemporaryFolder folder = new TemporaryFolder();\n\n        @Test\n        public void testUsingTempFolderStringReflection() throws Exception {\n            String subfolder = \"subfolder\";\n            String filename = \"a.txt\";\n            // force usage of folder.newFolder(String),\n            // check is available and works, to avoid a potential NoSuchMethodError with non-recompiled code.\n            Method method = folder.getClass().getMethod(\"newFolder\", new Class<?>[]{String.class});\n            createdFiles[0] = (File) method.invoke(folder, subfolder);\n            new File(createdFiles[0], filename).createNewFile();\n\n            File expectedFile = new File(folder.getRoot(), join(subfolder, filename));\n\n            assertTrue(expectedFile.exists());\n        }\n\n        @Test\n        public void testUsingTempFolderString() throws IOException {\n            String subfolder = \"subfolder\";\n            String filename = \"a.txt\";\n            // this uses newFolder(String), ensure that a single String works\n            createdFiles[0] = folder.newFolder(subfolder);\n            new File(createdFiles[0], filename).createNewFile();\n\n            File expectedFile = new File(folder.getRoot(), join(subfolder, filename));\n\n            assertTrue(expectedFile.exists());\n        }\n\n        @Test\n        public void testUsingTempTreeFolders() throws IOException {\n            String subfolder = \"subfolder\";\n            String anotherfolder = \"anotherfolder\";\n            String filename = \"a.txt\";\n\n            createdFiles[0] = folder.newFolder(subfolder, anotherfolder);\n            new File(createdFiles[0], filename).createNewFile();\n\n            File expectedFile = new File(folder.getRoot(), join(subfolder, anotherfolder, filename));\n\n            assertTrue(expectedFile.exists());\n        }\n\n        private String join(String... folderNames) {\n            StringBuilder path = new StringBuilder();\n            for (String folderName : folderNames) {\n                path.append(File.separator).append(folderName);\n            }\n            return path.toString();\n        }\n    }\n\n    @Test\n    public void subFolderIsDeleted() {\n        assertThat(testResult(CreatesSubFolder.class), isSuccessful());\n        assertFalse(createdFiles[0].exists());\n    }\n\n    public static class CreatesRandomSubFolders {\n        @Rule\n        public TemporaryFolder folder = new TemporaryFolder();\n\n        @Test\n        public void testUsingRandomTempFolders() throws IOException {\n            for (int i = 0; i < 20; i++) {\n                File newFolder = folder.newFolder();\n                assertThat(Arrays.asList(createdFiles), not(hasItem(newFolder)));\n                createdFiles[i] = newFolder;\n                new File(newFolder, \"a.txt\").createNewFile();\n                assertTrue(newFolder.exists());\n            }\n        }\n    }\n\n    @Test\n    public void randomSubFoldersAreDeleted() {\n        assertThat(testResult(CreatesRandomSubFolders.class), isSuccessful());\n        for (File f : createdFiles) {\n            assertFalse(f.exists());\n        }\n    }\n\n    public static class CreatesRandomFiles {\n        @Rule\n        public TemporaryFolder folder = new TemporaryFolder();\n\n        @Test\n        public void testUsingRandomTempFiles() throws IOException {\n            for (int i = 0; i < 20; i++) {\n                File newFile = folder.newFile();\n                assertThat(Arrays.asList(createdFiles), not(hasItem(newFile)));\n                createdFiles[i] = newFile;\n                assertTrue(newFile.exists());\n            }\n        }\n    }\n\n    @Test\n    public void randomFilesAreDeleted() {\n        assertThat(testResult(CreatesRandomFiles.class), isSuccessful());\n        for (File f : createdFiles) {\n            assertFalse(f.exists());\n        }\n    }\n\n    @Test\n    public void recursiveDeleteFolderWithOneElement() throws IOException {\n        TemporaryFolder folder = new TemporaryFolder();\n        folder.create();\n        File file = folder.newFile(\"a\");\n        folder.delete();\n        assertFalse(file.exists());\n        assertFalse(folder.getRoot().exists());\n    }\n\n    @Test\n    public void recursiveDeleteFolderWithOneRandomElement() throws IOException {\n        TemporaryFolder folder = new TemporaryFolder();\n        folder.create();\n        File file = folder.newFile();\n        folder.delete();\n        assertFalse(file.exists());\n        assertFalse(folder.getRoot().exists());\n    }\n\n    @Test\n    public void recursiveDeleteFolderWithZeroElements() throws IOException {\n        TemporaryFolder folder = new TemporaryFolder();\n        folder.create();\n        folder.delete();\n        assertFalse(folder.getRoot().exists());\n    }\n\n    @Test\n    public void tempFolderIsOnlyAccessibleByOwner() throws IOException {\n        TemporaryFolder folder = new TemporaryFolder();\n        folder.create();\n\n        Set<String> expectedPermissions = new TreeSet<String>(Arrays.asList(\"OWNER_READ\", \"OWNER_WRITE\", \"OWNER_EXECUTE\"));\n        Set<String> actualPermissions = getPosixFilePermissions(folder.getRoot());\n        assertEquals(expectedPermissions, actualPermissions);\n    }\n\n    private Set<String> getPosixFilePermissions(File root) {\n        try {\n            Class<?> pathClass = Class.forName(\"java.nio.file.Path\");\n            Object linkOptionArray = Array.newInstance(Class.forName(\"java.nio.file.LinkOption\"), 0);\n            Class<?> filesClass = Class.forName(\"java.nio.file.Files\");\n            Object path = File.class.getDeclaredMethod(\"toPath\").invoke(root);\n            Method posixFilePermissionsMethod = filesClass.getDeclaredMethod(\"getPosixFilePermissions\", pathClass, linkOptionArray.getClass());\n            Set<?> permissions = (Set<?>) posixFilePermissionsMethod.invoke(null, path, linkOptionArray);\n            SortedSet<String> convertedPermissions = new TreeSet<String>();\n            for (Object item : permissions) {\n                convertedPermissions.add(item.toString());\n            }\n            return convertedPermissions;\n        } catch (Exception e) {\n            throw new AssumptionViolatedException(\"Test requires at least Java 1.7\", e);\n        }\n    }\n\n    public static class NameClashes {\n        @Rule\n        public TemporaryFolder folder = new TemporaryFolder();\n\n        @Test\n        public void fileWithFileClash() throws IOException {\n            folder.newFile(\"something.txt\");\n            folder.newFile(\"something.txt\");\n        }\n\n        @Test\n        public void fileWithFolderTest() throws IOException {\n            folder.newFolder(\"dummy\");\n            folder.newFile(\"dummy\");\n        }\n    }\n\n    @Test\n    public void nameClashesResultInTestFailures() {\n        assertThat(testResult(NameClashes.class), failureCountIs(2));\n    }\n\n    private static final String GET_ROOT_DUMMY = \"dummy-getRoot\";\n\n    private static final String NEW_FILE_DUMMY = \"dummy-newFile\";\n\n    private static final String NEW_FOLDER_DUMMY = \"dummy-newFolder\";\n\n    public static class IncorrectUsage {\n        public TemporaryFolder folder = new TemporaryFolder();\n\n        @Test\n        public void testGetRoot() throws IOException {\n            new File(folder.getRoot(), GET_ROOT_DUMMY).createNewFile();\n        }\n\n        @Test\n        public void testNewFile() throws IOException {\n            folder.newFile(NEW_FILE_DUMMY);\n        }\n\n        @Test\n        public void testNewFolder() throws IOException {\n            folder.newFolder(NEW_FOLDER_DUMMY);\n        }\n    }\n\n    @Test\n    public void incorrectUsageWithoutApplyingTheRuleShouldNotPolluteTheCurrentWorkingDirectory() {\n        assertThat(testResult(IncorrectUsage.class), failureCountIs(3));\n        assertFalse(\"getRoot should have failed early\", new File(GET_ROOT_DUMMY).exists());\n        assertFalse(\"newFile should have failed early\", new File(NEW_FILE_DUMMY).exists());\n        assertFalse(\"newFolder should have failed early\", new File(NEW_FOLDER_DUMMY).exists());\n    }\n\n    @After\n    public void cleanCurrentWorkingDirectory() {\n        new File(GET_ROOT_DUMMY).delete();\n        new File(NEW_FILE_DUMMY).delete();\n        new File(NEW_FOLDER_DUMMY).delete();\n    }\n}\n"], "filenames": ["src/main/java/org/junit/rules/TemporaryFolder.java", "src/test/java/org/junit/rules/TempFolderRuleTest.java"], "buggy_code_start_loc": [6, 5], "buggy_code_end_loc": [233, 184], "fixing_code_start_loc": [7, 6], "fixing_code_end_loc": [274, 220], "type": "CWE-732", "message": "In JUnit4 from version 4.7 and before 4.13.1, the test rule TemporaryFolder contains a local information disclosure vulnerability. On Unix like systems, the system's temporary directory is shared between all users on that system. Because of this, when files and directories are written into this directory they are, by default, readable by other users on that same system. This vulnerability does not allow other users to overwrite the contents of these directories or files. This is purely an information disclosure vulnerability. This vulnerability impacts you if the JUnit tests write sensitive information, like API keys or passwords, into the temporary folder, and the JUnit tests execute in an environment where the OS has other untrusted users. Because certain JDK file system APIs were only added in JDK 1.7, this this fix is dependent upon the version of the JDK you are using. For Java 1.7 and higher users: this vulnerability is fixed in 4.13.1. For Java 1.6 and lower users: no patch is available, you must use the workaround below. If you are unable to patch, or are stuck running on Java 1.6, specifying the `java.io.tmpdir` system environment variable to a directory that is exclusively owned by the executing user will fix this vulnerability. For more information, including an example of vulnerable code, see the referenced GitHub Security Advisory.", "other": {"cve": {"id": "CVE-2020-15250", "sourceIdentifier": "security-advisories@github.com", "published": "2020-10-12T18:15:13.233", "lastModified": "2022-05-12T14:43:17.810", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In JUnit4 from version 4.7 and before 4.13.1, the test rule TemporaryFolder contains a local information disclosure vulnerability. On Unix like systems, the system's temporary directory is shared between all users on that system. Because of this, when files and directories are written into this directory they are, by default, readable by other users on that same system. This vulnerability does not allow other users to overwrite the contents of these directories or files. This is purely an information disclosure vulnerability. This vulnerability impacts you if the JUnit tests write sensitive information, like API keys or passwords, into the temporary folder, and the JUnit tests execute in an environment where the OS has other untrusted users. Because certain JDK file system APIs were only added in JDK 1.7, this this fix is dependent upon the version of the JDK you are using. For Java 1.7 and higher users: this vulnerability is fixed in 4.13.1. For Java 1.6 and lower users: no patch is available, you must use the workaround below. If you are unable to patch, or are stuck running on Java 1.6, specifying the `java.io.tmpdir` system environment variable to a directory that is exclusively owned by the executing user will fix this vulnerability. For more information, including an example of vulnerable code, see the referenced GitHub Security Advisory."}, {"lang": "es", "value": "En JUnit4 desde la versi\u00f3n y antes de la versi\u00f3n 4.13.1, la regla de prueba TemporaryFolder contiene una vulnerabilidad de divulgaci\u00f3n de informaci\u00f3n local. En sistemas similares a Unix, el directorio temporal del sistema es compartido entre todos los usuarios de ese sistema. Debido a esto, cuando los archivos y directorios se escrib\u00edan en este directorio, son, por defecto, legibles por otros usuarios en ese mismo sistema.  Esta vulnerabilidad no permite que otros usuarios sobrescriban el contenido de estos directorios o archivos. Esto es solamente una vulnerabilidad de divulgaci\u00f3n de informaci\u00f3n.  Esta vulnerabilidad lo impacta si las pruebas de JUnit escriben informaci\u00f3n confidencial, como claves de API o contrase\u00f1as, en la carpeta temporal, y las pruebas de JUnit son ejecutados en un entorno donde el sistema operativo posee otros usuarios que no son de confianza. Debido a que determinadas API del sistema de archivos JDK solo fueron agregadas en JDK versi\u00f3n 1.7. Esta correcci\u00f3n depende de la versi\u00f3n del JDK que est\u00e9 usando.  Para usuarios de Java versi\u00f3n 1.7 y posteriores: esta vulnerabilidad se corrigi\u00f3 en la versi\u00f3n 4.13.1. Para usuarios de Java versi\u00f3n 1.6 y anteriores: ning\u00fan parche est\u00e1 disponible, debe utilizar la siguiente soluci\u00f3n. Si no es capaz de parchear, o est\u00e1 bloqueado al ejecutar Java versi\u00f3n 1.6, especificar la variable de entorno del sistema \"java.io.tmpdir\" en un directorio que es propiedad exclusiva del usuario que lo ejecuta, solucionar\u00e1 esta vulnerabilidad.  Para m\u00e1s informaci\u00f3n, se incluye un ejemplo del c\u00f3digo vulnerable, consulte el Aviso de Seguridad de GitHub al que se hace referencia"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:H/PR:L/UI:R/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.4, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 0.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:M/Au:N/C:P/I:N/A:N", "accessVector": "LOCAL", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 1.9}, "baseSeverity": "LOW", "exploitabilityScore": 3.4, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-732"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:junit:junit4:*:*:*:*:*:*:*:*", "versionStartIncluding": "4.7", "versionEndExcluding": "4.13.1", "matchCriteriaId": "D5627372-47E1-4E48-BEF7-4F9A418BAB45"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:apache:pluto:*:*:*:*:*:*:*:*", "versionEndExcluding": "3.1.1", "matchCriteriaId": "0711079D-E43A-440A-A38F-2ACE1676653E"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oracle:communications_cloud_native_core_policy:1.14.0:*:*:*:*:*:*:*", "matchCriteriaId": "4479F76A-4B67-41CC-98C7-C76B81050F8E"}]}]}], "references": [{"url": "https://github.com/junit-team/junit4/blob/7852b90cfe1cea1e0cdaa19d490c83f0d8684b50/doc/ReleaseNotes4.13.1.md", "source": "security-advisories@github.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/junit-team/junit4/commit/610155b8c22138329f0723eec22521627dbc52ae", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/junit-team/junit4/issues/1676", "source": "security-advisories@github.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/junit-team/junit4/security/advisories/GHSA-269g-pwp5-87pp", "source": "security-advisories@github.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://junit.org/junit4/javadoc/4.13/org/junit/rules/TemporaryFolder.html", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://lists.apache.org/thread.html/r01110833b63616ddbef59ae4e10c0fbd0060f0a51206defd4cb4d917@%3Ccommits.pulsar.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r09cfbb5aedd76023691bbce9ca4ce2e16bb07dd37554a17efc19935d@%3Cpluto-dev.portals.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r1209986f79359b518d09513ff05a88e5b3c398540e775edea76a4774@%3Cdev.knox.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r29d703d1986d9b871466ff24082a1828ac8ad27bb0965a93a383872e@%3Cpluto-scm.portals.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r2b78f23bc2711a76a7fc73ad67b7fcd6817c5cfccefd6f30a4f54943@%3Cdev.knox.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r30f502d2f79e8d635361adb8108dcbb73095163fcbd776ee7984a094@%3Ccommits.creadur.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r500517c23200fb2fdb0b82770a62dd6c88b3521cfb01cfd0c76e3f8b@%3Cdev.creadur.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r5f8841507576f595bb783ccec6a7cb285ea90d4e6f5043eae0e61a41@%3Cdev.creadur.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r687f489b10b0d14e46f626aa88476545e1a2600b24c4ebd3c0d2a10b@%3Cdev.knox.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r717877028482c55acf604d7a0106af4ca05da4208c708fb157b53672@%3Ccommits.creadur.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r742b44fd75215fc75963b8ecc22b2e4372e68d67d3d859d2b5e8743f@%3Cdev.knox.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r8b02dc6f18df11ff39eedb3038f1e31e6f90a779b1959bae65107279@%3Cdev.knox.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r925eaae7dd8f77dd61eefc49c1fcf54bd9ecfe605486870d7b1e9390@%3Cpluto-dev.portals.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r934208a520b38f5cf0cae199b6b076bfe7d081809528b0eff2459e40@%3Cdev.knox.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r95f8ef60c4b3a5284b647bb3132cda08e6fadad888a66b84f49da0b0@%3Ccommits.creadur.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/r9710067c7096b83cb6ae8f53a2f6f94e9c042d1bf1d6929f8f2a2b7a@%3Ccommits.knox.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/ra1bdb9efae84794e8ffa2f8474be8290ba57830eefe9714b95da714b@%3Cdev.pdfbox.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/raebf13f53cd5d23d990712e3d11c80da9a7bae94a6284050f148ed99@%3Ccommits.pulsar.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rb2771949c676ca984e58a5cd5ca79c2634dee1945e0406e48e0f8457@%3Cdev.creadur.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rb2ffe2993f4dccc48d832e1a0f1c419477781b6ea16e725ca2276dbb@%3Cdev.knox.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rb33212dab7beccaf1ffef9b88610047c644f644c7a0ebdc44d77e381@%3Ccommits.turbine.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rbaec90e699bc7c7bd9a053f76707a36fda48b6d558f31dc79147dbf9@%3Cdev.creadur.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rc49cf1547ef6cac1be4b3c92339b2cae0acacf5acaba13cfa429a872@%3Cdev.creadur.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rdbdd30510a7c4d0908fd22075c02b75bbc2e0d977ec22249ef3133cb@%3Ccommits.pulsar.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rde385b8b53ed046600ef68dd6b4528dea7566aaddb02c3e702cc28bc@%3Ccommits.creadur.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rde8e70b95c992378e8570e4df400c6008a9839eabdfb8f800a3e5af6@%3Ccommits.pulsar.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rdef7d1380c86e7c0edf8a0f89a2a8db86fce5e363457d56b722691b4@%3Ccommits.pulsar.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rea812d8612fdc46842a2a57248cad4b01ddfdb1e9b037c49e68fdbfb@%3Ccommits.pulsar.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/reb700e60b9642eafa4b7922bfee80796394135aa09c7a239ef9f7486@%3Ccommits.pulsar.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rf2ec93f4ca9a97d1958eb4a31b1830f723419ce9bf2018a6e5741d5b@%3Ccommits.pulsar.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Patch", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rf6e5d894d4b03bef537c9d6641272e0197c047c0d1982b4e176d0353@%3Cdev.knox.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.apache.org/thread.html/rf797d119cc3f51a8d7c3c5cbe50cb4524c8487282b986edde83a9467@%3Ccommits.pulsar.apache.org%3E", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/11/msg00003.html", "source": "security-advisories@github.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://www.oracle.com/security-alerts/cpuapr2022.html", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/junit-team/junit4/commit/610155b8c22138329f0723eec22521627dbc52ae"}}