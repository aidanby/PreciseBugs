{"buggy_code": ["import { Meteor } from \"meteor/meteor\";\nimport nodemailer from \"nodemailer\";\nimport smtpPool from \"nodemailer-smtp-pool\";\n\nconst Future = Npm.require(\"fibers/future\");\n\nconst getSmtpConfig = function () {\n  const config = Settings.findOne({ _id: \"smtpConfig\" });\n  return config && config.value;\n};\n\nconst makePool = function (mailConfig) {\n  if (!mailConfig.hostname) {\n    throw new Error(\"This Sandstorm server has not been configured to send email.\");\n  }\n\n  let auth = false;\n  if (mailConfig.auth && (mailConfig.auth.user || mailConfig.auth.pass)) {\n    auth = mailConfig.auth;\n  }\n\n  const secure = (mailConfig.port === 465);\n  const tlsOptions = {\n    // Previously, node 0.10 did not attempt to validate certificates received when connecting\n    // with STARTTLS, so to avoid regressing we need to preserve that behavior here for now.\n    rejectUnauthorized: false,\n  };\n\n  const pool = nodemailer.createTransport(smtpPool({\n    host: mailConfig.hostname,\n    port: mailConfig.port,\n    secure,\n    tls: tlsOptions,\n    auth,\n    // TODO(someday): allow maxConnections to be configured?\n  }));\n\n  pool._futureWrappedSendMail = _.bind(Future.wrap(pool.sendMail), pool);\n  return pool;\n};\n\n// We construct the SMTP pool at the first call to Email.send, so that\n// other code like migrations can modify the SMTP configuration.\nlet pool;\nlet configured = false;\n\nMeteor.startup(function () {\n  Settings.find({ _id: \"smtpConfig\" }).observeChanges({\n    removed: function () {\n      configured = false;\n    },\n\n    changed: function () {\n      configured = false;\n    },\n\n    added: function () {\n      configured = false;\n    },\n  });\n});\n\nconst getPool = function (smtpConfig) {\n  if (smtpConfig) {\n    return makePool(smtpConfig);\n  } else if (!configured) {\n    configured = true;\n    const config = getSmtpConfig();\n    if (config) {\n      pool = makePool(config);\n    }\n  }\n\n  return pool;\n};\n\nconst smtpSend = function (pool, mailOptions) {\n  pool._futureWrappedSendMail(mailOptions).wait();\n};\n\nconst rawSend = function (mailOptions, smtpConfig) {\n  // Sends an email mailOptions object structured as described in\n  // https://github.com/nodemailer/mailcomposer#e-mail-message-fields\n  // across the transport described by smtpConfig.\n  const pool = getPool(smtpConfig);\n  if (pool) {\n    smtpSend(pool, mailOptions);\n  } else {\n    throw new Error(\"SMTP pool is misconfigured.\");\n  }\n};\n\n// Old comment below\n/**\n * Send an email.\n *\n * Connects to the mail server configured via the MAIL_URL environment\n * variable. If unset, prints formatted message to stdout. The \"from\" option\n * is required, and at least one of \"to\", \"cc\", and \"bcc\" must be provided;\n * all other options are optional.\n *\n * @param options\n * @param options.from {String} RFC5322 \"From:\" address\n * @param options.to {String|String[]} RFC5322 \"To:\" address[es]\n * @param options.cc {String|String[]} RFC5322 \"Cc:\" address[es]\n * @param options.bcc {String|String[]} RFC5322 \"Bcc:\" address[es]\n * @param options.replyTo {String|String[]} RFC5322 \"Reply-To:\" address[es]\n * @param options.subject {String} RFC5322 \"Subject:\" line\n * @param options.text {String} RFC5322 mail body (plain text)\n * @param options.html {String} RFC5322 mail body (HTML)\n * @param options.headers {Object} custom RFC5322 headers (dictionary)\n */\n\n// New API doc comment below\n/**\n * @summary Send an email. Throws an `Error` on failure to contact mail server\n * or if mail server returns an error. All fields should match\n * [RFC5322](http://tools.ietf.org/html/rfc5322) specification.\n * @locus Server\n * @param {Object} options\n * @param {String} options.from \"From:\" address (required)\n * @param {String|String[]} options.to,cc,bcc,replyTo\n *   \"To:\", \"Cc:\", \"Bcc:\", and \"Reply-To:\" addresses\n * @param {String} [options.subject]  \"Subject:\" line\n * @param {String} [options.text|html] Mail body (in plain text or HTML)\n * @param {Object} [options.headers] Dictionary of custom headers\n * @param {Object} [options.smtpConfig] SMTP server to use. Otherwise defaults to configured one.\n * @param {String} [options.smtpConfig.hostname] SMTP server hostname.\n * @param {Number} [options.smtpConfig.port] SMTP server port.\n * @param {Object} [options.smtpConfig.auth] SMTP server authentication tokens.  Optional.\n * @param {String} [options.smtpConfig.auth.user] Username of user to log in to SMTP server as.  Optional.\n * @param {String} [options.smtpConfig.auth.pass] Password of user to log in to SMTP server as.  Optional.\n * @param {Object} [options.attachments] Attachments. See:\n *   https://github.com/nodemailer/mailcomposer/tree/v0.1.15#add-attachments\n * @param {String} [options.envelopeFrom] Envelope sender.\n */\nconst send = function (options) {\n  // Unpack options\n  const {\n    from,\n    to,\n    cc,\n    bcc,\n    replyTo,\n    subject,\n    text,\n    html,\n    envelopeFrom,\n    headers,\n    attachments,\n    smtpConfig,\n  } = options;\n\n  const opts = {\n    from,\n    to,\n    cc,\n    bcc,\n    replyTo,\n    subject,\n    text,\n    html,\n    headers,\n    attachments,\n  };\n\n  if (envelopeFrom) {\n    opts.envelope = {\n      from: envelopeFrom,\n      to,\n      cc,\n      bcc,\n    };\n  }\n\n  rawSend(opts, smtpConfig);\n};\n\nexport { send, rawSend };\n\n// TODO(cleanup): Remove this once BlackrockPayments code finds a better way to import it.\nglobal.SandstormEmail = { send };\n", "// Sandstorm - Personal Cloud Sandbox\n// Copyright (c) 2014 Sandstorm Development Group, Inc. and contributors\n// All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// This file defines the database schema.\n\n// Useful for debugging: Set the env variable LOG_MONGO_QUERIES to have the server write every\n// query it makes, so you can see if it's doing queries too often, etc.\nif (Meteor.isServer && process.env.LOG_MONGO_QUERIES) {\n  const oldFind = Mongo.Collection.prototype.find;\n  Mongo.Collection.prototype.find = function () {\n    console.log(this._prefix, arguments);\n    return oldFind.apply(this, arguments);\n  };\n}\n\n// Helper so that we don't have to if (Meteor.isServer) before declaring indexes.\nif (Meteor.isServer) {\n  Mongo.Collection.prototype.ensureIndexOnServer = Mongo.Collection.prototype._ensureIndex;\n} else {\n  Mongo.Collection.prototype.ensureIndexOnServer = function () {};\n}\n\n// TODO(soon): Systematically go through this file and add ensureIndexOnServer() as needed.\n\nconst collectionOptions = { defineMutationMethods: Meteor.isClient };\n// Set to `true` on the client so that method simulation works. Set to `false` on the server\n// so that we can be extra certain that all mutations must go through methods.\n\n// Users = new Mongo.Collection(\"users\");\n// The users collection is special and can be accessed through `Meteor.users`.\n// See https://docs.meteor.com/#/full/meteor_users.\n//\n// There are two distinct types of entries in the users collection: identities and accounts. An\n// identity contains personal profile information and typically includes some intrinsic method for\n// authenticating as the owner of that information.\n//\n// An account is an owner of app actions, grains, contacts, notifications, and payment info.\n// Each account can have multiple identities linked to it. To log in as an account you must first\n// authenticate as one of its linked identities.\n//\n// Every user contains the following fields:\n//   _id: Unique string ID. For accounts, this is random. For identities, this is the globally\n//        stable SHA-256 ID of this identity, hex-encoded.\n//   createdAt: Date when this entry was added to the collection.\n//   lastActive: Date of the user's most recent interaction with this Sandstorm server.\n//   services: Object containing login data used by Meteor authentication services.\n//   expires: Date when this user should be deleted. Only present for demo users.\n//   upgradedFromDemo: If present, the date when this user was upgraded from being a demo user.\n//                     TODO(cleanup): Unlike other dates in our database, this is stored as a number\n//                     rather than as a Date object. We should fix that.\n//   appDemoId: If present and non-null, then the user is a demo user who arrived via an /appdemo/\n//              link. This field contains the app ID of the app that the user started out demoing.\n//              Unlike the `expires` field, this field is not cleared when the user upgrades from\n//              being a demo user.\n//   suspended: If this exists, this account/identity is supsended. Both accounts and identities\n//              can be suspended. After some amount of time, the user will be completely deleted\n//              and removed from the DB.\n//              It is an object with fields:\n//                voluntary: Boolean. This is true if the user initiated it. They will have the\n//                  chance to still login and reverse the suspension/deletion.\n//                admin: The userId of the admin who suspended the account.\n//                timestamp: Date object. When the suspension occurred.\n//                willDelete: Boolean. If true, this account will be deleted after some time.\n//\n// Identity users additionally contain the following fields:\n//   profile: Object containing the data that will be shared with users and grains that come into\n//            contact with this identity. Includes the following fields:\n//       service: String containing the name of this identity's authentication method.\n//       name: String containing the chosen display name of the identity.\n//       handle: String containing the identity's preferred handle.\n//       picture: _id into the StaticAssets table for the identity's picture. If not present,\n//                an identicon will be used.\n//       pronoun: One of \"male\", \"female\", \"neutral\", or \"robot\".\n//   unverifiedEmail: If present, a string containing an email address specified by the user.\n//   referredBy: ID of the Account that referred this Identity.\n//\n// Account users additionally contain the following fields:\n//   loginIdentities: Array of identity objects, each of which may include the following fields.\n//       id: The globally-stable SHA-256 ID of this identity, hex-encoded.\n//   nonloginIdentities: Array of identity objects, of the same form as `loginIdentities`. We use\n//                       a separate array here so that we can use a Mongo index to enforce the\n//                       invariant that an identity only be a login identity for a single account.\n//   primaryEmail: String containing this account's primary email address. Must be a verified adress\n//                 of one of this account's linked identities. Call SandstormDb.getUserEmails()\n//                 to do this checking automatically.\n//   isAdmin: Boolean indicating whether this account is allowed to access the Sandstorm admin panel.\n//   signupKey: If this is an invited user, then this field contains their signup key.\n//   signupNote: If the user was invited through a link, then this field contains the note that the\n//               inviter admin attached to the key.\n//   signupEmail: If the user was invited by email, then this field contains the email address that\n//                the invite was sent to.\n//   hasCompletedSignup: True if this account has confirmed its profile and agreed to this server's\n//                       terms of service.\n//   plan: _id of an entry in the Plans table which determines the user's quota.\n//   planBonus: {storage, compute, grains} bonus amounts to add to the user's plan. The payments\n//              module writes data here; we merely read it. Missing fields should be treated as\n//              zeroes. Does not yet include referral bonus, which is calculated separately.\n//              TODO(cleanup): Use for referral bonus too.\n//   storageUsage: Number of bytes this user is currently storing.\n//   payments: Object defined by payments module, if loaded.\n//   dailySentMailCount: Number of emails sent by this user today; used to limit spam.\n//   accessRequests: Object containing the following fields; used to limit spam.\n//       count: Number of \"request access\" emails during sent during the current interval.\n//       resetOn: Date when the count should be reset.\n//   referredByComplete: ID of the Account that referred this Account. If this is set, we\n//                        stop writing new referredBy values onto Identities for this account.\n//   referredCompleteDate: The Date at which the completed referral occurred.\n//   referredIdentityIds: List of Identity IDs that this Account has referred. This is used for\n//                        reliably determining which Identity's names are safe to display.\n//   experiments: Object where each field is an experiment that the user is in, and each value\n//           is the parameters for that experiment. Typically, the value simply names which\n//           experiment group which the user is in, where \"control\" is one group. If an experiment\n//           is not listed, then the user should not be considered at all for the purpose of that\n//           experiment. Each experiment may define a point in time where users not already in the\n//           experiment may be added to it and assigned to a group (for example, at user creation\n//           time). Current experiments:\n//       firstTimeBillingPrompt: Value is \"control\" or \"test\". Users are assigned to groups at\n//               account creation on servers where billing is enabled (i.e. Oasis). Users in the\n//               test group will see a plan selection dialog and asked to make an explitic choice\n//               (possibly \"free\") before they can create grains (but not when opening someone\n//               else's shared grain). The goal of the experiment is to determine whether this\n//               prompt scares users away -- and also whether it increases paid signups.\n//       freeGrainLimit: Value is \"control\" or or a number indicating the grain limit that the\n//               user should receive when on the \"free\" plan, e.g. \"Infinity\".\n//   stashedOldUser: A complete copy of this user from before the accounts/identities migration.\n//                   TODO(cleanup): Delete this field once we're sure it's safe to do so.\n\nMeteor.users.ensureIndexOnServer(\"services.google.email\", { sparse: 1 });\nMeteor.users.ensureIndexOnServer(\"services.github.emails.email\", { sparse: 1 });\nMeteor.users.ensureIndexOnServer(\"services.email.email\", { unique: 1, sparse: 1 });\nMeteor.users.ensureIndexOnServer(\"loginIdentities.id\", { unique: 1, sparse: 1 });\nMeteor.users.ensureIndexOnServer(\"nonloginIdentities.id\", { sparse: 1 });\nMeteor.users.ensureIndexOnServer(\"services.google.id\", { unique: 1, sparse: 1 });\nMeteor.users.ensureIndexOnServer(\"services.github.id\", { unique: 1, sparse: 1 });\nMeteor.users.ensureIndexOnServer(\"suspended.willDelete\", { sparse: 1 });\n\n// TODO(cleanup): This index is obsolete; delete it.\nMeteor.users.ensureIndexOnServer(\"identities.id\", { unique: 1, sparse: 1 });\n\nPackages = new Mongo.Collection(\"packages\", collectionOptions);\n// Packages which are installed or downloading.\n//\n// Each contains:\n//   _id:  128-bit prefix of SHA-256 hash of spk file, hex-encoded.\n//   status:  String.  One of \"download\", \"verify\", \"unpack\", \"analyze\", \"ready\", \"failed\", \"delete\"\n//   progress:  Float.  -1 = N/A, 0-1 = fractional progress (e.g. download percentage),\n//       >1 = download byte count.\n//   error:  If status is \"failed\", error message string.\n//   manifest:  If status is \"ready\", the package manifest.  See \"Manifest\" in package.capnp.\n//   appId:  If status is \"ready\", the application ID string.  Packages representing different\n//       versions of the same app have the same appId.  The spk tool defines the app ID format\n//       and can cryptographically verify that a package belongs to a particular app ID.\n//   shouldCleanup:  If true, a reference to this package was recently dropped, and the package\n//       collector should at some point check whether there are any other references and, if not,\n//       delete the package.\n//   url:  When status is \"download\", the URL from which the SPK can be obtained, if provided.\n//   isAutoUpdated: This package was downloaded as part of an auto-update. We shouldn't clean it up\n//     even if it has no users.\n//   authorPgpKeyFingerprint: Verified PGP key fingerprint (SHA-1, hex, all-caps) of the app\n//     packager.\n\nDevPackages = new Mongo.Collection(\"devpackages\", collectionOptions);\n// List of packages currently made available via the dev tools running on the local machine.\n// This is normally empty; the only time it is non-empty is when a developer is using the spk tool\n// on the local machine to publish an under-development app to this server. That should only ever\n// happen on developers' desktop machines.\n//\n// While a dev package is published, it automatically appears as installed by every user of the\n// server, and it overrides all packages with the same application ID. If any instances of those\n// packages are currently open, they are killed and reset on publish.\n//\n// When the dev tool disconnects, the package is automatically unpublished, and any open instances\n// are again killed and refreshed.\n//\n// Each contains:\n//   _id:  The package ID string (as with Packages._id).\n//   appId: The app ID this package is intended to override (as with Packages.appId).\n//   timestamp:  Time when the package was last updated. If this changes while the package is\n//     published, all running instances are reset. This is used e.g. to reset the app each time\n//     changes are made to the source code.\n//   manifest:  The app's manifest, as with Packages.manifest.\n//   mountProc: True if the supervisor should mount /proc.\n\nUserActions = new Mongo.Collection(\"userActions\", collectionOptions);\n// List of actions that each user has installed which create new grains.  Each app may install\n// some number of actions (usually, one).\n//\n// Each contains:\n//   _id:  random\n//   userId:  Account ID of the user who has installed this action.\n//   packageId:  Package used to run this action.\n//   appId:  Same as Packages.findOne(packageId).appId; denormalized for searchability.\n//   appTitle:  Same as Packages.findOne(packageId).manifest.appTitle; denormalized so\n//       that clients can access it without subscribing to the Packages collection.\n//   appVersion:  Same as Packages.findOne(packageId).manifest.appVersion; denormalized for\n//       searchability.\n//   appMarketingVersion:  Human-readable presentation of the app version, e.g. \"2.9.17\"\n//   title: JSON-encoded LocalizedText title for this action, e.g.\n//       `{defaultText: \"New Spreadsheet\"}`.\n//   nounPhrase: JSON-encoded LocalizedText describing what is created when this action is run.\n//   command:  Manifest.Command to run this action (see package.capnp).\n\nGrains = new Mongo.Collection(\"grains\", collectionOptions);\n// Grains belonging to users.\n//\n// Each contains:\n//   _id:  random\n//   packageId:  _id of the package of which this grain is an instance.\n//   packageSalt: If present, a random string that will used in session ID generation. This field\n//       is usually updated when `packageId` is updated, triggering automatic refreshes for\n//       clients with active sessions.\n//   appId:  Same as Packages.findOne(packageId).appId; denormalized for searchability.\n//   appVersion:  Same as Packages.findOne(packageId).manifest.appVersion; denormalized for\n//       searchability.\n//   userId: The _id of the account that owns this grain.\n//   identityId: The identity with which the owning account prefers to open this grain.\n//   title:  Human-readable string title, as chosen by the user.\n//   lastUsed:  Date when the grain was last used by a user.\n//   private: If true, then knowledge of `_id` does not suffice to open this grain.\n//   cachedViewInfo: The JSON-encoded result of `UiView.getViewInfo()`, cached from the most recent\n//                   time a session to this grain was opened.\n//   trashed: If present, the Date when this grain was moved to the trash bin. Thirty days after\n//            this date, the grain will be automatically deleted.\n//   suspended: If true, the owner of this grain has been suspended. They will soon be deleted,\n//              so treat this grain the same as \"trashed\". It is denormalized out of Users for ease\n//              of querying.\n//   ownerSeenAllActivity: True if the owner has viewed the grain since the last activity event\n//       occurred. See also ApiTokenOwner.user.seenAllActivity.\n//   size: On-disk size of the grain in bytes.\n//\n// The following fields *might* also exist. These are temporary hacks used to implement e-mail and\n// web publishing functionality without powerbox support; they will be replaced once the powerbox\n// is implemented.\n//   publicId:  An id used to publicly identify this grain. Used e.g. to route incoming e-mail and\n//       web publishing. This field is initialized when first requested by the app.\n\nGrains.ensureIndexOnServer(\"cachedViewInfo.matchRequests.tags.id\", { sparse: 1 });\n\nRoleAssignments = new Mongo.Collection(\"roleAssignments\", collectionOptions);\n// *OBSOLETE* Before `user` was a variant of ApiTokenOwner, this collection was used to store edges\n// in the permissions sharing graph. This functionality has been subsumed by the ApiTokens\n// collection.\n\nContacts = new Mongo.Collection(\"contacts\", collectionOptions);\n// Edges in the social graph.\n//\n// If Alice has Bob as a contact, then she is allowed to see Bob's profile information and Bob\n// will show up in her user-picker UI for actions like share-by-identity.\n//\n// Contacts are not symmetric. Bob might be one of Alice's contacts even if Alice is not one of\n// Bob's.\n//\n// Each contains:\n//   _id: random\n//   ownerId: The accountId of the user account who owns this contact.\n//   petname: Human-readable label chosen by and only visible to the owner. Uniquely identifies\n//            the contact to the owner.\n//   created: Date when this contact was created.\n//   identityId: The `_id` of the user whose contact info this contains.\n\nSessions = new Mongo.Collection(\"sessions\", collectionOptions);\n// UI sessions open to particular grains.  A new session is created each time a user opens a grain.\n//\n// Each contains:\n//   _id:  String generated as a SHA256 hash of the grain ID, the user ID, a salt generated by the\n//       client, and the grain's `packageSalt`.\n//   grainId:  _id of the grain to which this session is connected.\n//   hostId: ID part of the hostname from which this grain is being served. I.e. this replaces the\n//       '*' in WILDCARD_HOST.\n//   tabId: Random value unique to the grain tab in which this session is displayed. Typically\n//       every session has a different `tabId`, but embedded sessions (including in the powerbox)\n//       have the same `tabId` as the outer session.\n//   timestamp:  Time of last keep-alive message to this session.  Sessions time out after some\n//       period.\n//   userId:  Account ID of the user who owns this session.\n//   identityId:  Identity ID of the user who owns this session.\n//   hashedToken: If the session is owned by an anonymous user, the _id of the entry in ApiTokens\n//       that was used to open it. Note that for old-style sharing (i.e. when !grain.private),\n//       anonymous users can get access without an API token and so neither userId nor hashedToken\n//       are present.\n//   powerboxView: Information about a server-initiated powerbox interaction taking place in this\n//       session. When the client sees a `powerboxView` appear on the session, it opens the\n//       powerbox popup according to the contents. This field is an object containing one of:\n//     offer: A capability is being offered to the user by the app. This is an object containing:\n//       token: For a non-UiView capability, the API token that can be used to restore this\n//           capability.\n//       uiView: A UiView capability. This object contains one of:\n//         tokenId: The _id of an ApiToken belonging to the current user.\n//         token: A full webkey token which can be opened by an anonymous user.\n//     fulfill: A capability is being offered which fulfills the active powerbox request. This\n//         is an object with members:\n//       token: The SturdyRef of the fulfilling capability. This token can only be used in a call\n//           to claimRequest() by the requesting\n//           grain.\n//       descriptor: Packed-base64 PowerboxDescriptor for the capability.\n//   powerboxRequest: If present, this session is a powerbox request session. Object containing:\n//     descriptors: Array of PowerboxDescriptors representing the request.\n//     requestingSession: Session ID of the session initiating the request.\n//   viewInfo: The UiView.ViewInfo corresponding to the underlying UiSession. This isn't populated\n//       until newSession is called on the UiView.\n//   permissions: The permissions for the current identity on this UiView. This isn't populated\n//       until newSession is called on the UiView.\n//   hasLoaded: Marked as true by the proxy when the underlying UiSession has responded to its first\n//       request\n\nSignupKeys = new Mongo.Collection(\"signupKeys\", collectionOptions);\n// Invite keys which may be used by users to get access to Sandstorm.\n//\n// Each contains:\n//   _id:  random\n//   used:  Boolean indicating whether this key has already been consumed.\n//   note:  Text note assigned when creating key, to keep track of e.g. whom the key was for.\n//   email: If this key was sent as an email invite, the email address to which it was sent.\n\nActivityStats = new Mongo.Collection(\"activityStats\", collectionOptions);\n// Contains usage statistics taken on a regular interval. Each entry is a data point.\n//\n// Each contains:\n//   timestamp: Date when measurements were taken.\n//   daily: Contains stats counts pertaining to the last day before the sample time.\n//   weekly: Contains stats counts pertaining to the last seven days before the sample time.\n//   monthly: Contains stats counts pertaining to the last thirty days before the timestamp.\n//\n// Each of daily, weekly, and monthly contains:\n//   activeUsers: The number of unique users who have used a grain on the server in the time\n//       interval. Only counts logged-in users.\n//   demoUsers: Demo users.\n//   appDemoUsers: Users that came in through \"app demo\".\n//   activeGrains: The number of unique grains that have been used in the time interval.\n//   apps: An object indexed by app ID recording, for each app:\n//       owners: Number of unique owners of this app (counting only grains that still exist).\n//       sharedUsers: Number of users who have accessed other people's grains of this app (counting\n//         only grains that still exist).\n//       grains: Number of active grains of this app (that still exist).\n//       deleted: Number of non-demo grains of this app that were deleted.\n//       demoed: Number of demo grains created and expired.\n//       appDemoUsers: Number of app demos initiated with this app.\n\nDeleteStats = new Mongo.Collection(\"deleteStats\", collectionOptions);\n// Contains records of objects that were deleted, for stat-keeping purposes.\n//\n// Each contains:\n//   type: \"grain\" or \"user\" or \"demoGrain\" or \"demoUser\" or \"appDemoUser\"\n//   lastActive: Date of the user's or grain's last activity.\n//   appId: For type = \"grain\", the app ID of the grain. For type = \"appDemoUser\", the app ID they\n//     arrived to demo. For others, undefined.\n//   experiments: The experiments the user (or owner of the grain) was in. See user.experiments.\n\nFileTokens = new Mongo.Collection(\"fileTokens\", collectionOptions);\n// Tokens corresponding to backup files that are currently stored on the server. A user receives\n// a token when they create a backup file (either by uploading it, or by backing up one of their\n// grains) and may use the token to read the file (either to download it, or to restore a new\n// grain from it).\n//\n// Each contains:\n//   _id:       The unguessable token string.\n//   name:      Suggested filename.\n//   timestamp: File creation time. Used to figure out when the token and file should be wiped.\n\nApiTokens = new Mongo.Collection(\"apiTokens\", collectionOptions);\n// Access tokens for APIs exported by apps.\n//\n// Originally API tokens were only used by external users through the HTTP API endpoint. However,\n// now they are also used to implement SturdyRefs, not just held by external users, but also when\n// an app holds a SturdyRef to another app within the same server. See the various `save()`,\n// `restore()`, and `drop()` methods in `grain.capnp` (on `SandstormApi`, `AppPersistent`, and\n// `MainView`) -- the fields of type `Data` are API tokens.\n//\n// Each contains:\n//   _id:       A SHA-256 hash of the token, base64-encoded.\n//   grainId:   The grain servicing this API. (Not present if the API isn't serviced by a grain.)\n//   identityId: For UiView capabilities, this is the identity for which the view is attenuated.\n//              That is, the UiView's newSession() method will intersect the requested permissions\n//              with this identity's permissions before forwarding on to the underlying app. If\n//              `identityId` is not present, then no identity attenuation is applied, i.e. this is\n//              a raw UiView as implemented by the app. (The `roleAssignment` field, below, may\n//              still apply. For non-UiView capabilities, `identityId` is never present. Note that\n//              this is NOT the identity against which the `requiredPermissions` parameter of\n//              `SandstormApi.restore()` is checked; that would be `owner.grain.introducerIdentity`.\n//   accountId: For tokens where `identityId` is set, the `_id` (in the Users table) of the account\n//              that created the token.\n//   roleAssignment: If this API token represents a UiView, this field contains a JSON-encoded\n//              Grain.ViewSharingLink.RoleAssignment representing the permissions it carries. These\n//              permissions will be intersected with those held by `identityId` when the view is\n//              opened.\n//   forSharing: If true, requests sent to the HTTP API endpoint with this token will be treated as\n//              anonymous rather than as directly associated with `identityId`. This has no effect\n//              on the permissions granted.\n//   objectId:  If present, this token represents an arbitrary Cap'n Proto capability exported by\n//              the app or its supervisor (whereas without this it strictly represents UiView).\n//              sturdyRef is the JSON-encoded SupervisorObjectId (defined in `supervisor.capnp`).\n//              Note that if the SupervisorObjectId contains an AppObjectId, that field is\n//              treated as type AnyPointer, and so encoded as a raw Cap'n Proto message.\n//   frontendRef: If present, this token actually refers to an object implemented by the front-end,\n//              not a particular grain. (`grainId` and `identityId` are not set.) This is an object\n//              containing exactly one of the following fields:\n//       notificationHandle: A `Handle` for an ongoing notification, as returned by\n//                           `NotificationTarget.addOngoing`. The value is an `_id` from the\n//                           `Notifications` collection.\n//       ipNetwork: An IpNetwork capability that is implemented by the frontend. Eventually, this\n//                  will be moved out of the frontend and into the backend, but we'll migrate the\n//                  database when that happens. This field contains the boolean true to signify that\n//                  it has been set.\n//       ipInterface: Ditto IpNetwork, except it's an IpInterface.\n//       emailVerifier: An EmailVerifier capability that is implemented by the frontend. The\n//                      value is an object containing the fields `id` and `services`. `id` is the\n//                      value returned by `EmailVerifier.getId()` and is used as part of a\n//                      powerbox query for matching verified emails. `services` is a\n//                      list of names of identity providers that are trusted to verify addresses.\n//                      If `services` is omitted or falsy, all configured identity providers are\n//                      trusted. Note that a malicious user could specify invalid names in the\n//                      list; they should be ignored.\n//       verifiedEmail: An VerifiedEmail capability that is implemented by the frontend.\n//                      An object containing `verifierId`, `tabId`, and `address`.\n//       identity: An Identity capability. The field is the identity ID.\n//       http: An ApiSession capability pointing to an external HTTP service. Object containing:\n//           url: Base URL of the external service.\n//           auth: Authentication mechanism. Object containing one of:\n//               none: Value \"null\". Indicates no authorization.\n//               bearer: A bearer token to pass in the `Authorization: Bearer` header on all\n//                   requests. Encrypted with nonce 0.\n//               basic: A `{username, password}` object. The password is encrypted with nonce 0.\n//                   Before encryption, the password is padded to 32 bytes by appending NUL bytes,\n//                   in order to mask the length of small passwords.\n//               refresh: An OAuth refresh token, which can be exchanged for an access token.\n//                   Encrypted with nonce 0.\n//               TODO(security): How do we protect URLs that directly embed their secret? We don't\n//                   want to encrypt the full URL since this would make it hard to show a\n//                   meaningful audit UI, but maybe we could figure out a way to extract the key\n//                   part and encrypt it separately?\n//   parentToken: If present, then this token represents exactly the capability represented by\n//              the ApiToken with _id = parentToken, except possibly (if it is a UiView) attenuated\n//              by `roleAssignment` (if present). To facilitate permissions computations, if the\n//              capability is a UiView, then `grainId` is set to the backing grain, `identityId`\n//              is set to the identity that shared the view, and `accountId` is set to the account\n//              that shared the view. Neither `objectId` nor `frontendRef` is present when\n//              `parentToken` is present.\n//   parentTokenKey: The actual parent token -- whereas `parentToken` is only the parent token ID\n//              (hash). `parentTokenFull` is encrypted with nonce 0 (see below). This is needed\n//              in particular when the parent contains encrypted fields, since those would need to\n//              be decrypted using this key. If the parent contains no encrypted fields then\n//              `parentTokenKey` may be omitted from the child.\n//   petname:   Human-readable label for this access token, useful for identifying tokens for\n//              revocation. This should be displayed when visualizing incoming capabilities to\n//              the grain identified by `grainId`.\n//   created:   Date when this token was created.\n//   revoked:   If true, then this sturdyref has been revoked and can no longer be restored. It may\n//              become un-revoked in the future.\n//   trashed:   If present, the Date when this token was moved to the trash bin. Thirty days after\n//              this date, the token will be automatically deleted.\n//   suspended: If true, the owner of this token has been suspended. They will soon be deleted,\n//              so treat this token the same as \"trashed\". It is denormalized out of Users for\n//              ease of querying.\n//   expires:   Optional expiration Date. If undefined, the token does not expire.\n//   lastUsed:  Optional Date when this token was last used.\n//   owner:     A `ApiTokenOwner` (defined in `supervisor.capnp`, stored as a JSON object)\n//              as passed to the `save()` call that created this token. If not present, treat\n//              as `webkey` (the default for `ApiTokenOwner`).\n//   expiresIfUnused:\n//              Optional Date after which the token, if it has not been used yet, expires.\n//              This field should be cleared on a token's first use.\n//   requirements: List of conditions which must hold for this token to be considered valid.\n//              Semantically, this list specifies the powers which were *used* to originally\n//              create the token. If any condition in the list becomes untrue, then the token must\n//              be considered revoked, and all live refs and sturdy refs obtained transitively\n//              through it must also become revoked. Each item is the JSON serialization of the\n//              `MembraneRequirement` structure defined in `supervisor.capnp`.\n//   hasApiHost: If true, there is an entry in ApiHosts for this token, which will need to be\n//              cleaned up when the token is.\n//\n// It is important to note that a token's owner and provider are independent from each other. To\n// illustrate, here is an approximate definition of ApiToken in pseudo Cap'n Proto schema language:\n//\n// struct ApiToken {\n//   owner :ApiTokenOwner;\n//   provider :union {\n//     grain :group {\n//       grainId :Text;\n//       union {\n//         uiView :group {\n//           identityId :Text;\n//           roleAssignment :RoleAssignment;\n//           forSharing :Bool;\n//         }\n//         objectId :SupervisorObjectId;\n//       }\n//     }\n//     frontendRef :union {\n//       notificationHandle :Text;\n//       ipNetwork :Bool;\n//       ipInterface :Bool;\n//       emailVerifier :group {\n//         id :Text;\n//         services :List(String);\n//       }\n//       verifiedEmail :group {\n//         verifierId :Text;\n//         tabId :Text;\n//         address :Text;\n//       }\n//       identity :Text;\n//       http :group {\n//         url :Text;\n//         auth :union {\n//           none :Void;\n//           bearer :Text;\n//           basic :group { username :Text; password :Text; }\n//           refresh :Text;\n//         }\n//       }\n//     }\n//     child :group {\n//       parentToken :Text;\n//       union {\n//         uiView :group {\n//           grainId :Text;\n//           identityId :Text;\n//           roleAssignment :RoleAssignment = (allAccess = ());\n//         }\n//         other :Void;\n//       }\n//     }\n//   }\n//   requirements: List(Supervisor.MembraneRequirement);\n//   ...\n// }\n//\n// ENCRYPTION\n//\n// We want to make sure that someone who obtains a copy of the database cannot use it to gain live\n// credentials.\n//\n// The actual token corresponding to an ApiToken entry is not stored in the entry itself. Instead,\n// the ApiToken's `_id` is constructed as a SHA256 hash of the actual token. To use an ApiToken\n// in the live system, you must present the original token.\n//\n// Additionally, some ApiToken entries contain tokens to third-party services, e.g. OAuth tokens\n// or even passwords. Such tokens are encrypted, using the ApiToken entry's own full token (which,\n// again, is not stored in the database) as the encryption key.\n//\n// When such encryption is applied, the cipher used is ChaCha20. All API tokens are 256-bit base64\n// strings, hence can be used directly as the key. No MAC is applied, because this scheme is not\n// intended to protect against attackers who have write access to the database -- such an attacker\n// could almost certainly do more damage by modifying the non-encrypted fields anyway. (Put another\n// way, if we wanted to MAC something, we'd need to MAC the entire ApiToken structure, not just\n// the encrypted key. But we don't have a way to do that at present.)\n//\n// ChaCha20 requires a nonce. Luckily, all of the fields we wish to encrypt are immutable, so we\n// don't have to worry about tracking nonces over time -- we can just assign a static nonce to each\n// field. Moreover, many (currently, all) of these fields are mutually exclusive, so can even share\n// nonces. Currently, nonces map to fields as follows:\n//\n// nonce 0:\n//     parentTokenKey\n//     frontendRef.http.auth.basic.password\n//     frontendRef.http.auth.bearer\n//     frontendRef.http.auth.refresh\n\nApiTokens.ensureIndexOnServer(\"grainId\", { sparse: 1 });\nApiTokens.ensureIndexOnServer(\"owner.user.identityId\", { sparse: 1 });\nApiTokens.ensureIndexOnServer(\"frontendRef.emailVerifier.id\", { sparse: 1 });\n\nApiHosts = new Mongo.Collection(\"apiHosts\", collectionOptions);\n// Allows defining some limited static behavior for an API host when accessed unauthenticated. This\n// mainly exists to allow backwards-compatibility with client applications that expect to be able\n// to probe an API host without authentication to determine capabilities such as DAV protocols\n// supported, before authenticating to perform real requests. An app can specify these properties\n// when creating an offerTemplate.\n//\n// Each contains:\n//   _id:          apiHostIdHashForToken() of the corresponding API token.\n//   hash2:        hash(hash(token)), aka hash(ApiToken._id). Used to allow ApiHosts to be cleaned\n//                 up when ApiTokens are deleted.\n//   options:      Specifies how to respond to unauthenticated OPTIONS requests on this host.\n//                 This is an object containing fields:\n//     dav:        List of strings specifying DAV header `compliance-class`es, e.g. \"1\" or\n//                 \"calendar-access\". https://tools.ietf.org/html/rfc4918#section-10.1\n//   resources:    Object mapping URL paths (including initial '/') to static HTTP responses to\n//                 give when those paths are accessed unauthenticated. Due to Mongo disliking '.'\n//                 and '$' in keys, these characters must be escaped as '\\uFF0E' and '\\uFF04'\n//                 (see SandstormDb.escapeMongoKey). Each value in this map is an object with\n//                 fields:\n//     type:       Content-Type.\n//     language:   Content-Language.\n//     encoding:   Content-Encoding.\n//     body:       Entity-body as a string or buffer.\n\nNotifications = new Mongo.Collection(\"notifications\", collectionOptions);\n// Notifications for a user.\n//\n// Each contains:\n//   _id:          random\n//   grainId:      The grain originating this notification, if any.\n//   userId:       Account ID of the user receiving the notification.\n//   text:         The JSON-ified LocalizedText to display in the notification.\n//   isUnread:     Boolean indicating if this notification is unread.\n//   timestamp:    Date when this notification was last updated\n//   eventType:    If this notification is due to an activity event, this is the numeric index\n//                 of the event type on the grain's ViewInfo.\n//   count:        The number of times this exact event has repeated. Identical events are\n//                 aggregated by incrementing the count.\n//   initiatingIdentity: Identity ID of the user who initiated this notification.\n//   initiatorAnonymous: True if the initiator is an anonymous user. If neither this nor\n//                 initiatingIdentity is present, the notification is not from a user.\n//   path:         Path inside the grain to which the user should be directed if they click on\n//                 the notification.\n//   ongoing:      If present, this is an ongoing notification, and this field contains an\n//                 ApiToken referencing the `OngoingNotification` capability.\n//   admin:        If present, this is a notification intended for an admin.\n//     action:     If present, this is a (string) link that the notification should direct the\n//                 admin to.\n//     type:       The type of notification -- currently can only be \"reportStats\".\n//   appUpdates:   If present, this is an app update notification. It is an object with the appIds\n//                 as keys.\n//     $appId:     The appId that has an outstanding update.\n//       packageId: The packageId that it will update to.\n//       name: The name of the app. (appTitle from package.manifest)\n//       version: The app's version number. (appVersion from package.manifest)\n//       marketingVersion: String marketing version of this app. (appMarketingVersion from package.manifest)\n//   referral:     If this boolean field is true, then treat this notification as a referral\n//                 notification. This causes text to be ignored, since we need custom logic.\n//   mailingListBonus: Like `referral`, but notify the user about the mailing list bonus. This is\n//                 a one-time notification only to Oasis users who existed when the bonus program\n//                 was implemented.\n\nActivitySubscriptions = new Mongo.Collection(\"activitySubscriptions\", collectionOptions);\n// Activity events to which a user is subscribed.\n//\n// Each contains:\n//   _id:          random\n//   identityId:   Who is subscribed.\n//   grainId:      Grain to which subscription applies.\n//   threadPath:   If present, the subscription is on a specific thread. Otherwise, it is on the\n//                 whole grain.\n//   mute:         If true, this is an anti-subscription -- matching events should NOT notify.\n//                 This allows is useful to express:\n//                 - A user wants to subscribe to a grain but mute a specific thread.\n//                 - The owner of a grain does not want notifications (normally, they are\n//                   implicitly subscribed).\n//                 - A user no longer wishes to be implicitly subscribed to threads in a grain on\n//                   which they comment, so they mute the grain.\n\nActivitySubscriptions.ensureIndexOnServer(\"identityId\");\nActivitySubscriptions.ensureIndexOnServer({ \"grainId\": 1, \"threadPath\": 1 });\n\nStatsTokens = new Mongo.Collection(\"statsTokens\", collectionOptions);\n// Access tokens for the Stats collection\n//\n// These tokens are used for accessing the ActivityStats collection remotely\n// (ie. from a dashboard webapp)\n//\n// Each contains:\n//   _id:       The token. At least 128 bits entropy (Random.id(22)).\n\nMisc = new Mongo.Collection(\"misc\", collectionOptions);\n// Miscellaneous configuration and other settings\n//\n// This table is currently only used for persisting BASE_URL from one session to the next,\n// but in general any miscellaneous settings should go in here\n//\n// Each contains:\n//   _id:       The name of the setting. eg. \"BASE_URL\"\n//   value:     The value of the setting.\n\nSettings = new Mongo.Collection(\"settings\", collectionOptions);\n// Settings for this Sandstorm instance go here. They are configured through the adminSettings\n// route. This collection differs from misc in that any admin user can update it through the admin\n// interface.\n//\n// Each contains:\n//   _id:       The name of the setting. eg. \"smtpConfig\"\n//   value:     The value of the setting.\n//   automaticallyReset: Sometimes the server needs to automatically reset a setting. When it does\n//                       so, it will also write an object to this field indicating why the reset was\n//                       needed. That object can have the following variants:\n//       baseUrlChangedFrom: The reset was due to BASE_URL changing. This field contains a string\n//                           with the old BASE_URL.\n//   preinstalledApps: A list of objects:\n//     appId: The Packages.appId of the app to install\n//     status: packageId\n//     packageId: The Packages._id of the app to install\n//\n//   potentially other fields that are unique to the setting\n\nMigrations = new Mongo.Collection(\"migrations\", collectionOptions);\n// This table tracks which migrations we have applied to this instance.\n// It contains a single entry:\n//   _id:       \"migrations_applied\"\n//   value:     The number of migrations this instance has successfully completed.\n\nStaticAssets = new Mongo.Collection(\"staticAssets\", collectionOptions);\n// Collection of static assets served up from the Sandstorm server's \"static\" host. We only\n// support relatively small assets: under 1MB each.\n//\n// Each contains:\n//   _id:       Random ID; will be used in the URL.\n//   hash:      A base64-encoded SHA-256 hash of the data, used to de-dupe.\n//   mimeType:  MIME type of the asset, suitable for Content-Type header.\n//   encoding:  Either \"gzip\" or not present, suitable for Content-Encoding header.\n//   content:   The asset content (byte buffer).\n//   refcount:  Number of places where this asset's ID appears in the database. Since Mongo doesn't\n//       have transactions, this needs to bias towards over-counting; a backup GC could be used\n//       to catch leaked assets, although it's probably not a big deal in practice.\n\nAssetUploadTokens = new Mongo.Collection(\"assetUploadTokens\", collectionOptions);\n// Collection of tokens representing a single-use permission to upload an asset, such as a new\n// profile picture.\n//\n// Each contains:\n//   _id:       Random ID.\n//   purpose:   Contains one of the following, indicating how the asset is to be used:\n//       profilePicture: Indicates that the upload is a new profile picture. Contains fields:\n//           userId: Account ID of user whose picture shall be replaced.\n//           identityId: Which of the user's identities shall be updated.\n//   expires:   Time when this token will go away if unused.\n\nPlans = new Mongo.Collection(\"plans\", collectionOptions);\n// Subscription plans, which determine quota.\n//\n// Each contains:\n//   _id: Plan ID, usually a short string like \"free\", \"standard\", \"large\", \"mega\", ...\n//   storage: Number of bytes this user is allowed to store.\n//   compute: Number of kilobyte-RAM-seconds this user is allowed to consume.\n//   computeLabel: Label to display to the user describing this plan's compute units.\n//   grains: Total number of grains this user can create (often `Infinity`).\n//   price: Price per month in US cents.\n//   hidden: If true, a user cannot switch to this plan, but some users may be on it and are\n//       allowed to switch away.\n//   title: Title from display purposes. If missing, default to capitalizing _id.\n\nAppIndex = new Mongo.Collection(\"appIndex\", collectionOptions);\n// A mirror of the data from the App Market index\n//\n// Each contains:\n//   _id: the appId of the app\n//  The rest of the fields are defined in src/sandstorm/app-index/app-index.capnp:AppIndexForMarket\n\nKeybaseProfiles = new Mongo.Collection(\"keybaseProfiles\", collectionOptions);\n// Cache of Keybase profile information. The profile for a user is re-fetched every time a package\n// by that user is installed, as well as if the keybase profile is requested and not already\n// present for some reason.\n//\n// Each contains:\n//   _id: PGP key fingerprint (SHA-1, hex, all-caps)\n//   displayName: Display name from Keybase. (NOT VERIFIED AT ALL.)\n//   handle: Keybase handle.\n//   proofs: The \"proofs_summary.all\" array from the Keybase lookup. See the non-existent Keybase\n//     docs for details. We also add a boolean \"status\" field to each proof indicating whether\n//     we have directly verified the proof ourselves. Its values may be \"unverified\" (Keybase\n//     returned this but we haven't checked it directly), \"verified\" (we verified the proof and it\n//     is valid), \"invalid\" (we checked the proof and it was definitely bogus), or \"checking\" (the\n//     server is currently actively checking this proof). Note that if a check fails due to network\n//     errors, the status goes back to \"unverified\".\n//\n//     WARNING: Currently verification is NOT IMPLEMENTED, so all proofs will be \"unverified\"\n//       for now and we just trust Keybase.\n\nFeatureKey = new Mongo.Collection(\"featureKey\", collectionOptions);\n// OBSOLETE: This was used to implement the Sandstorm for Work paywall, which has been removed.\n//   Collection object still defined because it could have old data in it, for servers that used\n//   to have a feature key.\n\nSetupSession = new Mongo.Collection(\"setupSession\", collectionOptions);\n// Responsible for storing information about setup sessions.  Contains a single document with three\n// keys:\n//\n//   _id: \"current-session\"\n//   creationDate: Date object indicating when this session was created.\n//   hashedSessionId: the sha256 of the secret session id that was returned to the client\n\nconst DesktopNotifications = new Mongo.Collection(\"desktopNotifications\", collectionOptions);\n// Responsible for very short-lived queueing of desktop notification information.\n// Entries are removed when they are ~30 seconds old.  This collection is a bit\n// odd in that it is intended primarily for edge-triggered communications, but\n// Meteor's collections aren't really designed to support that organization.\n// Fields for each :\n//\n//   _id: String.  Used as the tag to coordinate notification merging between browser tabs.\n//   creationDate: Date object. indicating when this notification was posted.\n//   userId: String. Account id to which this notification was published.\n//   notificationId: String.  ID of the matching event in the Notifications table to dismiss if this\n//                            notification is activated.\n//   appActivity: Object with fields:\n//     user: Optional Object. Not present if this notification wasn't generated by a user. If\n//           present, it will have one of the following shapes:\n//       { anonymous: true } if this notification was generated by an anonymous user.  Otherwise:\n//       {\n//         identityId: String  The user's identity ID.\n//         name: String        The user's display name.\n//         avatarUrl: String   The URL for the user's profile picture.\n//       },\n//     grainId: String,      Which grain this action took place on\n//     path: String,         The path of the notification.\n//     body: Util.LocalizedText,  The main body of the activity event.\n//     actionText: Util.LocalizedText, What action the user took, e.g.\n//                                     { defaultText: \"added a comment\" }\n\nconst StandaloneDomains = new Mongo.Collection(\"standaloneDomains\", collectionOptions);\n// A standalone domain that points to a single share link. These domains act a little different\n// than a normal shared Sandstorm grain. They completely drop any Sandstorm topbar/sidebar, and at\n// first glance look completely like a non-Sandstorm hosted webserver. The apps instead act in\n// concert with Sandstorm through the postMessage API, which allows it to do things like prompt for\n// login.\n// Fields for each :\n//\n//   _id: String. The domain name to use.\n//   token: String. _id of a sharing token (it must be a webkey).\n\nif (Meteor.isServer) {\n  Meteor.publish(\"credentials\", function () {\n    // Data needed for isSignedUp() and isAdmin() to work.\n\n    if (this.userId) {\n      const db = this.connection.sandstormDb;\n      return [\n        Meteor.users.find({ _id: this.userId },\n            { fields: { signupKey: 1, isAdmin: 1, expires: 1, storageUsage: 1,\n                      plan: 1, planBonus: 1, hasCompletedSignup: 1, experiments: 1,\n                      referredIdentityIds: 1, cachedStorageQuota: 1, suspended: 1, }, }),\n        db.collections.plans.find(),\n      ];\n    } else {\n      return [];\n    }\n  });\n}\n\nconst countReferrals = function (user) {\n  const referredIdentityIds = user.referredIdentityIds;\n  return (referredIdentityIds && referredIdentityIds.length || 0);\n};\n\nconst calculateReferralBonus = function (user) {\n  // This function returns an object of the form:\n  //\n  // - {grains: 0, storage: 0}\n  //\n  // which are extra resources this account gets as part of participating in the referral\n  // program. (Storage is measured in bytes, as usual for plans.)\n\n  // TODO(cleanup): Consider moving referral bonus logic into Oasis payments module (since it's\n  //   payments-specific) and aggregating into `planBonus`.\n\n  // Authorization note: Only call this if accountId is the current user!\n  const isPaid = (user.plan && user.plan !== \"free\");\n\n  successfulReferralsCount = countReferrals(user);\n  if (isPaid) {\n    const maxPaidStorageBonus = 30 * 1e9;\n    return { grains: 0,\n            storage: Math.min(\n              successfulReferralsCount * 2 * 1e9,\n              maxPaidStorageBonus), };\n  } else {\n    const maxFreeStorageBonus = 2 * 1e9;\n    const bonus = {\n      storage: Math.min(\n        successfulReferralsCount * 50 * 1e6,\n        maxFreeStorageBonus),\n    };\n    if (successfulReferralsCount > 0) {\n      bonus.grains = Infinity;\n    } else {\n      bonus.grains = 0;\n    }\n\n    return bonus;\n  }\n};\n\nisAdmin = function () {\n  // Returns true if the user is the administrator.\n\n  const user = Meteor.user();\n  if (user && user.isAdmin) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nisAdminById = function (id) {\n  // Returns true if the user's id is the administrator.\n\n  const user = Meteor.users.findOne({ _id: id }, { fields: { isAdmin: 1 } });\n  if (user && user.isAdmin) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nfindAdminUserForToken = function (token) {\n  if (!token.requirements) {\n    return;\n  }\n\n  const requirements = token.requirements.filter(function (requirement) {\n    return \"userIsAdmin\" in requirement;\n  });\n\n  if (requirements.length > 1) {\n    return;\n  }\n\n  if (requirements.length === 0) {\n    return;\n  }\n\n  return requirements[0].userIsAdmin;\n};\n\nconst wildcardHost = Meteor.settings.public.wildcardHost.toLowerCase().split(\"*\");\n\nif (wildcardHost.length != 2) {\n  throw new Error(\"Wildcard host must contain exactly one asterisk.\");\n}\n\nmatchWildcardHost = function (host) {\n  // See if the hostname is a member of our wildcard. If so, extract the ID.\n\n  // We remove everything after the first \":\" character so that our\n  // comparison logic ignores port numbers.\n  const prefix = wildcardHost[0];\n  const suffix = wildcardHost[1].split(\":\")[0];\n  const hostSansPort = host.split(\":\")[0];\n\n  if (hostSansPort.lastIndexOf(prefix, 0) >= 0 &&\n      hostSansPort.indexOf(suffix, -suffix.length) >= 0 &&\n      hostSansPort.length >= prefix.length + suffix.length) {\n    const id = hostSansPort.slice(prefix.length, -suffix.length);\n    if (id.match(/^[-a-z0-9]*$/)) {\n      return id;\n    }\n  }\n\n  return null;\n};\n\nmakeWildcardHost = function (id) {\n  return wildcardHost[0] + id + wildcardHost[1];\n};\n\nconst isApiHostId = function (hostId) {\n  if (hostId) {\n    const split = hostId.split(\"-\");\n    if (split[0] === \"api\") return split[1] || \"*\";\n  }\n\n  return false;\n};\n\nconst isTokenSpecificHostId = function (hostId) {\n  return hostId.lastIndexOf(\"api-\", 0) === 0;\n};\n\nlet apiHostIdHashForToken;\nif (Meteor.isServer) {\n  const Crypto = Npm.require(\"crypto\");\n  apiHostIdHashForToken = function (token) {\n    // Given an API token, compute the host ID that must be used when requesting this token.\n\n    // We add a leading 'x' to the hash so that knowing the hostname alone is not sufficient to\n    // find the corresponding API token in the ApiTokens table (whose _id values are also hashes\n    // of tokens). This doesn't technically add any security, but helps prove that we don't have\n    // any bugs which would allow someone who knows only the hostname to access the app API.\n    return Crypto.createHash(\"sha256\").update(\"x\" + token).digest(\"hex\").slice(0, 32);\n  };\n} else {\n  apiHostIdHashForToken = function (token) {\n    // Given an API token, compute the host ID that must be used when requesting this token.\n\n    // We add a leading 'x' to the hash so that knowing the hostname alone is not sufficient to\n    // find the corresponding API token in the ApiTokens table (whose _id values are also hashes\n    // of tokens). This doesn't technically add any security, but helps prove that we don't have\n    // any bugs which would allow someone who knows only the hostname to access the app API.\n    return SHA256(\"x\" + token).slice(0, 32);\n  };\n}\n\nconst apiHostIdForToken = function (token) {\n  return \"api-\" + apiHostIdHashForToken(token);\n};\n\nconst makeApiHost = function (token) {\n  return makeWildcardHost(apiHostIdForToken(token));\n};\n\nif (Meteor.isServer) {\n  const Url = Npm.require(\"url\");\n  getWildcardOrigin = function () {\n    // The wildcard URL can be something like \"foo-*-bar.example.com\", but sometimes when we're\n    // trying to specify a pattern matching hostnames (say, a Content-Security-Policy directive),\n    // an astrisk is only allowed as the first character and must be followed by a period. So we need\n    // \"*.example.com\" instead -- which matches more than we actually want, but is the best we can\n    // really do. We also add the protocol to the front (again, that's what CSP wants).\n\n    // TODO(cleanup): `protocol` is computed in other files, like proxy.js. Put it somewhere common.\n    const protocol = Url.parse(process.env.ROOT_URL).protocol;\n\n    const dotPos = wildcardHost[1].indexOf(\".\");\n    if (dotPos < 0) {\n      return protocol + \"//*\";\n    } else {\n      return protocol + \"//*\" + wildcardHost[1].slice(dotPos);\n    }\n  };\n}\n\nSandstormDb = function (quotaManager) {\n  // quotaManager is an object with the following method:\n  //   updateUserQuota: It is provided two arguments\n  //     db: This SandstormDb object\n  //     user: A collections.users account object\n  //   and returns a quota object:\n  //     storage: A number (can be Infinity)\n  //     compute: A number (can be Infinity)\n  //     grains: A number (can be Infinity)\n\n  this.quotaManager = quotaManager;\n  this.collections = {\n    // Direct access to underlying collections. DEPRECATED, but better than accessing the top-level\n    // collection globals directly.\n    //\n    // TODO(cleanup): Over time, we will provide methods covering each supported query and remove\n    //   direct access to the collections.\n    users: Meteor.users,\n\n    packages: Packages,\n    devPackages: DevPackages,\n    userActions: UserActions,\n    grains: Grains,\n    roleAssignments: RoleAssignments, // Deprecated, only used by the migration that eliminated it.\n    contacts: Contacts,\n    sessions: Sessions,\n    signupKeys: SignupKeys,\n    activityStats: ActivityStats,\n    deleteStats: DeleteStats,\n    fileTokens: FileTokens,\n    apiTokens: ApiTokens,\n    apiHosts: ApiHosts,\n    notifications: Notifications,\n    activitySubscriptions: ActivitySubscriptions,\n    statsTokens: StatsTokens,\n    misc: Misc,\n    settings: Settings,\n    migrations: Migrations,\n    staticAssets: StaticAssets,\n    assetUploadTokens: AssetUploadTokens,\n    plans: Plans,\n    appIndex: AppIndex,\n    keybaseProfiles: KeybaseProfiles,\n    setupSession: SetupSession,\n    desktopNotifications: DesktopNotifications,\n    standaloneDomains: StandaloneDomains,\n  };\n};\n\n// TODO(cleanup): These methods should not be defined freestanding and should use collection\n//   objects created in SandstormDb's constructor rather than globals.\n\n_.extend(SandstormDb.prototype, {\n  isAdmin: isAdmin,\n  isAdminById: isAdminById,\n  findAdminUserForToken: findAdminUserForToken,\n  matchWildcardHost: matchWildcardHost,\n  makeWildcardHost: makeWildcardHost,\n  isApiHostId: isApiHostId,\n  isTokenSpecificHostId: isTokenSpecificHostId,\n  apiHostIdHashForToken: apiHostIdHashForToken,\n  apiHostIdForToken: apiHostIdForToken,\n  makeApiHost: makeApiHost,\n  allowDevAccounts() {\n    const setting = this.collections.settings.findOne({ _id: \"devAccounts\" });\n    if (setting) {\n      return setting.value;\n    } else {\n      return Meteor.settings && Meteor.settings.public &&\n             Meteor.settings.public.allowDevAccounts;\n    }\n  },\n\n  roleAssignmentPattern: {\n    none: Match.Optional(null),\n    allAccess: Match.Optional(null),\n    roleId: Match.Optional(Match.Integer),\n    addPermissions: Match.Optional([Boolean]),\n    removePermissions: Match.Optional([Boolean]),\n  },\n\n  isDemoUser() {\n    // Returns true if this is a demo user.\n\n    const user = Meteor.user();\n    if (user && user.expires) {\n      return true;\n    } else {\n      return false;\n    }\n  },\n\n  isSignedUp() {\n    const user = Meteor.user();\n    return this.isAccountSignedUp(user);\n  },\n\n  isAccountSignedUp(user) {\n    // Returns true if the user has presented an invite key.\n\n    if (!user) return false;  // not signed in\n\n    if (!user.loginIdentities) return false;  // not an account\n\n    if (user.expires) return false;  // demo user.\n\n    if (Meteor.settings.public.allowUninvited) return true;  // all accounts qualify\n\n    if (user.signupKey) return true;  // user is invited\n\n    if (this.isUserInOrganization(user)) return true;\n\n    return false;\n  },\n\n  isSignedUpOrDemo() {\n    const user = Meteor.user();\n    return this.isAccountSignedUpOrDemo(user);\n  },\n\n  isAccountSignedUpOrDemo(user) {\n    if (!user) return false;  // not signed in\n\n    if (!user.loginIdentities) return false;  // not an account\n\n    if (user.expires) return true;  // demo user.\n\n    if (Meteor.settings.public.allowUninvited) return true;  // all accounts qualify\n\n    if (user.signupKey) return true;  // user is invited\n\n    if (this.isUserInOrganization(user)) return true;\n\n    return false;\n  },\n\n  isIdentityInOrganization(identity) {\n    if (!identity || !identity.services) {\n      return false;\n    }\n\n    const orgMembership = this.getOrganizationMembership();\n    const googleEnabled = orgMembership && orgMembership.google && orgMembership.google.enabled;\n    const googleDomain = orgMembership && orgMembership.google && orgMembership.google.domain;\n    const emailEnabled = orgMembership && orgMembership.emailToken && orgMembership.emailToken.enabled;\n    const emailDomain = orgMembership && orgMembership.emailToken && orgMembership.emailToken.domain;\n    const ldapEnabled = orgMembership && orgMembership.ldap && orgMembership.ldap.enabled;\n    const samlEnabled = orgMembership && orgMembership.saml && orgMembership.saml.enabled;\n    if (emailEnabled && emailDomain && identity.services.email) {\n      const domainSuffixes = emailDomain.split(/\\s*,\\s*/);\n      for (let i = 0; i < domainSuffixes.length; i++) {\n        const suffix = domainSuffixes[i];\n        const domain = identity.services.email.email.toLowerCase().split(\"@\").pop();\n        if (suffix.startsWith(\"*.\")) {\n          if (domain.endsWith(suffix.substr(1))) {\n            return true;\n          }\n        } else if (domain === suffix) {\n          return true;\n        }\n      }\n    } else if (ldapEnabled && identity.services.ldap) {\n      return true;\n    } else if (samlEnabled && identity.services.saml) {\n      return true;\n    } else if (googleEnabled && googleDomain && identity.services.google && identity.services.google.hd) {\n      if (identity.services.google.hd.toLowerCase() === googleDomain) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  isUserInOrganization(user) {\n    for (let i = 0; i < user.loginIdentities.length; i++) {\n      let identity = Meteor.users.findOne({ _id: user.loginIdentities[i].id });\n      if (this.isIdentityInOrganization(identity)) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n});\n\nif (Meteor.isServer) {\n  SandstormDb.prototype.getWildcardOrigin = getWildcardOrigin;\n\n  const Crypto = Npm.require(\"crypto\");\n  SandstormDb.prototype.removeApiTokens = function (query) {\n    // Remove all API tokens matching the query, making sure to clean up ApiHosts as well.\n\n    this.collections.apiTokens.find(query).forEach((token) => {\n      // Clean up ApiHosts for webkey tokens.\n      if (token.hasApiHost) {\n        const hash2 = Crypto.createHash(\"sha256\").update(token._id).digest(\"base64\");\n        this.collections.apiHosts.remove({ hash2: hash2 });\n      }\n\n      // TODO(soon): Drop remote OAuth tokens for frontendRef.http. Unfortunately the way to do\n      //   this is different for every service. :( Also we may need to clarify with the \"bearer\"\n      //   type whether or not the token is \"owned\" by us...\n    });\n\n    this.collections.apiTokens.remove(query);\n  };\n}\n\n// TODO(someday): clean this up.  Logic for building static asset urls on client and server\n// appears all over the codebase.\nlet httpProtocol;\nif (Meteor.isServer) {\n  const Url = Npm.require(\"url\");\n  httpProtocol = Url.parse(process.env.ROOT_URL).protocol;\n} else {\n  httpProtocol = window.location.protocol;\n}\n\n// =======================================================================================\n// Below this point are newly-written or refactored functions.\n\n_.extend(SandstormDb.prototype, {\n  getUser(userId) {\n    check(userId, Match.OneOf(String, undefined, null));\n    if (userId) {\n      return Meteor.users.findOne(userId);\n    }\n  },\n\n  getIdentity(identityId) {\n    check(identityId, String);\n    const identity = Meteor.users.findOne({ _id: identityId });\n    if (identity) {\n      SandstormDb.fillInProfileDefaults(identity);\n      SandstormDb.fillInIntrinsicName(identity);\n      SandstormDb.fillInPictureUrl(identity);\n      return identity;\n    }\n  },\n\n  userHasIdentity(userId, identityId) {\n    check(userId, String);\n    check(identityId, String);\n\n    if (userId === identityId) return true;\n\n    const user = Meteor.users.findOne(userId);\n    return SandstormDb.getUserIdentityIds(user).indexOf(identityId) != -1;\n  },\n\n  userGrains(userId, options) {\n    check(userId, Match.OneOf(String, undefined, null));\n    check(options, Match.OneOf(undefined, null,\n        { includeTrashOnly: Match.Optional(Boolean), includeTrash: Match.Optional(Boolean), }));\n\n    const query = { userId: userId };\n    if (options && options.includeTrashOnly) {\n      query.trashed = { $exists: true };\n    } else if (options && options.includeTrash) {\n      // Keep query as-is.\n    } else {\n      query.trashed = { $exists: false };\n    }\n\n    return this.collections.grains.find(query);\n  },\n\n  currentUserGrains(options) {\n    return this.userGrains(Meteor.userId(), options);\n  },\n\n  getGrain(grainId) {\n    check(grainId, String);\n    return this.collections.grains.findOne(grainId);\n  },\n\n  userApiTokens(userId, trashed) {\n    check(userId, Match.OneOf(String, undefined, null));\n    check(trashed, Match.OneOf(Boolean, undefined, null));\n    const identityIds = SandstormDb.getUserIdentityIds(this.getUser(userId));\n    return this.collections.apiTokens.find({\n      \"owner.user.identityId\": { $in: identityIds },\n      trashed: { $exists: !!trashed },\n    });\n  },\n\n  currentUserApiTokens(trashed) {\n    return this.userApiTokens(Meteor.userId(), trashed);\n  },\n\n  userActions(user) {\n    return this.collections.userActions.find({ userId: user });\n  },\n\n  currentUserActions() {\n    return this.userActions(Meteor.userId());\n  },\n\n  iconSrcForPackage(pkg, usage) {\n    return Identicon.iconSrcForPackage(pkg, usage, httpProtocol + \"//\" + this.makeWildcardHost(\"static\"));\n  },\n\n  getDenormalizedGrainInfo(grainId) {\n    const grain = this.getGrain(grainId);\n    let pkg = this.collections.packages.findOne(grain.packageId);\n\n    if (!pkg) {\n      pkg = this.collections.devPackages.findOne(grain.packageId);\n    }\n\n    const appTitle = (pkg && pkg.manifest && pkg.manifest.appTitle) || { defaultText: \"\" };\n    const grainInfo = { appTitle: appTitle };\n\n    if (pkg && pkg.manifest && pkg.manifest.metadata && pkg.manifest.metadata.icons) {\n      const icons = pkg.manifest.metadata.icons;\n      const icon = icons.grain || icons.appGrid;\n      if (icon) {\n        grainInfo.icon = icon;\n      }\n    }\n\n    // Only provide an app ID if we have no icon asset to provide and need to offer an identicon.\n    if (!grainInfo.icon && pkg) {\n      grainInfo.appId = pkg.appId;\n    }\n\n    return grainInfo;\n  },\n\n  getPlan(id, user) {\n    check(id, String);\n\n    // `user`, if provided, is the user observing the plan. This matters only for checking if the\n    // user is in an experiment.\n\n    const plan = this.collections.plans.findOne(id);\n    if (!plan) {\n      throw new Error(\"no such plan: \" + id);\n    }\n\n    if (plan._id === \"free\") {\n      user = user || Meteor.user();\n      if (user && user.experiments &&\n          typeof user.experiments.freeGrainLimit === \"number\") {\n        plan.grains = user.experiments.freeGrainLimit;\n      }\n    }\n\n    return plan;\n  },\n\n  listPlans(user) {\n    user = user || Meteor.user();\n    if (user && user.experiments &&\n        typeof user.experiments.freeGrainLimit === \"number\") {\n      return this.collections.plans.find({}, { sort: { price: 1 } })\n          .map(plan => {\n        if (plan._id === \"free\") {\n          plan.grains = user.experiments.freeGrainLimit;\n        }\n\n        return plan;\n      });\n    } else {\n      return this.collections.plans.find({}, { sort: { price: 1 } }).fetch();\n    }\n  },\n\n  getMyPlan() {\n    const user = Meteor.user();\n    return user && this.collections.plans.findOne(user.plan || \"free\");\n  },\n\n  getMyReferralBonus(user) {\n    // This function is called from the server and from the client, similar to getMyPlan().\n    //\n    // The parameter may be omitted in which case the current user is assumed.\n\n    return calculateReferralBonus(user || Meteor.user());\n  },\n\n  getMyUsage(user) {\n    user = user || Meteor.user();\n    if (user && (Meteor.isServer || user.pseudoUsage)) {\n      if (Meteor.isClient) {\n        // Filled by pseudo-subscription to \"getMyUsage\". WARNING: The subscription is currently\n        // not reactive.\n        return user.pseudoUsage;\n      } else {\n        return {\n          grains: this.collections.grains.find({ userId: user._id }).count(),\n          storage: user.storageUsage || 0,\n          compute: 0,  // not tracked yet\n        };\n      }\n    } else {\n      return { grains: 0, storage: 0, compute: 0 };\n    }\n  },\n\n  isUninvitedFreeUser() {\n    if (!Meteor.settings.public.allowUninvited) return false;\n\n    const user = Meteor.user();\n    return user && !user.expires && (!user.plan || user.plan === \"free\");\n  },\n\n  getSetting(name) {\n    const setting = this.collections.settings.findOne(name);\n    return setting && setting.value;\n  },\n\n  getSettingWithFallback(name, fallbackValue) {\n    const value = this.getSetting(name);\n    if (value === undefined) {\n      return fallbackValue;\n    }\n\n    return value;\n  },\n\n  addUserActions(userId, packageId, simulation) {\n    check(userId, String);\n    check(packageId, String);\n\n    const pack = this.collections.packages.findOne({ _id: packageId });\n    if (pack) {\n      // Remove old versions.\n      const numRemoved = this.collections.userActions.remove({ userId: userId, appId: pack.appId });\n\n      // Install new.\n      const actions = pack.manifest.actions;\n      for (const i in actions) {\n        const action = actions[i];\n        if (\"none\" in action.input) {\n          const userAction = {\n            userId: userId,\n            packageId: pack._id,\n            appId: pack.appId,\n            appTitle: pack.manifest.appTitle,\n            appMarketingVersion: pack.manifest.appMarketingVersion,\n            appVersion: pack.manifest.appVersion,\n            title: action.title,\n            nounPhrase: action.nounPhrase,\n            command: action.command,\n          };\n          this.collections.userActions.insert(userAction);\n        } else {\n          // TODO(someday):  Implement actions with capability inputs.\n        }\n      }\n\n      if (numRemoved > 0 && !simulation) {\n        this.deleteUnusedPackages(pack.appId);\n      }\n    }\n  },\n\n  sendAdminNotification(type, action) {\n    Meteor.users.find({ isAdmin: true }, { fields: { _id: 1 } }).forEach(function (user) {\n      Notifications.insert({\n        admin: { action, type },\n        userId: user._id,\n        timestamp: new Date(),\n        isUnread: true,\n      });\n    });\n  },\n\n  getKeybaseProfile(keyFingerprint) {\n    return this.collections.keybaseProfiles.findOne(keyFingerprint) || {};\n  },\n\n  getServerTitle() {\n    const setting = this.collections.settings.findOne({ _id: \"serverTitle\" });\n    return setting ? setting.value : \"\";  // empty if subscription is not ready.\n  },\n\n  getSmtpConfig() {\n    const setting = this.collections.settings.findOne({ _id: \"smtpConfig\" });\n    return setting ? setting.value : undefined; // undefined if subscription is not ready.\n  },\n\n  getReturnAddress() {\n    const config = this.getSmtpConfig();\n    return config && config.returnAddress || \"\"; // empty if subscription is not ready.\n  },\n\n  getReturnAddressWithDisplayName(identityId) {\n    check(identityId, String);\n    const identity = this.getIdentity(identityId);\n    const displayName = identity.profile.name + \" (via \" + this.getServerTitle() + \")\";\n\n    // First remove any instances of characters that cause trouble for SimpleSmtp. Ideally,\n    // we could escape such characters with a backslash, but that does not seem to help here.\n    const sanitized = displayName.replace(/\"|<|>|\\\\|\\r/g, \"\");\n\n    return \"\\\"\" + sanitized + \"\\\" <\" + this.getReturnAddress() + \">\";\n  },\n\n  getPrimaryEmail(accountId, identityId) {\n    check(accountId, String);\n    check(identityId, String);\n\n    const identity = this.getIdentity(identityId);\n    const senderEmails = SandstormDb.getVerifiedEmails(identity);\n    const senderPrimaryEmail = _.findWhere(senderEmails, { primary: true });\n    const accountPrimaryEmailAddress = this.getUser(accountId).primaryEmail;\n    if (_.findWhere(senderEmails, { email: accountPrimaryEmailAddress })) {\n      return accountPrimaryEmailAddress;\n    } else if (senderPrimaryEmail) {\n      return senderPrimaryEmail.email;\n    } else {\n      return null;\n    }\n  },\n\n  incrementDailySentMailCount(accountId) {\n    check(accountId, String);\n\n    const DAILY_LIMIT = 50;\n    const result = Meteor.users.findAndModify({\n      query: { _id: accountId },\n      update: {\n        $inc: {\n          dailySentMailCount: 1,\n        },\n      },\n      fields: { dailySentMailCount: 1 },\n    });\n\n    if (!result.ok) {\n      throw new Error(\"Couldn't update daily sent mail count.\");\n    }\n\n    const user = result.value;\n    if (user.dailySentMailCount >= DAILY_LIMIT) {\n      throw new Error(\n          \"Sorry, you've reached your e-mail sending limit for today. Currently, Sandstorm \" +\n          \"limits each user to \" + DAILY_LIMIT + \" e-mails per day for spam control reasons. \" +\n          \"Please feel free to contact us if this is a problem.\");\n    }\n  },\n\n  getLdapUrl() {\n    const setting = this.collections.settings.findOne({ _id: \"ldapUrl\" });\n    return setting ? setting.value : \"\";  // empty if subscription is not ready.\n  },\n\n  getLdapBase() {\n    const setting = this.collections.settings.findOne({ _id: \"ldapBase\" });\n    return setting ? setting.value : \"\";  // empty if subscription is not ready.\n  },\n\n  getLdapDnPattern() {\n    const setting = this.collections.settings.findOne({ _id: \"ldapDnPattern\" });\n    return setting ? setting.value : \"\";  // empty if subscription is not ready.\n  },\n\n  getLdapSearchUsername() {\n    const setting = this.collections.settings.findOne({ _id: \"ldapSearchUsername\" });\n    return setting ? setting.value : \"\";  // empty if subscription is not ready.\n  },\n\n  getLdapNameField() {\n    const setting = this.collections.settings.findOne({ _id: \"ldapNameField\" });\n    return setting ? setting.value : \"\";  // empty if subscription is not ready.\n  },\n\n  getLdapEmailField() {\n    const setting = this.collections.settings.findOne({ _id: \"ldapEmailField\" });\n    return setting ? setting.value : \"mail\";\n    // default to \"mail\". This setting was added later, and so could potentially be unset.\n  },\n\n  getLdapExplicitDnSelected() {\n    const setting = this.collections.settings.findOne({ _id: \"ldapExplicitDnSelected\" });\n    return setting && setting.value;\n  },\n\n  getLdapFilter() {\n    const setting = this.collections.settings.findOne({ _id: \"ldapFilter\" });\n    return setting ? setting.value : \"\";  // empty if subscription is not ready.\n  },\n\n  getLdapSearchBindDn() {\n    const setting = this.collections.settings.findOne({ _id: \"ldapSearchBindDn\" });\n    return setting ? setting.value : \"\";  // empty if subscription is not ready.\n  },\n\n  getLdapSearchBindPassword() {\n    const setting = this.collections.settings.findOne({ _id: \"ldapSearchBindPassword\" });\n    return setting ? setting.value : \"\";  // empty if subscription is not ready.\n  },\n\n  getLdapCaCert() {\n    const setting = this.collections.settings.findOne({ _id: \"ldapCaCert\" });\n    return setting ? setting.value : \"\";  // empty if subscription is not ready.\n  },\n\n  getOrganizationMembership() {\n    const setting = this.collections.settings.findOne({ _id: \"organizationMembership\" });\n    return setting && setting.value;\n  },\n\n  getOrganizationEmailEnabled() {\n    const membership = this.getOrganizationMembership();\n    return membership && membership.emailToken && membership.emailToken.enabled;\n  },\n\n  getOrganizationEmailDomain() {\n    const membership = this.getOrganizationMembership();\n    return membership && membership.emailToken && membership.emailToken.domain;\n  },\n\n  getOrganizationGoogleEnabled() {\n    const membership = this.getOrganizationMembership();\n    return membership && membership.google && membership.google.enabled;\n  },\n\n  getOrganizationGoogleDomain() {\n    const membership = this.getOrganizationMembership();\n    return membership && membership.google && membership.google.domain;\n  },\n\n  getOrganizationLdapEnabled() {\n    const membership = this.getOrganizationMembership();\n    return membership && membership.ldap && membership.ldap.enabled;\n  },\n\n  getOrganizationSamlEnabled() {\n    const membership = this.getOrganizationMembership();\n    return membership && membership.saml && membership.saml.enabled;\n  },\n\n  getOrganizationDisallowGuests() {\n    return this.getOrganizationDisallowGuestsRaw();\n  },\n\n  getOrganizationDisallowGuestsRaw() {\n    const setting = this.collections.settings.findOne({ _id: \"organizationSettings\" });\n    return setting && setting.value && setting.value.disallowGuests;\n  },\n\n  getOrganizationShareContacts() {\n    return this.getOrganizationShareContactsRaw();\n  },\n\n  getOrganizationShareContactsRaw() {\n    const setting = this.collections.settings.findOne({ _id: \"organizationSettings\" });\n    if (!setting || !setting.value || setting.value.shareContacts === undefined) {\n      // default to true if undefined\n      return true;\n    } else {\n      return setting.value.shareContacts;\n    }\n  },\n\n  getSamlEntryPoint() {\n    const setting = this.collections.settings.findOne({ _id: \"samlEntryPoint\" });\n    return setting ? setting.value : \"\";  // empty if subscription is not ready.\n  },\n\n  getSamlLogout() {\n    const setting = this.collections.settings.findOne({ _id: \"samlLogout\" });\n    return setting ? setting.value : \"\";  // empty if subscription is not ready.\n  },\n\n  getSamlPublicCert() {\n    const setting = this.collections.settings.findOne({ _id: \"samlPublicCert\" });\n    return setting ? setting.value : \"\";  // empty if subscription is not ready.\n  },\n\n  getSamlEntityId() {\n    const setting = this.collections.settings.findOne({ _id: \"samlEntityId\" });\n    return setting ? setting.value : \"\"; // empty if subscription is not ready.\n  },\n\n  userHasSamlLoginIdentity() {\n    const user = Meteor.user();\n    if (!user.loginIdentities) {\n      return false;\n    }\n\n    let hasSaml = false;\n    user.loginIdentities.forEach((identity) => {\n      if (Meteor.users.findOne({ _id: identity.id }).services.saml) {\n        hasSaml = true;\n      }\n    });\n\n    return hasSaml;\n  },\n\n  getActivitySubscriptions(grainId, threadPath) {\n    return this.collections.activitySubscriptions.find({\n      grainId: grainId,\n      threadPath: threadPath || { $exists: false },\n    }, {\n      fields: { identityId: 1, mute: 1, _id: 0 },\n    }).fetch();\n  },\n\n  subscribeToActivity(identityId, grainId, threadPath) {\n    // Subscribe the given identity to activity events with the given grainId and (optional)\n    // threadPath -- unless the identity has previously muted this grainId/threadPath, in which\n    // case do nothing.\n\n    const record = { identityId, grainId };\n    if (threadPath) {\n      record.threadPath = threadPath;\n    }\n\n    // The $set here is redundant since an upsert automatically initializes a new record to contain\n    // the fields from the query, but if we try to do { $set: {} } Mongo throws an exception, and\n    // if we try to just pass {}, Mongo interprets it as \"replace the record with an empty record\".\n    // What a wonderful query language.\n    this.collections.activitySubscriptions.upsert(record, { $set: record });\n  },\n\n  muteActivity(identityId, grainId, threadPath) {\n    // Mute notifications for the given identity originating from the given grainId and\n    // (optional) threadPath.\n\n    const record = { identityId, grainId };\n    if (threadPath) {\n      record.threadPath = threadPath;\n    }\n\n    this.collections.activitySubscriptions.upsert(record, { $set: { mute: true } });\n  },\n\n  updateAppIndex() {\n    const appUpdatesEnabledSetting = this.collections.settings.findOne({ _id: \"appUpdatesEnabled\" });\n    const appUpdatesEnabled = appUpdatesEnabledSetting && appUpdatesEnabledSetting.value;\n    if (!appUpdatesEnabled) {\n      // It's much simpler to check appUpdatesEnabled here rather than reactively deactivate the\n      // timer that triggers this call.\n      return;\n    }\n\n    const appIndexUrl = this.collections.settings.findOne({ _id: \"appIndexUrl\" }).value;\n    const appIndex = this.collections.appIndex;\n    const data = HTTP.get(appIndexUrl + \"/apps/index.json\").data;\n    const preinstalledAppIds = this.getAllPreinstalledAppIds();\n    // We make sure to get all preinstalled appIds, even ones that are currently\n    // downloading/failed.\n    data.apps.forEach((app) => {\n      app._id = app.appId;\n\n      const oldApp = appIndex.findOne({ _id: app.appId });\n      app.hasSentNotifications = false;\n      appIndex.upsert({ _id: app._id }, app);\n      const isAppPreinstalled = _.contains(preinstalledAppIds, app.appId);\n      if ((!oldApp || app.versionNumber > oldApp.versionNumber) &&\n          (this.collections.userActions.findOne({ appId: app.appId }) ||\n          isAppPreinstalled)) {\n        const pack = this.collections.packages.findOne({ _id: app.packageId });\n        const url = appIndexUrl + \"/packages/\" + app.packageId;\n        if (pack) {\n          if (pack.status === \"ready\") {\n            if (pack.appId && pack.appId !== app.appId) {\n              console.error(\"app index returned app ID and package ID that don't match:\",\n                            JSON.stringify(app));\n            } else {\n              this.sendAppUpdateNotifications(app.appId, app.packageId, app.name, app.versionNumber,\n                app.version);\n              if (isAppPreinstalled) {\n                this.setPreinstallAppAsReady(app.appId, app.packageId);\n              }\n            }\n          } else {\n            const result = this.collections.packages.findAndModify({\n              query: { _id: app.packageId },\n              update: { $set: { isAutoUpdated: true } },\n            });\n\n            if (!result.ok) {\n              return;\n            }\n\n            const newPack = result.value;\n            if (newPack.status === \"ready\") {\n              // The package was marked as ready before we applied isAutoUpdated=true. We should send\n              // notifications ourselves to be sure there's no timing issue (sending more than one is\n              // fine, since it will de-dupe).\n              if (pack.appId && pack.appId !== app.appId) {\n                console.error(\"app index returned app ID and package ID that don't match:\",\n                              JSON.stringify(app));\n              } else {\n                this.sendAppUpdateNotifications(app.appId, app.packageId, app.name, app.versionNumber,\n                  app.version);\n                if (isAppPreinstalled) {\n                  this.setPreinstallAppAsReady(app.appId, app.packageId);\n                }\n              }\n            } else if (newPack.status === \"failed\") {\n              // If the package has failed, retry it\n              this.startInstall(app.packageId, url, true, true);\n            }\n          }\n        } else {\n          this.startInstall(app.packageId, url, false, true);\n        }\n      }\n    });\n  },\n\n  isPackagePreinstalled(packageId) {\n    return this.collections.settings.find({ _id: \"preinstalledApps\", \"value.packageId\": packageId }).count() === 1;\n  },\n\n  getAppIdForPreinstalledPackage(packageId) {\n    const setting = this.collections.settings.findOne({ _id: \"preinstalledApps\", \"value.packageId\": packageId },\n    { fields: { \"value.$\": 1 } });\n    // value.$ causes mongo to transform the result and only return the first matching element in\n    // the array\n    return setting && setting.value && setting.value[0] && setting.value[0].appId;\n  },\n\n  getPackageIdForPreinstalledApp(appId) {\n    const setting = this.collections.settings.findOne({ _id: \"preinstalledApps\", \"value.appId\": appId },\n    { fields: { \"value.$\": 1 } });\n    // value.$ causes mongo to transform the result and only return the first matching element in\n    // the array\n    return setting && setting.value && setting.value[0] && setting.value[0].packageId;\n  },\n\n  getReadyPreinstalledAppIds() {\n    const setting = this.collections.settings.findOne({ _id: \"preinstalledApps\" });\n    const ret = setting && setting.value || [];\n    return _.chain(ret)\n            .filter((app) => { return app.status === \"ready\"; })\n            .map((app) => { return app.appId; })\n            .value();\n  },\n\n  getAllPreinstalledAppIds() {\n    const setting = this.collections.settings.findOne({ _id: \"preinstalledApps\" });\n    const ret = setting && setting.value || [];\n    return _.map(ret, (app) => { return app.appId; });\n  },\n\n  preinstallAppsForUser(userId) {\n    const appIds = this.getReadyPreinstalledAppIds();\n    appIds.forEach((appId) => {\n      try {\n        this.addUserActions(userId, this.getPackageIdForPreinstalledApp(appId));\n      } catch (e) {\n        console.error(\"failed to install app for user:\", e);\n      }\n    });\n  },\n\n  setPreinstallAppAsDownloading(appId, packageId) {\n    this.collections.settings.update(\n      { _id: \"preinstalledApps\", \"value.appId\": appId, \"value.packageId\": packageId },\n      { $set: { \"value.$.status\": \"downloading\" } });\n  },\n\n  setPreinstallAppAsReady(appId, packageId) {\n    // This function both sets the appId as ready and updates the packageId for the given appId\n    // Setting the packageId is especially useful in installer.js, as it always ensures the\n    // latest installed package will be set as ready.\n    this.collections.settings.update(\n      { _id: \"preinstalledApps\", \"value.appId\": appId },\n      { $set: { \"value.$.status\": \"ready\", \"value.$.packageId\": packageId } });\n  },\n\n  ensureAppPreinstall(appId, packageId) {\n    check(appId, String);\n    const appIndexUrl = this.collections.settings.findOne({ _id: \"appIndexUrl\" }).value;\n    const pack = this.collections.packages.findOne({ _id: packageId });\n    const url = appIndexUrl + \"/packages/\" + packageId;\n    if (pack && pack.status === \"ready\") {\n      this.setPreinstallAppAsReady(appId, packageId);\n    } else if (pack && pack.status === \"failed\") {\n      this.setPreinstallAppAsDownloading(appId, packageId);\n      this.startInstall(packageId, url, true, false);\n    } else {\n      this.setPreinstallAppAsDownloading(appId, packageId);\n      this.startInstall(packageId, url, false, false);\n    }\n  },\n\n  setPreinstalledApps(appAndPackageIds) {\n    // appAndPackageIds: A List[Object] where each element has fields:\n    //     appId: The Packages.appId of the app to install\n    //     packageId: The Packages._id of the app to install\n    check(appAndPackageIds, [{ appId: String, packageId: String, }]);\n\n    // Start by clearing out the setting. We'll push appIds one by one to it\n    this.collections.settings.upsert({ _id: \"preinstalledApps\" }, { $set: {\n      value: appAndPackageIds.map((data) => {\n        return {\n          appId: data.appId,\n          status: \"notReady\",\n          packageId: data.packageId,\n        };\n      }),\n    }, });\n    appAndPackageIds.forEach((data) => {\n      this.ensureAppPreinstall(data.appId, data.packageId);\n    });\n  },\n\n  getProductivitySuiteAppIds() {\n    return [\n      \"8aspz4sfjnp8u89000mh2v1xrdyx97ytn8hq71mdzv4p4d8n0n3h\", // Davros\n      \"h37dm17aa89yrd8zuqpdn36p6zntumtv08fjpu8a8zrte7q1cn60\", // Etherpad\n      \"vfnwptfn02ty21w715snyyczw0nqxkv3jvawcah10c6z7hj1hnu0\", // Rocket.Chat\n      \"m86q05rdvj14yvn78ghaxynqz7u2svw6rnttptxx49g1785cdv1h\", // Wekan\n    ];\n  },\n\n  getSystemSuiteAppIds() {\n    return [\n      \"s3u2xgmqwznz2n3apf30sm3gw1d85y029enw5pymx734cnk5n78h\", // Collections\n    ];\n  },\n\n  isPreinstalledAppsReady() {\n    const setting = this.collections.settings.findOne({ _id: \"preinstalledApps\" });\n    if (!setting || !setting.value) {\n      return true;\n    }\n\n    const packageIds = _.pluck(setting.value, \"packageId\");\n    const readyApps = this.collections.packages.find({\n      _id: {\n        $in: packageIds,\n      },\n      status: \"ready\",\n    });\n    return readyApps.count() === packageIds.length;\n  },\n\n  getBillingPromptUrl() {\n    const setting = this.collections.settings.findOne({ _id: \"billingPromptUrl\" });\n    return setting && setting.value;\n  },\n\n  isReferralEnabled() {\n    // This function is a bit weird, in that we've transitioned from\n    // Meteor.settings.public.quotaEnabled to DB settings. For now,\n    // Meteor.settings.public.quotaEnabled implies bothisReferralEnabled and isQuotaEnabled are true.\n    return Meteor.settings.public.quotaEnabled;\n  },\n\n  isHideAboutEnabled() {\n    const setting = this.collections.settings.findOne({ _id: \"whiteLabelHideAbout\" });\n    return setting && setting.value;\n  },\n\n  isQuotaEnabled() {\n    if (Meteor.settings.public.quotaEnabled) return true;\n\n    const setting = this.collections.settings.findOne({ _id: \"quotaEnabled\" });\n    return setting && setting.value;\n  },\n\n  isQuotaLdapEnabled() {\n    const setting = this.collections.settings.findOne({ _id: \"quotaLdapEnabled\" });\n    return setting && setting.value;\n  },\n\n  updateUserQuota(user) {\n    if (this.quotaManager) {\n      return this.quotaManager.updateUserQuota(this, user);\n    }\n  },\n\n  getUserQuota(user) {\n    if (this.isQuotaLdapEnabled()) {\n      return this.quotaManager.updateUserQuota(this, user);\n    } else {\n      const plan = this.getPlan(user.plan || \"free\", user);\n      const referralBonus = calculateReferralBonus(user);\n      const bonus = user.planBonus || {};\n      const userQuota = {\n        storage: plan.storage + referralBonus.storage + (bonus.storage || 0),\n        grains: plan.grains + referralBonus.grains + (bonus.grains || 0),\n        compute: plan.compute + (bonus.compute || 0),\n      };\n      return userQuota;\n    }\n  },\n\n  isUserOverQuota(user) {\n    // Return false if user has quota space remaining, true if it is full. When this returns true,\n    // we will not allow the user to create new grains, though they may be able to open existing ones\n    // which may still increase their storage usage.\n    //\n    // (Actually returns a string which can be fed into `billingPrompt` as the reason.)\n\n    if (!this.isQuotaEnabled() || user.isAdmin) return false;\n\n    const plan = this.getUserQuota(user);\n    if (plan.grains < Infinity) {\n      const count = this.collections.grains.find({ userId: user._id, trashed: { $exists: false } },\n        { fields: {}, limit: plan.grains }).count();\n      if (count >= plan.grains) return \"outOfGrains\";\n    }\n\n    return plan && user.storageUsage && user.storageUsage >= plan.storage && \"outOfStorage\";\n  },\n\n  isUserExcessivelyOverQuota(user) {\n    // Return true if user is so far over quota that we should prevent their existing grains from\n    // running at all.\n    //\n    // (Actually returns a string which can be fed into `billingPrompt` as the reason.)\n\n    if (!this.isQuotaEnabled() || user.isAdmin) return false;\n\n    const quota = this.getUserQuota(user);\n\n    // quota.grains = Infinity means unlimited grains. IEEE754 defines Infinity == Infinity.\n    if (quota.grains < Infinity) {\n      const count = this.collections.grains.find({ userId: user._id, trashed: { $exists: false } },\n        { fields: {}, limit: quota.grains * 2 }).count();\n      if (count >= quota.grains * 2) return \"outOfGrains\";\n    }\n\n    return quota && user.storageUsage && user.storageUsage >= quota.storage * 1.2 && \"outOfStorage\";\n  },\n\n  suspendIdentity(userId, suspension) {\n    check(userId, String);\n    check(suspension, {\n      timestamp: Date,\n      admin: Match.Optional(String),\n      voluntary: Match.Optional(Boolean),\n    });\n\n    this.collections.users.update({ _id: userId }, { $set: { suspended: suspension } });\n    this.collections.apiTokens.update({ \"owner.user.identityId\": userId },\n      { $set: { suspended: true } }, { multi: true });\n  },\n\n  unsuspendIdentity(userId) {\n    check(userId, String);\n\n    this.collections.users.update({ _id: userId }, { $unset: { suspended: 1 } });\n    this.collections.apiTokens.update({ \"owner.user.identityId\": userId },\n      { $unset: { suspended: true } }, { multi: true });\n  },\n\n  suspendAccount(userId, byAdminUserId, willDelete) {\n    check(userId, String);\n    check(byAdminUserId, Match.OneOf(String, null, undefined));\n    check(willDelete, Boolean);\n\n    const user = this.collections.users.findOne({ _id: userId });\n    const suspension = {\n      timestamp: new Date(),\n      willDelete: willDelete || false,\n    };\n    if (byAdminUserId) {\n      suspension.admin = byAdminUserId;\n    } else {\n      suspension.voluntary = true;\n    }\n\n    this.collections.users.update({ _id: userId }, { $set: { suspended: suspension } });\n    this.collections.grains.update({ userId: userId }, { $set: { suspended: true } }, { multi: true });\n\n    delete suspension.willDelete;\n    // Only mark the parent account for deletion. This makes the query simpler later.\n\n    user.loginIdentities.forEach((identity) => {\n      this.suspendIdentity(identity.id, suspension);\n    });\n    user.nonloginIdentities.forEach((identity) => {\n      if (this.collections.users.find({ $or: [\n        { \"loginIdentities.id\": identity.id },\n        { \"nonloginIdentities.id\": identity.id },\n      ], }).count() === 1) {\n        // Only suspend non-login identities that are unique to this account.\n        this.suspendIdentity(identity.id, suspension);\n      }\n    });\n\n    // Force logout this user\n    this.collections.users.update({ _id: userId },\n      { $unset: { \"services.resume.loginTokens\": 1 } });\n    if (user && user.loginIdentities) {\n      user.loginIdentities.forEach(function (identity) {\n        Meteor.users.update({ _id: identity.id }, { $unset: { \"services.resume.loginTokens\": 1 } });\n      });\n    }\n  },\n\n  unsuspendAccount(userId) {\n    check(userId, String);\n\n    const user = this.collections.users.findOne({ _id: userId });\n    this.collections.users.update({ _id: userId }, { $unset: { suspended: 1 } });\n    this.collections.grains.update({ userId: userId }, { $unset: { suspended: 1 } }, { multi: true });\n\n    user.loginIdentities.forEach((identity) => {\n      this.unsuspendIdentity(identity.id);\n    });\n\n    user.nonloginIdentities.forEach((identity) => {\n      this.unsuspendIdentity(identity.id);\n    });\n  },\n\n  deletePendingAccounts(deletionCoolingOffTime, backend, cb) {\n    check(deletionCoolingOffTime, Number);\n\n    const queryDate = new Date(Date.now() - deletionCoolingOffTime);\n    this.collections.users.find({\n      \"suspended.willDelete\": true,\n      \"suspended.timestamp\": { $lt: queryDate },\n    }).forEach((user) => {\n      if (cb) cb(this, user);\n      this.deleteAccount(user._id, backend);\n    });\n  },\n\n  hostIsStandalone: function (hostname) {\n    check(hostname, String);\n\n    return !!this.collections.standaloneDomains.findOne({ _id: hostname, });\n  },\n});\n\nSandstormDb.escapeMongoKey = (key) => {\n  // This incredibly poor mechanism for escaping Mongo keys is recommended by the Mongo docs here:\n  //   https://docs.mongodb.org/manual/faq/developers/#dollar-sign-operator-escaping\n  // and seems to be a de facto standard, for example:\n  //   https://www.npmjs.com/package/mongo-key-escape\n  return key.replace(\".\", \"\\uFF0E\").replace(\"$\", \"\\uFF04\");\n};\n\nconst appNameFromPackage = function (packageObj) {\n  // This function takes a Package object from Mongo and returns an\n  // app title.\n  const manifest = packageObj.manifest;\n  if (!manifest) return packageObj.appId || packageObj._id || \"unknown\";\n  const action = manifest.actions[0];\n  appName = (manifest.appTitle && manifest.appTitle.defaultText) ||\n    appNameFromActionName(action.title.defaultText);\n  return appName;\n};\n\nconst appNameFromActionName = function (name) {\n  // Hack: Historically we only had action titles, like \"New Etherpad Document\", not app\n  //   titles. But for this UI we want app titles. As a transitionary measure, try to\n  //   derive the app title from the action title.\n  // TODO(cleanup): Get rid of this once apps have real titles.\n  if (!name) {\n    return \"(unnamed)\";\n  }\n\n  if (name.lastIndexOf(\"New \", 0) === 0) {\n    name = name.slice(4);\n  }\n\n  if (name.lastIndexOf(\"Hacker CMS\", 0) === 0) {\n    name = \"Hacker CMS\";\n  } else {\n    const space = name.indexOf(\" \");\n    if (space > 0) {\n      name = name.slice(0, space);\n    }\n  }\n\n  return name;\n};\n\nconst appShortDescriptionFromPackage = function (pkg) {\n  return pkg && pkg.manifest && pkg.manifest.metadata &&\n         pkg.manifest.metadata.shortDescription &&\n         pkg.manifest.metadata.shortDescription.defaultText;\n};\n\nconst nounPhraseForActionAndAppTitle = function (action, appTitle) {\n  // A hack to deal with legacy apps not including fields in their manifests.\n  // I look forward to the day I can remove most of this code.\n  // Attempt to figure out the appropriate noun that this action will create.\n  // Use an explicit noun phrase is one is available.  Apps should add these in the future.\n  if (action.nounPhrase) return action.nounPhrase.defaultText;\n  // Otherwise, try to guess one from the structure of the action title field\n  if (action.title && action.title.defaultText) {\n    const text = action.title.defaultText;\n    // Strip a leading \"New \"\n    if (text.lastIndexOf(\"New \", 0) === 0) {\n      const candidate = text.slice(4);\n      // Strip a leading appname too, if provided\n      if (candidate.lastIndexOf(appTitle, 0) === 0) {\n        const newCandidate = candidate.slice(appTitle.length);\n        // Unless that leaves you with no noun, in which case, use \"grain\"\n        if (newCandidate.length > 0) {\n          return newCandidate.toLowerCase();\n        } else {\n          return \"grain\";\n        }\n      }\n\n      return candidate.toLowerCase();\n    }\n    // Some other verb phrase was given.  Just use it verbatim, and hope the app author updates\n    // the package soon.\n    return text;\n  } else {\n    return \"grain\";\n  }\n};\n\n// Static methods on SandstormDb that don't need an instance.\n// Largely things that deal with backwards-compatibility.\n_.extend(SandstormDb, {\n  appNameFromActionName: appNameFromActionName,\n  appNameFromPackage: appNameFromPackage,\n  appShortDescriptionFromPackage: appShortDescriptionFromPackage,\n  nounPhraseForActionAndAppTitle: nounPhraseForActionAndAppTitle,\n});\n\nif (Meteor.isServer) {\n  const Crypto = Npm.require(\"crypto\");\n  const ContentType = Npm.require(\"content-type\");\n  const Zlib = Npm.require(\"zlib\");\n  const Url = Npm.require(\"url\");\n\n  const replicaNumber = Meteor.settings.replicaNumber || 0;\n\n  const computeStagger = function (n) {\n    // Compute a fraction in the range [0, 1) such that, for any natural number k, the values\n    // of computeStagger(n) for all n in [1, 2^k) are uniformly distributed between 0 and 1.\n    // The sequence looks like:\n    //   0, 1/2, 1/4, 3/4, 1/8, 3/8, 5/8, 7/8, 1/16, ...\n    //\n    // We use this to determine how we'll stagger periodic events performed by this replica.\n    // Notice that this allows us to compute a stagger which is independent of the number of\n    // front-end replicas present; we can add more replicas to the end without affecting how the\n    // earlier ones schedule their events.\n    let denom = 1;\n    while (denom <= n) denom <<= 1;\n    const num = n * 2 - denom + 1;\n    return num / denom;\n  };\n\n  const stagger = computeStagger(replicaNumber);\n\n  SandstormDb.periodicCleanup = function (intervalMs, callback) {\n    // Register a database cleanup function than should run periodically, roughly once every\n    // interval of the given length.\n    //\n    // In a blackrock deployment with multiple front-ends, the frequency of the cleanup will be\n    // scaled appropriately on the assumption that more data is being generated demanding more\n    // frequent cleanups.\n\n    check(intervalMs, Number);\n    check(callback, Function);\n\n    if (intervalMs < 120000) {\n      throw new Error(\"less than 2-minute cleanup interval seems too fast; \" +\n                      \"are you using the right units?\");\n    }\n\n    // Schedule first cleanup to happen at the next intervalMs interval from the epoch, so that\n    // the schedule is independent of the exact startup time.\n    let first = intervalMs - Date.now() % intervalMs;\n\n    // Stagger cleanups across replicas so that we don't have all replicas trying to clean the\n    // same data at the same time.\n    first += Math.floor(intervalMs * computeStagger(replicaNumber));\n\n    // If the stagger put us more than an interval away from now, back up.\n    if (first > intervalMs) first -= intervalMs;\n\n    Meteor.setTimeout(function () {\n      callback();\n      Meteor.setInterval(callback, intervalMs);\n    }, first);\n  };\n\n  // TODO(cleanup): Node 0.12 has a `gzipSync` but 0.10 (which Meteor still uses) does not.\n  const gzipSync = Meteor.wrapAsync(Zlib.gzip, Zlib);\n\n  const BufferSmallerThan = function (limit) {\n    return Match.Where(function (buf) {\n      check(buf, Buffer);\n      return buf.length < limit;\n    });\n  };\n\n  const DatabaseId = Match.Where(function (s) {\n    check(s, String);\n    return !!s.match(/^[a-zA-Z0-9_]+$/);\n  });\n\n  SandstormDb.prototype.addStaticAsset = function (metadata, content) {\n    // Add a new static asset to the database. If `content` is a string rather than a buffer, it\n    // will be automatically gzipped before storage; do not specify metadata.encoding in this case.\n\n    if (typeof content === \"string\" && !metadata.encoding) {\n      content = gzipSync(new Buffer(content, \"utf8\"));\n      metadata.encoding = \"gzip\";\n    }\n\n    check(metadata, {\n      mimeType: String,\n      encoding: Match.Optional(\"gzip\"),\n    });\n    check(content, BufferSmallerThan(1 << 20));\n\n    // Validate content type.\n    metadata.mimeType = ContentType.format(ContentType.parse(metadata.mimeType));\n\n    const hasher = Crypto.createHash(\"sha256\");\n    hasher.update(metadata.mimeType + \"\\n\" + metadata.encoding + \"\\n\", \"utf8\");\n    hasher.update(content);\n    const hash = hasher.digest(\"base64\");\n\n    const result = this.collections.staticAssets.findAndModify({\n      query: { hash: hash, refcount: { $gte: 1 } },\n      update: { $inc: { refcount: 1 } },\n      fields: { _id: 1, refcount: 1 },\n    });\n\n    if (!result.ok) {\n      throw new Error(`Couldn't increment refcount of asset with hash ${hash}`);\n    }\n\n    const existing = result.value;\n    if (existing) {\n      return existing._id;\n    }\n\n    return this.collections.staticAssets.insert(_.extend({\n      hash: hash,\n      content: content,\n      refcount: 1,\n    }, metadata));\n  };\n\n  SandstormDb.prototype.refStaticAsset = function (id) {\n    // Increment the refcount on an existing static asset. Returns the asset on success.\n    // If the asset does not exist, returns a falsey value.\n    //\n    // You must call this BEFORE adding the new reference to the DB, in case of failure between\n    // the two calls. (This way, the failure case is a storage leak, which is probably not a big\n    // deal and can be fixed by GC, rather than a mysteriously missing asset.)\n\n    check(id, String);\n\n    const result = this.collections.staticAssets.findAndModify({\n      query: { hash: hash },\n      update: { $inc: { refcount: 1 } },\n      fields: { _id: 1, content: 1, mimeType: 1 },\n    });\n\n    if (!result.ok) {\n      throw new Error(`Couldn't increment refcount of asset with hash ${hash}`);\n    }\n\n    const existing = result.value;\n    return existing;\n  };\n\n  SandstormDb.prototype.unrefStaticAsset = function (id) {\n    // Decrement refcount on a static asset and delete if it has reached zero.\n    //\n    // You must call this AFTER removing the reference from the DB, in case of failure between\n    // the two calls. (This way, the failure case is a storage leak, which is probably not a big\n    // deal and can be fixed by GC, rather than a mysteriously missing asset.)\n\n    check(id, String);\n\n    const result = this.collections.staticAssets.findAndModify({\n      query: { _id: id },\n      update: { $inc: { refcount: -1 } },\n      fields: { _id: 1, refcount: 1 },\n      new: true,\n    });\n\n    if (!result.ok) {\n      throw new Error(`Couldn't unref static asset ${id}`);\n    }\n\n    const existing = result.value;\n    if (!existing) {\n      console.error(new Error(\"unrefStaticAsset() called on asset that doesn't exist\").stack);\n    } else if (existing.refcount <= 0) {\n      this.collections.staticAssets.remove({ _id: existing._id });\n    }\n  };\n\n  SandstormDb.prototype.getStaticAsset = function (id) {\n    // Get a static asset's mimeType, encoding, and raw content.\n\n    check(id, String);\n\n    const asset = this.collections.staticAssets.findOne(id, { fields: { _id: 0, mimeType: 1, encoding: 1, content: 1 } });\n    if (asset) {\n      // TODO(perf): Mongo converts buffers to something else. Figure out a way to avoid a copy\n      //   here.\n      asset.content = new Buffer(asset.content);\n    }\n\n    return asset;\n  };\n\n  SandstormDb.prototype.newAssetUpload = function (purpose) {\n    check(purpose, Match.OneOf(\n      { profilePicture: { userId: DatabaseId, identityId: DatabaseId } },\n      { loginLogo: {} },\n    ));\n\n    return this.collections.assetUploadTokens.insert({\n      purpose: purpose,\n      expires: new Date(Date.now() + 300000),  // in 5 minutes\n    });\n  };\n\n  SandstormDb.prototype.fulfillAssetUpload = function (id) {\n    // Indicates that the given asset upload has completed. It will be removed and its purpose\n    // returned. If no matching upload exists, returns undefined.\n\n    check(id, String);\n\n    const result = this.collections.assetUploadTokens.findAndModify({\n      query: { _id: id },\n      remove: true,\n    });\n\n    if (!result.ok) {\n      throw new Error(\"Failed to remove asset upload token\");\n    }\n\n    const upload = result.value;\n\n    if (upload.expires.valueOf() < Date.now()) {\n      return undefined;  // already expired\n    } else {\n      return upload.purpose;\n    }\n  };\n\n  SandstormDb.prototype.cleanupExpiredAssetUploads = function () {\n    this.collections.assetUploadTokens.remove({ expires: { $lt: Date.now() } });\n  };\n\n  // TODO(cleanup): lift this out of the package so it can share with the ones in async-helpers.js\n  const Future = Npm.require(\"fibers/future\");\n  const promiseToFuture = (promise) => {\n    const result = new Future();\n    promise.then(result.return.bind(result), result.throw.bind(result));\n    return result;\n  };\n\n  const waitPromise = (promise) => {\n    return promiseToFuture(promise).wait();\n  };\n\n  SandstormDb.prototype.deleteGrains = function (query, backend, type) {\n    // Returns the number of grains deleted.\n\n    check(type, Match.OneOf(\"grain\", \"demoGrain\"));\n\n    let numDeleted = 0;\n    this.collections.grains.find(query).forEach((grain) => {\n      const user = Meteor.users.findOne(grain.userId);\n\n      waitPromise(backend.deleteGrain(grain._id, grain.userId));\n      numDeleted += this.collections.grains.remove({ _id: grain._id });\n      this.removeApiTokens({\n        grainId: grain._id,\n        $or: [\n          { owner: { $exists: false } },\n          { owner: { webkey: null } },\n        ],\n      });\n\n      this.removeApiTokens({ \"owner.grain.grainId\": grain._id });\n\n      this.collections.activitySubscriptions.remove({ grainId: grain._id });\n\n      if (grain.lastUsed) {\n        const record = {\n          type: \"grain\",  // Demo grains can never get here!\n          lastActive: grain.lastUsed,\n          appId: grain.appId,\n        };\n        if (user && user.experiments) {\n          record.experiments = user.experiments;\n        }\n\n        this.collections.deleteStats.insert(record);\n      }\n\n      this.deleteUnusedPackages(grain.appId);\n\n      if (grain.size) {\n        Meteor.users.update(grain.userId, { $inc: { storageUsage: -grain.size } });\n      }\n    });\n    return numDeleted;\n  };\n\n  SandstormDb.prototype.userGrainTitle = function (grainId, accountId, identityId) {\n    check(grainId, String);\n    check(accountId, Match.OneOf(String, undefined, null));\n    check(identityId, String);\n\n    const grain = this.getGrain(grainId);\n    if (!grain) {\n      throw new Error(\"called userGrainTitle() for a grain that doesn't exist\");\n    }\n\n    let title = grain.title;\n    if (grain.userId !== accountId) {\n      const sharerToken = this.collections.apiTokens.findOne({\n        grainId: grainId,\n        \"owner.user.identityId\": identityId,\n      }, {\n        sort: {\n          lastUsed: -1,\n        },\n      });\n      if (sharerToken) {\n        title = sharerToken.owner.user.title;\n      } else {\n        title = \"shared grain\";\n      }\n    }\n\n    return title;\n  };\n\n  const packageCache = {};\n  // Package info is immutable. Let's cache to save on mongo queries.\n\n  SandstormDb.prototype.getPackage = function (packageId) {\n    // Get the given package record. Since package info is immutable, cache the data in the server\n    // to reduce mongo query overhead, since it turns out we have to fetch specific packages a\n    // lot.\n\n    if (packageId in packageCache) {\n      return packageCache[packageId];\n    }\n\n    const pkg = this.collections.packages.findOne(packageId);\n    if (pkg && pkg.status === \"ready\") {\n      packageCache[packageId] = pkg;\n    }\n\n    return pkg;\n  };\n\n  SandstormDb.prototype.deleteUnusedPackages = function (appId) {\n    check(appId, String);\n    this.collections.packages.find({ appId: appId }).forEach((pkg) => {\n      // Mark package for possible deletion;\n      this.collections.packages.update({ _id: pkg._id, status: \"ready\" }, { $set: { shouldCleanup: true } });\n    });\n  };\n\n  SandstormDb.prototype.sendAppUpdateNotifications = function (appId, packageId, name,\n                                                               versionNumber, marketingVersion) {\n    const actions = this.collections.userActions.find({ appId: appId, appVersion: { $lt: versionNumber } },\n      { fields: { userId: 1 } });\n    actions.forEach((action) => {\n      const userId = action.userId;\n      const updater = {\n        timestamp: new Date(),\n        isUnread: true,\n      };\n      const inserter = _.extend({ userId, appUpdates: {} }, updater);\n\n      // Set only the appId that we care about. Use mongo's dot notation to specify only a single\n      // field inside of an object to update\n      inserter.appUpdates[appId] = updater[\"appUpdates.\" + appId] = {\n        marketingVersion: marketingVersion,\n        packageId: packageId,\n        name: name,\n        version: versionNumber,\n      };\n\n      // We unfortunately cannot upsert because upserts can only have field equality conditions in\n      // the query. If we try to upsert, Mongo complaints that \"$exists\" isn't valid to store.\n      if (this.collections.notifications.update(\n          { userId: userId, appUpdates: { $exists: true } },\n          { $set: updater }) == 0) {\n        // Update failed; try an insert instead.\n        this.collections.notifications.insert(inserter);\n      }\n    });\n\n    this.collections.appIndex.update({ _id: appId }, { $set: { hasSentNotifications: true } });\n\n    // In the case where we replaced a previous notification and that was the only reference to the\n    // package, we need to clean it up\n    this.deleteUnusedPackages(appId);\n  };\n\n  SandstormDb.prototype.sendReferralProgramNotification = function (userId) {\n    this.collections.notifications.upsert({\n      userId: userId,\n      referral: true,\n    }, {\n      userId: userId,\n      referral: true,\n      timestamp: new Date(),\n      isUnread: true,\n    });\n  };\n\n  SandstormDb.prototype.upgradeGrains =  function (appId, version, packageId, backend) {\n    check(appId, String);\n    check(version, Match.Integer);\n    check(packageId, String);\n\n    const selector = {\n      userId: Meteor.userId(),\n      appId: appId,\n      appVersion: { $lte: version },\n      packageId: { $ne: packageId },\n    };\n\n    this.collections.grains.find(selector).forEach(function (grain) {\n      backend.shutdownGrain(grain._id, grain.userId);\n    });\n\n    this.collections.grains.update(selector, {\n      $set: { appVersion: version, packageId: packageId, packageSalt: Random.secret() },\n    }, { multi: true });\n  };\n\n  SandstormDb.prototype.startInstall = function (packageId, url, retryFailed, isAutoUpdated) {\n    // Mark package for possible installation.\n\n    const fields = {\n      status: \"download\",\n      progress: 0,\n      url: url,\n      isAutoUpdated: !!isAutoUpdated,\n    };\n\n    if (retryFailed) {\n      this.collections.packages.update({ _id: packageId, status: \"failed\" }, { $set: fields });\n    } else {\n      try {\n        fields._id = packageId;\n        this.collections.packages.insert(fields);\n      } catch (err) {\n        console.error(\"Simultaneous startInstall()s?\", err.stack);\n      }\n    }\n  };\n\n  const ValidKeyFingerprint = Match.Where(function (keyFingerprint) {\n    check(keyFingerprint, String);\n    return !!keyFingerprint.match(/^[0-9A-F]{40}$/);\n  });\n\n  SandstormDb.prototype.updateKeybaseProfileAsync = function (keyFingerprint) {\n    // Asynchronously fetch the given Keybase profile and populate the KeybaseProfiles collection.\n\n    check(keyFingerprint, ValidKeyFingerprint);\n\n    console.log(\"fetching keybase\", keyFingerprint);\n\n    HTTP.get(\n        \"https://keybase.io/_/api/1.0/user/lookup.json?key_fingerprint=\" + keyFingerprint +\n        \"&fields=basics,profile,proofs_summary\", {\n      timeout: 5000,\n    }, (err, keybaseResponse) => {\n      if (err) {\n        console.log(\"keybase lookup error:\", err.stack);\n        return;\n      }\n\n      if (!keybaseResponse.data) {\n        console.log(\"keybase didn't return JSON? Headers:\", keybaseResponse.headers);\n        return;\n      }\n\n      const profile = (keybaseResponse.data.them || [])[0];\n\n      if (profile) {\n        // jscs:disable requireCamelCaseOrUpperCaseIdentifiers\n        const record = {\n          displayName: (profile.profile || {}).full_name,\n          handle: (profile.basics || {}).username,\n          proofs: (profile.proofs_summary || {}).all || [],\n        };\n        // jscs:enable requireCamelCaseOrUpperCaseIdentifiers\n\n        record.proofs.forEach(function (proof) {\n          // Remove potentially Mongo-incompatible stuff. (Currently Keybase returns nothing that\n          // this would filter.)\n          for (let field in proof) {\n            // Don't allow field names containing '.' or '$'. Also don't allow sub-objects mainly\n            // because I'm too lazy to check the field names recursively (and Keybase doesn't\n            // return any objects anyway).\n            if (field.match(/[.$]/) || typeof (proof[field]) === \"object\") {\n              delete proof[field];\n            }\n          }\n\n          // Indicate not verified.\n          // TODO(security): Asynchronously verify proofs. Presumably we can borrow code from the\n          //   Keybase node-based CLI.\n          proof.status = \"unverified\";\n        });\n\n        this.collections.keybaseProfiles.update(keyFingerprint, { $set: record }, { upsert: true });\n      } else {\n        // Keybase reports no match, so remove what we know of this user. We don't want to remove\n        // the item entirely from the cache as this will cause us to repeatedly re-fetch the data\n        // from Keybase.\n        //\n        // TODO(someday): We could perhaps keep the proofs if we can still verify them directly,\n        //   but at present we don't have the ability to verify proofs.\n        this.collections.keybaseProfiles.update(keyFingerprint,\n            { $unset: { displayName: \"\", handle: \"\", proofs: \"\" } }, { upsert: true });\n      }\n    });\n  };\n\n  SandstormDb.prototype.deleteUnusedAccount = function (backend, identityId) {\n    // If there is an *unused* account that has `identityId` as a login identity, deletes it.\n\n    check(identityId, String);\n    const account = this.collections.users.findOne({ \"loginIdentities.id\": identityId });\n    if (account &&\n        account.loginIdentities.length == 1 &&\n        account.nonloginIdentities.length == 0 &&\n        !this.collections.grains.findOne({ userId: account._id }) &&\n        !this.collections.apiTokens.findOne({ accountId: account._id }) &&\n        (!account.plan || account.plan === \"free\") &&\n        !(account.payments && account.payments.id) &&\n        !this.collections.contacts.findOne({ ownerId: account._id })) {\n      this.collections.users.remove({ _id: account._id });\n      backend.deleteUser(account._id);\n    }\n  };\n\n  Meteor.publish(\"keybaseProfile\", function (keyFingerprint) {\n    check(keyFingerprint, ValidKeyFingerprint);\n    const db = this.connection.sandstormDb;\n\n    const cursor = db.collections.keybaseProfiles.find(keyFingerprint);\n    if (cursor.count() === 0) {\n      // Fire off async update.\n      db.updateKeybaseProfileAsync(keyFingerprint);\n    }\n\n    return cursor;\n  });\n\n  Meteor.publish(\"appIndex\", function (appId) {\n    check(appId, String);\n    const db = this.connection.sandstormDb;\n    const cursor = db.collections.appIndex.find({ _id: appId });\n    return cursor;\n  });\n\n  Meteor.publish(\"userPackages\", function () {\n    // Users should be able to see packages that are either:\n    // 1. referenced by one of their userActions\n    // 2. referenced by one of their grains\n    const db = this.connection.sandstormDb;\n\n    // Note that package information, once it is in the database, is static. There's no need to\n    // reactively subscribe to changes to a package since they don't change. It's also unecessary\n    // to reactively remove a package from the client side when it is removed on the server, or\n    // when the client stops using it, because the worst case is the client has a small amount\n    // of extra info on a no-longer-used package held in memory until they refresh Sandstorm.\n    // So, we implement this as a cache: the first time each package ID shows up among the user's\n    // stuff, we push the package info to the client, and then we never update it.\n    //\n    // Alternatively, we could subscribe to each individual package query, but this would waste\n    // lots of server-side resources watching for events that will never happen or don't matter.\n    const hasPackage = {};\n    const refPackage = (packageId) => {\n      // Ignore dev apps.\n      if (packageId.lastIndexOf(\"dev-\", 0) === 0) return;\n\n      if (!hasPackage[packageId]) {\n        hasPackage[packageId] = true;\n        const pkg = db.getPackage(packageId);\n        if (pkg) {\n          this.added(\"packages\", packageId, pkg);\n        } else {\n          console.error(\n              \"shouldn't happen: missing package referenced by user's stuff:\", packageId);\n        }\n      }\n    };\n\n    // package source 1: packages referred to by actions\n    const actions = db.userActions(this.userId);\n    const actionsHandle = actions.observe({\n      added(newAction) {\n        refPackage(newAction.packageId);\n      },\n\n      changed(newAction, oldAction) {\n        refPackage(newAction.packageId);\n      },\n    });\n\n    // package source 2: packages referred to by grains directly\n    const grains = db.userGrains(this.userId, { includeTrash: true });\n    const grainsHandle = grains.observe({\n      added(newGrain) {\n        // Watch out: DevApp grains can lack a packageId.\n        if (newGrain.packageId) {\n          refPackage(newGrain.packageId);\n        }\n      },\n\n      changed(newGrain, oldGrain) {\n        // Watch out: DevApp grains can lack a packageId.\n        if (newGrain.packageId) {\n          refPackage(newGrain.packageId);\n        }\n      },\n    });\n\n    this.onStop(function () {\n      actionsHandle.stop();\n      grainsHandle.stop();\n    });\n\n    this.ready();\n  });\n}\n\nif (Meteor.isServer) {\n  SandstormDb.prototype.deleteIdentity = function (identityId) {\n    check(identityId, String);\n\n    this.removeApiTokens({ \"owner.user.identityId\": identityId });\n    this.collections.contacts.remove({ identityId: identityId });\n    Meteor.users.remove({ _id: identityId });\n  };\n\n  SandstormDb.prototype.deleteAccount = function (userId, backend) {\n    check(userId, String);\n\n    const _this = this;\n    const user = Meteor.users.findOne({ _id: userId });\n    this.deleteGrains({ userId: userId }, backend, \"grain\");\n    this.collections.userActions.remove({ userId: userId });\n    this.collections.notifications.remove({ userId: userId });\n    user.loginIdentities.forEach((identity) => {\n      if (Meteor.users.find({ $or: [\n        { \"loginIdentities.id\": identity.id },\n        { \"nonloginIdentities.id\": identity.id },\n      ], }).count() === 1) {\n        // If this is the only account with the identity, then delete it\n        _this.deleteIdentity(identity.id);\n      }\n    });\n    user.nonloginIdentities.forEach((identity) => {\n      if (Meteor.users.find({ $or: [\n        { \"loginIdentities.id\": identity.id },\n        { \"nonloginIdentities.id\": identity.id },\n      ], }).count() === 1) {\n        // If this is the only account with the identity, then delete it\n        _this.deleteIdentity(identity.id);\n      }\n    });\n    this.collections.contacts.remove({ ownerId: userId });\n    backend.deleteUser(userId);\n    Meteor.users.remove({ _id: userId });\n  };\n}\n\nMeteor.methods({\n  addUserActions(packageId) {\n    check(packageId, String);\n    if (!this.userId || !Meteor.user().loginIdentities || !isSignedUpOrDemo()) {\n      throw new Meteor.Exception(403, \"Must be logged in as a non-guest to add app actions.\");\n    }\n\n    if (this.isSimulation) {\n      // TODO(cleanup): Appdemo code relies on this being simulated client-side but we don't have\n      //   a proper DB object to use.\n      new SandstormDb().addUserActions(this.userId, packageId, true);\n    } else {\n      this.connection.sandstormDb.addUserActions(this.userId, packageId);\n    }\n  },\n\n  removeUserAction(actionId) {\n    check(actionId, String);\n    if (this.isSimulation) {\n      UserActions.remove({ _id: actionId });\n    } else {\n      if (this.userId) {\n        const result = this.connection.sandstormDb.collections.userActions.findAndModify({\n          query: { _id: actionId, userId: this.userId },\n          remove: true,\n        });\n\n        if (!result.ok) {\n          throw new Error(`Couldn't remove user action ${actionId}`);\n        }\n\n        const action = result.value;\n        if (action) {\n          this.connection.sandstormDb.deleteUnusedPackages(action.appId);\n        }\n      }\n    }\n  },\n});\n", "import crypto from \"crypto\";\n\nimport { send as sendEmail } from \"/imports/server/email.js\";\n\nconst Url = Npm.require(\"url\");\n\nconst V1_ROUNDS = 4096; // Selected to take ~5msec at creation time (2016) on a developer's laptop.\nconst V1_KEYSIZE = 32; // 256 bits / 8 bits/byte = 32 bytes\nconst V1_HASHFUNC = \"sha512\";\n// ^ hash function used with pbkdf2.  Chosen to be different from the function which maps the token\n// to the value stored in the database.  Note that the first thing that pbkdf2 does is\n// HMAC(HASHFUNC, key, salt), and the first thing that HMAC does is either pad or hash the key to\n// make it the appropriate width.  The result is that knowing sha256(key) and the salt is possibly\n// sufficient to reconstruct the output of pbkdf2().\nconst V1_CIPHER = \"AES-256-CTR\"; // cipher used\n\nconst TOKEN_EXPIRATION_MS = 60 * 60 * 1000;\n\nconst cleanupExpiredTokens = function () {\n  Meteor.users.update({\n    \"services.email.tokens.createdAt\": {\n      $lt: new Date(Date.now() - TOKEN_EXPIRATION_MS),\n    },\n  }, {\n    $pull: {\n      \"services.email.tokens\": {\n        createdAt: { $lt: new Date(Date.now() - TOKEN_EXPIRATION_MS) },\n      },\n    },\n  }, {\n    multi: true,\n  });\n};\n\nMeteor.startup(cleanupExpiredTokens);\n// Tokens can actually last up to 2 * TOKEN_EXPIRATION_MS\nSandstormDb.periodicCleanup(TOKEN_EXPIRATION_MS, cleanupExpiredTokens);\n\nconst hashToken = (token) => {\n  return {\n    digest: SHA256(token),\n    algorithm: \"sha-256\",\n  };\n};\n\nconst checkToken = function (tokens, token) {\n  // Looks for an object in `tokens` with `algorithm` and `digest` fields matching those in `token`.\n  // Returns the matching object, if one is found, or undefined if none match.\n  let foundToken = undefined;\n  tokens.forEach(function (userToken) {\n    if ((userToken.algorithm === token.algorithm) &&\n       (userToken.digest === token.digest)) {\n      foundToken = userToken;\n    }\n  });\n\n  return foundToken;\n};\n\nconst consumeToken = function (user, token) {\n  const hashedToken = hashToken(token);\n  const foundToken = checkToken(user.services.email.tokens, hashedToken);\n\n  if (foundToken !== undefined) {\n    Meteor.users.update({ _id: user._id }, { $pull: { \"services.email.tokens\": hashedToken } });\n  }\n\n  return foundToken;\n};\n\nconst makeBox = function (token, plaintext) {\n  // Encrypt plaintext symmetrically with a key derived from token.  Returns an object with\n  // ciphertext and associated data needed to decrypt later.\n\n  // Produce a symmetric key.  Note that the token itself does not have sufficient entropy to\n  // be used as a key directly, so we need to use a KDF with a strong random salt.\n  // In the fullness of time, it might be nice to move away from using a KDF (which blocks the whole\n  // node process) in favor of the token itself having enough entropy to serve as the key itself.\n  // This would require lengthening the token, which would make the manual-code-entry workflow\n  // worse, so I'm punting on that for now.\n  const salt = Random.secret(16);\n  const key = crypto.pbkdf2Sync(token, salt, V1_ROUNDS, V1_KEYSIZE, V1_HASHFUNC);\n  const iv = crypto.randomBytes(16);\n  const cipher = crypto.createCipheriv(V1_CIPHER, key, iv);\n  let ciphertext = cipher.update(new Buffer(plaintext, \"binary\"));\n  return {\n    version: 1,\n    salt: salt,\n    iv: iv.toString(\"base64\"),\n    boxedValue: ciphertext.toString(\"base64\"),\n  };\n};\n\nconst tryUnbox = function (box, secret) {\n  if (box) {\n    if (box.version === 1) {\n      const key = crypto.pbkdf2Sync(secret, box.salt, V1_ROUNDS, V1_KEYSIZE, V1_HASHFUNC);\n      const iv = new Buffer(box.iv, \"base64\");\n      const cipher = crypto.createDecipheriv(V1_CIPHER, key, iv);\n      const cipherText = new Buffer(box.boxedValue, \"base64\");\n      const plaintext = cipher.update(cipherText);\n      return plaintext.toString(\"binary\");\n    }\n  }\n\n  // If no box was provided, or it was of an unknown version, return no data.\n  return;\n};\n\n// Handler to login with a token.\nAccounts.registerLoginHandler(\"email\", function (options) {\n  if (!options.email) {\n    return undefined; // don't handle\n  }\n\n  if (!Accounts.identityServices.email.isEnabled()) {\n    throw new Meteor.Error(403, \"Email identity service is disabled.\");\n  }\n\n  options = options.email;\n  check(options, {\n    email: String,\n    token: String,\n  });\n\n  const user = Meteor.users.findOne({\n    \"services.email.email\": options.email,\n  }, {\n    fields: {\n      \"services.email\": 1,\n    },\n  });\n\n  if (!user) {\n    console.error(\"User not found:\", options.email);\n    return {\n      error: new Meteor.Error(403, \"User not found\"),\n    };\n  }\n\n  if (!user.services.email.tokens) {\n    console.error(\"User has no token set:\", options.email);\n    return {\n      error: new Meteor.Error(403, \"User has no token set\"),\n    };\n  }\n\n  const tokenString = options.token.trim();\n  const maybeToken = consumeToken(user, tokenString);\n  if (!maybeToken) {\n    console.error(\"Token not found:\", options.email);\n    return {\n      error: new Meteor.Error(403, \"Invalid authentication code\"),\n    };\n  }\n\n  // Attempt to decrypt the resumePath, if provided.\n  const resumePath = tryUnbox(maybeToken.secureBox, tokenString);\n\n  return {\n    userId: user._id,\n    options: {\n      resumePath,\n    },\n  };\n});\n\nconst makeTokenUrl = function (email, token, options) {\n  if (options.linking) {\n    return options.rootUrl + \"/_emailLinkIdentity/\" + encodeURIComponent(email) + \"/\" +\n      encodeURIComponent(token) + \"/\" + Meteor.userId() +\n      \"?allowLogin=\" + options.linking.allowLogin;\n  } else {\n    return options.rootUrl + \"/_emailLogin/\" + encodeURIComponent(email) + \"/\" + encodeURIComponent(token);\n  }\n};\n\n///\n/// EMAIL VERIFICATION\n///\nconst sendTokenEmail = function (db, email, token, options) {\n  let subject;\n  let text;\n\n  const rootHostname = Url.parse(options.rootUrl).hostname;\n\n  if (!options.linking) {\n    subject = \"Log in to \" + rootHostname;\n    text = \"To confirm this email address on \";\n  } else {\n    subject = \"Confirm this email address on \" + rootHostname;\n    text = \"To confirm this email address on \";\n  }\n\n  text = text + rootHostname + \", click on the following link:\\n\\n\" +\n      makeTokenUrl(email, token, options) + \"\\n\\n\" +\n      \"Alternatively, enter the following one-time authentication code into the log-in form:\\n\\n\" +\n      token;\n\n  const sendOptions = {\n    to:  email,\n    from: db.getServerTitle() + \" <\" + db.getReturnAddress() + \">\",\n    subject: subject,\n    text: text,\n  };\n\n  sendEmail(sendOptions);\n};\n\nconst parsedRootUrl = Url.parse(process.env.ROOT_URL);\n///\n/// CREATING USERS\n///\n// returns the user id\nconst createAndEmailTokenForUser = function (db, email, options) {\n  check(email, String);\n  check(options, {\n    resumePath: String,\n    linking: Match.Optional({ allowLogin: Boolean }),\n    rootUrl: String,\n  });\n\n  const parsedUrl = Url.parse(options.rootUrl);\n  if ((parsedUrl.hostname !== parsedRootUrl.hostname ||\n       parsedUrl.protocol !== parsedRootUrl.protocol) &&\n      !db.hostIsStandalone(parsedUrl.hostname)) {\n    // Ignore port and only check hostname/protocol since IE will differ from other browsers and\n    // sometimes include port 80/443 and sometimes won't\n    throw new Meteor.Error(400, \"rootUrl is not valid\");\n  }\n\n  const atIndex = email.indexOf(\"@\");\n  if (atIndex === -1) {\n    throw new Meteor.Error(400, \"No @ symbol was found in your email\");\n  }\n\n  let user = Meteor.users.findOne({ \"services.email.email\": email },\n                                  { fields: { \"services.email\": 1 } });\n  let userId;\n\n  // TODO(someday): make this shorter, and handle requests that try to brute force it.\n  // Alternately, require using the link over copy/pasting the code, and crank up the entropy.\n  const token = Random.id(12);\n  const tokenObj = hashToken(token);\n  tokenObj.createdAt = new Date();\n  tokenObj.secureBox = makeBox(token, options.resumePath);\n\n  if (user) {\n    if (user.services.email.tokens && user.services.email.tokens.length > 2) {\n      throw new Meteor.Error(\n        \"alreadySentEmailToken\",\n        \"It looks like we sent a log in email to this address not long \" +\n        \"ago. Please use the one that was already sent (check your spam folder if you can't find \" +\n        \"it), or wait a while and try again.\");\n    }\n\n    userId = user._id;\n\n    Meteor.users.update({ _id: user._id }, { $push: { \"services.email.tokens\": tokenObj } });\n  } else {\n    const options = {};\n    user = {\n      services: {\n        email: {\n          tokens: [tokenObj],\n          email: email,\n        },\n      },\n    };\n\n    userId = Accounts.insertUserDoc(options, user);\n  }\n\n  sendTokenEmail(db, email, token, options);\n\n  return userId;\n};\n\nMeteor.methods({\n  createAndEmailTokenForUser: function (email, options) {\n    // method for create user. Requests come from the client.\n    // This method will create a user if it doesn't exist, otherwise it will generate a token.\n    // It will always send an email to the user\n\n    check(email, String);\n    check(options, {\n      resumePath: String,\n      linking: Match.Optional({ allowLogin: Boolean }),\n      rootUrl: String,\n    });\n\n    if (!Accounts.identityServices.email.isEnabled()) {\n      throw new Meteor.Error(403, \"Email identity service is disabled.\");\n    }\n    // Create user. result contains id and token.\n    const user = createAndEmailTokenForUser(this.connection.sandstormDb, email, options);\n  },\n\n  linkEmailIdentityToAccount: function (email, token, allowLogin) {\n    // Links the email identity with address `email` and login token `token` to the current account.\n    check(email, String);\n    check(token, String);\n    check(allowLogin, Boolean);\n    const account = Meteor.user();\n    if (!account || !account.loginIdentities) {\n      throw new Meteor.Error(403, \"Must be logged in to an account to link an email identity.\");\n    }\n\n    const identity = Meteor.users.findOne({ \"services.email.email\": email },\n                                          { fields: { \"services.email\": 1 } });\n    if (!identity) {\n      throw new Meteor.Error(403, \"Invalid authentication code.\");\n    }\n\n    const maybeToken = consumeToken(identity, token.trim());\n    if (!maybeToken) {\n      throw new Meteor.Error(403, \"Invalid authentication code.\");\n    }\n\n    Accounts.linkIdentityToAccount(this.connection.sandstormDb, this.connection.sandstormBackend,\n                                   identity._id, account._id, allowLogin);\n\n    // Return the resume path, if we have one.\n    const resumePath = tryUnbox(maybeToken.secureBox, token);\n    return resumePath;\n  },\n});\n", "// Sandstorm - Personal Cloud Sandbox\n// Copyright (c) 2014 Sandstorm Development Group, Inc. and contributors\n// All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Meteor } from \"meteor/meteor\";\nimport Fs from \"fs\";\nimport Crypto from \"crypto\";\nimport Heapdump from \"heapdump\";\nimport { SANDSTORM_LOGDIR } from \"/imports/server/constants.js\";\nimport { clearAdminToken, checkAuth, tokenIsValid, tokenIsSetupSession } from \"/imports/server/auth.js\";\nimport { send as sendEmail } from \"/imports/server/email.js\";\nimport { fillUndefinedForChangedDoc } from \"/imports/server/observe-helpers.js\";\n\nconst publicAdminSettings = [\n  \"google\", \"github\", \"ldap\", \"saml\", \"emailToken\", \"splashUrl\", \"signupDialog\",\n  \"adminAlert\", \"adminAlertTime\", \"adminAlertUrl\", \"termsUrl\",\n  \"privacyUrl\", \"appMarketUrl\", \"appIndexUrl\", \"appUpdatesEnabled\",\n  \"serverTitle\", \"returnAddress\", \"ldapNameField\", \"organizationMembership\",\n  \"organizationSettings\",\n  \"whitelabelCustomLoginProviderName\",\n  \"whitelabelCustomLogoAssetId\",\n  \"whitelabelHideSendFeedback\",\n  \"whitelabelHideTroubleshooting\",\n  \"whiteLabelHideAbout\",\n  \"whitelabelUseServerTitleForHomeText\",\n  \"quotaEnabled\",\n  \"quotaLdapEnabled\",\n  \"billingPromptUrl\",\n];\n\nconst smtpConfigShape = {\n  hostname: String,\n  port: Number,\n  auth: {\n    user: String,\n    pass: String,\n  },\n  returnAddress: String,\n};\n\nMeteor.methods({\n  setAccountSetting: function (token, serviceName, value) {\n    checkAuth(token);\n    check(serviceName, String);\n    check(value, Boolean);\n\n    // TODO(someday): currently this relies on the fact that an account is tied to a single\n    // identity, and thus has only that entry in \"services\". This will need to be looked at when\n    // multiple login methods/identities are allowed for a single account.\n    if (!value && !tokenIsValid(token) && !tokenIsSetupSession(token) && (serviceName in Meteor.user().services)) {\n      throw new Meteor.Error(403,\n        \"You can not disable the login service that your account uses.\");\n    }\n\n    // Only check configurations for OAuth services.\n    const oauthServices = [\"google\", \"github\"];\n    if (value && (oauthServices.indexOf(serviceName) != -1)) {\n      const config = ServiceConfiguration.configurations.findOne({ service: serviceName });\n      if (!config) {\n        throw new Meteor.Error(403, \"You must configure the \" + serviceName +\n          \" service before you can enable it. Click the \\\"configure\\\" link.\");\n      }\n\n      if (!config.clientId || !config.secret) {\n        throw new Meteor.Error(403, \"You must provide a non-empty clientId and secret for the \" +\n          serviceName + \" service before you can enable it. Click the \\\"configure\\\" link.\");\n      }\n    }\n\n    Settings.upsert({ _id: serviceName }, { $set: { value: value } });\n    if (value) {\n      Settings.update({ _id: serviceName }, { $unset: { automaticallyReset: 1 } });\n    }\n  },\n\n  setSmtpConfig: function (token, config) {\n    checkAuth(token);\n    check(config, smtpConfigShape);\n\n    Settings.upsert({ _id: \"smtpConfig\" }, { $set: { value: config } });\n  },\n\n  disableEmail: function (token) {\n    checkAuth(token);\n\n    const db = this.connection.sandstormDb;\n    db.collections.settings.update({ _id: \"smtpConfig\" }, { $set: { \"value.hostname\": \"\" } });\n  },\n\n  setSetting: function (token, name, value) {\n    checkAuth(token);\n    check(name, String);\n    check(value, Match.OneOf(null, String, Date, Boolean));\n\n    Settings.upsert({ _id: name }, { $set: { value: value } });\n  },\n\n  saveOrganizationSettings(token, params) {\n    checkAuth(token);\n    check(params, {\n      membership: {\n        emailToken: {\n          enabled: Boolean,\n          domain: String,\n        },\n        google: {\n          enabled: Boolean,\n          domain: String,\n        },\n        ldap: {\n          enabled: Boolean,\n        },\n        saml: {\n          enabled: Boolean,\n        },\n      },\n      settings: {\n        disallowGuests: Boolean,\n        shareContacts: Boolean,\n      },\n    });\n\n    this.connection.sandstormDb.collections.settings.upsert({ _id: \"organizationMembership\" }, { value: params.membership });\n    this.connection.sandstormDb.collections.settings.upsert({ _id: \"organizationSettings\" }, { value: params.settings });\n  },\n\n  adminConfigureLoginService: function (token, options) {\n    checkAuth(token);\n    check(options, Match.ObjectIncluding({ service: String }));\n\n    ServiceConfiguration.configurations.upsert({ service: options.service }, options);\n  },\n\n  clearResumeTokensForService: function (token, serviceName) {\n    checkAuth(token);\n    check(serviceName, String);\n\n    const query = {};\n    query[\"services.\" + serviceName] = { $exists: true };\n    Meteor.users.find(query).forEach(function (identity) {\n      if (identity.services.resume && identity.services.resume.loginTokens &&\n          identity.services.resume.loginTokens.length > 0) {\n        Meteor.users.update({ _id: identity._id }, { $set: { \"services.resume.loginTokens\": [] } });\n      }\n\n      Meteor.users.update({ \"loginIdentities.id\": identity._id },\n                          { $set: { \"services.resume.loginTokens\": [] } });\n    });\n  },\n\n  adminUpdateUser: function (token, userInfo) {\n    checkAuth(token);\n    check(userInfo, {\n      userId: String,\n      signupKey: Boolean,\n      isAdmin: Boolean,\n    });\n\n    const userId = userInfo.userId;\n    if (userId === Meteor.userId() && !userInfo.isAdmin) {\n      throw new Meteor.Error(403, \"User cannot remove admin permissions from itself.\");\n    }\n\n    Meteor.users.update({ _id: userId }, { $set: _.omit(userInfo, [\"_id\", \"userId\"]) });\n  },\n\n  testSend: function (token, smtpConfig, to) {\n    checkAuth(token);\n    check(smtpConfig, smtpConfigShape);\n    check(to, String);\n    const { returnAddress, ...restConfig } = smtpConfig;\n\n    try {\n      sendEmail({\n        to: to,\n        from: globalDb.getServerTitle() + \" <\" + returnAddress + \">\",\n        subject: \"Testing your Sandstorm's SMTP setting\",\n        text: \"Success! Your outgoing SMTP is working.\",\n        smtpConfig: restConfig,\n      });\n    } catch (e) {\n      // Attempt to give more accurate error messages for a variety of known failure modes,\n      // and the actual exception data in the event a user hits a new failure mode.\n      if (e.syscall === \"getaddrinfo\") {\n        if (e.code === \"EIO\" || e.code === \"ENOTFOUND\") {\n          throw new Meteor.Error(\"getaddrinfo \" + e.code, \"Couldn't resolve \\\"\" + smtpConfig.hostname + \"\\\" - check for typos or broken DNS.\");\n        }\n      } else if (e.syscall === \"connect\") {\n        if (e.code === \"ECONNREFUSED\") {\n          throw new Meteor.Error(\"connect ECONNREFUSED\", \"Server at \" + smtpConfig.hostname + \":\" + smtpConfig.port + \" refused connection.  Check your settings, firewall rules, and that your mail server is up.\");\n        }\n      } else if (e.name === \"AuthError\") {\n        throw new Meteor.Error(\"auth error\", \"Authentication failed.  Check your credentials.  Message from \" +\n                smtpConfig.hostname + \": \" + e.data);\n      }\n\n      throw new Meteor.Error(\"other-email-sending-error\", \"Error while trying to send test email: \" + JSON.stringify(e));\n    }\n  },\n\n  createSignupKey: function (token, note, quota) {\n    checkAuth(token);\n    check(note, String);\n    check(quota, Match.OneOf(undefined, null, Number));\n\n    const key = Random.id();\n    const content = { _id: key, used: false, note: note };\n    if (typeof quota === \"number\") content.quota = quota;\n    SignupKeys.insert(content);\n    return key;\n  },\n\n  sendInvites: function (token, origin, from, list, subject, message, quota) {\n    checkAuth(token);\n    check([origin, from, list, subject, message], [String]);\n    check(quota, Match.OneOf(undefined, null, Number));\n\n    if (!from.trim()) {\n      throw new Meteor.Error(403, \"Must enter 'from' address.\");\n    }\n\n    if (!list.trim()) {\n      throw new Meteor.Error(403, \"Must enter 'to' addresses.\");\n    }\n\n    this.unblock();\n\n    list = list.split(\"\\n\");\n    for (const i in list) {\n      const email = list[i].trim();\n\n      if (email) {\n        const key = Random.id();\n\n        const content = {\n          _id: key,\n          used: false,\n          note: \"E-mail invite to \" + email,\n          email: email,\n          definitelySent: false,\n        };\n        if (typeof quota === \"number\") content.quota = quota;\n        SignupKeys.insert(content);\n        sendEmail({\n          to: email,\n          from: from,\n          envelopeFrom: globalDb.getReturnAddress(),\n          subject: subject,\n          text: message.replace(/\\$KEY/g, origin + \"/signup/\" + key),\n        });\n        SignupKeys.update(key, { $set: { definitelySent: true } });\n      }\n    }\n\n    return { sent: true };\n  },\n\n  adminToggleDisableCap: function (token, capId, value) {\n    checkAuth(token);\n    check(capId, String);\n    check(value, Boolean);\n\n    if (value) {\n      ApiTokens.update({ _id: capId }, { $set: { revoked: true } });\n    } else {\n      ApiTokens.update({ _id: capId }, { $set: { revoked: false } });\n    }\n  },\n\n  updateQuotas: function (token, list, quota) {\n    checkAuth(token);\n    check(list, String);\n    check(quota, Match.OneOf(undefined, null, Number));\n\n    if (!list.trim()) {\n      throw new Meteor.Error(400, \"Must enter addresses.\");\n    }\n\n    const items = list.split(\"\\n\");\n    const invalid = [];\n    for (const i in items) {\n      const modifier = (typeof quota === \"number\") ? { $set: { quota: quota } }\n                                                 : { $unset: { quota: \"\" } };\n      let n = SignupKeys.update({ email: items[i] }, modifier, { multi: true });\n      n += Meteor.users.update({ signupEmail: items[i] }, modifier, { multi: true });\n\n      if (n < 1) invalid.push(items[i]);\n    }\n\n    if (invalid.length > 0) {\n      throw new Meteor.Error(404, \"These addresses did not map to any user nor invite: \" +\n          invalid.join(\", \"));\n    }\n  },\n\n  dismissAdminStatsNotifications: function (token) {\n    checkAuth(token);\n    globalDb.collections.notifications.remove({ \"admin.type\": \"reportStats\" });\n  },\n\n  signUpAsAdmin: function (token) {\n    check(token, String);\n    checkAuth(token);\n    if (!this.userId) {\n      throw new Meteor.Error(403, \"Must be logged in to sign up as admin.\");\n    }\n\n    if (!Meteor.user().loginIdentities) {\n      throw new Meteor.Error(403, \"Must be logged into an account to sign up as admin.\");\n    }\n\n    Meteor.users.update({ _id: this.userId }, { $set: { isAdmin: true, signupKey: \"admin\" } });\n    clearAdminToken(token);\n  },\n\n  redeemSetupToken(token) {\n    // Redeem an admin token into a setup session.\n    check(token, String);\n    if (tokenIsValid(token)) {\n      const sessId = Random.secret();\n      const creationDate = new Date();\n      const hashedSessionId = Crypto.createHash(\"sha256\").update(sessId).digest(\"base64\");\n      this.connection.sandstormDb.collections.setupSession.upsert({\n        _id: \"current-session\",\n      }, {\n        creationDate,\n        hashedSessionId,\n      });\n      // Then, invalidate the token, so one one else can use it.\n      clearAdminToken(token);\n      return sessId;\n    } else {\n      throw new Meteor.Error(401, \"Invalid setup token\");\n    }\n  },\n\n  heapdump() {\n    // Requests a heap dump. Intended for use by Sandstorm developers. Requires admin.\n    //\n    // Call this from the JS console like:\n    //   Meteor.call(\"heapdump\");\n\n    checkAuth();\n\n    // We use /var/log because it's a location in the container to which the front-end is allowed\n    // to write.\n    const name = \"/var/log/\" + Date.now() + \".heapsnapshot\";\n    Heapdump.writeSnapshot(name);\n    console.log(\"Wrote heapdump: /opt/sandstorm\" + name);\n    return name;\n  },\n\n  setPreinstalledApps: function (appAndPackageIds) {\n    checkAuth();\n    check(appAndPackageIds, [{ appId: String, packageId: String, }]);\n\n    this.connection.sandstormDb.setPreinstalledApps(appAndPackageIds);\n  },\n});\n\nconst authorizedAsAdmin = function (token, userId) {\n  return Match.test(token, Match.OneOf(undefined, null, String)) &&\n         ((userId && isAdminById(userId)) || tokenIsValid(token) || tokenIsSetupSession(token));\n};\n\nMeteor.publish(\"admin\", function (token) {\n  if (!authorizedAsAdmin(token, this.userId)) return [];\n  return Settings.find();\n});\n\nMeteor.publish(\"adminServiceConfiguration\", function (token) {\n  if (!authorizedAsAdmin(token, this.userId)) return [];\n  return ServiceConfiguration.configurations.find();\n});\n\nMeteor.publish(\"publicAdminSettings\", function () {\n  return Settings.find({ _id: { $in: publicAdminSettings } });\n});\n\nMeteor.publish(\"adminToken\", function (token) {\n  check(token, String);\n  this.added(\"adminToken\", \"adminToken\", { tokenIsValid: tokenIsValid(token) || tokenIsSetupSession(token) });\n  this.ready();\n});\n\nMeteor.publish(\"allUsers\", function (token) {\n  if (!authorizedAsAdmin(token, this.userId)) return [];\n  return Meteor.users.find();\n});\n\nMeteor.publish(\"adminUserDetails\", function (userId) {\n  if (!authorizedAsAdmin(undefined, this.userId)) return [];\n\n  // Reactive publish of any identities owned by the account with id userId,\n  // as well as that user object itself.\n  const identitySubs = {};\n  const accountId = userId;\n\n  const unrefIdentity = (identityId) => {\n    if (!identitySubs[identityId]) {\n      // should never happen, but if somehow you attempt to unref an identity that we don't have a\n      // subscription to, then don't crash\n      console.error(\"attempted to unref untracked identity id:\", identityId);\n      return;\n    }\n\n    const observeHandle = identitySubs[identityId];\n    delete identitySubs[identityId];\n    observeHandle.stop();\n    this.removed(\"users\", identityId);\n  };\n\n  const refIdentity = (identityId) => {\n    if (identitySubs[identityId]) {\n      // should never happen, but if somehow an account wound up with a duplicate identity ID,\n      // avoid leaking a subscription\n      console.error(\"duplicate identity id:\", identityId);\n      return;\n    }\n\n    const cursor = Meteor.users.find({ _id: identityId });\n    const observeHandle = cursor.observe({\n      added: (doc) => {\n        this.added(\"users\", doc._id, doc);\n      },\n\n      changed: (newDoc, oldDoc) => {\n        fillUndefinedForChangedDoc(newDoc, oldDoc);\n        this.changed(\"users\", newDoc._id, newDoc);\n      },\n\n      removed: (oldDoc) => {\n        this.removed(\"users\", oldDoc._id);\n      },\n    });\n\n    identitySubs[identityId] = observeHandle;\n  };\n\n  const accountCursor = Meteor.users.find({ _id: accountId });\n  const accountSubHandle = accountCursor.observe({\n    added: (newDoc) => {\n      const newIdentities = SandstormDb.getUserIdentityIds(newDoc);\n      newIdentities.forEach((identityId) => {\n        refIdentity(identityId);\n      });\n\n      this.added(\"users\", newDoc._id, newDoc);\n    },\n\n    changed: (newDoc, oldDoc) => {\n      const newIdentities = SandstormDb.getUserIdentityIds(newDoc);\n      const oldIdentities = SandstormDb.getUserIdentityIds(oldDoc);\n\n      // Those in newDoc - oldDoc, ref.\n      const identitiesAdded = _.difference(newIdentities, oldIdentities);\n      identitiesAdded.forEach((identityId) => {\n        refIdentity(identityId);\n      });\n\n      // Those in oldDoc - newDoc, unref.\n      const identitiesRemoved = _.difference(oldIdentities, newIdentities);\n      identitiesRemoved.forEach((identityId) => {\n        unrefIdentity(identityId);\n      });\n\n      fillUndefinedForChangedDoc(newDoc, oldDoc);\n\n      this.changed(\"users\", newDoc._id, newDoc);\n    },\n\n    removed: (oldDoc) => {\n      this.removed(\"users\", oldDoc._id);\n      const oldIdentities = SandstormDb.getUserIdentityIds(oldDoc);\n      oldIdentities.forEach((identityId) => {\n        unrefIdentity(identityId);\n      });\n    },\n  });\n\n  this.onStop(() => {\n    accountSubHandle.stop();\n    // Also stop all the identity subscriptions.\n    const subs = _.values(identitySubs);\n    subs.forEach((sub) => {\n      sub.stop();\n    });\n  });\n\n  // Meteor's cursor.observe() will synchronously call all of the added() callbacks from the initial\n  // query, so by the time we get here we can report readiness.\n  this.ready();\n});\n\nMeteor.publish(\"activityStats\", function (token) {\n  if (!authorizedAsAdmin(token, this.userId)) return [];\n  return ActivityStats.find();\n});\n\nMeteor.publish(\"statsTokens\", function (token) {\n  if (!authorizedAsAdmin(token, this.userId)) return [];\n  return StatsTokens.find();\n});\n\nMeteor.publish(\"allPackages\", function (token) {\n  if (!authorizedAsAdmin(token, this.userId)) return [];\n  return Packages.find({ manifest: { $exists: true } },\n      { fields: { appId: 1, \"manifest.appVersion\": 1,\n      \"manifest.actions\": 1, \"manifest.appTitle\": 1, progress: 1, status: 1, }, });\n});\n\nMeteor.publish(\"realTimeStats\", function (token) {\n  if (!authorizedAsAdmin(token, this.userId)) return [];\n\n  // Last five minutes.\n  this.added(\"realTimeStats\", \"now\", computeStats(new Date(Date.now() - 5 * 60 * 1000)));\n\n  // Since last sample.\n  const lastSample = ActivityStats.findOne({}, { sort: { timestamp: -1 } });\n  const lastSampleTime = lastSample ? lastSample.timestamp : new Date(0);\n  this.added(\"realTimeStats\", \"today\", computeStats(lastSampleTime));\n\n  // TODO(someday): Update every few minutes?\n\n  this.ready();\n});\n\nMeteor.publish(\"adminLog\", function (token) {\n  if (!authorizedAsAdmin(token, this.userId)) return [];\n\n  const logfile = SANDSTORM_LOGDIR + \"/sandstorm.log\";\n\n  const fd = Fs.openSync(logfile, \"r\");\n  const startSize = Fs.fstatSync(fd).size;\n\n  // Difference between the current file offset and the subscription offset. Can be non-zero when\n  // logs have rotated.\n  let extraOffset = 0;\n\n  if (startSize < 8192) {\n    // Log size is less than window size. Check for rotated log and grab its tail.\n    const logfile1 = SANDSTORM_LOGDIR + \"/sandstorm.log.1\";\n    if (Fs.existsSync(logfile1)) {\n      const fd1 = Fs.openSync(logfile1, \"r\");\n      const startSize1 = Fs.fstatSync(fd1).size;\n      const amountFromLog1 = Math.min(startSize1, 8192 - startSize);\n      const offset1 = startSize1 - amountFromLog1;\n      const buf = new Buffer(amountFromLog1);\n      const n = Fs.readSync(fd1, buf, 0, buf.length, offset);\n      if (n > 0) {\n        this.added(\"adminLog\", 0, { text: buf.toString(\"utf8\", 0, n) });\n        extraOffset += n;\n      }\n    }\n  }\n\n  // Start tailing at EOF - 8k.\n  let offset = Math.max(0, startSize - 8192);\n\n  const _this = this;\n  function doTail() {\n    if (Fs.fstatSync(fd).size < offset) {\n      extraOffset += offset;\n      offset = 0;\n    }\n\n    for (;;) {\n      const buf = new Buffer(Math.max(1024, startSize - offset));\n      const n = Fs.readSync(fd, buf, 0, buf.length, offset);\n      if (n <= 0) break;\n      _this.added(\"adminLog\", offset + extraOffset, { text: buf.toString(\"utf8\", 0, n) });\n      offset += n;\n    }\n  }\n\n  // Watch the file for changes.\n  const watcher = Fs.watch(logfile, { persistent: false }, Meteor.bindEnvironment(doTail));\n\n  // When the subscription stops, stop watching the file.\n  this.onStop(function () {\n    watcher.close();\n    Fs.closeSync(fd);\n  });\n\n  // Read initial 8k tail data immediately.\n  doTail();\n\n  // Notify ready.\n  this.ready();\n});\n\nMeteor.publish(\"adminApiTokens\", function (token) {\n  if (!authorizedAsAdmin(token, this.userId)) return [];\n  return ApiTokens.find({\n    $or: [\n      { \"frontendRef.ipNetwork\": { $exists: true } },\n      { \"frontendRef.ipInterface\": { $exists: true } },\n    ],\n  }, {\n    fields: {\n      frontendRef: 1,\n      created: 1,\n      requirements: 1,\n      revoked: 1,\n      owner: 1,\n    },\n  });\n});\n\nMeteor.publish(\"hasAdmin\", function (token) {\n  // Like hasUsers, but for admins, and with token auth required.\n  if (!authorizedAsAdmin(token, this.userId)) return [];\n\n  // Query if there are any admin users.\n  const cursor = Meteor.users.find({ isAdmin: true });\n  if (cursor.count() > 0) {\n    this.added(\"hasAdmin\", \"hasAdmin\", { hasAdmin: true });\n  } else {\n    let handle = cursor.observeChanges({\n      added: (id) => {\n        this.added(\"hasAdmin\", \"hasAdmin\", { hasAdmin: true });\n        handle.stop();\n        handle = null;\n      },\n    });\n    this.onStop(function () {\n      if (handle) handle.stop();\n    });\n  }\n\n  this.ready();\n});\n\nMeteor.publish(\"appIndexAdmin\", function (token) {\n  if (!authorizedAsAdmin(token, this.userId)) return [];\n  return globalDb.collections.appIndex.find();\n});\n\nfunction observeOauthService(name) {\n  Settings.find({ _id: name, value: true }).observe({\n    added: function () {\n      // Tell the oauth library it should accept login attempts from this service.\n      Accounts.oauth.registerService(name);\n    },\n\n    removed: function () {\n      // Tell the oauth library it should deny login attempts from this service.\n      Accounts.oauth.unregisterService(name);\n    },\n  });\n}\n\nobserveOauthService(\"github\");\nobserveOauthService(\"google\");\n"], "fixing_code": ["import { Meteor } from \"meteor/meteor\";\nimport nodemailer from \"nodemailer\";\nimport smtpPool from \"nodemailer-smtp-pool\";\n\nconst Future = Npm.require(\"fibers/future\");\n\nconst getSmtpConfig = function () {\n  const config = Settings.findOne({ _id: \"smtpConfig\" });\n  return config && config.value;\n};\n\nconst makePool = function (mailConfig) {\n  if (!mailConfig.hostname) {\n    throw new Error(\"This Sandstorm server has not been configured to send email.\");\n  }\n\n  let auth = false;\n  if (mailConfig.auth && (mailConfig.auth.user || mailConfig.auth.pass)) {\n    auth = mailConfig.auth;\n  }\n\n  const secure = (mailConfig.port === 465);\n  const tlsOptions = {\n    // Previously, node 0.10 did not attempt to validate certificates received when connecting\n    // with STARTTLS, so to avoid regressing we need to preserve that behavior here for now.\n    rejectUnauthorized: false,\n  };\n\n  const pool = nodemailer.createTransport(smtpPool({\n    host: mailConfig.hostname,\n    port: mailConfig.port,\n    secure,\n    tls: tlsOptions,\n    auth,\n    // TODO(someday): allow maxConnections to be configured?\n  }));\n\n  pool._futureWrappedSendMail = _.bind(Future.wrap(pool.sendMail), pool);\n  return pool;\n};\n\n// We construct the SMTP pool at the first call to Email.send, so that\n// other code like migrations can modify the SMTP configuration.\nlet pool;\nlet configured = false;\n\nMeteor.startup(function () {\n  Settings.find({ _id: \"smtpConfig\" }).observeChanges({\n    removed: function () {\n      configured = false;\n    },\n\n    changed: function () {\n      configured = false;\n    },\n\n    added: function () {\n      configured = false;\n    },\n  });\n});\n\nconst getPool = function (smtpConfig) {\n  if (smtpConfig) {\n    return makePool(smtpConfig);\n  } else if (!configured) {\n    configured = true;\n    const config = getSmtpConfig();\n    if (config) {\n      pool = makePool(config);\n    }\n  }\n\n  return pool;\n};\n\nconst smtpSend = function (pool, mailOptions) {\n  console.log(mailOptions);\n  pool._futureWrappedSendMail(mailOptions).wait();\n};\n\n// From http://emailregex.com/, which claims this is the W3C standard for the HTML input element,\n// although their link is broken and I can find no evidence that this is a standard. The page\n// lists several regexes, ostensibly in syntaxes intended for different programming languages,\n// but each regex is in fact substantially different for no apparent reason.\n//\n// The most important thing here is that we disallow separators that might allow a user to confuse\n// nodemailer into thinking the address is a list. Unfortunately, nodemailer will happily separate\n// strings into lists splitting on all kinds of separator characters, such as commas, semicolons,\n// etc. This regex should accomplish that both by disallowing the separators, and by disallowing\n// multiple @ signs. The rest is for show.\nconst EMAIL_REGEX = /^[a-zA-Z0-9.!#$%&\u2019*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\\.[a-zA-Z0-9-]+)*$/;\n\nfunction validateEmail(email) {\n  if (email instanceof Array) {\n    email.forEach(validateEmail);\n  } else if (typeof email === \"object\" && \"address\" in email) {\n    validateEmail(email.address);\n  } else if (email) {\n    check(email, String);\n\n    if (!email.match(EMAIL_REGEX)) {\n      console.log(email);\n      throw new Meteor.Error(400, \"invalid e-mail address\");\n    }\n  }\n}\n\nconst rawSend = function (mailOptions, smtpConfig) {\n  // Sends an email mailOptions object structured as described in\n  // https://github.com/nodemailer/mailcomposer#e-mail-message-fields\n  // across the transport described by smtpConfig.\n\n  // For fields that are supposed to be lists of addresses, if only a single string is provided,\n  // wrap it in an array. This prevents nodemailer from interpreting the address as a\n  // comma-separated list.\n  [\"from\", \"to\", \"cc\", \"bcc\", \"replyTo\"].forEach(field => {\n    validateEmail(mailOptions[field]);\n  });\n\n  const pool = getPool(smtpConfig);\n  if (pool) {\n    smtpSend(pool, mailOptions);\n  } else {\n    throw new Error(\"SMTP pool is misconfigured.\");\n  }\n};\n\n// Old comment below\n/**\n * Send an email.\n *\n * Connects to the mail server configured via the MAIL_URL environment\n * variable. If unset, prints formatted message to stdout. The \"from\" option\n * is required, and at least one of \"to\", \"cc\", and \"bcc\" must be provided;\n * all other options are optional.\n *\n * @param options\n * @param options.from {String} RFC5322 \"From:\" address\n * @param options.to {String|String[]} RFC5322 \"To:\" address[es]\n * @param options.cc {String|String[]} RFC5322 \"Cc:\" address[es]\n * @param options.bcc {String|String[]} RFC5322 \"Bcc:\" address[es]\n * @param options.replyTo {String|String[]} RFC5322 \"Reply-To:\" address[es]\n * @param options.subject {String} RFC5322 \"Subject:\" line\n * @param options.text {String} RFC5322 mail body (plain text)\n * @param options.html {String} RFC5322 mail body (HTML)\n * @param options.headers {Object} custom RFC5322 headers (dictionary)\n */\n\n// New API doc comment below\n/**\n * @summary Send an email. Throws an `Error` on failure to contact mail server\n * or if mail server returns an error. All fields should match\n * [RFC5322](http://tools.ietf.org/html/rfc5322) specification.\n * @locus Server\n * @param {Object} options\n * @param {String} options.from \"From:\" address (required)\n * @param {String|String[]} options.to,cc,bcc,replyTo\n *   \"To:\", \"Cc:\", \"Bcc:\", and \"Reply-To:\" addresses\n * @param {String} [options.subject]  \"Subject:\" line\n * @param {String} [options.text|html] Mail body (in plain text or HTML)\n * @param {Object} [options.headers] Dictionary of custom headers\n * @param {Object} [options.smtpConfig] SMTP server to use. Otherwise defaults to configured one.\n * @param {String} [options.smtpConfig.hostname] SMTP server hostname.\n * @param {Number} [options.smtpConfig.port] SMTP server port.\n * @param {Object} [options.smtpConfig.auth] SMTP server authentication tokens.  Optional.\n * @param {String} [options.smtpConfig.auth.user] Username of user to log in to SMTP server as.  Optional.\n * @param {String} [options.smtpConfig.auth.pass] Password of user to log in to SMTP server as.  Optional.\n * @param {Object} [options.attachments] Attachments. See:\n *   https://github.com/nodemailer/mailcomposer/tree/v0.1.15#add-attachments\n * @param {String} [options.envelopeFrom] Envelope sender.\n */\nconst send = function (options) {\n  // Unpack options\n  const {\n    from,\n    to,\n    cc,\n    bcc,\n    replyTo,\n    subject,\n    text,\n    html,\n    envelopeFrom,\n    headers,\n    attachments,\n    smtpConfig,\n  } = options;\n\n  const opts = {\n    from,\n    to,\n    cc,\n    bcc,\n    replyTo,\n    subject,\n    text,\n    html,\n    headers,\n    attachments,\n  };\n\n  if (envelopeFrom) {\n    opts.envelope = {\n      from: envelopeFrom,\n      to,\n      cc,\n      bcc,\n    };\n  }\n\n  rawSend(opts, smtpConfig);\n};\n\nexport { send, rawSend };\n\n// TODO(cleanup): Remove this once BlackrockPayments code finds a better way to import it.\nglobal.SandstormEmail = { send };\n", "// Sandstorm - Personal Cloud Sandbox\n// Copyright (c) 2014 Sandstorm Development Group, Inc. and contributors\n// All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n// This file defines the database schema.\n\n// Useful for debugging: Set the env variable LOG_MONGO_QUERIES to have the server write every\n// query it makes, so you can see if it's doing queries too often, etc.\nif (Meteor.isServer && process.env.LOG_MONGO_QUERIES) {\n  const oldFind = Mongo.Collection.prototype.find;\n  Mongo.Collection.prototype.find = function () {\n    console.log(this._prefix, arguments);\n    return oldFind.apply(this, arguments);\n  };\n}\n\n// Helper so that we don't have to if (Meteor.isServer) before declaring indexes.\nif (Meteor.isServer) {\n  Mongo.Collection.prototype.ensureIndexOnServer = Mongo.Collection.prototype._ensureIndex;\n} else {\n  Mongo.Collection.prototype.ensureIndexOnServer = function () {};\n}\n\n// TODO(soon): Systematically go through this file and add ensureIndexOnServer() as needed.\n\nconst collectionOptions = { defineMutationMethods: Meteor.isClient };\n// Set to `true` on the client so that method simulation works. Set to `false` on the server\n// so that we can be extra certain that all mutations must go through methods.\n\n// Users = new Mongo.Collection(\"users\");\n// The users collection is special and can be accessed through `Meteor.users`.\n// See https://docs.meteor.com/#/full/meteor_users.\n//\n// There are two distinct types of entries in the users collection: identities and accounts. An\n// identity contains personal profile information and typically includes some intrinsic method for\n// authenticating as the owner of that information.\n//\n// An account is an owner of app actions, grains, contacts, notifications, and payment info.\n// Each account can have multiple identities linked to it. To log in as an account you must first\n// authenticate as one of its linked identities.\n//\n// Every user contains the following fields:\n//   _id: Unique string ID. For accounts, this is random. For identities, this is the globally\n//        stable SHA-256 ID of this identity, hex-encoded.\n//   createdAt: Date when this entry was added to the collection.\n//   lastActive: Date of the user's most recent interaction with this Sandstorm server.\n//   services: Object containing login data used by Meteor authentication services.\n//   expires: Date when this user should be deleted. Only present for demo users.\n//   upgradedFromDemo: If present, the date when this user was upgraded from being a demo user.\n//                     TODO(cleanup): Unlike other dates in our database, this is stored as a number\n//                     rather than as a Date object. We should fix that.\n//   appDemoId: If present and non-null, then the user is a demo user who arrived via an /appdemo/\n//              link. This field contains the app ID of the app that the user started out demoing.\n//              Unlike the `expires` field, this field is not cleared when the user upgrades from\n//              being a demo user.\n//   suspended: If this exists, this account/identity is supsended. Both accounts and identities\n//              can be suspended. After some amount of time, the user will be completely deleted\n//              and removed from the DB.\n//              It is an object with fields:\n//                voluntary: Boolean. This is true if the user initiated it. They will have the\n//                  chance to still login and reverse the suspension/deletion.\n//                admin: The userId of the admin who suspended the account.\n//                timestamp: Date object. When the suspension occurred.\n//                willDelete: Boolean. If true, this account will be deleted after some time.\n//\n// Identity users additionally contain the following fields:\n//   profile: Object containing the data that will be shared with users and grains that come into\n//            contact with this identity. Includes the following fields:\n//       service: String containing the name of this identity's authentication method.\n//       name: String containing the chosen display name of the identity.\n//       handle: String containing the identity's preferred handle.\n//       picture: _id into the StaticAssets table for the identity's picture. If not present,\n//                an identicon will be used.\n//       pronoun: One of \"male\", \"female\", \"neutral\", or \"robot\".\n//   unverifiedEmail: If present, a string containing an email address specified by the user.\n//   referredBy: ID of the Account that referred this Identity.\n//\n// Account users additionally contain the following fields:\n//   loginIdentities: Array of identity objects, each of which may include the following fields.\n//       id: The globally-stable SHA-256 ID of this identity, hex-encoded.\n//   nonloginIdentities: Array of identity objects, of the same form as `loginIdentities`. We use\n//                       a separate array here so that we can use a Mongo index to enforce the\n//                       invariant that an identity only be a login identity for a single account.\n//   primaryEmail: String containing this account's primary email address. Must be a verified adress\n//                 of one of this account's linked identities. Call SandstormDb.getUserEmails()\n//                 to do this checking automatically.\n//   isAdmin: Boolean indicating whether this account is allowed to access the Sandstorm admin panel.\n//   signupKey: If this is an invited user, then this field contains their signup key.\n//   signupNote: If the user was invited through a link, then this field contains the note that the\n//               inviter admin attached to the key.\n//   signupEmail: If the user was invited by email, then this field contains the email address that\n//                the invite was sent to.\n//   hasCompletedSignup: True if this account has confirmed its profile and agreed to this server's\n//                       terms of service.\n//   plan: _id of an entry in the Plans table which determines the user's quota.\n//   planBonus: {storage, compute, grains} bonus amounts to add to the user's plan. The payments\n//              module writes data here; we merely read it. Missing fields should be treated as\n//              zeroes. Does not yet include referral bonus, which is calculated separately.\n//              TODO(cleanup): Use for referral bonus too.\n//   storageUsage: Number of bytes this user is currently storing.\n//   payments: Object defined by payments module, if loaded.\n//   dailySentMailCount: Number of emails sent by this user today; used to limit spam.\n//   accessRequests: Object containing the following fields; used to limit spam.\n//       count: Number of \"request access\" emails during sent during the current interval.\n//       resetOn: Date when the count should be reset.\n//   referredByComplete: ID of the Account that referred this Account. If this is set, we\n//                        stop writing new referredBy values onto Identities for this account.\n//   referredCompleteDate: The Date at which the completed referral occurred.\n//   referredIdentityIds: List of Identity IDs that this Account has referred. This is used for\n//                        reliably determining which Identity's names are safe to display.\n//   experiments: Object where each field is an experiment that the user is in, and each value\n//           is the parameters for that experiment. Typically, the value simply names which\n//           experiment group which the user is in, where \"control\" is one group. If an experiment\n//           is not listed, then the user should not be considered at all for the purpose of that\n//           experiment. Each experiment may define a point in time where users not already in the\n//           experiment may be added to it and assigned to a group (for example, at user creation\n//           time). Current experiments:\n//       firstTimeBillingPrompt: Value is \"control\" or \"test\". Users are assigned to groups at\n//               account creation on servers where billing is enabled (i.e. Oasis). Users in the\n//               test group will see a plan selection dialog and asked to make an explitic choice\n//               (possibly \"free\") before they can create grains (but not when opening someone\n//               else's shared grain). The goal of the experiment is to determine whether this\n//               prompt scares users away -- and also whether it increases paid signups.\n//       freeGrainLimit: Value is \"control\" or or a number indicating the grain limit that the\n//               user should receive when on the \"free\" plan, e.g. \"Infinity\".\n//   stashedOldUser: A complete copy of this user from before the accounts/identities migration.\n//                   TODO(cleanup): Delete this field once we're sure it's safe to do so.\n\nMeteor.users.ensureIndexOnServer(\"services.google.email\", { sparse: 1 });\nMeteor.users.ensureIndexOnServer(\"services.github.emails.email\", { sparse: 1 });\nMeteor.users.ensureIndexOnServer(\"services.email.email\", { unique: 1, sparse: 1 });\nMeteor.users.ensureIndexOnServer(\"loginIdentities.id\", { unique: 1, sparse: 1 });\nMeteor.users.ensureIndexOnServer(\"nonloginIdentities.id\", { sparse: 1 });\nMeteor.users.ensureIndexOnServer(\"services.google.id\", { unique: 1, sparse: 1 });\nMeteor.users.ensureIndexOnServer(\"services.github.id\", { unique: 1, sparse: 1 });\nMeteor.users.ensureIndexOnServer(\"suspended.willDelete\", { sparse: 1 });\n\n// TODO(cleanup): This index is obsolete; delete it.\nMeteor.users.ensureIndexOnServer(\"identities.id\", { unique: 1, sparse: 1 });\n\nPackages = new Mongo.Collection(\"packages\", collectionOptions);\n// Packages which are installed or downloading.\n//\n// Each contains:\n//   _id:  128-bit prefix of SHA-256 hash of spk file, hex-encoded.\n//   status:  String.  One of \"download\", \"verify\", \"unpack\", \"analyze\", \"ready\", \"failed\", \"delete\"\n//   progress:  Float.  -1 = N/A, 0-1 = fractional progress (e.g. download percentage),\n//       >1 = download byte count.\n//   error:  If status is \"failed\", error message string.\n//   manifest:  If status is \"ready\", the package manifest.  See \"Manifest\" in package.capnp.\n//   appId:  If status is \"ready\", the application ID string.  Packages representing different\n//       versions of the same app have the same appId.  The spk tool defines the app ID format\n//       and can cryptographically verify that a package belongs to a particular app ID.\n//   shouldCleanup:  If true, a reference to this package was recently dropped, and the package\n//       collector should at some point check whether there are any other references and, if not,\n//       delete the package.\n//   url:  When status is \"download\", the URL from which the SPK can be obtained, if provided.\n//   isAutoUpdated: This package was downloaded as part of an auto-update. We shouldn't clean it up\n//     even if it has no users.\n//   authorPgpKeyFingerprint: Verified PGP key fingerprint (SHA-1, hex, all-caps) of the app\n//     packager.\n\nDevPackages = new Mongo.Collection(\"devpackages\", collectionOptions);\n// List of packages currently made available via the dev tools running on the local machine.\n// This is normally empty; the only time it is non-empty is when a developer is using the spk tool\n// on the local machine to publish an under-development app to this server. That should only ever\n// happen on developers' desktop machines.\n//\n// While a dev package is published, it automatically appears as installed by every user of the\n// server, and it overrides all packages with the same application ID. If any instances of those\n// packages are currently open, they are killed and reset on publish.\n//\n// When the dev tool disconnects, the package is automatically unpublished, and any open instances\n// are again killed and refreshed.\n//\n// Each contains:\n//   _id:  The package ID string (as with Packages._id).\n//   appId: The app ID this package is intended to override (as with Packages.appId).\n//   timestamp:  Time when the package was last updated. If this changes while the package is\n//     published, all running instances are reset. This is used e.g. to reset the app each time\n//     changes are made to the source code.\n//   manifest:  The app's manifest, as with Packages.manifest.\n//   mountProc: True if the supervisor should mount /proc.\n\nUserActions = new Mongo.Collection(\"userActions\", collectionOptions);\n// List of actions that each user has installed which create new grains.  Each app may install\n// some number of actions (usually, one).\n//\n// Each contains:\n//   _id:  random\n//   userId:  Account ID of the user who has installed this action.\n//   packageId:  Package used to run this action.\n//   appId:  Same as Packages.findOne(packageId).appId; denormalized for searchability.\n//   appTitle:  Same as Packages.findOne(packageId).manifest.appTitle; denormalized so\n//       that clients can access it without subscribing to the Packages collection.\n//   appVersion:  Same as Packages.findOne(packageId).manifest.appVersion; denormalized for\n//       searchability.\n//   appMarketingVersion:  Human-readable presentation of the app version, e.g. \"2.9.17\"\n//   title: JSON-encoded LocalizedText title for this action, e.g.\n//       `{defaultText: \"New Spreadsheet\"}`.\n//   nounPhrase: JSON-encoded LocalizedText describing what is created when this action is run.\n//   command:  Manifest.Command to run this action (see package.capnp).\n\nGrains = new Mongo.Collection(\"grains\", collectionOptions);\n// Grains belonging to users.\n//\n// Each contains:\n//   _id:  random\n//   packageId:  _id of the package of which this grain is an instance.\n//   packageSalt: If present, a random string that will used in session ID generation. This field\n//       is usually updated when `packageId` is updated, triggering automatic refreshes for\n//       clients with active sessions.\n//   appId:  Same as Packages.findOne(packageId).appId; denormalized for searchability.\n//   appVersion:  Same as Packages.findOne(packageId).manifest.appVersion; denormalized for\n//       searchability.\n//   userId: The _id of the account that owns this grain.\n//   identityId: The identity with which the owning account prefers to open this grain.\n//   title:  Human-readable string title, as chosen by the user.\n//   lastUsed:  Date when the grain was last used by a user.\n//   private: If true, then knowledge of `_id` does not suffice to open this grain.\n//   cachedViewInfo: The JSON-encoded result of `UiView.getViewInfo()`, cached from the most recent\n//                   time a session to this grain was opened.\n//   trashed: If present, the Date when this grain was moved to the trash bin. Thirty days after\n//            this date, the grain will be automatically deleted.\n//   suspended: If true, the owner of this grain has been suspended. They will soon be deleted,\n//              so treat this grain the same as \"trashed\". It is denormalized out of Users for ease\n//              of querying.\n//   ownerSeenAllActivity: True if the owner has viewed the grain since the last activity event\n//       occurred. See also ApiTokenOwner.user.seenAllActivity.\n//   size: On-disk size of the grain in bytes.\n//\n// The following fields *might* also exist. These are temporary hacks used to implement e-mail and\n// web publishing functionality without powerbox support; they will be replaced once the powerbox\n// is implemented.\n//   publicId:  An id used to publicly identify this grain. Used e.g. to route incoming e-mail and\n//       web publishing. This field is initialized when first requested by the app.\n\nGrains.ensureIndexOnServer(\"cachedViewInfo.matchRequests.tags.id\", { sparse: 1 });\n\nRoleAssignments = new Mongo.Collection(\"roleAssignments\", collectionOptions);\n// *OBSOLETE* Before `user` was a variant of ApiTokenOwner, this collection was used to store edges\n// in the permissions sharing graph. This functionality has been subsumed by the ApiTokens\n// collection.\n\nContacts = new Mongo.Collection(\"contacts\", collectionOptions);\n// Edges in the social graph.\n//\n// If Alice has Bob as a contact, then she is allowed to see Bob's profile information and Bob\n// will show up in her user-picker UI for actions like share-by-identity.\n//\n// Contacts are not symmetric. Bob might be one of Alice's contacts even if Alice is not one of\n// Bob's.\n//\n// Each contains:\n//   _id: random\n//   ownerId: The accountId of the user account who owns this contact.\n//   petname: Human-readable label chosen by and only visible to the owner. Uniquely identifies\n//            the contact to the owner.\n//   created: Date when this contact was created.\n//   identityId: The `_id` of the user whose contact info this contains.\n\nSessions = new Mongo.Collection(\"sessions\", collectionOptions);\n// UI sessions open to particular grains.  A new session is created each time a user opens a grain.\n//\n// Each contains:\n//   _id:  String generated as a SHA256 hash of the grain ID, the user ID, a salt generated by the\n//       client, and the grain's `packageSalt`.\n//   grainId:  _id of the grain to which this session is connected.\n//   hostId: ID part of the hostname from which this grain is being served. I.e. this replaces the\n//       '*' in WILDCARD_HOST.\n//   tabId: Random value unique to the grain tab in which this session is displayed. Typically\n//       every session has a different `tabId`, but embedded sessions (including in the powerbox)\n//       have the same `tabId` as the outer session.\n//   timestamp:  Time of last keep-alive message to this session.  Sessions time out after some\n//       period.\n//   userId:  Account ID of the user who owns this session.\n//   identityId:  Identity ID of the user who owns this session.\n//   hashedToken: If the session is owned by an anonymous user, the _id of the entry in ApiTokens\n//       that was used to open it. Note that for old-style sharing (i.e. when !grain.private),\n//       anonymous users can get access without an API token and so neither userId nor hashedToken\n//       are present.\n//   powerboxView: Information about a server-initiated powerbox interaction taking place in this\n//       session. When the client sees a `powerboxView` appear on the session, it opens the\n//       powerbox popup according to the contents. This field is an object containing one of:\n//     offer: A capability is being offered to the user by the app. This is an object containing:\n//       token: For a non-UiView capability, the API token that can be used to restore this\n//           capability.\n//       uiView: A UiView capability. This object contains one of:\n//         tokenId: The _id of an ApiToken belonging to the current user.\n//         token: A full webkey token which can be opened by an anonymous user.\n//     fulfill: A capability is being offered which fulfills the active powerbox request. This\n//         is an object with members:\n//       token: The SturdyRef of the fulfilling capability. This token can only be used in a call\n//           to claimRequest() by the requesting\n//           grain.\n//       descriptor: Packed-base64 PowerboxDescriptor for the capability.\n//   powerboxRequest: If present, this session is a powerbox request session. Object containing:\n//     descriptors: Array of PowerboxDescriptors representing the request.\n//     requestingSession: Session ID of the session initiating the request.\n//   viewInfo: The UiView.ViewInfo corresponding to the underlying UiSession. This isn't populated\n//       until newSession is called on the UiView.\n//   permissions: The permissions for the current identity on this UiView. This isn't populated\n//       until newSession is called on the UiView.\n//   hasLoaded: Marked as true by the proxy when the underlying UiSession has responded to its first\n//       request\n\nSignupKeys = new Mongo.Collection(\"signupKeys\", collectionOptions);\n// Invite keys which may be used by users to get access to Sandstorm.\n//\n// Each contains:\n//   _id:  random\n//   used:  Boolean indicating whether this key has already been consumed.\n//   note:  Text note assigned when creating key, to keep track of e.g. whom the key was for.\n//   email: If this key was sent as an email invite, the email address to which it was sent.\n\nActivityStats = new Mongo.Collection(\"activityStats\", collectionOptions);\n// Contains usage statistics taken on a regular interval. Each entry is a data point.\n//\n// Each contains:\n//   timestamp: Date when measurements were taken.\n//   daily: Contains stats counts pertaining to the last day before the sample time.\n//   weekly: Contains stats counts pertaining to the last seven days before the sample time.\n//   monthly: Contains stats counts pertaining to the last thirty days before the timestamp.\n//\n// Each of daily, weekly, and monthly contains:\n//   activeUsers: The number of unique users who have used a grain on the server in the time\n//       interval. Only counts logged-in users.\n//   demoUsers: Demo users.\n//   appDemoUsers: Users that came in through \"app demo\".\n//   activeGrains: The number of unique grains that have been used in the time interval.\n//   apps: An object indexed by app ID recording, for each app:\n//       owners: Number of unique owners of this app (counting only grains that still exist).\n//       sharedUsers: Number of users who have accessed other people's grains of this app (counting\n//         only grains that still exist).\n//       grains: Number of active grains of this app (that still exist).\n//       deleted: Number of non-demo grains of this app that were deleted.\n//       demoed: Number of demo grains created and expired.\n//       appDemoUsers: Number of app demos initiated with this app.\n\nDeleteStats = new Mongo.Collection(\"deleteStats\", collectionOptions);\n// Contains records of objects that were deleted, for stat-keeping purposes.\n//\n// Each contains:\n//   type: \"grain\" or \"user\" or \"demoGrain\" or \"demoUser\" or \"appDemoUser\"\n//   lastActive: Date of the user's or grain's last activity.\n//   appId: For type = \"grain\", the app ID of the grain. For type = \"appDemoUser\", the app ID they\n//     arrived to demo. For others, undefined.\n//   experiments: The experiments the user (or owner of the grain) was in. See user.experiments.\n\nFileTokens = new Mongo.Collection(\"fileTokens\", collectionOptions);\n// Tokens corresponding to backup files that are currently stored on the server. A user receives\n// a token when they create a backup file (either by uploading it, or by backing up one of their\n// grains) and may use the token to read the file (either to download it, or to restore a new\n// grain from it).\n//\n// Each contains:\n//   _id:       The unguessable token string.\n//   name:      Suggested filename.\n//   timestamp: File creation time. Used to figure out when the token and file should be wiped.\n\nApiTokens = new Mongo.Collection(\"apiTokens\", collectionOptions);\n// Access tokens for APIs exported by apps.\n//\n// Originally API tokens were only used by external users through the HTTP API endpoint. However,\n// now they are also used to implement SturdyRefs, not just held by external users, but also when\n// an app holds a SturdyRef to another app within the same server. See the various `save()`,\n// `restore()`, and `drop()` methods in `grain.capnp` (on `SandstormApi`, `AppPersistent`, and\n// `MainView`) -- the fields of type `Data` are API tokens.\n//\n// Each contains:\n//   _id:       A SHA-256 hash of the token, base64-encoded.\n//   grainId:   The grain servicing this API. (Not present if the API isn't serviced by a grain.)\n//   identityId: For UiView capabilities, this is the identity for which the view is attenuated.\n//              That is, the UiView's newSession() method will intersect the requested permissions\n//              with this identity's permissions before forwarding on to the underlying app. If\n//              `identityId` is not present, then no identity attenuation is applied, i.e. this is\n//              a raw UiView as implemented by the app. (The `roleAssignment` field, below, may\n//              still apply. For non-UiView capabilities, `identityId` is never present. Note that\n//              this is NOT the identity against which the `requiredPermissions` parameter of\n//              `SandstormApi.restore()` is checked; that would be `owner.grain.introducerIdentity`.\n//   accountId: For tokens where `identityId` is set, the `_id` (in the Users table) of the account\n//              that created the token.\n//   roleAssignment: If this API token represents a UiView, this field contains a JSON-encoded\n//              Grain.ViewSharingLink.RoleAssignment representing the permissions it carries. These\n//              permissions will be intersected with those held by `identityId` when the view is\n//              opened.\n//   forSharing: If true, requests sent to the HTTP API endpoint with this token will be treated as\n//              anonymous rather than as directly associated with `identityId`. This has no effect\n//              on the permissions granted.\n//   objectId:  If present, this token represents an arbitrary Cap'n Proto capability exported by\n//              the app or its supervisor (whereas without this it strictly represents UiView).\n//              sturdyRef is the JSON-encoded SupervisorObjectId (defined in `supervisor.capnp`).\n//              Note that if the SupervisorObjectId contains an AppObjectId, that field is\n//              treated as type AnyPointer, and so encoded as a raw Cap'n Proto message.\n//   frontendRef: If present, this token actually refers to an object implemented by the front-end,\n//              not a particular grain. (`grainId` and `identityId` are not set.) This is an object\n//              containing exactly one of the following fields:\n//       notificationHandle: A `Handle` for an ongoing notification, as returned by\n//                           `NotificationTarget.addOngoing`. The value is an `_id` from the\n//                           `Notifications` collection.\n//       ipNetwork: An IpNetwork capability that is implemented by the frontend. Eventually, this\n//                  will be moved out of the frontend and into the backend, but we'll migrate the\n//                  database when that happens. This field contains the boolean true to signify that\n//                  it has been set.\n//       ipInterface: Ditto IpNetwork, except it's an IpInterface.\n//       emailVerifier: An EmailVerifier capability that is implemented by the frontend. The\n//                      value is an object containing the fields `id` and `services`. `id` is the\n//                      value returned by `EmailVerifier.getId()` and is used as part of a\n//                      powerbox query for matching verified emails. `services` is a\n//                      list of names of identity providers that are trusted to verify addresses.\n//                      If `services` is omitted or falsy, all configured identity providers are\n//                      trusted. Note that a malicious user could specify invalid names in the\n//                      list; they should be ignored.\n//       verifiedEmail: An VerifiedEmail capability that is implemented by the frontend.\n//                      An object containing `verifierId`, `tabId`, and `address`.\n//       identity: An Identity capability. The field is the identity ID.\n//       http: An ApiSession capability pointing to an external HTTP service. Object containing:\n//           url: Base URL of the external service.\n//           auth: Authentication mechanism. Object containing one of:\n//               none: Value \"null\". Indicates no authorization.\n//               bearer: A bearer token to pass in the `Authorization: Bearer` header on all\n//                   requests. Encrypted with nonce 0.\n//               basic: A `{username, password}` object. The password is encrypted with nonce 0.\n//                   Before encryption, the password is padded to 32 bytes by appending NUL bytes,\n//                   in order to mask the length of small passwords.\n//               refresh: An OAuth refresh token, which can be exchanged for an access token.\n//                   Encrypted with nonce 0.\n//               TODO(security): How do we protect URLs that directly embed their secret? We don't\n//                   want to encrypt the full URL since this would make it hard to show a\n//                   meaningful audit UI, but maybe we could figure out a way to extract the key\n//                   part and encrypt it separately?\n//   parentToken: If present, then this token represents exactly the capability represented by\n//              the ApiToken with _id = parentToken, except possibly (if it is a UiView) attenuated\n//              by `roleAssignment` (if present). To facilitate permissions computations, if the\n//              capability is a UiView, then `grainId` is set to the backing grain, `identityId`\n//              is set to the identity that shared the view, and `accountId` is set to the account\n//              that shared the view. Neither `objectId` nor `frontendRef` is present when\n//              `parentToken` is present.\n//   parentTokenKey: The actual parent token -- whereas `parentToken` is only the parent token ID\n//              (hash). `parentTokenFull` is encrypted with nonce 0 (see below). This is needed\n//              in particular when the parent contains encrypted fields, since those would need to\n//              be decrypted using this key. If the parent contains no encrypted fields then\n//              `parentTokenKey` may be omitted from the child.\n//   petname:   Human-readable label for this access token, useful for identifying tokens for\n//              revocation. This should be displayed when visualizing incoming capabilities to\n//              the grain identified by `grainId`.\n//   created:   Date when this token was created.\n//   revoked:   If true, then this sturdyref has been revoked and can no longer be restored. It may\n//              become un-revoked in the future.\n//   trashed:   If present, the Date when this token was moved to the trash bin. Thirty days after\n//              this date, the token will be automatically deleted.\n//   suspended: If true, the owner of this token has been suspended. They will soon be deleted,\n//              so treat this token the same as \"trashed\". It is denormalized out of Users for\n//              ease of querying.\n//   expires:   Optional expiration Date. If undefined, the token does not expire.\n//   lastUsed:  Optional Date when this token was last used.\n//   owner:     A `ApiTokenOwner` (defined in `supervisor.capnp`, stored as a JSON object)\n//              as passed to the `save()` call that created this token. If not present, treat\n//              as `webkey` (the default for `ApiTokenOwner`).\n//   expiresIfUnused:\n//              Optional Date after which the token, if it has not been used yet, expires.\n//              This field should be cleared on a token's first use.\n//   requirements: List of conditions which must hold for this token to be considered valid.\n//              Semantically, this list specifies the powers which were *used* to originally\n//              create the token. If any condition in the list becomes untrue, then the token must\n//              be considered revoked, and all live refs and sturdy refs obtained transitively\n//              through it must also become revoked. Each item is the JSON serialization of the\n//              `MembraneRequirement` structure defined in `supervisor.capnp`.\n//   hasApiHost: If true, there is an entry in ApiHosts for this token, which will need to be\n//              cleaned up when the token is.\n//\n// It is important to note that a token's owner and provider are independent from each other. To\n// illustrate, here is an approximate definition of ApiToken in pseudo Cap'n Proto schema language:\n//\n// struct ApiToken {\n//   owner :ApiTokenOwner;\n//   provider :union {\n//     grain :group {\n//       grainId :Text;\n//       union {\n//         uiView :group {\n//           identityId :Text;\n//           roleAssignment :RoleAssignment;\n//           forSharing :Bool;\n//         }\n//         objectId :SupervisorObjectId;\n//       }\n//     }\n//     frontendRef :union {\n//       notificationHandle :Text;\n//       ipNetwork :Bool;\n//       ipInterface :Bool;\n//       emailVerifier :group {\n//         id :Text;\n//         services :List(String);\n//       }\n//       verifiedEmail :group {\n//         verifierId :Text;\n//         tabId :Text;\n//         address :Text;\n//       }\n//       identity :Text;\n//       http :group {\n//         url :Text;\n//         auth :union {\n//           none :Void;\n//           bearer :Text;\n//           basic :group { username :Text; password :Text; }\n//           refresh :Text;\n//         }\n//       }\n//     }\n//     child :group {\n//       parentToken :Text;\n//       union {\n//         uiView :group {\n//           grainId :Text;\n//           identityId :Text;\n//           roleAssignment :RoleAssignment = (allAccess = ());\n//         }\n//         other :Void;\n//       }\n//     }\n//   }\n//   requirements: List(Supervisor.MembraneRequirement);\n//   ...\n// }\n//\n// ENCRYPTION\n//\n// We want to make sure that someone who obtains a copy of the database cannot use it to gain live\n// credentials.\n//\n// The actual token corresponding to an ApiToken entry is not stored in the entry itself. Instead,\n// the ApiToken's `_id` is constructed as a SHA256 hash of the actual token. To use an ApiToken\n// in the live system, you must present the original token.\n//\n// Additionally, some ApiToken entries contain tokens to third-party services, e.g. OAuth tokens\n// or even passwords. Such tokens are encrypted, using the ApiToken entry's own full token (which,\n// again, is not stored in the database) as the encryption key.\n//\n// When such encryption is applied, the cipher used is ChaCha20. All API tokens are 256-bit base64\n// strings, hence can be used directly as the key. No MAC is applied, because this scheme is not\n// intended to protect against attackers who have write access to the database -- such an attacker\n// could almost certainly do more damage by modifying the non-encrypted fields anyway. (Put another\n// way, if we wanted to MAC something, we'd need to MAC the entire ApiToken structure, not just\n// the encrypted key. But we don't have a way to do that at present.)\n//\n// ChaCha20 requires a nonce. Luckily, all of the fields we wish to encrypt are immutable, so we\n// don't have to worry about tracking nonces over time -- we can just assign a static nonce to each\n// field. Moreover, many (currently, all) of these fields are mutually exclusive, so can even share\n// nonces. Currently, nonces map to fields as follows:\n//\n// nonce 0:\n//     parentTokenKey\n//     frontendRef.http.auth.basic.password\n//     frontendRef.http.auth.bearer\n//     frontendRef.http.auth.refresh\n\nApiTokens.ensureIndexOnServer(\"grainId\", { sparse: 1 });\nApiTokens.ensureIndexOnServer(\"owner.user.identityId\", { sparse: 1 });\nApiTokens.ensureIndexOnServer(\"frontendRef.emailVerifier.id\", { sparse: 1 });\n\nApiHosts = new Mongo.Collection(\"apiHosts\", collectionOptions);\n// Allows defining some limited static behavior for an API host when accessed unauthenticated. This\n// mainly exists to allow backwards-compatibility with client applications that expect to be able\n// to probe an API host without authentication to determine capabilities such as DAV protocols\n// supported, before authenticating to perform real requests. An app can specify these properties\n// when creating an offerTemplate.\n//\n// Each contains:\n//   _id:          apiHostIdHashForToken() of the corresponding API token.\n//   hash2:        hash(hash(token)), aka hash(ApiToken._id). Used to allow ApiHosts to be cleaned\n//                 up when ApiTokens are deleted.\n//   options:      Specifies how to respond to unauthenticated OPTIONS requests on this host.\n//                 This is an object containing fields:\n//     dav:        List of strings specifying DAV header `compliance-class`es, e.g. \"1\" or\n//                 \"calendar-access\". https://tools.ietf.org/html/rfc4918#section-10.1\n//   resources:    Object mapping URL paths (including initial '/') to static HTTP responses to\n//                 give when those paths are accessed unauthenticated. Due to Mongo disliking '.'\n//                 and '$' in keys, these characters must be escaped as '\\uFF0E' and '\\uFF04'\n//                 (see SandstormDb.escapeMongoKey). Each value in this map is an object with\n//                 fields:\n//     type:       Content-Type.\n//     language:   Content-Language.\n//     encoding:   Content-Encoding.\n//     body:       Entity-body as a string or buffer.\n\nNotifications = new Mongo.Collection(\"notifications\", collectionOptions);\n// Notifications for a user.\n//\n// Each contains:\n//   _id:          random\n//   grainId:      The grain originating this notification, if any.\n//   userId:       Account ID of the user receiving the notification.\n//   text:         The JSON-ified LocalizedText to display in the notification.\n//   isUnread:     Boolean indicating if this notification is unread.\n//   timestamp:    Date when this notification was last updated\n//   eventType:    If this notification is due to an activity event, this is the numeric index\n//                 of the event type on the grain's ViewInfo.\n//   count:        The number of times this exact event has repeated. Identical events are\n//                 aggregated by incrementing the count.\n//   initiatingIdentity: Identity ID of the user who initiated this notification.\n//   initiatorAnonymous: True if the initiator is an anonymous user. If neither this nor\n//                 initiatingIdentity is present, the notification is not from a user.\n//   path:         Path inside the grain to which the user should be directed if they click on\n//                 the notification.\n//   ongoing:      If present, this is an ongoing notification, and this field contains an\n//                 ApiToken referencing the `OngoingNotification` capability.\n//   admin:        If present, this is a notification intended for an admin.\n//     action:     If present, this is a (string) link that the notification should direct the\n//                 admin to.\n//     type:       The type of notification -- currently can only be \"reportStats\".\n//   appUpdates:   If present, this is an app update notification. It is an object with the appIds\n//                 as keys.\n//     $appId:     The appId that has an outstanding update.\n//       packageId: The packageId that it will update to.\n//       name: The name of the app. (appTitle from package.manifest)\n//       version: The app's version number. (appVersion from package.manifest)\n//       marketingVersion: String marketing version of this app. (appMarketingVersion from package.manifest)\n//   referral:     If this boolean field is true, then treat this notification as a referral\n//                 notification. This causes text to be ignored, since we need custom logic.\n//   mailingListBonus: Like `referral`, but notify the user about the mailing list bonus. This is\n//                 a one-time notification only to Oasis users who existed when the bonus program\n//                 was implemented.\n\nActivitySubscriptions = new Mongo.Collection(\"activitySubscriptions\", collectionOptions);\n// Activity events to which a user is subscribed.\n//\n// Each contains:\n//   _id:          random\n//   identityId:   Who is subscribed.\n//   grainId:      Grain to which subscription applies.\n//   threadPath:   If present, the subscription is on a specific thread. Otherwise, it is on the\n//                 whole grain.\n//   mute:         If true, this is an anti-subscription -- matching events should NOT notify.\n//                 This allows is useful to express:\n//                 - A user wants to subscribe to a grain but mute a specific thread.\n//                 - The owner of a grain does not want notifications (normally, they are\n//                   implicitly subscribed).\n//                 - A user no longer wishes to be implicitly subscribed to threads in a grain on\n//                   which they comment, so they mute the grain.\n\nActivitySubscriptions.ensureIndexOnServer(\"identityId\");\nActivitySubscriptions.ensureIndexOnServer({ \"grainId\": 1, \"threadPath\": 1 });\n\nStatsTokens = new Mongo.Collection(\"statsTokens\", collectionOptions);\n// Access tokens for the Stats collection\n//\n// These tokens are used for accessing the ActivityStats collection remotely\n// (ie. from a dashboard webapp)\n//\n// Each contains:\n//   _id:       The token. At least 128 bits entropy (Random.id(22)).\n\nMisc = new Mongo.Collection(\"misc\", collectionOptions);\n// Miscellaneous configuration and other settings\n//\n// This table is currently only used for persisting BASE_URL from one session to the next,\n// but in general any miscellaneous settings should go in here\n//\n// Each contains:\n//   _id:       The name of the setting. eg. \"BASE_URL\"\n//   value:     The value of the setting.\n\nSettings = new Mongo.Collection(\"settings\", collectionOptions);\n// Settings for this Sandstorm instance go here. They are configured through the adminSettings\n// route. This collection differs from misc in that any admin user can update it through the admin\n// interface.\n//\n// Each contains:\n//   _id:       The name of the setting. eg. \"smtpConfig\"\n//   value:     The value of the setting.\n//   automaticallyReset: Sometimes the server needs to automatically reset a setting. When it does\n//                       so, it will also write an object to this field indicating why the reset was\n//                       needed. That object can have the following variants:\n//       baseUrlChangedFrom: The reset was due to BASE_URL changing. This field contains a string\n//                           with the old BASE_URL.\n//   preinstalledApps: A list of objects:\n//     appId: The Packages.appId of the app to install\n//     status: packageId\n//     packageId: The Packages._id of the app to install\n//\n//   potentially other fields that are unique to the setting\n\nMigrations = new Mongo.Collection(\"migrations\", collectionOptions);\n// This table tracks which migrations we have applied to this instance.\n// It contains a single entry:\n//   _id:       \"migrations_applied\"\n//   value:     The number of migrations this instance has successfully completed.\n\nStaticAssets = new Mongo.Collection(\"staticAssets\", collectionOptions);\n// Collection of static assets served up from the Sandstorm server's \"static\" host. We only\n// support relatively small assets: under 1MB each.\n//\n// Each contains:\n//   _id:       Random ID; will be used in the URL.\n//   hash:      A base64-encoded SHA-256 hash of the data, used to de-dupe.\n//   mimeType:  MIME type of the asset, suitable for Content-Type header.\n//   encoding:  Either \"gzip\" or not present, suitable for Content-Encoding header.\n//   content:   The asset content (byte buffer).\n//   refcount:  Number of places where this asset's ID appears in the database. Since Mongo doesn't\n//       have transactions, this needs to bias towards over-counting; a backup GC could be used\n//       to catch leaked assets, although it's probably not a big deal in practice.\n\nAssetUploadTokens = new Mongo.Collection(\"assetUploadTokens\", collectionOptions);\n// Collection of tokens representing a single-use permission to upload an asset, such as a new\n// profile picture.\n//\n// Each contains:\n//   _id:       Random ID.\n//   purpose:   Contains one of the following, indicating how the asset is to be used:\n//       profilePicture: Indicates that the upload is a new profile picture. Contains fields:\n//           userId: Account ID of user whose picture shall be replaced.\n//           identityId: Which of the user's identities shall be updated.\n//   expires:   Time when this token will go away if unused.\n\nPlans = new Mongo.Collection(\"plans\", collectionOptions);\n// Subscription plans, which determine quota.\n//\n// Each contains:\n//   _id: Plan ID, usually a short string like \"free\", \"standard\", \"large\", \"mega\", ...\n//   storage: Number of bytes this user is allowed to store.\n//   compute: Number of kilobyte-RAM-seconds this user is allowed to consume.\n//   computeLabel: Label to display to the user describing this plan's compute units.\n//   grains: Total number of grains this user can create (often `Infinity`).\n//   price: Price per month in US cents.\n//   hidden: If true, a user cannot switch to this plan, but some users may be on it and are\n//       allowed to switch away.\n//   title: Title from display purposes. If missing, default to capitalizing _id.\n\nAppIndex = new Mongo.Collection(\"appIndex\", collectionOptions);\n// A mirror of the data from the App Market index\n//\n// Each contains:\n//   _id: the appId of the app\n//  The rest of the fields are defined in src/sandstorm/app-index/app-index.capnp:AppIndexForMarket\n\nKeybaseProfiles = new Mongo.Collection(\"keybaseProfiles\", collectionOptions);\n// Cache of Keybase profile information. The profile for a user is re-fetched every time a package\n// by that user is installed, as well as if the keybase profile is requested and not already\n// present for some reason.\n//\n// Each contains:\n//   _id: PGP key fingerprint (SHA-1, hex, all-caps)\n//   displayName: Display name from Keybase. (NOT VERIFIED AT ALL.)\n//   handle: Keybase handle.\n//   proofs: The \"proofs_summary.all\" array from the Keybase lookup. See the non-existent Keybase\n//     docs for details. We also add a boolean \"status\" field to each proof indicating whether\n//     we have directly verified the proof ourselves. Its values may be \"unverified\" (Keybase\n//     returned this but we haven't checked it directly), \"verified\" (we verified the proof and it\n//     is valid), \"invalid\" (we checked the proof and it was definitely bogus), or \"checking\" (the\n//     server is currently actively checking this proof). Note that if a check fails due to network\n//     errors, the status goes back to \"unverified\".\n//\n//     WARNING: Currently verification is NOT IMPLEMENTED, so all proofs will be \"unverified\"\n//       for now and we just trust Keybase.\n\nFeatureKey = new Mongo.Collection(\"featureKey\", collectionOptions);\n// OBSOLETE: This was used to implement the Sandstorm for Work paywall, which has been removed.\n//   Collection object still defined because it could have old data in it, for servers that used\n//   to have a feature key.\n\nSetupSession = new Mongo.Collection(\"setupSession\", collectionOptions);\n// Responsible for storing information about setup sessions.  Contains a single document with three\n// keys:\n//\n//   _id: \"current-session\"\n//   creationDate: Date object indicating when this session was created.\n//   hashedSessionId: the sha256 of the secret session id that was returned to the client\n\nconst DesktopNotifications = new Mongo.Collection(\"desktopNotifications\", collectionOptions);\n// Responsible for very short-lived queueing of desktop notification information.\n// Entries are removed when they are ~30 seconds old.  This collection is a bit\n// odd in that it is intended primarily for edge-triggered communications, but\n// Meteor's collections aren't really designed to support that organization.\n// Fields for each :\n//\n//   _id: String.  Used as the tag to coordinate notification merging between browser tabs.\n//   creationDate: Date object. indicating when this notification was posted.\n//   userId: String. Account id to which this notification was published.\n//   notificationId: String.  ID of the matching event in the Notifications table to dismiss if this\n//                            notification is activated.\n//   appActivity: Object with fields:\n//     user: Optional Object. Not present if this notification wasn't generated by a user. If\n//           present, it will have one of the following shapes:\n//       { anonymous: true } if this notification was generated by an anonymous user.  Otherwise:\n//       {\n//         identityId: String  The user's identity ID.\n//         name: String        The user's display name.\n//         avatarUrl: String   The URL for the user's profile picture.\n//       },\n//     grainId: String,      Which grain this action took place on\n//     path: String,         The path of the notification.\n//     body: Util.LocalizedText,  The main body of the activity event.\n//     actionText: Util.LocalizedText, What action the user took, e.g.\n//                                     { defaultText: \"added a comment\" }\n\nconst StandaloneDomains = new Mongo.Collection(\"standaloneDomains\", collectionOptions);\n// A standalone domain that points to a single share link. These domains act a little different\n// than a normal shared Sandstorm grain. They completely drop any Sandstorm topbar/sidebar, and at\n// first glance look completely like a non-Sandstorm hosted webserver. The apps instead act in\n// concert with Sandstorm through the postMessage API, which allows it to do things like prompt for\n// login.\n// Fields for each :\n//\n//   _id: String. The domain name to use.\n//   token: String. _id of a sharing token (it must be a webkey).\n\nif (Meteor.isServer) {\n  Meteor.publish(\"credentials\", function () {\n    // Data needed for isSignedUp() and isAdmin() to work.\n\n    if (this.userId) {\n      const db = this.connection.sandstormDb;\n      return [\n        Meteor.users.find({ _id: this.userId },\n            { fields: { signupKey: 1, isAdmin: 1, expires: 1, storageUsage: 1,\n                      plan: 1, planBonus: 1, hasCompletedSignup: 1, experiments: 1,\n                      referredIdentityIds: 1, cachedStorageQuota: 1, suspended: 1, }, }),\n        db.collections.plans.find(),\n      ];\n    } else {\n      return [];\n    }\n  });\n}\n\nconst countReferrals = function (user) {\n  const referredIdentityIds = user.referredIdentityIds;\n  return (referredIdentityIds && referredIdentityIds.length || 0);\n};\n\nconst calculateReferralBonus = function (user) {\n  // This function returns an object of the form:\n  //\n  // - {grains: 0, storage: 0}\n  //\n  // which are extra resources this account gets as part of participating in the referral\n  // program. (Storage is measured in bytes, as usual for plans.)\n\n  // TODO(cleanup): Consider moving referral bonus logic into Oasis payments module (since it's\n  //   payments-specific) and aggregating into `planBonus`.\n\n  // Authorization note: Only call this if accountId is the current user!\n  const isPaid = (user.plan && user.plan !== \"free\");\n\n  successfulReferralsCount = countReferrals(user);\n  if (isPaid) {\n    const maxPaidStorageBonus = 30 * 1e9;\n    return { grains: 0,\n            storage: Math.min(\n              successfulReferralsCount * 2 * 1e9,\n              maxPaidStorageBonus), };\n  } else {\n    const maxFreeStorageBonus = 2 * 1e9;\n    const bonus = {\n      storage: Math.min(\n        successfulReferralsCount * 50 * 1e6,\n        maxFreeStorageBonus),\n    };\n    if (successfulReferralsCount > 0) {\n      bonus.grains = Infinity;\n    } else {\n      bonus.grains = 0;\n    }\n\n    return bonus;\n  }\n};\n\nisAdmin = function () {\n  // Returns true if the user is the administrator.\n\n  const user = Meteor.user();\n  if (user && user.isAdmin) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nisAdminById = function (id) {\n  // Returns true if the user's id is the administrator.\n\n  const user = Meteor.users.findOne({ _id: id }, { fields: { isAdmin: 1 } });\n  if (user && user.isAdmin) {\n    return true;\n  } else {\n    return false;\n  }\n};\n\nfindAdminUserForToken = function (token) {\n  if (!token.requirements) {\n    return;\n  }\n\n  const requirements = token.requirements.filter(function (requirement) {\n    return \"userIsAdmin\" in requirement;\n  });\n\n  if (requirements.length > 1) {\n    return;\n  }\n\n  if (requirements.length === 0) {\n    return;\n  }\n\n  return requirements[0].userIsAdmin;\n};\n\nconst wildcardHost = Meteor.settings.public.wildcardHost.toLowerCase().split(\"*\");\n\nif (wildcardHost.length != 2) {\n  throw new Error(\"Wildcard host must contain exactly one asterisk.\");\n}\n\nmatchWildcardHost = function (host) {\n  // See if the hostname is a member of our wildcard. If so, extract the ID.\n\n  // We remove everything after the first \":\" character so that our\n  // comparison logic ignores port numbers.\n  const prefix = wildcardHost[0];\n  const suffix = wildcardHost[1].split(\":\")[0];\n  const hostSansPort = host.split(\":\")[0];\n\n  if (hostSansPort.lastIndexOf(prefix, 0) >= 0 &&\n      hostSansPort.indexOf(suffix, -suffix.length) >= 0 &&\n      hostSansPort.length >= prefix.length + suffix.length) {\n    const id = hostSansPort.slice(prefix.length, -suffix.length);\n    if (id.match(/^[-a-z0-9]*$/)) {\n      return id;\n    }\n  }\n\n  return null;\n};\n\nmakeWildcardHost = function (id) {\n  return wildcardHost[0] + id + wildcardHost[1];\n};\n\nconst isApiHostId = function (hostId) {\n  if (hostId) {\n    const split = hostId.split(\"-\");\n    if (split[0] === \"api\") return split[1] || \"*\";\n  }\n\n  return false;\n};\n\nconst isTokenSpecificHostId = function (hostId) {\n  return hostId.lastIndexOf(\"api-\", 0) === 0;\n};\n\nlet apiHostIdHashForToken;\nif (Meteor.isServer) {\n  const Crypto = Npm.require(\"crypto\");\n  apiHostIdHashForToken = function (token) {\n    // Given an API token, compute the host ID that must be used when requesting this token.\n\n    // We add a leading 'x' to the hash so that knowing the hostname alone is not sufficient to\n    // find the corresponding API token in the ApiTokens table (whose _id values are also hashes\n    // of tokens). This doesn't technically add any security, but helps prove that we don't have\n    // any bugs which would allow someone who knows only the hostname to access the app API.\n    return Crypto.createHash(\"sha256\").update(\"x\" + token).digest(\"hex\").slice(0, 32);\n  };\n} else {\n  apiHostIdHashForToken = function (token) {\n    // Given an API token, compute the host ID that must be used when requesting this token.\n\n    // We add a leading 'x' to the hash so that knowing the hostname alone is not sufficient to\n    // find the corresponding API token in the ApiTokens table (whose _id values are also hashes\n    // of tokens). This doesn't technically add any security, but helps prove that we don't have\n    // any bugs which would allow someone who knows only the hostname to access the app API.\n    return SHA256(\"x\" + token).slice(0, 32);\n  };\n}\n\nconst apiHostIdForToken = function (token) {\n  return \"api-\" + apiHostIdHashForToken(token);\n};\n\nconst makeApiHost = function (token) {\n  return makeWildcardHost(apiHostIdForToken(token));\n};\n\nif (Meteor.isServer) {\n  const Url = Npm.require(\"url\");\n  getWildcardOrigin = function () {\n    // The wildcard URL can be something like \"foo-*-bar.example.com\", but sometimes when we're\n    // trying to specify a pattern matching hostnames (say, a Content-Security-Policy directive),\n    // an astrisk is only allowed as the first character and must be followed by a period. So we need\n    // \"*.example.com\" instead -- which matches more than we actually want, but is the best we can\n    // really do. We also add the protocol to the front (again, that's what CSP wants).\n\n    // TODO(cleanup): `protocol` is computed in other files, like proxy.js. Put it somewhere common.\n    const protocol = Url.parse(process.env.ROOT_URL).protocol;\n\n    const dotPos = wildcardHost[1].indexOf(\".\");\n    if (dotPos < 0) {\n      return protocol + \"//*\";\n    } else {\n      return protocol + \"//*\" + wildcardHost[1].slice(dotPos);\n    }\n  };\n}\n\nSandstormDb = function (quotaManager) {\n  // quotaManager is an object with the following method:\n  //   updateUserQuota: It is provided two arguments\n  //     db: This SandstormDb object\n  //     user: A collections.users account object\n  //   and returns a quota object:\n  //     storage: A number (can be Infinity)\n  //     compute: A number (can be Infinity)\n  //     grains: A number (can be Infinity)\n\n  this.quotaManager = quotaManager;\n  this.collections = {\n    // Direct access to underlying collections. DEPRECATED, but better than accessing the top-level\n    // collection globals directly.\n    //\n    // TODO(cleanup): Over time, we will provide methods covering each supported query and remove\n    //   direct access to the collections.\n    users: Meteor.users,\n\n    packages: Packages,\n    devPackages: DevPackages,\n    userActions: UserActions,\n    grains: Grains,\n    roleAssignments: RoleAssignments, // Deprecated, only used by the migration that eliminated it.\n    contacts: Contacts,\n    sessions: Sessions,\n    signupKeys: SignupKeys,\n    activityStats: ActivityStats,\n    deleteStats: DeleteStats,\n    fileTokens: FileTokens,\n    apiTokens: ApiTokens,\n    apiHosts: ApiHosts,\n    notifications: Notifications,\n    activitySubscriptions: ActivitySubscriptions,\n    statsTokens: StatsTokens,\n    misc: Misc,\n    settings: Settings,\n    migrations: Migrations,\n    staticAssets: StaticAssets,\n    assetUploadTokens: AssetUploadTokens,\n    plans: Plans,\n    appIndex: AppIndex,\n    keybaseProfiles: KeybaseProfiles,\n    setupSession: SetupSession,\n    desktopNotifications: DesktopNotifications,\n    standaloneDomains: StandaloneDomains,\n  };\n};\n\n// TODO(cleanup): These methods should not be defined freestanding and should use collection\n//   objects created in SandstormDb's constructor rather than globals.\n\n_.extend(SandstormDb.prototype, {\n  isAdmin: isAdmin,\n  isAdminById: isAdminById,\n  findAdminUserForToken: findAdminUserForToken,\n  matchWildcardHost: matchWildcardHost,\n  makeWildcardHost: makeWildcardHost,\n  isApiHostId: isApiHostId,\n  isTokenSpecificHostId: isTokenSpecificHostId,\n  apiHostIdHashForToken: apiHostIdHashForToken,\n  apiHostIdForToken: apiHostIdForToken,\n  makeApiHost: makeApiHost,\n  allowDevAccounts() {\n    const setting = this.collections.settings.findOne({ _id: \"devAccounts\" });\n    if (setting) {\n      return setting.value;\n    } else {\n      return Meteor.settings && Meteor.settings.public &&\n             Meteor.settings.public.allowDevAccounts;\n    }\n  },\n\n  roleAssignmentPattern: {\n    none: Match.Optional(null),\n    allAccess: Match.Optional(null),\n    roleId: Match.Optional(Match.Integer),\n    addPermissions: Match.Optional([Boolean]),\n    removePermissions: Match.Optional([Boolean]),\n  },\n\n  isDemoUser() {\n    // Returns true if this is a demo user.\n\n    const user = Meteor.user();\n    if (user && user.expires) {\n      return true;\n    } else {\n      return false;\n    }\n  },\n\n  isSignedUp() {\n    const user = Meteor.user();\n    return this.isAccountSignedUp(user);\n  },\n\n  isAccountSignedUp(user) {\n    // Returns true if the user has presented an invite key.\n\n    if (!user) return false;  // not signed in\n\n    if (!user.loginIdentities) return false;  // not an account\n\n    if (user.expires) return false;  // demo user.\n\n    if (Meteor.settings.public.allowUninvited) return true;  // all accounts qualify\n\n    if (user.signupKey) return true;  // user is invited\n\n    if (this.isUserInOrganization(user)) return true;\n\n    return false;\n  },\n\n  isSignedUpOrDemo() {\n    const user = Meteor.user();\n    return this.isAccountSignedUpOrDemo(user);\n  },\n\n  isAccountSignedUpOrDemo(user) {\n    if (!user) return false;  // not signed in\n\n    if (!user.loginIdentities) return false;  // not an account\n\n    if (user.expires) return true;  // demo user.\n\n    if (Meteor.settings.public.allowUninvited) return true;  // all accounts qualify\n\n    if (user.signupKey) return true;  // user is invited\n\n    if (this.isUserInOrganization(user)) return true;\n\n    return false;\n  },\n\n  isIdentityInOrganization(identity) {\n    if (!identity || !identity.services) {\n      return false;\n    }\n\n    const orgMembership = this.getOrganizationMembership();\n    const googleEnabled = orgMembership && orgMembership.google && orgMembership.google.enabled;\n    const googleDomain = orgMembership && orgMembership.google && orgMembership.google.domain;\n    const emailEnabled = orgMembership && orgMembership.emailToken && orgMembership.emailToken.enabled;\n    const emailDomain = orgMembership && orgMembership.emailToken && orgMembership.emailToken.domain;\n    const ldapEnabled = orgMembership && orgMembership.ldap && orgMembership.ldap.enabled;\n    const samlEnabled = orgMembership && orgMembership.saml && orgMembership.saml.enabled;\n    if (emailEnabled && emailDomain && identity.services.email) {\n      const domainSuffixes = emailDomain.split(/\\s*,\\s*/);\n      for (let i = 0; i < domainSuffixes.length; i++) {\n        const suffix = domainSuffixes[i];\n        const domain = identity.services.email.email.toLowerCase().split(\"@\").pop();\n        if (suffix.startsWith(\"*.\")) {\n          if (domain.endsWith(suffix.substr(1))) {\n            return true;\n          }\n        } else if (domain === suffix) {\n          return true;\n        }\n      }\n    } else if (ldapEnabled && identity.services.ldap) {\n      return true;\n    } else if (samlEnabled && identity.services.saml) {\n      return true;\n    } else if (googleEnabled && googleDomain && identity.services.google && identity.services.google.hd) {\n      if (identity.services.google.hd.toLowerCase() === googleDomain) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n\n  isUserInOrganization(user) {\n    for (let i = 0; i < user.loginIdentities.length; i++) {\n      let identity = Meteor.users.findOne({ _id: user.loginIdentities[i].id });\n      if (this.isIdentityInOrganization(identity)) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n});\n\nif (Meteor.isServer) {\n  SandstormDb.prototype.getWildcardOrigin = getWildcardOrigin;\n\n  const Crypto = Npm.require(\"crypto\");\n  SandstormDb.prototype.removeApiTokens = function (query) {\n    // Remove all API tokens matching the query, making sure to clean up ApiHosts as well.\n\n    this.collections.apiTokens.find(query).forEach((token) => {\n      // Clean up ApiHosts for webkey tokens.\n      if (token.hasApiHost) {\n        const hash2 = Crypto.createHash(\"sha256\").update(token._id).digest(\"base64\");\n        this.collections.apiHosts.remove({ hash2: hash2 });\n      }\n\n      // TODO(soon): Drop remote OAuth tokens for frontendRef.http. Unfortunately the way to do\n      //   this is different for every service. :( Also we may need to clarify with the \"bearer\"\n      //   type whether or not the token is \"owned\" by us...\n    });\n\n    this.collections.apiTokens.remove(query);\n  };\n}\n\n// TODO(someday): clean this up.  Logic for building static asset urls on client and server\n// appears all over the codebase.\nlet httpProtocol;\nif (Meteor.isServer) {\n  const Url = Npm.require(\"url\");\n  httpProtocol = Url.parse(process.env.ROOT_URL).protocol;\n} else {\n  httpProtocol = window.location.protocol;\n}\n\n// =======================================================================================\n// Below this point are newly-written or refactored functions.\n\n_.extend(SandstormDb.prototype, {\n  getUser(userId) {\n    check(userId, Match.OneOf(String, undefined, null));\n    if (userId) {\n      return Meteor.users.findOne(userId);\n    }\n  },\n\n  getIdentity(identityId) {\n    check(identityId, String);\n    const identity = Meteor.users.findOne({ _id: identityId });\n    if (identity) {\n      SandstormDb.fillInProfileDefaults(identity);\n      SandstormDb.fillInIntrinsicName(identity);\n      SandstormDb.fillInPictureUrl(identity);\n      return identity;\n    }\n  },\n\n  userHasIdentity(userId, identityId) {\n    check(userId, String);\n    check(identityId, String);\n\n    if (userId === identityId) return true;\n\n    const user = Meteor.users.findOne(userId);\n    return SandstormDb.getUserIdentityIds(user).indexOf(identityId) != -1;\n  },\n\n  userGrains(userId, options) {\n    check(userId, Match.OneOf(String, undefined, null));\n    check(options, Match.OneOf(undefined, null,\n        { includeTrashOnly: Match.Optional(Boolean), includeTrash: Match.Optional(Boolean), }));\n\n    const query = { userId: userId };\n    if (options && options.includeTrashOnly) {\n      query.trashed = { $exists: true };\n    } else if (options && options.includeTrash) {\n      // Keep query as-is.\n    } else {\n      query.trashed = { $exists: false };\n    }\n\n    return this.collections.grains.find(query);\n  },\n\n  currentUserGrains(options) {\n    return this.userGrains(Meteor.userId(), options);\n  },\n\n  getGrain(grainId) {\n    check(grainId, String);\n    return this.collections.grains.findOne(grainId);\n  },\n\n  userApiTokens(userId, trashed) {\n    check(userId, Match.OneOf(String, undefined, null));\n    check(trashed, Match.OneOf(Boolean, undefined, null));\n    const identityIds = SandstormDb.getUserIdentityIds(this.getUser(userId));\n    return this.collections.apiTokens.find({\n      \"owner.user.identityId\": { $in: identityIds },\n      trashed: { $exists: !!trashed },\n    });\n  },\n\n  currentUserApiTokens(trashed) {\n    return this.userApiTokens(Meteor.userId(), trashed);\n  },\n\n  userActions(user) {\n    return this.collections.userActions.find({ userId: user });\n  },\n\n  currentUserActions() {\n    return this.userActions(Meteor.userId());\n  },\n\n  iconSrcForPackage(pkg, usage) {\n    return Identicon.iconSrcForPackage(pkg, usage, httpProtocol + \"//\" + this.makeWildcardHost(\"static\"));\n  },\n\n  getDenormalizedGrainInfo(grainId) {\n    const grain = this.getGrain(grainId);\n    let pkg = this.collections.packages.findOne(grain.packageId);\n\n    if (!pkg) {\n      pkg = this.collections.devPackages.findOne(grain.packageId);\n    }\n\n    const appTitle = (pkg && pkg.manifest && pkg.manifest.appTitle) || { defaultText: \"\" };\n    const grainInfo = { appTitle: appTitle };\n\n    if (pkg && pkg.manifest && pkg.manifest.metadata && pkg.manifest.metadata.icons) {\n      const icons = pkg.manifest.metadata.icons;\n      const icon = icons.grain || icons.appGrid;\n      if (icon) {\n        grainInfo.icon = icon;\n      }\n    }\n\n    // Only provide an app ID if we have no icon asset to provide and need to offer an identicon.\n    if (!grainInfo.icon && pkg) {\n      grainInfo.appId = pkg.appId;\n    }\n\n    return grainInfo;\n  },\n\n  getPlan(id, user) {\n    check(id, String);\n\n    // `user`, if provided, is the user observing the plan. This matters only for checking if the\n    // user is in an experiment.\n\n    const plan = this.collections.plans.findOne(id);\n    if (!plan) {\n      throw new Error(\"no such plan: \" + id);\n    }\n\n    if (plan._id === \"free\") {\n      user = user || Meteor.user();\n      if (user && user.experiments &&\n          typeof user.experiments.freeGrainLimit === \"number\") {\n        plan.grains = user.experiments.freeGrainLimit;\n      }\n    }\n\n    return plan;\n  },\n\n  listPlans(user) {\n    user = user || Meteor.user();\n    if (user && user.experiments &&\n        typeof user.experiments.freeGrainLimit === \"number\") {\n      return this.collections.plans.find({}, { sort: { price: 1 } })\n          .map(plan => {\n        if (plan._id === \"free\") {\n          plan.grains = user.experiments.freeGrainLimit;\n        }\n\n        return plan;\n      });\n    } else {\n      return this.collections.plans.find({}, { sort: { price: 1 } }).fetch();\n    }\n  },\n\n  getMyPlan() {\n    const user = Meteor.user();\n    return user && this.collections.plans.findOne(user.plan || \"free\");\n  },\n\n  getMyReferralBonus(user) {\n    // This function is called from the server and from the client, similar to getMyPlan().\n    //\n    // The parameter may be omitted in which case the current user is assumed.\n\n    return calculateReferralBonus(user || Meteor.user());\n  },\n\n  getMyUsage(user) {\n    user = user || Meteor.user();\n    if (user && (Meteor.isServer || user.pseudoUsage)) {\n      if (Meteor.isClient) {\n        // Filled by pseudo-subscription to \"getMyUsage\". WARNING: The subscription is currently\n        // not reactive.\n        return user.pseudoUsage;\n      } else {\n        return {\n          grains: this.collections.grains.find({ userId: user._id }).count(),\n          storage: user.storageUsage || 0,\n          compute: 0,  // not tracked yet\n        };\n      }\n    } else {\n      return { grains: 0, storage: 0, compute: 0 };\n    }\n  },\n\n  isUninvitedFreeUser() {\n    if (!Meteor.settings.public.allowUninvited) return false;\n\n    const user = Meteor.user();\n    return user && !user.expires && (!user.plan || user.plan === \"free\");\n  },\n\n  getSetting(name) {\n    const setting = this.collections.settings.findOne(name);\n    return setting && setting.value;\n  },\n\n  getSettingWithFallback(name, fallbackValue) {\n    const value = this.getSetting(name);\n    if (value === undefined) {\n      return fallbackValue;\n    }\n\n    return value;\n  },\n\n  addUserActions(userId, packageId, simulation) {\n    check(userId, String);\n    check(packageId, String);\n\n    const pack = this.collections.packages.findOne({ _id: packageId });\n    if (pack) {\n      // Remove old versions.\n      const numRemoved = this.collections.userActions.remove({ userId: userId, appId: pack.appId });\n\n      // Install new.\n      const actions = pack.manifest.actions;\n      for (const i in actions) {\n        const action = actions[i];\n        if (\"none\" in action.input) {\n          const userAction = {\n            userId: userId,\n            packageId: pack._id,\n            appId: pack.appId,\n            appTitle: pack.manifest.appTitle,\n            appMarketingVersion: pack.manifest.appMarketingVersion,\n            appVersion: pack.manifest.appVersion,\n            title: action.title,\n            nounPhrase: action.nounPhrase,\n            command: action.command,\n          };\n          this.collections.userActions.insert(userAction);\n        } else {\n          // TODO(someday):  Implement actions with capability inputs.\n        }\n      }\n\n      if (numRemoved > 0 && !simulation) {\n        this.deleteUnusedPackages(pack.appId);\n      }\n    }\n  },\n\n  sendAdminNotification(type, action) {\n    Meteor.users.find({ isAdmin: true }, { fields: { _id: 1 } }).forEach(function (user) {\n      Notifications.insert({\n        admin: { action, type },\n        userId: user._id,\n        timestamp: new Date(),\n        isUnread: true,\n      });\n    });\n  },\n\n  getKeybaseProfile(keyFingerprint) {\n    return this.collections.keybaseProfiles.findOne(keyFingerprint) || {};\n  },\n\n  getServerTitle() {\n    const setting = this.collections.settings.findOne({ _id: \"serverTitle\" });\n    return setting ? setting.value : \"\";  // empty if subscription is not ready.\n  },\n\n  getSmtpConfig() {\n    const setting = this.collections.settings.findOne({ _id: \"smtpConfig\" });\n    return setting ? setting.value : undefined; // undefined if subscription is not ready.\n  },\n\n  getReturnAddress() {\n    const config = this.getSmtpConfig();\n    return config && config.returnAddress || \"\"; // empty if subscription is not ready.\n  },\n\n  getReturnAddressWithDisplayName(identityId) {\n    check(identityId, String);\n    const identity = this.getIdentity(identityId);\n    const displayName = identity.profile.name + \" (via \" + this.getServerTitle() + \")\";\n\n    // First remove any instances of characters that cause trouble for SimpleSmtp. Ideally,\n    // we could escape such characters with a backslash, but that does not seem to help here.\n    // TODO(cleanup): Unclear whether this sanitization is still necessary now that we return a\n    //   structured object and have moved to nodemailer. I'm not touching it for now.\n    const sanitized = displayName.replace(/\"|<|>|\\\\|\\r/g, \"\");\n\n    return { name: sanitized, address: this.getReturnAddress() };\n  },\n\n  getPrimaryEmail(accountId, identityId) {\n    check(accountId, String);\n    check(identityId, String);\n\n    const identity = this.getIdentity(identityId);\n    const senderEmails = SandstormDb.getVerifiedEmails(identity);\n    const senderPrimaryEmail = _.findWhere(senderEmails, { primary: true });\n    const accountPrimaryEmailAddress = this.getUser(accountId).primaryEmail;\n    if (_.findWhere(senderEmails, { email: accountPrimaryEmailAddress })) {\n      return accountPrimaryEmailAddress;\n    } else if (senderPrimaryEmail) {\n      return senderPrimaryEmail.email;\n    } else {\n      return null;\n    }\n  },\n\n  incrementDailySentMailCount(accountId) {\n    check(accountId, String);\n\n    const DAILY_LIMIT = 50;\n    const result = Meteor.users.findAndModify({\n      query: { _id: accountId },\n      update: {\n        $inc: {\n          dailySentMailCount: 1,\n        },\n      },\n      fields: { dailySentMailCount: 1 },\n    });\n\n    if (!result.ok) {\n      throw new Error(\"Couldn't update daily sent mail count.\");\n    }\n\n    const user = result.value;\n    if (user.dailySentMailCount >= DAILY_LIMIT) {\n      throw new Error(\n          \"Sorry, you've reached your e-mail sending limit for today. Currently, Sandstorm \" +\n          \"limits each user to \" + DAILY_LIMIT + \" e-mails per day for spam control reasons. \" +\n          \"Please feel free to contact us if this is a problem.\");\n    }\n  },\n\n  getLdapUrl() {\n    const setting = this.collections.settings.findOne({ _id: \"ldapUrl\" });\n    return setting ? setting.value : \"\";  // empty if subscription is not ready.\n  },\n\n  getLdapBase() {\n    const setting = this.collections.settings.findOne({ _id: \"ldapBase\" });\n    return setting ? setting.value : \"\";  // empty if subscription is not ready.\n  },\n\n  getLdapDnPattern() {\n    const setting = this.collections.settings.findOne({ _id: \"ldapDnPattern\" });\n    return setting ? setting.value : \"\";  // empty if subscription is not ready.\n  },\n\n  getLdapSearchUsername() {\n    const setting = this.collections.settings.findOne({ _id: \"ldapSearchUsername\" });\n    return setting ? setting.value : \"\";  // empty if subscription is not ready.\n  },\n\n  getLdapNameField() {\n    const setting = this.collections.settings.findOne({ _id: \"ldapNameField\" });\n    return setting ? setting.value : \"\";  // empty if subscription is not ready.\n  },\n\n  getLdapEmailField() {\n    const setting = this.collections.settings.findOne({ _id: \"ldapEmailField\" });\n    return setting ? setting.value : \"mail\";\n    // default to \"mail\". This setting was added later, and so could potentially be unset.\n  },\n\n  getLdapExplicitDnSelected() {\n    const setting = this.collections.settings.findOne({ _id: \"ldapExplicitDnSelected\" });\n    return setting && setting.value;\n  },\n\n  getLdapFilter() {\n    const setting = this.collections.settings.findOne({ _id: \"ldapFilter\" });\n    return setting ? setting.value : \"\";  // empty if subscription is not ready.\n  },\n\n  getLdapSearchBindDn() {\n    const setting = this.collections.settings.findOne({ _id: \"ldapSearchBindDn\" });\n    return setting ? setting.value : \"\";  // empty if subscription is not ready.\n  },\n\n  getLdapSearchBindPassword() {\n    const setting = this.collections.settings.findOne({ _id: \"ldapSearchBindPassword\" });\n    return setting ? setting.value : \"\";  // empty if subscription is not ready.\n  },\n\n  getLdapCaCert() {\n    const setting = this.collections.settings.findOne({ _id: \"ldapCaCert\" });\n    return setting ? setting.value : \"\";  // empty if subscription is not ready.\n  },\n\n  getOrganizationMembership() {\n    const setting = this.collections.settings.findOne({ _id: \"organizationMembership\" });\n    return setting && setting.value;\n  },\n\n  getOrganizationEmailEnabled() {\n    const membership = this.getOrganizationMembership();\n    return membership && membership.emailToken && membership.emailToken.enabled;\n  },\n\n  getOrganizationEmailDomain() {\n    const membership = this.getOrganizationMembership();\n    return membership && membership.emailToken && membership.emailToken.domain;\n  },\n\n  getOrganizationGoogleEnabled() {\n    const membership = this.getOrganizationMembership();\n    return membership && membership.google && membership.google.enabled;\n  },\n\n  getOrganizationGoogleDomain() {\n    const membership = this.getOrganizationMembership();\n    return membership && membership.google && membership.google.domain;\n  },\n\n  getOrganizationLdapEnabled() {\n    const membership = this.getOrganizationMembership();\n    return membership && membership.ldap && membership.ldap.enabled;\n  },\n\n  getOrganizationSamlEnabled() {\n    const membership = this.getOrganizationMembership();\n    return membership && membership.saml && membership.saml.enabled;\n  },\n\n  getOrganizationDisallowGuests() {\n    return this.getOrganizationDisallowGuestsRaw();\n  },\n\n  getOrganizationDisallowGuestsRaw() {\n    const setting = this.collections.settings.findOne({ _id: \"organizationSettings\" });\n    return setting && setting.value && setting.value.disallowGuests;\n  },\n\n  getOrganizationShareContacts() {\n    return this.getOrganizationShareContactsRaw();\n  },\n\n  getOrganizationShareContactsRaw() {\n    const setting = this.collections.settings.findOne({ _id: \"organizationSettings\" });\n    if (!setting || !setting.value || setting.value.shareContacts === undefined) {\n      // default to true if undefined\n      return true;\n    } else {\n      return setting.value.shareContacts;\n    }\n  },\n\n  getSamlEntryPoint() {\n    const setting = this.collections.settings.findOne({ _id: \"samlEntryPoint\" });\n    return setting ? setting.value : \"\";  // empty if subscription is not ready.\n  },\n\n  getSamlLogout() {\n    const setting = this.collections.settings.findOne({ _id: \"samlLogout\" });\n    return setting ? setting.value : \"\";  // empty if subscription is not ready.\n  },\n\n  getSamlPublicCert() {\n    const setting = this.collections.settings.findOne({ _id: \"samlPublicCert\" });\n    return setting ? setting.value : \"\";  // empty if subscription is not ready.\n  },\n\n  getSamlEntityId() {\n    const setting = this.collections.settings.findOne({ _id: \"samlEntityId\" });\n    return setting ? setting.value : \"\"; // empty if subscription is not ready.\n  },\n\n  userHasSamlLoginIdentity() {\n    const user = Meteor.user();\n    if (!user.loginIdentities) {\n      return false;\n    }\n\n    let hasSaml = false;\n    user.loginIdentities.forEach((identity) => {\n      if (Meteor.users.findOne({ _id: identity.id }).services.saml) {\n        hasSaml = true;\n      }\n    });\n\n    return hasSaml;\n  },\n\n  getActivitySubscriptions(grainId, threadPath) {\n    return this.collections.activitySubscriptions.find({\n      grainId: grainId,\n      threadPath: threadPath || { $exists: false },\n    }, {\n      fields: { identityId: 1, mute: 1, _id: 0 },\n    }).fetch();\n  },\n\n  subscribeToActivity(identityId, grainId, threadPath) {\n    // Subscribe the given identity to activity events with the given grainId and (optional)\n    // threadPath -- unless the identity has previously muted this grainId/threadPath, in which\n    // case do nothing.\n\n    const record = { identityId, grainId };\n    if (threadPath) {\n      record.threadPath = threadPath;\n    }\n\n    // The $set here is redundant since an upsert automatically initializes a new record to contain\n    // the fields from the query, but if we try to do { $set: {} } Mongo throws an exception, and\n    // if we try to just pass {}, Mongo interprets it as \"replace the record with an empty record\".\n    // What a wonderful query language.\n    this.collections.activitySubscriptions.upsert(record, { $set: record });\n  },\n\n  muteActivity(identityId, grainId, threadPath) {\n    // Mute notifications for the given identity originating from the given grainId and\n    // (optional) threadPath.\n\n    const record = { identityId, grainId };\n    if (threadPath) {\n      record.threadPath = threadPath;\n    }\n\n    this.collections.activitySubscriptions.upsert(record, { $set: { mute: true } });\n  },\n\n  updateAppIndex() {\n    const appUpdatesEnabledSetting = this.collections.settings.findOne({ _id: \"appUpdatesEnabled\" });\n    const appUpdatesEnabled = appUpdatesEnabledSetting && appUpdatesEnabledSetting.value;\n    if (!appUpdatesEnabled) {\n      // It's much simpler to check appUpdatesEnabled here rather than reactively deactivate the\n      // timer that triggers this call.\n      return;\n    }\n\n    const appIndexUrl = this.collections.settings.findOne({ _id: \"appIndexUrl\" }).value;\n    const appIndex = this.collections.appIndex;\n    const data = HTTP.get(appIndexUrl + \"/apps/index.json\").data;\n    const preinstalledAppIds = this.getAllPreinstalledAppIds();\n    // We make sure to get all preinstalled appIds, even ones that are currently\n    // downloading/failed.\n    data.apps.forEach((app) => {\n      app._id = app.appId;\n\n      const oldApp = appIndex.findOne({ _id: app.appId });\n      app.hasSentNotifications = false;\n      appIndex.upsert({ _id: app._id }, app);\n      const isAppPreinstalled = _.contains(preinstalledAppIds, app.appId);\n      if ((!oldApp || app.versionNumber > oldApp.versionNumber) &&\n          (this.collections.userActions.findOne({ appId: app.appId }) ||\n          isAppPreinstalled)) {\n        const pack = this.collections.packages.findOne({ _id: app.packageId });\n        const url = appIndexUrl + \"/packages/\" + app.packageId;\n        if (pack) {\n          if (pack.status === \"ready\") {\n            if (pack.appId && pack.appId !== app.appId) {\n              console.error(\"app index returned app ID and package ID that don't match:\",\n                            JSON.stringify(app));\n            } else {\n              this.sendAppUpdateNotifications(app.appId, app.packageId, app.name, app.versionNumber,\n                app.version);\n              if (isAppPreinstalled) {\n                this.setPreinstallAppAsReady(app.appId, app.packageId);\n              }\n            }\n          } else {\n            const result = this.collections.packages.findAndModify({\n              query: { _id: app.packageId },\n              update: { $set: { isAutoUpdated: true } },\n            });\n\n            if (!result.ok) {\n              return;\n            }\n\n            const newPack = result.value;\n            if (newPack.status === \"ready\") {\n              // The package was marked as ready before we applied isAutoUpdated=true. We should send\n              // notifications ourselves to be sure there's no timing issue (sending more than one is\n              // fine, since it will de-dupe).\n              if (pack.appId && pack.appId !== app.appId) {\n                console.error(\"app index returned app ID and package ID that don't match:\",\n                              JSON.stringify(app));\n              } else {\n                this.sendAppUpdateNotifications(app.appId, app.packageId, app.name, app.versionNumber,\n                  app.version);\n                if (isAppPreinstalled) {\n                  this.setPreinstallAppAsReady(app.appId, app.packageId);\n                }\n              }\n            } else if (newPack.status === \"failed\") {\n              // If the package has failed, retry it\n              this.startInstall(app.packageId, url, true, true);\n            }\n          }\n        } else {\n          this.startInstall(app.packageId, url, false, true);\n        }\n      }\n    });\n  },\n\n  isPackagePreinstalled(packageId) {\n    return this.collections.settings.find({ _id: \"preinstalledApps\", \"value.packageId\": packageId }).count() === 1;\n  },\n\n  getAppIdForPreinstalledPackage(packageId) {\n    const setting = this.collections.settings.findOne({ _id: \"preinstalledApps\", \"value.packageId\": packageId },\n    { fields: { \"value.$\": 1 } });\n    // value.$ causes mongo to transform the result and only return the first matching element in\n    // the array\n    return setting && setting.value && setting.value[0] && setting.value[0].appId;\n  },\n\n  getPackageIdForPreinstalledApp(appId) {\n    const setting = this.collections.settings.findOne({ _id: \"preinstalledApps\", \"value.appId\": appId },\n    { fields: { \"value.$\": 1 } });\n    // value.$ causes mongo to transform the result and only return the first matching element in\n    // the array\n    return setting && setting.value && setting.value[0] && setting.value[0].packageId;\n  },\n\n  getReadyPreinstalledAppIds() {\n    const setting = this.collections.settings.findOne({ _id: \"preinstalledApps\" });\n    const ret = setting && setting.value || [];\n    return _.chain(ret)\n            .filter((app) => { return app.status === \"ready\"; })\n            .map((app) => { return app.appId; })\n            .value();\n  },\n\n  getAllPreinstalledAppIds() {\n    const setting = this.collections.settings.findOne({ _id: \"preinstalledApps\" });\n    const ret = setting && setting.value || [];\n    return _.map(ret, (app) => { return app.appId; });\n  },\n\n  preinstallAppsForUser(userId) {\n    const appIds = this.getReadyPreinstalledAppIds();\n    appIds.forEach((appId) => {\n      try {\n        this.addUserActions(userId, this.getPackageIdForPreinstalledApp(appId));\n      } catch (e) {\n        console.error(\"failed to install app for user:\", e);\n      }\n    });\n  },\n\n  setPreinstallAppAsDownloading(appId, packageId) {\n    this.collections.settings.update(\n      { _id: \"preinstalledApps\", \"value.appId\": appId, \"value.packageId\": packageId },\n      { $set: { \"value.$.status\": \"downloading\" } });\n  },\n\n  setPreinstallAppAsReady(appId, packageId) {\n    // This function both sets the appId as ready and updates the packageId for the given appId\n    // Setting the packageId is especially useful in installer.js, as it always ensures the\n    // latest installed package will be set as ready.\n    this.collections.settings.update(\n      { _id: \"preinstalledApps\", \"value.appId\": appId },\n      { $set: { \"value.$.status\": \"ready\", \"value.$.packageId\": packageId } });\n  },\n\n  ensureAppPreinstall(appId, packageId) {\n    check(appId, String);\n    const appIndexUrl = this.collections.settings.findOne({ _id: \"appIndexUrl\" }).value;\n    const pack = this.collections.packages.findOne({ _id: packageId });\n    const url = appIndexUrl + \"/packages/\" + packageId;\n    if (pack && pack.status === \"ready\") {\n      this.setPreinstallAppAsReady(appId, packageId);\n    } else if (pack && pack.status === \"failed\") {\n      this.setPreinstallAppAsDownloading(appId, packageId);\n      this.startInstall(packageId, url, true, false);\n    } else {\n      this.setPreinstallAppAsDownloading(appId, packageId);\n      this.startInstall(packageId, url, false, false);\n    }\n  },\n\n  setPreinstalledApps(appAndPackageIds) {\n    // appAndPackageIds: A List[Object] where each element has fields:\n    //     appId: The Packages.appId of the app to install\n    //     packageId: The Packages._id of the app to install\n    check(appAndPackageIds, [{ appId: String, packageId: String, }]);\n\n    // Start by clearing out the setting. We'll push appIds one by one to it\n    this.collections.settings.upsert({ _id: \"preinstalledApps\" }, { $set: {\n      value: appAndPackageIds.map((data) => {\n        return {\n          appId: data.appId,\n          status: \"notReady\",\n          packageId: data.packageId,\n        };\n      }),\n    }, });\n    appAndPackageIds.forEach((data) => {\n      this.ensureAppPreinstall(data.appId, data.packageId);\n    });\n  },\n\n  getProductivitySuiteAppIds() {\n    return [\n      \"8aspz4sfjnp8u89000mh2v1xrdyx97ytn8hq71mdzv4p4d8n0n3h\", // Davros\n      \"h37dm17aa89yrd8zuqpdn36p6zntumtv08fjpu8a8zrte7q1cn60\", // Etherpad\n      \"vfnwptfn02ty21w715snyyczw0nqxkv3jvawcah10c6z7hj1hnu0\", // Rocket.Chat\n      \"m86q05rdvj14yvn78ghaxynqz7u2svw6rnttptxx49g1785cdv1h\", // Wekan\n    ];\n  },\n\n  getSystemSuiteAppIds() {\n    return [\n      \"s3u2xgmqwznz2n3apf30sm3gw1d85y029enw5pymx734cnk5n78h\", // Collections\n    ];\n  },\n\n  isPreinstalledAppsReady() {\n    const setting = this.collections.settings.findOne({ _id: \"preinstalledApps\" });\n    if (!setting || !setting.value) {\n      return true;\n    }\n\n    const packageIds = _.pluck(setting.value, \"packageId\");\n    const readyApps = this.collections.packages.find({\n      _id: {\n        $in: packageIds,\n      },\n      status: \"ready\",\n    });\n    return readyApps.count() === packageIds.length;\n  },\n\n  getBillingPromptUrl() {\n    const setting = this.collections.settings.findOne({ _id: \"billingPromptUrl\" });\n    return setting && setting.value;\n  },\n\n  isReferralEnabled() {\n    // This function is a bit weird, in that we've transitioned from\n    // Meteor.settings.public.quotaEnabled to DB settings. For now,\n    // Meteor.settings.public.quotaEnabled implies bothisReferralEnabled and isQuotaEnabled are true.\n    return Meteor.settings.public.quotaEnabled;\n  },\n\n  isHideAboutEnabled() {\n    const setting = this.collections.settings.findOne({ _id: \"whiteLabelHideAbout\" });\n    return setting && setting.value;\n  },\n\n  isQuotaEnabled() {\n    if (Meteor.settings.public.quotaEnabled) return true;\n\n    const setting = this.collections.settings.findOne({ _id: \"quotaEnabled\" });\n    return setting && setting.value;\n  },\n\n  isQuotaLdapEnabled() {\n    const setting = this.collections.settings.findOne({ _id: \"quotaLdapEnabled\" });\n    return setting && setting.value;\n  },\n\n  updateUserQuota(user) {\n    if (this.quotaManager) {\n      return this.quotaManager.updateUserQuota(this, user);\n    }\n  },\n\n  getUserQuota(user) {\n    if (this.isQuotaLdapEnabled()) {\n      return this.quotaManager.updateUserQuota(this, user);\n    } else {\n      const plan = this.getPlan(user.plan || \"free\", user);\n      const referralBonus = calculateReferralBonus(user);\n      const bonus = user.planBonus || {};\n      const userQuota = {\n        storage: plan.storage + referralBonus.storage + (bonus.storage || 0),\n        grains: plan.grains + referralBonus.grains + (bonus.grains || 0),\n        compute: plan.compute + (bonus.compute || 0),\n      };\n      return userQuota;\n    }\n  },\n\n  isUserOverQuota(user) {\n    // Return false if user has quota space remaining, true if it is full. When this returns true,\n    // we will not allow the user to create new grains, though they may be able to open existing ones\n    // which may still increase their storage usage.\n    //\n    // (Actually returns a string which can be fed into `billingPrompt` as the reason.)\n\n    if (!this.isQuotaEnabled() || user.isAdmin) return false;\n\n    const plan = this.getUserQuota(user);\n    if (plan.grains < Infinity) {\n      const count = this.collections.grains.find({ userId: user._id, trashed: { $exists: false } },\n        { fields: {}, limit: plan.grains }).count();\n      if (count >= plan.grains) return \"outOfGrains\";\n    }\n\n    return plan && user.storageUsage && user.storageUsage >= plan.storage && \"outOfStorage\";\n  },\n\n  isUserExcessivelyOverQuota(user) {\n    // Return true if user is so far over quota that we should prevent their existing grains from\n    // running at all.\n    //\n    // (Actually returns a string which can be fed into `billingPrompt` as the reason.)\n\n    if (!this.isQuotaEnabled() || user.isAdmin) return false;\n\n    const quota = this.getUserQuota(user);\n\n    // quota.grains = Infinity means unlimited grains. IEEE754 defines Infinity == Infinity.\n    if (quota.grains < Infinity) {\n      const count = this.collections.grains.find({ userId: user._id, trashed: { $exists: false } },\n        { fields: {}, limit: quota.grains * 2 }).count();\n      if (count >= quota.grains * 2) return \"outOfGrains\";\n    }\n\n    return quota && user.storageUsage && user.storageUsage >= quota.storage * 1.2 && \"outOfStorage\";\n  },\n\n  suspendIdentity(userId, suspension) {\n    check(userId, String);\n    check(suspension, {\n      timestamp: Date,\n      admin: Match.Optional(String),\n      voluntary: Match.Optional(Boolean),\n    });\n\n    this.collections.users.update({ _id: userId }, { $set: { suspended: suspension } });\n    this.collections.apiTokens.update({ \"owner.user.identityId\": userId },\n      { $set: { suspended: true } }, { multi: true });\n  },\n\n  unsuspendIdentity(userId) {\n    check(userId, String);\n\n    this.collections.users.update({ _id: userId }, { $unset: { suspended: 1 } });\n    this.collections.apiTokens.update({ \"owner.user.identityId\": userId },\n      { $unset: { suspended: true } }, { multi: true });\n  },\n\n  suspendAccount(userId, byAdminUserId, willDelete) {\n    check(userId, String);\n    check(byAdminUserId, Match.OneOf(String, null, undefined));\n    check(willDelete, Boolean);\n\n    const user = this.collections.users.findOne({ _id: userId });\n    const suspension = {\n      timestamp: new Date(),\n      willDelete: willDelete || false,\n    };\n    if (byAdminUserId) {\n      suspension.admin = byAdminUserId;\n    } else {\n      suspension.voluntary = true;\n    }\n\n    this.collections.users.update({ _id: userId }, { $set: { suspended: suspension } });\n    this.collections.grains.update({ userId: userId }, { $set: { suspended: true } }, { multi: true });\n\n    delete suspension.willDelete;\n    // Only mark the parent account for deletion. This makes the query simpler later.\n\n    user.loginIdentities.forEach((identity) => {\n      this.suspendIdentity(identity.id, suspension);\n    });\n    user.nonloginIdentities.forEach((identity) => {\n      if (this.collections.users.find({ $or: [\n        { \"loginIdentities.id\": identity.id },\n        { \"nonloginIdentities.id\": identity.id },\n      ], }).count() === 1) {\n        // Only suspend non-login identities that are unique to this account.\n        this.suspendIdentity(identity.id, suspension);\n      }\n    });\n\n    // Force logout this user\n    this.collections.users.update({ _id: userId },\n      { $unset: { \"services.resume.loginTokens\": 1 } });\n    if (user && user.loginIdentities) {\n      user.loginIdentities.forEach(function (identity) {\n        Meteor.users.update({ _id: identity.id }, { $unset: { \"services.resume.loginTokens\": 1 } });\n      });\n    }\n  },\n\n  unsuspendAccount(userId) {\n    check(userId, String);\n\n    const user = this.collections.users.findOne({ _id: userId });\n    this.collections.users.update({ _id: userId }, { $unset: { suspended: 1 } });\n    this.collections.grains.update({ userId: userId }, { $unset: { suspended: 1 } }, { multi: true });\n\n    user.loginIdentities.forEach((identity) => {\n      this.unsuspendIdentity(identity.id);\n    });\n\n    user.nonloginIdentities.forEach((identity) => {\n      this.unsuspendIdentity(identity.id);\n    });\n  },\n\n  deletePendingAccounts(deletionCoolingOffTime, backend, cb) {\n    check(deletionCoolingOffTime, Number);\n\n    const queryDate = new Date(Date.now() - deletionCoolingOffTime);\n    this.collections.users.find({\n      \"suspended.willDelete\": true,\n      \"suspended.timestamp\": { $lt: queryDate },\n    }).forEach((user) => {\n      if (cb) cb(this, user);\n      this.deleteAccount(user._id, backend);\n    });\n  },\n\n  hostIsStandalone: function (hostname) {\n    check(hostname, String);\n\n    return !!this.collections.standaloneDomains.findOne({ _id: hostname, });\n  },\n});\n\nSandstormDb.escapeMongoKey = (key) => {\n  // This incredibly poor mechanism for escaping Mongo keys is recommended by the Mongo docs here:\n  //   https://docs.mongodb.org/manual/faq/developers/#dollar-sign-operator-escaping\n  // and seems to be a de facto standard, for example:\n  //   https://www.npmjs.com/package/mongo-key-escape\n  return key.replace(\".\", \"\\uFF0E\").replace(\"$\", \"\\uFF04\");\n};\n\nconst appNameFromPackage = function (packageObj) {\n  // This function takes a Package object from Mongo and returns an\n  // app title.\n  const manifest = packageObj.manifest;\n  if (!manifest) return packageObj.appId || packageObj._id || \"unknown\";\n  const action = manifest.actions[0];\n  appName = (manifest.appTitle && manifest.appTitle.defaultText) ||\n    appNameFromActionName(action.title.defaultText);\n  return appName;\n};\n\nconst appNameFromActionName = function (name) {\n  // Hack: Historically we only had action titles, like \"New Etherpad Document\", not app\n  //   titles. But for this UI we want app titles. As a transitionary measure, try to\n  //   derive the app title from the action title.\n  // TODO(cleanup): Get rid of this once apps have real titles.\n  if (!name) {\n    return \"(unnamed)\";\n  }\n\n  if (name.lastIndexOf(\"New \", 0) === 0) {\n    name = name.slice(4);\n  }\n\n  if (name.lastIndexOf(\"Hacker CMS\", 0) === 0) {\n    name = \"Hacker CMS\";\n  } else {\n    const space = name.indexOf(\" \");\n    if (space > 0) {\n      name = name.slice(0, space);\n    }\n  }\n\n  return name;\n};\n\nconst appShortDescriptionFromPackage = function (pkg) {\n  return pkg && pkg.manifest && pkg.manifest.metadata &&\n         pkg.manifest.metadata.shortDescription &&\n         pkg.manifest.metadata.shortDescription.defaultText;\n};\n\nconst nounPhraseForActionAndAppTitle = function (action, appTitle) {\n  // A hack to deal with legacy apps not including fields in their manifests.\n  // I look forward to the day I can remove most of this code.\n  // Attempt to figure out the appropriate noun that this action will create.\n  // Use an explicit noun phrase is one is available.  Apps should add these in the future.\n  if (action.nounPhrase) return action.nounPhrase.defaultText;\n  // Otherwise, try to guess one from the structure of the action title field\n  if (action.title && action.title.defaultText) {\n    const text = action.title.defaultText;\n    // Strip a leading \"New \"\n    if (text.lastIndexOf(\"New \", 0) === 0) {\n      const candidate = text.slice(4);\n      // Strip a leading appname too, if provided\n      if (candidate.lastIndexOf(appTitle, 0) === 0) {\n        const newCandidate = candidate.slice(appTitle.length);\n        // Unless that leaves you with no noun, in which case, use \"grain\"\n        if (newCandidate.length > 0) {\n          return newCandidate.toLowerCase();\n        } else {\n          return \"grain\";\n        }\n      }\n\n      return candidate.toLowerCase();\n    }\n    // Some other verb phrase was given.  Just use it verbatim, and hope the app author updates\n    // the package soon.\n    return text;\n  } else {\n    return \"grain\";\n  }\n};\n\n// Static methods on SandstormDb that don't need an instance.\n// Largely things that deal with backwards-compatibility.\n_.extend(SandstormDb, {\n  appNameFromActionName: appNameFromActionName,\n  appNameFromPackage: appNameFromPackage,\n  appShortDescriptionFromPackage: appShortDescriptionFromPackage,\n  nounPhraseForActionAndAppTitle: nounPhraseForActionAndAppTitle,\n});\n\nif (Meteor.isServer) {\n  const Crypto = Npm.require(\"crypto\");\n  const ContentType = Npm.require(\"content-type\");\n  const Zlib = Npm.require(\"zlib\");\n  const Url = Npm.require(\"url\");\n\n  const replicaNumber = Meteor.settings.replicaNumber || 0;\n\n  const computeStagger = function (n) {\n    // Compute a fraction in the range [0, 1) such that, for any natural number k, the values\n    // of computeStagger(n) for all n in [1, 2^k) are uniformly distributed between 0 and 1.\n    // The sequence looks like:\n    //   0, 1/2, 1/4, 3/4, 1/8, 3/8, 5/8, 7/8, 1/16, ...\n    //\n    // We use this to determine how we'll stagger periodic events performed by this replica.\n    // Notice that this allows us to compute a stagger which is independent of the number of\n    // front-end replicas present; we can add more replicas to the end without affecting how the\n    // earlier ones schedule their events.\n    let denom = 1;\n    while (denom <= n) denom <<= 1;\n    const num = n * 2 - denom + 1;\n    return num / denom;\n  };\n\n  const stagger = computeStagger(replicaNumber);\n\n  SandstormDb.periodicCleanup = function (intervalMs, callback) {\n    // Register a database cleanup function than should run periodically, roughly once every\n    // interval of the given length.\n    //\n    // In a blackrock deployment with multiple front-ends, the frequency of the cleanup will be\n    // scaled appropriately on the assumption that more data is being generated demanding more\n    // frequent cleanups.\n\n    check(intervalMs, Number);\n    check(callback, Function);\n\n    if (intervalMs < 120000) {\n      throw new Error(\"less than 2-minute cleanup interval seems too fast; \" +\n                      \"are you using the right units?\");\n    }\n\n    // Schedule first cleanup to happen at the next intervalMs interval from the epoch, so that\n    // the schedule is independent of the exact startup time.\n    let first = intervalMs - Date.now() % intervalMs;\n\n    // Stagger cleanups across replicas so that we don't have all replicas trying to clean the\n    // same data at the same time.\n    first += Math.floor(intervalMs * computeStagger(replicaNumber));\n\n    // If the stagger put us more than an interval away from now, back up.\n    if (first > intervalMs) first -= intervalMs;\n\n    Meteor.setTimeout(function () {\n      callback();\n      Meteor.setInterval(callback, intervalMs);\n    }, first);\n  };\n\n  // TODO(cleanup): Node 0.12 has a `gzipSync` but 0.10 (which Meteor still uses) does not.\n  const gzipSync = Meteor.wrapAsync(Zlib.gzip, Zlib);\n\n  const BufferSmallerThan = function (limit) {\n    return Match.Where(function (buf) {\n      check(buf, Buffer);\n      return buf.length < limit;\n    });\n  };\n\n  const DatabaseId = Match.Where(function (s) {\n    check(s, String);\n    return !!s.match(/^[a-zA-Z0-9_]+$/);\n  });\n\n  SandstormDb.prototype.addStaticAsset = function (metadata, content) {\n    // Add a new static asset to the database. If `content` is a string rather than a buffer, it\n    // will be automatically gzipped before storage; do not specify metadata.encoding in this case.\n\n    if (typeof content === \"string\" && !metadata.encoding) {\n      content = gzipSync(new Buffer(content, \"utf8\"));\n      metadata.encoding = \"gzip\";\n    }\n\n    check(metadata, {\n      mimeType: String,\n      encoding: Match.Optional(\"gzip\"),\n    });\n    check(content, BufferSmallerThan(1 << 20));\n\n    // Validate content type.\n    metadata.mimeType = ContentType.format(ContentType.parse(metadata.mimeType));\n\n    const hasher = Crypto.createHash(\"sha256\");\n    hasher.update(metadata.mimeType + \"\\n\" + metadata.encoding + \"\\n\", \"utf8\");\n    hasher.update(content);\n    const hash = hasher.digest(\"base64\");\n\n    const result = this.collections.staticAssets.findAndModify({\n      query: { hash: hash, refcount: { $gte: 1 } },\n      update: { $inc: { refcount: 1 } },\n      fields: { _id: 1, refcount: 1 },\n    });\n\n    if (!result.ok) {\n      throw new Error(`Couldn't increment refcount of asset with hash ${hash}`);\n    }\n\n    const existing = result.value;\n    if (existing) {\n      return existing._id;\n    }\n\n    return this.collections.staticAssets.insert(_.extend({\n      hash: hash,\n      content: content,\n      refcount: 1,\n    }, metadata));\n  };\n\n  SandstormDb.prototype.refStaticAsset = function (id) {\n    // Increment the refcount on an existing static asset. Returns the asset on success.\n    // If the asset does not exist, returns a falsey value.\n    //\n    // You must call this BEFORE adding the new reference to the DB, in case of failure between\n    // the two calls. (This way, the failure case is a storage leak, which is probably not a big\n    // deal and can be fixed by GC, rather than a mysteriously missing asset.)\n\n    check(id, String);\n\n    const result = this.collections.staticAssets.findAndModify({\n      query: { hash: hash },\n      update: { $inc: { refcount: 1 } },\n      fields: { _id: 1, content: 1, mimeType: 1 },\n    });\n\n    if (!result.ok) {\n      throw new Error(`Couldn't increment refcount of asset with hash ${hash}`);\n    }\n\n    const existing = result.value;\n    return existing;\n  };\n\n  SandstormDb.prototype.unrefStaticAsset = function (id) {\n    // Decrement refcount on a static asset and delete if it has reached zero.\n    //\n    // You must call this AFTER removing the reference from the DB, in case of failure between\n    // the two calls. (This way, the failure case is a storage leak, which is probably not a big\n    // deal and can be fixed by GC, rather than a mysteriously missing asset.)\n\n    check(id, String);\n\n    const result = this.collections.staticAssets.findAndModify({\n      query: { _id: id },\n      update: { $inc: { refcount: -1 } },\n      fields: { _id: 1, refcount: 1 },\n      new: true,\n    });\n\n    if (!result.ok) {\n      throw new Error(`Couldn't unref static asset ${id}`);\n    }\n\n    const existing = result.value;\n    if (!existing) {\n      console.error(new Error(\"unrefStaticAsset() called on asset that doesn't exist\").stack);\n    } else if (existing.refcount <= 0) {\n      this.collections.staticAssets.remove({ _id: existing._id });\n    }\n  };\n\n  SandstormDb.prototype.getStaticAsset = function (id) {\n    // Get a static asset's mimeType, encoding, and raw content.\n\n    check(id, String);\n\n    const asset = this.collections.staticAssets.findOne(id, { fields: { _id: 0, mimeType: 1, encoding: 1, content: 1 } });\n    if (asset) {\n      // TODO(perf): Mongo converts buffers to something else. Figure out a way to avoid a copy\n      //   here.\n      asset.content = new Buffer(asset.content);\n    }\n\n    return asset;\n  };\n\n  SandstormDb.prototype.newAssetUpload = function (purpose) {\n    check(purpose, Match.OneOf(\n      { profilePicture: { userId: DatabaseId, identityId: DatabaseId } },\n      { loginLogo: {} },\n    ));\n\n    return this.collections.assetUploadTokens.insert({\n      purpose: purpose,\n      expires: new Date(Date.now() + 300000),  // in 5 minutes\n    });\n  };\n\n  SandstormDb.prototype.fulfillAssetUpload = function (id) {\n    // Indicates that the given asset upload has completed. It will be removed and its purpose\n    // returned. If no matching upload exists, returns undefined.\n\n    check(id, String);\n\n    const result = this.collections.assetUploadTokens.findAndModify({\n      query: { _id: id },\n      remove: true,\n    });\n\n    if (!result.ok) {\n      throw new Error(\"Failed to remove asset upload token\");\n    }\n\n    const upload = result.value;\n\n    if (upload.expires.valueOf() < Date.now()) {\n      return undefined;  // already expired\n    } else {\n      return upload.purpose;\n    }\n  };\n\n  SandstormDb.prototype.cleanupExpiredAssetUploads = function () {\n    this.collections.assetUploadTokens.remove({ expires: { $lt: Date.now() } });\n  };\n\n  // TODO(cleanup): lift this out of the package so it can share with the ones in async-helpers.js\n  const Future = Npm.require(\"fibers/future\");\n  const promiseToFuture = (promise) => {\n    const result = new Future();\n    promise.then(result.return.bind(result), result.throw.bind(result));\n    return result;\n  };\n\n  const waitPromise = (promise) => {\n    return promiseToFuture(promise).wait();\n  };\n\n  SandstormDb.prototype.deleteGrains = function (query, backend, type) {\n    // Returns the number of grains deleted.\n\n    check(type, Match.OneOf(\"grain\", \"demoGrain\"));\n\n    let numDeleted = 0;\n    this.collections.grains.find(query).forEach((grain) => {\n      const user = Meteor.users.findOne(grain.userId);\n\n      waitPromise(backend.deleteGrain(grain._id, grain.userId));\n      numDeleted += this.collections.grains.remove({ _id: grain._id });\n      this.removeApiTokens({\n        grainId: grain._id,\n        $or: [\n          { owner: { $exists: false } },\n          { owner: { webkey: null } },\n        ],\n      });\n\n      this.removeApiTokens({ \"owner.grain.grainId\": grain._id });\n\n      this.collections.activitySubscriptions.remove({ grainId: grain._id });\n\n      if (grain.lastUsed) {\n        const record = {\n          type: \"grain\",  // Demo grains can never get here!\n          lastActive: grain.lastUsed,\n          appId: grain.appId,\n        };\n        if (user && user.experiments) {\n          record.experiments = user.experiments;\n        }\n\n        this.collections.deleteStats.insert(record);\n      }\n\n      this.deleteUnusedPackages(grain.appId);\n\n      if (grain.size) {\n        Meteor.users.update(grain.userId, { $inc: { storageUsage: -grain.size } });\n      }\n    });\n    return numDeleted;\n  };\n\n  SandstormDb.prototype.userGrainTitle = function (grainId, accountId, identityId) {\n    check(grainId, String);\n    check(accountId, Match.OneOf(String, undefined, null));\n    check(identityId, String);\n\n    const grain = this.getGrain(grainId);\n    if (!grain) {\n      throw new Error(\"called userGrainTitle() for a grain that doesn't exist\");\n    }\n\n    let title = grain.title;\n    if (grain.userId !== accountId) {\n      const sharerToken = this.collections.apiTokens.findOne({\n        grainId: grainId,\n        \"owner.user.identityId\": identityId,\n      }, {\n        sort: {\n          lastUsed: -1,\n        },\n      });\n      if (sharerToken) {\n        title = sharerToken.owner.user.title;\n      } else {\n        title = \"shared grain\";\n      }\n    }\n\n    return title;\n  };\n\n  const packageCache = {};\n  // Package info is immutable. Let's cache to save on mongo queries.\n\n  SandstormDb.prototype.getPackage = function (packageId) {\n    // Get the given package record. Since package info is immutable, cache the data in the server\n    // to reduce mongo query overhead, since it turns out we have to fetch specific packages a\n    // lot.\n\n    if (packageId in packageCache) {\n      return packageCache[packageId];\n    }\n\n    const pkg = this.collections.packages.findOne(packageId);\n    if (pkg && pkg.status === \"ready\") {\n      packageCache[packageId] = pkg;\n    }\n\n    return pkg;\n  };\n\n  SandstormDb.prototype.deleteUnusedPackages = function (appId) {\n    check(appId, String);\n    this.collections.packages.find({ appId: appId }).forEach((pkg) => {\n      // Mark package for possible deletion;\n      this.collections.packages.update({ _id: pkg._id, status: \"ready\" }, { $set: { shouldCleanup: true } });\n    });\n  };\n\n  SandstormDb.prototype.sendAppUpdateNotifications = function (appId, packageId, name,\n                                                               versionNumber, marketingVersion) {\n    const actions = this.collections.userActions.find({ appId: appId, appVersion: { $lt: versionNumber } },\n      { fields: { userId: 1 } });\n    actions.forEach((action) => {\n      const userId = action.userId;\n      const updater = {\n        timestamp: new Date(),\n        isUnread: true,\n      };\n      const inserter = _.extend({ userId, appUpdates: {} }, updater);\n\n      // Set only the appId that we care about. Use mongo's dot notation to specify only a single\n      // field inside of an object to update\n      inserter.appUpdates[appId] = updater[\"appUpdates.\" + appId] = {\n        marketingVersion: marketingVersion,\n        packageId: packageId,\n        name: name,\n        version: versionNumber,\n      };\n\n      // We unfortunately cannot upsert because upserts can only have field equality conditions in\n      // the query. If we try to upsert, Mongo complaints that \"$exists\" isn't valid to store.\n      if (this.collections.notifications.update(\n          { userId: userId, appUpdates: { $exists: true } },\n          { $set: updater }) == 0) {\n        // Update failed; try an insert instead.\n        this.collections.notifications.insert(inserter);\n      }\n    });\n\n    this.collections.appIndex.update({ _id: appId }, { $set: { hasSentNotifications: true } });\n\n    // In the case where we replaced a previous notification and that was the only reference to the\n    // package, we need to clean it up\n    this.deleteUnusedPackages(appId);\n  };\n\n  SandstormDb.prototype.sendReferralProgramNotification = function (userId) {\n    this.collections.notifications.upsert({\n      userId: userId,\n      referral: true,\n    }, {\n      userId: userId,\n      referral: true,\n      timestamp: new Date(),\n      isUnread: true,\n    });\n  };\n\n  SandstormDb.prototype.upgradeGrains =  function (appId, version, packageId, backend) {\n    check(appId, String);\n    check(version, Match.Integer);\n    check(packageId, String);\n\n    const selector = {\n      userId: Meteor.userId(),\n      appId: appId,\n      appVersion: { $lte: version },\n      packageId: { $ne: packageId },\n    };\n\n    this.collections.grains.find(selector).forEach(function (grain) {\n      backend.shutdownGrain(grain._id, grain.userId);\n    });\n\n    this.collections.grains.update(selector, {\n      $set: { appVersion: version, packageId: packageId, packageSalt: Random.secret() },\n    }, { multi: true });\n  };\n\n  SandstormDb.prototype.startInstall = function (packageId, url, retryFailed, isAutoUpdated) {\n    // Mark package for possible installation.\n\n    const fields = {\n      status: \"download\",\n      progress: 0,\n      url: url,\n      isAutoUpdated: !!isAutoUpdated,\n    };\n\n    if (retryFailed) {\n      this.collections.packages.update({ _id: packageId, status: \"failed\" }, { $set: fields });\n    } else {\n      try {\n        fields._id = packageId;\n        this.collections.packages.insert(fields);\n      } catch (err) {\n        console.error(\"Simultaneous startInstall()s?\", err.stack);\n      }\n    }\n  };\n\n  const ValidKeyFingerprint = Match.Where(function (keyFingerprint) {\n    check(keyFingerprint, String);\n    return !!keyFingerprint.match(/^[0-9A-F]{40}$/);\n  });\n\n  SandstormDb.prototype.updateKeybaseProfileAsync = function (keyFingerprint) {\n    // Asynchronously fetch the given Keybase profile and populate the KeybaseProfiles collection.\n\n    check(keyFingerprint, ValidKeyFingerprint);\n\n    console.log(\"fetching keybase\", keyFingerprint);\n\n    HTTP.get(\n        \"https://keybase.io/_/api/1.0/user/lookup.json?key_fingerprint=\" + keyFingerprint +\n        \"&fields=basics,profile,proofs_summary\", {\n      timeout: 5000,\n    }, (err, keybaseResponse) => {\n      if (err) {\n        console.log(\"keybase lookup error:\", err.stack);\n        return;\n      }\n\n      if (!keybaseResponse.data) {\n        console.log(\"keybase didn't return JSON? Headers:\", keybaseResponse.headers);\n        return;\n      }\n\n      const profile = (keybaseResponse.data.them || [])[0];\n\n      if (profile) {\n        // jscs:disable requireCamelCaseOrUpperCaseIdentifiers\n        const record = {\n          displayName: (profile.profile || {}).full_name,\n          handle: (profile.basics || {}).username,\n          proofs: (profile.proofs_summary || {}).all || [],\n        };\n        // jscs:enable requireCamelCaseOrUpperCaseIdentifiers\n\n        record.proofs.forEach(function (proof) {\n          // Remove potentially Mongo-incompatible stuff. (Currently Keybase returns nothing that\n          // this would filter.)\n          for (let field in proof) {\n            // Don't allow field names containing '.' or '$'. Also don't allow sub-objects mainly\n            // because I'm too lazy to check the field names recursively (and Keybase doesn't\n            // return any objects anyway).\n            if (field.match(/[.$]/) || typeof (proof[field]) === \"object\") {\n              delete proof[field];\n            }\n          }\n\n          // Indicate not verified.\n          // TODO(security): Asynchronously verify proofs. Presumably we can borrow code from the\n          //   Keybase node-based CLI.\n          proof.status = \"unverified\";\n        });\n\n        this.collections.keybaseProfiles.update(keyFingerprint, { $set: record }, { upsert: true });\n      } else {\n        // Keybase reports no match, so remove what we know of this user. We don't want to remove\n        // the item entirely from the cache as this will cause us to repeatedly re-fetch the data\n        // from Keybase.\n        //\n        // TODO(someday): We could perhaps keep the proofs if we can still verify them directly,\n        //   but at present we don't have the ability to verify proofs.\n        this.collections.keybaseProfiles.update(keyFingerprint,\n            { $unset: { displayName: \"\", handle: \"\", proofs: \"\" } }, { upsert: true });\n      }\n    });\n  };\n\n  SandstormDb.prototype.deleteUnusedAccount = function (backend, identityId) {\n    // If there is an *unused* account that has `identityId` as a login identity, deletes it.\n\n    check(identityId, String);\n    const account = this.collections.users.findOne({ \"loginIdentities.id\": identityId });\n    if (account &&\n        account.loginIdentities.length == 1 &&\n        account.nonloginIdentities.length == 0 &&\n        !this.collections.grains.findOne({ userId: account._id }) &&\n        !this.collections.apiTokens.findOne({ accountId: account._id }) &&\n        (!account.plan || account.plan === \"free\") &&\n        !(account.payments && account.payments.id) &&\n        !this.collections.contacts.findOne({ ownerId: account._id })) {\n      this.collections.users.remove({ _id: account._id });\n      backend.deleteUser(account._id);\n    }\n  };\n\n  Meteor.publish(\"keybaseProfile\", function (keyFingerprint) {\n    check(keyFingerprint, ValidKeyFingerprint);\n    const db = this.connection.sandstormDb;\n\n    const cursor = db.collections.keybaseProfiles.find(keyFingerprint);\n    if (cursor.count() === 0) {\n      // Fire off async update.\n      db.updateKeybaseProfileAsync(keyFingerprint);\n    }\n\n    return cursor;\n  });\n\n  Meteor.publish(\"appIndex\", function (appId) {\n    check(appId, String);\n    const db = this.connection.sandstormDb;\n    const cursor = db.collections.appIndex.find({ _id: appId });\n    return cursor;\n  });\n\n  Meteor.publish(\"userPackages\", function () {\n    // Users should be able to see packages that are either:\n    // 1. referenced by one of their userActions\n    // 2. referenced by one of their grains\n    const db = this.connection.sandstormDb;\n\n    // Note that package information, once it is in the database, is static. There's no need to\n    // reactively subscribe to changes to a package since they don't change. It's also unecessary\n    // to reactively remove a package from the client side when it is removed on the server, or\n    // when the client stops using it, because the worst case is the client has a small amount\n    // of extra info on a no-longer-used package held in memory until they refresh Sandstorm.\n    // So, we implement this as a cache: the first time each package ID shows up among the user's\n    // stuff, we push the package info to the client, and then we never update it.\n    //\n    // Alternatively, we could subscribe to each individual package query, but this would waste\n    // lots of server-side resources watching for events that will never happen or don't matter.\n    const hasPackage = {};\n    const refPackage = (packageId) => {\n      // Ignore dev apps.\n      if (packageId.lastIndexOf(\"dev-\", 0) === 0) return;\n\n      if (!hasPackage[packageId]) {\n        hasPackage[packageId] = true;\n        const pkg = db.getPackage(packageId);\n        if (pkg) {\n          this.added(\"packages\", packageId, pkg);\n        } else {\n          console.error(\n              \"shouldn't happen: missing package referenced by user's stuff:\", packageId);\n        }\n      }\n    };\n\n    // package source 1: packages referred to by actions\n    const actions = db.userActions(this.userId);\n    const actionsHandle = actions.observe({\n      added(newAction) {\n        refPackage(newAction.packageId);\n      },\n\n      changed(newAction, oldAction) {\n        refPackage(newAction.packageId);\n      },\n    });\n\n    // package source 2: packages referred to by grains directly\n    const grains = db.userGrains(this.userId, { includeTrash: true });\n    const grainsHandle = grains.observe({\n      added(newGrain) {\n        // Watch out: DevApp grains can lack a packageId.\n        if (newGrain.packageId) {\n          refPackage(newGrain.packageId);\n        }\n      },\n\n      changed(newGrain, oldGrain) {\n        // Watch out: DevApp grains can lack a packageId.\n        if (newGrain.packageId) {\n          refPackage(newGrain.packageId);\n        }\n      },\n    });\n\n    this.onStop(function () {\n      actionsHandle.stop();\n      grainsHandle.stop();\n    });\n\n    this.ready();\n  });\n}\n\nif (Meteor.isServer) {\n  SandstormDb.prototype.deleteIdentity = function (identityId) {\n    check(identityId, String);\n\n    this.removeApiTokens({ \"owner.user.identityId\": identityId });\n    this.collections.contacts.remove({ identityId: identityId });\n    Meteor.users.remove({ _id: identityId });\n  };\n\n  SandstormDb.prototype.deleteAccount = function (userId, backend) {\n    check(userId, String);\n\n    const _this = this;\n    const user = Meteor.users.findOne({ _id: userId });\n    this.deleteGrains({ userId: userId }, backend, \"grain\");\n    this.collections.userActions.remove({ userId: userId });\n    this.collections.notifications.remove({ userId: userId });\n    user.loginIdentities.forEach((identity) => {\n      if (Meteor.users.find({ $or: [\n        { \"loginIdentities.id\": identity.id },\n        { \"nonloginIdentities.id\": identity.id },\n      ], }).count() === 1) {\n        // If this is the only account with the identity, then delete it\n        _this.deleteIdentity(identity.id);\n      }\n    });\n    user.nonloginIdentities.forEach((identity) => {\n      if (Meteor.users.find({ $or: [\n        { \"loginIdentities.id\": identity.id },\n        { \"nonloginIdentities.id\": identity.id },\n      ], }).count() === 1) {\n        // If this is the only account with the identity, then delete it\n        _this.deleteIdentity(identity.id);\n      }\n    });\n    this.collections.contacts.remove({ ownerId: userId });\n    backend.deleteUser(userId);\n    Meteor.users.remove({ _id: userId });\n  };\n}\n\nMeteor.methods({\n  addUserActions(packageId) {\n    check(packageId, String);\n    if (!this.userId || !Meteor.user().loginIdentities || !isSignedUpOrDemo()) {\n      throw new Meteor.Exception(403, \"Must be logged in as a non-guest to add app actions.\");\n    }\n\n    if (this.isSimulation) {\n      // TODO(cleanup): Appdemo code relies on this being simulated client-side but we don't have\n      //   a proper DB object to use.\n      new SandstormDb().addUserActions(this.userId, packageId, true);\n    } else {\n      this.connection.sandstormDb.addUserActions(this.userId, packageId);\n    }\n  },\n\n  removeUserAction(actionId) {\n    check(actionId, String);\n    if (this.isSimulation) {\n      UserActions.remove({ _id: actionId });\n    } else {\n      if (this.userId) {\n        const result = this.connection.sandstormDb.collections.userActions.findAndModify({\n          query: { _id: actionId, userId: this.userId },\n          remove: true,\n        });\n\n        if (!result.ok) {\n          throw new Error(`Couldn't remove user action ${actionId}`);\n        }\n\n        const action = result.value;\n        if (action) {\n          this.connection.sandstormDb.deleteUnusedPackages(action.appId);\n        }\n      }\n    }\n  },\n});\n", "import crypto from \"crypto\";\n\nimport { send as sendEmail } from \"/imports/server/email.js\";\n\nconst Url = Npm.require(\"url\");\n\nconst V1_ROUNDS = 4096; // Selected to take ~5msec at creation time (2016) on a developer's laptop.\nconst V1_KEYSIZE = 32; // 256 bits / 8 bits/byte = 32 bytes\nconst V1_HASHFUNC = \"sha512\";\n// ^ hash function used with pbkdf2.  Chosen to be different from the function which maps the token\n// to the value stored in the database.  Note that the first thing that pbkdf2 does is\n// HMAC(HASHFUNC, key, salt), and the first thing that HMAC does is either pad or hash the key to\n// make it the appropriate width.  The result is that knowing sha256(key) and the salt is possibly\n// sufficient to reconstruct the output of pbkdf2().\nconst V1_CIPHER = \"AES-256-CTR\"; // cipher used\n\nconst TOKEN_EXPIRATION_MS = 60 * 60 * 1000;\n\nconst cleanupExpiredTokens = function () {\n  Meteor.users.update({\n    \"services.email.tokens.createdAt\": {\n      $lt: new Date(Date.now() - TOKEN_EXPIRATION_MS),\n    },\n  }, {\n    $pull: {\n      \"services.email.tokens\": {\n        createdAt: { $lt: new Date(Date.now() - TOKEN_EXPIRATION_MS) },\n      },\n    },\n  }, {\n    multi: true,\n  });\n};\n\nMeteor.startup(cleanupExpiredTokens);\n// Tokens can actually last up to 2 * TOKEN_EXPIRATION_MS\nSandstormDb.periodicCleanup(TOKEN_EXPIRATION_MS, cleanupExpiredTokens);\n\nconst hashToken = (token) => {\n  return {\n    digest: SHA256(token),\n    algorithm: \"sha-256\",\n  };\n};\n\nconst checkToken = function (tokens, token) {\n  // Looks for an object in `tokens` with `algorithm` and `digest` fields matching those in `token`.\n  // Returns the matching object, if one is found, or undefined if none match.\n  let foundToken = undefined;\n  tokens.forEach(function (userToken) {\n    if ((userToken.algorithm === token.algorithm) &&\n       (userToken.digest === token.digest)) {\n      foundToken = userToken;\n    }\n  });\n\n  return foundToken;\n};\n\nconst consumeToken = function (user, token) {\n  const hashedToken = hashToken(token);\n  const foundToken = checkToken(user.services.email.tokens, hashedToken);\n\n  if (foundToken !== undefined) {\n    Meteor.users.update({ _id: user._id }, { $pull: { \"services.email.tokens\": hashedToken } });\n  }\n\n  return foundToken;\n};\n\nconst makeBox = function (token, plaintext) {\n  // Encrypt plaintext symmetrically with a key derived from token.  Returns an object with\n  // ciphertext and associated data needed to decrypt later.\n\n  // Produce a symmetric key.  Note that the token itself does not have sufficient entropy to\n  // be used as a key directly, so we need to use a KDF with a strong random salt.\n  // In the fullness of time, it might be nice to move away from using a KDF (which blocks the whole\n  // node process) in favor of the token itself having enough entropy to serve as the key itself.\n  // This would require lengthening the token, which would make the manual-code-entry workflow\n  // worse, so I'm punting on that for now.\n  const salt = Random.secret(16);\n  const key = crypto.pbkdf2Sync(token, salt, V1_ROUNDS, V1_KEYSIZE, V1_HASHFUNC);\n  const iv = crypto.randomBytes(16);\n  const cipher = crypto.createCipheriv(V1_CIPHER, key, iv);\n  let ciphertext = cipher.update(new Buffer(plaintext, \"binary\"));\n  return {\n    version: 1,\n    salt: salt,\n    iv: iv.toString(\"base64\"),\n    boxedValue: ciphertext.toString(\"base64\"),\n  };\n};\n\nconst tryUnbox = function (box, secret) {\n  if (box) {\n    if (box.version === 1) {\n      const key = crypto.pbkdf2Sync(secret, box.salt, V1_ROUNDS, V1_KEYSIZE, V1_HASHFUNC);\n      const iv = new Buffer(box.iv, \"base64\");\n      const cipher = crypto.createDecipheriv(V1_CIPHER, key, iv);\n      const cipherText = new Buffer(box.boxedValue, \"base64\");\n      const plaintext = cipher.update(cipherText);\n      return plaintext.toString(\"binary\");\n    }\n  }\n\n  // If no box was provided, or it was of an unknown version, return no data.\n  return;\n};\n\n// Handler to login with a token.\nAccounts.registerLoginHandler(\"email\", function (options) {\n  if (!options.email) {\n    return undefined; // don't handle\n  }\n\n  if (!Accounts.identityServices.email.isEnabled()) {\n    throw new Meteor.Error(403, \"Email identity service is disabled.\");\n  }\n\n  options = options.email;\n  check(options, {\n    email: String,\n    token: String,\n  });\n\n  const user = Meteor.users.findOne({\n    \"services.email.email\": options.email,\n  }, {\n    fields: {\n      \"services.email\": 1,\n    },\n  });\n\n  if (!user) {\n    console.error(\"User not found:\", options.email);\n    return {\n      error: new Meteor.Error(403, \"User not found\"),\n    };\n  }\n\n  if (!user.services.email.tokens) {\n    console.error(\"User has no token set:\", options.email);\n    return {\n      error: new Meteor.Error(403, \"User has no token set\"),\n    };\n  }\n\n  const tokenString = options.token.trim();\n  const maybeToken = consumeToken(user, tokenString);\n  if (!maybeToken) {\n    console.error(\"Token not found:\", options.email);\n    return {\n      error: new Meteor.Error(403, \"Invalid authentication code\"),\n    };\n  }\n\n  // Attempt to decrypt the resumePath, if provided.\n  const resumePath = tryUnbox(maybeToken.secureBox, tokenString);\n\n  return {\n    userId: user._id,\n    options: {\n      resumePath,\n    },\n  };\n});\n\nconst makeTokenUrl = function (email, token, options) {\n  if (options.linking) {\n    return options.rootUrl + \"/_emailLinkIdentity/\" + encodeURIComponent(email) + \"/\" +\n      encodeURIComponent(token) + \"/\" + Meteor.userId() +\n      \"?allowLogin=\" + options.linking.allowLogin;\n  } else {\n    return options.rootUrl + \"/_emailLogin/\" + encodeURIComponent(email) + \"/\" + encodeURIComponent(token);\n  }\n};\n\n///\n/// EMAIL VERIFICATION\n///\nconst sendTokenEmail = function (db, email, token, options) {\n  let subject;\n  let text;\n\n  const rootHostname = Url.parse(options.rootUrl).hostname;\n\n  if (!options.linking) {\n    subject = \"Log in to \" + rootHostname;\n    text = \"To confirm this email address on \";\n  } else {\n    subject = \"Confirm this email address on \" + rootHostname;\n    text = \"To confirm this email address on \";\n  }\n\n  text = text + rootHostname + \", click on the following link:\\n\\n\" +\n      makeTokenUrl(email, token, options) + \"\\n\\n\" +\n      \"Alternatively, enter the following one-time authentication code into the log-in form:\\n\\n\" +\n      token;\n\n  const sendOptions = {\n    to:  email,\n    from: { name: globalDb.getServerTitle(), address: db.getReturnAddress() },\n    subject: subject,\n    text: text,\n  };\n\n  sendEmail(sendOptions);\n};\n\nconst parsedRootUrl = Url.parse(process.env.ROOT_URL);\n///\n/// CREATING USERS\n///\n// returns the user id\nconst createAndEmailTokenForUser = function (db, email, options) {\n  check(email, String);\n  check(options, {\n    resumePath: String,\n    linking: Match.Optional({ allowLogin: Boolean }),\n    rootUrl: String,\n  });\n\n  const parsedUrl = Url.parse(options.rootUrl);\n  if ((parsedUrl.hostname !== parsedRootUrl.hostname ||\n       parsedUrl.protocol !== parsedRootUrl.protocol) &&\n      !db.hostIsStandalone(parsedUrl.hostname)) {\n    // Ignore port and only check hostname/protocol since IE will differ from other browsers and\n    // sometimes include port 80/443 and sometimes won't\n    throw new Meteor.Error(400, \"rootUrl is not valid\");\n  }\n\n  const atIndex = email.indexOf(\"@\");\n  if (atIndex === -1) {\n    throw new Meteor.Error(400, \"No @ symbol was found in your email\");\n  }\n\n  let user = Meteor.users.findOne({ \"services.email.email\": email },\n                                  { fields: { \"services.email\": 1 } });\n  let userId;\n\n  // TODO(someday): make this shorter, and handle requests that try to brute force it.\n  // Alternately, require using the link over copy/pasting the code, and crank up the entropy.\n  const token = Random.id(12);\n  const tokenObj = hashToken(token);\n  tokenObj.createdAt = new Date();\n  tokenObj.secureBox = makeBox(token, options.resumePath);\n\n  if (user) {\n    if (user.services.email.tokens && user.services.email.tokens.length > 2) {\n      throw new Meteor.Error(\n        \"alreadySentEmailToken\",\n        \"It looks like we sent a log in email to this address not long \" +\n        \"ago. Please use the one that was already sent (check your spam folder if you can't find \" +\n        \"it), or wait a while and try again.\");\n    }\n\n    userId = user._id;\n\n    Meteor.users.update({ _id: user._id }, { $push: { \"services.email.tokens\": tokenObj } });\n  } else {\n    const options = {};\n    user = {\n      services: {\n        email: {\n          tokens: [tokenObj],\n          email: email,\n        },\n      },\n    };\n\n    userId = Accounts.insertUserDoc(options, user);\n  }\n\n  sendTokenEmail(db, email, token, options);\n\n  return userId;\n};\n\nMeteor.methods({\n  createAndEmailTokenForUser: function (email, options) {\n    // method for create user. Requests come from the client.\n    // This method will create a user if it doesn't exist, otherwise it will generate a token.\n    // It will always send an email to the user\n\n    check(email, String);\n    check(options, {\n      resumePath: String,\n      linking: Match.Optional({ allowLogin: Boolean }),\n      rootUrl: String,\n    });\n\n    if (!Accounts.identityServices.email.isEnabled()) {\n      throw new Meteor.Error(403, \"Email identity service is disabled.\");\n    }\n    // Create user. result contains id and token.\n    const user = createAndEmailTokenForUser(this.connection.sandstormDb, email, options);\n  },\n\n  linkEmailIdentityToAccount: function (email, token, allowLogin) {\n    // Links the email identity with address `email` and login token `token` to the current account.\n    check(email, String);\n    check(token, String);\n    check(allowLogin, Boolean);\n    const account = Meteor.user();\n    if (!account || !account.loginIdentities) {\n      throw new Meteor.Error(403, \"Must be logged in to an account to link an email identity.\");\n    }\n\n    const identity = Meteor.users.findOne({ \"services.email.email\": email },\n                                          { fields: { \"services.email\": 1 } });\n    if (!identity) {\n      throw new Meteor.Error(403, \"Invalid authentication code.\");\n    }\n\n    const maybeToken = consumeToken(identity, token.trim());\n    if (!maybeToken) {\n      throw new Meteor.Error(403, \"Invalid authentication code.\");\n    }\n\n    Accounts.linkIdentityToAccount(this.connection.sandstormDb, this.connection.sandstormBackend,\n                                   identity._id, account._id, allowLogin);\n\n    // Return the resume path, if we have one.\n    const resumePath = tryUnbox(maybeToken.secureBox, token);\n    return resumePath;\n  },\n});\n", "// Sandstorm - Personal Cloud Sandbox\n// Copyright (c) 2014 Sandstorm Development Group, Inc. and contributors\n// All rights reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//   http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport { Meteor } from \"meteor/meteor\";\nimport Fs from \"fs\";\nimport Crypto from \"crypto\";\nimport Heapdump from \"heapdump\";\nimport { SANDSTORM_LOGDIR } from \"/imports/server/constants.js\";\nimport { clearAdminToken, checkAuth, tokenIsValid, tokenIsSetupSession } from \"/imports/server/auth.js\";\nimport { send as sendEmail } from \"/imports/server/email.js\";\nimport { fillUndefinedForChangedDoc } from \"/imports/server/observe-helpers.js\";\n\nconst publicAdminSettings = [\n  \"google\", \"github\", \"ldap\", \"saml\", \"emailToken\", \"splashUrl\", \"signupDialog\",\n  \"adminAlert\", \"adminAlertTime\", \"adminAlertUrl\", \"termsUrl\",\n  \"privacyUrl\", \"appMarketUrl\", \"appIndexUrl\", \"appUpdatesEnabled\",\n  \"serverTitle\", \"returnAddress\", \"ldapNameField\", \"organizationMembership\",\n  \"organizationSettings\",\n  \"whitelabelCustomLoginProviderName\",\n  \"whitelabelCustomLogoAssetId\",\n  \"whitelabelHideSendFeedback\",\n  \"whitelabelHideTroubleshooting\",\n  \"whiteLabelHideAbout\",\n  \"whitelabelUseServerTitleForHomeText\",\n  \"quotaEnabled\",\n  \"quotaLdapEnabled\",\n  \"billingPromptUrl\",\n];\n\nconst smtpConfigShape = {\n  hostname: String,\n  port: Number,\n  auth: {\n    user: String,\n    pass: String,\n  },\n  returnAddress: String,\n};\n\nMeteor.methods({\n  setAccountSetting: function (token, serviceName, value) {\n    checkAuth(token);\n    check(serviceName, String);\n    check(value, Boolean);\n\n    // TODO(someday): currently this relies on the fact that an account is tied to a single\n    // identity, and thus has only that entry in \"services\". This will need to be looked at when\n    // multiple login methods/identities are allowed for a single account.\n    if (!value && !tokenIsValid(token) && !tokenIsSetupSession(token) && (serviceName in Meteor.user().services)) {\n      throw new Meteor.Error(403,\n        \"You can not disable the login service that your account uses.\");\n    }\n\n    // Only check configurations for OAuth services.\n    const oauthServices = [\"google\", \"github\"];\n    if (value && (oauthServices.indexOf(serviceName) != -1)) {\n      const config = ServiceConfiguration.configurations.findOne({ service: serviceName });\n      if (!config) {\n        throw new Meteor.Error(403, \"You must configure the \" + serviceName +\n          \" service before you can enable it. Click the \\\"configure\\\" link.\");\n      }\n\n      if (!config.clientId || !config.secret) {\n        throw new Meteor.Error(403, \"You must provide a non-empty clientId and secret for the \" +\n          serviceName + \" service before you can enable it. Click the \\\"configure\\\" link.\");\n      }\n    }\n\n    Settings.upsert({ _id: serviceName }, { $set: { value: value } });\n    if (value) {\n      Settings.update({ _id: serviceName }, { $unset: { automaticallyReset: 1 } });\n    }\n  },\n\n  setSmtpConfig: function (token, config) {\n    checkAuth(token);\n    check(config, smtpConfigShape);\n\n    Settings.upsert({ _id: \"smtpConfig\" }, { $set: { value: config } });\n  },\n\n  disableEmail: function (token) {\n    checkAuth(token);\n\n    const db = this.connection.sandstormDb;\n    db.collections.settings.update({ _id: \"smtpConfig\" }, { $set: { \"value.hostname\": \"\" } });\n  },\n\n  setSetting: function (token, name, value) {\n    checkAuth(token);\n    check(name, String);\n    check(value, Match.OneOf(null, String, Date, Boolean));\n\n    Settings.upsert({ _id: name }, { $set: { value: value } });\n  },\n\n  saveOrganizationSettings(token, params) {\n    checkAuth(token);\n    check(params, {\n      membership: {\n        emailToken: {\n          enabled: Boolean,\n          domain: String,\n        },\n        google: {\n          enabled: Boolean,\n          domain: String,\n        },\n        ldap: {\n          enabled: Boolean,\n        },\n        saml: {\n          enabled: Boolean,\n        },\n      },\n      settings: {\n        disallowGuests: Boolean,\n        shareContacts: Boolean,\n      },\n    });\n\n    this.connection.sandstormDb.collections.settings.upsert({ _id: \"organizationMembership\" }, { value: params.membership });\n    this.connection.sandstormDb.collections.settings.upsert({ _id: \"organizationSettings\" }, { value: params.settings });\n  },\n\n  adminConfigureLoginService: function (token, options) {\n    checkAuth(token);\n    check(options, Match.ObjectIncluding({ service: String }));\n\n    ServiceConfiguration.configurations.upsert({ service: options.service }, options);\n  },\n\n  clearResumeTokensForService: function (token, serviceName) {\n    checkAuth(token);\n    check(serviceName, String);\n\n    const query = {};\n    query[\"services.\" + serviceName] = { $exists: true };\n    Meteor.users.find(query).forEach(function (identity) {\n      if (identity.services.resume && identity.services.resume.loginTokens &&\n          identity.services.resume.loginTokens.length > 0) {\n        Meteor.users.update({ _id: identity._id }, { $set: { \"services.resume.loginTokens\": [] } });\n      }\n\n      Meteor.users.update({ \"loginIdentities.id\": identity._id },\n                          { $set: { \"services.resume.loginTokens\": [] } });\n    });\n  },\n\n  adminUpdateUser: function (token, userInfo) {\n    checkAuth(token);\n    check(userInfo, {\n      userId: String,\n      signupKey: Boolean,\n      isAdmin: Boolean,\n    });\n\n    const userId = userInfo.userId;\n    if (userId === Meteor.userId() && !userInfo.isAdmin) {\n      throw new Meteor.Error(403, \"User cannot remove admin permissions from itself.\");\n    }\n\n    Meteor.users.update({ _id: userId }, { $set: _.omit(userInfo, [\"_id\", \"userId\"]) });\n  },\n\n  testSend: function (token, smtpConfig, to) {\n    checkAuth(token);\n    check(smtpConfig, smtpConfigShape);\n    check(to, String);\n    const { returnAddress, ...restConfig } = smtpConfig;\n\n    try {\n      sendEmail({\n        to: to,\n        from: { name: globalDb.getServerTitle(), address: returnAddress },\n        subject: \"Testing your Sandstorm's SMTP setting\",\n        text: \"Success! Your outgoing SMTP is working.\",\n        smtpConfig: restConfig,\n      });\n    } catch (e) {\n      // Attempt to give more accurate error messages for a variety of known failure modes,\n      // and the actual exception data in the event a user hits a new failure mode.\n      if (e.syscall === \"getaddrinfo\") {\n        if (e.code === \"EIO\" || e.code === \"ENOTFOUND\") {\n          throw new Meteor.Error(\"getaddrinfo \" + e.code, \"Couldn't resolve \\\"\" + smtpConfig.hostname + \"\\\" - check for typos or broken DNS.\");\n        }\n      } else if (e.syscall === \"connect\") {\n        if (e.code === \"ECONNREFUSED\") {\n          throw new Meteor.Error(\"connect ECONNREFUSED\", \"Server at \" + smtpConfig.hostname + \":\" + smtpConfig.port + \" refused connection.  Check your settings, firewall rules, and that your mail server is up.\");\n        }\n      } else if (e.name === \"AuthError\") {\n        throw new Meteor.Error(\"auth error\", \"Authentication failed.  Check your credentials.  Message from \" +\n                smtpConfig.hostname + \": \" + e.data);\n      }\n\n      throw new Meteor.Error(\"other-email-sending-error\", \"Error while trying to send test email: \" + JSON.stringify(e));\n    }\n  },\n\n  createSignupKey: function (token, note, quota) {\n    checkAuth(token);\n    check(note, String);\n    check(quota, Match.OneOf(undefined, null, Number));\n\n    const key = Random.id();\n    const content = { _id: key, used: false, note: note };\n    if (typeof quota === \"number\") content.quota = quota;\n    SignupKeys.insert(content);\n    return key;\n  },\n\n  sendInvites: function (token, origin, from, list, subject, message, quota) {\n    checkAuth(token);\n    check(from, { name: String, address: String });\n    check([origin, list, subject, message], [String]);\n    check(quota, Match.OneOf(undefined, null, Number));\n\n    if (!from.address.trim()) {\n      throw new Meteor.Error(403, \"Must enter 'from' address.\");\n    }\n\n    if (!list.trim()) {\n      throw new Meteor.Error(403, \"Must enter 'to' addresses.\");\n    }\n\n    this.unblock();\n\n    list = list.split(\"\\n\");\n    for (const i in list) {\n      const email = list[i].trim();\n\n      if (email) {\n        const key = Random.id();\n\n        const content = {\n          _id: key,\n          used: false,\n          note: \"E-mail invite to \" + email,\n          email: email,\n          definitelySent: false,\n        };\n        if (typeof quota === \"number\") content.quota = quota;\n        SignupKeys.insert(content);\n        sendEmail({\n          to: email,\n          from: from,\n          envelopeFrom: globalDb.getReturnAddress(),\n          subject: subject,\n          text: message.replace(/\\$KEY/g, origin + \"/signup/\" + key),\n        });\n        SignupKeys.update(key, { $set: { definitelySent: true } });\n      }\n    }\n\n    return { sent: true };\n  },\n\n  adminToggleDisableCap: function (token, capId, value) {\n    checkAuth(token);\n    check(capId, String);\n    check(value, Boolean);\n\n    if (value) {\n      ApiTokens.update({ _id: capId }, { $set: { revoked: true } });\n    } else {\n      ApiTokens.update({ _id: capId }, { $set: { revoked: false } });\n    }\n  },\n\n  updateQuotas: function (token, list, quota) {\n    checkAuth(token);\n    check(list, String);\n    check(quota, Match.OneOf(undefined, null, Number));\n\n    if (!list.trim()) {\n      throw new Meteor.Error(400, \"Must enter addresses.\");\n    }\n\n    const items = list.split(\"\\n\");\n    const invalid = [];\n    for (const i in items) {\n      const modifier = (typeof quota === \"number\") ? { $set: { quota: quota } }\n                                                 : { $unset: { quota: \"\" } };\n      let n = SignupKeys.update({ email: items[i] }, modifier, { multi: true });\n      n += Meteor.users.update({ signupEmail: items[i] }, modifier, { multi: true });\n\n      if (n < 1) invalid.push(items[i]);\n    }\n\n    if (invalid.length > 0) {\n      throw new Meteor.Error(404, \"These addresses did not map to any user nor invite: \" +\n          invalid.join(\", \"));\n    }\n  },\n\n  dismissAdminStatsNotifications: function (token) {\n    checkAuth(token);\n    globalDb.collections.notifications.remove({ \"admin.type\": \"reportStats\" });\n  },\n\n  signUpAsAdmin: function (token) {\n    check(token, String);\n    checkAuth(token);\n    if (!this.userId) {\n      throw new Meteor.Error(403, \"Must be logged in to sign up as admin.\");\n    }\n\n    if (!Meteor.user().loginIdentities) {\n      throw new Meteor.Error(403, \"Must be logged into an account to sign up as admin.\");\n    }\n\n    Meteor.users.update({ _id: this.userId }, { $set: { isAdmin: true, signupKey: \"admin\" } });\n    clearAdminToken(token);\n  },\n\n  redeemSetupToken(token) {\n    // Redeem an admin token into a setup session.\n    check(token, String);\n    if (tokenIsValid(token)) {\n      const sessId = Random.secret();\n      const creationDate = new Date();\n      const hashedSessionId = Crypto.createHash(\"sha256\").update(sessId).digest(\"base64\");\n      this.connection.sandstormDb.collections.setupSession.upsert({\n        _id: \"current-session\",\n      }, {\n        creationDate,\n        hashedSessionId,\n      });\n      // Then, invalidate the token, so one one else can use it.\n      clearAdminToken(token);\n      return sessId;\n    } else {\n      throw new Meteor.Error(401, \"Invalid setup token\");\n    }\n  },\n\n  heapdump() {\n    // Requests a heap dump. Intended for use by Sandstorm developers. Requires admin.\n    //\n    // Call this from the JS console like:\n    //   Meteor.call(\"heapdump\");\n\n    checkAuth();\n\n    // We use /var/log because it's a location in the container to which the front-end is allowed\n    // to write.\n    const name = \"/var/log/\" + Date.now() + \".heapsnapshot\";\n    Heapdump.writeSnapshot(name);\n    console.log(\"Wrote heapdump: /opt/sandstorm\" + name);\n    return name;\n  },\n\n  setPreinstalledApps: function (appAndPackageIds) {\n    checkAuth();\n    check(appAndPackageIds, [{ appId: String, packageId: String, }]);\n\n    this.connection.sandstormDb.setPreinstalledApps(appAndPackageIds);\n  },\n});\n\nconst authorizedAsAdmin = function (token, userId) {\n  return Match.test(token, Match.OneOf(undefined, null, String)) &&\n         ((userId && isAdminById(userId)) || tokenIsValid(token) || tokenIsSetupSession(token));\n};\n\nMeteor.publish(\"admin\", function (token) {\n  if (!authorizedAsAdmin(token, this.userId)) return [];\n  return Settings.find();\n});\n\nMeteor.publish(\"adminServiceConfiguration\", function (token) {\n  if (!authorizedAsAdmin(token, this.userId)) return [];\n  return ServiceConfiguration.configurations.find();\n});\n\nMeteor.publish(\"publicAdminSettings\", function () {\n  return Settings.find({ _id: { $in: publicAdminSettings } });\n});\n\nMeteor.publish(\"adminToken\", function (token) {\n  check(token, String);\n  this.added(\"adminToken\", \"adminToken\", { tokenIsValid: tokenIsValid(token) || tokenIsSetupSession(token) });\n  this.ready();\n});\n\nMeteor.publish(\"allUsers\", function (token) {\n  if (!authorizedAsAdmin(token, this.userId)) return [];\n  return Meteor.users.find();\n});\n\nMeteor.publish(\"adminUserDetails\", function (userId) {\n  if (!authorizedAsAdmin(undefined, this.userId)) return [];\n\n  // Reactive publish of any identities owned by the account with id userId,\n  // as well as that user object itself.\n  const identitySubs = {};\n  const accountId = userId;\n\n  const unrefIdentity = (identityId) => {\n    if (!identitySubs[identityId]) {\n      // should never happen, but if somehow you attempt to unref an identity that we don't have a\n      // subscription to, then don't crash\n      console.error(\"attempted to unref untracked identity id:\", identityId);\n      return;\n    }\n\n    const observeHandle = identitySubs[identityId];\n    delete identitySubs[identityId];\n    observeHandle.stop();\n    this.removed(\"users\", identityId);\n  };\n\n  const refIdentity = (identityId) => {\n    if (identitySubs[identityId]) {\n      // should never happen, but if somehow an account wound up with a duplicate identity ID,\n      // avoid leaking a subscription\n      console.error(\"duplicate identity id:\", identityId);\n      return;\n    }\n\n    const cursor = Meteor.users.find({ _id: identityId });\n    const observeHandle = cursor.observe({\n      added: (doc) => {\n        this.added(\"users\", doc._id, doc);\n      },\n\n      changed: (newDoc, oldDoc) => {\n        fillUndefinedForChangedDoc(newDoc, oldDoc);\n        this.changed(\"users\", newDoc._id, newDoc);\n      },\n\n      removed: (oldDoc) => {\n        this.removed(\"users\", oldDoc._id);\n      },\n    });\n\n    identitySubs[identityId] = observeHandle;\n  };\n\n  const accountCursor = Meteor.users.find({ _id: accountId });\n  const accountSubHandle = accountCursor.observe({\n    added: (newDoc) => {\n      const newIdentities = SandstormDb.getUserIdentityIds(newDoc);\n      newIdentities.forEach((identityId) => {\n        refIdentity(identityId);\n      });\n\n      this.added(\"users\", newDoc._id, newDoc);\n    },\n\n    changed: (newDoc, oldDoc) => {\n      const newIdentities = SandstormDb.getUserIdentityIds(newDoc);\n      const oldIdentities = SandstormDb.getUserIdentityIds(oldDoc);\n\n      // Those in newDoc - oldDoc, ref.\n      const identitiesAdded = _.difference(newIdentities, oldIdentities);\n      identitiesAdded.forEach((identityId) => {\n        refIdentity(identityId);\n      });\n\n      // Those in oldDoc - newDoc, unref.\n      const identitiesRemoved = _.difference(oldIdentities, newIdentities);\n      identitiesRemoved.forEach((identityId) => {\n        unrefIdentity(identityId);\n      });\n\n      fillUndefinedForChangedDoc(newDoc, oldDoc);\n\n      this.changed(\"users\", newDoc._id, newDoc);\n    },\n\n    removed: (oldDoc) => {\n      this.removed(\"users\", oldDoc._id);\n      const oldIdentities = SandstormDb.getUserIdentityIds(oldDoc);\n      oldIdentities.forEach((identityId) => {\n        unrefIdentity(identityId);\n      });\n    },\n  });\n\n  this.onStop(() => {\n    accountSubHandle.stop();\n    // Also stop all the identity subscriptions.\n    const subs = _.values(identitySubs);\n    subs.forEach((sub) => {\n      sub.stop();\n    });\n  });\n\n  // Meteor's cursor.observe() will synchronously call all of the added() callbacks from the initial\n  // query, so by the time we get here we can report readiness.\n  this.ready();\n});\n\nMeteor.publish(\"activityStats\", function (token) {\n  if (!authorizedAsAdmin(token, this.userId)) return [];\n  return ActivityStats.find();\n});\n\nMeteor.publish(\"statsTokens\", function (token) {\n  if (!authorizedAsAdmin(token, this.userId)) return [];\n  return StatsTokens.find();\n});\n\nMeteor.publish(\"allPackages\", function (token) {\n  if (!authorizedAsAdmin(token, this.userId)) return [];\n  return Packages.find({ manifest: { $exists: true } },\n      { fields: { appId: 1, \"manifest.appVersion\": 1,\n      \"manifest.actions\": 1, \"manifest.appTitle\": 1, progress: 1, status: 1, }, });\n});\n\nMeteor.publish(\"realTimeStats\", function (token) {\n  if (!authorizedAsAdmin(token, this.userId)) return [];\n\n  // Last five minutes.\n  this.added(\"realTimeStats\", \"now\", computeStats(new Date(Date.now() - 5 * 60 * 1000)));\n\n  // Since last sample.\n  const lastSample = ActivityStats.findOne({}, { sort: { timestamp: -1 } });\n  const lastSampleTime = lastSample ? lastSample.timestamp : new Date(0);\n  this.added(\"realTimeStats\", \"today\", computeStats(lastSampleTime));\n\n  // TODO(someday): Update every few minutes?\n\n  this.ready();\n});\n\nMeteor.publish(\"adminLog\", function (token) {\n  if (!authorizedAsAdmin(token, this.userId)) return [];\n\n  const logfile = SANDSTORM_LOGDIR + \"/sandstorm.log\";\n\n  const fd = Fs.openSync(logfile, \"r\");\n  const startSize = Fs.fstatSync(fd).size;\n\n  // Difference between the current file offset and the subscription offset. Can be non-zero when\n  // logs have rotated.\n  let extraOffset = 0;\n\n  if (startSize < 8192) {\n    // Log size is less than window size. Check for rotated log and grab its tail.\n    const logfile1 = SANDSTORM_LOGDIR + \"/sandstorm.log.1\";\n    if (Fs.existsSync(logfile1)) {\n      const fd1 = Fs.openSync(logfile1, \"r\");\n      const startSize1 = Fs.fstatSync(fd1).size;\n      const amountFromLog1 = Math.min(startSize1, 8192 - startSize);\n      const offset1 = startSize1 - amountFromLog1;\n      const buf = new Buffer(amountFromLog1);\n      const n = Fs.readSync(fd1, buf, 0, buf.length, offset);\n      if (n > 0) {\n        this.added(\"adminLog\", 0, { text: buf.toString(\"utf8\", 0, n) });\n        extraOffset += n;\n      }\n    }\n  }\n\n  // Start tailing at EOF - 8k.\n  let offset = Math.max(0, startSize - 8192);\n\n  const _this = this;\n  function doTail() {\n    if (Fs.fstatSync(fd).size < offset) {\n      extraOffset += offset;\n      offset = 0;\n    }\n\n    for (;;) {\n      const buf = new Buffer(Math.max(1024, startSize - offset));\n      const n = Fs.readSync(fd, buf, 0, buf.length, offset);\n      if (n <= 0) break;\n      _this.added(\"adminLog\", offset + extraOffset, { text: buf.toString(\"utf8\", 0, n) });\n      offset += n;\n    }\n  }\n\n  // Watch the file for changes.\n  const watcher = Fs.watch(logfile, { persistent: false }, Meteor.bindEnvironment(doTail));\n\n  // When the subscription stops, stop watching the file.\n  this.onStop(function () {\n    watcher.close();\n    Fs.closeSync(fd);\n  });\n\n  // Read initial 8k tail data immediately.\n  doTail();\n\n  // Notify ready.\n  this.ready();\n});\n\nMeteor.publish(\"adminApiTokens\", function (token) {\n  if (!authorizedAsAdmin(token, this.userId)) return [];\n  return ApiTokens.find({\n    $or: [\n      { \"frontendRef.ipNetwork\": { $exists: true } },\n      { \"frontendRef.ipInterface\": { $exists: true } },\n    ],\n  }, {\n    fields: {\n      frontendRef: 1,\n      created: 1,\n      requirements: 1,\n      revoked: 1,\n      owner: 1,\n    },\n  });\n});\n\nMeteor.publish(\"hasAdmin\", function (token) {\n  // Like hasUsers, but for admins, and with token auth required.\n  if (!authorizedAsAdmin(token, this.userId)) return [];\n\n  // Query if there are any admin users.\n  const cursor = Meteor.users.find({ isAdmin: true });\n  if (cursor.count() > 0) {\n    this.added(\"hasAdmin\", \"hasAdmin\", { hasAdmin: true });\n  } else {\n    let handle = cursor.observeChanges({\n      added: (id) => {\n        this.added(\"hasAdmin\", \"hasAdmin\", { hasAdmin: true });\n        handle.stop();\n        handle = null;\n      },\n    });\n    this.onStop(function () {\n      if (handle) handle.stop();\n    });\n  }\n\n  this.ready();\n});\n\nMeteor.publish(\"appIndexAdmin\", function (token) {\n  if (!authorizedAsAdmin(token, this.userId)) return [];\n  return globalDb.collections.appIndex.find();\n});\n\nfunction observeOauthService(name) {\n  Settings.find({ _id: name, value: true }).observe({\n    added: function () {\n      // Tell the oauth library it should accept login attempts from this service.\n      Accounts.oauth.registerService(name);\n    },\n\n    removed: function () {\n      // Tell the oauth library it should deny login attempts from this service.\n      Accounts.oauth.unregisterService(name);\n    },\n  });\n}\n\nobserveOauthService(\"github\");\nobserveOauthService(\"google\");\n"], "filenames": ["shell/imports/server/email.js", "shell/packages/sandstorm-db/db.js", "shell/server/accounts/email-token/token-server.js", "shell/server/admin-server.js"], "buggy_code_start_loc": [77, 1518, 202, 188], "buggy_code_end_loc": [84, 1522, 203, 231], "fixing_code_start_loc": [78, 1519, 202, 188], "fixing_code_end_loc": [121, 1524, 203, 232], "type": "CWE-287", "message": "A remote attacker could bypass the Sandstorm organization restriction before build 0.203 via a comma in an email-address field.", "other": {"cve": {"id": "CVE-2017-6199", "sourceIdentifier": "cve@mitre.org", "published": "2018-02-06T16:29:00.730", "lastModified": "2018-03-13T19:27:30.200", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A remote attacker could bypass the Sandstorm organization restriction before build 0.203 via a comma in an email-address field."}, {"lang": "es", "value": "Un atacante remoto podr\u00eda omitir la restricci\u00f3n de organizaci\u00f3n de Sandstorm antes de la build 0.203 mediante una coma en un campo email-address."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-287"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sandstorm:sandstorm:*:*:*:*:*:*:*:*", "versionEndExcluding": "0.203", "matchCriteriaId": "683ED5F0-D297-4A47-ADF9-186832F3A3AD"}]}]}], "references": [{"url": "https://devco.re/blog/2018/01/26/Sandstorm-Security-Review-CVE-2017-6200-en/", "source": "cve@mitre.org", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://github.com/sandstorm-io/sandstorm/blob/v0.202/shell/packages/sandstorm-db/db.js#L1112", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/sandstorm-io/sandstorm/commit/37bd9a7f4eb776cdc2d3615f0bfea1254b66f59d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://sandstorm.io/news/2017-03-02-security-review", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/sandstorm-io/sandstorm/commit/37bd9a7f4eb776cdc2d3615f0bfea1254b66f59d"}}