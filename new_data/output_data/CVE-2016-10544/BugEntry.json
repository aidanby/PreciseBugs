{"buggy_code": ["#include \"Hub.h\"\n#include \"HTTPSocket.h\"\n#include <openssl/sha.h>\n\nnamespace uWS {\n\nchar *Hub::inflate(char *data, size_t &length) {\n    dynamicInflationBuffer.clear();\n\n    inflationStream.next_in = (Bytef *) data;\n    inflationStream.avail_in = length;\n\n    int err;\n    do {\n        inflationStream.next_out = (Bytef *) inflationBuffer;\n        inflationStream.avail_out = LARGE_BUFFER_SIZE;\n        err = ::inflate(&inflationStream, Z_FINISH);\n        if (!inflationStream.avail_in) {\n            break;\n        }\n        dynamicInflationBuffer.append(inflationBuffer, LARGE_BUFFER_SIZE - inflationStream.avail_out);\n    } while (err == Z_BUF_ERROR);\n\n    inflateReset(&inflationStream);\n\n    if (err != Z_BUF_ERROR && err != Z_OK) {\n        length = 0;\n        return nullptr;\n    }\n\n    if (dynamicInflationBuffer.length()) {\n        dynamicInflationBuffer.append(inflationBuffer, LARGE_BUFFER_SIZE - inflationStream.avail_out);\n\n        length = dynamicInflationBuffer.length();\n        return (char *) dynamicInflationBuffer.data();\n    }\n\n    length = LARGE_BUFFER_SIZE - inflationStream.avail_out;\n    return inflationBuffer;\n}\n\nvoid Hub::onServerAccept(uS::Socket s) {\n    uS::SocketData *socketData = s.getSocketData();\n    s.startTimeout<HTTPSocket<SERVER>::onEnd>();\n    s.enterState<HTTPSocket<SERVER>>(new HTTPSocket<SERVER>::Data(socketData));\n    delete socketData;\n}\n\nvoid Hub::onClientConnection(uS::Socket s, bool error) {\n    HTTPSocket<CLIENT>::Data *httpSocketData = (HTTPSocket<CLIENT>::Data *) s.getSocketData();\n\n    if (error) {\n        ((Group<CLIENT> *) httpSocketData->nodeData)->errorHandler(httpSocketData->httpUser);\n        delete httpSocketData;\n    } else {\n        s.enterState<HTTPSocket<CLIENT>>(s.getSocketData());\n        HTTPSocket<CLIENT>(s).upgrade();\n    }\n}\n\nbool Hub::listen(int port, uS::TLS::Context sslContext, int options, Group<SERVER> *eh) {\n    if (!eh) {\n        eh = (Group<SERVER> *) this;\n    }\n\n    if (uS::Node::listen<onServerAccept>(port, sslContext, options, (uS::NodeData *) eh, nullptr)) {\n        eh->errorHandler(port);\n        return false;\n    }\n    return true;\n}\n\nvoid Hub::connect(std::string uri, void *user, int timeoutMs, Group<CLIENT> *eh) {\n    if (!eh) {\n        eh = (Group<CLIENT> *) this;\n    }\n\n    int offset = 0;\n    std::string protocol = uri.substr(offset, uri.find(\"://\")), hostname, portStr, path;\n    if ((offset += protocol.length() + 3) < uri.length()) {\n        hostname = uri.substr(offset, uri.find_first_of(\":/\", offset) - offset);\n\n        offset += hostname.length();\n        if (uri[offset] == ':') {\n            offset++;\n            portStr = uri.substr(offset, uri.find(\"/\", offset) - offset);\n        }\n\n        offset += portStr.length();\n        if (uri[offset] == '/') {\n            path = uri.substr(++offset);\n        }\n    }\n\n    if (hostname.length()) {\n        int port = 80;\n        bool secure = false;\n        if (protocol == \"wss\") {\n            port = 443;\n            secure = true;\n        } else if (protocol != \"ws\") {\n            eh->errorHandler(user);\n        }\n\n        if (portStr.length()) {\n            port = stoi(portStr);\n        }\n\n        uS::SocketData socketData((uS::NodeData *) eh);\n        HTTPSocket<CLIENT>::Data *httpSocketData = new HTTPSocket<CLIENT>::Data(&socketData);\n\n        httpSocketData->host = hostname;\n        httpSocketData->path = path;\n        httpSocketData->httpUser = user;\n\n        uS::Socket s = uS::Node::connect<onClientConnection>(hostname.c_str(), port, secure, httpSocketData);\n        if (s) {\n            s.startTimeout<HTTPSocket<CLIENT>::onEnd>(timeoutMs);\n        }\n    } else {\n        eh->errorHandler(user);\n    }\n}\n\nbool Hub::upgrade(uv_os_sock_t fd, const char *secKey, SSL *ssl, const char *extensions, size_t extensionsLength, Group<SERVER> *serverGroup) {\n    if (!serverGroup) {\n        serverGroup = &getDefaultGroup<SERVER>();\n    }\n\n    uS::Socket s = uS::Socket::init((uS::NodeData *) serverGroup, fd, ssl);\n    uS::SocketData *socketData = s.getSocketData();\n    HTTPSocket<SERVER>::Data *temporaryHttpData = new HTTPSocket<SERVER>::Data(socketData);\n    delete socketData;\n    s.enterState<HTTPSocket<SERVER>>(temporaryHttpData);\n\n    // todo: move this into upgrade call\n    bool perMessageDeflate = false;\n    std::string extensionsResponse;\n    if (extensionsLength) {\n        ExtensionsNegotiator<uWS::SERVER> extensionsNegotiator(serverGroup->extensionOptions);\n        extensionsNegotiator.readOffer(std::string(extensions, extensionsLength));\n        extensionsResponse = extensionsNegotiator.generateOffer();\n        if (extensionsNegotiator.getNegotiatedOptions() & PERMESSAGE_DEFLATE) {\n            perMessageDeflate = true;\n        }\n    }\n\n    if (HTTPSocket<SERVER>(s).upgrade(secKey, extensionsResponse.data(), extensionsResponse.length())) {\n        s.enterState<WebSocket<SERVER>>(new WebSocket<SERVER>::Data(perMessageDeflate, s.getSocketData()));\n        serverGroup->addWebSocket(s);\n        serverGroup->connectionHandler(WebSocket<SERVER>(s), {nullptr, nullptr, 0, 0});\n        delete temporaryHttpData;\n        return true;\n    }\n    return false;\n}\n\n}\n", "#include \"Hub.h\"\n\nnamespace uWS {\n\ntemplate <const bool isServer>\nbool WebSocketProtocol<isServer>::setCompressed(void *user) {\n    uS::Socket s((uv_poll_t *) user);\n    typename WebSocket<isServer>::Data *webSocketData = (typename WebSocket<isServer>::Data *) s.getSocketData();\n\n    if (webSocketData->compressionStatus == WebSocket<isServer>::Data::CompressionStatus::ENABLED) {\n        webSocketData->compressionStatus = WebSocket<isServer>::Data::CompressionStatus::COMPRESSED_FRAME;\n        return true;\n    } else {\n        return false;\n    }\n}\n\ntemplate <const bool isServer>\nbool WebSocketProtocol<isServer>::refusePayloadLength(void *user, int length) {\n    return length > 16777216;\n}\n\ntemplate <const bool isServer>\nvoid WebSocketProtocol<isServer>::forceClose(void *user) {\n    WebSocket<isServer>((uv_poll_t *) user).terminate();\n}\n\ntemplate <const bool isServer>\nbool WebSocketProtocol<isServer>::handleFragment(char *data, size_t length, unsigned int remainingBytes, int opCode, bool fin, void *user) {\n    uS::Socket s((uv_poll_t *) user);\n    typename WebSocket<isServer>::Data *webSocketData = (typename WebSocket<isServer>::Data *) s.getSocketData();\n\n    if (opCode < 3) {\n        if (!remainingBytes && fin && !webSocketData->fragmentBuffer.length()) {\n            if (webSocketData->compressionStatus == WebSocket<isServer>::Data::CompressionStatus::COMPRESSED_FRAME) {\n                webSocketData->compressionStatus = WebSocket<isServer>::Data::CompressionStatus::ENABLED;\n                Hub *hub = ((Group<isServer> *) s.getSocketData()->nodeData)->hub;\n                data = hub->inflate(data, length);\n            }\n\n            if (opCode == 1 && !isValidUtf8((unsigned char *) data, length)) {\n                forceClose(user);\n                return true;\n            }\n\n            ((Group<isServer> *) s.getSocketData()->nodeData)->messageHandler(WebSocket<isServer>(s), data, length, (OpCode) opCode);\n            if (s.isClosed() || s.isShuttingDown()) {\n                return true;\n            }\n        } else {\n            webSocketData->fragmentBuffer.append(data, length);\n            if (!remainingBytes && fin) {\n                length = webSocketData->fragmentBuffer.length();\n                if (webSocketData->compressionStatus == WebSocket<isServer>::Data::CompressionStatus::COMPRESSED_FRAME) {\n                    webSocketData->compressionStatus = WebSocket<isServer>::Data::CompressionStatus::ENABLED;\n                    Hub *hub = ((Group<isServer> *) s.getSocketData()->nodeData)->hub;\n                    webSocketData->fragmentBuffer.append(\"....\");\n                    data = hub->inflate((char *) webSocketData->fragmentBuffer.data(), length);\n                } else {\n                    data = (char *) webSocketData->fragmentBuffer.data();\n                }\n\n                if (opCode == 1 && !isValidUtf8((unsigned char *) data, length)) {\n                    forceClose(user);\n                    return true;\n                }\n\n                ((Group<isServer> *) s.getSocketData()->nodeData)->messageHandler(WebSocket<isServer>(s), data, length, (OpCode) opCode);\n                if (s.isClosed() || s.isShuttingDown()) {\n                    return true;\n                }\n                webSocketData->fragmentBuffer.clear();\n            }\n        }\n    } else {\n        // todo: we don't need to buffer up in most cases!\n        webSocketData->controlBuffer.append(data, length);\n        if (!remainingBytes && fin) {\n            if (opCode == CLOSE) {\n                CloseFrame closeFrame = parseClosePayload((char *) webSocketData->controlBuffer.data(), webSocketData->controlBuffer.length());\n                WebSocket<isServer>(s).close(closeFrame.code, closeFrame.message, closeFrame.length);\n                return true;\n            } else {\n                if (opCode == PING) {\n                    WebSocket<isServer>(s).send(webSocketData->controlBuffer.data(), webSocketData->controlBuffer.length(), (OpCode) OpCode::PONG);\n                    ((Group<isServer> *) s.getSocketData()->nodeData)->pingHandler(WebSocket<isServer>(s), (char *) webSocketData->controlBuffer.data(), webSocketData->controlBuffer.length());\n                    if (s.isClosed() || s.isShuttingDown()) {\n                        return true;\n                    }\n                } else if (opCode == PONG) {\n                    ((Group<isServer> *) s.getSocketData()->nodeData)->pongHandler(WebSocket<isServer>(s), (char *) webSocketData->controlBuffer.data(), webSocketData->controlBuffer.length());\n                    if (s.isClosed() || s.isShuttingDown()) {\n                        return true;\n                    }\n                }\n            }\n            webSocketData->controlBuffer.clear();\n        }\n    }\n\n    return false;\n}\n\ntemplate class WebSocketProtocol<SERVER>;\ntemplate class WebSocketProtocol<CLIENT>;\n\n}\n"], "fixing_code": ["#include \"Hub.h\"\n#include \"HTTPSocket.h\"\n#include <openssl/sha.h>\n\nstatic const int INFLATE_LESS_THAN_ROUGHLY = 16777216;\n\nnamespace uWS {\n\nchar *Hub::inflate(char *data, size_t &length) {\n    dynamicInflationBuffer.clear();\n\n    inflationStream.next_in = (Bytef *) data;\n    inflationStream.avail_in = length;\n\n    int err;\n    do {\n        inflationStream.next_out = (Bytef *) inflationBuffer;\n        inflationStream.avail_out = LARGE_BUFFER_SIZE;\n        err = ::inflate(&inflationStream, Z_FINISH);\n        if (!inflationStream.avail_in) {\n            break;\n        }\n\n        dynamicInflationBuffer.append(inflationBuffer, LARGE_BUFFER_SIZE - inflationStream.avail_out);\n    } while (err == Z_BUF_ERROR && dynamicInflationBuffer.length() <= INFLATE_LESS_THAN_ROUGHLY);\n\n    inflateReset(&inflationStream);\n\n    if ((err != Z_BUF_ERROR && err != Z_OK) || dynamicInflationBuffer.length() > INFLATE_LESS_THAN_ROUGHLY) {\n        length = 0;\n        return nullptr;\n    }\n\n    if (dynamicInflationBuffer.length()) {\n        dynamicInflationBuffer.append(inflationBuffer, LARGE_BUFFER_SIZE - inflationStream.avail_out);\n\n        length = dynamicInflationBuffer.length();\n        return (char *) dynamicInflationBuffer.data();\n    }\n\n    length = LARGE_BUFFER_SIZE - inflationStream.avail_out;\n    return inflationBuffer;\n}\n\nvoid Hub::onServerAccept(uS::Socket s) {\n    uS::SocketData *socketData = s.getSocketData();\n    s.startTimeout<HTTPSocket<SERVER>::onEnd>();\n    s.enterState<HTTPSocket<SERVER>>(new HTTPSocket<SERVER>::Data(socketData));\n    delete socketData;\n}\n\nvoid Hub::onClientConnection(uS::Socket s, bool error) {\n    HTTPSocket<CLIENT>::Data *httpSocketData = (HTTPSocket<CLIENT>::Data *) s.getSocketData();\n\n    if (error) {\n        ((Group<CLIENT> *) httpSocketData->nodeData)->errorHandler(httpSocketData->httpUser);\n        delete httpSocketData;\n    } else {\n        s.enterState<HTTPSocket<CLIENT>>(s.getSocketData());\n        HTTPSocket<CLIENT>(s).upgrade();\n    }\n}\n\nbool Hub::listen(int port, uS::TLS::Context sslContext, int options, Group<SERVER> *eh) {\n    if (!eh) {\n        eh = (Group<SERVER> *) this;\n    }\n\n    if (uS::Node::listen<onServerAccept>(port, sslContext, options, (uS::NodeData *) eh, nullptr)) {\n        eh->errorHandler(port);\n        return false;\n    }\n    return true;\n}\n\nvoid Hub::connect(std::string uri, void *user, int timeoutMs, Group<CLIENT> *eh) {\n    if (!eh) {\n        eh = (Group<CLIENT> *) this;\n    }\n\n    int offset = 0;\n    std::string protocol = uri.substr(offset, uri.find(\"://\")), hostname, portStr, path;\n    if ((offset += protocol.length() + 3) < uri.length()) {\n        hostname = uri.substr(offset, uri.find_first_of(\":/\", offset) - offset);\n\n        offset += hostname.length();\n        if (uri[offset] == ':') {\n            offset++;\n            portStr = uri.substr(offset, uri.find(\"/\", offset) - offset);\n        }\n\n        offset += portStr.length();\n        if (uri[offset] == '/') {\n            path = uri.substr(++offset);\n        }\n    }\n\n    if (hostname.length()) {\n        int port = 80;\n        bool secure = false;\n        if (protocol == \"wss\") {\n            port = 443;\n            secure = true;\n        } else if (protocol != \"ws\") {\n            eh->errorHandler(user);\n        }\n\n        if (portStr.length()) {\n            port = stoi(portStr);\n        }\n\n        uS::SocketData socketData((uS::NodeData *) eh);\n        HTTPSocket<CLIENT>::Data *httpSocketData = new HTTPSocket<CLIENT>::Data(&socketData);\n\n        httpSocketData->host = hostname;\n        httpSocketData->path = path;\n        httpSocketData->httpUser = user;\n\n        uS::Socket s = uS::Node::connect<onClientConnection>(hostname.c_str(), port, secure, httpSocketData);\n        if (s) {\n            s.startTimeout<HTTPSocket<CLIENT>::onEnd>(timeoutMs);\n        }\n    } else {\n        eh->errorHandler(user);\n    }\n}\n\nbool Hub::upgrade(uv_os_sock_t fd, const char *secKey, SSL *ssl, const char *extensions, size_t extensionsLength, Group<SERVER> *serverGroup) {\n    if (!serverGroup) {\n        serverGroup = &getDefaultGroup<SERVER>();\n    }\n\n    uS::Socket s = uS::Socket::init((uS::NodeData *) serverGroup, fd, ssl);\n    uS::SocketData *socketData = s.getSocketData();\n    HTTPSocket<SERVER>::Data *temporaryHttpData = new HTTPSocket<SERVER>::Data(socketData);\n    delete socketData;\n    s.enterState<HTTPSocket<SERVER>>(temporaryHttpData);\n\n    // todo: move this into upgrade call\n    bool perMessageDeflate = false;\n    std::string extensionsResponse;\n    if (extensionsLength) {\n        ExtensionsNegotiator<uWS::SERVER> extensionsNegotiator(serverGroup->extensionOptions);\n        extensionsNegotiator.readOffer(std::string(extensions, extensionsLength));\n        extensionsResponse = extensionsNegotiator.generateOffer();\n        if (extensionsNegotiator.getNegotiatedOptions() & PERMESSAGE_DEFLATE) {\n            perMessageDeflate = true;\n        }\n    }\n\n    if (HTTPSocket<SERVER>(s).upgrade(secKey, extensionsResponse.data(), extensionsResponse.length())) {\n        s.enterState<WebSocket<SERVER>>(new WebSocket<SERVER>::Data(perMessageDeflate, s.getSocketData()));\n        serverGroup->addWebSocket(s);\n        serverGroup->connectionHandler(WebSocket<SERVER>(s), {nullptr, nullptr, 0, 0});\n        delete temporaryHttpData;\n        return true;\n    }\n    return false;\n}\n\n}\n", "#include \"Hub.h\"\n\nnamespace uWS {\n\ntemplate <const bool isServer>\nbool WebSocketProtocol<isServer>::setCompressed(void *user) {\n    uS::Socket s((uv_poll_t *) user);\n    typename WebSocket<isServer>::Data *webSocketData = (typename WebSocket<isServer>::Data *) s.getSocketData();\n\n    if (webSocketData->compressionStatus == WebSocket<isServer>::Data::CompressionStatus::ENABLED) {\n        webSocketData->compressionStatus = WebSocket<isServer>::Data::CompressionStatus::COMPRESSED_FRAME;\n        return true;\n    } else {\n        return false;\n    }\n}\n\ntemplate <const bool isServer>\nbool WebSocketProtocol<isServer>::refusePayloadLength(void *user, int length) {\n    return length > 16777216;\n}\n\ntemplate <const bool isServer>\nvoid WebSocketProtocol<isServer>::forceClose(void *user) {\n    WebSocket<isServer>((uv_poll_t *) user).terminate();\n}\n\ntemplate <const bool isServer>\nbool WebSocketProtocol<isServer>::handleFragment(char *data, size_t length, unsigned int remainingBytes, int opCode, bool fin, void *user) {\n    uS::Socket s((uv_poll_t *) user);\n    typename WebSocket<isServer>::Data *webSocketData = (typename WebSocket<isServer>::Data *) s.getSocketData();\n\n    if (opCode < 3) {\n        if (!remainingBytes && fin && !webSocketData->fragmentBuffer.length()) {\n            if (webSocketData->compressionStatus == WebSocket<isServer>::Data::CompressionStatus::COMPRESSED_FRAME) {\n                webSocketData->compressionStatus = WebSocket<isServer>::Data::CompressionStatus::ENABLED;\n                Hub *hub = ((Group<isServer> *) s.getSocketData()->nodeData)->hub;\n                data = hub->inflate(data, length);\n                if (!data) {\n                    forceClose(user);\n                    return true;\n                }\n            }\n\n            if (opCode == 1 && !isValidUtf8((unsigned char *) data, length)) {\n                forceClose(user);\n                return true;\n            }\n\n            ((Group<isServer> *) s.getSocketData()->nodeData)->messageHandler(WebSocket<isServer>(s), data, length, (OpCode) opCode);\n            if (s.isClosed() || s.isShuttingDown()) {\n                return true;\n            }\n        } else {\n            webSocketData->fragmentBuffer.append(data, length);\n            if (!remainingBytes && fin) {\n                length = webSocketData->fragmentBuffer.length();\n                if (webSocketData->compressionStatus == WebSocket<isServer>::Data::CompressionStatus::COMPRESSED_FRAME) {\n                    webSocketData->compressionStatus = WebSocket<isServer>::Data::CompressionStatus::ENABLED;\n                    Hub *hub = ((Group<isServer> *) s.getSocketData()->nodeData)->hub;\n                    webSocketData->fragmentBuffer.append(\"....\");\n                    data = hub->inflate((char *) webSocketData->fragmentBuffer.data(), length);\n                    if (!data) {\n                        forceClose(user);\n                        return true;\n                    }\n                } else {\n                    data = (char *) webSocketData->fragmentBuffer.data();\n                }\n\n                if (opCode == 1 && !isValidUtf8((unsigned char *) data, length)) {\n                    forceClose(user);\n                    return true;\n                }\n\n                ((Group<isServer> *) s.getSocketData()->nodeData)->messageHandler(WebSocket<isServer>(s), data, length, (OpCode) opCode);\n                if (s.isClosed() || s.isShuttingDown()) {\n                    return true;\n                }\n                webSocketData->fragmentBuffer.clear();\n            }\n        }\n    } else {\n        // todo: we don't need to buffer up in most cases!\n        webSocketData->controlBuffer.append(data, length);\n        if (!remainingBytes && fin) {\n            if (opCode == CLOSE) {\n                CloseFrame closeFrame = parseClosePayload((char *) webSocketData->controlBuffer.data(), webSocketData->controlBuffer.length());\n                WebSocket<isServer>(s).close(closeFrame.code, closeFrame.message, closeFrame.length);\n                return true;\n            } else {\n                if (opCode == PING) {\n                    WebSocket<isServer>(s).send(webSocketData->controlBuffer.data(), webSocketData->controlBuffer.length(), (OpCode) OpCode::PONG);\n                    ((Group<isServer> *) s.getSocketData()->nodeData)->pingHandler(WebSocket<isServer>(s), (char *) webSocketData->controlBuffer.data(), webSocketData->controlBuffer.length());\n                    if (s.isClosed() || s.isShuttingDown()) {\n                        return true;\n                    }\n                } else if (opCode == PONG) {\n                    ((Group<isServer> *) s.getSocketData()->nodeData)->pongHandler(WebSocket<isServer>(s), (char *) webSocketData->controlBuffer.data(), webSocketData->controlBuffer.length());\n                    if (s.isClosed() || s.isShuttingDown()) {\n                        return true;\n                    }\n                }\n            }\n            webSocketData->controlBuffer.clear();\n        }\n    }\n\n    return false;\n}\n\ntemplate class WebSocketProtocol<SERVER>;\ntemplate class WebSocketProtocol<CLIENT>;\n\n}\n"], "filenames": ["src/Hub.cpp", "src/WebSocketImpl.cpp"], "buggy_code_start_loc": [3, 38], "buggy_code_end_loc": [27, 58], "fixing_code_start_loc": [4, 39], "fixing_code_end_loc": [30, 67], "type": "CWE-20", "message": "uws is a WebSocket server library. By sending a 256mb websocket message to a uws server instance with permessage-deflate enabled, there is a possibility used compression will shrink said 256mb down to less than 16mb of websocket payload which passes the length check of 16mb payload. This data will then inflate up to 256mb and crash the node process by exceeding V8's maximum string size. This affects uws >=0.10.0 <=0.10.8.", "other": {"cve": {"id": "CVE-2016-10544", "sourceIdentifier": "support@hackerone.com", "published": "2018-05-31T20:29:01.643", "lastModified": "2019-10-09T23:16:45.090", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "uws is a WebSocket server library. By sending a 256mb websocket message to a uws server instance with permessage-deflate enabled, there is a possibility used compression will shrink said 256mb down to less than 16mb of websocket payload which passes the length check of 16mb payload. This data will then inflate up to 256mb and crash the node process by exceeding V8's maximum string size. This affects uws >=0.10.0 <=0.10.8."}, {"lang": "es", "value": "uws es una biblioteca del servidor WebSocket. Mediante el env\u00edo de un mensaje websocket de 256 mb a una instancia del servidor uws con permessage-deflate habilitado, existe la posibilidad de que la compresi\u00f3n utilizada comprimir\u00e1 esos 256 mb a menos de 16 mb de carga \u00fatil de websocket, lo que supera la comprobaci\u00f3n de longitud de 16 mb de carga \u00fatil. Estos datos aumentar\u00e1n posteriormente a 256 mb y provocar\u00e1n el cierre inesperado del proceso node excediendo el tama\u00f1o m\u00e1ximo de cadena de V8. Esto afecta a uws desde la versi\u00f3n 0.10.0 hasta la 0.10.8."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-20"}]}, {"source": "support@hackerone.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:uws_project:uws:*:*:*:*:*:node.js:*:*", "versionStartIncluding": "0.10.0", "versionEndIncluding": "0.10.8", "matchCriteriaId": "48FF74BE-2850-4F3F-9E2B-C49A4237CF66"}]}]}], "references": [{"url": "https://github.com/uWebSockets/uWebSockets/commit/37deefd01f0875e133ea967122e3a5e421b8fcd9", "source": "support@hackerone.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://nodesecurity.io/advisories/149", "source": "support@hackerone.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/uWebSockets/uWebSockets/commit/37deefd01f0875e133ea967122e3a5e421b8fcd9"}}