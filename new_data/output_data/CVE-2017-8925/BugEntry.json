{"buggy_code": ["/*\n * USB ZyXEL omni.net LCD PLUS driver\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License version\n *\t2 as published by the Free Software Foundation.\n *\n * See Documentation/usb/usb-serial.txt for more information on using this\n * driver\n *\n * Please report both successes and troubles to the author at omninet@kroah.com\n */\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n\n#define DRIVER_AUTHOR \"Alessandro Zummo\"\n#define DRIVER_DESC \"USB ZyXEL omni.net LCD PLUS Driver\"\n\n#define ZYXEL_VENDOR_ID\t\t0x0586\n#define ZYXEL_OMNINET_ID\t0x1000\n/* This one seems to be a re-branded ZyXEL device */\n#define BT_IGNITIONPRO_ID\t0x2000\n\n/* function prototypes */\nstatic int  omninet_open(struct tty_struct *tty, struct usb_serial_port *port);\nstatic void omninet_process_read_urb(struct urb *urb);\nstatic void omninet_write_bulk_callback(struct urb *urb);\nstatic int  omninet_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\t\t\tconst unsigned char *buf, int count);\nstatic int  omninet_write_room(struct tty_struct *tty);\nstatic void omninet_disconnect(struct usb_serial *serial);\nstatic int omninet_attach(struct usb_serial *serial);\nstatic int omninet_port_probe(struct usb_serial_port *port);\nstatic int omninet_port_remove(struct usb_serial_port *port);\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(ZYXEL_VENDOR_ID, ZYXEL_OMNINET_ID) },\n\t{ USB_DEVICE(ZYXEL_VENDOR_ID, BT_IGNITIONPRO_ID) },\n\t{ }\t\t\t\t\t\t/* Terminating entry */\n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstatic struct usb_serial_driver zyxel_omninet_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"omninet\",\n\t},\n\t.description =\t\t\"ZyXEL - omni.net lcd plus usb\",\n\t.id_table =\t\tid_table,\n\t.num_ports =\t\t1,\n\t.attach =\t\tomninet_attach,\n\t.port_probe =\t\tomninet_port_probe,\n\t.port_remove =\t\tomninet_port_remove,\n\t.open =\t\t\tomninet_open,\n\t.write =\t\tomninet_write,\n\t.write_room =\t\tomninet_write_room,\n\t.write_bulk_callback =\tomninet_write_bulk_callback,\n\t.process_read_urb =\tomninet_process_read_urb,\n\t.disconnect =\t\tomninet_disconnect,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&zyxel_omninet_device, NULL\n};\n\n\n/*\n * The protocol.\n *\n * The omni.net always exchange 64 bytes of data with the host. The first\n * four bytes are the control header.\n *\n * oh_seq is a sequence number. Don't know if/how it's used.\n * oh_len is the length of the data bytes in the packet.\n * oh_xxx Bit-mapped, related to handshaking and status info.\n *\tI normally set it to 0x03 in transmitted frames.\n *\t7: Active when the TA is in a CONNECTed state.\n *\t6: unknown\n *\t5: handshaking, unknown\n *\t4: handshaking, unknown\n *\t3: unknown, usually 0\n *\t2: unknown, usually 0\n *\t1: handshaking, unknown, usually set to 1 in transmitted frames\n *\t0: handshaking, unknown, usually set to 1 in transmitted frames\n * oh_pad Probably a pad byte.\n *\n * After the header you will find data bytes if oh_len was greater than zero.\n */\nstruct omninet_header {\n\t__u8\toh_seq;\n\t__u8\toh_len;\n\t__u8\toh_xxx;\n\t__u8\toh_pad;\n};\n\nstruct omninet_data {\n\t__u8\tod_outseq;\t/* Sequence number for bulk_out URBs */\n};\n\nstatic int omninet_attach(struct usb_serial *serial)\n{\n\t/* The second bulk-out endpoint is used for writing. */\n\tif (serial->num_bulk_out < 2) {\n\t\tdev_err(&serial->interface->dev, \"missing endpoints\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int omninet_port_probe(struct usb_serial_port *port)\n{\n\tstruct omninet_data *od;\n\n\tod = kzalloc(sizeof(*od), GFP_KERNEL);\n\tif (!od)\n\t\treturn -ENOMEM;\n\n\tusb_set_serial_port_data(port, od);\n\n\treturn 0;\n}\n\nstatic int omninet_port_remove(struct usb_serial_port *port)\n{\n\tstruct omninet_data *od;\n\n\tod = usb_get_serial_port_data(port);\n\tkfree(od);\n\n\treturn 0;\n}\n\nstatic int omninet_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\tstruct usb_serial\t*serial = port->serial;\n\tstruct usb_serial_port\t*wport;\n\n\twport = serial->port[1];\n\ttty_port_tty_set(&wport->port, tty);\n\n\treturn usb_serial_generic_open(tty, port);\n}\n\n#define OMNINET_HEADERLEN\t4\n#define OMNINET_BULKOUTSIZE\t64\n#define OMNINET_PAYLOADSIZE\t(OMNINET_BULKOUTSIZE - OMNINET_HEADERLEN)\n\nstatic void omninet_process_read_urb(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tconst struct omninet_header *hdr = urb->transfer_buffer;\n\tconst unsigned char *data;\n\tsize_t data_len;\n\n\tif (urb->actual_length <= OMNINET_HEADERLEN || !hdr->oh_len)\n\t\treturn;\n\n\tdata = (char *)urb->transfer_buffer + OMNINET_HEADERLEN;\n\tdata_len = min_t(size_t, urb->actual_length - OMNINET_HEADERLEN,\n\t\t\t\t\t\t\t\thdr->oh_len);\n\ttty_insert_flip_string(&port->port, data, data_len);\n\ttty_flip_buffer_push(&port->port);\n}\n\nstatic int omninet_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\t\t\t\tconst unsigned char *buf, int count)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct usb_serial_port *wport = serial->port[1];\n\n\tstruct omninet_data *od = usb_get_serial_port_data(port);\n\tstruct omninet_header *header = (struct omninet_header *)\n\t\t\t\t\twport->write_urb->transfer_buffer;\n\n\tint\t\t\tresult;\n\n\tif (count == 0) {\n\t\tdev_dbg(&port->dev, \"%s - write request of 0 bytes\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tif (!test_and_clear_bit(0, &port->write_urbs_free)) {\n\t\tdev_dbg(&port->dev, \"%s - already writing\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tcount = (count > OMNINET_PAYLOADSIZE) ? OMNINET_PAYLOADSIZE : count;\n\n\tmemcpy(wport->write_urb->transfer_buffer + OMNINET_HEADERLEN,\n\t\t\t\t\t\t\t\tbuf, count);\n\n\tusb_serial_debug_data(&port->dev, __func__, count,\n\t\t\t      wport->write_urb->transfer_buffer);\n\n\theader->oh_seq \t= od->od_outseq++;\n\theader->oh_len \t= count;\n\theader->oh_xxx  = 0x03;\n\theader->oh_pad \t= 0x00;\n\n\t/* send the data out the bulk port, always 64 bytes */\n\twport->write_urb->transfer_buffer_length = OMNINET_BULKOUTSIZE;\n\n\tresult = usb_submit_urb(wport->write_urb, GFP_ATOMIC);\n\tif (result) {\n\t\tset_bit(0, &wport->write_urbs_free);\n\t\tdev_err_console(port,\n\t\t\t\"%s - failed submitting write urb, error %d\\n\",\n\t\t\t__func__, result);\n\t} else\n\t\tresult = count;\n\n\treturn result;\n}\n\n\nstatic int omninet_write_room(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct usb_serial \t*serial = port->serial;\n\tstruct usb_serial_port \t*wport \t= serial->port[1];\n\n\tint room = 0; /* Default: no room */\n\n\tif (test_bit(0, &wport->write_urbs_free))\n\t\troom = wport->bulk_out_size - OMNINET_HEADERLEN;\n\n\tdev_dbg(&port->dev, \"%s - returns %d\\n\", __func__, room);\n\n\treturn room;\n}\n\nstatic void omninet_write_bulk_callback(struct urb *urb)\n{\n/*\tstruct omninet_header\t*header = (struct omninet_header  *)\n\t\t\t\t\t\turb->transfer_buffer; */\n\tstruct usb_serial_port \t*port   =  urb->context;\n\tint status = urb->status;\n\n\tset_bit(0, &port->write_urbs_free);\n\tif (status) {\n\t\tdev_dbg(&port->dev, \"%s - nonzero write bulk status received: %d\\n\",\n\t\t\t__func__, status);\n\t\treturn;\n\t}\n\n\tusb_serial_port_softint(port);\n}\n\n\nstatic void omninet_disconnect(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *wport = serial->port[1];\n\n\tusb_kill_urb(wport->write_urb);\n}\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n"], "fixing_code": ["/*\n * USB ZyXEL omni.net LCD PLUS driver\n *\n *\tThis program is free software; you can redistribute it and/or\n *\tmodify it under the terms of the GNU General Public License version\n *\t2 as published by the Free Software Foundation.\n *\n * See Documentation/usb/usb-serial.txt for more information on using this\n * driver\n *\n * Please report both successes and troubles to the author at omninet@kroah.com\n */\n\n#include <linux/kernel.h>\n#include <linux/errno.h>\n#include <linux/slab.h>\n#include <linux/tty.h>\n#include <linux/tty_driver.h>\n#include <linux/tty_flip.h>\n#include <linux/module.h>\n#include <linux/uaccess.h>\n#include <linux/usb.h>\n#include <linux/usb/serial.h>\n\n#define DRIVER_AUTHOR \"Alessandro Zummo\"\n#define DRIVER_DESC \"USB ZyXEL omni.net LCD PLUS Driver\"\n\n#define ZYXEL_VENDOR_ID\t\t0x0586\n#define ZYXEL_OMNINET_ID\t0x1000\n/* This one seems to be a re-branded ZyXEL device */\n#define BT_IGNITIONPRO_ID\t0x2000\n\n/* function prototypes */\nstatic int  omninet_open(struct tty_struct *tty, struct usb_serial_port *port);\nstatic void omninet_process_read_urb(struct urb *urb);\nstatic void omninet_write_bulk_callback(struct urb *urb);\nstatic int  omninet_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\t\t\tconst unsigned char *buf, int count);\nstatic int  omninet_write_room(struct tty_struct *tty);\nstatic void omninet_disconnect(struct usb_serial *serial);\nstatic int omninet_attach(struct usb_serial *serial);\nstatic int omninet_port_probe(struct usb_serial_port *port);\nstatic int omninet_port_remove(struct usb_serial_port *port);\n\nstatic const struct usb_device_id id_table[] = {\n\t{ USB_DEVICE(ZYXEL_VENDOR_ID, ZYXEL_OMNINET_ID) },\n\t{ USB_DEVICE(ZYXEL_VENDOR_ID, BT_IGNITIONPRO_ID) },\n\t{ }\t\t\t\t\t\t/* Terminating entry */\n};\nMODULE_DEVICE_TABLE(usb, id_table);\n\nstatic struct usb_serial_driver zyxel_omninet_device = {\n\t.driver = {\n\t\t.owner =\tTHIS_MODULE,\n\t\t.name =\t\t\"omninet\",\n\t},\n\t.description =\t\t\"ZyXEL - omni.net lcd plus usb\",\n\t.id_table =\t\tid_table,\n\t.num_ports =\t\t1,\n\t.attach =\t\tomninet_attach,\n\t.port_probe =\t\tomninet_port_probe,\n\t.port_remove =\t\tomninet_port_remove,\n\t.open =\t\t\tomninet_open,\n\t.write =\t\tomninet_write,\n\t.write_room =\t\tomninet_write_room,\n\t.write_bulk_callback =\tomninet_write_bulk_callback,\n\t.process_read_urb =\tomninet_process_read_urb,\n\t.disconnect =\t\tomninet_disconnect,\n};\n\nstatic struct usb_serial_driver * const serial_drivers[] = {\n\t&zyxel_omninet_device, NULL\n};\n\n\n/*\n * The protocol.\n *\n * The omni.net always exchange 64 bytes of data with the host. The first\n * four bytes are the control header.\n *\n * oh_seq is a sequence number. Don't know if/how it's used.\n * oh_len is the length of the data bytes in the packet.\n * oh_xxx Bit-mapped, related to handshaking and status info.\n *\tI normally set it to 0x03 in transmitted frames.\n *\t7: Active when the TA is in a CONNECTed state.\n *\t6: unknown\n *\t5: handshaking, unknown\n *\t4: handshaking, unknown\n *\t3: unknown, usually 0\n *\t2: unknown, usually 0\n *\t1: handshaking, unknown, usually set to 1 in transmitted frames\n *\t0: handshaking, unknown, usually set to 1 in transmitted frames\n * oh_pad Probably a pad byte.\n *\n * After the header you will find data bytes if oh_len was greater than zero.\n */\nstruct omninet_header {\n\t__u8\toh_seq;\n\t__u8\toh_len;\n\t__u8\toh_xxx;\n\t__u8\toh_pad;\n};\n\nstruct omninet_data {\n\t__u8\tod_outseq;\t/* Sequence number for bulk_out URBs */\n};\n\nstatic int omninet_attach(struct usb_serial *serial)\n{\n\t/* The second bulk-out endpoint is used for writing. */\n\tif (serial->num_bulk_out < 2) {\n\t\tdev_err(&serial->interface->dev, \"missing endpoints\\n\");\n\t\treturn -ENODEV;\n\t}\n\n\treturn 0;\n}\n\nstatic int omninet_port_probe(struct usb_serial_port *port)\n{\n\tstruct omninet_data *od;\n\n\tod = kzalloc(sizeof(*od), GFP_KERNEL);\n\tif (!od)\n\t\treturn -ENOMEM;\n\n\tusb_set_serial_port_data(port, od);\n\n\treturn 0;\n}\n\nstatic int omninet_port_remove(struct usb_serial_port *port)\n{\n\tstruct omninet_data *od;\n\n\tod = usb_get_serial_port_data(port);\n\tkfree(od);\n\n\treturn 0;\n}\n\nstatic int omninet_open(struct tty_struct *tty, struct usb_serial_port *port)\n{\n\treturn usb_serial_generic_open(tty, port);\n}\n\n#define OMNINET_HEADERLEN\t4\n#define OMNINET_BULKOUTSIZE\t64\n#define OMNINET_PAYLOADSIZE\t(OMNINET_BULKOUTSIZE - OMNINET_HEADERLEN)\n\nstatic void omninet_process_read_urb(struct urb *urb)\n{\n\tstruct usb_serial_port *port = urb->context;\n\tconst struct omninet_header *hdr = urb->transfer_buffer;\n\tconst unsigned char *data;\n\tsize_t data_len;\n\n\tif (urb->actual_length <= OMNINET_HEADERLEN || !hdr->oh_len)\n\t\treturn;\n\n\tdata = (char *)urb->transfer_buffer + OMNINET_HEADERLEN;\n\tdata_len = min_t(size_t, urb->actual_length - OMNINET_HEADERLEN,\n\t\t\t\t\t\t\t\thdr->oh_len);\n\ttty_insert_flip_string(&port->port, data, data_len);\n\ttty_flip_buffer_push(&port->port);\n}\n\nstatic int omninet_write(struct tty_struct *tty, struct usb_serial_port *port,\n\t\t\t\t\tconst unsigned char *buf, int count)\n{\n\tstruct usb_serial *serial = port->serial;\n\tstruct usb_serial_port *wport = serial->port[1];\n\n\tstruct omninet_data *od = usb_get_serial_port_data(port);\n\tstruct omninet_header *header = (struct omninet_header *)\n\t\t\t\t\twport->write_urb->transfer_buffer;\n\n\tint\t\t\tresult;\n\n\tif (count == 0) {\n\t\tdev_dbg(&port->dev, \"%s - write request of 0 bytes\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tif (!test_and_clear_bit(0, &port->write_urbs_free)) {\n\t\tdev_dbg(&port->dev, \"%s - already writing\\n\", __func__);\n\t\treturn 0;\n\t}\n\n\tcount = (count > OMNINET_PAYLOADSIZE) ? OMNINET_PAYLOADSIZE : count;\n\n\tmemcpy(wport->write_urb->transfer_buffer + OMNINET_HEADERLEN,\n\t\t\t\t\t\t\t\tbuf, count);\n\n\tusb_serial_debug_data(&port->dev, __func__, count,\n\t\t\t      wport->write_urb->transfer_buffer);\n\n\theader->oh_seq \t= od->od_outseq++;\n\theader->oh_len \t= count;\n\theader->oh_xxx  = 0x03;\n\theader->oh_pad \t= 0x00;\n\n\t/* send the data out the bulk port, always 64 bytes */\n\twport->write_urb->transfer_buffer_length = OMNINET_BULKOUTSIZE;\n\n\tresult = usb_submit_urb(wport->write_urb, GFP_ATOMIC);\n\tif (result) {\n\t\tset_bit(0, &wport->write_urbs_free);\n\t\tdev_err_console(port,\n\t\t\t\"%s - failed submitting write urb, error %d\\n\",\n\t\t\t__func__, result);\n\t} else\n\t\tresult = count;\n\n\treturn result;\n}\n\n\nstatic int omninet_write_room(struct tty_struct *tty)\n{\n\tstruct usb_serial_port *port = tty->driver_data;\n\tstruct usb_serial \t*serial = port->serial;\n\tstruct usb_serial_port \t*wport \t= serial->port[1];\n\n\tint room = 0; /* Default: no room */\n\n\tif (test_bit(0, &wport->write_urbs_free))\n\t\troom = wport->bulk_out_size - OMNINET_HEADERLEN;\n\n\tdev_dbg(&port->dev, \"%s - returns %d\\n\", __func__, room);\n\n\treturn room;\n}\n\nstatic void omninet_write_bulk_callback(struct urb *urb)\n{\n/*\tstruct omninet_header\t*header = (struct omninet_header  *)\n\t\t\t\t\t\turb->transfer_buffer; */\n\tstruct usb_serial_port \t*port   =  urb->context;\n\tint status = urb->status;\n\n\tset_bit(0, &port->write_urbs_free);\n\tif (status) {\n\t\tdev_dbg(&port->dev, \"%s - nonzero write bulk status received: %d\\n\",\n\t\t\t__func__, status);\n\t\treturn;\n\t}\n\n\tusb_serial_port_softint(port);\n}\n\n\nstatic void omninet_disconnect(struct usb_serial *serial)\n{\n\tstruct usb_serial_port *wport = serial->port[1];\n\n\tusb_kill_urb(wport->write_urb);\n}\n\nmodule_usb_serial_driver(serial_drivers, id_table);\n\nMODULE_AUTHOR(DRIVER_AUTHOR);\nMODULE_DESCRIPTION(DRIVER_DESC);\nMODULE_LICENSE(\"GPL\");\n"], "filenames": ["drivers/usb/serial/omninet.c"], "buggy_code_start_loc": [145], "buggy_code_end_loc": [151], "fixing_code_start_loc": [144], "fixing_code_end_loc": [144], "type": "CWE-404", "message": "The omninet_open function in drivers/usb/serial/omninet.c in the Linux kernel before 4.10.4 allows local users to cause a denial of service (tty exhaustion) by leveraging reference count mishandling.", "other": {"cve": {"id": "CVE-2017-8925", "sourceIdentifier": "cve@mitre.org", "published": "2017-05-12T21:29:00.237", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The omninet_open function in drivers/usb/serial/omninet.c in the Linux kernel before 4.10.4 allows local users to cause a denial of service (tty exhaustion) by leveraging reference count mishandling."}, {"lang": "es", "value": "La funci\u00f3n omninet_open en drivers/usb/serial/omninet.c en kernel de Linux anterior a 4.10.4 permite a los usuarios locales causar una denegaci\u00f3n de servicio (agotamiento de tty) aprovechando el manejo incorrecto del contador de referencia."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-404"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.10.3", "matchCriteriaId": "6ED8EA80-4953-4664-BF7B-1F35D965EA2A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=30572418b445d85fcfe6c8fe84c947d2606767d8", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "http://www.debian.org/security/2017/dsa-3886", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "http://www.kernel.org/pub/linux/kernel/v4.x/ChangeLog-4.10.4", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "http://www.securityfocus.com/bid/98462", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/torvalds/linux/commit/30572418b445d85fcfe6c8fe84c947d2606767d8", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/30572418b445d85fcfe6c8fe84c947d2606767d8"}}