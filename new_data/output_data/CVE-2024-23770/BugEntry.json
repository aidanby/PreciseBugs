{"buggy_code": ["/* darkhttpd - a simple, single-threaded, static content webserver.\n * https://unix4lyfe.org/darkhttpd/\n * Copyright (c) 2003-2022 Emil Mikulic <emikulic@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the\n * above copyright notice and this permission notice appear in all\n * copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL\n * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE\n * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL\n * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR\n * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\nstatic const char\n    pkgname[]   = \"darkhttpd/1.14.from.git\",\n    copyright[] = \"copyright (c) 2003-2022 Emil Mikulic\";\n\n/* Possible build options: -DDEBUG -DNO_IPV6 */\n\n#ifndef NO_IPV6\n# define HAVE_INET6\n#endif\n\n#ifndef DEBUG\n# define NDEBUG\nstatic const int debug = 0;\n#else\nstatic const int debug = 1;\n#endif\n\n#ifdef __linux\n# define _GNU_SOURCE /* for strsignal() and vasprintf() */\n# define _FILE_OFFSET_BITS 64 /* stat() files bigger than 2GB */\n# include <sys/sendfile.h>\n#endif\n\n#ifdef __sun__\n# include <sys/sendfile.h>\n#endif\n\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/wait.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <assert.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <grp.h>\n#include <limits.h>\n#include <pwd.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <syslog.h>\n#include <time.h>\n#include <unistd.h>\n\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n#  include <sanitizer/msan_interface.h>\n# endif\n#endif\n\n#ifdef __sun__\n# ifndef INADDR_NONE\n#  define INADDR_NONE -1\n# endif\n#endif\n\n#ifndef MAXNAMLEN\n# ifdef NAME_MAX\n#  define MAXNAMLEN NAME_MAX\n# else\n#  define MAXNAMLEN   255\n# endif\n#endif\n\n#if defined(O_EXCL) && !defined(O_EXLOCK)\n# define O_EXLOCK O_EXCL\n#endif\n\n#ifndef __printflike\n# ifdef __GNUC__\n/* [->] borrowed from FreeBSD's src/sys/sys/cdefs.h,v 1.102.2.2.2.1 */\n#  define __printflike(fmtarg, firstvararg) \\\n             __attribute__((__format__(__printf__, fmtarg, firstvararg)))\n/* [<-] */\n# else\n#  define __printflike(fmtarg, firstvararg)\n# endif\n#endif\n\n#if defined(__GNUC__) || defined(__INTEL_COMPILER)\n# define unused __attribute__((__unused__))\n#else\n# define unused\n#endif\n\n/* [->] borrowed from FreeBSD's src/sys/sys/systm.h,v 1.276.2.7.4.1 */\n#ifndef CTASSERT                /* Allow lint to override */\n# define CTASSERT(x)             _CTASSERT(x, __LINE__)\n# define _CTASSERT(x, y)         __CTASSERT(x, y)\n# define __CTASSERT(x, y)        typedef char __assert ## y[(x) ? 1 : -1]\n#endif\n/* [<-] */\n\nCTASSERT(sizeof(unsigned long long) >= sizeof(off_t));\n#define llu(x) ((unsigned long long)(x))\n\n#if defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__linux)\n# include <err.h>\n#else\n/* err - prints \"error: format: strerror(errno)\" to stderr and exit()s with\n * the given code.\n */\nstatic void err(const int code, const char *format, ...) __printflike(2, 3);\nstatic void err(const int code, const char *format, ...) {\n    va_list va;\n\n    va_start(va, format);\n    fprintf(stderr, \"error: \");\n    vfprintf(stderr, format, va);\n    fprintf(stderr, \": %s\\n\", strerror(errno));\n    va_end(va);\n    exit(code);\n}\n\n/* errx - err() without the strerror */\nstatic void errx(const int code, const char *format, ...) __printflike(2, 3);\nstatic void errx(const int code, const char *format, ...) {\n    va_list va;\n\n    va_start(va, format);\n    fprintf(stderr, \"error: \");\n    vfprintf(stderr, format, va);\n    fprintf(stderr, \"\\n\");\n    va_end(va);\n    exit(code);\n}\n\n/* warn - err() without the exit */\nstatic void warn(const char *format, ...) __printflike(1, 2);\nstatic void warn(const char *format, ...) {\n    va_list va;\n\n    va_start(va, format);\n    fprintf(stderr, \"warning: \");\n    vfprintf(stderr, format, va);\n    fprintf(stderr, \": %s\\n\", strerror(errno));\n    va_end(va);\n}\n#endif\n\n/* [->] LIST_* macros taken from FreeBSD's src/sys/sys/queue.h,v 1.56\n * Copyright (c) 1991, 1993\n *      The Regents of the University of California.  All rights reserved.\n *\n * Under a BSD license.\n */\n#define LIST_HEAD(name, type)                                           \\\nstruct name {                                                           \\\n        struct type *lh_first;  /* first element */                     \\\n}\n\n#define LIST_HEAD_INITIALIZER(head)                                     \\\n        { NULL }\n\n#define LIST_ENTRY(type)                                                \\\nstruct {                                                                \\\n        struct type *le_next;   /* next element */                      \\\n        struct type **le_prev;  /* address of previous next element */  \\\n}\n\n#define LIST_FIRST(head)        ((head)->lh_first)\n\n#define LIST_FOREACH_SAFE(var, head, field, tvar)                       \\\n    for ((var) = LIST_FIRST((head));                                    \\\n        (var) && ((tvar) = LIST_NEXT((var), field), 1);                 \\\n        (var) = (tvar))\n\n#define LIST_INSERT_HEAD(head, elm, field) do {                         \\\n        if ((LIST_NEXT((elm), field) = LIST_FIRST((head))) != NULL)     \\\n                LIST_FIRST((head))->field.le_prev = &LIST_NEXT((elm), field);\\\n        LIST_FIRST((head)) = (elm);                                     \\\n        (elm)->field.le_prev = &LIST_FIRST((head));                     \\\n} while (0)\n\n#define LIST_NEXT(elm, field)   ((elm)->field.le_next)\n\n#define LIST_REMOVE(elm, field) do {                                    \\\n        if (LIST_NEXT((elm), field) != NULL)                            \\\n                LIST_NEXT((elm), field)->field.le_prev =                \\\n                    (elm)->field.le_prev;                               \\\n        *(elm)->field.le_prev = LIST_NEXT((elm), field);                \\\n} while (0)\n/* [<-] */\n\nstatic LIST_HEAD(conn_list_head, connection) connlist =\n    LIST_HEAD_INITIALIZER(conn_list_head);\n\nstruct connection {\n    LIST_ENTRY(connection) entries;\n\n    int socket;\n#ifdef HAVE_INET6\n    struct in6_addr client;\n#else\n    in_addr_t client;\n#endif\n    time_t last_active;\n    enum {\n        RECV_REQUEST,   /* receiving request */\n        SEND_HEADER,    /* sending generated header */\n        SEND_REPLY,     /* sending reply */\n        DONE            /* connection closed, need to remove from queue */\n    } state;\n\n    /* char request[request_length+1] is null-terminated */\n    char *request;\n    size_t request_length;\n\n    /* request fields */\n    char *method, *url, *referer, *user_agent, *authorization;\n    off_t range_begin, range_end;\n    off_t range_begin_given, range_end_given;\n\n    char *header;\n    size_t header_length, header_sent;\n    int header_dont_free, header_only, http_code, conn_close;\n\n    enum { REPLY_GENERATED, REPLY_FROMFILE } reply_type;\n    char *reply;\n    int reply_dont_free;\n    int reply_fd;\n    off_t reply_start, reply_length, reply_sent,\n          total_sent; /* header + body = total, for logging */\n};\n\nstruct forward_mapping {\n    const char *host, *target_url; /* These point at argv. */\n};\n\nstatic struct forward_mapping *forward_map = NULL;\nstatic size_t forward_map_size = 0;\nstatic const char *forward_all_url = NULL;\n\nstatic int forward_to_https = 0;\n\nstruct mime_mapping {\n    char *extension, *mimetype;\n};\n\nstatic struct mime_mapping *mime_map = NULL;\nstatic size_t mime_map_size = 0;\nstatic size_t longest_ext = 0;\n\n/* If a connection is idle for timeout_secs or more, it gets closed and\n * removed from the connlist.\n */\nstatic int timeout_secs = 30;\nstatic char *keep_alive_field = NULL;\n\n/* Time is cached in the event loop to avoid making an excessive number of\n * gettimeofday() calls.\n */\nstatic time_t now;\n\n/* To prevent a malformed request from eating up too much memory, die once the\n * request exceeds this many bytes:\n */\n#define MAX_REQUEST_LENGTH 4000\n\n/* Defaults can be overridden on the command-line */\nstatic const char *bindaddr;\nstatic uint16_t bindport = 8080;    /* or 80 if running as root */\nstatic int max_connections = -1;    /* kern.ipc.somaxconn */\nstatic const char *index_name = \"index.html\";\nstatic int no_listing = 0;\n\nstatic int sockin = -1;             /* socket to accept connections from */\n#ifdef HAVE_INET6\nstatic int inet6 = 0;               /* whether the socket uses inet6 */\n#endif\nstatic char *wwwroot = NULL;        /* a path name */\nstatic char *logfile_name = NULL;   /* NULL = no logging */\nstatic FILE *logfile = NULL;\nstatic char *pidfile_name = NULL;   /* NULL = no pidfile */\nstatic int want_chroot = 0, want_daemon = 0, want_accf = 0,\n           want_keepalive = 1, want_server_id = 1;\nstatic char *server_hdr = NULL;\nstatic char *auth_key = NULL;       /* NULL or \"Basic base64_of_password\" */\nstatic char *custom_hdrs = NULL;\nstatic uint64_t num_requests = 0, total_in = 0, total_out = 0;\nstatic int accepting = 1;           /* set to 0 to stop accept()ing */\nstatic int syslog_enabled = 0;\nvolatile int running = 0; /* signal handler sets this to false */\n\n#define INVALID_UID ((uid_t) -1)\n#define INVALID_GID ((gid_t) -1)\n\nstatic uid_t drop_uid = INVALID_UID;\nstatic gid_t drop_gid = INVALID_GID;\n\n/* Default mimetype mappings - make sure this array is NULL terminated. */\nstatic const char *default_extension_map[] = {\n    \"application/json\"     \" json\",\n    \"application/pdf\"      \" pdf\",\n    \"application/wasm\"     \" wasm\",\n    \"application/xml\"      \" xsl xml\",\n    \"application/xml-dtd\"  \" dtd\",\n    \"application/xslt+xml\" \" xslt\",\n    \"application/zip\"      \" zip\",\n    \"audio/flac\"           \" flac\",\n    \"audio/mpeg\"           \" mp2 mp3 mpga\",\n    \"audio/ogg\"            \" ogg opus oga spx\",\n    \"audio/wav\"            \" wav\",\n    \"audio/x-m4a\"          \" m4a\",\n    \"font/woff\"            \" woff\",\n    \"font/woff2\"           \" woff2\",\n    \"image/apng\"           \" apng\",\n    \"image/avif\"           \" avif\",\n    \"image/gif\"            \" gif\",\n    \"image/jpeg\"           \" jpeg jpe jpg\",\n    \"image/png\"            \" png\",\n    \"image/svg+xml\"        \" svg\",\n    \"image/webp\"           \" webp\",\n    \"text/css\"             \" css\",\n    \"text/html\"            \" html htm\",\n    \"text/javascript\"      \" js\",\n    \"text/plain\"           \" txt asc\",\n    \"video/mpeg\"           \" mpeg mpe mpg\",\n    \"video/quicktime\"      \" qt mov\",\n    \"video/webm\"           \" webm\",\n    \"video/x-msvideo\"      \" avi\",\n    \"video/mp4\"            \" mp4 m4v\",\n    NULL\n};\n\nstatic const char octet_stream[] = \"application/octet-stream\";\nstatic const char *default_mimetype = octet_stream;\n\n/* Prototypes. */\nstatic void poll_recv_request(struct connection *conn);\nstatic void poll_send_header(struct connection *conn);\nstatic void poll_send_reply(struct connection *conn);\n\n/* close() that dies on error.  */\nstatic void xclose(const int fd) {\n    if (close(fd) == -1)\n        err(1, \"close()\");\n}\n\n/* malloc that dies if it can't allocate. */\nstatic void *xmalloc(const size_t size) {\n    void *ptr = malloc(size);\n    if (ptr == NULL)\n        errx(1, \"can't allocate %zu bytes\", size);\n    return ptr;\n}\n\n/* realloc() that dies if it can't reallocate. */\nstatic void *xrealloc(void *original, const size_t size) {\n    void *ptr = realloc(original, size);\n    if (ptr == NULL)\n        errx(1, \"can't reallocate %zu bytes\", size);\n    return ptr;\n}\n\n/* strdup() that dies if it can't allocate.\n * Implement this ourselves since regular strdup() isn't C89.\n */\nstatic char *xstrdup(const char *src) {\n    size_t len = strlen(src) + 1;\n    char *dest = xmalloc(len);\n    memcpy(dest, src, len);\n    return dest;\n}\n\n/* vasprintf() that dies if it fails. */\nstatic unsigned int xvasprintf(char **ret, const char *format, va_list ap)\n    __printflike(2,0);\nstatic unsigned int xvasprintf(char **ret, const char *format, va_list ap) {\n    int len = vasprintf(ret, format, ap);\n    if (ret == NULL || len == -1)\n        errx(1, \"out of memory in vasprintf()\");\n    return (unsigned int)len;\n}\n\n/* asprintf() that dies if it fails. */\nstatic unsigned int xasprintf(char **ret, const char *format, ...)\n    __printflike(2,3);\nstatic unsigned int xasprintf(char **ret, const char *format, ...) {\n    va_list va;\n    unsigned int len;\n\n    va_start(va, format);\n    len = xvasprintf(ret, format, va);\n    va_end(va);\n    return len;\n}\n\n/* Append buffer code.  A somewhat efficient string buffer with pool-based\n * reallocation.\n */\n#ifndef APBUF_INIT\n# define APBUF_INIT 4096\n#endif\n#define APBUF_GROW APBUF_INIT\nstruct apbuf {\n    size_t length, pool;\n    char *str;\n};\n\nstatic struct apbuf *make_apbuf(void) {\n    struct apbuf *buf = xmalloc(sizeof(struct apbuf));\n    buf->length = 0;\n    buf->pool = APBUF_INIT;\n    buf->str = xmalloc(buf->pool);\n    return buf;\n}\n\n/* Append s (of length len) to buf. */\nstatic void appendl(struct apbuf *buf, const char *s, const size_t len) {\n    size_t need = buf->length + len;\n    if (buf->pool < need) {\n        /* pool has dried up */\n        while (buf->pool < need)\n            buf->pool += APBUF_GROW;\n        buf->str = xrealloc(buf->str, buf->pool);\n    }\n    memcpy(buf->str + buf->length, s, len);\n    buf->length += len;\n}\n\n#ifdef __GNUC__\n#define append(buf, s) appendl(buf, s, \\\n    (__builtin_constant_p(s) ? sizeof(s)-1 : strlen(s)) )\n#else\nstatic void append(struct apbuf *buf, const char *s) {\n    appendl(buf, s, strlen(s));\n}\n#endif\n\nstatic void appendf(struct apbuf *buf, const char *format, ...)\n    __printflike(2, 3);\nstatic void appendf(struct apbuf *buf, const char *format, ...) {\n    char *tmp;\n    va_list va;\n    size_t len;\n\n    va_start(va, format);\n    len = xvasprintf(&tmp, format, va);\n    va_end(va);\n    appendl(buf, tmp, len);\n    free(tmp);\n}\n\n/* Make the specified socket non-blocking. */\nstatic void nonblock_socket(const int sock) {\n    int flags = fcntl(sock, F_GETFL);\n\n    if (flags == -1)\n        err(1, \"fcntl(F_GETFL)\");\n    flags |= O_NONBLOCK;\n    if (fcntl(sock, F_SETFL, flags) == -1)\n        err(1, \"fcntl() to set O_NONBLOCK\");\n}\n\n/* Split string out of src with range [left:right-1] */\nstatic char *split_string(const char *src,\n        const size_t left, const size_t right) {\n    char *dest;\n    assert(left <= right);\n    assert(left < strlen(src));   /* [left means must be smaller */\n    assert(right <= strlen(src)); /* right) means can be equal or smaller */\n\n    dest = xmalloc(right - left + 1);\n    memcpy(dest, src+left, right-left);\n    dest[right-left] = '\\0';\n    return dest;\n}\n\n/* Resolve /./ and /../ in a URL, in-place.\n * Returns NULL if the URL is invalid/unsafe, or the original buffer if\n * successful.\n */\nstatic char *make_safe_url(char *const url) {\n    char *src = url, *dst;\n    #define ends(c) ((c) == '/' || (c) == '\\0')\n\n    /* URLs not starting with a slash are illegal. */\n    if (*src != '/')\n        return NULL;\n\n    /* Fast case: skip until first double-slash or dot-dir. */\n    for ( ; *src; ++src) {\n        if (*src == '/') {\n            if (src[1] == '/')\n                break;\n            else if (src[1] == '.') {\n                if (ends(src[2]))\n                    break;\n                else if (src[2] == '.' && ends(src[3]))\n                    break;\n            }\n        }\n    }\n\n    /* Copy to dst, while collapsing multi-slashes and handling dot-dirs. */\n    dst = src;\n    while (*src) {\n        if (*src != '/')\n            *dst++ = *src++;\n        else if (*++src == '/')\n            ;\n        else if (*src != '.')\n            *dst++ = '/';\n        else if (ends(src[1]))\n            /* Ignore single-dot component. */\n            ++src;\n        else if (src[1] == '.' && ends(src[2])) {\n            /* Double-dot component. */\n            src += 2;\n            if (dst == url)\n                return NULL; /* Illegal URL */\n            else\n                /* Backtrack to previous slash. */\n                while (*--dst != '/' && dst > url);\n        }\n        else\n            *dst++ = '/';\n    }\n\n    if (dst == url)\n        ++dst;\n    *dst = '\\0';\n    return url;\n    #undef ends\n}\n\nstatic void add_forward_mapping(const char * const host,\n                                const char * const target_url) {\n    forward_map_size++;\n    forward_map = xrealloc(forward_map,\n                           sizeof(*forward_map) * forward_map_size);\n    forward_map[forward_map_size - 1].host = host;\n    forward_map[forward_map_size - 1].target_url = target_url;\n}\n\n/* Associates an extension with a mimetype in the mime_map.  Entries are in\n * unsorted order.  Makes copies of extension and mimetype strings.\n */\nstatic void add_mime_mapping(const char *extension, const char *mimetype) {\n    size_t i;\n    assert(strlen(extension) > 0);\n    assert(strlen(mimetype) > 0);\n\n    /* update longest_ext */\n    i = strlen(extension);\n    if (i > longest_ext)\n        longest_ext = i;\n\n    /* look through list and replace an existing entry if possible */\n    for (i = 0; i < mime_map_size; i++)\n        if (strcmp(mime_map[i].extension, extension) == 0) {\n            free(mime_map[i].mimetype);\n            mime_map[i].mimetype = xstrdup(mimetype);\n            return;\n        }\n\n    /* no replacement - add a new entry */\n    mime_map_size++;\n    mime_map = xrealloc(mime_map,\n        sizeof(struct mime_mapping) * mime_map_size);\n    mime_map[mime_map_size - 1].extension = xstrdup(extension);\n    mime_map[mime_map_size - 1].mimetype = xstrdup(mimetype);\n}\n\n/* qsort() the mime_map.  The map must be sorted before it can be\n * binary-searched.\n */\nstatic int mime_mapping_cmp(const void *a, const void *b) {\n    return strcmp(((const struct mime_mapping *)a)->extension,\n                  ((const struct mime_mapping *)b)->extension);\n}\n\nstatic void sort_mime_map(void) {\n    qsort(mime_map, mime_map_size, sizeof(struct mime_mapping),\n        mime_mapping_cmp);\n}\n\n/* Parses a mime.types line and adds the parsed data to the mime_map. */\nstatic void parse_mimetype_line(const char *line) {\n    unsigned int pad, bound1, lbound, rbound;\n\n    /* parse mimetype */\n    for (pad=0; (line[pad] == ' ') || (line[pad] == '\\t'); pad++)\n        ;\n    if (line[pad] == '\\0' || /* empty line */\n        line[pad] == '#')    /* comment */\n        return;\n\n    for (bound1=pad+1;\n        (line[bound1] != ' ') &&\n        (line[bound1] != '\\t');\n        bound1++) {\n        if (line[bound1] == '\\0')\n            return; /* malformed line */\n    }\n\n    lbound = bound1;\n    for (;;) {\n        char *mimetype, *extension;\n\n        /* find beginning of extension */\n        for (; (line[lbound] == ' ') || (line[lbound] == '\\t'); lbound++)\n            ;\n        if (line[lbound] == '\\0')\n            return; /* end of line */\n\n        /* find end of extension */\n        for (rbound = lbound;\n            line[rbound] != ' ' &&\n            line[rbound] != '\\t' &&\n            line[rbound] != '\\0';\n            rbound++)\n            ;\n\n        mimetype = split_string(line, pad, bound1);\n        extension = split_string(line, lbound, rbound);\n        add_mime_mapping(extension, mimetype);\n        free(mimetype);\n        free(extension);\n\n        if (line[rbound] == '\\0')\n            return; /* end of line */\n        else\n            lbound = rbound + 1;\n    }\n}\n\n/* Adds contents of default_extension_map[] to mime_map list.  The array must\n * be NULL terminated.\n */\nstatic void parse_default_extension_map(void) {\n    size_t i;\n\n    for (i = 0; default_extension_map[i] != NULL; i++)\n        parse_mimetype_line(default_extension_map[i]);\n}\n\n/* read a line from fp, return its contents in a dynamically allocated buffer,\n * not including the line ending.\n *\n * Handles CR, CRLF and LF line endings, as well as NOEOL correctly.  If\n * already at EOF, returns NULL.  Will err() or errx() in case of\n * unexpected file error or running out of memory.\n */\nstatic char *read_line(FILE *fp) {\n    char *buf;\n    long startpos, endpos;\n    size_t linelen, numread;\n    int c;\n\n    startpos = ftell(fp);\n    if (startpos == -1)\n        err(1, \"ftell()\");\n\n    /* find end of line (or file) */\n    linelen = 0;\n    for (;;) {\n        c = fgetc(fp);\n        if ((c == EOF) || (c == (int)'\\n') || (c == (int)'\\r'))\n            break;\n        linelen++;\n    }\n\n    /* return NULL on EOF (and empty line) */\n    if (linelen == 0 && c == EOF)\n        return NULL;\n\n    endpos = ftell(fp);\n    if (endpos == -1)\n        err(1, \"ftell()\");\n\n    /* skip CRLF */\n    if ((c == (int)'\\r') && (fgetc(fp) == (int)'\\n'))\n        endpos++;\n\n    buf = xmalloc(linelen + 1);\n\n    /* rewind file to where the line stared and load the line */\n    if (fseek(fp, startpos, SEEK_SET) == -1)\n        err(1, \"fseek()\");\n    numread = fread(buf, 1, linelen, fp);\n    if (numread != linelen)\n        errx(1, \"fread() %zu bytes, expecting %zu bytes\", numread, linelen);\n\n    /* terminate buffer */\n    buf[linelen] = 0;\n\n    /* advance file pointer over the endline */\n    if (fseek(fp, endpos, SEEK_SET) == -1)\n        err(1, \"fseek()\");\n\n    return buf;\n}\n\n/* ---------------------------------------------------------------------------\n * Adds contents of specified file to mime_map list.\n */\nstatic void parse_extension_map_file(const char *filename) {\n    char *buf;\n    FILE *fp = fopen(filename, \"rb\");\n\n    if (fp == NULL)\n        err(1, \"fopen(\\\"%s\\\")\", filename);\n    while ((buf = read_line(fp)) != NULL) {\n        parse_mimetype_line(buf);\n        free(buf);\n    }\n    fclose(fp);\n}\n\n/* Uses the mime_map to determine a Content-Type: for a requested URL.  This\n * bsearch()es mime_map, so make sure it's sorted first.\n */\nstatic int mime_mapping_cmp_str(const void *a, const void *b) {\n    return strcmp((const char *)a,\n                 ((const struct mime_mapping *)b)->extension);\n}\n\nstatic const char *url_content_type(const char *url) {\n    int period, urllen = (int)strlen(url);\n\n    for (period = urllen - 1;\n         (period > 0) && (url[period] != '.') &&\n         (urllen - period - 1 <= (int)longest_ext);\n         period--)\n            ;\n\n    if ((period >= 0) && (url[period] == '.')) {\n        struct mime_mapping *result =\n            bsearch((url + period + 1), mime_map, mime_map_size,\n                    sizeof(struct mime_mapping), mime_mapping_cmp_str);\n        if (result != NULL) {\n            assert(strcmp(url + period + 1, result->extension) == 0);\n            return result->mimetype;\n        }\n    }\n    /* else no period found in the string */\n    return default_mimetype;\n}\n\nstatic const char *get_address_text(const void *addr) {\n#ifdef HAVE_INET6\n    if (inet6) {\n        static char text_addr[INET6_ADDRSTRLEN];\n        inet_ntop(AF_INET6, (const struct in6_addr *)addr, text_addr,\n                  INET6_ADDRSTRLEN);\n        return text_addr;\n    } else\n#endif\n    {\n        return inet_ntoa(*(const struct in_addr *)addr);\n    }\n}\n\n/* Initialize the sockin global.  This is the socket that we accept\n * connections from.\n */\nstatic void init_sockin(void) {\n    struct sockaddr_in addrin;\n#ifdef HAVE_INET6\n    struct sockaddr_in6 addrin6;\n#endif\n    socklen_t addrin_len;\n    int sockopt;\n\n#ifdef HAVE_INET6\n    if (inet6) {\n        memset(&addrin6, 0, sizeof(addrin6));\n        if (inet_pton(AF_INET6, bindaddr ? bindaddr : \"::\",\n                      &addrin6.sin6_addr) == -1) {\n            errx(1, \"malformed --addr argument\");\n        }\n        sockin = socket(PF_INET6, SOCK_STREAM, 0);\n    } else\n#endif\n    {\n        memset(&addrin, 0, sizeof(addrin));\n        addrin.sin_addr.s_addr = bindaddr ? inet_addr(bindaddr) : INADDR_ANY;\n        if (addrin.sin_addr.s_addr == (in_addr_t)INADDR_NONE)\n            errx(1, \"malformed --addr argument\");\n        sockin = socket(PF_INET, SOCK_STREAM, 0);\n    }\n\n    if (sockin == -1)\n        err(1, \"socket()\");\n\n    /* reuse address */\n    sockopt = 1;\n    if (setsockopt(sockin, SOL_SOCKET, SO_REUSEADDR,\n                   &sockopt, sizeof(sockopt)) == -1)\n        err(1, \"setsockopt(SO_REUSEADDR)\");\n\n    /* disable Nagle since we buffer everything ourselves */\n    sockopt = 1;\n    if (setsockopt(sockin, IPPROTO_TCP, TCP_NODELAY,\n            &sockopt, sizeof(sockopt)) == -1)\n        err(1, \"setsockopt(TCP_NODELAY)\");\n\n#ifdef TORTURE\n    /* torture: cripple the kernel-side send buffer so we can only squeeze out\n     * one byte at a time (this is for debugging)\n     */\n    sockopt = 1;\n    if (setsockopt(sockin, SOL_SOCKET, SO_SNDBUF,\n            &sockopt, sizeof(sockopt)) == -1)\n        err(1, \"setsockopt(SO_SNDBUF)\");\n#endif\n\n    /* bind socket */\n#ifdef HAVE_INET6\n    if (inet6) {\n        addrin6.sin6_family = AF_INET6;\n        addrin6.sin6_port = htons(bindport);\n        if (bind(sockin, (struct sockaddr *)&addrin6,\n                 sizeof(struct sockaddr_in6)) == -1)\n            err(1, \"bind(port %u)\", bindport);\n\n        addrin_len = sizeof(addrin6);\n        if (getsockname(sockin, (struct sockaddr *)&addrin6, &addrin_len) == -1)\n            err(1, \"getsockname()\");\n        printf(\"listening on: http://[%s]:%u/\\n\",\n            get_address_text(&addrin6.sin6_addr), bindport);\n    } else\n#endif\n    {\n        addrin.sin_family = (u_char)PF_INET;\n        addrin.sin_port = htons(bindport);\n        if (bind(sockin, (struct sockaddr *)&addrin,\n                 sizeof(struct sockaddr_in)) == -1)\n            err(1, \"bind(port %u)\", bindport);\n        addrin_len = sizeof(addrin);\n        if (getsockname(sockin, (struct sockaddr *)&addrin, &addrin_len) == -1)\n            err(1, \"getsockname()\");\n        printf(\"listening on: http://%s:%u/\\n\",\n            get_address_text(&addrin.sin_addr), bindport);\n    }\n\n    /* listen on socket */\n    if (listen(sockin, max_connections) == -1)\n        err(1, \"listen()\");\n\n    /* enable acceptfilter (this is only available on FreeBSD) */\n    if (want_accf) {\n#if defined(__FreeBSD__)\n        struct accept_filter_arg filt = {\"httpready\", \"\"};\n        if (setsockopt(sockin, SOL_SOCKET, SO_ACCEPTFILTER,\n                       &filt, sizeof(filt)) == -1)\n            fprintf(stderr, \"cannot enable acceptfilter: %s\\n\",\n                strerror(errno));\n        else\n            printf(\"enabled acceptfilter\\n\");\n#else\n        printf(\"this platform doesn't support acceptfilter\\n\");\n#endif\n    }\n}\n\nstatic void usage(const char *argv0) {\n    printf(\"usage:\\t%s /path/to/wwwroot [flags]\\n\\n\", argv0);\n    printf(\"flags:\\t--port number (default: %u, or 80 if running as root)\\n\"\n    \"\\t\\tSpecifies which port to listen on for connections.\\n\"\n    \"\\t\\tPass 0 to let the system choose any free port for you.\\n\\n\", bindport);\n    printf(\"\\t--addr ip (default: all)\\n\"\n    \"\\t\\tIf multiple interfaces are present, specifies\\n\"\n    \"\\t\\twhich one to bind the listening port to.\\n\\n\");\n    printf(\"\\t--maxconn number (default: system maximum)\\n\"\n    \"\\t\\tSpecifies how many concurrent connections to accept.\\n\\n\");\n    printf(\"\\t--log filename (default: stdout)\\n\"\n    \"\\t\\tSpecifies which file to append the request log to.\\n\\n\");\n    printf(\"\\t--syslog\\n\"\n    \"\\t\\tUse syslog for request log.\\n\\n\");\n    printf(\"\\t--chroot (default: don't chroot)\\n\"\n    \"\\t\\tLocks server into wwwroot directory for added security.\\n\\n\");\n    printf(\"\\t--daemon (default: don't daemonize)\\n\"\n    \"\\t\\tDetach from the controlling terminal and run in the background.\\n\\n\");\n    printf(\"\\t--index filename (default: %s)\\n\"\n    \"\\t\\tDefault file to serve when a directory is requested.\\n\\n\",\n        index_name);\n    printf(\"\\t--no-listing\\n\"\n    \"\\t\\tDo not serve listing if directory is requested.\\n\\n\");\n    printf(\"\\t--mimetypes filename (optional)\\n\"\n    \"\\t\\tParses specified file for extension-MIME associations.\\n\\n\");\n    printf(\"\\t--default-mimetype string (optional, default: %s)\\n\"\n    \"\\t\\tFiles with unknown extensions are served as this mimetype.\\n\\n\",\n        octet_stream);\n    printf(\"\\t--uid uid/uname, --gid gid/gname (default: don't privdrop)\\n\"\n    \"\\t\\tDrops privileges to given uid:gid after initialization.\\n\\n\");\n    printf(\"\\t--pidfile filename (default: no pidfile)\\n\"\n    \"\\t\\tWrite PID to the specified file.  Note that if you are\\n\"\n    \"\\t\\tusing --chroot, then the pidfile must be relative to,\\n\"\n    \"\\t\\tand inside the wwwroot.\\n\\n\");\n    printf(\"\\t--no-keepalive\\n\"\n    \"\\t\\tDisables HTTP Keep-Alive functionality.\\n\\n\");\n#ifdef __FreeBSD__\n    printf(\"\\t--accf (default: don't use acceptfilter)\\n\"\n    \"\\t\\tUse acceptfilter.  Needs the accf_http module loaded.\\n\\n\");\n#endif\n    printf(\"\\t--forward host url (default: don't forward)\\n\"\n    \"\\t\\tWeb forward (301 redirect).\\n\"\n    \"\\t\\tRequests to the host are redirected to the corresponding url.\\n\"\n    \"\\t\\tThe option may be specified multiple times, in which case\\n\"\n    \"\\t\\tthe host is matched in order of appearance.\\n\\n\");\n    printf(\"\\t--forward-all url (default: don't forward)\\n\"\n    \"\\t\\tWeb forward (301 redirect).\\n\"\n    \"\\t\\tAll requests are redirected to the corresponding url.\\n\\n\");\n    printf(\"\\t--no-server-id\\n\"\n    \"\\t\\tDon't identify the server type in headers\\n\"\n    \"\\t\\tor directory listings.\\n\\n\");\n    printf(\"\\t--timeout secs (default: %d)\\n\"\n    \"\\t\\tIf a connection is idle for more than this many seconds,\\n\"\n    \"\\t\\tit will be closed. Set to zero to disable timeouts.\\n\\n\",\n    timeout_secs);\n    printf(\"\\t--auth username:password\\n\"\n    \"\\t\\tEnable basic authentication.\\n\\n\");\n    printf(\"\\t--forward-https\\n\"\n    \"\\t\\tIf the client requested HTTP, forward to HTTPS.\\n\"\n    \"\\t\\tThis is useful if darkhttpd is behind a reverse proxy\\n\"\n    \"\\t\\tthat supports SSL.\\n\\n\");\n    printf(\"\\t--header 'Header: Value'\\n\"\n    \"\\t\\tAdd a custom header to all responses.\\n\"\n    \"\\t\\tThis option can be specified multiple times, in which case\\n\"\n    \"\\t\\tthe headers are added in order of appearance.\\n\\n\");\n#ifdef HAVE_INET6\n    printf(\"\\t--ipv6\\n\"\n    \"\\t\\tListen on IPv6 address.\\n\\n\");\n#else\n    printf(\"\\t(This binary was built without IPv6 support: -DNO_IPV6)\\n\\n\");\n#endif\n}\n\nstatic char *base64_encode(char *str) {\n    const char base64_table[] = {\n        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',\n        'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',\n        'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\n        'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',\n        'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n        'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\n        'w', 'x', 'y', 'z', '0', '1', '2', '3',\n        '4', '5', '6', '7', '8', '9', '+', '/'};\n\n    int input_length = strlen(str);\n    int output_length = 4 * ((input_length + 2) / 3);\n\n    char *encoded_data = malloc(output_length+1);\n    if (encoded_data == NULL) return NULL;\n\n    int i;\n    int j;\n    for (i = 0, j = 0; i < input_length;) {\n        uint32_t octet_a = i < input_length ? (unsigned char)str[i++] : 0;\n        uint32_t octet_b = i < input_length ? (unsigned char)str[i++] : 0;\n        uint32_t octet_c = i < input_length ? (unsigned char)str[i++] : 0;\n\n        uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;\n\n        encoded_data[j++] = base64_table[(triple >> 3 * 6) & 0x3F];\n        encoded_data[j++] = base64_table[(triple >> 2 * 6) & 0x3F];\n        encoded_data[j++] = base64_table[(triple >> 1 * 6) & 0x3F];\n        encoded_data[j++] = base64_table[(triple >> 0 * 6) & 0x3F];\n    }\n\n    const int mod_table[] = {0, 2, 1};\n    for (i = 0; i < mod_table[input_length % 3]; i++)\n        encoded_data[output_length - 1 - i] = '=';\n    encoded_data[output_length] = '\\0';\n\n    return encoded_data;\n}\n\n/* Returns 1 if string is a number, 0 otherwise.  Set num to NULL if\n * disinterested in value.\n */\nstatic int str_to_num(const char *str, long long *num) {\n    char *endptr;\n    long long n;\n\n    errno = 0;\n    n = strtoll(str, &endptr, 10);\n    if (*endptr != '\\0')\n        return 0;\n    if (n == LLONG_MIN && errno == ERANGE)\n        return 0;\n    if (n == LLONG_MAX && errno == ERANGE)\n        return 0;\n    if (num != NULL)\n        *num = n;\n    return 1;\n}\n\n/* Returns a valid number or dies. */\nstatic long long xstr_to_num(const char *str) {\n    long long ret;\n\n    if (!str_to_num(str, &ret)) {\n        errx(1, \"number \\\"%s\\\" is invalid\", str);\n    }\n    return ret;\n}\n\nstatic void parse_commandline(const int argc, char *argv[]) {\n    int i;\n    size_t len;\n\n    if ((argc < 2) || (argc == 2 && strcmp(argv[1], \"--help\") == 0)) {\n        usage(argv[0]); /* no wwwroot given */\n        exit(EXIT_SUCCESS);\n    }\n\n    if (getuid() == 0)\n        bindport = 80;\n\n    custom_hdrs = strdup(\"\");\n\n    wwwroot = xstrdup(argv[1]);\n    /* Strip ending slash. */\n    len = strlen(wwwroot);\n    if (len > 0)\n        if (wwwroot[len - 1] == '/')\n            wwwroot[len - 1] = '\\0';\n\n    /* walk through the remainder of the arguments (if any) */\n    for (i = 2; i < argc; i++) {\n        if (strcmp(argv[i], \"--port\") == 0) {\n            if (++i >= argc)\n                errx(1, \"missing number after --port\");\n            bindport = (uint16_t)xstr_to_num(argv[i]);\n        }\n        else if (strcmp(argv[i], \"--addr\") == 0) {\n            if (++i >= argc)\n                errx(1, \"missing ip after --addr\");\n            bindaddr = argv[i];\n        }\n        else if (strcmp(argv[i], \"--maxconn\") == 0) {\n            if (++i >= argc)\n                errx(1, \"missing number after --maxconn\");\n            max_connections = (int)xstr_to_num(argv[i]);\n        }\n        else if (strcmp(argv[i], \"--log\") == 0) {\n            if (++i >= argc)\n                errx(1, \"missing filename after --log\");\n            logfile_name = argv[i];\n        }\n        else if (strcmp(argv[i], \"--chroot\") == 0) {\n            want_chroot = 1;\n        }\n        else if (strcmp(argv[i], \"--daemon\") == 0) {\n            want_daemon = 1;\n        }\n        else if (strcmp(argv[i], \"--index\") == 0) {\n            if (++i >= argc)\n                errx(1, \"missing filename after --index\");\n            index_name = argv[i];\n        }\n        else if (strcmp(argv[i], \"--no-listing\") == 0) {\n            no_listing = 1;\n        }\n        else if (strcmp(argv[i], \"--mimetypes\") == 0) {\n            if (++i >= argc)\n                errx(1, \"missing filename after --mimetypes\");\n            parse_extension_map_file(argv[i]);\n        }\n        else if (strcmp(argv[i], \"--default-mimetype\") == 0) {\n            if (++i >= argc)\n                errx(1, \"missing string after --default-mimetype\");\n            default_mimetype = argv[i];\n        }\n        else if (strcmp(argv[i], \"--uid\") == 0) {\n            struct passwd *p;\n            if (++i >= argc)\n                errx(1, \"missing uid after --uid\");\n            p = getpwnam(argv[i]);\n            if (!p) {\n                p = getpwuid((uid_t)xstr_to_num(argv[i]));\n            }\n            if (!p)\n                errx(1, \"no such uid: `%s'\", argv[i]);\n            drop_uid = p->pw_uid;\n        }\n        else if (strcmp(argv[i], \"--gid\") == 0) {\n            struct group *g;\n            if (++i >= argc)\n                errx(1, \"missing gid after --gid\");\n            g = getgrnam(argv[i]);\n            if (!g) {\n                g = getgrgid((gid_t)xstr_to_num(argv[i]));\n            }\n            if (!g) {\n                errx(1, \"no such gid: `%s'\", argv[i]);\n            }\n            drop_gid = g->gr_gid;\n        }\n        else if (strcmp(argv[i], \"--pidfile\") == 0) {\n            if (++i >= argc)\n                errx(1, \"missing filename after --pidfile\");\n            pidfile_name = argv[i];\n        }\n        else if (strcmp(argv[i], \"--no-keepalive\") == 0) {\n            want_keepalive = 0;\n        }\n        else if (strcmp(argv[i], \"--accf\") == 0) {\n            want_accf = 1;\n        }\n        else if (strcmp(argv[i], \"--syslog\") == 0) {\n            syslog_enabled = 1;\n        }\n        else if (strcmp(argv[i], \"--forward\") == 0) {\n            const char *host, *url;\n            if (++i >= argc)\n                errx(1, \"missing host after --forward\");\n            host = argv[i];\n            if (++i >= argc)\n                errx(1, \"missing url after --forward\");\n            url = argv[i];\n            add_forward_mapping(host, url);\n        }\n        else if (strcmp(argv[i], \"--forward-all\") == 0) {\n            if (++i >= argc)\n                errx(1, \"missing url after --forward-all\");\n            forward_all_url = argv[i];\n        }\n        else if (strcmp(argv[i], \"--no-server-id\") == 0) {\n            want_server_id = 0;\n        }\n        else if (strcmp(argv[i], \"--timeout\") == 0) {\n            if (++i >= argc)\n                errx(1, \"missing number after --timeout\");\n            timeout_secs = (int)xstr_to_num(argv[i]);\n        }\n        else if (strcmp(argv[i], \"--auth\") == 0) {\n            if (++i >= argc || strchr(argv[i], ':') == NULL)\n                errx(1, \"missing 'user:pass' after --auth\");\n\n            char *key = base64_encode(argv[i]);\n            xasprintf(&auth_key, \"Basic %s\", key);\n            free(key);\n        }\n        else if (strcmp(argv[i], \"--forward-https\") == 0) {\n            forward_to_https = 1;\n        }\n        else if (strcmp(argv[i], \"--header\") == 0) {\n            if (++i >= argc)\n                errx(1, \"missing argument after --header\");\n            if (strchr(argv[i], '\\n') != NULL || strstr(argv[i], \": \") == NULL)\n                errx(1, \"malformed argument after --header\");\n            char *old_custom_hdrs = custom_hdrs;\n            xasprintf(&custom_hdrs, \"%s%s\\r\\n\", old_custom_hdrs, argv[i]);\n            free(old_custom_hdrs);\n        }\n#ifdef HAVE_INET6\n        else if (strcmp(argv[i], \"--ipv6\") == 0) {\n            inet6 = 1;\n        }\n#endif\n        else\n            errx(1, \"unknown argument `%s'\", argv[i]);\n    }\n}\n\n/* Allocate and initialize an empty connection. */\nstatic struct connection *new_connection(void) {\n    struct connection *conn = xmalloc(sizeof(struct connection));\n\n    conn->socket = -1;\n    memset(&conn->client, 0, sizeof(conn->client));\n    conn->last_active = now;\n    conn->request = NULL;\n    conn->request_length = 0;\n    conn->method = NULL;\n    conn->url = NULL;\n    conn->referer = NULL;\n    conn->user_agent = NULL;\n    conn->authorization = NULL;\n    conn->range_begin = 0;\n    conn->range_end = 0;\n    conn->range_begin_given = 0;\n    conn->range_end_given = 0;\n    conn->header = NULL;\n    conn->header_length = 0;\n    conn->header_sent = 0;\n    conn->header_dont_free = 0;\n    conn->header_only = 0;\n    conn->http_code = 0;\n    conn->conn_close = 1;\n    conn->reply = NULL;\n    conn->reply_dont_free = 0;\n    conn->reply_fd = -1;\n    conn->reply_start = 0;\n    conn->reply_length = 0;\n    conn->reply_sent = 0;\n    conn->total_sent = 0;\n\n    /* Make it harmless so it gets garbage-collected if it should, for some\n     * reason, fail to be correctly filled out.\n     */\n    conn->state = DONE;\n\n    return conn;\n}\n\n/* Accept a connection from sockin and add it to the connection queue. */\nstatic void accept_connection(void) {\n    struct sockaddr_in addrin;\n#ifdef HAVE_INET6\n    struct sockaddr_in6 addrin6;\n#endif\n    socklen_t sin_size;\n    struct connection *conn;\n    int fd;\n\n#ifdef HAVE_INET6\n    if (inet6) {\n        sin_size = sizeof(addrin6);\n        memset(&addrin6, 0, sin_size);\n        fd = accept(sockin, (struct sockaddr *)&addrin6, &sin_size);\n    } else\n#endif\n    {\n        sin_size = sizeof(addrin);\n        memset(&addrin, 0, sin_size);\n        fd = accept(sockin, (struct sockaddr *)&addrin, &sin_size);\n    }\n\n    if (fd == -1) {\n        /* Failed to accept, but try to keep serving existing connections. */\n        if (errno == EMFILE || errno == ENFILE) accepting = 0;\n        warn(\"accept()\");\n        return;\n    }\n\n    /* Allocate and initialize struct connection. */\n    conn = new_connection();\n    conn->socket = fd;\n    nonblock_socket(conn->socket);\n    conn->state = RECV_REQUEST;\n\n#ifdef HAVE_INET6\n    if (inet6) {\n        conn->client = addrin6.sin6_addr;\n    } else\n#endif\n    {\n        *(in_addr_t *)&conn->client = addrin.sin_addr.s_addr;\n    }\n    LIST_INSERT_HEAD(&connlist, conn, entries);\n\n    if (debug)\n        printf(\"accepted connection from %s:%u (fd %d)\\n\",\n               inet_ntoa(addrin.sin_addr),\n               ntohs(addrin.sin_port),\n               conn->socket);\n\n    /* Try to read straight away rather than going through another iteration\n     * of the select() loop.\n     */\n    poll_recv_request(conn);\n}\n\n/* Should this character be logencoded?\n */\nstatic int needs_logencoding(const unsigned char c) {\n    return ((c <= 0x1F) || (c >= 0x7F) || (c == '\"'));\n}\n\n/* Encode string for logging.\n */\nstatic void logencode(const char *src, char *dest) {\n    static const char hex[] = \"0123456789ABCDEF\";\n    int i, j;\n\n    for (i = j = 0; src[i] != '\\0'; i++) {\n        if (needs_logencoding((unsigned char)src[i])) {\n            dest[j++] = '%';\n            dest[j++] = hex[(src[i] >> 4) & 0xF];\n            dest[j++] = hex[ src[i]       & 0xF];\n        }\n        else\n            dest[j++] = src[i];\n    }\n    dest[j] = '\\0';\n}\n\n/* Format [when] as a CLF date format, stored in the specified buffer.  The same\n * buffer is returned for convenience.\n */\n#define CLF_DATE_LEN 29 /* strlen(\"[10/Oct/2000:13:55:36 -0700]\")+1 */\nstatic char *clf_date(char *dest, const time_t when) {\n    time_t when_copy = when;\n    if (strftime(dest, CLF_DATE_LEN,\n                 \"[%d/%b/%Y:%H:%M:%S %z]\", localtime(&when_copy)) == 0) {\n        dest[0] = 0;\n    }\n    return dest;\n}\n\n/* Add a connection's details to the logfile. */\nstatic void log_connection(const struct connection *conn) {\n    char *safe_method, *safe_url, *safe_referer, *safe_user_agent,\n    dest[CLF_DATE_LEN];\n\n    if (logfile == NULL)\n        return;\n    if (conn->http_code == 0)\n        return; /* invalid - died in request */\n    if (conn->method == NULL)\n        return; /* invalid - didn't parse - maybe too long */\n\n#define make_safe(x) do { \\\n    if (conn->x) { \\\n        safe_##x = xmalloc(strlen(conn->x)*3 + 1); \\\n        logencode(conn->x, safe_##x); \\\n    } else { \\\n        safe_##x = NULL; \\\n    } \\\n} while(0)\n\n    make_safe(method);\n    make_safe(url);\n    make_safe(referer);\n    make_safe(user_agent);\n\n#define use_safe(x) safe_##x ? safe_##x : \"\"\n  if (syslog_enabled) {\n    syslog(LOG_INFO, \"%s - - %s \\\"%s %s HTTP/1.1\\\" %d %llu \\\"%s\\\" \\\"%s\\\"\\n\",\n        get_address_text(&conn->client),\n        clf_date(dest, now),\n        use_safe(method),\n        use_safe(url),\n        conn->http_code,\n        llu(conn->total_sent),\n        use_safe(referer),\n        use_safe(user_agent)\n        );\n  } else {\n    fprintf(logfile, \"%s - - %s \\\"%s %s HTTP/1.1\\\" %d %llu \\\"%s\\\" \\\"%s\\\"\\n\",\n        get_address_text(&conn->client),\n        clf_date(dest, now),\n        use_safe(method),\n        use_safe(url),\n        conn->http_code,\n        llu(conn->total_sent),\n        use_safe(referer),\n        use_safe(user_agent)\n        );\n    fflush(logfile);\n  }\n#define free_safe(x) if (safe_##x) free(safe_##x)\n\n    free_safe(method);\n    free_safe(url);\n    free_safe(referer);\n    free_safe(user_agent);\n\n#undef make_safe\n#undef use_safe\n#undef free_safe\n}\n\n/* Log a connection, then cleanly deallocate its internals. */\nstatic void free_connection(struct connection *conn) {\n    if (debug) printf(\"free_connection(%d)\\n\", conn->socket);\n    log_connection(conn);\n    if (conn->socket != -1) xclose(conn->socket);\n    if (conn->request != NULL) free(conn->request);\n    if (conn->method != NULL) free(conn->method);\n    if (conn->url != NULL) free(conn->url);\n    if (conn->referer != NULL) free(conn->referer);\n    if (conn->user_agent != NULL) free(conn->user_agent);\n    if (conn->authorization != NULL) free(conn->authorization);\n    if (conn->header != NULL && !conn->header_dont_free) free(conn->header);\n    if (conn->reply != NULL && !conn->reply_dont_free) free(conn->reply);\n    if (conn->reply_fd != -1) xclose(conn->reply_fd);\n    /* If we ran out of sockets, try to resume accepting. */\n    accepting = 1;\n}\n\n/* Recycle a finished connection for HTTP/1.1 Keep-Alive. */\nstatic void recycle_connection(struct connection *conn) {\n    int socket_tmp = conn->socket;\n    if (debug)\n        printf(\"recycle_connection(%d)\\n\", socket_tmp);\n    conn->socket = -1; /* so free_connection() doesn't close it */\n    free_connection(conn);\n    conn->socket = socket_tmp;\n\n    /* don't reset conn->client */\n    conn->request = NULL;\n    conn->request_length = 0;\n    conn->method = NULL;\n    conn->url = NULL;\n    conn->referer = NULL;\n    conn->user_agent = NULL;\n    conn->authorization = NULL;\n    conn->range_begin = 0;\n    conn->range_end = 0;\n    conn->range_begin_given = 0;\n    conn->range_end_given = 0;\n    conn->header = NULL;\n    conn->header_length = 0;\n    conn->header_sent = 0;\n    conn->header_dont_free = 0;\n    conn->header_only = 0;\n    conn->http_code = 0;\n    conn->conn_close = 1;\n    conn->reply = NULL;\n    conn->reply_dont_free = 0;\n    conn->reply_fd = -1;\n    conn->reply_start = 0;\n    conn->reply_length = 0;\n    conn->reply_sent = 0;\n    conn->total_sent = 0;\n\n    conn->state = RECV_REQUEST; /* ready for another */\n}\n\n/* Uppercasify all characters in a string of given length. */\nstatic void strntoupper(char *str, const size_t length) {\n    size_t i;\n\n    for (i = 0; i < length; i++)\n        str[i] = (char)toupper(str[i]);\n}\n\n/* If a connection has been idle for more than timeout_secs, it will be\n * marked as DONE and killed off in httpd_poll().\n */\nstatic void poll_check_timeout(struct connection *conn) {\n    if (timeout_secs > 0) {\n        if (now - conn->last_active >= timeout_secs) {\n            if (debug)\n                printf(\"poll_check_timeout(%d) closing connection\\n\",\n                       conn->socket);\n            conn->conn_close = 1;\n            conn->state = DONE;\n        }\n    }\n}\n\n/* Format [when] as an RFC1123 date, stored in the specified buffer.  The same\n * buffer is returned for convenience.\n */\n#define DATE_LEN 30 /* strlen(\"Fri, 28 Feb 2003 00:02:08 GMT\")+1 */\nstatic char *rfc1123_date(char *dest, const time_t when) {\n    time_t when_copy = when;\n    if (strftime(dest, DATE_LEN,\n                 \"%a, %d %b %Y %H:%M:%S GMT\", gmtime(&when_copy)) == 0) {\n        dest[0] = 0;\n    }\n    return dest;\n}\n\n/* Decode URL by converting %XX (where XX are hexadecimal digits) to the\n * character it represents.  Don't forget to free the return value.\n */\nstatic char *urldecode(const char *url) {\n    size_t i, pos, len = strlen(url);\n    char *out = xmalloc(len+1);\n\n    for (i = 0, pos = 0; i < len; i++) {\n        if ((url[i] == '%') && (i+2 < len) &&\n            isxdigit(url[i+1]) && isxdigit(url[i+2])) {\n            /* decode %XX */\n#define HEX_TO_DIGIT(hex) ( \\\n    ((hex) >= 'A' && (hex) <= 'F') ? ((hex)-'A'+10): \\\n    ((hex) >= 'a' && (hex) <= 'f') ? ((hex)-'a'+10): \\\n    ((hex)-'0') )\n\n            out[pos++] = HEX_TO_DIGIT(url[i+1]) * 16 +\n                         HEX_TO_DIGIT(url[i+2]);\n            i += 2;\n#undef HEX_TO_DIGIT\n        } else {\n            /* straight copy */\n            out[pos++] = url[i];\n        }\n    }\n    out[pos] = '\\0';\n    return out;\n}\n\n/* Returns Connection or Keep-Alive header, depending on conn_close. */\nstatic const char *keep_alive(const struct connection *conn)\n{\n    return (conn->conn_close ? \"Connection: close\\r\\n\" : keep_alive_field);\n}\n\n/* \"Generated by \" + pkgname + \" on \" + date + \"\\n\"\n *  1234567890123               1234            2 ('\\n' and '\\0')\n */\nstatic char _generated_on_buf[13 + sizeof(pkgname) - 1 + 4 + DATE_LEN + 2];\nstatic const char *generated_on(const char date[DATE_LEN]) {\n    if (!want_server_id)\n        return \"\";\n    snprintf(_generated_on_buf, sizeof(_generated_on_buf),\n            \"Generated by %s on %s\\n\",\n            pkgname, date);\n    return _generated_on_buf;\n}\n\n/* A default reply for any (erroneous) occasion. */\nstatic void default_reply(struct connection *conn,\n        const int errcode, const char *errname, const char *format, ...)\n        __printflike(4, 5);\nstatic void default_reply(struct connection *conn,\n        const int errcode, const char *errname, const char *format, ...) {\n    char *reason, date[DATE_LEN];\n    va_list va;\n\n    va_start(va, format);\n    xvasprintf(&reason, format, va);\n    va_end(va);\n\n    /* Only really need to calculate the date once. */\n    rfc1123_date(date, now);\n\n    conn->reply_length = xasprintf(&(conn->reply),\n     \"<html><head><title>%d %s</title></head><body>\\n\"\n     \"<h1>%s</h1>\\n\" /* errname */\n     \"%s\\n\" /* reason */\n     \"<hr>\\n\"\n     \"%s\" /* generated on */\n     \"</body></html>\\n\",\n     errcode, errname, errname, reason, generated_on(date));\n    free(reason);\n\n    const char auth_header[] =\n        \"WWW-Authenticate: Basic realm=\\\"User Visible Realm\\\"\\r\\n\";\n\n    conn->header_length = xasprintf(&(conn->header),\n     \"HTTP/1.1 %d %s\\r\\n\"\n     \"Date: %s\\r\\n\"\n     \"%s\" /* server */\n     \"Accept-Ranges: bytes\\r\\n\"\n     \"%s\" /* keep-alive */\n     \"%s\" /* custom headers */\n     \"Content-Length: %llu\\r\\n\"\n     \"Content-Type: text/html; charset=UTF-8\\r\\n\"\n     \"%s\"\n     \"\\r\\n\",\n     errcode, errname, date, server_hdr, keep_alive(conn),\n     custom_hdrs, llu(conn->reply_length),\n     (auth_key != NULL ? auth_header : \"\"));\n\n    conn->reply_type = REPLY_GENERATED;\n    conn->http_code = errcode;\n\n    /* Reset reply_start in case the request set a range. */\n    conn->reply_start = 0;\n}\n\nstatic void redirect(struct connection *conn, const char *format, ...)\n    __printflike(2, 3);\nstatic void redirect(struct connection *conn, const char *format, ...) {\n    char *where, date[DATE_LEN];\n    va_list va;\n\n    va_start(va, format);\n    xvasprintf(&where, format, va);\n    va_end(va);\n\n    /* Only really need to calculate the date once. */\n    rfc1123_date(date, now);\n\n    conn->reply_length = xasprintf(&(conn->reply),\n     \"<html><head><title>301 Moved Permanently</title></head><body>\\n\"\n     \"<h1>Moved Permanently</h1>\\n\"\n     \"Moved to: <a href=\\\"%s\\\">%s</a>\\n\" /* where x 2 */\n     \"<hr>\\n\"\n     \"%s\" /* generated on */\n     \"</body></html>\\n\",\n     where, where, generated_on(date));\n\n    conn->header_length = xasprintf(&(conn->header),\n     \"HTTP/1.1 301 Moved Permanently\\r\\n\"\n     \"Date: %s\\r\\n\"\n     \"%s\" /* server */\n     /* \"Accept-Ranges: bytes\\r\\n\" - not relevant here */\n     \"Location: %s\\r\\n\"\n     \"%s\" /* keep-alive */\n     \"%s\" /* custom headers */\n     \"Content-Length: %llu\\r\\n\"\n     \"Content-Type: text/html; charset=UTF-8\\r\\n\"\n     \"\\r\\n\",\n     date, server_hdr, where, keep_alive(conn),\n     custom_hdrs, llu(conn->reply_length));\n\n    free(where);\n    conn->reply_type = REPLY_GENERATED;\n    conn->http_code = 301;\n}\n\n/* Parses a single HTTP request field.  Returns string from end of [field] to\n * first \\r, \\n or end of request string.  Returns NULL if [field] can't be\n * matched.  Case insensitive.\n *\n * You need to remember to deallocate the result.\n * example: parse_field(conn, \"Referer: \");\n */\nstatic char *parse_field(const struct connection *conn, const char *field) {\n    size_t bound1, bound2;\n    char *pos;\n\n    /* find start */\n    pos = strcasestr(conn->request, field);\n    if (pos == NULL)\n        return NULL;\n    assert(pos >= conn->request);\n    bound1 = (size_t)(pos - conn->request) + strlen(field);\n\n    /* find end */\n    for (bound2 = bound1;\n         ((bound2 < conn->request_length) &&\n          (conn->request[bound2] != '\\r') &&\n          (conn->request[bound2] != '\\n'));\n         bound2++)\n            ;\n\n    /* copy to buffer */\n    return split_string(conn->request, bound1, bound2);\n}\n\nstatic void redirect_https(struct connection *conn) {\n    char *host, *url;\n\n    /* work out path of file being requested */\n    url = urldecode(conn->url);\n\n    /* make sure it's safe */\n    if (make_safe_url(url) == NULL) {\n        default_reply(conn, 400, \"Bad Request\",\n                      \"You requested an invalid URL.\");\n        free(url);\n        return;\n    }\n\n    host = parse_field(conn, \"Host: \");\n    if (host == NULL) {\n        default_reply(conn, 400, \"Bad Request\",\n                \"Missing 'Host' header.\");\n        free(url);\n        return;\n    }\n\n    redirect(conn, \"https://%s%s\", host, url);\n    free(host);\n    free(url);\n}\n\nstatic int is_https_redirect(struct connection *conn) {\n    char *proto = NULL;\n\n    if (forward_to_https == 0)\n        return 0; /* --forward-https was never used */\n\n    proto = parse_field(conn, \"X-Forwarded-Proto: \");\n    if (proto == NULL || strcasecmp(proto, \"https\") == 0) {\n        free(proto);\n        return 0;\n    }\n\n    free(proto);\n    return 1;\n}\n\n/* Parse a Range: field into range_begin and range_end.  Only handles the\n * first range if a list is given.  Sets range_{begin,end}_given to 1 if\n * either part of the range is given.\n */\nstatic void parse_range_field(struct connection *conn) {\n    char *range;\n\n    range = parse_field(conn, \"Range: bytes=\");\n    if (range == NULL)\n        return;\n\n    do {\n        size_t bound1, bound2, len;\n        len = strlen(range);\n\n        /* parse number up to hyphen */\n        bound1 = 0;\n        for (bound2=0;\n            (bound2 < len) && isdigit((int)range[bound2]);\n            bound2++)\n                ;\n\n        if ((bound2 == len) || (range[bound2] != '-'))\n            break; /* there must be a hyphen here */\n\n        if (bound1 != bound2) {\n            conn->range_begin_given = 1;\n            conn->range_begin = (off_t)strtoll(range+bound1, NULL, 10);\n        }\n\n        /* parse number after hyphen */\n        bound2++;\n        for (bound1=bound2;\n            (bound2 < len) && isdigit((int)range[bound2]);\n            bound2++)\n                ;\n\n        if ((bound2 != len) && (range[bound2] != ','))\n            break; /* must be end of string or a list to be valid */\n\n        if (bound1 != bound2) {\n            conn->range_end_given = 1;\n            conn->range_end = (off_t)strtoll(range+bound1, NULL, 10);\n        }\n    } while(0);\n    free(range);\n}\n\n/* Parse an HTTP request like \"GET / HTTP/1.1\" to get the method (GET), the\n * url (/), the referer (if given) and the user-agent (if given).  Remember to\n * deallocate all these buffers.  The method will be returned in uppercase.\n */\nstatic int parse_request(struct connection *conn) {\n    size_t bound1, bound2;\n    char *tmp;\n    assert(conn->request_length == strlen(conn->request));\n\n    /* parse method */\n    for (bound1 = 0;\n        (bound1 < conn->request_length) &&\n        (conn->request[bound1] != ' ');\n        bound1++)\n            ;\n\n    conn->method = split_string(conn->request, 0, bound1);\n    strntoupper(conn->method, bound1);\n\n    /* parse url */\n    for (;\n        (bound1 < conn->request_length) &&\n        (conn->request[bound1] == ' ');\n        bound1++)\n            ;\n\n    if (bound1 == conn->request_length)\n        return 0; /* fail */\n\n    for (bound2 = bound1 + 1;\n        (bound2 < conn->request_length) &&\n        (conn->request[bound2] != ' ') &&\n        (conn->request[bound2] != '\\r') &&\n        (conn->request[bound2] != '\\n');\n        bound2++)\n            ;\n\n    conn->url = split_string(conn->request, bound1, bound2);\n\n    /* parse protocol to determine conn_close */\n    if (conn->request[bound2] == ' ') {\n        char *proto;\n        for (bound1 = bound2;\n            (bound1 < conn->request_length) &&\n            (conn->request[bound1] == ' ');\n            bound1++)\n                ;\n\n        for (bound2 = bound1 + 1;\n            (bound2 < conn->request_length) &&\n            (conn->request[bound2] != ' ') &&\n            (conn->request[bound2] != '\\r');\n            bound2++)\n                ;\n\n        proto = split_string(conn->request, bound1, bound2);\n        if (strcasecmp(proto, \"HTTP/1.1\") == 0)\n            conn->conn_close = 0;\n        free(proto);\n    }\n\n    /* parse connection field */\n    tmp = parse_field(conn, \"Connection: \");\n    if (tmp != NULL) {\n        if (strcasecmp(tmp, \"close\") == 0)\n            conn->conn_close = 1;\n        else if (strcasecmp(tmp, \"keep-alive\") == 0)\n            conn->conn_close = 0;\n        free(tmp);\n    }\n\n    /* cmdline flag can be used to deny keep-alive */\n    if (!want_keepalive)\n        conn->conn_close = 1;\n\n    /* parse important fields */\n    conn->referer = parse_field(conn, \"Referer: \");\n    conn->user_agent = parse_field(conn, \"User-Agent: \");\n    conn->authorization = parse_field(conn, \"Authorization: \");\n    parse_range_field(conn);\n    return 1;\n}\n\nstatic int file_exists(const char *path) {\n    struct stat filestat;\n    if ((stat(path, &filestat) == -1) && (errno == ENOENT))\n        return 0;\n    else\n        return 1;\n}\n\nstruct dlent {\n    char *name;\n    int is_dir;\n    off_t size;\n};\n\nstatic int dlent_cmp(const void *a, const void *b) {\n    if (strcmp((*((const struct dlent * const *)a))->name, \"..\") == 0) {\n        return -1;  /* Special-case \"..\" to come first. */\n    }\n    return strcmp((*((const struct dlent * const *)a))->name,\n                  (*((const struct dlent * const *)b))->name);\n}\n\n/* Make sorted list of files in a directory.  Returns number of entries, or -1\n * if error occurs.\n */\nstatic ssize_t make_sorted_dirlist(const char *path, struct dlent ***output) {\n    DIR *dir;\n    struct dirent *ent;\n    size_t entries = 0;\n    size_t pool = 128;\n    char *currname;\n    struct dlent **list = NULL;\n\n    dir = opendir(path);\n    if (dir == NULL)\n        return -1;\n\n    currname = xmalloc(strlen(path) + MAXNAMLEN + 1);\n    list = xmalloc(sizeof(struct dlent*) * pool);\n\n    /* construct list */\n    while ((ent = readdir(dir)) != NULL) {\n        struct stat s;\n\n        if (strcmp(ent->d_name, \".\") == 0)\n            continue; /* skip \".\" */\n        assert(strlen(ent->d_name) <= MAXNAMLEN);\n        sprintf(currname, \"%s%s\", path, ent->d_name);\n        if (stat(currname, &s) == -1)\n            continue; /* skip un-stat-able files */\n        if (entries == pool) {\n            pool *= 2;\n            list = xrealloc(list, sizeof(struct dlent*) * pool);\n        }\n        list[entries] = xmalloc(sizeof(struct dlent));\n        list[entries]->name = xstrdup(ent->d_name);\n        list[entries]->is_dir = S_ISDIR(s.st_mode);\n        list[entries]->size = s.st_size;\n        entries++;\n    }\n    closedir(dir);\n    free(currname);\n    qsort(list, entries, sizeof(struct dlent*), dlent_cmp);\n    *output = list;\n    return (ssize_t)entries;\n}\n\n/* Cleanly deallocate a sorted list of directory files. */\nstatic void cleanup_sorted_dirlist(struct dlent **list, const ssize_t size) {\n    ssize_t i;\n\n    for (i = 0; i < size; i++) {\n        free(list[i]->name);\n        free(list[i]);\n    }\n}\n\n/* Is this an unreserved character according to\n * https://tools.ietf.org/html/rfc3986#section-2.3\n */\nstatic int is_unreserved(const unsigned char c) {\n    if (c >= 'a' && c <= 'z') return 1;\n    if (c >= 'A' && c <= 'Z') return 1;\n    if (c >= '0' && c <= '9') return 1;\n    switch (c) {\n        case '-':\n        case '.':\n        case '_':\n        case '~':\n            return 1;\n    }\n    return 0;\n}\n\n/* Encode string to be an RFC3986-compliant URL part.\n * Contributed by nf.\n */\nstatic void urlencode(const char *src, char *dest) {\n    static const char hex[] = \"0123456789ABCDEF\";\n    int i, j;\n\n    for (i = j = 0; src[i] != '\\0'; i++) {\n        if (!is_unreserved((unsigned char)src[i])) {\n            dest[j++] = '%';\n            dest[j++] = hex[(src[i] >> 4) & 0xF];\n            dest[j++] = hex[ src[i]       & 0xF];\n        }\n        else\n            dest[j++] = src[i];\n    }\n    dest[j] = '\\0';\n}\n\n/* Escape < > & ' \" into HTML entities. */\nstatic void append_escaped(struct apbuf *dst, const char *src) {\n    int pos = 0;\n    while (src[pos] != '\\0') {\n        switch (src[pos]) {\n            case '<':\n                append(dst, \"&lt;\");\n                break;\n            case '>':\n                append(dst, \"&gt;\");\n                break;\n            case '&':\n                append(dst, \"&amp;\");\n                break;\n            case '\\'':\n                append(dst, \"&apos;\");\n                break;\n            case '\"':\n                append(dst, \"&quot;\");\n                break;\n            default:\n                appendl(dst, src+pos, 1);\n        }\n        pos++;\n    }\n}\n\nstatic void generate_dir_listing(struct connection *conn, const char *path,\n        const char *decoded_url) {\n    char date[DATE_LEN], *spaces;\n    struct dlent **list;\n    ssize_t listsize;\n    size_t maxlen = 2; /* There has to be \"..\" */\n    int i;\n    struct apbuf *listing;\n\n    listsize = make_sorted_dirlist(path, &list);\n    if (listsize == -1) {\n        default_reply(conn, 500, \"Internal Server Error\",\n                      \"Couldn't list directory: %s\", strerror(errno));\n        return;\n    }\n\n    for (i=0; i<listsize; i++) {\n        size_t tmp = strlen(list[i]->name);\n        if (maxlen < tmp)\n            maxlen = tmp;\n    }\n\n    listing = make_apbuf();\n    append(listing, \"<html>\\n<head>\\n<title>\");\n    append_escaped(listing, decoded_url);\n    append(listing,\n            \"</title>\\n\"\n            \"<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1\\\">\\n\"\n            \"</head>\\n<body>\\n<h1>\");\n    append_escaped(listing, decoded_url);\n    append(listing, \"</h1>\\n<tt><pre>\\n\");\n\n    spaces = xmalloc(maxlen);\n    memset(spaces, ' ', maxlen);\n\n    for (i=0; i<listsize; i++) {\n        /* If a filename is made up of entirely unsafe chars,\n         * the url would be three times its original length.\n         */\n        char safe_url[MAXNAMLEN*3 + 1];\n\n        urlencode(list[i]->name, safe_url);\n\n        append(listing, \"<a href=\\\"\");\n        append(listing, safe_url);\n        if (list[i]->is_dir)\n            append(listing, \"/\");\n        append(listing, \"\\\">\");\n        append_escaped(listing, list[i]->name);\n        append(listing, \"</a>\");\n\n        if (list[i]->is_dir)\n            append(listing, \"/\\n\");\n        else {\n            appendl(listing, spaces, maxlen-strlen(list[i]->name));\n            appendf(listing, \"%10llu\\n\", llu(list[i]->size));\n        }\n    }\n\n    cleanup_sorted_dirlist(list, listsize);\n    free(list);\n    free(spaces);\n\n    append(listing,\n     \"</pre></tt>\\n\"\n     \"<hr>\\n\");\n\n    rfc1123_date(date, now);\n    append(listing, generated_on(date));\n    append(listing, \"</body>\\n</html>\\n\");\n\n    conn->reply = listing->str;\n    conn->reply_length = (off_t)listing->length;\n    free(listing); /* don't free inside of listing */\n\n    conn->header_length = xasprintf(&(conn->header),\n     \"HTTP/1.1 200 OK\\r\\n\"\n     \"Date: %s\\r\\n\"\n     \"%s\" /* server */\n     \"Accept-Ranges: bytes\\r\\n\"\n     \"%s\" /* keep-alive */\n     \"%s\" /* custom headers */\n     \"Content-Length: %llu\\r\\n\"\n     \"Content-Type: text/html; charset=UTF-8\\r\\n\"\n     \"\\r\\n\",\n     date, server_hdr, keep_alive(conn), custom_hdrs,\n     llu(conn->reply_length));\n\n    conn->reply_type = REPLY_GENERATED;\n    conn->http_code = 200;\n}\n\n/* Process a GET/HEAD request. */\nstatic void process_get(struct connection *conn) {\n    char *decoded_url, *end, *target, *if_mod_since;\n    char date[DATE_LEN], lastmod[DATE_LEN];\n    const char *mimetype = NULL;\n    const char *forward_to = NULL;\n    struct stat filestat;\n\n    /* strip out query params */\n    if ((end = strchr(conn->url, '?')) != NULL)\n        *end = '\\0';\n\n    /* work out path of file being requested */\n    decoded_url = urldecode(conn->url);\n\n    /* make sure it's safe */\n    if (make_safe_url(decoded_url) == NULL) {\n        default_reply(conn, 400, \"Bad Request\",\n                      \"You requested an invalid URL.\");\n        free(decoded_url);\n        return;\n    }\n\n    /* test the host against web forward options */\n    if (forward_map) {\n        char *host = parse_field(conn, \"Host: \");\n        if (host) {\n            size_t i;\n            if (debug)\n                printf(\"host=\\\"%s\\\"\\n\", host);\n            for (i = 0; i < forward_map_size; i++) {\n                if (strcasecmp(forward_map[i].host, host) == 0) {\n                    forward_to = forward_map[i].target_url;\n                    break;\n                }\n            }\n            free(host);\n        }\n    }\n    if (!forward_to) {\n        forward_to = forward_all_url;\n    }\n    if (forward_to) {\n        redirect(conn, \"%s%s\", forward_to, decoded_url);\n        free(decoded_url);\n        return;\n    }\n\n    /* does it end in a slash? serve up url/index_name */\n    if (decoded_url[strlen(decoded_url)-1] == '/') {\n        xasprintf(&target, \"%s%s%s\", wwwroot, decoded_url, index_name);\n        if (!file_exists(target)) {\n            free(target);\n            if (no_listing) {\n                free(decoded_url);\n                /* Return 404 instead of 403 to make --no-listing\n                 * indistinguishable from the directory not existing.\n                 * i.e.: Don't leak information.\n                 */\n                default_reply(conn, 404, \"Not Found\",\n                    \"The URL you requested was not found.\");\n                return;\n            }\n            xasprintf(&target, \"%s%s\", wwwroot, decoded_url);\n            generate_dir_listing(conn, target, decoded_url);\n            free(target);\n            free(decoded_url);\n            return;\n        }\n        mimetype = url_content_type(index_name);\n    }\n    else {\n        /* points to a file */\n        xasprintf(&target, \"%s%s\", wwwroot, decoded_url);\n        mimetype = url_content_type(decoded_url);\n    }\n    free(decoded_url);\n    if (debug)\n        printf(\"url=\\\"%s\\\", target=\\\"%s\\\", content-type=\\\"%s\\\"\\n\",\n               conn->url, target, mimetype);\n\n    /* open file */\n    conn->reply_fd = open(target, O_RDONLY | O_NONBLOCK);\n    free(target);\n\n    if (conn->reply_fd == -1) {\n        /* open() failed */\n        if (errno == EACCES)\n            default_reply(conn, 403, \"Forbidden\",\n                \"You don't have permission to access this URL.\");\n        else if (errno == ENOENT)\n            default_reply(conn, 404, \"Not Found\",\n                \"The URL you requested was not found.\");\n        else\n            default_reply(conn, 500, \"Internal Server Error\",\n                \"The URL you requested cannot be returned: %s.\",\n                strerror(errno));\n\n        return;\n    }\n\n    /* stat the file */\n    if (fstat(conn->reply_fd, &filestat) == -1) {\n        default_reply(conn, 500, \"Internal Server Error\",\n            \"fstat() failed: %s.\", strerror(errno));\n        return;\n    }\n\n    /* make sure it's a regular file */\n    if (S_ISDIR(filestat.st_mode)) {\n        redirect(conn, \"%s/\", conn->url);\n        return;\n    }\n    else if (!S_ISREG(filestat.st_mode)) {\n        default_reply(conn, 403, \"Forbidden\", \"Not a regular file.\");\n        return;\n    }\n\n    conn->reply_type = REPLY_FROMFILE;\n    rfc1123_date(lastmod, filestat.st_mtime);\n\n    /* check for If-Modified-Since, may not have to send */\n    if_mod_since = parse_field(conn, \"If-Modified-Since: \");\n    if ((if_mod_since != NULL) &&\n            (strcmp(if_mod_since, lastmod) == 0)) {\n        if (debug)\n            printf(\"not modified since %s\\n\", if_mod_since);\n        conn->http_code = 304;\n        conn->header_length = xasprintf(&(conn->header),\n         \"HTTP/1.1 304 Not Modified\\r\\n\"\n         \"Date: %s\\r\\n\"\n         \"%s\" /* server */\n         \"Accept-Ranges: bytes\\r\\n\"\n         \"%s\" /* keep-alive */\n         \"%s\" /* custom headers */\n         \"\\r\\n\",\n         rfc1123_date(date, now), server_hdr, keep_alive(conn),\n         custom_hdrs);\n        conn->reply_length = 0;\n        conn->reply_type = REPLY_GENERATED;\n        conn->header_only = 1;\n\n        free(if_mod_since);\n        return;\n    }\n    free(if_mod_since);\n\n    if (conn->range_begin_given || conn->range_end_given) {\n        off_t from, to;\n\n        if (conn->range_begin_given && conn->range_end_given) {\n            /* 100-200 */\n            from = conn->range_begin;\n            to = conn->range_end;\n\n            /* clamp end to filestat.st_size-1 */\n            if (to > (filestat.st_size - 1))\n                to = filestat.st_size - 1;\n        }\n        else if (conn->range_begin_given && !conn->range_end_given) {\n            /* 100- :: yields 100 to end */\n            from = conn->range_begin;\n            to = filestat.st_size - 1;\n        }\n        else if (!conn->range_begin_given && conn->range_end_given) {\n            /* -200 :: yields last 200 */\n            to = filestat.st_size - 1;\n            from = to - conn->range_end + 1;\n\n            /* clamp start */\n            if (from < 0)\n                from = 0;\n        }\n        else\n            errx(1, \"internal error - from/to mismatch\");\n\n        if (from >= filestat.st_size) {\n            default_reply(conn, 416, \"Requested Range Not Satisfiable\",\n                \"You requested a range outside of the file.\");\n            return;\n        }\n\n        if (to < from) {\n            default_reply(conn, 416, \"Requested Range Not Satisfiable\",\n                \"You requested a backward range.\");\n            return;\n        }\n\n        conn->reply_start = from;\n        conn->reply_length = to - from + 1;\n\n        conn->header_length = xasprintf(&(conn->header),\n            \"HTTP/1.1 206 Partial Content\\r\\n\"\n            \"Date: %s\\r\\n\"\n            \"%s\" /* server */\n            \"Accept-Ranges: bytes\\r\\n\"\n            \"%s\" /* keep-alive */\n            \"%s\" /* custom headers */\n            \"Content-Length: %llu\\r\\n\"\n            \"Content-Range: bytes %llu-%llu/%llu\\r\\n\"\n            \"Content-Type: %s\\r\\n\"\n            \"Last-Modified: %s\\r\\n\"\n            \"\\r\\n\"\n            ,\n            rfc1123_date(date, now), server_hdr, keep_alive(conn),\n            custom_hdrs,\n            llu(conn->reply_length), llu(from), llu(to),\n            llu(filestat.st_size), mimetype, lastmod\n        );\n        conn->http_code = 206;\n        if (debug)\n            printf(\"sending %llu-%llu/%llu\\n\",\n                   llu(from), llu(to), llu(filestat.st_size));\n    }\n    else {\n        /* no range stuff */\n        conn->reply_length = filestat.st_size;\n        conn->header_length = xasprintf(&(conn->header),\n            \"HTTP/1.1 200 OK\\r\\n\"\n            \"Date: %s\\r\\n\"\n            \"%s\" /* server */\n            \"Accept-Ranges: bytes\\r\\n\"\n            \"%s\" /* keep-alive */\n            \"%s\" /* custom headers */\n            \"Content-Length: %llu\\r\\n\"\n            \"Content-Type: %s\\r\\n\"\n            \"Last-Modified: %s\\r\\n\"\n            \"\\r\\n\"\n            ,\n            rfc1123_date(date, now), server_hdr, keep_alive(conn),\n            custom_hdrs, llu(conn->reply_length), mimetype, lastmod\n        );\n        conn->http_code = 200;\n    }\n}\n\n/* Returns 1 if passwords are equal, runtime is proportional to the length of\n * user_input to avoid leaking the secret's length and contents through timing\n * information.\n */\nint password_equal(const char *user_input, const char *secret) {\n    size_t i = 0;\n    size_t j = 0;\n    char out = 0;\n\n    while (1) {\n        /* Out stays zero if the strings are the same. */\n        out |= user_input[i] ^ secret[j];\n\n        /* Stop at end of user_input. */\n        if (user_input[i] == 0) break;\n        i++;\n\n        /* Don't go past end of secret. */\n        if (secret[j] != 0) j++;\n    }\n\n    /* Check length after loop, otherwise early exit would leak length. */\n    out |= (i != j); /* Secret was shorter. */\n    out |= (secret[j] != 0); /* Secret was longer; j is not the end. */\n    return out == 0;\n}\n\n/* Process a request: build the header and reply, advance state. */\nstatic void process_request(struct connection *conn) {\n    num_requests++;\n\n    if (!parse_request(conn)) {\n        default_reply(conn, 400, \"Bad Request\",\n            \"You sent a request that the server couldn't understand.\");\n    }\n    else if (is_https_redirect(conn)) {\n        redirect_https(conn);\n    }\n    /* fail if: (auth_enabled) AND (client supplied invalid credentials) */\n    else if (auth_key != NULL &&\n            (conn->authorization == NULL ||\n             !password_equal(conn->authorization, auth_key))) {\n        default_reply(conn, 401, \"Unauthorized\",\n            \"Access denied due to invalid credentials.\");\n    }\n    else if (strcmp(conn->method, \"GET\") == 0) {\n        process_get(conn);\n    }\n    else if (strcmp(conn->method, \"HEAD\") == 0) {\n        process_get(conn);\n        conn->header_only = 1;\n    }\n    else {\n        default_reply(conn, 501, \"Not Implemented\",\n                      \"The method you specified is not implemented.\");\n    }\n\n    /* advance state */\n    conn->state = SEND_HEADER;\n\n    /* request not needed anymore */\n    free(conn->request);\n    conn->request = NULL; /* important: don't free it again later */\n}\n\n/* Receiving request. */\nstatic void poll_recv_request(struct connection *conn) {\n    char buf[1<<15];\n    ssize_t recvd;\n\n    assert(conn->state == RECV_REQUEST);\n    recvd = recv(conn->socket, buf, sizeof(buf), 0);\n    if (debug)\n        printf(\"poll_recv_request(%d) got %d bytes\\n\",\n               conn->socket, (int)recvd);\n    if (recvd < 1) {\n        if (recvd == -1) {\n            if (errno == EAGAIN) {\n                if (debug) printf(\"poll_recv_request would have blocked\\n\");\n                return;\n            }\n            if (debug) printf(\"recv(%d) error: %s\\n\",\n                conn->socket, strerror(errno));\n        }\n        conn->conn_close = 1;\n        conn->state = DONE;\n        return;\n    }\n    conn->last_active = now;\n\n    /* append to conn->request */\n    assert(recvd > 0);\n    conn->request = xrealloc(\n        conn->request, conn->request_length + (size_t)recvd + 1);\n    memcpy(conn->request+conn->request_length, buf, (size_t)recvd);\n    conn->request_length += (size_t)recvd;\n    conn->request[conn->request_length] = 0;\n    total_in += (size_t)recvd;\n\n    /* process request if we have all of it */\n    if ((conn->request_length > 2) &&\n        (memcmp(conn->request+conn->request_length-2, \"\\n\\n\", 2) == 0))\n            process_request(conn);\n    else if ((conn->request_length > 4) &&\n        (memcmp(conn->request+conn->request_length-4, \"\\r\\n\\r\\n\", 4) == 0))\n            process_request(conn);\n\n    /* die if it's too large */\n    if (conn->request_length > MAX_REQUEST_LENGTH) {\n        default_reply(conn, 413, \"Request Entity Too Large\",\n                      \"Your request was dropped because it was too long.\");\n        conn->state = SEND_HEADER;\n    }\n\n    /* if we've moved on to the next state, try to send right away, instead of\n     * going through another iteration of the select() loop.\n     */\n    if (conn->state == SEND_HEADER)\n        poll_send_header(conn);\n}\n\n/* Sending header.  Assumes conn->header is not NULL. */\nstatic void poll_send_header(struct connection *conn) {\n    ssize_t sent;\n\n    assert(conn->state == SEND_HEADER);\n    assert(conn->header_length == strlen(conn->header));\n\n    sent = send(conn->socket,\n                conn->header + conn->header_sent,\n                conn->header_length - conn->header_sent,\n                0);\n    conn->last_active = now;\n    if (debug)\n        printf(\"poll_send_header(%d) sent %d bytes\\n\",\n               conn->socket, (int)sent);\n\n    /* handle any errors (-1) or closure (0) in send() */\n    if (sent < 1) {\n        if ((sent == -1) && (errno == EAGAIN)) {\n            if (debug) printf(\"poll_send_header would have blocked\\n\");\n            return;\n        }\n        if (debug && (sent == -1))\n            printf(\"send(%d) error: %s\\n\", conn->socket, strerror(errno));\n        conn->conn_close = 1;\n        conn->state = DONE;\n        return;\n    }\n    assert(sent > 0);\n    conn->header_sent += (size_t)sent;\n    conn->total_sent += (size_t)sent;\n    total_out += (size_t)sent;\n\n    /* check if we're done sending header */\n    if (conn->header_sent == conn->header_length) {\n        if (conn->header_only)\n            conn->state = DONE;\n        else {\n            conn->state = SEND_REPLY;\n            /* go straight on to body, don't go through another iteration of\n             * the select() loop.\n             */\n            poll_send_reply(conn);\n        }\n    }\n}\n\n/* Send chunk on socket <s> from FILE *fp, starting at <ofs> and of size\n * <size>.  Use sendfile() if possible since it's zero-copy on some platforms.\n * Returns the number of bytes sent, 0 on closure, -1 if send() failed, -2 if\n * read error.\n */\nstatic ssize_t send_from_file(const int s, const int fd,\n        off_t ofs, size_t size) {\n#ifdef __FreeBSD__\n    off_t sent;\n    int ret = sendfile(fd, s, ofs, size, NULL, &sent, 0);\n\n    /* It is possible for sendfile to send zero bytes due to a blocking\n     * condition.  Handle this correctly.\n     */\n    if (ret == -1)\n        if (errno == EAGAIN)\n            if (sent == 0)\n                return -1;\n            else\n                return sent;\n        else\n            return -1;\n    else\n        return size;\n#else\n#if defined(__linux) || defined(__sun__)\n    /* Limit truly ridiculous (LARGEFILE) requests. */\n    if (size > 1<<20)\n        size = 1<<20;\n    return sendfile(s, fd, &ofs, size);\n#else\n    /* Fake sendfile() with read(). */\n# ifndef min\n#  define min(a,b) ( ((a)<(b)) ? (a) : (b) )\n# endif\n    char buf[1<<15];\n    size_t amount = min(sizeof(buf), size);\n    ssize_t numread;\n\n    if (lseek(fd, ofs, SEEK_SET) == -1)\n        err(1, \"fseek(%d)\", (int)ofs);\n    numread = read(fd, buf, amount);\n    if (numread == 0) {\n        fprintf(stderr, \"premature eof on fd %d\\n\", fd);\n        return -1;\n    }\n    else if (numread == -1) {\n        fprintf(stderr, \"error reading on fd %d: %s\", fd, strerror(errno));\n        return -1;\n    }\n    else if ((size_t)numread != amount) {\n        fprintf(stderr, \"read %zd bytes, expecting %zu bytes on fd %d\\n\",\n            numread, amount, fd);\n        return -1;\n    }\n    else\n        return send(s, buf, amount, 0);\n#endif\n#endif\n}\n\n/* Sending reply. */\nstatic void poll_send_reply(struct connection *conn)\n{\n    ssize_t sent;\n    /* off_t can be wider than size_t, avoid overflow in send_len */\n    const size_t max_size_t = ~((size_t)0);\n    off_t send_len = conn->reply_length - conn->reply_sent;\n    if (send_len > max_size_t) send_len = max_size_t;\n\n    assert(conn->state == SEND_REPLY);\n    assert(!conn->header_only);\n    if (conn->reply_type == REPLY_GENERATED) {\n        assert(conn->reply_length >= conn->reply_sent);\n        sent = send(conn->socket,\n            conn->reply + conn->reply_start + conn->reply_sent,\n            (size_t)send_len, 0);\n    }\n    else {\n        errno = 0;\n        assert(conn->reply_length >= conn->reply_sent);\n        sent = send_from_file(conn->socket, conn->reply_fd,\n            conn->reply_start + conn->reply_sent, (size_t)send_len);\n        if (debug && (sent < 1))\n            printf(\"send_from_file returned %lld (errno=%d %s)\\n\",\n                (long long)sent, errno, strerror(errno));\n    }\n    conn->last_active = now;\n    if (debug)\n        printf(\"poll_send_reply(%d) sent %d: %llu+[%llu-%llu] of %llu\\n\",\n               conn->socket, (int)sent, llu(conn->reply_start),\n               llu(conn->reply_sent), llu(conn->reply_sent + sent - 1),\n               llu(conn->reply_length));\n\n    /* handle any errors (-1) or closure (0) in send() */\n    if (sent < 1) {\n        if (sent == -1) {\n            if (errno == EAGAIN) {\n                if (debug)\n                    printf(\"poll_send_reply would have blocked\\n\");\n                return;\n            }\n            if (debug)\n                printf(\"send(%d) error: %s\\n\", conn->socket, strerror(errno));\n        }\n        else if (sent == 0) {\n            if (debug)\n                printf(\"send(%d) closure\\n\", conn->socket);\n        }\n        conn->conn_close = 1;\n        conn->state = DONE;\n        return;\n    }\n    conn->reply_sent += sent;\n    conn->total_sent += (size_t)sent;\n    total_out += (size_t)sent;\n\n    /* check if we're done sending */\n    if (conn->reply_sent == conn->reply_length)\n        conn->state = DONE;\n}\n\n/* Main loop of the httpd - a select() and then delegation to accept\n * connections, handle receiving of requests, and sending of replies.\n */\nstatic void httpd_poll(void) {\n    fd_set recv_set, send_set;\n    int max_fd, select_ret;\n    struct connection *conn, *next;\n    int bother_with_timeout = 0;\n    struct timeval timeout, t0, t1;\n\n    timeout.tv_sec = timeout_secs;\n    timeout.tv_usec = 0;\n\n    FD_ZERO(&recv_set);\n    FD_ZERO(&send_set);\n    max_fd = 0;\n\n    /* set recv/send fd_sets */\n#define MAX_FD_SET(sock, fdset) do { FD_SET(sock,fdset); \\\n                                max_fd = (max_fd<sock) ? sock : max_fd; } \\\n                                while (0)\n    if (accepting) MAX_FD_SET(sockin, &recv_set);\n\n    LIST_FOREACH_SAFE(conn, &connlist, entries, next) {\n        switch (conn->state) {\n        case DONE:\n            /* do nothing, no connection should be left in this state */\n            break;\n\n        case RECV_REQUEST:\n            MAX_FD_SET(conn->socket, &recv_set);\n            bother_with_timeout = 1;\n            break;\n\n        case SEND_HEADER:\n        case SEND_REPLY:\n            MAX_FD_SET(conn->socket, &send_set);\n            bother_with_timeout = 1;\n            break;\n        }\n    }\n#undef MAX_FD_SET\n\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n    __msan_unpoison(&recv_set, sizeof(recv_set));\n    __msan_unpoison(&send_set, sizeof(send_set));\n# endif\n#endif\n\n    /* -select- */\n    if (timeout_secs == 0) {\n        bother_with_timeout = 0;\n    }\n    if (debug) {\n        printf(\"select() with max_fd %d timeout %d\\n\",\n                max_fd, bother_with_timeout ? (int)timeout.tv_sec : 0);\n        gettimeofday(&t0, NULL);\n    }\n    select_ret = select(max_fd + 1, &recv_set, &send_set, NULL,\n        (bother_with_timeout) ? &timeout : NULL);\n    if (select_ret == 0) {\n        if (!bother_with_timeout)\n            errx(1, \"select() timed out\");\n    }\n    if (select_ret == -1) {\n        if (errno == EINTR)\n            return; /* interrupted by signal */\n        else\n            err(1, \"select() failed\");\n    }\n    if (debug) {\n        long long sec, usec;\n        gettimeofday(&t1, NULL);\n        sec = t1.tv_sec - t0.tv_sec;\n        usec = t1.tv_usec - t0.tv_usec;\n        if (usec < 0) {\n            usec += 1000000;\n            sec--;\n        }\n        printf(\"select() returned %d after %lld.%06lld secs\\n\",\n                select_ret, sec, usec);\n    }\n\n    /* update time */\n    now = time(NULL);\n\n    /* poll connections that select() says need attention */\n    if (FD_ISSET(sockin, &recv_set))\n        accept_connection();\n\n    LIST_FOREACH_SAFE(conn, &connlist, entries, next) {\n        poll_check_timeout(conn);\n        switch (conn->state) {\n        case RECV_REQUEST:\n            if (FD_ISSET(conn->socket, &recv_set)) poll_recv_request(conn);\n            break;\n\n        case SEND_HEADER:\n            if (FD_ISSET(conn->socket, &send_set)) poll_send_header(conn);\n            break;\n\n        case SEND_REPLY:\n            if (FD_ISSET(conn->socket, &send_set)) poll_send_reply(conn);\n            break;\n\n        case DONE:\n            /* (handled later; ignore for now as it's a valid state) */\n            break;\n        }\n\n        /* Handling SEND_REPLY could have set the state to done. */\n        if (conn->state == DONE) {\n            /* clean out finished connection */\n            if (conn->conn_close) {\n                LIST_REMOVE(conn, entries);\n                free_connection(conn);\n                free(conn);\n            } else {\n                recycle_connection(conn);\n            }\n        }\n    }\n}\n\n/* Daemonize helpers. */\n#define PATH_DEVNULL \"/dev/null\"\nstatic int lifeline[2] = { -1, -1 };\nstatic int fd_null = -1;\n\nstatic void daemonize_start(void) {\n    pid_t f;\n\n    if (pipe(lifeline) == -1)\n        err(1, \"pipe(lifeline)\");\n\n    fd_null = open(PATH_DEVNULL, O_RDWR, 0);\n    if (fd_null == -1)\n        err(1, \"open(\" PATH_DEVNULL \")\");\n\n    f = fork();\n    if (f == -1)\n        err(1, \"fork\");\n    else if (f != 0) {\n        /* parent: wait for child */\n        char tmp[1];\n        int status;\n        pid_t w;\n\n        if (close(lifeline[1]) == -1)\n            warn(\"close lifeline in parent\");\n        if (read(lifeline[0], tmp, sizeof(tmp)) == -1)\n            warn(\"read lifeline in parent\");\n        w = waitpid(f, &status, WNOHANG);\n        if (w == -1)\n            err(1, \"waitpid\");\n        else if (w == 0)\n            /* child is running happily */\n            exit(EXIT_SUCCESS);\n        else\n            /* child init failed, pass on its exit status */\n            exit(WEXITSTATUS(status));\n    }\n    /* else we are the child: continue initializing */\n}\n\nstatic void daemonize_finish(void) {\n    if (fd_null == -1)\n        return; /* didn't daemonize_start() so we're not daemonizing */\n\n    if (setsid() == -1)\n        err(1, \"setsid\");\n    if (close(lifeline[0]) == -1)\n        warn(\"close read end of lifeline in child\");\n    if (close(lifeline[1]) == -1)\n        warn(\"couldn't cut the lifeline\");\n\n    /* close all our std fds */\n    if (dup2(fd_null, STDIN_FILENO) == -1)\n        warn(\"dup2(stdin)\");\n    if (dup2(fd_null, STDOUT_FILENO) == -1)\n        warn(\"dup2(stdout)\");\n    if (dup2(fd_null, STDERR_FILENO) == -1)\n        warn(\"dup2(stderr)\");\n    if (fd_null > 2)\n        close(fd_null);\n}\n\n/* [->] pidfile helpers, based on FreeBSD src/lib/libutil/pidfile.c,v 1.3\n * Original was copyright (c) 2005 Pawel Jakub Dawidek <pjd@FreeBSD.org>\n */\nstatic int pidfile_fd = -1;\n#define PIDFILE_MODE 0600\n\nstatic void pidfile_remove(void) {\n    if (unlink(pidfile_name) == -1)\n        err(1, \"unlink(pidfile) failed\");\n /* if (flock(pidfile_fd, LOCK_UN) == -1)\n        err(1, \"unlock(pidfile) failed\"); */\n    xclose(pidfile_fd);\n    pidfile_fd = -1;\n}\n\nstatic int pidfile_read(void) {\n    char buf[16];\n    int fd, i;\n    long long pid;\n\n    fd = open(pidfile_name, O_RDONLY);\n    if (fd == -1)\n        err(1, \" after create failed\");\n\n    i = (int)read(fd, buf, sizeof(buf) - 1);\n    if (i == -1)\n        err(1, \"read from pidfile failed\");\n    xclose(fd);\n    buf[i] = '\\0';\n\n    if (!str_to_num(buf, &pid)) {\n        err(1, \"invalid pidfile contents: \\\"%s\\\"\", buf);\n    }\n    return (int)pid;\n}\n\nstatic void pidfile_create(void) {\n    int error, fd;\n    char pidstr[16];\n\n    /* Open the PID file and obtain exclusive lock. */\n    fd = open(pidfile_name,\n        O_WRONLY | O_CREAT | O_EXLOCK | O_TRUNC | O_NONBLOCK, PIDFILE_MODE);\n    if (fd == -1) {\n        if ((errno == EWOULDBLOCK) || (errno == EEXIST))\n            errx(1, \"daemon already running with PID %d\", pidfile_read());\n        else\n            err(1, \"can't create pidfile %s\", pidfile_name);\n    }\n    pidfile_fd = fd;\n\n    if (ftruncate(fd, 0) == -1) {\n        error = errno;\n        pidfile_remove();\n        errno = error;\n        err(1, \"ftruncate() failed\");\n    }\n\n    snprintf(pidstr, sizeof(pidstr), \"%d\", (int)getpid());\n    if (pwrite(fd, pidstr, strlen(pidstr), 0) != (ssize_t)strlen(pidstr)) {\n        error = errno;\n        pidfile_remove();\n        errno = error;\n        err(1, \"pwrite() failed\");\n    }\n}\n/* [<-] end of pidfile helpers. */\n\n/* Close all sockets and FILEs and exit. */\nstatic void stop_running(int sig unused) {\n    running = 0;\n}\n\n/* Execution starts here. */\nint main(int argc, char **argv) {\n    printf(\"%s, %s.\\n\", pkgname, copyright);\n    parse_default_extension_map();\n    parse_commandline(argc, argv);\n    /* parse_commandline() might override parts of the extension map by\n     * parsing a user-specified file.\n     */\n    sort_mime_map();\n    xasprintf(&keep_alive_field, \"Keep-Alive: timeout=%d\\r\\n\", timeout_secs);\n    if (want_server_id)\n        xasprintf(&server_hdr, \"Server: %s\\r\\n\", pkgname);\n    else\n        server_hdr = xstrdup(\"\");\n    init_sockin();\n\n    /* open logfile */\n    if (logfile_name == NULL)\n        logfile = stdout;\n    else {\n        logfile = fopen(logfile_name, \"ab\");\n        if (logfile == NULL)\n            err(1, \"opening logfile: fopen(\\\"%s\\\")\", logfile_name);\n    }\n\n    if (want_daemon)\n        daemonize_start();\n\n    /* signals */\n    if (signal(SIGPIPE, SIG_IGN) == SIG_ERR)\n        err(1, \"signal(ignore SIGPIPE)\");\n    if (signal(SIGINT, stop_running) == SIG_ERR)\n        err(1, \"signal(SIGINT)\");\n    if (signal(SIGTERM, stop_running) == SIG_ERR)\n        err(1, \"signal(SIGTERM)\");\n\n    /* security */\n    if (want_chroot) {\n        tzset(); /* read /etc/localtime before we chroot */\n        if (chdir(wwwroot) == -1)\n            err(1, \"chdir(%s)\", wwwroot);\n        if (chroot(wwwroot) == -1)\n            err(1, \"chroot(%s)\", wwwroot);\n        printf(\"chrooted to `%s'\\n\", wwwroot);\n        wwwroot[0] = '\\0'; /* empty string */\n    }\n    if (drop_gid != INVALID_GID) {\n        gid_t list[1];\n        list[0] = drop_gid;\n        if (setgroups(1, list) == -1)\n            err(1, \"setgroups([%d])\", (int)drop_gid);\n        if (setgid(drop_gid) == -1)\n            err(1, \"setgid(%d)\", (int)drop_gid);\n        printf(\"set gid to %d\\n\", (int)drop_gid);\n    }\n    if (drop_uid != INVALID_UID) {\n        if (setuid(drop_uid) == -1)\n            err(1, \"setuid(%d)\", (int)drop_uid);\n        printf(\"set uid to %d\\n\", (int)drop_uid);\n    }\n\n    /* create pidfile */\n    if (pidfile_name) pidfile_create();\n\n    if (want_daemon) daemonize_finish();\n\n    /* main loop */\n    running = 1;\n    while (running) httpd_poll();\n\n    /* clean exit */\n    xclose(sockin);\n    if (logfile != NULL) fclose(logfile);\n    if (pidfile_name) pidfile_remove();\n\n    /* close and free connections */\n    {\n        struct connection *conn, *next;\n\n        LIST_FOREACH_SAFE(conn, &connlist, entries, next) {\n            LIST_REMOVE(conn, entries);\n            free_connection(conn);\n            free(conn);\n        }\n    }\n\n    /* free the mallocs */\n    {\n        size_t i;\n        for (i=0; i<mime_map_size; i++) {\n            free(mime_map[i].extension);\n            free(mime_map[i].mimetype);\n        }\n        free(mime_map);\n        if (forward_map)\n            free(forward_map);\n        free(keep_alive_field);\n        free(wwwroot);\n        free(server_hdr);\n        free(auth_key);\n        free(custom_hdrs);\n    }\n\n    /* usage stats */\n    {\n        struct rusage r;\n\n        getrusage(RUSAGE_SELF, &r);\n        printf(\"CPU time used: %u.%02u user, %u.%02u system\\n\",\n            (unsigned int)r.ru_utime.tv_sec,\n                (unsigned int)(r.ru_utime.tv_usec/10000),\n            (unsigned int)r.ru_stime.tv_sec,\n                (unsigned int)(r.ru_stime.tv_usec/10000)\n        );\n        printf(\"Requests: %llu\\n\", llu(num_requests));\n        printf(\"Bytes: %llu in, %llu out\\n\", llu(total_in), llu(total_out));\n    }\n\n    return 0;\n}\n\n/* vim:set ts=4 sw=4 sts=4 expandtab tw=78: */\n"], "fixing_code": ["/* darkhttpd - a simple, single-threaded, static content webserver.\n * https://unix4lyfe.org/darkhttpd/\n * Copyright (c) 2003-2022 Emil Mikulic <emikulic@gmail.com>\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the\n * above copyright notice and this permission notice appear in all\n * copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL\n * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE\n * AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL\n * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR\n * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER\n * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\nstatic const char\n    pkgname[]   = \"darkhttpd/1.14.from.git\",\n    copyright[] = \"copyright (c) 2003-2022 Emil Mikulic\";\n\n/* Possible build options: -DDEBUG -DNO_IPV6 */\n\n#ifndef NO_IPV6\n# define HAVE_INET6\n#endif\n\n#ifndef DEBUG\n# define NDEBUG\nstatic const int debug = 0;\n#else\nstatic const int debug = 1;\n#endif\n\n#ifdef __linux\n# define _GNU_SOURCE /* for strsignal() and vasprintf() */\n# define _FILE_OFFSET_BITS 64 /* stat() files bigger than 2GB */\n# include <sys/sendfile.h>\n#endif\n\n#ifdef __sun__\n# include <sys/sendfile.h>\n#endif\n\n#include <sys/time.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <sys/wait.h>\n#include <sys/param.h>\n#include <netinet/in.h>\n#include <netinet/tcp.h>\n#include <arpa/inet.h>\n#include <assert.h>\n#include <ctype.h>\n#include <dirent.h>\n#include <errno.h>\n#include <fcntl.h>\n#include <grp.h>\n#include <limits.h>\n#include <pwd.h>\n#include <signal.h>\n#include <stdarg.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <syslog.h>\n#include <time.h>\n#include <unistd.h>\n\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n#  include <sanitizer/msan_interface.h>\n# endif\n#endif\n\n#ifdef __sun__\n# ifndef INADDR_NONE\n#  define INADDR_NONE -1\n# endif\n#endif\n\n#ifndef MAXNAMLEN\n# ifdef NAME_MAX\n#  define MAXNAMLEN NAME_MAX\n# else\n#  define MAXNAMLEN   255\n# endif\n#endif\n\n#if defined(O_EXCL) && !defined(O_EXLOCK)\n# define O_EXLOCK O_EXCL\n#endif\n\n#ifndef __printflike\n# ifdef __GNUC__\n/* [->] borrowed from FreeBSD's src/sys/sys/cdefs.h,v 1.102.2.2.2.1 */\n#  define __printflike(fmtarg, firstvararg) \\\n             __attribute__((__format__(__printf__, fmtarg, firstvararg)))\n/* [<-] */\n# else\n#  define __printflike(fmtarg, firstvararg)\n# endif\n#endif\n\n#if defined(__GNUC__) || defined(__INTEL_COMPILER)\n# define unused __attribute__((__unused__))\n#else\n# define unused\n#endif\n\n/* [->] borrowed from FreeBSD's src/sys/sys/systm.h,v 1.276.2.7.4.1 */\n#ifndef CTASSERT                /* Allow lint to override */\n# define CTASSERT(x)             _CTASSERT(x, __LINE__)\n# define _CTASSERT(x, y)         __CTASSERT(x, y)\n# define __CTASSERT(x, y)        typedef char __assert ## y[(x) ? 1 : -1]\n#endif\n/* [<-] */\n\nCTASSERT(sizeof(unsigned long long) >= sizeof(off_t));\n#define llu(x) ((unsigned long long)(x))\n\n#if defined(__FreeBSD__) || defined(__OpenBSD__) || defined(__linux)\n# include <err.h>\n#else\n/* err - prints \"error: format: strerror(errno)\" to stderr and exit()s with\n * the given code.\n */\nstatic void err(const int code, const char *format, ...) __printflike(2, 3);\nstatic void err(const int code, const char *format, ...) {\n    va_list va;\n\n    va_start(va, format);\n    fprintf(stderr, \"error: \");\n    vfprintf(stderr, format, va);\n    fprintf(stderr, \": %s\\n\", strerror(errno));\n    va_end(va);\n    exit(code);\n}\n\n/* errx - err() without the strerror */\nstatic void errx(const int code, const char *format, ...) __printflike(2, 3);\nstatic void errx(const int code, const char *format, ...) {\n    va_list va;\n\n    va_start(va, format);\n    fprintf(stderr, \"error: \");\n    vfprintf(stderr, format, va);\n    fprintf(stderr, \"\\n\");\n    va_end(va);\n    exit(code);\n}\n\n/* warn - err() without the exit */\nstatic void warn(const char *format, ...) __printflike(1, 2);\nstatic void warn(const char *format, ...) {\n    va_list va;\n\n    va_start(va, format);\n    fprintf(stderr, \"warning: \");\n    vfprintf(stderr, format, va);\n    fprintf(stderr, \": %s\\n\", strerror(errno));\n    va_end(va);\n}\n#endif\n\n/* [->] LIST_* macros taken from FreeBSD's src/sys/sys/queue.h,v 1.56\n * Copyright (c) 1991, 1993\n *      The Regents of the University of California.  All rights reserved.\n *\n * Under a BSD license.\n */\n#define LIST_HEAD(name, type)                                           \\\nstruct name {                                                           \\\n        struct type *lh_first;  /* first element */                     \\\n}\n\n#define LIST_HEAD_INITIALIZER(head)                                     \\\n        { NULL }\n\n#define LIST_ENTRY(type)                                                \\\nstruct {                                                                \\\n        struct type *le_next;   /* next element */                      \\\n        struct type **le_prev;  /* address of previous next element */  \\\n}\n\n#define LIST_FIRST(head)        ((head)->lh_first)\n\n#define LIST_FOREACH_SAFE(var, head, field, tvar)                       \\\n    for ((var) = LIST_FIRST((head));                                    \\\n        (var) && ((tvar) = LIST_NEXT((var), field), 1);                 \\\n        (var) = (tvar))\n\n#define LIST_INSERT_HEAD(head, elm, field) do {                         \\\n        if ((LIST_NEXT((elm), field) = LIST_FIRST((head))) != NULL)     \\\n                LIST_FIRST((head))->field.le_prev = &LIST_NEXT((elm), field);\\\n        LIST_FIRST((head)) = (elm);                                     \\\n        (elm)->field.le_prev = &LIST_FIRST((head));                     \\\n} while (0)\n\n#define LIST_NEXT(elm, field)   ((elm)->field.le_next)\n\n#define LIST_REMOVE(elm, field) do {                                    \\\n        if (LIST_NEXT((elm), field) != NULL)                            \\\n                LIST_NEXT((elm), field)->field.le_prev =                \\\n                    (elm)->field.le_prev;                               \\\n        *(elm)->field.le_prev = LIST_NEXT((elm), field);                \\\n} while (0)\n/* [<-] */\n\nstatic LIST_HEAD(conn_list_head, connection) connlist =\n    LIST_HEAD_INITIALIZER(conn_list_head);\n\nstruct connection {\n    LIST_ENTRY(connection) entries;\n\n    int socket;\n#ifdef HAVE_INET6\n    struct in6_addr client;\n#else\n    in_addr_t client;\n#endif\n    time_t last_active;\n    enum {\n        RECV_REQUEST,   /* receiving request */\n        SEND_HEADER,    /* sending generated header */\n        SEND_REPLY,     /* sending reply */\n        DONE            /* connection closed, need to remove from queue */\n    } state;\n\n    /* char request[request_length+1] is null-terminated */\n    char *request;\n    size_t request_length;\n\n    /* request fields */\n    char *method, *url, *referer, *user_agent, *authorization;\n    off_t range_begin, range_end;\n    off_t range_begin_given, range_end_given;\n\n    char *header;\n    size_t header_length, header_sent;\n    int header_dont_free, header_only, http_code, conn_close;\n\n    enum { REPLY_GENERATED, REPLY_FROMFILE } reply_type;\n    char *reply;\n    int reply_dont_free;\n    int reply_fd;\n    off_t reply_start, reply_length, reply_sent,\n          total_sent; /* header + body = total, for logging */\n};\n\nstruct forward_mapping {\n    const char *host, *target_url; /* These point at argv. */\n};\n\nstatic struct forward_mapping *forward_map = NULL;\nstatic size_t forward_map_size = 0;\nstatic const char *forward_all_url = NULL;\n\nstatic int forward_to_https = 0;\n\nstruct mime_mapping {\n    char *extension, *mimetype;\n};\n\nstatic struct mime_mapping *mime_map = NULL;\nstatic size_t mime_map_size = 0;\nstatic size_t longest_ext = 0;\n\n/* If a connection is idle for timeout_secs or more, it gets closed and\n * removed from the connlist.\n */\nstatic int timeout_secs = 30;\nstatic char *keep_alive_field = NULL;\n\n/* Time is cached in the event loop to avoid making an excessive number of\n * gettimeofday() calls.\n */\nstatic time_t now;\n\n/* To prevent a malformed request from eating up too much memory, die once the\n * request exceeds this many bytes:\n */\n#define MAX_REQUEST_LENGTH 4000\n\n/* Defaults can be overridden on the command-line */\nstatic const char *bindaddr;\nstatic uint16_t bindport = 8080;    /* or 80 if running as root */\nstatic int max_connections = -1;    /* kern.ipc.somaxconn */\nstatic const char *index_name = \"index.html\";\nstatic int no_listing = 0;\n\nstatic int sockin = -1;             /* socket to accept connections from */\n#ifdef HAVE_INET6\nstatic int inet6 = 0;               /* whether the socket uses inet6 */\n#endif\nstatic char *wwwroot = NULL;        /* a path name */\nstatic char *logfile_name = NULL;   /* NULL = no logging */\nstatic FILE *logfile = NULL;\nstatic char *pidfile_name = NULL;   /* NULL = no pidfile */\nstatic int want_chroot = 0, want_daemon = 0, want_accf = 0,\n           want_keepalive = 1, want_server_id = 1;\nstatic char *server_hdr = NULL;\nstatic char *auth_key = NULL;       /* NULL or \"Basic base64_of_password\" */\nstatic char *custom_hdrs = NULL;\nstatic uint64_t num_requests = 0, total_in = 0, total_out = 0;\nstatic int accepting = 1;           /* set to 0 to stop accept()ing */\nstatic int syslog_enabled = 0;\nvolatile int running = 0; /* signal handler sets this to false */\n\n#define INVALID_UID ((uid_t) -1)\n#define INVALID_GID ((gid_t) -1)\n\nstatic uid_t drop_uid = INVALID_UID;\nstatic gid_t drop_gid = INVALID_GID;\n\n/* Default mimetype mappings - make sure this array is NULL terminated. */\nstatic const char *default_extension_map[] = {\n    \"application/json\"     \" json\",\n    \"application/pdf\"      \" pdf\",\n    \"application/wasm\"     \" wasm\",\n    \"application/xml\"      \" xsl xml\",\n    \"application/xml-dtd\"  \" dtd\",\n    \"application/xslt+xml\" \" xslt\",\n    \"application/zip\"      \" zip\",\n    \"audio/flac\"           \" flac\",\n    \"audio/mpeg\"           \" mp2 mp3 mpga\",\n    \"audio/ogg\"            \" ogg opus oga spx\",\n    \"audio/wav\"            \" wav\",\n    \"audio/x-m4a\"          \" m4a\",\n    \"font/woff\"            \" woff\",\n    \"font/woff2\"           \" woff2\",\n    \"image/apng\"           \" apng\",\n    \"image/avif\"           \" avif\",\n    \"image/gif\"            \" gif\",\n    \"image/jpeg\"           \" jpeg jpe jpg\",\n    \"image/png\"            \" png\",\n    \"image/svg+xml\"        \" svg\",\n    \"image/webp\"           \" webp\",\n    \"text/css\"             \" css\",\n    \"text/html\"            \" html htm\",\n    \"text/javascript\"      \" js\",\n    \"text/plain\"           \" txt asc\",\n    \"video/mpeg\"           \" mpeg mpe mpg\",\n    \"video/quicktime\"      \" qt mov\",\n    \"video/webm\"           \" webm\",\n    \"video/x-msvideo\"      \" avi\",\n    \"video/mp4\"            \" mp4 m4v\",\n    NULL\n};\n\nstatic const char octet_stream[] = \"application/octet-stream\";\nstatic const char *default_mimetype = octet_stream;\n\n/* Prototypes. */\nstatic void poll_recv_request(struct connection *conn);\nstatic void poll_send_header(struct connection *conn);\nstatic void poll_send_reply(struct connection *conn);\n\n/* close() that dies on error.  */\nstatic void xclose(const int fd) {\n    if (close(fd) == -1)\n        err(1, \"close()\");\n}\n\n/* malloc that dies if it can't allocate. */\nstatic void *xmalloc(const size_t size) {\n    void *ptr = malloc(size);\n    if (ptr == NULL)\n        errx(1, \"can't allocate %zu bytes\", size);\n    return ptr;\n}\n\n/* realloc() that dies if it can't reallocate. */\nstatic void *xrealloc(void *original, const size_t size) {\n    void *ptr = realloc(original, size);\n    if (ptr == NULL)\n        errx(1, \"can't reallocate %zu bytes\", size);\n    return ptr;\n}\n\n/* strdup() that dies if it can't allocate.\n * Implement this ourselves since regular strdup() isn't C89.\n */\nstatic char *xstrdup(const char *src) {\n    size_t len = strlen(src) + 1;\n    char *dest = xmalloc(len);\n    memcpy(dest, src, len);\n    return dest;\n}\n\n/* vasprintf() that dies if it fails. */\nstatic unsigned int xvasprintf(char **ret, const char *format, va_list ap)\n    __printflike(2,0);\nstatic unsigned int xvasprintf(char **ret, const char *format, va_list ap) {\n    int len = vasprintf(ret, format, ap);\n    if (ret == NULL || len == -1)\n        errx(1, \"out of memory in vasprintf()\");\n    return (unsigned int)len;\n}\n\n/* asprintf() that dies if it fails. */\nstatic unsigned int xasprintf(char **ret, const char *format, ...)\n    __printflike(2,3);\nstatic unsigned int xasprintf(char **ret, const char *format, ...) {\n    va_list va;\n    unsigned int len;\n\n    va_start(va, format);\n    len = xvasprintf(ret, format, va);\n    va_end(va);\n    return len;\n}\n\n/* Append buffer code.  A somewhat efficient string buffer with pool-based\n * reallocation.\n */\n#ifndef APBUF_INIT\n# define APBUF_INIT 4096\n#endif\n#define APBUF_GROW APBUF_INIT\nstruct apbuf {\n    size_t length, pool;\n    char *str;\n};\n\nstatic struct apbuf *make_apbuf(void) {\n    struct apbuf *buf = xmalloc(sizeof(struct apbuf));\n    buf->length = 0;\n    buf->pool = APBUF_INIT;\n    buf->str = xmalloc(buf->pool);\n    return buf;\n}\n\n/* Append s (of length len) to buf. */\nstatic void appendl(struct apbuf *buf, const char *s, const size_t len) {\n    size_t need = buf->length + len;\n    if (buf->pool < need) {\n        /* pool has dried up */\n        while (buf->pool < need)\n            buf->pool += APBUF_GROW;\n        buf->str = xrealloc(buf->str, buf->pool);\n    }\n    memcpy(buf->str + buf->length, s, len);\n    buf->length += len;\n}\n\n#ifdef __GNUC__\n#define append(buf, s) appendl(buf, s, \\\n    (__builtin_constant_p(s) ? sizeof(s)-1 : strlen(s)) )\n#else\nstatic void append(struct apbuf *buf, const char *s) {\n    appendl(buf, s, strlen(s));\n}\n#endif\n\nstatic void appendf(struct apbuf *buf, const char *format, ...)\n    __printflike(2, 3);\nstatic void appendf(struct apbuf *buf, const char *format, ...) {\n    char *tmp;\n    va_list va;\n    size_t len;\n\n    va_start(va, format);\n    len = xvasprintf(&tmp, format, va);\n    va_end(va);\n    appendl(buf, tmp, len);\n    free(tmp);\n}\n\n/* Make the specified socket non-blocking. */\nstatic void nonblock_socket(const int sock) {\n    int flags = fcntl(sock, F_GETFL);\n\n    if (flags == -1)\n        err(1, \"fcntl(F_GETFL)\");\n    flags |= O_NONBLOCK;\n    if (fcntl(sock, F_SETFL, flags) == -1)\n        err(1, \"fcntl() to set O_NONBLOCK\");\n}\n\n/* Split string out of src with range [left:right-1] */\nstatic char *split_string(const char *src,\n        const size_t left, const size_t right) {\n    char *dest;\n    assert(left <= right);\n    assert(left < strlen(src));   /* [left means must be smaller */\n    assert(right <= strlen(src)); /* right) means can be equal or smaller */\n\n    dest = xmalloc(right - left + 1);\n    memcpy(dest, src+left, right-left);\n    dest[right-left] = '\\0';\n    return dest;\n}\n\n/* Resolve /./ and /../ in a URL, in-place.\n * Returns NULL if the URL is invalid/unsafe, or the original buffer if\n * successful.\n */\nstatic char *make_safe_url(char *const url) {\n    char *src = url, *dst;\n    #define ends(c) ((c) == '/' || (c) == '\\0')\n\n    /* URLs not starting with a slash are illegal. */\n    if (*src != '/')\n        return NULL;\n\n    /* Fast case: skip until first double-slash or dot-dir. */\n    for ( ; *src; ++src) {\n        if (*src == '/') {\n            if (src[1] == '/')\n                break;\n            else if (src[1] == '.') {\n                if (ends(src[2]))\n                    break;\n                else if (src[2] == '.' && ends(src[3]))\n                    break;\n            }\n        }\n    }\n\n    /* Copy to dst, while collapsing multi-slashes and handling dot-dirs. */\n    dst = src;\n    while (*src) {\n        if (*src != '/')\n            *dst++ = *src++;\n        else if (*++src == '/')\n            ;\n        else if (*src != '.')\n            *dst++ = '/';\n        else if (ends(src[1]))\n            /* Ignore single-dot component. */\n            ++src;\n        else if (src[1] == '.' && ends(src[2])) {\n            /* Double-dot component. */\n            src += 2;\n            if (dst == url)\n                return NULL; /* Illegal URL */\n            else\n                /* Backtrack to previous slash. */\n                while (*--dst != '/' && dst > url);\n        }\n        else\n            *dst++ = '/';\n    }\n\n    if (dst == url)\n        ++dst;\n    *dst = '\\0';\n    return url;\n    #undef ends\n}\n\nstatic void add_forward_mapping(const char * const host,\n                                const char * const target_url) {\n    forward_map_size++;\n    forward_map = xrealloc(forward_map,\n                           sizeof(*forward_map) * forward_map_size);\n    forward_map[forward_map_size - 1].host = host;\n    forward_map[forward_map_size - 1].target_url = target_url;\n}\n\n/* Associates an extension with a mimetype in the mime_map.  Entries are in\n * unsorted order.  Makes copies of extension and mimetype strings.\n */\nstatic void add_mime_mapping(const char *extension, const char *mimetype) {\n    size_t i;\n    assert(strlen(extension) > 0);\n    assert(strlen(mimetype) > 0);\n\n    /* update longest_ext */\n    i = strlen(extension);\n    if (i > longest_ext)\n        longest_ext = i;\n\n    /* look through list and replace an existing entry if possible */\n    for (i = 0; i < mime_map_size; i++)\n        if (strcmp(mime_map[i].extension, extension) == 0) {\n            free(mime_map[i].mimetype);\n            mime_map[i].mimetype = xstrdup(mimetype);\n            return;\n        }\n\n    /* no replacement - add a new entry */\n    mime_map_size++;\n    mime_map = xrealloc(mime_map,\n        sizeof(struct mime_mapping) * mime_map_size);\n    mime_map[mime_map_size - 1].extension = xstrdup(extension);\n    mime_map[mime_map_size - 1].mimetype = xstrdup(mimetype);\n}\n\n/* qsort() the mime_map.  The map must be sorted before it can be\n * binary-searched.\n */\nstatic int mime_mapping_cmp(const void *a, const void *b) {\n    return strcmp(((const struct mime_mapping *)a)->extension,\n                  ((const struct mime_mapping *)b)->extension);\n}\n\nstatic void sort_mime_map(void) {\n    qsort(mime_map, mime_map_size, sizeof(struct mime_mapping),\n        mime_mapping_cmp);\n}\n\n/* Parses a mime.types line and adds the parsed data to the mime_map. */\nstatic void parse_mimetype_line(const char *line) {\n    unsigned int pad, bound1, lbound, rbound;\n\n    /* parse mimetype */\n    for (pad=0; (line[pad] == ' ') || (line[pad] == '\\t'); pad++)\n        ;\n    if (line[pad] == '\\0' || /* empty line */\n        line[pad] == '#')    /* comment */\n        return;\n\n    for (bound1=pad+1;\n        (line[bound1] != ' ') &&\n        (line[bound1] != '\\t');\n        bound1++) {\n        if (line[bound1] == '\\0')\n            return; /* malformed line */\n    }\n\n    lbound = bound1;\n    for (;;) {\n        char *mimetype, *extension;\n\n        /* find beginning of extension */\n        for (; (line[lbound] == ' ') || (line[lbound] == '\\t'); lbound++)\n            ;\n        if (line[lbound] == '\\0')\n            return; /* end of line */\n\n        /* find end of extension */\n        for (rbound = lbound;\n            line[rbound] != ' ' &&\n            line[rbound] != '\\t' &&\n            line[rbound] != '\\0';\n            rbound++)\n            ;\n\n        mimetype = split_string(line, pad, bound1);\n        extension = split_string(line, lbound, rbound);\n        add_mime_mapping(extension, mimetype);\n        free(mimetype);\n        free(extension);\n\n        if (line[rbound] == '\\0')\n            return; /* end of line */\n        else\n            lbound = rbound + 1;\n    }\n}\n\n/* Adds contents of default_extension_map[] to mime_map list.  The array must\n * be NULL terminated.\n */\nstatic void parse_default_extension_map(void) {\n    size_t i;\n\n    for (i = 0; default_extension_map[i] != NULL; i++)\n        parse_mimetype_line(default_extension_map[i]);\n}\n\n/* read a line from fp, return its contents in a dynamically allocated buffer,\n * not including the line ending.\n *\n * Handles CR, CRLF and LF line endings, as well as NOEOL correctly.  If\n * already at EOF, returns NULL.  Will err() or errx() in case of\n * unexpected file error or running out of memory.\n */\nstatic char *read_line(FILE *fp) {\n    char *buf;\n    long startpos, endpos;\n    size_t linelen, numread;\n    int c;\n\n    startpos = ftell(fp);\n    if (startpos == -1)\n        err(1, \"ftell()\");\n\n    /* find end of line (or file) */\n    linelen = 0;\n    for (;;) {\n        c = fgetc(fp);\n        if ((c == EOF) || (c == (int)'\\n') || (c == (int)'\\r'))\n            break;\n        linelen++;\n    }\n\n    /* return NULL on EOF (and empty line) */\n    if (linelen == 0 && c == EOF)\n        return NULL;\n\n    endpos = ftell(fp);\n    if (endpos == -1)\n        err(1, \"ftell()\");\n\n    /* skip CRLF */\n    if ((c == (int)'\\r') && (fgetc(fp) == (int)'\\n'))\n        endpos++;\n\n    buf = xmalloc(linelen + 1);\n\n    /* rewind file to where the line stared and load the line */\n    if (fseek(fp, startpos, SEEK_SET) == -1)\n        err(1, \"fseek()\");\n    numread = fread(buf, 1, linelen, fp);\n    if (numread != linelen)\n        errx(1, \"fread() %zu bytes, expecting %zu bytes\", numread, linelen);\n\n    /* terminate buffer */\n    buf[linelen] = 0;\n\n    /* advance file pointer over the endline */\n    if (fseek(fp, endpos, SEEK_SET) == -1)\n        err(1, \"fseek()\");\n\n    return buf;\n}\n\n/* ---------------------------------------------------------------------------\n * Adds contents of specified file to mime_map list.\n */\nstatic void parse_extension_map_file(const char *filename) {\n    char *buf;\n    FILE *fp = fopen(filename, \"rb\");\n\n    if (fp == NULL)\n        err(1, \"fopen(\\\"%s\\\")\", filename);\n    while ((buf = read_line(fp)) != NULL) {\n        parse_mimetype_line(buf);\n        free(buf);\n    }\n    fclose(fp);\n}\n\n/* Uses the mime_map to determine a Content-Type: for a requested URL.  This\n * bsearch()es mime_map, so make sure it's sorted first.\n */\nstatic int mime_mapping_cmp_str(const void *a, const void *b) {\n    return strcmp((const char *)a,\n                 ((const struct mime_mapping *)b)->extension);\n}\n\nstatic const char *url_content_type(const char *url) {\n    int period, urllen = (int)strlen(url);\n\n    for (period = urllen - 1;\n         (period > 0) && (url[period] != '.') &&\n         (urllen - period - 1 <= (int)longest_ext);\n         period--)\n            ;\n\n    if ((period >= 0) && (url[period] == '.')) {\n        struct mime_mapping *result =\n            bsearch((url + period + 1), mime_map, mime_map_size,\n                    sizeof(struct mime_mapping), mime_mapping_cmp_str);\n        if (result != NULL) {\n            assert(strcmp(url + period + 1, result->extension) == 0);\n            return result->mimetype;\n        }\n    }\n    /* else no period found in the string */\n    return default_mimetype;\n}\n\nstatic const char *get_address_text(const void *addr) {\n#ifdef HAVE_INET6\n    if (inet6) {\n        static char text_addr[INET6_ADDRSTRLEN];\n        inet_ntop(AF_INET6, (const struct in6_addr *)addr, text_addr,\n                  INET6_ADDRSTRLEN);\n        return text_addr;\n    } else\n#endif\n    {\n        return inet_ntoa(*(const struct in_addr *)addr);\n    }\n}\n\n/* Initialize the sockin global.  This is the socket that we accept\n * connections from.\n */\nstatic void init_sockin(void) {\n    struct sockaddr_in addrin;\n#ifdef HAVE_INET6\n    struct sockaddr_in6 addrin6;\n#endif\n    socklen_t addrin_len;\n    int sockopt;\n\n#ifdef HAVE_INET6\n    if (inet6) {\n        memset(&addrin6, 0, sizeof(addrin6));\n        if (inet_pton(AF_INET6, bindaddr ? bindaddr : \"::\",\n                      &addrin6.sin6_addr) == -1) {\n            errx(1, \"malformed --addr argument\");\n        }\n        sockin = socket(PF_INET6, SOCK_STREAM, 0);\n    } else\n#endif\n    {\n        memset(&addrin, 0, sizeof(addrin));\n        addrin.sin_addr.s_addr = bindaddr ? inet_addr(bindaddr) : INADDR_ANY;\n        if (addrin.sin_addr.s_addr == (in_addr_t)INADDR_NONE)\n            errx(1, \"malformed --addr argument\");\n        sockin = socket(PF_INET, SOCK_STREAM, 0);\n    }\n\n    if (sockin == -1)\n        err(1, \"socket()\");\n\n    /* reuse address */\n    sockopt = 1;\n    if (setsockopt(sockin, SOL_SOCKET, SO_REUSEADDR,\n                   &sockopt, sizeof(sockopt)) == -1)\n        err(1, \"setsockopt(SO_REUSEADDR)\");\n\n    /* disable Nagle since we buffer everything ourselves */\n    sockopt = 1;\n    if (setsockopt(sockin, IPPROTO_TCP, TCP_NODELAY,\n            &sockopt, sizeof(sockopt)) == -1)\n        err(1, \"setsockopt(TCP_NODELAY)\");\n\n#ifdef TORTURE\n    /* torture: cripple the kernel-side send buffer so we can only squeeze out\n     * one byte at a time (this is for debugging)\n     */\n    sockopt = 1;\n    if (setsockopt(sockin, SOL_SOCKET, SO_SNDBUF,\n            &sockopt, sizeof(sockopt)) == -1)\n        err(1, \"setsockopt(SO_SNDBUF)\");\n#endif\n\n    /* bind socket */\n#ifdef HAVE_INET6\n    if (inet6) {\n        addrin6.sin6_family = AF_INET6;\n        addrin6.sin6_port = htons(bindport);\n        if (bind(sockin, (struct sockaddr *)&addrin6,\n                 sizeof(struct sockaddr_in6)) == -1)\n            err(1, \"bind(port %u)\", bindport);\n\n        addrin_len = sizeof(addrin6);\n        if (getsockname(sockin, (struct sockaddr *)&addrin6, &addrin_len) == -1)\n            err(1, \"getsockname()\");\n        printf(\"listening on: http://[%s]:%u/\\n\",\n            get_address_text(&addrin6.sin6_addr), bindport);\n    } else\n#endif\n    {\n        addrin.sin_family = (u_char)PF_INET;\n        addrin.sin_port = htons(bindport);\n        if (bind(sockin, (struct sockaddr *)&addrin,\n                 sizeof(struct sockaddr_in)) == -1)\n            err(1, \"bind(port %u)\", bindport);\n        addrin_len = sizeof(addrin);\n        if (getsockname(sockin, (struct sockaddr *)&addrin, &addrin_len) == -1)\n            err(1, \"getsockname()\");\n        printf(\"listening on: http://%s:%u/\\n\",\n            get_address_text(&addrin.sin_addr), bindport);\n    }\n\n    /* listen on socket */\n    if (listen(sockin, max_connections) == -1)\n        err(1, \"listen()\");\n\n    /* enable acceptfilter (this is only available on FreeBSD) */\n    if (want_accf) {\n#if defined(__FreeBSD__)\n        struct accept_filter_arg filt = {\"httpready\", \"\"};\n        if (setsockopt(sockin, SOL_SOCKET, SO_ACCEPTFILTER,\n                       &filt, sizeof(filt)) == -1)\n            fprintf(stderr, \"cannot enable acceptfilter: %s\\n\",\n                strerror(errno));\n        else\n            printf(\"enabled acceptfilter\\n\");\n#else\n        printf(\"this platform doesn't support acceptfilter\\n\");\n#endif\n    }\n}\n\nstatic void usage(const char *argv0) {\n    printf(\"usage:\\t%s /path/to/wwwroot [flags]\\n\\n\", argv0);\n    printf(\"flags:\\t--port number (default: %u, or 80 if running as root)\\n\"\n    \"\\t\\tSpecifies which port to listen on for connections.\\n\"\n    \"\\t\\tPass 0 to let the system choose any free port for you.\\n\\n\", bindport);\n    printf(\"\\t--addr ip (default: all)\\n\"\n    \"\\t\\tIf multiple interfaces are present, specifies\\n\"\n    \"\\t\\twhich one to bind the listening port to.\\n\\n\");\n    printf(\"\\t--maxconn number (default: system maximum)\\n\"\n    \"\\t\\tSpecifies how many concurrent connections to accept.\\n\\n\");\n    printf(\"\\t--log filename (default: stdout)\\n\"\n    \"\\t\\tSpecifies which file to append the request log to.\\n\\n\");\n    printf(\"\\t--syslog\\n\"\n    \"\\t\\tUse syslog for request log.\\n\\n\");\n    printf(\"\\t--chroot (default: don't chroot)\\n\"\n    \"\\t\\tLocks server into wwwroot directory for added security.\\n\\n\");\n    printf(\"\\t--daemon (default: don't daemonize)\\n\"\n    \"\\t\\tDetach from the controlling terminal and run in the background.\\n\\n\");\n    printf(\"\\t--index filename (default: %s)\\n\"\n    \"\\t\\tDefault file to serve when a directory is requested.\\n\\n\",\n        index_name);\n    printf(\"\\t--no-listing\\n\"\n    \"\\t\\tDo not serve listing if directory is requested.\\n\\n\");\n    printf(\"\\t--mimetypes filename (optional)\\n\"\n    \"\\t\\tParses specified file for extension-MIME associations.\\n\\n\");\n    printf(\"\\t--default-mimetype string (optional, default: %s)\\n\"\n    \"\\t\\tFiles with unknown extensions are served as this mimetype.\\n\\n\",\n        octet_stream);\n    printf(\"\\t--uid uid/uname, --gid gid/gname (default: don't privdrop)\\n\"\n    \"\\t\\tDrops privileges to given uid:gid after initialization.\\n\\n\");\n    printf(\"\\t--pidfile filename (default: no pidfile)\\n\"\n    \"\\t\\tWrite PID to the specified file.  Note that if you are\\n\"\n    \"\\t\\tusing --chroot, then the pidfile must be relative to,\\n\"\n    \"\\t\\tand inside the wwwroot.\\n\\n\");\n    printf(\"\\t--no-keepalive\\n\"\n    \"\\t\\tDisables HTTP Keep-Alive functionality.\\n\\n\");\n#ifdef __FreeBSD__\n    printf(\"\\t--accf (default: don't use acceptfilter)\\n\"\n    \"\\t\\tUse acceptfilter.  Needs the accf_http module loaded.\\n\\n\");\n#endif\n    printf(\"\\t--forward host url (default: don't forward)\\n\"\n    \"\\t\\tWeb forward (301 redirect).\\n\"\n    \"\\t\\tRequests to the host are redirected to the corresponding url.\\n\"\n    \"\\t\\tThe option may be specified multiple times, in which case\\n\"\n    \"\\t\\tthe host is matched in order of appearance.\\n\\n\");\n    printf(\"\\t--forward-all url (default: don't forward)\\n\"\n    \"\\t\\tWeb forward (301 redirect).\\n\"\n    \"\\t\\tAll requests are redirected to the corresponding url.\\n\\n\");\n    printf(\"\\t--no-server-id\\n\"\n    \"\\t\\tDon't identify the server type in headers\\n\"\n    \"\\t\\tor directory listings.\\n\\n\");\n    printf(\"\\t--timeout secs (default: %d)\\n\"\n    \"\\t\\tIf a connection is idle for more than this many seconds,\\n\"\n    \"\\t\\tit will be closed. Set to zero to disable timeouts.\\n\\n\",\n    timeout_secs);\n    printf(\"\\t--auth username:password\\n\"\n    \"\\t\\tEnable basic authentication. This is *INSECURE*: passwords\\n\"\n    \"\\t\\tare sent unencrypted over HTTP, plus the password is visible\\n\"\n    \"\\t\\tin ps(1) to other users on the system.\\n\\n\");\n    printf(\"\\t--forward-https\\n\"\n    \"\\t\\tIf the client requested HTTP, forward to HTTPS.\\n\"\n    \"\\t\\tThis is useful if darkhttpd is behind a reverse proxy\\n\"\n    \"\\t\\tthat supports SSL.\\n\\n\");\n    printf(\"\\t--header 'Header: Value'\\n\"\n    \"\\t\\tAdd a custom header to all responses.\\n\"\n    \"\\t\\tThis option can be specified multiple times, in which case\\n\"\n    \"\\t\\tthe headers are added in order of appearance.\\n\\n\");\n#ifdef HAVE_INET6\n    printf(\"\\t--ipv6\\n\"\n    \"\\t\\tListen on IPv6 address.\\n\\n\");\n#else\n    printf(\"\\t(This binary was built without IPv6 support: -DNO_IPV6)\\n\\n\");\n#endif\n}\n\nstatic char *base64_encode(char *str) {\n    const char base64_table[] = {\n        'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',\n        'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',\n        'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',\n        'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',\n        'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',\n        'o', 'p', 'q', 'r', 's', 't', 'u', 'v',\n        'w', 'x', 'y', 'z', '0', '1', '2', '3',\n        '4', '5', '6', '7', '8', '9', '+', '/'};\n\n    int input_length = strlen(str);\n    int output_length = 4 * ((input_length + 2) / 3);\n\n    char *encoded_data = malloc(output_length+1);\n    if (encoded_data == NULL) return NULL;\n\n    int i;\n    int j;\n    for (i = 0, j = 0; i < input_length;) {\n        uint32_t octet_a = i < input_length ? (unsigned char)str[i++] : 0;\n        uint32_t octet_b = i < input_length ? (unsigned char)str[i++] : 0;\n        uint32_t octet_c = i < input_length ? (unsigned char)str[i++] : 0;\n\n        uint32_t triple = (octet_a << 0x10) + (octet_b << 0x08) + octet_c;\n\n        encoded_data[j++] = base64_table[(triple >> 3 * 6) & 0x3F];\n        encoded_data[j++] = base64_table[(triple >> 2 * 6) & 0x3F];\n        encoded_data[j++] = base64_table[(triple >> 1 * 6) & 0x3F];\n        encoded_data[j++] = base64_table[(triple >> 0 * 6) & 0x3F];\n    }\n\n    const int mod_table[] = {0, 2, 1};\n    for (i = 0; i < mod_table[input_length % 3]; i++)\n        encoded_data[output_length - 1 - i] = '=';\n    encoded_data[output_length] = '\\0';\n\n    return encoded_data;\n}\n\n/* Returns 1 if string is a number, 0 otherwise.  Set num to NULL if\n * disinterested in value.\n */\nstatic int str_to_num(const char *str, long long *num) {\n    char *endptr;\n    long long n;\n\n    errno = 0;\n    n = strtoll(str, &endptr, 10);\n    if (*endptr != '\\0')\n        return 0;\n    if (n == LLONG_MIN && errno == ERANGE)\n        return 0;\n    if (n == LLONG_MAX && errno == ERANGE)\n        return 0;\n    if (num != NULL)\n        *num = n;\n    return 1;\n}\n\n/* Returns a valid number or dies. */\nstatic long long xstr_to_num(const char *str) {\n    long long ret;\n\n    if (!str_to_num(str, &ret)) {\n        errx(1, \"number \\\"%s\\\" is invalid\", str);\n    }\n    return ret;\n}\n\nstatic void parse_commandline(const int argc, char *argv[]) {\n    int i;\n    size_t len;\n\n    if ((argc < 2) || (argc == 2 && strcmp(argv[1], \"--help\") == 0)) {\n        usage(argv[0]); /* no wwwroot given */\n        exit(EXIT_SUCCESS);\n    }\n\n    if (getuid() == 0)\n        bindport = 80;\n\n    custom_hdrs = strdup(\"\");\n\n    wwwroot = xstrdup(argv[1]);\n    /* Strip ending slash. */\n    len = strlen(wwwroot);\n    if (len > 0)\n        if (wwwroot[len - 1] == '/')\n            wwwroot[len - 1] = '\\0';\n\n    /* walk through the remainder of the arguments (if any) */\n    for (i = 2; i < argc; i++) {\n        if (strcmp(argv[i], \"--port\") == 0) {\n            if (++i >= argc)\n                errx(1, \"missing number after --port\");\n            bindport = (uint16_t)xstr_to_num(argv[i]);\n        }\n        else if (strcmp(argv[i], \"--addr\") == 0) {\n            if (++i >= argc)\n                errx(1, \"missing ip after --addr\");\n            bindaddr = argv[i];\n        }\n        else if (strcmp(argv[i], \"--maxconn\") == 0) {\n            if (++i >= argc)\n                errx(1, \"missing number after --maxconn\");\n            max_connections = (int)xstr_to_num(argv[i]);\n        }\n        else if (strcmp(argv[i], \"--log\") == 0) {\n            if (++i >= argc)\n                errx(1, \"missing filename after --log\");\n            logfile_name = argv[i];\n        }\n        else if (strcmp(argv[i], \"--chroot\") == 0) {\n            want_chroot = 1;\n        }\n        else if (strcmp(argv[i], \"--daemon\") == 0) {\n            want_daemon = 1;\n        }\n        else if (strcmp(argv[i], \"--index\") == 0) {\n            if (++i >= argc)\n                errx(1, \"missing filename after --index\");\n            index_name = argv[i];\n        }\n        else if (strcmp(argv[i], \"--no-listing\") == 0) {\n            no_listing = 1;\n        }\n        else if (strcmp(argv[i], \"--mimetypes\") == 0) {\n            if (++i >= argc)\n                errx(1, \"missing filename after --mimetypes\");\n            parse_extension_map_file(argv[i]);\n        }\n        else if (strcmp(argv[i], \"--default-mimetype\") == 0) {\n            if (++i >= argc)\n                errx(1, \"missing string after --default-mimetype\");\n            default_mimetype = argv[i];\n        }\n        else if (strcmp(argv[i], \"--uid\") == 0) {\n            struct passwd *p;\n            if (++i >= argc)\n                errx(1, \"missing uid after --uid\");\n            p = getpwnam(argv[i]);\n            if (!p) {\n                p = getpwuid((uid_t)xstr_to_num(argv[i]));\n            }\n            if (!p)\n                errx(1, \"no such uid: `%s'\", argv[i]);\n            drop_uid = p->pw_uid;\n        }\n        else if (strcmp(argv[i], \"--gid\") == 0) {\n            struct group *g;\n            if (++i >= argc)\n                errx(1, \"missing gid after --gid\");\n            g = getgrnam(argv[i]);\n            if (!g) {\n                g = getgrgid((gid_t)xstr_to_num(argv[i]));\n            }\n            if (!g) {\n                errx(1, \"no such gid: `%s'\", argv[i]);\n            }\n            drop_gid = g->gr_gid;\n        }\n        else if (strcmp(argv[i], \"--pidfile\") == 0) {\n            if (++i >= argc)\n                errx(1, \"missing filename after --pidfile\");\n            pidfile_name = argv[i];\n        }\n        else if (strcmp(argv[i], \"--no-keepalive\") == 0) {\n            want_keepalive = 0;\n        }\n        else if (strcmp(argv[i], \"--accf\") == 0) {\n            want_accf = 1;\n        }\n        else if (strcmp(argv[i], \"--syslog\") == 0) {\n            syslog_enabled = 1;\n        }\n        else if (strcmp(argv[i], \"--forward\") == 0) {\n            const char *host, *url;\n            if (++i >= argc)\n                errx(1, \"missing host after --forward\");\n            host = argv[i];\n            if (++i >= argc)\n                errx(1, \"missing url after --forward\");\n            url = argv[i];\n            add_forward_mapping(host, url);\n        }\n        else if (strcmp(argv[i], \"--forward-all\") == 0) {\n            if (++i >= argc)\n                errx(1, \"missing url after --forward-all\");\n            forward_all_url = argv[i];\n        }\n        else if (strcmp(argv[i], \"--no-server-id\") == 0) {\n            want_server_id = 0;\n        }\n        else if (strcmp(argv[i], \"--timeout\") == 0) {\n            if (++i >= argc)\n                errx(1, \"missing number after --timeout\");\n            timeout_secs = (int)xstr_to_num(argv[i]);\n        }\n        else if (strcmp(argv[i], \"--auth\") == 0) {\n            if (++i >= argc || strchr(argv[i], ':') == NULL)\n                errx(1, \"missing 'user:pass' after --auth\");\n\n            char *key = base64_encode(argv[i]);\n            xasprintf(&auth_key, \"Basic %s\", key);\n            free(key);\n        }\n        else if (strcmp(argv[i], \"--forward-https\") == 0) {\n            forward_to_https = 1;\n        }\n        else if (strcmp(argv[i], \"--header\") == 0) {\n            if (++i >= argc)\n                errx(1, \"missing argument after --header\");\n            if (strchr(argv[i], '\\n') != NULL || strstr(argv[i], \": \") == NULL)\n                errx(1, \"malformed argument after --header\");\n            char *old_custom_hdrs = custom_hdrs;\n            xasprintf(&custom_hdrs, \"%s%s\\r\\n\", old_custom_hdrs, argv[i]);\n            free(old_custom_hdrs);\n        }\n#ifdef HAVE_INET6\n        else if (strcmp(argv[i], \"--ipv6\") == 0) {\n            inet6 = 1;\n        }\n#endif\n        else\n            errx(1, \"unknown argument `%s'\", argv[i]);\n    }\n}\n\n/* Allocate and initialize an empty connection. */\nstatic struct connection *new_connection(void) {\n    struct connection *conn = xmalloc(sizeof(struct connection));\n\n    conn->socket = -1;\n    memset(&conn->client, 0, sizeof(conn->client));\n    conn->last_active = now;\n    conn->request = NULL;\n    conn->request_length = 0;\n    conn->method = NULL;\n    conn->url = NULL;\n    conn->referer = NULL;\n    conn->user_agent = NULL;\n    conn->authorization = NULL;\n    conn->range_begin = 0;\n    conn->range_end = 0;\n    conn->range_begin_given = 0;\n    conn->range_end_given = 0;\n    conn->header = NULL;\n    conn->header_length = 0;\n    conn->header_sent = 0;\n    conn->header_dont_free = 0;\n    conn->header_only = 0;\n    conn->http_code = 0;\n    conn->conn_close = 1;\n    conn->reply = NULL;\n    conn->reply_dont_free = 0;\n    conn->reply_fd = -1;\n    conn->reply_start = 0;\n    conn->reply_length = 0;\n    conn->reply_sent = 0;\n    conn->total_sent = 0;\n\n    /* Make it harmless so it gets garbage-collected if it should, for some\n     * reason, fail to be correctly filled out.\n     */\n    conn->state = DONE;\n\n    return conn;\n}\n\n/* Accept a connection from sockin and add it to the connection queue. */\nstatic void accept_connection(void) {\n    struct sockaddr_in addrin;\n#ifdef HAVE_INET6\n    struct sockaddr_in6 addrin6;\n#endif\n    socklen_t sin_size;\n    struct connection *conn;\n    int fd;\n\n#ifdef HAVE_INET6\n    if (inet6) {\n        sin_size = sizeof(addrin6);\n        memset(&addrin6, 0, sin_size);\n        fd = accept(sockin, (struct sockaddr *)&addrin6, &sin_size);\n    } else\n#endif\n    {\n        sin_size = sizeof(addrin);\n        memset(&addrin, 0, sin_size);\n        fd = accept(sockin, (struct sockaddr *)&addrin, &sin_size);\n    }\n\n    if (fd == -1) {\n        /* Failed to accept, but try to keep serving existing connections. */\n        if (errno == EMFILE || errno == ENFILE) accepting = 0;\n        warn(\"accept()\");\n        return;\n    }\n\n    /* Allocate and initialize struct connection. */\n    conn = new_connection();\n    conn->socket = fd;\n    nonblock_socket(conn->socket);\n    conn->state = RECV_REQUEST;\n\n#ifdef HAVE_INET6\n    if (inet6) {\n        conn->client = addrin6.sin6_addr;\n    } else\n#endif\n    {\n        *(in_addr_t *)&conn->client = addrin.sin_addr.s_addr;\n    }\n    LIST_INSERT_HEAD(&connlist, conn, entries);\n\n    if (debug)\n        printf(\"accepted connection from %s:%u (fd %d)\\n\",\n               inet_ntoa(addrin.sin_addr),\n               ntohs(addrin.sin_port),\n               conn->socket);\n\n    /* Try to read straight away rather than going through another iteration\n     * of the select() loop.\n     */\n    poll_recv_request(conn);\n}\n\n/* Should this character be logencoded?\n */\nstatic int needs_logencoding(const unsigned char c) {\n    return ((c <= 0x1F) || (c >= 0x7F) || (c == '\"'));\n}\n\n/* Encode string for logging.\n */\nstatic void logencode(const char *src, char *dest) {\n    static const char hex[] = \"0123456789ABCDEF\";\n    int i, j;\n\n    for (i = j = 0; src[i] != '\\0'; i++) {\n        if (needs_logencoding((unsigned char)src[i])) {\n            dest[j++] = '%';\n            dest[j++] = hex[(src[i] >> 4) & 0xF];\n            dest[j++] = hex[ src[i]       & 0xF];\n        }\n        else\n            dest[j++] = src[i];\n    }\n    dest[j] = '\\0';\n}\n\n/* Format [when] as a CLF date format, stored in the specified buffer.  The same\n * buffer is returned for convenience.\n */\n#define CLF_DATE_LEN 29 /* strlen(\"[10/Oct/2000:13:55:36 -0700]\")+1 */\nstatic char *clf_date(char *dest, const time_t when) {\n    time_t when_copy = when;\n    if (strftime(dest, CLF_DATE_LEN,\n                 \"[%d/%b/%Y:%H:%M:%S %z]\", localtime(&when_copy)) == 0) {\n        dest[0] = 0;\n    }\n    return dest;\n}\n\n/* Add a connection's details to the logfile. */\nstatic void log_connection(const struct connection *conn) {\n    char *safe_method, *safe_url, *safe_referer, *safe_user_agent,\n    dest[CLF_DATE_LEN];\n\n    if (logfile == NULL)\n        return;\n    if (conn->http_code == 0)\n        return; /* invalid - died in request */\n    if (conn->method == NULL)\n        return; /* invalid - didn't parse - maybe too long */\n\n#define make_safe(x) do { \\\n    if (conn->x) { \\\n        safe_##x = xmalloc(strlen(conn->x)*3 + 1); \\\n        logencode(conn->x, safe_##x); \\\n    } else { \\\n        safe_##x = NULL; \\\n    } \\\n} while(0)\n\n    make_safe(method);\n    make_safe(url);\n    make_safe(referer);\n    make_safe(user_agent);\n\n#define use_safe(x) safe_##x ? safe_##x : \"\"\n  if (syslog_enabled) {\n    syslog(LOG_INFO, \"%s - - %s \\\"%s %s HTTP/1.1\\\" %d %llu \\\"%s\\\" \\\"%s\\\"\\n\",\n        get_address_text(&conn->client),\n        clf_date(dest, now),\n        use_safe(method),\n        use_safe(url),\n        conn->http_code,\n        llu(conn->total_sent),\n        use_safe(referer),\n        use_safe(user_agent)\n        );\n  } else {\n    fprintf(logfile, \"%s - - %s \\\"%s %s HTTP/1.1\\\" %d %llu \\\"%s\\\" \\\"%s\\\"\\n\",\n        get_address_text(&conn->client),\n        clf_date(dest, now),\n        use_safe(method),\n        use_safe(url),\n        conn->http_code,\n        llu(conn->total_sent),\n        use_safe(referer),\n        use_safe(user_agent)\n        );\n    fflush(logfile);\n  }\n#define free_safe(x) if (safe_##x) free(safe_##x)\n\n    free_safe(method);\n    free_safe(url);\n    free_safe(referer);\n    free_safe(user_agent);\n\n#undef make_safe\n#undef use_safe\n#undef free_safe\n}\n\n/* Log a connection, then cleanly deallocate its internals. */\nstatic void free_connection(struct connection *conn) {\n    if (debug) printf(\"free_connection(%d)\\n\", conn->socket);\n    log_connection(conn);\n    if (conn->socket != -1) xclose(conn->socket);\n    if (conn->request != NULL) free(conn->request);\n    if (conn->method != NULL) free(conn->method);\n    if (conn->url != NULL) free(conn->url);\n    if (conn->referer != NULL) free(conn->referer);\n    if (conn->user_agent != NULL) free(conn->user_agent);\n    if (conn->authorization != NULL) free(conn->authorization);\n    if (conn->header != NULL && !conn->header_dont_free) free(conn->header);\n    if (conn->reply != NULL && !conn->reply_dont_free) free(conn->reply);\n    if (conn->reply_fd != -1) xclose(conn->reply_fd);\n    /* If we ran out of sockets, try to resume accepting. */\n    accepting = 1;\n}\n\n/* Recycle a finished connection for HTTP/1.1 Keep-Alive. */\nstatic void recycle_connection(struct connection *conn) {\n    int socket_tmp = conn->socket;\n    if (debug)\n        printf(\"recycle_connection(%d)\\n\", socket_tmp);\n    conn->socket = -1; /* so free_connection() doesn't close it */\n    free_connection(conn);\n    conn->socket = socket_tmp;\n\n    /* don't reset conn->client */\n    conn->request = NULL;\n    conn->request_length = 0;\n    conn->method = NULL;\n    conn->url = NULL;\n    conn->referer = NULL;\n    conn->user_agent = NULL;\n    conn->authorization = NULL;\n    conn->range_begin = 0;\n    conn->range_end = 0;\n    conn->range_begin_given = 0;\n    conn->range_end_given = 0;\n    conn->header = NULL;\n    conn->header_length = 0;\n    conn->header_sent = 0;\n    conn->header_dont_free = 0;\n    conn->header_only = 0;\n    conn->http_code = 0;\n    conn->conn_close = 1;\n    conn->reply = NULL;\n    conn->reply_dont_free = 0;\n    conn->reply_fd = -1;\n    conn->reply_start = 0;\n    conn->reply_length = 0;\n    conn->reply_sent = 0;\n    conn->total_sent = 0;\n\n    conn->state = RECV_REQUEST; /* ready for another */\n}\n\n/* Uppercasify all characters in a string of given length. */\nstatic void strntoupper(char *str, const size_t length) {\n    size_t i;\n\n    for (i = 0; i < length; i++)\n        str[i] = (char)toupper(str[i]);\n}\n\n/* If a connection has been idle for more than timeout_secs, it will be\n * marked as DONE and killed off in httpd_poll().\n */\nstatic void poll_check_timeout(struct connection *conn) {\n    if (timeout_secs > 0) {\n        if (now - conn->last_active >= timeout_secs) {\n            if (debug)\n                printf(\"poll_check_timeout(%d) closing connection\\n\",\n                       conn->socket);\n            conn->conn_close = 1;\n            conn->state = DONE;\n        }\n    }\n}\n\n/* Format [when] as an RFC1123 date, stored in the specified buffer.  The same\n * buffer is returned for convenience.\n */\n#define DATE_LEN 30 /* strlen(\"Fri, 28 Feb 2003 00:02:08 GMT\")+1 */\nstatic char *rfc1123_date(char *dest, const time_t when) {\n    time_t when_copy = when;\n    if (strftime(dest, DATE_LEN,\n                 \"%a, %d %b %Y %H:%M:%S GMT\", gmtime(&when_copy)) == 0) {\n        dest[0] = 0;\n    }\n    return dest;\n}\n\n/* Decode URL by converting %XX (where XX are hexadecimal digits) to the\n * character it represents.  Don't forget to free the return value.\n */\nstatic char *urldecode(const char *url) {\n    size_t i, pos, len = strlen(url);\n    char *out = xmalloc(len+1);\n\n    for (i = 0, pos = 0; i < len; i++) {\n        if ((url[i] == '%') && (i+2 < len) &&\n            isxdigit(url[i+1]) && isxdigit(url[i+2])) {\n            /* decode %XX */\n#define HEX_TO_DIGIT(hex) ( \\\n    ((hex) >= 'A' && (hex) <= 'F') ? ((hex)-'A'+10): \\\n    ((hex) >= 'a' && (hex) <= 'f') ? ((hex)-'a'+10): \\\n    ((hex)-'0') )\n\n            out[pos++] = HEX_TO_DIGIT(url[i+1]) * 16 +\n                         HEX_TO_DIGIT(url[i+2]);\n            i += 2;\n#undef HEX_TO_DIGIT\n        } else {\n            /* straight copy */\n            out[pos++] = url[i];\n        }\n    }\n    out[pos] = '\\0';\n    return out;\n}\n\n/* Returns Connection or Keep-Alive header, depending on conn_close. */\nstatic const char *keep_alive(const struct connection *conn)\n{\n    return (conn->conn_close ? \"Connection: close\\r\\n\" : keep_alive_field);\n}\n\n/* \"Generated by \" + pkgname + \" on \" + date + \"\\n\"\n *  1234567890123               1234            2 ('\\n' and '\\0')\n */\nstatic char _generated_on_buf[13 + sizeof(pkgname) - 1 + 4 + DATE_LEN + 2];\nstatic const char *generated_on(const char date[DATE_LEN]) {\n    if (!want_server_id)\n        return \"\";\n    snprintf(_generated_on_buf, sizeof(_generated_on_buf),\n            \"Generated by %s on %s\\n\",\n            pkgname, date);\n    return _generated_on_buf;\n}\n\n/* A default reply for any (erroneous) occasion. */\nstatic void default_reply(struct connection *conn,\n        const int errcode, const char *errname, const char *format, ...)\n        __printflike(4, 5);\nstatic void default_reply(struct connection *conn,\n        const int errcode, const char *errname, const char *format, ...) {\n    char *reason, date[DATE_LEN];\n    va_list va;\n\n    va_start(va, format);\n    xvasprintf(&reason, format, va);\n    va_end(va);\n\n    /* Only really need to calculate the date once. */\n    rfc1123_date(date, now);\n\n    conn->reply_length = xasprintf(&(conn->reply),\n     \"<html><head><title>%d %s</title></head><body>\\n\"\n     \"<h1>%s</h1>\\n\" /* errname */\n     \"%s\\n\" /* reason */\n     \"<hr>\\n\"\n     \"%s\" /* generated on */\n     \"</body></html>\\n\",\n     errcode, errname, errname, reason, generated_on(date));\n    free(reason);\n\n    const char auth_header[] =\n        \"WWW-Authenticate: Basic realm=\\\"User Visible Realm\\\"\\r\\n\";\n\n    conn->header_length = xasprintf(&(conn->header),\n     \"HTTP/1.1 %d %s\\r\\n\"\n     \"Date: %s\\r\\n\"\n     \"%s\" /* server */\n     \"Accept-Ranges: bytes\\r\\n\"\n     \"%s\" /* keep-alive */\n     \"%s\" /* custom headers */\n     \"Content-Length: %llu\\r\\n\"\n     \"Content-Type: text/html; charset=UTF-8\\r\\n\"\n     \"%s\"\n     \"\\r\\n\",\n     errcode, errname, date, server_hdr, keep_alive(conn),\n     custom_hdrs, llu(conn->reply_length),\n     (auth_key != NULL ? auth_header : \"\"));\n\n    conn->reply_type = REPLY_GENERATED;\n    conn->http_code = errcode;\n\n    /* Reset reply_start in case the request set a range. */\n    conn->reply_start = 0;\n}\n\nstatic void redirect(struct connection *conn, const char *format, ...)\n    __printflike(2, 3);\nstatic void redirect(struct connection *conn, const char *format, ...) {\n    char *where, date[DATE_LEN];\n    va_list va;\n\n    va_start(va, format);\n    xvasprintf(&where, format, va);\n    va_end(va);\n\n    /* Only really need to calculate the date once. */\n    rfc1123_date(date, now);\n\n    conn->reply_length = xasprintf(&(conn->reply),\n     \"<html><head><title>301 Moved Permanently</title></head><body>\\n\"\n     \"<h1>Moved Permanently</h1>\\n\"\n     \"Moved to: <a href=\\\"%s\\\">%s</a>\\n\" /* where x 2 */\n     \"<hr>\\n\"\n     \"%s\" /* generated on */\n     \"</body></html>\\n\",\n     where, where, generated_on(date));\n\n    conn->header_length = xasprintf(&(conn->header),\n     \"HTTP/1.1 301 Moved Permanently\\r\\n\"\n     \"Date: %s\\r\\n\"\n     \"%s\" /* server */\n     /* \"Accept-Ranges: bytes\\r\\n\" - not relevant here */\n     \"Location: %s\\r\\n\"\n     \"%s\" /* keep-alive */\n     \"%s\" /* custom headers */\n     \"Content-Length: %llu\\r\\n\"\n     \"Content-Type: text/html; charset=UTF-8\\r\\n\"\n     \"\\r\\n\",\n     date, server_hdr, where, keep_alive(conn),\n     custom_hdrs, llu(conn->reply_length));\n\n    free(where);\n    conn->reply_type = REPLY_GENERATED;\n    conn->http_code = 301;\n}\n\n/* Parses a single HTTP request field.  Returns string from end of [field] to\n * first \\r, \\n or end of request string.  Returns NULL if [field] can't be\n * matched.  Case insensitive.\n *\n * You need to remember to deallocate the result.\n * example: parse_field(conn, \"Referer: \");\n */\nstatic char *parse_field(const struct connection *conn, const char *field) {\n    size_t bound1, bound2;\n    char *pos;\n\n    /* find start */\n    pos = strcasestr(conn->request, field);\n    if (pos == NULL)\n        return NULL;\n    assert(pos >= conn->request);\n    bound1 = (size_t)(pos - conn->request) + strlen(field);\n\n    /* find end */\n    for (bound2 = bound1;\n         ((bound2 < conn->request_length) &&\n          (conn->request[bound2] != '\\r') &&\n          (conn->request[bound2] != '\\n'));\n         bound2++)\n            ;\n\n    /* copy to buffer */\n    return split_string(conn->request, bound1, bound2);\n}\n\nstatic void redirect_https(struct connection *conn) {\n    char *host, *url;\n\n    /* work out path of file being requested */\n    url = urldecode(conn->url);\n\n    /* make sure it's safe */\n    if (make_safe_url(url) == NULL) {\n        default_reply(conn, 400, \"Bad Request\",\n                      \"You requested an invalid URL.\");\n        free(url);\n        return;\n    }\n\n    host = parse_field(conn, \"Host: \");\n    if (host == NULL) {\n        default_reply(conn, 400, \"Bad Request\",\n                \"Missing 'Host' header.\");\n        free(url);\n        return;\n    }\n\n    redirect(conn, \"https://%s%s\", host, url);\n    free(host);\n    free(url);\n}\n\nstatic int is_https_redirect(struct connection *conn) {\n    char *proto = NULL;\n\n    if (forward_to_https == 0)\n        return 0; /* --forward-https was never used */\n\n    proto = parse_field(conn, \"X-Forwarded-Proto: \");\n    if (proto == NULL || strcasecmp(proto, \"https\") == 0) {\n        free(proto);\n        return 0;\n    }\n\n    free(proto);\n    return 1;\n}\n\n/* Parse a Range: field into range_begin and range_end.  Only handles the\n * first range if a list is given.  Sets range_{begin,end}_given to 1 if\n * either part of the range is given.\n */\nstatic void parse_range_field(struct connection *conn) {\n    char *range;\n\n    range = parse_field(conn, \"Range: bytes=\");\n    if (range == NULL)\n        return;\n\n    do {\n        size_t bound1, bound2, len;\n        len = strlen(range);\n\n        /* parse number up to hyphen */\n        bound1 = 0;\n        for (bound2=0;\n            (bound2 < len) && isdigit((int)range[bound2]);\n            bound2++)\n                ;\n\n        if ((bound2 == len) || (range[bound2] != '-'))\n            break; /* there must be a hyphen here */\n\n        if (bound1 != bound2) {\n            conn->range_begin_given = 1;\n            conn->range_begin = (off_t)strtoll(range+bound1, NULL, 10);\n        }\n\n        /* parse number after hyphen */\n        bound2++;\n        for (bound1=bound2;\n            (bound2 < len) && isdigit((int)range[bound2]);\n            bound2++)\n                ;\n\n        if ((bound2 != len) && (range[bound2] != ','))\n            break; /* must be end of string or a list to be valid */\n\n        if (bound1 != bound2) {\n            conn->range_end_given = 1;\n            conn->range_end = (off_t)strtoll(range+bound1, NULL, 10);\n        }\n    } while(0);\n    free(range);\n}\n\n/* Parse an HTTP request like \"GET / HTTP/1.1\" to get the method (GET), the\n * url (/), the referer (if given) and the user-agent (if given).  Remember to\n * deallocate all these buffers.  The method will be returned in uppercase.\n */\nstatic int parse_request(struct connection *conn) {\n    size_t bound1, bound2;\n    char *tmp;\n    assert(conn->request_length == strlen(conn->request));\n\n    /* parse method */\n    for (bound1 = 0;\n        (bound1 < conn->request_length) &&\n        (conn->request[bound1] != ' ');\n        bound1++)\n            ;\n\n    conn->method = split_string(conn->request, 0, bound1);\n    strntoupper(conn->method, bound1);\n\n    /* parse url */\n    for (;\n        (bound1 < conn->request_length) &&\n        (conn->request[bound1] == ' ');\n        bound1++)\n            ;\n\n    if (bound1 == conn->request_length)\n        return 0; /* fail */\n\n    for (bound2 = bound1 + 1;\n        (bound2 < conn->request_length) &&\n        (conn->request[bound2] != ' ') &&\n        (conn->request[bound2] != '\\r') &&\n        (conn->request[bound2] != '\\n');\n        bound2++)\n            ;\n\n    conn->url = split_string(conn->request, bound1, bound2);\n\n    /* parse protocol to determine conn_close */\n    if (conn->request[bound2] == ' ') {\n        char *proto;\n        for (bound1 = bound2;\n            (bound1 < conn->request_length) &&\n            (conn->request[bound1] == ' ');\n            bound1++)\n                ;\n\n        for (bound2 = bound1 + 1;\n            (bound2 < conn->request_length) &&\n            (conn->request[bound2] != ' ') &&\n            (conn->request[bound2] != '\\r');\n            bound2++)\n                ;\n\n        proto = split_string(conn->request, bound1, bound2);\n        if (strcasecmp(proto, \"HTTP/1.1\") == 0)\n            conn->conn_close = 0;\n        free(proto);\n    }\n\n    /* parse connection field */\n    tmp = parse_field(conn, \"Connection: \");\n    if (tmp != NULL) {\n        if (strcasecmp(tmp, \"close\") == 0)\n            conn->conn_close = 1;\n        else if (strcasecmp(tmp, \"keep-alive\") == 0)\n            conn->conn_close = 0;\n        free(tmp);\n    }\n\n    /* cmdline flag can be used to deny keep-alive */\n    if (!want_keepalive)\n        conn->conn_close = 1;\n\n    /* parse important fields */\n    conn->referer = parse_field(conn, \"Referer: \");\n    conn->user_agent = parse_field(conn, \"User-Agent: \");\n    conn->authorization = parse_field(conn, \"Authorization: \");\n    parse_range_field(conn);\n    return 1;\n}\n\nstatic int file_exists(const char *path) {\n    struct stat filestat;\n    if ((stat(path, &filestat) == -1) && (errno == ENOENT))\n        return 0;\n    else\n        return 1;\n}\n\nstruct dlent {\n    char *name;\n    int is_dir;\n    off_t size;\n};\n\nstatic int dlent_cmp(const void *a, const void *b) {\n    if (strcmp((*((const struct dlent * const *)a))->name, \"..\") == 0) {\n        return -1;  /* Special-case \"..\" to come first. */\n    }\n    return strcmp((*((const struct dlent * const *)a))->name,\n                  (*((const struct dlent * const *)b))->name);\n}\n\n/* Make sorted list of files in a directory.  Returns number of entries, or -1\n * if error occurs.\n */\nstatic ssize_t make_sorted_dirlist(const char *path, struct dlent ***output) {\n    DIR *dir;\n    struct dirent *ent;\n    size_t entries = 0;\n    size_t pool = 128;\n    char *currname;\n    struct dlent **list = NULL;\n\n    dir = opendir(path);\n    if (dir == NULL)\n        return -1;\n\n    currname = xmalloc(strlen(path) + MAXNAMLEN + 1);\n    list = xmalloc(sizeof(struct dlent*) * pool);\n\n    /* construct list */\n    while ((ent = readdir(dir)) != NULL) {\n        struct stat s;\n\n        if (strcmp(ent->d_name, \".\") == 0)\n            continue; /* skip \".\" */\n        assert(strlen(ent->d_name) <= MAXNAMLEN);\n        sprintf(currname, \"%s%s\", path, ent->d_name);\n        if (stat(currname, &s) == -1)\n            continue; /* skip un-stat-able files */\n        if (entries == pool) {\n            pool *= 2;\n            list = xrealloc(list, sizeof(struct dlent*) * pool);\n        }\n        list[entries] = xmalloc(sizeof(struct dlent));\n        list[entries]->name = xstrdup(ent->d_name);\n        list[entries]->is_dir = S_ISDIR(s.st_mode);\n        list[entries]->size = s.st_size;\n        entries++;\n    }\n    closedir(dir);\n    free(currname);\n    qsort(list, entries, sizeof(struct dlent*), dlent_cmp);\n    *output = list;\n    return (ssize_t)entries;\n}\n\n/* Cleanly deallocate a sorted list of directory files. */\nstatic void cleanup_sorted_dirlist(struct dlent **list, const ssize_t size) {\n    ssize_t i;\n\n    for (i = 0; i < size; i++) {\n        free(list[i]->name);\n        free(list[i]);\n    }\n}\n\n/* Is this an unreserved character according to\n * https://tools.ietf.org/html/rfc3986#section-2.3\n */\nstatic int is_unreserved(const unsigned char c) {\n    if (c >= 'a' && c <= 'z') return 1;\n    if (c >= 'A' && c <= 'Z') return 1;\n    if (c >= '0' && c <= '9') return 1;\n    switch (c) {\n        case '-':\n        case '.':\n        case '_':\n        case '~':\n            return 1;\n    }\n    return 0;\n}\n\n/* Encode string to be an RFC3986-compliant URL part.\n * Contributed by nf.\n */\nstatic void urlencode(const char *src, char *dest) {\n    static const char hex[] = \"0123456789ABCDEF\";\n    int i, j;\n\n    for (i = j = 0; src[i] != '\\0'; i++) {\n        if (!is_unreserved((unsigned char)src[i])) {\n            dest[j++] = '%';\n            dest[j++] = hex[(src[i] >> 4) & 0xF];\n            dest[j++] = hex[ src[i]       & 0xF];\n        }\n        else\n            dest[j++] = src[i];\n    }\n    dest[j] = '\\0';\n}\n\n/* Escape < > & ' \" into HTML entities. */\nstatic void append_escaped(struct apbuf *dst, const char *src) {\n    int pos = 0;\n    while (src[pos] != '\\0') {\n        switch (src[pos]) {\n            case '<':\n                append(dst, \"&lt;\");\n                break;\n            case '>':\n                append(dst, \"&gt;\");\n                break;\n            case '&':\n                append(dst, \"&amp;\");\n                break;\n            case '\\'':\n                append(dst, \"&apos;\");\n                break;\n            case '\"':\n                append(dst, \"&quot;\");\n                break;\n            default:\n                appendl(dst, src+pos, 1);\n        }\n        pos++;\n    }\n}\n\nstatic void generate_dir_listing(struct connection *conn, const char *path,\n        const char *decoded_url) {\n    char date[DATE_LEN], *spaces;\n    struct dlent **list;\n    ssize_t listsize;\n    size_t maxlen = 2; /* There has to be \"..\" */\n    int i;\n    struct apbuf *listing;\n\n    listsize = make_sorted_dirlist(path, &list);\n    if (listsize == -1) {\n        default_reply(conn, 500, \"Internal Server Error\",\n                      \"Couldn't list directory: %s\", strerror(errno));\n        return;\n    }\n\n    for (i=0; i<listsize; i++) {\n        size_t tmp = strlen(list[i]->name);\n        if (maxlen < tmp)\n            maxlen = tmp;\n    }\n\n    listing = make_apbuf();\n    append(listing, \"<html>\\n<head>\\n<title>\");\n    append_escaped(listing, decoded_url);\n    append(listing,\n            \"</title>\\n\"\n            \"<meta name=\\\"viewport\\\" content=\\\"width=device-width, initial-scale=1\\\">\\n\"\n            \"</head>\\n<body>\\n<h1>\");\n    append_escaped(listing, decoded_url);\n    append(listing, \"</h1>\\n<tt><pre>\\n\");\n\n    spaces = xmalloc(maxlen);\n    memset(spaces, ' ', maxlen);\n\n    for (i=0; i<listsize; i++) {\n        /* If a filename is made up of entirely unsafe chars,\n         * the url would be three times its original length.\n         */\n        char safe_url[MAXNAMLEN*3 + 1];\n\n        urlencode(list[i]->name, safe_url);\n\n        append(listing, \"<a href=\\\"\");\n        append(listing, safe_url);\n        if (list[i]->is_dir)\n            append(listing, \"/\");\n        append(listing, \"\\\">\");\n        append_escaped(listing, list[i]->name);\n        append(listing, \"</a>\");\n\n        if (list[i]->is_dir)\n            append(listing, \"/\\n\");\n        else {\n            appendl(listing, spaces, maxlen-strlen(list[i]->name));\n            appendf(listing, \"%10llu\\n\", llu(list[i]->size));\n        }\n    }\n\n    cleanup_sorted_dirlist(list, listsize);\n    free(list);\n    free(spaces);\n\n    append(listing,\n     \"</pre></tt>\\n\"\n     \"<hr>\\n\");\n\n    rfc1123_date(date, now);\n    append(listing, generated_on(date));\n    append(listing, \"</body>\\n</html>\\n\");\n\n    conn->reply = listing->str;\n    conn->reply_length = (off_t)listing->length;\n    free(listing); /* don't free inside of listing */\n\n    conn->header_length = xasprintf(&(conn->header),\n     \"HTTP/1.1 200 OK\\r\\n\"\n     \"Date: %s\\r\\n\"\n     \"%s\" /* server */\n     \"Accept-Ranges: bytes\\r\\n\"\n     \"%s\" /* keep-alive */\n     \"%s\" /* custom headers */\n     \"Content-Length: %llu\\r\\n\"\n     \"Content-Type: text/html; charset=UTF-8\\r\\n\"\n     \"\\r\\n\",\n     date, server_hdr, keep_alive(conn), custom_hdrs,\n     llu(conn->reply_length));\n\n    conn->reply_type = REPLY_GENERATED;\n    conn->http_code = 200;\n}\n\n/* Process a GET/HEAD request. */\nstatic void process_get(struct connection *conn) {\n    char *decoded_url, *end, *target, *if_mod_since;\n    char date[DATE_LEN], lastmod[DATE_LEN];\n    const char *mimetype = NULL;\n    const char *forward_to = NULL;\n    struct stat filestat;\n\n    /* strip out query params */\n    if ((end = strchr(conn->url, '?')) != NULL)\n        *end = '\\0';\n\n    /* work out path of file being requested */\n    decoded_url = urldecode(conn->url);\n\n    /* make sure it's safe */\n    if (make_safe_url(decoded_url) == NULL) {\n        default_reply(conn, 400, \"Bad Request\",\n                      \"You requested an invalid URL.\");\n        free(decoded_url);\n        return;\n    }\n\n    /* test the host against web forward options */\n    if (forward_map) {\n        char *host = parse_field(conn, \"Host: \");\n        if (host) {\n            size_t i;\n            if (debug)\n                printf(\"host=\\\"%s\\\"\\n\", host);\n            for (i = 0; i < forward_map_size; i++) {\n                if (strcasecmp(forward_map[i].host, host) == 0) {\n                    forward_to = forward_map[i].target_url;\n                    break;\n                }\n            }\n            free(host);\n        }\n    }\n    if (!forward_to) {\n        forward_to = forward_all_url;\n    }\n    if (forward_to) {\n        redirect(conn, \"%s%s\", forward_to, decoded_url);\n        free(decoded_url);\n        return;\n    }\n\n    /* does it end in a slash? serve up url/index_name */\n    if (decoded_url[strlen(decoded_url)-1] == '/') {\n        xasprintf(&target, \"%s%s%s\", wwwroot, decoded_url, index_name);\n        if (!file_exists(target)) {\n            free(target);\n            if (no_listing) {\n                free(decoded_url);\n                /* Return 404 instead of 403 to make --no-listing\n                 * indistinguishable from the directory not existing.\n                 * i.e.: Don't leak information.\n                 */\n                default_reply(conn, 404, \"Not Found\",\n                    \"The URL you requested was not found.\");\n                return;\n            }\n            xasprintf(&target, \"%s%s\", wwwroot, decoded_url);\n            generate_dir_listing(conn, target, decoded_url);\n            free(target);\n            free(decoded_url);\n            return;\n        }\n        mimetype = url_content_type(index_name);\n    }\n    else {\n        /* points to a file */\n        xasprintf(&target, \"%s%s\", wwwroot, decoded_url);\n        mimetype = url_content_type(decoded_url);\n    }\n    free(decoded_url);\n    if (debug)\n        printf(\"url=\\\"%s\\\", target=\\\"%s\\\", content-type=\\\"%s\\\"\\n\",\n               conn->url, target, mimetype);\n\n    /* open file */\n    conn->reply_fd = open(target, O_RDONLY | O_NONBLOCK);\n    free(target);\n\n    if (conn->reply_fd == -1) {\n        /* open() failed */\n        if (errno == EACCES)\n            default_reply(conn, 403, \"Forbidden\",\n                \"You don't have permission to access this URL.\");\n        else if (errno == ENOENT)\n            default_reply(conn, 404, \"Not Found\",\n                \"The URL you requested was not found.\");\n        else\n            default_reply(conn, 500, \"Internal Server Error\",\n                \"The URL you requested cannot be returned: %s.\",\n                strerror(errno));\n\n        return;\n    }\n\n    /* stat the file */\n    if (fstat(conn->reply_fd, &filestat) == -1) {\n        default_reply(conn, 500, \"Internal Server Error\",\n            \"fstat() failed: %s.\", strerror(errno));\n        return;\n    }\n\n    /* make sure it's a regular file */\n    if (S_ISDIR(filestat.st_mode)) {\n        redirect(conn, \"%s/\", conn->url);\n        return;\n    }\n    else if (!S_ISREG(filestat.st_mode)) {\n        default_reply(conn, 403, \"Forbidden\", \"Not a regular file.\");\n        return;\n    }\n\n    conn->reply_type = REPLY_FROMFILE;\n    rfc1123_date(lastmod, filestat.st_mtime);\n\n    /* check for If-Modified-Since, may not have to send */\n    if_mod_since = parse_field(conn, \"If-Modified-Since: \");\n    if ((if_mod_since != NULL) &&\n            (strcmp(if_mod_since, lastmod) == 0)) {\n        if (debug)\n            printf(\"not modified since %s\\n\", if_mod_since);\n        conn->http_code = 304;\n        conn->header_length = xasprintf(&(conn->header),\n         \"HTTP/1.1 304 Not Modified\\r\\n\"\n         \"Date: %s\\r\\n\"\n         \"%s\" /* server */\n         \"Accept-Ranges: bytes\\r\\n\"\n         \"%s\" /* keep-alive */\n         \"%s\" /* custom headers */\n         \"\\r\\n\",\n         rfc1123_date(date, now), server_hdr, keep_alive(conn),\n         custom_hdrs);\n        conn->reply_length = 0;\n        conn->reply_type = REPLY_GENERATED;\n        conn->header_only = 1;\n\n        free(if_mod_since);\n        return;\n    }\n    free(if_mod_since);\n\n    if (conn->range_begin_given || conn->range_end_given) {\n        off_t from, to;\n\n        if (conn->range_begin_given && conn->range_end_given) {\n            /* 100-200 */\n            from = conn->range_begin;\n            to = conn->range_end;\n\n            /* clamp end to filestat.st_size-1 */\n            if (to > (filestat.st_size - 1))\n                to = filestat.st_size - 1;\n        }\n        else if (conn->range_begin_given && !conn->range_end_given) {\n            /* 100- :: yields 100 to end */\n            from = conn->range_begin;\n            to = filestat.st_size - 1;\n        }\n        else if (!conn->range_begin_given && conn->range_end_given) {\n            /* -200 :: yields last 200 */\n            to = filestat.st_size - 1;\n            from = to - conn->range_end + 1;\n\n            /* clamp start */\n            if (from < 0)\n                from = 0;\n        }\n        else\n            errx(1, \"internal error - from/to mismatch\");\n\n        if (from >= filestat.st_size) {\n            default_reply(conn, 416, \"Requested Range Not Satisfiable\",\n                \"You requested a range outside of the file.\");\n            return;\n        }\n\n        if (to < from) {\n            default_reply(conn, 416, \"Requested Range Not Satisfiable\",\n                \"You requested a backward range.\");\n            return;\n        }\n\n        conn->reply_start = from;\n        conn->reply_length = to - from + 1;\n\n        conn->header_length = xasprintf(&(conn->header),\n            \"HTTP/1.1 206 Partial Content\\r\\n\"\n            \"Date: %s\\r\\n\"\n            \"%s\" /* server */\n            \"Accept-Ranges: bytes\\r\\n\"\n            \"%s\" /* keep-alive */\n            \"%s\" /* custom headers */\n            \"Content-Length: %llu\\r\\n\"\n            \"Content-Range: bytes %llu-%llu/%llu\\r\\n\"\n            \"Content-Type: %s\\r\\n\"\n            \"Last-Modified: %s\\r\\n\"\n            \"\\r\\n\"\n            ,\n            rfc1123_date(date, now), server_hdr, keep_alive(conn),\n            custom_hdrs,\n            llu(conn->reply_length), llu(from), llu(to),\n            llu(filestat.st_size), mimetype, lastmod\n        );\n        conn->http_code = 206;\n        if (debug)\n            printf(\"sending %llu-%llu/%llu\\n\",\n                   llu(from), llu(to), llu(filestat.st_size));\n    }\n    else {\n        /* no range stuff */\n        conn->reply_length = filestat.st_size;\n        conn->header_length = xasprintf(&(conn->header),\n            \"HTTP/1.1 200 OK\\r\\n\"\n            \"Date: %s\\r\\n\"\n            \"%s\" /* server */\n            \"Accept-Ranges: bytes\\r\\n\"\n            \"%s\" /* keep-alive */\n            \"%s\" /* custom headers */\n            \"Content-Length: %llu\\r\\n\"\n            \"Content-Type: %s\\r\\n\"\n            \"Last-Modified: %s\\r\\n\"\n            \"\\r\\n\"\n            ,\n            rfc1123_date(date, now), server_hdr, keep_alive(conn),\n            custom_hdrs, llu(conn->reply_length), mimetype, lastmod\n        );\n        conn->http_code = 200;\n    }\n}\n\n/* Returns 1 if passwords are equal, runtime is proportional to the length of\n * user_input to avoid leaking the secret's length and contents through timing\n * information.\n */\nint password_equal(const char *user_input, const char *secret) {\n    size_t i = 0;\n    size_t j = 0;\n    char out = 0;\n\n    while (1) {\n        /* Out stays zero if the strings are the same. */\n        out |= user_input[i] ^ secret[j];\n\n        /* Stop at end of user_input. */\n        if (user_input[i] == 0) break;\n        i++;\n\n        /* Don't go past end of secret. */\n        if (secret[j] != 0) j++;\n    }\n\n    /* Check length after loop, otherwise early exit would leak length. */\n    out |= (i != j); /* Secret was shorter. */\n    out |= (secret[j] != 0); /* Secret was longer; j is not the end. */\n    return out == 0;\n}\n\n/* Process a request: build the header and reply, advance state. */\nstatic void process_request(struct connection *conn) {\n    num_requests++;\n\n    if (!parse_request(conn)) {\n        default_reply(conn, 400, \"Bad Request\",\n            \"You sent a request that the server couldn't understand.\");\n    }\n    else if (is_https_redirect(conn)) {\n        redirect_https(conn);\n    }\n    /* fail if: (auth_enabled) AND (client supplied invalid credentials) */\n    else if (auth_key != NULL &&\n            (conn->authorization == NULL ||\n             !password_equal(conn->authorization, auth_key))) {\n        default_reply(conn, 401, \"Unauthorized\",\n            \"Access denied due to invalid credentials.\");\n    }\n    else if (strcmp(conn->method, \"GET\") == 0) {\n        process_get(conn);\n    }\n    else if (strcmp(conn->method, \"HEAD\") == 0) {\n        process_get(conn);\n        conn->header_only = 1;\n    }\n    else {\n        default_reply(conn, 501, \"Not Implemented\",\n                      \"The method you specified is not implemented.\");\n    }\n\n    /* advance state */\n    conn->state = SEND_HEADER;\n\n    /* request not needed anymore */\n    free(conn->request);\n    conn->request = NULL; /* important: don't free it again later */\n}\n\n/* Receiving request. */\nstatic void poll_recv_request(struct connection *conn) {\n    char buf[1<<15];\n    ssize_t recvd;\n\n    assert(conn->state == RECV_REQUEST);\n    recvd = recv(conn->socket, buf, sizeof(buf), 0);\n    if (debug)\n        printf(\"poll_recv_request(%d) got %d bytes\\n\",\n               conn->socket, (int)recvd);\n    if (recvd < 1) {\n        if (recvd == -1) {\n            if (errno == EAGAIN) {\n                if (debug) printf(\"poll_recv_request would have blocked\\n\");\n                return;\n            }\n            if (debug) printf(\"recv(%d) error: %s\\n\",\n                conn->socket, strerror(errno));\n        }\n        conn->conn_close = 1;\n        conn->state = DONE;\n        return;\n    }\n    conn->last_active = now;\n\n    /* append to conn->request */\n    assert(recvd > 0);\n    conn->request = xrealloc(\n        conn->request, conn->request_length + (size_t)recvd + 1);\n    memcpy(conn->request+conn->request_length, buf, (size_t)recvd);\n    conn->request_length += (size_t)recvd;\n    conn->request[conn->request_length] = 0;\n    total_in += (size_t)recvd;\n\n    /* process request if we have all of it */\n    if ((conn->request_length > 2) &&\n        (memcmp(conn->request+conn->request_length-2, \"\\n\\n\", 2) == 0))\n            process_request(conn);\n    else if ((conn->request_length > 4) &&\n        (memcmp(conn->request+conn->request_length-4, \"\\r\\n\\r\\n\", 4) == 0))\n            process_request(conn);\n\n    /* die if it's too large */\n    if (conn->request_length > MAX_REQUEST_LENGTH) {\n        default_reply(conn, 413, \"Request Entity Too Large\",\n                      \"Your request was dropped because it was too long.\");\n        conn->state = SEND_HEADER;\n    }\n\n    /* if we've moved on to the next state, try to send right away, instead of\n     * going through another iteration of the select() loop.\n     */\n    if (conn->state == SEND_HEADER)\n        poll_send_header(conn);\n}\n\n/* Sending header.  Assumes conn->header is not NULL. */\nstatic void poll_send_header(struct connection *conn) {\n    ssize_t sent;\n\n    assert(conn->state == SEND_HEADER);\n    assert(conn->header_length == strlen(conn->header));\n\n    sent = send(conn->socket,\n                conn->header + conn->header_sent,\n                conn->header_length - conn->header_sent,\n                0);\n    conn->last_active = now;\n    if (debug)\n        printf(\"poll_send_header(%d) sent %d bytes\\n\",\n               conn->socket, (int)sent);\n\n    /* handle any errors (-1) or closure (0) in send() */\n    if (sent < 1) {\n        if ((sent == -1) && (errno == EAGAIN)) {\n            if (debug) printf(\"poll_send_header would have blocked\\n\");\n            return;\n        }\n        if (debug && (sent == -1))\n            printf(\"send(%d) error: %s\\n\", conn->socket, strerror(errno));\n        conn->conn_close = 1;\n        conn->state = DONE;\n        return;\n    }\n    assert(sent > 0);\n    conn->header_sent += (size_t)sent;\n    conn->total_sent += (size_t)sent;\n    total_out += (size_t)sent;\n\n    /* check if we're done sending header */\n    if (conn->header_sent == conn->header_length) {\n        if (conn->header_only)\n            conn->state = DONE;\n        else {\n            conn->state = SEND_REPLY;\n            /* go straight on to body, don't go through another iteration of\n             * the select() loop.\n             */\n            poll_send_reply(conn);\n        }\n    }\n}\n\n/* Send chunk on socket <s> from FILE *fp, starting at <ofs> and of size\n * <size>.  Use sendfile() if possible since it's zero-copy on some platforms.\n * Returns the number of bytes sent, 0 on closure, -1 if send() failed, -2 if\n * read error.\n */\nstatic ssize_t send_from_file(const int s, const int fd,\n        off_t ofs, size_t size) {\n#ifdef __FreeBSD__\n    off_t sent;\n    int ret = sendfile(fd, s, ofs, size, NULL, &sent, 0);\n\n    /* It is possible for sendfile to send zero bytes due to a blocking\n     * condition.  Handle this correctly.\n     */\n    if (ret == -1)\n        if (errno == EAGAIN)\n            if (sent == 0)\n                return -1;\n            else\n                return sent;\n        else\n            return -1;\n    else\n        return size;\n#else\n#if defined(__linux) || defined(__sun__)\n    /* Limit truly ridiculous (LARGEFILE) requests. */\n    if (size > 1<<20)\n        size = 1<<20;\n    return sendfile(s, fd, &ofs, size);\n#else\n    /* Fake sendfile() with read(). */\n# ifndef min\n#  define min(a,b) ( ((a)<(b)) ? (a) : (b) )\n# endif\n    char buf[1<<15];\n    size_t amount = min(sizeof(buf), size);\n    ssize_t numread;\n\n    if (lseek(fd, ofs, SEEK_SET) == -1)\n        err(1, \"fseek(%d)\", (int)ofs);\n    numread = read(fd, buf, amount);\n    if (numread == 0) {\n        fprintf(stderr, \"premature eof on fd %d\\n\", fd);\n        return -1;\n    }\n    else if (numread == -1) {\n        fprintf(stderr, \"error reading on fd %d: %s\", fd, strerror(errno));\n        return -1;\n    }\n    else if ((size_t)numread != amount) {\n        fprintf(stderr, \"read %zd bytes, expecting %zu bytes on fd %d\\n\",\n            numread, amount, fd);\n        return -1;\n    }\n    else\n        return send(s, buf, amount, 0);\n#endif\n#endif\n}\n\n/* Sending reply. */\nstatic void poll_send_reply(struct connection *conn)\n{\n    ssize_t sent;\n    /* off_t can be wider than size_t, avoid overflow in send_len */\n    const size_t max_size_t = ~((size_t)0);\n    off_t send_len = conn->reply_length - conn->reply_sent;\n    if (send_len > max_size_t) send_len = max_size_t;\n\n    assert(conn->state == SEND_REPLY);\n    assert(!conn->header_only);\n    if (conn->reply_type == REPLY_GENERATED) {\n        assert(conn->reply_length >= conn->reply_sent);\n        sent = send(conn->socket,\n            conn->reply + conn->reply_start + conn->reply_sent,\n            (size_t)send_len, 0);\n    }\n    else {\n        errno = 0;\n        assert(conn->reply_length >= conn->reply_sent);\n        sent = send_from_file(conn->socket, conn->reply_fd,\n            conn->reply_start + conn->reply_sent, (size_t)send_len);\n        if (debug && (sent < 1))\n            printf(\"send_from_file returned %lld (errno=%d %s)\\n\",\n                (long long)sent, errno, strerror(errno));\n    }\n    conn->last_active = now;\n    if (debug)\n        printf(\"poll_send_reply(%d) sent %d: %llu+[%llu-%llu] of %llu\\n\",\n               conn->socket, (int)sent, llu(conn->reply_start),\n               llu(conn->reply_sent), llu(conn->reply_sent + sent - 1),\n               llu(conn->reply_length));\n\n    /* handle any errors (-1) or closure (0) in send() */\n    if (sent < 1) {\n        if (sent == -1) {\n            if (errno == EAGAIN) {\n                if (debug)\n                    printf(\"poll_send_reply would have blocked\\n\");\n                return;\n            }\n            if (debug)\n                printf(\"send(%d) error: %s\\n\", conn->socket, strerror(errno));\n        }\n        else if (sent == 0) {\n            if (debug)\n                printf(\"send(%d) closure\\n\", conn->socket);\n        }\n        conn->conn_close = 1;\n        conn->state = DONE;\n        return;\n    }\n    conn->reply_sent += sent;\n    conn->total_sent += (size_t)sent;\n    total_out += (size_t)sent;\n\n    /* check if we're done sending */\n    if (conn->reply_sent == conn->reply_length)\n        conn->state = DONE;\n}\n\n/* Main loop of the httpd - a select() and then delegation to accept\n * connections, handle receiving of requests, and sending of replies.\n */\nstatic void httpd_poll(void) {\n    fd_set recv_set, send_set;\n    int max_fd, select_ret;\n    struct connection *conn, *next;\n    int bother_with_timeout = 0;\n    struct timeval timeout, t0, t1;\n\n    timeout.tv_sec = timeout_secs;\n    timeout.tv_usec = 0;\n\n    FD_ZERO(&recv_set);\n    FD_ZERO(&send_set);\n    max_fd = 0;\n\n    /* set recv/send fd_sets */\n#define MAX_FD_SET(sock, fdset) do { FD_SET(sock,fdset); \\\n                                max_fd = (max_fd<sock) ? sock : max_fd; } \\\n                                while (0)\n    if (accepting) MAX_FD_SET(sockin, &recv_set);\n\n    LIST_FOREACH_SAFE(conn, &connlist, entries, next) {\n        switch (conn->state) {\n        case DONE:\n            /* do nothing, no connection should be left in this state */\n            break;\n\n        case RECV_REQUEST:\n            MAX_FD_SET(conn->socket, &recv_set);\n            bother_with_timeout = 1;\n            break;\n\n        case SEND_HEADER:\n        case SEND_REPLY:\n            MAX_FD_SET(conn->socket, &send_set);\n            bother_with_timeout = 1;\n            break;\n        }\n    }\n#undef MAX_FD_SET\n\n#if defined(__has_feature)\n# if __has_feature(memory_sanitizer)\n    __msan_unpoison(&recv_set, sizeof(recv_set));\n    __msan_unpoison(&send_set, sizeof(send_set));\n# endif\n#endif\n\n    /* -select- */\n    if (timeout_secs == 0) {\n        bother_with_timeout = 0;\n    }\n    if (debug) {\n        printf(\"select() with max_fd %d timeout %d\\n\",\n                max_fd, bother_with_timeout ? (int)timeout.tv_sec : 0);\n        gettimeofday(&t0, NULL);\n    }\n    select_ret = select(max_fd + 1, &recv_set, &send_set, NULL,\n        (bother_with_timeout) ? &timeout : NULL);\n    if (select_ret == 0) {\n        if (!bother_with_timeout)\n            errx(1, \"select() timed out\");\n    }\n    if (select_ret == -1) {\n        if (errno == EINTR)\n            return; /* interrupted by signal */\n        else\n            err(1, \"select() failed\");\n    }\n    if (debug) {\n        long long sec, usec;\n        gettimeofday(&t1, NULL);\n        sec = t1.tv_sec - t0.tv_sec;\n        usec = t1.tv_usec - t0.tv_usec;\n        if (usec < 0) {\n            usec += 1000000;\n            sec--;\n        }\n        printf(\"select() returned %d after %lld.%06lld secs\\n\",\n                select_ret, sec, usec);\n    }\n\n    /* update time */\n    now = time(NULL);\n\n    /* poll connections that select() says need attention */\n    if (FD_ISSET(sockin, &recv_set))\n        accept_connection();\n\n    LIST_FOREACH_SAFE(conn, &connlist, entries, next) {\n        poll_check_timeout(conn);\n        switch (conn->state) {\n        case RECV_REQUEST:\n            if (FD_ISSET(conn->socket, &recv_set)) poll_recv_request(conn);\n            break;\n\n        case SEND_HEADER:\n            if (FD_ISSET(conn->socket, &send_set)) poll_send_header(conn);\n            break;\n\n        case SEND_REPLY:\n            if (FD_ISSET(conn->socket, &send_set)) poll_send_reply(conn);\n            break;\n\n        case DONE:\n            /* (handled later; ignore for now as it's a valid state) */\n            break;\n        }\n\n        /* Handling SEND_REPLY could have set the state to done. */\n        if (conn->state == DONE) {\n            /* clean out finished connection */\n            if (conn->conn_close) {\n                LIST_REMOVE(conn, entries);\n                free_connection(conn);\n                free(conn);\n            } else {\n                recycle_connection(conn);\n            }\n        }\n    }\n}\n\n/* Daemonize helpers. */\n#define PATH_DEVNULL \"/dev/null\"\nstatic int lifeline[2] = { -1, -1 };\nstatic int fd_null = -1;\n\nstatic void daemonize_start(void) {\n    pid_t f;\n\n    if (pipe(lifeline) == -1)\n        err(1, \"pipe(lifeline)\");\n\n    fd_null = open(PATH_DEVNULL, O_RDWR, 0);\n    if (fd_null == -1)\n        err(1, \"open(\" PATH_DEVNULL \")\");\n\n    f = fork();\n    if (f == -1)\n        err(1, \"fork\");\n    else if (f != 0) {\n        /* parent: wait for child */\n        char tmp[1];\n        int status;\n        pid_t w;\n\n        if (close(lifeline[1]) == -1)\n            warn(\"close lifeline in parent\");\n        if (read(lifeline[0], tmp, sizeof(tmp)) == -1)\n            warn(\"read lifeline in parent\");\n        w = waitpid(f, &status, WNOHANG);\n        if (w == -1)\n            err(1, \"waitpid\");\n        else if (w == 0)\n            /* child is running happily */\n            exit(EXIT_SUCCESS);\n        else\n            /* child init failed, pass on its exit status */\n            exit(WEXITSTATUS(status));\n    }\n    /* else we are the child: continue initializing */\n}\n\nstatic void daemonize_finish(void) {\n    if (fd_null == -1)\n        return; /* didn't daemonize_start() so we're not daemonizing */\n\n    if (setsid() == -1)\n        err(1, \"setsid\");\n    if (close(lifeline[0]) == -1)\n        warn(\"close read end of lifeline in child\");\n    if (close(lifeline[1]) == -1)\n        warn(\"couldn't cut the lifeline\");\n\n    /* close all our std fds */\n    if (dup2(fd_null, STDIN_FILENO) == -1)\n        warn(\"dup2(stdin)\");\n    if (dup2(fd_null, STDOUT_FILENO) == -1)\n        warn(\"dup2(stdout)\");\n    if (dup2(fd_null, STDERR_FILENO) == -1)\n        warn(\"dup2(stderr)\");\n    if (fd_null > 2)\n        close(fd_null);\n}\n\n/* [->] pidfile helpers, based on FreeBSD src/lib/libutil/pidfile.c,v 1.3\n * Original was copyright (c) 2005 Pawel Jakub Dawidek <pjd@FreeBSD.org>\n */\nstatic int pidfile_fd = -1;\n#define PIDFILE_MODE 0600\n\nstatic void pidfile_remove(void) {\n    if (unlink(pidfile_name) == -1)\n        err(1, \"unlink(pidfile) failed\");\n /* if (flock(pidfile_fd, LOCK_UN) == -1)\n        err(1, \"unlock(pidfile) failed\"); */\n    xclose(pidfile_fd);\n    pidfile_fd = -1;\n}\n\nstatic int pidfile_read(void) {\n    char buf[16];\n    int fd, i;\n    long long pid;\n\n    fd = open(pidfile_name, O_RDONLY);\n    if (fd == -1)\n        err(1, \" after create failed\");\n\n    i = (int)read(fd, buf, sizeof(buf) - 1);\n    if (i == -1)\n        err(1, \"read from pidfile failed\");\n    xclose(fd);\n    buf[i] = '\\0';\n\n    if (!str_to_num(buf, &pid)) {\n        err(1, \"invalid pidfile contents: \\\"%s\\\"\", buf);\n    }\n    return (int)pid;\n}\n\nstatic void pidfile_create(void) {\n    int error, fd;\n    char pidstr[16];\n\n    /* Open the PID file and obtain exclusive lock. */\n    fd = open(pidfile_name,\n        O_WRONLY | O_CREAT | O_EXLOCK | O_TRUNC | O_NONBLOCK, PIDFILE_MODE);\n    if (fd == -1) {\n        if ((errno == EWOULDBLOCK) || (errno == EEXIST))\n            errx(1, \"daemon already running with PID %d\", pidfile_read());\n        else\n            err(1, \"can't create pidfile %s\", pidfile_name);\n    }\n    pidfile_fd = fd;\n\n    if (ftruncate(fd, 0) == -1) {\n        error = errno;\n        pidfile_remove();\n        errno = error;\n        err(1, \"ftruncate() failed\");\n    }\n\n    snprintf(pidstr, sizeof(pidstr), \"%d\", (int)getpid());\n    if (pwrite(fd, pidstr, strlen(pidstr), 0) != (ssize_t)strlen(pidstr)) {\n        error = errno;\n        pidfile_remove();\n        errno = error;\n        err(1, \"pwrite() failed\");\n    }\n}\n/* [<-] end of pidfile helpers. */\n\n/* Close all sockets and FILEs and exit. */\nstatic void stop_running(int sig unused) {\n    running = 0;\n}\n\n/* Execution starts here. */\nint main(int argc, char **argv) {\n    printf(\"%s, %s.\\n\", pkgname, copyright);\n    parse_default_extension_map();\n    parse_commandline(argc, argv);\n    /* parse_commandline() might override parts of the extension map by\n     * parsing a user-specified file.\n     */\n    sort_mime_map();\n    xasprintf(&keep_alive_field, \"Keep-Alive: timeout=%d\\r\\n\", timeout_secs);\n    if (want_server_id)\n        xasprintf(&server_hdr, \"Server: %s\\r\\n\", pkgname);\n    else\n        server_hdr = xstrdup(\"\");\n    init_sockin();\n\n    /* open logfile */\n    if (logfile_name == NULL)\n        logfile = stdout;\n    else {\n        logfile = fopen(logfile_name, \"ab\");\n        if (logfile == NULL)\n            err(1, \"opening logfile: fopen(\\\"%s\\\")\", logfile_name);\n    }\n\n    if (want_daemon)\n        daemonize_start();\n\n    /* signals */\n    if (signal(SIGPIPE, SIG_IGN) == SIG_ERR)\n        err(1, \"signal(ignore SIGPIPE)\");\n    if (signal(SIGINT, stop_running) == SIG_ERR)\n        err(1, \"signal(SIGINT)\");\n    if (signal(SIGTERM, stop_running) == SIG_ERR)\n        err(1, \"signal(SIGTERM)\");\n\n    /* security */\n    if (want_chroot) {\n        tzset(); /* read /etc/localtime before we chroot */\n        if (chdir(wwwroot) == -1)\n            err(1, \"chdir(%s)\", wwwroot);\n        if (chroot(wwwroot) == -1)\n            err(1, \"chroot(%s)\", wwwroot);\n        printf(\"chrooted to `%s'\\n\", wwwroot);\n        wwwroot[0] = '\\0'; /* empty string */\n    }\n    if (drop_gid != INVALID_GID) {\n        gid_t list[1];\n        list[0] = drop_gid;\n        if (setgroups(1, list) == -1)\n            err(1, \"setgroups([%d])\", (int)drop_gid);\n        if (setgid(drop_gid) == -1)\n            err(1, \"setgid(%d)\", (int)drop_gid);\n        printf(\"set gid to %d\\n\", (int)drop_gid);\n    }\n    if (drop_uid != INVALID_UID) {\n        if (setuid(drop_uid) == -1)\n            err(1, \"setuid(%d)\", (int)drop_uid);\n        printf(\"set uid to %d\\n\", (int)drop_uid);\n    }\n\n    /* create pidfile */\n    if (pidfile_name) pidfile_create();\n\n    if (want_daemon) daemonize_finish();\n\n    /* main loop */\n    running = 1;\n    while (running) httpd_poll();\n\n    /* clean exit */\n    xclose(sockin);\n    if (logfile != NULL) fclose(logfile);\n    if (pidfile_name) pidfile_remove();\n\n    /* close and free connections */\n    {\n        struct connection *conn, *next;\n\n        LIST_FOREACH_SAFE(conn, &connlist, entries, next) {\n            LIST_REMOVE(conn, entries);\n            free_connection(conn);\n            free(conn);\n        }\n    }\n\n    /* free the mallocs */\n    {\n        size_t i;\n        for (i=0; i<mime_map_size; i++) {\n            free(mime_map[i].extension);\n            free(mime_map[i].mimetype);\n        }\n        free(mime_map);\n        if (forward_map)\n            free(forward_map);\n        free(keep_alive_field);\n        free(wwwroot);\n        free(server_hdr);\n        free(auth_key);\n        free(custom_hdrs);\n    }\n\n    /* usage stats */\n    {\n        struct rusage r;\n\n        getrusage(RUSAGE_SELF, &r);\n        printf(\"CPU time used: %u.%02u user, %u.%02u system\\n\",\n            (unsigned int)r.ru_utime.tv_sec,\n                (unsigned int)(r.ru_utime.tv_usec/10000),\n            (unsigned int)r.ru_stime.tv_sec,\n                (unsigned int)(r.ru_stime.tv_usec/10000)\n        );\n        printf(\"Requests: %llu\\n\", llu(num_requests));\n        printf(\"Bytes: %llu in, %llu out\\n\", llu(total_in), llu(total_out));\n    }\n\n    return 0;\n}\n\n/* vim:set ts=4 sw=4 sts=4 expandtab tw=78: */\n"], "filenames": ["darkhttpd.c"], "buggy_code_start_loc": [944], "buggy_code_end_loc": [945], "fixing_code_start_loc": [944], "fixing_code_end_loc": [947], "type": "NVD-CWE-noinfo", "message": "darkhttpd through 1.15 allows local users to discover credentials (for --auth) by listing processes and their arguments.", "other": {"cve": {"id": "CVE-2024-23770", "sourceIdentifier": "cve@mitre.org", "published": "2024-01-22T04:15:07.670", "lastModified": "2024-01-26T19:18:29.190", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "darkhttpd through 1.15 allows local users to discover credentials (for --auth) by listing processes and their arguments."}, {"lang": "es", "value": "darkhttpd hasta 1.15 permite a los usuarios locales descubrir credenciales (para --auth) enumerando procesos y sus argumentos."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "NVD-CWE-noinfo"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:unix4lyfe:darkhttpd:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.15", "matchCriteriaId": "2AB81BE1-0454-4EA9-BB4C-90097B787823"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2024/01/25/1", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/emikulic/darkhttpd/commit/2b339828b2a42a5fda105ea84934957a7d23e35d", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/emikulic/darkhttpd/compare/v1.14...v1.15", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/emikulic/darkhttpd/commit/2b339828b2a42a5fda105ea84934957a7d23e35d"}}