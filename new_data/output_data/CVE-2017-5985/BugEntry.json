{"buggy_code": ["/*\n *\n * Copyright \u00a9 2013 Serge Hallyn <serge.hallyn@ubuntu.com>.\n * Copyright \u00a9 2013 Canonical Ltd.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2, as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#define _GNU_SOURCE             /* See feature_test_macros(7) */\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <sys/types.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include <alloca.h>\n#include <string.h>\n#include <sched.h>\n#include <sys/mman.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <linux/netlink.h>\n#include <arpa/inet.h>\n#include <net/if.h>\n#include <net/if_arp.h>\n#include <netinet/in.h>\n#include <linux/netlink.h>\n#include <linux/rtnetlink.h>\n#include <linux/sockios.h>\n#include <sys/param.h>\n\n#include \"config.h\"\n#include \"utils.h\"\n#include \"network.h\"\n\nstatic void usage(char *me, bool fail)\n{\n\tfprintf(stderr, \"Usage: %s lxcpath name pid type bridge nicname\\n\", me);\n\tfprintf(stderr, \" nicname is the name to use inside the container\\n\");\n\texit(fail ? 1 : 0);\n}\n\nstatic char *lxcpath, *lxcname;\n\nstatic int open_and_lock(char *path)\n{\n\tint fd;\n\tstruct flock lk;\n\n\tfd = open(path, O_RDWR|O_CREAT, S_IWUSR | S_IRUSR);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Failed to open %s: %s\\n\",\n\t\t\tpath, strerror(errno));\n\t\treturn(fd);\n\t}\n\n\tlk.l_type = F_WRLCK;\n\tlk.l_whence = SEEK_SET;\n\tlk.l_start = 0;\n\tlk.l_len = 0;\n\tif (fcntl(fd, F_SETLKW, &lk) < 0) {\n\t\tfprintf(stderr, \"Failed to lock %s: %s\\n\",\n\t\t\tpath, strerror(errno));\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}\n\n\nstatic char *get_username(void)\n{\n\tstruct passwd *pwd = getpwuid(getuid());\n\n\tif (pwd == NULL) {\n\t\tperror(\"getpwuid\");\n\t\treturn NULL;\n\t}\n\n\treturn pwd->pw_name;\n}\n\nstatic void free_groupnames(char **groupnames)\n{\n\tint i;\n\tif (!groupnames)\n\t\treturn;\n\tfor (i = 0; groupnames[i]; i++)\n\t\tfree(groupnames[i]);\n\tfree(groupnames);\n}\n\nstatic char **get_groupnames(void)\n{\n\tint ngroups;\n\tgid_t *group_ids;\n\tint ret, i;\n\tchar **groupnames;\n\tstruct group *gr;\n\n\tngroups = getgroups(0, NULL);\n\n\tif (ngroups == -1) {\n\t\tfprintf(stderr, \"Failed to get number of groups user belongs to: %s\\n\", strerror(errno));\n\t\treturn NULL;\n\t}\n\tif (ngroups == 0)\n\t\treturn NULL;\n\n\tgroup_ids = (gid_t *)malloc(sizeof(gid_t)*ngroups);\n\n\tif (group_ids == NULL) {\n\t\tfprintf(stderr, \"Out of memory while getting groups the user belongs to\\n\");\n\t\treturn NULL;\n\t}\n\n\tret = getgroups(ngroups, group_ids);\n\n\tif (ret < 0) {\n\t\tfree(group_ids);\n\t\tfprintf(stderr, \"Failed to get process groups: %s\\n\", strerror(errno));\n\t\treturn NULL;\n\t}\n\n\tgroupnames = (char **)malloc(sizeof(char *)*(ngroups+1));\n\n\tif (groupnames == NULL) {\n\t\tfree(group_ids);\n\t\tfprintf(stderr, \"Out of memory while getting group names\\n\");\n\t\treturn NULL;\n\t}\n\n\tmemset(groupnames, 0, sizeof(char *)*(ngroups+1));\n\n\tfor (i=0; i<ngroups; i++ ) {\n\t\tgr = getgrgid(group_ids[i]);\n\n\t\tif (gr == NULL) {\n\t\t\tfprintf(stderr, \"Failed to get group name\\n\");\n\t\t\tfree(group_ids);\n\t\t\tfree_groupnames(groupnames);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tgroupnames[i] = strdup(gr->gr_name);\n\n\t\tif (groupnames[i] == NULL) {\n\t\t\tfprintf(stderr, \"Failed to copy group name: %s\", gr->gr_name);\n\t\t\tfree(group_ids);\n\t\t\tfree_groupnames(groupnames);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tfree(group_ids);\n\n\treturn groupnames;\n}\n\nstatic bool name_is_in_groupnames(char *name, char **groupnames)\n{\n\twhile (groupnames != NULL) {\n\t\tif (strcmp(name, *groupnames) == 0)\n\t\t\treturn true;\n\t\tgroupnames++;\n\t}\n\treturn false;\n}\n\nstruct alloted_s {\n\tchar *name;\n\tint allowed;\n\tstruct alloted_s *next;\n};\n\nstatic struct alloted_s *append_alloted(struct alloted_s **head, char *name, int n)\n{\n\tstruct alloted_s *cur, *al;\n\n\tif (head == NULL || name == NULL) {\n\t\t// sanity check. parameters should not be null\n\t\tfprintf(stderr, \"NULL parameters to append_alloted not allowed\\n\");\n\t\treturn NULL;\n\t}\n\n\tal = (struct alloted_s *)malloc(sizeof(struct alloted_s));\n\n\tif (al == NULL) {\n\t\t// unable to allocate memory to new struct\n\t\tfprintf(stderr, \"Out of memory in append_alloted\\n\");\n\t\treturn NULL;\n\t}\n\n\tal->name = strdup(name);\n\n\tif (al->name == NULL) {\n\t\tfree(al);\n\t\treturn NULL;\n\t}\n\n\tal->allowed = n;\n\tal->next = NULL;\n\n\tif (*head == NULL) {\n\t\t*head = al;\n\t\treturn al;\n\t}\n\n\tcur = *head;\n\twhile (cur->next != NULL)\n\t\tcur = cur->next;\n\n\tcur->next = al;\n\treturn al;\n}\n\nstatic void free_alloted(struct alloted_s **head)\n{\n\tstruct alloted_s *cur;\n\n\tif (head == NULL) {\n\t\treturn;\n\t}\n\n\tcur = *head;\n\n\twhile (cur != NULL) {\n\t\tcur = cur->next;\n\t\tfree((*head)->name);\n\t\tfree(*head);\n\t\t*head = cur;\n\t}\n}\n\n/* The configuration file consists of lines of the form:\n *\n * user type bridge count\n * or\n * @group type bridge count\n *\n * Return the count entry for the calling user if there is one.  Else\n * return -1.\n */\nstatic int get_alloted(char *me, char *intype, char *link, struct alloted_s **alloted)\n{\n\tFILE *fin = fopen(LXC_USERNIC_CONF, \"r\");\n\tchar *line = NULL;\n\tchar name[100], type[100], br[100];\n\tsize_t len = 0;\n\tint n, ret, count = 0;\n\tchar **groups;\n\n\tif (!fin) {\n\t\tfprintf(stderr, \"Failed to open %s: %s\\n\", LXC_USERNIC_CONF,\n\t\t\tstrerror(errno));\n\t\treturn -1;\n\t}\n\n\tgroups = get_groupnames();\n\twhile ((getline(&line, &len, fin)) != -1) {\n\t\tret = sscanf(line, \"%99[^ \\t] %99[^ \\t] %99[^ \\t] %d\", name, type, br, &n);\n\n\t\tif (ret != 4)\n\t\t\tcontinue;\n\n\t\tif (strlen(name) == 0)\n\t\t\tcontinue;\n\n\t\tif (strcmp(name, me) != 0)\n\t\t{\n\t\t\tif (name[0] != '@')\n\t\t\t\tcontinue;\n\t\t\tif (!name_is_in_groupnames(name+1, groups))\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(type, intype) != 0)\n\t\t\tcontinue;\n\t\tif (strcmp(link, br) != 0)\n\t\t\tcontinue;\n\n\t\t/* found the user or group with the appropriate settings, therefore finish the search.\n\t\t * what to do if there are more than one applicable lines? not specified in the docs.\n\t\t * since getline is implemented with realloc, we don't need to free line until exiting func.\n\t\t *\n\t\t * if append_alloted returns NULL, e.g. due to a malloc error, we set count to 0 and break the loop,\n\t\t * allowing cleanup and then exiting from main()\n\t\t */\n\t\tif (append_alloted(alloted, name, n) == NULL) {\n\t\t\tcount = 0;\n\t\t\tbreak;\n\t\t}\n\t\tcount += n;\n\t}\n\n\tfree_groupnames(groups);\n\tfclose(fin);\n\tfree(line);\n\n\t// now return the total number of nics that this user can create\n\treturn count;\n}\n\nstatic char *get_eol(char *s, char *e)\n{\n\twhile (s<e && *s && *s != '\\n')\n\t\ts++;\n\treturn s;\n}\n\nstatic char *get_eow(char *s, char *e)\n{\n\twhile (s<e && *s && !isblank(*s) && *s != '\\n')\n\t\ts++;\n\treturn s;\n}\n\nstatic char *find_line(char *p, char *e, char *u, char *t, char *l)\n{\n\tchar *p1, *p2, *ret;\n\n\twhile (p<e  && (p1 = get_eol(p, e)) < e) {\n\t\tret = p;\n\t\tif (*p == '#')\n\t\t\tgoto next;\n\t\twhile (p<e && isblank(*p)) p++;\n\t\tp2 = get_eow(p, e);\n\t\tif (!p2 || p2-p != strlen(u) || strncmp(p, u, strlen(u)) != 0)\n\t\t\tgoto next;\n\t\tp = p2+1;\n\t\twhile (p<e && isblank(*p)) p++;\n\t\tp2 = get_eow(p, e);\n\t\tif (!p2 || p2-p != strlen(t) || strncmp(p, t, strlen(t)) != 0)\n\t\t\tgoto next;\n\t\tp = p2+1;\n\t\twhile (p<e && isblank(*p)) p++;\n\t\tp2 = get_eow(p, e);\n\t\tif (!p2 || p2-p != strlen(l) || strncmp(p, l, strlen(l)) != 0)\n\t\t\tgoto next;\n\t\treturn ret;\nnext:\n\t\tp = p1 + 1;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool nic_exists(char *nic)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\tstruct stat sb;\n\n\tif (strcmp(nic, \"none\") == 0)\n\t\treturn true;\n\tret = snprintf(path, MAXPATHLEN, \"/sys/class/net/%s\", nic);\n\tif (ret < 0 || ret >= MAXPATHLEN) // should never happen!\n\t\treturn false;\n\tret = stat(path, &sb);\n\tif (ret != 0)\n\t\treturn false;\n\treturn true;\n}\n\nstatic int instantiate_veth(char *n1, char **n2)\n{\n\tint err;\n\n\terr = snprintf(*n2, IFNAMSIZ, \"%sp\", n1);\n\tif (err < 0 || err >= IFNAMSIZ) {\n\t\tfprintf(stderr, \"nic name too long\\n\");\n\t\treturn -1;\n\t}\n\n\terr = lxc_veth_create(n1, *n2);\n\tif (err) {\n\t\tfprintf(stderr, \"failed to create %s-%s : %s\\n\", n1, *n2,\n\t\t      strerror(-err));\n\t\treturn -1;\n\t}\n\n\t/* changing the high byte of the mac address to 0xfe, the bridge interface\n\t * will always keep the host's mac address and not take the mac address\n\t * of a container */\n\terr = setup_private_host_hw_addr(n1);\n\tif (err) {\n\t\tfprintf(stderr, \"failed to change mac address of host interface '%s' : %s\\n\",\n\t\t\tn1, strerror(-err));\n\t}\n\n\treturn netdev_set_flag(n1, IFF_UP);\n}\n\nstatic int get_mtu(char *name)\n{\n\tint idx = if_nametoindex(name);\n\treturn netdev_get_mtu(idx);\n}\n\nstatic bool create_nic(char *nic, char *br, int pid, char **cnic)\n{\n\tchar *veth1buf, *veth2buf;\n\tveth1buf = alloca(IFNAMSIZ);\n\tveth2buf = alloca(IFNAMSIZ);\n\tint ret, mtu;\n\n\tret = snprintf(veth1buf, IFNAMSIZ, \"%s\", nic);\n\tif (ret < 0 || ret >= IFNAMSIZ) {\n\t\tfprintf(stderr, \"host nic name too long\\n\");\n\t\treturn false;\n\t}\n\n\t/* create the nics */\n\tif (instantiate_veth(veth1buf, &veth2buf) < 0) {\n\t\tfprintf(stderr, \"Error creating veth tunnel\\n\");\n\t\treturn false;\n\t}\n\n\tif (strcmp(br, \"none\") != 0) {\n\t\t/* copy the bridge's mtu to both ends */\n\t\tmtu = get_mtu(br);\n\t\tif (mtu != -1) {\n\t\t\tif (lxc_netdev_set_mtu(veth1buf, mtu) < 0 ||\n\t\t\t\t\tlxc_netdev_set_mtu(veth2buf, mtu) < 0) {\n\t\t\t\tfprintf(stderr, \"Failed setting mtu\\n\");\n\t\t\t\tgoto out_del;\n\t\t\t}\n\t\t}\n\n\t\t/* attach veth1 to bridge */\n\t\tif (lxc_bridge_attach(lxcpath, lxcname, br, veth1buf) < 0) {\n\t\t\tfprintf(stderr, \"Error attaching %s to %s\\n\", veth1buf, br);\n\t\t\tgoto out_del;\n\t\t}\n\t}\n\n\t/* pass veth2 to target netns */\n\tret = lxc_netdev_move_by_name(veth2buf, pid, NULL);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"Error moving %s to netns %d\\n\", veth2buf, pid);\n\t\tgoto out_del;\n\t}\n\t*cnic = strdup(veth2buf);\n\treturn true;\n\nout_del:\n\tlxc_netdev_delete_by_name(veth1buf);\n\treturn false;\n}\n\n/*\n * Get a new nic.\n * *dest will container the name (vethXXXXXX) which is attached\n * on the host to the lxc bridge\n */\nstatic bool get_new_nicname(char **dest, char *br, int pid, char **cnic)\n{\n\tchar template[IFNAMSIZ];\n\tsnprintf(template, sizeof(template), \"vethXXXXXX\");\n\t*dest = lxc_mkifname(template);\n\n\tif (!create_nic(*dest, br, pid, cnic)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool get_nic_from_line(char *p, char **nic)\n{\n\tchar user[100], type[100], br[100];\n\tint ret;\n\n\tret = sscanf(p, \"%99[^ \\t\\n] %99[^ \\t\\n] %99[^ \\t\\n] %99[^ \\t\\n]\", user, type, br, *nic);\n\tif (ret != 4)\n\t\treturn false;\n\treturn true;\n}\n\nstruct entry_line {\n\tchar *start;\n\tint len;\n\tbool keep;\n};\n\nstatic bool cull_entries(int fd, char *me, char *t, char *br)\n{\n\tstruct stat sb;\n\tchar *buf, *p, *e, *nic;\n\toff_t len;\n\tstruct entry_line *entry_lines = NULL;\n\tint i, n = 0;\n\n\tnic = alloca(100);\n\n\tif (fstat(fd, &sb) < 0) {\n\t\tfprintf(stderr, \"Failed to fstat: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\tlen = sb.st_size;\n\tif (len == 0)\n\t\treturn true;\n\tbuf = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\tif (buf == MAP_FAILED) {\n\t\tfprintf(stderr, \"Failed to create mapping: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\n\tp = buf;\n\te = buf + len;\n\twhile ((p = find_line(p, e, me, t, br)) != NULL) {\n\t\tstruct entry_line *newe = realloc(entry_lines, sizeof(*entry_lines)*(n+1));\n\t\tif (!newe) {\n\t\t\tfree(entry_lines);\n\t\t\treturn false;\n\t\t}\n\t\tentry_lines = newe;\n\t\tentry_lines[n].start = p;\n\t\tentry_lines[n].len = get_eol(p, e) - entry_lines[n].start;\n\t\tentry_lines[n].keep = true;\n\t\tn++;\n\t\tif (!get_nic_from_line(p, &nic))\n\t\t\tcontinue;\n\t\tif (nic && !nic_exists(nic))\n\t\t\tentry_lines[n-1].keep = false;\n\t\tp += entry_lines[n-1].len + 1;\n\t\tif (p >= e)\n\t\t\tbreak;\n \t}\n\tp = buf;\n\tfor (i=0; i<n; i++) {\n\t\tif (!entry_lines[i].keep)\n\t\t\tcontinue;\n\t\tmemcpy(p, entry_lines[i].start, entry_lines[i].len);\n\t\tp += entry_lines[i].len;\n\t\t*p = '\\n';\n\t\tp++;\n\t}\n\tfree(entry_lines);\n\tmunmap(buf, sb.st_size);\n\tif (ftruncate(fd, p-buf))\n\t\tfprintf(stderr, \"Failed to set new file size\\n\");\n\treturn true;\n}\n\nstatic int count_entries(char *buf, off_t len, char *me, char *t, char *br)\n{\n\tchar *e = &buf[len];\n\tint count = 0;\n\twhile ((buf = find_line(buf, e, me, t, br)) != NULL) {\n\t\tcount++;\n\t\tbuf = get_eol(buf, e)+1;\n\t\tif (buf >= e)\n\t\t\tbreak;\n\t}\n\n\treturn count;\n}\n\n/*\n * The dbfile has lines of the format:\n * user type bridge nicname\n */\nstatic bool get_nic_if_avail(int fd, struct alloted_s *names, int pid, char *intype, char *br, int allowed, char **nicname, char **cnic)\n{\n\toff_t len, slen;\n\tstruct stat sb;\n\tchar *buf = NULL, *newline;\n\tint ret, count = 0;\n\tchar *owner;\n\tstruct alloted_s *n;\n\n\tfor (n=names; n!=NULL; n=n->next)\n\t\tcull_entries(fd, n->name, intype, br);\n\n\tif (allowed == 0)\n\t\treturn false;\n\n\towner = names->name;\n\n\tif (fstat(fd, &sb) < 0) {\n\t\tfprintf(stderr, \"Failed to fstat: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\tlen = sb.st_size;\n\tif (len != 0) {\n\t\tbuf = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\t\tif (buf == MAP_FAILED) {\n\t\t\tfprintf(stderr, \"Failed to create mapping\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\towner = NULL;\n\t\tfor (n=names; n!=NULL; n=n->next) {\n\t\t\tcount = count_entries(buf, len, n->name, intype, br);\n\n\t\t\tif (count >= n->allowed)\n\t\t\t\tcontinue;\n\n\t\t\towner = n->name;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (owner == NULL)\n\t\treturn false;\n\n\tif (!get_new_nicname(nicname, br, pid, cnic))\n\t\treturn false;\n\t/* owner  ' ' intype ' ' br ' ' *nicname + '\\n' + '\\0' */\n\tslen = strlen(owner) + strlen(intype) + strlen(br) + strlen(*nicname) + 5;\n\tnewline = alloca(slen);\n\tret = snprintf(newline, slen, \"%s %s %s %s\\n\", owner, intype, br, *nicname);\n\tif (ret < 0 || ret >= slen) {\n\t\tif (lxc_netdev_delete_by_name(*nicname) != 0)\n\t\t\tfprintf(stderr, \"Error unlinking %s!\\n\", *nicname);\n\t\treturn false;\n\t}\n\tif (len)\n\t\tmunmap(buf, len);\n\tif (ftruncate(fd, len + slen))\n\t\tfprintf(stderr, \"Failed to set new file size\\n\");\n\tbuf = mmap(NULL, len + slen, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\tif (buf == MAP_FAILED) {\n\t\tfprintf(stderr, \"Failed to create mapping after extending: %s\\n\", strerror(errno));\n\t\tif (lxc_netdev_delete_by_name(*nicname) != 0)\n\t\t\tfprintf(stderr, \"Error unlinking %s!\\n\", *nicname);\n\t\treturn false;\n\t}\n\tstrcpy(buf+len, newline);\n\tmunmap(buf, len+slen);\n\treturn true;\n}\n\nstatic bool create_db_dir(char *fnam)\n{\n\tchar *p = alloca(strlen(fnam)+1);\n\n\tstrcpy(p, fnam);\n\tfnam = p;\n\tp = p + 1;\nagain:\n\twhile (*p && *p != '/') p++;\n\tif (!*p)\n\t\treturn true;\n\t*p = '\\0';\n\tif (mkdir(fnam, 0755) && errno != EEXIST) {\n\t\tfprintf(stderr, \"failed to create %s\\n\", fnam);\n\t\t*p = '/';\n\t\treturn false;\n\t}\n\t*(p++) = '/';\n\tgoto again;\n}\n\n#define VETH_DEF_NAME \"eth%d\"\n\nstatic int rename_in_ns(int pid, char *oldname, char **newnamep)\n{\n\tint fd = -1, ofd = -1, ret, ifindex = -1;\n\tbool grab_newname = false;\n\n\tofd = lxc_preserve_ns(getpid(), \"net\");\n\tif (ofd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", getpid());\n\t\treturn -1;\n\t}\n\n\tfd = lxc_preserve_ns(pid, \"net\");\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Failed opening network namespace path for '%d'.\", pid);\n\t\treturn -1;\n\t}\n\n\tif (setns(fd, 0) < 0) {\n\t\tfprintf(stderr, \"setns to container network namespace\\n\");\n\t\tgoto out_err;\n\t}\n\tclose(fd); fd = -1;\n\tif (!*newnamep) {\n\t\tgrab_newname = true;\n\t\t*newnamep = VETH_DEF_NAME;\n\t\tif (!(ifindex = if_nametoindex(oldname))) {\n\t\t\tfprintf(stderr, \"failed to get netdev index\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t}\n\tif ((ret = lxc_netdev_rename_by_name(oldname, *newnamep)) < 0) {\n\t\tfprintf(stderr, \"Error %d renaming netdev %s to %s in container\\n\", ret, oldname, *newnamep);\n\t\tgoto out_err;\n\t}\n\tif (grab_newname) {\n\t\tchar ifname[IFNAMSIZ], *namep = ifname;\n\t\tif (!if_indextoname(ifindex, namep)) {\n\t\t\tfprintf(stderr, \"Failed to get new netdev name\\n\");\n\t\t\tgoto out_err;\n\t\t}\n\t\t*newnamep = strdup(namep);\n\t\tif (!*newnamep)\n\t\t\tgoto out_err;\n\t}\n\tif (setns(ofd, 0) < 0) {\n\t\tfprintf(stderr, \"Error returning to original netns\\n\");\n\t\tclose(ofd);\n\t\treturn -1;\n\t}\n\tclose(ofd);\n\n\treturn 0;\n\nout_err:\n\tif (ofd >= 0)\n\t\tclose(ofd);\n\tif (setns(ofd, 0) < 0)\n\t\tfprintf(stderr, \"Error returning to original network namespace\\n\");\n\tif (fd >= 0)\n\t\tclose(fd);\n\treturn -1;\n}\n\n/*\n * If the caller (real uid, not effective uid) may read the\n * /proc/[pid]/ns/net, then it is either the caller's netns or one\n * which it created.\n */\nstatic bool may_access_netns(int pid)\n{\n\tint ret;\n\tchar s[200];\n\tuid_t ruid, suid, euid;\n\tbool may_access = false;\n\n\tret = getresuid(&ruid, &euid, &suid);\n\tif (ret) {\n\t\tfprintf(stderr, \"Failed to get my uids: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\tret = setresuid(ruid, ruid, euid);\n\tif (ret) {\n\t\tfprintf(stderr, \"Failed to set temp uids to (%d,%d,%d): %s\\n\",\n\t\t\t\t(int)ruid, (int)ruid, (int)euid, strerror(errno));\n\t\treturn false;\n\t}\n\tret = snprintf(s, 200, \"/proc/%d/ns/net\", pid);\n\tif (ret < 0 || ret >= 200)  // can't happen\n\t\treturn false;\n\tret = access(s, R_OK);\n\tif (ret) {\n\t\tfprintf(stderr, \"Uid %d may not access %s: %s\\n\",\n\t\t\t\t(int)ruid, s, strerror(errno));\n\t}\n\tmay_access = ret == 0;\n\tret = setresuid(ruid, euid, suid);\n\tif (ret) {\n\t\tfprintf(stderr, \"Failed to restore uids to (%d,%d,%d): %s\\n\",\n\t\t\t\t(int)ruid, (int)euid, (int)suid, strerror(errno));\n\t\tmay_access = false;\n\t}\n\treturn may_access;\n}\n\nint main(int argc, char *argv[])\n{\n\tint n, fd;\n\tbool gotone = false;\n\tchar *me;\n\tchar *nicname = alloca(40);\n\tchar *cnic = NULL; // created nic name in container is returned here.\n\tchar *vethname = NULL;\n\tint pid;\n\tstruct alloted_s *alloted = NULL;\n\n\t/* set a sane env, because we are setuid-root */\n\tif (clearenv() < 0) {\n\t\tfprintf(stderr, \"Failed to clear environment\");\n\t\texit(1);\n\t}\n\tif (setenv(\"PATH\", \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", 1) < 0) {\n\t\tfprintf(stderr, \"Failed to set PATH, exiting\\n\");\n\t\texit(1);\n\t}\n\tif ((me = get_username()) == NULL) {\n\t\tfprintf(stderr, \"Failed to get username\\n\");\n\t\texit(1);\n\t}\n\n\tif (argc < 6)\n\t\tusage(argv[0], true);\n\tif (argc >= 7)\n\t\tvethname = argv[6];\n\n\tlxcpath = argv[1];\n\tlxcname = argv[2];\n\n\terrno = 0;\n\tpid = (int) strtol(argv[3], NULL, 10);\n\tif (errno) {\n\t\tfprintf(stderr, \"Could not read pid: %s\\n\", argv[1]);\n\t\texit(1);\n\t}\n\n\tif (!create_db_dir(LXC_USERNIC_DB)) {\n\t\tfprintf(stderr, \"Failed to create directory for db file\\n\");\n\t\texit(1);\n\t}\n\n\tif ((fd = open_and_lock(LXC_USERNIC_DB)) < 0) {\n\t\tfprintf(stderr, \"Failed to lock %s\\n\", LXC_USERNIC_DB);\n\t\texit(1);\n\t}\n\n\tif (!may_access_netns(pid)) {\n\t\tfprintf(stderr, \"User %s may not modify netns for pid %d\\n\",\n\t\t\tme, pid);\n\t\texit(1);\n\t}\n\n\tn = get_alloted(me, argv[4], argv[5], &alloted);\n\tif (n > 0)\n\t\tgotone = get_nic_if_avail(fd, alloted, pid, argv[4], argv[5], n, &nicname, &cnic);\n\n\tclose(fd);\n\tfree_alloted(&alloted);\n\tif (!gotone) {\n\t\tfprintf(stderr, \"Quota reached\\n\");\n\t\texit(1);\n\t}\n\n\t// Now rename the link\n\tif (rename_in_ns(pid, cnic, &vethname) < 0) {\n\t\tfprintf(stderr, \"Failed to rename the link\\n\");\n\t\texit(1);\n\t}\n\n\t// write the name of the interface pair to the stdout - like eth0:veth9MT2L4\n\tfprintf(stdout, \"%s:%s\\n\", vethname, nicname);\n\texit(0);\n}\n"], "fixing_code": ["/*\n *\n * Copyright \u00a9 2013 Serge Hallyn <serge.hallyn@ubuntu.com>.\n * Copyright \u00a9 2013 Canonical Ltd.\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License version 2, as\n * published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, write to the Free Software Foundation, Inc.,\n * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n */\n\n#define _GNU_SOURCE             /* See feature_test_macros(7) */\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <sys/types.h>\n#include <pwd.h>\n#include <grp.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/file.h>\n#include <alloca.h>\n#include <string.h>\n#include <sched.h>\n#include <sys/mman.h>\n#include <sys/socket.h>\n#include <errno.h>\n#include <ctype.h>\n#include <sys/stat.h>\n#include <sys/ioctl.h>\n#include <linux/netlink.h>\n#include <arpa/inet.h>\n#include <net/if.h>\n#include <net/if_arp.h>\n#include <netinet/in.h>\n#include <linux/netlink.h>\n#include <linux/rtnetlink.h>\n#include <linux/sockios.h>\n#include <sys/param.h>\n\n#include \"config.h\"\n#include \"utils.h\"\n#include \"network.h\"\n\n#define usernic_debug_stream(stream, format, ...)                              \\\n\tdo {                                                                   \\\n\t\tfprintf(stream, \"%s: %d: %s: \" format, __FILE__, __LINE__,     \\\n\t\t\t__func__, __VA_ARGS__);                                \\\n\t} while (false)\n\n#define usernic_error(format, ...) usernic_debug_stream(stderr, format, __VA_ARGS__)\n\nstatic void usage(char *me, bool fail)\n{\n\tfprintf(stderr, \"Usage: %s lxcpath name pid type bridge nicname\\n\", me);\n\tfprintf(stderr, \" nicname is the name to use inside the container\\n\");\n\texit(fail ? 1 : 0);\n}\n\nstatic char *lxcpath, *lxcname;\n\nstatic int open_and_lock(char *path)\n{\n\tint fd;\n\tstruct flock lk;\n\n\tfd = open(path, O_RDWR|O_CREAT, S_IWUSR | S_IRUSR);\n\tif (fd < 0) {\n\t\tfprintf(stderr, \"Failed to open %s: %s\\n\",\n\t\t\tpath, strerror(errno));\n\t\treturn(fd);\n\t}\n\n\tlk.l_type = F_WRLCK;\n\tlk.l_whence = SEEK_SET;\n\tlk.l_start = 0;\n\tlk.l_len = 0;\n\tif (fcntl(fd, F_SETLKW, &lk) < 0) {\n\t\tfprintf(stderr, \"Failed to lock %s: %s\\n\",\n\t\t\tpath, strerror(errno));\n\t\tclose(fd);\n\t\treturn -1;\n\t}\n\n\treturn fd;\n}\n\n\nstatic char *get_username(void)\n{\n\tstruct passwd *pwd = getpwuid(getuid());\n\n\tif (pwd == NULL) {\n\t\tperror(\"getpwuid\");\n\t\treturn NULL;\n\t}\n\n\treturn pwd->pw_name;\n}\n\nstatic void free_groupnames(char **groupnames)\n{\n\tint i;\n\tif (!groupnames)\n\t\treturn;\n\tfor (i = 0; groupnames[i]; i++)\n\t\tfree(groupnames[i]);\n\tfree(groupnames);\n}\n\nstatic char **get_groupnames(void)\n{\n\tint ngroups;\n\tgid_t *group_ids;\n\tint ret, i;\n\tchar **groupnames;\n\tstruct group *gr;\n\n\tngroups = getgroups(0, NULL);\n\n\tif (ngroups == -1) {\n\t\tfprintf(stderr, \"Failed to get number of groups user belongs to: %s\\n\", strerror(errno));\n\t\treturn NULL;\n\t}\n\tif (ngroups == 0)\n\t\treturn NULL;\n\n\tgroup_ids = (gid_t *)malloc(sizeof(gid_t)*ngroups);\n\n\tif (group_ids == NULL) {\n\t\tfprintf(stderr, \"Out of memory while getting groups the user belongs to\\n\");\n\t\treturn NULL;\n\t}\n\n\tret = getgroups(ngroups, group_ids);\n\n\tif (ret < 0) {\n\t\tfree(group_ids);\n\t\tfprintf(stderr, \"Failed to get process groups: %s\\n\", strerror(errno));\n\t\treturn NULL;\n\t}\n\n\tgroupnames = (char **)malloc(sizeof(char *)*(ngroups+1));\n\n\tif (groupnames == NULL) {\n\t\tfree(group_ids);\n\t\tfprintf(stderr, \"Out of memory while getting group names\\n\");\n\t\treturn NULL;\n\t}\n\n\tmemset(groupnames, 0, sizeof(char *)*(ngroups+1));\n\n\tfor (i=0; i<ngroups; i++ ) {\n\t\tgr = getgrgid(group_ids[i]);\n\n\t\tif (gr == NULL) {\n\t\t\tfprintf(stderr, \"Failed to get group name\\n\");\n\t\t\tfree(group_ids);\n\t\t\tfree_groupnames(groupnames);\n\t\t\treturn NULL;\n\t\t}\n\n\t\tgroupnames[i] = strdup(gr->gr_name);\n\n\t\tif (groupnames[i] == NULL) {\n\t\t\tfprintf(stderr, \"Failed to copy group name: %s\", gr->gr_name);\n\t\t\tfree(group_ids);\n\t\t\tfree_groupnames(groupnames);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\n\tfree(group_ids);\n\n\treturn groupnames;\n}\n\nstatic bool name_is_in_groupnames(char *name, char **groupnames)\n{\n\twhile (groupnames != NULL) {\n\t\tif (strcmp(name, *groupnames) == 0)\n\t\t\treturn true;\n\t\tgroupnames++;\n\t}\n\treturn false;\n}\n\nstruct alloted_s {\n\tchar *name;\n\tint allowed;\n\tstruct alloted_s *next;\n};\n\nstatic struct alloted_s *append_alloted(struct alloted_s **head, char *name, int n)\n{\n\tstruct alloted_s *cur, *al;\n\n\tif (head == NULL || name == NULL) {\n\t\t// sanity check. parameters should not be null\n\t\tfprintf(stderr, \"NULL parameters to append_alloted not allowed\\n\");\n\t\treturn NULL;\n\t}\n\n\tal = (struct alloted_s *)malloc(sizeof(struct alloted_s));\n\n\tif (al == NULL) {\n\t\t// unable to allocate memory to new struct\n\t\tfprintf(stderr, \"Out of memory in append_alloted\\n\");\n\t\treturn NULL;\n\t}\n\n\tal->name = strdup(name);\n\n\tif (al->name == NULL) {\n\t\tfree(al);\n\t\treturn NULL;\n\t}\n\n\tal->allowed = n;\n\tal->next = NULL;\n\n\tif (*head == NULL) {\n\t\t*head = al;\n\t\treturn al;\n\t}\n\n\tcur = *head;\n\twhile (cur->next != NULL)\n\t\tcur = cur->next;\n\n\tcur->next = al;\n\treturn al;\n}\n\nstatic void free_alloted(struct alloted_s **head)\n{\n\tstruct alloted_s *cur;\n\n\tif (head == NULL) {\n\t\treturn;\n\t}\n\n\tcur = *head;\n\n\twhile (cur != NULL) {\n\t\tcur = cur->next;\n\t\tfree((*head)->name);\n\t\tfree(*head);\n\t\t*head = cur;\n\t}\n}\n\n/* The configuration file consists of lines of the form:\n *\n * user type bridge count\n * or\n * @group type bridge count\n *\n * Return the count entry for the calling user if there is one.  Else\n * return -1.\n */\nstatic int get_alloted(char *me, char *intype, char *link, struct alloted_s **alloted)\n{\n\tFILE *fin = fopen(LXC_USERNIC_CONF, \"r\");\n\tchar *line = NULL;\n\tchar name[100], type[100], br[100];\n\tsize_t len = 0;\n\tint n, ret, count = 0;\n\tchar **groups;\n\n\tif (!fin) {\n\t\tfprintf(stderr, \"Failed to open %s: %s\\n\", LXC_USERNIC_CONF,\n\t\t\tstrerror(errno));\n\t\treturn -1;\n\t}\n\n\tgroups = get_groupnames();\n\twhile ((getline(&line, &len, fin)) != -1) {\n\t\tret = sscanf(line, \"%99[^ \\t] %99[^ \\t] %99[^ \\t] %d\", name, type, br, &n);\n\n\t\tif (ret != 4)\n\t\t\tcontinue;\n\n\t\tif (strlen(name) == 0)\n\t\t\tcontinue;\n\n\t\tif (strcmp(name, me) != 0)\n\t\t{\n\t\t\tif (name[0] != '@')\n\t\t\t\tcontinue;\n\t\t\tif (!name_is_in_groupnames(name+1, groups))\n\t\t\t\tcontinue;\n\t\t}\n\t\tif (strcmp(type, intype) != 0)\n\t\t\tcontinue;\n\t\tif (strcmp(link, br) != 0)\n\t\t\tcontinue;\n\n\t\t/* found the user or group with the appropriate settings, therefore finish the search.\n\t\t * what to do if there are more than one applicable lines? not specified in the docs.\n\t\t * since getline is implemented with realloc, we don't need to free line until exiting func.\n\t\t *\n\t\t * if append_alloted returns NULL, e.g. due to a malloc error, we set count to 0 and break the loop,\n\t\t * allowing cleanup and then exiting from main()\n\t\t */\n\t\tif (append_alloted(alloted, name, n) == NULL) {\n\t\t\tcount = 0;\n\t\t\tbreak;\n\t\t}\n\t\tcount += n;\n\t}\n\n\tfree_groupnames(groups);\n\tfclose(fin);\n\tfree(line);\n\n\t// now return the total number of nics that this user can create\n\treturn count;\n}\n\nstatic char *get_eol(char *s, char *e)\n{\n\twhile (s<e && *s && *s != '\\n')\n\t\ts++;\n\treturn s;\n}\n\nstatic char *get_eow(char *s, char *e)\n{\n\twhile (s<e && *s && !isblank(*s) && *s != '\\n')\n\t\ts++;\n\treturn s;\n}\n\nstatic char *find_line(char *p, char *e, char *u, char *t, char *l)\n{\n\tchar *p1, *p2, *ret;\n\n\twhile (p<e  && (p1 = get_eol(p, e)) < e) {\n\t\tret = p;\n\t\tif (*p == '#')\n\t\t\tgoto next;\n\t\twhile (p<e && isblank(*p)) p++;\n\t\tp2 = get_eow(p, e);\n\t\tif (!p2 || p2-p != strlen(u) || strncmp(p, u, strlen(u)) != 0)\n\t\t\tgoto next;\n\t\tp = p2+1;\n\t\twhile (p<e && isblank(*p)) p++;\n\t\tp2 = get_eow(p, e);\n\t\tif (!p2 || p2-p != strlen(t) || strncmp(p, t, strlen(t)) != 0)\n\t\t\tgoto next;\n\t\tp = p2+1;\n\t\twhile (p<e && isblank(*p)) p++;\n\t\tp2 = get_eow(p, e);\n\t\tif (!p2 || p2-p != strlen(l) || strncmp(p, l, strlen(l)) != 0)\n\t\t\tgoto next;\n\t\treturn ret;\nnext:\n\t\tp = p1 + 1;\n\t}\n\n\treturn NULL;\n}\n\nstatic bool nic_exists(char *nic)\n{\n\tchar path[MAXPATHLEN];\n\tint ret;\n\tstruct stat sb;\n\n\tif (strcmp(nic, \"none\") == 0)\n\t\treturn true;\n\tret = snprintf(path, MAXPATHLEN, \"/sys/class/net/%s\", nic);\n\tif (ret < 0 || ret >= MAXPATHLEN) // should never happen!\n\t\treturn false;\n\tret = stat(path, &sb);\n\tif (ret != 0)\n\t\treturn false;\n\treturn true;\n}\n\nstatic int instantiate_veth(char *n1, char **n2)\n{\n\tint err;\n\n\terr = snprintf(*n2, IFNAMSIZ, \"%sp\", n1);\n\tif (err < 0 || err >= IFNAMSIZ) {\n\t\tfprintf(stderr, \"nic name too long\\n\");\n\t\treturn -1;\n\t}\n\n\terr = lxc_veth_create(n1, *n2);\n\tif (err) {\n\t\tfprintf(stderr, \"failed to create %s-%s : %s\\n\", n1, *n2,\n\t\t      strerror(-err));\n\t\treturn -1;\n\t}\n\n\t/* changing the high byte of the mac address to 0xfe, the bridge interface\n\t * will always keep the host's mac address and not take the mac address\n\t * of a container */\n\terr = setup_private_host_hw_addr(n1);\n\tif (err) {\n\t\tfprintf(stderr, \"failed to change mac address of host interface '%s' : %s\\n\",\n\t\t\tn1, strerror(-err));\n\t}\n\n\treturn netdev_set_flag(n1, IFF_UP);\n}\n\nstatic int get_mtu(char *name)\n{\n\tint idx = if_nametoindex(name);\n\treturn netdev_get_mtu(idx);\n}\n\nstatic bool create_nic(char *nic, char *br, int pid, char **cnic)\n{\n\tchar *veth1buf, *veth2buf;\n\tveth1buf = alloca(IFNAMSIZ);\n\tveth2buf = alloca(IFNAMSIZ);\n\tint ret, mtu;\n\n\tret = snprintf(veth1buf, IFNAMSIZ, \"%s\", nic);\n\tif (ret < 0 || ret >= IFNAMSIZ) {\n\t\tfprintf(stderr, \"host nic name too long\\n\");\n\t\treturn false;\n\t}\n\n\t/* create the nics */\n\tif (instantiate_veth(veth1buf, &veth2buf) < 0) {\n\t\tfprintf(stderr, \"Error creating veth tunnel\\n\");\n\t\treturn false;\n\t}\n\n\tif (strcmp(br, \"none\") != 0) {\n\t\t/* copy the bridge's mtu to both ends */\n\t\tmtu = get_mtu(br);\n\t\tif (mtu != -1) {\n\t\t\tif (lxc_netdev_set_mtu(veth1buf, mtu) < 0 ||\n\t\t\t\t\tlxc_netdev_set_mtu(veth2buf, mtu) < 0) {\n\t\t\t\tfprintf(stderr, \"Failed setting mtu\\n\");\n\t\t\t\tgoto out_del;\n\t\t\t}\n\t\t}\n\n\t\t/* attach veth1 to bridge */\n\t\tif (lxc_bridge_attach(lxcpath, lxcname, br, veth1buf) < 0) {\n\t\t\tfprintf(stderr, \"Error attaching %s to %s\\n\", veth1buf, br);\n\t\t\tgoto out_del;\n\t\t}\n\t}\n\n\t/* pass veth2 to target netns */\n\tret = lxc_netdev_move_by_name(veth2buf, pid, NULL);\n\tif (ret < 0) {\n\t\tfprintf(stderr, \"Error moving %s to netns %d\\n\", veth2buf, pid);\n\t\tgoto out_del;\n\t}\n\t*cnic = strdup(veth2buf);\n\treturn true;\n\nout_del:\n\tlxc_netdev_delete_by_name(veth1buf);\n\treturn false;\n}\n\n/*\n * Get a new nic.\n * *dest will container the name (vethXXXXXX) which is attached\n * on the host to the lxc bridge\n */\nstatic bool get_new_nicname(char **dest, char *br, int pid, char **cnic)\n{\n\tchar template[IFNAMSIZ];\n\tsnprintf(template, sizeof(template), \"vethXXXXXX\");\n\t*dest = lxc_mkifname(template);\n\n\tif (!create_nic(*dest, br, pid, cnic)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool get_nic_from_line(char *p, char **nic)\n{\n\tchar user[100], type[100], br[100];\n\tint ret;\n\n\tret = sscanf(p, \"%99[^ \\t\\n] %99[^ \\t\\n] %99[^ \\t\\n] %99[^ \\t\\n]\", user, type, br, *nic);\n\tif (ret != 4)\n\t\treturn false;\n\treturn true;\n}\n\nstruct entry_line {\n\tchar *start;\n\tint len;\n\tbool keep;\n};\n\nstatic bool cull_entries(int fd, char *me, char *t, char *br)\n{\n\tstruct stat sb;\n\tchar *buf, *p, *e, *nic;\n\toff_t len;\n\tstruct entry_line *entry_lines = NULL;\n\tint i, n = 0;\n\n\tnic = alloca(100);\n\n\tif (fstat(fd, &sb) < 0) {\n\t\tfprintf(stderr, \"Failed to fstat: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\tlen = sb.st_size;\n\tif (len == 0)\n\t\treturn true;\n\tbuf = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\tif (buf == MAP_FAILED) {\n\t\tfprintf(stderr, \"Failed to create mapping: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\n\tp = buf;\n\te = buf + len;\n\twhile ((p = find_line(p, e, me, t, br)) != NULL) {\n\t\tstruct entry_line *newe = realloc(entry_lines, sizeof(*entry_lines)*(n+1));\n\t\tif (!newe) {\n\t\t\tfree(entry_lines);\n\t\t\treturn false;\n\t\t}\n\t\tentry_lines = newe;\n\t\tentry_lines[n].start = p;\n\t\tentry_lines[n].len = get_eol(p, e) - entry_lines[n].start;\n\t\tentry_lines[n].keep = true;\n\t\tn++;\n\t\tif (!get_nic_from_line(p, &nic))\n\t\t\tcontinue;\n\t\tif (nic && !nic_exists(nic))\n\t\t\tentry_lines[n-1].keep = false;\n\t\tp += entry_lines[n-1].len + 1;\n\t\tif (p >= e)\n\t\t\tbreak;\n \t}\n\tp = buf;\n\tfor (i=0; i<n; i++) {\n\t\tif (!entry_lines[i].keep)\n\t\t\tcontinue;\n\t\tmemcpy(p, entry_lines[i].start, entry_lines[i].len);\n\t\tp += entry_lines[i].len;\n\t\t*p = '\\n';\n\t\tp++;\n\t}\n\tfree(entry_lines);\n\tmunmap(buf, sb.st_size);\n\tif (ftruncate(fd, p-buf))\n\t\tfprintf(stderr, \"Failed to set new file size\\n\");\n\treturn true;\n}\n\nstatic int count_entries(char *buf, off_t len, char *me, char *t, char *br)\n{\n\tchar *e = &buf[len];\n\tint count = 0;\n\twhile ((buf = find_line(buf, e, me, t, br)) != NULL) {\n\t\tcount++;\n\t\tbuf = get_eol(buf, e)+1;\n\t\tif (buf >= e)\n\t\t\tbreak;\n\t}\n\n\treturn count;\n}\n\n/*\n * The dbfile has lines of the format:\n * user type bridge nicname\n */\nstatic bool get_nic_if_avail(int fd, struct alloted_s *names, int pid, char *intype, char *br, int allowed, char **nicname, char **cnic)\n{\n\toff_t len, slen;\n\tstruct stat sb;\n\tchar *buf = NULL, *newline;\n\tint ret, count = 0;\n\tchar *owner;\n\tstruct alloted_s *n;\n\n\tfor (n=names; n!=NULL; n=n->next)\n\t\tcull_entries(fd, n->name, intype, br);\n\n\tif (allowed == 0)\n\t\treturn false;\n\n\towner = names->name;\n\n\tif (fstat(fd, &sb) < 0) {\n\t\tfprintf(stderr, \"Failed to fstat: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\tlen = sb.st_size;\n\tif (len != 0) {\n\t\tbuf = mmap(NULL, len, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\t\tif (buf == MAP_FAILED) {\n\t\t\tfprintf(stderr, \"Failed to create mapping\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\towner = NULL;\n\t\tfor (n=names; n!=NULL; n=n->next) {\n\t\t\tcount = count_entries(buf, len, n->name, intype, br);\n\n\t\t\tif (count >= n->allowed)\n\t\t\t\tcontinue;\n\n\t\t\towner = n->name;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (owner == NULL)\n\t\treturn false;\n\n\tif (!get_new_nicname(nicname, br, pid, cnic))\n\t\treturn false;\n\t/* owner  ' ' intype ' ' br ' ' *nicname + '\\n' + '\\0' */\n\tslen = strlen(owner) + strlen(intype) + strlen(br) + strlen(*nicname) + 5;\n\tnewline = alloca(slen);\n\tret = snprintf(newline, slen, \"%s %s %s %s\\n\", owner, intype, br, *nicname);\n\tif (ret < 0 || ret >= slen) {\n\t\tif (lxc_netdev_delete_by_name(*nicname) != 0)\n\t\t\tfprintf(stderr, \"Error unlinking %s!\\n\", *nicname);\n\t\treturn false;\n\t}\n\tif (len)\n\t\tmunmap(buf, len);\n\tif (ftruncate(fd, len + slen))\n\t\tfprintf(stderr, \"Failed to set new file size\\n\");\n\tbuf = mmap(NULL, len + slen, PROT_READ|PROT_WRITE, MAP_SHARED, fd, 0);\n\tif (buf == MAP_FAILED) {\n\t\tfprintf(stderr, \"Failed to create mapping after extending: %s\\n\", strerror(errno));\n\t\tif (lxc_netdev_delete_by_name(*nicname) != 0)\n\t\t\tfprintf(stderr, \"Error unlinking %s!\\n\", *nicname);\n\t\treturn false;\n\t}\n\tstrcpy(buf+len, newline);\n\tmunmap(buf, len+slen);\n\treturn true;\n}\n\nstatic bool create_db_dir(char *fnam)\n{\n\tchar *p = alloca(strlen(fnam)+1);\n\n\tstrcpy(p, fnam);\n\tfnam = p;\n\tp = p + 1;\nagain:\n\twhile (*p && *p != '/') p++;\n\tif (!*p)\n\t\treturn true;\n\t*p = '\\0';\n\tif (mkdir(fnam, 0755) && errno != EEXIST) {\n\t\tfprintf(stderr, \"failed to create %s\\n\", fnam);\n\t\t*p = '/';\n\t\treturn false;\n\t}\n\t*(p++) = '/';\n\tgoto again;\n}\n\n#define VETH_DEF_NAME \"eth%d\"\nstatic int rename_in_ns(int pid, char *oldname, char **newnamep)\n{\n\tuid_t ruid, suid, euid;\n\tint fret = -1;\n\tint fd = -1, ifindex = -1, ofd = -1, ret;\n\tbool grab_newname = false;\n\n\tofd = lxc_preserve_ns(getpid(), \"net\");\n\tif (ofd < 0) {\n\t\tusernic_error(\"Failed opening network namespace path for '%d'.\", getpid());\n\t\treturn fret;\n\t}\n\n\tfd = lxc_preserve_ns(pid, \"net\");\n\tif (fd < 0) {\n\t\tusernic_error(\"Failed opening network namespace path for '%d'.\", pid);\n\t\tgoto do_partial_cleanup;\n\t}\n\n\tret = getresuid(&ruid, &euid, &suid);\n\tif (ret < 0) {\n\t\tusernic_error(\"Failed to retrieve real, effective, and saved \"\n\t\t\t      \"user IDs: %s\\n\",\n\t\t\t      strerror(errno));\n\t\tgoto do_partial_cleanup;\n\t}\n\n\tret = setns(fd, CLONE_NEWNET);\n\tclose(fd);\n\tfd = -1;\n\tif (ret < 0) {\n\t\tusernic_error(\"Failed to setns() to the network namespace of \"\n\t\t\t      \"the container with PID %d: %s.\\n\",\n\t\t\t      pid, strerror(errno));\n\t\tgoto do_partial_cleanup;\n\t}\n\n\tret = setresuid(ruid, ruid, 0);\n\tif (ret < 0) {\n\t\tusernic_error(\"Failed to drop privilege by setting effective \"\n\t\t\t      \"user id and real user id to %d, and saved user \"\n\t\t\t      \"ID to 0: %s.\\n\",\n\t\t\t      ruid, strerror(errno));\n\t\t// COMMENT(brauner): It's ok to jump to do_full_cleanup here\n\t\t// since setresuid() will succeed when trying to set real,\n\t\t// effective, and saved to values they currently have.\n\t\tgoto do_full_cleanup;\n\t}\n\n\tif (!*newnamep) {\n\t\tgrab_newname = true;\n\t\t*newnamep = VETH_DEF_NAME;\n\n\t\tifindex = if_nametoindex(oldname);\n\t\tif (!ifindex) {\n\t\t\tusernic_error(\"Failed to get netdev index: %s.\\n\", strerror(errno));\n\t\t\tgoto do_full_cleanup;\n\t\t}\n\t}\n\n\tret = lxc_netdev_rename_by_name(oldname, *newnamep);\n\tif (ret < 0) {\n\t\tusernic_error(\"Error %d renaming netdev %s to %s in container.\\n\", ret, oldname, *newnamep);\n\t\tgoto do_full_cleanup;\n\t}\n\n\tif (grab_newname) {\n\t\tchar ifname[IFNAMSIZ];\n\t\tchar *namep = ifname;\n\n\t\tif (!if_indextoname(ifindex, namep)) {\n\t\t\tusernic_error(\"Failed to get new netdev name: %s.\\n\", strerror(errno));\n\t\t\tgoto do_full_cleanup;\n\t\t}\n\n\t\t*newnamep = strdup(namep);\n\t\tif (!*newnamep)\n\t\t\tgoto do_full_cleanup;\n\t}\n\n\tfret = 0;\n\ndo_full_cleanup:\n\tret = setresuid(ruid, euid, suid);\n\tif (ret < 0) {\n\t\tusernic_error(\"Failed to restore privilege by setting effective \"\n\t\t\t      \"user id to %d, real user id to %d, and saved user \"\n\t\t\t      \"ID to %d: %s.\\n\",\n\t\t\t      ruid, euid, suid, strerror(errno));\n\t\tfret = -1;\n\t\t// COMMENT(brauner): setns() should fail if setresuid() doesn't\n\t\t// succeed but there's no harm in falling through; keeps the\n\t\t// code cleaner.\n\t}\n\n\tret = setns(ofd, CLONE_NEWNET);\n\tif (ret < 0) {\n\t\tusernic_error(\"Failed to setns() to original network namespace \"\n\t\t\t      \"of PID %d: %s.\\n\",\n\t\t\t      ofd, strerror(errno));\n\t\tfret = -1;\n\t}\n\ndo_partial_cleanup:\n\tif (fd >= 0)\n\t\tclose(fd);\n\tclose(ofd);\n\n\treturn fret;\n}\n\n/*\n * If the caller (real uid, not effective uid) may read the\n * /proc/[pid]/ns/net, then it is either the caller's netns or one\n * which it created.\n */\nstatic bool may_access_netns(int pid)\n{\n\tint ret;\n\tchar s[200];\n\tuid_t ruid, suid, euid;\n\tbool may_access = false;\n\n\tret = getresuid(&ruid, &euid, &suid);\n\tif (ret) {\n\t\tfprintf(stderr, \"Failed to get my uids: %s\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\tret = setresuid(ruid, ruid, euid);\n\tif (ret) {\n\t\tfprintf(stderr, \"Failed to set temp uids to (%d,%d,%d): %s\\n\",\n\t\t\t\t(int)ruid, (int)ruid, (int)euid, strerror(errno));\n\t\treturn false;\n\t}\n\tret = snprintf(s, 200, \"/proc/%d/ns/net\", pid);\n\tif (ret < 0 || ret >= 200)  // can't happen\n\t\treturn false;\n\tret = access(s, R_OK);\n\tif (ret) {\n\t\tfprintf(stderr, \"Uid %d may not access %s: %s\\n\",\n\t\t\t\t(int)ruid, s, strerror(errno));\n\t}\n\tmay_access = ret == 0;\n\tret = setresuid(ruid, euid, suid);\n\tif (ret) {\n\t\tfprintf(stderr, \"Failed to restore uids to (%d,%d,%d): %s\\n\",\n\t\t\t\t(int)ruid, (int)euid, (int)suid, strerror(errno));\n\t\tmay_access = false;\n\t}\n\treturn may_access;\n}\n\nint main(int argc, char *argv[])\n{\n\tint n, fd;\n\tbool gotone = false;\n\tchar *me;\n\tchar *nicname = alloca(40);\n\tchar *cnic = NULL; // created nic name in container is returned here.\n\tchar *vethname = NULL;\n\tint pid;\n\tstruct alloted_s *alloted = NULL;\n\n\t/* set a sane env, because we are setuid-root */\n\tif (clearenv() < 0) {\n\t\tfprintf(stderr, \"Failed to clear environment\");\n\t\texit(1);\n\t}\n\tif (setenv(\"PATH\", \"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\", 1) < 0) {\n\t\tfprintf(stderr, \"Failed to set PATH, exiting\\n\");\n\t\texit(1);\n\t}\n\tif ((me = get_username()) == NULL) {\n\t\tfprintf(stderr, \"Failed to get username\\n\");\n\t\texit(1);\n\t}\n\n\tif (argc < 6)\n\t\tusage(argv[0], true);\n\tif (argc >= 7)\n\t\tvethname = argv[6];\n\n\tlxcpath = argv[1];\n\tlxcname = argv[2];\n\n\terrno = 0;\n\tpid = (int) strtol(argv[3], NULL, 10);\n\tif (errno) {\n\t\tfprintf(stderr, \"Could not read pid: %s\\n\", argv[1]);\n\t\texit(1);\n\t}\n\n\tif (!create_db_dir(LXC_USERNIC_DB)) {\n\t\tfprintf(stderr, \"Failed to create directory for db file\\n\");\n\t\texit(1);\n\t}\n\n\tif ((fd = open_and_lock(LXC_USERNIC_DB)) < 0) {\n\t\tfprintf(stderr, \"Failed to lock %s\\n\", LXC_USERNIC_DB);\n\t\texit(1);\n\t}\n\n\tif (!may_access_netns(pid)) {\n\t\tfprintf(stderr, \"User %s may not modify netns for pid %d\\n\",\n\t\t\tme, pid);\n\t\texit(1);\n\t}\n\n\tn = get_alloted(me, argv[4], argv[5], &alloted);\n\tif (n > 0)\n\t\tgotone = get_nic_if_avail(fd, alloted, pid, argv[4], argv[5], n, &nicname, &cnic);\n\n\tclose(fd);\n\tfree_alloted(&alloted);\n\tif (!gotone) {\n\t\tfprintf(stderr, \"Quota reached\\n\");\n\t\texit(1);\n\t}\n\n\t// Now rename the link\n\tif (rename_in_ns(pid, cnic, &vethname) < 0) {\n\t\tfprintf(stderr, \"Failed to rename the link\\n\");\n\t\texit(1);\n\t}\n\n\t// write the name of the interface pair to the stdout - like eth0:veth9MT2L4\n\tfprintf(stdout, \"%s:%s\\n\", vethname, nicname);\n\texit(0);\n}\n"], "filenames": ["src/lxc/lxc_user_nic.c"], "buggy_code_start_loc": [52], "buggy_code_end_loc": [735], "fixing_code_start_loc": [53], "fixing_code_end_loc": [790], "type": "CWE-862", "message": "lxc-user-nic in Linux Containers (LXC) allows local users with a lxc-usernet allocation to create network interfaces on the host and choose the name of those interfaces by leveraging lack of netns ownership check.", "other": {"cve": {"id": "CVE-2017-5985", "sourceIdentifier": "cve@mitre.org", "published": "2017-03-14T17:59:00.183", "lastModified": "2019-10-03T00:03:26.223", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "lxc-user-nic in Linux Containers (LXC) allows local users with a lxc-usernet allocation to create network interfaces on the host and choose the name of those interfaces by leveraging lack of netns ownership check."}, {"lang": "es", "value": "lxc-user-nic en Linux Containers (LXC) permite a usuarios locales con una asignaci\u00f3n lxc-usernet crear interfaces de red en el host y elegir el nombre de esas interfaces aprovechando la falta de verificaci\u00f3n de propiedad de netns."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:L/A:N", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 3.3, "baseSeverity": "LOW"}, "exploitabilityScore": 1.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:L/AC:L/Au:N/C:N/I:P/A:N", "accessVector": "LOCAL", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "PARTIAL", "availabilityImpact": "NONE", "baseScore": 2.1}, "baseSeverity": "LOW", "exploitabilityScore": 3.9, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-862"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:linuxcontainers:lxc:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.0.9", "matchCriteriaId": "CD42973B-545C-4D49-8DDA-CB3A9D6C68F5"}, {"vulnerable": true, "criteria": "cpe:2.3:a:linuxcontainers:lxc:*:*:*:*:*:*:*:*", "versionStartIncluding": "2.0.0", "versionEndIncluding": "2.0.6", "matchCriteriaId": "A326DD9B-29E6-4253-8270-B9D85FF0E8AF"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-05/msg00073.html", "source": "cve@mitre.org"}, {"url": "http://www.openwall.com/lists/oss-security/2017/03/09/4", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/96777", "source": "cve@mitre.org", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "http://www.ubuntu.com/usn/USN-3224-1", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://bugs.launchpad.net/ubuntu/+source/lxc/+bug/1654676", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://github.com/lxc/lxc/commit/16af238036a5464ae8f2420ed3af214f0de875f9", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://lists.linuxcontainers.org/pipermail/lxc-devel/2017-March/015535.html", "source": "cve@mitre.org", "tags": ["Vendor Advisory"]}]}, "github_commit_url": "https://github.com/lxc/lxc/commit/16af238036a5464ae8f2420ed3af214f0de875f9"}}