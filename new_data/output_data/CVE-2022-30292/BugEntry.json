{"buggy_code": ["/*\n    see copyright notice in squirrel.h\n*/\n#include \"sqpcheader.h\"\n#include \"sqvm.h\"\n#include \"sqstring.h\"\n#include \"sqtable.h\"\n#include \"sqarray.h\"\n#include \"sqfuncproto.h\"\n#include \"sqclosure.h\"\n#include \"sqclass.h\"\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n\nstatic bool str2num(const SQChar *s,SQObjectPtr &res,SQInteger base)\n{\n    SQChar *end;\n    const SQChar *e = s;\n    bool iseintbase = base > 13; //to fix error converting hexadecimals with e like 56f0791e\n    bool isfloat = false;\n    SQChar c;\n    while((c = *e) != _SC('\\0'))\n    {\n        if (c == _SC('.') || (!iseintbase && (c == _SC('E') || c == _SC('e')))) { //e and E is for scientific notation\n            isfloat = true;\n            break;\n        }\n        e++;\n    }\n    if(isfloat){\n        SQFloat r = SQFloat(scstrtod(s,&end));\n        if(s == end) return false;\n        res = r;\n    }\n    else{\n        SQInteger r = SQInteger(scstrtol(s,&end,(int)base));\n        if(s == end) return false;\n        res = r;\n    }\n    return true;\n}\n\nstatic SQInteger base_dummy(HSQUIRRELVM SQ_UNUSED_ARG(v))\n{\n    return 0;\n}\n\n#ifndef NO_GARBAGE_COLLECTOR\nstatic SQInteger base_collectgarbage(HSQUIRRELVM v)\n{\n    sq_pushinteger(v, sq_collectgarbage(v));\n    return 1;\n}\nstatic SQInteger base_resurectureachable(HSQUIRRELVM v)\n{\n    sq_resurrectunreachable(v);\n    return 1;\n}\n#endif\n\nstatic SQInteger base_getroottable(HSQUIRRELVM v)\n{\n    v->Push(v->_roottable);\n    return 1;\n}\n\nstatic SQInteger base_getconsttable(HSQUIRRELVM v)\n{\n    v->Push(_ss(v)->_consts);\n    return 1;\n}\n\n\nstatic SQInteger base_setroottable(HSQUIRRELVM v)\n{\n    SQObjectPtr o = v->_roottable;\n    if(SQ_FAILED(sq_setroottable(v))) return SQ_ERROR;\n    v->Push(o);\n    return 1;\n}\n\nstatic SQInteger base_setconsttable(HSQUIRRELVM v)\n{\n    SQObjectPtr o = _ss(v)->_consts;\n    if(SQ_FAILED(sq_setconsttable(v))) return SQ_ERROR;\n    v->Push(o);\n    return 1;\n}\n\nstatic SQInteger base_seterrorhandler(HSQUIRRELVM v)\n{\n    sq_seterrorhandler(v);\n    return 0;\n}\n\nstatic SQInteger base_setdebughook(HSQUIRRELVM v)\n{\n    sq_setdebughook(v);\n    return 0;\n}\n\nstatic SQInteger base_enabledebuginfo(HSQUIRRELVM v)\n{\n    SQObjectPtr &o=stack_get(v,2);\n\n    sq_enabledebuginfo(v,SQVM::IsFalse(o)?SQFalse:SQTrue);\n    return 0;\n}\n\nstatic SQInteger __getcallstackinfos(HSQUIRRELVM v,SQInteger level)\n{\n    SQStackInfos si;\n    SQInteger seq = 0;\n    const SQChar *name = NULL;\n\n    if (SQ_SUCCEEDED(sq_stackinfos(v, level, &si)))\n    {\n        const SQChar *fn = _SC(\"unknown\");\n        const SQChar *src = _SC(\"unknown\");\n        if(si.funcname)fn = si.funcname;\n        if(si.source)src = si.source;\n        sq_newtable(v);\n        sq_pushstring(v, _SC(\"func\"), -1);\n        sq_pushstring(v, fn, -1);\n        sq_newslot(v, -3, SQFalse);\n        sq_pushstring(v, _SC(\"src\"), -1);\n        sq_pushstring(v, src, -1);\n        sq_newslot(v, -3, SQFalse);\n        sq_pushstring(v, _SC(\"line\"), -1);\n        sq_pushinteger(v, si.line);\n        sq_newslot(v, -3, SQFalse);\n        sq_pushstring(v, _SC(\"locals\"), -1);\n        sq_newtable(v);\n        seq=0;\n        while ((name = sq_getlocal(v, level, seq))) {\n            sq_pushstring(v, name, -1);\n            sq_push(v, -2);\n            sq_newslot(v, -4, SQFalse);\n            sq_pop(v, 1);\n            seq++;\n        }\n        sq_newslot(v, -3, SQFalse);\n        return 1;\n    }\n\n    return 0;\n}\nstatic SQInteger base_getstackinfos(HSQUIRRELVM v)\n{\n    SQInteger level;\n    sq_getinteger(v, -1, &level);\n    return __getcallstackinfos(v,level);\n}\n\nstatic SQInteger base_assert(HSQUIRRELVM v)\n{\n    if(SQVM::IsFalse(stack_get(v,2))){\n        SQInteger top = sq_gettop(v);\n        if (top>2 && SQ_SUCCEEDED(sq_tostring(v,3))) {\n            const SQChar *str = 0;\n            if (SQ_SUCCEEDED(sq_getstring(v,-1,&str))) {\n                return sq_throwerror(v, str);\n            }\n        }\n        return sq_throwerror(v, _SC(\"assertion failed\"));\n    }\n    return 0;\n}\n\nstatic SQInteger get_slice_params(HSQUIRRELVM v,SQInteger &sidx,SQInteger &eidx,SQObjectPtr &o)\n{\n    SQInteger top = sq_gettop(v);\n    sidx=0;\n    eidx=0;\n    o=stack_get(v,1);\n    if(top>1){\n        SQObjectPtr &start=stack_get(v,2);\n        if(sq_type(start)!=OT_NULL && sq_isnumeric(start)){\n            sidx=tointeger(start);\n        }\n    }\n    if(top>2){\n        SQObjectPtr &end=stack_get(v,3);\n        if(sq_isnumeric(end)){\n            eidx=tointeger(end);\n        }\n    }\n    else {\n        eidx = sq_getsize(v,1);\n    }\n    return 1;\n}\n\nstatic SQInteger base_print(HSQUIRRELVM v)\n{\n    const SQChar *str;\n    if(SQ_SUCCEEDED(sq_tostring(v,2)))\n    {\n        if(SQ_SUCCEEDED(sq_getstring(v,-1,&str))) {\n            if(_ss(v)->_printfunc) _ss(v)->_printfunc(v,_SC(\"%s\"),str);\n            return 0;\n        }\n    }\n    return SQ_ERROR;\n}\n\nstatic SQInteger base_error(HSQUIRRELVM v)\n{\n    const SQChar *str;\n    if(SQ_SUCCEEDED(sq_tostring(v,2)))\n    {\n        if(SQ_SUCCEEDED(sq_getstring(v,-1,&str))) {\n            if(_ss(v)->_errorfunc) _ss(v)->_errorfunc(v,_SC(\"%s\"),str);\n            return 0;\n        }\n    }\n    return SQ_ERROR;\n}\n\nstatic SQInteger base_compilestring(HSQUIRRELVM v)\n{\n    SQInteger nargs=sq_gettop(v);\n    const SQChar *src=NULL,*name=_SC(\"unnamedbuffer\");\n    SQInteger size;\n    sq_getstring(v,2,&src);\n    size=sq_getsize(v,2);\n    if(nargs>2){\n        sq_getstring(v,3,&name);\n    }\n    if(SQ_SUCCEEDED(sq_compilebuffer(v,src,size,name,SQFalse)))\n        return 1;\n    else\n        return SQ_ERROR;\n}\n\nstatic SQInteger base_newthread(HSQUIRRELVM v)\n{\n    SQObjectPtr &func = stack_get(v,2);\n    SQInteger stksize = (_closure(func)->_function->_stacksize << 1) +2;\n    HSQUIRRELVM newv = sq_newthread(v, (stksize < MIN_STACK_OVERHEAD + 2)? MIN_STACK_OVERHEAD + 2 : stksize);\n    sq_move(newv,v,-2);\n    return 1;\n}\n\nstatic SQInteger base_suspend(HSQUIRRELVM v)\n{\n    return sq_suspendvm(v);\n}\n\nstatic SQInteger base_array(HSQUIRRELVM v)\n{\n    SQArray *a;\n    SQObject &size = stack_get(v,2);\n    if(sq_gettop(v) > 2) {\n        a = SQArray::Create(_ss(v),0);\n        a->Resize(tointeger(size),stack_get(v,3));\n    }\n    else {\n        a = SQArray::Create(_ss(v),tointeger(size));\n    }\n    v->Push(a);\n    return 1;\n}\n\nstatic SQInteger base_type(HSQUIRRELVM v)\n{\n    SQObjectPtr &o = stack_get(v,2);\n    v->Push(SQString::Create(_ss(v),GetTypeName(o),-1));\n    return 1;\n}\n\nstatic SQInteger base_callee(HSQUIRRELVM v)\n{\n    if(v->_callsstacksize > 1)\n    {\n        v->Push(v->_callsstack[v->_callsstacksize - 2]._closure);\n        return 1;\n    }\n    return sq_throwerror(v,_SC(\"no closure in the calls stack\"));\n}\n\nstatic const SQRegFunction base_funcs[]={\n    //generic\n    {_SC(\"seterrorhandler\"),base_seterrorhandler,2, NULL},\n    {_SC(\"setdebughook\"),base_setdebughook,2, NULL},\n    {_SC(\"enabledebuginfo\"),base_enabledebuginfo,2, NULL},\n    {_SC(\"getstackinfos\"),base_getstackinfos,2, _SC(\".n\")},\n    {_SC(\"getroottable\"),base_getroottable,1, NULL},\n    {_SC(\"setroottable\"),base_setroottable,2, NULL},\n    {_SC(\"getconsttable\"),base_getconsttable,1, NULL},\n    {_SC(\"setconsttable\"),base_setconsttable,2, NULL},\n    {_SC(\"assert\"),base_assert,-2, NULL},\n    {_SC(\"print\"),base_print,2, NULL},\n    {_SC(\"error\"),base_error,2, NULL},\n    {_SC(\"compilestring\"),base_compilestring,-2, _SC(\".ss\")},\n    {_SC(\"newthread\"),base_newthread,2, _SC(\".c\")},\n    {_SC(\"suspend\"),base_suspend,-1, NULL},\n    {_SC(\"array\"),base_array,-2, _SC(\".n\")},\n    {_SC(\"type\"),base_type,2, NULL},\n    {_SC(\"callee\"),base_callee,0,NULL},\n    {_SC(\"dummy\"),base_dummy,0,NULL},\n#ifndef NO_GARBAGE_COLLECTOR\n    {_SC(\"collectgarbage\"),base_collectgarbage,0, NULL},\n    {_SC(\"resurrectunreachable\"),base_resurectureachable,0, NULL},\n#endif\n    {NULL,(SQFUNCTION)0,0,NULL}\n};\n\nvoid sq_base_register(HSQUIRRELVM v)\n{\n    SQInteger i=0;\n    sq_pushroottable(v);\n    while(base_funcs[i].name!=0) {\n        sq_pushstring(v,base_funcs[i].name,-1);\n        sq_newclosure(v,base_funcs[i].f,0);\n        sq_setnativeclosurename(v,-1,base_funcs[i].name);\n        sq_setparamscheck(v,base_funcs[i].nparamscheck,base_funcs[i].typemask);\n        sq_newslot(v,-3, SQFalse);\n        i++;\n    }\n\n    sq_pushstring(v,_SC(\"_versionnumber_\"),-1);\n    sq_pushinteger(v,SQUIRREL_VERSION_NUMBER);\n    sq_newslot(v,-3, SQFalse);\n    sq_pushstring(v,_SC(\"_version_\"),-1);\n    sq_pushstring(v,SQUIRREL_VERSION,-1);\n    sq_newslot(v,-3, SQFalse);\n    sq_pushstring(v,_SC(\"_charsize_\"),-1);\n    sq_pushinteger(v,sizeof(SQChar));\n    sq_newslot(v,-3, SQFalse);\n    sq_pushstring(v,_SC(\"_intsize_\"),-1);\n    sq_pushinteger(v,sizeof(SQInteger));\n    sq_newslot(v,-3, SQFalse);\n    sq_pushstring(v,_SC(\"_floatsize_\"),-1);\n    sq_pushinteger(v,sizeof(SQFloat));\n    sq_newslot(v,-3, SQFalse);\n    sq_pop(v,1);\n}\n\nstatic SQInteger default_delegate_len(HSQUIRRELVM v)\n{\n    v->Push(SQInteger(sq_getsize(v,1)));\n    return 1;\n}\n\nstatic SQInteger default_delegate_tofloat(HSQUIRRELVM v)\n{\n    SQObjectPtr &o=stack_get(v,1);\n    switch(sq_type(o)){\n    case OT_STRING:{\n        SQObjectPtr res;\n        if(str2num(_stringval(o),res,10)){\n            v->Push(SQObjectPtr(tofloat(res)));\n            break;\n        }}\n        return sq_throwerror(v, _SC(\"cannot convert the string\"));\n        break;\n    case OT_INTEGER:case OT_FLOAT:\n        v->Push(SQObjectPtr(tofloat(o)));\n        break;\n    case OT_BOOL:\n        v->Push(SQObjectPtr((SQFloat)(_integer(o)?1:0)));\n        break;\n    default:\n        v->PushNull();\n        break;\n    }\n    return 1;\n}\n\nstatic SQInteger default_delegate_tointeger(HSQUIRRELVM v)\n{\n    SQObjectPtr &o=stack_get(v,1);\n    SQInteger base = 10;\n    if(sq_gettop(v) > 1) {\n        sq_getinteger(v,2,&base);\n    }\n    switch(sq_type(o)){\n    case OT_STRING:{\n        SQObjectPtr res;\n        if(str2num(_stringval(o),res,base)){\n            v->Push(SQObjectPtr(tointeger(res)));\n            break;\n        }}\n        return sq_throwerror(v, _SC(\"cannot convert the string\"));\n        break;\n    case OT_INTEGER:case OT_FLOAT:\n        v->Push(SQObjectPtr(tointeger(o)));\n        break;\n    case OT_BOOL:\n        v->Push(SQObjectPtr(_integer(o)?(SQInteger)1:(SQInteger)0));\n        break;\n    default:\n        v->PushNull();\n        break;\n    }\n    return 1;\n}\n\nstatic SQInteger default_delegate_tostring(HSQUIRRELVM v)\n{\n    if(SQ_FAILED(sq_tostring(v,1)))\n        return SQ_ERROR;\n    return 1;\n}\n\nstatic SQInteger obj_delegate_weakref(HSQUIRRELVM v)\n{\n    sq_weakref(v,1);\n    return 1;\n}\n\nstatic SQInteger obj_clear(HSQUIRRELVM v)\n{\n    return SQ_SUCCEEDED(sq_clear(v,-1)) ? 1 : SQ_ERROR;\n}\n\n\nstatic SQInteger number_delegate_tochar(HSQUIRRELVM v)\n{\n    SQObject &o=stack_get(v,1);\n    SQChar c = (SQChar)tointeger(o);\n    v->Push(SQString::Create(_ss(v),(const SQChar *)&c,1));\n    return 1;\n}\n\n\n\n/////////////////////////////////////////////////////////////////\n//TABLE DEFAULT DELEGATE\n\nstatic SQInteger table_rawdelete(HSQUIRRELVM v)\n{\n    if(SQ_FAILED(sq_rawdeleteslot(v,1,SQTrue)))\n        return SQ_ERROR;\n    return 1;\n}\n\n\nstatic SQInteger container_rawexists(HSQUIRRELVM v)\n{\n    if(SQ_SUCCEEDED(sq_rawget(v,-2))) {\n        sq_pushbool(v,SQTrue);\n        return 1;\n    }\n    sq_pushbool(v,SQFalse);\n    return 1;\n}\n\nstatic SQInteger container_rawset(HSQUIRRELVM v)\n{\n    return SQ_SUCCEEDED(sq_rawset(v,-3)) ? 1 : SQ_ERROR;\n}\n\n\nstatic SQInteger container_rawget(HSQUIRRELVM v)\n{\n    return SQ_SUCCEEDED(sq_rawget(v,-2))?1:SQ_ERROR;\n}\n\nstatic SQInteger table_setdelegate(HSQUIRRELVM v)\n{\n    if(SQ_FAILED(sq_setdelegate(v,-2)))\n        return SQ_ERROR;\n    sq_push(v,-1); // -1 because sq_setdelegate pops 1\n    return 1;\n}\n\nstatic SQInteger table_getdelegate(HSQUIRRELVM v)\n{\n    return SQ_SUCCEEDED(sq_getdelegate(v,-1))?1:SQ_ERROR;\n}\n\nstatic SQInteger table_filter(HSQUIRRELVM v)\n{\n    SQObject &o = stack_get(v,1);\n    SQTable *tbl = _table(o);\n    SQObjectPtr ret = SQTable::Create(_ss(v),0);\n\n    SQObjectPtr itr, key, val;\n    SQInteger nitr;\n    while((nitr = tbl->Next(false, itr, key, val)) != -1) {\n        itr = (SQInteger)nitr;\n\n        v->Push(o);\n        v->Push(key);\n        v->Push(val);\n        if(SQ_FAILED(sq_call(v,3,SQTrue,SQFalse))) {\n            return SQ_ERROR;\n        }\n        if(!SQVM::IsFalse(v->GetUp(-1))) {\n            _table(ret)->NewSlot(key, val);\n        }\n        v->Pop();\n    }\n\n    v->Push(ret);\n    return 1;\n}\n\nstatic SQInteger table_map(HSQUIRRELVM v)\n{\n\tSQObject &o = stack_get(v, 1);\n\tSQTable *tbl = _table(o);\n\tSQInteger nitr, n = 0;\n\tSQInteger nitems = tbl->CountUsed();\n\tSQObjectPtr ret = SQArray::Create(_ss(v), nitems);\n\tSQObjectPtr itr, key, val;\n\twhile ((nitr = tbl->Next(false, itr, key, val)) != -1) {\n\t\titr = (SQInteger)nitr;\n\n\t\tv->Push(o);\n\t\tv->Push(key);\n\t\tv->Push(val);\n\t\tif (SQ_FAILED(sq_call(v, 3, SQTrue, SQFalse))) {\n\t\t\treturn SQ_ERROR;\n\t\t}\n\t\t_array(ret)->Set(n, v->GetUp(-1));\n\t\tv->Pop();\n\t\tn++;\n\t}\n\n\tv->Push(ret);\n\treturn 1;\n}\n\n#define TABLE_TO_ARRAY_FUNC(_funcname_,_valname_) static SQInteger _funcname_(HSQUIRRELVM v) \\\n{ \\\n\tSQObject &o = stack_get(v, 1); \\\n\tSQTable *t = _table(o); \\\n\tSQObjectPtr itr, key, val; \\\n\tSQObjectPtr _null; \\\n\tSQInteger nitr, n = 0; \\\n\tSQInteger nitems = t->CountUsed(); \\\n\tSQArray *a = SQArray::Create(_ss(v), nitems); \\\n\ta->Resize(nitems, _null); \\\n\tif (nitems) { \\\n\t\twhile ((nitr = t->Next(false, itr, key, val)) != -1) { \\\n\t\t\titr = (SQInteger)nitr; \\\n\t\t\ta->Set(n, _valname_); \\\n\t\t\tn++; \\\n\t\t} \\\n\t} \\\n\tv->Push(a); \\\n\treturn 1; \\\n}\n\nTABLE_TO_ARRAY_FUNC(table_keys, key)\nTABLE_TO_ARRAY_FUNC(table_values, val)\n\n\nconst SQRegFunction SQSharedState::_table_default_delegate_funcz[]={\n    {_SC(\"len\"),default_delegate_len,1, _SC(\"t\")},\n    {_SC(\"rawget\"),container_rawget,2, _SC(\"t\")},\n    {_SC(\"rawset\"),container_rawset,3, _SC(\"t\")},\n    {_SC(\"rawdelete\"),table_rawdelete,2, _SC(\"t\")},\n    {_SC(\"rawin\"),container_rawexists,2, _SC(\"t\")},\n    {_SC(\"weakref\"),obj_delegate_weakref,1, NULL },\n    {_SC(\"tostring\"),default_delegate_tostring,1, _SC(\".\")},\n    {_SC(\"clear\"),obj_clear,1, _SC(\".\")},\n    {_SC(\"setdelegate\"),table_setdelegate,2, _SC(\".t|o\")},\n    {_SC(\"getdelegate\"),table_getdelegate,1, _SC(\".\")},\n    {_SC(\"filter\"),table_filter,2, _SC(\"tc\")},\n\t{_SC(\"map\"),table_map,2, _SC(\"tc\") },\n\t{_SC(\"keys\"),table_keys,1, _SC(\"t\") },\n\t{_SC(\"values\"),table_values,1, _SC(\"t\") },\n    {NULL,(SQFUNCTION)0,0,NULL}\n};\n\n//ARRAY DEFAULT DELEGATE///////////////////////////////////////\n\nstatic SQInteger array_append(HSQUIRRELVM v)\n{\n    return SQ_SUCCEEDED(sq_arrayappend(v,-2)) ? 1 : SQ_ERROR;\n}\n\nstatic SQInteger array_extend(HSQUIRRELVM v)\n{\n    _array(stack_get(v,1))->Extend(_array(stack_get(v,2)));\n    sq_pop(v,1);\n    return 1;\n}\n\nstatic SQInteger array_reverse(HSQUIRRELVM v)\n{\n    return SQ_SUCCEEDED(sq_arrayreverse(v,-1)) ? 1 : SQ_ERROR;\n}\n\nstatic SQInteger array_pop(HSQUIRRELVM v)\n{\n    return SQ_SUCCEEDED(sq_arraypop(v,1,SQTrue))?1:SQ_ERROR;\n}\n\nstatic SQInteger array_top(HSQUIRRELVM v)\n{\n    SQObject &o=stack_get(v,1);\n    if(_array(o)->Size()>0){\n        v->Push(_array(o)->Top());\n        return 1;\n    }\n    else return sq_throwerror(v,_SC(\"top() on a empty array\"));\n}\n\nstatic SQInteger array_insert(HSQUIRRELVM v)\n{\n    SQObject &o=stack_get(v,1);\n    SQObject &idx=stack_get(v,2);\n    SQObject &val=stack_get(v,3);\n    if(!_array(o)->Insert(tointeger(idx),val))\n        return sq_throwerror(v,_SC(\"index out of range\"));\n    sq_pop(v,2);\n    return 1;\n}\n\nstatic SQInteger array_remove(HSQUIRRELVM v)\n{\n    SQObject &o = stack_get(v, 1);\n    SQObject &idx = stack_get(v, 2);\n    if(!sq_isnumeric(idx)) return sq_throwerror(v, _SC(\"wrong type\"));\n    SQObjectPtr val;\n    if(_array(o)->Get(tointeger(idx), val)) {\n        _array(o)->Remove(tointeger(idx));\n        v->Push(val);\n        return 1;\n    }\n    return sq_throwerror(v, _SC(\"idx out of range\"));\n}\n\nstatic SQInteger array_resize(HSQUIRRELVM v)\n{\n    SQObject &o = stack_get(v, 1);\n    SQObject &nsize = stack_get(v, 2);\n    SQObjectPtr fill;\n    if(sq_isnumeric(nsize)) {\n        SQInteger sz = tointeger(nsize);\n        if (sz<0)\n          return sq_throwerror(v, _SC(\"resizing to negative length\"));\n\n        if(sq_gettop(v) > 2)\n            fill = stack_get(v, 3);\n        _array(o)->Resize(sz,fill);\n        sq_settop(v, 1);\n        return 1;\n    }\n    return sq_throwerror(v, _SC(\"size must be a number\"));\n}\n\nstatic SQInteger __map_array(SQArray *dest,SQArray *src,HSQUIRRELVM v) {\n    SQObjectPtr temp;\n    SQInteger size = src->Size();\n    SQObject &closure = stack_get(v, 2);\n    v->Push(closure);\n\n    SQInteger nArgs = 0;\n    if(sq_type(closure) == OT_CLOSURE) {\n        nArgs = _closure(closure)->_function->_nparameters;\n    }\n    else if (sq_type(closure) == OT_NATIVECLOSURE) {\n        SQInteger nParamsCheck = _nativeclosure(closure)->_nparamscheck;\n        if (nParamsCheck > 0)\n            nArgs = nParamsCheck;\n        else // push all params when there is no check or only minimal count set\n            nArgs = 4;\n    }\n\n    for(SQInteger n = 0; n < size; n++) {\n        src->Get(n,temp);\n        v->Push(src);\n        v->Push(temp);\n        if (nArgs >= 3)\n            v->Push(SQObjectPtr(n));\n        if (nArgs >= 4)\n            v->Push(src);\n        if(SQ_FAILED(sq_call(v,nArgs,SQTrue,SQFalse))) {\n            return SQ_ERROR;\n        }\n        dest->Set(n,v->GetUp(-1));\n        v->Pop();\n    }\n    v->Pop();\n    return 0;\n}\n\nstatic SQInteger array_map(HSQUIRRELVM v)\n{\n    SQObject &o = stack_get(v,1);\n    SQInteger size = _array(o)->Size();\n    SQObjectPtr ret = SQArray::Create(_ss(v),size);\n    if(SQ_FAILED(__map_array(_array(ret),_array(o),v)))\n        return SQ_ERROR;\n    v->Push(ret);\n    return 1;\n}\n\nstatic SQInteger array_apply(HSQUIRRELVM v)\n{\n    SQObject &o = stack_get(v,1);\n    if(SQ_FAILED(__map_array(_array(o),_array(o),v)))\n        return SQ_ERROR;\n    sq_pop(v,1);\n    return 1;\n}\n\nstatic SQInteger array_reduce(HSQUIRRELVM v)\n{\n    SQObject &o = stack_get(v,1);\n    SQArray *a = _array(o);\n    SQInteger size = a->Size();\n    SQObjectPtr res;\n    SQInteger iterStart;\n    if (sq_gettop(v)>2) {\n        res = stack_get(v,3);\n        iterStart = 0;\n    } else if (size==0) {\n        return 0;\n    } else {\n        a->Get(0,res);\n        iterStart = 1;\n    }\n    if (size > iterStart) {\n        SQObjectPtr other;\n        v->Push(stack_get(v,2));\n        for (SQInteger n = iterStart; n < size; n++) {\n            a->Get(n,other);\n            v->Push(o);\n            v->Push(res);\n            v->Push(other);\n            if(SQ_FAILED(sq_call(v,3,SQTrue,SQFalse))) {\n                return SQ_ERROR;\n            }\n            res = v->GetUp(-1);\n            v->Pop();\n        }\n        v->Pop();\n    }\n    v->Push(res);\n    return 1;\n}\n\nstatic SQInteger array_filter(HSQUIRRELVM v)\n{\n    SQObject &o = stack_get(v,1);\n    SQArray *a = _array(o);\n    SQObjectPtr ret = SQArray::Create(_ss(v),0);\n    SQInteger size = a->Size();\n    SQObjectPtr val;\n    for(SQInteger n = 0; n < size; n++) {\n        a->Get(n,val);\n        v->Push(o);\n        v->Push(n);\n        v->Push(val);\n        if(SQ_FAILED(sq_call(v,3,SQTrue,SQFalse))) {\n            return SQ_ERROR;\n        }\n        if(!SQVM::IsFalse(v->GetUp(-1))) {\n            _array(ret)->Append(val);\n        }\n        v->Pop();\n    }\n    v->Push(ret);\n    return 1;\n}\n\nstatic SQInteger array_find(HSQUIRRELVM v)\n{\n    SQObject &o = stack_get(v,1);\n    SQObjectPtr &val = stack_get(v,2);\n    SQArray *a = _array(o);\n    SQInteger size = a->Size();\n    SQObjectPtr temp;\n    for(SQInteger n = 0; n < size; n++) {\n        bool res = false;\n        a->Get(n,temp);\n        if(SQVM::IsEqual(temp,val,res) && res) {\n            v->Push(n);\n            return 1;\n        }\n    }\n    return 0;\n}\n\n\nstatic bool _sort_compare(HSQUIRRELVM v, SQArray *arr, SQObjectPtr &a,SQObjectPtr &b,SQInteger func,SQInteger &ret)\n{\n    if(func < 0) {\n        if(!v->ObjCmp(a,b,ret)) return false;\n    }\n    else {\n        SQInteger top = sq_gettop(v);\n        sq_push(v, func);\n        sq_pushroottable(v);\n        v->Push(a);\n        v->Push(b);\n\t\tSQObjectPtr *valptr = arr->_values._vals;\n\t\tSQUnsignedInteger precallsize = arr->_values.size();\n        if(SQ_FAILED(sq_call(v, 3, SQTrue, SQFalse))) {\n            if(!sq_isstring( v->_lasterror))\n                v->Raise_Error(_SC(\"compare func failed\"));\n            return false;\n        }\n\t\tif(SQ_FAILED(sq_getinteger(v, -1, &ret))) {\n            v->Raise_Error(_SC(\"numeric value expected as return value of the compare function\"));\n            return false;\n        }\n\t\tif (precallsize != arr->_values.size() || valptr != arr->_values._vals) {\n\t\t\tv->Raise_Error(_SC(\"array resized during sort operation\"));\n\t\t\treturn false;\n\t\t}\n        sq_settop(v, top);\n        return true;\n    }\n    return true;\n}\n\nstatic bool _hsort_sift_down(HSQUIRRELVM v,SQArray *arr, SQInteger root, SQInteger bottom, SQInteger func)\n{\n    SQInteger maxChild;\n    SQInteger done = 0;\n    SQInteger ret;\n    SQInteger root2;\n    while (((root2 = root * 2) <= bottom) && (!done))\n    {\n        if (root2 == bottom) {\n            maxChild = root2;\n        }\n        else {\n            if(!_sort_compare(v,arr,arr->_values[root2],arr->_values[root2 + 1],func,ret))\n                return false;\n            if (ret > 0) {\n                maxChild = root2;\n            }\n            else {\n                maxChild = root2 + 1;\n            }\n        }\n\n        if(!_sort_compare(v,arr,arr->_values[root],arr->_values[maxChild],func,ret))\n            return false;\n        if (ret < 0) {\n            if (root == maxChild) {\n                v->Raise_Error(_SC(\"inconsistent compare function\"));\n                return false; // We'd be swapping ourselve. The compare function is incorrect\n            }\n\n            _Swap(arr->_values[root],arr->_values[maxChild]);\n            root = maxChild;\n        }\n        else {\n            done = 1;\n        }\n    }\n    return true;\n}\n\nstatic bool _hsort(HSQUIRRELVM v,SQObjectPtr &arr, SQInteger SQ_UNUSED_ARG(l), SQInteger SQ_UNUSED_ARG(r),SQInteger func)\n{\n    SQArray *a = _array(arr);\n    SQInteger i;\n    SQInteger array_size = a->Size();\n    for (i = (array_size / 2); i >= 0; i--) {\n        if(!_hsort_sift_down(v,a, i, array_size - 1,func)) return false;\n    }\n\n    for (i = array_size-1; i >= 1; i--)\n    {\n        _Swap(a->_values[0],a->_values[i]);\n        if(!_hsort_sift_down(v,a, 0, i-1,func)) return false;\n    }\n    return true;\n}\n\nstatic SQInteger array_sort(HSQUIRRELVM v)\n{\n    SQInteger func = -1;\n    SQObjectPtr &o = stack_get(v,1);\n    if(_array(o)->Size() > 1) {\n        if(sq_gettop(v) == 2) func = 2;\n        if(!_hsort(v, o, 0, _array(o)->Size()-1, func))\n            return SQ_ERROR;\n\n    }\n    sq_settop(v,1);\n    return 1;\n}\n\nstatic SQInteger array_slice(HSQUIRRELVM v)\n{\n    SQInteger sidx,eidx;\n    SQObjectPtr o;\n    if(get_slice_params(v,sidx,eidx,o)==-1)return -1;\n    SQInteger alen = _array(o)->Size();\n    if(sidx < 0)sidx = alen + sidx;\n    if(eidx < 0)eidx = alen + eidx;\n    if(eidx < sidx)return sq_throwerror(v,_SC(\"wrong indexes\"));\n    if(eidx > alen || sidx < 0)return sq_throwerror(v, _SC(\"slice out of range\"));\n    SQArray *arr=SQArray::Create(_ss(v),eidx-sidx);\n    SQObjectPtr t;\n    SQInteger count=0;\n    for(SQInteger i=sidx;i<eidx;i++){\n        _array(o)->Get(i,t);\n        arr->Set(count++,t);\n    }\n    v->Push(arr);\n    return 1;\n\n}\n\nconst SQRegFunction SQSharedState::_array_default_delegate_funcz[]={\n    {_SC(\"len\"),default_delegate_len,1, _SC(\"a\")},\n    {_SC(\"append\"),array_append,2, _SC(\"a\")},\n    {_SC(\"extend\"),array_extend,2, _SC(\"aa\")},\n    {_SC(\"push\"),array_append,2, _SC(\"a\")},\n    {_SC(\"pop\"),array_pop,1, _SC(\"a\")},\n    {_SC(\"top\"),array_top,1, _SC(\"a\")},\n    {_SC(\"insert\"),array_insert,3, _SC(\"an\")},\n    {_SC(\"remove\"),array_remove,2, _SC(\"an\")},\n    {_SC(\"resize\"),array_resize,-2, _SC(\"an\")},\n    {_SC(\"reverse\"),array_reverse,1, _SC(\"a\")},\n    {_SC(\"sort\"),array_sort,-1, _SC(\"ac\")},\n    {_SC(\"slice\"),array_slice,-1, _SC(\"ann\")},\n    {_SC(\"weakref\"),obj_delegate_weakref,1, NULL },\n    {_SC(\"tostring\"),default_delegate_tostring,1, _SC(\".\")},\n    {_SC(\"clear\"),obj_clear,1, _SC(\".\")},\n    {_SC(\"map\"),array_map,2, _SC(\"ac\")},\n    {_SC(\"apply\"),array_apply,2, _SC(\"ac\")},\n    {_SC(\"reduce\"),array_reduce,-2, _SC(\"ac.\")},\n    {_SC(\"filter\"),array_filter,2, _SC(\"ac\")},\n    {_SC(\"find\"),array_find,2, _SC(\"a.\")},\n    {NULL,(SQFUNCTION)0,0,NULL}\n};\n\n//STRING DEFAULT DELEGATE//////////////////////////\nstatic SQInteger string_slice(HSQUIRRELVM v)\n{\n    SQInteger sidx,eidx;\n    SQObjectPtr o;\n    if(SQ_FAILED(get_slice_params(v,sidx,eidx,o)))return -1;\n    SQInteger slen = _string(o)->_len;\n    if(sidx < 0)sidx = slen + sidx;\n    if(eidx < 0)eidx = slen + eidx;\n    if(eidx < sidx) return sq_throwerror(v,_SC(\"wrong indexes\"));\n    if(eidx > slen || sidx < 0) return sq_throwerror(v, _SC(\"slice out of range\"));\n    v->Push(SQString::Create(_ss(v),&_stringval(o)[sidx],eidx-sidx));\n    return 1;\n}\n\nstatic SQInteger string_find(HSQUIRRELVM v)\n{\n    SQInteger top,start_idx=0;\n    const SQChar *str,*substr,*ret;\n    if(((top=sq_gettop(v))>1) && SQ_SUCCEEDED(sq_getstring(v,1,&str)) && SQ_SUCCEEDED(sq_getstring(v,2,&substr))){\n        if(top>2)sq_getinteger(v,3,&start_idx);\n        if((sq_getsize(v,1)>start_idx) && (start_idx>=0)){\n            ret=scstrstr(&str[start_idx],substr);\n            if(ret){\n                sq_pushinteger(v,(SQInteger)(ret-str));\n                return 1;\n            }\n        }\n        return 0;\n    }\n    return sq_throwerror(v,_SC(\"invalid param\"));\n}\n\n#define STRING_TOFUNCZ(func) static SQInteger string_##func(HSQUIRRELVM v) \\\n{\\\n    SQInteger sidx,eidx; \\\n    SQObjectPtr str; \\\n    if(SQ_FAILED(get_slice_params(v,sidx,eidx,str)))return -1; \\\n    SQInteger slen = _string(str)->_len; \\\n    if(sidx < 0)sidx = slen + sidx; \\\n    if(eidx < 0)eidx = slen + eidx; \\\n    if(eidx < sidx) return sq_throwerror(v,_SC(\"wrong indexes\")); \\\n    if(eidx > slen || sidx < 0) return sq_throwerror(v,_SC(\"slice out of range\")); \\\n    SQInteger len=_string(str)->_len; \\\n    const SQChar *sthis=_stringval(str); \\\n    SQChar *snew=(_ss(v)->GetScratchPad(sq_rsl(len))); \\\n    memcpy(snew,sthis,sq_rsl(len));\\\n    for(SQInteger i=sidx;i<eidx;i++) snew[i] = func(sthis[i]); \\\n    v->Push(SQString::Create(_ss(v),snew,len)); \\\n    return 1; \\\n}\n\n\nSTRING_TOFUNCZ(tolower)\nSTRING_TOFUNCZ(toupper)\n\nconst SQRegFunction SQSharedState::_string_default_delegate_funcz[]={\n    {_SC(\"len\"),default_delegate_len,1, _SC(\"s\")},\n    {_SC(\"tointeger\"),default_delegate_tointeger,-1, _SC(\"sn\")},\n    {_SC(\"tofloat\"),default_delegate_tofloat,1, _SC(\"s\")},\n    {_SC(\"tostring\"),default_delegate_tostring,1, _SC(\".\")},\n    {_SC(\"slice\"),string_slice,-1, _SC(\"s n  n\")},\n    {_SC(\"find\"),string_find,-2, _SC(\"s s n\")},\n    {_SC(\"tolower\"),string_tolower,-1, _SC(\"s n n\")},\n    {_SC(\"toupper\"),string_toupper,-1, _SC(\"s n n\")},\n    {_SC(\"weakref\"),obj_delegate_weakref,1, NULL },\n    {NULL,(SQFUNCTION)0,0,NULL}\n};\n\n//INTEGER DEFAULT DELEGATE//////////////////////////\nconst SQRegFunction SQSharedState::_number_default_delegate_funcz[]={\n    {_SC(\"tointeger\"),default_delegate_tointeger,1, _SC(\"n|b\")},\n    {_SC(\"tofloat\"),default_delegate_tofloat,1, _SC(\"n|b\")},\n    {_SC(\"tostring\"),default_delegate_tostring,1, _SC(\".\")},\n    {_SC(\"tochar\"),number_delegate_tochar,1, _SC(\"n|b\")},\n    {_SC(\"weakref\"),obj_delegate_weakref,1, NULL },\n    {NULL,(SQFUNCTION)0,0,NULL}\n};\n\n//CLOSURE DEFAULT DELEGATE//////////////////////////\nstatic SQInteger closure_pcall(HSQUIRRELVM v)\n{\n    return SQ_SUCCEEDED(sq_call(v,sq_gettop(v)-1,SQTrue,SQFalse))?1:SQ_ERROR;\n}\n\nstatic SQInteger closure_call(HSQUIRRELVM v)\n{\n\tSQObjectPtr &c = stack_get(v, -1);\n\tif (sq_type(c) == OT_CLOSURE && (_closure(c)->_function->_bgenerator == false))\n\t{\n\t\treturn sq_tailcall(v, sq_gettop(v) - 1);\n\t}\n\treturn SQ_SUCCEEDED(sq_call(v, sq_gettop(v) - 1, SQTrue, SQTrue)) ? 1 : SQ_ERROR;\n}\n\nstatic SQInteger _closure_acall(HSQUIRRELVM v,SQBool raiseerror)\n{\n    SQArray *aparams=_array(stack_get(v,2));\n    SQInteger nparams=aparams->Size();\n    v->Push(stack_get(v,1));\n    for(SQInteger i=0;i<nparams;i++)v->Push(aparams->_values[i]);\n    return SQ_SUCCEEDED(sq_call(v,nparams,SQTrue,raiseerror))?1:SQ_ERROR;\n}\n\nstatic SQInteger closure_acall(HSQUIRRELVM v)\n{\n    return _closure_acall(v,SQTrue);\n}\n\nstatic SQInteger closure_pacall(HSQUIRRELVM v)\n{\n    return _closure_acall(v,SQFalse);\n}\n\nstatic SQInteger closure_bindenv(HSQUIRRELVM v)\n{\n    if(SQ_FAILED(sq_bindenv(v,1)))\n        return SQ_ERROR;\n    return 1;\n}\n\nstatic SQInteger closure_getroot(HSQUIRRELVM v)\n{\n    if(SQ_FAILED(sq_getclosureroot(v,-1)))\n        return SQ_ERROR;\n    return 1;\n}\n\nstatic SQInteger closure_setroot(HSQUIRRELVM v)\n{\n    if(SQ_FAILED(sq_setclosureroot(v,-2)))\n        return SQ_ERROR;\n    return 1;\n}\n\nstatic SQInteger closure_getinfos(HSQUIRRELVM v) {\n    SQObject o = stack_get(v,1);\n    SQTable *res = SQTable::Create(_ss(v),4);\n    if(sq_type(o) == OT_CLOSURE) {\n        SQFunctionProto *f = _closure(o)->_function;\n        SQInteger nparams = f->_nparameters + (f->_varparams?1:0);\n        SQObjectPtr params = SQArray::Create(_ss(v),nparams);\n    SQObjectPtr defparams = SQArray::Create(_ss(v),f->_ndefaultparams);\n        for(SQInteger n = 0; n<f->_nparameters; n++) {\n            _array(params)->Set((SQInteger)n,f->_parameters[n]);\n        }\n    for(SQInteger j = 0; j<f->_ndefaultparams; j++) {\n            _array(defparams)->Set((SQInteger)j,_closure(o)->_defaultparams[j]);\n        }\n        if(f->_varparams) {\n            _array(params)->Set(nparams-1,SQString::Create(_ss(v),_SC(\"...\"),-1));\n        }\n        res->NewSlot(SQString::Create(_ss(v),_SC(\"native\"),-1),false);\n        res->NewSlot(SQString::Create(_ss(v),_SC(\"name\"),-1),f->_name);\n        res->NewSlot(SQString::Create(_ss(v),_SC(\"src\"),-1),f->_sourcename);\n        res->NewSlot(SQString::Create(_ss(v),_SC(\"parameters\"),-1),params);\n        res->NewSlot(SQString::Create(_ss(v),_SC(\"varargs\"),-1),f->_varparams);\n    res->NewSlot(SQString::Create(_ss(v),_SC(\"defparams\"),-1),defparams);\n    }\n    else { //OT_NATIVECLOSURE\n        SQNativeClosure *nc = _nativeclosure(o);\n        res->NewSlot(SQString::Create(_ss(v),_SC(\"native\"),-1),true);\n        res->NewSlot(SQString::Create(_ss(v),_SC(\"name\"),-1),nc->_name);\n        res->NewSlot(SQString::Create(_ss(v),_SC(\"paramscheck\"),-1),nc->_nparamscheck);\n        SQObjectPtr typecheck;\n        if(nc->_typecheck.size() > 0) {\n            typecheck =\n                SQArray::Create(_ss(v), nc->_typecheck.size());\n            for(SQUnsignedInteger n = 0; n<nc->_typecheck.size(); n++) {\n                    _array(typecheck)->Set((SQInteger)n,nc->_typecheck[n]);\n            }\n        }\n        res->NewSlot(SQString::Create(_ss(v),_SC(\"typecheck\"),-1),typecheck);\n    }\n    v->Push(res);\n    return 1;\n}\n\n\n\nconst SQRegFunction SQSharedState::_closure_default_delegate_funcz[]={\n    {_SC(\"call\"),closure_call,-1, _SC(\"c\")},\n    {_SC(\"pcall\"),closure_pcall,-1, _SC(\"c\")},\n    {_SC(\"acall\"),closure_acall,2, _SC(\"ca\")},\n    {_SC(\"pacall\"),closure_pacall,2, _SC(\"ca\")},\n    {_SC(\"weakref\"),obj_delegate_weakref,1, NULL },\n    {_SC(\"tostring\"),default_delegate_tostring,1, _SC(\".\")},\n    {_SC(\"bindenv\"),closure_bindenv,2, _SC(\"c x|y|t\")},\n    {_SC(\"getinfos\"),closure_getinfos,1, _SC(\"c\")},\n    {_SC(\"getroot\"),closure_getroot,1, _SC(\"c\")},\n    {_SC(\"setroot\"),closure_setroot,2, _SC(\"ct\")},\n    {NULL,(SQFUNCTION)0,0,NULL}\n};\n\n//GENERATOR DEFAULT DELEGATE\nstatic SQInteger generator_getstatus(HSQUIRRELVM v)\n{\n    SQObject &o=stack_get(v,1);\n    switch(_generator(o)->_state){\n        case SQGenerator::eSuspended:v->Push(SQString::Create(_ss(v),_SC(\"suspended\")));break;\n        case SQGenerator::eRunning:v->Push(SQString::Create(_ss(v),_SC(\"running\")));break;\n        case SQGenerator::eDead:v->Push(SQString::Create(_ss(v),_SC(\"dead\")));break;\n    }\n    return 1;\n}\n\nconst SQRegFunction SQSharedState::_generator_default_delegate_funcz[]={\n    {_SC(\"getstatus\"),generator_getstatus,1, _SC(\"g\")},\n    {_SC(\"weakref\"),obj_delegate_weakref,1, NULL },\n    {_SC(\"tostring\"),default_delegate_tostring,1, _SC(\".\")},\n    {NULL,(SQFUNCTION)0,0,NULL}\n};\n\n//THREAD DEFAULT DELEGATE\nstatic SQInteger thread_call(HSQUIRRELVM v)\n{\n    SQObjectPtr o = stack_get(v,1);\n    if(sq_type(o) == OT_THREAD) {\n        SQInteger nparams = sq_gettop(v);\n        _thread(o)->Push(_thread(o)->_roottable);\n        for(SQInteger i = 2; i<(nparams+1); i++)\n            sq_move(_thread(o),v,i);\n        if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) {\n            sq_move(v,_thread(o),-1);\n            sq_pop(_thread(o),1);\n            return 1;\n        }\n        v->_lasterror = _thread(o)->_lasterror;\n        return SQ_ERROR;\n    }\n    return sq_throwerror(v,_SC(\"wrong parameter\"));\n}\n\nstatic SQInteger thread_wakeup(HSQUIRRELVM v)\n{\n    SQObjectPtr o = stack_get(v,1);\n    if(sq_type(o) == OT_THREAD) {\n        SQVM *thread = _thread(o);\n        SQInteger state = sq_getvmstate(thread);\n        if(state != SQ_VMSTATE_SUSPENDED) {\n            switch(state) {\n                case SQ_VMSTATE_IDLE:\n                    return sq_throwerror(v,_SC(\"cannot wakeup a idle thread\"));\n                break;\n                case SQ_VMSTATE_RUNNING:\n                    return sq_throwerror(v,_SC(\"cannot wakeup a running thread\"));\n                break;\n            }\n        }\n\n        SQInteger wakeupret = sq_gettop(v)>1?SQTrue:SQFalse;\n        if(wakeupret) {\n            sq_move(thread,v,2);\n        }\n        if(SQ_SUCCEEDED(sq_wakeupvm(thread,wakeupret,SQTrue,SQTrue,SQFalse))) {\n            sq_move(v,thread,-1);\n            sq_pop(thread,1); //pop retval\n            if(sq_getvmstate(thread) == SQ_VMSTATE_IDLE) {\n                sq_settop(thread,1); //pop roottable\n            }\n            return 1;\n        }\n        sq_settop(thread,1);\n        v->_lasterror = thread->_lasterror;\n        return SQ_ERROR;\n    }\n    return sq_throwerror(v,_SC(\"wrong parameter\"));\n}\n\nstatic SQInteger thread_wakeupthrow(HSQUIRRELVM v)\n{\n    SQObjectPtr o = stack_get(v,1);\n    if(sq_type(o) == OT_THREAD) {\n        SQVM *thread = _thread(o);\n        SQInteger state = sq_getvmstate(thread);\n        if(state != SQ_VMSTATE_SUSPENDED) {\n            switch(state) {\n                case SQ_VMSTATE_IDLE:\n                    return sq_throwerror(v,_SC(\"cannot wakeup a idle thread\"));\n                break;\n                case SQ_VMSTATE_RUNNING:\n                    return sq_throwerror(v,_SC(\"cannot wakeup a running thread\"));\n                break;\n            }\n        }\n\n        sq_move(thread,v,2);\n        sq_throwobject(thread);\n        SQBool rethrow_error = SQTrue;\n        if(sq_gettop(v) > 2) {\n            sq_getbool(v,3,&rethrow_error);\n        }\n        if(SQ_SUCCEEDED(sq_wakeupvm(thread,SQFalse,SQTrue,SQTrue,SQTrue))) {\n            sq_move(v,thread,-1);\n            sq_pop(thread,1); //pop retval\n            if(sq_getvmstate(thread) == SQ_VMSTATE_IDLE) {\n                sq_settop(thread,1); //pop roottable\n            }\n            return 1;\n        }\n        sq_settop(thread,1);\n        if(rethrow_error) {\n            v->_lasterror = thread->_lasterror;\n            return SQ_ERROR;\n        }\n        return SQ_OK;\n    }\n    return sq_throwerror(v,_SC(\"wrong parameter\"));\n}\n\nstatic SQInteger thread_getstatus(HSQUIRRELVM v)\n{\n    SQObjectPtr &o = stack_get(v,1);\n    switch(sq_getvmstate(_thread(o))) {\n        case SQ_VMSTATE_IDLE:\n            sq_pushstring(v,_SC(\"idle\"),-1);\n        break;\n        case SQ_VMSTATE_RUNNING:\n            sq_pushstring(v,_SC(\"running\"),-1);\n        break;\n        case SQ_VMSTATE_SUSPENDED:\n            sq_pushstring(v,_SC(\"suspended\"),-1);\n        break;\n        default:\n            return sq_throwerror(v,_SC(\"internal VM error\"));\n    }\n    return 1;\n}\n\nstatic SQInteger thread_getstackinfos(HSQUIRRELVM v)\n{\n    SQObjectPtr o = stack_get(v,1);\n    if(sq_type(o) == OT_THREAD) {\n        SQVM *thread = _thread(o);\n        SQInteger threadtop = sq_gettop(thread);\n        SQInteger level;\n        sq_getinteger(v,-1,&level);\n        SQRESULT res = __getcallstackinfos(thread,level);\n        if(SQ_FAILED(res))\n        {\n            sq_settop(thread,threadtop);\n            if(sq_type(thread->_lasterror) == OT_STRING) {\n                sq_throwerror(v,_stringval(thread->_lasterror));\n            }\n            else {\n                sq_throwerror(v,_SC(\"unknown error\"));\n            }\n        }\n        if(res > 0) {\n            //some result\n            sq_move(v,thread,-1);\n            sq_settop(thread,threadtop);\n            return 1;\n        }\n        //no result\n        sq_settop(thread,threadtop);\n        return 0;\n\n    }\n    return sq_throwerror(v,_SC(\"wrong parameter\"));\n}\n\nconst SQRegFunction SQSharedState::_thread_default_delegate_funcz[] = {\n    {_SC(\"call\"), thread_call, -1, _SC(\"v\")},\n    {_SC(\"wakeup\"), thread_wakeup, -1, _SC(\"v\")},\n    {_SC(\"wakeupthrow\"), thread_wakeupthrow, -2, _SC(\"v.b\")},\n    {_SC(\"getstatus\"), thread_getstatus, 1, _SC(\"v\")},\n    {_SC(\"weakref\"),obj_delegate_weakref,1, NULL },\n    {_SC(\"getstackinfos\"),thread_getstackinfos,2, _SC(\"vn\")},\n    {_SC(\"tostring\"),default_delegate_tostring,1, _SC(\".\")},\n    {NULL,(SQFUNCTION)0,0,NULL}\n};\n\nstatic SQInteger class_getattributes(HSQUIRRELVM v)\n{\n    return SQ_SUCCEEDED(sq_getattributes(v,-2))?1:SQ_ERROR;\n}\n\nstatic SQInteger class_setattributes(HSQUIRRELVM v)\n{\n    return SQ_SUCCEEDED(sq_setattributes(v,-3))?1:SQ_ERROR;\n}\n\nstatic SQInteger class_instance(HSQUIRRELVM v)\n{\n    return SQ_SUCCEEDED(sq_createinstance(v,-1))?1:SQ_ERROR;\n}\n\nstatic SQInteger class_getbase(HSQUIRRELVM v)\n{\n    return SQ_SUCCEEDED(sq_getbase(v,-1))?1:SQ_ERROR;\n}\n\nstatic SQInteger class_newmember(HSQUIRRELVM v)\n{\n    SQInteger top = sq_gettop(v);\n    SQBool bstatic = SQFalse;\n    if(top == 5)\n    {\n        sq_tobool(v,-1,&bstatic);\n        sq_pop(v,1);\n    }\n\n    if(top < 4) {\n        sq_pushnull(v);\n    }\n    return SQ_SUCCEEDED(sq_newmember(v,-4,bstatic))?1:SQ_ERROR;\n}\n\nstatic SQInteger class_rawnewmember(HSQUIRRELVM v)\n{\n    SQInteger top = sq_gettop(v);\n    SQBool bstatic = SQFalse;\n    if(top == 5)\n    {\n        sq_tobool(v,-1,&bstatic);\n        sq_pop(v,1);\n    }\n\n    if(top < 4) {\n        sq_pushnull(v);\n    }\n    return SQ_SUCCEEDED(sq_rawnewmember(v,-4,bstatic))?1:SQ_ERROR;\n}\n\nconst SQRegFunction SQSharedState::_class_default_delegate_funcz[] = {\n    {_SC(\"getattributes\"), class_getattributes, 2, _SC(\"y.\")},\n    {_SC(\"setattributes\"), class_setattributes, 3, _SC(\"y..\")},\n    {_SC(\"rawget\"),container_rawget,2, _SC(\"y\")},\n    {_SC(\"rawset\"),container_rawset,3, _SC(\"y\")},\n    {_SC(\"rawin\"),container_rawexists,2, _SC(\"y\")},\n    {_SC(\"weakref\"),obj_delegate_weakref,1, NULL },\n    {_SC(\"tostring\"),default_delegate_tostring,1, _SC(\".\")},\n    {_SC(\"instance\"),class_instance,1, _SC(\"y\")},\n    {_SC(\"getbase\"),class_getbase,1, _SC(\"y\")},\n    {_SC(\"newmember\"),class_newmember,-3, _SC(\"y\")},\n    {_SC(\"rawnewmember\"),class_rawnewmember,-3, _SC(\"y\")},\n    {NULL,(SQFUNCTION)0,0,NULL}\n};\n\n\nstatic SQInteger instance_getclass(HSQUIRRELVM v)\n{\n    if(SQ_SUCCEEDED(sq_getclass(v,1)))\n        return 1;\n    return SQ_ERROR;\n}\n\nconst SQRegFunction SQSharedState::_instance_default_delegate_funcz[] = {\n    {_SC(\"getclass\"), instance_getclass, 1, _SC(\"x\")},\n    {_SC(\"rawget\"),container_rawget,2, _SC(\"x\")},\n    {_SC(\"rawset\"),container_rawset,3, _SC(\"x\")},\n    {_SC(\"rawin\"),container_rawexists,2, _SC(\"x\")},\n    {_SC(\"weakref\"),obj_delegate_weakref,1, NULL },\n    {_SC(\"tostring\"),default_delegate_tostring,1, _SC(\".\")},\n    {NULL,(SQFUNCTION)0,0,NULL}\n};\n\nstatic SQInteger weakref_ref(HSQUIRRELVM v)\n{\n    if(SQ_FAILED(sq_getweakrefval(v,1)))\n        return SQ_ERROR;\n    return 1;\n}\n\nconst SQRegFunction SQSharedState::_weakref_default_delegate_funcz[] = {\n    {_SC(\"ref\"),weakref_ref,1, _SC(\"r\")},\n    {_SC(\"weakref\"),obj_delegate_weakref,1, NULL },\n    {_SC(\"tostring\"),default_delegate_tostring,1, _SC(\".\")},\n    {NULL,(SQFUNCTION)0,0,NULL}\n};\n"], "fixing_code": ["/*\n    see copyright notice in squirrel.h\n*/\n#include \"sqpcheader.h\"\n#include \"sqvm.h\"\n#include \"sqstring.h\"\n#include \"sqtable.h\"\n#include \"sqarray.h\"\n#include \"sqfuncproto.h\"\n#include \"sqclosure.h\"\n#include \"sqclass.h\"\n#include <stdlib.h>\n#include <stdarg.h>\n#include <ctype.h>\n\nstatic bool str2num(const SQChar *s,SQObjectPtr &res,SQInteger base)\n{\n    SQChar *end;\n    const SQChar *e = s;\n    bool iseintbase = base > 13; //to fix error converting hexadecimals with e like 56f0791e\n    bool isfloat = false;\n    SQChar c;\n    while((c = *e) != _SC('\\0'))\n    {\n        if (c == _SC('.') || (!iseintbase && (c == _SC('E') || c == _SC('e')))) { //e and E is for scientific notation\n            isfloat = true;\n            break;\n        }\n        e++;\n    }\n    if(isfloat){\n        SQFloat r = SQFloat(scstrtod(s,&end));\n        if(s == end) return false;\n        res = r;\n    }\n    else{\n        SQInteger r = SQInteger(scstrtol(s,&end,(int)base));\n        if(s == end) return false;\n        res = r;\n    }\n    return true;\n}\n\nstatic SQInteger base_dummy(HSQUIRRELVM SQ_UNUSED_ARG(v))\n{\n    return 0;\n}\n\n#ifndef NO_GARBAGE_COLLECTOR\nstatic SQInteger base_collectgarbage(HSQUIRRELVM v)\n{\n    sq_pushinteger(v, sq_collectgarbage(v));\n    return 1;\n}\nstatic SQInteger base_resurectureachable(HSQUIRRELVM v)\n{\n    sq_resurrectunreachable(v);\n    return 1;\n}\n#endif\n\nstatic SQInteger base_getroottable(HSQUIRRELVM v)\n{\n    v->Push(v->_roottable);\n    return 1;\n}\n\nstatic SQInteger base_getconsttable(HSQUIRRELVM v)\n{\n    v->Push(_ss(v)->_consts);\n    return 1;\n}\n\n\nstatic SQInteger base_setroottable(HSQUIRRELVM v)\n{\n    SQObjectPtr o = v->_roottable;\n    if(SQ_FAILED(sq_setroottable(v))) return SQ_ERROR;\n    v->Push(o);\n    return 1;\n}\n\nstatic SQInteger base_setconsttable(HSQUIRRELVM v)\n{\n    SQObjectPtr o = _ss(v)->_consts;\n    if(SQ_FAILED(sq_setconsttable(v))) return SQ_ERROR;\n    v->Push(o);\n    return 1;\n}\n\nstatic SQInteger base_seterrorhandler(HSQUIRRELVM v)\n{\n    sq_seterrorhandler(v);\n    return 0;\n}\n\nstatic SQInteger base_setdebughook(HSQUIRRELVM v)\n{\n    sq_setdebughook(v);\n    return 0;\n}\n\nstatic SQInteger base_enabledebuginfo(HSQUIRRELVM v)\n{\n    SQObjectPtr &o=stack_get(v,2);\n\n    sq_enabledebuginfo(v,SQVM::IsFalse(o)?SQFalse:SQTrue);\n    return 0;\n}\n\nstatic SQInteger __getcallstackinfos(HSQUIRRELVM v,SQInteger level)\n{\n    SQStackInfos si;\n    SQInteger seq = 0;\n    const SQChar *name = NULL;\n\n    if (SQ_SUCCEEDED(sq_stackinfos(v, level, &si)))\n    {\n        const SQChar *fn = _SC(\"unknown\");\n        const SQChar *src = _SC(\"unknown\");\n        if(si.funcname)fn = si.funcname;\n        if(si.source)src = si.source;\n        sq_newtable(v);\n        sq_pushstring(v, _SC(\"func\"), -1);\n        sq_pushstring(v, fn, -1);\n        sq_newslot(v, -3, SQFalse);\n        sq_pushstring(v, _SC(\"src\"), -1);\n        sq_pushstring(v, src, -1);\n        sq_newslot(v, -3, SQFalse);\n        sq_pushstring(v, _SC(\"line\"), -1);\n        sq_pushinteger(v, si.line);\n        sq_newslot(v, -3, SQFalse);\n        sq_pushstring(v, _SC(\"locals\"), -1);\n        sq_newtable(v);\n        seq=0;\n        while ((name = sq_getlocal(v, level, seq))) {\n            sq_pushstring(v, name, -1);\n            sq_push(v, -2);\n            sq_newslot(v, -4, SQFalse);\n            sq_pop(v, 1);\n            seq++;\n        }\n        sq_newslot(v, -3, SQFalse);\n        return 1;\n    }\n\n    return 0;\n}\nstatic SQInteger base_getstackinfos(HSQUIRRELVM v)\n{\n    SQInteger level;\n    sq_getinteger(v, -1, &level);\n    return __getcallstackinfos(v,level);\n}\n\nstatic SQInteger base_assert(HSQUIRRELVM v)\n{\n    if(SQVM::IsFalse(stack_get(v,2))){\n        SQInteger top = sq_gettop(v);\n        if (top>2 && SQ_SUCCEEDED(sq_tostring(v,3))) {\n            const SQChar *str = 0;\n            if (SQ_SUCCEEDED(sq_getstring(v,-1,&str))) {\n                return sq_throwerror(v, str);\n            }\n        }\n        return sq_throwerror(v, _SC(\"assertion failed\"));\n    }\n    return 0;\n}\n\nstatic SQInteger get_slice_params(HSQUIRRELVM v,SQInteger &sidx,SQInteger &eidx,SQObjectPtr &o)\n{\n    SQInteger top = sq_gettop(v);\n    sidx=0;\n    eidx=0;\n    o=stack_get(v,1);\n    if(top>1){\n        SQObjectPtr &start=stack_get(v,2);\n        if(sq_type(start)!=OT_NULL && sq_isnumeric(start)){\n            sidx=tointeger(start);\n        }\n    }\n    if(top>2){\n        SQObjectPtr &end=stack_get(v,3);\n        if(sq_isnumeric(end)){\n            eidx=tointeger(end);\n        }\n    }\n    else {\n        eidx = sq_getsize(v,1);\n    }\n    return 1;\n}\n\nstatic SQInteger base_print(HSQUIRRELVM v)\n{\n    const SQChar *str;\n    if(SQ_SUCCEEDED(sq_tostring(v,2)))\n    {\n        if(SQ_SUCCEEDED(sq_getstring(v,-1,&str))) {\n            if(_ss(v)->_printfunc) _ss(v)->_printfunc(v,_SC(\"%s\"),str);\n            return 0;\n        }\n    }\n    return SQ_ERROR;\n}\n\nstatic SQInteger base_error(HSQUIRRELVM v)\n{\n    const SQChar *str;\n    if(SQ_SUCCEEDED(sq_tostring(v,2)))\n    {\n        if(SQ_SUCCEEDED(sq_getstring(v,-1,&str))) {\n            if(_ss(v)->_errorfunc) _ss(v)->_errorfunc(v,_SC(\"%s\"),str);\n            return 0;\n        }\n    }\n    return SQ_ERROR;\n}\n\nstatic SQInteger base_compilestring(HSQUIRRELVM v)\n{\n    SQInteger nargs=sq_gettop(v);\n    const SQChar *src=NULL,*name=_SC(\"unnamedbuffer\");\n    SQInteger size;\n    sq_getstring(v,2,&src);\n    size=sq_getsize(v,2);\n    if(nargs>2){\n        sq_getstring(v,3,&name);\n    }\n    if(SQ_SUCCEEDED(sq_compilebuffer(v,src,size,name,SQFalse)))\n        return 1;\n    else\n        return SQ_ERROR;\n}\n\nstatic SQInteger base_newthread(HSQUIRRELVM v)\n{\n    SQObjectPtr &func = stack_get(v,2);\n    SQInteger stksize = (_closure(func)->_function->_stacksize << 1) +2;\n    HSQUIRRELVM newv = sq_newthread(v, (stksize < MIN_STACK_OVERHEAD + 2)? MIN_STACK_OVERHEAD + 2 : stksize);\n    sq_move(newv,v,-2);\n    return 1;\n}\n\nstatic SQInteger base_suspend(HSQUIRRELVM v)\n{\n    return sq_suspendvm(v);\n}\n\nstatic SQInteger base_array(HSQUIRRELVM v)\n{\n    SQArray *a;\n    SQObject &size = stack_get(v,2);\n    if(sq_gettop(v) > 2) {\n        a = SQArray::Create(_ss(v),0);\n        a->Resize(tointeger(size),stack_get(v,3));\n    }\n    else {\n        a = SQArray::Create(_ss(v),tointeger(size));\n    }\n    v->Push(a);\n    return 1;\n}\n\nstatic SQInteger base_type(HSQUIRRELVM v)\n{\n    SQObjectPtr &o = stack_get(v,2);\n    v->Push(SQString::Create(_ss(v),GetTypeName(o),-1));\n    return 1;\n}\n\nstatic SQInteger base_callee(HSQUIRRELVM v)\n{\n    if(v->_callsstacksize > 1)\n    {\n        v->Push(v->_callsstack[v->_callsstacksize - 2]._closure);\n        return 1;\n    }\n    return sq_throwerror(v,_SC(\"no closure in the calls stack\"));\n}\n\nstatic const SQRegFunction base_funcs[]={\n    //generic\n    {_SC(\"seterrorhandler\"),base_seterrorhandler,2, NULL},\n    {_SC(\"setdebughook\"),base_setdebughook,2, NULL},\n    {_SC(\"enabledebuginfo\"),base_enabledebuginfo,2, NULL},\n    {_SC(\"getstackinfos\"),base_getstackinfos,2, _SC(\".n\")},\n    {_SC(\"getroottable\"),base_getroottable,1, NULL},\n    {_SC(\"setroottable\"),base_setroottable,2, NULL},\n    {_SC(\"getconsttable\"),base_getconsttable,1, NULL},\n    {_SC(\"setconsttable\"),base_setconsttable,2, NULL},\n    {_SC(\"assert\"),base_assert,-2, NULL},\n    {_SC(\"print\"),base_print,2, NULL},\n    {_SC(\"error\"),base_error,2, NULL},\n    {_SC(\"compilestring\"),base_compilestring,-2, _SC(\".ss\")},\n    {_SC(\"newthread\"),base_newthread,2, _SC(\".c\")},\n    {_SC(\"suspend\"),base_suspend,-1, NULL},\n    {_SC(\"array\"),base_array,-2, _SC(\".n\")},\n    {_SC(\"type\"),base_type,2, NULL},\n    {_SC(\"callee\"),base_callee,0,NULL},\n    {_SC(\"dummy\"),base_dummy,0,NULL},\n#ifndef NO_GARBAGE_COLLECTOR\n    {_SC(\"collectgarbage\"),base_collectgarbage,0, NULL},\n    {_SC(\"resurrectunreachable\"),base_resurectureachable,0, NULL},\n#endif\n    {NULL,(SQFUNCTION)0,0,NULL}\n};\n\nvoid sq_base_register(HSQUIRRELVM v)\n{\n    SQInteger i=0;\n    sq_pushroottable(v);\n    while(base_funcs[i].name!=0) {\n        sq_pushstring(v,base_funcs[i].name,-1);\n        sq_newclosure(v,base_funcs[i].f,0);\n        sq_setnativeclosurename(v,-1,base_funcs[i].name);\n        sq_setparamscheck(v,base_funcs[i].nparamscheck,base_funcs[i].typemask);\n        sq_newslot(v,-3, SQFalse);\n        i++;\n    }\n\n    sq_pushstring(v,_SC(\"_versionnumber_\"),-1);\n    sq_pushinteger(v,SQUIRREL_VERSION_NUMBER);\n    sq_newslot(v,-3, SQFalse);\n    sq_pushstring(v,_SC(\"_version_\"),-1);\n    sq_pushstring(v,SQUIRREL_VERSION,-1);\n    sq_newslot(v,-3, SQFalse);\n    sq_pushstring(v,_SC(\"_charsize_\"),-1);\n    sq_pushinteger(v,sizeof(SQChar));\n    sq_newslot(v,-3, SQFalse);\n    sq_pushstring(v,_SC(\"_intsize_\"),-1);\n    sq_pushinteger(v,sizeof(SQInteger));\n    sq_newslot(v,-3, SQFalse);\n    sq_pushstring(v,_SC(\"_floatsize_\"),-1);\n    sq_pushinteger(v,sizeof(SQFloat));\n    sq_newslot(v,-3, SQFalse);\n    sq_pop(v,1);\n}\n\nstatic SQInteger default_delegate_len(HSQUIRRELVM v)\n{\n    v->Push(SQInteger(sq_getsize(v,1)));\n    return 1;\n}\n\nstatic SQInteger default_delegate_tofloat(HSQUIRRELVM v)\n{\n    SQObjectPtr &o=stack_get(v,1);\n    switch(sq_type(o)){\n    case OT_STRING:{\n        SQObjectPtr res;\n        if(str2num(_stringval(o),res,10)){\n            v->Push(SQObjectPtr(tofloat(res)));\n            break;\n        }}\n        return sq_throwerror(v, _SC(\"cannot convert the string\"));\n        break;\n    case OT_INTEGER:case OT_FLOAT:\n        v->Push(SQObjectPtr(tofloat(o)));\n        break;\n    case OT_BOOL:\n        v->Push(SQObjectPtr((SQFloat)(_integer(o)?1:0)));\n        break;\n    default:\n        v->PushNull();\n        break;\n    }\n    return 1;\n}\n\nstatic SQInteger default_delegate_tointeger(HSQUIRRELVM v)\n{\n    SQObjectPtr &o=stack_get(v,1);\n    SQInteger base = 10;\n    if(sq_gettop(v) > 1) {\n        sq_getinteger(v,2,&base);\n    }\n    switch(sq_type(o)){\n    case OT_STRING:{\n        SQObjectPtr res;\n        if(str2num(_stringval(o),res,base)){\n            v->Push(SQObjectPtr(tointeger(res)));\n            break;\n        }}\n        return sq_throwerror(v, _SC(\"cannot convert the string\"));\n        break;\n    case OT_INTEGER:case OT_FLOAT:\n        v->Push(SQObjectPtr(tointeger(o)));\n        break;\n    case OT_BOOL:\n        v->Push(SQObjectPtr(_integer(o)?(SQInteger)1:(SQInteger)0));\n        break;\n    default:\n        v->PushNull();\n        break;\n    }\n    return 1;\n}\n\nstatic SQInteger default_delegate_tostring(HSQUIRRELVM v)\n{\n    if(SQ_FAILED(sq_tostring(v,1)))\n        return SQ_ERROR;\n    return 1;\n}\n\nstatic SQInteger obj_delegate_weakref(HSQUIRRELVM v)\n{\n    sq_weakref(v,1);\n    return 1;\n}\n\nstatic SQInteger obj_clear(HSQUIRRELVM v)\n{\n    return SQ_SUCCEEDED(sq_clear(v,-1)) ? 1 : SQ_ERROR;\n}\n\n\nstatic SQInteger number_delegate_tochar(HSQUIRRELVM v)\n{\n    SQObject &o=stack_get(v,1);\n    SQChar c = (SQChar)tointeger(o);\n    v->Push(SQString::Create(_ss(v),(const SQChar *)&c,1));\n    return 1;\n}\n\n\n\n/////////////////////////////////////////////////////////////////\n//TABLE DEFAULT DELEGATE\n\nstatic SQInteger table_rawdelete(HSQUIRRELVM v)\n{\n    if(SQ_FAILED(sq_rawdeleteslot(v,1,SQTrue)))\n        return SQ_ERROR;\n    return 1;\n}\n\n\nstatic SQInteger container_rawexists(HSQUIRRELVM v)\n{\n    if(SQ_SUCCEEDED(sq_rawget(v,-2))) {\n        sq_pushbool(v,SQTrue);\n        return 1;\n    }\n    sq_pushbool(v,SQFalse);\n    return 1;\n}\n\nstatic SQInteger container_rawset(HSQUIRRELVM v)\n{\n    return SQ_SUCCEEDED(sq_rawset(v,-3)) ? 1 : SQ_ERROR;\n}\n\n\nstatic SQInteger container_rawget(HSQUIRRELVM v)\n{\n    return SQ_SUCCEEDED(sq_rawget(v,-2))?1:SQ_ERROR;\n}\n\nstatic SQInteger table_setdelegate(HSQUIRRELVM v)\n{\n    if(SQ_FAILED(sq_setdelegate(v,-2)))\n        return SQ_ERROR;\n    sq_push(v,-1); // -1 because sq_setdelegate pops 1\n    return 1;\n}\n\nstatic SQInteger table_getdelegate(HSQUIRRELVM v)\n{\n    return SQ_SUCCEEDED(sq_getdelegate(v,-1))?1:SQ_ERROR;\n}\n\nstatic SQInteger table_filter(HSQUIRRELVM v)\n{\n    SQObject &o = stack_get(v,1);\n    SQTable *tbl = _table(o);\n    SQObjectPtr ret = SQTable::Create(_ss(v),0);\n\n    SQObjectPtr itr, key, val;\n    SQInteger nitr;\n    while((nitr = tbl->Next(false, itr, key, val)) != -1) {\n        itr = (SQInteger)nitr;\n\n        v->Push(o);\n        v->Push(key);\n        v->Push(val);\n        if(SQ_FAILED(sq_call(v,3,SQTrue,SQFalse))) {\n            return SQ_ERROR;\n        }\n        if(!SQVM::IsFalse(v->GetUp(-1))) {\n            _table(ret)->NewSlot(key, val);\n        }\n        v->Pop();\n    }\n\n    v->Push(ret);\n    return 1;\n}\n\nstatic SQInteger table_map(HSQUIRRELVM v)\n{\n\tSQObject &o = stack_get(v, 1);\n\tSQTable *tbl = _table(o);\n\tSQInteger nitr, n = 0;\n\tSQInteger nitems = tbl->CountUsed();\n\tSQObjectPtr ret = SQArray::Create(_ss(v), nitems);\n\tSQObjectPtr itr, key, val;\n\twhile ((nitr = tbl->Next(false, itr, key, val)) != -1) {\n\t\titr = (SQInteger)nitr;\n\n\t\tv->Push(o);\n\t\tv->Push(key);\n\t\tv->Push(val);\n\t\tif (SQ_FAILED(sq_call(v, 3, SQTrue, SQFalse))) {\n\t\t\treturn SQ_ERROR;\n\t\t}\n\t\t_array(ret)->Set(n, v->GetUp(-1));\n\t\tv->Pop();\n\t\tn++;\n\t}\n\n\tv->Push(ret);\n\treturn 1;\n}\n\n#define TABLE_TO_ARRAY_FUNC(_funcname_,_valname_) static SQInteger _funcname_(HSQUIRRELVM v) \\\n{ \\\n\tSQObject &o = stack_get(v, 1); \\\n\tSQTable *t = _table(o); \\\n\tSQObjectPtr itr, key, val; \\\n\tSQObjectPtr _null; \\\n\tSQInteger nitr, n = 0; \\\n\tSQInteger nitems = t->CountUsed(); \\\n\tSQArray *a = SQArray::Create(_ss(v), nitems); \\\n\ta->Resize(nitems, _null); \\\n\tif (nitems) { \\\n\t\twhile ((nitr = t->Next(false, itr, key, val)) != -1) { \\\n\t\t\titr = (SQInteger)nitr; \\\n\t\t\ta->Set(n, _valname_); \\\n\t\t\tn++; \\\n\t\t} \\\n\t} \\\n\tv->Push(a); \\\n\treturn 1; \\\n}\n\nTABLE_TO_ARRAY_FUNC(table_keys, key)\nTABLE_TO_ARRAY_FUNC(table_values, val)\n\n\nconst SQRegFunction SQSharedState::_table_default_delegate_funcz[]={\n    {_SC(\"len\"),default_delegate_len,1, _SC(\"t\")},\n    {_SC(\"rawget\"),container_rawget,2, _SC(\"t\")},\n    {_SC(\"rawset\"),container_rawset,3, _SC(\"t\")},\n    {_SC(\"rawdelete\"),table_rawdelete,2, _SC(\"t\")},\n    {_SC(\"rawin\"),container_rawexists,2, _SC(\"t\")},\n    {_SC(\"weakref\"),obj_delegate_weakref,1, NULL },\n    {_SC(\"tostring\"),default_delegate_tostring,1, _SC(\".\")},\n    {_SC(\"clear\"),obj_clear,1, _SC(\".\")},\n    {_SC(\"setdelegate\"),table_setdelegate,2, _SC(\".t|o\")},\n    {_SC(\"getdelegate\"),table_getdelegate,1, _SC(\".\")},\n    {_SC(\"filter\"),table_filter,2, _SC(\"tc\")},\n\t{_SC(\"map\"),table_map,2, _SC(\"tc\") },\n\t{_SC(\"keys\"),table_keys,1, _SC(\"t\") },\n\t{_SC(\"values\"),table_values,1, _SC(\"t\") },\n    {NULL,(SQFUNCTION)0,0,NULL}\n};\n\n//ARRAY DEFAULT DELEGATE///////////////////////////////////////\n\nstatic SQInteger array_append(HSQUIRRELVM v)\n{\n    return SQ_SUCCEEDED(sq_arrayappend(v,-2)) ? 1 : SQ_ERROR;\n}\n\nstatic SQInteger array_extend(HSQUIRRELVM v)\n{\n    _array(stack_get(v,1))->Extend(_array(stack_get(v,2)));\n    sq_pop(v,1);\n    return 1;\n}\n\nstatic SQInteger array_reverse(HSQUIRRELVM v)\n{\n    return SQ_SUCCEEDED(sq_arrayreverse(v,-1)) ? 1 : SQ_ERROR;\n}\n\nstatic SQInteger array_pop(HSQUIRRELVM v)\n{\n    return SQ_SUCCEEDED(sq_arraypop(v,1,SQTrue))?1:SQ_ERROR;\n}\n\nstatic SQInteger array_top(HSQUIRRELVM v)\n{\n    SQObject &o=stack_get(v,1);\n    if(_array(o)->Size()>0){\n        v->Push(_array(o)->Top());\n        return 1;\n    }\n    else return sq_throwerror(v,_SC(\"top() on a empty array\"));\n}\n\nstatic SQInteger array_insert(HSQUIRRELVM v)\n{\n    SQObject &o=stack_get(v,1);\n    SQObject &idx=stack_get(v,2);\n    SQObject &val=stack_get(v,3);\n    if(!_array(o)->Insert(tointeger(idx),val))\n        return sq_throwerror(v,_SC(\"index out of range\"));\n    sq_pop(v,2);\n    return 1;\n}\n\nstatic SQInteger array_remove(HSQUIRRELVM v)\n{\n    SQObject &o = stack_get(v, 1);\n    SQObject &idx = stack_get(v, 2);\n    if(!sq_isnumeric(idx)) return sq_throwerror(v, _SC(\"wrong type\"));\n    SQObjectPtr val;\n    if(_array(o)->Get(tointeger(idx), val)) {\n        _array(o)->Remove(tointeger(idx));\n        v->Push(val);\n        return 1;\n    }\n    return sq_throwerror(v, _SC(\"idx out of range\"));\n}\n\nstatic SQInteger array_resize(HSQUIRRELVM v)\n{\n    SQObject &o = stack_get(v, 1);\n    SQObject &nsize = stack_get(v, 2);\n    SQObjectPtr fill;\n    if(sq_isnumeric(nsize)) {\n        SQInteger sz = tointeger(nsize);\n        if (sz<0)\n          return sq_throwerror(v, _SC(\"resizing to negative length\"));\n\n        if(sq_gettop(v) > 2)\n            fill = stack_get(v, 3);\n        _array(o)->Resize(sz,fill);\n        sq_settop(v, 1);\n        return 1;\n    }\n    return sq_throwerror(v, _SC(\"size must be a number\"));\n}\n\nstatic SQInteger __map_array(SQArray *dest,SQArray *src,HSQUIRRELVM v) {\n    SQObjectPtr temp;\n    SQInteger size = src->Size();\n    SQObject &closure = stack_get(v, 2);\n    v->Push(closure);\n\n    SQInteger nArgs = 0;\n    if(sq_type(closure) == OT_CLOSURE) {\n        nArgs = _closure(closure)->_function->_nparameters;\n    }\n    else if (sq_type(closure) == OT_NATIVECLOSURE) {\n        SQInteger nParamsCheck = _nativeclosure(closure)->_nparamscheck;\n        if (nParamsCheck > 0)\n            nArgs = nParamsCheck;\n        else // push all params when there is no check or only minimal count set\n            nArgs = 4;\n    }\n\n    for(SQInteger n = 0; n < size; n++) {\n        src->Get(n,temp);\n        v->Push(src);\n        v->Push(temp);\n        if (nArgs >= 3)\n            v->Push(SQObjectPtr(n));\n        if (nArgs >= 4)\n            v->Push(src);\n        if(SQ_FAILED(sq_call(v,nArgs,SQTrue,SQFalse))) {\n            return SQ_ERROR;\n        }\n        dest->Set(n,v->GetUp(-1));\n        v->Pop();\n    }\n    v->Pop();\n    return 0;\n}\n\nstatic SQInteger array_map(HSQUIRRELVM v)\n{\n    SQObject &o = stack_get(v,1);\n    SQInteger size = _array(o)->Size();\n    SQObjectPtr ret = SQArray::Create(_ss(v),size);\n    if(SQ_FAILED(__map_array(_array(ret),_array(o),v)))\n        return SQ_ERROR;\n    v->Push(ret);\n    return 1;\n}\n\nstatic SQInteger array_apply(HSQUIRRELVM v)\n{\n    SQObject &o = stack_get(v,1);\n    if(SQ_FAILED(__map_array(_array(o),_array(o),v)))\n        return SQ_ERROR;\n    sq_pop(v,1);\n    return 1;\n}\n\nstatic SQInteger array_reduce(HSQUIRRELVM v)\n{\n    SQObject &o = stack_get(v,1);\n    SQArray *a = _array(o);\n    SQInteger size = a->Size();\n    SQObjectPtr res;\n    SQInteger iterStart;\n    if (sq_gettop(v)>2) {\n        res = stack_get(v,3);\n        iterStart = 0;\n    } else if (size==0) {\n        return 0;\n    } else {\n        a->Get(0,res);\n        iterStart = 1;\n    }\n    if (size > iterStart) {\n        SQObjectPtr other;\n        v->Push(stack_get(v,2));\n        for (SQInteger n = iterStart; n < size; n++) {\n            a->Get(n,other);\n            v->Push(o);\n            v->Push(res);\n            v->Push(other);\n            if(SQ_FAILED(sq_call(v,3,SQTrue,SQFalse))) {\n                return SQ_ERROR;\n            }\n            res = v->GetUp(-1);\n            v->Pop();\n        }\n        v->Pop();\n    }\n    v->Push(res);\n    return 1;\n}\n\nstatic SQInteger array_filter(HSQUIRRELVM v)\n{\n    SQObject &o = stack_get(v,1);\n    SQArray *a = _array(o);\n    SQObjectPtr ret = SQArray::Create(_ss(v),0);\n    SQInteger size = a->Size();\n    SQObjectPtr val;\n    for(SQInteger n = 0; n < size; n++) {\n        a->Get(n,val);\n        v->Push(o);\n        v->Push(n);\n        v->Push(val);\n        if(SQ_FAILED(sq_call(v,3,SQTrue,SQFalse))) {\n            return SQ_ERROR;\n        }\n        if(!SQVM::IsFalse(v->GetUp(-1))) {\n            _array(ret)->Append(val);\n        }\n        v->Pop();\n    }\n    v->Push(ret);\n    return 1;\n}\n\nstatic SQInteger array_find(HSQUIRRELVM v)\n{\n    SQObject &o = stack_get(v,1);\n    SQObjectPtr &val = stack_get(v,2);\n    SQArray *a = _array(o);\n    SQInteger size = a->Size();\n    SQObjectPtr temp;\n    for(SQInteger n = 0; n < size; n++) {\n        bool res = false;\n        a->Get(n,temp);\n        if(SQVM::IsEqual(temp,val,res) && res) {\n            v->Push(n);\n            return 1;\n        }\n    }\n    return 0;\n}\n\n\nstatic bool _sort_compare(HSQUIRRELVM v, SQArray *arr, SQObjectPtr &a,SQObjectPtr &b,SQInteger func,SQInteger &ret)\n{\n    if(func < 0) {\n        if(!v->ObjCmp(a,b,ret)) return false;\n    }\n    else {\n        SQInteger top = sq_gettop(v);\n        sq_push(v, func);\n        sq_pushroottable(v);\n        v->Push(a);\n        v->Push(b);\n\t\tSQObjectPtr *valptr = arr->_values._vals;\n\t\tSQUnsignedInteger precallsize = arr->_values.size();\n        if(SQ_FAILED(sq_call(v, 3, SQTrue, SQFalse))) {\n            if(!sq_isstring( v->_lasterror))\n                v->Raise_Error(_SC(\"compare func failed\"));\n            return false;\n        }\n\t\tif(SQ_FAILED(sq_getinteger(v, -1, &ret))) {\n            v->Raise_Error(_SC(\"numeric value expected as return value of the compare function\"));\n            return false;\n        }\n\t\tif (precallsize != arr->_values.size() || valptr != arr->_values._vals) {\n\t\t\tv->Raise_Error(_SC(\"array resized during sort operation\"));\n\t\t\treturn false;\n\t\t}\n        sq_settop(v, top);\n        return true;\n    }\n    return true;\n}\n\nstatic bool _hsort_sift_down(HSQUIRRELVM v,SQArray *arr, SQInteger root, SQInteger bottom, SQInteger func)\n{\n    SQInteger maxChild;\n    SQInteger done = 0;\n    SQInteger ret;\n    SQInteger root2;\n    while (((root2 = root * 2) <= bottom) && (!done))\n    {\n        if (root2 == bottom) {\n            maxChild = root2;\n        }\n        else {\n            if(!_sort_compare(v,arr,arr->_values[root2],arr->_values[root2 + 1],func,ret))\n                return false;\n            if (ret > 0) {\n                maxChild = root2;\n            }\n            else {\n                maxChild = root2 + 1;\n            }\n        }\n\n        if(!_sort_compare(v,arr,arr->_values[root],arr->_values[maxChild],func,ret))\n            return false;\n        if (ret < 0) {\n            if (root == maxChild) {\n                v->Raise_Error(_SC(\"inconsistent compare function\"));\n                return false; // We'd be swapping ourselve. The compare function is incorrect\n            }\n\n            _Swap(arr->_values[root],arr->_values[maxChild]);\n            root = maxChild;\n        }\n        else {\n            done = 1;\n        }\n    }\n    return true;\n}\n\nstatic bool _hsort(HSQUIRRELVM v,SQObjectPtr &arr, SQInteger SQ_UNUSED_ARG(l), SQInteger SQ_UNUSED_ARG(r),SQInteger func)\n{\n    SQArray *a = _array(arr);\n    SQInteger i;\n    SQInteger array_size = a->Size();\n    for (i = (array_size / 2); i >= 0; i--) {\n        if(!_hsort_sift_down(v,a, i, array_size - 1,func)) return false;\n    }\n\n    for (i = array_size-1; i >= 1; i--)\n    {\n        _Swap(a->_values[0],a->_values[i]);\n        if(!_hsort_sift_down(v,a, 0, i-1,func)) return false;\n    }\n    return true;\n}\n\nstatic SQInteger array_sort(HSQUIRRELVM v)\n{\n    SQInteger func = -1;\n    SQObjectPtr &o = stack_get(v,1);\n    if(_array(o)->Size() > 1) {\n        if(sq_gettop(v) == 2) func = 2;\n        if(!_hsort(v, o, 0, _array(o)->Size()-1, func))\n            return SQ_ERROR;\n\n    }\n    sq_settop(v,1);\n    return 1;\n}\n\nstatic SQInteger array_slice(HSQUIRRELVM v)\n{\n    SQInteger sidx,eidx;\n    SQObjectPtr o;\n    if(get_slice_params(v,sidx,eidx,o)==-1)return -1;\n    SQInteger alen = _array(o)->Size();\n    if(sidx < 0)sidx = alen + sidx;\n    if(eidx < 0)eidx = alen + eidx;\n    if(eidx < sidx)return sq_throwerror(v,_SC(\"wrong indexes\"));\n    if(eidx > alen || sidx < 0)return sq_throwerror(v, _SC(\"slice out of range\"));\n    SQArray *arr=SQArray::Create(_ss(v),eidx-sidx);\n    SQObjectPtr t;\n    SQInteger count=0;\n    for(SQInteger i=sidx;i<eidx;i++){\n        _array(o)->Get(i,t);\n        arr->Set(count++,t);\n    }\n    v->Push(arr);\n    return 1;\n\n}\n\nconst SQRegFunction SQSharedState::_array_default_delegate_funcz[]={\n    {_SC(\"len\"),default_delegate_len,1, _SC(\"a\")},\n    {_SC(\"append\"),array_append,2, _SC(\"a\")},\n    {_SC(\"extend\"),array_extend,2, _SC(\"aa\")},\n    {_SC(\"push\"),array_append,2, _SC(\"a\")},\n    {_SC(\"pop\"),array_pop,1, _SC(\"a\")},\n    {_SC(\"top\"),array_top,1, _SC(\"a\")},\n    {_SC(\"insert\"),array_insert,3, _SC(\"an\")},\n    {_SC(\"remove\"),array_remove,2, _SC(\"an\")},\n    {_SC(\"resize\"),array_resize,-2, _SC(\"an\")},\n    {_SC(\"reverse\"),array_reverse,1, _SC(\"a\")},\n    {_SC(\"sort\"),array_sort,-1, _SC(\"ac\")},\n    {_SC(\"slice\"),array_slice,-1, _SC(\"ann\")},\n    {_SC(\"weakref\"),obj_delegate_weakref,1, NULL },\n    {_SC(\"tostring\"),default_delegate_tostring,1, _SC(\".\")},\n    {_SC(\"clear\"),obj_clear,1, _SC(\".\")},\n    {_SC(\"map\"),array_map,2, _SC(\"ac\")},\n    {_SC(\"apply\"),array_apply,2, _SC(\"ac\")},\n    {_SC(\"reduce\"),array_reduce,-2, _SC(\"ac.\")},\n    {_SC(\"filter\"),array_filter,2, _SC(\"ac\")},\n    {_SC(\"find\"),array_find,2, _SC(\"a.\")},\n    {NULL,(SQFUNCTION)0,0,NULL}\n};\n\n//STRING DEFAULT DELEGATE//////////////////////////\nstatic SQInteger string_slice(HSQUIRRELVM v)\n{\n    SQInteger sidx,eidx;\n    SQObjectPtr o;\n    if(SQ_FAILED(get_slice_params(v,sidx,eidx,o)))return -1;\n    SQInteger slen = _string(o)->_len;\n    if(sidx < 0)sidx = slen + sidx;\n    if(eidx < 0)eidx = slen + eidx;\n    if(eidx < sidx) return sq_throwerror(v,_SC(\"wrong indexes\"));\n    if(eidx > slen || sidx < 0) return sq_throwerror(v, _SC(\"slice out of range\"));\n    v->Push(SQString::Create(_ss(v),&_stringval(o)[sidx],eidx-sidx));\n    return 1;\n}\n\nstatic SQInteger string_find(HSQUIRRELVM v)\n{\n    SQInteger top,start_idx=0;\n    const SQChar *str,*substr,*ret;\n    if(((top=sq_gettop(v))>1) && SQ_SUCCEEDED(sq_getstring(v,1,&str)) && SQ_SUCCEEDED(sq_getstring(v,2,&substr))){\n        if(top>2)sq_getinteger(v,3,&start_idx);\n        if((sq_getsize(v,1)>start_idx) && (start_idx>=0)){\n            ret=scstrstr(&str[start_idx],substr);\n            if(ret){\n                sq_pushinteger(v,(SQInteger)(ret-str));\n                return 1;\n            }\n        }\n        return 0;\n    }\n    return sq_throwerror(v,_SC(\"invalid param\"));\n}\n\n#define STRING_TOFUNCZ(func) static SQInteger string_##func(HSQUIRRELVM v) \\\n{\\\n    SQInteger sidx,eidx; \\\n    SQObjectPtr str; \\\n    if(SQ_FAILED(get_slice_params(v,sidx,eidx,str)))return -1; \\\n    SQInteger slen = _string(str)->_len; \\\n    if(sidx < 0)sidx = slen + sidx; \\\n    if(eidx < 0)eidx = slen + eidx; \\\n    if(eidx < sidx) return sq_throwerror(v,_SC(\"wrong indexes\")); \\\n    if(eidx > slen || sidx < 0) return sq_throwerror(v,_SC(\"slice out of range\")); \\\n    SQInteger len=_string(str)->_len; \\\n    const SQChar *sthis=_stringval(str); \\\n    SQChar *snew=(_ss(v)->GetScratchPad(sq_rsl(len))); \\\n    memcpy(snew,sthis,sq_rsl(len));\\\n    for(SQInteger i=sidx;i<eidx;i++) snew[i] = func(sthis[i]); \\\n    v->Push(SQString::Create(_ss(v),snew,len)); \\\n    return 1; \\\n}\n\n\nSTRING_TOFUNCZ(tolower)\nSTRING_TOFUNCZ(toupper)\n\nconst SQRegFunction SQSharedState::_string_default_delegate_funcz[]={\n    {_SC(\"len\"),default_delegate_len,1, _SC(\"s\")},\n    {_SC(\"tointeger\"),default_delegate_tointeger,-1, _SC(\"sn\")},\n    {_SC(\"tofloat\"),default_delegate_tofloat,1, _SC(\"s\")},\n    {_SC(\"tostring\"),default_delegate_tostring,1, _SC(\".\")},\n    {_SC(\"slice\"),string_slice,-1, _SC(\"s n  n\")},\n    {_SC(\"find\"),string_find,-2, _SC(\"s s n\")},\n    {_SC(\"tolower\"),string_tolower,-1, _SC(\"s n n\")},\n    {_SC(\"toupper\"),string_toupper,-1, _SC(\"s n n\")},\n    {_SC(\"weakref\"),obj_delegate_weakref,1, NULL },\n    {NULL,(SQFUNCTION)0,0,NULL}\n};\n\n//INTEGER DEFAULT DELEGATE//////////////////////////\nconst SQRegFunction SQSharedState::_number_default_delegate_funcz[]={\n    {_SC(\"tointeger\"),default_delegate_tointeger,1, _SC(\"n|b\")},\n    {_SC(\"tofloat\"),default_delegate_tofloat,1, _SC(\"n|b\")},\n    {_SC(\"tostring\"),default_delegate_tostring,1, _SC(\".\")},\n    {_SC(\"tochar\"),number_delegate_tochar,1, _SC(\"n|b\")},\n    {_SC(\"weakref\"),obj_delegate_weakref,1, NULL },\n    {NULL,(SQFUNCTION)0,0,NULL}\n};\n\n//CLOSURE DEFAULT DELEGATE//////////////////////////\nstatic SQInteger closure_pcall(HSQUIRRELVM v)\n{\n    return SQ_SUCCEEDED(sq_call(v,sq_gettop(v)-1,SQTrue,SQFalse))?1:SQ_ERROR;\n}\n\nstatic SQInteger closure_call(HSQUIRRELVM v)\n{\n\tSQObjectPtr &c = stack_get(v, -1);\n\tif (sq_type(c) == OT_CLOSURE && (_closure(c)->_function->_bgenerator == false))\n\t{\n\t\treturn sq_tailcall(v, sq_gettop(v) - 1);\n\t}\n\treturn SQ_SUCCEEDED(sq_call(v, sq_gettop(v) - 1, SQTrue, SQTrue)) ? 1 : SQ_ERROR;\n}\n\nstatic SQInteger _closure_acall(HSQUIRRELVM v,SQBool raiseerror)\n{\n    SQArray *aparams=_array(stack_get(v,2));\n    SQInteger nparams=aparams->Size();\n    v->Push(stack_get(v,1));\n    for(SQInteger i=0;i<nparams;i++)v->Push(aparams->_values[i]);\n    return SQ_SUCCEEDED(sq_call(v,nparams,SQTrue,raiseerror))?1:SQ_ERROR;\n}\n\nstatic SQInteger closure_acall(HSQUIRRELVM v)\n{\n    return _closure_acall(v,SQTrue);\n}\n\nstatic SQInteger closure_pacall(HSQUIRRELVM v)\n{\n    return _closure_acall(v,SQFalse);\n}\n\nstatic SQInteger closure_bindenv(HSQUIRRELVM v)\n{\n    if(SQ_FAILED(sq_bindenv(v,1)))\n        return SQ_ERROR;\n    return 1;\n}\n\nstatic SQInteger closure_getroot(HSQUIRRELVM v)\n{\n    if(SQ_FAILED(sq_getclosureroot(v,-1)))\n        return SQ_ERROR;\n    return 1;\n}\n\nstatic SQInteger closure_setroot(HSQUIRRELVM v)\n{\n    if(SQ_FAILED(sq_setclosureroot(v,-2)))\n        return SQ_ERROR;\n    return 1;\n}\n\nstatic SQInteger closure_getinfos(HSQUIRRELVM v) {\n    SQObject o = stack_get(v,1);\n    SQTable *res = SQTable::Create(_ss(v),4);\n    if(sq_type(o) == OT_CLOSURE) {\n        SQFunctionProto *f = _closure(o)->_function;\n        SQInteger nparams = f->_nparameters + (f->_varparams?1:0);\n        SQObjectPtr params = SQArray::Create(_ss(v),nparams);\n    SQObjectPtr defparams = SQArray::Create(_ss(v),f->_ndefaultparams);\n        for(SQInteger n = 0; n<f->_nparameters; n++) {\n            _array(params)->Set((SQInteger)n,f->_parameters[n]);\n        }\n    for(SQInteger j = 0; j<f->_ndefaultparams; j++) {\n            _array(defparams)->Set((SQInteger)j,_closure(o)->_defaultparams[j]);\n        }\n        if(f->_varparams) {\n            _array(params)->Set(nparams-1,SQString::Create(_ss(v),_SC(\"...\"),-1));\n        }\n        res->NewSlot(SQString::Create(_ss(v),_SC(\"native\"),-1),false);\n        res->NewSlot(SQString::Create(_ss(v),_SC(\"name\"),-1),f->_name);\n        res->NewSlot(SQString::Create(_ss(v),_SC(\"src\"),-1),f->_sourcename);\n        res->NewSlot(SQString::Create(_ss(v),_SC(\"parameters\"),-1),params);\n        res->NewSlot(SQString::Create(_ss(v),_SC(\"varargs\"),-1),f->_varparams);\n    res->NewSlot(SQString::Create(_ss(v),_SC(\"defparams\"),-1),defparams);\n    }\n    else { //OT_NATIVECLOSURE\n        SQNativeClosure *nc = _nativeclosure(o);\n        res->NewSlot(SQString::Create(_ss(v),_SC(\"native\"),-1),true);\n        res->NewSlot(SQString::Create(_ss(v),_SC(\"name\"),-1),nc->_name);\n        res->NewSlot(SQString::Create(_ss(v),_SC(\"paramscheck\"),-1),nc->_nparamscheck);\n        SQObjectPtr typecheck;\n        if(nc->_typecheck.size() > 0) {\n            typecheck =\n                SQArray::Create(_ss(v), nc->_typecheck.size());\n            for(SQUnsignedInteger n = 0; n<nc->_typecheck.size(); n++) {\n                    _array(typecheck)->Set((SQInteger)n,nc->_typecheck[n]);\n            }\n        }\n        res->NewSlot(SQString::Create(_ss(v),_SC(\"typecheck\"),-1),typecheck);\n    }\n    v->Push(res);\n    return 1;\n}\n\n\n\nconst SQRegFunction SQSharedState::_closure_default_delegate_funcz[]={\n    {_SC(\"call\"),closure_call,-1, _SC(\"c\")},\n    {_SC(\"pcall\"),closure_pcall,-1, _SC(\"c\")},\n    {_SC(\"acall\"),closure_acall,2, _SC(\"ca\")},\n    {_SC(\"pacall\"),closure_pacall,2, _SC(\"ca\")},\n    {_SC(\"weakref\"),obj_delegate_weakref,1, NULL },\n    {_SC(\"tostring\"),default_delegate_tostring,1, _SC(\".\")},\n    {_SC(\"bindenv\"),closure_bindenv,2, _SC(\"c x|y|t\")},\n    {_SC(\"getinfos\"),closure_getinfos,1, _SC(\"c\")},\n    {_SC(\"getroot\"),closure_getroot,1, _SC(\"c\")},\n    {_SC(\"setroot\"),closure_setroot,2, _SC(\"ct\")},\n    {NULL,(SQFUNCTION)0,0,NULL}\n};\n\n//GENERATOR DEFAULT DELEGATE\nstatic SQInteger generator_getstatus(HSQUIRRELVM v)\n{\n    SQObject &o=stack_get(v,1);\n    switch(_generator(o)->_state){\n        case SQGenerator::eSuspended:v->Push(SQString::Create(_ss(v),_SC(\"suspended\")));break;\n        case SQGenerator::eRunning:v->Push(SQString::Create(_ss(v),_SC(\"running\")));break;\n        case SQGenerator::eDead:v->Push(SQString::Create(_ss(v),_SC(\"dead\")));break;\n    }\n    return 1;\n}\n\nconst SQRegFunction SQSharedState::_generator_default_delegate_funcz[]={\n    {_SC(\"getstatus\"),generator_getstatus,1, _SC(\"g\")},\n    {_SC(\"weakref\"),obj_delegate_weakref,1, NULL },\n    {_SC(\"tostring\"),default_delegate_tostring,1, _SC(\".\")},\n    {NULL,(SQFUNCTION)0,0,NULL}\n};\n\n//THREAD DEFAULT DELEGATE\nstatic SQInteger thread_call(HSQUIRRELVM v)\n{\n    SQObjectPtr o = stack_get(v,1);\n    if(sq_type(o) == OT_THREAD) {\n        SQInteger nparams = sq_gettop(v);\n        sq_reservestack(_thread(o), nparams + 3);\n        _thread(o)->Push(_thread(o)->_roottable);\n        for(SQInteger i = 2; i<(nparams+1); i++)\n            sq_move(_thread(o),v,i);\n        if(SQ_SUCCEEDED(sq_call(_thread(o),nparams,SQTrue,SQTrue))) {\n            sq_move(v,_thread(o),-1);\n            sq_pop(_thread(o),1);\n            return 1;\n        }\n        v->_lasterror = _thread(o)->_lasterror;\n        return SQ_ERROR;\n    }\n    return sq_throwerror(v,_SC(\"wrong parameter\"));\n}\n\nstatic SQInteger thread_wakeup(HSQUIRRELVM v)\n{\n    SQObjectPtr o = stack_get(v,1);\n    if(sq_type(o) == OT_THREAD) {\n        SQVM *thread = _thread(o);\n        SQInteger state = sq_getvmstate(thread);\n        if(state != SQ_VMSTATE_SUSPENDED) {\n            switch(state) {\n                case SQ_VMSTATE_IDLE:\n                    return sq_throwerror(v,_SC(\"cannot wakeup a idle thread\"));\n                break;\n                case SQ_VMSTATE_RUNNING:\n                    return sq_throwerror(v,_SC(\"cannot wakeup a running thread\"));\n                break;\n            }\n        }\n\n        SQInteger wakeupret = sq_gettop(v)>1?SQTrue:SQFalse;\n        if(wakeupret) {\n            sq_move(thread,v,2);\n        }\n        if(SQ_SUCCEEDED(sq_wakeupvm(thread,wakeupret,SQTrue,SQTrue,SQFalse))) {\n            sq_move(v,thread,-1);\n            sq_pop(thread,1); //pop retval\n            if(sq_getvmstate(thread) == SQ_VMSTATE_IDLE) {\n                sq_settop(thread,1); //pop roottable\n            }\n            return 1;\n        }\n        sq_settop(thread,1);\n        v->_lasterror = thread->_lasterror;\n        return SQ_ERROR;\n    }\n    return sq_throwerror(v,_SC(\"wrong parameter\"));\n}\n\nstatic SQInteger thread_wakeupthrow(HSQUIRRELVM v)\n{\n    SQObjectPtr o = stack_get(v,1);\n    if(sq_type(o) == OT_THREAD) {\n        SQVM *thread = _thread(o);\n        SQInteger state = sq_getvmstate(thread);\n        if(state != SQ_VMSTATE_SUSPENDED) {\n            switch(state) {\n                case SQ_VMSTATE_IDLE:\n                    return sq_throwerror(v,_SC(\"cannot wakeup a idle thread\"));\n                break;\n                case SQ_VMSTATE_RUNNING:\n                    return sq_throwerror(v,_SC(\"cannot wakeup a running thread\"));\n                break;\n            }\n        }\n\n        sq_move(thread,v,2);\n        sq_throwobject(thread);\n        SQBool rethrow_error = SQTrue;\n        if(sq_gettop(v) > 2) {\n            sq_getbool(v,3,&rethrow_error);\n        }\n        if(SQ_SUCCEEDED(sq_wakeupvm(thread,SQFalse,SQTrue,SQTrue,SQTrue))) {\n            sq_move(v,thread,-1);\n            sq_pop(thread,1); //pop retval\n            if(sq_getvmstate(thread) == SQ_VMSTATE_IDLE) {\n                sq_settop(thread,1); //pop roottable\n            }\n            return 1;\n        }\n        sq_settop(thread,1);\n        if(rethrow_error) {\n            v->_lasterror = thread->_lasterror;\n            return SQ_ERROR;\n        }\n        return SQ_OK;\n    }\n    return sq_throwerror(v,_SC(\"wrong parameter\"));\n}\n\nstatic SQInteger thread_getstatus(HSQUIRRELVM v)\n{\n    SQObjectPtr &o = stack_get(v,1);\n    switch(sq_getvmstate(_thread(o))) {\n        case SQ_VMSTATE_IDLE:\n            sq_pushstring(v,_SC(\"idle\"),-1);\n        break;\n        case SQ_VMSTATE_RUNNING:\n            sq_pushstring(v,_SC(\"running\"),-1);\n        break;\n        case SQ_VMSTATE_SUSPENDED:\n            sq_pushstring(v,_SC(\"suspended\"),-1);\n        break;\n        default:\n            return sq_throwerror(v,_SC(\"internal VM error\"));\n    }\n    return 1;\n}\n\nstatic SQInteger thread_getstackinfos(HSQUIRRELVM v)\n{\n    SQObjectPtr o = stack_get(v,1);\n    if(sq_type(o) == OT_THREAD) {\n        SQVM *thread = _thread(o);\n        SQInteger threadtop = sq_gettop(thread);\n        SQInteger level;\n        sq_getinteger(v,-1,&level);\n        SQRESULT res = __getcallstackinfos(thread,level);\n        if(SQ_FAILED(res))\n        {\n            sq_settop(thread,threadtop);\n            if(sq_type(thread->_lasterror) == OT_STRING) {\n                sq_throwerror(v,_stringval(thread->_lasterror));\n            }\n            else {\n                sq_throwerror(v,_SC(\"unknown error\"));\n            }\n        }\n        if(res > 0) {\n            //some result\n            sq_move(v,thread,-1);\n            sq_settop(thread,threadtop);\n            return 1;\n        }\n        //no result\n        sq_settop(thread,threadtop);\n        return 0;\n\n    }\n    return sq_throwerror(v,_SC(\"wrong parameter\"));\n}\n\nconst SQRegFunction SQSharedState::_thread_default_delegate_funcz[] = {\n    {_SC(\"call\"), thread_call, -1, _SC(\"v\")},\n    {_SC(\"wakeup\"), thread_wakeup, -1, _SC(\"v\")},\n    {_SC(\"wakeupthrow\"), thread_wakeupthrow, -2, _SC(\"v.b\")},\n    {_SC(\"getstatus\"), thread_getstatus, 1, _SC(\"v\")},\n    {_SC(\"weakref\"),obj_delegate_weakref,1, NULL },\n    {_SC(\"getstackinfos\"),thread_getstackinfos,2, _SC(\"vn\")},\n    {_SC(\"tostring\"),default_delegate_tostring,1, _SC(\".\")},\n    {NULL,(SQFUNCTION)0,0,NULL}\n};\n\nstatic SQInteger class_getattributes(HSQUIRRELVM v)\n{\n    return SQ_SUCCEEDED(sq_getattributes(v,-2))?1:SQ_ERROR;\n}\n\nstatic SQInteger class_setattributes(HSQUIRRELVM v)\n{\n    return SQ_SUCCEEDED(sq_setattributes(v,-3))?1:SQ_ERROR;\n}\n\nstatic SQInteger class_instance(HSQUIRRELVM v)\n{\n    return SQ_SUCCEEDED(sq_createinstance(v,-1))?1:SQ_ERROR;\n}\n\nstatic SQInteger class_getbase(HSQUIRRELVM v)\n{\n    return SQ_SUCCEEDED(sq_getbase(v,-1))?1:SQ_ERROR;\n}\n\nstatic SQInteger class_newmember(HSQUIRRELVM v)\n{\n    SQInteger top = sq_gettop(v);\n    SQBool bstatic = SQFalse;\n    if(top == 5)\n    {\n        sq_tobool(v,-1,&bstatic);\n        sq_pop(v,1);\n    }\n\n    if(top < 4) {\n        sq_pushnull(v);\n    }\n    return SQ_SUCCEEDED(sq_newmember(v,-4,bstatic))?1:SQ_ERROR;\n}\n\nstatic SQInteger class_rawnewmember(HSQUIRRELVM v)\n{\n    SQInteger top = sq_gettop(v);\n    SQBool bstatic = SQFalse;\n    if(top == 5)\n    {\n        sq_tobool(v,-1,&bstatic);\n        sq_pop(v,1);\n    }\n\n    if(top < 4) {\n        sq_pushnull(v);\n    }\n    return SQ_SUCCEEDED(sq_rawnewmember(v,-4,bstatic))?1:SQ_ERROR;\n}\n\nconst SQRegFunction SQSharedState::_class_default_delegate_funcz[] = {\n    {_SC(\"getattributes\"), class_getattributes, 2, _SC(\"y.\")},\n    {_SC(\"setattributes\"), class_setattributes, 3, _SC(\"y..\")},\n    {_SC(\"rawget\"),container_rawget,2, _SC(\"y\")},\n    {_SC(\"rawset\"),container_rawset,3, _SC(\"y\")},\n    {_SC(\"rawin\"),container_rawexists,2, _SC(\"y\")},\n    {_SC(\"weakref\"),obj_delegate_weakref,1, NULL },\n    {_SC(\"tostring\"),default_delegate_tostring,1, _SC(\".\")},\n    {_SC(\"instance\"),class_instance,1, _SC(\"y\")},\n    {_SC(\"getbase\"),class_getbase,1, _SC(\"y\")},\n    {_SC(\"newmember\"),class_newmember,-3, _SC(\"y\")},\n    {_SC(\"rawnewmember\"),class_rawnewmember,-3, _SC(\"y\")},\n    {NULL,(SQFUNCTION)0,0,NULL}\n};\n\n\nstatic SQInteger instance_getclass(HSQUIRRELVM v)\n{\n    if(SQ_SUCCEEDED(sq_getclass(v,1)))\n        return 1;\n    return SQ_ERROR;\n}\n\nconst SQRegFunction SQSharedState::_instance_default_delegate_funcz[] = {\n    {_SC(\"getclass\"), instance_getclass, 1, _SC(\"x\")},\n    {_SC(\"rawget\"),container_rawget,2, _SC(\"x\")},\n    {_SC(\"rawset\"),container_rawset,3, _SC(\"x\")},\n    {_SC(\"rawin\"),container_rawexists,2, _SC(\"x\")},\n    {_SC(\"weakref\"),obj_delegate_weakref,1, NULL },\n    {_SC(\"tostring\"),default_delegate_tostring,1, _SC(\".\")},\n    {NULL,(SQFUNCTION)0,0,NULL}\n};\n\nstatic SQInteger weakref_ref(HSQUIRRELVM v)\n{\n    if(SQ_FAILED(sq_getweakrefval(v,1)))\n        return SQ_ERROR;\n    return 1;\n}\n\nconst SQRegFunction SQSharedState::_weakref_default_delegate_funcz[] = {\n    {_SC(\"ref\"),weakref_ref,1, _SC(\"r\")},\n    {_SC(\"weakref\"),obj_delegate_weakref,1, NULL },\n    {_SC(\"tostring\"),default_delegate_tostring,1, _SC(\".\")},\n    {NULL,(SQFUNCTION)0,0,NULL}\n};\n"], "filenames": ["squirrel/sqbaselib.cpp"], "buggy_code_start_loc": [1151], "buggy_code_end_loc": [1151], "fixing_code_start_loc": [1152], "fixing_code_end_loc": [1153], "type": "CWE-787", "message": "Heap-based buffer overflow in sqbaselib.cpp in SQUIRREL 3.2 due to lack of a certain sq_reservestack call.", "other": {"cve": {"id": "CVE-2022-30292", "sourceIdentifier": "cve@mitre.org", "published": "2022-05-04T23:15:08.567", "lastModified": "2022-12-09T16:22:03.587", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Heap-based buffer overflow in sqbaselib.cpp in SQUIRREL 3.2 due to lack of a certain sq_reservestack call."}, {"lang": "es", "value": "Desbordamiento de b\u00fafer basado en heap en sqbaselib.cpp en SQUIRREL 3.2 debido a la falta de una determinada llamada sq_reservestack"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 10.0, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 6.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:squirrel-lang:squirrel:3.2:*:*:*:*:*:*:*", "matchCriteriaId": "A78A553F-0288-4A47-8BA2-3FF2B76F36B2"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:35:*:*:*:*:*:*:*", "matchCriteriaId": "80E516C0-98A4-4ADE-B69F-66A772E2BAAA"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:36:*:*:*:*:*:*:*", "matchCriteriaId": "5C675112-476C-4D7C-BCB9-A2FB2D0BC9FD"}]}]}], "references": [{"url": "https://github.com/albertodemichelis/squirrel/commit/a6413aa690e0bdfef648c68693349a7b878fe60d", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/sprushed/CVE-2022-30292", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/BV7SJJ44AGAX4ILIVPREIXPJ2GOG3FKV/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/DMIKSVTKNU5FRCUUNAYMCQLOJA3K3S2I/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/M3FQILX7UUEERSDPMZP3MKGTMY2E7ESU/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WBUYGYXDQX3OSAYHP4TCG3JS7PJTIE75/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/albertodemichelis/squirrel/commit/a6413aa690e0bdfef648c68693349a7b878fe60d"}}