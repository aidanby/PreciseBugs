{"buggy_code": ["// Copyright 2012 Google Inc. All Rights Reserved.\n//\n// Use of this source code is governed by a BSD-style license\n// that can be found in the COPYING file in the root of the source\n// tree. An additional intellectual property rights grant can be found\n// in the file PATENTS. All contributing project authors may\n// be found in the AUTHORS file in the root of the source tree.\n// -----------------------------------------------------------------------------\n//\n// main entry for the decoder\n//\n// Authors: Vikas Arora (vikaas.arora@gmail.com)\n//          Jyrki Alakuijala (jyrki@google.com)\n\n#include <assert.h>\n#include <stdlib.h>\n\n#include \"src/dec/alphai_dec.h\"\n#include \"src/dec/vp8li_dec.h\"\n#include \"src/dsp/dsp.h\"\n#include \"src/dsp/lossless.h\"\n#include \"src/dsp/lossless_common.h\"\n#include \"src/dsp/yuv.h\"\n#include \"src/utils/endian_inl_utils.h\"\n#include \"src/utils/huffman_utils.h\"\n#include \"src/utils/utils.h\"\n\n#define NUM_ARGB_CACHE_ROWS          16\n\nstatic const int kCodeLengthLiterals = 16;\nstatic const int kCodeLengthRepeatCode = 16;\nstatic const uint8_t kCodeLengthExtraBits[3] = { 2, 3, 7 };\nstatic const uint8_t kCodeLengthRepeatOffsets[3] = { 3, 3, 11 };\n\n// -----------------------------------------------------------------------------\n//  Five Huffman codes are used at each meta code:\n//  1. green + length prefix codes + color cache codes,\n//  2. alpha,\n//  3. red,\n//  4. blue, and,\n//  5. distance prefix codes.\ntypedef enum {\n  GREEN = 0,\n  RED   = 1,\n  BLUE  = 2,\n  ALPHA = 3,\n  DIST  = 4\n} HuffIndex;\n\nstatic const uint16_t kAlphabetSize[HUFFMAN_CODES_PER_META_CODE] = {\n  NUM_LITERAL_CODES + NUM_LENGTH_CODES,\n  NUM_LITERAL_CODES, NUM_LITERAL_CODES, NUM_LITERAL_CODES,\n  NUM_DISTANCE_CODES\n};\n\nstatic const uint8_t kLiteralMap[HUFFMAN_CODES_PER_META_CODE] = {\n  0, 1, 1, 1, 0\n};\n\n#define NUM_CODE_LENGTH_CODES       19\nstatic const uint8_t kCodeLengthCodeOrder[NUM_CODE_LENGTH_CODES] = {\n  17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\n};\n\n#define CODE_TO_PLANE_CODES        120\nstatic const uint8_t kCodeToPlane[CODE_TO_PLANE_CODES] = {\n  0x18, 0x07, 0x17, 0x19, 0x28, 0x06, 0x27, 0x29, 0x16, 0x1a,\n  0x26, 0x2a, 0x38, 0x05, 0x37, 0x39, 0x15, 0x1b, 0x36, 0x3a,\n  0x25, 0x2b, 0x48, 0x04, 0x47, 0x49, 0x14, 0x1c, 0x35, 0x3b,\n  0x46, 0x4a, 0x24, 0x2c, 0x58, 0x45, 0x4b, 0x34, 0x3c, 0x03,\n  0x57, 0x59, 0x13, 0x1d, 0x56, 0x5a, 0x23, 0x2d, 0x44, 0x4c,\n  0x55, 0x5b, 0x33, 0x3d, 0x68, 0x02, 0x67, 0x69, 0x12, 0x1e,\n  0x66, 0x6a, 0x22, 0x2e, 0x54, 0x5c, 0x43, 0x4d, 0x65, 0x6b,\n  0x32, 0x3e, 0x78, 0x01, 0x77, 0x79, 0x53, 0x5d, 0x11, 0x1f,\n  0x64, 0x6c, 0x42, 0x4e, 0x76, 0x7a, 0x21, 0x2f, 0x75, 0x7b,\n  0x31, 0x3f, 0x63, 0x6d, 0x52, 0x5e, 0x00, 0x74, 0x7c, 0x41,\n  0x4f, 0x10, 0x20, 0x62, 0x6e, 0x30, 0x73, 0x7d, 0x51, 0x5f,\n  0x40, 0x72, 0x7e, 0x61, 0x6f, 0x50, 0x71, 0x7f, 0x60, 0x70\n};\n\n// Memory needed for lookup tables of one Huffman tree group. Red, blue, alpha\n// and distance alphabets are constant (256 for red, blue and alpha, 40 for\n// distance) and lookup table sizes for them in worst case are 630 and 410\n// respectively. Size of green alphabet depends on color cache size and is equal\n// to 256 (green component values) + 24 (length prefix values)\n// + color_cache_size (between 0 and 2048).\n// All values computed for 8-bit first level lookup with Mark Adler's tool:\n// https://github.com/madler/zlib/blob/v1.2.5/examples/enough.c\n#define FIXED_TABLE_SIZE (630 * 3 + 410)\nstatic const uint16_t kTableSize[12] = {\n  FIXED_TABLE_SIZE + 654,\n  FIXED_TABLE_SIZE + 656,\n  FIXED_TABLE_SIZE + 658,\n  FIXED_TABLE_SIZE + 662,\n  FIXED_TABLE_SIZE + 670,\n  FIXED_TABLE_SIZE + 686,\n  FIXED_TABLE_SIZE + 718,\n  FIXED_TABLE_SIZE + 782,\n  FIXED_TABLE_SIZE + 912,\n  FIXED_TABLE_SIZE + 1168,\n  FIXED_TABLE_SIZE + 1680,\n  FIXED_TABLE_SIZE + 2704\n};\n\nstatic int VP8LSetError(VP8LDecoder* const dec, VP8StatusCode error) {\n  // The oldest error reported takes precedence over the new one.\n  if (dec->status_ == VP8_STATUS_OK || dec->status_ == VP8_STATUS_SUSPENDED) {\n    dec->status_ = error;\n  }\n  return 0;\n}\n\nstatic int DecodeImageStream(int xsize, int ysize,\n                             int is_level0,\n                             VP8LDecoder* const dec,\n                             uint32_t** const decoded_data);\n\n//------------------------------------------------------------------------------\n\nint VP8LCheckSignature(const uint8_t* const data, size_t size) {\n  return (size >= VP8L_FRAME_HEADER_SIZE &&\n          data[0] == VP8L_MAGIC_BYTE &&\n          (data[4] >> 5) == 0);  // version\n}\n\nstatic int ReadImageInfo(VP8LBitReader* const br,\n                         int* const width, int* const height,\n                         int* const has_alpha) {\n  if (VP8LReadBits(br, 8) != VP8L_MAGIC_BYTE) return 0;\n  *width = VP8LReadBits(br, VP8L_IMAGE_SIZE_BITS) + 1;\n  *height = VP8LReadBits(br, VP8L_IMAGE_SIZE_BITS) + 1;\n  *has_alpha = VP8LReadBits(br, 1);\n  if (VP8LReadBits(br, VP8L_VERSION_BITS) != 0) return 0;\n  return !br->eos_;\n}\n\nint VP8LGetInfo(const uint8_t* data, size_t data_size,\n                int* const width, int* const height, int* const has_alpha) {\n  if (data == NULL || data_size < VP8L_FRAME_HEADER_SIZE) {\n    return 0;         // not enough data\n  } else if (!VP8LCheckSignature(data, data_size)) {\n    return 0;         // bad signature\n  } else {\n    int w, h, a;\n    VP8LBitReader br;\n    VP8LInitBitReader(&br, data, data_size);\n    if (!ReadImageInfo(&br, &w, &h, &a)) {\n      return 0;\n    }\n    if (width != NULL) *width = w;\n    if (height != NULL) *height = h;\n    if (has_alpha != NULL) *has_alpha = a;\n    return 1;\n  }\n}\n\n//------------------------------------------------------------------------------\n\nstatic WEBP_INLINE int GetCopyDistance(int distance_symbol,\n                                       VP8LBitReader* const br) {\n  int extra_bits, offset;\n  if (distance_symbol < 4) {\n    return distance_symbol + 1;\n  }\n  extra_bits = (distance_symbol - 2) >> 1;\n  offset = (2 + (distance_symbol & 1)) << extra_bits;\n  return offset + VP8LReadBits(br, extra_bits) + 1;\n}\n\nstatic WEBP_INLINE int GetCopyLength(int length_symbol,\n                                     VP8LBitReader* const br) {\n  // Length and distance prefixes are encoded the same way.\n  return GetCopyDistance(length_symbol, br);\n}\n\nstatic WEBP_INLINE int PlaneCodeToDistance(int xsize, int plane_code) {\n  if (plane_code > CODE_TO_PLANE_CODES) {\n    return plane_code - CODE_TO_PLANE_CODES;\n  } else {\n    const int dist_code = kCodeToPlane[plane_code - 1];\n    const int yoffset = dist_code >> 4;\n    const int xoffset = 8 - (dist_code & 0xf);\n    const int dist = yoffset * xsize + xoffset;\n    return (dist >= 1) ? dist : 1;  // dist<1 can happen if xsize is very small\n  }\n}\n\n//------------------------------------------------------------------------------\n// Decodes the next Huffman code from bit-stream.\n// VP8LFillBitWindow(br) needs to be called at minimum every second call\n// to ReadSymbol, in order to pre-fetch enough bits.\nstatic WEBP_INLINE int ReadSymbol(const HuffmanCode* table,\n                                  VP8LBitReader* const br) {\n  int nbits;\n  uint32_t val = VP8LPrefetchBits(br);\n  table += val & HUFFMAN_TABLE_MASK;\n  nbits = table->bits - HUFFMAN_TABLE_BITS;\n  if (nbits > 0) {\n    VP8LSetBitPos(br, br->bit_pos_ + HUFFMAN_TABLE_BITS);\n    val = VP8LPrefetchBits(br);\n    table += table->value;\n    table += val & ((1 << nbits) - 1);\n  }\n  VP8LSetBitPos(br, br->bit_pos_ + table->bits);\n  return table->value;\n}\n\n// Reads packed symbol depending on GREEN channel\n#define BITS_SPECIAL_MARKER 0x100  // something large enough (and a bit-mask)\n#define PACKED_NON_LITERAL_CODE 0  // must be < NUM_LITERAL_CODES\nstatic WEBP_INLINE int ReadPackedSymbols(const HTreeGroup* group,\n                                         VP8LBitReader* const br,\n                                         uint32_t* const dst) {\n  const uint32_t val = VP8LPrefetchBits(br) & (HUFFMAN_PACKED_TABLE_SIZE - 1);\n  const HuffmanCode32 code = group->packed_table[val];\n  assert(group->use_packed_table);\n  if (code.bits < BITS_SPECIAL_MARKER) {\n    VP8LSetBitPos(br, br->bit_pos_ + code.bits);\n    *dst = code.value;\n    return PACKED_NON_LITERAL_CODE;\n  } else {\n    VP8LSetBitPos(br, br->bit_pos_ + code.bits - BITS_SPECIAL_MARKER);\n    assert(code.value >= NUM_LITERAL_CODES);\n    return code.value;\n  }\n}\n\nstatic int AccumulateHCode(HuffmanCode hcode, int shift,\n                           HuffmanCode32* const huff) {\n  huff->bits += hcode.bits;\n  huff->value |= (uint32_t)hcode.value << shift;\n  assert(huff->bits <= HUFFMAN_TABLE_BITS);\n  return hcode.bits;\n}\n\nstatic void BuildPackedTable(HTreeGroup* const htree_group) {\n  uint32_t code;\n  for (code = 0; code < HUFFMAN_PACKED_TABLE_SIZE; ++code) {\n    uint32_t bits = code;\n    HuffmanCode32* const huff = &htree_group->packed_table[bits];\n    HuffmanCode hcode = htree_group->htrees[GREEN][bits];\n    if (hcode.value >= NUM_LITERAL_CODES) {\n      huff->bits = hcode.bits + BITS_SPECIAL_MARKER;\n      huff->value = hcode.value;\n    } else {\n      huff->bits = 0;\n      huff->value = 0;\n      bits >>= AccumulateHCode(hcode, 8, huff);\n      bits >>= AccumulateHCode(htree_group->htrees[RED][bits], 16, huff);\n      bits >>= AccumulateHCode(htree_group->htrees[BLUE][bits], 0, huff);\n      bits >>= AccumulateHCode(htree_group->htrees[ALPHA][bits], 24, huff);\n      (void)bits;\n    }\n  }\n}\n\nstatic int ReadHuffmanCodeLengths(\n    VP8LDecoder* const dec, const int* const code_length_code_lengths,\n    int num_symbols, int* const code_lengths) {\n  int ok = 0;\n  VP8LBitReader* const br = &dec->br_;\n  int symbol;\n  int max_symbol;\n  int prev_code_len = DEFAULT_CODE_LENGTH;\n  HuffmanCode table[1 << LENGTHS_TABLE_BITS];\n\n  if (!VP8LBuildHuffmanTable(table, LENGTHS_TABLE_BITS,\n                             code_length_code_lengths,\n                             NUM_CODE_LENGTH_CODES)) {\n    goto End;\n  }\n\n  if (VP8LReadBits(br, 1)) {    // use length\n    const int length_nbits = 2 + 2 * VP8LReadBits(br, 3);\n    max_symbol = 2 + VP8LReadBits(br, length_nbits);\n    if (max_symbol > num_symbols) {\n      goto End;\n    }\n  } else {\n    max_symbol = num_symbols;\n  }\n\n  symbol = 0;\n  while (symbol < num_symbols) {\n    const HuffmanCode* p;\n    int code_len;\n    if (max_symbol-- == 0) break;\n    VP8LFillBitWindow(br);\n    p = &table[VP8LPrefetchBits(br) & LENGTHS_TABLE_MASK];\n    VP8LSetBitPos(br, br->bit_pos_ + p->bits);\n    code_len = p->value;\n    if (code_len < kCodeLengthLiterals) {\n      code_lengths[symbol++] = code_len;\n      if (code_len != 0) prev_code_len = code_len;\n    } else {\n      const int use_prev = (code_len == kCodeLengthRepeatCode);\n      const int slot = code_len - kCodeLengthLiterals;\n      const int extra_bits = kCodeLengthExtraBits[slot];\n      const int repeat_offset = kCodeLengthRepeatOffsets[slot];\n      int repeat = VP8LReadBits(br, extra_bits) + repeat_offset;\n      if (symbol + repeat > num_symbols) {\n        goto End;\n      } else {\n        const int length = use_prev ? prev_code_len : 0;\n        while (repeat-- > 0) code_lengths[symbol++] = length;\n      }\n    }\n  }\n  ok = 1;\n\n End:\n  if (!ok) return VP8LSetError(dec, VP8_STATUS_BITSTREAM_ERROR);\n  return ok;\n}\n\n// 'code_lengths' is pre-allocated temporary buffer, used for creating Huffman\n// tree.\nstatic int ReadHuffmanCode(int alphabet_size, VP8LDecoder* const dec,\n                           int* const code_lengths, HuffmanCode* const table) {\n  int ok = 0;\n  int size = 0;\n  VP8LBitReader* const br = &dec->br_;\n  const int simple_code = VP8LReadBits(br, 1);\n\n  memset(code_lengths, 0, alphabet_size * sizeof(*code_lengths));\n\n  if (simple_code) {  // Read symbols, codes & code lengths directly.\n    const int num_symbols = VP8LReadBits(br, 1) + 1;\n    const int first_symbol_len_code = VP8LReadBits(br, 1);\n    // The first code is either 1 bit or 8 bit code.\n    int symbol = VP8LReadBits(br, (first_symbol_len_code == 0) ? 1 : 8);\n    code_lengths[symbol] = 1;\n    // The second code (if present), is always 8 bits long.\n    if (num_symbols == 2) {\n      symbol = VP8LReadBits(br, 8);\n      code_lengths[symbol] = 1;\n    }\n    ok = 1;\n  } else {  // Decode Huffman-coded code lengths.\n    int i;\n    int code_length_code_lengths[NUM_CODE_LENGTH_CODES] = { 0 };\n    const int num_codes = VP8LReadBits(br, 4) + 4;\n    assert(num_codes <= NUM_CODE_LENGTH_CODES);\n\n    for (i = 0; i < num_codes; ++i) {\n      code_length_code_lengths[kCodeLengthCodeOrder[i]] = VP8LReadBits(br, 3);\n    }\n    ok = ReadHuffmanCodeLengths(dec, code_length_code_lengths, alphabet_size,\n                                code_lengths);\n  }\n\n  ok = ok && !br->eos_;\n  if (ok) {\n    size = VP8LBuildHuffmanTable(table, HUFFMAN_TABLE_BITS,\n                                 code_lengths, alphabet_size);\n  }\n  if (!ok || size == 0) {\n    return VP8LSetError(dec, VP8_STATUS_BITSTREAM_ERROR);\n  }\n  return size;\n}\n\nstatic int ReadHuffmanCodes(VP8LDecoder* const dec, int xsize, int ysize,\n                            int color_cache_bits, int allow_recursion) {\n  int i, j;\n  VP8LBitReader* const br = &dec->br_;\n  VP8LMetadata* const hdr = &dec->hdr_;\n  uint32_t* huffman_image = NULL;\n  HTreeGroup* htree_groups = NULL;\n  HuffmanCode* huffman_tables = NULL;\n  HuffmanCode* huffman_table = NULL;\n  int num_htree_groups = 1;\n  int num_htree_groups_max = 1;\n  const int max_alphabet_size =\n      kAlphabetSize[0] + ((color_cache_bits > 0) ? 1 << color_cache_bits : 0);\n  int* code_lengths = NULL;\n  const int table_size = kTableSize[color_cache_bits];\n  int* mapping = NULL;\n  int ok = 0;\n\n  if (allow_recursion && VP8LReadBits(br, 1)) {\n    // use meta Huffman codes.\n    const int huffman_precision = VP8LReadBits(br, 3) + 2;\n    const int huffman_xsize = VP8LSubSampleSize(xsize, huffman_precision);\n    const int huffman_ysize = VP8LSubSampleSize(ysize, huffman_precision);\n    const int huffman_pixs = huffman_xsize * huffman_ysize;\n    if (!DecodeImageStream(huffman_xsize, huffman_ysize, /*is_level0=*/0, dec,\n                           &huffman_image)) {\n      goto Error;\n    }\n    hdr->huffman_subsample_bits_ = huffman_precision;\n    for (i = 0; i < huffman_pixs; ++i) {\n      // The huffman data is stored in red and green bytes.\n      const int group = (huffman_image[i] >> 8) & 0xffff;\n      huffman_image[i] = group;\n      if (group >= num_htree_groups_max) {\n        num_htree_groups_max = group + 1;\n      }\n    }\n    // Check the validity of num_htree_groups_max. If it seems too big, use a\n    // smaller value for later. This will prevent big memory allocations to end\n    // up with a bad bitstream anyway.\n    // The value of 1000 is totally arbitrary. We know that num_htree_groups_max\n    // is smaller than (1 << 16) and should be smaller than the number of pixels\n    // (though the format allows it to be bigger).\n    if (num_htree_groups_max > 1000 || num_htree_groups_max > xsize * ysize) {\n      // Create a mapping from the used indices to the minimal set of used\n      // values [0, num_htree_groups)\n      mapping = (int*)WebPSafeMalloc(num_htree_groups_max, sizeof(*mapping));\n      if (mapping == NULL) {\n        VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);\n        goto Error;\n      }\n      // -1 means a value is unmapped, and therefore unused in the Huffman\n      // image.\n      memset(mapping, 0xff, num_htree_groups_max * sizeof(*mapping));\n      for (num_htree_groups = 0, i = 0; i < huffman_pixs; ++i) {\n        // Get the current mapping for the group and remap the Huffman image.\n        int* const mapped_group = &mapping[huffman_image[i]];\n        if (*mapped_group == -1) *mapped_group = num_htree_groups++;\n        huffman_image[i] = *mapped_group;\n      }\n    } else {\n      num_htree_groups = num_htree_groups_max;\n    }\n  }\n\n  if (br->eos_) goto Error;\n\n  code_lengths = (int*)WebPSafeCalloc((uint64_t)max_alphabet_size,\n                                      sizeof(*code_lengths));\n  huffman_tables = (HuffmanCode*)WebPSafeMalloc(num_htree_groups * table_size,\n                                                sizeof(*huffman_tables));\n  htree_groups = VP8LHtreeGroupsNew(num_htree_groups);\n\n  if (htree_groups == NULL || code_lengths == NULL || huffman_tables == NULL) {\n    VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);\n    goto Error;\n  }\n\n  huffman_table = huffman_tables;\n  for (i = 0; i < num_htree_groups_max; ++i) {\n    // If the index \"i\" is unused in the Huffman image, just make sure the\n    // coefficients are valid but do not store them.\n    if (mapping != NULL && mapping[i] == -1) {\n      for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; ++j) {\n        int alphabet_size = kAlphabetSize[j];\n        if (j == 0 && color_cache_bits > 0) {\n          alphabet_size += (1 << color_cache_bits);\n        }\n        // Passing in NULL so that nothing gets filled.\n        if (!ReadHuffmanCode(alphabet_size, dec, code_lengths, NULL)) {\n          goto Error;\n        }\n      }\n    } else {\n      HTreeGroup* const htree_group =\n          &htree_groups[(mapping == NULL) ? i : mapping[i]];\n      HuffmanCode** const htrees = htree_group->htrees;\n      int size;\n      int total_size = 0;\n      int is_trivial_literal = 1;\n      int max_bits = 0;\n      for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; ++j) {\n        int alphabet_size = kAlphabetSize[j];\n        htrees[j] = huffman_table;\n        if (j == 0 && color_cache_bits > 0) {\n          alphabet_size += (1 << color_cache_bits);\n        }\n        size = ReadHuffmanCode(alphabet_size, dec, code_lengths, huffman_table);\n        if (size == 0) {\n          goto Error;\n        }\n        if (is_trivial_literal && kLiteralMap[j] == 1) {\n          is_trivial_literal = (huffman_table->bits == 0);\n        }\n        total_size += huffman_table->bits;\n        huffman_table += size;\n        if (j <= ALPHA) {\n          int local_max_bits = code_lengths[0];\n          int k;\n          for (k = 1; k < alphabet_size; ++k) {\n            if (code_lengths[k] > local_max_bits) {\n              local_max_bits = code_lengths[k];\n            }\n          }\n          max_bits += local_max_bits;\n        }\n      }\n      htree_group->is_trivial_literal = is_trivial_literal;\n      htree_group->is_trivial_code = 0;\n      if (is_trivial_literal) {\n        const int red = htrees[RED][0].value;\n        const int blue = htrees[BLUE][0].value;\n        const int alpha = htrees[ALPHA][0].value;\n        htree_group->literal_arb = ((uint32_t)alpha << 24) | (red << 16) | blue;\n        if (total_size == 0 && htrees[GREEN][0].value < NUM_LITERAL_CODES) {\n          htree_group->is_trivial_code = 1;\n          htree_group->literal_arb |= htrees[GREEN][0].value << 8;\n        }\n      }\n      htree_group->use_packed_table =\n          !htree_group->is_trivial_code && (max_bits < HUFFMAN_PACKED_BITS);\n      if (htree_group->use_packed_table) BuildPackedTable(htree_group);\n    }\n  }\n  ok = 1;\n\n  // All OK. Finalize pointers.\n  hdr->huffman_image_ = huffman_image;\n  hdr->num_htree_groups_ = num_htree_groups;\n  hdr->htree_groups_ = htree_groups;\n  hdr->huffman_tables_ = huffman_tables;\n\n Error:\n  WebPSafeFree(code_lengths);\n  WebPSafeFree(mapping);\n  if (!ok) {\n    WebPSafeFree(huffman_image);\n    WebPSafeFree(huffman_tables);\n    VP8LHtreeGroupsFree(htree_groups);\n  }\n  return ok;\n}\n\n//------------------------------------------------------------------------------\n// Scaling.\n\n#if !defined(WEBP_REDUCE_SIZE)\nstatic int AllocateAndInitRescaler(VP8LDecoder* const dec, VP8Io* const io) {\n  const int num_channels = 4;\n  const int in_width = io->mb_w;\n  const int out_width = io->scaled_width;\n  const int in_height = io->mb_h;\n  const int out_height = io->scaled_height;\n  const uint64_t work_size = 2 * num_channels * (uint64_t)out_width;\n  rescaler_t* work;        // Rescaler work area.\n  const uint64_t scaled_data_size = (uint64_t)out_width;\n  uint32_t* scaled_data;  // Temporary storage for scaled BGRA data.\n  const uint64_t memory_size = sizeof(*dec->rescaler) +\n                               work_size * sizeof(*work) +\n                               scaled_data_size * sizeof(*scaled_data);\n  uint8_t* memory = (uint8_t*)WebPSafeMalloc(memory_size, sizeof(*memory));\n  if (memory == NULL) {\n    return VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);\n  }\n  assert(dec->rescaler_memory == NULL);\n  dec->rescaler_memory = memory;\n\n  dec->rescaler = (WebPRescaler*)memory;\n  memory += sizeof(*dec->rescaler);\n  work = (rescaler_t*)memory;\n  memory += work_size * sizeof(*work);\n  scaled_data = (uint32_t*)memory;\n\n  if (!WebPRescalerInit(dec->rescaler, in_width, in_height,\n                        (uint8_t*)scaled_data, out_width, out_height,\n                        0, num_channels, work)) {\n    return 0;\n  }\n  return 1;\n}\n#endif   // WEBP_REDUCE_SIZE\n\n//------------------------------------------------------------------------------\n// Export to ARGB\n\n#if !defined(WEBP_REDUCE_SIZE)\n\n// We have special \"export\" function since we need to convert from BGRA\nstatic int Export(WebPRescaler* const rescaler, WEBP_CSP_MODE colorspace,\n                  int rgba_stride, uint8_t* const rgba) {\n  uint32_t* const src = (uint32_t*)rescaler->dst;\n  uint8_t* dst = rgba;\n  const int dst_width = rescaler->dst_width;\n  int num_lines_out = 0;\n  while (WebPRescalerHasPendingOutput(rescaler)) {\n    WebPRescalerExportRow(rescaler);\n    WebPMultARGBRow(src, dst_width, 1);\n    VP8LConvertFromBGRA(src, dst_width, colorspace, dst);\n    dst += rgba_stride;\n    ++num_lines_out;\n  }\n  return num_lines_out;\n}\n\n// Emit scaled rows.\nstatic int EmitRescaledRowsRGBA(const VP8LDecoder* const dec,\n                                uint8_t* in, int in_stride, int mb_h,\n                                uint8_t* const out, int out_stride) {\n  const WEBP_CSP_MODE colorspace = dec->output_->colorspace;\n  int num_lines_in = 0;\n  int num_lines_out = 0;\n  while (num_lines_in < mb_h) {\n    uint8_t* const row_in = in + (uint64_t)num_lines_in * in_stride;\n    uint8_t* const row_out = out + (uint64_t)num_lines_out * out_stride;\n    const int lines_left = mb_h - num_lines_in;\n    const int needed_lines = WebPRescaleNeededLines(dec->rescaler, lines_left);\n    int lines_imported;\n    assert(needed_lines > 0 && needed_lines <= lines_left);\n    WebPMultARGBRows(row_in, in_stride,\n                     dec->rescaler->src_width, needed_lines, 0);\n    lines_imported =\n        WebPRescalerImport(dec->rescaler, lines_left, row_in, in_stride);\n    assert(lines_imported == needed_lines);\n    num_lines_in += lines_imported;\n    num_lines_out += Export(dec->rescaler, colorspace, out_stride, row_out);\n  }\n  return num_lines_out;\n}\n\n#endif   // WEBP_REDUCE_SIZE\n\n// Emit rows without any scaling.\nstatic int EmitRows(WEBP_CSP_MODE colorspace,\n                    const uint8_t* row_in, int in_stride,\n                    int mb_w, int mb_h,\n                    uint8_t* const out, int out_stride) {\n  int lines = mb_h;\n  uint8_t* row_out = out;\n  while (lines-- > 0) {\n    VP8LConvertFromBGRA((const uint32_t*)row_in, mb_w, colorspace, row_out);\n    row_in += in_stride;\n    row_out += out_stride;\n  }\n  return mb_h;  // Num rows out == num rows in.\n}\n\n//------------------------------------------------------------------------------\n// Export to YUVA\n\nstatic void ConvertToYUVA(const uint32_t* const src, int width, int y_pos,\n                          const WebPDecBuffer* const output) {\n  const WebPYUVABuffer* const buf = &output->u.YUVA;\n\n  // first, the luma plane\n  WebPConvertARGBToY(src, buf->y + y_pos * buf->y_stride, width);\n\n  // then U/V planes\n  {\n    uint8_t* const u = buf->u + (y_pos >> 1) * buf->u_stride;\n    uint8_t* const v = buf->v + (y_pos >> 1) * buf->v_stride;\n    // even lines: store values\n    // odd lines: average with previous values\n    WebPConvertARGBToUV(src, u, v, width, !(y_pos & 1));\n  }\n  // Lastly, store alpha if needed.\n  if (buf->a != NULL) {\n    uint8_t* const a = buf->a + y_pos * buf->a_stride;\n#if defined(WORDS_BIGENDIAN)\n    WebPExtractAlpha((uint8_t*)src + 0, 0, width, 1, a, 0);\n#else\n    WebPExtractAlpha((uint8_t*)src + 3, 0, width, 1, a, 0);\n#endif\n  }\n}\n\nstatic int ExportYUVA(const VP8LDecoder* const dec, int y_pos) {\n  WebPRescaler* const rescaler = dec->rescaler;\n  uint32_t* const src = (uint32_t*)rescaler->dst;\n  const int dst_width = rescaler->dst_width;\n  int num_lines_out = 0;\n  while (WebPRescalerHasPendingOutput(rescaler)) {\n    WebPRescalerExportRow(rescaler);\n    WebPMultARGBRow(src, dst_width, 1);\n    ConvertToYUVA(src, dst_width, y_pos, dec->output_);\n    ++y_pos;\n    ++num_lines_out;\n  }\n  return num_lines_out;\n}\n\nstatic int EmitRescaledRowsYUVA(const VP8LDecoder* const dec,\n                                uint8_t* in, int in_stride, int mb_h) {\n  int num_lines_in = 0;\n  int y_pos = dec->last_out_row_;\n  while (num_lines_in < mb_h) {\n    const int lines_left = mb_h - num_lines_in;\n    const int needed_lines = WebPRescaleNeededLines(dec->rescaler, lines_left);\n    int lines_imported;\n    WebPMultARGBRows(in, in_stride, dec->rescaler->src_width, needed_lines, 0);\n    lines_imported =\n        WebPRescalerImport(dec->rescaler, lines_left, in, in_stride);\n    assert(lines_imported == needed_lines);\n    num_lines_in += lines_imported;\n    in += needed_lines * in_stride;\n    y_pos += ExportYUVA(dec, y_pos);\n  }\n  return y_pos;\n}\n\nstatic int EmitRowsYUVA(const VP8LDecoder* const dec,\n                        const uint8_t* in, int in_stride,\n                        int mb_w, int num_rows) {\n  int y_pos = dec->last_out_row_;\n  while (num_rows-- > 0) {\n    ConvertToYUVA((const uint32_t*)in, mb_w, y_pos, dec->output_);\n    in += in_stride;\n    ++y_pos;\n  }\n  return y_pos;\n}\n\n//------------------------------------------------------------------------------\n// Cropping.\n\n// Sets io->mb_y, io->mb_h & io->mb_w according to start row, end row and\n// crop options. Also updates the input data pointer, so that it points to the\n// start of the cropped window. Note that pixels are in ARGB format even if\n// 'in_data' is uint8_t*.\n// Returns true if the crop window is not empty.\nstatic int SetCropWindow(VP8Io* const io, int y_start, int y_end,\n                         uint8_t** const in_data, int pixel_stride) {\n  assert(y_start < y_end);\n  assert(io->crop_left < io->crop_right);\n  if (y_end > io->crop_bottom) {\n    y_end = io->crop_bottom;  // make sure we don't overflow on last row.\n  }\n  if (y_start < io->crop_top) {\n    const int delta = io->crop_top - y_start;\n    y_start = io->crop_top;\n    *in_data += delta * pixel_stride;\n  }\n  if (y_start >= y_end) return 0;  // Crop window is empty.\n\n  *in_data += io->crop_left * sizeof(uint32_t);\n\n  io->mb_y = y_start - io->crop_top;\n  io->mb_w = io->crop_right - io->crop_left;\n  io->mb_h = y_end - y_start;\n  return 1;  // Non-empty crop window.\n}\n\n//------------------------------------------------------------------------------\n\nstatic WEBP_INLINE int GetMetaIndex(\n    const uint32_t* const image, int xsize, int bits, int x, int y) {\n  if (bits == 0) return 0;\n  return image[xsize * (y >> bits) + (x >> bits)];\n}\n\nstatic WEBP_INLINE HTreeGroup* GetHtreeGroupForPos(VP8LMetadata* const hdr,\n                                                   int x, int y) {\n  const int meta_index = GetMetaIndex(hdr->huffman_image_, hdr->huffman_xsize_,\n                                      hdr->huffman_subsample_bits_, x, y);\n  assert(meta_index < hdr->num_htree_groups_);\n  return hdr->htree_groups_ + meta_index;\n}\n\n//------------------------------------------------------------------------------\n// Main loop, with custom row-processing function\n\ntypedef void (*ProcessRowsFunc)(VP8LDecoder* const dec, int row);\n\nstatic void ApplyInverseTransforms(VP8LDecoder* const dec,\n                                   int start_row, int num_rows,\n                                   const uint32_t* const rows) {\n  int n = dec->next_transform_;\n  const int cache_pixs = dec->width_ * num_rows;\n  const int end_row = start_row + num_rows;\n  const uint32_t* rows_in = rows;\n  uint32_t* const rows_out = dec->argb_cache_;\n\n  // Inverse transforms.\n  while (n-- > 0) {\n    VP8LTransform* const transform = &dec->transforms_[n];\n    VP8LInverseTransform(transform, start_row, end_row, rows_in, rows_out);\n    rows_in = rows_out;\n  }\n  if (rows_in != rows_out) {\n    // No transform called, hence just copy.\n    memcpy(rows_out, rows_in, cache_pixs * sizeof(*rows_out));\n  }\n}\n\n// Processes (transforms, scales & color-converts) the rows decoded after the\n// last call.\nstatic void ProcessRows(VP8LDecoder* const dec, int row) {\n  const uint32_t* const rows = dec->pixels_ + dec->width_ * dec->last_row_;\n  const int num_rows = row - dec->last_row_;\n\n  assert(row <= dec->io_->crop_bottom);\n  // We can't process more than NUM_ARGB_CACHE_ROWS at a time (that's the size\n  // of argb_cache_), but we currently don't need more than that.\n  assert(num_rows <= NUM_ARGB_CACHE_ROWS);\n  if (num_rows > 0) {    // Emit output.\n    VP8Io* const io = dec->io_;\n    uint8_t* rows_data = (uint8_t*)dec->argb_cache_;\n    const int in_stride = io->width * sizeof(uint32_t);  // in unit of RGBA\n    ApplyInverseTransforms(dec, dec->last_row_, num_rows, rows);\n    if (!SetCropWindow(io, dec->last_row_, row, &rows_data, in_stride)) {\n      // Nothing to output (this time).\n    } else {\n      const WebPDecBuffer* const output = dec->output_;\n      if (WebPIsRGBMode(output->colorspace)) {  // convert to RGBA\n        const WebPRGBABuffer* const buf = &output->u.RGBA;\n        uint8_t* const rgba =\n            buf->rgba + (int64_t)dec->last_out_row_ * buf->stride;\n        const int num_rows_out =\n#if !defined(WEBP_REDUCE_SIZE)\n         io->use_scaling ?\n            EmitRescaledRowsRGBA(dec, rows_data, in_stride, io->mb_h,\n                                 rgba, buf->stride) :\n#endif  // WEBP_REDUCE_SIZE\n            EmitRows(output->colorspace, rows_data, in_stride,\n                     io->mb_w, io->mb_h, rgba, buf->stride);\n        // Update 'last_out_row_'.\n        dec->last_out_row_ += num_rows_out;\n      } else {                              // convert to YUVA\n        dec->last_out_row_ = io->use_scaling ?\n            EmitRescaledRowsYUVA(dec, rows_data, in_stride, io->mb_h) :\n            EmitRowsYUVA(dec, rows_data, in_stride, io->mb_w, io->mb_h);\n      }\n      assert(dec->last_out_row_ <= output->height);\n    }\n  }\n\n  // Update 'last_row_'.\n  dec->last_row_ = row;\n  assert(dec->last_row_ <= dec->height_);\n}\n\n// Row-processing for the special case when alpha data contains only one\n// transform (color indexing), and trivial non-green literals.\nstatic int Is8bOptimizable(const VP8LMetadata* const hdr) {\n  int i;\n  if (hdr->color_cache_size_ > 0) return 0;\n  // When the Huffman tree contains only one symbol, we can skip the\n  // call to ReadSymbol() for red/blue/alpha channels.\n  for (i = 0; i < hdr->num_htree_groups_; ++i) {\n    HuffmanCode** const htrees = hdr->htree_groups_[i].htrees;\n    if (htrees[RED][0].bits > 0) return 0;\n    if (htrees[BLUE][0].bits > 0) return 0;\n    if (htrees[ALPHA][0].bits > 0) return 0;\n  }\n  return 1;\n}\n\nstatic void AlphaApplyFilter(ALPHDecoder* const alph_dec,\n                             int first_row, int last_row,\n                             uint8_t* out, int stride) {\n  if (alph_dec->filter_ != WEBP_FILTER_NONE) {\n    int y;\n    const uint8_t* prev_line = alph_dec->prev_line_;\n    assert(WebPUnfilters[alph_dec->filter_] != NULL);\n    for (y = first_row; y < last_row; ++y) {\n      WebPUnfilters[alph_dec->filter_](prev_line, out, out, stride);\n      prev_line = out;\n      out += stride;\n    }\n    alph_dec->prev_line_ = prev_line;\n  }\n}\n\nstatic void ExtractPalettedAlphaRows(VP8LDecoder* const dec, int last_row) {\n  // For vertical and gradient filtering, we need to decode the part above the\n  // crop_top row, in order to have the correct spatial predictors.\n  ALPHDecoder* const alph_dec = (ALPHDecoder*)dec->io_->opaque;\n  const int top_row =\n      (alph_dec->filter_ == WEBP_FILTER_NONE ||\n       alph_dec->filter_ == WEBP_FILTER_HORIZONTAL) ? dec->io_->crop_top\n                                                    : dec->last_row_;\n  const int first_row = (dec->last_row_ < top_row) ? top_row : dec->last_row_;\n  assert(last_row <= dec->io_->crop_bottom);\n  if (last_row > first_row) {\n    // Special method for paletted alpha data. We only process the cropped area.\n    const int width = dec->io_->width;\n    uint8_t* out = alph_dec->output_ + width * first_row;\n    const uint8_t* const in =\n      (uint8_t*)dec->pixels_ + dec->width_ * first_row;\n    VP8LTransform* const transform = &dec->transforms_[0];\n    assert(dec->next_transform_ == 1);\n    assert(transform->type_ == COLOR_INDEXING_TRANSFORM);\n    VP8LColorIndexInverseTransformAlpha(transform, first_row, last_row,\n                                        in, out);\n    AlphaApplyFilter(alph_dec, first_row, last_row, out, width);\n  }\n  dec->last_row_ = dec->last_out_row_ = last_row;\n}\n\n//------------------------------------------------------------------------------\n// Helper functions for fast pattern copy (8b and 32b)\n\n// cyclic rotation of pattern word\nstatic WEBP_INLINE uint32_t Rotate8b(uint32_t V) {\n#if defined(WORDS_BIGENDIAN)\n  return ((V & 0xff000000u) >> 24) | (V << 8);\n#else\n  return ((V & 0xffu) << 24) | (V >> 8);\n#endif\n}\n\n// copy 1, 2 or 4-bytes pattern\nstatic WEBP_INLINE void CopySmallPattern8b(const uint8_t* src, uint8_t* dst,\n                                           int length, uint32_t pattern) {\n  int i;\n  // align 'dst' to 4-bytes boundary. Adjust the pattern along the way.\n  while ((uintptr_t)dst & 3) {\n    *dst++ = *src++;\n    pattern = Rotate8b(pattern);\n    --length;\n  }\n  // Copy the pattern 4 bytes at a time.\n  for (i = 0; i < (length >> 2); ++i) {\n    ((uint32_t*)dst)[i] = pattern;\n  }\n  // Finish with left-overs. 'pattern' is still correctly positioned,\n  // so no Rotate8b() call is needed.\n  for (i <<= 2; i < length; ++i) {\n    dst[i] = src[i];\n  }\n}\n\nstatic WEBP_INLINE void CopyBlock8b(uint8_t* const dst, int dist, int length) {\n  const uint8_t* src = dst - dist;\n  if (length >= 8) {\n    uint32_t pattern = 0;\n    switch (dist) {\n      case 1:\n        pattern = src[0];\n#if defined(__arm__) || defined(_M_ARM)   // arm doesn't like multiply that much\n        pattern |= pattern << 8;\n        pattern |= pattern << 16;\n#elif defined(WEBP_USE_MIPS_DSP_R2)\n        __asm__ volatile (\"replv.qb %0, %0\" : \"+r\"(pattern));\n#else\n        pattern = 0x01010101u * pattern;\n#endif\n        break;\n      case 2:\n#if !defined(WORDS_BIGENDIAN)\n        memcpy(&pattern, src, sizeof(uint16_t));\n#else\n        pattern = ((uint32_t)src[0] << 8) | src[1];\n#endif\n#if defined(__arm__) || defined(_M_ARM)\n        pattern |= pattern << 16;\n#elif defined(WEBP_USE_MIPS_DSP_R2)\n        __asm__ volatile (\"replv.ph %0, %0\" : \"+r\"(pattern));\n#else\n        pattern = 0x00010001u * pattern;\n#endif\n        break;\n      case 4:\n        memcpy(&pattern, src, sizeof(uint32_t));\n        break;\n      default:\n        goto Copy;\n    }\n    CopySmallPattern8b(src, dst, length, pattern);\n    return;\n  }\n Copy:\n  if (dist >= length) {  // no overlap -> use memcpy()\n    memcpy(dst, src, length * sizeof(*dst));\n  } else {\n    int i;\n    for (i = 0; i < length; ++i) dst[i] = src[i];\n  }\n}\n\n// copy pattern of 1 or 2 uint32_t's\nstatic WEBP_INLINE void CopySmallPattern32b(const uint32_t* src,\n                                            uint32_t* dst,\n                                            int length, uint64_t pattern) {\n  int i;\n  if ((uintptr_t)dst & 4) {           // Align 'dst' to 8-bytes boundary.\n    *dst++ = *src++;\n    pattern = (pattern >> 32) | (pattern << 32);\n    --length;\n  }\n  assert(0 == ((uintptr_t)dst & 7));\n  for (i = 0; i < (length >> 1); ++i) {\n    ((uint64_t*)dst)[i] = pattern;    // Copy the pattern 8 bytes at a time.\n  }\n  if (length & 1) {                   // Finish with left-over.\n    dst[i << 1] = src[i << 1];\n  }\n}\n\nstatic WEBP_INLINE void CopyBlock32b(uint32_t* const dst,\n                                     int dist, int length) {\n  const uint32_t* const src = dst - dist;\n  if (dist <= 2 && length >= 4 && ((uintptr_t)dst & 3) == 0) {\n    uint64_t pattern;\n    if (dist == 1) {\n      pattern = (uint64_t)src[0];\n      pattern |= pattern << 32;\n    } else {\n      memcpy(&pattern, src, sizeof(pattern));\n    }\n    CopySmallPattern32b(src, dst, length, pattern);\n  } else if (dist >= length) {  // no overlap\n    memcpy(dst, src, length * sizeof(*dst));\n  } else {\n    int i;\n    for (i = 0; i < length; ++i) dst[i] = src[i];\n  }\n}\n\n//------------------------------------------------------------------------------\n\nstatic int DecodeAlphaData(VP8LDecoder* const dec, uint8_t* const data,\n                           int width, int height, int last_row) {\n  int ok = 1;\n  int row = dec->last_pixel_ / width;\n  int col = dec->last_pixel_ % width;\n  VP8LBitReader* const br = &dec->br_;\n  VP8LMetadata* const hdr = &dec->hdr_;\n  int pos = dec->last_pixel_;         // current position\n  const int end = width * height;     // End of data\n  const int last = width * last_row;  // Last pixel to decode\n  const int len_code_limit = NUM_LITERAL_CODES + NUM_LENGTH_CODES;\n  const int mask = hdr->huffman_mask_;\n  const HTreeGroup* htree_group =\n      (pos < last) ? GetHtreeGroupForPos(hdr, col, row) : NULL;\n  assert(pos <= end);\n  assert(last_row <= height);\n  assert(Is8bOptimizable(hdr));\n\n  while (!br->eos_ && pos < last) {\n    int code;\n    // Only update when changing tile.\n    if ((col & mask) == 0) {\n      htree_group = GetHtreeGroupForPos(hdr, col, row);\n    }\n    assert(htree_group != NULL);\n    VP8LFillBitWindow(br);\n    code = ReadSymbol(htree_group->htrees[GREEN], br);\n    if (code < NUM_LITERAL_CODES) {  // Literal\n      data[pos] = code;\n      ++pos;\n      ++col;\n      if (col >= width) {\n        col = 0;\n        ++row;\n        if (row <= last_row && (row % NUM_ARGB_CACHE_ROWS == 0)) {\n          ExtractPalettedAlphaRows(dec, row);\n        }\n      }\n    } else if (code < len_code_limit) {  // Backward reference\n      int dist_code, dist;\n      const int length_sym = code - NUM_LITERAL_CODES;\n      const int length = GetCopyLength(length_sym, br);\n      const int dist_symbol = ReadSymbol(htree_group->htrees[DIST], br);\n      VP8LFillBitWindow(br);\n      dist_code = GetCopyDistance(dist_symbol, br);\n      dist = PlaneCodeToDistance(width, dist_code);\n      if (pos >= dist && end - pos >= length) {\n        CopyBlock8b(data + pos, dist, length);\n      } else {\n        ok = 0;\n        goto End;\n      }\n      pos += length;\n      col += length;\n      while (col >= width) {\n        col -= width;\n        ++row;\n        if (row <= last_row && (row % NUM_ARGB_CACHE_ROWS == 0)) {\n          ExtractPalettedAlphaRows(dec, row);\n        }\n      }\n      if (pos < last && (col & mask)) {\n        htree_group = GetHtreeGroupForPos(hdr, col, row);\n      }\n    } else {  // Not reached\n      ok = 0;\n      goto End;\n    }\n    br->eos_ = VP8LIsEndOfStream(br);\n  }\n  // Process the remaining rows corresponding to last row-block.\n  ExtractPalettedAlphaRows(dec, row > last_row ? last_row : row);\n\n End:\n  br->eos_ = VP8LIsEndOfStream(br);\n  if (!ok || (br->eos_ && pos < end)) {\n    return VP8LSetError(\n        dec, br->eos_ ? VP8_STATUS_SUSPENDED : VP8_STATUS_BITSTREAM_ERROR);\n  }\n  dec->last_pixel_ = pos;\n  return ok;\n}\n\nstatic void SaveState(VP8LDecoder* const dec, int last_pixel) {\n  assert(dec->incremental_);\n  dec->saved_br_ = dec->br_;\n  dec->saved_last_pixel_ = last_pixel;\n  if (dec->hdr_.color_cache_size_ > 0) {\n    VP8LColorCacheCopy(&dec->hdr_.color_cache_, &dec->hdr_.saved_color_cache_);\n  }\n}\n\nstatic void RestoreState(VP8LDecoder* const dec) {\n  assert(dec->br_.eos_);\n  dec->status_ = VP8_STATUS_SUSPENDED;\n  dec->br_ = dec->saved_br_;\n  dec->last_pixel_ = dec->saved_last_pixel_;\n  if (dec->hdr_.color_cache_size_ > 0) {\n    VP8LColorCacheCopy(&dec->hdr_.saved_color_cache_, &dec->hdr_.color_cache_);\n  }\n}\n\n#define SYNC_EVERY_N_ROWS 8  // minimum number of rows between check-points\nstatic int DecodeImageData(VP8LDecoder* const dec, uint32_t* const data,\n                           int width, int height, int last_row,\n                           ProcessRowsFunc process_func) {\n  int row = dec->last_pixel_ / width;\n  int col = dec->last_pixel_ % width;\n  VP8LBitReader* const br = &dec->br_;\n  VP8LMetadata* const hdr = &dec->hdr_;\n  uint32_t* src = data + dec->last_pixel_;\n  uint32_t* last_cached = src;\n  uint32_t* const src_end = data + width * height;     // End of data\n  uint32_t* const src_last = data + width * last_row;  // Last pixel to decode\n  const int len_code_limit = NUM_LITERAL_CODES + NUM_LENGTH_CODES;\n  const int color_cache_limit = len_code_limit + hdr->color_cache_size_;\n  int next_sync_row = dec->incremental_ ? row : 1 << 24;\n  VP8LColorCache* const color_cache =\n      (hdr->color_cache_size_ > 0) ? &hdr->color_cache_ : NULL;\n  const int mask = hdr->huffman_mask_;\n  const HTreeGroup* htree_group =\n      (src < src_last) ? GetHtreeGroupForPos(hdr, col, row) : NULL;\n  assert(dec->last_row_ < last_row);\n  assert(src_last <= src_end);\n\n  while (src < src_last) {\n    int code;\n    if (row >= next_sync_row) {\n      SaveState(dec, (int)(src - data));\n      next_sync_row = row + SYNC_EVERY_N_ROWS;\n    }\n    // Only update when changing tile. Note we could use this test:\n    // if \"((((prev_col ^ col) | prev_row ^ row)) > mask)\" -> tile changed\n    // but that's actually slower and needs storing the previous col/row.\n    if ((col & mask) == 0) {\n      htree_group = GetHtreeGroupForPos(hdr, col, row);\n    }\n    assert(htree_group != NULL);\n    if (htree_group->is_trivial_code) {\n      *src = htree_group->literal_arb;\n      goto AdvanceByOne;\n    }\n    VP8LFillBitWindow(br);\n    if (htree_group->use_packed_table) {\n      code = ReadPackedSymbols(htree_group, br, src);\n      if (VP8LIsEndOfStream(br)) break;\n      if (code == PACKED_NON_LITERAL_CODE) goto AdvanceByOne;\n    } else {\n      code = ReadSymbol(htree_group->htrees[GREEN], br);\n    }\n    if (VP8LIsEndOfStream(br)) break;\n    if (code < NUM_LITERAL_CODES) {  // Literal\n      if (htree_group->is_trivial_literal) {\n        *src = htree_group->literal_arb | (code << 8);\n      } else {\n        int red, blue, alpha;\n        red = ReadSymbol(htree_group->htrees[RED], br);\n        VP8LFillBitWindow(br);\n        blue = ReadSymbol(htree_group->htrees[BLUE], br);\n        alpha = ReadSymbol(htree_group->htrees[ALPHA], br);\n        if (VP8LIsEndOfStream(br)) break;\n        *src = ((uint32_t)alpha << 24) | (red << 16) | (code << 8) | blue;\n      }\n    AdvanceByOne:\n      ++src;\n      ++col;\n      if (col >= width) {\n        col = 0;\n        ++row;\n        if (process_func != NULL) {\n          if (row <= last_row && (row % NUM_ARGB_CACHE_ROWS == 0)) {\n            process_func(dec, row);\n          }\n        }\n        if (color_cache != NULL) {\n          while (last_cached < src) {\n            VP8LColorCacheInsert(color_cache, *last_cached++);\n          }\n        }\n      }\n    } else if (code < len_code_limit) {  // Backward reference\n      int dist_code, dist;\n      const int length_sym = code - NUM_LITERAL_CODES;\n      const int length = GetCopyLength(length_sym, br);\n      const int dist_symbol = ReadSymbol(htree_group->htrees[DIST], br);\n      VP8LFillBitWindow(br);\n      dist_code = GetCopyDistance(dist_symbol, br);\n      dist = PlaneCodeToDistance(width, dist_code);\n\n      if (VP8LIsEndOfStream(br)) break;\n      if (src - data < (ptrdiff_t)dist || src_end - src < (ptrdiff_t)length) {\n        goto Error;\n      } else {\n        CopyBlock32b(src, dist, length);\n      }\n      src += length;\n      col += length;\n      while (col >= width) {\n        col -= width;\n        ++row;\n        if (process_func != NULL) {\n          if (row <= last_row && (row % NUM_ARGB_CACHE_ROWS == 0)) {\n            process_func(dec, row);\n          }\n        }\n      }\n      // Because of the check done above (before 'src' was incremented by\n      // 'length'), the following holds true.\n      assert(src <= src_end);\n      if (col & mask) htree_group = GetHtreeGroupForPos(hdr, col, row);\n      if (color_cache != NULL) {\n        while (last_cached < src) {\n          VP8LColorCacheInsert(color_cache, *last_cached++);\n        }\n      }\n    } else if (code < color_cache_limit) {  // Color cache\n      const int key = code - len_code_limit;\n      assert(color_cache != NULL);\n      while (last_cached < src) {\n        VP8LColorCacheInsert(color_cache, *last_cached++);\n      }\n      *src = VP8LColorCacheLookup(color_cache, key);\n      goto AdvanceByOne;\n    } else {  // Not reached\n      goto Error;\n    }\n  }\n\n  br->eos_ = VP8LIsEndOfStream(br);\n  if (dec->incremental_ && br->eos_ && src < src_end) {\n    RestoreState(dec);\n  } else if (!br->eos_) {\n    // Process the remaining rows corresponding to last row-block.\n    if (process_func != NULL) {\n      process_func(dec, row > last_row ? last_row : row);\n    }\n    dec->status_ = VP8_STATUS_OK;\n    dec->last_pixel_ = (int)(src - data);  // end-of-scan marker\n  } else {\n    // if not incremental, and we are past the end of buffer (eos_=1), then this\n    // is a real bitstream error.\n    goto Error;\n  }\n  return 1;\n\n Error:\n  return VP8LSetError(dec, VP8_STATUS_BITSTREAM_ERROR);\n}\n\n// -----------------------------------------------------------------------------\n// VP8LTransform\n\nstatic void ClearTransform(VP8LTransform* const transform) {\n  WebPSafeFree(transform->data_);\n  transform->data_ = NULL;\n}\n\n// For security reason, we need to remap the color map to span\n// the total possible bundled values, and not just the num_colors.\nstatic int ExpandColorMap(int num_colors, VP8LTransform* const transform) {\n  int i;\n  const int final_num_colors = 1 << (8 >> transform->bits_);\n  uint32_t* const new_color_map =\n      (uint32_t*)WebPSafeMalloc((uint64_t)final_num_colors,\n                                sizeof(*new_color_map));\n  if (new_color_map == NULL) {\n    return 0;\n  } else {\n    uint8_t* const data = (uint8_t*)transform->data_;\n    uint8_t* const new_data = (uint8_t*)new_color_map;\n    new_color_map[0] = transform->data_[0];\n    for (i = 4; i < 4 * num_colors; ++i) {\n      // Equivalent to VP8LAddPixels(), on a byte-basis.\n      new_data[i] = (data[i] + new_data[i - 4]) & 0xff;\n    }\n    for (; i < 4 * final_num_colors; ++i) {\n      new_data[i] = 0;  // black tail.\n    }\n    WebPSafeFree(transform->data_);\n    transform->data_ = new_color_map;\n  }\n  return 1;\n}\n\nstatic int ReadTransform(int* const xsize, int const* ysize,\n                         VP8LDecoder* const dec) {\n  int ok = 1;\n  VP8LBitReader* const br = &dec->br_;\n  VP8LTransform* transform = &dec->transforms_[dec->next_transform_];\n  const VP8LImageTransformType type =\n      (VP8LImageTransformType)VP8LReadBits(br, 2);\n\n  // Each transform type can only be present once in the stream.\n  if (dec->transforms_seen_ & (1U << type)) {\n    return 0;  // Already there, let's not accept the second same transform.\n  }\n  dec->transforms_seen_ |= (1U << type);\n\n  transform->type_ = type;\n  transform->xsize_ = *xsize;\n  transform->ysize_ = *ysize;\n  transform->data_ = NULL;\n  ++dec->next_transform_;\n  assert(dec->next_transform_ <= NUM_TRANSFORMS);\n\n  switch (type) {\n    case PREDICTOR_TRANSFORM:\n    case CROSS_COLOR_TRANSFORM:\n      transform->bits_ = VP8LReadBits(br, 3) + 2;\n      ok = DecodeImageStream(VP8LSubSampleSize(transform->xsize_,\n                                               transform->bits_),\n                             VP8LSubSampleSize(transform->ysize_,\n                                               transform->bits_),\n                             /*is_level0=*/0, dec, &transform->data_);\n      break;\n    case COLOR_INDEXING_TRANSFORM: {\n       const int num_colors = VP8LReadBits(br, 8) + 1;\n       const int bits = (num_colors > 16) ? 0\n                      : (num_colors > 4) ? 1\n                      : (num_colors > 2) ? 2\n                      : 3;\n       *xsize = VP8LSubSampleSize(transform->xsize_, bits);\n       transform->bits_ = bits;\n       ok = DecodeImageStream(num_colors, /*ysize=*/1, /*is_level0=*/0, dec,\n                              &transform->data_);\n       if (ok && !ExpandColorMap(num_colors, transform)) {\n         return VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);\n       }\n      break;\n    }\n    case SUBTRACT_GREEN_TRANSFORM:\n      break;\n    default:\n      assert(0);    // can't happen\n      break;\n  }\n\n  return ok;\n}\n\n// -----------------------------------------------------------------------------\n// VP8LMetadata\n\nstatic void InitMetadata(VP8LMetadata* const hdr) {\n  assert(hdr != NULL);\n  memset(hdr, 0, sizeof(*hdr));\n}\n\nstatic void ClearMetadata(VP8LMetadata* const hdr) {\n  assert(hdr != NULL);\n\n  WebPSafeFree(hdr->huffman_image_);\n  WebPSafeFree(hdr->huffman_tables_);\n  VP8LHtreeGroupsFree(hdr->htree_groups_);\n  VP8LColorCacheClear(&hdr->color_cache_);\n  VP8LColorCacheClear(&hdr->saved_color_cache_);\n  InitMetadata(hdr);\n}\n\n// -----------------------------------------------------------------------------\n// VP8LDecoder\n\nVP8LDecoder* VP8LNew(void) {\n  VP8LDecoder* const dec = (VP8LDecoder*)WebPSafeCalloc(1ULL, sizeof(*dec));\n  if (dec == NULL) return NULL;\n  dec->status_ = VP8_STATUS_OK;\n  dec->state_ = READ_DIM;\n\n  VP8LDspInit();  // Init critical function pointers.\n\n  return dec;\n}\n\nvoid VP8LClear(VP8LDecoder* const dec) {\n  int i;\n  if (dec == NULL) return;\n  ClearMetadata(&dec->hdr_);\n\n  WebPSafeFree(dec->pixels_);\n  dec->pixels_ = NULL;\n  for (i = 0; i < dec->next_transform_; ++i) {\n    ClearTransform(&dec->transforms_[i]);\n  }\n  dec->next_transform_ = 0;\n  dec->transforms_seen_ = 0;\n\n  WebPSafeFree(dec->rescaler_memory);\n  dec->rescaler_memory = NULL;\n\n  dec->output_ = NULL;   // leave no trace behind\n}\n\nvoid VP8LDelete(VP8LDecoder* const dec) {\n  if (dec != NULL) {\n    VP8LClear(dec);\n    WebPSafeFree(dec);\n  }\n}\n\nstatic void UpdateDecoder(VP8LDecoder* const dec, int width, int height) {\n  VP8LMetadata* const hdr = &dec->hdr_;\n  const int num_bits = hdr->huffman_subsample_bits_;\n  dec->width_ = width;\n  dec->height_ = height;\n\n  hdr->huffman_xsize_ = VP8LSubSampleSize(width, num_bits);\n  hdr->huffman_mask_ = (num_bits == 0) ? ~0 : (1 << num_bits) - 1;\n}\n\nstatic int DecodeImageStream(int xsize, int ysize,\n                             int is_level0,\n                             VP8LDecoder* const dec,\n                             uint32_t** const decoded_data) {\n  int ok = 1;\n  int transform_xsize = xsize;\n  int transform_ysize = ysize;\n  VP8LBitReader* const br = &dec->br_;\n  VP8LMetadata* const hdr = &dec->hdr_;\n  uint32_t* data = NULL;\n  int color_cache_bits = 0;\n\n  // Read the transforms (may recurse).\n  if (is_level0) {\n    while (ok && VP8LReadBits(br, 1)) {\n      ok = ReadTransform(&transform_xsize, &transform_ysize, dec);\n    }\n  }\n\n  // Color cache\n  if (ok && VP8LReadBits(br, 1)) {\n    color_cache_bits = VP8LReadBits(br, 4);\n    ok = (color_cache_bits >= 1 && color_cache_bits <= MAX_CACHE_BITS);\n    if (!ok) {\n      VP8LSetError(dec, VP8_STATUS_BITSTREAM_ERROR);\n      goto End;\n    }\n  }\n\n  // Read the Huffman codes (may recurse).\n  ok = ok && ReadHuffmanCodes(dec, transform_xsize, transform_ysize,\n                              color_cache_bits, is_level0);\n  if (!ok) {\n    VP8LSetError(dec, VP8_STATUS_BITSTREAM_ERROR);\n    goto End;\n  }\n\n  // Finish setting up the color-cache\n  if (color_cache_bits > 0) {\n    hdr->color_cache_size_ = 1 << color_cache_bits;\n    if (!VP8LColorCacheInit(&hdr->color_cache_, color_cache_bits)) {\n      ok = VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);\n      goto End;\n    }\n  } else {\n    hdr->color_cache_size_ = 0;\n  }\n  UpdateDecoder(dec, transform_xsize, transform_ysize);\n\n  if (is_level0) {   // level 0 complete\n    dec->state_ = READ_HDR;\n    goto End;\n  }\n\n  {\n    const uint64_t total_size = (uint64_t)transform_xsize * transform_ysize;\n    data = (uint32_t*)WebPSafeMalloc(total_size, sizeof(*data));\n    if (data == NULL) {\n      ok = VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);\n      goto End;\n    }\n  }\n\n  // Use the Huffman trees to decode the LZ77 encoded data.\n  ok = DecodeImageData(dec, data, transform_xsize, transform_ysize,\n                       transform_ysize, NULL);\n  ok = ok && !br->eos_;\n\n End:\n  if (!ok) {\n    WebPSafeFree(data);\n    ClearMetadata(hdr);\n  } else {\n    if (decoded_data != NULL) {\n      *decoded_data = data;\n    } else {\n      // We allocate image data in this function only for transforms. At level 0\n      // (that is: not the transforms), we shouldn't have allocated anything.\n      assert(data == NULL);\n      assert(is_level0);\n    }\n    dec->last_pixel_ = 0;  // Reset for future DECODE_DATA_FUNC() calls.\n    if (!is_level0) ClearMetadata(hdr);  // Clean up temporary data behind.\n  }\n  return ok;\n}\n\n//------------------------------------------------------------------------------\n// Allocate internal buffers dec->pixels_ and dec->argb_cache_.\nstatic int AllocateInternalBuffers32b(VP8LDecoder* const dec, int final_width) {\n  const uint64_t num_pixels = (uint64_t)dec->width_ * dec->height_;\n  // Scratch buffer corresponding to top-prediction row for transforming the\n  // first row in the row-blocks. Not needed for paletted alpha.\n  const uint64_t cache_top_pixels = (uint16_t)final_width;\n  // Scratch buffer for temporary BGRA storage. Not needed for paletted alpha.\n  const uint64_t cache_pixels = (uint64_t)final_width * NUM_ARGB_CACHE_ROWS;\n  const uint64_t total_num_pixels =\n      num_pixels + cache_top_pixels + cache_pixels;\n\n  assert(dec->width_ <= final_width);\n  dec->pixels_ = (uint32_t*)WebPSafeMalloc(total_num_pixels, sizeof(uint32_t));\n  if (dec->pixels_ == NULL) {\n    dec->argb_cache_ = NULL;    // for soundness\n    return VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);\n  }\n  dec->argb_cache_ = dec->pixels_ + num_pixels + cache_top_pixels;\n  return 1;\n}\n\nstatic int AllocateInternalBuffers8b(VP8LDecoder* const dec) {\n  const uint64_t total_num_pixels = (uint64_t)dec->width_ * dec->height_;\n  dec->argb_cache_ = NULL;    // for soundness\n  dec->pixels_ = (uint32_t*)WebPSafeMalloc(total_num_pixels, sizeof(uint8_t));\n  if (dec->pixels_ == NULL) {\n    return VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);\n  }\n  return 1;\n}\n\n//------------------------------------------------------------------------------\n\n// Special row-processing that only stores the alpha data.\nstatic void ExtractAlphaRows(VP8LDecoder* const dec, int last_row) {\n  int cur_row = dec->last_row_;\n  int num_rows = last_row - cur_row;\n  const uint32_t* in = dec->pixels_ + dec->width_ * cur_row;\n\n  assert(last_row <= dec->io_->crop_bottom);\n  while (num_rows > 0) {\n    const int num_rows_to_process =\n        (num_rows > NUM_ARGB_CACHE_ROWS) ? NUM_ARGB_CACHE_ROWS : num_rows;\n    // Extract alpha (which is stored in the green plane).\n    ALPHDecoder* const alph_dec = (ALPHDecoder*)dec->io_->opaque;\n    uint8_t* const output = alph_dec->output_;\n    const int width = dec->io_->width;      // the final width (!= dec->width_)\n    const int cache_pixs = width * num_rows_to_process;\n    uint8_t* const dst = output + width * cur_row;\n    const uint32_t* const src = dec->argb_cache_;\n    ApplyInverseTransforms(dec, cur_row, num_rows_to_process, in);\n    WebPExtractGreen(src, dst, cache_pixs);\n    AlphaApplyFilter(alph_dec,\n                     cur_row, cur_row + num_rows_to_process, dst, width);\n    num_rows -= num_rows_to_process;\n    in += num_rows_to_process * dec->width_;\n    cur_row += num_rows_to_process;\n  }\n  assert(cur_row == last_row);\n  dec->last_row_ = dec->last_out_row_ = last_row;\n}\n\nint VP8LDecodeAlphaHeader(ALPHDecoder* const alph_dec,\n                          const uint8_t* const data, size_t data_size) {\n  int ok = 0;\n  VP8LDecoder* dec = VP8LNew();\n\n  if (dec == NULL) return 0;\n\n  assert(alph_dec != NULL);\n\n  dec->width_ = alph_dec->width_;\n  dec->height_ = alph_dec->height_;\n  dec->io_ = &alph_dec->io_;\n  dec->io_->opaque = alph_dec;\n  dec->io_->width = alph_dec->width_;\n  dec->io_->height = alph_dec->height_;\n\n  dec->status_ = VP8_STATUS_OK;\n  VP8LInitBitReader(&dec->br_, data, data_size);\n\n  if (!DecodeImageStream(alph_dec->width_, alph_dec->height_, /*is_level0=*/1,\n                         dec, /*decoded_data=*/NULL)) {\n    goto Err;\n  }\n\n  // Special case: if alpha data uses only the color indexing transform and\n  // doesn't use color cache (a frequent case), we will use DecodeAlphaData()\n  // method that only needs allocation of 1 byte per pixel (alpha channel).\n  if (dec->next_transform_ == 1 &&\n      dec->transforms_[0].type_ == COLOR_INDEXING_TRANSFORM &&\n      Is8bOptimizable(&dec->hdr_)) {\n    alph_dec->use_8b_decode_ = 1;\n    ok = AllocateInternalBuffers8b(dec);\n  } else {\n    // Allocate internal buffers (note that dec->width_ may have changed here).\n    alph_dec->use_8b_decode_ = 0;\n    ok = AllocateInternalBuffers32b(dec, alph_dec->width_);\n  }\n\n  if (!ok) goto Err;\n\n  // Only set here, once we are sure it is valid (to avoid thread races).\n  alph_dec->vp8l_dec_ = dec;\n  return 1;\n\n Err:\n  VP8LDelete(dec);\n  return 0;\n}\n\nint VP8LDecodeAlphaImageStream(ALPHDecoder* const alph_dec, int last_row) {\n  VP8LDecoder* const dec = alph_dec->vp8l_dec_;\n  assert(dec != NULL);\n  assert(last_row <= dec->height_);\n\n  if (dec->last_row_ >= last_row) {\n    return 1;  // done\n  }\n\n  if (!alph_dec->use_8b_decode_) WebPInitAlphaProcessing();\n\n  // Decode (with special row processing).\n  return alph_dec->use_8b_decode_ ?\n      DecodeAlphaData(dec, (uint8_t*)dec->pixels_, dec->width_, dec->height_,\n                      last_row) :\n      DecodeImageData(dec, dec->pixels_, dec->width_, dec->height_,\n                      last_row, ExtractAlphaRows);\n}\n\n//------------------------------------------------------------------------------\n\nint VP8LDecodeHeader(VP8LDecoder* const dec, VP8Io* const io) {\n  int width, height, has_alpha;\n\n  if (dec == NULL) return 0;\n  if (io == NULL) {\n    return VP8LSetError(dec, VP8_STATUS_INVALID_PARAM);\n  }\n\n  dec->io_ = io;\n  dec->status_ = VP8_STATUS_OK;\n  VP8LInitBitReader(&dec->br_, io->data, io->data_size);\n  if (!ReadImageInfo(&dec->br_, &width, &height, &has_alpha)) {\n    VP8LSetError(dec, VP8_STATUS_BITSTREAM_ERROR);\n    goto Error;\n  }\n  dec->state_ = READ_DIM;\n  io->width = width;\n  io->height = height;\n\n  if (!DecodeImageStream(width, height, /*is_level0=*/1, dec,\n                         /*decoded_data=*/NULL)) {\n    goto Error;\n  }\n  return 1;\n\n Error:\n  VP8LClear(dec);\n  assert(dec->status_ != VP8_STATUS_OK);\n  return 0;\n}\n\nint VP8LDecodeImage(VP8LDecoder* const dec) {\n  VP8Io* io = NULL;\n  WebPDecParams* params = NULL;\n\n  if (dec == NULL) return 0;\n\n  assert(dec->hdr_.huffman_tables_ != NULL);\n  assert(dec->hdr_.htree_groups_ != NULL);\n  assert(dec->hdr_.num_htree_groups_ > 0);\n\n  io = dec->io_;\n  assert(io != NULL);\n  params = (WebPDecParams*)io->opaque;\n  assert(params != NULL);\n\n  // Initialization.\n  if (dec->state_ != READ_DATA) {\n    dec->output_ = params->output;\n    assert(dec->output_ != NULL);\n\n    if (!WebPIoInitFromOptions(params->options, io, MODE_BGRA)) {\n      VP8LSetError(dec, VP8_STATUS_INVALID_PARAM);\n      goto Err;\n    }\n\n    if (!AllocateInternalBuffers32b(dec, io->width)) goto Err;\n\n#if !defined(WEBP_REDUCE_SIZE)\n    if (io->use_scaling && !AllocateAndInitRescaler(dec, io)) goto Err;\n#else\n    if (io->use_scaling) {\n      VP8LSetError(dec, VP8_STATUS_INVALID_PARAM);\n      goto Err;\n    }\n#endif\n    if (io->use_scaling || WebPIsPremultipliedMode(dec->output_->colorspace)) {\n      // need the alpha-multiply functions for premultiplied output or rescaling\n      WebPInitAlphaProcessing();\n    }\n\n    if (!WebPIsRGBMode(dec->output_->colorspace)) {\n      WebPInitConvertARGBToYUV();\n      if (dec->output_->u.YUVA.a != NULL) WebPInitAlphaProcessing();\n    }\n    if (dec->incremental_) {\n      if (dec->hdr_.color_cache_size_ > 0 &&\n          dec->hdr_.saved_color_cache_.colors_ == NULL) {\n        if (!VP8LColorCacheInit(&dec->hdr_.saved_color_cache_,\n                                dec->hdr_.color_cache_.hash_bits_)) {\n          VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);\n          goto Err;\n        }\n      }\n    }\n    dec->state_ = READ_DATA;\n  }\n\n  // Decode.\n  if (!DecodeImageData(dec, dec->pixels_, dec->width_, dec->height_,\n                       io->crop_bottom, ProcessRows)) {\n    goto Err;\n  }\n\n  params->last_y = dec->last_out_row_;\n  return 1;\n\n Err:\n  VP8LClear(dec);\n  assert(dec->status_ != VP8_STATUS_OK);\n  return 0;\n}\n\n//------------------------------------------------------------------------------\n", "// Copyright 2012 Google Inc. All Rights Reserved.\n//\n// Use of this source code is governed by a BSD-style license\n// that can be found in the COPYING file in the root of the source\n// tree. An additional intellectual property rights grant can be found\n// in the file PATENTS. All contributing project authors may\n// be found in the AUTHORS file in the root of the source tree.\n// -----------------------------------------------------------------------------\n//\n// Lossless decoder: internal header.\n//\n// Author: Skal (pascal.massimino@gmail.com)\n//         Vikas Arora(vikaas.arora@gmail.com)\n\n#ifndef WEBP_DEC_VP8LI_DEC_H_\n#define WEBP_DEC_VP8LI_DEC_H_\n\n#include <string.h>     // for memcpy()\n#include \"src/dec/webpi_dec.h\"\n#include \"src/utils/bit_reader_utils.h\"\n#include \"src/utils/color_cache_utils.h\"\n#include \"src/utils/huffman_utils.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef enum {\n  READ_DATA = 0,\n  READ_HDR = 1,\n  READ_DIM = 2\n} VP8LDecodeState;\n\ntypedef struct VP8LTransform VP8LTransform;\nstruct VP8LTransform {\n  VP8LImageTransformType type_;   // transform type.\n  int                    bits_;   // subsampling bits defining transform window.\n  int                    xsize_;  // transform window X index.\n  int                    ysize_;  // transform window Y index.\n  uint32_t*              data_;   // transform data.\n};\n\ntypedef struct {\n  int             color_cache_size_;\n  VP8LColorCache  color_cache_;\n  VP8LColorCache  saved_color_cache_;  // for incremental\n\n  int             huffman_mask_;\n  int             huffman_subsample_bits_;\n  int             huffman_xsize_;\n  uint32_t*       huffman_image_;\n  int             num_htree_groups_;\n  HTreeGroup*     htree_groups_;\n  HuffmanCode*    huffman_tables_;\n} VP8LMetadata;\n\ntypedef struct VP8LDecoder VP8LDecoder;\nstruct VP8LDecoder {\n  VP8StatusCode    status_;\n  VP8LDecodeState  state_;\n  VP8Io*           io_;\n\n  const WebPDecBuffer* output_;    // shortcut to io->opaque->output\n\n  uint32_t*        pixels_;        // Internal data: either uint8_t* for alpha\n                                   // or uint32_t* for BGRA.\n  uint32_t*        argb_cache_;    // Scratch buffer for temporary BGRA storage.\n\n  VP8LBitReader    br_;\n  int              incremental_;   // if true, incremental decoding is expected\n  VP8LBitReader    saved_br_;      // note: could be local variables too\n  int              saved_last_pixel_;\n\n  int              width_;\n  int              height_;\n  int              last_row_;      // last input row decoded so far.\n  int              last_pixel_;    // last pixel decoded so far. However, it may\n                                   // not be transformed, scaled and\n                                   // color-converted yet.\n  int              last_out_row_;  // last row output so far.\n\n  VP8LMetadata     hdr_;\n\n  int              next_transform_;\n  VP8LTransform    transforms_[NUM_TRANSFORMS];\n  // or'd bitset storing the transforms types.\n  uint32_t         transforms_seen_;\n\n  uint8_t*         rescaler_memory;  // Working memory for rescaling work.\n  WebPRescaler*    rescaler;         // Common rescaler for all channels.\n};\n\n//------------------------------------------------------------------------------\n// internal functions. Not public.\n\nstruct ALPHDecoder;  // Defined in dec/alphai.h.\n\n// in vp8l.c\n\n// Decodes image header for alpha data stored using lossless compression.\n// Returns false in case of error.\nint VP8LDecodeAlphaHeader(struct ALPHDecoder* const alph_dec,\n                          const uint8_t* const data, size_t data_size);\n\n// Decodes *at least* 'last_row' rows of alpha. If some of the initial rows are\n// already decoded in previous call(s), it will resume decoding from where it\n// was paused.\n// Returns false in case of bitstream error.\nint VP8LDecodeAlphaImageStream(struct ALPHDecoder* const alph_dec,\n                               int last_row);\n\n// Allocates and initialize a new lossless decoder instance.\nVP8LDecoder* VP8LNew(void);\n\n// Decodes the image header. Returns false in case of error.\nint VP8LDecodeHeader(VP8LDecoder* const dec, VP8Io* const io);\n\n// Decodes an image. It's required to decode the lossless header before calling\n// this function. Returns false in case of error, with updated dec->status_.\nint VP8LDecodeImage(VP8LDecoder* const dec);\n\n// Resets the decoder in its initial state, reclaiming memory.\n// Preserves the dec->status_ value.\nvoid VP8LClear(VP8LDecoder* const dec);\n\n// Clears and deallocate a lossless decoder instance.\nvoid VP8LDelete(VP8LDecoder* const dec);\n\n//------------------------------------------------------------------------------\n\n#ifdef __cplusplus\n}    // extern \"C\"\n#endif\n\n#endif  // WEBP_DEC_VP8LI_DEC_H_\n", "// Copyright 2012 Google Inc. All Rights Reserved.\n//\n// Use of this source code is governed by a BSD-style license\n// that can be found in the COPYING file in the root of the source\n// tree. An additional intellectual property rights grant can be found\n// in the file PATENTS. All contributing project authors may\n// be found in the AUTHORS file in the root of the source tree.\n// -----------------------------------------------------------------------------\n//\n// Utilities for building and looking up Huffman trees.\n//\n// Author: Urvang Joshi (urvang@google.com)\n\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"src/utils/huffman_utils.h\"\n#include \"src/utils/utils.h\"\n#include \"src/webp/format_constants.h\"\n\n// Huffman data read via DecodeImageStream is represented in two (red and green)\n// bytes.\n#define MAX_HTREE_GROUPS    0x10000\n\nHTreeGroup* VP8LHtreeGroupsNew(int num_htree_groups) {\n  HTreeGroup* const htree_groups =\n      (HTreeGroup*)WebPSafeMalloc(num_htree_groups, sizeof(*htree_groups));\n  if (htree_groups == NULL) {\n    return NULL;\n  }\n  assert(num_htree_groups <= MAX_HTREE_GROUPS);\n  return htree_groups;\n}\n\nvoid VP8LHtreeGroupsFree(HTreeGroup* const htree_groups) {\n  if (htree_groups != NULL) {\n    WebPSafeFree(htree_groups);\n  }\n}\n\n// Returns reverse(reverse(key, len) + 1, len), where reverse(key, len) is the\n// bit-wise reversal of the len least significant bits of key.\nstatic WEBP_INLINE uint32_t GetNextKey(uint32_t key, int len) {\n  uint32_t step = 1 << (len - 1);\n  while (key & step) {\n    step >>= 1;\n  }\n  return step ? (key & (step - 1)) + step : key;\n}\n\n// Stores code in table[0], table[step], table[2*step], ..., table[end].\n// Assumes that end is an integer multiple of step.\nstatic WEBP_INLINE void ReplicateValue(HuffmanCode* table,\n                                       int step, int end,\n                                       HuffmanCode code) {\n  assert(end % step == 0);\n  do {\n    end -= step;\n    table[end] = code;\n  } while (end > 0);\n}\n\n// Returns the table width of the next 2nd level table. count is the histogram\n// of bit lengths for the remaining symbols, len is the code length of the next\n// processed symbol\nstatic WEBP_INLINE int NextTableBitSize(const int* const count,\n                                        int len, int root_bits) {\n  int left = 1 << (len - root_bits);\n  while (len < MAX_ALLOWED_CODE_LENGTH) {\n    left -= count[len];\n    if (left <= 0) break;\n    ++len;\n    left <<= 1;\n  }\n  return len - root_bits;\n}\n\n// sorted[code_lengths_size] is a pre-allocated array for sorting symbols\n// by code length.\nstatic int BuildHuffmanTable(HuffmanCode* const root_table, int root_bits,\n                             const int code_lengths[], int code_lengths_size,\n                             uint16_t sorted[]) {\n  HuffmanCode* table = root_table;  // next available space in table\n  int total_size = 1 << root_bits;  // total size root table + 2nd level table\n  int len;                          // current code length\n  int symbol;                       // symbol index in original or sorted table\n  // number of codes of each length:\n  int count[MAX_ALLOWED_CODE_LENGTH + 1] = { 0 };\n  // offsets in sorted table for each length:\n  int offset[MAX_ALLOWED_CODE_LENGTH + 1];\n\n  assert(code_lengths_size != 0);\n  assert(code_lengths != NULL);\n  assert((root_table != NULL && sorted != NULL) ||\n         (root_table == NULL && sorted == NULL));\n  assert(root_bits > 0);\n\n  // Build histogram of code lengths.\n  for (symbol = 0; symbol < code_lengths_size; ++symbol) {\n    if (code_lengths[symbol] > MAX_ALLOWED_CODE_LENGTH) {\n      return 0;\n    }\n    ++count[code_lengths[symbol]];\n  }\n\n  // Error, all code lengths are zeros.\n  if (count[0] == code_lengths_size) {\n    return 0;\n  }\n\n  // Generate offsets into sorted symbol table by code length.\n  offset[1] = 0;\n  for (len = 1; len < MAX_ALLOWED_CODE_LENGTH; ++len) {\n    if (count[len] > (1 << len)) {\n      return 0;\n    }\n    offset[len + 1] = offset[len] + count[len];\n  }\n\n  // Sort symbols by length, by symbol order within each length.\n  for (symbol = 0; symbol < code_lengths_size; ++symbol) {\n    const int symbol_code_length = code_lengths[symbol];\n    if (code_lengths[symbol] > 0) {\n      if (sorted != NULL) {\n        sorted[offset[symbol_code_length]++] = symbol;\n      } else {\n        offset[symbol_code_length]++;\n      }\n    }\n  }\n\n  // Special case code with only one value.\n  if (offset[MAX_ALLOWED_CODE_LENGTH] == 1) {\n    if (sorted != NULL) {\n      HuffmanCode code;\n      code.bits = 0;\n      code.value = (uint16_t)sorted[0];\n      ReplicateValue(table, 1, total_size, code);\n    }\n    return total_size;\n  }\n\n  {\n    int step;              // step size to replicate values in current table\n    uint32_t low = 0xffffffffu;        // low bits for current root entry\n    uint32_t mask = total_size - 1;    // mask for low bits\n    uint32_t key = 0;      // reversed prefix code\n    int num_nodes = 1;     // number of Huffman tree nodes\n    int num_open = 1;      // number of open branches in current tree level\n    int table_bits = root_bits;        // key length of current table\n    int table_size = 1 << table_bits;  // size of current table\n    symbol = 0;\n    // Fill in root table.\n    for (len = 1, step = 2; len <= root_bits; ++len, step <<= 1) {\n      num_open <<= 1;\n      num_nodes += num_open;\n      num_open -= count[len];\n      if (num_open < 0) {\n        return 0;\n      }\n      if (root_table == NULL) continue;\n      for (; count[len] > 0; --count[len]) {\n        HuffmanCode code;\n        code.bits = (uint8_t)len;\n        code.value = (uint16_t)sorted[symbol++];\n        ReplicateValue(&table[key], step, table_size, code);\n        key = GetNextKey(key, len);\n      }\n    }\n\n    // Fill in 2nd level tables and add pointers to root table.\n    for (len = root_bits + 1, step = 2; len <= MAX_ALLOWED_CODE_LENGTH;\n         ++len, step <<= 1) {\n      num_open <<= 1;\n      num_nodes += num_open;\n      num_open -= count[len];\n      if (num_open < 0) {\n        return 0;\n      }\n      if (root_table == NULL) continue;\n      for (; count[len] > 0; --count[len]) {\n        HuffmanCode code;\n        if ((key & mask) != low) {\n          table += table_size;\n          table_bits = NextTableBitSize(count, len, root_bits);\n          table_size = 1 << table_bits;\n          total_size += table_size;\n          low = key & mask;\n          root_table[low].bits = (uint8_t)(table_bits + root_bits);\n          root_table[low].value = (uint16_t)((table - root_table) - low);\n        }\n        code.bits = (uint8_t)(len - root_bits);\n        code.value = (uint16_t)sorted[symbol++];\n        ReplicateValue(&table[key >> root_bits], step, table_size, code);\n        key = GetNextKey(key, len);\n      }\n    }\n\n    // Check if tree is full.\n    if (num_nodes != 2 * offset[MAX_ALLOWED_CODE_LENGTH] - 1) {\n      return 0;\n    }\n  }\n\n  return total_size;\n}\n\n// Maximum code_lengths_size is 2328 (reached for 11-bit color_cache_bits).\n// More commonly, the value is around ~280.\n#define MAX_CODE_LENGTHS_SIZE \\\n  ((1 << MAX_CACHE_BITS) + NUM_LITERAL_CODES + NUM_LENGTH_CODES)\n// Cut-off value for switching between heap and stack allocation.\n#define SORTED_SIZE_CUTOFF 512\nint VP8LBuildHuffmanTable(HuffmanCode* const root_table, int root_bits,\n                          const int code_lengths[], int code_lengths_size) {\n  int total_size;\n  assert(code_lengths_size <= MAX_CODE_LENGTHS_SIZE);\n  if (root_table == NULL) {\n    total_size = BuildHuffmanTable(NULL, root_bits,\n                                   code_lengths, code_lengths_size, NULL);\n  } else if (code_lengths_size <= SORTED_SIZE_CUTOFF) {\n    // use local stack-allocated array.\n    uint16_t sorted[SORTED_SIZE_CUTOFF];\n    total_size = BuildHuffmanTable(root_table, root_bits,\n                                   code_lengths, code_lengths_size, sorted);\n  } else {   // rare case. Use heap allocation.\n    uint16_t* const sorted =\n        (uint16_t*)WebPSafeMalloc(code_lengths_size, sizeof(*sorted));\n    if (sorted == NULL) return 0;\n    total_size = BuildHuffmanTable(root_table, root_bits,\n                                   code_lengths, code_lengths_size, sorted);\n    WebPSafeFree(sorted);\n  }\n  return total_size;\n}\n", "// Copyright 2012 Google Inc. All Rights Reserved.\n//\n// Use of this source code is governed by a BSD-style license\n// that can be found in the COPYING file in the root of the source\n// tree. An additional intellectual property rights grant can be found\n// in the file PATENTS. All contributing project authors may\n// be found in the AUTHORS file in the root of the source tree.\n// -----------------------------------------------------------------------------\n//\n// Utilities for building and looking up Huffman trees.\n//\n// Author: Urvang Joshi (urvang@google.com)\n\n#ifndef WEBP_UTILS_HUFFMAN_UTILS_H_\n#define WEBP_UTILS_HUFFMAN_UTILS_H_\n\n#include <assert.h>\n#include \"src/webp/format_constants.h\"\n#include \"src/webp/types.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define HUFFMAN_TABLE_BITS      8\n#define HUFFMAN_TABLE_MASK      ((1 << HUFFMAN_TABLE_BITS) - 1)\n\n#define LENGTHS_TABLE_BITS      7\n#define LENGTHS_TABLE_MASK      ((1 << LENGTHS_TABLE_BITS) - 1)\n\n\n// Huffman lookup table entry\ntypedef struct {\n  uint8_t bits;     // number of bits used for this symbol\n  uint16_t value;   // symbol value or table offset\n} HuffmanCode;\n\n// long version for holding 32b values\ntypedef struct {\n  int bits;         // number of bits used for this symbol,\n                    // or an impossible value if not a literal code.\n  uint32_t value;   // 32b packed ARGB value if literal,\n                    // or non-literal symbol otherwise\n} HuffmanCode32;\n\n#define HUFFMAN_PACKED_BITS 6\n#define HUFFMAN_PACKED_TABLE_SIZE (1u << HUFFMAN_PACKED_BITS)\n\n// Huffman table group.\n// Includes special handling for the following cases:\n//  - is_trivial_literal: one common literal base for RED/BLUE/ALPHA (not GREEN)\n//  - is_trivial_code: only 1 code (no bit is read from bitstream)\n//  - use_packed_table: few enough literal symbols, so all the bit codes\n//    can fit into a small look-up table packed_table[]\n// The common literal base, if applicable, is stored in 'literal_arb'.\ntypedef struct HTreeGroup HTreeGroup;\nstruct HTreeGroup {\n  HuffmanCode* htrees[HUFFMAN_CODES_PER_META_CODE];\n  int      is_trivial_literal;  // True, if huffman trees for Red, Blue & Alpha\n                                // Symbols are trivial (have a single code).\n  uint32_t literal_arb;         // If is_trivial_literal is true, this is the\n                                // ARGB value of the pixel, with Green channel\n                                // being set to zero.\n  int is_trivial_code;          // true if is_trivial_literal with only one code\n  int use_packed_table;         // use packed table below for short literal code\n  // table mapping input bits to a packed values, or escape case to literal code\n  HuffmanCode32 packed_table[HUFFMAN_PACKED_TABLE_SIZE];\n};\n\n// Creates the instance of HTreeGroup with specified number of tree-groups.\nHTreeGroup* VP8LHtreeGroupsNew(int num_htree_groups);\n\n// Releases the memory allocated for HTreeGroup.\nvoid VP8LHtreeGroupsFree(HTreeGroup* const htree_groups);\n\n// Builds Huffman lookup table assuming code lengths are in symbol order.\n// The 'code_lengths' is pre-allocated temporary memory buffer used for creating\n// the huffman table.\n// Returns built table size or 0 in case of error (invalid tree or\n// memory error).\n// If root_table is NULL, it returns 0 if a lookup cannot be built, something\n// > 0 otherwise (but not the table size).\nint VP8LBuildHuffmanTable(HuffmanCode* const root_table, int root_bits,\n                          const int code_lengths[], int code_lengths_size);\n\n#ifdef __cplusplus\n}    // extern \"C\"\n#endif\n\n#endif  // WEBP_UTILS_HUFFMAN_UTILS_H_\n"], "fixing_code": ["// Copyright 2012 Google Inc. All Rights Reserved.\n//\n// Use of this source code is governed by a BSD-style license\n// that can be found in the COPYING file in the root of the source\n// tree. An additional intellectual property rights grant can be found\n// in the file PATENTS. All contributing project authors may\n// be found in the AUTHORS file in the root of the source tree.\n// -----------------------------------------------------------------------------\n//\n// main entry for the decoder\n//\n// Authors: Vikas Arora (vikaas.arora@gmail.com)\n//          Jyrki Alakuijala (jyrki@google.com)\n\n#include <assert.h>\n#include <stdlib.h>\n\n#include \"src/dec/alphai_dec.h\"\n#include \"src/dec/vp8li_dec.h\"\n#include \"src/dsp/dsp.h\"\n#include \"src/dsp/lossless.h\"\n#include \"src/dsp/lossless_common.h\"\n#include \"src/dsp/yuv.h\"\n#include \"src/utils/endian_inl_utils.h\"\n#include \"src/utils/huffman_utils.h\"\n#include \"src/utils/utils.h\"\n\n#define NUM_ARGB_CACHE_ROWS          16\n\nstatic const int kCodeLengthLiterals = 16;\nstatic const int kCodeLengthRepeatCode = 16;\nstatic const uint8_t kCodeLengthExtraBits[3] = { 2, 3, 7 };\nstatic const uint8_t kCodeLengthRepeatOffsets[3] = { 3, 3, 11 };\n\n// -----------------------------------------------------------------------------\n//  Five Huffman codes are used at each meta code:\n//  1. green + length prefix codes + color cache codes,\n//  2. alpha,\n//  3. red,\n//  4. blue, and,\n//  5. distance prefix codes.\ntypedef enum {\n  GREEN = 0,\n  RED   = 1,\n  BLUE  = 2,\n  ALPHA = 3,\n  DIST  = 4\n} HuffIndex;\n\nstatic const uint16_t kAlphabetSize[HUFFMAN_CODES_PER_META_CODE] = {\n  NUM_LITERAL_CODES + NUM_LENGTH_CODES,\n  NUM_LITERAL_CODES, NUM_LITERAL_CODES, NUM_LITERAL_CODES,\n  NUM_DISTANCE_CODES\n};\n\nstatic const uint8_t kLiteralMap[HUFFMAN_CODES_PER_META_CODE] = {\n  0, 1, 1, 1, 0\n};\n\n#define NUM_CODE_LENGTH_CODES       19\nstatic const uint8_t kCodeLengthCodeOrder[NUM_CODE_LENGTH_CODES] = {\n  17, 18, 0, 1, 2, 3, 4, 5, 16, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15\n};\n\n#define CODE_TO_PLANE_CODES        120\nstatic const uint8_t kCodeToPlane[CODE_TO_PLANE_CODES] = {\n  0x18, 0x07, 0x17, 0x19, 0x28, 0x06, 0x27, 0x29, 0x16, 0x1a,\n  0x26, 0x2a, 0x38, 0x05, 0x37, 0x39, 0x15, 0x1b, 0x36, 0x3a,\n  0x25, 0x2b, 0x48, 0x04, 0x47, 0x49, 0x14, 0x1c, 0x35, 0x3b,\n  0x46, 0x4a, 0x24, 0x2c, 0x58, 0x45, 0x4b, 0x34, 0x3c, 0x03,\n  0x57, 0x59, 0x13, 0x1d, 0x56, 0x5a, 0x23, 0x2d, 0x44, 0x4c,\n  0x55, 0x5b, 0x33, 0x3d, 0x68, 0x02, 0x67, 0x69, 0x12, 0x1e,\n  0x66, 0x6a, 0x22, 0x2e, 0x54, 0x5c, 0x43, 0x4d, 0x65, 0x6b,\n  0x32, 0x3e, 0x78, 0x01, 0x77, 0x79, 0x53, 0x5d, 0x11, 0x1f,\n  0x64, 0x6c, 0x42, 0x4e, 0x76, 0x7a, 0x21, 0x2f, 0x75, 0x7b,\n  0x31, 0x3f, 0x63, 0x6d, 0x52, 0x5e, 0x00, 0x74, 0x7c, 0x41,\n  0x4f, 0x10, 0x20, 0x62, 0x6e, 0x30, 0x73, 0x7d, 0x51, 0x5f,\n  0x40, 0x72, 0x7e, 0x61, 0x6f, 0x50, 0x71, 0x7f, 0x60, 0x70\n};\n\n// Memory needed for lookup tables of one Huffman tree group. Red, blue, alpha\n// and distance alphabets are constant (256 for red, blue and alpha, 40 for\n// distance) and lookup table sizes for them in worst case are 630 and 410\n// respectively. Size of green alphabet depends on color cache size and is equal\n// to 256 (green component values) + 24 (length prefix values)\n// + color_cache_size (between 0 and 2048).\n// All values computed for 8-bit first level lookup with Mark Adler's tool:\n// https://github.com/madler/zlib/blob/v1.2.5/examples/enough.c\n#define FIXED_TABLE_SIZE (630 * 3 + 410)\nstatic const uint16_t kTableSize[12] = {\n  FIXED_TABLE_SIZE + 654,\n  FIXED_TABLE_SIZE + 656,\n  FIXED_TABLE_SIZE + 658,\n  FIXED_TABLE_SIZE + 662,\n  FIXED_TABLE_SIZE + 670,\n  FIXED_TABLE_SIZE + 686,\n  FIXED_TABLE_SIZE + 718,\n  FIXED_TABLE_SIZE + 782,\n  FIXED_TABLE_SIZE + 912,\n  FIXED_TABLE_SIZE + 1168,\n  FIXED_TABLE_SIZE + 1680,\n  FIXED_TABLE_SIZE + 2704\n};\n\nstatic int VP8LSetError(VP8LDecoder* const dec, VP8StatusCode error) {\n  // The oldest error reported takes precedence over the new one.\n  if (dec->status_ == VP8_STATUS_OK || dec->status_ == VP8_STATUS_SUSPENDED) {\n    dec->status_ = error;\n  }\n  return 0;\n}\n\nstatic int DecodeImageStream(int xsize, int ysize,\n                             int is_level0,\n                             VP8LDecoder* const dec,\n                             uint32_t** const decoded_data);\n\n//------------------------------------------------------------------------------\n\nint VP8LCheckSignature(const uint8_t* const data, size_t size) {\n  return (size >= VP8L_FRAME_HEADER_SIZE &&\n          data[0] == VP8L_MAGIC_BYTE &&\n          (data[4] >> 5) == 0);  // version\n}\n\nstatic int ReadImageInfo(VP8LBitReader* const br,\n                         int* const width, int* const height,\n                         int* const has_alpha) {\n  if (VP8LReadBits(br, 8) != VP8L_MAGIC_BYTE) return 0;\n  *width = VP8LReadBits(br, VP8L_IMAGE_SIZE_BITS) + 1;\n  *height = VP8LReadBits(br, VP8L_IMAGE_SIZE_BITS) + 1;\n  *has_alpha = VP8LReadBits(br, 1);\n  if (VP8LReadBits(br, VP8L_VERSION_BITS) != 0) return 0;\n  return !br->eos_;\n}\n\nint VP8LGetInfo(const uint8_t* data, size_t data_size,\n                int* const width, int* const height, int* const has_alpha) {\n  if (data == NULL || data_size < VP8L_FRAME_HEADER_SIZE) {\n    return 0;         // not enough data\n  } else if (!VP8LCheckSignature(data, data_size)) {\n    return 0;         // bad signature\n  } else {\n    int w, h, a;\n    VP8LBitReader br;\n    VP8LInitBitReader(&br, data, data_size);\n    if (!ReadImageInfo(&br, &w, &h, &a)) {\n      return 0;\n    }\n    if (width != NULL) *width = w;\n    if (height != NULL) *height = h;\n    if (has_alpha != NULL) *has_alpha = a;\n    return 1;\n  }\n}\n\n//------------------------------------------------------------------------------\n\nstatic WEBP_INLINE int GetCopyDistance(int distance_symbol,\n                                       VP8LBitReader* const br) {\n  int extra_bits, offset;\n  if (distance_symbol < 4) {\n    return distance_symbol + 1;\n  }\n  extra_bits = (distance_symbol - 2) >> 1;\n  offset = (2 + (distance_symbol & 1)) << extra_bits;\n  return offset + VP8LReadBits(br, extra_bits) + 1;\n}\n\nstatic WEBP_INLINE int GetCopyLength(int length_symbol,\n                                     VP8LBitReader* const br) {\n  // Length and distance prefixes are encoded the same way.\n  return GetCopyDistance(length_symbol, br);\n}\n\nstatic WEBP_INLINE int PlaneCodeToDistance(int xsize, int plane_code) {\n  if (plane_code > CODE_TO_PLANE_CODES) {\n    return plane_code - CODE_TO_PLANE_CODES;\n  } else {\n    const int dist_code = kCodeToPlane[plane_code - 1];\n    const int yoffset = dist_code >> 4;\n    const int xoffset = 8 - (dist_code & 0xf);\n    const int dist = yoffset * xsize + xoffset;\n    return (dist >= 1) ? dist : 1;  // dist<1 can happen if xsize is very small\n  }\n}\n\n//------------------------------------------------------------------------------\n// Decodes the next Huffman code from bit-stream.\n// VP8LFillBitWindow(br) needs to be called at minimum every second call\n// to ReadSymbol, in order to pre-fetch enough bits.\nstatic WEBP_INLINE int ReadSymbol(const HuffmanCode* table,\n                                  VP8LBitReader* const br) {\n  int nbits;\n  uint32_t val = VP8LPrefetchBits(br);\n  table += val & HUFFMAN_TABLE_MASK;\n  nbits = table->bits - HUFFMAN_TABLE_BITS;\n  if (nbits > 0) {\n    VP8LSetBitPos(br, br->bit_pos_ + HUFFMAN_TABLE_BITS);\n    val = VP8LPrefetchBits(br);\n    table += table->value;\n    table += val & ((1 << nbits) - 1);\n  }\n  VP8LSetBitPos(br, br->bit_pos_ + table->bits);\n  return table->value;\n}\n\n// Reads packed symbol depending on GREEN channel\n#define BITS_SPECIAL_MARKER 0x100  // something large enough (and a bit-mask)\n#define PACKED_NON_LITERAL_CODE 0  // must be < NUM_LITERAL_CODES\nstatic WEBP_INLINE int ReadPackedSymbols(const HTreeGroup* group,\n                                         VP8LBitReader* const br,\n                                         uint32_t* const dst) {\n  const uint32_t val = VP8LPrefetchBits(br) & (HUFFMAN_PACKED_TABLE_SIZE - 1);\n  const HuffmanCode32 code = group->packed_table[val];\n  assert(group->use_packed_table);\n  if (code.bits < BITS_SPECIAL_MARKER) {\n    VP8LSetBitPos(br, br->bit_pos_ + code.bits);\n    *dst = code.value;\n    return PACKED_NON_LITERAL_CODE;\n  } else {\n    VP8LSetBitPos(br, br->bit_pos_ + code.bits - BITS_SPECIAL_MARKER);\n    assert(code.value >= NUM_LITERAL_CODES);\n    return code.value;\n  }\n}\n\nstatic int AccumulateHCode(HuffmanCode hcode, int shift,\n                           HuffmanCode32* const huff) {\n  huff->bits += hcode.bits;\n  huff->value |= (uint32_t)hcode.value << shift;\n  assert(huff->bits <= HUFFMAN_TABLE_BITS);\n  return hcode.bits;\n}\n\nstatic void BuildPackedTable(HTreeGroup* const htree_group) {\n  uint32_t code;\n  for (code = 0; code < HUFFMAN_PACKED_TABLE_SIZE; ++code) {\n    uint32_t bits = code;\n    HuffmanCode32* const huff = &htree_group->packed_table[bits];\n    HuffmanCode hcode = htree_group->htrees[GREEN][bits];\n    if (hcode.value >= NUM_LITERAL_CODES) {\n      huff->bits = hcode.bits + BITS_SPECIAL_MARKER;\n      huff->value = hcode.value;\n    } else {\n      huff->bits = 0;\n      huff->value = 0;\n      bits >>= AccumulateHCode(hcode, 8, huff);\n      bits >>= AccumulateHCode(htree_group->htrees[RED][bits], 16, huff);\n      bits >>= AccumulateHCode(htree_group->htrees[BLUE][bits], 0, huff);\n      bits >>= AccumulateHCode(htree_group->htrees[ALPHA][bits], 24, huff);\n      (void)bits;\n    }\n  }\n}\n\nstatic int ReadHuffmanCodeLengths(\n    VP8LDecoder* const dec, const int* const code_length_code_lengths,\n    int num_symbols, int* const code_lengths) {\n  int ok = 0;\n  VP8LBitReader* const br = &dec->br_;\n  int symbol;\n  int max_symbol;\n  int prev_code_len = DEFAULT_CODE_LENGTH;\n  HuffmanTables tables;\n\n  if (!VP8LHuffmanTablesAllocate(1 << LENGTHS_TABLE_BITS, &tables) ||\n      !VP8LBuildHuffmanTable(&tables, LENGTHS_TABLE_BITS,\n                             code_length_code_lengths, NUM_CODE_LENGTH_CODES)) {\n    goto End;\n  }\n\n  if (VP8LReadBits(br, 1)) {    // use length\n    const int length_nbits = 2 + 2 * VP8LReadBits(br, 3);\n    max_symbol = 2 + VP8LReadBits(br, length_nbits);\n    if (max_symbol > num_symbols) {\n      goto End;\n    }\n  } else {\n    max_symbol = num_symbols;\n  }\n\n  symbol = 0;\n  while (symbol < num_symbols) {\n    const HuffmanCode* p;\n    int code_len;\n    if (max_symbol-- == 0) break;\n    VP8LFillBitWindow(br);\n    p = &tables.curr_segment->start[VP8LPrefetchBits(br) & LENGTHS_TABLE_MASK];\n    VP8LSetBitPos(br, br->bit_pos_ + p->bits);\n    code_len = p->value;\n    if (code_len < kCodeLengthLiterals) {\n      code_lengths[symbol++] = code_len;\n      if (code_len != 0) prev_code_len = code_len;\n    } else {\n      const int use_prev = (code_len == kCodeLengthRepeatCode);\n      const int slot = code_len - kCodeLengthLiterals;\n      const int extra_bits = kCodeLengthExtraBits[slot];\n      const int repeat_offset = kCodeLengthRepeatOffsets[slot];\n      int repeat = VP8LReadBits(br, extra_bits) + repeat_offset;\n      if (symbol + repeat > num_symbols) {\n        goto End;\n      } else {\n        const int length = use_prev ? prev_code_len : 0;\n        while (repeat-- > 0) code_lengths[symbol++] = length;\n      }\n    }\n  }\n  ok = 1;\n\n End:\n  VP8LHuffmanTablesDeallocate(&tables);\n  if (!ok) return VP8LSetError(dec, VP8_STATUS_BITSTREAM_ERROR);\n  return ok;\n}\n\n// 'code_lengths' is pre-allocated temporary buffer, used for creating Huffman\n// tree.\nstatic int ReadHuffmanCode(int alphabet_size, VP8LDecoder* const dec,\n                           int* const code_lengths,\n                           HuffmanTables* const table) {\n  int ok = 0;\n  int size = 0;\n  VP8LBitReader* const br = &dec->br_;\n  const int simple_code = VP8LReadBits(br, 1);\n\n  memset(code_lengths, 0, alphabet_size * sizeof(*code_lengths));\n\n  if (simple_code) {  // Read symbols, codes & code lengths directly.\n    const int num_symbols = VP8LReadBits(br, 1) + 1;\n    const int first_symbol_len_code = VP8LReadBits(br, 1);\n    // The first code is either 1 bit or 8 bit code.\n    int symbol = VP8LReadBits(br, (first_symbol_len_code == 0) ? 1 : 8);\n    code_lengths[symbol] = 1;\n    // The second code (if present), is always 8 bits long.\n    if (num_symbols == 2) {\n      symbol = VP8LReadBits(br, 8);\n      code_lengths[symbol] = 1;\n    }\n    ok = 1;\n  } else {  // Decode Huffman-coded code lengths.\n    int i;\n    int code_length_code_lengths[NUM_CODE_LENGTH_CODES] = { 0 };\n    const int num_codes = VP8LReadBits(br, 4) + 4;\n    assert(num_codes <= NUM_CODE_LENGTH_CODES);\n\n    for (i = 0; i < num_codes; ++i) {\n      code_length_code_lengths[kCodeLengthCodeOrder[i]] = VP8LReadBits(br, 3);\n    }\n    ok = ReadHuffmanCodeLengths(dec, code_length_code_lengths, alphabet_size,\n                                code_lengths);\n  }\n\n  ok = ok && !br->eos_;\n  if (ok) {\n    size = VP8LBuildHuffmanTable(table, HUFFMAN_TABLE_BITS,\n                                 code_lengths, alphabet_size);\n  }\n  if (!ok || size == 0) {\n    return VP8LSetError(dec, VP8_STATUS_BITSTREAM_ERROR);\n  }\n  return size;\n}\n\nstatic int ReadHuffmanCodes(VP8LDecoder* const dec, int xsize, int ysize,\n                            int color_cache_bits, int allow_recursion) {\n  int i, j;\n  VP8LBitReader* const br = &dec->br_;\n  VP8LMetadata* const hdr = &dec->hdr_;\n  uint32_t* huffman_image = NULL;\n  HTreeGroup* htree_groups = NULL;\n  HuffmanTables* huffman_tables = &hdr->huffman_tables_;\n  int num_htree_groups = 1;\n  int num_htree_groups_max = 1;\n  const int max_alphabet_size =\n      kAlphabetSize[0] + ((color_cache_bits > 0) ? 1 << color_cache_bits : 0);\n  int* code_lengths = NULL;\n  const int table_size = kTableSize[color_cache_bits];\n  int* mapping = NULL;\n  int ok = 0;\n\n  // Check the table has been 0 initialized (through InitMetadata).\n  assert(huffman_tables->root.start == NULL);\n  assert(huffman_tables->curr_segment == NULL);\n\n  if (allow_recursion && VP8LReadBits(br, 1)) {\n    // use meta Huffman codes.\n    const int huffman_precision = VP8LReadBits(br, 3) + 2;\n    const int huffman_xsize = VP8LSubSampleSize(xsize, huffman_precision);\n    const int huffman_ysize = VP8LSubSampleSize(ysize, huffman_precision);\n    const int huffman_pixs = huffman_xsize * huffman_ysize;\n    if (!DecodeImageStream(huffman_xsize, huffman_ysize, /*is_level0=*/0, dec,\n                           &huffman_image)) {\n      goto Error;\n    }\n    hdr->huffman_subsample_bits_ = huffman_precision;\n    for (i = 0; i < huffman_pixs; ++i) {\n      // The huffman data is stored in red and green bytes.\n      const int group = (huffman_image[i] >> 8) & 0xffff;\n      huffman_image[i] = group;\n      if (group >= num_htree_groups_max) {\n        num_htree_groups_max = group + 1;\n      }\n    }\n    // Check the validity of num_htree_groups_max. If it seems too big, use a\n    // smaller value for later. This will prevent big memory allocations to end\n    // up with a bad bitstream anyway.\n    // The value of 1000 is totally arbitrary. We know that num_htree_groups_max\n    // is smaller than (1 << 16) and should be smaller than the number of pixels\n    // (though the format allows it to be bigger).\n    if (num_htree_groups_max > 1000 || num_htree_groups_max > xsize * ysize) {\n      // Create a mapping from the used indices to the minimal set of used\n      // values [0, num_htree_groups)\n      mapping = (int*)WebPSafeMalloc(num_htree_groups_max, sizeof(*mapping));\n      if (mapping == NULL) {\n        VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);\n        goto Error;\n      }\n      // -1 means a value is unmapped, and therefore unused in the Huffman\n      // image.\n      memset(mapping, 0xff, num_htree_groups_max * sizeof(*mapping));\n      for (num_htree_groups = 0, i = 0; i < huffman_pixs; ++i) {\n        // Get the current mapping for the group and remap the Huffman image.\n        int* const mapped_group = &mapping[huffman_image[i]];\n        if (*mapped_group == -1) *mapped_group = num_htree_groups++;\n        huffman_image[i] = *mapped_group;\n      }\n    } else {\n      num_htree_groups = num_htree_groups_max;\n    }\n  }\n\n  if (br->eos_) goto Error;\n\n  code_lengths = (int*)WebPSafeCalloc((uint64_t)max_alphabet_size,\n                                      sizeof(*code_lengths));\n  htree_groups = VP8LHtreeGroupsNew(num_htree_groups);\n\n  if (htree_groups == NULL || code_lengths == NULL ||\n      !VP8LHuffmanTablesAllocate(num_htree_groups * table_size,\n                                 huffman_tables)) {\n    VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);\n    goto Error;\n  }\n\n  for (i = 0; i < num_htree_groups_max; ++i) {\n    // If the index \"i\" is unused in the Huffman image, just make sure the\n    // coefficients are valid but do not store them.\n    if (mapping != NULL && mapping[i] == -1) {\n      for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; ++j) {\n        int alphabet_size = kAlphabetSize[j];\n        if (j == 0 && color_cache_bits > 0) {\n          alphabet_size += (1 << color_cache_bits);\n        }\n        // Passing in NULL so that nothing gets filled.\n        if (!ReadHuffmanCode(alphabet_size, dec, code_lengths, NULL)) {\n          goto Error;\n        }\n      }\n    } else {\n      HTreeGroup* const htree_group =\n          &htree_groups[(mapping == NULL) ? i : mapping[i]];\n      HuffmanCode** const htrees = htree_group->htrees;\n      int size;\n      int total_size = 0;\n      int is_trivial_literal = 1;\n      int max_bits = 0;\n      for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; ++j) {\n        int alphabet_size = kAlphabetSize[j];\n        if (j == 0 && color_cache_bits > 0) {\n          alphabet_size += (1 << color_cache_bits);\n        }\n        size =\n            ReadHuffmanCode(alphabet_size, dec, code_lengths, huffman_tables);\n        htrees[j] = huffman_tables->curr_segment->curr_table;\n        if (size == 0) {\n          goto Error;\n        }\n        if (is_trivial_literal && kLiteralMap[j] == 1) {\n          is_trivial_literal = (htrees[j]->bits == 0);\n        }\n        total_size += htrees[j]->bits;\n        huffman_tables->curr_segment->curr_table += size;\n        if (j <= ALPHA) {\n          int local_max_bits = code_lengths[0];\n          int k;\n          for (k = 1; k < alphabet_size; ++k) {\n            if (code_lengths[k] > local_max_bits) {\n              local_max_bits = code_lengths[k];\n            }\n          }\n          max_bits += local_max_bits;\n        }\n      }\n      htree_group->is_trivial_literal = is_trivial_literal;\n      htree_group->is_trivial_code = 0;\n      if (is_trivial_literal) {\n        const int red = htrees[RED][0].value;\n        const int blue = htrees[BLUE][0].value;\n        const int alpha = htrees[ALPHA][0].value;\n        htree_group->literal_arb = ((uint32_t)alpha << 24) | (red << 16) | blue;\n        if (total_size == 0 && htrees[GREEN][0].value < NUM_LITERAL_CODES) {\n          htree_group->is_trivial_code = 1;\n          htree_group->literal_arb |= htrees[GREEN][0].value << 8;\n        }\n      }\n      htree_group->use_packed_table =\n          !htree_group->is_trivial_code && (max_bits < HUFFMAN_PACKED_BITS);\n      if (htree_group->use_packed_table) BuildPackedTable(htree_group);\n    }\n  }\n  ok = 1;\n\n  // All OK. Finalize pointers.\n  hdr->huffman_image_ = huffman_image;\n  hdr->num_htree_groups_ = num_htree_groups;\n  hdr->htree_groups_ = htree_groups;\n\n Error:\n  WebPSafeFree(code_lengths);\n  WebPSafeFree(mapping);\n  if (!ok) {\n    WebPSafeFree(huffman_image);\n    VP8LHuffmanTablesDeallocate(huffman_tables);\n    VP8LHtreeGroupsFree(htree_groups);\n  }\n  return ok;\n}\n\n//------------------------------------------------------------------------------\n// Scaling.\n\n#if !defined(WEBP_REDUCE_SIZE)\nstatic int AllocateAndInitRescaler(VP8LDecoder* const dec, VP8Io* const io) {\n  const int num_channels = 4;\n  const int in_width = io->mb_w;\n  const int out_width = io->scaled_width;\n  const int in_height = io->mb_h;\n  const int out_height = io->scaled_height;\n  const uint64_t work_size = 2 * num_channels * (uint64_t)out_width;\n  rescaler_t* work;        // Rescaler work area.\n  const uint64_t scaled_data_size = (uint64_t)out_width;\n  uint32_t* scaled_data;  // Temporary storage for scaled BGRA data.\n  const uint64_t memory_size = sizeof(*dec->rescaler) +\n                               work_size * sizeof(*work) +\n                               scaled_data_size * sizeof(*scaled_data);\n  uint8_t* memory = (uint8_t*)WebPSafeMalloc(memory_size, sizeof(*memory));\n  if (memory == NULL) {\n    return VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);\n  }\n  assert(dec->rescaler_memory == NULL);\n  dec->rescaler_memory = memory;\n\n  dec->rescaler = (WebPRescaler*)memory;\n  memory += sizeof(*dec->rescaler);\n  work = (rescaler_t*)memory;\n  memory += work_size * sizeof(*work);\n  scaled_data = (uint32_t*)memory;\n\n  if (!WebPRescalerInit(dec->rescaler, in_width, in_height,\n                        (uint8_t*)scaled_data, out_width, out_height,\n                        0, num_channels, work)) {\n    return 0;\n  }\n  return 1;\n}\n#endif   // WEBP_REDUCE_SIZE\n\n//------------------------------------------------------------------------------\n// Export to ARGB\n\n#if !defined(WEBP_REDUCE_SIZE)\n\n// We have special \"export\" function since we need to convert from BGRA\nstatic int Export(WebPRescaler* const rescaler, WEBP_CSP_MODE colorspace,\n                  int rgba_stride, uint8_t* const rgba) {\n  uint32_t* const src = (uint32_t*)rescaler->dst;\n  uint8_t* dst = rgba;\n  const int dst_width = rescaler->dst_width;\n  int num_lines_out = 0;\n  while (WebPRescalerHasPendingOutput(rescaler)) {\n    WebPRescalerExportRow(rescaler);\n    WebPMultARGBRow(src, dst_width, 1);\n    VP8LConvertFromBGRA(src, dst_width, colorspace, dst);\n    dst += rgba_stride;\n    ++num_lines_out;\n  }\n  return num_lines_out;\n}\n\n// Emit scaled rows.\nstatic int EmitRescaledRowsRGBA(const VP8LDecoder* const dec,\n                                uint8_t* in, int in_stride, int mb_h,\n                                uint8_t* const out, int out_stride) {\n  const WEBP_CSP_MODE colorspace = dec->output_->colorspace;\n  int num_lines_in = 0;\n  int num_lines_out = 0;\n  while (num_lines_in < mb_h) {\n    uint8_t* const row_in = in + (uint64_t)num_lines_in * in_stride;\n    uint8_t* const row_out = out + (uint64_t)num_lines_out * out_stride;\n    const int lines_left = mb_h - num_lines_in;\n    const int needed_lines = WebPRescaleNeededLines(dec->rescaler, lines_left);\n    int lines_imported;\n    assert(needed_lines > 0 && needed_lines <= lines_left);\n    WebPMultARGBRows(row_in, in_stride,\n                     dec->rescaler->src_width, needed_lines, 0);\n    lines_imported =\n        WebPRescalerImport(dec->rescaler, lines_left, row_in, in_stride);\n    assert(lines_imported == needed_lines);\n    num_lines_in += lines_imported;\n    num_lines_out += Export(dec->rescaler, colorspace, out_stride, row_out);\n  }\n  return num_lines_out;\n}\n\n#endif   // WEBP_REDUCE_SIZE\n\n// Emit rows without any scaling.\nstatic int EmitRows(WEBP_CSP_MODE colorspace,\n                    const uint8_t* row_in, int in_stride,\n                    int mb_w, int mb_h,\n                    uint8_t* const out, int out_stride) {\n  int lines = mb_h;\n  uint8_t* row_out = out;\n  while (lines-- > 0) {\n    VP8LConvertFromBGRA((const uint32_t*)row_in, mb_w, colorspace, row_out);\n    row_in += in_stride;\n    row_out += out_stride;\n  }\n  return mb_h;  // Num rows out == num rows in.\n}\n\n//------------------------------------------------------------------------------\n// Export to YUVA\n\nstatic void ConvertToYUVA(const uint32_t* const src, int width, int y_pos,\n                          const WebPDecBuffer* const output) {\n  const WebPYUVABuffer* const buf = &output->u.YUVA;\n\n  // first, the luma plane\n  WebPConvertARGBToY(src, buf->y + y_pos * buf->y_stride, width);\n\n  // then U/V planes\n  {\n    uint8_t* const u = buf->u + (y_pos >> 1) * buf->u_stride;\n    uint8_t* const v = buf->v + (y_pos >> 1) * buf->v_stride;\n    // even lines: store values\n    // odd lines: average with previous values\n    WebPConvertARGBToUV(src, u, v, width, !(y_pos & 1));\n  }\n  // Lastly, store alpha if needed.\n  if (buf->a != NULL) {\n    uint8_t* const a = buf->a + y_pos * buf->a_stride;\n#if defined(WORDS_BIGENDIAN)\n    WebPExtractAlpha((uint8_t*)src + 0, 0, width, 1, a, 0);\n#else\n    WebPExtractAlpha((uint8_t*)src + 3, 0, width, 1, a, 0);\n#endif\n  }\n}\n\nstatic int ExportYUVA(const VP8LDecoder* const dec, int y_pos) {\n  WebPRescaler* const rescaler = dec->rescaler;\n  uint32_t* const src = (uint32_t*)rescaler->dst;\n  const int dst_width = rescaler->dst_width;\n  int num_lines_out = 0;\n  while (WebPRescalerHasPendingOutput(rescaler)) {\n    WebPRescalerExportRow(rescaler);\n    WebPMultARGBRow(src, dst_width, 1);\n    ConvertToYUVA(src, dst_width, y_pos, dec->output_);\n    ++y_pos;\n    ++num_lines_out;\n  }\n  return num_lines_out;\n}\n\nstatic int EmitRescaledRowsYUVA(const VP8LDecoder* const dec,\n                                uint8_t* in, int in_stride, int mb_h) {\n  int num_lines_in = 0;\n  int y_pos = dec->last_out_row_;\n  while (num_lines_in < mb_h) {\n    const int lines_left = mb_h - num_lines_in;\n    const int needed_lines = WebPRescaleNeededLines(dec->rescaler, lines_left);\n    int lines_imported;\n    WebPMultARGBRows(in, in_stride, dec->rescaler->src_width, needed_lines, 0);\n    lines_imported =\n        WebPRescalerImport(dec->rescaler, lines_left, in, in_stride);\n    assert(lines_imported == needed_lines);\n    num_lines_in += lines_imported;\n    in += needed_lines * in_stride;\n    y_pos += ExportYUVA(dec, y_pos);\n  }\n  return y_pos;\n}\n\nstatic int EmitRowsYUVA(const VP8LDecoder* const dec,\n                        const uint8_t* in, int in_stride,\n                        int mb_w, int num_rows) {\n  int y_pos = dec->last_out_row_;\n  while (num_rows-- > 0) {\n    ConvertToYUVA((const uint32_t*)in, mb_w, y_pos, dec->output_);\n    in += in_stride;\n    ++y_pos;\n  }\n  return y_pos;\n}\n\n//------------------------------------------------------------------------------\n// Cropping.\n\n// Sets io->mb_y, io->mb_h & io->mb_w according to start row, end row and\n// crop options. Also updates the input data pointer, so that it points to the\n// start of the cropped window. Note that pixels are in ARGB format even if\n// 'in_data' is uint8_t*.\n// Returns true if the crop window is not empty.\nstatic int SetCropWindow(VP8Io* const io, int y_start, int y_end,\n                         uint8_t** const in_data, int pixel_stride) {\n  assert(y_start < y_end);\n  assert(io->crop_left < io->crop_right);\n  if (y_end > io->crop_bottom) {\n    y_end = io->crop_bottom;  // make sure we don't overflow on last row.\n  }\n  if (y_start < io->crop_top) {\n    const int delta = io->crop_top - y_start;\n    y_start = io->crop_top;\n    *in_data += delta * pixel_stride;\n  }\n  if (y_start >= y_end) return 0;  // Crop window is empty.\n\n  *in_data += io->crop_left * sizeof(uint32_t);\n\n  io->mb_y = y_start - io->crop_top;\n  io->mb_w = io->crop_right - io->crop_left;\n  io->mb_h = y_end - y_start;\n  return 1;  // Non-empty crop window.\n}\n\n//------------------------------------------------------------------------------\n\nstatic WEBP_INLINE int GetMetaIndex(\n    const uint32_t* const image, int xsize, int bits, int x, int y) {\n  if (bits == 0) return 0;\n  return image[xsize * (y >> bits) + (x >> bits)];\n}\n\nstatic WEBP_INLINE HTreeGroup* GetHtreeGroupForPos(VP8LMetadata* const hdr,\n                                                   int x, int y) {\n  const int meta_index = GetMetaIndex(hdr->huffman_image_, hdr->huffman_xsize_,\n                                      hdr->huffman_subsample_bits_, x, y);\n  assert(meta_index < hdr->num_htree_groups_);\n  return hdr->htree_groups_ + meta_index;\n}\n\n//------------------------------------------------------------------------------\n// Main loop, with custom row-processing function\n\ntypedef void (*ProcessRowsFunc)(VP8LDecoder* const dec, int row);\n\nstatic void ApplyInverseTransforms(VP8LDecoder* const dec,\n                                   int start_row, int num_rows,\n                                   const uint32_t* const rows) {\n  int n = dec->next_transform_;\n  const int cache_pixs = dec->width_ * num_rows;\n  const int end_row = start_row + num_rows;\n  const uint32_t* rows_in = rows;\n  uint32_t* const rows_out = dec->argb_cache_;\n\n  // Inverse transforms.\n  while (n-- > 0) {\n    VP8LTransform* const transform = &dec->transforms_[n];\n    VP8LInverseTransform(transform, start_row, end_row, rows_in, rows_out);\n    rows_in = rows_out;\n  }\n  if (rows_in != rows_out) {\n    // No transform called, hence just copy.\n    memcpy(rows_out, rows_in, cache_pixs * sizeof(*rows_out));\n  }\n}\n\n// Processes (transforms, scales & color-converts) the rows decoded after the\n// last call.\nstatic void ProcessRows(VP8LDecoder* const dec, int row) {\n  const uint32_t* const rows = dec->pixels_ + dec->width_ * dec->last_row_;\n  const int num_rows = row - dec->last_row_;\n\n  assert(row <= dec->io_->crop_bottom);\n  // We can't process more than NUM_ARGB_CACHE_ROWS at a time (that's the size\n  // of argb_cache_), but we currently don't need more than that.\n  assert(num_rows <= NUM_ARGB_CACHE_ROWS);\n  if (num_rows > 0) {    // Emit output.\n    VP8Io* const io = dec->io_;\n    uint8_t* rows_data = (uint8_t*)dec->argb_cache_;\n    const int in_stride = io->width * sizeof(uint32_t);  // in unit of RGBA\n    ApplyInverseTransforms(dec, dec->last_row_, num_rows, rows);\n    if (!SetCropWindow(io, dec->last_row_, row, &rows_data, in_stride)) {\n      // Nothing to output (this time).\n    } else {\n      const WebPDecBuffer* const output = dec->output_;\n      if (WebPIsRGBMode(output->colorspace)) {  // convert to RGBA\n        const WebPRGBABuffer* const buf = &output->u.RGBA;\n        uint8_t* const rgba =\n            buf->rgba + (int64_t)dec->last_out_row_ * buf->stride;\n        const int num_rows_out =\n#if !defined(WEBP_REDUCE_SIZE)\n         io->use_scaling ?\n            EmitRescaledRowsRGBA(dec, rows_data, in_stride, io->mb_h,\n                                 rgba, buf->stride) :\n#endif  // WEBP_REDUCE_SIZE\n            EmitRows(output->colorspace, rows_data, in_stride,\n                     io->mb_w, io->mb_h, rgba, buf->stride);\n        // Update 'last_out_row_'.\n        dec->last_out_row_ += num_rows_out;\n      } else {                              // convert to YUVA\n        dec->last_out_row_ = io->use_scaling ?\n            EmitRescaledRowsYUVA(dec, rows_data, in_stride, io->mb_h) :\n            EmitRowsYUVA(dec, rows_data, in_stride, io->mb_w, io->mb_h);\n      }\n      assert(dec->last_out_row_ <= output->height);\n    }\n  }\n\n  // Update 'last_row_'.\n  dec->last_row_ = row;\n  assert(dec->last_row_ <= dec->height_);\n}\n\n// Row-processing for the special case when alpha data contains only one\n// transform (color indexing), and trivial non-green literals.\nstatic int Is8bOptimizable(const VP8LMetadata* const hdr) {\n  int i;\n  if (hdr->color_cache_size_ > 0) return 0;\n  // When the Huffman tree contains only one symbol, we can skip the\n  // call to ReadSymbol() for red/blue/alpha channels.\n  for (i = 0; i < hdr->num_htree_groups_; ++i) {\n    HuffmanCode** const htrees = hdr->htree_groups_[i].htrees;\n    if (htrees[RED][0].bits > 0) return 0;\n    if (htrees[BLUE][0].bits > 0) return 0;\n    if (htrees[ALPHA][0].bits > 0) return 0;\n  }\n  return 1;\n}\n\nstatic void AlphaApplyFilter(ALPHDecoder* const alph_dec,\n                             int first_row, int last_row,\n                             uint8_t* out, int stride) {\n  if (alph_dec->filter_ != WEBP_FILTER_NONE) {\n    int y;\n    const uint8_t* prev_line = alph_dec->prev_line_;\n    assert(WebPUnfilters[alph_dec->filter_] != NULL);\n    for (y = first_row; y < last_row; ++y) {\n      WebPUnfilters[alph_dec->filter_](prev_line, out, out, stride);\n      prev_line = out;\n      out += stride;\n    }\n    alph_dec->prev_line_ = prev_line;\n  }\n}\n\nstatic void ExtractPalettedAlphaRows(VP8LDecoder* const dec, int last_row) {\n  // For vertical and gradient filtering, we need to decode the part above the\n  // crop_top row, in order to have the correct spatial predictors.\n  ALPHDecoder* const alph_dec = (ALPHDecoder*)dec->io_->opaque;\n  const int top_row =\n      (alph_dec->filter_ == WEBP_FILTER_NONE ||\n       alph_dec->filter_ == WEBP_FILTER_HORIZONTAL) ? dec->io_->crop_top\n                                                    : dec->last_row_;\n  const int first_row = (dec->last_row_ < top_row) ? top_row : dec->last_row_;\n  assert(last_row <= dec->io_->crop_bottom);\n  if (last_row > first_row) {\n    // Special method for paletted alpha data. We only process the cropped area.\n    const int width = dec->io_->width;\n    uint8_t* out = alph_dec->output_ + width * first_row;\n    const uint8_t* const in =\n      (uint8_t*)dec->pixels_ + dec->width_ * first_row;\n    VP8LTransform* const transform = &dec->transforms_[0];\n    assert(dec->next_transform_ == 1);\n    assert(transform->type_ == COLOR_INDEXING_TRANSFORM);\n    VP8LColorIndexInverseTransformAlpha(transform, first_row, last_row,\n                                        in, out);\n    AlphaApplyFilter(alph_dec, first_row, last_row, out, width);\n  }\n  dec->last_row_ = dec->last_out_row_ = last_row;\n}\n\n//------------------------------------------------------------------------------\n// Helper functions for fast pattern copy (8b and 32b)\n\n// cyclic rotation of pattern word\nstatic WEBP_INLINE uint32_t Rotate8b(uint32_t V) {\n#if defined(WORDS_BIGENDIAN)\n  return ((V & 0xff000000u) >> 24) | (V << 8);\n#else\n  return ((V & 0xffu) << 24) | (V >> 8);\n#endif\n}\n\n// copy 1, 2 or 4-bytes pattern\nstatic WEBP_INLINE void CopySmallPattern8b(const uint8_t* src, uint8_t* dst,\n                                           int length, uint32_t pattern) {\n  int i;\n  // align 'dst' to 4-bytes boundary. Adjust the pattern along the way.\n  while ((uintptr_t)dst & 3) {\n    *dst++ = *src++;\n    pattern = Rotate8b(pattern);\n    --length;\n  }\n  // Copy the pattern 4 bytes at a time.\n  for (i = 0; i < (length >> 2); ++i) {\n    ((uint32_t*)dst)[i] = pattern;\n  }\n  // Finish with left-overs. 'pattern' is still correctly positioned,\n  // so no Rotate8b() call is needed.\n  for (i <<= 2; i < length; ++i) {\n    dst[i] = src[i];\n  }\n}\n\nstatic WEBP_INLINE void CopyBlock8b(uint8_t* const dst, int dist, int length) {\n  const uint8_t* src = dst - dist;\n  if (length >= 8) {\n    uint32_t pattern = 0;\n    switch (dist) {\n      case 1:\n        pattern = src[0];\n#if defined(__arm__) || defined(_M_ARM)   // arm doesn't like multiply that much\n        pattern |= pattern << 8;\n        pattern |= pattern << 16;\n#elif defined(WEBP_USE_MIPS_DSP_R2)\n        __asm__ volatile (\"replv.qb %0, %0\" : \"+r\"(pattern));\n#else\n        pattern = 0x01010101u * pattern;\n#endif\n        break;\n      case 2:\n#if !defined(WORDS_BIGENDIAN)\n        memcpy(&pattern, src, sizeof(uint16_t));\n#else\n        pattern = ((uint32_t)src[0] << 8) | src[1];\n#endif\n#if defined(__arm__) || defined(_M_ARM)\n        pattern |= pattern << 16;\n#elif defined(WEBP_USE_MIPS_DSP_R2)\n        __asm__ volatile (\"replv.ph %0, %0\" : \"+r\"(pattern));\n#else\n        pattern = 0x00010001u * pattern;\n#endif\n        break;\n      case 4:\n        memcpy(&pattern, src, sizeof(uint32_t));\n        break;\n      default:\n        goto Copy;\n    }\n    CopySmallPattern8b(src, dst, length, pattern);\n    return;\n  }\n Copy:\n  if (dist >= length) {  // no overlap -> use memcpy()\n    memcpy(dst, src, length * sizeof(*dst));\n  } else {\n    int i;\n    for (i = 0; i < length; ++i) dst[i] = src[i];\n  }\n}\n\n// copy pattern of 1 or 2 uint32_t's\nstatic WEBP_INLINE void CopySmallPattern32b(const uint32_t* src,\n                                            uint32_t* dst,\n                                            int length, uint64_t pattern) {\n  int i;\n  if ((uintptr_t)dst & 4) {           // Align 'dst' to 8-bytes boundary.\n    *dst++ = *src++;\n    pattern = (pattern >> 32) | (pattern << 32);\n    --length;\n  }\n  assert(0 == ((uintptr_t)dst & 7));\n  for (i = 0; i < (length >> 1); ++i) {\n    ((uint64_t*)dst)[i] = pattern;    // Copy the pattern 8 bytes at a time.\n  }\n  if (length & 1) {                   // Finish with left-over.\n    dst[i << 1] = src[i << 1];\n  }\n}\n\nstatic WEBP_INLINE void CopyBlock32b(uint32_t* const dst,\n                                     int dist, int length) {\n  const uint32_t* const src = dst - dist;\n  if (dist <= 2 && length >= 4 && ((uintptr_t)dst & 3) == 0) {\n    uint64_t pattern;\n    if (dist == 1) {\n      pattern = (uint64_t)src[0];\n      pattern |= pattern << 32;\n    } else {\n      memcpy(&pattern, src, sizeof(pattern));\n    }\n    CopySmallPattern32b(src, dst, length, pattern);\n  } else if (dist >= length) {  // no overlap\n    memcpy(dst, src, length * sizeof(*dst));\n  } else {\n    int i;\n    for (i = 0; i < length; ++i) dst[i] = src[i];\n  }\n}\n\n//------------------------------------------------------------------------------\n\nstatic int DecodeAlphaData(VP8LDecoder* const dec, uint8_t* const data,\n                           int width, int height, int last_row) {\n  int ok = 1;\n  int row = dec->last_pixel_ / width;\n  int col = dec->last_pixel_ % width;\n  VP8LBitReader* const br = &dec->br_;\n  VP8LMetadata* const hdr = &dec->hdr_;\n  int pos = dec->last_pixel_;         // current position\n  const int end = width * height;     // End of data\n  const int last = width * last_row;  // Last pixel to decode\n  const int len_code_limit = NUM_LITERAL_CODES + NUM_LENGTH_CODES;\n  const int mask = hdr->huffman_mask_;\n  const HTreeGroup* htree_group =\n      (pos < last) ? GetHtreeGroupForPos(hdr, col, row) : NULL;\n  assert(pos <= end);\n  assert(last_row <= height);\n  assert(Is8bOptimizable(hdr));\n\n  while (!br->eos_ && pos < last) {\n    int code;\n    // Only update when changing tile.\n    if ((col & mask) == 0) {\n      htree_group = GetHtreeGroupForPos(hdr, col, row);\n    }\n    assert(htree_group != NULL);\n    VP8LFillBitWindow(br);\n    code = ReadSymbol(htree_group->htrees[GREEN], br);\n    if (code < NUM_LITERAL_CODES) {  // Literal\n      data[pos] = code;\n      ++pos;\n      ++col;\n      if (col >= width) {\n        col = 0;\n        ++row;\n        if (row <= last_row && (row % NUM_ARGB_CACHE_ROWS == 0)) {\n          ExtractPalettedAlphaRows(dec, row);\n        }\n      }\n    } else if (code < len_code_limit) {  // Backward reference\n      int dist_code, dist;\n      const int length_sym = code - NUM_LITERAL_CODES;\n      const int length = GetCopyLength(length_sym, br);\n      const int dist_symbol = ReadSymbol(htree_group->htrees[DIST], br);\n      VP8LFillBitWindow(br);\n      dist_code = GetCopyDistance(dist_symbol, br);\n      dist = PlaneCodeToDistance(width, dist_code);\n      if (pos >= dist && end - pos >= length) {\n        CopyBlock8b(data + pos, dist, length);\n      } else {\n        ok = 0;\n        goto End;\n      }\n      pos += length;\n      col += length;\n      while (col >= width) {\n        col -= width;\n        ++row;\n        if (row <= last_row && (row % NUM_ARGB_CACHE_ROWS == 0)) {\n          ExtractPalettedAlphaRows(dec, row);\n        }\n      }\n      if (pos < last && (col & mask)) {\n        htree_group = GetHtreeGroupForPos(hdr, col, row);\n      }\n    } else {  // Not reached\n      ok = 0;\n      goto End;\n    }\n    br->eos_ = VP8LIsEndOfStream(br);\n  }\n  // Process the remaining rows corresponding to last row-block.\n  ExtractPalettedAlphaRows(dec, row > last_row ? last_row : row);\n\n End:\n  br->eos_ = VP8LIsEndOfStream(br);\n  if (!ok || (br->eos_ && pos < end)) {\n    return VP8LSetError(\n        dec, br->eos_ ? VP8_STATUS_SUSPENDED : VP8_STATUS_BITSTREAM_ERROR);\n  }\n  dec->last_pixel_ = pos;\n  return ok;\n}\n\nstatic void SaveState(VP8LDecoder* const dec, int last_pixel) {\n  assert(dec->incremental_);\n  dec->saved_br_ = dec->br_;\n  dec->saved_last_pixel_ = last_pixel;\n  if (dec->hdr_.color_cache_size_ > 0) {\n    VP8LColorCacheCopy(&dec->hdr_.color_cache_, &dec->hdr_.saved_color_cache_);\n  }\n}\n\nstatic void RestoreState(VP8LDecoder* const dec) {\n  assert(dec->br_.eos_);\n  dec->status_ = VP8_STATUS_SUSPENDED;\n  dec->br_ = dec->saved_br_;\n  dec->last_pixel_ = dec->saved_last_pixel_;\n  if (dec->hdr_.color_cache_size_ > 0) {\n    VP8LColorCacheCopy(&dec->hdr_.saved_color_cache_, &dec->hdr_.color_cache_);\n  }\n}\n\n#define SYNC_EVERY_N_ROWS 8  // minimum number of rows between check-points\nstatic int DecodeImageData(VP8LDecoder* const dec, uint32_t* const data,\n                           int width, int height, int last_row,\n                           ProcessRowsFunc process_func) {\n  int row = dec->last_pixel_ / width;\n  int col = dec->last_pixel_ % width;\n  VP8LBitReader* const br = &dec->br_;\n  VP8LMetadata* const hdr = &dec->hdr_;\n  uint32_t* src = data + dec->last_pixel_;\n  uint32_t* last_cached = src;\n  uint32_t* const src_end = data + width * height;     // End of data\n  uint32_t* const src_last = data + width * last_row;  // Last pixel to decode\n  const int len_code_limit = NUM_LITERAL_CODES + NUM_LENGTH_CODES;\n  const int color_cache_limit = len_code_limit + hdr->color_cache_size_;\n  int next_sync_row = dec->incremental_ ? row : 1 << 24;\n  VP8LColorCache* const color_cache =\n      (hdr->color_cache_size_ > 0) ? &hdr->color_cache_ : NULL;\n  const int mask = hdr->huffman_mask_;\n  const HTreeGroup* htree_group =\n      (src < src_last) ? GetHtreeGroupForPos(hdr, col, row) : NULL;\n  assert(dec->last_row_ < last_row);\n  assert(src_last <= src_end);\n\n  while (src < src_last) {\n    int code;\n    if (row >= next_sync_row) {\n      SaveState(dec, (int)(src - data));\n      next_sync_row = row + SYNC_EVERY_N_ROWS;\n    }\n    // Only update when changing tile. Note we could use this test:\n    // if \"((((prev_col ^ col) | prev_row ^ row)) > mask)\" -> tile changed\n    // but that's actually slower and needs storing the previous col/row.\n    if ((col & mask) == 0) {\n      htree_group = GetHtreeGroupForPos(hdr, col, row);\n    }\n    assert(htree_group != NULL);\n    if (htree_group->is_trivial_code) {\n      *src = htree_group->literal_arb;\n      goto AdvanceByOne;\n    }\n    VP8LFillBitWindow(br);\n    if (htree_group->use_packed_table) {\n      code = ReadPackedSymbols(htree_group, br, src);\n      if (VP8LIsEndOfStream(br)) break;\n      if (code == PACKED_NON_LITERAL_CODE) goto AdvanceByOne;\n    } else {\n      code = ReadSymbol(htree_group->htrees[GREEN], br);\n    }\n    if (VP8LIsEndOfStream(br)) break;\n    if (code < NUM_LITERAL_CODES) {  // Literal\n      if (htree_group->is_trivial_literal) {\n        *src = htree_group->literal_arb | (code << 8);\n      } else {\n        int red, blue, alpha;\n        red = ReadSymbol(htree_group->htrees[RED], br);\n        VP8LFillBitWindow(br);\n        blue = ReadSymbol(htree_group->htrees[BLUE], br);\n        alpha = ReadSymbol(htree_group->htrees[ALPHA], br);\n        if (VP8LIsEndOfStream(br)) break;\n        *src = ((uint32_t)alpha << 24) | (red << 16) | (code << 8) | blue;\n      }\n    AdvanceByOne:\n      ++src;\n      ++col;\n      if (col >= width) {\n        col = 0;\n        ++row;\n        if (process_func != NULL) {\n          if (row <= last_row && (row % NUM_ARGB_CACHE_ROWS == 0)) {\n            process_func(dec, row);\n          }\n        }\n        if (color_cache != NULL) {\n          while (last_cached < src) {\n            VP8LColorCacheInsert(color_cache, *last_cached++);\n          }\n        }\n      }\n    } else if (code < len_code_limit) {  // Backward reference\n      int dist_code, dist;\n      const int length_sym = code - NUM_LITERAL_CODES;\n      const int length = GetCopyLength(length_sym, br);\n      const int dist_symbol = ReadSymbol(htree_group->htrees[DIST], br);\n      VP8LFillBitWindow(br);\n      dist_code = GetCopyDistance(dist_symbol, br);\n      dist = PlaneCodeToDistance(width, dist_code);\n\n      if (VP8LIsEndOfStream(br)) break;\n      if (src - data < (ptrdiff_t)dist || src_end - src < (ptrdiff_t)length) {\n        goto Error;\n      } else {\n        CopyBlock32b(src, dist, length);\n      }\n      src += length;\n      col += length;\n      while (col >= width) {\n        col -= width;\n        ++row;\n        if (process_func != NULL) {\n          if (row <= last_row && (row % NUM_ARGB_CACHE_ROWS == 0)) {\n            process_func(dec, row);\n          }\n        }\n      }\n      // Because of the check done above (before 'src' was incremented by\n      // 'length'), the following holds true.\n      assert(src <= src_end);\n      if (col & mask) htree_group = GetHtreeGroupForPos(hdr, col, row);\n      if (color_cache != NULL) {\n        while (last_cached < src) {\n          VP8LColorCacheInsert(color_cache, *last_cached++);\n        }\n      }\n    } else if (code < color_cache_limit) {  // Color cache\n      const int key = code - len_code_limit;\n      assert(color_cache != NULL);\n      while (last_cached < src) {\n        VP8LColorCacheInsert(color_cache, *last_cached++);\n      }\n      *src = VP8LColorCacheLookup(color_cache, key);\n      goto AdvanceByOne;\n    } else {  // Not reached\n      goto Error;\n    }\n  }\n\n  br->eos_ = VP8LIsEndOfStream(br);\n  if (dec->incremental_ && br->eos_ && src < src_end) {\n    RestoreState(dec);\n  } else if (!br->eos_) {\n    // Process the remaining rows corresponding to last row-block.\n    if (process_func != NULL) {\n      process_func(dec, row > last_row ? last_row : row);\n    }\n    dec->status_ = VP8_STATUS_OK;\n    dec->last_pixel_ = (int)(src - data);  // end-of-scan marker\n  } else {\n    // if not incremental, and we are past the end of buffer (eos_=1), then this\n    // is a real bitstream error.\n    goto Error;\n  }\n  return 1;\n\n Error:\n  return VP8LSetError(dec, VP8_STATUS_BITSTREAM_ERROR);\n}\n\n// -----------------------------------------------------------------------------\n// VP8LTransform\n\nstatic void ClearTransform(VP8LTransform* const transform) {\n  WebPSafeFree(transform->data_);\n  transform->data_ = NULL;\n}\n\n// For security reason, we need to remap the color map to span\n// the total possible bundled values, and not just the num_colors.\nstatic int ExpandColorMap(int num_colors, VP8LTransform* const transform) {\n  int i;\n  const int final_num_colors = 1 << (8 >> transform->bits_);\n  uint32_t* const new_color_map =\n      (uint32_t*)WebPSafeMalloc((uint64_t)final_num_colors,\n                                sizeof(*new_color_map));\n  if (new_color_map == NULL) {\n    return 0;\n  } else {\n    uint8_t* const data = (uint8_t*)transform->data_;\n    uint8_t* const new_data = (uint8_t*)new_color_map;\n    new_color_map[0] = transform->data_[0];\n    for (i = 4; i < 4 * num_colors; ++i) {\n      // Equivalent to VP8LAddPixels(), on a byte-basis.\n      new_data[i] = (data[i] + new_data[i - 4]) & 0xff;\n    }\n    for (; i < 4 * final_num_colors; ++i) {\n      new_data[i] = 0;  // black tail.\n    }\n    WebPSafeFree(transform->data_);\n    transform->data_ = new_color_map;\n  }\n  return 1;\n}\n\nstatic int ReadTransform(int* const xsize, int const* ysize,\n                         VP8LDecoder* const dec) {\n  int ok = 1;\n  VP8LBitReader* const br = &dec->br_;\n  VP8LTransform* transform = &dec->transforms_[dec->next_transform_];\n  const VP8LImageTransformType type =\n      (VP8LImageTransformType)VP8LReadBits(br, 2);\n\n  // Each transform type can only be present once in the stream.\n  if (dec->transforms_seen_ & (1U << type)) {\n    return 0;  // Already there, let's not accept the second same transform.\n  }\n  dec->transforms_seen_ |= (1U << type);\n\n  transform->type_ = type;\n  transform->xsize_ = *xsize;\n  transform->ysize_ = *ysize;\n  transform->data_ = NULL;\n  ++dec->next_transform_;\n  assert(dec->next_transform_ <= NUM_TRANSFORMS);\n\n  switch (type) {\n    case PREDICTOR_TRANSFORM:\n    case CROSS_COLOR_TRANSFORM:\n      transform->bits_ = VP8LReadBits(br, 3) + 2;\n      ok = DecodeImageStream(VP8LSubSampleSize(transform->xsize_,\n                                               transform->bits_),\n                             VP8LSubSampleSize(transform->ysize_,\n                                               transform->bits_),\n                             /*is_level0=*/0, dec, &transform->data_);\n      break;\n    case COLOR_INDEXING_TRANSFORM: {\n       const int num_colors = VP8LReadBits(br, 8) + 1;\n       const int bits = (num_colors > 16) ? 0\n                      : (num_colors > 4) ? 1\n                      : (num_colors > 2) ? 2\n                      : 3;\n       *xsize = VP8LSubSampleSize(transform->xsize_, bits);\n       transform->bits_ = bits;\n       ok = DecodeImageStream(num_colors, /*ysize=*/1, /*is_level0=*/0, dec,\n                              &transform->data_);\n       if (ok && !ExpandColorMap(num_colors, transform)) {\n         return VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);\n       }\n      break;\n    }\n    case SUBTRACT_GREEN_TRANSFORM:\n      break;\n    default:\n      assert(0);    // can't happen\n      break;\n  }\n\n  return ok;\n}\n\n// -----------------------------------------------------------------------------\n// VP8LMetadata\n\nstatic void InitMetadata(VP8LMetadata* const hdr) {\n  assert(hdr != NULL);\n  memset(hdr, 0, sizeof(*hdr));\n}\n\nstatic void ClearMetadata(VP8LMetadata* const hdr) {\n  assert(hdr != NULL);\n\n  WebPSafeFree(hdr->huffman_image_);\n  VP8LHuffmanTablesDeallocate(&hdr->huffman_tables_);\n  VP8LHtreeGroupsFree(hdr->htree_groups_);\n  VP8LColorCacheClear(&hdr->color_cache_);\n  VP8LColorCacheClear(&hdr->saved_color_cache_);\n  InitMetadata(hdr);\n}\n\n// -----------------------------------------------------------------------------\n// VP8LDecoder\n\nVP8LDecoder* VP8LNew(void) {\n  VP8LDecoder* const dec = (VP8LDecoder*)WebPSafeCalloc(1ULL, sizeof(*dec));\n  if (dec == NULL) return NULL;\n  dec->status_ = VP8_STATUS_OK;\n  dec->state_ = READ_DIM;\n\n  VP8LDspInit();  // Init critical function pointers.\n\n  return dec;\n}\n\nvoid VP8LClear(VP8LDecoder* const dec) {\n  int i;\n  if (dec == NULL) return;\n  ClearMetadata(&dec->hdr_);\n\n  WebPSafeFree(dec->pixels_);\n  dec->pixels_ = NULL;\n  for (i = 0; i < dec->next_transform_; ++i) {\n    ClearTransform(&dec->transforms_[i]);\n  }\n  dec->next_transform_ = 0;\n  dec->transforms_seen_ = 0;\n\n  WebPSafeFree(dec->rescaler_memory);\n  dec->rescaler_memory = NULL;\n\n  dec->output_ = NULL;   // leave no trace behind\n}\n\nvoid VP8LDelete(VP8LDecoder* const dec) {\n  if (dec != NULL) {\n    VP8LClear(dec);\n    WebPSafeFree(dec);\n  }\n}\n\nstatic void UpdateDecoder(VP8LDecoder* const dec, int width, int height) {\n  VP8LMetadata* const hdr = &dec->hdr_;\n  const int num_bits = hdr->huffman_subsample_bits_;\n  dec->width_ = width;\n  dec->height_ = height;\n\n  hdr->huffman_xsize_ = VP8LSubSampleSize(width, num_bits);\n  hdr->huffman_mask_ = (num_bits == 0) ? ~0 : (1 << num_bits) - 1;\n}\n\nstatic int DecodeImageStream(int xsize, int ysize,\n                             int is_level0,\n                             VP8LDecoder* const dec,\n                             uint32_t** const decoded_data) {\n  int ok = 1;\n  int transform_xsize = xsize;\n  int transform_ysize = ysize;\n  VP8LBitReader* const br = &dec->br_;\n  VP8LMetadata* const hdr = &dec->hdr_;\n  uint32_t* data = NULL;\n  int color_cache_bits = 0;\n\n  // Read the transforms (may recurse).\n  if (is_level0) {\n    while (ok && VP8LReadBits(br, 1)) {\n      ok = ReadTransform(&transform_xsize, &transform_ysize, dec);\n    }\n  }\n\n  // Color cache\n  if (ok && VP8LReadBits(br, 1)) {\n    color_cache_bits = VP8LReadBits(br, 4);\n    ok = (color_cache_bits >= 1 && color_cache_bits <= MAX_CACHE_BITS);\n    if (!ok) {\n      VP8LSetError(dec, VP8_STATUS_BITSTREAM_ERROR);\n      goto End;\n    }\n  }\n\n  // Read the Huffman codes (may recurse).\n  ok = ok && ReadHuffmanCodes(dec, transform_xsize, transform_ysize,\n                              color_cache_bits, is_level0);\n  if (!ok) {\n    VP8LSetError(dec, VP8_STATUS_BITSTREAM_ERROR);\n    goto End;\n  }\n\n  // Finish setting up the color-cache\n  if (color_cache_bits > 0) {\n    hdr->color_cache_size_ = 1 << color_cache_bits;\n    if (!VP8LColorCacheInit(&hdr->color_cache_, color_cache_bits)) {\n      ok = VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);\n      goto End;\n    }\n  } else {\n    hdr->color_cache_size_ = 0;\n  }\n  UpdateDecoder(dec, transform_xsize, transform_ysize);\n\n  if (is_level0) {   // level 0 complete\n    dec->state_ = READ_HDR;\n    goto End;\n  }\n\n  {\n    const uint64_t total_size = (uint64_t)transform_xsize * transform_ysize;\n    data = (uint32_t*)WebPSafeMalloc(total_size, sizeof(*data));\n    if (data == NULL) {\n      ok = VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);\n      goto End;\n    }\n  }\n\n  // Use the Huffman trees to decode the LZ77 encoded data.\n  ok = DecodeImageData(dec, data, transform_xsize, transform_ysize,\n                       transform_ysize, NULL);\n  ok = ok && !br->eos_;\n\n End:\n  if (!ok) {\n    WebPSafeFree(data);\n    ClearMetadata(hdr);\n  } else {\n    if (decoded_data != NULL) {\n      *decoded_data = data;\n    } else {\n      // We allocate image data in this function only for transforms. At level 0\n      // (that is: not the transforms), we shouldn't have allocated anything.\n      assert(data == NULL);\n      assert(is_level0);\n    }\n    dec->last_pixel_ = 0;  // Reset for future DECODE_DATA_FUNC() calls.\n    if (!is_level0) ClearMetadata(hdr);  // Clean up temporary data behind.\n  }\n  return ok;\n}\n\n//------------------------------------------------------------------------------\n// Allocate internal buffers dec->pixels_ and dec->argb_cache_.\nstatic int AllocateInternalBuffers32b(VP8LDecoder* const dec, int final_width) {\n  const uint64_t num_pixels = (uint64_t)dec->width_ * dec->height_;\n  // Scratch buffer corresponding to top-prediction row for transforming the\n  // first row in the row-blocks. Not needed for paletted alpha.\n  const uint64_t cache_top_pixels = (uint16_t)final_width;\n  // Scratch buffer for temporary BGRA storage. Not needed for paletted alpha.\n  const uint64_t cache_pixels = (uint64_t)final_width * NUM_ARGB_CACHE_ROWS;\n  const uint64_t total_num_pixels =\n      num_pixels + cache_top_pixels + cache_pixels;\n\n  assert(dec->width_ <= final_width);\n  dec->pixels_ = (uint32_t*)WebPSafeMalloc(total_num_pixels, sizeof(uint32_t));\n  if (dec->pixels_ == NULL) {\n    dec->argb_cache_ = NULL;    // for soundness\n    return VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);\n  }\n  dec->argb_cache_ = dec->pixels_ + num_pixels + cache_top_pixels;\n  return 1;\n}\n\nstatic int AllocateInternalBuffers8b(VP8LDecoder* const dec) {\n  const uint64_t total_num_pixels = (uint64_t)dec->width_ * dec->height_;\n  dec->argb_cache_ = NULL;    // for soundness\n  dec->pixels_ = (uint32_t*)WebPSafeMalloc(total_num_pixels, sizeof(uint8_t));\n  if (dec->pixels_ == NULL) {\n    return VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);\n  }\n  return 1;\n}\n\n//------------------------------------------------------------------------------\n\n// Special row-processing that only stores the alpha data.\nstatic void ExtractAlphaRows(VP8LDecoder* const dec, int last_row) {\n  int cur_row = dec->last_row_;\n  int num_rows = last_row - cur_row;\n  const uint32_t* in = dec->pixels_ + dec->width_ * cur_row;\n\n  assert(last_row <= dec->io_->crop_bottom);\n  while (num_rows > 0) {\n    const int num_rows_to_process =\n        (num_rows > NUM_ARGB_CACHE_ROWS) ? NUM_ARGB_CACHE_ROWS : num_rows;\n    // Extract alpha (which is stored in the green plane).\n    ALPHDecoder* const alph_dec = (ALPHDecoder*)dec->io_->opaque;\n    uint8_t* const output = alph_dec->output_;\n    const int width = dec->io_->width;      // the final width (!= dec->width_)\n    const int cache_pixs = width * num_rows_to_process;\n    uint8_t* const dst = output + width * cur_row;\n    const uint32_t* const src = dec->argb_cache_;\n    ApplyInverseTransforms(dec, cur_row, num_rows_to_process, in);\n    WebPExtractGreen(src, dst, cache_pixs);\n    AlphaApplyFilter(alph_dec,\n                     cur_row, cur_row + num_rows_to_process, dst, width);\n    num_rows -= num_rows_to_process;\n    in += num_rows_to_process * dec->width_;\n    cur_row += num_rows_to_process;\n  }\n  assert(cur_row == last_row);\n  dec->last_row_ = dec->last_out_row_ = last_row;\n}\n\nint VP8LDecodeAlphaHeader(ALPHDecoder* const alph_dec,\n                          const uint8_t* const data, size_t data_size) {\n  int ok = 0;\n  VP8LDecoder* dec = VP8LNew();\n\n  if (dec == NULL) return 0;\n\n  assert(alph_dec != NULL);\n\n  dec->width_ = alph_dec->width_;\n  dec->height_ = alph_dec->height_;\n  dec->io_ = &alph_dec->io_;\n  dec->io_->opaque = alph_dec;\n  dec->io_->width = alph_dec->width_;\n  dec->io_->height = alph_dec->height_;\n\n  dec->status_ = VP8_STATUS_OK;\n  VP8LInitBitReader(&dec->br_, data, data_size);\n\n  if (!DecodeImageStream(alph_dec->width_, alph_dec->height_, /*is_level0=*/1,\n                         dec, /*decoded_data=*/NULL)) {\n    goto Err;\n  }\n\n  // Special case: if alpha data uses only the color indexing transform and\n  // doesn't use color cache (a frequent case), we will use DecodeAlphaData()\n  // method that only needs allocation of 1 byte per pixel (alpha channel).\n  if (dec->next_transform_ == 1 &&\n      dec->transforms_[0].type_ == COLOR_INDEXING_TRANSFORM &&\n      Is8bOptimizable(&dec->hdr_)) {\n    alph_dec->use_8b_decode_ = 1;\n    ok = AllocateInternalBuffers8b(dec);\n  } else {\n    // Allocate internal buffers (note that dec->width_ may have changed here).\n    alph_dec->use_8b_decode_ = 0;\n    ok = AllocateInternalBuffers32b(dec, alph_dec->width_);\n  }\n\n  if (!ok) goto Err;\n\n  // Only set here, once we are sure it is valid (to avoid thread races).\n  alph_dec->vp8l_dec_ = dec;\n  return 1;\n\n Err:\n  VP8LDelete(dec);\n  return 0;\n}\n\nint VP8LDecodeAlphaImageStream(ALPHDecoder* const alph_dec, int last_row) {\n  VP8LDecoder* const dec = alph_dec->vp8l_dec_;\n  assert(dec != NULL);\n  assert(last_row <= dec->height_);\n\n  if (dec->last_row_ >= last_row) {\n    return 1;  // done\n  }\n\n  if (!alph_dec->use_8b_decode_) WebPInitAlphaProcessing();\n\n  // Decode (with special row processing).\n  return alph_dec->use_8b_decode_ ?\n      DecodeAlphaData(dec, (uint8_t*)dec->pixels_, dec->width_, dec->height_,\n                      last_row) :\n      DecodeImageData(dec, dec->pixels_, dec->width_, dec->height_,\n                      last_row, ExtractAlphaRows);\n}\n\n//------------------------------------------------------------------------------\n\nint VP8LDecodeHeader(VP8LDecoder* const dec, VP8Io* const io) {\n  int width, height, has_alpha;\n\n  if (dec == NULL) return 0;\n  if (io == NULL) {\n    return VP8LSetError(dec, VP8_STATUS_INVALID_PARAM);\n  }\n\n  dec->io_ = io;\n  dec->status_ = VP8_STATUS_OK;\n  VP8LInitBitReader(&dec->br_, io->data, io->data_size);\n  if (!ReadImageInfo(&dec->br_, &width, &height, &has_alpha)) {\n    VP8LSetError(dec, VP8_STATUS_BITSTREAM_ERROR);\n    goto Error;\n  }\n  dec->state_ = READ_DIM;\n  io->width = width;\n  io->height = height;\n\n  if (!DecodeImageStream(width, height, /*is_level0=*/1, dec,\n                         /*decoded_data=*/NULL)) {\n    goto Error;\n  }\n  return 1;\n\n Error:\n  VP8LClear(dec);\n  assert(dec->status_ != VP8_STATUS_OK);\n  return 0;\n}\n\nint VP8LDecodeImage(VP8LDecoder* const dec) {\n  VP8Io* io = NULL;\n  WebPDecParams* params = NULL;\n\n  if (dec == NULL) return 0;\n\n  assert(dec->hdr_.huffman_tables_.root.start != NULL);\n  assert(dec->hdr_.htree_groups_ != NULL);\n  assert(dec->hdr_.num_htree_groups_ > 0);\n\n  io = dec->io_;\n  assert(io != NULL);\n  params = (WebPDecParams*)io->opaque;\n  assert(params != NULL);\n\n  // Initialization.\n  if (dec->state_ != READ_DATA) {\n    dec->output_ = params->output;\n    assert(dec->output_ != NULL);\n\n    if (!WebPIoInitFromOptions(params->options, io, MODE_BGRA)) {\n      VP8LSetError(dec, VP8_STATUS_INVALID_PARAM);\n      goto Err;\n    }\n\n    if (!AllocateInternalBuffers32b(dec, io->width)) goto Err;\n\n#if !defined(WEBP_REDUCE_SIZE)\n    if (io->use_scaling && !AllocateAndInitRescaler(dec, io)) goto Err;\n#else\n    if (io->use_scaling) {\n      VP8LSetError(dec, VP8_STATUS_INVALID_PARAM);\n      goto Err;\n    }\n#endif\n    if (io->use_scaling || WebPIsPremultipliedMode(dec->output_->colorspace)) {\n      // need the alpha-multiply functions for premultiplied output or rescaling\n      WebPInitAlphaProcessing();\n    }\n\n    if (!WebPIsRGBMode(dec->output_->colorspace)) {\n      WebPInitConvertARGBToYUV();\n      if (dec->output_->u.YUVA.a != NULL) WebPInitAlphaProcessing();\n    }\n    if (dec->incremental_) {\n      if (dec->hdr_.color_cache_size_ > 0 &&\n          dec->hdr_.saved_color_cache_.colors_ == NULL) {\n        if (!VP8LColorCacheInit(&dec->hdr_.saved_color_cache_,\n                                dec->hdr_.color_cache_.hash_bits_)) {\n          VP8LSetError(dec, VP8_STATUS_OUT_OF_MEMORY);\n          goto Err;\n        }\n      }\n    }\n    dec->state_ = READ_DATA;\n  }\n\n  // Decode.\n  if (!DecodeImageData(dec, dec->pixels_, dec->width_, dec->height_,\n                       io->crop_bottom, ProcessRows)) {\n    goto Err;\n  }\n\n  params->last_y = dec->last_out_row_;\n  return 1;\n\n Err:\n  VP8LClear(dec);\n  assert(dec->status_ != VP8_STATUS_OK);\n  return 0;\n}\n\n//------------------------------------------------------------------------------\n", "// Copyright 2012 Google Inc. All Rights Reserved.\n//\n// Use of this source code is governed by a BSD-style license\n// that can be found in the COPYING file in the root of the source\n// tree. An additional intellectual property rights grant can be found\n// in the file PATENTS. All contributing project authors may\n// be found in the AUTHORS file in the root of the source tree.\n// -----------------------------------------------------------------------------\n//\n// Lossless decoder: internal header.\n//\n// Author: Skal (pascal.massimino@gmail.com)\n//         Vikas Arora(vikaas.arora@gmail.com)\n\n#ifndef WEBP_DEC_VP8LI_DEC_H_\n#define WEBP_DEC_VP8LI_DEC_H_\n\n#include <string.h>     // for memcpy()\n#include \"src/dec/webpi_dec.h\"\n#include \"src/utils/bit_reader_utils.h\"\n#include \"src/utils/color_cache_utils.h\"\n#include \"src/utils/huffman_utils.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\ntypedef enum {\n  READ_DATA = 0,\n  READ_HDR = 1,\n  READ_DIM = 2\n} VP8LDecodeState;\n\ntypedef struct VP8LTransform VP8LTransform;\nstruct VP8LTransform {\n  VP8LImageTransformType type_;   // transform type.\n  int                    bits_;   // subsampling bits defining transform window.\n  int                    xsize_;  // transform window X index.\n  int                    ysize_;  // transform window Y index.\n  uint32_t*              data_;   // transform data.\n};\n\ntypedef struct {\n  int             color_cache_size_;\n  VP8LColorCache  color_cache_;\n  VP8LColorCache  saved_color_cache_;  // for incremental\n\n  int             huffman_mask_;\n  int             huffman_subsample_bits_;\n  int             huffman_xsize_;\n  uint32_t*       huffman_image_;\n  int             num_htree_groups_;\n  HTreeGroup*     htree_groups_;\n  HuffmanTables   huffman_tables_;\n} VP8LMetadata;\n\ntypedef struct VP8LDecoder VP8LDecoder;\nstruct VP8LDecoder {\n  VP8StatusCode    status_;\n  VP8LDecodeState  state_;\n  VP8Io*           io_;\n\n  const WebPDecBuffer* output_;    // shortcut to io->opaque->output\n\n  uint32_t*        pixels_;        // Internal data: either uint8_t* for alpha\n                                   // or uint32_t* for BGRA.\n  uint32_t*        argb_cache_;    // Scratch buffer for temporary BGRA storage.\n\n  VP8LBitReader    br_;\n  int              incremental_;   // if true, incremental decoding is expected\n  VP8LBitReader    saved_br_;      // note: could be local variables too\n  int              saved_last_pixel_;\n\n  int              width_;\n  int              height_;\n  int              last_row_;      // last input row decoded so far.\n  int              last_pixel_;    // last pixel decoded so far. However, it may\n                                   // not be transformed, scaled and\n                                   // color-converted yet.\n  int              last_out_row_;  // last row output so far.\n\n  VP8LMetadata     hdr_;\n\n  int              next_transform_;\n  VP8LTransform    transforms_[NUM_TRANSFORMS];\n  // or'd bitset storing the transforms types.\n  uint32_t         transforms_seen_;\n\n  uint8_t*         rescaler_memory;  // Working memory for rescaling work.\n  WebPRescaler*    rescaler;         // Common rescaler for all channels.\n};\n\n//------------------------------------------------------------------------------\n// internal functions. Not public.\n\nstruct ALPHDecoder;  // Defined in dec/alphai.h.\n\n// in vp8l.c\n\n// Decodes image header for alpha data stored using lossless compression.\n// Returns false in case of error.\nint VP8LDecodeAlphaHeader(struct ALPHDecoder* const alph_dec,\n                          const uint8_t* const data, size_t data_size);\n\n// Decodes *at least* 'last_row' rows of alpha. If some of the initial rows are\n// already decoded in previous call(s), it will resume decoding from where it\n// was paused.\n// Returns false in case of bitstream error.\nint VP8LDecodeAlphaImageStream(struct ALPHDecoder* const alph_dec,\n                               int last_row);\n\n// Allocates and initialize a new lossless decoder instance.\nVP8LDecoder* VP8LNew(void);\n\n// Decodes the image header. Returns false in case of error.\nint VP8LDecodeHeader(VP8LDecoder* const dec, VP8Io* const io);\n\n// Decodes an image. It's required to decode the lossless header before calling\n// this function. Returns false in case of error, with updated dec->status_.\nint VP8LDecodeImage(VP8LDecoder* const dec);\n\n// Resets the decoder in its initial state, reclaiming memory.\n// Preserves the dec->status_ value.\nvoid VP8LClear(VP8LDecoder* const dec);\n\n// Clears and deallocate a lossless decoder instance.\nvoid VP8LDelete(VP8LDecoder* const dec);\n\n//------------------------------------------------------------------------------\n\n#ifdef __cplusplus\n}    // extern \"C\"\n#endif\n\n#endif  // WEBP_DEC_VP8LI_DEC_H_\n", "// Copyright 2012 Google Inc. All Rights Reserved.\n//\n// Use of this source code is governed by a BSD-style license\n// that can be found in the COPYING file in the root of the source\n// tree. An additional intellectual property rights grant can be found\n// in the file PATENTS. All contributing project authors may\n// be found in the AUTHORS file in the root of the source tree.\n// -----------------------------------------------------------------------------\n//\n// Utilities for building and looking up Huffman trees.\n//\n// Author: Urvang Joshi (urvang@google.com)\n\n#include <assert.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"src/utils/huffman_utils.h\"\n#include \"src/utils/utils.h\"\n#include \"src/webp/format_constants.h\"\n\n// Huffman data read via DecodeImageStream is represented in two (red and green)\n// bytes.\n#define MAX_HTREE_GROUPS    0x10000\n\nHTreeGroup* VP8LHtreeGroupsNew(int num_htree_groups) {\n  HTreeGroup* const htree_groups =\n      (HTreeGroup*)WebPSafeMalloc(num_htree_groups, sizeof(*htree_groups));\n  if (htree_groups == NULL) {\n    return NULL;\n  }\n  assert(num_htree_groups <= MAX_HTREE_GROUPS);\n  return htree_groups;\n}\n\nvoid VP8LHtreeGroupsFree(HTreeGroup* const htree_groups) {\n  if (htree_groups != NULL) {\n    WebPSafeFree(htree_groups);\n  }\n}\n\n// Returns reverse(reverse(key, len) + 1, len), where reverse(key, len) is the\n// bit-wise reversal of the len least significant bits of key.\nstatic WEBP_INLINE uint32_t GetNextKey(uint32_t key, int len) {\n  uint32_t step = 1 << (len - 1);\n  while (key & step) {\n    step >>= 1;\n  }\n  return step ? (key & (step - 1)) + step : key;\n}\n\n// Stores code in table[0], table[step], table[2*step], ..., table[end].\n// Assumes that end is an integer multiple of step.\nstatic WEBP_INLINE void ReplicateValue(HuffmanCode* table,\n                                       int step, int end,\n                                       HuffmanCode code) {\n  assert(end % step == 0);\n  do {\n    end -= step;\n    table[end] = code;\n  } while (end > 0);\n}\n\n// Returns the table width of the next 2nd level table. count is the histogram\n// of bit lengths for the remaining symbols, len is the code length of the next\n// processed symbol\nstatic WEBP_INLINE int NextTableBitSize(const int* const count,\n                                        int len, int root_bits) {\n  int left = 1 << (len - root_bits);\n  while (len < MAX_ALLOWED_CODE_LENGTH) {\n    left -= count[len];\n    if (left <= 0) break;\n    ++len;\n    left <<= 1;\n  }\n  return len - root_bits;\n}\n\n// sorted[code_lengths_size] is a pre-allocated array for sorting symbols\n// by code length.\nstatic int BuildHuffmanTable(HuffmanCode* const root_table, int root_bits,\n                             const int code_lengths[], int code_lengths_size,\n                             uint16_t sorted[]) {\n  HuffmanCode* table = root_table;  // next available space in table\n  int total_size = 1 << root_bits;  // total size root table + 2nd level table\n  int len;                          // current code length\n  int symbol;                       // symbol index in original or sorted table\n  // number of codes of each length:\n  int count[MAX_ALLOWED_CODE_LENGTH + 1] = { 0 };\n  // offsets in sorted table for each length:\n  int offset[MAX_ALLOWED_CODE_LENGTH + 1];\n\n  assert(code_lengths_size != 0);\n  assert(code_lengths != NULL);\n  assert((root_table != NULL && sorted != NULL) ||\n         (root_table == NULL && sorted == NULL));\n  assert(root_bits > 0);\n\n  // Build histogram of code lengths.\n  for (symbol = 0; symbol < code_lengths_size; ++symbol) {\n    if (code_lengths[symbol] > MAX_ALLOWED_CODE_LENGTH) {\n      return 0;\n    }\n    ++count[code_lengths[symbol]];\n  }\n\n  // Error, all code lengths are zeros.\n  if (count[0] == code_lengths_size) {\n    return 0;\n  }\n\n  // Generate offsets into sorted symbol table by code length.\n  offset[1] = 0;\n  for (len = 1; len < MAX_ALLOWED_CODE_LENGTH; ++len) {\n    if (count[len] > (1 << len)) {\n      return 0;\n    }\n    offset[len + 1] = offset[len] + count[len];\n  }\n\n  // Sort symbols by length, by symbol order within each length.\n  for (symbol = 0; symbol < code_lengths_size; ++symbol) {\n    const int symbol_code_length = code_lengths[symbol];\n    if (code_lengths[symbol] > 0) {\n      if (sorted != NULL) {\n        sorted[offset[symbol_code_length]++] = symbol;\n      } else {\n        offset[symbol_code_length]++;\n      }\n    }\n  }\n\n  // Special case code with only one value.\n  if (offset[MAX_ALLOWED_CODE_LENGTH] == 1) {\n    if (sorted != NULL) {\n      HuffmanCode code;\n      code.bits = 0;\n      code.value = (uint16_t)sorted[0];\n      ReplicateValue(table, 1, total_size, code);\n    }\n    return total_size;\n  }\n\n  {\n    int step;              // step size to replicate values in current table\n    uint32_t low = 0xffffffffu;        // low bits for current root entry\n    uint32_t mask = total_size - 1;    // mask for low bits\n    uint32_t key = 0;      // reversed prefix code\n    int num_nodes = 1;     // number of Huffman tree nodes\n    int num_open = 1;      // number of open branches in current tree level\n    int table_bits = root_bits;        // key length of current table\n    int table_size = 1 << table_bits;  // size of current table\n    symbol = 0;\n    // Fill in root table.\n    for (len = 1, step = 2; len <= root_bits; ++len, step <<= 1) {\n      num_open <<= 1;\n      num_nodes += num_open;\n      num_open -= count[len];\n      if (num_open < 0) {\n        return 0;\n      }\n      if (root_table == NULL) continue;\n      for (; count[len] > 0; --count[len]) {\n        HuffmanCode code;\n        code.bits = (uint8_t)len;\n        code.value = (uint16_t)sorted[symbol++];\n        ReplicateValue(&table[key], step, table_size, code);\n        key = GetNextKey(key, len);\n      }\n    }\n\n    // Fill in 2nd level tables and add pointers to root table.\n    for (len = root_bits + 1, step = 2; len <= MAX_ALLOWED_CODE_LENGTH;\n         ++len, step <<= 1) {\n      num_open <<= 1;\n      num_nodes += num_open;\n      num_open -= count[len];\n      if (num_open < 0) {\n        return 0;\n      }\n      for (; count[len] > 0; --count[len]) {\n        HuffmanCode code;\n        if ((key & mask) != low) {\n          if (root_table != NULL) table += table_size;\n          table_bits = NextTableBitSize(count, len, root_bits);\n          table_size = 1 << table_bits;\n          total_size += table_size;\n          low = key & mask;\n          if (root_table != NULL) {\n            root_table[low].bits = (uint8_t)(table_bits + root_bits);\n            root_table[low].value = (uint16_t)((table - root_table) - low);\n          }\n        }\n        if (root_table != NULL) {\n          code.bits = (uint8_t)(len - root_bits);\n          code.value = (uint16_t)sorted[symbol++];\n          ReplicateValue(&table[key >> root_bits], step, table_size, code);\n        }\n        key = GetNextKey(key, len);\n      }\n    }\n\n    // Check if tree is full.\n    if (num_nodes != 2 * offset[MAX_ALLOWED_CODE_LENGTH] - 1) {\n      return 0;\n    }\n  }\n\n  return total_size;\n}\n\n// Maximum code_lengths_size is 2328 (reached for 11-bit color_cache_bits).\n// More commonly, the value is around ~280.\n#define MAX_CODE_LENGTHS_SIZE \\\n  ((1 << MAX_CACHE_BITS) + NUM_LITERAL_CODES + NUM_LENGTH_CODES)\n// Cut-off value for switching between heap and stack allocation.\n#define SORTED_SIZE_CUTOFF 512\nint VP8LBuildHuffmanTable(HuffmanTables* const root_table, int root_bits,\n                          const int code_lengths[], int code_lengths_size) {\n  const int total_size =\n      BuildHuffmanTable(NULL, root_bits, code_lengths, code_lengths_size, NULL);\n  assert(code_lengths_size <= MAX_CODE_LENGTHS_SIZE);\n  if (total_size == 0 || root_table == NULL) return total_size;\n\n  if (root_table->curr_segment->curr_table + total_size >=\n      root_table->curr_segment->start + root_table->curr_segment->size) {\n    // If 'root_table' does not have enough memory, allocate a new segment.\n    // The available part of root_table->curr_segment is left unused because we\n    // need a contiguous buffer.\n    const int segment_size = root_table->curr_segment->size;\n    struct HuffmanTablesSegment* next =\n        (HuffmanTablesSegment*)WebPSafeMalloc(1, sizeof(*next));\n    if (next == NULL) return 0;\n    // Fill the new segment.\n    // We need at least 'total_size' but if that value is small, it is better to\n    // allocate a big chunk to prevent more allocations later. 'segment_size' is\n    // therefore chosen (any other arbitrary value could be chosen).\n    next->size = total_size > segment_size ? total_size : segment_size;\n    next->start =\n        (HuffmanCode*)WebPSafeMalloc(next->size, sizeof(*next->start));\n    if (next->start == NULL) {\n      WebPSafeFree(next);\n      return 0;\n    }\n    next->curr_table = next->start;\n    next->next = NULL;\n    // Point to the new segment.\n    root_table->curr_segment->next = next;\n    root_table->curr_segment = next;\n  }\n  if (code_lengths_size <= SORTED_SIZE_CUTOFF) {\n    // use local stack-allocated array.\n    uint16_t sorted[SORTED_SIZE_CUTOFF];\n    BuildHuffmanTable(root_table->curr_segment->curr_table, root_bits,\n                      code_lengths, code_lengths_size, sorted);\n  } else {  // rare case. Use heap allocation.\n    uint16_t* const sorted =\n        (uint16_t*)WebPSafeMalloc(code_lengths_size, sizeof(*sorted));\n    if (sorted == NULL) return 0;\n    BuildHuffmanTable(root_table->curr_segment->curr_table, root_bits,\n                      code_lengths, code_lengths_size, sorted);\n    WebPSafeFree(sorted);\n  }\n  return total_size;\n}\n\nint VP8LHuffmanTablesAllocate(int size, HuffmanTables* huffman_tables) {\n  // Have 'segment' point to the first segment for now, 'root'.\n  HuffmanTablesSegment* const root = &huffman_tables->root;\n  huffman_tables->curr_segment = root;\n  // Allocate root.\n  root->start = (HuffmanCode*)WebPSafeMalloc(size, sizeof(*root->start));\n  if (root->start == NULL) return 0;\n  root->curr_table = root->start;\n  root->next = NULL;\n  root->size = size;\n  return 1;\n}\n\nvoid VP8LHuffmanTablesDeallocate(HuffmanTables* const huffman_tables) {\n  HuffmanTablesSegment *current, *next;\n  if (huffman_tables == NULL) return;\n  // Free the root node.\n  current = &huffman_tables->root;\n  next = current->next;\n  WebPSafeFree(current->start);\n  current->start = NULL;\n  current->next = NULL;\n  current = next;\n  // Free the following nodes.\n  while (current != NULL) {\n    next = current->next;\n    WebPSafeFree(current->start);\n    WebPSafeFree(current);\n    current = next;\n  }\n}\n", "// Copyright 2012 Google Inc. All Rights Reserved.\n//\n// Use of this source code is governed by a BSD-style license\n// that can be found in the COPYING file in the root of the source\n// tree. An additional intellectual property rights grant can be found\n// in the file PATENTS. All contributing project authors may\n// be found in the AUTHORS file in the root of the source tree.\n// -----------------------------------------------------------------------------\n//\n// Utilities for building and looking up Huffman trees.\n//\n// Author: Urvang Joshi (urvang@google.com)\n\n#ifndef WEBP_UTILS_HUFFMAN_UTILS_H_\n#define WEBP_UTILS_HUFFMAN_UTILS_H_\n\n#include <assert.h>\n#include \"src/webp/format_constants.h\"\n#include \"src/webp/types.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#define HUFFMAN_TABLE_BITS      8\n#define HUFFMAN_TABLE_MASK      ((1 << HUFFMAN_TABLE_BITS) - 1)\n\n#define LENGTHS_TABLE_BITS      7\n#define LENGTHS_TABLE_MASK      ((1 << LENGTHS_TABLE_BITS) - 1)\n\n\n// Huffman lookup table entry\ntypedef struct {\n  uint8_t bits;     // number of bits used for this symbol\n  uint16_t value;   // symbol value or table offset\n} HuffmanCode;\n\n// long version for holding 32b values\ntypedef struct {\n  int bits;         // number of bits used for this symbol,\n                    // or an impossible value if not a literal code.\n  uint32_t value;   // 32b packed ARGB value if literal,\n                    // or non-literal symbol otherwise\n} HuffmanCode32;\n\n// Contiguous memory segment of HuffmanCodes.\ntypedef struct HuffmanTablesSegment {\n  HuffmanCode* start;\n  // Pointer to where we are writing into the segment. Starts at 'start' and\n  // cannot go beyond 'start' + 'size'.\n  HuffmanCode* curr_table;\n  // Pointer to the next segment in the chain.\n  struct HuffmanTablesSegment* next;\n  int size;\n} HuffmanTablesSegment;\n\n// Chained memory segments of HuffmanCodes.\ntypedef struct HuffmanTables {\n  HuffmanTablesSegment root;\n  // Currently processed segment. At first, this is 'root'.\n  HuffmanTablesSegment* curr_segment;\n} HuffmanTables;\n\n// Allocates a HuffmanTables with 'size' contiguous HuffmanCodes. Returns 0 on\n// memory allocation error, 1 otherwise.\nint VP8LHuffmanTablesAllocate(int size, HuffmanTables* huffman_tables);\nvoid VP8LHuffmanTablesDeallocate(HuffmanTables* const huffman_tables);\n\n#define HUFFMAN_PACKED_BITS 6\n#define HUFFMAN_PACKED_TABLE_SIZE (1u << HUFFMAN_PACKED_BITS)\n\n// Huffman table group.\n// Includes special handling for the following cases:\n//  - is_trivial_literal: one common literal base for RED/BLUE/ALPHA (not GREEN)\n//  - is_trivial_code: only 1 code (no bit is read from bitstream)\n//  - use_packed_table: few enough literal symbols, so all the bit codes\n//    can fit into a small look-up table packed_table[]\n// The common literal base, if applicable, is stored in 'literal_arb'.\ntypedef struct HTreeGroup HTreeGroup;\nstruct HTreeGroup {\n  HuffmanCode* htrees[HUFFMAN_CODES_PER_META_CODE];\n  int      is_trivial_literal;  // True, if huffman trees for Red, Blue & Alpha\n                                // Symbols are trivial (have a single code).\n  uint32_t literal_arb;         // If is_trivial_literal is true, this is the\n                                // ARGB value of the pixel, with Green channel\n                                // being set to zero.\n  int is_trivial_code;          // true if is_trivial_literal with only one code\n  int use_packed_table;         // use packed table below for short literal code\n  // table mapping input bits to a packed values, or escape case to literal code\n  HuffmanCode32 packed_table[HUFFMAN_PACKED_TABLE_SIZE];\n};\n\n// Creates the instance of HTreeGroup with specified number of tree-groups.\nHTreeGroup* VP8LHtreeGroupsNew(int num_htree_groups);\n\n// Releases the memory allocated for HTreeGroup.\nvoid VP8LHtreeGroupsFree(HTreeGroup* const htree_groups);\n\n// Builds Huffman lookup table assuming code lengths are in symbol order.\n// The 'code_lengths' is pre-allocated temporary memory buffer used for creating\n// the huffman table.\n// Returns built table size or 0 in case of error (invalid tree or\n// memory error).\nint VP8LBuildHuffmanTable(HuffmanTables* const root_table, int root_bits,\n                          const int code_lengths[], int code_lengths_size);\n\n#ifdef __cplusplus\n}    // extern \"C\"\n#endif\n\n#endif  // WEBP_UTILS_HUFFMAN_UTILS_H_\n"], "filenames": ["src/dec/vp8l_dec.c", "src/dec/vp8li_dec.h", "src/utils/huffman_utils.c", "src/utils/huffman_utils.h"], "buggy_code_start_loc": [265, 54, 180, 45], "buggy_code_end_loc": [1670, 55, 235, 84], "fixing_code_start_loc": [265, 54, 179, 46], "fixing_code_end_loc": [1674, 55, 297, 105], "type": "CWE-787", "message": "Heap buffer overflow in libwebp in Google Chrome prior to 116.0.5845.187 and libwebp 1.3.2 allowed a remote attacker to perform an out of bounds memory write via a crafted HTML page. (Chromium security severity: Critical)", "other": {"cve": {"id": "CVE-2023-4863", "sourceIdentifier": "chrome-cve-admin@google.com", "published": "2023-09-12T15:15:24.327", "lastModified": "2024-01-07T11:15:13.650", "vulnStatus": "Modified", "cisaExploitAdd": "2023-09-13", "cisaActionDue": "2023-10-04", "cisaRequiredAction": "Apply mitigations per vendor instructions or discontinue use of the product if mitigations are unavailable.", "cisaVulnerabilityName": "Google Chromium WebP Heap-Based Buffer Overflow Vulnerability", "descriptions": [{"lang": "en", "value": "Heap buffer overflow in libwebp in Google Chrome prior to 116.0.5845.187 and libwebp 1.3.2 allowed a remote attacker to perform an out of bounds memory write via a crafted HTML page. (Chromium security severity: Critical)"}, {"lang": "es", "value": "El desbordamiento del b\u00fafer de memoria en libwebp en Google Chrome anterior a 116.0.5845.187 y libwebp 1.3.2 permit\u00eda a un atacante remoto realizar una escritura en memoria fuera de los l\u00edmites a trav\u00e9s de una p\u00e1gina HTML manipulada. (Severidad de seguridad de Chromium: cr\u00edtica)"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:google:chrome:*:*:*:*:*:*:*:*", "versionEndExcluding": "116.0.5845.187", "matchCriteriaId": "856C1821-5D22-4A4E-859D-8F5305255AB7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:37:*:*:*:*:*:*:*", "matchCriteriaId": "E30D0E6F-4AE8-4284-8716-991DFA48CC5D"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:38:*:*:*:*:*:*:*", "matchCriteriaId": "CC559B26-5DFC-4B7A-A27C-B77DE755DFF9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:39:*:*:*:*:*:*:*", "matchCriteriaId": "B8EDB836-4E6A-4B71-B9B2-AA3E03E0F646"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:10.0:*:*:*:*:*:*:*", "matchCriteriaId": "07B237A9-69A3-4A9C-9DA0-4E06BD37AE73"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:12.0:*:*:*:*:*:*:*", "matchCriteriaId": "46D69DCC-AE4D-4EA5-861C-D60951444C6C"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox:*:*:*:*:*:*:*:*", "versionEndExcluding": "117.0.1", "matchCriteriaId": "54A821DA-91BA-454E-BC32-2152CD7989AE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox_esr:*:*:*:*:*:*:*:*", "versionEndExcluding": "102.15.1", "matchCriteriaId": "F5CB1076-9147-44A4-B32F-86841DEB85DA"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:firefox_esr:*:*:*:*:*:*:*:*", "versionStartIncluding": "115.0", "versionEndExcluding": "115.2.1", "matchCriteriaId": "D288632E-E2D5-4319-BE74-882D71D699C2"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:thunderbird:*:*:*:*:*:*:*:*", "versionEndExcluding": "102.15.1", "matchCriteriaId": "A073724D-52BD-4426-B58D-7A8BD24B8F8E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:mozilla:thunderbird:*:*:*:*:*:*:*:*", "versionStartIncluding": "115.0", "versionEndExcluding": "115.2.2", "matchCriteriaId": "952BEC0C-2DB0-476A-AF62-1269F8635B4A"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:microsoft:edge:*:*:*:*:*:*:*:*", "versionEndExcluding": "117.0.2045.31", "matchCriteriaId": "49AFFE24-5E30-46A4-A3AE-13D8EB15DE91"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:webmproject:libwebp:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.3.2", "matchCriteriaId": "2804DDE4-B0A4-4B7F-A318-F491B6316B34"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2023/09/21/4", "source": "chrome-cve-admin@google.com"}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/22/1", "source": "chrome-cve-admin@google.com"}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/22/3", "source": "chrome-cve-admin@google.com"}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/22/4", "source": "chrome-cve-admin@google.com"}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/22/5", "source": "chrome-cve-admin@google.com"}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/22/6", "source": "chrome-cve-admin@google.com"}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/22/7", "source": "chrome-cve-admin@google.com"}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/22/8", "source": "chrome-cve-admin@google.com"}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/26/1", "source": "chrome-cve-admin@google.com"}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/26/7", "source": "chrome-cve-admin@google.com"}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/28/1", "source": "chrome-cve-admin@google.com"}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/28/2", "source": "chrome-cve-admin@google.com"}, {"url": "http://www.openwall.com/lists/oss-security/2023/09/28/4", "source": "chrome-cve-admin@google.com"}, {"url": "https://adamcaudill.com/2023/09/14/whose-cve-is-it-anyway/", "source": "chrome-cve-admin@google.com", "tags": ["Third Party Advisory"]}, {"url": "https://blog.isosceles.com/the-webp-0day/", "source": "chrome-cve-admin@google.com"}, {"url": "https://bugzilla.suse.com/show_bug.cgi?id=1215231", "source": "chrome-cve-admin@google.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://chromereleases.googleblog.com/2023/09/stable-channel-update-for-desktop_11.html", "source": "chrome-cve-admin@google.com", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://crbug.com/1479274", "source": "chrome-cve-admin@google.com", "tags": ["Issue Tracking", "Permissions Required", "Vendor Advisory"]}, {"url": "https://en.bandisoft.com/honeyview/history/", "source": "chrome-cve-admin@google.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://github.com/webmproject/libwebp/commit/902bc9190331343b2017211debcec8d2ab87e17a", "source": "chrome-cve-admin@google.com", "tags": ["Patch"]}, {"url": "https://github.com/webmproject/libwebp/releases/tag/v1.3.2", "source": "chrome-cve-admin@google.com", "tags": ["Release Notes"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/09/msg00015.html", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/09/msg00016.html", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2023/09/msg00017.html", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/6T655QF7CQ3DYAMPFV7IECQYGDEUIVVT/", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FYYKLG6CRGEDTNRBSU26EEWAO6D6U645/", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/KUQ7CTX3W372X3UY56VVNAHCH6H2F4X3/", "source": "chrome-cve-admin@google.com"}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/OZDGWWMJREPAGKWCJKSCM4WYLANSKIFX/", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/PYZV7TMKF4QHZ54SFJX54BDN52VHGGCX/", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WHOLML7N2G5KCAZXFWC5IDFFHSQS5SDB/", "source": "chrome-cve-admin@google.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WTRUIS3564P7ZLM2S2IH4Y4KZ327LI4I/", "source": "chrome-cve-admin@google.com"}, {"url": "https://msrc.microsoft.com/update-guide/vulnerability/CVE-2023-4863", "source": "chrome-cve-admin@google.com", "tags": ["Patch", "Vendor Advisory"]}, {"url": "https://news.ycombinator.com/item?id=37478403", "source": "chrome-cve-admin@google.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://security-tracker.debian.org/tracker/CVE-2023-4863", "source": "chrome-cve-admin@google.com", "tags": ["Issue Tracking", "Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202309-05", "source": "chrome-cve-admin@google.com", "tags": ["Third Party Advisory"]}, {"url": "https://security.gentoo.org/glsa/202401-10", "source": "chrome-cve-admin@google.com"}, {"url": "https://security.netapp.com/advisory/ntap-20230929-0011/", "source": "chrome-cve-admin@google.com"}, {"url": "https://sethmlarson.dev/security-developer-in-residence-weekly-report-16", "source": "chrome-cve-admin@google.com"}, {"url": "https://stackdiary.com/critical-vulnerability-in-webp-codec-cve-2023-4863/", "source": "chrome-cve-admin@google.com", "tags": ["Exploit", "Third Party Advisory"]}, {"url": "https://www.bentley.com/advisories/be-2023-0001/", "source": "chrome-cve-admin@google.com"}, {"url": "https://www.bleepingcomputer.com/news/google/google-fixes-another-chrome-zero-day-bug-exploited-in-attacks/", "source": "chrome-cve-admin@google.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5496", "source": "chrome-cve-admin@google.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5497", "source": "chrome-cve-admin@google.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.debian.org/security/2023/dsa-5498", "source": "chrome-cve-admin@google.com", "tags": ["Third Party Advisory"]}, {"url": "https://www.mozilla.org/en-US/security/advisories/mfsa2023-40/", "source": "chrome-cve-admin@google.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/webmproject/libwebp/commit/902bc9190331343b2017211debcec8d2ab87e17a"}}