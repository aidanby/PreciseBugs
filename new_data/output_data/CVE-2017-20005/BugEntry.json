{"buggy_code": ["\n/*\n * Copyright (C) Igor Sysoev\n * Copyright (C) Nginx, Inc.\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n\n\n/*\n * The time may be updated by signal handler or by several threads.\n * The time update operations are rare and require to hold the ngx_time_lock.\n * The time read operations are frequent, so they are lock-free and get time\n * values and strings from the current slot.  Thus thread may get the corrupted\n * values only if it is preempted while copying and then it is not scheduled\n * to run more than NGX_TIME_SLOTS seconds.\n */\n\n#define NGX_TIME_SLOTS   64\n\nstatic ngx_uint_t        slot;\nstatic ngx_atomic_t      ngx_time_lock;\n\nvolatile ngx_msec_t      ngx_current_msec;\nvolatile ngx_time_t     *ngx_cached_time;\nvolatile ngx_str_t       ngx_cached_err_log_time;\nvolatile ngx_str_t       ngx_cached_http_time;\nvolatile ngx_str_t       ngx_cached_http_log_time;\nvolatile ngx_str_t       ngx_cached_http_log_iso8601;\nvolatile ngx_str_t       ngx_cached_syslog_time;\n\n#if !(NGX_WIN32)\n\n/*\n * localtime() and localtime_r() are not Async-Signal-Safe functions, therefore,\n * they must not be called by a signal handler, so we use the cached\n * GMT offset value. Fortunately the value is changed only two times a year.\n */\n\nstatic ngx_int_t         cached_gmtoff;\n#endif\n\nstatic ngx_time_t        cached_time[NGX_TIME_SLOTS];\nstatic u_char            cached_err_log_time[NGX_TIME_SLOTS]\n                                    [sizeof(\"1970/09/28 12:00:00\")];\nstatic u_char            cached_http_time[NGX_TIME_SLOTS]\n                                    [sizeof(\"Mon, 28 Sep 1970 06:00:00 GMT\")];\nstatic u_char            cached_http_log_time[NGX_TIME_SLOTS]\n                                    [sizeof(\"28/Sep/1970:12:00:00 +0600\")];\nstatic u_char            cached_http_log_iso8601[NGX_TIME_SLOTS]\n                                    [sizeof(\"1970-09-28T12:00:00+06:00\")];\nstatic u_char            cached_syslog_time[NGX_TIME_SLOTS]\n                                    [sizeof(\"Sep 28 12:00:00\")];\n\n\nstatic char  *week[] = { \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\" };\nstatic char  *months[] = { \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n                           \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" };\n\nvoid\nngx_time_init(void)\n{\n    ngx_cached_err_log_time.len = sizeof(\"1970/09/28 12:00:00\") - 1;\n    ngx_cached_http_time.len = sizeof(\"Mon, 28 Sep 1970 06:00:00 GMT\") - 1;\n    ngx_cached_http_log_time.len = sizeof(\"28/Sep/1970:12:00:00 +0600\") - 1;\n    ngx_cached_http_log_iso8601.len = sizeof(\"1970-09-28T12:00:00+06:00\") - 1;\n    ngx_cached_syslog_time.len = sizeof(\"Sep 28 12:00:00\") - 1;\n\n    ngx_cached_time = &cached_time[0];\n\n    ngx_time_update();\n}\n\n\nvoid\nngx_time_update(void)\n{\n    u_char          *p0, *p1, *p2, *p3, *p4;\n    ngx_tm_t         tm, gmt;\n    time_t           sec;\n    ngx_uint_t       msec;\n    ngx_time_t      *tp;\n    struct timeval   tv;\n\n    if (!ngx_trylock(&ngx_time_lock)) {\n        return;\n    }\n\n    ngx_gettimeofday(&tv);\n\n    sec = tv.tv_sec;\n    msec = tv.tv_usec / 1000;\n\n    ngx_current_msec = (ngx_msec_t) sec * 1000 + msec;\n\n    tp = &cached_time[slot];\n\n    if (tp->sec == sec) {\n        tp->msec = msec;\n        ngx_unlock(&ngx_time_lock);\n        return;\n    }\n\n    if (slot == NGX_TIME_SLOTS - 1) {\n        slot = 0;\n    } else {\n        slot++;\n    }\n\n    tp = &cached_time[slot];\n\n    tp->sec = sec;\n    tp->msec = msec;\n\n    ngx_gmtime(sec, &gmt);\n\n\n    p0 = &cached_http_time[slot][0];\n\n    (void) ngx_sprintf(p0, \"%s, %02d %s %4d %02d:%02d:%02d GMT\",\n                       week[gmt.ngx_tm_wday], gmt.ngx_tm_mday,\n                       months[gmt.ngx_tm_mon - 1], gmt.ngx_tm_year,\n                       gmt.ngx_tm_hour, gmt.ngx_tm_min, gmt.ngx_tm_sec);\n\n#if (NGX_HAVE_GETTIMEZONE)\n\n    tp->gmtoff = ngx_gettimezone();\n    ngx_gmtime(sec + tp->gmtoff * 60, &tm);\n\n#elif (NGX_HAVE_GMTOFF)\n\n    ngx_localtime(sec, &tm);\n    cached_gmtoff = (ngx_int_t) (tm.ngx_tm_gmtoff / 60);\n    tp->gmtoff = cached_gmtoff;\n\n#else\n\n    ngx_localtime(sec, &tm);\n    cached_gmtoff = ngx_timezone(tm.ngx_tm_isdst);\n    tp->gmtoff = cached_gmtoff;\n\n#endif\n\n\n    p1 = &cached_err_log_time[slot][0];\n\n    (void) ngx_sprintf(p1, \"%4d/%02d/%02d %02d:%02d:%02d\",\n                       tm.ngx_tm_year, tm.ngx_tm_mon,\n                       tm.ngx_tm_mday, tm.ngx_tm_hour,\n                       tm.ngx_tm_min, tm.ngx_tm_sec);\n\n\n    p2 = &cached_http_log_time[slot][0];\n\n    (void) ngx_sprintf(p2, \"%02d/%s/%d:%02d:%02d:%02d %c%02i%02i\",\n                       tm.ngx_tm_mday, months[tm.ngx_tm_mon - 1],\n                       tm.ngx_tm_year, tm.ngx_tm_hour,\n                       tm.ngx_tm_min, tm.ngx_tm_sec,\n                       tp->gmtoff < 0 ? '-' : '+',\n                       ngx_abs(tp->gmtoff / 60), ngx_abs(tp->gmtoff % 60));\n\n    p3 = &cached_http_log_iso8601[slot][0];\n\n    (void) ngx_sprintf(p3, \"%4d-%02d-%02dT%02d:%02d:%02d%c%02i:%02i\",\n                       tm.ngx_tm_year, tm.ngx_tm_mon,\n                       tm.ngx_tm_mday, tm.ngx_tm_hour,\n                       tm.ngx_tm_min, tm.ngx_tm_sec,\n                       tp->gmtoff < 0 ? '-' : '+',\n                       ngx_abs(tp->gmtoff / 60), ngx_abs(tp->gmtoff % 60));\n\n    p4 = &cached_syslog_time[slot][0];\n\n    (void) ngx_sprintf(p4, \"%s %2d %02d:%02d:%02d\",\n                       months[tm.ngx_tm_mon - 1], tm.ngx_tm_mday,\n                       tm.ngx_tm_hour, tm.ngx_tm_min, tm.ngx_tm_sec);\n\n    ngx_memory_barrier();\n\n    ngx_cached_time = tp;\n    ngx_cached_http_time.data = p0;\n    ngx_cached_err_log_time.data = p1;\n    ngx_cached_http_log_time.data = p2;\n    ngx_cached_http_log_iso8601.data = p3;\n    ngx_cached_syslog_time.data = p4;\n\n    ngx_unlock(&ngx_time_lock);\n}\n\n\n#if !(NGX_WIN32)\n\nvoid\nngx_time_sigsafe_update(void)\n{\n    u_char          *p, *p2;\n    ngx_tm_t         tm;\n    time_t           sec;\n    ngx_time_t      *tp;\n    struct timeval   tv;\n\n    if (!ngx_trylock(&ngx_time_lock)) {\n        return;\n    }\n\n    ngx_gettimeofday(&tv);\n\n    sec = tv.tv_sec;\n\n    tp = &cached_time[slot];\n\n    if (tp->sec == sec) {\n        ngx_unlock(&ngx_time_lock);\n        return;\n    }\n\n    if (slot == NGX_TIME_SLOTS - 1) {\n        slot = 0;\n    } else {\n        slot++;\n    }\n\n    tp = &cached_time[slot];\n\n    tp->sec = 0;\n\n    ngx_gmtime(sec + cached_gmtoff * 60, &tm);\n\n    p = &cached_err_log_time[slot][0];\n\n    (void) ngx_sprintf(p, \"%4d/%02d/%02d %02d:%02d:%02d\",\n                       tm.ngx_tm_year, tm.ngx_tm_mon,\n                       tm.ngx_tm_mday, tm.ngx_tm_hour,\n                       tm.ngx_tm_min, tm.ngx_tm_sec);\n\n    p2 = &cached_syslog_time[slot][0];\n\n    (void) ngx_sprintf(p2, \"%s %2d %02d:%02d:%02d\",\n                       months[tm.ngx_tm_mon - 1], tm.ngx_tm_mday,\n                       tm.ngx_tm_hour, tm.ngx_tm_min, tm.ngx_tm_sec);\n\n    ngx_memory_barrier();\n\n    ngx_cached_err_log_time.data = p;\n    ngx_cached_syslog_time.data = p2;\n\n    ngx_unlock(&ngx_time_lock);\n}\n\n#endif\n\n\nu_char *\nngx_http_time(u_char *buf, time_t t)\n{\n    ngx_tm_t  tm;\n\n    ngx_gmtime(t, &tm);\n\n    return ngx_sprintf(buf, \"%s, %02d %s %4d %02d:%02d:%02d GMT\",\n                       week[tm.ngx_tm_wday],\n                       tm.ngx_tm_mday,\n                       months[tm.ngx_tm_mon - 1],\n                       tm.ngx_tm_year,\n                       tm.ngx_tm_hour,\n                       tm.ngx_tm_min,\n                       tm.ngx_tm_sec);\n}\n\n\nu_char *\nngx_http_cookie_time(u_char *buf, time_t t)\n{\n    ngx_tm_t  tm;\n\n    ngx_gmtime(t, &tm);\n\n    /*\n     * Netscape 3.x does not understand 4-digit years at all and\n     * 2-digit years more than \"37\"\n     */\n\n    return ngx_sprintf(buf,\n                       (tm.ngx_tm_year > 2037) ?\n                                         \"%s, %02d-%s-%d %02d:%02d:%02d GMT\":\n                                         \"%s, %02d-%s-%02d %02d:%02d:%02d GMT\",\n                       week[tm.ngx_tm_wday],\n                       tm.ngx_tm_mday,\n                       months[tm.ngx_tm_mon - 1],\n                       (tm.ngx_tm_year > 2037) ? tm.ngx_tm_year:\n                                                 tm.ngx_tm_year % 100,\n                       tm.ngx_tm_hour,\n                       tm.ngx_tm_min,\n                       tm.ngx_tm_sec);\n}\n\n\nvoid\nngx_gmtime(time_t t, ngx_tm_t *tp)\n{\n    ngx_int_t   yday;\n    ngx_uint_t  n, sec, min, hour, mday, mon, year, wday, days, leap;\n\n    /* the calculation is valid for positive time_t only */\n\n    n = (ngx_uint_t) t;\n\n    days = n / 86400;\n\n    /* January 1, 1970 was Thursday */\n\n    wday = (4 + days) % 7;\n\n    n %= 86400;\n    hour = n / 3600;\n    n %= 3600;\n    min = n / 60;\n    sec = n % 60;\n\n    /*\n     * the algorithm based on Gauss' formula,\n     * see src/core/ngx_parse_time.c\n     */\n\n    /* days since March 1, 1 BC */\n    days = days - (31 + 28) + 719527;\n\n    /*\n     * The \"days\" should be adjusted to 1 only, however, some March 1st's go\n     * to previous year, so we adjust them to 2.  This causes also shift of the\n     * last February days to next year, but we catch the case when \"yday\"\n     * becomes negative.\n     */\n\n    year = (days + 2) * 400 / (365 * 400 + 100 - 4 + 1);\n\n    yday = days - (365 * year + year / 4 - year / 100 + year / 400);\n\n    if (yday < 0) {\n        leap = (year % 4 == 0) && (year % 100 || (year % 400 == 0));\n        yday = 365 + leap + yday;\n        year--;\n    }\n\n    /*\n     * The empirical formula that maps \"yday\" to month.\n     * There are at least 10 variants, some of them are:\n     *     mon = (yday + 31) * 15 / 459\n     *     mon = (yday + 31) * 17 / 520\n     *     mon = (yday + 31) * 20 / 612\n     */\n\n    mon = (yday + 31) * 10 / 306;\n\n    /* the Gauss' formula that evaluates days before the month */\n\n    mday = yday - (367 * mon / 12 - 30) + 1;\n\n    if (yday >= 306) {\n\n        year++;\n        mon -= 10;\n\n        /*\n         * there is no \"yday\" in Win32 SYSTEMTIME\n         *\n         * yday -= 306;\n         */\n\n    } else {\n\n        mon += 2;\n\n        /*\n         * there is no \"yday\" in Win32 SYSTEMTIME\n         *\n         * yday += 31 + 28 + leap;\n         */\n    }\n\n    tp->ngx_tm_sec = (ngx_tm_sec_t) sec;\n    tp->ngx_tm_min = (ngx_tm_min_t) min;\n    tp->ngx_tm_hour = (ngx_tm_hour_t) hour;\n    tp->ngx_tm_mday = (ngx_tm_mday_t) mday;\n    tp->ngx_tm_mon = (ngx_tm_mon_t) mon;\n    tp->ngx_tm_year = (ngx_tm_year_t) year;\n    tp->ngx_tm_wday = (ngx_tm_wday_t) wday;\n}\n\n\ntime_t\nngx_next_time(time_t when)\n{\n    time_t     now, next;\n    struct tm  tm;\n\n    now = ngx_time();\n\n    ngx_libc_localtime(now, &tm);\n\n    tm.tm_hour = (int) (when / 3600);\n    when %= 3600;\n    tm.tm_min = (int) (when / 60);\n    tm.tm_sec = (int) (when % 60);\n\n    next = mktime(&tm);\n\n    if (next == -1) {\n        return -1;\n    }\n\n    if (next - now > 0) {\n        return next;\n    }\n\n    tm.tm_mday++;\n\n    /* mktime() should normalize a date (Jan 32, etc) */\n\n    next = mktime(&tm);\n\n    if (next != -1) {\n        return next;\n    }\n\n    return -1;\n}\n"], "fixing_code": ["\n/*\n * Copyright (C) Igor Sysoev\n * Copyright (C) Nginx, Inc.\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n\n\n/*\n * The time may be updated by signal handler or by several threads.\n * The time update operations are rare and require to hold the ngx_time_lock.\n * The time read operations are frequent, so they are lock-free and get time\n * values and strings from the current slot.  Thus thread may get the corrupted\n * values only if it is preempted while copying and then it is not scheduled\n * to run more than NGX_TIME_SLOTS seconds.\n */\n\n#define NGX_TIME_SLOTS   64\n\nstatic ngx_uint_t        slot;\nstatic ngx_atomic_t      ngx_time_lock;\n\nvolatile ngx_msec_t      ngx_current_msec;\nvolatile ngx_time_t     *ngx_cached_time;\nvolatile ngx_str_t       ngx_cached_err_log_time;\nvolatile ngx_str_t       ngx_cached_http_time;\nvolatile ngx_str_t       ngx_cached_http_log_time;\nvolatile ngx_str_t       ngx_cached_http_log_iso8601;\nvolatile ngx_str_t       ngx_cached_syslog_time;\n\n#if !(NGX_WIN32)\n\n/*\n * localtime() and localtime_r() are not Async-Signal-Safe functions, therefore,\n * they must not be called by a signal handler, so we use the cached\n * GMT offset value. Fortunately the value is changed only two times a year.\n */\n\nstatic ngx_int_t         cached_gmtoff;\n#endif\n\nstatic ngx_time_t        cached_time[NGX_TIME_SLOTS];\nstatic u_char            cached_err_log_time[NGX_TIME_SLOTS]\n                                    [sizeof(\"1970/09/28 12:00:00\")];\nstatic u_char            cached_http_time[NGX_TIME_SLOTS]\n                                    [sizeof(\"Mon, 28 Sep 1970 06:00:00 GMT\")];\nstatic u_char            cached_http_log_time[NGX_TIME_SLOTS]\n                                    [sizeof(\"28/Sep/1970:12:00:00 +0600\")];\nstatic u_char            cached_http_log_iso8601[NGX_TIME_SLOTS]\n                                    [sizeof(\"1970-09-28T12:00:00+06:00\")];\nstatic u_char            cached_syslog_time[NGX_TIME_SLOTS]\n                                    [sizeof(\"Sep 28 12:00:00\")];\n\n\nstatic char  *week[] = { \"Sun\", \"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\" };\nstatic char  *months[] = { \"Jan\", \"Feb\", \"Mar\", \"Apr\", \"May\", \"Jun\",\n                           \"Jul\", \"Aug\", \"Sep\", \"Oct\", \"Nov\", \"Dec\" };\n\nvoid\nngx_time_init(void)\n{\n    ngx_cached_err_log_time.len = sizeof(\"1970/09/28 12:00:00\") - 1;\n    ngx_cached_http_time.len = sizeof(\"Mon, 28 Sep 1970 06:00:00 GMT\") - 1;\n    ngx_cached_http_log_time.len = sizeof(\"28/Sep/1970:12:00:00 +0600\") - 1;\n    ngx_cached_http_log_iso8601.len = sizeof(\"1970-09-28T12:00:00+06:00\") - 1;\n    ngx_cached_syslog_time.len = sizeof(\"Sep 28 12:00:00\") - 1;\n\n    ngx_cached_time = &cached_time[0];\n\n    ngx_time_update();\n}\n\n\nvoid\nngx_time_update(void)\n{\n    u_char          *p0, *p1, *p2, *p3, *p4;\n    ngx_tm_t         tm, gmt;\n    time_t           sec;\n    ngx_uint_t       msec;\n    ngx_time_t      *tp;\n    struct timeval   tv;\n\n    if (!ngx_trylock(&ngx_time_lock)) {\n        return;\n    }\n\n    ngx_gettimeofday(&tv);\n\n    sec = tv.tv_sec;\n    msec = tv.tv_usec / 1000;\n\n    ngx_current_msec = (ngx_msec_t) sec * 1000 + msec;\n\n    tp = &cached_time[slot];\n\n    if (tp->sec == sec) {\n        tp->msec = msec;\n        ngx_unlock(&ngx_time_lock);\n        return;\n    }\n\n    if (slot == NGX_TIME_SLOTS - 1) {\n        slot = 0;\n    } else {\n        slot++;\n    }\n\n    tp = &cached_time[slot];\n\n    tp->sec = sec;\n    tp->msec = msec;\n\n    ngx_gmtime(sec, &gmt);\n\n\n    p0 = &cached_http_time[slot][0];\n\n    (void) ngx_sprintf(p0, \"%s, %02d %s %4d %02d:%02d:%02d GMT\",\n                       week[gmt.ngx_tm_wday], gmt.ngx_tm_mday,\n                       months[gmt.ngx_tm_mon - 1], gmt.ngx_tm_year,\n                       gmt.ngx_tm_hour, gmt.ngx_tm_min, gmt.ngx_tm_sec);\n\n#if (NGX_HAVE_GETTIMEZONE)\n\n    tp->gmtoff = ngx_gettimezone();\n    ngx_gmtime(sec + tp->gmtoff * 60, &tm);\n\n#elif (NGX_HAVE_GMTOFF)\n\n    ngx_localtime(sec, &tm);\n    cached_gmtoff = (ngx_int_t) (tm.ngx_tm_gmtoff / 60);\n    tp->gmtoff = cached_gmtoff;\n\n#else\n\n    ngx_localtime(sec, &tm);\n    cached_gmtoff = ngx_timezone(tm.ngx_tm_isdst);\n    tp->gmtoff = cached_gmtoff;\n\n#endif\n\n\n    p1 = &cached_err_log_time[slot][0];\n\n    (void) ngx_sprintf(p1, \"%4d/%02d/%02d %02d:%02d:%02d\",\n                       tm.ngx_tm_year, tm.ngx_tm_mon,\n                       tm.ngx_tm_mday, tm.ngx_tm_hour,\n                       tm.ngx_tm_min, tm.ngx_tm_sec);\n\n\n    p2 = &cached_http_log_time[slot][0];\n\n    (void) ngx_sprintf(p2, \"%02d/%s/%d:%02d:%02d:%02d %c%02i%02i\",\n                       tm.ngx_tm_mday, months[tm.ngx_tm_mon - 1],\n                       tm.ngx_tm_year, tm.ngx_tm_hour,\n                       tm.ngx_tm_min, tm.ngx_tm_sec,\n                       tp->gmtoff < 0 ? '-' : '+',\n                       ngx_abs(tp->gmtoff / 60), ngx_abs(tp->gmtoff % 60));\n\n    p3 = &cached_http_log_iso8601[slot][0];\n\n    (void) ngx_sprintf(p3, \"%4d-%02d-%02dT%02d:%02d:%02d%c%02i:%02i\",\n                       tm.ngx_tm_year, tm.ngx_tm_mon,\n                       tm.ngx_tm_mday, tm.ngx_tm_hour,\n                       tm.ngx_tm_min, tm.ngx_tm_sec,\n                       tp->gmtoff < 0 ? '-' : '+',\n                       ngx_abs(tp->gmtoff / 60), ngx_abs(tp->gmtoff % 60));\n\n    p4 = &cached_syslog_time[slot][0];\n\n    (void) ngx_sprintf(p4, \"%s %2d %02d:%02d:%02d\",\n                       months[tm.ngx_tm_mon - 1], tm.ngx_tm_mday,\n                       tm.ngx_tm_hour, tm.ngx_tm_min, tm.ngx_tm_sec);\n\n    ngx_memory_barrier();\n\n    ngx_cached_time = tp;\n    ngx_cached_http_time.data = p0;\n    ngx_cached_err_log_time.data = p1;\n    ngx_cached_http_log_time.data = p2;\n    ngx_cached_http_log_iso8601.data = p3;\n    ngx_cached_syslog_time.data = p4;\n\n    ngx_unlock(&ngx_time_lock);\n}\n\n\n#if !(NGX_WIN32)\n\nvoid\nngx_time_sigsafe_update(void)\n{\n    u_char          *p, *p2;\n    ngx_tm_t         tm;\n    time_t           sec;\n    ngx_time_t      *tp;\n    struct timeval   tv;\n\n    if (!ngx_trylock(&ngx_time_lock)) {\n        return;\n    }\n\n    ngx_gettimeofday(&tv);\n\n    sec = tv.tv_sec;\n\n    tp = &cached_time[slot];\n\n    if (tp->sec == sec) {\n        ngx_unlock(&ngx_time_lock);\n        return;\n    }\n\n    if (slot == NGX_TIME_SLOTS - 1) {\n        slot = 0;\n    } else {\n        slot++;\n    }\n\n    tp = &cached_time[slot];\n\n    tp->sec = 0;\n\n    ngx_gmtime(sec + cached_gmtoff * 60, &tm);\n\n    p = &cached_err_log_time[slot][0];\n\n    (void) ngx_sprintf(p, \"%4d/%02d/%02d %02d:%02d:%02d\",\n                       tm.ngx_tm_year, tm.ngx_tm_mon,\n                       tm.ngx_tm_mday, tm.ngx_tm_hour,\n                       tm.ngx_tm_min, tm.ngx_tm_sec);\n\n    p2 = &cached_syslog_time[slot][0];\n\n    (void) ngx_sprintf(p2, \"%s %2d %02d:%02d:%02d\",\n                       months[tm.ngx_tm_mon - 1], tm.ngx_tm_mday,\n                       tm.ngx_tm_hour, tm.ngx_tm_min, tm.ngx_tm_sec);\n\n    ngx_memory_barrier();\n\n    ngx_cached_err_log_time.data = p;\n    ngx_cached_syslog_time.data = p2;\n\n    ngx_unlock(&ngx_time_lock);\n}\n\n#endif\n\n\nu_char *\nngx_http_time(u_char *buf, time_t t)\n{\n    ngx_tm_t  tm;\n\n    ngx_gmtime(t, &tm);\n\n    return ngx_sprintf(buf, \"%s, %02d %s %4d %02d:%02d:%02d GMT\",\n                       week[tm.ngx_tm_wday],\n                       tm.ngx_tm_mday,\n                       months[tm.ngx_tm_mon - 1],\n                       tm.ngx_tm_year,\n                       tm.ngx_tm_hour,\n                       tm.ngx_tm_min,\n                       tm.ngx_tm_sec);\n}\n\n\nu_char *\nngx_http_cookie_time(u_char *buf, time_t t)\n{\n    ngx_tm_t  tm;\n\n    ngx_gmtime(t, &tm);\n\n    /*\n     * Netscape 3.x does not understand 4-digit years at all and\n     * 2-digit years more than \"37\"\n     */\n\n    return ngx_sprintf(buf,\n                       (tm.ngx_tm_year > 2037) ?\n                                         \"%s, %02d-%s-%d %02d:%02d:%02d GMT\":\n                                         \"%s, %02d-%s-%02d %02d:%02d:%02d GMT\",\n                       week[tm.ngx_tm_wday],\n                       tm.ngx_tm_mday,\n                       months[tm.ngx_tm_mon - 1],\n                       (tm.ngx_tm_year > 2037) ? tm.ngx_tm_year:\n                                                 tm.ngx_tm_year % 100,\n                       tm.ngx_tm_hour,\n                       tm.ngx_tm_min,\n                       tm.ngx_tm_sec);\n}\n\n\nvoid\nngx_gmtime(time_t t, ngx_tm_t *tp)\n{\n    ngx_int_t   yday;\n    ngx_uint_t  sec, min, hour, mday, mon, year, wday, days, leap;\n\n    /* the calculation is valid for positive time_t only */\n\n    if (t < 0) {\n        t = 0;\n    }\n\n    days = t / 86400;\n    sec = t % 86400;\n\n    /* January 1, 1970 was Thursday */\n\n    wday = (4 + days) % 7;\n\n    hour = sec / 3600;\n    sec %= 3600;\n    min = sec / 60;\n    sec %= 60;\n\n    /*\n     * the algorithm based on Gauss' formula,\n     * see src/core/ngx_parse_time.c\n     */\n\n    /* days since March 1, 1 BC */\n    days = days - (31 + 28) + 719527;\n\n    /*\n     * The \"days\" should be adjusted to 1 only, however, some March 1st's go\n     * to previous year, so we adjust them to 2.  This causes also shift of the\n     * last February days to next year, but we catch the case when \"yday\"\n     * becomes negative.\n     */\n\n    year = (days + 2) * 400 / (365 * 400 + 100 - 4 + 1);\n\n    yday = days - (365 * year + year / 4 - year / 100 + year / 400);\n\n    if (yday < 0) {\n        leap = (year % 4 == 0) && (year % 100 || (year % 400 == 0));\n        yday = 365 + leap + yday;\n        year--;\n    }\n\n    /*\n     * The empirical formula that maps \"yday\" to month.\n     * There are at least 10 variants, some of them are:\n     *     mon = (yday + 31) * 15 / 459\n     *     mon = (yday + 31) * 17 / 520\n     *     mon = (yday + 31) * 20 / 612\n     */\n\n    mon = (yday + 31) * 10 / 306;\n\n    /* the Gauss' formula that evaluates days before the month */\n\n    mday = yday - (367 * mon / 12 - 30) + 1;\n\n    if (yday >= 306) {\n\n        year++;\n        mon -= 10;\n\n        /*\n         * there is no \"yday\" in Win32 SYSTEMTIME\n         *\n         * yday -= 306;\n         */\n\n    } else {\n\n        mon += 2;\n\n        /*\n         * there is no \"yday\" in Win32 SYSTEMTIME\n         *\n         * yday += 31 + 28 + leap;\n         */\n    }\n\n    tp->ngx_tm_sec = (ngx_tm_sec_t) sec;\n    tp->ngx_tm_min = (ngx_tm_min_t) min;\n    tp->ngx_tm_hour = (ngx_tm_hour_t) hour;\n    tp->ngx_tm_mday = (ngx_tm_mday_t) mday;\n    tp->ngx_tm_mon = (ngx_tm_mon_t) mon;\n    tp->ngx_tm_year = (ngx_tm_year_t) year;\n    tp->ngx_tm_wday = (ngx_tm_wday_t) wday;\n}\n\n\ntime_t\nngx_next_time(time_t when)\n{\n    time_t     now, next;\n    struct tm  tm;\n\n    now = ngx_time();\n\n    ngx_libc_localtime(now, &tm);\n\n    tm.tm_hour = (int) (when / 3600);\n    when %= 3600;\n    tm.tm_min = (int) (when / 60);\n    tm.tm_sec = (int) (when % 60);\n\n    next = mktime(&tm);\n\n    if (next == -1) {\n        return -1;\n    }\n\n    if (next - now > 0) {\n        return next;\n    }\n\n    tm.tm_mday++;\n\n    /* mktime() should normalize a date (Jan 32, etc) */\n\n    next = mktime(&tm);\n\n    if (next != -1) {\n        return next;\n    }\n\n    return -1;\n}\n"], "filenames": ["src/core/ngx_times.c"], "buggy_code_start_loc": [303], "buggy_code_end_loc": [320], "fixing_code_start_loc": [303], "fixing_code_end_loc": [322], "type": "CWE-190", "message": "NGINX before 1.13.6 has a buffer overflow for years that exceed four digits, as demonstrated by a file with a modification date in 1969 that causes an integer overflow (or a false modification date far in the future), when encountered by the autoindex module.", "other": {"cve": {"id": "CVE-2017-20005", "sourceIdentifier": "cve@mitre.org", "published": "2021-06-06T22:15:08.417", "lastModified": "2021-12-02T19:43:01.953", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "NGINX before 1.13.6 has a buffer overflow for years that exceed four digits, as demonstrated by a file with a modification date in 1969 that causes an integer overflow (or a false modification date far in the future), when encountered by the autoindex module."}, {"lang": "es", "value": "NGINX versiones anteriores a 1.13.6, presenta un desbordamiento de b\u00fafer para los a\u00f1os que superan los cuatro d\u00edgitos, como es demostrado por un archivo con una fecha de modificaci\u00f3n en 1969 que causa un desbordamiento de enteros (o una falsa fecha de modificaci\u00f3n en el futuro), cuando es encontrado por el m\u00f3dulo autoindex"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-190"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:f5:nginx:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.13.6", "matchCriteriaId": "A212321D-5686-4DFF-80DD-3C3AF03971A7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}], "references": [{"url": "http://nginx.org/en/CHANGES", "source": "cve@mitre.org", "tags": ["Release Notes", "Vendor Advisory"]}, {"url": "https://github.com/nginx/nginx/commit/0206ebe76f748bb39d9de4dd4b3fce777fdfdccf", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/nginx/nginx/commit/b900cc28fcbb4cf5a32ab62f80b59292e1c85b4b", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2021/06/msg00009.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://security.netapp.com/advisory/ntap-20210805-0006/", "source": "cve@mitre.org", "tags": ["Third Party Advisory"]}, {"url": "https://trac.nginx.org/nginx/ticket/1368", "source": "cve@mitre.org", "tags": ["Exploit", "Patch", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/nginx/nginx/commit/0206ebe76f748bb39d9de4dd4b3fce777fdfdccf"}}