{"buggy_code": ["/** @file compression.c\n *  @brief Functions handling compression\n *\n * Copyright (c) 2014 Bartek Fabiszewski\n * http://www.fabiszewski.net\n *\n * This file is part of libmobi.\n * Licensed under LGPL, either version 3, or any later.\n * See <http://www.gnu.org/licenses/>\n */\n\n#include <string.h>\n#include \"compression.h\"\n#include \"buffer.h\"\n#include \"mobi.h\"\n#include \"debug.h\"\n\n\n/** \n @brief Decompressor fo PalmDOC version of LZ77 compression\n\n Decompressor based on this algorithm:\n http://en.wikibooks.org/wiki/Data_Compression/Dictionary_compression#PalmDoc\n\n @param[out] out Decompressed destination data\n @param[in] in Compressed source data\n @param[in,out] len_out Size of the memory reserved for decompressed data.\n On return it is set to actual size of decompressed data\n @param[in] len_in Size of compressed data\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_decompress_lz77(unsigned char *out, const unsigned char *in, size_t *len_out, const size_t len_in) {\n    MOBI_RET ret = MOBI_SUCCESS;\n    MOBIBuffer *buf_in = mobi_buffer_init_null((unsigned char *) in, len_in);\n    if (buf_in == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    MOBIBuffer *buf_out = mobi_buffer_init_null(out, *len_out);\n    if (buf_out == NULL) {\n        mobi_buffer_free_null(buf_in);\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    while (ret == MOBI_SUCCESS && buf_in->offset < buf_in->maxlen) {\n        uint8_t byte = mobi_buffer_get8(buf_in);\n        /* byte pair: space + char */\n        if (byte >= 0xc0) {\n            mobi_buffer_add8(buf_out, ' ');\n            mobi_buffer_add8(buf_out, byte ^ 0x80);\n        }\n        /* length, distance pair */\n        /* 0x8000 + (distance << 3) + ((length-3) & 0x07) */\n        else if (byte >= 0x80) {\n            uint8_t next = mobi_buffer_get8(buf_in);\n            uint16_t distance = ((((byte << 8) | ((uint8_t)next)) >> 3) & 0x7ff);\n            uint8_t length = (next & 0x7) + 3;\n            while (length--) {\n                mobi_buffer_move(buf_out, -distance, 1);\n            }\n        }\n        /* single char, not modified */\n        else if (byte >= 0x09) {\n            mobi_buffer_add8(buf_out, byte);\n        }\n        /* val chars not modified */\n        else if (byte >= 0x01) {\n            mobi_buffer_copy(buf_out, buf_in, byte);\n        }\n        /* char '\\0', not modified */\n        else {\n            mobi_buffer_add8(buf_out, byte);\n        }\n        if (buf_in->error || buf_out->error) {\n            ret = MOBI_BUFFER_END;\n        }\n    }\n    *len_out = buf_out->offset;\n    mobi_buffer_free_null(buf_out);\n    mobi_buffer_free_null(buf_in);\n    return ret;\n}\n\n/**\n @brief Read at most 8 bytes from buffer, big-endian\n \n If buffer data is shorter returned value is padded with zeroes\n \n @param[in] buf MOBIBuffer structure to read from\n @return 64-bit value\n */\nstatic MOBI_INLINE uint64_t mobi_buffer_fill64(MOBIBuffer *buf) {\n    uint64_t val = 0;\n    uint8_t i = 8;\n    size_t bytesleft = buf->maxlen - buf->offset;\n    unsigned char *ptr = buf->data + buf->offset;\n    while (i-- && bytesleft--) {\n        val |= (uint64_t) *ptr++ << (i * 8);\n    }\n    /* increase counter by 4 bytes only, 4 bytes overlap on each call */\n    buf->offset += 4;\n    return val;\n}\n\n/**\n @brief Internal function for huff/cdic decompression\n \n Decompressor and HUFF/CDIC records parsing based on:\n perl EBook::Tools::Mobipocket\n python mobiunpack.py, calibre\n \n @param[out] buf_out MOBIBuffer structure with decompressed data\n @param[in] buf_in MOBIBuffer structure with compressed data\n @param[in] huffcdic MOBIHuffCdic structure with parsed data from huff/cdic records\n @param[in] depth Depth of current recursion level\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nstatic MOBI_RET mobi_decompress_huffman_internal(MOBIBuffer *buf_out, MOBIBuffer *buf_in, const MOBIHuffCdic *huffcdic, size_t depth) {\n    if (depth > MOBI_HUFFMAN_MAXDEPTH) {\n        debug_print(\"Too many levels of recursion: %zu\\n\", depth);\n        return MOBI_DATA_CORRUPT;\n    }\n    MOBI_RET ret = MOBI_SUCCESS;\n    int8_t bitcount = 32;\n    /* this cast should be safe: max record size is 4096 */\n    int bitsleft = (int) (buf_in->maxlen * 8);\n    uint8_t code_length = 0;\n    uint64_t buffer = mobi_buffer_fill64(buf_in);\n    while (ret == MOBI_SUCCESS) {\n        if (bitcount <= 0) {\n            bitcount += 32;\n            buffer = mobi_buffer_fill64(buf_in);\n        }\n        uint32_t code = (buffer >> bitcount) & 0xffffffffU;\n        /* lookup code in table1 */\n        uint32_t t1 = huffcdic->table1[code >> 24];\n        /* get maxcode and codelen from t1 */\n        code_length = t1 & 0x1f;\n        uint32_t maxcode = (((t1 >> 8) + 1) << (32 - code_length)) - 1;\n        /* check termination bit */\n        if (!(t1 & 0x80)) {\n            /* get offset from mincode, maxcode tables */\n            while (code < huffcdic->mincode_table[code_length]) {\n                code_length++;\n            }\n            maxcode = huffcdic->maxcode_table[code_length];\n        }\n        bitcount -= code_length;\n        bitsleft -= code_length;\n        if (bitsleft < 0) {\n            break;\n        }\n        /* get index for symbol offset */\n        uint32_t index = (uint32_t) (maxcode - code) >> (32 - code_length);\n        /* check which part of cdic to use */\n        uint16_t cdic_index = (uint16_t) ((uint32_t)index >> huffcdic->code_length);\n        if (index >= huffcdic->index_count) {\n            debug_print(\"Wrong symbol offsets index: %u\\n\", index);\n            return MOBI_DATA_CORRUPT;\n        }\n        /* get offset */\n        uint32_t offset = huffcdic->symbol_offsets[index];\n        uint32_t symbol_length = (uint32_t) huffcdic->symbols[cdic_index][offset] << 8 | (uint32_t) huffcdic->symbols[cdic_index][offset + 1];\n        /* 1st bit is is_decompressed flag */\n        int is_decompressed = symbol_length >> 15;\n        /* get rid of flag */\n        symbol_length &= 0x7fff;\n        if (is_decompressed) {\n            /* symbol is at (offset + 2), 2 bytes used earlier for symbol length */\n            mobi_buffer_addraw(buf_out, (huffcdic->symbols[cdic_index] + offset + 2), symbol_length);\n            ret = buf_out->error;\n        } else {\n            /* symbol is compressed */\n            /* TODO cache uncompressed symbols? */\n            MOBIBuffer buf_sym;\n            buf_sym.data = huffcdic->symbols[cdic_index] + offset + 2;\n            buf_sym.offset = 0;\n            buf_sym.maxlen = symbol_length;\n            buf_sym.error = MOBI_SUCCESS;\n            ret = mobi_decompress_huffman_internal(buf_out, &buf_sym, huffcdic, depth + 1);\n        }\n    }\n    return ret;\n}\n\n/**\n @brief Decompressor for huff/cdic compressed text records\n \n Decompressor and HUFF/CDIC records parsing based on:\n perl EBook::Tools::Mobipocket\n python mobiunpack.py, calibre\n \n @param[out] out Decompressed destination data\n @param[in] in Compressed source data\n @param[in,out] len_out Size of the memory reserved for decompressed data.\n On return it is set to actual size of decompressed data\n @param[in] len_in Size of compressed data\n @param[in] huffcdic MOBIHuffCdic structure with parsed data from huff/cdic records\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_decompress_huffman(unsigned char *out, const unsigned char *in, size_t *len_out, size_t len_in, const MOBIHuffCdic *huffcdic) {\n    MOBIBuffer *buf_in = mobi_buffer_init_null((unsigned char *) in, len_in);\n    if (buf_in == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    MOBIBuffer *buf_out = mobi_buffer_init_null(out, *len_out);\n    if (buf_out == NULL) {\n        mobi_buffer_free_null(buf_in);\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    MOBI_RET ret = mobi_decompress_huffman_internal(buf_out, buf_in, huffcdic, 0);\n    *len_out = buf_out->offset;\n    mobi_buffer_free_null(buf_out);\n    mobi_buffer_free_null(buf_in);\n    return ret;\n}\n", "/** @file compression.h\n *\n * Copyright (c) 2014 Bartek Fabiszewski\n * http://www.fabiszewski.net\n *\n * This file is part of libmobi.\n * Licensed under LGPL, either version 3, or any later.\n * See <http://www.gnu.org/licenses/>\n */\n\n#ifndef libmobi_compression_h\n#define libmobi_compression_h\n\n#include \"config.h\"\n#include \"mobi.h\"\n\n#ifndef MOBI_INLINE\n#define MOBI_INLINE /**< Syntax for compiler inline keyword from config.h */\n#endif\n\n/* FIXME: what is the reasonable value? */\n#define MOBI_HUFFMAN_MAXDEPTH 20 /**< Maximal recursion level for huffman decompression routine */\n\n\n/**\n @brief Parsed data from HUFF and CDIC records needed to unpack huffman compressed text\n */\ntypedef struct {\n    size_t index_count; /**< Total number of indices in all CDIC records, stored in each CDIC record header */\n    size_t index_read; /**< Number of indices parsed, used by parser */\n    size_t code_length; /**< Code length value stored in CDIC record header */\n    uint32_t table1[256]; /**< Table of big-endian indices from HUFF record data1 */\n    uint32_t mincode_table[33]; /**< Table of big-endian mincodes from HUFF record data2 */\n    uint32_t maxcode_table[33]; /**< Table of big-endian maxcodes from HUFF record data2 */\n    uint16_t *symbol_offsets; /**< Index of symbol offsets parsed from CDIC records (index_count entries) */\n    unsigned char **symbols; /**< Array of pointers to start of symbols data in each CDIC record (index = number of CDIC record) */\n} MOBIHuffCdic;\n\nMOBI_RET mobi_decompress_lz77(unsigned char *out, const unsigned char *in, size_t *len_out, const size_t len_in);\nMOBI_RET mobi_decompress_huffman(unsigned char *out, const unsigned char *in, size_t *len_out, size_t len_in, const MOBIHuffCdic *huffcdic);\n\n#endif\n", "/** @file read.c\n *  @brief Functions for reading and parsing of MOBI document\n *\n * Copyright (c) 2014 Bartek Fabiszewski\n * http://www.fabiszewski.net\n *\n * This file is part of libmobi.\n * Licensed under LGPL, either version 3, or any later.\n * See <http://www.gnu.org/licenses/>\n */\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"read.h\"\n#include \"util.h\"\n#include \"index.h\"\n#include \"debug.h\"\n\n/**\n @brief Read palm database header from file into MOBIData structure (MOBIPdbHeader)\n \n @param[in,out] m MOBIData structure to be filled with read data\n @param[in] file Filedescriptor to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_load_pdbheader(MOBIData *m, FILE *file) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    if (!file) {\n        return MOBI_FILE_NOT_FOUND;\n    }\n    MOBIBuffer *buf = mobi_buffer_init(PALMDB_HEADER_LEN);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    const size_t len = fread(buf->data, 1, PALMDB_HEADER_LEN, file);\n    if (len != PALMDB_HEADER_LEN) {\n        mobi_buffer_free(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    m->ph = calloc(1, sizeof(MOBIPdbHeader));\n    if (m->ph == NULL) {\n        debug_print(\"%s\", \"Memory allocation for pdb header failed\\n\");\n        mobi_buffer_free(buf);\n        return MOBI_MALLOC_FAILED;\n    }\n    /* parse header */\n    mobi_buffer_getstring(m->ph->name, buf, PALMDB_NAME_SIZE_MAX);\n    m->ph->attributes = mobi_buffer_get16(buf);\n    m->ph->version = mobi_buffer_get16(buf);\n    m->ph->ctime = mobi_buffer_get32(buf);\n    m->ph->mtime = mobi_buffer_get32(buf);\n    m->ph->btime = mobi_buffer_get32(buf);\n    m->ph->mod_num = mobi_buffer_get32(buf);\n    m->ph->appinfo_offset = mobi_buffer_get32(buf);\n    m->ph->sortinfo_offset = mobi_buffer_get32(buf);\n    mobi_buffer_getstring(m->ph->type, buf, 4);\n    mobi_buffer_getstring(m->ph->creator, buf, 4);\n    m->ph->uid = mobi_buffer_get32(buf);\n    m->ph->next_rec = mobi_buffer_get32(buf);\n    m->ph->rec_count = mobi_buffer_get16(buf);\n    mobi_buffer_free(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Read list of database records from file into MOBIData structure (MOBIPdbRecord)\n \n @param[in,out] m MOBIData structure to be filled with read data\n @param[in] file Filedescriptor to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_load_reclist(MOBIData *m, FILE *file) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    if (!file) {\n        debug_print(\"%s\", \"File not ready\\n\");\n        return MOBI_FILE_NOT_FOUND;\n    }\n    m->rec = calloc(1, sizeof(MOBIPdbRecord));\n    if (m->rec == NULL) {\n        debug_print(\"%s\", \"Memory allocation for pdb record failed\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    MOBIPdbRecord *curr = m->rec;\n    for (int i = 0; i < m->ph->rec_count; i++) {\n        MOBIBuffer *buf = mobi_buffer_init(PALMDB_RECORD_INFO_SIZE);\n        if (buf == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        const size_t len = fread(buf->data, 1, PALMDB_RECORD_INFO_SIZE, file);\n        if (len != PALMDB_RECORD_INFO_SIZE) {\n            mobi_buffer_free(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        if (i > 0) {\n            curr->next = calloc(1, sizeof(MOBIPdbRecord));\n            if (curr->next == NULL) {\n                debug_print(\"%s\", \"Memory allocation for pdb record failed\\n\");\n                mobi_buffer_free(buf);\n                return MOBI_MALLOC_FAILED;\n            }\n            curr = curr->next;\n        }\n        curr->offset = mobi_buffer_get32(buf);\n        curr->attributes = mobi_buffer_get8(buf);\n        const uint8_t h = mobi_buffer_get8(buf);\n        const uint16_t l = mobi_buffer_get16(buf);\n        curr->uid =  (uint32_t) h << 16 | l;\n        curr->next = NULL;\n        mobi_buffer_free(buf);\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Read record data and size from file into MOBIData structure (MOBIPdbRecord)\n \n @param[in,out] m MOBIData structure to be filled with read data\n @param[in] file Filedescriptor to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_load_rec(MOBIData *m, FILE *file) {\n    MOBI_RET ret;\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    MOBIPdbRecord *curr = m->rec;\n    while (curr != NULL) {\n        MOBIPdbRecord *next;\n        size_t size;\n        if (curr->next != NULL) {\n            next = curr->next;\n            size = next->offset - curr->offset;\n        } else {\n            fseek(file, 0, SEEK_END);\n            long diff = ftell(file) - curr->offset;\n            if (diff <= 0) {\n                debug_print(\"Wrong record size: %li\\n\", diff);\n                return MOBI_DATA_CORRUPT;\n            }\n            size = (size_t) diff;\n            next = NULL;\n        }\n\n        curr->size = size;\n        ret = mobi_load_recdata(curr, file);\n        if (ret  != MOBI_SUCCESS) {\n            debug_print(\"Error loading record uid %i data\\n\", curr->uid);\n            mobi_free_rec(m);\n            return ret;\n        }\n        curr = next;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Read record data from file into MOBIPdbRecord structure\n \n @param[in,out] rec MOBIPdbRecord structure to be filled with read data\n @param[in] file Filedescriptor to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_load_recdata(MOBIPdbRecord *rec, FILE *file) {\n    const int ret = fseek(file, rec->offset, SEEK_SET);\n    if (ret != 0) {\n        debug_print(\"Record %i not found\\n\", rec->uid);\n        return MOBI_DATA_CORRUPT;\n    }\n    rec->data = malloc(rec->size);\n    if (rec->data == NULL) {\n        debug_print(\"%s\", \"Memory allocation for pdb record data failed\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    const size_t len = fread(rec->data, 1, rec->size, file);\n    if (len < rec->size) {\n        debug_print(\"Truncated data in record %i\\n\", rec->uid);\n        return MOBI_DATA_CORRUPT;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse EXTH header from Record 0 into MOBIData structure (MOBIExthHeader)\n \n @param[in,out] m MOBIData structure to be filled with parsed data\n @param[in] buf MOBIBuffer buffer to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_extheader(MOBIData *m, MOBIBuffer *buf) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    char exth_magic[5];\n    const size_t header_length = 12;\n    mobi_buffer_getstring(exth_magic, buf, 4);\n    const size_t exth_length = mobi_buffer_get32(buf) - header_length;\n    const size_t rec_count = mobi_buffer_get32(buf);\n    if (strncmp(exth_magic, EXTH_MAGIC, 4) != 0 ||\n        exth_length + buf->offset > buf->maxlen ||\n        rec_count == 0 || rec_count > MOBI_EXTH_MAXCNT) {\n        debug_print(\"%s\", \"Sanity checks for EXTH header failed\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t saved_maxlen = buf->maxlen;\n    buf->maxlen = exth_length + buf->offset;\n    m->eh = calloc(1, sizeof(MOBIExthHeader));\n    if (m->eh == NULL) {\n        debug_print(\"%s\", \"Memory allocation for EXTH header failed\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    MOBIExthHeader *curr = m->eh;\n    for (size_t i = 0; i < rec_count; i++) {\n        if (curr->data) {\n            curr->next = calloc(1, sizeof(MOBIExthHeader));\n            if (curr->next == NULL) {\n                debug_print(\"%s\", \"Memory allocation for EXTH header failed\\n\");\n                mobi_free_eh(m);\n                return MOBI_MALLOC_FAILED;\n            }\n            curr = curr->next;\n        }\n        curr->tag = mobi_buffer_get32(buf);\n        /* data size = record size minus 8 bytes for uid and size */\n        curr->size = mobi_buffer_get32(buf) - 8;\n        if (curr->size == 0) {\n            debug_print(\"Skip record %i, data too short\\n\", curr->tag);\n            continue;\n        }\n        if (buf->offset + curr->size > buf->maxlen) {\n            debug_print(\"Record %i too long\\n\", curr->tag);\n            mobi_free_eh(m);\n            return MOBI_DATA_CORRUPT;\n        }\n        curr->data = malloc(curr->size);\n        if (curr->data == NULL) {\n            debug_print(\"Memory allocation for EXTH record %i failed\\n\", curr->tag);\n            mobi_free_eh(m);\n            return MOBI_MALLOC_FAILED;\n        }\n        mobi_buffer_getraw(curr->data, buf, curr->size);\n        curr->next = NULL;\n    }    \n    buf->maxlen = saved_maxlen;\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse MOBI header from Record 0 into MOBIData structure (MOBIMobiHeader)\n \n @param[in,out] m MOBIData structure to be filled with parsed data\n @param[in] buf MOBIBuffer buffer to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_mobiheader(MOBIData *m, MOBIBuffer *buf) {\n    int isKF8 = 0;\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    m->mh = calloc(1, sizeof(MOBIMobiHeader));\n    if (m->mh == NULL) {\n        debug_print(\"%s\", \"Memory allocation for MOBI header failed\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    mobi_buffer_getstring(m->mh->mobi_magic, buf, 4);\n    mobi_buffer_dup32(&m->mh->header_length, buf);\n    if (strcmp(m->mh->mobi_magic, MOBI_MAGIC) != 0 || m->mh->header_length == NULL) {\n        debug_print(\"%s\", \"MOBI header not found\\n\");\n        mobi_free_mh(m->mh);\n        m->mh = NULL;\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t saved_maxlen = buf->maxlen;\n    /* some old files declare zero length mobi header, try to read first 24 bytes anyway */\n    uint32_t header_length = (*m->mh->header_length > 0) ? *m->mh->header_length : 24;\n    /* read only declared MOBI header length (curr offset minus 8 already read bytes) */\n    const size_t left_length = header_length + buf->offset - 8;\n    buf->maxlen = saved_maxlen < left_length ? saved_maxlen : left_length;\n    mobi_buffer_dup32(&m->mh->mobi_type, buf);\n    uint32_t encoding = mobi_buffer_get32(buf);\n    if (encoding == 1252) {\n        m->mh->text_encoding = malloc(sizeof(MOBIEncoding));\n        if (m->mh->text_encoding == NULL) {\n            debug_print(\"%s\", \"Memory allocation for MOBI header failed\\n\");\n            return MOBI_MALLOC_FAILED;\n        }\n        *m->mh->text_encoding = MOBI_CP1252;\n    }\n    else if (encoding == 65001) {\n        m->mh->text_encoding = malloc(sizeof(MOBIEncoding));\n        if (m->mh->text_encoding == NULL) {\n            debug_print(\"%s\", \"Memory allocation for MOBI header failed\\n\");\n            return MOBI_MALLOC_FAILED;\n        }\n        *m->mh->text_encoding = MOBI_UTF8;\n    } else {\n        debug_print(\"Unknown encoding in mobi header: %i\\n\", encoding);\n    }\n    mobi_buffer_dup32(&m->mh->uid, buf);\n    mobi_buffer_dup32(&m->mh->version, buf);\n    if (header_length >= MOBI_HEADER_V7_SIZE\n        && m->mh->version && *m->mh->version == 8) {\n        isKF8 = 1;\n    }\n    mobi_buffer_dup32(&m->mh->orth_index, buf);\n    mobi_buffer_dup32(&m->mh->infl_index, buf);\n    mobi_buffer_dup32(&m->mh->names_index, buf);\n    mobi_buffer_dup32(&m->mh->keys_index, buf);\n    mobi_buffer_dup32(&m->mh->extra0_index, buf);\n    mobi_buffer_dup32(&m->mh->extra1_index, buf);\n    mobi_buffer_dup32(&m->mh->extra2_index, buf);\n    mobi_buffer_dup32(&m->mh->extra3_index, buf);\n    mobi_buffer_dup32(&m->mh->extra4_index, buf);\n    mobi_buffer_dup32(&m->mh->extra5_index, buf);\n    mobi_buffer_dup32(&m->mh->non_text_index, buf);\n    mobi_buffer_dup32(&m->mh->full_name_offset, buf);\n    mobi_buffer_dup32(&m->mh->full_name_length, buf);\n    mobi_buffer_dup32(&m->mh->locale, buf);\n    mobi_buffer_dup32(&m->mh->dict_input_lang, buf);\n    mobi_buffer_dup32(&m->mh->dict_output_lang, buf);\n    mobi_buffer_dup32(&m->mh->min_version, buf);\n    mobi_buffer_dup32(&m->mh->image_index, buf);\n    mobi_buffer_dup32(&m->mh->huff_rec_index, buf);\n    mobi_buffer_dup32(&m->mh->huff_rec_count, buf);\n    mobi_buffer_dup32(&m->mh->datp_rec_index, buf);\n    mobi_buffer_dup32(&m->mh->datp_rec_count, buf);\n    mobi_buffer_dup32(&m->mh->exth_flags, buf);\n    mobi_buffer_seek(buf, 32); /* 32 unknown bytes */\n    mobi_buffer_dup32(&m->mh->unknown6, buf);\n    mobi_buffer_dup32(&m->mh->drm_offset, buf);\n    mobi_buffer_dup32(&m->mh->drm_count, buf);\n    mobi_buffer_dup32(&m->mh->drm_size, buf);\n    mobi_buffer_dup32(&m->mh->drm_flags, buf);\n    mobi_buffer_seek(buf, 8); /* 8 unknown bytes */\n    if (isKF8) {\n        mobi_buffer_dup32(&m->mh->fdst_index, buf);\n    } else {\n        mobi_buffer_dup16(&m->mh->first_text_index, buf);\n        mobi_buffer_dup16(&m->mh->last_text_index, buf);\n    }\n    mobi_buffer_dup32(&m->mh->fdst_section_count, buf);\n    mobi_buffer_dup32(&m->mh->fcis_index, buf);\n    mobi_buffer_dup32(&m->mh->fcis_count, buf);\n    mobi_buffer_dup32(&m->mh->flis_index, buf);\n    mobi_buffer_dup32(&m->mh->flis_count, buf);\n    mobi_buffer_dup32(&m->mh->unknown10, buf);\n    mobi_buffer_dup32(&m->mh->unknown11, buf);\n    mobi_buffer_dup32(&m->mh->srcs_index, buf);\n    mobi_buffer_dup32(&m->mh->srcs_count, buf);\n    mobi_buffer_dup32(&m->mh->unknown12, buf);\n    mobi_buffer_dup32(&m->mh->unknown13, buf);\n    mobi_buffer_seek(buf, 2); /* 2 byte fill */\n    mobi_buffer_dup16(&m->mh->extra_flags, buf);\n    mobi_buffer_dup32(&m->mh->ncx_index, buf);\n    if (isKF8) {\n        mobi_buffer_dup32(&m->mh->fragment_index, buf);\n        mobi_buffer_dup32(&m->mh->skeleton_index, buf);\n    } else {\n        mobi_buffer_dup32(&m->mh->unknown14, buf);\n        mobi_buffer_dup32(&m->mh->unknown15, buf);\n    }\n    mobi_buffer_dup32(&m->mh->datp_index, buf);\n    if (isKF8) {\n        mobi_buffer_dup32(&m->mh->guide_index, buf);\n    } else {\n        mobi_buffer_dup32(&m->mh->unknown16, buf);\n    }\n    mobi_buffer_dup32(&m->mh->unknown17, buf);\n    mobi_buffer_dup32(&m->mh->unknown18, buf);\n    mobi_buffer_dup32(&m->mh->unknown19, buf);\n    mobi_buffer_dup32(&m->mh->unknown20, buf);\n    if (buf->maxlen > buf->offset) {\n        debug_print(\"Skipping %zu unknown bytes in MOBI header\\n\", (buf->maxlen - buf->offset));\n        mobi_buffer_setpos(buf, buf->maxlen);\n    }\n    buf->maxlen = saved_maxlen;\n    /* get full name stored at m->mh->full_name_offset */\n    if (m->mh->full_name_offset && m->mh->full_name_length) {\n        const size_t saved_offset = buf->offset;\n        const uint32_t full_name_length = min(*m->mh->full_name_length, MOBI_TITLE_SIZEMAX);\n        mobi_buffer_setpos(buf, *m->mh->full_name_offset);\n        m->mh->full_name = malloc(full_name_length + 1);\n        if (m->mh->full_name == NULL) {\n            debug_print(\"%s\", \"Memory allocation for full name failed\\n\");\n            return MOBI_MALLOC_FAILED;\n        }\n        if (full_name_length) {\n            mobi_buffer_getstring(m->mh->full_name, buf, full_name_length);\n        } else {\n            m->mh->full_name[0] = '\\0';\n        }\n        mobi_buffer_setpos(buf, saved_offset);\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse Record 0 into MOBIData structure\n \n This function will parse MOBIRecord0Header, MOBIMobiHeader and MOBIExthHeader\n \n @param[in,out] m MOBIData structure to be filled with parsed data\n @param[in] seqnumber Sequential number of the palm database record\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_record0(MOBIData *m, const size_t seqnumber) {\n    MOBI_RET ret;\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    const MOBIPdbRecord *record0 = mobi_get_record_by_seqnumber(m, seqnumber);\n    if (record0 == NULL) {\n        debug_print(\"%s\", \"Record 0 not loaded\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    if (record0->size < RECORD0_HEADER_LEN) {\n        debug_print(\"%s\", \"Record 0 too short\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    MOBIBuffer *buf = mobi_buffer_init_null(record0->data, record0->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    m->rh = calloc(1, sizeof(MOBIRecord0Header));\n    if (m->rh == NULL) {\n        debug_print(\"%s\", \"Memory allocation for record 0 header failed\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_MALLOC_FAILED;\n    }\n    /* parse palmdoc header */\n    const uint16_t compression = mobi_buffer_get16(buf);\n    mobi_buffer_seek(buf, 2); // unused 2 bytes, zeroes\n    if ((compression != RECORD0_NO_COMPRESSION &&\n         compression != RECORD0_PALMDOC_COMPRESSION &&\n         compression != RECORD0_HUFF_COMPRESSION)) {\n        debug_print(\"Wrong record0 header: %c%c%c%c\\n\", record0->data[0], record0->data[1], record0->data[2], record0->data[3]);\n        mobi_buffer_free_null(buf);\n        free(m->rh);\n        m->rh = NULL;\n        return MOBI_DATA_CORRUPT;\n    }\n    m->rh->compression_type = compression;\n    m->rh->text_length = mobi_buffer_get32(buf);\n    m->rh->text_record_count = mobi_buffer_get16(buf);\n    m->rh->text_record_size = mobi_buffer_get16(buf);\n    m->rh->encryption_type = mobi_buffer_get16(buf);\n    m->rh->unknown1 = mobi_buffer_get16(buf);\n    if (mobi_is_mobipocket(m)) {\n        /* parse mobi header if present  */\n        ret = mobi_parse_mobiheader(m, buf);\n        if (ret == MOBI_SUCCESS) {\n            /* parse exth header if present */\n            mobi_parse_extheader(m, buf);\n        }\n    } \n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Calculate the size of extra bytes at the end of text record\n \n @param[in] record MOBIPdbRecord structure containing the record\n @param[in] flags Flags from MOBI header (extra_flags)\n @return The size of trailing bytes, MOBI_NOTSET on failure\n */\nsize_t mobi_get_record_extrasize(const MOBIPdbRecord *record, const uint16_t flags) {\n    size_t extra_size = 0;\n    MOBIBuffer *buf = mobi_buffer_init_null(record->data, record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\", \"Buffer init in extrasize failed\\n\");\n        return MOBI_NOTSET;\n    }\n    /* set pointer at the end of the record data */\n    mobi_buffer_setpos(buf, buf->maxlen - 1);\n    for (int bit = 15; bit > 0; bit--) {\n        if (flags & (1 << bit)) {\n            /* bit is set */\n            size_t len = 0;\n            /* size contains varlen itself and optional data */\n            const uint32_t size = mobi_buffer_get_varlen_dec(buf, &len);\n            /* skip data */\n            /* TODO: read and store in record struct */\n            mobi_buffer_seek(buf, - (int)(size - len));\n            extra_size += size;\n        }\n    };\n    /* check bit 0 */\n    if (flags & 1) {\n            const uint8_t b = mobi_buffer_get8(buf);\n            /* two first bits hold size */\n            extra_size += (b & 0x3) + 1;\n    }\n    mobi_buffer_free_null(buf);\n    return extra_size;\n}\n\n/**\n @brief Calculate the size of extra multibyte section at the end of text record\n \n @param[in] record MOBIPdbRecord structure containing the record\n @param[in] flags Flags from MOBI header (extra_flags)\n @return The size of trailing bytes, MOBI_NOTSET on failure\n */\nsize_t mobi_get_record_mb_extrasize(const MOBIPdbRecord *record, const uint16_t flags) {\n    size_t extra_size = 0;\n    if (flags & 1) {\n        MOBIBuffer *buf = mobi_buffer_init_null(record->data, record->size);\n        if (buf == NULL) {\n            debug_print(\"%s\", \"Buffer init in extrasize failed\\n\");\n            return MOBI_NOTSET;\n        }\n        /* set pointer at the end of the record data */\n        mobi_buffer_setpos(buf, buf->maxlen - 1);\n        for (int bit = 15; bit > 0; bit--) {\n            if (flags & (1 << bit)) {\n                /* bit is set */\n                size_t len = 0;\n                /* size contains varlen itself and optional data */\n                const uint32_t size = mobi_buffer_get_varlen_dec(buf, &len);\n                /* skip data */\n                /* TODO: read and store in record struct */\n                mobi_buffer_seek(buf, - (int)(size - len));\n            }\n        };\n        /* read multibyte section */\n        const uint8_t b = mobi_buffer_get8(buf);\n        /* two first bits hold size */\n        extra_size += (b & 0x3) + 1;\n        mobi_buffer_free_null(buf);\n    }\n    return extra_size;\n}\n\n/**\n @brief Parse HUFF record into MOBIHuffCdic structure\n \n @param[in,out] huffcdic MOBIHuffCdic structure to be filled with parsed data\n @param[in] record MOBIPdbRecord structure containing the record\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_huff(MOBIHuffCdic *huffcdic, const MOBIPdbRecord *record) {\n    MOBIBuffer *buf = mobi_buffer_init_null(record->data, record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    char huff_magic[5];\n    mobi_buffer_getstring(huff_magic, buf, 4);\n    const size_t header_length = mobi_buffer_get32(buf);\n    if (strncmp(huff_magic, HUFF_MAGIC, 4) != 0 || header_length < HUFF_HEADER_LEN) {\n        debug_print(\"HUFF wrong magic: %s\\n\", huff_magic);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t data1_offset = mobi_buffer_get32(buf);\n    const size_t data2_offset = mobi_buffer_get32(buf);\n    /* skip little-endian table offsets */\n    mobi_buffer_setpos(buf, data1_offset);\n    if (buf->offset + (256 * 4) > buf->maxlen) {\n        debug_print(\"%s\", \"HUFF data1 too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* read 256 indices from data1 big-endian */\n    for (int i = 0; i < 256; i++) {\n        huffcdic->table1[i] = mobi_buffer_get32(buf);\n    }\n    mobi_buffer_setpos(buf, data2_offset);\n    if (buf->offset + (64 * 4) > buf->maxlen) {\n        debug_print(\"%s\", \"HUFF data2 too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* read 32 mincode-maxcode pairs from data2 big-endian */\n    huffcdic->mincode_table[0] = 0;\n    huffcdic->maxcode_table[0] = 0xFFFFFFFF;\n    for (int i = 1; i < 33; i++) {\n        const uint32_t mincode = mobi_buffer_get32(buf);\n        const uint32_t maxcode = mobi_buffer_get32(buf);\n        huffcdic->mincode_table[i] =  mincode << (32 - i);\n        huffcdic->maxcode_table[i] =  ((maxcode + 1) << (32 - i)) - 1;\n    }\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse CDIC record into MOBIHuffCdic structure\n \n @param[in,out] huffcdic MOBIHuffCdic structure to be filled with parsed data\n @param[in] record MOBIPdbRecord structure containing the record\n @param[in] num Number of CDIC record in a set, starting from zero\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_cdic(MOBIHuffCdic *huffcdic, const MOBIPdbRecord *record, const size_t num) {\n    MOBIBuffer *buf = mobi_buffer_init_null(record->data, record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    char cdic_magic[5];\n    mobi_buffer_getstring(cdic_magic, buf, 4);\n    const size_t header_length = mobi_buffer_get32(buf);\n    if (strncmp(cdic_magic, CDIC_MAGIC, 4) != 0 || header_length < CDIC_HEADER_LEN) {\n        debug_print(\"CDIC wrong magic: %s or declared header length: %zu\\n\", cdic_magic, header_length);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* variables in huffcdic initialized to zero with calloc */\n    /* save initial count and length */\n    size_t index_count = mobi_buffer_get32(buf);\n    const size_t code_length = mobi_buffer_get32(buf);\n    if (huffcdic->code_length && huffcdic->code_length != code_length) {\n        debug_print(\"CDIC different code length %zu in record %i, previous was %zu\\n\", huffcdic->code_length, record->uid, code_length);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    if (huffcdic->index_count && huffcdic->index_count != index_count) {\n        debug_print(\"CDIC different index count %zu in record %i, previous was %zu\\n\", huffcdic->index_count, record->uid, index_count);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    if (code_length == 0 || code_length > HUFF_CODELEN_MAX) {\n        debug_print(\"Code length exceeds sanity checks (%zu)\\n\", code_length);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    huffcdic->code_length = code_length;\n    huffcdic->index_count = index_count;\n    if (index_count == 0) {\n        debug_print(\"%s\", \"CDIC index count is null\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* allocate memory for symbol offsets if not already allocated */\n    if (num == 0) {\n        if (index_count > (1 << HUFF_CODELEN_MAX) * CDIC_RECORD_MAXCNT) {\n            debug_print(\"CDIC index count too large %zu\\n\", index_count);\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        huffcdic->symbol_offsets = malloc(index_count * sizeof(*huffcdic->symbol_offsets));\n        if (huffcdic->symbol_offsets == NULL) {\n            debug_print(\"%s\", \"CDIC cannot allocate memory\");\n            mobi_buffer_free_null(buf);\n            return MOBI_MALLOC_FAILED;\n        }\n    }\n    index_count -= huffcdic->index_read;\n    /* limit number of records read to code_length bits */\n    if (index_count >> code_length) {\n        index_count = (1 << code_length);\n    }\n    if (buf->offset + (index_count * 2) > buf->maxlen) {\n        debug_print(\"%s\", \"CDIC indices data too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* read i * 2 byte big-endian indices */\n    while (index_count--) {\n        const uint16_t offset = mobi_buffer_get16(buf);\n        const size_t saved_pos = buf->offset;\n        mobi_buffer_setpos(buf, offset + CDIC_HEADER_LEN);\n        const size_t len = mobi_buffer_get16(buf) & 0x7fff;\n        if (buf->error != MOBI_SUCCESS || buf->offset + len > buf->maxlen) {\n            debug_print(\"%s\", \"CDIC offset beyond buffer\\n\");\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        mobi_buffer_setpos(buf, saved_pos);\n        huffcdic->symbol_offsets[huffcdic->index_read++] = offset;\n    }\n    if (buf->offset + code_length > buf->maxlen) {\n        debug_print(\"%s\", \"CDIC dictionary data too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* copy pointer to data */\n    huffcdic->symbols[num] = record->data + CDIC_HEADER_LEN;\n    /* free buffer */\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse a set of HUFF and CDIC records into MOBIHuffCdic structure\n \n @param[in] m MOBIData structure with loaded MOBI document\n @param[in,out] huffcdic MOBIHuffCdic structure to be filled with parsed data\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_huffdic(const MOBIData *m, MOBIHuffCdic *huffcdic) {\n    MOBI_RET ret;\n    const size_t offset = mobi_get_kf8offset(m);\n    if (m->mh == NULL || m->mh->huff_rec_index == NULL || m->mh->huff_rec_count == NULL) {\n        debug_print(\"%s\", \"HUFF/CDIC records metadata not found in MOBI header\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t huff_rec_index = *m->mh->huff_rec_index + offset;\n    const size_t huff_rec_count = *m->mh->huff_rec_count;\n    if (huff_rec_count > HUFF_RECORD_MAXCNT) {\n        debug_print(\"Too many HUFF record (%zu)\\n\", huff_rec_count);\n        return MOBI_DATA_CORRUPT;\n    }\n    const MOBIPdbRecord *curr = mobi_get_record_by_seqnumber(m, huff_rec_index);\n    if (curr == NULL || huff_rec_count < 2) {\n        debug_print(\"%s\", \"HUFF/CDIC record not found\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    if (curr->size < HUFF_RECORD_MINSIZE) {\n        debug_print(\"HUFF record too short (%zu b)\\n\", curr->size);\n        return MOBI_DATA_CORRUPT;\n    }\n    ret = mobi_parse_huff(huffcdic, curr);\n    if (ret != MOBI_SUCCESS) {\n        debug_print(\"%s\", \"HUFF parsing failed\\n\");\n        return ret;\n    }\n    curr = curr->next;\n    /* allocate memory for symbols data in each CDIC record */\n    huffcdic->symbols = malloc((huff_rec_count - 1) * sizeof(*huffcdic->symbols));\n    if (huffcdic->symbols == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    /* get following CDIC records */\n    size_t i = 0;\n    while (i < huff_rec_count - 1) {\n        if (curr == NULL) {\n            debug_print(\"%s\\n\", \"CDIC record not found\");\n            return MOBI_DATA_CORRUPT;\n        }\n        ret = mobi_parse_cdic(huffcdic, curr, i++);\n        if (ret != MOBI_SUCCESS) {\n            debug_print(\"%s\", \"CDIC parsing failed\\n\");\n            return ret;\n        }\n        curr = curr->next;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse FDST record into MOBIRawml structure (MOBIFdst member)\n \n @param[in] m MOBIData structure with loaded MOBI document\n @param[in,out] rawml MOBIRawml structure to be filled with parsed data\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_fdst(const MOBIData *m, MOBIRawml *rawml) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    const size_t fdst_record_number = mobi_get_fdst_record_number(m);\n    if (fdst_record_number == MOBI_NOTSET) {\n        return MOBI_DATA_CORRUPT;\n    }\n    const MOBIPdbRecord *fdst_record = mobi_get_record_by_seqnumber(m, fdst_record_number);\n    if (fdst_record == NULL) {\n        return MOBI_DATA_CORRUPT;\n    }\n    MOBIBuffer *buf = mobi_buffer_init_null(fdst_record->data, fdst_record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    char fdst_magic[5];\n    mobi_buffer_getstring(fdst_magic, buf, 4);\n    const size_t data_offset = mobi_buffer_get32(buf);\n    const size_t section_count = mobi_buffer_get32(buf);\n    if (strncmp(fdst_magic, FDST_MAGIC, 4) != 0 ||\n        section_count <= 1 ||\n        section_count != *m->mh->fdst_section_count ||\n        data_offset != 12) {\n        debug_print(\"FDST wrong magic: %s, sections count: %zu or data offset: %zu\\n\", fdst_magic, section_count, data_offset);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    if ((buf->maxlen - buf->offset) < section_count * 8) {\n        debug_print(\"%s\", \"Record FDST too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    rawml->fdst = malloc(sizeof(MOBIFdst));\n    if (rawml->fdst == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        mobi_buffer_free_null(buf);\n        return MOBI_MALLOC_FAILED;\n    }\n    rawml->fdst->fdst_section_count = section_count;\n    rawml->fdst->fdst_section_starts = malloc(sizeof(*rawml->fdst->fdst_section_starts) * section_count);\n    if (rawml->fdst->fdst_section_starts == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        mobi_buffer_free_null(buf);\n        free(rawml->fdst);\n        rawml->fdst = NULL;\n        return MOBI_MALLOC_FAILED;\n    }\n    rawml->fdst->fdst_section_ends = malloc(sizeof(*rawml->fdst->fdst_section_ends) * section_count);\n    if (rawml->fdst->fdst_section_ends == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        mobi_buffer_free_null(buf);\n        free(rawml->fdst->fdst_section_starts);\n        free(rawml->fdst);\n        rawml->fdst = NULL;\n        return MOBI_MALLOC_FAILED;\n    }\n    size_t i = 0;\n    while (i < section_count) {\n        rawml->fdst->fdst_section_starts[i] = mobi_buffer_get32(buf);\n        rawml->fdst->fdst_section_ends[i] = mobi_buffer_get32(buf);\n        debug_print(\"FDST[%zu]:\\t%i\\t%i\\n\", i, rawml->fdst->fdst_section_starts[i], rawml->fdst->fdst_section_ends[i]);\n        i++;\n    }\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Read MOBI document from file into MOBIData structure\n \n @param[in,out] m MOBIData structure to be filled with read data\n @param[in] file File descriptor to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_load_file(MOBIData *m, FILE *file) {\n    MOBI_RET ret;\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    ret = mobi_load_pdbheader(m, file);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    if (strcmp(m->ph->type, \"BOOK\") != 0 && strcmp(m->ph->type, \"TEXt\") != 0) {\n        debug_print(\"Unsupported file type: %s\\n\", m->ph->type);\n        return MOBI_FILE_UNSUPPORTED;\n    }\n    if (m->ph->rec_count == 0) {\n        debug_print(\"%s\", \"No records found\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    ret = mobi_load_reclist(m, file);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    ret = mobi_load_rec(m, file);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    ret = mobi_parse_record0(m, 0);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    if (m->rh && m->rh->encryption_type == RECORD0_OLD_ENCRYPTION) {\n        /* try to set key for encryption type 1 */\n        debug_print(\"Trying to set key for encryption type 1%s\", \"\\n\")\n        mobi_drm_setkey(m, NULL);\n    }\n    /* if EXTH is loaded parse KF8 record0 for hybrid KF7/KF8 file */\n    if (m->eh) {\n        const size_t boundary_rec_number = mobi_get_kf8boundary_seqnumber(m);\n        if (boundary_rec_number != MOBI_NOTSET && boundary_rec_number < UINT32_MAX) {\n            /* it is a hybrid KF7/KF8 file */\n            m->kf8_boundary_offset = (uint32_t) boundary_rec_number;\n            m->next = mobi_init();\n            /* link pdb header and records data to KF8data structure */\n            m->next->ph = m->ph;\n            m->next->rec = m->rec;\n            m->next->drm_key = m->drm_key;\n            /* close next loop */\n            m->next->next = m;\n            ret = mobi_parse_record0(m->next, boundary_rec_number + 1);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n            /* swap to kf8 part if use_kf8 flag is set */\n            if (m->use_kf8) {\n                mobi_swap_mobidata(m);\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Read MOBI document from a path into MOBIData structure\n \n @param[in,out] m MOBIData structure to be filled with read data\n @param[in] path Path to a MOBI document on disk (eg. /home/me/test.mobi)\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_load_filename(MOBIData *m, const char *path) {\n    FILE *file = fopen(path, \"rb\");\n    if (file == NULL) {\n        debug_print(\"%s\", \"File not found\\n\");\n        return MOBI_FILE_NOT_FOUND;\n    }\n    const MOBI_RET ret = mobi_load_file(m, file);\n    fclose(file);\n    return ret;\n}\n"], "fixing_code": ["/** @file compression.c\n *  @brief Functions handling compression\n *\n * Copyright (c) 2014 Bartek Fabiszewski\n * http://www.fabiszewski.net\n *\n * This file is part of libmobi.\n * Licensed under LGPL, either version 3, or any later.\n * See <http://www.gnu.org/licenses/>\n */\n\n#include <string.h>\n#include \"compression.h\"\n#include \"buffer.h\"\n#include \"mobi.h\"\n#include \"debug.h\"\n\n\n/** \n @brief Decompressor fo PalmDOC version of LZ77 compression\n\n Decompressor based on this algorithm:\n http://en.wikibooks.org/wiki/Data_Compression/Dictionary_compression#PalmDoc\n\n @param[out] out Decompressed destination data\n @param[in] in Compressed source data\n @param[in,out] len_out Size of the memory reserved for decompressed data.\n On return it is set to actual size of decompressed data\n @param[in] len_in Size of compressed data\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_decompress_lz77(unsigned char *out, const unsigned char *in, size_t *len_out, const size_t len_in) {\n    MOBI_RET ret = MOBI_SUCCESS;\n    MOBIBuffer *buf_in = mobi_buffer_init_null((unsigned char *) in, len_in);\n    if (buf_in == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    MOBIBuffer *buf_out = mobi_buffer_init_null(out, *len_out);\n    if (buf_out == NULL) {\n        mobi_buffer_free_null(buf_in);\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    while (ret == MOBI_SUCCESS && buf_in->offset < buf_in->maxlen) {\n        uint8_t byte = mobi_buffer_get8(buf_in);\n        /* byte pair: space + char */\n        if (byte >= 0xc0) {\n            mobi_buffer_add8(buf_out, ' ');\n            mobi_buffer_add8(buf_out, byte ^ 0x80);\n        }\n        /* length, distance pair */\n        /* 0x8000 + (distance << 3) + ((length-3) & 0x07) */\n        else if (byte >= 0x80) {\n            uint8_t next = mobi_buffer_get8(buf_in);\n            uint16_t distance = ((((byte << 8) | ((uint8_t)next)) >> 3) & 0x7ff);\n            uint8_t length = (next & 0x7) + 3;\n            while (length--) {\n                mobi_buffer_move(buf_out, -distance, 1);\n            }\n        }\n        /* single char, not modified */\n        else if (byte >= 0x09) {\n            mobi_buffer_add8(buf_out, byte);\n        }\n        /* val chars not modified */\n        else if (byte >= 0x01) {\n            mobi_buffer_copy(buf_out, buf_in, byte);\n        }\n        /* char '\\0', not modified */\n        else {\n            mobi_buffer_add8(buf_out, byte);\n        }\n        if (buf_in->error || buf_out->error) {\n            ret = MOBI_BUFFER_END;\n        }\n    }\n    *len_out = buf_out->offset;\n    mobi_buffer_free_null(buf_out);\n    mobi_buffer_free_null(buf_in);\n    return ret;\n}\n\n/**\n @brief Read at most 8 bytes from buffer, big-endian\n \n If buffer data is shorter returned value is padded with zeroes\n \n @param[in] buf MOBIBuffer structure to read from\n @return 64-bit value\n */\nstatic MOBI_INLINE uint64_t mobi_buffer_fill64(MOBIBuffer *buf) {\n    uint64_t val = 0;\n    uint8_t i = 8;\n    size_t bytesleft = buf->maxlen - buf->offset;\n    unsigned char *ptr = buf->data + buf->offset;\n    while (i-- && bytesleft--) {\n        val |= (uint64_t) *ptr++ << (i * 8);\n    }\n    /* increase counter by 4 bytes only, 4 bytes overlap on each call */\n    buf->offset += 4;\n    return val;\n}\n\n/**\n @brief Internal function for huff/cdic decompression\n \n Decompressor and HUFF/CDIC records parsing based on:\n perl EBook::Tools::Mobipocket\n python mobiunpack.py, calibre\n \n @param[out] buf_out MOBIBuffer structure with decompressed data\n @param[in] buf_in MOBIBuffer structure with compressed data\n @param[in] huffcdic MOBIHuffCdic structure with parsed data from huff/cdic records\n @param[in] depth Depth of current recursion level\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nstatic MOBI_RET mobi_decompress_huffman_internal(MOBIBuffer *buf_out, MOBIBuffer *buf_in, const MOBIHuffCdic *huffcdic, size_t depth) {\n    if (depth > MOBI_HUFFMAN_MAXDEPTH) {\n        debug_print(\"Too many levels of recursion: %zu\\n\", depth);\n        return MOBI_DATA_CORRUPT;\n    }\n    MOBI_RET ret = MOBI_SUCCESS;\n    int8_t bitcount = 32;\n    /* this cast should be safe: max record size is 4096 */\n    int bitsleft = (int) (buf_in->maxlen * 8);\n    uint8_t code_length = 0;\n    uint64_t buffer = mobi_buffer_fill64(buf_in);\n    while (ret == MOBI_SUCCESS) {\n        if (bitcount <= 0) {\n            bitcount += 32;\n            buffer = mobi_buffer_fill64(buf_in);\n        }\n        uint32_t code = (buffer >> bitcount) & 0xffffffffU;\n        /* lookup code in table1 */\n        uint32_t t1 = huffcdic->table1[code >> 24];\n        /* get maxcode and codelen from t1 */\n        code_length = t1 & 0x1f;\n        uint32_t maxcode = (((t1 >> 8) + 1) << (32 - code_length)) - 1;\n        /* check termination bit */\n        if (!(t1 & 0x80)) {\n            /* get offset from mincode, maxcode tables */\n            while (code < huffcdic->mincode_table[code_length]) {\n                if (++code_length >= HUFF_CODETABLE_SIZE) {\n                    debug_print(\"Wrong offset to mincode table: %hhu\\n\", code_length);\n                    return MOBI_DATA_CORRUPT;\n                }\n            }\n            maxcode = huffcdic->maxcode_table[code_length];\n        }\n        bitcount -= code_length;\n        bitsleft -= code_length;\n        if (bitsleft < 0) {\n            break;\n        }\n        /* get index for symbol offset */\n        uint32_t index = (uint32_t) (maxcode - code) >> (32 - code_length);\n        /* check which part of cdic to use */\n        uint16_t cdic_index = (uint16_t) ((uint32_t)index >> huffcdic->code_length);\n        if (index >= huffcdic->index_count) {\n            debug_print(\"Wrong symbol offsets index: %u\\n\", index);\n            return MOBI_DATA_CORRUPT;\n        }\n        /* get offset */\n        uint32_t offset = huffcdic->symbol_offsets[index];\n        uint32_t symbol_length = (uint32_t) huffcdic->symbols[cdic_index][offset] << 8 | (uint32_t) huffcdic->symbols[cdic_index][offset + 1];\n        /* 1st bit is is_decompressed flag */\n        int is_decompressed = symbol_length >> 15;\n        /* get rid of flag */\n        symbol_length &= 0x7fff;\n        if (is_decompressed) {\n            /* symbol is at (offset + 2), 2 bytes used earlier for symbol length */\n            mobi_buffer_addraw(buf_out, (huffcdic->symbols[cdic_index] + offset + 2), symbol_length);\n            ret = buf_out->error;\n        } else {\n            /* symbol is compressed */\n            /* TODO cache uncompressed symbols? */\n            MOBIBuffer buf_sym;\n            buf_sym.data = huffcdic->symbols[cdic_index] + offset + 2;\n            buf_sym.offset = 0;\n            buf_sym.maxlen = symbol_length;\n            buf_sym.error = MOBI_SUCCESS;\n            ret = mobi_decompress_huffman_internal(buf_out, &buf_sym, huffcdic, depth + 1);\n        }\n    }\n    return ret;\n}\n\n/**\n @brief Decompressor for huff/cdic compressed text records\n \n Decompressor and HUFF/CDIC records parsing based on:\n perl EBook::Tools::Mobipocket\n python mobiunpack.py, calibre\n \n @param[out] out Decompressed destination data\n @param[in] in Compressed source data\n @param[in,out] len_out Size of the memory reserved for decompressed data.\n On return it is set to actual size of decompressed data\n @param[in] len_in Size of compressed data\n @param[in] huffcdic MOBIHuffCdic structure with parsed data from huff/cdic records\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_decompress_huffman(unsigned char *out, const unsigned char *in, size_t *len_out, size_t len_in, const MOBIHuffCdic *huffcdic) {\n    MOBIBuffer *buf_in = mobi_buffer_init_null((unsigned char *) in, len_in);\n    if (buf_in == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    MOBIBuffer *buf_out = mobi_buffer_init_null(out, *len_out);\n    if (buf_out == NULL) {\n        mobi_buffer_free_null(buf_in);\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    MOBI_RET ret = mobi_decompress_huffman_internal(buf_out, buf_in, huffcdic, 0);\n    *len_out = buf_out->offset;\n    mobi_buffer_free_null(buf_out);\n    mobi_buffer_free_null(buf_in);\n    return ret;\n}\n", "/** @file compression.h\n *\n * Copyright (c) 2014 Bartek Fabiszewski\n * http://www.fabiszewski.net\n *\n * This file is part of libmobi.\n * Licensed under LGPL, either version 3, or any later.\n * See <http://www.gnu.org/licenses/>\n */\n\n#ifndef libmobi_compression_h\n#define libmobi_compression_h\n\n#include \"config.h\"\n#include \"mobi.h\"\n\n#ifndef MOBI_INLINE\n#define MOBI_INLINE /**< Syntax for compiler inline keyword from config.h */\n#endif\n\n/* FIXME: what is the reasonable value? */\n#define MOBI_HUFFMAN_MAXDEPTH 20 /**< Maximal recursion level for huffman decompression routine */\n#define HUFF_CODETABLE_SIZE 33 /**< Size of min- and maxcode tables */\n\n\n/**\n @brief Parsed data from HUFF and CDIC records needed to unpack huffman compressed text\n */\ntypedef struct {\n    size_t index_count; /**< Total number of indices in all CDIC records, stored in each CDIC record header */\n    size_t index_read; /**< Number of indices parsed, used by parser */\n    size_t code_length; /**< Code length value stored in CDIC record header */\n    uint32_t table1[256]; /**< Table of big-endian indices from HUFF record data1 */\n    uint32_t mincode_table[HUFF_CODETABLE_SIZE]; /**< Table of big-endian mincodes from HUFF record data2 */\n    uint32_t maxcode_table[HUFF_CODETABLE_SIZE]; /**< Table of big-endian maxcodes from HUFF record data2 */\n    uint16_t *symbol_offsets; /**< Index of symbol offsets parsed from CDIC records (index_count entries) */\n    unsigned char **symbols; /**< Array of pointers to start of symbols data in each CDIC record (index = number of CDIC record) */\n} MOBIHuffCdic;\n\nMOBI_RET mobi_decompress_lz77(unsigned char *out, const unsigned char *in, size_t *len_out, const size_t len_in);\nMOBI_RET mobi_decompress_huffman(unsigned char *out, const unsigned char *in, size_t *len_out, size_t len_in, const MOBIHuffCdic *huffcdic);\n\n#endif\n", "/** @file read.c\n *  @brief Functions for reading and parsing of MOBI document\n *\n * Copyright (c) 2014 Bartek Fabiszewski\n * http://www.fabiszewski.net\n *\n * This file is part of libmobi.\n * Licensed under LGPL, either version 3, or any later.\n * See <http://www.gnu.org/licenses/>\n */\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include \"read.h\"\n#include \"util.h\"\n#include \"index.h\"\n#include \"debug.h\"\n\n/**\n @brief Read palm database header from file into MOBIData structure (MOBIPdbHeader)\n \n @param[in,out] m MOBIData structure to be filled with read data\n @param[in] file Filedescriptor to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_load_pdbheader(MOBIData *m, FILE *file) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    if (!file) {\n        return MOBI_FILE_NOT_FOUND;\n    }\n    MOBIBuffer *buf = mobi_buffer_init(PALMDB_HEADER_LEN);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    const size_t len = fread(buf->data, 1, PALMDB_HEADER_LEN, file);\n    if (len != PALMDB_HEADER_LEN) {\n        mobi_buffer_free(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    m->ph = calloc(1, sizeof(MOBIPdbHeader));\n    if (m->ph == NULL) {\n        debug_print(\"%s\", \"Memory allocation for pdb header failed\\n\");\n        mobi_buffer_free(buf);\n        return MOBI_MALLOC_FAILED;\n    }\n    /* parse header */\n    mobi_buffer_getstring(m->ph->name, buf, PALMDB_NAME_SIZE_MAX);\n    m->ph->attributes = mobi_buffer_get16(buf);\n    m->ph->version = mobi_buffer_get16(buf);\n    m->ph->ctime = mobi_buffer_get32(buf);\n    m->ph->mtime = mobi_buffer_get32(buf);\n    m->ph->btime = mobi_buffer_get32(buf);\n    m->ph->mod_num = mobi_buffer_get32(buf);\n    m->ph->appinfo_offset = mobi_buffer_get32(buf);\n    m->ph->sortinfo_offset = mobi_buffer_get32(buf);\n    mobi_buffer_getstring(m->ph->type, buf, 4);\n    mobi_buffer_getstring(m->ph->creator, buf, 4);\n    m->ph->uid = mobi_buffer_get32(buf);\n    m->ph->next_rec = mobi_buffer_get32(buf);\n    m->ph->rec_count = mobi_buffer_get16(buf);\n    mobi_buffer_free(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Read list of database records from file into MOBIData structure (MOBIPdbRecord)\n \n @param[in,out] m MOBIData structure to be filled with read data\n @param[in] file Filedescriptor to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_load_reclist(MOBIData *m, FILE *file) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    if (!file) {\n        debug_print(\"%s\", \"File not ready\\n\");\n        return MOBI_FILE_NOT_FOUND;\n    }\n    m->rec = calloc(1, sizeof(MOBIPdbRecord));\n    if (m->rec == NULL) {\n        debug_print(\"%s\", \"Memory allocation for pdb record failed\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    MOBIPdbRecord *curr = m->rec;\n    for (int i = 0; i < m->ph->rec_count; i++) {\n        MOBIBuffer *buf = mobi_buffer_init(PALMDB_RECORD_INFO_SIZE);\n        if (buf == NULL) {\n            debug_print(\"%s\\n\", \"Memory allocation failed\");\n            return MOBI_MALLOC_FAILED;\n        }\n        const size_t len = fread(buf->data, 1, PALMDB_RECORD_INFO_SIZE, file);\n        if (len != PALMDB_RECORD_INFO_SIZE) {\n            mobi_buffer_free(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        if (i > 0) {\n            curr->next = calloc(1, sizeof(MOBIPdbRecord));\n            if (curr->next == NULL) {\n                debug_print(\"%s\", \"Memory allocation for pdb record failed\\n\");\n                mobi_buffer_free(buf);\n                return MOBI_MALLOC_FAILED;\n            }\n            curr = curr->next;\n        }\n        curr->offset = mobi_buffer_get32(buf);\n        curr->attributes = mobi_buffer_get8(buf);\n        const uint8_t h = mobi_buffer_get8(buf);\n        const uint16_t l = mobi_buffer_get16(buf);\n        curr->uid =  (uint32_t) h << 16 | l;\n        curr->next = NULL;\n        mobi_buffer_free(buf);\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Read record data and size from file into MOBIData structure (MOBIPdbRecord)\n \n @param[in,out] m MOBIData structure to be filled with read data\n @param[in] file Filedescriptor to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_load_rec(MOBIData *m, FILE *file) {\n    MOBI_RET ret;\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    MOBIPdbRecord *curr = m->rec;\n    while (curr != NULL) {\n        MOBIPdbRecord *next;\n        size_t size;\n        if (curr->next != NULL) {\n            next = curr->next;\n            size = next->offset - curr->offset;\n        } else {\n            fseek(file, 0, SEEK_END);\n            long diff = ftell(file) - curr->offset;\n            if (diff <= 0) {\n                debug_print(\"Wrong record size: %li\\n\", diff);\n                return MOBI_DATA_CORRUPT;\n            }\n            size = (size_t) diff;\n            next = NULL;\n        }\n\n        curr->size = size;\n        ret = mobi_load_recdata(curr, file);\n        if (ret  != MOBI_SUCCESS) {\n            debug_print(\"Error loading record uid %i data\\n\", curr->uid);\n            mobi_free_rec(m);\n            return ret;\n        }\n        curr = next;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Read record data from file into MOBIPdbRecord structure\n \n @param[in,out] rec MOBIPdbRecord structure to be filled with read data\n @param[in] file Filedescriptor to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_load_recdata(MOBIPdbRecord *rec, FILE *file) {\n    const int ret = fseek(file, rec->offset, SEEK_SET);\n    if (ret != 0) {\n        debug_print(\"Record %i not found\\n\", rec->uid);\n        return MOBI_DATA_CORRUPT;\n    }\n    rec->data = malloc(rec->size);\n    if (rec->data == NULL) {\n        debug_print(\"%s\", \"Memory allocation for pdb record data failed\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    const size_t len = fread(rec->data, 1, rec->size, file);\n    if (len < rec->size) {\n        debug_print(\"Truncated data in record %i\\n\", rec->uid);\n        return MOBI_DATA_CORRUPT;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse EXTH header from Record 0 into MOBIData structure (MOBIExthHeader)\n \n @param[in,out] m MOBIData structure to be filled with parsed data\n @param[in] buf MOBIBuffer buffer to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_extheader(MOBIData *m, MOBIBuffer *buf) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    char exth_magic[5];\n    const size_t header_length = 12;\n    mobi_buffer_getstring(exth_magic, buf, 4);\n    const size_t exth_length = mobi_buffer_get32(buf) - header_length;\n    const size_t rec_count = mobi_buffer_get32(buf);\n    if (strncmp(exth_magic, EXTH_MAGIC, 4) != 0 ||\n        exth_length + buf->offset > buf->maxlen ||\n        rec_count == 0 || rec_count > MOBI_EXTH_MAXCNT) {\n        debug_print(\"%s\", \"Sanity checks for EXTH header failed\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t saved_maxlen = buf->maxlen;\n    buf->maxlen = exth_length + buf->offset;\n    m->eh = calloc(1, sizeof(MOBIExthHeader));\n    if (m->eh == NULL) {\n        debug_print(\"%s\", \"Memory allocation for EXTH header failed\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    MOBIExthHeader *curr = m->eh;\n    for (size_t i = 0; i < rec_count; i++) {\n        if (curr->data) {\n            curr->next = calloc(1, sizeof(MOBIExthHeader));\n            if (curr->next == NULL) {\n                debug_print(\"%s\", \"Memory allocation for EXTH header failed\\n\");\n                mobi_free_eh(m);\n                return MOBI_MALLOC_FAILED;\n            }\n            curr = curr->next;\n        }\n        curr->tag = mobi_buffer_get32(buf);\n        /* data size = record size minus 8 bytes for uid and size */\n        curr->size = mobi_buffer_get32(buf) - 8;\n        if (curr->size == 0) {\n            debug_print(\"Skip record %i, data too short\\n\", curr->tag);\n            continue;\n        }\n        if (buf->offset + curr->size > buf->maxlen) {\n            debug_print(\"Record %i too long\\n\", curr->tag);\n            mobi_free_eh(m);\n            return MOBI_DATA_CORRUPT;\n        }\n        curr->data = malloc(curr->size);\n        if (curr->data == NULL) {\n            debug_print(\"Memory allocation for EXTH record %i failed\\n\", curr->tag);\n            mobi_free_eh(m);\n            return MOBI_MALLOC_FAILED;\n        }\n        mobi_buffer_getraw(curr->data, buf, curr->size);\n        curr->next = NULL;\n    }    \n    buf->maxlen = saved_maxlen;\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse MOBI header from Record 0 into MOBIData structure (MOBIMobiHeader)\n \n @param[in,out] m MOBIData structure to be filled with parsed data\n @param[in] buf MOBIBuffer buffer to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_mobiheader(MOBIData *m, MOBIBuffer *buf) {\n    int isKF8 = 0;\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    m->mh = calloc(1, sizeof(MOBIMobiHeader));\n    if (m->mh == NULL) {\n        debug_print(\"%s\", \"Memory allocation for MOBI header failed\\n\");\n        return MOBI_MALLOC_FAILED;\n    }\n    mobi_buffer_getstring(m->mh->mobi_magic, buf, 4);\n    mobi_buffer_dup32(&m->mh->header_length, buf);\n    if (strcmp(m->mh->mobi_magic, MOBI_MAGIC) != 0 || m->mh->header_length == NULL) {\n        debug_print(\"%s\", \"MOBI header not found\\n\");\n        mobi_free_mh(m->mh);\n        m->mh = NULL;\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t saved_maxlen = buf->maxlen;\n    /* some old files declare zero length mobi header, try to read first 24 bytes anyway */\n    uint32_t header_length = (*m->mh->header_length > 0) ? *m->mh->header_length : 24;\n    /* read only declared MOBI header length (curr offset minus 8 already read bytes) */\n    const size_t left_length = header_length + buf->offset - 8;\n    buf->maxlen = saved_maxlen < left_length ? saved_maxlen : left_length;\n    mobi_buffer_dup32(&m->mh->mobi_type, buf);\n    uint32_t encoding = mobi_buffer_get32(buf);\n    if (encoding == 1252) {\n        m->mh->text_encoding = malloc(sizeof(MOBIEncoding));\n        if (m->mh->text_encoding == NULL) {\n            debug_print(\"%s\", \"Memory allocation for MOBI header failed\\n\");\n            return MOBI_MALLOC_FAILED;\n        }\n        *m->mh->text_encoding = MOBI_CP1252;\n    }\n    else if (encoding == 65001) {\n        m->mh->text_encoding = malloc(sizeof(MOBIEncoding));\n        if (m->mh->text_encoding == NULL) {\n            debug_print(\"%s\", \"Memory allocation for MOBI header failed\\n\");\n            return MOBI_MALLOC_FAILED;\n        }\n        *m->mh->text_encoding = MOBI_UTF8;\n    } else {\n        debug_print(\"Unknown encoding in mobi header: %i\\n\", encoding);\n    }\n    mobi_buffer_dup32(&m->mh->uid, buf);\n    mobi_buffer_dup32(&m->mh->version, buf);\n    if (header_length >= MOBI_HEADER_V7_SIZE\n        && m->mh->version && *m->mh->version == 8) {\n        isKF8 = 1;\n    }\n    mobi_buffer_dup32(&m->mh->orth_index, buf);\n    mobi_buffer_dup32(&m->mh->infl_index, buf);\n    mobi_buffer_dup32(&m->mh->names_index, buf);\n    mobi_buffer_dup32(&m->mh->keys_index, buf);\n    mobi_buffer_dup32(&m->mh->extra0_index, buf);\n    mobi_buffer_dup32(&m->mh->extra1_index, buf);\n    mobi_buffer_dup32(&m->mh->extra2_index, buf);\n    mobi_buffer_dup32(&m->mh->extra3_index, buf);\n    mobi_buffer_dup32(&m->mh->extra4_index, buf);\n    mobi_buffer_dup32(&m->mh->extra5_index, buf);\n    mobi_buffer_dup32(&m->mh->non_text_index, buf);\n    mobi_buffer_dup32(&m->mh->full_name_offset, buf);\n    mobi_buffer_dup32(&m->mh->full_name_length, buf);\n    mobi_buffer_dup32(&m->mh->locale, buf);\n    mobi_buffer_dup32(&m->mh->dict_input_lang, buf);\n    mobi_buffer_dup32(&m->mh->dict_output_lang, buf);\n    mobi_buffer_dup32(&m->mh->min_version, buf);\n    mobi_buffer_dup32(&m->mh->image_index, buf);\n    mobi_buffer_dup32(&m->mh->huff_rec_index, buf);\n    mobi_buffer_dup32(&m->mh->huff_rec_count, buf);\n    mobi_buffer_dup32(&m->mh->datp_rec_index, buf);\n    mobi_buffer_dup32(&m->mh->datp_rec_count, buf);\n    mobi_buffer_dup32(&m->mh->exth_flags, buf);\n    mobi_buffer_seek(buf, 32); /* 32 unknown bytes */\n    mobi_buffer_dup32(&m->mh->unknown6, buf);\n    mobi_buffer_dup32(&m->mh->drm_offset, buf);\n    mobi_buffer_dup32(&m->mh->drm_count, buf);\n    mobi_buffer_dup32(&m->mh->drm_size, buf);\n    mobi_buffer_dup32(&m->mh->drm_flags, buf);\n    mobi_buffer_seek(buf, 8); /* 8 unknown bytes */\n    if (isKF8) {\n        mobi_buffer_dup32(&m->mh->fdst_index, buf);\n    } else {\n        mobi_buffer_dup16(&m->mh->first_text_index, buf);\n        mobi_buffer_dup16(&m->mh->last_text_index, buf);\n    }\n    mobi_buffer_dup32(&m->mh->fdst_section_count, buf);\n    mobi_buffer_dup32(&m->mh->fcis_index, buf);\n    mobi_buffer_dup32(&m->mh->fcis_count, buf);\n    mobi_buffer_dup32(&m->mh->flis_index, buf);\n    mobi_buffer_dup32(&m->mh->flis_count, buf);\n    mobi_buffer_dup32(&m->mh->unknown10, buf);\n    mobi_buffer_dup32(&m->mh->unknown11, buf);\n    mobi_buffer_dup32(&m->mh->srcs_index, buf);\n    mobi_buffer_dup32(&m->mh->srcs_count, buf);\n    mobi_buffer_dup32(&m->mh->unknown12, buf);\n    mobi_buffer_dup32(&m->mh->unknown13, buf);\n    mobi_buffer_seek(buf, 2); /* 2 byte fill */\n    mobi_buffer_dup16(&m->mh->extra_flags, buf);\n    mobi_buffer_dup32(&m->mh->ncx_index, buf);\n    if (isKF8) {\n        mobi_buffer_dup32(&m->mh->fragment_index, buf);\n        mobi_buffer_dup32(&m->mh->skeleton_index, buf);\n    } else {\n        mobi_buffer_dup32(&m->mh->unknown14, buf);\n        mobi_buffer_dup32(&m->mh->unknown15, buf);\n    }\n    mobi_buffer_dup32(&m->mh->datp_index, buf);\n    if (isKF8) {\n        mobi_buffer_dup32(&m->mh->guide_index, buf);\n    } else {\n        mobi_buffer_dup32(&m->mh->unknown16, buf);\n    }\n    mobi_buffer_dup32(&m->mh->unknown17, buf);\n    mobi_buffer_dup32(&m->mh->unknown18, buf);\n    mobi_buffer_dup32(&m->mh->unknown19, buf);\n    mobi_buffer_dup32(&m->mh->unknown20, buf);\n    if (buf->maxlen > buf->offset) {\n        debug_print(\"Skipping %zu unknown bytes in MOBI header\\n\", (buf->maxlen - buf->offset));\n        mobi_buffer_setpos(buf, buf->maxlen);\n    }\n    buf->maxlen = saved_maxlen;\n    /* get full name stored at m->mh->full_name_offset */\n    if (m->mh->full_name_offset && m->mh->full_name_length) {\n        const size_t saved_offset = buf->offset;\n        const uint32_t full_name_length = min(*m->mh->full_name_length, MOBI_TITLE_SIZEMAX);\n        mobi_buffer_setpos(buf, *m->mh->full_name_offset);\n        m->mh->full_name = malloc(full_name_length + 1);\n        if (m->mh->full_name == NULL) {\n            debug_print(\"%s\", \"Memory allocation for full name failed\\n\");\n            return MOBI_MALLOC_FAILED;\n        }\n        if (full_name_length) {\n            mobi_buffer_getstring(m->mh->full_name, buf, full_name_length);\n        } else {\n            m->mh->full_name[0] = '\\0';\n        }\n        mobi_buffer_setpos(buf, saved_offset);\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse Record 0 into MOBIData structure\n \n This function will parse MOBIRecord0Header, MOBIMobiHeader and MOBIExthHeader\n \n @param[in,out] m MOBIData structure to be filled with parsed data\n @param[in] seqnumber Sequential number of the palm database record\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_record0(MOBIData *m, const size_t seqnumber) {\n    MOBI_RET ret;\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    const MOBIPdbRecord *record0 = mobi_get_record_by_seqnumber(m, seqnumber);\n    if (record0 == NULL) {\n        debug_print(\"%s\", \"Record 0 not loaded\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    if (record0->size < RECORD0_HEADER_LEN) {\n        debug_print(\"%s\", \"Record 0 too short\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    MOBIBuffer *buf = mobi_buffer_init_null(record0->data, record0->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    m->rh = calloc(1, sizeof(MOBIRecord0Header));\n    if (m->rh == NULL) {\n        debug_print(\"%s\", \"Memory allocation for record 0 header failed\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_MALLOC_FAILED;\n    }\n    /* parse palmdoc header */\n    const uint16_t compression = mobi_buffer_get16(buf);\n    mobi_buffer_seek(buf, 2); // unused 2 bytes, zeroes\n    if ((compression != RECORD0_NO_COMPRESSION &&\n         compression != RECORD0_PALMDOC_COMPRESSION &&\n         compression != RECORD0_HUFF_COMPRESSION)) {\n        debug_print(\"Wrong record0 header: %c%c%c%c\\n\", record0->data[0], record0->data[1], record0->data[2], record0->data[3]);\n        mobi_buffer_free_null(buf);\n        free(m->rh);\n        m->rh = NULL;\n        return MOBI_DATA_CORRUPT;\n    }\n    m->rh->compression_type = compression;\n    m->rh->text_length = mobi_buffer_get32(buf);\n    m->rh->text_record_count = mobi_buffer_get16(buf);\n    m->rh->text_record_size = mobi_buffer_get16(buf);\n    m->rh->encryption_type = mobi_buffer_get16(buf);\n    m->rh->unknown1 = mobi_buffer_get16(buf);\n    if (mobi_is_mobipocket(m)) {\n        /* parse mobi header if present  */\n        ret = mobi_parse_mobiheader(m, buf);\n        if (ret == MOBI_SUCCESS) {\n            /* parse exth header if present */\n            mobi_parse_extheader(m, buf);\n        }\n    } \n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Calculate the size of extra bytes at the end of text record\n \n @param[in] record MOBIPdbRecord structure containing the record\n @param[in] flags Flags from MOBI header (extra_flags)\n @return The size of trailing bytes, MOBI_NOTSET on failure\n */\nsize_t mobi_get_record_extrasize(const MOBIPdbRecord *record, const uint16_t flags) {\n    size_t extra_size = 0;\n    MOBIBuffer *buf = mobi_buffer_init_null(record->data, record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\", \"Buffer init in extrasize failed\\n\");\n        return MOBI_NOTSET;\n    }\n    /* set pointer at the end of the record data */\n    mobi_buffer_setpos(buf, buf->maxlen - 1);\n    for (int bit = 15; bit > 0; bit--) {\n        if (flags & (1 << bit)) {\n            /* bit is set */\n            size_t len = 0;\n            /* size contains varlen itself and optional data */\n            const uint32_t size = mobi_buffer_get_varlen_dec(buf, &len);\n            /* skip data */\n            /* TODO: read and store in record struct */\n            mobi_buffer_seek(buf, - (int)(size - len));\n            extra_size += size;\n        }\n    };\n    /* check bit 0 */\n    if (flags & 1) {\n            const uint8_t b = mobi_buffer_get8(buf);\n            /* two first bits hold size */\n            extra_size += (b & 0x3) + 1;\n    }\n    mobi_buffer_free_null(buf);\n    return extra_size;\n}\n\n/**\n @brief Calculate the size of extra multibyte section at the end of text record\n \n @param[in] record MOBIPdbRecord structure containing the record\n @param[in] flags Flags from MOBI header (extra_flags)\n @return The size of trailing bytes, MOBI_NOTSET on failure\n */\nsize_t mobi_get_record_mb_extrasize(const MOBIPdbRecord *record, const uint16_t flags) {\n    size_t extra_size = 0;\n    if (flags & 1) {\n        MOBIBuffer *buf = mobi_buffer_init_null(record->data, record->size);\n        if (buf == NULL) {\n            debug_print(\"%s\", \"Buffer init in extrasize failed\\n\");\n            return MOBI_NOTSET;\n        }\n        /* set pointer at the end of the record data */\n        mobi_buffer_setpos(buf, buf->maxlen - 1);\n        for (int bit = 15; bit > 0; bit--) {\n            if (flags & (1 << bit)) {\n                /* bit is set */\n                size_t len = 0;\n                /* size contains varlen itself and optional data */\n                const uint32_t size = mobi_buffer_get_varlen_dec(buf, &len);\n                /* skip data */\n                /* TODO: read and store in record struct */\n                mobi_buffer_seek(buf, - (int)(size - len));\n            }\n        };\n        /* read multibyte section */\n        const uint8_t b = mobi_buffer_get8(buf);\n        /* two first bits hold size */\n        extra_size += (b & 0x3) + 1;\n        mobi_buffer_free_null(buf);\n    }\n    return extra_size;\n}\n\n/**\n @brief Parse HUFF record into MOBIHuffCdic structure\n \n @param[in,out] huffcdic MOBIHuffCdic structure to be filled with parsed data\n @param[in] record MOBIPdbRecord structure containing the record\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_huff(MOBIHuffCdic *huffcdic, const MOBIPdbRecord *record) {\n    MOBIBuffer *buf = mobi_buffer_init_null(record->data, record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    char huff_magic[5];\n    mobi_buffer_getstring(huff_magic, buf, 4);\n    const size_t header_length = mobi_buffer_get32(buf);\n    if (strncmp(huff_magic, HUFF_MAGIC, 4) != 0 || header_length < HUFF_HEADER_LEN) {\n        debug_print(\"HUFF wrong magic: %s\\n\", huff_magic);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t data1_offset = mobi_buffer_get32(buf);\n    const size_t data2_offset = mobi_buffer_get32(buf);\n    /* skip little-endian table offsets */\n    mobi_buffer_setpos(buf, data1_offset);\n    if (buf->offset + (256 * 4) > buf->maxlen) {\n        debug_print(\"%s\", \"HUFF data1 too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* read 256 indices from data1 big-endian */\n    for (int i = 0; i < 256; i++) {\n        huffcdic->table1[i] = mobi_buffer_get32(buf);\n    }\n    mobi_buffer_setpos(buf, data2_offset);\n    if (buf->offset + (64 * 4) > buf->maxlen) {\n        debug_print(\"%s\", \"HUFF data2 too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* read 32 mincode-maxcode pairs from data2 big-endian */\n    huffcdic->mincode_table[0] = 0;\n    huffcdic->maxcode_table[0] = 0xFFFFFFFF;\n    for (int i = 1; i < HUFF_CODETABLE_SIZE; i++) {\n        const uint32_t mincode = mobi_buffer_get32(buf);\n        const uint32_t maxcode = mobi_buffer_get32(buf);\n        huffcdic->mincode_table[i] =  mincode << (32 - i);\n        huffcdic->maxcode_table[i] =  ((maxcode + 1) << (32 - i)) - 1;\n    }\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse CDIC record into MOBIHuffCdic structure\n \n @param[in,out] huffcdic MOBIHuffCdic structure to be filled with parsed data\n @param[in] record MOBIPdbRecord structure containing the record\n @param[in] num Number of CDIC record in a set, starting from zero\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_cdic(MOBIHuffCdic *huffcdic, const MOBIPdbRecord *record, const size_t num) {\n    MOBIBuffer *buf = mobi_buffer_init_null(record->data, record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    char cdic_magic[5];\n    mobi_buffer_getstring(cdic_magic, buf, 4);\n    const size_t header_length = mobi_buffer_get32(buf);\n    if (strncmp(cdic_magic, CDIC_MAGIC, 4) != 0 || header_length < CDIC_HEADER_LEN) {\n        debug_print(\"CDIC wrong magic: %s or declared header length: %zu\\n\", cdic_magic, header_length);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* variables in huffcdic initialized to zero with calloc */\n    /* save initial count and length */\n    size_t index_count = mobi_buffer_get32(buf);\n    const size_t code_length = mobi_buffer_get32(buf);\n    if (huffcdic->code_length && huffcdic->code_length != code_length) {\n        debug_print(\"CDIC different code length %zu in record %i, previous was %zu\\n\", huffcdic->code_length, record->uid, code_length);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    if (huffcdic->index_count && huffcdic->index_count != index_count) {\n        debug_print(\"CDIC different index count %zu in record %i, previous was %zu\\n\", huffcdic->index_count, record->uid, index_count);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    if (code_length == 0 || code_length > HUFF_CODELEN_MAX) {\n        debug_print(\"Code length exceeds sanity checks (%zu)\\n\", code_length);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    huffcdic->code_length = code_length;\n    huffcdic->index_count = index_count;\n    if (index_count == 0) {\n        debug_print(\"%s\", \"CDIC index count is null\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* allocate memory for symbol offsets if not already allocated */\n    if (num == 0) {\n        if (index_count > (1 << HUFF_CODELEN_MAX) * CDIC_RECORD_MAXCNT) {\n            debug_print(\"CDIC index count too large %zu\\n\", index_count);\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        huffcdic->symbol_offsets = malloc(index_count * sizeof(*huffcdic->symbol_offsets));\n        if (huffcdic->symbol_offsets == NULL) {\n            debug_print(\"%s\", \"CDIC cannot allocate memory\");\n            mobi_buffer_free_null(buf);\n            return MOBI_MALLOC_FAILED;\n        }\n    }\n    index_count -= huffcdic->index_read;\n    /* limit number of records read to code_length bits */\n    if (index_count >> code_length) {\n        index_count = (1 << code_length);\n    }\n    if (buf->offset + (index_count * 2) > buf->maxlen) {\n        debug_print(\"%s\", \"CDIC indices data too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* read i * 2 byte big-endian indices */\n    while (index_count--) {\n        const uint16_t offset = mobi_buffer_get16(buf);\n        const size_t saved_pos = buf->offset;\n        mobi_buffer_setpos(buf, offset + CDIC_HEADER_LEN);\n        const size_t len = mobi_buffer_get16(buf) & 0x7fff;\n        if (buf->error != MOBI_SUCCESS || buf->offset + len > buf->maxlen) {\n            debug_print(\"%s\", \"CDIC offset beyond buffer\\n\");\n            mobi_buffer_free_null(buf);\n            return MOBI_DATA_CORRUPT;\n        }\n        mobi_buffer_setpos(buf, saved_pos);\n        huffcdic->symbol_offsets[huffcdic->index_read++] = offset;\n    }\n    if (buf->offset + code_length > buf->maxlen) {\n        debug_print(\"%s\", \"CDIC dictionary data too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    /* copy pointer to data */\n    huffcdic->symbols[num] = record->data + CDIC_HEADER_LEN;\n    /* free buffer */\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse a set of HUFF and CDIC records into MOBIHuffCdic structure\n \n @param[in] m MOBIData structure with loaded MOBI document\n @param[in,out] huffcdic MOBIHuffCdic structure to be filled with parsed data\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_huffdic(const MOBIData *m, MOBIHuffCdic *huffcdic) {\n    MOBI_RET ret;\n    const size_t offset = mobi_get_kf8offset(m);\n    if (m->mh == NULL || m->mh->huff_rec_index == NULL || m->mh->huff_rec_count == NULL) {\n        debug_print(\"%s\", \"HUFF/CDIC records metadata not found in MOBI header\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    const size_t huff_rec_index = *m->mh->huff_rec_index + offset;\n    const size_t huff_rec_count = *m->mh->huff_rec_count;\n    if (huff_rec_count > HUFF_RECORD_MAXCNT) {\n        debug_print(\"Too many HUFF record (%zu)\\n\", huff_rec_count);\n        return MOBI_DATA_CORRUPT;\n    }\n    const MOBIPdbRecord *curr = mobi_get_record_by_seqnumber(m, huff_rec_index);\n    if (curr == NULL || huff_rec_count < 2) {\n        debug_print(\"%s\", \"HUFF/CDIC record not found\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    if (curr->size < HUFF_RECORD_MINSIZE) {\n        debug_print(\"HUFF record too short (%zu b)\\n\", curr->size);\n        return MOBI_DATA_CORRUPT;\n    }\n    ret = mobi_parse_huff(huffcdic, curr);\n    if (ret != MOBI_SUCCESS) {\n        debug_print(\"%s\", \"HUFF parsing failed\\n\");\n        return ret;\n    }\n    curr = curr->next;\n    /* allocate memory for symbols data in each CDIC record */\n    huffcdic->symbols = malloc((huff_rec_count - 1) * sizeof(*huffcdic->symbols));\n    if (huffcdic->symbols == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    /* get following CDIC records */\n    size_t i = 0;\n    while (i < huff_rec_count - 1) {\n        if (curr == NULL) {\n            debug_print(\"%s\\n\", \"CDIC record not found\");\n            return MOBI_DATA_CORRUPT;\n        }\n        ret = mobi_parse_cdic(huffcdic, curr, i++);\n        if (ret != MOBI_SUCCESS) {\n            debug_print(\"%s\", \"CDIC parsing failed\\n\");\n            return ret;\n        }\n        curr = curr->next;\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Parse FDST record into MOBIRawml structure (MOBIFdst member)\n \n @param[in] m MOBIData structure with loaded MOBI document\n @param[in,out] rawml MOBIRawml structure to be filled with parsed data\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_parse_fdst(const MOBIData *m, MOBIRawml *rawml) {\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    const size_t fdst_record_number = mobi_get_fdst_record_number(m);\n    if (fdst_record_number == MOBI_NOTSET) {\n        return MOBI_DATA_CORRUPT;\n    }\n    const MOBIPdbRecord *fdst_record = mobi_get_record_by_seqnumber(m, fdst_record_number);\n    if (fdst_record == NULL) {\n        return MOBI_DATA_CORRUPT;\n    }\n    MOBIBuffer *buf = mobi_buffer_init_null(fdst_record->data, fdst_record->size);\n    if (buf == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        return MOBI_MALLOC_FAILED;\n    }\n    char fdst_magic[5];\n    mobi_buffer_getstring(fdst_magic, buf, 4);\n    const size_t data_offset = mobi_buffer_get32(buf);\n    const size_t section_count = mobi_buffer_get32(buf);\n    if (strncmp(fdst_magic, FDST_MAGIC, 4) != 0 ||\n        section_count <= 1 ||\n        section_count != *m->mh->fdst_section_count ||\n        data_offset != 12) {\n        debug_print(\"FDST wrong magic: %s, sections count: %zu or data offset: %zu\\n\", fdst_magic, section_count, data_offset);\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    if ((buf->maxlen - buf->offset) < section_count * 8) {\n        debug_print(\"%s\", \"Record FDST too short\\n\");\n        mobi_buffer_free_null(buf);\n        return MOBI_DATA_CORRUPT;\n    }\n    rawml->fdst = malloc(sizeof(MOBIFdst));\n    if (rawml->fdst == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        mobi_buffer_free_null(buf);\n        return MOBI_MALLOC_FAILED;\n    }\n    rawml->fdst->fdst_section_count = section_count;\n    rawml->fdst->fdst_section_starts = malloc(sizeof(*rawml->fdst->fdst_section_starts) * section_count);\n    if (rawml->fdst->fdst_section_starts == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        mobi_buffer_free_null(buf);\n        free(rawml->fdst);\n        rawml->fdst = NULL;\n        return MOBI_MALLOC_FAILED;\n    }\n    rawml->fdst->fdst_section_ends = malloc(sizeof(*rawml->fdst->fdst_section_ends) * section_count);\n    if (rawml->fdst->fdst_section_ends == NULL) {\n        debug_print(\"%s\\n\", \"Memory allocation failed\");\n        mobi_buffer_free_null(buf);\n        free(rawml->fdst->fdst_section_starts);\n        free(rawml->fdst);\n        rawml->fdst = NULL;\n        return MOBI_MALLOC_FAILED;\n    }\n    size_t i = 0;\n    while (i < section_count) {\n        rawml->fdst->fdst_section_starts[i] = mobi_buffer_get32(buf);\n        rawml->fdst->fdst_section_ends[i] = mobi_buffer_get32(buf);\n        debug_print(\"FDST[%zu]:\\t%i\\t%i\\n\", i, rawml->fdst->fdst_section_starts[i], rawml->fdst->fdst_section_ends[i]);\n        i++;\n    }\n    mobi_buffer_free_null(buf);\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Read MOBI document from file into MOBIData structure\n \n @param[in,out] m MOBIData structure to be filled with read data\n @param[in] file File descriptor to read from\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_load_file(MOBIData *m, FILE *file) {\n    MOBI_RET ret;\n    if (m == NULL) {\n        debug_print(\"%s\", \"Mobi structure not initialized\\n\");\n        return MOBI_INIT_FAILED;\n    }\n    ret = mobi_load_pdbheader(m, file);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    if (strcmp(m->ph->type, \"BOOK\") != 0 && strcmp(m->ph->type, \"TEXt\") != 0) {\n        debug_print(\"Unsupported file type: %s\\n\", m->ph->type);\n        return MOBI_FILE_UNSUPPORTED;\n    }\n    if (m->ph->rec_count == 0) {\n        debug_print(\"%s\", \"No records found\\n\");\n        return MOBI_DATA_CORRUPT;\n    }\n    ret = mobi_load_reclist(m, file);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    ret = mobi_load_rec(m, file);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    ret = mobi_parse_record0(m, 0);\n    if (ret != MOBI_SUCCESS) {\n        return ret;\n    }\n    if (m->rh && m->rh->encryption_type == RECORD0_OLD_ENCRYPTION) {\n        /* try to set key for encryption type 1 */\n        debug_print(\"Trying to set key for encryption type 1%s\", \"\\n\")\n        mobi_drm_setkey(m, NULL);\n    }\n    /* if EXTH is loaded parse KF8 record0 for hybrid KF7/KF8 file */\n    if (m->eh) {\n        const size_t boundary_rec_number = mobi_get_kf8boundary_seqnumber(m);\n        if (boundary_rec_number != MOBI_NOTSET && boundary_rec_number < UINT32_MAX) {\n            /* it is a hybrid KF7/KF8 file */\n            m->kf8_boundary_offset = (uint32_t) boundary_rec_number;\n            m->next = mobi_init();\n            /* link pdb header and records data to KF8data structure */\n            m->next->ph = m->ph;\n            m->next->rec = m->rec;\n            m->next->drm_key = m->drm_key;\n            /* close next loop */\n            m->next->next = m;\n            ret = mobi_parse_record0(m->next, boundary_rec_number + 1);\n            if (ret != MOBI_SUCCESS) {\n                return ret;\n            }\n            /* swap to kf8 part if use_kf8 flag is set */\n            if (m->use_kf8) {\n                mobi_swap_mobidata(m);\n            }\n        }\n    }\n    return MOBI_SUCCESS;\n}\n\n/**\n @brief Read MOBI document from a path into MOBIData structure\n \n @param[in,out] m MOBIData structure to be filled with read data\n @param[in] path Path to a MOBI document on disk (eg. /home/me/test.mobi)\n @return MOBI_RET status code (on success MOBI_SUCCESS)\n */\nMOBI_RET mobi_load_filename(MOBIData *m, const char *path) {\n    FILE *file = fopen(path, \"rb\");\n    if (file == NULL) {\n        debug_print(\"%s\", \"File not found\\n\");\n        return MOBI_FILE_NOT_FOUND;\n    }\n    const MOBI_RET ret = mobi_load_file(m, file);\n    fclose(file);\n    return ret;\n}\n"], "filenames": ["src/compression.c", "src/compression.h", "src/read.c"], "buggy_code_start_loc": [144, 22, 592], "buggy_code_end_loc": [145, 35, 593], "fixing_code_start_loc": [144, 23, 592], "fixing_code_end_loc": [148, 36, 593], "type": "CWE-125", "message": "libmobi is vulnerable to Out-of-bounds Read", "other": {"cve": {"id": "CVE-2021-3881", "sourceIdentifier": "security@huntr.dev", "published": "2021-10-15T14:15:07.907", "lastModified": "2021-10-22T12:29:28.390", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "libmobi is vulnerable to Out-of-bounds Read"}, {"lang": "es", "value": "libmobi es vulnerable a una lectura fuera de l\u00edmites"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:L", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "CHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 7.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 3.7}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libmobi_project:libmobi:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.7", "matchCriteriaId": "D2333D42-14FA-48A8-873C-573E718CBD86"}]}]}], "references": [{"url": "https://github.com/bfabiszewski/libmobi/commit/bec783e6212439a335ba6e8df7ab8ed610ca9a21", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/540fd115-7de4-4e19-a918-5ee61f5157c1", "source": "security@huntr.dev", "tags": ["Exploit", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/bfabiszewski/libmobi/commit/bec783e6212439a335ba6e8df7ab8ed610ca9a21"}}