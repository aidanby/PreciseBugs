{"buggy_code": ["# frozen_string_literal: true\n\nmodule Compression\n  class Engine\n    UnsupportedFileExtension = Class.new(StandardError)\n\n    def self.default_strategies\n      [\n        Compression::Zip.new,\n        Compression::Pipeline.new([Compression::Tar.new, Compression::Gzip.new]),\n        Compression::Gzip.new,\n        Compression::Tar.new\n      ]\n    end\n\n    def self.engine_for(filename, strategies: default_strategies)\n      strategy = strategies.detect(-> { raise UnsupportedFileExtension }) { |e| e.can_handle?(filename) }\n      new(strategy)\n    end\n\n    def initialize(strategy)\n      @strategy = strategy\n    end\n\n    delegate :extension, :decompress, :compress, :strip_directory, to: :@strategy\n  end\nend\n", "# frozen_string_literal: true\n\nmodule Compression\n  class Gzip < Strategy\n    def extension\n      '.gz'\n    end\n\n    def compress(path, target_name)\n      gzip_target = sanitize_path(\"#{path}/#{target_name}\")\n      Discourse::Utils.execute_command('gzip', '-5', gzip_target, failure_message: \"Failed to gzip file.\")\n\n      \"#{gzip_target}.gz\"\n    end\n\n    private\n\n    def entries_of(compressed_file)\n      [compressed_file]\n    end\n\n    def is_file?(_)\n      true\n    end\n\n    def extract_folder(_entry, _entry_path); end\n\n    def get_compressed_file_stream(compressed_file_path)\n      gzip = Zlib::GzipReader.open(compressed_file_path)\n      yield(gzip)\n    end\n\n    def build_entry_path(_compressed_file, dest_path, compressed_file_path, entry, _allow_non_root_folder)\n      compressed_file_path.gsub(extension, '')\n    end\n\n    def extract_file(entry, entry_path, available_size)\n      remaining_size = available_size\n\n      if ::File.exist?(entry_path)\n        raise ::Zip::DestinationFileExistsError,\n              \"Destination '#{entry_path}' already exists\"\n      end # Change this later.\n\n      ::File.open(entry_path, 'wb') do |os|\n        buf = ''.dup\n        while (buf = entry.read(chunk_size))\n          remaining_size -= chunk_size\n          raise ExtractFailed if remaining_size.negative?\n          os << buf\n        end\n      end\n\n      remaining_size\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nmodule Compression\n  class Pipeline < Strategy\n    def initialize(strategies)\n      @strategies = strategies\n    end\n\n    def extension\n      @strategies.reduce('') { |ext, strategy| ext += strategy.extension }\n    end\n\n    def compress(path, target_name)\n      current_target = target_name\n      @strategies.reduce('') do |compressed_path, strategy|\n        compressed_path = strategy.compress(path, current_target)\n        current_target = compressed_path.split('/').last\n\n        compressed_path\n      end\n    end\n\n    def decompress(dest_path, compressed_file_path, max_size, allow_non_root_folder: false)\n      @strategies.reverse.reduce(compressed_file_path) do |to_decompress, strategy|\n        last_extension = strategy.extension\n        strategy.decompress(dest_path, to_decompress, max_size, allow_non_root_folder: allow_non_root_folder)\n        to_decompress.gsub(last_extension, '')\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nmodule Compression\n  class Strategy\n    ExtractFailed = Class.new(StandardError)\n    DestinationFileExistsError = Class.new(StandardError)\n\n    def can_handle?(file_name)\n      file_name.include?(extension)\n    end\n\n    def decompress(dest_path, compressed_file_path, max_size, allow_non_root_folder: false)\n      sanitized_compressed_file_path = sanitize_path(compressed_file_path)\n\n      get_compressed_file_stream(sanitized_compressed_file_path) do |compressed_file|\n        available_size = calculate_available_size(max_size)\n\n        entries_of(compressed_file).each do |entry|\n          entry_path = build_entry_path(\n            compressed_file, sanitize_path(dest_path),\n            sanitized_compressed_file_path, entry,\n            allow_non_root_folder\n          )\n\n          if is_file?(entry)\n            remaining_size = extract_file(entry, entry_path, available_size)\n            available_size = remaining_size\n          else\n            extract_folder(entry, entry_path)\n          end\n        end\n      end\n    end\n\n    def strip_directory(from, to, relative: false)\n      sanitized_from = sanitize_path(from) rescue nil\n      sanitized_to = sanitize_path(to) rescue nil\n      return unless sanitized_from && sanitized_to\n\n      glob_path = relative ? \"#{sanitized_from}/*/*\" : \"#{sanitized_from}/**\"\n      FileUtils.mv(Dir.glob(glob_path), sanitized_to) if File.directory?(sanitized_from)\n    end\n\n    private\n\n    def sanitize_path(filename)\n      Pathname.new(filename).realpath.to_s\n    end\n\n    # https://guides.rubyonrails.org/security.html#file-uploads\n    def sanitize_filename(filename)\n      filename.strip.tap do |name|\n        # NOTE: File.basename doesn't work right with Windows paths on Unix\n        # get only the filename, not the whole path\n        name.sub! /\\A.*(\\\\|\\/)/, ''\n        # Finally, replace all non alphanumeric, underscore\n        # or periods with underscore\n        name.gsub! /[^\\w\\.\\-]/, '_'\n      end\n    end\n\n    def calculate_available_size(max_size)\n      1024**2 * (max_size / 1.049) # Mb to Mib\n    end\n\n    def entries_of(compressed_file)\n      compressed_file\n    end\n\n    def is_file?(entry)\n      entry.file?\n    end\n\n    def chunk_size\n      @chunk_size ||= 1024**2 * 2 # 2MiB\n    end\n\n    def extract_file(entry, entry_path, available_size)\n      remaining_size = available_size\n\n      if ::File.exist?(entry_path)\n        raise DestinationFileExistsError, \"Destination '#{entry_path}' already exists\"\n      end\n\n      ::File.open(entry_path, 'wb') do |os|\n        while (buf = entry.read(chunk_size))\n          remaining_size -= buf.size\n          raise ExtractFailed if remaining_size.negative?\n          os << buf\n        end\n      end\n\n      remaining_size\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rubygems/package'\n\nmodule Compression\n  class Tar < Strategy\n    def extension\n      '.tar'\n    end\n\n    def compress(path, target_name)\n      tar_filename = sanitize_filename(\"#{target_name}.tar\")\n      Discourse::Utils.execute_command('tar', '--create', '--file', tar_filename, target_name, failure_message: \"Failed to tar file.\")\n\n      sanitize_path(\"#{path}/#{tar_filename}\")\n    end\n\n    private\n\n    def extract_folder(_entry, _entry_path); end\n\n    def get_compressed_file_stream(compressed_file_path)\n      file_stream = IO.new(IO.sysopen(compressed_file_path))\n      tar_extract = Gem::Package::TarReader.new(file_stream)\n      tar_extract.rewind\n      yield(tar_extract)\n    end\n\n    def build_entry_path(_compressed_file, dest_path, compressed_file_path, entry, _allow_non_root_folder)\n      File.join(dest_path, entry.full_name).tap do |entry_path|\n        FileUtils.mkdir_p(File.dirname(entry_path))\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'zip'\n\nmodule Compression\n  class Zip < Strategy\n    def extension\n      '.zip'\n    end\n\n    def compress(path, target_name)\n      absolute_path = sanitize_path(\"#{path}/#{target_name}\")\n      zip_filename = \"#{absolute_path}.zip\"\n\n      ::Zip::File.open(zip_filename, ::Zip::File::CREATE) do |zipfile|\n        if File.directory?(absolute_path)\n          entries = Dir.entries(absolute_path) - %w[. ..]\n          write_entries(entries, absolute_path, '', zipfile)\n        else\n          put_into_archive(absolute_path, zipfile, target_name)\n        end\n      end\n\n      zip_filename\n    end\n\n    private\n\n    def extract_folder(entry, entry_path)\n      entry.extract(entry_path)\n    end\n\n    def get_compressed_file_stream(compressed_file_path)\n      zip_file = ::Zip::File.open(compressed_file_path)\n      yield(zip_file)\n    end\n\n    def build_entry_path(compressed_file, dest_path, compressed_file_path, entry, allow_non_root_folder)\n      folder_name = compressed_file_path.split('/').last.gsub('.zip', '')\n      root = root_folder_present?(compressed_file, allow_non_root_folder) ? '' : \"#{folder_name}/\"\n\n      File.join(dest_path, \"#{root}#{entry.name}\").tap do |entry_path|\n        FileUtils.mkdir_p(File.dirname(entry_path))\n      end\n    end\n\n    def root_folder_present?(filenames, allow_non_root_folder)\n      filenames.map { |p| p.name.split('/').first }.uniq.size == 1 || allow_non_root_folder\n    end\n\n    def extract_file(entry, entry_path, available_size)\n      remaining_size = available_size\n\n      if ::File.exist?(entry_path)\n        raise ::Zip::DestinationFileExistsError,\n              \"Destination '#{entry_path}' already exists\"\n      end\n\n      ::File.open(entry_path, 'wb') do |os|\n        entry.get_input_stream do |is|\n          entry.set_extra_attributes_on_path(entry_path)\n\n          buf = ''.dup\n          while (buf = is.sysread(chunk_size, buf))\n            remaining_size -= chunk_size\n            raise ExtractFailed if remaining_size.negative?\n            os << buf\n          end\n        end\n      end\n\n      remaining_size\n    end\n\n    # A helper method to make the recursion work.\n    def write_entries(entries, base_path, path, zipfile)\n      entries.each do |e|\n        zipfile_path = path == '' ? e : File.join(path, e)\n        disk_file_path = File.join(base_path, zipfile_path)\n\n        if File.directory? disk_file_path\n          recursively_deflate_directory(disk_file_path, zipfile, base_path, zipfile_path)\n        else\n          put_into_archive(disk_file_path, zipfile, zipfile_path)\n        end\n      end\n    end\n\n    def recursively_deflate_directory(disk_file_path, zipfile, base_path, zipfile_path)\n      zipfile.mkdir zipfile_path\n      subdir = Dir.entries(disk_file_path) - %w[. ..]\n      write_entries subdir, base_path, zipfile_path, zipfile\n    end\n\n    def put_into_archive(disk_file_path, zipfile, zipfile_path)\n      zipfile.add(zipfile_path, disk_file_path)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'compression/engine'\n\nmodule ThemeStore; end\n\nclass ThemeStore::ZipImporter\n\n  attr_reader :url\n\n  def initialize(filename, original_filename)\n    @temp_folder = \"#{Pathname.new(Dir.tmpdir).realpath}/discourse_theme_#{SecureRandom.hex}\"\n    @filename = filename\n    @original_filename = original_filename\n  end\n\n  def import!\n    FileUtils.mkdir(@temp_folder)\n\n    available_size = SiteSetting.decompressed_theme_max_file_size_mb\n    Compression::Engine.engine_for(@original_filename).tap do |engine|\n      engine.decompress(@temp_folder, @filename, available_size)\n      engine.strip_directory(@temp_folder, @temp_folder, relative: true)\n    end\n  rescue RuntimeError\n    raise RemoteTheme::ImportError, I18n.t(\"themes.import_error.unpack_failed\")\n  rescue Compression::Zip::ExtractFailed\n    raise RemoteTheme::ImportError, I18n.t(\"themes.import_error.file_too_big\")\n  end\n\n  def cleanup!\n    FileUtils.rm_rf(@temp_folder)\n  end\n\n  def version\n    \"\"\n  end\n\n  def real_path(relative)\n    fullpath = \"#{@temp_folder}/#{relative}\"\n    return nil unless File.exist?(fullpath)\n\n    # careful to handle symlinks here, don't want to expose random data\n    fullpath = Pathname.new(fullpath).realpath.to_s\n\n    if fullpath && fullpath.start_with?(@temp_folder)\n      fullpath\n    else\n      nil\n    end\n  end\n\n  def all_files\n    Dir.glob(\"**/**\", base: @temp_folder).reject { |f| File.directory?(File.join(@temp_folder, f)) }\n  end\n\n  def [](value)\n    fullpath = real_path(value)\n    return nil unless fullpath\n    File.read(fullpath)\n  end\n\nend\n", "# frozen_string_literal: true\n\nRSpec.describe Compression::Engine do\n  let(:available_size) { SiteSetting.decompressed_theme_max_file_size_mb }\n\n  before do\n    @temp_folder = \"#{Pathname.new(Dir.tmpdir).realpath}/#{SecureRandom.hex}\"\n    @folder_name = 'test'\n\n    FileUtils.mkdir(@temp_folder)\n    Dir.chdir(@temp_folder) do\n      FileUtils.mkdir_p(\"#{@folder_name}/a\")\n      File.write(\"#{@folder_name}/hello.txt\", 'hello world')\n      File.write(\"#{@folder_name}/a/inner\", 'hello world inner')\n    end\n  end\n\n  after { FileUtils.rm_rf @temp_folder }\n\n  it 'raises an exception when the file is not supported' do\n    unknown_extension = 'a_file.crazyext'\n    expect { described_class.engine_for(unknown_extension) }.to raise_error Compression::Engine::UnsupportedFileExtension\n  end\n\n  describe 'compressing and decompressing files' do\n    before do\n      Dir.chdir(@temp_folder) do\n        @compressed_path = Compression::Engine.engine_for(\"#{@folder_name}#{extension}\").compress(@temp_folder, @folder_name)\n        FileUtils.rm_rf(\"#{@folder_name}/\")\n      end\n    end\n\n    context 'when working with zip files' do\n      let(:extension) { '.zip' }\n\n      it 'decompress the folder and inspect files correctly' do\n        engine = described_class.engine_for(@compressed_path)\n\n        engine.decompress(@temp_folder, \"#{@temp_folder}/#{@folder_name}.zip\", available_size)\n\n        expect(read_file(\"test/hello.txt\")).to eq(\"hello world\")\n        expect(read_file(\"test/a/inner\")).to eq(\"hello world inner\")\n      end\n    end\n\n    context 'when working with .tar.gz files' do\n      let(:extension) { '.tar.gz' }\n\n      it 'decompress the folder and inspect files correctly' do\n        engine = described_class.engine_for(@compressed_path)\n\n        engine.decompress(@temp_folder, \"#{@temp_folder}/#{@folder_name}.tar.gz\", available_size)\n\n        expect(read_file(\"test/hello.txt\")).to eq(\"hello world\")\n        expect(read_file(\"test/a/inner\")).to eq(\"hello world inner\")\n      end\n    end\n\n    context 'when working with .tar files' do\n      let(:extension) { '.tar' }\n\n      it 'decompress the folder and inspect files correctly' do\n        engine = described_class.engine_for(@compressed_path)\n\n        engine.decompress(@temp_folder, \"#{@temp_folder}/#{@folder_name}.tar\", available_size)\n\n        expect(read_file(\"test/hello.txt\")).to eq(\"hello world\")\n        expect(read_file(\"test/a/inner\")).to eq(\"hello world inner\")\n      end\n    end\n  end\n\n  def read_file(relative_path)\n    File.read(\"#{@temp_folder}/#{relative_path}\")\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'theme_store/zip_exporter'\n\nRSpec.describe ThemeStore::ZipExporter do\n  let(:rand_hex) do\n    +\"X\" << SecureRandom.hex\n  end\n  let!(:theme) do\n    Fabricate(:theme, name: \"Header Icons\").tap do |theme|\n      theme.set_field(target: :common, name: :body_tag, value: \"<b>testtheme1</b>\")\n      theme.set_field(target: :settings, name: :yaml, value: \"somesetting: #{rand_hex}\")\n      theme.set_field(target: :mobile, name: :scss, value: 'body {background-color: $background_color; font-size: $font-size}')\n      theme.set_field(target: :translations, name: :en, value: { en: { key: \"value\" } }.deep_stringify_keys.to_yaml)\n      image = file_from_fixtures(\"logo.png\")\n      upload = UploadCreator.new(image, \"logo.png\").create_for(Discourse::SYSTEM_USER_ID)\n      theme.set_field(target: :common, name: :logo, upload_id: upload.id, type: :theme_upload_var)\n      image = file_from_fixtures(\"logo.png\")\n      _other_upload = UploadCreator.new(image, \"logo.png\").create_for(Discourse::SYSTEM_USER_ID)\n      theme.set_field(target: :common, name: \"other_logo\", upload_id: upload.id, type: :theme_upload_var)\n      theme.build_remote_theme(remote_url: \"\", about_url: \"abouturl\", license_url: \"licenseurl\",\n                               authors: \"David Taylor\", theme_version: \"1.0\", minimum_discourse_version: \"1.0.0\",\n                               maximum_discourse_version: \"3.0.0.beta1\")\n\n      cs1 = Fabricate(:color_scheme, name: 'Orphan Color Scheme', color_scheme_colors: [\n        Fabricate(:color_scheme_color, name: 'header_primary',  hex: 'F0F0F0'),\n        Fabricate(:color_scheme_color, name: 'header_background', hex: '1E1E1E'),\n        Fabricate(:color_scheme_color, name: 'tertiary', hex: '858585')\n      ])\n\n      cs2 = Fabricate(:color_scheme, name: 'Theme Color Scheme', color_scheme_colors: [\n        Fabricate(:color_scheme_color, name: 'header_primary',  hex: 'F0F0F0'),\n        Fabricate(:color_scheme_color, name: 'header_background', hex: '1E1E1E'),\n        Fabricate(:color_scheme_color, name: 'tertiary', hex: '858585')\n      ])\n\n      theme.color_scheme = cs1\n      cs2.update(theme_id: theme.id)\n\n      theme.save!\n    end\n  end\n\n  let(:dir) do\n    tmpdir = Dir.tmpdir\n    dir = \"#{tmpdir}/#{SecureRandom.hex}\"\n    FileUtils.mkdir(dir)\n    dir\n  end\n\n  after do\n    FileUtils.rm_rf(dir)\n  end\n\n  let(:package) do\n    exporter = ThemeStore::ZipExporter.new(theme)\n    filename = exporter.package_filename\n    FileUtils.cp(filename, dir)\n    exporter.cleanup!\n    \"#{dir}/discourse-header-icons.zip\"\n  end\n\n  it \"exports the theme correctly\" do\n    package\n    file = 'discourse-header-icons.zip'\n    Dir.chdir(dir) do\n      available_size = SiteSetting.decompressed_theme_max_file_size_mb\n      Compression::Zip.new.decompress(dir, file, available_size, allow_non_root_folder: true)\n      `rm #{file}`\n\n      folders = Dir.glob(\"**/*\").reject { |f| File.file?(f) }\n      expect(folders).to contain_exactly(\"assets\", \"common\", \"locales\", \"mobile\")\n\n      files = Dir.glob(\"**/*\").reject { |f| File.directory?(f) }\n      expect(files).to contain_exactly(\"about.json\", \"assets/logo.png\", \"assets/other_logo.png\", \"common/body_tag.html\", \"locales/en.yml\", \"mobile/mobile.scss\", \"settings.yml\")\n\n      expect(JSON.parse(File.read('about.json')).deep_symbolize_keys).to eq(\n        \"name\": \"Header Icons\",\n        \"about_url\": \"abouturl\",\n        \"license_url\": \"licenseurl\",\n        \"component\": false,\n        \"assets\": {\n          \"logo\": \"assets/logo.png\",\n          \"other_logo\": \"assets/other_logo.png\"\n        },\n        \"authors\": \"David Taylor\",\n        \"minimum_discourse_version\": \"1.0.0\",\n        \"maximum_discourse_version\": \"3.0.0.beta1\",\n        \"theme_version\": \"1.0\",\n        \"color_schemes\": {\n          \"Orphan Color Scheme\": {\n            \"header_primary\": \"F0F0F0\",\n            \"header_background\": \"1E1E1E\",\n            \"tertiary\": \"858585\"\n          },\n          \"Theme Color Scheme\": {\n            \"header_primary\": \"F0F0F0\",\n            \"header_background\": \"1E1E1E\",\n            \"tertiary\": \"858585\"\n          }\n        },\n        \"modifiers\": {},\n        \"learn_more\": \"https://meta.discourse.org/t/beginners-guide-to-using-discourse-themes/91966\"\n      )\n\n      expect(File.read(\"common/body_tag.html\")).to eq(\"<b>testtheme1</b>\")\n      expect(File.read(\"mobile/mobile.scss\")).to eq(\"body {background-color: $background_color; font-size: $font-size}\")\n      expect(File.read(\"settings.yml\")).to eq(\"somesetting: #{rand_hex}\")\n      expect(File.read(\"locales/en.yml\")).to eq({ en: { key: \"value\" } }.deep_stringify_keys.to_yaml)\n\n      theme.update!(name: \"Discourse Header Icons\")\n      exporter = ThemeStore::ZipExporter.new(theme)\n      filename = exporter.package_filename\n      exporter.cleanup!\n      expect(filename).to end_with \"/discourse-header-icons.zip\"\n    end\n  end\n\n  it \"has safeguards to prevent writing outside the temp directory\" do\n    # Theme field names should be sanitized before writing to the database,\n    # but protection is in place 'just in case'\n    expect do\n      theme.set_field(target: :translations, name: SiteSetting.default_locale, value: \"hacked\")\n      ThemeField.any_instance.stubs(:file_path).returns(\"../../malicious\")\n      theme.save!\n      package\n    end.to raise_error(RuntimeError)\n  end\n\nend\n"], "fixing_code": ["# frozen_string_literal: true\n\nmodule Compression\n  class Engine\n    UnsupportedFileExtension = Class.new(StandardError)\n\n    def self.default_strategies\n      [\n        Compression::Zip.new,\n        Compression::Pipeline.new([Compression::Tar.new, Compression::Gzip.new]),\n        Compression::Gzip.new,\n        Compression::Tar.new\n      ]\n    end\n\n    def self.engine_for(filename, strategies: default_strategies)\n      strategy = strategies.detect(-> { raise UnsupportedFileExtension }) { |e| e.can_handle?(filename) }\n      new(strategy)\n    end\n\n    def initialize(strategy)\n      @strategy = strategy\n    end\n\n    delegate :extension, :decompress, :compress, to: :@strategy\n  end\nend\n", "# frozen_string_literal: true\n\nmodule Compression\n  class Gzip < Strategy\n    def extension\n      '.gz'\n    end\n\n    def compress(path, target_name)\n      gzip_target = sanitize_path(\"#{path}/#{target_name}\")\n      Discourse::Utils.execute_command('gzip', '-5', gzip_target, failure_message: \"Failed to gzip file.\")\n\n      \"#{gzip_target}.gz\"\n    end\n\n    private\n\n    def entries_of(compressed_file)\n      [compressed_file]\n    end\n\n    def is_file?(_)\n      true\n    end\n\n    def extract_folder(_entry, _entry_path); end\n\n    def get_compressed_file_stream(compressed_file_path)\n      gzip = Zlib::GzipReader.open(compressed_file_path)\n      yield(gzip)\n    end\n\n    def build_entry_path(dest_path, _, compressed_file_path)\n      basename = File.basename(compressed_file_path)\n      basename.gsub!(/#{Regexp.escape(extension)}$/, '')\n      File.join(dest_path, basename)\n    end\n\n    def decompression_results_path(dest_path, compressed_file_path)\n      build_entry_path(dest_path, nil, compressed_file_path)\n    end\n\n    def extract_file(entry, entry_path, available_size)\n      remaining_size = available_size\n\n      if ::File.exist?(entry_path)\n        raise ::Zip::DestinationFileExistsError,\n              \"Destination '#{entry_path}' already exists\"\n      end # Change this later.\n\n      ::File.open(entry_path, 'wb') do |os|\n        buf = ''.dup\n        while (buf = entry.read(chunk_size))\n          remaining_size -= chunk_size\n          raise ExtractFailed if remaining_size.negative?\n          os << buf\n        end\n      end\n\n      remaining_size\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nmodule Compression\n  class Pipeline < Strategy\n    def initialize(strategies)\n      @strategies = strategies\n    end\n\n    def extension\n      @strategies.reduce('') { |ext, strategy| ext += strategy.extension }\n    end\n\n    def compress(path, target_name)\n      current_target = target_name\n      @strategies.reduce('') do |compressed_path, strategy|\n        compressed_path = strategy.compress(path, current_target)\n        current_target = compressed_path.split('/').last\n\n        compressed_path\n      end\n    end\n\n    def decompress(dest_path, compressed_file_path, max_size)\n      @strategies.reverse.reduce(compressed_file_path) do |to_decompress, strategy|\n        next_compressed_file = strategy.decompress(dest_path, to_decompress, max_size)\n        FileUtils.rm_rf(to_decompress)\n        next_compressed_file\n      end\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nmodule Compression\n  class Strategy\n    ExtractFailed = Class.new(StandardError)\n    DestinationFileExistsError = Class.new(StandardError)\n\n    def can_handle?(file_name)\n      file_name.include?(extension)\n    end\n\n    def decompress(dest_path, compressed_file_path, max_size)\n      sanitized_compressed_file_path = sanitize_path(compressed_file_path)\n      sanitized_dest_path = sanitize_path(dest_path)\n\n      get_compressed_file_stream(sanitized_compressed_file_path) do |compressed_file|\n        available_size = calculate_available_size(max_size)\n\n        entries_of(compressed_file).each do |entry|\n          entry_path = build_entry_path(sanitized_dest_path, entry, sanitized_compressed_file_path)\n          if !is_safe_path_for_extraction?(entry_path, sanitized_dest_path)\n            next\n          end\n\n          FileUtils.mkdir_p(File.dirname(entry_path))\n          if is_file?(entry)\n            remaining_size = extract_file(entry, entry_path, available_size)\n            available_size = remaining_size\n          else\n            extract_folder(entry, entry_path)\n          end\n        end\n        decompression_results_path(sanitized_dest_path, sanitized_compressed_file_path)\n      end\n    end\n\n    private\n\n    def sanitize_path(filename)\n      Pathname.new(filename).realpath.to_s\n    end\n\n    # https://guides.rubyonrails.org/security.html#file-uploads\n    def sanitize_filename(filename)\n      filename.strip.tap do |name|\n        # NOTE: File.basename doesn't work right with Windows paths on Unix\n        # get only the filename, not the whole path\n        name.sub! /\\A.*(\\\\|\\/)/, ''\n        # Finally, replace all non alphanumeric, underscore\n        # or periods with underscore\n        name.gsub! /[^\\w\\.\\-]/, '_'\n      end\n    end\n\n    def calculate_available_size(max_size)\n      1024**2 * (max_size / 1.049) # Mb to Mib\n    end\n\n    def entries_of(compressed_file)\n      compressed_file\n    end\n\n    def is_file?(entry)\n      entry.file?\n    end\n\n    def chunk_size\n      @chunk_size ||= 1024**2 * 2 # 2MiB\n    end\n\n    def extract_file(entry, entry_path, available_size)\n      remaining_size = available_size\n\n      if ::File.exist?(entry_path)\n        raise DestinationFileExistsError, \"Destination '#{entry_path}' already exists\"\n      end\n\n      ::File.open(entry_path, 'wb') do |os|\n        while (buf = entry.read(chunk_size))\n          remaining_size -= buf.size\n          raise ExtractFailed if remaining_size.negative?\n          os << buf\n        end\n      end\n\n      remaining_size\n    end\n\n    def is_safe_path_for_extraction?(path, dest_directory)\n      File.expand_path(path).start_with?(dest_directory)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'rubygems/package'\n\nmodule Compression\n  class Tar < Strategy\n    def extension\n      '.tar'\n    end\n\n    def compress(path, target_name)\n      tar_filename = sanitize_filename(\"#{target_name}.tar\")\n      Discourse::Utils.execute_command('tar', '--create', '--file', tar_filename, target_name, failure_message: \"Failed to tar file.\")\n\n      sanitize_path(\"#{path}/#{tar_filename}\")\n    end\n\n    private\n\n    def extract_folder(_entry, _entry_path); end\n\n    def get_compressed_file_stream(compressed_file_path)\n      file_stream = IO.new(IO.sysopen(compressed_file_path))\n      tar_extract = Gem::Package::TarReader.new(file_stream)\n      tar_extract.rewind\n      yield(tar_extract)\n    end\n\n    def build_entry_path(dest_path, entry, _)\n      File.join(dest_path, entry.full_name)\n    end\n\n    def decompression_results_path(dest_path, _)\n      dest_path\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'zip'\n\nmodule Compression\n  class Zip < Strategy\n    def extension\n      '.zip'\n    end\n\n    def compress(path, target_name)\n      absolute_path = sanitize_path(\"#{path}/#{target_name}\")\n      zip_filename = \"#{absolute_path}.zip\"\n\n      ::Zip::File.open(zip_filename, ::Zip::File::CREATE) do |zipfile|\n        if File.directory?(absolute_path)\n          entries = Dir.entries(absolute_path) - %w[. ..]\n          write_entries(entries, absolute_path, '', zipfile)\n        else\n          put_into_archive(absolute_path, zipfile, target_name)\n        end\n      end\n\n      zip_filename\n    end\n\n    private\n\n    def extract_folder(entry, entry_path)\n      entry.extract(entry_path)\n    end\n\n    def get_compressed_file_stream(compressed_file_path)\n      zip_file = ::Zip::File.open(compressed_file_path)\n      yield(zip_file)\n    end\n\n    def build_entry_path(dest_path, entry, _)\n      File.join(dest_path, entry.name)\n    end\n\n    def decompression_results_path(dest_path, _)\n      dest_path\n    end\n\n    def extract_file(entry, entry_path, available_size)\n      remaining_size = available_size\n\n      if ::File.exist?(entry_path)\n        raise ::Zip::DestinationFileExistsError,\n              \"Destination '#{entry_path}' already exists\"\n      end\n\n      ::File.open(entry_path, 'wb') do |os|\n        entry.get_input_stream do |is|\n          entry.set_extra_attributes_on_path(entry_path)\n\n          buf = ''.dup\n          while (buf = is.sysread(chunk_size, buf))\n            remaining_size -= chunk_size\n            raise ExtractFailed if remaining_size.negative?\n            os << buf\n          end\n        end\n      end\n\n      remaining_size\n    end\n\n    # A helper method to make the recursion work.\n    def write_entries(entries, base_path, path, zipfile)\n      entries.each do |e|\n        zipfile_path = path == '' ? e : File.join(path, e)\n        disk_file_path = File.join(base_path, zipfile_path)\n\n        if File.directory? disk_file_path\n          recursively_deflate_directory(disk_file_path, zipfile, base_path, zipfile_path)\n        else\n          put_into_archive(disk_file_path, zipfile, zipfile_path)\n        end\n      end\n    end\n\n    def recursively_deflate_directory(disk_file_path, zipfile, base_path, zipfile_path)\n      zipfile.mkdir zipfile_path\n      subdir = Dir.entries(disk_file_path) - %w[. ..]\n      write_entries subdir, base_path, zipfile_path, zipfile\n    end\n\n    def put_into_archive(disk_file_path, zipfile, zipfile_path)\n      zipfile.add(zipfile_path, disk_file_path)\n    end\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'compression/engine'\n\nmodule ThemeStore; end\n\nclass ThemeStore::ZipImporter\n\n  attr_reader :url\n\n  def initialize(filename, original_filename)\n    @temp_folder = \"#{Pathname.new(Dir.tmpdir).realpath}/discourse_theme_#{SecureRandom.hex}\"\n    @filename = filename\n    @original_filename = original_filename\n  end\n\n  def import!\n    FileUtils.mkdir(@temp_folder)\n\n    available_size = SiteSetting.decompressed_theme_max_file_size_mb\n    Compression::Engine.engine_for(@original_filename).tap do |engine|\n      engine.decompress(@temp_folder, @filename, available_size)\n      strip_root_directory\n    end\n  rescue RuntimeError\n    raise RemoteTheme::ImportError, I18n.t(\"themes.import_error.unpack_failed\")\n  rescue Compression::Zip::ExtractFailed\n    raise RemoteTheme::ImportError, I18n.t(\"themes.import_error.file_too_big\")\n  end\n\n  def cleanup!\n    FileUtils.rm_rf(@temp_folder)\n  end\n\n  def version\n    \"\"\n  end\n\n  def strip_root_directory\n    root_files = Dir.glob(\"#{@temp_folder}/*\")\n    if root_files.size == 1 && File.directory?(root_files[0])\n      FileUtils.mv(Dir.glob(\"#{@temp_folder}/*/*\"), @temp_folder)\n    end\n  end\n\n  def real_path(relative)\n    fullpath = \"#{@temp_folder}/#{relative}\"\n    return nil unless File.exist?(fullpath)\n\n    # careful to handle symlinks here, don't want to expose random data\n    fullpath = Pathname.new(fullpath).realpath.to_s\n\n    if fullpath && fullpath.start_with?(@temp_folder)\n      fullpath\n    else\n      nil\n    end\n  end\n\n  def all_files\n    Dir.glob(\"**/**\", base: @temp_folder).reject { |f| File.directory?(File.join(@temp_folder, f)) }\n  end\n\n  def [](value)\n    fullpath = real_path(value)\n    return nil unless fullpath\n    File.read(fullpath)\n  end\n\nend\n", "# frozen_string_literal: true\n\nRSpec.describe Compression::Engine do\n  let(:available_size) { SiteSetting.decompressed_theme_max_file_size_mb }\n  let(:folder_name) { 'test' }\n  let(:temp_folder) do\n    path = \"#{Pathname.new(Dir.tmpdir).realpath}/#{SecureRandom.hex}\"\n    FileUtils.mkdir(path)\n    path\n  end\n\n  before do\n    Dir.chdir(temp_folder) do\n      FileUtils.mkdir_p(\"#{folder_name}/a\")\n      File.write(\"#{folder_name}/hello.txt\", 'hello world')\n      File.write(\"#{folder_name}/a/inner\", 'hello world inner')\n    end\n  end\n\n  after { FileUtils.rm_rf(temp_folder) }\n\n  it 'raises an exception when the file is not supported' do\n    unknown_extension = 'a_file.crazyext'\n    expect { described_class.engine_for(unknown_extension) }.to raise_error Compression::Engine::UnsupportedFileExtension\n  end\n\n  describe 'compressing and decompressing files' do\n    before do\n      Dir.chdir(temp_folder) do\n        @compressed_path = Compression::Engine.engine_for(\"#{folder_name}#{extension}\").compress(temp_folder, folder_name)\n        FileUtils.rm_rf(\"#{folder_name}/\")\n      end\n    end\n\n    context 'when working with zip files' do\n      let(:extension) { '.zip' }\n\n      it 'decompresses the folder and inspects files correctly' do\n        engine = described_class.engine_for(@compressed_path)\n\n        extract_location = \"#{temp_folder}/extract_location\"\n        FileUtils.mkdir(extract_location)\n        engine.decompress(extract_location, \"#{temp_folder}/#{folder_name}.zip\", available_size)\n\n        expect(read_file(\"extract_location/hello.txt\")).to eq(\"hello world\")\n        expect(read_file(\"extract_location/a/inner\")).to eq(\"hello world inner\")\n      end\n\n      it \"doesn't allow files to be extracted outside the target directory\" do\n        FileUtils.rm_rf(temp_folder)\n        FileUtils.mkdir(temp_folder)\n\n        zip_file = \"#{temp_folder}/theme.zip\"\n        Zip::File.open(zip_file, create: true) do |zipfile|\n          zipfile.get_output_stream(\"child-file\") do |f|\n            f.puts(\"child file\")\n          end\n          zipfile.get_output_stream(\"../escape-decompression-folder.txt\") do |f|\n            f.puts(\"file that attempts to escape the decompression destination directory\")\n          end\n          zipfile.mkdir(\"child-dir\")\n          zipfile.get_output_stream(\"child-dir/grandchild-file\") do |f|\n            f.puts(\"grandchild file\")\n          end\n        end\n\n        extract_location = \"#{temp_folder}/extract_location\"\n        FileUtils.mkdir(extract_location)\n        engine = described_class.engine_for(zip_file)\n        engine.decompress(extract_location, zip_file, available_size)\n        Dir.chdir(temp_folder) do\n          expect(Dir.glob(\"**/*\")).to contain_exactly(\n            \"extract_location\",\n            \"extract_location/child-file\",\n            \"extract_location/child-dir\",\n            \"extract_location/child-dir/grandchild-file\",\n            \"theme.zip\"\n          )\n        end\n      end\n\n      it \"decompresses into symlinked directory\" do\n        real_location = \"#{temp_folder}/extract_location\"\n        extract_location = \"#{temp_folder}/is/symlinked\"\n\n        FileUtils.mkdir(real_location)\n        FileUtils.mkdir_p(extract_location)\n        extract_location = \"#{extract_location}/extract_location\"\n        FileUtils.symlink(real_location, extract_location)\n\n        engine = described_class.engine_for(@compressed_path)\n        engine.decompress(extract_location, \"#{temp_folder}/#{folder_name}.zip\", available_size)\n\n        expect(File.realpath(extract_location)).to eq(real_location)\n        expect(read_file(\"is/symlinked/extract_location/hello.txt\")).to eq(\"hello world\")\n        expect(read_file(\"is/symlinked/extract_location/a/inner\")).to eq(\"hello world inner\")\n      end\n    end\n\n    context 'when working with .tar.gz files' do\n      let(:extension) { '.tar.gz' }\n\n      it 'decompresses the folder and inspects files correctly' do\n        engine = described_class.engine_for(@compressed_path)\n\n        engine.decompress(temp_folder, \"#{temp_folder}/#{folder_name}.tar.gz\", available_size)\n\n        expect(read_file(\"test/hello.txt\")).to eq(\"hello world\")\n        expect(read_file(\"test/a/inner\")).to eq(\"hello world inner\")\n      end\n\n      it \"doesn't allow files to be extracted outside the target directory\" do\n        FileUtils.rm_rf(temp_folder)\n        FileUtils.mkdir(temp_folder)\n\n        tar_file = \"#{temp_folder}/theme.tar\"\n        File.open(tar_file, \"wb\") do |file|\n          Gem::Package::TarWriter.new(file) do |tar|\n            tar.add_file(\"child-file\", 644) do |tf|\n              tf.write(\"child file\")\n            end\n            tar.add_file(\"../escape-extraction-folder\", 644) do |tf|\n              tf.write(\"file that attempts to escape the decompression destination directory\")\n            end\n            tar.mkdir(\"child-dir\", 755)\n            tar.add_file(\"child-dir/grandchild-file\", 644) do |tf|\n              tf.write(\"grandchild file\")\n            end\n          end\n        end\n        tar_gz_file = \"#{temp_folder}/theme.tar.gz\"\n        Zlib::GzipWriter.open(tar_gz_file) do |gz|\n          gz.orig_name = tar_file\n          gz.write(File.binread(tar_file))\n        end\n        FileUtils.rm(tar_file)\n\n        extract_location = \"#{temp_folder}/extract_location\"\n        FileUtils.mkdir(extract_location)\n        engine = described_class.engine_for(tar_gz_file)\n        engine.decompress(extract_location, tar_gz_file, available_size)\n        Dir.chdir(temp_folder) do\n          expect(Dir.glob(\"**/*\")).to contain_exactly(\n            \"extract_location\",\n            \"extract_location/child-file\",\n            \"extract_location/child-dir\",\n            \"extract_location/child-dir/grandchild-file\",\n          )\n        end\n      end\n\n      it \"decompresses into symlinked directory\" do\n        real_location = \"#{temp_folder}/extract_location\"\n        extract_location = \"#{temp_folder}/is/symlinked\"\n\n        FileUtils.mkdir(real_location)\n        FileUtils.mkdir_p(extract_location)\n        extract_location = \"#{extract_location}/extract_location\"\n        FileUtils.symlink(real_location, extract_location)\n\n        engine = described_class.engine_for(@compressed_path)\n        engine.decompress(extract_location, \"#{temp_folder}/#{folder_name}.tar.gz\", available_size)\n\n        expect(File.realpath(extract_location)).to eq(real_location)\n        expect(read_file(\"is/symlinked/extract_location/test/hello.txt\")).to eq(\"hello world\")\n        expect(read_file(\"is/symlinked/extract_location/test/a/inner\")).to eq(\"hello world inner\")\n      end\n    end\n\n    context 'when working with .tar files' do\n      let(:extension) { '.tar' }\n\n      it 'decompress the folder and inspect files correctly' do\n        engine = described_class.engine_for(@compressed_path)\n\n        engine.decompress(temp_folder, \"#{temp_folder}/#{folder_name}.tar\", available_size)\n\n        expect(read_file(\"test/hello.txt\")).to eq(\"hello world\")\n        expect(read_file(\"test/a/inner\")).to eq(\"hello world inner\")\n      end\n    end\n  end\n\n  def read_file(relative_path)\n    File.read(\"#{temp_folder}/#{relative_path}\")\n  end\nend\n", "# frozen_string_literal: true\n\nrequire 'theme_store/zip_exporter'\n\nRSpec.describe ThemeStore::ZipExporter do\n  let(:rand_hex) do\n    +\"X\" << SecureRandom.hex\n  end\n  let!(:theme) do\n    Fabricate(:theme, name: \"Header Icons\").tap do |theme|\n      theme.set_field(target: :common, name: :body_tag, value: \"<b>testtheme1</b>\")\n      theme.set_field(target: :settings, name: :yaml, value: \"somesetting: #{rand_hex}\")\n      theme.set_field(target: :mobile, name: :scss, value: 'body {background-color: $background_color; font-size: $font-size}')\n      theme.set_field(target: :translations, name: :en, value: { en: { key: \"value\" } }.deep_stringify_keys.to_yaml)\n      image = file_from_fixtures(\"logo.png\")\n      upload = UploadCreator.new(image, \"logo.png\").create_for(Discourse::SYSTEM_USER_ID)\n      theme.set_field(target: :common, name: :logo, upload_id: upload.id, type: :theme_upload_var)\n      image = file_from_fixtures(\"logo.png\")\n      _other_upload = UploadCreator.new(image, \"logo.png\").create_for(Discourse::SYSTEM_USER_ID)\n      theme.set_field(target: :common, name: \"other_logo\", upload_id: upload.id, type: :theme_upload_var)\n      theme.build_remote_theme(remote_url: \"\", about_url: \"abouturl\", license_url: \"licenseurl\",\n                               authors: \"David Taylor\", theme_version: \"1.0\", minimum_discourse_version: \"1.0.0\",\n                               maximum_discourse_version: \"3.0.0.beta1\")\n\n      cs1 = Fabricate(:color_scheme, name: 'Orphan Color Scheme', color_scheme_colors: [\n        Fabricate(:color_scheme_color, name: 'header_primary',  hex: 'F0F0F0'),\n        Fabricate(:color_scheme_color, name: 'header_background', hex: '1E1E1E'),\n        Fabricate(:color_scheme_color, name: 'tertiary', hex: '858585')\n      ])\n\n      cs2 = Fabricate(:color_scheme, name: 'Theme Color Scheme', color_scheme_colors: [\n        Fabricate(:color_scheme_color, name: 'header_primary',  hex: 'F0F0F0'),\n        Fabricate(:color_scheme_color, name: 'header_background', hex: '1E1E1E'),\n        Fabricate(:color_scheme_color, name: 'tertiary', hex: '858585')\n      ])\n\n      theme.color_scheme = cs1\n      cs2.update(theme_id: theme.id)\n\n      theme.save!\n    end\n  end\n\n  let(:dir) do\n    tmpdir = Dir.tmpdir\n    dir = \"#{tmpdir}/#{SecureRandom.hex}\"\n    FileUtils.mkdir(dir)\n    dir\n  end\n\n  after do\n    FileUtils.rm_rf(dir)\n  end\n\n  let(:package) do\n    exporter = ThemeStore::ZipExporter.new(theme)\n    filename = exporter.package_filename\n    FileUtils.cp(filename, dir)\n    exporter.cleanup!\n    \"#{dir}/discourse-header-icons.zip\"\n  end\n\n  it \"exports the theme correctly\" do\n    package\n    file = 'discourse-header-icons.zip'\n    Dir.chdir(dir) do\n      available_size = SiteSetting.decompressed_theme_max_file_size_mb\n      Compression::Zip.new.decompress(dir, file, available_size)\n      `rm #{file}`\n\n      folders = Dir.glob(\"**/*\").reject { |f| File.file?(f) }\n      expect(folders).to contain_exactly(\"assets\", \"common\", \"locales\", \"mobile\")\n\n      files = Dir.glob(\"**/*\").reject { |f| File.directory?(f) }\n      expect(files).to contain_exactly(\"about.json\", \"assets/logo.png\", \"assets/other_logo.png\", \"common/body_tag.html\", \"locales/en.yml\", \"mobile/mobile.scss\", \"settings.yml\")\n\n      expect(JSON.parse(File.read('about.json')).deep_symbolize_keys).to eq(\n        \"name\": \"Header Icons\",\n        \"about_url\": \"abouturl\",\n        \"license_url\": \"licenseurl\",\n        \"component\": false,\n        \"assets\": {\n          \"logo\": \"assets/logo.png\",\n          \"other_logo\": \"assets/other_logo.png\"\n        },\n        \"authors\": \"David Taylor\",\n        \"minimum_discourse_version\": \"1.0.0\",\n        \"maximum_discourse_version\": \"3.0.0.beta1\",\n        \"theme_version\": \"1.0\",\n        \"color_schemes\": {\n          \"Orphan Color Scheme\": {\n            \"header_primary\": \"F0F0F0\",\n            \"header_background\": \"1E1E1E\",\n            \"tertiary\": \"858585\"\n          },\n          \"Theme Color Scheme\": {\n            \"header_primary\": \"F0F0F0\",\n            \"header_background\": \"1E1E1E\",\n            \"tertiary\": \"858585\"\n          }\n        },\n        \"modifiers\": {},\n        \"learn_more\": \"https://meta.discourse.org/t/beginners-guide-to-using-discourse-themes/91966\"\n      )\n\n      expect(File.read(\"common/body_tag.html\")).to eq(\"<b>testtheme1</b>\")\n      expect(File.read(\"mobile/mobile.scss\")).to eq(\"body {background-color: $background_color; font-size: $font-size}\")\n      expect(File.read(\"settings.yml\")).to eq(\"somesetting: #{rand_hex}\")\n      expect(File.read(\"locales/en.yml\")).to eq({ en: { key: \"value\" } }.deep_stringify_keys.to_yaml)\n\n      theme.update!(name: \"Discourse Header Icons\")\n      exporter = ThemeStore::ZipExporter.new(theme)\n      filename = exporter.package_filename\n      exporter.cleanup!\n      expect(filename).to end_with \"/discourse-header-icons.zip\"\n    end\n  end\n\n  it \"has safeguards to prevent writing outside the temp directory\" do\n    # Theme field names should be sanitized before writing to the database,\n    # but protection is in place 'just in case'\n    expect do\n      theme.set_field(target: :translations, name: SiteSetting.default_locale, value: \"hacked\")\n      ThemeField.any_instance.stubs(:file_path).returns(\"../../malicious\")\n      theme.save!\n      package\n    end.to raise_error(RuntimeError)\n  end\n\nend\n"], "filenames": ["lib/compression/engine.rb", "lib/compression/gzip.rb", "lib/compression/pipeline.rb", "lib/compression/strategy.rb", "lib/compression/tar.rb", "lib/compression/zip.rb", "lib/theme_store/zip_importer.rb", "spec/lib/compression/engine_spec.rb", "spec/lib/theme_store/zip_exporter_spec.rb"], "buggy_code_start_loc": [25, 33, 23, 12, 29, 38, 23, 4, 68], "buggy_code_end_loc": [26, 35, 28, 94, 33, 49, 36, 75, 69], "fixing_code_start_loc": [25, 33, 23, 12, 29, 38, 23, 5, 68], "fixing_code_end_loc": [26, 41, 28, 92, 35, 44, 44, 186, 69], "type": "CWE-434", "message": "Discourse is an open source discussion platform. In versions prior to 2.8.9 on the `stable` branch and prior to 2.9.0.beta10 on the `beta` and `tests-passed` branches, admins can upload a maliciously crafted Zip or Gzip Tar archive to write files at arbitrary locations and trigger remote code execution. The problem is patched in version 2.8.9 on the `stable` branch and version 2.9.0.beta10 on the `beta` and `tests-passed` branches. There are no known workarounds.", "other": {"cve": {"id": "CVE-2022-36066", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-29T20:15:09.747", "lastModified": "2022-10-06T19:07:04.313", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Discourse is an open source discussion platform. In versions prior to 2.8.9 on the `stable` branch and prior to 2.9.0.beta10 on the `beta` and `tests-passed` branches, admins can upload a maliciously crafted Zip or Gzip Tar archive to write files at arbitrary locations and trigger remote code execution. The problem is patched in version 2.8.9 on the `stable` branch and version 2.9.0.beta10 on the `beta` and `tests-passed` branches. There are no known workarounds."}, {"lang": "es", "value": "Discourse es una plataforma de debate de c\u00f3digo abierto. En versiones anteriores a 2.8.9 en la rama \"stable\" y anteriores a 2.9.0.beta10 en las ramas \"beta\" y \"tests-passed\", los administradores pueden descargar un archivo Zip o Gzip Tar dise\u00f1ado de forma maliciosa para escribir archivos en ubicaciones arbitrarias y desencadenar una ejecuci\u00f3n de c\u00f3digo remota. El problema est\u00e1 parcheado en versi\u00f3n 2.8.9 en la rama \"stable\" y en versi\u00f3n 2.9.0.beta10 en las ramas \"beta\" y \"tests-passed\". No se presentan mitigaciones conocidas"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:C/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.1, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 2.3, "impactScore": 6.0}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-434"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.8.9", "matchCriteriaId": "3BC8F74E-6BEF-4A8C-AF34-A0FC24A1EDFE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "B3803EF9-A296-42B7-887F-93C5E68E94C4"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta2:*:*:*:*:*:*", "matchCriteriaId": "8BA3D313-3C11-43E2-A47D-CBB532D1B6F8"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta3:*:*:*:*:*:*", "matchCriteriaId": "6F42673E-65F3-4807-9484-20CB747420FB"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta4:*:*:*:*:*:*", "matchCriteriaId": "0B91D023-FCE5-4866-AD8B-BBB675763104"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta5:*:*:*:*:*:*", "matchCriteriaId": "0086484D-0164-449C-8AAE-BE7479CB9706"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta6:*:*:*:*:*:*", "matchCriteriaId": "F9D1B031-96C7-44C0-A0A0-F67ABE55C93C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta7:*:*:*:*:*:*", "matchCriteriaId": "750D2AD9-35E7-4AC7-9C22-AA90DAA34F3F"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta8:*:*:*:*:*:*", "matchCriteriaId": "B68E308A-BDAB-4614-A563-4460F7996CBE"}, {"vulnerable": true, "criteria": "cpe:2.3:a:discourse:discourse:2.9.0:beta9:*:*:*:*:*:*", "matchCriteriaId": "5DEDE4C5-2C2A-4B74-BB41-8AAA0EE636E2"}]}]}], "references": [{"url": "https://github.com/discourse/discourse/commit/b27d5626d208a22c516a0adfda7554b67b493835", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/pull/18421", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/discourse/discourse/security/advisories/GHSA-grvh-qcpg-hfmv", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/discourse/discourse/commit/b27d5626d208a22c516a0adfda7554b67b493835"}}