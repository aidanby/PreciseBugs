{"buggy_code": ["'use strict';\n\nconst _ = require('lodash');\nconst assert = require('assert');\nconst path = require('path');\nconst fs = require('fs');\nconst SwaggerParser = require('@apidevtools/swagger-parser');\nconst request = require('request-promise-native');\nconst nconf = require('nconf');\nconst jwt = require('jsonwebtoken');\nconst util = require('util');\n\nconst wait = util.promisify(setTimeout);\n\nconst db = require('./mocks/databasemock');\nconst helpers = require('./helpers');\nconst meta = require('../src/meta');\nconst user = require('../src/user');\nconst groups = require('../src/groups');\nconst categories = require('../src/categories');\nconst topics = require('../src/topics');\nconst posts = require('../src/posts');\nconst plugins = require('../src/plugins');\nconst flags = require('../src/flags');\nconst messaging = require('../src/messaging');\nconst utils = require('../src/utils');\n\ndescribe('API', async () => {\n\tlet readApi = false;\n\tlet writeApi = false;\n\tconst readApiPath = path.resolve(__dirname, '../public/openapi/read.yaml');\n\tconst writeApiPath = path.resolve(__dirname, '../public/openapi/write.yaml');\n\tlet jar;\n\tlet csrfToken;\n\tlet setup = false;\n\tconst unauthenticatedRoutes = ['/api/login', '/api/register']; // Everything else will be called with the admin user\n\n\tconst mocks = {\n\t\thead: {},\n\t\tget: {\n\t\t\t'/api/email/unsubscribe/{token}': [\n\t\t\t\t{\n\t\t\t\t\tin: 'path',\n\t\t\t\t\tname: 'token',\n\t\t\t\t\texample: (() => jwt.sign({\n\t\t\t\t\t\ttemplate: 'digest',\n\t\t\t\t\t\tuid: 1,\n\t\t\t\t\t}, nconf.get('secret')))(),\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t\tpost: {},\n\t\tput: {},\n\t\tdelete: {\n\t\t\t'/users/{uid}/tokens/{token}': [\n\t\t\t\t{\n\t\t\t\t\tin: 'path',\n\t\t\t\t\tname: 'uid',\n\t\t\t\t\texample: 1,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tin: 'path',\n\t\t\t\t\tname: 'token',\n\t\t\t\t\texample: utils.generateUUID(),\n\t\t\t\t},\n\t\t\t],\n\t\t\t'/users/{uid}/sessions/{uuid}': [\n\t\t\t\t{\n\t\t\t\t\tin: 'path',\n\t\t\t\t\tname: 'uid',\n\t\t\t\t\texample: 1,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tin: 'path',\n\t\t\t\t\tname: 'uuid',\n\t\t\t\t\texample: '', // to be defined below...\n\t\t\t\t},\n\t\t\t],\n\t\t\t'/posts/{pid}/diffs/{timestamp}': [\n\t\t\t\t{\n\t\t\t\t\tin: 'path',\n\t\t\t\t\tname: 'pid',\n\t\t\t\t\texample: '', // to be defined below...\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tin: 'path',\n\t\t\t\t\tname: 'timestamp',\n\t\t\t\t\texample: '', // to be defined below...\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t};\n\n\tasync function dummySearchHook(data) {\n\t\treturn [1];\n\t}\n\tasync function dummyEmailerHook(data) {\n\t\t// pretend to handle sending emails\n\t}\n\n\tafter(async () => {\n\t\tplugins.hooks.unregister('core', 'filter:search.query', dummySearchHook);\n\t\tplugins.hooks.unregister('emailer-test', 'filter:email.send');\n\t});\n\n\tasync function setupData() {\n\t\tif (setup) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Create sample users\n\t\tconst adminUid = await user.create({ username: 'admin', password: '123456', email: 'test@example.org' });\n\t\tconst unprivUid = await user.create({ username: 'unpriv', password: '123456', email: 'unpriv@example.org' });\n\t\tawait user.setUserField(adminUid, 'email', 'test@example.org');\n\t\tawait user.setUserField(unprivUid, 'email', 'unpriv@example.org');\n\t\tawait user.email.confirmByUid(adminUid);\n\t\tawait user.email.confirmByUid(unprivUid);\n\n\t\tfor (let x = 0; x < 4; x++) {\n\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\tawait user.create({ username: 'deleteme', password: '123456' }); // for testing of DELETE /users (uids 5, 6) and DELETE /user/:uid/account (uid 7)\n\t\t}\n\t\tawait groups.join('administrators', adminUid);\n\n\t\t// Create sample group\n\t\tawait groups.create({\n\t\t\tname: 'Test Group',\n\t\t});\n\n\t\tawait meta.settings.set('core.api', {\n\t\t\ttokens: [{\n\t\t\t\ttoken: mocks.delete['/users/{uid}/tokens/{token}'][1].example,\n\t\t\t\tuid: 1,\n\t\t\t\tdescription: 'for testing of token deletion route',\n\t\t\t\ttimestamp: Date.now(),\n\t\t\t}],\n\t\t});\n\t\tmeta.config.allowTopicsThumbnail = 1;\n\t\tmeta.config.termsOfUse = 'I, for one, welcome our new test-driven overlords';\n\t\tmeta.config.chatMessageDelay = 0;\n\n\t\t// Create a category\n\t\tconst testCategory = await categories.create({ name: 'test' });\n\n\t\t// Post a new topic\n\t\tawait topics.post({\n\t\t\tuid: adminUid,\n\t\t\tcid: testCategory.cid,\n\t\t\ttitle: 'Test Topic',\n\t\t\tcontent: 'Test topic content',\n\t\t});\n\t\tconst unprivTopic = await topics.post({\n\t\t\tuid: unprivUid,\n\t\t\tcid: testCategory.cid,\n\t\t\ttitle: 'Test Topic 2',\n\t\t\tcontent: 'Test topic 2 content',\n\t\t});\n\t\tawait topics.post({\n\t\t\tuid: unprivUid,\n\t\t\tcid: testCategory.cid,\n\t\t\ttitle: 'Test Topic 3',\n\t\t\tcontent: 'Test topic 3 content',\n\t\t});\n\n\t\t// Create a post diff\n\t\tawait posts.edit({\n\t\t\tuid: adminUid,\n\t\t\tpid: unprivTopic.postData.pid,\n\t\t\tcontent: 'Test topic 2 edited content',\n\t\t\treq: {},\n\t\t});\n\t\tmocks.delete['/posts/{pid}/diffs/{timestamp}'][0].example = unprivTopic.postData.pid;\n\t\tmocks.delete['/posts/{pid}/diffs/{timestamp}'][1].example = (await posts.diffs.list(unprivTopic.postData.pid))[0];\n\n\t\t// Create a sample flag\n\t\tconst { flagId } = await flags.create('post', 1, unprivUid, 'sample reasons', Date.now()); // deleted in DELETE /api/v3/flags/1\n\t\tawait flags.appendNote(flagId, 1, 'test note', 1626446956652);\n\t\tawait flags.create('post', 2, unprivUid, 'sample reasons', Date.now()); // for testing flag notes (since flag 1 deleted)\n\n\t\t// Create a new chat room\n\t\tawait messaging.newRoom(1, [2]);\n\n\t\t// Create an empty file to test DELETE /files and thumb deletion\n\t\tfs.closeSync(fs.openSync(path.resolve(nconf.get('upload_path'), 'files/test.txt'), 'w'));\n\t\tfs.closeSync(fs.openSync(path.resolve(nconf.get('upload_path'), 'files/test.png'), 'w'));\n\n\t\t// Associate thumb with topic to test thumb reordering\n\t\tawait topics.thumbs.associate({\n\t\t\tid: 2,\n\t\t\tpath: 'files/test.png',\n\t\t});\n\n\t\tconst socketUser = require('../src/socket.io/user');\n\t\tconst socketAdmin = require('../src/socket.io/admin');\n\t\t// export data for admin user\n\t\tawait socketUser.exportProfile({ uid: adminUid }, { uid: adminUid });\n\t\tawait wait(2000);\n\t\tawait socketUser.exportPosts({ uid: adminUid }, { uid: adminUid });\n\t\tawait wait(2000);\n\t\tawait socketUser.exportUploads({ uid: adminUid }, { uid: adminUid });\n\t\tawait wait(2000);\n\t\tawait socketAdmin.user.exportUsersCSV({ uid: adminUid }, {});\n\t\t// wait for export child process to complete\n\t\tawait wait(5000);\n\n\t\t// Attach a search hook so /api/search is enabled\n\t\tplugins.hooks.register('core', {\n\t\t\thook: 'filter:search.query',\n\t\t\tmethod: dummySearchHook,\n\t\t});\n\t\t// Attach an emailer hook so related requests do not error\n\t\tplugins.hooks.register('emailer-test', {\n\t\t\thook: 'filter:email.send',\n\t\t\tmethod: dummyEmailerHook,\n\t\t});\n\n\t\t// All tests run as admin user\n\t\t({ jar } = await helpers.loginUser('admin', '123456'));\n\n\t\t// Retrieve CSRF token using cookie, to test Write API\n\t\tconst config = await request({\n\t\t\turl: `${nconf.get('url')}/api/config`,\n\t\t\tjson: true,\n\t\t\tjar: jar,\n\t\t});\n\t\tcsrfToken = config.csrf_token;\n\n\t\tsetup = true;\n\t}\n\n\tit('should pass OpenAPI v3 validation', async () => {\n\t\ttry {\n\t\t\tawait SwaggerParser.validate(readApiPath);\n\t\t\tawait SwaggerParser.validate(writeApiPath);\n\t\t} catch (e) {\n\t\t\tassert.ifError(e);\n\t\t}\n\t});\n\n\treadApi = await SwaggerParser.dereference(readApiPath);\n\twriteApi = await SwaggerParser.dereference(writeApiPath);\n\n\tit('should grab all mounted routes and ensure a schema exists', async () => {\n\t\tconst webserver = require('../src/webserver');\n\t\tconst buildPaths = function (stack, prefix) {\n\t\t\tconst paths = stack.map((dispatch) => {\n\t\t\t\tif (dispatch.route && dispatch.route.path && typeof dispatch.route.path === 'string') {\n\t\t\t\t\tif (!prefix && !dispatch.route.path.startsWith('/api/')) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (prefix === nconf.get('relative_path')) {\n\t\t\t\t\t\tprefix = '';\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tmethod: Object.keys(dispatch.route.methods)[0],\n\t\t\t\t\t\tpath: (prefix || '') + dispatch.route.path,\n\t\t\t\t\t};\n\t\t\t\t} else if (dispatch.name === 'router') {\n\t\t\t\t\tconst prefix = dispatch.regexp.toString().replace('/^', '').replace('\\\\/?(?=\\\\/|$)/i', '').replace(/\\\\\\//g, '/');\n\t\t\t\t\treturn buildPaths(dispatch.handle.stack, prefix);\n\t\t\t\t}\n\n\t\t\t\t// Drop any that aren't actual routes (middlewares, error handlers, etc.)\n\t\t\t\treturn null;\n\t\t\t});\n\n\t\t\treturn _.flatten(paths);\n\t\t};\n\n\t\tlet paths = buildPaths(webserver.app._router.stack).filter(Boolean).map((pathObj) => {\n\t\t\tpathObj.path = pathObj.path.replace(/\\/:([^\\\\/]+)/g, '/{$1}');\n\t\t\treturn pathObj;\n\t\t});\n\t\tconst exclusionPrefixes = [\n\t\t\t'/api/admin/plugins', '/api/compose', '/debug',\n\t\t\t'/api/user/{userslug}/theme', // from persona\n\t\t];\n\t\tpaths = paths.filter(path => path.method !== '_all' && !exclusionPrefixes.some(prefix => path.path.startsWith(prefix)));\n\n\n\t\t// For each express path, query for existence in read and write api schemas\n\t\tpaths.forEach((pathObj) => {\n\t\t\tdescribe(`${pathObj.method.toUpperCase()} ${pathObj.path}`, () => {\n\t\t\t\tit('should be defined in schema docs', () => {\n\t\t\t\t\tlet schema = readApi;\n\t\t\t\t\tif (pathObj.path.startsWith('/api/v3')) {\n\t\t\t\t\t\tschema = writeApi;\n\t\t\t\t\t\tpathObj.path = pathObj.path.replace('/api/v3', '');\n\t\t\t\t\t}\n\n\t\t\t\t\t// Don't check non-GET routes in Read API\n\t\t\t\t\tif (schema === readApi && pathObj.method !== 'get') {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst normalizedPath = pathObj.path.replace(/\\/:([^\\\\/]+)/g, '/{$1}').replace(/\\?/g, '');\n\t\t\t\t\tassert(schema.paths.hasOwnProperty(normalizedPath), `${pathObj.path} is not defined in schema docs`);\n\t\t\t\t\tassert(schema.paths[normalizedPath].hasOwnProperty(pathObj.method), `${pathObj.path} was found in schema docs, but ${pathObj.method.toUpperCase()} method is not defined`);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\t// generateTests(readApi, Object.keys(readApi.paths));\n\tgenerateTests(writeApi, Object.keys(writeApi.paths), writeApi.servers[0].url);\n\n\tfunction generateTests(api, paths, prefix) {\n\t\t// Iterate through all documented paths, make a call to it,\n\t\t// and compare the result body with what is defined in the spec\n\t\tconst pathLib = path; // for calling path module from inside this forEach\n\t\tpaths.forEach((path) => {\n\t\t\tconst context = api.paths[path];\n\t\t\tlet schema;\n\t\t\tlet response;\n\t\t\tlet url;\n\t\t\tlet method;\n\t\t\tconst headers = {};\n\t\t\tconst qs = {};\n\n\t\t\tObject.keys(context).forEach((_method) => {\n\t\t\t\t// Only test GET routes in the Read API\n\t\t\t\tif (api.info.title === 'NodeBB Read API' && _method !== 'get') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tit('should have each path parameter defined in its context', () => {\n\t\t\t\t\tmethod = _method;\n\t\t\t\t\tif (!context[method].parameters) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst pathParams = (path.match(/{[\\w\\-_*]+}?/g) || []).map(match => match.slice(1, -1));\n\t\t\t\t\tconst schemaParams = context[method].parameters.map(param => (param.in === 'path' ? param.name : null)).filter(Boolean);\n\t\t\t\t\tassert(pathParams.every(param => schemaParams.includes(param)), `${method.toUpperCase()} ${path} has path parameters specified but not defined`);\n\t\t\t\t});\n\n\t\t\t\tit('should have examples when parameters are present', () => {\n\t\t\t\t\tlet { parameters } = context[method];\n\t\t\t\t\tlet testPath = path;\n\n\t\t\t\t\tif (parameters) {\n\t\t\t\t\t\t// Use mock data if provided\n\t\t\t\t\t\tparameters = mocks[method][path] || parameters;\n\n\t\t\t\t\t\tparameters.forEach((param) => {\n\t\t\t\t\t\t\tassert(param.example !== null && param.example !== undefined, `${method.toUpperCase()} ${path} has parameters without examples`);\n\n\t\t\t\t\t\t\tswitch (param.in) {\n\t\t\t\t\t\t\t\tcase 'path':\n\t\t\t\t\t\t\t\t\ttestPath = testPath.replace(`{${param.name}}`, param.example);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'header':\n\t\t\t\t\t\t\t\t\theaders[param.name] = param.example;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'query':\n\t\t\t\t\t\t\t\t\tqs[param.name] = param.example;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\turl = nconf.get('url') + (prefix || '') + testPath;\n\t\t\t\t});\n\n\t\t\t\tit('should contain a valid request body (if present) with application/json or multipart/form-data type if POST/PUT/DELETE', () => {\n\t\t\t\t\tif (['post', 'put', 'delete'].includes(method) && context[method].hasOwnProperty('requestBody')) {\n\t\t\t\t\t\tconst failMessage = `${method.toUpperCase()} ${path} has a malformed request body`;\n\t\t\t\t\t\tassert(context[method].requestBody, failMessage);\n\t\t\t\t\t\tassert(context[method].requestBody.content, failMessage);\n\n\t\t\t\t\t\tif (context[method].requestBody.content.hasOwnProperty('application/json')) {\n\t\t\t\t\t\t\tassert(context[method].requestBody.content['application/json'], failMessage);\n\t\t\t\t\t\t\tassert(context[method].requestBody.content['application/json'].schema, failMessage);\n\t\t\t\t\t\t\tassert(context[method].requestBody.content['application/json'].schema.properties, failMessage);\n\t\t\t\t\t\t} else if (context[method].requestBody.content.hasOwnProperty('multipart/form-data')) {\n\t\t\t\t\t\t\tassert(context[method].requestBody.content['multipart/form-data'], failMessage);\n\t\t\t\t\t\t\tassert(context[method].requestBody.content['multipart/form-data'].schema, failMessage);\n\t\t\t\t\t\t\tassert(context[method].requestBody.content['multipart/form-data'].schema.properties, failMessage);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tit('should not error out when called', async () => {\n\t\t\t\t\tawait setupData();\n\n\t\t\t\t\tif (csrfToken) {\n\t\t\t\t\t\theaders['x-csrf-token'] = csrfToken;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet body = {};\n\t\t\t\t\tlet type = 'json';\n\t\t\t\t\tif (context[method].hasOwnProperty('requestBody') && context[method].requestBody.content['application/json']) {\n\t\t\t\t\t\tbody = buildBody(context[method].requestBody.content['application/json'].schema.properties);\n\t\t\t\t\t} else if (context[method].hasOwnProperty('requestBody') && context[method].requestBody.content['multipart/form-data']) {\n\t\t\t\t\t\ttype = 'form';\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (type === 'json') {\n\t\t\t\t\t\t\tresponse = await request(url, {\n\t\t\t\t\t\t\t\tmethod: method,\n\t\t\t\t\t\t\t\tjar: !unauthenticatedRoutes.includes(path) ? jar : undefined,\n\t\t\t\t\t\t\t\tjson: true,\n\t\t\t\t\t\t\t\tfollowRedirect: false, // all responses are significant (e.g. 302)\n\t\t\t\t\t\t\t\tsimple: false, // don't throw on non-200 (e.g. 302)\n\t\t\t\t\t\t\t\tresolveWithFullResponse: true, // send full request back (to check statusCode)\n\t\t\t\t\t\t\t\theaders: headers,\n\t\t\t\t\t\t\t\tqs: qs,\n\t\t\t\t\t\t\t\tbody: body,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else if (type === 'form') {\n\t\t\t\t\t\t\tresponse = await new Promise((resolve, reject) => {\n\t\t\t\t\t\t\t\thelpers.uploadFile(url, pathLib.join(__dirname, './files/test.png'), {}, jar, csrfToken, (err, res) => {\n\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tresolve(res);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tassert(!e, `${method.toUpperCase()} ${path} errored with: ${e.message}`);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tit('response status code should match one of the schema defined responses', () => {\n\t\t\t\t\t// HACK: allow HTTP 418 I am a teapot, for now   \ud83d\udc47\n\t\t\t\t\tassert(context[method].responses.hasOwnProperty('418') || Object.keys(context[method].responses).includes(String(response.statusCode)), `${method.toUpperCase()} ${path} sent back unexpected HTTP status code: ${response.statusCode}`);\n\t\t\t\t});\n\n\t\t\t\t// Recursively iterate through schema properties, comparing type\n\t\t\t\tit('response body should match schema definition', () => {\n\t\t\t\t\tconst http302 = context[method].responses['302'];\n\t\t\t\t\tif (http302 && response.statusCode === 302) {\n\t\t\t\t\t\t// Compare headers instead\n\t\t\t\t\t\tconst expectedHeaders = Object.keys(http302.headers).reduce((memo, name) => {\n\t\t\t\t\t\t\tconst value = http302.headers[name].schema.example;\n\t\t\t\t\t\t\tmemo[name] = value.startsWith(nconf.get('relative_path')) ? value : nconf.get('relative_path') + value;\n\t\t\t\t\t\t\treturn memo;\n\t\t\t\t\t\t}, {});\n\n\t\t\t\t\t\tfor (const header of Object.keys(expectedHeaders)) {\n\t\t\t\t\t\t\tassert(response.headers[header.toLowerCase()]);\n\t\t\t\t\t\t\tassert.strictEqual(response.headers[header.toLowerCase()], expectedHeaders[header]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst http200 = context[method].responses['200'];\n\t\t\t\t\tif (!http200) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tassert.strictEqual(response.statusCode, 200, `HTTP 200 expected (path: ${method} ${path}`);\n\n\t\t\t\t\tconst hasJSON = http200.content && http200.content['application/json'];\n\t\t\t\t\tif (hasJSON) {\n\t\t\t\t\t\tschema = context[method].responses['200'].content['application/json'].schema;\n\t\t\t\t\t\tcompare(schema, response.body, method.toUpperCase(), path, 'root');\n\t\t\t\t\t}\n\n\t\t\t\t\t// TODO someday: text/csv, binary file type checking?\n\t\t\t\t});\n\n\t\t\t\tit('should successfully re-login if needed', async () => {\n\t\t\t\t\tconst reloginPaths = ['PUT /users/{uid}/password', 'DELETE /users/{uid}/sessions/{uuid}'];\n\t\t\t\t\tif (reloginPaths.includes(`${method.toUpperCase()} ${path}`)) {\n\t\t\t\t\t\t({ jar } = await helpers.loginUser('admin', '123456'));\n\t\t\t\t\t\tconst sessionUUIDs = await db.getObject('uid:1:sessionUUID:sessionId');\n\t\t\t\t\t\tmocks.delete['/users/{uid}/sessions/{uuid}'][1].example = Object.keys(sessionUUIDs).pop();\n\n\t\t\t\t\t\t// Retrieve CSRF token using cookie, to test Write API\n\t\t\t\t\t\tconst config = await request({\n\t\t\t\t\t\t\turl: `${nconf.get('url')}/api/config`,\n\t\t\t\t\t\t\tjson: true,\n\t\t\t\t\t\t\tjar: jar,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tcsrfToken = config.csrf_token;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tit('should back out of a registration interstitial if needed', async () => {\n\t\t\t\t\tconst affectedPaths = ['GET /api/user/{userslug}/edit/email'];\n\t\t\t\t\tif (affectedPaths.includes(`${method.toUpperCase()} ${path}`)) {\n\t\t\t\t\t\tawait request({\n\t\t\t\t\t\t\turi: `${nconf.get('url')}/register/abort`,\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\tjar,\n\t\t\t\t\t\t\tsimple: false,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tfunction buildBody(schema) {\n\t\treturn Object.keys(schema).reduce((memo, cur) => {\n\t\t\tmemo[cur] = schema[cur].example;\n\t\t\treturn memo;\n\t\t}, {});\n\t}\n\n\tfunction compare(schema, response, method, path, context) {\n\t\tlet required = [];\n\t\tconst additionalProperties = schema.hasOwnProperty('additionalProperties');\n\n\t\tfunction flattenAllOf(obj) {\n\t\t\treturn obj.reduce((memo, obj) => {\n\t\t\t\tif (obj.allOf) {\n\t\t\t\t\tobj = { properties: flattenAllOf(obj.allOf) };\n\t\t\t\t} else {\n\t\t\t\t\ttry {\n\t\t\t\t\t\trequired = required.concat(obj.required ? obj.required : Object.keys(obj.properties));\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tassert.fail(`Syntax error re: allOf, perhaps you allOf'd an array? (path: ${method} ${path}, context: ${context})`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn { ...memo, ...obj.properties };\n\t\t\t}, {});\n\t\t}\n\n\t\tif (schema.allOf) {\n\t\t\tschema = flattenAllOf(schema.allOf);\n\t\t} else if (schema.properties) {\n\t\t\trequired = schema.required || Object.keys(schema.properties);\n\t\t\tschema = schema.properties;\n\t\t} else {\n\t\t\t// If schema contains no properties, check passes\n\t\t\treturn;\n\t\t}\n\n\t\t// Compare the schema to the response\n\t\trequired.forEach((prop) => {\n\t\t\tif (schema.hasOwnProperty(prop)) {\n\t\t\t\tassert(response.hasOwnProperty(prop), `\"${prop}\" is a required property (path: ${method} ${path}, context: ${context})`);\n\n\t\t\t\t// Don't proceed with type-check if the value could possibly be unset (nullable: true, in spec)\n\t\t\t\tif (response[prop] === null && schema[prop].nullable === true) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Therefore, if the value is actually null, that's a problem (nullable is probably missing)\n\t\t\t\tassert(response[prop] !== null, `\"${prop}\" was null, but schema does not specify it to be a nullable property (path: ${method} ${path}, context: ${context})`);\n\n\t\t\t\tswitch (schema[prop].type) {\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tassert.strictEqual(typeof response[prop], 'string', `\"${prop}\" was expected to be a string, but was ${typeof response[prop]} instead (path: ${method} ${path}, context: ${context})`);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'boolean':\n\t\t\t\t\t\tassert.strictEqual(typeof response[prop], 'boolean', `\"${prop}\" was expected to be a boolean, but was ${typeof response[prop]} instead (path: ${method} ${path}, context: ${context})`);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'object':\n\t\t\t\t\t\tassert.strictEqual(typeof response[prop], 'object', `\"${prop}\" was expected to be an object, but was ${typeof response[prop]} instead (path: ${method} ${path}, context: ${context})`);\n\t\t\t\t\t\tcompare(schema[prop], response[prop], method, path, context ? [context, prop].join('.') : prop);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'array':\n\t\t\t\t\t\tassert.strictEqual(Array.isArray(response[prop]), true, `\"${prop}\" was expected to be an array, but was ${typeof response[prop]} instead (path: ${method} ${path}, context: ${context})`);\n\n\t\t\t\t\t\tif (schema[prop].items) {\n\t\t\t\t\t\t\t// Ensure the array items have a schema defined\n\t\t\t\t\t\t\tassert(schema[prop].items.type || schema[prop].items.allOf, `\"${prop}\" is defined to be an array, but its items have no schema defined (path: ${method} ${path}, context: ${context})`);\n\n\t\t\t\t\t\t\t// Compare types\n\t\t\t\t\t\t\tif (schema[prop].items.type === 'object' || Array.isArray(schema[prop].items.allOf)) {\n\t\t\t\t\t\t\t\tresponse[prop].forEach((res) => {\n\t\t\t\t\t\t\t\t\tcompare(schema[prop].items, res, method, path, context ? [context, prop].join('.') : prop);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else if (response[prop].length) { // for now\n\t\t\t\t\t\t\t\tresponse[prop].forEach((item) => {\n\t\t\t\t\t\t\t\t\tassert.strictEqual(typeof item, schema[prop].items.type, `\"${prop}\" should have ${schema[prop].items.type} items, but found ${typeof items} instead (path: ${method} ${path}, context: ${context})`);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// Compare the response to the schema\n\t\tObject.keys(response).forEach((prop) => {\n\t\t\tif (additionalProperties) { // All bets are off\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tassert(schema[prop], `\"${prop}\" was found in response, but is not defined in schema (path: ${method} ${path}, context: ${context})`);\n\t\t});\n\t}\n});\n", "'use strict';\n\nconst async = require('async');\nconst assert = require('assert');\nconst nconf = require('nconf');\nconst request = require('request');\nconst requestAsync = require('request-promise-native');\nconst fs = require('fs');\nconst path = require('path');\n\nconst db = require('./mocks/databasemock');\nconst categories = require('../src/categories');\nconst topics = require('../src/topics');\nconst posts = require('../src/posts');\nconst user = require('../src/user');\nconst groups = require('../src/groups');\nconst meta = require('../src/meta');\nconst translator = require('../src/translator');\nconst privileges = require('../src/privileges');\nconst plugins = require('../src/plugins');\nconst utils = require('../src/utils');\nconst helpers = require('./helpers');\n\ndescribe('Controllers', () => {\n\tlet tid;\n\tlet cid;\n\tlet pid;\n\tlet fooUid;\n\tlet adminUid;\n\tlet category;\n\n\tbefore(async () => {\n\t\tcategory = await categories.create({\n\t\t\tname: 'Test Category',\n\t\t\tdescription: 'Test category created by testing script',\n\t\t});\n\t\tcid = category.cid;\n\n\t\tfooUid = await user.create({ username: 'foo', password: 'barbar', gdpr_consent: true });\n\t\tawait user.setUserField(fooUid, 'email', 'foo@test.com');\n\t\tawait user.email.confirmByUid(fooUid);\n\n\t\tadminUid = await user.create({ username: 'admin', password: 'barbar', gdpr_consent: true });\n\t\tawait groups.join('administrators', adminUid);\n\n\t\tconst navigation = require('../src/navigation/admin');\n\t\tconst data = require('../install/data/navigation.json');\n\n\t\tawait navigation.save(data);\n\n\t\tconst result = await topics.post({ uid: fooUid, title: 'test topic title', content: 'test topic content', cid: cid });\n\t\ttid = result.topicData.tid;\n\t\tpid = result.postData.pid;\n\t});\n\n\tit('should load /config with csrf_token', (done) => {\n\t\trequest({\n\t\t\turl: `${nconf.get('url')}/api/config`,\n\t\t\tjson: true,\n\t\t}, (err, response, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(response.statusCode, 200);\n\t\t\tassert(body.csrf_token);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load /config with no csrf_token as spider', (done) => {\n\t\trequest({\n\t\t\turl: `${nconf.get('url')}/api/config`,\n\t\t\tjson: true,\n\t\t\theaders: {\n\t\t\t\t'user-agent': 'yandex',\n\t\t\t},\n\t\t}, (err, response, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(response.statusCode, 200);\n\t\t\tassert.strictEqual(body.csrf_token, false);\n\t\t\tassert.strictEqual(body.uid, -1);\n\t\t\tassert.strictEqual(body.loggedIn, false);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tdescribe('homepage', () => {\n\t\tfunction hookMethod(hookData) {\n\t\t\tassert(hookData.req);\n\t\t\tassert(hookData.res);\n\t\t\tassert(hookData.next);\n\n\t\t\thookData.res.render('mycustompage', {\n\t\t\t\tworks: true,\n\t\t\t});\n\t\t}\n\t\tconst message = utils.generateUUID();\n\t\tconst name = 'mycustompage.tpl';\n\t\tconst tplPath = path.join(nconf.get('views_dir'), name);\n\n\t\tbefore(async () => {\n\t\t\tplugins.hooks.register('myTestPlugin', {\n\t\t\t\thook: 'action:homepage.get:mycustompage',\n\t\t\t\tmethod: hookMethod,\n\t\t\t});\n\n\t\t\tfs.writeFileSync(tplPath, message);\n\t\t\tawait meta.templates.compileTemplate(name, message);\n\t\t});\n\n\t\tit('should load default', (done) => {\n\t\t\trequest(nconf.get('url'), (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load unread', (done) => {\n\t\t\tmeta.configs.set('homePageRoute', 'unread', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\trequest(nconf.get('url'), (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert(body);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should load recent', (done) => {\n\t\t\tmeta.configs.set('homePageRoute', 'recent', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\trequest(nconf.get('url'), (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert(body);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should load top', (done) => {\n\t\t\tmeta.configs.set('homePageRoute', 'top', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\trequest(nconf.get('url'), (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert(body);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should load popular', (done) => {\n\t\t\tmeta.configs.set('homePageRoute', 'popular', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\trequest(nconf.get('url'), (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert(body);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should load category', (done) => {\n\t\t\tmeta.configs.set('homePageRoute', 'category/1/test-category', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\trequest(nconf.get('url'), (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert(body);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should not load breadcrumbs on home page route', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tassert(!body.breadcrumbs);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should redirect to custom', (done) => {\n\t\t\tmeta.configs.set('homePageRoute', 'groups', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\trequest(nconf.get('url'), (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert(body);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should 404 if custom does not exist', (done) => {\n\t\t\tmeta.configs.set('homePageRoute', 'this-route-does-not-exist', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\trequest(nconf.get('url'), (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\t\tassert(body);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('api should work with hook', (done) => {\n\t\t\tmeta.configs.set('homePageRoute', 'mycustompage', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\trequest(`${nconf.get('url')}/api`, { json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert.equal(body.works, true);\n\t\t\t\t\tassert.equal(body.template.mycustompage, true);\n\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should render with hook', (done) => {\n\t\t\tmeta.configs.set('homePageRoute', 'mycustompage', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\trequest(nconf.get('url'), (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert.ok(body);\n\t\t\t\t\tassert.ok(body.indexOf('<main id=\"panel\"'));\n\t\t\t\t\tassert.ok(body.includes(message));\n\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tafter(() => {\n\t\t\tplugins.hooks.unregister('myTestPlugin', 'action:homepage.get:custom', hookMethod);\n\t\t\tfs.unlinkSync(tplPath);\n\t\t\tfs.unlinkSync(tplPath.replace(/\\.tpl$/, '.js'));\n\t\t});\n\t});\n\n\tit('should load /reset without code', (done) => {\n\t\trequest(`${nconf.get('url')}/reset`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load /reset with invalid code', (done) => {\n\t\trequest(`${nconf.get('url')}/reset/123123`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load /login', (done) => {\n\t\trequest(`${nconf.get('url')}/login`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load /register', (done) => {\n\t\trequest(`${nconf.get('url')}/register`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load /register/complete', (done) => {\n\t\tconst data = {\n\t\t\tusername: 'interstitial',\n\t\t\tpassword: '123456',\n\t\t\t'password-confirm': '123456',\n\t\t\temail: 'test@me.com',\n\t\t};\n\n\t\tconst jar = request.jar();\n\t\trequest({\n\t\t\turl: `${nconf.get('url')}/api/config`,\n\t\t\tjson: true,\n\t\t\tjar: jar,\n\t\t}, (err, response, body) => {\n\t\t\tassert.ifError(err);\n\n\t\t\trequest.post(`${nconf.get('url')}/register`, {\n\t\t\t\tform: data,\n\t\t\t\tjson: true,\n\t\t\t\tjar: jar,\n\t\t\t\theaders: {\n\t\t\t\t\t'x-csrf-token': body.csrf_token,\n\t\t\t\t},\n\t\t\t}, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert.strictEqual(body.next, `${nconf.get('relative_path')}/register/complete`);\n\t\t\t\trequest(`${nconf.get('url')}/api/register/complete`, {\n\t\t\t\t\tjar: jar,\n\t\t\t\t\tjson: true,\n\t\t\t\t}, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert(body.sections);\n\t\t\t\t\tassert(body.errors);\n\t\t\t\t\tassert(body.title);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('registration interstitials', () => {\n\t\tdescribe('email update', () => {\n\t\t\tlet jar;\n\t\t\tlet token;\n\t\t\tconst dummyEmailerHook = async (data) => {};\n\n\t\t\tbefore(async () => {\n\t\t\t\t// Attach an emailer hook so related requests do not error\n\t\t\t\tplugins.hooks.register('emailer-test', {\n\t\t\t\t\thook: 'filter:email.send',\n\t\t\t\t\tmethod: dummyEmailerHook,\n\t\t\t\t});\n\n\t\t\t\tjar = await helpers.registerUser({\n\t\t\t\t\tusername: utils.generateUUID().slice(0, 10),\n\t\t\t\t\tpassword: utils.generateUUID(),\n\t\t\t\t});\n\t\t\t\ttoken = await helpers.getCsrfToken(jar);\n\n\t\t\t\tmeta.config.requireEmailAddress = 1;\n\t\t\t});\n\n\t\t\tafter(() => {\n\t\t\t\tmeta.config.requireEmailAddress = 0;\n\t\t\t\tplugins.hooks.unregister('emailer-test', 'filter:email.send');\n\t\t\t});\n\n\t\t\tit('email interstitial should still apply if empty email entered and requireEmailAddress is enabled', async () => {\n\t\t\t\tlet res = await requestAsync(`${nconf.get('url')}/register/complete`, {\n\t\t\t\t\tmethod: 'post',\n\t\t\t\t\tjar,\n\t\t\t\t\tjson: true,\n\t\t\t\t\tfollowRedirect: false,\n\t\t\t\t\tsimple: false,\n\t\t\t\t\tresolveWithFullResponse: true,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'x-csrf-token': token,\n\t\t\t\t\t},\n\t\t\t\t\tform: {\n\t\t\t\t\t\temail: '',\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\tassert.strictEqual(res.headers.location, `${nconf.get('relative_path')}/register/complete`);\n\n\t\t\t\tres = await requestAsync(`${nconf.get('url')}/api/register/complete`, {\n\t\t\t\t\tjar,\n\t\t\t\t\tjson: true,\n\t\t\t\t\tresolveWithFullResponse: true,\n\t\t\t\t});\n\t\t\t\tassert.strictEqual(res.statusCode, 200);\n\t\t\t\tassert(res.body.errors.length);\n\t\t\t\tassert(res.body.errors.includes('[[error:invalid-email]]'));\n\t\t\t});\n\n\t\t\tit('gdpr interstitial should still apply if email requirement is disabled', async () => {\n\t\t\t\tmeta.config.requireEmailAddress = 0;\n\n\t\t\t\tconst res = await requestAsync(`${nconf.get('url')}/api/register/complete`, {\n\t\t\t\t\tjar,\n\t\t\t\t\tjson: true,\n\t\t\t\t\tresolveWithFullResponse: true,\n\t\t\t\t});\n\n\t\t\t\tassert(!res.body.errors.includes('[[error:invalid-email]]'));\n\t\t\t\tassert(!res.body.errors.includes('[[error:gdpr_consent_denied]]'));\n\t\t\t});\n\n\t\t\tit('should error if userData is falsy', async () => {\n\t\t\t\ttry {\n\t\t\t\t\tawait user.interstitials.email({ userData: null });\n\t\t\t\t\tassert(false);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tassert.strictEqual(err.message, '[[error:invalid-data]]');\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tit('should throw error if email is not valid', async () => {\n\t\t\t\tconst uid = await user.create({ username: 'interstiuser1' });\n\t\t\t\ttry {\n\t\t\t\t\tconst result = await user.interstitials.email({\n\t\t\t\t\t\tuserData: { uid: uid, updateEmail: true },\n\t\t\t\t\t\treq: { uid: uid },\n\t\t\t\t\t\tinterstitials: [],\n\t\t\t\t\t});\n\t\t\t\t\tassert.strictEqual(result.interstitials[0].template, 'partials/email_update');\n\t\t\t\t\tawait result.interstitials[0].callback({ uid }, {\n\t\t\t\t\t\temail: 'invalidEmail',\n\t\t\t\t\t});\n\t\t\t\t\tassert(false);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tassert.strictEqual(err.message, '[[error:invalid-email]]');\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tit('should set req.session.emailChanged to 1', async () => {\n\t\t\t\tconst uid = await user.create({ username: 'interstiuser2' });\n\t\t\t\tconst result = await user.interstitials.email({\n\t\t\t\t\tuserData: { uid: uid, updateEmail: true },\n\t\t\t\t\treq: { uid: uid, session: {} },\n\t\t\t\t\tinterstitials: [],\n\t\t\t\t});\n\n\t\t\t\tawait result.interstitials[0].callback({ uid: uid }, {\n\t\t\t\t\temail: 'interstiuser2@nodebb.org',\n\t\t\t\t});\n\t\t\t\tassert.strictEqual(result.req.session.emailChanged, 1);\n\t\t\t});\n\n\t\t\tit('should set email if admin is changing it', async () => {\n\t\t\t\tconst uid = await user.create({ username: 'interstiuser3' });\n\t\t\t\tconst result = await user.interstitials.email({\n\t\t\t\t\tuserData: { uid: uid, updateEmail: true },\n\t\t\t\t\treq: { uid: adminUid },\n\t\t\t\t\tinterstitials: [],\n\t\t\t\t});\n\n\t\t\t\tawait result.interstitials[0].callback({ uid: uid }, {\n\t\t\t\t\temail: 'interstiuser3@nodebb.org',\n\t\t\t\t});\n\t\t\t\tconst userData = await user.getUserData(uid);\n\t\t\t\tassert.strictEqual(userData.email, 'interstiuser3@nodebb.org');\n\t\t\t\tassert.strictEqual(userData['email:confirmed'], 1);\n\t\t\t});\n\n\t\t\tit('should throw error if user tries to edit other users email', async () => {\n\t\t\t\tconst uid = await user.create({ username: 'interstiuser4' });\n\t\t\t\ttry {\n\t\t\t\t\tconst result = await user.interstitials.email({\n\t\t\t\t\t\tuserData: { uid: uid, updateEmail: true },\n\t\t\t\t\t\treq: { uid: 1000 },\n\t\t\t\t\t\tinterstitials: [],\n\t\t\t\t\t});\n\n\t\t\t\t\tawait result.interstitials[0].callback({ uid: uid }, {\n\t\t\t\t\t\temail: 'derp@derp.com',\n\t\t\t\t\t});\n\t\t\t\t\tassert(false);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tassert.strictEqual(err.message, '[[error:no-privileges]]');\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tit('should remove current email', async () => {\n\t\t\t\tconst uid = await user.create({ username: 'interstiuser5' });\n\t\t\t\tawait user.setUserField(uid, 'email', 'interstiuser5@nodebb.org');\n\t\t\t\tawait user.email.confirmByUid(uid);\n\n\t\t\t\tconst result = await user.interstitials.email({\n\t\t\t\t\tuserData: { uid: uid, updateEmail: true },\n\t\t\t\t\treq: { uid: uid, session: { id: 0 } },\n\t\t\t\t\tinterstitials: [],\n\t\t\t\t});\n\n\t\t\t\tawait result.interstitials[0].callback({ uid: uid }, {\n\t\t\t\t\temail: '',\n\t\t\t\t});\n\t\t\t\tconst userData = await user.getUserData(uid);\n\t\t\t\tassert.strictEqual(userData.email, '');\n\t\t\t\tassert.strictEqual(userData['email:confirmed'], 0);\n\t\t\t});\n\n\t\t\tit('should require a password (if one is set) for email change', async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst [username, password] = [utils.generateUUID().slice(0, 10), utils.generateUUID()];\n\t\t\t\t\tconst uid = await user.create({ username, password });\n\t\t\t\t\tawait user.setUserField(uid, 'email', `${username}@nodebb.org`);\n\t\t\t\t\tawait user.email.confirmByUid(uid);\n\n\t\t\t\t\tconst result = await user.interstitials.email({\n\t\t\t\t\t\tuserData: { uid: uid, updateEmail: true },\n\t\t\t\t\t\treq: { uid: uid, session: { id: 0 } },\n\t\t\t\t\t\tinterstitials: [],\n\t\t\t\t\t});\n\n\t\t\t\t\tawait result.interstitials[0].callback({ uid: uid }, {\n\t\t\t\t\t\temail: `${username}@nodebb.com`,\n\t\t\t\t\t});\n\t\t\t\t} catch (err) {\n\t\t\t\t\tassert.strictEqual(err.message, '[[error:invalid-password]]');\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tit('should require a password (if one is set) for email clearing', async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst [username, password] = [utils.generateUUID().slice(0, 10), utils.generateUUID()];\n\t\t\t\t\tconst uid = await user.create({ username, password });\n\t\t\t\t\tawait user.setUserField(uid, 'email', `${username}@nodebb.org`);\n\t\t\t\t\tawait user.email.confirmByUid(uid);\n\n\t\t\t\t\tconst result = await user.interstitials.email({\n\t\t\t\t\t\tuserData: { uid: uid, updateEmail: true },\n\t\t\t\t\t\treq: { uid: uid, session: { id: 0 } },\n\t\t\t\t\t\tinterstitials: [],\n\t\t\t\t\t});\n\n\t\t\t\t\tawait result.interstitials[0].callback({ uid: uid }, {\n\t\t\t\t\t\temail: '',\n\t\t\t\t\t});\n\t\t\t\t} catch (err) {\n\t\t\t\t\tassert.strictEqual(err.message, '[[error:invalid-password]]');\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tit('should successfully issue validation request if the correct password is passed in', async () => {\n\t\t\t\tconst [username, password] = [utils.generateUUID().slice(0, 10), utils.generateUUID()];\n\t\t\t\tconst uid = await user.create({ username, password });\n\t\t\t\tawait user.setUserField(uid, 'email', `${username}@nodebb.org`);\n\t\t\t\tawait user.email.confirmByUid(uid);\n\n\t\t\t\tconst result = await user.interstitials.email({\n\t\t\t\t\tuserData: { uid: uid, updateEmail: true },\n\t\t\t\t\treq: { uid: uid, session: { id: 0 } },\n\t\t\t\t\tinterstitials: [],\n\t\t\t\t});\n\n\t\t\t\tawait result.interstitials[0].callback({ uid }, {\n\t\t\t\t\temail: `${username}@nodebb.com`,\n\t\t\t\t\tpassword,\n\t\t\t\t});\n\n\t\t\t\tconst pending = await user.email.isValidationPending(uid, `${username}@nodebb.com`);\n\t\t\t\tassert.strictEqual(pending, true);\n\t\t\t\tawait user.setUserField(uid, 'email', `${username}@nodebb.com`);\n\t\t\t\tawait user.email.confirmByUid(uid);\n\t\t\t\tconst userData = await user.getUserData(uid);\n\t\t\t\tassert.strictEqual(userData.email, `${username}@nodebb.com`);\n\t\t\t\tassert.strictEqual(userData['email:confirmed'], 1);\n\t\t\t});\n\t\t});\n\n\t\tdescribe('gdpr', () => {\n\t\t\tlet jar;\n\t\t\tlet token;\n\n\t\t\tbefore(async () => {\n\t\t\t\tjar = await helpers.registerUser({\n\t\t\t\t\tusername: utils.generateUUID().slice(0, 10),\n\t\t\t\t\tpassword: utils.generateUUID(),\n\t\t\t\t});\n\t\t\t\ttoken = await helpers.getCsrfToken(jar);\n\t\t\t});\n\n\t\t\tit('registration should succeed once gdpr prompts are agreed to', async () => {\n\t\t\t\tconst res = await requestAsync(`${nconf.get('url')}/register/complete`, {\n\t\t\t\t\tmethod: 'post',\n\t\t\t\t\tjar,\n\t\t\t\t\tjson: true,\n\t\t\t\t\tfollowRedirect: false,\n\t\t\t\t\tsimple: false,\n\t\t\t\t\tresolveWithFullResponse: true,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'x-csrf-token': token,\n\t\t\t\t\t},\n\t\t\t\t\tform: {\n\t\t\t\t\t\tgdpr_agree_data: 'on',\n\t\t\t\t\t\tgdpr_agree_email: 'on',\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\tassert.strictEqual(res.statusCode, 302);\n\t\t\t\tassert.strictEqual(res.headers.location, `${nconf.get('relative_path')}/`);\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should load /robots.txt', (done) => {\n\t\trequest(`${nconf.get('url')}/robots.txt`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load /manifest.webmanifest', (done) => {\n\t\trequest(`${nconf.get('url')}/manifest.webmanifest`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load /outgoing?url=<url>', (done) => {\n\t\trequest(`${nconf.get('url')}/outgoing?url=http://youtube.com`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should 404 on /outgoing with no url', (done) => {\n\t\trequest(`${nconf.get('url')}/outgoing`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 404);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should 404 on /outgoing with javascript: protocol', (done) => {\n\t\trequest(`${nconf.get('url')}/outgoing?url=javascript:alert(1);`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 404);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should 404 on /outgoing with invalid url', (done) => {\n\t\trequest(`${nconf.get('url')}/outgoing?url=derp`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 404);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load /tos', (done) => {\n\t\tmeta.config.termsOfUse = 'please accept our tos';\n\t\trequest(`${nconf.get('url')}/tos`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\n\tit('should load 404 if meta.config.termsOfUse is empty', (done) => {\n\t\tmeta.config.termsOfUse = '';\n\t\trequest(`${nconf.get('url')}/tos`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 404);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load /sping', (done) => {\n\t\trequest(`${nconf.get('url')}/sping`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert.equal(body, 'healthy');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load /ping', (done) => {\n\t\trequest(`${nconf.get('url')}/ping`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert.equal(body, '200');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should handle 404', (done) => {\n\t\trequest(`${nconf.get('url')}/arouteinthevoid`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 404);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load topic rss feed', (done) => {\n\t\trequest(`${nconf.get('url')}/topic/${tid}.rss`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load category rss feed', (done) => {\n\t\trequest(`${nconf.get('url')}/category/${cid}.rss`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load topics rss feed', (done) => {\n\t\trequest(`${nconf.get('url')}/topics.rss`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load recent rss feed', (done) => {\n\t\trequest(`${nconf.get('url')}/recent.rss`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load top rss feed', (done) => {\n\t\trequest(`${nconf.get('url')}/top.rss`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load popular rss feed', (done) => {\n\t\trequest(`${nconf.get('url')}/popular.rss`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load popular rss feed with term', (done) => {\n\t\trequest(`${nconf.get('url')}/popular/day.rss`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load recent posts rss feed', (done) => {\n\t\trequest(`${nconf.get('url')}/recentposts.rss`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load category recent posts rss feed', (done) => {\n\t\trequest(`${nconf.get('url')}/category/${cid}/recentposts.rss`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load user topics rss feed', (done) => {\n\t\trequest(`${nconf.get('url')}/user/foo/topics.rss`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load tag rss feed', (done) => {\n\t\trequest(`${nconf.get('url')}/tags/nodebb.rss`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load client.css', (done) => {\n\t\trequest(`${nconf.get('url')}/assets/client.css`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load admin.css', (done) => {\n\t\trequest(`${nconf.get('url')}/assets/admin.css`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load sitemap.xml', (done) => {\n\t\trequest(`${nconf.get('url')}/sitemap.xml`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load sitemap/pages.xml', (done) => {\n\t\trequest(`${nconf.get('url')}/sitemap/pages.xml`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load sitemap/categories.xml', (done) => {\n\t\trequest(`${nconf.get('url')}/sitemap/categories.xml`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load sitemap/topics/1.xml', (done) => {\n\t\trequest(`${nconf.get('url')}/sitemap/topics.1.xml`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load robots.txt', (done) => {\n\t\trequest(`${nconf.get('url')}/robots.txt`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load theme screenshot', (done) => {\n\t\trequest(`${nconf.get('url')}/css/previews/nodebb-theme-persona`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load users page', (done) => {\n\t\trequest(`${nconf.get('url')}/users`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load users page', (done) => {\n\t\trequest(`${nconf.get('url')}/users?section=online`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should error if guests do not have search privilege', (done) => {\n\t\trequest(`${nconf.get('url')}/api/users?query=bar&section=sort-posts`, { json: true }, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 500);\n\t\t\tassert(body);\n\t\t\tassert.equal(body.error, '[[error:no-privileges]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load users search page', (done) => {\n\t\tprivileges.global.give(['groups:search:users'], 'guests', (err) => {\n\t\t\tassert.ifError(err);\n\t\t\trequest(`${nconf.get('url')}/users?query=bar&section=sort-posts`, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tprivileges.global.rescind(['groups:search:users'], 'guests', done);\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should load groups page', (done) => {\n\t\trequest(`${nconf.get('url')}/groups`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load group details page', (done) => {\n\t\tgroups.create({\n\t\t\tname: 'group-details',\n\t\t\tdescription: 'Foobar!',\n\t\t\thidden: 0,\n\t\t}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tgroups.join('group-details', fooUid, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\ttopics.post({\n\t\t\t\t\tuid: fooUid,\n\t\t\t\t\ttitle: 'topic title',\n\t\t\t\t\tcontent: 'test topic content',\n\t\t\t\t\tcid: cid,\n\t\t\t\t}, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\trequest(`${nconf.get('url')}/api/groups/group-details`, { json: true }, (err, res, body) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\t\tassert(body);\n\t\t\t\t\t\tassert.equal(body.posts[0].content, 'test topic content');\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should load group members page', (done) => {\n\t\trequest(`${nconf.get('url')}/groups/group-details/members`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should 404 when trying to load group members of hidden group', (done) => {\n\t\tconst groups = require('../src/groups');\n\t\tgroups.create({\n\t\t\tname: 'hidden-group',\n\t\t\tdescription: 'Foobar!',\n\t\t\thidden: 1,\n\t\t}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\trequest(`${nconf.get('url')}/groups/hidden-group/members`, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should get recent posts', (done) => {\n\t\trequest(`${nconf.get('url')}/api/recent/posts/month`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get post data', (done) => {\n\t\trequest(`${nconf.get('url')}/api/v3/posts/${pid}`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get topic data', (done) => {\n\t\trequest(`${nconf.get('url')}/api/v3/topics/${tid}`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get category data', (done) => {\n\t\trequest(`${nconf.get('url')}/api/v3/categories/${cid}`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\n\tdescribe('revoke session', () => {\n\t\tlet uid;\n\t\tlet jar;\n\t\tlet csrf_token;\n\n\t\tbefore(async () => {\n\t\t\tuid = await user.create({ username: 'revokeme', password: 'barbar' });\n\t\t\tconst login = await helpers.loginUser('revokeme', 'barbar');\n\t\t\tjar = login.jar;\n\t\t\tcsrf_token = login.csrf_token;\n\t\t});\n\n\t\tit('should fail to revoke session with missing uuid', (done) => {\n\t\t\trequest.del(`${nconf.get('url')}/api/user/revokeme/session`, {\n\t\t\t\tjar: jar,\n\t\t\t\theaders: {\n\t\t\t\t\t'x-csrf-token': csrf_token,\n\t\t\t\t},\n\t\t\t}, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should fail if user doesn\\'t exist', (done) => {\n\t\t\trequest.del(`${nconf.get('url')}/api/v3/users/doesnotexist/sessions/1112233`, {\n\t\t\t\tjar: jar,\n\t\t\t\theaders: {\n\t\t\t\t\t'x-csrf-token': csrf_token,\n\t\t\t\t},\n\t\t\t}, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(res.statusCode, 404);\n\t\t\t\tconst parsedResponse = JSON.parse(body);\n\t\t\t\tassert.deepStrictEqual(parsedResponse.response, {});\n\t\t\t\tassert.deepStrictEqual(parsedResponse.status, {\n\t\t\t\t\tcode: 'not-found',\n\t\t\t\t\tmessage: 'User does not exist',\n\t\t\t\t});\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should revoke user session', (done) => {\n\t\t\tdb.getSortedSetRange(`uid:${uid}:sessions`, 0, -1, (err, sids) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tconst sid = sids[0];\n\n\t\t\t\tdb.sessionStore.get(sid, (err, sessionObj) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\trequest.del(`${nconf.get('url')}/api/v3/users/${uid}/sessions/${sessionObj.meta.uuid}`, {\n\t\t\t\t\t\tjar: jar,\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'x-csrf-token': csrf_token,\n\t\t\t\t\t\t},\n\t\t\t\t\t}, (err, res, body) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.strictEqual(res.statusCode, 200);\n\t\t\t\t\t\tassert.deepStrictEqual(JSON.parse(body), {\n\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\tcode: 'ok',\n\t\t\t\t\t\t\t\tmessage: 'OK',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tresponse: {},\n\t\t\t\t\t\t});\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('widgets', () => {\n\t\tconst widgets = require('../src/widgets');\n\n\t\tbefore((done) => {\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\twidgets.reset(next);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\tconst data = {\n\t\t\t\t\t\ttemplate: 'categories.tpl',\n\t\t\t\t\t\tlocation: 'sidebar',\n\t\t\t\t\t\twidgets: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\twidget: 'html',\n\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\thtml: 'test',\n\t\t\t\t\t\t\t\t\ttitle: '',\n\t\t\t\t\t\t\t\t\tcontainer: '',\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t};\n\n\t\t\t\t\twidgets.setArea(data, next);\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should return {} if there are no widgets', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/category/${cid}`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body.widgets);\n\t\t\t\tassert.equal(Object.keys(body.widgets).length, 0);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should render templates', (done) => {\n\t\t\tconst url = `${nconf.get('url')}/api/categories`;\n\t\t\trequest(url, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body.widgets);\n\t\t\t\tassert(body.widgets.sidebar);\n\t\t\t\tassert.equal(body.widgets.sidebar[0].html, 'test');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should reset templates', (done) => {\n\t\t\twidgets.resetTemplates(['categories', 'category'], (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\trequest(`${nconf.get('url')}/api/categories`, { json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert(body.widgets);\n\t\t\t\t\tassert.equal(Object.keys(body.widgets).length, 0);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('tags', () => {\n\t\tlet tid;\n\t\tbefore((done) => {\n\t\t\ttopics.post({\n\t\t\t\tuid: fooUid,\n\t\t\t\ttitle: 'topic title',\n\t\t\t\tcontent: 'test topic content',\n\t\t\t\tcid: cid,\n\t\t\t\ttags: ['nodebb', 'bug', 'test'],\n\t\t\t}, (err, result) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\ttid = result.topicData.tid;\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should render tags page', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/tags`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tassert(Array.isArray(body.tags));\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should render tag page with no topics', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/tags/notag`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tassert(Array.isArray(body.topics));\n\t\t\t\tassert.equal(body.topics.length, 0);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should render tag page with 1 topic', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/tags/nodebb`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tassert(Array.isArray(body.topics));\n\t\t\t\tassert.equal(body.topics.length, 1);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\n\tdescribe('maintenance mode', () => {\n\t\tbefore((done) => {\n\t\t\tmeta.config.maintenanceMode = 1;\n\t\t\tdone();\n\t\t});\n\t\tafter((done) => {\n\t\t\tmeta.config.maintenanceMode = 0;\n\t\t\tdone();\n\t\t});\n\n\t\tit('should return 503 in maintenance mode', (done) => {\n\t\t\trequest(`${nconf.get('url')}/recent`, { json: true }, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 503);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return 503 in maintenance mode', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/recent`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 503);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return 200 in maintenance mode', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/login`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('account pages', () => {\n\t\tlet jar;\n\t\tbefore(async () => {\n\t\t\t({ jar } = await helpers.loginUser('foo', 'barbar'));\n\t\t});\n\n\t\tit('should redirect to account page with logged in user', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/login`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert.equal(res.headers['x-redirect'], '/user/foo');\n\t\t\t\tassert.equal(body, '/user/foo');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should 404 if uid is not a number', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/uid/test`, { json: true }, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should redirect to userslug', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/uid/${fooUid}`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert.equal(res.headers['x-redirect'], '/user/foo');\n\t\t\t\tassert.equal(body, '/user/foo');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should redirect to userslug and keep query params', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/uid/${fooUid}/topics?foo=bar`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert.equal(res.headers['x-redirect'], '/user/foo/topics?foo=bar');\n\t\t\t\tassert.equal(body, '/user/foo/topics?foo=bar');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should 404 if user does not exist', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/uid/123123`, { json: true }, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tdescribe('/me/*', () => {\n\t\t\tit('should redirect to user profile', (done) => {\n\t\t\t\trequest(`${nconf.get('url')}/me`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert(body.includes('\"template\":{\"name\":\"account/profile\",\"account/profile\":true}'));\n\t\t\t\t\tassert(body.includes('\"username\":\"foo\"'));\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t\tit('api should redirect to /user/[userslug]/bookmarks', (done) => {\n\t\t\t\trequest(`${nconf.get('url')}/api/me/bookmarks`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert.equal(res.headers['x-redirect'], '/user/foo/bookmarks');\n\t\t\t\t\tassert.equal(body, '/user/foo/bookmarks');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t\tit('api should redirect to /user/[userslug]/edit/username', (done) => {\n\t\t\t\trequest(`${nconf.get('url')}/api/me/edit/username`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert.equal(res.headers['x-redirect'], '/user/foo/edit/username');\n\t\t\t\t\tassert.equal(body, '/user/foo/edit/username');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t\tit('should redirect to login if user is not logged in', (done) => {\n\t\t\t\trequest(`${nconf.get('url')}/me/bookmarks`, { json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert(body.includes('Login to your account'), body.slice(0, 500));\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should 401 if user is not logged in', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/admin`, { json: true }, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 401);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should 403 if user is not admin', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/admin`, { jar: jar, json: true }, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 403);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/posts', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/posts`, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should 401 if not logged in', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/bookmarks`, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 401);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/bookmarks', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/bookmarks`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/upvoted', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/upvoted`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/downvoted', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/downvoted`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/best', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/best`, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/controversial', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/controversial`, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/watched', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/watched`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/ignored', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/ignored`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/topics', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/topics`, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/blocks', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/blocks`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/consent', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/consent`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/sessions', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/sessions`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/categories', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/categories`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/uploads', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/uploads`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should export users posts', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/export/posts`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should export users uploads', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/export/uploads`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should export users profile', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/export/profile`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load notifications page', (done) => {\n\t\t\tconst notifications = require('../src/notifications');\n\t\t\tconst notifData = {\n\t\t\t\tbodyShort: '[[notifications:user_posted_to, test1, test2]]',\n\t\t\t\tbodyLong: 'some post content',\n\t\t\t\tpid: 1,\n\t\t\t\tpath: `/post/${1}`,\n\t\t\t\tnid: `new_post:tid:${1}:pid:${1}:uid:${fooUid}`,\n\t\t\t\ttid: 1,\n\t\t\t\tfrom: fooUid,\n\t\t\t\tmergeId: `notifications:user_posted_to|${1}`,\n\t\t\t\ttopicTitle: 'topic title',\n\t\t\t};\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\tnotifications.create(notifData, next);\n\t\t\t\t},\n\t\t\t\tfunction (notification, next) {\n\t\t\t\t\tnotifications.push(notification, fooUid, next);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\tsetTimeout(next, 2500);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\trequest(`${nconf.get('url')}/api/notifications`, { jar: jar, json: true }, next);\n\t\t\t\t},\n\t\t\t\tfunction (res, body, next) {\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert(body);\n\t\t\t\t\tconst notif = body.notifications[0];\n\t\t\t\t\tassert.equal(notif.bodyShort, notifData.bodyShort);\n\t\t\t\t\tassert.equal(notif.bodyLong, notifData.bodyLong);\n\t\t\t\t\tassert.equal(notif.pid, notifData.pid);\n\t\t\t\t\tassert.equal(notif.path, nconf.get('relative_path') + notifData.path);\n\t\t\t\t\tassert.equal(notif.nid, notifData.nid);\n\t\t\t\t\tnext();\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should 404 if user does not exist', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/email/doesnotexist`, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load user by uid', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/uid/${fooUid}`, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load user by username', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/username/foo`, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should NOT load user by email (by default)', async () => {\n\t\t\tconst res = await requestAsync(`${nconf.get('url')}/api/user/email/foo@test.com`, {\n\t\t\t\tresolveWithFullResponse: true,\n\t\t\t\tsimple: false,\n\t\t\t});\n\n\t\t\tassert.strictEqual(res.statusCode, 404);\n\t\t});\n\n\t\tit('should load user by email if user has elected to show their email', async () => {\n\t\t\tawait user.setSetting(fooUid, 'showemail', 1);\n\t\t\tconst res = await requestAsync(`${nconf.get('url')}/api/user/email/foo@test.com`, {\n\t\t\t\tresolveWithFullResponse: true,\n\t\t\t});\n\t\t\tassert.strictEqual(res.statusCode, 200);\n\t\t\tassert(res.body);\n\t\t\tawait user.setSetting(fooUid, 'showemail', 0);\n\t\t});\n\n\t\tit('should return 401 if user does not have view:users privilege', (done) => {\n\t\t\tprivileges.global.rescind(['groups:view:users'], 'guests', (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\trequest(`${nconf.get('url')}/api/user/foo`, { json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 401);\n\t\t\t\t\tassert.deepEqual(body, {\n\t\t\t\t\t\tresponse: {},\n\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\tcode: 'not-authorised',\n\t\t\t\t\t\t\tmessage: 'A valid login session was not found. Please log in and try again.',\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t\tprivileges.global.give(['groups:view:users'], 'guests', done);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should return false if user can not edit user', (done) => {\n\t\t\tuser.create({ username: 'regularJoe', password: 'barbar' }, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\thelpers.loginUser('regularJoe', 'barbar', (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tconst { jar } = data;\n\t\t\t\t\trequest(`${nconf.get('url')}/api/user/foo/info`, { jar: jar, json: true }, (err, res) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(res.statusCode, 403);\n\t\t\t\t\t\trequest(`${nconf.get('url')}/api/user/foo/edit`, { jar: jar, json: true }, (err, res) => {\n\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\tassert.equal(res.statusCode, 403);\n\t\t\t\t\t\t\tdone();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should load correct user', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/FOO`, { jar: jar, json: true }, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should redirect', (done) => {\n\t\t\trequest(`${nconf.get('url')}/user/FOO`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should 404 if user does not exist', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/doesnotexist`, { jar: jar }, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should not increase profile view if you visit your own profile', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo`, { jar: jar }, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tuser.getUserField(fooUid, 'profileviews', (err, viewcount) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert(viewcount === 0);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t}, 500);\n\t\t\t});\n\t\t});\n\n\t\tit('should not increase profile view if a guest visits a profile', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo`, {}, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tuser.getUserField(fooUid, 'profileviews', (err, viewcount) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert(viewcount === 0);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t}, 500);\n\t\t\t});\n\t\t});\n\n\t\tit('should increase profile view', (done) => {\n\t\t\thelpers.loginUser('regularJoe', 'barbar', (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tconst { jar } = data;\n\t\t\t\trequest(`${nconf.get('url')}/api/user/foo`, { jar: jar }, (err, res) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tuser.getUserField(fooUid, 'profileviews', (err, viewcount) => {\n\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\tassert(viewcount > 0);\n\t\t\t\t\t\t\tdone();\n\t\t\t\t\t\t});\n\t\t\t\t\t}, 500);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should parse about me', (done) => {\n\t\t\tuser.setUserFields(fooUid, { picture: '/path/to/picture', aboutme: 'hi i am a bot' }, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\trequest(`${nconf.get('url')}/api/user/foo`, { json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert.equal(body.aboutme, 'hi i am a bot');\n\t\t\t\t\tassert.equal(body.picture, '/path/to/picture');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should not return reputation if reputation is disabled', (done) => {\n\t\t\tmeta.config['reputation:disabled'] = 1;\n\t\t\trequest(`${nconf.get('url')}/api/user/foo`, { json: true }, (err, res, body) => {\n\t\t\t\tmeta.config['reputation:disabled'] = 0;\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(!body.hasOwnProperty('reputation'));\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should only return posts that are not deleted', (done) => {\n\t\t\tlet topicData;\n\t\t\tlet pidToDelete;\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\ttopics.post({ uid: fooUid, title: 'visible', content: 'some content', cid: cid }, next);\n\t\t\t\t},\n\t\t\t\tfunction (data, next) {\n\t\t\t\t\ttopicData = data.topicData;\n\t\t\t\t\ttopics.reply({ uid: fooUid, content: '1st reply', tid: topicData.tid }, next);\n\t\t\t\t},\n\t\t\t\tfunction (postData, next) {\n\t\t\t\t\tpidToDelete = postData.pid;\n\t\t\t\t\ttopics.reply({ uid: fooUid, content: '2nd reply', tid: topicData.tid }, next);\n\t\t\t\t},\n\t\t\t\tfunction (postData, next) {\n\t\t\t\t\tposts.delete(pidToDelete, fooUid, next);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\trequest(`${nconf.get('url')}/api/user/foo`, { json: true }, (err, res, body) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\t\tconst contents = body.posts.map(p => p.content);\n\t\t\t\t\t\tassert(!contents.includes('1st reply'));\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should return selected group title', (done) => {\n\t\t\tgroups.create({\n\t\t\t\tname: 'selectedGroup',\n\t\t\t}, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tuser.create({ username: 'groupie' }, (err, uid) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tgroups.join('selectedGroup', uid, (err) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\trequest(`${nconf.get('url')}/api/user/groupie`, { json: true }, (err, res, body) => {\n\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\t\t\tassert(Array.isArray(body.selectedGroup));\n\t\t\t\t\t\t\tassert.equal(body.selectedGroup[0].name, 'selectedGroup');\n\t\t\t\t\t\t\tdone();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should 404 if user does not exist', (done) => {\n\t\t\tgroups.join('administrators', fooUid, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\trequest(`${nconf.get('url')}/api/user/doesnotexist/edit`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\t\tgroups.leave('administrators', fooUid, done);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should render edit/password', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/edit/password`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should render edit/email', async () => {\n\t\t\tconst res = await requestAsync(`${nconf.get('url')}/api/user/foo/edit/email`, {\n\t\t\t\tjar,\n\t\t\t\tjson: true,\n\t\t\t\tresolveWithFullResponse: true,\n\t\t\t});\n\n\t\t\tassert.strictEqual(res.statusCode, 200);\n\t\t\tassert.strictEqual(res.body, '/register/complete');\n\n\t\t\tawait requestAsync({\n\t\t\t\turi: `${nconf.get('url')}/register/abort`,\n\t\t\t\tmethod: 'post',\n\t\t\t\tjar,\n\t\t\t\tsimple: false,\n\t\t\t});\n\t\t});\n\n\t\tit('should render edit/username', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/edit/username`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('account follow page', () => {\n\t\tconst socketUser = require('../src/socket.io/user');\n\t\tconst apiUser = require('../src/api/users');\n\t\tlet uid;\n\t\tbefore(async () => {\n\t\t\tuid = await user.create({ username: 'follower' });\n\t\t\tawait apiUser.follow({ uid: uid }, { uid: fooUid });\n\t\t\tconst isFollowing = await socketUser.isFollowing({ uid: uid }, { uid: fooUid });\n\t\t\tassert(isFollowing);\n\t\t});\n\n\t\tit('should get followers page', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/followers`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert.equal(body.users[0].username, 'follower');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should get following page', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/follower/following`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert.equal(body.users[0].username, 'foo');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return empty after unfollow', async () => {\n\t\t\tawait apiUser.unfollow({ uid: uid }, { uid: fooUid });\n\t\t\tconst { res, body } = await helpers.request('get', `/api/user/foo/followers`, { json: true });\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert.equal(body.users.length, 0);\n\t\t});\n\t});\n\n\tdescribe('post redirect', () => {\n\t\tlet jar;\n\t\tbefore(async () => {\n\t\t\t({ jar } = await helpers.loginUser('foo', 'barbar'));\n\t\t});\n\n\t\tit('should 404 for invalid pid', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/post/fail`, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should 403 if user does not have read privilege', (done) => {\n\t\t\tprivileges.categories.rescind(['groups:topics:read'], category.cid, 'registered-users', (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\trequest(`${nconf.get('url')}/api/post/${pid}`, { jar: jar }, (err, res) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 403);\n\t\t\t\t\tprivileges.categories.give(['groups:topics:read'], category.cid, 'registered-users', done);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should return correct post path', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/post/${pid}`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert.equal(res.headers['x-redirect'], '/topic/1/test-topic-title/1');\n\t\t\t\tassert.equal(body, '/topic/1/test-topic-title/1');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('cookie consent', () => {\n\t\tit('should return relevant data in configs API route', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/config`, (err, res, body) => {\n\t\t\t\tlet parsed;\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\n\t\t\t\ttry {\n\t\t\t\t\tparsed = JSON.parse(body);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tassert.ifError(e);\n\t\t\t\t}\n\n\t\t\t\tassert.ok(parsed.cookies);\n\t\t\t\tassert.equal(translator.escape('[[global:cookies.message]]'), parsed.cookies.message);\n\t\t\t\tassert.equal(translator.escape('[[global:cookies.accept]]'), parsed.cookies.dismiss);\n\t\t\t\tassert.equal(translator.escape('[[global:cookies.learn_more]]'), parsed.cookies.link);\n\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('response should be parseable when entries have apostrophes', (done) => {\n\t\t\tmeta.configs.set('cookieConsentMessage', 'Julian\\'s Message', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\trequest(`${nconf.get('url')}/api/config`, (err, res, body) => {\n\t\t\t\t\tlet parsed;\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tparsed = JSON.parse(body);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tassert.ifError(e);\n\t\t\t\t\t}\n\n\t\t\t\t\tassert.equal('Julian&#x27;s Message', parsed.cookies.message);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should return osd data', (done) => {\n\t\trequest(`${nconf.get('url')}/osd.xml`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tdescribe('handle errors', () => {\n\t\tconst plugins = require('../src/plugins');\n\t\tafter((done) => {\n\t\t\tplugins.loadedHooks['filter:router.page'] = undefined;\n\t\t\tdone();\n\t\t});\n\n\t\tit('should handle topic malformed uri', (done) => {\n\t\t\trequest(`${nconf.get('url')}/topic/1/a%AFc`, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should handle category malformed uri', (done) => {\n\t\t\trequest(`${nconf.get('url')}/category/1/a%AFc`, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should handle malformed uri ', (done) => {\n\t\t\trequest(`${nconf.get('url')}/user/a%AFc`, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(body);\n\t\t\t\tassert.equal(res.statusCode, 400);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should handle malformed uri in api', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/a%AFc`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 400);\n\t\t\t\tassert.equal(body.error, '[[global:400.title]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should handle CSRF error', (done) => {\n\t\t\tplugins.loadedHooks['filter:router.page'] = plugins.loadedHooks['filter:router.page'] || [];\n\t\t\tplugins.loadedHooks['filter:router.page'].push({\n\t\t\t\tmethod: function (req, res, next) {\n\t\t\t\t\tconst err = new Error('csrf-error');\n\t\t\t\t\terr.code = 'EBADCSRFTOKEN';\n\t\t\t\t\tnext(err);\n\t\t\t\t},\n\t\t\t});\n\n\t\t\trequest(`${nconf.get('url')}/users`, {}, (err, res) => {\n\t\t\t\tplugins.loadedHooks['filter:router.page'] = [];\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 403);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should handle black-list error', (done) => {\n\t\t\tplugins.loadedHooks['filter:router.page'] = plugins.loadedHooks['filter:router.page'] || [];\n\t\t\tplugins.loadedHooks['filter:router.page'].push({\n\t\t\t\tmethod: function (req, res, next) {\n\t\t\t\t\tconst err = new Error('blacklist error message');\n\t\t\t\t\terr.code = 'blacklisted-ip';\n\t\t\t\t\tnext(err);\n\t\t\t\t},\n\t\t\t});\n\n\t\t\trequest(`${nconf.get('url')}/users`, {}, (err, res, body) => {\n\t\t\t\tplugins.loadedHooks['filter:router.page'] = [];\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 403);\n\t\t\t\tassert.equal(body, 'blacklist error message');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should handle page redirect through error', (done) => {\n\t\t\tplugins.loadedHooks['filter:router.page'] = plugins.loadedHooks['filter:router.page'] || [];\n\t\t\tplugins.loadedHooks['filter:router.page'].push({\n\t\t\t\tmethod: function (req, res, next) {\n\t\t\t\t\tconst err = new Error('redirect');\n\t\t\t\t\terr.status = 302;\n\t\t\t\t\terr.path = '/popular';\n\t\t\t\t\tplugins.loadedHooks['filter:router.page'] = [];\n\t\t\t\t\tnext(err);\n\t\t\t\t},\n\t\t\t});\n\n\t\t\trequest(`${nconf.get('url')}/users`, {}, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should handle api page redirect through error', (done) => {\n\t\t\tplugins.loadedHooks['filter:router.page'] = plugins.loadedHooks['filter:router.page'] || [];\n\t\t\tplugins.loadedHooks['filter:router.page'].push({\n\t\t\t\tmethod: function (req, res, next) {\n\t\t\t\t\tconst err = new Error('redirect');\n\t\t\t\t\terr.status = 308;\n\t\t\t\t\terr.path = '/api/popular';\n\t\t\t\t\tplugins.loadedHooks['filter:router.page'] = [];\n\t\t\t\t\tnext(err);\n\t\t\t\t},\n\t\t\t});\n\n\t\t\trequest(`${nconf.get('url')}/api/users`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert.equal(res.headers['x-redirect'], '/api/popular');\n\t\t\t\tassert(body, '/api/popular');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should handle error page', (done) => {\n\t\t\tplugins.loadedHooks['filter:router.page'] = plugins.loadedHooks['filter:router.page'] || [];\n\t\t\tplugins.loadedHooks['filter:router.page'].push({\n\t\t\t\tmethod: function (req, res, next) {\n\t\t\t\t\tconst err = new Error('regular error');\n\t\t\t\t\tnext(err);\n\t\t\t\t},\n\t\t\t});\n\n\t\t\trequest(`${nconf.get('url')}/users`, (err, res, body) => {\n\t\t\t\tplugins.loadedHooks['filter:router.page'] = [];\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 500);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('category', () => {\n\t\tlet jar;\n\t\tbefore(async () => {\n\t\t\t({ jar } = await helpers.loginUser('foo', 'barbar'));\n\t\t});\n\n\t\tit('should return 404 if cid is not a number', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/category/fail`, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return 404 if topic index is not a number', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/category/${category.slug}/invalidtopicindex`, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should 404 if category does not exist', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/category/123123`, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should 404 if category is disabled', (done) => {\n\t\t\tcategories.create({ name: 'disabled' }, (err, category) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tcategories.setCategoryField(category.cid, 'disabled', 1, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\trequest(`${nconf.get('url')}/api/category/${category.slug}`, (err, res) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should return 401 if not allowed to read', (done) => {\n\t\t\tcategories.create({ name: 'hidden' }, (err, category) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tprivileges.categories.rescind(['groups:read'], category.cid, 'guests', (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\trequest(`${nconf.get('url')}/api/category/${category.slug}`, (err, res) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(res.statusCode, 401);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should redirect if topic index is negative', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/category/${category.slug}/-10`, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert.ok(res.headers['x-redirect']);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should 404 if page is not found', (done) => {\n\t\t\tuser.setSetting(fooUid, 'usePagination', 1, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\trequest(`${nconf.get('url')}/api/category/${category.slug}?page=100`, { jar: jar, json: true }, (err, res) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should load page 1 if req.query.page is not sent', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/category/${category.slug}`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert.equal(body.pagination.currentPage, 1);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should sort topics by most posts', (done) => {\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\tcategories.create({ name: 'most-posts-category' }, next);\n\t\t\t\t},\n\t\t\t\tfunction (category, next) {\n\t\t\t\t\tasync.waterfall([\n\t\t\t\t\t\tfunction (next) {\n\t\t\t\t\t\t\ttopics.post({ uid: fooUid, cid: category.cid, title: 'topic 1', content: 'topic 1 OP' }, next);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (data, next) {\n\t\t\t\t\t\t\ttopics.post({ uid: fooUid, cid: category.cid, title: 'topic 2', content: 'topic 2 OP' }, next);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (data, next) {\n\t\t\t\t\t\t\ttopics.reply({ uid: fooUid, content: 'topic 2 reply', tid: data.topicData.tid }, next);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (postData, next) {\n\t\t\t\t\t\t\trequest(`${nconf.get('url')}/api/category/${category.slug}?sort=most_posts`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\t\t\t\tassert.equal(body.topics[0].title, 'topic 2');\n\t\t\t\t\t\t\t\tassert.equal(body.topics[0].postcount, 2);\n\t\t\t\t\t\t\t\tassert.equal(body.topics[1].postcount, 1);\n\t\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t], (err) => {\n\t\t\t\t\t\tnext(err);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should load a specific users topics from a category with tags', (done) => {\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\tcategories.create({ name: 'filtered-category' }, next);\n\t\t\t\t},\n\t\t\t\tfunction (category, next) {\n\t\t\t\t\tasync.waterfall([\n\t\t\t\t\t\tfunction (next) {\n\t\t\t\t\t\t\ttopics.post({ uid: fooUid, cid: category.cid, title: 'topic 1', content: 'topic 1 OP', tags: ['java', 'cpp'] }, next);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (data, next) {\n\t\t\t\t\t\t\ttopics.post({ uid: fooUid, cid: category.cid, title: 'topic 2', content: 'topic 2 OP', tags: ['node', 'javascript'] }, next);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (data, next) {\n\t\t\t\t\t\t\ttopics.post({ uid: fooUid, cid: category.cid, title: 'topic 3', content: 'topic 3 OP', tags: ['java', 'cpp', 'best'] }, next);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (data, next) {\n\t\t\t\t\t\t\trequest(`${nconf.get('url')}/api/category/${category.slug}?tag=node&author=foo`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\t\t\t\tassert.equal(body.topics[0].title, 'topic 2');\n\t\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (next) {\n\t\t\t\t\t\t\trequest(`${nconf.get('url')}/api/category/${category.slug}?tag[]=java&tag[]=cpp`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\t\t\t\tassert.equal(body.topics[0].title, 'topic 3');\n\t\t\t\t\t\t\t\tassert.equal(body.topics[1].title, 'topic 1');\n\t\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t], (err) => {\n\t\t\t\t\t\tnext(err);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should redirect if category is a link', (done) => {\n\t\t\tlet cid;\n\t\t\tlet category;\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\tcategories.create({ name: 'redirect', link: 'https://nodebb.org' }, next);\n\t\t\t\t},\n\t\t\t\tfunction (_category, next) {\n\t\t\t\t\tcategory = _category;\n\t\t\t\t\tcid = category.cid;\n\t\t\t\t\trequest(`${nconf.get('url')}/api/category/${category.slug}`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\t\tassert.equal(res.headers['x-redirect'], 'https://nodebb.org');\n\t\t\t\t\t\tassert.equal(body, 'https://nodebb.org');\n\t\t\t\t\t\tnext();\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\tcategories.setCategoryField(cid, 'link', '/recent', next);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\trequest(`${nconf.get('url')}/api/category/${category.slug}`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\t\tassert.equal(res.headers['x-redirect'], '/recent');\n\t\t\t\t\t\tassert.equal(body, '/recent');\n\t\t\t\t\t\tnext();\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should get recent topic replies from children categories', (done) => {\n\t\t\tlet parentCategory;\n\t\t\tlet childCategory1;\n\t\t\tlet childCategory2;\n\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\tcategories.create({ name: 'parent category', backgroundImage: 'path/to/some/image' }, next);\n\t\t\t\t},\n\t\t\t\tfunction (category, next) {\n\t\t\t\t\tparentCategory = category;\n\t\t\t\t\tasync.waterfall([\n\t\t\t\t\t\tfunction (next) {\n\t\t\t\t\t\t\tcategories.create({ name: 'child category 1', parentCid: category.cid }, next);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (category, next) {\n\t\t\t\t\t\t\tchildCategory1 = category;\n\t\t\t\t\t\t\tcategories.create({ name: 'child category 2', parentCid: parentCategory.cid }, next);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (category, next) {\n\t\t\t\t\t\t\tchildCategory2 = category;\n\t\t\t\t\t\t\ttopics.post({ uid: fooUid, cid: childCategory2.cid, title: 'topic 1', content: 'topic 1 OP' }, next);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (data, next) {\n\t\t\t\t\t\t\trequest(`${nconf.get('url')}/api/category/${parentCategory.slug}`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\t\t\t\tassert.equal(body.children[0].posts[0].content, 'topic 1 OP');\n\t\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t], (err) => {\n\t\t\t\t\t\tnext(err);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should create 2 pages of topics', (done) => {\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\tcategories.create({ name: 'category with 2 pages' }, next);\n\t\t\t\t},\n\t\t\t\tfunction (category, next) {\n\t\t\t\t\tconst titles = [];\n\t\t\t\t\tfor (let i = 0; i < 30; i++) {\n\t\t\t\t\t\ttitles.push(`topic title ${i}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tasync.waterfall([\n\t\t\t\t\t\tfunction (next) {\n\t\t\t\t\t\t\tasync.eachSeries(titles, (title, next) => {\n\t\t\t\t\t\t\t\ttopics.post({ uid: fooUid, cid: category.cid, title: title, content: 'does not really matter' }, next);\n\t\t\t\t\t\t\t}, next);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (next) {\n\t\t\t\t\t\t\tuser.getSettings(fooUid, next);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (settings, next) {\n\t\t\t\t\t\t\trequest(`${nconf.get('url')}/api/category/${category.slug}`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\t\t\t\tassert.equal(body.topics.length, settings.topicsPerPage);\n\t\t\t\t\t\t\t\tassert.equal(body.pagination.pageCount, 2);\n\t\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t], (err) => {\n\t\t\t\t\t\tnext(err);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should load categories', async () => {\n\t\t\tconst helpers = require('../src/controllers/helpers');\n\t\t\tconst data = await helpers.getCategories('cid:0:children', 1, 'topics:read', 0);\n\t\t\tassert(data.categories.length > 0);\n\t\t\tassert.strictEqual(data.selectedCategory, null);\n\t\t\tassert.deepStrictEqual(data.selectedCids, []);\n\t\t});\n\n\t\tit('should load categories by states', async () => {\n\t\t\tconst helpers = require('../src/controllers/helpers');\n\t\t\tconst data = await helpers.getCategoriesByStates(1, 1, Object.values(categories.watchStates), 'topics:read');\n\t\t\tassert.deepStrictEqual(data.selectedCategory.cid, 1);\n\t\t\tassert.deepStrictEqual(data.selectedCids, [1]);\n\t\t});\n\n\t\tit('should load categories by states', async () => {\n\t\t\tconst helpers = require('../src/controllers/helpers');\n\t\t\tconst data = await helpers.getCategoriesByStates(1, 0, [categories.watchStates.ignoring], 'topics:read');\n\t\t\tassert(data.categories.length === 0);\n\t\t\tassert.deepStrictEqual(data.selectedCategory, null);\n\t\t\tassert.deepStrictEqual(data.selectedCids, []);\n\t\t});\n\t});\n\n\tdescribe('unread', () => {\n\t\tlet jar;\n\t\tbefore(async () => {\n\t\t\t({ jar } = await helpers.loginUser('foo', 'barbar'));\n\t\t});\n\n\t\tit('should load unread page', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/unread`, { jar: jar }, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should 404 if filter is invalid', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/unread/doesnotexist`, { jar: jar }, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return total unread count', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/unread/total?filter=new`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert.equal(body, 0);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should redirect if page is out of bounds', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/unread?page=-1`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert.equal(res.headers['x-redirect'], '/unread?page=1');\n\t\t\t\tassert.equal(body, '/unread?page=1');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('admin middlewares', () => {\n\t\tit('should redirect to login', (done) => {\n\t\t\trequest(`${nconf.get('url')}//api/admin/advanced/database`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 401);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should redirect to login', (done) => {\n\t\t\trequest(`${nconf.get('url')}//admin/advanced/database`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body.includes('Login to your account'));\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('composer', () => {\n\t\tlet csrf_token;\n\t\tlet jar;\n\n\t\tbefore(async () => {\n\t\t\tconst login = await helpers.loginUser('foo', 'barbar');\n\t\t\tjar = login.jar;\n\t\t\tcsrf_token = login.csrf_token;\n\t\t});\n\n\t\tit('should load the composer route', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/compose?cid=1`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body.title);\n\t\t\t\tassert(body.template);\n\t\t\t\tassert.equal(body.url, `${nconf.get('relative_path')}/compose`);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load the composer route if disabled by plugin', (done) => {\n\t\t\tfunction hookMethod(hookData, callback) {\n\t\t\t\thookData.templateData.disabled = true;\n\t\t\t\tcallback(null, hookData);\n\t\t\t}\n\n\t\t\tplugins.hooks.register('myTestPlugin', {\n\t\t\t\thook: 'filter:composer.build',\n\t\t\t\tmethod: hookMethod,\n\t\t\t});\n\n\t\t\trequest(`${nconf.get('url')}/api/compose?cid=1`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body.title);\n\t\t\t\tassert.strictEqual(body.template.name, '');\n\t\t\t\tassert.strictEqual(body.url, `${nconf.get('relative_path')}/compose`);\n\n\t\t\t\tplugins.hooks.unregister('myTestPlugin', 'filter:composer.build', hookMethod);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error with invalid data', (done) => {\n\t\t\trequest.post(`${nconf.get('url')}/compose`, {\n\t\t\t\tform: {\n\t\t\t\t\tcontent: 'a new reply',\n\t\t\t\t},\n\t\t\t\tjar: jar,\n\t\t\t\theaders: {\n\t\t\t\t\t'x-csrf-token': csrf_token,\n\t\t\t\t},\n\t\t\t}, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 400);\n\t\t\t\trequest.post(`${nconf.get('url')}/compose`, {\n\t\t\t\t\tform: {\n\t\t\t\t\t\ttid: tid,\n\t\t\t\t\t},\n\t\t\t\t\tjar: jar,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'x-csrf-token': csrf_token,\n\t\t\t\t\t},\n\t\t\t\t}, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 400);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should create a new topic and reply by composer route', (done) => {\n\t\t\tconst data = {\n\t\t\t\tcid: cid,\n\t\t\t\ttitle: 'no js is good',\n\t\t\t\tcontent: 'a topic with noscript',\n\t\t\t};\n\t\t\trequest.post(`${nconf.get('url')}/compose`, {\n\t\t\t\tform: data,\n\t\t\t\tjar: jar,\n\t\t\t\theaders: {\n\t\t\t\t\t'x-csrf-token': csrf_token,\n\t\t\t\t},\n\t\t\t}, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 302);\n\t\t\t\trequest.post(`${nconf.get('url')}/compose`, {\n\t\t\t\t\tform: {\n\t\t\t\t\t\ttid: tid,\n\t\t\t\t\t\tcontent: 'a new reply',\n\t\t\t\t\t},\n\t\t\t\t\tjar: jar,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'x-csrf-token': csrf_token,\n\t\t\t\t\t},\n\t\t\t\t}, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 302);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('test routes', () => {\n\t\tif (process.env.NODE_ENV === 'development') {\n\t\t\tit('should load debug route', (done) => {\n\t\t\t\trequest(`${nconf.get('url')}/debug/test`, {}, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\t\tassert(body);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should load redoc read route', (done) => {\n\t\t\t\trequest(`${nconf.get('url')}/debug/spec/read`, {}, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert(body);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should load redoc write route', (done) => {\n\t\t\t\trequest(`${nconf.get('url')}/debug/spec/write`, {}, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert(body);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should load 404 for invalid type', (done) => {\n\t\t\t\trequest(`${nconf.get('url')}/debug/spec/doesnotexist`, {}, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\t\tassert(body);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t});\n\n\tafter((done) => {\n\t\tconst analytics = require('../src/analytics');\n\t\tanalytics.writeData(done);\n\t});\n});\n", "'use strict';\n\nconst assert = require('assert');\nconst async = require('async');\nconst fs = require('fs');\nconst path = require('path');\nconst nconf = require('nconf');\nconst validator = require('validator');\nconst request = require('request');\nconst requestAsync = require('request-promise-native');\nconst jwt = require('jsonwebtoken');\n\nconst db = require('./mocks/databasemock');\nconst User = require('../src/user');\nconst Topics = require('../src/topics');\nconst Categories = require('../src/categories');\nconst Posts = require('../src/posts');\nconst Password = require('../src/password');\nconst groups = require('../src/groups');\nconst messaging = require('../src/messaging');\nconst helpers = require('./helpers');\nconst meta = require('../src/meta');\nconst file = require('../src/file');\nconst socketUser = require('../src/socket.io/user');\nconst apiUser = require('../src/api/users');\nconst utils = require('../src/utils');\n\ndescribe('User', () => {\n\tlet userData;\n\tlet testUid;\n\tlet testCid;\n\n\tconst plugins = require('../src/plugins');\n\n\tasync function dummyEmailerHook(data) {\n\t\t// pretend to handle sending emails\n\t}\n\tbefore((done) => {\n\t\t// Attach an emailer hook so related requests do not error\n\t\tplugins.hooks.register('emailer-test', {\n\t\t\thook: 'filter:email.send',\n\t\t\tmethod: dummyEmailerHook,\n\t\t});\n\n\t\tCategories.create({\n\t\t\tname: 'Test Category',\n\t\t\tdescription: 'A test',\n\t\t\torder: 1,\n\t\t}, (err, categoryObj) => {\n\t\t\tif (err) {\n\t\t\t\treturn done(err);\n\t\t\t}\n\n\t\t\ttestCid = categoryObj.cid;\n\t\t\tdone();\n\t\t});\n\t});\n\tafter(() => {\n\t\tplugins.hooks.unregister('emailer-test', 'filter:email.send');\n\t});\n\n\tbeforeEach(() => {\n\t\tuserData = {\n\t\t\tusername: 'John Smith',\n\t\t\tfullname: 'John Smith McNamara',\n\t\t\tpassword: 'swordfish',\n\t\t\temail: 'john@example.com',\n\t\t\tcallback: undefined,\n\t\t};\n\t});\n\n\tconst goodImage = 'data:image/png;base64,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';\n\n\tdescribe('.create(), when created', () => {\n\t\tit('should be created properly', async () => {\n\t\t\ttestUid = await User.create({ username: userData.username, password: userData.password });\n\t\t\tassert.ok(testUid);\n\n\t\t\tawait User.setUserField(testUid, 'email', userData.email);\n\t\t\tawait User.email.confirmByUid(testUid);\n\t\t});\n\n\t\tit('should be created properly', async () => {\n\t\t\tconst email = '<h1>test</h1>@gmail.com';\n\t\t\tconst uid = await User.create({ username: 'weirdemail', email: email });\n\t\t\tconst data = await User.getUserData(uid);\n\n\t\t\tconst validationPending = await User.email.isValidationPending(uid, email);\n\t\t\tassert.strictEqual(validationPending, true);\n\n\t\t\tassert.equal(data.email, '&lt;h1&gt;test&lt;&#x2F;h1&gt;@gmail.com');\n\t\t\tassert.strictEqual(data.profileviews, 0);\n\t\t\tassert.strictEqual(data.reputation, 0);\n\t\t\tassert.strictEqual(data.postcount, 0);\n\t\t\tassert.strictEqual(data.topiccount, 0);\n\t\t\tassert.strictEqual(data.lastposttime, 0);\n\t\t\tassert.strictEqual(data.banned, false);\n\t\t});\n\n\t\tit('should have a valid email, if using an email', (done) => {\n\t\t\tUser.create({ username: userData.username, password: userData.password, email: 'fakeMail' }, (err) => {\n\t\t\t\tassert(err);\n\t\t\t\tassert.equal(err.message, '[[error:invalid-email]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error with invalid password', (done) => {\n\t\t\tUser.create({ username: 'test', password: '1' }, (err) => {\n\t\t\t\tassert.equal(err.message, '[[reset_password:password_too_short]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error with invalid password', (done) => {\n\t\t\tUser.create({ username: 'test', password: {} }, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-password]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error with a too long password', (done) => {\n\t\t\tlet toolong = '';\n\t\t\tfor (let i = 0; i < 5000; i++) {\n\t\t\t\ttoolong += 'a';\n\t\t\t}\n\t\t\tUser.create({ username: 'test', password: toolong }, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:password-too-long]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error if username is already taken or rename user', async () => {\n\t\t\tlet err;\n\t\t\tasync function tryCreate(data) {\n\t\t\t\ttry {\n\t\t\t\t\treturn await User.create(data);\n\t\t\t\t} catch (_err) {\n\t\t\t\t\terr = _err;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst [uid1, uid2] = await Promise.all([\n\t\t\t\ttryCreate({ username: 'dupe1' }),\n\t\t\t\ttryCreate({ username: 'dupe1' }),\n\t\t\t]);\n\t\t\tif (err) {\n\t\t\t\tassert.strictEqual(err.message, '[[error:username-taken]]');\n\t\t\t} else {\n\t\t\t\tconst userData = await User.getUsersFields([uid1, uid2], ['username']);\n\t\t\t\tconst userNames = userData.map(u => u.username);\n\t\t\t\t// make sure only 1 dupe1 is created\n\t\t\t\tassert.equal(userNames.filter(username => username === 'dupe1').length, 1);\n\t\t\t\tassert.equal(userNames.filter(username => username === 'dupe1 0').length, 1);\n\t\t\t}\n\t\t});\n\n\t\tit('should error if email is already taken', async () => {\n\t\t\tlet err;\n\t\t\tasync function tryCreate(data) {\n\t\t\t\ttry {\n\t\t\t\t\treturn await User.create(data);\n\t\t\t\t} catch (_err) {\n\t\t\t\t\terr = _err;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tawait Promise.all([\n\t\t\t\ttryCreate({ username: 'notdupe1', email: 'dupe@dupe.com' }),\n\t\t\t\ttryCreate({ username: 'notdupe2', email: 'dupe@dupe.com' }),\n\t\t\t]);\n\t\t\tassert.strictEqual(err.message, '[[error:email-taken]]');\n\t\t});\n\t});\n\n\tdescribe('.uniqueUsername()', () => {\n\t\tit('should deal with collisions', (done) => {\n\t\t\tconst users = [];\n\t\t\tfor (let i = 0; i < 10; i += 1) {\n\t\t\t\tusers.push({\n\t\t\t\t\tusername: 'Jane Doe',\n\t\t\t\t\temail: `jane.doe${i}@example.com`,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tasync.series([\n\t\t\t\tfunction (next) {\n\t\t\t\t\tasync.eachSeries(users, (user, next) => {\n\t\t\t\t\t\tUser.create(user, next);\n\t\t\t\t\t}, next);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\tUser.uniqueUsername({\n\t\t\t\t\t\tusername: 'Jane Doe',\n\t\t\t\t\t\tuserslug: 'jane-doe',\n\t\t\t\t\t}, (err, username) => {\n\t\t\t\t\t\tassert.ifError(err);\n\n\t\t\t\t\t\tassert.strictEqual(username, 'Jane Doe 9');\n\t\t\t\t\t\tnext();\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\t});\n\n\tdescribe('.isModerator()', () => {\n\t\tit('should return false', (done) => {\n\t\t\tUser.isModerator(testUid, testCid, (err, isModerator) => {\n\t\t\t\tassert.equal(err, null);\n\t\t\t\tassert.equal(isModerator, false);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return two false results', (done) => {\n\t\t\tUser.isModerator([testUid, testUid], testCid, (err, isModerator) => {\n\t\t\t\tassert.equal(err, null);\n\t\t\t\tassert.equal(isModerator[0], false);\n\t\t\t\tassert.equal(isModerator[1], false);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return two false results', (done) => {\n\t\t\tUser.isModerator(testUid, [testCid, testCid], (err, isModerator) => {\n\t\t\t\tassert.equal(err, null);\n\t\t\t\tassert.equal(isModerator[0], false);\n\t\t\t\tassert.equal(isModerator[1], false);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('.getModeratorUids()', () => {\n\t\tbefore((done) => {\n\t\t\tgroups.join('cid:1:privileges:moderate', 1, done);\n\t\t});\n\n\t\tit('should retrieve all users with moderator bit in category privilege', (done) => {\n\t\t\tUser.getModeratorUids((err, uids) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(1, uids.length);\n\t\t\t\tassert.strictEqual(1, parseInt(uids[0], 10));\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tafter((done) => {\n\t\t\tgroups.leave('cid:1:privileges:moderate', 1, done);\n\t\t});\n\t});\n\n\tdescribe('.getModeratorUids()', () => {\n\t\tbefore((done) => {\n\t\t\tasync.series([\n\t\t\t\tasync.apply(groups.create, { name: 'testGroup' }),\n\t\t\t\tasync.apply(groups.join, 'cid:1:privileges:groups:moderate', 'testGroup'),\n\t\t\t\tasync.apply(groups.join, 'testGroup', 1),\n\t\t\t], done);\n\t\t});\n\n\t\tit('should retrieve all users with moderator bit in category privilege', (done) => {\n\t\t\tUser.getModeratorUids((err, uids) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(1, uids.length);\n\t\t\t\tassert.strictEqual(1, parseInt(uids[0], 10));\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tafter((done) => {\n\t\t\tasync.series([\n\t\t\t\tasync.apply(groups.leave, 'cid:1:privileges:groups:moderate', 'testGroup'),\n\t\t\t\tasync.apply(groups.destroy, 'testGroup'),\n\t\t\t], done);\n\t\t});\n\t});\n\n\tdescribe('.isReadyToPost()', () => {\n\t\tit('should error when a user makes two posts in quick succession', (done) => {\n\t\t\tmeta.config = meta.config || {};\n\t\t\tmeta.config.postDelay = '10';\n\n\t\t\tasync.series([\n\t\t\t\tasync.apply(Topics.post, {\n\t\t\t\t\tuid: testUid,\n\t\t\t\t\ttitle: 'Topic 1',\n\t\t\t\t\tcontent: 'lorem ipsum',\n\t\t\t\t\tcid: testCid,\n\t\t\t\t}),\n\t\t\t\tasync.apply(Topics.post, {\n\t\t\t\t\tuid: testUid,\n\t\t\t\t\ttitle: 'Topic 2',\n\t\t\t\t\tcontent: 'lorem ipsum',\n\t\t\t\t\tcid: testCid,\n\t\t\t\t}),\n\t\t\t], (err) => {\n\t\t\t\tassert(err);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should allow a post if the last post time is > 10 seconds', (done) => {\n\t\t\tUser.setUserField(testUid, 'lastposttime', +new Date() - (11 * 1000), () => {\n\t\t\t\tTopics.post({\n\t\t\t\t\tuid: testUid,\n\t\t\t\t\ttitle: 'Topic 3',\n\t\t\t\t\tcontent: 'lorem ipsum',\n\t\t\t\t\tcid: testCid,\n\t\t\t\t}, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should error when a new user posts if the last post time is 10 < 30 seconds', (done) => {\n\t\t\tmeta.config.newbiePostDelay = 30;\n\t\t\tmeta.config.newbiePostDelayThreshold = 3;\n\n\t\t\tUser.setUserField(testUid, 'lastposttime', +new Date() - (20 * 1000), () => {\n\t\t\t\tTopics.post({\n\t\t\t\t\tuid: testUid,\n\t\t\t\t\ttitle: 'Topic 4',\n\t\t\t\t\tcontent: 'lorem ipsum',\n\t\t\t\t\tcid: testCid,\n\t\t\t\t}, (err) => {\n\t\t\t\t\tassert(err);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should not error if a non-newbie user posts if the last post time is 10 < 30 seconds', (done) => {\n\t\t\tUser.setUserFields(testUid, {\n\t\t\t\tlastposttime: +new Date() - (20 * 1000),\n\t\t\t\treputation: 10,\n\t\t\t}, () => {\n\t\t\t\tTopics.post({\n\t\t\t\t\tuid: testUid,\n\t\t\t\t\ttitle: 'Topic 5',\n\t\t\t\t\tcontent: 'lorem ipsum',\n\t\t\t\t\tcid: testCid,\n\t\t\t\t}, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('.search()', () => {\n\t\tlet adminUid;\n\t\tlet uid;\n\t\tbefore(async () => {\n\t\t\tadminUid = await User.create({ username: 'noteadmin' });\n\t\t\tawait groups.join('administrators', adminUid);\n\t\t});\n\n\t\tit('should return an object containing an array of matching users', (done) => {\n\t\t\tUser.search({ query: 'john' }, (err, searchData) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tuid = searchData.users[0].uid;\n\t\t\t\tassert.equal(Array.isArray(searchData.users) && searchData.users.length > 0, true);\n\t\t\t\tassert.equal(searchData.users[0].username, 'John Smith');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should search user', async () => {\n\t\t\tconst searchData = await apiUser.search({ uid: testUid }, { query: 'john' });\n\t\t\tassert.equal(searchData.users[0].username, 'John Smith');\n\t\t});\n\n\t\tit('should error for guest', async () => {\n\t\t\ttry {\n\t\t\t\tawait apiUser.search({ uid: 0 }, { query: 'john' });\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should error with invalid data', async () => {\n\t\t\ttry {\n\t\t\t\tawait apiUser.search({ uid: testUid }, null);\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should error for unprivileged user', async () => {\n\t\t\ttry {\n\t\t\t\tawait apiUser.search({ uid: testUid }, { searchBy: 'ip', query: '123' });\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should error for unprivileged user', async () => {\n\t\t\ttry {\n\t\t\t\tawait apiUser.search({ uid: testUid }, { filters: ['banned'], query: '123' });\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should error for unprivileged user', async () => {\n\t\t\ttry {\n\t\t\t\tawait apiUser.search({ uid: testUid }, { filters: ['flagged'], query: '123' });\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should search users by ip', async () => {\n\t\t\tconst uid = await User.create({ username: 'ipsearch' });\n\t\t\tawait db.sortedSetAdd('ip:1.1.1.1:uid', [1, 1], [testUid, uid]);\n\t\t\tconst data = await apiUser.search({ uid: adminUid }, { query: '1.1.1.1', searchBy: 'ip' });\n\t\t\tassert(Array.isArray(data.users));\n\t\t\tassert.equal(data.users.length, 2);\n\t\t});\n\n\t\tit('should search users by uid', async () => {\n\t\t\tconst data = await apiUser.search({ uid: testUid }, { query: uid, searchBy: 'uid' });\n\t\t\tassert(Array.isArray(data.users));\n\t\t\tassert.equal(data.users[0].uid, uid);\n\t\t});\n\n\t\tit('should search users by fullname', async () => {\n\t\t\tconst uid = await User.create({ username: 'fullnamesearch1', fullname: 'Mr. Fullname' });\n\t\t\tconst data = await apiUser.search({ uid: adminUid }, { query: 'mr', searchBy: 'fullname' });\n\t\t\tassert(Array.isArray(data.users));\n\t\t\tassert.equal(data.users.length, 1);\n\t\t\tassert.equal(uid, data.users[0].uid);\n\t\t});\n\n\t\tit('should search users by fullname', async () => {\n\t\t\tconst uid = await User.create({ username: 'fullnamesearch2', fullname: 'Baris:Usakli' });\n\t\t\tconst data = await apiUser.search({ uid: adminUid }, { query: 'baris:', searchBy: 'fullname' });\n\t\t\tassert(Array.isArray(data.users));\n\t\t\tassert.equal(data.users.length, 1);\n\t\t\tassert.equal(uid, data.users[0].uid);\n\t\t});\n\n\t\tit('should return empty array if query is empty', async () => {\n\t\t\tconst data = await apiUser.search({ uid: testUid }, { query: '' });\n\t\t\tassert.equal(data.users.length, 0);\n\t\t});\n\n\t\tit('should filter users', async () => {\n\t\t\tconst uid = await User.create({ username: 'ipsearch_filter' });\n\t\t\tawait User.bans.ban(uid, 0, '');\n\t\t\tawait User.setUserFields(uid, { flags: 10 });\n\t\t\tconst data = await apiUser.search({ uid: adminUid }, {\n\t\t\t\tquery: 'ipsearch',\n\t\t\t\tfilters: ['online', 'banned', 'flagged'],\n\t\t\t});\n\t\t\tassert.equal(data.users[0].username, 'ipsearch_filter');\n\t\t});\n\n\t\tit('should sort results by username', (done) => {\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\tUser.create({ username: 'brian' }, next);\n\t\t\t\t},\n\t\t\t\tfunction (uid, next) {\n\t\t\t\t\tUser.create({ username: 'baris' }, next);\n\t\t\t\t},\n\t\t\t\tfunction (uid, next) {\n\t\t\t\t\tUser.create({ username: 'bzari' }, next);\n\t\t\t\t},\n\t\t\t\tfunction (uid, next) {\n\t\t\t\t\tUser.search({\n\t\t\t\t\t\tuid: testUid,\n\t\t\t\t\t\tquery: 'b',\n\t\t\t\t\t\tsortBy: 'username',\n\t\t\t\t\t\tpaginate: false,\n\t\t\t\t\t}, next);\n\t\t\t\t},\n\t\t\t], (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(data.users[0].username, 'baris');\n\t\t\t\tassert.equal(data.users[1].username, 'brian');\n\t\t\t\tassert.equal(data.users[2].username, 'bzari');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('.delete()', () => {\n\t\tlet uid;\n\t\tbefore((done) => {\n\t\t\tUser.create({ username: 'usertodelete', password: '123456', email: 'delete@me.com' }, (err, newUid) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tuid = newUid;\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should delete a user account', (done) => {\n\t\t\tUser.delete(1, uid, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tUser.existsBySlug('usertodelete', (err, exists) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(exists, false);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should not re-add user to users:postcount if post is purged after user account deletion', async () => {\n\t\t\tconst uid = await User.create({ username: 'olduserwithposts' });\n\t\t\tassert(await db.isSortedSetMember('users:postcount', uid));\n\n\t\t\tconst result = await Topics.post({\n\t\t\t\tuid: uid,\n\t\t\t\ttitle: 'old user topic',\n\t\t\t\tcontent: 'old user topic post content',\n\t\t\t\tcid: testCid,\n\t\t\t});\n\t\t\tassert.equal(await db.sortedSetScore('users:postcount', uid), 1);\n\t\t\tawait User.deleteAccount(uid);\n\t\t\tassert(!await db.isSortedSetMember('users:postcount', uid));\n\t\t\tawait Posts.purge(result.postData.pid, 1);\n\t\t\tassert(!await db.isSortedSetMember('users:postcount', uid));\n\t\t});\n\n\t\tit('should not re-add user to users:reputation if post is upvoted after user account deletion', async () => {\n\t\t\tconst uid = await User.create({ username: 'olduserwithpostsupvote' });\n\t\t\tassert(await db.isSortedSetMember('users:reputation', uid));\n\n\t\t\tconst result = await Topics.post({\n\t\t\t\tuid: uid,\n\t\t\t\ttitle: 'old user topic',\n\t\t\t\tcontent: 'old user topic post content',\n\t\t\t\tcid: testCid,\n\t\t\t});\n\t\t\tassert.equal(await db.sortedSetScore('users:reputation', uid), 0);\n\t\t\tawait User.deleteAccount(uid);\n\t\t\tassert(!await db.isSortedSetMember('users:reputation', uid));\n\t\t\tawait Posts.upvote(result.postData.pid, 1);\n\t\t\tassert(!await db.isSortedSetMember('users:reputation', uid));\n\t\t});\n\n\t\tit('should delete user even if they started a chat', async () => {\n\t\t\tconst socketModules = require('../src/socket.io/modules');\n\t\t\tconst uid1 = await User.create({ username: 'chatuserdelete1' });\n\t\t\tconst uid2 = await User.create({ username: 'chatuserdelete2' });\n\t\t\tconst roomId = await messaging.newRoom(uid1, [uid2]);\n\t\t\tawait messaging.addMessage({\n\t\t\t\tuid: uid1,\n\t\t\t\tcontent: 'hello',\n\t\t\t\troomId,\n\t\t\t});\n\t\t\tawait messaging.leaveRoom([uid2], roomId);\n\t\t\tawait User.delete(1, uid1);\n\t\t\tassert.strictEqual(await User.exists(uid1), false);\n\t\t});\n\t});\n\n\tdescribe('passwordReset', () => {\n\t\tlet uid;\n\t\tlet code;\n\t\tbefore(async () => {\n\t\t\tuid = await User.create({ username: 'resetuser', password: '123456' });\n\t\t\tawait User.setUserField(uid, 'email', 'reset@me.com');\n\t\t\tawait User.email.confirmByUid(uid);\n\t\t});\n\n\t\tit('.generate() should generate a new reset code', (done) => {\n\t\t\tUser.reset.generate(uid, (err, _code) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(_code);\n\n\t\t\t\tcode = _code;\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('.generate() should invalidate a previous generated reset code', async () => {\n\t\t\tconst _code = await User.reset.generate(uid);\n\t\t\tconst valid = await User.reset.validate(code);\n\t\t\tassert.strictEqual(valid, false);\n\n\t\t\tcode = _code;\n\t\t});\n\n\t\tit('.validate() should ensure that this new code is valid', (done) => {\n\t\t\tUser.reset.validate(code, (err, valid) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(valid, true);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('.validate() should correctly identify an invalid code', (done) => {\n\t\t\tUser.reset.validate(`${code}abcdef`, (err, valid) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(valid, false);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('.send() should create a new reset code and reset password', async () => {\n\t\t\tcode = await User.reset.send('reset@me.com');\n\t\t});\n\n\t\tit('.commit() should update the user\\'s password and confirm their email', (done) => {\n\t\t\tUser.reset.commit(code, 'newpassword', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\tasync.parallel({\n\t\t\t\t\tuserData: function (next) {\n\t\t\t\t\t\tUser.getUserData(uid, next);\n\t\t\t\t\t},\n\t\t\t\t\tpassword: function (next) {\n\t\t\t\t\t\tdb.getObjectField(`user:${uid}`, 'password', next);\n\t\t\t\t\t},\n\t\t\t\t}, (err, results) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tPassword.compare('newpassword', results.password, true, (err, match) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert(match);\n\t\t\t\t\t\tassert.strictEqual(results.userData['email:confirmed'], 1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('.should error if same password is used for reset', async () => {\n\t\t\tconst uid = await User.create({ username: 'badmemory', email: 'bad@memory.com', password: '123456' });\n\t\t\tconst code = await User.reset.generate(uid);\n\t\t\tlet err;\n\t\t\ttry {\n\t\t\t\tawait User.reset.commit(code, '123456');\n\t\t\t} catch (_err) {\n\t\t\t\terr = _err;\n\t\t\t}\n\t\t\tassert.strictEqual(err.message, '[[error:reset-same-password]]');\n\t\t});\n\n\t\tit('should not validate email if password reset is due to expiry', async () => {\n\t\t\tconst uid = await User.create({ username: 'resetexpiry', email: 'reset@expiry.com', password: '123456' });\n\t\t\tlet confirmed = await User.getUserField(uid, 'email:confirmed');\n\t\t\tlet [verified, unverified] = await groups.isMemberOfGroups(uid, ['verified-users', 'unverified-users']);\n\t\t\tassert.strictEqual(confirmed, 0);\n\t\t\tassert.strictEqual(verified, false);\n\t\t\tassert.strictEqual(unverified, true);\n\t\t\tawait User.setUserField(uid, 'passwordExpiry', Date.now());\n\t\t\tconst code = await User.reset.generate(uid);\n\t\t\tawait User.reset.commit(code, '654321');\n\t\t\tconfirmed = await User.getUserField(uid, 'email:confirmed');\n\t\t\t[verified, unverified] = await groups.isMemberOfGroups(uid, ['verified-users', 'unverified-users']);\n\t\t\tassert.strictEqual(confirmed, 0);\n\t\t\tassert.strictEqual(verified, false);\n\t\t\tassert.strictEqual(unverified, true);\n\t\t});\n\t});\n\n\tdescribe('hash methods', () => {\n\t\tit('should return uid from email', (done) => {\n\t\t\tUser.getUidByEmail('john@example.com', (err, uid) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(parseInt(uid, 10), parseInt(testUid, 10));\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return uid from username', (done) => {\n\t\t\tUser.getUidByUsername('John Smith', (err, uid) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(parseInt(uid, 10), parseInt(testUid, 10));\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return uid from userslug', (done) => {\n\t\t\tUser.getUidByUserslug('john-smith', (err, uid) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(parseInt(uid, 10), parseInt(testUid, 10));\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should get user data even if one uid is NaN', (done) => {\n\t\t\tUser.getUsersData([NaN, testUid], (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(data[0]);\n\t\t\t\tassert.equal(data[0].username, '[[global:guest]]');\n\t\t\t\tassert(data[1]);\n\t\t\t\tassert.equal(data[1].username, userData.username);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should not return private user data', (done) => {\n\t\t\tUser.setUserFields(testUid, {\n\t\t\t\tfb_token: '123123123',\n\t\t\t\tanother_secret: 'abcde',\n\t\t\t\tpostcount: '123',\n\t\t\t}, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tUser.getUserData(testUid, (err, userData) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert(!userData.hasOwnProperty('fb_token'));\n\t\t\t\t\tassert(!userData.hasOwnProperty('another_secret'));\n\t\t\t\t\tassert(!userData.hasOwnProperty('password'));\n\t\t\t\t\tassert(!userData.hasOwnProperty('rss_token'));\n\t\t\t\t\tassert.strictEqual(userData.postcount, 123);\n\t\t\t\t\tassert.strictEqual(userData.uid, testUid);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should not return password even if explicitly requested', (done) => {\n\t\t\tUser.getUserFields(testUid, ['password'], (err, payload) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(!payload.hasOwnProperty('password'));\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should not modify the fields array passed in', async () => {\n\t\t\tconst fields = ['username', 'email'];\n\t\t\tawait User.getUserFields(testUid, fields);\n\t\t\tassert.deepStrictEqual(fields, ['username', 'email']);\n\t\t});\n\n\t\tit('should return an icon text and valid background if username and picture is explicitly requested', async () => {\n\t\t\tconst payload = await User.getUserFields(testUid, ['username', 'picture']);\n\t\t\tconst validBackgrounds = await User.getIconBackgrounds(testUid);\n\t\t\tassert.strictEqual(payload['icon:text'], userData.username.slice(0, 1).toUpperCase());\n\t\t\tassert(payload['icon:bgColor']);\n\t\t\tassert(validBackgrounds.includes(payload['icon:bgColor']));\n\t\t});\n\n\t\tit('should return a valid background, even if an invalid background colour is set', async () => {\n\t\t\tawait User.setUserField(testUid, 'icon:bgColor', 'teal');\n\t\t\tconst payload = await User.getUserFields(testUid, ['username', 'picture']);\n\t\t\tconst validBackgrounds = await User.getIconBackgrounds(testUid);\n\n\t\t\tassert(payload['icon:bgColor']);\n\t\t\tassert(validBackgrounds.includes(payload['icon:bgColor']));\n\t\t});\n\n\t\tit('should return private data if field is whitelisted', (done) => {\n\t\t\tfunction filterMethod(data, callback) {\n\t\t\t\tdata.whitelist.push('another_secret');\n\t\t\t\tcallback(null, data);\n\t\t\t}\n\n\t\t\tplugins.hooks.register('test-plugin', { hook: 'filter:user.whitelistFields', method: filterMethod });\n\t\t\tUser.getUserData(testUid, (err, userData) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(!userData.hasOwnProperty('fb_token'));\n\t\t\t\tassert.equal(userData.another_secret, 'abcde');\n\t\t\t\tplugins.hooks.unregister('test-plugin', 'filter:user.whitelistFields', filterMethod);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return 0 as uid if username is falsy', (done) => {\n\t\t\tUser.getUidByUsername('', (err, uid) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(uid, 0);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should get username by userslug', (done) => {\n\t\t\tUser.getUsernameByUserslug('john-smith', (err, username) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual('John Smith', username);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should get uids by emails', (done) => {\n\t\t\tUser.getUidsByEmails(['john@example.com'], (err, uids) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(uids[0], testUid);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should not get groupTitle for guests', (done) => {\n\t\t\tUser.getUserData(0, (err, userData) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(userData.groupTitle, '');\n\t\t\t\tassert.deepStrictEqual(userData.groupTitleArray, []);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load guest data', (done) => {\n\t\t\tUser.getUsersData([1, 0], (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(data[1].username, '[[global:guest]]');\n\t\t\t\tassert.strictEqual(data[1].userslug, '');\n\t\t\t\tassert.strictEqual(data[1].uid, 0);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('profile methods', () => {\n\t\tlet uid;\n\t\tlet jar;\n\n\t\tbefore(async () => {\n\t\t\tconst newUid = await User.create({ username: 'updateprofile', email: 'update@me.com', password: '123456' });\n\t\t\tuid = newUid;\n\n\t\t\tawait User.setUserField(uid, 'email', 'update@me.com');\n\t\t\tawait User.email.confirmByUid(uid);\n\n\t\t\t({ jar } = await helpers.loginUser('updateprofile', '123456'));\n\t\t});\n\n\t\tit('should return error if not logged in', async () => {\n\t\t\ttry {\n\t\t\t\tawait apiUser.update({ uid: 0 }, { uid: 1 });\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-uid]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should return error if data is invalid', async () => {\n\t\t\ttry {\n\t\t\t\tawait apiUser.update({ uid: uid }, null);\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should return error if data is missing uid', async () => {\n\t\t\ttry {\n\t\t\t\tawait apiUser.update({ uid: uid }, { username: 'bip', email: 'bop' });\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t}\n\t\t});\n\n\t\tdescribe('.updateProfile()', () => {\n\t\t\tlet uid;\n\n\t\t\tit('should update a user\\'s profile', async () => {\n\t\t\t\tuid = await User.create({ username: 'justforupdate', email: 'just@for.updated', password: '123456' });\n\t\t\t\tawait User.setUserField(uid, 'email', 'just@for.updated');\n\t\t\t\tawait User.email.confirmByUid(uid);\n\n\t\t\t\tconst data = {\n\t\t\t\t\tuid: uid,\n\t\t\t\t\tusername: 'updatedUserName',\n\t\t\t\t\temail: 'updatedEmail@me.com',\n\t\t\t\t\tfullname: 'updatedFullname',\n\t\t\t\t\twebsite: 'http://nodebb.org',\n\t\t\t\t\tlocation: 'izmir',\n\t\t\t\t\tgroupTitle: 'testGroup',\n\t\t\t\t\tbirthday: '01/01/1980',\n\t\t\t\t\tsignature: 'nodebb is good',\n\t\t\t\t\tpassword: '123456',\n\t\t\t\t};\n\t\t\t\tconst result = await apiUser.update({ uid: uid }, { ...data, password: '123456', invalid: 'field' });\n\t\t\t\tassert.equal(result.username, 'updatedUserName');\n\t\t\t\tassert.equal(result.userslug, 'updatedusername');\n\t\t\t\tassert.equal(result.location, 'izmir');\n\n\t\t\t\tconst userData = await db.getObject(`user:${uid}`);\n\t\t\t\tObject.keys(data).forEach((key) => {\n\t\t\t\t\tif (key === 'email') {\n\t\t\t\t\t\tassert.strictEqual(userData.email, 'just@for.updated'); // email remains the same until confirmed\n\t\t\t\t\t} else if (key !== 'password') {\n\t\t\t\t\t\tassert.equal(data[key], userData[key]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassert(userData[key].startsWith('$2a$'));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// updateProfile only saves valid fields\n\t\t\t\tassert.strictEqual(userData.invalid, undefined);\n\t\t\t});\n\n\t\t\tit('should also generate an email confirmation code for the changed email', async () => {\n\t\t\t\tconst confirmSent = await User.email.isValidationPending(uid, 'updatedemail@me.com');\n\t\t\t\tassert.strictEqual(confirmSent, true);\n\t\t\t});\n\t\t});\n\n\t\tit('should change a user\\'s password', async () => {\n\t\t\tconst uid = await User.create({ username: 'changepassword', password: '123456' });\n\t\t\tawait apiUser.changePassword({ uid: uid }, { uid: uid, newPassword: '654321', currentPassword: '123456' });\n\t\t\tconst correct = await User.isPasswordCorrect(uid, '654321', '127.0.0.1');\n\t\t\tassert(correct);\n\t\t});\n\n\t\tit('should not let user change another user\\'s password', async () => {\n\t\t\tconst regularUserUid = await User.create({ username: 'regularuserpwdchange', password: 'regularuser1234' });\n\t\t\tconst uid = await User.create({ username: 'changeadminpwd1', password: '123456' });\n\t\t\ttry {\n\t\t\t\tawait apiUser.changePassword({ uid: uid }, { uid: regularUserUid, newPassword: '654321', currentPassword: '123456' });\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[user:change_password_error_privileges]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should not let user change admin\\'s password', async () => {\n\t\t\tconst adminUid = await User.create({ username: 'adminpwdchange', password: 'admin1234' });\n\t\t\tawait groups.join('administrators', adminUid);\n\t\t\tconst uid = await User.create({ username: 'changeadminpwd2', password: '123456' });\n\t\t\ttry {\n\t\t\t\tawait apiUser.changePassword({ uid: uid }, { uid: adminUid, newPassword: '654321', currentPassword: '123456' });\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[user:change_password_error_privileges]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should let admin change another users password', async () => {\n\t\t\tconst adminUid = await User.create({ username: 'adminpwdchange2', password: 'admin1234' });\n\t\t\tawait groups.join('administrators', adminUid);\n\t\t\tconst uid = await User.create({ username: 'forgotmypassword', password: '123456' });\n\n\t\t\tawait apiUser.changePassword({ uid: adminUid }, { uid: uid, newPassword: '654321' });\n\t\t\tconst correct = await User.isPasswordCorrect(uid, '654321', '127.0.0.1');\n\t\t\tassert(correct);\n\t\t});\n\n\t\tit('should not let admin change their password if current password is incorrect', async () => {\n\t\t\tconst adminUid = await User.create({ username: 'adminforgotpwd', password: 'admin1234' });\n\t\t\tawait groups.join('administrators', adminUid);\n\n\t\t\ttry {\n\t\t\t\tawait apiUser.changePassword({ uid: adminUid }, { uid: adminUid, newPassword: '654321', currentPassword: 'wrongpwd' });\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[user:change_password_error_wrong_current]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should change username', async () => {\n\t\t\tawait apiUser.update({ uid: uid }, { uid: uid, username: 'updatedAgain', password: '123456' });\n\t\t\tconst username = await db.getObjectField(`user:${uid}`, 'username');\n\t\t\tassert.equal(username, 'updatedAgain');\n\t\t});\n\n\t\tit('should not let setting an empty username', async () => {\n\t\t\tawait apiUser.update({ uid: uid }, { uid: uid, username: '', password: '123456' });\n\t\t\tconst username = await db.getObjectField(`user:${uid}`, 'username');\n\t\t\tassert.strictEqual(username, 'updatedAgain');\n\t\t});\n\n\t\tit('should let updating profile if current username is above max length and it is not being changed', async () => {\n\t\t\tconst maxLength = meta.config.maximumUsernameLength + 1;\n\t\t\tconst longName = new Array(maxLength).fill('a').join('');\n\t\t\tconst uid = await User.create({ username: longName });\n\t\t\tawait apiUser.update({ uid: uid }, { uid: uid, username: longName, email: 'verylong@name.com' });\n\t\t\tconst userData = await db.getObject(`user:${uid}`);\n\t\t\tconst awaitingValidation = await User.email.isValidationPending(uid, 'verylong@name.com');\n\n\t\t\tassert.strictEqual(userData.username, longName);\n\t\t\tassert.strictEqual(awaitingValidation, true);\n\t\t});\n\n\t\tit('should not update a user\\'s username if it did not change', async () => {\n\t\t\tawait apiUser.update({ uid: uid }, { uid: uid, username: 'updatedAgain', password: '123456' });\n\t\t\tconst data = await db.getSortedSetRevRange(`user:${uid}:usernames`, 0, -1);\n\t\t\tassert.equal(data.length, 2);\n\t\t\tassert(data[0].startsWith('updatedAgain'));\n\t\t});\n\n\t\tit('should not update a user\\'s username if a password is not supplied', async () => {\n\t\t\ttry {\n\t\t\t\tawait apiUser.update({ uid: uid }, { uid: uid, username: 'updatedAgain', password: '' });\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.strictEqual(err.message, '[[error:invalid-password]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should send validation email', async () => {\n\t\t\tconst uid = await User.create({ username: 'pooremailupdate', email: 'poor@update.me', password: '123456' });\n\t\t\tawait User.email.expireValidation(uid);\n\t\t\tawait apiUser.update({ uid: uid }, { uid: uid, email: 'updatedAgain@me.com', password: '123456' });\n\n\t\t\tassert.strictEqual(await User.email.isValidationPending(uid, 'updatedAgain@me.com'.toLowerCase()), true);\n\t\t});\n\n\t\tit('should update cover image', (done) => {\n\t\t\tconst position = '50.0301% 19.2464%';\n\t\t\tsocketUser.updateCover({ uid: uid }, { uid: uid, imageData: goodImage, position: position }, (err, result) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(result.url);\n\t\t\t\tdb.getObjectFields(`user:${uid}`, ['cover:url', 'cover:position'], (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(data['cover:url'], result.url);\n\t\t\t\t\tassert.equal(data['cover:position'], position);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should remove cover image', async () => {\n\t\t\tconst coverPath = await User.getLocalCoverPath(uid);\n\t\t\tawait socketUser.removeCover({ uid: uid }, { uid: uid });\n\t\t\tconst coverUrlNow = await db.getObjectField(`user:${uid}`, 'cover:url');\n\t\t\tassert.strictEqual(coverUrlNow, null);\n\t\t\tassert.strictEqual(fs.existsSync(coverPath), false);\n\t\t});\n\n\t\tit('should set user status', (done) => {\n\t\t\tsocketUser.setStatus({ uid: uid }, 'away', (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(data.uid, uid);\n\t\t\t\tassert.equal(data.status, 'away');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should fail for invalid status', (done) => {\n\t\t\tsocketUser.setStatus({ uid: uid }, '12345', (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-user-status]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should get user status', (done) => {\n\t\t\tsocketUser.checkStatus({ uid: uid }, uid, (err, status) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(status, 'away');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should change user picture', async () => {\n\t\t\tawait apiUser.changePicture({ uid: uid }, { type: 'default', uid: uid });\n\t\t\tconst picture = await User.getUserField(uid, 'picture');\n\t\t\tassert.equal(picture, '');\n\t\t});\n\n\t\tit('should let you set an external image', async () => {\n\t\t\tconst token = await helpers.getCsrfToken(jar);\n\t\t\tconst body = await requestAsync(`${nconf.get('url')}/api/v3/users/${uid}/picture`, {\n\t\t\t\tjar,\n\t\t\t\tmethod: 'put',\n\t\t\t\tjson: true,\n\t\t\t\theaders: {\n\t\t\t\t\t'x-csrf-token': token,\n\t\t\t\t},\n\t\t\t\tbody: {\n\t\t\t\t\ttype: 'external',\n\t\t\t\t\turl: 'https://example.org/picture.jpg',\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tassert(body && body.status && body.response);\n\t\t\tassert.strictEqual(body.status.code, 'ok');\n\n\t\t\tconst picture = await User.getUserField(uid, 'picture');\n\t\t\tassert.strictEqual(picture, validator.escape('https://example.org/picture.jpg'));\n\t\t});\n\n\t\tit('should fail to change user picture with invalid data', async () => {\n\t\t\ttry {\n\t\t\t\tawait apiUser.changePicture({ uid: uid }, null);\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should fail to change user picture with invalid uid', async () => {\n\t\t\ttry {\n\t\t\t\tawait apiUser.changePicture({ uid: 0 }, { uid: 1 });\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should set user picture to uploaded', async () => {\n\t\t\tawait User.setUserField(uid, 'uploadedpicture', '/test');\n\t\t\tawait apiUser.changePicture({ uid: uid }, { type: 'uploaded', uid: uid });\n\t\t\tconst picture = await User.getUserField(uid, 'picture');\n\t\t\tassert.equal(picture, `${nconf.get('relative_path')}/test`);\n\t\t});\n\n\t\tit('should return error if profile image uploads disabled', (done) => {\n\t\t\tmeta.config.allowProfileImageUploads = 0;\n\t\t\tconst picture = {\n\t\t\t\tpath: path.join(nconf.get('base_dir'), 'test/files/test_copy.png'),\n\t\t\t\tsize: 7189,\n\t\t\t\tname: 'test.png',\n\t\t\t\ttype: 'image/png',\n\t\t\t};\n\t\t\tUser.uploadCroppedPicture({\n\t\t\t\tcallerUid: uid,\n\t\t\t\tuid: uid,\n\t\t\t\tfile: picture,\n\t\t\t}, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:profile-image-uploads-disabled]]');\n\t\t\t\tmeta.config.allowProfileImageUploads = 1;\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return error if profile image has no mime type', (done) => {\n\t\t\tUser.uploadCroppedPicture({\n\t\t\t\tcallerUid: uid,\n\t\t\t\tuid: uid,\n\t\t\t\timageData: 'data:image/invalid;base64,R0lGODlhPQBEAPeoAJosM/',\n\t\t\t}, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-image]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tdescribe('user.uploadCroppedPicture', () => {\n\t\t\tconst badImage = 'data:audio/mp3;base64,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';\n\n\t\t\tit('should upload cropped profile picture', async () => {\n\t\t\t\tconst result = await socketUser.uploadCroppedPicture({ uid: uid }, { uid: uid, imageData: goodImage });\n\t\t\t\tassert(result.url);\n\t\t\t\tconst data = await db.getObjectFields(`user:${uid}`, ['uploadedpicture', 'picture']);\n\t\t\t\tassert.strictEqual(result.url, data.uploadedpicture);\n\t\t\t\tassert.strictEqual(result.url, data.picture);\n\t\t\t});\n\n\t\t\tit('should upload cropped profile picture in chunks', async () => {\n\t\t\t\tconst socketUploads = require('../src/socket.io/uploads');\n\t\t\t\tconst socketData = {\n\t\t\t\t\tuid,\n\t\t\t\t\tmethod: 'user.uploadCroppedPicture',\n\t\t\t\t\tsize: goodImage.length,\n\t\t\t\t\tprogress: 0,\n\t\t\t\t};\n\t\t\t\tconst chunkSize = 1000;\n\t\t\t\tlet result;\n\t\t\t\tdo {\n\t\t\t\t\tconst chunk = goodImage.slice(socketData.progress, socketData.progress + chunkSize);\n\t\t\t\t\tsocketData.progress += chunk.length;\n\t\t\t\t\t// eslint-disable-next-line\n\t\t\t\t\tresult = await socketUploads.upload({ uid: uid }, {\n\t\t\t\t\t\tchunk: chunk,\n\t\t\t\t\t\tparams: socketData,\n\t\t\t\t\t});\n\t\t\t\t} while (socketData.progress < socketData.size);\n\n\t\t\t\tassert(result.url);\n\t\t\t\tconst data = await db.getObjectFields(`user:${uid}`, ['uploadedpicture', 'picture']);\n\t\t\t\tassert.strictEqual(result.url, data.uploadedpicture);\n\t\t\t\tassert.strictEqual(result.url, data.picture);\n\t\t\t});\n\n\t\t\tit('should error if both file and imageData are missing', (done) => {\n\t\t\t\tUser.uploadCroppedPicture({}, (err) => {\n\t\t\t\t\tassert.equal('[[error:invalid-data]]', err.message);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should error if file size is too big', (done) => {\n\t\t\t\tconst temp = meta.config.maximumProfileImageSize;\n\t\t\t\tmeta.config.maximumProfileImageSize = 1;\n\t\t\t\tUser.uploadCroppedPicture({\n\t\t\t\t\tcallerUid: uid,\n\t\t\t\t\tuid: 1,\n\t\t\t\t\timageData: goodImage,\n\t\t\t\t}, (err) => {\n\t\t\t\t\tassert.equal('[[error:file-too-big, 1]]', err.message);\n\n\t\t\t\t\t// Restore old value\n\t\t\t\t\tmeta.config.maximumProfileImageSize = temp;\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should not allow image data with bad MIME type to be passed in', (done) => {\n\t\t\t\tUser.uploadCroppedPicture({\n\t\t\t\t\tcallerUid: uid,\n\t\t\t\t\tuid: 1,\n\t\t\t\t\timageData: badImage,\n\t\t\t\t}, (err) => {\n\t\t\t\t\tassert.equal('[[error:invalid-image]]', err.message);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should get profile pictures', (done) => {\n\t\t\t\tsocketUser.getProfilePictures({ uid: uid }, { uid: uid }, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert(data);\n\t\t\t\t\tassert(Array.isArray(data));\n\t\t\t\t\tassert.equal(data[0].type, 'uploaded');\n\t\t\t\t\tassert.equal(data[0].text, '[[user:uploaded_picture]]');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should get default profile avatar', (done) => {\n\t\t\t\tassert.strictEqual(User.getDefaultAvatar(), '');\n\t\t\t\tmeta.config.defaultAvatar = 'https://path/to/default/avatar';\n\t\t\t\tassert.strictEqual(User.getDefaultAvatar(), meta.config.defaultAvatar);\n\t\t\t\tmeta.config.defaultAvatar = '/path/to/default/avatar';\n\t\t\t\tassert.strictEqual(User.getDefaultAvatar(), nconf.get('relative_path') + meta.config.defaultAvatar);\n\t\t\t\tmeta.config.defaultAvatar = '';\n\t\t\t\tdone();\n\t\t\t});\n\n\t\t\tit('should fail to get profile pictures with invalid data', (done) => {\n\t\t\t\tsocketUser.getProfilePictures({ uid: uid }, null, (err) => {\n\t\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\t\tsocketUser.getProfilePictures({ uid: uid }, { uid: null }, (err) => {\n\t\t\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should remove uploaded picture', async () => {\n\t\t\t\tconst avatarPath = await User.getLocalAvatarPath(uid);\n\t\t\t\tassert.notStrictEqual(avatarPath, false);\n\t\t\t\tawait socketUser.removeUploadedPicture({ uid: uid }, { uid: uid });\n\t\t\t\tconst uploadedPicture = await User.getUserField(uid, 'uploadedpicture');\n\t\t\t\tassert.strictEqual(uploadedPicture, '');\n\t\t\t\tassert.strictEqual(fs.existsSync(avatarPath), false);\n\t\t\t});\n\n\t\t\tit('should fail to remove uploaded picture with invalid-data', (done) => {\n\t\t\t\tsocketUser.removeUploadedPicture({ uid: uid }, null, (err) => {\n\t\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\t\tsocketUser.removeUploadedPicture({ uid: uid }, { }, (err) => {\n\t\t\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\t\t\tsocketUser.removeUploadedPicture({ uid: null }, { }, (err) => {\n\t\t\t\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\t\t\t\tdone();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should load profile page', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/updatedagain`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load settings page', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/updatedagain/settings`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body.settings);\n\t\t\t\tassert(body.languages);\n\t\t\t\tassert(body.homePageRoutes);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load edit page', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/updatedagain/edit`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load edit/email page', async () => {\n\t\t\tconst res = await requestAsync(`${nconf.get('url')}/api/user/updatedagain/edit/email`, { jar: jar, json: true, resolveWithFullResponse: true });\n\t\t\tassert.strictEqual(res.statusCode, 200);\n\t\t\tassert(res.body);\n\n\t\t\t// Accessing this page will mark the user's account as needing an updated email, below code undo's.\n\t\t\tawait requestAsync({\n\t\t\t\turi: `${nconf.get('url')}/register/abort`,\n\t\t\t\tjar,\n\t\t\t\tmethod: 'POST',\n\t\t\t\tsimple: false,\n\t\t\t});\n\t\t});\n\n\t\tit('should load user\\'s groups page', async () => {\n\t\t\tawait groups.create({\n\t\t\t\tname: 'Test',\n\t\t\t\tdescription: 'Foobar!',\n\t\t\t});\n\n\t\t\tawait groups.join('Test', uid);\n\t\t\tconst body = await requestAsync(`${nconf.get('url')}/api/user/updatedagain/groups`, { jar: jar, json: true });\n\n\t\t\tassert(Array.isArray(body.groups));\n\t\t\tassert.equal(body.groups[0].name, 'Test');\n\t\t});\n\t});\n\n\tdescribe('user info', () => {\n\t\tlet testUserUid;\n\t\tlet verifiedTestUserUid;\n\n\t\tbefore(async () => {\n\t\t\t// Might be the first user thus a verified one if this test part is ran alone\n\t\t\tverifiedTestUserUid = await User.create({ username: 'bannedUser', password: '123456', email: 'banneduser@example.com' });\n\t\t\tawait User.setUserField(verifiedTestUserUid, 'email:confirmed', 1);\n\t\t\ttestUserUid = await User.create({ username: 'bannedUser2', password: '123456', email: 'banneduser2@example.com' });\n\t\t});\n\n\t\tit('should return error if there is no ban reason', (done) => {\n\t\t\tUser.getLatestBanInfo(123, (err) => {\n\t\t\t\tassert.equal(err.message, 'no-ban-info');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should get history from set', async () => {\n\t\t\tconst now = Date.now();\n\t\t\tawait db.sortedSetAdd(`user:${testUserUid}:usernames`, now, `derp:${now}`);\n\t\t\tconst data = await User.getHistory(`user:${testUserUid}:usernames`);\n\t\t\tassert.equal(data[0].value, 'derp');\n\t\t\tassert.equal(data[0].timestamp, now);\n\t\t});\n\n\t\tit('should return the correct ban reason', (done) => {\n\t\t\tasync.series([\n\t\t\t\tfunction (next) {\n\t\t\t\t\tUser.bans.ban(testUserUid, 0, '', (err) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tnext(err);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\tUser.getModerationHistory(testUserUid, (err, data) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(data.bans.length, 1, 'one ban');\n\t\t\t\t\t\tassert.equal(data.bans[0].reason, '[[user:info.banned-no-reason]]', 'no ban reason');\n\n\t\t\t\t\t\tnext(err);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t], (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tUser.bans.unban(testUserUid, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should ban user permanently', (done) => {\n\t\t\tUser.bans.ban(testUserUid, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tUser.bans.isBanned(testUserUid, (err, isBanned) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(isBanned, true);\n\t\t\t\t\tUser.bans.unban(testUserUid, done);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should ban user temporarily', (done) => {\n\t\t\tUser.bans.ban(testUserUid, Date.now() + 2000, (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\tUser.bans.isBanned(testUserUid, (err, isBanned) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(isBanned, true);\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tUser.bans.isBanned(testUserUid, (err, isBanned) => {\n\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\tassert.equal(isBanned, false);\n\t\t\t\t\t\t\tUser.bans.unban(testUserUid, done);\n\t\t\t\t\t\t});\n\t\t\t\t\t}, 3000);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should error if until is NaN', (done) => {\n\t\t\tUser.bans.ban(testUserUid, 'asd', (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:ban-expiry-missing]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should be member of \"banned-users\" system group only after a ban', async () => {\n\t\t\tawait User.bans.ban(testUserUid);\n\n\t\t\tconst systemGroups = groups.systemGroups.filter(group => group !== groups.BANNED_USERS);\n\t\t\tconst isMember = await groups.isMember(testUserUid, groups.BANNED_USERS);\n\t\t\tconst isMemberOfAny = await groups.isMemberOfAny(testUserUid, systemGroups);\n\n\t\t\tassert.strictEqual(isMember, true);\n\t\t\tassert.strictEqual(isMemberOfAny, false);\n\t\t});\n\n\t\tit('should restore system group memberships after an unban (for an unverified user)', async () => {\n\t\t\tawait User.bans.unban(testUserUid);\n\n\t\t\tconst isMemberOfGroups = await groups.isMemberOfGroups(testUserUid, groups.systemGroups);\n\t\t\tconst membership = new Map(groups.systemGroups.map((item, index) => [item, isMemberOfGroups[index]]));\n\n\t\t\tassert.strictEqual(membership.get('registered-users'), true);\n\t\t\tassert.strictEqual(membership.get('verified-users'), false);\n\t\t\tassert.strictEqual(membership.get('unverified-users'), true);\n\t\t\tassert.strictEqual(membership.get(groups.BANNED_USERS), false);\n\t\t\t// administrators cannot be banned\n\t\t\tassert.strictEqual(membership.get('administrators'), false);\n\t\t\t// This will not restored\n\t\t\tassert.strictEqual(membership.get('Global Moderators'), false);\n\t\t});\n\n\t\tit('should restore system group memberships after an unban (for a verified user)', async () => {\n\t\t\tawait User.bans.ban(verifiedTestUserUid);\n\t\t\tawait User.bans.unban(verifiedTestUserUid);\n\n\t\t\tconst isMemberOfGroups = await groups.isMemberOfGroups(verifiedTestUserUid, groups.systemGroups);\n\t\t\tconst membership = new Map(groups.systemGroups.map((item, index) => [item, isMemberOfGroups[index]]));\n\n\t\t\tassert.strictEqual(membership.get('verified-users'), true);\n\t\t\tassert.strictEqual(membership.get('unverified-users'), false);\n\t\t});\n\t});\n\n\tdescribe('Digest.getSubscribers', () => {\n\t\tconst uidIndex = {};\n\n\t\tbefore((done) => {\n\t\t\tconst testUsers = ['daysub', 'offsub', 'nullsub', 'weeksub'];\n\t\t\tasync.each(testUsers, (username, next) => {\n\t\t\t\tasync.waterfall([\n\t\t\t\t\tasync.apply(User.create, { username: username, email: `${username}@example.com` }),\n\t\t\t\t\tfunction (uid, next) {\n\t\t\t\t\t\tif (username === 'nullsub') {\n\t\t\t\t\t\t\treturn setImmediate(next);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuidIndex[username] = uid;\n\n\t\t\t\t\t\tconst sub = username.slice(0, -3);\n\t\t\t\t\t\tasync.parallel([\n\t\t\t\t\t\t\tasync.apply(User.updateDigestSetting, uid, sub),\n\t\t\t\t\t\t\tasync.apply(User.setSetting, uid, 'dailyDigestFreq', sub),\n\t\t\t\t\t\t], next);\n\t\t\t\t\t},\n\t\t\t\t], next);\n\t\t\t}, done);\n\t\t});\n\n\t\tit('should accurately build digest list given ACP default \"null\" (not set)', (done) => {\n\t\t\tUser.digest.getSubscribers('day', (err, subs) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(subs.length, 1);\n\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should accurately build digest list given ACP default \"day\"', (done) => {\n\t\t\tasync.series([\n\t\t\t\tasync.apply(meta.configs.set, 'dailyDigestFreq', 'day'),\n\t\t\t\tfunction (next) {\n\t\t\t\t\tUser.digest.getSubscribers('day', (err, subs) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.strictEqual(subs.includes(uidIndex.daysub.toString()), true); // daysub does get emailed\n\t\t\t\t\t\tassert.strictEqual(subs.includes(uidIndex.weeksub.toString()), false); // weeksub does not get emailed\n\t\t\t\t\t\tassert.strictEqual(subs.includes(uidIndex.offsub.toString()), false); // offsub doesn't get emailed\n\n\t\t\t\t\t\tnext();\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should accurately build digest list given ACP default \"week\"', (done) => {\n\t\t\tasync.series([\n\t\t\t\tasync.apply(meta.configs.set, 'dailyDigestFreq', 'week'),\n\t\t\t\tfunction (next) {\n\t\t\t\t\tUser.digest.getSubscribers('week', (err, subs) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.strictEqual(subs.includes(uidIndex.weeksub.toString()), true); // weeksub gets emailed\n\t\t\t\t\t\tassert.strictEqual(subs.includes(uidIndex.daysub.toString()), false); // daysub gets emailed\n\t\t\t\t\t\tassert.strictEqual(subs.includes(uidIndex.offsub.toString()), false); // offsub does not get emailed\n\n\t\t\t\t\t\tnext();\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should accurately build digest list given ACP default \"off\"', (done) => {\n\t\t\tasync.series([\n\t\t\t\tasync.apply(meta.configs.set, 'dailyDigestFreq', 'off'),\n\t\t\t\tfunction (next) {\n\t\t\t\t\tUser.digest.getSubscribers('day', (err, subs) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.strictEqual(subs.length, 1);\n\n\t\t\t\t\t\tnext();\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\t});\n\n\tdescribe('digests', () => {\n\t\tlet uid;\n\t\tbefore((done) => {\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\tUser.create({ username: 'digestuser', email: 'test@example.com' }, next);\n\t\t\t\t},\n\t\t\t\tfunction (_uid, next) {\n\t\t\t\t\tuid = _uid;\n\t\t\t\t\tUser.updateDigestSetting(uid, 'day', next);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\tUser.setSetting(uid, 'dailyDigestFreq', 'day', next);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\tUser.setSetting(uid, 'notificationType_test', 'notificationemail', next);\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should send digests', (done) => {\n\t\t\tconst oldValue = meta.config.includeUnverifiedEmails;\n\t\t\tmeta.config.includeUnverifiedEmails = true;\n\t\t\tUser.digest.execute({ interval: 'day' }, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tmeta.config.includeUnverifiedEmails = oldValue;\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should not send digests', (done) => {\n\t\t\tUser.digest.execute({ interval: 'month' }, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should get delivery times', async () => {\n\t\t\tconst data = await User.digest.getDeliveryTimes(0, -1);\n\t\t\tconst users = data.users.filter(u => u.username === 'digestuser');\n\t\t\tassert.strictEqual(users[0].setting, 'day');\n\t\t});\n\n\t\tdescribe('unsubscribe via POST', () => {\n\t\t\tit('should unsubscribe from digest if one-click unsubscribe is POSTed', (done) => {\n\t\t\t\tconst token = jwt.sign({\n\t\t\t\t\ttemplate: 'digest',\n\t\t\t\t\tuid: uid,\n\t\t\t\t}, nconf.get('secret'));\n\n\t\t\t\trequest({\n\t\t\t\t\tmethod: 'post',\n\t\t\t\t\turl: `${nconf.get('url')}/email/unsubscribe/${token}`,\n\t\t\t\t}, (err, res) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(res.statusCode, 200);\n\n\t\t\t\t\tdb.getObjectField(`user:${uid}:settings`, 'dailyDigestFreq', (err, value) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.strictEqual(value, 'off');\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should unsubscribe from notifications if one-click unsubscribe is POSTed', (done) => {\n\t\t\t\tconst token = jwt.sign({\n\t\t\t\t\ttemplate: 'notification',\n\t\t\t\t\ttype: 'test',\n\t\t\t\t\tuid: uid,\n\t\t\t\t}, nconf.get('secret'));\n\n\t\t\t\trequest({\n\t\t\t\t\tmethod: 'post',\n\t\t\t\t\turl: `${nconf.get('url')}/email/unsubscribe/${token}`,\n\t\t\t\t}, (err, res) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(res.statusCode, 200);\n\n\t\t\t\t\tdb.getObjectField(`user:${uid}:settings`, 'notificationType_test', (err, value) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.strictEqual(value, 'notification');\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should return errors on missing template in token', (done) => {\n\t\t\t\tconst token = jwt.sign({\n\t\t\t\t\tuid: uid,\n\t\t\t\t}, nconf.get('secret'));\n\n\t\t\t\trequest({\n\t\t\t\t\tmethod: 'post',\n\t\t\t\t\turl: `${nconf.get('url')}/email/unsubscribe/${token}`,\n\t\t\t\t}, (err, res) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(res.statusCode, 404);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should return errors on wrong template in token', (done) => {\n\t\t\t\tconst token = jwt.sign({\n\t\t\t\t\ttemplate: 'user',\n\t\t\t\t\tuid: uid,\n\t\t\t\t}, nconf.get('secret'));\n\n\t\t\t\trequest({\n\t\t\t\t\tmethod: 'post',\n\t\t\t\t\turl: `${nconf.get('url')}/email/unsubscribe/${token}`,\n\t\t\t\t}, (err, res) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(res.statusCode, 404);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should return errors on missing token', (done) => {\n\t\t\t\trequest({\n\t\t\t\t\tmethod: 'post',\n\t\t\t\t\turl: `${nconf.get('url')}/email/unsubscribe/`,\n\t\t\t\t}, (err, res) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(res.statusCode, 404);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should return errors on token signed with wrong secret (verify-failure)', (done) => {\n\t\t\t\tconst token = jwt.sign({\n\t\t\t\t\ttemplate: 'notification',\n\t\t\t\t\ttype: 'test',\n\t\t\t\t\tuid: uid,\n\t\t\t\t}, `${nconf.get('secret')}aababacaba`);\n\n\t\t\t\trequest({\n\t\t\t\t\tmethod: 'post',\n\t\t\t\t\turl: `${nconf.get('url')}/email/unsubscribe/${token}`,\n\t\t\t\t}, (err, res) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(res.statusCode, 403);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('socket methods', () => {\n\t\tconst socketUser = require('../src/socket.io/user');\n\t\tlet delUid;\n\n\t\tit('should fail with invalid data', (done) => {\n\t\t\tmeta.userOrGroupExists(null, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return true if user/group exists', (done) => {\n\t\t\tmeta.userOrGroupExists('registered-users', (err, exists) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(exists);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return true if user/group exists', (done) => {\n\t\t\tmeta.userOrGroupExists('John Smith', (err, exists) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(exists);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return false if user/group does not exists', (done) => {\n\t\t\tmeta.userOrGroupExists('doesnot exist', (err, exists) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(!exists);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should delete user', async () => {\n\t\t\tdelUid = await User.create({ username: 'willbedeleted' });\n\n\t\t\t// Upload some avatars and covers before deleting\n\t\t\tmeta.config['profile:keepAllUserImages'] = 1;\n\t\t\tlet result = await socketUser.uploadCroppedPicture({ uid: delUid }, { uid: delUid, imageData: goodImage });\n\t\t\tassert(result.url);\n\t\t\tresult = await socketUser.uploadCroppedPicture({ uid: delUid }, { uid: delUid, imageData: goodImage });\n\t\t\tassert(result.url);\n\n\t\t\tconst position = '50.0301% 19.2464%';\n\t\t\tresult = await socketUser.updateCover({ uid: delUid }, { uid: delUid, imageData: goodImage, position: position });\n\t\t\tassert(result.url);\n\t\t\tresult = await socketUser.updateCover({ uid: delUid }, { uid: delUid, imageData: goodImage, position: position });\n\t\t\tassert(result.url);\n\t\t\tmeta.config['profile:keepAllUserImages'] = 0;\n\n\t\t\tawait apiUser.deleteAccount({ uid: delUid }, { uid: delUid });\n\t\t\tconst exists = await meta.userOrGroupExists('willbedeleted');\n\t\t\tassert(!exists);\n\t\t});\n\n\t\tit('should clean profile images after account deletion', () => {\n\t\t\tconst allProfileFiles = fs.readdirSync(path.join(nconf.get('upload_path'), 'profile'));\n\t\t\tconst deletedUserImages = allProfileFiles.filter(\n\t\t\t\tf => f.startsWith(`${delUid}-profilecover`) || f.startsWith(`${delUid}-profileavatar`)\n\t\t\t);\n\t\t\tassert.strictEqual(deletedUserImages.length, 0);\n\t\t});\n\n\t\tit('should fail to delete user with wrong password', async () => {\n\t\t\tconst uid = await User.create({ username: 'willbedeletedpwd', password: '123456' });\n\t\t\ttry {\n\t\t\t\tawait apiUser.deleteAccount({ uid: uid }, { uid: uid, password: '654321' });\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.strictEqual(err.message, '[[error:invalid-password]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should delete user with correct password', async () => {\n\t\t\tconst uid = await User.create({ username: 'willbedeletedcorrectpwd', password: '123456' });\n\t\t\tawait apiUser.deleteAccount({ uid: uid }, { uid: uid, password: '123456' });\n\t\t\tconst exists = await User.exists(uid);\n\t\t\tassert(!exists);\n\t\t});\n\n\t\tit('should fail to delete user if account deletion is not allowed', async () => {\n\t\t\tconst oldValue = meta.config.allowAccountDelete;\n\t\t\tmeta.config.allowAccountDelete = 0;\n\t\t\tconst uid = await User.create({ username: 'tobedeleted' });\n\t\t\ttry {\n\t\t\t\tawait apiUser.deleteAccount({ uid: uid }, { uid: uid });\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.strictEqual(err.message, '[[error:account-deletion-disabled]]');\n\t\t\t}\n\t\t\tmeta.config.allowAccountDelete = oldValue;\n\t\t});\n\n\t\tit('should send reset email', (done) => {\n\t\t\tsocketUser.reset.send({ uid: 0 }, 'john@example.com', (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return invalid-data error', (done) => {\n\t\t\tsocketUser.reset.send({ uid: 0 }, null, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should not error', (done) => {\n\t\t\tsocketUser.reset.send({ uid: 0 }, 'doestnot@exist.com', (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should commit reset', (done) => {\n\t\t\tdb.getObject('reset:uid', (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tconst code = Object.keys(data).find(code => parseInt(data[code], 10) === parseInt(testUid, 10));\n\t\t\t\tsocketUser.reset.commit({ uid: 0 }, { code: code, password: 'pwdchange' }, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should save user settings', async () => {\n\t\t\tconst data = {\n\t\t\t\tuid: testUid,\n\t\t\t\tsettings: {\n\t\t\t\t\tbootswatchSkin: 'default',\n\t\t\t\t\thomePageRoute: 'none',\n\t\t\t\t\thomePageCustom: '',\n\t\t\t\t\topenOutgoingLinksInNewTab: 0,\n\t\t\t\t\tscrollToMyPost: 1,\n\t\t\t\t\tuserLang: 'en-GB',\n\t\t\t\t\tusePagination: 1,\n\t\t\t\t\ttopicsPerPage: '10',\n\t\t\t\t\tpostsPerPage: '5',\n\t\t\t\t\tshowemail: 1,\n\t\t\t\t\tshowfullname: 1,\n\t\t\t\t\trestrictChat: 0,\n\t\t\t\t\tfollowTopicsOnCreate: 1,\n\t\t\t\t\tfollowTopicsOnReply: 1,\n\t\t\t\t},\n\t\t\t};\n\t\t\tawait apiUser.updateSettings({ uid: testUid }, data);\n\t\t\tconst userSettings = await User.getSettings(testUid);\n\t\t\tassert.strictEqual(userSettings.usePagination, true);\n\t\t});\n\n\t\tit('should properly escape homePageRoute', async () => {\n\t\t\tconst data = {\n\t\t\t\tuid: testUid,\n\t\t\t\tsettings: {\n\t\t\t\t\tbootswatchSkin: 'default',\n\t\t\t\t\thomePageRoute: 'category/6/testing-ground',\n\t\t\t\t\thomePageCustom: '',\n\t\t\t\t\topenOutgoingLinksInNewTab: 0,\n\t\t\t\t\tscrollToMyPost: 1,\n\t\t\t\t\tuserLang: 'en-GB',\n\t\t\t\t\tusePagination: 1,\n\t\t\t\t\ttopicsPerPage: '10',\n\t\t\t\t\tpostsPerPage: '5',\n\t\t\t\t\tshowemail: 1,\n\t\t\t\t\tshowfullname: 1,\n\t\t\t\t\trestrictChat: 0,\n\t\t\t\t\tfollowTopicsOnCreate: 1,\n\t\t\t\t\tfollowTopicsOnReply: 1,\n\t\t\t\t},\n\t\t\t};\n\t\t\tawait apiUser.updateSettings({ uid: testUid }, data);\n\t\t\tconst userSettings = await User.getSettings(testUid);\n\t\t\tassert.strictEqual(userSettings.homePageRoute, 'category/6/testing-ground');\n\t\t});\n\n\n\t\tit('should error if language is invalid', async () => {\n\t\t\tconst data = {\n\t\t\t\tuid: testUid,\n\t\t\t\tsettings: {\n\t\t\t\t\tuserLang: '<invalid-string>',\n\t\t\t\t\ttopicsPerPage: '10',\n\t\t\t\t\tpostsPerPage: '5',\n\t\t\t\t},\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tawait apiUser.updateSettings({ uid: testUid }, data);\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-language]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should set moderation note', (done) => {\n\t\t\tlet adminUid;\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\tUser.create({ username: 'noteadmin' }, next);\n\t\t\t\t},\n\t\t\t\tfunction (_adminUid, next) {\n\t\t\t\t\tadminUid = _adminUid;\n\t\t\t\t\tgroups.join('administrators', adminUid, next);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\tsocketUser.setModerationNote({ uid: adminUid }, { uid: testUid, note: 'this is a test user' }, next);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\tsetTimeout(next, 50);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\tsocketUser.setModerationNote({ uid: adminUid }, { uid: testUid, note: '<svg/onload=alert(document.location);//' }, next);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\tUser.getModerationNotes(testUid, 0, -1, next);\n\t\t\t\t},\n\t\t\t], (err, notes) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(notes[0].note, '&lt;svg&#x2F;onload=alert(document.location);&#x2F;&#x2F;');\n\t\t\t\tassert.equal(notes[0].uid, adminUid);\n\t\t\t\tassert.equal(notes[1].note, 'this is a test user');\n\t\t\t\tassert(notes[0].timestamp);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should get unread count 0 for guest', async () => {\n\t\t\tconst count = await socketUser.getUnreadCount({ uid: 0 });\n\t\t\tassert.strictEqual(count, 0);\n\t\t});\n\n\t\tit('should get unread count for user', async () => {\n\t\t\tconst count = await socketUser.getUnreadCount({ uid: testUid });\n\t\t\tassert.strictEqual(count, 2);\n\t\t});\n\n\t\tit('should get unread chat count 0 for guest', async () => {\n\t\t\tconst count = await socketUser.getUnreadChatCount({ uid: 0 });\n\t\t\tassert.strictEqual(count, 0);\n\t\t});\n\n\t\tit('should get unread chat count for user', async () => {\n\t\t\tconst count = await socketUser.getUnreadChatCount({ uid: testUid });\n\t\t\tassert.strictEqual(count, 0);\n\t\t});\n\n\t\tit('should get unread counts 0 for guest', async () => {\n\t\t\tconst counts = await socketUser.getUnreadCounts({ uid: 0 });\n\t\t\tassert.deepStrictEqual(counts, {});\n\t\t});\n\n\t\tit('should get unread counts for user', async () => {\n\t\t\tconst counts = await socketUser.getUnreadCounts({ uid: testUid });\n\t\t\tassert.deepStrictEqual(counts, {\n\t\t\t\tunreadChatCount: 0,\n\t\t\t\tunreadCounts: {\n\t\t\t\t\t'': 2,\n\t\t\t\t\tnew: 2,\n\t\t\t\t\tunreplied: 2,\n\t\t\t\t\twatched: 0,\n\t\t\t\t},\n\t\t\t\tunreadNewTopicCount: 2,\n\t\t\t\tunreadNotificationCount: 0,\n\t\t\t\tunreadTopicCount: 2,\n\t\t\t\tunreadUnrepliedTopicCount: 2,\n\t\t\t\tunreadWatchedTopicCount: 0,\n\t\t\t});\n\t\t});\n\n\t\tit('should get user data by uid', async () => {\n\t\t\tconst userData = await socketUser.getUserByUID({ uid: testUid }, testUid);\n\t\t\tassert.strictEqual(userData.uid, testUid);\n\t\t});\n\n\t\tit('should get user data by username', async () => {\n\t\t\tconst userData = await socketUser.getUserByUsername({ uid: testUid }, 'John Smith');\n\t\t\tassert.strictEqual(userData.uid, testUid);\n\t\t});\n\n\t\tit('should get user data by email', async () => {\n\t\t\tconst userData = await socketUser.getUserByEmail({ uid: testUid }, 'john@example.com');\n\t\t\tassert.strictEqual(userData.uid, testUid);\n\t\t});\n\n\t\tit('should check/consent gdpr status', async () => {\n\t\t\tconst consent = await socketUser.gdpr.check({ uid: testUid }, { uid: testUid });\n\t\t\tassert(!consent);\n\t\t\tawait socketUser.gdpr.consent({ uid: testUid });\n\t\t\tconst consentAfter = await socketUser.gdpr.check({ uid: testUid }, { uid: testUid });\n\t\t\tassert(consentAfter);\n\t\t});\n\t});\n\n\tdescribe('approval queue', () => {\n\t\tlet oldRegistrationApprovalType;\n\t\tlet adminUid;\n\t\tbefore((done) => {\n\t\t\toldRegistrationApprovalType = meta.config.registrationApprovalType;\n\t\t\tmeta.config.registrationApprovalType = 'admin-approval';\n\t\t\tUser.create({ username: 'admin', password: '123456' }, (err, uid) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tadminUid = uid;\n\t\t\t\tgroups.join('administrators', uid, done);\n\t\t\t});\n\t\t});\n\n\t\tafter((done) => {\n\t\t\tmeta.config.registrationApprovalType = oldRegistrationApprovalType;\n\t\t\tdone();\n\t\t});\n\n\t\tit('should add user to approval queue', (done) => {\n\t\t\thelpers.registerUser({\n\t\t\t\tusername: 'rejectme',\n\t\t\t\tpassword: '123456',\n\t\t\t\t'password-confirm': '123456',\n\t\t\t\temail: '<script>alert(\"ok\")<script>reject@me.com',\n\t\t\t\tgdpr_consent: true,\n\t\t\t}, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\thelpers.loginUser('admin', '123456', (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\trequest(`${nconf.get('url')}/api/admin/manage/registration`, { jar: data.jar, json: true }, (err, res, body) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(body.users[0].username, 'rejectme');\n\t\t\t\t\t\tassert.equal(body.users[0].email, '&lt;script&gt;alert(&quot;ok&quot;)&lt;script&gt;reject@me.com');\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should fail to add user to queue if username is taken', (done) => {\n\t\t\thelpers.registerUser({\n\t\t\t\tusername: 'rejectme',\n\t\t\t\tpassword: '123456',\n\t\t\t\t'password-confirm': '123456',\n\t\t\t\temail: '<script>alert(\"ok\")<script>reject@me.com',\n\t\t\t\tgdpr_consent: true,\n\t\t\t}, (err, jar, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(body, '[[error:username-taken]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should fail to add user to queue if email is taken', (done) => {\n\t\t\thelpers.registerUser({\n\t\t\t\tusername: 'rejectmenew',\n\t\t\t\tpassword: '123456',\n\t\t\t\t'password-confirm': '123456',\n\t\t\t\temail: '<script>alert(\"ok\")<script>reject@me.com',\n\t\t\t\tgdpr_consent: true,\n\t\t\t}, (err, jar, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(body, '[[error:email-taken]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should reject user registration', (done) => {\n\t\t\tsocketUser.rejectRegistration({ uid: adminUid }, { username: 'rejectme' }, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tUser.getRegistrationQueue(0, -1, (err, users) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(users.length, 0);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should accept user registration', (done) => {\n\t\t\thelpers.registerUser({\n\t\t\t\tusername: 'acceptme',\n\t\t\t\tpassword: '123456',\n\t\t\t\t'password-confirm': '123456',\n\t\t\t\temail: 'accept@me.com',\n\t\t\t\tgdpr_consent: true,\n\t\t\t}, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tsocketUser.acceptRegistration({ uid: adminUid }, { username: 'acceptme' }, (err, uid) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tUser.exists(uid, (err, exists) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert(exists);\n\t\t\t\t\t\tUser.getRegistrationQueue(0, -1, (err, users) => {\n\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\tassert.equal(users.length, 0);\n\t\t\t\t\t\t\tdone();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should trim username and add user to registration queue', (done) => {\n\t\t\thelpers.registerUser({\n\t\t\t\tusername: 'invalidname\\r\\n',\n\t\t\t\tpassword: '123456',\n\t\t\t\t'password-confirm': '123456',\n\t\t\t\temail: 'invalidtest@test.com',\n\t\t\t\tgdpr_consent: true,\n\t\t\t}, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tdb.getSortedSetRange('registration:queue', 0, -1, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(data[0], 'invalidname');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('invites', () => {\n\t\tlet notAnInviterUid;\n\t\tlet inviterUid;\n\t\tlet adminUid;\n\n\t\tconst PUBLIC_GROUP = 'publicGroup';\n\t\tconst PRIVATE_GROUP = 'privateGroup';\n\t\tconst OWN_PRIVATE_GROUP = 'ownPrivateGroup';\n\t\tconst HIDDEN_GROUP = 'hiddenGroup';\n\n\t\tconst COMMON_PW = '123456';\n\n\t\tbefore(async () => {\n\t\t\tconst results = await utils.promiseParallel({\n\t\t\t\tpublicGroup: groups.create({ name: PUBLIC_GROUP, private: 0 }),\n\t\t\t\tprivateGroup: groups.create({ name: PRIVATE_GROUP, private: 1 }),\n\t\t\t\thiddenGroup: groups.create({ name: HIDDEN_GROUP, hidden: 1 }),\n\t\t\t\tnotAnInviter: User.create({ username: 'notAnInviter', password: COMMON_PW }),\n\t\t\t\tinviter: User.create({ username: 'inviter', password: COMMON_PW }),\n\t\t\t\tadmin: User.create({ username: 'adminInvite', password: COMMON_PW }),\n\t\t\t});\n\n\t\t\tnotAnInviterUid = results.notAnInviter;\n\t\t\tinviterUid = results.inviter;\n\t\t\tadminUid = results.admin;\n\n\t\t\tawait User.setUserField(inviterUid, 'email', 'inviter@nodebb.org');\n\t\t\tawait Promise.all([\n\t\t\t\tgroups.create({ name: OWN_PRIVATE_GROUP, ownerUid: inviterUid, private: 1 }),\n\t\t\t\tgroups.join('administrators', adminUid),\n\t\t\t\tgroups.join('cid:0:privileges:invite', inviterUid),\n\t\t\t\tUser.email.confirmByUid(inviterUid),\n\t\t\t]);\n\t\t});\n\n\t\tdescribe('when inviter is not an admin and does not have invite privilege', () => {\n\t\t\tlet csrf_token;\n\t\t\tlet jar;\n\n\t\t\tbefore((done) => {\n\t\t\t\thelpers.loginUser('notAnInviter', COMMON_PW, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tjar = data.jar;\n\n\t\t\t\t\trequest({\n\t\t\t\t\t\turl: `${nconf.get('url')}/api/config`,\n\t\t\t\t\t\tjson: true,\n\t\t\t\t\t\tjar: jar,\n\t\t\t\t\t}, (err, response, body) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tcsrf_token = body.csrf_token;\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should error if user does not have invite privilege', async () => {\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'invite1@test.com', groupsToJoin: [] }, notAnInviterUid, jar, csrf_token);\n\t\t\t\tassert.strictEqual(res.statusCode, 403);\n\t\t\t\tassert.strictEqual(res.body.status.message, 'You do not have enough privileges for this action.');\n\t\t\t});\n\n\t\t\tit('should error out if user tries to use an inviter\\'s uid via the API', async () => {\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'invite1@test.com', groupsToJoin: [] }, inviterUid, jar, csrf_token);\n\t\t\t\tconst numInvites = await User.getInvitesNumber(inviterUid);\n\t\t\t\tassert.strictEqual(res.statusCode, 403);\n\t\t\t\tassert.strictEqual(res.body.status.message, 'You do not have enough privileges for this action.');\n\t\t\t\tassert.strictEqual(numInvites, 0);\n\t\t\t});\n\t\t});\n\n\t\tdescribe('when inviter has invite privilege', () => {\n\t\t\tlet csrf_token;\n\t\t\tlet jar;\n\n\t\t\tbefore((done) => {\n\t\t\t\thelpers.loginUser('inviter', COMMON_PW, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tjar = data.jar;\n\n\t\t\t\t\trequest({\n\t\t\t\t\t\turl: `${nconf.get('url')}/api/config`,\n\t\t\t\t\t\tjson: true,\n\t\t\t\t\t\tjar: jar,\n\t\t\t\t\t}, (err, response, body) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tcsrf_token = body.csrf_token;\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should error with invalid data', async () => {\n\t\t\t\tconst { res } = await helpers.invite({}, inviterUid, jar, csrf_token);\n\t\t\t\tassert.strictEqual(res.statusCode, 400);\n\t\t\t\tassert.strictEqual(res.body.status.message, 'Invalid Data');\n\t\t\t});\n\n\t\t\tit('should error if user is not admin and type is admin-invite-only', async () => {\n\t\t\t\tmeta.config.registrationType = 'admin-invite-only';\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'invite1@test.com', groupsToJoin: [] }, inviterUid, jar, csrf_token);\n\t\t\t\tassert.strictEqual(res.statusCode, 403);\n\t\t\t\tassert.strictEqual(res.body.status.message, 'You do not have enough privileges for this action.');\n\t\t\t});\n\n\t\t\tit('should send invitation email (without groups to be joined)', async () => {\n\t\t\t\tmeta.config.registrationType = 'normal';\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'invite1@test.com', groupsToJoin: [] }, inviterUid, jar, csrf_token);\n\t\t\t\tassert.strictEqual(res.statusCode, 200);\n\t\t\t});\n\n\t\t\tit('should send multiple invitation emails (with a public group to be joined)', async () => {\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'invite2@test.com,invite3@test.com', groupsToJoin: [PUBLIC_GROUP] }, inviterUid, jar, csrf_token);\n\t\t\t\tassert.strictEqual(res.statusCode, 200);\n\t\t\t});\n\n\t\t\tit('should error if the user has not permission to invite to the group', async () => {\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'invite4@test.com', groupsToJoin: [PRIVATE_GROUP] }, inviterUid, jar, csrf_token);\n\t\t\t\tassert.strictEqual(res.statusCode, 403);\n\t\t\t\tassert.strictEqual(res.body.status.message, 'You do not have enough privileges for this action.');\n\t\t\t});\n\n\t\t\tit('should error if a non-admin tries to invite to the administrators group', async () => {\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'invite4@test.com', groupsToJoin: ['administrators'] }, inviterUid, jar, csrf_token);\n\t\t\t\tassert.strictEqual(res.statusCode, 403);\n\t\t\t\tassert.strictEqual(res.body.status.message, 'You do not have enough privileges for this action.');\n\t\t\t});\n\n\t\t\tit('should to invite to own private group', async () => {\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'invite4@test.com', groupsToJoin: [OWN_PRIVATE_GROUP] }, inviterUid, jar, csrf_token);\n\t\t\t\tassert.strictEqual(res.statusCode, 200);\n\t\t\t});\n\n\t\t\tit('should to invite to multiple groups', async () => {\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'invite5@test.com', groupsToJoin: [PUBLIC_GROUP, OWN_PRIVATE_GROUP] }, inviterUid, jar, csrf_token);\n\t\t\t\tassert.strictEqual(res.statusCode, 200);\n\t\t\t});\n\n\t\t\tit('should error if tries to invite to hidden group', async () => {\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'invite6@test.com', groupsToJoin: [HIDDEN_GROUP] }, inviterUid, jar, csrf_token);\n\t\t\t\tassert.strictEqual(res.statusCode, 403);\n\t\t\t});\n\n\t\t\tit('should error if ouf of invitations', async () => {\n\t\t\t\tmeta.config.maximumInvites = 1;\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'invite6@test.com', groupsToJoin: [] }, inviterUid, jar, csrf_token);\n\t\t\t\tassert.strictEqual(res.statusCode, 403);\n\t\t\t\tassert.strictEqual(res.body.status.message, `You have invited the maximum amount of people (${5} out of ${1}).`);\n\t\t\t\tmeta.config.maximumInvites = 10;\n\t\t\t});\n\n\t\t\tit('should send invitation email after maximumInvites increased', async () => {\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'invite6@test.com', groupsToJoin: [] }, inviterUid, jar, csrf_token);\n\t\t\t\tassert.strictEqual(res.statusCode, 200);\n\t\t\t});\n\n\t\t\tit('should error if invite is sent via API with a different UID', async () => {\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'inviter@nodebb.org', groupsToJoin: [] }, adminUid, jar, csrf_token);\n\t\t\t\tconst numInvites = await User.getInvitesNumber(adminUid);\n\t\t\t\tassert.strictEqual(res.statusCode, 403);\n\t\t\t\tassert.strictEqual(res.body.status.message, 'You do not have enough privileges for this action.');\n\t\t\t\tassert.strictEqual(numInvites, 0);\n\t\t\t});\n\n\t\t\tit('should succeed if email exists but not actually send an invite', async () => {\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'inviter@nodebb.org', groupsToJoin: [] }, inviterUid, jar, csrf_token);\n\t\t\t\tconst numInvites = await User.getInvitesNumber(adminUid);\n\n\t\t\t\tassert.strictEqual(res.statusCode, 200);\n\t\t\t\tassert.strictEqual(numInvites, 0);\n\t\t\t});\n\t\t});\n\n\t\tdescribe('when inviter is an admin', () => {\n\t\t\tlet csrf_token;\n\t\t\tlet jar;\n\n\t\t\tbefore((done) => {\n\t\t\t\thelpers.loginUser('adminInvite', COMMON_PW, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tjar = data.jar;\n\n\t\t\t\t\trequest({\n\t\t\t\t\t\turl: `${nconf.get('url')}/api/config`,\n\t\t\t\t\t\tjson: true,\n\t\t\t\t\t\tjar: jar,\n\t\t\t\t\t}, (err, response, body) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tcsrf_token = body.csrf_token;\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should escape email', async () => {\n\t\t\t\tawait helpers.invite({ emails: '<script>alert(\"ok\");</script>', groupsToJoin: [] }, adminUid, jar, csrf_token);\n\t\t\t\tconst data = await User.getInvites(adminUid);\n\t\t\t\tassert.strictEqual(data[0], '&lt;script&gt;alert(&quot;ok&quot;);&lt;&#x2F;script&gt;');\n\t\t\t\tawait User.deleteInvitationKey('<script>alert(\"ok\");</script>');\n\t\t\t});\n\n\t\t\tit('should invite to the administrators group if inviter is an admin', async () => {\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'invite99@test.com', groupsToJoin: ['administrators'] }, adminUid, jar, csrf_token);\n\t\t\t\tassert.strictEqual(res.statusCode, 200);\n\t\t\t});\n\t\t});\n\n\t\tdescribe('after invites checks', () => {\n\t\t\tit('should get user\\'s invites', (done) => {\n\t\t\t\tUser.getInvites(inviterUid, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tArray.from(Array(6)).forEach((_, i) => {\n\t\t\t\t\t\tassert.notEqual(data.indexOf(`invite${i + 1}@test.com`), -1);\n\t\t\t\t\t});\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should get all invites', (done) => {\n\t\t\t\tUser.getAllInvites((err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\n\t\t\t\t\tconst adminData = data.filter(d => parseInt(d.uid, 10) === adminUid)[0];\n\t\t\t\t\tassert.notEqual(adminData.invitations.indexOf('invite99@test.com'), -1);\n\n\t\t\t\t\tconst inviterData = data.filter(d => parseInt(d.uid, 10) === inviterUid)[0];\n\t\t\t\t\tArray.from(Array(6)).forEach((_, i) => {\n\t\t\t\t\t\tassert.notEqual(inviterData.invitations.indexOf(`invite${i + 1}@test.com`), -1);\n\t\t\t\t\t});\n\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should fail to verify invitation with invalid data', (done) => {\n\t\t\t\tUser.verifyInvitation({ token: '', email: '' }, (err) => {\n\t\t\t\t\tassert.strictEqual(err.message, '[[register:invite.error-invite-only]]');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should fail to verify invitation with invalid email', (done) => {\n\t\t\t\tUser.verifyInvitation({ token: 'test', email: 'doesnotexist@test.com' }, (err) => {\n\t\t\t\t\tassert.strictEqual(err.message, '[[register:invite.error-invalid-data]]');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should verify installation with no errors', (done) => {\n\t\t\t\tconst email = 'invite1@test.com';\n\t\t\t\tdb.get(`invitation:uid:${inviterUid}:invited:${email}`, 'token', (err, token) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tUser.verifyInvitation({ token: token, email: 'invite1@test.com' }, (err) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should error with invalid username', (done) => {\n\t\t\t\tUser.deleteInvitation('doesnotexist', 'test@test.com', (err) => {\n\t\t\t\t\tassert.equal(err.message, '[[error:invalid-username]]');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should delete invitation', (done) => {\n\t\t\t\tconst socketUser = require('../src/socket.io/user');\n\t\t\t\tsocketUser.deleteInvitation({ uid: adminUid }, { invitedBy: 'inviter', email: 'invite1@test.com' }, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tdb.isSetMember(`invitation:uid:${inviterUid}`, 'invite1@test.com', (err, isMember) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(isMember, false);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should delete invitation key', (done) => {\n\t\t\t\tUser.deleteInvitationKey('invite99@test.com', (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tdb.isSetMember(`invitation:uid:${adminUid}`, 'invite99@test.com', (err, isMember) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(isMember, false);\n\t\t\t\t\t\tdb.isSetMember('invitation:uids', adminUid, (err, isMember) => {\n\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\tassert.equal(isMember, false);\n\t\t\t\t\t\t\tdone();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should joined the groups from invitation after registration', async () => {\n\t\t\t\tconst email = 'invite5@test.com';\n\t\t\t\tconst groupsToJoin = [PUBLIC_GROUP, OWN_PRIVATE_GROUP];\n\t\t\t\tconst token = await db.get(`invitation:uid:${inviterUid}:invited:${email}`);\n\n\t\t\t\tawait new Promise((resolve, reject) => {\n\t\t\t\t\thelpers.registerUser({\n\t\t\t\t\t\tusername: 'invite5',\n\t\t\t\t\t\tpassword: '123456',\n\t\t\t\t\t\t'password-confirm': '123456',\n\t\t\t\t\t\temail: email,\n\t\t\t\t\t\tgdpr_consent: true,\n\t\t\t\t\t\ttoken: token,\n\t\t\t\t\t}, async (err, jar, response, body) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst memberships = await groups.isMemberOfGroups(body.uid, groupsToJoin);\n\t\t\t\t\t\tconst joinedToAll = memberships.filter(Boolean);\n\n\t\t\t\t\t\tif (joinedToAll.length !== groupsToJoin.length) {\n\t\t\t\t\t\t\treject(new Error('Not joined to the groups'));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tdescribe('invite groups', () => {\n\t\t\tlet csrf_token;\n\t\t\tlet jar;\n\n\t\t\tbefore((done) => {\n\t\t\t\thelpers.loginUser('inviter', COMMON_PW, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tjar = data.jar;\n\n\t\t\t\t\trequest({\n\t\t\t\t\t\turl: `${nconf.get('url')}/api/config`,\n\t\t\t\t\t\tjson: true,\n\t\t\t\t\t\tjar: jar,\n\t\t\t\t\t}, (err, response, body) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tcsrf_token = body.csrf_token;\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should show a list of groups for adding to an invite', async () => {\n\t\t\t\tconst body = await requestAsync({\n\t\t\t\t\turl: `${nconf.get('url')}/api/v3/users/${inviterUid}/invites/groups`,\n\t\t\t\t\tjson: true,\n\t\t\t\t\tjar,\n\t\t\t\t});\n\n\t\t\t\tassert(Array.isArray(body.response));\n\t\t\t\tassert.strictEqual(2, body.response.length);\n\t\t\t\tassert.deepStrictEqual(body.response, ['ownPrivateGroup', 'publicGroup']);\n\t\t\t});\n\n\t\t\tit('should error out if you request invite groups for another uid', async () => {\n\t\t\t\tconst res = await requestAsync({\n\t\t\t\t\turl: `${nconf.get('url')}/api/v3/users/${adminUid}/invites/groups`,\n\t\t\t\t\tjson: true,\n\t\t\t\t\tjar,\n\t\t\t\t\tsimple: false,\n\t\t\t\t\tresolveWithFullResponse: true,\n\t\t\t\t});\n\n\t\t\t\tassert.strictEqual(res.statusCode, 401);\n\t\t\t\tassert.deepStrictEqual(res.body, {\n\t\t\t\t\tstatus: {\n\t\t\t\t\t\tcode: 'not-authorised',\n\t\t\t\t\t\tmessage: 'A valid login session was not found. Please log in and try again.',\n\t\t\t\t\t},\n\t\t\t\t\tresponse: {},\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('email confirm', () => {\n\t\tit('should error with invalid code', (done) => {\n\t\t\tUser.email.confirmByCode('asdasda', (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should confirm email of user', async () => {\n\t\t\tconst email = 'confirm@me.com';\n\t\t\tconst uid = await User.create({\n\t\t\t\tusername: 'confirme',\n\t\t\t\temail: email,\n\t\t\t});\n\n\t\t\tconst code = await User.email.sendValidationEmail(uid, { email, force: 1 });\n\t\t\tconst unverified = await groups.isMember(uid, 'unverified-users');\n\t\t\tassert.strictEqual(unverified, true);\n\t\t\tawait User.email.confirmByCode(code);\n\t\t\tconst [confirmed, isVerified] = await Promise.all([\n\t\t\t\tdb.getObjectField(`user:${uid}`, 'email:confirmed'),\n\t\t\t\tgroups.isMember(uid, 'verified-users', uid),\n\t\t\t]);\n\t\t\tassert.strictEqual(parseInt(confirmed, 10), 1);\n\t\t\tassert.strictEqual(isVerified, true);\n\t\t});\n\n\t\tit('should confirm email of user by uid', async () => {\n\t\t\tconst email = 'confirm2@me.com';\n\t\t\tconst uid = await User.create({\n\t\t\t\tusername: 'confirme2',\n\t\t\t\temail,\n\t\t\t});\n\t\t\tawait User.setUserField(uid, 'email', email);\n\n\t\t\tconst unverified = await groups.isMember(uid, 'unverified-users');\n\t\t\tassert.strictEqual(unverified, true);\n\t\t\tawait User.email.confirmByUid(uid);\n\t\t\tconst [confirmed, isVerified] = await Promise.all([\n\t\t\t\tdb.getObjectField(`user:${uid}`, 'email:confirmed'),\n\t\t\t\tgroups.isMember(uid, 'verified-users', uid),\n\t\t\t]);\n\t\t\tassert.strictEqual(parseInt(confirmed, 10), 1);\n\t\t\tassert.strictEqual(isVerified, true);\n\t\t});\n\n\t\tit('should remove the email from a different account if the email is already in use', async () => {\n\t\t\tconst email = 'confirm2@me.com';\n\t\t\tconst uid = await User.create({\n\t\t\t\tusername: 'confirme3',\n\t\t\t});\n\n\t\t\tconst oldUid = await db.sortedSetScore('email:uid', email);\n\t\t\tconst code = await User.email.sendValidationEmail(uid, email);\n\t\t\tawait User.email.confirmByCode(code);\n\n\t\t\tconst oldUserData = await User.getUserData(oldUid);\n\n\t\t\tassert.strictEqual((await db.sortedSetScore('email:uid', email)), uid);\n\t\t\tassert.strictEqual(oldUserData.email, '');\n\t\t});\n\t});\n\n\tdescribe('user jobs', () => {\n\t\tit('should start user jobs', (done) => {\n\t\t\tUser.startJobs();\n\t\t\tdone();\n\t\t});\n\n\t\tit('should stop user jobs', (done) => {\n\t\t\tUser.stopJobs();\n\t\t\tdone();\n\t\t});\n\n\t\tit('should send digest', (done) => {\n\t\t\tdb.sortedSetAdd('digest:day:uids', [Date.now(), Date.now()], [1, 2], (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tUser.digest.execute({ interval: 'day' }, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('hideEmail/hideFullname', () => {\n\t\tconst COMMON_PW = '123456';\n\t\tconst hidingUser = {\n\t\t\tusername: 'hiddenemail',\n\t\t\temail: 'should@be.hidden',\n\t\t\tfullname: 'baris soner usakli',\n\t\t\tpassword: COMMON_PW,\n\t\t};\n\t\tconst regularUser = {\n\t\t\tusername: 'regularUser',\n\t\t\temail: 'regular@example.com',\n\t\t\tfullname: 'regular user',\n\t\t\tpassword: COMMON_PW,\n\t\t};\n\t\tlet hidingUserJar;\n\t\tlet adminUid;\n\t\tlet adminJar;\n\t\tlet globalModJar;\n\t\tlet regularUserJar;\n\n\t\tbefore(async () => {\n\t\t\tadminUid = await User.create({\n\t\t\t\tusername: 'adminhideemail',\n\t\t\t\tpassword: COMMON_PW,\n\t\t\t});\n\t\t\tawait groups.join('administrators', adminUid);\n\t\t\t({ jar: adminJar } = await helpers.loginUser('adminhideemail', COMMON_PW));\n\n\t\t\t// Edge case: In a grepped test, this user should not be created as the first user to have its email not confirmed\n\t\t\thidingUser.uid = await User.create(hidingUser);\n\t\t\t({ jar: hidingUserJar } = await helpers.loginUser(hidingUser.username, COMMON_PW));\n\n\t\t\tconst globalModUid = await User.create({\n\t\t\t\tusername: 'globalmodhideemail',\n\t\t\t\tpassword: COMMON_PW,\n\t\t\t});\n\t\t\tawait groups.join('Global Moderators', globalModUid);\n\t\t\t({ jar: globalModJar } = await helpers.loginUser('globalmodhideemail', COMMON_PW));\n\n\t\t\tregularUser.uid = await User.create(regularUser);\n\t\t\t({ jar: regularUserJar } = await helpers.loginUser(regularUser.username, COMMON_PW));\n\t\t});\n\n\t\tafter((done) => {\n\t\t\tmeta.config.hideEmail = 0;\n\t\t\tmeta.config.hideFullname = 0;\n\t\t\tdone();\n\t\t});\n\n\t\tasync function assertPrivacy({ expectVisible, jar, v3Api, emailOnly }) {\n\t\t\tconst path = v3Api ? `v3/users/${hidingUser.uid}` : `user/${hidingUser.username}`;\n\t\t\tconst response = await requestAsync(`${nconf.get('url')}/api/${path}`, { json: true, jar });\n\t\t\tconst { response: userData } = v3Api ? response : { response };\n\n\t\t\tassert.strictEqual(userData.email, expectVisible ? hidingUser.email : '');\n\t\t\tif (!emailOnly) {\n\t\t\t\tassert.strictEqual(userData.fullname, expectVisible ? hidingUser.fullname : '');\n\t\t\t}\n\t\t}\n\n\t\tit('should hide unconfirmed emails on profile pages', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, emailOnly: true });\n\t\t\tawait assertPrivacy({ v3Api: false, jar: hidingUserJar, emailOnly: true });\n\t\t\tawait assertPrivacy({ v3Api: false, jar: adminJar, emailOnly: true });\n\t\t\tawait assertPrivacy({ v3Api: false, jar: globalModJar, emailOnly: true });\n\t\t\tawait assertPrivacy({ v3Api: false, jar: regularUserJar, emailOnly: true });\n\n\t\t\t// Let's confirm for afterwards\n\t\t\tawait User.email.confirmByUid(hidingUser.uid);\n\t\t});\n\n\t\tit('should hide from guests by default', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false });\n\t\t});\n\n\t\tit('should hide from unprivileged users by default', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, jar: regularUserJar });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: regularUserJar });\n\t\t});\n\n\t\tit('should be visible to self by default', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, jar: hidingUserJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: hidingUserJar, expectVisible: true });\n\t\t});\n\n\t\tit('should be visible to privileged users by default', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, jar: adminJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: adminJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: false, jar: globalModJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: globalModJar, expectVisible: true });\n\t\t});\n\n\t\tit('should hide from guests (system-wide: hide, by-user: hide)', async () => {\n\t\t\tmeta.config.hideEmail = 1;\n\t\t\tmeta.config.hideFullname = 1;\n\t\t\t// Explicitly set user's privacy settings to hide its email and fullname\n\t\t\tconst data = { uid: hidingUser.uid, settings: { showemail: 0, showfullname: 0 } };\n\t\t\tawait apiUser.updateSettings({ uid: hidingUser.uid }, data);\n\n\t\t\tawait assertPrivacy({ v3Api: false });\n\t\t});\n\n\t\tit('should hide from unprivileged users (system-wide: hide, by-user: hide)', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, jar: regularUserJar });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: regularUserJar });\n\t\t});\n\n\t\tit('should be visible to self (system-wide: hide, by-user: hide)', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, jar: hidingUserJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: hidingUserJar, expectVisible: true });\n\t\t});\n\n\t\tit('should be visible to privileged users (system-wide: hide, by-user: hide)', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, jar: adminJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: adminJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: false, jar: globalModJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: globalModJar, expectVisible: true });\n\t\t});\n\n\t\tit('should hide from guests (system-wide: show, by-user: hide)', async () => {\n\t\t\tmeta.config.hideEmail = 0;\n\t\t\tmeta.config.hideFullname = 0;\n\n\t\t\tawait assertPrivacy({ v3Api: false });\n\t\t});\n\n\t\tit('should hide from unprivileged users (system-wide: show, by-user: hide)', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, jar: regularUserJar });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: regularUserJar });\n\t\t});\n\n\t\tit('should be visible to self (system-wide: show, by-user: hide)', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, jar: hidingUserJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: hidingUserJar, expectVisible: true });\n\t\t});\n\n\t\tit('should be visible to privileged users (system-wide: show, by-user: hide)', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, jar: adminJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: adminJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: false, jar: globalModJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: globalModJar, expectVisible: true });\n\t\t});\n\n\t\tit('should be visible to guests (system-wide: show, by-user: show)', async () => {\n\t\t\tmeta.config.hideEmail = 0;\n\t\t\tmeta.config.hideFullname = 0;\n\n\t\t\t// Set user's individual privacy settings to show its email and fullname\n\t\t\tconst data = { uid: hidingUser.uid, settings: { showemail: 1, showfullname: 1 } };\n\t\t\tawait apiUser.updateSettings({ uid: hidingUser.uid }, data);\n\n\t\t\tawait assertPrivacy({ v3Api: false, expectVisible: true });\n\t\t});\n\n\t\tit('should be visible to unprivileged users (system-wide: show, by-user: show)', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, jar: regularUserJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: regularUserJar, expectVisible: true });\n\t\t});\n\n\t\t// System-wide \"hide\" prioritized over individual users' settings\n\t\tit('should hide from guests (system-wide: hide, by-user: show)', async () => {\n\t\t\tmeta.config.hideEmail = 1;\n\t\t\tmeta.config.hideFullname = 1;\n\n\t\t\tawait assertPrivacy({ v3Api: false });\n\t\t});\n\n\t\tit('should hide from unprivileged users (system-wide: hide, by-user: show)', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, jar: regularUserJar });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: regularUserJar });\n\t\t});\n\n\t\tit('should be visible to self (system-wide: hide, by-user: show)', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, jar: hidingUserJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: hidingUserJar, expectVisible: true });\n\t\t});\n\n\t\tit('should be visible to privileged users (system-wide: hide, by-user: show)', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, jar: adminJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: adminJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: false, jar: globalModJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: globalModJar, expectVisible: true });\n\t\t});\n\n\t\tit('should handle array of user data (system-wide: hide)', async () => {\n\t\t\tconst userData = await User.hidePrivateData([hidingUser, regularUser], hidingUser.uid);\n\t\t\tassert.strictEqual(userData[0].fullname, hidingUser.fullname);\n\t\t\tassert.strictEqual(userData[0].email, hidingUser.email);\n\t\t\tassert.strictEqual(userData[1].fullname, '');\n\t\t\tassert.strictEqual(userData[1].email, '');\n\t\t});\n\n\t\tit('should hide fullname in topic list and topic', (done) => {\n\t\t\tTopics.post({\n\t\t\t\tuid: hidingUser.uid,\n\t\t\t\ttitle: 'Topic hidden',\n\t\t\t\tcontent: 'lorem ipsum',\n\t\t\t\tcid: testCid,\n\t\t\t}, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\trequest(`${nconf.get('url')}/api/recent`, { json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert(!body.topics[0].user.hasOwnProperty('fullname'));\n\t\t\t\t\trequest(`${nconf.get('url')}/api/topic/${body.topics[0].slug}`, { json: true }, (err, res, body) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert(!body.posts[0].user.hasOwnProperty('fullname'));\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('user blocking methods', (done) => {\n\t\tlet blockeeUid;\n\t\tbefore((done) => {\n\t\t\tUser.create({\n\t\t\t\tusername: 'blockee',\n\t\t\t\temail: 'blockee@example.org',\n\t\t\t\tfullname: 'Block me',\n\t\t\t}, (err, uid) => {\n\t\t\t\tblockeeUid = uid;\n\t\t\t\tdone(err);\n\t\t\t});\n\t\t});\n\n\t\tdescribe('.toggle()', () => {\n\t\t\tit('should toggle block', (done) => {\n\t\t\t\tsocketUser.toggleBlock({ uid: 1 }, { blockerUid: 1, blockeeUid: blockeeUid }, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tUser.blocks.is(blockeeUid, 1, (err, blocked) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert(blocked);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should toggle block', (done) => {\n\t\t\t\tsocketUser.toggleBlock({ uid: 1 }, { blockerUid: 1, blockeeUid: blockeeUid }, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tUser.blocks.is(blockeeUid, 1, (err, blocked) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert(!blocked);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tdescribe('.add()', () => {\n\t\t\tit('should block a uid', (done) => {\n\t\t\t\tUser.blocks.add(blockeeUid, 1, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tUser.blocks.list(1, (err, blocked_uids) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.strictEqual(Array.isArray(blocked_uids), true);\n\t\t\t\t\t\tassert.strictEqual(blocked_uids.length, 1);\n\t\t\t\t\t\tassert.strictEqual(blocked_uids.includes(blockeeUid), true);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should automatically increment corresponding user field', (done) => {\n\t\t\t\tdb.getObjectField('user:1', 'blocksCount', (err, count) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(parseInt(count, 10), 1);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should error if you try to block the same uid again', (done) => {\n\t\t\t\tUser.blocks.add(blockeeUid, 1, (err) => {\n\t\t\t\t\tassert.equal(err.message, '[[error:already-blocked]]');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tdescribe('.remove()', () => {\n\t\t\tit('should unblock a uid', (done) => {\n\t\t\t\tUser.blocks.remove(blockeeUid, 1, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tUser.blocks.list(1, (err, blocked_uids) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.strictEqual(Array.isArray(blocked_uids), true);\n\t\t\t\t\t\tassert.strictEqual(blocked_uids.length, 0);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should automatically decrement corresponding user field', (done) => {\n\t\t\t\tdb.getObjectField('user:1', 'blocksCount', (err, count) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(parseInt(count, 10), 0);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should error if you try to unblock the same uid again', (done) => {\n\t\t\t\tUser.blocks.remove(blockeeUid, 1, (err) => {\n\t\t\t\t\tassert.equal(err.message, '[[error:already-unblocked]]');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tdescribe('.is()', () => {\n\t\t\tbefore((done) => {\n\t\t\t\tUser.blocks.add(blockeeUid, 1, done);\n\t\t\t});\n\n\t\t\tit('should return a Boolean with blocked status for the queried uid', (done) => {\n\t\t\t\tUser.blocks.is(blockeeUid, 1, (err, blocked) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(blocked, true);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tdescribe('.list()', () => {\n\t\t\tit('should return a list of blocked uids', (done) => {\n\t\t\t\tUser.blocks.list(1, (err, blocked_uids) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(Array.isArray(blocked_uids), true);\n\t\t\t\t\tassert.strictEqual(blocked_uids.length, 1);\n\t\t\t\t\tassert.strictEqual(blocked_uids.includes(blockeeUid), true);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tdescribe('.filter()', () => {\n\t\t\tit('should remove entries by blocked uids and return filtered set', (done) => {\n\t\t\t\tUser.blocks.filter(1, [{\n\t\t\t\t\tfoo: 'foo',\n\t\t\t\t\tuid: blockeeUid,\n\t\t\t\t}, {\n\t\t\t\t\tfoo: 'bar',\n\t\t\t\t\tuid: 1,\n\t\t\t\t}, {\n\t\t\t\t\tfoo: 'baz',\n\t\t\t\t\tuid: blockeeUid,\n\t\t\t\t}], (err, filtered) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(Array.isArray(filtered), true);\n\t\t\t\t\tassert.strictEqual(filtered.length, 1);\n\t\t\t\t\tassert.equal(filtered[0].uid, 1);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should allow property argument to be passed in to customise checked property', (done) => {\n\t\t\t\tUser.blocks.filter(1, 'fromuid', [{\n\t\t\t\t\tfoo: 'foo',\n\t\t\t\t\tfromuid: blockeeUid,\n\t\t\t\t}, {\n\t\t\t\t\tfoo: 'bar',\n\t\t\t\t\tfromuid: 1,\n\t\t\t\t}, {\n\t\t\t\t\tfoo: 'baz',\n\t\t\t\t\tfromuid: blockeeUid,\n\t\t\t\t}], (err, filtered) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(Array.isArray(filtered), true);\n\t\t\t\t\tassert.strictEqual(filtered.length, 1);\n\t\t\t\t\tassert.equal(filtered[0].fromuid, 1);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should not process invalid sets', (done) => {\n\t\t\t\tUser.blocks.filter(1, [{ foo: 'foo' }, { foo: 'bar' }, { foo: 'baz' }], (err, filtered) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(Array.isArray(filtered), true);\n\t\t\t\t\tassert.strictEqual(filtered.length, 3);\n\t\t\t\t\tfiltered.forEach((obj) => {\n\t\t\t\t\t\tassert.strictEqual(obj.hasOwnProperty('foo'), true);\n\t\t\t\t\t});\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should process plain sets that just contain uids', (done) => {\n\t\t\t\tUser.blocks.filter(1, [1, blockeeUid], (err, filtered) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(filtered.length, 1);\n\t\t\t\t\tassert.strictEqual(filtered[0], 1);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should filter uids that are blocking targetUid', (done) => {\n\t\t\t\tUser.blocks.filterUids(blockeeUid, [1, 2], (err, filtered) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.deepEqual(filtered, [2]);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('status/online', () => {\n\t\tit('should return offline if user is guest', (done) => {\n\t\t\tconst status = User.getStatus({ uid: 0 });\n\t\t\tassert.strictEqual(status, 'offline');\n\t\t\tdone();\n\t\t});\n\n\t\tit('should return offline if user is guest', async () => {\n\t\t\tassert.strictEqual(await User.isOnline(0), false);\n\t\t});\n\n\t\tit('should return true', async () => {\n\t\t\tassert.strictEqual(await User.isOnline(testUid), true);\n\t\t});\n\t});\n\n\tdescribe('isPrivilegedOrSelf', () => {\n\t\tit('should return not error if self', (done) => {\n\t\t\tUser.isPrivilegedOrSelf(1, 1, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should not error if privileged', (done) => {\n\t\t\tUser.create({ username: 'theadmin' }, (err, uid) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tgroups.join('administrators', uid, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tUser.isPrivilegedOrSelf(uid, 2, (err) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should error if not privileged', (done) => {\n\t\t\tUser.isPrivilegedOrSelf(0, 1, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should get admins and mods', (done) => {\n\t\tUser.getAdminsandGlobalMods((err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(Array.isArray(data));\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should allow user to login even if password is weak', (done) => {\n\t\tUser.create({ username: 'weakpwd', password: '123456' }, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tconst oldValue = meta.config.minimumPasswordStrength;\n\t\t\tmeta.config.minimumPasswordStrength = 3;\n\t\t\thelpers.loginUser('weakpwd', '123456', (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tmeta.config.minimumPasswordStrength = oldValue;\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('User\\'s', async () => {\n\t\tlet files;\n\n\t\tbefore(async () => {\n\t\t\tfiles = await file.walk(path.resolve(__dirname, './user'));\n\t\t});\n\n\t\tit('subfolder tests', () => {\n\t\t\tfiles.forEach((filePath) => {\n\t\t\t\trequire(filePath);\n\t\t\t});\n\t\t});\n\t});\n});\n"], "fixing_code": ["'use strict';\n\nconst _ = require('lodash');\nconst assert = require('assert');\nconst path = require('path');\nconst fs = require('fs');\nconst SwaggerParser = require('@apidevtools/swagger-parser');\nconst request = require('request-promise-native');\nconst nconf = require('nconf');\nconst jwt = require('jsonwebtoken');\nconst util = require('util');\n\nconst wait = util.promisify(setTimeout);\n\nconst db = require('./mocks/databasemock');\nconst helpers = require('./helpers');\nconst meta = require('../src/meta');\nconst user = require('../src/user');\nconst groups = require('../src/groups');\nconst categories = require('../src/categories');\nconst topics = require('../src/topics');\nconst posts = require('../src/posts');\nconst plugins = require('../src/plugins');\nconst flags = require('../src/flags');\nconst messaging = require('../src/messaging');\nconst utils = require('../src/utils');\n\ndescribe('API', async () => {\n\tlet readApi = false;\n\tlet writeApi = false;\n\tconst readApiPath = path.resolve(__dirname, '../public/openapi/read.yaml');\n\tconst writeApiPath = path.resolve(__dirname, '../public/openapi/write.yaml');\n\tlet jar;\n\tlet csrfToken;\n\tlet setup = false;\n\tconst unauthenticatedRoutes = ['/api/login', '/api/register']; // Everything else will be called with the admin user\n\n\tconst mocks = {\n\t\thead: {},\n\t\tget: {\n\t\t\t'/api/email/unsubscribe/{token}': [\n\t\t\t\t{\n\t\t\t\t\tin: 'path',\n\t\t\t\t\tname: 'token',\n\t\t\t\t\texample: (() => jwt.sign({\n\t\t\t\t\t\ttemplate: 'digest',\n\t\t\t\t\t\tuid: 1,\n\t\t\t\t\t}, nconf.get('secret')))(),\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t\tpost: {},\n\t\tput: {},\n\t\tdelete: {\n\t\t\t'/users/{uid}/tokens/{token}': [\n\t\t\t\t{\n\t\t\t\t\tin: 'path',\n\t\t\t\t\tname: 'uid',\n\t\t\t\t\texample: 1,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tin: 'path',\n\t\t\t\t\tname: 'token',\n\t\t\t\t\texample: utils.generateUUID(),\n\t\t\t\t},\n\t\t\t],\n\t\t\t'/users/{uid}/sessions/{uuid}': [\n\t\t\t\t{\n\t\t\t\t\tin: 'path',\n\t\t\t\t\tname: 'uid',\n\t\t\t\t\texample: 1,\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tin: 'path',\n\t\t\t\t\tname: 'uuid',\n\t\t\t\t\texample: '', // to be defined below...\n\t\t\t\t},\n\t\t\t],\n\t\t\t'/posts/{pid}/diffs/{timestamp}': [\n\t\t\t\t{\n\t\t\t\t\tin: 'path',\n\t\t\t\t\tname: 'pid',\n\t\t\t\t\texample: '', // to be defined below...\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\tin: 'path',\n\t\t\t\t\tname: 'timestamp',\n\t\t\t\t\texample: '', // to be defined below...\n\t\t\t\t},\n\t\t\t],\n\t\t},\n\t};\n\n\tasync function dummySearchHook(data) {\n\t\treturn [1];\n\t}\n\tasync function dummyEmailerHook(data) {\n\t\t// pretend to handle sending emails\n\t}\n\n\tafter(async () => {\n\t\tplugins.hooks.unregister('core', 'filter:search.query', dummySearchHook);\n\t\tplugins.hooks.unregister('emailer-test', 'filter:email.send');\n\t});\n\n\tasync function setupData() {\n\t\tif (setup) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Create sample users\n\t\tconst adminUid = await user.create({ username: 'admin', password: '123456', email: 'test@example.org' });\n\t\tconst unprivUid = await user.create({ username: 'unpriv', password: '123456', email: 'unpriv@example.org' });\n\t\tawait user.setUserField(adminUid, 'email', 'test@example.org');\n\t\tawait user.setUserField(unprivUid, 'email', 'unpriv@example.org');\n\t\tawait user.email.confirmByUid(adminUid);\n\t\tawait user.email.confirmByUid(unprivUid);\n\n\t\tfor (let x = 0; x < 4; x++) {\n\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\tawait user.create({ username: 'deleteme', password: '123456' }); // for testing of DELETE /users (uids 5, 6) and DELETE /user/:uid/account (uid 7)\n\t\t}\n\t\tawait groups.join('administrators', adminUid);\n\n\t\t// Create sample group\n\t\tawait groups.create({\n\t\t\tname: 'Test Group',\n\t\t});\n\n\t\tawait meta.settings.set('core.api', {\n\t\t\ttokens: [{\n\t\t\t\ttoken: mocks.delete['/users/{uid}/tokens/{token}'][1].example,\n\t\t\t\tuid: 1,\n\t\t\t\tdescription: 'for testing of token deletion route',\n\t\t\t\ttimestamp: Date.now(),\n\t\t\t}],\n\t\t});\n\t\tmeta.config.allowTopicsThumbnail = 1;\n\t\tmeta.config.termsOfUse = 'I, for one, welcome our new test-driven overlords';\n\t\tmeta.config.chatMessageDelay = 0;\n\n\t\t// Create a category\n\t\tconst testCategory = await categories.create({ name: 'test' });\n\n\t\t// Post a new topic\n\t\tawait topics.post({\n\t\t\tuid: adminUid,\n\t\t\tcid: testCategory.cid,\n\t\t\ttitle: 'Test Topic',\n\t\t\tcontent: 'Test topic content',\n\t\t});\n\t\tconst unprivTopic = await topics.post({\n\t\t\tuid: unprivUid,\n\t\t\tcid: testCategory.cid,\n\t\t\ttitle: 'Test Topic 2',\n\t\t\tcontent: 'Test topic 2 content',\n\t\t});\n\t\tawait topics.post({\n\t\t\tuid: unprivUid,\n\t\t\tcid: testCategory.cid,\n\t\t\ttitle: 'Test Topic 3',\n\t\t\tcontent: 'Test topic 3 content',\n\t\t});\n\n\t\t// Create a post diff\n\t\tawait posts.edit({\n\t\t\tuid: adminUid,\n\t\t\tpid: unprivTopic.postData.pid,\n\t\t\tcontent: 'Test topic 2 edited content',\n\t\t\treq: {},\n\t\t});\n\t\tmocks.delete['/posts/{pid}/diffs/{timestamp}'][0].example = unprivTopic.postData.pid;\n\t\tmocks.delete['/posts/{pid}/diffs/{timestamp}'][1].example = (await posts.diffs.list(unprivTopic.postData.pid))[0];\n\n\t\t// Create a sample flag\n\t\tconst { flagId } = await flags.create('post', 1, unprivUid, 'sample reasons', Date.now()); // deleted in DELETE /api/v3/flags/1\n\t\tawait flags.appendNote(flagId, 1, 'test note', 1626446956652);\n\t\tawait flags.create('post', 2, unprivUid, 'sample reasons', Date.now()); // for testing flag notes (since flag 1 deleted)\n\n\t\t// Create a new chat room\n\t\tawait messaging.newRoom(1, [2]);\n\n\t\t// Create an empty file to test DELETE /files and thumb deletion\n\t\tfs.closeSync(fs.openSync(path.resolve(nconf.get('upload_path'), 'files/test.txt'), 'w'));\n\t\tfs.closeSync(fs.openSync(path.resolve(nconf.get('upload_path'), 'files/test.png'), 'w'));\n\n\t\t// Associate thumb with topic to test thumb reordering\n\t\tawait topics.thumbs.associate({\n\t\t\tid: 2,\n\t\t\tpath: 'files/test.png',\n\t\t});\n\n\t\tconst socketUser = require('../src/socket.io/user');\n\t\tconst socketAdmin = require('../src/socket.io/admin');\n\t\t// export data for admin user\n\t\tawait socketUser.exportProfile({ uid: adminUid }, { uid: adminUid });\n\t\tawait wait(2000);\n\t\tawait socketUser.exportPosts({ uid: adminUid }, { uid: adminUid });\n\t\tawait wait(2000);\n\t\tawait socketUser.exportUploads({ uid: adminUid }, { uid: adminUid });\n\t\tawait wait(2000);\n\t\tawait socketAdmin.user.exportUsersCSV({ uid: adminUid }, {});\n\t\t// wait for export child process to complete\n\t\tawait wait(5000);\n\n\t\t// Attach a search hook so /api/search is enabled\n\t\tplugins.hooks.register('core', {\n\t\t\thook: 'filter:search.query',\n\t\t\tmethod: dummySearchHook,\n\t\t});\n\t\t// Attach an emailer hook so related requests do not error\n\t\tplugins.hooks.register('emailer-test', {\n\t\t\thook: 'filter:email.send',\n\t\t\tmethod: dummyEmailerHook,\n\t\t});\n\n\t\t// All tests run as admin user\n\t\t({ jar } = await helpers.loginUser('admin', '123456'));\n\n\t\t// Retrieve CSRF token using cookie, to test Write API\n\t\tconst config = await request({\n\t\t\turl: `${nconf.get('url')}/api/config`,\n\t\t\tjson: true,\n\t\t\tjar: jar,\n\t\t});\n\t\tcsrfToken = config.csrf_token;\n\n\t\tsetup = true;\n\t}\n\n\tit('should pass OpenAPI v3 validation', async () => {\n\t\ttry {\n\t\t\tawait SwaggerParser.validate(readApiPath);\n\t\t\tawait SwaggerParser.validate(writeApiPath);\n\t\t} catch (e) {\n\t\t\tassert.ifError(e);\n\t\t}\n\t});\n\n\treadApi = await SwaggerParser.dereference(readApiPath);\n\twriteApi = await SwaggerParser.dereference(writeApiPath);\n\n\tit('should grab all mounted routes and ensure a schema exists', async () => {\n\t\tconst webserver = require('../src/webserver');\n\t\tconst buildPaths = function (stack, prefix) {\n\t\t\tconst paths = stack.map((dispatch) => {\n\t\t\t\tif (dispatch.route && dispatch.route.path && typeof dispatch.route.path === 'string') {\n\t\t\t\t\tif (!prefix && !dispatch.route.path.startsWith('/api/')) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (prefix === nconf.get('relative_path')) {\n\t\t\t\t\t\tprefix = '';\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tmethod: Object.keys(dispatch.route.methods)[0],\n\t\t\t\t\t\tpath: (prefix || '') + dispatch.route.path,\n\t\t\t\t\t};\n\t\t\t\t} else if (dispatch.name === 'router') {\n\t\t\t\t\tconst prefix = dispatch.regexp.toString().replace('/^', '').replace('\\\\/?(?=\\\\/|$)/i', '').replace(/\\\\\\//g, '/');\n\t\t\t\t\treturn buildPaths(dispatch.handle.stack, prefix);\n\t\t\t\t}\n\n\t\t\t\t// Drop any that aren't actual routes (middlewares, error handlers, etc.)\n\t\t\t\treturn null;\n\t\t\t});\n\n\t\t\treturn _.flatten(paths);\n\t\t};\n\n\t\tlet paths = buildPaths(webserver.app._router.stack).filter(Boolean).map((pathObj) => {\n\t\t\tpathObj.path = pathObj.path.replace(/\\/:([^\\\\/]+)/g, '/{$1}');\n\t\t\treturn pathObj;\n\t\t});\n\t\tconst exclusionPrefixes = [\n\t\t\t'/api/admin/plugins', '/api/compose', '/debug',\n\t\t\t'/api/user/{userslug}/theme', // from persona\n\t\t];\n\t\tpaths = paths.filter(path => path.method !== '_all' && !exclusionPrefixes.some(prefix => path.path.startsWith(prefix)));\n\n\n\t\t// For each express path, query for existence in read and write api schemas\n\t\tpaths.forEach((pathObj) => {\n\t\t\tdescribe(`${pathObj.method.toUpperCase()} ${pathObj.path}`, () => {\n\t\t\t\tit('should be defined in schema docs', () => {\n\t\t\t\t\tlet schema = readApi;\n\t\t\t\t\tif (pathObj.path.startsWith('/api/v3')) {\n\t\t\t\t\t\tschema = writeApi;\n\t\t\t\t\t\tpathObj.path = pathObj.path.replace('/api/v3', '');\n\t\t\t\t\t}\n\n\t\t\t\t\t// Don't check non-GET routes in Read API\n\t\t\t\t\tif (schema === readApi && pathObj.method !== 'get') {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst normalizedPath = pathObj.path.replace(/\\/:([^\\\\/]+)/g, '/{$1}').replace(/\\?/g, '');\n\t\t\t\t\tassert(schema.paths.hasOwnProperty(normalizedPath), `${pathObj.path} is not defined in schema docs`);\n\t\t\t\t\tassert(schema.paths[normalizedPath].hasOwnProperty(pathObj.method), `${pathObj.path} was found in schema docs, but ${pathObj.method.toUpperCase()} method is not defined`);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\t// generateTests(readApi, Object.keys(readApi.paths));\n\tgenerateTests(writeApi, Object.keys(writeApi.paths), writeApi.servers[0].url);\n\n\tfunction generateTests(api, paths, prefix) {\n\t\t// Iterate through all documented paths, make a call to it,\n\t\t// and compare the result body with what is defined in the spec\n\t\tconst pathLib = path; // for calling path module from inside this forEach\n\t\tpaths.forEach((path) => {\n\t\t\tconst context = api.paths[path];\n\t\t\tlet schema;\n\t\t\tlet response;\n\t\t\tlet url;\n\t\t\tlet method;\n\t\t\tconst headers = {};\n\t\t\tconst qs = {};\n\n\t\t\tObject.keys(context).forEach((_method) => {\n\t\t\t\t// Only test GET routes in the Read API\n\t\t\t\tif (api.info.title === 'NodeBB Read API' && _method !== 'get') {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tit('should have each path parameter defined in its context', () => {\n\t\t\t\t\tmethod = _method;\n\t\t\t\t\tif (!context[method].parameters) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst pathParams = (path.match(/{[\\w\\-_*]+}?/g) || []).map(match => match.slice(1, -1));\n\t\t\t\t\tconst schemaParams = context[method].parameters.map(param => (param.in === 'path' ? param.name : null)).filter(Boolean);\n\t\t\t\t\tassert(pathParams.every(param => schemaParams.includes(param)), `${method.toUpperCase()} ${path} has path parameters specified but not defined`);\n\t\t\t\t});\n\n\t\t\t\tit('should have examples when parameters are present', () => {\n\t\t\t\t\tlet { parameters } = context[method];\n\t\t\t\t\tlet testPath = path;\n\n\t\t\t\t\tif (parameters) {\n\t\t\t\t\t\t// Use mock data if provided\n\t\t\t\t\t\tparameters = mocks[method][path] || parameters;\n\n\t\t\t\t\t\tparameters.forEach((param) => {\n\t\t\t\t\t\t\tassert(param.example !== null && param.example !== undefined, `${method.toUpperCase()} ${path} has parameters without examples`);\n\n\t\t\t\t\t\t\tswitch (param.in) {\n\t\t\t\t\t\t\t\tcase 'path':\n\t\t\t\t\t\t\t\t\ttestPath = testPath.replace(`{${param.name}}`, param.example);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'header':\n\t\t\t\t\t\t\t\t\theaders[param.name] = param.example;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\tcase 'query':\n\t\t\t\t\t\t\t\t\tqs[param.name] = param.example;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t\turl = nconf.get('url') + (prefix || '') + testPath;\n\t\t\t\t});\n\n\t\t\t\tit('should contain a valid request body (if present) with application/json or multipart/form-data type if POST/PUT/DELETE', () => {\n\t\t\t\t\tif (['post', 'put', 'delete'].includes(method) && context[method].hasOwnProperty('requestBody')) {\n\t\t\t\t\t\tconst failMessage = `${method.toUpperCase()} ${path} has a malformed request body`;\n\t\t\t\t\t\tassert(context[method].requestBody, failMessage);\n\t\t\t\t\t\tassert(context[method].requestBody.content, failMessage);\n\n\t\t\t\t\t\tif (context[method].requestBody.content.hasOwnProperty('application/json')) {\n\t\t\t\t\t\t\tassert(context[method].requestBody.content['application/json'], failMessage);\n\t\t\t\t\t\t\tassert(context[method].requestBody.content['application/json'].schema, failMessage);\n\t\t\t\t\t\t\tassert(context[method].requestBody.content['application/json'].schema.properties, failMessage);\n\t\t\t\t\t\t} else if (context[method].requestBody.content.hasOwnProperty('multipart/form-data')) {\n\t\t\t\t\t\t\tassert(context[method].requestBody.content['multipart/form-data'], failMessage);\n\t\t\t\t\t\t\tassert(context[method].requestBody.content['multipart/form-data'].schema, failMessage);\n\t\t\t\t\t\t\tassert(context[method].requestBody.content['multipart/form-data'].schema.properties, failMessage);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tit('should not error out when called', async () => {\n\t\t\t\t\tawait setupData();\n\n\t\t\t\t\tif (csrfToken) {\n\t\t\t\t\t\theaders['x-csrf-token'] = csrfToken;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet body = {};\n\t\t\t\t\tlet type = 'json';\n\t\t\t\t\tif (context[method].hasOwnProperty('requestBody') && context[method].requestBody.content['application/json']) {\n\t\t\t\t\t\tbody = buildBody(context[method].requestBody.content['application/json'].schema.properties);\n\t\t\t\t\t} else if (context[method].hasOwnProperty('requestBody') && context[method].requestBody.content['multipart/form-data']) {\n\t\t\t\t\t\ttype = 'form';\n\t\t\t\t\t}\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tif (type === 'json') {\n\t\t\t\t\t\t\tresponse = await request(url, {\n\t\t\t\t\t\t\t\tmethod: method,\n\t\t\t\t\t\t\t\tjar: !unauthenticatedRoutes.includes(path) ? jar : undefined,\n\t\t\t\t\t\t\t\tjson: true,\n\t\t\t\t\t\t\t\tfollowRedirect: false, // all responses are significant (e.g. 302)\n\t\t\t\t\t\t\t\tsimple: false, // don't throw on non-200 (e.g. 302)\n\t\t\t\t\t\t\t\tresolveWithFullResponse: true, // send full request back (to check statusCode)\n\t\t\t\t\t\t\t\theaders: headers,\n\t\t\t\t\t\t\t\tqs: qs,\n\t\t\t\t\t\t\t\tbody: body,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} else if (type === 'form') {\n\t\t\t\t\t\t\tresponse = await new Promise((resolve, reject) => {\n\t\t\t\t\t\t\t\thelpers.uploadFile(url, pathLib.join(__dirname, './files/test.png'), {}, jar, csrfToken, (err, res) => {\n\t\t\t\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\t\t\t\treturn reject(err);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tresolve(res);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tassert(!e, `${method.toUpperCase()} ${path} errored with: ${e.message}`);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tit('response status code should match one of the schema defined responses', () => {\n\t\t\t\t\t// HACK: allow HTTP 418 I am a teapot, for now   \ud83d\udc47\n\t\t\t\t\tassert(context[method].responses.hasOwnProperty('418') || Object.keys(context[method].responses).includes(String(response.statusCode)), `${method.toUpperCase()} ${path} sent back unexpected HTTP status code: ${response.statusCode}`);\n\t\t\t\t});\n\n\t\t\t\t// Recursively iterate through schema properties, comparing type\n\t\t\t\tit('response body should match schema definition', () => {\n\t\t\t\t\tconst http302 = context[method].responses['302'];\n\t\t\t\t\tif (http302 && response.statusCode === 302) {\n\t\t\t\t\t\t// Compare headers instead\n\t\t\t\t\t\tconst expectedHeaders = Object.keys(http302.headers).reduce((memo, name) => {\n\t\t\t\t\t\t\tconst value = http302.headers[name].schema.example;\n\t\t\t\t\t\t\tmemo[name] = value.startsWith(nconf.get('relative_path')) ? value : nconf.get('relative_path') + value;\n\t\t\t\t\t\t\treturn memo;\n\t\t\t\t\t\t}, {});\n\n\t\t\t\t\t\tfor (const header of Object.keys(expectedHeaders)) {\n\t\t\t\t\t\t\tassert(response.headers[header.toLowerCase()]);\n\t\t\t\t\t\t\tassert.strictEqual(response.headers[header.toLowerCase()], expectedHeaders[header]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst http200 = context[method].responses['200'];\n\t\t\t\t\tif (!http200) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tassert.strictEqual(response.statusCode, 200, `HTTP 200 expected (path: ${method} ${path}`);\n\n\t\t\t\t\tconst hasJSON = http200.content && http200.content['application/json'];\n\t\t\t\t\tif (hasJSON) {\n\t\t\t\t\t\tschema = context[method].responses['200'].content['application/json'].schema;\n\t\t\t\t\t\tcompare(schema, response.body, method.toUpperCase(), path, 'root');\n\t\t\t\t\t}\n\n\t\t\t\t\t// TODO someday: text/csv, binary file type checking?\n\t\t\t\t});\n\n\t\t\t\tit('should successfully re-login if needed', async () => {\n\t\t\t\t\tconst reloginPaths = ['PUT /users/{uid}/password', 'DELETE /users/{uid}/sessions/{uuid}'];\n\t\t\t\t\tif (reloginPaths.includes(`${method.toUpperCase()} ${path}`)) {\n\t\t\t\t\t\t({ jar } = await helpers.loginUser('admin', '123456'));\n\t\t\t\t\t\tconst sessionUUIDs = await db.getObject('uid:1:sessionUUID:sessionId');\n\t\t\t\t\t\tmocks.delete['/users/{uid}/sessions/{uuid}'][1].example = Object.keys(sessionUUIDs).pop();\n\n\t\t\t\t\t\t// Retrieve CSRF token using cookie, to test Write API\n\t\t\t\t\t\tconst config = await request({\n\t\t\t\t\t\t\turl: `${nconf.get('url')}/api/config`,\n\t\t\t\t\t\t\tjson: true,\n\t\t\t\t\t\t\tjar: jar,\n\t\t\t\t\t\t});\n\t\t\t\t\t\tcsrfToken = config.csrf_token;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tit('should back out of a registration interstitial if needed', async () => {\n\t\t\t\t\tconst affectedPaths = ['GET /api/user/{userslug}/edit/email'];\n\t\t\t\t\tif (affectedPaths.includes(`${method.toUpperCase()} ${path}`)) {\n\t\t\t\t\t\tawait request({\n\t\t\t\t\t\t\turi: `${nconf.get('url')}/register/abort?_csrf=${csrfToken}`,\n\t\t\t\t\t\t\tmethod: 'POST',\n\t\t\t\t\t\t\tjar,\n\t\t\t\t\t\t\tsimple: false,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t}\n\n\tfunction buildBody(schema) {\n\t\treturn Object.keys(schema).reduce((memo, cur) => {\n\t\t\tmemo[cur] = schema[cur].example;\n\t\t\treturn memo;\n\t\t}, {});\n\t}\n\n\tfunction compare(schema, response, method, path, context) {\n\t\tlet required = [];\n\t\tconst additionalProperties = schema.hasOwnProperty('additionalProperties');\n\n\t\tfunction flattenAllOf(obj) {\n\t\t\treturn obj.reduce((memo, obj) => {\n\t\t\t\tif (obj.allOf) {\n\t\t\t\t\tobj = { properties: flattenAllOf(obj.allOf) };\n\t\t\t\t} else {\n\t\t\t\t\ttry {\n\t\t\t\t\t\trequired = required.concat(obj.required ? obj.required : Object.keys(obj.properties));\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tassert.fail(`Syntax error re: allOf, perhaps you allOf'd an array? (path: ${method} ${path}, context: ${context})`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn { ...memo, ...obj.properties };\n\t\t\t}, {});\n\t\t}\n\n\t\tif (schema.allOf) {\n\t\t\tschema = flattenAllOf(schema.allOf);\n\t\t} else if (schema.properties) {\n\t\t\trequired = schema.required || Object.keys(schema.properties);\n\t\t\tschema = schema.properties;\n\t\t} else {\n\t\t\t// If schema contains no properties, check passes\n\t\t\treturn;\n\t\t}\n\n\t\t// Compare the schema to the response\n\t\trequired.forEach((prop) => {\n\t\t\tif (schema.hasOwnProperty(prop)) {\n\t\t\t\tassert(response.hasOwnProperty(prop), `\"${prop}\" is a required property (path: ${method} ${path}, context: ${context})`);\n\n\t\t\t\t// Don't proceed with type-check if the value could possibly be unset (nullable: true, in spec)\n\t\t\t\tif (response[prop] === null && schema[prop].nullable === true) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Therefore, if the value is actually null, that's a problem (nullable is probably missing)\n\t\t\t\tassert(response[prop] !== null, `\"${prop}\" was null, but schema does not specify it to be a nullable property (path: ${method} ${path}, context: ${context})`);\n\n\t\t\t\tswitch (schema[prop].type) {\n\t\t\t\t\tcase 'string':\n\t\t\t\t\t\tassert.strictEqual(typeof response[prop], 'string', `\"${prop}\" was expected to be a string, but was ${typeof response[prop]} instead (path: ${method} ${path}, context: ${context})`);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'boolean':\n\t\t\t\t\t\tassert.strictEqual(typeof response[prop], 'boolean', `\"${prop}\" was expected to be a boolean, but was ${typeof response[prop]} instead (path: ${method} ${path}, context: ${context})`);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'object':\n\t\t\t\t\t\tassert.strictEqual(typeof response[prop], 'object', `\"${prop}\" was expected to be an object, but was ${typeof response[prop]} instead (path: ${method} ${path}, context: ${context})`);\n\t\t\t\t\t\tcompare(schema[prop], response[prop], method, path, context ? [context, prop].join('.') : prop);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'array':\n\t\t\t\t\t\tassert.strictEqual(Array.isArray(response[prop]), true, `\"${prop}\" was expected to be an array, but was ${typeof response[prop]} instead (path: ${method} ${path}, context: ${context})`);\n\n\t\t\t\t\t\tif (schema[prop].items) {\n\t\t\t\t\t\t\t// Ensure the array items have a schema defined\n\t\t\t\t\t\t\tassert(schema[prop].items.type || schema[prop].items.allOf, `\"${prop}\" is defined to be an array, but its items have no schema defined (path: ${method} ${path}, context: ${context})`);\n\n\t\t\t\t\t\t\t// Compare types\n\t\t\t\t\t\t\tif (schema[prop].items.type === 'object' || Array.isArray(schema[prop].items.allOf)) {\n\t\t\t\t\t\t\t\tresponse[prop].forEach((res) => {\n\t\t\t\t\t\t\t\t\tcompare(schema[prop].items, res, method, path, context ? [context, prop].join('.') : prop);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t} else if (response[prop].length) { // for now\n\t\t\t\t\t\t\t\tresponse[prop].forEach((item) => {\n\t\t\t\t\t\t\t\t\tassert.strictEqual(typeof item, schema[prop].items.type, `\"${prop}\" should have ${schema[prop].items.type} items, but found ${typeof items} instead (path: ${method} ${path}, context: ${context})`);\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// Compare the response to the schema\n\t\tObject.keys(response).forEach((prop) => {\n\t\t\tif (additionalProperties) { // All bets are off\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tassert(schema[prop], `\"${prop}\" was found in response, but is not defined in schema (path: ${method} ${path}, context: ${context})`);\n\t\t});\n\t}\n});\n", "'use strict';\n\nconst async = require('async');\nconst assert = require('assert');\nconst nconf = require('nconf');\nconst request = require('request');\nconst requestAsync = require('request-promise-native');\nconst fs = require('fs');\nconst path = require('path');\n\nconst db = require('./mocks/databasemock');\nconst categories = require('../src/categories');\nconst topics = require('../src/topics');\nconst posts = require('../src/posts');\nconst user = require('../src/user');\nconst groups = require('../src/groups');\nconst meta = require('../src/meta');\nconst translator = require('../src/translator');\nconst privileges = require('../src/privileges');\nconst plugins = require('../src/plugins');\nconst utils = require('../src/utils');\nconst helpers = require('./helpers');\n\ndescribe('Controllers', () => {\n\tlet tid;\n\tlet cid;\n\tlet pid;\n\tlet fooUid;\n\tlet adminUid;\n\tlet category;\n\n\tbefore(async () => {\n\t\tcategory = await categories.create({\n\t\t\tname: 'Test Category',\n\t\t\tdescription: 'Test category created by testing script',\n\t\t});\n\t\tcid = category.cid;\n\n\t\tfooUid = await user.create({ username: 'foo', password: 'barbar', gdpr_consent: true });\n\t\tawait user.setUserField(fooUid, 'email', 'foo@test.com');\n\t\tawait user.email.confirmByUid(fooUid);\n\n\t\tadminUid = await user.create({ username: 'admin', password: 'barbar', gdpr_consent: true });\n\t\tawait groups.join('administrators', adminUid);\n\n\t\tconst navigation = require('../src/navigation/admin');\n\t\tconst data = require('../install/data/navigation.json');\n\n\t\tawait navigation.save(data);\n\n\t\tconst result = await topics.post({ uid: fooUid, title: 'test topic title', content: 'test topic content', cid: cid });\n\t\ttid = result.topicData.tid;\n\t\tpid = result.postData.pid;\n\t});\n\n\tit('should load /config with csrf_token', (done) => {\n\t\trequest({\n\t\t\turl: `${nconf.get('url')}/api/config`,\n\t\t\tjson: true,\n\t\t}, (err, response, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(response.statusCode, 200);\n\t\t\tassert(body.csrf_token);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load /config with no csrf_token as spider', (done) => {\n\t\trequest({\n\t\t\turl: `${nconf.get('url')}/api/config`,\n\t\t\tjson: true,\n\t\t\theaders: {\n\t\t\t\t'user-agent': 'yandex',\n\t\t\t},\n\t\t}, (err, response, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(response.statusCode, 200);\n\t\t\tassert.strictEqual(body.csrf_token, false);\n\t\t\tassert.strictEqual(body.uid, -1);\n\t\t\tassert.strictEqual(body.loggedIn, false);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tdescribe('homepage', () => {\n\t\tfunction hookMethod(hookData) {\n\t\t\tassert(hookData.req);\n\t\t\tassert(hookData.res);\n\t\t\tassert(hookData.next);\n\n\t\t\thookData.res.render('mycustompage', {\n\t\t\t\tworks: true,\n\t\t\t});\n\t\t}\n\t\tconst message = utils.generateUUID();\n\t\tconst name = 'mycustompage.tpl';\n\t\tconst tplPath = path.join(nconf.get('views_dir'), name);\n\n\t\tbefore(async () => {\n\t\t\tplugins.hooks.register('myTestPlugin', {\n\t\t\t\thook: 'action:homepage.get:mycustompage',\n\t\t\t\tmethod: hookMethod,\n\t\t\t});\n\n\t\t\tfs.writeFileSync(tplPath, message);\n\t\t\tawait meta.templates.compileTemplate(name, message);\n\t\t});\n\n\t\tit('should load default', (done) => {\n\t\t\trequest(nconf.get('url'), (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load unread', (done) => {\n\t\t\tmeta.configs.set('homePageRoute', 'unread', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\trequest(nconf.get('url'), (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert(body);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should load recent', (done) => {\n\t\t\tmeta.configs.set('homePageRoute', 'recent', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\trequest(nconf.get('url'), (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert(body);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should load top', (done) => {\n\t\t\tmeta.configs.set('homePageRoute', 'top', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\trequest(nconf.get('url'), (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert(body);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should load popular', (done) => {\n\t\t\tmeta.configs.set('homePageRoute', 'popular', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\trequest(nconf.get('url'), (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert(body);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should load category', (done) => {\n\t\t\tmeta.configs.set('homePageRoute', 'category/1/test-category', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\trequest(nconf.get('url'), (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert(body);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should not load breadcrumbs on home page route', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tassert(!body.breadcrumbs);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should redirect to custom', (done) => {\n\t\t\tmeta.configs.set('homePageRoute', 'groups', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\trequest(nconf.get('url'), (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert(body);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should 404 if custom does not exist', (done) => {\n\t\t\tmeta.configs.set('homePageRoute', 'this-route-does-not-exist', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\trequest(nconf.get('url'), (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\t\tassert(body);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('api should work with hook', (done) => {\n\t\t\tmeta.configs.set('homePageRoute', 'mycustompage', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\trequest(`${nconf.get('url')}/api`, { json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert.equal(body.works, true);\n\t\t\t\t\tassert.equal(body.template.mycustompage, true);\n\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should render with hook', (done) => {\n\t\t\tmeta.configs.set('homePageRoute', 'mycustompage', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\trequest(nconf.get('url'), (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert.ok(body);\n\t\t\t\t\tassert.ok(body.indexOf('<main id=\"panel\"'));\n\t\t\t\t\tassert.ok(body.includes(message));\n\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tafter(() => {\n\t\t\tplugins.hooks.unregister('myTestPlugin', 'action:homepage.get:custom', hookMethod);\n\t\t\tfs.unlinkSync(tplPath);\n\t\t\tfs.unlinkSync(tplPath.replace(/\\.tpl$/, '.js'));\n\t\t});\n\t});\n\n\tit('should load /reset without code', (done) => {\n\t\trequest(`${nconf.get('url')}/reset`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load /reset with invalid code', (done) => {\n\t\trequest(`${nconf.get('url')}/reset/123123`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load /login', (done) => {\n\t\trequest(`${nconf.get('url')}/login`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load /register', (done) => {\n\t\trequest(`${nconf.get('url')}/register`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load /register/complete', (done) => {\n\t\tconst data = {\n\t\t\tusername: 'interstitial',\n\t\t\tpassword: '123456',\n\t\t\t'password-confirm': '123456',\n\t\t\temail: 'test@me.com',\n\t\t};\n\n\t\tconst jar = request.jar();\n\t\trequest({\n\t\t\turl: `${nconf.get('url')}/api/config`,\n\t\t\tjson: true,\n\t\t\tjar: jar,\n\t\t}, (err, response, body) => {\n\t\t\tassert.ifError(err);\n\n\t\t\trequest.post(`${nconf.get('url')}/register`, {\n\t\t\t\tform: data,\n\t\t\t\tjson: true,\n\t\t\t\tjar: jar,\n\t\t\t\theaders: {\n\t\t\t\t\t'x-csrf-token': body.csrf_token,\n\t\t\t\t},\n\t\t\t}, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert.strictEqual(body.next, `${nconf.get('relative_path')}/register/complete`);\n\t\t\t\trequest(`${nconf.get('url')}/api/register/complete`, {\n\t\t\t\t\tjar: jar,\n\t\t\t\t\tjson: true,\n\t\t\t\t}, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert(body.sections);\n\t\t\t\t\tassert(body.errors);\n\t\t\t\t\tassert(body.title);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('registration interstitials', () => {\n\t\tdescribe('email update', () => {\n\t\t\tlet jar;\n\t\t\tlet token;\n\t\t\tconst dummyEmailerHook = async (data) => {};\n\n\t\t\tbefore(async () => {\n\t\t\t\t// Attach an emailer hook so related requests do not error\n\t\t\t\tplugins.hooks.register('emailer-test', {\n\t\t\t\t\thook: 'filter:email.send',\n\t\t\t\t\tmethod: dummyEmailerHook,\n\t\t\t\t});\n\n\t\t\t\tjar = await helpers.registerUser({\n\t\t\t\t\tusername: utils.generateUUID().slice(0, 10),\n\t\t\t\t\tpassword: utils.generateUUID(),\n\t\t\t\t});\n\t\t\t\ttoken = await helpers.getCsrfToken(jar);\n\n\t\t\t\tmeta.config.requireEmailAddress = 1;\n\t\t\t});\n\n\t\t\tafter(() => {\n\t\t\t\tmeta.config.requireEmailAddress = 0;\n\t\t\t\tplugins.hooks.unregister('emailer-test', 'filter:email.send');\n\t\t\t});\n\n\t\t\tit('email interstitial should still apply if empty email entered and requireEmailAddress is enabled', async () => {\n\t\t\t\tlet res = await requestAsync(`${nconf.get('url')}/register/complete`, {\n\t\t\t\t\tmethod: 'post',\n\t\t\t\t\tjar,\n\t\t\t\t\tjson: true,\n\t\t\t\t\tfollowRedirect: false,\n\t\t\t\t\tsimple: false,\n\t\t\t\t\tresolveWithFullResponse: true,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'x-csrf-token': token,\n\t\t\t\t\t},\n\t\t\t\t\tform: {\n\t\t\t\t\t\temail: '',\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\tassert.strictEqual(res.headers.location, `${nconf.get('relative_path')}/register/complete`);\n\n\t\t\t\tres = await requestAsync(`${nconf.get('url')}/api/register/complete`, {\n\t\t\t\t\tjar,\n\t\t\t\t\tjson: true,\n\t\t\t\t\tresolveWithFullResponse: true,\n\t\t\t\t});\n\t\t\t\tassert.strictEqual(res.statusCode, 200);\n\t\t\t\tassert(res.body.errors.length);\n\t\t\t\tassert(res.body.errors.includes('[[error:invalid-email]]'));\n\t\t\t});\n\n\t\t\tit('gdpr interstitial should still apply if email requirement is disabled', async () => {\n\t\t\t\tmeta.config.requireEmailAddress = 0;\n\n\t\t\t\tconst res = await requestAsync(`${nconf.get('url')}/api/register/complete`, {\n\t\t\t\t\tjar,\n\t\t\t\t\tjson: true,\n\t\t\t\t\tresolveWithFullResponse: true,\n\t\t\t\t});\n\n\t\t\t\tassert(!res.body.errors.includes('[[error:invalid-email]]'));\n\t\t\t\tassert(!res.body.errors.includes('[[error:gdpr_consent_denied]]'));\n\t\t\t});\n\n\t\t\tit('should error if userData is falsy', async () => {\n\t\t\t\ttry {\n\t\t\t\t\tawait user.interstitials.email({ userData: null });\n\t\t\t\t\tassert(false);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tassert.strictEqual(err.message, '[[error:invalid-data]]');\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tit('should throw error if email is not valid', async () => {\n\t\t\t\tconst uid = await user.create({ username: 'interstiuser1' });\n\t\t\t\ttry {\n\t\t\t\t\tconst result = await user.interstitials.email({\n\t\t\t\t\t\tuserData: { uid: uid, updateEmail: true },\n\t\t\t\t\t\treq: { uid: uid },\n\t\t\t\t\t\tinterstitials: [],\n\t\t\t\t\t});\n\t\t\t\t\tassert.strictEqual(result.interstitials[0].template, 'partials/email_update');\n\t\t\t\t\tawait result.interstitials[0].callback({ uid }, {\n\t\t\t\t\t\temail: 'invalidEmail',\n\t\t\t\t\t});\n\t\t\t\t\tassert(false);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tassert.strictEqual(err.message, '[[error:invalid-email]]');\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tit('should set req.session.emailChanged to 1', async () => {\n\t\t\t\tconst uid = await user.create({ username: 'interstiuser2' });\n\t\t\t\tconst result = await user.interstitials.email({\n\t\t\t\t\tuserData: { uid: uid, updateEmail: true },\n\t\t\t\t\treq: { uid: uid, session: {} },\n\t\t\t\t\tinterstitials: [],\n\t\t\t\t});\n\n\t\t\t\tawait result.interstitials[0].callback({ uid: uid }, {\n\t\t\t\t\temail: 'interstiuser2@nodebb.org',\n\t\t\t\t});\n\t\t\t\tassert.strictEqual(result.req.session.emailChanged, 1);\n\t\t\t});\n\n\t\t\tit('should set email if admin is changing it', async () => {\n\t\t\t\tconst uid = await user.create({ username: 'interstiuser3' });\n\t\t\t\tconst result = await user.interstitials.email({\n\t\t\t\t\tuserData: { uid: uid, updateEmail: true },\n\t\t\t\t\treq: { uid: adminUid },\n\t\t\t\t\tinterstitials: [],\n\t\t\t\t});\n\n\t\t\t\tawait result.interstitials[0].callback({ uid: uid }, {\n\t\t\t\t\temail: 'interstiuser3@nodebb.org',\n\t\t\t\t});\n\t\t\t\tconst userData = await user.getUserData(uid);\n\t\t\t\tassert.strictEqual(userData.email, 'interstiuser3@nodebb.org');\n\t\t\t\tassert.strictEqual(userData['email:confirmed'], 1);\n\t\t\t});\n\n\t\t\tit('should throw error if user tries to edit other users email', async () => {\n\t\t\t\tconst uid = await user.create({ username: 'interstiuser4' });\n\t\t\t\ttry {\n\t\t\t\t\tconst result = await user.interstitials.email({\n\t\t\t\t\t\tuserData: { uid: uid, updateEmail: true },\n\t\t\t\t\t\treq: { uid: 1000 },\n\t\t\t\t\t\tinterstitials: [],\n\t\t\t\t\t});\n\n\t\t\t\t\tawait result.interstitials[0].callback({ uid: uid }, {\n\t\t\t\t\t\temail: 'derp@derp.com',\n\t\t\t\t\t});\n\t\t\t\t\tassert(false);\n\t\t\t\t} catch (err) {\n\t\t\t\t\tassert.strictEqual(err.message, '[[error:no-privileges]]');\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tit('should remove current email', async () => {\n\t\t\t\tconst uid = await user.create({ username: 'interstiuser5' });\n\t\t\t\tawait user.setUserField(uid, 'email', 'interstiuser5@nodebb.org');\n\t\t\t\tawait user.email.confirmByUid(uid);\n\n\t\t\t\tconst result = await user.interstitials.email({\n\t\t\t\t\tuserData: { uid: uid, updateEmail: true },\n\t\t\t\t\treq: { uid: uid, session: { id: 0 } },\n\t\t\t\t\tinterstitials: [],\n\t\t\t\t});\n\n\t\t\t\tawait result.interstitials[0].callback({ uid: uid }, {\n\t\t\t\t\temail: '',\n\t\t\t\t});\n\t\t\t\tconst userData = await user.getUserData(uid);\n\t\t\t\tassert.strictEqual(userData.email, '');\n\t\t\t\tassert.strictEqual(userData['email:confirmed'], 0);\n\t\t\t});\n\n\t\t\tit('should require a password (if one is set) for email change', async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst [username, password] = [utils.generateUUID().slice(0, 10), utils.generateUUID()];\n\t\t\t\t\tconst uid = await user.create({ username, password });\n\t\t\t\t\tawait user.setUserField(uid, 'email', `${username}@nodebb.org`);\n\t\t\t\t\tawait user.email.confirmByUid(uid);\n\n\t\t\t\t\tconst result = await user.interstitials.email({\n\t\t\t\t\t\tuserData: { uid: uid, updateEmail: true },\n\t\t\t\t\t\treq: { uid: uid, session: { id: 0 } },\n\t\t\t\t\t\tinterstitials: [],\n\t\t\t\t\t});\n\n\t\t\t\t\tawait result.interstitials[0].callback({ uid: uid }, {\n\t\t\t\t\t\temail: `${username}@nodebb.com`,\n\t\t\t\t\t});\n\t\t\t\t} catch (err) {\n\t\t\t\t\tassert.strictEqual(err.message, '[[error:invalid-password]]');\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tit('should require a password (if one is set) for email clearing', async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst [username, password] = [utils.generateUUID().slice(0, 10), utils.generateUUID()];\n\t\t\t\t\tconst uid = await user.create({ username, password });\n\t\t\t\t\tawait user.setUserField(uid, 'email', `${username}@nodebb.org`);\n\t\t\t\t\tawait user.email.confirmByUid(uid);\n\n\t\t\t\t\tconst result = await user.interstitials.email({\n\t\t\t\t\t\tuserData: { uid: uid, updateEmail: true },\n\t\t\t\t\t\treq: { uid: uid, session: { id: 0 } },\n\t\t\t\t\t\tinterstitials: [],\n\t\t\t\t\t});\n\n\t\t\t\t\tawait result.interstitials[0].callback({ uid: uid }, {\n\t\t\t\t\t\temail: '',\n\t\t\t\t\t});\n\t\t\t\t} catch (err) {\n\t\t\t\t\tassert.strictEqual(err.message, '[[error:invalid-password]]');\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tit('should successfully issue validation request if the correct password is passed in', async () => {\n\t\t\t\tconst [username, password] = [utils.generateUUID().slice(0, 10), utils.generateUUID()];\n\t\t\t\tconst uid = await user.create({ username, password });\n\t\t\t\tawait user.setUserField(uid, 'email', `${username}@nodebb.org`);\n\t\t\t\tawait user.email.confirmByUid(uid);\n\n\t\t\t\tconst result = await user.interstitials.email({\n\t\t\t\t\tuserData: { uid: uid, updateEmail: true },\n\t\t\t\t\treq: { uid: uid, session: { id: 0 } },\n\t\t\t\t\tinterstitials: [],\n\t\t\t\t});\n\n\t\t\t\tawait result.interstitials[0].callback({ uid }, {\n\t\t\t\t\temail: `${username}@nodebb.com`,\n\t\t\t\t\tpassword,\n\t\t\t\t});\n\n\t\t\t\tconst pending = await user.email.isValidationPending(uid, `${username}@nodebb.com`);\n\t\t\t\tassert.strictEqual(pending, true);\n\t\t\t\tawait user.setUserField(uid, 'email', `${username}@nodebb.com`);\n\t\t\t\tawait user.email.confirmByUid(uid);\n\t\t\t\tconst userData = await user.getUserData(uid);\n\t\t\t\tassert.strictEqual(userData.email, `${username}@nodebb.com`);\n\t\t\t\tassert.strictEqual(userData['email:confirmed'], 1);\n\t\t\t});\n\t\t});\n\n\t\tdescribe('gdpr', () => {\n\t\t\tlet jar;\n\t\t\tlet token;\n\n\t\t\tbefore(async () => {\n\t\t\t\tjar = await helpers.registerUser({\n\t\t\t\t\tusername: utils.generateUUID().slice(0, 10),\n\t\t\t\t\tpassword: utils.generateUUID(),\n\t\t\t\t});\n\t\t\t\ttoken = await helpers.getCsrfToken(jar);\n\t\t\t});\n\n\t\t\tit('registration should succeed once gdpr prompts are agreed to', async () => {\n\t\t\t\tconst res = await requestAsync(`${nconf.get('url')}/register/complete`, {\n\t\t\t\t\tmethod: 'post',\n\t\t\t\t\tjar,\n\t\t\t\t\tjson: true,\n\t\t\t\t\tfollowRedirect: false,\n\t\t\t\t\tsimple: false,\n\t\t\t\t\tresolveWithFullResponse: true,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'x-csrf-token': token,\n\t\t\t\t\t},\n\t\t\t\t\tform: {\n\t\t\t\t\t\tgdpr_agree_data: 'on',\n\t\t\t\t\t\tgdpr_agree_email: 'on',\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\tassert.strictEqual(res.statusCode, 302);\n\t\t\t\tassert.strictEqual(res.headers.location, `${nconf.get('relative_path')}/`);\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should load /robots.txt', (done) => {\n\t\trequest(`${nconf.get('url')}/robots.txt`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load /manifest.webmanifest', (done) => {\n\t\trequest(`${nconf.get('url')}/manifest.webmanifest`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load /outgoing?url=<url>', (done) => {\n\t\trequest(`${nconf.get('url')}/outgoing?url=http://youtube.com`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should 404 on /outgoing with no url', (done) => {\n\t\trequest(`${nconf.get('url')}/outgoing`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 404);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should 404 on /outgoing with javascript: protocol', (done) => {\n\t\trequest(`${nconf.get('url')}/outgoing?url=javascript:alert(1);`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 404);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should 404 on /outgoing with invalid url', (done) => {\n\t\trequest(`${nconf.get('url')}/outgoing?url=derp`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 404);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load /tos', (done) => {\n\t\tmeta.config.termsOfUse = 'please accept our tos';\n\t\trequest(`${nconf.get('url')}/tos`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\n\tit('should load 404 if meta.config.termsOfUse is empty', (done) => {\n\t\tmeta.config.termsOfUse = '';\n\t\trequest(`${nconf.get('url')}/tos`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 404);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load /sping', (done) => {\n\t\trequest(`${nconf.get('url')}/sping`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert.equal(body, 'healthy');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load /ping', (done) => {\n\t\trequest(`${nconf.get('url')}/ping`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert.equal(body, '200');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should handle 404', (done) => {\n\t\trequest(`${nconf.get('url')}/arouteinthevoid`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 404);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load topic rss feed', (done) => {\n\t\trequest(`${nconf.get('url')}/topic/${tid}.rss`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load category rss feed', (done) => {\n\t\trequest(`${nconf.get('url')}/category/${cid}.rss`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load topics rss feed', (done) => {\n\t\trequest(`${nconf.get('url')}/topics.rss`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load recent rss feed', (done) => {\n\t\trequest(`${nconf.get('url')}/recent.rss`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load top rss feed', (done) => {\n\t\trequest(`${nconf.get('url')}/top.rss`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load popular rss feed', (done) => {\n\t\trequest(`${nconf.get('url')}/popular.rss`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load popular rss feed with term', (done) => {\n\t\trequest(`${nconf.get('url')}/popular/day.rss`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load recent posts rss feed', (done) => {\n\t\trequest(`${nconf.get('url')}/recentposts.rss`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load category recent posts rss feed', (done) => {\n\t\trequest(`${nconf.get('url')}/category/${cid}/recentposts.rss`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load user topics rss feed', (done) => {\n\t\trequest(`${nconf.get('url')}/user/foo/topics.rss`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load tag rss feed', (done) => {\n\t\trequest(`${nconf.get('url')}/tags/nodebb.rss`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load client.css', (done) => {\n\t\trequest(`${nconf.get('url')}/assets/client.css`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load admin.css', (done) => {\n\t\trequest(`${nconf.get('url')}/assets/admin.css`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load sitemap.xml', (done) => {\n\t\trequest(`${nconf.get('url')}/sitemap.xml`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load sitemap/pages.xml', (done) => {\n\t\trequest(`${nconf.get('url')}/sitemap/pages.xml`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load sitemap/categories.xml', (done) => {\n\t\trequest(`${nconf.get('url')}/sitemap/categories.xml`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load sitemap/topics/1.xml', (done) => {\n\t\trequest(`${nconf.get('url')}/sitemap/topics.1.xml`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load robots.txt', (done) => {\n\t\trequest(`${nconf.get('url')}/robots.txt`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load theme screenshot', (done) => {\n\t\trequest(`${nconf.get('url')}/css/previews/nodebb-theme-persona`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load users page', (done) => {\n\t\trequest(`${nconf.get('url')}/users`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load users page', (done) => {\n\t\trequest(`${nconf.get('url')}/users?section=online`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should error if guests do not have search privilege', (done) => {\n\t\trequest(`${nconf.get('url')}/api/users?query=bar&section=sort-posts`, { json: true }, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 500);\n\t\t\tassert(body);\n\t\t\tassert.equal(body.error, '[[error:no-privileges]]');\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load users search page', (done) => {\n\t\tprivileges.global.give(['groups:search:users'], 'guests', (err) => {\n\t\t\tassert.ifError(err);\n\t\t\trequest(`${nconf.get('url')}/users?query=bar&section=sort-posts`, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tprivileges.global.rescind(['groups:search:users'], 'guests', done);\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should load groups page', (done) => {\n\t\trequest(`${nconf.get('url')}/groups`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should load group details page', (done) => {\n\t\tgroups.create({\n\t\t\tname: 'group-details',\n\t\t\tdescription: 'Foobar!',\n\t\t\thidden: 0,\n\t\t}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tgroups.join('group-details', fooUid, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\ttopics.post({\n\t\t\t\t\tuid: fooUid,\n\t\t\t\t\ttitle: 'topic title',\n\t\t\t\t\tcontent: 'test topic content',\n\t\t\t\t\tcid: cid,\n\t\t\t\t}, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\trequest(`${nconf.get('url')}/api/groups/group-details`, { json: true }, (err, res, body) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\t\tassert(body);\n\t\t\t\t\t\tassert.equal(body.posts[0].content, 'test topic content');\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should load group members page', (done) => {\n\t\trequest(`${nconf.get('url')}/groups/group-details/members`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should 404 when trying to load group members of hidden group', (done) => {\n\t\tconst groups = require('../src/groups');\n\t\tgroups.create({\n\t\t\tname: 'hidden-group',\n\t\t\tdescription: 'Foobar!',\n\t\t\thidden: 1,\n\t\t}, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\trequest(`${nconf.get('url')}/groups/hidden-group/members`, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should get recent posts', (done) => {\n\t\trequest(`${nconf.get('url')}/api/recent/posts/month`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get post data', (done) => {\n\t\trequest(`${nconf.get('url')}/api/v3/posts/${pid}`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get topic data', (done) => {\n\t\trequest(`${nconf.get('url')}/api/v3/topics/${tid}`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should get category data', (done) => {\n\t\trequest(`${nconf.get('url')}/api/v3/categories/${cid}`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\n\tdescribe('revoke session', () => {\n\t\tlet uid;\n\t\tlet jar;\n\t\tlet csrf_token;\n\n\t\tbefore(async () => {\n\t\t\tuid = await user.create({ username: 'revokeme', password: 'barbar' });\n\t\t\tconst login = await helpers.loginUser('revokeme', 'barbar');\n\t\t\tjar = login.jar;\n\t\t\tcsrf_token = login.csrf_token;\n\t\t});\n\n\t\tit('should fail to revoke session with missing uuid', (done) => {\n\t\t\trequest.del(`${nconf.get('url')}/api/user/revokeme/session`, {\n\t\t\t\tjar: jar,\n\t\t\t\theaders: {\n\t\t\t\t\t'x-csrf-token': csrf_token,\n\t\t\t\t},\n\t\t\t}, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should fail if user doesn\\'t exist', (done) => {\n\t\t\trequest.del(`${nconf.get('url')}/api/v3/users/doesnotexist/sessions/1112233`, {\n\t\t\t\tjar: jar,\n\t\t\t\theaders: {\n\t\t\t\t\t'x-csrf-token': csrf_token,\n\t\t\t\t},\n\t\t\t}, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(res.statusCode, 404);\n\t\t\t\tconst parsedResponse = JSON.parse(body);\n\t\t\t\tassert.deepStrictEqual(parsedResponse.response, {});\n\t\t\t\tassert.deepStrictEqual(parsedResponse.status, {\n\t\t\t\t\tcode: 'not-found',\n\t\t\t\t\tmessage: 'User does not exist',\n\t\t\t\t});\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should revoke user session', (done) => {\n\t\t\tdb.getSortedSetRange(`uid:${uid}:sessions`, 0, -1, (err, sids) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tconst sid = sids[0];\n\n\t\t\t\tdb.sessionStore.get(sid, (err, sessionObj) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\trequest.del(`${nconf.get('url')}/api/v3/users/${uid}/sessions/${sessionObj.meta.uuid}`, {\n\t\t\t\t\t\tjar: jar,\n\t\t\t\t\t\theaders: {\n\t\t\t\t\t\t\t'x-csrf-token': csrf_token,\n\t\t\t\t\t\t},\n\t\t\t\t\t}, (err, res, body) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.strictEqual(res.statusCode, 200);\n\t\t\t\t\t\tassert.deepStrictEqual(JSON.parse(body), {\n\t\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\t\tcode: 'ok',\n\t\t\t\t\t\t\t\tmessage: 'OK',\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tresponse: {},\n\t\t\t\t\t\t});\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('widgets', () => {\n\t\tconst widgets = require('../src/widgets');\n\n\t\tbefore((done) => {\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\twidgets.reset(next);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\tconst data = {\n\t\t\t\t\t\ttemplate: 'categories.tpl',\n\t\t\t\t\t\tlocation: 'sidebar',\n\t\t\t\t\t\twidgets: [\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\twidget: 'html',\n\t\t\t\t\t\t\t\tdata: {\n\t\t\t\t\t\t\t\t\thtml: 'test',\n\t\t\t\t\t\t\t\t\ttitle: '',\n\t\t\t\t\t\t\t\t\tcontainer: '',\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t],\n\t\t\t\t\t};\n\n\t\t\t\t\twidgets.setArea(data, next);\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should return {} if there are no widgets', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/category/${cid}`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body.widgets);\n\t\t\t\tassert.equal(Object.keys(body.widgets).length, 0);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should render templates', (done) => {\n\t\t\tconst url = `${nconf.get('url')}/api/categories`;\n\t\t\trequest(url, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body.widgets);\n\t\t\t\tassert(body.widgets.sidebar);\n\t\t\t\tassert.equal(body.widgets.sidebar[0].html, 'test');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should reset templates', (done) => {\n\t\t\twidgets.resetTemplates(['categories', 'category'], (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\trequest(`${nconf.get('url')}/api/categories`, { json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert(body.widgets);\n\t\t\t\t\tassert.equal(Object.keys(body.widgets).length, 0);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('tags', () => {\n\t\tlet tid;\n\t\tbefore((done) => {\n\t\t\ttopics.post({\n\t\t\t\tuid: fooUid,\n\t\t\t\ttitle: 'topic title',\n\t\t\t\tcontent: 'test topic content',\n\t\t\t\tcid: cid,\n\t\t\t\ttags: ['nodebb', 'bug', 'test'],\n\t\t\t}, (err, result) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\ttid = result.topicData.tid;\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should render tags page', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/tags`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tassert(Array.isArray(body.tags));\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should render tag page with no topics', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/tags/notag`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tassert(Array.isArray(body.topics));\n\t\t\t\tassert.equal(body.topics.length, 0);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should render tag page with 1 topic', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/tags/nodebb`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tassert(Array.isArray(body.topics));\n\t\t\t\tassert.equal(body.topics.length, 1);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\n\tdescribe('maintenance mode', () => {\n\t\tbefore((done) => {\n\t\t\tmeta.config.maintenanceMode = 1;\n\t\t\tdone();\n\t\t});\n\t\tafter((done) => {\n\t\t\tmeta.config.maintenanceMode = 0;\n\t\t\tdone();\n\t\t});\n\n\t\tit('should return 503 in maintenance mode', (done) => {\n\t\t\trequest(`${nconf.get('url')}/recent`, { json: true }, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 503);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return 503 in maintenance mode', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/recent`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 503);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return 200 in maintenance mode', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/login`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('account pages', () => {\n\t\tlet jar;\n\t\tlet csrf_token;\n\n\t\tbefore(async () => {\n\t\t\t({ jar, csrf_token } = await helpers.loginUser('foo', 'barbar'));\n\t\t});\n\n\t\tit('should redirect to account page with logged in user', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/login`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert.equal(res.headers['x-redirect'], '/user/foo');\n\t\t\t\tassert.equal(body, '/user/foo');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should 404 if uid is not a number', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/uid/test`, { json: true }, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should redirect to userslug', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/uid/${fooUid}`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert.equal(res.headers['x-redirect'], '/user/foo');\n\t\t\t\tassert.equal(body, '/user/foo');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should redirect to userslug and keep query params', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/uid/${fooUid}/topics?foo=bar`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert.equal(res.headers['x-redirect'], '/user/foo/topics?foo=bar');\n\t\t\t\tassert.equal(body, '/user/foo/topics?foo=bar');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should 404 if user does not exist', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/uid/123123`, { json: true }, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tdescribe('/me/*', () => {\n\t\t\tit('should redirect to user profile', (done) => {\n\t\t\t\trequest(`${nconf.get('url')}/me`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert(body.includes('\"template\":{\"name\":\"account/profile\",\"account/profile\":true}'));\n\t\t\t\t\tassert(body.includes('\"username\":\"foo\"'));\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t\tit('api should redirect to /user/[userslug]/bookmarks', (done) => {\n\t\t\t\trequest(`${nconf.get('url')}/api/me/bookmarks`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert.equal(res.headers['x-redirect'], '/user/foo/bookmarks');\n\t\t\t\t\tassert.equal(body, '/user/foo/bookmarks');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t\tit('api should redirect to /user/[userslug]/edit/username', (done) => {\n\t\t\t\trequest(`${nconf.get('url')}/api/me/edit/username`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert.equal(res.headers['x-redirect'], '/user/foo/edit/username');\n\t\t\t\t\tassert.equal(body, '/user/foo/edit/username');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t\tit('should redirect to login if user is not logged in', (done) => {\n\t\t\t\trequest(`${nconf.get('url')}/me/bookmarks`, { json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert(body.includes('Login to your account'), body.slice(0, 500));\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should 401 if user is not logged in', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/admin`, { json: true }, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 401);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should 403 if user is not admin', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/admin`, { jar: jar, json: true }, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 403);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/posts', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/posts`, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should 401 if not logged in', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/bookmarks`, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 401);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/bookmarks', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/bookmarks`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/upvoted', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/upvoted`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/downvoted', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/downvoted`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/best', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/best`, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/controversial', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/controversial`, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/watched', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/watched`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/ignored', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/ignored`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/topics', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/topics`, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/blocks', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/blocks`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/consent', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/consent`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/sessions', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/sessions`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/categories', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/categories`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load /user/foo/uploads', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/uploads`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should export users posts', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/export/posts`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should export users uploads', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/export/uploads`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should export users profile', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/export/profile`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load notifications page', (done) => {\n\t\t\tconst notifications = require('../src/notifications');\n\t\t\tconst notifData = {\n\t\t\t\tbodyShort: '[[notifications:user_posted_to, test1, test2]]',\n\t\t\t\tbodyLong: 'some post content',\n\t\t\t\tpid: 1,\n\t\t\t\tpath: `/post/${1}`,\n\t\t\t\tnid: `new_post:tid:${1}:pid:${1}:uid:${fooUid}`,\n\t\t\t\ttid: 1,\n\t\t\t\tfrom: fooUid,\n\t\t\t\tmergeId: `notifications:user_posted_to|${1}`,\n\t\t\t\ttopicTitle: 'topic title',\n\t\t\t};\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\tnotifications.create(notifData, next);\n\t\t\t\t},\n\t\t\t\tfunction (notification, next) {\n\t\t\t\t\tnotifications.push(notification, fooUid, next);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\tsetTimeout(next, 2500);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\trequest(`${nconf.get('url')}/api/notifications`, { jar: jar, json: true }, next);\n\t\t\t\t},\n\t\t\t\tfunction (res, body, next) {\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert(body);\n\t\t\t\t\tconst notif = body.notifications[0];\n\t\t\t\t\tassert.equal(notif.bodyShort, notifData.bodyShort);\n\t\t\t\t\tassert.equal(notif.bodyLong, notifData.bodyLong);\n\t\t\t\t\tassert.equal(notif.pid, notifData.pid);\n\t\t\t\t\tassert.equal(notif.path, nconf.get('relative_path') + notifData.path);\n\t\t\t\t\tassert.equal(notif.nid, notifData.nid);\n\t\t\t\t\tnext();\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should 404 if user does not exist', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/email/doesnotexist`, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load user by uid', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/uid/${fooUid}`, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load user by username', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/username/foo`, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should NOT load user by email (by default)', async () => {\n\t\t\tconst res = await requestAsync(`${nconf.get('url')}/api/user/email/foo@test.com`, {\n\t\t\t\tresolveWithFullResponse: true,\n\t\t\t\tsimple: false,\n\t\t\t});\n\n\t\t\tassert.strictEqual(res.statusCode, 404);\n\t\t});\n\n\t\tit('should load user by email if user has elected to show their email', async () => {\n\t\t\tawait user.setSetting(fooUid, 'showemail', 1);\n\t\t\tconst res = await requestAsync(`${nconf.get('url')}/api/user/email/foo@test.com`, {\n\t\t\t\tresolveWithFullResponse: true,\n\t\t\t});\n\t\t\tassert.strictEqual(res.statusCode, 200);\n\t\t\tassert(res.body);\n\t\t\tawait user.setSetting(fooUid, 'showemail', 0);\n\t\t});\n\n\t\tit('should return 401 if user does not have view:users privilege', (done) => {\n\t\t\tprivileges.global.rescind(['groups:view:users'], 'guests', (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\trequest(`${nconf.get('url')}/api/user/foo`, { json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 401);\n\t\t\t\t\tassert.deepEqual(body, {\n\t\t\t\t\t\tresponse: {},\n\t\t\t\t\t\tstatus: {\n\t\t\t\t\t\t\tcode: 'not-authorised',\n\t\t\t\t\t\t\tmessage: 'A valid login session was not found. Please log in and try again.',\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t\tprivileges.global.give(['groups:view:users'], 'guests', done);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should return false if user can not edit user', (done) => {\n\t\t\tuser.create({ username: 'regularJoe', password: 'barbar' }, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\thelpers.loginUser('regularJoe', 'barbar', (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tconst { jar } = data;\n\t\t\t\t\trequest(`${nconf.get('url')}/api/user/foo/info`, { jar: jar, json: true }, (err, res) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(res.statusCode, 403);\n\t\t\t\t\t\trequest(`${nconf.get('url')}/api/user/foo/edit`, { jar: jar, json: true }, (err, res) => {\n\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\tassert.equal(res.statusCode, 403);\n\t\t\t\t\t\t\tdone();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should load correct user', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/FOO`, { jar: jar, json: true }, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should redirect', (done) => {\n\t\t\trequest(`${nconf.get('url')}/user/FOO`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should 404 if user does not exist', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/doesnotexist`, { jar: jar }, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should not increase profile view if you visit your own profile', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo`, { jar: jar }, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tuser.getUserField(fooUid, 'profileviews', (err, viewcount) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert(viewcount === 0);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t}, 500);\n\t\t\t});\n\t\t});\n\n\t\tit('should not increase profile view if a guest visits a profile', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo`, {}, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tuser.getUserField(fooUid, 'profileviews', (err, viewcount) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert(viewcount === 0);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t}, 500);\n\t\t\t});\n\t\t});\n\n\t\tit('should increase profile view', (done) => {\n\t\t\thelpers.loginUser('regularJoe', 'barbar', (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tconst { jar } = data;\n\t\t\t\trequest(`${nconf.get('url')}/api/user/foo`, { jar: jar }, (err, res) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tuser.getUserField(fooUid, 'profileviews', (err, viewcount) => {\n\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\tassert(viewcount > 0);\n\t\t\t\t\t\t\tdone();\n\t\t\t\t\t\t});\n\t\t\t\t\t}, 500);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should parse about me', (done) => {\n\t\t\tuser.setUserFields(fooUid, { picture: '/path/to/picture', aboutme: 'hi i am a bot' }, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\trequest(`${nconf.get('url')}/api/user/foo`, { json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert.equal(body.aboutme, 'hi i am a bot');\n\t\t\t\t\tassert.equal(body.picture, '/path/to/picture');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should not return reputation if reputation is disabled', (done) => {\n\t\t\tmeta.config['reputation:disabled'] = 1;\n\t\t\trequest(`${nconf.get('url')}/api/user/foo`, { json: true }, (err, res, body) => {\n\t\t\t\tmeta.config['reputation:disabled'] = 0;\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(!body.hasOwnProperty('reputation'));\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should only return posts that are not deleted', (done) => {\n\t\t\tlet topicData;\n\t\t\tlet pidToDelete;\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\ttopics.post({ uid: fooUid, title: 'visible', content: 'some content', cid: cid }, next);\n\t\t\t\t},\n\t\t\t\tfunction (data, next) {\n\t\t\t\t\ttopicData = data.topicData;\n\t\t\t\t\ttopics.reply({ uid: fooUid, content: '1st reply', tid: topicData.tid }, next);\n\t\t\t\t},\n\t\t\t\tfunction (postData, next) {\n\t\t\t\t\tpidToDelete = postData.pid;\n\t\t\t\t\ttopics.reply({ uid: fooUid, content: '2nd reply', tid: topicData.tid }, next);\n\t\t\t\t},\n\t\t\t\tfunction (postData, next) {\n\t\t\t\t\tposts.delete(pidToDelete, fooUid, next);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\trequest(`${nconf.get('url')}/api/user/foo`, { json: true }, (err, res, body) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\t\tconst contents = body.posts.map(p => p.content);\n\t\t\t\t\t\tassert(!contents.includes('1st reply'));\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should return selected group title', (done) => {\n\t\t\tgroups.create({\n\t\t\t\tname: 'selectedGroup',\n\t\t\t}, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tuser.create({ username: 'groupie' }, (err, uid) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tgroups.join('selectedGroup', uid, (err) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\trequest(`${nconf.get('url')}/api/user/groupie`, { json: true }, (err, res, body) => {\n\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\t\t\tassert(Array.isArray(body.selectedGroup));\n\t\t\t\t\t\t\tassert.equal(body.selectedGroup[0].name, 'selectedGroup');\n\t\t\t\t\t\t\tdone();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should 404 if user does not exist', (done) => {\n\t\t\tgroups.join('administrators', fooUid, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\trequest(`${nconf.get('url')}/api/user/doesnotexist/edit`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\t\tgroups.leave('administrators', fooUid, done);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should render edit/password', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/edit/password`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should render edit/email', async () => {\n\t\t\tconst res = await requestAsync(`${nconf.get('url')}/api/user/foo/edit/email`, {\n\t\t\t\tjar,\n\t\t\t\tjson: true,\n\t\t\t\tresolveWithFullResponse: true,\n\t\t\t});\n\n\t\t\tassert.strictEqual(res.statusCode, 200);\n\t\t\tassert.strictEqual(res.body, '/register/complete');\n\n\t\t\tawait requestAsync({\n\t\t\t\turi: `${nconf.get('url')}/register/abort?_csrf=${csrf_token}`,\n\t\t\t\tmethod: 'post',\n\t\t\t\tjar,\n\t\t\t\tsimple: false,\n\t\t\t});\n\t\t});\n\n\t\tit('should render edit/username', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/edit/username`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('account follow page', () => {\n\t\tconst socketUser = require('../src/socket.io/user');\n\t\tconst apiUser = require('../src/api/users');\n\t\tlet uid;\n\t\tbefore(async () => {\n\t\t\tuid = await user.create({ username: 'follower' });\n\t\t\tawait apiUser.follow({ uid: uid }, { uid: fooUid });\n\t\t\tconst isFollowing = await socketUser.isFollowing({ uid: uid }, { uid: fooUid });\n\t\t\tassert(isFollowing);\n\t\t});\n\n\t\tit('should get followers page', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/foo/followers`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert.equal(body.users[0].username, 'follower');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should get following page', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/follower/following`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert.equal(body.users[0].username, 'foo');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return empty after unfollow', async () => {\n\t\t\tawait apiUser.unfollow({ uid: uid }, { uid: fooUid });\n\t\t\tconst { res, body } = await helpers.request('get', `/api/user/foo/followers`, { json: true });\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert.equal(body.users.length, 0);\n\t\t});\n\t});\n\n\tdescribe('post redirect', () => {\n\t\tlet jar;\n\t\tbefore(async () => {\n\t\t\t({ jar } = await helpers.loginUser('foo', 'barbar'));\n\t\t});\n\n\t\tit('should 404 for invalid pid', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/post/fail`, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should 403 if user does not have read privilege', (done) => {\n\t\t\tprivileges.categories.rescind(['groups:topics:read'], category.cid, 'registered-users', (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\trequest(`${nconf.get('url')}/api/post/${pid}`, { jar: jar }, (err, res) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 403);\n\t\t\t\t\tprivileges.categories.give(['groups:topics:read'], category.cid, 'registered-users', done);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should return correct post path', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/post/${pid}`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert.equal(res.headers['x-redirect'], '/topic/1/test-topic-title/1');\n\t\t\t\tassert.equal(body, '/topic/1/test-topic-title/1');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('cookie consent', () => {\n\t\tit('should return relevant data in configs API route', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/config`, (err, res, body) => {\n\t\t\t\tlet parsed;\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\n\t\t\t\ttry {\n\t\t\t\t\tparsed = JSON.parse(body);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tassert.ifError(e);\n\t\t\t\t}\n\n\t\t\t\tassert.ok(parsed.cookies);\n\t\t\t\tassert.equal(translator.escape('[[global:cookies.message]]'), parsed.cookies.message);\n\t\t\t\tassert.equal(translator.escape('[[global:cookies.accept]]'), parsed.cookies.dismiss);\n\t\t\t\tassert.equal(translator.escape('[[global:cookies.learn_more]]'), parsed.cookies.link);\n\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('response should be parseable when entries have apostrophes', (done) => {\n\t\t\tmeta.configs.set('cookieConsentMessage', 'Julian\\'s Message', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\trequest(`${nconf.get('url')}/api/config`, (err, res, body) => {\n\t\t\t\t\tlet parsed;\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tparsed = JSON.parse(body);\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tassert.ifError(e);\n\t\t\t\t\t}\n\n\t\t\t\t\tassert.equal('Julian&#x27;s Message', parsed.cookies.message);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should return osd data', (done) => {\n\t\trequest(`${nconf.get('url')}/osd.xml`, (err, res, body) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert.equal(res.statusCode, 200);\n\t\t\tassert(body);\n\t\t\tdone();\n\t\t});\n\t});\n\n\tdescribe('handle errors', () => {\n\t\tconst plugins = require('../src/plugins');\n\t\tafter((done) => {\n\t\t\tplugins.loadedHooks['filter:router.page'] = undefined;\n\t\t\tdone();\n\t\t});\n\n\t\tit('should handle topic malformed uri', (done) => {\n\t\t\trequest(`${nconf.get('url')}/topic/1/a%AFc`, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should handle category malformed uri', (done) => {\n\t\t\trequest(`${nconf.get('url')}/category/1/a%AFc`, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should handle malformed uri ', (done) => {\n\t\t\trequest(`${nconf.get('url')}/user/a%AFc`, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(body);\n\t\t\t\tassert.equal(res.statusCode, 400);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should handle malformed uri in api', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/a%AFc`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 400);\n\t\t\t\tassert.equal(body.error, '[[global:400.title]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should handle CSRF error', (done) => {\n\t\t\tplugins.loadedHooks['filter:router.page'] = plugins.loadedHooks['filter:router.page'] || [];\n\t\t\tplugins.loadedHooks['filter:router.page'].push({\n\t\t\t\tmethod: function (req, res, next) {\n\t\t\t\t\tconst err = new Error('csrf-error');\n\t\t\t\t\terr.code = 'EBADCSRFTOKEN';\n\t\t\t\t\tnext(err);\n\t\t\t\t},\n\t\t\t});\n\n\t\t\trequest(`${nconf.get('url')}/users`, {}, (err, res) => {\n\t\t\t\tplugins.loadedHooks['filter:router.page'] = [];\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 403);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should handle black-list error', (done) => {\n\t\t\tplugins.loadedHooks['filter:router.page'] = plugins.loadedHooks['filter:router.page'] || [];\n\t\t\tplugins.loadedHooks['filter:router.page'].push({\n\t\t\t\tmethod: function (req, res, next) {\n\t\t\t\t\tconst err = new Error('blacklist error message');\n\t\t\t\t\terr.code = 'blacklisted-ip';\n\t\t\t\t\tnext(err);\n\t\t\t\t},\n\t\t\t});\n\n\t\t\trequest(`${nconf.get('url')}/users`, {}, (err, res, body) => {\n\t\t\t\tplugins.loadedHooks['filter:router.page'] = [];\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 403);\n\t\t\t\tassert.equal(body, 'blacklist error message');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should handle page redirect through error', (done) => {\n\t\t\tplugins.loadedHooks['filter:router.page'] = plugins.loadedHooks['filter:router.page'] || [];\n\t\t\tplugins.loadedHooks['filter:router.page'].push({\n\t\t\t\tmethod: function (req, res, next) {\n\t\t\t\t\tconst err = new Error('redirect');\n\t\t\t\t\terr.status = 302;\n\t\t\t\t\terr.path = '/popular';\n\t\t\t\t\tplugins.loadedHooks['filter:router.page'] = [];\n\t\t\t\t\tnext(err);\n\t\t\t\t},\n\t\t\t});\n\n\t\t\trequest(`${nconf.get('url')}/users`, {}, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should handle api page redirect through error', (done) => {\n\t\t\tplugins.loadedHooks['filter:router.page'] = plugins.loadedHooks['filter:router.page'] || [];\n\t\t\tplugins.loadedHooks['filter:router.page'].push({\n\t\t\t\tmethod: function (req, res, next) {\n\t\t\t\t\tconst err = new Error('redirect');\n\t\t\t\t\terr.status = 308;\n\t\t\t\t\terr.path = '/api/popular';\n\t\t\t\t\tplugins.loadedHooks['filter:router.page'] = [];\n\t\t\t\t\tnext(err);\n\t\t\t\t},\n\t\t\t});\n\n\t\t\trequest(`${nconf.get('url')}/api/users`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert.equal(res.headers['x-redirect'], '/api/popular');\n\t\t\t\tassert(body, '/api/popular');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should handle error page', (done) => {\n\t\t\tplugins.loadedHooks['filter:router.page'] = plugins.loadedHooks['filter:router.page'] || [];\n\t\t\tplugins.loadedHooks['filter:router.page'].push({\n\t\t\t\tmethod: function (req, res, next) {\n\t\t\t\t\tconst err = new Error('regular error');\n\t\t\t\t\tnext(err);\n\t\t\t\t},\n\t\t\t});\n\n\t\t\trequest(`${nconf.get('url')}/users`, (err, res, body) => {\n\t\t\t\tplugins.loadedHooks['filter:router.page'] = [];\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 500);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('category', () => {\n\t\tlet jar;\n\t\tbefore(async () => {\n\t\t\t({ jar } = await helpers.loginUser('foo', 'barbar'));\n\t\t});\n\n\t\tit('should return 404 if cid is not a number', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/category/fail`, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return 404 if topic index is not a number', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/category/${category.slug}/invalidtopicindex`, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should 404 if category does not exist', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/category/123123`, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should 404 if category is disabled', (done) => {\n\t\t\tcategories.create({ name: 'disabled' }, (err, category) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tcategories.setCategoryField(category.cid, 'disabled', 1, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\trequest(`${nconf.get('url')}/api/category/${category.slug}`, (err, res) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should return 401 if not allowed to read', (done) => {\n\t\t\tcategories.create({ name: 'hidden' }, (err, category) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tprivileges.categories.rescind(['groups:read'], category.cid, 'guests', (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\trequest(`${nconf.get('url')}/api/category/${category.slug}`, (err, res) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(res.statusCode, 401);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should redirect if topic index is negative', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/category/${category.slug}/-10`, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert.ok(res.headers['x-redirect']);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should 404 if page is not found', (done) => {\n\t\t\tuser.setSetting(fooUid, 'usePagination', 1, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\trequest(`${nconf.get('url')}/api/category/${category.slug}?page=100`, { jar: jar, json: true }, (err, res) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should load page 1 if req.query.page is not sent', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/category/${category.slug}`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert.equal(body.pagination.currentPage, 1);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should sort topics by most posts', (done) => {\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\tcategories.create({ name: 'most-posts-category' }, next);\n\t\t\t\t},\n\t\t\t\tfunction (category, next) {\n\t\t\t\t\tasync.waterfall([\n\t\t\t\t\t\tfunction (next) {\n\t\t\t\t\t\t\ttopics.post({ uid: fooUid, cid: category.cid, title: 'topic 1', content: 'topic 1 OP' }, next);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (data, next) {\n\t\t\t\t\t\t\ttopics.post({ uid: fooUid, cid: category.cid, title: 'topic 2', content: 'topic 2 OP' }, next);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (data, next) {\n\t\t\t\t\t\t\ttopics.reply({ uid: fooUid, content: 'topic 2 reply', tid: data.topicData.tid }, next);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (postData, next) {\n\t\t\t\t\t\t\trequest(`${nconf.get('url')}/api/category/${category.slug}?sort=most_posts`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\t\t\t\tassert.equal(body.topics[0].title, 'topic 2');\n\t\t\t\t\t\t\t\tassert.equal(body.topics[0].postcount, 2);\n\t\t\t\t\t\t\t\tassert.equal(body.topics[1].postcount, 1);\n\t\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t], (err) => {\n\t\t\t\t\t\tnext(err);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should load a specific users topics from a category with tags', (done) => {\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\tcategories.create({ name: 'filtered-category' }, next);\n\t\t\t\t},\n\t\t\t\tfunction (category, next) {\n\t\t\t\t\tasync.waterfall([\n\t\t\t\t\t\tfunction (next) {\n\t\t\t\t\t\t\ttopics.post({ uid: fooUid, cid: category.cid, title: 'topic 1', content: 'topic 1 OP', tags: ['java', 'cpp'] }, next);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (data, next) {\n\t\t\t\t\t\t\ttopics.post({ uid: fooUid, cid: category.cid, title: 'topic 2', content: 'topic 2 OP', tags: ['node', 'javascript'] }, next);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (data, next) {\n\t\t\t\t\t\t\ttopics.post({ uid: fooUid, cid: category.cid, title: 'topic 3', content: 'topic 3 OP', tags: ['java', 'cpp', 'best'] }, next);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (data, next) {\n\t\t\t\t\t\t\trequest(`${nconf.get('url')}/api/category/${category.slug}?tag=node&author=foo`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\t\t\t\tassert.equal(body.topics[0].title, 'topic 2');\n\t\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (next) {\n\t\t\t\t\t\t\trequest(`${nconf.get('url')}/api/category/${category.slug}?tag[]=java&tag[]=cpp`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\t\t\t\tassert.equal(body.topics[0].title, 'topic 3');\n\t\t\t\t\t\t\t\tassert.equal(body.topics[1].title, 'topic 1');\n\t\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t], (err) => {\n\t\t\t\t\t\tnext(err);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should redirect if category is a link', (done) => {\n\t\t\tlet cid;\n\t\t\tlet category;\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\tcategories.create({ name: 'redirect', link: 'https://nodebb.org' }, next);\n\t\t\t\t},\n\t\t\t\tfunction (_category, next) {\n\t\t\t\t\tcategory = _category;\n\t\t\t\t\tcid = category.cid;\n\t\t\t\t\trequest(`${nconf.get('url')}/api/category/${category.slug}`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\t\tassert.equal(res.headers['x-redirect'], 'https://nodebb.org');\n\t\t\t\t\t\tassert.equal(body, 'https://nodebb.org');\n\t\t\t\t\t\tnext();\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\tcategories.setCategoryField(cid, 'link', '/recent', next);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\trequest(`${nconf.get('url')}/api/category/${category.slug}`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\t\tassert.equal(res.headers['x-redirect'], '/recent');\n\t\t\t\t\t\tassert.equal(body, '/recent');\n\t\t\t\t\t\tnext();\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should get recent topic replies from children categories', (done) => {\n\t\t\tlet parentCategory;\n\t\t\tlet childCategory1;\n\t\t\tlet childCategory2;\n\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\tcategories.create({ name: 'parent category', backgroundImage: 'path/to/some/image' }, next);\n\t\t\t\t},\n\t\t\t\tfunction (category, next) {\n\t\t\t\t\tparentCategory = category;\n\t\t\t\t\tasync.waterfall([\n\t\t\t\t\t\tfunction (next) {\n\t\t\t\t\t\t\tcategories.create({ name: 'child category 1', parentCid: category.cid }, next);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (category, next) {\n\t\t\t\t\t\t\tchildCategory1 = category;\n\t\t\t\t\t\t\tcategories.create({ name: 'child category 2', parentCid: parentCategory.cid }, next);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (category, next) {\n\t\t\t\t\t\t\tchildCategory2 = category;\n\t\t\t\t\t\t\ttopics.post({ uid: fooUid, cid: childCategory2.cid, title: 'topic 1', content: 'topic 1 OP' }, next);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (data, next) {\n\t\t\t\t\t\t\trequest(`${nconf.get('url')}/api/category/${parentCategory.slug}`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\t\t\t\tassert.equal(body.children[0].posts[0].content, 'topic 1 OP');\n\t\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t], (err) => {\n\t\t\t\t\t\tnext(err);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should create 2 pages of topics', (done) => {\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\tcategories.create({ name: 'category with 2 pages' }, next);\n\t\t\t\t},\n\t\t\t\tfunction (category, next) {\n\t\t\t\t\tconst titles = [];\n\t\t\t\t\tfor (let i = 0; i < 30; i++) {\n\t\t\t\t\t\ttitles.push(`topic title ${i}`);\n\t\t\t\t\t}\n\n\t\t\t\t\tasync.waterfall([\n\t\t\t\t\t\tfunction (next) {\n\t\t\t\t\t\t\tasync.eachSeries(titles, (title, next) => {\n\t\t\t\t\t\t\t\ttopics.post({ uid: fooUid, cid: category.cid, title: title, content: 'does not really matter' }, next);\n\t\t\t\t\t\t\t}, next);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (next) {\n\t\t\t\t\t\t\tuser.getSettings(fooUid, next);\n\t\t\t\t\t\t},\n\t\t\t\t\t\tfunction (settings, next) {\n\t\t\t\t\t\t\trequest(`${nconf.get('url')}/api/category/${category.slug}`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\t\t\t\tassert.equal(body.topics.length, settings.topicsPerPage);\n\t\t\t\t\t\t\t\tassert.equal(body.pagination.pageCount, 2);\n\t\t\t\t\t\t\t\tnext();\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t},\n\t\t\t\t\t], (err) => {\n\t\t\t\t\t\tnext(err);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should load categories', async () => {\n\t\t\tconst helpers = require('../src/controllers/helpers');\n\t\t\tconst data = await helpers.getCategories('cid:0:children', 1, 'topics:read', 0);\n\t\t\tassert(data.categories.length > 0);\n\t\t\tassert.strictEqual(data.selectedCategory, null);\n\t\t\tassert.deepStrictEqual(data.selectedCids, []);\n\t\t});\n\n\t\tit('should load categories by states', async () => {\n\t\t\tconst helpers = require('../src/controllers/helpers');\n\t\t\tconst data = await helpers.getCategoriesByStates(1, 1, Object.values(categories.watchStates), 'topics:read');\n\t\t\tassert.deepStrictEqual(data.selectedCategory.cid, 1);\n\t\t\tassert.deepStrictEqual(data.selectedCids, [1]);\n\t\t});\n\n\t\tit('should load categories by states', async () => {\n\t\t\tconst helpers = require('../src/controllers/helpers');\n\t\t\tconst data = await helpers.getCategoriesByStates(1, 0, [categories.watchStates.ignoring], 'topics:read');\n\t\t\tassert(data.categories.length === 0);\n\t\t\tassert.deepStrictEqual(data.selectedCategory, null);\n\t\t\tassert.deepStrictEqual(data.selectedCids, []);\n\t\t});\n\t});\n\n\tdescribe('unread', () => {\n\t\tlet jar;\n\t\tbefore(async () => {\n\t\t\t({ jar } = await helpers.loginUser('foo', 'barbar'));\n\t\t});\n\n\t\tit('should load unread page', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/unread`, { jar: jar }, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should 404 if filter is invalid', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/unread/doesnotexist`, { jar: jar }, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return total unread count', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/unread/total?filter=new`, { jar: jar }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert.equal(body, 0);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should redirect if page is out of bounds', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/unread?page=-1`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert.equal(res.headers['x-redirect'], '/unread?page=1');\n\t\t\t\tassert.equal(body, '/unread?page=1');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('admin middlewares', () => {\n\t\tit('should redirect to login', (done) => {\n\t\t\trequest(`${nconf.get('url')}//api/admin/advanced/database`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 401);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should redirect to login', (done) => {\n\t\t\trequest(`${nconf.get('url')}//admin/advanced/database`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body.includes('Login to your account'));\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('composer', () => {\n\t\tlet csrf_token;\n\t\tlet jar;\n\n\t\tbefore(async () => {\n\t\t\tconst login = await helpers.loginUser('foo', 'barbar');\n\t\t\tjar = login.jar;\n\t\t\tcsrf_token = login.csrf_token;\n\t\t});\n\n\t\tit('should load the composer route', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/compose?cid=1`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body.title);\n\t\t\t\tassert(body.template);\n\t\t\t\tassert.equal(body.url, `${nconf.get('relative_path')}/compose`);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load the composer route if disabled by plugin', (done) => {\n\t\t\tfunction hookMethod(hookData, callback) {\n\t\t\t\thookData.templateData.disabled = true;\n\t\t\t\tcallback(null, hookData);\n\t\t\t}\n\n\t\t\tplugins.hooks.register('myTestPlugin', {\n\t\t\t\thook: 'filter:composer.build',\n\t\t\t\tmethod: hookMethod,\n\t\t\t});\n\n\t\t\trequest(`${nconf.get('url')}/api/compose?cid=1`, { json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body.title);\n\t\t\t\tassert.strictEqual(body.template.name, '');\n\t\t\t\tassert.strictEqual(body.url, `${nconf.get('relative_path')}/compose`);\n\n\t\t\t\tplugins.hooks.unregister('myTestPlugin', 'filter:composer.build', hookMethod);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error with invalid data', (done) => {\n\t\t\trequest.post(`${nconf.get('url')}/compose`, {\n\t\t\t\tform: {\n\t\t\t\t\tcontent: 'a new reply',\n\t\t\t\t},\n\t\t\t\tjar: jar,\n\t\t\t\theaders: {\n\t\t\t\t\t'x-csrf-token': csrf_token,\n\t\t\t\t},\n\t\t\t}, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 400);\n\t\t\t\trequest.post(`${nconf.get('url')}/compose`, {\n\t\t\t\t\tform: {\n\t\t\t\t\t\ttid: tid,\n\t\t\t\t\t},\n\t\t\t\t\tjar: jar,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'x-csrf-token': csrf_token,\n\t\t\t\t\t},\n\t\t\t\t}, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 400);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should create a new topic and reply by composer route', (done) => {\n\t\t\tconst data = {\n\t\t\t\tcid: cid,\n\t\t\t\ttitle: 'no js is good',\n\t\t\t\tcontent: 'a topic with noscript',\n\t\t\t};\n\t\t\trequest.post(`${nconf.get('url')}/compose`, {\n\t\t\t\tform: data,\n\t\t\t\tjar: jar,\n\t\t\t\theaders: {\n\t\t\t\t\t'x-csrf-token': csrf_token,\n\t\t\t\t},\n\t\t\t}, (err, res) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 302);\n\t\t\t\trequest.post(`${nconf.get('url')}/compose`, {\n\t\t\t\t\tform: {\n\t\t\t\t\t\ttid: tid,\n\t\t\t\t\t\tcontent: 'a new reply',\n\t\t\t\t\t},\n\t\t\t\t\tjar: jar,\n\t\t\t\t\theaders: {\n\t\t\t\t\t\t'x-csrf-token': csrf_token,\n\t\t\t\t\t},\n\t\t\t\t}, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 302);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('test routes', () => {\n\t\tif (process.env.NODE_ENV === 'development') {\n\t\t\tit('should load debug route', (done) => {\n\t\t\t\trequest(`${nconf.get('url')}/debug/test`, {}, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\t\tassert(body);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should load redoc read route', (done) => {\n\t\t\t\trequest(`${nconf.get('url')}/debug/spec/read`, {}, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert(body);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should load redoc write route', (done) => {\n\t\t\t\trequest(`${nconf.get('url')}/debug/spec/write`, {}, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\t\tassert(body);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should load 404 for invalid type', (done) => {\n\t\t\t\trequest(`${nconf.get('url')}/debug/spec/doesnotexist`, {}, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(res.statusCode, 404);\n\t\t\t\t\tassert(body);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t}\n\t});\n\n\tafter((done) => {\n\t\tconst analytics = require('../src/analytics');\n\t\tanalytics.writeData(done);\n\t});\n});\n", "'use strict';\n\nconst assert = require('assert');\nconst async = require('async');\nconst fs = require('fs');\nconst path = require('path');\nconst nconf = require('nconf');\nconst validator = require('validator');\nconst request = require('request');\nconst requestAsync = require('request-promise-native');\nconst jwt = require('jsonwebtoken');\n\nconst db = require('./mocks/databasemock');\nconst User = require('../src/user');\nconst Topics = require('../src/topics');\nconst Categories = require('../src/categories');\nconst Posts = require('../src/posts');\nconst Password = require('../src/password');\nconst groups = require('../src/groups');\nconst messaging = require('../src/messaging');\nconst helpers = require('./helpers');\nconst meta = require('../src/meta');\nconst file = require('../src/file');\nconst socketUser = require('../src/socket.io/user');\nconst apiUser = require('../src/api/users');\nconst utils = require('../src/utils');\n\ndescribe('User', () => {\n\tlet userData;\n\tlet testUid;\n\tlet testCid;\n\n\tconst plugins = require('../src/plugins');\n\n\tasync function dummyEmailerHook(data) {\n\t\t// pretend to handle sending emails\n\t}\n\tbefore((done) => {\n\t\t// Attach an emailer hook so related requests do not error\n\t\tplugins.hooks.register('emailer-test', {\n\t\t\thook: 'filter:email.send',\n\t\t\tmethod: dummyEmailerHook,\n\t\t});\n\n\t\tCategories.create({\n\t\t\tname: 'Test Category',\n\t\t\tdescription: 'A test',\n\t\t\torder: 1,\n\t\t}, (err, categoryObj) => {\n\t\t\tif (err) {\n\t\t\t\treturn done(err);\n\t\t\t}\n\n\t\t\ttestCid = categoryObj.cid;\n\t\t\tdone();\n\t\t});\n\t});\n\tafter(() => {\n\t\tplugins.hooks.unregister('emailer-test', 'filter:email.send');\n\t});\n\n\tbeforeEach(() => {\n\t\tuserData = {\n\t\t\tusername: 'John Smith',\n\t\t\tfullname: 'John Smith McNamara',\n\t\t\tpassword: 'swordfish',\n\t\t\temail: 'john@example.com',\n\t\t\tcallback: undefined,\n\t\t};\n\t});\n\n\tconst goodImage = 'data:image/png;base64,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';\n\n\tdescribe('.create(), when created', () => {\n\t\tit('should be created properly', async () => {\n\t\t\ttestUid = await User.create({ username: userData.username, password: userData.password });\n\t\t\tassert.ok(testUid);\n\n\t\t\tawait User.setUserField(testUid, 'email', userData.email);\n\t\t\tawait User.email.confirmByUid(testUid);\n\t\t});\n\n\t\tit('should be created properly', async () => {\n\t\t\tconst email = '<h1>test</h1>@gmail.com';\n\t\t\tconst uid = await User.create({ username: 'weirdemail', email: email });\n\t\t\tconst data = await User.getUserData(uid);\n\n\t\t\tconst validationPending = await User.email.isValidationPending(uid, email);\n\t\t\tassert.strictEqual(validationPending, true);\n\n\t\t\tassert.equal(data.email, '&lt;h1&gt;test&lt;&#x2F;h1&gt;@gmail.com');\n\t\t\tassert.strictEqual(data.profileviews, 0);\n\t\t\tassert.strictEqual(data.reputation, 0);\n\t\t\tassert.strictEqual(data.postcount, 0);\n\t\t\tassert.strictEqual(data.topiccount, 0);\n\t\t\tassert.strictEqual(data.lastposttime, 0);\n\t\t\tassert.strictEqual(data.banned, false);\n\t\t});\n\n\t\tit('should have a valid email, if using an email', (done) => {\n\t\t\tUser.create({ username: userData.username, password: userData.password, email: 'fakeMail' }, (err) => {\n\t\t\t\tassert(err);\n\t\t\t\tassert.equal(err.message, '[[error:invalid-email]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error with invalid password', (done) => {\n\t\t\tUser.create({ username: 'test', password: '1' }, (err) => {\n\t\t\t\tassert.equal(err.message, '[[reset_password:password_too_short]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error with invalid password', (done) => {\n\t\t\tUser.create({ username: 'test', password: {} }, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-password]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error with a too long password', (done) => {\n\t\t\tlet toolong = '';\n\t\t\tfor (let i = 0; i < 5000; i++) {\n\t\t\t\ttoolong += 'a';\n\t\t\t}\n\t\t\tUser.create({ username: 'test', password: toolong }, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:password-too-long]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should error if username is already taken or rename user', async () => {\n\t\t\tlet err;\n\t\t\tasync function tryCreate(data) {\n\t\t\t\ttry {\n\t\t\t\t\treturn await User.create(data);\n\t\t\t\t} catch (_err) {\n\t\t\t\t\terr = _err;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tconst [uid1, uid2] = await Promise.all([\n\t\t\t\ttryCreate({ username: 'dupe1' }),\n\t\t\t\ttryCreate({ username: 'dupe1' }),\n\t\t\t]);\n\t\t\tif (err) {\n\t\t\t\tassert.strictEqual(err.message, '[[error:username-taken]]');\n\t\t\t} else {\n\t\t\t\tconst userData = await User.getUsersFields([uid1, uid2], ['username']);\n\t\t\t\tconst userNames = userData.map(u => u.username);\n\t\t\t\t// make sure only 1 dupe1 is created\n\t\t\t\tassert.equal(userNames.filter(username => username === 'dupe1').length, 1);\n\t\t\t\tassert.equal(userNames.filter(username => username === 'dupe1 0').length, 1);\n\t\t\t}\n\t\t});\n\n\t\tit('should error if email is already taken', async () => {\n\t\t\tlet err;\n\t\t\tasync function tryCreate(data) {\n\t\t\t\ttry {\n\t\t\t\t\treturn await User.create(data);\n\t\t\t\t} catch (_err) {\n\t\t\t\t\terr = _err;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tawait Promise.all([\n\t\t\t\ttryCreate({ username: 'notdupe1', email: 'dupe@dupe.com' }),\n\t\t\t\ttryCreate({ username: 'notdupe2', email: 'dupe@dupe.com' }),\n\t\t\t]);\n\t\t\tassert.strictEqual(err.message, '[[error:email-taken]]');\n\t\t});\n\t});\n\n\tdescribe('.uniqueUsername()', () => {\n\t\tit('should deal with collisions', (done) => {\n\t\t\tconst users = [];\n\t\t\tfor (let i = 0; i < 10; i += 1) {\n\t\t\t\tusers.push({\n\t\t\t\t\tusername: 'Jane Doe',\n\t\t\t\t\temail: `jane.doe${i}@example.com`,\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tasync.series([\n\t\t\t\tfunction (next) {\n\t\t\t\t\tasync.eachSeries(users, (user, next) => {\n\t\t\t\t\t\tUser.create(user, next);\n\t\t\t\t\t}, next);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\tUser.uniqueUsername({\n\t\t\t\t\t\tusername: 'Jane Doe',\n\t\t\t\t\t\tuserslug: 'jane-doe',\n\t\t\t\t\t}, (err, username) => {\n\t\t\t\t\t\tassert.ifError(err);\n\n\t\t\t\t\t\tassert.strictEqual(username, 'Jane Doe 9');\n\t\t\t\t\t\tnext();\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\t});\n\n\tdescribe('.isModerator()', () => {\n\t\tit('should return false', (done) => {\n\t\t\tUser.isModerator(testUid, testCid, (err, isModerator) => {\n\t\t\t\tassert.equal(err, null);\n\t\t\t\tassert.equal(isModerator, false);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return two false results', (done) => {\n\t\t\tUser.isModerator([testUid, testUid], testCid, (err, isModerator) => {\n\t\t\t\tassert.equal(err, null);\n\t\t\t\tassert.equal(isModerator[0], false);\n\t\t\t\tassert.equal(isModerator[1], false);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return two false results', (done) => {\n\t\t\tUser.isModerator(testUid, [testCid, testCid], (err, isModerator) => {\n\t\t\t\tassert.equal(err, null);\n\t\t\t\tassert.equal(isModerator[0], false);\n\t\t\t\tassert.equal(isModerator[1], false);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('.getModeratorUids()', () => {\n\t\tbefore((done) => {\n\t\t\tgroups.join('cid:1:privileges:moderate', 1, done);\n\t\t});\n\n\t\tit('should retrieve all users with moderator bit in category privilege', (done) => {\n\t\t\tUser.getModeratorUids((err, uids) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(1, uids.length);\n\t\t\t\tassert.strictEqual(1, parseInt(uids[0], 10));\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tafter((done) => {\n\t\t\tgroups.leave('cid:1:privileges:moderate', 1, done);\n\t\t});\n\t});\n\n\tdescribe('.getModeratorUids()', () => {\n\t\tbefore((done) => {\n\t\t\tasync.series([\n\t\t\t\tasync.apply(groups.create, { name: 'testGroup' }),\n\t\t\t\tasync.apply(groups.join, 'cid:1:privileges:groups:moderate', 'testGroup'),\n\t\t\t\tasync.apply(groups.join, 'testGroup', 1),\n\t\t\t], done);\n\t\t});\n\n\t\tit('should retrieve all users with moderator bit in category privilege', (done) => {\n\t\t\tUser.getModeratorUids((err, uids) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(1, uids.length);\n\t\t\t\tassert.strictEqual(1, parseInt(uids[0], 10));\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tafter((done) => {\n\t\t\tasync.series([\n\t\t\t\tasync.apply(groups.leave, 'cid:1:privileges:groups:moderate', 'testGroup'),\n\t\t\t\tasync.apply(groups.destroy, 'testGroup'),\n\t\t\t], done);\n\t\t});\n\t});\n\n\tdescribe('.isReadyToPost()', () => {\n\t\tit('should error when a user makes two posts in quick succession', (done) => {\n\t\t\tmeta.config = meta.config || {};\n\t\t\tmeta.config.postDelay = '10';\n\n\t\t\tasync.series([\n\t\t\t\tasync.apply(Topics.post, {\n\t\t\t\t\tuid: testUid,\n\t\t\t\t\ttitle: 'Topic 1',\n\t\t\t\t\tcontent: 'lorem ipsum',\n\t\t\t\t\tcid: testCid,\n\t\t\t\t}),\n\t\t\t\tasync.apply(Topics.post, {\n\t\t\t\t\tuid: testUid,\n\t\t\t\t\ttitle: 'Topic 2',\n\t\t\t\t\tcontent: 'lorem ipsum',\n\t\t\t\t\tcid: testCid,\n\t\t\t\t}),\n\t\t\t], (err) => {\n\t\t\t\tassert(err);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should allow a post if the last post time is > 10 seconds', (done) => {\n\t\t\tUser.setUserField(testUid, 'lastposttime', +new Date() - (11 * 1000), () => {\n\t\t\t\tTopics.post({\n\t\t\t\t\tuid: testUid,\n\t\t\t\t\ttitle: 'Topic 3',\n\t\t\t\t\tcontent: 'lorem ipsum',\n\t\t\t\t\tcid: testCid,\n\t\t\t\t}, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should error when a new user posts if the last post time is 10 < 30 seconds', (done) => {\n\t\t\tmeta.config.newbiePostDelay = 30;\n\t\t\tmeta.config.newbiePostDelayThreshold = 3;\n\n\t\t\tUser.setUserField(testUid, 'lastposttime', +new Date() - (20 * 1000), () => {\n\t\t\t\tTopics.post({\n\t\t\t\t\tuid: testUid,\n\t\t\t\t\ttitle: 'Topic 4',\n\t\t\t\t\tcontent: 'lorem ipsum',\n\t\t\t\t\tcid: testCid,\n\t\t\t\t}, (err) => {\n\t\t\t\t\tassert(err);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should not error if a non-newbie user posts if the last post time is 10 < 30 seconds', (done) => {\n\t\t\tUser.setUserFields(testUid, {\n\t\t\t\tlastposttime: +new Date() - (20 * 1000),\n\t\t\t\treputation: 10,\n\t\t\t}, () => {\n\t\t\t\tTopics.post({\n\t\t\t\t\tuid: testUid,\n\t\t\t\t\ttitle: 'Topic 5',\n\t\t\t\t\tcontent: 'lorem ipsum',\n\t\t\t\t\tcid: testCid,\n\t\t\t\t}, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('.search()', () => {\n\t\tlet adminUid;\n\t\tlet uid;\n\t\tbefore(async () => {\n\t\t\tadminUid = await User.create({ username: 'noteadmin' });\n\t\t\tawait groups.join('administrators', adminUid);\n\t\t});\n\n\t\tit('should return an object containing an array of matching users', (done) => {\n\t\t\tUser.search({ query: 'john' }, (err, searchData) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tuid = searchData.users[0].uid;\n\t\t\t\tassert.equal(Array.isArray(searchData.users) && searchData.users.length > 0, true);\n\t\t\t\tassert.equal(searchData.users[0].username, 'John Smith');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should search user', async () => {\n\t\t\tconst searchData = await apiUser.search({ uid: testUid }, { query: 'john' });\n\t\t\tassert.equal(searchData.users[0].username, 'John Smith');\n\t\t});\n\n\t\tit('should error for guest', async () => {\n\t\t\ttry {\n\t\t\t\tawait apiUser.search({ uid: 0 }, { query: 'john' });\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should error with invalid data', async () => {\n\t\t\ttry {\n\t\t\t\tawait apiUser.search({ uid: testUid }, null);\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should error for unprivileged user', async () => {\n\t\t\ttry {\n\t\t\t\tawait apiUser.search({ uid: testUid }, { searchBy: 'ip', query: '123' });\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should error for unprivileged user', async () => {\n\t\t\ttry {\n\t\t\t\tawait apiUser.search({ uid: testUid }, { filters: ['banned'], query: '123' });\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should error for unprivileged user', async () => {\n\t\t\ttry {\n\t\t\t\tawait apiUser.search({ uid: testUid }, { filters: ['flagged'], query: '123' });\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should search users by ip', async () => {\n\t\t\tconst uid = await User.create({ username: 'ipsearch' });\n\t\t\tawait db.sortedSetAdd('ip:1.1.1.1:uid', [1, 1], [testUid, uid]);\n\t\t\tconst data = await apiUser.search({ uid: adminUid }, { query: '1.1.1.1', searchBy: 'ip' });\n\t\t\tassert(Array.isArray(data.users));\n\t\t\tassert.equal(data.users.length, 2);\n\t\t});\n\n\t\tit('should search users by uid', async () => {\n\t\t\tconst data = await apiUser.search({ uid: testUid }, { query: uid, searchBy: 'uid' });\n\t\t\tassert(Array.isArray(data.users));\n\t\t\tassert.equal(data.users[0].uid, uid);\n\t\t});\n\n\t\tit('should search users by fullname', async () => {\n\t\t\tconst uid = await User.create({ username: 'fullnamesearch1', fullname: 'Mr. Fullname' });\n\t\t\tconst data = await apiUser.search({ uid: adminUid }, { query: 'mr', searchBy: 'fullname' });\n\t\t\tassert(Array.isArray(data.users));\n\t\t\tassert.equal(data.users.length, 1);\n\t\t\tassert.equal(uid, data.users[0].uid);\n\t\t});\n\n\t\tit('should search users by fullname', async () => {\n\t\t\tconst uid = await User.create({ username: 'fullnamesearch2', fullname: 'Baris:Usakli' });\n\t\t\tconst data = await apiUser.search({ uid: adminUid }, { query: 'baris:', searchBy: 'fullname' });\n\t\t\tassert(Array.isArray(data.users));\n\t\t\tassert.equal(data.users.length, 1);\n\t\t\tassert.equal(uid, data.users[0].uid);\n\t\t});\n\n\t\tit('should return empty array if query is empty', async () => {\n\t\t\tconst data = await apiUser.search({ uid: testUid }, { query: '' });\n\t\t\tassert.equal(data.users.length, 0);\n\t\t});\n\n\t\tit('should filter users', async () => {\n\t\t\tconst uid = await User.create({ username: 'ipsearch_filter' });\n\t\t\tawait User.bans.ban(uid, 0, '');\n\t\t\tawait User.setUserFields(uid, { flags: 10 });\n\t\t\tconst data = await apiUser.search({ uid: adminUid }, {\n\t\t\t\tquery: 'ipsearch',\n\t\t\t\tfilters: ['online', 'banned', 'flagged'],\n\t\t\t});\n\t\t\tassert.equal(data.users[0].username, 'ipsearch_filter');\n\t\t});\n\n\t\tit('should sort results by username', (done) => {\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\tUser.create({ username: 'brian' }, next);\n\t\t\t\t},\n\t\t\t\tfunction (uid, next) {\n\t\t\t\t\tUser.create({ username: 'baris' }, next);\n\t\t\t\t},\n\t\t\t\tfunction (uid, next) {\n\t\t\t\t\tUser.create({ username: 'bzari' }, next);\n\t\t\t\t},\n\t\t\t\tfunction (uid, next) {\n\t\t\t\t\tUser.search({\n\t\t\t\t\t\tuid: testUid,\n\t\t\t\t\t\tquery: 'b',\n\t\t\t\t\t\tsortBy: 'username',\n\t\t\t\t\t\tpaginate: false,\n\t\t\t\t\t}, next);\n\t\t\t\t},\n\t\t\t], (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(data.users[0].username, 'baris');\n\t\t\t\tassert.equal(data.users[1].username, 'brian');\n\t\t\t\tassert.equal(data.users[2].username, 'bzari');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('.delete()', () => {\n\t\tlet uid;\n\t\tbefore((done) => {\n\t\t\tUser.create({ username: 'usertodelete', password: '123456', email: 'delete@me.com' }, (err, newUid) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tuid = newUid;\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should delete a user account', (done) => {\n\t\t\tUser.delete(1, uid, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tUser.existsBySlug('usertodelete', (err, exists) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(exists, false);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should not re-add user to users:postcount if post is purged after user account deletion', async () => {\n\t\t\tconst uid = await User.create({ username: 'olduserwithposts' });\n\t\t\tassert(await db.isSortedSetMember('users:postcount', uid));\n\n\t\t\tconst result = await Topics.post({\n\t\t\t\tuid: uid,\n\t\t\t\ttitle: 'old user topic',\n\t\t\t\tcontent: 'old user topic post content',\n\t\t\t\tcid: testCid,\n\t\t\t});\n\t\t\tassert.equal(await db.sortedSetScore('users:postcount', uid), 1);\n\t\t\tawait User.deleteAccount(uid);\n\t\t\tassert(!await db.isSortedSetMember('users:postcount', uid));\n\t\t\tawait Posts.purge(result.postData.pid, 1);\n\t\t\tassert(!await db.isSortedSetMember('users:postcount', uid));\n\t\t});\n\n\t\tit('should not re-add user to users:reputation if post is upvoted after user account deletion', async () => {\n\t\t\tconst uid = await User.create({ username: 'olduserwithpostsupvote' });\n\t\t\tassert(await db.isSortedSetMember('users:reputation', uid));\n\n\t\t\tconst result = await Topics.post({\n\t\t\t\tuid: uid,\n\t\t\t\ttitle: 'old user topic',\n\t\t\t\tcontent: 'old user topic post content',\n\t\t\t\tcid: testCid,\n\t\t\t});\n\t\t\tassert.equal(await db.sortedSetScore('users:reputation', uid), 0);\n\t\t\tawait User.deleteAccount(uid);\n\t\t\tassert(!await db.isSortedSetMember('users:reputation', uid));\n\t\t\tawait Posts.upvote(result.postData.pid, 1);\n\t\t\tassert(!await db.isSortedSetMember('users:reputation', uid));\n\t\t});\n\n\t\tit('should delete user even if they started a chat', async () => {\n\t\t\tconst socketModules = require('../src/socket.io/modules');\n\t\t\tconst uid1 = await User.create({ username: 'chatuserdelete1' });\n\t\t\tconst uid2 = await User.create({ username: 'chatuserdelete2' });\n\t\t\tconst roomId = await messaging.newRoom(uid1, [uid2]);\n\t\t\tawait messaging.addMessage({\n\t\t\t\tuid: uid1,\n\t\t\t\tcontent: 'hello',\n\t\t\t\troomId,\n\t\t\t});\n\t\t\tawait messaging.leaveRoom([uid2], roomId);\n\t\t\tawait User.delete(1, uid1);\n\t\t\tassert.strictEqual(await User.exists(uid1), false);\n\t\t});\n\t});\n\n\tdescribe('passwordReset', () => {\n\t\tlet uid;\n\t\tlet code;\n\t\tbefore(async () => {\n\t\t\tuid = await User.create({ username: 'resetuser', password: '123456' });\n\t\t\tawait User.setUserField(uid, 'email', 'reset@me.com');\n\t\t\tawait User.email.confirmByUid(uid);\n\t\t});\n\n\t\tit('.generate() should generate a new reset code', (done) => {\n\t\t\tUser.reset.generate(uid, (err, _code) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(_code);\n\n\t\t\t\tcode = _code;\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('.generate() should invalidate a previous generated reset code', async () => {\n\t\t\tconst _code = await User.reset.generate(uid);\n\t\t\tconst valid = await User.reset.validate(code);\n\t\t\tassert.strictEqual(valid, false);\n\n\t\t\tcode = _code;\n\t\t});\n\n\t\tit('.validate() should ensure that this new code is valid', (done) => {\n\t\t\tUser.reset.validate(code, (err, valid) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(valid, true);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('.validate() should correctly identify an invalid code', (done) => {\n\t\t\tUser.reset.validate(`${code}abcdef`, (err, valid) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(valid, false);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('.send() should create a new reset code and reset password', async () => {\n\t\t\tcode = await User.reset.send('reset@me.com');\n\t\t});\n\n\t\tit('.commit() should update the user\\'s password and confirm their email', (done) => {\n\t\t\tUser.reset.commit(code, 'newpassword', (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\tasync.parallel({\n\t\t\t\t\tuserData: function (next) {\n\t\t\t\t\t\tUser.getUserData(uid, next);\n\t\t\t\t\t},\n\t\t\t\t\tpassword: function (next) {\n\t\t\t\t\t\tdb.getObjectField(`user:${uid}`, 'password', next);\n\t\t\t\t\t},\n\t\t\t\t}, (err, results) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tPassword.compare('newpassword', results.password, true, (err, match) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert(match);\n\t\t\t\t\t\tassert.strictEqual(results.userData['email:confirmed'], 1);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('.should error if same password is used for reset', async () => {\n\t\t\tconst uid = await User.create({ username: 'badmemory', email: 'bad@memory.com', password: '123456' });\n\t\t\tconst code = await User.reset.generate(uid);\n\t\t\tlet err;\n\t\t\ttry {\n\t\t\t\tawait User.reset.commit(code, '123456');\n\t\t\t} catch (_err) {\n\t\t\t\terr = _err;\n\t\t\t}\n\t\t\tassert.strictEqual(err.message, '[[error:reset-same-password]]');\n\t\t});\n\n\t\tit('should not validate email if password reset is due to expiry', async () => {\n\t\t\tconst uid = await User.create({ username: 'resetexpiry', email: 'reset@expiry.com', password: '123456' });\n\t\t\tlet confirmed = await User.getUserField(uid, 'email:confirmed');\n\t\t\tlet [verified, unverified] = await groups.isMemberOfGroups(uid, ['verified-users', 'unverified-users']);\n\t\t\tassert.strictEqual(confirmed, 0);\n\t\t\tassert.strictEqual(verified, false);\n\t\t\tassert.strictEqual(unverified, true);\n\t\t\tawait User.setUserField(uid, 'passwordExpiry', Date.now());\n\t\t\tconst code = await User.reset.generate(uid);\n\t\t\tawait User.reset.commit(code, '654321');\n\t\t\tconfirmed = await User.getUserField(uid, 'email:confirmed');\n\t\t\t[verified, unverified] = await groups.isMemberOfGroups(uid, ['verified-users', 'unverified-users']);\n\t\t\tassert.strictEqual(confirmed, 0);\n\t\t\tassert.strictEqual(verified, false);\n\t\t\tassert.strictEqual(unverified, true);\n\t\t});\n\t});\n\n\tdescribe('hash methods', () => {\n\t\tit('should return uid from email', (done) => {\n\t\t\tUser.getUidByEmail('john@example.com', (err, uid) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(parseInt(uid, 10), parseInt(testUid, 10));\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return uid from username', (done) => {\n\t\t\tUser.getUidByUsername('John Smith', (err, uid) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(parseInt(uid, 10), parseInt(testUid, 10));\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return uid from userslug', (done) => {\n\t\t\tUser.getUidByUserslug('john-smith', (err, uid) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(parseInt(uid, 10), parseInt(testUid, 10));\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should get user data even if one uid is NaN', (done) => {\n\t\t\tUser.getUsersData([NaN, testUid], (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(data[0]);\n\t\t\t\tassert.equal(data[0].username, '[[global:guest]]');\n\t\t\t\tassert(data[1]);\n\t\t\t\tassert.equal(data[1].username, userData.username);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should not return private user data', (done) => {\n\t\t\tUser.setUserFields(testUid, {\n\t\t\t\tfb_token: '123123123',\n\t\t\t\tanother_secret: 'abcde',\n\t\t\t\tpostcount: '123',\n\t\t\t}, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tUser.getUserData(testUid, (err, userData) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert(!userData.hasOwnProperty('fb_token'));\n\t\t\t\t\tassert(!userData.hasOwnProperty('another_secret'));\n\t\t\t\t\tassert(!userData.hasOwnProperty('password'));\n\t\t\t\t\tassert(!userData.hasOwnProperty('rss_token'));\n\t\t\t\t\tassert.strictEqual(userData.postcount, 123);\n\t\t\t\t\tassert.strictEqual(userData.uid, testUid);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should not return password even if explicitly requested', (done) => {\n\t\t\tUser.getUserFields(testUid, ['password'], (err, payload) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(!payload.hasOwnProperty('password'));\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should not modify the fields array passed in', async () => {\n\t\t\tconst fields = ['username', 'email'];\n\t\t\tawait User.getUserFields(testUid, fields);\n\t\t\tassert.deepStrictEqual(fields, ['username', 'email']);\n\t\t});\n\n\t\tit('should return an icon text and valid background if username and picture is explicitly requested', async () => {\n\t\t\tconst payload = await User.getUserFields(testUid, ['username', 'picture']);\n\t\t\tconst validBackgrounds = await User.getIconBackgrounds(testUid);\n\t\t\tassert.strictEqual(payload['icon:text'], userData.username.slice(0, 1).toUpperCase());\n\t\t\tassert(payload['icon:bgColor']);\n\t\t\tassert(validBackgrounds.includes(payload['icon:bgColor']));\n\t\t});\n\n\t\tit('should return a valid background, even if an invalid background colour is set', async () => {\n\t\t\tawait User.setUserField(testUid, 'icon:bgColor', 'teal');\n\t\t\tconst payload = await User.getUserFields(testUid, ['username', 'picture']);\n\t\t\tconst validBackgrounds = await User.getIconBackgrounds(testUid);\n\n\t\t\tassert(payload['icon:bgColor']);\n\t\t\tassert(validBackgrounds.includes(payload['icon:bgColor']));\n\t\t});\n\n\t\tit('should return private data if field is whitelisted', (done) => {\n\t\t\tfunction filterMethod(data, callback) {\n\t\t\t\tdata.whitelist.push('another_secret');\n\t\t\t\tcallback(null, data);\n\t\t\t}\n\n\t\t\tplugins.hooks.register('test-plugin', { hook: 'filter:user.whitelistFields', method: filterMethod });\n\t\t\tUser.getUserData(testUid, (err, userData) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(!userData.hasOwnProperty('fb_token'));\n\t\t\t\tassert.equal(userData.another_secret, 'abcde');\n\t\t\t\tplugins.hooks.unregister('test-plugin', 'filter:user.whitelistFields', filterMethod);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return 0 as uid if username is falsy', (done) => {\n\t\t\tUser.getUidByUsername('', (err, uid) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(uid, 0);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should get username by userslug', (done) => {\n\t\t\tUser.getUsernameByUserslug('john-smith', (err, username) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual('John Smith', username);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should get uids by emails', (done) => {\n\t\t\tUser.getUidsByEmails(['john@example.com'], (err, uids) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(uids[0], testUid);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should not get groupTitle for guests', (done) => {\n\t\t\tUser.getUserData(0, (err, userData) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(userData.groupTitle, '');\n\t\t\t\tassert.deepStrictEqual(userData.groupTitleArray, []);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load guest data', (done) => {\n\t\t\tUser.getUsersData([1, 0], (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(data[1].username, '[[global:guest]]');\n\t\t\t\tassert.strictEqual(data[1].userslug, '');\n\t\t\t\tassert.strictEqual(data[1].uid, 0);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('profile methods', () => {\n\t\tlet uid;\n\t\tlet jar;\n\t\tlet csrf_token;\n\n\t\tbefore(async () => {\n\t\t\tconst newUid = await User.create({ username: 'updateprofile', email: 'update@me.com', password: '123456' });\n\t\t\tuid = newUid;\n\n\t\t\tawait User.setUserField(uid, 'email', 'update@me.com');\n\t\t\tawait User.email.confirmByUid(uid);\n\n\t\t\t({ jar, csrf_token } = await helpers.loginUser('updateprofile', '123456'));\n\t\t});\n\n\t\tit('should return error if not logged in', async () => {\n\t\t\ttry {\n\t\t\t\tawait apiUser.update({ uid: 0 }, { uid: 1 });\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-uid]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should return error if data is invalid', async () => {\n\t\t\ttry {\n\t\t\t\tawait apiUser.update({ uid: uid }, null);\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should return error if data is missing uid', async () => {\n\t\t\ttry {\n\t\t\t\tawait apiUser.update({ uid: uid }, { username: 'bip', email: 'bop' });\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t}\n\t\t});\n\n\t\tdescribe('.updateProfile()', () => {\n\t\t\tlet uid;\n\n\t\t\tit('should update a user\\'s profile', async () => {\n\t\t\t\tuid = await User.create({ username: 'justforupdate', email: 'just@for.updated', password: '123456' });\n\t\t\t\tawait User.setUserField(uid, 'email', 'just@for.updated');\n\t\t\t\tawait User.email.confirmByUid(uid);\n\n\t\t\t\tconst data = {\n\t\t\t\t\tuid: uid,\n\t\t\t\t\tusername: 'updatedUserName',\n\t\t\t\t\temail: 'updatedEmail@me.com',\n\t\t\t\t\tfullname: 'updatedFullname',\n\t\t\t\t\twebsite: 'http://nodebb.org',\n\t\t\t\t\tlocation: 'izmir',\n\t\t\t\t\tgroupTitle: 'testGroup',\n\t\t\t\t\tbirthday: '01/01/1980',\n\t\t\t\t\tsignature: 'nodebb is good',\n\t\t\t\t\tpassword: '123456',\n\t\t\t\t};\n\t\t\t\tconst result = await apiUser.update({ uid: uid }, { ...data, password: '123456', invalid: 'field' });\n\t\t\t\tassert.equal(result.username, 'updatedUserName');\n\t\t\t\tassert.equal(result.userslug, 'updatedusername');\n\t\t\t\tassert.equal(result.location, 'izmir');\n\n\t\t\t\tconst userData = await db.getObject(`user:${uid}`);\n\t\t\t\tObject.keys(data).forEach((key) => {\n\t\t\t\t\tif (key === 'email') {\n\t\t\t\t\t\tassert.strictEqual(userData.email, 'just@for.updated'); // email remains the same until confirmed\n\t\t\t\t\t} else if (key !== 'password') {\n\t\t\t\t\t\tassert.equal(data[key], userData[key]);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tassert(userData[key].startsWith('$2a$'));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\t// updateProfile only saves valid fields\n\t\t\t\tassert.strictEqual(userData.invalid, undefined);\n\t\t\t});\n\n\t\t\tit('should also generate an email confirmation code for the changed email', async () => {\n\t\t\t\tconst confirmSent = await User.email.isValidationPending(uid, 'updatedemail@me.com');\n\t\t\t\tassert.strictEqual(confirmSent, true);\n\t\t\t});\n\t\t});\n\n\t\tit('should change a user\\'s password', async () => {\n\t\t\tconst uid = await User.create({ username: 'changepassword', password: '123456' });\n\t\t\tawait apiUser.changePassword({ uid: uid }, { uid: uid, newPassword: '654321', currentPassword: '123456' });\n\t\t\tconst correct = await User.isPasswordCorrect(uid, '654321', '127.0.0.1');\n\t\t\tassert(correct);\n\t\t});\n\n\t\tit('should not let user change another user\\'s password', async () => {\n\t\t\tconst regularUserUid = await User.create({ username: 'regularuserpwdchange', password: 'regularuser1234' });\n\t\t\tconst uid = await User.create({ username: 'changeadminpwd1', password: '123456' });\n\t\t\ttry {\n\t\t\t\tawait apiUser.changePassword({ uid: uid }, { uid: regularUserUid, newPassword: '654321', currentPassword: '123456' });\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[user:change_password_error_privileges]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should not let user change admin\\'s password', async () => {\n\t\t\tconst adminUid = await User.create({ username: 'adminpwdchange', password: 'admin1234' });\n\t\t\tawait groups.join('administrators', adminUid);\n\t\t\tconst uid = await User.create({ username: 'changeadminpwd2', password: '123456' });\n\t\t\ttry {\n\t\t\t\tawait apiUser.changePassword({ uid: uid }, { uid: adminUid, newPassword: '654321', currentPassword: '123456' });\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[user:change_password_error_privileges]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should let admin change another users password', async () => {\n\t\t\tconst adminUid = await User.create({ username: 'adminpwdchange2', password: 'admin1234' });\n\t\t\tawait groups.join('administrators', adminUid);\n\t\t\tconst uid = await User.create({ username: 'forgotmypassword', password: '123456' });\n\n\t\t\tawait apiUser.changePassword({ uid: adminUid }, { uid: uid, newPassword: '654321' });\n\t\t\tconst correct = await User.isPasswordCorrect(uid, '654321', '127.0.0.1');\n\t\t\tassert(correct);\n\t\t});\n\n\t\tit('should not let admin change their password if current password is incorrect', async () => {\n\t\t\tconst adminUid = await User.create({ username: 'adminforgotpwd', password: 'admin1234' });\n\t\t\tawait groups.join('administrators', adminUid);\n\n\t\t\ttry {\n\t\t\t\tawait apiUser.changePassword({ uid: adminUid }, { uid: adminUid, newPassword: '654321', currentPassword: 'wrongpwd' });\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[user:change_password_error_wrong_current]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should change username', async () => {\n\t\t\tawait apiUser.update({ uid: uid }, { uid: uid, username: 'updatedAgain', password: '123456' });\n\t\t\tconst username = await db.getObjectField(`user:${uid}`, 'username');\n\t\t\tassert.equal(username, 'updatedAgain');\n\t\t});\n\n\t\tit('should not let setting an empty username', async () => {\n\t\t\tawait apiUser.update({ uid: uid }, { uid: uid, username: '', password: '123456' });\n\t\t\tconst username = await db.getObjectField(`user:${uid}`, 'username');\n\t\t\tassert.strictEqual(username, 'updatedAgain');\n\t\t});\n\n\t\tit('should let updating profile if current username is above max length and it is not being changed', async () => {\n\t\t\tconst maxLength = meta.config.maximumUsernameLength + 1;\n\t\t\tconst longName = new Array(maxLength).fill('a').join('');\n\t\t\tconst uid = await User.create({ username: longName });\n\t\t\tawait apiUser.update({ uid: uid }, { uid: uid, username: longName, email: 'verylong@name.com' });\n\t\t\tconst userData = await db.getObject(`user:${uid}`);\n\t\t\tconst awaitingValidation = await User.email.isValidationPending(uid, 'verylong@name.com');\n\n\t\t\tassert.strictEqual(userData.username, longName);\n\t\t\tassert.strictEqual(awaitingValidation, true);\n\t\t});\n\n\t\tit('should not update a user\\'s username if it did not change', async () => {\n\t\t\tawait apiUser.update({ uid: uid }, { uid: uid, username: 'updatedAgain', password: '123456' });\n\t\t\tconst data = await db.getSortedSetRevRange(`user:${uid}:usernames`, 0, -1);\n\t\t\tassert.equal(data.length, 2);\n\t\t\tassert(data[0].startsWith('updatedAgain'));\n\t\t});\n\n\t\tit('should not update a user\\'s username if a password is not supplied', async () => {\n\t\t\ttry {\n\t\t\t\tawait apiUser.update({ uid: uid }, { uid: uid, username: 'updatedAgain', password: '' });\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.strictEqual(err.message, '[[error:invalid-password]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should send validation email', async () => {\n\t\t\tconst uid = await User.create({ username: 'pooremailupdate', email: 'poor@update.me', password: '123456' });\n\t\t\tawait User.email.expireValidation(uid);\n\t\t\tawait apiUser.update({ uid: uid }, { uid: uid, email: 'updatedAgain@me.com', password: '123456' });\n\n\t\t\tassert.strictEqual(await User.email.isValidationPending(uid, 'updatedAgain@me.com'.toLowerCase()), true);\n\t\t});\n\n\t\tit('should update cover image', (done) => {\n\t\t\tconst position = '50.0301% 19.2464%';\n\t\t\tsocketUser.updateCover({ uid: uid }, { uid: uid, imageData: goodImage, position: position }, (err, result) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(result.url);\n\t\t\t\tdb.getObjectFields(`user:${uid}`, ['cover:url', 'cover:position'], (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(data['cover:url'], result.url);\n\t\t\t\t\tassert.equal(data['cover:position'], position);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should remove cover image', async () => {\n\t\t\tconst coverPath = await User.getLocalCoverPath(uid);\n\t\t\tawait socketUser.removeCover({ uid: uid }, { uid: uid });\n\t\t\tconst coverUrlNow = await db.getObjectField(`user:${uid}`, 'cover:url');\n\t\t\tassert.strictEqual(coverUrlNow, null);\n\t\t\tassert.strictEqual(fs.existsSync(coverPath), false);\n\t\t});\n\n\t\tit('should set user status', (done) => {\n\t\t\tsocketUser.setStatus({ uid: uid }, 'away', (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(data.uid, uid);\n\t\t\t\tassert.equal(data.status, 'away');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should fail for invalid status', (done) => {\n\t\t\tsocketUser.setStatus({ uid: uid }, '12345', (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-user-status]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should get user status', (done) => {\n\t\t\tsocketUser.checkStatus({ uid: uid }, uid, (err, status) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(status, 'away');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should change user picture', async () => {\n\t\t\tawait apiUser.changePicture({ uid: uid }, { type: 'default', uid: uid });\n\t\t\tconst picture = await User.getUserField(uid, 'picture');\n\t\t\tassert.equal(picture, '');\n\t\t});\n\n\t\tit('should let you set an external image', async () => {\n\t\t\tconst token = await helpers.getCsrfToken(jar);\n\t\t\tconst body = await requestAsync(`${nconf.get('url')}/api/v3/users/${uid}/picture`, {\n\t\t\t\tjar,\n\t\t\t\tmethod: 'put',\n\t\t\t\tjson: true,\n\t\t\t\theaders: {\n\t\t\t\t\t'x-csrf-token': token,\n\t\t\t\t},\n\t\t\t\tbody: {\n\t\t\t\t\ttype: 'external',\n\t\t\t\t\turl: 'https://example.org/picture.jpg',\n\t\t\t\t},\n\t\t\t});\n\n\t\t\tassert(body && body.status && body.response);\n\t\t\tassert.strictEqual(body.status.code, 'ok');\n\n\t\t\tconst picture = await User.getUserField(uid, 'picture');\n\t\t\tassert.strictEqual(picture, validator.escape('https://example.org/picture.jpg'));\n\t\t});\n\n\t\tit('should fail to change user picture with invalid data', async () => {\n\t\t\ttry {\n\t\t\t\tawait apiUser.changePicture({ uid: uid }, null);\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should fail to change user picture with invalid uid', async () => {\n\t\t\ttry {\n\t\t\t\tawait apiUser.changePicture({ uid: 0 }, { uid: 1 });\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should set user picture to uploaded', async () => {\n\t\t\tawait User.setUserField(uid, 'uploadedpicture', '/test');\n\t\t\tawait apiUser.changePicture({ uid: uid }, { type: 'uploaded', uid: uid });\n\t\t\tconst picture = await User.getUserField(uid, 'picture');\n\t\t\tassert.equal(picture, `${nconf.get('relative_path')}/test`);\n\t\t});\n\n\t\tit('should return error if profile image uploads disabled', (done) => {\n\t\t\tmeta.config.allowProfileImageUploads = 0;\n\t\t\tconst picture = {\n\t\t\t\tpath: path.join(nconf.get('base_dir'), 'test/files/test_copy.png'),\n\t\t\t\tsize: 7189,\n\t\t\t\tname: 'test.png',\n\t\t\t\ttype: 'image/png',\n\t\t\t};\n\t\t\tUser.uploadCroppedPicture({\n\t\t\t\tcallerUid: uid,\n\t\t\t\tuid: uid,\n\t\t\t\tfile: picture,\n\t\t\t}, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:profile-image-uploads-disabled]]');\n\t\t\t\tmeta.config.allowProfileImageUploads = 1;\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return error if profile image has no mime type', (done) => {\n\t\t\tUser.uploadCroppedPicture({\n\t\t\t\tcallerUid: uid,\n\t\t\t\tuid: uid,\n\t\t\t\timageData: 'data:image/invalid;base64,R0lGODlhPQBEAPeoAJosM/',\n\t\t\t}, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-image]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tdescribe('user.uploadCroppedPicture', () => {\n\t\t\tconst badImage = 'data:audio/mp3;base64,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';\n\n\t\t\tit('should upload cropped profile picture', async () => {\n\t\t\t\tconst result = await socketUser.uploadCroppedPicture({ uid: uid }, { uid: uid, imageData: goodImage });\n\t\t\t\tassert(result.url);\n\t\t\t\tconst data = await db.getObjectFields(`user:${uid}`, ['uploadedpicture', 'picture']);\n\t\t\t\tassert.strictEqual(result.url, data.uploadedpicture);\n\t\t\t\tassert.strictEqual(result.url, data.picture);\n\t\t\t});\n\n\t\t\tit('should upload cropped profile picture in chunks', async () => {\n\t\t\t\tconst socketUploads = require('../src/socket.io/uploads');\n\t\t\t\tconst socketData = {\n\t\t\t\t\tuid,\n\t\t\t\t\tmethod: 'user.uploadCroppedPicture',\n\t\t\t\t\tsize: goodImage.length,\n\t\t\t\t\tprogress: 0,\n\t\t\t\t};\n\t\t\t\tconst chunkSize = 1000;\n\t\t\t\tlet result;\n\t\t\t\tdo {\n\t\t\t\t\tconst chunk = goodImage.slice(socketData.progress, socketData.progress + chunkSize);\n\t\t\t\t\tsocketData.progress += chunk.length;\n\t\t\t\t\t// eslint-disable-next-line\n\t\t\t\t\tresult = await socketUploads.upload({ uid: uid }, {\n\t\t\t\t\t\tchunk: chunk,\n\t\t\t\t\t\tparams: socketData,\n\t\t\t\t\t});\n\t\t\t\t} while (socketData.progress < socketData.size);\n\n\t\t\t\tassert(result.url);\n\t\t\t\tconst data = await db.getObjectFields(`user:${uid}`, ['uploadedpicture', 'picture']);\n\t\t\t\tassert.strictEqual(result.url, data.uploadedpicture);\n\t\t\t\tassert.strictEqual(result.url, data.picture);\n\t\t\t});\n\n\t\t\tit('should error if both file and imageData are missing', (done) => {\n\t\t\t\tUser.uploadCroppedPicture({}, (err) => {\n\t\t\t\t\tassert.equal('[[error:invalid-data]]', err.message);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should error if file size is too big', (done) => {\n\t\t\t\tconst temp = meta.config.maximumProfileImageSize;\n\t\t\t\tmeta.config.maximumProfileImageSize = 1;\n\t\t\t\tUser.uploadCroppedPicture({\n\t\t\t\t\tcallerUid: uid,\n\t\t\t\t\tuid: 1,\n\t\t\t\t\timageData: goodImage,\n\t\t\t\t}, (err) => {\n\t\t\t\t\tassert.equal('[[error:file-too-big, 1]]', err.message);\n\n\t\t\t\t\t// Restore old value\n\t\t\t\t\tmeta.config.maximumProfileImageSize = temp;\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should not allow image data with bad MIME type to be passed in', (done) => {\n\t\t\t\tUser.uploadCroppedPicture({\n\t\t\t\t\tcallerUid: uid,\n\t\t\t\t\tuid: 1,\n\t\t\t\t\timageData: badImage,\n\t\t\t\t}, (err) => {\n\t\t\t\t\tassert.equal('[[error:invalid-image]]', err.message);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should get profile pictures', (done) => {\n\t\t\t\tsocketUser.getProfilePictures({ uid: uid }, { uid: uid }, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert(data);\n\t\t\t\t\tassert(Array.isArray(data));\n\t\t\t\t\tassert.equal(data[0].type, 'uploaded');\n\t\t\t\t\tassert.equal(data[0].text, '[[user:uploaded_picture]]');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should get default profile avatar', (done) => {\n\t\t\t\tassert.strictEqual(User.getDefaultAvatar(), '');\n\t\t\t\tmeta.config.defaultAvatar = 'https://path/to/default/avatar';\n\t\t\t\tassert.strictEqual(User.getDefaultAvatar(), meta.config.defaultAvatar);\n\t\t\t\tmeta.config.defaultAvatar = '/path/to/default/avatar';\n\t\t\t\tassert.strictEqual(User.getDefaultAvatar(), nconf.get('relative_path') + meta.config.defaultAvatar);\n\t\t\t\tmeta.config.defaultAvatar = '';\n\t\t\t\tdone();\n\t\t\t});\n\n\t\t\tit('should fail to get profile pictures with invalid data', (done) => {\n\t\t\t\tsocketUser.getProfilePictures({ uid: uid }, null, (err) => {\n\t\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\t\tsocketUser.getProfilePictures({ uid: uid }, { uid: null }, (err) => {\n\t\t\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should remove uploaded picture', async () => {\n\t\t\t\tconst avatarPath = await User.getLocalAvatarPath(uid);\n\t\t\t\tassert.notStrictEqual(avatarPath, false);\n\t\t\t\tawait socketUser.removeUploadedPicture({ uid: uid }, { uid: uid });\n\t\t\t\tconst uploadedPicture = await User.getUserField(uid, 'uploadedpicture');\n\t\t\t\tassert.strictEqual(uploadedPicture, '');\n\t\t\t\tassert.strictEqual(fs.existsSync(avatarPath), false);\n\t\t\t});\n\n\t\t\tit('should fail to remove uploaded picture with invalid-data', (done) => {\n\t\t\t\tsocketUser.removeUploadedPicture({ uid: uid }, null, (err) => {\n\t\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\t\tsocketUser.removeUploadedPicture({ uid: uid }, { }, (err) => {\n\t\t\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\t\t\tsocketUser.removeUploadedPicture({ uid: null }, { }, (err) => {\n\t\t\t\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\t\t\t\tdone();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should load profile page', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/updatedagain`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load settings page', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/updatedagain/settings`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body.settings);\n\t\t\t\tassert(body.languages);\n\t\t\t\tassert(body.homePageRoutes);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load edit page', (done) => {\n\t\t\trequest(`${nconf.get('url')}/api/user/updatedagain/edit`, { jar: jar, json: true }, (err, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(res.statusCode, 200);\n\t\t\t\tassert(body);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should load edit/email page', async () => {\n\t\t\tconst res = await requestAsync(`${nconf.get('url')}/api/user/updatedagain/edit/email`, { jar: jar, json: true, resolveWithFullResponse: true });\n\t\t\tassert.strictEqual(res.statusCode, 200);\n\t\t\tassert(res.body);\n\n\t\t\t// Accessing this page will mark the user's account as needing an updated email, below code undo's.\n\t\t\tawait requestAsync({\n\t\t\t\turi: `${nconf.get('url')}/register/abort?_csrf=${csrf_token}`,\n\t\t\t\tjar,\n\t\t\t\tmethod: 'POST',\n\t\t\t\tsimple: false,\n\t\t\t});\n\t\t});\n\n\t\tit('should load user\\'s groups page', async () => {\n\t\t\tawait groups.create({\n\t\t\t\tname: 'Test',\n\t\t\t\tdescription: 'Foobar!',\n\t\t\t});\n\n\t\t\tawait groups.join('Test', uid);\n\t\t\tconst body = await requestAsync(`${nconf.get('url')}/api/user/updatedagain/groups`, { jar: jar, json: true });\n\n\t\t\tassert(Array.isArray(body.groups));\n\t\t\tassert.equal(body.groups[0].name, 'Test');\n\t\t});\n\t});\n\n\tdescribe('user info', () => {\n\t\tlet testUserUid;\n\t\tlet verifiedTestUserUid;\n\n\t\tbefore(async () => {\n\t\t\t// Might be the first user thus a verified one if this test part is ran alone\n\t\t\tverifiedTestUserUid = await User.create({ username: 'bannedUser', password: '123456', email: 'banneduser@example.com' });\n\t\t\tawait User.setUserField(verifiedTestUserUid, 'email:confirmed', 1);\n\t\t\ttestUserUid = await User.create({ username: 'bannedUser2', password: '123456', email: 'banneduser2@example.com' });\n\t\t});\n\n\t\tit('should return error if there is no ban reason', (done) => {\n\t\t\tUser.getLatestBanInfo(123, (err) => {\n\t\t\t\tassert.equal(err.message, 'no-ban-info');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should get history from set', async () => {\n\t\t\tconst now = Date.now();\n\t\t\tawait db.sortedSetAdd(`user:${testUserUid}:usernames`, now, `derp:${now}`);\n\t\t\tconst data = await User.getHistory(`user:${testUserUid}:usernames`);\n\t\t\tassert.equal(data[0].value, 'derp');\n\t\t\tassert.equal(data[0].timestamp, now);\n\t\t});\n\n\t\tit('should return the correct ban reason', (done) => {\n\t\t\tasync.series([\n\t\t\t\tfunction (next) {\n\t\t\t\t\tUser.bans.ban(testUserUid, 0, '', (err) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tnext(err);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\tUser.getModerationHistory(testUserUid, (err, data) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(data.bans.length, 1, 'one ban');\n\t\t\t\t\t\tassert.equal(data.bans[0].reason, '[[user:info.banned-no-reason]]', 'no ban reason');\n\n\t\t\t\t\t\tnext(err);\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t], (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tUser.bans.unban(testUserUid, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should ban user permanently', (done) => {\n\t\t\tUser.bans.ban(testUserUid, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tUser.bans.isBanned(testUserUid, (err, isBanned) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(isBanned, true);\n\t\t\t\t\tUser.bans.unban(testUserUid, done);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should ban user temporarily', (done) => {\n\t\t\tUser.bans.ban(testUserUid, Date.now() + 2000, (err) => {\n\t\t\t\tassert.ifError(err);\n\n\t\t\t\tUser.bans.isBanned(testUserUid, (err, isBanned) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(isBanned, true);\n\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\tUser.bans.isBanned(testUserUid, (err, isBanned) => {\n\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\tassert.equal(isBanned, false);\n\t\t\t\t\t\t\tUser.bans.unban(testUserUid, done);\n\t\t\t\t\t\t});\n\t\t\t\t\t}, 3000);\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should error if until is NaN', (done) => {\n\t\t\tUser.bans.ban(testUserUid, 'asd', (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:ban-expiry-missing]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should be member of \"banned-users\" system group only after a ban', async () => {\n\t\t\tawait User.bans.ban(testUserUid);\n\n\t\t\tconst systemGroups = groups.systemGroups.filter(group => group !== groups.BANNED_USERS);\n\t\t\tconst isMember = await groups.isMember(testUserUid, groups.BANNED_USERS);\n\t\t\tconst isMemberOfAny = await groups.isMemberOfAny(testUserUid, systemGroups);\n\n\t\t\tassert.strictEqual(isMember, true);\n\t\t\tassert.strictEqual(isMemberOfAny, false);\n\t\t});\n\n\t\tit('should restore system group memberships after an unban (for an unverified user)', async () => {\n\t\t\tawait User.bans.unban(testUserUid);\n\n\t\t\tconst isMemberOfGroups = await groups.isMemberOfGroups(testUserUid, groups.systemGroups);\n\t\t\tconst membership = new Map(groups.systemGroups.map((item, index) => [item, isMemberOfGroups[index]]));\n\n\t\t\tassert.strictEqual(membership.get('registered-users'), true);\n\t\t\tassert.strictEqual(membership.get('verified-users'), false);\n\t\t\tassert.strictEqual(membership.get('unverified-users'), true);\n\t\t\tassert.strictEqual(membership.get(groups.BANNED_USERS), false);\n\t\t\t// administrators cannot be banned\n\t\t\tassert.strictEqual(membership.get('administrators'), false);\n\t\t\t// This will not restored\n\t\t\tassert.strictEqual(membership.get('Global Moderators'), false);\n\t\t});\n\n\t\tit('should restore system group memberships after an unban (for a verified user)', async () => {\n\t\t\tawait User.bans.ban(verifiedTestUserUid);\n\t\t\tawait User.bans.unban(verifiedTestUserUid);\n\n\t\t\tconst isMemberOfGroups = await groups.isMemberOfGroups(verifiedTestUserUid, groups.systemGroups);\n\t\t\tconst membership = new Map(groups.systemGroups.map((item, index) => [item, isMemberOfGroups[index]]));\n\n\t\t\tassert.strictEqual(membership.get('verified-users'), true);\n\t\t\tassert.strictEqual(membership.get('unverified-users'), false);\n\t\t});\n\t});\n\n\tdescribe('Digest.getSubscribers', () => {\n\t\tconst uidIndex = {};\n\n\t\tbefore((done) => {\n\t\t\tconst testUsers = ['daysub', 'offsub', 'nullsub', 'weeksub'];\n\t\t\tasync.each(testUsers, (username, next) => {\n\t\t\t\tasync.waterfall([\n\t\t\t\t\tasync.apply(User.create, { username: username, email: `${username}@example.com` }),\n\t\t\t\t\tfunction (uid, next) {\n\t\t\t\t\t\tif (username === 'nullsub') {\n\t\t\t\t\t\t\treturn setImmediate(next);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tuidIndex[username] = uid;\n\n\t\t\t\t\t\tconst sub = username.slice(0, -3);\n\t\t\t\t\t\tasync.parallel([\n\t\t\t\t\t\t\tasync.apply(User.updateDigestSetting, uid, sub),\n\t\t\t\t\t\t\tasync.apply(User.setSetting, uid, 'dailyDigestFreq', sub),\n\t\t\t\t\t\t], next);\n\t\t\t\t\t},\n\t\t\t\t], next);\n\t\t\t}, done);\n\t\t});\n\n\t\tit('should accurately build digest list given ACP default \"null\" (not set)', (done) => {\n\t\t\tUser.digest.getSubscribers('day', (err, subs) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.strictEqual(subs.length, 1);\n\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should accurately build digest list given ACP default \"day\"', (done) => {\n\t\t\tasync.series([\n\t\t\t\tasync.apply(meta.configs.set, 'dailyDigestFreq', 'day'),\n\t\t\t\tfunction (next) {\n\t\t\t\t\tUser.digest.getSubscribers('day', (err, subs) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.strictEqual(subs.includes(uidIndex.daysub.toString()), true); // daysub does get emailed\n\t\t\t\t\t\tassert.strictEqual(subs.includes(uidIndex.weeksub.toString()), false); // weeksub does not get emailed\n\t\t\t\t\t\tassert.strictEqual(subs.includes(uidIndex.offsub.toString()), false); // offsub doesn't get emailed\n\n\t\t\t\t\t\tnext();\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should accurately build digest list given ACP default \"week\"', (done) => {\n\t\t\tasync.series([\n\t\t\t\tasync.apply(meta.configs.set, 'dailyDigestFreq', 'week'),\n\t\t\t\tfunction (next) {\n\t\t\t\t\tUser.digest.getSubscribers('week', (err, subs) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.strictEqual(subs.includes(uidIndex.weeksub.toString()), true); // weeksub gets emailed\n\t\t\t\t\t\tassert.strictEqual(subs.includes(uidIndex.daysub.toString()), false); // daysub gets emailed\n\t\t\t\t\t\tassert.strictEqual(subs.includes(uidIndex.offsub.toString()), false); // offsub does not get emailed\n\n\t\t\t\t\t\tnext();\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should accurately build digest list given ACP default \"off\"', (done) => {\n\t\t\tasync.series([\n\t\t\t\tasync.apply(meta.configs.set, 'dailyDigestFreq', 'off'),\n\t\t\t\tfunction (next) {\n\t\t\t\t\tUser.digest.getSubscribers('day', (err, subs) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.strictEqual(subs.length, 1);\n\n\t\t\t\t\t\tnext();\n\t\t\t\t\t});\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\t});\n\n\tdescribe('digests', () => {\n\t\tlet uid;\n\t\tbefore((done) => {\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\tUser.create({ username: 'digestuser', email: 'test@example.com' }, next);\n\t\t\t\t},\n\t\t\t\tfunction (_uid, next) {\n\t\t\t\t\tuid = _uid;\n\t\t\t\t\tUser.updateDigestSetting(uid, 'day', next);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\tUser.setSetting(uid, 'dailyDigestFreq', 'day', next);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\tUser.setSetting(uid, 'notificationType_test', 'notificationemail', next);\n\t\t\t\t},\n\t\t\t], done);\n\t\t});\n\n\t\tit('should send digests', (done) => {\n\t\t\tconst oldValue = meta.config.includeUnverifiedEmails;\n\t\t\tmeta.config.includeUnverifiedEmails = true;\n\t\t\tUser.digest.execute({ interval: 'day' }, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tmeta.config.includeUnverifiedEmails = oldValue;\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should not send digests', (done) => {\n\t\t\tUser.digest.execute({ interval: 'month' }, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should get delivery times', async () => {\n\t\t\tconst data = await User.digest.getDeliveryTimes(0, -1);\n\t\t\tconst users = data.users.filter(u => u.username === 'digestuser');\n\t\t\tassert.strictEqual(users[0].setting, 'day');\n\t\t});\n\n\t\tdescribe('unsubscribe via POST', () => {\n\t\t\tit('should unsubscribe from digest if one-click unsubscribe is POSTed', (done) => {\n\t\t\t\tconst token = jwt.sign({\n\t\t\t\t\ttemplate: 'digest',\n\t\t\t\t\tuid: uid,\n\t\t\t\t}, nconf.get('secret'));\n\n\t\t\t\trequest({\n\t\t\t\t\tmethod: 'post',\n\t\t\t\t\turl: `${nconf.get('url')}/email/unsubscribe/${token}`,\n\t\t\t\t}, (err, res) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(res.statusCode, 200);\n\n\t\t\t\t\tdb.getObjectField(`user:${uid}:settings`, 'dailyDigestFreq', (err, value) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.strictEqual(value, 'off');\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should unsubscribe from notifications if one-click unsubscribe is POSTed', (done) => {\n\t\t\t\tconst token = jwt.sign({\n\t\t\t\t\ttemplate: 'notification',\n\t\t\t\t\ttype: 'test',\n\t\t\t\t\tuid: uid,\n\t\t\t\t}, nconf.get('secret'));\n\n\t\t\t\trequest({\n\t\t\t\t\tmethod: 'post',\n\t\t\t\t\turl: `${nconf.get('url')}/email/unsubscribe/${token}`,\n\t\t\t\t}, (err, res) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(res.statusCode, 200);\n\n\t\t\t\t\tdb.getObjectField(`user:${uid}:settings`, 'notificationType_test', (err, value) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.strictEqual(value, 'notification');\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should return errors on missing template in token', (done) => {\n\t\t\t\tconst token = jwt.sign({\n\t\t\t\t\tuid: uid,\n\t\t\t\t}, nconf.get('secret'));\n\n\t\t\t\trequest({\n\t\t\t\t\tmethod: 'post',\n\t\t\t\t\turl: `${nconf.get('url')}/email/unsubscribe/${token}`,\n\t\t\t\t}, (err, res) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(res.statusCode, 404);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should return errors on wrong template in token', (done) => {\n\t\t\t\tconst token = jwt.sign({\n\t\t\t\t\ttemplate: 'user',\n\t\t\t\t\tuid: uid,\n\t\t\t\t}, nconf.get('secret'));\n\n\t\t\t\trequest({\n\t\t\t\t\tmethod: 'post',\n\t\t\t\t\turl: `${nconf.get('url')}/email/unsubscribe/${token}`,\n\t\t\t\t}, (err, res) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(res.statusCode, 404);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should return errors on missing token', (done) => {\n\t\t\t\trequest({\n\t\t\t\t\tmethod: 'post',\n\t\t\t\t\turl: `${nconf.get('url')}/email/unsubscribe/`,\n\t\t\t\t}, (err, res) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(res.statusCode, 404);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should return errors on token signed with wrong secret (verify-failure)', (done) => {\n\t\t\t\tconst token = jwt.sign({\n\t\t\t\t\ttemplate: 'notification',\n\t\t\t\t\ttype: 'test',\n\t\t\t\t\tuid: uid,\n\t\t\t\t}, `${nconf.get('secret')}aababacaba`);\n\n\t\t\t\trequest({\n\t\t\t\t\tmethod: 'post',\n\t\t\t\t\turl: `${nconf.get('url')}/email/unsubscribe/${token}`,\n\t\t\t\t}, (err, res) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(res.statusCode, 403);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('socket methods', () => {\n\t\tconst socketUser = require('../src/socket.io/user');\n\t\tlet delUid;\n\n\t\tit('should fail with invalid data', (done) => {\n\t\t\tmeta.userOrGroupExists(null, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return true if user/group exists', (done) => {\n\t\t\tmeta.userOrGroupExists('registered-users', (err, exists) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(exists);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return true if user/group exists', (done) => {\n\t\t\tmeta.userOrGroupExists('John Smith', (err, exists) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(exists);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return false if user/group does not exists', (done) => {\n\t\t\tmeta.userOrGroupExists('doesnot exist', (err, exists) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert(!exists);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should delete user', async () => {\n\t\t\tdelUid = await User.create({ username: 'willbedeleted' });\n\n\t\t\t// Upload some avatars and covers before deleting\n\t\t\tmeta.config['profile:keepAllUserImages'] = 1;\n\t\t\tlet result = await socketUser.uploadCroppedPicture({ uid: delUid }, { uid: delUid, imageData: goodImage });\n\t\t\tassert(result.url);\n\t\t\tresult = await socketUser.uploadCroppedPicture({ uid: delUid }, { uid: delUid, imageData: goodImage });\n\t\t\tassert(result.url);\n\n\t\t\tconst position = '50.0301% 19.2464%';\n\t\t\tresult = await socketUser.updateCover({ uid: delUid }, { uid: delUid, imageData: goodImage, position: position });\n\t\t\tassert(result.url);\n\t\t\tresult = await socketUser.updateCover({ uid: delUid }, { uid: delUid, imageData: goodImage, position: position });\n\t\t\tassert(result.url);\n\t\t\tmeta.config['profile:keepAllUserImages'] = 0;\n\n\t\t\tawait apiUser.deleteAccount({ uid: delUid }, { uid: delUid });\n\t\t\tconst exists = await meta.userOrGroupExists('willbedeleted');\n\t\t\tassert(!exists);\n\t\t});\n\n\t\tit('should clean profile images after account deletion', () => {\n\t\t\tconst allProfileFiles = fs.readdirSync(path.join(nconf.get('upload_path'), 'profile'));\n\t\t\tconst deletedUserImages = allProfileFiles.filter(\n\t\t\t\tf => f.startsWith(`${delUid}-profilecover`) || f.startsWith(`${delUid}-profileavatar`)\n\t\t\t);\n\t\t\tassert.strictEqual(deletedUserImages.length, 0);\n\t\t});\n\n\t\tit('should fail to delete user with wrong password', async () => {\n\t\t\tconst uid = await User.create({ username: 'willbedeletedpwd', password: '123456' });\n\t\t\ttry {\n\t\t\t\tawait apiUser.deleteAccount({ uid: uid }, { uid: uid, password: '654321' });\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.strictEqual(err.message, '[[error:invalid-password]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should delete user with correct password', async () => {\n\t\t\tconst uid = await User.create({ username: 'willbedeletedcorrectpwd', password: '123456' });\n\t\t\tawait apiUser.deleteAccount({ uid: uid }, { uid: uid, password: '123456' });\n\t\t\tconst exists = await User.exists(uid);\n\t\t\tassert(!exists);\n\t\t});\n\n\t\tit('should fail to delete user if account deletion is not allowed', async () => {\n\t\t\tconst oldValue = meta.config.allowAccountDelete;\n\t\t\tmeta.config.allowAccountDelete = 0;\n\t\t\tconst uid = await User.create({ username: 'tobedeleted' });\n\t\t\ttry {\n\t\t\t\tawait apiUser.deleteAccount({ uid: uid }, { uid: uid });\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.strictEqual(err.message, '[[error:account-deletion-disabled]]');\n\t\t\t}\n\t\t\tmeta.config.allowAccountDelete = oldValue;\n\t\t});\n\n\t\tit('should send reset email', (done) => {\n\t\t\tsocketUser.reset.send({ uid: 0 }, 'john@example.com', (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should return invalid-data error', (done) => {\n\t\t\tsocketUser.reset.send({ uid: 0 }, null, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should not error', (done) => {\n\t\t\tsocketUser.reset.send({ uid: 0 }, 'doestnot@exist.com', (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should commit reset', (done) => {\n\t\t\tdb.getObject('reset:uid', (err, data) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tconst code = Object.keys(data).find(code => parseInt(data[code], 10) === parseInt(testUid, 10));\n\t\t\t\tsocketUser.reset.commit({ uid: 0 }, { code: code, password: 'pwdchange' }, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should save user settings', async () => {\n\t\t\tconst data = {\n\t\t\t\tuid: testUid,\n\t\t\t\tsettings: {\n\t\t\t\t\tbootswatchSkin: 'default',\n\t\t\t\t\thomePageRoute: 'none',\n\t\t\t\t\thomePageCustom: '',\n\t\t\t\t\topenOutgoingLinksInNewTab: 0,\n\t\t\t\t\tscrollToMyPost: 1,\n\t\t\t\t\tuserLang: 'en-GB',\n\t\t\t\t\tusePagination: 1,\n\t\t\t\t\ttopicsPerPage: '10',\n\t\t\t\t\tpostsPerPage: '5',\n\t\t\t\t\tshowemail: 1,\n\t\t\t\t\tshowfullname: 1,\n\t\t\t\t\trestrictChat: 0,\n\t\t\t\t\tfollowTopicsOnCreate: 1,\n\t\t\t\t\tfollowTopicsOnReply: 1,\n\t\t\t\t},\n\t\t\t};\n\t\t\tawait apiUser.updateSettings({ uid: testUid }, data);\n\t\t\tconst userSettings = await User.getSettings(testUid);\n\t\t\tassert.strictEqual(userSettings.usePagination, true);\n\t\t});\n\n\t\tit('should properly escape homePageRoute', async () => {\n\t\t\tconst data = {\n\t\t\t\tuid: testUid,\n\t\t\t\tsettings: {\n\t\t\t\t\tbootswatchSkin: 'default',\n\t\t\t\t\thomePageRoute: 'category/6/testing-ground',\n\t\t\t\t\thomePageCustom: '',\n\t\t\t\t\topenOutgoingLinksInNewTab: 0,\n\t\t\t\t\tscrollToMyPost: 1,\n\t\t\t\t\tuserLang: 'en-GB',\n\t\t\t\t\tusePagination: 1,\n\t\t\t\t\ttopicsPerPage: '10',\n\t\t\t\t\tpostsPerPage: '5',\n\t\t\t\t\tshowemail: 1,\n\t\t\t\t\tshowfullname: 1,\n\t\t\t\t\trestrictChat: 0,\n\t\t\t\t\tfollowTopicsOnCreate: 1,\n\t\t\t\t\tfollowTopicsOnReply: 1,\n\t\t\t\t},\n\t\t\t};\n\t\t\tawait apiUser.updateSettings({ uid: testUid }, data);\n\t\t\tconst userSettings = await User.getSettings(testUid);\n\t\t\tassert.strictEqual(userSettings.homePageRoute, 'category/6/testing-ground');\n\t\t});\n\n\n\t\tit('should error if language is invalid', async () => {\n\t\t\tconst data = {\n\t\t\t\tuid: testUid,\n\t\t\t\tsettings: {\n\t\t\t\t\tuserLang: '<invalid-string>',\n\t\t\t\t\ttopicsPerPage: '10',\n\t\t\t\t\tpostsPerPage: '5',\n\t\t\t\t},\n\t\t\t};\n\t\t\ttry {\n\t\t\t\tawait apiUser.updateSettings({ uid: testUid }, data);\n\t\t\t\tassert(false);\n\t\t\t} catch (err) {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-language]]');\n\t\t\t}\n\t\t});\n\n\t\tit('should set moderation note', (done) => {\n\t\t\tlet adminUid;\n\t\t\tasync.waterfall([\n\t\t\t\tfunction (next) {\n\t\t\t\t\tUser.create({ username: 'noteadmin' }, next);\n\t\t\t\t},\n\t\t\t\tfunction (_adminUid, next) {\n\t\t\t\t\tadminUid = _adminUid;\n\t\t\t\t\tgroups.join('administrators', adminUid, next);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\tsocketUser.setModerationNote({ uid: adminUid }, { uid: testUid, note: 'this is a test user' }, next);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\tsetTimeout(next, 50);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\tsocketUser.setModerationNote({ uid: adminUid }, { uid: testUid, note: '<svg/onload=alert(document.location);//' }, next);\n\t\t\t\t},\n\t\t\t\tfunction (next) {\n\t\t\t\t\tUser.getModerationNotes(testUid, 0, -1, next);\n\t\t\t\t},\n\t\t\t], (err, notes) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(notes[0].note, '&lt;svg&#x2F;onload=alert(document.location);&#x2F;&#x2F;');\n\t\t\t\tassert.equal(notes[0].uid, adminUid);\n\t\t\t\tassert.equal(notes[1].note, 'this is a test user');\n\t\t\t\tassert(notes[0].timestamp);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should get unread count 0 for guest', async () => {\n\t\t\tconst count = await socketUser.getUnreadCount({ uid: 0 });\n\t\t\tassert.strictEqual(count, 0);\n\t\t});\n\n\t\tit('should get unread count for user', async () => {\n\t\t\tconst count = await socketUser.getUnreadCount({ uid: testUid });\n\t\t\tassert.strictEqual(count, 2);\n\t\t});\n\n\t\tit('should get unread chat count 0 for guest', async () => {\n\t\t\tconst count = await socketUser.getUnreadChatCount({ uid: 0 });\n\t\t\tassert.strictEqual(count, 0);\n\t\t});\n\n\t\tit('should get unread chat count for user', async () => {\n\t\t\tconst count = await socketUser.getUnreadChatCount({ uid: testUid });\n\t\t\tassert.strictEqual(count, 0);\n\t\t});\n\n\t\tit('should get unread counts 0 for guest', async () => {\n\t\t\tconst counts = await socketUser.getUnreadCounts({ uid: 0 });\n\t\t\tassert.deepStrictEqual(counts, {});\n\t\t});\n\n\t\tit('should get unread counts for user', async () => {\n\t\t\tconst counts = await socketUser.getUnreadCounts({ uid: testUid });\n\t\t\tassert.deepStrictEqual(counts, {\n\t\t\t\tunreadChatCount: 0,\n\t\t\t\tunreadCounts: {\n\t\t\t\t\t'': 2,\n\t\t\t\t\tnew: 2,\n\t\t\t\t\tunreplied: 2,\n\t\t\t\t\twatched: 0,\n\t\t\t\t},\n\t\t\t\tunreadNewTopicCount: 2,\n\t\t\t\tunreadNotificationCount: 0,\n\t\t\t\tunreadTopicCount: 2,\n\t\t\t\tunreadUnrepliedTopicCount: 2,\n\t\t\t\tunreadWatchedTopicCount: 0,\n\t\t\t});\n\t\t});\n\n\t\tit('should get user data by uid', async () => {\n\t\t\tconst userData = await socketUser.getUserByUID({ uid: testUid }, testUid);\n\t\t\tassert.strictEqual(userData.uid, testUid);\n\t\t});\n\n\t\tit('should get user data by username', async () => {\n\t\t\tconst userData = await socketUser.getUserByUsername({ uid: testUid }, 'John Smith');\n\t\t\tassert.strictEqual(userData.uid, testUid);\n\t\t});\n\n\t\tit('should get user data by email', async () => {\n\t\t\tconst userData = await socketUser.getUserByEmail({ uid: testUid }, 'john@example.com');\n\t\t\tassert.strictEqual(userData.uid, testUid);\n\t\t});\n\n\t\tit('should check/consent gdpr status', async () => {\n\t\t\tconst consent = await socketUser.gdpr.check({ uid: testUid }, { uid: testUid });\n\t\t\tassert(!consent);\n\t\t\tawait socketUser.gdpr.consent({ uid: testUid });\n\t\t\tconst consentAfter = await socketUser.gdpr.check({ uid: testUid }, { uid: testUid });\n\t\t\tassert(consentAfter);\n\t\t});\n\t});\n\n\tdescribe('approval queue', () => {\n\t\tlet oldRegistrationApprovalType;\n\t\tlet adminUid;\n\t\tbefore((done) => {\n\t\t\toldRegistrationApprovalType = meta.config.registrationApprovalType;\n\t\t\tmeta.config.registrationApprovalType = 'admin-approval';\n\t\t\tUser.create({ username: 'admin', password: '123456' }, (err, uid) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tadminUid = uid;\n\t\t\t\tgroups.join('administrators', uid, done);\n\t\t\t});\n\t\t});\n\n\t\tafter((done) => {\n\t\t\tmeta.config.registrationApprovalType = oldRegistrationApprovalType;\n\t\t\tdone();\n\t\t});\n\n\t\tit('should add user to approval queue', (done) => {\n\t\t\thelpers.registerUser({\n\t\t\t\tusername: 'rejectme',\n\t\t\t\tpassword: '123456',\n\t\t\t\t'password-confirm': '123456',\n\t\t\t\temail: '<script>alert(\"ok\")<script>reject@me.com',\n\t\t\t\tgdpr_consent: true,\n\t\t\t}, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\thelpers.loginUser('admin', '123456', (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\trequest(`${nconf.get('url')}/api/admin/manage/registration`, { jar: data.jar, json: true }, (err, res, body) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(body.users[0].username, 'rejectme');\n\t\t\t\t\t\tassert.equal(body.users[0].email, '&lt;script&gt;alert(&quot;ok&quot;)&lt;script&gt;reject@me.com');\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should fail to add user to queue if username is taken', (done) => {\n\t\t\thelpers.registerUser({\n\t\t\t\tusername: 'rejectme',\n\t\t\t\tpassword: '123456',\n\t\t\t\t'password-confirm': '123456',\n\t\t\t\temail: '<script>alert(\"ok\")<script>reject@me.com',\n\t\t\t\tgdpr_consent: true,\n\t\t\t}, (err, jar, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(body, '[[error:username-taken]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should fail to add user to queue if email is taken', (done) => {\n\t\t\thelpers.registerUser({\n\t\t\t\tusername: 'rejectmenew',\n\t\t\t\tpassword: '123456',\n\t\t\t\t'password-confirm': '123456',\n\t\t\t\temail: '<script>alert(\"ok\")<script>reject@me.com',\n\t\t\t\tgdpr_consent: true,\n\t\t\t}, (err, jar, res, body) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tassert.equal(body, '[[error:email-taken]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should reject user registration', (done) => {\n\t\t\tsocketUser.rejectRegistration({ uid: adminUid }, { username: 'rejectme' }, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tUser.getRegistrationQueue(0, -1, (err, users) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(users.length, 0);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should accept user registration', (done) => {\n\t\t\thelpers.registerUser({\n\t\t\t\tusername: 'acceptme',\n\t\t\t\tpassword: '123456',\n\t\t\t\t'password-confirm': '123456',\n\t\t\t\temail: 'accept@me.com',\n\t\t\t\tgdpr_consent: true,\n\t\t\t}, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tsocketUser.acceptRegistration({ uid: adminUid }, { username: 'acceptme' }, (err, uid) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tUser.exists(uid, (err, exists) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert(exists);\n\t\t\t\t\t\tUser.getRegistrationQueue(0, -1, (err, users) => {\n\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\tassert.equal(users.length, 0);\n\t\t\t\t\t\t\tdone();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should trim username and add user to registration queue', (done) => {\n\t\t\thelpers.registerUser({\n\t\t\t\tusername: 'invalidname\\r\\n',\n\t\t\t\tpassword: '123456',\n\t\t\t\t'password-confirm': '123456',\n\t\t\t\temail: 'invalidtest@test.com',\n\t\t\t\tgdpr_consent: true,\n\t\t\t}, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tdb.getSortedSetRange('registration:queue', 0, -1, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.equal(data[0], 'invalidname');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('invites', () => {\n\t\tlet notAnInviterUid;\n\t\tlet inviterUid;\n\t\tlet adminUid;\n\n\t\tconst PUBLIC_GROUP = 'publicGroup';\n\t\tconst PRIVATE_GROUP = 'privateGroup';\n\t\tconst OWN_PRIVATE_GROUP = 'ownPrivateGroup';\n\t\tconst HIDDEN_GROUP = 'hiddenGroup';\n\n\t\tconst COMMON_PW = '123456';\n\n\t\tbefore(async () => {\n\t\t\tconst results = await utils.promiseParallel({\n\t\t\t\tpublicGroup: groups.create({ name: PUBLIC_GROUP, private: 0 }),\n\t\t\t\tprivateGroup: groups.create({ name: PRIVATE_GROUP, private: 1 }),\n\t\t\t\thiddenGroup: groups.create({ name: HIDDEN_GROUP, hidden: 1 }),\n\t\t\t\tnotAnInviter: User.create({ username: 'notAnInviter', password: COMMON_PW }),\n\t\t\t\tinviter: User.create({ username: 'inviter', password: COMMON_PW }),\n\t\t\t\tadmin: User.create({ username: 'adminInvite', password: COMMON_PW }),\n\t\t\t});\n\n\t\t\tnotAnInviterUid = results.notAnInviter;\n\t\t\tinviterUid = results.inviter;\n\t\t\tadminUid = results.admin;\n\n\t\t\tawait User.setUserField(inviterUid, 'email', 'inviter@nodebb.org');\n\t\t\tawait Promise.all([\n\t\t\t\tgroups.create({ name: OWN_PRIVATE_GROUP, ownerUid: inviterUid, private: 1 }),\n\t\t\t\tgroups.join('administrators', adminUid),\n\t\t\t\tgroups.join('cid:0:privileges:invite', inviterUid),\n\t\t\t\tUser.email.confirmByUid(inviterUid),\n\t\t\t]);\n\t\t});\n\n\t\tdescribe('when inviter is not an admin and does not have invite privilege', () => {\n\t\t\tlet csrf_token;\n\t\t\tlet jar;\n\n\t\t\tbefore((done) => {\n\t\t\t\thelpers.loginUser('notAnInviter', COMMON_PW, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tjar = data.jar;\n\n\t\t\t\t\trequest({\n\t\t\t\t\t\turl: `${nconf.get('url')}/api/config`,\n\t\t\t\t\t\tjson: true,\n\t\t\t\t\t\tjar: jar,\n\t\t\t\t\t}, (err, response, body) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tcsrf_token = body.csrf_token;\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should error if user does not have invite privilege', async () => {\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'invite1@test.com', groupsToJoin: [] }, notAnInviterUid, jar, csrf_token);\n\t\t\t\tassert.strictEqual(res.statusCode, 403);\n\t\t\t\tassert.strictEqual(res.body.status.message, 'You do not have enough privileges for this action.');\n\t\t\t});\n\n\t\t\tit('should error out if user tries to use an inviter\\'s uid via the API', async () => {\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'invite1@test.com', groupsToJoin: [] }, inviterUid, jar, csrf_token);\n\t\t\t\tconst numInvites = await User.getInvitesNumber(inviterUid);\n\t\t\t\tassert.strictEqual(res.statusCode, 403);\n\t\t\t\tassert.strictEqual(res.body.status.message, 'You do not have enough privileges for this action.');\n\t\t\t\tassert.strictEqual(numInvites, 0);\n\t\t\t});\n\t\t});\n\n\t\tdescribe('when inviter has invite privilege', () => {\n\t\t\tlet csrf_token;\n\t\t\tlet jar;\n\n\t\t\tbefore((done) => {\n\t\t\t\thelpers.loginUser('inviter', COMMON_PW, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tjar = data.jar;\n\n\t\t\t\t\trequest({\n\t\t\t\t\t\turl: `${nconf.get('url')}/api/config`,\n\t\t\t\t\t\tjson: true,\n\t\t\t\t\t\tjar: jar,\n\t\t\t\t\t}, (err, response, body) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tcsrf_token = body.csrf_token;\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should error with invalid data', async () => {\n\t\t\t\tconst { res } = await helpers.invite({}, inviterUid, jar, csrf_token);\n\t\t\t\tassert.strictEqual(res.statusCode, 400);\n\t\t\t\tassert.strictEqual(res.body.status.message, 'Invalid Data');\n\t\t\t});\n\n\t\t\tit('should error if user is not admin and type is admin-invite-only', async () => {\n\t\t\t\tmeta.config.registrationType = 'admin-invite-only';\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'invite1@test.com', groupsToJoin: [] }, inviterUid, jar, csrf_token);\n\t\t\t\tassert.strictEqual(res.statusCode, 403);\n\t\t\t\tassert.strictEqual(res.body.status.message, 'You do not have enough privileges for this action.');\n\t\t\t});\n\n\t\t\tit('should send invitation email (without groups to be joined)', async () => {\n\t\t\t\tmeta.config.registrationType = 'normal';\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'invite1@test.com', groupsToJoin: [] }, inviterUid, jar, csrf_token);\n\t\t\t\tassert.strictEqual(res.statusCode, 200);\n\t\t\t});\n\n\t\t\tit('should send multiple invitation emails (with a public group to be joined)', async () => {\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'invite2@test.com,invite3@test.com', groupsToJoin: [PUBLIC_GROUP] }, inviterUid, jar, csrf_token);\n\t\t\t\tassert.strictEqual(res.statusCode, 200);\n\t\t\t});\n\n\t\t\tit('should error if the user has not permission to invite to the group', async () => {\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'invite4@test.com', groupsToJoin: [PRIVATE_GROUP] }, inviterUid, jar, csrf_token);\n\t\t\t\tassert.strictEqual(res.statusCode, 403);\n\t\t\t\tassert.strictEqual(res.body.status.message, 'You do not have enough privileges for this action.');\n\t\t\t});\n\n\t\t\tit('should error if a non-admin tries to invite to the administrators group', async () => {\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'invite4@test.com', groupsToJoin: ['administrators'] }, inviterUid, jar, csrf_token);\n\t\t\t\tassert.strictEqual(res.statusCode, 403);\n\t\t\t\tassert.strictEqual(res.body.status.message, 'You do not have enough privileges for this action.');\n\t\t\t});\n\n\t\t\tit('should to invite to own private group', async () => {\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'invite4@test.com', groupsToJoin: [OWN_PRIVATE_GROUP] }, inviterUid, jar, csrf_token);\n\t\t\t\tassert.strictEqual(res.statusCode, 200);\n\t\t\t});\n\n\t\t\tit('should to invite to multiple groups', async () => {\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'invite5@test.com', groupsToJoin: [PUBLIC_GROUP, OWN_PRIVATE_GROUP] }, inviterUid, jar, csrf_token);\n\t\t\t\tassert.strictEqual(res.statusCode, 200);\n\t\t\t});\n\n\t\t\tit('should error if tries to invite to hidden group', async () => {\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'invite6@test.com', groupsToJoin: [HIDDEN_GROUP] }, inviterUid, jar, csrf_token);\n\t\t\t\tassert.strictEqual(res.statusCode, 403);\n\t\t\t});\n\n\t\t\tit('should error if ouf of invitations', async () => {\n\t\t\t\tmeta.config.maximumInvites = 1;\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'invite6@test.com', groupsToJoin: [] }, inviterUid, jar, csrf_token);\n\t\t\t\tassert.strictEqual(res.statusCode, 403);\n\t\t\t\tassert.strictEqual(res.body.status.message, `You have invited the maximum amount of people (${5} out of ${1}).`);\n\t\t\t\tmeta.config.maximumInvites = 10;\n\t\t\t});\n\n\t\t\tit('should send invitation email after maximumInvites increased', async () => {\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'invite6@test.com', groupsToJoin: [] }, inviterUid, jar, csrf_token);\n\t\t\t\tassert.strictEqual(res.statusCode, 200);\n\t\t\t});\n\n\t\t\tit('should error if invite is sent via API with a different UID', async () => {\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'inviter@nodebb.org', groupsToJoin: [] }, adminUid, jar, csrf_token);\n\t\t\t\tconst numInvites = await User.getInvitesNumber(adminUid);\n\t\t\t\tassert.strictEqual(res.statusCode, 403);\n\t\t\t\tassert.strictEqual(res.body.status.message, 'You do not have enough privileges for this action.');\n\t\t\t\tassert.strictEqual(numInvites, 0);\n\t\t\t});\n\n\t\t\tit('should succeed if email exists but not actually send an invite', async () => {\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'inviter@nodebb.org', groupsToJoin: [] }, inviterUid, jar, csrf_token);\n\t\t\t\tconst numInvites = await User.getInvitesNumber(adminUid);\n\n\t\t\t\tassert.strictEqual(res.statusCode, 200);\n\t\t\t\tassert.strictEqual(numInvites, 0);\n\t\t\t});\n\t\t});\n\n\t\tdescribe('when inviter is an admin', () => {\n\t\t\tlet csrf_token;\n\t\t\tlet jar;\n\n\t\t\tbefore((done) => {\n\t\t\t\thelpers.loginUser('adminInvite', COMMON_PW, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tjar = data.jar;\n\n\t\t\t\t\trequest({\n\t\t\t\t\t\turl: `${nconf.get('url')}/api/config`,\n\t\t\t\t\t\tjson: true,\n\t\t\t\t\t\tjar: jar,\n\t\t\t\t\t}, (err, response, body) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tcsrf_token = body.csrf_token;\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should escape email', async () => {\n\t\t\t\tawait helpers.invite({ emails: '<script>alert(\"ok\");</script>', groupsToJoin: [] }, adminUid, jar, csrf_token);\n\t\t\t\tconst data = await User.getInvites(adminUid);\n\t\t\t\tassert.strictEqual(data[0], '&lt;script&gt;alert(&quot;ok&quot;);&lt;&#x2F;script&gt;');\n\t\t\t\tawait User.deleteInvitationKey('<script>alert(\"ok\");</script>');\n\t\t\t});\n\n\t\t\tit('should invite to the administrators group if inviter is an admin', async () => {\n\t\t\t\tconst { res } = await helpers.invite({ emails: 'invite99@test.com', groupsToJoin: ['administrators'] }, adminUid, jar, csrf_token);\n\t\t\t\tassert.strictEqual(res.statusCode, 200);\n\t\t\t});\n\t\t});\n\n\t\tdescribe('after invites checks', () => {\n\t\t\tit('should get user\\'s invites', (done) => {\n\t\t\t\tUser.getInvites(inviterUid, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tArray.from(Array(6)).forEach((_, i) => {\n\t\t\t\t\t\tassert.notEqual(data.indexOf(`invite${i + 1}@test.com`), -1);\n\t\t\t\t\t});\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should get all invites', (done) => {\n\t\t\t\tUser.getAllInvites((err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\n\t\t\t\t\tconst adminData = data.filter(d => parseInt(d.uid, 10) === adminUid)[0];\n\t\t\t\t\tassert.notEqual(adminData.invitations.indexOf('invite99@test.com'), -1);\n\n\t\t\t\t\tconst inviterData = data.filter(d => parseInt(d.uid, 10) === inviterUid)[0];\n\t\t\t\t\tArray.from(Array(6)).forEach((_, i) => {\n\t\t\t\t\t\tassert.notEqual(inviterData.invitations.indexOf(`invite${i + 1}@test.com`), -1);\n\t\t\t\t\t});\n\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should fail to verify invitation with invalid data', (done) => {\n\t\t\t\tUser.verifyInvitation({ token: '', email: '' }, (err) => {\n\t\t\t\t\tassert.strictEqual(err.message, '[[register:invite.error-invite-only]]');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should fail to verify invitation with invalid email', (done) => {\n\t\t\t\tUser.verifyInvitation({ token: 'test', email: 'doesnotexist@test.com' }, (err) => {\n\t\t\t\t\tassert.strictEqual(err.message, '[[register:invite.error-invalid-data]]');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should verify installation with no errors', (done) => {\n\t\t\t\tconst email = 'invite1@test.com';\n\t\t\t\tdb.get(`invitation:uid:${inviterUid}:invited:${email}`, 'token', (err, token) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tUser.verifyInvitation({ token: token, email: 'invite1@test.com' }, (err) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should error with invalid username', (done) => {\n\t\t\t\tUser.deleteInvitation('doesnotexist', 'test@test.com', (err) => {\n\t\t\t\t\tassert.equal(err.message, '[[error:invalid-username]]');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should delete invitation', (done) => {\n\t\t\t\tconst socketUser = require('../src/socket.io/user');\n\t\t\t\tsocketUser.deleteInvitation({ uid: adminUid }, { invitedBy: 'inviter', email: 'invite1@test.com' }, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tdb.isSetMember(`invitation:uid:${inviterUid}`, 'invite1@test.com', (err, isMember) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(isMember, false);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should delete invitation key', (done) => {\n\t\t\t\tUser.deleteInvitationKey('invite99@test.com', (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tdb.isSetMember(`invitation:uid:${adminUid}`, 'invite99@test.com', (err, isMember) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.equal(isMember, false);\n\t\t\t\t\t\tdb.isSetMember('invitation:uids', adminUid, (err, isMember) => {\n\t\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\t\tassert.equal(isMember, false);\n\t\t\t\t\t\t\tdone();\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should joined the groups from invitation after registration', async () => {\n\t\t\t\tconst email = 'invite5@test.com';\n\t\t\t\tconst groupsToJoin = [PUBLIC_GROUP, OWN_PRIVATE_GROUP];\n\t\t\t\tconst token = await db.get(`invitation:uid:${inviterUid}:invited:${email}`);\n\n\t\t\t\tawait new Promise((resolve, reject) => {\n\t\t\t\t\thelpers.registerUser({\n\t\t\t\t\t\tusername: 'invite5',\n\t\t\t\t\t\tpassword: '123456',\n\t\t\t\t\t\t'password-confirm': '123456',\n\t\t\t\t\t\temail: email,\n\t\t\t\t\t\tgdpr_consent: true,\n\t\t\t\t\t\ttoken: token,\n\t\t\t\t\t}, async (err, jar, response, body) => {\n\t\t\t\t\t\tif (err) {\n\t\t\t\t\t\t\treject(err);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst memberships = await groups.isMemberOfGroups(body.uid, groupsToJoin);\n\t\t\t\t\t\tconst joinedToAll = memberships.filter(Boolean);\n\n\t\t\t\t\t\tif (joinedToAll.length !== groupsToJoin.length) {\n\t\t\t\t\t\t\treject(new Error('Not joined to the groups'));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tresolve();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tdescribe('invite groups', () => {\n\t\t\tlet csrf_token;\n\t\t\tlet jar;\n\n\t\t\tbefore((done) => {\n\t\t\t\thelpers.loginUser('inviter', COMMON_PW, (err, data) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tjar = data.jar;\n\n\t\t\t\t\trequest({\n\t\t\t\t\t\turl: `${nconf.get('url')}/api/config`,\n\t\t\t\t\t\tjson: true,\n\t\t\t\t\t\tjar: jar,\n\t\t\t\t\t}, (err, response, body) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tcsrf_token = body.csrf_token;\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should show a list of groups for adding to an invite', async () => {\n\t\t\t\tconst body = await requestAsync({\n\t\t\t\t\turl: `${nconf.get('url')}/api/v3/users/${inviterUid}/invites/groups`,\n\t\t\t\t\tjson: true,\n\t\t\t\t\tjar,\n\t\t\t\t});\n\n\t\t\t\tassert(Array.isArray(body.response));\n\t\t\t\tassert.strictEqual(2, body.response.length);\n\t\t\t\tassert.deepStrictEqual(body.response, ['ownPrivateGroup', 'publicGroup']);\n\t\t\t});\n\n\t\t\tit('should error out if you request invite groups for another uid', async () => {\n\t\t\t\tconst res = await requestAsync({\n\t\t\t\t\turl: `${nconf.get('url')}/api/v3/users/${adminUid}/invites/groups`,\n\t\t\t\t\tjson: true,\n\t\t\t\t\tjar,\n\t\t\t\t\tsimple: false,\n\t\t\t\t\tresolveWithFullResponse: true,\n\t\t\t\t});\n\n\t\t\t\tassert.strictEqual(res.statusCode, 401);\n\t\t\t\tassert.deepStrictEqual(res.body, {\n\t\t\t\t\tstatus: {\n\t\t\t\t\t\tcode: 'not-authorised',\n\t\t\t\t\t\tmessage: 'A valid login session was not found. Please log in and try again.',\n\t\t\t\t\t},\n\t\t\t\t\tresponse: {},\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('email confirm', () => {\n\t\tit('should error with invalid code', (done) => {\n\t\t\tUser.email.confirmByCode('asdasda', (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:invalid-data]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should confirm email of user', async () => {\n\t\t\tconst email = 'confirm@me.com';\n\t\t\tconst uid = await User.create({\n\t\t\t\tusername: 'confirme',\n\t\t\t\temail: email,\n\t\t\t});\n\n\t\t\tconst code = await User.email.sendValidationEmail(uid, { email, force: 1 });\n\t\t\tconst unverified = await groups.isMember(uid, 'unverified-users');\n\t\t\tassert.strictEqual(unverified, true);\n\t\t\tawait User.email.confirmByCode(code);\n\t\t\tconst [confirmed, isVerified] = await Promise.all([\n\t\t\t\tdb.getObjectField(`user:${uid}`, 'email:confirmed'),\n\t\t\t\tgroups.isMember(uid, 'verified-users', uid),\n\t\t\t]);\n\t\t\tassert.strictEqual(parseInt(confirmed, 10), 1);\n\t\t\tassert.strictEqual(isVerified, true);\n\t\t});\n\n\t\tit('should confirm email of user by uid', async () => {\n\t\t\tconst email = 'confirm2@me.com';\n\t\t\tconst uid = await User.create({\n\t\t\t\tusername: 'confirme2',\n\t\t\t\temail,\n\t\t\t});\n\t\t\tawait User.setUserField(uid, 'email', email);\n\n\t\t\tconst unverified = await groups.isMember(uid, 'unverified-users');\n\t\t\tassert.strictEqual(unverified, true);\n\t\t\tawait User.email.confirmByUid(uid);\n\t\t\tconst [confirmed, isVerified] = await Promise.all([\n\t\t\t\tdb.getObjectField(`user:${uid}`, 'email:confirmed'),\n\t\t\t\tgroups.isMember(uid, 'verified-users', uid),\n\t\t\t]);\n\t\t\tassert.strictEqual(parseInt(confirmed, 10), 1);\n\t\t\tassert.strictEqual(isVerified, true);\n\t\t});\n\n\t\tit('should remove the email from a different account if the email is already in use', async () => {\n\t\t\tconst email = 'confirm2@me.com';\n\t\t\tconst uid = await User.create({\n\t\t\t\tusername: 'confirme3',\n\t\t\t});\n\n\t\t\tconst oldUid = await db.sortedSetScore('email:uid', email);\n\t\t\tconst code = await User.email.sendValidationEmail(uid, email);\n\t\t\tawait User.email.confirmByCode(code);\n\n\t\t\tconst oldUserData = await User.getUserData(oldUid);\n\n\t\t\tassert.strictEqual((await db.sortedSetScore('email:uid', email)), uid);\n\t\t\tassert.strictEqual(oldUserData.email, '');\n\t\t});\n\t});\n\n\tdescribe('user jobs', () => {\n\t\tit('should start user jobs', (done) => {\n\t\t\tUser.startJobs();\n\t\t\tdone();\n\t\t});\n\n\t\tit('should stop user jobs', (done) => {\n\t\t\tUser.stopJobs();\n\t\t\tdone();\n\t\t});\n\n\t\tit('should send digest', (done) => {\n\t\t\tdb.sortedSetAdd('digest:day:uids', [Date.now(), Date.now()], [1, 2], (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tUser.digest.execute({ interval: 'day' }, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('hideEmail/hideFullname', () => {\n\t\tconst COMMON_PW = '123456';\n\t\tconst hidingUser = {\n\t\t\tusername: 'hiddenemail',\n\t\t\temail: 'should@be.hidden',\n\t\t\tfullname: 'baris soner usakli',\n\t\t\tpassword: COMMON_PW,\n\t\t};\n\t\tconst regularUser = {\n\t\t\tusername: 'regularUser',\n\t\t\temail: 'regular@example.com',\n\t\t\tfullname: 'regular user',\n\t\t\tpassword: COMMON_PW,\n\t\t};\n\t\tlet hidingUserJar;\n\t\tlet adminUid;\n\t\tlet adminJar;\n\t\tlet globalModJar;\n\t\tlet regularUserJar;\n\n\t\tbefore(async () => {\n\t\t\tadminUid = await User.create({\n\t\t\t\tusername: 'adminhideemail',\n\t\t\t\tpassword: COMMON_PW,\n\t\t\t});\n\t\t\tawait groups.join('administrators', adminUid);\n\t\t\t({ jar: adminJar } = await helpers.loginUser('adminhideemail', COMMON_PW));\n\n\t\t\t// Edge case: In a grepped test, this user should not be created as the first user to have its email not confirmed\n\t\t\thidingUser.uid = await User.create(hidingUser);\n\t\t\t({ jar: hidingUserJar } = await helpers.loginUser(hidingUser.username, COMMON_PW));\n\n\t\t\tconst globalModUid = await User.create({\n\t\t\t\tusername: 'globalmodhideemail',\n\t\t\t\tpassword: COMMON_PW,\n\t\t\t});\n\t\t\tawait groups.join('Global Moderators', globalModUid);\n\t\t\t({ jar: globalModJar } = await helpers.loginUser('globalmodhideemail', COMMON_PW));\n\n\t\t\tregularUser.uid = await User.create(regularUser);\n\t\t\t({ jar: regularUserJar } = await helpers.loginUser(regularUser.username, COMMON_PW));\n\t\t});\n\n\t\tafter((done) => {\n\t\t\tmeta.config.hideEmail = 0;\n\t\t\tmeta.config.hideFullname = 0;\n\t\t\tdone();\n\t\t});\n\n\t\tasync function assertPrivacy({ expectVisible, jar, v3Api, emailOnly }) {\n\t\t\tconst path = v3Api ? `v3/users/${hidingUser.uid}` : `user/${hidingUser.username}`;\n\t\t\tconst response = await requestAsync(`${nconf.get('url')}/api/${path}`, { json: true, jar });\n\t\t\tconst { response: userData } = v3Api ? response : { response };\n\n\t\t\tassert.strictEqual(userData.email, expectVisible ? hidingUser.email : '');\n\t\t\tif (!emailOnly) {\n\t\t\t\tassert.strictEqual(userData.fullname, expectVisible ? hidingUser.fullname : '');\n\t\t\t}\n\t\t}\n\n\t\tit('should hide unconfirmed emails on profile pages', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, emailOnly: true });\n\t\t\tawait assertPrivacy({ v3Api: false, jar: hidingUserJar, emailOnly: true });\n\t\t\tawait assertPrivacy({ v3Api: false, jar: adminJar, emailOnly: true });\n\t\t\tawait assertPrivacy({ v3Api: false, jar: globalModJar, emailOnly: true });\n\t\t\tawait assertPrivacy({ v3Api: false, jar: regularUserJar, emailOnly: true });\n\n\t\t\t// Let's confirm for afterwards\n\t\t\tawait User.email.confirmByUid(hidingUser.uid);\n\t\t});\n\n\t\tit('should hide from guests by default', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false });\n\t\t});\n\n\t\tit('should hide from unprivileged users by default', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, jar: regularUserJar });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: regularUserJar });\n\t\t});\n\n\t\tit('should be visible to self by default', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, jar: hidingUserJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: hidingUserJar, expectVisible: true });\n\t\t});\n\n\t\tit('should be visible to privileged users by default', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, jar: adminJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: adminJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: false, jar: globalModJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: globalModJar, expectVisible: true });\n\t\t});\n\n\t\tit('should hide from guests (system-wide: hide, by-user: hide)', async () => {\n\t\t\tmeta.config.hideEmail = 1;\n\t\t\tmeta.config.hideFullname = 1;\n\t\t\t// Explicitly set user's privacy settings to hide its email and fullname\n\t\t\tconst data = { uid: hidingUser.uid, settings: { showemail: 0, showfullname: 0 } };\n\t\t\tawait apiUser.updateSettings({ uid: hidingUser.uid }, data);\n\n\t\t\tawait assertPrivacy({ v3Api: false });\n\t\t});\n\n\t\tit('should hide from unprivileged users (system-wide: hide, by-user: hide)', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, jar: regularUserJar });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: regularUserJar });\n\t\t});\n\n\t\tit('should be visible to self (system-wide: hide, by-user: hide)', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, jar: hidingUserJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: hidingUserJar, expectVisible: true });\n\t\t});\n\n\t\tit('should be visible to privileged users (system-wide: hide, by-user: hide)', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, jar: adminJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: adminJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: false, jar: globalModJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: globalModJar, expectVisible: true });\n\t\t});\n\n\t\tit('should hide from guests (system-wide: show, by-user: hide)', async () => {\n\t\t\tmeta.config.hideEmail = 0;\n\t\t\tmeta.config.hideFullname = 0;\n\n\t\t\tawait assertPrivacy({ v3Api: false });\n\t\t});\n\n\t\tit('should hide from unprivileged users (system-wide: show, by-user: hide)', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, jar: regularUserJar });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: regularUserJar });\n\t\t});\n\n\t\tit('should be visible to self (system-wide: show, by-user: hide)', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, jar: hidingUserJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: hidingUserJar, expectVisible: true });\n\t\t});\n\n\t\tit('should be visible to privileged users (system-wide: show, by-user: hide)', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, jar: adminJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: adminJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: false, jar: globalModJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: globalModJar, expectVisible: true });\n\t\t});\n\n\t\tit('should be visible to guests (system-wide: show, by-user: show)', async () => {\n\t\t\tmeta.config.hideEmail = 0;\n\t\t\tmeta.config.hideFullname = 0;\n\n\t\t\t// Set user's individual privacy settings to show its email and fullname\n\t\t\tconst data = { uid: hidingUser.uid, settings: { showemail: 1, showfullname: 1 } };\n\t\t\tawait apiUser.updateSettings({ uid: hidingUser.uid }, data);\n\n\t\t\tawait assertPrivacy({ v3Api: false, expectVisible: true });\n\t\t});\n\n\t\tit('should be visible to unprivileged users (system-wide: show, by-user: show)', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, jar: regularUserJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: regularUserJar, expectVisible: true });\n\t\t});\n\n\t\t// System-wide \"hide\" prioritized over individual users' settings\n\t\tit('should hide from guests (system-wide: hide, by-user: show)', async () => {\n\t\t\tmeta.config.hideEmail = 1;\n\t\t\tmeta.config.hideFullname = 1;\n\n\t\t\tawait assertPrivacy({ v3Api: false });\n\t\t});\n\n\t\tit('should hide from unprivileged users (system-wide: hide, by-user: show)', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, jar: regularUserJar });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: regularUserJar });\n\t\t});\n\n\t\tit('should be visible to self (system-wide: hide, by-user: show)', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, jar: hidingUserJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: hidingUserJar, expectVisible: true });\n\t\t});\n\n\t\tit('should be visible to privileged users (system-wide: hide, by-user: show)', async () => {\n\t\t\tawait assertPrivacy({ v3Api: false, jar: adminJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: adminJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: false, jar: globalModJar, expectVisible: true });\n\t\t\tawait assertPrivacy({ v3Api: true, jar: globalModJar, expectVisible: true });\n\t\t});\n\n\t\tit('should handle array of user data (system-wide: hide)', async () => {\n\t\t\tconst userData = await User.hidePrivateData([hidingUser, regularUser], hidingUser.uid);\n\t\t\tassert.strictEqual(userData[0].fullname, hidingUser.fullname);\n\t\t\tassert.strictEqual(userData[0].email, hidingUser.email);\n\t\t\tassert.strictEqual(userData[1].fullname, '');\n\t\t\tassert.strictEqual(userData[1].email, '');\n\t\t});\n\n\t\tit('should hide fullname in topic list and topic', (done) => {\n\t\t\tTopics.post({\n\t\t\t\tuid: hidingUser.uid,\n\t\t\t\ttitle: 'Topic hidden',\n\t\t\t\tcontent: 'lorem ipsum',\n\t\t\t\tcid: testCid,\n\t\t\t}, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\trequest(`${nconf.get('url')}/api/recent`, { json: true }, (err, res, body) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert(!body.topics[0].user.hasOwnProperty('fullname'));\n\t\t\t\t\trequest(`${nconf.get('url')}/api/topic/${body.topics[0].slug}`, { json: true }, (err, res, body) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert(!body.posts[0].user.hasOwnProperty('fullname'));\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('user blocking methods', (done) => {\n\t\tlet blockeeUid;\n\t\tbefore((done) => {\n\t\t\tUser.create({\n\t\t\t\tusername: 'blockee',\n\t\t\t\temail: 'blockee@example.org',\n\t\t\t\tfullname: 'Block me',\n\t\t\t}, (err, uid) => {\n\t\t\t\tblockeeUid = uid;\n\t\t\t\tdone(err);\n\t\t\t});\n\t\t});\n\n\t\tdescribe('.toggle()', () => {\n\t\t\tit('should toggle block', (done) => {\n\t\t\t\tsocketUser.toggleBlock({ uid: 1 }, { blockerUid: 1, blockeeUid: blockeeUid }, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tUser.blocks.is(blockeeUid, 1, (err, blocked) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert(blocked);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should toggle block', (done) => {\n\t\t\t\tsocketUser.toggleBlock({ uid: 1 }, { blockerUid: 1, blockeeUid: blockeeUid }, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tUser.blocks.is(blockeeUid, 1, (err, blocked) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert(!blocked);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tdescribe('.add()', () => {\n\t\t\tit('should block a uid', (done) => {\n\t\t\t\tUser.blocks.add(blockeeUid, 1, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tUser.blocks.list(1, (err, blocked_uids) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.strictEqual(Array.isArray(blocked_uids), true);\n\t\t\t\t\t\tassert.strictEqual(blocked_uids.length, 1);\n\t\t\t\t\t\tassert.strictEqual(blocked_uids.includes(blockeeUid), true);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should automatically increment corresponding user field', (done) => {\n\t\t\t\tdb.getObjectField('user:1', 'blocksCount', (err, count) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(parseInt(count, 10), 1);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should error if you try to block the same uid again', (done) => {\n\t\t\t\tUser.blocks.add(blockeeUid, 1, (err) => {\n\t\t\t\t\tassert.equal(err.message, '[[error:already-blocked]]');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tdescribe('.remove()', () => {\n\t\t\tit('should unblock a uid', (done) => {\n\t\t\t\tUser.blocks.remove(blockeeUid, 1, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tUser.blocks.list(1, (err, blocked_uids) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tassert.strictEqual(Array.isArray(blocked_uids), true);\n\t\t\t\t\t\tassert.strictEqual(blocked_uids.length, 0);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should automatically decrement corresponding user field', (done) => {\n\t\t\t\tdb.getObjectField('user:1', 'blocksCount', (err, count) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(parseInt(count, 10), 0);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should error if you try to unblock the same uid again', (done) => {\n\t\t\t\tUser.blocks.remove(blockeeUid, 1, (err) => {\n\t\t\t\t\tassert.equal(err.message, '[[error:already-unblocked]]');\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tdescribe('.is()', () => {\n\t\t\tbefore((done) => {\n\t\t\t\tUser.blocks.add(blockeeUid, 1, done);\n\t\t\t});\n\n\t\t\tit('should return a Boolean with blocked status for the queried uid', (done) => {\n\t\t\t\tUser.blocks.is(blockeeUid, 1, (err, blocked) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(blocked, true);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tdescribe('.list()', () => {\n\t\t\tit('should return a list of blocked uids', (done) => {\n\t\t\t\tUser.blocks.list(1, (err, blocked_uids) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(Array.isArray(blocked_uids), true);\n\t\t\t\t\tassert.strictEqual(blocked_uids.length, 1);\n\t\t\t\t\tassert.strictEqual(blocked_uids.includes(blockeeUid), true);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tdescribe('.filter()', () => {\n\t\t\tit('should remove entries by blocked uids and return filtered set', (done) => {\n\t\t\t\tUser.blocks.filter(1, [{\n\t\t\t\t\tfoo: 'foo',\n\t\t\t\t\tuid: blockeeUid,\n\t\t\t\t}, {\n\t\t\t\t\tfoo: 'bar',\n\t\t\t\t\tuid: 1,\n\t\t\t\t}, {\n\t\t\t\t\tfoo: 'baz',\n\t\t\t\t\tuid: blockeeUid,\n\t\t\t\t}], (err, filtered) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(Array.isArray(filtered), true);\n\t\t\t\t\tassert.strictEqual(filtered.length, 1);\n\t\t\t\t\tassert.equal(filtered[0].uid, 1);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should allow property argument to be passed in to customise checked property', (done) => {\n\t\t\t\tUser.blocks.filter(1, 'fromuid', [{\n\t\t\t\t\tfoo: 'foo',\n\t\t\t\t\tfromuid: blockeeUid,\n\t\t\t\t}, {\n\t\t\t\t\tfoo: 'bar',\n\t\t\t\t\tfromuid: 1,\n\t\t\t\t}, {\n\t\t\t\t\tfoo: 'baz',\n\t\t\t\t\tfromuid: blockeeUid,\n\t\t\t\t}], (err, filtered) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(Array.isArray(filtered), true);\n\t\t\t\t\tassert.strictEqual(filtered.length, 1);\n\t\t\t\t\tassert.equal(filtered[0].fromuid, 1);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should not process invalid sets', (done) => {\n\t\t\t\tUser.blocks.filter(1, [{ foo: 'foo' }, { foo: 'bar' }, { foo: 'baz' }], (err, filtered) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(Array.isArray(filtered), true);\n\t\t\t\t\tassert.strictEqual(filtered.length, 3);\n\t\t\t\t\tfiltered.forEach((obj) => {\n\t\t\t\t\t\tassert.strictEqual(obj.hasOwnProperty('foo'), true);\n\t\t\t\t\t});\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should process plain sets that just contain uids', (done) => {\n\t\t\t\tUser.blocks.filter(1, [1, blockeeUid], (err, filtered) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.strictEqual(filtered.length, 1);\n\t\t\t\t\tassert.strictEqual(filtered[0], 1);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\n\t\t\tit('should filter uids that are blocking targetUid', (done) => {\n\t\t\t\tUser.blocks.filterUids(blockeeUid, [1, 2], (err, filtered) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tassert.deepEqual(filtered, [2]);\n\t\t\t\t\tdone();\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('status/online', () => {\n\t\tit('should return offline if user is guest', (done) => {\n\t\t\tconst status = User.getStatus({ uid: 0 });\n\t\t\tassert.strictEqual(status, 'offline');\n\t\t\tdone();\n\t\t});\n\n\t\tit('should return offline if user is guest', async () => {\n\t\t\tassert.strictEqual(await User.isOnline(0), false);\n\t\t});\n\n\t\tit('should return true', async () => {\n\t\t\tassert.strictEqual(await User.isOnline(testUid), true);\n\t\t});\n\t});\n\n\tdescribe('isPrivilegedOrSelf', () => {\n\t\tit('should return not error if self', (done) => {\n\t\t\tUser.isPrivilegedOrSelf(1, 1, (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\n\t\tit('should not error if privileged', (done) => {\n\t\t\tUser.create({ username: 'theadmin' }, (err, uid) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tgroups.join('administrators', uid, (err) => {\n\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\tUser.isPrivilegedOrSelf(uid, 2, (err) => {\n\t\t\t\t\t\tassert.ifError(err);\n\t\t\t\t\t\tdone();\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t});\n\n\t\tit('should error if not privileged', (done) => {\n\t\t\tUser.isPrivilegedOrSelf(0, 1, (err) => {\n\t\t\t\tassert.equal(err.message, '[[error:no-privileges]]');\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tit('should get admins and mods', (done) => {\n\t\tUser.getAdminsandGlobalMods((err, data) => {\n\t\t\tassert.ifError(err);\n\t\t\tassert(Array.isArray(data));\n\t\t\tdone();\n\t\t});\n\t});\n\n\tit('should allow user to login even if password is weak', (done) => {\n\t\tUser.create({ username: 'weakpwd', password: '123456' }, (err) => {\n\t\t\tassert.ifError(err);\n\t\t\tconst oldValue = meta.config.minimumPasswordStrength;\n\t\t\tmeta.config.minimumPasswordStrength = 3;\n\t\t\thelpers.loginUser('weakpwd', '123456', (err) => {\n\t\t\t\tassert.ifError(err);\n\t\t\t\tmeta.config.minimumPasswordStrength = oldValue;\n\t\t\t\tdone();\n\t\t\t});\n\t\t});\n\t});\n\n\tdescribe('User\\'s', async () => {\n\t\tlet files;\n\n\t\tbefore(async () => {\n\t\t\tfiles = await file.walk(path.resolve(__dirname, './user'));\n\t\t});\n\n\t\tit('subfolder tests', () => {\n\t\t\tfiles.forEach((filePath) => {\n\t\t\t\trequire(filePath);\n\t\t\t});\n\t\t});\n\t});\n});\n"], "filenames": ["test/api.js", "test/controllers.js", "test/user.js"], "buggy_code_start_loc": [488, 1239, 816], "buggy_code_end_loc": [489, 1806, 1291], "fixing_code_start_loc": [488, 1240, 817], "fixing_code_end_loc": [489, 1808, 1292], "type": "CWE-352", "message": "A vulnerability, which was classified as problematic, was found in NodeBB up to 2.5.7. This affects an unknown part of the file /register/abort. The manipulation leads to cross-site request forgery. It is possible to initiate the attack remotely. Upgrading to version 2.5.8 is able to address this issue. The name of the patch is 2f9d8c350e54543f608d3d4c8e1a49bbb6cdea38. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-213555.", "other": {"cve": {"id": "CVE-2022-3978", "sourceIdentifier": "cna@vuldb.com", "published": "2022-11-13T14:15:10.487", "lastModified": "2022-11-18T21:13:51.490", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability, which was classified as problematic, was found in NodeBB up to 2.5.7. This affects an unknown part of the file /register/abort. The manipulation leads to cross-site request forgery. It is possible to initiate the attack remotely. Upgrading to version 2.5.8 is able to address this issue. The name of the patch is 2f9d8c350e54543f608d3d4c8e1a49bbb6cdea38. It is recommended to upgrade the affected component. The associated identifier of this vulnerability is VDB-213555."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:N/I:L/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "LOW", "availabilityImpact": "NONE", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-352"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-352"}, {"lang": "en", "value": "CWE-862"}, {"lang": "en", "value": "CWE-863"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:nodebb:nodebb:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.5.8", "matchCriteriaId": "5FB1FA81-94BA-4943-B016-35E191A9682B"}]}]}], "references": [{"url": "https://github.com/NodeBB/NodeBB/commit/2f9d8c350e54543f608d3d4c8e1a49bbb6cdea38", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/NodeBB/NodeBB/issues/11017", "source": "cna@vuldb.com", "tags": ["Exploit", "Issue Tracking", "Third Party Advisory"]}, {"url": "https://github.com/NodeBB/NodeBB/releases/tag/v2.5.8", "source": "cna@vuldb.com", "tags": ["Release Notes", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.213555", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/NodeBB/NodeBB/commit/2f9d8c350e54543f608d3d4c8e1a49bbb6cdea38"}}