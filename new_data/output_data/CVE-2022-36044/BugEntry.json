{"buggy_code": ["// SPDX-License-Identifier: LGPL-3.0-only\n// SPDX-FileCopyrightText: 2021 Heersin <teablearcher@gmail.com>\n\n#include \"luac_common.h\"\n\nvoid luac_add_section(RzList *section_list, char *name, ut64 offset, ut32 size, bool is_func) {\n\tRzBinSection *bin_sec = RZ_NEW0(RzBinSection);\n\tif (!bin_sec) {\n\t\treturn;\n\t}\n\n\tbin_sec->name = rz_str_new(name);\n\tbin_sec->vaddr = bin_sec->paddr = offset;\n\tbin_sec->size = bin_sec->vsize = size;\n\tbin_sec->is_data = false;\n\tbin_sec->bits = is_func ? sizeof(LUA_INSTRUCTION) * 8 : 8;\n\t// bin_sec->has_strings = !is_func;\n\tbin_sec->has_strings = false;\n\tbin_sec->arch = rz_str_new(\"luac\");\n\n\tif (is_func) {\n\t\tbin_sec->perm = RZ_PERM_R | RZ_PERM_X;\n\t} else {\n\t\tbin_sec->perm = RZ_PERM_R;\n\t}\n\n\trz_list_append(section_list, bin_sec);\n}\n\nvoid luac_add_symbol(RzList *symbol_list, char *name, ut64 offset, ut64 size, const char *type) {\n\tRzBinSymbol *bin_sym = RZ_NEW0(RzBinSymbol);\n\tif (!bin_sym) {\n\t\treturn;\n\t}\n\n\tbin_sym->name = rz_str_new(name);\n\tbin_sym->vaddr = bin_sym->paddr = offset;\n\tbin_sym->size = size;\n\tbin_sym->type = type;\n\n\trz_list_append(symbol_list, bin_sym);\n}\n\nvoid luac_add_entry(RzList *entry_list, ut64 offset, int entry_type) {\n\tRzBinAddr *entry = RZ_NEW0(RzBinAddr);\n\tif (!entry) {\n\t\treturn;\n\t}\n\n\tentry->vaddr = offset;\n\tentry->paddr = offset;\n\tentry->type = entry_type;\n\n\trz_list_append(entry_list, entry);\n}\n\nvoid luac_add_string(RzList *string_list, char *string, ut64 offset, ut64 size) {\n\tRzBinString *bin_string = RZ_NEW0(RzBinString);\n\tif (!bin_string) {\n\t\treturn;\n\t}\n\n\tbin_string->paddr = offset;\n\tbin_string->vaddr = offset;\n\tbin_string->size = size;\n\tbin_string->length = size;\n\tbin_string->string = rz_str_new(string);\n\tbin_string->type = RZ_STRING_ENC_UTF8;\n\n\trz_list_append(string_list, bin_string);\n}\n\nstatic void try_free_empty_list(RzList *list) {\n\tif (list != NULL) {\n\t\trz_list_free(list);\n\t}\n}\n\nstatic void free_rz_section(RzBinSection *section) {\n\tif (!section) {\n\t\treturn;\n\t}\n\n\tif (section->name) {\n\t\tRZ_FREE(section->name);\n\t}\n\n\tif (section->format) {\n\t\tRZ_FREE(section->format);\n\t}\n\n\tRZ_FREE(section);\n}\n\nstatic void free_rz_string(RzBinString *string) {\n\tif (!string) {\n\t\treturn;\n\t}\n\n\tif (string->string) {\n\t\tRZ_FREE(string->string);\n\t}\n\n\tRZ_FREE(string);\n}\n\nstatic void free_rz_addr(RzBinAddr *addr) {\n\tif (!addr) {\n\t\treturn;\n\t}\n\tRZ_FREE(addr);\n}\n\nLuacBinInfo *luac_build_info(LuaProto *proto) {\n\tif (!proto) {\n\t\tRZ_LOG_ERROR(\"Invalid luac file\\n\");\n\t\treturn NULL;\n\t}\n\n\tLuacBinInfo *ret = RZ_NEW0(LuacBinInfo);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tret->entry_list = rz_list_newf((RzListFree)free_rz_addr);\n\tret->symbol_list = rz_list_newf((RzListFree)rz_bin_symbol_free);\n\tret->section_list = rz_list_newf((RzListFree)free_rz_section);\n\tret->string_list = rz_list_newf((RzListFree)free_rz_string);\n\n\tif (!(ret->entry_list && ret->symbol_list && ret->section_list && ret->string_list)) {\n\t\ttry_free_empty_list(ret->entry_list);\n\t\ttry_free_empty_list(ret->symbol_list);\n\t\ttry_free_empty_list(ret->section_list);\n\t\ttry_free_empty_list(ret->string_list);\n\t}\n\n\t_luac_build_info(proto, ret);\n\n\t// add entry of main\n\tut64 main_entry_offset;\n\tmain_entry_offset = proto->code_offset + proto->code_skipped;\n\tluac_add_entry(ret->entry_list, main_entry_offset, RZ_BIN_ENTRY_TYPE_PROGRAM);\n\n\treturn ret;\n}\n\nstatic const char *get_tag_string(ut8 tag) {\n\tswitch (tag) {\n\tcase LUA_VNIL:\n\t\treturn \"CONST_NIL\";\n\tcase LUA_VTRUE:\n\tcase LUA_VFALSE:\n\t\treturn \"CONST_BOOL\";\n\tcase LUA_VSHRSTR:\n\tcase LUA_VLNGSTR:\n\t\treturn \"CONST_STRING\";\n\tcase LUA_VNUMFLT:\n\tcase LUA_VNUMINT:\n\t\treturn \"CONST_NUM\";\n\tdefault:\n\t\treturn \"CONST_UNKNOWN\";\n\t}\n}\n\n/* Heap allocated string */\nstatic char *get_constant_symbol_name(char *proto_name, LuaConstEntry *entry) {\n\trz_return_val_if_fail(entry || proto_name, NULL);\n\tut8 tag = entry->tag;\n\tchar *ret;\n\tint integer_value;\n\tdouble float_value;\n\n\tswitch (tag) {\n\tcase LUA_VNIL:\n\t\tret = rz_str_newf(\"%s_const_nil\", proto_name);\n\t\tbreak;\n\tcase LUA_VTRUE:\n\t\tret = rz_str_newf(\"%s_const_true\", proto_name);\n\t\tbreak;\n\tcase LUA_VFALSE:\n\t\tret = rz_str_newf(\"%s_const_false\", proto_name);\n\t\tbreak;\n\tcase LUA_VSHRSTR:\n\tcase LUA_VLNGSTR:\n\t\trz_return_val_if_fail(entry->data, NULL);\n\t\tret = rz_str_newf(\"%s_const_%s\", proto_name, (char *)entry->data);\n\t\tbreak;\n\tcase LUA_VNUMFLT:\n\t\trz_return_val_if_fail(entry->data, NULL);\n\t\tif (entry->data_len < sizeof(double)) {\n\t\t\treturn NULL;\n\t\t}\n\t\tfloat_value = *(double *)entry->data;\n\t\tret = rz_str_newf(\"%s_const_%f\", proto_name, float_value);\n\t\tbreak;\n\tcase LUA_VNUMINT:\n\t\trz_return_val_if_fail(entry->data, NULL);\n\t\tif (entry->data_len < sizeof(int)) {\n\t\t\treturn NULL;\n\t\t}\n\t\tinteger_value = *(int *)entry->data;\n\t\tret = rz_str_newf(\"%s_const_%d\", proto_name, integer_value);\n\t\tbreak;\n\tdefault:\n\t\tret = rz_str_newf(\"%s_const_0x%llx\", proto_name, entry->offset);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n/* Heap allocated string */\nstatic char *simple_build_upvalue_symbol(char *proto_name, LuaUpvalueEntry *entry) {\n\treturn rz_str_newf(\"%s_upvalue_0x%llx\", proto_name, entry->offset);\n}\n\nstatic char *get_upvalue_symbol_name(char *proto_name, LuaUpvalueEntry *entry, char *debug_name) {\n\trz_return_val_if_fail(proto_name || entry, NULL);\n\tif (debug_name == NULL) {\n\t\treturn simple_build_upvalue_symbol(proto_name, entry);\n\t}\n\n\treturn rz_str_newf(\"%s_upvalue_%s\", proto_name, debug_name);\n}\n\nvoid _luac_build_info(LuaProto *proto, LuacBinInfo *info) {\n\t/* process proto header info */\n\tchar *section_name;\n\tchar *symbol_name;\n\tchar *proto_name;\n\tRzListIter *iter;\n\n\tut64 current_offset;\n\tut64 current_size;\n\n\tint i = 0; // iter\n\n\t// 0. check if stripped (proto name is lost)\n\tif (proto->name_size == 0 || proto->proto_name == NULL) {\n\t\t// replace name with current offset\n\t\tproto_name = rz_str_newf(\"fcn.%08llx\", proto->offset);\n\t} else {\n\t\tproto_name = rz_str_new((char *)proto->proto_name);\n\t}\n\n\t// 1.1 set section name as function_name.header\n\tcurrent_offset = proto->offset;\n\tcurrent_size = proto->size;\n\tsection_name = rz_str_newf(\"%s.header\", proto_name);\n\tluac_add_section(info->section_list, section_name, current_offset, current_size, false);\n\tRZ_FREE(section_name);\n\n\t// 1.2 set section name as function_name.code\n\tcurrent_offset = proto->code_offset;\n\tcurrent_size = proto->code_size;\n\tsection_name = rz_str_newf(\"%s.code\", proto_name);\n\tluac_add_section(info->section_list, section_name, current_offset, current_size, true);\n\tRZ_FREE(section_name);\n\n\t// 1.3 set const section\n\tcurrent_offset = proto->const_offset;\n\tcurrent_size = proto->const_size;\n\tsection_name = rz_str_newf(\"%s.const\", proto_name);\n\tluac_add_section(info->section_list, section_name, current_offset, current_size, false);\n\tRZ_FREE(section_name);\n\n\t// 1.4 upvalue section\n\tcurrent_offset = proto->upvalue_offset;\n\tcurrent_size = proto->upvalue_size;\n\tsection_name = rz_str_newf(\"%s.upvalues\", proto_name);\n\tluac_add_section(info->section_list, section_name, current_offset, current_size, false);\n\tRZ_FREE(section_name);\n\n\t// 1.5 inner protos section\n\tcurrent_offset = proto->inner_proto_offset;\n\tcurrent_size = proto->inner_proto_size;\n\tsection_name = rz_str_newf(\"%s.protos\", proto_name);\n\tluac_add_section(info->section_list, section_name, current_offset, current_size, false);\n\tRZ_FREE(section_name);\n\n\t// 1.6 debug section\n\tcurrent_offset = proto->debug_offset;\n\tcurrent_size = proto->debug_size;\n\tsection_name = rz_str_newf(\"%s.debug\", proto_name);\n\tluac_add_section(info->section_list, section_name, current_offset, current_size, false);\n\tRZ_FREE(section_name);\n\n\t// 2.1 parse local var info\n\tLuaLocalVarEntry *local_var_entry;\n\trz_list_foreach (proto->local_var_info_entries, iter, local_var_entry) {\n\t\tluac_add_string(\n\t\t\tinfo->string_list,\n\t\t\t(char *)local_var_entry->varname,\n\t\t\tlocal_var_entry->offset,\n\t\t\tlocal_var_entry->varname_len);\n\t}\n\n\t// 2.2 parse debug_upvalues\n\tchar **upvalue_names;\n\tint real_upvalue_cnt;\n\tLuaDbgUpvalueEntry *debug_upv_entry;\n\treal_upvalue_cnt = rz_list_length(proto->upvalue_entries);\n\tupvalue_names = RZ_NEWS0(char *, real_upvalue_cnt);\n\tif (!upvalue_names) {\n\t\treturn;\n\t}\n\trz_list_foreach (proto->dbg_upvalue_entries, iter, debug_upv_entry) {\n\t\tupvalue_names[i] = (char *)debug_upv_entry->upvalue_name;\n\t\tluac_add_string(\n\t\t\tinfo->string_list,\n\t\t\tupvalue_names[i],\n\t\t\tdebug_upv_entry->offset,\n\t\t\tdebug_upv_entry->name_len);\n\t}\n\n\t// 3.1 construct constant symbols\n\tLuaConstEntry *const_entry;\n\trz_list_foreach (proto->const_entries, iter, const_entry) {\n\t\tsymbol_name = get_constant_symbol_name(proto_name, const_entry);\n\t\tluac_add_symbol(\n\t\t\tinfo->symbol_list,\n\t\t\tsymbol_name,\n\t\t\tconst_entry->offset,\n\t\t\tconst_entry->data_len,\n\t\t\tget_tag_string(const_entry->tag));\n\t\tif (const_entry->tag == LUA_VLNGSTR || const_entry->tag == LUA_VSHRSTR) {\n\t\t\tluac_add_string(\n\t\t\t\tinfo->string_list,\n\t\t\t\t(char *)const_entry->data,\n\t\t\t\tconst_entry->offset,\n\t\t\t\tconst_entry->data_len);\n\t\t}\n\t\tRZ_FREE(symbol_name);\n\t}\n\n\t// 3.2 construct upvalue symbols\n\tLuaUpvalueEntry *upvalue_entry;\n\ti = 0;\n\trz_list_foreach (proto->upvalue_entries, iter, upvalue_entry) {\n\t\tsymbol_name = get_upvalue_symbol_name(proto_name, upvalue_entry, upvalue_names[i++]);\n\t\tluac_add_symbol(\n\t\t\tinfo->symbol_list,\n\t\t\tsymbol_name,\n\t\t\tupvalue_entry->offset,\n\t\t\t3,\n\t\t\t\"UPVALUE\");\n\t\tRZ_FREE(symbol_name);\n\t}\n\n\t// 4. parse sub proto\n\tLuaProto *sub_proto;\n\trz_list_foreach (proto->proto_entries, iter, sub_proto) {\n\t\t_luac_build_info(sub_proto, info);\n\t}\n\n\tRZ_FREE(proto_name);\n}\n", "// SPDX-License-Identifier: LGPL-3.0-only\n// SPDX-FileCopyrightText: 2021 Heersin <teablearcher@gmail.com>\n\n// put common definition of luac\n\n#ifndef BUILD_LUAC_COMMON_H\n#define BUILD_LUAC_COMMON_H\n\n#include <rz_bin.h>\n#include <rz_lib.h>\n#include <rz_list.h>\n\ntypedef ut32 LUA_INSTRUCTION;\n\n/* Macros About Luac Format */\n#define LUAC_MAGIC_OFFSET   0x00\n#define LUAC_MAGIC_SIZE     4\n#define LUAC_VERSION_OFFSET 0x04\n#define LUAC_VERSION_SIZE   1\n\n#define LUAC_MAGIC \"\\x1b\\x4c\\x75\\x61\"\n\n/* Lua Constant Tag */\n#define makevariant(t, v) ((t) | ((v) << 4))\n\n#define LUA_TNIL     0\n#define LUA_TBOOLEAN 1\n#define LUA_TNUMBER  3\n#define LUA_TSTRING  4\n\n#define LUA_VNIL    makevariant(LUA_TNIL, 0)\n#define LUA_VFALSE  makevariant(LUA_TBOOLEAN, 0)\n#define LUA_VTRUE   makevariant(LUA_TBOOLEAN, 1)\n#define LUA_VNUMINT makevariant(LUA_TNUMBER, 0) /* integer numbers */\n#define LUA_VNUMFLT makevariant(LUA_TNUMBER, 1) /* float numbers */\n#define LUA_VSHRSTR makevariant(LUA_TSTRING, 0) /* short strings */\n#define LUA_VLNGSTR makevariant(LUA_TSTRING, 1) /* long strings */\n\n/**\n *  \\struct lua_proto_ex\n *  \\brief Store valuable info when parsing. Treat luac file body as a main function.\n */\ntypedef struct lua_proto_ex {\n\tut64 offset; ///< proto offset in bytes\n\tut64 size; ///< current proto size\n\n\tut8 *proto_name; ///<  current proto name\n\tint name_size; ///< size of proto name\n\n\tut64 line_defined; ///< line number of function start\n\tut64 lastline_defined; ///< line number of function end\n\n\tut8 num_params; ///< number of parameters of this proto\n\tut8 is_vararg; ///< is variable arg?\n\tut8 max_stack_size; ///< max stack size\n\n\t/* Code of this proto */\n\tut64 code_offset; ///< code section offset\n\tut64 code_size; ///< code section size\n\tut64 code_skipped; ///< opcode data offset to code_offset.\n\n\t/* store constant entries */\n\tRzList *const_entries; ///< A list to store constant entries\n\tut64 const_offset; ///< const section offset\n\tut64 const_size; ///< const section size\n\n\t/* store upvalue entries */\n\tRzList *upvalue_entries; ///< A list to store upvalue entries\n\tut64 upvalue_offset; ///< upvalue section offset\n\tut64 upvalue_size; ///< upvalue section size\n\n\t/* store protos defined in this proto */\n\tRzList *proto_entries; ///< A list to store sub proto entries\n\tut64 inner_proto_offset; ///< sub proto section offset\n\tut64 inner_proto_size; ///< sub proto section size\n\n\t/* store Debug info */\n\tut64 debug_offset; ///< debug section offset\n\tut64 debug_size; ///< debug section size\n\tRzList *line_info_entries; ///< A list to store line info entries\n\tRzList *abs_line_info_entries; ///< A list to store absolutely line info entries\n\tRzList *local_var_info_entries; ///< A list to store local var entries\n\tRzList *dbg_upvalue_entries; ///< A list to store upvalue names\n\n} LuaProtoHeavy;\n\ntypedef LuaProtoHeavy LuaProto;\n\n/**\n * \\struct lua_constant_entry\n * \\brief Store constant type, data, and offset of this constant in luac file\n */\ntypedef struct lua_constant_entry {\n\tut8 tag; ///< type of this constant, see LUA_V* macros in luac_common.h\n\tvoid *data; ///< can be Number/Integer/String\n\tint data_len; ///< len of data\n\tut64 offset; ///< addr of this constant\n} LuaConstEntry;\n\n/**\n * \\struct lua_upvalue_entry\n * \\brief Store upvalue attributes\n */\ntypedef struct lua_upvalue_entry {\n\t/* attributes of upvalue */\n\tut8 instack; ///< is in stack\n\tut8 idx; ///< index\n\tut8 kind; ///< kind\n\tut64 offset; ///< offset of this upvalue\n} LuaUpvalueEntry;\n\ntypedef struct LuaProto LuaProtoEntry;\n\n/**\n * \\struct lua_lineinfo_entry\n * \\brief Store line info attributes\n */\ntypedef struct lua_lineinfo_entry {\n\tut32 info_data;\n\tut64 offset;\n} LuaLineinfoEntry;\n\n/**\n * \\struct lua_abs_lineinfo_entry\n * \\brief Store line info attributes\n */\ntypedef struct lua_abs_lineinfo_entry {\n\tint pc; ///< pc value of lua\n\tint line; ///< line number in source file\n\tut64 offset;\n} LuaAbsLineinfoEntry;\n\n/**\n * \\struct lua_local_var_entry\n * \\brief Store local var names and other info\n */\ntypedef struct lua_local_var_entry {\n\tut8 *varname; ///< name of this variable\n\tint varname_len; ///< length of name\n\tint start_pc; ///< first active position\n\tint end_pc; ///< first deactive position\n\tut64 offset; ///< offset of this entry\n} LuaLocalVarEntry;\n\n/**\n * \\struct lua_dbg_upvalue_entry\n * \\brief Store upvalue's debug info\n */\ntypedef struct lua_dbg_upvalue_entry {\n\tut8 *upvalue_name; ///< upvalue name\n\tint name_len; ///< length of name\n\tut64 offset;\n} LuaDbgUpvalueEntry;\n\n/**\n * \\struct lua_bin_info\n * \\brief A context info structure for luac plugin.\n */\ntypedef struct luac_bin_info {\n\tst32 major; ///< major version\n\tst32 minor; ///< minor version\n\tRzList *section_list; ///< list of sections\n\tRzList *symbol_list; ///< list of symbols\n\tRzList *entry_list; ///< list of entries\n\tRzList *string_list; ///< list of strings\n\tRzBinInfo *general_info; ///< general binary info from luac header\n} LuacBinInfo;\n\n/* ========================================================\n * Common Operation to Lua structures\n * Implemented in 'bin/format/luac/luac_common.c'\n * ======================================================== */\nLuaDbgUpvalueEntry *lua_new_dbg_upvalue_entry();\nLuaLocalVarEntry *lua_new_local_var_entry();\nLuaAbsLineinfoEntry *lua_new_abs_lineinfo_entry();\nLuaLineinfoEntry *lua_new_lineinfo_entry();\nLuaUpvalueEntry *lua_new_upvalue_entry();\nLuaConstEntry *lua_new_const_entry();\nLuaProto *lua_new_proto_entry();\n\nvoid lua_free_dbg_upvalue_entry(LuaDbgUpvalueEntry *);\nvoid lua_free_local_var_entry(LuaLocalVarEntry *);\nvoid lua_free_const_entry(LuaConstEntry *);\nvoid lua_free_proto_entry(LuaProto *);\n\n/* ========================================================\n * Common Operation to RzBinInfo\n * Implemented in 'bin/format/luac/luac_bin.c'\n * ======================================================== */\nvoid luac_add_section(RzList *section_list, char *name, ut64 offset, ut32 size, bool is_func);\nvoid luac_add_symbol(RzList *symbol_list, char *name, ut64 offset, ut64 size, const char *type);\nvoid luac_add_entry(RzList *entry_list, ut64 offset, int entry_type);\nvoid luac_add_string(RzList *string_list, char *string, ut64 offset, ut64 size);\n\nLuacBinInfo *luac_build_info(LuaProto *proto);\nvoid _luac_build_info(LuaProto *proto, LuacBinInfo *info);\n\n/* ========================================================\n * Export version specified Api to bin_luac.c\n * Implemented in 'bin/format/luac/v[version]/bin_[version]\n * ======================================================== */\nRzBinInfo *lua_parse_header_54(RzBinFile *bf, st32 major, st32 minor);\nLuaProto *lua_parse_body_54(RzBuffer *buffer, ut64 offset, ut64 data_size);\n\nRzBinInfo *lua_parse_header_53(RzBinFile *bf, st32 major, st32 minor);\nLuaProto *lua_parse_body_53(RzBuffer *buffer, ut64 offset, ut64 data_size);\n\n#define lua_check_error_offset(offset) \\\n\tif ((offset) == 0) { \\\n\t\treturn 0; \\\n\t}\n#define lua_check_error_offset_proto(offset, proto) \\\n\tif ((offset) == 0) { \\\n\t\tlua_free_proto_entry((proto)); \\\n\t\treturn NULL; \\\n\t}\n#define lua_return_if_null(proto) \\\n\tif ((proto) == NULL) { \\\n\t\treturn 0; \\\n\t}\n\n#endif // BUILD_LUAC_COMMON_H\n", "// SPDX-License-Identifier: LGPL-3.0-only\n// SPDX-FileCopyrightText: 2021 Heersin <teablearcher@gmail.com>\n\n#include <rz_bin.h>\n#include <rz_lib.h>\n#include \"librz/bin/format/luac/luac_common.h\"\n\n#define GET_INTERNAL_BIN_INFO_OBJ(bf) ((LuacBinInfo *)(bf)->o->bin_obj)\n\nstatic bool check_buffer(RzBuffer *buff) {\n\tif (rz_buf_size(buff) > 4) {\n\t\tut8 buf[LUAC_MAGIC_SIZE];\n\t\trz_buf_read_at(buff, LUAC_MAGIC_OFFSET, buf, LUAC_MAGIC_SIZE);\n\t\treturn !memcmp(buf, LUAC_MAGIC, LUAC_MAGIC_SIZE);\n\t}\n\treturn false;\n}\n\nstatic bool load_buffer(RzBinFile *bf, RzBinObject *obj, RzBuffer *buf, Sdb *sdb) {\n\tut8 MAJOR_MINOR_VERSION;\n\tLuacBinInfo *bin_info_obj = NULL;\n\tLuaProto *proto = NULL;\n\tRzBinInfo *general_info = NULL;\n\tst32 major;\n\tst32 minor;\n\n\trz_buf_read_at(buf, LUAC_VERSION_OFFSET, &MAJOR_MINOR_VERSION, sizeof(MAJOR_MINOR_VERSION)); /* 1-byte in fact */\n\tif ((bin_info_obj = RZ_NEW(LuacBinInfo)) == NULL) {\n\t\treturn false;\n\t}\n\tmajor = (MAJOR_MINOR_VERSION & 0xF0) >> 4;\n\tminor = (MAJOR_MINOR_VERSION & 0x0F);\n\n\tif (major != 5) {\n\t\tRZ_LOG_ERROR(\"currently support lua 5.x only\\n\");\n\t\treturn false;\n\t}\n\n\tswitch (minor) {\n\tcase 4:\n\t\tproto = lua_parse_body_54(buf, 0x20, bf->size);\n\t\tgeneral_info = lua_parse_header_54(bf, major, minor);\n\t\tbreak;\n\tcase 3:\n\t\tproto = lua_parse_body_53(buf, 0x22, bf->size);\n\t\tgeneral_info = lua_parse_header_53(bf, major, minor);\n\t\tbreak;\n\tdefault:\n\t\tRZ_LOG_ERROR(\"lua 5.%c not support now\\n\", minor + '0');\n\t\treturn false;\n\t}\n\n\tbin_info_obj = luac_build_info(proto);\n\tif (bin_info_obj == NULL) {\n\t\tlua_free_proto_entry(proto);\n\t\trz_bin_info_free(general_info);\n\t\treturn false;\n\t}\n\tbin_info_obj->general_info = general_info;\n\tbin_info_obj->major = major;\n\tbin_info_obj->minor = minor;\n\n\tlua_free_proto_entry(proto);\n\tproto = NULL;\n\n\tobj->bin_obj = bin_info_obj;\n\treturn true;\n}\n\nstatic RzBinInfo *info(RzBinFile *bf) {\n\tif (!bf) {\n\t\treturn NULL;\n\t}\n\tLuacBinInfo *bin_info_obj = GET_INTERNAL_BIN_INFO_OBJ(bf);\n\tif (!bin_info_obj) {\n\t\treturn NULL;\n\t}\n\n\treturn bin_info_obj->general_info;\n}\n\nstatic RzList *sections(RzBinFile *bf) {\n\tif (!bf) {\n\t\treturn NULL;\n\t}\n\tLuacBinInfo *bin_info_obj = GET_INTERNAL_BIN_INFO_OBJ(bf);\n\tif (!bin_info_obj) {\n\t\treturn NULL;\n\t}\n\n\treturn rz_list_clone(bin_info_obj->section_list);\n}\n\nstatic RzList *symbols(RzBinFile *bf) {\n\tif (!bf) {\n\t\treturn NULL;\n\t}\n\tLuacBinInfo *bin_info_obj = GET_INTERNAL_BIN_INFO_OBJ(bf);\n\tif (!bin_info_obj) {\n\t\treturn NULL;\n\t}\n\n\treturn bin_info_obj->symbol_list;\n}\n\nstatic RzList *entries(RzBinFile *bf) {\n\tif (!bf) {\n\t\treturn NULL;\n\t}\n\tLuacBinInfo *bin_info_obj = GET_INTERNAL_BIN_INFO_OBJ(bf);\n\tif (!bin_info_obj) {\n\t\treturn NULL;\n\t}\n\n\treturn bin_info_obj->entry_list;\n}\n\nstatic RzList *strings(RzBinFile *bf) {\n\tif (!bf) {\n\t\treturn NULL;\n\t}\n\tLuacBinInfo *bin_info_obj = GET_INTERNAL_BIN_INFO_OBJ(bf);\n\tif (!bin_info_obj) {\n\t\treturn NULL;\n\t}\n\n\treturn bin_info_obj->string_list;\n}\n\nRzBinPlugin rz_bin_plugin_luac = {\n\t.name = \"luac\",\n\t.desc = \"LUA Compiled File\",\n\t.license = \"LGPL3\",\n\t.get_sdb = NULL,\n\t.load_buffer = &load_buffer,\n\t.check_buffer = &check_buffer,\n\t.baddr = NULL,\n\t.entries = &entries,\n\t.maps = &rz_bin_maps_of_file_sections,\n\t.sections = &sections,\n\t.symbols = &symbols,\n\t.info = &info,\n\t.strings = &strings,\n};\n\n#ifndef RZ_PLUGIN_INCORE\nRZ_API RzLibStruct rizin_plugin = {\n\t.type = RZ_LIB_TYPE_BIN,\n\t.data = &rz_bin_plugin_luac,\n\t.version = RZ_VERSION\n};\n#endif\n"], "fixing_code": ["// SPDX-License-Identifier: LGPL-3.0-only\n// SPDX-FileCopyrightText: 2021 Heersin <teablearcher@gmail.com>\n\n#include \"luac_common.h\"\n\nvoid luac_add_section(RzList *section_list, char *name, ut64 offset, ut32 size, bool is_func) {\n\tRzBinSection *bin_sec = RZ_NEW0(RzBinSection);\n\tif (!bin_sec) {\n\t\treturn;\n\t}\n\n\tbin_sec->name = rz_str_new(name);\n\tbin_sec->vaddr = bin_sec->paddr = offset;\n\tbin_sec->size = bin_sec->vsize = size;\n\tbin_sec->is_data = false;\n\tbin_sec->bits = is_func ? sizeof(LUA_INSTRUCTION) * 8 : 8;\n\t// bin_sec->has_strings = !is_func;\n\tbin_sec->has_strings = false;\n\tbin_sec->arch = rz_str_new(\"luac\");\n\n\tif (is_func) {\n\t\tbin_sec->perm = RZ_PERM_R | RZ_PERM_X;\n\t} else {\n\t\tbin_sec->perm = RZ_PERM_R;\n\t}\n\n\trz_list_append(section_list, bin_sec);\n}\n\nvoid luac_add_symbol(RzList *symbol_list, char *name, ut64 offset, ut64 size, const char *type) {\n\tRzBinSymbol *bin_sym = RZ_NEW0(RzBinSymbol);\n\tif (!bin_sym) {\n\t\treturn;\n\t}\n\n\tbin_sym->name = rz_str_new(name);\n\tbin_sym->vaddr = bin_sym->paddr = offset;\n\tbin_sym->size = size;\n\tbin_sym->type = type;\n\n\trz_list_append(symbol_list, bin_sym);\n}\n\nvoid luac_add_entry(RzList *entry_list, ut64 offset, int entry_type) {\n\tRzBinAddr *entry = RZ_NEW0(RzBinAddr);\n\tif (!entry) {\n\t\treturn;\n\t}\n\n\tentry->vaddr = offset;\n\tentry->paddr = offset;\n\tentry->type = entry_type;\n\n\trz_list_append(entry_list, entry);\n}\n\nvoid luac_add_string(RzList *string_list, char *string, ut64 offset, ut64 size) {\n\tRzBinString *bin_string = RZ_NEW0(RzBinString);\n\tif (!bin_string) {\n\t\treturn;\n\t}\n\n\tbin_string->paddr = offset;\n\tbin_string->vaddr = offset;\n\tbin_string->size = size;\n\tbin_string->length = size;\n\tbin_string->string = rz_str_new(string);\n\tbin_string->type = RZ_STRING_ENC_UTF8;\n\n\trz_list_append(string_list, bin_string);\n}\n\nstatic void free_rz_section(RzBinSection *section) {\n\tif (!section) {\n\t\treturn;\n\t}\n\n\tif (section->name) {\n\t\tRZ_FREE(section->name);\n\t}\n\n\tif (section->format) {\n\t\tRZ_FREE(section->format);\n\t}\n\n\tRZ_FREE(section);\n}\n\nstatic void free_rz_string(RzBinString *string) {\n\tif (!string) {\n\t\treturn;\n\t}\n\n\tif (string->string) {\n\t\tRZ_FREE(string->string);\n\t}\n\n\tRZ_FREE(string);\n}\n\nstatic void free_rz_addr(RzBinAddr *addr) {\n\tif (!addr) {\n\t\treturn;\n\t}\n\tRZ_FREE(addr);\n}\n\nvoid luac_build_info_free(LuacBinInfo *bin_info) {\n\tif (!bin_info) {\n\t\treturn;\n\t}\n\trz_list_free(bin_info->entry_list);\n\trz_list_free(bin_info->symbol_list);\n\trz_list_free(bin_info->section_list);\n\trz_list_free(bin_info->string_list);\n\tfree(bin_info);\n}\n\nLuacBinInfo *luac_build_info(LuaProto *proto) {\n\tif (!proto) {\n\t\tRZ_LOG_ERROR(\"Invalid luac file\\n\");\n\t\treturn NULL;\n\t}\n\n\tLuacBinInfo *ret = RZ_NEW0(LuacBinInfo);\n\tif (!ret) {\n\t\treturn NULL;\n\t}\n\n\tret->entry_list = rz_list_newf((RzListFree)free_rz_addr);\n\tret->symbol_list = rz_list_newf((RzListFree)rz_bin_symbol_free);\n\tret->section_list = rz_list_newf((RzListFree)free_rz_section);\n\tret->string_list = rz_list_newf((RzListFree)free_rz_string);\n\n\tif (!(ret->entry_list && ret->symbol_list && ret->section_list && ret->string_list)) {\n\t\trz_list_free(ret->entry_list);\n\t\trz_list_free(ret->symbol_list);\n\t\trz_list_free(ret->section_list);\n\t\trz_list_free(ret->string_list);\n\t}\n\n\t_luac_build_info(proto, ret);\n\n\t// add entry of main\n\tut64 main_entry_offset;\n\tmain_entry_offset = proto->code_offset + proto->code_skipped;\n\tluac_add_entry(ret->entry_list, main_entry_offset, RZ_BIN_ENTRY_TYPE_PROGRAM);\n\n\treturn ret;\n}\n\nstatic const char *get_tag_string(ut8 tag) {\n\tswitch (tag) {\n\tcase LUA_VNIL:\n\t\treturn \"CONST_NIL\";\n\tcase LUA_VTRUE:\n\tcase LUA_VFALSE:\n\t\treturn \"CONST_BOOL\";\n\tcase LUA_VSHRSTR:\n\tcase LUA_VLNGSTR:\n\t\treturn \"CONST_STRING\";\n\tcase LUA_VNUMFLT:\n\tcase LUA_VNUMINT:\n\t\treturn \"CONST_NUM\";\n\tdefault:\n\t\treturn \"CONST_UNKNOWN\";\n\t}\n}\n\n/* Heap allocated string */\nstatic char *get_constant_symbol_name(char *proto_name, LuaConstEntry *entry) {\n\trz_return_val_if_fail(entry || proto_name, NULL);\n\tut8 tag = entry->tag;\n\tchar *ret;\n\tint integer_value;\n\tdouble float_value;\n\n\tswitch (tag) {\n\tcase LUA_VNIL:\n\t\tret = rz_str_newf(\"%s_const_nil\", proto_name);\n\t\tbreak;\n\tcase LUA_VTRUE:\n\t\tret = rz_str_newf(\"%s_const_true\", proto_name);\n\t\tbreak;\n\tcase LUA_VFALSE:\n\t\tret = rz_str_newf(\"%s_const_false\", proto_name);\n\t\tbreak;\n\tcase LUA_VSHRSTR:\n\tcase LUA_VLNGSTR:\n\t\trz_return_val_if_fail(entry->data, NULL);\n\t\tret = rz_str_newf(\"%s_const_%s\", proto_name, (char *)entry->data);\n\t\tbreak;\n\tcase LUA_VNUMFLT:\n\t\trz_return_val_if_fail(entry->data, NULL);\n\t\tif (entry->data_len < sizeof(double)) {\n\t\t\treturn NULL;\n\t\t}\n\t\tfloat_value = *(double *)entry->data;\n\t\tret = rz_str_newf(\"%s_const_%f\", proto_name, float_value);\n\t\tbreak;\n\tcase LUA_VNUMINT:\n\t\trz_return_val_if_fail(entry->data, NULL);\n\t\tif (entry->data_len < sizeof(int)) {\n\t\t\treturn NULL;\n\t\t}\n\t\tinteger_value = *(int *)entry->data;\n\t\tret = rz_str_newf(\"%s_const_%d\", proto_name, integer_value);\n\t\tbreak;\n\tdefault:\n\t\tret = rz_str_newf(\"%s_const_0x%llx\", proto_name, entry->offset);\n\t\tbreak;\n\t}\n\treturn ret;\n}\n\n/* Heap allocated string */\nstatic char *simple_build_upvalue_symbol(char *proto_name, LuaUpvalueEntry *entry) {\n\treturn rz_str_newf(\"%s_upvalue_0x%llx\", proto_name, entry->offset);\n}\n\nstatic char *get_upvalue_symbol_name(char *proto_name, LuaUpvalueEntry *entry, char *debug_name) {\n\trz_return_val_if_fail(proto_name || entry, NULL);\n\tif (debug_name == NULL) {\n\t\treturn simple_build_upvalue_symbol(proto_name, entry);\n\t}\n\n\treturn rz_str_newf(\"%s_upvalue_%s\", proto_name, debug_name);\n}\n\nvoid _luac_build_info(LuaProto *proto, LuacBinInfo *info) {\n\t/* process proto header info */\n\tchar *section_name;\n\tchar *symbol_name;\n\tchar *proto_name;\n\tchar **upvalue_names = NULL;\n\tRzListIter *iter;\n\tint i = 0; // iter\n\n\tut64 current_offset;\n\tut64 current_size;\n\n\t// 0. check if stripped (proto name is lost)\n\tif (proto->name_size == 0 || proto->proto_name == NULL) {\n\t\t// replace name with current offset\n\t\tproto_name = rz_str_newf(\"fcn.%08llx\", proto->offset);\n\t} else {\n\t\tproto_name = rz_str_new((char *)proto->proto_name);\n\t}\n\n\t// 1.1 set section name as function_name.header\n\tcurrent_offset = proto->offset;\n\tcurrent_size = proto->size;\n\tsection_name = rz_str_newf(\"%s.header\", proto_name);\n\tluac_add_section(info->section_list, section_name, current_offset, current_size, false);\n\tRZ_FREE(section_name);\n\n\t// 1.2 set section name as function_name.code\n\tcurrent_offset = proto->code_offset;\n\tcurrent_size = proto->code_size;\n\tsection_name = rz_str_newf(\"%s.code\", proto_name);\n\tluac_add_section(info->section_list, section_name, current_offset, current_size, true);\n\tRZ_FREE(section_name);\n\n\t// 1.3 set const section\n\tcurrent_offset = proto->const_offset;\n\tcurrent_size = proto->const_size;\n\tsection_name = rz_str_newf(\"%s.const\", proto_name);\n\tluac_add_section(info->section_list, section_name, current_offset, current_size, false);\n\tRZ_FREE(section_name);\n\n\t// 1.4 upvalue section\n\tcurrent_offset = proto->upvalue_offset;\n\tcurrent_size = proto->upvalue_size;\n\tsection_name = rz_str_newf(\"%s.upvalues\", proto_name);\n\tluac_add_section(info->section_list, section_name, current_offset, current_size, false);\n\tRZ_FREE(section_name);\n\n\t// 1.5 inner protos section\n\tcurrent_offset = proto->inner_proto_offset;\n\tcurrent_size = proto->inner_proto_size;\n\tsection_name = rz_str_newf(\"%s.protos\", proto_name);\n\tluac_add_section(info->section_list, section_name, current_offset, current_size, false);\n\tRZ_FREE(section_name);\n\n\t// 1.6 debug section\n\tcurrent_offset = proto->debug_offset;\n\tcurrent_size = proto->debug_size;\n\tsection_name = rz_str_newf(\"%s.debug\", proto_name);\n\tluac_add_section(info->section_list, section_name, current_offset, current_size, false);\n\tRZ_FREE(section_name);\n\n\t// 2.1 parse local var info\n\tLuaLocalVarEntry *local_var_entry;\n\trz_list_foreach (proto->local_var_info_entries, iter, local_var_entry) {\n\t\tluac_add_string(\n\t\t\tinfo->string_list,\n\t\t\t(char *)local_var_entry->varname,\n\t\t\tlocal_var_entry->offset,\n\t\t\tlocal_var_entry->varname_len);\n\t}\n\n\t// 2.2 parse debug_upvalues\n\tsize_t real_upvalue_cnt = rz_list_length(proto->upvalue_entries);\n\tif (real_upvalue_cnt > 0) {\n\t\tLuaDbgUpvalueEntry *debug_upv_entry;\n\t\tupvalue_names = RZ_NEWS0(char *, real_upvalue_cnt);\n\t\tif (!upvalue_names) {\n\t\t\tfree(proto_name);\n\t\t\treturn;\n\t\t}\n\n\t\ti = 0;\n\t\trz_list_foreach (proto->dbg_upvalue_entries, iter, debug_upv_entry) {\n\t\t\tupvalue_names[i] = (char *)debug_upv_entry->upvalue_name;\n\t\t\tluac_add_string(\n\t\t\t\tinfo->string_list,\n\t\t\t\tupvalue_names[i],\n\t\t\t\tdebug_upv_entry->offset,\n\t\t\t\tdebug_upv_entry->name_len);\n\t\t\ti++;\n\t\t}\n\t}\n\n\t// 3.1 construct constant symbols\n\tLuaConstEntry *const_entry;\n\trz_list_foreach (proto->const_entries, iter, const_entry) {\n\t\tsymbol_name = get_constant_symbol_name(proto_name, const_entry);\n\t\tluac_add_symbol(\n\t\t\tinfo->symbol_list,\n\t\t\tsymbol_name,\n\t\t\tconst_entry->offset,\n\t\t\tconst_entry->data_len,\n\t\t\tget_tag_string(const_entry->tag));\n\t\tif (const_entry->tag == LUA_VLNGSTR || const_entry->tag == LUA_VSHRSTR) {\n\t\t\tluac_add_string(\n\t\t\t\tinfo->string_list,\n\t\t\t\t(char *)const_entry->data,\n\t\t\t\tconst_entry->offset,\n\t\t\t\tconst_entry->data_len);\n\t\t}\n\t\tRZ_FREE(symbol_name);\n\t}\n\n\t// 3.2 construct upvalue symbols\n\tLuaUpvalueEntry *upvalue_entry;\n\ti = 0;\n\trz_list_foreach (proto->upvalue_entries, iter, upvalue_entry) {\n\t\tsymbol_name = get_upvalue_symbol_name(proto_name, upvalue_entry, upvalue_names[i++]);\n\t\tluac_add_symbol(\n\t\t\tinfo->symbol_list,\n\t\t\tsymbol_name,\n\t\t\tupvalue_entry->offset,\n\t\t\t3,\n\t\t\t\"UPVALUE\");\n\t\tRZ_FREE(symbol_name);\n\t}\n\n\t// 4. parse sub proto\n\tLuaProto *sub_proto;\n\trz_list_foreach (proto->proto_entries, iter, sub_proto) {\n\t\t_luac_build_info(sub_proto, info);\n\t}\n\n\tfree(upvalue_names);\n\tfree(proto_name);\n}\n", "// SPDX-License-Identifier: LGPL-3.0-only\n// SPDX-FileCopyrightText: 2021 Heersin <teablearcher@gmail.com>\n\n// put common definition of luac\n\n#ifndef BUILD_LUAC_COMMON_H\n#define BUILD_LUAC_COMMON_H\n\n#include <rz_bin.h>\n#include <rz_lib.h>\n#include <rz_list.h>\n\ntypedef ut32 LUA_INSTRUCTION;\n\n/* Macros About Luac Format */\n#define LUAC_MAGIC_OFFSET   0x00\n#define LUAC_MAGIC_SIZE     4\n#define LUAC_VERSION_OFFSET 0x04\n#define LUAC_VERSION_SIZE   1\n\n#define LUAC_MAGIC \"\\x1b\\x4c\\x75\\x61\"\n\n/* Lua Constant Tag */\n#define makevariant(t, v) ((t) | ((v) << 4))\n\n#define LUA_TNIL     0\n#define LUA_TBOOLEAN 1\n#define LUA_TNUMBER  3\n#define LUA_TSTRING  4\n\n#define LUA_VNIL    makevariant(LUA_TNIL, 0)\n#define LUA_VFALSE  makevariant(LUA_TBOOLEAN, 0)\n#define LUA_VTRUE   makevariant(LUA_TBOOLEAN, 1)\n#define LUA_VNUMINT makevariant(LUA_TNUMBER, 0) /* integer numbers */\n#define LUA_VNUMFLT makevariant(LUA_TNUMBER, 1) /* float numbers */\n#define LUA_VSHRSTR makevariant(LUA_TSTRING, 0) /* short strings */\n#define LUA_VLNGSTR makevariant(LUA_TSTRING, 1) /* long strings */\n\n/**\n *  \\struct lua_proto_ex\n *  \\brief Store valuable info when parsing. Treat luac file body as a main function.\n */\ntypedef struct lua_proto_ex {\n\tut64 offset; ///< proto offset in bytes\n\tut64 size; ///< current proto size\n\n\tut8 *proto_name; ///<  current proto name\n\tint name_size; ///< size of proto name\n\n\tut64 line_defined; ///< line number of function start\n\tut64 lastline_defined; ///< line number of function end\n\n\tut8 num_params; ///< number of parameters of this proto\n\tut8 is_vararg; ///< is variable arg?\n\tut8 max_stack_size; ///< max stack size\n\n\t/* Code of this proto */\n\tut64 code_offset; ///< code section offset\n\tut64 code_size; ///< code section size\n\tut64 code_skipped; ///< opcode data offset to code_offset.\n\n\t/* store constant entries */\n\tRzList *const_entries; ///< A list to store constant entries\n\tut64 const_offset; ///< const section offset\n\tut64 const_size; ///< const section size\n\n\t/* store upvalue entries */\n\tRzList *upvalue_entries; ///< A list to store upvalue entries\n\tut64 upvalue_offset; ///< upvalue section offset\n\tut64 upvalue_size; ///< upvalue section size\n\n\t/* store protos defined in this proto */\n\tRzList *proto_entries; ///< A list to store sub proto entries\n\tut64 inner_proto_offset; ///< sub proto section offset\n\tut64 inner_proto_size; ///< sub proto section size\n\n\t/* store Debug info */\n\tut64 debug_offset; ///< debug section offset\n\tut64 debug_size; ///< debug section size\n\tRzList *line_info_entries; ///< A list to store line info entries\n\tRzList *abs_line_info_entries; ///< A list to store absolutely line info entries\n\tRzList *local_var_info_entries; ///< A list to store local var entries\n\tRzList *dbg_upvalue_entries; ///< A list to store upvalue names\n\n} LuaProtoHeavy;\n\ntypedef LuaProtoHeavy LuaProto;\n\n/**\n * \\struct lua_constant_entry\n * \\brief Store constant type, data, and offset of this constant in luac file\n */\ntypedef struct lua_constant_entry {\n\tut8 tag; ///< type of this constant, see LUA_V* macros in luac_common.h\n\tvoid *data; ///< can be Number/Integer/String\n\tint data_len; ///< len of data\n\tut64 offset; ///< addr of this constant\n} LuaConstEntry;\n\n/**\n * \\struct lua_upvalue_entry\n * \\brief Store upvalue attributes\n */\ntypedef struct lua_upvalue_entry {\n\t/* attributes of upvalue */\n\tut8 instack; ///< is in stack\n\tut8 idx; ///< index\n\tut8 kind; ///< kind\n\tut64 offset; ///< offset of this upvalue\n} LuaUpvalueEntry;\n\ntypedef struct LuaProto LuaProtoEntry;\n\n/**\n * \\struct lua_lineinfo_entry\n * \\brief Store line info attributes\n */\ntypedef struct lua_lineinfo_entry {\n\tut32 info_data;\n\tut64 offset;\n} LuaLineinfoEntry;\n\n/**\n * \\struct lua_abs_lineinfo_entry\n * \\brief Store line info attributes\n */\ntypedef struct lua_abs_lineinfo_entry {\n\tint pc; ///< pc value of lua\n\tint line; ///< line number in source file\n\tut64 offset;\n} LuaAbsLineinfoEntry;\n\n/**\n * \\struct lua_local_var_entry\n * \\brief Store local var names and other info\n */\ntypedef struct lua_local_var_entry {\n\tut8 *varname; ///< name of this variable\n\tint varname_len; ///< length of name\n\tint start_pc; ///< first active position\n\tint end_pc; ///< first deactive position\n\tut64 offset; ///< offset of this entry\n} LuaLocalVarEntry;\n\n/**\n * \\struct lua_dbg_upvalue_entry\n * \\brief Store upvalue's debug info\n */\ntypedef struct lua_dbg_upvalue_entry {\n\tut8 *upvalue_name; ///< upvalue name\n\tint name_len; ///< length of name\n\tut64 offset;\n} LuaDbgUpvalueEntry;\n\n/**\n * \\struct lua_bin_info\n * \\brief A context info structure for luac plugin.\n */\ntypedef struct luac_bin_info {\n\tst32 major; ///< major version\n\tst32 minor; ///< minor version\n\tRzList *section_list; ///< list of sections\n\tRzList *symbol_list; ///< list of symbols\n\tRzList *entry_list; ///< list of entries\n\tRzList *string_list; ///< list of strings\n\tRzBinInfo *general_info; ///< general binary info from luac header\n} LuacBinInfo;\n\n/* ========================================================\n * Common Operation to Lua structures\n * Implemented in 'bin/format/luac/luac_common.c'\n * ======================================================== */\nLuaDbgUpvalueEntry *lua_new_dbg_upvalue_entry();\nLuaLocalVarEntry *lua_new_local_var_entry();\nLuaAbsLineinfoEntry *lua_new_abs_lineinfo_entry();\nLuaLineinfoEntry *lua_new_lineinfo_entry();\nLuaUpvalueEntry *lua_new_upvalue_entry();\nLuaConstEntry *lua_new_const_entry();\nLuaProto *lua_new_proto_entry();\n\nvoid lua_free_dbg_upvalue_entry(LuaDbgUpvalueEntry *);\nvoid lua_free_local_var_entry(LuaLocalVarEntry *);\nvoid lua_free_const_entry(LuaConstEntry *);\nvoid lua_free_proto_entry(LuaProto *);\n\n/* ========================================================\n * Common Operation to RzBinInfo\n * Implemented in 'bin/format/luac/luac_bin.c'\n * ======================================================== */\nvoid luac_add_section(RzList *section_list, char *name, ut64 offset, ut32 size, bool is_func);\nvoid luac_add_symbol(RzList *symbol_list, char *name, ut64 offset, ut64 size, const char *type);\nvoid luac_add_entry(RzList *entry_list, ut64 offset, int entry_type);\nvoid luac_add_string(RzList *string_list, char *string, ut64 offset, ut64 size);\n\nLuacBinInfo *luac_build_info(LuaProto *proto);\nvoid luac_build_info_free(LuacBinInfo *bin_info);\nvoid _luac_build_info(LuaProto *proto, LuacBinInfo *info);\n\n/* ========================================================\n * Export version specified Api to bin_luac.c\n * Implemented in 'bin/format/luac/v[version]/bin_[version]\n * ======================================================== */\nRzBinInfo *lua_parse_header_54(RzBinFile *bf, st32 major, st32 minor);\nLuaProto *lua_parse_body_54(RzBuffer *buffer, ut64 offset, ut64 data_size);\n\nRzBinInfo *lua_parse_header_53(RzBinFile *bf, st32 major, st32 minor);\nLuaProto *lua_parse_body_53(RzBuffer *buffer, ut64 offset, ut64 data_size);\n\n#define lua_check_error_offset(offset) \\\n\tif ((offset) == 0) { \\\n\t\treturn 0; \\\n\t}\n#define lua_check_error_offset_proto(offset, proto) \\\n\tif ((offset) == 0) { \\\n\t\tlua_free_proto_entry((proto)); \\\n\t\treturn NULL; \\\n\t}\n#define lua_return_if_null(proto) \\\n\tif ((proto) == NULL) { \\\n\t\treturn 0; \\\n\t}\n\n#endif // BUILD_LUAC_COMMON_H\n", "// SPDX-License-Identifier: LGPL-3.0-only\n// SPDX-FileCopyrightText: 2021 Heersin <teablearcher@gmail.com>\n\n#include <rz_bin.h>\n#include <rz_lib.h>\n#include \"librz/bin/format/luac/luac_common.h\"\n\n#define GET_INTERNAL_BIN_INFO_OBJ(bf) ((LuacBinInfo *)(bf)->o->bin_obj)\n\nstatic bool check_buffer(RzBuffer *buff) {\n\tif (rz_buf_size(buff) > 4) {\n\t\tut8 buf[LUAC_MAGIC_SIZE];\n\t\trz_buf_read_at(buff, LUAC_MAGIC_OFFSET, buf, LUAC_MAGIC_SIZE);\n\t\treturn !memcmp(buf, LUAC_MAGIC, LUAC_MAGIC_SIZE);\n\t}\n\treturn false;\n}\n\nstatic bool load_buffer(RzBinFile *bf, RzBinObject *obj, RzBuffer *buf, Sdb *sdb) {\n\tut8 MAJOR_MINOR_VERSION;\n\tLuacBinInfo *bin_info_obj = NULL;\n\tLuaProto *proto = NULL;\n\tRzBinInfo *general_info = NULL;\n\tst32 major;\n\tst32 minor;\n\n\trz_buf_read_at(buf, LUAC_VERSION_OFFSET, &MAJOR_MINOR_VERSION, sizeof(MAJOR_MINOR_VERSION)); /* 1-byte in fact */\n\tif ((bin_info_obj = RZ_NEW(LuacBinInfo)) == NULL) {\n\t\treturn false;\n\t}\n\tmajor = (MAJOR_MINOR_VERSION & 0xF0) >> 4;\n\tminor = (MAJOR_MINOR_VERSION & 0x0F);\n\n\tif (major != 5) {\n\t\tRZ_LOG_ERROR(\"currently support lua 5.x only\\n\");\n\t\treturn false;\n\t}\n\n\tswitch (minor) {\n\tcase 4:\n\t\tproto = lua_parse_body_54(buf, 0x20, bf->size);\n\t\tgeneral_info = lua_parse_header_54(bf, major, minor);\n\t\tbreak;\n\tcase 3:\n\t\tproto = lua_parse_body_53(buf, 0x22, bf->size);\n\t\tgeneral_info = lua_parse_header_53(bf, major, minor);\n\t\tbreak;\n\tdefault:\n\t\tRZ_LOG_ERROR(\"lua 5.%c not support now\\n\", minor + '0');\n\t\treturn false;\n\t}\n\n\tbin_info_obj = luac_build_info(proto);\n\tif (bin_info_obj == NULL) {\n\t\tlua_free_proto_entry(proto);\n\t\trz_bin_info_free(general_info);\n\t\treturn false;\n\t}\n\tbin_info_obj->general_info = general_info;\n\tbin_info_obj->major = major;\n\tbin_info_obj->minor = minor;\n\n\tlua_free_proto_entry(proto);\n\tproto = NULL;\n\n\tobj->bin_obj = bin_info_obj;\n\treturn true;\n}\n\nstatic RzBinInfo *info(RzBinFile *bf) {\n\tif (!bf) {\n\t\treturn NULL;\n\t}\n\tLuacBinInfo *bin_info_obj = GET_INTERNAL_BIN_INFO_OBJ(bf);\n\tif (!bin_info_obj) {\n\t\treturn NULL;\n\t}\n\n\treturn bin_info_obj->general_info;\n}\n\nstatic RzList *sections(RzBinFile *bf) {\n\tif (!bf) {\n\t\treturn NULL;\n\t}\n\tLuacBinInfo *bin_info_obj = GET_INTERNAL_BIN_INFO_OBJ(bf);\n\tif (!bin_info_obj) {\n\t\treturn NULL;\n\t}\n\n\treturn rz_list_clone(bin_info_obj->section_list);\n}\n\nstatic RzList *symbols(RzBinFile *bf) {\n\tif (!bf) {\n\t\treturn NULL;\n\t}\n\tLuacBinInfo *bin_info_obj = GET_INTERNAL_BIN_INFO_OBJ(bf);\n\tif (!bin_info_obj) {\n\t\treturn NULL;\n\t}\n\n\treturn rz_list_clone(bin_info_obj->symbol_list);\n}\n\nstatic RzList *entries(RzBinFile *bf) {\n\tif (!bf) {\n\t\treturn NULL;\n\t}\n\tLuacBinInfo *bin_info_obj = GET_INTERNAL_BIN_INFO_OBJ(bf);\n\tif (!bin_info_obj) {\n\t\treturn NULL;\n\t}\n\n\treturn rz_list_clone(bin_info_obj->entry_list);\n}\n\nstatic RzList *strings(RzBinFile *bf) {\n\tif (!bf) {\n\t\treturn NULL;\n\t}\n\tLuacBinInfo *bin_info_obj = GET_INTERNAL_BIN_INFO_OBJ(bf);\n\tif (!bin_info_obj) {\n\t\treturn NULL;\n\t}\n\n\treturn rz_list_clone(bin_info_obj->string_list);\n}\n\nstatic void destroy(RzBinFile *bf) {\n\tLuacBinInfo *bin_info_obj = GET_INTERNAL_BIN_INFO_OBJ(bf);\n\tluac_build_info_free(bin_info_obj);\n}\n\nRzBinPlugin rz_bin_plugin_luac = {\n\t.name = \"luac\",\n\t.desc = \"LUA Compiled File\",\n\t.license = \"LGPL3\",\n\t.get_sdb = NULL,\n\t.load_buffer = &load_buffer,\n\t.destroy = &destroy,\n\t.check_buffer = &check_buffer,\n\t.baddr = NULL,\n\t.entries = &entries,\n\t.maps = &rz_bin_maps_of_file_sections,\n\t.sections = &sections,\n\t.symbols = &symbols,\n\t.info = &info,\n\t.strings = &strings,\n};\n\n#ifndef RZ_PLUGIN_INCORE\nRZ_API RzLibStruct rizin_plugin = {\n\t.type = RZ_LIB_TYPE_BIN,\n\t.data = &rz_bin_plugin_luac,\n\t.version = RZ_VERSION\n};\n#endif\n"], "filenames": ["librz/bin/format/luac/luac_bin.c", "librz/bin/format/luac/luac_common.h", "librz/bin/p/bin_luac.c"], "buggy_code_start_loc": [73, 195, 103], "buggy_code_end_loc": [357, 195, 135], "fixing_code_start_loc": [72, 196, 103], "fixing_code_end_loc": [367, 197, 142], "type": "CWE-787", "message": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting data from Luac files. A user opening a malicious Luac file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commits 07b43bc8aa1ffebd9b68d60624c9610cf7e460c7 and 05bbd147caccc60162d6fba9baaaf24befa281cd contain fixes for the issue.", "other": {"cve": {"id": "CVE-2022-36044", "sourceIdentifier": "security-advisories@github.com", "published": "2022-09-06T20:15:08.807", "lastModified": "2023-03-30T04:15:09.657", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "Rizin is a UNIX-like reverse engineering framework and command-line toolset. Versions 0.4.0 and prior are vulnerable to an out-of-bounds write when getting data from Luac files. A user opening a malicious Luac file could be affected by this vulnerability, allowing an attacker to execute code on the user's machine. Commits 07b43bc8aa1ffebd9b68d60624c9610cf7e460c7 and 05bbd147caccc60162d6fba9baaaf24befa281cd contain fixes for the issue."}, {"lang": "es", "value": "Rizin es un framework de ingenier\u00eda inversa de tipo UNIX y un conjunto de herramientas de l\u00ednea de comandos. Las versiones 0.4.0 y anteriores son vulnerables a una escritura fuera de l\u00edmites cuando obtienen datos de archivos Luac. Un usuario que abra un archivo Luac malicioso podr\u00eda verse afectado por esta vulnerabilidad, permitiendo a un atacante ejecutar c\u00f3digo en la m\u00e1quina del usuario. Los commits 07b43bc8aa1ffebd9b68d60624c9610cf7e460c7 y 05bbd147caccc60162d6fba9baaaf24befa281cd contienen correcciones para este problema.\n"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.9}]}, "weaknesses": [{"source": "security-advisories@github.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:rizin:rizin:*:*:*:*:*:*:*:*", "versionEndIncluding": "0.4.0", "matchCriteriaId": "5E797DF4-7DCA-46AA-9A36-5C0064FE79CA"}]}]}], "references": [{"url": "https://github.com/rizinorg/rizin/commit/05bbd147caccc60162d6fba9baaaf24befa281cd", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rizinorg/rizin/commit/07b43bc8aa1ffebd9b68d60624c9610cf7e460c7", "source": "security-advisories@github.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/rizinorg/rizin/security/advisories/GHSA-mqcj-82c6-gh5q", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/WQZLMHEI5D7EJASA5UW6XN4ODHLRHK6N/", "source": "security-advisories@github.com"}, {"url": "https://security.gentoo.org/glsa/202209-06", "source": "security-advisories@github.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/rizinorg/rizin/commit/05bbd147caccc60162d6fba9baaaf24befa281cd"}}