{"buggy_code": ["'use strict';\n\n// Declare app level module which depends on views, and components\nvar app = angular.module('myApp', [\n  'ngRoute',\n  'myApp.tests',\n  'myApp.stats',\n  'myApp.version'\n]).\nconfig(['$routeProvider', function($routeProvider) {\n  $routeProvider.otherwise({redirectTo: '/tests'});\n}]);\n\napp.controller('projectCtrl', function($scope, $location, $http, myFactory) {\n\t$scope.project = {};\n\t\n\t$http.get('http://localhost:4968/getProjects').success(function(data, status, headers, config) {\t\t\n\t\t$scope.projects = data;  \n\t}).error(function(data, status, headers, config) {\n\t\tvar objs = [];\n\t\tobjs[0] = {name : \"Uh-oh - error fetching project\", error : \"Couldn't connect to local server on port 4968.\"};\n\t\t$scope.projects = objs;\n\t});\n\t\n\t$scope.init = function () {\n\t\tmyFactory.set(\"tests_Default\");\n\t\t$scope.project.name = \"Default\";\n\t};\n\t\n\t$scope.switchProject = function(project){\n\t\tmyFactory.set(project);\n\t\t$scope.project.name = project.substring(6);\n\t\t$location.path('/app/index.html#/view1');\n\t};\n});\n\napp.factory('myFactory', function() {\n\tvar savedData = {};\n\tfunction set(data) {\n\t\tsavedData = data;\n\t}\n\tfunction get() {\n\t\treturn savedData;\n\t}\n\n\treturn {\n\t\tset: set,\n\t\tget: get\n\t}\n\n});\n", "var http = require('http');\nvar url = require('url');\nvar mysql = require('mysql');\n\n/**\n * Database connection\n */\nvar connection = mysql.createConnection({\n\thost     : 'localhost',\n\tdatabase : 'tests',\n\tuser     : 'root',\n\tpassword : 'root',\n});\n\n/**\n * Gets the 'test' objects from the database\n * @param response Response to write the test to\n * @param callback Function to map sub objects to the list of tests\n */\nfunction getTestObjects(response, table ,callback){\n\tvar tests = [];\n\tvar query = connection.query(\"SELECT * FROM \"+table+\" ORDER BY id DESC\", function(err, rows, fields) {\n\t\tif (err) {\n\t\t\tconsole.log(err);\n\t\t} else {\n\t\t\tfor(var i = 0; i < rows.length; i++){\n\t\t\t\trows[i].notes = [];\n\t\t\t\ttests[i] = rows[i];\n\t\t\t}\n\t\t}\n\t});\n\n\tquery.on('end',function(){\n\t\tif(callback){\n\t\t\tcallback(response,tests, table);\n\t\t}\n\t\telse {\n\t\t\tresponse.write(JSON.stringify(tests));\n\t\t\tresponse.end();\n\t\t}\n\t});\n}\n\nfunction getStats(response, filter, table){\n\tvar stats = [];\n\tvar query;\n\tif(filter === \"all\"){\n\t\tquery = connection.query(\"SELECT (SELECT COUNT(*) FROM \"+table+\" WHERE status = 'success') AS success, \"+ \n\t\t\t\t\"(SELECT COUNT(*) FROM \"+table+\" WHERE status = 'danger') as failure, \"+\n\t\t\t\t\"(SELECT COUNT(*) FROM \"+table+\" WHERE status != 'success' AND status != 'danger') as other\", function(err, rows, fields) {\n\t\t\tif (err) {\n\t\t\t\tconsole.log(err);\n\t\t\t} else {\n\t\t\t\tfor(var i = 0; i < rows.length; i++){\n\t\t\t\t\tstats[i] = rows[i];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tquery.on('end',function(){\n\t\t\tresponse.write(JSON.stringify(stats));\n\t\t\tresponse.end();\n\t\t});\t\n\t}\n}\n\n/**\n * Gets the notes and adds them to the 'test' objects.\n * There is probably one query that could be ran to pull this info\n * into and object, to simplify code but only way I was skilled enough to  was \n * first select 'tests' then manually add 'notes' to them with another\n * select statement. \n * @param response Response to write the tests to\n * @param tests Array of tests from the DB\n */\nfunction getAddNotesToTests(response, tests, table){\n\tvar notes = [];\n\tvar query = connection.query('SELECT * FROM notes_'+table.substring(6), function(err, rows, fields) {\n\t\tif (err) {\n\t\t\tconsole.log(err);\n\t\t} else {\n\t\t\tfor(var i = 0; i < rows.length; i++){\n\t\t\t\tnotes[i] = rows[i];\n\t\t\t}\n\t\t}\n\t});\n\n\tquery.on('end',function(){\n\t\tfor(var i = 0; i < tests.length; i++){\n\t\t\tvar test = tests[i];\n\t\t\tfor(var j = 0; j < notes.length; j++){\n\t\t\t\tvar note = notes[j];\n\t\t\t\tif(note.testId === test.id){\n\t\t\t\t\ttest.notes.push(note);\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\t\tresponse.write(JSON.stringify(tests));\n\t\tresponse.end();\n\t});\n}\n\n/**\n * Gets the tables in the database to fill the projects drop down\n * @param response Response to return\n */\nfunction getProjectTables(response){\n\tvar projects = [];\n\tvar query = connection.query(\"SELECT TABLE_NAME as project FROM information_schema.tables WHERE TABLE_NAME LIKE 'test_%'\", function(err, rows, fields) {\n\t\tif (err) {\n\t\t\tconsole.log(err);\n\t\t} else {\n\t\t\tfor(var i = 0; i < rows.length; i++){\n\t\t\t\tprojects[i] = rows[i];\n\t\t\t}\n\t\t}\n\t});\n\n\tquery.on('end',function(){\n\t\tfor(var j = 0; j < projects.length; j++){\n\t\t\tvar project ={};\n\t\t\tproject.db = projects[j].project;\n\t\t\tproject.name = projects[j].project.substring(6);\n\t\t\tprojects[j] = project;\n\t\t}\n\t\tresponse.write(JSON.stringify(projects));\n\t\tresponse.end();\n\t});\n}\n\n/**\n * Adds a note to a test\n * @param response The response to send back\n * @param note Note object to add\n */\nfunction addNote(request, response, note){\n\tvar parts = url.parse(request.url,true);\n\tvar query = connection.query(\"INSERT INTO notes_\"+(parts.query.table).substring(6)+\" (testId,who,note) VALUES (\"+note.testId+\",'\" + note.who + \"','\"+note.note+\"')\", function(err, rows, fields) {\n\t\tif (err) {\n\t\t\tresponse.statusCode = 400;\n\t\t\tconsole.log(err);\n\t\t} \n\t});\n\n\tquery.on('end',function(){\n\t\tresponse.end();\n\t});\n}\n\n/**\n * Handles requests to add a 'test' to the DB\n * @param request The http request\n * @param response The http response\n * @param body The data from the post request\n */\nfunction addTest(request, response, body){\n\tvar table = body.table;\n\tvar test = body.result;\n\tvar start = new Date(Number(test.start));\n\tvar end = new Date(Number(test.end));\n\n\t//Format to YYYY-MM-DD HH:MM:SS\n\tstart = start.getFullYear()+\"-\"+(start.getMonth()+1)+\"-\"+start.getDate()+\" \"+start.getHours()+\":\"+start.getMinutes()+\":\"+start.getSeconds();\n\tend = end.getFullYear()+\"-\"+(end.getMonth()+1)+\"-\"+end.getDate()+\" \"+end.getHours()+\":\"+end.getMinutes()+\":\"+end.getSeconds();\n\n\tvar queryStr = \"INSERT INTO \"+table+\" (name,param,error,start,end,status,extra,runInfo) VALUES ('\"+test.name+\"','\" + test.param + \"','\"+test.error+ \"','\"+start+ \"','\"+end+ \"','\"+test.status+ \"','\"+test.extra+ \"','\"+test.runInfo+\"')\";\n\tvar query = connection.query(queryStr, function(err, rows, fields) {\n\t\tif (err) {\n\t\t\tresponse.statusCode = 400;\n\t\t\tconsole.log(err);\n\t\t} \n\t});\n\n\tquery.on('end',function(){\n\t\tresponse.end();\n\t});\n}\n\n/**\n * Function handles JSON POST requests, will read the data and once done\n * dispatch the request and response the the action function\n * @param request The http request\n * @param response The http response\n * @param action The function to be ran once the body is read\n */\nfunction handlePost(request, response, action){\n\tresponse.statusCode = 200;\n\tresponse.setHeader('Access-Control-Allow-Origin', 'http://localhost:8000');\n\tresponse.setHeader('Access-Control-Allow-Methods', 'POST');\n\tresponse.setHeader('Access-Control-Allow-Headers', 'Content-Type');\n\tvar body = '';\t\n\trequest.on('data', function (data) {\n\t\tbody += data;\n\t});\t\t\n\trequest.on('error', function(e) {\n\t\tconsole.log('Bad post');\n\t\tresponse.statusCode = 400;\n\t\tresponse.end();\n\t});\t\t\n\trequest.on('end', function () {\n\t\t//TODO Mysterious blank post is sent (below work around)\n\t\tif(body.length){\n\t\t\taction(request, response, JSON.parse(body));\n\t\t} else{\n\t\t\tresponse.end();\n\t\t}\n\t});\n}\n\n/**\n * Server, so far just handles request to /getTestData\n */\nvar server = http.createServer(function (request,response){\n\tvar parts = url.parse(request.url,true);\n\tvar path = parts.path;\n\tresponse.setHeader('Access-Control-Allow-Origin', 'http://localhost:8000');\n\tresponse.setHeader('Access-Control-Allow-Methods', 'GET');\n\tif(path.indexOf(\"/getTestData?table=\") === 0){\n\t\tresponse.statusCode = 200;\n\t\tgetTestObjects(response, parts.query.table, getAddNotesToTests);\n\t} else if(path.indexOf(\"/getStats?filter\") === 0){\n\t\tresponse.statusCode = 200;\n\t\tgetStats(response,parts.query.filter,parts.query.table);\n\t} else if(parts.pathname === \"/addNote\"){\n\t\thandlePost(request, response, addNote);\n\t} else if(path === \"/addTest\") {\n\t\thandlePost(request, response, addTest);\n\t} else if(path === \"/getProjects\"){\n\t\tresponse.statusCode = 200;\n\t\tgetProjectTables(response);\n\t} else {\n\t\tresponse.statusCode = 404;\n\t\tresponse.write(\"Invalid\")\n\t\tresponse.end();\n\t}\n});\n\nserver.listen(4968);\nconsole.log(\"Server Started on port 4968\");"], "fixing_code": ["'use strict';\n\n// Declare app level module which depends on views, and components\nvar app = angular.module('myApp', [\n  'ngRoute',\n  'myApp.tests',\n  'myApp.stats',\n  'myApp.version'\n]).\nconfig(['$routeProvider', function($routeProvider) {\n  $routeProvider.otherwise({redirectTo: '/tests'});\n}]);\n\napp.controller('projectCtrl', function($scope, $location, $http, myFactory) {\n\t$scope.project = {};\n\t\n\t$http.get('http://localhost:4968/getProjects').success(function(data, status, headers, config) {\t\t\n\t\t$scope.projects = data;  \n\t}).error(function(data, status, headers, config) {\n\t\tvar objs = [];\n\t\tobjs[0] = {name : \"Uh-oh - error fetching project\", error : \"Couldn't connect to local server on port 4968.\"};\n\t\t$scope.projects = objs;\n\t});\n\t\n\t$scope.init = function () {\n\t\tmyFactory.set(\"tests_Default\");\n\t\t$scope.project.name = \"Default\";\n\t};\n\t\n\t$scope.switchProject = function(project){\n\t\tmyFactory.set(project);\n\t\t$scope.project.name = project.substring(6);\n\t\t$location.path('/app/index.html#/tests');\n\t};\n});\n\napp.factory('myFactory', function() {\n\tvar savedData = {};\n\tfunction set(data) {\n\t\tsavedData = data;\n\t}\n\tfunction get() {\n\t\treturn savedData;\n\t}\n\n\treturn {\n\t\tset: set,\n\t\tget: get\n\t}\n\n});\n", "var http = require('http');\nvar url = require('url');\nvar mysql = require('mysql');\n\n/**\n * Database connection\n */\nvar connection = mysql.createConnection({\n\thost     : 'localhost',\n\tdatabase : 'tests',\n\tuser     : 'root',\n\tpassword : 'root',\n});\n\n/**\n * Gets the 'test' objects from the database\n * @param response Response to write the test to\n * @param callback Function to map sub objects to the list of tests\n */\nfunction getTestObjects(response, table ,callback){\n\tvar tests = [];\n\tvar query = connection.query(\"SELECT * FROM \"+table+\" ORDER BY id DESC\", function(err, rows, fields) {\n\t\tif (err) {\n\t\t\tconsole.log(err);\n\t\t} else {\n\t\t\tfor(var i = 0; i < rows.length; i++){\n\t\t\t\trows[i].notes = [];\n\t\t\t\ttests[i] = rows[i];\n\t\t\t}\n\t\t}\n\t});\n\n\tquery.on('end',function(){\n\t\tif(callback){\n\t\t\tcallback(response,tests, table);\n\t\t}\n\t\telse {\n\t\t\tresponse.write(JSON.stringify(tests));\n\t\t\tresponse.end();\n\t\t}\n\t});\n}\n\nfunction getStats(response, filter, table){\n\tvar stats = [];\n\tvar query;\n\tif(filter === \"all\"){\n\t\tquery = connection.query(\"SELECT (SELECT COUNT(*) FROM \"+table+\" WHERE status = 'success') AS success, \"+ \n\t\t\t\t\"(SELECT COUNT(*) FROM \"+table+\" WHERE status = 'danger') as failure, \"+\n\t\t\t\t\"(SELECT COUNT(*) FROM \"+table+\" WHERE status != 'success' AND status != 'danger') as other\", function(err, rows, fields) {\n\t\t\tif (err) {\n\t\t\t\tconsole.log(err);\n\t\t\t} else {\n\t\t\t\tfor(var i = 0; i < rows.length; i++){\n\t\t\t\t\tstats[i] = rows[i];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tquery.on('end',function(){\n\t\t\tresponse.write(JSON.stringify(stats));\n\t\t\tresponse.end();\n\t\t});\t\n\t}\n}\n\n/**\n * Gets the notes and adds them to the 'test' objects.\n * There is probably one query that could be ran to pull this info\n * into and object, to simplify code but only way I was skilled enough to  was \n * first select 'tests' then manually add 'notes' to them with another\n * select statement. \n * @param response Response to write the tests to\n * @param tests Array of tests from the DB\n */\nfunction getAddNotesToTests(response, tests, table){\n\tvar notes = [];\n\tvar query = connection.query('SELECT * FROM notes_'+table.substring(6), function(err, rows, fields) {\n\t\tif (err) {\n\t\t\tconsole.log(err);\n\t\t} else {\n\t\t\tfor(var i = 0; i < rows.length; i++){\n\t\t\t\tnotes[i] = rows[i];\n\t\t\t}\n\t\t}\n\t});\n\n\tquery.on('end',function(){\n\t\tfor(var i = 0; i < tests.length; i++){\n\t\t\tvar test = tests[i];\n\t\t\tfor(var j = 0; j < notes.length; j++){\n\t\t\t\tvar note = notes[j];\n\t\t\t\tif(note.testId === test.id){\n\t\t\t\t\ttest.notes.push(note);\n\t\t\t\t} \n\t\t\t}\n\t\t}\n\t\tresponse.write(JSON.stringify(tests));\n\t\tresponse.end();\n\t});\n}\n\n/**\n * Gets the tables in the database to fill the projects drop down\n * @param response Response to return\n */\nfunction getProjectTables(response){\n\tvar projects = [];\n\tvar query = connection.query(\"SELECT TABLE_NAME as project FROM information_schema.tables WHERE TABLE_NAME LIKE 'test_%'\", function(err, rows, fields) {\n\t\tif (err) {\n\t\t\tconsole.log(err);\n\t\t} else {\n\t\t\tfor(var i = 0; i < rows.length; i++){\n\t\t\t\tprojects[i] = rows[i];\n\t\t\t}\n\t\t}\n\t});\n\n\tquery.on('end',function(){\n\t\tfor(var j = 0; j < projects.length; j++){\n\t\t\tvar project ={};\n\t\t\tproject.db = projects[j].project;\n\t\t\tproject.name = projects[j].project.substring(6);\n\t\t\tprojects[j] = project;\n\t\t}\n\t\tresponse.write(JSON.stringify(projects));\n\t\tresponse.end();\n\t});\n}\n\n/**\n * Adds a note to a test\n * @param response The response to send back\n * @param note Note object to add\n */\nfunction addNote(request, response, note){\n\tvar parts = url.parse(request.url,true);\n\tvar queryStr = \"INSERT INTO notes_\"+(parts.query.table).substring(6)+\" (testId,who,note) VALUES (\"+connection.escape(note.testId)+\",\" + connection.escape(note.who) + \",\"+connection.escape(note.note)+\")\";\n\tvar query = connection.query(queryStr,function(err, rows, fields) {\n\t\tif (err) {\n\t\t\tresponse.statusCode = 400;\n\t\t\tconsole.log(err);\n\t\t} \n\t});\n\n\tquery.on('end',function(){\n\t\tresponse.end();\n\t});\n}\n\n/**\n * Handles requests to add a 'test' to the DB\n * @param request The http request\n * @param response The http response\n * @param body The data from the post request\n */\nfunction addTest(request, response, body){\n\tvar table = body.table;\n\tvar test = body.result;\n\tvar start = new Date(Number(test.start));\n\tvar end = new Date(Number(test.end));\n\n\t//Format to YYYY-MM-DD HH:MM:SS\n\tstart = start.getFullYear()+\"-\"+(start.getMonth()+1)+\"-\"+start.getDate()+\" \"+start.getHours()+\":\"+start.getMinutes()+\":\"+start.getSeconds();\n\tend = end.getFullYear()+\"-\"+(end.getMonth()+1)+\"-\"+end.getDate()+\" \"+end.getHours()+\":\"+end.getMinutes()+\":\"+end.getSeconds();\n\n\tvar queryStr = \"INSERT INTO \"+table+\" (name,param,error,start,end,status,extra,runInfo) VALUES (\"+connection.escape(test.name)+\"','\" + connection.escape(test.param) + \",\"+connection.escape(test.error)+ \"','\"+start+ \"','\"+end+ \"',\"+connection.escape(test.status)+ \",\"+connection.escape(test.extra)+ \",\"+connection.escape(test.runInfo)+\")\";\n\tvar query = connection.query(queryStr, function(err, rows, fields) {\n\t\tif (err) {\n\t\t\tresponse.statusCode = 400;\n\t\t\tconsole.log(err);\n\t\t} \n\t});\n\n\tquery.on('end',function(){\n\t\tresponse.end();\n\t});\n}\n\n/**\n * Function handles JSON POST requests, will read the data and once done\n * dispatch the request and response the the action function\n * @param request The http request\n * @param response The http response\n * @param action The function to be ran once the body is read\n */\nfunction handlePost(request, response, action){\n\tresponse.statusCode = 200;\n\tresponse.setHeader('Access-Control-Allow-Origin', 'http://localhost:8000');\n\tresponse.setHeader('Access-Control-Allow-Methods', 'POST');\n\tresponse.setHeader('Access-Control-Allow-Headers', 'Content-Type');\n\tvar body = '';\t\n\trequest.on('data', function (data) {\n\t\tbody += data;\n\t});\t\t\n\trequest.on('error', function(e) {\n\t\tconsole.log('Bad post');\n\t\tresponse.statusCode = 400;\n\t\tresponse.end();\n\t});\t\t\n\trequest.on('end', function () {\n\t\t//TODO Mysterious blank post is sent (below work around)\n\t\tif(body.length){\n\t\t\taction(request, response, JSON.parse(body));\n\t\t} else{\n\t\t\tresponse.end();\n\t\t}\n\t});\n}\n\n/**\n * Server, so far just handles request to /getTestData\n */\nvar server = http.createServer(function (request,response){\n\tvar parts = url.parse(request.url,true);\n\tvar path = parts.path;\n\tresponse.setHeader('Access-Control-Allow-Origin', 'http://localhost:8000');\n\tresponse.setHeader('Access-Control-Allow-Methods', 'GET');\n\tif(path.indexOf(\"/getTestData?table=\") === 0){\n\t\tresponse.statusCode = 200;\n\t\tgetTestObjects(response, parts.query.table, getAddNotesToTests);\n\t} else if(path.indexOf(\"/getStats?filter\") === 0){\n\t\tresponse.statusCode = 200;\n\t\tgetStats(response,parts.query.filter,parts.query.table);\n\t} else if(parts.pathname === \"/addNote\"){\n\t\thandlePost(request, response, addNote);\n\t} else if(path === \"/addTest\") {\n\t\thandlePost(request, response, addTest);\n\t} else if(path === \"/getProjects\"){\n\t\tresponse.statusCode = 200;\n\t\tgetProjectTables(response);\n\t} else {\n\t\tresponse.statusCode = 404;\n\t\tresponse.write(\"Invalid\")\n\t\tresponse.end();\n\t}\n});\n\nserver.listen(4968);\nconsole.log(\"Server Started on port 4968\");"], "filenames": ["app/app.js", "rest-server/data-server.js"], "buggy_code_start_loc": [33, 138], "buggy_code_end_loc": [34, 167], "fixing_code_start_loc": [33, 138], "fixing_code_end_loc": [34, 168], "type": "CWE-89", "message": "A vulnerability was found in gperson angular-test-reporter and classified as critical. This issue affects the function getProjectTables/addTest of the file rest-server/data-server.js. The manipulation leads to sql injection. The name of the patch is a29d8ae121b46ebfa96a55a9106466ab2ef166ae. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-217715.", "other": {"cve": {"id": "CVE-2015-10035", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-09T21:15:10.383", "lastModified": "2023-01-13T18:17:23.670", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in gperson angular-test-reporter and classified as critical. This issue affects the function getProjectTables/addTest of the file rest-server/data-server.js. The manipulation leads to sql injection. The name of the patch is a29d8ae121b46ebfa96a55a9106466ab2ef166ae. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-217715."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:L/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.1, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 5.2}, "baseSeverity": "MEDIUM", "exploitabilityScore": 5.1, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "cna@vuldb.com", "type": "Primary", "description": [{"lang": "en", "value": "CWE-89"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:angular-test-reporter_project:angular-test-reporter:*:*:*:*:*:*:*:*", "versionEndExcluding": "2015-01-07", "matchCriteriaId": "4D4FA270-3B5E-49D7-A984-893AA56E6325"}]}]}], "references": [{"url": "https://github.com/gperson/angular-test-reporter/commit/a29d8ae121b46ebfa96a55a9106466ab2ef166ae", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.217715", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}, {"url": "https://vuldb.com/?id.217715", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/gperson/angular-test-reporter/commit/a29d8ae121b46ebfa96a55a9106466ab2ef166ae"}}