{"buggy_code": ["# Copyright 2014 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Base constants and handlers.\"\"\"\n\nfrom __future__ import annotations\n\nimport abc\nimport base64\nimport datetime\nimport functools\nimport hmac\nimport io\nimport json\nimport logging\nimport os\nimport re\nimport time\nimport urllib\n\nfrom core import feconf\nfrom core import handler_schema_constants\nfrom core import utils\nfrom core.controllers import payload_validator\nfrom core.domain import auth_domain\nfrom core.domain import auth_services\nfrom core.domain import classifier_domain\nfrom core.domain import config_domain\nfrom core.domain import config_services\nfrom core.domain import user_services\n\nfrom typing import (\n    Any, Dict, Final, Generic, Mapping, Optional, Sequence, TypedDict, TypeVar,\n    Union\n)\n\nimport webapp2\n\n# Note: These private type variables are only defined to implement the Generic\n# typing structure of BaseHandler. So, do not make them public in the future.\n_NormalizedRequestDictType = TypeVar('_NormalizedRequestDictType')\n_NormalizedPayloadDictType = TypeVar('_NormalizedPayloadDictType')\n\nONE_DAY_AGO_IN_SECS: Final = -24 * 60 * 60\nDEFAULT_CSRF_SECRET: Final = 'oppia csrf secret'\nCSRF_SECRET: Final = config_domain.ConfigProperty(\n    'oppia_csrf_secret', {'type': 'unicode'},\n    'Text used to encrypt CSRF tokens.', DEFAULT_CSRF_SECRET)\n\n# NOTE: These handlers manage user sessions and serve auth pages. Thus, we\n# should never reject or replace them when running in maintenance mode;\n# otherwise admins will be unable to access the site.\nAUTH_HANDLER_PATHS: Final = (\n    '/csrfhandler',\n    '/login',\n    '/session_begin',\n    '/session_end',\n)\n\n\nclass ResponseValueDict(TypedDict):\n    \"\"\"Dict representation of key-value pairs that will be included in the\n    response.\n    \"\"\"\n\n    error: str\n    status_code: int\n\n\n@functools.lru_cache(maxsize=128)\ndef load_template(\n    filename: str, *, template_is_aot_compiled: bool\n) -> str:\n    \"\"\"Return the HTML file contents at filepath.\n\n    Args:\n        filename: str. Name of the requested HTML file.\n        template_is_aot_compiled: bool. Used to determine which bundle to use.\n\n    Returns:\n        str. The HTML file content.\n    \"\"\"\n    filepath = os.path.join(\n        (\n            feconf.FRONTEND_AOT_DIR\n            if template_is_aot_compiled\n            else feconf.FRONTEND_TEMPLATES_DIR\n        ),\n        filename\n    )\n    with utils.open_file(filepath, 'r') as f:\n        html_text = f.read()\n    return html_text\n\n\nclass SessionBeginHandler(webapp2.RequestHandler):\n    \"\"\"Handler for creating new authentication sessions.\"\"\"\n\n    def get(self) -> None:\n        \"\"\"Establishes a new auth session.\"\"\"\n        auth_services.establish_auth_session(self.request, self.response)\n\n\nclass SessionEndHandler(webapp2.RequestHandler):\n    \"\"\"Handler for destroying existing authentication sessions.\"\"\"\n\n    def get(self) -> None:\n        \"\"\"Destroys an existing auth session.\"\"\"\n        auth_services.destroy_auth_session(self.response)\n\n\nclass UserFacingExceptions:\n    \"\"\"This class contains all the exception class definitions used.\"\"\"\n\n    class NotLoggedInException(Exception):\n        \"\"\"Error class for users that are not logged in (error code 401).\"\"\"\n\n        pass\n\n    class InvalidInputException(Exception):\n        \"\"\"Error class for invalid input on the user side (error code 400).\"\"\"\n\n        pass\n\n    class UnauthorizedUserException(Exception):\n        \"\"\"Error class for unauthorized access.\"\"\"\n\n        pass\n\n    class PageNotFoundException(Exception):\n        \"\"\"Error class for a page not found error (error code 404).\"\"\"\n\n        pass\n\n    class InternalErrorException(Exception):\n        \"\"\"Error class for an internal server side error (error code 500).\"\"\"\n\n        pass\n\n\nclass BaseHandler(\n    webapp2.RequestHandler,\n    Generic[_NormalizedPayloadDictType, _NormalizedRequestDictType]\n):\n    \"\"\"Base class for all Oppia handlers.\"\"\"\n\n    # Whether to check POST and PUT payloads for CSRF tokens prior to\n    # processing them. Can be overridden by subclasses if this check is\n    # not necessary.\n    REQUIRE_PAYLOAD_CSRF_CHECK = True\n    # Whether to redirect requests corresponding to a logged-in user who has\n    # not completed signup in to the signup page. This ensures that logged-in\n    # users have agreed to the latest terms.\n    REDIRECT_UNFINISHED_SIGNUPS = True\n\n    # What format the get method returns when exception raised, json or html.\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_HTML\n    POST_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    PUT_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    DELETE_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n    # Here we use type Any because the sub-classes of BaseHandler can contain\n    # different schemas with different types of values, like str, complex Dicts\n    # and etc.\n    URL_PATH_ARGS_SCHEMAS: Optional[Dict[str, Any]] = None\n    # Here we use type Any because the sub-classes of BaseHandler can contain\n    # different schemas with different types of values, like str, complex Dicts\n    # and etc.\n    HANDLER_ARGS_SCHEMAS: Optional[Dict[str, Any]] = None\n\n    def __init__(  # pylint: disable=super-init-not-called\n        self, request: webapp2.Request, response: webapp2.Response\n    ) -> None:\n        # Set self.request, self.response and self.app.\n        self.initialize(request, response)\n\n        self.start_time = datetime.datetime.utcnow()\n\n        # Here we use type Any because dict 'self.values' is a return dict\n        # for the handlers, and different handlers can return different\n        # key-value pairs. So, to allow every type of key-value pair, we\n        # used Any type here.\n        self.values: Dict[str, Any] = {}\n\n        # This try-catch block is intended to log cases where getting the\n        # request payload errors with ValueError: Invalid boundary in multipart\n        # form: b''. This is done to gather sufficient data to help debug the\n        # error if it arises in the future.\n        try:\n            payload_json_string = self.request.get('payload')\n        except ValueError as e:\n            logging.error('%s: request %s', e, self.request)\n            raise e\n        # TODO(#13155): Remove the if-else part once all the handlers have had\n        # schema validation implemented.\n        if payload_json_string:\n            self.payload = json.loads(payload_json_string)\n        else:\n            self.payload = None\n        self.iframed = False\n\n        self.user_id = None\n        self.username = None\n        self.email = None\n        self.partially_logged_in = False\n        self.user_is_scheduled_for_deletion = False\n        self.current_user_is_super_admin = False\n        self.normalized_request: Optional[_NormalizedRequestDictType] = None\n        self.normalized_payload: Optional[_NormalizedPayloadDictType] = None\n\n        try:\n            auth_claims = auth_services.get_auth_claims_from_request(request)\n        except auth_domain.StaleAuthSessionError:\n            auth_services.destroy_auth_session(self.response)\n            self.redirect(user_services.create_login_url(self.request.uri))\n            return\n        except auth_domain.UserDisabledError:\n            auth_services.destroy_auth_session(self.response)\n            self.redirect(\n                '/logout?redirect_url=%s' % feconf.PENDING_ACCOUNT_DELETION_URL)\n            return\n        except auth_domain.InvalidAuthSessionError:\n            logging.exception('User session is invalid!')\n            auth_services.destroy_auth_session(self.response)\n            self.redirect(user_services.create_login_url(self.request.uri))\n            return\n        else:\n            self.current_user_is_super_admin = (\n                auth_claims is not None and auth_claims.role_is_super_admin)\n\n        if auth_claims:\n            auth_id = auth_claims.auth_id\n            user_settings = user_services.get_user_settings_by_auth_id(auth_id)\n            if user_settings is None:\n                # If the user settings are not yet created and the request leads\n                # to signup page create a new user settings. Otherwise logout\n                # the not-fully registered user.\n                email = auth_claims.email\n                if email is None:\n                    logging.exception(\n                        'No email address was found for the user.'\n                    )\n                    auth_services.destroy_auth_session(self.response)\n                    return\n                if 'signup?' in self.request.uri:\n                    user_settings = (\n                        user_services.create_new_user(auth_id, email))\n                else:\n                    logging.error(\n                        'Cannot find user %s with email %s on page %s' % (\n                            auth_id, email, self.request.uri))\n                    auth_services.destroy_auth_session(self.response)\n                    return\n\n            self.email = user_settings.email\n            self.values['user_email'] = user_settings.email\n            self.user_id = user_settings.user_id\n\n            if user_settings.deleted:\n                self.user_is_scheduled_for_deletion = user_settings.deleted\n            elif (self.REDIRECT_UNFINISHED_SIGNUPS and\n                  not user_services.has_fully_registered_account(self.user_id)):\n                self.partially_logged_in = True\n            else:\n                self.username = user_settings.username\n                self.values['username'] = self.username\n                # In order to avoid too many datastore writes, we do not bother\n                # recording a log-in if the current time is sufficiently close\n                # to the last log-in time.\n                if (user_settings.last_logged_in is None or\n                        not utils.are_datetimes_close(\n                            datetime.datetime.utcnow(),\n                            user_settings.last_logged_in)):\n                    user_services.record_user_logged_in(self.user_id)\n\n            self.roles = user_settings.roles\n\n        if self.user_id is None:\n            self.roles = [feconf.ROLE_ID_GUEST]\n\n        self.user = user_services.get_user_actions_info(self.user_id)\n\n        if not self._is_requested_path_currently_accessible_to_user():\n            auth_services.destroy_auth_session(self.response)\n            return\n\n        self.values['is_super_admin'] = self.current_user_is_super_admin\n\n    def dispatch(self) -> None:\n        \"\"\"Overrides dispatch method in webapp2 superclass.\n\n        Raises:\n            Exception. The CSRF token is missing.\n            UnauthorizedUserException. The CSRF token is invalid.\n        \"\"\"\n        request_split = urllib.parse.urlsplit(self.request.uri)\n        # If the request is to the old demo server, redirect it permanently to\n        # the new demo server. (Unless it is a cron job or tasks request,\n        # because cron job and tasks destination URLs are generated by\n        # App Engine and we can't change their destination.)\n        if (\n                request_split.netloc == 'oppiaserver.appspot.com' and\n                not request_split.path.startswith(('/cron/', '/task/'))\n        ):\n            self.redirect('https://oppiatestserver.appspot.com', permanent=True)\n            return\n\n        if not self._is_requested_path_currently_accessible_to_user():\n            self.render_template('maintenance-page.mainpage.html')\n            return\n\n        if self.user_is_scheduled_for_deletion:\n            self.redirect(\n                '/logout?redirect_url=%s' % feconf.PENDING_ACCOUNT_DELETION_URL)\n            return\n\n        if self.partially_logged_in and request_split.path != '/logout':\n            self.redirect('/logout?redirect_url=%s' % request_split.path)\n            return\n\n        if self.payload is not None and self.REQUIRE_PAYLOAD_CSRF_CHECK:\n            try:\n                # If user opens a new tab during signup process, the user_id\n                # parameter is set to None and this causes the signup session\n                # to expire. The code here checks if user is on the signup\n                # page and the user_id is None, if that is the case an exception\n                # is raised which is handled by the frontend by showing a\n                # continue to registration modal.\n                if 'signup' in self.request.uri and not self.user_id:\n                    raise self.UnauthorizedUserException(\n                        'Registration session expired.')\n                csrf_token = self.request.get('csrf_token')\n                if not csrf_token:\n                    raise self.UnauthorizedUserException(\n                        'Missing CSRF token. Changes were not saved. '\n                        'Please report this bug.')\n\n                is_csrf_token_valid = CsrfTokenManager.is_csrf_token_valid(\n                    self.user_id, csrf_token)\n\n                if not is_csrf_token_valid:\n                    raise self.UnauthorizedUserException(\n                        'Your session has expired, and unfortunately your '\n                        'changes cannot be saved. Please refresh the page.')\n            except Exception as e:\n                logging.exception('%s: payload %s', e, self.payload)\n\n                self.handle_exception(e, self.app.debug)\n                return\n\n        schema_validation_succeeded = True\n        try:\n            self.validate_and_normalize_args()\n\n        # TODO(#13155): Remove NotImplementedError once all the handlers\n        # have had schema validation implemented.\n        except (\n            NotImplementedError,\n            self.InternalErrorException,\n            self.InvalidInputException\n        ) as e:\n            self.handle_exception(e, self.app.debug)\n            schema_validation_succeeded = False\n        if not schema_validation_succeeded:\n            return\n\n        super().dispatch()\n\n    def validate_and_normalize_args(self) -> None:\n        \"\"\"Validates schema for controller layer handler class arguments.\n\n        Raises:\n            InvalidInputException. Schema validation failed.\n            NotImplementedError. Schema is not provided in handler class.\n        \"\"\"\n        handler_class_name = self.__class__.__name__\n        request_method = self.request.environ['REQUEST_METHOD']\n\n        # For HEAD requests, we use the schema of GET handler,\n        # because HEAD returns just the handlers of the GET request.\n        if request_method == 'HEAD':\n            request_method = 'GET'\n\n        url_path_args = self.request.route_kwargs\n\n        if (\n            handler_class_name in\n            handler_schema_constants.HANDLER_CLASS_NAMES_WITH_NO_SCHEMA\n        ):\n            # TODO(#13155): Remove this clause once all the handlers have had\n            # schema validation implemented.\n            if self.URL_PATH_ARGS_SCHEMAS or self.HANDLER_ARGS_SCHEMAS:\n                raise self.InternalErrorException(\n                    'Remove handler class name from '\n                    'HANDLER_CLASS_NAMES_WHICH_STILL_NEED_SCHEMAS')\n            return\n\n        handler_args = {}\n        payload_arg_keys = []\n        request_arg_keys = []\n        for arg in self.request.arguments():\n            if arg == 'csrf_token':\n                # 'csrf_token' has been already validated in the\n                # dispatch method.\n                pass\n            elif arg == 'source':\n                source_url = self.request.get('source')\n                regex_pattern = (\n                    r'http[s]?://(?:[a-zA-Z]|[0-9]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+' # pylint: disable=line-too-long\n                )\n                regex_verified_url = re.findall(regex_pattern, source_url)\n                if not regex_verified_url:\n                    raise self.InvalidInputException(\n                        'Not a valid source url.')\n            elif arg == 'payload':\n                payload_args = self.payload\n                if payload_args is not None:\n                    payload_arg_keys = list(payload_args.keys())\n                    handler_args.update(payload_args)\n            else:\n                request_arg_keys.append(arg)\n                handler_args[arg] = self.request.get(arg)\n\n        # For html handlers, extra args are allowed (to accommodate\n        # e.g. utm parameters which are not used by the backend but\n        # needed for analytics).\n        extra_args_are_allowed = (\n            self.GET_HANDLER_ERROR_RETURN_TYPE == feconf.HANDLER_TYPE_HTML and\n            request_method == 'GET')\n\n        if self.URL_PATH_ARGS_SCHEMAS is None:\n            raise NotImplementedError(\n                'Missing schema for url path args in %s handler class.' % (\n                    handler_class_name))\n\n        schema_for_url_path_args = self.URL_PATH_ARGS_SCHEMAS\n        self.request.route_kwargs, errors = (\n            payload_validator.validate_arguments_against_schema(\n                url_path_args, schema_for_url_path_args, extra_args_are_allowed)\n        )\n\n        if errors:\n            raise self.InvalidInputException(\n                'At \\'%s\\' these errors are happening:\\n%s' % (\n                    self.request.uri, '\\n'.join(errors)\n                )\n            )\n\n        # This check ensures that if a request method is not defined\n        # in the handler class then schema validation will not raise\n        # NotImplementedError for that corresponding request method.\n        if request_method in ['GET', 'POST', 'PUT', 'DELETE'] and (\n                getattr(self.__class__, request_method.lower()) ==\n                getattr(BaseHandler, request_method.lower())):\n            return\n\n        try:\n            if self.HANDLER_ARGS_SCHEMAS is None:\n                raise Exception(\n                    'No \\'HANDLER_ARGS_SCHEMAS\\' Found for the '\n                    'handler class: %s' % handler_class_name\n                )\n            schema_for_request_method = self.HANDLER_ARGS_SCHEMAS[\n                request_method]\n        except Exception as e:\n            raise NotImplementedError(\n                'Missing schema for %s method in %s handler class.' % (\n                    request_method, handler_class_name)) from e\n\n        allow_string_to_bool_conversion = request_method in ['GET', 'DELETE']\n        normalized_arg_values, errors = (\n            payload_validator.validate_arguments_against_schema(\n                handler_args, schema_for_request_method, extra_args_are_allowed,\n                allow_string_to_bool_conversion)\n        )\n\n        normalized_payload = {\n            arg: normalized_arg_values.get(arg) for arg in payload_arg_keys\n        }\n        normalized_request = {\n            arg: normalized_arg_values.get(arg) for arg in request_arg_keys\n        }\n\n        # The following keys are absent in request/payload but present in\n        # normalized_arg_values because these args are populated from their\n        # default_value provided in the schema.\n        keys_that_correspond_to_default_values = list(\n            set(normalized_arg_values.keys()) -\n            set(payload_arg_keys + request_arg_keys)\n        )\n        # Populate the payload/request with the default args before passing\n        # execution onwards to the handler.\n        for arg in keys_that_correspond_to_default_values:\n            if request_method in ['GET', 'DELETE']:\n                normalized_request[arg] = normalized_arg_values.get(arg)\n            else:\n                normalized_payload[arg] = normalized_arg_values.get(arg)\n\n        # Here we use MyPy ignore because 'normalized_payload' is of\n        # Dict[str, Any] type, whereas 'self.normalized_payload' is a Generic\n        # type whose type can be decided while defining sub-classes. So, Due\n        # to this mismatch in types MyPy throws an error. Thus, to silence the\n        # error, we used type ignore here.\n        self.normalized_payload = normalized_payload  # type: ignore[assignment]\n        # Here we use MyPy ignore because 'normalized_request' is of\n        # Dict[str, Any] type, whereas 'self.normalized_request' is a Generic\n        # type whose type can be decided while defining sub-classes. So, Due\n        # to this mismatch in types MyPy throws an error. Thus, to silence the\n        # error, we used type ignore here.\n        self.normalized_request = normalized_request  # type: ignore[assignment]\n\n        # Here we use MyPy ignore because here we assigning RaiseErrorOnGet's\n        # instance to a 'get' method, and according to MyPy assignment to a\n        # method is not allowed.\n        self.request.get = RaiseErrorOnGet(  # type: ignore[assignment]\n            'Use self.normalized_request instead of self.request.').get\n        self.payload = RaiseErrorOnGet(\n            'Use self.normalized_payload instead of self.payload.')\n\n        if errors:\n            raise self.InvalidInputException('\\n'.join(errors))\n\n    @property\n    def current_user_is_site_maintainer(self) -> bool:\n        \"\"\"Returns whether the current user is a site maintainer.\n\n        A super admin or release coordinator is also a site maintainer.\n\n        Returns:\n            bool. Whether the current user is a site maintainer.\n        \"\"\"\n        return (\n            self.current_user_is_super_admin or\n            feconf.ROLE_ID_RELEASE_COORDINATOR in self.roles)\n\n    def _is_requested_path_currently_accessible_to_user(self) -> bool:\n        \"\"\"Checks whether the requested path is currently accessible to user.\n\n        Returns:\n            bool. Whether the requested path is currently accessible to user.\n        \"\"\"\n        return (\n            self.request.path in AUTH_HANDLER_PATHS or\n            not feconf.ENABLE_MAINTENANCE_MODE or\n            self.current_user_is_site_maintainer)\n\n    # Here we use type Any because the sub-classes of 'Basehandler' can have\n    # 'get' method with different number of arguments and types.\n    def get(self, *args: Any, **kwargs: Any) -> None:  # pylint: disable=unused-argument\n        \"\"\"Base method to handle GET requests.\"\"\"\n        logging.warning('Invalid URL requested: %s', self.request.uri)\n        self.error(404)\n        values: ResponseValueDict = {\n            'error': 'Could not find the page %s.' % self.request.uri,\n            'status_code': 404\n        }\n        self._render_exception(values)\n\n    # Here we use type Any because the sub-classes of 'Basehandler' can have\n    # 'post' method with different number of arguments and types.\n    def post(self, *args: Any) -> None:  # pylint: disable=unused-argument\n        \"\"\"Base method to handle POST requests.\n\n        Raises:\n            PageNotFoundException. Page not found error (error code 404).\n        \"\"\"\n        raise self.PageNotFoundException\n\n    # Here we use type Any because the sub-classes of 'Basehandler' can have\n    # 'put' method with different number of arguments and types.\n    def put(self, *args: Any) -> None:  # pylint: disable=unused-argument\n        \"\"\"Base method to handle PUT requests.\n\n        Raises:\n            PageNotFoundException. Page not found error (error code 404).\n        \"\"\"\n        raise self.PageNotFoundException\n\n    # Here we use type Any because the sub-classes of 'Basehandler' can have\n    # 'delete' method with different number of arguments and types.\n    def delete(self, *args: Any) -> None:  # pylint: disable=unused-argument\n        \"\"\"Base method to handle DELETE requests.\n\n        Raises:\n            PageNotFoundException. Page not found error (error code 404).\n        \"\"\"\n        raise self.PageNotFoundException\n\n    # Here we use type Any because the sub-classes of 'Basehandler' can have\n    # 'head' method with different number of arguments and types.\n    def head(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"Method to handle HEAD requests. The webapp library automatically\n        makes sure that HEAD only returns the headers of GET request.\n        \"\"\"\n        return self.get(*args, **kwargs)\n\n    # TODO(#16539): Once all the places are fixed with the type of value\n    # that is rendered to JSON, then please remove Sequence[Mapping[str, Any]]\n    # from render_json's argument type.\n    # Here we use type Any because the argument 'values' can accept various\n    # kinds of dictionaries that needs to be sent as a JSON response.\n    def render_json(\n        self, values: Union[str, Sequence[Mapping[str, Any]], Mapping[str, Any]]\n    ) -> None:\n        \"\"\"Prepares JSON response to be sent to the client.\n\n        Args:\n            values: str|dict. The key-value pairs to encode in the\n                JSON response.\n        \"\"\"\n        self.response.content_type = 'application/json; charset=utf-8'\n        self.response.headers['Content-Disposition'] = (\n            'attachment; filename=\"oppia-attachment.txt\"')\n        self.response.headers['Strict-Transport-Security'] = (\n            'max-age=31536000; includeSubDomains')\n        self.response.headers['X-Content-Type-Options'] = 'nosniff'\n        self.response.headers['X-Xss-Protection'] = '1; mode=block'\n\n        json_output = json.dumps(values, cls=utils.JSONEncoderForHTML)\n        # Write expects bytes, thus we need to encode the JSON output.\n        self.response.write(\n            b'%s%s' % (feconf.XSSI_PREFIX, json_output.encode('utf-8')))\n\n    def render_downloadable_file(\n        self, file: io.BytesIO, filename: str, content_type: str\n    ) -> None:\n        \"\"\"Prepares downloadable content to be sent to the client.\n\n        Args:\n            file: BytesIO. The data of the downloadable file.\n            filename: str. The name of the file to be rendered.\n            content_type: str. The type of file to be rendered.\n        \"\"\"\n        self.response.headers['Content-Type'] = content_type\n        self.response.headers['Content-Disposition'] = (\n            'attachment; filename=%s' % filename)\n        self.response.charset = 'utf-8'\n        # Here we use MyPy ignore because according to MyPy super can\n        # accept 'super class and self' as arguments but here we are passing\n        # 'webapp2.Response, and self.response' which confuses MyPy about the\n        # typing of super, and due to this MyPy is unable to recognize the\n        # 'write' method and throws an error. This change in arguments is\n        # done because we use 'super' method in order to bypass the write\n        # method in webapp2.Response, since webapp2.Response doesn't support\n        # writing bytes.\n        super(webapp2.Response, self.response).write(file.getvalue())  # type: ignore[misc] # pylint: disable=bad-super-call\n\n    def render_template(\n        self,\n        filepath: str,\n        iframe_restriction: Optional[str] = 'DENY',\n        *,\n        template_is_aot_compiled: bool = False\n    ) -> None:\n        \"\"\"Prepares an HTML response to be sent to the client.\n\n        Args:\n            filepath: str. The template filepath.\n            iframe_restriction: str or None. Possible values are\n                'DENY' and 'SAMEORIGIN':\n\n                DENY: Strictly prevents the template to load in an iframe.\n                SAMEORIGIN: The template can only be displayed in a frame\n                    on the same origin as the page itself.\n            template_is_aot_compiled: bool. False by default. Use\n                True when the template is compiled by angular AoT compiler.\n\n        Raises:\n            Exception. Invalid X-Frame-Options.\n        \"\"\"\n\n        # The 'no-store' must be used to properly invalidate the cache when we\n        # deploy a new version, using only 'no-cache' doesn't work properly.\n        self.response.cache_control.no_store = True\n        self.response.cache_control.must_revalidate = True\n        self.response.headers['Strict-Transport-Security'] = (\n            'max-age=31536000; includeSubDomains')\n        self.response.headers['X-Content-Type-Options'] = 'nosniff'\n        self.response.headers['X-Xss-Protection'] = '1; mode=block'\n\n        if iframe_restriction is not None:\n            if iframe_restriction in ['SAMEORIGIN', 'DENY']:\n                self.response.headers['X-Frame-Options'] = (\n                    str(iframe_restriction))\n            else:\n                raise Exception(\n                    'Invalid X-Frame-Options: %s' % iframe_restriction)\n\n        self.response.expires = 'Mon, 01 Jan 1990 00:00:00 GMT'\n        self.response.pragma = 'no-cache'\n        self.response.write(load_template(\n            filepath, template_is_aot_compiled=template_is_aot_compiled\n        ))\n\n    def _render_exception_json_or_html(\n        self, return_type: str, values: ResponseValueDict\n    ) -> None:\n        \"\"\"Renders an error page, or an error JSON response.\n\n        Args:\n            return_type: str. Indicator to return JSON or HTML.\n            values: dict. The key-value pairs to include in the response.\n        \"\"\"\n\n        method = self.request.environ['REQUEST_METHOD']\n\n        if return_type == feconf.HANDLER_TYPE_HTML and method == 'GET':\n            self.values.update(values)\n            if self.iframed:\n                self.render_template(\n                    'error-iframed.mainpage.html', iframe_restriction=None)\n            elif values['status_code'] == 404:\n                # Only 404 routes can be handled with angular router as it only\n                # has access to the path, not to the status code.\n                # That's why 404 status code is treated differently.\n                self.render_template('oppia-root.mainpage.html')\n            else:\n                self.render_template(\n                    'error-page-%s.mainpage.html' % values['status_code'])\n        else:\n            if return_type not in (\n                    feconf.HANDLER_TYPE_JSON, feconf.HANDLER_TYPE_DOWNLOADABLE):\n                logging.warning(\n                    'Not a recognized return type: defaulting to render JSON.')\n            self.render_json(values)\n\n    def _render_exception(\n        self, values: ResponseValueDict\n    ) -> None:\n        \"\"\"Renders an error page, or an error JSON response.\n\n        Args:\n            values: dict. The key-value pairs to include in the response.\n        \"\"\"\n        # The error codes here should be in sync with the error pages\n        # generated via webpack.common.config.ts.\n        assert values['status_code'] in [400, 401, 404, 500]\n        method = self.request.environ['REQUEST_METHOD']\n\n        if method == 'GET':\n            self._render_exception_json_or_html(\n                self.GET_HANDLER_ERROR_RETURN_TYPE, values)\n        elif method == 'POST':\n            self._render_exception_json_or_html(\n                self.POST_HANDLER_ERROR_RETURN_TYPE, values)\n        elif method == 'PUT':\n            self._render_exception_json_or_html(\n                self.PUT_HANDLER_ERROR_RETURN_TYPE, values)\n        elif method == 'DELETE':\n            self._render_exception_json_or_html(\n                self.DELETE_HANDLER_ERROR_RETURN_TYPE, values)\n        else:\n            logging.warning('Not a recognized request method.')\n            self._render_exception_json_or_html(\n                feconf.HANDLER_TYPE_JSON, values\n            )\n\n    def handle_exception(\n        self, exception: BaseException, unused_debug_mode: bool\n    ) -> None:\n        \"\"\"Overwrites the default exception handler.\n\n        Args:\n            exception: Exception. The exception that was thrown.\n            unused_debug_mode: bool. True if the web application is running\n                in debug mode.\n        \"\"\"\n        if isinstance(exception, self.NotLoggedInException):\n            # This checks if the response should be JSON or HTML.\n            # For GET requests, there is no payload, so we check against\n            # GET_HANDLER_ERROR_RETURN_TYPE.\n            # Otherwise, we check whether self.payload exists.\n\n            # This check is to avoid throwing of 401 when payload doesn't\n            # exists and self.payload is replaced by RaiseErrorOnGet object.\n            # TODO(#13155): Change this to self.normalized_payload\n            #  once schema is implemented for all handlers.\n            payload_exists = (\n                self.payload is not None and\n                not isinstance(self.payload, RaiseErrorOnGet)\n            )\n            if (\n                    payload_exists or\n                    self.GET_HANDLER_ERROR_RETURN_TYPE ==\n                    feconf.HANDLER_TYPE_JSON\n            ):\n                self.error(401)\n                values: ResponseValueDict = {\n                    'error': 'You must be logged in to access this resource.',\n                    'status_code': 401\n                }\n                self._render_exception(values)\n            else:\n                self.redirect(user_services.create_login_url(self.request.uri))\n            return\n\n        logging.exception(\n            'Exception raised at %s: %s', self.request.uri, exception)\n\n        if isinstance(exception, self.PageNotFoundException):\n            logging.warning('Invalid URL requested: %s', self.request.uri)\n            self.error(404)\n            values = {\n                'error': 'Could not find the page %s.' % self.request.uri,\n                'status_code': 404\n            }\n            self._render_exception(values)\n            return\n\n        logging.exception('Exception raised: %s', exception)\n\n        if isinstance(exception, self.UnauthorizedUserException):\n            self.error(401)\n            values = {\n                'error': str(exception),\n                'status_code': 401\n            }\n            self._render_exception(values)\n            return\n\n        if isinstance(exception, self.InvalidInputException):\n            self.error(400)\n            values = {\n                'error': str(exception),\n                'status_code': 400\n            }\n            self._render_exception(values)\n            return\n\n        if isinstance(exception, self.InternalErrorException):\n            self.error(500)\n            values = {\n                'error': str(exception),\n                'status_code': 500\n            }\n            self._render_exception(values)\n            return\n\n        self.error(500)\n        values = {\n            'error': str(exception),\n            'status_code': 500\n        }\n        self._render_exception(values)\n\n    InternalErrorException = UserFacingExceptions.InternalErrorException\n    InvalidInputException = UserFacingExceptions.InvalidInputException\n    NotLoggedInException = UserFacingExceptions.NotLoggedInException\n    PageNotFoundException = UserFacingExceptions.PageNotFoundException\n    UnauthorizedUserException = UserFacingExceptions.UnauthorizedUserException\n\n\nclass Error404Handler(BaseHandler[Dict[str, str], Dict[str, str]]):\n    \"\"\"Handles 404 errors.\"\"\"\n\n    pass\n\n\nclass RaiseErrorOnGet:\n    \"\"\"Class that will throw a ValueError when the get function is invoked.\"\"\"\n\n    def __init__(self, message: str) -> None:\n        self.error_message = message\n\n    # Here we use type Any because the 'get' method can accept arbitrary number\n    # of arguments with different types.\n    def get(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"Raises an error when invoked.\"\"\"\n        raise ValueError(self.error_message)\n\n\nclass CsrfTokenManager:\n    \"\"\"Manages page/user tokens in memcache to protect against CSRF.\"\"\"\n\n    # Max age of the token (48 hours).\n    _CSRF_TOKEN_AGE_SECS: Final = 60 * 60 * 48\n    # Default user id for non-logged-in users.\n    _USER_ID_DEFAULT: Final = 'non_logged_in_user'\n\n    @classmethod\n    def init_csrf_secret(cls) -> None:\n        \"\"\"Verify that non-default CSRF secret exists; creates one if not.\"\"\"\n\n        # Any non-default value is fine.\n        if CSRF_SECRET.value and CSRF_SECRET.value != DEFAULT_CSRF_SECRET:\n            return\n\n        # Initialize to random value.\n        config_services.set_property(\n            feconf.SYSTEM_COMMITTER_ID, CSRF_SECRET.name,\n            base64.urlsafe_b64encode(os.urandom(20)))\n\n    @classmethod\n    def _create_token(cls, user_id: Optional[str], issued_on: float) -> str:\n        \"\"\"Creates a new CSRF token.\n\n        Args:\n            user_id: str|None. The user_id for which the token is generated.\n            issued_on: float. The timestamp at which the token was issued.\n\n        Returns:\n            str. The generated CSRF token.\n        \"\"\"\n        cls.init_csrf_secret()\n\n        # The token has 4 parts: hash of the actor user id, hash of the page\n        # name, hash of the time issued and plain text of the time issued.\n\n        if user_id is None:\n            user_id = cls._USER_ID_DEFAULT\n\n        # Round time to seconds.\n        issued_on_str = str(int(issued_on))\n\n        digester = hmac.new(\n            key=CSRF_SECRET.value.encode('utf-8'),\n            digestmod='md5'\n        )\n        digester.update(user_id.encode('utf-8'))\n        digester.update(b':')\n        digester.update(issued_on_str.encode('utf-8'))\n\n        digest = digester.digest()\n        # The b64encode returns bytes, so we first need to decode the returned\n        # bytes to string.\n        token = '%s/%s' % (\n            issued_on_str, base64.urlsafe_b64encode(digest).decode('utf-8'))\n\n        return token\n\n    @classmethod\n    def _get_current_time(cls) -> float:\n        \"\"\"Returns the current server time.\n\n        Returns:\n            float. The time in seconds as floating point number.\n        \"\"\"\n        return time.time()\n\n    @classmethod\n    def create_csrf_token(cls, user_id: Optional[str]) -> str:\n        \"\"\"Creates a CSRF token for the given user_id.\n\n        Args:\n            user_id: str|None. The user_id for whom the token is generated.\n\n        Returns:\n            str. The generated CSRF token.\n        \"\"\"\n        return cls._create_token(user_id, cls._get_current_time())\n\n    @classmethod\n    def is_csrf_token_valid(cls, user_id: Optional[str], token: str) -> bool:\n        \"\"\"Validates a given CSRF token.\n\n        Args:\n            user_id: str|None. The user_id to validate the CSRF token against.\n            token: str. The CSRF token to validate.\n\n        Returns:\n            bool. Whether the given CSRF token is valid.\n        \"\"\"\n        try:\n            parts = token.split('/')\n            if len(parts) != 2:\n                return False\n\n            issued_on = int(parts[0])\n            age = cls._get_current_time() - issued_on\n            if age > cls._CSRF_TOKEN_AGE_SECS:\n                return False\n\n            authentic_token = cls._create_token(user_id, issued_on)\n            if authentic_token == token:\n                return True\n\n            return False\n        except Exception:\n            return False\n\n\nclass CsrfTokenHandler(BaseHandler[Dict[str, str], Dict[str, str]]):\n    \"\"\"Handles sending CSRF tokens to the frontend.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    REDIRECT_UNFINISHED_SIGNUPS = False\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n    # Here we use MyPy ignore because the signature of 'get' method is not\n    # compatible with super class's (BaseHandler) 'get' method.\n    def get(self) -> None:  # type: ignore[override]\n        csrf_token = CsrfTokenManager.create_csrf_token(\n            self.user_id)\n        self.render_json({\n            'token': csrf_token,\n        })\n\n\nclass OppiaMLVMHandler(\n    BaseHandler[_NormalizedPayloadDictType, _NormalizedRequestDictType]\n):\n    \"\"\"Base class for the handlers that communicate with Oppia-ML VM instances.\n    \"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    # Here we use type Any because the sub-classes of OppiaMLVMHandler can\n    # contain different schemas with different types of values, like str,\n    # complex Dicts and etc.\n    URL_PATH_ARGS_SCHEMAS: Dict[str, Any] = {}\n    # Here we use type Any because the sub-classes of OppiaMLVMHandler can\n    # contain different schemas with different types of values, like str,\n    # complex Dicts and etc.\n    HANDLER_ARGS_SCHEMAS: Dict[str, Any] = {}\n\n    @abc.abstractmethod\n    def extract_request_message_vm_id_and_signature(\n        self\n    ) -> classifier_domain.OppiaMLAuthInfo:\n        \"\"\"Returns the OppiaMLAuthInfo domain object containing\n        information from the incoming request that is necessary for\n        authentication.\n\n        Since incoming request can be either a protobuf serialized binary or\n        a JSON object, the derived classes must implement the necessary\n        logic to decode the incoming request and return a tuple of size 3\n        where message is at index 0, vm_id is at index 1 and signature is at\n        index 2.\n\n        Raises:\n            NotImplementedError. The derived child classes must implement the\n                necessary logic as described above.\n        \"\"\"\n        raise NotImplementedError\n", "# coding: utf-8\n#\n# Copyright 2014 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for generic controller behavior.\"\"\"\n\nfrom __future__ import annotations\n\nimport contextlib\nimport importlib\nimport inspect\nimport io\nimport json\nimport logging\nimport os\nimport re\nimport types\n\nfrom core import feconf\nfrom core import handler_schema_constants\nfrom core import utils\nfrom core.constants import constants\nfrom core.controllers import acl_decorators\nfrom core.controllers import base\nfrom core.controllers import payload_validator\nfrom core.domain import auth_domain\nfrom core.domain import classifier_domain\nfrom core.domain import classifier_services\nfrom core.domain import exp_services\nfrom core.domain import rights_manager\nfrom core.domain import taskqueue_services\nfrom core.domain import user_services\nfrom core.domain import wipeout_service\nfrom core.platform import models\nfrom core.tests import test_utils\nimport main\n\nfrom typing import Dict, Final, FrozenSet, List, Optional, TypedDict\nimport webapp2\nfrom webapp2_extras import routes\nimport webtest\n\nMYPY = False\nif MYPY:  # pragma: no cover\n    from mypy_imports import platform_auth_services as auth_services\n\nauth_services = models.Registry.import_auth_services()\ndatastore_services = models.Registry.import_datastore_services()\nsecrets_services = models.Registry.import_secrets_services()\n(user_models,) = models.Registry.import_models([models.Names.USER])\n\nFORTY_EIGHT_HOURS_IN_SECS: Final = 48 * 60 * 60\nPADDING: Final = 1\n\n\nclass HelperFunctionTests(test_utils.GenericTestBase):\n\n    def test_load_template(self) -> None:\n        oppia_root_path = os.path.join(\n            'core', 'templates', 'pages', 'oppia-root')\n        with self.swap(feconf, 'FRONTEND_TEMPLATES_DIR', oppia_root_path):\n            self.assertIn(\n                '\"Loading | Oppia\"',\n                base.load_template(\n                    'oppia-root.mainpage.html',\n                    template_is_aot_compiled=False\n                )\n            )\n\n\nclass UniqueTemplateNamesTests(test_utils.GenericTestBase):\n    \"\"\"Tests to ensure that all template filenames in\n    core/templates/pages have unique filenames. This is required\n    for the backend tests to work correctly since they fetch templates\n    from this directory based on name of the template. For details, refer\n    get_filepath_from_filename function in test_utils.py.\n    \"\"\"\n\n    def test_template_filenames_are_unique(self) -> None:\n        templates_dir = os.path.join(\n            'core', 'templates', 'pages')\n        all_template_names: List[str] = []\n        for root, _, filenames in os.walk(templates_dir):\n            template_filenames = [\n                filename for filename in filenames if filename.endswith(\n                    '.html')]\n            all_template_names = all_template_names + template_filenames\n        self.assertEqual(len(all_template_names), len(set(all_template_names)))\n\n\nclass BaseHandlerTests(test_utils.GenericTestBase):\n\n    TEST_LEARNER_EMAIL: Final = 'test.learner@example.com'\n    TEST_LEARNER_USERNAME: Final = 'testlearneruser'\n    TEST_CREATOR_EMAIL: Final = 'test.creator@example.com'\n    TEST_CREATOR_USERNAME: Final = 'testcreatoruser'\n    TEST_EDITOR_EMAIL: Final = 'test.editor@example.com'\n    TEST_EDITOR_USERNAME: Final = 'testeditoruser'\n    DELETED_USER_EMAIL: Final = 'deleted.user@example.com'\n    DELETED_USER_USERNAME: Final = 'deleteduser'\n    PARTIALLY_LOGGED_IN_USER_EMAIL: Final = 'partial@example.com'\n\n    class MockHandlerWithInvalidReturnType(\n        base.BaseHandler[Dict[str, str], Dict[str, str]]\n    ):\n        GET_HANDLER_ERROR_RETURN_TYPE = 'invalid_type'\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n        # Here we use MyPy ignore because the signature of 'get' method does not\n        # match with the signature of super class's (BaseHandler) 'get' method,\n        # and this happens because all handler methods in the main codebase have\n        # decorators which modify the function signature accordingly, but these\n        # methods in base_test.py do not.\n        def get(self) -> None:  # type: ignore[override]\n            self.render_template('invalid_page.html')\n\n        def options(self) -> None:\n            \"\"\"Do a OPTIONS request. This is an unrecognized request method in our\n            codebase.\n            \"\"\"\n            self.render_template('invalid_page.html')\n\n    class MockHandlerForTestingErrorPageWithIframed(\n        base.BaseHandler[Dict[str, str], Dict[str, str]]\n    ):\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n        # Here we use MyPy ignore because the signature of 'get' method does not\n        # match with the signature of super class's (BaseHandler) 'get' method,\n        # and this happens because all handler methods in the main codebase have\n        # decorators which modify the function signature accordingly, but these\n        # methods in base_test.py do not.\n        def get(self) -> None:  # type: ignore[override]\n            self.iframed = True\n            self.render_template('invalid_page.html')\n\n    class MockHandlerForTestingUiAccessWrapper(\n        base.BaseHandler[Dict[str, str], Dict[str, str]]\n    ):\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n        # Here we use MyPy ignore because the signature of 'get' method does not\n        # match with the signature of super class's (BaseHandler) 'get' method,\n        # and this happens because all handler methods in the main codebase have\n        # decorators which modify the function signature accordingly, but these\n        # methods in base_test.py do not.\n        def get(self) -> None:  # type: ignore[override]\n            \"\"\"Handles GET requests.\"\"\"\n            pass\n\n    class MockHandlerForTestingAuthorizationWrapper(\n        base.BaseHandler[Dict[str, str], Dict[str, str]]\n    ):\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n        # Here we use MyPy ignore because the signature of 'get' method does not\n        # match with the signature of super class's (BaseHandler) 'get' method,\n        # and this happens because all handler methods in the main codebase have\n        # decorators which modify the function signature accordingly, but these\n        # methods in base_test.py do not.\n        def get(self) -> None:  # type: ignore[override]\n            \"\"\"Handles GET requests.\"\"\"\n            pass\n\n    def setUp(self) -> None:\n        super(BaseHandlerTests, self).setUp()\n        self.signup('user@example.com', 'user')\n\n        # Create a user to test redirect behavior for the learner.\n        # A \"learner\" is defined as a user who has not created or contributed\n        # to any exploration ever.\n        self.signup(self.TEST_LEARNER_EMAIL, self.TEST_LEARNER_USERNAME)\n\n        # Create two users to test redirect behavior for the creators.\n        # A \"creator\" is defined as a user who has created, edited or\n        # contributed to any exploration at present or in past.\n        self.signup(self.TEST_CREATOR_EMAIL, self.TEST_CREATOR_USERNAME)\n        self.signup(self.TEST_EDITOR_EMAIL, self.TEST_EDITOR_USERNAME)\n\n        # Create user that is scheduled for deletion.\n        self.signup(self.DELETED_USER_EMAIL, self.DELETED_USER_USERNAME)\n        deleted_user_id = self.get_user_id_from_email(self.DELETED_USER_EMAIL)\n        wipeout_service.pre_delete_user(deleted_user_id)\n\n        # Create a new user but do not submit their registration form.\n        user_services.create_new_user(\n            self.get_auth_id_from_email(self.PARTIALLY_LOGGED_IN_USER_EMAIL),\n            self.PARTIALLY_LOGGED_IN_USER_EMAIL)\n\n    def test_that_no_get_results_in_500_error(self) -> None:\n        \"\"\"Test that no GET request results in a 500 error.\"\"\"\n\n        for route in main.URLS:\n            url = re.sub('<([^/^:]+)>', 'abc123', route.template)\n\n            # This url is ignored since it is only needed for a protractor test.\n            # The backend tests fetch templates from\n            # core/templates/pages instead of webpack_bundles since we\n            # skip webpack compilation for backend tests.\n            # The console_errors.html template is present in\n            # core/templates/tests and we want one canonical\n            # directory for retrieving templates so we ignore this url.\n            if url == '/console_errors':\n                continue\n\n            with self.swap_to_always_return(\n                secrets_services, 'get_secret', 'secret'\n            ):\n                # Some of these will 404 or 302. This is expected.\n                self.get_response_without_checking_for_errors(\n                    url, [200, 301, 302, 400, 401, 404])\n\n        # TODO(sll): Add similar tests for POST, PUT, DELETE.\n        # TODO(sll): Set a self.payload attr in the BaseHandler for\n        #     POST, PUT and DELETE. Something needs to regulate what\n        #     the fields in the payload should be.\n\n    def test_requests_for_missing_csrf_token(self) -> None:\n        \"\"\"Tests request without csrf_token results in 401 error.\"\"\"\n\n        self.post_json(\n            '/community-library/any', data={}, expected_status_int=401)\n\n        self.put_json(\n            '/community-library/any', payload={}, expected_status_int=401)\n\n    def test_requests_for_invalid_paths(self) -> None:\n        \"\"\"Test that requests for invalid paths result in a 404 error.\"\"\"\n        user_id = user_services.get_user_id_from_username('learneruser')\n        csrf_token = base.CsrfTokenManager.create_csrf_token(user_id)\n\n        self.get_html_response(\n            '/community-library/extra', expected_status_int=404)\n\n        self.get_html_response(\n            '/community-library/data/extra', expected_status_int=404)\n\n        self.post_json(\n            '/community-library/extra', data={}, csrf_token=csrf_token,\n            expected_status_int=404)\n\n        self.put_json(\n            '/community-library/extra', payload={}, csrf_token=csrf_token,\n            expected_status_int=404)\n\n        self.delete_json('/community-library/data', expected_status_int=404)\n\n    def test_html_requests_have_no_store_cache_policy(self) -> None:\n        response = self.get_html_response('/community-library')\n        # We set 'no-store' and 'must-revalidate', but webapp\n        # adds 'no-cache' since it is basically a subset of 'no-store'.\n        self.assertEqual(\n            response.headers['Cache-Control'],\n            'must-revalidate, no-cache, no-store'\n        )\n\n    def test_root_redirect_rules_for_deleted_user_prod_mode(self) -> None:\n        with self.swap(constants, 'DEV_MODE', False):\n            self.login(self.DELETED_USER_EMAIL)\n            response = self.get_html_response('/', expected_status_int=302)\n            self.assertIn('pending-account-deletion', response.headers['location'])\n\n    def test_root_redirect_rules_for_deleted_user_dev_mode(self) -> None:\n        with self.swap(constants, 'DEV_MODE', True):\n            self.login(self.DELETED_USER_EMAIL)\n            response = self.get_html_response('/', expected_status_int=302)\n            self.assertIn('pending-account-deletion', response.headers['location'])\n\n    def test_get_with_invalid_return_type_logs_correct_warning(self) -> None:\n        # Modify the testapp to use the mock handler.\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock', self.MockHandlerWithInvalidReturnType,\n                name='MockHandlerWithInvalidReturnType')],\n            debug=feconf.DEBUG,\n        ))\n\n        observed_log_messages: List[str] = []\n        def mock_logging_function(msg: str) -> None:\n            observed_log_messages.append(msg)\n\n        with self.swap(logging, 'warning', mock_logging_function):\n            self.get_json('/mock', expected_status_int=500)\n            self.assertEqual(len(observed_log_messages), 1)\n            self.assertEqual(\n                observed_log_messages[0],\n                'Not a recognized return type: defaulting to render JSON.')\n\n    def test_unrecognized_request_method_logs_correct_warning(self) -> None:\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock', self.MockHandlerWithInvalidReturnType,\n                name='MockHandlerWithInvalidReturnType')],\n            debug=feconf.DEBUG,\n        ))\n\n        observed_log_messages: List[str] = []\n        def mock_logging_function(msg: str) -> None:\n            observed_log_messages.append(msg)\n\n        with self.swap(logging, 'warning', mock_logging_function):\n            self.testapp.options('/mock', status=500)\n            self.assertEqual(len(observed_log_messages), 1)\n            self.assertEqual(\n                observed_log_messages[0],\n                'Not a recognized request method.')\n\n    def test_renders_error_page_with_iframed(self) -> None:\n        # Modify the testapp to use the mock handler.\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_iframed', self.MockHandlerForTestingErrorPageWithIframed,\n                name='MockHandlerForTestingErrorPageWithIframed')],\n            debug=feconf.DEBUG,\n        ))\n        # The 500 is expected because the template file does not exist\n        # (so it is a legitimate server error caused by the\n        # MockHandlerForTestingErrorPageWithIframed).\n        response = self.get_html_response(\n            '/mock_iframed', expected_status_int=500)\n\n        self.assertIn(\n            b'<oppia-error-iframed-page-root></oppia-error-iframed-page-root>',\n            response.body\n        )\n\n    def test_dev_mode_cannot_be_true_on_production(self) -> None:\n        server_software_swap = self.swap(\n            os, 'environ', {'SERVER_SOFTWARE': 'Production'})\n        assert_raises_regexp_context_manager = self.assertRaisesRegex(\n            Exception, 'DEV_MODE can\\'t be true on production.')\n        with assert_raises_regexp_context_manager, server_software_swap:\n            # This reloads the feconf module so that all the checks in\n            # the module are reexecuted.\n            importlib.reload(feconf)  # pylint: disable-all\n\n    def test_frontend_error_handler(self) -> None:\n        observed_log_messages: List[str] = []\n\n        def _mock_logging_function(msg: str, *args: str) -> None:\n            \"\"\"Mocks logging.error().\"\"\"\n            observed_log_messages.append(msg % args)\n\n        with self.swap(logging, 'error', _mock_logging_function):\n            self.post_json('/frontend_errors', {'error': 'errors'})\n\n        self.assertEqual(observed_log_messages, ['Frontend error: errors'])\n\n    def test_redirect_when_user_is_disabled(self) -> None:\n        get_auth_claims_from_request_swap = self.swap_to_always_raise(\n            auth_services,\n            'get_auth_claims_from_request',\n            auth_domain.UserDisabledError\n        )\n        with get_auth_claims_from_request_swap:\n            response = self.get_html_response('/', expected_status_int=302)\n            self.assertIn(\n                'pending-account-deletion', response.headers['location'])\n\n    def test_redirect_oppia_test_server(self) -> None:\n        # The old demo server redirects to the new demo server.\n        response = self.get_html_response(\n            'https://oppiaserver.appspot.com/splash', expected_status_int=301)\n        self.assertEqual(\n            response.headers['Location'], 'https://oppiatestserver.appspot.com')\n\n    def test_no_redirection_for_cron_jobs(self) -> None:\n        # Valid URL, where user now has permissions.\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        self.get_json('/cron/models/cleanup', expected_status_int=200)\n        self.logout()\n\n        # Valid URL, but user does not have permissions.\n        self.get_json(\n            'https://oppiaserver.appspot.com/cron/models/cleanup',\n            expected_status_int=401)\n\n        # Invalid URL.\n        self.get_html_response(\n            'https://oppiaserver.appspot.com/cron/unknown',\n            expected_status_int=404)\n\n    def test_no_redirection_for_tasks(self) -> None:\n        tasks_data = '{\"fn_identifier\": \"%s\", \"args\": [[]], \"kwargs\": {}}' % (\n            taskqueue_services.FUNCTION_ID_DELETE_EXPS_FROM_USER_MODELS\n        )\n\n        # Valid URL, where user now has permissions.\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        self.post_json(\n            'https://oppiaserver.appspot.com/task/deferredtaskshandler',\n            tasks_data,\n            use_payload=False,\n            expected_status_int=200\n        )\n        self.logout()\n\n        # Valid URL, but user does not have permissions.\n        self.post_json(\n            'https://oppiaserver.appspot.com/task/deferredtaskshandler',\n            tasks_data,\n            expected_status_int=401\n        )\n\n    def test_splash_redirect(self) -> None:\n        # Tests that the old '/splash' URL is redirected to '/'.\n        response = self.get_html_response('/splash', expected_status_int=302)\n        self.assertEqual('http://localhost/', response.headers['location'])\n\n    def test_partially_logged_in_redirect(self) -> None:\n        login_context = self.login_context(\n            self.PARTIALLY_LOGGED_IN_USER_EMAIL)\n\n        with login_context:\n            response = self.get_html_response(\n                '/splash', expected_status_int=302)\n            self.assertEqual(\n                response.location,\n                'http://localhost/logout?redirect_url=/splash')\n\n    def test_no_partially_logged_in_redirect_from_logout(self) -> None:\n        login_context = self.login_context(\n            self.PARTIALLY_LOGGED_IN_USER_EMAIL)\n\n        with login_context:\n            response = self.get_html_response(\n                '/logout', expected_status_int=200)\n\n    def test_unauthorized_user_exception_raised_when_session_is_stale(\n        self\n    ) -> None:\n        with contextlib.ExitStack() as exit_stack:\n            call_counter = exit_stack.enter_context(self.swap_with_call_counter(\n                auth_services, 'destroy_auth_session'))\n            logs = exit_stack.enter_context(\n                self.capture_logging(min_level=logging.ERROR))\n            exit_stack.enter_context(self.swap_to_always_raise(\n                auth_services, 'get_auth_claims_from_request',\n                error=auth_domain.StaleAuthSessionError('uh-oh')))\n\n            response = self.get_html_response('/', expected_status_int=302)\n\n        self.assertEqual(call_counter.times_called, 1)\n        self.assertEqual(\n            response.location,\n            'http://localhost/login?return_url=http%3A%2F%2Flocalhost%2F')\n\n    def test_unauthorized_user_exception_raised_when_session_is_invalid(\n        self\n    ) -> None:\n        with contextlib.ExitStack() as exit_stack:\n            call_counter = exit_stack.enter_context(self.swap_with_call_counter(\n                auth_services, 'destroy_auth_session'))\n            logs = exit_stack.enter_context(\n                self.capture_logging(min_level=logging.ERROR))\n            exit_stack.enter_context(self.swap_to_always_raise(\n                auth_services, 'get_auth_claims_from_request',\n                error=auth_domain.InvalidAuthSessionError('uh-oh')))\n\n            response = self.get_html_response('/', expected_status_int=302)\n\n        self.assert_matches_regexps(logs, ['User session is invalid!'])\n        self.assertEqual(call_counter.times_called, 1)\n        self.assertEqual(\n            response.location,\n            'http://localhost/login?return_url=http%3A%2F%2Flocalhost%2F')\n\n    def test_signup_attempt_on_wrong_page_fails(self) -> None:\n        with contextlib.ExitStack() as exit_stack:\n            call_counter = exit_stack.enter_context(self.swap_with_call_counter(\n                auth_services, 'destroy_auth_session'))\n            logs = exit_stack.enter_context(\n                self.capture_logging(min_level=logging.ERROR))\n            exit_stack.enter_context(self.swap_to_always_return(\n                auth_services,\n                'get_auth_claims_from_request',\n                auth_domain.AuthClaims(\n                    'auth_id', self.NEW_USER_EMAIL, role_is_super_admin=False)\n            ))\n            response = self.get_html_response('/', expected_status_int=200)\n            self.assertIn(\n                b'<lightweight-oppia-root></lightweight-oppia-root>',\n                response.body\n            )\n\n        self.assert_matches_regexps(\n            logs,\n            [\n                'Cannot find user auth_id with email %s on '\n                'page http://localhost/' % self.NEW_USER_EMAIL\n            ]\n        )\n        self.assertEqual(call_counter.times_called, 1)\n\n    def test_user_without_email_id_raises_exception(self) -> None:\n        with contextlib.ExitStack() as exit_stack:\n            swap_auth_claim = self.swap_to_always_return(\n                auth_services,\n                'get_auth_claims_from_request',\n                auth_domain.AuthClaims(\n                    'auth_id', None, role_is_super_admin=False)\n            )\n            logs = exit_stack.enter_context(\n                self.capture_logging(min_level=logging.ERROR)\n            )\n            with swap_auth_claim:\n                self.get_html_response('/')\n\n        self.assert_matches_regexps(\n            logs,\n            [\n                'No email address was found for the user.'\n            ]\n        )\n\n    def test_logs_request_with_invalid_payload(self) -> None:\n        with contextlib.ExitStack() as exit_stack:\n            logs = exit_stack.enter_context(\n                self.capture_logging(min_level=logging.ERROR))\n            exit_stack.enter_context(self.swap_to_always_raise(\n                webapp2.Request, 'get',\n                error=ValueError('uh-oh')))\n            self.get_custom_response(\n                '/',\n                expected_content_type='text/plain',\n                params=None,\n                expected_status_int=500)\n\n        self.assertRegexpMatches(\n            logs[0],\n            'uh-oh: request GET /')\n\n\nclass MissingHandlerArgsTests(test_utils.GenericTestBase):\n\n    class MissingArgsHandler(\n        base.BaseHandler[Dict[str, str], Dict[str, str]]\n    ):\n        \"\"\"Mock handler for testing.\"\"\"\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n\n        # Here we use MyPy ignore because the signature of 'post' method does\n        # not match with the signature of super class's (BaseHandler) 'post'\n        # method, and this happens because all handler methods in the main\n        # codebase have decorators which modify the function signature\n        # accordingly, but these methods in base_test.py do not.\n        def post(self) -> None:  # type: ignore[override]\n            \"\"\"Handles POST requests.\"\"\"\n            self.render_json({})\n\n    def setUp(self) -> None:\n        super(MissingHandlerArgsTests, self).setUp()\n\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n\n        # Modify the testapp to use the MissingArgsHandler.\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [\n                webapp2.Route(\n                    '/MissingArgHandler',\n                    self.MissingArgsHandler,\n                    name='MissingArgHandler'\n                )\n            ],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_missing_arg_handler_raises_error(self) -> None:\n        response = self.testapp.post('/MissingArgHandler', status=500)\n        parsed_response = json.loads(response.body[len(feconf.XSSI_PREFIX):])\n        self.assertEqual(\n            parsed_response['error'],\n            'Missing schema for POST method in MissingArgsHandler handler class.'\n        )\n\n\nclass MaintenanceModeTests(test_utils.GenericTestBase):\n    \"\"\"Tests BaseHandler behavior when maintenance mode is enabled.\n\n    Each test case runs within a context where ENABLE_MAINTENANCE_MODE is True.\n    \"\"\"\n\n    def setUp(self) -> None:\n        super(MaintenanceModeTests, self).setUp()\n        self.signup(\n            self.RELEASE_COORDINATOR_EMAIL, self.RELEASE_COORDINATOR_USERNAME)\n        self.add_user_role(\n            self.RELEASE_COORDINATOR_USERNAME,\n            feconf.ROLE_ID_RELEASE_COORDINATOR)\n        with contextlib.ExitStack() as context_stack:\n            context_stack.enter_context(\n                self.swap(feconf, 'ENABLE_MAINTENANCE_MODE', True))\n            self.context_stack = context_stack.pop_all()\n\n    def tearDown(self) -> None:\n        self.context_stack.close()\n        super(MaintenanceModeTests, self).tearDown()\n\n    def test_html_response_is_rejected(self) -> None:\n        destroy_auth_session_call_counter = self.context_stack.enter_context(\n            self.swap_with_call_counter(auth_services, 'destroy_auth_session'))\n\n        response = self.get_html_response(\n            '/community-library', expected_status_int=200)\n\n        self.assertIn(b'<oppia-maintenance-page>', response.body)\n        self.assertNotIn(b'<oppia-library-page-root>', response.body)\n        self.assertEqual(destroy_auth_session_call_counter.times_called, 1)\n\n    def test_html_response_is_not_rejected_when_user_is_super_admin(\n        self\n    ) -> None:\n        self.context_stack.enter_context(self.super_admin_context())\n        destroy_auth_session_call_counter = self.context_stack.enter_context(\n            self.swap_with_call_counter(auth_services, 'destroy_auth_session'))\n\n        response = self.get_html_response('/community-library')\n\n        self.assertIn(b'<oppia-root></oppia-root>', response.body)\n        self.assertNotIn(b'<oppia-maintenance-page>', response.body)\n        self.assertEqual(destroy_auth_session_call_counter.times_called, 0)\n\n    def test_html_response_is_not_rejected_when_user_is_release_coordinator(\n        self\n    ) -> None:\n        self.context_stack.enter_context(\n            self.login_context(self.RELEASE_COORDINATOR_EMAIL))\n        destroy_auth_session_call_counter = self.context_stack.enter_context(\n            self.swap_with_call_counter(auth_services, 'destroy_auth_session'))\n\n        response = self.get_html_response('/community-library')\n\n        self.assertIn(b'<oppia-root></oppia-root>', response.body)\n        self.assertNotIn(b'<oppia-maintenance-page>', response.body)\n        self.assertEqual(destroy_auth_session_call_counter.times_called, 0)\n\n    def test_csrfhandler_handler_is_not_rejected(self) -> None:\n        response = self.get_json('/csrfhandler')\n\n        self.assertTrue(\n            base.CsrfTokenManager.is_csrf_token_valid(None, response['token']))\n\n    def test_session_begin_handler_is_not_rejected(self) -> None:\n        call_counter = self.context_stack.enter_context(\n            self.swap_with_call_counter(\n                auth_services, 'establish_auth_session'))\n\n        self.get_html_response('/session_begin', expected_status_int=200)\n\n        self.assertEqual(call_counter.times_called, 1)\n\n    def test_session_end_handler_is_not_rejected(self) -> None:\n        call_counter = self.context_stack.enter_context(\n            self.swap_with_call_counter(auth_services, 'destroy_auth_session'))\n\n        self.get_html_response('/session_end', expected_status_int=200)\n\n        self.assertEqual(call_counter.times_called, 1)\n\n    def test_signup_fails(self) -> None:\n        with self.assertRaisesRegex(\n            Exception, '\\'<oppia-maintenance-page>\\' unexpectedly found in'):\n            self.signup(self.VIEWER_EMAIL, self.VIEWER_USERNAME)\n\n    def test_signup_succeeds_when_maintenance_mode_is_disabled(self) -> None:\n        with self.swap(feconf, 'ENABLE_MAINTENANCE_MODE', False):\n            self.signup(self.VIEWER_EMAIL, self.VIEWER_USERNAME)\n\n    def test_signup_succeeds_when_user_is_super_admin(self) -> None:\n        self.signup(\n            self.CURRICULUM_ADMIN_EMAIL,\n            self.CURRICULUM_ADMIN_USERNAME,\n            is_super_admin=True\n        )\n\n    def test_admin_auth_session_is_preserved_when_in_maintenance_mode(\n        self\n    ) -> None:\n        # TODO(#12692): Use stateful login sessions to assert the behavior of\n        # logging out, rather than asserting that destroy_auth_session() gets\n        # called.\n        destroy_auth_session_call_counter = self.context_stack.enter_context(\n            self.swap_with_call_counter(auth_services, 'destroy_auth_session'))\n        self.context_stack.enter_context(self.super_admin_context())\n\n        with self.swap(feconf, 'ENABLE_MAINTENANCE_MODE', False):\n            self.get_json('/url_handler?current_url=/')\n\n        self.assertEqual(destroy_auth_session_call_counter.times_called, 0)\n\n        self.get_json('/url_handler?current_url=/')\n\n        self.assertEqual(destroy_auth_session_call_counter.times_called, 0)\n\n    def test_non_admin_auth_session_is_destroyed_when_in_maintenance_mode(\n        self\n    ) -> None:\n        # TODO(#12692): Use stateful login sessions to assert the behavior of\n        # logging out, rather than asserting that destroy_auth_session() gets\n        # called.\n        destroy_auth_session_call_counter = self.context_stack.enter_context(\n            self.swap_with_call_counter(auth_services, 'destroy_auth_session'))\n\n        with self.swap(feconf, 'ENABLE_MAINTENANCE_MODE', False):\n            self.get_json('/url_handler?current_url=/')\n\n        self.assertEqual(destroy_auth_session_call_counter.times_called, 0)\n\n        response = self.get_html_response('/url_handler?current_url=/')\n        self.assertIn(b'<oppia-maintenance-page>', response.body)\n\n        self.assertEqual(destroy_auth_session_call_counter.times_called, 1)\n\n\nclass CsrfTokenManagerTests(test_utils.GenericTestBase):\n\n    def test_create_and_validate_token(self) -> None:\n        uid = 'user_id'\n\n        token = base.CsrfTokenManager.create_csrf_token(uid)\n        self.assertTrue(base.CsrfTokenManager.is_csrf_token_valid(\n            uid, token))\n\n        self.assertFalse(\n            base.CsrfTokenManager.is_csrf_token_valid('bad_user', token))\n        self.assertFalse(\n            base.CsrfTokenManager.is_csrf_token_valid(uid, 'new_token'))\n        self.assertFalse(\n            base.CsrfTokenManager.is_csrf_token_valid(uid, 'new/token'))\n\n    def test_non_default_csrf_secret_is_used(self) -> None:\n        base.CsrfTokenManager.create_csrf_token('uid')\n        self.assertNotEqual(base.CSRF_SECRET.value, base.DEFAULT_CSRF_SECRET)\n\n    def test_token_expiry(self) -> None:\n        # This can be any value.\n        orig_time = 100.0\n        current_time = orig_time\n\n        def mock_get_current_time(unused_cls: str) -> float:\n            return current_time\n\n        with self.swap(\n            base.CsrfTokenManager, '_get_current_time',\n            types.MethodType(mock_get_current_time, base.CsrfTokenManager)):\n            # Create a token and check that it expires correctly.\n            token = base.CsrfTokenManager().create_csrf_token('uid')\n            self.assertTrue(base.CsrfTokenManager.is_csrf_token_valid(\n                'uid', token))\n\n            current_time = orig_time + 1\n            self.assertTrue(base.CsrfTokenManager.is_csrf_token_valid(\n                'uid', token))\n\n            current_time = orig_time + FORTY_EIGHT_HOURS_IN_SECS - PADDING\n            self.assertTrue(base.CsrfTokenManager.is_csrf_token_valid(\n                'uid', token))\n\n            current_time = orig_time + FORTY_EIGHT_HOURS_IN_SECS + PADDING\n            self.assertFalse(base.CsrfTokenManager.is_csrf_token_valid(\n                'uid', token))\n\n\nclass EscapingTests(test_utils.GenericTestBase):\n\n    class FakePage(base.BaseHandler[Dict[str, str], Dict[str, str]]):\n        \"\"\"Fake page for testing autoescaping.\"\"\"\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'POST': {}}\n\n        # Here we use MyPy ignore because the signature of 'post' method does\n        # not match with the signature of super class's (BaseHandler) 'post'\n        # method, and this happens because all handler methods in the main\n        # codebase have decorators which modify the function signature\n        # accordingly, but these methods in base_test.py do not.\n        def post(self) -> None:  # type: ignore[override]\n            \"\"\"Handles POST requests.\"\"\"\n            self.render_json({'big_value': u'\\n<script>\u9a6c={{'})\n\n    def setUp(self) -> None:\n        super(EscapingTests, self).setUp()\n\n        # Update a config property that shows in all pages.\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n\n        # Modify the testapp to use the fake handler.\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/fake', self.FakePage, name='FakePage')],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_special_char_escaping(self) -> None:\n        response = self.testapp.post('/fake', params={})\n        self.assertEqual(response.status_int, 200)\n\n        self.assertTrue(response.body.startswith(feconf.XSSI_PREFIX))\n        self.assertIn(b'\\\\n\\\\u003cscript\\\\u003e\\\\u9a6c={{', response.body)\n        self.assertNotIn(b'<script>', response.body)\n        self.assertNotIn('\u9a6c'.encode('utf-8'), response.body)\n\n\nclass RenderDownloadableTests(test_utils.GenericTestBase):\n\n    class MockHandler(base.BaseHandler[Dict[str, str], Dict[str, str]]):\n        \"\"\"Mock handler that subclasses BaseHandler and serves a response\n        that is of a 'downloadable' type.\n        \"\"\"\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n        # Here we use MyPy ignore because the signature of 'get' method does not\n        # match with the signature of super class's (BaseHandler) 'get' method,\n        # and this happens because all handler methods in the main codebase have\n        # decorators which modify the function signature accordingly, but these\n        # methods in base_test.py do not.\n        def get(self) -> None:  # type: ignore[override]\n            \"\"\"Handles GET requests.\"\"\"\n            file_contents = io.BytesIO(b'example')\n            self.render_downloadable_file(\n                file_contents, 'example.pdf', 'text/plain')\n\n    def setUp(self) -> None:\n        super(RenderDownloadableTests, self).setUp()\n\n        # Modify the testapp to use the mock handler.\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock', self.MockHandler, name='MockHandler')],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_downloadable(self) -> None:\n        response = self.testapp.get('/mock')\n        self.assertEqual(\n            response.content_disposition, 'attachment; filename=example.pdf')\n        self.assertEqual(response.body, b'example')\n        self.assertEqual(response.content_type, 'text/plain')\n\n\nclass SessionBeginHandlerTests(test_utils.GenericTestBase):\n    \"\"\"Tests for /session_begin handler.\"\"\"\n\n    def test_get(self) -> None:\n        swap = self.swap_with_call_counter(\n            auth_services, 'establish_auth_session')\n\n        with swap as call_counter:\n            self.get_html_response('/session_begin', expected_status_int=200)\n\n        self.assertEqual(call_counter.times_called, 1)\n\n\nclass SessionEndHandlerTests(test_utils.GenericTestBase):\n    \"\"\"Tests for /session_end handler.\"\"\"\n\n    def test_get(self) -> None:\n        swap = (\n            self.swap_with_call_counter(auth_services, 'destroy_auth_session'))\n\n        with swap as call_counter:\n            self.get_html_response('/session_end', expected_status_int=200)\n\n        self.assertEqual(call_counter.times_called, 1)\n\n\nclass I18nDictsTests(test_utils.GenericTestBase):\n    \"\"\"Tests for I18n dicts.\"\"\"\n\n    def _extract_keys_from_json_file(self, filename: str) -> List[str]:\n        \"\"\"Returns the extracted keys from the json file corresponding to the\n        given filename.\n        \"\"\"\n        return sorted(json.loads(utils.get_file_contents(\n            os.path.join(os.getcwd(), self.get_static_asset_filepath(),\n                         'assets', 'i18n', filename)\n        )).keys())\n\n    def _extract_keys_from_html_file(self, filename: str) -> List[str]:\n        \"\"\"Returns the extracted keys from the html file corresponding to the\n        given filename.\n        \"\"\"\n        # The \\b is added at the start to ensure that keys ending with\n        # '_I18N_IDS' do not get matched. Instances of such keys can be found\n        # in learner_dashboard.html.\n        regex_pattern = r'(\\bI18N_[A-Z/_\\d]*)'\n        return re.findall(regex_pattern, utils.get_file_contents(\n            filename))\n\n    def _get_tags(\n        self, input_string: str, key: str, filename: str\n    ) -> List[str]:\n        \"\"\"Returns the parts in the input string that lie within <...>\n        characters.\n\n        Args:\n            input_string: str. The string to extract tags from.\n            key: str. The key for the key-value pair in the dict where the\n                string comes from (the string is typically the value in this\n                key-value pair). This is used only for logging errors.\n            filename: str. The filename which the string comes from. This is\n                used only for logging errors.\n\n        Returns:\n            list(str). A list of all tags contained in the input string.\n        \"\"\"\n        result = []\n        bracket_level = 0\n        current_string = ''\n        for c in input_string:\n            if c == '<':\n                current_string += c\n                bracket_level += 1\n            elif c == '>':\n                self.assertGreater(\n                    bracket_level, 0,\n                    msg='Invalid HTML: %s at %s in %s' % (\n                        input_string, key, filename))\n                result.append(current_string + c)\n                current_string = ''\n                bracket_level -= 1\n            elif bracket_level > 0:\n                current_string += c\n\n        self.assertEqual(\n            bracket_level, 0,\n            msg='Invalid HTML: %s at %s in %s' % (input_string, key, filename))\n        return sorted(result)\n\n    def test_i18n_keys(self) -> None:\n        \"\"\"Tests that the keys in all JSON files are a subset of those in\n        en.json.\n        \"\"\"\n        master_key_list = self._extract_keys_from_json_file('en.json')\n        self.assertGreater(len(master_key_list), 0)\n\n        supported_language_filenames = [\n            ('%s.json' % language_details['id'])\n            for language_details in constants.SUPPORTED_SITE_LANGUAGES]\n\n        filenames = os.listdir(\n            os.path.join(os.getcwd(), self.get_static_asset_filepath(),\n                         'assets', 'i18n'))\n        for filename in filenames:\n            if filename == 'en.json':\n                continue\n\n            key_list = self._extract_keys_from_json_file(filename)\n            # All other JSON files should have a subset of the keys in en.json.\n            self.assertEqual(len(set(key_list) - set(master_key_list)), 0)\n\n            # If there are missing keys in supported site languages, log an\n            # error, but don't fail the tests.\n            if (filename in supported_language_filenames and\n                    set(key_list) != set(master_key_list)):\n                untranslated_keys = list(set(master_key_list) - set(key_list))\n                self.log_line('Untranslated keys in %s:' % filename)\n                for key in untranslated_keys:\n                    self.log_line('- %s' % key)\n                self.log_line('')\n\n    def test_alphabetic_i18n_keys(self) -> None:\n        \"\"\"Tests that the keys of all i18n json files are arranged in\n        alphabetical order.\n        \"\"\"\n        filenames = os.listdir(\n            os.path.join(os.getcwd(), self.get_static_asset_filepath(),\n                         'assets', 'i18n'))\n        for filename in filenames:\n            with utils.open_file(\n                os.path.join(os.getcwd(), 'assets', 'i18n', filename),\n                mode='r') as f:\n                lines = f.readlines()\n                self.assertEqual(lines[0], '{\\n')\n                self.assertEqual(lines[-1], '}\\n')\n                lines = lines[1:-1]\n\n                key_list = [line[:line.find(':')].strip() for line in lines]\n                for key in key_list:\n                    self.assertTrue(key.startswith('\"I18N_'))\n                    if not key.startswith('\"I18N_'):\n                        self.log_line('Bad line in file: %s' % filename)\n                self.assertEqual(sorted(key_list), key_list)\n\n    # TODO(#14645): Remove this method when translation service is extended.\n    def test_hacky_tranlsation_keys_match_constants_en(self) -> None:\n        \"\"\"Tests that the hacky translation keys present in constants file\n        are also present in en.json.\n        \"\"\"\n        en_key_list = self._extract_keys_from_json_file('en.json')\n        hacky_translation_keys = constants.HACKY_TRANSLATION_KEYS\n        missing_hacky_translation_keys = list(\n            set(hacky_translation_keys) - set(en_key_list))\n        self.assertEqual(missing_hacky_translation_keys, [])\n\n    def test_keys_match_en_qqq(self) -> None:\n        \"\"\"Tests that en.json and qqq.json have the exact same set of keys.\"\"\"\n        en_key_list = self._extract_keys_from_json_file('en.json')\n        qqq_key_list = self._extract_keys_from_json_file('qqq.json')\n        self.assertEqual(en_key_list, qqq_key_list)\n\n    def test_keys_in_source_code_match_en(self) -> None:\n        \"\"\"Tests that keys in HTML files are present in en.json.\"\"\"\n        en_key_list = self._extract_keys_from_json_file('en.json')\n        dirs_to_search = [\n            os.path.join('core', 'templates', ''),\n            'extensions']\n        files_checked = 0\n        missing_keys_count = 0\n        for directory in dirs_to_search:\n            for root, _, files in os.walk(os.path.join(os.getcwd(), directory)):\n                for filename in files:\n                    if filename.endswith('.html'):\n                        files_checked += 1\n                        html_key_list = self._extract_keys_from_html_file(\n                            os.path.join(root, filename))\n                        if not set(html_key_list) <= set(en_key_list): #pylint: disable=unneeded-not\n                            self.log_line('ERROR: Undefined keys in %s:'\n                                          % os.path.join(root, filename))\n                            missing_keys = list(\n                                set(html_key_list) - set(en_key_list))\n                            missing_keys_count += len(missing_keys)\n                            for key in missing_keys:\n                                self.log_line(' - %s' % key)\n                            self.log_line('')\n        self.assertEqual(missing_keys_count, 0)\n        self.assertGreater(files_checked, 0)\n\n    def test_html_in_translations_is_preserved_correctly(self) -> None:\n        \"\"\"Tests that HTML in translated strings matches the original\n        structure.\n        \"\"\"\n        # For this test, show the entire diff if there is a mismatch.\n        self.maxDiff = 0\n\n        master_translation_dict = json.loads(utils.get_file_contents(\n            os.path.join(os.getcwd(), 'assets', 'i18n', 'en.json')))\n        # Remove anything outside '<'...'>' tags. Note that this handles both\n        # HTML tags and Angular variable interpolations.\n        master_tags_dict = {\n            key: self._get_tags(value, key, 'en.json')\n            for key, value in master_translation_dict.items()\n        }\n\n        mismatches = []\n\n        filenames = os.listdir(os.path.join(\n            os.getcwd(), self.get_static_asset_filepath(), 'assets', 'i18n'))\n        for filename in filenames:\n            if filename == 'qqq.json':\n                continue\n            translation_dict = json.loads(utils.get_file_contents(\n                os.path.join(os.getcwd(), 'assets', 'i18n', filename)))\n            for key, value in translation_dict.items():\n                tags = self._get_tags(value, key, filename)\n                if tags != master_tags_dict[key]:\n                    mismatches.append('%s (%s): %s != %s' % (\n                        filename, key, tags, master_tags_dict[key]))\n\n        # Sorting the list before printing makes it easier to systematically\n        # fix any issues that arise.\n        self.assertEqual(sorted(mismatches), [])\n\n\nclass GetHandlerTypeIfExceptionRaisedTests(test_utils.GenericTestBase):\n\n    class FakeHandler(base.BaseHandler[Dict[str, str], Dict[str, str]]):\n        \"\"\"A fake handler class.\"\"\"\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n        # Here we use MyPy ignore because the signature of 'get' method does not\n        # match with the signature of super class's (BaseHandler) 'get' method,\n        # and this happens because all handler methods in the main codebase have\n        # decorators which modify the function signature accordingly, but these\n        # methods in base_test.py do not.\n        def get(self) -> None:  # type: ignore[override]\n            \"\"\"Handles get requests.\"\"\"\n            raise self.InternalErrorException('fake exception')\n\n    def test_error_response_for_get_request_of_type_json_has_json_format(\n        self\n    ) -> None:\n        fake_urls = []\n        fake_urls.append(main.get_redirect_route(r'/fake', self.FakeHandler))\n        fake_urls.append(main.URLS[-1])\n        with self.swap(main, 'URLS', fake_urls):\n            self.testapp = webtest.TestApp(\n                webapp2.WSGIApplication(main.URLS, debug=feconf.DEBUG))\n            response = self.get_json(\n                '/fake', expected_status_int=500)\n            self.assertTrue(isinstance(response, dict))\n\n\nclass CheckAllHandlersHaveDecoratorTests(test_utils.GenericTestBase):\n    \"\"\"Tests that all methods in handlers have authentication decorators\n    applied on them.\n    \"\"\"\n\n    # Following handlers are present in base.py where acl_decorators cannot be\n    # imported.\n    UNDECORATED_HANDLERS: FrozenSet[str] = frozenset([\n        'CsrfTokenHandler',\n        'Error404Handler',\n        'SessionBeginHandler',\n        'SessionEndHandler',\n        'SeedFirebaseHandler',\n    ])\n\n    def test_every_method_has_decorator(self) -> None:\n        handlers_checked = []\n\n        for route in main.URLS:\n            handler = route.handler\n\n            if handler.__name__ in self.UNDECORATED_HANDLERS:\n                continue\n\n            if handler.get != base.BaseHandler.get:\n                handler_is_decorated = hasattr(handler.get, '__wrapped__')\n                handlers_checked.append(\n                    (handler.__name__, 'GET', handler_is_decorated))\n\n            if handler.post != base.BaseHandler.post:\n                handler_is_decorated = hasattr(handler.post, '__wrapped__')\n                handlers_checked.append(\n                    (handler.__name__, 'POST', handler_is_decorated))\n\n            if handler.put != base.BaseHandler.put:\n                handler_is_decorated = hasattr(handler.put, '__wrapped__')\n                handlers_checked.append(\n                    (handler.__name__, 'PUT', handler_is_decorated))\n\n            if handler.delete != base.BaseHandler.delete:\n                handler_is_decorated = hasattr(handler.delete, '__wrapped__')\n                handlers_checked.append(\n                    (handler.__name__, 'DELETE', handler_is_decorated))\n\n        self.log_line('Verifying decorators for handlers .... ')\n        for (name, method, handler_is_decorated) in handlers_checked:\n            self.log_line('%s %s method: %s' % (\n                name, method, 'PASS' if handler_is_decorated else 'FAIL'))\n        self.log_line(\n            'Total number of handlers checked: %s' % len(handlers_checked))\n\n        self.assertGreater(len(handlers_checked), 0)\n\n        for (name, method, handler_is_decorated) in handlers_checked:\n            with self.subTest('%s.%s' % (name, method)):\n                self.assertTrue(handler_is_decorated)\n\n\nclass GetItemsEscapedCharactersTests(test_utils.GenericTestBase):\n    \"\"\"Test that request.GET.items() correctly retrieves escaped characters.\"\"\"\n    class MockHandler(base.BaseHandler[Dict[str, str], Dict[str, str]]):\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n        # Here we use MyPy ignore because the signature of 'get' method does not\n        # match with the signature of super class's (BaseHandler) 'get' method,\n        # and this happens because all handler methods in the main codebase have\n        # decorators which modify the function signature accordingly, but these\n        # methods in base_test.py do not.\n        def get(self) -> None:  # type: ignore[override]\n            self.values.update(list(self.request.GET.items()))\n            self.render_json(self.values)\n\n    def test_get_items(self) -> None:\n        mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n        with self.swap(self, 'testapp', mock_testapp):\n            params = {\n                'param1': 'value1',\n                'param2': 'value2'\n            }\n            result = self.get_json('/mock?param1=value1&param2=value2')\n            self.assertDictContainsSubset(params, result)\n            params = {\n                'param1': 'value with space',\n                'param2': 'value with & + - /',\n                'param3': 'value with . % @ 123 = ! <>'\n            }\n            result = self.get_json(\n                r'/mock?param1=value%20with%20space&'\n                'param2=value%20with%20%26%20%2B%20-%20/&'\n                'param3=value%20with%20.%20%%20@%20123%20=%20!%20%3C%3E')\n            self.assertDictContainsSubset(params, result)\n\n\nclass ControllerClassNameTests(test_utils.GenericTestBase):\n\n    def test_controller_class_names(self) -> None:\n        \"\"\"This function checks that all controller class names end with\n        either 'Handler', 'Page' or 'FileDownloader'.\n        \"\"\"\n        # A mapping of returned handler types to expected name endings.\n        handler_type_to_name_endings_dict = {\n            feconf.HANDLER_TYPE_HTML: 'Page',\n            feconf.HANDLER_TYPE_JSON: 'Handler',\n            feconf.HANDLER_TYPE_DOWNLOADABLE: 'FileDownloader',\n        }\n        num_handlers_checked = 0\n        for url in main.URLS:\n            clazz = url.handler\n            num_handlers_checked += 1\n            all_base_classes = [\n                base_class.__name__ for base_class in inspect.getmro(clazz)]\n\n            # Check that it is a subclass of 'BaseHandler'.\n            if 'BaseHandler' in all_base_classes:\n                class_return_type = clazz.GET_HANDLER_ERROR_RETURN_TYPE\n                # Check that any class with a get handler has a\n                # GET_HANDLER_ERROR_RETURN_TYPE that's one of\n                # the allowed values.\n                if 'get' in clazz.__dict__.keys():\n                    self.assertIn(\n                        class_return_type, handler_type_to_name_endings_dict)\n                class_name = clazz.__name__\n                # BulkEmailWebhookEndpoint is a unique class, compared to\n                # others, since it is never called from the frontend, and so\n                # the error raised here on it - 'Please ensure that the name\n                # of this class ends with 'Page'' - doesn't apply.\n                # It is only called from the bulk email provider via a\n                # webhook to update Oppia's database.\n                if class_name == 'BulkEmailWebhookEndpoint':\n                    continue\n                file_name = inspect.getfile(clazz)\n                line_num = inspect.getsourcelines(clazz)[1]\n                allowed_class_ending = (\n                    handler_type_to_name_endings_dict[class_return_type])\n                # Check that the name of the class ends with\n                # the proper word if it has a get function.\n                if 'get' in clazz.__dict__.keys():\n                    message = (\n                        'Please ensure that the name of this class '\n                        'ends with \\'%s\\'' % allowed_class_ending)\n                    error_message = (\n                        '%s --> Line %s: %s' % (file_name, line_num, message))\n                    with self.subTest(class_name):\n                        self.assertTrue(\n                            class_name.endswith(allowed_class_ending),\n                            msg=error_message)\n\n                # Check that the name of the class ends with 'Handler'\n                # if it does not has a get function.\n                else:\n                    message = (\n                        'Please ensure that the name of this class '\n                        'ends with \\'Handler\\'')\n                    error_message = (\n                        '%s --> Line %s: %s'\n                        % (file_name, line_num, message))\n                    with self.subTest(class_name):\n                        self.assertTrue(\n                            class_name.endswith('Handler'), msg=error_message)\n\n        self.assertGreater(num_handlers_checked, 275)\n\n\nclass MockHandlerForTestingPageIframingNormalizedRequestDict(TypedDict):\n    \"\"\"Dict representation of MockHandlerForTestingPageIframing's\n    normalized_request dictionary.\n    \"\"\"\n\n    iframe_restriction: Optional[str]\n\n\nclass IframeRestrictionTests(test_utils.GenericTestBase):\n\n    class MockHandlerForTestingPageIframing(\n        base.BaseHandler[\n            Dict[str, str],\n            MockHandlerForTestingPageIframingNormalizedRequestDict\n        ]\n    ):\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS = {\n            'GET': {\n                'iframe_restriction': {\n                    'schema': {\n                        'type': 'basestring'\n                    },\n                    'default_value': None\n                }\n            }\n        }\n\n        # Here we use MyPy ignore because the signature of 'get' method does not\n        # match with the signature of super class's (BaseHandler) 'get' method,\n        # and this happens because all handler methods in the main codebase have\n        # decorators which modify the function signature accordingly, but these\n        # methods in base_test.py do not.\n        def get(self) -> None:  # type: ignore[override]\n            assert self.normalized_request is not None\n            iframe_restriction = self.normalized_request.get('iframe_restriction')\n            self.render_template(\n                'oppia-root.mainpage.html',\n                iframe_restriction=iframe_restriction)\n\n    def setUp(self) -> None:\n        super(IframeRestrictionTests, self).setUp()\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        # Modify the testapp to use the mock handler.\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock', self.MockHandlerForTestingPageIframing,\n                name='MockHandlerForTestingPageIframing')],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_responses_with_valid_iframe_restriction(self) -> None:\n        self.login(self.OWNER_EMAIL)\n        self.get_html_response('/mock')\n\n        response = self.get_html_response(\n            '/mock', params={'iframe_restriction': 'DENY'})\n        self.assertEqual(response.headers['X-Frame-Options'], 'DENY')\n\n        response = self.get_html_response(\n            '/mock', params={'iframe_restriction': 'SAMEORIGIN'})\n        self.assertEqual(response.headers['X-Frame-Options'], 'SAMEORIGIN')\n\n        self.logout()\n\n    def test_responses_with_invalid_iframe_restriction(self) -> None:\n        self.login(self.OWNER_EMAIL)\n        self.get_html_response(\n            '/mock', params={\n                'iframe_restriction': 'invalid_iframe_restriction'},\n            expected_status_int=500)\n        self.logout()\n\n\nclass SignUpTests(test_utils.GenericTestBase):\n\n    def test_error_is_raised_on_opening_new_tab_during_signup(self) -> None:\n        \"\"\"Test that error is raised if user opens a new tab\n        during signup.\n        \"\"\"\n        self.login('abc@example.com')\n        self.get_html_response(feconf.SIGNUP_URL + '?return_url=/')\n        csrf_token = self.get_new_csrf_token()\n\n        response = self.get_html_response('/about', expected_status_int=302)\n        self.assertIn('logout', response.location)\n        self.logout()\n\n        response = self.post_json(\n            feconf.SIGNUP_DATA_URL, {\n                'username': 'abc',\n                'agreed_to_terms': True,\n                'default_dashboard': constants.DASHBOARD_TYPE_LEARNER\n            }, csrf_token=csrf_token, expected_status_int=401,\n        )\n\n        self.assertEqual(response['error'], 'Registration session expired.')\n\n    def test_no_error_is_raised_on_opening_new_tab_after_signup(self) -> None:\n        \"\"\"Test that no error is raised if user opens a new tab\n        after signup.\n        \"\"\"\n        self.login('abc@example.com')\n        self.get_html_response(feconf.SIGNUP_URL + '?return_url=/')\n        csrf_token = self.get_new_csrf_token()\n        self.post_json(\n            feconf.SIGNUP_DATA_URL, {\n                'username': 'abc',\n                'agreed_to_terms': True,\n                'default_dashboard': constants.DASHBOARD_TYPE_LEARNER,\n                'can_receive_email_updates': (\n                    feconf.DEFAULT_EMAIL_UPDATES_PREFERENCE\n                )\n            }, csrf_token=csrf_token,\n        )\n\n        self.get_html_response('/community-library')\n\n    def test_error_is_raised_during_signup_using_invalid_token(self) -> None:\n        \"\"\"Test that error is raised if user tries to signup\n        using invalid CSRF token.\n        \"\"\"\n        self.login('abc@example.com')\n        self.get_html_response(feconf.SIGNUP_URL + '?return_url=/')\n\n        response = self.post_json(\n            feconf.SIGNUP_DATA_URL, {\n                'username': 'abc',\n                'agreed_to_terms': True,\n                'default_dashboard': constants.DASHBOARD_TYPE_LEARNER\n            }, csrf_token='invalid_token', expected_status_int=401,\n        )\n\n        self.assertEqual(response['error'],\n            'Your session has expired, and unfortunately your '\n            'changes cannot be saved. Please refresh the page.')\n\n\nclass CsrfTokenHandlerTests(test_utils.GenericTestBase):\n\n    def test_valid_token_is_returned(self) -> None:\n        \"\"\"Test that a valid CSRF token is returned by\n        the handler.\n        \"\"\"\n\n        response = self.get_json('/csrfhandler')\n        csrf_token = response['token']\n\n        self.assertTrue(base.CsrfTokenManager.is_csrf_token_valid(\n            None, csrf_token))\n\n\nclass CorrectMockVMHandlerNormalizedPayloadDict(TypedDict):\n    \"\"\"Type for the CorrectMockVMHandler's normalized_payload dictionary.\"\"\"\n\n    vm_id: str\n    signature: str\n    message: bytes\n\n\nclass OppiaMLVMHandlerTests(test_utils.GenericTestBase):\n    \"\"\"Unit tests for OppiaMLVMHandler class.\"\"\"\n\n    class IncorrectMockVMHandler(\n        base.OppiaMLVMHandler[Dict[str, str], Dict[str, str]]\n    ):\n        \"\"\"Derived VM Handler class with missing function implementation for\n        extract_request_message_vm_id_and_signature function.\n        \"\"\"\n\n        REQUIRE_PAYLOAD_CSRF_CHECK = False\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS = {\n            'POST': {\n                'vm_id': {'schema': {'type': 'basestring'}},\n                'signature': {'schema': {'type': 'basestring'}},\n                'message': {'schema': {'type': 'basestring'}},\n            }\n        }\n\n        @acl_decorators.is_from_oppia_ml\n        def post(self) -> None:\n            return self.render_json({})\n\n    class CorrectMockVMHandler(\n        base.OppiaMLVMHandler[\n            CorrectMockVMHandlerNormalizedPayloadDict,\n            Dict[str, str]\n        ]\n    ):\n        \"\"\"Derived VM Handler class with\n        extract_request_message_vm_id_and_signature function implementation.\n        \"\"\"\n\n        REQUIRE_PAYLOAD_CSRF_CHECK = False\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS = {\n            'POST': {\n                'vm_id': {'schema': {'type': 'basestring'}},\n                'signature': {'schema': {'type': 'basestring'}},\n                'message': {'schema': {'type': 'basestring'}},\n            }\n        }\n\n        def extract_request_message_vm_id_and_signature(\n            self\n        ) -> classifier_domain.OppiaMLAuthInfo:\n            \"\"\"Returns the message, vm_id and signature retrieved from the\n            incoming requests.\n            \"\"\"\n            assert self.normalized_payload is not None\n            signature = self.normalized_payload['signature']\n            vm_id = self.normalized_payload['vm_id']\n            message = self.normalized_payload['message']\n            return classifier_domain.OppiaMLAuthInfo(message, vm_id, signature)\n\n        @acl_decorators.is_from_oppia_ml\n        def post(self) -> None:\n            self.render_json({'job_id': 'new_job'})\n\n    def setUp(self) -> None:\n        super(OppiaMLVMHandlerTests, self).setUp()\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication([\n            webapp2.Route('/incorrectmock', self.IncorrectMockVMHandler),\n            webapp2.Route('/correctmock', self.CorrectMockVMHandler)],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_that_incorrect_derived_class_raises_exception(self) -> None:\n        payload = {}\n        payload['vm_id'] = feconf.DEFAULT_VM_ID\n        secret = feconf.DEFAULT_VM_SHARED_SECRET\n        payload['message'] = json.dumps('message')\n        payload['signature'] = classifier_services.generate_signature(\n            secret.encode('utf-8'),\n            payload['message'].encode('utf-8'),\n            payload['vm_id'])\n\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.post_json(\n                '/incorrectmock', payload, expected_status_int=500)\n\n    def test_that_correct_derived_class_does_not_raise_exception(self) -> None:\n        def _mock_get_secret(name: str) -> Optional[str]:\n            if name == 'VM_ID':\n                return 'vm_default'\n            elif name == 'SHARED_SECRET_KEY':\n                return '1a2b3c4e'\n            return None\n        swap_secret = self.swap_with_checks(\n            secrets_services,\n            'get_secret',\n            _mock_get_secret,\n            expected_args=[('VM_ID',), ('SHARED_SECRET_KEY',)],\n        )\n        payload = {}\n        payload['vm_id'] = feconf.DEFAULT_VM_ID\n        secret = feconf.DEFAULT_VM_SHARED_SECRET\n        payload['message'] = json.dumps('message')\n        payload['signature'] = classifier_services.generate_signature(\n            secret.encode('utf-8'),\n            payload['message'].encode('utf-8'),\n            payload['vm_id'])\n        with self.swap(self, 'testapp', self.mock_testapp), swap_secret:\n            self.post_json(\n                '/correctmock', payload, expected_status_int=200)\n\n\nclass SchemaValidationIntegrationTests(test_utils.GenericTestBase):\n    \"\"\"Tests all the functionality of SVS(Schema-Validation-System)\n    architecture.\n    \"\"\"\n    handler_class_names_with_no_schema: Final = (\n        handler_schema_constants.HANDLER_CLASS_NAMES_WITH_NO_SCHEMA)\n    wiki_page_link: Final = (\n        'https://github.com/oppia/oppia/wiki/Writing-schema-for-handler-args')\n\n    def _get_list_of_routes_which_need_schemas(\n        self\n    ) -> List[routes.RedirectRoute]:\n        \"\"\"This method iterates over all the routes and returns those routes\n        which need schemas.\n\n        Returns:\n            list(RedirectRoute). A list of RedirectRoute objects.\n        \"\"\"\n        return [route for route in main.URLS]\n\n    def test_every_handler_class_has_schema(self) -> None:\n        \"\"\"This test ensures that every child class of BaseHandler\n        has an associated schema.\n        \"\"\"\n        list_of_handlers_which_need_schemas = []\n        list_of_routes_which_need_schemas = (\n            self._get_list_of_routes_which_need_schemas())\n\n        for route in list_of_routes_which_need_schemas:\n            handler = route.handler\n\n            handler_class_name = handler.__name__\n            if handler_class_name in self.handler_class_names_with_no_schema:\n                continue\n\n            schema_written_for_request_methods = (\n                handler.HANDLER_ARGS_SCHEMAS is not None)\n            schema_written_for_url_path_args = (\n                handler.URL_PATH_ARGS_SCHEMAS is not None)\n            handler_has_schemas = (schema_written_for_request_methods and\n                schema_written_for_url_path_args)\n\n            if handler_has_schemas is False:\n                list_of_handlers_which_need_schemas.append(handler_class_name)\n\n        error_msg = (\n            'The following handlers have missing schemas: [ %s ].'\n            '\\nVisit %s to learn how to write schemas for handler args.' % (\n                ', '.join(\n                    list_of_handlers_which_need_schemas), self.wiki_page_link))\n\n        self.assertEqual(list_of_handlers_which_need_schemas, [], error_msg)\n\n    def test_schema_keys_exactly_match_with_url_path_elements(self) -> None:\n        \"\"\"This test ensures that schema keys in URL_PATH_ARGS_SCHEMAS must\n        exactly match with url path elements.\n        \"\"\"\n        handlers_with_missing_url_schema_keys = []\n        list_of_routes_which_need_schemas = (\n            self._get_list_of_routes_which_need_schemas())\n\n        for route in list_of_routes_which_need_schemas:\n            handler = route.handler\n\n            handler_class_name = handler.__name__\n            if handler_class_name in self.handler_class_names_with_no_schema:\n                continue\n            if handler.URL_PATH_ARGS_SCHEMAS is None:\n                continue\n\n            regex_pattern = r'<.*?>'\n            url_path_arg_names = []\n            for url_path_element in re.findall(regex_pattern, route.name):\n                url_path_keyword = url_path_element[1: -1]\n                # In some cases, url_path_arguments are defined with specific\n                # acceptable values, e.g: /<asset_type:(image|audio|thumbnail)>.\n                # So, to separate out the argument name from acceptable values,\n                # we have used ':' delimiter's index so that we can strip the\n                # part after ':'.\n                url_argument_delimiter_index = url_path_keyword.find(':')\n                url_path_arg_name = (\n                    url_path_keyword[:url_argument_delimiter_index]\n                    if url_argument_delimiter_index != -1 else url_path_keyword\n                )\n                url_path_arg_names.append(url_path_arg_name)\n            schema_keys = handler.URL_PATH_ARGS_SCHEMAS.keys()\n\n            missing_schema_keys = set(url_path_arg_names) - set(schema_keys)\n            if missing_schema_keys:\n                handlers_with_missing_url_schema_keys.append(handler_class_name)\n                self.log_line(\n                    'Missing keys in URL_PATH_ARGS_SCHEMAS for %s: %s.' % (\n                        handler_class_name, ', '.join(missing_schema_keys)))\n\n        error_msg = (\n            'Missing schema keys in URL_PATH_ARGS_SCHEMAS for [ %s ] classes.'\n            '\\nVisit %s to learn how to write schemas for handler args.' % (\n                ', '.join(handlers_with_missing_url_schema_keys),\n                    self.wiki_page_link))\n\n        self.assertEqual(handlers_with_missing_url_schema_keys, [], error_msg)\n\n    def test_schema_keys_exactly_match_with_request_methods_in_handlers(\n        self\n    ) -> None:\n        \"\"\"This test ensures that schema keys in HANDLER_ARGS_SCHEMAS must\n        exactly match with request arguments.\n        \"\"\"\n        handlers_with_missing_request_schema_keys = []\n        list_of_routes_which_need_schemas = (\n            self._get_list_of_routes_which_need_schemas())\n\n        for route in list_of_routes_which_need_schemas:\n            handler = route.handler\n\n            handler_class_name = handler.__name__\n            if handler_class_name in self.handler_class_names_with_no_schema:\n                continue\n            if handler.HANDLER_ARGS_SCHEMAS is None:\n                continue\n\n            handler_request_methods = []\n            if handler.get != base.BaseHandler.get:\n                handler_request_methods.append('GET')\n            if handler.put != base.BaseHandler.put:\n                handler_request_methods.append('PUT')\n            if handler.post != base.BaseHandler.post:\n                handler_request_methods.append('POST')\n            if handler.delete != base.BaseHandler.delete:\n                handler_request_methods.append('DELETE')\n            methods_defined_in_schema = handler.HANDLER_ARGS_SCHEMAS.keys()\n\n            missing_schema_keys = (\n                set(handler_request_methods) - set(methods_defined_in_schema))\n            if missing_schema_keys:\n                handlers_with_missing_request_schema_keys.append(\n                    handler_class_name)\n                self.log_line(\n                    'Missing keys in HANDLER_ARGS_SCHEMAS for %s: %s.' % (\n                        handler_class_name, ', '.join(missing_schema_keys)))\n\n        error_msg = (\n            'Missing schema keys in HANDLER_ARGS_SCHEMAS for [ %s ] classes.'\n            '\\nVisit %s to learn how to write schemas for handler args.' % (\n                ', '.join(handlers_with_missing_request_schema_keys),\n                    self.wiki_page_link))\n\n        self.assertEqual(\n            handlers_with_missing_request_schema_keys, [], error_msg)\n\n    def test_default_value_in_schema_conforms_with_schema(self) -> None:\n        \"\"\"This test checks whether the default_value provided in schema\n        conforms with the rest of the schema.\n        \"\"\"\n        handlers_with_non_conforming_default_schemas = []\n        list_of_routes_which_need_schemas = (\n            self._get_list_of_routes_which_need_schemas())\n\n        for route in list_of_routes_which_need_schemas:\n            handler = route.handler\n\n            handler_class_name = handler.__name__\n            if handler_class_name in self.handler_class_names_with_no_schema:\n                continue\n            if handler.HANDLER_ARGS_SCHEMAS is None:\n                continue\n\n            schemas = handler.HANDLER_ARGS_SCHEMAS\n            for request_method, request_method_schema in schemas.items():\n                for arg, schema in request_method_schema.items():\n                    if 'default_value' not in schema:\n                        continue\n                    default_value = {arg: schema['default_value']}\n                    default_value_schema = {arg: schema}\n\n                    _, errors = (\n                        payload_validator.validate_arguments_against_schema(\n                            default_value,\n                            default_value_schema,\n                            allowed_extra_args=True,\n                            allow_string_to_bool_conversion=False)\n                    )\n                    if len(errors) == 0:\n                        continue\n                    self.log_line(\n                        'Handler: %s, argument: %s, default_value '\n                            'validation failed.' % (handler_class_name, arg))\n\n                    if (handler_class_name not in\n                            handlers_with_non_conforming_default_schemas):\n                        handlers_with_non_conforming_default_schemas.append(\n                            handler_class_name)\n\n        error_msg = (\n            'Schema validation for default values failed for handlers: [ %s ].'\n            '\\nVisit %s to learn how to write schemas for handler args.' % (\n                ', '.join(handlers_with_non_conforming_default_schemas),\n                        self.wiki_page_link))\n\n        self.assertEqual(\n            handlers_with_non_conforming_default_schemas, [], error_msg)\n\n    def test_handlers_with_schemas_are_not_in_handler_schema_todo_list(\n        self\n    ) -> None:\n        \"\"\"This test ensures that the\n        HANDLER_CLASS_NAMES_WHICH_STILL_NEED_SCHEMAS list in handler_schema_constants\n        only contains handler class names which require schemas.\n        \"\"\"\n\n        list_of_handlers_to_be_removed = []\n        handler_names_which_require_schemas = (\n        handler_schema_constants.HANDLER_CLASS_NAMES_WHICH_STILL_NEED_SCHEMAS)\n        list_of_routes_which_need_schemas = (\n            self._get_list_of_routes_which_need_schemas())\n\n        for route in list_of_routes_which_need_schemas:\n            handler = route.handler\n\n            handler_class_name = handler.__name__\n            if handler_class_name not in handler_names_which_require_schemas:\n                continue\n\n            schema_written_for_request_methods = (\n                handler.HANDLER_ARGS_SCHEMAS is not None)\n            schema_written_for_url_path_args = (\n                handler.URL_PATH_ARGS_SCHEMAS is not None)\n            handler_has_schemas = (schema_written_for_request_methods and\n                schema_written_for_url_path_args)\n\n            if handler_has_schemas:\n                list_of_handlers_to_be_removed.append(handler_class_name)\n\n        error_msg = (\n            'Handlers to be removed from schema requiring list in '\n            'handler_schema_constants file: [ %s ].' % (\n                ', '.join(list_of_handlers_to_be_removed)))\n\n        self.assertEqual(list_of_handlers_to_be_removed, [], error_msg)\n\n\nclass SchemaValidationUrlArgsTests(test_utils.GenericTestBase):\n    \"\"\"Tests to check schema validation architecture for url path elements.\"\"\"\n\n    exp_id = 'exp_id'\n\n    class MockHandlerWithInvalidSchema(\n        base.BaseHandler[Dict[str, str], Dict[str, str]]\n    ):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n        URL_PATH_ARGS_SCHEMAS = {\n            'exploration_id': {\n                'schema': {\n                    'type': 'int'\n                }\n            }\n        }\n        HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n        @acl_decorators.can_play_exploration\n        def get(self, exploration_id: str) -> None:\n            self.render_json({'exploration_id': exploration_id})\n\n    class MockHandlerWithValidSchema(\n        base.BaseHandler[Dict[str, str], Dict[str, str]]\n    ):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n        URL_PATH_ARGS_SCHEMAS = {\n            'exploration_id': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            }\n        }\n        HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n        @acl_decorators.can_play_exploration\n        def get(self, exploration_id: str) -> None:\n            self.render_json({'exploration_id': exploration_id})\n\n    class MockHandlerWithMissingUrlPathSchema(\n        base.BaseHandler[Dict[str, str], Dict[str, str]]\n    ):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n        HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n        @acl_decorators.can_play_exploration\n        def get(self, exploration_id: str) -> None:\n            self.render_json({'exploration_id': exploration_id})\n\n    def setUp(self) -> None:\n        super(SchemaValidationUrlArgsTests, self).setUp()\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.mock_testapp1 = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_play_exploration/<exploration_id>',\n                    self.MockHandlerWithInvalidSchema)], debug=feconf.DEBUG))\n\n        self.mock_testapp2 = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_play_exploration/<exploration_id>',\n                    self.MockHandlerWithValidSchema)], debug=feconf.DEBUG))\n\n        self.mock_testapp3 = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_play_exploration/<exploration_id>',\n                    self.MockHandlerWithMissingUrlPathSchema)],\n                debug=feconf.DEBUG))\n\n        self.save_new_valid_exploration(self.exp_id, self.owner_id)\n\n    def test_cannot_access_exploration_with_incorrect_schema(self) -> None:\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp1):\n            response = self.get_json(\n                '/mock_play_exploration/%s' % self.exp_id,\n                    expected_status_int=400)\n            error_msg = (\n                'At \\'http://localhost/mock_play_exploration/exp_id\\' '\n                'these errors are happening:\\n'\n                'Schema validation for \\'exploration_id\\' failed: Could not '\n                'convert str to int: %s' % self.exp_id)\n            self.assertEqual(response['error'], error_msg)\n        self.logout()\n\n    def test_can_access_exploration_with_correct_schema(self) -> None:\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp2):\n            response = self.get_json(\n                '/mock_play_exploration/%s' % self.exp_id,\n                    expected_status_int=200)\n        self.logout()\n\n    def test_cannot_access_exploration_with_missing_schema(self) -> None:\n        self.login(self.OWNER_EMAIL)\n        error_msg = (\n            'Missing schema for url path args in '\n            'MockHandlerWithMissingUrlPathSchema handler class.')\n\n        with self.swap(self, 'testapp', self.mock_testapp3):\n            response = self.get_json('/mock_play_exploration/%s' % self.exp_id,\n                expected_status_int=500)\n            self.assertEqual(response['error'], error_msg)\n        self.logout()\n\n\nclass MockHandlerWithInvalidSchemaNormalizedRequestDict(TypedDict):\n    \"\"\"Type for the MockHandlerWithInvalidSchema's normalized_request\n    dictionary.\n    \"\"\"\n\n    exploration_id: int\n\n\nclass MockHandlerWithDefaultGetSchemaNormalizedRequestDict(TypedDict):\n    \"\"\"Type for the MockHandlerWithDefaultGetSchema's normalized_request\n    dictionary.\n    \"\"\"\n\n    exploration_id: str\n    apply_draft: bool\n\n\nclass MockHandlerWithDefaultPutSchemaNormalizedPayloadDict(TypedDict):\n    \"\"\"Type for the MockHandlerWithDefaultPutSchema's normalized_payload\n    dictionary.\n    \"\"\"\n\n    exploration_id: str\n\n\nclass SchemaValidationRequestArgsTests(test_utils.GenericTestBase):\n    \"\"\"Tests to check schema validation architecture for request args.\"\"\"\n\n    exp_id: Final = 'exp_id'\n\n    class MockHandlerWithInvalidSchema(\n        base.BaseHandler[\n            Dict[str, str],\n            MockHandlerWithInvalidSchemaNormalizedRequestDict\n        ]\n    ):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS = {\n            'GET': {\n                'exploration_id': {\n                    'schema': {\n                        'type': 'int'\n                    }\n                }\n            }\n        }\n\n        @acl_decorators.can_play_exploration\n        def get(self) -> None:\n            assert self.normalized_request is not None\n            exploration_id = self.normalized_request['exploration_id']\n            self.render_json({'exploration_id': exploration_id})\n\n    class MockHandlerWithMissingRequestSchema(\n        base.BaseHandler[Dict[str, str], Dict[str, str]]\n    ):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS: Dict[str, str] = {}\n\n        @acl_decorators.can_play_exploration\n        def get(self) -> None:\n            assert self.normalized_request is not None\n            exploration_id = self.normalized_request.get('exploration_id')\n            self.render_json({'exploration_id': exploration_id})\n\n    class MockHandlerWithDefaultGetSchema(\n        base.BaseHandler[\n            Dict[str, str],\n            MockHandlerWithDefaultGetSchemaNormalizedRequestDict\n        ]\n    ):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS = {\n            'GET': {\n                'exploration_id': {\n                    'schema': {\n                        'type': 'basestring'\n                    },\n                    'default_value': 'random_exp_id'\n                },\n                'apply_draft': {\n                    'schema': {\n                        'type': 'bool'\n                    },\n                    'default_value': False\n                }\n            }\n        }\n\n        # Here we use MyPy ignore because the signature of 'get' method does not\n        # match with the signature of super class's (BaseHandler) 'get' method,\n        # and this happens because all handler methods in the main codebase have\n        # decorators which modify the function signature accordingly, but these\n        # methods in base_test.py do not.\n        def get(self) -> None:  # type: ignore[override]\n            assert self.normalized_request is not None\n            exploration_id = self.normalized_request['exploration_id']\n            if exploration_id != 'random_exp_id':\n                raise self.InvalidInputException(\n                    'Expected exploration_id to be random_exp_id received %s'\n                    % exploration_id)\n            return self.render_json({'exploration_id': exploration_id})\n\n    class MockHandlerWithDefaultPutSchema(\n        base.BaseHandler[\n            MockHandlerWithDefaultPutSchemaNormalizedPayloadDict,\n            Dict[str, str]\n        ]\n    ):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS = {\n            'PUT': {\n                'exploration_id': {\n                    'schema': {\n                        'type': 'basestring'\n                    },\n                    'default_value': 'random_exp_id'\n                }\n            }\n        }\n\n        # Here we use MyPy ignore because the signature of 'put' method does\n        # not match with the signature of super class's (BaseHandler) 'put'\n        # method, and this happens because all handler methods in the main\n        # codebase have decorators which modify the function signature\n        # accordingly, but these methods in base_test.py do not.\n        def put(self) -> None:  # type: ignore[override]\n            assert self.normalized_payload is not None\n            exploration_id = self.normalized_payload['exploration_id']\n            if exploration_id != 'random_exp_id':\n                raise self.InvalidInputException(\n                    'Expected exploration_id to be random_exp_id received %s'\n                    % exploration_id)\n            self.render_json({'exploration_id': exploration_id})\n\n    def setUp(self) -> None:\n        super(SchemaValidationRequestArgsTests, self).setUp()\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.mock_testapp1 = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_play_exploration',\n                    self.MockHandlerWithInvalidSchema)], debug=feconf.DEBUG))\n\n        self.mock_testapp2 = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_play_exploration',\n                    self.MockHandlerWithMissingRequestSchema)],\n                debug=feconf.DEBUG))\n\n        self.mock_testapp3 = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_play_exploration',\n                    self.MockHandlerWithDefaultGetSchema)], debug=feconf.DEBUG))\n\n        self.mock_testapp4 = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_play_exploration',\n                    self.MockHandlerWithDefaultPutSchema)], debug=feconf.DEBUG))\n\n        self.save_new_valid_exploration(self.exp_id, self.owner_id)\n\n    def test_cannot_access_exploration_with_incorrect_schema(self) -> None:\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp1):\n            response = self.get_json(\n                '/mock_play_exploration?exploration_id=%s' % self.exp_id,\n                    expected_status_int=400)\n            error_msg = (\n                'Schema validation for \\'exploration_id\\' failed: Could not '\n                'convert str to int: %s' % self.exp_id)\n            self.assertEqual(response['error'], error_msg)\n        self.logout()\n\n    def test_cannot_access_exploration_with_missing_schema(self) -> None:\n        self.login(self.OWNER_EMAIL)\n        error_msg = (\n            'Missing schema for GET method in '\n            'MockHandlerWithMissingRequestSchema handler class.')\n\n        with self.swap(self, 'testapp', self.mock_testapp2):\n            response = self.get_json(\n                '/mock_play_exploration?exploration_id=%s' % self.exp_id,\n                    expected_status_int=500)\n            self.assertEqual(response['error'], error_msg)\n        self.logout()\n\n    def test_can_access_exploration_with_default_value_in_schema(self) -> None:\n        self.login(self.OWNER_EMAIL)\n\n        with self.swap(self, 'testapp', self.mock_testapp3):\n            self.get_json('/mock_play_exploration?apply_draft=true')\n\n        csrf_token = self.get_new_csrf_token()\n        with self.swap(self, 'testapp', self.mock_testapp4):\n            self.put_json('/mock_play_exploration', {}, csrf_token=csrf_token)\n        self.logout()\n\n\nclass HandlerClassWithSchemaInStillNeedsSchemaListRaiseErrorTest(\n        test_utils.GenericTestBase):\n    \"\"\"This test ensures that, InternalServerError is raised for\n    the request with handler class which has schema but class name is still in\n    HANDLER_CLASS_NAMES_WHICH_STILL_NEED_SCHEMAS.\n    \"\"\"\n\n    class MockHandler(base.BaseHandler[Dict[str, str], Dict[str, str]]):\n        \"\"\"Mock handler with schema.\"\"\"\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS = {\n            'POST': {\n                'arg_a': {\n                    'schema': {\n                        'type': 'basestring'\n                    }\n                }\n            }\n        }\n\n        # Here we use MyPy ignore because the signature of 'post' method does\n        # not match with the signature of super class's (BaseHandler) 'post'\n        # method, and this happens because all handler methods in the main\n        # codebase have decorators which modify the function signature\n        # accordingly, but these methods in base_test.py do not.\n        def post(self) -> None:  # type: ignore[override]\n            self.render_json({})\n\n    def setUp(self) -> None:\n        super().setUp()\n        user_id = user_services.get_user_id_from_username('learneruser')\n        self.csrf_token = base.CsrfTokenManager.create_csrf_token(user_id)\n        self.payload = {'arg_a': 'val'}\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock', self.MockHandler, name='MockHandler')],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_post_request_raise_internal_server_error(self) -> None:\n        test_app_ctx = self.swap(self, 'testapp', self.testapp)\n        handler_class_still_needs_schema_list_ctx = self.swap(\n            handler_schema_constants, 'HANDLER_CLASS_NAMES_WITH_NO_SCHEMA',\n            ['MockHandler'])\n        with test_app_ctx, handler_class_still_needs_schema_list_ctx:\n            self.post_json(\n                '/mock', self.payload, csrf_token=self.csrf_token,\n                expected_status_int=500)\n\n\nclass HeaderRequestsTests(test_utils.GenericTestBase):\n    \"\"\"Tests to check header requests.\"\"\"\n\n    class MockHandler(base.BaseHandler[Dict[str, str], Dict[str, str]]):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n        URL_PATH_ARGS_SCHEMAS = {\n            'entity_id': {\n                'schema': {\n                    'type': 'int'\n                }\n            }\n        }\n        HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n        # Here we use MyPy ignore because the signature of 'get' method does not\n        # match with the signature of super class's (BaseHandler) 'get' method,\n        # and this happens because all handler methods in the main codebase have\n        # decorators which modify the function signature accordingly, but these\n        # methods in base_test.py do not.\n        def get(self, entity_id: str) -> None:  # type: ignore[override]\n            self.render_json({'entity_id': entity_id})\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication([\n            webapp2.Route(\n                '/mock/<entity_id>', self.MockHandler, name='MockHandler')],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_head_request_with_invalid_url_args_raises(self) -> None:\n        with self.swap(self, 'testapp', self.testapp):\n            self.testapp.head('/mock/not_int', status=400)\n\n    def test_valid_head_request_returns_only_headers(self) -> None:\n        with self.swap(self, 'testapp', self.testapp):\n            response = self.testapp.head('/mock/234', status=200)\n            self.assertEqual(response.body, b'')\n            self.assertIsNotNone(response.headers)\n\n\nclass RequestMethodNotInHandlerClassDoNotRaiseMissingSchemaErrorTest(\n        test_utils.GenericTestBase):\n    \"\"\"This test ensures that, NotImplementedError should not be raised for\n    the request method which are not present in the handler class.\n    \"\"\"\n\n    class MockHandler(base.BaseHandler[Dict[str, str], Dict[str, str]]):\n        \"\"\"Mock handler with no get method.\n        \"\"\"\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS: Dict[str, str] = {}\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n    def setUp(self) -> None:\n        super(RequestMethodNotInHandlerClassDoNotRaiseMissingSchemaErrorTest,\n            self).setUp()\n\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock', self.MockHandler, name='MockHandler')],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_get_request_do_not_raise_notimplemented_error(self) -> None:\n        with self.swap(self, 'testapp', self.testapp):\n            self.get_json('/mock', expected_status_int=404)\n\n\nclass MockHandlerNormalizedRequestDict(TypedDict):\n    \"\"\"Type for the MockHandler's normalized_payload\n    dictionary.\n    \"\"\"\n\n    arg_b: str\n    arg_a: str\n\n\nclass HandlerClassWithBothRequestAndPayloadTest(test_utils.GenericTestBase):\n    \"\"\"This test class ensures that SVS architecture validates both request args\n    and payload args if they are present in a single request method.\"\"\"\n\n    class MockHandler(\n        base.BaseHandler[\n            MockHandlerNormalizedRequestDict, Dict[str, str]\n        ]\n    ):\n        \"\"\"Fake page for testing autoescaping.\"\"\"\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS = {\n            'POST': {\n                'arg_b': {\n                    'schema': {\n                        'type': 'basestring'\n                    }\n                },\n                'arg_a': {\n                    'schema': {\n                        'type': 'basestring'\n                    }\n                }\n            }\n        }\n\n        # Here we use MyPy ignore because the signature of 'post' method does\n        # not match with the signature of super class's (BaseHandler) 'post'\n        # method, and this happens because all handler methods in the main\n        # codebase have decorators which modify the function signature\n        # accordingly, but these methods in base_test.py do not.\n        def post(self) -> None:  # type: ignore[override]\n            \"\"\"Handles POST requests. This request method contains both type\n            of args, i.e., request args as well as payload args.\n            \"\"\"\n            assert self.normalized_request is not None\n            # arg_a = self.request.get('arg_a') is not used, since we\n            # intend to use normalized value.\n            arg_a = self.normalized_request.get('arg_a')\n\n            # arg_b = self.payload.get('arg_b') is not used, since we\n            # intend to use normalized value.\n            arg_b = self.normalized_request.get('arg_b')\n\n            self.render_json({'arg_a': arg_a, 'arg_b': arg_b})\n\n    def setUp(self) -> None:\n        super(HandlerClassWithBothRequestAndPayloadTest, self).setUp()\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock', self.MockHandler, name='MockHandler')],\n            debug=feconf.DEBUG,\n        ))\n        self.payload = {'arg_b': 'arg_in_payload'}\n        user_id = user_services.get_user_id_from_username('learneruser')\n        self.csrf_token = base.CsrfTokenManager.create_csrf_token(user_id)\n\n    def test_both_args_in_post_request(self) -> None:\n        with self.swap(self, 'testapp', self.testapp):\n            self.post_json(\n                '/mock?arg_a=arg_in_request', self.payload,\n                csrf_token=self.csrf_token)\n\n    def test_post_request_with_invalid_source_raise_error(self) -> None:\n        with self.swap(self, 'testapp', self.testapp):\n            self.post_json(\n                '/mock?arg_a=arg_in_request', self.payload,\n                csrf_token=self.csrf_token, source='fake_url',\n                expected_status_int=400)\n\n    def test_post_request_with_valid_source_do_not_raise_error(self) -> None:\n        with self.swap(self, 'testapp', self.testapp):\n            self.post_json(\n                '/mock?arg_a=arg_in_request', self.payload,\n                csrf_token=self.csrf_token,\n                source='http://localhost:8181/sample_url/')\n\n\nclass MockUploadHandlerNormalizedPayloadDict(TypedDict):\n    \"\"\"Type for the MockUploadHandler's normalized_payload\n    dictionary.\n    \"\"\"\n\n    filename: str\n    filename_prefix: Optional[str]\n\n\nclass MockUploadHandlerNormalizedRequestDict(TypedDict):\n    \"\"\"Type for the MockUploadHandler's normalized_request\n    dictionary.\n    \"\"\"\n\n    image: bytes\n\n\nclass ImageUploadHandlerTest(test_utils.GenericTestBase):\n    \"\"\"This test class ensures that schema validation is done successfully\n    for handlers which upload image files.\n    \"\"\"\n\n    TEST_LEARNER_EMAIL: Final = 'test.learner@example.com'\n    TEST_LEARNER_USERNAME: Final = 'testlearneruser'\n\n    class MockUploadHandler(\n        base.BaseHandler[\n            MockUploadHandlerNormalizedPayloadDict,\n            MockUploadHandlerNormalizedRequestDict\n        ]\n    ):\n        \"\"\"Handles image uploads.\"\"\"\n        URL_PATH_ARGS_SCHEMAS = {\n            'entity_type': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            },\n            'entity_id': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            }\n        }\n        HANDLER_ARGS_SCHEMAS = {\n            'POST': {\n                'image': {\n                    'schema': {\n                        'type': 'basestring'\n                    }\n                },\n                'filename': {\n                    'schema': {\n                        'type': 'basestring'\n                    }\n                },\n                'filename_prefix': {\n                    'schema': {\n                        'type': 'basestring'\n                    },\n                    'default_value': None\n                }\n            }\n        }\n\n        # Here we use MyPy ignore because the signature of 'post' method does\n        # not match with the signature of super class's (BaseHandler) 'post'\n        # method, and this happens because all handler methods in the main\n        # codebase have decorators which modify the function signature\n        # accordingly, but these methods in base_test.py do not.\n        def post(self, entity_type: str, entity_id: str) -> None:  # type: ignore[override]\n            \"\"\"Saves an image uploaded by a content creator.\"\"\"\n            assert self.normalized_payload is not None\n            assert self.normalized_request is not None\n            raw = self.normalized_request.get('image')\n            filename = self.normalized_payload.get('filename')\n            filename_prefix = self.normalized_payload.get('filename_prefix')\n\n            self.render_json({'filename': filename})\n\n    def setUp(self) -> None:\n        super(ImageUploadHandlerTest, self).setUp()\n        self.signup(self.TEST_LEARNER_EMAIL, self.TEST_LEARNER_USERNAME)\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock_upload/<entity_type>/<entity_id>',\n            self.MockUploadHandler, name='MockUploadHandler')],\n            debug=feconf.DEBUG,\n        ))\n\n        self.system_user = user_services.get_system_user()\n        exp_services.load_demo('0')\n\n        rights_manager.release_ownership_of_exploration(\n            self.system_user, '0')\n\n    def test_image_upload_and_download(self) -> None:\n        \"\"\"Test image uploading and downloading.\"\"\"\n        self.login(self.TEST_LEARNER_EMAIL)\n        user_id = user_services.get_user_id_from_username('testlearneruser')\n        csrf_token = base.CsrfTokenManager.create_csrf_token(user_id)\n\n        with utils.open_file(\n            os.path.join(feconf.TESTS_DATA_DIR, 'img.png'),\n            'rb', encoding=None\n        ) as f:\n            raw_image = f.read()\n        with self.swap(self, 'testapp', self.testapp):\n            response_dict = self.post_json(\n                '/mock_upload/exploration/0', {'filename': 'test.png'},\n                csrf_token=csrf_token,\n                upload_files=[('image', 'unused_filename', raw_image)]\n            )\n            filename = response_dict['filename']\n        self.logout()\n\n\nclass UrlPathNormalizationTest(test_utils.GenericTestBase):\n    \"\"\"Tests that ensure url path arguments are normalized\"\"\"\n\n    class MockHandler(base.BaseHandler[Dict[str, str], Dict[str, str]]):\n        URL_PATH_ARGS_SCHEMAS = {\n            'mock_list': {\n                'schema': {\n                    'type': 'custom',\n                    'obj_type': 'JsonEncodedInString'\n                }\n            },\n            'mock_int': {\n                'schema': {\n                    'type': 'int'\n                }\n            }\n        }\n        HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {\n            'GET': {}\n        }\n\n        # Here we use MyPy ignore because the signature of 'get' method does not\n        # match with the signature of super class's (BaseHandler) 'get' method,\n        # and this happens because all handler methods in the main codebase have\n        # decorators which modify the function signature accordingly, but these\n        # methods in base_test.py do not.\n        def get(self, mock_list: List[str], mock_int: int) -> None:  # type: ignore[override]\n            if not isinstance(mock_list, list):\n                raise self.InvalidInputException(\n                    'Expected arg mock_list to be a list. Was type %s' %\n                    type(mock_list))\n            if not isinstance(mock_int, int):\n                raise self.InvalidInputException(\n                    'Expected arg mock_int to be a int. Was type %s' %\n                    type(mock_int))\n            self.render_json({'mock_list': mock_list, 'mock_int': mock_int})\n\n    def setUp(self) -> None:\n        super(UrlPathNormalizationTest, self).setUp()\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock_normalization/<mock_int>/<mock_list>',\n            self.MockHandler, name='MockHandler')],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_url_path_arg_normalization_is_successful(self) -> None:\n        list_string = '[\"id1\", \"id2\", \"id3\"]'\n        int_string = '1'\n\n        with self.swap(self, 'testapp', self.testapp):\n            self.get_json(\n                '/mock_normalization/%s/%s' % (int_string, list_string),\n                expected_status_int=200)\n\n\nclass RaiseErrorOnGetTest(test_utils.GenericTestBase):\n    \"\"\"This test class is to ensure handlers with schema raises error\n    when they use self.request or self.payload.\"\"\"\n\n    class MockHandlerWithSchema(\n        base.BaseHandler[Dict[str, str], Dict[str, str]]\n    ):\n        \"\"\"Mock handler with schema.\"\"\"\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS = {\n            'POST': {\n                'mock_int': {\n                    'schema': {\n                        'type': 'int'\n                    }\n                }\n            }\n        }\n\n        # Here we use MyPy ignore because the signature of 'post' method does\n        # not match with the signature of super class's (BaseHandler) 'post'\n        # method, and this happens because all handler methods in the main\n        # codebase have decorators which modify the function signature\n        # accordingly, but these methods in base_test.py do not.\n        def post(self) -> None:  # type: ignore[override]\n            self.payload.get('mock_int')\n            return self.render_json({})\n\n    class MockHandlerWithoutSchema(\n        base.BaseHandler[Dict[str, str], Dict[str, str]]\n    ):\n        \"\"\"Mock handler without schema.\"\"\"\n\n        # Here we use MyPy ignore because the signature of 'post' method does\n        # not match with the signature of super class's (BaseHandler) 'post'\n        # method, and this happens because all handler methods in the main\n        # codebase have decorators which modify the function signature\n        # accordingly, but these methods in base_test.py do not.\n        def post(self) -> None:  # type: ignore[override]\n            self.payload.get('mock_int')\n            return self.render_json({})\n\n    def setUp(self) -> None:\n        super().setUp()\n        user_id = user_services.get_user_id_from_username('learneruser')\n        self.csrf_token = base.CsrfTokenManager.create_csrf_token(user_id)\n        self.payload = {'mock_int': 1}\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication([\n            webapp2.Route('/mock_with_schema', self.MockHandlerWithSchema),\n            webapp2.Route(\n                '/mock_without_schema', self.MockHandlerWithoutSchema),\n        ], debug=feconf.DEBUG))\n\n    def test_object_which_raises_error_on_get(self) -> None:\n        error_message = 'error_message'\n        object_that_raises_error_on_get = base.RaiseErrorOnGet(error_message)\n        with self.assertRaisesRegex(ValueError, error_message):\n            object_that_raises_error_on_get.get('key')\n\n    def test_request_with_schema_using_payload_or_request_attr_raise_error(\n        self\n    ) -> None:\n        with self.swap(self, 'testapp', self.testapp):\n            self.post_json(\n                '/mock_with_schema', self.payload, csrf_token=self.csrf_token,\n                expected_status_int=500)\n\n    def test_request_without_schema_using_payload_or_request_attr_raise_no_err(\n        self\n    ) -> None:\n        test_app_ctx = self.swap(self, 'testapp', self.testapp)\n        handler_class_still_needs_schema_list_ctx = self.swap(\n            handler_schema_constants, 'HANDLER_CLASS_NAMES_WITH_NO_SCHEMA',\n            ['MockHandlerWithoutSchema'])\n        with test_app_ctx, handler_class_still_needs_schema_list_ctx:\n            self.post_json(\n                '/mock_without_schema', self.payload, csrf_token=self.csrf_token,\n                expected_status_int=200)\n"], "fixing_code": ["# Copyright 2014 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Base constants and handlers.\"\"\"\n\nfrom __future__ import annotations\n\nimport abc\nimport base64\nimport datetime\nimport functools\nimport hmac\nimport io\nimport json\nimport logging\nimport os\nimport re\nimport time\nimport urllib\n\nfrom core import feconf\nfrom core import handler_schema_constants\nfrom core import utils\nfrom core.controllers import payload_validator\nfrom core.domain import auth_domain\nfrom core.domain import auth_services\nfrom core.domain import classifier_domain\nfrom core.domain import config_domain\nfrom core.domain import config_services\nfrom core.domain import user_services\n\nfrom typing import (\n    Any, Dict, Final, Generic, Mapping, Optional, Sequence, TypedDict, TypeVar,\n    Union\n)\n\nimport webapp2\n\n# Note: These private type variables are only defined to implement the Generic\n# typing structure of BaseHandler. So, do not make them public in the future.\n_NormalizedRequestDictType = TypeVar('_NormalizedRequestDictType')\n_NormalizedPayloadDictType = TypeVar('_NormalizedPayloadDictType')\n\nONE_DAY_AGO_IN_SECS: Final = -24 * 60 * 60\nDEFAULT_CSRF_SECRET: Final = 'oppia csrf secret'\nCSRF_SECRET: Final = config_domain.ConfigProperty(\n    'oppia_csrf_secret', {'type': 'unicode'},\n    'Text used to encrypt CSRF tokens.', DEFAULT_CSRF_SECRET)\n\n# NOTE: These handlers manage user sessions and serve auth pages. Thus, we\n# should never reject or replace them when running in maintenance mode;\n# otherwise admins will be unable to access the site.\nAUTH_HANDLER_PATHS: Final = (\n    '/csrfhandler',\n    '/login',\n    '/session_begin',\n    '/session_end',\n)\n\n\nclass ResponseValueDict(TypedDict):\n    \"\"\"Dict representation of key-value pairs that will be included in the\n    response.\n    \"\"\"\n\n    error: str\n    status_code: int\n\n\n@functools.lru_cache(maxsize=128)\ndef load_template(\n    filename: str, *, template_is_aot_compiled: bool\n) -> str:\n    \"\"\"Return the HTML file contents at filepath.\n\n    Args:\n        filename: str. Name of the requested HTML file.\n        template_is_aot_compiled: bool. Used to determine which bundle to use.\n\n    Returns:\n        str. The HTML file content.\n    \"\"\"\n    filepath = os.path.join(\n        (\n            feconf.FRONTEND_AOT_DIR\n            if template_is_aot_compiled\n            else feconf.FRONTEND_TEMPLATES_DIR\n        ),\n        filename\n    )\n    with utils.open_file(filepath, 'r') as f:\n        html_text = f.read()\n    return html_text\n\n\nclass SessionBeginHandler(webapp2.RequestHandler):\n    \"\"\"Handler for creating new authentication sessions.\"\"\"\n\n    def get(self) -> None:\n        \"\"\"Establishes a new auth session.\"\"\"\n        auth_services.establish_auth_session(self.request, self.response)\n\n\nclass SessionEndHandler(webapp2.RequestHandler):\n    \"\"\"Handler for destroying existing authentication sessions.\"\"\"\n\n    def get(self) -> None:\n        \"\"\"Destroys an existing auth session.\"\"\"\n        auth_services.destroy_auth_session(self.response)\n\n\nclass UserFacingExceptions:\n    \"\"\"This class contains all the exception class definitions used.\"\"\"\n\n    class NotLoggedInException(Exception):\n        \"\"\"Error class for users that are not logged in (error code 401).\"\"\"\n\n        pass\n\n    class InvalidInputException(Exception):\n        \"\"\"Error class for invalid input on the user side (error code 400).\"\"\"\n\n        pass\n\n    class UnauthorizedUserException(Exception):\n        \"\"\"Error class for unauthorized access.\"\"\"\n\n        pass\n\n    class PageNotFoundException(Exception):\n        \"\"\"Error class for a page not found error (error code 404).\"\"\"\n\n        pass\n\n    class InternalErrorException(Exception):\n        \"\"\"Error class for an internal server side error (error code 500).\"\"\"\n\n        pass\n\n\nclass BaseHandler(\n    webapp2.RequestHandler,\n    Generic[_NormalizedPayloadDictType, _NormalizedRequestDictType]\n):\n    \"\"\"Base class for all Oppia handlers.\"\"\"\n\n    # Whether to check POST and PUT payloads for CSRF tokens prior to\n    # processing them. Can be overridden by subclasses if this check is\n    # not necessary.\n    REQUIRE_PAYLOAD_CSRF_CHECK = True\n    # Whether to redirect requests corresponding to a logged-in user who has\n    # not completed signup in to the signup page. This ensures that logged-in\n    # users have agreed to the latest terms.\n    REDIRECT_UNFINISHED_SIGNUPS = True\n\n    # What format the get method returns when exception raised, json or html.\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_HTML\n    POST_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    PUT_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    DELETE_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n    # Here we use type Any because the sub-classes of BaseHandler can contain\n    # different schemas with different types of values, like str, complex Dicts\n    # and etc.\n    URL_PATH_ARGS_SCHEMAS: Optional[Dict[str, Any]] = None\n    # Here we use type Any because the sub-classes of BaseHandler can contain\n    # different schemas with different types of values, like str, complex Dicts\n    # and etc.\n    HANDLER_ARGS_SCHEMAS: Optional[Dict[str, Any]] = None\n\n    def __init__(  # pylint: disable=super-init-not-called\n        self, request: webapp2.Request, response: webapp2.Response\n    ) -> None:\n        # Set self.request, self.response and self.app.\n        self.initialize(request, response)\n\n        self.start_time = datetime.datetime.utcnow()\n\n        # Here we use type Any because dict 'self.values' is a return dict\n        # for the handlers, and different handlers can return different\n        # key-value pairs. So, to allow every type of key-value pair, we\n        # used Any type here.\n        self.values: Dict[str, Any] = {}\n\n        # This try-catch block is intended to log cases where getting the\n        # request payload errors with ValueError: Invalid boundary in multipart\n        # form: b''. This is done to gather sufficient data to help debug the\n        # error if it arises in the future.\n        try:\n            payload_json_string = self.request.get('payload')\n        except ValueError as e:\n            logging.error('%s: request %s', e, self.request)\n            raise e\n        # TODO(#13155): Remove the if-else part once all the handlers have had\n        # schema validation implemented.\n        if payload_json_string:\n            self.payload = json.loads(payload_json_string)\n        else:\n            self.payload = None\n        self.iframed = False\n\n        self.user_id = None\n        self.username = None\n        self.email = None\n        self.partially_logged_in = False\n        self.user_is_scheduled_for_deletion = False\n        self.current_user_is_super_admin = False\n        self.normalized_request: Optional[_NormalizedRequestDictType] = None\n        self.normalized_payload: Optional[_NormalizedPayloadDictType] = None\n\n        try:\n            auth_claims = auth_services.get_auth_claims_from_request(request)\n        except auth_domain.StaleAuthSessionError:\n            auth_services.destroy_auth_session(self.response)\n            self.redirect(user_services.create_login_url(self.request.uri))\n            return\n        except auth_domain.UserDisabledError:\n            auth_services.destroy_auth_session(self.response)\n            self.redirect(\n                '/logout?redirect_url=%s' % feconf.PENDING_ACCOUNT_DELETION_URL)\n            return\n        except auth_domain.InvalidAuthSessionError:\n            logging.exception('User session is invalid!')\n            auth_services.destroy_auth_session(self.response)\n            self.redirect(user_services.create_login_url(self.request.uri))\n            return\n        else:\n            self.current_user_is_super_admin = (\n                auth_claims is not None and auth_claims.role_is_super_admin)\n\n        if auth_claims:\n            auth_id = auth_claims.auth_id\n            user_settings = user_services.get_user_settings_by_auth_id(auth_id)\n            if user_settings is None:\n                # If the user settings are not yet created and the request leads\n                # to signup page create a new user settings. Otherwise logout\n                # the not-fully registered user.\n                email = auth_claims.email\n                if email is None:\n                    logging.exception(\n                        'No email address was found for the user.'\n                    )\n                    auth_services.destroy_auth_session(self.response)\n                    return\n                if 'signup?' in self.request.uri:\n                    user_settings = (\n                        user_services.create_new_user(auth_id, email))\n                else:\n                    logging.error(\n                        'Cannot find user %s with email %s on page %s' % (\n                            auth_id, email, self.request.uri))\n                    auth_services.destroy_auth_session(self.response)\n                    return\n\n            self.email = user_settings.email\n            self.values['user_email'] = user_settings.email\n            self.user_id = user_settings.user_id\n\n            if user_settings.deleted:\n                self.user_is_scheduled_for_deletion = user_settings.deleted\n            elif (self.REDIRECT_UNFINISHED_SIGNUPS and\n                  not user_services.has_fully_registered_account(self.user_id)):\n                self.partially_logged_in = True\n            else:\n                self.username = user_settings.username\n                self.values['username'] = self.username\n                # In order to avoid too many datastore writes, we do not bother\n                # recording a log-in if the current time is sufficiently close\n                # to the last log-in time.\n                if (user_settings.last_logged_in is None or\n                        not utils.are_datetimes_close(\n                            datetime.datetime.utcnow(),\n                            user_settings.last_logged_in)):\n                    user_services.record_user_logged_in(self.user_id)\n\n            self.roles = user_settings.roles\n\n        if self.user_id is None:\n            self.roles = [feconf.ROLE_ID_GUEST]\n\n        self.user = user_services.get_user_actions_info(self.user_id)\n\n        if not self._is_requested_path_currently_accessible_to_user():\n            auth_services.destroy_auth_session(self.response)\n            return\n\n        self.values['is_super_admin'] = self.current_user_is_super_admin\n\n    def dispatch(self) -> None:\n        \"\"\"Overrides dispatch method in webapp2 superclass.\n\n        Raises:\n            Exception. The CSRF token is missing.\n            UnauthorizedUserException. The CSRF token is invalid.\n        \"\"\"\n        request_split = urllib.parse.urlsplit(self.request.uri)\n        # If the request is to the old demo server, redirect it permanently to\n        # the new demo server. (Unless it is a cron job or tasks request,\n        # because cron job and tasks destination URLs are generated by\n        # App Engine and we can't change their destination.)\n        if (\n                request_split.netloc == 'oppiaserver.appspot.com' and\n                not request_split.path.startswith(('/cron/', '/task/'))\n        ):\n            self.redirect('https://oppiatestserver.appspot.com', permanent=True)\n            return\n\n        if not self._is_requested_path_currently_accessible_to_user():\n            self.render_template('maintenance-page.mainpage.html')\n            return\n\n        if self.user_is_scheduled_for_deletion:\n            self.redirect(\n                '/logout?redirect_url=%s' % feconf.PENDING_ACCOUNT_DELETION_URL)\n            return\n\n        if self.partially_logged_in and request_split.path != '/logout':\n            self.redirect('/logout?redirect_url=%s' % request_split.path)\n            return\n\n        if self.payload is not None and self.REQUIRE_PAYLOAD_CSRF_CHECK:\n            try:\n                # If user opens a new tab during signup process, the user_id\n                # parameter is set to None and this causes the signup session\n                # to expire. The code here checks if user is on the signup\n                # page and the user_id is None, if that is the case an exception\n                # is raised which is handled by the frontend by showing a\n                # continue to registration modal.\n                if 'signup' in self.request.uri and not self.user_id:\n                    raise self.UnauthorizedUserException(\n                        'Registration session expired.')\n                csrf_token = self.request.get('csrf_token')\n                if not csrf_token:\n                    raise self.UnauthorizedUserException(\n                        'Missing CSRF token. Changes were not saved. '\n                        'Please report this bug.')\n\n                is_csrf_token_valid = CsrfTokenManager.is_csrf_token_valid(\n                    self.user_id, csrf_token)\n\n                if not is_csrf_token_valid:\n                    raise self.UnauthorizedUserException(\n                        'Your session has expired, and unfortunately your '\n                        'changes cannot be saved. Please refresh the page.')\n            except Exception as e:\n                logging.exception('%s: payload %s', e, self.payload)\n\n                self.handle_exception(e, self.app.debug)\n                return\n\n        schema_validation_succeeded = True\n        try:\n            self.validate_and_normalize_args()\n\n        # TODO(#13155): Remove NotImplementedError once all the handlers\n        # have had schema validation implemented.\n        except (\n            NotImplementedError,\n            self.InternalErrorException,\n            self.InvalidInputException\n        ) as e:\n            self.handle_exception(e, self.app.debug)\n            schema_validation_succeeded = False\n        if not schema_validation_succeeded:\n            return\n\n        super().dispatch()\n\n    def validate_and_normalize_args(self) -> None:\n        \"\"\"Validates schema for controller layer handler class arguments.\n\n        Raises:\n            InvalidInputException. Schema validation failed.\n            NotImplementedError. Schema is not provided in handler class.\n        \"\"\"\n        handler_class_name = self.__class__.__name__\n        request_method = self.request.environ['REQUEST_METHOD']\n\n        # For HEAD requests, we use the schema of GET handler,\n        # because HEAD returns just the handlers of the GET request.\n        if request_method == 'HEAD':\n            request_method = 'GET'\n\n        url_path_args = self.request.route_kwargs\n\n        if (\n            handler_class_name in\n            handler_schema_constants.HANDLER_CLASS_NAMES_WITH_NO_SCHEMA\n        ):\n            # TODO(#13155): Remove this clause once all the handlers have had\n            # schema validation implemented.\n            if self.URL_PATH_ARGS_SCHEMAS or self.HANDLER_ARGS_SCHEMAS:\n                raise self.InternalErrorException(\n                    'Remove handler class name from '\n                    'HANDLER_CLASS_NAMES_WHICH_STILL_NEED_SCHEMAS')\n            return\n\n        handler_args = {}\n        payload_arg_keys = []\n        request_arg_keys = []\n        for arg in self.request.arguments():\n            if arg == 'csrf_token':\n                # 'csrf_token' has been already validated in the\n                # dispatch method.\n                pass\n            elif arg == 'source':\n                source_url = self.request.get('source')\n                regex_pattern = (\n                    r'http[s]?://(?:[a-zA-Z]|[0-9]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+' # pylint: disable=line-too-long\n                )\n                regex_verified_url = re.findall(regex_pattern, source_url)\n                if not regex_verified_url:\n                    raise self.InvalidInputException(\n                        'Not a valid source url.')\n            elif arg == 'payload':\n                payload_args = self.payload\n                if payload_args is not None:\n                    payload_arg_keys = list(payload_args.keys())\n                    handler_args.update(payload_args)\n            else:\n                request_arg_keys.append(arg)\n                handler_args[arg] = self.request.get(arg)\n\n        # For html handlers, extra args are allowed (to accommodate\n        # e.g. utm parameters which are not used by the backend but\n        # needed for analytics).\n        extra_args_are_allowed = (\n            self.GET_HANDLER_ERROR_RETURN_TYPE == feconf.HANDLER_TYPE_HTML and\n            request_method == 'GET')\n\n        if self.URL_PATH_ARGS_SCHEMAS is None:\n            raise NotImplementedError(\n                'Missing schema for url path args in %s handler class.' % (\n                    handler_class_name))\n\n        schema_for_url_path_args = self.URL_PATH_ARGS_SCHEMAS\n        self.request.route_kwargs, errors = (\n            payload_validator.validate_arguments_against_schema(\n                url_path_args, schema_for_url_path_args, extra_args_are_allowed)\n        )\n\n        if errors:\n            raise self.InvalidInputException(\n                'At \\'%s\\' these errors are happening:\\n%s' % (\n                    self.request.uri, '\\n'.join(errors)\n                )\n            )\n\n        # This check ensures that if a request method is not defined\n        # in the handler class then schema validation will not raise\n        # NotImplementedError for that corresponding request method.\n        if request_method in ['GET', 'POST', 'PUT', 'DELETE'] and (\n                getattr(self.__class__, request_method.lower()) ==\n                getattr(BaseHandler, request_method.lower())):\n            return\n\n        try:\n            if self.HANDLER_ARGS_SCHEMAS is None:\n                raise Exception(\n                    'No \\'HANDLER_ARGS_SCHEMAS\\' Found for the '\n                    'handler class: %s' % handler_class_name\n                )\n            schema_for_request_method = self.HANDLER_ARGS_SCHEMAS[\n                request_method]\n        except Exception as e:\n            raise NotImplementedError(\n                'Missing schema for %s method in %s handler class.' % (\n                    request_method, handler_class_name)) from e\n\n        allow_string_to_bool_conversion = request_method in ['GET', 'DELETE']\n        normalized_arg_values, errors = (\n            payload_validator.validate_arguments_against_schema(\n                handler_args, schema_for_request_method, extra_args_are_allowed,\n                allow_string_to_bool_conversion)\n        )\n\n        normalized_payload = {\n            arg: normalized_arg_values.get(arg) for arg in payload_arg_keys\n        }\n        normalized_request = {\n            arg: normalized_arg_values.get(arg) for arg in request_arg_keys\n        }\n\n        # The following keys are absent in request/payload but present in\n        # normalized_arg_values because these args are populated from their\n        # default_value provided in the schema.\n        keys_that_correspond_to_default_values = list(\n            set(normalized_arg_values.keys()) -\n            set(payload_arg_keys + request_arg_keys)\n        )\n        # Populate the payload/request with the default args before passing\n        # execution onwards to the handler.\n        for arg in keys_that_correspond_to_default_values:\n            if request_method in ['GET', 'DELETE']:\n                normalized_request[arg] = normalized_arg_values.get(arg)\n            else:\n                normalized_payload[arg] = normalized_arg_values.get(arg)\n\n        # Here we use MyPy ignore because 'normalized_payload' is of\n        # Dict[str, Any] type, whereas 'self.normalized_payload' is a Generic\n        # type whose type can be decided while defining sub-classes. So, Due\n        # to this mismatch in types MyPy throws an error. Thus, to silence the\n        # error, we used type ignore here.\n        self.normalized_payload = normalized_payload  # type: ignore[assignment]\n        # Here we use MyPy ignore because 'normalized_request' is of\n        # Dict[str, Any] type, whereas 'self.normalized_request' is a Generic\n        # type whose type can be decided while defining sub-classes. So, Due\n        # to this mismatch in types MyPy throws an error. Thus, to silence the\n        # error, we used type ignore here.\n        self.normalized_request = normalized_request  # type: ignore[assignment]\n\n        # Here we use MyPy ignore because here we assigning RaiseErrorOnGet's\n        # instance to a 'get' method, and according to MyPy assignment to a\n        # method is not allowed.\n        self.request.get = RaiseErrorOnGet(  # type: ignore[assignment]\n            'Use self.normalized_request instead of self.request.').get\n        self.payload = RaiseErrorOnGet(\n            'Use self.normalized_payload instead of self.payload.')\n\n        if errors:\n            raise self.InvalidInputException('\\n'.join(errors))\n\n    @property\n    def current_user_is_site_maintainer(self) -> bool:\n        \"\"\"Returns whether the current user is a site maintainer.\n\n        A super admin or release coordinator is also a site maintainer.\n\n        Returns:\n            bool. Whether the current user is a site maintainer.\n        \"\"\"\n        return (\n            self.current_user_is_super_admin or\n            feconf.ROLE_ID_RELEASE_COORDINATOR in self.roles)\n\n    def _is_requested_path_currently_accessible_to_user(self) -> bool:\n        \"\"\"Checks whether the requested path is currently accessible to user.\n\n        Returns:\n            bool. Whether the requested path is currently accessible to user.\n        \"\"\"\n        return (\n            self.request.path in AUTH_HANDLER_PATHS or\n            not feconf.ENABLE_MAINTENANCE_MODE or\n            self.current_user_is_site_maintainer)\n\n    # Here we use type Any because the sub-classes of 'Basehandler' can have\n    # 'get' method with different number of arguments and types.\n    def get(self, *args: Any, **kwargs: Any) -> None:  # pylint: disable=unused-argument\n        \"\"\"Base method to handle GET requests.\"\"\"\n        logging.warning('Invalid URL requested: %s', self.request.uri)\n        self.error(404)\n        values: ResponseValueDict = {\n            'error': 'Could not find the page %s.' % self.request.uri,\n            'status_code': 404\n        }\n        self._render_exception(values)\n\n    # Here we use type Any because the sub-classes of 'Basehandler' can have\n    # 'post' method with different number of arguments and types.\n    def post(self, *args: Any) -> None:  # pylint: disable=unused-argument\n        \"\"\"Base method to handle POST requests.\n\n        Raises:\n            PageNotFoundException. Page not found error (error code 404).\n        \"\"\"\n        raise self.PageNotFoundException\n\n    # Here we use type Any because the sub-classes of 'Basehandler' can have\n    # 'put' method with different number of arguments and types.\n    def put(self, *args: Any) -> None:  # pylint: disable=unused-argument\n        \"\"\"Base method to handle PUT requests.\n\n        Raises:\n            PageNotFoundException. Page not found error (error code 404).\n        \"\"\"\n        raise self.PageNotFoundException\n\n    # Here we use type Any because the sub-classes of 'Basehandler' can have\n    # 'delete' method with different number of arguments and types.\n    def delete(self, *args: Any) -> None:  # pylint: disable=unused-argument\n        \"\"\"Base method to handle DELETE requests.\n\n        Raises:\n            PageNotFoundException. Page not found error (error code 404).\n        \"\"\"\n        raise self.PageNotFoundException\n\n    # Here we use type Any because the sub-classes of 'Basehandler' can have\n    # 'head' method with different number of arguments and types.\n    def head(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"Method to handle HEAD requests. The webapp library automatically\n        makes sure that HEAD only returns the headers of GET request.\n        \"\"\"\n        return self.get(*args, **kwargs)\n\n    # TODO(#16539): Once all the places are fixed with the type of value\n    # that is rendered to JSON, then please remove Sequence[Mapping[str, Any]]\n    # from render_json's argument type.\n    # Here we use type Any because the argument 'values' can accept various\n    # kinds of dictionaries that needs to be sent as a JSON response.\n    def render_json(\n        self, values: Union[str, Sequence[Mapping[str, Any]], Mapping[str, Any]]\n    ) -> None:\n        \"\"\"Prepares JSON response to be sent to the client.\n\n        Args:\n            values: str|dict. The key-value pairs to encode in the\n                JSON response.\n        \"\"\"\n        self.response.content_type = 'application/json; charset=utf-8'\n        self.response.headers['Content-Disposition'] = (\n            'attachment; filename=\"oppia-attachment.txt\"')\n        self.response.headers['Strict-Transport-Security'] = (\n            'max-age=31536000; includeSubDomains')\n        self.response.headers['X-Content-Type-Options'] = 'nosniff'\n        self.response.headers['X-Xss-Protection'] = '1; mode=block'\n\n        json_output = json.dumps(values, cls=utils.JSONEncoderForHTML)\n        # Write expects bytes, thus we need to encode the JSON output.\n        self.response.write(\n            b'%s%s' % (feconf.XSSI_PREFIX, json_output.encode('utf-8')))\n\n    def render_downloadable_file(\n        self, file: io.BytesIO, filename: str, content_type: str\n    ) -> None:\n        \"\"\"Prepares downloadable content to be sent to the client.\n\n        Args:\n            file: BytesIO. The data of the downloadable file.\n            filename: str. The name of the file to be rendered.\n            content_type: str. The type of file to be rendered.\n        \"\"\"\n        self.response.headers['Content-Type'] = content_type\n        self.response.headers['Content-Disposition'] = (\n            'attachment; filename=%s' % filename)\n        self.response.charset = 'utf-8'\n        # Here we use MyPy ignore because according to MyPy super can\n        # accept 'super class and self' as arguments but here we are passing\n        # 'webapp2.Response, and self.response' which confuses MyPy about the\n        # typing of super, and due to this MyPy is unable to recognize the\n        # 'write' method and throws an error. This change in arguments is\n        # done because we use 'super' method in order to bypass the write\n        # method in webapp2.Response, since webapp2.Response doesn't support\n        # writing bytes.\n        super(webapp2.Response, self.response).write(file.getvalue())  # type: ignore[misc] # pylint: disable=bad-super-call\n\n    def render_template(\n        self,\n        filepath: str,\n        iframe_restriction: Optional[str] = 'DENY',\n        *,\n        template_is_aot_compiled: bool = False\n    ) -> None:\n        \"\"\"Prepares an HTML response to be sent to the client.\n\n        Args:\n            filepath: str. The template filepath.\n            iframe_restriction: str or None. Possible values are\n                'DENY' and 'SAMEORIGIN':\n\n                DENY: Strictly prevents the template to load in an iframe.\n                SAMEORIGIN: The template can only be displayed in a frame\n                    on the same origin as the page itself.\n            template_is_aot_compiled: bool. False by default. Use\n                True when the template is compiled by angular AoT compiler.\n\n        Raises:\n            Exception. Invalid X-Frame-Options.\n        \"\"\"\n\n        # The 'no-store' must be used to properly invalidate the cache when we\n        # deploy a new version, using only 'no-cache' doesn't work properly.\n        self.response.cache_control.no_store = True\n        self.response.cache_control.must_revalidate = True\n        self.response.headers['Strict-Transport-Security'] = (\n            'max-age=31536000; includeSubDomains')\n        self.response.headers['X-Content-Type-Options'] = 'nosniff'\n        self.response.headers['X-Xss-Protection'] = '1; mode=block'\n\n        if iframe_restriction is not None:\n            if iframe_restriction in ['SAMEORIGIN', 'DENY']:\n                self.response.headers['X-Frame-Options'] = (\n                    str(iframe_restriction))\n            else:\n                raise Exception(\n                    'Invalid X-Frame-Options: %s' % iframe_restriction)\n\n        self.response.expires = 'Mon, 01 Jan 1990 00:00:00 GMT'\n        self.response.pragma = 'no-cache'\n        self.response.write(load_template(\n            filepath, template_is_aot_compiled=template_is_aot_compiled\n        ))\n\n    def _render_exception_json_or_html(\n        self, return_type: str, values: ResponseValueDict\n    ) -> None:\n        \"\"\"Renders an error page, or an error JSON response.\n\n        Args:\n            return_type: str. Indicator to return JSON or HTML.\n            values: dict. The key-value pairs to include in the response.\n        \"\"\"\n\n        method = self.request.environ['REQUEST_METHOD']\n\n        if return_type == feconf.HANDLER_TYPE_HTML and method == 'GET':\n            self.values.update(values)\n            if self.iframed:\n                self.render_template(\n                    'error-iframed.mainpage.html', iframe_restriction=None)\n            elif values['status_code'] == 404:\n                # Only 404 routes can be handled with angular router as it only\n                # has access to the path, not to the status code.\n                # That's why 404 status code is treated differently.\n                self.render_template('oppia-root.mainpage.html')\n            else:\n                self.render_template(\n                    'error-page-%s.mainpage.html' % values['status_code'])\n        else:\n            if return_type not in (\n                    feconf.HANDLER_TYPE_JSON, feconf.HANDLER_TYPE_DOWNLOADABLE):\n                logging.warning(\n                    'Not a recognized return type: defaulting to render JSON.')\n            self.render_json(values)\n\n    def _render_exception(\n        self, values: ResponseValueDict\n    ) -> None:\n        \"\"\"Renders an error page, or an error JSON response.\n\n        Args:\n            values: dict. The key-value pairs to include in the response.\n        \"\"\"\n        # The error codes here should be in sync with the error pages\n        # generated via webpack.common.config.ts.\n        assert values['status_code'] in [400, 401, 404, 500]\n        method = self.request.environ['REQUEST_METHOD']\n\n        if method == 'GET':\n            self._render_exception_json_or_html(\n                self.GET_HANDLER_ERROR_RETURN_TYPE, values)\n        elif method == 'POST':\n            self._render_exception_json_or_html(\n                self.POST_HANDLER_ERROR_RETURN_TYPE, values)\n        elif method == 'PUT':\n            self._render_exception_json_or_html(\n                self.PUT_HANDLER_ERROR_RETURN_TYPE, values)\n        elif method == 'DELETE':\n            self._render_exception_json_or_html(\n                self.DELETE_HANDLER_ERROR_RETURN_TYPE, values)\n        else:\n            logging.warning('Not a recognized request method.')\n            self._render_exception_json_or_html(\n                feconf.HANDLER_TYPE_JSON, values\n            )\n\n    def handle_exception(\n        self, exception: BaseException, unused_debug_mode: bool\n    ) -> None:\n        \"\"\"Overwrites the default exception handler.\n\n        Args:\n            exception: Exception. The exception that was thrown.\n            unused_debug_mode: bool. True if the web application is running\n                in debug mode.\n        \"\"\"\n        if isinstance(exception, self.NotLoggedInException):\n            # This checks if the response should be JSON or HTML.\n            # For GET requests, there is no payload, so we check against\n            # GET_HANDLER_ERROR_RETURN_TYPE.\n            # Otherwise, we check whether self.payload exists.\n\n            # This check is to avoid throwing of 401 when payload doesn't\n            # exists and self.payload is replaced by RaiseErrorOnGet object.\n            # TODO(#13155): Change this to self.normalized_payload\n            #  once schema is implemented for all handlers.\n            payload_exists = (\n                self.payload is not None and\n                not isinstance(self.payload, RaiseErrorOnGet)\n            )\n            if (\n                    payload_exists or\n                    self.GET_HANDLER_ERROR_RETURN_TYPE ==\n                    feconf.HANDLER_TYPE_JSON\n            ):\n                self.error(401)\n                values: ResponseValueDict = {\n                    'error': 'You must be logged in to access this resource.',\n                    'status_code': 401\n                }\n                self._render_exception(values)\n            else:\n                self.redirect(user_services.create_login_url(self.request.uri))\n            return\n\n        logging.exception(\n            'Exception raised at %s: %s', self.request.uri, exception)\n\n        if isinstance(exception, self.PageNotFoundException):\n            logging.warning('Invalid URL requested: %s', self.request.uri)\n            self.error(404)\n            values = {\n                'error': 'Could not find the page %s.' % self.request.uri,\n                'status_code': 404\n            }\n            self._render_exception(values)\n            return\n\n        logging.exception('Exception raised: %s', exception)\n\n        if isinstance(exception, self.UnauthorizedUserException):\n            self.error(401)\n            values = {\n                'error': str(exception),\n                'status_code': 401\n            }\n            self._render_exception(values)\n            return\n\n        if isinstance(exception, self.InvalidInputException):\n            self.error(400)\n            values = {\n                'error': str(exception),\n                'status_code': 400\n            }\n            self._render_exception(values)\n            return\n\n        if isinstance(exception, self.InternalErrorException):\n            self.error(500)\n            values = {\n                'error': str(exception),\n                'status_code': 500\n            }\n            self._render_exception(values)\n            return\n\n        self.error(500)\n        values = {\n            'error': str(exception),\n            'status_code': 500\n        }\n        self._render_exception(values)\n\n    InternalErrorException = UserFacingExceptions.InternalErrorException\n    InvalidInputException = UserFacingExceptions.InvalidInputException\n    NotLoggedInException = UserFacingExceptions.NotLoggedInException\n    PageNotFoundException = UserFacingExceptions.PageNotFoundException\n    UnauthorizedUserException = UserFacingExceptions.UnauthorizedUserException\n\n\nclass Error404Handler(BaseHandler[Dict[str, str], Dict[str, str]]):\n    \"\"\"Handles 404 errors.\"\"\"\n\n    pass\n\n\nclass RaiseErrorOnGet:\n    \"\"\"Class that will throw a ValueError when the get function is invoked.\"\"\"\n\n    def __init__(self, message: str) -> None:\n        self.error_message = message\n\n    # Here we use type Any because the 'get' method can accept arbitrary number\n    # of arguments with different types.\n    def get(self, *args: Any, **kwargs: Any) -> None:\n        \"\"\"Raises an error when invoked.\"\"\"\n        raise ValueError(self.error_message)\n\n\nclass CsrfTokenManager:\n    \"\"\"Manages page/user tokens in memcache to protect against CSRF.\"\"\"\n\n    # Max age of the token (48 hours).\n    _CSRF_TOKEN_AGE_SECS: Final = 60 * 60 * 48\n    # Default user id for non-logged-in users.\n    _USER_ID_DEFAULT: Final = 'non_logged_in_user'\n\n    @classmethod\n    def init_csrf_secret(cls) -> None:\n        \"\"\"Verify that non-default CSRF secret exists; creates one if not.\"\"\"\n\n        # Any non-default value is fine.\n        if CSRF_SECRET.value and CSRF_SECRET.value != DEFAULT_CSRF_SECRET:\n            return\n\n        # Initialize to random value.\n        config_services.set_property(\n            feconf.SYSTEM_COMMITTER_ID, CSRF_SECRET.name,\n            base64.urlsafe_b64encode(os.urandom(20)))\n\n    @classmethod\n    def _create_token(\n            cls, user_id: Optional[str], issued_on: float,\n            nonce: Optional[str] = None) -> str:\n        \"\"\"Creates a new CSRF token.\n\n        Args:\n            user_id: str|None. The user_id for which the token is generated.\n            issued_on: float. The timestamp at which the token was issued.\n            nonce: str|None. A token that is never reused to prevent reply\n                attacks. This argument should only be provided when validating a\n                received CSRF token, in which case the nonce in the received\n                token should be provided here.\n\n        Returns:\n            str. The generated CSRF token.\n        \"\"\"\n        cls.init_csrf_secret()\n\n        # The token has 4 parts: hash of the actor user id, hash of the page\n        # name, hash of the time issued and plain text of the time issued.\n\n        if user_id is None:\n            user_id = cls._USER_ID_DEFAULT\n\n        # Round time to seconds.\n        issued_on_str = str(int(issued_on))\n\n        # Generate a nonce (number used once) to ensure that even two\n        # consecutive calls to the same endpoint in the same second generate\n        # different tokens. Note that this nonce is just for anti-collision\n        # purposes, so it's okay that the nonce is stored in the CSRF token and\n        # therefore can be controlled by an attacker. See OWASP guidance here:\n        # https://cheatsheetseries.owasp.org/cheatsheets/Cross-Site_Request_Forgery_Prevention_Cheat_Sheet.html#signed-double-submit-cookie.\n        if nonce is None:\n            nonce = base64.urlsafe_b64encode(os.urandom(20)).decode('utf-8')\n\n        digester = hmac.new(\n            key=CSRF_SECRET.value.encode('utf-8'),\n            digestmod='sha256'\n        )\n        digester.update(user_id.encode('utf-8'))\n        digester.update(b':')\n        digester.update(issued_on_str.encode('utf-8'))\n        digester.update(b':')\n        digester.update(nonce.encode('utf-8'))\n\n        digest = digester.digest()\n        # The b64encode returns bytes, so we first need to decode the returned\n        # bytes to string.\n        token = '%s/%s/%s' % (\n            issued_on_str, nonce,\n            base64.urlsafe_b64encode(digest).decode('utf-8'))\n\n        return token\n\n    @classmethod\n    def _get_current_time(cls) -> float:\n        \"\"\"Returns the current server time.\n\n        Returns:\n            float. The time in seconds as floating point number.\n        \"\"\"\n        return time.time()\n\n    @classmethod\n    def create_csrf_token(cls, user_id: Optional[str]) -> str:\n        \"\"\"Creates a CSRF token for the given user_id.\n\n        Args:\n            user_id: str|None. The user_id for whom the token is generated.\n\n        Returns:\n            str. The generated CSRF token.\n        \"\"\"\n        return cls._create_token(user_id, cls._get_current_time())\n\n    @classmethod\n    def is_csrf_token_valid(cls, user_id: Optional[str], token: str) -> bool:\n        \"\"\"Validates a given CSRF token.\n\n        Args:\n            user_id: str|None. The user_id to validate the CSRF token against.\n            token: str. The CSRF token to validate.\n\n        Returns:\n            bool. Whether the given CSRF token is valid.\n        \"\"\"\n        try:\n            parts = token.split('/')\n            if len(parts) != 3:\n                return False\n\n            issued_on = int(parts[0])\n            age = cls._get_current_time() - issued_on\n            if age > cls._CSRF_TOKEN_AGE_SECS:\n                return False\n\n            nonce = parts[1]\n\n            authentic_token = cls._create_token(user_id, issued_on, nonce)\n            if hmac.compare_digest(\n                authentic_token.encode('utf-8'), token.encode('utf-8')\n            ):\n                return True\n\n            return False\n        except Exception:\n            return False\n\n\nclass CsrfTokenHandler(BaseHandler[Dict[str, str], Dict[str, str]]):\n    \"\"\"Handles sending CSRF tokens to the frontend.\"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    REDIRECT_UNFINISHED_SIGNUPS = False\n    URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n    HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n    # Here we use MyPy ignore because the signature of 'get' method is not\n    # compatible with super class's (BaseHandler) 'get' method.\n    def get(self) -> None:  # type: ignore[override]\n        csrf_token = CsrfTokenManager.create_csrf_token(\n            self.user_id)\n        self.render_json({\n            'token': csrf_token,\n        })\n\n\nclass OppiaMLVMHandler(\n    BaseHandler[_NormalizedPayloadDictType, _NormalizedRequestDictType]\n):\n    \"\"\"Base class for the handlers that communicate with Oppia-ML VM instances.\n    \"\"\"\n\n    GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n    # Here we use type Any because the sub-classes of OppiaMLVMHandler can\n    # contain different schemas with different types of values, like str,\n    # complex Dicts and etc.\n    URL_PATH_ARGS_SCHEMAS: Dict[str, Any] = {}\n    # Here we use type Any because the sub-classes of OppiaMLVMHandler can\n    # contain different schemas with different types of values, like str,\n    # complex Dicts and etc.\n    HANDLER_ARGS_SCHEMAS: Dict[str, Any] = {}\n\n    @abc.abstractmethod\n    def extract_request_message_vm_id_and_signature(\n        self\n    ) -> classifier_domain.OppiaMLAuthInfo:\n        \"\"\"Returns the OppiaMLAuthInfo domain object containing\n        information from the incoming request that is necessary for\n        authentication.\n\n        Since incoming request can be either a protobuf serialized binary or\n        a JSON object, the derived classes must implement the necessary\n        logic to decode the incoming request and return a tuple of size 3\n        where message is at index 0, vm_id is at index 1 and signature is at\n        index 2.\n\n        Raises:\n            NotImplementedError. The derived child classes must implement the\n                necessary logic as described above.\n        \"\"\"\n        raise NotImplementedError\n", "# coding: utf-8\n#\n# Copyright 2014 The Oppia Authors. All Rights Reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS-IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tests for generic controller behavior.\"\"\"\n\nfrom __future__ import annotations\n\nimport contextlib\nimport importlib\nimport inspect\nimport io\nimport json\nimport logging\nimport os\nimport re\nimport types\n\nfrom core import feconf\nfrom core import handler_schema_constants\nfrom core import utils\nfrom core.constants import constants\nfrom core.controllers import acl_decorators\nfrom core.controllers import base\nfrom core.controllers import payload_validator\nfrom core.domain import auth_domain\nfrom core.domain import classifier_domain\nfrom core.domain import classifier_services\nfrom core.domain import exp_services\nfrom core.domain import rights_manager\nfrom core.domain import taskqueue_services\nfrom core.domain import user_services\nfrom core.domain import wipeout_service\nfrom core.platform import models\nfrom core.tests import test_utils\nimport main\n\nfrom typing import Dict, Final, FrozenSet, List, Optional, TypedDict\nimport webapp2\nfrom webapp2_extras import routes\nimport webtest\n\nMYPY = False\nif MYPY:  # pragma: no cover\n    from mypy_imports import platform_auth_services as auth_services\n\nauth_services = models.Registry.import_auth_services()\ndatastore_services = models.Registry.import_datastore_services()\nsecrets_services = models.Registry.import_secrets_services()\n(user_models,) = models.Registry.import_models([models.Names.USER])\n\nFORTY_EIGHT_HOURS_IN_SECS: Final = 48 * 60 * 60\nPADDING: Final = 1\n\n\nclass HelperFunctionTests(test_utils.GenericTestBase):\n\n    def test_load_template(self) -> None:\n        oppia_root_path = os.path.join(\n            'core', 'templates', 'pages', 'oppia-root')\n        with self.swap(feconf, 'FRONTEND_TEMPLATES_DIR', oppia_root_path):\n            self.assertIn(\n                '\"Loading | Oppia\"',\n                base.load_template(\n                    'oppia-root.mainpage.html',\n                    template_is_aot_compiled=False\n                )\n            )\n\n\nclass UniqueTemplateNamesTests(test_utils.GenericTestBase):\n    \"\"\"Tests to ensure that all template filenames in\n    core/templates/pages have unique filenames. This is required\n    for the backend tests to work correctly since they fetch templates\n    from this directory based on name of the template. For details, refer\n    get_filepath_from_filename function in test_utils.py.\n    \"\"\"\n\n    def test_template_filenames_are_unique(self) -> None:\n        templates_dir = os.path.join(\n            'core', 'templates', 'pages')\n        all_template_names: List[str] = []\n        for root, _, filenames in os.walk(templates_dir):\n            template_filenames = [\n                filename for filename in filenames if filename.endswith(\n                    '.html')]\n            all_template_names = all_template_names + template_filenames\n        self.assertEqual(len(all_template_names), len(set(all_template_names)))\n\n\nclass BaseHandlerTests(test_utils.GenericTestBase):\n\n    TEST_LEARNER_EMAIL: Final = 'test.learner@example.com'\n    TEST_LEARNER_USERNAME: Final = 'testlearneruser'\n    TEST_CREATOR_EMAIL: Final = 'test.creator@example.com'\n    TEST_CREATOR_USERNAME: Final = 'testcreatoruser'\n    TEST_EDITOR_EMAIL: Final = 'test.editor@example.com'\n    TEST_EDITOR_USERNAME: Final = 'testeditoruser'\n    DELETED_USER_EMAIL: Final = 'deleted.user@example.com'\n    DELETED_USER_USERNAME: Final = 'deleteduser'\n    PARTIALLY_LOGGED_IN_USER_EMAIL: Final = 'partial@example.com'\n\n    class MockHandlerWithInvalidReturnType(\n        base.BaseHandler[Dict[str, str], Dict[str, str]]\n    ):\n        GET_HANDLER_ERROR_RETURN_TYPE = 'invalid_type'\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n        # Here we use MyPy ignore because the signature of 'get' method does not\n        # match with the signature of super class's (BaseHandler) 'get' method,\n        # and this happens because all handler methods in the main codebase have\n        # decorators which modify the function signature accordingly, but these\n        # methods in base_test.py do not.\n        def get(self) -> None:  # type: ignore[override]\n            self.render_template('invalid_page.html')\n\n        def options(self) -> None:\n            \"\"\"Do a OPTIONS request. This is an unrecognized request method in our\n            codebase.\n            \"\"\"\n            self.render_template('invalid_page.html')\n\n    class MockHandlerForTestingErrorPageWithIframed(\n        base.BaseHandler[Dict[str, str], Dict[str, str]]\n    ):\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n        # Here we use MyPy ignore because the signature of 'get' method does not\n        # match with the signature of super class's (BaseHandler) 'get' method,\n        # and this happens because all handler methods in the main codebase have\n        # decorators which modify the function signature accordingly, but these\n        # methods in base_test.py do not.\n        def get(self) -> None:  # type: ignore[override]\n            self.iframed = True\n            self.render_template('invalid_page.html')\n\n    class MockHandlerForTestingUiAccessWrapper(\n        base.BaseHandler[Dict[str, str], Dict[str, str]]\n    ):\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n        # Here we use MyPy ignore because the signature of 'get' method does not\n        # match with the signature of super class's (BaseHandler) 'get' method,\n        # and this happens because all handler methods in the main codebase have\n        # decorators which modify the function signature accordingly, but these\n        # methods in base_test.py do not.\n        def get(self) -> None:  # type: ignore[override]\n            \"\"\"Handles GET requests.\"\"\"\n            pass\n\n    class MockHandlerForTestingAuthorizationWrapper(\n        base.BaseHandler[Dict[str, str], Dict[str, str]]\n    ):\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n        # Here we use MyPy ignore because the signature of 'get' method does not\n        # match with the signature of super class's (BaseHandler) 'get' method,\n        # and this happens because all handler methods in the main codebase have\n        # decorators which modify the function signature accordingly, but these\n        # methods in base_test.py do not.\n        def get(self) -> None:  # type: ignore[override]\n            \"\"\"Handles GET requests.\"\"\"\n            pass\n\n    def setUp(self) -> None:\n        super(BaseHandlerTests, self).setUp()\n        self.signup('user@example.com', 'user')\n\n        # Create a user to test redirect behavior for the learner.\n        # A \"learner\" is defined as a user who has not created or contributed\n        # to any exploration ever.\n        self.signup(self.TEST_LEARNER_EMAIL, self.TEST_LEARNER_USERNAME)\n\n        # Create two users to test redirect behavior for the creators.\n        # A \"creator\" is defined as a user who has created, edited or\n        # contributed to any exploration at present or in past.\n        self.signup(self.TEST_CREATOR_EMAIL, self.TEST_CREATOR_USERNAME)\n        self.signup(self.TEST_EDITOR_EMAIL, self.TEST_EDITOR_USERNAME)\n\n        # Create user that is scheduled for deletion.\n        self.signup(self.DELETED_USER_EMAIL, self.DELETED_USER_USERNAME)\n        deleted_user_id = self.get_user_id_from_email(self.DELETED_USER_EMAIL)\n        wipeout_service.pre_delete_user(deleted_user_id)\n\n        # Create a new user but do not submit their registration form.\n        user_services.create_new_user(\n            self.get_auth_id_from_email(self.PARTIALLY_LOGGED_IN_USER_EMAIL),\n            self.PARTIALLY_LOGGED_IN_USER_EMAIL)\n\n    def test_that_no_get_results_in_500_error(self) -> None:\n        \"\"\"Test that no GET request results in a 500 error.\"\"\"\n\n        for route in main.URLS:\n            url = re.sub('<([^/^:]+)>', 'abc123', route.template)\n\n            # This url is ignored since it is only needed for a protractor test.\n            # The backend tests fetch templates from\n            # core/templates/pages instead of webpack_bundles since we\n            # skip webpack compilation for backend tests.\n            # The console_errors.html template is present in\n            # core/templates/tests and we want one canonical\n            # directory for retrieving templates so we ignore this url.\n            if url == '/console_errors':\n                continue\n\n            with self.swap_to_always_return(\n                secrets_services, 'get_secret', 'secret'\n            ):\n                # Some of these will 404 or 302. This is expected.\n                self.get_response_without_checking_for_errors(\n                    url, [200, 301, 302, 400, 401, 404])\n\n        # TODO(sll): Add similar tests for POST, PUT, DELETE.\n        # TODO(sll): Set a self.payload attr in the BaseHandler for\n        #     POST, PUT and DELETE. Something needs to regulate what\n        #     the fields in the payload should be.\n\n    def test_requests_for_missing_csrf_token(self) -> None:\n        \"\"\"Tests request without csrf_token results in 401 error.\"\"\"\n\n        self.post_json(\n            '/community-library/any', data={}, expected_status_int=401)\n\n        self.put_json(\n            '/community-library/any', payload={}, expected_status_int=401)\n\n    def test_requests_for_invalid_paths(self) -> None:\n        \"\"\"Test that requests for invalid paths result in a 404 error.\"\"\"\n        user_id = user_services.get_user_id_from_username('learneruser')\n        csrf_token = base.CsrfTokenManager.create_csrf_token(user_id)\n\n        self.get_html_response(\n            '/community-library/extra', expected_status_int=404)\n\n        self.get_html_response(\n            '/community-library/data/extra', expected_status_int=404)\n\n        self.post_json(\n            '/community-library/extra', data={}, csrf_token=csrf_token,\n            expected_status_int=404)\n\n        self.put_json(\n            '/community-library/extra', payload={}, csrf_token=csrf_token,\n            expected_status_int=404)\n\n        self.delete_json('/community-library/data', expected_status_int=404)\n\n    def test_html_requests_have_no_store_cache_policy(self) -> None:\n        response = self.get_html_response('/community-library')\n        # We set 'no-store' and 'must-revalidate', but webapp\n        # adds 'no-cache' since it is basically a subset of 'no-store'.\n        self.assertEqual(\n            response.headers['Cache-Control'],\n            'must-revalidate, no-cache, no-store'\n        )\n\n    def test_root_redirect_rules_for_deleted_user_prod_mode(self) -> None:\n        with self.swap(constants, 'DEV_MODE', False):\n            self.login(self.DELETED_USER_EMAIL)\n            response = self.get_html_response('/', expected_status_int=302)\n            self.assertIn('pending-account-deletion', response.headers['location'])\n\n    def test_root_redirect_rules_for_deleted_user_dev_mode(self) -> None:\n        with self.swap(constants, 'DEV_MODE', True):\n            self.login(self.DELETED_USER_EMAIL)\n            response = self.get_html_response('/', expected_status_int=302)\n            self.assertIn('pending-account-deletion', response.headers['location'])\n\n    def test_get_with_invalid_return_type_logs_correct_warning(self) -> None:\n        # Modify the testapp to use the mock handler.\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock', self.MockHandlerWithInvalidReturnType,\n                name='MockHandlerWithInvalidReturnType')],\n            debug=feconf.DEBUG,\n        ))\n\n        observed_log_messages: List[str] = []\n        def mock_logging_function(msg: str) -> None:\n            observed_log_messages.append(msg)\n\n        with self.swap(logging, 'warning', mock_logging_function):\n            self.get_json('/mock', expected_status_int=500)\n            self.assertEqual(len(observed_log_messages), 1)\n            self.assertEqual(\n                observed_log_messages[0],\n                'Not a recognized return type: defaulting to render JSON.')\n\n    def test_unrecognized_request_method_logs_correct_warning(self) -> None:\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock', self.MockHandlerWithInvalidReturnType,\n                name='MockHandlerWithInvalidReturnType')],\n            debug=feconf.DEBUG,\n        ))\n\n        observed_log_messages: List[str] = []\n        def mock_logging_function(msg: str) -> None:\n            observed_log_messages.append(msg)\n\n        with self.swap(logging, 'warning', mock_logging_function):\n            self.testapp.options('/mock', status=500)\n            self.assertEqual(len(observed_log_messages), 1)\n            self.assertEqual(\n                observed_log_messages[0],\n                'Not a recognized request method.')\n\n    def test_renders_error_page_with_iframed(self) -> None:\n        # Modify the testapp to use the mock handler.\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_iframed', self.MockHandlerForTestingErrorPageWithIframed,\n                name='MockHandlerForTestingErrorPageWithIframed')],\n            debug=feconf.DEBUG,\n        ))\n        # The 500 is expected because the template file does not exist\n        # (so it is a legitimate server error caused by the\n        # MockHandlerForTestingErrorPageWithIframed).\n        response = self.get_html_response(\n            '/mock_iframed', expected_status_int=500)\n\n        self.assertIn(\n            b'<oppia-error-iframed-page-root></oppia-error-iframed-page-root>',\n            response.body\n        )\n\n    def test_dev_mode_cannot_be_true_on_production(self) -> None:\n        server_software_swap = self.swap(\n            os, 'environ', {'SERVER_SOFTWARE': 'Production'})\n        assert_raises_regexp_context_manager = self.assertRaisesRegex(\n            Exception, 'DEV_MODE can\\'t be true on production.')\n        with assert_raises_regexp_context_manager, server_software_swap:\n            # This reloads the feconf module so that all the checks in\n            # the module are reexecuted.\n            importlib.reload(feconf)  # pylint: disable-all\n\n    def test_frontend_error_handler(self) -> None:\n        observed_log_messages: List[str] = []\n\n        def _mock_logging_function(msg: str, *args: str) -> None:\n            \"\"\"Mocks logging.error().\"\"\"\n            observed_log_messages.append(msg % args)\n\n        with self.swap(logging, 'error', _mock_logging_function):\n            self.post_json('/frontend_errors', {'error': 'errors'})\n\n        self.assertEqual(observed_log_messages, ['Frontend error: errors'])\n\n    def test_redirect_when_user_is_disabled(self) -> None:\n        get_auth_claims_from_request_swap = self.swap_to_always_raise(\n            auth_services,\n            'get_auth_claims_from_request',\n            auth_domain.UserDisabledError\n        )\n        with get_auth_claims_from_request_swap:\n            response = self.get_html_response('/', expected_status_int=302)\n            self.assertIn(\n                'pending-account-deletion', response.headers['location'])\n\n    def test_redirect_oppia_test_server(self) -> None:\n        # The old demo server redirects to the new demo server.\n        response = self.get_html_response(\n            'https://oppiaserver.appspot.com/splash', expected_status_int=301)\n        self.assertEqual(\n            response.headers['Location'], 'https://oppiatestserver.appspot.com')\n\n    def test_no_redirection_for_cron_jobs(self) -> None:\n        # Valid URL, where user now has permissions.\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        self.get_json('/cron/models/cleanup', expected_status_int=200)\n        self.logout()\n\n        # Valid URL, but user does not have permissions.\n        self.get_json(\n            'https://oppiaserver.appspot.com/cron/models/cleanup',\n            expected_status_int=401)\n\n        # Invalid URL.\n        self.get_html_response(\n            'https://oppiaserver.appspot.com/cron/unknown',\n            expected_status_int=404)\n\n    def test_no_redirection_for_tasks(self) -> None:\n        tasks_data = '{\"fn_identifier\": \"%s\", \"args\": [[]], \"kwargs\": {}}' % (\n            taskqueue_services.FUNCTION_ID_DELETE_EXPS_FROM_USER_MODELS\n        )\n\n        # Valid URL, where user now has permissions.\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n        self.post_json(\n            'https://oppiaserver.appspot.com/task/deferredtaskshandler',\n            tasks_data,\n            use_payload=False,\n            expected_status_int=200\n        )\n        self.logout()\n\n        # Valid URL, but user does not have permissions.\n        self.post_json(\n            'https://oppiaserver.appspot.com/task/deferredtaskshandler',\n            tasks_data,\n            expected_status_int=401\n        )\n\n    def test_splash_redirect(self) -> None:\n        # Tests that the old '/splash' URL is redirected to '/'.\n        response = self.get_html_response('/splash', expected_status_int=302)\n        self.assertEqual('http://localhost/', response.headers['location'])\n\n    def test_partially_logged_in_redirect(self) -> None:\n        login_context = self.login_context(\n            self.PARTIALLY_LOGGED_IN_USER_EMAIL)\n\n        with login_context:\n            response = self.get_html_response(\n                '/splash', expected_status_int=302)\n            self.assertEqual(\n                response.location,\n                'http://localhost/logout?redirect_url=/splash')\n\n    def test_no_partially_logged_in_redirect_from_logout(self) -> None:\n        login_context = self.login_context(\n            self.PARTIALLY_LOGGED_IN_USER_EMAIL)\n\n        with login_context:\n            response = self.get_html_response(\n                '/logout', expected_status_int=200)\n\n    def test_unauthorized_user_exception_raised_when_session_is_stale(\n        self\n    ) -> None:\n        with contextlib.ExitStack() as exit_stack:\n            call_counter = exit_stack.enter_context(self.swap_with_call_counter(\n                auth_services, 'destroy_auth_session'))\n            logs = exit_stack.enter_context(\n                self.capture_logging(min_level=logging.ERROR))\n            exit_stack.enter_context(self.swap_to_always_raise(\n                auth_services, 'get_auth_claims_from_request',\n                error=auth_domain.StaleAuthSessionError('uh-oh')))\n\n            response = self.get_html_response('/', expected_status_int=302)\n\n        self.assertEqual(call_counter.times_called, 1)\n        self.assertEqual(\n            response.location,\n            'http://localhost/login?return_url=http%3A%2F%2Flocalhost%2F')\n\n    def test_unauthorized_user_exception_raised_when_session_is_invalid(\n        self\n    ) -> None:\n        with contextlib.ExitStack() as exit_stack:\n            call_counter = exit_stack.enter_context(self.swap_with_call_counter(\n                auth_services, 'destroy_auth_session'))\n            logs = exit_stack.enter_context(\n                self.capture_logging(min_level=logging.ERROR))\n            exit_stack.enter_context(self.swap_to_always_raise(\n                auth_services, 'get_auth_claims_from_request',\n                error=auth_domain.InvalidAuthSessionError('uh-oh')))\n\n            response = self.get_html_response('/', expected_status_int=302)\n\n        self.assert_matches_regexps(logs, ['User session is invalid!'])\n        self.assertEqual(call_counter.times_called, 1)\n        self.assertEqual(\n            response.location,\n            'http://localhost/login?return_url=http%3A%2F%2Flocalhost%2F')\n\n    def test_signup_attempt_on_wrong_page_fails(self) -> None:\n        with contextlib.ExitStack() as exit_stack:\n            call_counter = exit_stack.enter_context(self.swap_with_call_counter(\n                auth_services, 'destroy_auth_session'))\n            logs = exit_stack.enter_context(\n                self.capture_logging(min_level=logging.ERROR))\n            exit_stack.enter_context(self.swap_to_always_return(\n                auth_services,\n                'get_auth_claims_from_request',\n                auth_domain.AuthClaims(\n                    'auth_id', self.NEW_USER_EMAIL, role_is_super_admin=False)\n            ))\n            response = self.get_html_response('/', expected_status_int=200)\n            self.assertIn(\n                b'<lightweight-oppia-root></lightweight-oppia-root>',\n                response.body\n            )\n\n        self.assert_matches_regexps(\n            logs,\n            [\n                'Cannot find user auth_id with email %s on '\n                'page http://localhost/' % self.NEW_USER_EMAIL\n            ]\n        )\n        self.assertEqual(call_counter.times_called, 1)\n\n    def test_user_without_email_id_raises_exception(self) -> None:\n        with contextlib.ExitStack() as exit_stack:\n            swap_auth_claim = self.swap_to_always_return(\n                auth_services,\n                'get_auth_claims_from_request',\n                auth_domain.AuthClaims(\n                    'auth_id', None, role_is_super_admin=False)\n            )\n            logs = exit_stack.enter_context(\n                self.capture_logging(min_level=logging.ERROR)\n            )\n            with swap_auth_claim:\n                self.get_html_response('/')\n\n        self.assert_matches_regexps(\n            logs,\n            [\n                'No email address was found for the user.'\n            ]\n        )\n\n    def test_logs_request_with_invalid_payload(self) -> None:\n        with contextlib.ExitStack() as exit_stack:\n            logs = exit_stack.enter_context(\n                self.capture_logging(min_level=logging.ERROR))\n            exit_stack.enter_context(self.swap_to_always_raise(\n                webapp2.Request, 'get',\n                error=ValueError('uh-oh')))\n            self.get_custom_response(\n                '/',\n                expected_content_type='text/plain',\n                params=None,\n                expected_status_int=500)\n\n        self.assertRegexpMatches(\n            logs[0],\n            'uh-oh: request GET /')\n\n\nclass MissingHandlerArgsTests(test_utils.GenericTestBase):\n\n    class MissingArgsHandler(\n        base.BaseHandler[Dict[str, str], Dict[str, str]]\n    ):\n        \"\"\"Mock handler for testing.\"\"\"\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n\n        # Here we use MyPy ignore because the signature of 'post' method does\n        # not match with the signature of super class's (BaseHandler) 'post'\n        # method, and this happens because all handler methods in the main\n        # codebase have decorators which modify the function signature\n        # accordingly, but these methods in base_test.py do not.\n        def post(self) -> None:  # type: ignore[override]\n            \"\"\"Handles POST requests.\"\"\"\n            self.render_json({})\n\n    def setUp(self) -> None:\n        super(MissingHandlerArgsTests, self).setUp()\n\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n\n        # Modify the testapp to use the MissingArgsHandler.\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [\n                webapp2.Route(\n                    '/MissingArgHandler',\n                    self.MissingArgsHandler,\n                    name='MissingArgHandler'\n                )\n            ],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_missing_arg_handler_raises_error(self) -> None:\n        response = self.testapp.post('/MissingArgHandler', status=500)\n        parsed_response = json.loads(response.body[len(feconf.XSSI_PREFIX):])\n        self.assertEqual(\n            parsed_response['error'],\n            'Missing schema for POST method in MissingArgsHandler handler class.'\n        )\n\n\nclass MaintenanceModeTests(test_utils.GenericTestBase):\n    \"\"\"Tests BaseHandler behavior when maintenance mode is enabled.\n\n    Each test case runs within a context where ENABLE_MAINTENANCE_MODE is True.\n    \"\"\"\n\n    def setUp(self) -> None:\n        super(MaintenanceModeTests, self).setUp()\n        self.signup(\n            self.RELEASE_COORDINATOR_EMAIL, self.RELEASE_COORDINATOR_USERNAME)\n        self.add_user_role(\n            self.RELEASE_COORDINATOR_USERNAME,\n            feconf.ROLE_ID_RELEASE_COORDINATOR)\n        with contextlib.ExitStack() as context_stack:\n            context_stack.enter_context(\n                self.swap(feconf, 'ENABLE_MAINTENANCE_MODE', True))\n            self.context_stack = context_stack.pop_all()\n\n    def tearDown(self) -> None:\n        self.context_stack.close()\n        super(MaintenanceModeTests, self).tearDown()\n\n    def test_html_response_is_rejected(self) -> None:\n        destroy_auth_session_call_counter = self.context_stack.enter_context(\n            self.swap_with_call_counter(auth_services, 'destroy_auth_session'))\n\n        response = self.get_html_response(\n            '/community-library', expected_status_int=200)\n\n        self.assertIn(b'<oppia-maintenance-page>', response.body)\n        self.assertNotIn(b'<oppia-library-page-root>', response.body)\n        self.assertEqual(destroy_auth_session_call_counter.times_called, 1)\n\n    def test_html_response_is_not_rejected_when_user_is_super_admin(\n        self\n    ) -> None:\n        self.context_stack.enter_context(self.super_admin_context())\n        destroy_auth_session_call_counter = self.context_stack.enter_context(\n            self.swap_with_call_counter(auth_services, 'destroy_auth_session'))\n\n        response = self.get_html_response('/community-library')\n\n        self.assertIn(b'<oppia-root></oppia-root>', response.body)\n        self.assertNotIn(b'<oppia-maintenance-page>', response.body)\n        self.assertEqual(destroy_auth_session_call_counter.times_called, 0)\n\n    def test_html_response_is_not_rejected_when_user_is_release_coordinator(\n        self\n    ) -> None:\n        self.context_stack.enter_context(\n            self.login_context(self.RELEASE_COORDINATOR_EMAIL))\n        destroy_auth_session_call_counter = self.context_stack.enter_context(\n            self.swap_with_call_counter(auth_services, 'destroy_auth_session'))\n\n        response = self.get_html_response('/community-library')\n\n        self.assertIn(b'<oppia-root></oppia-root>', response.body)\n        self.assertNotIn(b'<oppia-maintenance-page>', response.body)\n        self.assertEqual(destroy_auth_session_call_counter.times_called, 0)\n\n    def test_csrfhandler_handler_is_not_rejected(self) -> None:\n        response = self.get_json('/csrfhandler')\n\n        self.assertTrue(\n            base.CsrfTokenManager.is_csrf_token_valid(None, response['token']))\n\n    def test_session_begin_handler_is_not_rejected(self) -> None:\n        call_counter = self.context_stack.enter_context(\n            self.swap_with_call_counter(\n                auth_services, 'establish_auth_session'))\n\n        self.get_html_response('/session_begin', expected_status_int=200)\n\n        self.assertEqual(call_counter.times_called, 1)\n\n    def test_session_end_handler_is_not_rejected(self) -> None:\n        call_counter = self.context_stack.enter_context(\n            self.swap_with_call_counter(auth_services, 'destroy_auth_session'))\n\n        self.get_html_response('/session_end', expected_status_int=200)\n\n        self.assertEqual(call_counter.times_called, 1)\n\n    def test_signup_fails(self) -> None:\n        with self.assertRaisesRegex(\n            Exception, '\\'<oppia-maintenance-page>\\' unexpectedly found in'):\n            self.signup(self.VIEWER_EMAIL, self.VIEWER_USERNAME)\n\n    def test_signup_succeeds_when_maintenance_mode_is_disabled(self) -> None:\n        with self.swap(feconf, 'ENABLE_MAINTENANCE_MODE', False):\n            self.signup(self.VIEWER_EMAIL, self.VIEWER_USERNAME)\n\n    def test_signup_succeeds_when_user_is_super_admin(self) -> None:\n        self.signup(\n            self.CURRICULUM_ADMIN_EMAIL,\n            self.CURRICULUM_ADMIN_USERNAME,\n            is_super_admin=True\n        )\n\n    def test_admin_auth_session_is_preserved_when_in_maintenance_mode(\n        self\n    ) -> None:\n        # TODO(#12692): Use stateful login sessions to assert the behavior of\n        # logging out, rather than asserting that destroy_auth_session() gets\n        # called.\n        destroy_auth_session_call_counter = self.context_stack.enter_context(\n            self.swap_with_call_counter(auth_services, 'destroy_auth_session'))\n        self.context_stack.enter_context(self.super_admin_context())\n\n        with self.swap(feconf, 'ENABLE_MAINTENANCE_MODE', False):\n            self.get_json('/url_handler?current_url=/')\n\n        self.assertEqual(destroy_auth_session_call_counter.times_called, 0)\n\n        self.get_json('/url_handler?current_url=/')\n\n        self.assertEqual(destroy_auth_session_call_counter.times_called, 0)\n\n    def test_non_admin_auth_session_is_destroyed_when_in_maintenance_mode(\n        self\n    ) -> None:\n        # TODO(#12692): Use stateful login sessions to assert the behavior of\n        # logging out, rather than asserting that destroy_auth_session() gets\n        # called.\n        destroy_auth_session_call_counter = self.context_stack.enter_context(\n            self.swap_with_call_counter(auth_services, 'destroy_auth_session'))\n\n        with self.swap(feconf, 'ENABLE_MAINTENANCE_MODE', False):\n            self.get_json('/url_handler?current_url=/')\n\n        self.assertEqual(destroy_auth_session_call_counter.times_called, 0)\n\n        response = self.get_html_response('/url_handler?current_url=/')\n        self.assertIn(b'<oppia-maintenance-page>', response.body)\n\n        self.assertEqual(destroy_auth_session_call_counter.times_called, 1)\n\n\nclass CsrfTokenManagerTests(test_utils.GenericTestBase):\n\n    def test_create_and_validate_token(self) -> None:\n        uid = 'user_id'\n\n        token = base.CsrfTokenManager.create_csrf_token(uid)\n        self.assertTrue(base.CsrfTokenManager.is_csrf_token_valid(\n            uid, token))\n\n        self.assertFalse(\n            base.CsrfTokenManager.is_csrf_token_valid('bad_user', token))\n        self.assertFalse(\n            base.CsrfTokenManager.is_csrf_token_valid(uid, 'new_token'))\n        self.assertFalse(\n            base.CsrfTokenManager.is_csrf_token_valid(uid, 'a/new/token'))\n\n    def test_non_default_csrf_secret_is_used(self) -> None:\n        base.CsrfTokenManager.create_csrf_token('uid')\n        self.assertNotEqual(base.CSRF_SECRET.value, base.DEFAULT_CSRF_SECRET)\n\n    def test_token_expiry(self) -> None:\n        # This can be any value.\n        orig_time = 100.0\n        current_time = orig_time\n\n        def mock_get_current_time(unused_cls: str) -> float:\n            return current_time\n\n        with self.swap(\n            base.CsrfTokenManager, '_get_current_time',\n            types.MethodType(mock_get_current_time, base.CsrfTokenManager)):\n            # Create a token and check that it expires correctly.\n            token = base.CsrfTokenManager().create_csrf_token('uid')\n            self.assertTrue(base.CsrfTokenManager.is_csrf_token_valid(\n                'uid', token))\n\n            current_time = orig_time + 1\n            self.assertTrue(base.CsrfTokenManager.is_csrf_token_valid(\n                'uid', token))\n\n            current_time = orig_time + FORTY_EIGHT_HOURS_IN_SECS - PADDING\n            self.assertTrue(base.CsrfTokenManager.is_csrf_token_valid(\n                'uid', token))\n\n            current_time = orig_time + FORTY_EIGHT_HOURS_IN_SECS + PADDING\n            self.assertFalse(base.CsrfTokenManager.is_csrf_token_valid(\n                'uid', token))\n\n\nclass EscapingTests(test_utils.GenericTestBase):\n\n    class FakePage(base.BaseHandler[Dict[str, str], Dict[str, str]]):\n        \"\"\"Fake page for testing autoescaping.\"\"\"\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'POST': {}}\n\n        # Here we use MyPy ignore because the signature of 'post' method does\n        # not match with the signature of super class's (BaseHandler) 'post'\n        # method, and this happens because all handler methods in the main\n        # codebase have decorators which modify the function signature\n        # accordingly, but these methods in base_test.py do not.\n        def post(self) -> None:  # type: ignore[override]\n            \"\"\"Handles POST requests.\"\"\"\n            self.render_json({'big_value': u'\\n<script>\u9a6c={{'})\n\n    def setUp(self) -> None:\n        super(EscapingTests, self).setUp()\n\n        # Update a config property that shows in all pages.\n        self.signup(self.CURRICULUM_ADMIN_EMAIL, self.CURRICULUM_ADMIN_USERNAME)\n        self.login(self.CURRICULUM_ADMIN_EMAIL, is_super_admin=True)\n\n        # Modify the testapp to use the fake handler.\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/fake', self.FakePage, name='FakePage')],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_special_char_escaping(self) -> None:\n        response = self.testapp.post('/fake', params={})\n        self.assertEqual(response.status_int, 200)\n\n        self.assertTrue(response.body.startswith(feconf.XSSI_PREFIX))\n        self.assertIn(b'\\\\n\\\\u003cscript\\\\u003e\\\\u9a6c={{', response.body)\n        self.assertNotIn(b'<script>', response.body)\n        self.assertNotIn('\u9a6c'.encode('utf-8'), response.body)\n\n\nclass RenderDownloadableTests(test_utils.GenericTestBase):\n\n    class MockHandler(base.BaseHandler[Dict[str, str], Dict[str, str]]):\n        \"\"\"Mock handler that subclasses BaseHandler and serves a response\n        that is of a 'downloadable' type.\n        \"\"\"\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n        # Here we use MyPy ignore because the signature of 'get' method does not\n        # match with the signature of super class's (BaseHandler) 'get' method,\n        # and this happens because all handler methods in the main codebase have\n        # decorators which modify the function signature accordingly, but these\n        # methods in base_test.py do not.\n        def get(self) -> None:  # type: ignore[override]\n            \"\"\"Handles GET requests.\"\"\"\n            file_contents = io.BytesIO(b'example')\n            self.render_downloadable_file(\n                file_contents, 'example.pdf', 'text/plain')\n\n    def setUp(self) -> None:\n        super(RenderDownloadableTests, self).setUp()\n\n        # Modify the testapp to use the mock handler.\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock', self.MockHandler, name='MockHandler')],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_downloadable(self) -> None:\n        response = self.testapp.get('/mock')\n        self.assertEqual(\n            response.content_disposition, 'attachment; filename=example.pdf')\n        self.assertEqual(response.body, b'example')\n        self.assertEqual(response.content_type, 'text/plain')\n\n\nclass SessionBeginHandlerTests(test_utils.GenericTestBase):\n    \"\"\"Tests for /session_begin handler.\"\"\"\n\n    def test_get(self) -> None:\n        swap = self.swap_with_call_counter(\n            auth_services, 'establish_auth_session')\n\n        with swap as call_counter:\n            self.get_html_response('/session_begin', expected_status_int=200)\n\n        self.assertEqual(call_counter.times_called, 1)\n\n\nclass SessionEndHandlerTests(test_utils.GenericTestBase):\n    \"\"\"Tests for /session_end handler.\"\"\"\n\n    def test_get(self) -> None:\n        swap = (\n            self.swap_with_call_counter(auth_services, 'destroy_auth_session'))\n\n        with swap as call_counter:\n            self.get_html_response('/session_end', expected_status_int=200)\n\n        self.assertEqual(call_counter.times_called, 1)\n\n\nclass I18nDictsTests(test_utils.GenericTestBase):\n    \"\"\"Tests for I18n dicts.\"\"\"\n\n    def _extract_keys_from_json_file(self, filename: str) -> List[str]:\n        \"\"\"Returns the extracted keys from the json file corresponding to the\n        given filename.\n        \"\"\"\n        return sorted(json.loads(utils.get_file_contents(\n            os.path.join(os.getcwd(), self.get_static_asset_filepath(),\n                         'assets', 'i18n', filename)\n        )).keys())\n\n    def _extract_keys_from_html_file(self, filename: str) -> List[str]:\n        \"\"\"Returns the extracted keys from the html file corresponding to the\n        given filename.\n        \"\"\"\n        # The \\b is added at the start to ensure that keys ending with\n        # '_I18N_IDS' do not get matched. Instances of such keys can be found\n        # in learner_dashboard.html.\n        regex_pattern = r'(\\bI18N_[A-Z/_\\d]*)'\n        return re.findall(regex_pattern, utils.get_file_contents(\n            filename))\n\n    def _get_tags(\n        self, input_string: str, key: str, filename: str\n    ) -> List[str]:\n        \"\"\"Returns the parts in the input string that lie within <...>\n        characters.\n\n        Args:\n            input_string: str. The string to extract tags from.\n            key: str. The key for the key-value pair in the dict where the\n                string comes from (the string is typically the value in this\n                key-value pair). This is used only for logging errors.\n            filename: str. The filename which the string comes from. This is\n                used only for logging errors.\n\n        Returns:\n            list(str). A list of all tags contained in the input string.\n        \"\"\"\n        result = []\n        bracket_level = 0\n        current_string = ''\n        for c in input_string:\n            if c == '<':\n                current_string += c\n                bracket_level += 1\n            elif c == '>':\n                self.assertGreater(\n                    bracket_level, 0,\n                    msg='Invalid HTML: %s at %s in %s' % (\n                        input_string, key, filename))\n                result.append(current_string + c)\n                current_string = ''\n                bracket_level -= 1\n            elif bracket_level > 0:\n                current_string += c\n\n        self.assertEqual(\n            bracket_level, 0,\n            msg='Invalid HTML: %s at %s in %s' % (input_string, key, filename))\n        return sorted(result)\n\n    def test_i18n_keys(self) -> None:\n        \"\"\"Tests that the keys in all JSON files are a subset of those in\n        en.json.\n        \"\"\"\n        master_key_list = self._extract_keys_from_json_file('en.json')\n        self.assertGreater(len(master_key_list), 0)\n\n        supported_language_filenames = [\n            ('%s.json' % language_details['id'])\n            for language_details in constants.SUPPORTED_SITE_LANGUAGES]\n\n        filenames = os.listdir(\n            os.path.join(os.getcwd(), self.get_static_asset_filepath(),\n                         'assets', 'i18n'))\n        for filename in filenames:\n            if filename == 'en.json':\n                continue\n\n            key_list = self._extract_keys_from_json_file(filename)\n            # All other JSON files should have a subset of the keys in en.json.\n            self.assertEqual(len(set(key_list) - set(master_key_list)), 0)\n\n            # If there are missing keys in supported site languages, log an\n            # error, but don't fail the tests.\n            if (filename in supported_language_filenames and\n                    set(key_list) != set(master_key_list)):\n                untranslated_keys = list(set(master_key_list) - set(key_list))\n                self.log_line('Untranslated keys in %s:' % filename)\n                for key in untranslated_keys:\n                    self.log_line('- %s' % key)\n                self.log_line('')\n\n    def test_alphabetic_i18n_keys(self) -> None:\n        \"\"\"Tests that the keys of all i18n json files are arranged in\n        alphabetical order.\n        \"\"\"\n        filenames = os.listdir(\n            os.path.join(os.getcwd(), self.get_static_asset_filepath(),\n                         'assets', 'i18n'))\n        for filename in filenames:\n            with utils.open_file(\n                os.path.join(os.getcwd(), 'assets', 'i18n', filename),\n                mode='r') as f:\n                lines = f.readlines()\n                self.assertEqual(lines[0], '{\\n')\n                self.assertEqual(lines[-1], '}\\n')\n                lines = lines[1:-1]\n\n                key_list = [line[:line.find(':')].strip() for line in lines]\n                for key in key_list:\n                    self.assertTrue(key.startswith('\"I18N_'))\n                    if not key.startswith('\"I18N_'):\n                        self.log_line('Bad line in file: %s' % filename)\n                self.assertEqual(sorted(key_list), key_list)\n\n    # TODO(#14645): Remove this method when translation service is extended.\n    def test_hacky_tranlsation_keys_match_constants_en(self) -> None:\n        \"\"\"Tests that the hacky translation keys present in constants file\n        are also present in en.json.\n        \"\"\"\n        en_key_list = self._extract_keys_from_json_file('en.json')\n        hacky_translation_keys = constants.HACKY_TRANSLATION_KEYS\n        missing_hacky_translation_keys = list(\n            set(hacky_translation_keys) - set(en_key_list))\n        self.assertEqual(missing_hacky_translation_keys, [])\n\n    def test_keys_match_en_qqq(self) -> None:\n        \"\"\"Tests that en.json and qqq.json have the exact same set of keys.\"\"\"\n        en_key_list = self._extract_keys_from_json_file('en.json')\n        qqq_key_list = self._extract_keys_from_json_file('qqq.json')\n        self.assertEqual(en_key_list, qqq_key_list)\n\n    def test_keys_in_source_code_match_en(self) -> None:\n        \"\"\"Tests that keys in HTML files are present in en.json.\"\"\"\n        en_key_list = self._extract_keys_from_json_file('en.json')\n        dirs_to_search = [\n            os.path.join('core', 'templates', ''),\n            'extensions']\n        files_checked = 0\n        missing_keys_count = 0\n        for directory in dirs_to_search:\n            for root, _, files in os.walk(os.path.join(os.getcwd(), directory)):\n                for filename in files:\n                    if filename.endswith('.html'):\n                        files_checked += 1\n                        html_key_list = self._extract_keys_from_html_file(\n                            os.path.join(root, filename))\n                        if not set(html_key_list) <= set(en_key_list): #pylint: disable=unneeded-not\n                            self.log_line('ERROR: Undefined keys in %s:'\n                                          % os.path.join(root, filename))\n                            missing_keys = list(\n                                set(html_key_list) - set(en_key_list))\n                            missing_keys_count += len(missing_keys)\n                            for key in missing_keys:\n                                self.log_line(' - %s' % key)\n                            self.log_line('')\n        self.assertEqual(missing_keys_count, 0)\n        self.assertGreater(files_checked, 0)\n\n    def test_html_in_translations_is_preserved_correctly(self) -> None:\n        \"\"\"Tests that HTML in translated strings matches the original\n        structure.\n        \"\"\"\n        # For this test, show the entire diff if there is a mismatch.\n        self.maxDiff = 0\n\n        master_translation_dict = json.loads(utils.get_file_contents(\n            os.path.join(os.getcwd(), 'assets', 'i18n', 'en.json')))\n        # Remove anything outside '<'...'>' tags. Note that this handles both\n        # HTML tags and Angular variable interpolations.\n        master_tags_dict = {\n            key: self._get_tags(value, key, 'en.json')\n            for key, value in master_translation_dict.items()\n        }\n\n        mismatches = []\n\n        filenames = os.listdir(os.path.join(\n            os.getcwd(), self.get_static_asset_filepath(), 'assets', 'i18n'))\n        for filename in filenames:\n            if filename == 'qqq.json':\n                continue\n            translation_dict = json.loads(utils.get_file_contents(\n                os.path.join(os.getcwd(), 'assets', 'i18n', filename)))\n            for key, value in translation_dict.items():\n                tags = self._get_tags(value, key, filename)\n                if tags != master_tags_dict[key]:\n                    mismatches.append('%s (%s): %s != %s' % (\n                        filename, key, tags, master_tags_dict[key]))\n\n        # Sorting the list before printing makes it easier to systematically\n        # fix any issues that arise.\n        self.assertEqual(sorted(mismatches), [])\n\n\nclass GetHandlerTypeIfExceptionRaisedTests(test_utils.GenericTestBase):\n\n    class FakeHandler(base.BaseHandler[Dict[str, str], Dict[str, str]]):\n        \"\"\"A fake handler class.\"\"\"\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n        # Here we use MyPy ignore because the signature of 'get' method does not\n        # match with the signature of super class's (BaseHandler) 'get' method,\n        # and this happens because all handler methods in the main codebase have\n        # decorators which modify the function signature accordingly, but these\n        # methods in base_test.py do not.\n        def get(self) -> None:  # type: ignore[override]\n            \"\"\"Handles get requests.\"\"\"\n            raise self.InternalErrorException('fake exception')\n\n    def test_error_response_for_get_request_of_type_json_has_json_format(\n        self\n    ) -> None:\n        fake_urls = []\n        fake_urls.append(main.get_redirect_route(r'/fake', self.FakeHandler))\n        fake_urls.append(main.URLS[-1])\n        with self.swap(main, 'URLS', fake_urls):\n            self.testapp = webtest.TestApp(\n                webapp2.WSGIApplication(main.URLS, debug=feconf.DEBUG))\n            response = self.get_json(\n                '/fake', expected_status_int=500)\n            self.assertTrue(isinstance(response, dict))\n\n\nclass CheckAllHandlersHaveDecoratorTests(test_utils.GenericTestBase):\n    \"\"\"Tests that all methods in handlers have authentication decorators\n    applied on them.\n    \"\"\"\n\n    # Following handlers are present in base.py where acl_decorators cannot be\n    # imported.\n    UNDECORATED_HANDLERS: FrozenSet[str] = frozenset([\n        'CsrfTokenHandler',\n        'Error404Handler',\n        'SessionBeginHandler',\n        'SessionEndHandler',\n        'SeedFirebaseHandler',\n    ])\n\n    def test_every_method_has_decorator(self) -> None:\n        handlers_checked = []\n\n        for route in main.URLS:\n            handler = route.handler\n\n            if handler.__name__ in self.UNDECORATED_HANDLERS:\n                continue\n\n            if handler.get != base.BaseHandler.get:\n                handler_is_decorated = hasattr(handler.get, '__wrapped__')\n                handlers_checked.append(\n                    (handler.__name__, 'GET', handler_is_decorated))\n\n            if handler.post != base.BaseHandler.post:\n                handler_is_decorated = hasattr(handler.post, '__wrapped__')\n                handlers_checked.append(\n                    (handler.__name__, 'POST', handler_is_decorated))\n\n            if handler.put != base.BaseHandler.put:\n                handler_is_decorated = hasattr(handler.put, '__wrapped__')\n                handlers_checked.append(\n                    (handler.__name__, 'PUT', handler_is_decorated))\n\n            if handler.delete != base.BaseHandler.delete:\n                handler_is_decorated = hasattr(handler.delete, '__wrapped__')\n                handlers_checked.append(\n                    (handler.__name__, 'DELETE', handler_is_decorated))\n\n        self.log_line('Verifying decorators for handlers .... ')\n        for (name, method, handler_is_decorated) in handlers_checked:\n            self.log_line('%s %s method: %s' % (\n                name, method, 'PASS' if handler_is_decorated else 'FAIL'))\n        self.log_line(\n            'Total number of handlers checked: %s' % len(handlers_checked))\n\n        self.assertGreater(len(handlers_checked), 0)\n\n        for (name, method, handler_is_decorated) in handlers_checked:\n            with self.subTest('%s.%s' % (name, method)):\n                self.assertTrue(handler_is_decorated)\n\n\nclass GetItemsEscapedCharactersTests(test_utils.GenericTestBase):\n    \"\"\"Test that request.GET.items() correctly retrieves escaped characters.\"\"\"\n    class MockHandler(base.BaseHandler[Dict[str, str], Dict[str, str]]):\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n        # Here we use MyPy ignore because the signature of 'get' method does not\n        # match with the signature of super class's (BaseHandler) 'get' method,\n        # and this happens because all handler methods in the main codebase have\n        # decorators which modify the function signature accordingly, but these\n        # methods in base_test.py do not.\n        def get(self) -> None:  # type: ignore[override]\n            self.values.update(list(self.request.GET.items()))\n            self.render_json(self.values)\n\n    def test_get_items(self) -> None:\n        mock_testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock', self.MockHandler)],\n            debug=feconf.DEBUG,\n        ))\n        with self.swap(self, 'testapp', mock_testapp):\n            params = {\n                'param1': 'value1',\n                'param2': 'value2'\n            }\n            result = self.get_json('/mock?param1=value1&param2=value2')\n            self.assertDictContainsSubset(params, result)\n            params = {\n                'param1': 'value with space',\n                'param2': 'value with & + - /',\n                'param3': 'value with . % @ 123 = ! <>'\n            }\n            result = self.get_json(\n                r'/mock?param1=value%20with%20space&'\n                'param2=value%20with%20%26%20%2B%20-%20/&'\n                'param3=value%20with%20.%20%%20@%20123%20=%20!%20%3C%3E')\n            self.assertDictContainsSubset(params, result)\n\n\nclass ControllerClassNameTests(test_utils.GenericTestBase):\n\n    def test_controller_class_names(self) -> None:\n        \"\"\"This function checks that all controller class names end with\n        either 'Handler', 'Page' or 'FileDownloader'.\n        \"\"\"\n        # A mapping of returned handler types to expected name endings.\n        handler_type_to_name_endings_dict = {\n            feconf.HANDLER_TYPE_HTML: 'Page',\n            feconf.HANDLER_TYPE_JSON: 'Handler',\n            feconf.HANDLER_TYPE_DOWNLOADABLE: 'FileDownloader',\n        }\n        num_handlers_checked = 0\n        for url in main.URLS:\n            clazz = url.handler\n            num_handlers_checked += 1\n            all_base_classes = [\n                base_class.__name__ for base_class in inspect.getmro(clazz)]\n\n            # Check that it is a subclass of 'BaseHandler'.\n            if 'BaseHandler' in all_base_classes:\n                class_return_type = clazz.GET_HANDLER_ERROR_RETURN_TYPE\n                # Check that any class with a get handler has a\n                # GET_HANDLER_ERROR_RETURN_TYPE that's one of\n                # the allowed values.\n                if 'get' in clazz.__dict__.keys():\n                    self.assertIn(\n                        class_return_type, handler_type_to_name_endings_dict)\n                class_name = clazz.__name__\n                # BulkEmailWebhookEndpoint is a unique class, compared to\n                # others, since it is never called from the frontend, and so\n                # the error raised here on it - 'Please ensure that the name\n                # of this class ends with 'Page'' - doesn't apply.\n                # It is only called from the bulk email provider via a\n                # webhook to update Oppia's database.\n                if class_name == 'BulkEmailWebhookEndpoint':\n                    continue\n                file_name = inspect.getfile(clazz)\n                line_num = inspect.getsourcelines(clazz)[1]\n                allowed_class_ending = (\n                    handler_type_to_name_endings_dict[class_return_type])\n                # Check that the name of the class ends with\n                # the proper word if it has a get function.\n                if 'get' in clazz.__dict__.keys():\n                    message = (\n                        'Please ensure that the name of this class '\n                        'ends with \\'%s\\'' % allowed_class_ending)\n                    error_message = (\n                        '%s --> Line %s: %s' % (file_name, line_num, message))\n                    with self.subTest(class_name):\n                        self.assertTrue(\n                            class_name.endswith(allowed_class_ending),\n                            msg=error_message)\n\n                # Check that the name of the class ends with 'Handler'\n                # if it does not has a get function.\n                else:\n                    message = (\n                        'Please ensure that the name of this class '\n                        'ends with \\'Handler\\'')\n                    error_message = (\n                        '%s --> Line %s: %s'\n                        % (file_name, line_num, message))\n                    with self.subTest(class_name):\n                        self.assertTrue(\n                            class_name.endswith('Handler'), msg=error_message)\n\n        self.assertGreater(num_handlers_checked, 275)\n\n\nclass MockHandlerForTestingPageIframingNormalizedRequestDict(TypedDict):\n    \"\"\"Dict representation of MockHandlerForTestingPageIframing's\n    normalized_request dictionary.\n    \"\"\"\n\n    iframe_restriction: Optional[str]\n\n\nclass IframeRestrictionTests(test_utils.GenericTestBase):\n\n    class MockHandlerForTestingPageIframing(\n        base.BaseHandler[\n            Dict[str, str],\n            MockHandlerForTestingPageIframingNormalizedRequestDict\n        ]\n    ):\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS = {\n            'GET': {\n                'iframe_restriction': {\n                    'schema': {\n                        'type': 'basestring'\n                    },\n                    'default_value': None\n                }\n            }\n        }\n\n        # Here we use MyPy ignore because the signature of 'get' method does not\n        # match with the signature of super class's (BaseHandler) 'get' method,\n        # and this happens because all handler methods in the main codebase have\n        # decorators which modify the function signature accordingly, but these\n        # methods in base_test.py do not.\n        def get(self) -> None:  # type: ignore[override]\n            assert self.normalized_request is not None\n            iframe_restriction = self.normalized_request.get('iframe_restriction')\n            self.render_template(\n                'oppia-root.mainpage.html',\n                iframe_restriction=iframe_restriction)\n\n    def setUp(self) -> None:\n        super(IframeRestrictionTests, self).setUp()\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        # Modify the testapp to use the mock handler.\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock', self.MockHandlerForTestingPageIframing,\n                name='MockHandlerForTestingPageIframing')],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_responses_with_valid_iframe_restriction(self) -> None:\n        self.login(self.OWNER_EMAIL)\n        self.get_html_response('/mock')\n\n        response = self.get_html_response(\n            '/mock', params={'iframe_restriction': 'DENY'})\n        self.assertEqual(response.headers['X-Frame-Options'], 'DENY')\n\n        response = self.get_html_response(\n            '/mock', params={'iframe_restriction': 'SAMEORIGIN'})\n        self.assertEqual(response.headers['X-Frame-Options'], 'SAMEORIGIN')\n\n        self.logout()\n\n    def test_responses_with_invalid_iframe_restriction(self) -> None:\n        self.login(self.OWNER_EMAIL)\n        self.get_html_response(\n            '/mock', params={\n                'iframe_restriction': 'invalid_iframe_restriction'},\n            expected_status_int=500)\n        self.logout()\n\n\nclass SignUpTests(test_utils.GenericTestBase):\n\n    def test_error_is_raised_on_opening_new_tab_during_signup(self) -> None:\n        \"\"\"Test that error is raised if user opens a new tab\n        during signup.\n        \"\"\"\n        self.login('abc@example.com')\n        self.get_html_response(feconf.SIGNUP_URL + '?return_url=/')\n        csrf_token = self.get_new_csrf_token()\n\n        response = self.get_html_response('/about', expected_status_int=302)\n        self.assertIn('logout', response.location)\n        self.logout()\n\n        response = self.post_json(\n            feconf.SIGNUP_DATA_URL, {\n                'username': 'abc',\n                'agreed_to_terms': True,\n                'default_dashboard': constants.DASHBOARD_TYPE_LEARNER\n            }, csrf_token=csrf_token, expected_status_int=401,\n        )\n\n        self.assertEqual(response['error'], 'Registration session expired.')\n\n    def test_no_error_is_raised_on_opening_new_tab_after_signup(self) -> None:\n        \"\"\"Test that no error is raised if user opens a new tab\n        after signup.\n        \"\"\"\n        self.login('abc@example.com')\n        self.get_html_response(feconf.SIGNUP_URL + '?return_url=/')\n        csrf_token = self.get_new_csrf_token()\n        self.post_json(\n            feconf.SIGNUP_DATA_URL, {\n                'username': 'abc',\n                'agreed_to_terms': True,\n                'default_dashboard': constants.DASHBOARD_TYPE_LEARNER,\n                'can_receive_email_updates': (\n                    feconf.DEFAULT_EMAIL_UPDATES_PREFERENCE\n                )\n            }, csrf_token=csrf_token,\n        )\n\n        self.get_html_response('/community-library')\n\n    def test_error_is_raised_during_signup_using_invalid_token(self) -> None:\n        \"\"\"Test that error is raised if user tries to signup\n        using invalid CSRF token.\n        \"\"\"\n        self.login('abc@example.com')\n        self.get_html_response(feconf.SIGNUP_URL + '?return_url=/')\n\n        response = self.post_json(\n            feconf.SIGNUP_DATA_URL, {\n                'username': 'abc',\n                'agreed_to_terms': True,\n                'default_dashboard': constants.DASHBOARD_TYPE_LEARNER\n            }, csrf_token='invalid_token', expected_status_int=401,\n        )\n\n        self.assertEqual(response['error'],\n            'Your session has expired, and unfortunately your '\n            'changes cannot be saved. Please refresh the page.')\n\n\nclass CsrfTokenHandlerTests(test_utils.GenericTestBase):\n\n    def test_valid_token_is_returned(self) -> None:\n        \"\"\"Test that a valid CSRF token is returned by\n        the handler.\n        \"\"\"\n\n        response = self.get_json('/csrfhandler')\n        csrf_token = response['token']\n\n        self.assertTrue(base.CsrfTokenManager.is_csrf_token_valid(\n            None, csrf_token))\n\n\nclass CorrectMockVMHandlerNormalizedPayloadDict(TypedDict):\n    \"\"\"Type for the CorrectMockVMHandler's normalized_payload dictionary.\"\"\"\n\n    vm_id: str\n    signature: str\n    message: bytes\n\n\nclass OppiaMLVMHandlerTests(test_utils.GenericTestBase):\n    \"\"\"Unit tests for OppiaMLVMHandler class.\"\"\"\n\n    class IncorrectMockVMHandler(\n        base.OppiaMLVMHandler[Dict[str, str], Dict[str, str]]\n    ):\n        \"\"\"Derived VM Handler class with missing function implementation for\n        extract_request_message_vm_id_and_signature function.\n        \"\"\"\n\n        REQUIRE_PAYLOAD_CSRF_CHECK = False\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS = {\n            'POST': {\n                'vm_id': {'schema': {'type': 'basestring'}},\n                'signature': {'schema': {'type': 'basestring'}},\n                'message': {'schema': {'type': 'basestring'}},\n            }\n        }\n\n        @acl_decorators.is_from_oppia_ml\n        def post(self) -> None:\n            return self.render_json({})\n\n    class CorrectMockVMHandler(\n        base.OppiaMLVMHandler[\n            CorrectMockVMHandlerNormalizedPayloadDict,\n            Dict[str, str]\n        ]\n    ):\n        \"\"\"Derived VM Handler class with\n        extract_request_message_vm_id_and_signature function implementation.\n        \"\"\"\n\n        REQUIRE_PAYLOAD_CSRF_CHECK = False\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS = {\n            'POST': {\n                'vm_id': {'schema': {'type': 'basestring'}},\n                'signature': {'schema': {'type': 'basestring'}},\n                'message': {'schema': {'type': 'basestring'}},\n            }\n        }\n\n        def extract_request_message_vm_id_and_signature(\n            self\n        ) -> classifier_domain.OppiaMLAuthInfo:\n            \"\"\"Returns the message, vm_id and signature retrieved from the\n            incoming requests.\n            \"\"\"\n            assert self.normalized_payload is not None\n            signature = self.normalized_payload['signature']\n            vm_id = self.normalized_payload['vm_id']\n            message = self.normalized_payload['message']\n            return classifier_domain.OppiaMLAuthInfo(message, vm_id, signature)\n\n        @acl_decorators.is_from_oppia_ml\n        def post(self) -> None:\n            self.render_json({'job_id': 'new_job'})\n\n    def setUp(self) -> None:\n        super(OppiaMLVMHandlerTests, self).setUp()\n        self.mock_testapp = webtest.TestApp(webapp2.WSGIApplication([\n            webapp2.Route('/incorrectmock', self.IncorrectMockVMHandler),\n            webapp2.Route('/correctmock', self.CorrectMockVMHandler)],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_that_incorrect_derived_class_raises_exception(self) -> None:\n        payload = {}\n        payload['vm_id'] = feconf.DEFAULT_VM_ID\n        secret = feconf.DEFAULT_VM_SHARED_SECRET\n        payload['message'] = json.dumps('message')\n        payload['signature'] = classifier_services.generate_signature(\n            secret.encode('utf-8'),\n            payload['message'].encode('utf-8'),\n            payload['vm_id'])\n\n        with self.swap(self, 'testapp', self.mock_testapp):\n            self.post_json(\n                '/incorrectmock', payload, expected_status_int=500)\n\n    def test_that_correct_derived_class_does_not_raise_exception(self) -> None:\n        def _mock_get_secret(name: str) -> Optional[str]:\n            if name == 'VM_ID':\n                return 'vm_default'\n            elif name == 'SHARED_SECRET_KEY':\n                return '1a2b3c4e'\n            return None\n        swap_secret = self.swap_with_checks(\n            secrets_services,\n            'get_secret',\n            _mock_get_secret,\n            expected_args=[('VM_ID',), ('SHARED_SECRET_KEY',)],\n        )\n        payload = {}\n        payload['vm_id'] = feconf.DEFAULT_VM_ID\n        secret = feconf.DEFAULT_VM_SHARED_SECRET\n        payload['message'] = json.dumps('message')\n        payload['signature'] = classifier_services.generate_signature(\n            secret.encode('utf-8'),\n            payload['message'].encode('utf-8'),\n            payload['vm_id'])\n        with self.swap(self, 'testapp', self.mock_testapp), swap_secret:\n            self.post_json(\n                '/correctmock', payload, expected_status_int=200)\n\n\nclass SchemaValidationIntegrationTests(test_utils.GenericTestBase):\n    \"\"\"Tests all the functionality of SVS(Schema-Validation-System)\n    architecture.\n    \"\"\"\n    handler_class_names_with_no_schema: Final = (\n        handler_schema_constants.HANDLER_CLASS_NAMES_WITH_NO_SCHEMA)\n    wiki_page_link: Final = (\n        'https://github.com/oppia/oppia/wiki/Writing-schema-for-handler-args')\n\n    def _get_list_of_routes_which_need_schemas(\n        self\n    ) -> List[routes.RedirectRoute]:\n        \"\"\"This method iterates over all the routes and returns those routes\n        which need schemas.\n\n        Returns:\n            list(RedirectRoute). A list of RedirectRoute objects.\n        \"\"\"\n        return [route for route in main.URLS]\n\n    def test_every_handler_class_has_schema(self) -> None:\n        \"\"\"This test ensures that every child class of BaseHandler\n        has an associated schema.\n        \"\"\"\n        list_of_handlers_which_need_schemas = []\n        list_of_routes_which_need_schemas = (\n            self._get_list_of_routes_which_need_schemas())\n\n        for route in list_of_routes_which_need_schemas:\n            handler = route.handler\n\n            handler_class_name = handler.__name__\n            if handler_class_name in self.handler_class_names_with_no_schema:\n                continue\n\n            schema_written_for_request_methods = (\n                handler.HANDLER_ARGS_SCHEMAS is not None)\n            schema_written_for_url_path_args = (\n                handler.URL_PATH_ARGS_SCHEMAS is not None)\n            handler_has_schemas = (schema_written_for_request_methods and\n                schema_written_for_url_path_args)\n\n            if handler_has_schemas is False:\n                list_of_handlers_which_need_schemas.append(handler_class_name)\n\n        error_msg = (\n            'The following handlers have missing schemas: [ %s ].'\n            '\\nVisit %s to learn how to write schemas for handler args.' % (\n                ', '.join(\n                    list_of_handlers_which_need_schemas), self.wiki_page_link))\n\n        self.assertEqual(list_of_handlers_which_need_schemas, [], error_msg)\n\n    def test_schema_keys_exactly_match_with_url_path_elements(self) -> None:\n        \"\"\"This test ensures that schema keys in URL_PATH_ARGS_SCHEMAS must\n        exactly match with url path elements.\n        \"\"\"\n        handlers_with_missing_url_schema_keys = []\n        list_of_routes_which_need_schemas = (\n            self._get_list_of_routes_which_need_schemas())\n\n        for route in list_of_routes_which_need_schemas:\n            handler = route.handler\n\n            handler_class_name = handler.__name__\n            if handler_class_name in self.handler_class_names_with_no_schema:\n                continue\n            if handler.URL_PATH_ARGS_SCHEMAS is None:\n                continue\n\n            regex_pattern = r'<.*?>'\n            url_path_arg_names = []\n            for url_path_element in re.findall(regex_pattern, route.name):\n                url_path_keyword = url_path_element[1: -1]\n                # In some cases, url_path_arguments are defined with specific\n                # acceptable values, e.g: /<asset_type:(image|audio|thumbnail)>.\n                # So, to separate out the argument name from acceptable values,\n                # we have used ':' delimiter's index so that we can strip the\n                # part after ':'.\n                url_argument_delimiter_index = url_path_keyword.find(':')\n                url_path_arg_name = (\n                    url_path_keyword[:url_argument_delimiter_index]\n                    if url_argument_delimiter_index != -1 else url_path_keyword\n                )\n                url_path_arg_names.append(url_path_arg_name)\n            schema_keys = handler.URL_PATH_ARGS_SCHEMAS.keys()\n\n            missing_schema_keys = set(url_path_arg_names) - set(schema_keys)\n            if missing_schema_keys:\n                handlers_with_missing_url_schema_keys.append(handler_class_name)\n                self.log_line(\n                    'Missing keys in URL_PATH_ARGS_SCHEMAS for %s: %s.' % (\n                        handler_class_name, ', '.join(missing_schema_keys)))\n\n        error_msg = (\n            'Missing schema keys in URL_PATH_ARGS_SCHEMAS for [ %s ] classes.'\n            '\\nVisit %s to learn how to write schemas for handler args.' % (\n                ', '.join(handlers_with_missing_url_schema_keys),\n                    self.wiki_page_link))\n\n        self.assertEqual(handlers_with_missing_url_schema_keys, [], error_msg)\n\n    def test_schema_keys_exactly_match_with_request_methods_in_handlers(\n        self\n    ) -> None:\n        \"\"\"This test ensures that schema keys in HANDLER_ARGS_SCHEMAS must\n        exactly match with request arguments.\n        \"\"\"\n        handlers_with_missing_request_schema_keys = []\n        list_of_routes_which_need_schemas = (\n            self._get_list_of_routes_which_need_schemas())\n\n        for route in list_of_routes_which_need_schemas:\n            handler = route.handler\n\n            handler_class_name = handler.__name__\n            if handler_class_name in self.handler_class_names_with_no_schema:\n                continue\n            if handler.HANDLER_ARGS_SCHEMAS is None:\n                continue\n\n            handler_request_methods = []\n            if handler.get != base.BaseHandler.get:\n                handler_request_methods.append('GET')\n            if handler.put != base.BaseHandler.put:\n                handler_request_methods.append('PUT')\n            if handler.post != base.BaseHandler.post:\n                handler_request_methods.append('POST')\n            if handler.delete != base.BaseHandler.delete:\n                handler_request_methods.append('DELETE')\n            methods_defined_in_schema = handler.HANDLER_ARGS_SCHEMAS.keys()\n\n            missing_schema_keys = (\n                set(handler_request_methods) - set(methods_defined_in_schema))\n            if missing_schema_keys:\n                handlers_with_missing_request_schema_keys.append(\n                    handler_class_name)\n                self.log_line(\n                    'Missing keys in HANDLER_ARGS_SCHEMAS for %s: %s.' % (\n                        handler_class_name, ', '.join(missing_schema_keys)))\n\n        error_msg = (\n            'Missing schema keys in HANDLER_ARGS_SCHEMAS for [ %s ] classes.'\n            '\\nVisit %s to learn how to write schemas for handler args.' % (\n                ', '.join(handlers_with_missing_request_schema_keys),\n                    self.wiki_page_link))\n\n        self.assertEqual(\n            handlers_with_missing_request_schema_keys, [], error_msg)\n\n    def test_default_value_in_schema_conforms_with_schema(self) -> None:\n        \"\"\"This test checks whether the default_value provided in schema\n        conforms with the rest of the schema.\n        \"\"\"\n        handlers_with_non_conforming_default_schemas = []\n        list_of_routes_which_need_schemas = (\n            self._get_list_of_routes_which_need_schemas())\n\n        for route in list_of_routes_which_need_schemas:\n            handler = route.handler\n\n            handler_class_name = handler.__name__\n            if handler_class_name in self.handler_class_names_with_no_schema:\n                continue\n            if handler.HANDLER_ARGS_SCHEMAS is None:\n                continue\n\n            schemas = handler.HANDLER_ARGS_SCHEMAS\n            for request_method, request_method_schema in schemas.items():\n                for arg, schema in request_method_schema.items():\n                    if 'default_value' not in schema:\n                        continue\n                    default_value = {arg: schema['default_value']}\n                    default_value_schema = {arg: schema}\n\n                    _, errors = (\n                        payload_validator.validate_arguments_against_schema(\n                            default_value,\n                            default_value_schema,\n                            allowed_extra_args=True,\n                            allow_string_to_bool_conversion=False)\n                    )\n                    if len(errors) == 0:\n                        continue\n                    self.log_line(\n                        'Handler: %s, argument: %s, default_value '\n                            'validation failed.' % (handler_class_name, arg))\n\n                    if (handler_class_name not in\n                            handlers_with_non_conforming_default_schemas):\n                        handlers_with_non_conforming_default_schemas.append(\n                            handler_class_name)\n\n        error_msg = (\n            'Schema validation for default values failed for handlers: [ %s ].'\n            '\\nVisit %s to learn how to write schemas for handler args.' % (\n                ', '.join(handlers_with_non_conforming_default_schemas),\n                        self.wiki_page_link))\n\n        self.assertEqual(\n            handlers_with_non_conforming_default_schemas, [], error_msg)\n\n    def test_handlers_with_schemas_are_not_in_handler_schema_todo_list(\n        self\n    ) -> None:\n        \"\"\"This test ensures that the\n        HANDLER_CLASS_NAMES_WHICH_STILL_NEED_SCHEMAS list in handler_schema_constants\n        only contains handler class names which require schemas.\n        \"\"\"\n\n        list_of_handlers_to_be_removed = []\n        handler_names_which_require_schemas = (\n        handler_schema_constants.HANDLER_CLASS_NAMES_WHICH_STILL_NEED_SCHEMAS)\n        list_of_routes_which_need_schemas = (\n            self._get_list_of_routes_which_need_schemas())\n\n        for route in list_of_routes_which_need_schemas:\n            handler = route.handler\n\n            handler_class_name = handler.__name__\n            if handler_class_name not in handler_names_which_require_schemas:\n                continue\n\n            schema_written_for_request_methods = (\n                handler.HANDLER_ARGS_SCHEMAS is not None)\n            schema_written_for_url_path_args = (\n                handler.URL_PATH_ARGS_SCHEMAS is not None)\n            handler_has_schemas = (schema_written_for_request_methods and\n                schema_written_for_url_path_args)\n\n            if handler_has_schemas:\n                list_of_handlers_to_be_removed.append(handler_class_name)\n\n        error_msg = (\n            'Handlers to be removed from schema requiring list in '\n            'handler_schema_constants file: [ %s ].' % (\n                ', '.join(list_of_handlers_to_be_removed)))\n\n        self.assertEqual(list_of_handlers_to_be_removed, [], error_msg)\n\n\nclass SchemaValidationUrlArgsTests(test_utils.GenericTestBase):\n    \"\"\"Tests to check schema validation architecture for url path elements.\"\"\"\n\n    exp_id = 'exp_id'\n\n    class MockHandlerWithInvalidSchema(\n        base.BaseHandler[Dict[str, str], Dict[str, str]]\n    ):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n        URL_PATH_ARGS_SCHEMAS = {\n            'exploration_id': {\n                'schema': {\n                    'type': 'int'\n                }\n            }\n        }\n        HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n        @acl_decorators.can_play_exploration\n        def get(self, exploration_id: str) -> None:\n            self.render_json({'exploration_id': exploration_id})\n\n    class MockHandlerWithValidSchema(\n        base.BaseHandler[Dict[str, str], Dict[str, str]]\n    ):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n        URL_PATH_ARGS_SCHEMAS = {\n            'exploration_id': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            }\n        }\n        HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n        @acl_decorators.can_play_exploration\n        def get(self, exploration_id: str) -> None:\n            self.render_json({'exploration_id': exploration_id})\n\n    class MockHandlerWithMissingUrlPathSchema(\n        base.BaseHandler[Dict[str, str], Dict[str, str]]\n    ):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n        HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n        @acl_decorators.can_play_exploration\n        def get(self, exploration_id: str) -> None:\n            self.render_json({'exploration_id': exploration_id})\n\n    def setUp(self) -> None:\n        super(SchemaValidationUrlArgsTests, self).setUp()\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.mock_testapp1 = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_play_exploration/<exploration_id>',\n                    self.MockHandlerWithInvalidSchema)], debug=feconf.DEBUG))\n\n        self.mock_testapp2 = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_play_exploration/<exploration_id>',\n                    self.MockHandlerWithValidSchema)], debug=feconf.DEBUG))\n\n        self.mock_testapp3 = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_play_exploration/<exploration_id>',\n                    self.MockHandlerWithMissingUrlPathSchema)],\n                debug=feconf.DEBUG))\n\n        self.save_new_valid_exploration(self.exp_id, self.owner_id)\n\n    def test_cannot_access_exploration_with_incorrect_schema(self) -> None:\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp1):\n            response = self.get_json(\n                '/mock_play_exploration/%s' % self.exp_id,\n                    expected_status_int=400)\n            error_msg = (\n                'At \\'http://localhost/mock_play_exploration/exp_id\\' '\n                'these errors are happening:\\n'\n                'Schema validation for \\'exploration_id\\' failed: Could not '\n                'convert str to int: %s' % self.exp_id)\n            self.assertEqual(response['error'], error_msg)\n        self.logout()\n\n    def test_can_access_exploration_with_correct_schema(self) -> None:\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp2):\n            response = self.get_json(\n                '/mock_play_exploration/%s' % self.exp_id,\n                    expected_status_int=200)\n        self.logout()\n\n    def test_cannot_access_exploration_with_missing_schema(self) -> None:\n        self.login(self.OWNER_EMAIL)\n        error_msg = (\n            'Missing schema for url path args in '\n            'MockHandlerWithMissingUrlPathSchema handler class.')\n\n        with self.swap(self, 'testapp', self.mock_testapp3):\n            response = self.get_json('/mock_play_exploration/%s' % self.exp_id,\n                expected_status_int=500)\n            self.assertEqual(response['error'], error_msg)\n        self.logout()\n\n\nclass MockHandlerWithInvalidSchemaNormalizedRequestDict(TypedDict):\n    \"\"\"Type for the MockHandlerWithInvalidSchema's normalized_request\n    dictionary.\n    \"\"\"\n\n    exploration_id: int\n\n\nclass MockHandlerWithDefaultGetSchemaNormalizedRequestDict(TypedDict):\n    \"\"\"Type for the MockHandlerWithDefaultGetSchema's normalized_request\n    dictionary.\n    \"\"\"\n\n    exploration_id: str\n    apply_draft: bool\n\n\nclass MockHandlerWithDefaultPutSchemaNormalizedPayloadDict(TypedDict):\n    \"\"\"Type for the MockHandlerWithDefaultPutSchema's normalized_payload\n    dictionary.\n    \"\"\"\n\n    exploration_id: str\n\n\nclass SchemaValidationRequestArgsTests(test_utils.GenericTestBase):\n    \"\"\"Tests to check schema validation architecture for request args.\"\"\"\n\n    exp_id: Final = 'exp_id'\n\n    class MockHandlerWithInvalidSchema(\n        base.BaseHandler[\n            Dict[str, str],\n            MockHandlerWithInvalidSchemaNormalizedRequestDict\n        ]\n    ):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS = {\n            'GET': {\n                'exploration_id': {\n                    'schema': {\n                        'type': 'int'\n                    }\n                }\n            }\n        }\n\n        @acl_decorators.can_play_exploration\n        def get(self) -> None:\n            assert self.normalized_request is not None\n            exploration_id = self.normalized_request['exploration_id']\n            self.render_json({'exploration_id': exploration_id})\n\n    class MockHandlerWithMissingRequestSchema(\n        base.BaseHandler[Dict[str, str], Dict[str, str]]\n    ):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS: Dict[str, str] = {}\n\n        @acl_decorators.can_play_exploration\n        def get(self) -> None:\n            assert self.normalized_request is not None\n            exploration_id = self.normalized_request.get('exploration_id')\n            self.render_json({'exploration_id': exploration_id})\n\n    class MockHandlerWithDefaultGetSchema(\n        base.BaseHandler[\n            Dict[str, str],\n            MockHandlerWithDefaultGetSchemaNormalizedRequestDict\n        ]\n    ):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS = {\n            'GET': {\n                'exploration_id': {\n                    'schema': {\n                        'type': 'basestring'\n                    },\n                    'default_value': 'random_exp_id'\n                },\n                'apply_draft': {\n                    'schema': {\n                        'type': 'bool'\n                    },\n                    'default_value': False\n                }\n            }\n        }\n\n        # Here we use MyPy ignore because the signature of 'get' method does not\n        # match with the signature of super class's (BaseHandler) 'get' method,\n        # and this happens because all handler methods in the main codebase have\n        # decorators which modify the function signature accordingly, but these\n        # methods in base_test.py do not.\n        def get(self) -> None:  # type: ignore[override]\n            assert self.normalized_request is not None\n            exploration_id = self.normalized_request['exploration_id']\n            if exploration_id != 'random_exp_id':\n                raise self.InvalidInputException(\n                    'Expected exploration_id to be random_exp_id received %s'\n                    % exploration_id)\n            return self.render_json({'exploration_id': exploration_id})\n\n    class MockHandlerWithDefaultPutSchema(\n        base.BaseHandler[\n            MockHandlerWithDefaultPutSchemaNormalizedPayloadDict,\n            Dict[str, str]\n        ]\n    ):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS = {\n            'PUT': {\n                'exploration_id': {\n                    'schema': {\n                        'type': 'basestring'\n                    },\n                    'default_value': 'random_exp_id'\n                }\n            }\n        }\n\n        # Here we use MyPy ignore because the signature of 'put' method does\n        # not match with the signature of super class's (BaseHandler) 'put'\n        # method, and this happens because all handler methods in the main\n        # codebase have decorators which modify the function signature\n        # accordingly, but these methods in base_test.py do not.\n        def put(self) -> None:  # type: ignore[override]\n            assert self.normalized_payload is not None\n            exploration_id = self.normalized_payload['exploration_id']\n            if exploration_id != 'random_exp_id':\n                raise self.InvalidInputException(\n                    'Expected exploration_id to be random_exp_id received %s'\n                    % exploration_id)\n            self.render_json({'exploration_id': exploration_id})\n\n    def setUp(self) -> None:\n        super(SchemaValidationRequestArgsTests, self).setUp()\n        self.signup(self.OWNER_EMAIL, self.OWNER_USERNAME)\n        self.owner_id = self.get_user_id_from_email(self.OWNER_EMAIL)\n        self.mock_testapp1 = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_play_exploration',\n                    self.MockHandlerWithInvalidSchema)], debug=feconf.DEBUG))\n\n        self.mock_testapp2 = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_play_exploration',\n                    self.MockHandlerWithMissingRequestSchema)],\n                debug=feconf.DEBUG))\n\n        self.mock_testapp3 = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_play_exploration',\n                    self.MockHandlerWithDefaultGetSchema)], debug=feconf.DEBUG))\n\n        self.mock_testapp4 = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route(\n                '/mock_play_exploration',\n                    self.MockHandlerWithDefaultPutSchema)], debug=feconf.DEBUG))\n\n        self.save_new_valid_exploration(self.exp_id, self.owner_id)\n\n    def test_cannot_access_exploration_with_incorrect_schema(self) -> None:\n        self.login(self.OWNER_EMAIL)\n        with self.swap(self, 'testapp', self.mock_testapp1):\n            response = self.get_json(\n                '/mock_play_exploration?exploration_id=%s' % self.exp_id,\n                    expected_status_int=400)\n            error_msg = (\n                'Schema validation for \\'exploration_id\\' failed: Could not '\n                'convert str to int: %s' % self.exp_id)\n            self.assertEqual(response['error'], error_msg)\n        self.logout()\n\n    def test_cannot_access_exploration_with_missing_schema(self) -> None:\n        self.login(self.OWNER_EMAIL)\n        error_msg = (\n            'Missing schema for GET method in '\n            'MockHandlerWithMissingRequestSchema handler class.')\n\n        with self.swap(self, 'testapp', self.mock_testapp2):\n            response = self.get_json(\n                '/mock_play_exploration?exploration_id=%s' % self.exp_id,\n                    expected_status_int=500)\n            self.assertEqual(response['error'], error_msg)\n        self.logout()\n\n    def test_can_access_exploration_with_default_value_in_schema(self) -> None:\n        self.login(self.OWNER_EMAIL)\n\n        with self.swap(self, 'testapp', self.mock_testapp3):\n            self.get_json('/mock_play_exploration?apply_draft=true')\n\n        csrf_token = self.get_new_csrf_token()\n        with self.swap(self, 'testapp', self.mock_testapp4):\n            self.put_json('/mock_play_exploration', {}, csrf_token=csrf_token)\n        self.logout()\n\n\nclass HandlerClassWithSchemaInStillNeedsSchemaListRaiseErrorTest(\n        test_utils.GenericTestBase):\n    \"\"\"This test ensures that, InternalServerError is raised for\n    the request with handler class which has schema but class name is still in\n    HANDLER_CLASS_NAMES_WHICH_STILL_NEED_SCHEMAS.\n    \"\"\"\n\n    class MockHandler(base.BaseHandler[Dict[str, str], Dict[str, str]]):\n        \"\"\"Mock handler with schema.\"\"\"\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS = {\n            'POST': {\n                'arg_a': {\n                    'schema': {\n                        'type': 'basestring'\n                    }\n                }\n            }\n        }\n\n        # Here we use MyPy ignore because the signature of 'post' method does\n        # not match with the signature of super class's (BaseHandler) 'post'\n        # method, and this happens because all handler methods in the main\n        # codebase have decorators which modify the function signature\n        # accordingly, but these methods in base_test.py do not.\n        def post(self) -> None:  # type: ignore[override]\n            self.render_json({})\n\n    def setUp(self) -> None:\n        super().setUp()\n        user_id = user_services.get_user_id_from_username('learneruser')\n        self.csrf_token = base.CsrfTokenManager.create_csrf_token(user_id)\n        self.payload = {'arg_a': 'val'}\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock', self.MockHandler, name='MockHandler')],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_post_request_raise_internal_server_error(self) -> None:\n        test_app_ctx = self.swap(self, 'testapp', self.testapp)\n        handler_class_still_needs_schema_list_ctx = self.swap(\n            handler_schema_constants, 'HANDLER_CLASS_NAMES_WITH_NO_SCHEMA',\n            ['MockHandler'])\n        with test_app_ctx, handler_class_still_needs_schema_list_ctx:\n            self.post_json(\n                '/mock', self.payload, csrf_token=self.csrf_token,\n                expected_status_int=500)\n\n\nclass HeaderRequestsTests(test_utils.GenericTestBase):\n    \"\"\"Tests to check header requests.\"\"\"\n\n    class MockHandler(base.BaseHandler[Dict[str, str], Dict[str, str]]):\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n        URL_PATH_ARGS_SCHEMAS = {\n            'entity_id': {\n                'schema': {\n                    'type': 'int'\n                }\n            }\n        }\n        HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {'GET': {}}\n\n        # Here we use MyPy ignore because the signature of 'get' method does not\n        # match with the signature of super class's (BaseHandler) 'get' method,\n        # and this happens because all handler methods in the main codebase have\n        # decorators which modify the function signature accordingly, but these\n        # methods in base_test.py do not.\n        def get(self, entity_id: str) -> None:  # type: ignore[override]\n            self.render_json({'entity_id': entity_id})\n\n    def setUp(self) -> None:\n        super().setUp()\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication([\n            webapp2.Route(\n                '/mock/<entity_id>', self.MockHandler, name='MockHandler')],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_head_request_with_invalid_url_args_raises(self) -> None:\n        with self.swap(self, 'testapp', self.testapp):\n            self.testapp.head('/mock/not_int', status=400)\n\n    def test_valid_head_request_returns_only_headers(self) -> None:\n        with self.swap(self, 'testapp', self.testapp):\n            response = self.testapp.head('/mock/234', status=200)\n            self.assertEqual(response.body, b'')\n            self.assertIsNotNone(response.headers)\n\n\nclass RequestMethodNotInHandlerClassDoNotRaiseMissingSchemaErrorTest(\n        test_utils.GenericTestBase):\n    \"\"\"This test ensures that, NotImplementedError should not be raised for\n    the request method which are not present in the handler class.\n    \"\"\"\n\n    class MockHandler(base.BaseHandler[Dict[str, str], Dict[str, str]]):\n        \"\"\"Mock handler with no get method.\n        \"\"\"\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS: Dict[str, str] = {}\n        GET_HANDLER_ERROR_RETURN_TYPE = feconf.HANDLER_TYPE_JSON\n\n    def setUp(self) -> None:\n        super(RequestMethodNotInHandlerClassDoNotRaiseMissingSchemaErrorTest,\n            self).setUp()\n\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock', self.MockHandler, name='MockHandler')],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_get_request_do_not_raise_notimplemented_error(self) -> None:\n        with self.swap(self, 'testapp', self.testapp):\n            self.get_json('/mock', expected_status_int=404)\n\n\nclass MockHandlerNormalizedRequestDict(TypedDict):\n    \"\"\"Type for the MockHandler's normalized_payload\n    dictionary.\n    \"\"\"\n\n    arg_b: str\n    arg_a: str\n\n\nclass HandlerClassWithBothRequestAndPayloadTest(test_utils.GenericTestBase):\n    \"\"\"This test class ensures that SVS architecture validates both request args\n    and payload args if they are present in a single request method.\"\"\"\n\n    class MockHandler(\n        base.BaseHandler[\n            MockHandlerNormalizedRequestDict, Dict[str, str]\n        ]\n    ):\n        \"\"\"Fake page for testing autoescaping.\"\"\"\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS = {\n            'POST': {\n                'arg_b': {\n                    'schema': {\n                        'type': 'basestring'\n                    }\n                },\n                'arg_a': {\n                    'schema': {\n                        'type': 'basestring'\n                    }\n                }\n            }\n        }\n\n        # Here we use MyPy ignore because the signature of 'post' method does\n        # not match with the signature of super class's (BaseHandler) 'post'\n        # method, and this happens because all handler methods in the main\n        # codebase have decorators which modify the function signature\n        # accordingly, but these methods in base_test.py do not.\n        def post(self) -> None:  # type: ignore[override]\n            \"\"\"Handles POST requests. This request method contains both type\n            of args, i.e., request args as well as payload args.\n            \"\"\"\n            assert self.normalized_request is not None\n            # arg_a = self.request.get('arg_a') is not used, since we\n            # intend to use normalized value.\n            arg_a = self.normalized_request.get('arg_a')\n\n            # arg_b = self.payload.get('arg_b') is not used, since we\n            # intend to use normalized value.\n            arg_b = self.normalized_request.get('arg_b')\n\n            self.render_json({'arg_a': arg_a, 'arg_b': arg_b})\n\n    def setUp(self) -> None:\n        super(HandlerClassWithBothRequestAndPayloadTest, self).setUp()\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock', self.MockHandler, name='MockHandler')],\n            debug=feconf.DEBUG,\n        ))\n        self.payload = {'arg_b': 'arg_in_payload'}\n        user_id = user_services.get_user_id_from_username('learneruser')\n        self.csrf_token = base.CsrfTokenManager.create_csrf_token(user_id)\n\n    def test_both_args_in_post_request(self) -> None:\n        with self.swap(self, 'testapp', self.testapp):\n            self.post_json(\n                '/mock?arg_a=arg_in_request', self.payload,\n                csrf_token=self.csrf_token)\n\n    def test_post_request_with_invalid_source_raise_error(self) -> None:\n        with self.swap(self, 'testapp', self.testapp):\n            self.post_json(\n                '/mock?arg_a=arg_in_request', self.payload,\n                csrf_token=self.csrf_token, source='fake_url',\n                expected_status_int=400)\n\n    def test_post_request_with_valid_source_do_not_raise_error(self) -> None:\n        with self.swap(self, 'testapp', self.testapp):\n            self.post_json(\n                '/mock?arg_a=arg_in_request', self.payload,\n                csrf_token=self.csrf_token,\n                source='http://localhost:8181/sample_url/')\n\n\nclass MockUploadHandlerNormalizedPayloadDict(TypedDict):\n    \"\"\"Type for the MockUploadHandler's normalized_payload\n    dictionary.\n    \"\"\"\n\n    filename: str\n    filename_prefix: Optional[str]\n\n\nclass MockUploadHandlerNormalizedRequestDict(TypedDict):\n    \"\"\"Type for the MockUploadHandler's normalized_request\n    dictionary.\n    \"\"\"\n\n    image: bytes\n\n\nclass ImageUploadHandlerTest(test_utils.GenericTestBase):\n    \"\"\"This test class ensures that schema validation is done successfully\n    for handlers which upload image files.\n    \"\"\"\n\n    TEST_LEARNER_EMAIL: Final = 'test.learner@example.com'\n    TEST_LEARNER_USERNAME: Final = 'testlearneruser'\n\n    class MockUploadHandler(\n        base.BaseHandler[\n            MockUploadHandlerNormalizedPayloadDict,\n            MockUploadHandlerNormalizedRequestDict\n        ]\n    ):\n        \"\"\"Handles image uploads.\"\"\"\n        URL_PATH_ARGS_SCHEMAS = {\n            'entity_type': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            },\n            'entity_id': {\n                'schema': {\n                    'type': 'basestring'\n                }\n            }\n        }\n        HANDLER_ARGS_SCHEMAS = {\n            'POST': {\n                'image': {\n                    'schema': {\n                        'type': 'basestring'\n                    }\n                },\n                'filename': {\n                    'schema': {\n                        'type': 'basestring'\n                    }\n                },\n                'filename_prefix': {\n                    'schema': {\n                        'type': 'basestring'\n                    },\n                    'default_value': None\n                }\n            }\n        }\n\n        # Here we use MyPy ignore because the signature of 'post' method does\n        # not match with the signature of super class's (BaseHandler) 'post'\n        # method, and this happens because all handler methods in the main\n        # codebase have decorators which modify the function signature\n        # accordingly, but these methods in base_test.py do not.\n        def post(self, entity_type: str, entity_id: str) -> None:  # type: ignore[override]\n            \"\"\"Saves an image uploaded by a content creator.\"\"\"\n            assert self.normalized_payload is not None\n            assert self.normalized_request is not None\n            raw = self.normalized_request.get('image')\n            filename = self.normalized_payload.get('filename')\n            filename_prefix = self.normalized_payload.get('filename_prefix')\n\n            self.render_json({'filename': filename})\n\n    def setUp(self) -> None:\n        super(ImageUploadHandlerTest, self).setUp()\n        self.signup(self.TEST_LEARNER_EMAIL, self.TEST_LEARNER_USERNAME)\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock_upload/<entity_type>/<entity_id>',\n            self.MockUploadHandler, name='MockUploadHandler')],\n            debug=feconf.DEBUG,\n        ))\n\n        self.system_user = user_services.get_system_user()\n        exp_services.load_demo('0')\n\n        rights_manager.release_ownership_of_exploration(\n            self.system_user, '0')\n\n    def test_image_upload_and_download(self) -> None:\n        \"\"\"Test image uploading and downloading.\"\"\"\n        self.login(self.TEST_LEARNER_EMAIL)\n        user_id = user_services.get_user_id_from_username('testlearneruser')\n        csrf_token = base.CsrfTokenManager.create_csrf_token(user_id)\n\n        with utils.open_file(\n            os.path.join(feconf.TESTS_DATA_DIR, 'img.png'),\n            'rb', encoding=None\n        ) as f:\n            raw_image = f.read()\n        with self.swap(self, 'testapp', self.testapp):\n            response_dict = self.post_json(\n                '/mock_upload/exploration/0', {'filename': 'test.png'},\n                csrf_token=csrf_token,\n                upload_files=[('image', 'unused_filename', raw_image)]\n            )\n            filename = response_dict['filename']\n        self.logout()\n\n\nclass UrlPathNormalizationTest(test_utils.GenericTestBase):\n    \"\"\"Tests that ensure url path arguments are normalized\"\"\"\n\n    class MockHandler(base.BaseHandler[Dict[str, str], Dict[str, str]]):\n        URL_PATH_ARGS_SCHEMAS = {\n            'mock_list': {\n                'schema': {\n                    'type': 'custom',\n                    'obj_type': 'JsonEncodedInString'\n                }\n            },\n            'mock_int': {\n                'schema': {\n                    'type': 'int'\n                }\n            }\n        }\n        HANDLER_ARGS_SCHEMAS: Dict[str, Dict[str, str]] = {\n            'GET': {}\n        }\n\n        # Here we use MyPy ignore because the signature of 'get' method does not\n        # match with the signature of super class's (BaseHandler) 'get' method,\n        # and this happens because all handler methods in the main codebase have\n        # decorators which modify the function signature accordingly, but these\n        # methods in base_test.py do not.\n        def get(self, mock_list: List[str], mock_int: int) -> None:  # type: ignore[override]\n            if not isinstance(mock_list, list):\n                raise self.InvalidInputException(\n                    'Expected arg mock_list to be a list. Was type %s' %\n                    type(mock_list))\n            if not isinstance(mock_int, int):\n                raise self.InvalidInputException(\n                    'Expected arg mock_int to be a int. Was type %s' %\n                    type(mock_int))\n            self.render_json({'mock_list': mock_list, 'mock_int': mock_int})\n\n    def setUp(self) -> None:\n        super(UrlPathNormalizationTest, self).setUp()\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication(\n            [webapp2.Route('/mock_normalization/<mock_int>/<mock_list>',\n            self.MockHandler, name='MockHandler')],\n            debug=feconf.DEBUG,\n        ))\n\n    def test_url_path_arg_normalization_is_successful(self) -> None:\n        list_string = '[\"id1\", \"id2\", \"id3\"]'\n        int_string = '1'\n\n        with self.swap(self, 'testapp', self.testapp):\n            self.get_json(\n                '/mock_normalization/%s/%s' % (int_string, list_string),\n                expected_status_int=200)\n\n\nclass RaiseErrorOnGetTest(test_utils.GenericTestBase):\n    \"\"\"This test class is to ensure handlers with schema raises error\n    when they use self.request or self.payload.\"\"\"\n\n    class MockHandlerWithSchema(\n        base.BaseHandler[Dict[str, str], Dict[str, str]]\n    ):\n        \"\"\"Mock handler with schema.\"\"\"\n        URL_PATH_ARGS_SCHEMAS: Dict[str, str] = {}\n        HANDLER_ARGS_SCHEMAS = {\n            'POST': {\n                'mock_int': {\n                    'schema': {\n                        'type': 'int'\n                    }\n                }\n            }\n        }\n\n        # Here we use MyPy ignore because the signature of 'post' method does\n        # not match with the signature of super class's (BaseHandler) 'post'\n        # method, and this happens because all handler methods in the main\n        # codebase have decorators which modify the function signature\n        # accordingly, but these methods in base_test.py do not.\n        def post(self) -> None:  # type: ignore[override]\n            self.payload.get('mock_int')\n            return self.render_json({})\n\n    class MockHandlerWithoutSchema(\n        base.BaseHandler[Dict[str, str], Dict[str, str]]\n    ):\n        \"\"\"Mock handler without schema.\"\"\"\n\n        # Here we use MyPy ignore because the signature of 'post' method does\n        # not match with the signature of super class's (BaseHandler) 'post'\n        # method, and this happens because all handler methods in the main\n        # codebase have decorators which modify the function signature\n        # accordingly, but these methods in base_test.py do not.\n        def post(self) -> None:  # type: ignore[override]\n            self.payload.get('mock_int')\n            return self.render_json({})\n\n    def setUp(self) -> None:\n        super().setUp()\n        user_id = user_services.get_user_id_from_username('learneruser')\n        self.csrf_token = base.CsrfTokenManager.create_csrf_token(user_id)\n        self.payload = {'mock_int': 1}\n        self.testapp = webtest.TestApp(webapp2.WSGIApplication([\n            webapp2.Route('/mock_with_schema', self.MockHandlerWithSchema),\n            webapp2.Route(\n                '/mock_without_schema', self.MockHandlerWithoutSchema),\n        ], debug=feconf.DEBUG))\n\n    def test_object_which_raises_error_on_get(self) -> None:\n        error_message = 'error_message'\n        object_that_raises_error_on_get = base.RaiseErrorOnGet(error_message)\n        with self.assertRaisesRegex(ValueError, error_message):\n            object_that_raises_error_on_get.get('key')\n\n    def test_request_with_schema_using_payload_or_request_attr_raise_error(\n        self\n    ) -> None:\n        with self.swap(self, 'testapp', self.testapp):\n            self.post_json(\n                '/mock_with_schema', self.payload, csrf_token=self.csrf_token,\n                expected_status_int=500)\n\n    def test_request_without_schema_using_payload_or_request_attr_raise_no_err(\n        self\n    ) -> None:\n        test_app_ctx = self.swap(self, 'testapp', self.testapp)\n        handler_class_still_needs_schema_list_ctx = self.swap(\n            handler_schema_constants, 'HANDLER_CLASS_NAMES_WITH_NO_SCHEMA',\n            ['MockHandlerWithoutSchema'])\n        with test_app_ctx, handler_class_still_needs_schema_list_ctx:\n            self.post_json(\n                '/mock_without_schema', self.payload, csrf_token=self.csrf_token,\n                expected_status_int=200)\n"], "filenames": ["core/controllers/base.py", "core/controllers/base_test.py"], "buggy_code_start_loc": [905, 746], "buggy_code_end_loc": [986, 747], "fixing_code_start_loc": [905, 746], "fixing_code_end_loc": [1008, 747], "type": "CWE-203", "message": "Oppia is an online learning platform. When comparing a received CSRF token against the expected token, Oppia uses the string equality operator (`==`), which is not safe against timing attacks. By repeatedly submitting invalid tokens, an attacker can brute-force the expected CSRF token character by character. Once they have recovered the token, they can then submit a forged request on behalf of a logged-in user and execute privileged actions on that user's behalf. In particular the function to validate received CSRF tokens is at `oppia.core.controllers.base.CsrfTokenManager.is_csrf_token_valid`. An attacker who can lure a logged-in Oppia user to a malicious website can perform any change on Oppia that the user is authorized to do, including changing profile information; creating, deleting, and changing explorations; etc. Note that the attacker cannot change a user's login credentials. An attack would need to complete within 1 second because every second, the time used in computing the token changes. This issue has been addressed in commit `b89bf80837` which has been included in release `3.3.2-hotfix-2`. Users are advised to upgrade. There are no known workarounds for this vulnerability.", "other": {"cve": {"id": "CVE-2023-40021", "sourceIdentifier": "security-advisories@github.com", "published": "2023-08-16T21:15:09.880", "lastModified": "2023-08-25T20:08:17.657", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Oppia is an online learning platform. When comparing a received CSRF token against the expected token, Oppia uses the string equality operator (`==`), which is not safe against timing attacks. By repeatedly submitting invalid tokens, an attacker can brute-force the expected CSRF token character by character. Once they have recovered the token, they can then submit a forged request on behalf of a logged-in user and execute privileged actions on that user's behalf. In particular the function to validate received CSRF tokens is at `oppia.core.controllers.base.CsrfTokenManager.is_csrf_token_valid`. An attacker who can lure a logged-in Oppia user to a malicious website can perform any change on Oppia that the user is authorized to do, including changing profile information; creating, deleting, and changing explorations; etc. Note that the attacker cannot change a user's login credentials. An attack would need to complete within 1 second because every second, the time used in computing the token changes. This issue has been addressed in commit `b89bf80837` which has been included in release `3.3.2-hotfix-2`. Users are advised to upgrade. There are no known workarounds for this vulnerability."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:R/S:U/C:N/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 5.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.6, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-203"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-203"}, {"lang": "en", "value": "CWE-208"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:oppia:oppia:*:*:*:*:*:*:*:*", "versionStartIncluding": "1.1.0", "versionEndExcluding": "3.3.2", "matchCriteriaId": "87F65B5D-6454-4E3C-A7A5-F1FEEC6DC78C"}, {"vulnerable": true, "criteria": "cpe:2.3:a:oppia:oppia:3.3.2:-:*:*:*:*:*:*", "matchCriteriaId": "7B0060B6-6E1F-4B0F-8A6B-3437450C94C3"}]}]}], "references": [{"url": "https://github.com/oppia/oppia/blob/3a05c3558a292f3db9e658e60e708c266c003fd0/core/controllers/base.py#L964-L990", "source": "security-advisories@github.com", "tags": ["Product"]}, {"url": "https://github.com/oppia/oppia/commit/b89bf808378c1236874b5797a7bda32c77b4af23", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/oppia/oppia/pull/18769", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/oppia/oppia/security/advisories/GHSA-49jp-pjc3-2532", "source": "security-advisories@github.com", "tags": ["Exploit", "Vendor Advisory"]}]}, "github_commit_url": "https://github.com/oppia/oppia/commit/b89bf808378c1236874b5797a7bda32c77b4af23"}}