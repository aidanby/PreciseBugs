{"buggy_code": ["/* radare - LGPL - Copyright 2022 - jmaselbas */\n\n#include \"kvx.h\"\n#include \"kvx-reg.h\"\n#include <stdio.h>\n#include <string.h>\n#include <r_anal.h>\n\nconst opc_t kv3_opc[] = {\n#include \"kv3.opc\"\n};\n#define KV3_OPC_COUNT R_ARRAY_SIZE(kv3_opc)\n\nint kvx_instr_print(insn_t *insn, ut64 offset, char *buf, size_t len) {\n\tconst char *fmt = insn->opc->format;\n\toperand_t opr;\n\tint i = 0;\n\tint n, w;\n\n\t/* print mnemonic */\n\tw = snprintf (buf, len, \"%s%s\", insn->opc->mnemonic, fmt[0] != '\\0' ? \" \" : \"\");\n\tn = R_MIN (w, len);\n\n\t/* append operands */\n\twhile (n < (len - 1) && *fmt != '\\0') {\n\t\tif (fmt[0] == '%' && fmt[1] == 's') {\n\t\t\t/* decode each operand in order */\n\t\t\tif (i < R_ARRAY_SIZE (insn->opc->decode) && insn->opc->decode[i]) {\n\t\t\t\tinsn->opc->decode[i] (&opr, insn->value);\n\t\t\t\tif (opr.type == KVX_OPER_TYPE_IMM)\n\t\t\t\t\tw = snprintf (buf + n, len - n, \"0x%\" PFMT64x, (ut64)opr.imm);\n\t\t\t\telse if (opr.type == KVX_OPER_TYPE_OFF)\n\t\t\t\t\tw = snprintf (buf + n, len - n, \"0x%\" PFMT64x, (ut64)opr.imm + offset);\n\t\t\t\telse if (opr.type == KVX_OPER_TYPE_REG)\n\t\t\t\t\tw = snprintf (buf + n, len - n, \"%s\", opr.reg);\n\t\t\t\telse\n\t\t\t\t\tw = 0;\n\t\t\t\tn += R_MIN (w, len - n);\n\n\t\t\t\ti++;\n\t\t\t\t/* advance after the format '%s' */\n\t\t\t\tfmt += 2;\n\t\t\t}\n\t\t} else {\n\t\t\t/* simple copy */\n\t\t\tbuf[n] = fmt[0];\n\t\t\tfmt++;\n\t\t\tn++;\n\t\t}\n\t}\n\tif (!insn->rem) {\n\t\tw = snprintf (buf + n, len - n, \" ;;\");\n\t\tn += R_MIN (w, len - n);\n\t}\n\tbuf[n] = 0;\n\n\treturn n;\n}\n\nut64 kvx_instr_jump(insn_t *insn, ut64 offset) {\n\toperand_t opr;\n\tint i;\n\n\tfor (i = 0; i < 4 && insn->opc->decode[i]; i++) {\n\t\tinsn->opc->decode[i] (&opr, insn->value);\n\t\tif (opr.type == KVX_OPER_TYPE_OFF) {\n\t\t\treturn opr.imm + offset;\n\t\t}\n\t}\n\treturn offset;\n}\n\nstatic const int immx_to_bundle_issue[] = {\n\t[IMMX_ISSUE_ALU0] = BUNDLE_ISSUE_ALU0,\n\t[IMMX_ISSUE_ALU1] = BUNDLE_ISSUE_ALU1,\n\t[IMMX_ISSUE_MAU] = BUNDLE_ISSUE_MAU,\n\t[IMMX_ISSUE_LSU] = BUNDLE_ISSUE_LSU,\n};\n\nstatic inline int kvx_steering(ut32 x) {\n\treturn (((x) & 0x60000000) >> 29);\n}\n\nstatic inline int kvx_extension(ut32 x) {\n\treturn (((x) & 0x18000000) >> 27);\n}\n\nstatic inline int kvx_has_parallel_bit(ut32 x) {\n\treturn (((x) & 0x80000000) == 0x80000000);\n}\n\nstatic inline int kvx_is_tca_opcode(ut32 x) {\n\tunsigned major = ((x)>>24) & 0x1F;\n\treturn (major > 1) && (major < 8);\n}\n\nstatic inline int kvx_is_nop_opcode(ut32 x) {\n\treturn ((x)<<1) == 0xFFFFFFFE;\n}\n\nstatic inline int kvx_opc_match(const opc_t *opc, insn_t *insn) {\n\tint i;\n\n\tif (opc->len != insn->len)\n\t\treturn 0;\n\n\tfor (i = 0; i < insn->len; i++) {\n\t\tif ((insn->value[i] & opc->mask[i]) != opc->value[i])\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int disassemble_bundle(bundle_t *bundle, const ut32 *words, int count) {\n\tbool used[KVX_MAX_BUNDLE_ISSUE] = {0};\n\tinsn_t *insn;\n\tut32 word;\n\tint issue, immx, extension;\n\tint bcu = 0;\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\textension = 0;\n\t\tword = words[i];\n\t\tswitch (kvx_steering (word)) {\n\t\tcase STEERING_BCU:\n\t\t\tif (i == 0 && !kvx_is_tca_opcode (word)) {\n\t\t\t\tbcu = 1;\n\t\t\t\tissue = BUNDLE_ISSUE_BCU;\n\t\t\t} else if ((i == 0 && kvx_is_tca_opcode (word))\n\t\t\t\t|| (i == 1 && bcu && kvx_is_tca_opcode (word))) {\n\t\t\t\tissue = BUNDLE_ISSUE_TCA;\n\t\t\t} else {\n\t\t\t\timmx = kvx_extension (word);\n\t\t\t\tissue = immx_to_bundle_issue[immx];\n\t\t\t\textension = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase STEERING_ALU:\n\t\t\tif (!used[BUNDLE_ISSUE_ALU0]) {\n\t\t\t\tissue = BUNDLE_ISSUE_ALU0;\n\t\t\t} else if (!used[BUNDLE_ISSUE_ALU1]) {\n\t\t\t\tissue = BUNDLE_ISSUE_ALU1;\n\t\t\t} else if (!used[BUNDLE_ISSUE_MAU]) {\n\t\t\t\tissue = BUNDLE_ISSUE_MAU;\n\t\t\t} else if (!used[BUNDLE_ISSUE_LSU]) {\n\t\t\t\tissue = BUNDLE_ISSUE_LSU;\n\t\t\t} else {\n\t\t\t\t/* too many ALUs */\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase STEERING_MAU:\n\t\t\tissue = BUNDLE_ISSUE_MAU;\n\t\t\tbreak;\n\t\tcase STEERING_LSU:\n\t\t\tissue = BUNDLE_ISSUE_LSU;\n\t\t\tbreak;\n\t\t}\n\n\t\tinsn = &bundle->issue[issue];\n\n\t\tif (!used[issue]) {\n\t\t\tused[issue] = 1;\n\t\t\tinsn->len = 0;\n\t\t} else if (!extension && used[issue]) {\n\t\t\t/* issue already used */\n\t\t\tgoto error;\n\t\t} else if (extension && !used[issue]) {\n\t\t\t/* missing issue */\n\t\t\tgoto error;\n\t\t}\n\t\tif (insn->len == KVX_MAX_SYLLABLES) {\n\t\t\t/* too many syllables */\n\t\t\tgoto error;\n\t\t}\n\t\tinsn->value[insn->len] = word;\n\t\tinsn->len++;\n\t}\n\n\tfor (issue = 0; issue < KVX_MAX_BUNDLE_ISSUE; issue++) {\n\t\tif (!used[issue])\n\t\t\tcontinue;\n\t\tinsn = &bundle->issue[issue];\n\n\t\tinsn->opc = NULL;\n\t\tfor (i = 0; i < KV3_OPC_COUNT; i++) {\n\t\t\tif (kvx_opc_match (&kv3_opc[i], insn)) {\n\t\t\t\tinsn->opc = &kv3_opc[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcount = 0;\n\tfor (issue = KVX_MAX_BUNDLE_ISSUE - 1; issue >= 0; issue--) {\n\t\tif (!used[issue])\n\t\t\tcontinue;\n\t\tinsn = &bundle->issue[issue];\n\t\tinsn->rem = count++;\n\t}\n\n\treturn 0;\nerror:\n\treturn -1;\n}\n\nstatic int read_bundle(ut32 *words, const ut8 *buf, int len) {\n\tint count = 0;\n\tut32 word;\n\n\twhile (len >= sizeof (ut32) && count < KVX_MAX_BUNDLE_WORDS) {\n\t\tword = r_read_le32 (buf);\n\t\twords[count] = word;\n\t\tcount++;\n\n\t\tif (!kvx_has_parallel_bit (word)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf += sizeof (ut32);\n\t\tlen -= sizeof (ut32);\n\t}\n\n\tif (count == KVX_MAX_BUNDLE_WORDS && kvx_has_parallel_bit (word)) {\n\t\t/* this is wrong */\n\t}\n\n\treturn count;\n}\n\ninsn_t *kvx_next_insn(bundle_t *bundle, ut64 addr, const ut8 *buf, int len) {\n\tut32 words[KVX_MAX_BUNDLE_WORDS];\n\tut64 start;\n\tint count, issue = KVX_MAX_BUNDLE_ISSUE;\n\tint ret;\n\n\tif (bundle->addr <= addr && addr < (bundle->addr + bundle->size)) {\n\t\tstart = bundle->addr;\n\t\tissue = 0;\n\t\tfor (issue = 0; issue < KVX_MAX_BUNDLE_ISSUE; issue++) {\n\t\t\tif (addr == start) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart += bundle->issue[issue].len * sizeof (ut32);\n\t\t}\n\t\twhile (issue < KVX_MAX_BUNDLE_ISSUE && bundle->issue[issue].len == 0) {\n\t\t\tissue++;\n\t\t}\n\t}\n\n\tif (issue == KVX_MAX_BUNDLE_ISSUE) {\n\t\tmemset (bundle, 0, sizeof (*bundle));\n\t\tissue = 0;\n\n\t\tcount = read_bundle (words, buf, len);\n\t\tif (count == 0)\n\t\t\treturn NULL;\n\n\t\tbundle->addr = addr;\n\t\tbundle->size = count * sizeof (ut32);\n\t\tret = disassemble_bundle (bundle, words, count);\n\t\tif (ret)\n\t\t\treturn NULL;\n\t}\n\n\twhile (issue < KVX_MAX_BUNDLE_ISSUE && bundle->issue[issue].len == 0) {\n\t\tissue++;\n\t}\n\n\tif (issue < KVX_MAX_BUNDLE_ISSUE) {\n\t\treturn &bundle->issue[issue];\n\t}\n\n\treturn NULL;\n}\n", "/* radare - LGPL - Copyright 2009-2021 - pancake, nibble */\n\n#include <r_types.h>\n#include <r_list.h>\n#include <r_flag.h>\n#include <r_core.h>\n#include <r_bin.h>\n#include <ht_uu.h>\n#include <r_util/r_graph_drawable.h>\n\n#include <string.h>\n\nHEAPTYPE (ut64);\n\n// used to speedup strcmp with rconfig.get in loops\nenum {\n\tR2_ARCH_THUMB,\n\tR2_ARCH_ARM32,\n\tR2_ARCH_ARM64,\n\tR2_ARCH_MIPS\n};\n// 128M\n#define MAX_SCAN_SIZE 0x7ffffff\n\nstatic void loganal(ut64 from, ut64 to, int depth) {\n\tr_cons_clear_line (1);\n\teprintf (\"0x%08\"PFMT64x\" > 0x%08\"PFMT64x\" %d\\r\", from, to, depth);\n}\n\nstatic int cmpsize(const void *a, const void *b) {\n\tut64 as = r_anal_function_linear_size ((RAnalFunction *) a);\n\tut64 bs = r_anal_function_linear_size ((RAnalFunction *) b);\n\treturn (as> bs)? 1: (as< bs)? -1: 0;\n}\n\nstatic int cmpfcncc(const void *_a, const void *_b) {\n\tRAnalFunction *a = (RAnalFunction *)_a;\n\tRAnalFunction *b = (RAnalFunction *)_b;\n\tut64 as = r_anal_function_complexity (a);\n\tut64 bs = r_anal_function_complexity (b);\n\treturn (as > bs)? 1: (as < bs)? -1: 0;\n}\n\nstatic int cmpedges(const void *_a, const void *_b) {\n\tconst RAnalFunction *a = _a, *b = _b;\n\tint as, bs;\n\tr_anal_function_count_edges (a, &as);\n\tr_anal_function_count_edges (b, &bs);\n\treturn (as > bs)? 1: (as < bs)? -1: 0;\n}\n\nstatic int cmpframe(const void *_a, const void *_b) {\n\tconst RAnalFunction *a = _a, *b = _b;\n\tint as = a->maxstack;\n\tint bs = b->maxstack;\n\treturn (as > bs)? 1: (as < bs)? -1: 0;\n}\n\nstatic int cmpxrefs(const void *_a, const void *_b) {\n\tconst RAnalFunction *a = _a, *b = _b;\n\tint as = a->meta.numrefs;\n\tint bs = b->meta.numrefs;\n\treturn (as > bs)? 1: (as < bs)? -1: 0;\n}\n\nstatic int cmpname(const void *_a, const void *_b) {\n\tconst RAnalFunction *a = _a, *b = _b;\n\tint as = strcmp (a->name, b->name);\n\tint bs = strcmp (b->name, a->name);\n\treturn (as > bs)? 1: (as < bs)? -1: 0;\n}\n\nstatic int cmpcalls(const void *_a, const void *_b) {\n\tconst RAnalFunction *a = _a, *b = _b;\n\tint as = a->meta.numcallrefs;\n\tint bs = b->meta.numcallrefs;\n\treturn (as > bs)? 1: (as < bs)? -1: 0;\n}\n\nstatic int cmpnbbs(const void *_a, const void *_b) {\n\tconst RAnalFunction *a = _a, *b = _b;\n\tut64 as = r_list_length (a->bbs);\n\tut64 bs = r_list_length (b->bbs);\n\treturn (as> bs)? 1: (as< bs)? -1: 0;\n}\n\nstatic int cmpaddr(const void *_a, const void *_b) {\n\tconst RAnalFunction *a = _a, *b = _b;\n\treturn (a->addr > b->addr)? 1: (a->addr < b->addr)? -1: 0;\n}\n\nstatic char *get_function_name(RCore *core, ut64 addr) {\n\tRBinFile *bf = r_bin_cur (core->bin);\n\tif (bf && bf->o) {\n\t\tRBinSymbol *sym = ht_up_find (bf->o->addr2klassmethod, addr, NULL);\n\t\tif (sym && sym->classname && sym->name) {\n\t\t\treturn r_str_newf (\"method.%s.%s\", sym->classname, sym->name);\n\t\t}\n\t}\n\tRFlagItem *flag = r_core_flag_get_by_spaces (core->flags, addr);\n\treturn (flag && flag->name) ? strdup (flag->name) : NULL;\n}\n\nstatic RCore *mycore = NULL;\n\n// XXX: copypaste from anal/data.c\n#define MINLEN 1\nstatic int is_string(const ut8 *buf, int size, int *len) {\n\tint i, fakeLen = 0;\n\tif (size < 1) {\n\t\treturn 0;\n\t}\n\tif (!len) {\n\t\tlen = &fakeLen;\n\t}\n\tif (size > 3 && buf[0] && !buf[1] && buf[2] && !buf[3]) {\n\t\t*len = 1; // XXX: TODO: Measure wide string length\n\t\treturn 2; // is wide\n\t}\n\tfor (i = 0; i < size; i++) {\n\t\tif (!buf[i] && i > MINLEN) {\n\t\t\t*len = i;\n\t\t\treturn 1;\n\t\t}\n\t\tif (buf[i] == 10 || buf[i] == 13 || buf[i] == 9) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[i] < 32 || buf[i] > 127) {\n\t\t\t// not ascii text\n\t\t\treturn 0;\n\t\t}\n\t\tif (!IS_PRINTABLE (buf[i])) {\n\t\t\t*len = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t*len = i;\n\treturn 1;\n}\n\nstatic char *is_string_at(RCore *core, ut64 addr, int *olen) {\n\tut8 rstr[128] = {0};\n\tint ret = 0, len = 0;\n\tut8 *str = calloc (256, 1);\n\tif (!str) {\n\t\tif (olen) {\n\t\t\t*olen = 0;\n\t\t}\n\t\treturn NULL;\n\t}\n\tr_io_read_at (core->io, addr, str, 255);\n\n\tstr[255] = 0;\n\tif (is_string (str, 256, &len)) {\n\t\tif (olen) {\n\t\t\t*olen = len;\n\t\t}\n\t\treturn (char*) str;\n\t}\n\n\tut64 *cstr = (ut64*)str;\n\tut64 lowptr = cstr[0];\n\tif (lowptr >> 32) { // must be pa mode only\n\t\tlowptr &= UT32_MAX;\n\t}\n\t// cstring\n\tif (cstr[0] == 0 && cstr[1] < 0x1000) {\n\t\tut64 ptr = cstr[2];\n\t\tif (ptr >> 32) { // must be pa mode only\n\t\t\tptr &= UT32_MAX;\n\t\t}\n\t\tif (ptr) {\n\t\t\tr_io_read_at (core->io, ptr, rstr, sizeof (rstr));\n\t\t\trstr[127] = 0;\n\t\t\tret = is_string (rstr, 128, &len);\n\t\t\tif (ret) {\n\t\t\t\tstrcpy ((char*) str, (char*) rstr);\n\t\t\t\tif (olen) {\n\t\t\t\t\t*olen = len;\n\t\t\t\t}\n\t\t\t\treturn (char*) str;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// pstring\n\t\tr_io_read_at (core->io, lowptr, rstr, sizeof (rstr));\n\t\trstr[127] = 0;\n\t\tret = is_string (rstr, sizeof (rstr), &len);\n\t\tif (ret) {\n\t\t\tstrcpy ((char*) str, (char*) rstr);\n\t\t\tif (olen) {\n\t\t\t\t*olen = len;\n\t\t\t}\n\t\t\treturn (char*) str;\n\t\t}\n\t}\n\t// check if current section have no exec bit\n\tif (len < 1) {\n\t\tret = 0;\n\t\tfree (str);\n\t\tlen = -1;\n\t} else if (olen) {\n\t\t*olen = len;\n\t}\n\t// NOTE: coverity says that ret is always 0 here, so str is dead code\n\treturn ret? (char *)str: NULL;\n}\n\n/* returns the R_ANAL_ADDR_TYPE_* of the address 'addr' */\nR_API ut64 r_core_anal_address(RCore *core, ut64 addr) {\n\tut64 types = 0;\n\tRRegSet *rs = NULL;\n\tif (!core) {\n\t\treturn 0;\n\t}\n\tif (core->dbg && core->dbg->reg) {\n\t\trs = r_reg_regset_get (core->dbg->reg, R_REG_TYPE_GPR);\n\t}\n\tif (rs) {\n\t\tRRegItem *r;\n\t\tRListIter *iter;\n\t\tr_list_foreach (rs->regs, iter, r) {\n\t\t\tif (r->type == R_REG_TYPE_GPR) {\n\t\t\t\tut64 val = r_reg_getv(core->dbg->reg, r->name);\n\t\t\t\tif (addr == val) {\n\t\t\t\t\ttypes |= R_ANAL_ADDR_TYPE_REG;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (r_flag_get_i (core->flags, addr)) {\n\t\ttypes |= R_ANAL_ADDR_TYPE_FLAG;\n\t}\n\tif (r_anal_get_fcn_in (core->anal, addr, 0)) {\n\t\ttypes |= R_ANAL_ADDR_TYPE_FUNC;\n\t}\n\t// check registers\n\tif (core->bin && core->dbg && r_config_get_b (core->config, \"cfg.debug\")) {\n\t\tRDebugMap *map;\n\t\tRListIter *iter;\n\t\t// use 'dm'\n\t\t// XXX: this line makes r2 debugging MUCH slower\n\t\t// r_debug_map_sync (core->dbg);\n\t\tr_list_foreach (core->dbg->maps, iter, map) {\n\t\t\tif (addr >= map->addr && addr < map->addr_end) {\n\t\t\t\tif (map->name && map->name[0] == '/') {\n\t\t\t\t\tif (core->io && core->io->desc &&\n\t\t\t\t\t\tcore->io->desc->name &&\n\t\t\t\t\t\t!strcmp (map->name,\n\t\t\t\t\t\t\t core->io->desc->name)) {\n\t\t\t\t\t\ttypes |= R_ANAL_ADDR_TYPE_PROGRAM;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttypes |= R_ANAL_ADDR_TYPE_LIBRARY;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (map->perm & R_PERM_X) {\n\t\t\t\t\ttypes |= R_ANAL_ADDR_TYPE_EXEC;\n\t\t\t\t}\n\t\t\t\tif (map->perm & R_PERM_R) {\n\t\t\t\t\ttypes |= R_ANAL_ADDR_TYPE_READ;\n\t\t\t\t}\n\t\t\t\tif (map->perm & R_PERM_W) {\n\t\t\t\t\ttypes |= R_ANAL_ADDR_TYPE_WRITE;\n\t\t\t\t}\n\t\t\t\t// find function\n\t\t\t\tif (map->name && strstr (map->name, \"heap\")) {\n\t\t\t\t\ttypes |= R_ANAL_ADDR_TYPE_HEAP;\n\t\t\t\t}\n\t\t\t\tif (map->name && strstr (map->name, \"stack\")) {\n\t\t\t\t\ttypes |= R_ANAL_ADDR_TYPE_STACK;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tint _perm = -1;\n\t\tif (core->io) {\n\t\t\t// sections\n\t\t\tRIOBank *bank = r_io_bank_get (core->io, core->io->bank);\n\t\t\tif (bank) {\n\t\t\t\tRIOMapRef *mapref;\n\t\t\t\tRListIter *iter;\n\t\t\t\tr_list_foreach (bank->maprefs, iter, mapref) {\n\t\t\t\t\tRIOMap *s = r_io_map_get (core->io, mapref->id);\n\t\t\t\t\tif (addr >= s->itv.addr && addr < (s->itv.addr + s->itv.size)) {\n\t\t\t\t\t\t// sections overlap, so we want to get the one with lower perms\n\t\t\t\t\t\t_perm = (_perm != -1) ? R_MIN (_perm, s->perm) : s->perm;\n\t\t\t\t\t\t// TODO: we should identify which maps come from the program or other\n\t\t\t\t\t\t//types |= R_ANAL_ADDR_TYPE_PROGRAM;\n\t\t\t\t\t\t// find function those sections should be created by hand or esil init\n\t\t\t\t\t\tif (s->name && strstr (s->name, \"heap\")) {\n\t\t\t\t\t\t\ttypes |= R_ANAL_ADDR_TYPE_HEAP;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (s->name && strstr (s->name, \"stack\")) {\n\t\t\t\t\t\t\ttypes |= R_ANAL_ADDR_TYPE_STACK;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (_perm != -1) {\n\t\t\tif (_perm & R_PERM_X) {\n\t\t\t\ttypes |= R_ANAL_ADDR_TYPE_EXEC;\n\t\t\t}\n\t\t\tif (_perm & R_PERM_R) {\n\t\t\t\ttypes |= R_ANAL_ADDR_TYPE_READ;\n\t\t\t}\n\t\t\tif (_perm & R_PERM_W) {\n\t\t\t\ttypes |= R_ANAL_ADDR_TYPE_WRITE;\n\t\t\t}\n\t\t}\n\t}\n\n\t// check if it's ascii\n\tif (addr != 0) {\n\t\tint not_ascii = 0;\n\t\tint i, failed_sequence, dir, on;\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tut8 n = (addr >> (i * 8)) & 0xff;\n\t\t\tif (n && !IS_PRINTABLE (n)) {\n\t\t\t\tnot_ascii = 1;\n\t\t\t}\n\t\t}\n\t\tif (!not_ascii) {\n\t\t\ttypes |= R_ANAL_ADDR_TYPE_ASCII;\n\t\t}\n\t\tfailed_sequence = 0;\n\t\tdir = on = -1;\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tut8 n = (addr >> (i * 8)) & 0xff;\n\t\t\tif (on != -1) {\n\t\t\t\tif (dir == -1) {\n\t\t\t\t\tdir = (n > on)? 1: -1;\n\t\t\t\t}\n\t\t\t\tif (n == on + dir) {\n\t\t\t\t\t// ok\n\t\t\t\t} else {\n\t\t\t\t\tfailed_sequence = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ton = n;\n\t\t}\n\t\tif (!failed_sequence) {\n\t\t\ttypes |= R_ANAL_ADDR_TYPE_SEQUENCE;\n\t\t}\n\t}\n\treturn types;\n}\n\nstatic bool blacklisted_word(char* name) {\n\tconst char * list[] = {\n\t\t\"__stack_chk_guard\",\n\t\t\"__stderrp\",\n\t\t\"__stdinp\",\n\t\t\"__stdoutp\",\n\t\t\"_DefaultRuneLocale\"\n\t};\n\tint i;\n\tfor (i = 0; i < sizeof (list) / sizeof (list[0]); i++) {\n\t\tif (strstr (name, list[i])) { return true; }\n\t}\n\treturn false;\n}\n\nstatic char *anal_fcn_autoname(RCore *core, RAnalFunction *fcn, int dump, int mode) {\n\tint use_getopt = 0;\n\tint use_isatty = 0;\n\tPJ *pj = NULL;\n\tchar *do_call = NULL;\n\tRAnalRef *ref;\n\tRListIter *iter;\n\tRList *refs = r_anal_function_get_refs (fcn);\n\tif (mode == 'j') {\n\t\t// start a new JSON object\n\t\tpj = r_core_pj_new (core);\n\t\tpj_a (pj);\n\t}\n\tif (refs) {\n\t\tr_list_foreach (refs, iter, ref) {\n\t\t\tRFlagItem *f = r_flag_get_i (core->flags, ref->addr);\n\t\t\tif (f) {\n\t\t\t\t// If dump is true, print all strings referenced by the function\n\t\t\t\tif (dump) {\n\t\t\t\t\t// take only strings flags\n\t\t\t\t\tif (!strncmp (f->name, \"str.\", 4)) {\n\t\t\t\t\t\tif (mode == 'j') {\n\t\t\t\t\t\t\t// add new json item\n\t\t\t\t\t\t\tpj_o (pj);\n\t\t\t\t\t\t\tpj_kn (pj, \"addr\", ref->at);\n\t\t\t\t\t\t\tpj_kn (pj, \"ref\", ref->addr);\n\t\t\t\t\t\t\tpj_ks (pj, \"flag\", f->name);\n\t\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" 0x%08\"PFMT64x\" %s\\n\", ref->at, ref->addr, f->name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (do_call) { // break if a proper autoname found and not in dump mode\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// enter only if a candidate name hasn't found yet\n\t\t\t\tif (!do_call) {\n\t\t\t\t\tif (blacklisted_word (f->name)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (strstr (f->name, \".isatty\")) {\n\t\t\t\t\t\tuse_isatty = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (strstr (f->name, \".getopt\")) {\n\t\t\t\t\t\tuse_getopt = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (!strncmp (f->name, \"method.\", 7)) {\n\t\t\t\t\t\tfree (do_call);\n\t\t\t\t\t\tdo_call = strdup (f->name + 7);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!strncmp (f->name, \"str.\", 4)) {\n\t\t\t\t\t\tfree (do_call);\n\t\t\t\t\t\tdo_call = strdup (f->name + 4);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!strncmp (f->name, \"dbg.\", 4)) {\n\t\t\t\t\t\tfree (do_call);\n\t\t\t\t\t\tdo_call = strdup (f->name + 4);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!strncmp (f->name, \"sym.imp.\", 8)) {\n\t\t\t\t\t\tfree (do_call);\n\t\t\t\t\t\tdo_call = strdup (f->name + 8);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!strncmp (f->name, \"reloc.\", 6)) {\n\t\t\t\t\t\tfree (do_call);\n\t\t\t\t\t\tdo_call = strdup (f->name + 6);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tr_list_free (refs);\n\t}\n\tif (mode ==  'j') {\n\t\tpj_end (pj);\n\t}\n\tif (pj) {\n\t\tr_cons_printf (\"%s\\n\", pj_string (pj));\n\t\tpj_free (pj);\n\t}\n\t// TODO: append counter if name already exists\n\tif (use_getopt) {\n\t\tRFlagItem *item = r_flag_get (core->flags, \"main\");\n\t\tfree (do_call);\n\t\t// if referenced from entrypoint. this should be main\n\t\tif (item && item->offset == fcn->addr) {\n\t\t\treturn strdup (\"main\"); // main?\n\t\t}\n\t\treturn strdup (\"parse_args\"); // main?\n\t}\n\tif (use_isatty) {\n\t\tchar *ret = r_str_newf (\"sub.setup_tty_%s_%\"PFMT64x, do_call, fcn->addr);\n\t\tfree (do_call);\n\t\treturn ret;\n\t}\n\tif (do_call) {\n\t\tchar *ret = r_str_newf (\"sub.%s_%\"PFMT64x, do_call, fcn->addr);\n\t\tfree (do_call);\n\t\treturn ret;\n\t}\n\treturn NULL;\n}\n\n/*this only autoname those function that start with fcn.* or sym.func.* */\nR_API void r_core_anal_autoname_all_fcns(RCore *core) {\n\tRListIter *it;\n\tRAnalFunction *fcn;\n\n\tr_list_foreach (core->anal->fcns, it, fcn) {\n\t\tif (!strncmp (fcn->name, \"fcn.\", 4) || !strncmp (fcn->name, \"sym.func.\", 9)) {\n\t\t\tRFlagItem *item = r_flag_get (core->flags, fcn->name);\n\t\t\tif (item) {\n\t\t\t\tchar *name = anal_fcn_autoname (core, fcn, 0, 0);\n\t\t\t\tif (name) {\n\t\t\t\t\tr_flag_rename (core->flags, item, name);\n\t\t\t\t\tfree (fcn->name);\n\t\t\t\t\tfcn->name = name;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// there should always be a flag for a function\n\t\t\t\tr_warn_if_reached ();\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* reads .gopclntab section in go binaries to recover function names\n   and adds them as sym.go.* flags */\nR_API void r_core_anal_autoname_all_golang_fcns(RCore *core) {\n\tRList* section_list = r_bin_get_sections (core->bin);\n\tRListIter *iter;\n\tconst char* oldstr = NULL;\n\tRBinSection *section;\n\tut64 gopclntab = 0;\n\tr_list_foreach (section_list, iter, section) {\n\t\tif (strstr (section->name, \".gopclntab\")) {\n\t\t\tgopclntab = section->vaddr;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!gopclntab) {\n\t\toldstr = r_print_rowlog (core->print, \"Could not find .gopclntab section\");\n\t\tr_print_rowlog_done (core->print, oldstr);\n\t\treturn;\n\t}\n\tint ptr_size = core->anal->bits / 8;\n\tut64 offset = gopclntab + 2 * ptr_size;\n\tut64 size_offset = gopclntab + 3 * ptr_size ;\n\tut8 temp_size[4] = {0};\n\tif (!r_io_nread_at (core->io, size_offset, temp_size, 4)) {\n\t\treturn;\n\t}\n\tut32 size = r_read_le32 (temp_size);\n\tint num_syms = 0;\n\t//r_cons_print (\"[x] Reading .gopclntab...\\n\");\n\tr_flag_space_push (core->flags, R_FLAGS_FS_SYMBOLS);\n\twhile (offset < gopclntab + size) {\n\t\tut8 temp_delta[4] = {0};\n\t\tut8 temp_func_addr[4] = {0};\n\t\tut8 temp_func_name[4] = {0};\n\t\tif (!r_io_nread_at (core->io, offset + ptr_size, temp_delta, 4)) {\n\t\t\tbreak;\n\t\t}\n\t\tut32 delta = r_read_le32 (temp_delta);\n\t\tut64 func_offset = gopclntab + delta;\n\t\tif (!r_io_nread_at (core->io, func_offset, temp_func_addr, 4) ||\n\t\t\t!r_io_nread_at (core->io, func_offset + ptr_size, temp_func_name, 4)) {\n\t\t\tbreak;\n\t\t}\n\t\tut32 func_addr = r_read_le32 (temp_func_addr);\n\t\tut32 func_name_offset = r_read_le32 (temp_func_name);\n\t\tut8 func_name[64] = {0};\n\t\tr_io_read_at (core->io, gopclntab + func_name_offset, func_name, 63);\n\t\tif (func_name[0] == 0xff) {\n\t\t\tbreak;\n\t\t}\n\t\tr_name_filter ((char *)func_name, 0);\n\t\t//r_cons_printf (\"[x] Found symbol %s at 0x%x\\n\", func_name, func_addr);\n\t\tchar *flagname = r_str_newf (\"sym.go.%s\", func_name);\n\t\tr_flag_set (core->flags, flagname, func_addr, 1);\n\t\tfree (flagname);\n\t\toffset += 2 * ptr_size;\n\t\tnum_syms++;\n\t}\n\tr_flag_space_pop (core->flags);\n\tif (num_syms) {\n\t\tr_strf_var (msg, 128, \"Found %d symbols and saved them at sym.go.*\", num_syms);\n\t\toldstr = r_print_rowlog (core->print, msg);\n\t\tr_print_rowlog_done (core->print, oldstr);\n\t} else {\n\t\toldstr = r_print_rowlog (core->print, \"Found no symbols.\");\n\t\tr_print_rowlog_done (core->print, oldstr);\n\t}\n}\n\n/* suggest a name for the function at the address 'addr'.\n * If dump is true, every strings associated with the function is printed */\nR_API char *r_core_anal_fcn_autoname(RCore *core, ut64 addr, int dump, int mode) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\treturn fcn? anal_fcn_autoname (core, fcn, dump, mode): NULL;\n}\n\nstatic ut64 *next_append(ut64 *next, int *nexti, ut64 v) {\n\tut64 *tmp_next = realloc (next, sizeof (ut64) * (1 + *nexti));\n\tif (!tmp_next) {\n\t\treturn NULL;\n\t}\n\tnext = tmp_next;\n\tnext[*nexti] = v;\n\t(*nexti)++;\n\treturn next;\n}\n\nstatic void r_anal_set_stringrefs(RCore *core, RAnalFunction *fcn) {\n\tRListIter *iter;\n\tRAnalRef *ref;\n\tRList *refs = r_anal_function_get_refs (fcn);\n\tr_list_foreach (refs, iter, ref) {\n\t\tif (ref->type == R_ANAL_REF_TYPE_DATA &&\n\t\t\tr_bin_is_string (core->bin, ref->addr)) {\n\t\t\tr_anal_xrefs_set (core->anal, ref->at, ref->addr, R_ANAL_REF_TYPE_STRING);\n\t\t}\n\t}\n\tr_list_free (refs);\n}\n\nstatic bool r_anal_try_get_fcn(RCore *core, RAnalRef *ref, int fcndepth, int refdepth) {\n\tif (!refdepth) {\n\t\treturn false;\n\t}\n\tRIOMap *map = r_io_map_get_at (core->io, ref->addr);\n\tif (!map) {\n\t\treturn false;\n\t}\n\n\tif (map->perm & R_PERM_X) {\n\t\tut8 buf[64];\n\t\tr_io_read_at (core->io, ref->addr, buf, sizeof (buf));\n\t\tbool looksLikeAFunction = r_anal_check_fcn (core->anal, buf, sizeof (buf), ref->addr, r_io_map_begin (map),\n\t\t\t\tr_io_map_end (map));\n\t\tif (looksLikeAFunction) {\n\t\t\tif (core->anal->limit) {\n\t\t\t\tif (ref->addr < core->anal->limit->from ||\n\t\t\t\t\t\tref->addr > core->anal->limit->to) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_core_anal_fcn (core, ref->addr, ref->at, ref->type, fcndepth - 1);\n\t\t}\n\t} else {\n\t\tut64 offs = 0;\n\t\tut64 sz = core->anal->bits >> 3;\n\t\tRAnalRef ref1;\n\t\tref1.type = R_ANAL_REF_TYPE_DATA;\n\t\tref1.at = ref->addr;\n\t\tref1.addr = 0;\n\t\tut32 i32;\n\t\tut16 i16;\n\t\tut8 i8;\n\t\tut64 offe = offs + 1024;\n\t\tfor (offs = 0; offs < offe; offs += sz, ref1.at += sz) {\n\t\t\tut8 bo[8];\n\t\t\tr_io_read_at (core->io, ref->addr + offs, bo, R_MIN (sizeof (bo), sz));\n\t\t\tbool be = core->anal->big_endian;\n\t\t\tswitch (sz) {\n\t\t\tcase 1:\n\t\t\t\ti8 = r_read_ble8 (bo);\n\t\t\t\tref1.addr = (ut64)i8;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ti16 = r_read_ble16 (bo, be);\n\t\t\t\tref1.addr = (ut64)i16;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\ti32 = r_read_ble32 (bo, be);\n\t\t\t\tref1.addr = (ut64)i32;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tref1.addr = r_read_ble64 (bo, be);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_anal_try_get_fcn (core, &ref1, fcndepth, refdepth - 1);\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int r_anal_analyze_fcn_refs(RCore *core, RAnalFunction *fcn, int depth) {\n\tRListIter *iter;\n\tRAnalRef *ref;\n\tRList *refs = r_anal_function_get_refs (fcn);\n\n\tr_list_foreach (refs, iter, ref) {\n\t\tif (ref->addr == UT64_MAX) {\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (ref->type) {\n\t\tcase R_ANAL_REF_TYPE_DATA:\n\t\t\tif (core->anal->opt.followdatarefs) {\n\t\t\t\tr_anal_try_get_fcn (core, ref, depth, 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_REF_TYPE_CODE:\n\t\tcase R_ANAL_REF_TYPE_CALL:\n\t\t\tr_core_anal_fcn (core, ref->addr, ref->at, ref->type, depth - 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t// TODO: fix memleak here, fcn not freed even though it is\n\t\t// added in core->anal->fcns which is freed in r_anal_free()\n\t}\n\tr_list_free (refs);\n\treturn 1;\n}\n\nstatic void function_rename(RFlag *flags, RAnalFunction *fcn) {\n\tconst char *locname = \"loc.\";\n\tconst size_t locsize = strlen (locname);\n\tchar *fcnname = fcn->name;\n\n\tif (strncmp (fcn->name, locname, locsize) == 0) {\n\t\tconst char *fcnpfx, *restofname;\n\t\tRFlagItem *f;\n\n\t\tfcn->type = R_ANAL_FCN_TYPE_FCN;\n\t\tfcnpfx = r_anal_functiontype_tostring (fcn->type);\n\t\trestofname = fcn->name + locsize;\n\t\tfcn->name = r_str_newf (\"%s.%s\", fcnpfx, restofname);\n\n\t\tf = r_flag_get_i (flags, fcn->addr);\n\t\tr_flag_rename (flags, f, fcn->name);\n\n\t\tfree (fcnname);\n\t}\n}\n\nstatic void autoname_imp_trampoline(RCore *core, RAnalFunction *fcn) {\n\tif (r_list_length (fcn->bbs) == 1 && ((RAnalBlock *) r_list_first (fcn->bbs))->ninstr == 1) {\n\t\tRList *refs = r_anal_function_get_refs (fcn);\n\t\tif (refs && r_list_length (refs) == 1) {\n\t\t\tRAnalRef *ref = r_list_first (refs);\n\t\t\tif (ref->type != R_ANAL_REF_TYPE_CALL) { /* Some fcns don't return */\n\t\t\t\tRFlagItem *flg = r_flag_get_i (core->flags, ref->addr);\n\t\t\t\tif (flg && r_str_startswith (flg->name, \"sym.imp.\")) {\n\t\t\t\t\tR_FREE (fcn->name);\n\t\t\t\t\tfcn->name = r_str_newf (\"sub.%s\", flg->name + 8);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tr_list_free (refs);\n\t}\n}\n\nstatic void set_fcn_name_from_flag(RAnalFunction *fcn, RFlagItem *f, const char *fcnpfx) {\n\tbool nameChanged = false;\n\tif (f && f->name) {\n\t\tif (!strncmp (fcn->name, \"loc.\", 4) || !strncmp (fcn->name, \"fcn.\", 4)) {\n\t\t\tr_anal_function_rename (fcn, f->name);\n\t\t\tnameChanged = true;\n\t\t} else if (strncmp (f->name, \"sect\", 4)) {\n\t\t\tr_anal_function_rename (fcn, f->name);\n\t\t\tnameChanged = true;\n\t\t}\n\t}\n\tif (!nameChanged) {\n\t\tchar *nn = r_str_newf (\"%s.%08\" PFMT64x, fcnpfx, fcn->addr);\n\t\tr_anal_function_rename (fcn, nn);\n\t\tfree (nn);\n\t}\n}\n\nstatic bool is_entry_flag(RFlagItem *f) {\n\treturn f->space && !strcmp (f->space->name, R_FLAGS_FS_SYMBOLS) && r_str_startswith (f->name, \"entry.\");\n}\n\nstatic bool __core_anal_fcn(RCore *core, ut64 at, ut64 from, int reftype, int depth) {\n\tif (depth < 0) {\n//\t\tprintf (\"Too deep for 0x%08\"PFMT64x\"\\n\", at);\n//\t\tr_sys_backtrace ();\n\t\treturn false;\n\t}\n\tint has_next = r_config_get_i (core->config, \"anal.hasnext\");\n\tRAnalHint *hint = NULL;\n\tint i, nexti = 0;\n\tut64 *next = NULL;\n\tint fcnlen;\n\tRAnalFunction *fcn = r_anal_function_new (core->anal);\n\tr_warn_if_fail (fcn);\n\tconst char *fcnpfx = r_config_get (core->config, \"anal.fcnprefix\");\n\tif (!fcnpfx) {\n\t\tfcnpfx = \"fcn\";\n\t}\n\tconst char *cc = r_anal_cc_default (core->anal);\n\tif (!cc) {\n\t\tif (r_anal_cc_once (core->anal)) {\n\t\t\teprintf (\"Warning: set your favourite calling convention in `e anal.cc=?`\\n\");\n\t\t}\n\t\tcc = \"reg\";\n\t}\n\tfcn->cc = r_str_constpool_get (&core->anal->constpool, cc);\n\tr_warn_if_fail (fcn->cc);\n\thint = r_anal_hint_get (core->anal, at);\n\tif (hint && hint->bits == 16) {\n\t\t// expand 16bit for function\n\t\tfcn->bits = 16;\n\t} else {\n\t\tfcn->bits = core->anal->bits;\n\t}\n\tfcn->addr = at;\n\tfcn->name = get_function_name (core, at);\n\n\tif (!fcn->name) {\n\t\tfcn->name = r_str_newf (\"%s.%08\"PFMT64x, fcnpfx, at);\n\t}\n\tr_anal_function_invalidate_read_ahead_cache ();\n\tdo {\n\t\tRFlagItem *f;\n\t\tut64 delta = r_anal_function_linear_size (fcn);\n\t\tif (!r_io_is_valid_offset (core->io, at + delta, !core->anal->opt.noncode)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tfcnlen = r_anal_function(core->anal, fcn, at + delta, core->anal->opt.bb_max_size, reftype);\n\t\tif (core->anal->opt.searchstringrefs) {\n\t\t\tr_anal_set_stringrefs (core, fcn);\n\t\t}\n\t\tif (fcnlen == 0) {\n\t\t\tif (core->anal->verbose) {\n\t\t\t\teprintf (\"Analyzed function size is 0 at 0x%08\"PFMT64x\"\\n\", at + delta);\n\t\t\t}\n\t\t\tgoto error;\n\t\t}\n\t\tif (fcnlen < 0) {\n\t\t\tswitch (fcnlen) {\n\t\t\tcase R_ANAL_RET_ERROR:\n\t\t\tcase R_ANAL_RET_NEW:\n\t\t\tcase R_ANAL_RET_DUP:\n\t\t\tcase R_ANAL_RET_END:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\teprintf (\"Oops. Negative fcnsize at 0x%08\"PFMT64x\" (%d)\\n\", at, fcnlen);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tf = r_core_flag_get_by_spaces (core->flags, fcn->addr);\n\t\tset_fcn_name_from_flag (fcn, f, fcnpfx);\n\n\t\tif (fcnlen == R_ANAL_RET_ERROR ||\n\t\t\t(fcnlen == R_ANAL_RET_END && !r_anal_function_realsize (fcn))) { /* Error analyzing function */\n\t\t\tif (core->anal->opt.followbrokenfcnsrefs) {\n\t\t\t\tr_anal_analyze_fcn_refs (core, fcn, depth);\n\t\t\t}\n\t\t\tgoto error;\n\t\t} else if (fcnlen == R_ANAL_RET_END) { /* Function analysis complete */\n\t\t\tf = r_core_flag_get_by_spaces (core->flags, fcn->addr);\n\t\t\tif (f && f->name && strncmp (f->name, \"sect\", 4)) { /* Check if it's already flagged */\n\t\t\t\tchar *new_name = strdup (f->name);\n\t\t\t\tif (is_entry_flag (f)) {\n\t\t\t\t\tRListIter *iter;\n\t\t\t\t\tRBinSymbol *sym;\n\t\t\t\t\tconst RList *syms = r_bin_get_symbols (core->bin);\n\t\t\t\t\tut64 baddr = r_config_get_i (core->config, \"bin.baddr\");\n\t\t\t\t\tr_list_foreach (syms, iter, sym) {\n\t\t\t\t\t\tif (sym->type && (sym->paddr + baddr) == fcn->addr && !strcmp (sym->type, R_BIN_TYPE_FUNC_STR)) {\n\t\t\t\t\t\t\tfree (new_name);\n\t\t\t\t\t\t\tnew_name = r_str_newf (\"sym.%s\", sym->name);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (fcn->name);\n\t\t\t\tfcn->name = new_name;\n\t\t\t} else {\n\t\t\t\tR_FREE (fcn->name);\n\t\t\t\tconst char *fcnpfx = r_anal_functiontype_tostring (fcn->type);\n\t\t\t\tif (!fcnpfx || !*fcnpfx || !strcmp (fcnpfx, \"fcn\")) {\n\t\t\t\t\tfcnpfx = r_config_get (core->config, \"anal.fcnprefix\");\n\t\t\t\t}\n\t\t\t\tfcn->name = r_str_newf (\"%s.%08\"PFMT64x, fcnpfx, fcn->addr);\n\t\t\t\tautoname_imp_trampoline (core, fcn);\n\t\t\t\t/* Add flag */\n\t\t\t\tr_flag_space_push (core->flags, R_FLAGS_FS_FUNCTIONS);\n\t\t\t\tr_flag_set (core->flags, fcn->name, fcn->addr, r_anal_function_linear_size (fcn));\n\t\t\t\tr_flag_space_pop (core->flags);\n\t\t\t}\n\n\t\t\t/* New function: Add initial xref */\n\t\t\tif (from != UT64_MAX) {\n\t\t\t\tr_anal_xrefs_set (core->anal, from, fcn->addr, reftype);\n\t\t\t}\n\t\t\t// XXX: this is wrong. See CID 1134565\n\t\t\tr_anal_add_function (core->anal, fcn);\n\t\t\tif (has_next) {\n\t\t\t\tut64 addr = r_anal_function_max_addr (fcn);\n\t\t\t\tRIOMap *map = r_io_map_get_at (core->io, addr);\n\t\t\t\t// only get next if found on an executable section\n\t\t\t\tif (!map || (map && map->perm & R_PERM_X)) {\n\t\t\t\t\tfor (i = 0; i < nexti; i++) {\n\t\t\t\t\t\tif (next[i] == addr) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (i == nexti) {\n\t\t\t\t\t\tut64 at = r_anal_function_max_addr (fcn);\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tut64 size;\n\t\t\t\t\t\t\tRAnalMetaItem *mi = r_meta_get_at (core->anal, at, R_META_TYPE_ANY, &size);\n\t\t\t\t\t\t\tif (!mi) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tat += size;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// TODO: ensure next address is function after padding (nop or trap or wat)\n\t\t\t\t\t\t// XXX noisy for test cases because we want to clear the stderr\n\t\t\t\t\t\tr_cons_clear_line (1);\n\t\t\t\t\t\tloganal (fcn->addr, at, 10000 - depth);\n\t\t\t\t\t\tnext = next_append (next, &nexti, at);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!r_anal_analyze_fcn_refs (core, fcn, depth)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t} while (fcnlen != R_ANAL_RET_END);\n\tr_list_free (core->anal->leaddrs);\n\tcore->anal->leaddrs = NULL;\n\tif (has_next) {\n\t\tfor (i = 0; i < nexti; i++) {\n\t\t\tif (!next[i] || r_anal_get_fcn_in (core->anal, next[i], 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr_core_anal_fcn (core, next[i], from, 0, depth - 1);\n\t\t}\n\t\tfree (next);\n\t}\n\tif (core->anal->cur && core->anal->cur->arch && !strcmp (core->anal->cur->arch, \"x86\")) {\n\t\tr_anal_function_check_bp_use (fcn);\n\t\tif (fcn && !fcn->bp_frame) {\n\t\t\tr_anal_function_delete_vars_by_kind (fcn, R_ANAL_VAR_KIND_BPV);\n\t\t}\n\t}\n\tr_anal_hint_free (hint);\n\treturn true;\n\nerror:\n\tr_list_free (core->anal->leaddrs);\n\tcore->anal->leaddrs = NULL;\n\t// ugly hack to free fcn\n\tif (fcn) {\n\t\tif (!r_anal_function_realsize (fcn) || fcn->addr == UT64_MAX) {\n\t\t\tr_anal_function_free (fcn);\n\t\t\tfcn = NULL;\n\t\t} else {\n\t\t\t// TODO: mark this function as not properly analyzed\n\t\t\tif (!fcn->name) {\n\t\t\t\t// XXX dupped code.\n\t\t\t\tfcn->name = r_str_newf (\n\t\t\t\t\t\"%s.%08\" PFMT64x,\n\t\t\t\t\tr_anal_functiontype_tostring (fcn->type),\n\t\t\t\t\tat);\n\t\t\t\t/* Add flag */\n\t\t\t\tr_flag_space_push (core->flags, R_FLAGS_FS_FUNCTIONS);\n\t\t\t\tr_flag_set (core->flags, fcn->name, at, r_anal_function_linear_size (fcn));\n\t\t\t\tr_flag_space_pop (core->flags);\n\t\t\t}\n\t\t\tr_anal_add_function (core->anal, fcn);\n\t\t}\n\t\tif (fcn && has_next) {\n\t\t\tut64 newaddr = r_anal_function_max_addr (fcn);\n\t\t\tRIOMap *map = r_io_map_get_at (core->io, newaddr);\n\t\t\tif (!map || (map && (map->perm & R_PERM_X))) {\n\t\t\t\tnext = next_append (next, &nexti, newaddr);\n\t\t\t\tfor (i = 0; i < nexti; i++) {\n\t\t\t\t\tif (!next[i]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr_core_anal_fcn (core, next[i], next[i], 0, depth - 1);\n\t\t\t\t}\n\t\t\t\tfree (next);\n\t\t\t}\n\t\t}\n\t}\n\tif (fcn && core->anal->cur && core->anal->cur->arch && !strcmp (core->anal->cur->arch, \"x86\")) {\n\t\tr_anal_function_check_bp_use (fcn);\n\t\tif (!fcn->bp_frame) {\n\t\t\tr_anal_function_delete_vars_by_kind (fcn, R_ANAL_VAR_KIND_BPV);\n\t\t}\n\t}\n\tr_anal_hint_free (hint);\n\treturn false;\n}\n\nstatic char *get_title(ut64 addr) {\n\treturn r_str_newf (\"0x%\"PFMT64x, addr);\n}\n\n/* decode and return the RAnalOp at the address addr */\nR_API RAnalOp* r_core_anal_op(RCore *core, ut64 addr, int mask) {\n\tint len;\n\tut8 buf[32];\n\tut8 *ptr;\n\n\tr_return_val_if_fail (core, NULL);\n\tif (addr == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tRAnalOp *op = R_NEW0 (RAnalOp);\n\tif (!op) {\n\t\treturn NULL;\n\t}\n\tint delta = (addr - core->offset);\n\tint minopsz = 8;\n\tif (delta > 0 && delta + minopsz < core->blocksize && addr >= core->offset && addr + 16 < core->offset + core->blocksize) {\n\t\tptr = core->block + delta;\n\t\tlen = core->blocksize - delta;\n\t\tif (len < 1) {\n\t\t\tgoto err_op;\n\t\t}\n\t} else {\n\t\tif (!r_io_read_at (core->io, addr, buf, sizeof (buf))) {\n\t\t\tgoto err_op;\n\t\t}\n\t\tptr = buf;\n\t\tlen = sizeof (buf);\n\t}\n\tif (r_anal_op (core->anal, op, addr, ptr, len, mask) < 1) {\n\t\tgoto err_op;\n\t}\n\t// TODO This code block must be deleted when all the anal plugs support disasm\n\tif (!op->mnemonic && mask & R_ANAL_OP_MASK_DISASM) {\n\t\tRAsmOp asmop;\n\t\tif (core->anal->verbose) {\n\t\t\teprintf (\"Warning: Implement RAnalOp.MASK_DISASM for current anal.arch. Using the sluggish RAsmOp fallback for now.\\n\");\n\t\t}\n\t\tr_asm_set_pc (core->rasm, addr);\n\t\tr_asm_op_init (&asmop);\n\t\tif (r_asm_disassemble (core->rasm, &asmop, ptr, len) > 0) {\n\t\t\top->mnemonic = strdup (r_strbuf_get (&asmop.buf_asm));\n\t\t}\n\t\tr_asm_op_fini (&asmop);\n\t}\n\treturn op;\nerr_op:\n\tfree (op);\n\treturn NULL;\n}\n\n// Node for tree-sorting anal hints or collecting hint records at a single addr\ntypedef struct {\n\tRBNode rb;\n\tut64 addr;\n\tenum {\n\t\tHINT_NODE_ADDR,\n\t\tHINT_NODE_ARCH,\n\t\tHINT_NODE_BITS\n\t} type;\n\tunion {\n\t\tconst RVector/*<const RAnalAddrHintRecord>*/ *addr_hints;\n\t\tconst char *arch;\n\t\tint bits;\n\t};\n} HintNode;\n\nstatic void print_hint_h_format(HintNode *node) {\n\tswitch (node->type) {\n\tcase HINT_NODE_ADDR: {\n\t\tconst RAnalAddrHintRecord *record;\n\t\tr_vector_foreach (node->addr_hints, record) {\n\t\t\tswitch (record->type) {\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_IMMBASE:\n\t\t\t\tr_cons_printf (\" immbase=%d\", record->immbase);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_JUMP:\n\t\t\t\tr_cons_printf (\" jump=0x%08\"PFMT64x, record->jump);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_FAIL:\n\t\t\t\tr_cons_printf (\" fail=0x%08\"PFMT64x, record->fail);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_STACKFRAME:\n\t\t\t\tr_cons_printf (\" stackframe=0x%\"PFMT64x, record->stackframe);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_PTR:\n\t\t\t\tr_cons_printf (\" ptr=0x%\"PFMT64x, record->ptr);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_NWORD:\n\t\t\t\tr_cons_printf (\" nword=%d\", record->nword);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_RET:\n\t\t\t\tr_cons_printf (\" ret=0x%08\"PFMT64x, record->retval);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_NEW_BITS:\n\t\t\t\tr_cons_printf (\" newbits=%d\", record->newbits);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_SIZE:\n\t\t\t\tr_cons_printf (\" size=%\"PFMT64u, record->size);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_SYNTAX:\n\t\t\t\tr_cons_printf (\" syntax='%s'\", record->syntax);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_OPTYPE: {\n\t\t\t\tconst char *type = r_anal_optype_to_string (record->optype);\n\t\t\t\tif (type) {\n\t\t\t\t\tr_cons_printf (\" type='%s'\", type);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_OPCODE:\n\t\t\t\tr_cons_printf (\" opcode='%s'\", record->opcode);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_TYPE_OFFSET:\n\t\t\t\tr_cons_printf (\" offset='%s'\", record->type_offset);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_ESIL:\n\t\t\t\tr_cons_printf (\" esil='%s'\", record->esil);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_HIGH:\n\t\t\t\tr_cons_printf (\" high=true\");\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_VAL:\n\t\t\t\tr_cons_printf (\" val=0x%08\"PFMT64x, record->val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase HINT_NODE_ARCH:\n\t\tif (node->arch) {\n\t\t\tr_cons_printf (\" arch='%s'\", node->arch);\n\t\t} else {\n\t\t\tr_cons_print (\" arch=RESET\");\n\t\t}\n\t\tbreak;\n\tcase HINT_NODE_BITS:\n\t\tif (node->bits) {\n\t\t\tr_cons_printf (\" bits=%d\", node->bits);\n\t\t} else {\n\t\t\tr_cons_print (\" bits=RESET\");\n\t\t}\n\t\tbreak;\n\t}\n}\n\n// if mode == 'j', pj must be an existing PJ!\nstatic void hint_node_print(HintNode *node, int mode, PJ *pj) {\n\tswitch (mode) {\n\tcase '*':\n#define HINTCMD_ADDR(hint,fmt,x) r_cons_printf (fmt\" @ 0x%\"PFMT64x\"\\n\", x, (hint)->addr)\n\t\tswitch (node->type) {\n\t\tcase HINT_NODE_ADDR: {\n\t\t\tconst RAnalAddrHintRecord *record;\n\t\t\tr_vector_foreach (node->addr_hints, record) {\n\t\t\t\tswitch (record->type) {\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_IMMBASE:\n\t\t\t\t\tHINTCMD_ADDR (node, \"ahi %d\", record->immbase);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_JUMP:\n\t\t\t\t\tHINTCMD_ADDR (node, \"ahc 0x%\"PFMT64x, record->jump);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_FAIL:\n\t\t\t\t\tHINTCMD_ADDR (node, \"ahf 0x%\"PFMT64x, record->fail);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_STACKFRAME:\n\t\t\t\t\tHINTCMD_ADDR (node, \"ahF 0x%\"PFMT64x, record->stackframe);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_PTR:\n\t\t\t\t\tHINTCMD_ADDR (node, \"ahp 0x%\"PFMT64x, record->ptr);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_NWORD:\n\t\t\t\t\t// no command for this\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_RET:\n\t\t\t\t\tHINTCMD_ADDR (node, \"ahr 0x%\"PFMT64x, record->retval);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_NEW_BITS:\n\t\t\t\t\t// no command for this\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_SIZE:\n\t\t\t\t\tHINTCMD_ADDR (node, \"ahs 0x%\"PFMT64x, record->size);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_SYNTAX:\n\t\t\t\t\tHINTCMD_ADDR (node, \"ahS %s\", record->syntax); // TODO: escape for newcmd\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_OPTYPE: {\n\t\t\t\t\tconst char *type = r_anal_optype_to_string (record->optype);\n\t\t\t\t\tif (type) {\n\t\t\t\t\t\tHINTCMD_ADDR (node, \"aho %s\", type); // TODO: escape for newcmd\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_OPCODE:\n\t\t\t\t\tHINTCMD_ADDR (node, \"ahd %s\", record->opcode);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_TYPE_OFFSET:\n\t\t\t\t\tHINTCMD_ADDR (node, \"aht %s\", record->type_offset); // TODO: escape for newcmd\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_ESIL:\n\t\t\t\t\tHINTCMD_ADDR (node, \"ahe %s\", record->esil); // TODO: escape for newcmd\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_HIGH:\n\t\t\t\t\tr_cons_printf (\"ahh @ 0x%\"PFMT64x\"\\n\", node->addr);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_VAL:\n\t\t\t\t\t// no command for this\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase HINT_NODE_ARCH:\n\t\t\tHINTCMD_ADDR (node, \"aha %s\", r_str_get_fail (node->arch, \"0\"));\n\t\t\tbreak;\n\t\tcase HINT_NODE_BITS:\n\t\t\tHINTCMD_ADDR (node, \"ahb %d\", node->bits);\n\t\t\tbreak;\n\t\t}\n#undef HINTCMD_ADDR\n\t\tbreak;\n\tcase 'j':\n\t\tswitch (node->type) {\n\t\tcase HINT_NODE_ADDR: {\n\t\t\tconst RAnalAddrHintRecord *record;\n\t\t\tr_vector_foreach (node->addr_hints, record) {\n\t\t\t\tswitch (record->type) {\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_IMMBASE:\n\t\t\t\t\tpj_ki (pj, \"immbase\", record->immbase);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_JUMP:\n\t\t\t\t\tpj_kn (pj, \"jump\", record->jump);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_FAIL:\n\t\t\t\t\tpj_kn (pj, \"fail\", record->fail);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_STACKFRAME:\n\t\t\t\t\tpj_kn (pj, \"stackframe\", record->stackframe);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_PTR:\n\t\t\t\t\tpj_kn (pj, \"ptr\", record->ptr);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_NWORD:\n\t\t\t\t\tpj_ki (pj, \"nword\", record->nword);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_RET:\n\t\t\t\t\tpj_kn (pj, \"ret\", record->retval);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_NEW_BITS:\n\t\t\t\t\tpj_ki (pj, \"newbits\", record->newbits);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_SIZE:\n\t\t\t\t\tpj_kn (pj, \"size\", record->size);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_SYNTAX:\n\t\t\t\t\tpj_ks (pj, \"syntax\", record->syntax);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_OPTYPE: {\n\t\t\t\t\tconst char *type = r_anal_optype_to_string (record->optype);\n\t\t\t\t\tif (type) {\n\t\t\t\t\t\tpj_ks (pj, \"type\", type);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_OPCODE:\n\t\t\t\t\tpj_ks (pj, \"opcode\", record->opcode);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_TYPE_OFFSET:\n\t\t\t\t\tpj_ks (pj, \"offset\", record->type_offset);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_ESIL:\n\t\t\t\t\tpj_ks (pj, \"esil\", record->esil);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_HIGH:\n\t\t\t\t\tpj_kb (pj, \"high\", true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_VAL:\n\t\t\t\t\tpj_kn (pj, \"val\", record->val);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase HINT_NODE_ARCH:\n\t\t\tif (node->arch) {\n\t\t\t\tpj_ks (pj, \"arch\", node->arch);\n\t\t\t} else {\n\t\t\t\tpj_knull (pj, \"arch\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HINT_NODE_BITS:\n\t\t\tpj_ki (pj, \"bits\", node->bits);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprint_hint_h_format (node);\n\t\tbreak;\n\t}\n}\n\nvoid hint_node_free(RBNode *node, void *user) {\n\tfree (container_of (node, HintNode, rb));\n}\n\nint hint_node_cmp(const void *incoming, const RBNode *in_tree, void *user) {\n\tut64 ia = *(ut64 *)incoming;\n\tut64 ta = container_of (in_tree, const HintNode, rb)->addr;\n\tif (ia < ta) {\n\t\treturn -1;\n\t} else if (ia > ta) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nbool print_addr_hint_cb(ut64 addr, const RVector/*<const RAnalAddrHintRecord>*/ *records, void *user) {\n\tHintNode *node = R_NEW0 (HintNode);\n\tif (!node) {\n\t\treturn false;\n\t}\n\tnode->addr = addr;\n\tnode->type = HINT_NODE_ADDR;\n\tnode->addr_hints = records;\n\tr_rbtree_insert (user, &addr, &node->rb, hint_node_cmp, NULL);\n\treturn true;\n}\n\nbool print_arch_hint_cb(ut64 addr, R_NULLABLE const char *arch, void *user) {\n\tHintNode *node = R_NEW0 (HintNode);\n\tif (!node) {\n\t\treturn false;\n\t}\n\tnode->addr = addr;\n\tnode->type = HINT_NODE_ARCH;\n\tnode->arch = arch;\n\tr_rbtree_insert (user, &addr, &node->rb, hint_node_cmp, NULL);\n\treturn true;\n}\n\nbool print_bits_hint_cb(ut64 addr, int bits, void *user) {\n\tHintNode *node = R_NEW0 (HintNode);\n\tif (!node) {\n\t\treturn false;\n\t}\n\tnode->addr = addr;\n\tnode->type = HINT_NODE_BITS;\n\tnode->bits = bits;\n\tr_rbtree_insert (user, &addr, &node->rb, hint_node_cmp, NULL);\n\treturn true;\n}\n\nstatic void print_hint_tree(RBTree tree, int mode) {\n#define END_ADDR if (mode == 'j') { pj_end (pj); } else if (mode != '*') { r_cons_newline (); }\n\tPJ *pj = NULL;\n\tif (mode == 'j') {\n\t\tpj = pj_new ();\n\t\tpj_a (pj);\n\t}\n\tRBIter it;\n\tHintNode *node;\n\tut64 last_addr = 0;\n\tbool in_addr = false;\n\tr_rbtree_foreach (tree, it, node, HintNode, rb) {\n\t\tif (!in_addr || last_addr != node->addr) {\n\t\t\tif (in_addr) {\n\t\t\t\tEND_ADDR\n\t\t\t}\n\t\t\tin_addr = true;\n\t\t\tlast_addr = node->addr;\n\t\t\tif (pj) {\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_kn (pj, \"addr\", node->addr);\n\t\t\t} else if (mode != '*') {\n\t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x\" =>\", node->addr);\n\t\t\t}\n\t\t}\n\t\thint_node_print (node, mode, pj);\n\t}\n\tif (in_addr) {\n\t\tEND_ADDR\n\t}\n\tif (pj) {\n\t\tpj_end (pj);\n\t\tr_cons_printf (\"%s\\n\", pj_string (pj));\n\t\tpj_free (pj);\n\t}\n#undef END_ADDR\n}\n\nR_API void r_core_anal_hint_list(RAnal *a, int mode) {\n\tRBTree tree = NULL;\n\t// Collect all hints in the tree to sort them\n\tr_anal_arch_hints_foreach (a, print_arch_hint_cb, &tree);\n\tr_anal_bits_hints_foreach (a, print_bits_hint_cb, &tree);\n\tr_anal_addr_hints_foreach (a, print_addr_hint_cb, &tree);\n\tprint_hint_tree (tree, mode);\n\tr_rbtree_free (tree, hint_node_free, NULL);\n}\n\nR_API void r_core_anal_hint_print(RAnal* a, ut64 addr, int mode) {\n\tRBTree tree = NULL;\n\tut64 hint_addr = UT64_MAX;\n\tconst char *arch = r_anal_hint_arch_at(a, addr, &hint_addr);\n\tif (hint_addr != UT64_MAX) {\n\t\tprint_arch_hint_cb (hint_addr, arch, &tree);\n\t}\n\tint bits = r_anal_hint_bits_at (a, addr, &hint_addr);\n\tif (hint_addr != UT64_MAX) {\n\t\tprint_bits_hint_cb (hint_addr, bits, &tree);\n\t}\n\tconst RVector *addr_hints = r_anal_addr_hints_at (a, addr);\n\tif (addr_hints) {\n\t\tprint_addr_hint_cb (addr, addr_hints, &tree);\n\t}\n\tprint_hint_tree (tree, mode);\n\tr_rbtree_free (tree, hint_node_free, NULL);\n}\n\nstatic char *core_anal_graph_label(RCore *core, RAnalBlock *bb, int opts) {\n\tint is_html = r_cons_context ()->is_html;\n\tint is_json = opts & R_CORE_ANAL_JSON;\n\tchar cmd[1024], file[1024], *cmdstr = NULL, *filestr = NULL, *str = NULL;\n\tint line = 0, oline = 0, idx = 0;\n\tut64 at;\n\n\tif (opts & R_CORE_ANAL_GRAPHLINES) {\n\t\tfor (at = bb->addr; at < bb->addr + bb->size; at += 2) {\n\t\t\tr_bin_addr2line (core->bin, at, file, sizeof (file) - 1, &line);\n\t\t\tif (line != 0 && line != oline && strcmp (file, \"??\")) {\n\t\t\t\tfilestr = r_file_slurp_line (file, line, 0);\n\t\t\t\tif (filestr) {\n\t\t\t\t\tint flen = strlen (filestr);\n\t\t\t\t\tcmdstr = realloc (cmdstr, idx + flen + 8);\n\t\t\t\t\tmemcpy (cmdstr + idx, filestr, flen);\n\t\t\t\t\tidx += flen;\n\t\t\t\t\tif (is_json) {\n\t\t\t\t\t\tstrcpy (cmdstr + idx, \"\\\\n\");\n\t\t\t\t\t\tidx += 2;\n\t\t\t\t\t} else if (is_html) {\n\t\t\t\t\t\tstrcpy (cmdstr + idx, \"<br />\");\n\t\t\t\t\t\tidx += 6;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstrcpy (cmdstr + idx, \"\\\\l\");\n\t\t\t\t\t\tidx += 2;\n\t\t\t\t\t}\n\t\t\t\t\tfree (filestr);\n\t\t\t\t}\n\t\t\t}\n\t\t\toline = line;\n\t\t}\n\t} else if (opts & R_CORE_ANAL_STAR) {\n\t\tsnprintf (cmd, sizeof (cmd), \"pdb %\"PFMT64u\" @ 0x%08\" PFMT64x, bb->size, bb->addr);\n\t\tstr = r_core_cmd_str (core, cmd);\n\t} else if (opts & R_CORE_ANAL_GRAPHBODY) {\n\t\tconst bool scrColor = r_config_get (core->config, \"scr.color\");\n\t\tconst bool scrUtf8 = r_config_get (core->config, \"scr.utf8\");\n\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n\t\tr_config_set (core->config, \"scr.utf8\", \"false\");\n\t\tsnprintf (cmd, sizeof (cmd), \"pD %\"PFMT64u\" @ 0x%08\" PFMT64x, bb->size, bb->addr);\n\t\tcmdstr = r_core_cmd_str (core, cmd);\n\t\tr_config_set_i (core->config, \"scr.color\", scrColor);\n\t\tr_config_set_i (core->config, \"scr.utf8\", scrUtf8);\n\t}\n\tif (cmdstr) {\n\t\tstr = r_str_escape_dot (cmdstr);\n\t\tfree (cmdstr);\n\t}\n\treturn str;\n}\n\nstatic char *palColorFor(const char *k) {\n\tif (!r_cons_singleton ()) {\n\t\treturn NULL;\n\t}\n\tRColor rcolor = r_cons_pal_get (k);\n\treturn r_cons_rgb_tostring (rcolor.r, rcolor.g, rcolor.b);\n}\n\nstatic void core_anal_color_curr_node(RCore *core, RAnalBlock *bbi) {\n\tbool color_current = r_config_get_i (core->config, \"graph.gv.current\");\n\tchar *pal_curr = palColorFor (\"graph.current\");\n\tbool current = r_anal_block_contains (bbi, core->offset);\n\n\tif (current && color_current) {\n\t\tr_cons_printf (\"\\t\\\"0x%08\"PFMT64x\"\\\" \", bbi->addr);\n\t\tr_cons_printf (\"\\t[fillcolor=%s style=filled shape=box];\\n\", pal_curr);\n\t}\n\tfree (pal_curr);\n}\n\nstatic int core_anal_graph_construct_edges(RCore *core, RAnalFunction *fcn, int opts, PJ *pj, Sdb *DB) {\n\tRAnalBlock *bbi;\n\tRListIter *iter;\n\tint is_keva = opts & R_CORE_ANAL_KEYVALUE;\n\tint is_star = opts & R_CORE_ANAL_STAR;\n\tint is_json = opts & R_CORE_ANAL_JSON;\n\tint is_html = r_cons_context ()->is_html;\n\tchar *pal_jump = palColorFor (\"graph.true\");\n\tchar *pal_fail = palColorFor (\"graph.false\");\n\tchar *pal_trfa = palColorFor (\"graph.trufae\");\n\tint nodes = 0;\n\tr_list_foreach (fcn->bbs, iter, bbi) {\n\t\tif (bbi->jump != UT64_MAX) {\n\t\t\tnodes++;\n\t\t\tif (is_keva) {\n\t\t\t\tchar key[128];\n\t\t\t\tchar val[128];\n\t\t\t\tsnprintf (key, sizeof (key), \"bb.0x%08\"PFMT64x\".to\", bbi->addr);\n\t\t\t\tif (bbi->fail != UT64_MAX) {\n\t\t\t\t\tsnprintf (val, sizeof (val), \"0x%08\"PFMT64x, bbi->jump);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf (val, sizeof (val), \"0x%08\"PFMT64x \",0x%08\"PFMT64x,\n\t\t\t\t\t\t\tbbi->jump, bbi->fail);\n\t\t\t\t}\n\t\t\t\t// bb.<addr>.to=<jump>,<fail>\n\t\t\t\tsdb_set (DB, key, val, 0);\n\t\t\t} else if (is_html) {\n\t\t\t\tr_cons_printf (\"<div class=\\\"connector _0x%08\"PFMT64x\" _0x%08\"PFMT64x\"\\\">\\n\"\n\t\t\t\t\t\t\"  <img class=\\\"connector-end\\\" src=\\\"img/arrow.gif\\\" /></div>\\n\",\n\t\t\t\t\t\tbbi->addr, bbi->jump);\n\t\t\t} else if (!is_json && !is_keva) {\n\t\t\t\tif (is_star) {\n\t\t\t\t\tchar *from = get_title (bbi->addr);\n\t\t\t\t\tchar *to = get_title (bbi->jump);\n\t\t\t\t\tr_cons_printf (\"age %s %s\\n\", from, to);\n\t\t\t\t\tfree (from);\n\t\t\t\t\tfree (to);\n\t\t\t\t} else {\n\t\t\t\t\tr_strf_buffer (128);\n\t\t\t\t\tconst char* edge_color = bbi->fail != -1 ? pal_jump : pal_trfa;\n\t\t\t\t\tif (sdb_const_get (core->sdb, r_strf (\"agraph.edge.0x%\"PFMT64x\"_0x%\"PFMT64x\".highlight\", bbi->addr, bbi->jump), 0)) {\n\t\t\t\t\t\tedge_color = \"cyan\";\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_printf (\"        \\\"0x%08\"PFMT64x\"\\\" -> \\\"0x%08\"PFMT64x\"\\\" \"\n\t\t\t\t\t\t\t\"[color=\\\"%s\\\"];\\n\", bbi->addr, bbi->jump, edge_color);\n\t\t\t\t\tcore_anal_color_curr_node (core, bbi);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bbi->fail != -1) {\n\t\t\tnodes++;\n\t\t\tif (is_html) {\n\t\t\t\tr_cons_printf (\"<div class=\\\"connector _0x%08\"PFMT64x\" _0x%08\"PFMT64x\"\\\">\\n\"\n\t\t\t\t\t\t\"  <img class=\\\"connector-end\\\" src=\\\"img/arrow.gif\\\"/></div>\\n\",\n\t\t\t\t\t\tbbi->addr, bbi->fail);\n\t\t\t} else if (!is_keva && !is_json) {\n\t\t\t\tif (is_star) {\n\t\t\t\t\tchar *from = get_title (bbi->addr);\n\t\t\t\t\tchar *to = get_title (bbi->fail);\n\t\t\t\t\tr_cons_printf (\"age %s %s\\n\", from, to);\n\t\t\t\t\tfree(from);\n\t\t\t\t\tfree(to);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"        \\\"0x%08\"PFMT64x\"\\\" -> \\\"0x%08\"PFMT64x\"\\\" \"\n\t\t\t\t\t\t\t\t\t\"[color=\\\"%s\\\"];\\n\", bbi->addr, bbi->fail, pal_fail);\n\t\t\t\t\tcore_anal_color_curr_node (core, bbi);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bbi->switch_op) {\n\t\t\tRAnalCaseOp *caseop;\n\t\t\tRListIter *iter;\n\n\t\t\tif (bbi->fail != UT64_MAX) {\n\t\t\t\tif (is_html) {\n\t\t\t\t\tr_cons_printf (\"<div class=\\\"connector _0x%08\"PFMT64x\" _0x%08\"PFMT64x\"\\\">\\n\"\n\t\t\t\t\t\t\t\"  <img class=\\\"connector-end\\\" src=\\\"img/arrow.gif\\\"/></div>\\n\",\n\t\t\t\t\t\t\tbbi->addr, bbi->fail);\n\t\t\t\t} else if (!is_keva && !is_json) {\n\t\t\t\t\tif (is_star) {\n\t\t\t\t\t\tchar *from = get_title (bbi->addr);\n\t\t\t\t\t\tchar *to = get_title (bbi->fail);\n\t\t\t\t\t\tr_cons_printf (\"age %s %s\\n\", from, to);\n\t\t\t\t\t\tfree(from);\n\t\t\t\t\t\tfree(to);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"        \\\"0x%08\"PFMT64x\"\\\" -> \\\"0x%08\"PFMT64x\"\\\" \"\n\t\t\t\t\t\t\t\t\"[color=\\\"%s\\\"];\\n\", bbi->addr, bbi->fail, pal_fail);\n\t\t\t\t\t\tcore_anal_color_curr_node (core, bbi);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_list_foreach (bbi->switch_op->cases, iter, caseop) {\n\t\t\t\tnodes++;\n\t\t\t\tif (is_keva) {\n\t\t\t\t\tchar key[128];\n\t\t\t\t\tsnprintf (key, sizeof (key),\n\t\t\t\t\t\t\t\"bb.0x%08\"PFMT64x\".switch.%\"PFMT64d,\n\t\t\t\t\t\t\tbbi->addr, caseop->value);\n\t\t\t\t\tsdb_num_set (DB, key, caseop->jump, 0);\n\t\t\t\t\tsnprintf (key, sizeof (key),\n\t\t\t\t\t\t\t\"bb.0x%08\"PFMT64x\".switch\", bbi->addr);\n\t\t\t\t\t\t\tsdb_array_add_num (DB, key, caseop->value, 0);\n\t\t\t\t} else if (is_html) {\n\t\t\t\t\tr_cons_printf (\"<div class=\\\"connector _0x%08\" PFMT64x \" _0x%08\" PFMT64x \"\\\">\\n\"\n\t\t\t\t\t\t\t\"  <img class=\\\"connector-end\\\" src=\\\"img/arrow.gif\\\"/></div>\\n\",\n\t\t\t\t\t\t\tbbi->addr, caseop->addr);\n\t\t\t\t} else if (!is_json && !is_keva) {\n\t\t\t\t\tif (is_star) {\n\t\t\t\t\t\tchar *from = get_title (bbi->addr);\n\t\t\t\t\t\tchar *to = get_title (caseop->addr);\n\t\t\t\t\t\tr_cons_printf (\"age %s %s\\n\", from ,to);\n\t\t\t\t\t\tfree (from);\n\t\t\t\t\t\tfree (to);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"        \\\"0x%08\" PFMT64x \"\\\" -> \\\"0x%08\" PFMT64x \"\\\" \"\n\t\t\t\t\t\t\t\t\"[color=\\\"%s\\\"];\\n\",\n\t\t\t\t\t\t\t\tbbi->addr, caseop->addr, pal_trfa);\n\t\t\t\t\t\tcore_anal_color_curr_node (core, bbi);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfree(pal_jump);\n\tfree(pal_fail);\n\tfree(pal_trfa);\n\treturn nodes;\n}\n\nstatic int core_anal_graph_construct_nodes(RCore *core, RAnalFunction *fcn, int opts, PJ *pj, Sdb *DB) {\n\tRAnalBlock *bbi;\n\tRListIter *iter;\n\tint is_keva = opts & R_CORE_ANAL_KEYVALUE;\n\tint is_star = opts & R_CORE_ANAL_STAR;\n\tint is_json = opts & R_CORE_ANAL_JSON;\n\tint is_html = r_cons_context ()->is_html;\n\tint left = 300;\n\tint top = 0;\n\n\tint is_json_format_disasm = opts & R_CORE_ANAL_JSON_FORMAT_DISASM;\n\tchar *pal_curr = palColorFor (\"graph.current\");\n\tchar *pal_traced = palColorFor (\"graph.traced\");\n\tchar *pal_box4 = palColorFor (\"graph.box4\");\n\tconst char *font = r_config_get (core->config, \"graph.font\");\n\tbool color_current = r_config_get_i (core->config, \"graph.gv.current\");\n\tchar *str;\n\tint nodes = 0;\n\tr_list_foreach (fcn->bbs, iter, bbi) {\n\t\tif (is_keva) {\n\t\t\tchar key[128];\n\t\t\tsdb_array_push_num (DB, \"bbs\", bbi->addr, 0);\n\t\t\tsnprintf (key, sizeof (key), \"bb.0x%08\"PFMT64x\".size\", bbi->addr);\n\t\t\tsdb_num_set (DB, key, bbi->size, 0); // bb.<addr>.size=<num>\n\t\t} else if (is_json) {\n\t\t\tRDebugTracepoint *t = r_debug_trace_get (core->dbg, bbi->addr);\n\t\t\tpj_o (pj);\n\t\t\tpj_kn (pj, \"offset\", bbi->addr);\n\t\t\tpj_kn (pj, \"size\", bbi->size);\n\t\t\tif (bbi->jump != UT64_MAX) {\n\t\t\t\tpj_kn (pj, \"jump\", bbi->jump);\n\t\t\t}\n\t\t\tif (bbi->fail != -1) {\n\t\t\t\tpj_kn (pj, \"fail\", bbi->fail);\n\t\t\t}\n\t\t\tif (bbi->switch_op) {\n\t\t\t\tRAnalSwitchOp *op = bbi->switch_op;\n\t\t\t\tpj_k (pj, \"switchop\");\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_kn (pj, \"offset\", op->addr);\n\t\t\t\tpj_kn (pj, \"defval\", op->def_val);\n\t\t\t\tpj_kn (pj, \"maxval\", op->max_val);\n\t\t\t\tpj_kn (pj, \"minval\", op->min_val);\n\t\t\t\tpj_k (pj, \"cases\");\n\t\t\t\tpj_a (pj);\n\t\t\t\tRAnalCaseOp *case_op;\n\t\t\t\tRListIter *case_iter;\n\t\t\t\tr_list_foreach (op->cases, case_iter, case_op) {\n\t\t\t\t\tpj_o (pj);\n\t\t\t\t\tpj_kn (pj, \"offset\", case_op->addr);\n\t\t\t\t\tpj_kn (pj, \"value\", case_op->value);\n\t\t\t\t\tpj_kn (pj, \"jump\", case_op->jump);\n\t\t\t\t\tpj_end (pj);\n\t\t\t\t}\n\t\t\t\tpj_end (pj);\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t\tif (t) {\n\t\t\t\tpj_k (pj, \"trace\");\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_ki (pj, \"count\", t->count);\n\t\t\t\tpj_ki (pj, \"times\", t->times);\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t\tif (bbi->color.r || bbi->color.g || bbi->color.b) {\n\t\t\t\tchar *s = r_cons_rgb_tostring (bbi->color.r, bbi->color.g, bbi->color.b);\n\t\t\t\tpj_ks (pj, \"color\", s);\n\t\t\t\tfree (s);\n\t\t\t}\n\t\t\tpj_k (pj, \"ops\");\n\t\t\tpj_a (pj);\n\t\t\tut8 *buf = malloc (bbi->size);\n\t\t\tif (buf) {\n\t\t\t\tr_io_read_at (core->io, bbi->addr, buf, bbi->size);\n\t\t\t\tif (is_json_format_disasm) {\n\t\t\t\t\tr_core_print_disasm (core, bbi->addr, buf, bbi->size, bbi->size, 0, NULL, true, true, pj, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tr_core_print_disasm_json (core, bbi->addr, buf, bbi->size, 0, pj);\n\t\t\t\t}\n\t\t\t\tfree (buf);\n\t\t\t} else {\n\t\t\t\teprintf (\"cannot allocate %\"PFMT64u\" byte(s)\\n\", bbi->size);\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t\tpj_end (pj);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((str = core_anal_graph_label (core, bbi, opts))) {\n\t\t\tif (opts & R_CORE_ANAL_GRAPHDIFF) {\n\t\t\t\tconst char *difftype = bbi->diff? (\\\n\t\t\t\tbbi->diff->type==R_ANAL_DIFF_TYPE_MATCH? \"lightgray\":\n\t\t\t\tbbi->diff->type==R_ANAL_DIFF_TYPE_UNMATCH? \"yellow\": \"red\"): \"orange\";\n\t\t\t\tconst char *diffname = bbi->diff? (\\\n\t\t\t\tbbi->diff->type==R_ANAL_DIFF_TYPE_MATCH? \"match\":\n\t\t\t\tbbi->diff->type==R_ANAL_DIFF_TYPE_UNMATCH? \"unmatch\": \"new\"): \"unk\";\n\t\t\t\tif (is_keva) {\n\t\t\t\t\tsdb_set (DB, \"diff\", diffname, 0);\n\t\t\t\t\tsdb_set (DB, \"label\", str, 0);\n\t\t\t\t} else if (!is_json) {\n\t\t\t\t\tnodes++;\n\t\t\t\t\tRConfigHold *hc = r_config_hold_new (core->config);\n\t\t\t\t\tr_config_hold (hc, \"scr.color\", \"scr.utf8\", \"asm.offset\", \"asm.lines\",\n\t\t\t\t\t\t\t\"asm.cmt.right\", \"asm.lines.fcn\", \"asm.bytes\", NULL);\n\t\t\t\t\tRDiff *d = r_diff_new ();\n\t\t\t\t\tr_config_set_i (core->config, \"scr.utf8\", 0);\n\t\t\t\t\tr_config_set_i (core->config, \"asm.offset\", 0);\n\t\t\t\t\tr_config_set_i (core->config, \"asm.lines\", 0);\n\t\t\t\t\tr_config_set_i (core->config, \"asm.cmt.right\", 0);\n\t\t\t\t\tr_config_set_i (core->config, \"asm.lines.fcn\", 0);\n\t\t\t\t\tr_config_set_i (core->config, \"asm.bytes\", 0);\n\t\t\t\t\tif (!is_star) {\n\t\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\t// disable color for dot\n\t\t\t\t\t}\n\n\t\t\t\t\tif (bbi->diff && bbi->diff->type != R_ANAL_DIFF_TYPE_MATCH && core->c2) {\n\t\t\t\t\t\tRCore *c = core->c2;\n\t\t\t\t\t\tRConfig *oc = c->config;\n\t\t\t\t\t\tchar *str = r_core_cmd_strf (core, \"pdb @ 0x%08\"PFMT64x, bbi->addr);\n\t\t\t\t\t\tc->config = core->config;\n\t\t\t\t\t\t// XXX. the bbi->addr doesnt needs to be in the same address in core2\n\t\t\t\t\t\tchar *str2 = r_core_cmd_strf (c, \"pdb @ 0x%08\"PFMT64x, bbi->diff->addr);\n\t\t\t\t\t\tchar *diffstr = r_diff_buffers_to_string (d,\n\t\t\t\t\t\t\t\t(const ut8*)str, strlen (str),\n\t\t\t\t\t\t\t\t(const ut8*)str2, strlen (str2));\n\n\t\t\t\t\t\tif (diffstr) {\n\t\t\t\t\t\t\tchar *nl = strchr (diffstr, '\\n');\n\t\t\t\t\t\t\tif (nl) {\n\t\t\t\t\t\t\t\tnl = strchr (nl + 1, '\\n');\n\t\t\t\t\t\t\t\tif (nl) {\n\t\t\t\t\t\t\t\t\tnl = strchr (nl + 1, '\\n');\n\t\t\t\t\t\t\t\t\tif (nl) {\n\t\t\t\t\t\t\t\t\t\tr_str_cpy (diffstr, nl + 1);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (is_star) {\n\t\t\t\t\t\t\tchar *title = get_title (bbi->addr);\n\t\t\t\t\t\t\tchar *body_b64 = r_base64_encode_dyn (diffstr, -1);\n\t\t\t\t\t\t\tif (!title  || !body_b64) {\n\t\t\t\t\t\t\t\tfree (body_b64);\n\t\t\t\t\t\t\t\tfree (title);\n\t\t\t\t\t\t\t\tr_diff_free (d);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbody_b64 = r_str_prepend (body_b64, \"base64:\");\n\t\t\t\t\t\t\tr_cons_printf (\"agn %s %s %d\\n\", title, body_b64, bbi->diff->type);\n\t\t\t\t\t\t\tfree (body_b64);\n\t\t\t\t\t\t\tfree (title);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdiffstr = r_str_replace (diffstr, \"\\n\", \"\\\\l\", 1);\n\t\t\t\t\t\t\tdiffstr = r_str_replace (diffstr, \"\\\"\", \"'\", 1);\n\t\t\t\t\t\t\tr_cons_printf(\" \\\"0x%08\"PFMT64x\"\\\" [fillcolor=\\\"%s\\\",\"\n\t\t\t\t\t\t\t\"color=\\\"black\\\", fontname=\\\"%s\\\",\"\n\t\t\t\t\t\t\t\" label=\\\"%s\\\", URL=\\\"%s/0x%08\"PFMT64x\"\\\"]\\n\",\n\t\t\t\t\t\t\tbbi->addr, difftype, font, diffstr, fcn->name,\n\t\t\t\t\t\t\tbbi->addr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (diffstr);\n\t\t\t\t\t\tc->config = oc;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (is_star) {\n\t\t\t\t\t\t\tchar *title = get_title (bbi->addr);\n\t\t\t\t\t\t\tchar *body_b64 = r_base64_encode_dyn (str, -1);\n\t\t\t\t\t\t\tint color = (bbi && bbi->diff) ? bbi->diff->type : 0;\n\t\t\t\t\t\t\tif (!title  || !body_b64) {\n\t\t\t\t\t\t\t\tfree (body_b64);\n\t\t\t\t\t\t\t\tfree (title);\n\t\t\t\t\t\t\t\tr_diff_free (d);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbody_b64 = r_str_prepend (body_b64, \"base64:\");\n\t\t\t\t\t\t\tr_cons_printf (\"agn %s %s %d\\n\", title, body_b64, color);\n\t\t\t\t\t\t\tfree (body_b64);\n\t\t\t\t\t\t\tfree (title);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_printf(\" \\\"0x%08\"PFMT64x\"\\\" [fillcolor=\\\"%s\\\",\"\n\t\t\t\t\t\t\t\t\t\"color=\\\"black\\\", fontname=\\\"%s\\\",\"\n\t\t\t\t\t\t\t\t\t\" label=\\\"%s\\\", URL=\\\"%s/0x%08\"PFMT64x\"\\\"]\\n\",\n\t\t\t\t\t\t\t\t\tbbi->addr, difftype, font, str, fcn->name, bbi->addr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr_diff_free (d);\n\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", 1);\n\t\t\t\t\tr_config_hold_free (hc);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (is_html) {\n\t\t\t\t\t\tnodes++;\n\t\t\t\t\t\tr_cons_printf (\"<p class=\\\"block draggable\\\" style=\\\"\"\n\t\t\t\t\t\t\t\t\t\t\t\t\"top: %dpx; left: %dpx; width: 400px;\\\" id=\\\"\"\n\t\t\t\t\t\t\t\t\t\t\t\t\"_0x%08\"PFMT64x\"\\\">\\n%s</p>\\n\",\n\t\t\t\t\t\t\t\t\t\t\t\ttop, left, bbi->addr, str);\n\t\t\t\t\t\tleft = left? 0: 600;\n\t\t\t\t\t\tif (!left) {\n\t\t\t\t\t\t\t\ttop += 250;\n\t\t\t\t\t\t}\n\t\t\t\t} else if (!is_json && !is_keva) {\n\t\t\t\t\tbool current = r_anal_block_contains (bbi, core->offset);\n\t\t\t\t\tconst char *label_color = bbi->traced\n\t\t\t\t\t\t\t? pal_traced\n\t\t\t\t\t\t\t: (current && color_current)\n\t\t\t\t\t\t\t? pal_curr\n\t\t\t\t\t\t\t: pal_box4;\n\t\t\t\t\tconst char *fill_color = ((current && color_current) || label_color == pal_traced)? pal_traced: \"white\";\n\t\t\t\t\tnodes++;\n\t\t\t\t\tif (is_star) {\n\t\t\t\t\t\tchar *title = get_title (bbi->addr);\n\t\t\t\t\t\tchar *body_b64 = r_base64_encode_dyn (str, -1);\n\t\t\t\t\t\tint color = (bbi && bbi->diff) ? bbi->diff->type : 0;\n\t\t\t\t\t\tif (!title  || !body_b64) {\n\t\t\t\t\t\t\t\tfree (body_b64);\n\t\t\t\t\t\t\t\tfree (title);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbody_b64 = r_str_prepend (body_b64, \"base64:\");\n\t\t\t\t\t\tr_cons_printf (\"agn %s %s %d\\n\", title, body_b64, color);\n\t\t\t\t\t\tfree (body_b64);\n\t\t\t\t\t\tfree (title);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"\\t\\\"0x%08\"PFMT64x\"\\\" [\"\n\t\t\t\t\t\t\t\t\"URL=\\\"%s/0x%08\"PFMT64x\"\\\", fillcolor=\\\"%s\\\",\"\n\t\t\t\t\t\t\t\t\"color=\\\"%s\\\", fontname=\\\"%s\\\",\"\n\t\t\t\t\t\t\t\t\"label=\\\"%s\\\"]\\n\",\n\t\t\t\t\t\t\t\tbbi->addr, fcn->name, bbi->addr,\n\t\t\t\t\t\t\t\tfill_color, label_color, font, str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (str);\n\t\t}\n\t}\n\treturn nodes;\n}\n\nstatic int core_anal_graph_nodes(RCore *core, RAnalFunction *fcn, int opts, PJ *pj) {\n\tint is_json = opts & R_CORE_ANAL_JSON;\n\tint is_keva = opts & R_CORE_ANAL_KEYVALUE;\n\tint nodes = 0;\n\tSdb *DB = NULL;\n\tchar *pal_jump = palColorFor (\"graph.true\");\n\tchar *pal_fail = palColorFor (\"graph.false\");\n\tchar *pal_trfa = palColorFor (\"graph.trufae\");\n\tchar *pal_curr = palColorFor (\"graph.current\");\n\tchar *pal_traced = palColorFor (\"graph.traced\");\n\tchar *pal_box4 = palColorFor (\"graph.box4\");\n\tif (!fcn || !fcn->bbs) {\n\t\teprintf (\"No fcn\\n\");\n\t\tfree (pal_jump);\n\t\tfree (pal_fail);\n\t\tfree (pal_trfa);\n\t\tfree (pal_curr);\n\t\tfree (pal_traced);\n\t\tfree (pal_box4);\n\t\treturn -1;\n\t}\n\n\tif (is_keva) {\n\t\tchar ns[64];\n\t\tDB = sdb_ns (core->anal->sdb, \"graph\", 1);\n\t\tsnprintf (ns, sizeof (ns), \"fcn.0x%08\"PFMT64x, fcn->addr);\n\t\tDB = sdb_ns (DB, ns, 1);\n\t}\n\n\tif (is_keva) {\n\t\tchar *ename = sdb_encode ((const ut8*)fcn->name, -1);\n\t\tsdb_set (DB, \"name\", fcn->name, 0);\n\t\tsdb_set (DB, \"ename\", ename, 0);\n\t\tfree (ename);\n\t\tsdb_num_set (DB, \"size\", r_anal_function_linear_size (fcn), 0);\n\t\tif (fcn->maxstack > 0) {\n\t\t\tsdb_num_set (DB, \"stack\", fcn->maxstack, 0);\n\t\t}\n\t\tsdb_set (DB, \"pos\", \"0,0\", 0); // needs to run layout\n\t\tsdb_set (DB, \"type\", r_anal_functiontype_tostring (fcn->type), 0);\n\t} else if (is_json) {\n\t\t// TODO: show vars, refs and xrefs\n\t\tchar *fcn_name_escaped = r_str_escape_utf8_for_json (fcn->name, -1);\n\t\tpj_o (pj);\n\t\tpj_ks (pj, \"name\", r_str_getf (fcn_name_escaped));\n\t\tfree (fcn_name_escaped);\n\t\tpj_kn (pj, \"offset\", fcn->addr);\n\t\tpj_ki (pj, \"ninstr\", fcn->ninstr);\n\t\tpj_ki (pj, \"nargs\", r_anal_var_count_args (fcn));\n\t\tpj_ki (pj, \"nlocals\", r_anal_var_count_locals (fcn));\n\t\tpj_kn (pj, \"size\", r_anal_function_linear_size (fcn));\n\t\tpj_ki (pj, \"stack\", fcn->maxstack);\n\t\tpj_ks (pj, \"type\", r_anal_functiontype_tostring (fcn->type));\n\t\tpj_k (pj, \"blocks\");\n\t\tpj_a (pj);\n\t}\n\tnodes += core_anal_graph_construct_nodes (core, fcn, opts, pj, DB);\n\tnodes += core_anal_graph_construct_edges (core, fcn, opts, pj, DB);\n\tif (is_json) {\n\t\tpj_end (pj);\n\t\tpj_end (pj);\n\t}\n\tfree (pal_jump);\n\tfree (pal_fail);\n\tfree (pal_trfa);\n\tfree (pal_curr);\n\tfree (pal_traced);\n\tfree (pal_box4);\n\treturn nodes;\n}\n\n/* seek basic block that contains address addr or just addr if there's no such\n * basic block */\nR_API bool r_core_anal_bb_seek(RCore *core, ut64 addr) {\n\tut64 bbaddr = r_anal_get_bbaddr (core->anal, addr);\n\tif (bbaddr != UT64_MAX) {\n\t\tr_core_seek (core, bbaddr, false);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_core_anal_esil_fcn(RCore *core, ut64 at, ut64 from, int reftype, int depth) {\n\tconst char *esil;\n\teprintf (\"TODO\\n\");\n\twhile (1) {\n\t\t// TODO: Implement the proper logic for doing esil analysis\n\t\tRAnalOp *op = r_core_anal_op (core, at, R_ANAL_OP_MASK_ESIL);\n\t\tif (!op) {\n\t\t\tbreak;\n\t\t}\n\t\tesil = R_STRBUF_SAFEGET (&op->esil);\n\t\teprintf (\"0x%08\"PFMT64x\" %d %s\\n\", at, op->size, esil);\n\t\t// at += op->size;\n\t\t// esilIsRet()\n\t\t// esilIsCall()\n\t\t// esilIsJmp()\n\t\tr_anal_op_free (op);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int find_sym_flag(const void *a1, const void *a2) {\n\tconst RFlagItem *f = (const RFlagItem *)a2;\n\treturn f->space && !strcmp (f->space->name, R_FLAGS_FS_SYMBOLS)? 0: 1;\n}\n\nstatic bool is_skippable_addr(RCore *core, ut64 addr) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\tif (!fcn) {\n\t\treturn false;\n\t}\n\tif (fcn->addr == addr) {\n\t\treturn true;\n\t}\n\tconst RList *flags = r_flag_get_list (core->flags, addr);\n\treturn !(flags && r_list_find (flags, fcn, find_sym_flag));\n}\n\n// XXX: This function takes sometimes forever\n/* analyze a RAnalFunction at the address 'at'.\n * If the function has been already analyzed, it adds a\n * reference to that fcn */\nR_API bool r_core_anal_fcn(RCore *core, ut64 at, ut64 from, int reftype, int depth) {\n\tif (depth < 0) {\n\t\tif (core->anal->verbose) {\n\t\t\teprintf (\"Message: Early deepness at 0x%08\"PFMT64x\"\\n\", at);\n\t\t}\n\t\treturn false;\n\t}\n\tif (from == UT64_MAX && is_skippable_addr (core, at)) {\n\t\tif (core->anal->verbose) {\n\t\t\teprintf (\"Message: Invalid address for function 0x%08\"PFMT64x\"\\n\", at);\n\t\t}\n\t\treturn false;\n\t}\n\n\tconst bool use_esil = r_config_get_i (core->config, \"anal.esil\");\n\tRAnalFunction *fcn;\n\n\t//update bits based on the core->offset otherwise we could have the\n\t//last value set and blow everything up\n\tr_core_seek_arch_bits (core, at);\n\n\tif (core->io->va) {\n\t\tif (!r_io_is_valid_offset (core->io, at, !core->anal->opt.noncode)) {\n\t\t\tif (core->anal->verbose) {\n\t\t\t\teprintf (\"Warning: Address not mapped or not executable at 0x%08\"PFMT64x\"\\n\", at);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (r_config_get_i (core->config, \"anal.a2f\")) {\n\t\tr_core_cmd0 (core, \".a2f\");\n\t\treturn 0;\n\t}\n\tif (use_esil) {\n\t\treturn r_core_anal_esil_fcn (core, at, from, reftype, depth);\n\t}\n\n\tif ((from != UT64_MAX && !at) || at == UT64_MAX) {\n\t\teprintf (\"Invalid address from 0x%08\"PFMT64x\"\\n\", from);\n\t\treturn false;\n\t}\n\tif (r_cons_is_breaked ()) {\n\t\treturn false;\n\t}\n\tfcn = r_anal_get_fcn_in (core->anal, at, 0);\n\tif (fcn) {\n\t\tif (fcn->addr == at) {\n\t\t\t// if the function was already analyzed as a \"loc.\",\n\t\t\t// convert it to function and rename it to \"fcn.\",\n\t\t\t// because we found a call to this address\n\t\t\tif (reftype == R_ANAL_REF_TYPE_CALL && fcn->type == R_ANAL_FCN_TYPE_LOC) {\n\t\t\t\tfunction_rename (core->flags, fcn);\n\t\t\t}\n\t\t\treturn 0;  // already analyzed function\n\t\t}\n\t\tif (r_anal_function_contains (fcn, from)) { // inner function\n\t\t\tRList *l = r_anal_xrefs_get (core->anal, from);\n\t\t\tif (l && !r_list_empty (l)) {\n\t\t\t\tr_list_free (l);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tr_list_free (l);\n\n\t\t\t// we should analyze and add code ref otherwise aaa != aac\n\t\t\tif (from != UT64_MAX) {\n\t\t\t\tr_anal_xrefs_set (core->anal, from, at, reftype);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (__core_anal_fcn (core, at, from, reftype, depth - 1)) {\n\t\t// split function if overlaps\n\t\tif (fcn) {\n\t\t\tr_anal_function_resize (fcn, at - fcn->addr);\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/* if addr is 0, remove all functions\n * otherwise remove the function addr falls into */\nR_API int r_core_anal_fcn_clean(RCore *core, ut64 addr) {\n\tRAnalFunction *fcni;\n\tRListIter *iter, *iter_tmp;\n\n\tif (!addr) {\n\t\tr_list_purge (core->anal->fcns);\n\t\tif (!(core->anal->fcns = r_list_new ())) {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tr_list_foreach_safe (core->anal->fcns, iter, iter_tmp, fcni) {\n\t\t\tif (r_anal_function_contains (fcni, addr)) {\n\t\t\t\tr_anal_function_delete (fcni);\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nR_API int r_core_print_bb_custom(RCore *core, RAnalFunction *fcn) {\n\tRAnalBlock *bb;\n\tRListIter *iter;\n\tif (!fcn) {\n\t\treturn false;\n\t}\n\n\tRConfigHold *hc = r_config_hold_new (core->config);\n\tr_config_hold (hc, \"scr.color\", \"scr.utf8\", \"asm.marks\", \"asm.offset\", \"asm.lines\",\n\t  \"asm.cmt.right\", \"asm.cmt.col\", \"asm.lines.fcn\", \"asm.bytes\", NULL);\n\t/*r_config_set_i (core->config, \"scr.color\", 0);*/\n\tr_config_set_i (core->config, \"scr.utf8\", 0);\n\tr_config_set_i (core->config, \"asm.marks\", 0);\n\tr_config_set_i (core->config, \"asm.offset\", 0);\n\tr_config_set_i (core->config, \"asm.lines\", 0);\n\tr_config_set_i (core->config, \"asm.cmt.right\", 0);\n\tr_config_set_i (core->config, \"asm.cmt.col\", 0);\n\tr_config_set_i (core->config, \"asm.lines.fcn\", 0);\n\tr_config_set_i (core->config, \"asm.bytes\", 0);\n\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tif (bb->addr == UT64_MAX) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *title = get_title (bb->addr);\n\t\tchar *body = r_core_cmd_strf (core, \"pdb @ 0x%08\"PFMT64x, bb->addr);\n\t\tchar *body_b64 = r_base64_encode_dyn (body, -1);\n\t\tif (!title || !body || !body_b64) {\n\t\t\tfree (body_b64);\n\t\t\tfree (body);\n\t\t\tfree (title);\n\t\t\tr_config_hold_restore (hc);\n\t\t\tr_config_hold_free (hc);\n\t\t\treturn false;\n\t\t}\n\t\tbody_b64 = r_str_prepend (body_b64, \"base64:\");\n\t\tr_cons_printf (\"agn %s %s\\n\", title, body_b64);\n\t\tfree (body);\n\t\tfree (body_b64);\n\t\tfree (title);\n\t}\n\n\tr_config_hold_restore (hc);\n\tr_config_hold_free (hc);\n\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tif (bb->addr == UT64_MAX) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *u = get_title (bb->addr), *v = NULL;\n\t\tif (bb->jump != UT64_MAX) {\n\t\t\tv = get_title (bb->jump);\n\t\t\tr_cons_printf (\"age %s %s\\n\", u, v);\n\t\t\tfree (v);\n\t\t}\n\t\tif (bb->fail != UT64_MAX) {\n\t\t\tv = get_title (bb->fail);\n\t\t\tr_cons_printf (\"age %s %s\\n\", u, v);\n\t\t\tfree (v);\n\t\t}\n\t\tif (bb->switch_op) {\n\t\t\tRListIter *it;\n\t\t\tRAnalCaseOp *cop;\n\t\t\tr_list_foreach (bb->switch_op->cases, it, cop) {\n\t\t\t\tv = get_title (cop->addr);\n\t\t\t\tr_cons_printf (\"age %s %s\\n\", u, v);\n\t\t\t\tfree (v);\n\t\t\t}\n\t\t}\n\t\tfree (u);\n\t}\n\treturn true;\n}\n\n#define USE_ID 1\nR_API int r_core_print_bb_gml(RCore *core, RAnalFunction *fcn) {\n\tRAnalBlock *bb;\n\tRListIter *iter;\n\tif (!fcn) {\n\t\treturn false;\n\t}\n\tint id = 0;\n\tHtUUOptions opt = { 0 };\n\tHtUU *ht = ht_uu_new_opt (&opt);\n\n\tr_cons_printf (\"graph\\n[\\n\" \"hierarchic 1\\n\" \"label \\\"\\\"\\n\" \"directed 1\\n\");\n\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tRFlagItem *flag = r_flag_get_i (core->flags, bb->addr);\n\t\tchar *msg = flag? strdup (flag->name): r_str_newf (\"0x%08\"PFMT64x, bb->addr);\n\t\t// TODO char *str = r_str_escape_dot (msg);\n#if USE_ID\n\t\tht_uu_insert (ht, bb->addr, id);\n\t\tr_cons_printf (\"  node [\\n\"\n\t\t\t\t\"    id  %d\\n\"\n\t\t\t\t\"    label  \\\"%s\\\"\\n\"\n\t\t\t\t\"  ]\\n\", id, msg);\n\t\tid++;\n#else\n\t\tr_cons_printf (\"  node [\\n\"\n\t\t\t\t\"    id  %\"PFMT64d\"\\n\"\n\t\t\t\t\"    label  \\\"%s\\\"\\n\"\n\t\t\t\t\"  ]\\n\", bb->addr, msg);\n#endif\n\t\tfree (msg);\n\t}\n\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tif (bb->addr == UT64_MAX) {\n\t\t\tcontinue;\n\t\t}\n\n#if USE_ID\n\t\tif (bb->jump != UT64_MAX) {\n\t\t\tbool found;\n\t\t\tint i = ht_uu_find (ht, bb->addr, &found);\n\t\t\tif (found) {\n\t\t\t\tint i2 = ht_uu_find (ht, bb->jump, &found);\n\t\t\t\tif (found) {\n\t\t\t\t\tr_cons_printf (\"  edge [\\n\"\n\t\t\t\t\t\t\t\"    source  %d\\n\"\n\t\t\t\t\t\t\t\"    target  %d\\n\"\n\t\t\t\t\t\t\t\"  ]\\n\", i, i2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bb->fail != UT64_MAX) {\n\t\t\tbool found;\n\t\t\tint i = ht_uu_find (ht, bb->addr, &found);\n\t\t\tif (found) {\n\t\t\t\tint i2 = ht_uu_find (ht, bb->fail, &found);\n\t\t\t\tif (found) {\n\t\t\t\t\tr_cons_printf (\"  edge [\\n\"\n\t\t\t\t\t\t\"    source  %d\\n\"\n\t\t\t\t\t\t\"    target  %d\\n\"\n\t\t\t\t\t\t\"  ]\\n\", i, i2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bb->switch_op) {\n\t\t\tRListIter *it;\n\t\t\tRAnalCaseOp *cop;\n\t\t\tr_list_foreach (bb->switch_op->cases, it, cop) {\n\t\t\t\tbool found;\n\t\t\t\tint i = ht_uu_find (ht, bb->addr, &found);\n\t\t\t\tif (found) {\n\t\t\t\t\tint i2 = ht_uu_find (ht, cop->addr, &found);\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\tr_cons_printf (\"  edge [\\n\"\n\t\t\t\t\t\t\t\t\"    source  %d\\n\"\n\t\t\t\t\t\t\t\t\"    target  %d\\n\"\n\t\t\t\t\t\t\t\t\"  ]\\n\", i, i2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#else\n\t\tif (bb->jump != UT64_MAX) {\n\t\t\tr_cons_printf (\"  edge [\\n\"\n\t\t\t\t\"    source  %\"PFMT64d\"\\n\"\n\t\t\t\t\"    target  %\"PFMT64d\"\\n\"\n\t\t\t\t\"  ]\\n\", bb->addr, bb->jump\n\t\t\t\t);\n\t\t}\n\t\tif (bb->fail != UT64_MAX) {\n\t\t\tr_cons_printf (\"  edge [\\n\"\n\t\t\t\t\"    source  %\"PFMT64d\"\\n\"\n\t\t\t\t\"    target  %\"PFMT64d\"\\n\"\n\t\t\t\t\"  ]\\n\", bb->addr, bb->fail\n\t\t\t\t);\n\t\t}\n\t\tif (bb->switch_op) {\n\t\t\tRListIter *it;\n\t\t\tRAnalCaseOp *cop;\n\t\t\tr_list_foreach (bb->switch_op->cases, it, cop) {\n\t\t\t\tr_cons_printf (\"  edge [\\n\"\n\t\t\t\t\t\"    source  %\"PFMT64d\"\\n\"\n\t\t\t\t\t\"    target  %\"PFMT64d\"\\n\"\n\t\t\t\t\t\"  ]\\n\", bb->addr, cop->addr\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tr_cons_printf (\"]\\n\");\n\tht_uu_free (ht);\n\treturn true;\n}\n\nR_API void r_core_anal_datarefs(RCore *core, ut64 addr) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, -1);\n\tif (fcn) {\n\t\tbool found = false;\n\t\tconst char *me = fcn->name;\n\t\tRListIter *iter;\n\t\tRAnalRef *ref;\n\t\tRList *refs = r_anal_function_get_refs (fcn);\n\t\tr_list_foreach (refs, iter, ref) {\n\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n\t\t\tRBinSection *binsec = r_bin_get_section_at (obj, ref->addr, true);\n\t\t\tif (binsec && binsec->is_data) {\n\t\t\t\tif (!found) {\n\t\t\t\t\tr_cons_printf (\"agn %s\\n\", me);\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t\tRFlagItem *item = r_flag_get_i (core->flags, ref->addr);\n\t\t\t\tr_strf_buffer (32);\n\t\t\t\tconst char *dst = item? item->name: r_strf (\"0x%08\"PFMT64x, ref->addr);\n\t\t\t\tr_cons_printf (\"agn %s\\n\", dst);\n\t\t\t\tr_cons_printf (\"age %s %s\\n\", me, dst);\n\t\t\t}\n\t\t}\n\t\tr_list_free (refs);\n\t} else {\n\t\teprintf (\"Not in a function. Use 'df' to define it.\\n\");\n\t}\n}\n\nR_API void r_core_anal_coderefs(RCore *core, ut64 addr) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, -1);\n\tif (fcn) {\n\t\tconst char *me = fcn->name;\n\t\tRListIter *iter;\n\t\tRAnalRef *ref;\n\t\tRList *refs = r_anal_function_get_refs (fcn);\n\t\tr_cons_printf (\"agn %s\\n\", me);\n\t\tr_list_foreach (refs, iter, ref) {\n\t\t\tr_strf_buffer (32);\n\t\t\tRFlagItem *item = r_flag_get_i (core->flags, ref->addr);\n\t\t\tconst char *dst = item? item->name: r_strf (\"0x%08\"PFMT64x, ref->addr);\n\t\t\tr_cons_printf (\"agn %s\\n\", dst);\n\t\t\tr_cons_printf (\"age %s %s\\n\", me, dst);\n\t\t}\n\t\tr_list_free (refs);\n\t} else {\n\t\teprintf(\"Not in a function. Use 'df' to define it.\\n\");\n\t}\n}\n\nstatic void add_single_addr_xrefs(RCore *core, ut64 addr, RGraph *graph) {\n\tr_return_if_fail (graph);\n\tRFlagItem *f = r_flag_get_at (core->flags, addr, false);\n\tchar *me = (f && f->offset == addr)\n\t\t? r_str_new (f->name)\n\t\t: r_str_newf (\"0x%\" PFMT64x, addr);\n\n\tRGraphNode *curr_node = r_graph_add_node_info (graph, me, NULL, addr);\n\tR_FREE (me);\n\tif (!curr_node) {\n\t\treturn;\n\t}\n\tRListIter *iter;\n\tRAnalRef *ref;\n\tRList *list = r_anal_xrefs_get (core->anal, addr);\n\tr_list_foreach (list, iter, ref) {\n\t\tRFlagItem *item = r_flag_get_i (core->flags, ref->addr);\n\t\tchar *src = item? r_str_new (item->name): r_str_newf (\"0x%08\" PFMT64x, ref->addr);\n\t\tRGraphNode *reference_from = r_graph_add_node_info (graph, src, NULL, ref->addr);\n\t\tfree (src);\n\t\tr_graph_add_edge (graph, reference_from, curr_node);\n\t}\n\tr_list_free (list);\n}\n\nR_API RGraph *r_core_anal_importxrefs(RCore *core) {\n\tRBinInfo *info = r_bin_get_info (core->bin);\n\tRBinObject *obj = r_bin_cur_object (core->bin);\n\tbool lit = info? info->has_lit: false;\n\tbool va = core->io->va || r_config_get_b (core->config, \"cfg.debug\");\n\n\tRListIter *iter;\n\tRBinImport *imp;\n\tif (!obj) {\n\t\treturn NULL;\n\t}\n\tRGraph *graph = r_graph_new ();\n\tif (!graph) {\n\t\treturn NULL;\n\t}\n\tr_list_foreach (obj->imports, iter, imp) {\n\t\tut64 addr = lit ? r_core_bin_impaddr (core->bin, va, imp->name): 0;\n\t\tif (addr) {\n\t\t\tadd_single_addr_xrefs (core, addr, graph);\n\t\t} else {\n\t\t\tr_graph_add_node_info (graph, imp->name, NULL, 0);\n\t\t}\n\t}\n\treturn graph;\n}\n\nR_API RGraph *r_core_anal_codexrefs(RCore *core, ut64 addr) {\n\tRGraph *graph = r_graph_new ();\n\tif (!graph) {\n\t\treturn NULL;\n\t}\n\tadd_single_addr_xrefs (core, addr, graph);\n\treturn graph;\n}\n\nstatic ut64 RAnalRef_val(const void *_ref1) {\n\tconst RAnalRef* ref1 = _ref1;\n\treturn ref1->addr;\n}\n\nstatic int RAnalRef_cmp(const RAnalRef* ref1, const RAnalRef* ref2) {\n\treturn ref1->addr != ref2->addr;\n}\n\nR_API void r_core_anal_callgraph(RCore *core, ut64 addr, int fmt) {\n\tconst char *font = r_config_get (core->config, \"graph.font\");\n\tint is_html = r_cons_context ()->is_html;\n\tbool refgraph = r_config_get_i (core->config, \"graph.refs\");\n\tRListIter *iter, *iter2;\n\tint usenames = r_config_get_i (core->config, \"graph.json.usenames\");;\n\tRAnalFunction *fcni;\n\tRAnalRef *fcnr;\n\tPJ *pj = NULL;\n\n\tut64 from = r_config_get_i (core->config, \"graph.from\");\n\tut64 to = r_config_get_i (core->config, \"graph.to\");\n\n\tswitch (fmt) {\n\tcase R_GRAPH_FORMAT_JSON:\n\t\tpj = pj_new ();\n\t\tif (!pj) {\n\t\t\treturn;\n\t\t}\n\t\tpj_a (pj);\n\t\tbreak;\n\tcase R_GRAPH_FORMAT_GML:\n\tcase R_GRAPH_FORMAT_GMLFCN:\n\t\tr_cons_printf (\"graph\\n[\\n\"\n\t\t\t\t\"hierarchic  1\\n\"\n\t\t\t\t\"label  \\\"\\\"\\n\"\n\t\t\t\t\"directed  1\\n\");\n\t\tbreak;\n\tcase R_GRAPH_FORMAT_DOT:\n\t\tif (!is_html) {\n\t\t\tconst char * gv_edge = r_config_get (core->config, \"graph.gv.edge\");\n\t\t\tchar * gv_node = strdup (r_config_get (core->config, \"graph.gv.node\"));\n\t\t\tconst char * gv_grph = r_config_get (core->config, \"graph.gv.graph\");\n\t\t\tconst char * gv_spline = r_config_get (core->config, \"graph.gv.spline\");\n\t\t\tif (!gv_edge || !*gv_edge) {\n\t\t\t\tgv_edge = \"arrowhead=\\\"normal\\\" style=bold weight=2\";\n\t\t\t}\n\t\t\tif (!gv_node || !*gv_node) {\n\t\t\t\tconst char *font = r_config_get (core->config, \"graph.font\");\n\t\t\t\tfree (gv_node);\n\t\t\t\tgv_node = r_str_newf (\"penwidth=4 fillcolor=white style=filled fontname=\\\"%s Bold\\\" fontsize=14 shape=box\", font);\n\t\t\t}\n\t\t\tif (!gv_grph || !*gv_grph) {\n\t\t\t\tgv_grph = \"bgcolor=azure\";\n\t\t\t}\n\t\t\tif (!gv_spline || !*gv_spline) {\n\t\t\t\t// ortho for bbgraph and curved for callgraph\n\t\t\t\tgv_spline = \"splines=\\\"curved\\\"\";\n\t\t\t}\n\t\t\tr_cons_printf (\"digraph code {\\n\"\n\t\t\t\t\t\"rankdir=LR;\\n\"\n\t\t\t\t\t\"outputorder=edgesfirst;\\n\"\n\t\t\t\t\t\"graph [%s fontname=\\\"%s\\\" %s];\\n\"\n\t\t\t\t\t\"node [%s];\\n\"\n\t\t\t\t\t\"edge [%s];\\n\", gv_grph, font, gv_spline,\n\t\t\t\t\tgv_node, gv_edge);\n\t\t\tfree (gv_node);\n\t\t}\n\t\tbreak;\n\t}\n\tut64 base = UT64_MAX;\n\tint iteration = 0;\nrepeat:\n\tr_list_foreach (core->anal->fcns, iter, fcni) {\n\t\tif (base == UT64_MAX) {\n\t\t\tbase = fcni->addr;\n\t\t}\n\t\tif (from != UT64_MAX && fcni->addr < from) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (to != UT64_MAX && fcni->addr > to) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (addr != UT64_MAX && addr != fcni->addr) {\n\t\t\tcontinue;\n\t\t}\n\t\tRList *refs = r_anal_function_get_refs (fcni);\n\t\tRList *calls = r_list_new ();\n\t\t// TODO: maybe fcni->calls instead ?\n\t\tr_list_foreach (refs, iter2, fcnr) {\n\t\t\t//  TODO: tail calll jumps are also calls\n\t\t\tif (fcnr->type == 'C' && r_list_find(calls, fcnr, (RListComparator)RAnalRef_cmp) == NULL) {\n\t\t\t\tr_list_append (calls, fcnr);\n\t\t\t}\n\t\t}\n\t\tif (r_list_empty(calls)) {\n\t\t\tr_list_free (refs);\n\t\t\tr_list_free (calls);\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (fmt) {\n\t\tcase R_GRAPH_FORMAT_NO:\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"\\n\", fcni->addr);\n\t\t\tbreak;\n\t\tcase R_GRAPH_FORMAT_GML:\n\t\tcase R_GRAPH_FORMAT_GMLFCN: {\n\t\t\tRFlagItem *flag = r_flag_get_i (core->flags, fcni->addr);\n\t\t\tif (iteration == 0) {\n\t\t\t\tchar *msg = flag? strdup (flag->name): r_str_newf (\"0x%08\"PFMT64x, fcni->addr);\n\t\t\t\tr_cons_printf (\"  node [\\n\"\n\t\t\t\t\t\t\"  id  %\"PFMT64d\"\\n\"\n\t\t\t\t\t\t\"    label  \\\"%s\\\"\\n\"\n\t\t\t\t\t\t\"  ]\\n\", fcni->addr - base, msg);\n\t\t\t\tfree (msg);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase R_GRAPH_FORMAT_JSON:\n\t\t\tpj_o (pj);\n\t\t\tif (usenames) {\n\t\t\t\tpj_ks (pj, \"name\", fcni->name);\n\t\t\t} else {\n\t\t\t\tchar fcni_addr[20];\n\t\t\t\tsnprintf (fcni_addr, sizeof (fcni_addr) - 1, \"0x%08\" PFMT64x, fcni->addr);\n\t\t\t\tpj_ks (pj, \"name\", fcni_addr);\n\t\t\t}\n\t\t\tpj_kn (pj, \"size\", r_anal_function_linear_size (fcni));\n\t\t\tpj_ka (pj, \"imports\");\n\t\t\tbreak;\n\t\tcase R_GRAPH_FORMAT_DOT:\n\t\t\tr_cons_printf (\"  \\\"0x%08\"PFMT64x\"\\\" \"\n\t\t\t\t\t\"[label=\\\"%s\\\"\"\n\t\t\t\t\t\" URL=\\\"%s/0x%08\"PFMT64x\"\\\"];\\n\",\n\t\t\t\t\tfcni->addr, fcni->name,\n\t\t\t\t\tfcni->name, fcni->addr);\n\t\t}\n\t\tr_list_foreach (calls, iter2, fcnr) {\n\t\t\t// TODO: display only code or data refs?\n\t\t\tRFlagItem *flag = r_flag_get_i (core->flags, fcnr->addr);\n\t\t\tchar *fcnr_name = (flag && flag->name) ? flag->name : r_str_newf (\"unk.0x%\"PFMT64x, fcnr->addr);\n\t\t\tswitch (fmt) {\n\t\t\tcase R_GRAPH_FORMAT_GMLFCN:\n\t\t\t\tif (iteration == 0) {\n\t\t\t\t\tr_cons_printf (\"  node [\\n\"\n\t\t\t\t\t\t\t\"    id  %\"PFMT64d\"\\n\"\n\t\t\t\t\t\t\t\"    label  \\\"%s\\\"\\n\"\n\t\t\t\t\t\t\t\"  ]\\n\", fcnr->addr - base, fcnr_name);\n\t\t\t\t\tr_cons_printf (\"  edge [\\n\"\n\t\t\t\t\t\t\t\"    source  %\"PFMT64d\"\\n\"\n\t\t\t\t\t\t\t\"    target  %\"PFMT64d\"\\n\"\n\t\t\t\t\t\t\t\"  ]\\n\", fcni->addr-base, fcnr->addr-base);\n\t\t\t\t}\n\t\t\tcase R_GRAPH_FORMAT_GML:\n\t\t\t\tif (iteration != 0) {\n\t\t\t\t\tr_cons_printf (\"  edge [\\n\"\n\t\t\t\t\t\t\t\"    source  %\"PFMT64d\"\\n\"\n\t\t\t\t\t\t\t\"    target  %\"PFMT64d\"\\n\"\n\t\t\t\t\t\t\t\"  ]\\n\", fcni->addr-base, fcnr->addr-base); //, \"#000000\"\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_GRAPH_FORMAT_DOT:\n\t\t\t\tr_cons_printf (\"  \\\"0x%08\"PFMT64x\"\\\" -> \\\"0x%08\"PFMT64x\"\\\" \"\n\t\t\t\t\t\t\"[color=\\\"%s\\\" URL=\\\"%s/0x%08\"PFMT64x\"\\\"];\\n\",\n\t\t\t\t\t\t//\"[label=\\\"%s\\\" color=\\\"%s\\\" URL=\\\"%s/0x%08\"PFMT64x\"\\\"];\\n\",\n\t\t\t\t\t\tfcni->addr, fcnr->addr, //, fcnr_name,\n\t\t\t\t\t\t\"#61afef\",\n\t\t\t\t\t\tfcnr_name, fcnr->addr);\n\t\t\t\tr_cons_printf (\"  \\\"0x%08\"PFMT64x\"\\\" \"\n\t\t\t\t\t\t\"[label=\\\"%s\\\"\"\n\t\t\t\t\t\t\" URL=\\\"%s/0x%08\"PFMT64x\"\\\"];\\n\",\n\t\t\t\t\t\tfcnr->addr, fcnr_name,\n\t\t\t\t\t\tfcnr_name, fcnr->addr);\n\t\t\t\tbreak;\n\t\t\tcase R_GRAPH_FORMAT_JSON:\n\t\t\t\tif (usenames) {\n\t\t\t\t\tpj_s (pj, fcnr_name);\n\t\t\t\t} else {\n\t\t\t\t\tchar fcnr_addr[20];\n\t\t\t\t\tsnprintf (fcnr_addr, sizeof (fcnr_addr) - 1, \"0x%08\" PFMT64x, fcnr->addr);\n\t\t\t\t\tpj_s (pj, fcnr_addr);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (refgraph || fcnr->type == R_ANAL_REF_TYPE_CALL) {\n\t\t\t\t\t// TODO: avoid recreating nodes unnecessarily\n\t\t\t\t\tr_cons_printf (\"agn %s\\n\", fcni->name);\n\t\t\t\t\tr_cons_printf (\"agn %s\\n\", fcnr_name);\n\t\t\t\t\tr_cons_printf (\"age %s %s\\n\", fcni->name, fcnr_name);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"# - 0x%08\"PFMT64x\" (%c)\\n\", fcnr->addr, fcnr->type);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!(flag && flag->name)) {\n\t\t\t\tfree(fcnr_name);\n\t\t\t}\n\t\t}\n\t\tr_list_free (refs);\n\t\tr_list_free (calls);\n\t\tif (fmt == R_GRAPH_FORMAT_JSON) {\n\t\t\tpj_end (pj);\n\t\t\tpj_end (pj);\n\t\t}\n\t}\n\tif (iteration == 0 && fmt == R_GRAPH_FORMAT_GML) {\n\t\titeration++;\n\t\tgoto repeat;\n\t}\n\tif (iteration == 0 && fmt == R_GRAPH_FORMAT_GMLFCN) {\n\t\titeration++;\n\t}\n\tswitch (fmt) {\n\tcase R_GRAPH_FORMAT_GML:\n\tcase R_GRAPH_FORMAT_GMLFCN:\n\tcase R_GRAPH_FORMAT_JSON:\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t\tbreak;\n\tcase R_GRAPH_FORMAT_DOT:\n\t\tr_cons_printf (\"}\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic void fcn_list_bbs(RAnalFunction *fcn) {\n\tRAnalBlock *bbi;\n\tRListIter *iter;\n\n\tr_list_foreach (fcn->bbs, iter, bbi) {\n\t\tr_cons_printf (\"afb+ 0x%08\" PFMT64x \" 0x%08\" PFMT64x \" %\" PFMT64u \" \",\n\t\t\t\t   fcn->addr, bbi->addr, bbi->size);\n\t\tr_cons_printf (\"0x%08\"PFMT64x\" \", bbi->jump);\n\t\tr_cons_printf (\"0x%08\"PFMT64x, bbi->fail);\n\t\tif (bbi->diff) {\n\t\t\tif (bbi->diff->type == R_ANAL_DIFF_TYPE_MATCH) {\n\t\t\t\tr_cons_printf (\" m\");\n\t\t\t} else if (bbi->diff->type == R_ANAL_DIFF_TYPE_UNMATCH) {\n\t\t\t\tr_cons_printf (\" u\");\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\" n\");\n\t\t\t}\n\t\t}\n\t\tr_cons_printf (\"\\n\");\n\t}\n}\n\nR_API ut64 r_core_anal_fcn_list_size(RCore *core) {\n\tRAnalFunction *fcn;\n\tRListIter *iter;\n\tut64 total = 0;\n\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\ttotal += r_anal_function_realsize (fcn);\n\t}\n\tr_cons_printf (\"%\"PFMT64u\"\\n\", total);\n\treturn total;\n}\n\n/* Fill out metadata struct of functions */\nstatic int fcnlist_gather_metadata(RAnal *anal, RList *fcns) {\n\tRListIter *iter;\n\tRAnalFunction *fcn;\n\tRList *xrefs;\n\n\tr_list_foreach (fcns, iter, fcn) {\n\t\t// Count the number of references and number of calls\n\t\tRListIter *callrefiter;\n\t\tRAnalRef *ref;\n\t\tRList *refs = r_anal_function_get_refs (fcn);\n\t\tint numcallrefs = 0;\n\t\tr_list_foreach (refs, callrefiter, ref) {\n\t\t\tif (ref->type == R_ANAL_REF_TYPE_CALL) {\n\t\t\t\tnumcallrefs++;\n\t\t\t}\n\t\t}\n\t\tr_list_free (refs);\n\t\tfcn->meta.numcallrefs = numcallrefs;\n\t\txrefs = r_anal_xrefs_get (anal, fcn->addr);\n\t\tfcn->meta.numrefs = xrefs? xrefs->length: 0;\n\t\tr_list_free (xrefs);\n\t}\n\t// TODO: Determine sgnc, sgec\n\treturn 0;\n}\n\nR_API char *r_core_anal_fcn_name(RCore *core, RAnalFunction *fcn) {\n\tbool demangle = r_config_get_i (core->config, \"bin.demangle\");\n\tconst char *lang = demangle ? r_config_get (core->config, \"bin.lang\") : NULL;\n\tbool keep_lib = r_config_get_i (core->config, \"bin.demangle.libs\");\n\tchar *name = strdup (r_str_get (fcn->name));\n\tif (demangle) {\n\t\tchar *tmp = r_bin_demangle (core->bin->cur, lang, name, fcn->addr, keep_lib);\n\t\tif (tmp) {\n\t\t\tfree (name);\n\t\t\tname = tmp;\n\t\t}\n\t}\n\treturn name;\n}\n\n#define FCN_LIST_VERBOSE_ENTRY \"%s0x%0*\"PFMT64x\" %4\"PFMT64d\" %5d %5d %5d %4d 0x%0*\"PFMT64x\" %5\"PFMT64d\" 0x%0*\"PFMT64x\" %5d %4d %6d %4d %5d %s%s\\n\"\nstatic int fcn_print_verbose(RCore *core, RAnalFunction *fcn, bool use_color) {\n\tchar *name = r_core_anal_fcn_name (core, fcn);\n\tint ebbs = 0;\n\tint addrwidth = 8;\n\tconst char *color = \"\";\n\tconst char *color_end = \"\";\n\tif (use_color) {\n\t\tcolor_end = Color_RESET;\n\t\tif (strstr (name, \"sym.imp.\")) {\n\t\t\tcolor = Color_YELLOW;\n\t\t} else if (strstr (name, \"sym.\")) {\n\t\t\tcolor = Color_GREEN;\n\t\t} else if (strstr (name, \"sub.\")) {\n\t\t\tcolor = Color_MAGENTA;\n\t\t}\n\t}\n\n\tif (core->anal->bits == 64) {\n\t\taddrwidth = 16;\n\t}\n\n\tr_cons_printf (FCN_LIST_VERBOSE_ENTRY, color,\n\t\t\taddrwidth, fcn->addr,\n\t\t\tr_anal_function_realsize (fcn),\n\t\t\tr_list_length (fcn->bbs),\n\t\t\tr_anal_function_count_edges (fcn, &ebbs),\n\t\t\tr_anal_function_complexity (fcn),\n\t\t\tr_anal_function_cost (fcn),\n\t\t\taddrwidth, r_anal_function_min_addr (fcn),\n\t\t\tr_anal_function_linear_size (fcn),\n\t\t\taddrwidth, r_anal_function_max_addr (fcn),\n\t\t\tfcn->meta.numcallrefs,\n\t\t\tr_anal_var_count_locals (fcn),\n\t\t\tr_anal_var_count_args (fcn),\n\t\t\tfcn->meta.numrefs,\n\t\t\tfcn->maxstack,\n\t\t\tname,\n\t\t\tcolor_end);\n\tfree (name);\n\treturn 0;\n}\n\nstatic int fcn_list_verbose(RCore *core, RList *fcns, const char *sortby) {\n\tbool use_color = r_config_get_i (core->config, \"scr.color\");\n\tint headeraddr_width = 10;\n\tchar *headeraddr = \"==========\";\n\n\tif (core->anal->bits == 64) {\n\t\theaderaddr_width = 18;\n\t\theaderaddr = \"==================\";\n\t}\n\n\tif (sortby) {\n\t\tif (!strcmp (sortby, \"size\")) {\n\t\t\tr_list_sort (fcns, cmpsize);\n\t\t} else if (!strcmp (sortby, \"addr\")) {\n\t\t\tr_list_sort (fcns, cmpaddr);\n\t\t} else if (!strcmp (sortby, \"cc\")) {\n\t\t\tr_list_sort (fcns, cmpfcncc);\n\t\t} else if (!strcmp (sortby, \"edges\")) {\n\t\t\tr_list_sort (fcns, cmpedges);\n\t\t} else if (!strcmp (sortby, \"calls\")) {\n\t\t\tr_list_sort (fcns, cmpcalls);\n\t\t} else if (strstr (sortby, \"name\")) {\n\t\t\tr_list_sort (fcns, cmpname);\n\t\t} else if (strstr (sortby, \"frame\")) {\n\t\t\tr_list_sort (fcns, cmpframe);\n\t\t} else if (strstr (sortby, \"ref\")) {\n\t\t\tr_list_sort (fcns, cmpxrefs);\n\t\t} else if (!strcmp (sortby, \"nbbs\")) {\n\t\t\tr_list_sort (fcns, cmpnbbs);\n\t\t}\n\t}\n\n\tr_cons_printf (\"%-*s %4s %5s %5s %5s %4s %*s range %-*s %s %s %s %s %s %s\\n\",\n\t\t\theaderaddr_width, \"address\", \"size\", \"nbbs\", \"edges\", \"cc\", \"cost\",\n\t\t\theaderaddr_width, \"min bound\", headeraddr_width, \"max bound\", \"calls\",\n\t\t\t\"locals\", \"args\", \"xref\", \"frame\", \"name\");\n\tr_cons_printf (\"%s ==== ===== ===== ===== ==== %s ===== %s ===== ====== ==== ==== ===== ====\\n\",\n\t\t\theaderaddr, headeraddr, headeraddr);\n\tRListIter *iter;\n\tRAnalFunction *fcn;\n\tr_list_foreach (fcns, iter, fcn) {\n\t\tfcn_print_verbose (core, fcn, use_color);\n\t}\n\n\treturn 0;\n}\n\nstatic void __fcn_print_default(RCore *core, RAnalFunction *fcn, bool quiet) {\n\tif (quiet) {\n\t\tr_cons_printf (\"0x%08\"PFMT64x\" \", fcn->addr);\n\t} else {\n\t\tchar *name = r_core_anal_fcn_name (core, fcn);\n\t\tut64 realsize = r_anal_function_realsize (fcn);\n\t\tut64 size = r_anal_function_linear_size (fcn);\n\t\tchar *msg = (realsize == size)\n\t\t\t? r_str_newf (\"%-12\"PFMT64u, size)\n\t\t\t: r_str_newf (\"%-4\"PFMT64u\" -> %-4\"PFMT64u, size, realsize);\n\t\tr_cons_printf (\"0x%08\"PFMT64x\" %4d %4s %s\\n\",\n\t\t\t\tfcn->addr, r_list_length (fcn->bbs), msg, name);\n\t\tfree (name);\n\t\tfree (msg);\n\t}\n}\n\nstatic int fcn_list_default(RCore *core, RList *fcns, bool quiet) {\n\tRListIter *iter;\n\tRAnalFunction *fcn;\n\tr_list_foreach (fcns, iter, fcn) {\n\t\t__fcn_print_default (core, fcn, quiet);\n\t\tif (quiet) {\n\t\t\tr_cons_newline ();\n\t\t}\n\t}\n\treturn 0;\n}\n\n// for a given function returns an RList of all functions that were called in it\nR_API RList *r_core_anal_fcn_get_calls(RCore *core, RAnalFunction *fcn) {\n\tRAnalRef *refi;\n\tRListIter *iter, *iter2;\n\n\t// get all references from this function\n\tRList *refs = r_anal_function_get_refs (fcn);\n\t// sanity check\n\tif (!r_list_empty (refs)) {\n\t\t// iterate over all the references and remove these which aren't of type call\n\t\tr_list_foreach_safe (refs, iter, iter2, refi) {\n\t\t\tif (refi->type != R_ANAL_REF_TYPE_CALL) {\n\t\t\t\tr_list_delete (refs, iter);\n\t\t\t}\n\t\t}\n\t}\n\treturn refs;\n}\n\n// Lists function names and their calls (uniqified)\nstatic int fcn_print_makestyle(RCore *core, RList *fcns, char mode) {\n\tRListIter *refiter;\n\tRListIter *fcniter;\n\tRAnalFunction *fcn;\n\tRAnalRef *refi;\n\tRList *refs = NULL;\n\tPJ *pj = NULL;\n\n\tif (mode == 'j') {\n\t\tpj = r_core_pj_new (core);\n\t\tpj_a (pj);\n\t}\n\n\t// Iterate over all functions\n\tr_list_foreach (fcns, fcniter, fcn) {\n\t\t// Get all refs for a function\n\t\trefs = r_core_anal_fcn_get_calls (core, fcn);\n\t\t// Uniquify the list by ref->addr\n\t\tr_list_uniq_inplace (refs, RAnalRef_val);\n\n\t\t// don't enter for functions with 0 refs\n\t\tif (!r_list_empty (refs)) {\n\t\t\tif (pj) { // begin json output of function\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_ks (pj, \"name\", fcn->name);\n\t\t\t\tpj_kn (pj, \"addr\", fcn->addr);\n\t\t\t\tpj_k (pj, \"calls\");\n\t\t\t\tpj_a (pj);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"%s\", fcn->name);\n\t\t\t}\n\n\t\t\tif (mode == 'm') {\n\t\t\t\tr_cons_printf (\":\\n\");\n\t\t\t} else if (mode == 'q') {\n\t\t\t\tr_cons_printf (\" -> \");\n\t\t\t}\n\t\t\t// Iterate over all refs from a function\n\t\t\tr_list_foreach (refs, refiter, refi) {\n\t\t\t\tRFlagItem *f = r_flag_get_i (core->flags, refi->addr);\n\t\t\t\tchar *dst = r_str_newf ((f? f->name: \"0x%08\"PFMT64x), refi->addr);\n\t\t\t\tif (pj) { // Append calee json item\n\t\t\t\t\tpj_o (pj);\n\t\t\t\t\tpj_ks (pj, \"name\", dst);\n\t\t\t\t\tpj_kn (pj, \"addr\", refi->addr);\n\t\t\t\t\tpj_end (pj); // close referenced item\n\t\t\t\t} else if (mode == 'q') {\n\t\t\t\t\tr_cons_printf (\"%s \", dst);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"    %s\\n\", dst);\n\t\t\t\t}\n\t\t\t\tfree (dst);\n\t\t\t}\n\t\t\tif (pj) {\n\t\t\t\tpj_end (pj); // close list of calls\n\t\t\t\tpj_end (pj); // close function item\n\t\t\t} else {\n\t\t\t\tr_cons_newline();\n\t\t\t}\n\t\t}\n\n\t\tr_list_free (refs);\n\t}\n\n\tif (mode == 'j') {\n\t\tpj_end (pj); // close json output\n\t\tr_cons_printf (\"%s\\n\", pj_string (pj));\n\t}\n\tif (pj) {\n\t\tpj_free (pj);\n\t}\n\treturn 0;\n}\n\nstatic int fcn_print_json(RCore *core, RAnalFunction *fcn, PJ *pj) {\n\tRListIter *iter;\n\tRAnalRef *refi;\n\tRList *refs, *xrefs;\n\tif (!pj) {\n\t\treturn -1;\n\t}\n\tint ebbs = 0;\n\tpj_o (pj);\n\tpj_kn (pj, \"offset\", fcn->addr);\n\tchar *name = r_core_anal_fcn_name (core, fcn);\n\tif (name) {\n\t\tpj_ks (pj, \"name\", name);\n\t}\n\tpj_kn (pj, \"size\", r_anal_function_linear_size (fcn));\n\tpj_ks (pj, \"is-pure\", r_str_bool (r_anal_function_purity (fcn)));\n\tpj_kn (pj, \"realsz\", r_anal_function_realsize (fcn));\n\tpj_kb (pj, \"noreturn\", fcn->is_noreturn);\n\tpj_ki (pj, \"stackframe\", fcn->maxstack);\n\tif (fcn->cc) {\n\t\tpj_ks (pj, \"calltype\", fcn->cc); // calling conventions\n\t}\n\tpj_ki (pj, \"cost\", r_anal_function_cost (fcn)); // execution cost\n\tpj_ki (pj, \"cc\", r_anal_function_complexity (fcn)); // cyclic cost\n\tpj_ki (pj, \"bits\", fcn->bits);\n\tpj_ks (pj, \"type\", r_anal_functiontype_tostring (fcn->type));\n\tpj_ki (pj, \"nbbs\", r_list_length (fcn->bbs));\n\tpj_ki (pj, \"edges\", r_anal_function_count_edges (fcn, &ebbs));\n\tpj_ki (pj, \"ebbs\", ebbs);\n\t{\n\t\tchar *sig = r_core_cmd_strf (core, \"afcf @ 0x%\"PFMT64x, fcn->addr);\n\t\tif (sig) {\n\t\t\tr_str_trim (sig);\n\t\t\tpj_ks (pj, \"signature\", sig);\n\t\t\tfree (sig);\n\t\t}\n\n\t}\n\tpj_kn (pj, \"minbound\", r_anal_function_min_addr (fcn));\n\tpj_kn (pj, \"maxbound\", r_anal_function_max_addr (fcn));\n\n\tint outdegree = 0;\n\trefs = r_anal_function_get_refs (fcn);\n\tif (!r_list_empty (refs)) {\n\t\tpj_k (pj, \"callrefs\");\n\t\tpj_a (pj);\n\t\tr_list_foreach (refs, iter, refi) {\n\t\t\tif (refi->type == R_ANAL_REF_TYPE_CALL) {\n\t\t\t\toutdegree++;\n\t\t\t}\n\t\t\tif (refi->type == R_ANAL_REF_TYPE_CODE ||\n\t\t\t\trefi->type == R_ANAL_REF_TYPE_CALL) {\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_kn (pj, \"addr\", refi->addr);\n\t\t\t\tpj_ks (pj, \"type\", r_anal_xrefs_type_tostring (refi->type));\n\t\t\t\tpj_kn (pj, \"at\", refi->at);\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t}\n\t\tpj_end (pj);\n\n\t\tpj_k (pj, \"datarefs\");\n\t\tpj_a (pj);\n\t\tr_list_foreach (refs, iter, refi) {\n\t\t\tif (refi->type == R_ANAL_REF_TYPE_DATA) {\n\t\t\t\tpj_n (pj, refi->addr);\n\t\t\t}\n\t\t}\n\t\tpj_end (pj);\n\t}\n\tr_list_free (refs);\n\n\tint indegree = 0;\n\txrefs = r_anal_function_get_xrefs (fcn);\n\tif (!r_list_empty (xrefs)) {\n\t\tpj_k (pj, \"codexrefs\");\n\t\tpj_a (pj);\n\t\tr_list_foreach (xrefs, iter, refi) {\n\t\t\tif (refi->type == R_ANAL_REF_TYPE_CODE ||\n\t\t\t\trefi->type == R_ANAL_REF_TYPE_CALL) {\n\t\t\t\tindegree++;\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_kn (pj, \"addr\", refi->addr);\n\t\t\t\tpj_ks (pj, \"type\", r_anal_xrefs_type_tostring (refi->type));\n\t\t\t\tpj_kn (pj, \"at\", refi->at);\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t}\n\n\t\tpj_end (pj);\n\t\tpj_k (pj, \"dataxrefs\");\n\t\tpj_a (pj);\n\n\t\tr_list_foreach (xrefs, iter, refi) {\n\t\t\tif (refi->type == R_ANAL_REF_TYPE_DATA) {\n\t\t\t\tpj_n (pj, refi->addr);\n\t\t\t}\n\t\t}\n\t\tpj_end (pj);\n\t}\n\tr_list_free (xrefs);\n\n\tpj_ki (pj, \"indegree\", indegree);\n\tpj_ki (pj, \"outdegree\", outdegree);\n\n\tif (fcn->type == R_ANAL_FCN_TYPE_FCN || fcn->type == R_ANAL_FCN_TYPE_SYM) {\n\t\tpj_ki (pj, \"nlocals\", r_anal_var_count_locals (fcn));\n\t\tpj_ki (pj, \"nargs\", r_anal_var_count_args (fcn));\n\t\tpj_k (pj, \"bpvars\");\n\t\tr_anal_var_list_show (core->anal, fcn, 'b', 'j', pj);\n\t\tpj_k (pj, \"spvars\");\n\t\tr_anal_var_list_show (core->anal, fcn, 's', 'j', pj);\n\t\tpj_k (pj, \"regvars\");\n\t\tr_anal_var_list_show (core->anal, fcn, 'r', 'j', pj);\n\n\t\tpj_ks (pj, \"difftype\", fcn->diff->type == R_ANAL_DIFF_TYPE_MATCH?\"match\":\n\t\t\t\tfcn->diff->type == R_ANAL_DIFF_TYPE_UNMATCH?\"unmatch\":\"new\");\n\t\tif (fcn->diff->addr != -1) {\n\t\t\tpj_kn (pj, \"diffaddr\", fcn->diff->addr);\n\t\t}\n\t\tif (fcn->diff->name) {\n\t\t\tpj_ks (pj, \"diffname\", fcn->diff->name);\n\t\t}\n\t}\n\tpj_end (pj);\n\tfree (name);\n\treturn 0;\n}\n\nstatic int fcn_list_json(RCore *core, RList *fcns, bool quiet) {\n\tRListIter *iter;\n\tRAnalFunction *fcn;\n\tPJ *pj = r_core_pj_new (core);\n\tif (!pj) {\n\t\tr_cons_println (\"[]\");\n\t\treturn -1;\n\t}\n\tpj_a (pj);\n\tr_list_foreach (fcns, iter, fcn) {\n\t\tif (quiet) {\n\t\t\tpj_n (pj, fcn->addr);\n\t\t} else {\n\t\t\tfcn_print_json (core, fcn, pj);\n\t\t}\n\t}\n\tpj_end (pj);\n\tr_cons_println (pj_string (pj));\n\tpj_free (pj);\n\treturn 0;\n}\n\nstatic int fcn_list_verbose_json(RCore *core, RList *fcns) {\n\treturn fcn_list_json (core, fcns, false);\n}\n\nstatic int fcn_print_detail(RCore *core, RAnalFunction *fcn) {\n\tconst char *defaultCC = r_anal_cc_default (core->anal);\n\tchar *name = r_core_anal_fcn_name (core, fcn);\n\tchar *paren = strchr (name, '(');\n\tif (paren) {\n\t\t*paren = '\\0';\n\t}\n\tr_cons_printf (\"\\\"f %s %\"PFMT64u\" 0x%08\"PFMT64x\"\\\"\\n\", name, r_anal_function_linear_size (fcn), fcn->addr);\n\tr_cons_printf (\"\\\"af+ 0x%08\"PFMT64x\" %s %c %c\\\"\\n\",\n\t\t\tfcn->addr, name, //r_anal_function_size (fcn), name,\n\t\t\tfcn->type == R_ANAL_FCN_TYPE_LOC?'l':\n\t\t\tfcn->type == R_ANAL_FCN_TYPE_SYM?'s':\n\t\t\tfcn->type == R_ANAL_FCN_TYPE_IMP?'i':'f',\n\t\t\tfcn->diff->type == R_ANAL_DIFF_TYPE_MATCH?'m':\n\t\t\tfcn->diff->type == R_ANAL_DIFF_TYPE_UNMATCH?'u':'n');\n\t// FIXME: this command prints something annoying. Does it have important side-effects?\n\tfcn_list_bbs (fcn);\n\tif (fcn->bits != 0) {\n\t\tr_cons_printf (\"afB %d @ 0x%08\"PFMT64x\"\\n\", fcn->bits, fcn->addr);\n\t}\n\t// FIXME command injection vuln here\n\tif (fcn->cc || defaultCC) {\n\t\tr_cons_printf (\"s 0x%\"PFMT64x\"\\n\", fcn->addr);\n\t\tr_cons_printf (\"\\\"afc %s\\\"\\n\", fcn->cc? fcn->cc: defaultCC);\n\t\tr_cons_println (\"s-\");\n\t}\n\tif (fcn->folded) {\n\t\tr_cons_printf (\"afF @ 0x%08\"PFMT64x\"\\n\", fcn->addr);\n\t}\n\tif (fcn) {\n\t\t/* show variables  and arguments */\n\t\tr_core_cmdf (core, \"afvb* @ 0x%\"PFMT64x\"\\n\", fcn->addr);\n\t\tr_core_cmdf (core, \"afvr* @ 0x%\"PFMT64x\"\\n\", fcn->addr);\n\t\tr_core_cmdf (core, \"afvs* @ 0x%\"PFMT64x\"\\n\", fcn->addr);\n\t}\n\t/* Show references */\n\tRListIter *refiter;\n\tRAnalRef *refi;\n\tRList *refs = r_anal_function_get_refs (fcn);\n\tr_list_foreach (refs, refiter, refi) {\n\t\tswitch (refi->type) {\n\t\tcase R_ANAL_REF_TYPE_CALL:\n\t\t\tr_cons_printf (\"axC 0x%\"PFMT64x\" 0x%\"PFMT64x\"\\n\", refi->addr, refi->at);\n\t\t\tbreak;\n\t\tcase R_ANAL_REF_TYPE_DATA:\n\t\t\tr_cons_printf (\"axd 0x%\"PFMT64x\" 0x%\"PFMT64x\"\\n\", refi->addr, refi->at);\n\t\t\tbreak;\n\t\tcase R_ANAL_REF_TYPE_CODE:\n\t\t\tr_cons_printf (\"axc 0x%\"PFMT64x\" 0x%\"PFMT64x\"\\n\", refi->addr, refi->at);\n\t\t\tbreak;\n\t\tcase R_ANAL_REF_TYPE_STRING:\n\t\t\tr_cons_printf (\"axs 0x%\"PFMT64x\" 0x%\"PFMT64x\"\\n\", refi->addr, refi->at);\n\t\t\tbreak;\n\t\tcase R_ANAL_REF_TYPE_NULL:\n\t\tdefault:\n\t\t\tr_cons_printf (\"ax 0x%\"PFMT64x\" 0x%\"PFMT64x\"\\n\", refi->addr, refi->at);\n\t\t\tbreak;\n\t\t}\n\t}\n\tr_list_free (refs);\n\t/*Saving Function stack frame*/\n\tr_cons_printf (\"afS %d @ 0x%\"PFMT64x\"\\n\", fcn->maxstack, fcn->addr);\n\tfree (name);\n\treturn 0;\n}\n\nstatic bool is_fcn_traced(RDebugTrace *traced, RAnalFunction *fcn) {\n\tint tag = traced->tag;\n\tRListIter *iter;\n\tRDebugTracepoint *trace;\n\n\tr_list_foreach (traced->traces, iter, trace) {\n\t\tif (!trace->tag || (tag & trace->tag)) {\n\t\t\tif (r_anal_function_contains (fcn, trace->addr)) {\n\t\t\t\tr_cons_printf (\"\\ntraced: %d\\n\", trace->times);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int fcn_print_legacy(RCore *core, RAnalFunction *fcn) {\n\tRListIter *iter;\n\tRAnalRef *refi;\n\tRList *refs, *xrefs;\n\tint ebbs = 0;\n\tchar *name = r_core_anal_fcn_name (core, fcn);\n\n\tr_cons_printf (\"#\\noffset: 0x%08\"PFMT64x\"\\nname: %s\\nsize: %\"PFMT64u,\n\t\t\tfcn->addr, name, r_anal_function_linear_size (fcn));\n\tr_cons_printf (\"\\nis-pure: %s\", r_str_bool (r_anal_function_purity (fcn)));\n\tr_cons_printf (\"\\nrealsz: %\" PFMT64d, r_anal_function_realsize (fcn));\n\tr_cons_printf (\"\\nstackframe: %d\", fcn->maxstack);\n\tif (fcn->cc) {\n\t\tr_cons_printf (\"\\ncall-convention: %s\", fcn->cc);\n\t}\n\tr_cons_printf (\"\\ncyclomatic-cost: %d\", r_anal_function_cost (fcn));\n\tr_cons_printf (\"\\ncyclomatic-complexity: %d\", r_anal_function_complexity (fcn));\n\tr_cons_printf (\"\\nbits: %d\", fcn->bits);\n\tr_cons_printf (\"\\ntype: %s\", r_anal_functiontype_tostring (fcn->type));\n\tif (fcn->type == R_ANAL_FCN_TYPE_FCN || fcn->type == R_ANAL_FCN_TYPE_SYM) {\n\t\tr_cons_printf (\" [%s]\",\n\t\t\t\tfcn->diff->type == R_ANAL_DIFF_TYPE_MATCH?\"MATCH\":\n\t\t\t\tfcn->diff->type == R_ANAL_DIFF_TYPE_UNMATCH?\"UNMATCH\":\"NEW\");\n\t}\n\tr_cons_printf (\"\\nnum-bbs: %d\", r_list_length (fcn->bbs));\n\tr_cons_printf (\"\\nedges: %d\", r_anal_function_count_edges (fcn, &ebbs));\n\tr_cons_printf (\"\\nend-bbs: %d\", ebbs);\n\tr_cons_printf (\"\\ncall-refs:\");\n\tint outdegree = 0;\n\trefs = r_anal_function_get_refs (fcn);\n\tr_list_foreach (refs, iter, refi) {\n\t\tif (refi->type == R_ANAL_REF_TYPE_CALL) {\n\t\t\toutdegree++;\n\t\t}\n\t\tif (refi->type == R_ANAL_REF_TYPE_CODE || refi->type == R_ANAL_REF_TYPE_CALL) {\n\t\t\tr_cons_printf (\" 0x%08\"PFMT64x\" %c\", refi->addr,\n\t\t\t\t\trefi->type == R_ANAL_REF_TYPE_CALL?'C':'J');\n\t\t}\n\t}\n\tr_cons_printf (\"\\ndata-refs:\");\n\tr_list_foreach (refs, iter, refi) {\n\t\t// global or local?\n\t\tif (refi->type == R_ANAL_REF_TYPE_DATA) {\n\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, refi->addr);\n\t\t}\n\t}\n\tr_list_free (refs);\n\n\tint indegree = 0;\n\tr_cons_printf (\"\\ncode-xrefs:\");\n\txrefs = r_anal_function_get_xrefs (fcn);\n\tr_list_foreach (xrefs, iter, refi) {\n\t\tif (refi->type == R_ANAL_REF_TYPE_CODE || refi->type == R_ANAL_REF_TYPE_CALL) {\n\t\t\tindegree++;\n\t\t\tr_cons_printf (\" 0x%08\"PFMT64x\" %c\", refi->addr,\n\t\t\t\t\trefi->type == R_ANAL_REF_TYPE_CALL?'C':'J');\n\t\t}\n\t}\n\tr_cons_printf (\"\\nnoreturn: %s\", r_str_bool (fcn->is_noreturn));\n\tr_cons_printf (\"\\nin-degree: %d\", indegree);\n\tr_cons_printf (\"\\nout-degree: %d\", outdegree);\n\tr_cons_printf (\"\\ndata-xrefs:\");\n\tr_list_foreach (xrefs, iter, refi) {\n\t\tif (refi->type == R_ANAL_REF_TYPE_DATA) {\n\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, refi->addr);\n\t\t}\n\t}\n\tr_list_free (xrefs);\n\n\tif (fcn->type == R_ANAL_FCN_TYPE_FCN || fcn->type == R_ANAL_FCN_TYPE_SYM) {\n\t\tint args_count = r_anal_var_count_args (fcn);\n\t\tint var_count = r_anal_var_count_locals (fcn);\n\n\t\tr_cons_printf (\"\\nlocals: %d\\nargs: %d\\n\", var_count, args_count);\n\t\tr_anal_var_list_show (core->anal, fcn, 'b', 0, NULL);\n\t\tr_anal_var_list_show (core->anal, fcn, 's', 0, NULL);\n\t\tr_anal_var_list_show (core->anal, fcn, 'r', 0, NULL);\n\t\tr_cons_printf (\"diff: type: %s\",\n\t\t\t\tfcn->diff->type == R_ANAL_DIFF_TYPE_MATCH?\"match\":\n\t\t\t\tfcn->diff->type == R_ANAL_DIFF_TYPE_UNMATCH?\"unmatch\":\"new\");\n\t\tif (fcn->diff->addr != -1) {\n\t\t\tr_cons_printf (\"addr: 0x%\"PFMT64x, fcn->diff->addr);\n\t\t}\n\t\tif (fcn->diff->name) {\n\t\t\tr_cons_printf (\"function: %s\", fcn->diff->name);\n\t\t}\n\t}\n\tfree (name);\n\n\t// traced\n\tif (core->dbg->trace->enabled) {\n\t\tis_fcn_traced (core->dbg->trace, fcn);\n\t}\n\treturn 0;\n}\n\nstatic int fcn_list_detail(RCore *core, RList *fcns) {\n\tRListIter *iter;\n\tRAnalFunction *fcn;\n\tr_list_foreach (fcns, iter, fcn) {\n\t\tfcn_print_detail (core, fcn);\n\t}\n\tr_cons_newline ();\n\treturn 0;\n}\n\nstatic int fcn_list_table(RCore *core, const char *q, int fmt) {\n\tchar xref[128], ccstr[128], castr[128];\n\tRAnalFunction *fcn;\n\tRListIter *iter;\n\tRTable *t = r_core_table (core, \"fcns\");\n\tRTableColumnType *typeString = r_table_type (\"string\");\n\tRTableColumnType *typeNumber = r_table_type (\"number\");\n\tr_table_add_column (t, typeNumber, \"addr\", 0);\n\tr_table_add_column (t, typeNumber, \"size\", 0);\n\tr_table_add_column (t, typeString, \"name\", 0);\n\tr_table_add_column (t, typeNumber, \"nbbs\", 0);\n\tr_table_add_column (t, typeNumber, \"xref\", 0);\n\tr_table_add_column (t, typeNumber, \"calls\", 0);\n\tr_table_add_column (t, typeNumber, \"cc\", 0);\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\tr_strf_var (fcnAddr, 32, \"0x%08\"PFMT64x, fcn->addr);\n\t\tr_strf_var (fcnSize, 32, \"%\"PFMT64u, r_anal_function_linear_size (fcn)); // r_anal_function_size (fcn));\n\t\tr_strf_var (nbbs, 32, \"%d\", r_list_length (fcn->bbs));\n\t\tRList *xrefs = r_anal_function_get_xrefs (fcn);\n\t\tsnprintf (xref, sizeof (xref), \"%d\", r_list_length (xrefs));\n\t\tr_list_free (xrefs);\n\n\t\tRList *calls = r_core_anal_fcn_get_calls (core, fcn);\n\t\tr_list_uniq_inplace (calls, (RListComparatorItem)RAnalRef_val);\n\t\tsnprintf (castr, sizeof (castr), \"%d\", r_list_length (calls));\n\t\tr_list_free (calls);\n\t\tsnprintf (ccstr, sizeof (ccstr), \"%d\", r_anal_function_complexity (fcn));\n\n\t\tr_table_add_row (t, fcnAddr, fcnSize, fcn->name, nbbs, xref, castr, ccstr, NULL);\n\t}\n\tif (r_table_query (t, q)) {\n\t\tchar *s = (fmt == 'j')\n\t\t\t? r_table_tojson (t)\n\t\t\t: r_table_tostring (t);\n\t\tr_cons_printf (\"%s\\n\", s);\n\t\tfree (s);\n\t}\n\tr_table_free (t);\n\treturn 0;\n}\n\nstatic int fcn_list_legacy(RCore *core, RList *fcns) {\n\tRListIter *iter;\n\tRAnalFunction *fcn;\n\tr_list_foreach (fcns, iter, fcn) {\n\t\tfcn_print_legacy (core, fcn);\n\t}\n\tr_cons_newline ();\n\treturn 0;\n}\n\nR_API int r_core_anal_fcn_list(RCore *core, const char *input, const char *rad) {\n\tchar temp[64];\n\tr_return_val_if_fail (core && core->anal, 0);\n\tif (r_list_empty (core->anal->fcns)) {\n\t\tif (*rad == 'j') {\n\t\t\tr_cons_println (\"[]\");\n\t\t}\n\t\treturn 0;\n\t}\n\tif (*rad == '.') {\n\t\tRList *fcns = r_anal_get_functions_in (core->anal, core->offset);\n\t\tif (!fcns || r_list_empty (fcns)) {\n\t\t\teprintf (\"No functions at current address.\\n\");\n\t\t\tr_list_free (fcns);\n\t\t\treturn -1;\n\t\t}\n\t\tfcn_list_default (core, fcns, false);\n\t\tr_list_free (fcns);\n\t\treturn 0;\n\t}\n\n\tif (rad && (*rad == 'l' || *rad == 'j')) {\n\t\tfcnlist_gather_metadata (core->anal, core->anal->fcns);\n\t}\n\n\tconst char *name = input;\n\tut64 addr = core->offset;\n\tif (input && *input) {\n\t\tname = input + 1;\n\t\taddr = r_num_math (core->num, name);\n\t}\n\n\tRList *fcns = r_list_newf (NULL);\n\tif (!fcns) {\n\t\treturn -1;\n\t}\n\tRListIter *iter;\n\tRAnalFunction *fcn;\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\tif (!input || r_anal_function_contains (fcn, addr) || (!strcmp (name, fcn->name))) {\n\t\t\tr_list_append (fcns, fcn);\n\t\t}\n\t}\n\n\t// Use afls[asn] to sort by address, size or name, dont sort it here .. r_list_sort (fcns, &cmpfcn);\n\tif (!rad) {\n\t\tfcn_list_default (core, fcns, false);\n\t\tr_list_free (fcns);\n\t\treturn 0;\n\t}\n\tswitch (*rad) {\n\tcase '+':\n\t\tr_core_anal_fcn_list_size (core);\n\t\tbreak;\n\tcase '=': { // afl=\n\t\tr_list_sort (fcns, cmpaddr);\n\t\tRList *flist = r_list_newf ((RListFree) r_listinfo_free);\n\t\tif (!flist) {\n\t\t\tr_list_free (fcns);\n\t\t\treturn -1;\n\t\t}\n\t\tls_foreach (fcns, iter, fcn) {\n\t\t\tRInterval inter = {r_anal_function_min_addr (fcn), r_anal_function_linear_size (fcn) };\n\t\t\tRListInfo *info = r_listinfo_new (r_core_anal_fcn_name (core, fcn), inter, inter, -1, sdb_itoa (fcn->bits, temp, 10));\n\t\t\tif (!info) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (flist, info);\n\t\t}\n\t\tRTable *table = r_core_table (core, \"functions\");\n\t\tr_table_visual_list (table, flist, core->offset, core->blocksize,\n\t\t\tr_cons_get_size (NULL), r_config_get_i (core->config, \"scr.color\"));\n\t\tr_cons_printf (\"\\n%s\\n\", r_table_tostring (table));\n\t\tr_table_free (table);\n\t\tr_list_free (flist);\n\t\tbreak;\n\t\t}\n\tcase ',': // \"afl,\" \"afl,j\"\n\tcase 't': // \"aflt\" \"afltj\"\n\t\tif (rad[1] == 'j') {\n\t\t\tfcn_list_table (core, r_str_trim_head_ro (rad + 2), 'j');\n\t\t} else {\n\t\t\tfcn_list_table (core, r_str_trim_head_ro (rad + 1), rad[1]);\n\t\t}\n\t\tbreak;\n\tcase 'l': // \"afll\" \"afllj\"\n\t\tif (rad[1] == 'j') {\n\t\t\tfcn_list_verbose_json (core, fcns);\n\t\t} else {\n\t\t\tchar *sp = strchr (rad, ' ');\n\t\t\tfcn_list_verbose (core, fcns, sp?sp+1: NULL);\n\t\t}\n\t\tbreak;\n\tcase 'q':\n\t\tif (rad[1] == 'j') {\n\t\t\tfcn_list_json (core, fcns, true);\n\t\t} else {\n\t\t\tfcn_list_default (core, fcns, true);\n\t\t}\n\t\tbreak;\n\tcase 'j':\n\t\tfcn_list_json (core, fcns, false);\n\t\tbreak;\n\tcase '*':\n\t\tfcn_list_detail (core, fcns);\n\t\tbreak;\n\tcase 'm': // \"aflm\"\n\t\t{\n\t\t\tchar mode = 'm';\n\t\t\tif (rad[1] != 0) {\n\t\t\t\tif (rad[1] == 'j') { // \"aflmj\"\n\t\t\t\t\tmode = 'j';\n\t\t\t\t} else if (rad[1] == 'q') { // \"aflmq\"\n\t\t\t\t\tmode = 'q';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfcn_print_makestyle (core, fcns, mode);\n\t\t\tbreak;\n\t\t}\n\tcase 1:\n\t\tfcn_list_legacy (core, fcns);\n\t\tbreak;\n\tdefault:\n\t\tfcn_list_default (core, fcns, false);\n\t\tbreak;\n\t}\n\tr_list_free (fcns);\n\treturn 0;\n}\n\nstatic RList *recurse_bb(RCore *core, ut64 addr, RAnalBlock *dest);\n\nstatic RList *recurse(RCore *core, RAnalBlock *from, RAnalBlock *dest) {\n\trecurse_bb (core, from->jump, dest);\n\trecurse_bb (core, from->fail, dest);\n\n\t/* same for all calls */\n\t// TODO: RAnalBlock must contain a linked list of calls\n\treturn NULL;\n}\n\nstatic RList *recurse_bb(RCore *core, ut64 addr, RAnalBlock *dest) {\n\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, addr);\n\tif (bb == dest) {\n\t\teprintf (\"path found!\");\n\t\treturn NULL;\n\t}\n\treturn recurse (core, bb, dest);\n}\n\n#define REG_SET_SIZE (R_ANAL_CC_MAXARG + 2)\n\ntypedef struct {\n\tint count;\n\tRPVector reg_set;\n\tbool argonly;\n\tRAnalFunction *fcn;\n\tRCore *core;\n} BlockRecurseCtx;\n\nstatic bool anal_block_on_exit(RAnalBlock *bb, BlockRecurseCtx *ctx) {\n\tint *cur_regset = r_pvector_pop (&ctx->reg_set);\n\tint *prev_regset = r_pvector_at (&ctx->reg_set, r_pvector_len (&ctx->reg_set) - 1);\n\tsize_t i;\n\tfor (i = 0; i < REG_SET_SIZE; i++) {\n\t\tif (!prev_regset[i] && cur_regset[i] == 1) {\n\t\t\tprev_regset[i] = 1;\n\t\t}\n\t}\n\tfree (cur_regset);\n\treturn true;\n}\n\nstatic bool anal_block_cb(RAnalBlock *bb, BlockRecurseCtx *ctx) {\n\tif (r_cons_is_breaked ()) {\n\t\treturn false;\n\t}\n\tif (bb->size < 1) {\n\t\treturn true;\n\t}\n\tif (bb->size > ctx->core->anal->opt.bb_max_size) {\n\t\treturn true;\n\t}\n\tint *parent_reg_set = r_pvector_at (&ctx->reg_set, r_pvector_len (&ctx->reg_set) - 1);\n\tint *reg_set = R_NEWS (int, REG_SET_SIZE);\n\tmemcpy (reg_set, parent_reg_set, REG_SET_SIZE * sizeof (int));\n\tr_pvector_push (&ctx->reg_set, reg_set);\n\tRCore *core = ctx->core;\n\tRAnalFunction *fcn = ctx->fcn;\n\tfcn->stack = bb->parent_stackptr;\n\tut64 pos = bb->addr;\n\twhile (pos < bb->addr + bb->size) {\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tRAnalOp *op = r_core_anal_op (core, pos, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_HINT);\n\t\tif (!op) {\n\t\t\t//eprintf (\"Cannot get op\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tr_anal_extract_rarg (core->anal, op, fcn, reg_set, &ctx->count);\n\t\tif (!ctx->argonly) {\n\t\t\tif (op->stackop == R_ANAL_STACK_INC) {\n\t\t\t\tfcn->stack += op->stackptr;\n\t\t\t} else if (op->stackop == R_ANAL_STACK_RESET) {\n\t\t\t\tfcn->stack = 0;\n\t\t\t}\n\t\t\tr_anal_extract_vars (core->anal, fcn, op);\n\t\t}\n\t\tint opsize = op->size;\n\t\tint optype = op->type;\n\t\tr_anal_op_free (op);\n\t\tif (opsize < 1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (optype == R_ANAL_OP_TYPE_CALL) {\n\t\t\tsize_t i;\n\t\t\tint max_count = fcn->cc ? r_anal_cc_max_arg (core->anal, fcn->cc) : 0;\n\t\t\tfor (i = 0; i < max_count; i++) {\n\t\t\t\treg_set[i] = 2;\n\t\t\t}\n\t\t}\n\t\tpos += opsize;\n\t}\n\treturn true;\n}\n\n// TODO: move this logic into the main anal loop\nR_API void r_core_recover_vars(RCore *core, RAnalFunction *fcn, bool argonly) {\n\tr_return_if_fail (core && core->anal && fcn);\n\tif (core->anal->opt.bb_max_size < 1) {\n\t\treturn;\n\t}\n\tBlockRecurseCtx ctx = { 0, {{ 0 }}, argonly, fcn, core };\n\tr_pvector_init (&ctx.reg_set, free);\n\tint *reg_set = R_NEWS0 (int, REG_SET_SIZE);\n\tr_pvector_push (&ctx.reg_set, reg_set);\n\tint saved_stack = fcn->stack;\n\tRAnalBlock *first_bb = r_anal_get_block_at (fcn->anal, fcn->addr);\n\tr_anal_block_recurse_depth_first (first_bb, (RAnalBlockCb)anal_block_cb, (RAnalBlockCb)anal_block_on_exit, &ctx);\n\tr_pvector_fini (&ctx.reg_set);\n\tfcn->stack = saved_stack;\n}\n\nstatic bool anal_path_exists(RCore *core, ut64 from, ut64 to, RList *bbs, int depth, HtUP *state, HtUP *avoid) {\n\tr_return_val_if_fail (bbs, false);\n\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, from);\n\tRListIter *iter = NULL;\n\tRAnalRef *refi;\n\n\tif (depth < 0) {\n\t\teprintf (\"going too deep\\n\");\n\t\treturn false;\n\t}\n\n\tif (!bb) {\n\t\treturn false;\n\t}\n\n\tht_up_update (state, from, bb);\n\n\t// try to find the target in the current function\n\tif (r_anal_block_contains (bb, to) ||\n\t\t((!ht_up_find (avoid, bb->jump, NULL) &&\n\t\t\t!ht_up_find (state, bb->jump, NULL) &&\n\t\t\tanal_path_exists (core, bb->jump, to, bbs, depth - 1, state, avoid))) ||\n\t\t((!ht_up_find (avoid, bb->fail, NULL) &&\n\t\t\t!ht_up_find (state, bb->fail, NULL) &&\n\t\t\tanal_path_exists (core, bb->fail, to, bbs, depth - 1, state, avoid)))) {\n\t\tr_list_prepend (bbs, bb);\n\t\treturn true;\n\t}\n\n\t// find our current function\n\tRAnalFunction *cur_fcn = r_anal_get_fcn_in (core->anal, from, 0);\n\n\t// get call refs from current basic block and find a path from them\n\tif (cur_fcn) {\n\t\tRList *refs = r_anal_function_get_refs (cur_fcn);\n\t\tif (refs) {\n\t\t\tr_list_foreach (refs, iter, refi) {\n\t\t\t\tif (refi->type == R_ANAL_REF_TYPE_CALL) {\n\t\t\t\t\tif (r_anal_block_contains (bb, refi->at)) {\n\t\t\t\t\t\tif ((refi->at != refi->addr) && !ht_up_find (state, refi->addr, NULL) && anal_path_exists (core, refi->addr, to, bbs, depth - 1, state, avoid)) {\n\t\t\t\t\t\t\tr_list_prepend (bbs, bb);\n\t\t\t\t\t\t\tr_list_free (refs);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tr_list_free (refs);\n\t}\n\n\treturn false;\n}\n\nstatic RList *anal_graph_to(RCore *core, ut64 addr, int depth, HtUP *avoid) {\n\tRAnalFunction *cur_fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\tRList *list = r_list_new ();\n\tHtUP *state = ht_up_new0 ();\n\n\tif (!list || !state || !cur_fcn) {\n\t\tr_list_free (list);\n\t\tht_up_free (state);\n\t\treturn NULL;\n\t}\n\n\t// forward search\n\tif (anal_path_exists (core, core->offset, addr, list, depth - 1, state, avoid)) {\n\t\tht_up_free (state);\n\t\treturn list;\n\t}\n\n\t// backward search\n\tRList *xrefs = r_anal_xrefs_get (core->anal, cur_fcn->addr);\n\tif (xrefs) {\n\t\tRListIter *iter;\n\t\tRAnalRef *xref = NULL;\n\t\tr_list_foreach (xrefs, iter, xref) {\n\t\t\tif (xref->type == R_ANAL_REF_TYPE_CALL) {\n\t\t\t\tut64 offset = core->offset;\n\t\t\t\tcore->offset = xref->addr;\n\t\t\t\tr_list_free (list);\n\t\t\t\tlist = anal_graph_to (core, addr, depth - 1, avoid);\n\t\t\t\tcore->offset = offset;\n\t\t\t\tif (list && r_list_length (list)) {\n\t\t\t\t\tr_list_free (xrefs);\n\t\t\t\t\tht_up_free (state);\n\t\t\t\t\treturn list;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tr_list_free (xrefs);\n\tht_up_free (state);\n\tr_list_free (list);\n\treturn NULL;\n}\n\nR_API RList* r_core_anal_graph_to(RCore *core, ut64 addr, int n) {\n\tint depth = r_config_get_i (core->config, \"anal.graph_depth\");\n\tRList *path, *paths = r_list_new ();\n\tHtUP *avoid = ht_up_new0 ();\n\twhile (n) {\n\t\tpath = anal_graph_to (core, addr, depth, avoid);\n\t\tif (path) {\n\t\t\tr_list_append (paths, path);\n\t\t\tif (r_list_length (path) >= 2) {\n\t\t\t\tRAnalBlock *last = r_list_get_n (path, r_list_length (path) - 2);\n\t\t\t\tht_up_update (avoid, last->addr, last);\n\t\t\t\tn--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t// no more path found\n\t\tbreak;\n\t}\n\tht_up_free (avoid);\n\treturn paths;\n}\n\nR_API int r_core_anal_graph(RCore *core, ut64 addr, int opts) {\n\tut64 from = r_config_get_i (core->config, \"graph.from\");\n\tut64 to = r_config_get_i (core->config, \"graph.to\");\n\tconst char *font = r_config_get (core->config, \"graph.font\");\n\tint is_html = r_cons_context ()->is_html;\n\tint is_json = opts & R_CORE_ANAL_JSON;\n\tint is_json_format_disasm = opts & R_CORE_ANAL_JSON_FORMAT_DISASM;\n\tint is_keva = opts & R_CORE_ANAL_KEYVALUE;\n\tint is_star = opts & R_CORE_ANAL_STAR;\n\tRConfigHold *hc;\n\tRAnalFunction *fcni;\n\tRListIter *iter;\n\tint nodes = 0;\n\tPJ *pj = NULL;\n\n\tif (!addr) {\n\t\taddr = core->offset;\n\t}\n\tif (r_list_empty (core->anal->fcns)) {\n\t\treturn false;\n\t}\n\thc = r_config_hold_new (core->config);\n\tif (!hc) {\n\t\treturn false;\n\t}\n\n\tr_config_hold (hc, \"asm.lines\", \"asm.bytes\", \"asm.dwarf\", NULL);\n\t//opts |= R_CORE_ANAL_GRAPHBODY;\n\tr_config_set_i (core->config, \"asm.lines\", 0);\n\tr_config_set_i (core->config, \"asm.dwarf\", 0);\n\tif (!is_json_format_disasm) {\n\t\tr_config_hold (hc, \"asm.bytes\", NULL);\n\t\tr_config_set_i (core->config, \"asm.bytes\", 0);\n\t}\n\tif (!is_html && !is_json && !is_keva && !is_star) {\n\t\tconst char * gv_edge = r_config_get (core->config, \"graph.gv.edge\");\n\t\tconst char * gv_node = r_config_get (core->config, \"graph.gv.node\");\n\t\tconst char * gv_spline = r_config_get (core->config, \"graph.gv.spline\");\n\t\tif (!gv_edge || !*gv_edge) {\n\t\t\tgv_edge = \"arrowhead=\\\"normal\\\"\";\n\t\t}\n\t\tif (!gv_node || !*gv_node) {\n\t\t\tgv_node = \"fillcolor=gray style=filled shape=box\";\n\t\t}\n\t\tif (!gv_spline || !*gv_spline) {\n\t\t\tgv_spline = \"splines=\\\"ortho\\\"\";\n\t\t}\n\t\tr_cons_printf (\"digraph code {\\n\"\n\t\t\t\"\\tgraph [bgcolor=azure fontsize=8 fontname=\\\"%s\\\" %s];\\n\"\n\t\t\t\"\\tnode [%s];\\n\"\n\t\t\t\"\\tedge [%s];\\n\", font, gv_spline, gv_node, gv_edge);\n\t}\n\tif (is_json) {\n\t\tpj = r_core_pj_new (core);\n\t\tif (!pj) {\n\t\t\tr_config_hold_restore (hc);\n\t\t\tr_config_hold_free (hc);\n\t\t\treturn false;\n\t\t}\n\t\tpj_a (pj);\n\t}\n\tr_list_foreach (core->anal->fcns, iter, fcni) {\n\t\tif (fcni->type & (R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_FCN |\n\t\t\t\t\t\t  R_ANAL_FCN_TYPE_LOC) &&\n\t\t\t(addr == UT64_MAX || r_anal_get_fcn_in (core->anal, addr, 0) == fcni)) {\n\t\t\tif (addr == UT64_MAX && (from != UT64_MAX && to != UT64_MAX)) {\n\t\t\t\tif (fcni->addr < from || fcni->addr > to) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnodes += core_anal_graph_nodes (core, fcni, opts, pj);\n\t\t\tif (addr != UT64_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!nodes) {\n\t\tif (!is_html && !is_json && !is_keva) {\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\t\tif (is_star) {\n\t\t\t\t\tchar *name = get_title(fcn ? fcn->addr: addr);\n\t\t\t\t\tr_cons_printf (\"agn %s;\", name);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"\\t\\\"0x%08\"PFMT64x\"\\\";\\n\", fcn? fcn->addr: addr);\n\t\t\t}\n\t\t}\n\t}\n\tif (!is_keva && !is_html && !is_json && !is_star && !is_json_format_disasm) {\n\t\tr_cons_printf (\"}\\n\");\n\t}\n\tif (is_json) {\n\t\tpj_end (pj);\n\t\tr_cons_printf (\"%s\\n\", pj_string (pj));\n\t\tpj_free (pj);\n\t}\n\tr_config_hold_restore (hc);\n\tr_config_hold_free (hc);\n\treturn true;\n}\n\nstatic int core_anal_followptr(RCore *core, int type, ut64 at, ut64 ptr, ut64 ref, int code, int depth) {\n\t// SLOW Operation try to reduce as much as possible\n\tif (!ptr) {\n\t\treturn false;\n\t}\n\tif (ref == UT64_MAX || ptr == ref) {\n\t\tconst RAnalRefType t = code? type? type: R_ANAL_REF_TYPE_CODE: R_ANAL_REF_TYPE_DATA;\n\t\tr_anal_xrefs_set (core->anal, at, ptr, t);\n\t\treturn true;\n\t}\n\tif (depth < 0) {\n\t\treturn false;\n\t}\n\tint wordsize = (int)(core->anal->bits / 8);\n\tut64 dataptr;\n\tif (!r_io_read_i (core->io, ptr, &dataptr, wordsize, false)) {\n\t\t// eprintf (\"core_anal_followptr: Cannot read word at destination\\n\");\n\t\treturn false;\n\t}\n\treturn core_anal_followptr (core, type, at, dataptr, ref, code, depth - 1);\n}\n\nstatic bool opiscall(RCore *core, RAnalOp *aop, ut64 addr, const ut8* buf, int len, int arch) {\n\tswitch (arch) {\n\tcase R2_ARCH_ARM64:\n\t\taop->size = 4;\n\t\t//addr should be aligned by 4 in aarch64\n\t\tif (addr % 4) {\n\t\t\tchar diff = addr % 4;\n\t\t\taddr = addr - diff;\n\t\t\tbuf = buf - diff;\n\t\t}\n\t\t//if is not bl do not analyze\n\t\tif (buf[3] == 0x94) {\n\t\t\tif (r_anal_op (core->anal, aop, addr, buf, len, R_ANAL_OP_MASK_BASIC)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\taop->size = 1;\n\t\tif (r_anal_op (core->anal, aop, addr, buf, len, R_ANAL_OP_MASK_BASIC)) {\n\t\t\tswitch (aop->type & R_ANAL_OP_TYPE_MASK) {\n\t\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\tcase R_ANAL_OP_TYPE_CCALL:\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn false;\n}\n\n// TODO(maskray) RAddrInterval API\n#define OPSZ 8\nR_API int r_core_anal_search(RCore *core, ut64 from, ut64 to, ut64 ref, int mode) {\n\tut8 *buf = (ut8 *)malloc (core->blocksize);\n\tif (!buf) {\n\t\treturn -1;\n\t}\n\tint ptrdepth = r_config_get_i (core->config, \"anal.ptrdepth\");\n\tint i, count = 0;\n\tRAnalOp op = R_EMPTY;\n\tut64 at;\n\tchar bckwrds, do_bckwrd_srch;\n\tint arch = -1;\n\tif (core->rasm->bits == 64) {\n\t\t// speedup search\n\t\tif (!strncmp (core->rasm->cur->name, \"arm\", 3)) {\n\t\t\tarch = R2_ARCH_ARM64;\n\t\t}\n\t}\n\t// TODO: get current section range here or gtfo\n\t// ???\n\t// XXX must read bytes correctly\n\tdo_bckwrd_srch = bckwrds = core->search->bckwrds;\n\tif (!ref) {\n\t\teprintf (\"Null reference search is not supported\\n\");\n\t\tfree (buf);\n\t\treturn -1;\n\t}\n\tr_cons_break_push (NULL, NULL);\n\tif (core->blocksize > OPSZ) {\n\t\tif (bckwrds) {\n\t\t\tif (from + core->blocksize > to) {\n\t\t\t\tat = from;\n\t\t\t\tdo_bckwrd_srch = false;\n\t\t\t} else {\n\t\t\t\tat = to - core->blocksize;\n\t\t\t}\n\t\t} else {\n\t\t\tat = from;\n\t\t}\n\t\twhile ((!bckwrds && at < to) || bckwrds) {\n\t\t\teprintf (\"\\r[0x%08\"PFMT64x\"-0x%08\"PFMT64x\"] \", at, to);\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// TODO: this can be probably enhanced\n\t\t\tif (!r_io_read_at (core->io, at, buf, core->blocksize)) {\n\t\t\t\teprintf (\"Failed to read at 0x%08\" PFMT64x \"\\n\", at);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (i = bckwrds ? (core->blocksize - OPSZ - 1) : 0;\n\t\t\t\t (!bckwrds && i < core->blocksize - OPSZ) ||\n\t\t\t\t (bckwrds && i > 0);\n\t\t\t\t bckwrds ? i-- : i++) {\n\t\t\t\t// TODO: honor anal.align\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tswitch (mode) {\n\t\t\t\tcase 'c':\n\t\t\t\t\t(void)opiscall (core, &op, at + i, buf + i, core->blocksize - i, arch);\n\t\t\t\t\tif (op.size < 1) {\n\t\t\t\t\t\top.size = 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'r':\n\t\t\t\tcase 'w':\n\t\t\t\tcase 'x':\n\t\t\t\t\t{\n\t\t\t\t\t\tr_anal_op (core->anal, &op, at + i, buf + i, core->blocksize - i, R_ANAL_OP_MASK_BASIC);\n\t\t\t\t\t\tint mask = mode=='r' ? 1 : mode == 'w' ? 2: mode == 'x' ? 4: 0;\n\t\t\t\t\t\tif (op.direction == mask) {\n\t\t\t\t\t\t\ti += op.size;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_anal_op_fini (&op);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (!r_anal_op (core->anal, &op, at + i, buf + i, core->blocksize - i, R_ANAL_OP_MASK_BASIC)) {\n\t\t\t\t\t\tr_anal_op_fini (&op);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tswitch (op.type) {\n\t\t\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\t\tcase R_ANAL_OP_TYPE_CCALL:\n\t\t\t\t\tif (op.jump != UT64_MAX &&\n\t\t\t\t\t\tcore_anal_followptr (core, 'C', at + i, op.jump, ref, true, 0)) {\n\t\t\t\t\t\tcount ++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_OP_TYPE_UCJMP:\n\t\t\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\t\t\tcase R_ANAL_OP_TYPE_IJMP:\n\t\t\t\tcase R_ANAL_OP_TYPE_RJMP:\n\t\t\t\tcase R_ANAL_OP_TYPE_IRJMP:\n\t\t\t\tcase R_ANAL_OP_TYPE_MJMP:\n\t\t\t\t\tif (op.ptr != UT64_MAX &&\n\t\t\t\t\t\tcore_anal_followptr (core, 'c', at + i, op.ptr, ref, true ,1)) {\n\t\t\t\t\t\tcount ++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\t\t\tcase R_ANAL_OP_TYPE_ICALL:\n\t\t\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\t\t\tcase R_ANAL_OP_TYPE_IRCALL:\n\t\t\t\tcase R_ANAL_OP_TYPE_UCCALL:\n\t\t\t\t\tif (op.ptr != UT64_MAX &&\n\t\t\t\t\t\tcore_anal_followptr (core, 'C', at + i, op.ptr, ref, true ,1)) {\n\t\t\t\t\t\tcount ++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!r_anal_op (core->anal, &op, at + i, buf + i, core->blocksize - i, R_ANAL_OP_MASK_BASIC)) {\n\t\t\t\t\t\t\tr_anal_op_fini (&op);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (op.ptr != UT64_MAX &&\n\t\t\t\t\t\tcore_anal_followptr (core, 'd', at + i, op.ptr, ref, false, ptrdepth)) {\n\t\t\t\t\t\tcount ++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (op.size < 1) {\n\t\t\t\t\top.size = 1;\n\t\t\t\t}\n\t\t\t\ti += op.size - 1;\n\t\t\t\tr_anal_op_fini (&op);\n\t\t\t}\n\t\t\tif (bckwrds) {\n\t\t\t\tif (!do_bckwrd_srch) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (at > from + core->blocksize - OPSZ) {\n\t\t\t\t\tat -= core->blocksize;\n\t\t\t\t} else {\n\t\t\t\t\tdo_bckwrd_srch = false;\n\t\t\t\t\tat = from;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tat += core->blocksize - OPSZ;\n\t\t\t}\n\t\t}\n\t} else {\n\t\teprintf (\"error: block size too small\\n\");\n\t}\n\tr_cons_break_pop ();\n\tfree (buf);\n\tr_anal_op_fini (&op);\n\treturn count;\n}\n\nstatic bool found_xref(RCore *core, ut64 at, ut64 xref_to, RAnalRefType type, PJ *pj, int rad, bool cfg_debug, bool cfg_anal_strings) {\n\t// Validate the reference. If virtual addressing is enabled, we\n\t// allow only references to virtual addresses in order to reduce\n\t// the number of false positives. In debugger mode, the reference\n\t// must point to a mapped memory region.\n\tif (type == R_ANAL_REF_TYPE_NULL) {\n\t\treturn false;\n\t}\n\tif (cfg_debug) {\n\t\tif (!r_debug_map_get (core->dbg, xref_to)) {\n\t\t\treturn false;\n\t\t}\n\t} else if (core->io->va) {\n\t\tif (!r_io_is_valid_offset (core->io, xref_to, 0)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (!rad) {\n\t\tif (cfg_anal_strings && type == R_ANAL_REF_TYPE_DATA) {\n\t\t\tint len = 0;\n\t\t\tchar *str_string = is_string_at (core, xref_to, &len);\n\t\t\tif (str_string) {\n\t\t\t\tr_name_filter (str_string, -1);\n\t\t\t\tchar *str_flagname = r_str_newf (\"str.%s\", str_string);\n\t\t\t\tr_flag_space_push (core->flags, R_FLAGS_FS_STRINGS);\n\t\t\t\t(void)r_flag_set (core->flags, str_flagname, xref_to, 1);\n\t\t\t\tr_flag_space_pop (core->flags);\n\t\t\t\tfree (str_flagname);\n\t\t\t\tif (len > 0) {\n\t\t\t\t\tr_meta_set (core->anal, R_META_TYPE_STRING, xref_to,\n\t\t\t\t\t\t\t\tlen, (const char *) str_string);\n\t\t\t\t}\n\t\t\t\tfree (str_string);\n\t\t\t}\n\t\t}\n\t\t// Add to SDB\n\t\tif (xref_to) {\n\t\t\tr_anal_xrefs_set (core->anal, at, xref_to, type);\n\t\t}\n\t} else if (rad == 'j') {\n\t\tr_strf_var (key, 32, \"0x%\"PFMT64x, xref_to);\n\t\tr_strf_var (value, 32, \"0x%\"PFMT64x, at);\n\t\tpj_ks (pj, key, value);\n\t} else {\n\t\tint len = 0;\n\t\t// Display in radare commands format\n\t\tchar *cmd;\n\t\tswitch (type) {\n\t\tcase R_ANAL_REF_TYPE_CODE: cmd = \"axc\"; break;\n\t\tcase R_ANAL_REF_TYPE_CALL: cmd = \"axC\"; break;\n\t\tcase R_ANAL_REF_TYPE_DATA: cmd = \"axd\"; break;\n\t\tdefault: cmd = \"ax\"; break;\n\t\t}\n\t\tr_cons_printf (\"%s 0x%08\"PFMT64x\" 0x%08\"PFMT64x\"\\n\", cmd, xref_to, at);\n\t\tif (cfg_anal_strings && type == R_ANAL_REF_TYPE_DATA) {\n\t\t\tchar *str_flagname = is_string_at (core, xref_to, &len);\n\t\t\tif (str_flagname) {\n\t\t\t\tut64 str_addr = xref_to;\n\t\t\t\tr_name_filter (str_flagname, -1);\n\t\t\t\tr_cons_printf (\"f str.%s=0x%\"PFMT64x\"\\n\", str_flagname, str_addr);\n\t\t\t\tr_cons_printf (\"Cs %d @ 0x%\"PFMT64x\"\\n\", len, str_addr);\n\t\t\t\tfree (str_flagname);\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nR_API int r_core_anal_search_xrefs(RCore *core, ut64 from, ut64 to, PJ *pj, int rad) {\n\tconst bool cfg_debug = r_config_get_b (core->config, \"cfg.debug\");\n\tbool cfg_anal_strings = r_config_get_i (core->config, \"anal.strings\");\n\tut64 at;\n\tint count = 0;\n\tint bsz = 8096;\n\tRAnalOp op = { 0 };\n\n\tif (from == to) {\n\t\treturn -1;\n\t}\n\tif (from > to) {\n\t\teprintf (\"Invalid range (0x%\"PFMT64x\n\t\t\" >= 0x%\"PFMT64x\")\\n\", from, to);\n\t\treturn -1;\n\t}\n\n\tif (core->blocksize <= OPSZ) {\n\t\teprintf (\"Error: block size too small\\n\");\n\t\treturn -1;\n\t}\n\tut8 *buf = malloc (bsz);\n\tif (!buf) {\n\t\teprintf (\"Error: cannot allocate a block\\n\");\n\t\treturn -1;\n\t}\n\tut8 *block = malloc (bsz);\n\tif (!block) {\n\t\teprintf (\"Error: cannot allocate a temp block\\n\");\n\t\tfree (buf);\n\t\treturn -1;\n\t}\n\tr_cons_break_push (NULL, NULL);\n\tat = from;\n\tst64 asm_sub_varmin = r_config_get_i (core->config, \"asm.sub.varmin\");\n\tint maxopsz = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MAX_OP_SIZE);\n\tint minopsz = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\tif (maxopsz < 1) {\n\t\tmaxopsz = 4;\n\t}\n\tif (minopsz < 1) {\n\t\tminopsz = 1;\n\t}\n\tif (bsz < maxopsz) {\n\t\t// wtf\n\t\teprintf (\"Error: Something is really wrong deep inside\\n\");\n\t\tfree (block);\n\t\treturn -1;\n\t}\n\twhile (at < to && !r_cons_is_breaked ()) {\n\t\tint i = 0, ret = bsz;\n\t\tif (!r_io_is_valid_offset (core->io, at, R_PERM_X)) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 left = to - at;\n\t\tif (bsz > left) {\n\t\t\tbsz = left;\n\t\t}\n\t\t(void)r_io_read_at (core->io, at, buf, bsz);\n\t\tmemset (block, -1, bsz);\n\t\tif (!memcmp (buf, block, bsz)) {\n\t\t//\teprintf (\"Error: skipping uninitialized block \\n\");\n\t\t\tat += ret;\n\t\t\tcontinue;\n\t\t}\n\t\tmemset (block, 0, bsz);\n\t\tif (!memcmp (buf, block, bsz)) {\n\t\t//\teprintf (\"Error: skipping uninitialized block \\n\");\n\t\t\tat += ret;\n\t\t\tcontinue;\n\t\t}\n\t\t(void) r_anal_op (core->anal, &op, at, buf, bsz, R_ANAL_OP_MASK_BASIC | R_ANAL_OP_MASK_HINT);\n\t\twhile ((i + maxopsz) < bsz && !r_cons_is_breaked ()) {\n\t\t\tr_anal_op_fini (&op);\n\t\t\tret = r_anal_op (core->anal, &op, at + i, buf + i, bsz - i, R_ANAL_OP_MASK_BASIC | R_ANAL_OP_MASK_HINT);\n\t\t\tif (ret < 1) {\n\t\t\t\ti += minopsz;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti += ret;\n\t\t\tif (i > bsz) {\n\t\t\t\t// at += minopsz;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// find references\n\t\t\tif ((st64)op.val > asm_sub_varmin && op.val != UT64_MAX && op.val != UT32_MAX) {\n\t\t\t\tif (found_xref (core, op.addr, op.val, R_ANAL_REF_TYPE_DATA, pj, rad, cfg_debug, cfg_anal_strings)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// find references\n\t\t\tif (op.ptr && op.ptr != UT64_MAX && op.ptr != UT32_MAX) {\n\t\t\t\tif (found_xref (core, op.addr, op.ptr, R_ANAL_REF_TYPE_DATA, pj, rad, cfg_debug, cfg_anal_strings)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// find references\n\t\t\tif (op.addr > 512 && op.disp > 512 && op.disp && op.disp != UT64_MAX) {\n\t\t\t\tif (found_xref (core, op.addr, op.disp, R_ANAL_REF_TYPE_DATA, pj, rad, cfg_debug, cfg_anal_strings)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (op.type) {\n\t\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\t\tif (found_xref (core, op.addr, op.jump, R_ANAL_REF_TYPE_CODE, pj, rad, cfg_debug, cfg_anal_strings)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\tcase R_ANAL_OP_TYPE_CCALL:\n\t\t\t\tif (found_xref (core, op.addr, op.jump, R_ANAL_REF_TYPE_CALL, pj, rad, cfg_debug, cfg_anal_strings)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\t\tcase R_ANAL_OP_TYPE_IJMP:\n\t\t\tcase R_ANAL_OP_TYPE_RJMP:\n\t\t\tcase R_ANAL_OP_TYPE_IRJMP:\n\t\t\tcase R_ANAL_OP_TYPE_MJMP:\n\t\t\tcase R_ANAL_OP_TYPE_UCJMP:\n\t\t\t\tcount++;\n\t\t\t\tif (found_xref (core, op.addr, op.ptr, R_ANAL_REF_TYPE_CODE, pj, rad, cfg_debug, cfg_anal_strings)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\t\tcase R_ANAL_OP_TYPE_ICALL:\n\t\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\t\tcase R_ANAL_OP_TYPE_IRCALL:\n\t\t\tcase R_ANAL_OP_TYPE_UCCALL:\n\t\t\t\tif (found_xref (core, op.addr, op.ptr, R_ANAL_REF_TYPE_CALL, pj, rad, cfg_debug, cfg_anal_strings)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tr_anal_op_fini (&op);\n\t\tif (i < 1) {\n\t\t\tbreak;\n\t\t}\n\t\tat += i + 1;\n\t}\n\tr_cons_break_pop ();\n\tfree (buf);\n\tfree (block);\n\treturn count;\n}\n\nstatic bool isValidSymbol(RBinSymbol *symbol) {\n\tif (symbol && symbol->type) {\n\t\tconst char *type = symbol->type;\n\t\treturn (symbol->paddr != UT64_MAX) && (!strcmp (type, R_BIN_TYPE_FUNC_STR) || !strcmp (type, R_BIN_TYPE_HIOS_STR) || !strcmp (type, R_BIN_TYPE_LOOS_STR) || !strcmp (type, R_BIN_TYPE_METH_STR) || !strcmp (type , R_BIN_TYPE_STATIC_STR));\n\t}\n\treturn false;\n}\n\nstatic bool isSkippable(RBinSymbol *s) {\n\tif (s && s->name && s->bind) {\n\t\tif (r_str_startswith (s->name, \"radr://\")) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!strcmp (s->name, \"__mh_execute_header\")) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!strcmp (s->bind, \"NONE\")) {\n\t\t\tif (s->is_imported && s->libname && strstr(s->libname, \".dll\")) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nR_API int r_core_anal_all(RCore *core) {\n\tRList *list;\n\tRListIter *iter;\n\tRFlagItem *item;\n\tRAnalFunction *fcni;\n\tRBinAddr *binmain;\n\tRBinAddr *entry;\n\tRBinSymbol *symbol;\n\tconst bool anal_vars = r_config_get_i (core->config, \"anal.vars\");\n\tconst bool anal_calls = r_config_get_i (core->config, \"anal.calls\");\n\n\t/* Analyze Functions */\n\t/* Entries */\n\titem = r_flag_get (core->flags, \"entry0\");\n\tif (item) {\n\t\tr_core_af (core, item->offset, \"entry0\", anal_calls);\n\t} else {\n\t\tr_core_af (core, core->offset, NULL, anal_calls);\n\t}\n\n\tr_core_task_yield (&core->tasks);\n\n\tr_cons_break_push (NULL, NULL);\n\t/* Symbols (Imports are already analyzed by rabin2 on init) */\n\tif ((list = r_bin_get_symbols (core->bin)) != NULL) {\n\t\tr_list_foreach (list, iter, symbol) {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// Stop analyzing PE imports further\n\t\t\tif (isSkippable (symbol)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (isValidSymbol (symbol)) {\n\t\t\t\tut64 addr = r_bin_get_vaddr (core->bin, symbol->paddr, symbol->vaddr);\n\t\t\t\t// TODO: uncomment to: fcn.name = symbol.name, problematic for imports\n\t\t\t\t// r_core_af (core, addr, symbol->name, anal_calls);\n\t\t\t\tr_core_af (core, addr, NULL, anal_calls);\n\t\t\t}\n\t\t}\n\t}\n\tr_core_task_yield (&core->tasks);\n\t/* Main */\n\tif ((binmain = r_bin_get_sym (core->bin, R_BIN_SYM_MAIN))) {\n\t\tif (binmain->paddr != UT64_MAX) {\n\t\t\tut64 addr = r_bin_get_vaddr (core->bin, binmain->paddr, binmain->vaddr);\n\t\t\tr_core_af (core, addr, \"main\", anal_calls);\n\t\t}\n\t}\n\tr_core_task_yield (&core->tasks);\n\tif ((list = r_bin_get_entries (core->bin))) {\n\t\tr_list_foreach (list, iter, entry) {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (entry->paddr == UT64_MAX) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut64 addr = r_bin_get_vaddr (core->bin, entry->paddr, entry->vaddr);\n\t\t\tr_core_af (core, addr, NULL, anal_calls);\n\t\t}\n\t}\n\tr_core_task_yield (&core->tasks);\n\tif (anal_vars) {\n\t\t/* Set fcn type to R_ANAL_FCN_TYPE_SYM for symbols */\n\t\tr_list_foreach_prev (core->anal->fcns, iter, fcni) {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_core_recover_vars (core, fcni, true);\n\t\t\tif (!strncmp (fcni->name, \"dbg.\", 4) || !strncmp (fcni->name, \"sym.\", 4) || !strncmp (fcni->name, \"main\", 4)) {\n\t\t\t\tfcni->type = R_ANAL_FCN_TYPE_SYM;\n\t\t\t}\n\t\t}\n\t}\n\tr_cons_break_pop ();\n\treturn true;\n}\n\nR_API int r_core_anal_data(RCore *core, ut64 addr, int count, int depth, int wordsize) {\n\tRAnalData *d;\n\tut64 dstaddr = 0LL;\n\tut8 *buf = core->block;\n\tint len = core->blocksize;\n\tint word = wordsize ? wordsize: core->rasm->bits / 8;\n\tchar *str;\n\tint i, j;\n\n\tcount = R_MIN (count, len);\n\tbuf = malloc (len + 1);\n\tif (!buf) {\n\t\treturn false;\n\t}\n\tmemset (buf, 0xff, len);\n\tr_io_read_at (core->io, addr, buf, len);\n\tbuf[len - 1] = 0;\n\n\tRConsPrintablePalette *pal = r_config_get_i (core->config, \"scr.color\")? &r_cons_context ()->pal: NULL;\n\tfor (i = j = 0; j < count; j++) {\n\t\tif (i >= len) {\n\t\t\tr_io_read_at (core->io, addr + i, buf, len);\n\t\t\tbuf[len] = 0;\n\t\t\taddr += i;\n\t\t\ti = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t/* r_anal_data requires null-terminated buffer according to coverity */\n\t\t/* but it should not.. so this must be fixed in anal/data.c instead of */\n\t\t/* null terminating here */\n\t\td = r_anal_data (core->anal, addr + i, buf + i, len - i, wordsize);\n\t\tstr = r_anal_data_to_string (d, pal);\n\t\tr_cons_println (str);\n\n\t\tif (d) {\n\t\t\tswitch (d->type) {\n\t\t\tcase R_ANAL_DATA_TYPE_POINTER:\n\t\t\t\tr_cons_printf (\"`- \");\n\t\t\t\tdstaddr = r_mem_get_num (buf + i, word);\n\t\t\t\tif (depth > 0) {\n\t\t\t\t\tr_core_anal_data (core, dstaddr, 1, depth - 1, wordsize);\n\t\t\t\t}\n\t\t\t\ti += word;\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_DATA_TYPE_STRING:\n\t\t\t\tbuf[len-1] = 0;\n\t\t\t\ti += strlen ((const char*)buf + i) + 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ti += (d->len > 3)? d->len: word;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\ti += word;\n\t\t}\n\t\tfree (str);\n\t\tr_anal_data_free (d);\n\t}\n\tfree (buf);\n\treturn true;\n}\n\nstruct block_flags_stat_t {\n\tut64 step;\n\tut64 from;\n\tRCoreAnalStats *as;\n};\n\nstatic bool block_flags_stat(RFlagItem *fi, void *user) {\n\tstruct block_flags_stat_t *u = (struct block_flags_stat_t *)user;\n\tint piece = (fi->offset - u->from) / u->step;\n\tu->as->block[piece].flags++;\n\treturn true;\n}\n\n/* core analysis stats */\n/* stats --- colorful bar */\nR_API RCoreAnalStats* r_core_anal_get_stats(RCore *core, ut64 from, ut64 to, ut64 step) {\n\tRAnalFunction *F;\n\tRAnalBlock  *B;\n\tRBinSymbol *S;\n\tRListIter *iter, *iter2;\n\tRCoreAnalStats *as = NULL;\n\tint piece, as_size, blocks;\n\tut64 at;\n\n\tif (from == to || from == UT64_MAX || to == UT64_MAX) {\n\t\teprintf (\"Cannot alloc for this range\\n\");\n\t\treturn NULL;\n\t}\n\tas = R_NEW0 (RCoreAnalStats);\n\tif (!as) {\n\t\treturn NULL;\n\t}\n\tif (step < 1) {\n\t\tstep = 1;\n\t}\n\tblocks = (to - from) / step;\n\tas_size = (1 + blocks) * sizeof (RCoreAnalStatsItem);\n\tas->block = malloc (as_size);\n\tif (!as->block) {\n\t\tfree (as);\n\t\treturn NULL;\n\t}\n\tmemset (as->block, 0, as_size);\n\tfor (at = from; at < to; at += step) {\n\t\tRIOMap *map = r_io_map_get_at (core->io, at);\n\t\tpiece = (at - from) / step;\n\t\tas->block[piece].perm = map ? map->perm: (core->io->desc ? core->io->desc->perm: 0);\n\t}\n\t// iter all flags\n\tstruct block_flags_stat_t u = { .step = step, .from = from, .as = as };\n\tr_flag_foreach_range (core->flags, from, to + 1, block_flags_stat, &u);\n\t// iter all functions\n\tr_list_foreach (core->anal->fcns, iter, F) {\n\t\tif (F->addr < from || F->addr > to) {\n\t\t\tcontinue;\n\t\t}\n\t\tpiece = (F->addr - from) / step;\n\t\tas->block[piece].functions++;\n\t\tut64 last_piece = R_MIN ((F->addr + r_anal_function_linear_size (F) - 1) / step, blocks - 1);\n\t\tfor (; piece <= last_piece; piece++) {\n\t\t\tas->block[piece].in_functions++;\n\t\t}\n\t\t// iter all basic blocks\n\t\tr_list_foreach (F->bbs, iter2, B) {\n\t\t\tif (B->addr < from || B->addr > to) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpiece = (B->addr - from) / step;\n\t\t\tas->block[piece].blocks++;\n\t\t}\n\t}\n\t// iter all symbols\n\tr_list_foreach (r_bin_get_symbols (core->bin), iter, S) {\n\t\tif (S->vaddr < from || S->vaddr > to) {\n\t\t\tcontinue;\n\t\t}\n\t\tpiece = (S->vaddr - from) / step;\n\t\tas->block[piece].symbols++;\n\t}\n\tRPVector *metas = to > from ? r_meta_get_all_intersect (core->anal, from, to - from, R_META_TYPE_ANY) : NULL;\n\tif (metas) {\n\t\tvoid **it;\n\t\tr_pvector_foreach (metas, it) {\n\t\t\tRIntervalNode *node = *it;\n\t\t\tRAnalMetaItem *mi = node->data;\n\t\t\tif (node->start < from || node->end > to) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpiece = (node->start - from) / step;\n\t\t\tswitch (mi->type) {\n\t\t\tcase R_META_TYPE_STRING:\n\t\t\t\tas->block[piece].strings++;\n\t\t\t\tbreak;\n\t\t\tcase R_META_TYPE_COMMENT:\n\t\t\t\tas->block[piece].comments++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tr_pvector_free (metas);\n\t}\n\treturn as;\n}\n\nR_API void r_core_anal_stats_free(RCoreAnalStats *s) {\n\tif (s) {\n\t\tfree (s->block);\n\t}\n\tfree (s);\n}\n\nR_API RList* r_core_anal_cycles(RCore *core, int ccl) {\n\tut64 addr = core->offset;\n\tint depth = 0;\n\tRAnalOp *op = NULL;\n\tRAnalCycleFrame *prev = NULL, *cf = NULL;\n\tRAnalCycleHook *ch;\n\tRList *hooks = r_list_new ();\n\tif (!hooks) {\n\t\treturn NULL;\n\t}\n\tcf = r_anal_cycle_frame_new ();\n\tr_cons_break_push (NULL, NULL);\n\twhile (cf && !r_cons_is_breaked ()) {\n\t\tif ((op = r_core_anal_op (core, addr, R_ANAL_OP_MASK_BASIC)) && (op->cycles) && (ccl > 0)) {\n\t\t\tr_cons_clear_line (1);\n\t\t\teprintf (\"%i -- \", ccl);\n\t\t\taddr += op->size;\n\t\t\tswitch (op->type) {\n\t\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\t\taddr = op->jump;\n\t\t\t\tccl -= op->cycles;\n\t\t\t\tloganal (op->addr, addr, depth);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\t\tcase R_ANAL_OP_TYPE_MJMP:\n\t\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\t\tcase R_ANAL_OP_TYPE_ICALL:\n\t\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\t\tcase R_ANAL_OP_TYPE_IRCALL:\n\t\t\t\tch = R_NEW0 (RAnalCycleHook);\n\t\t\t\tch->addr = op->addr;\n\t\t\t\teprintf (\"0x%08\"PFMT64x\" > ?\\r\", op->addr);\n\t\t\t\tch->cycles = ccl;\n\t\t\t\tr_list_append (hooks, ch);\n\t\t\t\tch = NULL;\n\t\t\t\twhile (!ch && cf) {\n\t\t\t\t\tch = r_list_pop (cf->hooks);\n\t\t\t\t\tif (ch) {\n\t\t\t\t\t\taddr = ch->addr;\n\t\t\t\t\t\tccl = ch->cycles;\n\t\t\t\t\t\tfree (ch);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_anal_cycle_frame_free (cf);\n\t\t\t\t\t\tcf = prev;\n\t\t\t\t\t\tif (cf) {\n\t\t\t\t\t\t\tprev = cf->prev;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\t\tch = R_NEW0 (RAnalCycleHook);\n\t\t\t\tch->addr = addr;\n\t\t\t\tch->cycles = ccl - op->failcycles;\n\t\t\t\tr_list_push (cf->hooks, ch);\n\t\t\t\tch = NULL;\n\t\t\t\taddr = op->jump;\n\t\t\t\tloganal (op->addr, addr, depth);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_OP_TYPE_UCJMP:\n\t\t\tcase R_ANAL_OP_TYPE_UCCALL:\n\t\t\t\tch = R_NEW0 (RAnalCycleHook);\n\t\t\t\tch->addr = op->addr;\n\t\t\t\tch->cycles = ccl;\n\t\t\t\tr_list_append (hooks, ch);\n\t\t\t\tch = NULL;\n\t\t\t\tccl -= op->failcycles;\n\t\t\t\teprintf (\"0x%08\"PFMT64x\" > ?\\r\", op->addr);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_OP_TYPE_CCALL:\n\t\t\t\tch = R_NEW0 (RAnalCycleHook);\n\t\t\t\tch->addr = addr;\n\t\t\t\tch->cycles = ccl - op->failcycles;\n\t\t\t\tr_list_push (cf->hooks, ch);\n\t\t\t\tch = NULL;\n\t\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\t\tif (op->addr != op->jump) { //no selfies\n\t\t\t\t\tcf->naddr = addr;\n\t\t\t\t\tprev = cf;\n\t\t\t\t\tcf = r_anal_cycle_frame_new ();\n\t\t\t\t\tcf->prev = prev;\n\t\t\t\t}\n\t\t\t\tccl -= op->cycles;\n\t\t\t\taddr = op->jump;\n\t\t\t\tloganal (op->addr, addr, depth - 1);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\t\tch = R_NEW0 (RAnalCycleHook);\n\t\t\t\tif (prev) {\n\t\t\t\t\tch->addr = prev->naddr;\n\t\t\t\t\tccl -= op->cycles;\n\t\t\t\t\tch->cycles = ccl;\n\t\t\t\t\tr_list_push (prev->hooks, ch);\n\t\t\t\t\teprintf (\"0x%08\"PFMT64x\" < 0x%08\"PFMT64x\"\\r\", prev->naddr, op->addr);\n\t\t\t\t} else {\n\t\t\t\t\tch->addr = op->addr;\n\t\t\t\t\tch->cycles = ccl;\n\t\t\t\t\tr_list_append (hooks, ch);\n\t\t\t\t\teprintf (\"? < 0x%08\"PFMT64x\"\\r\", op->addr);\n\t\t\t\t}\n\t\t\t\tch = NULL;\n\t\t\t\twhile (!ch && cf) {\n\t\t\t\t\tch = r_list_pop (cf->hooks);\n\t\t\t\t\tif (ch) {\n\t\t\t\t\t\taddr = ch->addr;\n\t\t\t\t\t\tccl = ch->cycles;\n\t\t\t\t\t\tfree (ch);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_anal_cycle_frame_free (cf);\n\t\t\t\t\t\tcf = prev;\n\t\t\t\t\t\tif (cf) {\n\t\t\t\t\t\t\tprev = cf->prev;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_OP_TYPE_CRET:\n\t\t\t\tch = R_NEW0 (RAnalCycleHook);\n\t\t\t\tif (prev) {\n\t\t\t\t\tch->addr = prev->naddr;\n\t\t\t\t\tch->cycles = ccl - op->cycles;\n\t\t\t\t\tr_list_push (prev->hooks, ch);\n\t\t\t\t\teprintf (\"0x%08\"PFMT64x\" < 0x%08\"PFMT64x\"\\r\", prev->naddr, op->addr);\n\t\t\t\t} else {\n\t\t\t\t\tch->addr = op->addr;\n\t\t\t\t\tch->cycles = ccl - op->cycles;\n\t\t\t\t\tr_list_append (hooks, ch);\n\t\t\t\t\teprintf (\"? < 0x%08\"PFMT64x\"\\r\", op->addr);\n\t\t\t\t}\n\t\t\t\tccl -= op->failcycles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tccl -= op->cycles;\n\t\t\t\teprintf (\"0x%08\"PFMT64x\"\\r\", op->addr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tch = R_NEW0 (RAnalCycleHook);\n\t\t\tif (!ch) {\n\t\t\t\tr_anal_cycle_frame_free (cf);\n\t\t\t\tr_list_free (hooks);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tch->addr = addr;\n\t\t\tch->cycles = ccl;\n\t\t\tr_list_append (hooks, ch);\n\t\t\tch = NULL;\n\t\t\twhile (!ch && cf) {\n\t\t\t\tch = r_list_pop (cf->hooks);\n\t\t\t\tif (ch) {\n\t\t\t\t\taddr = ch->addr;\n\t\t\t\t\tccl = ch->cycles;\n\t\t\t\t\tfree (ch);\n\t\t\t\t} else {\n\t\t\t\t\tr_anal_cycle_frame_free (cf);\n\t\t\t\t\tcf = prev;\n\t\t\t\t\tif (cf) {\n\t\t\t\t\t\tprev = cf->prev;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tr_anal_op_free (op);\n\t}\n\tif (r_cons_is_breaked ()) {\n\t\twhile (cf) {\n\t\t\tch = r_list_pop (cf->hooks);\n\t\t\twhile (ch) {\n\t\t\t\tfree (ch);\n\t\t\t\tch = r_list_pop (cf->hooks);\n\t\t\t}\n\t\t\tprev = cf->prev;\n\t\t\tr_anal_cycle_frame_free (cf);\n\t\t\tcf = prev;\n\t\t}\n\t}\n\tr_cons_break_pop ();\n\treturn hooks;\n}\n\nint cmd_anal_fcn(RCore *core, const char *input);\nR_API void r_core_anal_undefine(RCore *core, ut64 off) {\n\t// very slow\n\t// RAnalFunction *f = r_anal_get_fcn_in (core->anal, off, -1);\n\tRAnalFunction *f = r_anal_get_function_at (core->anal, off);\n\tif (f) {\n\t\tif (!strncmp (f->name, \"fcn.\", 4)) {\n\t\t\tr_flag_unset_name (core->flags, f->name);\n\t\t}\n\t\tr_meta_del (core->anal, R_META_TYPE_ANY, r_anal_function_min_addr (f), r_anal_function_linear_size (f));\n\t\tr_anal_function_del (core->anal, off);\n\t}\n\t//r_anal_function_del_locs (core->anal, off);\n\tr_anal_delete_block_at (core->anal, off);\n\tchar *abcmd = r_str_newf (\"ab-0x%\"PFMT64x, off);\n\tcmd_anal_fcn (core, abcmd);\n\tfree (abcmd);\n}\n\n/* Join function at addr2 into function at addr */\n// addr use to be core->offset\nR_API void r_core_anal_fcn_merge(RCore *core, ut64 addr, ut64 addr2) {\n\tRListIter *iter;\n\tut64 min = 0;\n\tut64 max = 0;\n\tint first = 1;\n\tRAnalBlock *bb;\n\tRAnalFunction *f1 = r_anal_get_function_at (core->anal, addr);\n\tRAnalFunction *f2 = r_anal_get_function_at (core->anal, addr2);\n\tif (!f1 || !f2) {\n\t\teprintf (\"Cannot find function\\n\");\n\t\treturn;\n\t}\n\tif (f1 == f2) {\n\t\teprintf (\"Cannot merge the same function\\n\");\n\t\treturn;\n\t}\n\t// join all basic blocks from f1 into f2 if they are not\n\t// delete f2\n\teprintf (\"Merge 0x%08\"PFMT64x\" into 0x%08\"PFMT64x\"\\n\", addr, addr2);\n\tr_list_foreach (f1->bbs, iter, bb) {\n\t\tif (first) {\n\t\t\tmin = bb->addr;\n\t\t\tmax = bb->addr + bb->size;\n\t\t\tfirst = 0;\n\t\t} else {\n\t\t\tif (bb->addr < min) {\n\t\t\t\tmin = bb->addr;\n\t\t\t}\n\t\t\tif (bb->addr + bb->size > max) {\n\t\t\t\tmax = bb->addr + bb->size;\n\t\t\t}\n\t\t}\n\t}\n\tr_list_foreach (f2->bbs, iter, bb) {\n\t\tif (first) {\n\t\t\tmin = bb->addr;\n\t\t\tmax = bb->addr + bb->size;\n\t\t\tfirst = 0;\n\t\t} else {\n\t\t\tif (bb->addr < min) {\n\t\t\t\tmin = bb->addr;\n\t\t\t}\n\t\t\tif (bb->addr + bb->size > max) {\n\t\t\t\tmax = bb->addr + bb->size;\n\t\t\t}\n\t\t}\n\t\tr_anal_function_add_block (f1, bb);\n\t}\n\t// TODO: import data/code/refs\n\tr_anal_function_delete (f2);\n\t// update size\n\tr_anal_function_relocate (f2, R_MIN (addr, addr2));\n}\n\nstatic bool esil_anal_stop = false;\nstatic void cccb(void *u) {\n\tesil_anal_stop = true;\n\teprintf (\"^C\\n\");\n}\n\nstatic void add_string_ref(RCore *core, ut64 xref_from, ut64 xref_to) {\n\tint len = 0;\n\tif (xref_to == UT64_MAX || !xref_to) {\n\t\treturn;\n\t}\n\tif (!xref_from || xref_from == UT64_MAX) {\n\t\txref_from = core->anal->esil->address;\n\t}\n\tchar *str_flagname = is_string_at (core, xref_to, &len);\n\tif (str_flagname) {\n\t\tr_anal_xrefs_set (core->anal, xref_from, xref_to, R_ANAL_REF_TYPE_DATA);\n\t\tr_name_filter (str_flagname, -1);\n\t\tr_flag_space_push (core->flags, R_FLAGS_FS_STRINGS);\n\t\tchar *flagname = r_str_newf (\"str.%s\", str_flagname);\n\t\tr_flag_set (core->flags, flagname, xref_to, len);\n\t\tfree (flagname);\n\t\tr_flag_space_pop (core->flags);\n\t\tr_meta_set (core->anal, 's', xref_to, len, str_flagname);\n\t\tfree (str_flagname);\n\t}\n}\n\n\n// dup with isValidAddress wtf\nstatic bool myvalid(RIO *io, ut64 addr) {\n\tif (addr < 0x100) {\n\t\treturn false;\n\t}\n\tif (addr == UT32_MAX || addr == UT64_MAX) {\t//the best of the best of the best :(\n\t\treturn false;\n\t}\n\tif (!r_io_is_valid_offset (io, addr, 0)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\ntypedef struct {\n\tRAnalOp *op;\n\tRAnalFunction *fcn;\n\tconst char *spname;\n\tut64 initial_sp;\n} EsilBreakCtx;\n\nstatic const char *reg_name_for_access(RAnalOp* op, RAnalVarAccessType type) {\n\tif (type == R_ANAL_VAR_ACCESS_TYPE_WRITE) {\n\t\tif (op->dst && op->dst->reg) {\n\t\t\treturn op->dst->reg->name;\n\t\t}\n\t} else {\n\t\tif (op->src[0] && op->src[0]->reg) {\n\t\t\treturn op->src[0]->reg->name;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic ut64 delta_for_access(RAnalOp *op, RAnalVarAccessType type) {\n\tif (type == R_ANAL_VAR_ACCESS_TYPE_WRITE) {\n\t\tif (op->dst) {\n\t\t\treturn op->dst->imm + op->dst->delta;\n\t\t}\n\t} else {\n\t\tif (op->src[1] && (op->src[1]->imm || op->src[1]->delta)) {\n\t\t\treturn op->src[1]->imm + op->src[1]->delta;\n\t\t}\n\t\tif (op->src[0]) {\n\t\t\treturn op->src[0]->imm + op->src[0]->delta;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void handle_var_stack_access(RAnalEsil *esil, ut64 addr, RAnalVarAccessType type, int len) {\n\tEsilBreakCtx *ctx = esil->user;\n\tconst char *regname = reg_name_for_access (ctx->op, type);\n\tif (ctx->fcn && regname) {\n\t\tut64 spaddr = r_reg_getv (esil->anal->reg, ctx->spname);\n\t\tif (addr >= spaddr && addr < ctx->initial_sp) {\n\t\t\tint stack_off = addr - ctx->initial_sp;\n\t\t\tRAnalVar *var = r_anal_function_get_var (ctx->fcn, R_ANAL_VAR_KIND_SPV, stack_off);\n\t\t\tif (!var) {\n\t\t\t\tvar = r_anal_function_get_var (ctx->fcn, R_ANAL_VAR_KIND_BPV, stack_off);\n\t\t\t}\n\t\t\tif (!var && stack_off >= -ctx->fcn->maxstack) {\n\t\t\t\tchar *varname;\n\t\t\t\tvarname = ctx->fcn->anal->opt.varname_stack\n\t\t\t\t\t? r_str_newf (\"var_%xh\", R_ABS (stack_off))\n\t\t\t\t\t: r_anal_function_autoname_var (ctx->fcn, R_ANAL_VAR_KIND_SPV, \"var\", delta_for_access (ctx->op, type));\n\t\t\t\tvar = r_anal_function_set_var (ctx->fcn, stack_off, R_ANAL_VAR_KIND_SPV, NULL, len, false, varname);\n\t\t\t\tfree (varname);\n\t\t\t}\n\t\t\tif (var) {\n\t\t\t\tr_anal_var_set_access (var, regname, ctx->op->addr, type, delta_for_access (ctx->op, type));\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic bool esilbreak_mem_write(RAnalEsil *esil, ut64 addr, const ut8 *buf, int len) {\n\thandle_var_stack_access (esil, addr, R_ANAL_VAR_ACCESS_TYPE_WRITE, len);\n\treturn true;\n}\n\n/* TODO: move into RCore? */\nstatic ut64 esilbreak_last_read = UT64_MAX;\nstatic ut64 esilbreak_last_data = UT64_MAX;\n\nstatic ut64 ntarget = UT64_MAX;\n\n// TODO differentiate endian-aware mem_read with other reads; move ntarget handling to another function\nstatic bool esilbreak_mem_read(RAnalEsil *esil, ut64 addr, ut8 *buf, int len) {\n\tut8 str[128];\n\tif (addr != UT64_MAX) {\n\t\tesilbreak_last_read = addr;\n\t}\n\thandle_var_stack_access (esil, addr, R_ANAL_VAR_ACCESS_TYPE_READ, len);\n\tif (myvalid (mycore->io, addr) && r_io_read_at (mycore->io, addr, (ut8*)buf, len)) {\n\t\tut64 refptr;\n\t\tbool trace = true;\n\t\tswitch (len) {\n\t\tcase 2:\n\t\t\tesilbreak_last_data = refptr = (ut64)r_read_ble16 (buf, esil->anal->big_endian);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tesilbreak_last_data = refptr = (ut64)r_read_ble32 (buf, esil->anal->big_endian);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tesilbreak_last_data = refptr = r_read_ble64 (buf, esil->anal->big_endian);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttrace = false;\n\t\t\tr_io_read_at (mycore->io, addr, (ut8*)buf, len);\n\t\t\tbreak;\n\t\t}\n\t\t// TODO incorrect\n\t\tbool validRef = false;\n\t\tif (trace && myvalid (mycore->io, refptr)) {\n\t\t\tif (ntarget == UT64_MAX || ntarget == refptr) {\n\t\t\t\tstr[0] = 0;\n\t\t\t\tif (r_io_read_at (mycore->io, refptr, str, sizeof (str)) < 1) {\n\t\t\t\t\t//eprintf (\"Invalid read\\n\");\n\t\t\t\t\tstr[0] = 0;\n\t\t\t\t\tvalidRef = false;\n\t\t\t\t} else {\n\t\t\t\t\tr_anal_xrefs_set (mycore->anal, esil->address, refptr, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\tstr[sizeof (str) - 1] = 0;\n\t\t\t\t\tadd_string_ref (mycore, esil->address, refptr);\n\t\t\t\t\tesilbreak_last_data = UT64_MAX;\n\t\t\t\t\tvalidRef = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/** resolve ptr */\n\t\tif (ntarget == UT64_MAX || ntarget == addr || (ntarget == UT64_MAX && !validRef)) {\n\t\t\tr_anal_xrefs_set (mycore->anal, esil->address, addr, R_ANAL_REF_TYPE_DATA);\n\t\t}\n\t}\n\treturn false; // fallback\n}\n\nstatic bool esilbreak_reg_write(RAnalEsil *esil, const char *name, ut64 *val) {\n\tif (!esil) {\n\t\treturn false;\n\t}\n\tRAnal *anal = esil->anal;\n\tEsilBreakCtx *ctx = esil->user;\n\tRAnalOp *op = ctx->op;\n\tRCore *core = anal->coreb.core;\n\thandle_var_stack_access (esil, *val, R_ANAL_VAR_ACCESS_TYPE_PTR, esil->anal->bits / 8);\n\t//specific case to handle blx/bx cases in arm through emulation\n\t// XXX this thing creates a lot of false positives\n\tut64 at = *val;\n\tif (anal && anal->opt.armthumb) {\n\t\tif (anal->cur && anal->cur->arch && anal->bits < 33 &&\n\t\t\tstrstr (anal->cur->arch, \"arm\") && !strcmp (name, \"pc\") && op) {\n\t\t\tswitch (op->type) {\n\t\t\tcase R_ANAL_OP_TYPE_UCALL: // BLX\n\t\t\tcase R_ANAL_OP_TYPE_UJMP: // BX\n\t\t\t\t// maybe UJMP/UCALL is enough here\n\t\t\t\tif (!(*val & 1)) {\n\t\t\t\t\tr_anal_hint_set_bits (anal, *val, 32);\n\t\t\t\t} else {\n\t\t\t\t\tut64 snv = r_reg_getv (anal->reg, \"pc\");\n\t\t\t\t\tif (snv != UT32_MAX && snv != UT64_MAX) {\n\t\t\t\t\t\tif (r_io_is_valid_offset (anal->iob.io, *val, 1)) {\n\t\t\t\t\t\t\tr_anal_hint_set_bits (anal, *val - 1, 16);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (core->rasm->bits == 32 && strstr (core->rasm->cur->name, \"arm\")) {\n\t\tif ((!(at & 1)) && r_io_is_valid_offset (anal->iob.io, at, 0)) { //  !core->anal->opt.noncode)) {\n\t\t\tadd_string_ref (anal->coreb.core, esil->address, at);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void getpcfromstack(RCore *core, RAnalEsil *esil) {\n\tut64 cur;\n\tut64 addr;\n\tut64 size;\n\tint idx;\n\tRAnalEsil esil_cpy;\n\tRAnalOp op = R_EMPTY;\n\tRAnalFunction *fcn = NULL;\n\tut8 *buf = NULL;\n\tchar *tmp_esil_str = NULL;\n\tint tmp_esil_str_len;\n\tconst char *esilstr;\n\tconst int maxaddrlen = 20;\n\tconst char *spname = NULL;\n\tif (!esil) {\n\t\treturn;\n\t}\n\n\tmemcpy (&esil_cpy, esil, sizeof (esil_cpy));\n\taddr = cur = esil_cpy.cur;\n\tfcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\tif (!fcn) {\n\t\treturn;\n\t}\n\n\tsize = r_anal_function_linear_size (fcn);\n\tif (size <= 0) {\n\t\treturn;\n\t}\n\n\tbuf = malloc (size + 2);\n\tif (!buf) {\n\t\tperror (\"malloc\");\n\t\treturn;\n\t}\n\n\tr_io_read_at (core->io, addr, buf, size + 1);\n\n\t// TODO Hardcoding for 2 instructions (mov e_p,[esp];ret). More work needed\n\tidx = 0;\n\tif (r_anal_op (core->anal, &op, cur, buf + idx, size - idx, R_ANAL_OP_MASK_ESIL) <= 0 ||\n\t\t\top.size <= 0 ||\n\t\t\t(op.type != R_ANAL_OP_TYPE_MOV && op.type != R_ANAL_OP_TYPE_CMOV)) {\n\t\tgoto err_anal_op;\n\t}\n\n\tr_asm_set_pc (core->rasm, cur);\n\tesilstr = R_STRBUF_SAFEGET (&op.esil);\n\tif (!esilstr) {\n\t\tgoto err_anal_op;\n\t}\n\t// Ugly code\n\t// This is a hack, since ESIL doesn't always preserve values pushed on the stack. That probably needs to be rectified\n\tspname = r_reg_get_name (core->anal->reg, R_REG_NAME_SP);\n\tif (!spname || !*spname) {\n\t\tgoto err_anal_op;\n\t}\n\ttmp_esil_str_len = strlen (esilstr) + strlen (spname) + maxaddrlen;\n\ttmp_esil_str = (char*) malloc (tmp_esil_str_len);\n\tif (!tmp_esil_str) {\n\t\tgoto err_anal_op;\n\t}\n\ttmp_esil_str[tmp_esil_str_len - 1] = '\\0';\n\tsnprintf (tmp_esil_str, tmp_esil_str_len - 1, \"%s,[\", spname);\n\tif (!*esilstr || (strncmp ( esilstr, tmp_esil_str, strlen (tmp_esil_str)))) {\n\t\tfree (tmp_esil_str);\n\t\tgoto err_anal_op;\n\t}\n\n\tsnprintf (tmp_esil_str, tmp_esil_str_len - 1, \"%20\" PFMT64u \"%s\", esil_cpy.old, &esilstr[strlen (spname) + 4]);\n\tr_str_trim (tmp_esil_str);\n\tidx += op.size;\n\tr_anal_esil_set_pc (&esil_cpy, cur);\n\tr_anal_esil_parse (&esil_cpy, tmp_esil_str);\n\tr_anal_esil_stack_free (&esil_cpy);\n\tfree (tmp_esil_str);\n\n\tcur = addr + idx;\n\tr_anal_op_fini (&op);\n\tif (r_anal_op (core->anal, &op, cur, buf + idx, size - idx, R_ANAL_OP_MASK_ESIL) <= 0 ||\n\t\t\top.size <= 0 ||\n\t\t\t(op.type != R_ANAL_OP_TYPE_RET && op.type != R_ANAL_OP_TYPE_CRET)) {\n\t\tgoto err_anal_op;\n\t}\n\tr_asm_set_pc (core->rasm, cur);\n\n\tesilstr = R_STRBUF_SAFEGET (&op.esil);\n\tr_anal_esil_set_pc (&esil_cpy, cur);\n\tif (!esilstr || !*esilstr) {\n\t\tgoto err_anal_op;\n\t}\n\tr_anal_esil_parse (&esil_cpy, esilstr);\n\tr_anal_esil_stack_free (&esil_cpy);\n\n\tmemcpy (esil, &esil_cpy, sizeof (esil_cpy));\n\n err_anal_op:\n\tr_anal_op_fini (&op);\n\tfree (buf);\n}\n\ntypedef struct {\n\tut64 start_addr;\n\tut64 end_addr;\n\tRAnalFunction *fcn;\n\tRAnalBlock *cur_bb;\n\tRList *bbl, *path, *switch_path;\n} IterCtx;\n\nstatic int find_bb(ut64 *addr, RAnalBlock *bb) {\n\treturn *addr != bb->addr;\n}\n\nstatic inline bool get_next_i(IterCtx *ctx, size_t *next_i) {\n\t(*next_i)++;\n\tut64 cur_addr = *next_i + ctx->start_addr;\n\tif (ctx->fcn) {\n\t\tif (!ctx->cur_bb) {\n\t\t\tctx->path = r_list_new ();\n\t\t\tctx->switch_path = r_list_new ();\n\t\t\tctx->bbl = r_list_clone (ctx->fcn->bbs);\n\t\t\tctx->cur_bb = r_anal_get_block_at (ctx->fcn->anal, ctx->fcn->addr);\n\t\t\tif (!ctx->cur_bb) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_list_push (ctx->path, ctx->cur_bb);\n\t\t}\n\t\tRAnalBlock *bb = ctx->cur_bb;\n\t\tif (cur_addr >= bb->addr + bb->size) {\n\t\t\tr_reg_arena_push (ctx->fcn->anal->reg);\n\t\t\tRListIter *bbit = NULL;\n\t\t\tif (bb->switch_op) {\n\t\t\t\tRAnalCaseOp *cop = r_list_first (bb->switch_op->cases);\n\t\t\t\tbbit = r_list_find (ctx->bbl, &cop->jump, (RListComparator)find_bb);\n\t\t\t\tif (bbit) {\n\t\t\t\t\tr_list_push (ctx->switch_path, bb->switch_op->cases->head);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbbit = r_list_find (ctx->bbl, &bb->jump, (RListComparator)find_bb);\n\t\t\t\tif (!bbit && bb->fail != UT64_MAX) {\n\t\t\t\t\tbbit = r_list_find (ctx->bbl, &bb->fail, (RListComparator)find_bb);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!bbit) {\n\t\t\t\tRListIter *cop_it = r_list_last (ctx->switch_path);\n\t\t\t\tRAnalBlock *prev_bb = NULL;\n\t\t\t\tdo {\n\t\t\t\t\tr_reg_arena_pop (ctx->fcn->anal->reg);\n\t\t\t\t\tprev_bb = r_list_pop (ctx->path);\n\t\t\t\t\tif (prev_bb->fail != UT64_MAX) {\n\t\t\t\t\t\tbbit = r_list_find (ctx->bbl, &prev_bb->fail, (RListComparator)find_bb);\n\t\t\t\t\t\tif (bbit) {\n\t\t\t\t\t\t\tr_reg_arena_push (ctx->fcn->anal->reg);\n\t\t\t\t\t\t\tr_list_push (ctx->path, prev_bb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!bbit && cop_it) {\n\t\t\t\t\t\tRAnalCaseOp *cop = cop_it->data;\n\t\t\t\t\t\tif (cop->jump == prev_bb->addr && cop_it->n) {\n\t\t\t\t\t\t\tcop = cop_it->n->data;\n\t\t\t\t\t\t\tr_list_pop (ctx->switch_path);\n\t\t\t\t\t\t\tr_list_push (ctx->switch_path, cop_it->n);\n\t\t\t\t\t\t\tcop_it = cop_it->n;\n\t\t\t\t\t\t\tbbit = r_list_find (ctx->bbl, &cop->jump, (RListComparator)find_bb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (cop_it && !cop_it->n) {\n\t\t\t\t\t\tr_list_pop (ctx->switch_path);\n\t\t\t\t\t\tcop_it = r_list_last (ctx->switch_path);\n\t\t\t\t\t}\n\t\t\t\t} while (!bbit && !r_list_empty (ctx->path));\n\t\t\t}\n\t\t\tif (!bbit) {\n\t\t\t\tr_list_free (ctx->path);\n\t\t\t\tr_list_free (ctx->switch_path);\n\t\t\t\tr_list_free (ctx->bbl);\n\t\t\t\tctx->path = NULL;\n\t\t\t\tctx->switch_path = NULL;\n\t\t\t\tctx->bbl = NULL;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!bbit->data) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!bbit->data) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tctx->cur_bb = bbit->data;\n\t\t\tr_list_push (ctx->path, ctx->cur_bb);\n\t\t\tr_list_delete (ctx->bbl, bbit);\n\t\t\t*next_i = ctx->cur_bb->addr - ctx->start_addr;\n\t\t}\n\t} else if (cur_addr >= ctx->end_addr) {\n\t\treturn false;\n\t}\n\tif (*next_i == 0) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nR_API void r_core_anal_esil(RCore *core, const char *str, const char *target) {\n\tbool cfg_anal_strings = r_config_get_i (core->config, \"anal.strings\");\n\tbool emu_lazy = r_config_get_i (core->config, \"emu.lazy\");\n\tbool gp_fixed = r_config_get_i (core->config, \"anal.gpfixed\");\n\tRAnalEsil *ESIL = core->anal->esil;\n\tut64 refptr = 0LL;\n\tconst char *pcname;\n\tRAnalOp op = R_EMPTY;\n\tut8 *buf = NULL;\n\tbool end_address_set = false;\n\tint iend;\n\tint minopsize = 4; // XXX this depends on asm->mininstrsize\n\tbool archIsArm = false;\n\tut64 addr = core->offset;\n\tut64 start = addr;\n\tut64 end = 0LL;\n\tut64 cur;\n\tif (esil_anal_stop || r_cons_is_breaked ()) {\n\t\t// faster ^C\n\t\treturn;\n\t}\n\n\tmycore = core;\n\tif (!strcmp (str, \"?\")) {\n\t\teprintf (\"Usage: aae[f] [len] [addr] - analyze refs in function, section or len bytes with esil\\n\");\n\t\teprintf (\"  aae $SS @ $S             - analyze the whole section\\n\");\n\t\teprintf (\"  aae $SS str.Hello @ $S   - find references for str.Hellow\\n\");\n\t\teprintf (\"  aaef                     - analyze functions discovered with esil\\n\");\n\t\treturn;\n\t}\n#define CHECKREF(x) ((refptr && (x) == refptr) || !refptr)\n\tif (target) {\n\t\tconst char *expr = r_str_trim_head_ro (target);\n\t\tif (*expr) {\n\t\t\trefptr = ntarget = r_num_math (core->num, expr);\n\t\t\tif (!refptr) {\n\t\t\t\tntarget = refptr = addr;\n\t\t\t}\n\t\t} else {\n\t\t\tntarget = UT64_MAX;\n\t\t\trefptr = 0LL;\n\t\t}\n\t} else {\n\t\tntarget = UT64_MAX;\n\t\trefptr = 0LL;\n\t}\n\tRAnalFunction *fcn = NULL;\n\tif (!strcmp (str, \"f\")) {\n\t\tfcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\tif (fcn) {\n\t\t\tstart = r_anal_function_min_addr (fcn);\n\t\t\taddr = fcn->addr;\n\t\t\tend = r_anal_function_max_addr (fcn);\n\t\t\tend_address_set = true;\n\t\t}\n\t}\n\n\tif (!end_address_set) {\n\t\tif (str[0] == ' ') {\n\t\t\tend = addr + r_num_math (core->num, str + 1);\n\t\t} else {\n\t\t\tRIOMap *map = r_io_map_get_at (core->io, addr);\n\t\t\tif (map) {\n\t\t\t\tend = r_io_map_end (map);\n\t\t\t} else {\n\t\t\t\tend = addr + core->blocksize;\n\t\t\t}\n\t\t}\n\t}\n\n\tiend = end - start;\n\tif (iend < 0) {\n\t\treturn;\n\t}\n\tif (iend > MAX_SCAN_SIZE) {\n\t\teprintf (\"Warning: Not going to analyze 0x%08\"PFMT64x\" bytes.\\n\", (ut64)iend);\n\t\treturn;\n\t}\n\tbuf = malloc ((size_t)iend + 2);\n\tif (!buf) {\n\t\tperror (\"malloc\");\n\t\treturn;\n\t}\n\tesilbreak_last_read = UT64_MAX;\n\tr_io_read_at (core->io, start, buf, iend + 1);\n\tif (!ESIL) {\n\t\tr_core_cmd0 (core, \"aei\");\n\t\tESIL = core->anal->esil;\n\t\tif (!ESIL) {\n\t\t\teprintf (\"ESIL not initialized\\n\");\n\t\t\treturn;\n\t\t}\n\t\tr_core_cmd0 (core, \"aeim\");\n\t\tESIL = core->anal->esil;\n\t}\n\tconst char *spname = r_reg_get_name (core->anal->reg, R_REG_NAME_SP);\n\tif (!spname) {\n\t\teprintf (\"Error: No =SP defined in the reg profile.\\n\");\n\t\treturn;\n\t}\n\tEsilBreakCtx ctx = {\n\t\t&op,\n\t\tfcn,\n\t\tspname,\n\t\tr_reg_getv (core->anal->reg, spname)\n\t};\n\tESIL->cb.hook_reg_write = &esilbreak_reg_write;\n\t//this is necessary for the hook to read the id of analop\n\tESIL->user = &ctx;\n\tESIL->cb.hook_mem_read = &esilbreak_mem_read;\n\tESIL->cb.hook_mem_write = &esilbreak_mem_write;\n\n\tif (fcn && fcn->reg_save_area) {\n\t\tr_reg_setv (core->anal->reg, ctx.spname, ctx.initial_sp - fcn->reg_save_area);\n\t}\n\t//eprintf (\"Analyzing ESIL refs from 0x%\"PFMT64x\" - 0x%\"PFMT64x\"\\n\", addr, end);\n\t// TODO: backup/restore register state before/after analysis\n\tpcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tif (!pcname || !*pcname) {\n\t\teprintf (\"Cannot find program counter register in the current profile.\\n\");\n\t\treturn;\n\t}\n\tesil_anal_stop = false;\n\tr_cons_break_push (cccb, core);\n\n\tint arch = -1;\n\tif (!strcmp (core->anal->cur->arch, \"arm\")) {\n\t\tswitch (core->anal->cur->bits) {\n\t\tcase 64: arch = R2_ARCH_ARM64; break;\n\t\tcase 32: arch = R2_ARCH_ARM32; break;\n\t\tcase 16: arch = R2_ARCH_THUMB; break;\n\t\t}\n\t\tarchIsArm = true;\n\t}\n\n\tut64 gp = r_config_get_i (core->config, \"anal.gp\");\n\tconst char *gp_reg = NULL;\n\tif (!strcmp (core->anal->cur->arch, \"mips\")) {\n\t\tgp_reg = \"gp\";\n\t\tarch = R2_ARCH_MIPS;\n\t}\n\n\tconst char *sn = r_reg_get_name (core->anal->reg, R_REG_NAME_SN);\n\tif (!sn) {\n\t\teprintf (\"Warning: No SN reg alias for current architecture.\\n\");\n\t}\n\tr_reg_arena_push (core->anal->reg);\n\n\tIterCtx ictx = { start, end, fcn, NULL };\n\tsize_t i = addr - start;\n\tsize_t i_old = 0;\n\tdo {\n\t\tif (esil_anal_stop || r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tcur = start + i;\n\t\tif (!r_io_is_valid_offset (core->io, cur, 0)) {\n\t\t\tbreak;\n\t\t}\n#if 0\n\t\t// disabled because it causes some tests to fail\n\t\t{\n\t\t\tRPVector *list = r_meta_get_all_in (core->anal, cur, R_META_TYPE_ANY);\n\t\t\tvoid **it;\n\t\t\tr_pvector_foreach (list, it) {\n\t\t\t\tRIntervalNode *node = *it;\n\t\t\t\tRAnalMetaItem *meta = node->data;\n\t\t\t\tswitch (meta->type) {\n\t\t\t\tcase R_META_TYPE_DATA:\n\t\t\t\tcase R_META_TYPE_STRING:\n\t\t\t\tcase R_META_TYPE_FORMAT:\n#if 0\n\t\t\t\t\t{\n\t\t\t\t\t\tint msz = r_meta_get_size (core->anal, meta->type);\n\t\t\t\t\t\ti += (msz > 0)? msz: minopsize;\n\t\t\t\t\t}\n\t\t\t\t\tr_pvector_free (list);\n\t\t\t\t\tgoto loopback;\n#elif 0\n\t\t\t\t\t{\n\t\t\t\t\t\tint msz = r_meta_get_size (core->anal, meta->type);\n\t\t\t\t\t\ti += (msz > 0)? msz: minopsize;\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n#else\n\t\t\t\t\ti += 4;\n\t\t\t\t\tgoto repeat;\n#endif\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_pvector_free (list);\n\t\t}\n#endif\n\n\t\t/* realign address if needed */\n\t\tr_core_seek_arch_bits (core, cur);\n\t\tint opalign = core->anal->pcalign;\n\t\tif (opalign > 0) {\n\t\t\tcur -= (cur % opalign);\n\t\t}\n\n\t\tr_anal_op_fini (&op);\n\t\tr_asm_set_pc (core->rasm, cur);\n\t\ti_old = i;\n#if 1\n\t\tif (i > iend) {\n\t\t\tgoto repeat;\n\t\t}\n#endif\n\t\tif (!r_anal_op (core->anal, &op, cur, buf + i, iend - i, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_HINT)) {\n\t\t\ti += minopsize - 1; //   XXX dupe in op.size below\n\t\t}\n\t\tif (op.type == R_ANAL_OP_TYPE_ILL || op.type == R_ANAL_OP_TYPE_UNK) {\n\t\t\t// i += 2\n\t\t\tr_anal_op_fini (&op);\n\t\t\tgoto repeat;\n\t\t}\n\t\t//we need to check again i because buf+i may goes beyond its boundaries\n\t\t//because of i+= minopsize - 1\n\t\tif (op.size < 1) {\n\t\t\ti += minopsize - 1;\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (emu_lazy) {\n\t\t\tif (op.type & R_ANAL_OP_TYPE_REP) {\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tswitch (op.type & R_ANAL_OP_TYPE_MASK) {\n\t\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\t\tcase R_ANAL_OP_TYPE_NOP:\n\t\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\t\tcase R_ANAL_OP_TYPE_IO:\n\t\t\tcase R_ANAL_OP_TYPE_LEAVE:\n\t\t\tcase R_ANAL_OP_TYPE_CRYPTO:\n\t\t\tcase R_ANAL_OP_TYPE_CPL:\n\t\t\tcase R_ANAL_OP_TYPE_SYNC:\n\t\t\tcase R_ANAL_OP_TYPE_SWI:\n\t\t\tcase R_ANAL_OP_TYPE_CMP:\n\t\t\tcase R_ANAL_OP_TYPE_ACMP:\n\t\t\tcase R_ANAL_OP_TYPE_NULL:\n\t\t\tcase R_ANAL_OP_TYPE_CSWI:\n\t\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t//  those require write support\n\t\t\tcase R_ANAL_OP_TYPE_PUSH:\n\t\t\tcase R_ANAL_OP_TYPE_POP:\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t}\n\t\tif (sn && op.type == R_ANAL_OP_TYPE_SWI) {\n\t\t\tr_strf_buffer (64);\n\t\t\tr_flag_space_set (core->flags, R_FLAGS_FS_SYSCALLS);\n\t\t\tint snv = (arch == R2_ARCH_THUMB)? op.val: (int)r_reg_getv (core->anal->reg, sn);\n\t\t\tRSyscallItem *si = r_syscall_get (core->anal->syscall, snv, -1);\n\t\t\tif (si) {\n\t\t\t//\teprintf (\"0x%08\"PFMT64x\" SYSCALL %-4d %s\\n\", cur, snv, si->name);\n\t\t\t\tr_flag_set_next (core->flags, r_strf (\"syscall.%s\", si->name), cur, 1);\n\t\t\t} else {\n\t\t\t\t//todo were doing less filtering up top because we can't match against 80 on all platforms\n\t\t\t\t// might get too many of this path now..\n\t\t\t//\teprintf (\"0x%08\"PFMT64x\" SYSCALL %d\\n\", cur, snv);\n\t\t\t\tr_flag_set_next (core->flags, r_strf (\"syscall.%d\", snv), cur, 1);\n\t\t\t}\n\t\t\tr_flag_space_set (core->flags, NULL);\n\t\t\tr_syscall_item_free (si);\n\t\t}\n\t\tconst char *esilstr = R_STRBUF_SAFEGET (&op.esil);\n\t\ti += op.size - 1;\n\t\tif (R_STR_ISEMPTY (esilstr)) {\n\t\t\tgoto repeat;\n\t\t}\n\t\tr_anal_esil_set_pc (ESIL, cur);\n\t\tr_reg_setv (core->anal->reg, pcname, cur + op.size);\n\t\tif (gp_fixed && gp_reg) {\n\t\t\tr_reg_setv (core->anal->reg, gp_reg, gp);\n\t\t}\n\t\t(void)r_anal_esil_parse (ESIL, esilstr);\n\t\t// looks like ^C is handled by esil_parse !!!!\n\t\t//r_anal_esil_dumpstack (ESIL);\n\t\t//r_anal_esil_stack_free (ESIL);\n\t\tswitch (op.type) {\n\t\tcase R_ANAL_OP_TYPE_LEA:\n\t\t\t// arm64\n\t\t\tif (core->anal->cur && arch == R2_ARCH_ARM64) {\n\t\t\t\tif (CHECKREF (ESIL->cur)) {\n\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t}\n\t\t\t} else if ((target && op.ptr == ntarget) || !target) {\n\t\t\t\tif (CHECKREF (ESIL->cur)) {\n\t\t\t\t\tif (op.ptr && r_io_is_valid_offset (core->io, op.ptr, !core->anal->opt.noncode)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, op.ptr, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cfg_anal_strings) {\n\t\t\t\tadd_string_ref (core, op.addr, op.ptr);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_ADD:\n\t\t\t/* TODO: test if this is valid for other archs too */\n\t\t\tif (core->anal->cur && archIsArm) {\n\t\t\t\t/* This code is known to work on Thumb, ARM and ARM64 */\n\t\t\t\tut64 dst = ESIL->cur;\n\t\t\t\tif ((target && dst == ntarget) || !target) {\n\t\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\t\tint type = core_type_by_addr (core, dst); // R_ANAL_REF_TYPE_DATA;\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t}\n\t\t\t} else if ((core->anal->bits == 32 && core->anal->cur && arch == R2_ARCH_MIPS)) {\n\t\t\t\tut64 dst = ESIL->cur;\n\t\t\t\tif (!op.src[0] || !op.src[0]->reg || !op.src[0]->reg->name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp (op.src[0]->reg->name, \"sp\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp (op.src[0]->reg->name, \"zero\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((target && dst == ntarget) || !target) {\n\t\t\t\t\tif (dst > 0xffff && op.src[1] && (dst & 0xffff) == (op.src[1]->imm & 0xffff) && myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tRFlagItem *f;\n\t\t\t\t\t\tchar *str;\n\t\t\t\t\t\tif (CHECKREF (dst) || CHECKREF (cur)) {\n\t\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((f = r_core_flag_get_by_spaces (core->flags, dst))) {\n\t\t\t\t\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, f->name);\n\t\t\t\t\t\t\t} else if ((str = is_string_at (mycore, dst, NULL))) {\n\t\t\t\t\t\t\t\tchar *str2 = r_str_newf (\"esilref: '%s'\", str);\n\t\t\t\t\t\t\t\t// HACK avoid format string inside string used later as format\n\t\t\t\t\t\t\t\t// string crashes disasm inside agf under some conditions.\n\t\t\t\t\t\t\t\t// https://github.com/radareorg/radare2/issues/6937\n\t\t\t\t\t\t\t\tr_str_replace_char (str2, '%', '&');\n\t\t\t\t\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, str2);\n\t\t\t\t\t\t\t\tfree (str2);\n\t\t\t\t\t\t\t\tfree (str);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_LOAD:\n\t\t\t{\n\t\t\t\tut64 dst = esilbreak_last_read;\n\t\t\t\tif (dst != UT64_MAX && CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = esilbreak_last_data;\n\t\t\t\tif (dst != UT64_MAX && CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\t{\n\t\t\t\tut64 dst = op.jump;\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CODE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\t{\n\t\t\t\tut64 dst = op.jump;\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CALL);\n\t\t\t\t\t}\n\t\t\t\t\tESIL->old = cur + op.size;\n\t\t\t\t\tgetpcfromstack (core, ESIL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\tcase R_ANAL_OP_TYPE_ICALL:\n\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\tcase R_ANAL_OP_TYPE_IRCALL:\n\t\tcase R_ANAL_OP_TYPE_MJMP:\n\t\t\t{\n\t\t\t\tut64 dst = core->anal->esil->jump_target;\n\t\t\t\tif (dst == 0 || dst == UT64_MAX) {\n\t\t\t\t\tdst = r_reg_getv (core->anal->reg, pcname);\n\t\t\t\t}\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tRAnalRefType ref =\n\t\t\t\t\t\t\t(op.type & R_ANAL_OP_TYPE_MASK) == R_ANAL_OP_TYPE_UCALL\n\t\t\t\t\t\t\t? R_ANAL_REF_TYPE_CALL\n\t\t\t\t\t\t\t: R_ANAL_REF_TYPE_CODE;\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, ref);\n\t\t\t\t\t\tr_core_anal_fcn (core, dst, UT64_MAX, R_ANAL_REF_TYPE_NULL, 1);\n// analyze function here\n#if 0\n\t\t\t\t\t\tif (op.type == R_ANAL_OP_TYPE_UCALL || op.type == R_ANAL_OP_TYPE_RCALL) {\n\t\t\t\t\t\t\teprintf (\"0x%08\"PFMT64x\"  RCALL TO %llx\\n\", cur, dst);\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tr_anal_esil_stack_free (ESIL);\nrepeat:\n\t\tif (!r_anal_get_block_at (core->anal, cur)) {\n\t\t\tsize_t fcn_i;\n\t\t\tfor (fcn_i = i_old + 1; fcn_i <= i; fcn_i++) {\n\t\t\t\tif (r_anal_get_function_at (core->anal, start + fcn_i)) {\n\t\t\t\t\ti = fcn_i - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (i >= iend) {\n\t\t\tbreak;\n\t\t}\n\t} while (get_next_i (&ictx, &i));\n\tr_list_free (ictx.bbl);\n\tr_list_free (ictx.path);\n\tr_list_free (ictx.switch_path);\n\tfree (buf);\n\tESIL->cb.hook_mem_read = NULL;\n\tESIL->cb.hook_mem_write = NULL;\n\tESIL->cb.hook_reg_write = NULL;\n\tESIL->user = NULL;\n\tr_anal_op_fini (&op);\n\tr_cons_break_pop ();\n\t// restore register\n\tr_reg_arena_pop (core->anal->reg);\n}\n\nstatic bool isValidAddress(RCore *core, ut64 addr) {\n\t// check if address is mapped\n\tRIOMap* map = r_io_map_get_at (core->io, addr);\n\tif (!map) {\n\t\treturn false;\n\t}\n\tst64 fdsz = (st64)r_io_fd_size (core->io, map->fd);\n\tif (fdsz > 0 && map->delta > fdsz) {\n\t\treturn false;\n\t}\n\t// check if associated file is opened\n\tRIODesc *desc = r_io_desc_get (core->io, map->fd);\n\tif (!desc) {\n\t\treturn false;\n\t}\n\t// check if current map->fd is null://\n\tif (!strncmp (desc->name, \"null://\", 7)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool stringAt(RCore *core, ut64 addr) {\n\tut8 buf[32];\n\tr_io_read_at (core->io, addr - 1, buf, sizeof (buf));\n\t// check if previous byte is a null byte, all strings, except pascal ones should be like this\n\tif (buf[0] != 0) {\n\t\treturn false;\n\t}\n\treturn is_string (buf + 1, 31, NULL);\n}\n\nR_API int r_core_search_value_in_range(RCore *core, RInterval search_itv, ut64 vmin,\n\t\t\t\t\t ut64 vmax, int vsize, inRangeCb cb, void *cb_user) {\n\tint i, align = core->search->align, hitctr = 0;\n\tbool vinfun = r_config_get_i (core->config, \"anal.vinfun\");\n\tbool vinfunr = r_config_get_i (core->config, \"anal.vinfunrange\");\n\tbool analStrings = r_config_get_i (core->config, \"anal.strings\");\n\tmycore = core;\n\tut8 buf[4096];\n\tut64 v64, value = 0, size;\n\tut64 from = search_itv.addr, to = r_itv_end (search_itv);\n\tut32 v32;\n\tut16 v16;\n\tif (from >= to) {\n\t\teprintf (\"Error: from must be lower than to\\n\");\n\t\treturn -1;\n\t}\n\tbool maybeThumb = false;\n\tif (align && core->anal->cur && core->anal->cur->arch) {\n\t\tif (!strcmp (core->anal->cur->arch, \"arm\") && core->anal->bits != 64) {\n\t\t\tmaybeThumb = true;\n\t\t}\n\t}\n\n\tif (vmin >= vmax) {\n\t\teprintf (\"Error: vmin must be lower than vmax\\n\");\n\t\treturn -1;\n\t}\n\tif (to == UT64_MAX) {\n\t\teprintf (\"Error: Invalid destination boundary\\n\");\n\t\treturn -1;\n\t}\n\tr_cons_break_push (NULL, NULL);\n\n\tif (!r_io_is_valid_offset (core->io, from, 0)) {\n\t\treturn -1;\n\t}\n\twhile (from < to) {\n\t\tsize = R_MIN (to - from, sizeof (buf));\n\t\tmemset (buf, 0xff, sizeof (buf)); // probably unnecessary\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tgoto beach;\n\t\t}\n\t\tbool res = r_io_read_at_mapped (core->io, from, buf, size);\n\t\tif (!res || !memcmp (buf, \"\\xff\\xff\\xff\\xff\", 4) || !memcmp (buf, \"\\x00\\x00\\x00\\x00\", 4)) {\n\t\t\tif (!isValidAddress (core, from)) {\n\t\t\t\tut64 next = from;\n\t\t\t\tif (!r_io_map_locate (core->io, &next, 1, 0)) {\n\t\t\t\t\tfrom += sizeof (buf);\n\t\t\t\t} else {\n\t\t\t\t\tfrom += (next - from);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i <= (size - vsize); i++) {\n\t\t\tvoid *v = (buf + i);\n\t\t\tut64 addr = from + i;\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (align && (addr) % align) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint match = false;\n\t\t\tint left = size - i;\n\t\t\tif (vsize > left) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch (vsize) {\n\t\t\tcase 1: value = *(ut8 *)v; match = (buf[i] >= vmin && buf[i] <= vmax); break;\n\t\t\tcase 2: v16 = *(uut16 *)v; match = (v16 >= vmin && v16 <= vmax); value = v16; break;\n\t\t\tcase 4: v32 = *(uut32 *)v; match = (v32 >= vmin && v32 <= vmax); value = v32; break;\n\t\t\tcase 8: v64 = *(uut64 *)v; match = (v64 >= vmin && v64 <= vmax); value = v64; break;\n\t\t\tdefault: eprintf (\"Unknown vsize %d\\n\", vsize); return -1;\n\t\t\t}\n\t\t\tif (match && !vinfun) {\n\t\t\t\tif (vinfunr) {\n\t\t\t\t\tif (r_anal_get_fcn_in_bounds (core->anal, addr, R_ANAL_FCN_TYPE_NULL)) {\n\t\t\t\t\t\tmatch = false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL)) {\n\t\t\t\t\t\tmatch = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (match && value) {\n\t\t\t\tbool isValidMatch = true;\n\t\t\t\tif (align && (value % align)) {\n\t\t\t\t\t// ignored .. unless we are analyzing arm/thumb and lower bit is 1\n\t\t\t\t\tisValidMatch = false;\n\t\t\t\t\tif (maybeThumb && (value & 1)) {\n\t\t\t\t\t\tisValidMatch = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isValidMatch) {\n\t\t\t\t\tcb (core, addr, value, vsize, cb_user);\n\t\t\t\t\tif (analStrings && stringAt (core, addr)) {\n\t\t\t\t\t\tadd_string_ref (mycore, addr, value);\n\t\t\t\t\t}\n\t\t\t\t\thitctr++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (size == to-from) {\n\t\t\tbreak;\n\t\t}\n\t\tfrom += size-vsize+1;\n\t}\nbeach:\n\tr_cons_break_pop ();\n\treturn hitctr;\n}\n\n\ntypedef struct {\n\tdict visited;\n\tRList *path;\n\tRCore *core;\n\tut64 from;\n\tRAnalBlock *fromBB;\n\tut64 to;\n\tRAnalBlock *toBB;\n\tRAnalBlock *cur;\n\tbool followCalls;\n\tint followDepth;\n\tint count; // max number of results\n} RCoreAnalPaths;\n\nstatic bool printAnalPaths(RCoreAnalPaths *p, PJ *pj) {\n\tRListIter *iter;\n\tRAnalBlock *path;\n\tif (pj) {\n\t\tpj_a (pj);\n\t} else {\n\t\tr_cons_printf (\"pdb @@= \");\n\t}\n\n\tr_list_foreach (p->path, iter, path) {\n\t\tif (pj) {\n\t\t\tpj_n (pj, path->addr);\n\t\t} else {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" \", path->addr);\n\t\t}\n\t}\n\n\tif(pj) {\n\t\tpj_end (pj);\n\t} else {\n\t\tr_cons_printf (\"\\n\");\n\t}\n\treturn (p->count < 1 || --p->count > 0);\n}\nstatic void analPaths(RCoreAnalPaths *p, PJ *pj);\n\nstatic void analPathFollow(RCoreAnalPaths *p, ut64 addr, PJ *pj) {\n\tif (addr == UT64_MAX) {\n\t\treturn;\n\t}\n\tif (!dict_get (&p->visited, addr)) {\n\t\tp->cur = r_anal_bb_from_offset (p->core->anal, addr);\n\t\tanalPaths (p, pj);\n\t}\n}\n\nstatic void analPaths(RCoreAnalPaths *p, PJ *pj) {\n\tRAnalBlock *cur = p->cur;\n\tif (!cur) {\n\t\t// eprintf (\"eof\\n\");\n\t\treturn;\n\t}\n\t/* handle ^C */\n\tif (r_cons_is_breaked ()) {\n\t\treturn;\n\t}\n\tdict_set (&p->visited, cur->addr, 1, NULL);\n\tr_list_append (p->path, cur);\n\tif (p->followDepth && --p->followDepth == 0) {\n\t\treturn;\n\t}\n\tif (p->toBB && cur->addr == p->toBB->addr) {\n\t\tif (!printAnalPaths (p, pj)) {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tRAnalBlock *c = cur;\n\t\tut64 j = cur->jump;\n\t\tut64 f = cur->fail;\n\t\tanalPathFollow (p, j, pj);\n\t\tcur = c;\n\t\tanalPathFollow (p, f, pj);\n\t\tif (p->followCalls) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < cur->op_pos_size; i++) {\n\t\t\t\tut64 addr = cur->addr + cur->op_pos[i];\n\t\t\t\tRAnalOp *op = r_core_anal_op (p->core, addr, R_ANAL_OP_MASK_BASIC);\n\t\t\t\tif (op && op->type == R_ANAL_OP_TYPE_CALL) {\n\t\t\t\t\tanalPathFollow (p, op->jump, pj);\n\t\t\t\t}\n\t\t\t\tcur = c;\n\t\t\t\tr_anal_op_free (op);\n\t\t\t}\n\t\t}\n\t}\n\tp->cur = r_list_pop (p->path);\n\tdict_del (&p->visited, cur->addr);\n\tif (p->followDepth) {\n\t\tp->followDepth++;\n\t}\n}\n\nR_API void r_core_anal_paths(RCore *core, ut64 from, ut64 to, bool followCalls, int followDepth, bool is_json) {\n\tRAnalBlock *b0 = r_anal_bb_from_offset (core->anal, from);\n\tRAnalBlock *b1 = r_anal_bb_from_offset (core->anal, to);\n\tPJ *pj = NULL;\n\tif (!b0) {\n\t\teprintf (\"Cannot find basic block for 0x%08\"PFMT64x\"\\n\", from);\n\t\treturn;\n\t}\n\tif (!b1) {\n\t\teprintf (\"Cannot find basic block for 0x%08\"PFMT64x\"\\n\", to);\n\t\treturn;\n\t}\n\tRCoreAnalPaths rcap = {{0}};\n\tdict_init (&rcap.visited, 32, free);\n\trcap.path = r_list_new ();\n\trcap.core = core;\n\trcap.from = from;\n\trcap.fromBB = b0;\n\trcap.to = to;\n\trcap.toBB = b1;\n\trcap.cur = b0;\n\trcap.count = r_config_get_i (core->config, \"search.maxhits\");;\n\trcap.followCalls = followCalls;\n\trcap.followDepth = followDepth;\n\n\t// Initialize a PJ object for json mode\n\tif (is_json) {\n\t\tpj = r_core_pj_new (core);\n\t\tpj_a (pj);\n\t}\n\n\tanalPaths (&rcap, pj);\n\n\tif (is_json) {\n\t\tpj_end (pj);\n\t\tr_cons_printf (\"%s\", pj_string (pj));\n\t}\n\n\tif (pj) {\n\t\tpj_free (pj);\n\t}\n\n\tdict_fini (&rcap.visited);\n\tr_list_free (rcap.path);\n}\n\nstatic bool __cb(RFlagItem *fi, void *user) {\n\tr_list_append (user, r_str_newf (\"0x%08\"PFMT64x, fi->offset));\n\treturn true;\n}\n\nstatic int __addrs_cmp(void *_a, void *_b) {\n\tut64 a = r_num_get (NULL, _a);\n\tut64 b = r_num_get (NULL, _b);\n\tif (a > b) {\n\t\treturn 1;\n\t}\n\tif (a < b) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nR_API void r_core_anal_inflags(RCore *core, const char *glob) {\n\tRList *addrs = r_list_newf (free);\n\tRListIter *iter;\n\tbool a2f = r_config_get_i (core->config, \"anal.a2f\");\n\tchar *anal_in = strdup (r_config_get (core->config, \"anal.in\"));\n\tr_config_set (core->config, \"anal.in\", \"block\");\n\t// aaFa = use a2f instead of af+\n\tbool simple = (!glob || *glob != 'a');\n\tglob = r_str_trim_head_ro (glob);\n\tchar *addr;\n\tr_flag_foreach_glob (core->flags, glob, __cb, addrs);\n\t// should be sorted already\n\tr_list_sort (addrs, (RListComparator)__addrs_cmp);\n\tr_list_foreach (addrs, iter, addr) {\n\t\tif (!iter->n || r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tchar *addr2 = iter->n->data;\n\t\tif (!addr || !addr2) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 a0 = r_num_get (NULL, addr);\n\t\tut64 a1 = r_num_get (NULL, addr2);\n\t\tif (a0 == a1) {\n\t\t\t// ignore\n\t\t\tcontinue;\n\t\t}\n\t\tif (a0 > a1) {\n\t\t\teprintf (\"Warning: unsorted flag list 0x%\"PFMT64x\" 0x%\"PFMT64x\"\\n\", a0, a1);\n\t\t\tcontinue;\n\t\t}\n\t\tst64 sz = a1 - a0;\n\t\tif (sz < 1 || sz > core->anal->opt.bb_max_size) {\n\t\t\teprintf (\"Warning: invalid flag range from 0x%08\"PFMT64x\" to 0x%08\"PFMT64x\"\\n\", a0, a1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (simple) {\n\t\t\tRFlagItem *fi = r_flag_get_at (core->flags, a0, 0);\n\t\t\tr_core_cmdf (core, \"af+ %s fcn.%s\", addr, fi? fi->name: addr);\n\t\t\tr_core_cmdf (core, \"afb+ %s %s %d\", addr, addr, (int)sz);\n\t\t} else {\n\t\t\tr_core_cmdf (core, \"aab@%s!%s-%s\\n\", addr, addr2, addr);\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, r_num_math (core->num, addr), 0);\n\t\t\tif (fcn) {\n\t\t\t\teprintf (\"%s  %s %\"PFMT64d\"    # %s\\n\", addr, \"af\", sz, fcn->name);\n\t\t\t} else {\n\t\t\t\tif (a2f) {\n\t\t\t\t\tr_core_cmdf (core, \"a2f@%s!%s-%s\\n\", addr, addr2, addr);\n\t\t\t\t} else {\n\t\t\t\t\tr_core_cmdf (core, \"af@%s!%s-%s\\n\", addr, addr2, addr);\n\t\t\t\t}\n\t\t\t\tfcn = r_anal_get_fcn_in (core->anal, r_num_math (core->num, addr), 0);\n\t\t\t\teprintf (\"%s  %s %.4\"PFMT64d\"   # %s\\n\", addr, \"aab\", sz, fcn?fcn->name: \"\");\n\t\t\t}\n\t\t}\n\t}\n\tr_list_free (addrs);\n\tr_config_set (core->config, \"anal.in\", anal_in);\n\tfree (anal_in);\n}\n\nstatic bool analyze_noreturn_function(RCore *core, RAnalFunction *f) {\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\tr_list_foreach (f->bbs, iter, bb) {\n\t\tut64 opaddr = r_anal_bb_opaddr_i (bb, bb->ninstr - 1);\n\t\tif (opaddr == UT64_MAX) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// get last opcode\n\t\tRAnalOp *op = r_core_op_anal (core, opaddr, R_ANAL_OP_MASK_HINT);\n\t\tif (!op) {\n\t\t\teprintf (\"Cannot analyze opcode at 0x%08\" PFMT64x \"\\n\", opaddr);\n\t\t\treturn false;\n\t\t}\n\n\t\tswitch (op->type & R_ANAL_OP_TYPE_MASK) {\n\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\tr_anal_op_free (op);\n\t\t\treturn false;\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\tif (!r_anal_function_contains (f, op->jump)) {\n\t\t\t\tr_anal_op_free (op);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tr_anal_op_free (op);\n\t}\n\treturn true;\n}\n\nR_API void r_core_anal_propagate_noreturn(RCore *core, ut64 addr) {\n\tRList *todo = r_list_newf (free);\n\tif (!todo) {\n\t\treturn;\n\t}\n\n\tHtUU *done = ht_uu_new0 ();\n\tif (!done) {\n\t\tr_list_free (todo);\n\t\treturn;\n\t}\n\n\tRAnalFunction *request_fcn = NULL;\n\tif (addr != UT64_MAX) {\n\t\trequest_fcn = r_anal_get_function_at (core->anal, addr);\n\t\tif (!request_fcn) {\n\t\t\tr_list_free (todo);\n\t\t\tht_uu_free (done);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// find known noreturn functions to propagate\n\tRListIter *iter;\n\tRAnalFunction *f;\n\tr_list_foreach (core->anal->fcns, iter, f) {\n\t\tif (f->is_noreturn) {\n\t\t\tut64 *n = ut64_new (f->addr);\n\t\t\tr_list_append (todo, n);\n\t\t}\n\t}\n\n\twhile (!r_list_empty (todo)) {\n\t\tut64 *paddr = (ut64*)r_list_pop (todo);\n\t\tut64 noret_addr = *paddr;\n\t\tfree (paddr);\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tRList *xrefs = r_anal_xrefs_get (core->anal, noret_addr);\n\t\tRAnalRef *xref;\n\t\tr_list_foreach (xrefs, iter, xref) {\n\t\t\tRAnalOp *xrefop = r_core_op_anal (core, xref->addr, R_ANAL_OP_MASK_ALL);\n\t\t\tif (!xrefop) {\n\t\t\t\teprintf (\"Cannot analyze opcode at 0x%08\" PFMT64x \"\\n\", xref->addr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut64 call_addr = xref->addr;\n\t\t\tut64 chop_addr = call_addr + xrefop->size;\n\t\t\tr_anal_op_free (xrefop);\n\t\t\tif (xref->type != R_ANAL_REF_TYPE_CALL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Find the block that has an instruction at exactly the xref addr\n\t\t\tRList *blocks = r_anal_get_blocks_in (core->anal, call_addr);\n\t\t\tif (!blocks) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRAnalBlock *block = NULL;\n\t\t\tRListIter *bit;\n\t\t\tRAnalBlock *block_cur;\n\t\t\tr_list_foreach (blocks, bit, block_cur) {\n\t\t\t\tif (r_anal_block_op_starts_at (block_cur, call_addr)) {\n\t\t\t\t\tblock = block_cur;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (block) {\n\t\t\t\tr_anal_block_ref (block);\n\t\t\t}\n\t\t\tr_list_free (blocks);\n\t\t\tif (!block) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tRList *block_fcns = r_list_clone (block->fcns);\n\t\t\tif (request_fcn) {\n\t\t\t\t// specific function requested, check if it contains the bb\n\t\t\t\tif (!r_list_contains (block->fcns, request_fcn)) {\n\t\t\t\t\tgoto kontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// r_anal_block_chop_noreturn() might free the block!\n\t\t\t\tblock = r_anal_block_chop_noreturn (block, chop_addr);\n\t\t\t}\n\n\t\t\tRListIter *fit;\n\t\t\tr_list_foreach (block_fcns, fit, f) {\n\t\t\t\tbool found = ht_uu_find (done, f->addr, NULL) != 0;\n\t\t\t\tif (f->addr && !found && analyze_noreturn_function (core, f)) {\n\t\t\t\t\tf->is_noreturn = true;\n\t\t\t\t\tr_anal_noreturn_add (core->anal, NULL, f->addr);\n\t\t\t\t\tut64 *n = malloc (sizeof (ut64));\n\t\t\t\t\t*n = f->addr;\n\t\t\t\t\tr_list_append (todo, n);\n\t\t\t\t\tht_uu_insert (done, *n, 1);\n\t\t\t\t}\n\t\t\t}\nkontinue:\n\t\t\tif (block) {\n\t\t\t\tr_anal_block_unref (block);\n\t\t\t}\n\t\t\tr_list_free (block_fcns);\n\t\t}\n\t\tr_list_free (xrefs);\n\t}\n\tr_list_free (todo);\n\tht_uu_free (done);\n}\n"], "fixing_code": ["/* radare - LGPL - Copyright 2022 - jmaselbas */\n\n#include \"kvx.h\"\n#include \"kvx-reg.h\"\n#include <stdio.h>\n#include <string.h>\n#include <r_anal.h>\n\nconst opc_t kv3_opc[] = {\n#include \"kv3.opc\"\n};\n#define KV3_OPC_COUNT R_ARRAY_SIZE(kv3_opc)\n\nint kvx_instr_print(insn_t *insn, ut64 offset, char *buf, size_t len) {\n\tconst char *fmt = insn->opc->format;\n\toperand_t opr;\n\tint i = 0;\n\tint n, w;\n\n\t/* print mnemonic */\n\tw = snprintf (buf, len, \"%s%s\", insn->opc->mnemonic, fmt[0] != '\\0' ? \" \" : \"\");\n\tn = R_MIN (w, len);\n\n\t/* append operands */\n\twhile (n < (len - 1) && *fmt != '\\0') {\n\t\tif (fmt[0] == '%' && fmt[1] == 's') {\n\t\t\t/* decode each operand in order */\n\t\t\tif (i < R_ARRAY_SIZE (insn->opc->decode) && insn->opc->decode[i]) {\n\t\t\t\tinsn->opc->decode[i] (&opr, insn->value);\n\t\t\t\tif (opr.type == KVX_OPER_TYPE_IMM)\n\t\t\t\t\tw = snprintf (buf + n, len - n, \"0x%\" PFMT64x, (ut64)opr.imm);\n\t\t\t\telse if (opr.type == KVX_OPER_TYPE_OFF)\n\t\t\t\t\tw = snprintf (buf + n, len - n, \"0x%\" PFMT64x, (ut64)opr.imm + offset);\n\t\t\t\telse if (opr.type == KVX_OPER_TYPE_REG)\n\t\t\t\t\tw = snprintf (buf + n, len - n, \"%s\", opr.reg);\n\t\t\t\telse\n\t\t\t\t\tw = 0;\n\t\t\t\tn += R_MIN (w, len - n);\n\n\t\t\t\ti++;\n\t\t\t\t/* advance after the format '%s' */\n\t\t\t\tfmt += 2;\n\t\t\t}\n\t\t} else {\n\t\t\t/* simple copy */\n\t\t\tbuf[n] = fmt[0];\n\t\t\tfmt++;\n\t\t\tn++;\n\t\t}\n\t}\n\tif (!insn->rem) {\n\t\tw = snprintf (buf + n, len - n, \" ;;\");\n\t\tn += R_MIN (w, len - n);\n\t}\n\tbuf[n] = 0;\n\n\treturn n;\n}\n\nut64 kvx_instr_jump(insn_t *insn, ut64 offset) {\n\toperand_t opr;\n\tint i;\n\n\tfor (i = 0; i < 4 && insn->opc->decode[i]; i++) {\n\t\tinsn->opc->decode[i] (&opr, insn->value);\n\t\tif (opr.type == KVX_OPER_TYPE_OFF) {\n\t\t\treturn opr.imm + offset;\n\t\t}\n\t}\n\treturn offset;\n}\n\nstatic const int immx_to_bundle_issue[] = {\n\t[IMMX_ISSUE_ALU0] = BUNDLE_ISSUE_ALU0,\n\t[IMMX_ISSUE_ALU1] = BUNDLE_ISSUE_ALU1,\n\t[IMMX_ISSUE_MAU] = BUNDLE_ISSUE_MAU,\n\t[IMMX_ISSUE_LSU] = BUNDLE_ISSUE_LSU,\n};\n\nstatic inline int kvx_steering(ut32 x) {\n\treturn (((x) & 0x60000000) >> 29);\n}\n\nstatic inline int kvx_extension(ut32 x) {\n\treturn (((x) & 0x18000000) >> 27);\n}\n\nstatic inline int kvx_has_parallel_bit(ut32 x) {\n\treturn (((x) & 0x80000000) == 0x80000000);\n}\n\nstatic inline int kvx_is_tca_opcode(ut32 x) {\n\tunsigned major = ((x)>>24) & 0x1F;\n\treturn (major > 1) && (major < 8);\n}\n\n#if UNUSED0\nstatic inline int kvx_is_nop_opcode(ut32 x) {\n\treturn ((x)<<1) == 0xFFFFFFFE;\n}\n#endif\n\nstatic inline int kvx_opc_match(const opc_t *opc, insn_t *insn) {\n\tint i;\n\n\tif (opc->len != insn->len)\n\t\treturn 0;\n\n\tfor (i = 0; i < insn->len; i++) {\n\t\tif ((insn->value[i] & opc->mask[i]) != opc->value[i])\n\t\t\treturn 0;\n\t}\n\n\treturn 1;\n}\n\nstatic int disassemble_bundle(bundle_t *bundle, const ut32 *words, int count) {\n\tbool used[KVX_MAX_BUNDLE_ISSUE] = {0};\n\tinsn_t *insn;\n\tut32 word;\n\tint issue, immx, extension;\n\tint bcu = 0;\n\tint i;\n\n\tfor (i = 0; i < count; i++) {\n\t\textension = 0;\n\t\tword = words[i];\n\t\tswitch (kvx_steering (word)) {\n\t\tcase STEERING_BCU:\n\t\t\tif (i == 0 && !kvx_is_tca_opcode (word)) {\n\t\t\t\tbcu = 1;\n\t\t\t\tissue = BUNDLE_ISSUE_BCU;\n\t\t\t} else if ((i == 0 && kvx_is_tca_opcode (word))\n\t\t\t\t|| (i == 1 && bcu && kvx_is_tca_opcode (word))) {\n\t\t\t\tissue = BUNDLE_ISSUE_TCA;\n\t\t\t} else {\n\t\t\t\timmx = kvx_extension (word);\n\t\t\t\tissue = immx_to_bundle_issue[immx];\n\t\t\t\textension = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase STEERING_ALU:\n\t\t\tif (!used[BUNDLE_ISSUE_ALU0]) {\n\t\t\t\tissue = BUNDLE_ISSUE_ALU0;\n\t\t\t} else if (!used[BUNDLE_ISSUE_ALU1]) {\n\t\t\t\tissue = BUNDLE_ISSUE_ALU1;\n\t\t\t} else if (!used[BUNDLE_ISSUE_MAU]) {\n\t\t\t\tissue = BUNDLE_ISSUE_MAU;\n\t\t\t} else if (!used[BUNDLE_ISSUE_LSU]) {\n\t\t\t\tissue = BUNDLE_ISSUE_LSU;\n\t\t\t} else {\n\t\t\t\t/* too many ALUs */\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t\tbreak;\n\t\tcase STEERING_MAU:\n\t\t\tissue = BUNDLE_ISSUE_MAU;\n\t\t\tbreak;\n\t\tcase STEERING_LSU:\n\t\t\tissue = BUNDLE_ISSUE_LSU;\n\t\t\tbreak;\n\t\t}\n\n\t\tinsn = &bundle->issue[issue];\n\n\t\tif (!used[issue]) {\n\t\t\tused[issue] = 1;\n\t\t\tinsn->len = 0;\n\t\t} else if (!extension && used[issue]) {\n\t\t\t/* issue already used */\n\t\t\tgoto error;\n\t\t} else if (extension && !used[issue]) {\n\t\t\t/* missing issue */\n\t\t\tgoto error;\n\t\t}\n\t\tif (insn->len == KVX_MAX_SYLLABLES) {\n\t\t\t/* too many syllables */\n\t\t\tgoto error;\n\t\t}\n\t\tinsn->value[insn->len] = word;\n\t\tinsn->len++;\n\t}\n\n\tfor (issue = 0; issue < KVX_MAX_BUNDLE_ISSUE; issue++) {\n\t\tif (!used[issue])\n\t\t\tcontinue;\n\t\tinsn = &bundle->issue[issue];\n\n\t\tinsn->opc = NULL;\n\t\tfor (i = 0; i < KV3_OPC_COUNT; i++) {\n\t\t\tif (kvx_opc_match (&kv3_opc[i], insn)) {\n\t\t\t\tinsn->opc = &kv3_opc[i];\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tcount = 0;\n\tfor (issue = KVX_MAX_BUNDLE_ISSUE - 1; issue >= 0; issue--) {\n\t\tif (!used[issue])\n\t\t\tcontinue;\n\t\tinsn = &bundle->issue[issue];\n\t\tinsn->rem = count++;\n\t}\n\n\treturn 0;\nerror:\n\treturn -1;\n}\n\nstatic int read_bundle(ut32 *words, const ut8 *buf, int len) {\n\tint count = 0;\n\tut32 word;\n\n\twhile (len >= sizeof (ut32) && count < KVX_MAX_BUNDLE_WORDS) {\n\t\tword = r_read_le32 (buf);\n\t\twords[count] = word;\n\t\tcount++;\n\n\t\tif (!kvx_has_parallel_bit (word)) {\n\t\t\tbreak;\n\t\t}\n\n\t\tbuf += sizeof (ut32);\n\t\tlen -= sizeof (ut32);\n\t}\n\n\tif (count == KVX_MAX_BUNDLE_WORDS && kvx_has_parallel_bit (word)) {\n\t\t/* this is wrong */\n\t}\n\n\treturn count;\n}\n\ninsn_t *kvx_next_insn(bundle_t *bundle, ut64 addr, const ut8 *buf, int len) {\n\tut32 words[KVX_MAX_BUNDLE_WORDS];\n\tut64 start;\n\tint count, issue = KVX_MAX_BUNDLE_ISSUE;\n\tint ret;\n\n\tif (bundle->addr <= addr && addr < (bundle->addr + bundle->size)) {\n\t\tstart = bundle->addr;\n\t\tissue = 0;\n\t\tfor (issue = 0; issue < KVX_MAX_BUNDLE_ISSUE; issue++) {\n\t\t\tif (addr == start) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tstart += bundle->issue[issue].len * sizeof (ut32);\n\t\t}\n\t\twhile (issue < KVX_MAX_BUNDLE_ISSUE && bundle->issue[issue].len == 0) {\n\t\t\tissue++;\n\t\t}\n\t}\n\n\tif (issue == KVX_MAX_BUNDLE_ISSUE) {\n\t\tmemset (bundle, 0, sizeof (*bundle));\n\t\tissue = 0;\n\n\t\tcount = read_bundle (words, buf, len);\n\t\tif (count == 0)\n\t\t\treturn NULL;\n\n\t\tbundle->addr = addr;\n\t\tbundle->size = count * sizeof (ut32);\n\t\tret = disassemble_bundle (bundle, words, count);\n\t\tif (ret)\n\t\t\treturn NULL;\n\t}\n\n\twhile (issue < KVX_MAX_BUNDLE_ISSUE && bundle->issue[issue].len == 0) {\n\t\tissue++;\n\t}\n\n\tif (issue < KVX_MAX_BUNDLE_ISSUE) {\n\t\treturn &bundle->issue[issue];\n\t}\n\n\treturn NULL;\n}\n", "/* radare - LGPL - Copyright 2009-2022 - pancake, nibble */\n\n#include <r_types.h>\n#include <r_list.h>\n#include <r_flag.h>\n#include <r_core.h>\n#include <r_bin.h>\n#include <ht_uu.h>\n#include <r_util/r_graph_drawable.h>\n\n#include <string.h>\n\nHEAPTYPE (ut64);\n\n// used to speedup strcmp with rconfig.get in loops\nenum {\n\tR2_ARCH_THUMB,\n\tR2_ARCH_ARM32,\n\tR2_ARCH_ARM64,\n\tR2_ARCH_MIPS\n};\n// 128M\n#define MAX_SCAN_SIZE 0x7ffffff\n\nstatic void loganal(ut64 from, ut64 to, int depth) {\n\tr_cons_clear_line (1);\n\teprintf (\"0x%08\"PFMT64x\" > 0x%08\"PFMT64x\" %d\\r\", from, to, depth);\n}\n\nstatic int cmpsize(const void *a, const void *b) {\n\tut64 as = r_anal_function_linear_size ((RAnalFunction *) a);\n\tut64 bs = r_anal_function_linear_size ((RAnalFunction *) b);\n\treturn (as> bs)? 1: (as< bs)? -1: 0;\n}\n\nstatic int cmpfcncc(const void *_a, const void *_b) {\n\tRAnalFunction *a = (RAnalFunction *)_a;\n\tRAnalFunction *b = (RAnalFunction *)_b;\n\tut64 as = r_anal_function_complexity (a);\n\tut64 bs = r_anal_function_complexity (b);\n\treturn (as > bs)? 1: (as < bs)? -1: 0;\n}\n\nstatic int cmpedges(const void *_a, const void *_b) {\n\tconst RAnalFunction *a = _a, *b = _b;\n\tint as, bs;\n\tr_anal_function_count_edges (a, &as);\n\tr_anal_function_count_edges (b, &bs);\n\treturn (as > bs)? 1: (as < bs)? -1: 0;\n}\n\nstatic int cmpframe(const void *_a, const void *_b) {\n\tconst RAnalFunction *a = _a, *b = _b;\n\tint as = a->maxstack;\n\tint bs = b->maxstack;\n\treturn (as > bs)? 1: (as < bs)? -1: 0;\n}\n\nstatic int cmpxrefs(const void *_a, const void *_b) {\n\tconst RAnalFunction *a = _a, *b = _b;\n\tint as = a->meta.numrefs;\n\tint bs = b->meta.numrefs;\n\treturn (as > bs)? 1: (as < bs)? -1: 0;\n}\n\nstatic int cmpname(const void *_a, const void *_b) {\n\tconst RAnalFunction *a = _a, *b = _b;\n\tint as = strcmp (a->name, b->name);\n\tint bs = strcmp (b->name, a->name);\n\treturn (as > bs)? 1: (as < bs)? -1: 0;\n}\n\nstatic int cmpcalls(const void *_a, const void *_b) {\n\tconst RAnalFunction *a = _a, *b = _b;\n\tint as = a->meta.numcallrefs;\n\tint bs = b->meta.numcallrefs;\n\treturn (as > bs)? 1: (as < bs)? -1: 0;\n}\n\nstatic int cmpnbbs(const void *_a, const void *_b) {\n\tconst RAnalFunction *a = _a, *b = _b;\n\tut64 as = r_list_length (a->bbs);\n\tut64 bs = r_list_length (b->bbs);\n\treturn (as> bs)? 1: (as< bs)? -1: 0;\n}\n\nstatic int cmpaddr(const void *_a, const void *_b) {\n\tconst RAnalFunction *a = _a, *b = _b;\n\treturn (a->addr > b->addr)? 1: (a->addr < b->addr)? -1: 0;\n}\n\nstatic char *get_function_name(RCore *core, ut64 addr) {\n\tRBinFile *bf = r_bin_cur (core->bin);\n\tif (bf && bf->o) {\n\t\tRBinSymbol *sym = ht_up_find (bf->o->addr2klassmethod, addr, NULL);\n\t\tif (sym && sym->classname && sym->name) {\n\t\t\treturn r_str_newf (\"method.%s.%s\", sym->classname, sym->name);\n\t\t}\n\t}\n\tRFlagItem *flag = r_core_flag_get_by_spaces (core->flags, addr);\n\treturn (flag && flag->name) ? strdup (flag->name) : NULL;\n}\n\nstatic RCore *mycore = NULL;\n\n// XXX: copypaste from anal/data.c\n#define MINLEN 1\nstatic int is_string(const ut8 *buf, int size, int *len) {\n\tint i, fakeLen = 0;\n\tif (size < 1) {\n\t\treturn 0;\n\t}\n\tif (!len) {\n\t\tlen = &fakeLen;\n\t}\n\tif (size > 3 && buf[0] && !buf[1] && buf[2] && !buf[3]) {\n\t\t*len = 1; // XXX: TODO: Measure wide string length\n\t\treturn 2; // is wide\n\t}\n\tfor (i = 0; i < size; i++) {\n\t\tif (!buf[i] && i > MINLEN) {\n\t\t\t*len = i;\n\t\t\treturn 1;\n\t\t}\n\t\tif (buf[i] == 10 || buf[i] == 13 || buf[i] == 9) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (buf[i] < 32 || buf[i] > 127) {\n\t\t\t// not ascii text\n\t\t\treturn 0;\n\t\t}\n\t\tif (!IS_PRINTABLE (buf[i])) {\n\t\t\t*len = i;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t*len = i;\n\treturn 1;\n}\n\nstatic char *is_string_at(RCore *core, ut64 addr, int *olen) {\n\tut8 rstr[128] = {0};\n\tint ret = 0, len = 0;\n\tut8 *str = calloc (256, 1);\n\tif (!str) {\n\t\tif (olen) {\n\t\t\t*olen = 0;\n\t\t}\n\t\treturn NULL;\n\t}\n\tr_io_read_at (core->io, addr, str, 255);\n\n\tstr[255] = 0;\n\tif (is_string (str, 256, &len)) {\n\t\tif (olen) {\n\t\t\t*olen = len;\n\t\t}\n\t\treturn (char*) str;\n\t}\n\n\tut64 *cstr = (ut64*)str;\n\tut64 lowptr = cstr[0];\n\tif (lowptr >> 32) { // must be pa mode only\n\t\tlowptr &= UT32_MAX;\n\t}\n\t// cstring\n\tif (cstr[0] == 0 && cstr[1] < 0x1000) {\n\t\tut64 ptr = cstr[2];\n\t\tif (ptr >> 32) { // must be pa mode only\n\t\t\tptr &= UT32_MAX;\n\t\t}\n\t\tif (ptr) {\n\t\t\tr_io_read_at (core->io, ptr, rstr, sizeof (rstr));\n\t\t\trstr[127] = 0;\n\t\t\tret = is_string (rstr, 128, &len);\n\t\t\tif (ret) {\n\t\t\t\tstrcpy ((char*) str, (char*) rstr);\n\t\t\t\tif (olen) {\n\t\t\t\t\t*olen = len;\n\t\t\t\t}\n\t\t\t\treturn (char*) str;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// pstring\n\t\tr_io_read_at (core->io, lowptr, rstr, sizeof (rstr));\n\t\trstr[127] = 0;\n\t\tret = is_string (rstr, sizeof (rstr), &len);\n\t\tif (ret) {\n\t\t\tstrcpy ((char*) str, (char*) rstr);\n\t\t\tif (olen) {\n\t\t\t\t*olen = len;\n\t\t\t}\n\t\t\treturn (char*) str;\n\t\t}\n\t}\n\t// check if current section have no exec bit\n\tif (len < 1) {\n\t\tret = 0;\n\t\tfree (str);\n\t\tlen = -1;\n\t} else if (olen) {\n\t\t*olen = len;\n\t}\n\t// NOTE: coverity says that ret is always 0 here, so str is dead code\n\treturn ret? (char *)str: NULL;\n}\n\n/* returns the R_ANAL_ADDR_TYPE_* of the address 'addr' */\nR_API ut64 r_core_anal_address(RCore *core, ut64 addr) {\n\tut64 types = 0;\n\tRRegSet *rs = NULL;\n\tif (!core) {\n\t\treturn 0;\n\t}\n\tif (core->dbg && core->dbg->reg) {\n\t\trs = r_reg_regset_get (core->dbg->reg, R_REG_TYPE_GPR);\n\t}\n\tif (rs) {\n\t\tRRegItem *r;\n\t\tRListIter *iter;\n\t\tr_list_foreach (rs->regs, iter, r) {\n\t\t\tif (r->type == R_REG_TYPE_GPR) {\n\t\t\t\tut64 val = r_reg_getv(core->dbg->reg, r->name);\n\t\t\t\tif (addr == val) {\n\t\t\t\t\ttypes |= R_ANAL_ADDR_TYPE_REG;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tif (r_flag_get_i (core->flags, addr)) {\n\t\ttypes |= R_ANAL_ADDR_TYPE_FLAG;\n\t}\n\tif (r_anal_get_fcn_in (core->anal, addr, 0)) {\n\t\ttypes |= R_ANAL_ADDR_TYPE_FUNC;\n\t}\n\t// check registers\n\tif (core->bin && core->dbg && r_config_get_b (core->config, \"cfg.debug\")) {\n\t\tRDebugMap *map;\n\t\tRListIter *iter;\n\t\t// use 'dm'\n\t\t// XXX: this line makes r2 debugging MUCH slower\n\t\t// r_debug_map_sync (core->dbg);\n\t\tr_list_foreach (core->dbg->maps, iter, map) {\n\t\t\tif (addr >= map->addr && addr < map->addr_end) {\n\t\t\t\tif (map->name && map->name[0] == '/') {\n\t\t\t\t\tif (core->io && core->io->desc &&\n\t\t\t\t\t\tcore->io->desc->name &&\n\t\t\t\t\t\t!strcmp (map->name,\n\t\t\t\t\t\t\t core->io->desc->name)) {\n\t\t\t\t\t\ttypes |= R_ANAL_ADDR_TYPE_PROGRAM;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttypes |= R_ANAL_ADDR_TYPE_LIBRARY;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (map->perm & R_PERM_X) {\n\t\t\t\t\ttypes |= R_ANAL_ADDR_TYPE_EXEC;\n\t\t\t\t}\n\t\t\t\tif (map->perm & R_PERM_R) {\n\t\t\t\t\ttypes |= R_ANAL_ADDR_TYPE_READ;\n\t\t\t\t}\n\t\t\t\tif (map->perm & R_PERM_W) {\n\t\t\t\t\ttypes |= R_ANAL_ADDR_TYPE_WRITE;\n\t\t\t\t}\n\t\t\t\t// find function\n\t\t\t\tif (map->name && strstr (map->name, \"heap\")) {\n\t\t\t\t\ttypes |= R_ANAL_ADDR_TYPE_HEAP;\n\t\t\t\t}\n\t\t\t\tif (map->name && strstr (map->name, \"stack\")) {\n\t\t\t\t\ttypes |= R_ANAL_ADDR_TYPE_STACK;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tint _perm = -1;\n\t\tif (core->io) {\n\t\t\t// sections\n\t\t\tRIOBank *bank = r_io_bank_get (core->io, core->io->bank);\n\t\t\tif (bank) {\n\t\t\t\tRIOMapRef *mapref;\n\t\t\t\tRListIter *iter;\n\t\t\t\tr_list_foreach (bank->maprefs, iter, mapref) {\n\t\t\t\t\tRIOMap *s = r_io_map_get (core->io, mapref->id);\n\t\t\t\t\tif (addr >= s->itv.addr && addr < (s->itv.addr + s->itv.size)) {\n\t\t\t\t\t\t// sections overlap, so we want to get the one with lower perms\n\t\t\t\t\t\t_perm = (_perm != -1) ? R_MIN (_perm, s->perm) : s->perm;\n\t\t\t\t\t\t// TODO: we should identify which maps come from the program or other\n\t\t\t\t\t\t//types |= R_ANAL_ADDR_TYPE_PROGRAM;\n\t\t\t\t\t\t// find function those sections should be created by hand or esil init\n\t\t\t\t\t\tif (s->name && strstr (s->name, \"heap\")) {\n\t\t\t\t\t\t\ttypes |= R_ANAL_ADDR_TYPE_HEAP;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (s->name && strstr (s->name, \"stack\")) {\n\t\t\t\t\t\t\ttypes |= R_ANAL_ADDR_TYPE_STACK;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (_perm != -1) {\n\t\t\tif (_perm & R_PERM_X) {\n\t\t\t\ttypes |= R_ANAL_ADDR_TYPE_EXEC;\n\t\t\t}\n\t\t\tif (_perm & R_PERM_R) {\n\t\t\t\ttypes |= R_ANAL_ADDR_TYPE_READ;\n\t\t\t}\n\t\t\tif (_perm & R_PERM_W) {\n\t\t\t\ttypes |= R_ANAL_ADDR_TYPE_WRITE;\n\t\t\t}\n\t\t}\n\t}\n\n\t// check if it's ascii\n\tif (addr != 0) {\n\t\tint not_ascii = 0;\n\t\tint i, failed_sequence, dir, on;\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tut8 n = (addr >> (i * 8)) & 0xff;\n\t\t\tif (n && !IS_PRINTABLE (n)) {\n\t\t\t\tnot_ascii = 1;\n\t\t\t}\n\t\t}\n\t\tif (!not_ascii) {\n\t\t\ttypes |= R_ANAL_ADDR_TYPE_ASCII;\n\t\t}\n\t\tfailed_sequence = 0;\n\t\tdir = on = -1;\n\t\tfor (i = 0; i < 8; i++) {\n\t\t\tut8 n = (addr >> (i * 8)) & 0xff;\n\t\t\tif (on != -1) {\n\t\t\t\tif (dir == -1) {\n\t\t\t\t\tdir = (n > on)? 1: -1;\n\t\t\t\t}\n\t\t\t\tif (n == on + dir) {\n\t\t\t\t\t// ok\n\t\t\t\t} else {\n\t\t\t\t\tfailed_sequence = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ton = n;\n\t\t}\n\t\tif (!failed_sequence) {\n\t\t\ttypes |= R_ANAL_ADDR_TYPE_SEQUENCE;\n\t\t}\n\t}\n\treturn types;\n}\n\nstatic bool blacklisted_word(char* name) {\n\tconst char * list[] = {\n\t\t\"__stack_chk_guard\",\n\t\t\"__stderrp\",\n\t\t\"__stdinp\",\n\t\t\"__stdoutp\",\n\t\t\"_DefaultRuneLocale\"\n\t};\n\tint i;\n\tfor (i = 0; i < sizeof (list) / sizeof (list[0]); i++) {\n\t\tif (strstr (name, list[i])) { return true; }\n\t}\n\treturn false;\n}\n\nstatic char *anal_fcn_autoname(RCore *core, RAnalFunction *fcn, int dump, int mode) {\n\tint use_getopt = 0;\n\tint use_isatty = 0;\n\tPJ *pj = NULL;\n\tchar *do_call = NULL;\n\tRAnalRef *ref;\n\tRListIter *iter;\n\tRList *refs = r_anal_function_get_refs (fcn);\n\tif (mode == 'j') {\n\t\t// start a new JSON object\n\t\tpj = r_core_pj_new (core);\n\t\tpj_a (pj);\n\t}\n\tif (refs) {\n\t\tr_list_foreach (refs, iter, ref) {\n\t\t\tRFlagItem *f = r_flag_get_i (core->flags, ref->addr);\n\t\t\tif (f) {\n\t\t\t\t// If dump is true, print all strings referenced by the function\n\t\t\t\tif (dump) {\n\t\t\t\t\t// take only strings flags\n\t\t\t\t\tif (!strncmp (f->name, \"str.\", 4)) {\n\t\t\t\t\t\tif (mode == 'j') {\n\t\t\t\t\t\t\t// add new json item\n\t\t\t\t\t\t\tpj_o (pj);\n\t\t\t\t\t\t\tpj_kn (pj, \"addr\", ref->at);\n\t\t\t\t\t\t\tpj_kn (pj, \"ref\", ref->addr);\n\t\t\t\t\t\t\tpj_ks (pj, \"flag\", f->name);\n\t\t\t\t\t\t\tpj_end (pj);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" 0x%08\"PFMT64x\" %s\\n\", ref->at, ref->addr, f->name);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else if (do_call) { // break if a proper autoname found and not in dump mode\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// enter only if a candidate name hasn't found yet\n\t\t\t\tif (!do_call) {\n\t\t\t\t\tif (blacklisted_word (f->name)) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (strstr (f->name, \".isatty\")) {\n\t\t\t\t\t\tuse_isatty = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (strstr (f->name, \".getopt\")) {\n\t\t\t\t\t\tuse_getopt = 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (!strncmp (f->name, \"method.\", 7)) {\n\t\t\t\t\t\tfree (do_call);\n\t\t\t\t\t\tdo_call = strdup (f->name + 7);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!strncmp (f->name, \"str.\", 4)) {\n\t\t\t\t\t\tfree (do_call);\n\t\t\t\t\t\tdo_call = strdup (f->name + 4);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!strncmp (f->name, \"dbg.\", 4)) {\n\t\t\t\t\t\tfree (do_call);\n\t\t\t\t\t\tdo_call = strdup (f->name + 4);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!strncmp (f->name, \"sym.imp.\", 8)) {\n\t\t\t\t\t\tfree (do_call);\n\t\t\t\t\t\tdo_call = strdup (f->name + 8);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif (!strncmp (f->name, \"reloc.\", 6)) {\n\t\t\t\t\t\tfree (do_call);\n\t\t\t\t\t\tdo_call = strdup (f->name + 6);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tr_list_free (refs);\n\t}\n\tif (mode ==  'j') {\n\t\tpj_end (pj);\n\t}\n\tif (pj) {\n\t\tr_cons_printf (\"%s\\n\", pj_string (pj));\n\t\tpj_free (pj);\n\t}\n\t// TODO: append counter if name already exists\n\tif (use_getopt) {\n\t\tRFlagItem *item = r_flag_get (core->flags, \"main\");\n\t\tfree (do_call);\n\t\t// if referenced from entrypoint. this should be main\n\t\tif (item && item->offset == fcn->addr) {\n\t\t\treturn strdup (\"main\"); // main?\n\t\t}\n\t\treturn strdup (\"parse_args\"); // main?\n\t}\n\tif (use_isatty) {\n\t\tchar *ret = r_str_newf (\"sub.setup_tty_%s_%\"PFMT64x, do_call, fcn->addr);\n\t\tfree (do_call);\n\t\treturn ret;\n\t}\n\tif (do_call) {\n\t\tchar *ret = r_str_newf (\"sub.%s_%\"PFMT64x, do_call, fcn->addr);\n\t\tfree (do_call);\n\t\treturn ret;\n\t}\n\treturn NULL;\n}\n\n/*this only autoname those function that start with fcn.* or sym.func.* */\nR_API void r_core_anal_autoname_all_fcns(RCore *core) {\n\tRListIter *it;\n\tRAnalFunction *fcn;\n\n\tr_list_foreach (core->anal->fcns, it, fcn) {\n\t\tif (!strncmp (fcn->name, \"fcn.\", 4) || !strncmp (fcn->name, \"sym.func.\", 9)) {\n\t\t\tRFlagItem *item = r_flag_get (core->flags, fcn->name);\n\t\t\tif (item) {\n\t\t\t\tchar *name = anal_fcn_autoname (core, fcn, 0, 0);\n\t\t\t\tif (name) {\n\t\t\t\t\tr_flag_rename (core->flags, item, name);\n\t\t\t\t\tfree (fcn->name);\n\t\t\t\t\tfcn->name = name;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// there should always be a flag for a function\n\t\t\t\tr_warn_if_reached ();\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* reads .gopclntab section in go binaries to recover function names\n   and adds them as sym.go.* flags */\nR_API void r_core_anal_autoname_all_golang_fcns(RCore *core) {\n\tRList* section_list = r_bin_get_sections (core->bin);\n\tRListIter *iter;\n\tconst char* oldstr = NULL;\n\tRBinSection *section;\n\tut64 gopclntab = 0;\n\tr_list_foreach (section_list, iter, section) {\n\t\tif (strstr (section->name, \".gopclntab\")) {\n\t\t\tgopclntab = section->vaddr;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (!gopclntab) {\n\t\toldstr = r_print_rowlog (core->print, \"Could not find .gopclntab section\");\n\t\tr_print_rowlog_done (core->print, oldstr);\n\t\treturn;\n\t}\n\tint ptr_size = core->anal->bits / 8;\n\tut64 offset = gopclntab + 2 * ptr_size;\n\tut64 size_offset = gopclntab + 3 * ptr_size ;\n\tut8 temp_size[4] = {0};\n\tif (!r_io_nread_at (core->io, size_offset, temp_size, 4)) {\n\t\treturn;\n\t}\n\tut32 size = r_read_le32 (temp_size);\n\tint num_syms = 0;\n\t//r_cons_print (\"[x] Reading .gopclntab...\\n\");\n\tr_flag_space_push (core->flags, R_FLAGS_FS_SYMBOLS);\n\twhile (offset < gopclntab + size) {\n\t\tut8 temp_delta[4] = {0};\n\t\tut8 temp_func_addr[4] = {0};\n\t\tut8 temp_func_name[4] = {0};\n\t\tif (!r_io_nread_at (core->io, offset + ptr_size, temp_delta, 4)) {\n\t\t\tbreak;\n\t\t}\n\t\tut32 delta = r_read_le32 (temp_delta);\n\t\tut64 func_offset = gopclntab + delta;\n\t\tif (!r_io_nread_at (core->io, func_offset, temp_func_addr, 4) ||\n\t\t\t!r_io_nread_at (core->io, func_offset + ptr_size, temp_func_name, 4)) {\n\t\t\tbreak;\n\t\t}\n\t\tut32 func_addr = r_read_le32 (temp_func_addr);\n\t\tut32 func_name_offset = r_read_le32 (temp_func_name);\n\t\tut8 func_name[64] = {0};\n\t\tr_io_read_at (core->io, gopclntab + func_name_offset, func_name, 63);\n\t\tif (func_name[0] == 0xff) {\n\t\t\tbreak;\n\t\t}\n\t\tr_name_filter ((char *)func_name, 0);\n\t\t//r_cons_printf (\"[x] Found symbol %s at 0x%x\\n\", func_name, func_addr);\n\t\tchar *flagname = r_str_newf (\"sym.go.%s\", func_name);\n\t\tr_flag_set (core->flags, flagname, func_addr, 1);\n\t\tfree (flagname);\n\t\toffset += 2 * ptr_size;\n\t\tnum_syms++;\n\t}\n\tr_flag_space_pop (core->flags);\n\tif (num_syms) {\n\t\tr_strf_var (msg, 128, \"Found %d symbols and saved them at sym.go.*\", num_syms);\n\t\toldstr = r_print_rowlog (core->print, msg);\n\t\tr_print_rowlog_done (core->print, oldstr);\n\t} else {\n\t\toldstr = r_print_rowlog (core->print, \"Found no symbols.\");\n\t\tr_print_rowlog_done (core->print, oldstr);\n\t}\n}\n\n/* suggest a name for the function at the address 'addr'.\n * If dump is true, every strings associated with the function is printed */\nR_API char *r_core_anal_fcn_autoname(RCore *core, ut64 addr, int dump, int mode) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\treturn fcn? anal_fcn_autoname (core, fcn, dump, mode): NULL;\n}\n\nstatic ut64 *next_append(ut64 *next, int *nexti, ut64 v) {\n\tut64 *tmp_next = realloc (next, sizeof (ut64) * (1 + *nexti));\n\tif (!tmp_next) {\n\t\treturn NULL;\n\t}\n\tnext = tmp_next;\n\tnext[*nexti] = v;\n\t(*nexti)++;\n\treturn next;\n}\n\nstatic void r_anal_set_stringrefs(RCore *core, RAnalFunction *fcn) {\n\tRListIter *iter;\n\tRAnalRef *ref;\n\tRList *refs = r_anal_function_get_refs (fcn);\n\tr_list_foreach (refs, iter, ref) {\n\t\tif (ref->type == R_ANAL_REF_TYPE_DATA &&\n\t\t\tr_bin_is_string (core->bin, ref->addr)) {\n\t\t\tr_anal_xrefs_set (core->anal, ref->at, ref->addr, R_ANAL_REF_TYPE_STRING);\n\t\t}\n\t}\n\tr_list_free (refs);\n}\n\nstatic bool r_anal_try_get_fcn(RCore *core, RAnalRef *ref, int fcndepth, int refdepth) {\n\tif (!refdepth) {\n\t\treturn false;\n\t}\n\tRIOMap *map = r_io_map_get_at (core->io, ref->addr);\n\tif (!map) {\n\t\treturn false;\n\t}\n\n\tif (map->perm & R_PERM_X) {\n\t\tut8 buf[64];\n\t\tr_io_read_at (core->io, ref->addr, buf, sizeof (buf));\n\t\tbool looksLikeAFunction = r_anal_check_fcn (core->anal, buf, sizeof (buf), ref->addr, r_io_map_begin (map),\n\t\t\t\tr_io_map_end (map));\n\t\tif (looksLikeAFunction) {\n\t\t\tif (core->anal->limit) {\n\t\t\t\tif (ref->addr < core->anal->limit->from ||\n\t\t\t\t\t\tref->addr > core->anal->limit->to) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_core_anal_fcn (core, ref->addr, ref->at, ref->type, fcndepth - 1);\n\t\t}\n\t} else {\n\t\tut64 offs = 0;\n\t\tut64 sz = core->anal->bits >> 3;\n\t\tRAnalRef ref1;\n\t\tref1.type = R_ANAL_REF_TYPE_DATA;\n\t\tref1.at = ref->addr;\n\t\tref1.addr = 0;\n\t\tut32 i32;\n\t\tut16 i16;\n\t\tut8 i8;\n\t\tut64 offe = offs + 1024;\n\t\tfor (offs = 0; offs < offe; offs += sz, ref1.at += sz) {\n\t\t\tut8 bo[8];\n\t\t\tr_io_read_at (core->io, ref->addr + offs, bo, R_MIN (sizeof (bo), sz));\n\t\t\tbool be = core->anal->big_endian;\n\t\t\tswitch (sz) {\n\t\t\tcase 1:\n\t\t\t\ti8 = r_read_ble8 (bo);\n\t\t\t\tref1.addr = (ut64)i8;\n\t\t\t\tbreak;\n\t\t\tcase 2:\n\t\t\t\ti16 = r_read_ble16 (bo, be);\n\t\t\t\tref1.addr = (ut64)i16;\n\t\t\t\tbreak;\n\t\t\tcase 4:\n\t\t\t\ti32 = r_read_ble32 (bo, be);\n\t\t\t\tref1.addr = (ut64)i32;\n\t\t\t\tbreak;\n\t\t\tcase 8:\n\t\t\t\tref1.addr = r_read_ble64 (bo, be);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_anal_try_get_fcn (core, &ref1, fcndepth, refdepth - 1);\n\t\t}\n\t}\n\treturn 1;\n}\n\nstatic int r_anal_analyze_fcn_refs(RCore *core, RAnalFunction *fcn, int depth) {\n\tRListIter *iter;\n\tRAnalRef *ref;\n\tRList *refs = r_anal_function_get_refs (fcn);\n\n\tr_list_foreach (refs, iter, ref) {\n\t\tif (ref->addr == UT64_MAX) {\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (ref->type) {\n\t\tcase R_ANAL_REF_TYPE_DATA:\n\t\t\tif (core->anal->opt.followdatarefs) {\n\t\t\t\tr_anal_try_get_fcn (core, ref, depth, 2);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_REF_TYPE_CODE:\n\t\tcase R_ANAL_REF_TYPE_CALL:\n\t\t\tr_core_anal_fcn (core, ref->addr, ref->at, ref->type, depth - 1);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\t// TODO: fix memleak here, fcn not freed even though it is\n\t\t// added in core->anal->fcns which is freed in r_anal_free()\n\t}\n\tr_list_free (refs);\n\treturn 1;\n}\n\nstatic void function_rename(RFlag *flags, RAnalFunction *fcn) {\n\tconst char *locname = \"loc.\";\n\tconst size_t locsize = strlen (locname);\n\tchar *fcnname = fcn->name;\n\n\tif (strncmp (fcn->name, locname, locsize) == 0) {\n\t\tconst char *fcnpfx, *restofname;\n\t\tRFlagItem *f;\n\n\t\tfcn->type = R_ANAL_FCN_TYPE_FCN;\n\t\tfcnpfx = r_anal_functiontype_tostring (fcn->type);\n\t\trestofname = fcn->name + locsize;\n\t\tfcn->name = r_str_newf (\"%s.%s\", fcnpfx, restofname);\n\n\t\tf = r_flag_get_i (flags, fcn->addr);\n\t\tr_flag_rename (flags, f, fcn->name);\n\n\t\tfree (fcnname);\n\t}\n}\n\nstatic void autoname_imp_trampoline(RCore *core, RAnalFunction *fcn) {\n\tif (r_list_length (fcn->bbs) == 1 && ((RAnalBlock *) r_list_first (fcn->bbs))->ninstr == 1) {\n\t\tRList *refs = r_anal_function_get_refs (fcn);\n\t\tif (refs && r_list_length (refs) == 1) {\n\t\t\tRAnalRef *ref = r_list_first (refs);\n\t\t\tif (ref->type != R_ANAL_REF_TYPE_CALL) { /* Some fcns don't return */\n\t\t\t\tRFlagItem *flg = r_flag_get_i (core->flags, ref->addr);\n\t\t\t\tif (flg && r_str_startswith (flg->name, \"sym.imp.\")) {\n\t\t\t\t\tR_FREE (fcn->name);\n\t\t\t\t\tfcn->name = r_str_newf (\"sub.%s\", flg->name + 8);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tr_list_free (refs);\n\t}\n}\n\nstatic void set_fcn_name_from_flag(RAnalFunction *fcn, RFlagItem *f, const char *fcnpfx) {\n\tbool nameChanged = false;\n\tif (f && f->name) {\n\t\tif (!strncmp (fcn->name, \"loc.\", 4) || !strncmp (fcn->name, \"fcn.\", 4)) {\n\t\t\tr_anal_function_rename (fcn, f->name);\n\t\t\tnameChanged = true;\n\t\t} else if (strncmp (f->name, \"sect\", 4)) {\n\t\t\tr_anal_function_rename (fcn, f->name);\n\t\t\tnameChanged = true;\n\t\t}\n\t}\n\tif (!nameChanged) {\n\t\tchar *nn = r_str_newf (\"%s.%08\" PFMT64x, fcnpfx, fcn->addr);\n\t\tr_anal_function_rename (fcn, nn);\n\t\tfree (nn);\n\t}\n}\n\nstatic bool is_entry_flag(RFlagItem *f) {\n\treturn f->space && !strcmp (f->space->name, R_FLAGS_FS_SYMBOLS) && r_str_startswith (f->name, \"entry.\");\n}\n\nstatic bool __core_anal_fcn(RCore *core, ut64 at, ut64 from, int reftype, int depth) {\n\tif (depth < 0) {\n//\t\tprintf (\"Too deep for 0x%08\"PFMT64x\"\\n\", at);\n//\t\tr_sys_backtrace ();\n\t\treturn false;\n\t}\n\tint has_next = r_config_get_i (core->config, \"anal.hasnext\");\n\tRAnalHint *hint = NULL;\n\tint i, nexti = 0;\n\tut64 *next = NULL;\n\tint fcnlen;\n\tRAnalFunction *fcn = r_anal_function_new (core->anal);\n\tr_warn_if_fail (fcn);\n\tconst char *fcnpfx = r_config_get (core->config, \"anal.fcnprefix\");\n\tif (!fcnpfx) {\n\t\tfcnpfx = \"fcn\";\n\t}\n\tconst char *cc = r_anal_cc_default (core->anal);\n\tif (!cc) {\n\t\tif (r_anal_cc_once (core->anal)) {\n\t\t\teprintf (\"Warning: set your favourite calling convention in `e anal.cc=?`\\n\");\n\t\t}\n\t\tcc = \"reg\";\n\t}\n\tfcn->cc = r_str_constpool_get (&core->anal->constpool, cc);\n\tr_warn_if_fail (fcn->cc);\n\thint = r_anal_hint_get (core->anal, at);\n\tif (hint && hint->bits == 16) {\n\t\t// expand 16bit for function\n\t\tfcn->bits = 16;\n\t} else {\n\t\tfcn->bits = core->anal->bits;\n\t}\n\tfcn->addr = at;\n\tfcn->name = get_function_name (core, at);\n\n\tif (!fcn->name) {\n\t\tfcn->name = r_str_newf (\"%s.%08\"PFMT64x, fcnpfx, at);\n\t}\n\tr_anal_function_invalidate_read_ahead_cache ();\n\tdo {\n\t\tRFlagItem *f;\n\t\tut64 delta = r_anal_function_linear_size (fcn);\n\t\tif (!r_io_is_valid_offset (core->io, at + delta, !core->anal->opt.noncode)) {\n\t\t\tgoto error;\n\t\t}\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tfcnlen = r_anal_function(core->anal, fcn, at + delta, core->anal->opt.bb_max_size, reftype);\n\t\tif (core->anal->opt.searchstringrefs) {\n\t\t\tr_anal_set_stringrefs (core, fcn);\n\t\t}\n\t\tif (fcnlen == 0) {\n\t\t\tif (core->anal->verbose) {\n\t\t\t\teprintf (\"Analyzed function size is 0 at 0x%08\"PFMT64x\"\\n\", at + delta);\n\t\t\t}\n\t\t\tgoto error;\n\t\t}\n\t\tif (fcnlen < 0) {\n\t\t\tswitch (fcnlen) {\n\t\t\tcase R_ANAL_RET_ERROR:\n\t\t\tcase R_ANAL_RET_NEW:\n\t\t\tcase R_ANAL_RET_DUP:\n\t\t\tcase R_ANAL_RET_END:\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\teprintf (\"Oops. Negative fcnsize at 0x%08\"PFMT64x\" (%d)\\n\", at, fcnlen);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tf = r_core_flag_get_by_spaces (core->flags, fcn->addr);\n\t\tset_fcn_name_from_flag (fcn, f, fcnpfx);\n\n\t\tif (fcnlen == R_ANAL_RET_ERROR ||\n\t\t\t(fcnlen == R_ANAL_RET_END && !r_anal_function_realsize (fcn))) { /* Error analyzing function */\n\t\t\tif (core->anal->opt.followbrokenfcnsrefs) {\n\t\t\t\tr_anal_analyze_fcn_refs (core, fcn, depth);\n\t\t\t}\n\t\t\tgoto error;\n\t\t} else if (fcnlen == R_ANAL_RET_END) { /* Function analysis complete */\n\t\t\tf = r_core_flag_get_by_spaces (core->flags, fcn->addr);\n\t\t\tif (f && f->name && strncmp (f->name, \"sect\", 4)) { /* Check if it's already flagged */\n\t\t\t\tchar *new_name = strdup (f->name);\n\t\t\t\tif (is_entry_flag (f)) {\n\t\t\t\t\tRListIter *iter;\n\t\t\t\t\tRBinSymbol *sym;\n\t\t\t\t\tconst RList *syms = r_bin_get_symbols (core->bin);\n\t\t\t\t\tut64 baddr = r_config_get_i (core->config, \"bin.baddr\");\n\t\t\t\t\tr_list_foreach (syms, iter, sym) {\n\t\t\t\t\t\tif (sym->type && (sym->paddr + baddr) == fcn->addr && !strcmp (sym->type, R_BIN_TYPE_FUNC_STR)) {\n\t\t\t\t\t\t\tfree (new_name);\n\t\t\t\t\t\t\tnew_name = r_str_newf (\"sym.%s\", sym->name);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfree (fcn->name);\n\t\t\t\tfcn->name = new_name;\n\t\t\t} else {\n\t\t\t\tR_FREE (fcn->name);\n\t\t\t\tconst char *fcnpfx = r_anal_functiontype_tostring (fcn->type);\n\t\t\t\tif (!fcnpfx || !*fcnpfx || !strcmp (fcnpfx, \"fcn\")) {\n\t\t\t\t\tfcnpfx = r_config_get (core->config, \"anal.fcnprefix\");\n\t\t\t\t}\n\t\t\t\tfcn->name = r_str_newf (\"%s.%08\"PFMT64x, fcnpfx, fcn->addr);\n\t\t\t\tautoname_imp_trampoline (core, fcn);\n\t\t\t\t/* Add flag */\n\t\t\t\tr_flag_space_push (core->flags, R_FLAGS_FS_FUNCTIONS);\n\t\t\t\tr_flag_set (core->flags, fcn->name, fcn->addr, r_anal_function_linear_size (fcn));\n\t\t\t\tr_flag_space_pop (core->flags);\n\t\t\t}\n\n\t\t\t/* New function: Add initial xref */\n\t\t\tif (from != UT64_MAX) {\n\t\t\t\tr_anal_xrefs_set (core->anal, from, fcn->addr, reftype);\n\t\t\t}\n\t\t\t// XXX: this is wrong. See CID 1134565\n\t\t\tr_anal_add_function (core->anal, fcn);\n\t\t\tif (has_next) {\n\t\t\t\tut64 addr = r_anal_function_max_addr (fcn);\n\t\t\t\tRIOMap *map = r_io_map_get_at (core->io, addr);\n\t\t\t\t// only get next if found on an executable section\n\t\t\t\tif (!map || (map && map->perm & R_PERM_X)) {\n\t\t\t\t\tfor (i = 0; i < nexti; i++) {\n\t\t\t\t\t\tif (next[i] == addr) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (i == nexti) {\n\t\t\t\t\t\tut64 at = r_anal_function_max_addr (fcn);\n\t\t\t\t\t\twhile (true) {\n\t\t\t\t\t\t\tut64 size;\n\t\t\t\t\t\t\tRAnalMetaItem *mi = r_meta_get_at (core->anal, at, R_META_TYPE_ANY, &size);\n\t\t\t\t\t\t\tif (!mi) {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tat += size;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// TODO: ensure next address is function after padding (nop or trap or wat)\n\t\t\t\t\t\t// XXX noisy for test cases because we want to clear the stderr\n\t\t\t\t\t\tr_cons_clear_line (1);\n\t\t\t\t\t\tloganal (fcn->addr, at, 10000 - depth);\n\t\t\t\t\t\tnext = next_append (next, &nexti, at);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!r_anal_analyze_fcn_refs (core, fcn, depth)) {\n\t\t\t\tgoto error;\n\t\t\t}\n\t\t}\n\t} while (fcnlen != R_ANAL_RET_END);\n\tr_list_free (core->anal->leaddrs);\n\tcore->anal->leaddrs = NULL;\n\tif (has_next) {\n\t\tfor (i = 0; i < nexti; i++) {\n\t\t\tif (!next[i] || r_anal_get_fcn_in (core->anal, next[i], 0)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tr_core_anal_fcn (core, next[i], from, 0, depth - 1);\n\t\t}\n\t\tfree (next);\n\t}\n\tif (core->anal->cur && core->anal->cur->arch && !strcmp (core->anal->cur->arch, \"x86\")) {\n\t\tr_anal_function_check_bp_use (fcn);\n\t\tif (fcn && !fcn->bp_frame) {\n\t\t\tr_anal_function_delete_vars_by_kind (fcn, R_ANAL_VAR_KIND_BPV);\n\t\t}\n\t}\n\tr_anal_hint_free (hint);\n\treturn true;\n\nerror:\n\tr_list_free (core->anal->leaddrs);\n\tcore->anal->leaddrs = NULL;\n\t// ugly hack to free fcn\n\tif (fcn) {\n\t\tif (!r_anal_function_realsize (fcn) || fcn->addr == UT64_MAX) {\n\t\t\tr_anal_function_free (fcn);\n\t\t\tfcn = NULL;\n\t\t} else {\n\t\t\t// TODO: mark this function as not properly analyzed\n\t\t\tif (!fcn->name) {\n\t\t\t\t// XXX dupped code.\n\t\t\t\tfcn->name = r_str_newf (\n\t\t\t\t\t\"%s.%08\" PFMT64x,\n\t\t\t\t\tr_anal_functiontype_tostring (fcn->type),\n\t\t\t\t\tat);\n\t\t\t\t/* Add flag */\n\t\t\t\tr_flag_space_push (core->flags, R_FLAGS_FS_FUNCTIONS);\n\t\t\t\tr_flag_set (core->flags, fcn->name, at, r_anal_function_linear_size (fcn));\n\t\t\t\tr_flag_space_pop (core->flags);\n\t\t\t}\n\t\t\tr_anal_add_function (core->anal, fcn);\n\t\t}\n\t\tif (fcn && has_next) {\n\t\t\tut64 newaddr = r_anal_function_max_addr (fcn);\n\t\t\tRIOMap *map = r_io_map_get_at (core->io, newaddr);\n\t\t\tif (!map || (map && (map->perm & R_PERM_X))) {\n\t\t\t\tnext = next_append (next, &nexti, newaddr);\n\t\t\t\tfor (i = 0; i < nexti; i++) {\n\t\t\t\t\tif (!next[i]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tr_core_anal_fcn (core, next[i], next[i], 0, depth - 1);\n\t\t\t\t}\n\t\t\t\tfree (next);\n\t\t\t}\n\t\t}\n\t}\n\tif (fcn && core->anal->cur && core->anal->cur->arch && !strcmp (core->anal->cur->arch, \"x86\")) {\n\t\tr_anal_function_check_bp_use (fcn);\n\t\tif (!fcn->bp_frame) {\n\t\t\tr_anal_function_delete_vars_by_kind (fcn, R_ANAL_VAR_KIND_BPV);\n\t\t}\n\t}\n\tr_anal_hint_free (hint);\n\treturn false;\n}\n\nstatic char *get_title(ut64 addr) {\n\treturn r_str_newf (\"0x%\"PFMT64x, addr);\n}\n\n/* decode and return the RAnalOp at the address addr */\nR_API RAnalOp* r_core_anal_op(RCore *core, ut64 addr, int mask) {\n\tint len;\n\tut8 buf[32];\n\tut8 *ptr;\n\n\tr_return_val_if_fail (core, NULL);\n\tif (addr == UT64_MAX) {\n\t\treturn NULL;\n\t}\n\tRAnalOp *op = R_NEW0 (RAnalOp);\n\tif (!op) {\n\t\treturn NULL;\n\t}\n\tint delta = (addr - core->offset);\n\tint minopsz = 8;\n\tif (delta > 0 && delta + minopsz < core->blocksize && addr >= core->offset && addr + 16 < core->offset + core->blocksize) {\n\t\tptr = core->block + delta;\n\t\tlen = core->blocksize - delta;\n\t\tif (len < 1) {\n\t\t\tgoto err_op;\n\t\t}\n\t} else {\n\t\tif (!r_io_read_at (core->io, addr, buf, sizeof (buf))) {\n\t\t\tgoto err_op;\n\t\t}\n\t\tptr = buf;\n\t\tlen = sizeof (buf);\n\t}\n\tif (r_anal_op (core->anal, op, addr, ptr, len, mask) < 1) {\n\t\tgoto err_op;\n\t}\n\t// TODO This code block must be deleted when all the anal plugs support disasm\n\tif (!op->mnemonic && mask & R_ANAL_OP_MASK_DISASM) {\n\t\tRAsmOp asmop;\n\t\tif (core->anal->verbose) {\n\t\t\teprintf (\"Warning: Implement RAnalOp.MASK_DISASM for current anal.arch. Using the sluggish RAsmOp fallback for now.\\n\");\n\t\t}\n\t\tr_asm_set_pc (core->rasm, addr);\n\t\tr_asm_op_init (&asmop);\n\t\tif (r_asm_disassemble (core->rasm, &asmop, ptr, len) > 0) {\n\t\t\top->mnemonic = strdup (r_strbuf_get (&asmop.buf_asm));\n\t\t}\n\t\tr_asm_op_fini (&asmop);\n\t}\n\treturn op;\nerr_op:\n\tfree (op);\n\treturn NULL;\n}\n\n// Node for tree-sorting anal hints or collecting hint records at a single addr\ntypedef struct {\n\tRBNode rb;\n\tut64 addr;\n\tenum {\n\t\tHINT_NODE_ADDR,\n\t\tHINT_NODE_ARCH,\n\t\tHINT_NODE_BITS\n\t} type;\n\tunion {\n\t\tconst RVector/*<const RAnalAddrHintRecord>*/ *addr_hints;\n\t\tconst char *arch;\n\t\tint bits;\n\t};\n} HintNode;\n\nstatic void print_hint_h_format(HintNode *node) {\n\tswitch (node->type) {\n\tcase HINT_NODE_ADDR: {\n\t\tconst RAnalAddrHintRecord *record;\n\t\tr_vector_foreach (node->addr_hints, record) {\n\t\t\tswitch (record->type) {\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_IMMBASE:\n\t\t\t\tr_cons_printf (\" immbase=%d\", record->immbase);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_JUMP:\n\t\t\t\tr_cons_printf (\" jump=0x%08\"PFMT64x, record->jump);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_FAIL:\n\t\t\t\tr_cons_printf (\" fail=0x%08\"PFMT64x, record->fail);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_STACKFRAME:\n\t\t\t\tr_cons_printf (\" stackframe=0x%\"PFMT64x, record->stackframe);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_PTR:\n\t\t\t\tr_cons_printf (\" ptr=0x%\"PFMT64x, record->ptr);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_NWORD:\n\t\t\t\tr_cons_printf (\" nword=%d\", record->nword);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_RET:\n\t\t\t\tr_cons_printf (\" ret=0x%08\"PFMT64x, record->retval);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_NEW_BITS:\n\t\t\t\tr_cons_printf (\" newbits=%d\", record->newbits);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_SIZE:\n\t\t\t\tr_cons_printf (\" size=%\"PFMT64u, record->size);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_SYNTAX:\n\t\t\t\tr_cons_printf (\" syntax='%s'\", record->syntax);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_OPTYPE: {\n\t\t\t\tconst char *type = r_anal_optype_to_string (record->optype);\n\t\t\t\tif (type) {\n\t\t\t\t\tr_cons_printf (\" type='%s'\", type);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_OPCODE:\n\t\t\t\tr_cons_printf (\" opcode='%s'\", record->opcode);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_TYPE_OFFSET:\n\t\t\t\tr_cons_printf (\" offset='%s'\", record->type_offset);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_ESIL:\n\t\t\t\tr_cons_printf (\" esil='%s'\", record->esil);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_HIGH:\n\t\t\t\tr_cons_printf (\" high=true\");\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_ADDR_HINT_TYPE_VAL:\n\t\t\t\tr_cons_printf (\" val=0x%08\"PFMT64x, record->val);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\tcase HINT_NODE_ARCH:\n\t\tif (node->arch) {\n\t\t\tr_cons_printf (\" arch='%s'\", node->arch);\n\t\t} else {\n\t\t\tr_cons_print (\" arch=RESET\");\n\t\t}\n\t\tbreak;\n\tcase HINT_NODE_BITS:\n\t\tif (node->bits) {\n\t\t\tr_cons_printf (\" bits=%d\", node->bits);\n\t\t} else {\n\t\t\tr_cons_print (\" bits=RESET\");\n\t\t}\n\t\tbreak;\n\t}\n}\n\n// if mode == 'j', pj must be an existing PJ!\nstatic void hint_node_print(HintNode *node, int mode, PJ *pj) {\n\tswitch (mode) {\n\tcase '*':\n#define HINTCMD_ADDR(hint,fmt,x) r_cons_printf (fmt\" @ 0x%\"PFMT64x\"\\n\", x, (hint)->addr)\n\t\tswitch (node->type) {\n\t\tcase HINT_NODE_ADDR: {\n\t\t\tconst RAnalAddrHintRecord *record;\n\t\t\tr_vector_foreach (node->addr_hints, record) {\n\t\t\t\tswitch (record->type) {\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_IMMBASE:\n\t\t\t\t\tHINTCMD_ADDR (node, \"ahi %d\", record->immbase);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_JUMP:\n\t\t\t\t\tHINTCMD_ADDR (node, \"ahc 0x%\"PFMT64x, record->jump);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_FAIL:\n\t\t\t\t\tHINTCMD_ADDR (node, \"ahf 0x%\"PFMT64x, record->fail);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_STACKFRAME:\n\t\t\t\t\tHINTCMD_ADDR (node, \"ahF 0x%\"PFMT64x, record->stackframe);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_PTR:\n\t\t\t\t\tHINTCMD_ADDR (node, \"ahp 0x%\"PFMT64x, record->ptr);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_NWORD:\n\t\t\t\t\t// no command for this\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_RET:\n\t\t\t\t\tHINTCMD_ADDR (node, \"ahr 0x%\"PFMT64x, record->retval);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_NEW_BITS:\n\t\t\t\t\t// no command for this\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_SIZE:\n\t\t\t\t\tHINTCMD_ADDR (node, \"ahs 0x%\"PFMT64x, record->size);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_SYNTAX:\n\t\t\t\t\tHINTCMD_ADDR (node, \"ahS %s\", record->syntax); // TODO: escape for newcmd\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_OPTYPE: {\n\t\t\t\t\tconst char *type = r_anal_optype_to_string (record->optype);\n\t\t\t\t\tif (type) {\n\t\t\t\t\t\tHINTCMD_ADDR (node, \"aho %s\", type); // TODO: escape for newcmd\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_OPCODE:\n\t\t\t\t\tHINTCMD_ADDR (node, \"ahd %s\", record->opcode);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_TYPE_OFFSET:\n\t\t\t\t\tHINTCMD_ADDR (node, \"aht %s\", record->type_offset); // TODO: escape for newcmd\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_ESIL:\n\t\t\t\t\tHINTCMD_ADDR (node, \"ahe %s\", record->esil); // TODO: escape for newcmd\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_HIGH:\n\t\t\t\t\tr_cons_printf (\"ahh @ 0x%\"PFMT64x\"\\n\", node->addr);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_VAL:\n\t\t\t\t\t// no command for this\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase HINT_NODE_ARCH:\n\t\t\tHINTCMD_ADDR (node, \"aha %s\", r_str_get_fail (node->arch, \"0\"));\n\t\t\tbreak;\n\t\tcase HINT_NODE_BITS:\n\t\t\tHINTCMD_ADDR (node, \"ahb %d\", node->bits);\n\t\t\tbreak;\n\t\t}\n#undef HINTCMD_ADDR\n\t\tbreak;\n\tcase 'j':\n\t\tswitch (node->type) {\n\t\tcase HINT_NODE_ADDR: {\n\t\t\tconst RAnalAddrHintRecord *record;\n\t\t\tr_vector_foreach (node->addr_hints, record) {\n\t\t\t\tswitch (record->type) {\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_IMMBASE:\n\t\t\t\t\tpj_ki (pj, \"immbase\", record->immbase);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_JUMP:\n\t\t\t\t\tpj_kn (pj, \"jump\", record->jump);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_FAIL:\n\t\t\t\t\tpj_kn (pj, \"fail\", record->fail);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_STACKFRAME:\n\t\t\t\t\tpj_kn (pj, \"stackframe\", record->stackframe);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_PTR:\n\t\t\t\t\tpj_kn (pj, \"ptr\", record->ptr);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_NWORD:\n\t\t\t\t\tpj_ki (pj, \"nword\", record->nword);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_RET:\n\t\t\t\t\tpj_kn (pj, \"ret\", record->retval);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_NEW_BITS:\n\t\t\t\t\tpj_ki (pj, \"newbits\", record->newbits);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_SIZE:\n\t\t\t\t\tpj_kn (pj, \"size\", record->size);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_SYNTAX:\n\t\t\t\t\tpj_ks (pj, \"syntax\", record->syntax);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_OPTYPE: {\n\t\t\t\t\tconst char *type = r_anal_optype_to_string (record->optype);\n\t\t\t\t\tif (type) {\n\t\t\t\t\t\tpj_ks (pj, \"type\", type);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_OPCODE:\n\t\t\t\t\tpj_ks (pj, \"opcode\", record->opcode);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_TYPE_OFFSET:\n\t\t\t\t\tpj_ks (pj, \"offset\", record->type_offset);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_ESIL:\n\t\t\t\t\tpj_ks (pj, \"esil\", record->esil);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_HIGH:\n\t\t\t\t\tpj_kb (pj, \"high\", true);\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_ADDR_HINT_TYPE_VAL:\n\t\t\t\t\tpj_kn (pj, \"val\", record->val);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase HINT_NODE_ARCH:\n\t\t\tif (node->arch) {\n\t\t\t\tpj_ks (pj, \"arch\", node->arch);\n\t\t\t} else {\n\t\t\t\tpj_knull (pj, \"arch\");\n\t\t\t}\n\t\t\tbreak;\n\t\tcase HINT_NODE_BITS:\n\t\t\tpj_ki (pj, \"bits\", node->bits);\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tprint_hint_h_format (node);\n\t\tbreak;\n\t}\n}\n\nvoid hint_node_free(RBNode *node, void *user) {\n\tfree (container_of (node, HintNode, rb));\n}\n\nint hint_node_cmp(const void *incoming, const RBNode *in_tree, void *user) {\n\tut64 ia = *(ut64 *)incoming;\n\tut64 ta = container_of (in_tree, const HintNode, rb)->addr;\n\tif (ia < ta) {\n\t\treturn -1;\n\t} else if (ia > ta) {\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nbool print_addr_hint_cb(ut64 addr, const RVector/*<const RAnalAddrHintRecord>*/ *records, void *user) {\n\tHintNode *node = R_NEW0 (HintNode);\n\tif (!node) {\n\t\treturn false;\n\t}\n\tnode->addr = addr;\n\tnode->type = HINT_NODE_ADDR;\n\tnode->addr_hints = records;\n\tr_rbtree_insert (user, &addr, &node->rb, hint_node_cmp, NULL);\n\treturn true;\n}\n\nbool print_arch_hint_cb(ut64 addr, R_NULLABLE const char *arch, void *user) {\n\tHintNode *node = R_NEW0 (HintNode);\n\tif (!node) {\n\t\treturn false;\n\t}\n\tnode->addr = addr;\n\tnode->type = HINT_NODE_ARCH;\n\tnode->arch = arch;\n\tr_rbtree_insert (user, &addr, &node->rb, hint_node_cmp, NULL);\n\treturn true;\n}\n\nbool print_bits_hint_cb(ut64 addr, int bits, void *user) {\n\tHintNode *node = R_NEW0 (HintNode);\n\tif (!node) {\n\t\treturn false;\n\t}\n\tnode->addr = addr;\n\tnode->type = HINT_NODE_BITS;\n\tnode->bits = bits;\n\tr_rbtree_insert (user, &addr, &node->rb, hint_node_cmp, NULL);\n\treturn true;\n}\n\nstatic void print_hint_tree(RBTree tree, int mode) {\n#define END_ADDR if (mode == 'j') { pj_end (pj); } else if (mode != '*') { r_cons_newline (); }\n\tPJ *pj = NULL;\n\tif (mode == 'j') {\n\t\tpj = pj_new ();\n\t\tpj_a (pj);\n\t}\n\tRBIter it;\n\tHintNode *node;\n\tut64 last_addr = 0;\n\tbool in_addr = false;\n\tr_rbtree_foreach (tree, it, node, HintNode, rb) {\n\t\tif (!in_addr || last_addr != node->addr) {\n\t\t\tif (in_addr) {\n\t\t\t\tEND_ADDR\n\t\t\t}\n\t\t\tin_addr = true;\n\t\t\tlast_addr = node->addr;\n\t\t\tif (pj) {\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_kn (pj, \"addr\", node->addr);\n\t\t\t} else if (mode != '*') {\n\t\t\t\tr_cons_printf (\" 0x%08\"PFMT64x\" =>\", node->addr);\n\t\t\t}\n\t\t}\n\t\thint_node_print (node, mode, pj);\n\t}\n\tif (in_addr) {\n\t\tEND_ADDR\n\t}\n\tif (pj) {\n\t\tpj_end (pj);\n\t\tr_cons_printf (\"%s\\n\", pj_string (pj));\n\t\tpj_free (pj);\n\t}\n#undef END_ADDR\n}\n\nR_API void r_core_anal_hint_list(RAnal *a, int mode) {\n\tRBTree tree = NULL;\n\t// Collect all hints in the tree to sort them\n\tr_anal_arch_hints_foreach (a, print_arch_hint_cb, &tree);\n\tr_anal_bits_hints_foreach (a, print_bits_hint_cb, &tree);\n\tr_anal_addr_hints_foreach (a, print_addr_hint_cb, &tree);\n\tprint_hint_tree (tree, mode);\n\tr_rbtree_free (tree, hint_node_free, NULL);\n}\n\nR_API void r_core_anal_hint_print(RAnal* a, ut64 addr, int mode) {\n\tRBTree tree = NULL;\n\tut64 hint_addr = UT64_MAX;\n\tconst char *arch = r_anal_hint_arch_at(a, addr, &hint_addr);\n\tif (hint_addr != UT64_MAX) {\n\t\tprint_arch_hint_cb (hint_addr, arch, &tree);\n\t}\n\tint bits = r_anal_hint_bits_at (a, addr, &hint_addr);\n\tif (hint_addr != UT64_MAX) {\n\t\tprint_bits_hint_cb (hint_addr, bits, &tree);\n\t}\n\tconst RVector *addr_hints = r_anal_addr_hints_at (a, addr);\n\tif (addr_hints) {\n\t\tprint_addr_hint_cb (addr, addr_hints, &tree);\n\t}\n\tprint_hint_tree (tree, mode);\n\tr_rbtree_free (tree, hint_node_free, NULL);\n}\n\nstatic char *core_anal_graph_label(RCore *core, RAnalBlock *bb, int opts) {\n\tint is_html = r_cons_context ()->is_html;\n\tint is_json = opts & R_CORE_ANAL_JSON;\n\tchar cmd[1024], file[1024], *cmdstr = NULL, *filestr = NULL, *str = NULL;\n\tint line = 0, oline = 0, idx = 0;\n\tut64 at;\n\n\tif (opts & R_CORE_ANAL_GRAPHLINES) {\n\t\tfor (at = bb->addr; at < bb->addr + bb->size; at += 2) {\n\t\t\tr_bin_addr2line (core->bin, at, file, sizeof (file) - 1, &line);\n\t\t\tif (line != 0 && line != oline && strcmp (file, \"??\")) {\n\t\t\t\tfilestr = r_file_slurp_line (file, line, 0);\n\t\t\t\tif (filestr) {\n\t\t\t\t\tint flen = strlen (filestr);\n\t\t\t\t\tcmdstr = realloc (cmdstr, idx + flen + 8);\n\t\t\t\t\tmemcpy (cmdstr + idx, filestr, flen);\n\t\t\t\t\tidx += flen;\n\t\t\t\t\tif (is_json) {\n\t\t\t\t\t\tstrcpy (cmdstr + idx, \"\\\\n\");\n\t\t\t\t\t\tidx += 2;\n\t\t\t\t\t} else if (is_html) {\n\t\t\t\t\t\tstrcpy (cmdstr + idx, \"<br />\");\n\t\t\t\t\t\tidx += 6;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tstrcpy (cmdstr + idx, \"\\\\l\");\n\t\t\t\t\t\tidx += 2;\n\t\t\t\t\t}\n\t\t\t\t\tfree (filestr);\n\t\t\t\t}\n\t\t\t}\n\t\t\toline = line;\n\t\t}\n\t} else if (opts & R_CORE_ANAL_STAR) {\n\t\tsnprintf (cmd, sizeof (cmd), \"pdb %\"PFMT64u\" @ 0x%08\" PFMT64x, bb->size, bb->addr);\n\t\tstr = r_core_cmd_str (core, cmd);\n\t} else if (opts & R_CORE_ANAL_GRAPHBODY) {\n\t\tconst bool scrColor = r_config_get (core->config, \"scr.color\");\n\t\tconst bool scrUtf8 = r_config_get (core->config, \"scr.utf8\");\n\t\tr_config_set_i (core->config, \"scr.color\", COLOR_MODE_DISABLED);\n\t\tr_config_set (core->config, \"scr.utf8\", \"false\");\n\t\tsnprintf (cmd, sizeof (cmd), \"pD %\"PFMT64u\" @ 0x%08\" PFMT64x, bb->size, bb->addr);\n\t\tcmdstr = r_core_cmd_str (core, cmd);\n\t\tr_config_set_i (core->config, \"scr.color\", scrColor);\n\t\tr_config_set_i (core->config, \"scr.utf8\", scrUtf8);\n\t}\n\tif (cmdstr) {\n\t\tstr = r_str_escape_dot (cmdstr);\n\t\tfree (cmdstr);\n\t}\n\treturn str;\n}\n\nstatic char *palColorFor(const char *k) {\n\tif (!r_cons_singleton ()) {\n\t\treturn NULL;\n\t}\n\tRColor rcolor = r_cons_pal_get (k);\n\treturn r_cons_rgb_tostring (rcolor.r, rcolor.g, rcolor.b);\n}\n\nstatic void core_anal_color_curr_node(RCore *core, RAnalBlock *bbi) {\n\tbool color_current = r_config_get_i (core->config, \"graph.gv.current\");\n\tchar *pal_curr = palColorFor (\"graph.current\");\n\tbool current = r_anal_block_contains (bbi, core->offset);\n\n\tif (current && color_current) {\n\t\tr_cons_printf (\"\\t\\\"0x%08\"PFMT64x\"\\\" \", bbi->addr);\n\t\tr_cons_printf (\"\\t[fillcolor=%s style=filled shape=box];\\n\", pal_curr);\n\t}\n\tfree (pal_curr);\n}\n\nstatic int core_anal_graph_construct_edges(RCore *core, RAnalFunction *fcn, int opts, PJ *pj, Sdb *DB) {\n\tRAnalBlock *bbi;\n\tRListIter *iter;\n\tint is_keva = opts & R_CORE_ANAL_KEYVALUE;\n\tint is_star = opts & R_CORE_ANAL_STAR;\n\tint is_json = opts & R_CORE_ANAL_JSON;\n\tint is_html = r_cons_context ()->is_html;\n\tchar *pal_jump = palColorFor (\"graph.true\");\n\tchar *pal_fail = palColorFor (\"graph.false\");\n\tchar *pal_trfa = palColorFor (\"graph.trufae\");\n\tint nodes = 0;\n\tr_list_foreach (fcn->bbs, iter, bbi) {\n\t\tif (bbi->jump != UT64_MAX) {\n\t\t\tnodes++;\n\t\t\tif (is_keva) {\n\t\t\t\tchar key[128];\n\t\t\t\tchar val[128];\n\t\t\t\tsnprintf (key, sizeof (key), \"bb.0x%08\"PFMT64x\".to\", bbi->addr);\n\t\t\t\tif (bbi->fail != UT64_MAX) {\n\t\t\t\t\tsnprintf (val, sizeof (val), \"0x%08\"PFMT64x, bbi->jump);\n\t\t\t\t} else {\n\t\t\t\t\tsnprintf (val, sizeof (val), \"0x%08\"PFMT64x \",0x%08\"PFMT64x,\n\t\t\t\t\t\t\tbbi->jump, bbi->fail);\n\t\t\t\t}\n\t\t\t\t// bb.<addr>.to=<jump>,<fail>\n\t\t\t\tsdb_set (DB, key, val, 0);\n\t\t\t} else if (is_html) {\n\t\t\t\tr_cons_printf (\"<div class=\\\"connector _0x%08\"PFMT64x\" _0x%08\"PFMT64x\"\\\">\\n\"\n\t\t\t\t\t\t\"  <img class=\\\"connector-end\\\" src=\\\"img/arrow.gif\\\" /></div>\\n\",\n\t\t\t\t\t\tbbi->addr, bbi->jump);\n\t\t\t} else if (!is_json && !is_keva) {\n\t\t\t\tif (is_star) {\n\t\t\t\t\tchar *from = get_title (bbi->addr);\n\t\t\t\t\tchar *to = get_title (bbi->jump);\n\t\t\t\t\tr_cons_printf (\"age %s %s\\n\", from, to);\n\t\t\t\t\tfree (from);\n\t\t\t\t\tfree (to);\n\t\t\t\t} else {\n\t\t\t\t\tr_strf_buffer (128);\n\t\t\t\t\tconst char* edge_color = bbi->fail != -1 ? pal_jump : pal_trfa;\n\t\t\t\t\tif (sdb_const_get (core->sdb, r_strf (\"agraph.edge.0x%\"PFMT64x\"_0x%\"PFMT64x\".highlight\", bbi->addr, bbi->jump), 0)) {\n\t\t\t\t\t\tedge_color = \"cyan\";\n\t\t\t\t\t}\n\t\t\t\t\tr_cons_printf (\"        \\\"0x%08\"PFMT64x\"\\\" -> \\\"0x%08\"PFMT64x\"\\\" \"\n\t\t\t\t\t\t\t\"[color=\\\"%s\\\"];\\n\", bbi->addr, bbi->jump, edge_color);\n\t\t\t\t\tcore_anal_color_curr_node (core, bbi);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bbi->fail != -1) {\n\t\t\tnodes++;\n\t\t\tif (is_html) {\n\t\t\t\tr_cons_printf (\"<div class=\\\"connector _0x%08\"PFMT64x\" _0x%08\"PFMT64x\"\\\">\\n\"\n\t\t\t\t\t\t\"  <img class=\\\"connector-end\\\" src=\\\"img/arrow.gif\\\"/></div>\\n\",\n\t\t\t\t\t\tbbi->addr, bbi->fail);\n\t\t\t} else if (!is_keva && !is_json) {\n\t\t\t\tif (is_star) {\n\t\t\t\t\tchar *from = get_title (bbi->addr);\n\t\t\t\t\tchar *to = get_title (bbi->fail);\n\t\t\t\t\tr_cons_printf (\"age %s %s\\n\", from, to);\n\t\t\t\t\tfree(from);\n\t\t\t\t\tfree(to);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"        \\\"0x%08\"PFMT64x\"\\\" -> \\\"0x%08\"PFMT64x\"\\\" \"\n\t\t\t\t\t\t\t\t\t\"[color=\\\"%s\\\"];\\n\", bbi->addr, bbi->fail, pal_fail);\n\t\t\t\t\tcore_anal_color_curr_node (core, bbi);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bbi->switch_op) {\n\t\t\tRAnalCaseOp *caseop;\n\t\t\tRListIter *iter;\n\n\t\t\tif (bbi->fail != UT64_MAX) {\n\t\t\t\tif (is_html) {\n\t\t\t\t\tr_cons_printf (\"<div class=\\\"connector _0x%08\"PFMT64x\" _0x%08\"PFMT64x\"\\\">\\n\"\n\t\t\t\t\t\t\t\"  <img class=\\\"connector-end\\\" src=\\\"img/arrow.gif\\\"/></div>\\n\",\n\t\t\t\t\t\t\tbbi->addr, bbi->fail);\n\t\t\t\t} else if (!is_keva && !is_json) {\n\t\t\t\t\tif (is_star) {\n\t\t\t\t\t\tchar *from = get_title (bbi->addr);\n\t\t\t\t\t\tchar *to = get_title (bbi->fail);\n\t\t\t\t\t\tr_cons_printf (\"age %s %s\\n\", from, to);\n\t\t\t\t\t\tfree(from);\n\t\t\t\t\t\tfree(to);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"        \\\"0x%08\"PFMT64x\"\\\" -> \\\"0x%08\"PFMT64x\"\\\" \"\n\t\t\t\t\t\t\t\t\"[color=\\\"%s\\\"];\\n\", bbi->addr, bbi->fail, pal_fail);\n\t\t\t\t\t\tcore_anal_color_curr_node (core, bbi);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_list_foreach (bbi->switch_op->cases, iter, caseop) {\n\t\t\t\tnodes++;\n\t\t\t\tif (is_keva) {\n\t\t\t\t\tchar key[128];\n\t\t\t\t\tsnprintf (key, sizeof (key),\n\t\t\t\t\t\t\t\"bb.0x%08\"PFMT64x\".switch.%\"PFMT64d,\n\t\t\t\t\t\t\tbbi->addr, caseop->value);\n\t\t\t\t\tsdb_num_set (DB, key, caseop->jump, 0);\n\t\t\t\t\tsnprintf (key, sizeof (key),\n\t\t\t\t\t\t\t\"bb.0x%08\"PFMT64x\".switch\", bbi->addr);\n\t\t\t\t\t\t\tsdb_array_add_num (DB, key, caseop->value, 0);\n\t\t\t\t} else if (is_html) {\n\t\t\t\t\tr_cons_printf (\"<div class=\\\"connector _0x%08\" PFMT64x \" _0x%08\" PFMT64x \"\\\">\\n\"\n\t\t\t\t\t\t\t\"  <img class=\\\"connector-end\\\" src=\\\"img/arrow.gif\\\"/></div>\\n\",\n\t\t\t\t\t\t\tbbi->addr, caseop->addr);\n\t\t\t\t} else if (!is_json && !is_keva) {\n\t\t\t\t\tif (is_star) {\n\t\t\t\t\t\tchar *from = get_title (bbi->addr);\n\t\t\t\t\t\tchar *to = get_title (caseop->addr);\n\t\t\t\t\t\tr_cons_printf (\"age %s %s\\n\", from ,to);\n\t\t\t\t\t\tfree (from);\n\t\t\t\t\t\tfree (to);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"        \\\"0x%08\" PFMT64x \"\\\" -> \\\"0x%08\" PFMT64x \"\\\" \"\n\t\t\t\t\t\t\t\t\"[color=\\\"%s\\\"];\\n\",\n\t\t\t\t\t\t\t\tbbi->addr, caseop->addr, pal_trfa);\n\t\t\t\t\t\tcore_anal_color_curr_node (core, bbi);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfree(pal_jump);\n\tfree(pal_fail);\n\tfree(pal_trfa);\n\treturn nodes;\n}\n\nstatic int core_anal_graph_construct_nodes(RCore *core, RAnalFunction *fcn, int opts, PJ *pj, Sdb *DB) {\n\tRAnalBlock *bbi;\n\tRListIter *iter;\n\tint is_keva = opts & R_CORE_ANAL_KEYVALUE;\n\tint is_star = opts & R_CORE_ANAL_STAR;\n\tint is_json = opts & R_CORE_ANAL_JSON;\n\tint is_html = r_cons_context ()->is_html;\n\tint left = 300;\n\tint top = 0;\n\n\tint is_json_format_disasm = opts & R_CORE_ANAL_JSON_FORMAT_DISASM;\n\tchar *pal_curr = palColorFor (\"graph.current\");\n\tchar *pal_traced = palColorFor (\"graph.traced\");\n\tchar *pal_box4 = palColorFor (\"graph.box4\");\n\tconst char *font = r_config_get (core->config, \"graph.font\");\n\tbool color_current = r_config_get_i (core->config, \"graph.gv.current\");\n\tchar *str;\n\tint nodes = 0;\n\tr_list_foreach (fcn->bbs, iter, bbi) {\n\t\tif (is_keva) {\n\t\t\tchar key[128];\n\t\t\tsdb_array_push_num (DB, \"bbs\", bbi->addr, 0);\n\t\t\tsnprintf (key, sizeof (key), \"bb.0x%08\"PFMT64x\".size\", bbi->addr);\n\t\t\tsdb_num_set (DB, key, bbi->size, 0); // bb.<addr>.size=<num>\n\t\t} else if (is_json) {\n\t\t\tRDebugTracepoint *t = r_debug_trace_get (core->dbg, bbi->addr);\n\t\t\tpj_o (pj);\n\t\t\tpj_kn (pj, \"offset\", bbi->addr);\n\t\t\tpj_kn (pj, \"size\", bbi->size);\n\t\t\tif (bbi->jump != UT64_MAX) {\n\t\t\t\tpj_kn (pj, \"jump\", bbi->jump);\n\t\t\t}\n\t\t\tif (bbi->fail != -1) {\n\t\t\t\tpj_kn (pj, \"fail\", bbi->fail);\n\t\t\t}\n\t\t\tif (bbi->switch_op) {\n\t\t\t\tRAnalSwitchOp *op = bbi->switch_op;\n\t\t\t\tpj_k (pj, \"switchop\");\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_kn (pj, \"offset\", op->addr);\n\t\t\t\tpj_kn (pj, \"defval\", op->def_val);\n\t\t\t\tpj_kn (pj, \"maxval\", op->max_val);\n\t\t\t\tpj_kn (pj, \"minval\", op->min_val);\n\t\t\t\tpj_k (pj, \"cases\");\n\t\t\t\tpj_a (pj);\n\t\t\t\tRAnalCaseOp *case_op;\n\t\t\t\tRListIter *case_iter;\n\t\t\t\tr_list_foreach (op->cases, case_iter, case_op) {\n\t\t\t\t\tpj_o (pj);\n\t\t\t\t\tpj_kn (pj, \"offset\", case_op->addr);\n\t\t\t\t\tpj_kn (pj, \"value\", case_op->value);\n\t\t\t\t\tpj_kn (pj, \"jump\", case_op->jump);\n\t\t\t\t\tpj_end (pj);\n\t\t\t\t}\n\t\t\t\tpj_end (pj);\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t\tif (t) {\n\t\t\t\tpj_k (pj, \"trace\");\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_ki (pj, \"count\", t->count);\n\t\t\t\tpj_ki (pj, \"times\", t->times);\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t\tif (bbi->color.r || bbi->color.g || bbi->color.b) {\n\t\t\t\tchar *s = r_cons_rgb_tostring (bbi->color.r, bbi->color.g, bbi->color.b);\n\t\t\t\tpj_ks (pj, \"color\", s);\n\t\t\t\tfree (s);\n\t\t\t}\n\t\t\tpj_k (pj, \"ops\");\n\t\t\tpj_a (pj);\n\t\t\tut8 *buf = malloc (bbi->size);\n\t\t\tif (buf) {\n\t\t\t\tr_io_read_at (core->io, bbi->addr, buf, bbi->size);\n\t\t\t\tif (is_json_format_disasm) {\n\t\t\t\t\tr_core_print_disasm (core, bbi->addr, buf, bbi->size, bbi->size, 0, NULL, true, true, pj, NULL);\n\t\t\t\t} else {\n\t\t\t\t\tr_core_print_disasm_json (core, bbi->addr, buf, bbi->size, 0, pj);\n\t\t\t\t}\n\t\t\t\tfree (buf);\n\t\t\t} else {\n\t\t\t\teprintf (\"cannot allocate %\"PFMT64u\" byte(s)\\n\", bbi->size);\n\t\t\t}\n\t\t\tpj_end (pj);\n\t\t\tpj_end (pj);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((str = core_anal_graph_label (core, bbi, opts))) {\n\t\t\tif (opts & R_CORE_ANAL_GRAPHDIFF) {\n\t\t\t\tconst char *difftype = bbi->diff? (\\\n\t\t\t\tbbi->diff->type==R_ANAL_DIFF_TYPE_MATCH? \"lightgray\":\n\t\t\t\tbbi->diff->type==R_ANAL_DIFF_TYPE_UNMATCH? \"yellow\": \"red\"): \"orange\";\n\t\t\t\tconst char *diffname = bbi->diff? (\\\n\t\t\t\tbbi->diff->type==R_ANAL_DIFF_TYPE_MATCH? \"match\":\n\t\t\t\tbbi->diff->type==R_ANAL_DIFF_TYPE_UNMATCH? \"unmatch\": \"new\"): \"unk\";\n\t\t\t\tif (is_keva) {\n\t\t\t\t\tsdb_set (DB, \"diff\", diffname, 0);\n\t\t\t\t\tsdb_set (DB, \"label\", str, 0);\n\t\t\t\t} else if (!is_json) {\n\t\t\t\t\tnodes++;\n\t\t\t\t\tRConfigHold *hc = r_config_hold_new (core->config);\n\t\t\t\t\tr_config_hold (hc, \"scr.color\", \"scr.utf8\", \"asm.offset\", \"asm.lines\",\n\t\t\t\t\t\t\t\"asm.cmt.right\", \"asm.lines.fcn\", \"asm.bytes\", NULL);\n\t\t\t\t\tRDiff *d = r_diff_new ();\n\t\t\t\t\tr_config_set_i (core->config, \"scr.utf8\", 0);\n\t\t\t\t\tr_config_set_i (core->config, \"asm.offset\", 0);\n\t\t\t\t\tr_config_set_i (core->config, \"asm.lines\", 0);\n\t\t\t\t\tr_config_set_i (core->config, \"asm.cmt.right\", 0);\n\t\t\t\t\tr_config_set_i (core->config, \"asm.lines.fcn\", 0);\n\t\t\t\t\tr_config_set_i (core->config, \"asm.bytes\", 0);\n\t\t\t\t\tif (!is_star) {\n\t\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", 0);\t// disable color for dot\n\t\t\t\t\t}\n\n\t\t\t\t\tif (bbi->diff && bbi->diff->type != R_ANAL_DIFF_TYPE_MATCH && core->c2) {\n\t\t\t\t\t\tRCore *c = core->c2;\n\t\t\t\t\t\tRConfig *oc = c->config;\n\t\t\t\t\t\tchar *str = r_core_cmd_strf (core, \"pdb @ 0x%08\"PFMT64x, bbi->addr);\n\t\t\t\t\t\tc->config = core->config;\n\t\t\t\t\t\t// XXX. the bbi->addr doesnt needs to be in the same address in core2\n\t\t\t\t\t\tchar *str2 = r_core_cmd_strf (c, \"pdb @ 0x%08\"PFMT64x, bbi->diff->addr);\n\t\t\t\t\t\tchar *diffstr = r_diff_buffers_to_string (d,\n\t\t\t\t\t\t\t\t(const ut8*)str, strlen (str),\n\t\t\t\t\t\t\t\t(const ut8*)str2, strlen (str2));\n\n\t\t\t\t\t\tif (diffstr) {\n\t\t\t\t\t\t\tchar *nl = strchr (diffstr, '\\n');\n\t\t\t\t\t\t\tif (nl) {\n\t\t\t\t\t\t\t\tnl = strchr (nl + 1, '\\n');\n\t\t\t\t\t\t\t\tif (nl) {\n\t\t\t\t\t\t\t\t\tnl = strchr (nl + 1, '\\n');\n\t\t\t\t\t\t\t\t\tif (nl) {\n\t\t\t\t\t\t\t\t\t\tr_str_cpy (diffstr, nl + 1);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (is_star) {\n\t\t\t\t\t\t\tchar *title = get_title (bbi->addr);\n\t\t\t\t\t\t\tchar *body_b64 = r_base64_encode_dyn (diffstr, -1);\n\t\t\t\t\t\t\tif (!title  || !body_b64) {\n\t\t\t\t\t\t\t\tfree (body_b64);\n\t\t\t\t\t\t\t\tfree (title);\n\t\t\t\t\t\t\t\tr_diff_free (d);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbody_b64 = r_str_prepend (body_b64, \"base64:\");\n\t\t\t\t\t\t\tr_cons_printf (\"agn %s %s %d\\n\", title, body_b64, bbi->diff->type);\n\t\t\t\t\t\t\tfree (body_b64);\n\t\t\t\t\t\t\tfree (title);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tdiffstr = r_str_replace (diffstr, \"\\n\", \"\\\\l\", 1);\n\t\t\t\t\t\t\tdiffstr = r_str_replace (diffstr, \"\\\"\", \"'\", 1);\n\t\t\t\t\t\t\tr_cons_printf(\" \\\"0x%08\"PFMT64x\"\\\" [fillcolor=\\\"%s\\\",\"\n\t\t\t\t\t\t\t\"color=\\\"black\\\", fontname=\\\"%s\\\",\"\n\t\t\t\t\t\t\t\" label=\\\"%s\\\", URL=\\\"%s/0x%08\"PFMT64x\"\\\"]\\n\",\n\t\t\t\t\t\t\tbbi->addr, difftype, font, diffstr, fcn->name,\n\t\t\t\t\t\t\tbbi->addr);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfree (diffstr);\n\t\t\t\t\t\tc->config = oc;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (is_star) {\n\t\t\t\t\t\t\tchar *title = get_title (bbi->addr);\n\t\t\t\t\t\t\tchar *body_b64 = r_base64_encode_dyn (str, -1);\n\t\t\t\t\t\t\tint color = (bbi && bbi->diff) ? bbi->diff->type : 0;\n\t\t\t\t\t\t\tif (!title  || !body_b64) {\n\t\t\t\t\t\t\t\tfree (body_b64);\n\t\t\t\t\t\t\t\tfree (title);\n\t\t\t\t\t\t\t\tr_diff_free (d);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbody_b64 = r_str_prepend (body_b64, \"base64:\");\n\t\t\t\t\t\t\tr_cons_printf (\"agn %s %s %d\\n\", title, body_b64, color);\n\t\t\t\t\t\t\tfree (body_b64);\n\t\t\t\t\t\t\tfree (title);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tr_cons_printf(\" \\\"0x%08\"PFMT64x\"\\\" [fillcolor=\\\"%s\\\",\"\n\t\t\t\t\t\t\t\t\t\"color=\\\"black\\\", fontname=\\\"%s\\\",\"\n\t\t\t\t\t\t\t\t\t\" label=\\\"%s\\\", URL=\\\"%s/0x%08\"PFMT64x\"\\\"]\\n\",\n\t\t\t\t\t\t\t\t\tbbi->addr, difftype, font, str, fcn->name, bbi->addr);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr_diff_free (d);\n\t\t\t\t\tr_config_set_i (core->config, \"scr.color\", 1);\n\t\t\t\t\tr_config_hold_free (hc);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (is_html) {\n\t\t\t\t\t\tnodes++;\n\t\t\t\t\t\tr_cons_printf (\"<p class=\\\"block draggable\\\" style=\\\"\"\n\t\t\t\t\t\t\t\t\t\t\t\t\"top: %dpx; left: %dpx; width: 400px;\\\" id=\\\"\"\n\t\t\t\t\t\t\t\t\t\t\t\t\"_0x%08\"PFMT64x\"\\\">\\n%s</p>\\n\",\n\t\t\t\t\t\t\t\t\t\t\t\ttop, left, bbi->addr, str);\n\t\t\t\t\t\tleft = left? 0: 600;\n\t\t\t\t\t\tif (!left) {\n\t\t\t\t\t\t\t\ttop += 250;\n\t\t\t\t\t\t}\n\t\t\t\t} else if (!is_json && !is_keva) {\n\t\t\t\t\tbool current = r_anal_block_contains (bbi, core->offset);\n\t\t\t\t\tconst char *label_color = bbi->traced\n\t\t\t\t\t\t\t? pal_traced\n\t\t\t\t\t\t\t: (current && color_current)\n\t\t\t\t\t\t\t? pal_curr\n\t\t\t\t\t\t\t: pal_box4;\n\t\t\t\t\tconst char *fill_color = ((current && color_current) || label_color == pal_traced)? pal_traced: \"white\";\n\t\t\t\t\tnodes++;\n\t\t\t\t\tif (is_star) {\n\t\t\t\t\t\tchar *title = get_title (bbi->addr);\n\t\t\t\t\t\tchar *body_b64 = r_base64_encode_dyn (str, -1);\n\t\t\t\t\t\tint color = (bbi && bbi->diff) ? bbi->diff->type : 0;\n\t\t\t\t\t\tif (!title  || !body_b64) {\n\t\t\t\t\t\t\t\tfree (body_b64);\n\t\t\t\t\t\t\t\tfree (title);\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbody_b64 = r_str_prepend (body_b64, \"base64:\");\n\t\t\t\t\t\tr_cons_printf (\"agn %s %s %d\\n\", title, body_b64, color);\n\t\t\t\t\t\tfree (body_b64);\n\t\t\t\t\t\tfree (title);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_cons_printf (\"\\t\\\"0x%08\"PFMT64x\"\\\" [\"\n\t\t\t\t\t\t\t\t\"URL=\\\"%s/0x%08\"PFMT64x\"\\\", fillcolor=\\\"%s\\\",\"\n\t\t\t\t\t\t\t\t\"color=\\\"%s\\\", fontname=\\\"%s\\\",\"\n\t\t\t\t\t\t\t\t\"label=\\\"%s\\\"]\\n\",\n\t\t\t\t\t\t\t\tbbi->addr, fcn->name, bbi->addr,\n\t\t\t\t\t\t\t\tfill_color, label_color, font, str);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfree (str);\n\t\t}\n\t}\n\treturn nodes;\n}\n\nstatic int core_anal_graph_nodes(RCore *core, RAnalFunction *fcn, int opts, PJ *pj) {\n\tint is_json = opts & R_CORE_ANAL_JSON;\n\tint is_keva = opts & R_CORE_ANAL_KEYVALUE;\n\tint nodes = 0;\n\tSdb *DB = NULL;\n\tchar *pal_jump = palColorFor (\"graph.true\");\n\tchar *pal_fail = palColorFor (\"graph.false\");\n\tchar *pal_trfa = palColorFor (\"graph.trufae\");\n\tchar *pal_curr = palColorFor (\"graph.current\");\n\tchar *pal_traced = palColorFor (\"graph.traced\");\n\tchar *pal_box4 = palColorFor (\"graph.box4\");\n\tif (!fcn || !fcn->bbs) {\n\t\teprintf (\"No fcn\\n\");\n\t\tfree (pal_jump);\n\t\tfree (pal_fail);\n\t\tfree (pal_trfa);\n\t\tfree (pal_curr);\n\t\tfree (pal_traced);\n\t\tfree (pal_box4);\n\t\treturn -1;\n\t}\n\n\tif (is_keva) {\n\t\tchar ns[64];\n\t\tDB = sdb_ns (core->anal->sdb, \"graph\", 1);\n\t\tsnprintf (ns, sizeof (ns), \"fcn.0x%08\"PFMT64x, fcn->addr);\n\t\tDB = sdb_ns (DB, ns, 1);\n\t}\n\n\tif (is_keva) {\n\t\tchar *ename = sdb_encode ((const ut8*)fcn->name, -1);\n\t\tsdb_set (DB, \"name\", fcn->name, 0);\n\t\tsdb_set (DB, \"ename\", ename, 0);\n\t\tfree (ename);\n\t\tsdb_num_set (DB, \"size\", r_anal_function_linear_size (fcn), 0);\n\t\tif (fcn->maxstack > 0) {\n\t\t\tsdb_num_set (DB, \"stack\", fcn->maxstack, 0);\n\t\t}\n\t\tsdb_set (DB, \"pos\", \"0,0\", 0); // needs to run layout\n\t\tsdb_set (DB, \"type\", r_anal_functiontype_tostring (fcn->type), 0);\n\t} else if (is_json) {\n\t\t// TODO: show vars, refs and xrefs\n\t\tchar *fcn_name_escaped = r_str_escape_utf8_for_json (fcn->name, -1);\n\t\tpj_o (pj);\n\t\tpj_ks (pj, \"name\", r_str_getf (fcn_name_escaped));\n\t\tfree (fcn_name_escaped);\n\t\tpj_kn (pj, \"offset\", fcn->addr);\n\t\tpj_ki (pj, \"ninstr\", fcn->ninstr);\n\t\tpj_ki (pj, \"nargs\", r_anal_var_count_args (fcn));\n\t\tpj_ki (pj, \"nlocals\", r_anal_var_count_locals (fcn));\n\t\tpj_kn (pj, \"size\", r_anal_function_linear_size (fcn));\n\t\tpj_ki (pj, \"stack\", fcn->maxstack);\n\t\tpj_ks (pj, \"type\", r_anal_functiontype_tostring (fcn->type));\n\t\tpj_k (pj, \"blocks\");\n\t\tpj_a (pj);\n\t}\n\tnodes += core_anal_graph_construct_nodes (core, fcn, opts, pj, DB);\n\tnodes += core_anal_graph_construct_edges (core, fcn, opts, pj, DB);\n\tif (is_json) {\n\t\tpj_end (pj);\n\t\tpj_end (pj);\n\t}\n\tfree (pal_jump);\n\tfree (pal_fail);\n\tfree (pal_trfa);\n\tfree (pal_curr);\n\tfree (pal_traced);\n\tfree (pal_box4);\n\treturn nodes;\n}\n\n/* seek basic block that contains address addr or just addr if there's no such\n * basic block */\nR_API bool r_core_anal_bb_seek(RCore *core, ut64 addr) {\n\tut64 bbaddr = r_anal_get_bbaddr (core->anal, addr);\n\tif (bbaddr != UT64_MAX) {\n\t\tr_core_seek (core, bbaddr, false);\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nR_API int r_core_anal_esil_fcn(RCore *core, ut64 at, ut64 from, int reftype, int depth) {\n\tconst char *esil;\n\teprintf (\"TODO\\n\");\n\twhile (1) {\n\t\t// TODO: Implement the proper logic for doing esil analysis\n\t\tRAnalOp *op = r_core_anal_op (core, at, R_ANAL_OP_MASK_ESIL);\n\t\tif (!op) {\n\t\t\tbreak;\n\t\t}\n\t\tesil = R_STRBUF_SAFEGET (&op->esil);\n\t\teprintf (\"0x%08\"PFMT64x\" %d %s\\n\", at, op->size, esil);\n\t\t// at += op->size;\n\t\t// esilIsRet()\n\t\t// esilIsCall()\n\t\t// esilIsJmp()\n\t\tr_anal_op_free (op);\n\t\tbreak;\n\t}\n\treturn 0;\n}\n\nstatic int find_sym_flag(const void *a1, const void *a2) {\n\tconst RFlagItem *f = (const RFlagItem *)a2;\n\treturn f->space && !strcmp (f->space->name, R_FLAGS_FS_SYMBOLS)? 0: 1;\n}\n\nstatic bool is_skippable_addr(RCore *core, ut64 addr) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\tif (!fcn) {\n\t\treturn false;\n\t}\n\tif (fcn->addr == addr) {\n\t\treturn true;\n\t}\n\tconst RList *flags = r_flag_get_list (core->flags, addr);\n\treturn !(flags && r_list_find (flags, fcn, find_sym_flag));\n}\n\n// XXX: This function takes sometimes forever\n/* analyze a RAnalFunction at the address 'at'.\n * If the function has been already analyzed, it adds a\n * reference to that fcn */\nR_API bool r_core_anal_fcn(RCore *core, ut64 at, ut64 from, int reftype, int depth) {\n\tif (depth < 0) {\n\t\tif (core->anal->verbose) {\n\t\t\teprintf (\"Message: Early deepness at 0x%08\"PFMT64x\"\\n\", at);\n\t\t}\n\t\treturn false;\n\t}\n\tif (from == UT64_MAX && is_skippable_addr (core, at)) {\n\t\tif (core->anal->verbose) {\n\t\t\teprintf (\"Message: Invalid address for function 0x%08\"PFMT64x\"\\n\", at);\n\t\t}\n\t\treturn false;\n\t}\n\n\tconst bool use_esil = r_config_get_i (core->config, \"anal.esil\");\n\tRAnalFunction *fcn;\n\n\t//update bits based on the core->offset otherwise we could have the\n\t//last value set and blow everything up\n\tr_core_seek_arch_bits (core, at);\n\n\tif (core->io->va) {\n\t\tif (!r_io_is_valid_offset (core->io, at, !core->anal->opt.noncode)) {\n\t\t\tif (core->anal->verbose) {\n\t\t\t\teprintf (\"Warning: Address not mapped or not executable at 0x%08\"PFMT64x\"\\n\", at);\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (r_config_get_i (core->config, \"anal.a2f\")) {\n\t\tr_core_cmd0 (core, \".a2f\");\n\t\treturn 0;\n\t}\n\tif (use_esil) {\n\t\treturn r_core_anal_esil_fcn (core, at, from, reftype, depth);\n\t}\n\n\tif ((from != UT64_MAX && !at) || at == UT64_MAX) {\n\t\teprintf (\"Invalid address from 0x%08\"PFMT64x\"\\n\", from);\n\t\treturn false;\n\t}\n\tif (r_cons_is_breaked ()) {\n\t\treturn false;\n\t}\n\tfcn = r_anal_get_fcn_in (core->anal, at, 0);\n\tif (fcn) {\n\t\tif (fcn->addr == at) {\n\t\t\t// if the function was already analyzed as a \"loc.\",\n\t\t\t// convert it to function and rename it to \"fcn.\",\n\t\t\t// because we found a call to this address\n\t\t\tif (reftype == R_ANAL_REF_TYPE_CALL && fcn->type == R_ANAL_FCN_TYPE_LOC) {\n\t\t\t\tfunction_rename (core->flags, fcn);\n\t\t\t}\n\t\t\treturn 0;  // already analyzed function\n\t\t}\n\t\tif (r_anal_function_contains (fcn, from)) { // inner function\n\t\t\tRList *l = r_anal_xrefs_get (core->anal, from);\n\t\t\tif (l && !r_list_empty (l)) {\n\t\t\t\tr_list_free (l);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tr_list_free (l);\n\n\t\t\t// we should analyze and add code ref otherwise aaa != aac\n\t\t\tif (from != UT64_MAX) {\n\t\t\t\tr_anal_xrefs_set (core->anal, from, at, reftype);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\tif (__core_anal_fcn (core, at, from, reftype, depth - 1)) {\n\t\t// split function if overlaps\n\t\tif (fcn) {\n\t\t\tr_anal_function_resize (fcn, at - fcn->addr);\n\t\t}\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n/* if addr is 0, remove all functions\n * otherwise remove the function addr falls into */\nR_API int r_core_anal_fcn_clean(RCore *core, ut64 addr) {\n\tRAnalFunction *fcni;\n\tRListIter *iter, *iter_tmp;\n\n\tif (!addr) {\n\t\tr_list_purge (core->anal->fcns);\n\t\tif (!(core->anal->fcns = r_list_new ())) {\n\t\t\treturn false;\n\t\t}\n\t} else {\n\t\tr_list_foreach_safe (core->anal->fcns, iter, iter_tmp, fcni) {\n\t\t\tif (r_anal_function_contains (fcni, addr)) {\n\t\t\t\tr_anal_function_delete (fcni);\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nR_API int r_core_print_bb_custom(RCore *core, RAnalFunction *fcn) {\n\tRAnalBlock *bb;\n\tRListIter *iter;\n\tif (!fcn) {\n\t\treturn false;\n\t}\n\n\tRConfigHold *hc = r_config_hold_new (core->config);\n\tr_config_hold (hc, \"scr.color\", \"scr.utf8\", \"asm.marks\", \"asm.offset\", \"asm.lines\",\n\t  \"asm.cmt.right\", \"asm.cmt.col\", \"asm.lines.fcn\", \"asm.bytes\", NULL);\n\t/*r_config_set_i (core->config, \"scr.color\", 0);*/\n\tr_config_set_i (core->config, \"scr.utf8\", 0);\n\tr_config_set_i (core->config, \"asm.marks\", 0);\n\tr_config_set_i (core->config, \"asm.offset\", 0);\n\tr_config_set_i (core->config, \"asm.lines\", 0);\n\tr_config_set_i (core->config, \"asm.cmt.right\", 0);\n\tr_config_set_i (core->config, \"asm.cmt.col\", 0);\n\tr_config_set_i (core->config, \"asm.lines.fcn\", 0);\n\tr_config_set_i (core->config, \"asm.bytes\", 0);\n\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tif (bb->addr == UT64_MAX) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *title = get_title (bb->addr);\n\t\tchar *body = r_core_cmd_strf (core, \"pdb @ 0x%08\"PFMT64x, bb->addr);\n\t\tchar *body_b64 = r_base64_encode_dyn (body, -1);\n\t\tif (!title || !body || !body_b64) {\n\t\t\tfree (body_b64);\n\t\t\tfree (body);\n\t\t\tfree (title);\n\t\t\tr_config_hold_restore (hc);\n\t\t\tr_config_hold_free (hc);\n\t\t\treturn false;\n\t\t}\n\t\tbody_b64 = r_str_prepend (body_b64, \"base64:\");\n\t\tr_cons_printf (\"agn %s %s\\n\", title, body_b64);\n\t\tfree (body);\n\t\tfree (body_b64);\n\t\tfree (title);\n\t}\n\n\tr_config_hold_restore (hc);\n\tr_config_hold_free (hc);\n\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tif (bb->addr == UT64_MAX) {\n\t\t\tcontinue;\n\t\t}\n\t\tchar *u = get_title (bb->addr), *v = NULL;\n\t\tif (bb->jump != UT64_MAX) {\n\t\t\tv = get_title (bb->jump);\n\t\t\tr_cons_printf (\"age %s %s\\n\", u, v);\n\t\t\tfree (v);\n\t\t}\n\t\tif (bb->fail != UT64_MAX) {\n\t\t\tv = get_title (bb->fail);\n\t\t\tr_cons_printf (\"age %s %s\\n\", u, v);\n\t\t\tfree (v);\n\t\t}\n\t\tif (bb->switch_op) {\n\t\t\tRListIter *it;\n\t\t\tRAnalCaseOp *cop;\n\t\t\tr_list_foreach (bb->switch_op->cases, it, cop) {\n\t\t\t\tv = get_title (cop->addr);\n\t\t\t\tr_cons_printf (\"age %s %s\\n\", u, v);\n\t\t\t\tfree (v);\n\t\t\t}\n\t\t}\n\t\tfree (u);\n\t}\n\treturn true;\n}\n\n#define USE_ID 1\nR_API int r_core_print_bb_gml(RCore *core, RAnalFunction *fcn) {\n\tRAnalBlock *bb;\n\tRListIter *iter;\n\tif (!fcn) {\n\t\treturn false;\n\t}\n\tint id = 0;\n\tHtUUOptions opt = { 0 };\n\tHtUU *ht = ht_uu_new_opt (&opt);\n\n\tr_cons_printf (\"graph\\n[\\n\" \"hierarchic 1\\n\" \"label \\\"\\\"\\n\" \"directed 1\\n\");\n\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tRFlagItem *flag = r_flag_get_i (core->flags, bb->addr);\n\t\tchar *msg = flag? strdup (flag->name): r_str_newf (\"0x%08\"PFMT64x, bb->addr);\n\t\t// TODO char *str = r_str_escape_dot (msg);\n#if USE_ID\n\t\tht_uu_insert (ht, bb->addr, id);\n\t\tr_cons_printf (\"  node [\\n\"\n\t\t\t\t\"    id  %d\\n\"\n\t\t\t\t\"    label  \\\"%s\\\"\\n\"\n\t\t\t\t\"  ]\\n\", id, msg);\n\t\tid++;\n#else\n\t\tr_cons_printf (\"  node [\\n\"\n\t\t\t\t\"    id  %\"PFMT64d\"\\n\"\n\t\t\t\t\"    label  \\\"%s\\\"\\n\"\n\t\t\t\t\"  ]\\n\", bb->addr, msg);\n#endif\n\t\tfree (msg);\n\t}\n\n\tr_list_foreach (fcn->bbs, iter, bb) {\n\t\tif (bb->addr == UT64_MAX) {\n\t\t\tcontinue;\n\t\t}\n\n#if USE_ID\n\t\tif (bb->jump != UT64_MAX) {\n\t\t\tbool found;\n\t\t\tint i = ht_uu_find (ht, bb->addr, &found);\n\t\t\tif (found) {\n\t\t\t\tint i2 = ht_uu_find (ht, bb->jump, &found);\n\t\t\t\tif (found) {\n\t\t\t\t\tr_cons_printf (\"  edge [\\n\"\n\t\t\t\t\t\t\t\"    source  %d\\n\"\n\t\t\t\t\t\t\t\"    target  %d\\n\"\n\t\t\t\t\t\t\t\"  ]\\n\", i, i2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bb->fail != UT64_MAX) {\n\t\t\tbool found;\n\t\t\tint i = ht_uu_find (ht, bb->addr, &found);\n\t\t\tif (found) {\n\t\t\t\tint i2 = ht_uu_find (ht, bb->fail, &found);\n\t\t\t\tif (found) {\n\t\t\t\t\tr_cons_printf (\"  edge [\\n\"\n\t\t\t\t\t\t\"    source  %d\\n\"\n\t\t\t\t\t\t\"    target  %d\\n\"\n\t\t\t\t\t\t\"  ]\\n\", i, i2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (bb->switch_op) {\n\t\t\tRListIter *it;\n\t\t\tRAnalCaseOp *cop;\n\t\t\tr_list_foreach (bb->switch_op->cases, it, cop) {\n\t\t\t\tbool found;\n\t\t\t\tint i = ht_uu_find (ht, bb->addr, &found);\n\t\t\t\tif (found) {\n\t\t\t\t\tint i2 = ht_uu_find (ht, cop->addr, &found);\n\t\t\t\t\tif (found) {\n\t\t\t\t\t\tr_cons_printf (\"  edge [\\n\"\n\t\t\t\t\t\t\t\t\"    source  %d\\n\"\n\t\t\t\t\t\t\t\t\"    target  %d\\n\"\n\t\t\t\t\t\t\t\t\"  ]\\n\", i, i2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n#else\n\t\tif (bb->jump != UT64_MAX) {\n\t\t\tr_cons_printf (\"  edge [\\n\"\n\t\t\t\t\"    source  %\"PFMT64d\"\\n\"\n\t\t\t\t\"    target  %\"PFMT64d\"\\n\"\n\t\t\t\t\"  ]\\n\", bb->addr, bb->jump\n\t\t\t\t);\n\t\t}\n\t\tif (bb->fail != UT64_MAX) {\n\t\t\tr_cons_printf (\"  edge [\\n\"\n\t\t\t\t\"    source  %\"PFMT64d\"\\n\"\n\t\t\t\t\"    target  %\"PFMT64d\"\\n\"\n\t\t\t\t\"  ]\\n\", bb->addr, bb->fail\n\t\t\t\t);\n\t\t}\n\t\tif (bb->switch_op) {\n\t\t\tRListIter *it;\n\t\t\tRAnalCaseOp *cop;\n\t\t\tr_list_foreach (bb->switch_op->cases, it, cop) {\n\t\t\t\tr_cons_printf (\"  edge [\\n\"\n\t\t\t\t\t\"    source  %\"PFMT64d\"\\n\"\n\t\t\t\t\t\"    target  %\"PFMT64d\"\\n\"\n\t\t\t\t\t\"  ]\\n\", bb->addr, cop->addr\n\t\t\t\t\t);\n\t\t\t}\n\t\t}\n#endif\n\t}\n\tr_cons_printf (\"]\\n\");\n\tht_uu_free (ht);\n\treturn true;\n}\n\nR_API void r_core_anal_datarefs(RCore *core, ut64 addr) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, -1);\n\tif (fcn) {\n\t\tbool found = false;\n\t\tconst char *me = fcn->name;\n\t\tRListIter *iter;\n\t\tRAnalRef *ref;\n\t\tRList *refs = r_anal_function_get_refs (fcn);\n\t\tr_list_foreach (refs, iter, ref) {\n\t\t\tRBinObject *obj = r_bin_cur_object (core->bin);\n\t\t\tRBinSection *binsec = r_bin_get_section_at (obj, ref->addr, true);\n\t\t\tif (binsec && binsec->is_data) {\n\t\t\t\tif (!found) {\n\t\t\t\t\tr_cons_printf (\"agn %s\\n\", me);\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t\tRFlagItem *item = r_flag_get_i (core->flags, ref->addr);\n\t\t\t\tr_strf_buffer (32);\n\t\t\t\tconst char *dst = item? item->name: r_strf (\"0x%08\"PFMT64x, ref->addr);\n\t\t\t\tr_cons_printf (\"agn %s\\n\", dst);\n\t\t\t\tr_cons_printf (\"age %s %s\\n\", me, dst);\n\t\t\t}\n\t\t}\n\t\tr_list_free (refs);\n\t} else {\n\t\teprintf (\"Not in a function. Use 'df' to define it.\\n\");\n\t}\n}\n\nR_API void r_core_anal_coderefs(RCore *core, ut64 addr) {\n\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, -1);\n\tif (fcn) {\n\t\tconst char *me = fcn->name;\n\t\tRListIter *iter;\n\t\tRAnalRef *ref;\n\t\tRList *refs = r_anal_function_get_refs (fcn);\n\t\tr_cons_printf (\"agn %s\\n\", me);\n\t\tr_list_foreach (refs, iter, ref) {\n\t\t\tr_strf_buffer (32);\n\t\t\tRFlagItem *item = r_flag_get_i (core->flags, ref->addr);\n\t\t\tconst char *dst = item? item->name: r_strf (\"0x%08\"PFMT64x, ref->addr);\n\t\t\tr_cons_printf (\"agn %s\\n\", dst);\n\t\t\tr_cons_printf (\"age %s %s\\n\", me, dst);\n\t\t}\n\t\tr_list_free (refs);\n\t} else {\n\t\teprintf(\"Not in a function. Use 'df' to define it.\\n\");\n\t}\n}\n\nstatic void add_single_addr_xrefs(RCore *core, ut64 addr, RGraph *graph) {\n\tr_return_if_fail (graph);\n\tRFlagItem *f = r_flag_get_at (core->flags, addr, false);\n\tchar *me = (f && f->offset == addr)\n\t\t? r_str_new (f->name)\n\t\t: r_str_newf (\"0x%\" PFMT64x, addr);\n\n\tRGraphNode *curr_node = r_graph_add_node_info (graph, me, NULL, addr);\n\tR_FREE (me);\n\tif (!curr_node) {\n\t\treturn;\n\t}\n\tRListIter *iter;\n\tRAnalRef *ref;\n\tRList *list = r_anal_xrefs_get (core->anal, addr);\n\tr_list_foreach (list, iter, ref) {\n\t\tRFlagItem *item = r_flag_get_i (core->flags, ref->addr);\n\t\tchar *src = item? r_str_new (item->name): r_str_newf (\"0x%08\" PFMT64x, ref->addr);\n\t\tRGraphNode *reference_from = r_graph_add_node_info (graph, src, NULL, ref->addr);\n\t\tfree (src);\n\t\tr_graph_add_edge (graph, reference_from, curr_node);\n\t}\n\tr_list_free (list);\n}\n\nR_API RGraph *r_core_anal_importxrefs(RCore *core) {\n\tRBinInfo *info = r_bin_get_info (core->bin);\n\tRBinObject *obj = r_bin_cur_object (core->bin);\n\tbool lit = info? info->has_lit: false;\n\tbool va = core->io->va || r_config_get_b (core->config, \"cfg.debug\");\n\n\tRListIter *iter;\n\tRBinImport *imp;\n\tif (!obj) {\n\t\treturn NULL;\n\t}\n\tRGraph *graph = r_graph_new ();\n\tif (!graph) {\n\t\treturn NULL;\n\t}\n\tr_list_foreach (obj->imports, iter, imp) {\n\t\tut64 addr = lit ? r_core_bin_impaddr (core->bin, va, imp->name): 0;\n\t\tif (addr) {\n\t\t\tadd_single_addr_xrefs (core, addr, graph);\n\t\t} else {\n\t\t\tr_graph_add_node_info (graph, imp->name, NULL, 0);\n\t\t}\n\t}\n\treturn graph;\n}\n\nR_API RGraph *r_core_anal_codexrefs(RCore *core, ut64 addr) {\n\tRGraph *graph = r_graph_new ();\n\tif (!graph) {\n\t\treturn NULL;\n\t}\n\tadd_single_addr_xrefs (core, addr, graph);\n\treturn graph;\n}\n\nstatic ut64 RAnalRef_val(const void *_ref1) {\n\tconst RAnalRef* ref1 = _ref1;\n\treturn ref1->addr;\n}\n\nstatic int RAnalRef_cmp(const RAnalRef* ref1, const RAnalRef* ref2) {\n\treturn ref1->addr != ref2->addr;\n}\n\nR_API void r_core_anal_callgraph(RCore *core, ut64 addr, int fmt) {\n\tconst char *font = r_config_get (core->config, \"graph.font\");\n\tint is_html = r_cons_context ()->is_html;\n\tbool refgraph = r_config_get_i (core->config, \"graph.refs\");\n\tRListIter *iter, *iter2;\n\tint usenames = r_config_get_i (core->config, \"graph.json.usenames\");;\n\tRAnalFunction *fcni;\n\tRAnalRef *fcnr;\n\tPJ *pj = NULL;\n\n\tut64 from = r_config_get_i (core->config, \"graph.from\");\n\tut64 to = r_config_get_i (core->config, \"graph.to\");\n\n\tswitch (fmt) {\n\tcase R_GRAPH_FORMAT_JSON:\n\t\tpj = pj_new ();\n\t\tif (!pj) {\n\t\t\treturn;\n\t\t}\n\t\tpj_a (pj);\n\t\tbreak;\n\tcase R_GRAPH_FORMAT_GML:\n\tcase R_GRAPH_FORMAT_GMLFCN:\n\t\tr_cons_printf (\"graph\\n[\\n\"\n\t\t\t\t\"hierarchic  1\\n\"\n\t\t\t\t\"label  \\\"\\\"\\n\"\n\t\t\t\t\"directed  1\\n\");\n\t\tbreak;\n\tcase R_GRAPH_FORMAT_DOT:\n\t\tif (!is_html) {\n\t\t\tconst char * gv_edge = r_config_get (core->config, \"graph.gv.edge\");\n\t\t\tchar * gv_node = strdup (r_config_get (core->config, \"graph.gv.node\"));\n\t\t\tconst char * gv_grph = r_config_get (core->config, \"graph.gv.graph\");\n\t\t\tconst char * gv_spline = r_config_get (core->config, \"graph.gv.spline\");\n\t\t\tif (!gv_edge || !*gv_edge) {\n\t\t\t\tgv_edge = \"arrowhead=\\\"normal\\\" style=bold weight=2\";\n\t\t\t}\n\t\t\tif (!gv_node || !*gv_node) {\n\t\t\t\tconst char *font = r_config_get (core->config, \"graph.font\");\n\t\t\t\tfree (gv_node);\n\t\t\t\tgv_node = r_str_newf (\"penwidth=4 fillcolor=white style=filled fontname=\\\"%s Bold\\\" fontsize=14 shape=box\", font);\n\t\t\t}\n\t\t\tif (!gv_grph || !*gv_grph) {\n\t\t\t\tgv_grph = \"bgcolor=azure\";\n\t\t\t}\n\t\t\tif (!gv_spline || !*gv_spline) {\n\t\t\t\t// ortho for bbgraph and curved for callgraph\n\t\t\t\tgv_spline = \"splines=\\\"curved\\\"\";\n\t\t\t}\n\t\t\tr_cons_printf (\"digraph code {\\n\"\n\t\t\t\t\t\"rankdir=LR;\\n\"\n\t\t\t\t\t\"outputorder=edgesfirst;\\n\"\n\t\t\t\t\t\"graph [%s fontname=\\\"%s\\\" %s];\\n\"\n\t\t\t\t\t\"node [%s];\\n\"\n\t\t\t\t\t\"edge [%s];\\n\", gv_grph, font, gv_spline,\n\t\t\t\t\tgv_node, gv_edge);\n\t\t\tfree (gv_node);\n\t\t}\n\t\tbreak;\n\t}\n\tut64 base = UT64_MAX;\n\tint iteration = 0;\nrepeat:\n\tr_list_foreach (core->anal->fcns, iter, fcni) {\n\t\tif (base == UT64_MAX) {\n\t\t\tbase = fcni->addr;\n\t\t}\n\t\tif (from != UT64_MAX && fcni->addr < from) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (to != UT64_MAX && fcni->addr > to) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (addr != UT64_MAX && addr != fcni->addr) {\n\t\t\tcontinue;\n\t\t}\n\t\tRList *refs = r_anal_function_get_refs (fcni);\n\t\tRList *calls = r_list_new ();\n\t\t// TODO: maybe fcni->calls instead ?\n\t\tr_list_foreach (refs, iter2, fcnr) {\n\t\t\t//  TODO: tail calll jumps are also calls\n\t\t\tif (fcnr->type == 'C' && r_list_find(calls, fcnr, (RListComparator)RAnalRef_cmp) == NULL) {\n\t\t\t\tr_list_append (calls, fcnr);\n\t\t\t}\n\t\t}\n\t\tif (r_list_empty(calls)) {\n\t\t\tr_list_free (refs);\n\t\t\tr_list_free (calls);\n\t\t\tcontinue;\n\t\t}\n\t\tswitch (fmt) {\n\t\tcase R_GRAPH_FORMAT_NO:\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\"\\n\", fcni->addr);\n\t\t\tbreak;\n\t\tcase R_GRAPH_FORMAT_GML:\n\t\tcase R_GRAPH_FORMAT_GMLFCN: {\n\t\t\tRFlagItem *flag = r_flag_get_i (core->flags, fcni->addr);\n\t\t\tif (iteration == 0) {\n\t\t\t\tchar *msg = flag? strdup (flag->name): r_str_newf (\"0x%08\"PFMT64x, fcni->addr);\n\t\t\t\tr_cons_printf (\"  node [\\n\"\n\t\t\t\t\t\t\"  id  %\"PFMT64d\"\\n\"\n\t\t\t\t\t\t\"    label  \\\"%s\\\"\\n\"\n\t\t\t\t\t\t\"  ]\\n\", fcni->addr - base, msg);\n\t\t\t\tfree (msg);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tcase R_GRAPH_FORMAT_JSON:\n\t\t\tpj_o (pj);\n\t\t\tif (usenames) {\n\t\t\t\tpj_ks (pj, \"name\", fcni->name);\n\t\t\t} else {\n\t\t\t\tchar fcni_addr[20];\n\t\t\t\tsnprintf (fcni_addr, sizeof (fcni_addr) - 1, \"0x%08\" PFMT64x, fcni->addr);\n\t\t\t\tpj_ks (pj, \"name\", fcni_addr);\n\t\t\t}\n\t\t\tpj_kn (pj, \"size\", r_anal_function_linear_size (fcni));\n\t\t\tpj_ka (pj, \"imports\");\n\t\t\tbreak;\n\t\tcase R_GRAPH_FORMAT_DOT:\n\t\t\tr_cons_printf (\"  \\\"0x%08\"PFMT64x\"\\\" \"\n\t\t\t\t\t\"[label=\\\"%s\\\"\"\n\t\t\t\t\t\" URL=\\\"%s/0x%08\"PFMT64x\"\\\"];\\n\",\n\t\t\t\t\tfcni->addr, fcni->name,\n\t\t\t\t\tfcni->name, fcni->addr);\n\t\t}\n\t\tr_list_foreach (calls, iter2, fcnr) {\n\t\t\t// TODO: display only code or data refs?\n\t\t\tRFlagItem *flag = r_flag_get_i (core->flags, fcnr->addr);\n\t\t\tchar *fcnr_name = (flag && flag->name) ? flag->name : r_str_newf (\"unk.0x%\"PFMT64x, fcnr->addr);\n\t\t\tswitch (fmt) {\n\t\t\tcase R_GRAPH_FORMAT_GMLFCN:\n\t\t\t\tif (iteration == 0) {\n\t\t\t\t\tr_cons_printf (\"  node [\\n\"\n\t\t\t\t\t\t\t\"    id  %\"PFMT64d\"\\n\"\n\t\t\t\t\t\t\t\"    label  \\\"%s\\\"\\n\"\n\t\t\t\t\t\t\t\"  ]\\n\", fcnr->addr - base, fcnr_name);\n\t\t\t\t\tr_cons_printf (\"  edge [\\n\"\n\t\t\t\t\t\t\t\"    source  %\"PFMT64d\"\\n\"\n\t\t\t\t\t\t\t\"    target  %\"PFMT64d\"\\n\"\n\t\t\t\t\t\t\t\"  ]\\n\", fcni->addr-base, fcnr->addr-base);\n\t\t\t\t}\n\t\t\tcase R_GRAPH_FORMAT_GML:\n\t\t\t\tif (iteration != 0) {\n\t\t\t\t\tr_cons_printf (\"  edge [\\n\"\n\t\t\t\t\t\t\t\"    source  %\"PFMT64d\"\\n\"\n\t\t\t\t\t\t\t\"    target  %\"PFMT64d\"\\n\"\n\t\t\t\t\t\t\t\"  ]\\n\", fcni->addr-base, fcnr->addr-base); //, \"#000000\"\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_GRAPH_FORMAT_DOT:\n\t\t\t\tr_cons_printf (\"  \\\"0x%08\"PFMT64x\"\\\" -> \\\"0x%08\"PFMT64x\"\\\" \"\n\t\t\t\t\t\t\"[color=\\\"%s\\\" URL=\\\"%s/0x%08\"PFMT64x\"\\\"];\\n\",\n\t\t\t\t\t\t//\"[label=\\\"%s\\\" color=\\\"%s\\\" URL=\\\"%s/0x%08\"PFMT64x\"\\\"];\\n\",\n\t\t\t\t\t\tfcni->addr, fcnr->addr, //, fcnr_name,\n\t\t\t\t\t\t\"#61afef\",\n\t\t\t\t\t\tfcnr_name, fcnr->addr);\n\t\t\t\tr_cons_printf (\"  \\\"0x%08\"PFMT64x\"\\\" \"\n\t\t\t\t\t\t\"[label=\\\"%s\\\"\"\n\t\t\t\t\t\t\" URL=\\\"%s/0x%08\"PFMT64x\"\\\"];\\n\",\n\t\t\t\t\t\tfcnr->addr, fcnr_name,\n\t\t\t\t\t\tfcnr_name, fcnr->addr);\n\t\t\t\tbreak;\n\t\t\tcase R_GRAPH_FORMAT_JSON:\n\t\t\t\tif (usenames) {\n\t\t\t\t\tpj_s (pj, fcnr_name);\n\t\t\t\t} else {\n\t\t\t\t\tchar fcnr_addr[20];\n\t\t\t\t\tsnprintf (fcnr_addr, sizeof (fcnr_addr) - 1, \"0x%08\" PFMT64x, fcnr->addr);\n\t\t\t\t\tpj_s (pj, fcnr_addr);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tif (refgraph || fcnr->type == R_ANAL_REF_TYPE_CALL) {\n\t\t\t\t\t// TODO: avoid recreating nodes unnecessarily\n\t\t\t\t\tr_cons_printf (\"agn %s\\n\", fcni->name);\n\t\t\t\t\tr_cons_printf (\"agn %s\\n\", fcnr_name);\n\t\t\t\t\tr_cons_printf (\"age %s %s\\n\", fcni->name, fcnr_name);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"# - 0x%08\"PFMT64x\" (%c)\\n\", fcnr->addr, fcnr->type);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!(flag && flag->name)) {\n\t\t\t\tfree(fcnr_name);\n\t\t\t}\n\t\t}\n\t\tr_list_free (refs);\n\t\tr_list_free (calls);\n\t\tif (fmt == R_GRAPH_FORMAT_JSON) {\n\t\t\tpj_end (pj);\n\t\t\tpj_end (pj);\n\t\t}\n\t}\n\tif (iteration == 0 && fmt == R_GRAPH_FORMAT_GML) {\n\t\titeration++;\n\t\tgoto repeat;\n\t}\n\tif (iteration == 0 && fmt == R_GRAPH_FORMAT_GMLFCN) {\n\t\titeration++;\n\t}\n\tswitch (fmt) {\n\tcase R_GRAPH_FORMAT_GML:\n\tcase R_GRAPH_FORMAT_GMLFCN:\n\tcase R_GRAPH_FORMAT_JSON:\n\t\tpj_end (pj);\n\t\tr_cons_println (pj_string (pj));\n\t\tpj_free (pj);\n\t\tbreak;\n\tcase R_GRAPH_FORMAT_DOT:\n\t\tr_cons_printf (\"}\\n\");\n\t\tbreak;\n\t}\n}\n\nstatic void fcn_list_bbs(RAnalFunction *fcn) {\n\tRAnalBlock *bbi;\n\tRListIter *iter;\n\n\tr_list_foreach (fcn->bbs, iter, bbi) {\n\t\tr_cons_printf (\"afb+ 0x%08\" PFMT64x \" 0x%08\" PFMT64x \" %\" PFMT64u \" \",\n\t\t\t\t   fcn->addr, bbi->addr, bbi->size);\n\t\tr_cons_printf (\"0x%08\"PFMT64x\" \", bbi->jump);\n\t\tr_cons_printf (\"0x%08\"PFMT64x, bbi->fail);\n\t\tif (bbi->diff) {\n\t\t\tif (bbi->diff->type == R_ANAL_DIFF_TYPE_MATCH) {\n\t\t\t\tr_cons_printf (\" m\");\n\t\t\t} else if (bbi->diff->type == R_ANAL_DIFF_TYPE_UNMATCH) {\n\t\t\t\tr_cons_printf (\" u\");\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\" n\");\n\t\t\t}\n\t\t}\n\t\tr_cons_printf (\"\\n\");\n\t}\n}\n\nR_API ut64 r_core_anal_fcn_list_size(RCore *core) {\n\tRAnalFunction *fcn;\n\tRListIter *iter;\n\tut64 total = 0;\n\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\ttotal += r_anal_function_realsize (fcn);\n\t}\n\tr_cons_printf (\"%\"PFMT64u\"\\n\", total);\n\treturn total;\n}\n\n/* Fill out metadata struct of functions */\nstatic int fcnlist_gather_metadata(RAnal *anal, RList *fcns) {\n\tRListIter *iter;\n\tRAnalFunction *fcn;\n\tRList *xrefs;\n\n\tr_list_foreach (fcns, iter, fcn) {\n\t\t// Count the number of references and number of calls\n\t\tRListIter *callrefiter;\n\t\tRAnalRef *ref;\n\t\tRList *refs = r_anal_function_get_refs (fcn);\n\t\tint numcallrefs = 0;\n\t\tr_list_foreach (refs, callrefiter, ref) {\n\t\t\tif (ref->type == R_ANAL_REF_TYPE_CALL) {\n\t\t\t\tnumcallrefs++;\n\t\t\t}\n\t\t}\n\t\tr_list_free (refs);\n\t\tfcn->meta.numcallrefs = numcallrefs;\n\t\txrefs = r_anal_xrefs_get (anal, fcn->addr);\n\t\tfcn->meta.numrefs = xrefs? xrefs->length: 0;\n\t\tr_list_free (xrefs);\n\t}\n\t// TODO: Determine sgnc, sgec\n\treturn 0;\n}\n\nR_API char *r_core_anal_fcn_name(RCore *core, RAnalFunction *fcn) {\n\tbool demangle = r_config_get_i (core->config, \"bin.demangle\");\n\tconst char *lang = demangle ? r_config_get (core->config, \"bin.lang\") : NULL;\n\tbool keep_lib = r_config_get_i (core->config, \"bin.demangle.libs\");\n\tchar *name = strdup (r_str_get (fcn->name));\n\tif (demangle) {\n\t\tchar *tmp = r_bin_demangle (core->bin->cur, lang, name, fcn->addr, keep_lib);\n\t\tif (tmp) {\n\t\t\tfree (name);\n\t\t\tname = tmp;\n\t\t}\n\t}\n\treturn name;\n}\n\n#define FCN_LIST_VERBOSE_ENTRY \"%s0x%0*\"PFMT64x\" %4\"PFMT64d\" %5d %5d %5d %4d 0x%0*\"PFMT64x\" %5\"PFMT64d\" 0x%0*\"PFMT64x\" %5d %4d %6d %4d %5d %s%s\\n\"\nstatic int fcn_print_verbose(RCore *core, RAnalFunction *fcn, bool use_color) {\n\tchar *name = r_core_anal_fcn_name (core, fcn);\n\tint ebbs = 0;\n\tint addrwidth = 8;\n\tconst char *color = \"\";\n\tconst char *color_end = \"\";\n\tif (use_color) {\n\t\tcolor_end = Color_RESET;\n\t\tif (strstr (name, \"sym.imp.\")) {\n\t\t\tcolor = Color_YELLOW;\n\t\t} else if (strstr (name, \"sym.\")) {\n\t\t\tcolor = Color_GREEN;\n\t\t} else if (strstr (name, \"sub.\")) {\n\t\t\tcolor = Color_MAGENTA;\n\t\t}\n\t}\n\n\tif (core->anal->bits == 64) {\n\t\taddrwidth = 16;\n\t}\n\n\tr_cons_printf (FCN_LIST_VERBOSE_ENTRY, color,\n\t\t\taddrwidth, fcn->addr,\n\t\t\tr_anal_function_realsize (fcn),\n\t\t\tr_list_length (fcn->bbs),\n\t\t\tr_anal_function_count_edges (fcn, &ebbs),\n\t\t\tr_anal_function_complexity (fcn),\n\t\t\tr_anal_function_cost (fcn),\n\t\t\taddrwidth, r_anal_function_min_addr (fcn),\n\t\t\tr_anal_function_linear_size (fcn),\n\t\t\taddrwidth, r_anal_function_max_addr (fcn),\n\t\t\tfcn->meta.numcallrefs,\n\t\t\tr_anal_var_count_locals (fcn),\n\t\t\tr_anal_var_count_args (fcn),\n\t\t\tfcn->meta.numrefs,\n\t\t\tfcn->maxstack,\n\t\t\tname,\n\t\t\tcolor_end);\n\tfree (name);\n\treturn 0;\n}\n\nstatic int fcn_list_verbose(RCore *core, RList *fcns, const char *sortby) {\n\tbool use_color = r_config_get_i (core->config, \"scr.color\");\n\tint headeraddr_width = 10;\n\tchar *headeraddr = \"==========\";\n\n\tif (core->anal->bits == 64) {\n\t\theaderaddr_width = 18;\n\t\theaderaddr = \"==================\";\n\t}\n\n\tif (sortby) {\n\t\tif (!strcmp (sortby, \"size\")) {\n\t\t\tr_list_sort (fcns, cmpsize);\n\t\t} else if (!strcmp (sortby, \"addr\")) {\n\t\t\tr_list_sort (fcns, cmpaddr);\n\t\t} else if (!strcmp (sortby, \"cc\")) {\n\t\t\tr_list_sort (fcns, cmpfcncc);\n\t\t} else if (!strcmp (sortby, \"edges\")) {\n\t\t\tr_list_sort (fcns, cmpedges);\n\t\t} else if (!strcmp (sortby, \"calls\")) {\n\t\t\tr_list_sort (fcns, cmpcalls);\n\t\t} else if (strstr (sortby, \"name\")) {\n\t\t\tr_list_sort (fcns, cmpname);\n\t\t} else if (strstr (sortby, \"frame\")) {\n\t\t\tr_list_sort (fcns, cmpframe);\n\t\t} else if (strstr (sortby, \"ref\")) {\n\t\t\tr_list_sort (fcns, cmpxrefs);\n\t\t} else if (!strcmp (sortby, \"nbbs\")) {\n\t\t\tr_list_sort (fcns, cmpnbbs);\n\t\t}\n\t}\n\n\tr_cons_printf (\"%-*s %4s %5s %5s %5s %4s %*s range %-*s %s %s %s %s %s %s\\n\",\n\t\t\theaderaddr_width, \"address\", \"size\", \"nbbs\", \"edges\", \"cc\", \"cost\",\n\t\t\theaderaddr_width, \"min bound\", headeraddr_width, \"max bound\", \"calls\",\n\t\t\t\"locals\", \"args\", \"xref\", \"frame\", \"name\");\n\tr_cons_printf (\"%s ==== ===== ===== ===== ==== %s ===== %s ===== ====== ==== ==== ===== ====\\n\",\n\t\t\theaderaddr, headeraddr, headeraddr);\n\tRListIter *iter;\n\tRAnalFunction *fcn;\n\tr_list_foreach (fcns, iter, fcn) {\n\t\tfcn_print_verbose (core, fcn, use_color);\n\t}\n\n\treturn 0;\n}\n\nstatic void __fcn_print_default(RCore *core, RAnalFunction *fcn, bool quiet) {\n\tif (quiet) {\n\t\tr_cons_printf (\"0x%08\"PFMT64x\" \", fcn->addr);\n\t} else {\n\t\tchar *name = r_core_anal_fcn_name (core, fcn);\n\t\tut64 realsize = r_anal_function_realsize (fcn);\n\t\tut64 size = r_anal_function_linear_size (fcn);\n\t\tchar *msg = (realsize == size)\n\t\t\t? r_str_newf (\"%-12\"PFMT64u, size)\n\t\t\t: r_str_newf (\"%-4\"PFMT64u\" -> %-4\"PFMT64u, size, realsize);\n\t\tr_cons_printf (\"0x%08\"PFMT64x\" %4d %4s %s\\n\",\n\t\t\t\tfcn->addr, r_list_length (fcn->bbs), msg, name);\n\t\tfree (name);\n\t\tfree (msg);\n\t}\n}\n\nstatic int fcn_list_default(RCore *core, RList *fcns, bool quiet) {\n\tRListIter *iter;\n\tRAnalFunction *fcn;\n\tr_list_foreach (fcns, iter, fcn) {\n\t\t__fcn_print_default (core, fcn, quiet);\n\t\tif (quiet) {\n\t\t\tr_cons_newline ();\n\t\t}\n\t}\n\treturn 0;\n}\n\n// for a given function returns an RList of all functions that were called in it\nR_API RList *r_core_anal_fcn_get_calls(RCore *core, RAnalFunction *fcn) {\n\tRAnalRef *refi;\n\tRListIter *iter, *iter2;\n\n\t// get all references from this function\n\tRList *refs = r_anal_function_get_refs (fcn);\n\t// sanity check\n\tif (!r_list_empty (refs)) {\n\t\t// iterate over all the references and remove these which aren't of type call\n\t\tr_list_foreach_safe (refs, iter, iter2, refi) {\n\t\t\tif (refi->type != R_ANAL_REF_TYPE_CALL) {\n\t\t\t\tr_list_delete (refs, iter);\n\t\t\t}\n\t\t}\n\t}\n\treturn refs;\n}\n\n// Lists function names and their calls (uniqified)\nstatic int fcn_print_makestyle(RCore *core, RList *fcns, char mode) {\n\tRListIter *refiter;\n\tRListIter *fcniter;\n\tRAnalFunction *fcn;\n\tRAnalRef *refi;\n\tRList *refs = NULL;\n\tPJ *pj = NULL;\n\n\tif (mode == 'j') {\n\t\tpj = r_core_pj_new (core);\n\t\tpj_a (pj);\n\t}\n\n\t// Iterate over all functions\n\tr_list_foreach (fcns, fcniter, fcn) {\n\t\t// Get all refs for a function\n\t\trefs = r_core_anal_fcn_get_calls (core, fcn);\n\t\t// Uniquify the list by ref->addr\n\t\tr_list_uniq_inplace (refs, RAnalRef_val);\n\n\t\t// don't enter for functions with 0 refs\n\t\tif (!r_list_empty (refs)) {\n\t\t\tif (pj) { // begin json output of function\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_ks (pj, \"name\", fcn->name);\n\t\t\t\tpj_kn (pj, \"addr\", fcn->addr);\n\t\t\t\tpj_k (pj, \"calls\");\n\t\t\t\tpj_a (pj);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"%s\", fcn->name);\n\t\t\t}\n\n\t\t\tif (mode == 'm') {\n\t\t\t\tr_cons_printf (\":\\n\");\n\t\t\t} else if (mode == 'q') {\n\t\t\t\tr_cons_printf (\" -> \");\n\t\t\t}\n\t\t\t// Iterate over all refs from a function\n\t\t\tr_list_foreach (refs, refiter, refi) {\n\t\t\t\tRFlagItem *f = r_flag_get_i (core->flags, refi->addr);\n\t\t\t\tchar *dst = r_str_newf ((f? f->name: \"0x%08\"PFMT64x), refi->addr);\n\t\t\t\tif (pj) { // Append calee json item\n\t\t\t\t\tpj_o (pj);\n\t\t\t\t\tpj_ks (pj, \"name\", dst);\n\t\t\t\t\tpj_kn (pj, \"addr\", refi->addr);\n\t\t\t\t\tpj_end (pj); // close referenced item\n\t\t\t\t} else if (mode == 'q') {\n\t\t\t\t\tr_cons_printf (\"%s \", dst);\n\t\t\t\t} else {\n\t\t\t\t\tr_cons_printf (\"    %s\\n\", dst);\n\t\t\t\t}\n\t\t\t\tfree (dst);\n\t\t\t}\n\t\t\tif (pj) {\n\t\t\t\tpj_end (pj); // close list of calls\n\t\t\t\tpj_end (pj); // close function item\n\t\t\t} else {\n\t\t\t\tr_cons_newline();\n\t\t\t}\n\t\t}\n\n\t\tr_list_free (refs);\n\t}\n\n\tif (mode == 'j') {\n\t\tpj_end (pj); // close json output\n\t\tr_cons_printf (\"%s\\n\", pj_string (pj));\n\t}\n\tif (pj) {\n\t\tpj_free (pj);\n\t}\n\treturn 0;\n}\n\nstatic int fcn_print_json(RCore *core, RAnalFunction *fcn, PJ *pj) {\n\tRListIter *iter;\n\tRAnalRef *refi;\n\tRList *refs, *xrefs;\n\tif (!pj) {\n\t\treturn -1;\n\t}\n\tint ebbs = 0;\n\tpj_o (pj);\n\tpj_kn (pj, \"offset\", fcn->addr);\n\tchar *name = r_core_anal_fcn_name (core, fcn);\n\tif (name) {\n\t\tpj_ks (pj, \"name\", name);\n\t}\n\tpj_kn (pj, \"size\", r_anal_function_linear_size (fcn));\n\tpj_ks (pj, \"is-pure\", r_str_bool (r_anal_function_purity (fcn)));\n\tpj_kn (pj, \"realsz\", r_anal_function_realsize (fcn));\n\tpj_kb (pj, \"noreturn\", fcn->is_noreturn);\n\tpj_ki (pj, \"stackframe\", fcn->maxstack);\n\tif (fcn->cc) {\n\t\tpj_ks (pj, \"calltype\", fcn->cc); // calling conventions\n\t}\n\tpj_ki (pj, \"cost\", r_anal_function_cost (fcn)); // execution cost\n\tpj_ki (pj, \"cc\", r_anal_function_complexity (fcn)); // cyclic cost\n\tpj_ki (pj, \"bits\", fcn->bits);\n\tpj_ks (pj, \"type\", r_anal_functiontype_tostring (fcn->type));\n\tpj_ki (pj, \"nbbs\", r_list_length (fcn->bbs));\n\tpj_ki (pj, \"edges\", r_anal_function_count_edges (fcn, &ebbs));\n\tpj_ki (pj, \"ebbs\", ebbs);\n\t{\n\t\tchar *sig = r_core_cmd_strf (core, \"afcf @ 0x%\"PFMT64x, fcn->addr);\n\t\tif (sig) {\n\t\t\tr_str_trim (sig);\n\t\t\tpj_ks (pj, \"signature\", sig);\n\t\t\tfree (sig);\n\t\t}\n\n\t}\n\tpj_kn (pj, \"minbound\", r_anal_function_min_addr (fcn));\n\tpj_kn (pj, \"maxbound\", r_anal_function_max_addr (fcn));\n\n\tint outdegree = 0;\n\trefs = r_anal_function_get_refs (fcn);\n\tif (!r_list_empty (refs)) {\n\t\tpj_k (pj, \"callrefs\");\n\t\tpj_a (pj);\n\t\tr_list_foreach (refs, iter, refi) {\n\t\t\tif (refi->type == R_ANAL_REF_TYPE_CALL) {\n\t\t\t\toutdegree++;\n\t\t\t}\n\t\t\tif (refi->type == R_ANAL_REF_TYPE_CODE ||\n\t\t\t\trefi->type == R_ANAL_REF_TYPE_CALL) {\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_kn (pj, \"addr\", refi->addr);\n\t\t\t\tpj_ks (pj, \"type\", r_anal_xrefs_type_tostring (refi->type));\n\t\t\t\tpj_kn (pj, \"at\", refi->at);\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t}\n\t\tpj_end (pj);\n\n\t\tpj_k (pj, \"datarefs\");\n\t\tpj_a (pj);\n\t\tr_list_foreach (refs, iter, refi) {\n\t\t\tif (refi->type == R_ANAL_REF_TYPE_DATA) {\n\t\t\t\tpj_n (pj, refi->addr);\n\t\t\t}\n\t\t}\n\t\tpj_end (pj);\n\t}\n\tr_list_free (refs);\n\n\tint indegree = 0;\n\txrefs = r_anal_function_get_xrefs (fcn);\n\tif (!r_list_empty (xrefs)) {\n\t\tpj_k (pj, \"codexrefs\");\n\t\tpj_a (pj);\n\t\tr_list_foreach (xrefs, iter, refi) {\n\t\t\tif (refi->type == R_ANAL_REF_TYPE_CODE ||\n\t\t\t\trefi->type == R_ANAL_REF_TYPE_CALL) {\n\t\t\t\tindegree++;\n\t\t\t\tpj_o (pj);\n\t\t\t\tpj_kn (pj, \"addr\", refi->addr);\n\t\t\t\tpj_ks (pj, \"type\", r_anal_xrefs_type_tostring (refi->type));\n\t\t\t\tpj_kn (pj, \"at\", refi->at);\n\t\t\t\tpj_end (pj);\n\t\t\t}\n\t\t}\n\n\t\tpj_end (pj);\n\t\tpj_k (pj, \"dataxrefs\");\n\t\tpj_a (pj);\n\n\t\tr_list_foreach (xrefs, iter, refi) {\n\t\t\tif (refi->type == R_ANAL_REF_TYPE_DATA) {\n\t\t\t\tpj_n (pj, refi->addr);\n\t\t\t}\n\t\t}\n\t\tpj_end (pj);\n\t}\n\tr_list_free (xrefs);\n\n\tpj_ki (pj, \"indegree\", indegree);\n\tpj_ki (pj, \"outdegree\", outdegree);\n\n\tif (fcn->type == R_ANAL_FCN_TYPE_FCN || fcn->type == R_ANAL_FCN_TYPE_SYM) {\n\t\tpj_ki (pj, \"nlocals\", r_anal_var_count_locals (fcn));\n\t\tpj_ki (pj, \"nargs\", r_anal_var_count_args (fcn));\n\t\tpj_k (pj, \"bpvars\");\n\t\tr_anal_var_list_show (core->anal, fcn, 'b', 'j', pj);\n\t\tpj_k (pj, \"spvars\");\n\t\tr_anal_var_list_show (core->anal, fcn, 's', 'j', pj);\n\t\tpj_k (pj, \"regvars\");\n\t\tr_anal_var_list_show (core->anal, fcn, 'r', 'j', pj);\n\n\t\tpj_ks (pj, \"difftype\", fcn->diff->type == R_ANAL_DIFF_TYPE_MATCH?\"match\":\n\t\t\t\tfcn->diff->type == R_ANAL_DIFF_TYPE_UNMATCH?\"unmatch\":\"new\");\n\t\tif (fcn->diff->addr != -1) {\n\t\t\tpj_kn (pj, \"diffaddr\", fcn->diff->addr);\n\t\t}\n\t\tif (fcn->diff->name) {\n\t\t\tpj_ks (pj, \"diffname\", fcn->diff->name);\n\t\t}\n\t}\n\tpj_end (pj);\n\tfree (name);\n\treturn 0;\n}\n\nstatic int fcn_list_json(RCore *core, RList *fcns, bool quiet) {\n\tRListIter *iter;\n\tRAnalFunction *fcn;\n\tPJ *pj = r_core_pj_new (core);\n\tif (!pj) {\n\t\tr_cons_println (\"[]\");\n\t\treturn -1;\n\t}\n\tpj_a (pj);\n\tr_list_foreach (fcns, iter, fcn) {\n\t\tif (quiet) {\n\t\t\tpj_n (pj, fcn->addr);\n\t\t} else {\n\t\t\tfcn_print_json (core, fcn, pj);\n\t\t}\n\t}\n\tpj_end (pj);\n\tr_cons_println (pj_string (pj));\n\tpj_free (pj);\n\treturn 0;\n}\n\nstatic int fcn_list_verbose_json(RCore *core, RList *fcns) {\n\treturn fcn_list_json (core, fcns, false);\n}\n\nstatic int fcn_print_detail(RCore *core, RAnalFunction *fcn) {\n\tconst char *defaultCC = r_anal_cc_default (core->anal);\n\tchar *name = r_core_anal_fcn_name (core, fcn);\n\tchar *paren = strchr (name, '(');\n\tif (paren) {\n\t\t*paren = '\\0';\n\t}\n\tr_cons_printf (\"\\\"f %s %\"PFMT64u\" 0x%08\"PFMT64x\"\\\"\\n\", name, r_anal_function_linear_size (fcn), fcn->addr);\n\tr_cons_printf (\"\\\"af+ 0x%08\"PFMT64x\" %s %c %c\\\"\\n\",\n\t\t\tfcn->addr, name, //r_anal_function_size (fcn), name,\n\t\t\tfcn->type == R_ANAL_FCN_TYPE_LOC?'l':\n\t\t\tfcn->type == R_ANAL_FCN_TYPE_SYM?'s':\n\t\t\tfcn->type == R_ANAL_FCN_TYPE_IMP?'i':'f',\n\t\t\tfcn->diff->type == R_ANAL_DIFF_TYPE_MATCH?'m':\n\t\t\tfcn->diff->type == R_ANAL_DIFF_TYPE_UNMATCH?'u':'n');\n\t// FIXME: this command prints something annoying. Does it have important side-effects?\n\tfcn_list_bbs (fcn);\n\tif (fcn->bits != 0) {\n\t\tr_cons_printf (\"afB %d @ 0x%08\"PFMT64x\"\\n\", fcn->bits, fcn->addr);\n\t}\n\t// FIXME command injection vuln here\n\tif (fcn->cc || defaultCC) {\n\t\tr_cons_printf (\"s 0x%\"PFMT64x\"\\n\", fcn->addr);\n\t\tr_cons_printf (\"\\\"afc %s\\\"\\n\", fcn->cc? fcn->cc: defaultCC);\n\t\tr_cons_println (\"s-\");\n\t}\n\tif (fcn->folded) {\n\t\tr_cons_printf (\"afF @ 0x%08\"PFMT64x\"\\n\", fcn->addr);\n\t}\n\tif (fcn) {\n\t\t/* show variables  and arguments */\n\t\tr_core_cmdf (core, \"afvb* @ 0x%\"PFMT64x\"\\n\", fcn->addr);\n\t\tr_core_cmdf (core, \"afvr* @ 0x%\"PFMT64x\"\\n\", fcn->addr);\n\t\tr_core_cmdf (core, \"afvs* @ 0x%\"PFMT64x\"\\n\", fcn->addr);\n\t}\n\t/* Show references */\n\tRListIter *refiter;\n\tRAnalRef *refi;\n\tRList *refs = r_anal_function_get_refs (fcn);\n\tr_list_foreach (refs, refiter, refi) {\n\t\tswitch (refi->type) {\n\t\tcase R_ANAL_REF_TYPE_CALL:\n\t\t\tr_cons_printf (\"axC 0x%\"PFMT64x\" 0x%\"PFMT64x\"\\n\", refi->addr, refi->at);\n\t\t\tbreak;\n\t\tcase R_ANAL_REF_TYPE_DATA:\n\t\t\tr_cons_printf (\"axd 0x%\"PFMT64x\" 0x%\"PFMT64x\"\\n\", refi->addr, refi->at);\n\t\t\tbreak;\n\t\tcase R_ANAL_REF_TYPE_CODE:\n\t\t\tr_cons_printf (\"axc 0x%\"PFMT64x\" 0x%\"PFMT64x\"\\n\", refi->addr, refi->at);\n\t\t\tbreak;\n\t\tcase R_ANAL_REF_TYPE_STRING:\n\t\t\tr_cons_printf (\"axs 0x%\"PFMT64x\" 0x%\"PFMT64x\"\\n\", refi->addr, refi->at);\n\t\t\tbreak;\n\t\tcase R_ANAL_REF_TYPE_NULL:\n\t\tdefault:\n\t\t\tr_cons_printf (\"ax 0x%\"PFMT64x\" 0x%\"PFMT64x\"\\n\", refi->addr, refi->at);\n\t\t\tbreak;\n\t\t}\n\t}\n\tr_list_free (refs);\n\t/*Saving Function stack frame*/\n\tr_cons_printf (\"afS %d @ 0x%\"PFMT64x\"\\n\", fcn->maxstack, fcn->addr);\n\tfree (name);\n\treturn 0;\n}\n\nstatic bool is_fcn_traced(RDebugTrace *traced, RAnalFunction *fcn) {\n\tint tag = traced->tag;\n\tRListIter *iter;\n\tRDebugTracepoint *trace;\n\n\tr_list_foreach (traced->traces, iter, trace) {\n\t\tif (!trace->tag || (tag & trace->tag)) {\n\t\t\tif (r_anal_function_contains (fcn, trace->addr)) {\n\t\t\t\tr_cons_printf (\"\\ntraced: %d\\n\", trace->times);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nstatic int fcn_print_legacy(RCore *core, RAnalFunction *fcn) {\n\tRListIter *iter;\n\tRAnalRef *refi;\n\tRList *refs, *xrefs;\n\tint ebbs = 0;\n\tchar *name = r_core_anal_fcn_name (core, fcn);\n\n\tr_cons_printf (\"#\\noffset: 0x%08\"PFMT64x\"\\nname: %s\\nsize: %\"PFMT64u,\n\t\t\tfcn->addr, name, r_anal_function_linear_size (fcn));\n\tr_cons_printf (\"\\nis-pure: %s\", r_str_bool (r_anal_function_purity (fcn)));\n\tr_cons_printf (\"\\nrealsz: %\" PFMT64d, r_anal_function_realsize (fcn));\n\tr_cons_printf (\"\\nstackframe: %d\", fcn->maxstack);\n\tif (fcn->cc) {\n\t\tr_cons_printf (\"\\ncall-convention: %s\", fcn->cc);\n\t}\n\tr_cons_printf (\"\\ncyclomatic-cost: %d\", r_anal_function_cost (fcn));\n\tr_cons_printf (\"\\ncyclomatic-complexity: %d\", r_anal_function_complexity (fcn));\n\tr_cons_printf (\"\\nbits: %d\", fcn->bits);\n\tr_cons_printf (\"\\ntype: %s\", r_anal_functiontype_tostring (fcn->type));\n\tif (fcn->type == R_ANAL_FCN_TYPE_FCN || fcn->type == R_ANAL_FCN_TYPE_SYM) {\n\t\tr_cons_printf (\" [%s]\",\n\t\t\t\tfcn->diff->type == R_ANAL_DIFF_TYPE_MATCH?\"MATCH\":\n\t\t\t\tfcn->diff->type == R_ANAL_DIFF_TYPE_UNMATCH?\"UNMATCH\":\"NEW\");\n\t}\n\tr_cons_printf (\"\\nnum-bbs: %d\", r_list_length (fcn->bbs));\n\tr_cons_printf (\"\\nedges: %d\", r_anal_function_count_edges (fcn, &ebbs));\n\tr_cons_printf (\"\\nend-bbs: %d\", ebbs);\n\tr_cons_printf (\"\\ncall-refs:\");\n\tint outdegree = 0;\n\trefs = r_anal_function_get_refs (fcn);\n\tr_list_foreach (refs, iter, refi) {\n\t\tif (refi->type == R_ANAL_REF_TYPE_CALL) {\n\t\t\toutdegree++;\n\t\t}\n\t\tif (refi->type == R_ANAL_REF_TYPE_CODE || refi->type == R_ANAL_REF_TYPE_CALL) {\n\t\t\tr_cons_printf (\" 0x%08\"PFMT64x\" %c\", refi->addr,\n\t\t\t\t\trefi->type == R_ANAL_REF_TYPE_CALL?'C':'J');\n\t\t}\n\t}\n\tr_cons_printf (\"\\ndata-refs:\");\n\tr_list_foreach (refs, iter, refi) {\n\t\t// global or local?\n\t\tif (refi->type == R_ANAL_REF_TYPE_DATA) {\n\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, refi->addr);\n\t\t}\n\t}\n\tr_list_free (refs);\n\n\tint indegree = 0;\n\tr_cons_printf (\"\\ncode-xrefs:\");\n\txrefs = r_anal_function_get_xrefs (fcn);\n\tr_list_foreach (xrefs, iter, refi) {\n\t\tif (refi->type == R_ANAL_REF_TYPE_CODE || refi->type == R_ANAL_REF_TYPE_CALL) {\n\t\t\tindegree++;\n\t\t\tr_cons_printf (\" 0x%08\"PFMT64x\" %c\", refi->addr,\n\t\t\t\t\trefi->type == R_ANAL_REF_TYPE_CALL?'C':'J');\n\t\t}\n\t}\n\tr_cons_printf (\"\\nnoreturn: %s\", r_str_bool (fcn->is_noreturn));\n\tr_cons_printf (\"\\nin-degree: %d\", indegree);\n\tr_cons_printf (\"\\nout-degree: %d\", outdegree);\n\tr_cons_printf (\"\\ndata-xrefs:\");\n\tr_list_foreach (xrefs, iter, refi) {\n\t\tif (refi->type == R_ANAL_REF_TYPE_DATA) {\n\t\t\tr_cons_printf (\" 0x%08\"PFMT64x, refi->addr);\n\t\t}\n\t}\n\tr_list_free (xrefs);\n\n\tif (fcn->type == R_ANAL_FCN_TYPE_FCN || fcn->type == R_ANAL_FCN_TYPE_SYM) {\n\t\tint args_count = r_anal_var_count_args (fcn);\n\t\tint var_count = r_anal_var_count_locals (fcn);\n\n\t\tr_cons_printf (\"\\nlocals: %d\\nargs: %d\\n\", var_count, args_count);\n\t\tr_anal_var_list_show (core->anal, fcn, 'b', 0, NULL);\n\t\tr_anal_var_list_show (core->anal, fcn, 's', 0, NULL);\n\t\tr_anal_var_list_show (core->anal, fcn, 'r', 0, NULL);\n\t\tr_cons_printf (\"diff: type: %s\",\n\t\t\t\tfcn->diff->type == R_ANAL_DIFF_TYPE_MATCH?\"match\":\n\t\t\t\tfcn->diff->type == R_ANAL_DIFF_TYPE_UNMATCH?\"unmatch\":\"new\");\n\t\tif (fcn->diff->addr != -1) {\n\t\t\tr_cons_printf (\"addr: 0x%\"PFMT64x, fcn->diff->addr);\n\t\t}\n\t\tif (fcn->diff->name) {\n\t\t\tr_cons_printf (\"function: %s\", fcn->diff->name);\n\t\t}\n\t}\n\tfree (name);\n\n\t// traced\n\tif (core->dbg->trace->enabled) {\n\t\tis_fcn_traced (core->dbg->trace, fcn);\n\t}\n\treturn 0;\n}\n\nstatic int fcn_list_detail(RCore *core, RList *fcns) {\n\tRListIter *iter;\n\tRAnalFunction *fcn;\n\tr_list_foreach (fcns, iter, fcn) {\n\t\tfcn_print_detail (core, fcn);\n\t}\n\tr_cons_newline ();\n\treturn 0;\n}\n\nstatic int fcn_list_table(RCore *core, const char *q, int fmt) {\n\tchar xref[128], ccstr[128], castr[128];\n\tRAnalFunction *fcn;\n\tRListIter *iter;\n\tRTable *t = r_core_table (core, \"fcns\");\n\tRTableColumnType *typeString = r_table_type (\"string\");\n\tRTableColumnType *typeNumber = r_table_type (\"number\");\n\tr_table_add_column (t, typeNumber, \"addr\", 0);\n\tr_table_add_column (t, typeNumber, \"size\", 0);\n\tr_table_add_column (t, typeString, \"name\", 0);\n\tr_table_add_column (t, typeNumber, \"nbbs\", 0);\n\tr_table_add_column (t, typeNumber, \"xref\", 0);\n\tr_table_add_column (t, typeNumber, \"calls\", 0);\n\tr_table_add_column (t, typeNumber, \"cc\", 0);\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\tr_strf_var (fcnAddr, 32, \"0x%08\"PFMT64x, fcn->addr);\n\t\tr_strf_var (fcnSize, 32, \"%\"PFMT64u, r_anal_function_linear_size (fcn)); // r_anal_function_size (fcn));\n\t\tr_strf_var (nbbs, 32, \"%d\", r_list_length (fcn->bbs));\n\t\tRList *xrefs = r_anal_function_get_xrefs (fcn);\n\t\tsnprintf (xref, sizeof (xref), \"%d\", r_list_length (xrefs));\n\t\tr_list_free (xrefs);\n\n\t\tRList *calls = r_core_anal_fcn_get_calls (core, fcn);\n\t\tr_list_uniq_inplace (calls, (RListComparatorItem)RAnalRef_val);\n\t\tsnprintf (castr, sizeof (castr), \"%d\", r_list_length (calls));\n\t\tr_list_free (calls);\n\t\tsnprintf (ccstr, sizeof (ccstr), \"%d\", r_anal_function_complexity (fcn));\n\n\t\tr_table_add_row (t, fcnAddr, fcnSize, fcn->name, nbbs, xref, castr, ccstr, NULL);\n\t}\n\tif (r_table_query (t, q)) {\n\t\tchar *s = (fmt == 'j')\n\t\t\t? r_table_tojson (t)\n\t\t\t: r_table_tostring (t);\n\t\tr_cons_printf (\"%s\\n\", s);\n\t\tfree (s);\n\t}\n\tr_table_free (t);\n\treturn 0;\n}\n\nstatic int fcn_list_legacy(RCore *core, RList *fcns) {\n\tRListIter *iter;\n\tRAnalFunction *fcn;\n\tr_list_foreach (fcns, iter, fcn) {\n\t\tfcn_print_legacy (core, fcn);\n\t}\n\tr_cons_newline ();\n\treturn 0;\n}\n\nR_API int r_core_anal_fcn_list(RCore *core, const char *input, const char *rad) {\n\tchar temp[64];\n\tr_return_val_if_fail (core && core->anal, 0);\n\tif (r_list_empty (core->anal->fcns)) {\n\t\tif (*rad == 'j') {\n\t\t\tr_cons_println (\"[]\");\n\t\t}\n\t\treturn 0;\n\t}\n\tif (*rad == '.') {\n\t\tRList *fcns = r_anal_get_functions_in (core->anal, core->offset);\n\t\tif (!fcns || r_list_empty (fcns)) {\n\t\t\teprintf (\"No functions at current address.\\n\");\n\t\t\tr_list_free (fcns);\n\t\t\treturn -1;\n\t\t}\n\t\tfcn_list_default (core, fcns, false);\n\t\tr_list_free (fcns);\n\t\treturn 0;\n\t}\n\n\tif (rad && (*rad == 'l' || *rad == 'j')) {\n\t\tfcnlist_gather_metadata (core->anal, core->anal->fcns);\n\t}\n\n\tconst char *name = input;\n\tut64 addr = core->offset;\n\tif (input && *input) {\n\t\tname = input + 1;\n\t\taddr = r_num_math (core->num, name);\n\t}\n\n\tRList *fcns = r_list_newf (NULL);\n\tif (!fcns) {\n\t\treturn -1;\n\t}\n\tRListIter *iter;\n\tRAnalFunction *fcn;\n\tr_list_foreach (core->anal->fcns, iter, fcn) {\n\t\tif (!input || r_anal_function_contains (fcn, addr) || (!strcmp (name, fcn->name))) {\n\t\t\tr_list_append (fcns, fcn);\n\t\t}\n\t}\n\n\t// Use afls[asn] to sort by address, size or name, dont sort it here .. r_list_sort (fcns, &cmpfcn);\n\tif (!rad) {\n\t\tfcn_list_default (core, fcns, false);\n\t\tr_list_free (fcns);\n\t\treturn 0;\n\t}\n\tswitch (*rad) {\n\tcase '+':\n\t\tr_core_anal_fcn_list_size (core);\n\t\tbreak;\n\tcase '=': { // afl=\n\t\tr_list_sort (fcns, cmpaddr);\n\t\tRList *flist = r_list_newf ((RListFree) r_listinfo_free);\n\t\tif (!flist) {\n\t\t\tr_list_free (fcns);\n\t\t\treturn -1;\n\t\t}\n\t\tls_foreach (fcns, iter, fcn) {\n\t\t\tRInterval inter = {r_anal_function_min_addr (fcn), r_anal_function_linear_size (fcn) };\n\t\t\tRListInfo *info = r_listinfo_new (r_core_anal_fcn_name (core, fcn), inter, inter, -1, sdb_itoa (fcn->bits, temp, 10));\n\t\t\tif (!info) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_list_append (flist, info);\n\t\t}\n\t\tRTable *table = r_core_table (core, \"functions\");\n\t\tr_table_visual_list (table, flist, core->offset, core->blocksize,\n\t\t\tr_cons_get_size (NULL), r_config_get_i (core->config, \"scr.color\"));\n\t\tr_cons_printf (\"\\n%s\\n\", r_table_tostring (table));\n\t\tr_table_free (table);\n\t\tr_list_free (flist);\n\t\tbreak;\n\t\t}\n\tcase ',': // \"afl,\" \"afl,j\"\n\tcase 't': // \"aflt\" \"afltj\"\n\t\tif (rad[1] == 'j') {\n\t\t\tfcn_list_table (core, r_str_trim_head_ro (rad + 2), 'j');\n\t\t} else {\n\t\t\tfcn_list_table (core, r_str_trim_head_ro (rad + 1), rad[1]);\n\t\t}\n\t\tbreak;\n\tcase 'l': // \"afll\" \"afllj\"\n\t\tif (rad[1] == 'j') {\n\t\t\tfcn_list_verbose_json (core, fcns);\n\t\t} else {\n\t\t\tchar *sp = strchr (rad, ' ');\n\t\t\tfcn_list_verbose (core, fcns, sp?sp+1: NULL);\n\t\t}\n\t\tbreak;\n\tcase 'q':\n\t\tif (rad[1] == 'j') {\n\t\t\tfcn_list_json (core, fcns, true);\n\t\t} else {\n\t\t\tfcn_list_default (core, fcns, true);\n\t\t}\n\t\tbreak;\n\tcase 'j':\n\t\tfcn_list_json (core, fcns, false);\n\t\tbreak;\n\tcase '*':\n\t\tfcn_list_detail (core, fcns);\n\t\tbreak;\n\tcase 'm': // \"aflm\"\n\t\t{\n\t\t\tchar mode = 'm';\n\t\t\tif (rad[1] != 0) {\n\t\t\t\tif (rad[1] == 'j') { // \"aflmj\"\n\t\t\t\t\tmode = 'j';\n\t\t\t\t} else if (rad[1] == 'q') { // \"aflmq\"\n\t\t\t\t\tmode = 'q';\n\t\t\t\t}\n\t\t\t}\n\t\t\tfcn_print_makestyle (core, fcns, mode);\n\t\t\tbreak;\n\t\t}\n\tcase 1:\n\t\tfcn_list_legacy (core, fcns);\n\t\tbreak;\n\tdefault:\n\t\tfcn_list_default (core, fcns, false);\n\t\tbreak;\n\t}\n\tr_list_free (fcns);\n\treturn 0;\n}\n\nstatic RList *recurse_bb(RCore *core, ut64 addr, RAnalBlock *dest);\n\nstatic RList *recurse(RCore *core, RAnalBlock *from, RAnalBlock *dest) {\n\trecurse_bb (core, from->jump, dest);\n\trecurse_bb (core, from->fail, dest);\n\n\t/* same for all calls */\n\t// TODO: RAnalBlock must contain a linked list of calls\n\treturn NULL;\n}\n\nstatic RList *recurse_bb(RCore *core, ut64 addr, RAnalBlock *dest) {\n\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, addr);\n\tif (bb == dest) {\n\t\teprintf (\"path found!\");\n\t\treturn NULL;\n\t}\n\treturn recurse (core, bb, dest);\n}\n\n#define REG_SET_SIZE (R_ANAL_CC_MAXARG + 2)\n\ntypedef struct {\n\tint count;\n\tRPVector reg_set;\n\tbool argonly;\n\tRAnalFunction *fcn;\n\tRCore *core;\n} BlockRecurseCtx;\n\nstatic bool anal_block_on_exit(RAnalBlock *bb, BlockRecurseCtx *ctx) {\n\tint *cur_regset = r_pvector_pop (&ctx->reg_set);\n\tint *prev_regset = r_pvector_at (&ctx->reg_set, r_pvector_len (&ctx->reg_set) - 1);\n\tsize_t i;\n\tfor (i = 0; i < REG_SET_SIZE; i++) {\n\t\tif (!prev_regset[i] && cur_regset[i] == 1) {\n\t\t\tprev_regset[i] = 1;\n\t\t}\n\t}\n\tfree (cur_regset);\n\treturn true;\n}\n\nstatic bool anal_block_cb(RAnalBlock *bb, BlockRecurseCtx *ctx) {\n\tif (r_cons_is_breaked ()) {\n\t\treturn false;\n\t}\n\tif (bb->size < 1) {\n\t\treturn true;\n\t}\n\tif (bb->size > ctx->core->anal->opt.bb_max_size) {\n\t\treturn true;\n\t}\n\tint *parent_reg_set = r_pvector_at (&ctx->reg_set, r_pvector_len (&ctx->reg_set) - 1);\n\tint *reg_set = R_NEWS (int, REG_SET_SIZE);\n\tmemcpy (reg_set, parent_reg_set, REG_SET_SIZE * sizeof (int));\n\tr_pvector_push (&ctx->reg_set, reg_set);\n\tRCore *core = ctx->core;\n\tRAnalFunction *fcn = ctx->fcn;\n\tfcn->stack = bb->parent_stackptr;\n\tut64 pos = bb->addr;\n\twhile (pos < bb->addr + bb->size) {\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tRAnalOp *op = r_core_anal_op (core, pos, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_HINT);\n\t\tif (!op) {\n\t\t\t//eprintf (\"Cannot get op\\n\");\n\t\t\tbreak;\n\t\t}\n\t\tr_anal_extract_rarg (core->anal, op, fcn, reg_set, &ctx->count);\n\t\tif (!ctx->argonly) {\n\t\t\tif (op->stackop == R_ANAL_STACK_INC) {\n\t\t\t\tfcn->stack += op->stackptr;\n\t\t\t} else if (op->stackop == R_ANAL_STACK_RESET) {\n\t\t\t\tfcn->stack = 0;\n\t\t\t}\n\t\t\tr_anal_extract_vars (core->anal, fcn, op);\n\t\t}\n\t\tint opsize = op->size;\n\t\tint optype = op->type;\n\t\tr_anal_op_free (op);\n\t\tif (opsize < 1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (optype == R_ANAL_OP_TYPE_CALL) {\n\t\t\tsize_t i;\n\t\t\tint max_count = fcn->cc ? r_anal_cc_max_arg (core->anal, fcn->cc) : 0;\n\t\t\tfor (i = 0; i < max_count; i++) {\n\t\t\t\treg_set[i] = 2;\n\t\t\t}\n\t\t}\n\t\tpos += opsize;\n\t}\n\treturn true;\n}\n\n// TODO: move this logic into the main anal loop\nR_API void r_core_recover_vars(RCore *core, RAnalFunction *fcn, bool argonly) {\n\tr_return_if_fail (core && core->anal && fcn);\n\tif (core->anal->opt.bb_max_size < 1) {\n\t\treturn;\n\t}\n\tBlockRecurseCtx ctx = { 0, {{ 0 }}, argonly, fcn, core };\n\tr_pvector_init (&ctx.reg_set, free);\n\tint *reg_set = R_NEWS0 (int, REG_SET_SIZE);\n\tr_pvector_push (&ctx.reg_set, reg_set);\n\tint saved_stack = fcn->stack;\n\tRAnalBlock *first_bb = r_anal_get_block_at (fcn->anal, fcn->addr);\n\tr_anal_block_recurse_depth_first (first_bb, (RAnalBlockCb)anal_block_cb, (RAnalBlockCb)anal_block_on_exit, &ctx);\n\tr_pvector_fini (&ctx.reg_set);\n\tfcn->stack = saved_stack;\n}\n\nstatic bool anal_path_exists(RCore *core, ut64 from, ut64 to, RList *bbs, int depth, HtUP *state, HtUP *avoid) {\n\tr_return_val_if_fail (bbs, false);\n\tRAnalBlock *bb = r_anal_bb_from_offset (core->anal, from);\n\tRListIter *iter = NULL;\n\tRAnalRef *refi;\n\n\tif (depth < 0) {\n\t\teprintf (\"going too deep\\n\");\n\t\treturn false;\n\t}\n\n\tif (!bb) {\n\t\treturn false;\n\t}\n\n\tht_up_update (state, from, bb);\n\n\t// try to find the target in the current function\n\tif (r_anal_block_contains (bb, to) ||\n\t\t((!ht_up_find (avoid, bb->jump, NULL) &&\n\t\t\t!ht_up_find (state, bb->jump, NULL) &&\n\t\t\tanal_path_exists (core, bb->jump, to, bbs, depth - 1, state, avoid))) ||\n\t\t((!ht_up_find (avoid, bb->fail, NULL) &&\n\t\t\t!ht_up_find (state, bb->fail, NULL) &&\n\t\t\tanal_path_exists (core, bb->fail, to, bbs, depth - 1, state, avoid)))) {\n\t\tr_list_prepend (bbs, bb);\n\t\treturn true;\n\t}\n\n\t// find our current function\n\tRAnalFunction *cur_fcn = r_anal_get_fcn_in (core->anal, from, 0);\n\n\t// get call refs from current basic block and find a path from them\n\tif (cur_fcn) {\n\t\tRList *refs = r_anal_function_get_refs (cur_fcn);\n\t\tif (refs) {\n\t\t\tr_list_foreach (refs, iter, refi) {\n\t\t\t\tif (refi->type == R_ANAL_REF_TYPE_CALL) {\n\t\t\t\t\tif (r_anal_block_contains (bb, refi->at)) {\n\t\t\t\t\t\tif ((refi->at != refi->addr) && !ht_up_find (state, refi->addr, NULL) && anal_path_exists (core, refi->addr, to, bbs, depth - 1, state, avoid)) {\n\t\t\t\t\t\t\tr_list_prepend (bbs, bb);\n\t\t\t\t\t\t\tr_list_free (refs);\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tr_list_free (refs);\n\t}\n\n\treturn false;\n}\n\nstatic RList *anal_graph_to(RCore *core, ut64 addr, int depth, HtUP *avoid) {\n\tRAnalFunction *cur_fcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\tRList *list = r_list_new ();\n\tHtUP *state = ht_up_new0 ();\n\n\tif (!list || !state || !cur_fcn) {\n\t\tr_list_free (list);\n\t\tht_up_free (state);\n\t\treturn NULL;\n\t}\n\n\t// forward search\n\tif (anal_path_exists (core, core->offset, addr, list, depth - 1, state, avoid)) {\n\t\tht_up_free (state);\n\t\treturn list;\n\t}\n\n\t// backward search\n\tRList *xrefs = r_anal_xrefs_get (core->anal, cur_fcn->addr);\n\tif (xrefs) {\n\t\tRListIter *iter;\n\t\tRAnalRef *xref = NULL;\n\t\tr_list_foreach (xrefs, iter, xref) {\n\t\t\tif (xref->type == R_ANAL_REF_TYPE_CALL) {\n\t\t\t\tut64 offset = core->offset;\n\t\t\t\tcore->offset = xref->addr;\n\t\t\t\tr_list_free (list);\n\t\t\t\tlist = anal_graph_to (core, addr, depth - 1, avoid);\n\t\t\t\tcore->offset = offset;\n\t\t\t\tif (list && r_list_length (list)) {\n\t\t\t\t\tr_list_free (xrefs);\n\t\t\t\t\tht_up_free (state);\n\t\t\t\t\treturn list;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tr_list_free (xrefs);\n\tht_up_free (state);\n\tr_list_free (list);\n\treturn NULL;\n}\n\nR_API RList* r_core_anal_graph_to(RCore *core, ut64 addr, int n) {\n\tint depth = r_config_get_i (core->config, \"anal.graph_depth\");\n\tRList *path, *paths = r_list_new ();\n\tHtUP *avoid = ht_up_new0 ();\n\twhile (n) {\n\t\tpath = anal_graph_to (core, addr, depth, avoid);\n\t\tif (path) {\n\t\t\tr_list_append (paths, path);\n\t\t\tif (r_list_length (path) >= 2) {\n\t\t\t\tRAnalBlock *last = r_list_get_n (path, r_list_length (path) - 2);\n\t\t\t\tht_up_update (avoid, last->addr, last);\n\t\t\t\tn--;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\t// no more path found\n\t\tbreak;\n\t}\n\tht_up_free (avoid);\n\treturn paths;\n}\n\nR_API int r_core_anal_graph(RCore *core, ut64 addr, int opts) {\n\tut64 from = r_config_get_i (core->config, \"graph.from\");\n\tut64 to = r_config_get_i (core->config, \"graph.to\");\n\tconst char *font = r_config_get (core->config, \"graph.font\");\n\tint is_html = r_cons_context ()->is_html;\n\tint is_json = opts & R_CORE_ANAL_JSON;\n\tint is_json_format_disasm = opts & R_CORE_ANAL_JSON_FORMAT_DISASM;\n\tint is_keva = opts & R_CORE_ANAL_KEYVALUE;\n\tint is_star = opts & R_CORE_ANAL_STAR;\n\tRConfigHold *hc;\n\tRAnalFunction *fcni;\n\tRListIter *iter;\n\tint nodes = 0;\n\tPJ *pj = NULL;\n\n\tif (!addr) {\n\t\taddr = core->offset;\n\t}\n\tif (r_list_empty (core->anal->fcns)) {\n\t\treturn false;\n\t}\n\thc = r_config_hold_new (core->config);\n\tif (!hc) {\n\t\treturn false;\n\t}\n\n\tr_config_hold (hc, \"asm.lines\", \"asm.bytes\", \"asm.dwarf\", NULL);\n\t//opts |= R_CORE_ANAL_GRAPHBODY;\n\tr_config_set_i (core->config, \"asm.lines\", 0);\n\tr_config_set_i (core->config, \"asm.dwarf\", 0);\n\tif (!is_json_format_disasm) {\n\t\tr_config_hold (hc, \"asm.bytes\", NULL);\n\t\tr_config_set_i (core->config, \"asm.bytes\", 0);\n\t}\n\tif (!is_html && !is_json && !is_keva && !is_star) {\n\t\tconst char * gv_edge = r_config_get (core->config, \"graph.gv.edge\");\n\t\tconst char * gv_node = r_config_get (core->config, \"graph.gv.node\");\n\t\tconst char * gv_spline = r_config_get (core->config, \"graph.gv.spline\");\n\t\tif (!gv_edge || !*gv_edge) {\n\t\t\tgv_edge = \"arrowhead=\\\"normal\\\"\";\n\t\t}\n\t\tif (!gv_node || !*gv_node) {\n\t\t\tgv_node = \"fillcolor=gray style=filled shape=box\";\n\t\t}\n\t\tif (!gv_spline || !*gv_spline) {\n\t\t\tgv_spline = \"splines=\\\"ortho\\\"\";\n\t\t}\n\t\tr_cons_printf (\"digraph code {\\n\"\n\t\t\t\"\\tgraph [bgcolor=azure fontsize=8 fontname=\\\"%s\\\" %s];\\n\"\n\t\t\t\"\\tnode [%s];\\n\"\n\t\t\t\"\\tedge [%s];\\n\", font, gv_spline, gv_node, gv_edge);\n\t}\n\tif (is_json) {\n\t\tpj = r_core_pj_new (core);\n\t\tif (!pj) {\n\t\t\tr_config_hold_restore (hc);\n\t\t\tr_config_hold_free (hc);\n\t\t\treturn false;\n\t\t}\n\t\tpj_a (pj);\n\t}\n\tr_list_foreach (core->anal->fcns, iter, fcni) {\n\t\tif (fcni->type & (R_ANAL_FCN_TYPE_SYM | R_ANAL_FCN_TYPE_FCN |\n\t\t\t\t\t\t  R_ANAL_FCN_TYPE_LOC) &&\n\t\t\t(addr == UT64_MAX || r_anal_get_fcn_in (core->anal, addr, 0) == fcni)) {\n\t\t\tif (addr == UT64_MAX && (from != UT64_MAX && to != UT64_MAX)) {\n\t\t\t\tif (fcni->addr < from || fcni->addr > to) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnodes += core_anal_graph_nodes (core, fcni, opts, pj);\n\t\t\tif (addr != UT64_MAX) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (!nodes) {\n\t\tif (!is_html && !is_json && !is_keva) {\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\t\t\tif (is_star) {\n\t\t\t\t\tchar *name = get_title(fcn ? fcn->addr: addr);\n\t\t\t\t\tr_cons_printf (\"agn %s;\", name);\n\t\t\t} else {\n\t\t\t\tr_cons_printf (\"\\t\\\"0x%08\"PFMT64x\"\\\";\\n\", fcn? fcn->addr: addr);\n\t\t\t}\n\t\t}\n\t}\n\tif (!is_keva && !is_html && !is_json && !is_star && !is_json_format_disasm) {\n\t\tr_cons_printf (\"}\\n\");\n\t}\n\tif (is_json) {\n\t\tpj_end (pj);\n\t\tr_cons_printf (\"%s\\n\", pj_string (pj));\n\t\tpj_free (pj);\n\t}\n\tr_config_hold_restore (hc);\n\tr_config_hold_free (hc);\n\treturn true;\n}\n\nstatic int core_anal_followptr(RCore *core, int type, ut64 at, ut64 ptr, ut64 ref, int code, int depth) {\n\t// SLOW Operation try to reduce as much as possible\n\tif (!ptr) {\n\t\treturn false;\n\t}\n\tif (ref == UT64_MAX || ptr == ref) {\n\t\tconst RAnalRefType t = code? type? type: R_ANAL_REF_TYPE_CODE: R_ANAL_REF_TYPE_DATA;\n\t\tr_anal_xrefs_set (core->anal, at, ptr, t);\n\t\treturn true;\n\t}\n\tif (depth < 0) {\n\t\treturn false;\n\t}\n\tint wordsize = (int)(core->anal->bits / 8);\n\tut64 dataptr;\n\tif (!r_io_read_i (core->io, ptr, &dataptr, wordsize, false)) {\n\t\t// eprintf (\"core_anal_followptr: Cannot read word at destination\\n\");\n\t\treturn false;\n\t}\n\treturn core_anal_followptr (core, type, at, dataptr, ref, code, depth - 1);\n}\n\nstatic bool opiscall(RCore *core, RAnalOp *aop, ut64 addr, const ut8* buf, int len, int arch) {\n\tswitch (arch) {\n\tcase R2_ARCH_ARM64:\n\t\taop->size = 4;\n\t\t//addr should be aligned by 4 in aarch64\n\t\tif (addr % 4) {\n\t\t\tchar diff = addr % 4;\n\t\t\taddr = addr - diff;\n\t\t\tbuf = buf - diff;\n\t\t}\n\t\t//if is not bl do not analyze\n\t\tif (buf[3] == 0x94) {\n\t\t\tif (r_anal_op (core->anal, aop, addr, buf, len, R_ANAL_OP_MASK_BASIC)) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\taop->size = 1;\n\t\tif (r_anal_op (core->anal, aop, addr, buf, len, R_ANAL_OP_MASK_BASIC)) {\n\t\t\tswitch (aop->type & R_ANAL_OP_TYPE_MASK) {\n\t\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\tcase R_ANAL_OP_TYPE_CCALL:\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\tbreak;\n\t}\n\treturn false;\n}\n\n// TODO(maskray) RAddrInterval API\n#define OPSZ 8\nR_API int r_core_anal_search(RCore *core, ut64 from, ut64 to, ut64 ref, int mode) {\n\tut8 *buf = (ut8 *)malloc (core->blocksize);\n\tif (!buf) {\n\t\treturn -1;\n\t}\n\tint ptrdepth = r_config_get_i (core->config, \"anal.ptrdepth\");\n\tint i, count = 0;\n\tRAnalOp op = R_EMPTY;\n\tut64 at;\n\tchar bckwrds, do_bckwrd_srch;\n\tint arch = -1;\n\tif (core->rasm->bits == 64) {\n\t\t// speedup search\n\t\tif (!strncmp (core->rasm->cur->name, \"arm\", 3)) {\n\t\t\tarch = R2_ARCH_ARM64;\n\t\t}\n\t}\n\t// TODO: get current section range here or gtfo\n\t// ???\n\t// XXX must read bytes correctly\n\tdo_bckwrd_srch = bckwrds = core->search->bckwrds;\n\tif (!ref) {\n\t\teprintf (\"Null reference search is not supported\\n\");\n\t\tfree (buf);\n\t\treturn -1;\n\t}\n\tr_cons_break_push (NULL, NULL);\n\tif (core->blocksize > OPSZ) {\n\t\tif (bckwrds) {\n\t\t\tif (from + core->blocksize > to) {\n\t\t\t\tat = from;\n\t\t\t\tdo_bckwrd_srch = false;\n\t\t\t} else {\n\t\t\t\tat = to - core->blocksize;\n\t\t\t}\n\t\t} else {\n\t\t\tat = from;\n\t\t}\n\t\twhile ((!bckwrds && at < to) || bckwrds) {\n\t\t\teprintf (\"\\r[0x%08\"PFMT64x\"-0x%08\"PFMT64x\"] \", at, to);\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// TODO: this can be probably enhanced\n\t\t\tif (!r_io_read_at (core->io, at, buf, core->blocksize)) {\n\t\t\t\teprintf (\"Failed to read at 0x%08\" PFMT64x \"\\n\", at);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor (i = bckwrds ? (core->blocksize - OPSZ - 1) : 0;\n\t\t\t\t (!bckwrds && i < core->blocksize - OPSZ) ||\n\t\t\t\t (bckwrds && i > 0);\n\t\t\t\t bckwrds ? i-- : i++) {\n\t\t\t\t// TODO: honor anal.align\n\t\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tswitch (mode) {\n\t\t\t\tcase 'c':\n\t\t\t\t\t(void)opiscall (core, &op, at + i, buf + i, core->blocksize - i, arch);\n\t\t\t\t\tif (op.size < 1) {\n\t\t\t\t\t\top.size = 1;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'r':\n\t\t\t\tcase 'w':\n\t\t\t\tcase 'x':\n\t\t\t\t\t{\n\t\t\t\t\t\tr_anal_op (core->anal, &op, at + i, buf + i, core->blocksize - i, R_ANAL_OP_MASK_BASIC);\n\t\t\t\t\t\tint mask = mode=='r' ? 1 : mode == 'w' ? 2: mode == 'x' ? 4: 0;\n\t\t\t\t\t\tif (op.direction == mask) {\n\t\t\t\t\t\t\ti += op.size;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr_anal_op_fini (&op);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tif (!r_anal_op (core->anal, &op, at + i, buf + i, core->blocksize - i, R_ANAL_OP_MASK_BASIC)) {\n\t\t\t\t\t\tr_anal_op_fini (&op);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tswitch (op.type) {\n\t\t\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\t\tcase R_ANAL_OP_TYPE_CCALL:\n\t\t\t\t\tif (op.jump != UT64_MAX &&\n\t\t\t\t\t\tcore_anal_followptr (core, 'C', at + i, op.jump, ref, true, 0)) {\n\t\t\t\t\t\tcount ++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_OP_TYPE_UCJMP:\n\t\t\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\t\t\tcase R_ANAL_OP_TYPE_IJMP:\n\t\t\t\tcase R_ANAL_OP_TYPE_RJMP:\n\t\t\t\tcase R_ANAL_OP_TYPE_IRJMP:\n\t\t\t\tcase R_ANAL_OP_TYPE_MJMP:\n\t\t\t\t\tif (op.ptr != UT64_MAX &&\n\t\t\t\t\t\tcore_anal_followptr (core, 'c', at + i, op.ptr, ref, true ,1)) {\n\t\t\t\t\t\tcount ++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\t\t\tcase R_ANAL_OP_TYPE_ICALL:\n\t\t\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\t\t\tcase R_ANAL_OP_TYPE_IRCALL:\n\t\t\t\tcase R_ANAL_OP_TYPE_UCCALL:\n\t\t\t\t\tif (op.ptr != UT64_MAX &&\n\t\t\t\t\t\tcore_anal_followptr (core, 'C', at + i, op.ptr, ref, true ,1)) {\n\t\t\t\t\t\tcount ++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!r_anal_op (core->anal, &op, at + i, buf + i, core->blocksize - i, R_ANAL_OP_MASK_BASIC)) {\n\t\t\t\t\t\t\tr_anal_op_fini (&op);\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (op.ptr != UT64_MAX &&\n\t\t\t\t\t\tcore_anal_followptr (core, 'd', at + i, op.ptr, ref, false, ptrdepth)) {\n\t\t\t\t\t\tcount ++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (op.size < 1) {\n\t\t\t\t\top.size = 1;\n\t\t\t\t}\n\t\t\t\ti += op.size - 1;\n\t\t\t\tr_anal_op_fini (&op);\n\t\t\t}\n\t\t\tif (bckwrds) {\n\t\t\t\tif (!do_bckwrd_srch) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (at > from + core->blocksize - OPSZ) {\n\t\t\t\t\tat -= core->blocksize;\n\t\t\t\t} else {\n\t\t\t\t\tdo_bckwrd_srch = false;\n\t\t\t\t\tat = from;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tat += core->blocksize - OPSZ;\n\t\t\t}\n\t\t}\n\t} else {\n\t\teprintf (\"error: block size too small\\n\");\n\t}\n\tr_cons_break_pop ();\n\tfree (buf);\n\tr_anal_op_fini (&op);\n\treturn count;\n}\n\nstatic bool found_xref(RCore *core, ut64 at, ut64 xref_to, RAnalRefType type, PJ *pj, int rad, bool cfg_debug, bool cfg_anal_strings) {\n\t// Validate the reference. If virtual addressing is enabled, we\n\t// allow only references to virtual addresses in order to reduce\n\t// the number of false positives. In debugger mode, the reference\n\t// must point to a mapped memory region.\n\tif (type == R_ANAL_REF_TYPE_NULL) {\n\t\treturn false;\n\t}\n\tif (cfg_debug) {\n\t\tif (!r_debug_map_get (core->dbg, xref_to)) {\n\t\t\treturn false;\n\t\t}\n\t} else if (core->io->va) {\n\t\tif (!r_io_is_valid_offset (core->io, xref_to, 0)) {\n\t\t\treturn false;\n\t\t}\n\t}\n\tif (!rad) {\n\t\tif (cfg_anal_strings && type == R_ANAL_REF_TYPE_DATA) {\n\t\t\tint len = 0;\n\t\t\tchar *str_string = is_string_at (core, xref_to, &len);\n\t\t\tif (str_string) {\n\t\t\t\tr_name_filter (str_string, -1);\n\t\t\t\tchar *str_flagname = r_str_newf (\"str.%s\", str_string);\n\t\t\t\tr_flag_space_push (core->flags, R_FLAGS_FS_STRINGS);\n\t\t\t\t(void)r_flag_set (core->flags, str_flagname, xref_to, 1);\n\t\t\t\tr_flag_space_pop (core->flags);\n\t\t\t\tfree (str_flagname);\n\t\t\t\tif (len > 0) {\n\t\t\t\t\tr_meta_set (core->anal, R_META_TYPE_STRING, xref_to,\n\t\t\t\t\t\t\t\tlen, (const char *) str_string);\n\t\t\t\t}\n\t\t\t\tfree (str_string);\n\t\t\t}\n\t\t}\n\t\t// Add to SDB\n\t\tif (xref_to) {\n\t\t\tr_anal_xrefs_set (core->anal, at, xref_to, type);\n\t\t}\n\t} else if (rad == 'j') {\n\t\tr_strf_var (key, 32, \"0x%\"PFMT64x, xref_to);\n\t\tr_strf_var (value, 32, \"0x%\"PFMT64x, at);\n\t\tpj_ks (pj, key, value);\n\t} else {\n\t\tint len = 0;\n\t\t// Display in radare commands format\n\t\tchar *cmd;\n\t\tswitch (type) {\n\t\tcase R_ANAL_REF_TYPE_CODE: cmd = \"axc\"; break;\n\t\tcase R_ANAL_REF_TYPE_CALL: cmd = \"axC\"; break;\n\t\tcase R_ANAL_REF_TYPE_DATA: cmd = \"axd\"; break;\n\t\tdefault: cmd = \"ax\"; break;\n\t\t}\n\t\tr_cons_printf (\"%s 0x%08\"PFMT64x\" 0x%08\"PFMT64x\"\\n\", cmd, xref_to, at);\n\t\tif (cfg_anal_strings && type == R_ANAL_REF_TYPE_DATA) {\n\t\t\tchar *str_flagname = is_string_at (core, xref_to, &len);\n\t\t\tif (str_flagname) {\n\t\t\t\tut64 str_addr = xref_to;\n\t\t\t\tr_name_filter (str_flagname, -1);\n\t\t\t\tr_cons_printf (\"f str.%s=0x%\"PFMT64x\"\\n\", str_flagname, str_addr);\n\t\t\t\tr_cons_printf (\"Cs %d @ 0x%\"PFMT64x\"\\n\", len, str_addr);\n\t\t\t\tfree (str_flagname);\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nR_API int r_core_anal_search_xrefs(RCore *core, ut64 from, ut64 to, PJ *pj, int rad) {\n\tconst bool cfg_debug = r_config_get_b (core->config, \"cfg.debug\");\n\tbool cfg_anal_strings = r_config_get_i (core->config, \"anal.strings\");\n\tut64 at;\n\tint count = 0;\n\tint bsz = 8096;\n\tRAnalOp op = { 0 };\n\n\tif (from == to) {\n\t\treturn -1;\n\t}\n\tif (from > to) {\n\t\teprintf (\"Invalid range (0x%\"PFMT64x\n\t\t\" >= 0x%\"PFMT64x\")\\n\", from, to);\n\t\treturn -1;\n\t}\n\n\tif (core->blocksize <= OPSZ) {\n\t\teprintf (\"Error: block size too small\\n\");\n\t\treturn -1;\n\t}\n\tut8 *buf = malloc (bsz);\n\tif (!buf) {\n\t\teprintf (\"Error: cannot allocate a block\\n\");\n\t\treturn -1;\n\t}\n\tut8 *block = malloc (bsz);\n\tif (!block) {\n\t\teprintf (\"Error: cannot allocate a temp block\\n\");\n\t\tfree (buf);\n\t\treturn -1;\n\t}\n\tr_cons_break_push (NULL, NULL);\n\tat = from;\n\tst64 asm_sub_varmin = r_config_get_i (core->config, \"asm.sub.varmin\");\n\tint maxopsz = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MAX_OP_SIZE);\n\tint minopsz = r_anal_archinfo (core->anal, R_ANAL_ARCHINFO_MIN_OP_SIZE);\n\tif (maxopsz < 1) {\n\t\tmaxopsz = 4;\n\t}\n\tif (minopsz < 1) {\n\t\tminopsz = 1;\n\t}\n\tif (bsz < maxopsz) {\n\t\t// wtf\n\t\teprintf (\"Error: Something is really wrong deep inside\\n\");\n\t\tfree (block);\n\t\treturn -1;\n\t}\n\twhile (at < to && !r_cons_is_breaked ()) {\n\t\tint i = 0, ret = bsz;\n\t\tif (!r_io_is_valid_offset (core->io, at, R_PERM_X)) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 left = to - at;\n\t\tif (bsz > left) {\n\t\t\tbsz = left;\n\t\t}\n\t\t(void)r_io_read_at (core->io, at, buf, bsz);\n\t\tmemset (block, -1, bsz);\n\t\tif (!memcmp (buf, block, bsz)) {\n\t\t//\teprintf (\"Error: skipping uninitialized block \\n\");\n\t\t\tat += ret;\n\t\t\tcontinue;\n\t\t}\n\t\tmemset (block, 0, bsz);\n\t\tif (!memcmp (buf, block, bsz)) {\n\t\t//\teprintf (\"Error: skipping uninitialized block \\n\");\n\t\t\tat += ret;\n\t\t\tcontinue;\n\t\t}\n\t\t(void) r_anal_op (core->anal, &op, at, buf, bsz, R_ANAL_OP_MASK_BASIC | R_ANAL_OP_MASK_HINT);\n\t\twhile ((i + maxopsz) < bsz && !r_cons_is_breaked ()) {\n\t\t\tr_anal_op_fini (&op);\n\t\t\tret = r_anal_op (core->anal, &op, at + i, buf + i, bsz - i, R_ANAL_OP_MASK_BASIC | R_ANAL_OP_MASK_HINT);\n\t\t\tif (ret < 1) {\n\t\t\t\ti += minopsz;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ti += ret;\n\t\t\tif (i > bsz) {\n\t\t\t\t// at += minopsz;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// find references\n\t\t\tif ((st64)op.val > asm_sub_varmin && op.val != UT64_MAX && op.val != UT32_MAX) {\n\t\t\t\tif (found_xref (core, op.addr, op.val, R_ANAL_REF_TYPE_DATA, pj, rad, cfg_debug, cfg_anal_strings)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// find references\n\t\t\tif (op.ptr && op.ptr != UT64_MAX && op.ptr != UT32_MAX) {\n\t\t\t\tif (found_xref (core, op.addr, op.ptr, R_ANAL_REF_TYPE_DATA, pj, rad, cfg_debug, cfg_anal_strings)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// find references\n\t\t\tif (op.addr > 512 && op.disp > 512 && op.disp && op.disp != UT64_MAX) {\n\t\t\t\tif (found_xref (core, op.addr, op.disp, R_ANAL_REF_TYPE_DATA, pj, rad, cfg_debug, cfg_anal_strings)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tswitch (op.type) {\n\t\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\t\tif (found_xref (core, op.addr, op.jump, R_ANAL_REF_TYPE_CODE, pj, rad, cfg_debug, cfg_anal_strings)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\tcase R_ANAL_OP_TYPE_CCALL:\n\t\t\t\tif (found_xref (core, op.addr, op.jump, R_ANAL_REF_TYPE_CALL, pj, rad, cfg_debug, cfg_anal_strings)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\t\tcase R_ANAL_OP_TYPE_IJMP:\n\t\t\tcase R_ANAL_OP_TYPE_RJMP:\n\t\t\tcase R_ANAL_OP_TYPE_IRJMP:\n\t\t\tcase R_ANAL_OP_TYPE_MJMP:\n\t\t\tcase R_ANAL_OP_TYPE_UCJMP:\n\t\t\t\tcount++;\n\t\t\t\tif (found_xref (core, op.addr, op.ptr, R_ANAL_REF_TYPE_CODE, pj, rad, cfg_debug, cfg_anal_strings)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\t\tcase R_ANAL_OP_TYPE_ICALL:\n\t\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\t\tcase R_ANAL_OP_TYPE_IRCALL:\n\t\t\tcase R_ANAL_OP_TYPE_UCCALL:\n\t\t\t\tif (found_xref (core, op.addr, op.ptr, R_ANAL_REF_TYPE_CALL, pj, rad, cfg_debug, cfg_anal_strings)) {\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tr_anal_op_fini (&op);\n\t\tif (i < 1) {\n\t\t\tbreak;\n\t\t}\n\t\tat += i + 1;\n\t}\n\tr_cons_break_pop ();\n\tfree (buf);\n\tfree (block);\n\treturn count;\n}\n\nstatic bool isValidSymbol(RBinSymbol *symbol) {\n\tif (symbol && symbol->type) {\n\t\tconst char *type = symbol->type;\n\t\treturn (symbol->paddr != UT64_MAX) && (!strcmp (type, R_BIN_TYPE_FUNC_STR) || !strcmp (type, R_BIN_TYPE_HIOS_STR) || !strcmp (type, R_BIN_TYPE_LOOS_STR) || !strcmp (type, R_BIN_TYPE_METH_STR) || !strcmp (type , R_BIN_TYPE_STATIC_STR));\n\t}\n\treturn false;\n}\n\nstatic bool isSkippable(RBinSymbol *s) {\n\tif (s && s->name && s->bind) {\n\t\tif (r_str_startswith (s->name, \"radr://\")) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!strcmp (s->name, \"__mh_execute_header\")) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!strcmp (s->bind, \"NONE\")) {\n\t\t\tif (s->is_imported && s->libname && strstr(s->libname, \".dll\")) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\treturn false;\n}\n\nR_API int r_core_anal_all(RCore *core) {\n\tRList *list;\n\tRListIter *iter;\n\tRFlagItem *item;\n\tRAnalFunction *fcni;\n\tRBinAddr *binmain;\n\tRBinAddr *entry;\n\tRBinSymbol *symbol;\n\tconst bool anal_vars = r_config_get_i (core->config, \"anal.vars\");\n\tconst bool anal_calls = r_config_get_i (core->config, \"anal.calls\");\n\n\t/* Analyze Functions */\n\t/* Entries */\n\titem = r_flag_get (core->flags, \"entry0\");\n\tif (item) {\n\t\tr_core_af (core, item->offset, \"entry0\", anal_calls);\n\t} else {\n\t\tr_core_af (core, core->offset, NULL, anal_calls);\n\t}\n\n\tr_core_task_yield (&core->tasks);\n\n\tr_cons_break_push (NULL, NULL);\n\t/* Symbols (Imports are already analyzed by rabin2 on init) */\n\tif ((list = r_bin_get_symbols (core->bin)) != NULL) {\n\t\tr_list_foreach (list, iter, symbol) {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// Stop analyzing PE imports further\n\t\t\tif (isSkippable (symbol)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (isValidSymbol (symbol)) {\n\t\t\t\tut64 addr = r_bin_get_vaddr (core->bin, symbol->paddr, symbol->vaddr);\n\t\t\t\t// TODO: uncomment to: fcn.name = symbol.name, problematic for imports\n\t\t\t\t// r_core_af (core, addr, symbol->name, anal_calls);\n\t\t\t\tr_core_af (core, addr, NULL, anal_calls);\n\t\t\t}\n\t\t}\n\t}\n\tr_core_task_yield (&core->tasks);\n\t/* Main */\n\tif ((binmain = r_bin_get_sym (core->bin, R_BIN_SYM_MAIN))) {\n\t\tif (binmain->paddr != UT64_MAX) {\n\t\t\tut64 addr = r_bin_get_vaddr (core->bin, binmain->paddr, binmain->vaddr);\n\t\t\tr_core_af (core, addr, \"main\", anal_calls);\n\t\t}\n\t}\n\tr_core_task_yield (&core->tasks);\n\tif ((list = r_bin_get_entries (core->bin))) {\n\t\tr_list_foreach (list, iter, entry) {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (entry->paddr == UT64_MAX) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut64 addr = r_bin_get_vaddr (core->bin, entry->paddr, entry->vaddr);\n\t\t\tr_core_af (core, addr, NULL, anal_calls);\n\t\t}\n\t}\n\tr_core_task_yield (&core->tasks);\n\tif (anal_vars) {\n\t\t/* Set fcn type to R_ANAL_FCN_TYPE_SYM for symbols */\n\t\tr_list_foreach_prev (core->anal->fcns, iter, fcni) {\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tr_core_recover_vars (core, fcni, true);\n\t\t\tif (!strncmp (fcni->name, \"dbg.\", 4) || !strncmp (fcni->name, \"sym.\", 4) || !strncmp (fcni->name, \"main\", 4)) {\n\t\t\t\tfcni->type = R_ANAL_FCN_TYPE_SYM;\n\t\t\t}\n\t\t}\n\t}\n\tr_cons_break_pop ();\n\treturn true;\n}\n\nR_API int r_core_anal_data(RCore *core, ut64 addr, int count, int depth, int wordsize) {\n\tRAnalData *d;\n\tut64 dstaddr = 0LL;\n\tut8 *buf = core->block;\n\tint len = core->blocksize;\n\tint word = wordsize ? wordsize: core->rasm->bits / 8;\n\tchar *str;\n\tint i, j;\n\n\tcount = R_MIN (count, len);\n\tbuf = malloc (len + 1);\n\tif (!buf) {\n\t\treturn false;\n\t}\n\tmemset (buf, 0xff, len);\n\tr_io_read_at (core->io, addr, buf, len);\n\tbuf[len - 1] = 0;\n\n\tRConsPrintablePalette *pal = r_config_get_i (core->config, \"scr.color\")? &r_cons_context ()->pal: NULL;\n\tfor (i = j = 0; j < count; j++) {\n\t\tif (i >= len) {\n\t\t\tr_io_read_at (core->io, addr + i, buf, len);\n\t\t\tbuf[len] = 0;\n\t\t\taddr += i;\n\t\t\ti = 0;\n\t\t\tcontinue;\n\t\t}\n\t\t/* r_anal_data requires null-terminated buffer according to coverity */\n\t\t/* but it should not.. so this must be fixed in anal/data.c instead of */\n\t\t/* null terminating here */\n\t\td = r_anal_data (core->anal, addr + i, buf + i, len - i, wordsize);\n\t\tstr = r_anal_data_to_string (d, pal);\n\t\tr_cons_println (str);\n\n\t\tif (d) {\n\t\t\tswitch (d->type) {\n\t\t\tcase R_ANAL_DATA_TYPE_POINTER:\n\t\t\t\tr_cons_printf (\"`- \");\n\t\t\t\tdstaddr = r_mem_get_num (buf + i, word);\n\t\t\t\tif (depth > 0) {\n\t\t\t\t\tr_core_anal_data (core, dstaddr, 1, depth - 1, wordsize);\n\t\t\t\t}\n\t\t\t\ti += word;\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_DATA_TYPE_STRING:\n\t\t\t\tbuf[len-1] = 0;\n\t\t\t\ti += strlen ((const char*)buf + i) + 1;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\ti += (d->len > 3)? d->len: word;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\ti += word;\n\t\t}\n\t\tfree (str);\n\t\tr_anal_data_free (d);\n\t}\n\tfree (buf);\n\treturn true;\n}\n\nstruct block_flags_stat_t {\n\tut64 step;\n\tut64 from;\n\tRCoreAnalStats *as;\n};\n\nstatic bool block_flags_stat(RFlagItem *fi, void *user) {\n\tstruct block_flags_stat_t *u = (struct block_flags_stat_t *)user;\n\tint piece = (fi->offset - u->from) / u->step;\n\tu->as->block[piece].flags++;\n\treturn true;\n}\n\n/* core analysis stats */\n/* stats --- colorful bar */\nR_API RCoreAnalStats* r_core_anal_get_stats(RCore *core, ut64 from, ut64 to, ut64 step) {\n\tRAnalFunction *F;\n\tRAnalBlock  *B;\n\tRBinSymbol *S;\n\tRListIter *iter, *iter2;\n\tRCoreAnalStats *as = NULL;\n\tint piece, as_size, blocks;\n\tut64 at;\n\n\tif (from == to || from == UT64_MAX || to == UT64_MAX) {\n\t\teprintf (\"Cannot alloc for this range\\n\");\n\t\treturn NULL;\n\t}\n\tas = R_NEW0 (RCoreAnalStats);\n\tif (!as) {\n\t\treturn NULL;\n\t}\n\tif (step < 1) {\n\t\tstep = 1;\n\t}\n\tblocks = (to - from) / step;\n\tas_size = (1 + blocks) * sizeof (RCoreAnalStatsItem);\n\tas->block = malloc (as_size);\n\tif (!as->block) {\n\t\tfree (as);\n\t\treturn NULL;\n\t}\n\tmemset (as->block, 0, as_size);\n\tfor (at = from; at < to; at += step) {\n\t\tRIOMap *map = r_io_map_get_at (core->io, at);\n\t\tpiece = (at - from) / step;\n\t\tas->block[piece].perm = map ? map->perm: (core->io->desc ? core->io->desc->perm: 0);\n\t}\n\t// iter all flags\n\tstruct block_flags_stat_t u = { .step = step, .from = from, .as = as };\n\tr_flag_foreach_range (core->flags, from, to + 1, block_flags_stat, &u);\n\t// iter all functions\n\tr_list_foreach (core->anal->fcns, iter, F) {\n\t\tif (F->addr < from || F->addr > to) {\n\t\t\tcontinue;\n\t\t}\n\t\tpiece = (F->addr - from) / step;\n\t\tas->block[piece].functions++;\n\t\tut64 last_piece = R_MIN ((F->addr + r_anal_function_linear_size (F) - 1) / step, blocks - 1);\n\t\tfor (; piece <= last_piece; piece++) {\n\t\t\tas->block[piece].in_functions++;\n\t\t}\n\t\t// iter all basic blocks\n\t\tr_list_foreach (F->bbs, iter2, B) {\n\t\t\tif (B->addr < from || B->addr > to) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpiece = (B->addr - from) / step;\n\t\t\tas->block[piece].blocks++;\n\t\t}\n\t}\n\t// iter all symbols\n\tr_list_foreach (r_bin_get_symbols (core->bin), iter, S) {\n\t\tif (S->vaddr < from || S->vaddr > to) {\n\t\t\tcontinue;\n\t\t}\n\t\tpiece = (S->vaddr - from) / step;\n\t\tas->block[piece].symbols++;\n\t}\n\tRPVector *metas = to > from ? r_meta_get_all_intersect (core->anal, from, to - from, R_META_TYPE_ANY) : NULL;\n\tif (metas) {\n\t\tvoid **it;\n\t\tr_pvector_foreach (metas, it) {\n\t\t\tRIntervalNode *node = *it;\n\t\t\tRAnalMetaItem *mi = node->data;\n\t\t\tif (node->start < from || node->end > to) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpiece = (node->start - from) / step;\n\t\t\tswitch (mi->type) {\n\t\t\tcase R_META_TYPE_STRING:\n\t\t\t\tas->block[piece].strings++;\n\t\t\t\tbreak;\n\t\t\tcase R_META_TYPE_COMMENT:\n\t\t\t\tas->block[piece].comments++;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tr_pvector_free (metas);\n\t}\n\treturn as;\n}\n\nR_API void r_core_anal_stats_free(RCoreAnalStats *s) {\n\tif (s) {\n\t\tfree (s->block);\n\t}\n\tfree (s);\n}\n\nR_API RList* r_core_anal_cycles(RCore *core, int ccl) {\n\tut64 addr = core->offset;\n\tint depth = 0;\n\tRAnalOp *op = NULL;\n\tRAnalCycleFrame *prev = NULL, *cf = NULL;\n\tRAnalCycleHook *ch;\n\tRList *hooks = r_list_new ();\n\tif (!hooks) {\n\t\treturn NULL;\n\t}\n\tcf = r_anal_cycle_frame_new ();\n\tr_cons_break_push (NULL, NULL);\n\twhile (cf && !r_cons_is_breaked ()) {\n\t\tif ((op = r_core_anal_op (core, addr, R_ANAL_OP_MASK_BASIC)) && (op->cycles) && (ccl > 0)) {\n\t\t\tr_cons_clear_line (1);\n\t\t\teprintf (\"%i -- \", ccl);\n\t\t\taddr += op->size;\n\t\t\tswitch (op->type) {\n\t\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\t\taddr = op->jump;\n\t\t\t\tccl -= op->cycles;\n\t\t\t\tloganal (op->addr, addr, depth);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\t\tcase R_ANAL_OP_TYPE_MJMP:\n\t\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\t\tcase R_ANAL_OP_TYPE_ICALL:\n\t\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\t\tcase R_ANAL_OP_TYPE_IRCALL:\n\t\t\t\tch = R_NEW0 (RAnalCycleHook);\n\t\t\t\tch->addr = op->addr;\n\t\t\t\teprintf (\"0x%08\"PFMT64x\" > ?\\r\", op->addr);\n\t\t\t\tch->cycles = ccl;\n\t\t\t\tr_list_append (hooks, ch);\n\t\t\t\tch = NULL;\n\t\t\t\twhile (!ch && cf) {\n\t\t\t\t\tch = r_list_pop (cf->hooks);\n\t\t\t\t\tif (ch) {\n\t\t\t\t\t\taddr = ch->addr;\n\t\t\t\t\t\tccl = ch->cycles;\n\t\t\t\t\t\tfree (ch);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_anal_cycle_frame_free (cf);\n\t\t\t\t\t\tcf = prev;\n\t\t\t\t\t\tif (cf) {\n\t\t\t\t\t\t\tprev = cf->prev;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\t\tch = R_NEW0 (RAnalCycleHook);\n\t\t\t\tch->addr = addr;\n\t\t\t\tch->cycles = ccl - op->failcycles;\n\t\t\t\tr_list_push (cf->hooks, ch);\n\t\t\t\tch = NULL;\n\t\t\t\taddr = op->jump;\n\t\t\t\tloganal (op->addr, addr, depth);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_OP_TYPE_UCJMP:\n\t\t\tcase R_ANAL_OP_TYPE_UCCALL:\n\t\t\t\tch = R_NEW0 (RAnalCycleHook);\n\t\t\t\tch->addr = op->addr;\n\t\t\t\tch->cycles = ccl;\n\t\t\t\tr_list_append (hooks, ch);\n\t\t\t\tch = NULL;\n\t\t\t\tccl -= op->failcycles;\n\t\t\t\teprintf (\"0x%08\"PFMT64x\" > ?\\r\", op->addr);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_OP_TYPE_CCALL:\n\t\t\t\tch = R_NEW0 (RAnalCycleHook);\n\t\t\t\tch->addr = addr;\n\t\t\t\tch->cycles = ccl - op->failcycles;\n\t\t\t\tr_list_push (cf->hooks, ch);\n\t\t\t\tch = NULL;\n\t\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\t\tif (op->addr != op->jump) { //no selfies\n\t\t\t\t\tcf->naddr = addr;\n\t\t\t\t\tprev = cf;\n\t\t\t\t\tcf = r_anal_cycle_frame_new ();\n\t\t\t\t\tcf->prev = prev;\n\t\t\t\t}\n\t\t\t\tccl -= op->cycles;\n\t\t\t\taddr = op->jump;\n\t\t\t\tloganal (op->addr, addr, depth - 1);\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\t\tch = R_NEW0 (RAnalCycleHook);\n\t\t\t\tif (prev) {\n\t\t\t\t\tch->addr = prev->naddr;\n\t\t\t\t\tccl -= op->cycles;\n\t\t\t\t\tch->cycles = ccl;\n\t\t\t\t\tr_list_push (prev->hooks, ch);\n\t\t\t\t\teprintf (\"0x%08\"PFMT64x\" < 0x%08\"PFMT64x\"\\r\", prev->naddr, op->addr);\n\t\t\t\t} else {\n\t\t\t\t\tch->addr = op->addr;\n\t\t\t\t\tch->cycles = ccl;\n\t\t\t\t\tr_list_append (hooks, ch);\n\t\t\t\t\teprintf (\"? < 0x%08\"PFMT64x\"\\r\", op->addr);\n\t\t\t\t}\n\t\t\t\tch = NULL;\n\t\t\t\twhile (!ch && cf) {\n\t\t\t\t\tch = r_list_pop (cf->hooks);\n\t\t\t\t\tif (ch) {\n\t\t\t\t\t\taddr = ch->addr;\n\t\t\t\t\t\tccl = ch->cycles;\n\t\t\t\t\t\tfree (ch);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_anal_cycle_frame_free (cf);\n\t\t\t\t\t\tcf = prev;\n\t\t\t\t\t\tif (cf) {\n\t\t\t\t\t\t\tprev = cf->prev;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase R_ANAL_OP_TYPE_CRET:\n\t\t\t\tch = R_NEW0 (RAnalCycleHook);\n\t\t\t\tif (prev) {\n\t\t\t\t\tch->addr = prev->naddr;\n\t\t\t\t\tch->cycles = ccl - op->cycles;\n\t\t\t\t\tr_list_push (prev->hooks, ch);\n\t\t\t\t\teprintf (\"0x%08\"PFMT64x\" < 0x%08\"PFMT64x\"\\r\", prev->naddr, op->addr);\n\t\t\t\t} else {\n\t\t\t\t\tch->addr = op->addr;\n\t\t\t\t\tch->cycles = ccl - op->cycles;\n\t\t\t\t\tr_list_append (hooks, ch);\n\t\t\t\t\teprintf (\"? < 0x%08\"PFMT64x\"\\r\", op->addr);\n\t\t\t\t}\n\t\t\t\tccl -= op->failcycles;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tccl -= op->cycles;\n\t\t\t\teprintf (\"0x%08\"PFMT64x\"\\r\", op->addr);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tch = R_NEW0 (RAnalCycleHook);\n\t\t\tif (!ch) {\n\t\t\t\tr_anal_cycle_frame_free (cf);\n\t\t\t\tr_list_free (hooks);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tch->addr = addr;\n\t\t\tch->cycles = ccl;\n\t\t\tr_list_append (hooks, ch);\n\t\t\tch = NULL;\n\t\t\twhile (!ch && cf) {\n\t\t\t\tch = r_list_pop (cf->hooks);\n\t\t\t\tif (ch) {\n\t\t\t\t\taddr = ch->addr;\n\t\t\t\t\tccl = ch->cycles;\n\t\t\t\t\tfree (ch);\n\t\t\t\t} else {\n\t\t\t\t\tr_anal_cycle_frame_free (cf);\n\t\t\t\t\tcf = prev;\n\t\t\t\t\tif (cf) {\n\t\t\t\t\t\tprev = cf->prev;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tr_anal_op_free (op);\n\t}\n\tif (r_cons_is_breaked ()) {\n\t\twhile (cf) {\n\t\t\tch = r_list_pop (cf->hooks);\n\t\t\twhile (ch) {\n\t\t\t\tfree (ch);\n\t\t\t\tch = r_list_pop (cf->hooks);\n\t\t\t}\n\t\t\tprev = cf->prev;\n\t\t\tr_anal_cycle_frame_free (cf);\n\t\t\tcf = prev;\n\t\t}\n\t}\n\tr_cons_break_pop ();\n\treturn hooks;\n}\n\nint cmd_anal_fcn(RCore *core, const char *input);\nR_API void r_core_anal_undefine(RCore *core, ut64 off) {\n\t// very slow\n\t// RAnalFunction *f = r_anal_get_fcn_in (core->anal, off, -1);\n\tRAnalFunction *f = r_anal_get_function_at (core->anal, off);\n\tif (f) {\n\t\tif (!strncmp (f->name, \"fcn.\", 4)) {\n\t\t\tr_flag_unset_name (core->flags, f->name);\n\t\t}\n\t\tr_meta_del (core->anal, R_META_TYPE_ANY, r_anal_function_min_addr (f), r_anal_function_linear_size (f));\n\t\tr_anal_function_del (core->anal, off);\n\t}\n\t//r_anal_function_del_locs (core->anal, off);\n\tr_anal_delete_block_at (core->anal, off);\n\tchar *abcmd = r_str_newf (\"ab-0x%\"PFMT64x, off);\n\tcmd_anal_fcn (core, abcmd);\n\tfree (abcmd);\n}\n\n/* Join function at addr2 into function at addr */\n// addr use to be core->offset\nR_API void r_core_anal_fcn_merge(RCore *core, ut64 addr, ut64 addr2) {\n\tRListIter *iter;\n\tut64 min = 0;\n\tut64 max = 0;\n\tint first = 1;\n\tRAnalBlock *bb;\n\tRAnalFunction *f1 = r_anal_get_function_at (core->anal, addr);\n\tRAnalFunction *f2 = r_anal_get_function_at (core->anal, addr2);\n\tif (!f1 || !f2) {\n\t\teprintf (\"Cannot find function\\n\");\n\t\treturn;\n\t}\n\tif (f1 == f2) {\n\t\teprintf (\"Cannot merge the same function\\n\");\n\t\treturn;\n\t}\n\t// join all basic blocks from f1 into f2 if they are not\n\t// delete f2\n\teprintf (\"Merge 0x%08\"PFMT64x\" into 0x%08\"PFMT64x\"\\n\", addr, addr2);\n\tr_list_foreach (f1->bbs, iter, bb) {\n\t\tif (first) {\n\t\t\tmin = bb->addr;\n\t\t\tmax = bb->addr + bb->size;\n\t\t\tfirst = 0;\n\t\t} else {\n\t\t\tif (bb->addr < min) {\n\t\t\t\tmin = bb->addr;\n\t\t\t}\n\t\t\tif (bb->addr + bb->size > max) {\n\t\t\t\tmax = bb->addr + bb->size;\n\t\t\t}\n\t\t}\n\t}\n\tr_list_foreach (f2->bbs, iter, bb) {\n\t\tif (first) {\n\t\t\tmin = bb->addr;\n\t\t\tmax = bb->addr + bb->size;\n\t\t\tfirst = 0;\n\t\t} else {\n\t\t\tif (bb->addr < min) {\n\t\t\t\tmin = bb->addr;\n\t\t\t}\n\t\t\tif (bb->addr + bb->size > max) {\n\t\t\t\tmax = bb->addr + bb->size;\n\t\t\t}\n\t\t}\n\t\tr_anal_function_add_block (f1, bb);\n\t}\n\t// TODO: import data/code/refs\n\tr_anal_function_delete (f2);\n\t// update size\n\tr_anal_function_relocate (f2, R_MIN (addr, addr2));\n}\n\nstatic bool esil_anal_stop = false;\nstatic void cccb(void *u) {\n\tesil_anal_stop = true;\n\teprintf (\"^C\\n\");\n}\n\nstatic void add_string_ref(RCore *core, ut64 xref_from, ut64 xref_to) {\n\tint len = 0;\n\tif (xref_to == UT64_MAX || !xref_to) {\n\t\treturn;\n\t}\n\tif (!xref_from || xref_from == UT64_MAX) {\n\t\txref_from = core->anal->esil->address;\n\t}\n\tchar *str_flagname = is_string_at (core, xref_to, &len);\n\tif (str_flagname) {\n\t\tr_anal_xrefs_set (core->anal, xref_from, xref_to, R_ANAL_REF_TYPE_DATA);\n\t\tr_name_filter (str_flagname, -1);\n\t\tr_flag_space_push (core->flags, R_FLAGS_FS_STRINGS);\n\t\tchar *flagname = r_str_newf (\"str.%s\", str_flagname);\n\t\tr_flag_set (core->flags, flagname, xref_to, len);\n\t\tfree (flagname);\n\t\tr_flag_space_pop (core->flags);\n\t\tr_meta_set (core->anal, 's', xref_to, len, str_flagname);\n\t\tfree (str_flagname);\n\t}\n}\n\n\n// dup with isValidAddress wtf\nstatic bool myvalid(RIO *io, ut64 addr) {\n\tif (addr < 0x100) {\n\t\treturn false;\n\t}\n\tif (addr == UT32_MAX || addr == UT64_MAX) {\t//the best of the best of the best :(\n\t\treturn false;\n\t}\n\tif (!r_io_is_valid_offset (io, addr, 0)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\ntypedef struct {\n\tRAnalOp *op;\n\tRAnalFunction *fcn;\n\tchar *spname;\n\tut64 initial_sp;\n} EsilBreakCtx;\n\nstatic const char *reg_name_for_access(RAnalOp* op, RAnalVarAccessType type) {\n\tif (type == R_ANAL_VAR_ACCESS_TYPE_WRITE) {\n\t\tif (op->dst && op->dst->reg) {\n\t\t\treturn op->dst->reg->name;\n\t\t}\n\t} else {\n\t\tif (op->src[0] && op->src[0]->reg) {\n\t\t\treturn op->src[0]->reg->name;\n\t\t}\n\t}\n\treturn NULL;\n}\n\nstatic ut64 delta_for_access(RAnalOp *op, RAnalVarAccessType type) {\n\tif (type == R_ANAL_VAR_ACCESS_TYPE_WRITE) {\n\t\tif (op->dst) {\n\t\t\treturn op->dst->imm + op->dst->delta;\n\t\t}\n\t} else {\n\t\tif (op->src[1] && (op->src[1]->imm || op->src[1]->delta)) {\n\t\t\treturn op->src[1]->imm + op->src[1]->delta;\n\t\t}\n\t\tif (op->src[0]) {\n\t\t\treturn op->src[0]->imm + op->src[0]->delta;\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void handle_var_stack_access(RAnalEsil *esil, ut64 addr, RAnalVarAccessType type, int len) {\n\tEsilBreakCtx *ctx = esil->user;\n\tconst char *regname = reg_name_for_access (ctx->op, type);\n\tif (ctx->fcn && regname) {\n\t\tut64 spaddr = r_reg_getv (esil->anal->reg, ctx->spname);\n\t\tif (addr >= spaddr && addr < ctx->initial_sp) {\n\t\t\tint stack_off = addr - ctx->initial_sp;\n\t\t\tRAnalVar *var = r_anal_function_get_var (ctx->fcn, R_ANAL_VAR_KIND_SPV, stack_off);\n\t\t\tif (!var) {\n\t\t\t\tvar = r_anal_function_get_var (ctx->fcn, R_ANAL_VAR_KIND_BPV, stack_off);\n\t\t\t}\n\t\t\tif (!var && stack_off >= -ctx->fcn->maxstack) {\n\t\t\t\tchar *varname;\n\t\t\t\tvarname = ctx->fcn->anal->opt.varname_stack\n\t\t\t\t\t? r_str_newf (\"var_%xh\", R_ABS (stack_off))\n\t\t\t\t\t: r_anal_function_autoname_var (ctx->fcn, R_ANAL_VAR_KIND_SPV, \"var\", delta_for_access (ctx->op, type));\n\t\t\t\tvar = r_anal_function_set_var (ctx->fcn, stack_off, R_ANAL_VAR_KIND_SPV, NULL, len, false, varname);\n\t\t\t\tfree (varname);\n\t\t\t}\n\t\t\tif (var) {\n\t\t\t\tr_anal_var_set_access (var, regname, ctx->op->addr, type, delta_for_access (ctx->op, type));\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic bool esilbreak_mem_write(RAnalEsil *esil, ut64 addr, const ut8 *buf, int len) {\n\thandle_var_stack_access (esil, addr, R_ANAL_VAR_ACCESS_TYPE_WRITE, len);\n\treturn true;\n}\n\n/* TODO: move into RCore? */\nstatic ut64 esilbreak_last_read = UT64_MAX;\nstatic ut64 esilbreak_last_data = UT64_MAX;\n\nstatic ut64 ntarget = UT64_MAX;\n\n// TODO differentiate endian-aware mem_read with other reads; move ntarget handling to another function\nstatic bool esilbreak_mem_read(RAnalEsil *esil, ut64 addr, ut8 *buf, int len) {\n\tut8 str[128];\n\tif (addr != UT64_MAX) {\n\t\tesilbreak_last_read = addr;\n\t}\n\thandle_var_stack_access (esil, addr, R_ANAL_VAR_ACCESS_TYPE_READ, len);\n\tif (myvalid (mycore->io, addr) && r_io_read_at (mycore->io, addr, (ut8*)buf, len)) {\n\t\tut64 refptr;\n\t\tbool trace = true;\n\t\tswitch (len) {\n\t\tcase 2:\n\t\t\tesilbreak_last_data = refptr = (ut64)r_read_ble16 (buf, esil->anal->big_endian);\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tesilbreak_last_data = refptr = (ut64)r_read_ble32 (buf, esil->anal->big_endian);\n\t\t\tbreak;\n\t\tcase 8:\n\t\t\tesilbreak_last_data = refptr = r_read_ble64 (buf, esil->anal->big_endian);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ttrace = false;\n\t\t\tr_io_read_at (mycore->io, addr, (ut8*)buf, len);\n\t\t\tbreak;\n\t\t}\n\t\t// TODO incorrect\n\t\tbool validRef = false;\n\t\tif (trace && myvalid (mycore->io, refptr)) {\n\t\t\tif (ntarget == UT64_MAX || ntarget == refptr) {\n\t\t\t\tstr[0] = 0;\n\t\t\t\tif (r_io_read_at (mycore->io, refptr, str, sizeof (str)) < 1) {\n\t\t\t\t\t//eprintf (\"Invalid read\\n\");\n\t\t\t\t\tstr[0] = 0;\n\t\t\t\t\tvalidRef = false;\n\t\t\t\t} else {\n\t\t\t\t\tr_anal_xrefs_set (mycore->anal, esil->address, refptr, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\tstr[sizeof (str) - 1] = 0;\n\t\t\t\t\tadd_string_ref (mycore, esil->address, refptr);\n\t\t\t\t\tesilbreak_last_data = UT64_MAX;\n\t\t\t\t\tvalidRef = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/** resolve ptr */\n\t\tif (ntarget == UT64_MAX || ntarget == addr || (ntarget == UT64_MAX && !validRef)) {\n\t\t\tr_anal_xrefs_set (mycore->anal, esil->address, addr, R_ANAL_REF_TYPE_DATA);\n\t\t}\n\t}\n\treturn false; // fallback\n}\n\nstatic bool esilbreak_reg_write(RAnalEsil *esil, const char *name, ut64 *val) {\n\tif (!esil) {\n\t\treturn false;\n\t}\n\tRAnal *anal = esil->anal;\n\tEsilBreakCtx *ctx = esil->user;\n\tRAnalOp *op = ctx->op;\n\tRCore *core = anal->coreb.core;\n\thandle_var_stack_access (esil, *val, R_ANAL_VAR_ACCESS_TYPE_PTR, esil->anal->bits / 8);\n\t//specific case to handle blx/bx cases in arm through emulation\n\t// XXX this thing creates a lot of false positives\n\tut64 at = *val;\n\tif (anal && anal->opt.armthumb) {\n\t\tif (anal->cur && anal->cur->arch && anal->bits < 33 &&\n\t\t\tstrstr (anal->cur->arch, \"arm\") && !strcmp (name, \"pc\") && op) {\n\t\t\tswitch (op->type) {\n\t\t\tcase R_ANAL_OP_TYPE_UCALL: // BLX\n\t\t\tcase R_ANAL_OP_TYPE_UJMP: // BX\n\t\t\t\t// maybe UJMP/UCALL is enough here\n\t\t\t\tif (!(*val & 1)) {\n\t\t\t\t\tr_anal_hint_set_bits (anal, *val, 32);\n\t\t\t\t} else {\n\t\t\t\t\tut64 snv = r_reg_getv (anal->reg, \"pc\");\n\t\t\t\t\tif (snv != UT32_MAX && snv != UT64_MAX) {\n\t\t\t\t\t\tif (r_io_is_valid_offset (anal->iob.io, *val, 1)) {\n\t\t\t\t\t\t\tr_anal_hint_set_bits (anal, *val - 1, 16);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tif (core->rasm->bits == 32 && strstr (core->rasm->cur->name, \"arm\")) {\n\t\tif ((!(at & 1)) && r_io_is_valid_offset (anal->iob.io, at, 0)) { //  !core->anal->opt.noncode)) {\n\t\t\tadd_string_ref (anal->coreb.core, esil->address, at);\n\t\t}\n\t}\n\treturn 0;\n}\n\nstatic void getpcfromstack(RCore *core, RAnalEsil *esil) {\n\tut64 cur;\n\tut64 addr;\n\tut64 size;\n\tint idx;\n\tRAnalEsil esil_cpy;\n\tRAnalOp op = R_EMPTY;\n\tRAnalFunction *fcn = NULL;\n\tut8 *buf = NULL;\n\tchar *tmp_esil_str = NULL;\n\tint tmp_esil_str_len;\n\tconst char *esilstr;\n\tconst int maxaddrlen = 20;\n\tconst char *spname = NULL;\n\tif (!esil) {\n\t\treturn;\n\t}\n\n\tmemcpy (&esil_cpy, esil, sizeof (esil_cpy));\n\taddr = cur = esil_cpy.cur;\n\tfcn = r_anal_get_fcn_in (core->anal, addr, 0);\n\tif (!fcn) {\n\t\treturn;\n\t}\n\n\tsize = r_anal_function_linear_size (fcn);\n\tif (size <= 0) {\n\t\treturn;\n\t}\n\n\tbuf = malloc (size + 2);\n\tif (!buf) {\n\t\tperror (\"malloc\");\n\t\treturn;\n\t}\n\n\tr_io_read_at (core->io, addr, buf, size + 1);\n\n\t// TODO Hardcoding for 2 instructions (mov e_p,[esp];ret). More work needed\n\tidx = 0;\n\tif (r_anal_op (core->anal, &op, cur, buf + idx, size - idx, R_ANAL_OP_MASK_ESIL) <= 0 ||\n\t\t\top.size <= 0 ||\n\t\t\t(op.type != R_ANAL_OP_TYPE_MOV && op.type != R_ANAL_OP_TYPE_CMOV)) {\n\t\tgoto err_anal_op;\n\t}\n\n\tr_asm_set_pc (core->rasm, cur);\n\tesilstr = R_STRBUF_SAFEGET (&op.esil);\n\tif (!esilstr) {\n\t\tgoto err_anal_op;\n\t}\n\t// Ugly code\n\t// This is a hack, since ESIL doesn't always preserve values pushed on the stack. That probably needs to be rectified\n\tspname = r_reg_get_name (core->anal->reg, R_REG_NAME_SP);\n\tif (!spname || !*spname) {\n\t\tgoto err_anal_op;\n\t}\n\ttmp_esil_str_len = strlen (esilstr) + strlen (spname) + maxaddrlen;\n\ttmp_esil_str = (char*) malloc (tmp_esil_str_len);\n\tif (!tmp_esil_str) {\n\t\tgoto err_anal_op;\n\t}\n\ttmp_esil_str[tmp_esil_str_len - 1] = '\\0';\n\tsnprintf (tmp_esil_str, tmp_esil_str_len - 1, \"%s,[\", spname);\n\tif (!*esilstr || (strncmp ( esilstr, tmp_esil_str, strlen (tmp_esil_str)))) {\n\t\tfree (tmp_esil_str);\n\t\tgoto err_anal_op;\n\t}\n\n\tsnprintf (tmp_esil_str, tmp_esil_str_len - 1, \"%20\" PFMT64u \"%s\", esil_cpy.old, &esilstr[strlen (spname) + 4]);\n\tr_str_trim (tmp_esil_str);\n\tidx += op.size;\n\tr_anal_esil_set_pc (&esil_cpy, cur);\n\tr_anal_esil_parse (&esil_cpy, tmp_esil_str);\n\tr_anal_esil_stack_free (&esil_cpy);\n\tfree (tmp_esil_str);\n\n\tcur = addr + idx;\n\tr_anal_op_fini (&op);\n\tif (r_anal_op (core->anal, &op, cur, buf + idx, size - idx, R_ANAL_OP_MASK_ESIL) <= 0 ||\n\t\t\top.size <= 0 ||\n\t\t\t(op.type != R_ANAL_OP_TYPE_RET && op.type != R_ANAL_OP_TYPE_CRET)) {\n\t\tgoto err_anal_op;\n\t}\n\tr_asm_set_pc (core->rasm, cur);\n\n\tesilstr = R_STRBUF_SAFEGET (&op.esil);\n\tr_anal_esil_set_pc (&esil_cpy, cur);\n\tif (!esilstr || !*esilstr) {\n\t\tgoto err_anal_op;\n\t}\n\tr_anal_esil_parse (&esil_cpy, esilstr);\n\tr_anal_esil_stack_free (&esil_cpy);\n\n\tmemcpy (esil, &esil_cpy, sizeof (esil_cpy));\n\n err_anal_op:\n\tr_anal_op_fini (&op);\n\tfree (buf);\n}\n\ntypedef struct {\n\tut64 start_addr;\n\tut64 end_addr;\n\tRAnalFunction *fcn;\n\tRAnalBlock *cur_bb;\n\tRList *bbl, *path, *switch_path;\n} IterCtx;\n\nstatic int find_bb(ut64 *addr, RAnalBlock *bb) {\n\treturn *addr != bb->addr;\n}\n\nstatic inline bool get_next_i(IterCtx *ctx, size_t *next_i) {\n\t(*next_i)++;\n\tut64 cur_addr = *next_i + ctx->start_addr;\n\tif (ctx->fcn) {\n\t\tif (!ctx->cur_bb) {\n\t\t\tctx->path = r_list_new ();\n\t\t\tctx->switch_path = r_list_new ();\n\t\t\tctx->bbl = r_list_clone (ctx->fcn->bbs);\n\t\t\tctx->cur_bb = r_anal_get_block_at (ctx->fcn->anal, ctx->fcn->addr);\n\t\t\tif (!ctx->cur_bb) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tr_list_push (ctx->path, ctx->cur_bb);\n\t\t}\n\t\tRAnalBlock *bb = ctx->cur_bb;\n\t\tif (cur_addr >= bb->addr + bb->size) {\n\t\t\tr_reg_arena_push (ctx->fcn->anal->reg);\n\t\t\tRListIter *bbit = NULL;\n\t\t\tif (bb->switch_op) {\n\t\t\t\tRAnalCaseOp *cop = r_list_first (bb->switch_op->cases);\n\t\t\t\tbbit = r_list_find (ctx->bbl, &cop->jump, (RListComparator)find_bb);\n\t\t\t\tif (bbit) {\n\t\t\t\t\tr_list_push (ctx->switch_path, bb->switch_op->cases->head);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tbbit = r_list_find (ctx->bbl, &bb->jump, (RListComparator)find_bb);\n\t\t\t\tif (!bbit && bb->fail != UT64_MAX) {\n\t\t\t\t\tbbit = r_list_find (ctx->bbl, &bb->fail, (RListComparator)find_bb);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!bbit) {\n\t\t\t\tRListIter *cop_it = r_list_last (ctx->switch_path);\n\t\t\t\tRAnalBlock *prev_bb = NULL;\n\t\t\t\tdo {\n\t\t\t\t\tr_reg_arena_pop (ctx->fcn->anal->reg);\n\t\t\t\t\tprev_bb = r_list_pop (ctx->path);\n\t\t\t\t\tif (prev_bb->fail != UT64_MAX) {\n\t\t\t\t\t\tbbit = r_list_find (ctx->bbl, &prev_bb->fail, (RListComparator)find_bb);\n\t\t\t\t\t\tif (bbit) {\n\t\t\t\t\t\t\tr_reg_arena_push (ctx->fcn->anal->reg);\n\t\t\t\t\t\t\tr_list_push (ctx->path, prev_bb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (!bbit && cop_it) {\n\t\t\t\t\t\tRAnalCaseOp *cop = cop_it->data;\n\t\t\t\t\t\tif (cop->jump == prev_bb->addr && cop_it->n) {\n\t\t\t\t\t\t\tcop = cop_it->n->data;\n\t\t\t\t\t\t\tr_list_pop (ctx->switch_path);\n\t\t\t\t\t\t\tr_list_push (ctx->switch_path, cop_it->n);\n\t\t\t\t\t\t\tcop_it = cop_it->n;\n\t\t\t\t\t\t\tbbit = r_list_find (ctx->bbl, &cop->jump, (RListComparator)find_bb);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (cop_it && !cop_it->n) {\n\t\t\t\t\t\tr_list_pop (ctx->switch_path);\n\t\t\t\t\t\tcop_it = r_list_last (ctx->switch_path);\n\t\t\t\t\t}\n\t\t\t\t} while (!bbit && !r_list_empty (ctx->path));\n\t\t\t}\n\t\t\tif (!bbit) {\n\t\t\t\tr_list_free (ctx->path);\n\t\t\t\tr_list_free (ctx->switch_path);\n\t\t\t\tr_list_free (ctx->bbl);\n\t\t\t\tctx->path = NULL;\n\t\t\t\tctx->switch_path = NULL;\n\t\t\t\tctx->bbl = NULL;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!bbit->data) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!bbit->data) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tctx->cur_bb = bbit->data;\n\t\t\tr_list_push (ctx->path, ctx->cur_bb);\n\t\t\tr_list_delete (ctx->bbl, bbit);\n\t\t\t*next_i = ctx->cur_bb->addr - ctx->start_addr;\n\t\t}\n\t} else if (cur_addr >= ctx->end_addr) {\n\t\treturn false;\n\t}\n\tif (*next_i == 0) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nR_API void r_core_anal_esil(RCore *core, const char *str, const char *target) {\n\tbool cfg_anal_strings = r_config_get_i (core->config, \"anal.strings\");\n\tbool emu_lazy = r_config_get_i (core->config, \"emu.lazy\");\n\tbool gp_fixed = r_config_get_i (core->config, \"anal.gpfixed\");\n\tRAnalEsil *ESIL = core->anal->esil;\n\tut64 refptr = 0LL;\n\tchar *pcname = NULL;\n\tRAnalOp op = R_EMPTY;\n\tut8 *buf = NULL;\n\tbool end_address_set = false;\n\tint iend;\n\tint minopsize = 4; // XXX this depends on asm->mininstrsize\n\tbool archIsArm = false;\n\tut64 addr = core->offset;\n\tut64 start = addr;\n\tut64 end = 0LL;\n\tut64 cur;\n\tif (esil_anal_stop || r_cons_is_breaked ()) {\n\t\t// faster ^C\n\t\treturn;\n\t}\n\n\tmycore = core;\n\tif (!strcmp (str, \"?\")) {\n\t\teprintf (\"Usage: aae[f] [len] [addr] - analyze refs in function, section or len bytes with esil\\n\");\n\t\teprintf (\"  aae $SS @ $S             - analyze the whole section\\n\");\n\t\teprintf (\"  aae $SS str.Hello @ $S   - find references for str.Hellow\\n\");\n\t\teprintf (\"  aaef                     - analyze functions discovered with esil\\n\");\n\t\treturn;\n\t}\n#define CHECKREF(x) ((refptr && (x) == refptr) || !refptr)\n\tif (target) {\n\t\tconst char *expr = r_str_trim_head_ro (target);\n\t\tif (*expr) {\n\t\t\trefptr = ntarget = r_num_math (core->num, expr);\n\t\t\tif (!refptr) {\n\t\t\t\tntarget = refptr = addr;\n\t\t\t}\n\t\t} else {\n\t\t\tntarget = UT64_MAX;\n\t\t\trefptr = 0LL;\n\t\t}\n\t} else {\n\t\tntarget = UT64_MAX;\n\t\trefptr = 0LL;\n\t}\n\tRAnalFunction *fcn = NULL;\n\tif (!strcmp (str, \"f\")) {\n\t\tfcn = r_anal_get_fcn_in (core->anal, core->offset, 0);\n\t\tif (fcn) {\n\t\t\tstart = r_anal_function_min_addr (fcn);\n\t\t\taddr = fcn->addr;\n\t\t\tend = r_anal_function_max_addr (fcn);\n\t\t\tend_address_set = true;\n\t\t}\n\t}\n\n\tif (!end_address_set) {\n\t\tif (str[0] == ' ') {\n\t\t\tend = addr + r_num_math (core->num, str + 1);\n\t\t} else {\n\t\t\tRIOMap *map = r_io_map_get_at (core->io, addr);\n\t\t\tif (map) {\n\t\t\t\tend = r_io_map_end (map);\n\t\t\t} else {\n\t\t\t\tend = addr + core->blocksize;\n\t\t\t}\n\t\t}\n\t}\n\n\tiend = end - start;\n\tif (iend < 0) {\n\t\treturn;\n\t}\n\tif (iend > MAX_SCAN_SIZE) {\n\t\teprintf (\"Warning: Not going to analyze 0x%08\"PFMT64x\" bytes.\\n\", (ut64)iend);\n\t\treturn;\n\t}\n\tbuf = malloc ((size_t)iend + 2);\n\tif (!buf) {\n\t\tperror (\"malloc\");\n\t\treturn;\n\t}\n\tesilbreak_last_read = UT64_MAX;\n\tr_io_read_at (core->io, start, buf, iend + 1);\n\tif (!ESIL) {\n\t\tr_core_cmd0 (core, \"aei\");\n\t\tESIL = core->anal->esil;\n\t\tif (!ESIL) {\n\t\t\teprintf (\"ESIL not initialized\\n\");\n\t\t\treturn;\n\t\t}\n\t\tr_core_cmd0 (core, \"aeim\");\n\t\tESIL = core->anal->esil;\n\t}\n\tconst char *kspname = r_reg_get_name (core->anal->reg, R_REG_NAME_SP);\n\tif (R_STR_ISEMPTY (kspname)) {\n\t\teprintf (\"Error: No =SP defined in the reg profile.\\n\");\n\t\treturn;\n\t}\n\tchar *spname = strdup (kspname);\n\tEsilBreakCtx ctx = {\n\t\t&op,\n\t\tfcn,\n\t\tspname,\n\t\tr_reg_getv (core->anal->reg, spname)\n\t};\n\tESIL->cb.hook_reg_write = &esilbreak_reg_write;\n\t//this is necessary for the hook to read the id of analop\n\tESIL->user = &ctx;\n\tESIL->cb.hook_mem_read = &esilbreak_mem_read;\n\tESIL->cb.hook_mem_write = &esilbreak_mem_write;\n\n\tif (fcn && fcn->reg_save_area) {\n\t\tr_reg_setv (core->anal->reg, ctx.spname, ctx.initial_sp - fcn->reg_save_area);\n\t}\n\t//eprintf (\"Analyzing ESIL refs from 0x%\"PFMT64x\" - 0x%\"PFMT64x\"\\n\", addr, end);\n\t// TODO: backup/restore register state before/after analysis\n\tconst char *kpcname = r_reg_get_name (core->anal->reg, R_REG_NAME_PC);\n\tif (!kpcname || !*kpcname) {\n\t\teprintf (\"Cannot find program counter register in the current profile.\\n\");\n\t\treturn;\n\t}\n\tpcname = strdup (kpcname);\n\tesil_anal_stop = false;\n\tr_cons_break_push (cccb, core);\n\n\tint arch = -1;\n\tif (!strcmp (core->anal->cur->arch, \"arm\")) {\n\t\tswitch (core->anal->cur->bits) {\n\t\tcase 64: arch = R2_ARCH_ARM64; break;\n\t\tcase 32: arch = R2_ARCH_ARM32; break;\n\t\tcase 16: arch = R2_ARCH_THUMB; break;\n\t\t}\n\t\tarchIsArm = true;\n\t}\n\n\tut64 gp = r_config_get_i (core->config, \"anal.gp\");\n\tconst char *gp_reg = NULL;\n\tif (!strcmp (core->anal->cur->arch, \"mips\")) {\n\t\tgp_reg = \"gp\";\n\t\tarch = R2_ARCH_MIPS;\n\t}\n\n\tconst char *sn = r_reg_get_name (core->anal->reg, R_REG_NAME_SN);\n\tif (!sn) {\n\t\teprintf (\"Warning: No SN reg alias for current architecture.\\n\");\n\t}\n\tr_reg_arena_push (core->anal->reg);\n\n\tIterCtx ictx = { start, end, fcn, NULL };\n\tsize_t i = addr - start;\n\tsize_t i_old = 0;\n\tdo {\n\t\tif (esil_anal_stop || r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tcur = start + i;\n\t\tif (!r_io_is_valid_offset (core->io, cur, 0)) {\n\t\t\tbreak;\n\t\t}\n#if 0\n\t\t// disabled because it causes some tests to fail\n\t\t{\n\t\t\tRPVector *list = r_meta_get_all_in (core->anal, cur, R_META_TYPE_ANY);\n\t\t\tvoid **it;\n\t\t\tr_pvector_foreach (list, it) {\n\t\t\t\tRIntervalNode *node = *it;\n\t\t\t\tRAnalMetaItem *meta = node->data;\n\t\t\t\tswitch (meta->type) {\n\t\t\t\tcase R_META_TYPE_DATA:\n\t\t\t\tcase R_META_TYPE_STRING:\n\t\t\t\tcase R_META_TYPE_FORMAT:\n#if 0\n\t\t\t\t\t{\n\t\t\t\t\t\tint msz = r_meta_get_size (core->anal, meta->type);\n\t\t\t\t\t\ti += (msz > 0)? msz: minopsize;\n\t\t\t\t\t}\n\t\t\t\t\tr_pvector_free (list);\n\t\t\t\t\tgoto loopback;\n#elif 0\n\t\t\t\t\t{\n\t\t\t\t\t\tint msz = r_meta_get_size (core->anal, meta->type);\n\t\t\t\t\t\ti += (msz > 0)? msz: minopsize;\n\t\t\t\t\t\ti--;\n\t\t\t\t\t}\n#else\n\t\t\t\t\ti += 4;\n\t\t\t\t\tgoto repeat;\n#endif\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tr_pvector_free (list);\n\t\t}\n#endif\n\n\t\t/* realign address if needed */\n\t\tr_core_seek_arch_bits (core, cur);\n\t\tint opalign = core->anal->pcalign;\n\t\tif (opalign > 0) {\n\t\t\tcur -= (cur % opalign);\n\t\t}\n\n\t\tr_anal_op_fini (&op);\n\t\tr_asm_set_pc (core->rasm, cur);\n\t\ti_old = i;\n\t\tif (i > iend) {\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (!r_anal_op (core->anal, &op, cur, buf + i, iend - i, R_ANAL_OP_MASK_ESIL | R_ANAL_OP_MASK_VAL | R_ANAL_OP_MASK_HINT)) {\n\t\t\ti += minopsize - 1; //   XXX dupe in op.size below\n\t\t}\n\t\tif (op.type == R_ANAL_OP_TYPE_ILL || op.type == R_ANAL_OP_TYPE_UNK) {\n\t\t\t// i += 2\n\t\t\tr_anal_op_fini (&op);\n\t\t\tgoto repeat;\n\t\t}\n\t\t//we need to check again i because buf+i may goes beyond its boundaries\n\t\t//because of i+= minopsize - 1\n\t\tif (op.size < 1) {\n\t\t\ti += minopsize - 1;\n\t\t\tgoto repeat;\n\t\t}\n\t\tif (emu_lazy) {\n\t\t\tif (op.type & R_ANAL_OP_TYPE_REP) {\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t\tswitch (op.type & R_ANAL_OP_TYPE_MASK) {\n\t\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\tcase R_ANAL_OP_TYPE_CJMP:\n\t\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\t\tcase R_ANAL_OP_TYPE_NOP:\n\t\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\t\tcase R_ANAL_OP_TYPE_IO:\n\t\t\tcase R_ANAL_OP_TYPE_LEAVE:\n\t\t\tcase R_ANAL_OP_TYPE_CRYPTO:\n\t\t\tcase R_ANAL_OP_TYPE_CPL:\n\t\t\tcase R_ANAL_OP_TYPE_SYNC:\n\t\t\tcase R_ANAL_OP_TYPE_SWI:\n\t\t\tcase R_ANAL_OP_TYPE_CMP:\n\t\t\tcase R_ANAL_OP_TYPE_ACMP:\n\t\t\tcase R_ANAL_OP_TYPE_NULL:\n\t\t\tcase R_ANAL_OP_TYPE_CSWI:\n\t\t\tcase R_ANAL_OP_TYPE_TRAP:\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t//  those require write support\n\t\t\tcase R_ANAL_OP_TYPE_PUSH:\n\t\t\tcase R_ANAL_OP_TYPE_POP:\n\t\t\t\ti += op.size - 1;\n\t\t\t\tgoto repeat;\n\t\t\t}\n\t\t}\n\t\tif (sn && op.type == R_ANAL_OP_TYPE_SWI) {\n\t\t\tr_strf_buffer (64);\n\t\t\tr_flag_space_set (core->flags, R_FLAGS_FS_SYSCALLS);\n\t\t\tint snv = (arch == R2_ARCH_THUMB)? op.val: (int)r_reg_getv (core->anal->reg, sn);\n\t\t\tRSyscallItem *si = r_syscall_get (core->anal->syscall, snv, -1);\n\t\t\tif (si) {\n\t\t\t//\teprintf (\"0x%08\"PFMT64x\" SYSCALL %-4d %s\\n\", cur, snv, si->name);\n\t\t\t\tr_flag_set_next (core->flags, r_strf (\"syscall.%s\", si->name), cur, 1);\n\t\t\t} else {\n\t\t\t\t//todo were doing less filtering up top because we can't match against 80 on all platforms\n\t\t\t\t// might get too many of this path now..\n\t\t\t//\teprintf (\"0x%08\"PFMT64x\" SYSCALL %d\\n\", cur, snv);\n\t\t\t\tr_flag_set_next (core->flags, r_strf (\"syscall.%d\", snv), cur, 1);\n\t\t\t}\n\t\t\tr_flag_space_set (core->flags, NULL);\n\t\t\tr_syscall_item_free (si);\n\t\t}\n\t\tconst char *esilstr = R_STRBUF_SAFEGET (&op.esil);\n\t\ti += op.size - 1;\n\t\tif (R_STR_ISEMPTY (esilstr)) {\n\t\t\tgoto repeat;\n\t\t}\n\t\tr_anal_esil_set_pc (ESIL, cur);\n\t\tr_reg_setv (core->anal->reg, pcname, cur + op.size);\n\t\tif (gp_fixed && gp_reg) {\n\t\t\tr_reg_setv (core->anal->reg, gp_reg, gp);\n\t\t}\n\t\t(void)r_anal_esil_parse (ESIL, esilstr);\n\t\t// looks like ^C is handled by esil_parse !!!!\n\t\t//r_anal_esil_dumpstack (ESIL);\n\t\t//r_anal_esil_stack_free (ESIL);\n\t\tswitch (op.type) {\n\t\tcase R_ANAL_OP_TYPE_LEA:\n\t\t\t// arm64\n\t\t\tif (core->anal->cur && arch == R2_ARCH_ARM64) {\n\t\t\t\tif (CHECKREF (ESIL->cur)) {\n\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t}\n\t\t\t} else if ((target && op.ptr == ntarget) || !target) {\n\t\t\t\tif (CHECKREF (ESIL->cur)) {\n\t\t\t\t\tif (op.ptr && r_io_is_valid_offset (core->io, op.ptr, !core->anal->opt.noncode)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, op.ptr, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, ESIL->cur, R_ANAL_REF_TYPE_STRING);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (cfg_anal_strings) {\n\t\t\t\tadd_string_ref (core, op.addr, op.ptr);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_ADD:\n\t\t\t/* TODO: test if this is valid for other archs too */\n\t\t\tif (core->anal->cur && archIsArm) {\n\t\t\t\t/* This code is known to work on Thumb, ARM and ARM64 */\n\t\t\t\tut64 dst = ESIL->cur;\n\t\t\t\tif ((target && dst == ntarget) || !target) {\n\t\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\t\tint type = core_type_by_addr (core, dst); // R_ANAL_REF_TYPE_DATA;\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, type);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t}\n\t\t\t} else if ((core->anal->bits == 32 && core->anal->cur && arch == R2_ARCH_MIPS)) {\n\t\t\t\tut64 dst = ESIL->cur;\n\t\t\t\tif (!op.src[0] || !op.src[0]->reg || !op.src[0]->reg->name) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp (op.src[0]->reg->name, \"sp\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (!strcmp (op.src[0]->reg->name, \"zero\")) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif ((target && dst == ntarget) || !target) {\n\t\t\t\t\tif (dst > 0xffff && op.src[1] && (dst & 0xffff) == (op.src[1]->imm & 0xffff) && myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tRFlagItem *f;\n\t\t\t\t\t\tchar *str;\n\t\t\t\t\t\tif (CHECKREF (dst) || CHECKREF (cur)) {\n\t\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif ((f = r_core_flag_get_by_spaces (core->flags, dst))) {\n\t\t\t\t\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, f->name);\n\t\t\t\t\t\t\t} else if ((str = is_string_at (mycore, dst, NULL))) {\n\t\t\t\t\t\t\t\tchar *str2 = r_str_newf (\"esilref: '%s'\", str);\n\t\t\t\t\t\t\t\t// HACK avoid format string inside string used later as format\n\t\t\t\t\t\t\t\t// string crashes disasm inside agf under some conditions.\n\t\t\t\t\t\t\t\t// https://github.com/radareorg/radare2/issues/6937\n\t\t\t\t\t\t\t\tr_str_replace_char (str2, '%', '&');\n\t\t\t\t\t\t\t\tr_meta_set_string (core->anal, R_META_TYPE_COMMENT, cur, str2);\n\t\t\t\t\t\t\t\tfree (str2);\n\t\t\t\t\t\t\t\tfree (str);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_LOAD:\n\t\t\t{\n\t\t\t\tut64 dst = esilbreak_last_read;\n\t\t\t\tif (dst != UT64_MAX && CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdst = esilbreak_last_data;\n\t\t\t\tif (dst != UT64_MAX && CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (mycore->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_DATA);\n\t\t\t\t\t\tif (cfg_anal_strings) {\n\t\t\t\t\t\t\tadd_string_ref (core, op.addr, dst);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\t{\n\t\t\t\tut64 dst = op.jump;\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CODE);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_CALL:\n\t\t\t{\n\t\t\t\tut64 dst = op.jump;\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, R_ANAL_REF_TYPE_CALL);\n\t\t\t\t\t}\n\t\t\t\t\tESIL->old = cur + op.size;\n\t\t\t\t\tgetpcfromstack (core, ESIL);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase R_ANAL_OP_TYPE_UJMP:\n\t\tcase R_ANAL_OP_TYPE_UCALL:\n\t\tcase R_ANAL_OP_TYPE_ICALL:\n\t\tcase R_ANAL_OP_TYPE_RCALL:\n\t\tcase R_ANAL_OP_TYPE_IRCALL:\n\t\tcase R_ANAL_OP_TYPE_MJMP:\n\t\t\t{\n\t\t\t\tut64 dst = core->anal->esil->jump_target;\n\t\t\t\tif (dst == 0 || dst == UT64_MAX) {\n\t\t\t\t\tdst = r_reg_getv (core->anal->reg, pcname);\n\t\t\t\t}\n\t\t\t\tif (CHECKREF (dst)) {\n\t\t\t\t\tif (myvalid (core->io, dst)) {\n\t\t\t\t\t\tRAnalRefType ref =\n\t\t\t\t\t\t\t(op.type & R_ANAL_OP_TYPE_MASK) == R_ANAL_OP_TYPE_UCALL\n\t\t\t\t\t\t\t? R_ANAL_REF_TYPE_CALL\n\t\t\t\t\t\t\t: R_ANAL_REF_TYPE_CODE;\n\t\t\t\t\t\tr_anal_xrefs_set (core->anal, cur, dst, ref);\n\t\t\t\t\t\tr_core_anal_fcn (core, dst, UT64_MAX, R_ANAL_REF_TYPE_NULL, 1);\n// analyze function here\n#if 0\n\t\t\t\t\t\tif (op.type == R_ANAL_OP_TYPE_UCALL || op.type == R_ANAL_OP_TYPE_RCALL) {\n\t\t\t\t\t\t\teprintf (\"0x%08\"PFMT64x\"  RCALL TO %llx\\n\", cur, dst);\n\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t\tr_anal_esil_stack_free (ESIL);\nrepeat:\n\t\tif (!r_anal_get_block_at (core->anal, cur)) {\n\t\t\tsize_t fcn_i;\n\t\t\tfor (fcn_i = i_old + 1; fcn_i <= i; fcn_i++) {\n\t\t\t\tif (r_anal_get_function_at (core->anal, start + fcn_i)) {\n\t\t\t\t\ti = fcn_i - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (i >= iend) {\n\t\t\tbreak;\n\t\t}\n\t} while (get_next_i (&ictx, &i));\n\tfree (pcname);\n\tfree (spname);\n\tr_list_free (ictx.bbl);\n\tr_list_free (ictx.path);\n\tr_list_free (ictx.switch_path);\n\tfree (buf);\n\tESIL->cb.hook_mem_read = NULL;\n\tESIL->cb.hook_mem_write = NULL;\n\tESIL->cb.hook_reg_write = NULL;\n\tESIL->user = NULL;\n\tr_anal_op_fini (&op);\n\tr_cons_break_pop ();\n\t// restore register\n\tr_reg_arena_pop (core->anal->reg);\n}\n\nstatic bool isValidAddress(RCore *core, ut64 addr) {\n\t// check if address is mapped\n\tRIOMap* map = r_io_map_get_at (core->io, addr);\n\tif (!map) {\n\t\treturn false;\n\t}\n\tst64 fdsz = (st64)r_io_fd_size (core->io, map->fd);\n\tif (fdsz > 0 && map->delta > fdsz) {\n\t\treturn false;\n\t}\n\t// check if associated file is opened\n\tRIODesc *desc = r_io_desc_get (core->io, map->fd);\n\tif (!desc) {\n\t\treturn false;\n\t}\n\t// check if current map->fd is null://\n\tif (!strncmp (desc->name, \"null://\", 7)) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nstatic bool stringAt(RCore *core, ut64 addr) {\n\tut8 buf[32];\n\tr_io_read_at (core->io, addr - 1, buf, sizeof (buf));\n\t// check if previous byte is a null byte, all strings, except pascal ones should be like this\n\tif (buf[0] != 0) {\n\t\treturn false;\n\t}\n\treturn is_string (buf + 1, 31, NULL);\n}\n\nR_API int r_core_search_value_in_range(RCore *core, RInterval search_itv, ut64 vmin,\n\t\t\t\t\t ut64 vmax, int vsize, inRangeCb cb, void *cb_user) {\n\tint i, align = core->search->align, hitctr = 0;\n\tbool vinfun = r_config_get_i (core->config, \"anal.vinfun\");\n\tbool vinfunr = r_config_get_i (core->config, \"anal.vinfunrange\");\n\tbool analStrings = r_config_get_i (core->config, \"anal.strings\");\n\tmycore = core;\n\tut8 buf[4096];\n\tut64 v64, value = 0, size;\n\tut64 from = search_itv.addr, to = r_itv_end (search_itv);\n\tut32 v32;\n\tut16 v16;\n\tif (from >= to) {\n\t\teprintf (\"Error: from must be lower than to\\n\");\n\t\treturn -1;\n\t}\n\tbool maybeThumb = false;\n\tif (align && core->anal->cur && core->anal->cur->arch) {\n\t\tif (!strcmp (core->anal->cur->arch, \"arm\") && core->anal->bits != 64) {\n\t\t\tmaybeThumb = true;\n\t\t}\n\t}\n\n\tif (vmin >= vmax) {\n\t\teprintf (\"Error: vmin must be lower than vmax\\n\");\n\t\treturn -1;\n\t}\n\tif (to == UT64_MAX) {\n\t\teprintf (\"Error: Invalid destination boundary\\n\");\n\t\treturn -1;\n\t}\n\tr_cons_break_push (NULL, NULL);\n\n\tif (!r_io_is_valid_offset (core->io, from, 0)) {\n\t\treturn -1;\n\t}\n\twhile (from < to) {\n\t\tsize = R_MIN (to - from, sizeof (buf));\n\t\tmemset (buf, 0xff, sizeof (buf)); // probably unnecessary\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tgoto beach;\n\t\t}\n\t\tbool res = r_io_read_at_mapped (core->io, from, buf, size);\n\t\tif (!res || !memcmp (buf, \"\\xff\\xff\\xff\\xff\", 4) || !memcmp (buf, \"\\x00\\x00\\x00\\x00\", 4)) {\n\t\t\tif (!isValidAddress (core, from)) {\n\t\t\t\tut64 next = from;\n\t\t\t\tif (!r_io_map_locate (core->io, &next, 1, 0)) {\n\t\t\t\t\tfrom += sizeof (buf);\n\t\t\t\t} else {\n\t\t\t\t\tfrom += (next - from);\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfor (i = 0; i <= (size - vsize); i++) {\n\t\t\tvoid *v = (buf + i);\n\t\t\tut64 addr = from + i;\n\t\t\tif (r_cons_is_breaked ()) {\n\t\t\t\tgoto beach;\n\t\t\t}\n\t\t\tif (align && (addr) % align) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint match = false;\n\t\t\tint left = size - i;\n\t\t\tif (vsize > left) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tswitch (vsize) {\n\t\t\tcase 1: value = *(ut8 *)v; match = (buf[i] >= vmin && buf[i] <= vmax); break;\n\t\t\tcase 2: v16 = *(uut16 *)v; match = (v16 >= vmin && v16 <= vmax); value = v16; break;\n\t\t\tcase 4: v32 = *(uut32 *)v; match = (v32 >= vmin && v32 <= vmax); value = v32; break;\n\t\t\tcase 8: v64 = *(uut64 *)v; match = (v64 >= vmin && v64 <= vmax); value = v64; break;\n\t\t\tdefault: eprintf (\"Unknown vsize %d\\n\", vsize); return -1;\n\t\t\t}\n\t\t\tif (match && !vinfun) {\n\t\t\t\tif (vinfunr) {\n\t\t\t\t\tif (r_anal_get_fcn_in_bounds (core->anal, addr, R_ANAL_FCN_TYPE_NULL)) {\n\t\t\t\t\t\tmatch = false;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (r_anal_get_fcn_in (core->anal, addr, R_ANAL_FCN_TYPE_NULL)) {\n\t\t\t\t\t\tmatch = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (match && value) {\n\t\t\t\tbool isValidMatch = true;\n\t\t\t\tif (align && (value % align)) {\n\t\t\t\t\t// ignored .. unless we are analyzing arm/thumb and lower bit is 1\n\t\t\t\t\tisValidMatch = false;\n\t\t\t\t\tif (maybeThumb && (value & 1)) {\n\t\t\t\t\t\tisValidMatch = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (isValidMatch) {\n\t\t\t\t\tcb (core, addr, value, vsize, cb_user);\n\t\t\t\t\tif (analStrings && stringAt (core, addr)) {\n\t\t\t\t\t\tadd_string_ref (mycore, addr, value);\n\t\t\t\t\t}\n\t\t\t\t\thitctr++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (size == to-from) {\n\t\t\tbreak;\n\t\t}\n\t\tfrom += size-vsize+1;\n\t}\nbeach:\n\tr_cons_break_pop ();\n\treturn hitctr;\n}\n\n\ntypedef struct {\n\tdict visited;\n\tRList *path;\n\tRCore *core;\n\tut64 from;\n\tRAnalBlock *fromBB;\n\tut64 to;\n\tRAnalBlock *toBB;\n\tRAnalBlock *cur;\n\tbool followCalls;\n\tint followDepth;\n\tint count; // max number of results\n} RCoreAnalPaths;\n\nstatic bool printAnalPaths(RCoreAnalPaths *p, PJ *pj) {\n\tRListIter *iter;\n\tRAnalBlock *path;\n\tif (pj) {\n\t\tpj_a (pj);\n\t} else {\n\t\tr_cons_printf (\"pdb @@= \");\n\t}\n\n\tr_list_foreach (p->path, iter, path) {\n\t\tif (pj) {\n\t\t\tpj_n (pj, path->addr);\n\t\t} else {\n\t\t\tr_cons_printf (\"0x%08\"PFMT64x\" \", path->addr);\n\t\t}\n\t}\n\n\tif(pj) {\n\t\tpj_end (pj);\n\t} else {\n\t\tr_cons_printf (\"\\n\");\n\t}\n\treturn (p->count < 1 || --p->count > 0);\n}\nstatic void analPaths(RCoreAnalPaths *p, PJ *pj);\n\nstatic void analPathFollow(RCoreAnalPaths *p, ut64 addr, PJ *pj) {\n\tif (addr == UT64_MAX) {\n\t\treturn;\n\t}\n\tif (!dict_get (&p->visited, addr)) {\n\t\tp->cur = r_anal_bb_from_offset (p->core->anal, addr);\n\t\tanalPaths (p, pj);\n\t}\n}\n\nstatic void analPaths(RCoreAnalPaths *p, PJ *pj) {\n\tRAnalBlock *cur = p->cur;\n\tif (!cur) {\n\t\t// eprintf (\"eof\\n\");\n\t\treturn;\n\t}\n\t/* handle ^C */\n\tif (r_cons_is_breaked ()) {\n\t\treturn;\n\t}\n\tdict_set (&p->visited, cur->addr, 1, NULL);\n\tr_list_append (p->path, cur);\n\tif (p->followDepth && --p->followDepth == 0) {\n\t\treturn;\n\t}\n\tif (p->toBB && cur->addr == p->toBB->addr) {\n\t\tif (!printAnalPaths (p, pj)) {\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tRAnalBlock *c = cur;\n\t\tut64 j = cur->jump;\n\t\tut64 f = cur->fail;\n\t\tanalPathFollow (p, j, pj);\n\t\tcur = c;\n\t\tanalPathFollow (p, f, pj);\n\t\tif (p->followCalls) {\n\t\t\tint i;\n\t\t\tfor (i = 0; i < cur->op_pos_size; i++) {\n\t\t\t\tut64 addr = cur->addr + cur->op_pos[i];\n\t\t\t\tRAnalOp *op = r_core_anal_op (p->core, addr, R_ANAL_OP_MASK_BASIC);\n\t\t\t\tif (op && op->type == R_ANAL_OP_TYPE_CALL) {\n\t\t\t\t\tanalPathFollow (p, op->jump, pj);\n\t\t\t\t}\n\t\t\t\tcur = c;\n\t\t\t\tr_anal_op_free (op);\n\t\t\t}\n\t\t}\n\t}\n\tp->cur = r_list_pop (p->path);\n\tdict_del (&p->visited, cur->addr);\n\tif (p->followDepth) {\n\t\tp->followDepth++;\n\t}\n}\n\nR_API void r_core_anal_paths(RCore *core, ut64 from, ut64 to, bool followCalls, int followDepth, bool is_json) {\n\tRAnalBlock *b0 = r_anal_bb_from_offset (core->anal, from);\n\tRAnalBlock *b1 = r_anal_bb_from_offset (core->anal, to);\n\tPJ *pj = NULL;\n\tif (!b0) {\n\t\teprintf (\"Cannot find basic block for 0x%08\"PFMT64x\"\\n\", from);\n\t\treturn;\n\t}\n\tif (!b1) {\n\t\teprintf (\"Cannot find basic block for 0x%08\"PFMT64x\"\\n\", to);\n\t\treturn;\n\t}\n\tRCoreAnalPaths rcap = {{0}};\n\tdict_init (&rcap.visited, 32, free);\n\trcap.path = r_list_new ();\n\trcap.core = core;\n\trcap.from = from;\n\trcap.fromBB = b0;\n\trcap.to = to;\n\trcap.toBB = b1;\n\trcap.cur = b0;\n\trcap.count = r_config_get_i (core->config, \"search.maxhits\");;\n\trcap.followCalls = followCalls;\n\trcap.followDepth = followDepth;\n\n\t// Initialize a PJ object for json mode\n\tif (is_json) {\n\t\tpj = r_core_pj_new (core);\n\t\tpj_a (pj);\n\t}\n\n\tanalPaths (&rcap, pj);\n\n\tif (is_json) {\n\t\tpj_end (pj);\n\t\tr_cons_printf (\"%s\", pj_string (pj));\n\t}\n\n\tif (pj) {\n\t\tpj_free (pj);\n\t}\n\n\tdict_fini (&rcap.visited);\n\tr_list_free (rcap.path);\n}\n\nstatic bool __cb(RFlagItem *fi, void *user) {\n\tr_list_append (user, r_str_newf (\"0x%08\"PFMT64x, fi->offset));\n\treturn true;\n}\n\nstatic int __addrs_cmp(void *_a, void *_b) {\n\tut64 a = r_num_get (NULL, _a);\n\tut64 b = r_num_get (NULL, _b);\n\tif (a > b) {\n\t\treturn 1;\n\t}\n\tif (a < b) {\n\t\treturn -1;\n\t}\n\treturn 0;\n}\n\nR_API void r_core_anal_inflags(RCore *core, const char *glob) {\n\tRList *addrs = r_list_newf (free);\n\tRListIter *iter;\n\tbool a2f = r_config_get_i (core->config, \"anal.a2f\");\n\tchar *anal_in = strdup (r_config_get (core->config, \"anal.in\"));\n\tr_config_set (core->config, \"anal.in\", \"block\");\n\t// aaFa = use a2f instead of af+\n\tbool simple = (!glob || *glob != 'a');\n\tglob = r_str_trim_head_ro (glob);\n\tchar *addr;\n\tr_flag_foreach_glob (core->flags, glob, __cb, addrs);\n\t// should be sorted already\n\tr_list_sort (addrs, (RListComparator)__addrs_cmp);\n\tr_list_foreach (addrs, iter, addr) {\n\t\tif (!iter->n || r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tchar *addr2 = iter->n->data;\n\t\tif (!addr || !addr2) {\n\t\t\tbreak;\n\t\t}\n\t\tut64 a0 = r_num_get (NULL, addr);\n\t\tut64 a1 = r_num_get (NULL, addr2);\n\t\tif (a0 == a1) {\n\t\t\t// ignore\n\t\t\tcontinue;\n\t\t}\n\t\tif (a0 > a1) {\n\t\t\teprintf (\"Warning: unsorted flag list 0x%\"PFMT64x\" 0x%\"PFMT64x\"\\n\", a0, a1);\n\t\t\tcontinue;\n\t\t}\n\t\tst64 sz = a1 - a0;\n\t\tif (sz < 1 || sz > core->anal->opt.bb_max_size) {\n\t\t\teprintf (\"Warning: invalid flag range from 0x%08\"PFMT64x\" to 0x%08\"PFMT64x\"\\n\", a0, a1);\n\t\t\tcontinue;\n\t\t}\n\t\tif (simple) {\n\t\t\tRFlagItem *fi = r_flag_get_at (core->flags, a0, 0);\n\t\t\tr_core_cmdf (core, \"af+ %s fcn.%s\", addr, fi? fi->name: addr);\n\t\t\tr_core_cmdf (core, \"afb+ %s %s %d\", addr, addr, (int)sz);\n\t\t} else {\n\t\t\tr_core_cmdf (core, \"aab@%s!%s-%s\\n\", addr, addr2, addr);\n\t\t\tRAnalFunction *fcn = r_anal_get_fcn_in (core->anal, r_num_math (core->num, addr), 0);\n\t\t\tif (fcn) {\n\t\t\t\teprintf (\"%s  %s %\"PFMT64d\"    # %s\\n\", addr, \"af\", sz, fcn->name);\n\t\t\t} else {\n\t\t\t\tif (a2f) {\n\t\t\t\t\tr_core_cmdf (core, \"a2f@%s!%s-%s\\n\", addr, addr2, addr);\n\t\t\t\t} else {\n\t\t\t\t\tr_core_cmdf (core, \"af@%s!%s-%s\\n\", addr, addr2, addr);\n\t\t\t\t}\n\t\t\t\tfcn = r_anal_get_fcn_in (core->anal, r_num_math (core->num, addr), 0);\n\t\t\t\teprintf (\"%s  %s %.4\"PFMT64d\"   # %s\\n\", addr, \"aab\", sz, fcn?fcn->name: \"\");\n\t\t\t}\n\t\t}\n\t}\n\tr_list_free (addrs);\n\tr_config_set (core->config, \"anal.in\", anal_in);\n\tfree (anal_in);\n}\n\nstatic bool analyze_noreturn_function(RCore *core, RAnalFunction *f) {\n\tRListIter *iter;\n\tRAnalBlock *bb;\n\tr_list_foreach (f->bbs, iter, bb) {\n\t\tut64 opaddr = r_anal_bb_opaddr_i (bb, bb->ninstr - 1);\n\t\tif (opaddr == UT64_MAX) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// get last opcode\n\t\tRAnalOp *op = r_core_op_anal (core, opaddr, R_ANAL_OP_MASK_HINT);\n\t\tif (!op) {\n\t\t\teprintf (\"Cannot analyze opcode at 0x%08\" PFMT64x \"\\n\", opaddr);\n\t\t\treturn false;\n\t\t}\n\n\t\tswitch (op->type & R_ANAL_OP_TYPE_MASK) {\n\t\tcase R_ANAL_OP_TYPE_ILL:\n\t\tcase R_ANAL_OP_TYPE_RET:\n\t\t\tr_anal_op_free (op);\n\t\t\treturn false;\n\t\tcase R_ANAL_OP_TYPE_JMP:\n\t\t\tif (!r_anal_function_contains (f, op->jump)) {\n\t\t\t\tr_anal_op_free (op);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t\tr_anal_op_free (op);\n\t}\n\treturn true;\n}\n\nR_API void r_core_anal_propagate_noreturn(RCore *core, ut64 addr) {\n\tRList *todo = r_list_newf (free);\n\tif (!todo) {\n\t\treturn;\n\t}\n\n\tHtUU *done = ht_uu_new0 ();\n\tif (!done) {\n\t\tr_list_free (todo);\n\t\treturn;\n\t}\n\n\tRAnalFunction *request_fcn = NULL;\n\tif (addr != UT64_MAX) {\n\t\trequest_fcn = r_anal_get_function_at (core->anal, addr);\n\t\tif (!request_fcn) {\n\t\t\tr_list_free (todo);\n\t\t\tht_uu_free (done);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// find known noreturn functions to propagate\n\tRListIter *iter;\n\tRAnalFunction *f;\n\tr_list_foreach (core->anal->fcns, iter, f) {\n\t\tif (f->is_noreturn) {\n\t\t\tut64 *n = ut64_new (f->addr);\n\t\t\tr_list_append (todo, n);\n\t\t}\n\t}\n\n\twhile (!r_list_empty (todo)) {\n\t\tut64 *paddr = (ut64*)r_list_pop (todo);\n\t\tut64 noret_addr = *paddr;\n\t\tfree (paddr);\n\t\tif (r_cons_is_breaked ()) {\n\t\t\tbreak;\n\t\t}\n\t\tRList *xrefs = r_anal_xrefs_get (core->anal, noret_addr);\n\t\tRAnalRef *xref;\n\t\tr_list_foreach (xrefs, iter, xref) {\n\t\t\tRAnalOp *xrefop = r_core_op_anal (core, xref->addr, R_ANAL_OP_MASK_ALL);\n\t\t\tif (!xrefop) {\n\t\t\t\teprintf (\"Cannot analyze opcode at 0x%08\" PFMT64x \"\\n\", xref->addr);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tut64 call_addr = xref->addr;\n\t\t\tut64 chop_addr = call_addr + xrefop->size;\n\t\t\tr_anal_op_free (xrefop);\n\t\t\tif (xref->type != R_ANAL_REF_TYPE_CALL) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Find the block that has an instruction at exactly the xref addr\n\t\t\tRList *blocks = r_anal_get_blocks_in (core->anal, call_addr);\n\t\t\tif (!blocks) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tRAnalBlock *block = NULL;\n\t\t\tRListIter *bit;\n\t\t\tRAnalBlock *block_cur;\n\t\t\tr_list_foreach (blocks, bit, block_cur) {\n\t\t\t\tif (r_anal_block_op_starts_at (block_cur, call_addr)) {\n\t\t\t\t\tblock = block_cur;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (block) {\n\t\t\t\tr_anal_block_ref (block);\n\t\t\t}\n\t\t\tr_list_free (blocks);\n\t\t\tif (!block) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tRList *block_fcns = r_list_clone (block->fcns);\n\t\t\tif (request_fcn) {\n\t\t\t\t// specific function requested, check if it contains the bb\n\t\t\t\tif (!r_list_contains (block->fcns, request_fcn)) {\n\t\t\t\t\tgoto kontinue;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// r_anal_block_chop_noreturn() might free the block!\n\t\t\t\tblock = r_anal_block_chop_noreturn (block, chop_addr);\n\t\t\t}\n\n\t\t\tRListIter *fit;\n\t\t\tr_list_foreach (block_fcns, fit, f) {\n\t\t\t\tbool found = ht_uu_find (done, f->addr, NULL) != 0;\n\t\t\t\tif (f->addr && !found && analyze_noreturn_function (core, f)) {\n\t\t\t\t\tf->is_noreturn = true;\n\t\t\t\t\tr_anal_noreturn_add (core->anal, NULL, f->addr);\n\t\t\t\t\tut64 *n = malloc (sizeof (ut64));\n\t\t\t\t\t*n = f->addr;\n\t\t\t\t\tr_list_append (todo, n);\n\t\t\t\t\tht_uu_insert (done, *n, 1);\n\t\t\t\t}\n\t\t\t}\nkontinue:\n\t\t\tif (block) {\n\t\t\t\tr_anal_block_unref (block);\n\t\t\t}\n\t\t\tr_list_free (block_fcns);\n\t\t}\n\t\tr_list_free (xrefs);\n\t}\n\tr_list_free (todo);\n\tht_uu_free (done);\n}\n"], "filenames": ["libr/anal/arch/kvx/kvx-dis.c", "libr/core/canal.c"], "buggy_code_start_loc": [96, 1], "buggy_code_end_loc": [99, 5546], "fixing_code_start_loc": [97, 1], "fixing_code_end_loc": [102, 5549], "type": "CWE-416", "message": "Use After Free in r_reg_get_name_idx in GitHub repository radareorg/radare2 prior to 5.6.6.", "other": {"cve": {"id": "CVE-2022-0849", "sourceIdentifier": "security@huntr.dev", "published": "2022-03-05T10:15:07.760", "lastModified": "2022-03-10T21:44:05.230", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Use After Free in r_reg_get_name_idx in GitHub repository radareorg/radare2 prior to 5.6.6."}, {"lang": "es", "value": "Un Uso de Memoria Previamente Liberada en la funci\u00f3n  r_reg_get_name_idx en el repositorio de GitHub radareorg/radare2 versiones anteriores a 5.6.6"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:L/AC:L/PR:N/UI:R/S:U/C:L/I:H/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.3, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.8, "impactScore": 5.5}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 4.3}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-416"}]}, {"source": "security@huntr.dev", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-416"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:radare:radare2:*:*:*:*:*:*:*:*", "versionEndExcluding": "5.6.6", "matchCriteriaId": "F3E05FE2-B40C-4EAB-B211-1CCEC2B73F98"}]}]}], "references": [{"url": "https://github.com/radareorg/radare2/commit/10517e3ff0e609697eb8cde60ec8dc999ee5ea24", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/29c5f76e-5f1f-43ab-a0c8-e31951e407b6", "source": "security@huntr.dev", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/radareorg/radare2/commit/10517e3ff0e609697eb8cde60ec8dc999ee5ea24"}}