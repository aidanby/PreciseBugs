{"buggy_code": ["/**\n * WinPR: Windows Portable Runtime\n * Network Level Authentication (NLA)\n *\n * Copyright 2010-2012 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *\t\t http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <time.h>\n\n#ifndef _WIN32\n#include <unistd.h>\n#endif\n\n#include <freerdp/crypto/tls.h>\n\n#include <winpr/crt.h>\n#include <winpr/sspi.h>\n#include <winpr/print.h>\n#include <winpr/tchar.h>\n#include <winpr/library.h>\n#include <winpr/registry.h>\n\n#include \"nla.h\"\n\n/**\n * TSRequest ::= SEQUENCE {\n * \tversion    [0] INTEGER,\n * \tnegoTokens [1] NegoData OPTIONAL,\n * \tauthInfo   [2] OCTET STRING OPTIONAL,\n * \tpubKeyAuth [3] OCTET STRING OPTIONAL\n * }\n *\n * NegoData ::= SEQUENCE OF NegoDataItem\n *\n * NegoDataItem ::= SEQUENCE {\n * \tnegoToken [0] OCTET STRING\n * }\n *\n * TSCredentials ::= SEQUENCE {\n * \tcredType    [0] INTEGER,\n * \tcredentials [1] OCTET STRING\n * }\n *\n * TSPasswordCreds ::= SEQUENCE {\n * \tdomainName  [0] OCTET STRING,\n * \tuserName    [1] OCTET STRING,\n * \tpassword    [2] OCTET STRING\n * }\n *\n * TSSmartCardCreds ::= SEQUENCE {\n * \tpin        [0] OCTET STRING,\n * \tcspData    [1] TSCspDataDetail,\n * \tuserHint   [2] OCTET STRING OPTIONAL,\n * \tdomainHint [3] OCTET STRING OPTIONAL\n * }\n *\n * TSCspDataDetail ::= SEQUENCE {\n * \tkeySpec       [0] INTEGER,\n * \tcardName      [1] OCTET STRING OPTIONAL,\n * \treaderName    [2] OCTET STRING OPTIONAL,\n * \tcontainerName [3] OCTET STRING OPTIONAL,\n * \tcspName       [4] OCTET STRING OPTIONAL\n * }\n *\n */\n\n#ifdef WITH_DEBUG_NLA\n#define WITH_DEBUG_CREDSSP\n#endif\n\n#ifdef WITH_NATIVE_SSPI\n#define NLA_PKG_NAME\tNTLMSP_NAME\n#else\n#define NLA_PKG_NAME\tNTLMSP_NAME\n#endif\n\n#define TERMSRV_SPN_PREFIX\t\"TERMSRV/\"\n\nvoid credssp_send(rdpCredssp* credssp);\nint credssp_recv(rdpCredssp* credssp);\nvoid credssp_buffer_print(rdpCredssp* credssp);\nvoid credssp_buffer_free(rdpCredssp* credssp);\nSECURITY_STATUS credssp_encrypt_public_key_echo(rdpCredssp* credssp);\nSECURITY_STATUS credssp_decrypt_public_key_echo(rdpCredssp* credssp);\nSECURITY_STATUS credssp_encrypt_ts_credentials(rdpCredssp* credssp);\nSECURITY_STATUS credssp_decrypt_ts_credentials(rdpCredssp* credssp);\n\n#define ber_sizeof_sequence_octet_string(length) ber_sizeof_contextual_tag(ber_sizeof_octet_string(length)) + ber_sizeof_octet_string(length)\n#define ber_write_sequence_octet_string(stream, context, value, length) ber_write_contextual_tag(stream, context, ber_sizeof_octet_string(length), TRUE) + ber_write_octet_string(stream, value, length)\n\n/**\n * Initialize NTLMSSP authentication module (client).\n * @param credssp\n */\n\nint credssp_ntlm_client_init(rdpCredssp* credssp)\n{\n\tchar* spn;\n\tint length;\n\tfreerdp* instance;\n\trdpSettings* settings;\n\n\tsettings = credssp->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tif ((settings->Password == NULL) || (settings->Username == NULL))\n\t{\n\t\tif (instance->Authenticate)\n\t\t{\n\t\t\tBOOL proceed = instance->Authenticate(instance,\n\t\t\t\t\t&settings->Username, &settings->Password, &settings->Domain);\n\t\t\tif (!proceed)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tsspi_SetAuthIdentity(&(credssp->identity), settings->Username, settings->Domain, settings->Password);\n\n#ifdef WITH_DEBUG_NLA\n\t_tprintf(_T(\"User: %s Domain: %s Password: %s\\n\"),\n\t\t(char*) credssp->identity.User, (char*) credssp->identity.Domain, (char*) credssp->identity.Password);\n#endif\n\n\tsspi_SecBufferAlloc(&credssp->PublicKey, credssp->transport->TlsIn->PublicKeyLength);\n\tCopyMemory(credssp->PublicKey.pvBuffer, credssp->transport->TlsIn->PublicKey, credssp->transport->TlsIn->PublicKeyLength);\n\n\tlength = sizeof(TERMSRV_SPN_PREFIX) + strlen(settings->ServerHostname);\n\n\tspn = (SEC_CHAR*) malloc(length + 1);\n\tsprintf(spn, \"%s%s\", TERMSRV_SPN_PREFIX, settings->ServerHostname);\n\n#ifdef UNICODE\n\tcredssp->ServicePrincipalName = (LPTSTR) malloc(length * 2 + 2);\n\tMultiByteToWideChar(CP_UTF8, 0, spn, length,\n\t\t(LPWSTR) credssp->ServicePrincipalName, length);\n\tfree(spn);\n#else\n\tcredssp->ServicePrincipalName = spn;\n#endif\n\n\treturn 1;\n}\n\n/**\n * Initialize NTLMSSP authentication module (server).\n * @param credssp\n */\n\nint credssp_ntlm_server_init(rdpCredssp* credssp)\n{\n\tfreerdp* instance;\n\trdpSettings* settings = credssp->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tsspi_SecBufferAlloc(&credssp->PublicKey, credssp->transport->TlsIn->PublicKeyLength);\n\tCopyMemory(credssp->PublicKey.pvBuffer, credssp->transport->TlsIn->PublicKey, credssp->transport->TlsIn->PublicKeyLength);\n\n\treturn 1;\n}\n\nint credssp_client_authenticate(rdpCredssp* credssp)\n{\n\tULONG cbMaxToken;\n\tULONG fContextReq;\n\tULONG pfContextAttr;\n\tSECURITY_STATUS status;\n\tCredHandle credentials;\n\tTimeStamp expiration;\n\tPSecPkgInfo pPackageInfo;\n\tSecBuffer input_buffer;\n\tSecBuffer output_buffer;\n\tSecBufferDesc input_buffer_desc;\n\tSecBufferDesc output_buffer_desc;\n\tBOOL have_context;\n\tBOOL have_input_buffer;\n\tBOOL have_pub_key_auth;\n\n\tsspi_GlobalInit();\n\n\tif (credssp_ntlm_client_init(credssp) == 0)\n\t\treturn 0;\n\n#ifdef WITH_NATIVE_SSPI\n\t{\n\t\tHMODULE hSSPI;\n\t\tINIT_SECURITY_INTERFACE InitSecurityInterface;\n\t\tPSecurityFunctionTable pSecurityInterface = NULL;\n\n\t\thSSPI = LoadLibrary(_T(\"secur32.dll\"));\n\n#ifdef UNICODE\n\t\tInitSecurityInterface = (INIT_SECURITY_INTERFACE) GetProcAddress(hSSPI, \"InitSecurityInterfaceW\");\n#else\n\t\tInitSecurityInterface = (INIT_SECURITY_INTERFACE) GetProcAddress(hSSPI, \"InitSecurityInterfaceA\");\n#endif\n\t\tcredssp->table = (*InitSecurityInterface)();\n\t}\n#else\n\tcredssp->table = InitSecurityInterface();\n#endif\n\n\tstatus = credssp->table->QuerySecurityPackageInfo(NLA_PKG_NAME, &pPackageInfo);\n\n\tif (status != SEC_E_OK)\n\t{\n\t\tfprintf(stderr, \"QuerySecurityPackageInfo status: 0x%08X\\n\", status);\n\t\treturn 0;\n\t}\n\n\tcbMaxToken = pPackageInfo->cbMaxToken;\n\n\tstatus = credssp->table->AcquireCredentialsHandle(NULL, NLA_PKG_NAME,\n\t\t\tSECPKG_CRED_OUTBOUND, NULL, &credssp->identity, NULL, NULL, &credentials, &expiration);\n\n\tif (status != SEC_E_OK)\n\t{\n\t\tfprintf(stderr, \"AcquireCredentialsHandle status: 0x%08X\\n\", status);\n\t\treturn 0;\n\t}\n\n\thave_context = FALSE;\n\thave_input_buffer = FALSE;\n\thave_pub_key_auth = FALSE;\n\tZeroMemory(&input_buffer, sizeof(SecBuffer));\n\tZeroMemory(&output_buffer, sizeof(SecBuffer));\n\tZeroMemory(&credssp->ContextSizes, sizeof(SecPkgContext_Sizes));\n\n\t/*\n\t * from tspkg.dll: 0x00000132\n\t * ISC_REQ_MUTUAL_AUTH\n\t * ISC_REQ_CONFIDENTIALITY\n\t * ISC_REQ_USE_SESSION_KEY\n\t * ISC_REQ_ALLOCATE_MEMORY\n\t */\n\n\tfContextReq = ISC_REQ_MUTUAL_AUTH | ISC_REQ_CONFIDENTIALITY | ISC_REQ_USE_SESSION_KEY;\n\n\twhile (TRUE)\n\t{\n\t\toutput_buffer_desc.ulVersion = SECBUFFER_VERSION;\n\t\toutput_buffer_desc.cBuffers = 1;\n\t\toutput_buffer_desc.pBuffers = &output_buffer;\n\t\toutput_buffer.BufferType = SECBUFFER_TOKEN;\n\t\toutput_buffer.cbBuffer = cbMaxToken;\n\t\toutput_buffer.pvBuffer = malloc(output_buffer.cbBuffer);\n\n\t\tstatus = credssp->table->InitializeSecurityContext(&credentials,\n\t\t\t\t(have_context) ? &credssp->context : NULL,\n\t\t\t\tcredssp->ServicePrincipalName, fContextReq, 0,\n\t\t\t\tSECURITY_NATIVE_DREP, (have_input_buffer) ? &input_buffer_desc : NULL,\n\t\t\t\t0, &credssp->context, &output_buffer_desc, &pfContextAttr, &expiration);\n\n\t\tif (have_input_buffer && (input_buffer.pvBuffer != NULL))\n\t\t{\n\t\t\tfree(input_buffer.pvBuffer);\n\t\t\tinput_buffer.pvBuffer = NULL;\n\t\t}\n\n\t\tif ((status == SEC_I_COMPLETE_AND_CONTINUE) || (status == SEC_I_COMPLETE_NEEDED) || (status == SEC_E_OK))\n\t\t{\n\t\t\tif (credssp->table->CompleteAuthToken != NULL)\n\t\t\t\tcredssp->table->CompleteAuthToken(&credssp->context, &output_buffer_desc);\n\n\t\t\thave_pub_key_auth = TRUE;\n\n\t\t\tif (credssp->table->QueryContextAttributes(&credssp->context, SECPKG_ATTR_SIZES, &credssp->ContextSizes) != SEC_E_OK)\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"QueryContextAttributes SECPKG_ATTR_SIZES failure\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tcredssp_encrypt_public_key_echo(credssp);\n\n\t\t\tif (status == SEC_I_COMPLETE_NEEDED)\n\t\t\t\tstatus = SEC_E_OK;\n\t\t\telse if (status == SEC_I_COMPLETE_AND_CONTINUE)\n\t\t\t\tstatus = SEC_I_CONTINUE_NEEDED;\n\t\t}\n\n\t\t/* send authentication token to server */\n\n\t\tif (output_buffer.cbBuffer > 0)\n\t\t{\n\t\t\tcredssp->negoToken.pvBuffer = output_buffer.pvBuffer;\n\t\t\tcredssp->negoToken.cbBuffer = output_buffer.cbBuffer;\n\n#ifdef WITH_DEBUG_CREDSSP\n\t\t\tfprintf(stderr, \"Sending Authentication Token\\n\");\n\t\t\twinpr_HexDump(credssp->negoToken.pvBuffer, credssp->negoToken.cbBuffer);\n#endif\n\n\t\t\tcredssp_send(credssp);\n\t\t\tcredssp_buffer_free(credssp);\n\t\t}\n\n\t\tif (status != SEC_I_CONTINUE_NEEDED)\n\t\t\tbreak;\n\n\t\t/* receive server response and place in input buffer */\n\n\t\tinput_buffer_desc.ulVersion = SECBUFFER_VERSION;\n\t\tinput_buffer_desc.cBuffers = 1;\n\t\tinput_buffer_desc.pBuffers = &input_buffer;\n\t\tinput_buffer.BufferType = SECBUFFER_TOKEN;\n\n\t\tif (credssp_recv(credssp) < 0)\n\t\t\treturn -1;\n\n#ifdef WITH_DEBUG_CREDSSP\n\t\tfprintf(stderr, \"Receiving Authentication Token (%d)\\n\", (int) credssp->negoToken.cbBuffer);\n\t\twinpr_HexDump(credssp->negoToken.pvBuffer, credssp->negoToken.cbBuffer);\n#endif\n\n\t\tinput_buffer.pvBuffer = credssp->negoToken.pvBuffer;\n\t\tinput_buffer.cbBuffer = credssp->negoToken.cbBuffer;\n\n\t\thave_input_buffer = TRUE;\n\t\thave_context = TRUE;\n\t}\n\n\t/* Encrypted Public Key +1 */\n\tif (credssp_recv(credssp) < 0)\n\t\treturn -1;\n\n\t/* Verify Server Public Key Echo */\n\n\tstatus = credssp_decrypt_public_key_echo(credssp);\n\tcredssp_buffer_free(credssp);\n\n\tif (status != SEC_E_OK)\n\t{\n\t\tfprintf(stderr, \"Could not verify public key echo!\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Send encrypted credentials */\n\n\tstatus = credssp_encrypt_ts_credentials(credssp);\n\n\tif (status != SEC_E_OK)\n\t{\n\t\tfprintf(stderr, \"credssp_encrypt_ts_credentials status: 0x%08X\\n\", status);\n\t\treturn 0;\n\t}\n\n\tcredssp_send(credssp);\n\tcredssp_buffer_free(credssp);\n\n\t/* Free resources */\n\n\tcredssp->table->FreeCredentialsHandle(&credentials);\n\tcredssp->table->FreeContextBuffer(pPackageInfo);\n\n\treturn 1;\n}\n\n/**\n * Authenticate with client using CredSSP (server).\n * @param credssp\n * @return 1 if authentication is successful\n */\n\nint credssp_server_authenticate(rdpCredssp* credssp)\n{\n\tUINT32 cbMaxToken;\n\tULONG fContextReq;\n\tULONG pfContextAttr;\n\tSECURITY_STATUS status;\n\tCredHandle credentials;\n\tTimeStamp expiration;\n\tPSecPkgInfo pPackageInfo;\n\tSecBuffer input_buffer;\n\tSecBuffer output_buffer;\n\tSecBufferDesc input_buffer_desc;\n\tSecBufferDesc output_buffer_desc;\n\tBOOL have_context;\n\tBOOL have_input_buffer;\n\tBOOL have_pub_key_auth;\n\n\tsspi_GlobalInit();\n\n\tif (credssp_ntlm_server_init(credssp) == 0)\n\t\treturn 0;\n\n#ifdef WITH_NATIVE_SSPI\n\tif (!credssp->SspiModule)\n\t\tcredssp->SspiModule = _tcsdup(_T(\"secur32.dll\"));\n#endif\n\n\tif (credssp->SspiModule)\n\t{\n\t\tHMODULE hSSPI;\n\t\tINIT_SECURITY_INTERFACE pInitSecurityInterface;\n\n\t\thSSPI = LoadLibrary(credssp->SspiModule);\n\n\t\tif (!hSSPI)\n\t\t{\n\t\t\t_tprintf(_T(\"Failed to load SSPI module: %s\\n\"), credssp->SspiModule);\n\t\t\treturn 0;\n\t\t}\n\n#ifdef UNICODE\n\t\tpInitSecurityInterface = (INIT_SECURITY_INTERFACE) GetProcAddress(hSSPI, \"InitSecurityInterfaceW\");\n#else\n\t\tpInitSecurityInterface = (INIT_SECURITY_INTERFACE) GetProcAddress(hSSPI, \"InitSecurityInterfaceA\");\n#endif\n\n\t\tcredssp->table = (*pInitSecurityInterface)();\n\t}\n#ifndef WITH_NATIVE_SSPI\n\telse\n\t{\n\t\tcredssp->table = InitSecurityInterface();\n\t}\n#endif\n\n\tstatus = credssp->table->QuerySecurityPackageInfo(NLA_PKG_NAME, &pPackageInfo);\n\n\tif (status != SEC_E_OK)\n\t{\n\t\tfprintf(stderr, \"QuerySecurityPackageInfo status: 0x%08X\\n\", status);\n\t\treturn 0;\n\t}\n\n\tcbMaxToken = pPackageInfo->cbMaxToken;\n\n\tstatus = credssp->table->AcquireCredentialsHandle(NULL, NLA_PKG_NAME,\n\t\t\tSECPKG_CRED_INBOUND, NULL, NULL, NULL, NULL, &credentials, &expiration);\n\n\tif (status != SEC_E_OK)\n\t{\n\t\tfprintf(stderr, \"AcquireCredentialsHandle status: 0x%08X\\n\", status);\n\t\treturn 0;\n\t}\n\n\thave_context = FALSE;\n\thave_input_buffer = FALSE;\n\thave_pub_key_auth = FALSE;\n\tZeroMemory(&input_buffer, sizeof(SecBuffer));\n\tZeroMemory(&output_buffer, sizeof(SecBuffer));\n\tZeroMemory(&input_buffer_desc, sizeof(SecBufferDesc));\n\tZeroMemory(&output_buffer_desc, sizeof(SecBufferDesc));\n\tZeroMemory(&credssp->ContextSizes, sizeof(SecPkgContext_Sizes));\n\n\t/*\n\t * from tspkg.dll: 0x00000112\n\t * ASC_REQ_MUTUAL_AUTH\n\t * ASC_REQ_CONFIDENTIALITY\n\t * ASC_REQ_ALLOCATE_MEMORY\n\t */\n\n\tfContextReq = 0;\n\tfContextReq |= ASC_REQ_MUTUAL_AUTH;\n\tfContextReq |= ASC_REQ_CONFIDENTIALITY;\n\n\tfContextReq |= ASC_REQ_CONNECTION;\n\tfContextReq |= ASC_REQ_USE_SESSION_KEY;\n\n\tfContextReq |= ASC_REQ_REPLAY_DETECT;\n\tfContextReq |= ASC_REQ_SEQUENCE_DETECT;\n\n\tfContextReq |= ASC_REQ_EXTENDED_ERROR;\n\n\twhile (TRUE)\n\t{\n\t\tinput_buffer_desc.ulVersion = SECBUFFER_VERSION;\n\t\tinput_buffer_desc.cBuffers = 1;\n\t\tinput_buffer_desc.pBuffers = &input_buffer;\n\t\tinput_buffer.BufferType = SECBUFFER_TOKEN;\n\n\t\t/* receive authentication token */\n\n\t\tinput_buffer_desc.ulVersion = SECBUFFER_VERSION;\n\t\tinput_buffer_desc.cBuffers = 1;\n\t\tinput_buffer_desc.pBuffers = &input_buffer;\n\t\tinput_buffer.BufferType = SECBUFFER_TOKEN;\n\n\t\tif (credssp_recv(credssp) < 0)\n\t\t\treturn -1;\n\n#ifdef WITH_DEBUG_CREDSSP\n\t\tfprintf(stderr, \"Receiving Authentication Token\\n\");\n\t\tcredssp_buffer_print(credssp);\n#endif\n\n\t\tinput_buffer.pvBuffer = credssp->negoToken.pvBuffer;\n\t\tinput_buffer.cbBuffer = credssp->negoToken.cbBuffer;\n\n\t\tif (credssp->negoToken.cbBuffer < 1)\n\t\t{\n\t\t\tfprintf(stderr, \"CredSSP: invalid negoToken!\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\toutput_buffer_desc.ulVersion = SECBUFFER_VERSION;\n\t\toutput_buffer_desc.cBuffers = 1;\n\t\toutput_buffer_desc.pBuffers = &output_buffer;\n\t\toutput_buffer.BufferType = SECBUFFER_TOKEN;\n\t\toutput_buffer.cbBuffer = cbMaxToken;\n\t\toutput_buffer.pvBuffer = malloc(output_buffer.cbBuffer);\n\n\t\tstatus = credssp->table->AcceptSecurityContext(&credentials,\n\t\t\thave_context? &credssp->context: NULL,\n\t\t\t&input_buffer_desc, fContextReq, SECURITY_NATIVE_DREP, &credssp->context,\n\t\t\t&output_buffer_desc, &pfContextAttr, &expiration);\n\n\t\tcredssp->negoToken.pvBuffer = output_buffer.pvBuffer;\n\t\tcredssp->negoToken.cbBuffer = output_buffer.cbBuffer;\n\n\t\tif ((status == SEC_I_COMPLETE_AND_CONTINUE) || (status == SEC_I_COMPLETE_NEEDED))\n\t\t{\n\t\t\tif (credssp->table->CompleteAuthToken != NULL)\n\t\t\t\tcredssp->table->CompleteAuthToken(&credssp->context, &output_buffer_desc);\n\n\t\t\tif (status == SEC_I_COMPLETE_NEEDED)\n\t\t\t\tstatus = SEC_E_OK;\n\t\t\telse if (status == SEC_I_COMPLETE_AND_CONTINUE)\n\t\t\t\tstatus = SEC_I_CONTINUE_NEEDED;\n\t\t}\n\n\t\tif (status == SEC_E_OK)\n\t\t{\n\t\t\thave_pub_key_auth = TRUE;\n\n\t\t\tif (credssp->table->QueryContextAttributes(&credssp->context, SECPKG_ATTR_SIZES, &credssp->ContextSizes) != SEC_E_OK)\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"QueryContextAttributes SECPKG_ATTR_SIZES failure\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (credssp_decrypt_public_key_echo(credssp) != SEC_E_OK)\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"Error: could not verify client's public key echo\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tsspi_SecBufferFree(&credssp->negoToken);\n\t\t\tcredssp->negoToken.pvBuffer = NULL;\n\t\t\tcredssp->negoToken.cbBuffer = 0;\n\n\t\t\tcredssp_encrypt_public_key_echo(credssp);\n\t\t}\n\n\t\tif ((status != SEC_E_OK) && (status != SEC_I_CONTINUE_NEEDED))\n\t\t{\n\t\t\tfprintf(stderr, \"AcceptSecurityContext status: 0x%08X\\n\", status);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* send authentication token */\n\n#ifdef WITH_DEBUG_CREDSSP\n\t\tfprintf(stderr, \"Sending Authentication Token\\n\");\n\t\tcredssp_buffer_print(credssp);\n#endif\n\n\t\tcredssp_send(credssp);\n\t\tcredssp_buffer_free(credssp);\n\n\t\tif (status != SEC_I_CONTINUE_NEEDED)\n\t\t\tbreak;\n\n\t\thave_context = TRUE;\n\t}\n\n\t/* Receive encrypted credentials */\n\n\tif (credssp_recv(credssp) < 0)\n\t\treturn -1;\n\n\tif (credssp_decrypt_ts_credentials(credssp) != SEC_E_OK)\n\t{\n\t\tfprintf(stderr, \"Could not decrypt TSCredentials status: 0x%08X\\n\", status);\n\t\treturn 0;\n\t}\n\n\tif (status != SEC_E_OK)\n\t{\n\t\tfprintf(stderr, \"AcceptSecurityContext status: 0x%08X\\n\", status);\n\t\treturn 0;\n\t}\n\n\tstatus = credssp->table->ImpersonateSecurityContext(&credssp->context);\n\n\tif (status != SEC_E_OK)\n\t{\n\t\tfprintf(stderr, \"ImpersonateSecurityContext status: 0x%08X\\n\", status);\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tstatus = credssp->table->RevertSecurityContext(&credssp->context);\n\n\t\tif (status != SEC_E_OK)\n\t\t{\n\t\t\tfprintf(stderr, \"RevertSecurityContext status: 0x%08X\\n\", status);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcredssp->table->FreeContextBuffer(pPackageInfo);\n\n\treturn 1;\n}\n\n/**\n * Authenticate using CredSSP.\n * @param credssp\n * @return 1 if authentication is successful\n */\n\nint credssp_authenticate(rdpCredssp* credssp)\n{\n\tif (credssp->server)\n\t\treturn credssp_server_authenticate(credssp);\n\telse\n\t\treturn credssp_client_authenticate(credssp);\n}\n\nvoid ap_integer_increment_le(BYTE* number, int size)\n{\n\tint index;\n\n\tfor (index = 0; index < size; index++)\n\t{\n\t\tif (number[index] < 0xFF)\n\t\t{\n\t\t\tnumber[index]++;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnumber[index] = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\nvoid ap_integer_decrement_le(BYTE* number, int size)\n{\n\tint index;\n\n\tfor (index = 0; index < size; index++)\n\t{\n\t\tif (number[index] > 0)\n\t\t{\n\t\t\tnumber[index]--;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnumber[index] = 0xFF;\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\nSECURITY_STATUS credssp_encrypt_public_key_echo(rdpCredssp* credssp)\n{\n\tSecBuffer Buffers[2];\n\tSecBufferDesc Message;\n\tSECURITY_STATUS status;\n\tint public_key_length;\n\n\tpublic_key_length = credssp->PublicKey.cbBuffer;\n\n\tBuffers[0].BufferType = SECBUFFER_TOKEN; /* Signature */\n\tBuffers[1].BufferType = SECBUFFER_DATA; /* TLS Public Key */\n\n\tsspi_SecBufferAlloc(&credssp->pubKeyAuth, credssp->ContextSizes.cbMaxSignature + public_key_length);\n\n\tBuffers[0].cbBuffer = credssp->ContextSizes.cbMaxSignature;\n\tBuffers[0].pvBuffer = credssp->pubKeyAuth.pvBuffer;\n\n\tBuffers[1].cbBuffer = public_key_length;\n\tBuffers[1].pvBuffer = ((BYTE*) credssp->pubKeyAuth.pvBuffer) + credssp->ContextSizes.cbMaxSignature;\n\tCopyMemory(Buffers[1].pvBuffer, credssp->PublicKey.pvBuffer, Buffers[1].cbBuffer);\n\n\tif (credssp->server)\n\t{\n\t\t/* server echos the public key +1 */\n\t\tap_integer_increment_le((BYTE*) Buffers[1].pvBuffer, Buffers[1].cbBuffer);\n\t}\n\n\tMessage.cBuffers = 2;\n\tMessage.ulVersion = SECBUFFER_VERSION;\n\tMessage.pBuffers = (PSecBuffer) &Buffers;\n\n\tstatus = credssp->table->EncryptMessage(&credssp->context, 0, &Message, credssp->send_seq_num++);\n\n\tif (status != SEC_E_OK)\n\t{\n\t\tfprintf(stderr, \"EncryptMessage status: 0x%08X\\n\", status);\n\t\treturn status;\n\t}\n\n\treturn status;\n}\n\nSECURITY_STATUS credssp_decrypt_public_key_echo(rdpCredssp* credssp)\n{\n\tint length;\n\tBYTE* buffer;\n\tULONG pfQOP;\n\tBYTE* public_key1;\n\tBYTE* public_key2;\n\tint public_key_length;\n\tSecBuffer Buffers[2];\n\tSecBufferDesc Message;\n\tSECURITY_STATUS status;\n\n\tif (credssp->PublicKey.cbBuffer + credssp->ContextSizes.cbMaxSignature != credssp->pubKeyAuth.cbBuffer)\n\t{\n\t\tfprintf(stderr, \"unexpected pubKeyAuth buffer size:%d\\n\", (int) credssp->pubKeyAuth.cbBuffer);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tlength = credssp->pubKeyAuth.cbBuffer;\n\tbuffer = (BYTE*) malloc(length);\n\tCopyMemory(buffer, credssp->pubKeyAuth.pvBuffer, length);\n\n\tpublic_key_length = credssp->PublicKey.cbBuffer;\n\n\tBuffers[0].BufferType = SECBUFFER_TOKEN; /* Signature */\n\tBuffers[1].BufferType = SECBUFFER_DATA; /* Encrypted TLS Public Key */\n\n\tBuffers[0].cbBuffer = credssp->ContextSizes.cbMaxSignature;\n\tBuffers[0].pvBuffer = buffer;\n\n\tBuffers[1].cbBuffer = length - credssp->ContextSizes.cbMaxSignature;\n\tBuffers[1].pvBuffer = buffer + credssp->ContextSizes.cbMaxSignature;\n\n\tMessage.cBuffers = 2;\n\tMessage.ulVersion = SECBUFFER_VERSION;\n\tMessage.pBuffers = (PSecBuffer) &Buffers;\n\n\tstatus = credssp->table->DecryptMessage(&credssp->context, &Message, credssp->recv_seq_num++, &pfQOP);\n\n\tif (status != SEC_E_OK)\n\t{\n\t\tfprintf(stderr, \"DecryptMessage failure: 0x%08X\\n\", status);\n\t\treturn status;\n\t}\n\n\tpublic_key1 = (BYTE*) credssp->PublicKey.pvBuffer;\n\tpublic_key2 = (BYTE*) Buffers[1].pvBuffer;\n\n\tif (!credssp->server)\n\t{\n\t\t/* server echos the public key +1 */\n\t\tap_integer_decrement_le(public_key2, public_key_length);\n\t}\n\n\tif (memcmp(public_key1, public_key2, public_key_length) != 0)\n\t{\n\t\tfprintf(stderr, \"Could not verify server's public key echo\\n\");\n\n\t\tfprintf(stderr, \"Expected (length = %d):\\n\", public_key_length);\n\t\twinpr_HexDump(public_key1, public_key_length);\n\n\t\tfprintf(stderr, \"Actual (length = %d):\\n\", public_key_length);\n\t\twinpr_HexDump(public_key2, public_key_length);\n\n\t\treturn SEC_E_MESSAGE_ALTERED; /* DO NOT SEND CREDENTIALS! */\n\t}\n\n\tfree(buffer);\n\n\treturn SEC_E_OK;\n}\n\nint credssp_sizeof_ts_password_creds(rdpCredssp* credssp)\n{\n\tint length = 0;\n\n\tlength += ber_sizeof_sequence_octet_string(credssp->identity.DomainLength * 2);\n\tlength += ber_sizeof_sequence_octet_string(credssp->identity.UserLength * 2);\n\tlength += ber_sizeof_sequence_octet_string(credssp->identity.PasswordLength * 2);\n\n\treturn length;\n}\n\nvoid credssp_read_ts_password_creds(rdpCredssp* credssp, wStream* s)\n{\n\tint length;\n\n\t/* TSPasswordCreds (SEQUENCE) */\n\tber_read_sequence_tag(s, &length);\n\n\t/* [0] domainName (OCTET STRING) */\n\tber_read_contextual_tag(s, 0, &length, TRUE);\n\tber_read_octet_string_tag(s, &length);\n\tcredssp->identity.DomainLength = (UINT32) length;\n\tcredssp->identity.Domain = (UINT16*) malloc(length);\n\tCopyMemory(credssp->identity.Domain, Stream_Pointer(s), credssp->identity.DomainLength);\n\tStream_Seek(s, credssp->identity.DomainLength);\n\tcredssp->identity.DomainLength /= 2;\n\n\t/* [1] userName (OCTET STRING) */\n\tber_read_contextual_tag(s, 1, &length, TRUE);\n\tber_read_octet_string_tag(s, &length);\n\tcredssp->identity.UserLength = (UINT32) length;\n\tcredssp->identity.User = (UINT16*) malloc(length);\n\tCopyMemory(credssp->identity.User, Stream_Pointer(s), credssp->identity.UserLength);\n\tStream_Seek(s, credssp->identity.UserLength);\n\tcredssp->identity.UserLength /= 2;\n\n\t/* [2] password (OCTET STRING) */\n\tber_read_contextual_tag(s, 2, &length, TRUE);\n\tber_read_octet_string_tag(s, &length);\n\tcredssp->identity.PasswordLength = (UINT32) length;\n\tcredssp->identity.Password = (UINT16*) malloc(length);\n\tCopyMemory(credssp->identity.Password, Stream_Pointer(s), credssp->identity.PasswordLength);\n\tStream_Seek(s, credssp->identity.PasswordLength);\n\tcredssp->identity.PasswordLength /= 2;\n\n\tcredssp->identity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;\n}\n\nint credssp_write_ts_password_creds(rdpCredssp* credssp, wStream* s)\n{\n\tint size = 0;\n\tint innerSize = credssp_sizeof_ts_password_creds(credssp);\n\n\t/* TSPasswordCreds (SEQUENCE) */\n\n\tsize += ber_write_sequence_tag(s, innerSize);\n\n\t/* [0] domainName (OCTET STRING) */\n\tsize += ber_write_sequence_octet_string(s, 0, (BYTE*) credssp->identity.Domain, credssp->identity.DomainLength * 2);\n\n\t/* [1] userName (OCTET STRING) */\n\tsize += ber_write_sequence_octet_string(s, 1, (BYTE*) credssp->identity.User, credssp->identity.UserLength * 2);\n\n\t/* [2] password (OCTET STRING) */\n\tsize += ber_write_sequence_octet_string(s, 2, (BYTE*) credssp->identity.Password, credssp->identity.PasswordLength * 2);\n\n\treturn size;\n}\n\nint credssp_sizeof_ts_credentials(rdpCredssp* credssp)\n{\n\tint size = 0;\n\n\tsize += ber_sizeof_integer(1);\n\tsize += ber_sizeof_contextual_tag(ber_sizeof_integer(1));\n\tsize += ber_sizeof_sequence_octet_string(ber_sizeof_sequence(credssp_sizeof_ts_password_creds(credssp)));\n\n\treturn size;\n}\n\nvoid credssp_read_ts_credentials(rdpCredssp* credssp, PSecBuffer ts_credentials)\n{\n\twStream* s;\n\tint length;\n\tint ts_password_creds_length;\n\n\ts = Stream_New(ts_credentials->pvBuffer, ts_credentials->cbBuffer);\n\n\t/* TSCredentials (SEQUENCE) */\n\tber_read_sequence_tag(s, &length);\n\n\t/* [0] credType (INTEGER) */\n\tber_read_contextual_tag(s, 0, &length, TRUE);\n\tber_read_integer(s, NULL);\n\n\t/* [1] credentials (OCTET STRING) */\n\tber_read_contextual_tag(s, 1, &length, TRUE);\n\tber_read_octet_string_tag(s, &ts_password_creds_length);\n\n\tcredssp_read_ts_password_creds(credssp, s);\n\n\tStream_Free(s, FALSE);\n}\n\nint credssp_write_ts_credentials(rdpCredssp* credssp, wStream* s)\n{\n\tint size = 0;\n\tint innerSize = credssp_sizeof_ts_credentials(credssp);\n\tint passwordSize;\n\n\t/* TSCredentials (SEQUENCE) */\n\tsize += ber_write_sequence_tag(s, innerSize);\n\n\t/* [0] credType (INTEGER) */\n\tsize += ber_write_contextual_tag(s, 0, ber_sizeof_integer(1), TRUE);\n\tsize += ber_write_integer(s, 1);\n\n\t/* [1] credentials (OCTET STRING) */\n\n\tpasswordSize = ber_sizeof_sequence(credssp_sizeof_ts_password_creds(credssp));\n\n\tsize += ber_write_contextual_tag(s, 1, ber_sizeof_octet_string(passwordSize), TRUE);\n\tsize += ber_write_octet_string_tag(s, passwordSize);\n\tsize += credssp_write_ts_password_creds(credssp, s);\n\n\treturn size;\n}\n\n/**\n * Encode TSCredentials structure.\n * @param credssp\n */\n\nvoid credssp_encode_ts_credentials(rdpCredssp* credssp)\n{\n\twStream* s;\n\tint length;\n\n\tlength = ber_sizeof_sequence(credssp_sizeof_ts_credentials(credssp));\n\tsspi_SecBufferAlloc(&credssp->ts_credentials, length);\n\n\ts = Stream_New(credssp->ts_credentials.pvBuffer, length);\n\tcredssp_write_ts_credentials(credssp, s);\n\n\tStream_Free(s, FALSE);\n}\n\nSECURITY_STATUS credssp_encrypt_ts_credentials(rdpCredssp* credssp)\n{\n\tSecBuffer Buffers[2];\n\tSecBufferDesc Message;\n\tSECURITY_STATUS status;\n\n\tcredssp_encode_ts_credentials(credssp);\n\n\tBuffers[0].BufferType = SECBUFFER_TOKEN; /* Signature */\n\tBuffers[1].BufferType = SECBUFFER_DATA; /* TSCredentials */\n\n\tsspi_SecBufferAlloc(&credssp->authInfo, credssp->ContextSizes.cbMaxSignature + credssp->ts_credentials.cbBuffer);\n\n\tBuffers[0].cbBuffer = credssp->ContextSizes.cbMaxSignature;\n\tBuffers[0].pvBuffer = credssp->authInfo.pvBuffer;\n\tZeroMemory(Buffers[0].pvBuffer, Buffers[0].cbBuffer);\n\n\tBuffers[1].cbBuffer = credssp->ts_credentials.cbBuffer;\n\tBuffers[1].pvBuffer = &((BYTE*) credssp->authInfo.pvBuffer)[Buffers[0].cbBuffer];\n\tCopyMemory(Buffers[1].pvBuffer, credssp->ts_credentials.pvBuffer, Buffers[1].cbBuffer);\n\n\tMessage.cBuffers = 2;\n\tMessage.ulVersion = SECBUFFER_VERSION;\n\tMessage.pBuffers = (PSecBuffer) &Buffers;\n\n\tstatus = credssp->table->EncryptMessage(&credssp->context, 0, &Message, credssp->send_seq_num++);\n\n\tif (status != SEC_E_OK)\n\t\treturn status;\n\n\treturn SEC_E_OK;\n}\n\nSECURITY_STATUS credssp_decrypt_ts_credentials(rdpCredssp* credssp)\n{\n\tint length;\n\tBYTE* buffer;\n\tULONG pfQOP;\n\tSecBuffer Buffers[2];\n\tSecBufferDesc Message;\n\tSECURITY_STATUS status;\n\n\tBuffers[0].BufferType = SECBUFFER_TOKEN; /* Signature */\n\tBuffers[1].BufferType = SECBUFFER_DATA; /* TSCredentials */\n\n\tif (credssp->authInfo.cbBuffer < 1)\n\t{\n\t\tfprintf(stderr, \"credssp_decrypt_ts_credentials missing authInfo buffer\\n\");\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tlength = credssp->authInfo.cbBuffer;\n\tbuffer = (BYTE*) malloc(length);\n\tCopyMemory(buffer, credssp->authInfo.pvBuffer, length);\n\n\tBuffers[0].cbBuffer = credssp->ContextSizes.cbMaxSignature;\n\tBuffers[0].pvBuffer = buffer;\n\n\tBuffers[1].cbBuffer = length - credssp->ContextSizes.cbMaxSignature;\n\tBuffers[1].pvBuffer = &buffer[credssp->ContextSizes.cbMaxSignature];\n\n\tMessage.cBuffers = 2;\n\tMessage.ulVersion = SECBUFFER_VERSION;\n\tMessage.pBuffers = (PSecBuffer) &Buffers;\n\n\tstatus = credssp->table->DecryptMessage(&credssp->context, &Message, credssp->recv_seq_num++, &pfQOP);\n\n\tif (status != SEC_E_OK)\n\t\treturn status;\n\n\tcredssp_read_ts_credentials(credssp, &Buffers[1]);\n\n\tfree(buffer);\n\n\treturn SEC_E_OK;\n}\n\nint credssp_sizeof_nego_token(int length)\n{\n\tlength = ber_sizeof_octet_string(length);\n\tlength += ber_sizeof_contextual_tag(length);\n\treturn length;\n}\n\nint credssp_sizeof_nego_tokens(int length)\n{\n\tlength = credssp_sizeof_nego_token(length);\n\tlength += ber_sizeof_sequence_tag(length);\n\tlength += ber_sizeof_sequence_tag(length);\n\tlength += ber_sizeof_contextual_tag(length);\n\treturn length;\n}\n\nint credssp_sizeof_pub_key_auth(int length)\n{\n\tlength = ber_sizeof_octet_string(length);\n\tlength += ber_sizeof_contextual_tag(length);\n\treturn length;\n}\n\nint credssp_sizeof_auth_info(int length)\n{\n\tlength = ber_sizeof_octet_string(length);\n\tlength += ber_sizeof_contextual_tag(length);\n\treturn length;\n}\n\nint credssp_sizeof_ts_request(int length)\n{\n\tlength += ber_sizeof_integer(2);\n\tlength += ber_sizeof_contextual_tag(3);\n\treturn length;\n}\n\n/**\n * Send CredSSP message.\n * @param credssp\n */\n\nvoid credssp_send(rdpCredssp* credssp)\n{\n\twStream* s;\n\tint length;\n\tint ts_request_length;\n\tint nego_tokens_length;\n\tint pub_key_auth_length;\n\tint auth_info_length;\n\n\tnego_tokens_length = (credssp->negoToken.cbBuffer > 0) ? credssp_sizeof_nego_tokens(credssp->negoToken.cbBuffer) : 0;\n\tpub_key_auth_length = (credssp->pubKeyAuth.cbBuffer > 0) ? credssp_sizeof_pub_key_auth(credssp->pubKeyAuth.cbBuffer) : 0;\n\tauth_info_length = (credssp->authInfo.cbBuffer > 0) ? credssp_sizeof_auth_info(credssp->authInfo.cbBuffer) : 0;\n\n\tlength = nego_tokens_length + pub_key_auth_length + auth_info_length;\n\n\tts_request_length = credssp_sizeof_ts_request(length);\n\n\ts = Stream_New(NULL, ber_sizeof_sequence(ts_request_length));\n\n\t/* TSRequest */\n\tber_write_sequence_tag(s, ts_request_length); /* SEQUENCE */\n\n\t/* [0] version */\n\tber_write_contextual_tag(s, 0, 3, TRUE);\n\tber_write_integer(s, 2); /* INTEGER */\n\n\t/* [1] negoTokens (NegoData) */\n\tif (nego_tokens_length > 0)\n\t{\n\t\tlength = nego_tokens_length;\n\n\t\tlength -= ber_write_contextual_tag(s, 1, ber_sizeof_sequence(ber_sizeof_sequence(ber_sizeof_sequence_octet_string(credssp->negoToken.cbBuffer))), TRUE); /* NegoData */\n\t\tlength -= ber_write_sequence_tag(s, ber_sizeof_sequence(ber_sizeof_sequence_octet_string(credssp->negoToken.cbBuffer))); /* SEQUENCE OF NegoDataItem */\n\t\tlength -= ber_write_sequence_tag(s, ber_sizeof_sequence_octet_string(credssp->negoToken.cbBuffer)); /* NegoDataItem */\n\t\tlength -= ber_write_sequence_octet_string(s, 0, (BYTE*) credssp->negoToken.pvBuffer, credssp->negoToken.cbBuffer); /* OCTET STRING */\n\n\t\t// assert length == 0\n\t}\n\n\t/* [2] authInfo (OCTET STRING) */\n\tif (auth_info_length > 0)\n\t{\n\t\tlength = auth_info_length;\n\t\tlength -= ber_write_sequence_octet_string(s, 2, credssp->authInfo.pvBuffer, credssp->authInfo.cbBuffer);\n\n\t\t// assert length == 0\n\t}\n\n\t/* [3] pubKeyAuth (OCTET STRING) */\n\tif (pub_key_auth_length > 0)\n\t{\n\t\tlength = pub_key_auth_length;\n\t\tlength -= ber_write_sequence_octet_string(s, 3, credssp->pubKeyAuth.pvBuffer, credssp->pubKeyAuth.cbBuffer);\n\n\t\t// assert length == 0\n\t}\n\n\tStream_SealLength(s);\n\n\ttransport_write(credssp->transport, s);\n\n\tStream_Free(s, TRUE);\n}\n\n/**\n * Receive CredSSP message.\n * @param credssp\n * @return\n */\n\nint credssp_recv(rdpCredssp* credssp)\n{\n\twStream* s;\n\tint length;\n\tint status;\n\tUINT32 version;\n\n\ts = Stream_New(NULL, 4096);\n\n\tstatus = transport_read(credssp->transport, s);\n\tStream_Length(s) = status;\n\n\tif (status < 0)\n\t{\n\t\tfprintf(stderr, \"credssp_recv() error: %d\\n\", status);\n\t\tStream_Free(s, TRUE);\n\t\treturn -1;\n\t}\n\n\t/* TSRequest */\n\tif(!ber_read_sequence_tag(s, &length) ||\n\t\t!ber_read_contextual_tag(s, 0, &length, TRUE) ||\n\t\t!ber_read_integer(s, &version))\n\t\treturn -1;\n\n\t/* [1] negoTokens (NegoData) */\n\tif (ber_read_contextual_tag(s, 1, &length, TRUE) != FALSE)\n\t{\n\t\tif (!ber_read_sequence_tag(s, &length) || /* SEQUENCE OF NegoDataItem */\n\t\t\t!ber_read_sequence_tag(s, &length) || /* NegoDataItem */\n\t\t\t!ber_read_contextual_tag(s, 0, &length, TRUE) || /* [0] negoToken */\n\t\t\t!ber_read_octet_string_tag(s, &length) || /* OCTET STRING */\n\t\t\tStream_GetRemainingLength(s) < length)\n\t\t\treturn -1;\n\t\tsspi_SecBufferAlloc(&credssp->negoToken, length);\n\t\tStream_Read(s, credssp->negoToken.pvBuffer, length);\n\t\tcredssp->negoToken.cbBuffer = length;\n\t}\n\n\t/* [2] authInfo (OCTET STRING) */\n\tif (ber_read_contextual_tag(s, 2, &length, TRUE) != FALSE)\n\t{\n\t\tif(!ber_read_octet_string_tag(s, &length) || /* OCTET STRING */\n\t\t\tStream_GetRemainingLength(s) < length)\n\t\t\treturn -1;\n\t\tsspi_SecBufferAlloc(&credssp->authInfo, length);\n\t\tStream_Read(s, credssp->authInfo.pvBuffer, length);\n\t\tcredssp->authInfo.cbBuffer = length;\n\t}\n\n\t/* [3] pubKeyAuth (OCTET STRING) */\n\tif (ber_read_contextual_tag(s, 3, &length, TRUE) != FALSE)\n\t{\n\t\tif(!ber_read_octet_string_tag(s, &length) || /* OCTET STRING */\n\t\t\tStream_GetRemainingLength(s) < length)\n\t\t\treturn -1;\n\t\tsspi_SecBufferAlloc(&credssp->pubKeyAuth, length);\n\t\tStream_Read(s, credssp->pubKeyAuth.pvBuffer, length);\n\t\tcredssp->pubKeyAuth.cbBuffer = length;\n\t}\n\n\tStream_Free(s, TRUE);\n\n\treturn 0;\n}\n\nvoid credssp_buffer_print(rdpCredssp* credssp)\n{\n\tif (credssp->negoToken.cbBuffer > 0)\n\t{\n\t\tfprintf(stderr, \"CredSSP.negoToken (length = %d):\\n\", (int) credssp->negoToken.cbBuffer);\n\t\twinpr_HexDump(credssp->negoToken.pvBuffer, credssp->negoToken.cbBuffer);\n\t}\n\n\tif (credssp->pubKeyAuth.cbBuffer > 0)\n\t{\n\t\tfprintf(stderr, \"CredSSP.pubKeyAuth (length = %d):\\n\", (int) credssp->pubKeyAuth.cbBuffer);\n\t\twinpr_HexDump(credssp->pubKeyAuth.pvBuffer, credssp->pubKeyAuth.cbBuffer);\n\t}\n\n\tif (credssp->authInfo.cbBuffer > 0)\n\t{\n\t\tfprintf(stderr, \"CredSSP.authInfo (length = %d):\\n\", (int) credssp->authInfo.cbBuffer);\n\t\twinpr_HexDump(credssp->authInfo.pvBuffer, credssp->authInfo.cbBuffer);\n\t}\n}\n\nvoid credssp_buffer_free(rdpCredssp* credssp)\n{\n\tsspi_SecBufferFree(&credssp->negoToken);\n\tsspi_SecBufferFree(&credssp->pubKeyAuth);\n\tsspi_SecBufferFree(&credssp->authInfo);\n}\n\n/**\n * Create new CredSSP state machine.\n * @param transport\n * @return new CredSSP state machine.\n */\n\nrdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings* settings)\n{\n\trdpCredssp* credssp;\n\n\tcredssp = (rdpCredssp*) malloc(sizeof(rdpCredssp));\n\tZeroMemory(credssp, sizeof(rdpCredssp));\n\n\tif (credssp != NULL)\n\t{\n\t\tHKEY hKey;\n\t\tLONG status;\n\t\tDWORD dwType;\n\t\tDWORD dwSize;\n\n\t\tcredssp->instance = instance;\n\t\tcredssp->settings = settings;\n\t\tcredssp->server = settings->ServerMode;\n\t\tcredssp->transport = transport;\n\t\tcredssp->send_seq_num = 0;\n\t\tcredssp->recv_seq_num = 0;\n\t\tZeroMemory(&credssp->negoToken, sizeof(SecBuffer));\n\t\tZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));\n\t\tZeroMemory(&credssp->authInfo, sizeof(SecBuffer));\n\n\t\tif (credssp->server)\n\t\t{\n\t\t\tstatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T(\"Software\\\\FreeRDP\\\\Server\"),\n\t\t\t\t\t0, KEY_READ | KEY_WOW64_64KEY, &hKey);\n\n\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t{\n\t\t\t\tstatus = RegQueryValueEx(hKey, _T(\"SspiModule\"), NULL, &dwType, NULL, &dwSize);\n\n\t\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t\t{\n\t\t\t\t\tcredssp->SspiModule = (LPTSTR) malloc(dwSize + sizeof(TCHAR));\n\n\t\t\t\t\tstatus = RegQueryValueEx(hKey, _T(\"SspiModule\"), NULL, &dwType,\n\t\t\t\t\t\t\t(BYTE*) credssp->SspiModule, &dwSize);\n\n\t\t\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t\t\t{\n\t\t\t\t\t\t_tprintf(_T(\"Using SSPI Module: %s\\n\"), credssp->SspiModule);\n\t\t\t\t\t\tRegCloseKey(hKey);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn credssp;\n}\n\n/**\n * Free CredSSP state machine.\n * @param credssp\n */\n\nvoid credssp_free(rdpCredssp* credssp)\n{\n\tif (credssp != NULL)\n\t{\n\t\tif (credssp->table)\n\t\t\tcredssp->table->DeleteSecurityContext(&credssp->context);\n\n\t\tsspi_SecBufferFree(&credssp->PublicKey);\n\t\tsspi_SecBufferFree(&credssp->ts_credentials);\n\n\t\tfree(credssp->ServicePrincipalName);\n\n\t\tfree(credssp->identity.User);\n\t\tfree(credssp->identity.Domain);\n\t\tfree(credssp->identity.Password);\n\t\tfree(credssp);\n\t}\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RDP Server Peer\n *\n * Copyright 2011 Vic Lee\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n\n#include \"certificate.h\"\n\n#include <freerdp/utils/tcp.h>\n\n#include \"peer.h\"\n\nstatic BOOL freerdp_peer_initialize(freerdp_peer* client)\n{\n\tclient->context->rdp->settings->ServerMode = TRUE;\n\tclient->context->rdp->settings->FrameAcknowledge = 0;\n\tclient->context->rdp->settings->LocalConnection = client->local;\n\tclient->context->rdp->state = CONNECTION_STATE_INITIAL;\n\n\tif (client->context->rdp->settings->RdpKeyFile != NULL)\n\t{\n\t\tclient->context->rdp->settings->RdpServerRsaKey =\n\t\t    key_new(client->context->rdp->settings->RdpKeyFile);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL freerdp_peer_get_fds(freerdp_peer* client, void** rfds, int* rcount)\n{\n\trfds[*rcount] = (void*)(long)(client->context->rdp->transport->TcpIn->sockfd);\n\t(*rcount)++;\n\n\treturn TRUE;\n}\n\nstatic BOOL freerdp_peer_check_fds(freerdp_peer* client)\n{\n\tint status;\n\trdpRdp* rdp;\n\n\trdp = client->context->rdp;\n\n\tstatus = rdp_check_fds(rdp);\n\n\tif (status < 0)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nstatic BOOL peer_recv_data_pdu(freerdp_peer* client, wStream* s)\n{\n\tBYTE type;\n\tUINT16 length;\n\tUINT32 share_id;\n\tBYTE compressed_type;\n\tUINT16 compressed_len;\n\n\tif (!rdp_read_share_data_header(s, &length, &type, &share_id, &compressed_type, &compressed_len))\n\t\treturn FALSE;\n\n\tswitch (type)\n\t{\n\t\tcase DATA_PDU_TYPE_SYNCHRONIZE:\n\t\t\tif (!rdp_recv_client_synchronize_pdu(client->context->rdp, s))\n\t\t\t\treturn FALSE;\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_CONTROL:\n\t\t\tif (!rdp_server_accept_client_control_pdu(client->context->rdp, s))\n\t\t\t\treturn FALSE;\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_INPUT:\n\t\t\tif (!input_recv(client->context->rdp->input, s))\n\t\t\t\treturn FALSE;\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_BITMAP_CACHE_PERSISTENT_LIST:\n\t\t\t/* TODO: notify server bitmap cache data */\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_FONT_LIST:\n\n\t\t\tif (!rdp_server_accept_client_font_list_pdu(client->context->rdp, s))\n\t\t\t\treturn FALSE;\n\n\t\t\tif (!client->connected)\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * PostConnect should only be called once and should not be called\n\t\t\t\t * after a reactivation sequence.\n\t\t\t\t */\n\n\t\t\t\tIFCALLRET(client->PostConnect, client->connected, client);\n\n\t\t\t\tif (!client->connected)\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tif (!client->activated)\n\t\t\t{\n\t\t\t\t/* Activate will be called everytime after the client is activated/reactivated. */\n\t\t\t\n\t\t\t\tIFCALLRET(client->Activate, client->activated, client);\n\n\t\t\t\tif (!client->activated)\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SHUTDOWN_REQUEST:\n\t\t\tmcs_send_disconnect_provider_ultimatum(client->context->rdp->mcs);\n\t\t\treturn FALSE;\n\n\t\tcase DATA_PDU_TYPE_FRAME_ACKNOWLEDGE:\n\t\t\tif(Stream_GetRemainingLength(s) < 4)\n\t\t\t\treturn FALSE;\n\t\t\tStream_Read_UINT32(s, client->ack_frame_id);\n\t\t\tIFCALL(client->update->SurfaceFrameAcknowledge, client->update->context, client->ack_frame_id);\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_REFRESH_RECT:\n\t\t\tif (!update_read_refresh_rect(client->update, s))\n\t\t\t\treturn FALSE;\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SUPPRESS_OUTPUT:\n\t\t\tif (!update_read_suppress_output(client->update, s))\n\t\t\t\treturn FALSE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Data PDU type %d\\n\", type);\n\t\t\tbreak;\n\t}\n\n\treturn TRUE;\n}\n\nstatic int peer_recv_tpkt_pdu(freerdp_peer* client, wStream* s)\n{\n\trdpRdp* rdp;\n\tUINT16 length;\n\tUINT16 pduType;\n\tUINT16 pduLength;\n\tUINT16 pduSource;\n\tUINT16 channelId;\n\tUINT16 securityFlags;\n\n\trdp = client->context->rdp;\n\n\tif (!rdp_read_header(rdp, s, &length, &channelId))\n\t{\n\t\tfprintf(stderr, \"Incorrect RDP header.\\n\");\n\t\treturn -1;\n\t}\n\n\tif (rdp->settings->DisableEncryption)\n\t{\n\t\tif (!rdp_read_security_header(s, &securityFlags))\n\t\t\treturn -1;\n\n\t\tif (securityFlags & SEC_ENCRYPT)\n\t\t{\n\t\t\tif (!rdp_decrypt(rdp, s, length - 4, securityFlags))\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"rdp_decrypt failed\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (channelId != MCS_GLOBAL_CHANNEL_ID)\n\t{\n\t\tif(!freerdp_channel_peer_process(client, s, channelId))\n\t\t\treturn -1;\n\t}\n\telse\n\t{\n\t\tif (!rdp_read_share_control_header(s, &pduLength, &pduType, &pduSource))\n\t\t\treturn -1;\n\n\t\tclient->settings->PduSource = pduSource;\n\n\t\tswitch (pduType)\n\t\t{\n\t\t\tcase PDU_TYPE_DATA:\n\t\t\t\tif (!peer_recv_data_pdu(client, s))\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"Client sent pduType %d\\n\", pduType);\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int peer_recv_fastpath_pdu(freerdp_peer* client, wStream* s)\n{\n\trdpRdp* rdp;\n\tUINT16 length;\n\trdpFastPath* fastpath;\n\n\trdp = client->context->rdp;\n\tfastpath = rdp->fastpath;\n\t//if (!fastpath_read_header_rdp(fastpath, s, &length))\n\t//\treturn -1;\n\n\tfastpath_read_header_rdp(fastpath, s, &length);\n\n\tif ((length == 0) || (length > Stream_GetRemainingLength(s)))\n\t{\n\t\tfprintf(stderr, \"incorrect FastPath PDU header length %d\\n\", length);\n\t\treturn -1;\n\t}\n\n\tif (fastpath->encryptionFlags & FASTPATH_OUTPUT_ENCRYPTED)\n\t{\n\t\tif (!rdp_decrypt(rdp, s, length, (fastpath->encryptionFlags & FASTPATH_OUTPUT_SECURE_CHECKSUM) ? SEC_SECURE_CHECKSUM : 0))\n\t\t\treturn -1;\n\t}\n\n\treturn fastpath_recv_inputs(fastpath, s);\n}\n\nstatic int peer_recv_pdu(freerdp_peer* client, wStream* s)\n{\n\tif (tpkt_verify_header(s))\n\t\treturn peer_recv_tpkt_pdu(client, s);\n\telse\n\t\treturn peer_recv_fastpath_pdu(client, s);\n}\n\nstatic int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n{\n\tfreerdp_peer* client = (freerdp_peer*) extra;\n\trdpRdp* rdp = client->context->rdp;\n\n\tswitch (rdp->state)\n\t{\n\t\tcase CONNECTION_STATE_INITIAL:\n\t\t\tif (!rdp_server_accept_nego(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tif (rdp->nego->selected_protocol & PROTOCOL_NLA)\n\t\t\t{\n\t\t\t\tsspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);\n\t\t\t\tcredssp_free(rdp->nego->transport->credssp);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, FALSE);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_NEGO:\n\t\t\tif (!rdp_server_accept_mcs_connect_initial(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CONNECT:\n\t\t\tif (!rdp_server_accept_mcs_erect_domain_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ERECT_DOMAIN:\n\t\t\tif (!rdp_server_accept_mcs_attach_user_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ATTACH_USER:\n\t\t\tif (!rdp_server_accept_mcs_channel_join_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CHANNEL_JOIN:\n\t\t\tif (rdp->settings->DisableEncryption)\n\t\t\t{\n\t\t\t\tif (!rdp_server_accept_client_keys(rdp, s))\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trdp->state = CONNECTION_STATE_ESTABLISH_KEYS;\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase CONNECTION_STATE_ESTABLISH_KEYS:\n\t\t\tif (!rdp_server_accept_client_info(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tIFCALL(client->Capabilities, client);\n\n\t\t\tif (!rdp_send_demand_active(rdp))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_LICENSE:\n\t\t\tif (!rdp_server_accept_confirm_active(rdp, s))\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * During reactivation sequence the client might sent some input or channel data\n\t\t\t\t * before receiving the Deactivate All PDU. We need to process them as usual.\n\t\t\t\t */\n\t\t\t\tStream_SetPosition(s, 0);\n\t\t\t\treturn peer_recv_pdu(client, s);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_ACTIVE:\n\t\t\tif (peer_recv_pdu(client, s) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Invalid state %d\\n\", rdp->state);\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic BOOL freerdp_peer_close(freerdp_peer* client)\n{\n\t/**\n\t * [MS-RDPBCGR] 1.3.1.4.2 User-Initiated Disconnection Sequence on Server\n\t * The server first sends the client a Deactivate All PDU followed by an\n\t * optional MCS Disconnect Provider Ultimatum PDU.\n\t */\n\tif (!rdp_send_deactivate_all(client->context->rdp))\n\t\treturn FALSE;\n\treturn mcs_send_disconnect_provider_ultimatum(client->context->rdp->mcs);\n}\n\nstatic void freerdp_peer_disconnect(freerdp_peer* client)\n{\n\ttransport_disconnect(client->context->rdp->transport);\n}\n\nstatic int freerdp_peer_send_channel_data(freerdp_peer* client, int channelId, BYTE* data, int size)\n{\n\treturn rdp_send_channel_data(client->context->rdp, channelId, data, size);\n}\n\nvoid freerdp_peer_context_new(freerdp_peer* client)\n{\n\trdpRdp* rdp;\n\n\trdp = rdp_new(NULL);\n\tclient->input = rdp->input;\n\tclient->update = rdp->update;\n\tclient->settings = rdp->settings;\n\n\tclient->context = (rdpContext*) malloc(client->ContextSize);\n\tZeroMemory(client->context, client->ContextSize);\n\n\tclient->context->rdp = rdp;\n\tclient->context->peer = client;\n\tclient->context->input = client->input;\n\tclient->context->update = client->update;\n\tclient->context->settings = client->settings;\n\n\tclient->update->context = client->context;\n\tclient->input->context = client->context;\n\n\tupdate_register_server_callbacks(client->update);\n\n\ttransport_attach(rdp->transport, client->sockfd);\n\n\trdp->transport->ReceiveCallback = peer_recv_callback;\n\trdp->transport->ReceiveExtra = client;\n\ttransport_set_blocking_mode(rdp->transport, FALSE);\n\n\tIFCALL(client->ContextNew, client, client->context);\n}\n\nvoid freerdp_peer_context_free(freerdp_peer* client)\n{\n\tIFCALL(client->ContextFree, client, client->context);\n}\n\nfreerdp_peer* freerdp_peer_new(int sockfd)\n{\n\tfreerdp_peer* client;\n\n\tclient = (freerdp_peer*) malloc(sizeof(freerdp_peer));\n\tZeroMemory(client, sizeof(freerdp_peer));\n\n\tfreerdp_tcp_set_no_delay(sockfd, TRUE);\n\n\tif (client != NULL)\n\t{\n\t\tclient->sockfd = sockfd;\n\t\tclient->ContextSize = sizeof(rdpContext);\n\t\tclient->Initialize = freerdp_peer_initialize;\n\t\tclient->GetFileDescriptor = freerdp_peer_get_fds;\n\t\tclient->CheckFileDescriptor = freerdp_peer_check_fds;\n\t\tclient->Close = freerdp_peer_close;\n\t\tclient->Disconnect = freerdp_peer_disconnect;\n\t\tclient->SendChannelData = freerdp_peer_send_channel_data;\n\t}\n\n\treturn client;\n}\n\nvoid freerdp_peer_free(freerdp_peer* client)\n{\n\tif (client)\n\t{\n\t\trdp_free(client->context->rdp);\n\t\tfree(client->context);\n\t\tfree(client);\n\t}\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Network Transport Layer\n *\n * Copyright 2011 Vic Lee\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <winpr/crt.h>\n#include <winpr/synch.h>\n#include <winpr/print.h>\n\n#include <freerdp/error.h>\n#include <freerdp/utils/tcp.h>\n#include <winpr/stream.h>\n\n#include <time.h>\n#include <errno.h>\n#include <fcntl.h>\n\n#ifndef _WIN32\n#include <netdb.h>\n#include <sys/socket.h>\n#endif\n\n#include \"tpkt.h\"\n#include \"fastpath.h\"\n#include \"transport.h\"\n\n#define BUFFER_SIZE 16384\n\nstatic void* transport_client_thread(void* arg);\n\nwStream* transport_send_stream_init(rdpTransport* transport, int size)\n{\n\twStream* s;\n\n\ts = StreamPool_Take(transport->ReceivePool, size);\n\n\tStream_EnsureCapacity(s, size);\n\tStream_SetPosition(s, 0);\n\n\treturn s;\n}\n\nvoid transport_attach(rdpTransport* transport, int sockfd)\n{\n\ttransport->TcpIn->sockfd = sockfd;\n\n\ttransport->SplitInputOutput = FALSE;\n\ttransport->TcpOut = transport->TcpIn;\n}\n\nBOOL transport_disconnect(rdpTransport* transport)\n{\n\tBOOL status = TRUE;\n\n\tif (transport->layer == TRANSPORT_LAYER_TLS)\n\t\tstatus &= tls_disconnect(transport->TlsIn);\n\n\tif (transport->layer == TRANSPORT_LAYER_TSG)\n\t{\n\t\ttsg_disconnect(transport->tsg);\n\t}\n\telse\n\t{\n\t\tstatus &= tcp_disconnect(transport->TcpIn);\n\t}\n\n\treturn status;\n}\n\nBOOL transport_connect_rdp(rdpTransport* transport)\n{\n\t/* RDP encryption */\n\n\treturn TRUE;\n}\n\nBOOL transport_connect_tls(rdpTransport* transport)\n{\n\tif (transport->layer == TRANSPORT_LAYER_TSG)\n\t\treturn TRUE;\n\n\tif (transport->TlsIn == NULL)\n\t\ttransport->TlsIn = tls_new(transport->settings);\n\n\tif (transport->TlsOut == NULL)\n\t\ttransport->TlsOut = transport->TlsIn;\n\n\ttransport->layer = TRANSPORT_LAYER_TLS;\n\ttransport->TlsIn->sockfd = transport->TcpIn->sockfd;\n\n\tif (tls_connect(transport->TlsIn) != TRUE)\n\t{\n\t\tif (!connectErrorCode)\n\t\t\tconnectErrorCode = TLSCONNECTERROR;\n\n\t\ttls_free(transport->TlsIn);\n\n\t\tif (transport->TlsIn == transport->TlsOut)\n\t\t\ttransport->TlsIn = transport->TlsOut = NULL;\n\t\telse\n\t\t\ttransport->TlsIn = NULL;\n\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nBOOL transport_connect_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\n\tif (transport->layer == TRANSPORT_LAYER_TSG)\n\t\treturn TRUE;\n\n\tif (!transport_connect_tls(transport))\n\t\treturn FALSE;\n\n\t/* Network Level Authentication */\n\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tif (!connectErrorCode)\n\t\t\tconnectErrorCode = AUTHENTICATIONERROR;\n\n\t\tfprintf(stderr, \"Authentication failure, check credentials.\\n\"\n\t\t\t\"If credentials are valid, the NTLMSSP implementation may be to blame.\\n\");\n\n\t\tcredssp_free(transport->credssp);\n\t\treturn FALSE;\n\t}\n\n\tcredssp_free(transport->credssp);\n\n\treturn TRUE;\n}\n\nBOOL transport_tsg_connect(rdpTransport* transport, const char* hostname, UINT16 port)\n{\n\trdpTsg* tsg = tsg_new(transport);\n\n\ttsg->transport = transport;\n\ttransport->tsg = tsg;\n\ttransport->SplitInputOutput = TRUE;\n\n\tif (transport->TlsIn == NULL)\n\t\ttransport->TlsIn = tls_new(transport->settings);\n\n\ttransport->TlsIn->sockfd = transport->TcpIn->sockfd;\n\n\tif (transport->TlsOut == NULL)\n\t\ttransport->TlsOut = tls_new(transport->settings);\n\n\ttransport->TlsOut->sockfd = transport->TcpOut->sockfd;\n\n\tif (tls_connect(transport->TlsIn) != TRUE)\n\t\treturn FALSE;\n\n\tif (tls_connect(transport->TlsOut) != TRUE)\n\t\treturn FALSE;\n\n\tif (!tsg_connect(tsg, hostname, port))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nBOOL transport_connect(rdpTransport* transport, const char* hostname, UINT16 port)\n{\n\tBOOL status = FALSE;\n\trdpSettings* settings = transport->settings;\n\n\ttransport->async = transport->settings->AsyncTransport;\n\n\tif (transport->async)\n\t{\n\t\ttransport->stopEvent = CreateEvent(NULL, TRUE, FALSE, NULL);\n\n\t\ttransport->thread = CreateThread(NULL, 0,\n\t\t\t\t(LPTHREAD_START_ROUTINE) transport_client_thread, transport, 0, NULL);\n\t}\n\n\tif (transport->settings->GatewayUsageMethod)\n\t{\n\t\ttransport->layer = TRANSPORT_LAYER_TSG;\n\t\ttransport->TcpOut = tcp_new(settings);\n\n\t\tstatus = tcp_connect(transport->TcpIn, settings->GatewayHostname, 443);\n\n\t\tif (status)\n\t\t\tstatus = tcp_connect(transport->TcpOut, settings->GatewayHostname, 443);\n\n\t\tif (status)\n\t\t\tstatus = transport_tsg_connect(transport, hostname, port);\n\t}\n\telse\n\t{\n\t\tstatus = tcp_connect(transport->TcpIn, hostname, port);\n\n\t\ttransport->SplitInputOutput = FALSE;\n\t\ttransport->TcpOut = transport->TcpIn;\n\t}\n\n\treturn status;\n}\n\nBOOL transport_accept_rdp(rdpTransport* transport)\n{\n\t/* RDP encryption */\n\n\treturn TRUE;\n}\n\nBOOL transport_accept_tls(rdpTransport* transport)\n{\n\tif (transport->TlsIn == NULL)\n\t\ttransport->TlsIn = tls_new(transport->settings);\n\n\tif (transport->TlsOut == NULL)\n\t\ttransport->TlsOut = transport->TlsIn;\n\n\ttransport->layer = TRANSPORT_LAYER_TLS;\n\ttransport->TlsIn->sockfd = transport->TcpIn->sockfd;\n\n\tif (tls_accept(transport->TlsIn, transport->settings->CertificateFile, transport->settings->PrivateKeyFile) != TRUE)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nBOOL transport_accept_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\n\tif (transport->TlsIn == NULL)\n\t\ttransport->TlsIn = tls_new(transport->settings);\n\n\tif (transport->TlsOut == NULL)\n\t\ttransport->TlsOut = transport->TlsIn;\n\n\ttransport->layer = TRANSPORT_LAYER_TLS;\n\ttransport->TlsIn->sockfd = transport->TcpIn->sockfd;\n\n\tif (tls_accept(transport->TlsIn, transport->settings->CertificateFile, transport->settings->PrivateKeyFile) != TRUE)\n\t\treturn FALSE;\n\n\t/* Network Level Authentication */\n\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tfprintf(stderr, \"client authentication failure\\n\");\n\t\tcredssp_free(transport->credssp);\n\t\treturn FALSE;\n\t}\n\n\t/* don't free credssp module yet, we need to copy the credentials from it first */\n\n\treturn TRUE;\n}\n\nBOOL nla_verify_header(wStream* s)\n{\n\tif ((s->pointer[0] == 0x30) && (s->pointer[1] & 0x80))\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n\nUINT32 nla_read_header(wStream* s)\n{\n\tUINT32 length = 0;\n\n\tif (s->pointer[1] & 0x80)\n\t{\n\t\tif ((s->pointer[1] & ~(0x80)) == 1)\n\t\t{\n\t\t\tlength = s->pointer[2];\n\t\t\tlength += 3;\n\t\t\tStream_Seek(s, 3);\n\t\t}\n\t\telse if ((s->pointer[1] & ~(0x80)) == 2)\n\t\t{\n\t\t\tlength = (s->pointer[2] << 8) | s->pointer[3];\n\t\t\tlength += 4;\n\t\t\tStream_Seek(s, 4);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfprintf(stderr, \"Error reading TSRequest!\\n\");\n\t\t}\n\t}\n\telse\n\t{\n\t\tlength = s->pointer[1];\n\t\tlength += 2;\n\t\tStream_Seek(s, 2);\n\t}\n\n\treturn length;\n}\n\nUINT32 nla_header_length(wStream* s)\n{\n\tUINT32 length = 0;\n\n\tif (s->pointer[1] & 0x80)\n\t{\n\t\tif ((s->pointer[1] & ~(0x80)) == 1)\n\t\t\tlength = 3;\n\t\telse if ((s->pointer[1] & ~(0x80)) == 2)\n\t\t\tlength = 4;\n\t\telse\n\t\t\tfprintf(stderr, \"Error reading TSRequest!\\n\");\n\t}\n\telse\n\t{\n\t\tlength = 2;\n\t}\n\n\treturn length;\n}\n\nint transport_read_layer(rdpTransport* transport, UINT8* data, int bytes)\n{\n\tint read = 0;\n\tint status = -1;\n\n\twhile (read < bytes)\n\t{\n\t\tif (transport->layer == TRANSPORT_LAYER_TLS)\n\t\t\tstatus = tls_read(transport->TlsIn, data + read, bytes - read);\n\t\telse if (transport->layer == TRANSPORT_LAYER_TCP)\n\t\t\tstatus = tcp_read(transport->TcpIn, data + read, bytes - read);\n\t\telse if (transport->layer == TRANSPORT_LAYER_TSG)\n\t\t\tstatus = tsg_read(transport->tsg, data + read, bytes - read);\n\n\t\t/* blocking means that we can't continue until this is read */\n\n\t\tif (!transport->blocking)\n\t\t\treturn status;\n\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\tread += status;\n\n\t\tif (status == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * instead of sleeping, we should wait timeout on the\n\t\t\t * socket but this only happens on initial connection\n\t\t\t */\n\t\t\tUSleep(transport->SleepInterval);\n\t\t}\n\t}\n\n\treturn read;\n}\n\nint transport_read(rdpTransport* transport, wStream* s)\n{\n\tint status;\n\tint pduLength;\n\tint streamPosition;\n\tint transport_status;\n\n\tpduLength = 0;\n\ttransport_status = 0;\n\n\t/* first check if we have header */\n\tstreamPosition = Stream_GetPosition(s);\n\n\tif (streamPosition < 4)\n\t{\n\t\tstatus = transport_read_layer(transport, Stream_Buffer(s) + streamPosition, 4 - streamPosition);\n\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\ttransport_status += status;\n\n\t\tif ((status + streamPosition) < 4)\n\t\t\treturn transport_status;\n\n\t\tstreamPosition += status;\n\t}\n\n\t/* if header is present, read in exactly one PDU */\n\tif (s->buffer[0] == 0x03)\n\t{\n\t\t/* TPKT header */\n\n\t\tpduLength = (s->buffer[2] << 8) | s->buffer[3];\n\t}\n\telse if (s->buffer[0] == 0x30)\n\t{\n\t\t/* TSRequest (NLA) */\n\n\t\tif (s->buffer[1] & 0x80)\n\t\t{\n\t\t\tif ((s->buffer[1] & ~(0x80)) == 1)\n\t\t\t{\n\t\t\t\tpduLength = s->buffer[2];\n\t\t\t\tpduLength += 3;\n\t\t\t}\n\t\t\telse if ((s->buffer[1] & ~(0x80)) == 2)\n\t\t\t{\n\t\t\t\tpduLength = (s->buffer[2] << 8) | s->buffer[3];\n\t\t\t\tpduLength += 4;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"Error reading TSRequest!\\n\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpduLength = s->buffer[1];\n\t\t\tpduLength += 2;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Fast-Path Header */\n\n\t\tif (s->buffer[1] & 0x80)\n\t\t\tpduLength = ((s->buffer[1] & 0x7F) << 8) | s->buffer[2];\n\t\telse\n\t\t\tpduLength = s->buffer[1];\n\t}\n\n\tstatus = transport_read_layer(transport, Stream_Buffer(s) + streamPosition, pduLength - streamPosition);\n\n\tif (status < 0)\n\t\treturn status;\n\n\ttransport_status += status;\n\n#ifdef WITH_DEBUG_TRANSPORT\n\t/* dump when whole PDU is read */\n\tif (streamPosition + status >= pduLength)\n\t{\n\t\tfprintf(stderr, \"Local < Remote\\n\");\n\t\twinpr_HexDump(Stream_Buffer(s), pduLength);\n\t}\n#endif\n\n\treturn transport_status;\n}\n\nstatic int transport_read_nonblocking(rdpTransport* transport)\n{\n\tint status;\n\n\tstatus = transport_read(transport, transport->ReceiveBuffer);\n\n\tif (status <= 0)\n\t\treturn status;\n\n\tStream_Seek(transport->ReceiveBuffer, status);\n\n\treturn status;\n}\n\nint transport_write(rdpTransport* transport, wStream* s)\n{\n\tint length;\n\tint status = -1;\n\n\tWaitForSingleObject(transport->WriteMutex, INFINITE);\n\n\tlength = Stream_GetPosition(s);\n\tStream_SetPosition(s, 0);\n\n#ifdef WITH_DEBUG_TRANSPORT\n\tif (length > 0)\n\t{\n\t\tfprintf(stderr, \"Local > Remote\\n\");\n\t\twinpr_HexDump(Stream_Buffer(s), length);\n\t}\n#endif\n\n\twhile (length > 0)\n\t{\n\t\tif (transport->layer == TRANSPORT_LAYER_TLS)\n\t\t\tstatus = tls_write(transport->TlsOut, Stream_Pointer(s), length);\n\t\telse if (transport->layer == TRANSPORT_LAYER_TCP)\n\t\t\tstatus = tcp_write(transport->TcpOut, Stream_Pointer(s), length);\n\t\telse if (transport->layer == TRANSPORT_LAYER_TSG)\n\t\t\tstatus = tsg_write(transport->tsg, Stream_Pointer(s), length);\n\n\t\tif (status < 0)\n\t\t\tbreak; /* error occurred */\n\n\t\tif (status == 0)\n\t\t{\n\t\t\t/* when sending is blocked in nonblocking mode, the receiving buffer should be checked */\n\t\t\tif (!transport->blocking)\n\t\t\t{\n\t\t\t\t/* and in case we do have buffered some data, we set the event so next loop will get it */\n\t\t\t\tif (transport_read_nonblocking(transport) > 0)\n\t\t\t\t\tSetEvent(transport->ReceiveEvent);\n\t\t\t}\n\n\t\t\tif (transport->layer == TRANSPORT_LAYER_TLS)\n\t\t\t\ttls_wait_write(transport->TlsOut);\n\t\t\telse if (transport->layer == TRANSPORT_LAYER_TCP)\n\t\t\t\ttcp_wait_write(transport->TcpOut);\n\t\t\telse\n\t\t\t\tUSleep(transport->SleepInterval);\n\t\t}\n\n\t\tlength -= status;\n\t\tStream_Seek(s, status);\n\t}\n\n\tif (status < 0)\n\t{\n\t\t/* A write error indicates that the peer has dropped the connection */\n\t\ttransport->layer = TRANSPORT_LAYER_CLOSED;\n\t}\n\n\tif (s->pool)\n\t\tStream_Release(s);\n\n\tReleaseMutex(transport->WriteMutex);\n\n\treturn status;\n}\n\n\nvoid transport_get_fds(rdpTransport* transport, void** rfds, int* rcount)\n{\n\tvoid* pfd;\n\n#ifdef _WIN32\n\trfds[*rcount] = transport->TcpIn->wsa_event;\n\t(*rcount)++;\n\n\tif (transport->SplitInputOutput)\n\t{\n\t\trfds[*rcount] = transport->TcpOut->wsa_event;\n\t\t(*rcount)++;\n\t}\n#else\n\trfds[*rcount] = (void*)(long)(transport->TcpIn->sockfd);\n\t(*rcount)++;\n\n\tif (transport->SplitInputOutput)\n\t{\n\t\trfds[*rcount] = (void*)(long)(transport->TcpOut->sockfd);\n\t\t(*rcount)++;\n\t}\n#endif\n\n\tpfd = GetEventWaitObject(transport->ReceiveEvent);\n\n\tif (pfd)\n\t{\n\t\trfds[*rcount] = pfd;\n\t\t(*rcount)++;\n\t}\n\n\tif (transport->GatewayEvent)\n\t{\n\t\tpfd = GetEventWaitObject(transport->GatewayEvent);\n\n\t\tif (pfd)\n\t\t{\n\t\t\trfds[*rcount] = pfd;\n\t\t\t(*rcount)++;\n\t\t}\n\t}\n}\n\nvoid transport_get_read_handles(rdpTransport* transport, HANDLE* events, DWORD* count)\n{\n\tevents[*count] = tcp_get_event_handle(transport->TcpIn);\n\t(*count)++;\n\n\tif (transport->SplitInputOutput)\n\t{\n\t\tevents[*count] = tcp_get_event_handle(transport->TcpOut);\n\t\t(*count)++;\n\t}\n\n\tif (transport->ReceiveEvent)\n\t{\n\t\tevents[*count] = transport->ReceiveEvent;\n\t\t(*count)++;\n\t}\n\n\tif (transport->GatewayEvent)\n\t{\n\t\tevents[*count] = transport->GatewayEvent;\n\t\t(*count)++;\n\t}\n}\n\nint transport_check_fds(rdpTransport** ptransport)\n{\n\tint pos;\n\tint status;\n\tUINT16 length;\n\tint recv_status;\n\twStream* received;\n\trdpTransport* transport = *ptransport;\n\n#ifdef _WIN32\n\tWSAResetEvent(transport->TcpIn->wsa_event);\n#endif\n\tResetEvent(transport->ReceiveEvent);\n\n\tstatus = transport_read_nonblocking(transport);\n\n\tif (status < 0)\n\t\treturn status;\n\n\twhile ((pos = Stream_GetPosition(transport->ReceiveBuffer)) > 0)\n\t{\n\t\tStream_SetPosition(transport->ReceiveBuffer, 0);\n\n\t\tif (tpkt_verify_header(transport->ReceiveBuffer)) /* TPKT */\n\t\t{\n\t\t\t/* Ensure the TPKT header is available. */\n\t\t\tif (pos <= 4)\n\t\t\t{\n\t\t\t\tStream_SetPosition(transport->ReceiveBuffer, pos);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tlength = tpkt_read_header(transport->ReceiveBuffer);\n\t\t}\n\t\telse if (nla_verify_header(transport->ReceiveBuffer))\n\t\t{\n\t\t\t/* TSRequest */\n\n\t\t\t/* Ensure the TSRequest header is available. */\n\t\t\tif (pos <= 4)\n\t\t\t{\n\t\t\t\tStream_SetPosition(transport->ReceiveBuffer, pos);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* TSRequest header can be 2, 3 or 4 bytes long */\n\t\t\tlength = nla_header_length(transport->ReceiveBuffer);\n\n\t\t\tif (pos < length)\n\t\t\t{\n\t\t\t\tStream_SetPosition(transport->ReceiveBuffer, pos);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tlength = nla_read_header(transport->ReceiveBuffer);\n\t\t}\n\t\telse /* Fast Path */\n\t\t{\n\t\t\t/* Ensure the Fast Path header is available. */\n\t\t\tif (pos <= 2)\n\t\t\t{\n\t\t\t\tStream_SetPosition(transport->ReceiveBuffer, pos);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Fastpath header can be two or three bytes long. */\n\t\t\tlength = fastpath_header_length(transport->ReceiveBuffer);\n\n\t\t\tif (pos < length)\n\t\t\t{\n\t\t\t\tStream_SetPosition(transport->ReceiveBuffer, pos);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tlength = fastpath_read_header(NULL, transport->ReceiveBuffer);\n\t\t}\n\n\t\tif (length == 0)\n\t\t{\n\t\t\tfprintf(stderr, \"transport_check_fds: protocol error, not a TPKT or Fast Path header.\\n\");\n\t\t\twinpr_HexDump(Stream_Buffer(transport->ReceiveBuffer), pos);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (pos < length)\n\t\t{\n\t\t\tStream_SetPosition(transport->ReceiveBuffer, pos);\n\t\t\treturn 0; /* Packet is not yet completely received. */\n\t\t}\n\n\t\treceived = transport->ReceiveBuffer;\n\t\ttransport->ReceiveBuffer = StreamPool_Take(transport->ReceivePool, 0);\n\n\t\tStream_SetPosition(received, length);\n\t\tStream_SealLength(received);\n\t\tStream_SetPosition(received, 0);\n\n\t\trecv_status = transport->ReceiveCallback(transport, received, transport->ReceiveExtra);\n\n\t\tStream_Release(received);\n\n\t\tif (recv_status < 0)\n\t\t\tstatus = -1;\n\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\t/* transport might now have been freed by rdp_client_redirect and a new rdp->transport created */\n\t\ttransport = *ptransport;\n\t}\n\n\treturn 0;\n}\n\nBOOL transport_set_blocking_mode(rdpTransport* transport, BOOL blocking)\n{\n\tBOOL status;\n\n\tstatus = TRUE;\n\ttransport->blocking = blocking;\n\n\tif (transport->SplitInputOutput)\n\t{\n\t\tstatus &= tcp_set_blocking_mode(transport->TcpIn, blocking);\n\t\tstatus &= tcp_set_blocking_mode(transport->TcpOut, blocking);\n\t}\n\telse\n\t{\n\t\tstatus &= tcp_set_blocking_mode(transport->TcpIn, blocking);\n\t}\n\n\tif (transport->layer == TRANSPORT_LAYER_TSG)\n\t{\n\t\ttsg_set_blocking_mode(transport->tsg, blocking);\n\t}\n\n\treturn status;\n}\n\nstatic void* transport_client_thread(void* arg)\n{\n\tDWORD status;\n\tDWORD nCount;\n\tHANDLE events[32];\n\tfreerdp* instance;\n\trdpContext* context;\n\trdpTransport* transport;\n\tTerminateEventArgs e;\n\n\ttransport = (rdpTransport*) arg;\n\tinstance = (freerdp*) transport->settings->instance;\n\tcontext = instance->context;\n\n\twhile (1)\n\t{\n\t\tnCount = 0;\n\t\tevents[nCount++] = transport->stopEvent;\n\t\tevents[nCount] = transport->connectedEvent;\n\n\t\tstatus = WaitForMultipleObjects(nCount + 1, events, FALSE, INFINITE);\n\n\t\tif (WaitForSingleObject(transport->stopEvent, 0) == WAIT_OBJECT_0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\ttransport_get_read_handles(transport, (HANDLE*) &events, &nCount);\n\n\t\tstatus = WaitForMultipleObjects(nCount, events, FALSE, INFINITE);\n\n\t\tif (WaitForSingleObject(transport->stopEvent, 0) == WAIT_OBJECT_0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!freerdp_check_fds(instance))\n\t\t\tbreak;\n\t}\n\n\treturn NULL;\n}\n\nrdpTransport* transport_new(rdpSettings* settings)\n{\n\trdpTransport* transport;\n\n\ttransport = (rdpTransport*) malloc(sizeof(rdpTransport));\n\n\tif (transport != NULL)\n\t{\n\t\tZeroMemory(transport, sizeof(rdpTransport));\n\n\t\ttransport->TcpIn = tcp_new(settings);\n\n\t\ttransport->settings = settings;\n\n\t\t/* a small 0.1ms delay when transport is blocking. */\n\t\ttransport->SleepInterval = 100;\n\n\t\ttransport->ReceivePool = StreamPool_New(TRUE, BUFFER_SIZE);\n\n\t\t/* receive buffer for non-blocking read. */\n\t\ttransport->ReceiveBuffer = StreamPool_Take(transport->ReceivePool, 0);\n\t\ttransport->ReceiveEvent = CreateEvent(NULL, TRUE, FALSE, NULL);\n\n\t\ttransport->connectedEvent = CreateEvent(NULL, TRUE, FALSE, NULL);\n\n\t\ttransport->blocking = TRUE;\n\n\t\ttransport->ReadMutex = CreateMutex(NULL, FALSE, NULL);\n\t\ttransport->WriteMutex = CreateMutex(NULL, FALSE, NULL);\n\n\t\ttransport->layer = TRANSPORT_LAYER_TCP;\n\t}\n\n\treturn transport;\n}\n\nvoid transport_free(rdpTransport* transport)\n{\n\tif (transport != NULL)\n\t{\n        SetEvent(transport->stopEvent);\n        \n\t\tif (transport->ReceiveBuffer)\n\t\t\tStream_Release(transport->ReceiveBuffer);\n\n\t\tStreamPool_Free(transport->ReceivePool);\n\n\t\tCloseHandle(transport->ReceiveEvent);\n\t\tCloseHandle(transport->connectedEvent);\n\n\t\tif (transport->TlsIn)\n\t\t\ttls_free(transport->TlsIn);\n\n\t\tif (transport->TlsOut != transport->TlsIn)\n\t\t\ttls_free(transport->TlsOut);\n\n\t\ttcp_free(transport->TcpIn);\n\n\t\tif (transport->TcpOut != transport->TcpIn)\n\t\t\ttcp_free(transport->TcpOut);\n\n\t\ttsg_free(transport->tsg);\n\n\t\tCloseHandle(transport->ReadMutex);\n\t\tCloseHandle(transport->WriteMutex);\n\n\t\tfree(transport);\n\t}\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Security Support Provider Interface (SSPI)\n *\n * Copyright 2012 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdlib.h>\n\n#include <winpr/windows.h>\n\n#include <winpr/crt.h>\n#include <winpr/sspi.h>\n#include <winpr/print.h>\n\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n\n#include \"sspi.h\"\n\n/* Authentication Functions: http://msdn.microsoft.com/en-us/library/windows/desktop/aa374731/ */\n\n#ifdef WINPR_SSPI\n\nextern const SecPkgInfoA NTLM_SecPkgInfoA;\nextern const SecPkgInfoW NTLM_SecPkgInfoW;\nextern const SecurityFunctionTableA NTLM_SecurityFunctionTableA;\nextern const SecurityFunctionTableW NTLM_SecurityFunctionTableW;\n\nextern const SecPkgInfoA CREDSSP_SecPkgInfoA;\nextern const SecPkgInfoW CREDSSP_SecPkgInfoW;\nextern const SecurityFunctionTableA CREDSSP_SecurityFunctionTableA;\nextern const SecurityFunctionTableW CREDSSP_SecurityFunctionTableW;\n\nextern const SecPkgInfoA SCHANNEL_SecPkgInfoA;\nextern const SecPkgInfoW SCHANNEL_SecPkgInfoW;\nextern const SecurityFunctionTableA SCHANNEL_SecurityFunctionTableA;\nextern const SecurityFunctionTableW SCHANNEL_SecurityFunctionTableW;\n\nconst SecPkgInfoA* SecPkgInfoA_LIST[] =\n{\n\t&NTLM_SecPkgInfoA,\n\t&CREDSSP_SecPkgInfoA,\n\t&SCHANNEL_SecPkgInfoA\n};\n\nconst SecPkgInfoW* SecPkgInfoW_LIST[] =\n{\n\t&NTLM_SecPkgInfoW,\n\t&CREDSSP_SecPkgInfoW,\n\t&SCHANNEL_SecPkgInfoW\n};\n\nSecurityFunctionTableA SSPI_SecurityFunctionTableA;\nSecurityFunctionTableW SSPI_SecurityFunctionTableW;\n\nstruct _SecurityFunctionTableA_NAME\n{\n\tSEC_CHAR* Name;\n\tconst SecurityFunctionTableA* SecurityFunctionTable;\n};\ntypedef struct _SecurityFunctionTableA_NAME SecurityFunctionTableA_NAME;\n\nstruct _SecurityFunctionTableW_NAME\n{\n\tSEC_WCHAR* Name;\n\tconst SecurityFunctionTableW* SecurityFunctionTable;\n};\ntypedef struct _SecurityFunctionTableW_NAME SecurityFunctionTableW_NAME;\n\nconst SecurityFunctionTableA_NAME SecurityFunctionTableA_NAME_LIST[] =\n{\n\t{ \"NTLM\", &NTLM_SecurityFunctionTableA },\n\t{ \"CREDSSP\", &CREDSSP_SecurityFunctionTableA },\n\t{ \"Schannel\", &SCHANNEL_SecurityFunctionTableA }\n};\n\nWCHAR NTLM_NAME_W[] = { 'N','T','L','M','\\0' };\nWCHAR CREDSSP_NAME_W[] = { 'C','r','e','d','S','S','P','\\0' };\nWCHAR SCHANNEL_NAME_W[] = { 'S','c','h','a','n','n','e','l','\\0' };\n\nconst SecurityFunctionTableW_NAME SecurityFunctionTableW_NAME_LIST[] =\n{\n\t{ NTLM_NAME_W, &NTLM_SecurityFunctionTableW },\n\t{ CREDSSP_NAME_W, &CREDSSP_SecurityFunctionTableW },\n\t{ SCHANNEL_NAME_W, &SCHANNEL_SecurityFunctionTableW }\n};\n\n#endif\n\n#define SecHandle_LOWER_MAX\t0xFFFFFFFF\n#define SecHandle_UPPER_MAX\t0xFFFFFFFE\n\nstruct _CONTEXT_BUFFER_ALLOC_ENTRY\n{\n\tvoid* contextBuffer;\n\tUINT32 allocatorIndex;\n};\ntypedef struct _CONTEXT_BUFFER_ALLOC_ENTRY CONTEXT_BUFFER_ALLOC_ENTRY;\n\nstruct _CONTEXT_BUFFER_ALLOC_TABLE\n{\n\tUINT32 cEntries;\n\tUINT32 cMaxEntries;\n\tCONTEXT_BUFFER_ALLOC_ENTRY* entries;\n};\ntypedef struct _CONTEXT_BUFFER_ALLOC_TABLE CONTEXT_BUFFER_ALLOC_TABLE;\n\nCONTEXT_BUFFER_ALLOC_TABLE ContextBufferAllocTable;\n\nvoid sspi_ContextBufferAllocTableNew()\n{\n\tsize_t size;\n\n\tContextBufferAllocTable.cEntries = 0;\n\tContextBufferAllocTable.cMaxEntries = 4;\n\n\tsize = sizeof(CONTEXT_BUFFER_ALLOC_ENTRY) * ContextBufferAllocTable.cMaxEntries;\n\n\tContextBufferAllocTable.entries = malloc(size);\n\tZeroMemory(ContextBufferAllocTable.entries, size);\n}\n\nvoid sspi_ContextBufferAllocTableGrow()\n{\n\tsize_t size;\n\tContextBufferAllocTable.cEntries = 0;\n\tContextBufferAllocTable.cMaxEntries *= 2;\n\n\tsize = sizeof(CONTEXT_BUFFER_ALLOC_ENTRY) * ContextBufferAllocTable.cMaxEntries;\n\n\tContextBufferAllocTable.entries = realloc(ContextBufferAllocTable.entries, size);\n\tZeroMemory((void*) &ContextBufferAllocTable.entries[ContextBufferAllocTable.cMaxEntries / 2], size / 2);\n}\n\nvoid sspi_ContextBufferAllocTableFree()\n{\n\tContextBufferAllocTable.cEntries = ContextBufferAllocTable.cMaxEntries = 0;\n\tfree(ContextBufferAllocTable.entries);\n}\n\nvoid* sspi_ContextBufferAlloc(UINT32 allocatorIndex, size_t size)\n{\n\tint index;\n\tvoid* contextBuffer;\n\n\tfor (index = 0; index < (int) ContextBufferAllocTable.cMaxEntries; index++)\n\t{\n\t\tif (ContextBufferAllocTable.entries[index].contextBuffer == NULL)\n\t\t{\n\t\t\tcontextBuffer = malloc(size);\n\t\t\tZeroMemory(contextBuffer, size);\n\t\t\tContextBufferAllocTable.cEntries++;\n\n\t\t\tContextBufferAllocTable.entries[index].contextBuffer = contextBuffer;\n\t\t\tContextBufferAllocTable.entries[index].allocatorIndex = allocatorIndex;\n\n\t\t\treturn ContextBufferAllocTable.entries[index].contextBuffer;\n\t\t}\n\t}\n\n\t/* no available entry was found, the table needs to be grown */\n\n\tsspi_ContextBufferAllocTableGrow();\n\n\t/* the next call to sspi_ContextBufferAlloc() should now succeed */\n\n\treturn sspi_ContextBufferAlloc(allocatorIndex, size);\n}\n\nCREDENTIALS* sspi_CredentialsNew()\n{\n\tCREDENTIALS* credentials;\n\n\tcredentials = (CREDENTIALS*) malloc(sizeof(CREDENTIALS));\n\tZeroMemory(credentials, sizeof(CREDENTIALS));\n\n\tif (credentials != NULL)\n\t{\n\n\t}\n\n\treturn credentials;\n}\n\nvoid sspi_CredentialsFree(CREDENTIALS* credentials)\n{\n\tif (!credentials)\n\t\treturn;\n\n\tfree(credentials);\n}\n\nvoid sspi_SecBufferAlloc(PSecBuffer SecBuffer, size_t size)\n{\n\tSecBuffer->cbBuffer = size;\n\tSecBuffer->pvBuffer = malloc(size);\n\tZeroMemory(SecBuffer->pvBuffer, SecBuffer->cbBuffer);\n}\n\nvoid sspi_SecBufferFree(PSecBuffer SecBuffer)\n{\n\tfree(SecBuffer->pvBuffer);\n\tSecBuffer->pvBuffer = NULL;\n\tSecBuffer->cbBuffer = 0;\n}\n\nSecHandle* sspi_SecureHandleAlloc()\n{\n\tSecHandle* handle = (SecHandle*) malloc(sizeof(SecHandle));\n\tsspi_SecureHandleInit(handle);\n\treturn handle;\n}\n\nvoid sspi_SecureHandleInit(SecHandle* handle)\n{\n\tif (!handle)\n\t\treturn;\n\n\tmemset(handle, 0xFF, sizeof(SecHandle));\n}\n\nvoid sspi_SecureHandleInvalidate(SecHandle* handle)\n{\n\tif (!handle)\n\t\treturn;\n\n\tsspi_SecureHandleInit(handle);\n}\n\nvoid* sspi_SecureHandleGetLowerPointer(SecHandle* handle)\n{\n\tvoid* pointer;\n\n\tif (!handle)\n\t\treturn NULL;\n\n\tpointer = (void*) ~((size_t) handle->dwLower);\n\n\treturn pointer;\n}\n\nvoid sspi_SecureHandleSetLowerPointer(SecHandle* handle, void* pointer)\n{\n\tif (!handle)\n\t\treturn;\n\n\thandle->dwLower = (ULONG_PTR) (~((size_t) pointer));\n}\n\nvoid* sspi_SecureHandleGetUpperPointer(SecHandle* handle)\n{\n\tvoid* pointer;\n\n\tif (!handle)\n\t\treturn NULL;\n\n\tpointer = (void*) ~((size_t) handle->dwUpper);\n\n\treturn pointer;\n}\n\nvoid sspi_SecureHandleSetUpperPointer(SecHandle* handle, void* pointer)\n{\n\tif (!handle)\n\t\treturn;\n\n\thandle->dwUpper = (ULONG_PTR) (~((size_t) pointer));\n}\n\nvoid sspi_SecureHandleFree(SecHandle* handle)\n{\n\tif (!handle)\n\t\treturn;\n\n\tfree(handle);\n}\n\nvoid sspi_SetAuthIdentity(SEC_WINNT_AUTH_IDENTITY* identity, char* user, char* domain, char* password)\n{\n\tidentity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;\n\n\tif (user)\n\t{\n\t\tidentity->UserLength = ConvertToUnicode(CP_UTF8, 0, user, -1, &identity->User, 0) - 1;\n\t}\n\telse\n\t{\n\t\tidentity->User = (UINT16*) NULL;\n\t\tidentity->UserLength = 0;\n\t}\n\n\tif (domain)\n\t{\n\t\tidentity->DomainLength = ConvertToUnicode(CP_UTF8, 0, domain, -1, &identity->Domain, 0) - 1;\n\t}\n\telse\n\t{\n\t\tidentity->Domain = (UINT16*) NULL;\n\t\tidentity->DomainLength = 0;\n\t}\n\n\tif (password != NULL)\n\t{\n\t\tidentity->PasswordLength = ConvertToUnicode(CP_UTF8, 0, password, -1, &identity->Password, 0) - 1;\n\t}\n\telse\n\t{\n\t\tidentity->Password = NULL;\n\t\tidentity->PasswordLength = 0;\n\t}\n}\n\nvoid sspi_CopyAuthIdentity(SEC_WINNT_AUTH_IDENTITY* identity, SEC_WINNT_AUTH_IDENTITY* srcIdentity)\n{\n\tif (identity->Flags == SEC_WINNT_AUTH_IDENTITY_ANSI)\n\t{\n\t\tsspi_SetAuthIdentity(identity, (char*) srcIdentity->User,\n\t\t\t\t(char*) srcIdentity->Domain, (char*) srcIdentity->Password);\n\n\t\tidentity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;\n\n\t\treturn;\n\t}\n\n\tidentity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;\n\n\tidentity->User = identity->Domain = identity->Password = NULL;\n\n\tidentity->UserLength = srcIdentity->UserLength;\n\n\tif (identity->UserLength > 0)\n\t{\n\t\tidentity->User = (UINT16*) malloc((identity->UserLength + 1) * sizeof(WCHAR));\n\t\tCopyMemory(identity->User, srcIdentity->User, identity->UserLength * sizeof(WCHAR));\n\t\tidentity->User[identity->UserLength] = 0;\n\t}\n\n\tidentity->DomainLength = srcIdentity->DomainLength;\n\n\tif (identity->DomainLength > 0)\n\t{\n\t\tidentity->Domain = (UINT16*) malloc((identity->DomainLength + 1) * sizeof(WCHAR));\n\t\tCopyMemory(identity->Domain, srcIdentity->Domain, identity->DomainLength * sizeof(WCHAR));\n\t\tidentity->Domain[identity->DomainLength] = 0;\n\t}\n\n\tidentity->PasswordLength = srcIdentity->PasswordLength;\n\n\tif (identity->PasswordLength > 0)\n\t{\n\t\tidentity->Password = (UINT16*) malloc((identity->PasswordLength + 1) * sizeof(WCHAR));\n\t\tCopyMemory(identity->Password, srcIdentity->Password, identity->PasswordLength * sizeof(WCHAR));\n\t\tidentity->Password[identity->PasswordLength] = 0;\n\t}\n}\n\nPSecBuffer sspi_FindSecBuffer(PSecBufferDesc pMessage, ULONG BufferType)\n{\n\tint index;\n\tPSecBuffer pSecBuffer = NULL;\n\n\tfor (index = 0; index < pMessage->cBuffers; index++)\n\t{\n\t\tif (pMessage->pBuffers[index].BufferType == BufferType)\n\t\t{\n\t\t\tpSecBuffer = &pMessage->pBuffers[index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn pSecBuffer;\n}\n\nstatic BOOL sspi_initialized = FALSE;\n\nvoid sspi_GlobalInit()\n{\n\tif (!sspi_initialized)\n\t{\n\t\tSSL_load_error_strings();\n\t\tSSL_library_init();\n\n\t\tsspi_ContextBufferAllocTableNew();\n\t\tsspi_initialized = TRUE;\n\t}\n}\n\nvoid sspi_GlobalFinish()\n{\n\tif (sspi_initialized)\n\t{\n\t\tsspi_ContextBufferAllocTableFree();\n\t}\n\n\tsspi_initialized = FALSE;\n}\n\n#ifndef WITH_NATIVE_SSPI\n\nSecurityFunctionTableA* sspi_GetSecurityFunctionTableAByNameA(const SEC_CHAR* Name)\n{\n\tint index;\n\tUINT32 cPackages;\n\n\tcPackages = sizeof(SecPkgInfoA_LIST) / sizeof(*(SecPkgInfoA_LIST));\n\n\tfor (index = 0; index < (int) cPackages; index++)\n\t{\n\t\tif (strcmp(Name, SecurityFunctionTableA_NAME_LIST[index].Name) == 0)\n\t\t{\n\t\t\treturn (SecurityFunctionTableA*) SecurityFunctionTableA_NAME_LIST[index].SecurityFunctionTable;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nSecurityFunctionTableA* sspi_GetSecurityFunctionTableAByNameW(const SEC_WCHAR* Name)\n{\n\treturn NULL;\n}\n\nSecurityFunctionTableW* sspi_GetSecurityFunctionTableWByNameW(const SEC_WCHAR* Name)\n{\n\tint index;\n\tUINT32 cPackages;\n\n\tcPackages = sizeof(SecPkgInfoW_LIST) / sizeof(*(SecPkgInfoW_LIST));\n\n\tfor (index = 0; index < (int) cPackages; index++)\n\t{\n\t\tif (lstrcmpW(Name, SecurityFunctionTableW_NAME_LIST[index].Name) == 0)\n\t\t{\n\t\t\treturn (SecurityFunctionTableW*) SecurityFunctionTableW_NAME_LIST[index].SecurityFunctionTable;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nSecurityFunctionTableW* sspi_GetSecurityFunctionTableWByNameA(const SEC_CHAR* Name)\n{\n\tSEC_WCHAR* NameW = NULL;\n\tSecurityFunctionTableW* table;\n\n\tConvertToUnicode(CP_UTF8, 0, Name, -1, &NameW, 0);\n\n\ttable = sspi_GetSecurityFunctionTableWByNameW(NameW);\n\tfree(NameW);\n\n\treturn table;\n}\n\nvoid FreeContextBuffer_EnumerateSecurityPackages(void* contextBuffer);\nvoid FreeContextBuffer_QuerySecurityPackageInfo(void* contextBuffer);\n\nvoid sspi_ContextBufferFree(void* contextBuffer)\n{\n\tint index;\n\tUINT32 allocatorIndex;\n\n\tfor (index = 0; index < (int) ContextBufferAllocTable.cMaxEntries; index++)\n\t{\n\t\tif (contextBuffer == ContextBufferAllocTable.entries[index].contextBuffer)\n\t\t{\n\t\t\tcontextBuffer = ContextBufferAllocTable.entries[index].contextBuffer;\n\t\t\tallocatorIndex = ContextBufferAllocTable.entries[index].allocatorIndex;\n\n\t\t\tContextBufferAllocTable.cEntries--;\n\n\t\t\tContextBufferAllocTable.entries[index].allocatorIndex = 0;\n\t\t\tContextBufferAllocTable.entries[index].contextBuffer = NULL;\n\n\t\t\tswitch (allocatorIndex)\n\t\t\t{\n\t\t\t\tcase EnumerateSecurityPackagesIndex:\n\t\t\t\t\tFreeContextBuffer_EnumerateSecurityPackages(contextBuffer);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase QuerySecurityPackageInfoIndex:\n\t\t\t\t\tFreeContextBuffer_QuerySecurityPackageInfo(contextBuffer);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* Package Management */\n\nSECURITY_STATUS SEC_ENTRY EnumerateSecurityPackagesW(ULONG* pcPackages, PSecPkgInfoW* ppPackageInfo)\n{\n\tint index;\n\tsize_t size;\n\tUINT32 cPackages;\n\tSecPkgInfoW* pPackageInfo;\n\n\tcPackages = sizeof(SecPkgInfoW_LIST) / sizeof(*(SecPkgInfoW_LIST));\n\tsize = sizeof(SecPkgInfoW) * cPackages;\n\n\tpPackageInfo = (SecPkgInfoW*) sspi_ContextBufferAlloc(EnumerateSecurityPackagesIndex, size);\n\n\tfor (index = 0; index < (int) cPackages; index++)\n\t{\n\t\tpPackageInfo[index].fCapabilities = SecPkgInfoW_LIST[index]->fCapabilities;\n\t\tpPackageInfo[index].wVersion = SecPkgInfoW_LIST[index]->wVersion;\n\t\tpPackageInfo[index].wRPCID = SecPkgInfoW_LIST[index]->wRPCID;\n\t\tpPackageInfo[index].cbMaxToken = SecPkgInfoW_LIST[index]->cbMaxToken;\n\t\tpPackageInfo[index].Name = _wcsdup(SecPkgInfoW_LIST[index]->Name);\n\t\tpPackageInfo[index].Comment = _wcsdup(SecPkgInfoW_LIST[index]->Comment);\n\t}\n\n\t*(pcPackages) = cPackages;\n\t*(ppPackageInfo) = pPackageInfo;\n\n\treturn SEC_E_OK;\n}\n\nSECURITY_STATUS SEC_ENTRY EnumerateSecurityPackagesA(ULONG* pcPackages, PSecPkgInfoA* ppPackageInfo)\n{\n\tint index;\n\tsize_t size;\n\tUINT32 cPackages;\n\tSecPkgInfoA* pPackageInfo;\n\n\tcPackages = sizeof(SecPkgInfoA_LIST) / sizeof(*(SecPkgInfoA_LIST));\n\tsize = sizeof(SecPkgInfoA) * cPackages;\n\n\tpPackageInfo = (SecPkgInfoA*) sspi_ContextBufferAlloc(EnumerateSecurityPackagesIndex, size);\n\n\tfor (index = 0; index < (int) cPackages; index++)\n\t{\n\t\tpPackageInfo[index].fCapabilities = SecPkgInfoA_LIST[index]->fCapabilities;\n\t\tpPackageInfo[index].wVersion = SecPkgInfoA_LIST[index]->wVersion;\n\t\tpPackageInfo[index].wRPCID = SecPkgInfoA_LIST[index]->wRPCID;\n\t\tpPackageInfo[index].cbMaxToken = SecPkgInfoA_LIST[index]->cbMaxToken;\n\t\tpPackageInfo[index].Name = _strdup(SecPkgInfoA_LIST[index]->Name);\n\t\tpPackageInfo[index].Comment = _strdup(SecPkgInfoA_LIST[index]->Comment);\n\t}\n\n\t*(pcPackages) = cPackages;\n\t*(ppPackageInfo) = pPackageInfo;\n\n\treturn SEC_E_OK;\n}\n\nvoid FreeContextBuffer_EnumerateSecurityPackages(void* contextBuffer)\n{\n\tint index;\n\tUINT32 cPackages;\n\tSecPkgInfoA* pPackageInfo = (SecPkgInfoA*) contextBuffer;\n\n\tcPackages = sizeof(SecPkgInfoA_LIST) / sizeof(*(SecPkgInfoA_LIST));\n\n\tfor (index = 0; index < (int) cPackages; index++)\n\t{\n\t\tif (pPackageInfo[index].Name)\n\t\t\tfree(pPackageInfo[index].Name);\n\n\t\tif (pPackageInfo[index].Comment)\n\t\t\tfree(pPackageInfo[index].Comment);\n\t}\n\n\tfree(pPackageInfo);\n}\n\nSecurityFunctionTableW* SEC_ENTRY InitSecurityInterfaceW(void)\n{\n\treturn &SSPI_SecurityFunctionTableW;\n}\n\nSecurityFunctionTableA* SEC_ENTRY InitSecurityInterfaceA(void)\n{\n\treturn &SSPI_SecurityFunctionTableA;\n}\n\nSECURITY_STATUS SEC_ENTRY QuerySecurityPackageInfoW(SEC_WCHAR* pszPackageName, PSecPkgInfoW* ppPackageInfo)\n{\n\tint index;\n\tsize_t size;\n\tUINT32 cPackages;\n\tSecPkgInfoW* pPackageInfo;\n\n\tcPackages = sizeof(SecPkgInfoW_LIST) / sizeof(*(SecPkgInfoW_LIST));\n\n\tfor (index = 0; index < (int) cPackages; index++)\n\t{\n\t\tif (lstrcmpW(pszPackageName, SecPkgInfoW_LIST[index]->Name) == 0)\n\t\t{\n\t\t\tsize = sizeof(SecPkgInfoW);\n\t\t\tpPackageInfo = (SecPkgInfoW*) sspi_ContextBufferAlloc(QuerySecurityPackageInfoIndex, size);\n\n\t\t\tpPackageInfo->fCapabilities = SecPkgInfoW_LIST[index]->fCapabilities;\n\t\t\tpPackageInfo->wVersion = SecPkgInfoW_LIST[index]->wVersion;\n\t\t\tpPackageInfo->wRPCID = SecPkgInfoW_LIST[index]->wRPCID;\n\t\t\tpPackageInfo->cbMaxToken = SecPkgInfoW_LIST[index]->cbMaxToken;\n\t\t\tpPackageInfo->Name = _wcsdup(SecPkgInfoW_LIST[index]->Name);\n\t\t\tpPackageInfo->Comment = _wcsdup(SecPkgInfoW_LIST[index]->Comment);\n\n\t\t\t*(ppPackageInfo) = pPackageInfo;\n\n\t\t\treturn SEC_E_OK;\n\t\t}\n\t}\n\n\t*(ppPackageInfo) = NULL;\n\n\treturn SEC_E_SECPKG_NOT_FOUND;\n}\n\nSECURITY_STATUS SEC_ENTRY QuerySecurityPackageInfoA(SEC_CHAR* pszPackageName, PSecPkgInfoA* ppPackageInfo)\n{\n\tint index;\n\tsize_t size;\n\tUINT32 cPackages;\n\tSecPkgInfoA* pPackageInfo;\n\n\tcPackages = sizeof(SecPkgInfoA_LIST) / sizeof(*(SecPkgInfoA_LIST));\n\n\tfor (index = 0; index < (int) cPackages; index++)\n\t{\n\t\tif (strcmp(pszPackageName, SecPkgInfoA_LIST[index]->Name) == 0)\n\t\t{\n\t\t\tsize = sizeof(SecPkgInfoA);\n\t\t\tpPackageInfo = (SecPkgInfoA*) sspi_ContextBufferAlloc(QuerySecurityPackageInfoIndex, size);\n\n\t\t\tpPackageInfo->fCapabilities = SecPkgInfoA_LIST[index]->fCapabilities;\n\t\t\tpPackageInfo->wVersion = SecPkgInfoA_LIST[index]->wVersion;\n\t\t\tpPackageInfo->wRPCID = SecPkgInfoA_LIST[index]->wRPCID;\n\t\t\tpPackageInfo->cbMaxToken = SecPkgInfoA_LIST[index]->cbMaxToken;\n\t\t\tpPackageInfo->Name = _strdup(SecPkgInfoA_LIST[index]->Name);\n\t\t\tpPackageInfo->Comment = _strdup(SecPkgInfoA_LIST[index]->Comment);\n\n\t\t\t*(ppPackageInfo) = pPackageInfo;\n\n\t\t\treturn SEC_E_OK;\n\t\t}\n\t}\n\n\t*(ppPackageInfo) = NULL;\n\n\treturn SEC_E_SECPKG_NOT_FOUND;\n}\n\nvoid FreeContextBuffer_QuerySecurityPackageInfo(void* contextBuffer)\n{\n\tSecPkgInfo* pPackageInfo = (SecPkgInfo*) contextBuffer;\n\n\tif (pPackageInfo->Name)\n\t\tfree(pPackageInfo->Name);\n\n\tif (pPackageInfo->Comment)\n\t\tfree(pPackageInfo->Comment);\n\n\tfree(pPackageInfo);\n}\n\n/* Credential Management */\n\nSECURITY_STATUS SEC_ENTRY AcquireCredentialsHandleW(SEC_WCHAR* pszPrincipal, SEC_WCHAR* pszPackage,\n\t\tULONG fCredentialUse, void* pvLogonID, void* pAuthData, SEC_GET_KEY_FN pGetKeyFn,\n\t\tvoid* pvGetKeyArgument, PCredHandle phCredential, PTimeStamp ptsExpiry)\n{\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableW* table = sspi_GetSecurityFunctionTableWByNameW(pszPackage);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->AcquireCredentialsHandleW == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->AcquireCredentialsHandleW(pszPrincipal, pszPackage, fCredentialUse,\n\t\t\tpvLogonID, pAuthData, pGetKeyFn, pvGetKeyArgument, phCredential, ptsExpiry);\n\n\treturn status;\n}\n\nSECURITY_STATUS SEC_ENTRY AcquireCredentialsHandleA(SEC_CHAR* pszPrincipal, SEC_CHAR* pszPackage,\n\t\tULONG fCredentialUse, void* pvLogonID, void* pAuthData, SEC_GET_KEY_FN pGetKeyFn,\n\t\tvoid* pvGetKeyArgument, PCredHandle phCredential, PTimeStamp ptsExpiry)\n{\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table = sspi_GetSecurityFunctionTableAByNameA(pszPackage);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->AcquireCredentialsHandleA == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->AcquireCredentialsHandleA(pszPrincipal, pszPackage, fCredentialUse,\n\t\t\tpvLogonID, pAuthData, pGetKeyFn, pvGetKeyArgument, phCredential, ptsExpiry);\n\n\treturn status;\n}\n\nSECURITY_STATUS SEC_ENTRY ExportSecurityContext(PCtxtHandle phContext, ULONG fFlags, PSecBuffer pPackedContext, HANDLE* pToken)\n{\n\treturn SEC_E_OK;\n}\n\nSECURITY_STATUS SEC_ENTRY FreeCredentialsHandle(PCredHandle phCredential)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phCredential);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->FreeCredentialsHandle == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->FreeCredentialsHandle(phCredential);\n\n\treturn status;\n}\n\nSECURITY_STATUS SEC_ENTRY ImportSecurityContextW(SEC_WCHAR* pszPackage, PSecBuffer pPackedContext, HANDLE pToken, PCtxtHandle phContext)\n{\n\treturn SEC_E_OK;\n}\n\nSECURITY_STATUS SEC_ENTRY ImportSecurityContextA(SEC_CHAR* pszPackage, PSecBuffer pPackedContext, HANDLE pToken, PCtxtHandle phContext)\n{\n\treturn SEC_E_OK;\n}\n\nSECURITY_STATUS SEC_ENTRY QueryCredentialsAttributesW(PCredHandle phCredential, ULONG ulAttribute, void* pBuffer)\n{\n\tSEC_WCHAR* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableW* table;\n\n\tName = (SEC_WCHAR*) sspi_SecureHandleGetUpperPointer(phCredential);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableWByNameW(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->QueryCredentialsAttributesW == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->QueryCredentialsAttributesW(phCredential, ulAttribute, pBuffer);\n\n\treturn status;\n}\n\nSECURITY_STATUS SEC_ENTRY QueryCredentialsAttributesA(PCredHandle phCredential, ULONG ulAttribute, void* pBuffer)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phCredential);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->QueryCredentialsAttributesA == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->QueryCredentialsAttributesA(phCredential, ulAttribute, pBuffer);\n\n\treturn status;\n}\n\n/* Context Management */\n\nSECURITY_STATUS SEC_ENTRY AcceptSecurityContext(PCredHandle phCredential, PCtxtHandle phContext,\n\t\tPSecBufferDesc pInput, ULONG fContextReq, ULONG TargetDataRep, PCtxtHandle phNewContext,\n\t\tPSecBufferDesc pOutput, PULONG pfContextAttr, PTimeStamp ptsTimeStamp)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phCredential);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->AcceptSecurityContext == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->AcceptSecurityContext(phCredential, phContext, pInput, fContextReq,\n\t\t\tTargetDataRep, phNewContext, pOutput, pfContextAttr, ptsTimeStamp);\n\n\treturn status;\n}\n\nSECURITY_STATUS SEC_ENTRY ApplyControlToken(PCtxtHandle phContext, PSecBufferDesc pInput)\n{\n\treturn SEC_E_OK;\n}\n\nSECURITY_STATUS SEC_ENTRY CompleteAuthToken(PCtxtHandle phContext, PSecBufferDesc pToken)\n{\n\treturn SEC_E_OK;\n}\n\nSECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phContext);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->DeleteSecurityContext == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->DeleteSecurityContext(phContext);\n\n\treturn status;\n}\n\nSECURITY_STATUS SEC_ENTRY FreeContextBuffer(void* pvContextBuffer)\n{\n\tif (!pvContextBuffer)\n\t\treturn SEC_E_INVALID_HANDLE;\n\n\tsspi_ContextBufferFree(pvContextBuffer);\n\n\treturn SEC_E_OK;\n}\n\nSECURITY_STATUS SEC_ENTRY ImpersonateSecurityContext(PCtxtHandle phContext)\n{\n\treturn SEC_E_OK;\n}\n\nSECURITY_STATUS SEC_ENTRY InitializeSecurityContextW(PCredHandle phCredential, PCtxtHandle phContext,\n\t\tSEC_WCHAR* pszTargetName, ULONG fContextReq, ULONG Reserved1, ULONG TargetDataRep,\n\t\tPSecBufferDesc pInput, ULONG Reserved2, PCtxtHandle phNewContext,\n\t\tPSecBufferDesc pOutput, PULONG pfContextAttr, PTimeStamp ptsExpiry)\n{\n\tSEC_CHAR* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableW* table;\n\n\tName = (SEC_CHAR*) sspi_SecureHandleGetUpperPointer(phCredential);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableWByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->InitializeSecurityContextW == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->InitializeSecurityContextW(phCredential, phContext,\n\t\t\tpszTargetName, fContextReq, Reserved1, TargetDataRep,\n\t\t\tpInput, Reserved2, phNewContext, pOutput, pfContextAttr, ptsExpiry);\n\n\treturn status;\n}\n\nSECURITY_STATUS SEC_ENTRY InitializeSecurityContextA(PCredHandle phCredential, PCtxtHandle phContext,\n\t\tSEC_CHAR* pszTargetName, ULONG fContextReq, ULONG Reserved1, ULONG TargetDataRep,\n\t\tPSecBufferDesc pInput, ULONG Reserved2, PCtxtHandle phNewContext,\n\t\tPSecBufferDesc pOutput, PULONG pfContextAttr, PTimeStamp ptsExpiry)\n{\n\tSEC_CHAR* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (SEC_CHAR*) sspi_SecureHandleGetUpperPointer(phCredential);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->InitializeSecurityContextA == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->InitializeSecurityContextA(phCredential, phContext,\n\t\t\tpszTargetName, fContextReq, Reserved1, TargetDataRep,\n\t\t\tpInput, Reserved2, phNewContext, pOutput, pfContextAttr, ptsExpiry);\n\n\treturn status;\n}\n\nSECURITY_STATUS SEC_ENTRY QueryContextAttributesW(PCtxtHandle phContext, ULONG ulAttribute, void* pBuffer)\n{\n\tSEC_CHAR* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableW* table;\n\n\tName = (SEC_CHAR*) sspi_SecureHandleGetUpperPointer(phContext);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableWByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->QueryContextAttributesW == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->QueryContextAttributesW(phContext, ulAttribute, pBuffer);\n\n\treturn status;\n}\n\nSECURITY_STATUS SEC_ENTRY QueryContextAttributesA(PCtxtHandle phContext, ULONG ulAttribute, void* pBuffer)\n{\n\tSEC_CHAR* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (SEC_CHAR*) sspi_SecureHandleGetUpperPointer(phContext);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->QueryContextAttributesA == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->QueryContextAttributesA(phContext, ulAttribute, pBuffer);\n\n\treturn status;\n}\n\nSECURITY_STATUS SEC_ENTRY QuerySecurityContextToken(PCtxtHandle phContext, HANDLE* phToken)\n{\n\treturn SEC_E_OK;\n}\n\nSECURITY_STATUS SEC_ENTRY SetContextAttributes(PCtxtHandle phContext, ULONG ulAttribute, void* pBuffer, ULONG cbBuffer)\n{\n\treturn SEC_E_OK;\n}\n\nSECURITY_STATUS SEC_ENTRY RevertSecurityContext(PCtxtHandle phContext)\n{\n\treturn SEC_E_OK;\n}\n\n/* Message Support */\n\nSECURITY_STATUS SEC_ENTRY DecryptMessage(PCtxtHandle phContext, PSecBufferDesc pMessage, ULONG MessageSeqNo, PULONG pfQOP)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phContext);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->DecryptMessage == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->DecryptMessage(phContext, pMessage, MessageSeqNo, pfQOP);\n\n\treturn status;\n}\n\nSECURITY_STATUS SEC_ENTRY EncryptMessage(PCtxtHandle phContext, ULONG fQOP, PSecBufferDesc pMessage, ULONG MessageSeqNo)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phContext);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->EncryptMessage == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->EncryptMessage(phContext, fQOP, pMessage, MessageSeqNo);\n\n\treturn status;\n}\n\nSECURITY_STATUS SEC_ENTRY MakeSignature(PCtxtHandle phContext, ULONG fQOP, PSecBufferDesc pMessage, ULONG MessageSeqNo)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phContext);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->MakeSignature == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->MakeSignature(phContext, fQOP, pMessage, MessageSeqNo);\n\n\treturn status;\n}\n\nSECURITY_STATUS SEC_ENTRY VerifySignature(PCtxtHandle phContext, PSecBufferDesc pMessage, ULONG MessageSeqNo, PULONG pfQOP)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phContext);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->VerifySignature == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->VerifySignature(phContext, pMessage, MessageSeqNo, pfQOP);\n\n\treturn status;\n}\n\nSecurityFunctionTableA SSPI_SecurityFunctionTableA =\n{\n\t1, /* dwVersion */\n\tEnumerateSecurityPackagesA, /* EnumerateSecurityPackages */\n\tQueryCredentialsAttributesA, /* QueryCredentialsAttributes */\n\tAcquireCredentialsHandleA, /* AcquireCredentialsHandle */\n\tFreeCredentialsHandle, /* FreeCredentialsHandle */\n\tNULL, /* Reserved2 */\n\tInitializeSecurityContextA, /* InitializeSecurityContext */\n\tAcceptSecurityContext, /* AcceptSecurityContext */\n\tCompleteAuthToken, /* CompleteAuthToken */\n\tDeleteSecurityContext, /* DeleteSecurityContext */\n\tApplyControlToken, /* ApplyControlToken */\n\tQueryContextAttributesA, /* QueryContextAttributes */\n\tImpersonateSecurityContext, /* ImpersonateSecurityContext */\n\tRevertSecurityContext, /* RevertSecurityContext */\n\tMakeSignature, /* MakeSignature */\n\tVerifySignature, /* VerifySignature */\n\tFreeContextBuffer, /* FreeContextBuffer */\n\tQuerySecurityPackageInfoA, /* QuerySecurityPackageInfo */\n\tNULL, /* Reserved3 */\n\tNULL, /* Reserved4 */\n\tExportSecurityContext, /* ExportSecurityContext */\n\tImportSecurityContextA, /* ImportSecurityContext */\n\tNULL, /* AddCredentials */\n\tNULL, /* Reserved8 */\n\tQuerySecurityContextToken, /* QuerySecurityContextToken */\n\tEncryptMessage, /* EncryptMessage */\n\tDecryptMessage, /* DecryptMessage */\n\tSetContextAttributes, /* SetContextAttributes */\n};\n\nSecurityFunctionTableW SSPI_SecurityFunctionTableW =\n{\n\t1, /* dwVersion */\n\tEnumerateSecurityPackagesW, /* EnumerateSecurityPackages */\n\tQueryCredentialsAttributesW, /* QueryCredentialsAttributes */\n\tAcquireCredentialsHandleW, /* AcquireCredentialsHandle */\n\tFreeCredentialsHandle, /* FreeCredentialsHandle */\n\tNULL, /* Reserved2 */\n\tInitializeSecurityContextW, /* InitializeSecurityContext */\n\tAcceptSecurityContext, /* AcceptSecurityContext */\n\tCompleteAuthToken, /* CompleteAuthToken */\n\tDeleteSecurityContext, /* DeleteSecurityContext */\n\tApplyControlToken, /* ApplyControlToken */\n\tQueryContextAttributesW, /* QueryContextAttributes */\n\tImpersonateSecurityContext, /* ImpersonateSecurityContext */\n\tRevertSecurityContext, /* RevertSecurityContext */\n\tMakeSignature, /* MakeSignature */\n\tVerifySignature, /* VerifySignature */\n\tFreeContextBuffer, /* FreeContextBuffer */\n\tQuerySecurityPackageInfoW, /* QuerySecurityPackageInfo */\n\tNULL, /* Reserved3 */\n\tNULL, /* Reserved4 */\n\tExportSecurityContext, /* ExportSecurityContext */\n\tImportSecurityContextW, /* ImportSecurityContext */\n\tNULL, /* AddCredentials */\n\tNULL, /* Reserved8 */\n\tQuerySecurityContextToken, /* QuerySecurityContextToken */\n\tEncryptMessage, /* EncryptMessage */\n\tDecryptMessage, /* DecryptMessage */\n\tSetContextAttributes, /* SetContextAttributes */\n};\n\n#endif\n"], "fixing_code": ["/**\n * WinPR: Windows Portable Runtime\n * Network Level Authentication (NLA)\n *\n * Copyright 2010-2012 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *\t\t http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <time.h>\n\n#ifndef _WIN32\n#include <unistd.h>\n#endif\n\n#include <freerdp/crypto/tls.h>\n\n#include <winpr/crt.h>\n#include <winpr/sspi.h>\n#include <winpr/print.h>\n#include <winpr/tchar.h>\n#include <winpr/library.h>\n#include <winpr/registry.h>\n\n#include \"nla.h\"\n\n/**\n * TSRequest ::= SEQUENCE {\n * \tversion    [0] INTEGER,\n * \tnegoTokens [1] NegoData OPTIONAL,\n * \tauthInfo   [2] OCTET STRING OPTIONAL,\n * \tpubKeyAuth [3] OCTET STRING OPTIONAL\n * }\n *\n * NegoData ::= SEQUENCE OF NegoDataItem\n *\n * NegoDataItem ::= SEQUENCE {\n * \tnegoToken [0] OCTET STRING\n * }\n *\n * TSCredentials ::= SEQUENCE {\n * \tcredType    [0] INTEGER,\n * \tcredentials [1] OCTET STRING\n * }\n *\n * TSPasswordCreds ::= SEQUENCE {\n * \tdomainName  [0] OCTET STRING,\n * \tuserName    [1] OCTET STRING,\n * \tpassword    [2] OCTET STRING\n * }\n *\n * TSSmartCardCreds ::= SEQUENCE {\n * \tpin        [0] OCTET STRING,\n * \tcspData    [1] TSCspDataDetail,\n * \tuserHint   [2] OCTET STRING OPTIONAL,\n * \tdomainHint [3] OCTET STRING OPTIONAL\n * }\n *\n * TSCspDataDetail ::= SEQUENCE {\n * \tkeySpec       [0] INTEGER,\n * \tcardName      [1] OCTET STRING OPTIONAL,\n * \treaderName    [2] OCTET STRING OPTIONAL,\n * \tcontainerName [3] OCTET STRING OPTIONAL,\n * \tcspName       [4] OCTET STRING OPTIONAL\n * }\n *\n */\n\n#ifdef WITH_DEBUG_NLA\n#define WITH_DEBUG_CREDSSP\n#endif\n\n#ifdef WITH_NATIVE_SSPI\n#define NLA_PKG_NAME\tNTLMSP_NAME\n#else\n#define NLA_PKG_NAME\tNTLMSP_NAME\n#endif\n\n#define TERMSRV_SPN_PREFIX\t\"TERMSRV/\"\n\nvoid credssp_send(rdpCredssp* credssp);\nint credssp_recv(rdpCredssp* credssp);\nvoid credssp_buffer_print(rdpCredssp* credssp);\nvoid credssp_buffer_free(rdpCredssp* credssp);\nSECURITY_STATUS credssp_encrypt_public_key_echo(rdpCredssp* credssp);\nSECURITY_STATUS credssp_decrypt_public_key_echo(rdpCredssp* credssp);\nSECURITY_STATUS credssp_encrypt_ts_credentials(rdpCredssp* credssp);\nSECURITY_STATUS credssp_decrypt_ts_credentials(rdpCredssp* credssp);\n\n#define ber_sizeof_sequence_octet_string(length) ber_sizeof_contextual_tag(ber_sizeof_octet_string(length)) + ber_sizeof_octet_string(length)\n#define ber_write_sequence_octet_string(stream, context, value, length) ber_write_contextual_tag(stream, context, ber_sizeof_octet_string(length), TRUE) + ber_write_octet_string(stream, value, length)\n\n/**\n * Initialize NTLMSSP authentication module (client).\n * @param credssp\n */\n\nint credssp_ntlm_client_init(rdpCredssp* credssp)\n{\n\tchar* spn;\n\tint length;\n\tfreerdp* instance;\n\trdpSettings* settings;\n\n\tsettings = credssp->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tif ((settings->Password == NULL) || (settings->Username == NULL))\n\t{\n\t\tif (instance->Authenticate)\n\t\t{\n\t\t\tBOOL proceed = instance->Authenticate(instance,\n\t\t\t\t\t&settings->Username, &settings->Password, &settings->Domain);\n\t\t\tif (!proceed)\n\t\t\t\treturn 0;\n\t\t}\n\t}\n\n\tsspi_SetAuthIdentity(&(credssp->identity), settings->Username, settings->Domain, settings->Password);\n\n#ifdef WITH_DEBUG_NLA\n\t_tprintf(_T(\"User: %s Domain: %s Password: %s\\n\"),\n\t\t(char*) credssp->identity.User, (char*) credssp->identity.Domain, (char*) credssp->identity.Password);\n#endif\n\n\tsspi_SecBufferAlloc(&credssp->PublicKey, credssp->transport->TlsIn->PublicKeyLength);\n\tCopyMemory(credssp->PublicKey.pvBuffer, credssp->transport->TlsIn->PublicKey, credssp->transport->TlsIn->PublicKeyLength);\n\n\tlength = sizeof(TERMSRV_SPN_PREFIX) + strlen(settings->ServerHostname);\n\n\tspn = (SEC_CHAR*) malloc(length + 1);\n\tsprintf(spn, \"%s%s\", TERMSRV_SPN_PREFIX, settings->ServerHostname);\n\n#ifdef UNICODE\n\tcredssp->ServicePrincipalName = (LPTSTR) malloc(length * 2 + 2);\n\tMultiByteToWideChar(CP_UTF8, 0, spn, length,\n\t\t(LPWSTR) credssp->ServicePrincipalName, length);\n\tfree(spn);\n#else\n\tcredssp->ServicePrincipalName = spn;\n#endif\n\n\treturn 1;\n}\n\n/**\n * Initialize NTLMSSP authentication module (server).\n * @param credssp\n */\n\nint credssp_ntlm_server_init(rdpCredssp* credssp)\n{\n\tfreerdp* instance;\n\trdpSettings* settings = credssp->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tsspi_SecBufferAlloc(&credssp->PublicKey, credssp->transport->TlsIn->PublicKeyLength);\n\tCopyMemory(credssp->PublicKey.pvBuffer, credssp->transport->TlsIn->PublicKey, credssp->transport->TlsIn->PublicKeyLength);\n\n\treturn 1;\n}\n\nint credssp_client_authenticate(rdpCredssp* credssp)\n{\n\tULONG cbMaxToken;\n\tULONG fContextReq;\n\tULONG pfContextAttr;\n\tSECURITY_STATUS status;\n\tCredHandle credentials;\n\tTimeStamp expiration;\n\tPSecPkgInfo pPackageInfo;\n\tSecBuffer input_buffer;\n\tSecBuffer output_buffer;\n\tSecBufferDesc input_buffer_desc;\n\tSecBufferDesc output_buffer_desc;\n\tBOOL have_context;\n\tBOOL have_input_buffer;\n\tBOOL have_pub_key_auth;\n\n\tsspi_GlobalInit();\n\n\tif (credssp_ntlm_client_init(credssp) == 0)\n\t\treturn 0;\n\n#ifdef WITH_NATIVE_SSPI\n\t{\n\t\tHMODULE hSSPI;\n\t\tINIT_SECURITY_INTERFACE InitSecurityInterface;\n\t\tPSecurityFunctionTable pSecurityInterface = NULL;\n\n\t\thSSPI = LoadLibrary(_T(\"secur32.dll\"));\n\n#ifdef UNICODE\n\t\tInitSecurityInterface = (INIT_SECURITY_INTERFACE) GetProcAddress(hSSPI, \"InitSecurityInterfaceW\");\n#else\n\t\tInitSecurityInterface = (INIT_SECURITY_INTERFACE) GetProcAddress(hSSPI, \"InitSecurityInterfaceA\");\n#endif\n\t\tcredssp->table = (*InitSecurityInterface)();\n\t}\n#else\n\tcredssp->table = InitSecurityInterface();\n#endif\n\n\tstatus = credssp->table->QuerySecurityPackageInfo(NLA_PKG_NAME, &pPackageInfo);\n\n\tif (status != SEC_E_OK)\n\t{\n\t\tfprintf(stderr, \"QuerySecurityPackageInfo status: 0x%08X\\n\", status);\n\t\treturn 0;\n\t}\n\n\tcbMaxToken = pPackageInfo->cbMaxToken;\n\n\tstatus = credssp->table->AcquireCredentialsHandle(NULL, NLA_PKG_NAME,\n\t\t\tSECPKG_CRED_OUTBOUND, NULL, &credssp->identity, NULL, NULL, &credentials, &expiration);\n\n\tif (status != SEC_E_OK)\n\t{\n\t\tfprintf(stderr, \"AcquireCredentialsHandle status: 0x%08X\\n\", status);\n\t\treturn 0;\n\t}\n\n\thave_context = FALSE;\n\thave_input_buffer = FALSE;\n\thave_pub_key_auth = FALSE;\n\tZeroMemory(&input_buffer, sizeof(SecBuffer));\n\tZeroMemory(&output_buffer, sizeof(SecBuffer));\n\tZeroMemory(&credssp->ContextSizes, sizeof(SecPkgContext_Sizes));\n\n\t/*\n\t * from tspkg.dll: 0x00000132\n\t * ISC_REQ_MUTUAL_AUTH\n\t * ISC_REQ_CONFIDENTIALITY\n\t * ISC_REQ_USE_SESSION_KEY\n\t * ISC_REQ_ALLOCATE_MEMORY\n\t */\n\n\tfContextReq = ISC_REQ_MUTUAL_AUTH | ISC_REQ_CONFIDENTIALITY | ISC_REQ_USE_SESSION_KEY;\n\n\twhile (TRUE)\n\t{\n\t\toutput_buffer_desc.ulVersion = SECBUFFER_VERSION;\n\t\toutput_buffer_desc.cBuffers = 1;\n\t\toutput_buffer_desc.pBuffers = &output_buffer;\n\t\toutput_buffer.BufferType = SECBUFFER_TOKEN;\n\t\toutput_buffer.cbBuffer = cbMaxToken;\n\t\toutput_buffer.pvBuffer = malloc(output_buffer.cbBuffer);\n\n\t\tstatus = credssp->table->InitializeSecurityContext(&credentials,\n\t\t\t\t(have_context) ? &credssp->context : NULL,\n\t\t\t\tcredssp->ServicePrincipalName, fContextReq, 0,\n\t\t\t\tSECURITY_NATIVE_DREP, (have_input_buffer) ? &input_buffer_desc : NULL,\n\t\t\t\t0, &credssp->context, &output_buffer_desc, &pfContextAttr, &expiration);\n\n\t\tif (have_input_buffer && (input_buffer.pvBuffer != NULL))\n\t\t{\n\t\t\tfree(input_buffer.pvBuffer);\n\t\t\tinput_buffer.pvBuffer = NULL;\n\t\t}\n\n\t\tif ((status == SEC_I_COMPLETE_AND_CONTINUE) || (status == SEC_I_COMPLETE_NEEDED) || (status == SEC_E_OK))\n\t\t{\n\t\t\tif (credssp->table->CompleteAuthToken != NULL)\n\t\t\t\tcredssp->table->CompleteAuthToken(&credssp->context, &output_buffer_desc);\n\n\t\t\thave_pub_key_auth = TRUE;\n\n\t\t\tif (credssp->table->QueryContextAttributes(&credssp->context, SECPKG_ATTR_SIZES, &credssp->ContextSizes) != SEC_E_OK)\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"QueryContextAttributes SECPKG_ATTR_SIZES failure\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tcredssp_encrypt_public_key_echo(credssp);\n\n\t\t\tif (status == SEC_I_COMPLETE_NEEDED)\n\t\t\t\tstatus = SEC_E_OK;\n\t\t\telse if (status == SEC_I_COMPLETE_AND_CONTINUE)\n\t\t\t\tstatus = SEC_I_CONTINUE_NEEDED;\n\t\t}\n\n\t\t/* send authentication token to server */\n\n\t\tif (output_buffer.cbBuffer > 0)\n\t\t{\n\t\t\tcredssp->negoToken.pvBuffer = output_buffer.pvBuffer;\n\t\t\tcredssp->negoToken.cbBuffer = output_buffer.cbBuffer;\n\n#ifdef WITH_DEBUG_CREDSSP\n\t\t\tfprintf(stderr, \"Sending Authentication Token\\n\");\n\t\t\twinpr_HexDump(credssp->negoToken.pvBuffer, credssp->negoToken.cbBuffer);\n#endif\n\n\t\t\tcredssp_send(credssp);\n\t\t\tcredssp_buffer_free(credssp);\n\t\t}\n\n\t\tif (status != SEC_I_CONTINUE_NEEDED)\n\t\t\tbreak;\n\n\t\t/* receive server response and place in input buffer */\n\n\t\tinput_buffer_desc.ulVersion = SECBUFFER_VERSION;\n\t\tinput_buffer_desc.cBuffers = 1;\n\t\tinput_buffer_desc.pBuffers = &input_buffer;\n\t\tinput_buffer.BufferType = SECBUFFER_TOKEN;\n\n\t\tif (credssp_recv(credssp) < 0)\n\t\t\treturn -1;\n\n#ifdef WITH_DEBUG_CREDSSP\n\t\tfprintf(stderr, \"Receiving Authentication Token (%d)\\n\", (int) credssp->negoToken.cbBuffer);\n\t\twinpr_HexDump(credssp->negoToken.pvBuffer, credssp->negoToken.cbBuffer);\n#endif\n\n\t\tinput_buffer.pvBuffer = credssp->negoToken.pvBuffer;\n\t\tinput_buffer.cbBuffer = credssp->negoToken.cbBuffer;\n\n\t\thave_input_buffer = TRUE;\n\t\thave_context = TRUE;\n\t}\n\n\t/* Encrypted Public Key +1 */\n\tif (credssp_recv(credssp) < 0)\n\t\treturn -1;\n\n\t/* Verify Server Public Key Echo */\n\n\tstatus = credssp_decrypt_public_key_echo(credssp);\n\tcredssp_buffer_free(credssp);\n\n\tif (status != SEC_E_OK)\n\t{\n\t\tfprintf(stderr, \"Could not verify public key echo!\\n\");\n\t\treturn -1;\n\t}\n\n\t/* Send encrypted credentials */\n\n\tstatus = credssp_encrypt_ts_credentials(credssp);\n\n\tif (status != SEC_E_OK)\n\t{\n\t\tfprintf(stderr, \"credssp_encrypt_ts_credentials status: 0x%08X\\n\", status);\n\t\treturn 0;\n\t}\n\n\tcredssp_send(credssp);\n\tcredssp_buffer_free(credssp);\n\n\t/* Free resources */\n\n\tcredssp->table->FreeCredentialsHandle(&credentials);\n\tcredssp->table->FreeContextBuffer(pPackageInfo);\n\n\treturn 1;\n}\n\n/**\n * Authenticate with client using CredSSP (server).\n * @param credssp\n * @return 1 if authentication is successful\n */\n\nint credssp_server_authenticate(rdpCredssp* credssp)\n{\n\tUINT32 cbMaxToken;\n\tULONG fContextReq;\n\tULONG pfContextAttr;\n\tSECURITY_STATUS status;\n\tCredHandle credentials;\n\tTimeStamp expiration;\n\tPSecPkgInfo pPackageInfo;\n\tSecBuffer input_buffer;\n\tSecBuffer output_buffer;\n\tSecBufferDesc input_buffer_desc;\n\tSecBufferDesc output_buffer_desc;\n\tBOOL have_context;\n\tBOOL have_input_buffer;\n\tBOOL have_pub_key_auth;\n\n\tsspi_GlobalInit();\n\n\tif (credssp_ntlm_server_init(credssp) == 0)\n\t\treturn 0;\n\n#ifdef WITH_NATIVE_SSPI\n\tif (!credssp->SspiModule)\n\t\tcredssp->SspiModule = _tcsdup(_T(\"secur32.dll\"));\n#endif\n\n\tif (credssp->SspiModule)\n\t{\n\t\tHMODULE hSSPI;\n\t\tINIT_SECURITY_INTERFACE pInitSecurityInterface;\n\n\t\thSSPI = LoadLibrary(credssp->SspiModule);\n\n\t\tif (!hSSPI)\n\t\t{\n\t\t\t_tprintf(_T(\"Failed to load SSPI module: %s\\n\"), credssp->SspiModule);\n\t\t\treturn 0;\n\t\t}\n\n#ifdef UNICODE\n\t\tpInitSecurityInterface = (INIT_SECURITY_INTERFACE) GetProcAddress(hSSPI, \"InitSecurityInterfaceW\");\n#else\n\t\tpInitSecurityInterface = (INIT_SECURITY_INTERFACE) GetProcAddress(hSSPI, \"InitSecurityInterfaceA\");\n#endif\n\n\t\tcredssp->table = (*pInitSecurityInterface)();\n\t}\n#ifndef WITH_NATIVE_SSPI\n\telse\n\t{\n\t\tcredssp->table = InitSecurityInterface();\n\t}\n#endif\n\n\tstatus = credssp->table->QuerySecurityPackageInfo(NLA_PKG_NAME, &pPackageInfo);\n\n\tif (status != SEC_E_OK)\n\t{\n\t\tfprintf(stderr, \"QuerySecurityPackageInfo status: 0x%08X\\n\", status);\n\t\treturn 0;\n\t}\n\n\tcbMaxToken = pPackageInfo->cbMaxToken;\n\n\tstatus = credssp->table->AcquireCredentialsHandle(NULL, NLA_PKG_NAME,\n\t\t\tSECPKG_CRED_INBOUND, NULL, NULL, NULL, NULL, &credentials, &expiration);\n\n\tif (status != SEC_E_OK)\n\t{\n\t\tfprintf(stderr, \"AcquireCredentialsHandle status: 0x%08X\\n\", status);\n\t\treturn 0;\n\t}\n\n\thave_context = FALSE;\n\thave_input_buffer = FALSE;\n\thave_pub_key_auth = FALSE;\n\tZeroMemory(&input_buffer, sizeof(SecBuffer));\n\tZeroMemory(&output_buffer, sizeof(SecBuffer));\n\tZeroMemory(&input_buffer_desc, sizeof(SecBufferDesc));\n\tZeroMemory(&output_buffer_desc, sizeof(SecBufferDesc));\n\tZeroMemory(&credssp->ContextSizes, sizeof(SecPkgContext_Sizes));\n\n\t/*\n\t * from tspkg.dll: 0x00000112\n\t * ASC_REQ_MUTUAL_AUTH\n\t * ASC_REQ_CONFIDENTIALITY\n\t * ASC_REQ_ALLOCATE_MEMORY\n\t */\n\n\tfContextReq = 0;\n\tfContextReq |= ASC_REQ_MUTUAL_AUTH;\n\tfContextReq |= ASC_REQ_CONFIDENTIALITY;\n\n\tfContextReq |= ASC_REQ_CONNECTION;\n\tfContextReq |= ASC_REQ_USE_SESSION_KEY;\n\n\tfContextReq |= ASC_REQ_REPLAY_DETECT;\n\tfContextReq |= ASC_REQ_SEQUENCE_DETECT;\n\n\tfContextReq |= ASC_REQ_EXTENDED_ERROR;\n\n\twhile (TRUE)\n\t{\n\t\tinput_buffer_desc.ulVersion = SECBUFFER_VERSION;\n\t\tinput_buffer_desc.cBuffers = 1;\n\t\tinput_buffer_desc.pBuffers = &input_buffer;\n\t\tinput_buffer.BufferType = SECBUFFER_TOKEN;\n\n\t\t/* receive authentication token */\n\n\t\tinput_buffer_desc.ulVersion = SECBUFFER_VERSION;\n\t\tinput_buffer_desc.cBuffers = 1;\n\t\tinput_buffer_desc.pBuffers = &input_buffer;\n\t\tinput_buffer.BufferType = SECBUFFER_TOKEN;\n\n\t\tif (credssp_recv(credssp) < 0)\n\t\t\treturn -1;\n\n#ifdef WITH_DEBUG_CREDSSP\n\t\tfprintf(stderr, \"Receiving Authentication Token\\n\");\n\t\tcredssp_buffer_print(credssp);\n#endif\n\n\t\tinput_buffer.pvBuffer = credssp->negoToken.pvBuffer;\n\t\tinput_buffer.cbBuffer = credssp->negoToken.cbBuffer;\n\n\t\tif (credssp->negoToken.cbBuffer < 1)\n\t\t{\n\t\t\tfprintf(stderr, \"CredSSP: invalid negoToken!\\n\");\n\t\t\treturn -1;\n\t\t}\n\n\t\toutput_buffer_desc.ulVersion = SECBUFFER_VERSION;\n\t\toutput_buffer_desc.cBuffers = 1;\n\t\toutput_buffer_desc.pBuffers = &output_buffer;\n\t\toutput_buffer.BufferType = SECBUFFER_TOKEN;\n\t\toutput_buffer.cbBuffer = cbMaxToken;\n\t\toutput_buffer.pvBuffer = malloc(output_buffer.cbBuffer);\n\n\t\tstatus = credssp->table->AcceptSecurityContext(&credentials,\n\t\t\thave_context? &credssp->context: NULL,\n\t\t\t&input_buffer_desc, fContextReq, SECURITY_NATIVE_DREP, &credssp->context,\n\t\t\t&output_buffer_desc, &pfContextAttr, &expiration);\n\n\t\tcredssp->negoToken.pvBuffer = output_buffer.pvBuffer;\n\t\tcredssp->negoToken.cbBuffer = output_buffer.cbBuffer;\n\n\t\tif ((status == SEC_I_COMPLETE_AND_CONTINUE) || (status == SEC_I_COMPLETE_NEEDED))\n\t\t{\n\t\t\tif (credssp->table->CompleteAuthToken != NULL)\n\t\t\t\tcredssp->table->CompleteAuthToken(&credssp->context, &output_buffer_desc);\n\n\t\t\tif (status == SEC_I_COMPLETE_NEEDED)\n\t\t\t\tstatus = SEC_E_OK;\n\t\t\telse if (status == SEC_I_COMPLETE_AND_CONTINUE)\n\t\t\t\tstatus = SEC_I_CONTINUE_NEEDED;\n\t\t}\n\n\t\tif (status == SEC_E_OK)\n\t\t{\n\t\t\thave_pub_key_auth = TRUE;\n\n\t\t\tif (credssp->table->QueryContextAttributes(&credssp->context, SECPKG_ATTR_SIZES, &credssp->ContextSizes) != SEC_E_OK)\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"QueryContextAttributes SECPKG_ATTR_SIZES failure\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif (credssp_decrypt_public_key_echo(credssp) != SEC_E_OK)\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"Error: could not verify client's public key echo\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tsspi_SecBufferFree(&credssp->negoToken);\n\t\t\tcredssp->negoToken.pvBuffer = NULL;\n\t\t\tcredssp->negoToken.cbBuffer = 0;\n\n\t\t\tcredssp_encrypt_public_key_echo(credssp);\n\t\t}\n\n\t\tif ((status != SEC_E_OK) && (status != SEC_I_CONTINUE_NEEDED))\n\t\t{\n\t\t\tfprintf(stderr, \"AcceptSecurityContext status: 0x%08X\\n\", status);\n\t\t\treturn -1;\n\t\t}\n\n\t\t/* send authentication token */\n\n#ifdef WITH_DEBUG_CREDSSP\n\t\tfprintf(stderr, \"Sending Authentication Token\\n\");\n\t\tcredssp_buffer_print(credssp);\n#endif\n\n\t\tcredssp_send(credssp);\n\t\tcredssp_buffer_free(credssp);\n\n\t\tif (status != SEC_I_CONTINUE_NEEDED)\n\t\t\tbreak;\n\n\t\thave_context = TRUE;\n\t}\n\n\t/* Receive encrypted credentials */\n\n\tif (credssp_recv(credssp) < 0)\n\t\treturn -1;\n\n\tif (credssp_decrypt_ts_credentials(credssp) != SEC_E_OK)\n\t{\n\t\tfprintf(stderr, \"Could not decrypt TSCredentials status: 0x%08X\\n\", status);\n\t\treturn 0;\n\t}\n\n\tif (status != SEC_E_OK)\n\t{\n\t\tfprintf(stderr, \"AcceptSecurityContext status: 0x%08X\\n\", status);\n\t\treturn 0;\n\t}\n\n\tstatus = credssp->table->ImpersonateSecurityContext(&credssp->context);\n\n\tif (status != SEC_E_OK)\n\t{\n\t\tfprintf(stderr, \"ImpersonateSecurityContext status: 0x%08X\\n\", status);\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tstatus = credssp->table->RevertSecurityContext(&credssp->context);\n\n\t\tif (status != SEC_E_OK)\n\t\t{\n\t\t\tfprintf(stderr, \"RevertSecurityContext status: 0x%08X\\n\", status);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tcredssp->table->FreeContextBuffer(pPackageInfo);\n\n\treturn 1;\n}\n\n/**\n * Authenticate using CredSSP.\n * @param credssp\n * @return 1 if authentication is successful\n */\n\nint credssp_authenticate(rdpCredssp* credssp)\n{\n\tif (credssp->server)\n\t\treturn credssp_server_authenticate(credssp);\n\telse\n\t\treturn credssp_client_authenticate(credssp);\n}\n\nvoid ap_integer_increment_le(BYTE* number, int size)\n{\n\tint index;\n\n\tfor (index = 0; index < size; index++)\n\t{\n\t\tif (number[index] < 0xFF)\n\t\t{\n\t\t\tnumber[index]++;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnumber[index] = 0;\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\nvoid ap_integer_decrement_le(BYTE* number, int size)\n{\n\tint index;\n\n\tfor (index = 0; index < size; index++)\n\t{\n\t\tif (number[index] > 0)\n\t\t{\n\t\t\tnumber[index]--;\n\t\t\tbreak;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnumber[index] = 0xFF;\n\t\t\tcontinue;\n\t\t}\n\t}\n}\n\nSECURITY_STATUS credssp_encrypt_public_key_echo(rdpCredssp* credssp)\n{\n\tSecBuffer Buffers[2];\n\tSecBufferDesc Message;\n\tSECURITY_STATUS status;\n\tint public_key_length;\n\n\tpublic_key_length = credssp->PublicKey.cbBuffer;\n\n\tBuffers[0].BufferType = SECBUFFER_TOKEN; /* Signature */\n\tBuffers[1].BufferType = SECBUFFER_DATA; /* TLS Public Key */\n\n\tsspi_SecBufferAlloc(&credssp->pubKeyAuth, credssp->ContextSizes.cbMaxSignature + public_key_length);\n\n\tBuffers[0].cbBuffer = credssp->ContextSizes.cbMaxSignature;\n\tBuffers[0].pvBuffer = credssp->pubKeyAuth.pvBuffer;\n\n\tBuffers[1].cbBuffer = public_key_length;\n\tBuffers[1].pvBuffer = ((BYTE*) credssp->pubKeyAuth.pvBuffer) + credssp->ContextSizes.cbMaxSignature;\n\tCopyMemory(Buffers[1].pvBuffer, credssp->PublicKey.pvBuffer, Buffers[1].cbBuffer);\n\n\tif (credssp->server)\n\t{\n\t\t/* server echos the public key +1 */\n\t\tap_integer_increment_le((BYTE*) Buffers[1].pvBuffer, Buffers[1].cbBuffer);\n\t}\n\n\tMessage.cBuffers = 2;\n\tMessage.ulVersion = SECBUFFER_VERSION;\n\tMessage.pBuffers = (PSecBuffer) &Buffers;\n\n\tstatus = credssp->table->EncryptMessage(&credssp->context, 0, &Message, credssp->send_seq_num++);\n\n\tif (status != SEC_E_OK)\n\t{\n\t\tfprintf(stderr, \"EncryptMessage status: 0x%08X\\n\", status);\n\t\treturn status;\n\t}\n\n\treturn status;\n}\n\nSECURITY_STATUS credssp_decrypt_public_key_echo(rdpCredssp* credssp)\n{\n\tint length;\n\tBYTE* buffer;\n\tULONG pfQOP;\n\tBYTE* public_key1;\n\tBYTE* public_key2;\n\tint public_key_length;\n\tSecBuffer Buffers[2];\n\tSecBufferDesc Message;\n\tSECURITY_STATUS status;\n\n\tif (credssp->PublicKey.cbBuffer + credssp->ContextSizes.cbMaxSignature != credssp->pubKeyAuth.cbBuffer)\n\t{\n\t\tfprintf(stderr, \"unexpected pubKeyAuth buffer size:%d\\n\", (int) credssp->pubKeyAuth.cbBuffer);\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tlength = credssp->pubKeyAuth.cbBuffer;\n\tbuffer = (BYTE*) malloc(length);\n\tCopyMemory(buffer, credssp->pubKeyAuth.pvBuffer, length);\n\n\tpublic_key_length = credssp->PublicKey.cbBuffer;\n\n\tBuffers[0].BufferType = SECBUFFER_TOKEN; /* Signature */\n\tBuffers[1].BufferType = SECBUFFER_DATA; /* Encrypted TLS Public Key */\n\n\tBuffers[0].cbBuffer = credssp->ContextSizes.cbMaxSignature;\n\tBuffers[0].pvBuffer = buffer;\n\n\tBuffers[1].cbBuffer = length - credssp->ContextSizes.cbMaxSignature;\n\tBuffers[1].pvBuffer = buffer + credssp->ContextSizes.cbMaxSignature;\n\n\tMessage.cBuffers = 2;\n\tMessage.ulVersion = SECBUFFER_VERSION;\n\tMessage.pBuffers = (PSecBuffer) &Buffers;\n\n\tstatus = credssp->table->DecryptMessage(&credssp->context, &Message, credssp->recv_seq_num++, &pfQOP);\n\n\tif (status != SEC_E_OK)\n\t{\n\t\tfprintf(stderr, \"DecryptMessage failure: 0x%08X\\n\", status);\n\t\treturn status;\n\t}\n\n\tpublic_key1 = (BYTE*) credssp->PublicKey.pvBuffer;\n\tpublic_key2 = (BYTE*) Buffers[1].pvBuffer;\n\n\tif (!credssp->server)\n\t{\n\t\t/* server echos the public key +1 */\n\t\tap_integer_decrement_le(public_key2, public_key_length);\n\t}\n\n\tif (memcmp(public_key1, public_key2, public_key_length) != 0)\n\t{\n\t\tfprintf(stderr, \"Could not verify server's public key echo\\n\");\n\n\t\tfprintf(stderr, \"Expected (length = %d):\\n\", public_key_length);\n\t\twinpr_HexDump(public_key1, public_key_length);\n\n\t\tfprintf(stderr, \"Actual (length = %d):\\n\", public_key_length);\n\t\twinpr_HexDump(public_key2, public_key_length);\n\n\t\treturn SEC_E_MESSAGE_ALTERED; /* DO NOT SEND CREDENTIALS! */\n\t}\n\n\tfree(buffer);\n\n\treturn SEC_E_OK;\n}\n\nint credssp_sizeof_ts_password_creds(rdpCredssp* credssp)\n{\n\tint length = 0;\n\n\tlength += ber_sizeof_sequence_octet_string(credssp->identity.DomainLength * 2);\n\tlength += ber_sizeof_sequence_octet_string(credssp->identity.UserLength * 2);\n\tlength += ber_sizeof_sequence_octet_string(credssp->identity.PasswordLength * 2);\n\n\treturn length;\n}\n\nvoid credssp_read_ts_password_creds(rdpCredssp* credssp, wStream* s)\n{\n\tint length;\n\n\t/* TSPasswordCreds (SEQUENCE) */\n\tber_read_sequence_tag(s, &length);\n\n\t/* [0] domainName (OCTET STRING) */\n\tber_read_contextual_tag(s, 0, &length, TRUE);\n\tber_read_octet_string_tag(s, &length);\n\tcredssp->identity.DomainLength = (UINT32) length;\n\tcredssp->identity.Domain = (UINT16*) malloc(length);\n\tCopyMemory(credssp->identity.Domain, Stream_Pointer(s), credssp->identity.DomainLength);\n\tStream_Seek(s, credssp->identity.DomainLength);\n\tcredssp->identity.DomainLength /= 2;\n\n\t/* [1] userName (OCTET STRING) */\n\tber_read_contextual_tag(s, 1, &length, TRUE);\n\tber_read_octet_string_tag(s, &length);\n\tcredssp->identity.UserLength = (UINT32) length;\n\tcredssp->identity.User = (UINT16*) malloc(length);\n\tCopyMemory(credssp->identity.User, Stream_Pointer(s), credssp->identity.UserLength);\n\tStream_Seek(s, credssp->identity.UserLength);\n\tcredssp->identity.UserLength /= 2;\n\n\t/* [2] password (OCTET STRING) */\n\tber_read_contextual_tag(s, 2, &length, TRUE);\n\tber_read_octet_string_tag(s, &length);\n\tcredssp->identity.PasswordLength = (UINT32) length;\n\tcredssp->identity.Password = (UINT16*) malloc(length);\n\tCopyMemory(credssp->identity.Password, Stream_Pointer(s), credssp->identity.PasswordLength);\n\tStream_Seek(s, credssp->identity.PasswordLength);\n\tcredssp->identity.PasswordLength /= 2;\n\n\tcredssp->identity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;\n}\n\nint credssp_write_ts_password_creds(rdpCredssp* credssp, wStream* s)\n{\n\tint size = 0;\n\tint innerSize = credssp_sizeof_ts_password_creds(credssp);\n\n\t/* TSPasswordCreds (SEQUENCE) */\n\n\tsize += ber_write_sequence_tag(s, innerSize);\n\n\t/* [0] domainName (OCTET STRING) */\n\tsize += ber_write_sequence_octet_string(s, 0, (BYTE*) credssp->identity.Domain, credssp->identity.DomainLength * 2);\n\n\t/* [1] userName (OCTET STRING) */\n\tsize += ber_write_sequence_octet_string(s, 1, (BYTE*) credssp->identity.User, credssp->identity.UserLength * 2);\n\n\t/* [2] password (OCTET STRING) */\n\tsize += ber_write_sequence_octet_string(s, 2, (BYTE*) credssp->identity.Password, credssp->identity.PasswordLength * 2);\n\n\treturn size;\n}\n\nint credssp_sizeof_ts_credentials(rdpCredssp* credssp)\n{\n\tint size = 0;\n\n\tsize += ber_sizeof_integer(1);\n\tsize += ber_sizeof_contextual_tag(ber_sizeof_integer(1));\n\tsize += ber_sizeof_sequence_octet_string(ber_sizeof_sequence(credssp_sizeof_ts_password_creds(credssp)));\n\n\treturn size;\n}\n\nvoid credssp_read_ts_credentials(rdpCredssp* credssp, PSecBuffer ts_credentials)\n{\n\twStream* s;\n\tint length;\n\tint ts_password_creds_length;\n\n\ts = Stream_New(ts_credentials->pvBuffer, ts_credentials->cbBuffer);\n\n\t/* TSCredentials (SEQUENCE) */\n\tber_read_sequence_tag(s, &length);\n\n\t/* [0] credType (INTEGER) */\n\tber_read_contextual_tag(s, 0, &length, TRUE);\n\tber_read_integer(s, NULL);\n\n\t/* [1] credentials (OCTET STRING) */\n\tber_read_contextual_tag(s, 1, &length, TRUE);\n\tber_read_octet_string_tag(s, &ts_password_creds_length);\n\n\tcredssp_read_ts_password_creds(credssp, s);\n\n\tStream_Free(s, FALSE);\n}\n\nint credssp_write_ts_credentials(rdpCredssp* credssp, wStream* s)\n{\n\tint size = 0;\n\tint innerSize = credssp_sizeof_ts_credentials(credssp);\n\tint passwordSize;\n\n\t/* TSCredentials (SEQUENCE) */\n\tsize += ber_write_sequence_tag(s, innerSize);\n\n\t/* [0] credType (INTEGER) */\n\tsize += ber_write_contextual_tag(s, 0, ber_sizeof_integer(1), TRUE);\n\tsize += ber_write_integer(s, 1);\n\n\t/* [1] credentials (OCTET STRING) */\n\n\tpasswordSize = ber_sizeof_sequence(credssp_sizeof_ts_password_creds(credssp));\n\n\tsize += ber_write_contextual_tag(s, 1, ber_sizeof_octet_string(passwordSize), TRUE);\n\tsize += ber_write_octet_string_tag(s, passwordSize);\n\tsize += credssp_write_ts_password_creds(credssp, s);\n\n\treturn size;\n}\n\n/**\n * Encode TSCredentials structure.\n * @param credssp\n */\n\nvoid credssp_encode_ts_credentials(rdpCredssp* credssp)\n{\n\twStream* s;\n\tint length;\n\n\tlength = ber_sizeof_sequence(credssp_sizeof_ts_credentials(credssp));\n\tsspi_SecBufferAlloc(&credssp->ts_credentials, length);\n\n\ts = Stream_New(credssp->ts_credentials.pvBuffer, length);\n\tcredssp_write_ts_credentials(credssp, s);\n\n\tStream_Free(s, FALSE);\n}\n\nSECURITY_STATUS credssp_encrypt_ts_credentials(rdpCredssp* credssp)\n{\n\tSecBuffer Buffers[2];\n\tSecBufferDesc Message;\n\tSECURITY_STATUS status;\n\n\tcredssp_encode_ts_credentials(credssp);\n\n\tBuffers[0].BufferType = SECBUFFER_TOKEN; /* Signature */\n\tBuffers[1].BufferType = SECBUFFER_DATA; /* TSCredentials */\n\n\tsspi_SecBufferAlloc(&credssp->authInfo, credssp->ContextSizes.cbMaxSignature + credssp->ts_credentials.cbBuffer);\n\n\tBuffers[0].cbBuffer = credssp->ContextSizes.cbMaxSignature;\n\tBuffers[0].pvBuffer = credssp->authInfo.pvBuffer;\n\tZeroMemory(Buffers[0].pvBuffer, Buffers[0].cbBuffer);\n\n\tBuffers[1].cbBuffer = credssp->ts_credentials.cbBuffer;\n\tBuffers[1].pvBuffer = &((BYTE*) credssp->authInfo.pvBuffer)[Buffers[0].cbBuffer];\n\tCopyMemory(Buffers[1].pvBuffer, credssp->ts_credentials.pvBuffer, Buffers[1].cbBuffer);\n\n\tMessage.cBuffers = 2;\n\tMessage.ulVersion = SECBUFFER_VERSION;\n\tMessage.pBuffers = (PSecBuffer) &Buffers;\n\n\tstatus = credssp->table->EncryptMessage(&credssp->context, 0, &Message, credssp->send_seq_num++);\n\n\tif (status != SEC_E_OK)\n\t\treturn status;\n\n\treturn SEC_E_OK;\n}\n\nSECURITY_STATUS credssp_decrypt_ts_credentials(rdpCredssp* credssp)\n{\n\tint length;\n\tBYTE* buffer;\n\tULONG pfQOP;\n\tSecBuffer Buffers[2];\n\tSecBufferDesc Message;\n\tSECURITY_STATUS status;\n\n\tBuffers[0].BufferType = SECBUFFER_TOKEN; /* Signature */\n\tBuffers[1].BufferType = SECBUFFER_DATA; /* TSCredentials */\n\n\tif (credssp->authInfo.cbBuffer < 1)\n\t{\n\t\tfprintf(stderr, \"credssp_decrypt_ts_credentials missing authInfo buffer\\n\");\n\t\treturn SEC_E_INVALID_TOKEN;\n\t}\n\n\tlength = credssp->authInfo.cbBuffer;\n\tbuffer = (BYTE*) malloc(length);\n\tCopyMemory(buffer, credssp->authInfo.pvBuffer, length);\n\n\tBuffers[0].cbBuffer = credssp->ContextSizes.cbMaxSignature;\n\tBuffers[0].pvBuffer = buffer;\n\n\tBuffers[1].cbBuffer = length - credssp->ContextSizes.cbMaxSignature;\n\tBuffers[1].pvBuffer = &buffer[credssp->ContextSizes.cbMaxSignature];\n\n\tMessage.cBuffers = 2;\n\tMessage.ulVersion = SECBUFFER_VERSION;\n\tMessage.pBuffers = (PSecBuffer) &Buffers;\n\n\tstatus = credssp->table->DecryptMessage(&credssp->context, &Message, credssp->recv_seq_num++, &pfQOP);\n\n\tif (status != SEC_E_OK)\n\t\treturn status;\n\n\tcredssp_read_ts_credentials(credssp, &Buffers[1]);\n\n\tfree(buffer);\n\n\treturn SEC_E_OK;\n}\n\nint credssp_sizeof_nego_token(int length)\n{\n\tlength = ber_sizeof_octet_string(length);\n\tlength += ber_sizeof_contextual_tag(length);\n\treturn length;\n}\n\nint credssp_sizeof_nego_tokens(int length)\n{\n\tlength = credssp_sizeof_nego_token(length);\n\tlength += ber_sizeof_sequence_tag(length);\n\tlength += ber_sizeof_sequence_tag(length);\n\tlength += ber_sizeof_contextual_tag(length);\n\treturn length;\n}\n\nint credssp_sizeof_pub_key_auth(int length)\n{\n\tlength = ber_sizeof_octet_string(length);\n\tlength += ber_sizeof_contextual_tag(length);\n\treturn length;\n}\n\nint credssp_sizeof_auth_info(int length)\n{\n\tlength = ber_sizeof_octet_string(length);\n\tlength += ber_sizeof_contextual_tag(length);\n\treturn length;\n}\n\nint credssp_sizeof_ts_request(int length)\n{\n\tlength += ber_sizeof_integer(2);\n\tlength += ber_sizeof_contextual_tag(3);\n\treturn length;\n}\n\n/**\n * Send CredSSP message.\n * @param credssp\n */\n\nvoid credssp_send(rdpCredssp* credssp)\n{\n\twStream* s;\n\tint length;\n\tint ts_request_length;\n\tint nego_tokens_length;\n\tint pub_key_auth_length;\n\tint auth_info_length;\n\n\tnego_tokens_length = (credssp->negoToken.cbBuffer > 0) ? credssp_sizeof_nego_tokens(credssp->negoToken.cbBuffer) : 0;\n\tpub_key_auth_length = (credssp->pubKeyAuth.cbBuffer > 0) ? credssp_sizeof_pub_key_auth(credssp->pubKeyAuth.cbBuffer) : 0;\n\tauth_info_length = (credssp->authInfo.cbBuffer > 0) ? credssp_sizeof_auth_info(credssp->authInfo.cbBuffer) : 0;\n\n\tlength = nego_tokens_length + pub_key_auth_length + auth_info_length;\n\n\tts_request_length = credssp_sizeof_ts_request(length);\n\n\ts = Stream_New(NULL, ber_sizeof_sequence(ts_request_length));\n\n\t/* TSRequest */\n\tber_write_sequence_tag(s, ts_request_length); /* SEQUENCE */\n\n\t/* [0] version */\n\tber_write_contextual_tag(s, 0, 3, TRUE);\n\tber_write_integer(s, 2); /* INTEGER */\n\n\t/* [1] negoTokens (NegoData) */\n\tif (nego_tokens_length > 0)\n\t{\n\t\tlength = nego_tokens_length;\n\n\t\tlength -= ber_write_contextual_tag(s, 1, ber_sizeof_sequence(ber_sizeof_sequence(ber_sizeof_sequence_octet_string(credssp->negoToken.cbBuffer))), TRUE); /* NegoData */\n\t\tlength -= ber_write_sequence_tag(s, ber_sizeof_sequence(ber_sizeof_sequence_octet_string(credssp->negoToken.cbBuffer))); /* SEQUENCE OF NegoDataItem */\n\t\tlength -= ber_write_sequence_tag(s, ber_sizeof_sequence_octet_string(credssp->negoToken.cbBuffer)); /* NegoDataItem */\n\t\tlength -= ber_write_sequence_octet_string(s, 0, (BYTE*) credssp->negoToken.pvBuffer, credssp->negoToken.cbBuffer); /* OCTET STRING */\n\n\t\t// assert length == 0\n\t}\n\n\t/* [2] authInfo (OCTET STRING) */\n\tif (auth_info_length > 0)\n\t{\n\t\tlength = auth_info_length;\n\t\tlength -= ber_write_sequence_octet_string(s, 2, credssp->authInfo.pvBuffer, credssp->authInfo.cbBuffer);\n\n\t\t// assert length == 0\n\t}\n\n\t/* [3] pubKeyAuth (OCTET STRING) */\n\tif (pub_key_auth_length > 0)\n\t{\n\t\tlength = pub_key_auth_length;\n\t\tlength -= ber_write_sequence_octet_string(s, 3, credssp->pubKeyAuth.pvBuffer, credssp->pubKeyAuth.cbBuffer);\n\n\t\t// assert length == 0\n\t}\n\n\tStream_SealLength(s);\n\n\ttransport_write(credssp->transport, s);\n\n\tStream_Free(s, TRUE);\n}\n\n/**\n * Receive CredSSP message.\n * @param credssp\n * @return\n */\n\nint credssp_recv(rdpCredssp* credssp)\n{\n\twStream* s;\n\tint length;\n\tint status;\n\tUINT32 version;\n\n\ts = Stream_New(NULL, 4096);\n\n\tstatus = transport_read(credssp->transport, s);\n\tStream_Length(s) = status;\n\n\tif (status < 0)\n\t{\n\t\tfprintf(stderr, \"credssp_recv() error: %d\\n\", status);\n\t\tStream_Free(s, TRUE);\n\t\treturn -1;\n\t}\n\n\t/* TSRequest */\n\tif(!ber_read_sequence_tag(s, &length) ||\n\t\t!ber_read_contextual_tag(s, 0, &length, TRUE) ||\n\t\t!ber_read_integer(s, &version))\n\t\treturn -1;\n\n\t/* [1] negoTokens (NegoData) */\n\tif (ber_read_contextual_tag(s, 1, &length, TRUE) != FALSE)\n\t{\n\t\tif (!ber_read_sequence_tag(s, &length) || /* SEQUENCE OF NegoDataItem */\n\t\t\t!ber_read_sequence_tag(s, &length) || /* NegoDataItem */\n\t\t\t!ber_read_contextual_tag(s, 0, &length, TRUE) || /* [0] negoToken */\n\t\t\t!ber_read_octet_string_tag(s, &length) || /* OCTET STRING */\n\t\t\tStream_GetRemainingLength(s) < length)\n\t\t\treturn -1;\n\t\tsspi_SecBufferAlloc(&credssp->negoToken, length);\n\t\tStream_Read(s, credssp->negoToken.pvBuffer, length);\n\t\tcredssp->negoToken.cbBuffer = length;\n\t}\n\n\t/* [2] authInfo (OCTET STRING) */\n\tif (ber_read_contextual_tag(s, 2, &length, TRUE) != FALSE)\n\t{\n\t\tif(!ber_read_octet_string_tag(s, &length) || /* OCTET STRING */\n\t\t\tStream_GetRemainingLength(s) < length)\n\t\t\treturn -1;\n\t\tsspi_SecBufferAlloc(&credssp->authInfo, length);\n\t\tStream_Read(s, credssp->authInfo.pvBuffer, length);\n\t\tcredssp->authInfo.cbBuffer = length;\n\t}\n\n\t/* [3] pubKeyAuth (OCTET STRING) */\n\tif (ber_read_contextual_tag(s, 3, &length, TRUE) != FALSE)\n\t{\n\t\tif(!ber_read_octet_string_tag(s, &length) || /* OCTET STRING */\n\t\t\tStream_GetRemainingLength(s) < length)\n\t\t\treturn -1;\n\t\tsspi_SecBufferAlloc(&credssp->pubKeyAuth, length);\n\t\tStream_Read(s, credssp->pubKeyAuth.pvBuffer, length);\n\t\tcredssp->pubKeyAuth.cbBuffer = length;\n\t}\n\n\tStream_Free(s, TRUE);\n\n\treturn 0;\n}\n\nvoid credssp_buffer_print(rdpCredssp* credssp)\n{\n\tif (credssp->negoToken.cbBuffer > 0)\n\t{\n\t\tfprintf(stderr, \"CredSSP.negoToken (length = %d):\\n\", (int) credssp->negoToken.cbBuffer);\n\t\twinpr_HexDump(credssp->negoToken.pvBuffer, credssp->negoToken.cbBuffer);\n\t}\n\n\tif (credssp->pubKeyAuth.cbBuffer > 0)\n\t{\n\t\tfprintf(stderr, \"CredSSP.pubKeyAuth (length = %d):\\n\", (int) credssp->pubKeyAuth.cbBuffer);\n\t\twinpr_HexDump(credssp->pubKeyAuth.pvBuffer, credssp->pubKeyAuth.cbBuffer);\n\t}\n\n\tif (credssp->authInfo.cbBuffer > 0)\n\t{\n\t\tfprintf(stderr, \"CredSSP.authInfo (length = %d):\\n\", (int) credssp->authInfo.cbBuffer);\n\t\twinpr_HexDump(credssp->authInfo.pvBuffer, credssp->authInfo.cbBuffer);\n\t}\n}\n\nvoid credssp_buffer_free(rdpCredssp* credssp)\n{\n\tsspi_SecBufferFree(&credssp->negoToken);\n\tsspi_SecBufferFree(&credssp->pubKeyAuth);\n\tsspi_SecBufferFree(&credssp->authInfo);\n}\n\n/**\n * Create new CredSSP state machine.\n * @param transport\n * @return new CredSSP state machine.\n */\n\nrdpCredssp* credssp_new(freerdp* instance, rdpTransport* transport, rdpSettings* settings)\n{\n\trdpCredssp* credssp;\n\n\tcredssp = (rdpCredssp*) malloc(sizeof(rdpCredssp));\n\tZeroMemory(credssp, sizeof(rdpCredssp));\n\n\tif (credssp != NULL)\n\t{\n\t\tHKEY hKey;\n\t\tLONG status;\n\t\tDWORD dwType;\n\t\tDWORD dwSize;\n\n\t\tcredssp->instance = instance;\n\t\tcredssp->settings = settings;\n\t\tcredssp->server = settings->ServerMode;\n\t\tcredssp->transport = transport;\n\t\tcredssp->send_seq_num = 0;\n\t\tcredssp->recv_seq_num = 0;\n\t\tZeroMemory(&credssp->negoToken, sizeof(SecBuffer));\n\t\tZeroMemory(&credssp->pubKeyAuth, sizeof(SecBuffer));\n\t\tZeroMemory(&credssp->authInfo, sizeof(SecBuffer));\n\t\tSecInvalidateHandle(&credssp->context);\n\n\t\tif (credssp->server)\n\t\t{\n\t\t\tstatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, _T(\"Software\\\\FreeRDP\\\\Server\"),\n\t\t\t\t\t0, KEY_READ | KEY_WOW64_64KEY, &hKey);\n\n\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t{\n\t\t\t\tstatus = RegQueryValueEx(hKey, _T(\"SspiModule\"), NULL, &dwType, NULL, &dwSize);\n\n\t\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t\t{\n\t\t\t\t\tcredssp->SspiModule = (LPTSTR) malloc(dwSize + sizeof(TCHAR));\n\n\t\t\t\t\tstatus = RegQueryValueEx(hKey, _T(\"SspiModule\"), NULL, &dwType,\n\t\t\t\t\t\t\t(BYTE*) credssp->SspiModule, &dwSize);\n\n\t\t\t\t\tif (status == ERROR_SUCCESS)\n\t\t\t\t\t{\n\t\t\t\t\t\t_tprintf(_T(\"Using SSPI Module: %s\\n\"), credssp->SspiModule);\n\t\t\t\t\t\tRegCloseKey(hKey);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn credssp;\n}\n\n/**\n * Free CredSSP state machine.\n * @param credssp\n */\n\nvoid credssp_free(rdpCredssp* credssp)\n{\n\tif (credssp != NULL)\n\t{\n\t\tif (credssp->table)\n\t\t\tcredssp->table->DeleteSecurityContext(&credssp->context);\n\n\t\tsspi_SecBufferFree(&credssp->PublicKey);\n\t\tsspi_SecBufferFree(&credssp->ts_credentials);\n\n\t\tfree(credssp->ServicePrincipalName);\n\n\t\tfree(credssp->identity.User);\n\t\tfree(credssp->identity.Domain);\n\t\tfree(credssp->identity.Password);\n\t\tfree(credssp);\n\t}\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * RDP Server Peer\n *\n * Copyright 2011 Vic Lee\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <winpr/crt.h>\n\n#include \"certificate.h\"\n\n#include <freerdp/utils/tcp.h>\n\n#include \"peer.h\"\n\nstatic BOOL freerdp_peer_initialize(freerdp_peer* client)\n{\n\tclient->context->rdp->settings->ServerMode = TRUE;\n\tclient->context->rdp->settings->FrameAcknowledge = 0;\n\tclient->context->rdp->settings->LocalConnection = client->local;\n\tclient->context->rdp->state = CONNECTION_STATE_INITIAL;\n\n\tif (client->context->rdp->settings->RdpKeyFile != NULL)\n\t{\n\t\tclient->context->rdp->settings->RdpServerRsaKey =\n\t\t    key_new(client->context->rdp->settings->RdpKeyFile);\n\t}\n\n\treturn TRUE;\n}\n\nstatic BOOL freerdp_peer_get_fds(freerdp_peer* client, void** rfds, int* rcount)\n{\n\trfds[*rcount] = (void*)(long)(client->context->rdp->transport->TcpIn->sockfd);\n\t(*rcount)++;\n\n\treturn TRUE;\n}\n\nstatic BOOL freerdp_peer_check_fds(freerdp_peer* client)\n{\n\tint status;\n\trdpRdp* rdp;\n\n\trdp = client->context->rdp;\n\n\tstatus = rdp_check_fds(rdp);\n\n\tif (status < 0)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nstatic BOOL peer_recv_data_pdu(freerdp_peer* client, wStream* s)\n{\n\tBYTE type;\n\tUINT16 length;\n\tUINT32 share_id;\n\tBYTE compressed_type;\n\tUINT16 compressed_len;\n\n\tif (!rdp_read_share_data_header(s, &length, &type, &share_id, &compressed_type, &compressed_len))\n\t\treturn FALSE;\n\n\tswitch (type)\n\t{\n\t\tcase DATA_PDU_TYPE_SYNCHRONIZE:\n\t\t\tif (!rdp_recv_client_synchronize_pdu(client->context->rdp, s))\n\t\t\t\treturn FALSE;\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_CONTROL:\n\t\t\tif (!rdp_server_accept_client_control_pdu(client->context->rdp, s))\n\t\t\t\treturn FALSE;\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_INPUT:\n\t\t\tif (!input_recv(client->context->rdp->input, s))\n\t\t\t\treturn FALSE;\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_BITMAP_CACHE_PERSISTENT_LIST:\n\t\t\t/* TODO: notify server bitmap cache data */\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_FONT_LIST:\n\n\t\t\tif (!rdp_server_accept_client_font_list_pdu(client->context->rdp, s))\n\t\t\t\treturn FALSE;\n\n\t\t\tif (!client->connected)\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * PostConnect should only be called once and should not be called\n\t\t\t\t * after a reactivation sequence.\n\t\t\t\t */\n\n\t\t\t\tIFCALLRET(client->PostConnect, client->connected, client);\n\n\t\t\t\tif (!client->connected)\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tif (!client->activated)\n\t\t\t{\n\t\t\t\t/* Activate will be called everytime after the client is activated/reactivated. */\n\t\t\t\n\t\t\t\tIFCALLRET(client->Activate, client->activated, client);\n\n\t\t\t\tif (!client->activated)\n\t\t\t\t\treturn FALSE;\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SHUTDOWN_REQUEST:\n\t\t\tmcs_send_disconnect_provider_ultimatum(client->context->rdp->mcs);\n\t\t\treturn FALSE;\n\n\t\tcase DATA_PDU_TYPE_FRAME_ACKNOWLEDGE:\n\t\t\tif(Stream_GetRemainingLength(s) < 4)\n\t\t\t\treturn FALSE;\n\t\t\tStream_Read_UINT32(s, client->ack_frame_id);\n\t\t\tIFCALL(client->update->SurfaceFrameAcknowledge, client->update->context, client->ack_frame_id);\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_REFRESH_RECT:\n\t\t\tif (!update_read_refresh_rect(client->update, s))\n\t\t\t\treturn FALSE;\n\t\t\tbreak;\n\n\t\tcase DATA_PDU_TYPE_SUPPRESS_OUTPUT:\n\t\t\tif (!update_read_suppress_output(client->update, s))\n\t\t\t\treturn FALSE;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Data PDU type %d\\n\", type);\n\t\t\tbreak;\n\t}\n\n\treturn TRUE;\n}\n\nstatic int peer_recv_tpkt_pdu(freerdp_peer* client, wStream* s)\n{\n\trdpRdp* rdp;\n\tUINT16 length;\n\tUINT16 pduType;\n\tUINT16 pduLength;\n\tUINT16 pduSource;\n\tUINT16 channelId;\n\tUINT16 securityFlags;\n\n\trdp = client->context->rdp;\n\n\tif (!rdp_read_header(rdp, s, &length, &channelId))\n\t{\n\t\tfprintf(stderr, \"Incorrect RDP header.\\n\");\n\t\treturn -1;\n\t}\n\n\tif (rdp->settings->DisableEncryption)\n\t{\n\t\tif (!rdp_read_security_header(s, &securityFlags))\n\t\t\treturn -1;\n\n\t\tif (securityFlags & SEC_ENCRYPT)\n\t\t{\n\t\t\tif (!rdp_decrypt(rdp, s, length - 4, securityFlags))\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"rdp_decrypt failed\\n\");\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (channelId != MCS_GLOBAL_CHANNEL_ID)\n\t{\n\t\tif(!freerdp_channel_peer_process(client, s, channelId))\n\t\t\treturn -1;\n\t}\n\telse\n\t{\n\t\tif (!rdp_read_share_control_header(s, &pduLength, &pduType, &pduSource))\n\t\t\treturn -1;\n\n\t\tclient->settings->PduSource = pduSource;\n\n\t\tswitch (pduType)\n\t\t{\n\t\t\tcase PDU_TYPE_DATA:\n\t\t\t\tif (!peer_recv_data_pdu(client, s))\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tfprintf(stderr, \"Client sent pduType %d\\n\", pduType);\n\t\t\t\treturn -1;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nstatic int peer_recv_fastpath_pdu(freerdp_peer* client, wStream* s)\n{\n\trdpRdp* rdp;\n\tUINT16 length;\n\trdpFastPath* fastpath;\n\n\trdp = client->context->rdp;\n\tfastpath = rdp->fastpath;\n\t//if (!fastpath_read_header_rdp(fastpath, s, &length))\n\t//\treturn -1;\n\n\tfastpath_read_header_rdp(fastpath, s, &length);\n\n\tif ((length == 0) || (length > Stream_GetRemainingLength(s)))\n\t{\n\t\tfprintf(stderr, \"incorrect FastPath PDU header length %d\\n\", length);\n\t\treturn -1;\n\t}\n\n\tif (fastpath->encryptionFlags & FASTPATH_OUTPUT_ENCRYPTED)\n\t{\n\t\tif (!rdp_decrypt(rdp, s, length, (fastpath->encryptionFlags & FASTPATH_OUTPUT_SECURE_CHECKSUM) ? SEC_SECURE_CHECKSUM : 0))\n\t\t\treturn -1;\n\t}\n\n\treturn fastpath_recv_inputs(fastpath, s);\n}\n\nstatic int peer_recv_pdu(freerdp_peer* client, wStream* s)\n{\n\tif (tpkt_verify_header(s))\n\t\treturn peer_recv_tpkt_pdu(client, s);\n\telse\n\t\treturn peer_recv_fastpath_pdu(client, s);\n}\n\nstatic int peer_recv_callback(rdpTransport* transport, wStream* s, void* extra)\n{\n\tfreerdp_peer* client = (freerdp_peer*) extra;\n\trdpRdp* rdp = client->context->rdp;\n\n\tswitch (rdp->state)\n\t{\n\t\tcase CONNECTION_STATE_INITIAL:\n\t\t\tif (!rdp_server_accept_nego(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tif (rdp->nego->selected_protocol & PROTOCOL_NLA)\n\t\t\t{\n\t\t\t\tsspi_CopyAuthIdentity(&client->identity, &(rdp->nego->transport->credssp->identity));\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, TRUE);\n\t\t\t\tcredssp_free(rdp->nego->transport->credssp);\n\t\t\t\trdp->nego->transport->credssp = NULL;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tIFCALLRET(client->Logon, client->authenticated, client, &client->identity, FALSE);\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_NEGO:\n\t\t\tif (!rdp_server_accept_mcs_connect_initial(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CONNECT:\n\t\t\tif (!rdp_server_accept_mcs_erect_domain_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ERECT_DOMAIN:\n\t\t\tif (!rdp_server_accept_mcs_attach_user_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_ATTACH_USER:\n\t\t\tif (!rdp_server_accept_mcs_channel_join_request(rdp, s))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_MCS_CHANNEL_JOIN:\n\t\t\tif (rdp->settings->DisableEncryption)\n\t\t\t{\n\t\t\t\tif (!rdp_server_accept_client_keys(rdp, s))\n\t\t\t\t\treturn -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\trdp->state = CONNECTION_STATE_ESTABLISH_KEYS;\n\t\t\t/* FALLTHROUGH */\n\n\t\tcase CONNECTION_STATE_ESTABLISH_KEYS:\n\t\t\tif (!rdp_server_accept_client_info(rdp, s))\n\t\t\t\treturn -1;\n\n\t\t\tIFCALL(client->Capabilities, client);\n\n\t\t\tif (!rdp_send_demand_active(rdp))\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_LICENSE:\n\t\t\tif (!rdp_server_accept_confirm_active(rdp, s))\n\t\t\t{\n\t\t\t\t/**\n\t\t\t\t * During reactivation sequence the client might sent some input or channel data\n\t\t\t\t * before receiving the Deactivate All PDU. We need to process them as usual.\n\t\t\t\t */\n\t\t\t\tStream_SetPosition(s, 0);\n\t\t\t\treturn peer_recv_pdu(client, s);\n\t\t\t}\n\t\t\tbreak;\n\n\t\tcase CONNECTION_STATE_ACTIVE:\n\t\t\tif (peer_recv_pdu(client, s) < 0)\n\t\t\t\treturn -1;\n\t\t\tbreak;\n\n\t\tdefault:\n\t\t\tfprintf(stderr, \"Invalid state %d\\n\", rdp->state);\n\t\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\nstatic BOOL freerdp_peer_close(freerdp_peer* client)\n{\n\t/**\n\t * [MS-RDPBCGR] 1.3.1.4.2 User-Initiated Disconnection Sequence on Server\n\t * The server first sends the client a Deactivate All PDU followed by an\n\t * optional MCS Disconnect Provider Ultimatum PDU.\n\t */\n\tif (!rdp_send_deactivate_all(client->context->rdp))\n\t\treturn FALSE;\n\treturn mcs_send_disconnect_provider_ultimatum(client->context->rdp->mcs);\n}\n\nstatic void freerdp_peer_disconnect(freerdp_peer* client)\n{\n\ttransport_disconnect(client->context->rdp->transport);\n}\n\nstatic int freerdp_peer_send_channel_data(freerdp_peer* client, int channelId, BYTE* data, int size)\n{\n\treturn rdp_send_channel_data(client->context->rdp, channelId, data, size);\n}\n\nvoid freerdp_peer_context_new(freerdp_peer* client)\n{\n\trdpRdp* rdp;\n\n\trdp = rdp_new(NULL);\n\tclient->input = rdp->input;\n\tclient->update = rdp->update;\n\tclient->settings = rdp->settings;\n\n\tclient->context = (rdpContext*) malloc(client->ContextSize);\n\tZeroMemory(client->context, client->ContextSize);\n\n\tclient->context->rdp = rdp;\n\tclient->context->peer = client;\n\tclient->context->input = client->input;\n\tclient->context->update = client->update;\n\tclient->context->settings = client->settings;\n\n\tclient->update->context = client->context;\n\tclient->input->context = client->context;\n\n\tupdate_register_server_callbacks(client->update);\n\n\ttransport_attach(rdp->transport, client->sockfd);\n\n\trdp->transport->ReceiveCallback = peer_recv_callback;\n\trdp->transport->ReceiveExtra = client;\n\ttransport_set_blocking_mode(rdp->transport, FALSE);\n\n\tIFCALL(client->ContextNew, client, client->context);\n}\n\nvoid freerdp_peer_context_free(freerdp_peer* client)\n{\n\tIFCALL(client->ContextFree, client, client->context);\n}\n\nfreerdp_peer* freerdp_peer_new(int sockfd)\n{\n\tfreerdp_peer* client;\n\n\tclient = (freerdp_peer*) malloc(sizeof(freerdp_peer));\n\tZeroMemory(client, sizeof(freerdp_peer));\n\n\tfreerdp_tcp_set_no_delay(sockfd, TRUE);\n\n\tif (client != NULL)\n\t{\n\t\tclient->sockfd = sockfd;\n\t\tclient->ContextSize = sizeof(rdpContext);\n\t\tclient->Initialize = freerdp_peer_initialize;\n\t\tclient->GetFileDescriptor = freerdp_peer_get_fds;\n\t\tclient->CheckFileDescriptor = freerdp_peer_check_fds;\n\t\tclient->Close = freerdp_peer_close;\n\t\tclient->Disconnect = freerdp_peer_disconnect;\n\t\tclient->SendChannelData = freerdp_peer_send_channel_data;\n\t}\n\n\treturn client;\n}\n\nvoid freerdp_peer_free(freerdp_peer* client)\n{\n\tif (client)\n\t{\n\t\trdp_free(client->context->rdp);\n\t\tfree(client->context);\n\t\tfree(client);\n\t}\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Network Transport Layer\n *\n * Copyright 2011 Vic Lee\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <winpr/crt.h>\n#include <winpr/synch.h>\n#include <winpr/print.h>\n\n#include <freerdp/error.h>\n#include <freerdp/utils/tcp.h>\n#include <winpr/stream.h>\n\n#include <time.h>\n#include <errno.h>\n#include <fcntl.h>\n\n#ifndef _WIN32\n#include <netdb.h>\n#include <sys/socket.h>\n#endif\n\n#include \"tpkt.h\"\n#include \"fastpath.h\"\n#include \"transport.h\"\n\n#define BUFFER_SIZE 16384\n\nstatic void* transport_client_thread(void* arg);\n\nwStream* transport_send_stream_init(rdpTransport* transport, int size)\n{\n\twStream* s;\n\n\ts = StreamPool_Take(transport->ReceivePool, size);\n\n\tStream_EnsureCapacity(s, size);\n\tStream_SetPosition(s, 0);\n\n\treturn s;\n}\n\nvoid transport_attach(rdpTransport* transport, int sockfd)\n{\n\ttransport->TcpIn->sockfd = sockfd;\n\n\ttransport->SplitInputOutput = FALSE;\n\ttransport->TcpOut = transport->TcpIn;\n}\n\nBOOL transport_disconnect(rdpTransport* transport)\n{\n\tBOOL status = TRUE;\n\n\tif (transport->layer == TRANSPORT_LAYER_TLS)\n\t\tstatus &= tls_disconnect(transport->TlsIn);\n\n\tif (transport->layer == TRANSPORT_LAYER_TSG)\n\t{\n\t\ttsg_disconnect(transport->tsg);\n\t}\n\telse\n\t{\n\t\tstatus &= tcp_disconnect(transport->TcpIn);\n\t}\n\n\treturn status;\n}\n\nBOOL transport_connect_rdp(rdpTransport* transport)\n{\n\t/* RDP encryption */\n\n\treturn TRUE;\n}\n\nBOOL transport_connect_tls(rdpTransport* transport)\n{\n\tif (transport->layer == TRANSPORT_LAYER_TSG)\n\t\treturn TRUE;\n\n\tif (transport->TlsIn == NULL)\n\t\ttransport->TlsIn = tls_new(transport->settings);\n\n\tif (transport->TlsOut == NULL)\n\t\ttransport->TlsOut = transport->TlsIn;\n\n\ttransport->layer = TRANSPORT_LAYER_TLS;\n\ttransport->TlsIn->sockfd = transport->TcpIn->sockfd;\n\n\tif (tls_connect(transport->TlsIn) != TRUE)\n\t{\n\t\tif (!connectErrorCode)\n\t\t\tconnectErrorCode = TLSCONNECTERROR;\n\n\t\ttls_free(transport->TlsIn);\n\n\t\tif (transport->TlsIn == transport->TlsOut)\n\t\t\ttransport->TlsIn = transport->TlsOut = NULL;\n\t\telse\n\t\t\ttransport->TlsIn = NULL;\n\n\t\treturn FALSE;\n\t}\n\n\treturn TRUE;\n}\n\nBOOL transport_connect_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\n\tif (transport->layer == TRANSPORT_LAYER_TSG)\n\t\treturn TRUE;\n\n\tif (!transport_connect_tls(transport))\n\t\treturn FALSE;\n\n\t/* Network Level Authentication */\n\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tif (!connectErrorCode)\n\t\t\tconnectErrorCode = AUTHENTICATIONERROR;\n\n\t\tfprintf(stderr, \"Authentication failure, check credentials.\\n\"\n\t\t\t\"If credentials are valid, the NTLMSSP implementation may be to blame.\\n\");\n\n\t\tcredssp_free(transport->credssp);\n\t\ttransport->credssp = NULL;\n\t\treturn FALSE;\n\t}\n\n\tcredssp_free(transport->credssp);\n\n\treturn TRUE;\n}\n\nBOOL transport_tsg_connect(rdpTransport* transport, const char* hostname, UINT16 port)\n{\n\trdpTsg* tsg = tsg_new(transport);\n\n\ttsg->transport = transport;\n\ttransport->tsg = tsg;\n\ttransport->SplitInputOutput = TRUE;\n\n\tif (transport->TlsIn == NULL)\n\t\ttransport->TlsIn = tls_new(transport->settings);\n\n\ttransport->TlsIn->sockfd = transport->TcpIn->sockfd;\n\n\tif (transport->TlsOut == NULL)\n\t\ttransport->TlsOut = tls_new(transport->settings);\n\n\ttransport->TlsOut->sockfd = transport->TcpOut->sockfd;\n\n\tif (tls_connect(transport->TlsIn) != TRUE)\n\t\treturn FALSE;\n\n\tif (tls_connect(transport->TlsOut) != TRUE)\n\t\treturn FALSE;\n\n\tif (!tsg_connect(tsg, hostname, port))\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nBOOL transport_connect(rdpTransport* transport, const char* hostname, UINT16 port)\n{\n\tBOOL status = FALSE;\n\trdpSettings* settings = transport->settings;\n\n\ttransport->async = transport->settings->AsyncTransport;\n\n\tif (transport->async)\n\t{\n\t\ttransport->stopEvent = CreateEvent(NULL, TRUE, FALSE, NULL);\n\n\t\ttransport->thread = CreateThread(NULL, 0,\n\t\t\t\t(LPTHREAD_START_ROUTINE) transport_client_thread, transport, 0, NULL);\n\t}\n\n\tif (transport->settings->GatewayUsageMethod)\n\t{\n\t\ttransport->layer = TRANSPORT_LAYER_TSG;\n\t\ttransport->TcpOut = tcp_new(settings);\n\n\t\tstatus = tcp_connect(transport->TcpIn, settings->GatewayHostname, 443);\n\n\t\tif (status)\n\t\t\tstatus = tcp_connect(transport->TcpOut, settings->GatewayHostname, 443);\n\n\t\tif (status)\n\t\t\tstatus = transport_tsg_connect(transport, hostname, port);\n\t}\n\telse\n\t{\n\t\tstatus = tcp_connect(transport->TcpIn, hostname, port);\n\n\t\ttransport->SplitInputOutput = FALSE;\n\t\ttransport->TcpOut = transport->TcpIn;\n\t}\n\n\treturn status;\n}\n\nBOOL transport_accept_rdp(rdpTransport* transport)\n{\n\t/* RDP encryption */\n\n\treturn TRUE;\n}\n\nBOOL transport_accept_tls(rdpTransport* transport)\n{\n\tif (transport->TlsIn == NULL)\n\t\ttransport->TlsIn = tls_new(transport->settings);\n\n\tif (transport->TlsOut == NULL)\n\t\ttransport->TlsOut = transport->TlsIn;\n\n\ttransport->layer = TRANSPORT_LAYER_TLS;\n\ttransport->TlsIn->sockfd = transport->TcpIn->sockfd;\n\n\tif (tls_accept(transport->TlsIn, transport->settings->CertificateFile, transport->settings->PrivateKeyFile) != TRUE)\n\t\treturn FALSE;\n\n\treturn TRUE;\n}\n\nBOOL transport_accept_nla(rdpTransport* transport)\n{\n\tfreerdp* instance;\n\trdpSettings* settings;\n\n\tif (transport->TlsIn == NULL)\n\t\ttransport->TlsIn = tls_new(transport->settings);\n\n\tif (transport->TlsOut == NULL)\n\t\ttransport->TlsOut = transport->TlsIn;\n\n\ttransport->layer = TRANSPORT_LAYER_TLS;\n\ttransport->TlsIn->sockfd = transport->TcpIn->sockfd;\n\n\tif (tls_accept(transport->TlsIn, transport->settings->CertificateFile, transport->settings->PrivateKeyFile) != TRUE)\n\t\treturn FALSE;\n\n\t/* Network Level Authentication */\n\n\tif (transport->settings->Authentication != TRUE)\n\t\treturn TRUE;\n\n\tsettings = transport->settings;\n\tinstance = (freerdp*) settings->instance;\n\n\tif (transport->credssp == NULL)\n\t\ttransport->credssp = credssp_new(instance, transport, settings);\n\n\tif (credssp_authenticate(transport->credssp) < 0)\n\t{\n\t\tfprintf(stderr, \"client authentication failure\\n\");\n\t\tcredssp_free(transport->credssp);\n\t\ttransport->credssp = NULL;\n\t\treturn FALSE;\n\t}\n\n\t/* don't free credssp module yet, we need to copy the credentials from it first */\n\n\treturn TRUE;\n}\n\nBOOL nla_verify_header(wStream* s)\n{\n\tif ((s->pointer[0] == 0x30) && (s->pointer[1] & 0x80))\n\t\treturn TRUE;\n\n\treturn FALSE;\n}\n\nUINT32 nla_read_header(wStream* s)\n{\n\tUINT32 length = 0;\n\n\tif (s->pointer[1] & 0x80)\n\t{\n\t\tif ((s->pointer[1] & ~(0x80)) == 1)\n\t\t{\n\t\t\tlength = s->pointer[2];\n\t\t\tlength += 3;\n\t\t\tStream_Seek(s, 3);\n\t\t}\n\t\telse if ((s->pointer[1] & ~(0x80)) == 2)\n\t\t{\n\t\t\tlength = (s->pointer[2] << 8) | s->pointer[3];\n\t\t\tlength += 4;\n\t\t\tStream_Seek(s, 4);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfprintf(stderr, \"Error reading TSRequest!\\n\");\n\t\t}\n\t}\n\telse\n\t{\n\t\tlength = s->pointer[1];\n\t\tlength += 2;\n\t\tStream_Seek(s, 2);\n\t}\n\n\treturn length;\n}\n\nUINT32 nla_header_length(wStream* s)\n{\n\tUINT32 length = 0;\n\n\tif (s->pointer[1] & 0x80)\n\t{\n\t\tif ((s->pointer[1] & ~(0x80)) == 1)\n\t\t\tlength = 3;\n\t\telse if ((s->pointer[1] & ~(0x80)) == 2)\n\t\t\tlength = 4;\n\t\telse\n\t\t\tfprintf(stderr, \"Error reading TSRequest!\\n\");\n\t}\n\telse\n\t{\n\t\tlength = 2;\n\t}\n\n\treturn length;\n}\n\nint transport_read_layer(rdpTransport* transport, UINT8* data, int bytes)\n{\n\tint read = 0;\n\tint status = -1;\n\n\twhile (read < bytes)\n\t{\n\t\tif (transport->layer == TRANSPORT_LAYER_TLS)\n\t\t\tstatus = tls_read(transport->TlsIn, data + read, bytes - read);\n\t\telse if (transport->layer == TRANSPORT_LAYER_TCP)\n\t\t\tstatus = tcp_read(transport->TcpIn, data + read, bytes - read);\n\t\telse if (transport->layer == TRANSPORT_LAYER_TSG)\n\t\t\tstatus = tsg_read(transport->tsg, data + read, bytes - read);\n\n\t\t/* blocking means that we can't continue until this is read */\n\n\t\tif (!transport->blocking)\n\t\t\treturn status;\n\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\tread += status;\n\n\t\tif (status == 0)\n\t\t{\n\t\t\t/*\n\t\t\t * instead of sleeping, we should wait timeout on the\n\t\t\t * socket but this only happens on initial connection\n\t\t\t */\n\t\t\tUSleep(transport->SleepInterval);\n\t\t}\n\t}\n\n\treturn read;\n}\n\nint transport_read(rdpTransport* transport, wStream* s)\n{\n\tint status;\n\tint pduLength;\n\tint streamPosition;\n\tint transport_status;\n\n\tpduLength = 0;\n\ttransport_status = 0;\n\n\t/* first check if we have header */\n\tstreamPosition = Stream_GetPosition(s);\n\n\tif (streamPosition < 4)\n\t{\n\t\tstatus = transport_read_layer(transport, Stream_Buffer(s) + streamPosition, 4 - streamPosition);\n\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\ttransport_status += status;\n\n\t\tif ((status + streamPosition) < 4)\n\t\t\treturn transport_status;\n\n\t\tstreamPosition += status;\n\t}\n\n\t/* if header is present, read in exactly one PDU */\n\tif (s->buffer[0] == 0x03)\n\t{\n\t\t/* TPKT header */\n\n\t\tpduLength = (s->buffer[2] << 8) | s->buffer[3];\n\t}\n\telse if (s->buffer[0] == 0x30)\n\t{\n\t\t/* TSRequest (NLA) */\n\n\t\tif (s->buffer[1] & 0x80)\n\t\t{\n\t\t\tif ((s->buffer[1] & ~(0x80)) == 1)\n\t\t\t{\n\t\t\t\tpduLength = s->buffer[2];\n\t\t\t\tpduLength += 3;\n\t\t\t}\n\t\t\telse if ((s->buffer[1] & ~(0x80)) == 2)\n\t\t\t{\n\t\t\t\tpduLength = (s->buffer[2] << 8) | s->buffer[3];\n\t\t\t\tpduLength += 4;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfprintf(stderr, \"Error reading TSRequest!\\n\");\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpduLength = s->buffer[1];\n\t\t\tpduLength += 2;\n\t\t}\n\t}\n\telse\n\t{\n\t\t/* Fast-Path Header */\n\n\t\tif (s->buffer[1] & 0x80)\n\t\t\tpduLength = ((s->buffer[1] & 0x7F) << 8) | s->buffer[2];\n\t\telse\n\t\t\tpduLength = s->buffer[1];\n\t}\n\n\tstatus = transport_read_layer(transport, Stream_Buffer(s) + streamPosition, pduLength - streamPosition);\n\n\tif (status < 0)\n\t\treturn status;\n\n\ttransport_status += status;\n\n#ifdef WITH_DEBUG_TRANSPORT\n\t/* dump when whole PDU is read */\n\tif (streamPosition + status >= pduLength)\n\t{\n\t\tfprintf(stderr, \"Local < Remote\\n\");\n\t\twinpr_HexDump(Stream_Buffer(s), pduLength);\n\t}\n#endif\n\n\treturn transport_status;\n}\n\nstatic int transport_read_nonblocking(rdpTransport* transport)\n{\n\tint status;\n\n\tstatus = transport_read(transport, transport->ReceiveBuffer);\n\n\tif (status <= 0)\n\t\treturn status;\n\n\tStream_Seek(transport->ReceiveBuffer, status);\n\n\treturn status;\n}\n\nint transport_write(rdpTransport* transport, wStream* s)\n{\n\tint length;\n\tint status = -1;\n\n\tWaitForSingleObject(transport->WriteMutex, INFINITE);\n\n\tlength = Stream_GetPosition(s);\n\tStream_SetPosition(s, 0);\n\n#ifdef WITH_DEBUG_TRANSPORT\n\tif (length > 0)\n\t{\n\t\tfprintf(stderr, \"Local > Remote\\n\");\n\t\twinpr_HexDump(Stream_Buffer(s), length);\n\t}\n#endif\n\n\twhile (length > 0)\n\t{\n\t\tif (transport->layer == TRANSPORT_LAYER_TLS)\n\t\t\tstatus = tls_write(transport->TlsOut, Stream_Pointer(s), length);\n\t\telse if (transport->layer == TRANSPORT_LAYER_TCP)\n\t\t\tstatus = tcp_write(transport->TcpOut, Stream_Pointer(s), length);\n\t\telse if (transport->layer == TRANSPORT_LAYER_TSG)\n\t\t\tstatus = tsg_write(transport->tsg, Stream_Pointer(s), length);\n\n\t\tif (status < 0)\n\t\t\tbreak; /* error occurred */\n\n\t\tif (status == 0)\n\t\t{\n\t\t\t/* when sending is blocked in nonblocking mode, the receiving buffer should be checked */\n\t\t\tif (!transport->blocking)\n\t\t\t{\n\t\t\t\t/* and in case we do have buffered some data, we set the event so next loop will get it */\n\t\t\t\tif (transport_read_nonblocking(transport) > 0)\n\t\t\t\t\tSetEvent(transport->ReceiveEvent);\n\t\t\t}\n\n\t\t\tif (transport->layer == TRANSPORT_LAYER_TLS)\n\t\t\t\ttls_wait_write(transport->TlsOut);\n\t\t\telse if (transport->layer == TRANSPORT_LAYER_TCP)\n\t\t\t\ttcp_wait_write(transport->TcpOut);\n\t\t\telse\n\t\t\t\tUSleep(transport->SleepInterval);\n\t\t}\n\n\t\tlength -= status;\n\t\tStream_Seek(s, status);\n\t}\n\n\tif (status < 0)\n\t{\n\t\t/* A write error indicates that the peer has dropped the connection */\n\t\ttransport->layer = TRANSPORT_LAYER_CLOSED;\n\t}\n\n\tif (s->pool)\n\t\tStream_Release(s);\n\n\tReleaseMutex(transport->WriteMutex);\n\n\treturn status;\n}\n\n\nvoid transport_get_fds(rdpTransport* transport, void** rfds, int* rcount)\n{\n\tvoid* pfd;\n\n#ifdef _WIN32\n\trfds[*rcount] = transport->TcpIn->wsa_event;\n\t(*rcount)++;\n\n\tif (transport->SplitInputOutput)\n\t{\n\t\trfds[*rcount] = transport->TcpOut->wsa_event;\n\t\t(*rcount)++;\n\t}\n#else\n\trfds[*rcount] = (void*)(long)(transport->TcpIn->sockfd);\n\t(*rcount)++;\n\n\tif (transport->SplitInputOutput)\n\t{\n\t\trfds[*rcount] = (void*)(long)(transport->TcpOut->sockfd);\n\t\t(*rcount)++;\n\t}\n#endif\n\n\tpfd = GetEventWaitObject(transport->ReceiveEvent);\n\n\tif (pfd)\n\t{\n\t\trfds[*rcount] = pfd;\n\t\t(*rcount)++;\n\t}\n\n\tif (transport->GatewayEvent)\n\t{\n\t\tpfd = GetEventWaitObject(transport->GatewayEvent);\n\n\t\tif (pfd)\n\t\t{\n\t\t\trfds[*rcount] = pfd;\n\t\t\t(*rcount)++;\n\t\t}\n\t}\n}\n\nvoid transport_get_read_handles(rdpTransport* transport, HANDLE* events, DWORD* count)\n{\n\tevents[*count] = tcp_get_event_handle(transport->TcpIn);\n\t(*count)++;\n\n\tif (transport->SplitInputOutput)\n\t{\n\t\tevents[*count] = tcp_get_event_handle(transport->TcpOut);\n\t\t(*count)++;\n\t}\n\n\tif (transport->ReceiveEvent)\n\t{\n\t\tevents[*count] = transport->ReceiveEvent;\n\t\t(*count)++;\n\t}\n\n\tif (transport->GatewayEvent)\n\t{\n\t\tevents[*count] = transport->GatewayEvent;\n\t\t(*count)++;\n\t}\n}\n\nint transport_check_fds(rdpTransport** ptransport)\n{\n\tint pos;\n\tint status;\n\tUINT16 length;\n\tint recv_status;\n\twStream* received;\n\trdpTransport* transport = *ptransport;\n\n#ifdef _WIN32\n\tWSAResetEvent(transport->TcpIn->wsa_event);\n#endif\n\tResetEvent(transport->ReceiveEvent);\n\n\tstatus = transport_read_nonblocking(transport);\n\n\tif (status < 0)\n\t\treturn status;\n\n\twhile ((pos = Stream_GetPosition(transport->ReceiveBuffer)) > 0)\n\t{\n\t\tStream_SetPosition(transport->ReceiveBuffer, 0);\n\n\t\tif (tpkt_verify_header(transport->ReceiveBuffer)) /* TPKT */\n\t\t{\n\t\t\t/* Ensure the TPKT header is available. */\n\t\t\tif (pos <= 4)\n\t\t\t{\n\t\t\t\tStream_SetPosition(transport->ReceiveBuffer, pos);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tlength = tpkt_read_header(transport->ReceiveBuffer);\n\t\t}\n\t\telse if (nla_verify_header(transport->ReceiveBuffer))\n\t\t{\n\t\t\t/* TSRequest */\n\n\t\t\t/* Ensure the TSRequest header is available. */\n\t\t\tif (pos <= 4)\n\t\t\t{\n\t\t\t\tStream_SetPosition(transport->ReceiveBuffer, pos);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* TSRequest header can be 2, 3 or 4 bytes long */\n\t\t\tlength = nla_header_length(transport->ReceiveBuffer);\n\n\t\t\tif (pos < length)\n\t\t\t{\n\t\t\t\tStream_SetPosition(transport->ReceiveBuffer, pos);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tlength = nla_read_header(transport->ReceiveBuffer);\n\t\t}\n\t\telse /* Fast Path */\n\t\t{\n\t\t\t/* Ensure the Fast Path header is available. */\n\t\t\tif (pos <= 2)\n\t\t\t{\n\t\t\t\tStream_SetPosition(transport->ReceiveBuffer, pos);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t/* Fastpath header can be two or three bytes long. */\n\t\t\tlength = fastpath_header_length(transport->ReceiveBuffer);\n\n\t\t\tif (pos < length)\n\t\t\t{\n\t\t\t\tStream_SetPosition(transport->ReceiveBuffer, pos);\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tlength = fastpath_read_header(NULL, transport->ReceiveBuffer);\n\t\t}\n\n\t\tif (length == 0)\n\t\t{\n\t\t\tfprintf(stderr, \"transport_check_fds: protocol error, not a TPKT or Fast Path header.\\n\");\n\t\t\twinpr_HexDump(Stream_Buffer(transport->ReceiveBuffer), pos);\n\t\t\treturn -1;\n\t\t}\n\n\t\tif (pos < length)\n\t\t{\n\t\t\tStream_SetPosition(transport->ReceiveBuffer, pos);\n\t\t\treturn 0; /* Packet is not yet completely received. */\n\t\t}\n\n\t\treceived = transport->ReceiveBuffer;\n\t\ttransport->ReceiveBuffer = StreamPool_Take(transport->ReceivePool, 0);\n\n\t\tStream_SetPosition(received, length);\n\t\tStream_SealLength(received);\n\t\tStream_SetPosition(received, 0);\n\n\t\trecv_status = transport->ReceiveCallback(transport, received, transport->ReceiveExtra);\n\n\t\tStream_Release(received);\n\n\t\tif (recv_status < 0)\n\t\t\tstatus = -1;\n\n\t\tif (status < 0)\n\t\t\treturn status;\n\n\t\t/* transport might now have been freed by rdp_client_redirect and a new rdp->transport created */\n\t\ttransport = *ptransport;\n\t}\n\n\treturn 0;\n}\n\nBOOL transport_set_blocking_mode(rdpTransport* transport, BOOL blocking)\n{\n\tBOOL status;\n\n\tstatus = TRUE;\n\ttransport->blocking = blocking;\n\n\tif (transport->SplitInputOutput)\n\t{\n\t\tstatus &= tcp_set_blocking_mode(transport->TcpIn, blocking);\n\t\tstatus &= tcp_set_blocking_mode(transport->TcpOut, blocking);\n\t}\n\telse\n\t{\n\t\tstatus &= tcp_set_blocking_mode(transport->TcpIn, blocking);\n\t}\n\n\tif (transport->layer == TRANSPORT_LAYER_TSG)\n\t{\n\t\ttsg_set_blocking_mode(transport->tsg, blocking);\n\t}\n\n\treturn status;\n}\n\nstatic void* transport_client_thread(void* arg)\n{\n\tDWORD status;\n\tDWORD nCount;\n\tHANDLE events[32];\n\tfreerdp* instance;\n\trdpContext* context;\n\trdpTransport* transport;\n\tTerminateEventArgs e;\n\n\ttransport = (rdpTransport*) arg;\n\tinstance = (freerdp*) transport->settings->instance;\n\tcontext = instance->context;\n\n\twhile (1)\n\t{\n\t\tnCount = 0;\n\t\tevents[nCount++] = transport->stopEvent;\n\t\tevents[nCount] = transport->connectedEvent;\n\n\t\tstatus = WaitForMultipleObjects(nCount + 1, events, FALSE, INFINITE);\n\n\t\tif (WaitForSingleObject(transport->stopEvent, 0) == WAIT_OBJECT_0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\ttransport_get_read_handles(transport, (HANDLE*) &events, &nCount);\n\n\t\tstatus = WaitForMultipleObjects(nCount, events, FALSE, INFINITE);\n\n\t\tif (WaitForSingleObject(transport->stopEvent, 0) == WAIT_OBJECT_0)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tif (!freerdp_check_fds(instance))\n\t\t\tbreak;\n\t}\n\n\treturn NULL;\n}\n\nrdpTransport* transport_new(rdpSettings* settings)\n{\n\trdpTransport* transport;\n\n\ttransport = (rdpTransport*) malloc(sizeof(rdpTransport));\n\n\tif (transport != NULL)\n\t{\n\t\tZeroMemory(transport, sizeof(rdpTransport));\n\n\t\ttransport->TcpIn = tcp_new(settings);\n\n\t\ttransport->settings = settings;\n\n\t\t/* a small 0.1ms delay when transport is blocking. */\n\t\ttransport->SleepInterval = 100;\n\n\t\ttransport->ReceivePool = StreamPool_New(TRUE, BUFFER_SIZE);\n\n\t\t/* receive buffer for non-blocking read. */\n\t\ttransport->ReceiveBuffer = StreamPool_Take(transport->ReceivePool, 0);\n\t\ttransport->ReceiveEvent = CreateEvent(NULL, TRUE, FALSE, NULL);\n\n\t\ttransport->connectedEvent = CreateEvent(NULL, TRUE, FALSE, NULL);\n\n\t\ttransport->blocking = TRUE;\n\n\t\ttransport->ReadMutex = CreateMutex(NULL, FALSE, NULL);\n\t\ttransport->WriteMutex = CreateMutex(NULL, FALSE, NULL);\n\n\t\ttransport->layer = TRANSPORT_LAYER_TCP;\n\t}\n\n\treturn transport;\n}\n\nvoid transport_free(rdpTransport* transport)\n{\n\tif (transport != NULL)\n\t{\n        SetEvent(transport->stopEvent);\n        \n\t\tif (transport->ReceiveBuffer)\n\t\t\tStream_Release(transport->ReceiveBuffer);\n\n\t\tStreamPool_Free(transport->ReceivePool);\n\n\t\tCloseHandle(transport->ReceiveEvent);\n\t\tCloseHandle(transport->connectedEvent);\n\n\t\tif (transport->TlsIn)\n\t\t\ttls_free(transport->TlsIn);\n\n\t\tif (transport->TlsOut != transport->TlsIn)\n\t\t\ttls_free(transport->TlsOut);\n\n\t\ttcp_free(transport->TcpIn);\n\n\t\tif (transport->TcpOut != transport->TcpIn)\n\t\t\ttcp_free(transport->TcpOut);\n\n\t\ttsg_free(transport->tsg);\n\n\t\tCloseHandle(transport->ReadMutex);\n\t\tCloseHandle(transport->WriteMutex);\n\n\t\tfree(transport);\n\t}\n}\n", "/**\n * FreeRDP: A Remote Desktop Protocol Implementation\n * Security Support Provider Interface (SSPI)\n *\n * Copyright 2012 Marc-Andre Moreau <marcandre.moreau@gmail.com>\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef HAVE_CONFIG_H\n#include \"config.h\"\n#endif\n\n#include <stdlib.h>\n\n#include <winpr/windows.h>\n\n#include <winpr/crt.h>\n#include <winpr/sspi.h>\n#include <winpr/print.h>\n\n#include <openssl/ssl.h>\n#include <openssl/err.h>\n\n#include \"sspi.h\"\n\n/* Authentication Functions: http://msdn.microsoft.com/en-us/library/windows/desktop/aa374731/ */\n\n#ifdef WINPR_SSPI\n\nextern const SecPkgInfoA NTLM_SecPkgInfoA;\nextern const SecPkgInfoW NTLM_SecPkgInfoW;\nextern const SecurityFunctionTableA NTLM_SecurityFunctionTableA;\nextern const SecurityFunctionTableW NTLM_SecurityFunctionTableW;\n\nextern const SecPkgInfoA CREDSSP_SecPkgInfoA;\nextern const SecPkgInfoW CREDSSP_SecPkgInfoW;\nextern const SecurityFunctionTableA CREDSSP_SecurityFunctionTableA;\nextern const SecurityFunctionTableW CREDSSP_SecurityFunctionTableW;\n\nextern const SecPkgInfoA SCHANNEL_SecPkgInfoA;\nextern const SecPkgInfoW SCHANNEL_SecPkgInfoW;\nextern const SecurityFunctionTableA SCHANNEL_SecurityFunctionTableA;\nextern const SecurityFunctionTableW SCHANNEL_SecurityFunctionTableW;\n\nconst SecPkgInfoA* SecPkgInfoA_LIST[] =\n{\n\t&NTLM_SecPkgInfoA,\n\t&CREDSSP_SecPkgInfoA,\n\t&SCHANNEL_SecPkgInfoA\n};\n\nconst SecPkgInfoW* SecPkgInfoW_LIST[] =\n{\n\t&NTLM_SecPkgInfoW,\n\t&CREDSSP_SecPkgInfoW,\n\t&SCHANNEL_SecPkgInfoW\n};\n\nSecurityFunctionTableA SSPI_SecurityFunctionTableA;\nSecurityFunctionTableW SSPI_SecurityFunctionTableW;\n\nstruct _SecurityFunctionTableA_NAME\n{\n\tSEC_CHAR* Name;\n\tconst SecurityFunctionTableA* SecurityFunctionTable;\n};\ntypedef struct _SecurityFunctionTableA_NAME SecurityFunctionTableA_NAME;\n\nstruct _SecurityFunctionTableW_NAME\n{\n\tSEC_WCHAR* Name;\n\tconst SecurityFunctionTableW* SecurityFunctionTable;\n};\ntypedef struct _SecurityFunctionTableW_NAME SecurityFunctionTableW_NAME;\n\nconst SecurityFunctionTableA_NAME SecurityFunctionTableA_NAME_LIST[] =\n{\n\t{ \"NTLM\", &NTLM_SecurityFunctionTableA },\n\t{ \"CREDSSP\", &CREDSSP_SecurityFunctionTableA },\n\t{ \"Schannel\", &SCHANNEL_SecurityFunctionTableA }\n};\n\nWCHAR NTLM_NAME_W[] = { 'N','T','L','M','\\0' };\nWCHAR CREDSSP_NAME_W[] = { 'C','r','e','d','S','S','P','\\0' };\nWCHAR SCHANNEL_NAME_W[] = { 'S','c','h','a','n','n','e','l','\\0' };\n\nconst SecurityFunctionTableW_NAME SecurityFunctionTableW_NAME_LIST[] =\n{\n\t{ NTLM_NAME_W, &NTLM_SecurityFunctionTableW },\n\t{ CREDSSP_NAME_W, &CREDSSP_SecurityFunctionTableW },\n\t{ SCHANNEL_NAME_W, &SCHANNEL_SecurityFunctionTableW }\n};\n\n#endif\n\n#define SecHandle_LOWER_MAX\t0xFFFFFFFF\n#define SecHandle_UPPER_MAX\t0xFFFFFFFE\n\nstruct _CONTEXT_BUFFER_ALLOC_ENTRY\n{\n\tvoid* contextBuffer;\n\tUINT32 allocatorIndex;\n};\ntypedef struct _CONTEXT_BUFFER_ALLOC_ENTRY CONTEXT_BUFFER_ALLOC_ENTRY;\n\nstruct _CONTEXT_BUFFER_ALLOC_TABLE\n{\n\tUINT32 cEntries;\n\tUINT32 cMaxEntries;\n\tCONTEXT_BUFFER_ALLOC_ENTRY* entries;\n};\ntypedef struct _CONTEXT_BUFFER_ALLOC_TABLE CONTEXT_BUFFER_ALLOC_TABLE;\n\nCONTEXT_BUFFER_ALLOC_TABLE ContextBufferAllocTable;\n\nvoid sspi_ContextBufferAllocTableNew()\n{\n\tsize_t size;\n\n\tContextBufferAllocTable.cEntries = 0;\n\tContextBufferAllocTable.cMaxEntries = 4;\n\n\tsize = sizeof(CONTEXT_BUFFER_ALLOC_ENTRY) * ContextBufferAllocTable.cMaxEntries;\n\n\tContextBufferAllocTable.entries = malloc(size);\n\tZeroMemory(ContextBufferAllocTable.entries, size);\n}\n\nvoid sspi_ContextBufferAllocTableGrow()\n{\n\tsize_t size;\n\tContextBufferAllocTable.cEntries = 0;\n\tContextBufferAllocTable.cMaxEntries *= 2;\n\n\tsize = sizeof(CONTEXT_BUFFER_ALLOC_ENTRY) * ContextBufferAllocTable.cMaxEntries;\n\n\tContextBufferAllocTable.entries = realloc(ContextBufferAllocTable.entries, size);\n\tZeroMemory((void*) &ContextBufferAllocTable.entries[ContextBufferAllocTable.cMaxEntries / 2], size / 2);\n}\n\nvoid sspi_ContextBufferAllocTableFree()\n{\n\tContextBufferAllocTable.cEntries = ContextBufferAllocTable.cMaxEntries = 0;\n\tfree(ContextBufferAllocTable.entries);\n}\n\nvoid* sspi_ContextBufferAlloc(UINT32 allocatorIndex, size_t size)\n{\n\tint index;\n\tvoid* contextBuffer;\n\n\tfor (index = 0; index < (int) ContextBufferAllocTable.cMaxEntries; index++)\n\t{\n\t\tif (ContextBufferAllocTable.entries[index].contextBuffer == NULL)\n\t\t{\n\t\t\tcontextBuffer = malloc(size);\n\t\t\tZeroMemory(contextBuffer, size);\n\t\t\tContextBufferAllocTable.cEntries++;\n\n\t\t\tContextBufferAllocTable.entries[index].contextBuffer = contextBuffer;\n\t\t\tContextBufferAllocTable.entries[index].allocatorIndex = allocatorIndex;\n\n\t\t\treturn ContextBufferAllocTable.entries[index].contextBuffer;\n\t\t}\n\t}\n\n\t/* no available entry was found, the table needs to be grown */\n\n\tsspi_ContextBufferAllocTableGrow();\n\n\t/* the next call to sspi_ContextBufferAlloc() should now succeed */\n\n\treturn sspi_ContextBufferAlloc(allocatorIndex, size);\n}\n\nCREDENTIALS* sspi_CredentialsNew()\n{\n\tCREDENTIALS* credentials;\n\n\tcredentials = (CREDENTIALS*) malloc(sizeof(CREDENTIALS));\n\tZeroMemory(credentials, sizeof(CREDENTIALS));\n\n\tif (credentials != NULL)\n\t{\n\n\t}\n\n\treturn credentials;\n}\n\nvoid sspi_CredentialsFree(CREDENTIALS* credentials)\n{\n\tif (!credentials)\n\t\treturn;\n\n\tfree(credentials);\n}\n\nvoid sspi_SecBufferAlloc(PSecBuffer SecBuffer, size_t size)\n{\n\tSecBuffer->cbBuffer = size;\n\tSecBuffer->pvBuffer = malloc(size);\n\tZeroMemory(SecBuffer->pvBuffer, SecBuffer->cbBuffer);\n}\n\nvoid sspi_SecBufferFree(PSecBuffer SecBuffer)\n{\n\tfree(SecBuffer->pvBuffer);\n\tSecBuffer->pvBuffer = NULL;\n\tSecBuffer->cbBuffer = 0;\n}\n\nSecHandle* sspi_SecureHandleAlloc()\n{\n\tSecHandle* handle = (SecHandle*) malloc(sizeof(SecHandle));\n\tsspi_SecureHandleInit(handle);\n\treturn handle;\n}\n\nvoid sspi_SecureHandleInit(SecHandle* handle)\n{\n\tif (!handle)\n\t\treturn;\n\n\tmemset(handle, 0xFF, sizeof(SecHandle));\n}\n\nvoid sspi_SecureHandleInvalidate(SecHandle* handle)\n{\n\tif (!handle)\n\t\treturn;\n\n\tsspi_SecureHandleInit(handle);\n}\n\nvoid* sspi_SecureHandleGetLowerPointer(SecHandle* handle)\n{\n\tvoid* pointer;\n\n\tif (!handle || !SecIsValidHandle(handle))\n\t\treturn NULL;\n\n\tpointer = (void*) ~((size_t) handle->dwLower);\n\n\treturn pointer;\n}\n\nvoid sspi_SecureHandleSetLowerPointer(SecHandle* handle, void* pointer)\n{\n\tif (!handle)\n\t\treturn;\n\n\thandle->dwLower = (ULONG_PTR) (~((size_t) pointer));\n}\n\nvoid* sspi_SecureHandleGetUpperPointer(SecHandle* handle)\n{\n\tvoid* pointer;\n\n\tif (!handle || !SecIsValidHandle(handle))\n\t\treturn NULL;\n\n\tpointer = (void*) ~((size_t) handle->dwUpper);\n\n\treturn pointer;\n}\n\nvoid sspi_SecureHandleSetUpperPointer(SecHandle* handle, void* pointer)\n{\n\tif (!handle)\n\t\treturn;\n\n\thandle->dwUpper = (ULONG_PTR) (~((size_t) pointer));\n}\n\nvoid sspi_SecureHandleFree(SecHandle* handle)\n{\n\tif (!handle)\n\t\treturn;\n\n\tfree(handle);\n}\n\nvoid sspi_SetAuthIdentity(SEC_WINNT_AUTH_IDENTITY* identity, char* user, char* domain, char* password)\n{\n\tidentity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;\n\n\tif (user)\n\t{\n\t\tidentity->UserLength = ConvertToUnicode(CP_UTF8, 0, user, -1, &identity->User, 0) - 1;\n\t}\n\telse\n\t{\n\t\tidentity->User = (UINT16*) NULL;\n\t\tidentity->UserLength = 0;\n\t}\n\n\tif (domain)\n\t{\n\t\tidentity->DomainLength = ConvertToUnicode(CP_UTF8, 0, domain, -1, &identity->Domain, 0) - 1;\n\t}\n\telse\n\t{\n\t\tidentity->Domain = (UINT16*) NULL;\n\t\tidentity->DomainLength = 0;\n\t}\n\n\tif (password != NULL)\n\t{\n\t\tidentity->PasswordLength = ConvertToUnicode(CP_UTF8, 0, password, -1, &identity->Password, 0) - 1;\n\t}\n\telse\n\t{\n\t\tidentity->Password = NULL;\n\t\tidentity->PasswordLength = 0;\n\t}\n}\n\nvoid sspi_CopyAuthIdentity(SEC_WINNT_AUTH_IDENTITY* identity, SEC_WINNT_AUTH_IDENTITY* srcIdentity)\n{\n\tif (identity->Flags == SEC_WINNT_AUTH_IDENTITY_ANSI)\n\t{\n\t\tsspi_SetAuthIdentity(identity, (char*) srcIdentity->User,\n\t\t\t\t(char*) srcIdentity->Domain, (char*) srcIdentity->Password);\n\n\t\tidentity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;\n\n\t\treturn;\n\t}\n\n\tidentity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;\n\n\tidentity->User = identity->Domain = identity->Password = NULL;\n\n\tidentity->UserLength = srcIdentity->UserLength;\n\n\tif (identity->UserLength > 0)\n\t{\n\t\tidentity->User = (UINT16*) malloc((identity->UserLength + 1) * sizeof(WCHAR));\n\t\tCopyMemory(identity->User, srcIdentity->User, identity->UserLength * sizeof(WCHAR));\n\t\tidentity->User[identity->UserLength] = 0;\n\t}\n\n\tidentity->DomainLength = srcIdentity->DomainLength;\n\n\tif (identity->DomainLength > 0)\n\t{\n\t\tidentity->Domain = (UINT16*) malloc((identity->DomainLength + 1) * sizeof(WCHAR));\n\t\tCopyMemory(identity->Domain, srcIdentity->Domain, identity->DomainLength * sizeof(WCHAR));\n\t\tidentity->Domain[identity->DomainLength] = 0;\n\t}\n\n\tidentity->PasswordLength = srcIdentity->PasswordLength;\n\n\tif (identity->PasswordLength > 0)\n\t{\n\t\tidentity->Password = (UINT16*) malloc((identity->PasswordLength + 1) * sizeof(WCHAR));\n\t\tCopyMemory(identity->Password, srcIdentity->Password, identity->PasswordLength * sizeof(WCHAR));\n\t\tidentity->Password[identity->PasswordLength] = 0;\n\t}\n}\n\nPSecBuffer sspi_FindSecBuffer(PSecBufferDesc pMessage, ULONG BufferType)\n{\n\tint index;\n\tPSecBuffer pSecBuffer = NULL;\n\n\tfor (index = 0; index < pMessage->cBuffers; index++)\n\t{\n\t\tif (pMessage->pBuffers[index].BufferType == BufferType)\n\t\t{\n\t\t\tpSecBuffer = &pMessage->pBuffers[index];\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn pSecBuffer;\n}\n\nstatic BOOL sspi_initialized = FALSE;\n\nvoid sspi_GlobalInit()\n{\n\tif (!sspi_initialized)\n\t{\n\t\tSSL_load_error_strings();\n\t\tSSL_library_init();\n\n\t\tsspi_ContextBufferAllocTableNew();\n\t\tsspi_initialized = TRUE;\n\t}\n}\n\nvoid sspi_GlobalFinish()\n{\n\tif (sspi_initialized)\n\t{\n\t\tsspi_ContextBufferAllocTableFree();\n\t}\n\n\tsspi_initialized = FALSE;\n}\n\n#ifndef WITH_NATIVE_SSPI\n\nSecurityFunctionTableA* sspi_GetSecurityFunctionTableAByNameA(const SEC_CHAR* Name)\n{\n\tint index;\n\tUINT32 cPackages;\n\n\tcPackages = sizeof(SecPkgInfoA_LIST) / sizeof(*(SecPkgInfoA_LIST));\n\n\tfor (index = 0; index < (int) cPackages; index++)\n\t{\n\t\tif (strcmp(Name, SecurityFunctionTableA_NAME_LIST[index].Name) == 0)\n\t\t{\n\t\t\treturn (SecurityFunctionTableA*) SecurityFunctionTableA_NAME_LIST[index].SecurityFunctionTable;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nSecurityFunctionTableA* sspi_GetSecurityFunctionTableAByNameW(const SEC_WCHAR* Name)\n{\n\treturn NULL;\n}\n\nSecurityFunctionTableW* sspi_GetSecurityFunctionTableWByNameW(const SEC_WCHAR* Name)\n{\n\tint index;\n\tUINT32 cPackages;\n\n\tcPackages = sizeof(SecPkgInfoW_LIST) / sizeof(*(SecPkgInfoW_LIST));\n\n\tfor (index = 0; index < (int) cPackages; index++)\n\t{\n\t\tif (lstrcmpW(Name, SecurityFunctionTableW_NAME_LIST[index].Name) == 0)\n\t\t{\n\t\t\treturn (SecurityFunctionTableW*) SecurityFunctionTableW_NAME_LIST[index].SecurityFunctionTable;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\nSecurityFunctionTableW* sspi_GetSecurityFunctionTableWByNameA(const SEC_CHAR* Name)\n{\n\tSEC_WCHAR* NameW = NULL;\n\tSecurityFunctionTableW* table;\n\n\tConvertToUnicode(CP_UTF8, 0, Name, -1, &NameW, 0);\n\n\ttable = sspi_GetSecurityFunctionTableWByNameW(NameW);\n\tfree(NameW);\n\n\treturn table;\n}\n\nvoid FreeContextBuffer_EnumerateSecurityPackages(void* contextBuffer);\nvoid FreeContextBuffer_QuerySecurityPackageInfo(void* contextBuffer);\n\nvoid sspi_ContextBufferFree(void* contextBuffer)\n{\n\tint index;\n\tUINT32 allocatorIndex;\n\n\tfor (index = 0; index < (int) ContextBufferAllocTable.cMaxEntries; index++)\n\t{\n\t\tif (contextBuffer == ContextBufferAllocTable.entries[index].contextBuffer)\n\t\t{\n\t\t\tcontextBuffer = ContextBufferAllocTable.entries[index].contextBuffer;\n\t\t\tallocatorIndex = ContextBufferAllocTable.entries[index].allocatorIndex;\n\n\t\t\tContextBufferAllocTable.cEntries--;\n\n\t\t\tContextBufferAllocTable.entries[index].allocatorIndex = 0;\n\t\t\tContextBufferAllocTable.entries[index].contextBuffer = NULL;\n\n\t\t\tswitch (allocatorIndex)\n\t\t\t{\n\t\t\t\tcase EnumerateSecurityPackagesIndex:\n\t\t\t\t\tFreeContextBuffer_EnumerateSecurityPackages(contextBuffer);\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase QuerySecurityPackageInfoIndex:\n\t\t\t\t\tFreeContextBuffer_QuerySecurityPackageInfo(contextBuffer);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* Package Management */\n\nSECURITY_STATUS SEC_ENTRY EnumerateSecurityPackagesW(ULONG* pcPackages, PSecPkgInfoW* ppPackageInfo)\n{\n\tint index;\n\tsize_t size;\n\tUINT32 cPackages;\n\tSecPkgInfoW* pPackageInfo;\n\n\tcPackages = sizeof(SecPkgInfoW_LIST) / sizeof(*(SecPkgInfoW_LIST));\n\tsize = sizeof(SecPkgInfoW) * cPackages;\n\n\tpPackageInfo = (SecPkgInfoW*) sspi_ContextBufferAlloc(EnumerateSecurityPackagesIndex, size);\n\n\tfor (index = 0; index < (int) cPackages; index++)\n\t{\n\t\tpPackageInfo[index].fCapabilities = SecPkgInfoW_LIST[index]->fCapabilities;\n\t\tpPackageInfo[index].wVersion = SecPkgInfoW_LIST[index]->wVersion;\n\t\tpPackageInfo[index].wRPCID = SecPkgInfoW_LIST[index]->wRPCID;\n\t\tpPackageInfo[index].cbMaxToken = SecPkgInfoW_LIST[index]->cbMaxToken;\n\t\tpPackageInfo[index].Name = _wcsdup(SecPkgInfoW_LIST[index]->Name);\n\t\tpPackageInfo[index].Comment = _wcsdup(SecPkgInfoW_LIST[index]->Comment);\n\t}\n\n\t*(pcPackages) = cPackages;\n\t*(ppPackageInfo) = pPackageInfo;\n\n\treturn SEC_E_OK;\n}\n\nSECURITY_STATUS SEC_ENTRY EnumerateSecurityPackagesA(ULONG* pcPackages, PSecPkgInfoA* ppPackageInfo)\n{\n\tint index;\n\tsize_t size;\n\tUINT32 cPackages;\n\tSecPkgInfoA* pPackageInfo;\n\n\tcPackages = sizeof(SecPkgInfoA_LIST) / sizeof(*(SecPkgInfoA_LIST));\n\tsize = sizeof(SecPkgInfoA) * cPackages;\n\n\tpPackageInfo = (SecPkgInfoA*) sspi_ContextBufferAlloc(EnumerateSecurityPackagesIndex, size);\n\n\tfor (index = 0; index < (int) cPackages; index++)\n\t{\n\t\tpPackageInfo[index].fCapabilities = SecPkgInfoA_LIST[index]->fCapabilities;\n\t\tpPackageInfo[index].wVersion = SecPkgInfoA_LIST[index]->wVersion;\n\t\tpPackageInfo[index].wRPCID = SecPkgInfoA_LIST[index]->wRPCID;\n\t\tpPackageInfo[index].cbMaxToken = SecPkgInfoA_LIST[index]->cbMaxToken;\n\t\tpPackageInfo[index].Name = _strdup(SecPkgInfoA_LIST[index]->Name);\n\t\tpPackageInfo[index].Comment = _strdup(SecPkgInfoA_LIST[index]->Comment);\n\t}\n\n\t*(pcPackages) = cPackages;\n\t*(ppPackageInfo) = pPackageInfo;\n\n\treturn SEC_E_OK;\n}\n\nvoid FreeContextBuffer_EnumerateSecurityPackages(void* contextBuffer)\n{\n\tint index;\n\tUINT32 cPackages;\n\tSecPkgInfoA* pPackageInfo = (SecPkgInfoA*) contextBuffer;\n\n\tcPackages = sizeof(SecPkgInfoA_LIST) / sizeof(*(SecPkgInfoA_LIST));\n\n\tfor (index = 0; index < (int) cPackages; index++)\n\t{\n\t\tif (pPackageInfo[index].Name)\n\t\t\tfree(pPackageInfo[index].Name);\n\n\t\tif (pPackageInfo[index].Comment)\n\t\t\tfree(pPackageInfo[index].Comment);\n\t}\n\n\tfree(pPackageInfo);\n}\n\nSecurityFunctionTableW* SEC_ENTRY InitSecurityInterfaceW(void)\n{\n\treturn &SSPI_SecurityFunctionTableW;\n}\n\nSecurityFunctionTableA* SEC_ENTRY InitSecurityInterfaceA(void)\n{\n\treturn &SSPI_SecurityFunctionTableA;\n}\n\nSECURITY_STATUS SEC_ENTRY QuerySecurityPackageInfoW(SEC_WCHAR* pszPackageName, PSecPkgInfoW* ppPackageInfo)\n{\n\tint index;\n\tsize_t size;\n\tUINT32 cPackages;\n\tSecPkgInfoW* pPackageInfo;\n\n\tcPackages = sizeof(SecPkgInfoW_LIST) / sizeof(*(SecPkgInfoW_LIST));\n\n\tfor (index = 0; index < (int) cPackages; index++)\n\t{\n\t\tif (lstrcmpW(pszPackageName, SecPkgInfoW_LIST[index]->Name) == 0)\n\t\t{\n\t\t\tsize = sizeof(SecPkgInfoW);\n\t\t\tpPackageInfo = (SecPkgInfoW*) sspi_ContextBufferAlloc(QuerySecurityPackageInfoIndex, size);\n\n\t\t\tpPackageInfo->fCapabilities = SecPkgInfoW_LIST[index]->fCapabilities;\n\t\t\tpPackageInfo->wVersion = SecPkgInfoW_LIST[index]->wVersion;\n\t\t\tpPackageInfo->wRPCID = SecPkgInfoW_LIST[index]->wRPCID;\n\t\t\tpPackageInfo->cbMaxToken = SecPkgInfoW_LIST[index]->cbMaxToken;\n\t\t\tpPackageInfo->Name = _wcsdup(SecPkgInfoW_LIST[index]->Name);\n\t\t\tpPackageInfo->Comment = _wcsdup(SecPkgInfoW_LIST[index]->Comment);\n\n\t\t\t*(ppPackageInfo) = pPackageInfo;\n\n\t\t\treturn SEC_E_OK;\n\t\t}\n\t}\n\n\t*(ppPackageInfo) = NULL;\n\n\treturn SEC_E_SECPKG_NOT_FOUND;\n}\n\nSECURITY_STATUS SEC_ENTRY QuerySecurityPackageInfoA(SEC_CHAR* pszPackageName, PSecPkgInfoA* ppPackageInfo)\n{\n\tint index;\n\tsize_t size;\n\tUINT32 cPackages;\n\tSecPkgInfoA* pPackageInfo;\n\n\tcPackages = sizeof(SecPkgInfoA_LIST) / sizeof(*(SecPkgInfoA_LIST));\n\n\tfor (index = 0; index < (int) cPackages; index++)\n\t{\n\t\tif (strcmp(pszPackageName, SecPkgInfoA_LIST[index]->Name) == 0)\n\t\t{\n\t\t\tsize = sizeof(SecPkgInfoA);\n\t\t\tpPackageInfo = (SecPkgInfoA*) sspi_ContextBufferAlloc(QuerySecurityPackageInfoIndex, size);\n\n\t\t\tpPackageInfo->fCapabilities = SecPkgInfoA_LIST[index]->fCapabilities;\n\t\t\tpPackageInfo->wVersion = SecPkgInfoA_LIST[index]->wVersion;\n\t\t\tpPackageInfo->wRPCID = SecPkgInfoA_LIST[index]->wRPCID;\n\t\t\tpPackageInfo->cbMaxToken = SecPkgInfoA_LIST[index]->cbMaxToken;\n\t\t\tpPackageInfo->Name = _strdup(SecPkgInfoA_LIST[index]->Name);\n\t\t\tpPackageInfo->Comment = _strdup(SecPkgInfoA_LIST[index]->Comment);\n\n\t\t\t*(ppPackageInfo) = pPackageInfo;\n\n\t\t\treturn SEC_E_OK;\n\t\t}\n\t}\n\n\t*(ppPackageInfo) = NULL;\n\n\treturn SEC_E_SECPKG_NOT_FOUND;\n}\n\nvoid FreeContextBuffer_QuerySecurityPackageInfo(void* contextBuffer)\n{\n\tSecPkgInfo* pPackageInfo = (SecPkgInfo*) contextBuffer;\n\n\tif (pPackageInfo->Name)\n\t\tfree(pPackageInfo->Name);\n\n\tif (pPackageInfo->Comment)\n\t\tfree(pPackageInfo->Comment);\n\n\tfree(pPackageInfo);\n}\n\n/* Credential Management */\n\nSECURITY_STATUS SEC_ENTRY AcquireCredentialsHandleW(SEC_WCHAR* pszPrincipal, SEC_WCHAR* pszPackage,\n\t\tULONG fCredentialUse, void* pvLogonID, void* pAuthData, SEC_GET_KEY_FN pGetKeyFn,\n\t\tvoid* pvGetKeyArgument, PCredHandle phCredential, PTimeStamp ptsExpiry)\n{\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableW* table = sspi_GetSecurityFunctionTableWByNameW(pszPackage);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->AcquireCredentialsHandleW == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->AcquireCredentialsHandleW(pszPrincipal, pszPackage, fCredentialUse,\n\t\t\tpvLogonID, pAuthData, pGetKeyFn, pvGetKeyArgument, phCredential, ptsExpiry);\n\n\treturn status;\n}\n\nSECURITY_STATUS SEC_ENTRY AcquireCredentialsHandleA(SEC_CHAR* pszPrincipal, SEC_CHAR* pszPackage,\n\t\tULONG fCredentialUse, void* pvLogonID, void* pAuthData, SEC_GET_KEY_FN pGetKeyFn,\n\t\tvoid* pvGetKeyArgument, PCredHandle phCredential, PTimeStamp ptsExpiry)\n{\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table = sspi_GetSecurityFunctionTableAByNameA(pszPackage);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->AcquireCredentialsHandleA == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->AcquireCredentialsHandleA(pszPrincipal, pszPackage, fCredentialUse,\n\t\t\tpvLogonID, pAuthData, pGetKeyFn, pvGetKeyArgument, phCredential, ptsExpiry);\n\n\treturn status;\n}\n\nSECURITY_STATUS SEC_ENTRY ExportSecurityContext(PCtxtHandle phContext, ULONG fFlags, PSecBuffer pPackedContext, HANDLE* pToken)\n{\n\treturn SEC_E_OK;\n}\n\nSECURITY_STATUS SEC_ENTRY FreeCredentialsHandle(PCredHandle phCredential)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phCredential);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->FreeCredentialsHandle == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->FreeCredentialsHandle(phCredential);\n\n\treturn status;\n}\n\nSECURITY_STATUS SEC_ENTRY ImportSecurityContextW(SEC_WCHAR* pszPackage, PSecBuffer pPackedContext, HANDLE pToken, PCtxtHandle phContext)\n{\n\treturn SEC_E_OK;\n}\n\nSECURITY_STATUS SEC_ENTRY ImportSecurityContextA(SEC_CHAR* pszPackage, PSecBuffer pPackedContext, HANDLE pToken, PCtxtHandle phContext)\n{\n\treturn SEC_E_OK;\n}\n\nSECURITY_STATUS SEC_ENTRY QueryCredentialsAttributesW(PCredHandle phCredential, ULONG ulAttribute, void* pBuffer)\n{\n\tSEC_WCHAR* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableW* table;\n\n\tName = (SEC_WCHAR*) sspi_SecureHandleGetUpperPointer(phCredential);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableWByNameW(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->QueryCredentialsAttributesW == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->QueryCredentialsAttributesW(phCredential, ulAttribute, pBuffer);\n\n\treturn status;\n}\n\nSECURITY_STATUS SEC_ENTRY QueryCredentialsAttributesA(PCredHandle phCredential, ULONG ulAttribute, void* pBuffer)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phCredential);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->QueryCredentialsAttributesA == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->QueryCredentialsAttributesA(phCredential, ulAttribute, pBuffer);\n\n\treturn status;\n}\n\n/* Context Management */\n\nSECURITY_STATUS SEC_ENTRY AcceptSecurityContext(PCredHandle phCredential, PCtxtHandle phContext,\n\t\tPSecBufferDesc pInput, ULONG fContextReq, ULONG TargetDataRep, PCtxtHandle phNewContext,\n\t\tPSecBufferDesc pOutput, PULONG pfContextAttr, PTimeStamp ptsTimeStamp)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phCredential);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->AcceptSecurityContext == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->AcceptSecurityContext(phCredential, phContext, pInput, fContextReq,\n\t\t\tTargetDataRep, phNewContext, pOutput, pfContextAttr, ptsTimeStamp);\n\n\treturn status;\n}\n\nSECURITY_STATUS SEC_ENTRY ApplyControlToken(PCtxtHandle phContext, PSecBufferDesc pInput)\n{\n\treturn SEC_E_OK;\n}\n\nSECURITY_STATUS SEC_ENTRY CompleteAuthToken(PCtxtHandle phContext, PSecBufferDesc pToken)\n{\n\treturn SEC_E_OK;\n}\n\nSECURITY_STATUS SEC_ENTRY DeleteSecurityContext(PCtxtHandle phContext)\n{\n\tchar* Name = NULL;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phContext);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->DeleteSecurityContext == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->DeleteSecurityContext(phContext);\n\n\treturn status;\n}\n\nSECURITY_STATUS SEC_ENTRY FreeContextBuffer(void* pvContextBuffer)\n{\n\tif (!pvContextBuffer)\n\t\treturn SEC_E_INVALID_HANDLE;\n\n\tsspi_ContextBufferFree(pvContextBuffer);\n\n\treturn SEC_E_OK;\n}\n\nSECURITY_STATUS SEC_ENTRY ImpersonateSecurityContext(PCtxtHandle phContext)\n{\n\treturn SEC_E_OK;\n}\n\nSECURITY_STATUS SEC_ENTRY InitializeSecurityContextW(PCredHandle phCredential, PCtxtHandle phContext,\n\t\tSEC_WCHAR* pszTargetName, ULONG fContextReq, ULONG Reserved1, ULONG TargetDataRep,\n\t\tPSecBufferDesc pInput, ULONG Reserved2, PCtxtHandle phNewContext,\n\t\tPSecBufferDesc pOutput, PULONG pfContextAttr, PTimeStamp ptsExpiry)\n{\n\tSEC_CHAR* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableW* table;\n\n\tName = (SEC_CHAR*) sspi_SecureHandleGetUpperPointer(phCredential);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableWByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->InitializeSecurityContextW == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->InitializeSecurityContextW(phCredential, phContext,\n\t\t\tpszTargetName, fContextReq, Reserved1, TargetDataRep,\n\t\t\tpInput, Reserved2, phNewContext, pOutput, pfContextAttr, ptsExpiry);\n\n\treturn status;\n}\n\nSECURITY_STATUS SEC_ENTRY InitializeSecurityContextA(PCredHandle phCredential, PCtxtHandle phContext,\n\t\tSEC_CHAR* pszTargetName, ULONG fContextReq, ULONG Reserved1, ULONG TargetDataRep,\n\t\tPSecBufferDesc pInput, ULONG Reserved2, PCtxtHandle phNewContext,\n\t\tPSecBufferDesc pOutput, PULONG pfContextAttr, PTimeStamp ptsExpiry)\n{\n\tSEC_CHAR* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (SEC_CHAR*) sspi_SecureHandleGetUpperPointer(phCredential);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->InitializeSecurityContextA == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->InitializeSecurityContextA(phCredential, phContext,\n\t\t\tpszTargetName, fContextReq, Reserved1, TargetDataRep,\n\t\t\tpInput, Reserved2, phNewContext, pOutput, pfContextAttr, ptsExpiry);\n\n\treturn status;\n}\n\nSECURITY_STATUS SEC_ENTRY QueryContextAttributesW(PCtxtHandle phContext, ULONG ulAttribute, void* pBuffer)\n{\n\tSEC_CHAR* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableW* table;\n\n\tName = (SEC_CHAR*) sspi_SecureHandleGetUpperPointer(phContext);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableWByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->QueryContextAttributesW == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->QueryContextAttributesW(phContext, ulAttribute, pBuffer);\n\n\treturn status;\n}\n\nSECURITY_STATUS SEC_ENTRY QueryContextAttributesA(PCtxtHandle phContext, ULONG ulAttribute, void* pBuffer)\n{\n\tSEC_CHAR* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (SEC_CHAR*) sspi_SecureHandleGetUpperPointer(phContext);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->QueryContextAttributesA == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->QueryContextAttributesA(phContext, ulAttribute, pBuffer);\n\n\treturn status;\n}\n\nSECURITY_STATUS SEC_ENTRY QuerySecurityContextToken(PCtxtHandle phContext, HANDLE* phToken)\n{\n\treturn SEC_E_OK;\n}\n\nSECURITY_STATUS SEC_ENTRY SetContextAttributes(PCtxtHandle phContext, ULONG ulAttribute, void* pBuffer, ULONG cbBuffer)\n{\n\treturn SEC_E_OK;\n}\n\nSECURITY_STATUS SEC_ENTRY RevertSecurityContext(PCtxtHandle phContext)\n{\n\treturn SEC_E_OK;\n}\n\n/* Message Support */\n\nSECURITY_STATUS SEC_ENTRY DecryptMessage(PCtxtHandle phContext, PSecBufferDesc pMessage, ULONG MessageSeqNo, PULONG pfQOP)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phContext);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->DecryptMessage == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->DecryptMessage(phContext, pMessage, MessageSeqNo, pfQOP);\n\n\treturn status;\n}\n\nSECURITY_STATUS SEC_ENTRY EncryptMessage(PCtxtHandle phContext, ULONG fQOP, PSecBufferDesc pMessage, ULONG MessageSeqNo)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phContext);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->EncryptMessage == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->EncryptMessage(phContext, fQOP, pMessage, MessageSeqNo);\n\n\treturn status;\n}\n\nSECURITY_STATUS SEC_ENTRY MakeSignature(PCtxtHandle phContext, ULONG fQOP, PSecBufferDesc pMessage, ULONG MessageSeqNo)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phContext);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->MakeSignature == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->MakeSignature(phContext, fQOP, pMessage, MessageSeqNo);\n\n\treturn status;\n}\n\nSECURITY_STATUS SEC_ENTRY VerifySignature(PCtxtHandle phContext, PSecBufferDesc pMessage, ULONG MessageSeqNo, PULONG pfQOP)\n{\n\tchar* Name;\n\tSECURITY_STATUS status;\n\tSecurityFunctionTableA* table;\n\n\tName = (char*) sspi_SecureHandleGetUpperPointer(phContext);\n\n\tif (!Name)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\ttable = sspi_GetSecurityFunctionTableAByNameA(Name);\n\n\tif (!table)\n\t\treturn SEC_E_SECPKG_NOT_FOUND;\n\n\tif (table->VerifySignature == NULL)\n\t\treturn SEC_E_UNSUPPORTED_FUNCTION;\n\n\tstatus = table->VerifySignature(phContext, pMessage, MessageSeqNo, pfQOP);\n\n\treturn status;\n}\n\nSecurityFunctionTableA SSPI_SecurityFunctionTableA =\n{\n\t1, /* dwVersion */\n\tEnumerateSecurityPackagesA, /* EnumerateSecurityPackages */\n\tQueryCredentialsAttributesA, /* QueryCredentialsAttributes */\n\tAcquireCredentialsHandleA, /* AcquireCredentialsHandle */\n\tFreeCredentialsHandle, /* FreeCredentialsHandle */\n\tNULL, /* Reserved2 */\n\tInitializeSecurityContextA, /* InitializeSecurityContext */\n\tAcceptSecurityContext, /* AcceptSecurityContext */\n\tCompleteAuthToken, /* CompleteAuthToken */\n\tDeleteSecurityContext, /* DeleteSecurityContext */\n\tApplyControlToken, /* ApplyControlToken */\n\tQueryContextAttributesA, /* QueryContextAttributes */\n\tImpersonateSecurityContext, /* ImpersonateSecurityContext */\n\tRevertSecurityContext, /* RevertSecurityContext */\n\tMakeSignature, /* MakeSignature */\n\tVerifySignature, /* VerifySignature */\n\tFreeContextBuffer, /* FreeContextBuffer */\n\tQuerySecurityPackageInfoA, /* QuerySecurityPackageInfo */\n\tNULL, /* Reserved3 */\n\tNULL, /* Reserved4 */\n\tExportSecurityContext, /* ExportSecurityContext */\n\tImportSecurityContextA, /* ImportSecurityContext */\n\tNULL, /* AddCredentials */\n\tNULL, /* Reserved8 */\n\tQuerySecurityContextToken, /* QuerySecurityContextToken */\n\tEncryptMessage, /* EncryptMessage */\n\tDecryptMessage, /* DecryptMessage */\n\tSetContextAttributes, /* SetContextAttributes */\n};\n\nSecurityFunctionTableW SSPI_SecurityFunctionTableW =\n{\n\t1, /* dwVersion */\n\tEnumerateSecurityPackagesW, /* EnumerateSecurityPackages */\n\tQueryCredentialsAttributesW, /* QueryCredentialsAttributes */\n\tAcquireCredentialsHandleW, /* AcquireCredentialsHandle */\n\tFreeCredentialsHandle, /* FreeCredentialsHandle */\n\tNULL, /* Reserved2 */\n\tInitializeSecurityContextW, /* InitializeSecurityContext */\n\tAcceptSecurityContext, /* AcceptSecurityContext */\n\tCompleteAuthToken, /* CompleteAuthToken */\n\tDeleteSecurityContext, /* DeleteSecurityContext */\n\tApplyControlToken, /* ApplyControlToken */\n\tQueryContextAttributesW, /* QueryContextAttributes */\n\tImpersonateSecurityContext, /* ImpersonateSecurityContext */\n\tRevertSecurityContext, /* RevertSecurityContext */\n\tMakeSignature, /* MakeSignature */\n\tVerifySignature, /* VerifySignature */\n\tFreeContextBuffer, /* FreeContextBuffer */\n\tQuerySecurityPackageInfoW, /* QuerySecurityPackageInfo */\n\tNULL, /* Reserved3 */\n\tNULL, /* Reserved4 */\n\tExportSecurityContext, /* ExportSecurityContext */\n\tImportSecurityContextW, /* ImportSecurityContext */\n\tNULL, /* AddCredentials */\n\tNULL, /* Reserved8 */\n\tQuerySecurityContextToken, /* QuerySecurityContextToken */\n\tEncryptMessage, /* EncryptMessage */\n\tDecryptMessage, /* DecryptMessage */\n\tSetContextAttributes, /* SetContextAttributes */\n};\n\n#endif\n"], "filenames": ["libfreerdp/core/nla.c", "libfreerdp/core/peer.c", "libfreerdp/core/transport.c", "winpr/libwinpr/sspi/sspi.c"], "buggy_code_start_loc": [1247, 274, 161, 251], "buggy_code_end_loc": [1247, 274, 294, 843], "fixing_code_start_loc": [1248, 275, 162, 251], "fixing_code_end_loc": [1249, 276, 297, 843], "type": "CWE-476", "message": "FreeRDP before 1.1.0-beta+2013071101 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) by disconnecting before authentication has finished.", "other": {"cve": {"id": "CVE-2013-4119", "sourceIdentifier": "secalert@redhat.com", "published": "2016-10-03T21:59:01.423", "lastModified": "2020-03-06T17:18:46.660", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "FreeRDP before 1.1.0-beta+2013071101 allows remote attackers to cause a denial of service (NULL pointer dereference and application crash) by disconnecting before authentication has finished."}, {"lang": "es", "value": "FreeRDP en versiones anteriores a 1.1.0-beta+2013071101 permite a atacantes remotos provocar una denegaci\u00f3n de servicio (referencia a puntero NULL y ca\u00edda de aplicaci\u00f3n) desconectando antes de que la autenticaci\u00f3n haya finalizado."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 5.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 10.0, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:freerdp:freerdp:*:*:*:*:*:*:*:*", "versionEndIncluding": "1.0.2", "matchCriteriaId": "F437CAE0-7C2D-441D-8122-6E621F5D1DA4"}]}]}], "references": [{"url": "http://www.openwall.com/lists/oss-security/2013/07/11/12", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.openwall.com/lists/oss-security/2013/07/12/2", "source": "secalert@redhat.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "http://www.securityfocus.com/bid/61072", "source": "secalert@redhat.com", "tags": ["Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/FreeRDP/FreeRDP/commit/0773bb9303d24473fe1185d85a424dfe159aff53", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch"]}]}, "github_commit_url": "https://github.com/FreeRDP/FreeRDP/commit/0773bb9303d24473fe1185d85a424dfe159aff53"}}