{"buggy_code": ["pragma solidity 0.4.15;\n\nimport \"zeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"zeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"tce-contracts/contracts/CPToken.sol\";\nimport \"./BasicUCAC.sol\";\n\ncontract CreditProtocol is Ownable {\n    using SafeMath for uint256;\n\n    struct Ucac {\n        address ucacContractAddr;\n        uint256 totalStakedTokens;\n        uint256 txLevel;\n        uint256 lastTxTimestamp;\n        bytes32 denomination;\n    }\n\n    CPToken public token;\n    uint256 public txPerGigaTokenPerHour; // gigatoken = 10 ^ 9 nominal tokens\n    uint256 public tokensToOwnUcac;\n\n    mapping (address => Ucac) public ucacs; // ucacAddress -> Ucac struct\n\n    // ucacAddr -> token owner address -> amount of tokens\n    mapping (address => mapping (address => uint256)) public stakedTokensMap;\n\n    // id -> id -> # of transactions in all UCACs\n    // lesser id is must always be the first argument\n    mapping(address => mapping(address => uint256)) public nonces;\n    // ucacAddr -> id -> balance\n    mapping(address => mapping(address => int256)) public balances;\n\n    // the standard prefix appended to 32-byte-long messages when signed by an\n    // Ethereum client\n    bytes prefix = \"\\x19Ethereum Signed Message:\\n32\";\n\n    event IssueCredit(address indexed ucac, address indexed creditor, address indexed debtor, uint256 amount, uint256 nonce, bytes32 memo);\n    event UcacCreation(address indexed ucac, bytes32 denomination);\n\n    function CreditProtocol(address _tokenContract, uint256 _txPerGigaTokenPerHour, uint256 _tokensToOwnUcac) {\n        token = CPToken(_tokenContract);\n        txPerGigaTokenPerHour = _txPerGigaTokenPerHour;\n        tokensToOwnUcac = _tokensToOwnUcac;\n    }\n\n    function getNonce(address p1, address p2) public constant returns (uint256) {\n        return p1 < p2 ? nonces[p1][p2] : nonces[p2][p1];\n    }\n\n    function issueCredit( address _ucacContractAddr, address creditor, address debtor, uint256 amount\n                        , bytes32[3] memory sig1\n                        , bytes32[3] memory sig2\n                        , bytes32 memo\n                        ) public {\n        require(creditor != debtor);\n        uint256 nonce = getNonce(creditor, debtor);\n        bytes32 hash = keccak256(prefix, keccak256(_ucacContractAddr, creditor, debtor, amount, nonce));\n\n        // verifying signatures\n        require(ecrecover(hash, uint8(sig1[2]), sig1[0], sig1[1]) == creditor);\n        require(ecrecover(hash, uint8(sig2[2]), sig2[0], sig2[1]) == debtor);\n\n        // checking for overflow\n        require(balances[_ucacContractAddr][creditor] < balances[_ucacContractAddr][creditor] + int256(amount));\n        // checking for underflow\n        require(balances[_ucacContractAddr][debtor] > balances[_ucacContractAddr][debtor] - int256(amount));\n        // executeUcacTx will throw if a transaction limit has been reached or the ucac is uninitialized\n        executeUcacTx(_ucacContractAddr);\n        // check that UCAC contract approves the transaction\n        require(BasicUCAC(_ucacContractAddr).allowTransaction(creditor, debtor, amount));\n\n        balances[_ucacContractAddr][creditor] = balances[_ucacContractAddr][creditor] + int256(amount);\n        balances[_ucacContractAddr][debtor] = balances[_ucacContractAddr][debtor] - int256(amount);\n        IssueCredit(_ucacContractAddr, creditor, debtor, amount, nonce, memo);\n        incrementNonce(creditor, debtor);\n    }\n\n    function incrementNonce(address p1, address p2) private {\n        if (p1 < p2) {\n            nonces[p1][p2] = nonces[p1][p2] + 1;\n        } else {\n            nonces[p2][p1] = nonces[p2][p1] + 1;\n        }\n    }\n\n    // Staking\n\n    /**\n       @dev The gigatokens of `_txPerGigaTokenPerHour` are nominal giga tokens, that is\n       10 ^ 18 * 10 ^ 9 = 10 ^ 27 attotokens\n     **/\n    function setTxPerGigaTokenPerHour(uint256 _txPerGigaTokenPerHour) public onlyOwner {\n        txPerGigaTokenPerHour = _txPerGigaTokenPerHour;\n    }\n\n    function setTokensToOwnUcac(uint256 _tokensToOwnUcac) public onlyOwner {\n        tokensToOwnUcac = _tokensToOwnUcac;\n    }\n\n    function currentTxLevel(address _ucacContractAddr) public constant returns (uint256) {\n        uint256 totalStaked = ucacs[_ucacContractAddr].totalStakedTokens;\n        uint256 currentDecay = totalStaked / 3600 * (now - ucacs[_ucacContractAddr].lastTxTimestamp);\n        uint256 adjustedTxLevel = ucacs[_ucacContractAddr].txLevel < currentDecay ? 0 : ucacs[_ucacContractAddr].txLevel - currentDecay;\n        return adjustedTxLevel;\n    }\n\n    function executeUcacTx(address _ucacContractAddr) public {\n        uint256 txLevelBeforeCurrentTx = currentTxLevel(_ucacContractAddr);\n        uint256 txLevelAfterCurrentTx = txLevelBeforeCurrentTx + 10 ** 27 / txPerGigaTokenPerHour;\n        require(ucacs[_ucacContractAddr].totalStakedTokens >= txLevelAfterCurrentTx);\n        require(ucacs[_ucacContractAddr].totalStakedTokens >= tokensToOwnUcac);\n        ucacs[_ucacContractAddr].lastTxTimestamp = now;\n        ucacs[_ucacContractAddr].txLevel = txLevelAfterCurrentTx;\n    }\n\n    /**\n       @dev msg.sender must have approved Stake contract to transfer at least `_tokensToStake` tokens.\n            `_tokensToStake` is measured in attotokens.\n     **/\n    function createAndStakeUcac( address _ucacContractAddr, bytes32 _denomination\n                               , uint256 _tokensToStake) public {\n        // check that _ucacContractAddr points to something meaningful\n        require(_ucacContractAddr != address(0));\n        // check that _ucacContractAddr does not point to an extant UCAC\n        require(ucacs[_ucacContractAddr].totalStakedTokens == 0 && ucacs[_ucacContractAddr].ucacContractAddr == address(0));\n        // checking that initial token staking amount is enough to own a UCAC\n        require(_tokensToStake >= tokensToOwnUcac);\n        stakeTokensInternal(_ucacContractAddr, msg.sender, _tokensToStake);\n        ucacs[_ucacContractAddr].ucacContractAddr = _ucacContractAddr;\n        ucacs[_ucacContractAddr].denomination = _denomination;\n        UcacCreation(_ucacContractAddr, _denomination);\n    }\n\n    /* Token staking functionality */\n\n    /**\n       @dev msg.sender must have approved Stake contract to transfer at least `_numTokens` tokens\n       `_numTokens` is measured in attotokens.\n     **/\n    function stakeTokens(address _ucacContractAddr, uint256 _numTokens) public {\n        // check that _ucacContractAddr points to an extant UCAC\n        require(ucacs[_ucacContractAddr].ucacContractAddr != address(0));\n        stakeTokensInternal(_ucacContractAddr, msg.sender, _numTokens);\n    }\n\n    /**\n       @notice Checks if this address is already in this name.\n       @param _ucacContractAddr Id of the ucac tokens are staked to\n       @param _numTokens Number of attotokens the user wants to unstake\n     **/\n    function unstakeTokens(address _ucacContractAddr, uint256 _numTokens) public {\n        // SafeMath will throw if _numTokens is greater than a sender's stakedTokens amount\n        uint256 updatedStakedTokens = stakedTokensMap[_ucacContractAddr][msg.sender].sub(_numTokens);\n        stakedTokensMap[_ucacContractAddr][msg.sender] = updatedStakedTokens;\n        uint256 updatedNumTokens = ucacs[_ucacContractAddr].totalStakedTokens.sub(_numTokens);\n\n        // updating txLevel to ensure accurate decay calculation\n        ucacs[_ucacContractAddr].txLevel = currentTxLevel(_ucacContractAddr);\n\n        ucacs[_ucacContractAddr].totalStakedTokens = updatedNumTokens;\n        token.transfer(msg.sender, _numTokens);\n    }\n\n    // Private Functions\n\n    function stakeTokensInternal(address _ucacContractAddr, address _stakeholder, uint256 _numTokens) private {\n        token.transferFrom(_stakeholder, this, _numTokens);\n        uint256 updatedStakedTokens = stakedTokensMap[_ucacContractAddr][_stakeholder].add(_numTokens);\n        stakedTokensMap[_ucacContractAddr][_stakeholder] = updatedStakedTokens;\n\n        // updating txLevel to ensure accurate decay calculation\n        ucacs[_ucacContractAddr].txLevel = currentTxLevel(_ucacContractAddr);\n\n        uint256 updatedNumTokens =  ucacs[_ucacContractAddr].totalStakedTokens.add(_numTokens);\n        ucacs[_ucacContractAddr].totalStakedTokens = updatedNumTokens;\n    }\n\n}\n"], "fixing_code": ["pragma solidity 0.4.15;\n\nimport \"zeppelin-solidity/contracts/math/SafeMath.sol\";\nimport \"zeppelin-solidity/contracts/ownership/Ownable.sol\";\nimport \"tce-contracts/contracts/CPToken.sol\";\nimport \"./BasicUCAC.sol\";\n\ncontract CreditProtocol is Ownable {\n    using SafeMath for uint256;\n\n    struct Ucac {\n        address ucacContractAddr;\n        uint256 totalStakedTokens;\n        uint256 txLevel;\n        uint256 lastTxTimestamp;\n        bytes32 denomination;\n    }\n\n    CPToken public token;\n    uint256 public txPerGigaTokenPerHour; // gigatoken = 10 ^ 9 nominal tokens\n    uint256 public tokensToOwnUcac;\n\n    mapping (address => Ucac) public ucacs; // ucacAddress -> Ucac struct\n\n    // ucacAddr -> token owner address -> amount of tokens\n    mapping (address => mapping (address => uint256)) public stakedTokensMap;\n\n    // id -> id -> # of transactions in all UCACs\n    // lesser id is must always be the first argument\n    mapping(address => mapping(address => uint256)) public nonces;\n    // ucacAddr -> id -> balance\n    mapping(address => mapping(address => int256)) public balances;\n\n    // the standard prefix appended to 32-byte-long messages when signed by an\n    // Ethereum client\n    bytes prefix = \"\\x19Ethereum Signed Message:\\n32\";\n\n    event IssueCredit(address indexed ucac, address indexed creditor, address indexed debtor, uint256 amount, uint256 nonce, bytes32 memo);\n    event UcacCreation(address indexed ucac, bytes32 denomination);\n\n    function CreditProtocol(address _tokenContract, uint256 _txPerGigaTokenPerHour, uint256 _tokensToOwnUcac) {\n        token = CPToken(_tokenContract);\n        txPerGigaTokenPerHour = _txPerGigaTokenPerHour;\n        tokensToOwnUcac = _tokensToOwnUcac;\n    }\n\n    function getNonce(address p1, address p2) public constant returns (uint256) {\n        return p1 < p2 ? nonces[p1][p2] : nonces[p2][p1];\n    }\n\n    function issueCredit( address _ucacContractAddr, address creditor, address debtor, uint256 amount\n                        , bytes32[3] memory sig1\n                        , bytes32[3] memory sig2\n                        , bytes32 memo\n                        ) public {\n        require(creditor != debtor);\n        uint256 nonce = getNonce(creditor, debtor);\n        bytes32 hash = keccak256(prefix, keccak256(_ucacContractAddr, creditor, debtor, amount, nonce));\n\n        // verifying signatures\n        require(ecrecover(hash, uint8(sig1[2]), sig1[0], sig1[1]) == creditor);\n        require(ecrecover(hash, uint8(sig2[2]), sig2[0], sig2[1]) == debtor);\n\n        // checking for overflow\n        require(balances[_ucacContractAddr][creditor] < balances[_ucacContractAddr][creditor] + int256(amount));\n        // checking for underflow\n        require(balances[_ucacContractAddr][debtor] > balances[_ucacContractAddr][debtor] - int256(amount));\n        // executeUcacTx will throw if a transaction limit has been reached or the ucac is uninitialized\n        executeUcacTx(_ucacContractAddr);\n        // check that UCAC contract approves the transaction\n        require(BasicUCAC(_ucacContractAddr).allowTransaction(creditor, debtor, amount));\n\n        balances[_ucacContractAddr][creditor] = balances[_ucacContractAddr][creditor] + int256(amount);\n        balances[_ucacContractAddr][debtor] = balances[_ucacContractAddr][debtor] - int256(amount);\n        IssueCredit(_ucacContractAddr, creditor, debtor, amount, nonce, memo);\n        incrementNonce(creditor, debtor);\n    }\n\n    function incrementNonce(address p1, address p2) private {\n        if (p1 < p2) {\n            nonces[p1][p2] = nonces[p1][p2] + 1;\n        } else {\n            nonces[p2][p1] = nonces[p2][p1] + 1;\n        }\n    }\n\n    // Staking\n\n    /**\n       @dev The gigatokens of `_txPerGigaTokenPerHour` are nominal giga tokens, that is\n       10 ^ 18 * 10 ^ 9 = 10 ^ 27 attotokens\n     **/\n    function setTxPerGigaTokenPerHour(uint256 _txPerGigaTokenPerHour) public onlyOwner {\n        txPerGigaTokenPerHour = _txPerGigaTokenPerHour;\n    }\n\n    function setTokensToOwnUcac(uint256 _tokensToOwnUcac) public onlyOwner {\n        tokensToOwnUcac = _tokensToOwnUcac;\n    }\n\n    function currentTxLevel(address _ucacContractAddr) public constant returns (uint256) {\n        uint256 totalStaked = ucacs[_ucacContractAddr].totalStakedTokens;\n        uint256 currentDecay = totalStaked / 3600 * (now - ucacs[_ucacContractAddr].lastTxTimestamp);\n        uint256 adjustedTxLevel = ucacs[_ucacContractAddr].txLevel < currentDecay ? 0 : ucacs[_ucacContractAddr].txLevel - currentDecay;\n        return adjustedTxLevel;\n    }\n\n    function executeUcacTx(address _ucacContractAddr) private {\n        uint256 txLevelBeforeCurrentTx = currentTxLevel(_ucacContractAddr);\n        uint256 txLevelAfterCurrentTx = txLevelBeforeCurrentTx + 10 ** 27 / txPerGigaTokenPerHour;\n        require(ucacs[_ucacContractAddr].totalStakedTokens >= txLevelAfterCurrentTx);\n        require(ucacs[_ucacContractAddr].totalStakedTokens >= tokensToOwnUcac);\n        ucacs[_ucacContractAddr].lastTxTimestamp = now;\n        ucacs[_ucacContractAddr].txLevel = txLevelAfterCurrentTx;\n    }\n\n    /**\n       @dev msg.sender must have approved Stake contract to transfer at least `_tokensToStake` tokens.\n            `_tokensToStake` is measured in attotokens.\n     **/\n    function createAndStakeUcac( address _ucacContractAddr, bytes32 _denomination\n                               , uint256 _tokensToStake) public {\n        // check that _ucacContractAddr points to something meaningful\n        require(_ucacContractAddr != address(0));\n        // check that _ucacContractAddr does not point to an extant UCAC\n        require(ucacs[_ucacContractAddr].totalStakedTokens == 0 && ucacs[_ucacContractAddr].ucacContractAddr == address(0));\n        // checking that initial token staking amount is enough to own a UCAC\n        require(_tokensToStake >= tokensToOwnUcac);\n        stakeTokensInternal(_ucacContractAddr, msg.sender, _tokensToStake);\n        ucacs[_ucacContractAddr].ucacContractAddr = _ucacContractAddr;\n        ucacs[_ucacContractAddr].denomination = _denomination;\n        UcacCreation(_ucacContractAddr, _denomination);\n    }\n\n    /* Token staking functionality */\n\n    /**\n       @dev msg.sender must have approved Stake contract to transfer at least `_numTokens` tokens\n       `_numTokens` is measured in attotokens.\n     **/\n    function stakeTokens(address _ucacContractAddr, uint256 _numTokens) public {\n        // check that _ucacContractAddr points to an extant UCAC\n        require(ucacs[_ucacContractAddr].ucacContractAddr != address(0));\n        stakeTokensInternal(_ucacContractAddr, msg.sender, _numTokens);\n    }\n\n    /**\n       @notice Checks if this address is already in this name.\n       @param _ucacContractAddr Id of the ucac tokens are staked to\n       @param _numTokens Number of attotokens the user wants to unstake\n     **/\n    function unstakeTokens(address _ucacContractAddr, uint256 _numTokens) public {\n        // SafeMath will throw if _numTokens is greater than a sender's stakedTokens amount\n        uint256 updatedStakedTokens = stakedTokensMap[_ucacContractAddr][msg.sender].sub(_numTokens);\n        stakedTokensMap[_ucacContractAddr][msg.sender] = updatedStakedTokens;\n        uint256 updatedNumTokens = ucacs[_ucacContractAddr].totalStakedTokens.sub(_numTokens);\n\n        // updating txLevel to ensure accurate decay calculation\n        ucacs[_ucacContractAddr].txLevel = currentTxLevel(_ucacContractAddr);\n\n        ucacs[_ucacContractAddr].totalStakedTokens = updatedNumTokens;\n        token.transfer(msg.sender, _numTokens);\n    }\n\n    // Private Functions\n\n    function stakeTokensInternal(address _ucacContractAddr, address _stakeholder, uint256 _numTokens) private {\n        token.transferFrom(_stakeholder, this, _numTokens);\n        uint256 updatedStakedTokens = stakedTokensMap[_ucacContractAddr][_stakeholder].add(_numTokens);\n        stakedTokensMap[_ucacContractAddr][_stakeholder] = updatedStakedTokens;\n\n        // updating txLevel to ensure accurate decay calculation\n        ucacs[_ucacContractAddr].txLevel = currentTxLevel(_ucacContractAddr);\n\n        uint256 updatedNumTokens =  ucacs[_ucacContractAddr].totalStakedTokens.add(_numTokens);\n        ucacs[_ucacContractAddr].totalStakedTokens = updatedNumTokens;\n    }\n\n}\n"], "filenames": ["contracts/CreditProtocol.sol"], "buggy_code_start_loc": [108], "buggy_code_end_loc": [109], "fixing_code_start_loc": [108], "fixing_code_end_loc": [109], "type": "CWE-672", "message": "** UNSUPPORTED WHEN ASSIGNED ** A vulnerability was found in blockmason credit-protocol. It has been declared as problematic. Affected by this vulnerability is the function executeUcacTx of the file contracts/CreditProtocol.sol of the component UCAC Handler. The manipulation leads to denial of service. This product does not use versioning. This is why information about affected and unaffected releases are unavailable. The patch is named 082e01f18707ef995e80ebe97fcedb229a55efc5. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-252799. NOTE: This vulnerability only affects products that are no longer supported by the maintainer.", "other": {"cve": {"id": "CVE-2018-25098", "sourceIdentifier": "cna@vuldb.com", "published": "2024-02-04T17:15:07.880", "lastModified": "2024-02-29T01:23:15.647", "vulnStatus": "Modified", "descriptions": [{"lang": "en", "value": "** UNSUPPORTED WHEN ASSIGNED ** A vulnerability was found in blockmason credit-protocol. It has been declared as problematic. Affected by this vulnerability is the function executeUcacTx of the file contracts/CreditProtocol.sol of the component UCAC Handler. The manipulation leads to denial of service. This product does not use versioning. This is why information about affected and unaffected releases are unavailable. The patch is named 082e01f18707ef995e80ebe97fcedb229a55efc5. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-252799. NOTE: This vulnerability only affects products that are no longer supported by the maintainer."}, {"lang": "es", "value": "** NO SOPORTADO CUANDO SE ASIGN\u00d3 ** Se encontr\u00f3 una vulnerabilidad en el protocolo de cr\u00e9dito blockmason. Ha sido declarado problem\u00e1tico. La funci\u00f3n ejecutarUcacTx del archivo contracts/CreditProtocol.sol del componente UCAC Handler es afectada por esta vulnerabilidad. La manipulaci\u00f3n conduce a la denegaci\u00f3n del servicio. Este producto no utiliza versiones. Esta es la raz\u00f3n por la que la informaci\u00f3n sobre las versiones afectadas y no afectadas no est\u00e1 disponible. El parche se llama 082e01f18707ef995e80ebe97fcedb229a55efc5. Se recomienda aplicar un parche para solucionar este problema. El identificador asociado de esta vulnerabilidad es VDB-252799. NOTA: Esta vulnerabilidad solo afecta a productos que ya no son compatibles con el fabricante."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}, {"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:A/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "LOW", "baseScore": 4.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.8, "impactScore": 1.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:L/Au:N/C:N/I:N/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "PARTIAL", "baseScore": 3.3}, "baseSeverity": "LOW", "exploitabilityScore": 6.5, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-672"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-404"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:blockmason:credit-protocol:*:*:*:*:*:*:*:*", "versionEndExcluding": "2018-04-11", "matchCriteriaId": "5C5EDCFF-8C24-41FD-B648-8DAEF7B07CDC"}]}]}], "references": [{"url": "https://github.com/blockmason/credit-protocol/commit/082e01f18707ef995e80ebe97fcedb229a55efc5", "source": "cna@vuldb.com", "tags": ["Patch"]}, {"url": "https://github.com/blockmason/credit-protocol/pull/33", "source": "cna@vuldb.com", "tags": ["Issue Tracking", "Patch"]}, {"url": "https://vuldb.com/?ctiid.252799", "source": "cna@vuldb.com", "tags": ["Permissions Required"]}, {"url": "https://vuldb.com/?id.252799", "source": "cna@vuldb.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/blockmason/credit-protocol/commit/082e01f18707ef995e80ebe97fcedb229a55efc5"}}