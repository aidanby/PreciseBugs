{"buggy_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Copyright 2021 Google LLC.\n */\n\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/kobject.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/vmalloc.h>\n\n#include \"internal.h\"\n\nstatic int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}\n\nstatic struct page *module_get_next_page(struct load_info *info)\n{\n\tstruct page *page;\n\tint error;\n\n\tif (info->max_pages == info->used_pages) {\n\t\terror = module_extend_max_pages(info, info->used_pages);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t}\n\n\tpage = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinfo->pages[info->used_pages++] = page;\n\treturn page;\n}\n\n#ifdef CONFIG_MODULE_COMPRESS_GZIP\n#include <linux/zlib.h>\n#define MODULE_COMPRESSION\tgzip\n#define MODULE_DECOMPRESS_FN\tmodule_gzip_decompress\n\n/*\n * Calculate length of the header which consists of signature, header\n * flags, time stamp and operating system ID (10 bytes total), plus\n * an optional filename.\n */\nstatic size_t module_gzip_header_len(const u8 *buf, size_t size)\n{\n\tconst u8 signature[] = { 0x1f, 0x8b, 0x08 };\n\tsize_t len = 10;\n\n\tif (size < len || memcmp(buf, signature, sizeof(signature)))\n\t\treturn 0;\n\n\tif (buf[3] & 0x08) {\n\t\tdo {\n\t\t\t/*\n\t\t\t * If we can't find the end of the file name we must\n\t\t\t * be dealing with a corrupted file.\n\t\t\t */\n\t\t\tif (len == size)\n\t\t\t\treturn 0;\n\t\t} while (buf[len++] != '\\0');\n\t}\n\n\treturn len;\n}\n\nstatic ssize_t module_gzip_decompress(struct load_info *info,\n\t\t\t\t      const void *buf, size_t size)\n{\n\tstruct z_stream_s s = { 0 };\n\tsize_t new_size = 0;\n\tsize_t gzip_hdr_len;\n\tssize_t retval;\n\tint rc;\n\n\tgzip_hdr_len = module_gzip_header_len(buf, size);\n\tif (!gzip_hdr_len) {\n\t\tpr_err(\"not a gzip compressed module\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ts.next_in = buf + gzip_hdr_len;\n\ts.avail_in = size - gzip_hdr_len;\n\n\ts.workspace = kmalloc(zlib_inflate_workspacesize(), GFP_KERNEL);\n\tif (!s.workspace)\n\t\treturn -ENOMEM;\n\n\trc = zlib_inflateInit2(&s, -MAX_WBITS);\n\tif (rc != Z_OK) {\n\t\tpr_err(\"failed to initialize decompressor: %d\\n\", rc);\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdo {\n\t\tstruct page *page = module_get_next_page(info);\n\n\t\tif (!page) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out_inflate_end;\n\t\t}\n\n\t\ts.next_out = kmap_local_page(page);\n\t\ts.avail_out = PAGE_SIZE;\n\t\trc = zlib_inflate(&s, 0);\n\t\tkunmap_local(s.next_out);\n\n\t\tnew_size += PAGE_SIZE - s.avail_out;\n\t} while (rc == Z_OK);\n\n\tif (rc != Z_STREAM_END) {\n\t\tpr_err(\"decompression failed with status %d\\n\", rc);\n\t\tretval = -EINVAL;\n\t\tgoto out_inflate_end;\n\t}\n\n\tretval = new_size;\n\nout_inflate_end:\n\tzlib_inflateEnd(&s);\nout:\n\tkfree(s.workspace);\n\treturn retval;\n}\n#elif CONFIG_MODULE_COMPRESS_XZ\n#include <linux/xz.h>\n#define MODULE_COMPRESSION\txz\n#define MODULE_DECOMPRESS_FN\tmodule_xz_decompress\n\nstatic ssize_t module_xz_decompress(struct load_info *info,\n\t\t\t\t    const void *buf, size_t size)\n{\n\tstatic const u8 signature[] = { 0xfd, '7', 'z', 'X', 'Z', 0 };\n\tstruct xz_dec *xz_dec;\n\tstruct xz_buf xz_buf;\n\tenum xz_ret xz_ret;\n\tsize_t new_size = 0;\n\tssize_t retval;\n\n\tif (size < sizeof(signature) ||\n\t    memcmp(buf, signature, sizeof(signature))) {\n\t\tpr_err(\"not an xz compressed module\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\txz_dec = xz_dec_init(XZ_DYNALLOC, (u32)-1);\n\tif (!xz_dec)\n\t\treturn -ENOMEM;\n\n\txz_buf.in_size = size;\n\txz_buf.in = buf;\n\txz_buf.in_pos = 0;\n\n\tdo {\n\t\tstruct page *page = module_get_next_page(info);\n\n\t\tif (!page) {\n\t\t\tretval = -ENOMEM;\n\t\t\tgoto out;\n\t\t}\n\n\t\txz_buf.out = kmap_local_page(page);\n\t\txz_buf.out_pos = 0;\n\t\txz_buf.out_size = PAGE_SIZE;\n\t\txz_ret = xz_dec_run(xz_dec, &xz_buf);\n\t\tkunmap_local(xz_buf.out);\n\n\t\tnew_size += xz_buf.out_pos;\n\t} while (xz_buf.out_pos == PAGE_SIZE && xz_ret == XZ_OK);\n\n\tif (xz_ret != XZ_STREAM_END) {\n\t\tpr_err(\"decompression failed with status %d\\n\", xz_ret);\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tretval = new_size;\n\n out:\n\txz_dec_end(xz_dec);\n\treturn retval;\n}\n#else\n#error \"Unexpected configuration for CONFIG_MODULE_DECOMPRESS\"\n#endif\n\nint module_decompress(struct load_info *info, const void *buf, size_t size)\n{\n\tunsigned int n_pages;\n\tssize_t data_size;\n\tint error;\n\n\t/*\n\t * Start with number of pages twice as big as needed for\n\t * compressed data.\n\t */\n\tn_pages = DIV_ROUND_UP(size, PAGE_SIZE) * 2;\n\terror = module_extend_max_pages(info, n_pages);\n\n\tdata_size = MODULE_DECOMPRESS_FN(info, buf, size);\n\tif (data_size < 0) {\n\t\terror = data_size;\n\t\tgoto err;\n\t}\n\n\tinfo->hdr = vmap(info->pages, info->used_pages, VM_MAP, PAGE_KERNEL);\n\tif (!info->hdr) {\n\t\terror = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tinfo->len = data_size;\n\treturn 0;\n\nerr:\n\tmodule_decompress_cleanup(info);\n\treturn error;\n}\n\nvoid module_decompress_cleanup(struct load_info *info)\n{\n\tint i;\n\n\tif (info->hdr)\n\t\tvunmap(info->hdr);\n\n\tfor (i = 0; i < info->used_pages; i++)\n\t\t__free_page(info->pages[i]);\n\n\tkvfree(info->pages);\n\n\tinfo->pages = NULL;\n\tinfo->max_pages = info->used_pages = 0;\n}\n\n#ifdef CONFIG_SYSFS\nstatic ssize_t compression_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, __stringify(MODULE_COMPRESSION) \"\\n\");\n}\n\nstatic struct kobj_attribute module_compression_attr = __ATTR_RO(compression);\n\nstatic int __init module_decompress_sysfs_init(void)\n{\n\tint error;\n\n\terror = sysfs_create_file(&module_kset->kobj,\n\t\t\t\t  &module_compression_attr.attr);\n\tif (error)\n\t\tpr_warn(\"Failed to create 'compression' attribute\");\n\n\treturn 0;\n}\nlate_initcall(module_decompress_sysfs_init);\n#endif\n"], "fixing_code": ["// SPDX-License-Identifier: GPL-2.0-or-later\n/*\n * Copyright 2021 Google LLC.\n */\n\n#include <linux/init.h>\n#include <linux/highmem.h>\n#include <linux/kobject.h>\n#include <linux/mm.h>\n#include <linux/module.h>\n#include <linux/slab.h>\n#include <linux/sysfs.h>\n#include <linux/vmalloc.h>\n\n#include \"internal.h\"\n\nstatic int module_extend_max_pages(struct load_info *info, unsigned int extent)\n{\n\tstruct page **new_pages;\n\n\tnew_pages = kvmalloc_array(info->max_pages + extent,\n\t\t\t\t   sizeof(info->pages), GFP_KERNEL);\n\tif (!new_pages)\n\t\treturn -ENOMEM;\n\n\tmemcpy(new_pages, info->pages, info->max_pages * sizeof(info->pages));\n\tkvfree(info->pages);\n\tinfo->pages = new_pages;\n\tinfo->max_pages += extent;\n\n\treturn 0;\n}\n\nstatic struct page *module_get_next_page(struct load_info *info)\n{\n\tstruct page *page;\n\tint error;\n\n\tif (info->max_pages == info->used_pages) {\n\t\terror = module_extend_max_pages(info, info->used_pages);\n\t\tif (error)\n\t\t\treturn ERR_PTR(error);\n\t}\n\n\tpage = alloc_page(GFP_KERNEL | __GFP_HIGHMEM);\n\tif (!page)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tinfo->pages[info->used_pages++] = page;\n\treturn page;\n}\n\n#ifdef CONFIG_MODULE_COMPRESS_GZIP\n#include <linux/zlib.h>\n#define MODULE_COMPRESSION\tgzip\n#define MODULE_DECOMPRESS_FN\tmodule_gzip_decompress\n\n/*\n * Calculate length of the header which consists of signature, header\n * flags, time stamp and operating system ID (10 bytes total), plus\n * an optional filename.\n */\nstatic size_t module_gzip_header_len(const u8 *buf, size_t size)\n{\n\tconst u8 signature[] = { 0x1f, 0x8b, 0x08 };\n\tsize_t len = 10;\n\n\tif (size < len || memcmp(buf, signature, sizeof(signature)))\n\t\treturn 0;\n\n\tif (buf[3] & 0x08) {\n\t\tdo {\n\t\t\t/*\n\t\t\t * If we can't find the end of the file name we must\n\t\t\t * be dealing with a corrupted file.\n\t\t\t */\n\t\t\tif (len == size)\n\t\t\t\treturn 0;\n\t\t} while (buf[len++] != '\\0');\n\t}\n\n\treturn len;\n}\n\nstatic ssize_t module_gzip_decompress(struct load_info *info,\n\t\t\t\t      const void *buf, size_t size)\n{\n\tstruct z_stream_s s = { 0 };\n\tsize_t new_size = 0;\n\tsize_t gzip_hdr_len;\n\tssize_t retval;\n\tint rc;\n\n\tgzip_hdr_len = module_gzip_header_len(buf, size);\n\tif (!gzip_hdr_len) {\n\t\tpr_err(\"not a gzip compressed module\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\ts.next_in = buf + gzip_hdr_len;\n\ts.avail_in = size - gzip_hdr_len;\n\n\ts.workspace = kmalloc(zlib_inflate_workspacesize(), GFP_KERNEL);\n\tif (!s.workspace)\n\t\treturn -ENOMEM;\n\n\trc = zlib_inflateInit2(&s, -MAX_WBITS);\n\tif (rc != Z_OK) {\n\t\tpr_err(\"failed to initialize decompressor: %d\\n\", rc);\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tdo {\n\t\tstruct page *page = module_get_next_page(info);\n\n\t\tif (IS_ERR(page)) {\n\t\t\tretval = PTR_ERR(page);\n\t\t\tgoto out_inflate_end;\n\t\t}\n\n\t\ts.next_out = kmap_local_page(page);\n\t\ts.avail_out = PAGE_SIZE;\n\t\trc = zlib_inflate(&s, 0);\n\t\tkunmap_local(s.next_out);\n\n\t\tnew_size += PAGE_SIZE - s.avail_out;\n\t} while (rc == Z_OK);\n\n\tif (rc != Z_STREAM_END) {\n\t\tpr_err(\"decompression failed with status %d\\n\", rc);\n\t\tretval = -EINVAL;\n\t\tgoto out_inflate_end;\n\t}\n\n\tretval = new_size;\n\nout_inflate_end:\n\tzlib_inflateEnd(&s);\nout:\n\tkfree(s.workspace);\n\treturn retval;\n}\n#elif CONFIG_MODULE_COMPRESS_XZ\n#include <linux/xz.h>\n#define MODULE_COMPRESSION\txz\n#define MODULE_DECOMPRESS_FN\tmodule_xz_decompress\n\nstatic ssize_t module_xz_decompress(struct load_info *info,\n\t\t\t\t    const void *buf, size_t size)\n{\n\tstatic const u8 signature[] = { 0xfd, '7', 'z', 'X', 'Z', 0 };\n\tstruct xz_dec *xz_dec;\n\tstruct xz_buf xz_buf;\n\tenum xz_ret xz_ret;\n\tsize_t new_size = 0;\n\tssize_t retval;\n\n\tif (size < sizeof(signature) ||\n\t    memcmp(buf, signature, sizeof(signature))) {\n\t\tpr_err(\"not an xz compressed module\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\txz_dec = xz_dec_init(XZ_DYNALLOC, (u32)-1);\n\tif (!xz_dec)\n\t\treturn -ENOMEM;\n\n\txz_buf.in_size = size;\n\txz_buf.in = buf;\n\txz_buf.in_pos = 0;\n\n\tdo {\n\t\tstruct page *page = module_get_next_page(info);\n\n\t\tif (IS_ERR(page)) {\n\t\t\tretval = PTR_ERR(page);\n\t\t\tgoto out;\n\t\t}\n\n\t\txz_buf.out = kmap_local_page(page);\n\t\txz_buf.out_pos = 0;\n\t\txz_buf.out_size = PAGE_SIZE;\n\t\txz_ret = xz_dec_run(xz_dec, &xz_buf);\n\t\tkunmap_local(xz_buf.out);\n\n\t\tnew_size += xz_buf.out_pos;\n\t} while (xz_buf.out_pos == PAGE_SIZE && xz_ret == XZ_OK);\n\n\tif (xz_ret != XZ_STREAM_END) {\n\t\tpr_err(\"decompression failed with status %d\\n\", xz_ret);\n\t\tretval = -EINVAL;\n\t\tgoto out;\n\t}\n\n\tretval = new_size;\n\n out:\n\txz_dec_end(xz_dec);\n\treturn retval;\n}\n#else\n#error \"Unexpected configuration for CONFIG_MODULE_DECOMPRESS\"\n#endif\n\nint module_decompress(struct load_info *info, const void *buf, size_t size)\n{\n\tunsigned int n_pages;\n\tssize_t data_size;\n\tint error;\n\n\t/*\n\t * Start with number of pages twice as big as needed for\n\t * compressed data.\n\t */\n\tn_pages = DIV_ROUND_UP(size, PAGE_SIZE) * 2;\n\terror = module_extend_max_pages(info, n_pages);\n\n\tdata_size = MODULE_DECOMPRESS_FN(info, buf, size);\n\tif (data_size < 0) {\n\t\terror = data_size;\n\t\tgoto err;\n\t}\n\n\tinfo->hdr = vmap(info->pages, info->used_pages, VM_MAP, PAGE_KERNEL);\n\tif (!info->hdr) {\n\t\terror = -ENOMEM;\n\t\tgoto err;\n\t}\n\n\tinfo->len = data_size;\n\treturn 0;\n\nerr:\n\tmodule_decompress_cleanup(info);\n\treturn error;\n}\n\nvoid module_decompress_cleanup(struct load_info *info)\n{\n\tint i;\n\n\tif (info->hdr)\n\t\tvunmap(info->hdr);\n\n\tfor (i = 0; i < info->used_pages; i++)\n\t\t__free_page(info->pages[i]);\n\n\tkvfree(info->pages);\n\n\tinfo->pages = NULL;\n\tinfo->max_pages = info->used_pages = 0;\n}\n\n#ifdef CONFIG_SYSFS\nstatic ssize_t compression_show(struct kobject *kobj,\n\t\t\t\tstruct kobj_attribute *attr, char *buf)\n{\n\treturn sysfs_emit(buf, __stringify(MODULE_COMPRESSION) \"\\n\");\n}\n\nstatic struct kobj_attribute module_compression_attr = __ATTR_RO(compression);\n\nstatic int __init module_decompress_sysfs_init(void)\n{\n\tint error;\n\n\terror = sysfs_create_file(&module_kset->kobj,\n\t\t\t\t  &module_compression_attr.attr);\n\tif (error)\n\t\tpr_warn(\"Failed to create 'compression' attribute\");\n\n\treturn 0;\n}\nlate_initcall(module_decompress_sysfs_init);\n#endif\n"], "filenames": ["kernel/module/decompress.c"], "buggy_code_start_loc": [117], "buggy_code_end_loc": [178], "fixing_code_start_loc": [117], "fixing_code_end_loc": [178], "type": "CWE-476", "message": "In the Linux kernel before 6.1.2, kernel/module/decompress.c misinterprets the module_get_next_page return value (expects it to be NULL in the error case, whereas it is actually an error pointer).", "other": {"cve": {"id": "CVE-2023-22997", "sourceIdentifier": "cve@mitre.org", "published": "2023-02-28T21:15:12.117", "lastModified": "2023-03-06T16:27:20.590", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In the Linux kernel before 6.1.2, kernel/module/decompress.c misinterprets the module_get_next_page return value (expects it to be NULL in the error case, whereas it is actually an error pointer)."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:L/UI:N/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-476"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:linux:linux_kernel:*:*:*:*:*:*:*:*", "versionEndExcluding": "6.1.2", "matchCriteriaId": "6C1DD811-F5C6-4439-A808-D788FE878C65"}]}]}], "references": [{"url": "https://cdn.kernel.org/pub/linux/kernel/v6.x/ChangeLog-6.1.2", "source": "cve@mitre.org", "tags": ["Release Notes"]}, {"url": "https://github.com/torvalds/linux/commit/45af1d7aae7d5520d2858f8517a1342646f015db", "source": "cve@mitre.org", "tags": ["Patch"]}]}, "github_commit_url": "https://github.com/torvalds/linux/commit/45af1d7aae7d5520d2858f8517a1342646f015db"}}