{"buggy_code": ["import { PrimaryGeneratedColumn, BaseEntity, Column, Entity, ManyToOne, JoinColumn } from 'typeorm';\nimport { User } from './user.entity';\nimport { App } from './app.entity';\nimport { Organization } from './organization.entity';\n\n@Entity({ name: 'threads' })\nexport class Thread extends BaseEntity {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n\n  @Column({ name: 'x' })\n  x: number;\n\n  @Column({ name: 'y' })\n  y: number;\n\n  @Column({ name: 'app_id' })\n  appId: string;\n\n  @Column({ name: 'app_versions_id' })\n  appVersionsId: string;\n\n  @Column({ name: 'user_id' })\n  userId: string;\n\n  @Column({ name: 'organization_id' })\n  organizationId: string;\n\n  @Column({ default: false, name: 'is_resolved' })\n  isResolved: boolean;\n\n  @ManyToOne(() => User, (user) => user.id, { eager: true })\n  @JoinColumn({ name: 'user_id' })\n  user: User;\n\n  @ManyToOne(() => App, (app) => app.id)\n  @JoinColumn({ name: 'app_id' })\n  app: App;\n\n  @ManyToOne(() => Organization, (app) => app.id)\n  @JoinColumn({ name: 'organization_id' })\n  organization: Organization;\n}\n", "import { Injectable, NotFoundException } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Thread } from '../entities/thread.entity';\nimport { Comment } from '../entities/comment.entity';\nimport { CreateThreadDto, UpdateThreadDto } from '../dto/thread.dto';\nimport { ThreadRepository } from '../repositories/thread.repository';\n\n@Injectable()\nexport class ThreadService {\n  constructor(\n    @InjectRepository(ThreadRepository)\n    private threadRepository: ThreadRepository\n  ) {}\n\n  public async createThread(createThreadDto: CreateThreadDto, userId: string, orgId: string): Promise<Thread> {\n    return await this.threadRepository.createThread(createThreadDto, userId, orgId);\n  }\n\n  public async getThreads(appId: string, organizationId: string, appVersionsId: string): Promise<Thread[]> {\n    return await this.threadRepository.find({\n      where: {\n        appId,\n        organizationId,\n        appVersionsId,\n      },\n    });\n  }\n\n  public async getOrganizationThreads(orgId: string): Promise<Thread[]> {\n    return await this.threadRepository.find({\n      where: {\n        orgId,\n      },\n    });\n  }\n\n  public async getThread(threadId: number): Promise<Thread> {\n    const foundThread = await this.threadRepository.findOne({ where: { id: threadId } });\n    if (!foundThread) {\n      throw new NotFoundException('Thread not found');\n    }\n    return foundThread;\n  }\n\n  public async editThread(threadId: string, updateThreadDto: UpdateThreadDto): Promise<Thread> {\n    const editedThread = await this.threadRepository.findOne({ where: { id: threadId } });\n    if (!editedThread) {\n      throw new NotFoundException('Thread not found');\n    }\n    return this.threadRepository.editThread(updateThreadDto, editedThread);\n  }\n\n  public async deleteThread(threadId: string): Promise<void> {\n    const comments = await Comment.find({\n      where: { threadId },\n    });\n\n    comments.map((c) => Comment.delete(c.id));\n    await this.threadRepository.delete(threadId);\n  }\n}\n"], "fixing_code": ["import { PrimaryGeneratedColumn, BaseEntity, Column, Entity, ManyToOne, JoinColumn } from 'typeorm';\nimport { User } from './user.entity';\nimport { App } from './app.entity';\nimport { Organization } from './organization.entity';\n\n@Entity({ name: 'threads' })\nexport class Thread extends BaseEntity {\n  @PrimaryGeneratedColumn('uuid')\n  id: string;\n\n  @Column({ name: 'x' })\n  x: number;\n\n  @Column({ name: 'y' })\n  y: number;\n\n  @Column({ name: 'app_id' })\n  appId: string;\n\n  @Column({ name: 'app_versions_id' })\n  appVersionsId: string;\n\n  @Column({ name: 'user_id' })\n  userId: string;\n\n  @Column({ name: 'organization_id' })\n  organizationId: string;\n\n  @Column({ default: false, name: 'is_resolved' })\n  isResolved: boolean;\n\n  @ManyToOne(() => User, (user) => user.id)\n  @JoinColumn({ name: 'user_id' })\n  user: User;\n\n  @ManyToOne(() => App, (app) => app.id)\n  @JoinColumn({ name: 'app_id' })\n  app: App;\n\n  @ManyToOne(() => Organization, (app) => app.id)\n  @JoinColumn({ name: 'organization_id' })\n  organization: Organization;\n}\n", "import { Injectable, NotFoundException } from '@nestjs/common';\nimport { InjectRepository } from '@nestjs/typeorm';\nimport { Thread } from '../entities/thread.entity';\nimport { Comment } from '../entities/comment.entity';\nimport { CreateThreadDto, UpdateThreadDto } from '../dto/thread.dto';\nimport { ThreadRepository } from '../repositories/thread.repository';\nimport { createQueryBuilder } from 'typeorm';\n\n@Injectable()\nexport class ThreadService {\n  constructor(\n    @InjectRepository(ThreadRepository)\n    private threadRepository: ThreadRepository\n  ) {}\n\n  public async createThread(createThreadDto: CreateThreadDto, userId: string, orgId: string): Promise<Thread> {\n    return await this.threadRepository.createThread(createThreadDto, userId, orgId);\n  }\n\n  public async getThreads(appId: string, organizationId: string, appVersionsId: string): Promise<Thread[]> {\n    return await createQueryBuilder(Thread, 'thread')\n      .innerJoin('thread.user', 'user')\n      .addSelect(['user.id', 'user.firstName', 'user.lastName'])\n      .andWhere('thread.appId = :appId', {\n        appId,\n      })\n      .andWhere('thread.organizationId = :organizationId', {\n        organizationId,\n      })\n      .andWhere('thread.appVersionsId = :appVersionsId', {\n        appVersionsId,\n      })\n      .getMany();\n  }\n\n  public async getOrganizationThreads(orgId: string): Promise<Thread[]> {\n    return await this.threadRepository.find({\n      where: {\n        orgId,\n      },\n    });\n  }\n\n  public async getThread(threadId: number): Promise<Thread> {\n    const foundThread = await this.threadRepository.findOne({ where: { id: threadId } });\n    if (!foundThread) {\n      throw new NotFoundException('Thread not found');\n    }\n    return foundThread;\n  }\n\n  public async editThread(threadId: string, updateThreadDto: UpdateThreadDto): Promise<Thread> {\n    const editedThread = await this.threadRepository.findOne({ where: { id: threadId } });\n    if (!editedThread) {\n      throw new NotFoundException('Thread not found');\n    }\n    return this.threadRepository.editThread(updateThreadDto, editedThread);\n  }\n\n  public async deleteThread(threadId: string): Promise<void> {\n    const comments = await Comment.find({\n      where: { threadId },\n    });\n\n    comments.map((c) => Comment.delete(c.id));\n    await this.threadRepository.delete(threadId);\n  }\n}\n"], "filenames": ["server/src/entities/thread.entity.ts", "server/src/services/thread.service.ts"], "buggy_code_start_loc": [32, 6], "buggy_code_end_loc": [33, 27], "fixing_code_start_loc": [32, 7], "fixing_code_end_loc": [33, 34], "type": "CWE-200", "message": "Just like in the previous report, an attacker could steal the account of different users. But in this case, it's a little bit more specific, because it is needed to be an editor in the same app as the victim.", "other": {"cve": {"id": "CVE-2022-3348", "sourceIdentifier": "security@huntr.dev", "published": "2022-09-28T09:15:09.973", "lastModified": "2022-09-30T13:59:56.927", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Just like in the previous report, an attacker could steal the account of different users. But in this case, it's a little bit more specific, because it is needed to be an editor in the same app as the victim."}, {"lang": "es", "value": "Al igual que en el informe anterior, un atacante podr\u00eda robar la cuenta de diferentes usuarios. Pero en este caso, es un poco m\u00e1s espec\u00edfico, porque se necesita ser un editor en la misma aplicaci\u00f3n que la v\u00edctima"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 4.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.6}], "cvssMetricV30": [{"source": "security@huntr.dev", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:N", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "NONE", "baseScore": 6.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 5.2}]}, "weaknesses": [{"source": "security@huntr.dev", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tooljet:tooljet:*:*:*:*:*:*:*:*", "versionEndExcluding": "2022-09-11", "matchCriteriaId": "9C399C04-A736-496A-8112-2D404A660BA3"}]}]}], "references": [{"url": "https://github.com/tooljet/tooljet/commit/37bf6de75f161e03c2a81888810488b913863a46", "source": "security@huntr.dev", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://huntr.dev/bounties/aae4aeb8-2612-4254-85e5-90675b082eac", "source": "security@huntr.dev", "tags": ["Exploit", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/tooljet/tooljet/commit/37bf6de75f161e03c2a81888810488b913863a46"}}