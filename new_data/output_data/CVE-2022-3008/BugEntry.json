{"buggy_code": ["//\n// Header-only tiny glTF 2.0 loader and serializer.\n//\n//\n// The MIT License (MIT)\n//\n// Copyright (c) 2015 - Present Syoyo Fujita, Aur\u00e9lien Chatelain and many\n// contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Version:\n//  - v2.5.0 Add SetPreserveImageChannels() option to load image data as is.\n//  - v2.4.3 Fix null object output when when material has all default\n//  parameters.\n//  - v2.4.2 Decode percent-encoded URI.\n//  - v2.4.1 Fix some glTF object class does not have `extensions` and/or\n//  `extras` property.\n//  - v2.4.0 Experimental RapidJSON and C++14 support(Thanks to @jrkoone).\n//  - v2.3.1 Set default value of minFilter and magFilter in Sampler to -1.\n//  - v2.3.0 Modified Material representation according to glTF 2.0 schema\n//           (and introduced TextureInfo class)\n//           Change the behavior of `Value::IsNumber`. It return true either the\n//           value is int or real.\n//  - v2.2.0 Add loading 16bit PNG support. Add Sparse accessor support(Thanks\n//  to @Ybalrid)\n//  - v2.1.0 Add draco compression.\n//  - v2.0.1 Add comparsion feature(Thanks to @Selmar).\n//  - v2.0.0 glTF 2.0!.\n//\n// Tiny glTF loader is using following third party libraries:\n//\n//  - jsonhpp: C++ JSON library.\n//  - base64: base64 decode/encode library.\n//  - stb_image: Image loading library.\n//\n#ifndef TINY_GLTF_H_\n#define TINY_GLTF_H_\n\n#include <array>\n#include <cassert>\n#include <cmath>  // std::fabs\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n#include <map>\n#include <string>\n#include <vector>\n\n#ifndef TINYGLTF_USE_CPP14\n#include <functional>\n#endif\n\n#ifdef __ANDROID__\n#ifdef TINYGLTF_ANDROID_LOAD_FROM_ASSETS\n#include <android/asset_manager.h>\n#endif\n#endif\n\n#ifdef __GNUC__\n#if (__GNUC__ < 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ <= 8))\n#define TINYGLTF_NOEXCEPT\n#else\n#define TINYGLTF_NOEXCEPT noexcept\n#endif\n#else\n#define TINYGLTF_NOEXCEPT noexcept\n#endif\n\n#define DEFAULT_METHODS(x)             \\\n  ~x() = default;                      \\\n  x(const x &) = default;              \\\n  x(x &&) TINYGLTF_NOEXCEPT = default; \\\n  x &operator=(const x &) = default;   \\\n  x &operator=(x &&) TINYGLTF_NOEXCEPT = default;\n\nnamespace tinygltf {\n\n#define TINYGLTF_MODE_POINTS (0)\n#define TINYGLTF_MODE_LINE (1)\n#define TINYGLTF_MODE_LINE_LOOP (2)\n#define TINYGLTF_MODE_LINE_STRIP (3)\n#define TINYGLTF_MODE_TRIANGLES (4)\n#define TINYGLTF_MODE_TRIANGLE_STRIP (5)\n#define TINYGLTF_MODE_TRIANGLE_FAN (6)\n\n#define TINYGLTF_COMPONENT_TYPE_BYTE (5120)\n#define TINYGLTF_COMPONENT_TYPE_UNSIGNED_BYTE (5121)\n#define TINYGLTF_COMPONENT_TYPE_SHORT (5122)\n#define TINYGLTF_COMPONENT_TYPE_UNSIGNED_SHORT (5123)\n#define TINYGLTF_COMPONENT_TYPE_INT (5124)\n#define TINYGLTF_COMPONENT_TYPE_UNSIGNED_INT (5125)\n#define TINYGLTF_COMPONENT_TYPE_FLOAT (5126)\n#define TINYGLTF_COMPONENT_TYPE_DOUBLE (5130) // OpenGL double type. Note that some of glTF 2.0 validator does not support double type even the schema seems allow any value of integer: https://github.com/KhronosGroup/glTF/blob/b9884a2fd45130b4d673dd6c8a706ee21ee5c5f7/specification/2.0/schema/accessor.schema.json#L22\n\n#define TINYGLTF_TEXTURE_FILTER_NEAREST (9728)\n#define TINYGLTF_TEXTURE_FILTER_LINEAR (9729)\n#define TINYGLTF_TEXTURE_FILTER_NEAREST_MIPMAP_NEAREST (9984)\n#define TINYGLTF_TEXTURE_FILTER_LINEAR_MIPMAP_NEAREST (9985)\n#define TINYGLTF_TEXTURE_FILTER_NEAREST_MIPMAP_LINEAR (9986)\n#define TINYGLTF_TEXTURE_FILTER_LINEAR_MIPMAP_LINEAR (9987)\n\n#define TINYGLTF_TEXTURE_WRAP_REPEAT (10497)\n#define TINYGLTF_TEXTURE_WRAP_CLAMP_TO_EDGE (33071)\n#define TINYGLTF_TEXTURE_WRAP_MIRRORED_REPEAT (33648)\n\n// Redeclarations of the above for technique.parameters.\n#define TINYGLTF_PARAMETER_TYPE_BYTE (5120)\n#define TINYGLTF_PARAMETER_TYPE_UNSIGNED_BYTE (5121)\n#define TINYGLTF_PARAMETER_TYPE_SHORT (5122)\n#define TINYGLTF_PARAMETER_TYPE_UNSIGNED_SHORT (5123)\n#define TINYGLTF_PARAMETER_TYPE_INT (5124)\n#define TINYGLTF_PARAMETER_TYPE_UNSIGNED_INT (5125)\n#define TINYGLTF_PARAMETER_TYPE_FLOAT (5126)\n\n#define TINYGLTF_PARAMETER_TYPE_FLOAT_VEC2 (35664)\n#define TINYGLTF_PARAMETER_TYPE_FLOAT_VEC3 (35665)\n#define TINYGLTF_PARAMETER_TYPE_FLOAT_VEC4 (35666)\n\n#define TINYGLTF_PARAMETER_TYPE_INT_VEC2 (35667)\n#define TINYGLTF_PARAMETER_TYPE_INT_VEC3 (35668)\n#define TINYGLTF_PARAMETER_TYPE_INT_VEC4 (35669)\n\n#define TINYGLTF_PARAMETER_TYPE_BOOL (35670)\n#define TINYGLTF_PARAMETER_TYPE_BOOL_VEC2 (35671)\n#define TINYGLTF_PARAMETER_TYPE_BOOL_VEC3 (35672)\n#define TINYGLTF_PARAMETER_TYPE_BOOL_VEC4 (35673)\n\n#define TINYGLTF_PARAMETER_TYPE_FLOAT_MAT2 (35674)\n#define TINYGLTF_PARAMETER_TYPE_FLOAT_MAT3 (35675)\n#define TINYGLTF_PARAMETER_TYPE_FLOAT_MAT4 (35676)\n\n#define TINYGLTF_PARAMETER_TYPE_SAMPLER_2D (35678)\n\n// End parameter types\n\n#define TINYGLTF_TYPE_VEC2 (2)\n#define TINYGLTF_TYPE_VEC3 (3)\n#define TINYGLTF_TYPE_VEC4 (4)\n#define TINYGLTF_TYPE_MAT2 (32 + 2)\n#define TINYGLTF_TYPE_MAT3 (32 + 3)\n#define TINYGLTF_TYPE_MAT4 (32 + 4)\n#define TINYGLTF_TYPE_SCALAR (64 + 1)\n#define TINYGLTF_TYPE_VECTOR (64 + 4)\n#define TINYGLTF_TYPE_MATRIX (64 + 16)\n\n#define TINYGLTF_IMAGE_FORMAT_JPEG (0)\n#define TINYGLTF_IMAGE_FORMAT_PNG (1)\n#define TINYGLTF_IMAGE_FORMAT_BMP (2)\n#define TINYGLTF_IMAGE_FORMAT_GIF (3)\n\n#define TINYGLTF_TEXTURE_FORMAT_ALPHA (6406)\n#define TINYGLTF_TEXTURE_FORMAT_RGB (6407)\n#define TINYGLTF_TEXTURE_FORMAT_RGBA (6408)\n#define TINYGLTF_TEXTURE_FORMAT_LUMINANCE (6409)\n#define TINYGLTF_TEXTURE_FORMAT_LUMINANCE_ALPHA (6410)\n\n#define TINYGLTF_TEXTURE_TARGET_TEXTURE2D (3553)\n#define TINYGLTF_TEXTURE_TYPE_UNSIGNED_BYTE (5121)\n\n#define TINYGLTF_TARGET_ARRAY_BUFFER (34962)\n#define TINYGLTF_TARGET_ELEMENT_ARRAY_BUFFER (34963)\n\n#define TINYGLTF_SHADER_TYPE_VERTEX_SHADER (35633)\n#define TINYGLTF_SHADER_TYPE_FRAGMENT_SHADER (35632)\n\n#define TINYGLTF_DOUBLE_EPS (1.e-12)\n#define TINYGLTF_DOUBLE_EQUAL(a, b) (std::fabs((b) - (a)) < TINYGLTF_DOUBLE_EPS)\n\n#ifdef __ANDROID__\n#ifdef TINYGLTF_ANDROID_LOAD_FROM_ASSETS\nAAssetManager *asset_manager = nullptr;\n#endif\n#endif\n\ntypedef enum {\n  NULL_TYPE,\n  REAL_TYPE,\n  INT_TYPE,\n  BOOL_TYPE,\n  STRING_TYPE,\n  ARRAY_TYPE,\n  BINARY_TYPE,\n  OBJECT_TYPE\n} Type;\n\nstatic inline int32_t GetComponentSizeInBytes(uint32_t componentType) {\n  if (componentType == TINYGLTF_COMPONENT_TYPE_BYTE) {\n    return 1;\n  } else if (componentType == TINYGLTF_COMPONENT_TYPE_UNSIGNED_BYTE) {\n    return 1;\n  } else if (componentType == TINYGLTF_COMPONENT_TYPE_SHORT) {\n    return 2;\n  } else if (componentType == TINYGLTF_COMPONENT_TYPE_UNSIGNED_SHORT) {\n    return 2;\n  } else if (componentType == TINYGLTF_COMPONENT_TYPE_INT) {\n    return 4;\n  } else if (componentType == TINYGLTF_COMPONENT_TYPE_UNSIGNED_INT) {\n    return 4;\n  } else if (componentType == TINYGLTF_COMPONENT_TYPE_FLOAT) {\n    return 4;\n  } else if (componentType == TINYGLTF_COMPONENT_TYPE_DOUBLE) {\n    return 8;\n  } else {\n    // Unknown componenty type\n    return -1;\n  }\n}\n\nstatic inline int32_t GetNumComponentsInType(uint32_t ty) {\n  if (ty == TINYGLTF_TYPE_SCALAR) {\n    return 1;\n  } else if (ty == TINYGLTF_TYPE_VEC2) {\n    return 2;\n  } else if (ty == TINYGLTF_TYPE_VEC3) {\n    return 3;\n  } else if (ty == TINYGLTF_TYPE_VEC4) {\n    return 4;\n  } else if (ty == TINYGLTF_TYPE_MAT2) {\n    return 4;\n  } else if (ty == TINYGLTF_TYPE_MAT3) {\n    return 9;\n  } else if (ty == TINYGLTF_TYPE_MAT4) {\n    return 16;\n  } else {\n    // Unknown componenty type\n    return -1;\n  }\n}\n\n// TODO(syoyo): Move these functions to TinyGLTF class\nbool IsDataURI(const std::string &in);\nbool DecodeDataURI(std::vector<unsigned char> *out, std::string &mime_type,\n                   const std::string &in, size_t reqBytes, bool checkSize);\n\n#ifdef __clang__\n#pragma clang diagnostic push\n// Suppress warning for : static Value null_value\n#pragma clang diagnostic ignored \"-Wexit-time-destructors\"\n#pragma clang diagnostic ignored \"-Wpadded\"\n#endif\n\n// Simple class to represent JSON object\nclass Value {\n public:\n  typedef std::vector<Value> Array;\n  typedef std::map<std::string, Value> Object;\n\n  Value()\n      : type_(NULL_TYPE),\n        int_value_(0),\n        real_value_(0.0),\n        boolean_value_(false) {}\n\n  explicit Value(bool b) : type_(BOOL_TYPE) { boolean_value_ = b; }\n  explicit Value(int i) : type_(INT_TYPE) {\n    int_value_ = i;\n    real_value_ = i;\n  }\n  explicit Value(double n) : type_(REAL_TYPE) { real_value_ = n; }\n  explicit Value(const std::string &s) : type_(STRING_TYPE) {\n    string_value_ = s;\n  }\n  explicit Value(std::string &&s)\n      : type_(STRING_TYPE), string_value_(std::move(s)) {}\n  explicit Value(const unsigned char *p, size_t n) : type_(BINARY_TYPE) {\n    binary_value_.resize(n);\n    memcpy(binary_value_.data(), p, n);\n  }\n  explicit Value(std::vector<unsigned char> &&v) noexcept\n      : type_(BINARY_TYPE),\n        binary_value_(std::move(v)) {}\n  explicit Value(const Array &a) : type_(ARRAY_TYPE) { array_value_ = a; }\n  explicit Value(Array &&a) noexcept : type_(ARRAY_TYPE),\n                                       array_value_(std::move(a)) {}\n\n  explicit Value(const Object &o) : type_(OBJECT_TYPE) { object_value_ = o; }\n  explicit Value(Object &&o) noexcept : type_(OBJECT_TYPE),\n                                        object_value_(std::move(o)) {}\n\n  DEFAULT_METHODS(Value)\n\n  char Type() const { return static_cast<char>(type_); }\n\n  bool IsBool() const { return (type_ == BOOL_TYPE); }\n\n  bool IsInt() const { return (type_ == INT_TYPE); }\n\n  bool IsNumber() const { return (type_ == REAL_TYPE) || (type_ == INT_TYPE); }\n\n  bool IsReal() const { return (type_ == REAL_TYPE); }\n\n  bool IsString() const { return (type_ == STRING_TYPE); }\n\n  bool IsBinary() const { return (type_ == BINARY_TYPE); }\n\n  bool IsArray() const { return (type_ == ARRAY_TYPE); }\n\n  bool IsObject() const { return (type_ == OBJECT_TYPE); }\n\n  // Use this function if you want to have number value as double.\n  double GetNumberAsDouble() const {\n    if (type_ == INT_TYPE) {\n      return double(int_value_);\n    } else {\n      return real_value_;\n    }\n  }\n\n  // Use this function if you want to have number value as int.\n  // TODO(syoyo): Support int value larger than 32 bits\n  int GetNumberAsInt() const {\n    if (type_ == REAL_TYPE) {\n      return int(real_value_);\n    } else {\n      return int_value_;\n    }\n  }\n\n  // Accessor\n  template <typename T>\n  const T &Get() const;\n  template <typename T>\n  T &Get();\n\n  // Lookup value from an array\n  const Value &Get(int idx) const {\n    static Value null_value;\n    assert(IsArray());\n    assert(idx >= 0);\n    return (static_cast<size_t>(idx) < array_value_.size())\n               ? array_value_[static_cast<size_t>(idx)]\n               : null_value;\n  }\n\n  // Lookup value from a key-value pair\n  const Value &Get(const std::string &key) const {\n    static Value null_value;\n    assert(IsObject());\n    Object::const_iterator it = object_value_.find(key);\n    return (it != object_value_.end()) ? it->second : null_value;\n  }\n\n  size_t ArrayLen() const {\n    if (!IsArray()) return 0;\n    return array_value_.size();\n  }\n\n  // Valid only for object type.\n  bool Has(const std::string &key) const {\n    if (!IsObject()) return false;\n    Object::const_iterator it = object_value_.find(key);\n    return (it != object_value_.end()) ? true : false;\n  }\n\n  // List keys\n  std::vector<std::string> Keys() const {\n    std::vector<std::string> keys;\n    if (!IsObject()) return keys;  // empty\n\n    for (Object::const_iterator it = object_value_.begin();\n         it != object_value_.end(); ++it) {\n      keys.push_back(it->first);\n    }\n\n    return keys;\n  }\n\n  size_t Size() const { return (IsArray() ? ArrayLen() : Keys().size()); }\n\n  bool operator==(const tinygltf::Value &other) const;\n\n protected:\n  int type_ = NULL_TYPE;\n\n  int int_value_ = 0;\n  double real_value_ = 0.0;\n  std::string string_value_;\n  std::vector<unsigned char> binary_value_;\n  Array array_value_;\n  Object object_value_;\n  bool boolean_value_ = false;\n};\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n#define TINYGLTF_VALUE_GET(ctype, var)            \\\n  template <>                                     \\\n  inline const ctype &Value::Get<ctype>() const { \\\n    return var;                                   \\\n  }                                               \\\n  template <>                                     \\\n  inline ctype &Value::Get<ctype>() {             \\\n    return var;                                   \\\n  }\nTINYGLTF_VALUE_GET(bool, boolean_value_)\nTINYGLTF_VALUE_GET(double, real_value_)\nTINYGLTF_VALUE_GET(int, int_value_)\nTINYGLTF_VALUE_GET(std::string, string_value_)\nTINYGLTF_VALUE_GET(std::vector<unsigned char>, binary_value_)\nTINYGLTF_VALUE_GET(Value::Array, array_value_)\nTINYGLTF_VALUE_GET(Value::Object, object_value_)\n#undef TINYGLTF_VALUE_GET\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wc++98-compat\"\n#pragma clang diagnostic ignored \"-Wpadded\"\n#endif\n\n/// Agregate object for representing a color\nusing ColorValue = std::array<double, 4>;\n\n// === legacy interface ====\n// TODO(syoyo): Deprecate `Parameter` class.\nstruct Parameter {\n  bool bool_value = false;\n  bool has_number_value = false;\n  std::string string_value;\n  std::vector<double> number_array;\n  std::map<std::string, double> json_double_value;\n  double number_value = 0.0;\n\n  // context sensitive methods. depending the type of the Parameter you are\n  // accessing, these are either valid or not\n  // If this parameter represent a texture map in a material, will return the\n  // texture index\n\n  /// Return the index of a texture if this Parameter is a texture map.\n  /// Returned value is only valid if the parameter represent a texture from a\n  /// material\n  int TextureIndex() const {\n    const auto it = json_double_value.find(\"index\");\n    if (it != std::end(json_double_value)) {\n      return int(it->second);\n    }\n    return -1;\n  }\n\n  /// Return the index of a texture coordinate set if this Parameter is a\n  /// texture map. Returned value is only valid if the parameter represent a\n  /// texture from a material\n  int TextureTexCoord() const {\n    const auto it = json_double_value.find(\"texCoord\");\n    if (it != std::end(json_double_value)) {\n      return int(it->second);\n    }\n    // As per the spec, if texCoord is ommited, this parameter is 0\n    return 0;\n  }\n\n  /// Return the scale of a texture if this Parameter is a normal texture map.\n  /// Returned value is only valid if the parameter represent a normal texture\n  /// from a material\n  double TextureScale() const {\n    const auto it = json_double_value.find(\"scale\");\n    if (it != std::end(json_double_value)) {\n      return it->second;\n    }\n    // As per the spec, if scale is ommited, this paramter is 1\n    return 1;\n  }\n\n  /// Return the strength of a texture if this Parameter is a an occlusion map.\n  /// Returned value is only valid if the parameter represent an occlusion map\n  /// from a material\n  double TextureStrength() const {\n    const auto it = json_double_value.find(\"strength\");\n    if (it != std::end(json_double_value)) {\n      return it->second;\n    }\n    // As per the spec, if strenghth is ommited, this parameter is 1\n    return 1;\n  }\n\n  /// Material factor, like the roughness or metalness of a material\n  /// Returned value is only valid if the parameter represent a texture from a\n  /// material\n  double Factor() const { return number_value; }\n\n  /// Return the color of a material\n  /// Returned value is only valid if the parameter represent a texture from a\n  /// material\n  ColorValue ColorFactor() const {\n    return {\n        {// this agregate intialize the std::array object, and uses C++11 RVO.\n         number_array[0], number_array[1], number_array[2],\n         (number_array.size() > 3 ? number_array[3] : 1.0)}};\n  }\n\n  Parameter() = default;\n  DEFAULT_METHODS(Parameter)\n  bool operator==(const Parameter &) const;\n};\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wpadded\"\n#endif\n\ntypedef std::map<std::string, Parameter> ParameterMap;\ntypedef std::map<std::string, Value> ExtensionMap;\n\nstruct AnimationChannel {\n  int sampler;              // required\n  int target_node;          // required (index of the node to target)\n  std::string target_path;  // required in [\"translation\", \"rotation\", \"scale\",\n                            // \"weights\"]\n  Value extras;\n  ExtensionMap extensions;\n  ExtensionMap target_extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n  std::string target_extensions_json_string;\n\n  AnimationChannel() : sampler(-1), target_node(-1) {}\n  DEFAULT_METHODS(AnimationChannel)\n  bool operator==(const AnimationChannel &) const;\n};\n\nstruct AnimationSampler {\n  int input;                  // required\n  int output;                 // required\n  std::string interpolation;  // \"LINEAR\", \"STEP\",\"CUBICSPLINE\" or user defined\n                              // string. default \"LINEAR\"\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  AnimationSampler() : input(-1), output(-1), interpolation(\"LINEAR\") {}\n  DEFAULT_METHODS(AnimationSampler)\n  bool operator==(const AnimationSampler &) const;\n};\n\nstruct Animation {\n  std::string name;\n  std::vector<AnimationChannel> channels;\n  std::vector<AnimationSampler> samplers;\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  Animation() = default;\n  DEFAULT_METHODS(Animation)\n  bool operator==(const Animation &) const;\n};\n\nstruct Skin {\n  std::string name;\n  int inverseBindMatrices;  // required here but not in the spec\n  int skeleton;             // The index of the node used as a skeleton root\n  std::vector<int> joints;  // Indices of skeleton nodes\n\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  Skin() {\n    inverseBindMatrices = -1;\n    skeleton = -1;\n  }\n  DEFAULT_METHODS(Skin)\n  bool operator==(const Skin &) const;\n};\n\nstruct Sampler {\n  std::string name;\n  // glTF 2.0 spec does not define default value for `minFilter` and\n  // `magFilter`. Set -1 in TinyGLTF(issue #186)\n  int minFilter =\n      -1;  // optional. -1 = no filter defined. [\"NEAREST\", \"LINEAR\",\n           // \"NEAREST_MIPMAP_NEAREST\", \"LINEAR_MIPMAP_NEAREST\",\n           // \"NEAREST_MIPMAP_LINEAR\", \"LINEAR_MIPMAP_LINEAR\"]\n  int magFilter =\n      -1;  // optional. -1 = no filter defined. [\"NEAREST\", \"LINEAR\"]\n  int wrapS =\n      TINYGLTF_TEXTURE_WRAP_REPEAT;  // [\"CLAMP_TO_EDGE\", \"MIRRORED_REPEAT\",\n                                     // \"REPEAT\"], default \"REPEAT\"\n  int wrapT =\n      TINYGLTF_TEXTURE_WRAP_REPEAT;  // [\"CLAMP_TO_EDGE\", \"MIRRORED_REPEAT\",\n                                     // \"REPEAT\"], default \"REPEAT\"\n  //int wrapR = TINYGLTF_TEXTURE_WRAP_REPEAT;  // TinyGLTF extension. currently not used.\n\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  Sampler()\n      : minFilter(-1),\n        magFilter(-1),\n        wrapS(TINYGLTF_TEXTURE_WRAP_REPEAT),\n        wrapT(TINYGLTF_TEXTURE_WRAP_REPEAT) {}\n  DEFAULT_METHODS(Sampler)\n  bool operator==(const Sampler &) const;\n};\n\nstruct Image {\n  std::string name;\n  int width;\n  int height;\n  int component;\n  int bits;        // bit depth per channel. 8(byte), 16 or 32.\n  int pixel_type;  // pixel type(TINYGLTF_COMPONENT_TYPE_***). usually\n                   // UBYTE(bits = 8) or USHORT(bits = 16)\n  std::vector<unsigned char> image;\n  int bufferView;        // (required if no uri)\n  std::string mimeType;  // (required if no uri) [\"image/jpeg\", \"image/png\",\n                         // \"image/bmp\", \"image/gif\"]\n  std::string uri;       // (required if no mimeType) uri is not decoded(e.g.\n                         // whitespace may be represented as %20)\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  // When this flag is true, data is stored to `image` in as-is format(e.g. jpeg\n  // compressed for \"image/jpeg\" mime) This feature is good if you use custom\n  // image loader function. (e.g. delayed decoding of images for faster glTF\n  // parsing) Default parser for Image does not provide as-is loading feature at\n  // the moment. (You can manipulate this by providing your own LoadImageData\n  // function)\n  bool as_is;\n\n  Image() : as_is(false) {\n    bufferView = -1;\n    width = -1;\n    height = -1;\n    component = -1;\n    bits = -1;\n    pixel_type = -1;\n  }\n  DEFAULT_METHODS(Image)\n\n  bool operator==(const Image &) const;\n};\n\nstruct Texture {\n  std::string name;\n\n  int sampler;\n  int source;\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  Texture() : sampler(-1), source(-1) {}\n  DEFAULT_METHODS(Texture)\n\n  bool operator==(const Texture &) const;\n};\n\nstruct TextureInfo {\n  int index = -1;  // required.\n  int texCoord;    // The set index of texture's TEXCOORD attribute used for\n                   // texture coordinate mapping.\n\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  TextureInfo() : index(-1), texCoord(0) {}\n  DEFAULT_METHODS(TextureInfo)\n  bool operator==(const TextureInfo &) const;\n};\n\nstruct NormalTextureInfo {\n  int index = -1;  // required\n  int texCoord;    // The set index of texture's TEXCOORD attribute used for\n                   // texture coordinate mapping.\n  double scale;    // scaledNormal = normalize((<sampled normal texture value>\n                   // * 2.0 - 1.0) * vec3(<normal scale>, <normal scale>, 1.0))\n\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  NormalTextureInfo() : index(-1), texCoord(0), scale(1.0) {}\n  DEFAULT_METHODS(NormalTextureInfo)\n  bool operator==(const NormalTextureInfo &) const;\n};\n\nstruct OcclusionTextureInfo {\n  int index = -1;   // required\n  int texCoord;     // The set index of texture's TEXCOORD attribute used for\n                    // texture coordinate mapping.\n  double strength;  // occludedColor = lerp(color, color * <sampled occlusion\n                    // texture value>, <occlusion strength>)\n\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  OcclusionTextureInfo() : index(-1), texCoord(0), strength(1.0) {}\n  DEFAULT_METHODS(OcclusionTextureInfo)\n  bool operator==(const OcclusionTextureInfo &) const;\n};\n\n// pbrMetallicRoughness class defined in glTF 2.0 spec.\nstruct PbrMetallicRoughness {\n  std::vector<double> baseColorFactor;  // len = 4. default [1,1,1,1]\n  TextureInfo baseColorTexture;\n  double metallicFactor;   // default 1\n  double roughnessFactor;  // default 1\n  TextureInfo metallicRoughnessTexture;\n\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  PbrMetallicRoughness()\n      : baseColorFactor(std::vector<double>{1.0, 1.0, 1.0, 1.0}),\n        metallicFactor(1.0),\n        roughnessFactor(1.0) {}\n  DEFAULT_METHODS(PbrMetallicRoughness)\n  bool operator==(const PbrMetallicRoughness &) const;\n};\n\n// Each extension should be stored in a ParameterMap.\n// members not in the values could be included in the ParameterMap\n// to keep a single material model\nstruct Material {\n  std::string name;\n\n  std::vector<double> emissiveFactor;  // length 3. default [0, 0, 0]\n  std::string alphaMode;               // default \"OPAQUE\"\n  double alphaCutoff;                  // default 0.5\n  bool doubleSided;                    // default false;\n\n  PbrMetallicRoughness pbrMetallicRoughness;\n\n  NormalTextureInfo normalTexture;\n  OcclusionTextureInfo occlusionTexture;\n  TextureInfo emissiveTexture;\n\n  // For backward compatibility\n  // TODO(syoyo): Remove `values` and `additionalValues` in the next release.\n  ParameterMap values;\n  ParameterMap additionalValues;\n\n  ExtensionMap extensions;\n  Value extras;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  Material() : alphaMode(\"OPAQUE\"), alphaCutoff(0.5), doubleSided(false) {}\n  DEFAULT_METHODS(Material)\n\n  bool operator==(const Material &) const;\n};\n\nstruct BufferView {\n  std::string name;\n  int buffer{-1};        // Required\n  size_t byteOffset{0};  // minimum 0, default 0\n  size_t byteLength{0};  // required, minimum 1. 0 = invalid\n  size_t byteStride{0};  // minimum 4, maximum 252 (multiple of 4), default 0 =\n                         // understood to be tightly packed\n  int target{0};  // [\"ARRAY_BUFFER\", \"ELEMENT_ARRAY_BUFFER\"] for vertex indices\n                  // or atttribs. Could be 0 for other data\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  bool dracoDecoded{false};  // Flag indicating this has been draco decoded\n\n  BufferView()\n      : buffer(-1),\n        byteOffset(0),\n        byteLength(0),\n        byteStride(0),\n        target(0),\n        dracoDecoded(false) {}\n  DEFAULT_METHODS(BufferView)\n  bool operator==(const BufferView &) const;\n};\n\nstruct Accessor {\n  int bufferView;  // optional in spec but required here since sparse accessor\n                   // are not supported\n  std::string name;\n  size_t byteOffset;\n  bool normalized;    // optional.\n  int componentType;  // (required) One of TINYGLTF_COMPONENT_TYPE_***\n  size_t count;       // required\n  int type;           // (required) One of TINYGLTF_TYPE_***   ..\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  std::vector<double>\n      minValues;  // optional. integer value is promoted to double\n  std::vector<double>\n      maxValues;  // optional. integer value is promoted to double\n\n  struct {\n    int count;\n    bool isSparse;\n    struct {\n      int byteOffset;\n      int bufferView;\n      int componentType;  // a TINYGLTF_COMPONENT_TYPE_ value\n    } indices;\n    struct {\n      int bufferView;\n      int byteOffset;\n    } values;\n  } sparse;\n\n  ///\n  /// Utility function to compute byteStride for a given bufferView object.\n  /// Returns -1 upon invalid glTF value or parameter configuration.\n  ///\n  int ByteStride(const BufferView &bufferViewObject) const {\n    if (bufferViewObject.byteStride == 0) {\n      // Assume data is tightly packed.\n      int componentSizeInBytes =\n          GetComponentSizeInBytes(static_cast<uint32_t>(componentType));\n      if (componentSizeInBytes <= 0) {\n        return -1;\n      }\n\n      int numComponents = GetNumComponentsInType(static_cast<uint32_t>(type));\n      if (numComponents <= 0) {\n        return -1;\n      }\n\n      return componentSizeInBytes * numComponents;\n    } else {\n      // Check if byteStride is a mulple of the size of the accessor's component\n      // type.\n      int componentSizeInBytes =\n          GetComponentSizeInBytes(static_cast<uint32_t>(componentType));\n      if (componentSizeInBytes <= 0) {\n        return -1;\n      }\n\n      if ((bufferViewObject.byteStride % uint32_t(componentSizeInBytes)) != 0) {\n        return -1;\n      }\n      return static_cast<int>(bufferViewObject.byteStride);\n    }\n\n    // unreachable return 0;\n  }\n\n  Accessor()\n      : bufferView(-1),\n        byteOffset(0),\n        normalized(false),\n        componentType(-1),\n        count(0),\n        type(-1) {\n    sparse.isSparse = false;\n  }\n  DEFAULT_METHODS(Accessor)\n  bool operator==(const tinygltf::Accessor &) const;\n};\n\nstruct PerspectiveCamera {\n  double aspectRatio;  // min > 0\n  double yfov;         // required. min > 0\n  double zfar;         // min > 0\n  double znear;        // required. min > 0\n\n  PerspectiveCamera()\n      : aspectRatio(0.0),\n        yfov(0.0),\n        zfar(0.0)  // 0 = use infinite projecton matrix\n        ,\n        znear(0.0) {}\n  DEFAULT_METHODS(PerspectiveCamera)\n  bool operator==(const PerspectiveCamera &) const;\n\n  ExtensionMap extensions;\n  Value extras;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n};\n\nstruct OrthographicCamera {\n  double xmag;   // required. must not be zero.\n  double ymag;   // required. must not be zero.\n  double zfar;   // required. `zfar` must be greater than `znear`.\n  double znear;  // required\n\n  OrthographicCamera() : xmag(0.0), ymag(0.0), zfar(0.0), znear(0.0) {}\n  DEFAULT_METHODS(OrthographicCamera)\n  bool operator==(const OrthographicCamera &) const;\n\n  ExtensionMap extensions;\n  Value extras;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n};\n\nstruct Camera {\n  std::string type;  // required. \"perspective\" or \"orthographic\"\n  std::string name;\n\n  PerspectiveCamera perspective;\n  OrthographicCamera orthographic;\n\n  Camera() {}\n  DEFAULT_METHODS(Camera)\n  bool operator==(const Camera &) const;\n\n  ExtensionMap extensions;\n  Value extras;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n};\n\nstruct Primitive {\n  std::map<std::string, int> attributes;  // (required) A dictionary object of\n                                          // integer, where each integer\n                                          // is the index of the accessor\n                                          // containing an attribute.\n  int material;  // The index of the material to apply to this primitive\n                 // when rendering.\n  int indices;   // The index of the accessor that contains the indices.\n  int mode;      // one of TINYGLTF_MODE_***\n  std::vector<std::map<std::string, int> > targets;  // array of morph targets,\n  // where each target is a dict with attribues in [\"POSITION, \"NORMAL\",\n  // \"TANGENT\"] pointing\n  // to their corresponding accessors\n  ExtensionMap extensions;\n  Value extras;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  Primitive() {\n    material = -1;\n    indices = -1;\n    mode = -1;\n  }\n  DEFAULT_METHODS(Primitive)\n  bool operator==(const Primitive &) const;\n};\n\nstruct Mesh {\n  std::string name;\n  std::vector<Primitive> primitives;\n  std::vector<double> weights;  // weights to be applied to the Morph Targets\n  ExtensionMap extensions;\n  Value extras;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  Mesh() = default;\n  DEFAULT_METHODS(Mesh)\n  bool operator==(const Mesh &) const;\n};\n\nclass Node {\n public:\n  Node() : camera(-1), skin(-1), mesh(-1) {}\n\n  DEFAULT_METHODS(Node)\n\n  bool operator==(const Node &) const;\n\n  int camera;  // the index of the camera referenced by this node\n\n  std::string name;\n  int skin;\n  int mesh;\n  std::vector<int> children;\n  std::vector<double> rotation;     // length must be 0 or 4\n  std::vector<double> scale;        // length must be 0 or 3\n  std::vector<double> translation;  // length must be 0 or 3\n  std::vector<double> matrix;       // length must be 0 or 16\n  std::vector<double> weights;  // The weights of the instantiated Morph Target\n\n  ExtensionMap extensions;\n  Value extras;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n};\n\nstruct Buffer {\n  std::string name;\n  std::vector<unsigned char> data;\n  std::string\n      uri;  // considered as required here but not in the spec (need to clarify)\n            // uri is not decoded(e.g. whitespace may be represented as %20)\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  Buffer() = default;\n  DEFAULT_METHODS(Buffer)\n  bool operator==(const Buffer &) const;\n};\n\nstruct Asset {\n  std::string version = \"2.0\";  // required\n  std::string generator;\n  std::string minVersion;\n  std::string copyright;\n  ExtensionMap extensions;\n  Value extras;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  Asset() = default;\n  DEFAULT_METHODS(Asset)\n  bool operator==(const Asset &) const;\n};\n\nstruct Scene {\n  std::string name;\n  std::vector<int> nodes;\n\n  ExtensionMap extensions;\n  Value extras;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  Scene() = default;\n  DEFAULT_METHODS(Scene)\n  bool operator==(const Scene &) const;\n};\n\nstruct SpotLight {\n  double innerConeAngle;\n  double outerConeAngle;\n\n  SpotLight() : innerConeAngle(0.0), outerConeAngle(0.7853981634) {}\n  DEFAULT_METHODS(SpotLight)\n  bool operator==(const SpotLight &) const;\n\n  ExtensionMap extensions;\n  Value extras;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n};\n\nstruct Light {\n  std::string name;\n  std::vector<double> color;\n  double intensity{1.0};\n  std::string type;\n  double range{0.0};  // 0.0 = inifinite\n  SpotLight spot;\n\n  Light() : intensity(1.0), range(0.0) {}\n  DEFAULT_METHODS(Light)\n\n  bool operator==(const Light &) const;\n\n  ExtensionMap extensions;\n  Value extras;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n};\n\nclass Model {\n public:\n  Model() = default;\n  DEFAULT_METHODS(Model)\n\n  bool operator==(const Model &) const;\n\n  std::vector<Accessor> accessors;\n  std::vector<Animation> animations;\n  std::vector<Buffer> buffers;\n  std::vector<BufferView> bufferViews;\n  std::vector<Material> materials;\n  std::vector<Mesh> meshes;\n  std::vector<Node> nodes;\n  std::vector<Texture> textures;\n  std::vector<Image> images;\n  std::vector<Skin> skins;\n  std::vector<Sampler> samplers;\n  std::vector<Camera> cameras;\n  std::vector<Scene> scenes;\n  std::vector<Light> lights;\n\n  int defaultScene = -1;\n  std::vector<std::string> extensionsUsed;\n  std::vector<std::string> extensionsRequired;\n\n  Asset asset;\n\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n};\n\nenum SectionCheck {\n  NO_REQUIRE = 0x00,\n  REQUIRE_VERSION = 0x01,\n  REQUIRE_SCENE = 0x02,\n  REQUIRE_SCENES = 0x04,\n  REQUIRE_NODES = 0x08,\n  REQUIRE_ACCESSORS = 0x10,\n  REQUIRE_BUFFERS = 0x20,\n  REQUIRE_BUFFER_VIEWS = 0x40,\n  REQUIRE_ALL = 0x7f\n};\n\n///\n/// LoadImageDataFunction type. Signature for custom image loading callbacks.\n///\ntypedef bool (*LoadImageDataFunction)(Image *, const int, std::string *,\n                                      std::string *, int, int,\n                                      const unsigned char *, int,\n                                      void *user_pointer);\n\n///\n/// WriteImageDataFunction type. Signature for custom image writing callbacks.\n///\ntypedef bool (*WriteImageDataFunction)(const std::string *, const std::string *,\n                                       Image *, bool, void *);\n\n#ifndef TINYGLTF_NO_STB_IMAGE\n// Declaration of default image loader callback\nbool LoadImageData(Image *image, const int image_idx, std::string *err,\n                   std::string *warn, int req_width, int req_height,\n                   const unsigned char *bytes, int size, void *);\n#endif\n\n#ifndef TINYGLTF_NO_STB_IMAGE_WRITE\n// Declaration of default image writer callback\nbool WriteImageData(const std::string *basepath, const std::string *filename,\n                    Image *image, bool embedImages, void *);\n#endif\n\n///\n/// FilExistsFunction type. Signature for custom filesystem callbacks.\n///\ntypedef bool (*FileExistsFunction)(const std::string &abs_filename, void *);\n\n///\n/// ExpandFilePathFunction type. Signature for custom filesystem callbacks.\n///\ntypedef std::string (*ExpandFilePathFunction)(const std::string &, void *);\n\n///\n/// ReadWholeFileFunction type. Signature for custom filesystem callbacks.\n///\ntypedef bool (*ReadWholeFileFunction)(std::vector<unsigned char> *,\n                                      std::string *, const std::string &,\n                                      void *);\n\n///\n/// WriteWholeFileFunction type. Signature for custom filesystem callbacks.\n///\ntypedef bool (*WriteWholeFileFunction)(std::string *, const std::string &,\n                                       const std::vector<unsigned char> &,\n                                       void *);\n\n///\n/// A structure containing all required filesystem callbacks and a pointer to\n/// their user data.\n///\nstruct FsCallbacks {\n  FileExistsFunction FileExists;\n  ExpandFilePathFunction ExpandFilePath;\n  ReadWholeFileFunction ReadWholeFile;\n  WriteWholeFileFunction WriteWholeFile;\n\n  void *user_data;  // An argument that is passed to all fs callbacks\n};\n\n#ifndef TINYGLTF_NO_FS\n// Declaration of default filesystem callbacks\n\nbool FileExists(const std::string &abs_filename, void *);\n\n///\n/// Expand file path(e.g. `~` to home directory on posix, `%APPDATA%` to\n/// `C:\\\\Users\\\\tinygltf\\\\AppData`)\n///\n/// @param[in] filepath File path string. Assume UTF-8\n/// @param[in] userdata User data. Set to `nullptr` if you don't need it.\n///\nstd::string ExpandFilePath(const std::string &filepath, void *userdata);\n\nbool ReadWholeFile(std::vector<unsigned char> *out, std::string *err,\n                   const std::string &filepath, void *);\n\nbool WriteWholeFile(std::string *err, const std::string &filepath,\n                    const std::vector<unsigned char> &contents, void *);\n#endif\n\n///\n/// glTF Parser/Serialier context.\n///\nclass TinyGLTF {\n public:\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wc++98-compat\"\n#endif\n\n  TinyGLTF() : bin_data_(nullptr), bin_size_(0), is_binary_(false) {}\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n  ~TinyGLTF() {}\n\n  ///\n  /// Loads glTF ASCII asset from a file.\n  /// Set warning message to `warn` for example it fails to load asserts.\n  /// Returns false and set error string to `err` if there's an error.\n  ///\n  bool LoadASCIIFromFile(Model *model, std::string *err, std::string *warn,\n                         const std::string &filename,\n                         unsigned int check_sections = REQUIRE_VERSION);\n\n  ///\n  /// Loads glTF ASCII asset from string(memory).\n  /// `length` = strlen(str);\n  /// Set warning message to `warn` for example it fails to load asserts.\n  /// Returns false and set error string to `err` if there's an error.\n  ///\n  bool LoadASCIIFromString(Model *model, std::string *err, std::string *warn,\n                           const char *str, const unsigned int length,\n                           const std::string &base_dir,\n                           unsigned int check_sections = REQUIRE_VERSION);\n\n  ///\n  /// Loads glTF binary asset from a file.\n  /// Set warning message to `warn` for example it fails to load asserts.\n  /// Returns false and set error string to `err` if there's an error.\n  ///\n  bool LoadBinaryFromFile(Model *model, std::string *err, std::string *warn,\n                          const std::string &filename,\n                          unsigned int check_sections = REQUIRE_VERSION);\n\n  ///\n  /// Loads glTF binary asset from memory.\n  /// `length` = strlen(str);\n  /// Set warning message to `warn` for example it fails to load asserts.\n  /// Returns false and set error string to `err` if there's an error.\n  ///\n  bool LoadBinaryFromMemory(Model *model, std::string *err, std::string *warn,\n                            const unsigned char *bytes,\n                            const unsigned int length,\n                            const std::string &base_dir = \"\",\n                            unsigned int check_sections = REQUIRE_VERSION);\n\n  ///\n  /// Write glTF to stream, buffers and images will be embeded\n  ///\n  bool WriteGltfSceneToStream(Model *model, std::ostream &stream,\n                              bool prettyPrint, bool writeBinary);\n\n  ///\n  /// Write glTF to file.\n  ///\n  bool WriteGltfSceneToFile(Model *model, const std::string &filename,\n                            bool embedImages, bool embedBuffers,\n                            bool prettyPrint, bool writeBinary);\n\n  ///\n  /// Set callback to use for loading image data\n  ///\n  void SetImageLoader(LoadImageDataFunction LoadImageData, void *user_data);\n\n  ///\n  /// Unset(remove) callback of loading image data\n  ///\n  void RemoveImageLoader();\n\n  ///\n  /// Set callback to use for writing image data\n  ///\n  void SetImageWriter(WriteImageDataFunction WriteImageData, void *user_data);\n\n  ///\n  /// Set callbacks to use for filesystem (fs) access and their user data\n  ///\n  void SetFsCallbacks(FsCallbacks callbacks);\n\n  ///\n  /// Set serializing default values(default = false).\n  /// When true, default values are force serialized to .glTF.\n  /// This may be helpfull if you want to serialize a full description of glTF\n  /// data.\n  ///\n  /// TODO(LTE): Supply parsing option as function arguments to\n  /// `LoadASCIIFromFile()` and others, not by a class method\n  ///\n  void SetSerializeDefaultValues(const bool enabled) {\n    serialize_default_values_ = enabled;\n  }\n\n  bool GetSerializeDefaultValues() const { return serialize_default_values_; }\n\n  ///\n  /// Store original JSON string for `extras` and `extensions`.\n  /// This feature will be useful when the user want to reconstruct custom data\n  /// structure from JSON string.\n  ///\n  void SetStoreOriginalJSONForExtrasAndExtensions(const bool enabled) {\n    store_original_json_for_extras_and_extensions_ = enabled;\n  }\n\n  bool GetStoreOriginalJSONForExtrasAndExtensions() const {\n    return store_original_json_for_extras_and_extensions_;\n  }\n\n  ///\n  /// Specify whether preserve image channales when loading images or not.\n  /// (Not effective when the user suppy their own LoadImageData callbacks)\n  ///\n  void SetPreserveImageChannels(bool onoff) {\n    preserve_image_channels_ = onoff;\n  }\n\n  bool GetPreserveImageChannels() const { return preserve_image_channels_; }\n\n private:\n  ///\n  /// Loads glTF asset from string(memory).\n  /// `length` = strlen(str);\n  /// Set warning message to `warn` for example it fails to load asserts\n  /// Returns false and set error string to `err` if there's an error.\n  ///\n  bool LoadFromString(Model *model, std::string *err, std::string *warn,\n                      const char *str, const unsigned int length,\n                      const std::string &base_dir, unsigned int check_sections);\n\n  const unsigned char *bin_data_ = nullptr;\n  size_t bin_size_ = 0;\n  bool is_binary_ = false;\n\n  bool serialize_default_values_ = false;  ///< Serialize default values?\n\n  bool store_original_json_for_extras_and_extensions_ = false;\n\n  bool preserve_image_channels_ = false;  /// Default false(expand channels to\n                                          /// RGBA) for backward compatibility.\n\n  FsCallbacks fs = {\n#ifndef TINYGLTF_NO_FS\n      &tinygltf::FileExists, &tinygltf::ExpandFilePath,\n      &tinygltf::ReadWholeFile, &tinygltf::WriteWholeFile,\n\n      nullptr  // Fs callback user data\n#else\n      nullptr, nullptr, nullptr, nullptr,\n\n      nullptr  // Fs callback user data\n#endif\n  };\n\n  LoadImageDataFunction LoadImageData =\n#ifndef TINYGLTF_NO_STB_IMAGE\n      &tinygltf::LoadImageData;\n#else\n      nullptr;\n#endif\n  void *load_image_user_data_{nullptr};\n  bool user_image_loader_{false};\n\n  WriteImageDataFunction WriteImageData =\n#ifndef TINYGLTF_NO_STB_IMAGE_WRITE\n      &tinygltf::WriteImageData;\n#else\n      nullptr;\n#endif\n  void *write_image_user_data_{nullptr};\n};\n\n#ifdef __clang__\n#pragma clang diagnostic pop  // -Wpadded\n#endif\n\n}  // namespace tinygltf\n\n#endif  // TINY_GLTF_H_\n\n#if defined(TINYGLTF_IMPLEMENTATION) || defined(__INTELLISENSE__)\n#include <algorithm>\n//#include <cassert>\n#ifndef TINYGLTF_NO_FS\n#include <cstdio>\n#include <fstream>\n#endif\n#include <sstream>\n\n#ifdef __clang__\n// Disable some warnings for external files.\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wfloat-equal\"\n#pragma clang diagnostic ignored \"-Wexit-time-destructors\"\n#pragma clang diagnostic ignored \"-Wconversion\"\n#pragma clang diagnostic ignored \"-Wold-style-cast\"\n#pragma clang diagnostic ignored \"-Wglobal-constructors\"\n#if __has_warning(\"-Wreserved-id-macro\")\n#pragma clang diagnostic ignored \"-Wreserved-id-macro\"\n#endif\n#pragma clang diagnostic ignored \"-Wdisabled-macro-expansion\"\n#pragma clang diagnostic ignored \"-Wpadded\"\n#pragma clang diagnostic ignored \"-Wc++98-compat\"\n#pragma clang diagnostic ignored \"-Wc++98-compat-pedantic\"\n#pragma clang diagnostic ignored \"-Wdocumentation-unknown-command\"\n#pragma clang diagnostic ignored \"-Wswitch-enum\"\n#pragma clang diagnostic ignored \"-Wimplicit-fallthrough\"\n#pragma clang diagnostic ignored \"-Wweak-vtables\"\n#pragma clang diagnostic ignored \"-Wcovered-switch-default\"\n#if __has_warning(\"-Wdouble-promotion\")\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"\n#endif\n#if __has_warning(\"-Wcomma\")\n#pragma clang diagnostic ignored \"-Wcomma\"\n#endif\n#if __has_warning(\"-Wzero-as-null-pointer-constant\")\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"\n#endif\n#if __has_warning(\"-Wcast-qual\")\n#pragma clang diagnostic ignored \"-Wcast-qual\"\n#endif\n#if __has_warning(\"-Wmissing-variable-declarations\")\n#pragma clang diagnostic ignored \"-Wmissing-variable-declarations\"\n#endif\n#if __has_warning(\"-Wmissing-prototypes\")\n#pragma clang diagnostic ignored \"-Wmissing-prototypes\"\n#endif\n#if __has_warning(\"-Wcast-align\")\n#pragma clang diagnostic ignored \"-Wcast-align\"\n#endif\n#if __has_warning(\"-Wnewline-eof\")\n#pragma clang diagnostic ignored \"-Wnewline-eof\"\n#endif\n#if __has_warning(\"-Wunused-parameter\")\n#pragma clang diagnostic ignored \"-Wunused-parameter\"\n#endif\n#if __has_warning(\"-Wmismatched-tags\")\n#pragma clang diagnostic ignored \"-Wmismatched-tags\"\n#endif\n#if __has_warning(\"-Wextra-semi-stmt\")\n#pragma clang diagnostic ignored \"-Wextra-semi-stmt\"\n#endif\n#endif\n\n// Disable GCC warnigs\n#ifdef __GNUC__\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wtype-limits\"\n#endif  // __GNUC__\n\n#ifndef TINYGLTF_NO_INCLUDE_JSON\n#ifndef TINYGLTF_USE_RAPIDJSON\n#include \"json.hpp\"\n#else\n#ifndef TINYGLTF_NO_INCLUDE_RAPIDJSON\n#include \"document.h\"\n#include \"prettywriter.h\"\n#include \"rapidjson.h\"\n#include \"stringbuffer.h\"\n#include \"writer.h\"\n#endif\n#endif\n#endif\n\n#ifdef TINYGLTF_ENABLE_DRACO\n#include \"draco/compression/decode.h\"\n#include \"draco/core/decoder_buffer.h\"\n#endif\n\n#ifndef TINYGLTF_NO_STB_IMAGE\n#ifndef TINYGLTF_NO_INCLUDE_STB_IMAGE\n#include \"stb_image.h\"\n#endif\n#endif\n\n#ifndef TINYGLTF_NO_STB_IMAGE_WRITE\n#ifndef TINYGLTF_NO_INCLUDE_STB_IMAGE_WRITE\n#include \"stb_image_write.h\"\n#endif\n#endif\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n#ifdef __GNUC__\n#pragma GCC diagnostic pop\n#endif\n\n#ifdef _WIN32\n\n// issue 143.\n// Define NOMINMAX to avoid min/max defines,\n// but undef it after included windows.h\n#ifndef NOMINMAX\n#define TINYGLTF_INTERNAL_NOMINMAX\n#define NOMINMAX\n#endif\n\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#define TINYGLTF_INTERNAL_WIN32_LEAN_AND_MEAN\n#endif\n#include <windows.h>  // include API for expanding a file path\n\n#ifdef TINYGLTF_INTERNAL_WIN32_LEAN_AND_MEAN\n#undef WIN32_LEAN_AND_MEAN\n#endif\n\n#if defined(TINYGLTF_INTERNAL_NOMINMAX)\n#undef NOMINMAX\n#endif\n\n#if defined(__GLIBCXX__)  // mingw\n\n#include <fcntl.h>  // _O_RDONLY\n\n#include <ext/stdio_filebuf.h>  // fstream (all sorts of IO stuff) + stdio_filebuf (=streambuf)\n\n#endif\n\n#elif !defined(__ANDROID__) && !defined(__OpenBSD__)\n#include <wordexp.h>\n#endif\n\n#if defined(__sparcv9) || defined(__powerpc__)\n// Big endian\n#else\n#if (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) || MINIZ_X86_OR_X64_CPU\n#define TINYGLTF_LITTLE_ENDIAN 1\n#endif\n#endif\n\nnamespace {\n#ifdef TINYGLTF_USE_RAPIDJSON\n\n#ifdef TINYGLTF_USE_RAPIDJSON_CRTALLOCATOR\n// This uses the RapidJSON CRTAllocator.  It is thread safe and multiple\n// documents may be active at once.\nusing json =\n    rapidjson::GenericValue<rapidjson::UTF8<>, rapidjson::CrtAllocator>;\nusing json_const_iterator = json::ConstMemberIterator;\nusing json_const_array_iterator = json const *;\nusing JsonDocument =\n    rapidjson::GenericDocument<rapidjson::UTF8<>, rapidjson::CrtAllocator>;\nrapidjson::CrtAllocator s_CrtAllocator;  // stateless and thread safe\nrapidjson::CrtAllocator &GetAllocator() { return s_CrtAllocator; }\n#else\n// This uses the default RapidJSON MemoryPoolAllocator.  It is very fast, but\n// not thread safe. Only a single JsonDocument may be active at any one time,\n// meaning only a single gltf load/save can be active any one time.\nusing json = rapidjson::Value;\nusing json_const_iterator = json::ConstMemberIterator;\nusing json_const_array_iterator = json const *;\nrapidjson::Document *s_pActiveDocument = nullptr;\nrapidjson::Document::AllocatorType &GetAllocator() {\n  assert(s_pActiveDocument);  // Root json node must be JsonDocument type\n  return s_pActiveDocument->GetAllocator();\n}\n\n#ifdef __clang__\n#pragma clang diagnostic push\n// Suppress JsonDocument(JsonDocument &&rhs) noexcept\n#pragma clang diagnostic ignored \"-Wunused-member-function\"\n#endif\n\nstruct JsonDocument : public rapidjson::Document {\n  JsonDocument() {\n    assert(s_pActiveDocument ==\n           nullptr);  // When using default allocator, only one document can be\n                      // active at a time, if you need multiple active at once,\n                      // define TINYGLTF_USE_RAPIDJSON_CRTALLOCATOR\n    s_pActiveDocument = this;\n  }\n  JsonDocument(const JsonDocument &) = delete;\n  JsonDocument(JsonDocument &&rhs) noexcept\n      : rapidjson::Document(std::move(rhs)) {\n    s_pActiveDocument = this;\n    rhs.isNil = true;\n  }\n  ~JsonDocument() {\n    if (!isNil) {\n      s_pActiveDocument = nullptr;\n    }\n  }\n\n private:\n  bool isNil = false;\n};\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n#endif  // TINYGLTF_USE_RAPIDJSON_CRTALLOCATOR\n\n#else\nusing nlohmann::json;\nusing json_const_iterator = json::const_iterator;\nusing json_const_array_iterator = json_const_iterator;\nusing JsonDocument = json;\n#endif\n\nvoid JsonParse(JsonDocument &doc, const char *str, size_t length,\n               bool throwExc = false) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  (void)throwExc;\n  doc.Parse(str, length);\n#else\n  doc = json::parse(str, str + length, nullptr, throwExc);\n#endif\n}\n}  // namespace\n\n#ifdef __APPLE__\n#include \"TargetConditionals.h\"\n#endif\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wc++98-compat\"\n#endif\n\nnamespace tinygltf {\n\n///\n/// Internal LoadImageDataOption struct.\n/// This struct is passed through `user_pointer` in LoadImageData.\n/// The struct is not passed when the user supply their own LoadImageData\n/// callbacks.\n///\nstruct LoadImageDataOption {\n  // true: preserve image channels(e.g. load as RGB image if the image has RGB\n  // channels) default `false`(channels are expanded to RGBA for backward\n  // compatiblity).\n  bool preserve_channels{false};\n};\n\n// Equals function for Value, for recursivity\nstatic bool Equals(const tinygltf::Value &one, const tinygltf::Value &other) {\n  if (one.Type() != other.Type()) return false;\n\n  switch (one.Type()) {\n    case NULL_TYPE:\n      return true;\n    case BOOL_TYPE:\n      return one.Get<bool>() == other.Get<bool>();\n    case REAL_TYPE:\n      return TINYGLTF_DOUBLE_EQUAL(one.Get<double>(), other.Get<double>());\n    case INT_TYPE:\n      return one.Get<int>() == other.Get<int>();\n    case OBJECT_TYPE: {\n      auto oneObj = one.Get<tinygltf::Value::Object>();\n      auto otherObj = other.Get<tinygltf::Value::Object>();\n      if (oneObj.size() != otherObj.size()) return false;\n      for (auto &it : oneObj) {\n        auto otherIt = otherObj.find(it.first);\n        if (otherIt == otherObj.end()) return false;\n\n        if (!Equals(it.second, otherIt->second)) return false;\n      }\n      return true;\n    }\n    case ARRAY_TYPE: {\n      if (one.Size() != other.Size()) return false;\n      for (int i = 0; i < int(one.Size()); ++i)\n        if (!Equals(one.Get(i), other.Get(i))) return false;\n      return true;\n    }\n    case STRING_TYPE:\n      return one.Get<std::string>() == other.Get<std::string>();\n    case BINARY_TYPE:\n      return one.Get<std::vector<unsigned char> >() ==\n             other.Get<std::vector<unsigned char> >();\n    default: {\n      // unhandled type\n      return false;\n    }\n  }\n}\n\n// Equals function for std::vector<double> using TINYGLTF_DOUBLE_EPSILON\nstatic bool Equals(const std::vector<double> &one,\n                   const std::vector<double> &other) {\n  if (one.size() != other.size()) return false;\n  for (int i = 0; i < int(one.size()); ++i) {\n    if (!TINYGLTF_DOUBLE_EQUAL(one[size_t(i)], other[size_t(i)])) return false;\n  }\n  return true;\n}\n\nbool Accessor::operator==(const Accessor &other) const {\n  return this->bufferView == other.bufferView &&\n         this->byteOffset == other.byteOffset &&\n         this->componentType == other.componentType &&\n         this->count == other.count && this->extensions == other.extensions &&\n         this->extras == other.extras &&\n         Equals(this->maxValues, other.maxValues) &&\n         Equals(this->minValues, other.minValues) && this->name == other.name &&\n         this->normalized == other.normalized && this->type == other.type;\n}\nbool Animation::operator==(const Animation &other) const {\n  return this->channels == other.channels &&\n         this->extensions == other.extensions && this->extras == other.extras &&\n         this->name == other.name && this->samplers == other.samplers;\n}\nbool AnimationChannel::operator==(const AnimationChannel &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->target_node == other.target_node &&\n         this->target_path == other.target_path &&\n         this->sampler == other.sampler;\n}\nbool AnimationSampler::operator==(const AnimationSampler &other) const {\n  return this->extras == other.extras && this->extensions == other.extensions &&\n         this->input == other.input &&\n         this->interpolation == other.interpolation &&\n         this->output == other.output;\n}\nbool Asset::operator==(const Asset &other) const {\n  return this->copyright == other.copyright &&\n         this->extensions == other.extensions && this->extras == other.extras &&\n         this->generator == other.generator &&\n         this->minVersion == other.minVersion && this->version == other.version;\n}\nbool Buffer::operator==(const Buffer &other) const {\n  return this->data == other.data && this->extensions == other.extensions &&\n         this->extras == other.extras && this->name == other.name &&\n         this->uri == other.uri;\n}\nbool BufferView::operator==(const BufferView &other) const {\n  return this->buffer == other.buffer && this->byteLength == other.byteLength &&\n         this->byteOffset == other.byteOffset &&\n         this->byteStride == other.byteStride && this->name == other.name &&\n         this->target == other.target && this->extensions == other.extensions &&\n         this->extras == other.extras &&\n         this->dracoDecoded == other.dracoDecoded;\n}\nbool Camera::operator==(const Camera &other) const {\n  return this->name == other.name && this->extensions == other.extensions &&\n         this->extras == other.extras &&\n         this->orthographic == other.orthographic &&\n         this->perspective == other.perspective && this->type == other.type;\n}\nbool Image::operator==(const Image &other) const {\n  return this->bufferView == other.bufferView &&\n         this->component == other.component &&\n         this->extensions == other.extensions && this->extras == other.extras &&\n         this->height == other.height && this->image == other.image &&\n         this->mimeType == other.mimeType && this->name == other.name &&\n         this->uri == other.uri && this->width == other.width;\n}\nbool Light::operator==(const Light &other) const {\n  return Equals(this->color, other.color) && this->name == other.name &&\n         this->type == other.type;\n}\nbool Material::operator==(const Material &other) const {\n  return (this->pbrMetallicRoughness == other.pbrMetallicRoughness) &&\n         (this->normalTexture == other.normalTexture) &&\n         (this->occlusionTexture == other.occlusionTexture) &&\n         (this->emissiveTexture == other.emissiveTexture) &&\n         Equals(this->emissiveFactor, other.emissiveFactor) &&\n         (this->alphaMode == other.alphaMode) &&\n         TINYGLTF_DOUBLE_EQUAL(this->alphaCutoff, other.alphaCutoff) &&\n         (this->doubleSided == other.doubleSided) &&\n         (this->extensions == other.extensions) &&\n         (this->extras == other.extras) && (this->values == other.values) &&\n         (this->additionalValues == other.additionalValues) &&\n         (this->name == other.name);\n}\nbool Mesh::operator==(const Mesh &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->name == other.name && Equals(this->weights, other.weights) &&\n         this->primitives == other.primitives;\n}\nbool Model::operator==(const Model &other) const {\n  return this->accessors == other.accessors &&\n         this->animations == other.animations && this->asset == other.asset &&\n         this->buffers == other.buffers &&\n         this->bufferViews == other.bufferViews &&\n         this->cameras == other.cameras &&\n         this->defaultScene == other.defaultScene &&\n         this->extensions == other.extensions &&\n         this->extensionsRequired == other.extensionsRequired &&\n         this->extensionsUsed == other.extensionsUsed &&\n         this->extras == other.extras && this->images == other.images &&\n         this->lights == other.lights && this->materials == other.materials &&\n         this->meshes == other.meshes && this->nodes == other.nodes &&\n         this->samplers == other.samplers && this->scenes == other.scenes &&\n         this->skins == other.skins && this->textures == other.textures;\n}\nbool Node::operator==(const Node &other) const {\n  return this->camera == other.camera && this->children == other.children &&\n         this->extensions == other.extensions && this->extras == other.extras &&\n         Equals(this->matrix, other.matrix) && this->mesh == other.mesh &&\n         this->name == other.name && Equals(this->rotation, other.rotation) &&\n         Equals(this->scale, other.scale) && this->skin == other.skin &&\n         Equals(this->translation, other.translation) &&\n         Equals(this->weights, other.weights);\n}\nbool SpotLight::operator==(const SpotLight &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         TINYGLTF_DOUBLE_EQUAL(this->innerConeAngle, other.innerConeAngle) &&\n         TINYGLTF_DOUBLE_EQUAL(this->outerConeAngle, other.outerConeAngle);\n}\nbool OrthographicCamera::operator==(const OrthographicCamera &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         TINYGLTF_DOUBLE_EQUAL(this->xmag, other.xmag) &&\n         TINYGLTF_DOUBLE_EQUAL(this->ymag, other.ymag) &&\n         TINYGLTF_DOUBLE_EQUAL(this->zfar, other.zfar) &&\n         TINYGLTF_DOUBLE_EQUAL(this->znear, other.znear);\n}\nbool Parameter::operator==(const Parameter &other) const {\n  if (this->bool_value != other.bool_value ||\n      this->has_number_value != other.has_number_value)\n    return false;\n\n  if (!TINYGLTF_DOUBLE_EQUAL(this->number_value, other.number_value))\n    return false;\n\n  if (this->json_double_value.size() != other.json_double_value.size())\n    return false;\n  for (auto &it : this->json_double_value) {\n    auto otherIt = other.json_double_value.find(it.first);\n    if (otherIt == other.json_double_value.end()) return false;\n\n    if (!TINYGLTF_DOUBLE_EQUAL(it.second, otherIt->second)) return false;\n  }\n\n  if (!Equals(this->number_array, other.number_array)) return false;\n\n  if (this->string_value != other.string_value) return false;\n\n  return true;\n}\nbool PerspectiveCamera::operator==(const PerspectiveCamera &other) const {\n  return TINYGLTF_DOUBLE_EQUAL(this->aspectRatio, other.aspectRatio) &&\n         this->extensions == other.extensions && this->extras == other.extras &&\n         TINYGLTF_DOUBLE_EQUAL(this->yfov, other.yfov) &&\n         TINYGLTF_DOUBLE_EQUAL(this->zfar, other.zfar) &&\n         TINYGLTF_DOUBLE_EQUAL(this->znear, other.znear);\n}\nbool Primitive::operator==(const Primitive &other) const {\n  return this->attributes == other.attributes && this->extras == other.extras &&\n         this->indices == other.indices && this->material == other.material &&\n         this->mode == other.mode && this->targets == other.targets;\n}\nbool Sampler::operator==(const Sampler &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->magFilter == other.magFilter &&\n         this->minFilter == other.minFilter && this->name == other.name &&\n         this->wrapS == other.wrapS &&\n         this->wrapT == other.wrapT;\n\n         //this->wrapR == other.wrapR\n}\nbool Scene::operator==(const Scene &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->name == other.name && this->nodes == other.nodes;\n}\nbool Skin::operator==(const Skin &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->inverseBindMatrices == other.inverseBindMatrices &&\n         this->joints == other.joints && this->name == other.name &&\n         this->skeleton == other.skeleton;\n}\nbool Texture::operator==(const Texture &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->name == other.name && this->sampler == other.sampler &&\n         this->source == other.source;\n}\nbool TextureInfo::operator==(const TextureInfo &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->index == other.index && this->texCoord == other.texCoord;\n}\nbool NormalTextureInfo::operator==(const NormalTextureInfo &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->index == other.index && this->texCoord == other.texCoord &&\n         TINYGLTF_DOUBLE_EQUAL(this->scale, other.scale);\n}\nbool OcclusionTextureInfo::operator==(const OcclusionTextureInfo &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->index == other.index && this->texCoord == other.texCoord &&\n         TINYGLTF_DOUBLE_EQUAL(this->strength, other.strength);\n}\nbool PbrMetallicRoughness::operator==(const PbrMetallicRoughness &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         (this->baseColorTexture == other.baseColorTexture) &&\n         (this->metallicRoughnessTexture == other.metallicRoughnessTexture) &&\n         Equals(this->baseColorFactor, other.baseColorFactor) &&\n         TINYGLTF_DOUBLE_EQUAL(this->metallicFactor, other.metallicFactor) &&\n         TINYGLTF_DOUBLE_EQUAL(this->roughnessFactor, other.roughnessFactor);\n}\nbool Value::operator==(const Value &other) const {\n  return Equals(*this, other);\n}\n\nstatic void swap4(unsigned int *val) {\n#ifdef TINYGLTF_LITTLE_ENDIAN\n  (void)val;\n#else\n  unsigned int tmp = *val;\n  unsigned char *dst = reinterpret_cast<unsigned char *>(val);\n  unsigned char *src = reinterpret_cast<unsigned char *>(&tmp);\n\n  dst[0] = src[3];\n  dst[1] = src[2];\n  dst[2] = src[1];\n  dst[3] = src[0];\n#endif\n}\n\nstatic std::string JoinPath(const std::string &path0,\n                            const std::string &path1) {\n  if (path0.empty()) {\n    return path1;\n  } else {\n    // check '/'\n    char lastChar = *path0.rbegin();\n    if (lastChar != '/') {\n      return path0 + std::string(\"/\") + path1;\n    } else {\n      return path0 + path1;\n    }\n  }\n}\n\nstatic std::string FindFile(const std::vector<std::string> &paths,\n                            const std::string &filepath, FsCallbacks *fs) {\n  if (fs == nullptr || fs->ExpandFilePath == nullptr ||\n      fs->FileExists == nullptr) {\n    // Error, fs callback[s] missing\n    return std::string();\n  }\n\n  for (size_t i = 0; i < paths.size(); i++) {\n    std::string absPath =\n        fs->ExpandFilePath(JoinPath(paths[i], filepath), fs->user_data);\n    if (fs->FileExists(absPath, fs->user_data)) {\n      return absPath;\n    }\n  }\n\n  return std::string();\n}\n\nstatic std::string GetFilePathExtension(const std::string &FileName) {\n  if (FileName.find_last_of(\".\") != std::string::npos)\n    return FileName.substr(FileName.find_last_of(\".\") + 1);\n  return \"\";\n}\n\nstatic std::string GetBaseDir(const std::string &filepath) {\n  if (filepath.find_last_of(\"/\\\\\") != std::string::npos)\n    return filepath.substr(0, filepath.find_last_of(\"/\\\\\"));\n  return \"\";\n}\n\nstatic std::string GetBaseFilename(const std::string &filepath) {\n  auto idx = filepath.find_last_of(\"/\\\\\");\n  if (idx != std::string::npos)\n    return filepath.substr(idx + 1);\n  return filepath;\n}\n\nstd::string base64_encode(unsigned char const *, unsigned int len);\nstd::string base64_decode(std::string const &s);\n\n/*\n   base64.cpp and base64.h\n\n   Copyright (C) 2004-2008 Ren\u00e9 Nyffenegger\n\n   This source code is provided 'as-is', without any express or implied\n   warranty. In no event will the author be held liable for any damages\n   arising from the use of this software.\n\n   Permission is granted to anyone to use this software for any purpose,\n   including commercial applications, and to alter it and redistribute it\n   freely, subject to the following restrictions:\n\n   1. The origin of this source code must not be misrepresented; you must not\n      claim that you wrote the original source code. If you use this source code\n      in a product, an acknowledgment in the product documentation would be\n      appreciated but is not required.\n\n   2. Altered source versions must be plainly marked as such, and must not be\n      misrepresented as being the original source code.\n\n   3. This notice may not be removed or altered from any source distribution.\n\n   Ren\u00e9 Nyffenegger rene.nyffenegger@adp-gmbh.ch\n\n*/\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wsign-conversion\"\n#pragma clang diagnostic ignored \"-Wconversion\"\n#endif\n\nstatic inline bool is_base64(unsigned char c) {\n  return (isalnum(c) || (c == '+') || (c == '/'));\n}\n\nstd::string base64_encode(unsigned char const *bytes_to_encode,\n                          unsigned int in_len) {\n  std::string ret;\n  int i = 0;\n  int j = 0;\n  unsigned char char_array_3[3];\n  unsigned char char_array_4[4];\n\n  const char *base64_chars =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n      \"abcdefghijklmnopqrstuvwxyz\"\n      \"0123456789+/\";\n\n  while (in_len--) {\n    char_array_3[i++] = *(bytes_to_encode++);\n    if (i == 3) {\n      char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;\n      char_array_4[1] =\n          ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);\n      char_array_4[2] =\n          ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);\n      char_array_4[3] = char_array_3[2] & 0x3f;\n\n      for (i = 0; (i < 4); i++) ret += base64_chars[char_array_4[i]];\n      i = 0;\n    }\n  }\n\n  if (i) {\n    for (j = i; j < 3; j++) char_array_3[j] = '\\0';\n\n    char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;\n    char_array_4[1] =\n        ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);\n    char_array_4[2] =\n        ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);\n\n    for (j = 0; (j < i + 1); j++) ret += base64_chars[char_array_4[j]];\n\n    while ((i++ < 3)) ret += '=';\n  }\n\n  return ret;\n}\n\nstd::string base64_decode(std::string const &encoded_string) {\n  int in_len = static_cast<int>(encoded_string.size());\n  int i = 0;\n  int j = 0;\n  int in_ = 0;\n  unsigned char char_array_4[4], char_array_3[3];\n  std::string ret;\n\n  const std::string base64_chars =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n      \"abcdefghijklmnopqrstuvwxyz\"\n      \"0123456789+/\";\n\n  while (in_len-- && (encoded_string[in_] != '=') &&\n         is_base64(encoded_string[in_])) {\n    char_array_4[i++] = encoded_string[in_];\n    in_++;\n    if (i == 4) {\n      for (i = 0; i < 4; i++)\n        char_array_4[i] =\n            static_cast<unsigned char>(base64_chars.find(char_array_4[i]));\n\n      char_array_3[0] =\n          (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);\n      char_array_3[1] =\n          ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);\n      char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];\n\n      for (i = 0; (i < 3); i++) ret += char_array_3[i];\n      i = 0;\n    }\n  }\n\n  if (i) {\n    for (j = i; j < 4; j++) char_array_4[j] = 0;\n\n    for (j = 0; j < 4; j++)\n      char_array_4[j] =\n          static_cast<unsigned char>(base64_chars.find(char_array_4[j]));\n\n    char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);\n    char_array_3[1] =\n        ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);\n    char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];\n\n    for (j = 0; (j < i - 1); j++) ret += char_array_3[j];\n  }\n\n  return ret;\n}\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n// https://github.com/syoyo/tinygltf/issues/228\n// TODO(syoyo): Use uriparser https://uriparser.github.io/ for stricter Uri\n// decoding?\n//\n// Uri Decoding from DLIB\n// http://dlib.net/dlib/server/server_http.cpp.html\n// --- dlib begin ------------------------------------------------------------\n// Copyright (C) 2003  Davis E. King (davis@dlib.net)\n// License: Boost Software License\n// Boost Software License - Version 1.0 - August 17th, 2003\n\n// Permission is hereby granted, free of charge, to any person or organization\n// obtaining a copy of the software and accompanying documentation covered by\n// this license (the \"Software\") to use, reproduce, display, distribute,\n// execute, and transmit the Software, and to prepare derivative works of the\n// Software, and to permit third-parties to whom the Software is furnished to\n// do so, all subject to the following:\n// The copyright notices in the Software and this entire statement, including\n// the above license grant, this restriction and the following disclaimer,\n// must be included in all copies of the Software, in whole or in part, and\n// all derivative works of the Software, unless such copies or derivative\n// works are solely in the form of machine-executable object code generated by\n// a source language processor.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT\n// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE\n// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n// DEALINGS IN THE SOFTWARE.\n//\nnamespace dlib {\n\ninline unsigned char from_hex(unsigned char ch) {\n  if (ch <= '9' && ch >= '0')\n    ch -= '0';\n  else if (ch <= 'f' && ch >= 'a')\n    ch -= 'a' - 10;\n  else if (ch <= 'F' && ch >= 'A')\n    ch -= 'A' - 10;\n  else\n    ch = 0;\n  return ch;\n}\n\nstatic const std::string urldecode(const std::string &str) {\n  using namespace std;\n  string result;\n  string::size_type i;\n  for (i = 0; i < str.size(); ++i) {\n    if (str[i] == '+') {\n      result += ' ';\n    } else if (str[i] == '%' && str.size() > i + 2) {\n      const unsigned char ch1 =\n          from_hex(static_cast<unsigned char>(str[i + 1]));\n      const unsigned char ch2 =\n          from_hex(static_cast<unsigned char>(str[i + 2]));\n      const unsigned char ch = static_cast<unsigned char>((ch1 << 4) | ch2);\n      result += static_cast<char>(ch);\n      i += 2;\n    } else {\n      result += str[i];\n    }\n  }\n  return result;\n}\n\n}  // namespace dlib\n// --- dlib end --------------------------------------------------------------\n\nstatic bool LoadExternalFile(std::vector<unsigned char> *out, std::string *err,\n                             std::string *warn, const std::string &filename,\n                             const std::string &basedir, bool required,\n                             size_t reqBytes, bool checkSize, FsCallbacks *fs) {\n  if (fs == nullptr || fs->FileExists == nullptr ||\n      fs->ExpandFilePath == nullptr || fs->ReadWholeFile == nullptr) {\n    // This is a developer error, assert() ?\n    if (err) {\n      (*err) += \"FS callback[s] not set\\n\";\n    }\n    return false;\n  }\n\n  std::string *failMsgOut = required ? err : warn;\n\n  out->clear();\n\n  std::vector<std::string> paths;\n  paths.push_back(basedir);\n  paths.push_back(\".\");\n\n  std::string filepath = FindFile(paths, filename, fs);\n  if (filepath.empty() || filename.empty()) {\n    if (failMsgOut) {\n      (*failMsgOut) += \"File not found : \" + filename + \"\\n\";\n    }\n    return false;\n  }\n\n  std::vector<unsigned char> buf;\n  std::string fileReadErr;\n  bool fileRead =\n      fs->ReadWholeFile(&buf, &fileReadErr, filepath, fs->user_data);\n  if (!fileRead) {\n    if (failMsgOut) {\n      (*failMsgOut) +=\n          \"File read error : \" + filepath + \" : \" + fileReadErr + \"\\n\";\n    }\n    return false;\n  }\n\n  size_t sz = buf.size();\n  if (sz == 0) {\n    if (failMsgOut) {\n      (*failMsgOut) += \"File is empty : \" + filepath + \"\\n\";\n    }\n    return false;\n  }\n\n  if (checkSize) {\n    if (reqBytes == sz) {\n      out->swap(buf);\n      return true;\n    } else {\n      std::stringstream ss;\n      ss << \"File size mismatch : \" << filepath << \", requestedBytes \"\n         << reqBytes << \", but got \" << sz << std::endl;\n      if (failMsgOut) {\n        (*failMsgOut) += ss.str();\n      }\n      return false;\n    }\n  }\n\n  out->swap(buf);\n  return true;\n}\n\nvoid TinyGLTF::SetImageLoader(LoadImageDataFunction func, void *user_data) {\n  LoadImageData = func;\n  load_image_user_data_ = user_data;\n  user_image_loader_ = true;\n}\n\nvoid TinyGLTF::RemoveImageLoader() {\n  LoadImageData =\n#ifndef TINYGLTF_NO_STB_IMAGE\n      &tinygltf::LoadImageData;\n#else\n      nullptr;\n#endif\n\n  load_image_user_data_ = nullptr;\n  user_image_loader_ = false;\n}\n\n#ifndef TINYGLTF_NO_STB_IMAGE\nbool LoadImageData(Image *image, const int image_idx, std::string *err,\n                   std::string *warn, int req_width, int req_height,\n                   const unsigned char *bytes, int size, void *user_data) {\n  (void)warn;\n\n  LoadImageDataOption option;\n  if (user_data) {\n    option = *reinterpret_cast<LoadImageDataOption *>(user_data);\n  }\n\n  int w = 0, h = 0, comp = 0, req_comp = 0;\n\n  unsigned char *data = nullptr;\n\n  // preserve_channels true: Use channels stored in the image file.\n  // false: force 32-bit textures for common Vulkan compatibility. It appears\n  // that some GPU drivers do not support 24-bit images for Vulkan\n  req_comp = option.preserve_channels ? 0 : 4;\n  int bits = 8;\n  int pixel_type = TINYGLTF_COMPONENT_TYPE_UNSIGNED_BYTE;\n\n  // It is possible that the image we want to load is a 16bit per channel image\n  // We are going to attempt to load it as 16bit per channel, and if it worked,\n  // set the image data accodingly. We are casting the returned pointer into\n  // unsigned char, because we are representing \"bytes\". But we are updating\n  // the Image metadata to signal that this image uses 2 bytes (16bits) per\n  // channel:\n  if (stbi_is_16_bit_from_memory(bytes, size)) {\n    data = reinterpret_cast<unsigned char *>(\n        stbi_load_16_from_memory(bytes, size, &w, &h, &comp, req_comp));\n    if (data) {\n      bits = 16;\n      pixel_type = TINYGLTF_COMPONENT_TYPE_UNSIGNED_SHORT;\n    }\n  }\n\n  // at this point, if data is still NULL, it means that the image wasn't\n  // 16bit per channel, we are going to load it as a normal 8bit per channel\n  // mage as we used to do:\n  // if image cannot be decoded, ignore parsing and keep it by its path\n  // don't break in this case\n  // FIXME we should only enter this function if the image is embedded. If\n  // image->uri references\n  // an image file, it should be left as it is. Image loading should not be\n  // mandatory (to support other formats)\n  if (!data) data = stbi_load_from_memory(bytes, size, &w, &h, &comp, req_comp);\n  if (!data) {\n    // NOTE: you can use `warn` instead of `err`\n    if (err) {\n      (*err) +=\n          \"Unknown image format. STB cannot decode image data for image[\" +\n          std::to_string(image_idx) + \"] name = \\\"\" + image->name + \"\\\".\\n\";\n    }\n    return false;\n  }\n\n  if ((w < 1) || (h < 1)) {\n    stbi_image_free(data);\n    if (err) {\n      (*err) += \"Invalid image data for image[\" + std::to_string(image_idx) +\n                \"] name = \\\"\" + image->name + \"\\\"\\n\";\n    }\n    return false;\n  }\n\n  if (req_width > 0) {\n    if (req_width != w) {\n      stbi_image_free(data);\n      if (err) {\n        (*err) += \"Image width mismatch for image[\" +\n                  std::to_string(image_idx) + \"] name = \\\"\" + image->name +\n                  \"\\\"\\n\";\n      }\n      return false;\n    }\n  }\n\n  if (req_height > 0) {\n    if (req_height != h) {\n      stbi_image_free(data);\n      if (err) {\n        (*err) += \"Image height mismatch. for image[\" +\n                  std::to_string(image_idx) + \"] name = \\\"\" + image->name +\n                  \"\\\"\\n\";\n      }\n      return false;\n    }\n  }\n\n  if (req_comp != 0) {\n    // loaded data has `req_comp` channels(components)\n    comp = req_comp;\n  }\n\n  image->width = w;\n  image->height = h;\n  image->component = comp;\n  image->bits = bits;\n  image->pixel_type = pixel_type;\n  image->image.resize(static_cast<size_t>(w * h * comp) * size_t(bits / 8));\n  std::copy(data, data + w * h * comp * (bits / 8), image->image.begin());\n  stbi_image_free(data);\n\n  return true;\n}\n#endif\n\nvoid TinyGLTF::SetImageWriter(WriteImageDataFunction func, void *user_data) {\n  WriteImageData = func;\n  write_image_user_data_ = user_data;\n}\n\n#ifndef TINYGLTF_NO_STB_IMAGE_WRITE\nstatic void WriteToMemory_stbi(void *context, void *data, int size) {\n  std::vector<unsigned char> *buffer =\n      reinterpret_cast<std::vector<unsigned char> *>(context);\n\n  unsigned char *pData = reinterpret_cast<unsigned char *>(data);\n\n  buffer->insert(buffer->end(), pData, pData + size);\n}\n\nbool WriteImageData(const std::string *basepath, const std::string *filename,\n                    Image *image, bool embedImages, void *fsPtr) {\n  const std::string ext = GetFilePathExtension(*filename);\n\n  // Write image to temporary buffer\n  std::string header;\n  std::vector<unsigned char> data;\n\n  if (ext == \"png\") {\n    if ((image->bits != 8) ||\n        (image->pixel_type != TINYGLTF_COMPONENT_TYPE_UNSIGNED_BYTE)) {\n      // Unsupported pixel format\n      return false;\n    }\n\n    if (!stbi_write_png_to_func(WriteToMemory_stbi, &data, image->width,\n                                image->height, image->component,\n                                &image->image[0], 0)) {\n      return false;\n    }\n    header = \"data:image/png;base64,\";\n  } else if (ext == \"jpg\") {\n    if (!stbi_write_jpg_to_func(WriteToMemory_stbi, &data, image->width,\n                                image->height, image->component,\n                                &image->image[0], 100)) {\n      return false;\n    }\n    header = \"data:image/jpeg;base64,\";\n  } else if (ext == \"bmp\") {\n    if (!stbi_write_bmp_to_func(WriteToMemory_stbi, &data, image->width,\n                                image->height, image->component,\n                                &image->image[0])) {\n      return false;\n    }\n    header = \"data:image/bmp;base64,\";\n  } else if (!embedImages) {\n    // Error: can't output requested format to file\n    return false;\n  }\n\n  if (embedImages) {\n    // Embed base64-encoded image into URI\n    if (data.size()) {\n      image->uri =\n          header +\n          base64_encode(&data[0], static_cast<unsigned int>(data.size()));\n    } else {\n      // Throw error?\n    }\n  } else {\n    // Write image to disc\n    FsCallbacks *fs = reinterpret_cast<FsCallbacks *>(fsPtr);\n    if ((fs != nullptr) && (fs->WriteWholeFile != nullptr)) {\n      const std::string imagefilepath = JoinPath(*basepath, *filename);\n      std::string writeError;\n      if (!fs->WriteWholeFile(&writeError, imagefilepath, data,\n                              fs->user_data)) {\n        // Could not write image file to disc; Throw error ?\n        return false;\n      }\n    } else {\n      // Throw error?\n    }\n    image->uri = *filename;\n  }\n\n  return true;\n}\n#endif\n\nvoid TinyGLTF::SetFsCallbacks(FsCallbacks callbacks) { fs = callbacks; }\n\n#ifdef _WIN32\nstatic inline std::wstring UTF8ToWchar(const std::string &str) {\n  int wstr_size =\n      MultiByteToWideChar(CP_UTF8, 0, str.data(), (int)str.size(), nullptr, 0);\n  std::wstring wstr(wstr_size, 0);\n  MultiByteToWideChar(CP_UTF8, 0, str.data(), (int)str.size(), &wstr[0],\n                      (int)wstr.size());\n  return wstr;\n}\n\nstatic inline std::string WcharToUTF8(const std::wstring &wstr) {\n  int str_size = WideCharToMultiByte(CP_UTF8, 0, wstr.data(), (int)wstr.size(),\n                                     nullptr, 0, NULL, NULL);\n  std::string str(str_size, 0);\n  WideCharToMultiByte(CP_UTF8, 0, wstr.data(), (int)wstr.size(), &str[0],\n                      (int)str.size(), NULL, NULL);\n  return str;\n}\n#endif\n\n#ifndef TINYGLTF_NO_FS\n// Default implementations of filesystem functions\n\nbool FileExists(const std::string &abs_filename, void *) {\n  bool ret;\n#ifdef TINYGLTF_ANDROID_LOAD_FROM_ASSETS\n  if (asset_manager) {\n    AAsset *asset = AAssetManager_open(asset_manager, abs_filename.c_str(),\n                                       AASSET_MODE_STREAMING);\n    if (!asset) {\n      return false;\n    }\n    AAsset_close(asset);\n    ret = true;\n  } else {\n    return false;\n  }\n#else\n#ifdef _WIN32\n#if defined(_MSC_VER) || defined(__GLIBCXX__)\n  FILE *fp = nullptr;\n  errno_t err = _wfopen_s(&fp, UTF8ToWchar(abs_filename).c_str(), L\"rb\");\n  if (err != 0) {\n    return false;\n  }\n#else\n  FILE *fp = nullptr;\n  errno_t err = fopen_s(&fp, abs_filename.c_str(), \"rb\");\n  if (err != 0) {\n    return false;\n  }\n#endif\n\n#else\n  FILE *fp = fopen(abs_filename.c_str(), \"rb\");\n#endif\n  if (fp) {\n    ret = true;\n    fclose(fp);\n  } else {\n    ret = false;\n  }\n#endif\n\n  return ret;\n}\n\nstd::string ExpandFilePath(const std::string &filepath, void *) {\n#ifdef _WIN32\n  // Assume input `filepath` is encoded in UTF-8\n  std::wstring wfilepath = UTF8ToWchar(filepath);\n  DWORD wlen = ExpandEnvironmentStringsW(wfilepath.c_str(), nullptr, 0);\n  wchar_t *wstr = new wchar_t[wlen];\n  ExpandEnvironmentStringsW(wfilepath.c_str(), wstr, wlen);\n\n  std::wstring ws(wstr);\n  delete[] wstr;\n  return WcharToUTF8(ws);\n\n#else\n\n#if defined(TARGET_OS_IPHONE) || defined(TARGET_IPHONE_SIMULATOR) || \\\n    defined(__ANDROID__) || defined(__EMSCRIPTEN__) || defined(__OpenBSD__)\n  // no expansion\n  std::string s = filepath;\n#else\n  std::string s;\n  wordexp_t p;\n\n  if (filepath.empty()) {\n    return \"\";\n  }\n\n  // Quote the string to keep any spaces in filepath intact.\n  std::string quoted_path = \"\\\"\" + filepath + \"\\\"\";\n  // char** w;\n  int ret = wordexp(quoted_path.c_str(), &p, 0);\n  if (ret) {\n    // err\n    s = filepath;\n    return s;\n  }\n\n  // Use first element only.\n  if (p.we_wordv) {\n    s = std::string(p.we_wordv[0]);\n    wordfree(&p);\n  } else {\n    s = filepath;\n  }\n\n#endif\n\n  return s;\n#endif\n}\n\nbool ReadWholeFile(std::vector<unsigned char> *out, std::string *err,\n                   const std::string &filepath, void *) {\n#ifdef TINYGLTF_ANDROID_LOAD_FROM_ASSETS\n  if (asset_manager) {\n    AAsset *asset = AAssetManager_open(asset_manager, filepath.c_str(),\n                                       AASSET_MODE_STREAMING);\n    if (!asset) {\n      if (err) {\n        (*err) += \"File open error : \" + filepath + \"\\n\";\n      }\n      return false;\n    }\n    size_t size = AAsset_getLength(asset);\n    if (size == 0) {\n      if (err) {\n        (*err) += \"Invalid file size : \" + filepath +\n                  \" (does the path point to a directory?)\";\n      }\n      return false;\n    }\n    out->resize(size);\n    AAsset_read(asset, reinterpret_cast<char *>(&out->at(0)), size);\n    AAsset_close(asset);\n    return true;\n  } else {\n    if (err) {\n      (*err) += \"No asset manager specified : \" + filepath + \"\\n\";\n    }\n    return false;\n  }\n#else\n#ifdef _WIN32\n#if defined(__GLIBCXX__)  // mingw\n  int file_descriptor =\n      _wopen(UTF8ToWchar(filepath).c_str(), _O_RDONLY | _O_BINARY);\n  __gnu_cxx::stdio_filebuf<char> wfile_buf(file_descriptor, std::ios_base::in);\n  std::istream f(&wfile_buf);\n#elif defined(_MSC_VER) || defined(_LIBCPP_VERSION)\n  // For libcxx, assume _LIBCPP_HAS_OPEN_WITH_WCHAR is defined to accept\n  // `wchar_t *`\n  std::ifstream f(UTF8ToWchar(filepath).c_str(), std::ifstream::binary);\n#else\n  // Unknown compiler/runtime\n  std::ifstream f(filepath.c_str(), std::ifstream::binary);\n#endif\n#else\n  std::ifstream f(filepath.c_str(), std::ifstream::binary);\n#endif\n  if (!f) {\n    if (err) {\n      (*err) += \"File open error : \" + filepath + \"\\n\";\n    }\n    return false;\n  }\n\n  f.seekg(0, f.end);\n  size_t sz = static_cast<size_t>(f.tellg());\n  f.seekg(0, f.beg);\n\n  if (int64_t(sz) < 0) {\n    if (err) {\n      (*err) += \"Invalid file size : \" + filepath +\n                \" (does the path point to a directory?)\";\n    }\n    return false;\n  } else if (sz == 0) {\n    if (err) {\n      (*err) += \"File is empty : \" + filepath + \"\\n\";\n    }\n    return false;\n  }\n\n  out->resize(sz);\n  f.read(reinterpret_cast<char *>(&out->at(0)),\n         static_cast<std::streamsize>(sz));\n\n  return true;\n#endif\n}\n\nbool WriteWholeFile(std::string *err, const std::string &filepath,\n                    const std::vector<unsigned char> &contents, void *) {\n#ifdef _WIN32\n#if defined(__GLIBCXX__)  // mingw\n  int file_descriptor = _wopen(UTF8ToWchar(filepath).c_str(),\n                               _O_CREAT | _O_WRONLY | _O_TRUNC | _O_BINARY);\n  __gnu_cxx::stdio_filebuf<char> wfile_buf(\n      file_descriptor, std::ios_base::out | std::ios_base::binary);\n  std::ostream f(&wfile_buf);\n#elif defined(_MSC_VER)\n  std::ofstream f(UTF8ToWchar(filepath).c_str(), std::ofstream::binary);\n#else  // clang?\n  std::ofstream f(filepath.c_str(), std::ofstream::binary);\n#endif\n#else\n  std::ofstream f(filepath.c_str(), std::ofstream::binary);\n#endif\n  if (!f) {\n    if (err) {\n      (*err) += \"File open error for writing : \" + filepath + \"\\n\";\n    }\n    return false;\n  }\n\n  f.write(reinterpret_cast<const char *>(&contents.at(0)),\n          static_cast<std::streamsize>(contents.size()));\n  if (!f) {\n    if (err) {\n      (*err) += \"File write error: \" + filepath + \"\\n\";\n    }\n    return false;\n  }\n\n  return true;\n}\n\n#endif  // TINYGLTF_NO_FS\n\nstatic std::string MimeToExt(const std::string &mimeType) {\n  if (mimeType == \"image/jpeg\") {\n    return \"jpg\";\n  } else if (mimeType == \"image/png\") {\n    return \"png\";\n  } else if (mimeType == \"image/bmp\") {\n    return \"bmp\";\n  } else if (mimeType == \"image/gif\") {\n    return \"gif\";\n  }\n\n  return \"\";\n}\n\nstatic void UpdateImageObject(Image &image, std::string &baseDir, int index,\n                              bool embedImages,\n                              WriteImageDataFunction *WriteImageData = nullptr,\n                              void *user_data = nullptr) {\n  std::string filename;\n  std::string ext;\n  // If image has uri, use it it as a filename\n  if (image.uri.size()) {\n    filename = GetBaseFilename(image.uri);\n    ext = GetFilePathExtension(filename);\n  } else if (image.bufferView != -1) {\n    // If there's no URI and the data exists in a buffer,\n    // don't change properties or write images\n  } else if (image.name.size()) {\n    ext = MimeToExt(image.mimeType);\n    // Otherwise use name as filename\n    filename = image.name + \".\" + ext;\n  } else {\n    ext = MimeToExt(image.mimeType);\n    // Fallback to index of image as filename\n    filename = std::to_string(index) + \".\" + ext;\n  }\n\n  // If callback is set, modify image data object\n  if (*WriteImageData != nullptr && !filename.empty()) {\n    std::string uri;\n    (*WriteImageData)(&baseDir, &filename, &image, embedImages, user_data);\n  }\n}\n\nbool IsDataURI(const std::string &in) {\n  std::string header = \"data:application/octet-stream;base64,\";\n  if (in.find(header) == 0) {\n    return true;\n  }\n\n  header = \"data:image/jpeg;base64,\";\n  if (in.find(header) == 0) {\n    return true;\n  }\n\n  header = \"data:image/png;base64,\";\n  if (in.find(header) == 0) {\n    return true;\n  }\n\n  header = \"data:image/bmp;base64,\";\n  if (in.find(header) == 0) {\n    return true;\n  }\n\n  header = \"data:image/gif;base64,\";\n  if (in.find(header) == 0) {\n    return true;\n  }\n\n  header = \"data:text/plain;base64,\";\n  if (in.find(header) == 0) {\n    return true;\n  }\n\n  header = \"data:application/gltf-buffer;base64,\";\n  if (in.find(header) == 0) {\n    return true;\n  }\n\n  return false;\n}\n\nbool DecodeDataURI(std::vector<unsigned char> *out, std::string &mime_type,\n                   const std::string &in, size_t reqBytes, bool checkSize) {\n  std::string header = \"data:application/octet-stream;base64,\";\n  std::string data;\n  if (in.find(header) == 0) {\n    data = base64_decode(in.substr(header.size()));  // cut mime string.\n  }\n\n  if (data.empty()) {\n    header = \"data:image/jpeg;base64,\";\n    if (in.find(header) == 0) {\n      mime_type = \"image/jpeg\";\n      data = base64_decode(in.substr(header.size()));  // cut mime string.\n    }\n  }\n\n  if (data.empty()) {\n    header = \"data:image/png;base64,\";\n    if (in.find(header) == 0) {\n      mime_type = \"image/png\";\n      data = base64_decode(in.substr(header.size()));  // cut mime string.\n    }\n  }\n\n  if (data.empty()) {\n    header = \"data:image/bmp;base64,\";\n    if (in.find(header) == 0) {\n      mime_type = \"image/bmp\";\n      data = base64_decode(in.substr(header.size()));  // cut mime string.\n    }\n  }\n\n  if (data.empty()) {\n    header = \"data:image/gif;base64,\";\n    if (in.find(header) == 0) {\n      mime_type = \"image/gif\";\n      data = base64_decode(in.substr(header.size()));  // cut mime string.\n    }\n  }\n\n  if (data.empty()) {\n    header = \"data:text/plain;base64,\";\n    if (in.find(header) == 0) {\n      mime_type = \"text/plain\";\n      data = base64_decode(in.substr(header.size()));\n    }\n  }\n\n  if (data.empty()) {\n    header = \"data:application/gltf-buffer;base64,\";\n    if (in.find(header) == 0) {\n      data = base64_decode(in.substr(header.size()));\n    }\n  }\n\n  // TODO(syoyo): Allow empty buffer? #229\n  if (data.empty()) {\n    return false;\n  }\n\n  if (checkSize) {\n    if (data.size() != reqBytes) {\n      return false;\n    }\n    out->resize(reqBytes);\n  } else {\n    out->resize(data.size());\n  }\n  std::copy(data.begin(), data.end(), out->begin());\n  return true;\n}\n\nnamespace {\nbool GetInt(const json &o, int &val) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  if (!o.IsDouble()) {\n    if (o.IsInt()) {\n      val = o.GetInt();\n      return true;\n    } else if (o.IsUint()) {\n      val = static_cast<int>(o.GetUint());\n      return true;\n    } else if (o.IsInt64()) {\n      val = static_cast<int>(o.GetInt64());\n      return true;\n    } else if (o.IsUint64()) {\n      val = static_cast<int>(o.GetUint64());\n      return true;\n    }\n  }\n\n  return false;\n#else\n  auto type = o.type();\n\n  if ((type == json::value_t::number_integer) ||\n      (type == json::value_t::number_unsigned)) {\n    val = static_cast<int>(o.get<int64_t>());\n    return true;\n  }\n\n  return false;\n#endif\n}\n\n#ifdef TINYGLTF_USE_RAPIDJSON\nbool GetDouble(const json &o, double &val) {\n  if (o.IsDouble()) {\n    val = o.GetDouble();\n    return true;\n  }\n\n  return false;\n}\n#endif\n\nbool GetNumber(const json &o, double &val) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  if (o.IsNumber()) {\n    val = o.GetDouble();\n    return true;\n  }\n\n  return false;\n#else\n  if (o.is_number()) {\n    val = o.get<double>();\n    return true;\n  }\n\n  return false;\n#endif\n}\n\nbool GetString(const json &o, std::string &val) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  if (o.IsString()) {\n    val = o.GetString();\n    return true;\n  }\n\n  return false;\n#else\n  if (o.type() == json::value_t::string) {\n    val = o.get<std::string>();\n    return true;\n  }\n\n  return false;\n#endif\n}\n\nbool IsArray(const json &o) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  return o.IsArray();\n#else\n  return o.is_array();\n#endif\n}\n\njson_const_array_iterator ArrayBegin(const json &o) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  return o.Begin();\n#else\n  return o.begin();\n#endif\n}\n\njson_const_array_iterator ArrayEnd(const json &o) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  return o.End();\n#else\n  return o.end();\n#endif\n}\n\nbool IsObject(const json &o) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  return o.IsObject();\n#else\n  return o.is_object();\n#endif\n}\n\njson_const_iterator ObjectBegin(const json &o) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  return o.MemberBegin();\n#else\n  return o.begin();\n#endif\n}\n\njson_const_iterator ObjectEnd(const json &o) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  return o.MemberEnd();\n#else\n  return o.end();\n#endif\n}\n\n// Making this a const char* results in a pointer to a temporary when\n// TINYGLTF_USE_RAPIDJSON is off.\nstd::string GetKey(json_const_iterator &it) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  return it->name.GetString();\n#else\n  return it.key().c_str();\n#endif\n}\n\nbool FindMember(const json &o, const char *member, json_const_iterator &it) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  if (!o.IsObject()) {\n    return false;\n  }\n  it = o.FindMember(member);\n  return it != o.MemberEnd();\n#else\n  it = o.find(member);\n  return it != o.end();\n#endif\n}\n\nconst json &GetValue(json_const_iterator &it) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  return it->value;\n#else\n  return it.value();\n#endif\n}\n\nstd::string JsonToString(const json &o, int spacing = -1) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  using namespace rapidjson;\n  StringBuffer buffer;\n  if (spacing == -1) {\n    Writer<StringBuffer> writer(buffer);\n    // TODO: Better error handling.\n    // https://github.com/syoyo/tinygltf/issues/332\n    if (!o.Accept(writer)) {\n      return \"tiny_gltf::JsonToString() failed rapidjson conversion\";\n    }\n  } else {\n    PrettyWriter<StringBuffer> writer(buffer);\n    writer.SetIndent(' ', uint32_t(spacing));\n    if (!o.Accept(writer)) {\n      return \"tiny_gltf::JsonToString() failed rapidjson conversion\";\n    }\n  }\n  return buffer.GetString();\n#else\n  return o.dump(spacing);\n#endif\n}\n\n}  // namespace\n\nstatic bool ParseJsonAsValue(Value *ret, const json &o) {\n  Value val{};\n#ifdef TINYGLTF_USE_RAPIDJSON\n  using rapidjson::Type;\n  switch (o.GetType()) {\n    case Type::kObjectType: {\n      Value::Object value_object;\n      for (auto it = o.MemberBegin(); it != o.MemberEnd(); ++it) {\n        Value entry;\n        ParseJsonAsValue(&entry, it->value);\n        if (entry.Type() != NULL_TYPE)\n          value_object.emplace(GetKey(it), std::move(entry));\n      }\n      if (value_object.size() > 0) val = Value(std::move(value_object));\n    } break;\n    case Type::kArrayType: {\n      Value::Array value_array;\n      value_array.reserve(o.Size());\n      for (auto it = o.Begin(); it != o.End(); ++it) {\n        Value entry;\n        ParseJsonAsValue(&entry, *it);\n        if (entry.Type() != NULL_TYPE)\n          value_array.emplace_back(std::move(entry));\n      }\n      if (value_array.size() > 0) val = Value(std::move(value_array));\n    } break;\n    case Type::kStringType:\n      val = Value(std::string(o.GetString()));\n      break;\n    case Type::kFalseType:\n    case Type::kTrueType:\n      val = Value(o.GetBool());\n      break;\n    case Type::kNumberType:\n      if (!o.IsDouble()) {\n        int i = 0;\n        GetInt(o, i);\n        val = Value(i);\n      } else {\n        double d = 0.0;\n        GetDouble(o, d);\n        val = Value(d);\n      }\n      break;\n    case Type::kNullType:\n      break;\n      // all types are covered, so no `case default`\n  }\n#else\n  switch (o.type()) {\n    case json::value_t::object: {\n      Value::Object value_object;\n      for (auto it = o.begin(); it != o.end(); it++) {\n        Value entry;\n        ParseJsonAsValue(&entry, it.value());\n        if (entry.Type() != NULL_TYPE)\n          value_object.emplace(it.key(), std::move(entry));\n      }\n      if (value_object.size() > 0) val = Value(std::move(value_object));\n    } break;\n    case json::value_t::array: {\n      Value::Array value_array;\n      value_array.reserve(o.size());\n      for (auto it = o.begin(); it != o.end(); it++) {\n        Value entry;\n        ParseJsonAsValue(&entry, it.value());\n        if (entry.Type() != NULL_TYPE)\n          value_array.emplace_back(std::move(entry));\n      }\n      if (value_array.size() > 0) val = Value(std::move(value_array));\n    } break;\n    case json::value_t::string:\n      val = Value(o.get<std::string>());\n      break;\n    case json::value_t::boolean:\n      val = Value(o.get<bool>());\n      break;\n    case json::value_t::number_integer:\n    case json::value_t::number_unsigned:\n      val = Value(static_cast<int>(o.get<int64_t>()));\n      break;\n    case json::value_t::number_float:\n      val = Value(o.get<double>());\n      break;\n    case json::value_t::null:\n    case json::value_t::discarded:\n    case json::value_t::binary:\n      // default:\n      break;\n  }\n#endif\n  if (ret) *ret = std::move(val);\n\n  return val.Type() != NULL_TYPE;\n}\n\nstatic bool ParseExtrasProperty(Value *ret, const json &o) {\n  json_const_iterator it;\n  if (!FindMember(o, \"extras\", it)) {\n    return false;\n  }\n\n  return ParseJsonAsValue(ret, GetValue(it));\n}\n\nstatic bool ParseBooleanProperty(bool *ret, std::string *err, const json &o,\n                                 const std::string &property,\n                                 const bool required,\n                                 const std::string &parent_node = \"\") {\n  json_const_iterator it;\n  if (!FindMember(o, property.c_str(), it)) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is missing\";\n        if (!parent_node.empty()) {\n          (*err) += \" in \" + parent_node;\n        }\n        (*err) += \".\\n\";\n      }\n    }\n    return false;\n  }\n\n  auto &value = GetValue(it);\n\n  bool isBoolean;\n  bool boolValue = false;\n#ifdef TINYGLTF_USE_RAPIDJSON\n  isBoolean = value.IsBool();\n  if (isBoolean) {\n    boolValue = value.GetBool();\n  }\n#else\n  isBoolean = value.is_boolean();\n  if (isBoolean) {\n    boolValue = value.get<bool>();\n  }\n#endif\n  if (!isBoolean) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is not a bool type.\\n\";\n      }\n    }\n    return false;\n  }\n\n  if (ret) {\n    (*ret) = boolValue;\n  }\n\n  return true;\n}\n\nstatic bool ParseIntegerProperty(int *ret, std::string *err, const json &o,\n                                 const std::string &property,\n                                 const bool required,\n                                 const std::string &parent_node = \"\") {\n  json_const_iterator it;\n  if (!FindMember(o, property.c_str(), it)) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is missing\";\n        if (!parent_node.empty()) {\n          (*err) += \" in \" + parent_node;\n        }\n        (*err) += \".\\n\";\n      }\n    }\n    return false;\n  }\n\n  int intValue;\n  bool isInt = GetInt(GetValue(it), intValue);\n  if (!isInt) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is not an integer type.\\n\";\n      }\n    }\n    return false;\n  }\n\n  if (ret) {\n    (*ret) = intValue;\n  }\n\n  return true;\n}\n\nstatic bool ParseUnsignedProperty(size_t *ret, std::string *err, const json &o,\n                                  const std::string &property,\n                                  const bool required,\n                                  const std::string &parent_node = \"\") {\n  json_const_iterator it;\n  if (!FindMember(o, property.c_str(), it)) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is missing\";\n        if (!parent_node.empty()) {\n          (*err) += \" in \" + parent_node;\n        }\n        (*err) += \".\\n\";\n      }\n    }\n    return false;\n  }\n\n  auto &value = GetValue(it);\n\n  size_t uValue = 0;\n  bool isUValue;\n#ifdef TINYGLTF_USE_RAPIDJSON\n  isUValue = false;\n  if (value.IsUint()) {\n    uValue = value.GetUint();\n    isUValue = true;\n  } else if (value.IsUint64()) {\n    uValue = value.GetUint64();\n    isUValue = true;\n  }\n#else\n  isUValue = value.is_number_unsigned();\n  if (isUValue) {\n    uValue = value.get<size_t>();\n  }\n#endif\n  if (!isUValue) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is not a positive integer.\\n\";\n      }\n    }\n    return false;\n  }\n\n  if (ret) {\n    (*ret) = uValue;\n  }\n\n  return true;\n}\n\nstatic bool ParseNumberProperty(double *ret, std::string *err, const json &o,\n                                const std::string &property,\n                                const bool required,\n                                const std::string &parent_node = \"\") {\n  json_const_iterator it;\n\n  if (!FindMember(o, property.c_str(), it)) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is missing\";\n        if (!parent_node.empty()) {\n          (*err) += \" in \" + parent_node;\n        }\n        (*err) += \".\\n\";\n      }\n    }\n    return false;\n  }\n\n  double numberValue;\n  bool isNumber = GetNumber(GetValue(it), numberValue);\n\n  if (!isNumber) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is not a number type.\\n\";\n      }\n    }\n    return false;\n  }\n\n  if (ret) {\n    (*ret) = numberValue;\n  }\n\n  return true;\n}\n\nstatic bool ParseNumberArrayProperty(std::vector<double> *ret, std::string *err,\n                                     const json &o, const std::string &property,\n                                     bool required,\n                                     const std::string &parent_node = \"\") {\n  json_const_iterator it;\n  if (!FindMember(o, property.c_str(), it)) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is missing\";\n        if (!parent_node.empty()) {\n          (*err) += \" in \" + parent_node;\n        }\n        (*err) += \".\\n\";\n      }\n    }\n    return false;\n  }\n\n  if (!IsArray(GetValue(it))) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is not an array\";\n        if (!parent_node.empty()) {\n          (*err) += \" in \" + parent_node;\n        }\n        (*err) += \".\\n\";\n      }\n    }\n    return false;\n  }\n\n  ret->clear();\n  auto end = ArrayEnd(GetValue(it));\n  for (auto i = ArrayBegin(GetValue(it)); i != end; ++i) {\n    double numberValue;\n    const bool isNumber = GetNumber(*i, numberValue);\n    if (!isNumber) {\n      if (required) {\n        if (err) {\n          (*err) += \"'\" + property + \"' property is not a number.\\n\";\n          if (!parent_node.empty()) {\n            (*err) += \" in \" + parent_node;\n          }\n          (*err) += \".\\n\";\n        }\n      }\n      return false;\n    }\n    ret->push_back(numberValue);\n  }\n\n  return true;\n}\n\nstatic bool ParseIntegerArrayProperty(std::vector<int> *ret, std::string *err,\n                                      const json &o,\n                                      const std::string &property,\n                                      bool required,\n                                      const std::string &parent_node = \"\") {\n  json_const_iterator it;\n  if (!FindMember(o, property.c_str(), it)) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is missing\";\n        if (!parent_node.empty()) {\n          (*err) += \" in \" + parent_node;\n        }\n        (*err) += \".\\n\";\n      }\n    }\n    return false;\n  }\n\n  if (!IsArray(GetValue(it))) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is not an array\";\n        if (!parent_node.empty()) {\n          (*err) += \" in \" + parent_node;\n        }\n        (*err) += \".\\n\";\n      }\n    }\n    return false;\n  }\n\n  ret->clear();\n  auto end = ArrayEnd(GetValue(it));\n  for (auto i = ArrayBegin(GetValue(it)); i != end; ++i) {\n    int numberValue;\n    bool isNumber = GetInt(*i, numberValue);\n    if (!isNumber) {\n      if (required) {\n        if (err) {\n          (*err) += \"'\" + property + \"' property is not an integer type.\\n\";\n          if (!parent_node.empty()) {\n            (*err) += \" in \" + parent_node;\n          }\n          (*err) += \".\\n\";\n        }\n      }\n      return false;\n    }\n    ret->push_back(numberValue);\n  }\n\n  return true;\n}\n\nstatic bool ParseStringProperty(\n    std::string *ret, std::string *err, const json &o,\n    const std::string &property, bool required,\n    const std::string &parent_node = std::string()) {\n  json_const_iterator it;\n  if (!FindMember(o, property.c_str(), it)) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is missing\";\n        if (parent_node.empty()) {\n          (*err) += \".\\n\";\n        } else {\n          (*err) += \" in `\" + parent_node + \"'.\\n\";\n        }\n      }\n    }\n    return false;\n  }\n\n  std::string strValue;\n  if (!GetString(GetValue(it), strValue)) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is not a string type.\\n\";\n      }\n    }\n    return false;\n  }\n\n  if (ret) {\n    (*ret) = std::move(strValue);\n  }\n\n  return true;\n}\n\nstatic bool ParseStringIntegerProperty(std::map<std::string, int> *ret,\n                                       std::string *err, const json &o,\n                                       const std::string &property,\n                                       bool required,\n                                       const std::string &parent = \"\") {\n  json_const_iterator it;\n  if (!FindMember(o, property.c_str(), it)) {\n    if (required) {\n      if (err) {\n        if (!parent.empty()) {\n          (*err) +=\n              \"'\" + property + \"' property is missing in \" + parent + \".\\n\";\n        } else {\n          (*err) += \"'\" + property + \"' property is missing.\\n\";\n        }\n      }\n    }\n    return false;\n  }\n\n  const json &dict = GetValue(it);\n\n  // Make sure we are dealing with an object / dictionary.\n  if (!IsObject(dict)) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is not an object.\\n\";\n      }\n    }\n    return false;\n  }\n\n  ret->clear();\n\n  json_const_iterator dictIt(ObjectBegin(dict));\n  json_const_iterator dictItEnd(ObjectEnd(dict));\n\n  for (; dictIt != dictItEnd; ++dictIt) {\n    int intVal;\n    if (!GetInt(GetValue(dictIt), intVal)) {\n      if (required) {\n        if (err) {\n          (*err) += \"'\" + property + \"' value is not an integer type.\\n\";\n        }\n      }\n      return false;\n    }\n\n    // Insert into the list.\n    (*ret)[GetKey(dictIt)] = intVal;\n  }\n  return true;\n}\n\nstatic bool ParseJSONProperty(std::map<std::string, double> *ret,\n                              std::string *err, const json &o,\n                              const std::string &property, bool required) {\n  json_const_iterator it;\n  if (!FindMember(o, property.c_str(), it)) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is missing. \\n'\";\n      }\n    }\n    return false;\n  }\n\n  const json &obj = GetValue(it);\n\n  if (!IsObject(obj)) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is not a JSON object.\\n\";\n      }\n    }\n    return false;\n  }\n\n  ret->clear();\n\n  json_const_iterator it2(ObjectBegin(obj));\n  json_const_iterator itEnd(ObjectEnd(obj));\n  for (; it2 != itEnd; ++it2) {\n    double numVal;\n    if (GetNumber(GetValue(it2), numVal))\n      ret->emplace(std::string(GetKey(it2)), numVal);\n  }\n\n  return true;\n}\n\nstatic bool ParseParameterProperty(Parameter *param, std::string *err,\n                                   const json &o, const std::string &prop,\n                                   bool required) {\n  // A parameter value can either be a string or an array of either a boolean or\n  // a number. Booleans of any kind aren't supported here. Granted, it\n  // complicates the Parameter structure and breaks it semantically in the sense\n  // that the client probably works off the assumption that if the string is\n  // empty the vector is used, etc. Would a tagged union work?\n  if (ParseStringProperty(&param->string_value, err, o, prop, false)) {\n    // Found string property.\n    return true;\n  } else if (ParseNumberArrayProperty(&param->number_array, err, o, prop,\n                                      false)) {\n    // Found a number array.\n    return true;\n  } else if (ParseNumberProperty(&param->number_value, err, o, prop, false)) {\n    return param->has_number_value = true;\n  } else if (ParseJSONProperty(&param->json_double_value, err, o, prop,\n                               false)) {\n    return true;\n  } else if (ParseBooleanProperty(&param->bool_value, err, o, prop, false)) {\n    return true;\n  } else {\n    if (required) {\n      if (err) {\n        (*err) += \"parameter must be a string or number / number array.\\n\";\n      }\n    }\n    return false;\n  }\n}\n\nstatic bool ParseExtensionsProperty(ExtensionMap *ret, std::string *err,\n                                    const json &o) {\n  (void)err;\n\n  json_const_iterator it;\n  if (!FindMember(o, \"extensions\", it)) {\n    return false;\n  }\n\n  auto &obj = GetValue(it);\n  if (!IsObject(obj)) {\n    return false;\n  }\n  ExtensionMap extensions;\n  json_const_iterator extIt = ObjectBegin(obj);  // it.value().begin();\n  json_const_iterator extEnd = ObjectEnd(obj);\n  for (; extIt != extEnd; ++extIt) {\n    auto &itObj = GetValue(extIt);\n    if (!IsObject(itObj)) continue;\n    std::string key(GetKey(extIt));\n    if (!ParseJsonAsValue(&extensions[key], itObj)) {\n      if (!key.empty()) {\n        // create empty object so that an extension object is still of type\n        // object\n        extensions[key] = Value{Value::Object{}};\n      }\n    }\n  }\n  if (ret) {\n    (*ret) = std::move(extensions);\n  }\n  return true;\n}\n\nstatic bool ParseAsset(Asset *asset, std::string *err, const json &o,\n                       bool store_original_json_for_extras_and_extensions) {\n  ParseStringProperty(&asset->version, err, o, \"version\", true, \"Asset\");\n  ParseStringProperty(&asset->generator, err, o, \"generator\", false, \"Asset\");\n  ParseStringProperty(&asset->minVersion, err, o, \"minVersion\", false, \"Asset\");\n  ParseStringProperty(&asset->copyright, err, o, \"copyright\", false, \"Asset\");\n\n  ParseExtensionsProperty(&asset->extensions, err, o);\n\n  // Unity exporter version is added as extra here\n  ParseExtrasProperty(&(asset->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        asset->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        asset->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParseImage(Image *image, const int image_idx, std::string *err,\n                       std::string *warn, const json &o,\n                       bool store_original_json_for_extras_and_extensions,\n                       const std::string &basedir, FsCallbacks *fs,\n                       LoadImageDataFunction *LoadImageData = nullptr,\n                       void *load_image_user_data = nullptr) {\n  // A glTF image must either reference a bufferView or an image uri\n\n  // schema says oneOf [`bufferView`, `uri`]\n  // TODO(syoyo): Check the type of each parameters.\n  json_const_iterator it;\n  bool hasBufferView = FindMember(o, \"bufferView\", it);\n  bool hasURI = FindMember(o, \"uri\", it);\n\n  ParseStringProperty(&image->name, err, o, \"name\", false);\n\n  if (hasBufferView && hasURI) {\n    // Should not both defined.\n    if (err) {\n      (*err) +=\n          \"Only one of `bufferView` or `uri` should be defined, but both are \"\n          \"defined for image[\" +\n          std::to_string(image_idx) + \"] name = \\\"\" + image->name + \"\\\"\\n\";\n    }\n    return false;\n  }\n\n  if (!hasBufferView && !hasURI) {\n    if (err) {\n      (*err) += \"Neither required `bufferView` nor `uri` defined for image[\" +\n                std::to_string(image_idx) + \"] name = \\\"\" + image->name +\n                \"\\\"\\n\";\n    }\n    return false;\n  }\n\n  ParseExtensionsProperty(&image->extensions, err, o);\n  ParseExtrasProperty(&image->extras, o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator eit;\n      if (FindMember(o, \"extensions\", eit)) {\n        image->extensions_json_string = JsonToString(GetValue(eit));\n      }\n    }\n    {\n      json_const_iterator eit;\n      if (FindMember(o, \"extras\", eit)) {\n        image->extras_json_string = JsonToString(GetValue(eit));\n      }\n    }\n  }\n\n  if (hasBufferView) {\n    int bufferView = -1;\n    if (!ParseIntegerProperty(&bufferView, err, o, \"bufferView\", true)) {\n      if (err) {\n        (*err) += \"Failed to parse `bufferView` for image[\" +\n                  std::to_string(image_idx) + \"] name = \\\"\" + image->name +\n                  \"\\\"\\n\";\n      }\n      return false;\n    }\n\n    std::string mime_type;\n    ParseStringProperty(&mime_type, err, o, \"mimeType\", false);\n\n    int width = 0;\n    ParseIntegerProperty(&width, err, o, \"width\", false);\n\n    int height = 0;\n    ParseIntegerProperty(&height, err, o, \"height\", false);\n\n    // Just only save some information here. Loading actual image data from\n    // bufferView is done after this `ParseImage` function.\n    image->bufferView = bufferView;\n    image->mimeType = mime_type;\n    image->width = width;\n    image->height = height;\n\n    return true;\n  }\n\n  // Parse URI & Load image data.\n\n  std::string uri;\n  std::string tmp_err;\n  if (!ParseStringProperty(&uri, &tmp_err, o, \"uri\", true)) {\n    if (err) {\n      (*err) += \"Failed to parse `uri` for image[\" + std::to_string(image_idx) +\n                \"] name = \\\"\" + image->name + \"\\\".\\n\";\n    }\n    return false;\n  }\n\n  std::vector<unsigned char> img;\n\n  if (IsDataURI(uri)) {\n    if (!DecodeDataURI(&img, image->mimeType, uri, 0, false)) {\n      if (err) {\n        (*err) += \"Failed to decode 'uri' for image[\" +\n                  std::to_string(image_idx) + \"] name = [\" + image->name +\n                  \"]\\n\";\n      }\n      return false;\n    }\n  } else {\n    // Assume external file\n    // Keep texture path (for textures that cannot be decoded)\n    image->uri = uri;\n#ifdef TINYGLTF_NO_EXTERNAL_IMAGE\n    return true;\n#endif\n    std::string decoded_uri = dlib::urldecode(uri);\n    if (!LoadExternalFile(&img, err, warn, decoded_uri, basedir,\n                          /* required */ false, /* required bytes */ 0,\n                          /* checksize */ false, fs)) {\n      if (warn) {\n        (*warn) += \"Failed to load external 'uri' for image[\" +\n                   std::to_string(image_idx) + \"] name = [\" + image->name +\n                   \"]\\n\";\n      }\n      // If the image cannot be loaded, keep uri as image->uri.\n      return true;\n    }\n\n    if (img.empty()) {\n      if (warn) {\n        (*warn) += \"Image data is empty for image[\" +\n                   std::to_string(image_idx) + \"] name = [\" + image->name +\n                   \"] \\n\";\n      }\n      return false;\n    }\n  }\n\n  if (*LoadImageData == nullptr) {\n    if (err) {\n      (*err) += \"No LoadImageData callback specified.\\n\";\n    }\n    return false;\n  }\n  return (*LoadImageData)(image, image_idx, err, warn, 0, 0, &img.at(0),\n                          static_cast<int>(img.size()), load_image_user_data);\n}\n\nstatic bool ParseTexture(Texture *texture, std::string *err, const json &o,\n                         bool store_original_json_for_extras_and_extensions,\n                         const std::string &basedir) {\n  (void)basedir;\n  int sampler = -1;\n  int source = -1;\n  ParseIntegerProperty(&sampler, err, o, \"sampler\", false);\n\n  ParseIntegerProperty(&source, err, o, \"source\", false);\n\n  texture->sampler = sampler;\n  texture->source = source;\n\n  ParseExtensionsProperty(&texture->extensions, err, o);\n  ParseExtrasProperty(&texture->extras, o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        texture->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        texture->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  ParseStringProperty(&texture->name, err, o, \"name\", false);\n\n  return true;\n}\n\nstatic bool ParseTextureInfo(\n    TextureInfo *texinfo, std::string *err, const json &o,\n    bool store_original_json_for_extras_and_extensions) {\n  if (texinfo == nullptr) {\n    return false;\n  }\n\n  if (!ParseIntegerProperty(&texinfo->index, err, o, \"index\",\n                            /* required */ true, \"TextureInfo\")) {\n    return false;\n  }\n\n  ParseIntegerProperty(&texinfo->texCoord, err, o, \"texCoord\", false);\n\n  ParseExtensionsProperty(&texinfo->extensions, err, o);\n  ParseExtrasProperty(&texinfo->extras, o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        texinfo->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        texinfo->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParseNormalTextureInfo(\n    NormalTextureInfo *texinfo, std::string *err, const json &o,\n    bool store_original_json_for_extras_and_extensions) {\n  if (texinfo == nullptr) {\n    return false;\n  }\n\n  if (!ParseIntegerProperty(&texinfo->index, err, o, \"index\",\n                            /* required */ true, \"NormalTextureInfo\")) {\n    return false;\n  }\n\n  ParseIntegerProperty(&texinfo->texCoord, err, o, \"texCoord\", false);\n  ParseNumberProperty(&texinfo->scale, err, o, \"scale\", false);\n\n  ParseExtensionsProperty(&texinfo->extensions, err, o);\n  ParseExtrasProperty(&texinfo->extras, o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        texinfo->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        texinfo->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParseOcclusionTextureInfo(\n    OcclusionTextureInfo *texinfo, std::string *err, const json &o,\n    bool store_original_json_for_extras_and_extensions) {\n  if (texinfo == nullptr) {\n    return false;\n  }\n\n  if (!ParseIntegerProperty(&texinfo->index, err, o, \"index\",\n                            /* required */ true, \"NormalTextureInfo\")) {\n    return false;\n  }\n\n  ParseIntegerProperty(&texinfo->texCoord, err, o, \"texCoord\", false);\n  ParseNumberProperty(&texinfo->strength, err, o, \"strength\", false);\n\n  ParseExtensionsProperty(&texinfo->extensions, err, o);\n  ParseExtrasProperty(&texinfo->extras, o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        texinfo->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        texinfo->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParseBuffer(Buffer *buffer, std::string *err, const json &o,\n                        bool store_original_json_for_extras_and_extensions,\n                        FsCallbacks *fs, const std::string &basedir,\n                        bool is_binary = false,\n                        const unsigned char *bin_data = nullptr,\n                        size_t bin_size = 0) {\n  size_t byteLength;\n  if (!ParseUnsignedProperty(&byteLength, err, o, \"byteLength\", true,\n                             \"Buffer\")) {\n    return false;\n  }\n\n  // In glTF 2.0, uri is not mandatory anymore\n  buffer->uri.clear();\n  ParseStringProperty(&buffer->uri, err, o, \"uri\", false, \"Buffer\");\n\n  // having an empty uri for a non embedded image should not be valid\n  if (!is_binary && buffer->uri.empty()) {\n    if (err) {\n      (*err) += \"'uri' is missing from non binary glTF file buffer.\\n\";\n    }\n  }\n\n  json_const_iterator type;\n  if (FindMember(o, \"type\", type)) {\n    std::string typeStr;\n    if (GetString(GetValue(type), typeStr)) {\n      if (typeStr.compare(\"arraybuffer\") == 0) {\n        // buffer.type = \"arraybuffer\";\n      }\n    }\n  }\n\n  if (is_binary) {\n    // Still binary glTF accepts external dataURI.\n    if (!buffer->uri.empty()) {\n      // First try embedded data URI.\n      if (IsDataURI(buffer->uri)) {\n        std::string mime_type;\n        if (!DecodeDataURI(&buffer->data, mime_type, buffer->uri, byteLength,\n                           true)) {\n          if (err) {\n            (*err) +=\n                \"Failed to decode 'uri' : \" + buffer->uri + \" in Buffer\\n\";\n          }\n          return false;\n        }\n      } else {\n        // External .bin file.\n        std::string decoded_uri = dlib::urldecode(buffer->uri);\n        if (!LoadExternalFile(&buffer->data, err, /* warn */ nullptr,\n                              decoded_uri, basedir, /* required */ true,\n                              byteLength, /* checkSize */ true, fs)) {\n          return false;\n        }\n      }\n    } else {\n      // load data from (embedded) binary data\n\n      if ((bin_size == 0) || (bin_data == nullptr)) {\n        if (err) {\n          (*err) += \"Invalid binary data in `Buffer'.\\n\";\n        }\n        return false;\n      }\n\n      if (byteLength > bin_size) {\n        if (err) {\n          std::stringstream ss;\n          ss << \"Invalid `byteLength'. Must be equal or less than binary size: \"\n                \"`byteLength' = \"\n             << byteLength << \", binary size = \" << bin_size << std::endl;\n          (*err) += ss.str();\n        }\n        return false;\n      }\n\n      // Read buffer data\n      buffer->data.resize(static_cast<size_t>(byteLength));\n      memcpy(&(buffer->data.at(0)), bin_data, static_cast<size_t>(byteLength));\n    }\n\n  } else {\n    if (IsDataURI(buffer->uri)) {\n      std::string mime_type;\n      if (!DecodeDataURI(&buffer->data, mime_type, buffer->uri, byteLength,\n                         true)) {\n        if (err) {\n          (*err) += \"Failed to decode 'uri' : \" + buffer->uri + \" in Buffer\\n\";\n        }\n        return false;\n      }\n    } else {\n      // Assume external .bin file.\n      std::string decoded_uri = dlib::urldecode(buffer->uri);\n      if (!LoadExternalFile(&buffer->data, err, /* warn */ nullptr, decoded_uri,\n                            basedir, /* required */ true, byteLength,\n                            /* checkSize */ true, fs)) {\n        return false;\n      }\n    }\n  }\n\n  ParseStringProperty(&buffer->name, err, o, \"name\", false);\n\n  ParseExtensionsProperty(&buffer->extensions, err, o);\n  ParseExtrasProperty(&buffer->extras, o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        buffer->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        buffer->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParseBufferView(\n    BufferView *bufferView, std::string *err, const json &o,\n    bool store_original_json_for_extras_and_extensions) {\n  int buffer = -1;\n  if (!ParseIntegerProperty(&buffer, err, o, \"buffer\", true, \"BufferView\")) {\n    return false;\n  }\n\n  size_t byteOffset = 0;\n  ParseUnsignedProperty(&byteOffset, err, o, \"byteOffset\", false);\n\n  size_t byteLength = 1;\n  if (!ParseUnsignedProperty(&byteLength, err, o, \"byteLength\", true,\n                             \"BufferView\")) {\n    return false;\n  }\n\n  size_t byteStride = 0;\n  if (!ParseUnsignedProperty(&byteStride, err, o, \"byteStride\", false)) {\n    // Spec says: When byteStride of referenced bufferView is not defined, it\n    // means that accessor elements are tightly packed, i.e., effective stride\n    // equals the size of the element.\n    // We cannot determine the actual byteStride until Accessor are parsed, thus\n    // set 0(= tightly packed) here(as done in OpenGL's VertexAttribPoiner)\n    byteStride = 0;\n  }\n\n  if ((byteStride > 252) || ((byteStride % 4) != 0)) {\n    if (err) {\n      std::stringstream ss;\n      ss << \"Invalid `byteStride' value. `byteStride' must be the multiple of \"\n            \"4 : \"\n         << byteStride << std::endl;\n\n      (*err) += ss.str();\n    }\n    return false;\n  }\n\n  int target = 0;\n  ParseIntegerProperty(&target, err, o, \"target\", false);\n  if ((target == TINYGLTF_TARGET_ARRAY_BUFFER) ||\n      (target == TINYGLTF_TARGET_ELEMENT_ARRAY_BUFFER)) {\n    // OK\n  } else {\n    target = 0;\n  }\n  bufferView->target = target;\n\n  ParseStringProperty(&bufferView->name, err, o, \"name\", false);\n\n  ParseExtensionsProperty(&bufferView->extensions, err, o);\n  ParseExtrasProperty(&bufferView->extras, o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        bufferView->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        bufferView->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  bufferView->buffer = buffer;\n  bufferView->byteOffset = byteOffset;\n  bufferView->byteLength = byteLength;\n  bufferView->byteStride = byteStride;\n  return true;\n}\n\nstatic bool ParseSparseAccessor(Accessor *accessor, std::string *err,\n                                const json &o) {\n  accessor->sparse.isSparse = true;\n\n  int count = 0;\n  if (!ParseIntegerProperty(&count, err, o, \"count\", true, \"SparseAccessor\")) {\n    return false;\n  }\n\n  json_const_iterator indices_iterator;\n  json_const_iterator values_iterator;\n  if (!FindMember(o, \"indices\", indices_iterator)) {\n    (*err) = \"the sparse object of this accessor doesn't have indices\";\n    return false;\n  }\n\n  if (!FindMember(o, \"values\", values_iterator)) {\n    (*err) = \"the sparse object ob ths accessor doesn't have values\";\n    return false;\n  }\n\n  const json &indices_obj = GetValue(indices_iterator);\n  const json &values_obj = GetValue(values_iterator);\n\n  int indices_buffer_view = 0, indices_byte_offset = 0, component_type = 0;\n  if (!ParseIntegerProperty(&indices_buffer_view, err, indices_obj, \"bufferView\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&indices_byte_offset, err, indices_obj, \"byteOffset\",\n                       false);\n  if (!ParseIntegerProperty(&component_type, err, indices_obj, \"componentType\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n\n  int values_buffer_view = 0, values_byte_offset = 0;\n  if (!ParseIntegerProperty(&values_buffer_view, err, values_obj, \"bufferView\",\n                       true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&values_byte_offset, err, values_obj, \"byteOffset\",\n                       false);\n\n  accessor->sparse.count = count;\n  accessor->sparse.indices.bufferView = indices_buffer_view;\n  accessor->sparse.indices.byteOffset = indices_byte_offset;\n  accessor->sparse.indices.componentType = component_type;\n  accessor->sparse.values.bufferView = values_buffer_view;\n  accessor->sparse.values.byteOffset = values_byte_offset;\n\n  return true;\n}\n\nstatic bool ParseAccessor(Accessor *accessor, std::string *err, const json &o,\n                          bool store_original_json_for_extras_and_extensions) {\n  int bufferView = -1;\n  ParseIntegerProperty(&bufferView, err, o, \"bufferView\", false, \"Accessor\");\n\n  size_t byteOffset = 0;\n  ParseUnsignedProperty(&byteOffset, err, o, \"byteOffset\", false, \"Accessor\");\n\n  bool normalized = false;\n  ParseBooleanProperty(&normalized, err, o, \"normalized\", false, \"Accessor\");\n\n  size_t componentType = 0;\n  if (!ParseUnsignedProperty(&componentType, err, o, \"componentType\", true,\n                             \"Accessor\")) {\n    return false;\n  }\n\n  size_t count = 0;\n  if (!ParseUnsignedProperty(&count, err, o, \"count\", true, \"Accessor\")) {\n    return false;\n  }\n\n  std::string type;\n  if (!ParseStringProperty(&type, err, o, \"type\", true, \"Accessor\")) {\n    return false;\n  }\n\n  if (type.compare(\"SCALAR\") == 0) {\n    accessor->type = TINYGLTF_TYPE_SCALAR;\n  } else if (type.compare(\"VEC2\") == 0) {\n    accessor->type = TINYGLTF_TYPE_VEC2;\n  } else if (type.compare(\"VEC3\") == 0) {\n    accessor->type = TINYGLTF_TYPE_VEC3;\n  } else if (type.compare(\"VEC4\") == 0) {\n    accessor->type = TINYGLTF_TYPE_VEC4;\n  } else if (type.compare(\"MAT2\") == 0) {\n    accessor->type = TINYGLTF_TYPE_MAT2;\n  } else if (type.compare(\"MAT3\") == 0) {\n    accessor->type = TINYGLTF_TYPE_MAT3;\n  } else if (type.compare(\"MAT4\") == 0) {\n    accessor->type = TINYGLTF_TYPE_MAT4;\n  } else {\n    std::stringstream ss;\n    ss << \"Unsupported `type` for accessor object. Got \\\"\" << type << \"\\\"\\n\";\n    if (err) {\n      (*err) += ss.str();\n    }\n    return false;\n  }\n\n  ParseStringProperty(&accessor->name, err, o, \"name\", false);\n\n  accessor->minValues.clear();\n  accessor->maxValues.clear();\n  ParseNumberArrayProperty(&accessor->minValues, err, o, \"min\", false,\n                           \"Accessor\");\n\n  ParseNumberArrayProperty(&accessor->maxValues, err, o, \"max\", false,\n                           \"Accessor\");\n\n  accessor->count = count;\n  accessor->bufferView = bufferView;\n  accessor->byteOffset = byteOffset;\n  accessor->normalized = normalized;\n  {\n    if (componentType >= TINYGLTF_COMPONENT_TYPE_BYTE &&\n        componentType <= TINYGLTF_COMPONENT_TYPE_DOUBLE) {\n      // OK\n      accessor->componentType = int(componentType);\n    } else {\n      std::stringstream ss;\n      ss << \"Invalid `componentType` in accessor. Got \" << componentType\n         << \"\\n\";\n      if (err) {\n        (*err) += ss.str();\n      }\n      return false;\n    }\n  }\n\n  ParseExtensionsProperty(&(accessor->extensions), err, o);\n  ParseExtrasProperty(&(accessor->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        accessor->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        accessor->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  // check if accessor has a \"sparse\" object:\n  json_const_iterator iterator;\n  if (FindMember(o, \"sparse\", iterator)) {\n    // here this accessor has a \"sparse\" subobject\n    return ParseSparseAccessor(accessor, err, GetValue(iterator));\n  }\n\n  return true;\n}\n\n#ifdef TINYGLTF_ENABLE_DRACO\n\nstatic void DecodeIndexBuffer(draco::Mesh *mesh, size_t componentSize,\n                              std::vector<uint8_t> &outBuffer) {\n  if (componentSize == 4) {\n    assert(sizeof(mesh->face(draco::FaceIndex(0))[0]) == componentSize);\n    memcpy(outBuffer.data(), &mesh->face(draco::FaceIndex(0))[0],\n           outBuffer.size());\n  } else {\n    size_t faceStride = componentSize * 3;\n    for (draco::FaceIndex f(0); f < mesh->num_faces(); ++f) {\n      const draco::Mesh::Face &face = mesh->face(f);\n      if (componentSize == 2) {\n        uint16_t indices[3] = {(uint16_t)face[0].value(),\n                               (uint16_t)face[1].value(),\n                               (uint16_t)face[2].value()};\n        memcpy(outBuffer.data() + f.value() * faceStride, &indices[0],\n               faceStride);\n      } else {\n        uint8_t indices[3] = {(uint8_t)face[0].value(),\n                              (uint8_t)face[1].value(),\n                              (uint8_t)face[2].value()};\n        memcpy(outBuffer.data() + f.value() * faceStride, &indices[0],\n               faceStride);\n      }\n    }\n  }\n}\n\ntemplate <typename T>\nstatic bool GetAttributeForAllPoints(draco::Mesh *mesh,\n                                     const draco::PointAttribute *pAttribute,\n                                     std::vector<uint8_t> &outBuffer) {\n  size_t byteOffset = 0;\n  T values[4] = {0, 0, 0, 0};\n  for (draco::PointIndex i(0); i < mesh->num_points(); ++i) {\n    const draco::AttributeValueIndex val_index = pAttribute->mapped_index(i);\n    if (!pAttribute->ConvertValue<T>(val_index, pAttribute->num_components(),\n                                     values))\n      return false;\n\n    memcpy(outBuffer.data() + byteOffset, &values[0],\n           sizeof(T) * pAttribute->num_components());\n    byteOffset += sizeof(T) * pAttribute->num_components();\n  }\n\n  return true;\n}\n\nstatic bool GetAttributeForAllPoints(uint32_t componentType, draco::Mesh *mesh,\n                                     const draco::PointAttribute *pAttribute,\n                                     std::vector<uint8_t> &outBuffer) {\n  bool decodeResult = false;\n  switch (componentType) {\n    case TINYGLTF_COMPONENT_TYPE_UNSIGNED_BYTE:\n      decodeResult =\n          GetAttributeForAllPoints<uint8_t>(mesh, pAttribute, outBuffer);\n      break;\n    case TINYGLTF_COMPONENT_TYPE_BYTE:\n      decodeResult =\n          GetAttributeForAllPoints<int8_t>(mesh, pAttribute, outBuffer);\n      break;\n    case TINYGLTF_COMPONENT_TYPE_UNSIGNED_SHORT:\n      decodeResult =\n          GetAttributeForAllPoints<uint16_t>(mesh, pAttribute, outBuffer);\n      break;\n    case TINYGLTF_COMPONENT_TYPE_SHORT:\n      decodeResult =\n          GetAttributeForAllPoints<int16_t>(mesh, pAttribute, outBuffer);\n      break;\n    case TINYGLTF_COMPONENT_TYPE_INT:\n      decodeResult =\n          GetAttributeForAllPoints<int32_t>(mesh, pAttribute, outBuffer);\n      break;\n    case TINYGLTF_COMPONENT_TYPE_UNSIGNED_INT:\n      decodeResult =\n          GetAttributeForAllPoints<uint32_t>(mesh, pAttribute, outBuffer);\n      break;\n    case TINYGLTF_COMPONENT_TYPE_FLOAT:\n      decodeResult =\n          GetAttributeForAllPoints<float>(mesh, pAttribute, outBuffer);\n      break;\n    case TINYGLTF_COMPONENT_TYPE_DOUBLE:\n      decodeResult =\n          GetAttributeForAllPoints<double>(mesh, pAttribute, outBuffer);\n      break;\n    default:\n      return false;\n  }\n\n  return decodeResult;\n}\n\nstatic bool ParseDracoExtension(Primitive *primitive, Model *model,\n                                std::string *err,\n                                const Value &dracoExtensionValue) {\n  (void)err;\n  auto bufferViewValue = dracoExtensionValue.Get(\"bufferView\");\n  if (!bufferViewValue.IsInt()) return false;\n  auto attributesValue = dracoExtensionValue.Get(\"attributes\");\n  if (!attributesValue.IsObject()) return false;\n\n  auto attributesObject = attributesValue.Get<Value::Object>();\n  int bufferView = bufferViewValue.Get<int>();\n\n  BufferView &view = model->bufferViews[bufferView];\n  Buffer &buffer = model->buffers[view.buffer];\n  // BufferView has already been decoded\n  if (view.dracoDecoded) return true;\n  view.dracoDecoded = true;\n\n  const char *bufferViewData =\n      reinterpret_cast<const char *>(buffer.data.data() + view.byteOffset);\n  size_t bufferViewSize = view.byteLength;\n\n  // decode draco\n  draco::DecoderBuffer decoderBuffer;\n  decoderBuffer.Init(bufferViewData, bufferViewSize);\n  draco::Decoder decoder;\n  auto decodeResult = decoder.DecodeMeshFromBuffer(&decoderBuffer);\n  if (!decodeResult.ok()) {\n    return false;\n  }\n  const std::unique_ptr<draco::Mesh> &mesh = decodeResult.value();\n\n  // create new bufferView for indices\n  if (primitive->indices >= 0) {\n    int32_t componentSize = GetComponentSizeInBytes(\n        model->accessors[primitive->indices].componentType);\n    Buffer decodedIndexBuffer;\n    decodedIndexBuffer.data.resize(mesh->num_faces() * 3 * componentSize);\n\n    DecodeIndexBuffer(mesh.get(), componentSize, decodedIndexBuffer.data);\n\n    model->buffers.emplace_back(std::move(decodedIndexBuffer));\n\n    BufferView decodedIndexBufferView;\n    decodedIndexBufferView.buffer = int(model->buffers.size() - 1);\n    decodedIndexBufferView.byteLength =\n        int(mesh->num_faces() * 3 * componentSize);\n    decodedIndexBufferView.byteOffset = 0;\n    decodedIndexBufferView.byteStride = 0;\n    decodedIndexBufferView.target = TINYGLTF_TARGET_ARRAY_BUFFER;\n    model->bufferViews.emplace_back(std::move(decodedIndexBufferView));\n\n    model->accessors[primitive->indices].bufferView =\n        int(model->bufferViews.size() - 1);\n    model->accessors[primitive->indices].count = int(mesh->num_faces() * 3);\n  }\n\n  for (const auto &attribute : attributesObject) {\n    if (!attribute.second.IsInt()) return false;\n    auto primitiveAttribute = primitive->attributes.find(attribute.first);\n    if (primitiveAttribute == primitive->attributes.end()) return false;\n\n    int dracoAttributeIndex = attribute.second.Get<int>();\n    const auto pAttribute = mesh->GetAttributeByUniqueId(dracoAttributeIndex);\n    const auto componentType =\n        model->accessors[primitiveAttribute->second].componentType;\n\n    // Create a new buffer for this decoded buffer\n    Buffer decodedBuffer;\n    size_t bufferSize = mesh->num_points() * pAttribute->num_components() *\n                        GetComponentSizeInBytes(componentType);\n    decodedBuffer.data.resize(bufferSize);\n\n    if (!GetAttributeForAllPoints(componentType, mesh.get(), pAttribute,\n                                  decodedBuffer.data))\n      return false;\n\n    model->buffers.emplace_back(std::move(decodedBuffer));\n\n    BufferView decodedBufferView;\n    decodedBufferView.buffer = int(model->buffers.size() - 1);\n    decodedBufferView.byteLength = bufferSize;\n    decodedBufferView.byteOffset = pAttribute->byte_offset();\n    decodedBufferView.byteStride = pAttribute->byte_stride();\n    decodedBufferView.target = primitive->indices >= 0\n                                   ? TINYGLTF_TARGET_ELEMENT_ARRAY_BUFFER\n                                   : TINYGLTF_TARGET_ARRAY_BUFFER;\n    model->bufferViews.emplace_back(std::move(decodedBufferView));\n\n    model->accessors[primitiveAttribute->second].bufferView =\n        int(model->bufferViews.size() - 1);\n    model->accessors[primitiveAttribute->second].count =\n        int(mesh->num_points());\n  }\n\n  return true;\n}\n#endif\n\nstatic bool ParsePrimitive(Primitive *primitive, Model *model, std::string *err,\n                           const json &o,\n                           bool store_original_json_for_extras_and_extensions) {\n  int material = -1;\n  ParseIntegerProperty(&material, err, o, \"material\", false);\n  primitive->material = material;\n\n  int mode = TINYGLTF_MODE_TRIANGLES;\n  ParseIntegerProperty(&mode, err, o, \"mode\", false);\n  primitive->mode = mode;  // Why only triangled were supported ?\n\n  int indices = -1;\n  ParseIntegerProperty(&indices, err, o, \"indices\", false);\n  primitive->indices = indices;\n  if (!ParseStringIntegerProperty(&primitive->attributes, err, o, \"attributes\",\n                                  true, \"Primitive\")) {\n    return false;\n  }\n\n  // Look for morph targets\n  json_const_iterator targetsObject;\n  if (FindMember(o, \"targets\", targetsObject) &&\n      IsArray(GetValue(targetsObject))) {\n    auto targetsObjectEnd = ArrayEnd(GetValue(targetsObject));\n    for (json_const_array_iterator i = ArrayBegin(GetValue(targetsObject));\n         i != targetsObjectEnd; ++i) {\n      std::map<std::string, int> targetAttribues;\n\n      const json &dict = *i;\n      if (IsObject(dict)) {\n        json_const_iterator dictIt(ObjectBegin(dict));\n        json_const_iterator dictItEnd(ObjectEnd(dict));\n\n        for (; dictIt != dictItEnd; ++dictIt) {\n          int iVal;\n          if (GetInt(GetValue(dictIt), iVal))\n            targetAttribues[GetKey(dictIt)] = iVal;\n        }\n        primitive->targets.emplace_back(std::move(targetAttribues));\n      }\n    }\n  }\n\n  ParseExtrasProperty(&(primitive->extras), o);\n  ParseExtensionsProperty(&primitive->extensions, err, o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        primitive->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        primitive->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n#ifdef TINYGLTF_ENABLE_DRACO\n  auto dracoExtension =\n      primitive->extensions.find(\"KHR_draco_mesh_compression\");\n  if (dracoExtension != primitive->extensions.end()) {\n    ParseDracoExtension(primitive, model, err, dracoExtension->second);\n  }\n#else\n  (void)model;\n#endif\n\n  return true;\n}\n\nstatic bool ParseMesh(Mesh *mesh, Model *model, std::string *err, const json &o,\n                      bool store_original_json_for_extras_and_extensions) {\n  ParseStringProperty(&mesh->name, err, o, \"name\", false);\n\n  mesh->primitives.clear();\n  json_const_iterator primObject;\n  if (FindMember(o, \"primitives\", primObject) &&\n      IsArray(GetValue(primObject))) {\n    json_const_array_iterator primEnd = ArrayEnd(GetValue(primObject));\n    for (json_const_array_iterator i = ArrayBegin(GetValue(primObject));\n         i != primEnd; ++i) {\n      Primitive primitive;\n      if (ParsePrimitive(&primitive, model, err, *i,\n                         store_original_json_for_extras_and_extensions)) {\n        // Only add the primitive if the parsing succeeds.\n        mesh->primitives.emplace_back(std::move(primitive));\n      }\n    }\n  }\n\n  // Should probably check if has targets and if dimensions fit\n  ParseNumberArrayProperty(&mesh->weights, err, o, \"weights\", false);\n\n  ParseExtensionsProperty(&mesh->extensions, err, o);\n  ParseExtrasProperty(&(mesh->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        mesh->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        mesh->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParseNode(Node *node, std::string *err, const json &o,\n                      bool store_original_json_for_extras_and_extensions) {\n  ParseStringProperty(&node->name, err, o, \"name\", false);\n\n  int skin = -1;\n  ParseIntegerProperty(&skin, err, o, \"skin\", false);\n  node->skin = skin;\n\n  // Matrix and T/R/S are exclusive\n  if (!ParseNumberArrayProperty(&node->matrix, err, o, \"matrix\", false)) {\n    ParseNumberArrayProperty(&node->rotation, err, o, \"rotation\", false);\n    ParseNumberArrayProperty(&node->scale, err, o, \"scale\", false);\n    ParseNumberArrayProperty(&node->translation, err, o, \"translation\", false);\n  }\n\n  int camera = -1;\n  ParseIntegerProperty(&camera, err, o, \"camera\", false);\n  node->camera = camera;\n\n  int mesh = -1;\n  ParseIntegerProperty(&mesh, err, o, \"mesh\", false);\n  node->mesh = mesh;\n\n  node->children.clear();\n  ParseIntegerArrayProperty(&node->children, err, o, \"children\", false);\n\n  ParseNumberArrayProperty(&node->weights, err, o, \"weights\", false);\n\n  ParseExtensionsProperty(&node->extensions, err, o);\n  ParseExtrasProperty(&(node->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        node->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        node->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParsePbrMetallicRoughness(\n    PbrMetallicRoughness *pbr, std::string *err, const json &o,\n    bool store_original_json_for_extras_and_extensions) {\n  if (pbr == nullptr) {\n    return false;\n  }\n\n  std::vector<double> baseColorFactor;\n  if (ParseNumberArrayProperty(&baseColorFactor, err, o, \"baseColorFactor\",\n                               /* required */ false)) {\n    if (baseColorFactor.size() != 4) {\n      if (err) {\n        (*err) +=\n            \"Array length of `baseColorFactor` parameter in \"\n            \"pbrMetallicRoughness must be 4, but got \" +\n            std::to_string(baseColorFactor.size()) + \"\\n\";\n      }\n      return false;\n    }\n    pbr->baseColorFactor = baseColorFactor;\n  }\n\n  {\n    json_const_iterator it;\n    if (FindMember(o, \"baseColorTexture\", it)) {\n      ParseTextureInfo(&pbr->baseColorTexture, err, GetValue(it),\n                       store_original_json_for_extras_and_extensions);\n    }\n  }\n\n  {\n    json_const_iterator it;\n    if (FindMember(o, \"metallicRoughnessTexture\", it)) {\n      ParseTextureInfo(&pbr->metallicRoughnessTexture, err, GetValue(it),\n                       store_original_json_for_extras_and_extensions);\n    }\n  }\n\n  ParseNumberProperty(&pbr->metallicFactor, err, o, \"metallicFactor\", false);\n  ParseNumberProperty(&pbr->roughnessFactor, err, o, \"roughnessFactor\", false);\n\n  ParseExtensionsProperty(&pbr->extensions, err, o);\n  ParseExtrasProperty(&pbr->extras, o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        pbr->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        pbr->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParseMaterial(Material *material, std::string *err, const json &o,\n                          bool store_original_json_for_extras_and_extensions) {\n  ParseStringProperty(&material->name, err, o, \"name\", /* required */ false);\n\n  if (ParseNumberArrayProperty(&material->emissiveFactor, err, o,\n                               \"emissiveFactor\",\n                               /* required */ false)) {\n    if (material->emissiveFactor.size() != 3) {\n      if (err) {\n        (*err) +=\n            \"Array length of `emissiveFactor` parameter in \"\n            \"material must be 3, but got \" +\n            std::to_string(material->emissiveFactor.size()) + \"\\n\";\n      }\n      return false;\n    }\n  } else {\n    // fill with default values\n    material->emissiveFactor = {0.0, 0.0, 0.0};\n  }\n\n  ParseStringProperty(&material->alphaMode, err, o, \"alphaMode\",\n                      /* required */ false);\n  ParseNumberProperty(&material->alphaCutoff, err, o, \"alphaCutoff\",\n                      /* required */ false);\n  ParseBooleanProperty(&material->doubleSided, err, o, \"doubleSided\",\n                       /* required */ false);\n\n  {\n    json_const_iterator it;\n    if (FindMember(o, \"pbrMetallicRoughness\", it)) {\n      ParsePbrMetallicRoughness(&material->pbrMetallicRoughness, err,\n                                GetValue(it),\n                                store_original_json_for_extras_and_extensions);\n    }\n  }\n\n  {\n    json_const_iterator it;\n    if (FindMember(o, \"normalTexture\", it)) {\n      ParseNormalTextureInfo(&material->normalTexture, err, GetValue(it),\n                             store_original_json_for_extras_and_extensions);\n    }\n  }\n\n  {\n    json_const_iterator it;\n    if (FindMember(o, \"occlusionTexture\", it)) {\n      ParseOcclusionTextureInfo(&material->occlusionTexture, err, GetValue(it),\n                                store_original_json_for_extras_and_extensions);\n    }\n  }\n\n  {\n    json_const_iterator it;\n    if (FindMember(o, \"emissiveTexture\", it)) {\n      ParseTextureInfo(&material->emissiveTexture, err, GetValue(it),\n                       store_original_json_for_extras_and_extensions);\n    }\n  }\n\n  // Old code path. For backward compatibility, we still store material values\n  // as Parameter. This will create duplicated information for\n  // example(pbrMetallicRoughness), but should be neglible in terms of memory\n  // consumption.\n  // TODO(syoyo): Remove in the next major release.\n  material->values.clear();\n  material->additionalValues.clear();\n\n  json_const_iterator it(ObjectBegin(o));\n  json_const_iterator itEnd(ObjectEnd(o));\n\n  for (; it != itEnd; ++it) {\n    std::string key(GetKey(it));\n    if (key == \"pbrMetallicRoughness\") {\n      if (IsObject(GetValue(it))) {\n        const json &values_object = GetValue(it);\n\n        json_const_iterator itVal(ObjectBegin(values_object));\n        json_const_iterator itValEnd(ObjectEnd(values_object));\n\n        for (; itVal != itValEnd; ++itVal) {\n          Parameter param;\n          if (ParseParameterProperty(&param, err, values_object, GetKey(itVal),\n                                     false)) {\n            material->values.emplace(GetKey(itVal), std::move(param));\n          }\n        }\n      }\n    } else if (key == \"extensions\" || key == \"extras\") {\n      // done later, skip, otherwise poorly parsed contents will be saved in the\n      // parametermap and serialized again later\n    } else {\n      Parameter param;\n      if (ParseParameterProperty(&param, err, o, key, false)) {\n        // names of materials have already been parsed. Putting it in this map\n        // doesn't correctly reflext the glTF specification\n        if (key != \"name\")\n          material->additionalValues.emplace(std::move(key), std::move(param));\n      }\n    }\n  }\n\n  material->extensions.clear();\n  ParseExtensionsProperty(&material->extensions, err, o);\n  ParseExtrasProperty(&(material->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator eit;\n      if (FindMember(o, \"extensions\", eit)) {\n        material->extensions_json_string = JsonToString(GetValue(eit));\n      }\n    }\n    {\n      json_const_iterator eit;\n      if (FindMember(o, \"extras\", eit)) {\n        material->extras_json_string = JsonToString(GetValue(eit));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParseAnimationChannel(\n    AnimationChannel *channel, std::string *err, const json &o,\n    bool store_original_json_for_extras_and_extensions) {\n  int samplerIndex = -1;\n  int targetIndex = -1;\n  if (!ParseIntegerProperty(&samplerIndex, err, o, \"sampler\", true,\n                            \"AnimationChannel\")) {\n    if (err) {\n      (*err) += \"`sampler` field is missing in animation channels\\n\";\n    }\n    return false;\n  }\n\n  json_const_iterator targetIt;\n  if (FindMember(o, \"target\", targetIt) && IsObject(GetValue(targetIt))) {\n    const json &target_object = GetValue(targetIt);\n\n    if (!ParseIntegerProperty(&targetIndex, err, target_object, \"node\", true)) {\n      if (err) {\n        (*err) += \"`node` field is missing in animation.channels.target\\n\";\n      }\n      return false;\n    }\n\n    if (!ParseStringProperty(&channel->target_path, err, target_object, \"path\",\n                             true)) {\n      if (err) {\n        (*err) += \"`path` field is missing in animation.channels.target\\n\";\n      }\n      return false;\n    }\n    ParseExtensionsProperty(&channel->target_extensions, err, target_object);\n    if (store_original_json_for_extras_and_extensions) {\n      json_const_iterator it;\n      if (FindMember(target_object, \"extensions\", it)) {\n        channel->target_extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  channel->sampler = samplerIndex;\n  channel->target_node = targetIndex;\n\n  ParseExtensionsProperty(&channel->extensions, err, o);\n  ParseExtrasProperty(&(channel->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        channel->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        channel->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParseAnimation(Animation *animation, std::string *err,\n                           const json &o,\n                           bool store_original_json_for_extras_and_extensions) {\n  {\n    json_const_iterator channelsIt;\n    if (FindMember(o, \"channels\", channelsIt) &&\n        IsArray(GetValue(channelsIt))) {\n      json_const_array_iterator channelEnd = ArrayEnd(GetValue(channelsIt));\n      for (json_const_array_iterator i = ArrayBegin(GetValue(channelsIt));\n           i != channelEnd; ++i) {\n        AnimationChannel channel;\n        if (ParseAnimationChannel(\n                &channel, err, *i,\n                store_original_json_for_extras_and_extensions)) {\n          // Only add the channel if the parsing succeeds.\n          animation->channels.emplace_back(std::move(channel));\n        }\n      }\n    }\n  }\n\n  {\n    json_const_iterator samplerIt;\n    if (FindMember(o, \"samplers\", samplerIt) && IsArray(GetValue(samplerIt))) {\n      const json &sampler_array = GetValue(samplerIt);\n\n      json_const_array_iterator it = ArrayBegin(sampler_array);\n      json_const_array_iterator itEnd = ArrayEnd(sampler_array);\n\n      for (; it != itEnd; ++it) {\n        const json &s = *it;\n\n        AnimationSampler sampler;\n        int inputIndex = -1;\n        int outputIndex = -1;\n        if (!ParseIntegerProperty(&inputIndex, err, s, \"input\", true)) {\n          if (err) {\n            (*err) += \"`input` field is missing in animation.sampler\\n\";\n          }\n          return false;\n        }\n        ParseStringProperty(&sampler.interpolation, err, s, \"interpolation\",\n                            false);\n        if (!ParseIntegerProperty(&outputIndex, err, s, \"output\", true)) {\n          if (err) {\n            (*err) += \"`output` field is missing in animation.sampler\\n\";\n          }\n          return false;\n        }\n        sampler.input = inputIndex;\n        sampler.output = outputIndex;\n        ParseExtensionsProperty(&(sampler.extensions), err, o);\n        ParseExtrasProperty(&(sampler.extras), s);\n\n        if (store_original_json_for_extras_and_extensions) {\n          {\n            json_const_iterator eit;\n            if (FindMember(o, \"extensions\", eit)) {\n              sampler.extensions_json_string = JsonToString(GetValue(eit));\n            }\n          }\n          {\n            json_const_iterator eit;\n            if (FindMember(o, \"extras\", eit)) {\n              sampler.extras_json_string = JsonToString(GetValue(eit));\n            }\n          }\n        }\n\n        animation->samplers.emplace_back(std::move(sampler));\n      }\n    }\n  }\n\n  ParseStringProperty(&animation->name, err, o, \"name\", false);\n\n  ParseExtensionsProperty(&animation->extensions, err, o);\n  ParseExtrasProperty(&(animation->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        animation->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        animation->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParseSampler(Sampler *sampler, std::string *err, const json &o,\n                         bool store_original_json_for_extras_and_extensions) {\n  ParseStringProperty(&sampler->name, err, o, \"name\", false);\n\n  int minFilter = -1;\n  int magFilter = -1;\n  int wrapS = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  int wrapT = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  //int wrapR = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  ParseIntegerProperty(&minFilter, err, o, \"minFilter\", false);\n  ParseIntegerProperty(&magFilter, err, o, \"magFilter\", false);\n  ParseIntegerProperty(&wrapS, err, o, \"wrapS\", false);\n  ParseIntegerProperty(&wrapT, err, o, \"wrapT\", false);\n  //ParseIntegerProperty(&wrapR, err, o, \"wrapR\", false);  // tinygltf extension\n\n  // TODO(syoyo): Check the value is alloed one.\n  // (e.g. we allow 9728(NEAREST), but don't allow 9727)\n\n  sampler->minFilter = minFilter;\n  sampler->magFilter = magFilter;\n  sampler->wrapS = wrapS;\n  sampler->wrapT = wrapT;\n  //sampler->wrapR = wrapR;\n\n  ParseExtensionsProperty(&(sampler->extensions), err, o);\n  ParseExtrasProperty(&(sampler->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        sampler->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        sampler->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParseSkin(Skin *skin, std::string *err, const json &o,\n                      bool store_original_json_for_extras_and_extensions) {\n  ParseStringProperty(&skin->name, err, o, \"name\", false, \"Skin\");\n\n  std::vector<int> joints;\n  if (!ParseIntegerArrayProperty(&joints, err, o, \"joints\", false, \"Skin\")) {\n    return false;\n  }\n  skin->joints = std::move(joints);\n\n  int skeleton = -1;\n  ParseIntegerProperty(&skeleton, err, o, \"skeleton\", false, \"Skin\");\n  skin->skeleton = skeleton;\n\n  int invBind = -1;\n  ParseIntegerProperty(&invBind, err, o, \"inverseBindMatrices\", true, \"Skin\");\n  skin->inverseBindMatrices = invBind;\n\n  ParseExtensionsProperty(&(skin->extensions), err, o);\n  ParseExtrasProperty(&(skin->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        skin->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        skin->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParsePerspectiveCamera(\n    PerspectiveCamera *camera, std::string *err, const json &o,\n    bool store_original_json_for_extras_and_extensions) {\n  double yfov = 0.0;\n  if (!ParseNumberProperty(&yfov, err, o, \"yfov\", true, \"OrthographicCamera\")) {\n    return false;\n  }\n\n  double znear = 0.0;\n  if (!ParseNumberProperty(&znear, err, o, \"znear\", true,\n                           \"PerspectiveCamera\")) {\n    return false;\n  }\n\n  double aspectRatio = 0.0;  // = invalid\n  ParseNumberProperty(&aspectRatio, err, o, \"aspectRatio\", false,\n                      \"PerspectiveCamera\");\n\n  double zfar = 0.0;  // = invalid\n  ParseNumberProperty(&zfar, err, o, \"zfar\", false, \"PerspectiveCamera\");\n\n  camera->aspectRatio = aspectRatio;\n  camera->zfar = zfar;\n  camera->yfov = yfov;\n  camera->znear = znear;\n\n  ParseExtensionsProperty(&camera->extensions, err, o);\n  ParseExtrasProperty(&(camera->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        camera->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        camera->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  // TODO(syoyo): Validate parameter values.\n\n  return true;\n}\n\nstatic bool ParseSpotLight(SpotLight *light, std::string *err, const json &o,\n                           bool store_original_json_for_extras_and_extensions) {\n  ParseNumberProperty(&light->innerConeAngle, err, o, \"innerConeAngle\", false);\n  ParseNumberProperty(&light->outerConeAngle, err, o, \"outerConeAngle\", false);\n\n  ParseExtensionsProperty(&light->extensions, err, o);\n  ParseExtrasProperty(&light->extras, o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        light->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        light->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  // TODO(syoyo): Validate parameter values.\n\n  return true;\n}\n\nstatic bool ParseOrthographicCamera(\n    OrthographicCamera *camera, std::string *err, const json &o,\n    bool store_original_json_for_extras_and_extensions) {\n  double xmag = 0.0;\n  if (!ParseNumberProperty(&xmag, err, o, \"xmag\", true, \"OrthographicCamera\")) {\n    return false;\n  }\n\n  double ymag = 0.0;\n  if (!ParseNumberProperty(&ymag, err, o, \"ymag\", true, \"OrthographicCamera\")) {\n    return false;\n  }\n\n  double zfar = 0.0;\n  if (!ParseNumberProperty(&zfar, err, o, \"zfar\", true, \"OrthographicCamera\")) {\n    return false;\n  }\n\n  double znear = 0.0;\n  if (!ParseNumberProperty(&znear, err, o, \"znear\", true,\n                           \"OrthographicCamera\")) {\n    return false;\n  }\n\n  ParseExtensionsProperty(&camera->extensions, err, o);\n  ParseExtrasProperty(&(camera->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        camera->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        camera->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  camera->xmag = xmag;\n  camera->ymag = ymag;\n  camera->zfar = zfar;\n  camera->znear = znear;\n\n  // TODO(syoyo): Validate parameter values.\n\n  return true;\n}\n\nstatic bool ParseCamera(Camera *camera, std::string *err, const json &o,\n                        bool store_original_json_for_extras_and_extensions) {\n  if (!ParseStringProperty(&camera->type, err, o, \"type\", true, \"Camera\")) {\n    return false;\n  }\n\n  if (camera->type.compare(\"orthographic\") == 0) {\n    json_const_iterator orthoIt;\n    if (!FindMember(o, \"orthographic\", orthoIt)) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"Orhographic camera description not found.\" << std::endl;\n        (*err) += ss.str();\n      }\n      return false;\n    }\n\n    const json &v = GetValue(orthoIt);\n    if (!IsObject(v)) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"\\\"orthographic\\\" is not a JSON object.\" << std::endl;\n        (*err) += ss.str();\n      }\n      return false;\n    }\n\n    if (!ParseOrthographicCamera(\n            &camera->orthographic, err, v,\n            store_original_json_for_extras_and_extensions)) {\n      return false;\n    }\n  } else if (camera->type.compare(\"perspective\") == 0) {\n    json_const_iterator perspIt;\n    if (!FindMember(o, \"perspective\", perspIt)) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"Perspective camera description not found.\" << std::endl;\n        (*err) += ss.str();\n      }\n      return false;\n    }\n\n    const json &v = GetValue(perspIt);\n    if (!IsObject(v)) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"\\\"perspective\\\" is not a JSON object.\" << std::endl;\n        (*err) += ss.str();\n      }\n      return false;\n    }\n\n    if (!ParsePerspectiveCamera(\n            &camera->perspective, err, v,\n            store_original_json_for_extras_and_extensions)) {\n      return false;\n    }\n  } else {\n    if (err) {\n      std::stringstream ss;\n      ss << \"Invalid camera type: \\\"\" << camera->type\n         << \"\\\". Must be \\\"perspective\\\" or \\\"orthographic\\\"\" << std::endl;\n      (*err) += ss.str();\n    }\n    return false;\n  }\n\n  ParseStringProperty(&camera->name, err, o, \"name\", false);\n\n  ParseExtensionsProperty(&camera->extensions, err, o);\n  ParseExtrasProperty(&(camera->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        camera->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        camera->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParseLight(Light *light, std::string *err, const json &o,\n                       bool store_original_json_for_extras_and_extensions) {\n  if (!ParseStringProperty(&light->type, err, o, \"type\", true)) {\n    return false;\n  }\n\n  if (light->type == \"spot\") {\n    json_const_iterator spotIt;\n    if (!FindMember(o, \"spot\", spotIt)) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"Spot light description not found.\" << std::endl;\n        (*err) += ss.str();\n      }\n      return false;\n    }\n\n    const json &v = GetValue(spotIt);\n    if (!IsObject(v)) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"\\\"spot\\\" is not a JSON object.\" << std::endl;\n        (*err) += ss.str();\n      }\n      return false;\n    }\n\n    if (!ParseSpotLight(&light->spot, err, v,\n                        store_original_json_for_extras_and_extensions)) {\n      return false;\n    }\n  }\n\n  ParseStringProperty(&light->name, err, o, \"name\", false);\n  ParseNumberArrayProperty(&light->color, err, o, \"color\", false);\n  ParseNumberProperty(&light->range, err, o, \"range\", false);\n  ParseNumberProperty(&light->intensity, err, o, \"intensity\", false);\n  ParseExtensionsProperty(&light->extensions, err, o);\n  ParseExtrasProperty(&(light->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        light->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        light->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nbool TinyGLTF::LoadFromString(Model *model, std::string *err, std::string *warn,\n                              const char *json_str,\n                              unsigned int json_str_length,\n                              const std::string &base_dir,\n                              unsigned int check_sections) {\n  if (json_str_length < 4) {\n    if (err) {\n      (*err) = \"JSON string too short.\\n\";\n    }\n    return false;\n  }\n\n  JsonDocument v;\n\n#if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || \\\n     defined(_CPPUNWIND)) &&                               \\\n    !defined(TINYGLTF_NOEXCEPTION)\n  try {\n    JsonParse(v, json_str, json_str_length, true);\n\n  } catch (const std::exception &e) {\n    if (err) {\n      (*err) = e.what();\n    }\n    return false;\n  }\n#else\n  {\n    JsonParse(v, json_str, json_str_length);\n\n    if (!IsObject(v)) {\n      // Assume parsing was failed.\n      if (err) {\n        (*err) = \"Failed to parse JSON object\\n\";\n      }\n      return false;\n    }\n  }\n#endif\n\n  if (!IsObject(v)) {\n    // root is not an object.\n    if (err) {\n      (*err) = \"Root element is not a JSON object\\n\";\n    }\n    return false;\n  }\n\n  {\n    bool version_found = false;\n    json_const_iterator it;\n    if (FindMember(v, \"asset\", it) && IsObject(GetValue(it))) {\n      auto &itObj = GetValue(it);\n      json_const_iterator version_it;\n      std::string versionStr;\n      if (FindMember(itObj, \"version\", version_it) &&\n          GetString(GetValue(version_it), versionStr)) {\n        version_found = true;\n      }\n    }\n    if (version_found) {\n      // OK\n    } else if (check_sections & REQUIRE_VERSION) {\n      if (err) {\n        (*err) += \"\\\"asset\\\" object not found in .gltf or not an object type\\n\";\n      }\n      return false;\n    }\n  }\n\n  // scene is not mandatory.\n  // FIXME Maybe a better way to handle it than removing the code\n\n  auto IsArrayMemberPresent = [](const json &_v, const char *name) -> bool {\n    json_const_iterator it;\n    return FindMember(_v, name, it) && IsArray(GetValue(it));\n  };\n\n  {\n    if ((check_sections & REQUIRE_SCENES) &&\n        !IsArrayMemberPresent(v, \"scenes\")) {\n      if (err) {\n        (*err) += \"\\\"scenes\\\" object not found in .gltf or not an array type\\n\";\n      }\n      return false;\n    }\n  }\n\n  {\n    if ((check_sections & REQUIRE_NODES) && !IsArrayMemberPresent(v, \"nodes\")) {\n      if (err) {\n        (*err) += \"\\\"nodes\\\" object not found in .gltf\\n\";\n      }\n      return false;\n    }\n  }\n\n  {\n    if ((check_sections & REQUIRE_ACCESSORS) &&\n        !IsArrayMemberPresent(v, \"accessors\")) {\n      if (err) {\n        (*err) += \"\\\"accessors\\\" object not found in .gltf\\n\";\n      }\n      return false;\n    }\n  }\n\n  {\n    if ((check_sections & REQUIRE_BUFFERS) &&\n        !IsArrayMemberPresent(v, \"buffers\")) {\n      if (err) {\n        (*err) += \"\\\"buffers\\\" object not found in .gltf\\n\";\n      }\n      return false;\n    }\n  }\n\n  {\n    if ((check_sections & REQUIRE_BUFFER_VIEWS) &&\n        !IsArrayMemberPresent(v, \"bufferViews\")) {\n      if (err) {\n        (*err) += \"\\\"bufferViews\\\" object not found in .gltf\\n\";\n      }\n      return false;\n    }\n  }\n\n  model->buffers.clear();\n  model->bufferViews.clear();\n  model->accessors.clear();\n  model->meshes.clear();\n  model->cameras.clear();\n  model->nodes.clear();\n  model->extensionsUsed.clear();\n  model->extensionsRequired.clear();\n  model->extensions.clear();\n  model->defaultScene = -1;\n\n  // 1. Parse Asset\n  {\n    json_const_iterator it;\n    if (FindMember(v, \"asset\", it) && IsObject(GetValue(it))) {\n      const json &root = GetValue(it);\n\n      ParseAsset(&model->asset, err, root,\n                 store_original_json_for_extras_and_extensions_);\n    }\n  }\n\n#ifdef TINYGLTF_USE_CPP14\n  auto ForEachInArray = [](const json &_v, const char *member,\n                           const auto &cb) -> bool\n#else\n  // The std::function<> implementation can be less efficient because it will\n  // allocate heap when the size of the captured lambda is above 16 bytes with\n  // clang and gcc, but it does not require C++14.\n  auto ForEachInArray = [](const json &_v, const char *member,\n                           const std::function<bool(const json &)> &cb) -> bool\n#endif\n  {\n    json_const_iterator itm;\n    if (FindMember(_v, member, itm) && IsArray(GetValue(itm))) {\n      const json &root = GetValue(itm);\n      auto it = ArrayBegin(root);\n      auto end = ArrayEnd(root);\n      for (; it != end; ++it) {\n        if (!cb(*it)) return false;\n      }\n    }\n    return true;\n  };\n\n  // 2. Parse extensionUsed\n  {\n    ForEachInArray(v, \"extensionsUsed\", [&](const json &o) {\n      std::string str;\n      GetString(o, str);\n      model->extensionsUsed.emplace_back(std::move(str));\n      return true;\n    });\n  }\n\n  {\n    ForEachInArray(v, \"extensionsRequired\", [&](const json &o) {\n      std::string str;\n      GetString(o, str);\n      model->extensionsRequired.emplace_back(std::move(str));\n      return true;\n    });\n  }\n\n  // 3. Parse Buffer\n  {\n    bool success = ForEachInArray(v, \"buffers\", [&](const json &o) {\n      if (!IsObject(o)) {\n        if (err) {\n          (*err) += \"`buffers' does not contain an JSON object.\";\n        }\n        return false;\n      }\n      Buffer buffer;\n      if (!ParseBuffer(&buffer, err, o,\n                       store_original_json_for_extras_and_extensions_, &fs,\n                       base_dir, is_binary_, bin_data_, bin_size_)) {\n        return false;\n      }\n\n      model->buffers.emplace_back(std::move(buffer));\n      return true;\n    });\n\n    if (!success) {\n      return false;\n    }\n  }\n  // 4. Parse BufferView\n  {\n    bool success = ForEachInArray(v, \"bufferViews\", [&](const json &o) {\n      if (!IsObject(o)) {\n        if (err) {\n          (*err) += \"`bufferViews' does not contain an JSON object.\";\n        }\n        return false;\n      }\n      BufferView bufferView;\n      if (!ParseBufferView(&bufferView, err, o,\n                           store_original_json_for_extras_and_extensions_)) {\n        return false;\n      }\n\n      model->bufferViews.emplace_back(std::move(bufferView));\n      return true;\n    });\n\n    if (!success) {\n      return false;\n    }\n  }\n\n  // 5. Parse Accessor\n  {\n    bool success = ForEachInArray(v, \"accessors\", [&](const json &o) {\n      if (!IsObject(o)) {\n        if (err) {\n          (*err) += \"`accessors' does not contain an JSON object.\";\n        }\n        return false;\n      }\n      Accessor accessor;\n      if (!ParseAccessor(&accessor, err, o,\n                         store_original_json_for_extras_and_extensions_)) {\n        return false;\n      }\n\n      model->accessors.emplace_back(std::move(accessor));\n      return true;\n    });\n\n    if (!success) {\n      return false;\n    }\n  }\n\n  // 6. Parse Mesh\n  {\n    bool success = ForEachInArray(v, \"meshes\", [&](const json &o) {\n      if (!IsObject(o)) {\n        if (err) {\n          (*err) += \"`meshes' does not contain an JSON object.\";\n        }\n        return false;\n      }\n      Mesh mesh;\n      if (!ParseMesh(&mesh, model, err, o,\n                     store_original_json_for_extras_and_extensions_)) {\n        return false;\n      }\n\n      model->meshes.emplace_back(std::move(mesh));\n      return true;\n    });\n\n    if (!success) {\n      return false;\n    }\n  }\n\n  // Assign missing bufferView target types\n  // - Look for missing Mesh indices\n  // - Look for missing Mesh attributes\n  for (auto &mesh : model->meshes) {\n    for (auto &primitive : mesh.primitives) {\n      if (primitive.indices >\n          -1)  // has indices from parsing step, must be Element Array Buffer\n      {\n        if (size_t(primitive.indices) >= model->accessors.size()) {\n          if (err) {\n            (*err) += \"primitive indices accessor out of bounds\";\n          }\n          return false;\n        }\n\n        auto bufferView =\n            model->accessors[size_t(primitive.indices)].bufferView;\n        if (bufferView < 0 || size_t(bufferView) >= model->bufferViews.size()) {\n          if (err) {\n            (*err) += \"accessor[\" + std::to_string(primitive.indices) +\n                      \"] invalid bufferView\";\n          }\n          return false;\n        }\n\n        model->bufferViews[size_t(bufferView)].target =\n            TINYGLTF_TARGET_ELEMENT_ARRAY_BUFFER;\n        // we could optionally check if acessors' bufferView type is Scalar, as\n        // it should be\n      }\n\n      for (auto &attribute : primitive.attributes) {\n        model\n            ->bufferViews[size_t(\n                model->accessors[size_t(attribute.second)].bufferView)]\n            .target = TINYGLTF_TARGET_ARRAY_BUFFER;\n      }\n\n      for (auto &target : primitive.targets) {\n        for (auto &attribute : target) {\n          auto bufferView =\n              model->accessors[size_t(attribute.second)].bufferView;\n          // bufferView could be null(-1) for sparse morph target\n          if (bufferView >= 0) {\n            model->bufferViews[size_t(bufferView)].target =\n                TINYGLTF_TARGET_ARRAY_BUFFER;\n          }\n        }\n      }\n    }\n  }\n\n  // 7. Parse Node\n  {\n    bool success = ForEachInArray(v, \"nodes\", [&](const json &o) {\n      if (!IsObject(o)) {\n        if (err) {\n          (*err) += \"`nodes' does not contain an JSON object.\";\n        }\n        return false;\n      }\n      Node node;\n      if (!ParseNode(&node, err, o,\n                     store_original_json_for_extras_and_extensions_)) {\n        return false;\n      }\n\n      model->nodes.emplace_back(std::move(node));\n      return true;\n    });\n\n    if (!success) {\n      return false;\n    }\n  }\n\n  // 8. Parse scenes.\n  {\n    bool success = ForEachInArray(v, \"scenes\", [&](const json &o) {\n      if (!IsObject(o)) {\n        if (err) {\n          (*err) += \"`scenes' does not contain an JSON object.\";\n        }\n        return false;\n      }\n      std::vector<int> nodes;\n      ParseIntegerArrayProperty(&nodes, err, o, \"nodes\", false);\n\n      Scene scene;\n      scene.nodes = std::move(nodes);\n\n      ParseStringProperty(&scene.name, err, o, \"name\", false);\n\n      ParseExtensionsProperty(&scene.extensions, err, o);\n      ParseExtrasProperty(&scene.extras, o);\n\n      if (store_original_json_for_extras_and_extensions_) {\n        {\n          json_const_iterator it;\n          if (FindMember(o, \"extensions\", it)) {\n            scene.extensions_json_string = JsonToString(GetValue(it));\n          }\n        }\n        {\n          json_const_iterator it;\n          if (FindMember(o, \"extras\", it)) {\n            scene.extras_json_string = JsonToString(GetValue(it));\n          }\n        }\n      }\n\n      model->scenes.emplace_back(std::move(scene));\n      return true;\n    });\n\n    if (!success) {\n      return false;\n    }\n  }\n\n  // 9. Parse default scenes.\n  {\n    json_const_iterator rootIt;\n    int iVal;\n    if (FindMember(v, \"scene\", rootIt) && GetInt(GetValue(rootIt), iVal)) {\n      model->defaultScene = iVal;\n    }\n  }\n\n  // 10. Parse Material\n  {\n    bool success = ForEachInArray(v, \"materials\", [&](const json &o) {\n      if (!IsObject(o)) {\n        if (err) {\n          (*err) += \"`materials' does not contain an JSON object.\";\n        }\n        return false;\n      }\n      Material material;\n      ParseStringProperty(&material.name, err, o, \"name\", false);\n\n      if (!ParseMaterial(&material, err, o,\n                         store_original_json_for_extras_and_extensions_)) {\n        return false;\n      }\n\n      model->materials.emplace_back(std::move(material));\n      return true;\n    });\n\n    if (!success) {\n      return false;\n    }\n  }\n\n  // 11. Parse Image\n  void *load_image_user_data{nullptr};\n\n  LoadImageDataOption load_image_option;\n\n  if (user_image_loader_) {\n    // Use user supplied pointer\n    load_image_user_data = load_image_user_data_;\n  } else {\n    load_image_option.preserve_channels = preserve_image_channels_;\n    load_image_user_data = reinterpret_cast<void *>(&load_image_option);\n  }\n\n  {\n    int idx = 0;\n    bool success = ForEachInArray(v, \"images\", [&](const json &o) {\n      if (!IsObject(o)) {\n        if (err) {\n          (*err) += \"image[\" + std::to_string(idx) + \"] is not a JSON object.\";\n        }\n        return false;\n      }\n      Image image;\n      if (!ParseImage(&image, idx, err, warn, o,\n                      store_original_json_for_extras_and_extensions_, base_dir,\n                      &fs, &this->LoadImageData, load_image_user_data)) {\n        return false;\n      }\n\n      if (image.bufferView != -1) {\n        // Load image from the buffer view.\n        if (size_t(image.bufferView) >= model->bufferViews.size()) {\n          if (err) {\n            std::stringstream ss;\n            ss << \"image[\" << idx << \"] bufferView \\\"\" << image.bufferView\n               << \"\\\" not found in the scene.\" << std::endl;\n            (*err) += ss.str();\n          }\n          return false;\n        }\n\n        const BufferView &bufferView =\n            model->bufferViews[size_t(image.bufferView)];\n        if (size_t(bufferView.buffer) >= model->buffers.size()) {\n          if (err) {\n            std::stringstream ss;\n            ss << \"image[\" << idx << \"] buffer \\\"\" << bufferView.buffer\n               << \"\\\" not found in the scene.\" << std::endl;\n            (*err) += ss.str();\n          }\n          return false;\n        }\n        const Buffer &buffer = model->buffers[size_t(bufferView.buffer)];\n\n        if (*LoadImageData == nullptr) {\n          if (err) {\n            (*err) += \"No LoadImageData callback specified.\\n\";\n          }\n          return false;\n        }\n        bool ret = LoadImageData(\n            &image, idx, err, warn, image.width, image.height,\n            &buffer.data[bufferView.byteOffset],\n            static_cast<int>(bufferView.byteLength), load_image_user_data);\n        if (!ret) {\n          return false;\n        }\n      }\n\n      model->images.emplace_back(std::move(image));\n      ++idx;\n      return true;\n    });\n\n    if (!success) {\n      return false;\n    }\n  }\n\n  // 12. Parse Texture\n  {\n    bool success = ForEachInArray(v, \"textures\", [&](const json &o) {\n      if (!IsObject(o)) {\n        if (err) {\n          (*err) += \"`textures' does not contain an JSON object.\";\n        }\n        return false;\n      }\n      Texture texture;\n      if (!ParseTexture(&texture, err, o,\n                        store_original_json_for_extras_and_extensions_,\n                        base_dir)) {\n        return false;\n      }\n\n      model->textures.emplace_back(std::move(texture));\n      return true;\n    });\n\n    if (!success) {\n      return false;\n    }\n  }\n\n  // 13. Parse Animation\n  {\n    bool success = ForEachInArray(v, \"animations\", [&](const json &o) {\n      if (!IsObject(o)) {\n        if (err) {\n          (*err) += \"`animations' does not contain an JSON object.\";\n        }\n        return false;\n      }\n      Animation animation;\n      if (!ParseAnimation(&animation, err, o,\n                          store_original_json_for_extras_and_extensions_)) {\n        return false;\n      }\n\n      model->animations.emplace_back(std::move(animation));\n      return true;\n    });\n\n    if (!success) {\n      return false;\n    }\n  }\n\n  // 14. Parse Skin\n  {\n    bool success = ForEachInArray(v, \"skins\", [&](const json &o) {\n      if (!IsObject(o)) {\n        if (err) {\n          (*err) += \"`skins' does not contain an JSON object.\";\n        }\n        return false;\n      }\n      Skin skin;\n      if (!ParseSkin(&skin, err, o,\n                     store_original_json_for_extras_and_extensions_)) {\n        return false;\n      }\n\n      model->skins.emplace_back(std::move(skin));\n      return true;\n    });\n\n    if (!success) {\n      return false;\n    }\n  }\n\n  // 15. Parse Sampler\n  {\n    bool success = ForEachInArray(v, \"samplers\", [&](const json &o) {\n      if (!IsObject(o)) {\n        if (err) {\n          (*err) += \"`samplers' does not contain an JSON object.\";\n        }\n        return false;\n      }\n      Sampler sampler;\n      if (!ParseSampler(&sampler, err, o,\n                        store_original_json_for_extras_and_extensions_)) {\n        return false;\n      }\n\n      model->samplers.emplace_back(std::move(sampler));\n      return true;\n    });\n\n    if (!success) {\n      return false;\n    }\n  }\n\n  // 16. Parse Camera\n  {\n    bool success = ForEachInArray(v, \"cameras\", [&](const json &o) {\n      if (!IsObject(o)) {\n        if (err) {\n          (*err) += \"`cameras' does not contain an JSON object.\";\n        }\n        return false;\n      }\n      Camera camera;\n      if (!ParseCamera(&camera, err, o,\n                       store_original_json_for_extras_and_extensions_)) {\n        return false;\n      }\n\n      model->cameras.emplace_back(std::move(camera));\n      return true;\n    });\n\n    if (!success) {\n      return false;\n    }\n  }\n\n  // 17. Parse Extensions\n  ParseExtensionsProperty(&model->extensions, err, v);\n\n  // 18. Specific extension implementations\n  {\n    json_const_iterator rootIt;\n    if (FindMember(v, \"extensions\", rootIt) && IsObject(GetValue(rootIt))) {\n      const json &root = GetValue(rootIt);\n\n      json_const_iterator it(ObjectBegin(root));\n      json_const_iterator itEnd(ObjectEnd(root));\n      for (; it != itEnd; ++it) {\n        // parse KHR_lights_punctual extension\n        std::string key(GetKey(it));\n        if ((key == \"KHR_lights_punctual\") && IsObject(GetValue(it))) {\n          const json &object = GetValue(it);\n          json_const_iterator itLight;\n          if (FindMember(object, \"lights\", itLight)) {\n            const json &lights = GetValue(itLight);\n            if (!IsArray(lights)) {\n              continue;\n            }\n\n            auto arrayIt(ArrayBegin(lights));\n            auto arrayItEnd(ArrayEnd(lights));\n            for (; arrayIt != arrayItEnd; ++arrayIt) {\n              Light light;\n              if (!ParseLight(&light, err, *arrayIt,\n                              store_original_json_for_extras_and_extensions_)) {\n                return false;\n              }\n              model->lights.emplace_back(std::move(light));\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // 19. Parse Extras\n  ParseExtrasProperty(&model->extras, v);\n\n  if (store_original_json_for_extras_and_extensions_) {\n    model->extras_json_string = JsonToString(v[\"extras\"]);\n    model->extensions_json_string = JsonToString(v[\"extensions\"]);\n  }\n\n  return true;\n}\n\nbool TinyGLTF::LoadASCIIFromString(Model *model, std::string *err,\n                                   std::string *warn, const char *str,\n                                   unsigned int length,\n                                   const std::string &base_dir,\n                                   unsigned int check_sections) {\n  is_binary_ = false;\n  bin_data_ = nullptr;\n  bin_size_ = 0;\n\n  return LoadFromString(model, err, warn, str, length, base_dir,\n                        check_sections);\n}\n\nbool TinyGLTF::LoadASCIIFromFile(Model *model, std::string *err,\n                                 std::string *warn, const std::string &filename,\n                                 unsigned int check_sections) {\n  std::stringstream ss;\n\n  if (fs.ReadWholeFile == nullptr) {\n    // Programmer error, assert() ?\n    ss << \"Failed to read file: \" << filename\n       << \": one or more FS callback not set\" << std::endl;\n    if (err) {\n      (*err) = ss.str();\n    }\n    return false;\n  }\n\n  std::vector<unsigned char> data;\n  std::string fileerr;\n  bool fileread = fs.ReadWholeFile(&data, &fileerr, filename, fs.user_data);\n  if (!fileread) {\n    ss << \"Failed to read file: \" << filename << \": \" << fileerr << std::endl;\n    if (err) {\n      (*err) = ss.str();\n    }\n    return false;\n  }\n\n  size_t sz = data.size();\n  if (sz == 0) {\n    if (err) {\n      (*err) = \"Empty file.\";\n    }\n    return false;\n  }\n\n  std::string basedir = GetBaseDir(filename);\n\n  bool ret = LoadASCIIFromString(\n      model, err, warn, reinterpret_cast<const char *>(&data.at(0)),\n      static_cast<unsigned int>(data.size()), basedir, check_sections);\n\n  return ret;\n}\n\nbool TinyGLTF::LoadBinaryFromMemory(Model *model, std::string *err,\n                                    std::string *warn,\n                                    const unsigned char *bytes,\n                                    unsigned int size,\n                                    const std::string &base_dir,\n                                    unsigned int check_sections) {\n  if (size < 20) {\n    if (err) {\n      (*err) = \"Too short data size for glTF Binary.\";\n    }\n    return false;\n  }\n\n  if (bytes[0] == 'g' && bytes[1] == 'l' && bytes[2] == 'T' &&\n      bytes[3] == 'F') {\n    // ok\n  } else {\n    if (err) {\n      (*err) = \"Invalid magic.\";\n    }\n    return false;\n  }\n\n  unsigned int version;       // 4 bytes\n  unsigned int length;        // 4 bytes\n  unsigned int model_length;  // 4 bytes\n  unsigned int model_format;  // 4 bytes;\n\n  // @todo { Endian swap for big endian machine. }\n  memcpy(&version, bytes + 4, 4);\n  swap4(&version);\n  memcpy(&length, bytes + 8, 4);\n  swap4(&length);\n  memcpy(&model_length, bytes + 12, 4);\n  swap4(&model_length);\n  memcpy(&model_format, bytes + 16, 4);\n  swap4(&model_format);\n\n  // In case the Bin buffer is not present, the size is exactly 20 + size of\n  // JSON contents,\n  // so use \"greater than\" operator.\n  if ((20 + model_length > size) || (model_length < 1) || (length > size) ||\n      (20 + model_length > length) ||\n      (model_format != 0x4E4F534A)) {  // 0x4E4F534A = JSON format.\n    if (err) {\n      (*err) = \"Invalid glTF binary.\";\n    }\n    return false;\n  }\n\n  // Extract JSON string.\n  std::string jsonString(reinterpret_cast<const char *>(&bytes[20]),\n                         model_length);\n\n  is_binary_ = true;\n  bin_data_ = bytes + 20 + model_length +\n              8;  // 4 bytes (buffer_length) + 4 bytes(buffer_format)\n  bin_size_ =\n      length - (20 + model_length);  // extract header + JSON scene data.\n\n  bool ret = LoadFromString(model, err, warn,\n                            reinterpret_cast<const char *>(&bytes[20]),\n                            model_length, base_dir, check_sections);\n  if (!ret) {\n    return ret;\n  }\n\n  return true;\n}\n\nbool TinyGLTF::LoadBinaryFromFile(Model *model, std::string *err,\n                                  std::string *warn,\n                                  const std::string &filename,\n                                  unsigned int check_sections) {\n  std::stringstream ss;\n\n  if (fs.ReadWholeFile == nullptr) {\n    // Programmer error, assert() ?\n    ss << \"Failed to read file: \" << filename\n       << \": one or more FS callback not set\" << std::endl;\n    if (err) {\n      (*err) = ss.str();\n    }\n    return false;\n  }\n\n  std::vector<unsigned char> data;\n  std::string fileerr;\n  bool fileread = fs.ReadWholeFile(&data, &fileerr, filename, fs.user_data);\n  if (!fileread) {\n    ss << \"Failed to read file: \" << filename << \": \" << fileerr << std::endl;\n    if (err) {\n      (*err) = ss.str();\n    }\n    return false;\n  }\n\n  std::string basedir = GetBaseDir(filename);\n\n  bool ret = LoadBinaryFromMemory(model, err, warn, &data.at(0),\n                                  static_cast<unsigned int>(data.size()),\n                                  basedir, check_sections);\n\n  return ret;\n}\n\n///////////////////////\n// GLTF Serialization\n///////////////////////\nnamespace {\njson JsonFromString(const char *s) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  return json(s, GetAllocator());\n#else\n  return json(s);\n#endif\n}\n\nvoid JsonAssign(json &dest, const json &src) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  dest.CopyFrom(src, GetAllocator());\n#else\n  dest = src;\n#endif\n}\n\nvoid JsonAddMember(json &o, const char *key, json &&value) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  if (!o.IsObject()) {\n    o.SetObject();\n  }\n  o.AddMember(json(key, GetAllocator()), std::move(value), GetAllocator());\n#else\n  o[key] = std::move(value);\n#endif\n}\n\nvoid JsonPushBack(json &o, json &&value) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  o.PushBack(std::move(value), GetAllocator());\n#else\n  o.push_back(std::move(value));\n#endif\n}\n\nbool JsonIsNull(const json &o) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  return o.IsNull();\n#else\n  return o.is_null();\n#endif\n}\n\nvoid JsonSetObject(json &o) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  o.SetObject();\n#else\n  o = o.object({});\n#endif\n}\n\nvoid JsonReserveArray(json &o, size_t s) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  o.SetArray();\n  o.Reserve(static_cast<rapidjson::SizeType>(s), GetAllocator());\n#endif\n  (void)(o);\n  (void)(s);\n}\n}  // namespace\n\n// typedef std::pair<std::string, json> json_object_pair;\n\ntemplate <typename T>\nstatic void SerializeNumberProperty(const std::string &key, T number,\n                                    json &obj) {\n  // obj.insert(\n  //    json_object_pair(key, json(static_cast<double>(number))));\n  // obj[key] = static_cast<double>(number);\n  JsonAddMember(obj, key.c_str(), json(number));\n}\n\n#ifdef TINYGLTF_USE_RAPIDJSON\ntemplate <>\nvoid SerializeNumberProperty(const std::string &key, size_t number, json &obj) {\n  JsonAddMember(obj, key.c_str(), json(static_cast<uint64_t>(number)));\n}\n#endif\n\ntemplate <typename T>\nstatic void SerializeNumberArrayProperty(const std::string &key,\n                                         const std::vector<T> &value,\n                                         json &obj) {\n  if (value.empty()) return;\n\n  json ary;\n  JsonReserveArray(ary, value.size());\n  for (const auto &s : value) {\n    JsonPushBack(ary, json(s));\n  }\n  JsonAddMember(obj, key.c_str(), std::move(ary));\n}\n\nstatic void SerializeStringProperty(const std::string &key,\n                                    const std::string &value, json &obj) {\n  JsonAddMember(obj, key.c_str(), JsonFromString(value.c_str()));\n}\n\nstatic void SerializeStringArrayProperty(const std::string &key,\n                                         const std::vector<std::string> &value,\n                                         json &obj) {\n  json ary;\n  JsonReserveArray(ary, value.size());\n  for (auto &s : value) {\n    JsonPushBack(ary, JsonFromString(s.c_str()));\n  }\n  JsonAddMember(obj, key.c_str(), std::move(ary));\n}\n\nstatic bool ValueToJson(const Value &value, json *ret) {\n  json obj;\n#ifdef TINYGLTF_USE_RAPIDJSON\n  switch (value.Type()) {\n    case REAL_TYPE:\n      obj.SetDouble(value.Get<double>());\n      break;\n    case INT_TYPE:\n      obj.SetInt(value.Get<int>());\n      break;\n    case BOOL_TYPE:\n      obj.SetBool(value.Get<bool>());\n      break;\n    case STRING_TYPE:\n      obj.SetString(value.Get<std::string>().c_str(), GetAllocator());\n      break;\n    case ARRAY_TYPE: {\n      obj.SetArray();\n      obj.Reserve(static_cast<rapidjson::SizeType>(value.ArrayLen()),\n                  GetAllocator());\n      for (unsigned int i = 0; i < value.ArrayLen(); ++i) {\n        Value elementValue = value.Get(int(i));\n        json elementJson;\n        if (ValueToJson(value.Get(int(i)), &elementJson))\n          obj.PushBack(std::move(elementJson), GetAllocator());\n      }\n      break;\n    }\n    case BINARY_TYPE:\n      // TODO\n      // obj = json(value.Get<std::vector<unsigned char>>());\n      return false;\n      break;\n    case OBJECT_TYPE: {\n      obj.SetObject();\n      Value::Object objMap = value.Get<Value::Object>();\n      for (auto &it : objMap) {\n        json elementJson;\n        if (ValueToJson(it.second, &elementJson)) {\n          obj.AddMember(json(it.first.c_str(), GetAllocator()),\n                        std::move(elementJson), GetAllocator());\n        }\n      }\n      break;\n    }\n    case NULL_TYPE:\n    default:\n      return false;\n  }\n#else\n  switch (value.Type()) {\n    case REAL_TYPE:\n      obj = json(value.Get<double>());\n      break;\n    case INT_TYPE:\n      obj = json(value.Get<int>());\n      break;\n    case BOOL_TYPE:\n      obj = json(value.Get<bool>());\n      break;\n    case STRING_TYPE:\n      obj = json(value.Get<std::string>());\n      break;\n    case ARRAY_TYPE: {\n      for (unsigned int i = 0; i < value.ArrayLen(); ++i) {\n        Value elementValue = value.Get(int(i));\n        json elementJson;\n        if (ValueToJson(value.Get(int(i)), &elementJson))\n          obj.push_back(elementJson);\n      }\n      break;\n    }\n    case BINARY_TYPE:\n      // TODO\n      // obj = json(value.Get<std::vector<unsigned char>>());\n      return false;\n      break;\n    case OBJECT_TYPE: {\n      Value::Object objMap = value.Get<Value::Object>();\n      for (auto &it : objMap) {\n        json elementJson;\n        if (ValueToJson(it.second, &elementJson)) obj[it.first] = elementJson;\n      }\n      break;\n    }\n    case NULL_TYPE:\n    default:\n      return false;\n  }\n#endif\n  if (ret) *ret = std::move(obj);\n  return true;\n}\n\nstatic void SerializeValue(const std::string &key, const Value &value,\n                           json &obj) {\n  json ret;\n  if (ValueToJson(value, &ret)) {\n    JsonAddMember(obj, key.c_str(), std::move(ret));\n  }\n}\n\nstatic void SerializeGltfBufferData(const std::vector<unsigned char> &data,\n                                    json &o) {\n  std::string header = \"data:application/octet-stream;base64,\";\n  if (data.size() > 0) {\n    std::string encodedData =\n        base64_encode(&data[0], static_cast<unsigned int>(data.size()));\n    SerializeStringProperty(\"uri\", header + encodedData, o);\n  } else {\n    // Issue #229\n    // size 0 is allowd. Just emit mime header.\n    SerializeStringProperty(\"uri\", header, o);\n  }\n}\n\nstatic bool SerializeGltfBufferData(const std::vector<unsigned char> &data,\n                                    const std::string &binFilename) {\n#ifdef _WIN32\n#if defined(__GLIBCXX__)  // mingw\n  int file_descriptor = _wopen(UTF8ToWchar(binFilename).c_str(),\n                               _O_CREAT | _O_WRONLY | _O_TRUNC | _O_BINARY);\n  __gnu_cxx::stdio_filebuf<char> wfile_buf(\n      file_descriptor, std::ios_base::out | std::ios_base::binary);\n  std::ostream output(&wfile_buf);\n  if (!wfile_buf.is_open()) return false;\n#elif defined(_MSC_VER)\n  std::ofstream output(UTF8ToWchar(binFilename).c_str(), std::ofstream::binary);\n  if (!output.is_open()) return false;\n#else\n  std::ofstream output(binFilename.c_str(), std::ofstream::binary);\n  if (!output.is_open()) return false;\n#endif\n#else\n  std::ofstream output(binFilename.c_str(), std::ofstream::binary);\n  if (!output.is_open()) return false;\n#endif\n  if (data.size() > 0) {\n    output.write(reinterpret_cast<const char *>(&data[0]),\n                 std::streamsize(data.size()));\n  } else {\n    // Issue #229\n    // size 0 will be still valid buffer data.\n    // write empty file.\n  }\n  return true;\n}\n\n#if 0  // FIXME(syoyo): not used. will be removed in the future release.\nstatic void SerializeParameterMap(ParameterMap &param, json &o) {\n  for (ParameterMap::iterator paramIt = param.begin(); paramIt != param.end();\n       ++paramIt) {\n    if (paramIt->second.number_array.size()) {\n      SerializeNumberArrayProperty<double>(paramIt->first,\n                                           paramIt->second.number_array, o);\n    } else if (paramIt->second.json_double_value.size()) {\n      json json_double_value;\n      for (std::map<std::string, double>::iterator it =\n               paramIt->second.json_double_value.begin();\n           it != paramIt->second.json_double_value.end(); ++it) {\n        if (it->first == \"index\") {\n          json_double_value[it->first] = paramIt->second.TextureIndex();\n        } else {\n          json_double_value[it->first] = it->second;\n        }\n      }\n\n      o[paramIt->first] = json_double_value;\n    } else if (!paramIt->second.string_value.empty()) {\n      SerializeStringProperty(paramIt->first, paramIt->second.string_value, o);\n    } else if (paramIt->second.has_number_value) {\n      o[paramIt->first] = paramIt->second.number_value;\n    } else {\n      o[paramIt->first] = paramIt->second.bool_value;\n    }\n  }\n}\n#endif\n\nstatic void SerializeExtensionMap(const ExtensionMap &extensions, json &o) {\n  if (!extensions.size()) return;\n\n  json extMap;\n  for (ExtensionMap::const_iterator extIt = extensions.begin();\n       extIt != extensions.end(); ++extIt) {\n    // Allow an empty object for extension(#97)\n    json ret;\n    bool isNull = true;\n    if (ValueToJson(extIt->second, &ret)) {\n      isNull = JsonIsNull(ret);\n      JsonAddMember(extMap, extIt->first.c_str(), std::move(ret));\n    }\n    if (isNull) {\n      if (!(extIt->first.empty())) {  // name should not be empty, but for sure\n        // create empty object so that an extension name is still included in\n        // json.\n        json empty;\n        JsonSetObject(empty);\n        JsonAddMember(extMap, extIt->first.c_str(), std::move(empty));\n      }\n    }\n  }\n  JsonAddMember(o, \"extensions\", std::move(extMap));\n}\n\nstatic void SerializeGltfAccessor(Accessor &accessor, json &o) {\n  if (accessor.bufferView >= 0)\n    SerializeNumberProperty<int>(\"bufferView\", accessor.bufferView, o);\n\n  if (accessor.byteOffset != 0)\n    SerializeNumberProperty<int>(\"byteOffset\", int(accessor.byteOffset), o);\n\n  SerializeNumberProperty<int>(\"componentType\", accessor.componentType, o);\n  SerializeNumberProperty<size_t>(\"count\", accessor.count, o);\n\n  if ((accessor.componentType == TINYGLTF_COMPONENT_TYPE_FLOAT) ||\n      (accessor.componentType == TINYGLTF_COMPONENT_TYPE_DOUBLE)) {\n    SerializeNumberArrayProperty<double>(\"min\", accessor.minValues, o);\n    SerializeNumberArrayProperty<double>(\"max\", accessor.maxValues, o);\n  } else {\n    // Issue #301. Serialize as integer.\n    // Assume int value is within [-2**31-1, 2**31-1]\n    {\n      std::vector<int> values;\n      std::transform(accessor.minValues.begin(), accessor.minValues.end(),\n                     std::back_inserter(values),\n                     [](double v) { return static_cast<int>(v); });\n\n      SerializeNumberArrayProperty<int>(\"min\", values, o);\n    }\n\n    {\n      std::vector<int> values;\n      std::transform(accessor.maxValues.begin(), accessor.maxValues.end(),\n                     std::back_inserter(values),\n                     [](double v) { return static_cast<int>(v); });\n\n      SerializeNumberArrayProperty<int>(\"max\", values, o);\n    }\n  }\n\n  if (accessor.normalized)\n    SerializeValue(\"normalized\", Value(accessor.normalized), o);\n  std::string type;\n  switch (accessor.type) {\n    case TINYGLTF_TYPE_SCALAR:\n      type = \"SCALAR\";\n      break;\n    case TINYGLTF_TYPE_VEC2:\n      type = \"VEC2\";\n      break;\n    case TINYGLTF_TYPE_VEC3:\n      type = \"VEC3\";\n      break;\n    case TINYGLTF_TYPE_VEC4:\n      type = \"VEC4\";\n      break;\n    case TINYGLTF_TYPE_MAT2:\n      type = \"MAT2\";\n      break;\n    case TINYGLTF_TYPE_MAT3:\n      type = \"MAT3\";\n      break;\n    case TINYGLTF_TYPE_MAT4:\n      type = \"MAT4\";\n      break;\n  }\n\n  SerializeStringProperty(\"type\", type, o);\n  if (!accessor.name.empty()) SerializeStringProperty(\"name\", accessor.name, o);\n\n  if (accessor.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", accessor.extras, o);\n  }\n}\n\nstatic void SerializeGltfAnimationChannel(AnimationChannel &channel, json &o) {\n  SerializeNumberProperty(\"sampler\", channel.sampler, o);\n  {\n    json target;\n    SerializeNumberProperty(\"node\", channel.target_node, target);\n    SerializeStringProperty(\"path\", channel.target_path, target);\n\n    SerializeExtensionMap(channel.target_extensions, target);\n\n    JsonAddMember(o, \"target\", std::move(target));\n  }\n\n  if (channel.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", channel.extras, o);\n  }\n\n  SerializeExtensionMap(channel.extensions, o);\n}\n\nstatic void SerializeGltfAnimationSampler(AnimationSampler &sampler, json &o) {\n  SerializeNumberProperty(\"input\", sampler.input, o);\n  SerializeNumberProperty(\"output\", sampler.output, o);\n  SerializeStringProperty(\"interpolation\", sampler.interpolation, o);\n\n  if (sampler.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", sampler.extras, o);\n  }\n}\n\nstatic void SerializeGltfAnimation(Animation &animation, json &o) {\n  if (!animation.name.empty())\n    SerializeStringProperty(\"name\", animation.name, o);\n\n  {\n    json channels;\n    JsonReserveArray(channels, animation.channels.size());\n    for (unsigned int i = 0; i < animation.channels.size(); ++i) {\n      json channel;\n      AnimationChannel gltfChannel = animation.channels[i];\n      SerializeGltfAnimationChannel(gltfChannel, channel);\n      JsonPushBack(channels, std::move(channel));\n    }\n\n    JsonAddMember(o, \"channels\", std::move(channels));\n  }\n\n  {\n    json samplers;\n    JsonReserveArray(samplers, animation.samplers.size());\n    for (unsigned int i = 0; i < animation.samplers.size(); ++i) {\n      json sampler;\n      AnimationSampler gltfSampler = animation.samplers[i];\n      SerializeGltfAnimationSampler(gltfSampler, sampler);\n      JsonPushBack(samplers, std::move(sampler));\n    }\n    JsonAddMember(o, \"samplers\", std::move(samplers));\n  }\n\n  if (animation.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", animation.extras, o);\n  }\n\n  SerializeExtensionMap(animation.extensions, o);\n}\n\nstatic void SerializeGltfAsset(Asset &asset, json &o) {\n  if (!asset.generator.empty()) {\n    SerializeStringProperty(\"generator\", asset.generator, o);\n  }\n\n  if (!asset.copyright.empty()) {\n    SerializeStringProperty(\"copyright\", asset.copyright, o);\n  }\n\n  if (asset.version.empty()) {\n    // Just in case\n    // `version` must be defined\n    asset.version = \"2.0\";\n  }\n\n  // TODO(syoyo): Do we need to check if `version` is greater or equal to 2.0?\n  SerializeStringProperty(\"version\", asset.version, o);\n\n  if (asset.extras.Keys().size()) {\n    SerializeValue(\"extras\", asset.extras, o);\n  }\n\n  SerializeExtensionMap(asset.extensions, o);\n}\n\nstatic void SerializeGltfBufferBin(Buffer &buffer, json &o,\n                                   std::vector<unsigned char> &binBuffer) {\n  SerializeNumberProperty(\"byteLength\", buffer.data.size(), o);\n  binBuffer = buffer.data;\n\n  if (buffer.name.size()) SerializeStringProperty(\"name\", buffer.name, o);\n\n  if (buffer.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", buffer.extras, o);\n  }\n}\n\nstatic void SerializeGltfBuffer(Buffer &buffer, json &o) {\n  SerializeNumberProperty(\"byteLength\", buffer.data.size(), o);\n  SerializeGltfBufferData(buffer.data, o);\n\n  if (buffer.name.size()) SerializeStringProperty(\"name\", buffer.name, o);\n\n  if (buffer.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", buffer.extras, o);\n  }\n}\n\nstatic bool SerializeGltfBuffer(Buffer &buffer, json &o,\n                                const std::string &binFilename,\n                                const std::string &binBaseFilename) {\n  if (!SerializeGltfBufferData(buffer.data, binFilename)) return false;\n  SerializeNumberProperty(\"byteLength\", buffer.data.size(), o);\n  SerializeStringProperty(\"uri\", binBaseFilename, o);\n\n  if (buffer.name.size()) SerializeStringProperty(\"name\", buffer.name, o);\n\n  if (buffer.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", buffer.extras, o);\n  }\n  return true;\n}\n\nstatic void SerializeGltfBufferView(BufferView &bufferView, json &o) {\n  SerializeNumberProperty(\"buffer\", bufferView.buffer, o);\n  SerializeNumberProperty<size_t>(\"byteLength\", bufferView.byteLength, o);\n\n  // byteStride is optional, minimum allowed is 4\n  if (bufferView.byteStride >= 4) {\n    SerializeNumberProperty<size_t>(\"byteStride\", bufferView.byteStride, o);\n  }\n  // byteOffset is optional, default is 0\n  if (bufferView.byteOffset > 0) {\n    SerializeNumberProperty<size_t>(\"byteOffset\", bufferView.byteOffset, o);\n  }\n  // Target is optional, check if it contains a valid value\n  if (bufferView.target == TINYGLTF_TARGET_ARRAY_BUFFER ||\n      bufferView.target == TINYGLTF_TARGET_ELEMENT_ARRAY_BUFFER) {\n    SerializeNumberProperty(\"target\", bufferView.target, o);\n  }\n  if (bufferView.name.size()) {\n    SerializeStringProperty(\"name\", bufferView.name, o);\n  }\n\n  if (bufferView.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", bufferView.extras, o);\n  }\n}\n\nstatic void SerializeGltfImage(Image &image, json &o) {\n  // if uri empty, the mimeType and bufferview should be set\n  if (image.uri.empty()) {\n    SerializeStringProperty(\"mimeType\", image.mimeType, o);\n    SerializeNumberProperty<int>(\"bufferView\", image.bufferView, o);\n  } else {\n    // TODO(syoyo): dlib::urilencode?\n    SerializeStringProperty(\"uri\", image.uri, o);\n  }\n\n  if (image.name.size()) {\n    SerializeStringProperty(\"name\", image.name, o);\n  }\n\n  if (image.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", image.extras, o);\n  }\n\n  SerializeExtensionMap(image.extensions, o);\n}\n\nstatic void SerializeGltfTextureInfo(TextureInfo &texinfo, json &o) {\n  SerializeNumberProperty(\"index\", texinfo.index, o);\n\n  if (texinfo.texCoord != 0) {\n    SerializeNumberProperty(\"texCoord\", texinfo.texCoord, o);\n  }\n\n  if (texinfo.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", texinfo.extras, o);\n  }\n\n  SerializeExtensionMap(texinfo.extensions, o);\n}\n\nstatic void SerializeGltfNormalTextureInfo(NormalTextureInfo &texinfo,\n                                           json &o) {\n  SerializeNumberProperty(\"index\", texinfo.index, o);\n\n  if (texinfo.texCoord != 0) {\n    SerializeNumberProperty(\"texCoord\", texinfo.texCoord, o);\n  }\n\n  if (!TINYGLTF_DOUBLE_EQUAL(texinfo.scale, 1.0)) {\n    SerializeNumberProperty(\"scale\", texinfo.scale, o);\n  }\n\n  if (texinfo.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", texinfo.extras, o);\n  }\n\n  SerializeExtensionMap(texinfo.extensions, o);\n}\n\nstatic void SerializeGltfOcclusionTextureInfo(OcclusionTextureInfo &texinfo,\n                                              json &o) {\n  SerializeNumberProperty(\"index\", texinfo.index, o);\n\n  if (texinfo.texCoord != 0) {\n    SerializeNumberProperty(\"texCoord\", texinfo.texCoord, o);\n  }\n\n  if (!TINYGLTF_DOUBLE_EQUAL(texinfo.strength, 1.0)) {\n    SerializeNumberProperty(\"strength\", texinfo.strength, o);\n  }\n\n  if (texinfo.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", texinfo.extras, o);\n  }\n\n  SerializeExtensionMap(texinfo.extensions, o);\n}\n\nstatic void SerializeGltfPbrMetallicRoughness(PbrMetallicRoughness &pbr,\n                                              json &o) {\n  std::vector<double> default_baseColorFactor = {1.0, 1.0, 1.0, 1.0};\n  if (!Equals(pbr.baseColorFactor, default_baseColorFactor)) {\n    SerializeNumberArrayProperty<double>(\"baseColorFactor\", pbr.baseColorFactor,\n                                         o);\n  }\n\n  if (!TINYGLTF_DOUBLE_EQUAL(pbr.metallicFactor, 1.0)) {\n    SerializeNumberProperty(\"metallicFactor\", pbr.metallicFactor, o);\n  }\n\n  if (!TINYGLTF_DOUBLE_EQUAL(pbr.roughnessFactor, 1.0)) {\n    SerializeNumberProperty(\"roughnessFactor\", pbr.roughnessFactor, o);\n  }\n\n  if (pbr.baseColorTexture.index > -1) {\n    json texinfo;\n    SerializeGltfTextureInfo(pbr.baseColorTexture, texinfo);\n    JsonAddMember(o, \"baseColorTexture\", std::move(texinfo));\n  }\n\n  if (pbr.metallicRoughnessTexture.index > -1) {\n    json texinfo;\n    SerializeGltfTextureInfo(pbr.metallicRoughnessTexture, texinfo);\n    JsonAddMember(o, \"metallicRoughnessTexture\", std::move(texinfo));\n  }\n\n  SerializeExtensionMap(pbr.extensions, o);\n\n  if (pbr.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", pbr.extras, o);\n  }\n}\n\nstatic void SerializeGltfMaterial(Material &material, json &o) {\n  if (material.name.size()) {\n    SerializeStringProperty(\"name\", material.name, o);\n  }\n\n  // QUESTION(syoyo): Write material parameters regardless of its default value?\n\n  if (!TINYGLTF_DOUBLE_EQUAL(material.alphaCutoff, 0.5)) {\n    SerializeNumberProperty(\"alphaCutoff\", material.alphaCutoff, o);\n  }\n\n  if (material.alphaMode.compare(\"OPAQUE\") != 0) {\n    SerializeStringProperty(\"alphaMode\", material.alphaMode, o);\n  }\n\n  if (material.doubleSided != false)\n    JsonAddMember(o, \"doubleSided\", json(material.doubleSided));\n\n  if (material.normalTexture.index > -1) {\n    json texinfo;\n    SerializeGltfNormalTextureInfo(material.normalTexture, texinfo);\n    JsonAddMember(o, \"normalTexture\", std::move(texinfo));\n  }\n\n  if (material.occlusionTexture.index > -1) {\n    json texinfo;\n    SerializeGltfOcclusionTextureInfo(material.occlusionTexture, texinfo);\n    JsonAddMember(o, \"occlusionTexture\", std::move(texinfo));\n  }\n\n  if (material.emissiveTexture.index > -1) {\n    json texinfo;\n    SerializeGltfTextureInfo(material.emissiveTexture, texinfo);\n    JsonAddMember(o, \"emissiveTexture\", std::move(texinfo));\n  }\n\n  std::vector<double> default_emissiveFactor = {0.0, 0.0, 0.0};\n  if (!Equals(material.emissiveFactor, default_emissiveFactor)) {\n    SerializeNumberArrayProperty<double>(\"emissiveFactor\",\n                                         material.emissiveFactor, o);\n  }\n\n  {\n    json pbrMetallicRoughness;\n    SerializeGltfPbrMetallicRoughness(material.pbrMetallicRoughness,\n                                      pbrMetallicRoughness);\n    // Issue 204\n    // Do not serialize `pbrMetallicRoughness` if pbrMetallicRoughness has all\n    // default values(json is null). Otherwise it will serialize to\n    // `pbrMetallicRoughness : null`, which cannot be read by other glTF\n    // importers(and validators).\n    //\n    if (!JsonIsNull(pbrMetallicRoughness)) {\n      JsonAddMember(o, \"pbrMetallicRoughness\", std::move(pbrMetallicRoughness));\n    }\n  }\n\n#if 0  // legacy way. just for the record.\n  if (material.values.size()) {\n    json pbrMetallicRoughness;\n    SerializeParameterMap(material.values, pbrMetallicRoughness);\n    JsonAddMember(o, \"pbrMetallicRoughness\", std::move(pbrMetallicRoughness));\n  }\n\n  SerializeParameterMap(material.additionalValues, o);\n#else\n\n#endif\n\n  SerializeExtensionMap(material.extensions, o);\n\n  if (material.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", material.extras, o);\n  }\n}\n\nstatic void SerializeGltfMesh(Mesh &mesh, json &o) {\n  json primitives;\n  JsonReserveArray(primitives, mesh.primitives.size());\n  for (unsigned int i = 0; i < mesh.primitives.size(); ++i) {\n    json primitive;\n    const Primitive &gltfPrimitive = mesh.primitives[i];  // don't make a copy\n    {\n      json attributes;\n      for (auto attrIt = gltfPrimitive.attributes.begin();\n           attrIt != gltfPrimitive.attributes.end(); ++attrIt) {\n        SerializeNumberProperty<int>(attrIt->first, attrIt->second, attributes);\n      }\n\n      JsonAddMember(primitive, \"attributes\", std::move(attributes));\n    }\n\n    // Indicies is optional\n    if (gltfPrimitive.indices > -1) {\n      SerializeNumberProperty<int>(\"indices\", gltfPrimitive.indices, primitive);\n    }\n    // Material is optional\n    if (gltfPrimitive.material > -1) {\n      SerializeNumberProperty<int>(\"material\", gltfPrimitive.material,\n                                   primitive);\n    }\n    SerializeNumberProperty<int>(\"mode\", gltfPrimitive.mode, primitive);\n\n    // Morph targets\n    if (gltfPrimitive.targets.size()) {\n      json targets;\n      JsonReserveArray(targets, gltfPrimitive.targets.size());\n      for (unsigned int k = 0; k < gltfPrimitive.targets.size(); ++k) {\n        json targetAttributes;\n        std::map<std::string, int> targetData = gltfPrimitive.targets[k];\n        for (std::map<std::string, int>::iterator attrIt = targetData.begin();\n             attrIt != targetData.end(); ++attrIt) {\n          SerializeNumberProperty<int>(attrIt->first, attrIt->second,\n                                       targetAttributes);\n        }\n        JsonPushBack(targets, std::move(targetAttributes));\n      }\n      JsonAddMember(primitive, \"targets\", std::move(targets));\n    }\n\n    SerializeExtensionMap(gltfPrimitive.extensions, primitive);\n\n    if (gltfPrimitive.extras.Type() != NULL_TYPE) {\n      SerializeValue(\"extras\", gltfPrimitive.extras, primitive);\n    }\n\n    JsonPushBack(primitives, std::move(primitive));\n  }\n\n  JsonAddMember(o, \"primitives\", std::move(primitives));\n\n  if (mesh.weights.size()) {\n    SerializeNumberArrayProperty<double>(\"weights\", mesh.weights, o);\n  }\n\n  if (mesh.name.size()) {\n    SerializeStringProperty(\"name\", mesh.name, o);\n  }\n\n  SerializeExtensionMap(mesh.extensions, o);\n  if (mesh.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", mesh.extras, o);\n  }\n}\n\nstatic void SerializeSpotLight(SpotLight &spot, json &o) {\n  SerializeNumberProperty(\"innerConeAngle\", spot.innerConeAngle, o);\n  SerializeNumberProperty(\"outerConeAngle\", spot.outerConeAngle, o);\n  SerializeExtensionMap(spot.extensions, o);\n  if (spot.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", spot.extras, o);\n  }\n}\n\nstatic void SerializeGltfLight(Light &light, json &o) {\n  if (!light.name.empty()) SerializeStringProperty(\"name\", light.name, o);\n  SerializeNumberProperty(\"intensity\", light.intensity, o);\n  if (light.range > 0.0) {\n    SerializeNumberProperty(\"range\", light.range, o);\n  }\n  SerializeNumberArrayProperty(\"color\", light.color, o);\n  SerializeStringProperty(\"type\", light.type, o);\n  if (light.type == \"spot\") {\n    json spot;\n    SerializeSpotLight(light.spot, spot);\n    JsonAddMember(o, \"spot\", std::move(spot));\n  }\n  SerializeExtensionMap(light.extensions, o);\n  if (light.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", light.extras, o);\n  }\n}\n\nstatic void SerializeGltfNode(Node &node, json &o) {\n  if (node.translation.size() > 0) {\n    SerializeNumberArrayProperty<double>(\"translation\", node.translation, o);\n  }\n  if (node.rotation.size() > 0) {\n    SerializeNumberArrayProperty<double>(\"rotation\", node.rotation, o);\n  }\n  if (node.scale.size() > 0) {\n    SerializeNumberArrayProperty<double>(\"scale\", node.scale, o);\n  }\n  if (node.matrix.size() > 0) {\n    SerializeNumberArrayProperty<double>(\"matrix\", node.matrix, o);\n  }\n  if (node.mesh != -1) {\n    SerializeNumberProperty<int>(\"mesh\", node.mesh, o);\n  }\n\n  if (node.skin != -1) {\n    SerializeNumberProperty<int>(\"skin\", node.skin, o);\n  }\n\n  if (node.camera != -1) {\n    SerializeNumberProperty<int>(\"camera\", node.camera, o);\n  }\n\n  if (node.weights.size() > 0) {\n    SerializeNumberArrayProperty<double>(\"weights\", node.weights, o);\n  }\n\n  if (node.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", node.extras, o);\n  }\n\n  SerializeExtensionMap(node.extensions, o);\n  if (!node.name.empty()) SerializeStringProperty(\"name\", node.name, o);\n  SerializeNumberArrayProperty<int>(\"children\", node.children, o);\n}\n\nstatic void SerializeGltfSampler(Sampler &sampler, json &o) {\n  if (sampler.magFilter != -1) {\n    SerializeNumberProperty(\"magFilter\", sampler.magFilter, o);\n  }\n  if (sampler.minFilter != -1) {\n    SerializeNumberProperty(\"minFilter\", sampler.minFilter, o);\n  }\n  //SerializeNumberProperty(\"wrapR\", sampler.wrapR, o);\n  SerializeNumberProperty(\"wrapS\", sampler.wrapS, o);\n  SerializeNumberProperty(\"wrapT\", sampler.wrapT, o);\n\n  if (sampler.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", sampler.extras, o);\n  }\n}\n\nstatic void SerializeGltfOrthographicCamera(const OrthographicCamera &camera,\n                                            json &o) {\n  SerializeNumberProperty(\"zfar\", camera.zfar, o);\n  SerializeNumberProperty(\"znear\", camera.znear, o);\n  SerializeNumberProperty(\"xmag\", camera.xmag, o);\n  SerializeNumberProperty(\"ymag\", camera.ymag, o);\n\n  if (camera.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", camera.extras, o);\n  }\n}\n\nstatic void SerializeGltfPerspectiveCamera(const PerspectiveCamera &camera,\n                                           json &o) {\n  SerializeNumberProperty(\"zfar\", camera.zfar, o);\n  SerializeNumberProperty(\"znear\", camera.znear, o);\n  if (camera.aspectRatio > 0) {\n    SerializeNumberProperty(\"aspectRatio\", camera.aspectRatio, o);\n  }\n\n  if (camera.yfov > 0) {\n    SerializeNumberProperty(\"yfov\", camera.yfov, o);\n  }\n\n  if (camera.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", camera.extras, o);\n  }\n}\n\nstatic void SerializeGltfCamera(const Camera &camera, json &o) {\n  SerializeStringProperty(\"type\", camera.type, o);\n  if (!camera.name.empty()) {\n    SerializeStringProperty(\"name\", camera.name, o);\n  }\n\n  if (camera.type.compare(\"orthographic\") == 0) {\n    json orthographic;\n    SerializeGltfOrthographicCamera(camera.orthographic, orthographic);\n    JsonAddMember(o, \"orthographic\", std::move(orthographic));\n  } else if (camera.type.compare(\"perspective\") == 0) {\n    json perspective;\n    SerializeGltfPerspectiveCamera(camera.perspective, perspective);\n    JsonAddMember(o, \"perspective\", std::move(perspective));\n  } else {\n    // ???\n  }\n\n  if (camera.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", camera.extras, o);\n  }\n  SerializeExtensionMap(camera.extensions, o);\n}\n\nstatic void SerializeGltfScene(Scene &scene, json &o) {\n  SerializeNumberArrayProperty<int>(\"nodes\", scene.nodes, o);\n\n  if (scene.name.size()) {\n    SerializeStringProperty(\"name\", scene.name, o);\n  }\n  if (scene.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", scene.extras, o);\n  }\n  SerializeExtensionMap(scene.extensions, o);\n}\n\nstatic void SerializeGltfSkin(Skin &skin, json &o) {\n  // required\n  SerializeNumberArrayProperty<int>(\"joints\", skin.joints, o);\n\n  if (skin.inverseBindMatrices >= 0) {\n    SerializeNumberProperty(\"inverseBindMatrices\", skin.inverseBindMatrices, o);\n  }\n\n  if (skin.skeleton >= 0) {\n    SerializeNumberProperty(\"skeleton\", skin.skeleton, o);\n  }\n\n  if (skin.name.size()) {\n    SerializeStringProperty(\"name\", skin.name, o);\n  }\n}\n\nstatic void SerializeGltfTexture(Texture &texture, json &o) {\n  if (texture.sampler > -1) {\n    SerializeNumberProperty(\"sampler\", texture.sampler, o);\n  }\n  if (texture.source > -1) {\n    SerializeNumberProperty(\"source\", texture.source, o);\n  }\n  if (texture.name.size()) {\n    SerializeStringProperty(\"name\", texture.name, o);\n  }\n  if (texture.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", texture.extras, o);\n  }\n  SerializeExtensionMap(texture.extensions, o);\n}\n\n///\n/// Serialize all properties except buffers and images.\n///\nstatic void SerializeGltfModel(Model *model, json &o) {\n  // ACCESSORS\n  if (model->accessors.size()) {\n    json accessors;\n    JsonReserveArray(accessors, model->accessors.size());\n    for (unsigned int i = 0; i < model->accessors.size(); ++i) {\n      json accessor;\n      SerializeGltfAccessor(model->accessors[i], accessor);\n      JsonPushBack(accessors, std::move(accessor));\n    }\n    JsonAddMember(o, \"accessors\", std::move(accessors));\n  }\n\n  // ANIMATIONS\n  if (model->animations.size()) {\n    json animations;\n    JsonReserveArray(animations, model->animations.size());\n    for (unsigned int i = 0; i < model->animations.size(); ++i) {\n      if (model->animations[i].channels.size()) {\n        json animation;\n        SerializeGltfAnimation(model->animations[i], animation);\n        JsonPushBack(animations, std::move(animation));\n      }\n    }\n\n    JsonAddMember(o, \"animations\", std::move(animations));\n  }\n\n  // ASSET\n  json asset;\n  SerializeGltfAsset(model->asset, asset);\n  JsonAddMember(o, \"asset\", std::move(asset));\n\n  // BUFFERVIEWS\n  if (model->bufferViews.size()) {\n    json bufferViews;\n    JsonReserveArray(bufferViews, model->bufferViews.size());\n    for (unsigned int i = 0; i < model->bufferViews.size(); ++i) {\n      json bufferView;\n      SerializeGltfBufferView(model->bufferViews[i], bufferView);\n      JsonPushBack(bufferViews, std::move(bufferView));\n    }\n    JsonAddMember(o, \"bufferViews\", std::move(bufferViews));\n  }\n\n  // Extensions required\n  if (model->extensionsRequired.size()) {\n    SerializeStringArrayProperty(\"extensionsRequired\",\n                                 model->extensionsRequired, o);\n  }\n\n  // MATERIALS\n  if (model->materials.size()) {\n    json materials;\n    JsonReserveArray(materials, model->materials.size());\n    for (unsigned int i = 0; i < model->materials.size(); ++i) {\n      json material;\n      SerializeGltfMaterial(model->materials[i], material);\n\n      if (JsonIsNull(material)) {\n        // Issue 294.\n        // `material` does not have any required parameters\n        // so the result may be null(unmodified) when all material parameters\n        // have default value.\n        //\n        // null is not allowed thus we create an empty JSON object.\n        JsonSetObject(material);\n      }\n      JsonPushBack(materials, std::move(material));\n    }\n    JsonAddMember(o, \"materials\", std::move(materials));\n  }\n\n  // MESHES\n  if (model->meshes.size()) {\n    json meshes;\n    JsonReserveArray(meshes, model->meshes.size());\n    for (unsigned int i = 0; i < model->meshes.size(); ++i) {\n      json mesh;\n      SerializeGltfMesh(model->meshes[i], mesh);\n      JsonPushBack(meshes, std::move(mesh));\n    }\n    JsonAddMember(o, \"meshes\", std::move(meshes));\n  }\n\n  // NODES\n  if (model->nodes.size()) {\n    json nodes;\n    JsonReserveArray(nodes, model->nodes.size());\n    for (unsigned int i = 0; i < model->nodes.size(); ++i) {\n      json node;\n      SerializeGltfNode(model->nodes[i], node);\n      JsonPushBack(nodes, std::move(node));\n    }\n    JsonAddMember(o, \"nodes\", std::move(nodes));\n  }\n\n  // SCENE\n  if (model->defaultScene > -1) {\n    SerializeNumberProperty<int>(\"scene\", model->defaultScene, o);\n  }\n\n  // SCENES\n  if (model->scenes.size()) {\n    json scenes;\n    JsonReserveArray(scenes, model->scenes.size());\n    for (unsigned int i = 0; i < model->scenes.size(); ++i) {\n      json currentScene;\n      SerializeGltfScene(model->scenes[i], currentScene);\n      JsonPushBack(scenes, std::move(currentScene));\n    }\n    JsonAddMember(o, \"scenes\", std::move(scenes));\n  }\n\n  // SKINS\n  if (model->skins.size()) {\n    json skins;\n    JsonReserveArray(skins, model->skins.size());\n    for (unsigned int i = 0; i < model->skins.size(); ++i) {\n      json skin;\n      SerializeGltfSkin(model->skins[i], skin);\n      JsonPushBack(skins, std::move(skin));\n    }\n    JsonAddMember(o, \"skins\", std::move(skins));\n  }\n\n  // TEXTURES\n  if (model->textures.size()) {\n    json textures;\n    JsonReserveArray(textures, model->textures.size());\n    for (unsigned int i = 0; i < model->textures.size(); ++i) {\n      json texture;\n      SerializeGltfTexture(model->textures[i], texture);\n      JsonPushBack(textures, std::move(texture));\n    }\n    JsonAddMember(o, \"textures\", std::move(textures));\n  }\n\n  // SAMPLERS\n  if (model->samplers.size()) {\n    json samplers;\n    JsonReserveArray(samplers, model->samplers.size());\n    for (unsigned int i = 0; i < model->samplers.size(); ++i) {\n      json sampler;\n      SerializeGltfSampler(model->samplers[i], sampler);\n      JsonPushBack(samplers, std::move(sampler));\n    }\n    JsonAddMember(o, \"samplers\", std::move(samplers));\n  }\n\n  // CAMERAS\n  if (model->cameras.size()) {\n    json cameras;\n    JsonReserveArray(cameras, model->cameras.size());\n    for (unsigned int i = 0; i < model->cameras.size(); ++i) {\n      json camera;\n      SerializeGltfCamera(model->cameras[i], camera);\n      JsonPushBack(cameras, std::move(camera));\n    }\n    JsonAddMember(o, \"cameras\", std::move(cameras));\n  }\n\n  // EXTENSIONS\n  SerializeExtensionMap(model->extensions, o);\n\n  auto extensionsUsed = model->extensionsUsed;\n\n  // LIGHTS as KHR_lights_punctual\n  if (model->lights.size()) {\n    json lights;\n    JsonReserveArray(lights, model->lights.size());\n    for (unsigned int i = 0; i < model->lights.size(); ++i) {\n      json light;\n      SerializeGltfLight(model->lights[i], light);\n      JsonPushBack(lights, std::move(light));\n    }\n    json khr_lights_cmn;\n    JsonAddMember(khr_lights_cmn, \"lights\", std::move(lights));\n    json ext_j;\n\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        JsonAssign(ext_j, GetValue(it));\n      }\n    }\n\n    JsonAddMember(ext_j, \"KHR_lights_punctual\", std::move(khr_lights_cmn));\n\n    JsonAddMember(o, \"extensions\", std::move(ext_j));\n\n    // Also add \"KHR_lights_punctual\" to `extensionsUsed`\n    {\n      auto has_khr_lights_punctual =\n          std::find_if(extensionsUsed.begin(), extensionsUsed.end(),\n                       [](const std::string &s) {\n                         return (s.compare(\"KHR_lights_punctual\") == 0);\n                       });\n\n      if (has_khr_lights_punctual == extensionsUsed.end()) {\n        extensionsUsed.push_back(\"KHR_lights_punctual\");\n      }\n    }\n  }\n\n  // Extensions used\n  if (extensionsUsed.size()) {\n    SerializeStringArrayProperty(\"extensionsUsed\", extensionsUsed, o);\n  }\n\n  // EXTRAS\n  if (model->extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", model->extras, o);\n  }\n}\n\nstatic bool WriteGltfStream(std::ostream &stream, const std::string &content) {\n  stream << content << std::endl;\n  return true;\n}\n\nstatic bool WriteGltfFile(const std::string &output,\n                          const std::string &content) {\n#ifdef _WIN32\n#if defined(_MSC_VER)\n  std::ofstream gltfFile(UTF8ToWchar(output).c_str());\n#elif defined(__GLIBCXX__)\n  int file_descriptor = _wopen(UTF8ToWchar(output).c_str(),\n                               _O_CREAT | _O_WRONLY | _O_TRUNC | _O_BINARY);\n  __gnu_cxx::stdio_filebuf<char> wfile_buf(\n      file_descriptor, std::ios_base::out | std::ios_base::binary);\n  std::ostream gltfFile(&wfile_buf);\n  if (!wfile_buf.is_open()) return false;\n#else\n  std::ofstream gltfFile(output.c_str());\n  if (!gltfFile.is_open()) return false;\n#endif\n#else\n  std::ofstream gltfFile(output.c_str());\n  if (!gltfFile.is_open()) return false;\n#endif\n  return WriteGltfStream(gltfFile, content);\n}\n\nstatic void WriteBinaryGltfStream(std::ostream &stream,\n                                  const std::string &content,\n                                  const std::vector<unsigned char> &binBuffer) {\n  const std::string header = \"glTF\";\n  const int version = 2;\n\n  const uint32_t content_size = uint32_t(content.size());\n  const uint32_t binBuffer_size = uint32_t(binBuffer.size());\n  // determine number of padding bytes required to ensure 4 byte alignment\n  const uint32_t content_padding_size = content_size % 4 == 0 ? 0 : 4 - content_size % 4;\n  const uint32_t bin_padding_size = binBuffer_size % 4 == 0 ? 0 : 4 - binBuffer_size % 4;\n\n  // 12 bytes for header, JSON content length, 8 bytes for JSON chunk info.\n  // Chunk data must be located at 4-byte boundary, which may require padding\n  const uint32_t length =\n      12 + 8 + content_size + content_padding_size +\n      (binBuffer_size ? (8 + binBuffer_size + bin_padding_size) : 0);\n\n  stream.write(header.c_str(), std::streamsize(header.size()));\n  stream.write(reinterpret_cast<const char *>(&version), sizeof(version));\n  stream.write(reinterpret_cast<const char *>(&length), sizeof(length));\n\n  // JSON chunk info, then JSON data\n  const uint32_t model_length = uint32_t(content.size()) + content_padding_size;\n  const uint32_t model_format = 0x4E4F534A;\n  stream.write(reinterpret_cast<const char *>(&model_length),\n               sizeof(model_length));\n  stream.write(reinterpret_cast<const char *>(&model_format),\n               sizeof(model_format));\n  stream.write(content.c_str(), std::streamsize(content.size()));\n\n  // Chunk must be multiplies of 4, so pad with spaces\n  if (content_padding_size > 0) {\n    const std::string padding = std::string(size_t(content_padding_size), ' ');\n    stream.write(padding.c_str(), std::streamsize(padding.size()));\n  }\n  if (binBuffer.size() > 0) {\n    // BIN chunk info, then BIN data\n    const uint32_t bin_length = uint32_t(binBuffer.size()) + bin_padding_size;\n    const uint32_t bin_format = 0x004e4942;\n    stream.write(reinterpret_cast<const char *>(&bin_length),\n                 sizeof(bin_length));\n    stream.write(reinterpret_cast<const char *>(&bin_format),\n                 sizeof(bin_format));\n    stream.write(reinterpret_cast<const char *>(binBuffer.data()),\n                 std::streamsize(binBuffer.size()));\n    // Chunksize must be multiplies of 4, so pad with zeroes\n    if (bin_padding_size > 0) {\n      const std::vector<unsigned char> padding =\n          std::vector<unsigned char>(size_t(bin_padding_size), 0);\n      stream.write(reinterpret_cast<const char *>(padding.data()),\n                   std::streamsize(padding.size()));\n    }\n  }\n}\n\nstatic void WriteBinaryGltfFile(const std::string &output,\n                                const std::string &content,\n                                const std::vector<unsigned char> &binBuffer) {\n#ifdef _WIN32\n#if defined(_MSC_VER)\n  std::ofstream gltfFile(UTF8ToWchar(output).c_str(), std::ios::binary);\n#elif defined(__GLIBCXX__)\n  int file_descriptor = _wopen(UTF8ToWchar(output).c_str(),\n                               _O_CREAT | _O_WRONLY | _O_TRUNC | _O_BINARY);\n  __gnu_cxx::stdio_filebuf<char> wfile_buf(\n      file_descriptor, std::ios_base::out | std::ios_base::binary);\n  std::ostream gltfFile(&wfile_buf);\n#else\n  std::ofstream gltfFile(output.c_str(), std::ios::binary);\n#endif\n#else\n  std::ofstream gltfFile(output.c_str(), std::ios::binary);\n#endif\n  WriteBinaryGltfStream(gltfFile, content, binBuffer);\n}\n\nbool TinyGLTF::WriteGltfSceneToStream(Model *model, std::ostream &stream,\n                                      bool prettyPrint = true,\n                                      bool writeBinary = false) {\n  JsonDocument output;\n\n  /// Serialize all properties except buffers and images.\n  SerializeGltfModel(model, output);\n\n  // BUFFERS\n  std::vector<unsigned char> binBuffer;\n  if (model->buffers.size()) {\n    json buffers;\n    JsonReserveArray(buffers, model->buffers.size());\n    for (unsigned int i = 0; i < model->buffers.size(); ++i) {\n      json buffer;\n      if (writeBinary && i == 0 && model->buffers[i].uri.empty()) {\n        SerializeGltfBufferBin(model->buffers[i], buffer, binBuffer);\n      } else {\n        SerializeGltfBuffer(model->buffers[i], buffer);\n      }\n      JsonPushBack(buffers, std::move(buffer));\n    }\n    JsonAddMember(output, \"buffers\", std::move(buffers));\n  }\n\n  // IMAGES\n  if (model->images.size()) {\n    json images;\n    JsonReserveArray(images, model->images.size());\n    for (unsigned int i = 0; i < model->images.size(); ++i) {\n      json image;\n\n      std::string dummystring = \"\";\n      // UpdateImageObject need baseDir but only uses it if embeddedImages is\n      // enabled, since we won't write separate images when writing to a stream\n      // we\n      UpdateImageObject(model->images[i], dummystring, int(i), true,\n                        &this->WriteImageData, this->write_image_user_data_);\n      SerializeGltfImage(model->images[i], image);\n      JsonPushBack(images, std::move(image));\n    }\n    JsonAddMember(output, \"images\", std::move(images));\n  }\n\n  if (writeBinary) {\n    WriteBinaryGltfStream(stream, JsonToString(output), binBuffer);\n  } else {\n    WriteGltfStream(stream, JsonToString(output, prettyPrint ? 2 : -1));\n  }\n\n  return true;\n}\n\nbool TinyGLTF::WriteGltfSceneToFile(Model *model, const std::string &filename,\n                                    bool embedImages = false,\n                                    bool embedBuffers = false,\n                                    bool prettyPrint = true,\n                                    bool writeBinary = false) {\n  JsonDocument output;\n  std::string defaultBinFilename = GetBaseFilename(filename);\n  std::string defaultBinFileExt = \".bin\";\n  std::string::size_type pos =\n      defaultBinFilename.rfind('.', defaultBinFilename.length());\n\n  if (pos != std::string::npos) {\n    defaultBinFilename = defaultBinFilename.substr(0, pos);\n  }\n  std::string baseDir = GetBaseDir(filename);\n  if (baseDir.empty()) {\n    baseDir = \"./\";\n  }\n  /// Serialize all properties except buffers and images.\n  SerializeGltfModel(model, output);\n\n  // BUFFERS\n  std::vector<std::string> usedUris;\n  std::vector<unsigned char> binBuffer;\n  if (model->buffers.size()) {\n    json buffers;\n    JsonReserveArray(buffers, model->buffers.size());\n    for (unsigned int i = 0; i < model->buffers.size(); ++i) {\n      json buffer;\n      if (writeBinary && i == 0 && model->buffers[i].uri.empty()) {\n        SerializeGltfBufferBin(model->buffers[i], buffer, binBuffer);\n      } else if (embedBuffers) {\n        SerializeGltfBuffer(model->buffers[i], buffer);\n      } else {\n        std::string binSavePath;\n        std::string binUri;\n        if (!model->buffers[i].uri.empty() &&\n            !IsDataURI(model->buffers[i].uri)) {\n          binUri = model->buffers[i].uri;\n        } else {\n          binUri = defaultBinFilename + defaultBinFileExt;\n          bool inUse = true;\n          int numUsed = 0;\n          while (inUse) {\n            inUse = false;\n            for (const std::string &usedName : usedUris) {\n              if (binUri.compare(usedName) != 0) continue;\n              inUse = true;\n              binUri = defaultBinFilename + std::to_string(numUsed++) +\n                       defaultBinFileExt;\n              break;\n            }\n          }\n        }\n        usedUris.push_back(binUri);\n        binSavePath = JoinPath(baseDir, binUri);\n        if (!SerializeGltfBuffer(model->buffers[i], buffer, binSavePath,\n                                 binUri)) {\n          return false;\n        }\n      }\n      JsonPushBack(buffers, std::move(buffer));\n    }\n    JsonAddMember(output, \"buffers\", std::move(buffers));\n  }\n\n  // IMAGES\n  if (model->images.size()) {\n    json images;\n    JsonReserveArray(images, model->images.size());\n    for (unsigned int i = 0; i < model->images.size(); ++i) {\n      json image;\n\n      UpdateImageObject(model->images[i], baseDir, int(i), embedImages,\n                        &this->WriteImageData, this->write_image_user_data_);\n      SerializeGltfImage(model->images[i], image);\n      JsonPushBack(images, std::move(image));\n    }\n    JsonAddMember(output, \"images\", std::move(images));\n  }\n\n  if (writeBinary) {\n    WriteBinaryGltfFile(filename, JsonToString(output), binBuffer);\n  } else {\n    WriteGltfFile(filename, JsonToString(output, (prettyPrint ? 2 : -1)));\n  }\n\n  return true;\n}\n\n}  // namespace tinygltf\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n#endif  // TINYGLTF_IMPLEMENTATION\n"], "fixing_code": ["//\n// Header-only tiny glTF 2.0 loader and serializer.\n//\n//\n// The MIT License (MIT)\n//\n// Copyright (c) 2015 - Present Syoyo Fujita, Aur\u00e9lien Chatelain and many\n// contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\n// Version:\n//  - v2.6.0 Disable expanding file path for security(no use of awkward `wordexp` anymore).\n//  - v2.5.0 Add SetPreserveImageChannels() option to load image data as is.\n//  - v2.4.3 Fix null object output when when material has all default\n//  parameters.\n//  - v2.4.2 Decode percent-encoded URI.\n//  - v2.4.1 Fix some glTF object class does not have `extensions` and/or\n//  `extras` property.\n//  - v2.4.0 Experimental RapidJSON and C++14 support(Thanks to @jrkoone).\n//  - v2.3.1 Set default value of minFilter and magFilter in Sampler to -1.\n//  - v2.3.0 Modified Material representation according to glTF 2.0 schema\n//           (and introduced TextureInfo class)\n//           Change the behavior of `Value::IsNumber`. It return true either the\n//           value is int or real.\n//  - v2.2.0 Add loading 16bit PNG support. Add Sparse accessor support(Thanks\n//  to @Ybalrid)\n//  - v2.1.0 Add draco compression.\n//  - v2.0.1 Add comparsion feature(Thanks to @Selmar).\n//  - v2.0.0 glTF 2.0!.\n//\n// Tiny glTF loader is using following third party libraries:\n//\n//  - jsonhpp: C++ JSON library.\n//  - base64: base64 decode/encode library.\n//  - stb_image: Image loading library.\n//\n#ifndef TINY_GLTF_H_\n#define TINY_GLTF_H_\n\n#include <array>\n#include <cassert>\n#include <cmath>  // std::fabs\n#include <cstdint>\n#include <cstdlib>\n#include <cstring>\n#include <limits>\n#include <map>\n#include <string>\n#include <vector>\n\n#ifndef TINYGLTF_USE_CPP14\n#include <functional>\n#endif\n\n#ifdef __ANDROID__\n#ifdef TINYGLTF_ANDROID_LOAD_FROM_ASSETS\n#include <android/asset_manager.h>\n#endif\n#endif\n\n#ifdef __GNUC__\n#if (__GNUC__ < 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ <= 8))\n#define TINYGLTF_NOEXCEPT\n#else\n#define TINYGLTF_NOEXCEPT noexcept\n#endif\n#else\n#define TINYGLTF_NOEXCEPT noexcept\n#endif\n\n#define DEFAULT_METHODS(x)             \\\n  ~x() = default;                      \\\n  x(const x &) = default;              \\\n  x(x &&) TINYGLTF_NOEXCEPT = default; \\\n  x &operator=(const x &) = default;   \\\n  x &operator=(x &&) TINYGLTF_NOEXCEPT = default;\n\nnamespace tinygltf {\n\n#define TINYGLTF_MODE_POINTS (0)\n#define TINYGLTF_MODE_LINE (1)\n#define TINYGLTF_MODE_LINE_LOOP (2)\n#define TINYGLTF_MODE_LINE_STRIP (3)\n#define TINYGLTF_MODE_TRIANGLES (4)\n#define TINYGLTF_MODE_TRIANGLE_STRIP (5)\n#define TINYGLTF_MODE_TRIANGLE_FAN (6)\n\n#define TINYGLTF_COMPONENT_TYPE_BYTE (5120)\n#define TINYGLTF_COMPONENT_TYPE_UNSIGNED_BYTE (5121)\n#define TINYGLTF_COMPONENT_TYPE_SHORT (5122)\n#define TINYGLTF_COMPONENT_TYPE_UNSIGNED_SHORT (5123)\n#define TINYGLTF_COMPONENT_TYPE_INT (5124)\n#define TINYGLTF_COMPONENT_TYPE_UNSIGNED_INT (5125)\n#define TINYGLTF_COMPONENT_TYPE_FLOAT (5126)\n#define TINYGLTF_COMPONENT_TYPE_DOUBLE \\\n  (5130)  // OpenGL double type. Note that some of glTF 2.0 validator does not\n          // support double type even the schema seems allow any value of\n          // integer:\n          // https://github.com/KhronosGroup/glTF/blob/b9884a2fd45130b4d673dd6c8a706ee21ee5c5f7/specification/2.0/schema/accessor.schema.json#L22\n\n#define TINYGLTF_TEXTURE_FILTER_NEAREST (9728)\n#define TINYGLTF_TEXTURE_FILTER_LINEAR (9729)\n#define TINYGLTF_TEXTURE_FILTER_NEAREST_MIPMAP_NEAREST (9984)\n#define TINYGLTF_TEXTURE_FILTER_LINEAR_MIPMAP_NEAREST (9985)\n#define TINYGLTF_TEXTURE_FILTER_NEAREST_MIPMAP_LINEAR (9986)\n#define TINYGLTF_TEXTURE_FILTER_LINEAR_MIPMAP_LINEAR (9987)\n\n#define TINYGLTF_TEXTURE_WRAP_REPEAT (10497)\n#define TINYGLTF_TEXTURE_WRAP_CLAMP_TO_EDGE (33071)\n#define TINYGLTF_TEXTURE_WRAP_MIRRORED_REPEAT (33648)\n\n// Redeclarations of the above for technique.parameters.\n#define TINYGLTF_PARAMETER_TYPE_BYTE (5120)\n#define TINYGLTF_PARAMETER_TYPE_UNSIGNED_BYTE (5121)\n#define TINYGLTF_PARAMETER_TYPE_SHORT (5122)\n#define TINYGLTF_PARAMETER_TYPE_UNSIGNED_SHORT (5123)\n#define TINYGLTF_PARAMETER_TYPE_INT (5124)\n#define TINYGLTF_PARAMETER_TYPE_UNSIGNED_INT (5125)\n#define TINYGLTF_PARAMETER_TYPE_FLOAT (5126)\n\n#define TINYGLTF_PARAMETER_TYPE_FLOAT_VEC2 (35664)\n#define TINYGLTF_PARAMETER_TYPE_FLOAT_VEC3 (35665)\n#define TINYGLTF_PARAMETER_TYPE_FLOAT_VEC4 (35666)\n\n#define TINYGLTF_PARAMETER_TYPE_INT_VEC2 (35667)\n#define TINYGLTF_PARAMETER_TYPE_INT_VEC3 (35668)\n#define TINYGLTF_PARAMETER_TYPE_INT_VEC4 (35669)\n\n#define TINYGLTF_PARAMETER_TYPE_BOOL (35670)\n#define TINYGLTF_PARAMETER_TYPE_BOOL_VEC2 (35671)\n#define TINYGLTF_PARAMETER_TYPE_BOOL_VEC3 (35672)\n#define TINYGLTF_PARAMETER_TYPE_BOOL_VEC4 (35673)\n\n#define TINYGLTF_PARAMETER_TYPE_FLOAT_MAT2 (35674)\n#define TINYGLTF_PARAMETER_TYPE_FLOAT_MAT3 (35675)\n#define TINYGLTF_PARAMETER_TYPE_FLOAT_MAT4 (35676)\n\n#define TINYGLTF_PARAMETER_TYPE_SAMPLER_2D (35678)\n\n// End parameter types\n\n#define TINYGLTF_TYPE_VEC2 (2)\n#define TINYGLTF_TYPE_VEC3 (3)\n#define TINYGLTF_TYPE_VEC4 (4)\n#define TINYGLTF_TYPE_MAT2 (32 + 2)\n#define TINYGLTF_TYPE_MAT3 (32 + 3)\n#define TINYGLTF_TYPE_MAT4 (32 + 4)\n#define TINYGLTF_TYPE_SCALAR (64 + 1)\n#define TINYGLTF_TYPE_VECTOR (64 + 4)\n#define TINYGLTF_TYPE_MATRIX (64 + 16)\n\n#define TINYGLTF_IMAGE_FORMAT_JPEG (0)\n#define TINYGLTF_IMAGE_FORMAT_PNG (1)\n#define TINYGLTF_IMAGE_FORMAT_BMP (2)\n#define TINYGLTF_IMAGE_FORMAT_GIF (3)\n\n#define TINYGLTF_TEXTURE_FORMAT_ALPHA (6406)\n#define TINYGLTF_TEXTURE_FORMAT_RGB (6407)\n#define TINYGLTF_TEXTURE_FORMAT_RGBA (6408)\n#define TINYGLTF_TEXTURE_FORMAT_LUMINANCE (6409)\n#define TINYGLTF_TEXTURE_FORMAT_LUMINANCE_ALPHA (6410)\n\n#define TINYGLTF_TEXTURE_TARGET_TEXTURE2D (3553)\n#define TINYGLTF_TEXTURE_TYPE_UNSIGNED_BYTE (5121)\n\n#define TINYGLTF_TARGET_ARRAY_BUFFER (34962)\n#define TINYGLTF_TARGET_ELEMENT_ARRAY_BUFFER (34963)\n\n#define TINYGLTF_SHADER_TYPE_VERTEX_SHADER (35633)\n#define TINYGLTF_SHADER_TYPE_FRAGMENT_SHADER (35632)\n\n#define TINYGLTF_DOUBLE_EPS (1.e-12)\n#define TINYGLTF_DOUBLE_EQUAL(a, b) (std::fabs((b) - (a)) < TINYGLTF_DOUBLE_EPS)\n\n#ifdef __ANDROID__\n#ifdef TINYGLTF_ANDROID_LOAD_FROM_ASSETS\nAAssetManager *asset_manager = nullptr;\n#endif\n#endif\n\ntypedef enum {\n  NULL_TYPE,\n  REAL_TYPE,\n  INT_TYPE,\n  BOOL_TYPE,\n  STRING_TYPE,\n  ARRAY_TYPE,\n  BINARY_TYPE,\n  OBJECT_TYPE\n} Type;\n\nstatic inline int32_t GetComponentSizeInBytes(uint32_t componentType) {\n  if (componentType == TINYGLTF_COMPONENT_TYPE_BYTE) {\n    return 1;\n  } else if (componentType == TINYGLTF_COMPONENT_TYPE_UNSIGNED_BYTE) {\n    return 1;\n  } else if (componentType == TINYGLTF_COMPONENT_TYPE_SHORT) {\n    return 2;\n  } else if (componentType == TINYGLTF_COMPONENT_TYPE_UNSIGNED_SHORT) {\n    return 2;\n  } else if (componentType == TINYGLTF_COMPONENT_TYPE_INT) {\n    return 4;\n  } else if (componentType == TINYGLTF_COMPONENT_TYPE_UNSIGNED_INT) {\n    return 4;\n  } else if (componentType == TINYGLTF_COMPONENT_TYPE_FLOAT) {\n    return 4;\n  } else if (componentType == TINYGLTF_COMPONENT_TYPE_DOUBLE) {\n    return 8;\n  } else {\n    // Unknown componenty type\n    return -1;\n  }\n}\n\nstatic inline int32_t GetNumComponentsInType(uint32_t ty) {\n  if (ty == TINYGLTF_TYPE_SCALAR) {\n    return 1;\n  } else if (ty == TINYGLTF_TYPE_VEC2) {\n    return 2;\n  } else if (ty == TINYGLTF_TYPE_VEC3) {\n    return 3;\n  } else if (ty == TINYGLTF_TYPE_VEC4) {\n    return 4;\n  } else if (ty == TINYGLTF_TYPE_MAT2) {\n    return 4;\n  } else if (ty == TINYGLTF_TYPE_MAT3) {\n    return 9;\n  } else if (ty == TINYGLTF_TYPE_MAT4) {\n    return 16;\n  } else {\n    // Unknown componenty type\n    return -1;\n  }\n}\n\n// TODO(syoyo): Move these functions to TinyGLTF class\nbool IsDataURI(const std::string &in);\nbool DecodeDataURI(std::vector<unsigned char> *out, std::string &mime_type,\n                   const std::string &in, size_t reqBytes, bool checkSize);\n\n#ifdef __clang__\n#pragma clang diagnostic push\n// Suppress warning for : static Value null_value\n#pragma clang diagnostic ignored \"-Wexit-time-destructors\"\n#pragma clang diagnostic ignored \"-Wpadded\"\n#endif\n\n// Simple class to represent JSON object\nclass Value {\n public:\n  typedef std::vector<Value> Array;\n  typedef std::map<std::string, Value> Object;\n\n  Value()\n      : type_(NULL_TYPE),\n        int_value_(0),\n        real_value_(0.0),\n        boolean_value_(false) {}\n\n  explicit Value(bool b) : type_(BOOL_TYPE) { boolean_value_ = b; }\n  explicit Value(int i) : type_(INT_TYPE) {\n    int_value_ = i;\n    real_value_ = i;\n  }\n  explicit Value(double n) : type_(REAL_TYPE) { real_value_ = n; }\n  explicit Value(const std::string &s) : type_(STRING_TYPE) {\n    string_value_ = s;\n  }\n  explicit Value(std::string &&s)\n      : type_(STRING_TYPE), string_value_(std::move(s)) {}\n  explicit Value(const unsigned char *p, size_t n) : type_(BINARY_TYPE) {\n    binary_value_.resize(n);\n    memcpy(binary_value_.data(), p, n);\n  }\n  explicit Value(std::vector<unsigned char> &&v) noexcept\n      : type_(BINARY_TYPE),\n        binary_value_(std::move(v)) {}\n  explicit Value(const Array &a) : type_(ARRAY_TYPE) { array_value_ = a; }\n  explicit Value(Array &&a) noexcept : type_(ARRAY_TYPE),\n                                       array_value_(std::move(a)) {}\n\n  explicit Value(const Object &o) : type_(OBJECT_TYPE) { object_value_ = o; }\n  explicit Value(Object &&o) noexcept : type_(OBJECT_TYPE),\n                                        object_value_(std::move(o)) {}\n\n  DEFAULT_METHODS(Value)\n\n  char Type() const { return static_cast<char>(type_); }\n\n  bool IsBool() const { return (type_ == BOOL_TYPE); }\n\n  bool IsInt() const { return (type_ == INT_TYPE); }\n\n  bool IsNumber() const { return (type_ == REAL_TYPE) || (type_ == INT_TYPE); }\n\n  bool IsReal() const { return (type_ == REAL_TYPE); }\n\n  bool IsString() const { return (type_ == STRING_TYPE); }\n\n  bool IsBinary() const { return (type_ == BINARY_TYPE); }\n\n  bool IsArray() const { return (type_ == ARRAY_TYPE); }\n\n  bool IsObject() const { return (type_ == OBJECT_TYPE); }\n\n  // Use this function if you want to have number value as double.\n  double GetNumberAsDouble() const {\n    if (type_ == INT_TYPE) {\n      return double(int_value_);\n    } else {\n      return real_value_;\n    }\n  }\n\n  // Use this function if you want to have number value as int.\n  // TODO(syoyo): Support int value larger than 32 bits\n  int GetNumberAsInt() const {\n    if (type_ == REAL_TYPE) {\n      return int(real_value_);\n    } else {\n      return int_value_;\n    }\n  }\n\n  // Accessor\n  template <typename T>\n  const T &Get() const;\n  template <typename T>\n  T &Get();\n\n  // Lookup value from an array\n  const Value &Get(int idx) const {\n    static Value null_value;\n    assert(IsArray());\n    assert(idx >= 0);\n    return (static_cast<size_t>(idx) < array_value_.size())\n               ? array_value_[static_cast<size_t>(idx)]\n               : null_value;\n  }\n\n  // Lookup value from a key-value pair\n  const Value &Get(const std::string &key) const {\n    static Value null_value;\n    assert(IsObject());\n    Object::const_iterator it = object_value_.find(key);\n    return (it != object_value_.end()) ? it->second : null_value;\n  }\n\n  size_t ArrayLen() const {\n    if (!IsArray()) return 0;\n    return array_value_.size();\n  }\n\n  // Valid only for object type.\n  bool Has(const std::string &key) const {\n    if (!IsObject()) return false;\n    Object::const_iterator it = object_value_.find(key);\n    return (it != object_value_.end()) ? true : false;\n  }\n\n  // List keys\n  std::vector<std::string> Keys() const {\n    std::vector<std::string> keys;\n    if (!IsObject()) return keys;  // empty\n\n    for (Object::const_iterator it = object_value_.begin();\n         it != object_value_.end(); ++it) {\n      keys.push_back(it->first);\n    }\n\n    return keys;\n  }\n\n  size_t Size() const { return (IsArray() ? ArrayLen() : Keys().size()); }\n\n  bool operator==(const tinygltf::Value &other) const;\n\n protected:\n  int type_ = NULL_TYPE;\n\n  int int_value_ = 0;\n  double real_value_ = 0.0;\n  std::string string_value_;\n  std::vector<unsigned char> binary_value_;\n  Array array_value_;\n  Object object_value_;\n  bool boolean_value_ = false;\n};\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n#define TINYGLTF_VALUE_GET(ctype, var)            \\\n  template <>                                     \\\n  inline const ctype &Value::Get<ctype>() const { \\\n    return var;                                   \\\n  }                                               \\\n  template <>                                     \\\n  inline ctype &Value::Get<ctype>() {             \\\n    return var;                                   \\\n  }\nTINYGLTF_VALUE_GET(bool, boolean_value_)\nTINYGLTF_VALUE_GET(double, real_value_)\nTINYGLTF_VALUE_GET(int, int_value_)\nTINYGLTF_VALUE_GET(std::string, string_value_)\nTINYGLTF_VALUE_GET(std::vector<unsigned char>, binary_value_)\nTINYGLTF_VALUE_GET(Value::Array, array_value_)\nTINYGLTF_VALUE_GET(Value::Object, object_value_)\n#undef TINYGLTF_VALUE_GET\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wc++98-compat\"\n#pragma clang diagnostic ignored \"-Wpadded\"\n#endif\n\n/// Agregate object for representing a color\nusing ColorValue = std::array<double, 4>;\n\n// === legacy interface ====\n// TODO(syoyo): Deprecate `Parameter` class.\nstruct Parameter {\n  bool bool_value = false;\n  bool has_number_value = false;\n  std::string string_value;\n  std::vector<double> number_array;\n  std::map<std::string, double> json_double_value;\n  double number_value = 0.0;\n\n  // context sensitive methods. depending the type of the Parameter you are\n  // accessing, these are either valid or not\n  // If this parameter represent a texture map in a material, will return the\n  // texture index\n\n  /// Return the index of a texture if this Parameter is a texture map.\n  /// Returned value is only valid if the parameter represent a texture from a\n  /// material\n  int TextureIndex() const {\n    const auto it = json_double_value.find(\"index\");\n    if (it != std::end(json_double_value)) {\n      return int(it->second);\n    }\n    return -1;\n  }\n\n  /// Return the index of a texture coordinate set if this Parameter is a\n  /// texture map. Returned value is only valid if the parameter represent a\n  /// texture from a material\n  int TextureTexCoord() const {\n    const auto it = json_double_value.find(\"texCoord\");\n    if (it != std::end(json_double_value)) {\n      return int(it->second);\n    }\n    // As per the spec, if texCoord is ommited, this parameter is 0\n    return 0;\n  }\n\n  /// Return the scale of a texture if this Parameter is a normal texture map.\n  /// Returned value is only valid if the parameter represent a normal texture\n  /// from a material\n  double TextureScale() const {\n    const auto it = json_double_value.find(\"scale\");\n    if (it != std::end(json_double_value)) {\n      return it->second;\n    }\n    // As per the spec, if scale is ommited, this paramter is 1\n    return 1;\n  }\n\n  /// Return the strength of a texture if this Parameter is a an occlusion map.\n  /// Returned value is only valid if the parameter represent an occlusion map\n  /// from a material\n  double TextureStrength() const {\n    const auto it = json_double_value.find(\"strength\");\n    if (it != std::end(json_double_value)) {\n      return it->second;\n    }\n    // As per the spec, if strenghth is ommited, this parameter is 1\n    return 1;\n  }\n\n  /// Material factor, like the roughness or metalness of a material\n  /// Returned value is only valid if the parameter represent a texture from a\n  /// material\n  double Factor() const { return number_value; }\n\n  /// Return the color of a material\n  /// Returned value is only valid if the parameter represent a texture from a\n  /// material\n  ColorValue ColorFactor() const {\n    return {\n        {// this agregate intialize the std::array object, and uses C++11 RVO.\n         number_array[0], number_array[1], number_array[2],\n         (number_array.size() > 3 ? number_array[3] : 1.0)}};\n  }\n\n  Parameter() = default;\n  DEFAULT_METHODS(Parameter)\n  bool operator==(const Parameter &) const;\n};\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wpadded\"\n#endif\n\ntypedef std::map<std::string, Parameter> ParameterMap;\ntypedef std::map<std::string, Value> ExtensionMap;\n\nstruct AnimationChannel {\n  int sampler;              // required\n  int target_node;          // required (index of the node to target)\n  std::string target_path;  // required in [\"translation\", \"rotation\", \"scale\",\n                            // \"weights\"]\n  Value extras;\n  ExtensionMap extensions;\n  ExtensionMap target_extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n  std::string target_extensions_json_string;\n\n  AnimationChannel() : sampler(-1), target_node(-1) {}\n  DEFAULT_METHODS(AnimationChannel)\n  bool operator==(const AnimationChannel &) const;\n};\n\nstruct AnimationSampler {\n  int input;                  // required\n  int output;                 // required\n  std::string interpolation;  // \"LINEAR\", \"STEP\",\"CUBICSPLINE\" or user defined\n                              // string. default \"LINEAR\"\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  AnimationSampler() : input(-1), output(-1), interpolation(\"LINEAR\") {}\n  DEFAULT_METHODS(AnimationSampler)\n  bool operator==(const AnimationSampler &) const;\n};\n\nstruct Animation {\n  std::string name;\n  std::vector<AnimationChannel> channels;\n  std::vector<AnimationSampler> samplers;\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  Animation() = default;\n  DEFAULT_METHODS(Animation)\n  bool operator==(const Animation &) const;\n};\n\nstruct Skin {\n  std::string name;\n  int inverseBindMatrices;  // required here but not in the spec\n  int skeleton;             // The index of the node used as a skeleton root\n  std::vector<int> joints;  // Indices of skeleton nodes\n\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  Skin() {\n    inverseBindMatrices = -1;\n    skeleton = -1;\n  }\n  DEFAULT_METHODS(Skin)\n  bool operator==(const Skin &) const;\n};\n\nstruct Sampler {\n  std::string name;\n  // glTF 2.0 spec does not define default value for `minFilter` and\n  // `magFilter`. Set -1 in TinyGLTF(issue #186)\n  int minFilter =\n      -1;  // optional. -1 = no filter defined. [\"NEAREST\", \"LINEAR\",\n           // \"NEAREST_MIPMAP_NEAREST\", \"LINEAR_MIPMAP_NEAREST\",\n           // \"NEAREST_MIPMAP_LINEAR\", \"LINEAR_MIPMAP_LINEAR\"]\n  int magFilter =\n      -1;  // optional. -1 = no filter defined. [\"NEAREST\", \"LINEAR\"]\n  int wrapS =\n      TINYGLTF_TEXTURE_WRAP_REPEAT;  // [\"CLAMP_TO_EDGE\", \"MIRRORED_REPEAT\",\n                                     // \"REPEAT\"], default \"REPEAT\"\n  int wrapT =\n      TINYGLTF_TEXTURE_WRAP_REPEAT;  // [\"CLAMP_TO_EDGE\", \"MIRRORED_REPEAT\",\n                                     // \"REPEAT\"], default \"REPEAT\"\n  // int wrapR = TINYGLTF_TEXTURE_WRAP_REPEAT;  // TinyGLTF extension. currently\n  // not used.\n\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  Sampler()\n      : minFilter(-1),\n        magFilter(-1),\n        wrapS(TINYGLTF_TEXTURE_WRAP_REPEAT),\n        wrapT(TINYGLTF_TEXTURE_WRAP_REPEAT) {}\n  DEFAULT_METHODS(Sampler)\n  bool operator==(const Sampler &) const;\n};\n\nstruct Image {\n  std::string name;\n  int width;\n  int height;\n  int component;\n  int bits;        // bit depth per channel. 8(byte), 16 or 32.\n  int pixel_type;  // pixel type(TINYGLTF_COMPONENT_TYPE_***). usually\n                   // UBYTE(bits = 8) or USHORT(bits = 16)\n  std::vector<unsigned char> image;\n  int bufferView;        // (required if no uri)\n  std::string mimeType;  // (required if no uri) [\"image/jpeg\", \"image/png\",\n                         // \"image/bmp\", \"image/gif\"]\n  std::string uri;       // (required if no mimeType) uri is not decoded(e.g.\n                         // whitespace may be represented as %20)\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  // When this flag is true, data is stored to `image` in as-is format(e.g. jpeg\n  // compressed for \"image/jpeg\" mime) This feature is good if you use custom\n  // image loader function. (e.g. delayed decoding of images for faster glTF\n  // parsing) Default parser for Image does not provide as-is loading feature at\n  // the moment. (You can manipulate this by providing your own LoadImageData\n  // function)\n  bool as_is;\n\n  Image() : as_is(false) {\n    bufferView = -1;\n    width = -1;\n    height = -1;\n    component = -1;\n    bits = -1;\n    pixel_type = -1;\n  }\n  DEFAULT_METHODS(Image)\n\n  bool operator==(const Image &) const;\n};\n\nstruct Texture {\n  std::string name;\n\n  int sampler;\n  int source;\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  Texture() : sampler(-1), source(-1) {}\n  DEFAULT_METHODS(Texture)\n\n  bool operator==(const Texture &) const;\n};\n\nstruct TextureInfo {\n  int index = -1;  // required.\n  int texCoord;    // The set index of texture's TEXCOORD attribute used for\n                   // texture coordinate mapping.\n\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  TextureInfo() : index(-1), texCoord(0) {}\n  DEFAULT_METHODS(TextureInfo)\n  bool operator==(const TextureInfo &) const;\n};\n\nstruct NormalTextureInfo {\n  int index = -1;  // required\n  int texCoord;    // The set index of texture's TEXCOORD attribute used for\n                   // texture coordinate mapping.\n  double scale;    // scaledNormal = normalize((<sampled normal texture value>\n                   // * 2.0 - 1.0) * vec3(<normal scale>, <normal scale>, 1.0))\n\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  NormalTextureInfo() : index(-1), texCoord(0), scale(1.0) {}\n  DEFAULT_METHODS(NormalTextureInfo)\n  bool operator==(const NormalTextureInfo &) const;\n};\n\nstruct OcclusionTextureInfo {\n  int index = -1;   // required\n  int texCoord;     // The set index of texture's TEXCOORD attribute used for\n                    // texture coordinate mapping.\n  double strength;  // occludedColor = lerp(color, color * <sampled occlusion\n                    // texture value>, <occlusion strength>)\n\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  OcclusionTextureInfo() : index(-1), texCoord(0), strength(1.0) {}\n  DEFAULT_METHODS(OcclusionTextureInfo)\n  bool operator==(const OcclusionTextureInfo &) const;\n};\n\n// pbrMetallicRoughness class defined in glTF 2.0 spec.\nstruct PbrMetallicRoughness {\n  std::vector<double> baseColorFactor;  // len = 4. default [1,1,1,1]\n  TextureInfo baseColorTexture;\n  double metallicFactor;   // default 1\n  double roughnessFactor;  // default 1\n  TextureInfo metallicRoughnessTexture;\n\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  PbrMetallicRoughness()\n      : baseColorFactor(std::vector<double>{1.0, 1.0, 1.0, 1.0}),\n        metallicFactor(1.0),\n        roughnessFactor(1.0) {}\n  DEFAULT_METHODS(PbrMetallicRoughness)\n  bool operator==(const PbrMetallicRoughness &) const;\n};\n\n// Each extension should be stored in a ParameterMap.\n// members not in the values could be included in the ParameterMap\n// to keep a single material model\nstruct Material {\n  std::string name;\n\n  std::vector<double> emissiveFactor;  // length 3. default [0, 0, 0]\n  std::string alphaMode;               // default \"OPAQUE\"\n  double alphaCutoff;                  // default 0.5\n  bool doubleSided;                    // default false;\n\n  PbrMetallicRoughness pbrMetallicRoughness;\n\n  NormalTextureInfo normalTexture;\n  OcclusionTextureInfo occlusionTexture;\n  TextureInfo emissiveTexture;\n\n  // For backward compatibility\n  // TODO(syoyo): Remove `values` and `additionalValues` in the next release.\n  ParameterMap values;\n  ParameterMap additionalValues;\n\n  ExtensionMap extensions;\n  Value extras;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  Material() : alphaMode(\"OPAQUE\"), alphaCutoff(0.5), doubleSided(false) {}\n  DEFAULT_METHODS(Material)\n\n  bool operator==(const Material &) const;\n};\n\nstruct BufferView {\n  std::string name;\n  int buffer{-1};        // Required\n  size_t byteOffset{0};  // minimum 0, default 0\n  size_t byteLength{0};  // required, minimum 1. 0 = invalid\n  size_t byteStride{0};  // minimum 4, maximum 252 (multiple of 4), default 0 =\n                         // understood to be tightly packed\n  int target{0};  // [\"ARRAY_BUFFER\", \"ELEMENT_ARRAY_BUFFER\"] for vertex indices\n                  // or atttribs. Could be 0 for other data\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  bool dracoDecoded{false};  // Flag indicating this has been draco decoded\n\n  BufferView()\n      : buffer(-1),\n        byteOffset(0),\n        byteLength(0),\n        byteStride(0),\n        target(0),\n        dracoDecoded(false) {}\n  DEFAULT_METHODS(BufferView)\n  bool operator==(const BufferView &) const;\n};\n\nstruct Accessor {\n  int bufferView;  // optional in spec but required here since sparse accessor\n                   // are not supported\n  std::string name;\n  size_t byteOffset;\n  bool normalized;    // optional.\n  int componentType;  // (required) One of TINYGLTF_COMPONENT_TYPE_***\n  size_t count;       // required\n  int type;           // (required) One of TINYGLTF_TYPE_***   ..\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  std::vector<double>\n      minValues;  // optional. integer value is promoted to double\n  std::vector<double>\n      maxValues;  // optional. integer value is promoted to double\n\n  struct {\n    int count;\n    bool isSparse;\n    struct {\n      int byteOffset;\n      int bufferView;\n      int componentType;  // a TINYGLTF_COMPONENT_TYPE_ value\n    } indices;\n    struct {\n      int bufferView;\n      int byteOffset;\n    } values;\n  } sparse;\n\n  ///\n  /// Utility function to compute byteStride for a given bufferView object.\n  /// Returns -1 upon invalid glTF value or parameter configuration.\n  ///\n  int ByteStride(const BufferView &bufferViewObject) const {\n    if (bufferViewObject.byteStride == 0) {\n      // Assume data is tightly packed.\n      int componentSizeInBytes =\n          GetComponentSizeInBytes(static_cast<uint32_t>(componentType));\n      if (componentSizeInBytes <= 0) {\n        return -1;\n      }\n\n      int numComponents = GetNumComponentsInType(static_cast<uint32_t>(type));\n      if (numComponents <= 0) {\n        return -1;\n      }\n\n      return componentSizeInBytes * numComponents;\n    } else {\n      // Check if byteStride is a mulple of the size of the accessor's component\n      // type.\n      int componentSizeInBytes =\n          GetComponentSizeInBytes(static_cast<uint32_t>(componentType));\n      if (componentSizeInBytes <= 0) {\n        return -1;\n      }\n\n      if ((bufferViewObject.byteStride % uint32_t(componentSizeInBytes)) != 0) {\n        return -1;\n      }\n      return static_cast<int>(bufferViewObject.byteStride);\n    }\n\n    // unreachable return 0;\n  }\n\n  Accessor()\n      : bufferView(-1),\n        byteOffset(0),\n        normalized(false),\n        componentType(-1),\n        count(0),\n        type(-1) {\n    sparse.isSparse = false;\n  }\n  DEFAULT_METHODS(Accessor)\n  bool operator==(const tinygltf::Accessor &) const;\n};\n\nstruct PerspectiveCamera {\n  double aspectRatio;  // min > 0\n  double yfov;         // required. min > 0\n  double zfar;         // min > 0\n  double znear;        // required. min > 0\n\n  PerspectiveCamera()\n      : aspectRatio(0.0),\n        yfov(0.0),\n        zfar(0.0)  // 0 = use infinite projecton matrix\n        ,\n        znear(0.0) {}\n  DEFAULT_METHODS(PerspectiveCamera)\n  bool operator==(const PerspectiveCamera &) const;\n\n  ExtensionMap extensions;\n  Value extras;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n};\n\nstruct OrthographicCamera {\n  double xmag;   // required. must not be zero.\n  double ymag;   // required. must not be zero.\n  double zfar;   // required. `zfar` must be greater than `znear`.\n  double znear;  // required\n\n  OrthographicCamera() : xmag(0.0), ymag(0.0), zfar(0.0), znear(0.0) {}\n  DEFAULT_METHODS(OrthographicCamera)\n  bool operator==(const OrthographicCamera &) const;\n\n  ExtensionMap extensions;\n  Value extras;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n};\n\nstruct Camera {\n  std::string type;  // required. \"perspective\" or \"orthographic\"\n  std::string name;\n\n  PerspectiveCamera perspective;\n  OrthographicCamera orthographic;\n\n  Camera() {}\n  DEFAULT_METHODS(Camera)\n  bool operator==(const Camera &) const;\n\n  ExtensionMap extensions;\n  Value extras;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n};\n\nstruct Primitive {\n  std::map<std::string, int> attributes;  // (required) A dictionary object of\n                                          // integer, where each integer\n                                          // is the index of the accessor\n                                          // containing an attribute.\n  int material;  // The index of the material to apply to this primitive\n                 // when rendering.\n  int indices;   // The index of the accessor that contains the indices.\n  int mode;      // one of TINYGLTF_MODE_***\n  std::vector<std::map<std::string, int> > targets;  // array of morph targets,\n  // where each target is a dict with attribues in [\"POSITION, \"NORMAL\",\n  // \"TANGENT\"] pointing\n  // to their corresponding accessors\n  ExtensionMap extensions;\n  Value extras;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  Primitive() {\n    material = -1;\n    indices = -1;\n    mode = -1;\n  }\n  DEFAULT_METHODS(Primitive)\n  bool operator==(const Primitive &) const;\n};\n\nstruct Mesh {\n  std::string name;\n  std::vector<Primitive> primitives;\n  std::vector<double> weights;  // weights to be applied to the Morph Targets\n  ExtensionMap extensions;\n  Value extras;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  Mesh() = default;\n  DEFAULT_METHODS(Mesh)\n  bool operator==(const Mesh &) const;\n};\n\nclass Node {\n public:\n  Node() : camera(-1), skin(-1), mesh(-1) {}\n\n  DEFAULT_METHODS(Node)\n\n  bool operator==(const Node &) const;\n\n  int camera;  // the index of the camera referenced by this node\n\n  std::string name;\n  int skin;\n  int mesh;\n  std::vector<int> children;\n  std::vector<double> rotation;     // length must be 0 or 4\n  std::vector<double> scale;        // length must be 0 or 3\n  std::vector<double> translation;  // length must be 0 or 3\n  std::vector<double> matrix;       // length must be 0 or 16\n  std::vector<double> weights;  // The weights of the instantiated Morph Target\n\n  ExtensionMap extensions;\n  Value extras;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n};\n\nstruct Buffer {\n  std::string name;\n  std::vector<unsigned char> data;\n  std::string\n      uri;  // considered as required here but not in the spec (need to clarify)\n            // uri is not decoded(e.g. whitespace may be represented as %20)\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  Buffer() = default;\n  DEFAULT_METHODS(Buffer)\n  bool operator==(const Buffer &) const;\n};\n\nstruct Asset {\n  std::string version = \"2.0\";  // required\n  std::string generator;\n  std::string minVersion;\n  std::string copyright;\n  ExtensionMap extensions;\n  Value extras;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  Asset() = default;\n  DEFAULT_METHODS(Asset)\n  bool operator==(const Asset &) const;\n};\n\nstruct Scene {\n  std::string name;\n  std::vector<int> nodes;\n\n  ExtensionMap extensions;\n  Value extras;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n\n  Scene() = default;\n  DEFAULT_METHODS(Scene)\n  bool operator==(const Scene &) const;\n};\n\nstruct SpotLight {\n  double innerConeAngle;\n  double outerConeAngle;\n\n  SpotLight() : innerConeAngle(0.0), outerConeAngle(0.7853981634) {}\n  DEFAULT_METHODS(SpotLight)\n  bool operator==(const SpotLight &) const;\n\n  ExtensionMap extensions;\n  Value extras;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n};\n\nstruct Light {\n  std::string name;\n  std::vector<double> color;\n  double intensity{1.0};\n  std::string type;\n  double range{0.0};  // 0.0 = inifinite\n  SpotLight spot;\n\n  Light() : intensity(1.0), range(0.0) {}\n  DEFAULT_METHODS(Light)\n\n  bool operator==(const Light &) const;\n\n  ExtensionMap extensions;\n  Value extras;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n};\n\nclass Model {\n public:\n  Model() = default;\n  DEFAULT_METHODS(Model)\n\n  bool operator==(const Model &) const;\n\n  std::vector<Accessor> accessors;\n  std::vector<Animation> animations;\n  std::vector<Buffer> buffers;\n  std::vector<BufferView> bufferViews;\n  std::vector<Material> materials;\n  std::vector<Mesh> meshes;\n  std::vector<Node> nodes;\n  std::vector<Texture> textures;\n  std::vector<Image> images;\n  std::vector<Skin> skins;\n  std::vector<Sampler> samplers;\n  std::vector<Camera> cameras;\n  std::vector<Scene> scenes;\n  std::vector<Light> lights;\n\n  int defaultScene = -1;\n  std::vector<std::string> extensionsUsed;\n  std::vector<std::string> extensionsRequired;\n\n  Asset asset;\n\n  Value extras;\n  ExtensionMap extensions;\n\n  // Filled when SetStoreOriginalJSONForExtrasAndExtensions is enabled.\n  std::string extras_json_string;\n  std::string extensions_json_string;\n};\n\nenum SectionCheck {\n  NO_REQUIRE = 0x00,\n  REQUIRE_VERSION = 0x01,\n  REQUIRE_SCENE = 0x02,\n  REQUIRE_SCENES = 0x04,\n  REQUIRE_NODES = 0x08,\n  REQUIRE_ACCESSORS = 0x10,\n  REQUIRE_BUFFERS = 0x20,\n  REQUIRE_BUFFER_VIEWS = 0x40,\n  REQUIRE_ALL = 0x7f\n};\n\n///\n/// LoadImageDataFunction type. Signature for custom image loading callbacks.\n///\ntypedef bool (*LoadImageDataFunction)(Image *, const int, std::string *,\n                                      std::string *, int, int,\n                                      const unsigned char *, int,\n                                      void *user_pointer);\n\n///\n/// WriteImageDataFunction type. Signature for custom image writing callbacks.\n///\ntypedef bool (*WriteImageDataFunction)(const std::string *, const std::string *,\n                                       Image *, bool, void *);\n\n#ifndef TINYGLTF_NO_STB_IMAGE\n// Declaration of default image loader callback\nbool LoadImageData(Image *image, const int image_idx, std::string *err,\n                   std::string *warn, int req_width, int req_height,\n                   const unsigned char *bytes, int size, void *);\n#endif\n\n#ifndef TINYGLTF_NO_STB_IMAGE_WRITE\n// Declaration of default image writer callback\nbool WriteImageData(const std::string *basepath, const std::string *filename,\n                    Image *image, bool embedImages, void *);\n#endif\n\n///\n/// FilExistsFunction type. Signature for custom filesystem callbacks.\n///\ntypedef bool (*FileExistsFunction)(const std::string &abs_filename, void *);\n\n///\n/// ExpandFilePathFunction type. Signature for custom filesystem callbacks.\n///\ntypedef std::string (*ExpandFilePathFunction)(const std::string &, void *);\n\n///\n/// ReadWholeFileFunction type. Signature for custom filesystem callbacks.\n///\ntypedef bool (*ReadWholeFileFunction)(std::vector<unsigned char> *,\n                                      std::string *, const std::string &,\n                                      void *);\n\n///\n/// WriteWholeFileFunction type. Signature for custom filesystem callbacks.\n///\ntypedef bool (*WriteWholeFileFunction)(std::string *, const std::string &,\n                                       const std::vector<unsigned char> &,\n                                       void *);\n\n///\n/// A structure containing all required filesystem callbacks and a pointer to\n/// their user data.\n///\nstruct FsCallbacks {\n  FileExistsFunction FileExists;\n  ExpandFilePathFunction ExpandFilePath;\n  ReadWholeFileFunction ReadWholeFile;\n  WriteWholeFileFunction WriteWholeFile;\n\n  void *user_data;  // An argument that is passed to all fs callbacks\n};\n\n#ifndef TINYGLTF_NO_FS\n// Declaration of default filesystem callbacks\n\nbool FileExists(const std::string &abs_filename, void *);\n\n///\n/// Expand file path(e.g. `~` to home directory on posix, `%APPDATA%` to\n/// `C:\\\\Users\\\\tinygltf\\\\AppData`)\n///\n/// @param[in] filepath File path string. Assume UTF-8\n/// @param[in] userdata User data. Set to `nullptr` if you don't need it.\n///\nstd::string ExpandFilePath(const std::string &filepath, void *userdata);\n\nbool ReadWholeFile(std::vector<unsigned char> *out, std::string *err,\n                   const std::string &filepath, void *);\n\nbool WriteWholeFile(std::string *err, const std::string &filepath,\n                    const std::vector<unsigned char> &contents, void *);\n#endif\n\n///\n/// glTF Parser/Serialier context.\n///\nclass TinyGLTF {\n public:\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wc++98-compat\"\n#endif\n\n  TinyGLTF() : bin_data_(nullptr), bin_size_(0), is_binary_(false) {}\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n  ~TinyGLTF() {}\n\n  ///\n  /// Loads glTF ASCII asset from a file.\n  /// Set warning message to `warn` for example it fails to load asserts.\n  /// Returns false and set error string to `err` if there's an error.\n  ///\n  bool LoadASCIIFromFile(Model *model, std::string *err, std::string *warn,\n                         const std::string &filename,\n                         unsigned int check_sections = REQUIRE_VERSION);\n\n  ///\n  /// Loads glTF ASCII asset from string(memory).\n  /// `length` = strlen(str);\n  /// `base_dir` is a search path of glTF asset(e.g. images). Path Must be an\n  /// expanded path (e.g. no tilde(`~`), no environment variables). Set warning\n  /// message to `warn` for example it fails to load asserts. Returns false and\n  /// set error string to `err` if there's an error.\n  ///\n  bool LoadASCIIFromString(Model *model, std::string *err, std::string *warn,\n                           const char *str, const unsigned int length,\n                           const std::string &base_dir,\n                           unsigned int check_sections = REQUIRE_VERSION);\n\n  ///\n  /// Loads glTF binary asset from a file.\n  /// Set warning message to `warn` for example it fails to load asserts.\n  /// Returns false and set error string to `err` if there's an error.\n  ///\n  bool LoadBinaryFromFile(Model *model, std::string *err, std::string *warn,\n                          const std::string &filename,\n                          unsigned int check_sections = REQUIRE_VERSION);\n\n  ///\n  /// Loads glTF binary asset from memory.\n  /// `length` = strlen(str);\n  /// `base_dir` is a search path of glTF asset(e.g. images). Path Must be an\n  /// expanded path (e.g. no tilde(`~`), no environment variables).\n  /// Set warning message to `warn` for example it fails to load asserts.\n  /// Returns false and set error string to `err` if there's an error.\n  ///\n  bool LoadBinaryFromMemory(Model *model, std::string *err, std::string *warn,\n                            const unsigned char *bytes,\n                            const unsigned int length,\n                            const std::string &base_dir = \"\",\n                            unsigned int check_sections = REQUIRE_VERSION);\n\n  ///\n  /// Write glTF to stream, buffers and images will be embeded\n  ///\n  bool WriteGltfSceneToStream(Model *model, std::ostream &stream,\n                              bool prettyPrint, bool writeBinary);\n\n  ///\n  /// Write glTF to file.\n  ///\n  bool WriteGltfSceneToFile(Model *model, const std::string &filename,\n                            bool embedImages, bool embedBuffers,\n                            bool prettyPrint, bool writeBinary);\n\n  ///\n  /// Set callback to use for loading image data\n  ///\n  void SetImageLoader(LoadImageDataFunction LoadImageData, void *user_data);\n\n  ///\n  /// Unset(remove) callback of loading image data\n  ///\n  void RemoveImageLoader();\n\n  ///\n  /// Set callback to use for writing image data\n  ///\n  void SetImageWriter(WriteImageDataFunction WriteImageData, void *user_data);\n\n  ///\n  /// Set callbacks to use for filesystem (fs) access and their user data\n  ///\n  void SetFsCallbacks(FsCallbacks callbacks);\n\n  ///\n  /// Set serializing default values(default = false).\n  /// When true, default values are force serialized to .glTF.\n  /// This may be helpfull if you want to serialize a full description of glTF\n  /// data.\n  ///\n  /// TODO(LTE): Supply parsing option as function arguments to\n  /// `LoadASCIIFromFile()` and others, not by a class method\n  ///\n  void SetSerializeDefaultValues(const bool enabled) {\n    serialize_default_values_ = enabled;\n  }\n\n  bool GetSerializeDefaultValues() const { return serialize_default_values_; }\n\n  ///\n  /// Store original JSON string for `extras` and `extensions`.\n  /// This feature will be useful when the user want to reconstruct custom data\n  /// structure from JSON string.\n  ///\n  void SetStoreOriginalJSONForExtrasAndExtensions(const bool enabled) {\n    store_original_json_for_extras_and_extensions_ = enabled;\n  }\n\n  bool GetStoreOriginalJSONForExtrasAndExtensions() const {\n    return store_original_json_for_extras_and_extensions_;\n  }\n\n  ///\n  /// Specify whether preserve image channales when loading images or not.\n  /// (Not effective when the user suppy their own LoadImageData callbacks)\n  ///\n  void SetPreserveImageChannels(bool onoff) {\n    preserve_image_channels_ = onoff;\n  }\n\n  bool GetPreserveImageChannels() const { return preserve_image_channels_; }\n\n private:\n  ///\n  /// Loads glTF asset from string(memory).\n  /// `length` = strlen(str);\n  /// Set warning message to `warn` for example it fails to load asserts\n  /// Returns false and set error string to `err` if there's an error.\n  ///\n  bool LoadFromString(Model *model, std::string *err, std::string *warn,\n                      const char *str, const unsigned int length,\n                      const std::string &base_dir, unsigned int check_sections);\n\n  const unsigned char *bin_data_ = nullptr;\n  size_t bin_size_ = 0;\n  bool is_binary_ = false;\n\n  bool serialize_default_values_ = false;  ///< Serialize default values?\n\n  bool store_original_json_for_extras_and_extensions_ = false;\n\n  bool preserve_image_channels_ = false;  /// Default false(expand channels to\n                                          /// RGBA) for backward compatibility.\n\n  FsCallbacks fs = {\n#ifndef TINYGLTF_NO_FS\n      &tinygltf::FileExists, &tinygltf::ExpandFilePath,\n      &tinygltf::ReadWholeFile, &tinygltf::WriteWholeFile,\n\n      nullptr  // Fs callback user data\n#else\n      nullptr, nullptr, nullptr, nullptr,\n\n      nullptr  // Fs callback user data\n#endif\n  };\n\n  LoadImageDataFunction LoadImageData =\n#ifndef TINYGLTF_NO_STB_IMAGE\n      &tinygltf::LoadImageData;\n#else\n      nullptr;\n#endif\n  void *load_image_user_data_{nullptr};\n  bool user_image_loader_{false};\n\n  WriteImageDataFunction WriteImageData =\n#ifndef TINYGLTF_NO_STB_IMAGE_WRITE\n      &tinygltf::WriteImageData;\n#else\n      nullptr;\n#endif\n  void *write_image_user_data_{nullptr};\n};\n\n#ifdef __clang__\n#pragma clang diagnostic pop  // -Wpadded\n#endif\n\n}  // namespace tinygltf\n\n#endif  // TINY_GLTF_H_\n\n#if defined(TINYGLTF_IMPLEMENTATION) || defined(__INTELLISENSE__)\n#include <algorithm>\n//#include <cassert>\n#ifndef TINYGLTF_NO_FS\n#include <cstdio>\n#include <fstream>\n#endif\n#include <sstream>\n\n#ifdef __clang__\n// Disable some warnings for external files.\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wfloat-equal\"\n#pragma clang diagnostic ignored \"-Wexit-time-destructors\"\n#pragma clang diagnostic ignored \"-Wconversion\"\n#pragma clang diagnostic ignored \"-Wold-style-cast\"\n#pragma clang diagnostic ignored \"-Wglobal-constructors\"\n#if __has_warning(\"-Wreserved-id-macro\")\n#pragma clang diagnostic ignored \"-Wreserved-id-macro\"\n#endif\n#pragma clang diagnostic ignored \"-Wdisabled-macro-expansion\"\n#pragma clang diagnostic ignored \"-Wpadded\"\n#pragma clang diagnostic ignored \"-Wc++98-compat\"\n#pragma clang diagnostic ignored \"-Wc++98-compat-pedantic\"\n#pragma clang diagnostic ignored \"-Wdocumentation-unknown-command\"\n#pragma clang diagnostic ignored \"-Wswitch-enum\"\n#pragma clang diagnostic ignored \"-Wimplicit-fallthrough\"\n#pragma clang diagnostic ignored \"-Wweak-vtables\"\n#pragma clang diagnostic ignored \"-Wcovered-switch-default\"\n#if __has_warning(\"-Wdouble-promotion\")\n#pragma clang diagnostic ignored \"-Wdouble-promotion\"\n#endif\n#if __has_warning(\"-Wcomma\")\n#pragma clang diagnostic ignored \"-Wcomma\"\n#endif\n#if __has_warning(\"-Wzero-as-null-pointer-constant\")\n#pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"\n#endif\n#if __has_warning(\"-Wcast-qual\")\n#pragma clang diagnostic ignored \"-Wcast-qual\"\n#endif\n#if __has_warning(\"-Wmissing-variable-declarations\")\n#pragma clang diagnostic ignored \"-Wmissing-variable-declarations\"\n#endif\n#if __has_warning(\"-Wmissing-prototypes\")\n#pragma clang diagnostic ignored \"-Wmissing-prototypes\"\n#endif\n#if __has_warning(\"-Wcast-align\")\n#pragma clang diagnostic ignored \"-Wcast-align\"\n#endif\n#if __has_warning(\"-Wnewline-eof\")\n#pragma clang diagnostic ignored \"-Wnewline-eof\"\n#endif\n#if __has_warning(\"-Wunused-parameter\")\n#pragma clang diagnostic ignored \"-Wunused-parameter\"\n#endif\n#if __has_warning(\"-Wmismatched-tags\")\n#pragma clang diagnostic ignored \"-Wmismatched-tags\"\n#endif\n#if __has_warning(\"-Wextra-semi-stmt\")\n#pragma clang diagnostic ignored \"-Wextra-semi-stmt\"\n#endif\n#endif\n\n// Disable GCC warnigs\n#ifdef __GNUC__\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wtype-limits\"\n#endif  // __GNUC__\n\n#ifndef TINYGLTF_NO_INCLUDE_JSON\n#ifndef TINYGLTF_USE_RAPIDJSON\n#include \"json.hpp\"\n#else\n#ifndef TINYGLTF_NO_INCLUDE_RAPIDJSON\n#include \"document.h\"\n#include \"prettywriter.h\"\n#include \"rapidjson.h\"\n#include \"stringbuffer.h\"\n#include \"writer.h\"\n#endif\n#endif\n#endif\n\n#ifdef TINYGLTF_ENABLE_DRACO\n#include \"draco/compression/decode.h\"\n#include \"draco/core/decoder_buffer.h\"\n#endif\n\n#ifndef TINYGLTF_NO_STB_IMAGE\n#ifndef TINYGLTF_NO_INCLUDE_STB_IMAGE\n#include \"stb_image.h\"\n#endif\n#endif\n\n#ifndef TINYGLTF_NO_STB_IMAGE_WRITE\n#ifndef TINYGLTF_NO_INCLUDE_STB_IMAGE_WRITE\n#include \"stb_image_write.h\"\n#endif\n#endif\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n#ifdef __GNUC__\n#pragma GCC diagnostic pop\n#endif\n\n#ifdef _WIN32\n\n// issue 143.\n// Define NOMINMAX to avoid min/max defines,\n// but undef it after included windows.h\n#ifndef NOMINMAX\n#define TINYGLTF_INTERNAL_NOMINMAX\n#define NOMINMAX\n#endif\n\n#ifndef WIN32_LEAN_AND_MEAN\n#define WIN32_LEAN_AND_MEAN\n#define TINYGLTF_INTERNAL_WIN32_LEAN_AND_MEAN\n#endif\n#include <windows.h>  // include API for expanding a file path\n\n#ifdef TINYGLTF_INTERNAL_WIN32_LEAN_AND_MEAN\n#undef WIN32_LEAN_AND_MEAN\n#endif\n\n#if defined(TINYGLTF_INTERNAL_NOMINMAX)\n#undef NOMINMAX\n#endif\n\n#if defined(__GLIBCXX__)  // mingw\n\n#include <fcntl.h>  // _O_RDONLY\n\n#include <ext/stdio_filebuf.h>  // fstream (all sorts of IO stuff) + stdio_filebuf (=streambuf)\n\n#endif\n\n#elif !defined(__ANDROID__) && !defined(__OpenBSD__)\n//#include <wordexp.h>\n#endif\n\n#if defined(__sparcv9) || defined(__powerpc__)\n// Big endian\n#else\n#if (__BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__) || MINIZ_X86_OR_X64_CPU\n#define TINYGLTF_LITTLE_ENDIAN 1\n#endif\n#endif\n\nnamespace {\n#ifdef TINYGLTF_USE_RAPIDJSON\n\n#ifdef TINYGLTF_USE_RAPIDJSON_CRTALLOCATOR\n// This uses the RapidJSON CRTAllocator.  It is thread safe and multiple\n// documents may be active at once.\nusing json =\n    rapidjson::GenericValue<rapidjson::UTF8<>, rapidjson::CrtAllocator>;\nusing json_const_iterator = json::ConstMemberIterator;\nusing json_const_array_iterator = json const *;\nusing JsonDocument =\n    rapidjson::GenericDocument<rapidjson::UTF8<>, rapidjson::CrtAllocator>;\nrapidjson::CrtAllocator s_CrtAllocator;  // stateless and thread safe\nrapidjson::CrtAllocator &GetAllocator() { return s_CrtAllocator; }\n#else\n// This uses the default RapidJSON MemoryPoolAllocator.  It is very fast, but\n// not thread safe. Only a single JsonDocument may be active at any one time,\n// meaning only a single gltf load/save can be active any one time.\nusing json = rapidjson::Value;\nusing json_const_iterator = json::ConstMemberIterator;\nusing json_const_array_iterator = json const *;\nrapidjson::Document *s_pActiveDocument = nullptr;\nrapidjson::Document::AllocatorType &GetAllocator() {\n  assert(s_pActiveDocument);  // Root json node must be JsonDocument type\n  return s_pActiveDocument->GetAllocator();\n}\n\n#ifdef __clang__\n#pragma clang diagnostic push\n// Suppress JsonDocument(JsonDocument &&rhs) noexcept\n#pragma clang diagnostic ignored \"-Wunused-member-function\"\n#endif\n\nstruct JsonDocument : public rapidjson::Document {\n  JsonDocument() {\n    assert(s_pActiveDocument ==\n           nullptr);  // When using default allocator, only one document can be\n                      // active at a time, if you need multiple active at once,\n                      // define TINYGLTF_USE_RAPIDJSON_CRTALLOCATOR\n    s_pActiveDocument = this;\n  }\n  JsonDocument(const JsonDocument &) = delete;\n  JsonDocument(JsonDocument &&rhs) noexcept\n      : rapidjson::Document(std::move(rhs)) {\n    s_pActiveDocument = this;\n    rhs.isNil = true;\n  }\n  ~JsonDocument() {\n    if (!isNil) {\n      s_pActiveDocument = nullptr;\n    }\n  }\n\n private:\n  bool isNil = false;\n};\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n#endif  // TINYGLTF_USE_RAPIDJSON_CRTALLOCATOR\n\n#else\nusing nlohmann::json;\nusing json_const_iterator = json::const_iterator;\nusing json_const_array_iterator = json_const_iterator;\nusing JsonDocument = json;\n#endif\n\nvoid JsonParse(JsonDocument &doc, const char *str, size_t length,\n               bool throwExc = false) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  (void)throwExc;\n  doc.Parse(str, length);\n#else\n  doc = json::parse(str, str + length, nullptr, throwExc);\n#endif\n}\n}  // namespace\n\n#ifdef __APPLE__\n#include \"TargetConditionals.h\"\n#endif\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wc++98-compat\"\n#endif\n\nnamespace tinygltf {\n\n///\n/// Internal LoadImageDataOption struct.\n/// This struct is passed through `user_pointer` in LoadImageData.\n/// The struct is not passed when the user supply their own LoadImageData\n/// callbacks.\n///\nstruct LoadImageDataOption {\n  // true: preserve image channels(e.g. load as RGB image if the image has RGB\n  // channels) default `false`(channels are expanded to RGBA for backward\n  // compatiblity).\n  bool preserve_channels{false};\n};\n\n// Equals function for Value, for recursivity\nstatic bool Equals(const tinygltf::Value &one, const tinygltf::Value &other) {\n  if (one.Type() != other.Type()) return false;\n\n  switch (one.Type()) {\n    case NULL_TYPE:\n      return true;\n    case BOOL_TYPE:\n      return one.Get<bool>() == other.Get<bool>();\n    case REAL_TYPE:\n      return TINYGLTF_DOUBLE_EQUAL(one.Get<double>(), other.Get<double>());\n    case INT_TYPE:\n      return one.Get<int>() == other.Get<int>();\n    case OBJECT_TYPE: {\n      auto oneObj = one.Get<tinygltf::Value::Object>();\n      auto otherObj = other.Get<tinygltf::Value::Object>();\n      if (oneObj.size() != otherObj.size()) return false;\n      for (auto &it : oneObj) {\n        auto otherIt = otherObj.find(it.first);\n        if (otherIt == otherObj.end()) return false;\n\n        if (!Equals(it.second, otherIt->second)) return false;\n      }\n      return true;\n    }\n    case ARRAY_TYPE: {\n      if (one.Size() != other.Size()) return false;\n      for (int i = 0; i < int(one.Size()); ++i)\n        if (!Equals(one.Get(i), other.Get(i))) return false;\n      return true;\n    }\n    case STRING_TYPE:\n      return one.Get<std::string>() == other.Get<std::string>();\n    case BINARY_TYPE:\n      return one.Get<std::vector<unsigned char> >() ==\n             other.Get<std::vector<unsigned char> >();\n    default: {\n      // unhandled type\n      return false;\n    }\n  }\n}\n\n// Equals function for std::vector<double> using TINYGLTF_DOUBLE_EPSILON\nstatic bool Equals(const std::vector<double> &one,\n                   const std::vector<double> &other) {\n  if (one.size() != other.size()) return false;\n  for (int i = 0; i < int(one.size()); ++i) {\n    if (!TINYGLTF_DOUBLE_EQUAL(one[size_t(i)], other[size_t(i)])) return false;\n  }\n  return true;\n}\n\nbool Accessor::operator==(const Accessor &other) const {\n  return this->bufferView == other.bufferView &&\n         this->byteOffset == other.byteOffset &&\n         this->componentType == other.componentType &&\n         this->count == other.count && this->extensions == other.extensions &&\n         this->extras == other.extras &&\n         Equals(this->maxValues, other.maxValues) &&\n         Equals(this->minValues, other.minValues) && this->name == other.name &&\n         this->normalized == other.normalized && this->type == other.type;\n}\nbool Animation::operator==(const Animation &other) const {\n  return this->channels == other.channels &&\n         this->extensions == other.extensions && this->extras == other.extras &&\n         this->name == other.name && this->samplers == other.samplers;\n}\nbool AnimationChannel::operator==(const AnimationChannel &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->target_node == other.target_node &&\n         this->target_path == other.target_path &&\n         this->sampler == other.sampler;\n}\nbool AnimationSampler::operator==(const AnimationSampler &other) const {\n  return this->extras == other.extras && this->extensions == other.extensions &&\n         this->input == other.input &&\n         this->interpolation == other.interpolation &&\n         this->output == other.output;\n}\nbool Asset::operator==(const Asset &other) const {\n  return this->copyright == other.copyright &&\n         this->extensions == other.extensions && this->extras == other.extras &&\n         this->generator == other.generator &&\n         this->minVersion == other.minVersion && this->version == other.version;\n}\nbool Buffer::operator==(const Buffer &other) const {\n  return this->data == other.data && this->extensions == other.extensions &&\n         this->extras == other.extras && this->name == other.name &&\n         this->uri == other.uri;\n}\nbool BufferView::operator==(const BufferView &other) const {\n  return this->buffer == other.buffer && this->byteLength == other.byteLength &&\n         this->byteOffset == other.byteOffset &&\n         this->byteStride == other.byteStride && this->name == other.name &&\n         this->target == other.target && this->extensions == other.extensions &&\n         this->extras == other.extras &&\n         this->dracoDecoded == other.dracoDecoded;\n}\nbool Camera::operator==(const Camera &other) const {\n  return this->name == other.name && this->extensions == other.extensions &&\n         this->extras == other.extras &&\n         this->orthographic == other.orthographic &&\n         this->perspective == other.perspective && this->type == other.type;\n}\nbool Image::operator==(const Image &other) const {\n  return this->bufferView == other.bufferView &&\n         this->component == other.component &&\n         this->extensions == other.extensions && this->extras == other.extras &&\n         this->height == other.height && this->image == other.image &&\n         this->mimeType == other.mimeType && this->name == other.name &&\n         this->uri == other.uri && this->width == other.width;\n}\nbool Light::operator==(const Light &other) const {\n  return Equals(this->color, other.color) && this->name == other.name &&\n         this->type == other.type;\n}\nbool Material::operator==(const Material &other) const {\n  return (this->pbrMetallicRoughness == other.pbrMetallicRoughness) &&\n         (this->normalTexture == other.normalTexture) &&\n         (this->occlusionTexture == other.occlusionTexture) &&\n         (this->emissiveTexture == other.emissiveTexture) &&\n         Equals(this->emissiveFactor, other.emissiveFactor) &&\n         (this->alphaMode == other.alphaMode) &&\n         TINYGLTF_DOUBLE_EQUAL(this->alphaCutoff, other.alphaCutoff) &&\n         (this->doubleSided == other.doubleSided) &&\n         (this->extensions == other.extensions) &&\n         (this->extras == other.extras) && (this->values == other.values) &&\n         (this->additionalValues == other.additionalValues) &&\n         (this->name == other.name);\n}\nbool Mesh::operator==(const Mesh &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->name == other.name && Equals(this->weights, other.weights) &&\n         this->primitives == other.primitives;\n}\nbool Model::operator==(const Model &other) const {\n  return this->accessors == other.accessors &&\n         this->animations == other.animations && this->asset == other.asset &&\n         this->buffers == other.buffers &&\n         this->bufferViews == other.bufferViews &&\n         this->cameras == other.cameras &&\n         this->defaultScene == other.defaultScene &&\n         this->extensions == other.extensions &&\n         this->extensionsRequired == other.extensionsRequired &&\n         this->extensionsUsed == other.extensionsUsed &&\n         this->extras == other.extras && this->images == other.images &&\n         this->lights == other.lights && this->materials == other.materials &&\n         this->meshes == other.meshes && this->nodes == other.nodes &&\n         this->samplers == other.samplers && this->scenes == other.scenes &&\n         this->skins == other.skins && this->textures == other.textures;\n}\nbool Node::operator==(const Node &other) const {\n  return this->camera == other.camera && this->children == other.children &&\n         this->extensions == other.extensions && this->extras == other.extras &&\n         Equals(this->matrix, other.matrix) && this->mesh == other.mesh &&\n         this->name == other.name && Equals(this->rotation, other.rotation) &&\n         Equals(this->scale, other.scale) && this->skin == other.skin &&\n         Equals(this->translation, other.translation) &&\n         Equals(this->weights, other.weights);\n}\nbool SpotLight::operator==(const SpotLight &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         TINYGLTF_DOUBLE_EQUAL(this->innerConeAngle, other.innerConeAngle) &&\n         TINYGLTF_DOUBLE_EQUAL(this->outerConeAngle, other.outerConeAngle);\n}\nbool OrthographicCamera::operator==(const OrthographicCamera &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         TINYGLTF_DOUBLE_EQUAL(this->xmag, other.xmag) &&\n         TINYGLTF_DOUBLE_EQUAL(this->ymag, other.ymag) &&\n         TINYGLTF_DOUBLE_EQUAL(this->zfar, other.zfar) &&\n         TINYGLTF_DOUBLE_EQUAL(this->znear, other.znear);\n}\nbool Parameter::operator==(const Parameter &other) const {\n  if (this->bool_value != other.bool_value ||\n      this->has_number_value != other.has_number_value)\n    return false;\n\n  if (!TINYGLTF_DOUBLE_EQUAL(this->number_value, other.number_value))\n    return false;\n\n  if (this->json_double_value.size() != other.json_double_value.size())\n    return false;\n  for (auto &it : this->json_double_value) {\n    auto otherIt = other.json_double_value.find(it.first);\n    if (otherIt == other.json_double_value.end()) return false;\n\n    if (!TINYGLTF_DOUBLE_EQUAL(it.second, otherIt->second)) return false;\n  }\n\n  if (!Equals(this->number_array, other.number_array)) return false;\n\n  if (this->string_value != other.string_value) return false;\n\n  return true;\n}\nbool PerspectiveCamera::operator==(const PerspectiveCamera &other) const {\n  return TINYGLTF_DOUBLE_EQUAL(this->aspectRatio, other.aspectRatio) &&\n         this->extensions == other.extensions && this->extras == other.extras &&\n         TINYGLTF_DOUBLE_EQUAL(this->yfov, other.yfov) &&\n         TINYGLTF_DOUBLE_EQUAL(this->zfar, other.zfar) &&\n         TINYGLTF_DOUBLE_EQUAL(this->znear, other.znear);\n}\nbool Primitive::operator==(const Primitive &other) const {\n  return this->attributes == other.attributes && this->extras == other.extras &&\n         this->indices == other.indices && this->material == other.material &&\n         this->mode == other.mode && this->targets == other.targets;\n}\nbool Sampler::operator==(const Sampler &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->magFilter == other.magFilter &&\n         this->minFilter == other.minFilter && this->name == other.name &&\n         this->wrapS == other.wrapS && this->wrapT == other.wrapT;\n\n  // this->wrapR == other.wrapR\n}\nbool Scene::operator==(const Scene &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->name == other.name && this->nodes == other.nodes;\n}\nbool Skin::operator==(const Skin &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->inverseBindMatrices == other.inverseBindMatrices &&\n         this->joints == other.joints && this->name == other.name &&\n         this->skeleton == other.skeleton;\n}\nbool Texture::operator==(const Texture &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->name == other.name && this->sampler == other.sampler &&\n         this->source == other.source;\n}\nbool TextureInfo::operator==(const TextureInfo &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->index == other.index && this->texCoord == other.texCoord;\n}\nbool NormalTextureInfo::operator==(const NormalTextureInfo &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->index == other.index && this->texCoord == other.texCoord &&\n         TINYGLTF_DOUBLE_EQUAL(this->scale, other.scale);\n}\nbool OcclusionTextureInfo::operator==(const OcclusionTextureInfo &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         this->index == other.index && this->texCoord == other.texCoord &&\n         TINYGLTF_DOUBLE_EQUAL(this->strength, other.strength);\n}\nbool PbrMetallicRoughness::operator==(const PbrMetallicRoughness &other) const {\n  return this->extensions == other.extensions && this->extras == other.extras &&\n         (this->baseColorTexture == other.baseColorTexture) &&\n         (this->metallicRoughnessTexture == other.metallicRoughnessTexture) &&\n         Equals(this->baseColorFactor, other.baseColorFactor) &&\n         TINYGLTF_DOUBLE_EQUAL(this->metallicFactor, other.metallicFactor) &&\n         TINYGLTF_DOUBLE_EQUAL(this->roughnessFactor, other.roughnessFactor);\n}\nbool Value::operator==(const Value &other) const {\n  return Equals(*this, other);\n}\n\nstatic void swap4(unsigned int *val) {\n#ifdef TINYGLTF_LITTLE_ENDIAN\n  (void)val;\n#else\n  unsigned int tmp = *val;\n  unsigned char *dst = reinterpret_cast<unsigned char *>(val);\n  unsigned char *src = reinterpret_cast<unsigned char *>(&tmp);\n\n  dst[0] = src[3];\n  dst[1] = src[2];\n  dst[2] = src[1];\n  dst[3] = src[0];\n#endif\n}\n\nstatic std::string JoinPath(const std::string &path0,\n                            const std::string &path1) {\n  if (path0.empty()) {\n    return path1;\n  } else {\n    // check '/'\n    char lastChar = *path0.rbegin();\n    if (lastChar != '/') {\n      return path0 + std::string(\"/\") + path1;\n    } else {\n      return path0 + path1;\n    }\n  }\n}\n\nstatic std::string FindFile(const std::vector<std::string> &paths,\n                            const std::string &filepath, FsCallbacks *fs) {\n  if (fs == nullptr || fs->ExpandFilePath == nullptr ||\n      fs->FileExists == nullptr) {\n    // Error, fs callback[s] missing\n    return std::string();\n  }\n\n  for (size_t i = 0; i < paths.size(); i++) {\n    std::string absPath =\n        fs->ExpandFilePath(JoinPath(paths[i], filepath), fs->user_data);\n    if (fs->FileExists(absPath, fs->user_data)) {\n      return absPath;\n    }\n  }\n\n  return std::string();\n}\n\nstatic std::string GetFilePathExtension(const std::string &FileName) {\n  if (FileName.find_last_of(\".\") != std::string::npos)\n    return FileName.substr(FileName.find_last_of(\".\") + 1);\n  return \"\";\n}\n\nstatic std::string GetBaseDir(const std::string &filepath) {\n  if (filepath.find_last_of(\"/\\\\\") != std::string::npos)\n    return filepath.substr(0, filepath.find_last_of(\"/\\\\\"));\n  return \"\";\n}\n\nstatic std::string GetBaseFilename(const std::string &filepath) {\n  auto idx = filepath.find_last_of(\"/\\\\\");\n  if (idx != std::string::npos) return filepath.substr(idx + 1);\n  return filepath;\n}\n\nstd::string base64_encode(unsigned char const *, unsigned int len);\nstd::string base64_decode(std::string const &s);\n\n/*\n   base64.cpp and base64.h\n\n   Copyright (C) 2004-2008 Ren\u00e9 Nyffenegger\n\n   This source code is provided 'as-is', without any express or implied\n   warranty. In no event will the author be held liable for any damages\n   arising from the use of this software.\n\n   Permission is granted to anyone to use this software for any purpose,\n   including commercial applications, and to alter it and redistribute it\n   freely, subject to the following restrictions:\n\n   1. The origin of this source code must not be misrepresented; you must not\n      claim that you wrote the original source code. If you use this source code\n      in a product, an acknowledgment in the product documentation would be\n      appreciated but is not required.\n\n   2. Altered source versions must be plainly marked as such, and must not be\n      misrepresented as being the original source code.\n\n   3. This notice may not be removed or altered from any source distribution.\n\n   Ren\u00e9 Nyffenegger rene.nyffenegger@adp-gmbh.ch\n\n*/\n\n#ifdef __clang__\n#pragma clang diagnostic push\n#pragma clang diagnostic ignored \"-Wsign-conversion\"\n#pragma clang diagnostic ignored \"-Wconversion\"\n#endif\n\nstatic inline bool is_base64(unsigned char c) {\n  return (isalnum(c) || (c == '+') || (c == '/'));\n}\n\nstd::string base64_encode(unsigned char const *bytes_to_encode,\n                          unsigned int in_len) {\n  std::string ret;\n  int i = 0;\n  int j = 0;\n  unsigned char char_array_3[3];\n  unsigned char char_array_4[4];\n\n  const char *base64_chars =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n      \"abcdefghijklmnopqrstuvwxyz\"\n      \"0123456789+/\";\n\n  while (in_len--) {\n    char_array_3[i++] = *(bytes_to_encode++);\n    if (i == 3) {\n      char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;\n      char_array_4[1] =\n          ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);\n      char_array_4[2] =\n          ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);\n      char_array_4[3] = char_array_3[2] & 0x3f;\n\n      for (i = 0; (i < 4); i++) ret += base64_chars[char_array_4[i]];\n      i = 0;\n    }\n  }\n\n  if (i) {\n    for (j = i; j < 3; j++) char_array_3[j] = '\\0';\n\n    char_array_4[0] = (char_array_3[0] & 0xfc) >> 2;\n    char_array_4[1] =\n        ((char_array_3[0] & 0x03) << 4) + ((char_array_3[1] & 0xf0) >> 4);\n    char_array_4[2] =\n        ((char_array_3[1] & 0x0f) << 2) + ((char_array_3[2] & 0xc0) >> 6);\n\n    for (j = 0; (j < i + 1); j++) ret += base64_chars[char_array_4[j]];\n\n    while ((i++ < 3)) ret += '=';\n  }\n\n  return ret;\n}\n\nstd::string base64_decode(std::string const &encoded_string) {\n  int in_len = static_cast<int>(encoded_string.size());\n  int i = 0;\n  int j = 0;\n  int in_ = 0;\n  unsigned char char_array_4[4], char_array_3[3];\n  std::string ret;\n\n  const std::string base64_chars =\n      \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n      \"abcdefghijklmnopqrstuvwxyz\"\n      \"0123456789+/\";\n\n  while (in_len-- && (encoded_string[in_] != '=') &&\n         is_base64(encoded_string[in_])) {\n    char_array_4[i++] = encoded_string[in_];\n    in_++;\n    if (i == 4) {\n      for (i = 0; i < 4; i++)\n        char_array_4[i] =\n            static_cast<unsigned char>(base64_chars.find(char_array_4[i]));\n\n      char_array_3[0] =\n          (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);\n      char_array_3[1] =\n          ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);\n      char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];\n\n      for (i = 0; (i < 3); i++) ret += char_array_3[i];\n      i = 0;\n    }\n  }\n\n  if (i) {\n    for (j = i; j < 4; j++) char_array_4[j] = 0;\n\n    for (j = 0; j < 4; j++)\n      char_array_4[j] =\n          static_cast<unsigned char>(base64_chars.find(char_array_4[j]));\n\n    char_array_3[0] = (char_array_4[0] << 2) + ((char_array_4[1] & 0x30) >> 4);\n    char_array_3[1] =\n        ((char_array_4[1] & 0xf) << 4) + ((char_array_4[2] & 0x3c) >> 2);\n    char_array_3[2] = ((char_array_4[2] & 0x3) << 6) + char_array_4[3];\n\n    for (j = 0; (j < i - 1); j++) ret += char_array_3[j];\n  }\n\n  return ret;\n}\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n// https://github.com/syoyo/tinygltf/issues/228\n// TODO(syoyo): Use uriparser https://uriparser.github.io/ for stricter Uri\n// decoding?\n//\n// Uri Decoding from DLIB\n// http://dlib.net/dlib/server/server_http.cpp.html\n// --- dlib begin ------------------------------------------------------------\n// Copyright (C) 2003  Davis E. King (davis@dlib.net)\n// License: Boost Software License\n// Boost Software License - Version 1.0 - August 17th, 2003\n\n// Permission is hereby granted, free of charge, to any person or organization\n// obtaining a copy of the software and accompanying documentation covered by\n// this license (the \"Software\") to use, reproduce, display, distribute,\n// execute, and transmit the Software, and to prepare derivative works of the\n// Software, and to permit third-parties to whom the Software is furnished to\n// do so, all subject to the following:\n// The copyright notices in the Software and this entire statement, including\n// the above license grant, this restriction and the following disclaimer,\n// must be included in all copies of the Software, in whole or in part, and\n// all derivative works of the Software, unless such copies or derivative\n// works are solely in the form of machine-executable object code generated by\n// a source language processor.\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT\n// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE\n// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,\n// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n// DEALINGS IN THE SOFTWARE.\n//\nnamespace dlib {\n\ninline unsigned char from_hex(unsigned char ch) {\n  if (ch <= '9' && ch >= '0')\n    ch -= '0';\n  else if (ch <= 'f' && ch >= 'a')\n    ch -= 'a' - 10;\n  else if (ch <= 'F' && ch >= 'A')\n    ch -= 'A' - 10;\n  else\n    ch = 0;\n  return ch;\n}\n\nstatic const std::string urldecode(const std::string &str) {\n  using namespace std;\n  string result;\n  string::size_type i;\n  for (i = 0; i < str.size(); ++i) {\n    if (str[i] == '+') {\n      result += ' ';\n    } else if (str[i] == '%' && str.size() > i + 2) {\n      const unsigned char ch1 =\n          from_hex(static_cast<unsigned char>(str[i + 1]));\n      const unsigned char ch2 =\n          from_hex(static_cast<unsigned char>(str[i + 2]));\n      const unsigned char ch = static_cast<unsigned char>((ch1 << 4) | ch2);\n      result += static_cast<char>(ch);\n      i += 2;\n    } else {\n      result += str[i];\n    }\n  }\n  return result;\n}\n\n}  // namespace dlib\n// --- dlib end --------------------------------------------------------------\n\nstatic bool LoadExternalFile(std::vector<unsigned char> *out, std::string *err,\n                             std::string *warn, const std::string &filename,\n                             const std::string &basedir, bool required,\n                             size_t reqBytes, bool checkSize, FsCallbacks *fs) {\n  if (fs == nullptr || fs->FileExists == nullptr ||\n      fs->ExpandFilePath == nullptr || fs->ReadWholeFile == nullptr) {\n    // This is a developer error, assert() ?\n    if (err) {\n      (*err) += \"FS callback[s] not set\\n\";\n    }\n    return false;\n  }\n\n  std::string *failMsgOut = required ? err : warn;\n\n  out->clear();\n\n  std::vector<std::string> paths;\n  paths.push_back(basedir);\n  paths.push_back(\".\");\n\n  std::string filepath = FindFile(paths, filename, fs);\n  if (filepath.empty() || filename.empty()) {\n    if (failMsgOut) {\n      (*failMsgOut) += \"File not found : \" + filename + \"\\n\";\n    }\n    return false;\n  }\n\n  std::vector<unsigned char> buf;\n  std::string fileReadErr;\n  bool fileRead =\n      fs->ReadWholeFile(&buf, &fileReadErr, filepath, fs->user_data);\n  if (!fileRead) {\n    if (failMsgOut) {\n      (*failMsgOut) +=\n          \"File read error : \" + filepath + \" : \" + fileReadErr + \"\\n\";\n    }\n    return false;\n  }\n\n  size_t sz = buf.size();\n  if (sz == 0) {\n    if (failMsgOut) {\n      (*failMsgOut) += \"File is empty : \" + filepath + \"\\n\";\n    }\n    return false;\n  }\n\n  if (checkSize) {\n    if (reqBytes == sz) {\n      out->swap(buf);\n      return true;\n    } else {\n      std::stringstream ss;\n      ss << \"File size mismatch : \" << filepath << \", requestedBytes \"\n         << reqBytes << \", but got \" << sz << std::endl;\n      if (failMsgOut) {\n        (*failMsgOut) += ss.str();\n      }\n      return false;\n    }\n  }\n\n  out->swap(buf);\n  return true;\n}\n\nvoid TinyGLTF::SetImageLoader(LoadImageDataFunction func, void *user_data) {\n  LoadImageData = func;\n  load_image_user_data_ = user_data;\n  user_image_loader_ = true;\n}\n\nvoid TinyGLTF::RemoveImageLoader() {\n  LoadImageData =\n#ifndef TINYGLTF_NO_STB_IMAGE\n      &tinygltf::LoadImageData;\n#else\n      nullptr;\n#endif\n\n  load_image_user_data_ = nullptr;\n  user_image_loader_ = false;\n}\n\n#ifndef TINYGLTF_NO_STB_IMAGE\nbool LoadImageData(Image *image, const int image_idx, std::string *err,\n                   std::string *warn, int req_width, int req_height,\n                   const unsigned char *bytes, int size, void *user_data) {\n  (void)warn;\n\n  LoadImageDataOption option;\n  if (user_data) {\n    option = *reinterpret_cast<LoadImageDataOption *>(user_data);\n  }\n\n  int w = 0, h = 0, comp = 0, req_comp = 0;\n\n  unsigned char *data = nullptr;\n\n  // preserve_channels true: Use channels stored in the image file.\n  // false: force 32-bit textures for common Vulkan compatibility. It appears\n  // that some GPU drivers do not support 24-bit images for Vulkan\n  req_comp = option.preserve_channels ? 0 : 4;\n  int bits = 8;\n  int pixel_type = TINYGLTF_COMPONENT_TYPE_UNSIGNED_BYTE;\n\n  // It is possible that the image we want to load is a 16bit per channel image\n  // We are going to attempt to load it as 16bit per channel, and if it worked,\n  // set the image data accodingly. We are casting the returned pointer into\n  // unsigned char, because we are representing \"bytes\". But we are updating\n  // the Image metadata to signal that this image uses 2 bytes (16bits) per\n  // channel:\n  if (stbi_is_16_bit_from_memory(bytes, size)) {\n    data = reinterpret_cast<unsigned char *>(\n        stbi_load_16_from_memory(bytes, size, &w, &h, &comp, req_comp));\n    if (data) {\n      bits = 16;\n      pixel_type = TINYGLTF_COMPONENT_TYPE_UNSIGNED_SHORT;\n    }\n  }\n\n  // at this point, if data is still NULL, it means that the image wasn't\n  // 16bit per channel, we are going to load it as a normal 8bit per channel\n  // mage as we used to do:\n  // if image cannot be decoded, ignore parsing and keep it by its path\n  // don't break in this case\n  // FIXME we should only enter this function if the image is embedded. If\n  // image->uri references\n  // an image file, it should be left as it is. Image loading should not be\n  // mandatory (to support other formats)\n  if (!data) data = stbi_load_from_memory(bytes, size, &w, &h, &comp, req_comp);\n  if (!data) {\n    // NOTE: you can use `warn` instead of `err`\n    if (err) {\n      (*err) +=\n          \"Unknown image format. STB cannot decode image data for image[\" +\n          std::to_string(image_idx) + \"] name = \\\"\" + image->name + \"\\\".\\n\";\n    }\n    return false;\n  }\n\n  if ((w < 1) || (h < 1)) {\n    stbi_image_free(data);\n    if (err) {\n      (*err) += \"Invalid image data for image[\" + std::to_string(image_idx) +\n                \"] name = \\\"\" + image->name + \"\\\"\\n\";\n    }\n    return false;\n  }\n\n  if (req_width > 0) {\n    if (req_width != w) {\n      stbi_image_free(data);\n      if (err) {\n        (*err) += \"Image width mismatch for image[\" +\n                  std::to_string(image_idx) + \"] name = \\\"\" + image->name +\n                  \"\\\"\\n\";\n      }\n      return false;\n    }\n  }\n\n  if (req_height > 0) {\n    if (req_height != h) {\n      stbi_image_free(data);\n      if (err) {\n        (*err) += \"Image height mismatch. for image[\" +\n                  std::to_string(image_idx) + \"] name = \\\"\" + image->name +\n                  \"\\\"\\n\";\n      }\n      return false;\n    }\n  }\n\n  if (req_comp != 0) {\n    // loaded data has `req_comp` channels(components)\n    comp = req_comp;\n  }\n\n  image->width = w;\n  image->height = h;\n  image->component = comp;\n  image->bits = bits;\n  image->pixel_type = pixel_type;\n  image->image.resize(static_cast<size_t>(w * h * comp) * size_t(bits / 8));\n  std::copy(data, data + w * h * comp * (bits / 8), image->image.begin());\n  stbi_image_free(data);\n\n  return true;\n}\n#endif\n\nvoid TinyGLTF::SetImageWriter(WriteImageDataFunction func, void *user_data) {\n  WriteImageData = func;\n  write_image_user_data_ = user_data;\n}\n\n#ifndef TINYGLTF_NO_STB_IMAGE_WRITE\nstatic void WriteToMemory_stbi(void *context, void *data, int size) {\n  std::vector<unsigned char> *buffer =\n      reinterpret_cast<std::vector<unsigned char> *>(context);\n\n  unsigned char *pData = reinterpret_cast<unsigned char *>(data);\n\n  buffer->insert(buffer->end(), pData, pData + size);\n}\n\nbool WriteImageData(const std::string *basepath, const std::string *filename,\n                    Image *image, bool embedImages, void *fsPtr) {\n  const std::string ext = GetFilePathExtension(*filename);\n\n  // Write image to temporary buffer\n  std::string header;\n  std::vector<unsigned char> data;\n\n  if (ext == \"png\") {\n    if ((image->bits != 8) ||\n        (image->pixel_type != TINYGLTF_COMPONENT_TYPE_UNSIGNED_BYTE)) {\n      // Unsupported pixel format\n      return false;\n    }\n\n    if (!stbi_write_png_to_func(WriteToMemory_stbi, &data, image->width,\n                                image->height, image->component,\n                                &image->image[0], 0)) {\n      return false;\n    }\n    header = \"data:image/png;base64,\";\n  } else if (ext == \"jpg\") {\n    if (!stbi_write_jpg_to_func(WriteToMemory_stbi, &data, image->width,\n                                image->height, image->component,\n                                &image->image[0], 100)) {\n      return false;\n    }\n    header = \"data:image/jpeg;base64,\";\n  } else if (ext == \"bmp\") {\n    if (!stbi_write_bmp_to_func(WriteToMemory_stbi, &data, image->width,\n                                image->height, image->component,\n                                &image->image[0])) {\n      return false;\n    }\n    header = \"data:image/bmp;base64,\";\n  } else if (!embedImages) {\n    // Error: can't output requested format to file\n    return false;\n  }\n\n  if (embedImages) {\n    // Embed base64-encoded image into URI\n    if (data.size()) {\n      image->uri =\n          header +\n          base64_encode(&data[0], static_cast<unsigned int>(data.size()));\n    } else {\n      // Throw error?\n    }\n  } else {\n    // Write image to disc\n    FsCallbacks *fs = reinterpret_cast<FsCallbacks *>(fsPtr);\n    if ((fs != nullptr) && (fs->WriteWholeFile != nullptr)) {\n      const std::string imagefilepath = JoinPath(*basepath, *filename);\n      std::string writeError;\n      if (!fs->WriteWholeFile(&writeError, imagefilepath, data,\n                              fs->user_data)) {\n        // Could not write image file to disc; Throw error ?\n        return false;\n      }\n    } else {\n      // Throw error?\n    }\n    image->uri = *filename;\n  }\n\n  return true;\n}\n#endif\n\nvoid TinyGLTF::SetFsCallbacks(FsCallbacks callbacks) { fs = callbacks; }\n\n#ifdef _WIN32\nstatic inline std::wstring UTF8ToWchar(const std::string &str) {\n  int wstr_size =\n      MultiByteToWideChar(CP_UTF8, 0, str.data(), (int)str.size(), nullptr, 0);\n  std::wstring wstr(wstr_size, 0);\n  MultiByteToWideChar(CP_UTF8, 0, str.data(), (int)str.size(), &wstr[0],\n                      (int)wstr.size());\n  return wstr;\n}\n\nstatic inline std::string WcharToUTF8(const std::wstring &wstr) {\n  int str_size = WideCharToMultiByte(CP_UTF8, 0, wstr.data(), (int)wstr.size(),\n                                     nullptr, 0, NULL, NULL);\n  std::string str(str_size, 0);\n  WideCharToMultiByte(CP_UTF8, 0, wstr.data(), (int)wstr.size(), &str[0],\n                      (int)str.size(), NULL, NULL);\n  return str;\n}\n#endif\n\n#ifndef TINYGLTF_NO_FS\n// Default implementations of filesystem functions\n\nbool FileExists(const std::string &abs_filename, void *) {\n  bool ret;\n#ifdef TINYGLTF_ANDROID_LOAD_FROM_ASSETS\n  if (asset_manager) {\n    AAsset *asset = AAssetManager_open(asset_manager, abs_filename.c_str(),\n                                       AASSET_MODE_STREAMING);\n    if (!asset) {\n      return false;\n    }\n    AAsset_close(asset);\n    ret = true;\n  } else {\n    return false;\n  }\n#else\n#ifdef _WIN32\n#if defined(_MSC_VER) || defined(__GLIBCXX__)\n  FILE *fp = nullptr;\n  errno_t err = _wfopen_s(&fp, UTF8ToWchar(abs_filename).c_str(), L\"rb\");\n  if (err != 0) {\n    return false;\n  }\n#else\n  FILE *fp = nullptr;\n  errno_t err = fopen_s(&fp, abs_filename.c_str(), \"rb\");\n  if (err != 0) {\n    return false;\n  }\n#endif\n\n#else\n  FILE *fp = fopen(abs_filename.c_str(), \"rb\");\n#endif\n  if (fp) {\n    ret = true;\n    fclose(fp);\n  } else {\n    ret = false;\n  }\n#endif\n\n  return ret;\n}\n\nstd::string ExpandFilePath(const std::string &filepath, void *) {\n  // https://github.com/syoyo/tinygltf/issues/368\n  //\n  // No file path expansion in built-in FS function anymore, since glTF URI\n  // should not contain tilde('~') and environment variables, and for security\n  // reason(`wordexp`).\n  //\n  // Users need to supply `base_dir`(in `LoadASCIIFromString`,\n  // `LoadBinaryFromMemory`) in expanded absolute path.\n\n  return filepath;\n\n#if 0\n#ifdef _WIN32\n  // Assume input `filepath` is encoded in UTF-8\n  std::wstring wfilepath = UTF8ToWchar(filepath);\n  DWORD wlen = ExpandEnvironmentStringsW(wfilepath.c_str(), nullptr, 0);\n  wchar_t *wstr = new wchar_t[wlen];\n  ExpandEnvironmentStringsW(wfilepath.c_str(), wstr, wlen);\n\n  std::wstring ws(wstr);\n  delete[] wstr;\n  return WcharToUTF8(ws);\n\n#else\n\n#if defined(TARGET_OS_IPHONE) || defined(TARGET_IPHONE_SIMULATOR) || \\\n    defined(__ANDROID__) || defined(__EMSCRIPTEN__) || defined(__OpenBSD__)\n  // no expansion\n  std::string s = filepath;\n#else\n  std::string s;\n  wordexp_t p;\n\n  if (filepath.empty()) {\n    return \"\";\n  }\n\n  // Quote the string to keep any spaces in filepath intact.\n  std::string quoted_path = \"\\\"\" + filepath + \"\\\"\";\n  // char** w;\n  int ret = wordexp(quoted_path.c_str(), &p, 0);\n  if (ret) {\n    // err\n    s = filepath;\n    return s;\n  }\n\n  // Use first element only.\n  if (p.we_wordv) {\n    s = std::string(p.we_wordv[0]);\n    wordfree(&p);\n  } else {\n    s = filepath;\n  }\n\n#endif\n\n  return s;\n#endif\n#endif\n}\n\nbool ReadWholeFile(std::vector<unsigned char> *out, std::string *err,\n                   const std::string &filepath, void *) {\n#ifdef TINYGLTF_ANDROID_LOAD_FROM_ASSETS\n  if (asset_manager) {\n    AAsset *asset = AAssetManager_open(asset_manager, filepath.c_str(),\n                                       AASSET_MODE_STREAMING);\n    if (!asset) {\n      if (err) {\n        (*err) += \"File open error : \" + filepath + \"\\n\";\n      }\n      return false;\n    }\n    size_t size = AAsset_getLength(asset);\n    if (size == 0) {\n      if (err) {\n        (*err) += \"Invalid file size : \" + filepath +\n                  \" (does the path point to a directory?)\";\n      }\n      return false;\n    }\n    out->resize(size);\n    AAsset_read(asset, reinterpret_cast<char *>(&out->at(0)), size);\n    AAsset_close(asset);\n    return true;\n  } else {\n    if (err) {\n      (*err) += \"No asset manager specified : \" + filepath + \"\\n\";\n    }\n    return false;\n  }\n#else\n#ifdef _WIN32\n#if defined(__GLIBCXX__)  // mingw\n  int file_descriptor =\n      _wopen(UTF8ToWchar(filepath).c_str(), _O_RDONLY | _O_BINARY);\n  __gnu_cxx::stdio_filebuf<char> wfile_buf(file_descriptor, std::ios_base::in);\n  std::istream f(&wfile_buf);\n#elif defined(_MSC_VER) || defined(_LIBCPP_VERSION)\n  // For libcxx, assume _LIBCPP_HAS_OPEN_WITH_WCHAR is defined to accept\n  // `wchar_t *`\n  std::ifstream f(UTF8ToWchar(filepath).c_str(), std::ifstream::binary);\n#else\n  // Unknown compiler/runtime\n  std::ifstream f(filepath.c_str(), std::ifstream::binary);\n#endif\n#else\n  std::ifstream f(filepath.c_str(), std::ifstream::binary);\n#endif\n  if (!f) {\n    if (err) {\n      (*err) += \"File open error : \" + filepath + \"\\n\";\n    }\n    return false;\n  }\n\n  f.seekg(0, f.end);\n  size_t sz = static_cast<size_t>(f.tellg());\n  f.seekg(0, f.beg);\n\n  if (int64_t(sz) < 0) {\n    if (err) {\n      (*err) += \"Invalid file size : \" + filepath +\n                \" (does the path point to a directory?)\";\n    }\n    return false;\n  } else if (sz == 0) {\n    if (err) {\n      (*err) += \"File is empty : \" + filepath + \"\\n\";\n    }\n    return false;\n  }\n\n  out->resize(sz);\n  f.read(reinterpret_cast<char *>(&out->at(0)),\n         static_cast<std::streamsize>(sz));\n\n  return true;\n#endif\n}\n\nbool WriteWholeFile(std::string *err, const std::string &filepath,\n                    const std::vector<unsigned char> &contents, void *) {\n#ifdef _WIN32\n#if defined(__GLIBCXX__)  // mingw\n  int file_descriptor = _wopen(UTF8ToWchar(filepath).c_str(),\n                               _O_CREAT | _O_WRONLY | _O_TRUNC | _O_BINARY);\n  __gnu_cxx::stdio_filebuf<char> wfile_buf(\n      file_descriptor, std::ios_base::out | std::ios_base::binary);\n  std::ostream f(&wfile_buf);\n#elif defined(_MSC_VER)\n  std::ofstream f(UTF8ToWchar(filepath).c_str(), std::ofstream::binary);\n#else  // clang?\n  std::ofstream f(filepath.c_str(), std::ofstream::binary);\n#endif\n#else\n  std::ofstream f(filepath.c_str(), std::ofstream::binary);\n#endif\n  if (!f) {\n    if (err) {\n      (*err) += \"File open error for writing : \" + filepath + \"\\n\";\n    }\n    return false;\n  }\n\n  f.write(reinterpret_cast<const char *>(&contents.at(0)),\n          static_cast<std::streamsize>(contents.size()));\n  if (!f) {\n    if (err) {\n      (*err) += \"File write error: \" + filepath + \"\\n\";\n    }\n    return false;\n  }\n\n  return true;\n}\n\n#endif  // TINYGLTF_NO_FS\n\nstatic std::string MimeToExt(const std::string &mimeType) {\n  if (mimeType == \"image/jpeg\") {\n    return \"jpg\";\n  } else if (mimeType == \"image/png\") {\n    return \"png\";\n  } else if (mimeType == \"image/bmp\") {\n    return \"bmp\";\n  } else if (mimeType == \"image/gif\") {\n    return \"gif\";\n  }\n\n  return \"\";\n}\n\nstatic void UpdateImageObject(Image &image, std::string &baseDir, int index,\n                              bool embedImages,\n                              WriteImageDataFunction *WriteImageData = nullptr,\n                              void *user_data = nullptr) {\n  std::string filename;\n  std::string ext;\n  // If image has uri, use it it as a filename\n  if (image.uri.size()) {\n    filename = GetBaseFilename(image.uri);\n    ext = GetFilePathExtension(filename);\n  } else if (image.bufferView != -1) {\n    // If there's no URI and the data exists in a buffer,\n    // don't change properties or write images\n  } else if (image.name.size()) {\n    ext = MimeToExt(image.mimeType);\n    // Otherwise use name as filename\n    filename = image.name + \".\" + ext;\n  } else {\n    ext = MimeToExt(image.mimeType);\n    // Fallback to index of image as filename\n    filename = std::to_string(index) + \".\" + ext;\n  }\n\n  // If callback is set, modify image data object\n  if (*WriteImageData != nullptr && !filename.empty()) {\n    std::string uri;\n    (*WriteImageData)(&baseDir, &filename, &image, embedImages, user_data);\n  }\n}\n\nbool IsDataURI(const std::string &in) {\n  std::string header = \"data:application/octet-stream;base64,\";\n  if (in.find(header) == 0) {\n    return true;\n  }\n\n  header = \"data:image/jpeg;base64,\";\n  if (in.find(header) == 0) {\n    return true;\n  }\n\n  header = \"data:image/png;base64,\";\n  if (in.find(header) == 0) {\n    return true;\n  }\n\n  header = \"data:image/bmp;base64,\";\n  if (in.find(header) == 0) {\n    return true;\n  }\n\n  header = \"data:image/gif;base64,\";\n  if (in.find(header) == 0) {\n    return true;\n  }\n\n  header = \"data:text/plain;base64,\";\n  if (in.find(header) == 0) {\n    return true;\n  }\n\n  header = \"data:application/gltf-buffer;base64,\";\n  if (in.find(header) == 0) {\n    return true;\n  }\n\n  return false;\n}\n\nbool DecodeDataURI(std::vector<unsigned char> *out, std::string &mime_type,\n                   const std::string &in, size_t reqBytes, bool checkSize) {\n  std::string header = \"data:application/octet-stream;base64,\";\n  std::string data;\n  if (in.find(header) == 0) {\n    data = base64_decode(in.substr(header.size()));  // cut mime string.\n  }\n\n  if (data.empty()) {\n    header = \"data:image/jpeg;base64,\";\n    if (in.find(header) == 0) {\n      mime_type = \"image/jpeg\";\n      data = base64_decode(in.substr(header.size()));  // cut mime string.\n    }\n  }\n\n  if (data.empty()) {\n    header = \"data:image/png;base64,\";\n    if (in.find(header) == 0) {\n      mime_type = \"image/png\";\n      data = base64_decode(in.substr(header.size()));  // cut mime string.\n    }\n  }\n\n  if (data.empty()) {\n    header = \"data:image/bmp;base64,\";\n    if (in.find(header) == 0) {\n      mime_type = \"image/bmp\";\n      data = base64_decode(in.substr(header.size()));  // cut mime string.\n    }\n  }\n\n  if (data.empty()) {\n    header = \"data:image/gif;base64,\";\n    if (in.find(header) == 0) {\n      mime_type = \"image/gif\";\n      data = base64_decode(in.substr(header.size()));  // cut mime string.\n    }\n  }\n\n  if (data.empty()) {\n    header = \"data:text/plain;base64,\";\n    if (in.find(header) == 0) {\n      mime_type = \"text/plain\";\n      data = base64_decode(in.substr(header.size()));\n    }\n  }\n\n  if (data.empty()) {\n    header = \"data:application/gltf-buffer;base64,\";\n    if (in.find(header) == 0) {\n      data = base64_decode(in.substr(header.size()));\n    }\n  }\n\n  // TODO(syoyo): Allow empty buffer? #229\n  if (data.empty()) {\n    return false;\n  }\n\n  if (checkSize) {\n    if (data.size() != reqBytes) {\n      return false;\n    }\n    out->resize(reqBytes);\n  } else {\n    out->resize(data.size());\n  }\n  std::copy(data.begin(), data.end(), out->begin());\n  return true;\n}\n\nnamespace {\nbool GetInt(const json &o, int &val) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  if (!o.IsDouble()) {\n    if (o.IsInt()) {\n      val = o.GetInt();\n      return true;\n    } else if (o.IsUint()) {\n      val = static_cast<int>(o.GetUint());\n      return true;\n    } else if (o.IsInt64()) {\n      val = static_cast<int>(o.GetInt64());\n      return true;\n    } else if (o.IsUint64()) {\n      val = static_cast<int>(o.GetUint64());\n      return true;\n    }\n  }\n\n  return false;\n#else\n  auto type = o.type();\n\n  if ((type == json::value_t::number_integer) ||\n      (type == json::value_t::number_unsigned)) {\n    val = static_cast<int>(o.get<int64_t>());\n    return true;\n  }\n\n  return false;\n#endif\n}\n\n#ifdef TINYGLTF_USE_RAPIDJSON\nbool GetDouble(const json &o, double &val) {\n  if (o.IsDouble()) {\n    val = o.GetDouble();\n    return true;\n  }\n\n  return false;\n}\n#endif\n\nbool GetNumber(const json &o, double &val) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  if (o.IsNumber()) {\n    val = o.GetDouble();\n    return true;\n  }\n\n  return false;\n#else\n  if (o.is_number()) {\n    val = o.get<double>();\n    return true;\n  }\n\n  return false;\n#endif\n}\n\nbool GetString(const json &o, std::string &val) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  if (o.IsString()) {\n    val = o.GetString();\n    return true;\n  }\n\n  return false;\n#else\n  if (o.type() == json::value_t::string) {\n    val = o.get<std::string>();\n    return true;\n  }\n\n  return false;\n#endif\n}\n\nbool IsArray(const json &o) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  return o.IsArray();\n#else\n  return o.is_array();\n#endif\n}\n\njson_const_array_iterator ArrayBegin(const json &o) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  return o.Begin();\n#else\n  return o.begin();\n#endif\n}\n\njson_const_array_iterator ArrayEnd(const json &o) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  return o.End();\n#else\n  return o.end();\n#endif\n}\n\nbool IsObject(const json &o) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  return o.IsObject();\n#else\n  return o.is_object();\n#endif\n}\n\njson_const_iterator ObjectBegin(const json &o) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  return o.MemberBegin();\n#else\n  return o.begin();\n#endif\n}\n\njson_const_iterator ObjectEnd(const json &o) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  return o.MemberEnd();\n#else\n  return o.end();\n#endif\n}\n\n// Making this a const char* results in a pointer to a temporary when\n// TINYGLTF_USE_RAPIDJSON is off.\nstd::string GetKey(json_const_iterator &it) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  return it->name.GetString();\n#else\n  return it.key().c_str();\n#endif\n}\n\nbool FindMember(const json &o, const char *member, json_const_iterator &it) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  if (!o.IsObject()) {\n    return false;\n  }\n  it = o.FindMember(member);\n  return it != o.MemberEnd();\n#else\n  it = o.find(member);\n  return it != o.end();\n#endif\n}\n\nconst json &GetValue(json_const_iterator &it) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  return it->value;\n#else\n  return it.value();\n#endif\n}\n\nstd::string JsonToString(const json &o, int spacing = -1) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  using namespace rapidjson;\n  StringBuffer buffer;\n  if (spacing == -1) {\n    Writer<StringBuffer> writer(buffer);\n    // TODO: Better error handling.\n    // https://github.com/syoyo/tinygltf/issues/332\n    if (!o.Accept(writer)) {\n      return \"tiny_gltf::JsonToString() failed rapidjson conversion\";\n    }\n  } else {\n    PrettyWriter<StringBuffer> writer(buffer);\n    writer.SetIndent(' ', uint32_t(spacing));\n    if (!o.Accept(writer)) {\n      return \"tiny_gltf::JsonToString() failed rapidjson conversion\";\n    }\n  }\n  return buffer.GetString();\n#else\n  return o.dump(spacing);\n#endif\n}\n\n}  // namespace\n\nstatic bool ParseJsonAsValue(Value *ret, const json &o) {\n  Value val{};\n#ifdef TINYGLTF_USE_RAPIDJSON\n  using rapidjson::Type;\n  switch (o.GetType()) {\n    case Type::kObjectType: {\n      Value::Object value_object;\n      for (auto it = o.MemberBegin(); it != o.MemberEnd(); ++it) {\n        Value entry;\n        ParseJsonAsValue(&entry, it->value);\n        if (entry.Type() != NULL_TYPE)\n          value_object.emplace(GetKey(it), std::move(entry));\n      }\n      if (value_object.size() > 0) val = Value(std::move(value_object));\n    } break;\n    case Type::kArrayType: {\n      Value::Array value_array;\n      value_array.reserve(o.Size());\n      for (auto it = o.Begin(); it != o.End(); ++it) {\n        Value entry;\n        ParseJsonAsValue(&entry, *it);\n        if (entry.Type() != NULL_TYPE)\n          value_array.emplace_back(std::move(entry));\n      }\n      if (value_array.size() > 0) val = Value(std::move(value_array));\n    } break;\n    case Type::kStringType:\n      val = Value(std::string(o.GetString()));\n      break;\n    case Type::kFalseType:\n    case Type::kTrueType:\n      val = Value(o.GetBool());\n      break;\n    case Type::kNumberType:\n      if (!o.IsDouble()) {\n        int i = 0;\n        GetInt(o, i);\n        val = Value(i);\n      } else {\n        double d = 0.0;\n        GetDouble(o, d);\n        val = Value(d);\n      }\n      break;\n    case Type::kNullType:\n      break;\n      // all types are covered, so no `case default`\n  }\n#else\n  switch (o.type()) {\n    case json::value_t::object: {\n      Value::Object value_object;\n      for (auto it = o.begin(); it != o.end(); it++) {\n        Value entry;\n        ParseJsonAsValue(&entry, it.value());\n        if (entry.Type() != NULL_TYPE)\n          value_object.emplace(it.key(), std::move(entry));\n      }\n      if (value_object.size() > 0) val = Value(std::move(value_object));\n    } break;\n    case json::value_t::array: {\n      Value::Array value_array;\n      value_array.reserve(o.size());\n      for (auto it = o.begin(); it != o.end(); it++) {\n        Value entry;\n        ParseJsonAsValue(&entry, it.value());\n        if (entry.Type() != NULL_TYPE)\n          value_array.emplace_back(std::move(entry));\n      }\n      if (value_array.size() > 0) val = Value(std::move(value_array));\n    } break;\n    case json::value_t::string:\n      val = Value(o.get<std::string>());\n      break;\n    case json::value_t::boolean:\n      val = Value(o.get<bool>());\n      break;\n    case json::value_t::number_integer:\n    case json::value_t::number_unsigned:\n      val = Value(static_cast<int>(o.get<int64_t>()));\n      break;\n    case json::value_t::number_float:\n      val = Value(o.get<double>());\n      break;\n    case json::value_t::null:\n    case json::value_t::discarded:\n    case json::value_t::binary:\n      // default:\n      break;\n  }\n#endif\n  if (ret) *ret = std::move(val);\n\n  return val.Type() != NULL_TYPE;\n}\n\nstatic bool ParseExtrasProperty(Value *ret, const json &o) {\n  json_const_iterator it;\n  if (!FindMember(o, \"extras\", it)) {\n    return false;\n  }\n\n  return ParseJsonAsValue(ret, GetValue(it));\n}\n\nstatic bool ParseBooleanProperty(bool *ret, std::string *err, const json &o,\n                                 const std::string &property,\n                                 const bool required,\n                                 const std::string &parent_node = \"\") {\n  json_const_iterator it;\n  if (!FindMember(o, property.c_str(), it)) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is missing\";\n        if (!parent_node.empty()) {\n          (*err) += \" in \" + parent_node;\n        }\n        (*err) += \".\\n\";\n      }\n    }\n    return false;\n  }\n\n  auto &value = GetValue(it);\n\n  bool isBoolean;\n  bool boolValue = false;\n#ifdef TINYGLTF_USE_RAPIDJSON\n  isBoolean = value.IsBool();\n  if (isBoolean) {\n    boolValue = value.GetBool();\n  }\n#else\n  isBoolean = value.is_boolean();\n  if (isBoolean) {\n    boolValue = value.get<bool>();\n  }\n#endif\n  if (!isBoolean) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is not a bool type.\\n\";\n      }\n    }\n    return false;\n  }\n\n  if (ret) {\n    (*ret) = boolValue;\n  }\n\n  return true;\n}\n\nstatic bool ParseIntegerProperty(int *ret, std::string *err, const json &o,\n                                 const std::string &property,\n                                 const bool required,\n                                 const std::string &parent_node = \"\") {\n  json_const_iterator it;\n  if (!FindMember(o, property.c_str(), it)) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is missing\";\n        if (!parent_node.empty()) {\n          (*err) += \" in \" + parent_node;\n        }\n        (*err) += \".\\n\";\n      }\n    }\n    return false;\n  }\n\n  int intValue;\n  bool isInt = GetInt(GetValue(it), intValue);\n  if (!isInt) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is not an integer type.\\n\";\n      }\n    }\n    return false;\n  }\n\n  if (ret) {\n    (*ret) = intValue;\n  }\n\n  return true;\n}\n\nstatic bool ParseUnsignedProperty(size_t *ret, std::string *err, const json &o,\n                                  const std::string &property,\n                                  const bool required,\n                                  const std::string &parent_node = \"\") {\n  json_const_iterator it;\n  if (!FindMember(o, property.c_str(), it)) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is missing\";\n        if (!parent_node.empty()) {\n          (*err) += \" in \" + parent_node;\n        }\n        (*err) += \".\\n\";\n      }\n    }\n    return false;\n  }\n\n  auto &value = GetValue(it);\n\n  size_t uValue = 0;\n  bool isUValue;\n#ifdef TINYGLTF_USE_RAPIDJSON\n  isUValue = false;\n  if (value.IsUint()) {\n    uValue = value.GetUint();\n    isUValue = true;\n  } else if (value.IsUint64()) {\n    uValue = value.GetUint64();\n    isUValue = true;\n  }\n#else\n  isUValue = value.is_number_unsigned();\n  if (isUValue) {\n    uValue = value.get<size_t>();\n  }\n#endif\n  if (!isUValue) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is not a positive integer.\\n\";\n      }\n    }\n    return false;\n  }\n\n  if (ret) {\n    (*ret) = uValue;\n  }\n\n  return true;\n}\n\nstatic bool ParseNumberProperty(double *ret, std::string *err, const json &o,\n                                const std::string &property,\n                                const bool required,\n                                const std::string &parent_node = \"\") {\n  json_const_iterator it;\n\n  if (!FindMember(o, property.c_str(), it)) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is missing\";\n        if (!parent_node.empty()) {\n          (*err) += \" in \" + parent_node;\n        }\n        (*err) += \".\\n\";\n      }\n    }\n    return false;\n  }\n\n  double numberValue;\n  bool isNumber = GetNumber(GetValue(it), numberValue);\n\n  if (!isNumber) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is not a number type.\\n\";\n      }\n    }\n    return false;\n  }\n\n  if (ret) {\n    (*ret) = numberValue;\n  }\n\n  return true;\n}\n\nstatic bool ParseNumberArrayProperty(std::vector<double> *ret, std::string *err,\n                                     const json &o, const std::string &property,\n                                     bool required,\n                                     const std::string &parent_node = \"\") {\n  json_const_iterator it;\n  if (!FindMember(o, property.c_str(), it)) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is missing\";\n        if (!parent_node.empty()) {\n          (*err) += \" in \" + parent_node;\n        }\n        (*err) += \".\\n\";\n      }\n    }\n    return false;\n  }\n\n  if (!IsArray(GetValue(it))) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is not an array\";\n        if (!parent_node.empty()) {\n          (*err) += \" in \" + parent_node;\n        }\n        (*err) += \".\\n\";\n      }\n    }\n    return false;\n  }\n\n  ret->clear();\n  auto end = ArrayEnd(GetValue(it));\n  for (auto i = ArrayBegin(GetValue(it)); i != end; ++i) {\n    double numberValue;\n    const bool isNumber = GetNumber(*i, numberValue);\n    if (!isNumber) {\n      if (required) {\n        if (err) {\n          (*err) += \"'\" + property + \"' property is not a number.\\n\";\n          if (!parent_node.empty()) {\n            (*err) += \" in \" + parent_node;\n          }\n          (*err) += \".\\n\";\n        }\n      }\n      return false;\n    }\n    ret->push_back(numberValue);\n  }\n\n  return true;\n}\n\nstatic bool ParseIntegerArrayProperty(std::vector<int> *ret, std::string *err,\n                                      const json &o,\n                                      const std::string &property,\n                                      bool required,\n                                      const std::string &parent_node = \"\") {\n  json_const_iterator it;\n  if (!FindMember(o, property.c_str(), it)) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is missing\";\n        if (!parent_node.empty()) {\n          (*err) += \" in \" + parent_node;\n        }\n        (*err) += \".\\n\";\n      }\n    }\n    return false;\n  }\n\n  if (!IsArray(GetValue(it))) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is not an array\";\n        if (!parent_node.empty()) {\n          (*err) += \" in \" + parent_node;\n        }\n        (*err) += \".\\n\";\n      }\n    }\n    return false;\n  }\n\n  ret->clear();\n  auto end = ArrayEnd(GetValue(it));\n  for (auto i = ArrayBegin(GetValue(it)); i != end; ++i) {\n    int numberValue;\n    bool isNumber = GetInt(*i, numberValue);\n    if (!isNumber) {\n      if (required) {\n        if (err) {\n          (*err) += \"'\" + property + \"' property is not an integer type.\\n\";\n          if (!parent_node.empty()) {\n            (*err) += \" in \" + parent_node;\n          }\n          (*err) += \".\\n\";\n        }\n      }\n      return false;\n    }\n    ret->push_back(numberValue);\n  }\n\n  return true;\n}\n\nstatic bool ParseStringProperty(\n    std::string *ret, std::string *err, const json &o,\n    const std::string &property, bool required,\n    const std::string &parent_node = std::string()) {\n  json_const_iterator it;\n  if (!FindMember(o, property.c_str(), it)) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is missing\";\n        if (parent_node.empty()) {\n          (*err) += \".\\n\";\n        } else {\n          (*err) += \" in `\" + parent_node + \"'.\\n\";\n        }\n      }\n    }\n    return false;\n  }\n\n  std::string strValue;\n  if (!GetString(GetValue(it), strValue)) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is not a string type.\\n\";\n      }\n    }\n    return false;\n  }\n\n  if (ret) {\n    (*ret) = std::move(strValue);\n  }\n\n  return true;\n}\n\nstatic bool ParseStringIntegerProperty(std::map<std::string, int> *ret,\n                                       std::string *err, const json &o,\n                                       const std::string &property,\n                                       bool required,\n                                       const std::string &parent = \"\") {\n  json_const_iterator it;\n  if (!FindMember(o, property.c_str(), it)) {\n    if (required) {\n      if (err) {\n        if (!parent.empty()) {\n          (*err) +=\n              \"'\" + property + \"' property is missing in \" + parent + \".\\n\";\n        } else {\n          (*err) += \"'\" + property + \"' property is missing.\\n\";\n        }\n      }\n    }\n    return false;\n  }\n\n  const json &dict = GetValue(it);\n\n  // Make sure we are dealing with an object / dictionary.\n  if (!IsObject(dict)) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is not an object.\\n\";\n      }\n    }\n    return false;\n  }\n\n  ret->clear();\n\n  json_const_iterator dictIt(ObjectBegin(dict));\n  json_const_iterator dictItEnd(ObjectEnd(dict));\n\n  for (; dictIt != dictItEnd; ++dictIt) {\n    int intVal;\n    if (!GetInt(GetValue(dictIt), intVal)) {\n      if (required) {\n        if (err) {\n          (*err) += \"'\" + property + \"' value is not an integer type.\\n\";\n        }\n      }\n      return false;\n    }\n\n    // Insert into the list.\n    (*ret)[GetKey(dictIt)] = intVal;\n  }\n  return true;\n}\n\nstatic bool ParseJSONProperty(std::map<std::string, double> *ret,\n                              std::string *err, const json &o,\n                              const std::string &property, bool required) {\n  json_const_iterator it;\n  if (!FindMember(o, property.c_str(), it)) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is missing. \\n'\";\n      }\n    }\n    return false;\n  }\n\n  const json &obj = GetValue(it);\n\n  if (!IsObject(obj)) {\n    if (required) {\n      if (err) {\n        (*err) += \"'\" + property + \"' property is not a JSON object.\\n\";\n      }\n    }\n    return false;\n  }\n\n  ret->clear();\n\n  json_const_iterator it2(ObjectBegin(obj));\n  json_const_iterator itEnd(ObjectEnd(obj));\n  for (; it2 != itEnd; ++it2) {\n    double numVal;\n    if (GetNumber(GetValue(it2), numVal))\n      ret->emplace(std::string(GetKey(it2)), numVal);\n  }\n\n  return true;\n}\n\nstatic bool ParseParameterProperty(Parameter *param, std::string *err,\n                                   const json &o, const std::string &prop,\n                                   bool required) {\n  // A parameter value can either be a string or an array of either a boolean or\n  // a number. Booleans of any kind aren't supported here. Granted, it\n  // complicates the Parameter structure and breaks it semantically in the sense\n  // that the client probably works off the assumption that if the string is\n  // empty the vector is used, etc. Would a tagged union work?\n  if (ParseStringProperty(&param->string_value, err, o, prop, false)) {\n    // Found string property.\n    return true;\n  } else if (ParseNumberArrayProperty(&param->number_array, err, o, prop,\n                                      false)) {\n    // Found a number array.\n    return true;\n  } else if (ParseNumberProperty(&param->number_value, err, o, prop, false)) {\n    return param->has_number_value = true;\n  } else if (ParseJSONProperty(&param->json_double_value, err, o, prop,\n                               false)) {\n    return true;\n  } else if (ParseBooleanProperty(&param->bool_value, err, o, prop, false)) {\n    return true;\n  } else {\n    if (required) {\n      if (err) {\n        (*err) += \"parameter must be a string or number / number array.\\n\";\n      }\n    }\n    return false;\n  }\n}\n\nstatic bool ParseExtensionsProperty(ExtensionMap *ret, std::string *err,\n                                    const json &o) {\n  (void)err;\n\n  json_const_iterator it;\n  if (!FindMember(o, \"extensions\", it)) {\n    return false;\n  }\n\n  auto &obj = GetValue(it);\n  if (!IsObject(obj)) {\n    return false;\n  }\n  ExtensionMap extensions;\n  json_const_iterator extIt = ObjectBegin(obj);  // it.value().begin();\n  json_const_iterator extEnd = ObjectEnd(obj);\n  for (; extIt != extEnd; ++extIt) {\n    auto &itObj = GetValue(extIt);\n    if (!IsObject(itObj)) continue;\n    std::string key(GetKey(extIt));\n    if (!ParseJsonAsValue(&extensions[key], itObj)) {\n      if (!key.empty()) {\n        // create empty object so that an extension object is still of type\n        // object\n        extensions[key] = Value{Value::Object{}};\n      }\n    }\n  }\n  if (ret) {\n    (*ret) = std::move(extensions);\n  }\n  return true;\n}\n\nstatic bool ParseAsset(Asset *asset, std::string *err, const json &o,\n                       bool store_original_json_for_extras_and_extensions) {\n  ParseStringProperty(&asset->version, err, o, \"version\", true, \"Asset\");\n  ParseStringProperty(&asset->generator, err, o, \"generator\", false, \"Asset\");\n  ParseStringProperty(&asset->minVersion, err, o, \"minVersion\", false, \"Asset\");\n  ParseStringProperty(&asset->copyright, err, o, \"copyright\", false, \"Asset\");\n\n  ParseExtensionsProperty(&asset->extensions, err, o);\n\n  // Unity exporter version is added as extra here\n  ParseExtrasProperty(&(asset->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        asset->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        asset->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParseImage(Image *image, const int image_idx, std::string *err,\n                       std::string *warn, const json &o,\n                       bool store_original_json_for_extras_and_extensions,\n                       const std::string &basedir, FsCallbacks *fs,\n                       LoadImageDataFunction *LoadImageData = nullptr,\n                       void *load_image_user_data = nullptr) {\n  // A glTF image must either reference a bufferView or an image uri\n\n  // schema says oneOf [`bufferView`, `uri`]\n  // TODO(syoyo): Check the type of each parameters.\n  json_const_iterator it;\n  bool hasBufferView = FindMember(o, \"bufferView\", it);\n  bool hasURI = FindMember(o, \"uri\", it);\n\n  ParseStringProperty(&image->name, err, o, \"name\", false);\n\n  if (hasBufferView && hasURI) {\n    // Should not both defined.\n    if (err) {\n      (*err) +=\n          \"Only one of `bufferView` or `uri` should be defined, but both are \"\n          \"defined for image[\" +\n          std::to_string(image_idx) + \"] name = \\\"\" + image->name + \"\\\"\\n\";\n    }\n    return false;\n  }\n\n  if (!hasBufferView && !hasURI) {\n    if (err) {\n      (*err) += \"Neither required `bufferView` nor `uri` defined for image[\" +\n                std::to_string(image_idx) + \"] name = \\\"\" + image->name +\n                \"\\\"\\n\";\n    }\n    return false;\n  }\n\n  ParseExtensionsProperty(&image->extensions, err, o);\n  ParseExtrasProperty(&image->extras, o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator eit;\n      if (FindMember(o, \"extensions\", eit)) {\n        image->extensions_json_string = JsonToString(GetValue(eit));\n      }\n    }\n    {\n      json_const_iterator eit;\n      if (FindMember(o, \"extras\", eit)) {\n        image->extras_json_string = JsonToString(GetValue(eit));\n      }\n    }\n  }\n\n  if (hasBufferView) {\n    int bufferView = -1;\n    if (!ParseIntegerProperty(&bufferView, err, o, \"bufferView\", true)) {\n      if (err) {\n        (*err) += \"Failed to parse `bufferView` for image[\" +\n                  std::to_string(image_idx) + \"] name = \\\"\" + image->name +\n                  \"\\\"\\n\";\n      }\n      return false;\n    }\n\n    std::string mime_type;\n    ParseStringProperty(&mime_type, err, o, \"mimeType\", false);\n\n    int width = 0;\n    ParseIntegerProperty(&width, err, o, \"width\", false);\n\n    int height = 0;\n    ParseIntegerProperty(&height, err, o, \"height\", false);\n\n    // Just only save some information here. Loading actual image data from\n    // bufferView is done after this `ParseImage` function.\n    image->bufferView = bufferView;\n    image->mimeType = mime_type;\n    image->width = width;\n    image->height = height;\n\n    return true;\n  }\n\n  // Parse URI & Load image data.\n\n  std::string uri;\n  std::string tmp_err;\n  if (!ParseStringProperty(&uri, &tmp_err, o, \"uri\", true)) {\n    if (err) {\n      (*err) += \"Failed to parse `uri` for image[\" + std::to_string(image_idx) +\n                \"] name = \\\"\" + image->name + \"\\\".\\n\";\n    }\n    return false;\n  }\n\n  std::vector<unsigned char> img;\n\n  if (IsDataURI(uri)) {\n    if (!DecodeDataURI(&img, image->mimeType, uri, 0, false)) {\n      if (err) {\n        (*err) += \"Failed to decode 'uri' for image[\" +\n                  std::to_string(image_idx) + \"] name = [\" + image->name +\n                  \"]\\n\";\n      }\n      return false;\n    }\n  } else {\n    // Assume external file\n    // Keep texture path (for textures that cannot be decoded)\n    image->uri = uri;\n#ifdef TINYGLTF_NO_EXTERNAL_IMAGE\n    return true;\n#endif\n    std::string decoded_uri = dlib::urldecode(uri);\n    if (!LoadExternalFile(&img, err, warn, decoded_uri, basedir,\n                          /* required */ false, /* required bytes */ 0,\n                          /* checksize */ false, fs)) {\n      if (warn) {\n        (*warn) += \"Failed to load external 'uri' for image[\" +\n                   std::to_string(image_idx) + \"] name = [\" + image->name +\n                   \"]\\n\";\n      }\n      // If the image cannot be loaded, keep uri as image->uri.\n      return true;\n    }\n\n    if (img.empty()) {\n      if (warn) {\n        (*warn) += \"Image data is empty for image[\" +\n                   std::to_string(image_idx) + \"] name = [\" + image->name +\n                   \"] \\n\";\n      }\n      return false;\n    }\n  }\n\n  if (*LoadImageData == nullptr) {\n    if (err) {\n      (*err) += \"No LoadImageData callback specified.\\n\";\n    }\n    return false;\n  }\n  return (*LoadImageData)(image, image_idx, err, warn, 0, 0, &img.at(0),\n                          static_cast<int>(img.size()), load_image_user_data);\n}\n\nstatic bool ParseTexture(Texture *texture, std::string *err, const json &o,\n                         bool store_original_json_for_extras_and_extensions,\n                         const std::string &basedir) {\n  (void)basedir;\n  int sampler = -1;\n  int source = -1;\n  ParseIntegerProperty(&sampler, err, o, \"sampler\", false);\n\n  ParseIntegerProperty(&source, err, o, \"source\", false);\n\n  texture->sampler = sampler;\n  texture->source = source;\n\n  ParseExtensionsProperty(&texture->extensions, err, o);\n  ParseExtrasProperty(&texture->extras, o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        texture->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        texture->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  ParseStringProperty(&texture->name, err, o, \"name\", false);\n\n  return true;\n}\n\nstatic bool ParseTextureInfo(\n    TextureInfo *texinfo, std::string *err, const json &o,\n    bool store_original_json_for_extras_and_extensions) {\n  if (texinfo == nullptr) {\n    return false;\n  }\n\n  if (!ParseIntegerProperty(&texinfo->index, err, o, \"index\",\n                            /* required */ true, \"TextureInfo\")) {\n    return false;\n  }\n\n  ParseIntegerProperty(&texinfo->texCoord, err, o, \"texCoord\", false);\n\n  ParseExtensionsProperty(&texinfo->extensions, err, o);\n  ParseExtrasProperty(&texinfo->extras, o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        texinfo->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        texinfo->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParseNormalTextureInfo(\n    NormalTextureInfo *texinfo, std::string *err, const json &o,\n    bool store_original_json_for_extras_and_extensions) {\n  if (texinfo == nullptr) {\n    return false;\n  }\n\n  if (!ParseIntegerProperty(&texinfo->index, err, o, \"index\",\n                            /* required */ true, \"NormalTextureInfo\")) {\n    return false;\n  }\n\n  ParseIntegerProperty(&texinfo->texCoord, err, o, \"texCoord\", false);\n  ParseNumberProperty(&texinfo->scale, err, o, \"scale\", false);\n\n  ParseExtensionsProperty(&texinfo->extensions, err, o);\n  ParseExtrasProperty(&texinfo->extras, o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        texinfo->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        texinfo->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParseOcclusionTextureInfo(\n    OcclusionTextureInfo *texinfo, std::string *err, const json &o,\n    bool store_original_json_for_extras_and_extensions) {\n  if (texinfo == nullptr) {\n    return false;\n  }\n\n  if (!ParseIntegerProperty(&texinfo->index, err, o, \"index\",\n                            /* required */ true, \"NormalTextureInfo\")) {\n    return false;\n  }\n\n  ParseIntegerProperty(&texinfo->texCoord, err, o, \"texCoord\", false);\n  ParseNumberProperty(&texinfo->strength, err, o, \"strength\", false);\n\n  ParseExtensionsProperty(&texinfo->extensions, err, o);\n  ParseExtrasProperty(&texinfo->extras, o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        texinfo->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        texinfo->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParseBuffer(Buffer *buffer, std::string *err, const json &o,\n                        bool store_original_json_for_extras_and_extensions,\n                        FsCallbacks *fs, const std::string &basedir,\n                        bool is_binary = false,\n                        const unsigned char *bin_data = nullptr,\n                        size_t bin_size = 0) {\n  size_t byteLength;\n  if (!ParseUnsignedProperty(&byteLength, err, o, \"byteLength\", true,\n                             \"Buffer\")) {\n    return false;\n  }\n\n  // In glTF 2.0, uri is not mandatory anymore\n  buffer->uri.clear();\n  ParseStringProperty(&buffer->uri, err, o, \"uri\", false, \"Buffer\");\n\n  // having an empty uri for a non embedded image should not be valid\n  if (!is_binary && buffer->uri.empty()) {\n    if (err) {\n      (*err) += \"'uri' is missing from non binary glTF file buffer.\\n\";\n    }\n  }\n\n  json_const_iterator type;\n  if (FindMember(o, \"type\", type)) {\n    std::string typeStr;\n    if (GetString(GetValue(type), typeStr)) {\n      if (typeStr.compare(\"arraybuffer\") == 0) {\n        // buffer.type = \"arraybuffer\";\n      }\n    }\n  }\n\n  if (is_binary) {\n    // Still binary glTF accepts external dataURI.\n    if (!buffer->uri.empty()) {\n      // First try embedded data URI.\n      if (IsDataURI(buffer->uri)) {\n        std::string mime_type;\n        if (!DecodeDataURI(&buffer->data, mime_type, buffer->uri, byteLength,\n                           true)) {\n          if (err) {\n            (*err) +=\n                \"Failed to decode 'uri' : \" + buffer->uri + \" in Buffer\\n\";\n          }\n          return false;\n        }\n      } else {\n        // External .bin file.\n        std::string decoded_uri = dlib::urldecode(buffer->uri);\n        if (!LoadExternalFile(&buffer->data, err, /* warn */ nullptr,\n                              decoded_uri, basedir, /* required */ true,\n                              byteLength, /* checkSize */ true, fs)) {\n          return false;\n        }\n      }\n    } else {\n      // load data from (embedded) binary data\n\n      if ((bin_size == 0) || (bin_data == nullptr)) {\n        if (err) {\n          (*err) += \"Invalid binary data in `Buffer'.\\n\";\n        }\n        return false;\n      }\n\n      if (byteLength > bin_size) {\n        if (err) {\n          std::stringstream ss;\n          ss << \"Invalid `byteLength'. Must be equal or less than binary size: \"\n                \"`byteLength' = \"\n             << byteLength << \", binary size = \" << bin_size << std::endl;\n          (*err) += ss.str();\n        }\n        return false;\n      }\n\n      // Read buffer data\n      buffer->data.resize(static_cast<size_t>(byteLength));\n      memcpy(&(buffer->data.at(0)), bin_data, static_cast<size_t>(byteLength));\n    }\n\n  } else {\n    if (IsDataURI(buffer->uri)) {\n      std::string mime_type;\n      if (!DecodeDataURI(&buffer->data, mime_type, buffer->uri, byteLength,\n                         true)) {\n        if (err) {\n          (*err) += \"Failed to decode 'uri' : \" + buffer->uri + \" in Buffer\\n\";\n        }\n        return false;\n      }\n    } else {\n      // Assume external .bin file.\n      std::string decoded_uri = dlib::urldecode(buffer->uri);\n      if (!LoadExternalFile(&buffer->data, err, /* warn */ nullptr, decoded_uri,\n                            basedir, /* required */ true, byteLength,\n                            /* checkSize */ true, fs)) {\n        return false;\n      }\n    }\n  }\n\n  ParseStringProperty(&buffer->name, err, o, \"name\", false);\n\n  ParseExtensionsProperty(&buffer->extensions, err, o);\n  ParseExtrasProperty(&buffer->extras, o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        buffer->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        buffer->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParseBufferView(\n    BufferView *bufferView, std::string *err, const json &o,\n    bool store_original_json_for_extras_and_extensions) {\n  int buffer = -1;\n  if (!ParseIntegerProperty(&buffer, err, o, \"buffer\", true, \"BufferView\")) {\n    return false;\n  }\n\n  size_t byteOffset = 0;\n  ParseUnsignedProperty(&byteOffset, err, o, \"byteOffset\", false);\n\n  size_t byteLength = 1;\n  if (!ParseUnsignedProperty(&byteLength, err, o, \"byteLength\", true,\n                             \"BufferView\")) {\n    return false;\n  }\n\n  size_t byteStride = 0;\n  if (!ParseUnsignedProperty(&byteStride, err, o, \"byteStride\", false)) {\n    // Spec says: When byteStride of referenced bufferView is not defined, it\n    // means that accessor elements are tightly packed, i.e., effective stride\n    // equals the size of the element.\n    // We cannot determine the actual byteStride until Accessor are parsed, thus\n    // set 0(= tightly packed) here(as done in OpenGL's VertexAttribPoiner)\n    byteStride = 0;\n  }\n\n  if ((byteStride > 252) || ((byteStride % 4) != 0)) {\n    if (err) {\n      std::stringstream ss;\n      ss << \"Invalid `byteStride' value. `byteStride' must be the multiple of \"\n            \"4 : \"\n         << byteStride << std::endl;\n\n      (*err) += ss.str();\n    }\n    return false;\n  }\n\n  int target = 0;\n  ParseIntegerProperty(&target, err, o, \"target\", false);\n  if ((target == TINYGLTF_TARGET_ARRAY_BUFFER) ||\n      (target == TINYGLTF_TARGET_ELEMENT_ARRAY_BUFFER)) {\n    // OK\n  } else {\n    target = 0;\n  }\n  bufferView->target = target;\n\n  ParseStringProperty(&bufferView->name, err, o, \"name\", false);\n\n  ParseExtensionsProperty(&bufferView->extensions, err, o);\n  ParseExtrasProperty(&bufferView->extras, o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        bufferView->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        bufferView->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  bufferView->buffer = buffer;\n  bufferView->byteOffset = byteOffset;\n  bufferView->byteLength = byteLength;\n  bufferView->byteStride = byteStride;\n  return true;\n}\n\nstatic bool ParseSparseAccessor(Accessor *accessor, std::string *err,\n                                const json &o) {\n  accessor->sparse.isSparse = true;\n\n  int count = 0;\n  if (!ParseIntegerProperty(&count, err, o, \"count\", true, \"SparseAccessor\")) {\n    return false;\n  }\n\n  json_const_iterator indices_iterator;\n  json_const_iterator values_iterator;\n  if (!FindMember(o, \"indices\", indices_iterator)) {\n    (*err) = \"the sparse object of this accessor doesn't have indices\";\n    return false;\n  }\n\n  if (!FindMember(o, \"values\", values_iterator)) {\n    (*err) = \"the sparse object ob ths accessor doesn't have values\";\n    return false;\n  }\n\n  const json &indices_obj = GetValue(indices_iterator);\n  const json &values_obj = GetValue(values_iterator);\n\n  int indices_buffer_view = 0, indices_byte_offset = 0, component_type = 0;\n  if (!ParseIntegerProperty(&indices_buffer_view, err, indices_obj,\n                            \"bufferView\", true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&indices_byte_offset, err, indices_obj, \"byteOffset\",\n                       false);\n  if (!ParseIntegerProperty(&component_type, err, indices_obj, \"componentType\",\n                            true, \"SparseAccessor\")) {\n    return false;\n  }\n\n  int values_buffer_view = 0, values_byte_offset = 0;\n  if (!ParseIntegerProperty(&values_buffer_view, err, values_obj, \"bufferView\",\n                            true, \"SparseAccessor\")) {\n    return false;\n  }\n  ParseIntegerProperty(&values_byte_offset, err, values_obj, \"byteOffset\",\n                       false);\n\n  accessor->sparse.count = count;\n  accessor->sparse.indices.bufferView = indices_buffer_view;\n  accessor->sparse.indices.byteOffset = indices_byte_offset;\n  accessor->sparse.indices.componentType = component_type;\n  accessor->sparse.values.bufferView = values_buffer_view;\n  accessor->sparse.values.byteOffset = values_byte_offset;\n\n  return true;\n}\n\nstatic bool ParseAccessor(Accessor *accessor, std::string *err, const json &o,\n                          bool store_original_json_for_extras_and_extensions) {\n  int bufferView = -1;\n  ParseIntegerProperty(&bufferView, err, o, \"bufferView\", false, \"Accessor\");\n\n  size_t byteOffset = 0;\n  ParseUnsignedProperty(&byteOffset, err, o, \"byteOffset\", false, \"Accessor\");\n\n  bool normalized = false;\n  ParseBooleanProperty(&normalized, err, o, \"normalized\", false, \"Accessor\");\n\n  size_t componentType = 0;\n  if (!ParseUnsignedProperty(&componentType, err, o, \"componentType\", true,\n                             \"Accessor\")) {\n    return false;\n  }\n\n  size_t count = 0;\n  if (!ParseUnsignedProperty(&count, err, o, \"count\", true, \"Accessor\")) {\n    return false;\n  }\n\n  std::string type;\n  if (!ParseStringProperty(&type, err, o, \"type\", true, \"Accessor\")) {\n    return false;\n  }\n\n  if (type.compare(\"SCALAR\") == 0) {\n    accessor->type = TINYGLTF_TYPE_SCALAR;\n  } else if (type.compare(\"VEC2\") == 0) {\n    accessor->type = TINYGLTF_TYPE_VEC2;\n  } else if (type.compare(\"VEC3\") == 0) {\n    accessor->type = TINYGLTF_TYPE_VEC3;\n  } else if (type.compare(\"VEC4\") == 0) {\n    accessor->type = TINYGLTF_TYPE_VEC4;\n  } else if (type.compare(\"MAT2\") == 0) {\n    accessor->type = TINYGLTF_TYPE_MAT2;\n  } else if (type.compare(\"MAT3\") == 0) {\n    accessor->type = TINYGLTF_TYPE_MAT3;\n  } else if (type.compare(\"MAT4\") == 0) {\n    accessor->type = TINYGLTF_TYPE_MAT4;\n  } else {\n    std::stringstream ss;\n    ss << \"Unsupported `type` for accessor object. Got \\\"\" << type << \"\\\"\\n\";\n    if (err) {\n      (*err) += ss.str();\n    }\n    return false;\n  }\n\n  ParseStringProperty(&accessor->name, err, o, \"name\", false);\n\n  accessor->minValues.clear();\n  accessor->maxValues.clear();\n  ParseNumberArrayProperty(&accessor->minValues, err, o, \"min\", false,\n                           \"Accessor\");\n\n  ParseNumberArrayProperty(&accessor->maxValues, err, o, \"max\", false,\n                           \"Accessor\");\n\n  accessor->count = count;\n  accessor->bufferView = bufferView;\n  accessor->byteOffset = byteOffset;\n  accessor->normalized = normalized;\n  {\n    if (componentType >= TINYGLTF_COMPONENT_TYPE_BYTE &&\n        componentType <= TINYGLTF_COMPONENT_TYPE_DOUBLE) {\n      // OK\n      accessor->componentType = int(componentType);\n    } else {\n      std::stringstream ss;\n      ss << \"Invalid `componentType` in accessor. Got \" << componentType\n         << \"\\n\";\n      if (err) {\n        (*err) += ss.str();\n      }\n      return false;\n    }\n  }\n\n  ParseExtensionsProperty(&(accessor->extensions), err, o);\n  ParseExtrasProperty(&(accessor->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        accessor->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        accessor->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  // check if accessor has a \"sparse\" object:\n  json_const_iterator iterator;\n  if (FindMember(o, \"sparse\", iterator)) {\n    // here this accessor has a \"sparse\" subobject\n    return ParseSparseAccessor(accessor, err, GetValue(iterator));\n  }\n\n  return true;\n}\n\n#ifdef TINYGLTF_ENABLE_DRACO\n\nstatic void DecodeIndexBuffer(draco::Mesh *mesh, size_t componentSize,\n                              std::vector<uint8_t> &outBuffer) {\n  if (componentSize == 4) {\n    assert(sizeof(mesh->face(draco::FaceIndex(0))[0]) == componentSize);\n    memcpy(outBuffer.data(), &mesh->face(draco::FaceIndex(0))[0],\n           outBuffer.size());\n  } else {\n    size_t faceStride = componentSize * 3;\n    for (draco::FaceIndex f(0); f < mesh->num_faces(); ++f) {\n      const draco::Mesh::Face &face = mesh->face(f);\n      if (componentSize == 2) {\n        uint16_t indices[3] = {(uint16_t)face[0].value(),\n                               (uint16_t)face[1].value(),\n                               (uint16_t)face[2].value()};\n        memcpy(outBuffer.data() + f.value() * faceStride, &indices[0],\n               faceStride);\n      } else {\n        uint8_t indices[3] = {(uint8_t)face[0].value(),\n                              (uint8_t)face[1].value(),\n                              (uint8_t)face[2].value()};\n        memcpy(outBuffer.data() + f.value() * faceStride, &indices[0],\n               faceStride);\n      }\n    }\n  }\n}\n\ntemplate <typename T>\nstatic bool GetAttributeForAllPoints(draco::Mesh *mesh,\n                                     const draco::PointAttribute *pAttribute,\n                                     std::vector<uint8_t> &outBuffer) {\n  size_t byteOffset = 0;\n  T values[4] = {0, 0, 0, 0};\n  for (draco::PointIndex i(0); i < mesh->num_points(); ++i) {\n    const draco::AttributeValueIndex val_index = pAttribute->mapped_index(i);\n    if (!pAttribute->ConvertValue<T>(val_index, pAttribute->num_components(),\n                                     values))\n      return false;\n\n    memcpy(outBuffer.data() + byteOffset, &values[0],\n           sizeof(T) * pAttribute->num_components());\n    byteOffset += sizeof(T) * pAttribute->num_components();\n  }\n\n  return true;\n}\n\nstatic bool GetAttributeForAllPoints(uint32_t componentType, draco::Mesh *mesh,\n                                     const draco::PointAttribute *pAttribute,\n                                     std::vector<uint8_t> &outBuffer) {\n  bool decodeResult = false;\n  switch (componentType) {\n    case TINYGLTF_COMPONENT_TYPE_UNSIGNED_BYTE:\n      decodeResult =\n          GetAttributeForAllPoints<uint8_t>(mesh, pAttribute, outBuffer);\n      break;\n    case TINYGLTF_COMPONENT_TYPE_BYTE:\n      decodeResult =\n          GetAttributeForAllPoints<int8_t>(mesh, pAttribute, outBuffer);\n      break;\n    case TINYGLTF_COMPONENT_TYPE_UNSIGNED_SHORT:\n      decodeResult =\n          GetAttributeForAllPoints<uint16_t>(mesh, pAttribute, outBuffer);\n      break;\n    case TINYGLTF_COMPONENT_TYPE_SHORT:\n      decodeResult =\n          GetAttributeForAllPoints<int16_t>(mesh, pAttribute, outBuffer);\n      break;\n    case TINYGLTF_COMPONENT_TYPE_INT:\n      decodeResult =\n          GetAttributeForAllPoints<int32_t>(mesh, pAttribute, outBuffer);\n      break;\n    case TINYGLTF_COMPONENT_TYPE_UNSIGNED_INT:\n      decodeResult =\n          GetAttributeForAllPoints<uint32_t>(mesh, pAttribute, outBuffer);\n      break;\n    case TINYGLTF_COMPONENT_TYPE_FLOAT:\n      decodeResult =\n          GetAttributeForAllPoints<float>(mesh, pAttribute, outBuffer);\n      break;\n    case TINYGLTF_COMPONENT_TYPE_DOUBLE:\n      decodeResult =\n          GetAttributeForAllPoints<double>(mesh, pAttribute, outBuffer);\n      break;\n    default:\n      return false;\n  }\n\n  return decodeResult;\n}\n\nstatic bool ParseDracoExtension(Primitive *primitive, Model *model,\n                                std::string *err,\n                                const Value &dracoExtensionValue) {\n  (void)err;\n  auto bufferViewValue = dracoExtensionValue.Get(\"bufferView\");\n  if (!bufferViewValue.IsInt()) return false;\n  auto attributesValue = dracoExtensionValue.Get(\"attributes\");\n  if (!attributesValue.IsObject()) return false;\n\n  auto attributesObject = attributesValue.Get<Value::Object>();\n  int bufferView = bufferViewValue.Get<int>();\n\n  BufferView &view = model->bufferViews[bufferView];\n  Buffer &buffer = model->buffers[view.buffer];\n  // BufferView has already been decoded\n  if (view.dracoDecoded) return true;\n  view.dracoDecoded = true;\n\n  const char *bufferViewData =\n      reinterpret_cast<const char *>(buffer.data.data() + view.byteOffset);\n  size_t bufferViewSize = view.byteLength;\n\n  // decode draco\n  draco::DecoderBuffer decoderBuffer;\n  decoderBuffer.Init(bufferViewData, bufferViewSize);\n  draco::Decoder decoder;\n  auto decodeResult = decoder.DecodeMeshFromBuffer(&decoderBuffer);\n  if (!decodeResult.ok()) {\n    return false;\n  }\n  const std::unique_ptr<draco::Mesh> &mesh = decodeResult.value();\n\n  // create new bufferView for indices\n  if (primitive->indices >= 0) {\n    int32_t componentSize = GetComponentSizeInBytes(\n        model->accessors[primitive->indices].componentType);\n    Buffer decodedIndexBuffer;\n    decodedIndexBuffer.data.resize(mesh->num_faces() * 3 * componentSize);\n\n    DecodeIndexBuffer(mesh.get(), componentSize, decodedIndexBuffer.data);\n\n    model->buffers.emplace_back(std::move(decodedIndexBuffer));\n\n    BufferView decodedIndexBufferView;\n    decodedIndexBufferView.buffer = int(model->buffers.size() - 1);\n    decodedIndexBufferView.byteLength =\n        int(mesh->num_faces() * 3 * componentSize);\n    decodedIndexBufferView.byteOffset = 0;\n    decodedIndexBufferView.byteStride = 0;\n    decodedIndexBufferView.target = TINYGLTF_TARGET_ARRAY_BUFFER;\n    model->bufferViews.emplace_back(std::move(decodedIndexBufferView));\n\n    model->accessors[primitive->indices].bufferView =\n        int(model->bufferViews.size() - 1);\n    model->accessors[primitive->indices].count = int(mesh->num_faces() * 3);\n  }\n\n  for (const auto &attribute : attributesObject) {\n    if (!attribute.second.IsInt()) return false;\n    auto primitiveAttribute = primitive->attributes.find(attribute.first);\n    if (primitiveAttribute == primitive->attributes.end()) return false;\n\n    int dracoAttributeIndex = attribute.second.Get<int>();\n    const auto pAttribute = mesh->GetAttributeByUniqueId(dracoAttributeIndex);\n    const auto componentType =\n        model->accessors[primitiveAttribute->second].componentType;\n\n    // Create a new buffer for this decoded buffer\n    Buffer decodedBuffer;\n    size_t bufferSize = mesh->num_points() * pAttribute->num_components() *\n                        GetComponentSizeInBytes(componentType);\n    decodedBuffer.data.resize(bufferSize);\n\n    if (!GetAttributeForAllPoints(componentType, mesh.get(), pAttribute,\n                                  decodedBuffer.data))\n      return false;\n\n    model->buffers.emplace_back(std::move(decodedBuffer));\n\n    BufferView decodedBufferView;\n    decodedBufferView.buffer = int(model->buffers.size() - 1);\n    decodedBufferView.byteLength = bufferSize;\n    decodedBufferView.byteOffset = pAttribute->byte_offset();\n    decodedBufferView.byteStride = pAttribute->byte_stride();\n    decodedBufferView.target = primitive->indices >= 0\n                                   ? TINYGLTF_TARGET_ELEMENT_ARRAY_BUFFER\n                                   : TINYGLTF_TARGET_ARRAY_BUFFER;\n    model->bufferViews.emplace_back(std::move(decodedBufferView));\n\n    model->accessors[primitiveAttribute->second].bufferView =\n        int(model->bufferViews.size() - 1);\n    model->accessors[primitiveAttribute->second].count =\n        int(mesh->num_points());\n  }\n\n  return true;\n}\n#endif\n\nstatic bool ParsePrimitive(Primitive *primitive, Model *model, std::string *err,\n                           const json &o,\n                           bool store_original_json_for_extras_and_extensions) {\n  int material = -1;\n  ParseIntegerProperty(&material, err, o, \"material\", false);\n  primitive->material = material;\n\n  int mode = TINYGLTF_MODE_TRIANGLES;\n  ParseIntegerProperty(&mode, err, o, \"mode\", false);\n  primitive->mode = mode;  // Why only triangled were supported ?\n\n  int indices = -1;\n  ParseIntegerProperty(&indices, err, o, \"indices\", false);\n  primitive->indices = indices;\n  if (!ParseStringIntegerProperty(&primitive->attributes, err, o, \"attributes\",\n                                  true, \"Primitive\")) {\n    return false;\n  }\n\n  // Look for morph targets\n  json_const_iterator targetsObject;\n  if (FindMember(o, \"targets\", targetsObject) &&\n      IsArray(GetValue(targetsObject))) {\n    auto targetsObjectEnd = ArrayEnd(GetValue(targetsObject));\n    for (json_const_array_iterator i = ArrayBegin(GetValue(targetsObject));\n         i != targetsObjectEnd; ++i) {\n      std::map<std::string, int> targetAttribues;\n\n      const json &dict = *i;\n      if (IsObject(dict)) {\n        json_const_iterator dictIt(ObjectBegin(dict));\n        json_const_iterator dictItEnd(ObjectEnd(dict));\n\n        for (; dictIt != dictItEnd; ++dictIt) {\n          int iVal;\n          if (GetInt(GetValue(dictIt), iVal))\n            targetAttribues[GetKey(dictIt)] = iVal;\n        }\n        primitive->targets.emplace_back(std::move(targetAttribues));\n      }\n    }\n  }\n\n  ParseExtrasProperty(&(primitive->extras), o);\n  ParseExtensionsProperty(&primitive->extensions, err, o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        primitive->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        primitive->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n#ifdef TINYGLTF_ENABLE_DRACO\n  auto dracoExtension =\n      primitive->extensions.find(\"KHR_draco_mesh_compression\");\n  if (dracoExtension != primitive->extensions.end()) {\n    ParseDracoExtension(primitive, model, err, dracoExtension->second);\n  }\n#else\n  (void)model;\n#endif\n\n  return true;\n}\n\nstatic bool ParseMesh(Mesh *mesh, Model *model, std::string *err, const json &o,\n                      bool store_original_json_for_extras_and_extensions) {\n  ParseStringProperty(&mesh->name, err, o, \"name\", false);\n\n  mesh->primitives.clear();\n  json_const_iterator primObject;\n  if (FindMember(o, \"primitives\", primObject) &&\n      IsArray(GetValue(primObject))) {\n    json_const_array_iterator primEnd = ArrayEnd(GetValue(primObject));\n    for (json_const_array_iterator i = ArrayBegin(GetValue(primObject));\n         i != primEnd; ++i) {\n      Primitive primitive;\n      if (ParsePrimitive(&primitive, model, err, *i,\n                         store_original_json_for_extras_and_extensions)) {\n        // Only add the primitive if the parsing succeeds.\n        mesh->primitives.emplace_back(std::move(primitive));\n      }\n    }\n  }\n\n  // Should probably check if has targets and if dimensions fit\n  ParseNumberArrayProperty(&mesh->weights, err, o, \"weights\", false);\n\n  ParseExtensionsProperty(&mesh->extensions, err, o);\n  ParseExtrasProperty(&(mesh->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        mesh->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        mesh->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParseNode(Node *node, std::string *err, const json &o,\n                      bool store_original_json_for_extras_and_extensions) {\n  ParseStringProperty(&node->name, err, o, \"name\", false);\n\n  int skin = -1;\n  ParseIntegerProperty(&skin, err, o, \"skin\", false);\n  node->skin = skin;\n\n  // Matrix and T/R/S are exclusive\n  if (!ParseNumberArrayProperty(&node->matrix, err, o, \"matrix\", false)) {\n    ParseNumberArrayProperty(&node->rotation, err, o, \"rotation\", false);\n    ParseNumberArrayProperty(&node->scale, err, o, \"scale\", false);\n    ParseNumberArrayProperty(&node->translation, err, o, \"translation\", false);\n  }\n\n  int camera = -1;\n  ParseIntegerProperty(&camera, err, o, \"camera\", false);\n  node->camera = camera;\n\n  int mesh = -1;\n  ParseIntegerProperty(&mesh, err, o, \"mesh\", false);\n  node->mesh = mesh;\n\n  node->children.clear();\n  ParseIntegerArrayProperty(&node->children, err, o, \"children\", false);\n\n  ParseNumberArrayProperty(&node->weights, err, o, \"weights\", false);\n\n  ParseExtensionsProperty(&node->extensions, err, o);\n  ParseExtrasProperty(&(node->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        node->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        node->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParsePbrMetallicRoughness(\n    PbrMetallicRoughness *pbr, std::string *err, const json &o,\n    bool store_original_json_for_extras_and_extensions) {\n  if (pbr == nullptr) {\n    return false;\n  }\n\n  std::vector<double> baseColorFactor;\n  if (ParseNumberArrayProperty(&baseColorFactor, err, o, \"baseColorFactor\",\n                               /* required */ false)) {\n    if (baseColorFactor.size() != 4) {\n      if (err) {\n        (*err) +=\n            \"Array length of `baseColorFactor` parameter in \"\n            \"pbrMetallicRoughness must be 4, but got \" +\n            std::to_string(baseColorFactor.size()) + \"\\n\";\n      }\n      return false;\n    }\n    pbr->baseColorFactor = baseColorFactor;\n  }\n\n  {\n    json_const_iterator it;\n    if (FindMember(o, \"baseColorTexture\", it)) {\n      ParseTextureInfo(&pbr->baseColorTexture, err, GetValue(it),\n                       store_original_json_for_extras_and_extensions);\n    }\n  }\n\n  {\n    json_const_iterator it;\n    if (FindMember(o, \"metallicRoughnessTexture\", it)) {\n      ParseTextureInfo(&pbr->metallicRoughnessTexture, err, GetValue(it),\n                       store_original_json_for_extras_and_extensions);\n    }\n  }\n\n  ParseNumberProperty(&pbr->metallicFactor, err, o, \"metallicFactor\", false);\n  ParseNumberProperty(&pbr->roughnessFactor, err, o, \"roughnessFactor\", false);\n\n  ParseExtensionsProperty(&pbr->extensions, err, o);\n  ParseExtrasProperty(&pbr->extras, o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        pbr->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        pbr->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParseMaterial(Material *material, std::string *err, const json &o,\n                          bool store_original_json_for_extras_and_extensions) {\n  ParseStringProperty(&material->name, err, o, \"name\", /* required */ false);\n\n  if (ParseNumberArrayProperty(&material->emissiveFactor, err, o,\n                               \"emissiveFactor\",\n                               /* required */ false)) {\n    if (material->emissiveFactor.size() != 3) {\n      if (err) {\n        (*err) +=\n            \"Array length of `emissiveFactor` parameter in \"\n            \"material must be 3, but got \" +\n            std::to_string(material->emissiveFactor.size()) + \"\\n\";\n      }\n      return false;\n    }\n  } else {\n    // fill with default values\n    material->emissiveFactor = {0.0, 0.0, 0.0};\n  }\n\n  ParseStringProperty(&material->alphaMode, err, o, \"alphaMode\",\n                      /* required */ false);\n  ParseNumberProperty(&material->alphaCutoff, err, o, \"alphaCutoff\",\n                      /* required */ false);\n  ParseBooleanProperty(&material->doubleSided, err, o, \"doubleSided\",\n                       /* required */ false);\n\n  {\n    json_const_iterator it;\n    if (FindMember(o, \"pbrMetallicRoughness\", it)) {\n      ParsePbrMetallicRoughness(&material->pbrMetallicRoughness, err,\n                                GetValue(it),\n                                store_original_json_for_extras_and_extensions);\n    }\n  }\n\n  {\n    json_const_iterator it;\n    if (FindMember(o, \"normalTexture\", it)) {\n      ParseNormalTextureInfo(&material->normalTexture, err, GetValue(it),\n                             store_original_json_for_extras_and_extensions);\n    }\n  }\n\n  {\n    json_const_iterator it;\n    if (FindMember(o, \"occlusionTexture\", it)) {\n      ParseOcclusionTextureInfo(&material->occlusionTexture, err, GetValue(it),\n                                store_original_json_for_extras_and_extensions);\n    }\n  }\n\n  {\n    json_const_iterator it;\n    if (FindMember(o, \"emissiveTexture\", it)) {\n      ParseTextureInfo(&material->emissiveTexture, err, GetValue(it),\n                       store_original_json_for_extras_and_extensions);\n    }\n  }\n\n  // Old code path. For backward compatibility, we still store material values\n  // as Parameter. This will create duplicated information for\n  // example(pbrMetallicRoughness), but should be neglible in terms of memory\n  // consumption.\n  // TODO(syoyo): Remove in the next major release.\n  material->values.clear();\n  material->additionalValues.clear();\n\n  json_const_iterator it(ObjectBegin(o));\n  json_const_iterator itEnd(ObjectEnd(o));\n\n  for (; it != itEnd; ++it) {\n    std::string key(GetKey(it));\n    if (key == \"pbrMetallicRoughness\") {\n      if (IsObject(GetValue(it))) {\n        const json &values_object = GetValue(it);\n\n        json_const_iterator itVal(ObjectBegin(values_object));\n        json_const_iterator itValEnd(ObjectEnd(values_object));\n\n        for (; itVal != itValEnd; ++itVal) {\n          Parameter param;\n          if (ParseParameterProperty(&param, err, values_object, GetKey(itVal),\n                                     false)) {\n            material->values.emplace(GetKey(itVal), std::move(param));\n          }\n        }\n      }\n    } else if (key == \"extensions\" || key == \"extras\") {\n      // done later, skip, otherwise poorly parsed contents will be saved in the\n      // parametermap and serialized again later\n    } else {\n      Parameter param;\n      if (ParseParameterProperty(&param, err, o, key, false)) {\n        // names of materials have already been parsed. Putting it in this map\n        // doesn't correctly reflext the glTF specification\n        if (key != \"name\")\n          material->additionalValues.emplace(std::move(key), std::move(param));\n      }\n    }\n  }\n\n  material->extensions.clear();\n  ParseExtensionsProperty(&material->extensions, err, o);\n  ParseExtrasProperty(&(material->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator eit;\n      if (FindMember(o, \"extensions\", eit)) {\n        material->extensions_json_string = JsonToString(GetValue(eit));\n      }\n    }\n    {\n      json_const_iterator eit;\n      if (FindMember(o, \"extras\", eit)) {\n        material->extras_json_string = JsonToString(GetValue(eit));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParseAnimationChannel(\n    AnimationChannel *channel, std::string *err, const json &o,\n    bool store_original_json_for_extras_and_extensions) {\n  int samplerIndex = -1;\n  int targetIndex = -1;\n  if (!ParseIntegerProperty(&samplerIndex, err, o, \"sampler\", true,\n                            \"AnimationChannel\")) {\n    if (err) {\n      (*err) += \"`sampler` field is missing in animation channels\\n\";\n    }\n    return false;\n  }\n\n  json_const_iterator targetIt;\n  if (FindMember(o, \"target\", targetIt) && IsObject(GetValue(targetIt))) {\n    const json &target_object = GetValue(targetIt);\n\n    if (!ParseIntegerProperty(&targetIndex, err, target_object, \"node\", true)) {\n      if (err) {\n        (*err) += \"`node` field is missing in animation.channels.target\\n\";\n      }\n      return false;\n    }\n\n    if (!ParseStringProperty(&channel->target_path, err, target_object, \"path\",\n                             true)) {\n      if (err) {\n        (*err) += \"`path` field is missing in animation.channels.target\\n\";\n      }\n      return false;\n    }\n    ParseExtensionsProperty(&channel->target_extensions, err, target_object);\n    if (store_original_json_for_extras_and_extensions) {\n      json_const_iterator it;\n      if (FindMember(target_object, \"extensions\", it)) {\n        channel->target_extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  channel->sampler = samplerIndex;\n  channel->target_node = targetIndex;\n\n  ParseExtensionsProperty(&channel->extensions, err, o);\n  ParseExtrasProperty(&(channel->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        channel->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        channel->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParseAnimation(Animation *animation, std::string *err,\n                           const json &o,\n                           bool store_original_json_for_extras_and_extensions) {\n  {\n    json_const_iterator channelsIt;\n    if (FindMember(o, \"channels\", channelsIt) &&\n        IsArray(GetValue(channelsIt))) {\n      json_const_array_iterator channelEnd = ArrayEnd(GetValue(channelsIt));\n      for (json_const_array_iterator i = ArrayBegin(GetValue(channelsIt));\n           i != channelEnd; ++i) {\n        AnimationChannel channel;\n        if (ParseAnimationChannel(\n                &channel, err, *i,\n                store_original_json_for_extras_and_extensions)) {\n          // Only add the channel if the parsing succeeds.\n          animation->channels.emplace_back(std::move(channel));\n        }\n      }\n    }\n  }\n\n  {\n    json_const_iterator samplerIt;\n    if (FindMember(o, \"samplers\", samplerIt) && IsArray(GetValue(samplerIt))) {\n      const json &sampler_array = GetValue(samplerIt);\n\n      json_const_array_iterator it = ArrayBegin(sampler_array);\n      json_const_array_iterator itEnd = ArrayEnd(sampler_array);\n\n      for (; it != itEnd; ++it) {\n        const json &s = *it;\n\n        AnimationSampler sampler;\n        int inputIndex = -1;\n        int outputIndex = -1;\n        if (!ParseIntegerProperty(&inputIndex, err, s, \"input\", true)) {\n          if (err) {\n            (*err) += \"`input` field is missing in animation.sampler\\n\";\n          }\n          return false;\n        }\n        ParseStringProperty(&sampler.interpolation, err, s, \"interpolation\",\n                            false);\n        if (!ParseIntegerProperty(&outputIndex, err, s, \"output\", true)) {\n          if (err) {\n            (*err) += \"`output` field is missing in animation.sampler\\n\";\n          }\n          return false;\n        }\n        sampler.input = inputIndex;\n        sampler.output = outputIndex;\n        ParseExtensionsProperty(&(sampler.extensions), err, o);\n        ParseExtrasProperty(&(sampler.extras), s);\n\n        if (store_original_json_for_extras_and_extensions) {\n          {\n            json_const_iterator eit;\n            if (FindMember(o, \"extensions\", eit)) {\n              sampler.extensions_json_string = JsonToString(GetValue(eit));\n            }\n          }\n          {\n            json_const_iterator eit;\n            if (FindMember(o, \"extras\", eit)) {\n              sampler.extras_json_string = JsonToString(GetValue(eit));\n            }\n          }\n        }\n\n        animation->samplers.emplace_back(std::move(sampler));\n      }\n    }\n  }\n\n  ParseStringProperty(&animation->name, err, o, \"name\", false);\n\n  ParseExtensionsProperty(&animation->extensions, err, o);\n  ParseExtrasProperty(&(animation->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        animation->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        animation->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParseSampler(Sampler *sampler, std::string *err, const json &o,\n                         bool store_original_json_for_extras_and_extensions) {\n  ParseStringProperty(&sampler->name, err, o, \"name\", false);\n\n  int minFilter = -1;\n  int magFilter = -1;\n  int wrapS = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  int wrapT = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  // int wrapR = TINYGLTF_TEXTURE_WRAP_REPEAT;\n  ParseIntegerProperty(&minFilter, err, o, \"minFilter\", false);\n  ParseIntegerProperty(&magFilter, err, o, \"magFilter\", false);\n  ParseIntegerProperty(&wrapS, err, o, \"wrapS\", false);\n  ParseIntegerProperty(&wrapT, err, o, \"wrapT\", false);\n  // ParseIntegerProperty(&wrapR, err, o, \"wrapR\", false);  // tinygltf\n  // extension\n\n  // TODO(syoyo): Check the value is alloed one.\n  // (e.g. we allow 9728(NEAREST), but don't allow 9727)\n\n  sampler->minFilter = minFilter;\n  sampler->magFilter = magFilter;\n  sampler->wrapS = wrapS;\n  sampler->wrapT = wrapT;\n  // sampler->wrapR = wrapR;\n\n  ParseExtensionsProperty(&(sampler->extensions), err, o);\n  ParseExtrasProperty(&(sampler->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        sampler->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        sampler->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParseSkin(Skin *skin, std::string *err, const json &o,\n                      bool store_original_json_for_extras_and_extensions) {\n  ParseStringProperty(&skin->name, err, o, \"name\", false, \"Skin\");\n\n  std::vector<int> joints;\n  if (!ParseIntegerArrayProperty(&joints, err, o, \"joints\", false, \"Skin\")) {\n    return false;\n  }\n  skin->joints = std::move(joints);\n\n  int skeleton = -1;\n  ParseIntegerProperty(&skeleton, err, o, \"skeleton\", false, \"Skin\");\n  skin->skeleton = skeleton;\n\n  int invBind = -1;\n  ParseIntegerProperty(&invBind, err, o, \"inverseBindMatrices\", true, \"Skin\");\n  skin->inverseBindMatrices = invBind;\n\n  ParseExtensionsProperty(&(skin->extensions), err, o);\n  ParseExtrasProperty(&(skin->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        skin->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        skin->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParsePerspectiveCamera(\n    PerspectiveCamera *camera, std::string *err, const json &o,\n    bool store_original_json_for_extras_and_extensions) {\n  double yfov = 0.0;\n  if (!ParseNumberProperty(&yfov, err, o, \"yfov\", true, \"OrthographicCamera\")) {\n    return false;\n  }\n\n  double znear = 0.0;\n  if (!ParseNumberProperty(&znear, err, o, \"znear\", true,\n                           \"PerspectiveCamera\")) {\n    return false;\n  }\n\n  double aspectRatio = 0.0;  // = invalid\n  ParseNumberProperty(&aspectRatio, err, o, \"aspectRatio\", false,\n                      \"PerspectiveCamera\");\n\n  double zfar = 0.0;  // = invalid\n  ParseNumberProperty(&zfar, err, o, \"zfar\", false, \"PerspectiveCamera\");\n\n  camera->aspectRatio = aspectRatio;\n  camera->zfar = zfar;\n  camera->yfov = yfov;\n  camera->znear = znear;\n\n  ParseExtensionsProperty(&camera->extensions, err, o);\n  ParseExtrasProperty(&(camera->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        camera->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        camera->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  // TODO(syoyo): Validate parameter values.\n\n  return true;\n}\n\nstatic bool ParseSpotLight(SpotLight *light, std::string *err, const json &o,\n                           bool store_original_json_for_extras_and_extensions) {\n  ParseNumberProperty(&light->innerConeAngle, err, o, \"innerConeAngle\", false);\n  ParseNumberProperty(&light->outerConeAngle, err, o, \"outerConeAngle\", false);\n\n  ParseExtensionsProperty(&light->extensions, err, o);\n  ParseExtrasProperty(&light->extras, o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        light->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        light->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  // TODO(syoyo): Validate parameter values.\n\n  return true;\n}\n\nstatic bool ParseOrthographicCamera(\n    OrthographicCamera *camera, std::string *err, const json &o,\n    bool store_original_json_for_extras_and_extensions) {\n  double xmag = 0.0;\n  if (!ParseNumberProperty(&xmag, err, o, \"xmag\", true, \"OrthographicCamera\")) {\n    return false;\n  }\n\n  double ymag = 0.0;\n  if (!ParseNumberProperty(&ymag, err, o, \"ymag\", true, \"OrthographicCamera\")) {\n    return false;\n  }\n\n  double zfar = 0.0;\n  if (!ParseNumberProperty(&zfar, err, o, \"zfar\", true, \"OrthographicCamera\")) {\n    return false;\n  }\n\n  double znear = 0.0;\n  if (!ParseNumberProperty(&znear, err, o, \"znear\", true,\n                           \"OrthographicCamera\")) {\n    return false;\n  }\n\n  ParseExtensionsProperty(&camera->extensions, err, o);\n  ParseExtrasProperty(&(camera->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        camera->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        camera->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  camera->xmag = xmag;\n  camera->ymag = ymag;\n  camera->zfar = zfar;\n  camera->znear = znear;\n\n  // TODO(syoyo): Validate parameter values.\n\n  return true;\n}\n\nstatic bool ParseCamera(Camera *camera, std::string *err, const json &o,\n                        bool store_original_json_for_extras_and_extensions) {\n  if (!ParseStringProperty(&camera->type, err, o, \"type\", true, \"Camera\")) {\n    return false;\n  }\n\n  if (camera->type.compare(\"orthographic\") == 0) {\n    json_const_iterator orthoIt;\n    if (!FindMember(o, \"orthographic\", orthoIt)) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"Orhographic camera description not found.\" << std::endl;\n        (*err) += ss.str();\n      }\n      return false;\n    }\n\n    const json &v = GetValue(orthoIt);\n    if (!IsObject(v)) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"\\\"orthographic\\\" is not a JSON object.\" << std::endl;\n        (*err) += ss.str();\n      }\n      return false;\n    }\n\n    if (!ParseOrthographicCamera(\n            &camera->orthographic, err, v,\n            store_original_json_for_extras_and_extensions)) {\n      return false;\n    }\n  } else if (camera->type.compare(\"perspective\") == 0) {\n    json_const_iterator perspIt;\n    if (!FindMember(o, \"perspective\", perspIt)) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"Perspective camera description not found.\" << std::endl;\n        (*err) += ss.str();\n      }\n      return false;\n    }\n\n    const json &v = GetValue(perspIt);\n    if (!IsObject(v)) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"\\\"perspective\\\" is not a JSON object.\" << std::endl;\n        (*err) += ss.str();\n      }\n      return false;\n    }\n\n    if (!ParsePerspectiveCamera(\n            &camera->perspective, err, v,\n            store_original_json_for_extras_and_extensions)) {\n      return false;\n    }\n  } else {\n    if (err) {\n      std::stringstream ss;\n      ss << \"Invalid camera type: \\\"\" << camera->type\n         << \"\\\". Must be \\\"perspective\\\" or \\\"orthographic\\\"\" << std::endl;\n      (*err) += ss.str();\n    }\n    return false;\n  }\n\n  ParseStringProperty(&camera->name, err, o, \"name\", false);\n\n  ParseExtensionsProperty(&camera->extensions, err, o);\n  ParseExtrasProperty(&(camera->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        camera->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        camera->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nstatic bool ParseLight(Light *light, std::string *err, const json &o,\n                       bool store_original_json_for_extras_and_extensions) {\n  if (!ParseStringProperty(&light->type, err, o, \"type\", true)) {\n    return false;\n  }\n\n  if (light->type == \"spot\") {\n    json_const_iterator spotIt;\n    if (!FindMember(o, \"spot\", spotIt)) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"Spot light description not found.\" << std::endl;\n        (*err) += ss.str();\n      }\n      return false;\n    }\n\n    const json &v = GetValue(spotIt);\n    if (!IsObject(v)) {\n      if (err) {\n        std::stringstream ss;\n        ss << \"\\\"spot\\\" is not a JSON object.\" << std::endl;\n        (*err) += ss.str();\n      }\n      return false;\n    }\n\n    if (!ParseSpotLight(&light->spot, err, v,\n                        store_original_json_for_extras_and_extensions)) {\n      return false;\n    }\n  }\n\n  ParseStringProperty(&light->name, err, o, \"name\", false);\n  ParseNumberArrayProperty(&light->color, err, o, \"color\", false);\n  ParseNumberProperty(&light->range, err, o, \"range\", false);\n  ParseNumberProperty(&light->intensity, err, o, \"intensity\", false);\n  ParseExtensionsProperty(&light->extensions, err, o);\n  ParseExtrasProperty(&(light->extras), o);\n\n  if (store_original_json_for_extras_and_extensions) {\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        light->extensions_json_string = JsonToString(GetValue(it));\n      }\n    }\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extras\", it)) {\n        light->extras_json_string = JsonToString(GetValue(it));\n      }\n    }\n  }\n\n  return true;\n}\n\nbool TinyGLTF::LoadFromString(Model *model, std::string *err, std::string *warn,\n                              const char *json_str,\n                              unsigned int json_str_length,\n                              const std::string &base_dir,\n                              unsigned int check_sections) {\n  if (json_str_length < 4) {\n    if (err) {\n      (*err) = \"JSON string too short.\\n\";\n    }\n    return false;\n  }\n\n  JsonDocument v;\n\n#if (defined(__cpp_exceptions) || defined(__EXCEPTIONS) || \\\n     defined(_CPPUNWIND)) &&                               \\\n    !defined(TINYGLTF_NOEXCEPTION)\n  try {\n    JsonParse(v, json_str, json_str_length, true);\n\n  } catch (const std::exception &e) {\n    if (err) {\n      (*err) = e.what();\n    }\n    return false;\n  }\n#else\n  {\n    JsonParse(v, json_str, json_str_length);\n\n    if (!IsObject(v)) {\n      // Assume parsing was failed.\n      if (err) {\n        (*err) = \"Failed to parse JSON object\\n\";\n      }\n      return false;\n    }\n  }\n#endif\n\n  if (!IsObject(v)) {\n    // root is not an object.\n    if (err) {\n      (*err) = \"Root element is not a JSON object\\n\";\n    }\n    return false;\n  }\n\n  {\n    bool version_found = false;\n    json_const_iterator it;\n    if (FindMember(v, \"asset\", it) && IsObject(GetValue(it))) {\n      auto &itObj = GetValue(it);\n      json_const_iterator version_it;\n      std::string versionStr;\n      if (FindMember(itObj, \"version\", version_it) &&\n          GetString(GetValue(version_it), versionStr)) {\n        version_found = true;\n      }\n    }\n    if (version_found) {\n      // OK\n    } else if (check_sections & REQUIRE_VERSION) {\n      if (err) {\n        (*err) += \"\\\"asset\\\" object not found in .gltf or not an object type\\n\";\n      }\n      return false;\n    }\n  }\n\n  // scene is not mandatory.\n  // FIXME Maybe a better way to handle it than removing the code\n\n  auto IsArrayMemberPresent = [](const json &_v, const char *name) -> bool {\n    json_const_iterator it;\n    return FindMember(_v, name, it) && IsArray(GetValue(it));\n  };\n\n  {\n    if ((check_sections & REQUIRE_SCENES) &&\n        !IsArrayMemberPresent(v, \"scenes\")) {\n      if (err) {\n        (*err) += \"\\\"scenes\\\" object not found in .gltf or not an array type\\n\";\n      }\n      return false;\n    }\n  }\n\n  {\n    if ((check_sections & REQUIRE_NODES) && !IsArrayMemberPresent(v, \"nodes\")) {\n      if (err) {\n        (*err) += \"\\\"nodes\\\" object not found in .gltf\\n\";\n      }\n      return false;\n    }\n  }\n\n  {\n    if ((check_sections & REQUIRE_ACCESSORS) &&\n        !IsArrayMemberPresent(v, \"accessors\")) {\n      if (err) {\n        (*err) += \"\\\"accessors\\\" object not found in .gltf\\n\";\n      }\n      return false;\n    }\n  }\n\n  {\n    if ((check_sections & REQUIRE_BUFFERS) &&\n        !IsArrayMemberPresent(v, \"buffers\")) {\n      if (err) {\n        (*err) += \"\\\"buffers\\\" object not found in .gltf\\n\";\n      }\n      return false;\n    }\n  }\n\n  {\n    if ((check_sections & REQUIRE_BUFFER_VIEWS) &&\n        !IsArrayMemberPresent(v, \"bufferViews\")) {\n      if (err) {\n        (*err) += \"\\\"bufferViews\\\" object not found in .gltf\\n\";\n      }\n      return false;\n    }\n  }\n\n  model->buffers.clear();\n  model->bufferViews.clear();\n  model->accessors.clear();\n  model->meshes.clear();\n  model->cameras.clear();\n  model->nodes.clear();\n  model->extensionsUsed.clear();\n  model->extensionsRequired.clear();\n  model->extensions.clear();\n  model->defaultScene = -1;\n\n  // 1. Parse Asset\n  {\n    json_const_iterator it;\n    if (FindMember(v, \"asset\", it) && IsObject(GetValue(it))) {\n      const json &root = GetValue(it);\n\n      ParseAsset(&model->asset, err, root,\n                 store_original_json_for_extras_and_extensions_);\n    }\n  }\n\n#ifdef TINYGLTF_USE_CPP14\n  auto ForEachInArray = [](const json &_v, const char *member,\n                           const auto &cb) -> bool\n#else\n  // The std::function<> implementation can be less efficient because it will\n  // allocate heap when the size of the captured lambda is above 16 bytes with\n  // clang and gcc, but it does not require C++14.\n  auto ForEachInArray = [](const json &_v, const char *member,\n                           const std::function<bool(const json &)> &cb) -> bool\n#endif\n  {\n    json_const_iterator itm;\n    if (FindMember(_v, member, itm) && IsArray(GetValue(itm))) {\n      const json &root = GetValue(itm);\n      auto it = ArrayBegin(root);\n      auto end = ArrayEnd(root);\n      for (; it != end; ++it) {\n        if (!cb(*it)) return false;\n      }\n    }\n    return true;\n  };\n\n  // 2. Parse extensionUsed\n  {\n    ForEachInArray(v, \"extensionsUsed\", [&](const json &o) {\n      std::string str;\n      GetString(o, str);\n      model->extensionsUsed.emplace_back(std::move(str));\n      return true;\n    });\n  }\n\n  {\n    ForEachInArray(v, \"extensionsRequired\", [&](const json &o) {\n      std::string str;\n      GetString(o, str);\n      model->extensionsRequired.emplace_back(std::move(str));\n      return true;\n    });\n  }\n\n  // 3. Parse Buffer\n  {\n    bool success = ForEachInArray(v, \"buffers\", [&](const json &o) {\n      if (!IsObject(o)) {\n        if (err) {\n          (*err) += \"`buffers' does not contain an JSON object.\";\n        }\n        return false;\n      }\n      Buffer buffer;\n      if (!ParseBuffer(&buffer, err, o,\n                       store_original_json_for_extras_and_extensions_, &fs,\n                       base_dir, is_binary_, bin_data_, bin_size_)) {\n        return false;\n      }\n\n      model->buffers.emplace_back(std::move(buffer));\n      return true;\n    });\n\n    if (!success) {\n      return false;\n    }\n  }\n  // 4. Parse BufferView\n  {\n    bool success = ForEachInArray(v, \"bufferViews\", [&](const json &o) {\n      if (!IsObject(o)) {\n        if (err) {\n          (*err) += \"`bufferViews' does not contain an JSON object.\";\n        }\n        return false;\n      }\n      BufferView bufferView;\n      if (!ParseBufferView(&bufferView, err, o,\n                           store_original_json_for_extras_and_extensions_)) {\n        return false;\n      }\n\n      model->bufferViews.emplace_back(std::move(bufferView));\n      return true;\n    });\n\n    if (!success) {\n      return false;\n    }\n  }\n\n  // 5. Parse Accessor\n  {\n    bool success = ForEachInArray(v, \"accessors\", [&](const json &o) {\n      if (!IsObject(o)) {\n        if (err) {\n          (*err) += \"`accessors' does not contain an JSON object.\";\n        }\n        return false;\n      }\n      Accessor accessor;\n      if (!ParseAccessor(&accessor, err, o,\n                         store_original_json_for_extras_and_extensions_)) {\n        return false;\n      }\n\n      model->accessors.emplace_back(std::move(accessor));\n      return true;\n    });\n\n    if (!success) {\n      return false;\n    }\n  }\n\n  // 6. Parse Mesh\n  {\n    bool success = ForEachInArray(v, \"meshes\", [&](const json &o) {\n      if (!IsObject(o)) {\n        if (err) {\n          (*err) += \"`meshes' does not contain an JSON object.\";\n        }\n        return false;\n      }\n      Mesh mesh;\n      if (!ParseMesh(&mesh, model, err, o,\n                     store_original_json_for_extras_and_extensions_)) {\n        return false;\n      }\n\n      model->meshes.emplace_back(std::move(mesh));\n      return true;\n    });\n\n    if (!success) {\n      return false;\n    }\n  }\n\n  // Assign missing bufferView target types\n  // - Look for missing Mesh indices\n  // - Look for missing Mesh attributes\n  for (auto &mesh : model->meshes) {\n    for (auto &primitive : mesh.primitives) {\n      if (primitive.indices >\n          -1)  // has indices from parsing step, must be Element Array Buffer\n      {\n        if (size_t(primitive.indices) >= model->accessors.size()) {\n          if (err) {\n            (*err) += \"primitive indices accessor out of bounds\";\n          }\n          return false;\n        }\n\n        auto bufferView =\n            model->accessors[size_t(primitive.indices)].bufferView;\n        if (bufferView < 0 || size_t(bufferView) >= model->bufferViews.size()) {\n          if (err) {\n            (*err) += \"accessor[\" + std::to_string(primitive.indices) +\n                      \"] invalid bufferView\";\n          }\n          return false;\n        }\n\n        model->bufferViews[size_t(bufferView)].target =\n            TINYGLTF_TARGET_ELEMENT_ARRAY_BUFFER;\n        // we could optionally check if acessors' bufferView type is Scalar, as\n        // it should be\n      }\n\n      for (auto &attribute : primitive.attributes) {\n        model\n            ->bufferViews[size_t(\n                model->accessors[size_t(attribute.second)].bufferView)]\n            .target = TINYGLTF_TARGET_ARRAY_BUFFER;\n      }\n\n      for (auto &target : primitive.targets) {\n        for (auto &attribute : target) {\n          auto bufferView =\n              model->accessors[size_t(attribute.second)].bufferView;\n          // bufferView could be null(-1) for sparse morph target\n          if (bufferView >= 0) {\n            model->bufferViews[size_t(bufferView)].target =\n                TINYGLTF_TARGET_ARRAY_BUFFER;\n          }\n        }\n      }\n    }\n  }\n\n  // 7. Parse Node\n  {\n    bool success = ForEachInArray(v, \"nodes\", [&](const json &o) {\n      if (!IsObject(o)) {\n        if (err) {\n          (*err) += \"`nodes' does not contain an JSON object.\";\n        }\n        return false;\n      }\n      Node node;\n      if (!ParseNode(&node, err, o,\n                     store_original_json_for_extras_and_extensions_)) {\n        return false;\n      }\n\n      model->nodes.emplace_back(std::move(node));\n      return true;\n    });\n\n    if (!success) {\n      return false;\n    }\n  }\n\n  // 8. Parse scenes.\n  {\n    bool success = ForEachInArray(v, \"scenes\", [&](const json &o) {\n      if (!IsObject(o)) {\n        if (err) {\n          (*err) += \"`scenes' does not contain an JSON object.\";\n        }\n        return false;\n      }\n      std::vector<int> nodes;\n      ParseIntegerArrayProperty(&nodes, err, o, \"nodes\", false);\n\n      Scene scene;\n      scene.nodes = std::move(nodes);\n\n      ParseStringProperty(&scene.name, err, o, \"name\", false);\n\n      ParseExtensionsProperty(&scene.extensions, err, o);\n      ParseExtrasProperty(&scene.extras, o);\n\n      if (store_original_json_for_extras_and_extensions_) {\n        {\n          json_const_iterator it;\n          if (FindMember(o, \"extensions\", it)) {\n            scene.extensions_json_string = JsonToString(GetValue(it));\n          }\n        }\n        {\n          json_const_iterator it;\n          if (FindMember(o, \"extras\", it)) {\n            scene.extras_json_string = JsonToString(GetValue(it));\n          }\n        }\n      }\n\n      model->scenes.emplace_back(std::move(scene));\n      return true;\n    });\n\n    if (!success) {\n      return false;\n    }\n  }\n\n  // 9. Parse default scenes.\n  {\n    json_const_iterator rootIt;\n    int iVal;\n    if (FindMember(v, \"scene\", rootIt) && GetInt(GetValue(rootIt), iVal)) {\n      model->defaultScene = iVal;\n    }\n  }\n\n  // 10. Parse Material\n  {\n    bool success = ForEachInArray(v, \"materials\", [&](const json &o) {\n      if (!IsObject(o)) {\n        if (err) {\n          (*err) += \"`materials' does not contain an JSON object.\";\n        }\n        return false;\n      }\n      Material material;\n      ParseStringProperty(&material.name, err, o, \"name\", false);\n\n      if (!ParseMaterial(&material, err, o,\n                         store_original_json_for_extras_and_extensions_)) {\n        return false;\n      }\n\n      model->materials.emplace_back(std::move(material));\n      return true;\n    });\n\n    if (!success) {\n      return false;\n    }\n  }\n\n  // 11. Parse Image\n  void *load_image_user_data{nullptr};\n\n  LoadImageDataOption load_image_option;\n\n  if (user_image_loader_) {\n    // Use user supplied pointer\n    load_image_user_data = load_image_user_data_;\n  } else {\n    load_image_option.preserve_channels = preserve_image_channels_;\n    load_image_user_data = reinterpret_cast<void *>(&load_image_option);\n  }\n\n  {\n    int idx = 0;\n    bool success = ForEachInArray(v, \"images\", [&](const json &o) {\n      if (!IsObject(o)) {\n        if (err) {\n          (*err) += \"image[\" + std::to_string(idx) + \"] is not a JSON object.\";\n        }\n        return false;\n      }\n      Image image;\n      if (!ParseImage(&image, idx, err, warn, o,\n                      store_original_json_for_extras_and_extensions_, base_dir,\n                      &fs, &this->LoadImageData, load_image_user_data)) {\n        return false;\n      }\n\n      if (image.bufferView != -1) {\n        // Load image from the buffer view.\n        if (size_t(image.bufferView) >= model->bufferViews.size()) {\n          if (err) {\n            std::stringstream ss;\n            ss << \"image[\" << idx << \"] bufferView \\\"\" << image.bufferView\n               << \"\\\" not found in the scene.\" << std::endl;\n            (*err) += ss.str();\n          }\n          return false;\n        }\n\n        const BufferView &bufferView =\n            model->bufferViews[size_t(image.bufferView)];\n        if (size_t(bufferView.buffer) >= model->buffers.size()) {\n          if (err) {\n            std::stringstream ss;\n            ss << \"image[\" << idx << \"] buffer \\\"\" << bufferView.buffer\n               << \"\\\" not found in the scene.\" << std::endl;\n            (*err) += ss.str();\n          }\n          return false;\n        }\n        const Buffer &buffer = model->buffers[size_t(bufferView.buffer)];\n\n        if (*LoadImageData == nullptr) {\n          if (err) {\n            (*err) += \"No LoadImageData callback specified.\\n\";\n          }\n          return false;\n        }\n        bool ret = LoadImageData(\n            &image, idx, err, warn, image.width, image.height,\n            &buffer.data[bufferView.byteOffset],\n            static_cast<int>(bufferView.byteLength), load_image_user_data);\n        if (!ret) {\n          return false;\n        }\n      }\n\n      model->images.emplace_back(std::move(image));\n      ++idx;\n      return true;\n    });\n\n    if (!success) {\n      return false;\n    }\n  }\n\n  // 12. Parse Texture\n  {\n    bool success = ForEachInArray(v, \"textures\", [&](const json &o) {\n      if (!IsObject(o)) {\n        if (err) {\n          (*err) += \"`textures' does not contain an JSON object.\";\n        }\n        return false;\n      }\n      Texture texture;\n      if (!ParseTexture(&texture, err, o,\n                        store_original_json_for_extras_and_extensions_,\n                        base_dir)) {\n        return false;\n      }\n\n      model->textures.emplace_back(std::move(texture));\n      return true;\n    });\n\n    if (!success) {\n      return false;\n    }\n  }\n\n  // 13. Parse Animation\n  {\n    bool success = ForEachInArray(v, \"animations\", [&](const json &o) {\n      if (!IsObject(o)) {\n        if (err) {\n          (*err) += \"`animations' does not contain an JSON object.\";\n        }\n        return false;\n      }\n      Animation animation;\n      if (!ParseAnimation(&animation, err, o,\n                          store_original_json_for_extras_and_extensions_)) {\n        return false;\n      }\n\n      model->animations.emplace_back(std::move(animation));\n      return true;\n    });\n\n    if (!success) {\n      return false;\n    }\n  }\n\n  // 14. Parse Skin\n  {\n    bool success = ForEachInArray(v, \"skins\", [&](const json &o) {\n      if (!IsObject(o)) {\n        if (err) {\n          (*err) += \"`skins' does not contain an JSON object.\";\n        }\n        return false;\n      }\n      Skin skin;\n      if (!ParseSkin(&skin, err, o,\n                     store_original_json_for_extras_and_extensions_)) {\n        return false;\n      }\n\n      model->skins.emplace_back(std::move(skin));\n      return true;\n    });\n\n    if (!success) {\n      return false;\n    }\n  }\n\n  // 15. Parse Sampler\n  {\n    bool success = ForEachInArray(v, \"samplers\", [&](const json &o) {\n      if (!IsObject(o)) {\n        if (err) {\n          (*err) += \"`samplers' does not contain an JSON object.\";\n        }\n        return false;\n      }\n      Sampler sampler;\n      if (!ParseSampler(&sampler, err, o,\n                        store_original_json_for_extras_and_extensions_)) {\n        return false;\n      }\n\n      model->samplers.emplace_back(std::move(sampler));\n      return true;\n    });\n\n    if (!success) {\n      return false;\n    }\n  }\n\n  // 16. Parse Camera\n  {\n    bool success = ForEachInArray(v, \"cameras\", [&](const json &o) {\n      if (!IsObject(o)) {\n        if (err) {\n          (*err) += \"`cameras' does not contain an JSON object.\";\n        }\n        return false;\n      }\n      Camera camera;\n      if (!ParseCamera(&camera, err, o,\n                       store_original_json_for_extras_and_extensions_)) {\n        return false;\n      }\n\n      model->cameras.emplace_back(std::move(camera));\n      return true;\n    });\n\n    if (!success) {\n      return false;\n    }\n  }\n\n  // 17. Parse Extensions\n  ParseExtensionsProperty(&model->extensions, err, v);\n\n  // 18. Specific extension implementations\n  {\n    json_const_iterator rootIt;\n    if (FindMember(v, \"extensions\", rootIt) && IsObject(GetValue(rootIt))) {\n      const json &root = GetValue(rootIt);\n\n      json_const_iterator it(ObjectBegin(root));\n      json_const_iterator itEnd(ObjectEnd(root));\n      for (; it != itEnd; ++it) {\n        // parse KHR_lights_punctual extension\n        std::string key(GetKey(it));\n        if ((key == \"KHR_lights_punctual\") && IsObject(GetValue(it))) {\n          const json &object = GetValue(it);\n          json_const_iterator itLight;\n          if (FindMember(object, \"lights\", itLight)) {\n            const json &lights = GetValue(itLight);\n            if (!IsArray(lights)) {\n              continue;\n            }\n\n            auto arrayIt(ArrayBegin(lights));\n            auto arrayItEnd(ArrayEnd(lights));\n            for (; arrayIt != arrayItEnd; ++arrayIt) {\n              Light light;\n              if (!ParseLight(&light, err, *arrayIt,\n                              store_original_json_for_extras_and_extensions_)) {\n                return false;\n              }\n              model->lights.emplace_back(std::move(light));\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // 19. Parse Extras\n  ParseExtrasProperty(&model->extras, v);\n\n  if (store_original_json_for_extras_and_extensions_) {\n    model->extras_json_string = JsonToString(v[\"extras\"]);\n    model->extensions_json_string = JsonToString(v[\"extensions\"]);\n  }\n\n  return true;\n}\n\nbool TinyGLTF::LoadASCIIFromString(Model *model, std::string *err,\n                                   std::string *warn, const char *str,\n                                   unsigned int length,\n                                   const std::string &base_dir,\n                                   unsigned int check_sections) {\n  is_binary_ = false;\n  bin_data_ = nullptr;\n  bin_size_ = 0;\n\n  return LoadFromString(model, err, warn, str, length, base_dir,\n                        check_sections);\n}\n\nbool TinyGLTF::LoadASCIIFromFile(Model *model, std::string *err,\n                                 std::string *warn, const std::string &filename,\n                                 unsigned int check_sections) {\n  std::stringstream ss;\n\n  if (fs.ReadWholeFile == nullptr) {\n    // Programmer error, assert() ?\n    ss << \"Failed to read file: \" << filename\n       << \": one or more FS callback not set\" << std::endl;\n    if (err) {\n      (*err) = ss.str();\n    }\n    return false;\n  }\n\n  std::vector<unsigned char> data;\n  std::string fileerr;\n  bool fileread = fs.ReadWholeFile(&data, &fileerr, filename, fs.user_data);\n  if (!fileread) {\n    ss << \"Failed to read file: \" << filename << \": \" << fileerr << std::endl;\n    if (err) {\n      (*err) = ss.str();\n    }\n    return false;\n  }\n\n  size_t sz = data.size();\n  if (sz == 0) {\n    if (err) {\n      (*err) = \"Empty file.\";\n    }\n    return false;\n  }\n\n  std::string basedir = GetBaseDir(filename);\n\n  bool ret = LoadASCIIFromString(\n      model, err, warn, reinterpret_cast<const char *>(&data.at(0)),\n      static_cast<unsigned int>(data.size()), basedir, check_sections);\n\n  return ret;\n}\n\nbool TinyGLTF::LoadBinaryFromMemory(Model *model, std::string *err,\n                                    std::string *warn,\n                                    const unsigned char *bytes,\n                                    unsigned int size,\n                                    const std::string &base_dir,\n                                    unsigned int check_sections) {\n  if (size < 20) {\n    if (err) {\n      (*err) = \"Too short data size for glTF Binary.\";\n    }\n    return false;\n  }\n\n  if (bytes[0] == 'g' && bytes[1] == 'l' && bytes[2] == 'T' &&\n      bytes[3] == 'F') {\n    // ok\n  } else {\n    if (err) {\n      (*err) = \"Invalid magic.\";\n    }\n    return false;\n  }\n\n  unsigned int version;       // 4 bytes\n  unsigned int length;        // 4 bytes\n  unsigned int model_length;  // 4 bytes\n  unsigned int model_format;  // 4 bytes;\n\n  // @todo { Endian swap for big endian machine. }\n  memcpy(&version, bytes + 4, 4);\n  swap4(&version);\n  memcpy(&length, bytes + 8, 4);\n  swap4(&length);\n  memcpy(&model_length, bytes + 12, 4);\n  swap4(&model_length);\n  memcpy(&model_format, bytes + 16, 4);\n  swap4(&model_format);\n\n  // In case the Bin buffer is not present, the size is exactly 20 + size of\n  // JSON contents,\n  // so use \"greater than\" operator.\n  if ((20 + model_length > size) || (model_length < 1) || (length > size) ||\n      (20 + model_length > length) ||\n      (model_format != 0x4E4F534A)) {  // 0x4E4F534A = JSON format.\n    if (err) {\n      (*err) = \"Invalid glTF binary.\";\n    }\n    return false;\n  }\n\n  // Extract JSON string.\n  std::string jsonString(reinterpret_cast<const char *>(&bytes[20]),\n                         model_length);\n\n  is_binary_ = true;\n  bin_data_ = bytes + 20 + model_length +\n              8;  // 4 bytes (buffer_length) + 4 bytes(buffer_format)\n  bin_size_ =\n      length - (20 + model_length);  // extract header + JSON scene data.\n\n  bool ret = LoadFromString(model, err, warn,\n                            reinterpret_cast<const char *>(&bytes[20]),\n                            model_length, base_dir, check_sections);\n  if (!ret) {\n    return ret;\n  }\n\n  return true;\n}\n\nbool TinyGLTF::LoadBinaryFromFile(Model *model, std::string *err,\n                                  std::string *warn,\n                                  const std::string &filename,\n                                  unsigned int check_sections) {\n  std::stringstream ss;\n\n  if (fs.ReadWholeFile == nullptr) {\n    // Programmer error, assert() ?\n    ss << \"Failed to read file: \" << filename\n       << \": one or more FS callback not set\" << std::endl;\n    if (err) {\n      (*err) = ss.str();\n    }\n    return false;\n  }\n\n  std::vector<unsigned char> data;\n  std::string fileerr;\n  bool fileread = fs.ReadWholeFile(&data, &fileerr, filename, fs.user_data);\n  if (!fileread) {\n    ss << \"Failed to read file: \" << filename << \": \" << fileerr << std::endl;\n    if (err) {\n      (*err) = ss.str();\n    }\n    return false;\n  }\n\n  std::string basedir = GetBaseDir(filename);\n\n  bool ret = LoadBinaryFromMemory(model, err, warn, &data.at(0),\n                                  static_cast<unsigned int>(data.size()),\n                                  basedir, check_sections);\n\n  return ret;\n}\n\n///////////////////////\n// GLTF Serialization\n///////////////////////\nnamespace {\njson JsonFromString(const char *s) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  return json(s, GetAllocator());\n#else\n  return json(s);\n#endif\n}\n\nvoid JsonAssign(json &dest, const json &src) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  dest.CopyFrom(src, GetAllocator());\n#else\n  dest = src;\n#endif\n}\n\nvoid JsonAddMember(json &o, const char *key, json &&value) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  if (!o.IsObject()) {\n    o.SetObject();\n  }\n  o.AddMember(json(key, GetAllocator()), std::move(value), GetAllocator());\n#else\n  o[key] = std::move(value);\n#endif\n}\n\nvoid JsonPushBack(json &o, json &&value) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  o.PushBack(std::move(value), GetAllocator());\n#else\n  o.push_back(std::move(value));\n#endif\n}\n\nbool JsonIsNull(const json &o) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  return o.IsNull();\n#else\n  return o.is_null();\n#endif\n}\n\nvoid JsonSetObject(json &o) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  o.SetObject();\n#else\n  o = o.object({});\n#endif\n}\n\nvoid JsonReserveArray(json &o, size_t s) {\n#ifdef TINYGLTF_USE_RAPIDJSON\n  o.SetArray();\n  o.Reserve(static_cast<rapidjson::SizeType>(s), GetAllocator());\n#endif\n  (void)(o);\n  (void)(s);\n}\n}  // namespace\n\n// typedef std::pair<std::string, json> json_object_pair;\n\ntemplate <typename T>\nstatic void SerializeNumberProperty(const std::string &key, T number,\n                                    json &obj) {\n  // obj.insert(\n  //    json_object_pair(key, json(static_cast<double>(number))));\n  // obj[key] = static_cast<double>(number);\n  JsonAddMember(obj, key.c_str(), json(number));\n}\n\n#ifdef TINYGLTF_USE_RAPIDJSON\ntemplate <>\nvoid SerializeNumberProperty(const std::string &key, size_t number, json &obj) {\n  JsonAddMember(obj, key.c_str(), json(static_cast<uint64_t>(number)));\n}\n#endif\n\ntemplate <typename T>\nstatic void SerializeNumberArrayProperty(const std::string &key,\n                                         const std::vector<T> &value,\n                                         json &obj) {\n  if (value.empty()) return;\n\n  json ary;\n  JsonReserveArray(ary, value.size());\n  for (const auto &s : value) {\n    JsonPushBack(ary, json(s));\n  }\n  JsonAddMember(obj, key.c_str(), std::move(ary));\n}\n\nstatic void SerializeStringProperty(const std::string &key,\n                                    const std::string &value, json &obj) {\n  JsonAddMember(obj, key.c_str(), JsonFromString(value.c_str()));\n}\n\nstatic void SerializeStringArrayProperty(const std::string &key,\n                                         const std::vector<std::string> &value,\n                                         json &obj) {\n  json ary;\n  JsonReserveArray(ary, value.size());\n  for (auto &s : value) {\n    JsonPushBack(ary, JsonFromString(s.c_str()));\n  }\n  JsonAddMember(obj, key.c_str(), std::move(ary));\n}\n\nstatic bool ValueToJson(const Value &value, json *ret) {\n  json obj;\n#ifdef TINYGLTF_USE_RAPIDJSON\n  switch (value.Type()) {\n    case REAL_TYPE:\n      obj.SetDouble(value.Get<double>());\n      break;\n    case INT_TYPE:\n      obj.SetInt(value.Get<int>());\n      break;\n    case BOOL_TYPE:\n      obj.SetBool(value.Get<bool>());\n      break;\n    case STRING_TYPE:\n      obj.SetString(value.Get<std::string>().c_str(), GetAllocator());\n      break;\n    case ARRAY_TYPE: {\n      obj.SetArray();\n      obj.Reserve(static_cast<rapidjson::SizeType>(value.ArrayLen()),\n                  GetAllocator());\n      for (unsigned int i = 0; i < value.ArrayLen(); ++i) {\n        Value elementValue = value.Get(int(i));\n        json elementJson;\n        if (ValueToJson(value.Get(int(i)), &elementJson))\n          obj.PushBack(std::move(elementJson), GetAllocator());\n      }\n      break;\n    }\n    case BINARY_TYPE:\n      // TODO\n      // obj = json(value.Get<std::vector<unsigned char>>());\n      return false;\n      break;\n    case OBJECT_TYPE: {\n      obj.SetObject();\n      Value::Object objMap = value.Get<Value::Object>();\n      for (auto &it : objMap) {\n        json elementJson;\n        if (ValueToJson(it.second, &elementJson)) {\n          obj.AddMember(json(it.first.c_str(), GetAllocator()),\n                        std::move(elementJson), GetAllocator());\n        }\n      }\n      break;\n    }\n    case NULL_TYPE:\n    default:\n      return false;\n  }\n#else\n  switch (value.Type()) {\n    case REAL_TYPE:\n      obj = json(value.Get<double>());\n      break;\n    case INT_TYPE:\n      obj = json(value.Get<int>());\n      break;\n    case BOOL_TYPE:\n      obj = json(value.Get<bool>());\n      break;\n    case STRING_TYPE:\n      obj = json(value.Get<std::string>());\n      break;\n    case ARRAY_TYPE: {\n      for (unsigned int i = 0; i < value.ArrayLen(); ++i) {\n        Value elementValue = value.Get(int(i));\n        json elementJson;\n        if (ValueToJson(value.Get(int(i)), &elementJson))\n          obj.push_back(elementJson);\n      }\n      break;\n    }\n    case BINARY_TYPE:\n      // TODO\n      // obj = json(value.Get<std::vector<unsigned char>>());\n      return false;\n      break;\n    case OBJECT_TYPE: {\n      Value::Object objMap = value.Get<Value::Object>();\n      for (auto &it : objMap) {\n        json elementJson;\n        if (ValueToJson(it.second, &elementJson)) obj[it.first] = elementJson;\n      }\n      break;\n    }\n    case NULL_TYPE:\n    default:\n      return false;\n  }\n#endif\n  if (ret) *ret = std::move(obj);\n  return true;\n}\n\nstatic void SerializeValue(const std::string &key, const Value &value,\n                           json &obj) {\n  json ret;\n  if (ValueToJson(value, &ret)) {\n    JsonAddMember(obj, key.c_str(), std::move(ret));\n  }\n}\n\nstatic void SerializeGltfBufferData(const std::vector<unsigned char> &data,\n                                    json &o) {\n  std::string header = \"data:application/octet-stream;base64,\";\n  if (data.size() > 0) {\n    std::string encodedData =\n        base64_encode(&data[0], static_cast<unsigned int>(data.size()));\n    SerializeStringProperty(\"uri\", header + encodedData, o);\n  } else {\n    // Issue #229\n    // size 0 is allowd. Just emit mime header.\n    SerializeStringProperty(\"uri\", header, o);\n  }\n}\n\nstatic bool SerializeGltfBufferData(const std::vector<unsigned char> &data,\n                                    const std::string &binFilename) {\n#ifdef _WIN32\n#if defined(__GLIBCXX__)  // mingw\n  int file_descriptor = _wopen(UTF8ToWchar(binFilename).c_str(),\n                               _O_CREAT | _O_WRONLY | _O_TRUNC | _O_BINARY);\n  __gnu_cxx::stdio_filebuf<char> wfile_buf(\n      file_descriptor, std::ios_base::out | std::ios_base::binary);\n  std::ostream output(&wfile_buf);\n  if (!wfile_buf.is_open()) return false;\n#elif defined(_MSC_VER)\n  std::ofstream output(UTF8ToWchar(binFilename).c_str(), std::ofstream::binary);\n  if (!output.is_open()) return false;\n#else\n  std::ofstream output(binFilename.c_str(), std::ofstream::binary);\n  if (!output.is_open()) return false;\n#endif\n#else\n  std::ofstream output(binFilename.c_str(), std::ofstream::binary);\n  if (!output.is_open()) return false;\n#endif\n  if (data.size() > 0) {\n    output.write(reinterpret_cast<const char *>(&data[0]),\n                 std::streamsize(data.size()));\n  } else {\n    // Issue #229\n    // size 0 will be still valid buffer data.\n    // write empty file.\n  }\n  return true;\n}\n\n#if 0  // FIXME(syoyo): not used. will be removed in the future release.\nstatic void SerializeParameterMap(ParameterMap &param, json &o) {\n  for (ParameterMap::iterator paramIt = param.begin(); paramIt != param.end();\n       ++paramIt) {\n    if (paramIt->second.number_array.size()) {\n      SerializeNumberArrayProperty<double>(paramIt->first,\n                                           paramIt->second.number_array, o);\n    } else if (paramIt->second.json_double_value.size()) {\n      json json_double_value;\n      for (std::map<std::string, double>::iterator it =\n               paramIt->second.json_double_value.begin();\n           it != paramIt->second.json_double_value.end(); ++it) {\n        if (it->first == \"index\") {\n          json_double_value[it->first] = paramIt->second.TextureIndex();\n        } else {\n          json_double_value[it->first] = it->second;\n        }\n      }\n\n      o[paramIt->first] = json_double_value;\n    } else if (!paramIt->second.string_value.empty()) {\n      SerializeStringProperty(paramIt->first, paramIt->second.string_value, o);\n    } else if (paramIt->second.has_number_value) {\n      o[paramIt->first] = paramIt->second.number_value;\n    } else {\n      o[paramIt->first] = paramIt->second.bool_value;\n    }\n  }\n}\n#endif\n\nstatic void SerializeExtensionMap(const ExtensionMap &extensions, json &o) {\n  if (!extensions.size()) return;\n\n  json extMap;\n  for (ExtensionMap::const_iterator extIt = extensions.begin();\n       extIt != extensions.end(); ++extIt) {\n    // Allow an empty object for extension(#97)\n    json ret;\n    bool isNull = true;\n    if (ValueToJson(extIt->second, &ret)) {\n      isNull = JsonIsNull(ret);\n      JsonAddMember(extMap, extIt->first.c_str(), std::move(ret));\n    }\n    if (isNull) {\n      if (!(extIt->first.empty())) {  // name should not be empty, but for sure\n        // create empty object so that an extension name is still included in\n        // json.\n        json empty;\n        JsonSetObject(empty);\n        JsonAddMember(extMap, extIt->first.c_str(), std::move(empty));\n      }\n    }\n  }\n  JsonAddMember(o, \"extensions\", std::move(extMap));\n}\n\nstatic void SerializeGltfAccessor(Accessor &accessor, json &o) {\n  if (accessor.bufferView >= 0)\n    SerializeNumberProperty<int>(\"bufferView\", accessor.bufferView, o);\n\n  if (accessor.byteOffset != 0)\n    SerializeNumberProperty<int>(\"byteOffset\", int(accessor.byteOffset), o);\n\n  SerializeNumberProperty<int>(\"componentType\", accessor.componentType, o);\n  SerializeNumberProperty<size_t>(\"count\", accessor.count, o);\n\n  if ((accessor.componentType == TINYGLTF_COMPONENT_TYPE_FLOAT) ||\n      (accessor.componentType == TINYGLTF_COMPONENT_TYPE_DOUBLE)) {\n    SerializeNumberArrayProperty<double>(\"min\", accessor.minValues, o);\n    SerializeNumberArrayProperty<double>(\"max\", accessor.maxValues, o);\n  } else {\n    // Issue #301. Serialize as integer.\n    // Assume int value is within [-2**31-1, 2**31-1]\n    {\n      std::vector<int> values;\n      std::transform(accessor.minValues.begin(), accessor.minValues.end(),\n                     std::back_inserter(values),\n                     [](double v) { return static_cast<int>(v); });\n\n      SerializeNumberArrayProperty<int>(\"min\", values, o);\n    }\n\n    {\n      std::vector<int> values;\n      std::transform(accessor.maxValues.begin(), accessor.maxValues.end(),\n                     std::back_inserter(values),\n                     [](double v) { return static_cast<int>(v); });\n\n      SerializeNumberArrayProperty<int>(\"max\", values, o);\n    }\n  }\n\n  if (accessor.normalized)\n    SerializeValue(\"normalized\", Value(accessor.normalized), o);\n  std::string type;\n  switch (accessor.type) {\n    case TINYGLTF_TYPE_SCALAR:\n      type = \"SCALAR\";\n      break;\n    case TINYGLTF_TYPE_VEC2:\n      type = \"VEC2\";\n      break;\n    case TINYGLTF_TYPE_VEC3:\n      type = \"VEC3\";\n      break;\n    case TINYGLTF_TYPE_VEC4:\n      type = \"VEC4\";\n      break;\n    case TINYGLTF_TYPE_MAT2:\n      type = \"MAT2\";\n      break;\n    case TINYGLTF_TYPE_MAT3:\n      type = \"MAT3\";\n      break;\n    case TINYGLTF_TYPE_MAT4:\n      type = \"MAT4\";\n      break;\n  }\n\n  SerializeStringProperty(\"type\", type, o);\n  if (!accessor.name.empty()) SerializeStringProperty(\"name\", accessor.name, o);\n\n  if (accessor.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", accessor.extras, o);\n  }\n}\n\nstatic void SerializeGltfAnimationChannel(AnimationChannel &channel, json &o) {\n  SerializeNumberProperty(\"sampler\", channel.sampler, o);\n  {\n    json target;\n    SerializeNumberProperty(\"node\", channel.target_node, target);\n    SerializeStringProperty(\"path\", channel.target_path, target);\n\n    SerializeExtensionMap(channel.target_extensions, target);\n\n    JsonAddMember(o, \"target\", std::move(target));\n  }\n\n  if (channel.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", channel.extras, o);\n  }\n\n  SerializeExtensionMap(channel.extensions, o);\n}\n\nstatic void SerializeGltfAnimationSampler(AnimationSampler &sampler, json &o) {\n  SerializeNumberProperty(\"input\", sampler.input, o);\n  SerializeNumberProperty(\"output\", sampler.output, o);\n  SerializeStringProperty(\"interpolation\", sampler.interpolation, o);\n\n  if (sampler.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", sampler.extras, o);\n  }\n}\n\nstatic void SerializeGltfAnimation(Animation &animation, json &o) {\n  if (!animation.name.empty())\n    SerializeStringProperty(\"name\", animation.name, o);\n\n  {\n    json channels;\n    JsonReserveArray(channels, animation.channels.size());\n    for (unsigned int i = 0; i < animation.channels.size(); ++i) {\n      json channel;\n      AnimationChannel gltfChannel = animation.channels[i];\n      SerializeGltfAnimationChannel(gltfChannel, channel);\n      JsonPushBack(channels, std::move(channel));\n    }\n\n    JsonAddMember(o, \"channels\", std::move(channels));\n  }\n\n  {\n    json samplers;\n    JsonReserveArray(samplers, animation.samplers.size());\n    for (unsigned int i = 0; i < animation.samplers.size(); ++i) {\n      json sampler;\n      AnimationSampler gltfSampler = animation.samplers[i];\n      SerializeGltfAnimationSampler(gltfSampler, sampler);\n      JsonPushBack(samplers, std::move(sampler));\n    }\n    JsonAddMember(o, \"samplers\", std::move(samplers));\n  }\n\n  if (animation.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", animation.extras, o);\n  }\n\n  SerializeExtensionMap(animation.extensions, o);\n}\n\nstatic void SerializeGltfAsset(Asset &asset, json &o) {\n  if (!asset.generator.empty()) {\n    SerializeStringProperty(\"generator\", asset.generator, o);\n  }\n\n  if (!asset.copyright.empty()) {\n    SerializeStringProperty(\"copyright\", asset.copyright, o);\n  }\n\n  if (asset.version.empty()) {\n    // Just in case\n    // `version` must be defined\n    asset.version = \"2.0\";\n  }\n\n  // TODO(syoyo): Do we need to check if `version` is greater or equal to 2.0?\n  SerializeStringProperty(\"version\", asset.version, o);\n\n  if (asset.extras.Keys().size()) {\n    SerializeValue(\"extras\", asset.extras, o);\n  }\n\n  SerializeExtensionMap(asset.extensions, o);\n}\n\nstatic void SerializeGltfBufferBin(Buffer &buffer, json &o,\n                                   std::vector<unsigned char> &binBuffer) {\n  SerializeNumberProperty(\"byteLength\", buffer.data.size(), o);\n  binBuffer = buffer.data;\n\n  if (buffer.name.size()) SerializeStringProperty(\"name\", buffer.name, o);\n\n  if (buffer.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", buffer.extras, o);\n  }\n}\n\nstatic void SerializeGltfBuffer(Buffer &buffer, json &o) {\n  SerializeNumberProperty(\"byteLength\", buffer.data.size(), o);\n  SerializeGltfBufferData(buffer.data, o);\n\n  if (buffer.name.size()) SerializeStringProperty(\"name\", buffer.name, o);\n\n  if (buffer.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", buffer.extras, o);\n  }\n}\n\nstatic bool SerializeGltfBuffer(Buffer &buffer, json &o,\n                                const std::string &binFilename,\n                                const std::string &binBaseFilename) {\n  if (!SerializeGltfBufferData(buffer.data, binFilename)) return false;\n  SerializeNumberProperty(\"byteLength\", buffer.data.size(), o);\n  SerializeStringProperty(\"uri\", binBaseFilename, o);\n\n  if (buffer.name.size()) SerializeStringProperty(\"name\", buffer.name, o);\n\n  if (buffer.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", buffer.extras, o);\n  }\n  return true;\n}\n\nstatic void SerializeGltfBufferView(BufferView &bufferView, json &o) {\n  SerializeNumberProperty(\"buffer\", bufferView.buffer, o);\n  SerializeNumberProperty<size_t>(\"byteLength\", bufferView.byteLength, o);\n\n  // byteStride is optional, minimum allowed is 4\n  if (bufferView.byteStride >= 4) {\n    SerializeNumberProperty<size_t>(\"byteStride\", bufferView.byteStride, o);\n  }\n  // byteOffset is optional, default is 0\n  if (bufferView.byteOffset > 0) {\n    SerializeNumberProperty<size_t>(\"byteOffset\", bufferView.byteOffset, o);\n  }\n  // Target is optional, check if it contains a valid value\n  if (bufferView.target == TINYGLTF_TARGET_ARRAY_BUFFER ||\n      bufferView.target == TINYGLTF_TARGET_ELEMENT_ARRAY_BUFFER) {\n    SerializeNumberProperty(\"target\", bufferView.target, o);\n  }\n  if (bufferView.name.size()) {\n    SerializeStringProperty(\"name\", bufferView.name, o);\n  }\n\n  if (bufferView.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", bufferView.extras, o);\n  }\n}\n\nstatic void SerializeGltfImage(Image &image, json &o) {\n  // if uri empty, the mimeType and bufferview should be set\n  if (image.uri.empty()) {\n    SerializeStringProperty(\"mimeType\", image.mimeType, o);\n    SerializeNumberProperty<int>(\"bufferView\", image.bufferView, o);\n  } else {\n    // TODO(syoyo): dlib::urilencode?\n    SerializeStringProperty(\"uri\", image.uri, o);\n  }\n\n  if (image.name.size()) {\n    SerializeStringProperty(\"name\", image.name, o);\n  }\n\n  if (image.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", image.extras, o);\n  }\n\n  SerializeExtensionMap(image.extensions, o);\n}\n\nstatic void SerializeGltfTextureInfo(TextureInfo &texinfo, json &o) {\n  SerializeNumberProperty(\"index\", texinfo.index, o);\n\n  if (texinfo.texCoord != 0) {\n    SerializeNumberProperty(\"texCoord\", texinfo.texCoord, o);\n  }\n\n  if (texinfo.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", texinfo.extras, o);\n  }\n\n  SerializeExtensionMap(texinfo.extensions, o);\n}\n\nstatic void SerializeGltfNormalTextureInfo(NormalTextureInfo &texinfo,\n                                           json &o) {\n  SerializeNumberProperty(\"index\", texinfo.index, o);\n\n  if (texinfo.texCoord != 0) {\n    SerializeNumberProperty(\"texCoord\", texinfo.texCoord, o);\n  }\n\n  if (!TINYGLTF_DOUBLE_EQUAL(texinfo.scale, 1.0)) {\n    SerializeNumberProperty(\"scale\", texinfo.scale, o);\n  }\n\n  if (texinfo.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", texinfo.extras, o);\n  }\n\n  SerializeExtensionMap(texinfo.extensions, o);\n}\n\nstatic void SerializeGltfOcclusionTextureInfo(OcclusionTextureInfo &texinfo,\n                                              json &o) {\n  SerializeNumberProperty(\"index\", texinfo.index, o);\n\n  if (texinfo.texCoord != 0) {\n    SerializeNumberProperty(\"texCoord\", texinfo.texCoord, o);\n  }\n\n  if (!TINYGLTF_DOUBLE_EQUAL(texinfo.strength, 1.0)) {\n    SerializeNumberProperty(\"strength\", texinfo.strength, o);\n  }\n\n  if (texinfo.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", texinfo.extras, o);\n  }\n\n  SerializeExtensionMap(texinfo.extensions, o);\n}\n\nstatic void SerializeGltfPbrMetallicRoughness(PbrMetallicRoughness &pbr,\n                                              json &o) {\n  std::vector<double> default_baseColorFactor = {1.0, 1.0, 1.0, 1.0};\n  if (!Equals(pbr.baseColorFactor, default_baseColorFactor)) {\n    SerializeNumberArrayProperty<double>(\"baseColorFactor\", pbr.baseColorFactor,\n                                         o);\n  }\n\n  if (!TINYGLTF_DOUBLE_EQUAL(pbr.metallicFactor, 1.0)) {\n    SerializeNumberProperty(\"metallicFactor\", pbr.metallicFactor, o);\n  }\n\n  if (!TINYGLTF_DOUBLE_EQUAL(pbr.roughnessFactor, 1.0)) {\n    SerializeNumberProperty(\"roughnessFactor\", pbr.roughnessFactor, o);\n  }\n\n  if (pbr.baseColorTexture.index > -1) {\n    json texinfo;\n    SerializeGltfTextureInfo(pbr.baseColorTexture, texinfo);\n    JsonAddMember(o, \"baseColorTexture\", std::move(texinfo));\n  }\n\n  if (pbr.metallicRoughnessTexture.index > -1) {\n    json texinfo;\n    SerializeGltfTextureInfo(pbr.metallicRoughnessTexture, texinfo);\n    JsonAddMember(o, \"metallicRoughnessTexture\", std::move(texinfo));\n  }\n\n  SerializeExtensionMap(pbr.extensions, o);\n\n  if (pbr.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", pbr.extras, o);\n  }\n}\n\nstatic void SerializeGltfMaterial(Material &material, json &o) {\n  if (material.name.size()) {\n    SerializeStringProperty(\"name\", material.name, o);\n  }\n\n  // QUESTION(syoyo): Write material parameters regardless of its default value?\n\n  if (!TINYGLTF_DOUBLE_EQUAL(material.alphaCutoff, 0.5)) {\n    SerializeNumberProperty(\"alphaCutoff\", material.alphaCutoff, o);\n  }\n\n  if (material.alphaMode.compare(\"OPAQUE\") != 0) {\n    SerializeStringProperty(\"alphaMode\", material.alphaMode, o);\n  }\n\n  if (material.doubleSided != false)\n    JsonAddMember(o, \"doubleSided\", json(material.doubleSided));\n\n  if (material.normalTexture.index > -1) {\n    json texinfo;\n    SerializeGltfNormalTextureInfo(material.normalTexture, texinfo);\n    JsonAddMember(o, \"normalTexture\", std::move(texinfo));\n  }\n\n  if (material.occlusionTexture.index > -1) {\n    json texinfo;\n    SerializeGltfOcclusionTextureInfo(material.occlusionTexture, texinfo);\n    JsonAddMember(o, \"occlusionTexture\", std::move(texinfo));\n  }\n\n  if (material.emissiveTexture.index > -1) {\n    json texinfo;\n    SerializeGltfTextureInfo(material.emissiveTexture, texinfo);\n    JsonAddMember(o, \"emissiveTexture\", std::move(texinfo));\n  }\n\n  std::vector<double> default_emissiveFactor = {0.0, 0.0, 0.0};\n  if (!Equals(material.emissiveFactor, default_emissiveFactor)) {\n    SerializeNumberArrayProperty<double>(\"emissiveFactor\",\n                                         material.emissiveFactor, o);\n  }\n\n  {\n    json pbrMetallicRoughness;\n    SerializeGltfPbrMetallicRoughness(material.pbrMetallicRoughness,\n                                      pbrMetallicRoughness);\n    // Issue 204\n    // Do not serialize `pbrMetallicRoughness` if pbrMetallicRoughness has all\n    // default values(json is null). Otherwise it will serialize to\n    // `pbrMetallicRoughness : null`, which cannot be read by other glTF\n    // importers(and validators).\n    //\n    if (!JsonIsNull(pbrMetallicRoughness)) {\n      JsonAddMember(o, \"pbrMetallicRoughness\", std::move(pbrMetallicRoughness));\n    }\n  }\n\n#if 0  // legacy way. just for the record.\n  if (material.values.size()) {\n    json pbrMetallicRoughness;\n    SerializeParameterMap(material.values, pbrMetallicRoughness);\n    JsonAddMember(o, \"pbrMetallicRoughness\", std::move(pbrMetallicRoughness));\n  }\n\n  SerializeParameterMap(material.additionalValues, o);\n#else\n\n#endif\n\n  SerializeExtensionMap(material.extensions, o);\n\n  if (material.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", material.extras, o);\n  }\n}\n\nstatic void SerializeGltfMesh(Mesh &mesh, json &o) {\n  json primitives;\n  JsonReserveArray(primitives, mesh.primitives.size());\n  for (unsigned int i = 0; i < mesh.primitives.size(); ++i) {\n    json primitive;\n    const Primitive &gltfPrimitive = mesh.primitives[i];  // don't make a copy\n    {\n      json attributes;\n      for (auto attrIt = gltfPrimitive.attributes.begin();\n           attrIt != gltfPrimitive.attributes.end(); ++attrIt) {\n        SerializeNumberProperty<int>(attrIt->first, attrIt->second, attributes);\n      }\n\n      JsonAddMember(primitive, \"attributes\", std::move(attributes));\n    }\n\n    // Indicies is optional\n    if (gltfPrimitive.indices > -1) {\n      SerializeNumberProperty<int>(\"indices\", gltfPrimitive.indices, primitive);\n    }\n    // Material is optional\n    if (gltfPrimitive.material > -1) {\n      SerializeNumberProperty<int>(\"material\", gltfPrimitive.material,\n                                   primitive);\n    }\n    SerializeNumberProperty<int>(\"mode\", gltfPrimitive.mode, primitive);\n\n    // Morph targets\n    if (gltfPrimitive.targets.size()) {\n      json targets;\n      JsonReserveArray(targets, gltfPrimitive.targets.size());\n      for (unsigned int k = 0; k < gltfPrimitive.targets.size(); ++k) {\n        json targetAttributes;\n        std::map<std::string, int> targetData = gltfPrimitive.targets[k];\n        for (std::map<std::string, int>::iterator attrIt = targetData.begin();\n             attrIt != targetData.end(); ++attrIt) {\n          SerializeNumberProperty<int>(attrIt->first, attrIt->second,\n                                       targetAttributes);\n        }\n        JsonPushBack(targets, std::move(targetAttributes));\n      }\n      JsonAddMember(primitive, \"targets\", std::move(targets));\n    }\n\n    SerializeExtensionMap(gltfPrimitive.extensions, primitive);\n\n    if (gltfPrimitive.extras.Type() != NULL_TYPE) {\n      SerializeValue(\"extras\", gltfPrimitive.extras, primitive);\n    }\n\n    JsonPushBack(primitives, std::move(primitive));\n  }\n\n  JsonAddMember(o, \"primitives\", std::move(primitives));\n\n  if (mesh.weights.size()) {\n    SerializeNumberArrayProperty<double>(\"weights\", mesh.weights, o);\n  }\n\n  if (mesh.name.size()) {\n    SerializeStringProperty(\"name\", mesh.name, o);\n  }\n\n  SerializeExtensionMap(mesh.extensions, o);\n  if (mesh.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", mesh.extras, o);\n  }\n}\n\nstatic void SerializeSpotLight(SpotLight &spot, json &o) {\n  SerializeNumberProperty(\"innerConeAngle\", spot.innerConeAngle, o);\n  SerializeNumberProperty(\"outerConeAngle\", spot.outerConeAngle, o);\n  SerializeExtensionMap(spot.extensions, o);\n  if (spot.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", spot.extras, o);\n  }\n}\n\nstatic void SerializeGltfLight(Light &light, json &o) {\n  if (!light.name.empty()) SerializeStringProperty(\"name\", light.name, o);\n  SerializeNumberProperty(\"intensity\", light.intensity, o);\n  if (light.range > 0.0) {\n    SerializeNumberProperty(\"range\", light.range, o);\n  }\n  SerializeNumberArrayProperty(\"color\", light.color, o);\n  SerializeStringProperty(\"type\", light.type, o);\n  if (light.type == \"spot\") {\n    json spot;\n    SerializeSpotLight(light.spot, spot);\n    JsonAddMember(o, \"spot\", std::move(spot));\n  }\n  SerializeExtensionMap(light.extensions, o);\n  if (light.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", light.extras, o);\n  }\n}\n\nstatic void SerializeGltfNode(Node &node, json &o) {\n  if (node.translation.size() > 0) {\n    SerializeNumberArrayProperty<double>(\"translation\", node.translation, o);\n  }\n  if (node.rotation.size() > 0) {\n    SerializeNumberArrayProperty<double>(\"rotation\", node.rotation, o);\n  }\n  if (node.scale.size() > 0) {\n    SerializeNumberArrayProperty<double>(\"scale\", node.scale, o);\n  }\n  if (node.matrix.size() > 0) {\n    SerializeNumberArrayProperty<double>(\"matrix\", node.matrix, o);\n  }\n  if (node.mesh != -1) {\n    SerializeNumberProperty<int>(\"mesh\", node.mesh, o);\n  }\n\n  if (node.skin != -1) {\n    SerializeNumberProperty<int>(\"skin\", node.skin, o);\n  }\n\n  if (node.camera != -1) {\n    SerializeNumberProperty<int>(\"camera\", node.camera, o);\n  }\n\n  if (node.weights.size() > 0) {\n    SerializeNumberArrayProperty<double>(\"weights\", node.weights, o);\n  }\n\n  if (node.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", node.extras, o);\n  }\n\n  SerializeExtensionMap(node.extensions, o);\n  if (!node.name.empty()) SerializeStringProperty(\"name\", node.name, o);\n  SerializeNumberArrayProperty<int>(\"children\", node.children, o);\n}\n\nstatic void SerializeGltfSampler(Sampler &sampler, json &o) {\n  if (sampler.magFilter != -1) {\n    SerializeNumberProperty(\"magFilter\", sampler.magFilter, o);\n  }\n  if (sampler.minFilter != -1) {\n    SerializeNumberProperty(\"minFilter\", sampler.minFilter, o);\n  }\n  // SerializeNumberProperty(\"wrapR\", sampler.wrapR, o);\n  SerializeNumberProperty(\"wrapS\", sampler.wrapS, o);\n  SerializeNumberProperty(\"wrapT\", sampler.wrapT, o);\n\n  if (sampler.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", sampler.extras, o);\n  }\n}\n\nstatic void SerializeGltfOrthographicCamera(const OrthographicCamera &camera,\n                                            json &o) {\n  SerializeNumberProperty(\"zfar\", camera.zfar, o);\n  SerializeNumberProperty(\"znear\", camera.znear, o);\n  SerializeNumberProperty(\"xmag\", camera.xmag, o);\n  SerializeNumberProperty(\"ymag\", camera.ymag, o);\n\n  if (camera.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", camera.extras, o);\n  }\n}\n\nstatic void SerializeGltfPerspectiveCamera(const PerspectiveCamera &camera,\n                                           json &o) {\n  SerializeNumberProperty(\"zfar\", camera.zfar, o);\n  SerializeNumberProperty(\"znear\", camera.znear, o);\n  if (camera.aspectRatio > 0) {\n    SerializeNumberProperty(\"aspectRatio\", camera.aspectRatio, o);\n  }\n\n  if (camera.yfov > 0) {\n    SerializeNumberProperty(\"yfov\", camera.yfov, o);\n  }\n\n  if (camera.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", camera.extras, o);\n  }\n}\n\nstatic void SerializeGltfCamera(const Camera &camera, json &o) {\n  SerializeStringProperty(\"type\", camera.type, o);\n  if (!camera.name.empty()) {\n    SerializeStringProperty(\"name\", camera.name, o);\n  }\n\n  if (camera.type.compare(\"orthographic\") == 0) {\n    json orthographic;\n    SerializeGltfOrthographicCamera(camera.orthographic, orthographic);\n    JsonAddMember(o, \"orthographic\", std::move(orthographic));\n  } else if (camera.type.compare(\"perspective\") == 0) {\n    json perspective;\n    SerializeGltfPerspectiveCamera(camera.perspective, perspective);\n    JsonAddMember(o, \"perspective\", std::move(perspective));\n  } else {\n    // ???\n  }\n\n  if (camera.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", camera.extras, o);\n  }\n  SerializeExtensionMap(camera.extensions, o);\n}\n\nstatic void SerializeGltfScene(Scene &scene, json &o) {\n  SerializeNumberArrayProperty<int>(\"nodes\", scene.nodes, o);\n\n  if (scene.name.size()) {\n    SerializeStringProperty(\"name\", scene.name, o);\n  }\n  if (scene.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", scene.extras, o);\n  }\n  SerializeExtensionMap(scene.extensions, o);\n}\n\nstatic void SerializeGltfSkin(Skin &skin, json &o) {\n  // required\n  SerializeNumberArrayProperty<int>(\"joints\", skin.joints, o);\n\n  if (skin.inverseBindMatrices >= 0) {\n    SerializeNumberProperty(\"inverseBindMatrices\", skin.inverseBindMatrices, o);\n  }\n\n  if (skin.skeleton >= 0) {\n    SerializeNumberProperty(\"skeleton\", skin.skeleton, o);\n  }\n\n  if (skin.name.size()) {\n    SerializeStringProperty(\"name\", skin.name, o);\n  }\n}\n\nstatic void SerializeGltfTexture(Texture &texture, json &o) {\n  if (texture.sampler > -1) {\n    SerializeNumberProperty(\"sampler\", texture.sampler, o);\n  }\n  if (texture.source > -1) {\n    SerializeNumberProperty(\"source\", texture.source, o);\n  }\n  if (texture.name.size()) {\n    SerializeStringProperty(\"name\", texture.name, o);\n  }\n  if (texture.extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", texture.extras, o);\n  }\n  SerializeExtensionMap(texture.extensions, o);\n}\n\n///\n/// Serialize all properties except buffers and images.\n///\nstatic void SerializeGltfModel(Model *model, json &o) {\n  // ACCESSORS\n  if (model->accessors.size()) {\n    json accessors;\n    JsonReserveArray(accessors, model->accessors.size());\n    for (unsigned int i = 0; i < model->accessors.size(); ++i) {\n      json accessor;\n      SerializeGltfAccessor(model->accessors[i], accessor);\n      JsonPushBack(accessors, std::move(accessor));\n    }\n    JsonAddMember(o, \"accessors\", std::move(accessors));\n  }\n\n  // ANIMATIONS\n  if (model->animations.size()) {\n    json animations;\n    JsonReserveArray(animations, model->animations.size());\n    for (unsigned int i = 0; i < model->animations.size(); ++i) {\n      if (model->animations[i].channels.size()) {\n        json animation;\n        SerializeGltfAnimation(model->animations[i], animation);\n        JsonPushBack(animations, std::move(animation));\n      }\n    }\n\n    JsonAddMember(o, \"animations\", std::move(animations));\n  }\n\n  // ASSET\n  json asset;\n  SerializeGltfAsset(model->asset, asset);\n  JsonAddMember(o, \"asset\", std::move(asset));\n\n  // BUFFERVIEWS\n  if (model->bufferViews.size()) {\n    json bufferViews;\n    JsonReserveArray(bufferViews, model->bufferViews.size());\n    for (unsigned int i = 0; i < model->bufferViews.size(); ++i) {\n      json bufferView;\n      SerializeGltfBufferView(model->bufferViews[i], bufferView);\n      JsonPushBack(bufferViews, std::move(bufferView));\n    }\n    JsonAddMember(o, \"bufferViews\", std::move(bufferViews));\n  }\n\n  // Extensions required\n  if (model->extensionsRequired.size()) {\n    SerializeStringArrayProperty(\"extensionsRequired\",\n                                 model->extensionsRequired, o);\n  }\n\n  // MATERIALS\n  if (model->materials.size()) {\n    json materials;\n    JsonReserveArray(materials, model->materials.size());\n    for (unsigned int i = 0; i < model->materials.size(); ++i) {\n      json material;\n      SerializeGltfMaterial(model->materials[i], material);\n\n      if (JsonIsNull(material)) {\n        // Issue 294.\n        // `material` does not have any required parameters\n        // so the result may be null(unmodified) when all material parameters\n        // have default value.\n        //\n        // null is not allowed thus we create an empty JSON object.\n        JsonSetObject(material);\n      }\n      JsonPushBack(materials, std::move(material));\n    }\n    JsonAddMember(o, \"materials\", std::move(materials));\n  }\n\n  // MESHES\n  if (model->meshes.size()) {\n    json meshes;\n    JsonReserveArray(meshes, model->meshes.size());\n    for (unsigned int i = 0; i < model->meshes.size(); ++i) {\n      json mesh;\n      SerializeGltfMesh(model->meshes[i], mesh);\n      JsonPushBack(meshes, std::move(mesh));\n    }\n    JsonAddMember(o, \"meshes\", std::move(meshes));\n  }\n\n  // NODES\n  if (model->nodes.size()) {\n    json nodes;\n    JsonReserveArray(nodes, model->nodes.size());\n    for (unsigned int i = 0; i < model->nodes.size(); ++i) {\n      json node;\n      SerializeGltfNode(model->nodes[i], node);\n      JsonPushBack(nodes, std::move(node));\n    }\n    JsonAddMember(o, \"nodes\", std::move(nodes));\n  }\n\n  // SCENE\n  if (model->defaultScene > -1) {\n    SerializeNumberProperty<int>(\"scene\", model->defaultScene, o);\n  }\n\n  // SCENES\n  if (model->scenes.size()) {\n    json scenes;\n    JsonReserveArray(scenes, model->scenes.size());\n    for (unsigned int i = 0; i < model->scenes.size(); ++i) {\n      json currentScene;\n      SerializeGltfScene(model->scenes[i], currentScene);\n      JsonPushBack(scenes, std::move(currentScene));\n    }\n    JsonAddMember(o, \"scenes\", std::move(scenes));\n  }\n\n  // SKINS\n  if (model->skins.size()) {\n    json skins;\n    JsonReserveArray(skins, model->skins.size());\n    for (unsigned int i = 0; i < model->skins.size(); ++i) {\n      json skin;\n      SerializeGltfSkin(model->skins[i], skin);\n      JsonPushBack(skins, std::move(skin));\n    }\n    JsonAddMember(o, \"skins\", std::move(skins));\n  }\n\n  // TEXTURES\n  if (model->textures.size()) {\n    json textures;\n    JsonReserveArray(textures, model->textures.size());\n    for (unsigned int i = 0; i < model->textures.size(); ++i) {\n      json texture;\n      SerializeGltfTexture(model->textures[i], texture);\n      JsonPushBack(textures, std::move(texture));\n    }\n    JsonAddMember(o, \"textures\", std::move(textures));\n  }\n\n  // SAMPLERS\n  if (model->samplers.size()) {\n    json samplers;\n    JsonReserveArray(samplers, model->samplers.size());\n    for (unsigned int i = 0; i < model->samplers.size(); ++i) {\n      json sampler;\n      SerializeGltfSampler(model->samplers[i], sampler);\n      JsonPushBack(samplers, std::move(sampler));\n    }\n    JsonAddMember(o, \"samplers\", std::move(samplers));\n  }\n\n  // CAMERAS\n  if (model->cameras.size()) {\n    json cameras;\n    JsonReserveArray(cameras, model->cameras.size());\n    for (unsigned int i = 0; i < model->cameras.size(); ++i) {\n      json camera;\n      SerializeGltfCamera(model->cameras[i], camera);\n      JsonPushBack(cameras, std::move(camera));\n    }\n    JsonAddMember(o, \"cameras\", std::move(cameras));\n  }\n\n  // EXTENSIONS\n  SerializeExtensionMap(model->extensions, o);\n\n  auto extensionsUsed = model->extensionsUsed;\n\n  // LIGHTS as KHR_lights_punctual\n  if (model->lights.size()) {\n    json lights;\n    JsonReserveArray(lights, model->lights.size());\n    for (unsigned int i = 0; i < model->lights.size(); ++i) {\n      json light;\n      SerializeGltfLight(model->lights[i], light);\n      JsonPushBack(lights, std::move(light));\n    }\n    json khr_lights_cmn;\n    JsonAddMember(khr_lights_cmn, \"lights\", std::move(lights));\n    json ext_j;\n\n    {\n      json_const_iterator it;\n      if (FindMember(o, \"extensions\", it)) {\n        JsonAssign(ext_j, GetValue(it));\n      }\n    }\n\n    JsonAddMember(ext_j, \"KHR_lights_punctual\", std::move(khr_lights_cmn));\n\n    JsonAddMember(o, \"extensions\", std::move(ext_j));\n\n    // Also add \"KHR_lights_punctual\" to `extensionsUsed`\n    {\n      auto has_khr_lights_punctual =\n          std::find_if(extensionsUsed.begin(), extensionsUsed.end(),\n                       [](const std::string &s) {\n                         return (s.compare(\"KHR_lights_punctual\") == 0);\n                       });\n\n      if (has_khr_lights_punctual == extensionsUsed.end()) {\n        extensionsUsed.push_back(\"KHR_lights_punctual\");\n      }\n    }\n  }\n\n  // Extensions used\n  if (extensionsUsed.size()) {\n    SerializeStringArrayProperty(\"extensionsUsed\", extensionsUsed, o);\n  }\n\n  // EXTRAS\n  if (model->extras.Type() != NULL_TYPE) {\n    SerializeValue(\"extras\", model->extras, o);\n  }\n}\n\nstatic bool WriteGltfStream(std::ostream &stream, const std::string &content) {\n  stream << content << std::endl;\n  return true;\n}\n\nstatic bool WriteGltfFile(const std::string &output,\n                          const std::string &content) {\n#ifdef _WIN32\n#if defined(_MSC_VER)\n  std::ofstream gltfFile(UTF8ToWchar(output).c_str());\n#elif defined(__GLIBCXX__)\n  int file_descriptor = _wopen(UTF8ToWchar(output).c_str(),\n                               _O_CREAT | _O_WRONLY | _O_TRUNC | _O_BINARY);\n  __gnu_cxx::stdio_filebuf<char> wfile_buf(\n      file_descriptor, std::ios_base::out | std::ios_base::binary);\n  std::ostream gltfFile(&wfile_buf);\n  if (!wfile_buf.is_open()) return false;\n#else\n  std::ofstream gltfFile(output.c_str());\n  if (!gltfFile.is_open()) return false;\n#endif\n#else\n  std::ofstream gltfFile(output.c_str());\n  if (!gltfFile.is_open()) return false;\n#endif\n  return WriteGltfStream(gltfFile, content);\n}\n\nstatic void WriteBinaryGltfStream(std::ostream &stream,\n                                  const std::string &content,\n                                  const std::vector<unsigned char> &binBuffer) {\n  const std::string header = \"glTF\";\n  const int version = 2;\n\n  const uint32_t content_size = uint32_t(content.size());\n  const uint32_t binBuffer_size = uint32_t(binBuffer.size());\n  // determine number of padding bytes required to ensure 4 byte alignment\n  const uint32_t content_padding_size =\n      content_size % 4 == 0 ? 0 : 4 - content_size % 4;\n  const uint32_t bin_padding_size =\n      binBuffer_size % 4 == 0 ? 0 : 4 - binBuffer_size % 4;\n\n  // 12 bytes for header, JSON content length, 8 bytes for JSON chunk info.\n  // Chunk data must be located at 4-byte boundary, which may require padding\n  const uint32_t length =\n      12 + 8 + content_size + content_padding_size +\n      (binBuffer_size ? (8 + binBuffer_size + bin_padding_size) : 0);\n\n  stream.write(header.c_str(), std::streamsize(header.size()));\n  stream.write(reinterpret_cast<const char *>(&version), sizeof(version));\n  stream.write(reinterpret_cast<const char *>(&length), sizeof(length));\n\n  // JSON chunk info, then JSON data\n  const uint32_t model_length = uint32_t(content.size()) + content_padding_size;\n  const uint32_t model_format = 0x4E4F534A;\n  stream.write(reinterpret_cast<const char *>(&model_length),\n               sizeof(model_length));\n  stream.write(reinterpret_cast<const char *>(&model_format),\n               sizeof(model_format));\n  stream.write(content.c_str(), std::streamsize(content.size()));\n\n  // Chunk must be multiplies of 4, so pad with spaces\n  if (content_padding_size > 0) {\n    const std::string padding = std::string(size_t(content_padding_size), ' ');\n    stream.write(padding.c_str(), std::streamsize(padding.size()));\n  }\n  if (binBuffer.size() > 0) {\n    // BIN chunk info, then BIN data\n    const uint32_t bin_length = uint32_t(binBuffer.size()) + bin_padding_size;\n    const uint32_t bin_format = 0x004e4942;\n    stream.write(reinterpret_cast<const char *>(&bin_length),\n                 sizeof(bin_length));\n    stream.write(reinterpret_cast<const char *>(&bin_format),\n                 sizeof(bin_format));\n    stream.write(reinterpret_cast<const char *>(binBuffer.data()),\n                 std::streamsize(binBuffer.size()));\n    // Chunksize must be multiplies of 4, so pad with zeroes\n    if (bin_padding_size > 0) {\n      const std::vector<unsigned char> padding =\n          std::vector<unsigned char>(size_t(bin_padding_size), 0);\n      stream.write(reinterpret_cast<const char *>(padding.data()),\n                   std::streamsize(padding.size()));\n    }\n  }\n}\n\nstatic void WriteBinaryGltfFile(const std::string &output,\n                                const std::string &content,\n                                const std::vector<unsigned char> &binBuffer) {\n#ifdef _WIN32\n#if defined(_MSC_VER)\n  std::ofstream gltfFile(UTF8ToWchar(output).c_str(), std::ios::binary);\n#elif defined(__GLIBCXX__)\n  int file_descriptor = _wopen(UTF8ToWchar(output).c_str(),\n                               _O_CREAT | _O_WRONLY | _O_TRUNC | _O_BINARY);\n  __gnu_cxx::stdio_filebuf<char> wfile_buf(\n      file_descriptor, std::ios_base::out | std::ios_base::binary);\n  std::ostream gltfFile(&wfile_buf);\n#else\n  std::ofstream gltfFile(output.c_str(), std::ios::binary);\n#endif\n#else\n  std::ofstream gltfFile(output.c_str(), std::ios::binary);\n#endif\n  WriteBinaryGltfStream(gltfFile, content, binBuffer);\n}\n\nbool TinyGLTF::WriteGltfSceneToStream(Model *model, std::ostream &stream,\n                                      bool prettyPrint = true,\n                                      bool writeBinary = false) {\n  JsonDocument output;\n\n  /// Serialize all properties except buffers and images.\n  SerializeGltfModel(model, output);\n\n  // BUFFERS\n  std::vector<unsigned char> binBuffer;\n  if (model->buffers.size()) {\n    json buffers;\n    JsonReserveArray(buffers, model->buffers.size());\n    for (unsigned int i = 0; i < model->buffers.size(); ++i) {\n      json buffer;\n      if (writeBinary && i == 0 && model->buffers[i].uri.empty()) {\n        SerializeGltfBufferBin(model->buffers[i], buffer, binBuffer);\n      } else {\n        SerializeGltfBuffer(model->buffers[i], buffer);\n      }\n      JsonPushBack(buffers, std::move(buffer));\n    }\n    JsonAddMember(output, \"buffers\", std::move(buffers));\n  }\n\n  // IMAGES\n  if (model->images.size()) {\n    json images;\n    JsonReserveArray(images, model->images.size());\n    for (unsigned int i = 0; i < model->images.size(); ++i) {\n      json image;\n\n      std::string dummystring = \"\";\n      // UpdateImageObject need baseDir but only uses it if embeddedImages is\n      // enabled, since we won't write separate images when writing to a stream\n      // we\n      UpdateImageObject(model->images[i], dummystring, int(i), true,\n                        &this->WriteImageData, this->write_image_user_data_);\n      SerializeGltfImage(model->images[i], image);\n      JsonPushBack(images, std::move(image));\n    }\n    JsonAddMember(output, \"images\", std::move(images));\n  }\n\n  if (writeBinary) {\n    WriteBinaryGltfStream(stream, JsonToString(output), binBuffer);\n  } else {\n    WriteGltfStream(stream, JsonToString(output, prettyPrint ? 2 : -1));\n  }\n\n  return true;\n}\n\nbool TinyGLTF::WriteGltfSceneToFile(Model *model, const std::string &filename,\n                                    bool embedImages = false,\n                                    bool embedBuffers = false,\n                                    bool prettyPrint = true,\n                                    bool writeBinary = false) {\n  JsonDocument output;\n  std::string defaultBinFilename = GetBaseFilename(filename);\n  std::string defaultBinFileExt = \".bin\";\n  std::string::size_type pos =\n      defaultBinFilename.rfind('.', defaultBinFilename.length());\n\n  if (pos != std::string::npos) {\n    defaultBinFilename = defaultBinFilename.substr(0, pos);\n  }\n  std::string baseDir = GetBaseDir(filename);\n  if (baseDir.empty()) {\n    baseDir = \"./\";\n  }\n  /// Serialize all properties except buffers and images.\n  SerializeGltfModel(model, output);\n\n  // BUFFERS\n  std::vector<std::string> usedUris;\n  std::vector<unsigned char> binBuffer;\n  if (model->buffers.size()) {\n    json buffers;\n    JsonReserveArray(buffers, model->buffers.size());\n    for (unsigned int i = 0; i < model->buffers.size(); ++i) {\n      json buffer;\n      if (writeBinary && i == 0 && model->buffers[i].uri.empty()) {\n        SerializeGltfBufferBin(model->buffers[i], buffer, binBuffer);\n      } else if (embedBuffers) {\n        SerializeGltfBuffer(model->buffers[i], buffer);\n      } else {\n        std::string binSavePath;\n        std::string binUri;\n        if (!model->buffers[i].uri.empty() &&\n            !IsDataURI(model->buffers[i].uri)) {\n          binUri = model->buffers[i].uri;\n        } else {\n          binUri = defaultBinFilename + defaultBinFileExt;\n          bool inUse = true;\n          int numUsed = 0;\n          while (inUse) {\n            inUse = false;\n            for (const std::string &usedName : usedUris) {\n              if (binUri.compare(usedName) != 0) continue;\n              inUse = true;\n              binUri = defaultBinFilename + std::to_string(numUsed++) +\n                       defaultBinFileExt;\n              break;\n            }\n          }\n        }\n        usedUris.push_back(binUri);\n        binSavePath = JoinPath(baseDir, binUri);\n        if (!SerializeGltfBuffer(model->buffers[i], buffer, binSavePath,\n                                 binUri)) {\n          return false;\n        }\n      }\n      JsonPushBack(buffers, std::move(buffer));\n    }\n    JsonAddMember(output, \"buffers\", std::move(buffers));\n  }\n\n  // IMAGES\n  if (model->images.size()) {\n    json images;\n    JsonReserveArray(images, model->images.size());\n    for (unsigned int i = 0; i < model->images.size(); ++i) {\n      json image;\n\n      UpdateImageObject(model->images[i], baseDir, int(i), embedImages,\n                        &this->WriteImageData, this->write_image_user_data_);\n      SerializeGltfImage(model->images[i], image);\n      JsonPushBack(images, std::move(image));\n    }\n    JsonAddMember(output, \"images\", std::move(images));\n  }\n\n  if (writeBinary) {\n    WriteBinaryGltfFile(filename, JsonToString(output), binBuffer);\n  } else {\n    WriteGltfFile(filename, JsonToString(output, (prettyPrint ? 2 : -1)));\n  }\n\n  return true;\n}\n\n}  // namespace tinygltf\n\n#ifdef __clang__\n#pragma clang diagnostic pop\n#endif\n\n#endif  // TINYGLTF_IMPLEMENTATION\n"], "filenames": ["tiny_gltf.h"], "buggy_code_start_loc": [28], "buggy_code_end_loc": [7539], "fixing_code_start_loc": [29], "fixing_code_end_loc": [7563], "type": "CWE-77", "message": "The tinygltf library uses the C library function wordexp() to perform file path expansion on untrusted paths that are provided from the input file. This function allows for command injection by using backticks. An attacker could craft an untrusted path input that would result in a path expansion. We recommend upgrading to 2.6.0 or past commit 52ff00a38447f06a17eab1caa2cf0730a119c751", "other": {"cve": {"id": "CVE-2022-3008", "sourceIdentifier": "cve-coordination@google.com", "published": "2022-09-05T09:15:10.110", "lastModified": "2022-10-01T02:17:27.233", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "The tinygltf library uses the C library function wordexp() to perform file path expansion on untrusted paths that are provided from the input file. This function allows for command injection by using backticks. An attacker could craft an untrusted path input that would result in a path expansion. We recommend upgrading to 2.6.0 or past commit 52ff00a38447f06a17eab1caa2cf0730a119c751"}, {"lang": "es", "value": "La biblioteca tinygltf usa la funci\u00f3n de la biblioteca C wordexp() para llevar a cabo una expansi\u00f3n de la ruta del archivo en rutas no confiables que son proporcionadas desde el archivo de entrada. Esta funci\u00f3n permite una inyecci\u00f3n de comandos mediante el uso de signos de retroceso. Un atacante podr\u00eda dise\u00f1ar una ruta de entrada no confiable que resultar\u00eda en una expansi\u00f3n de ruta. Recomendamos actualizar a versi\u00f3n 2.6.0 o al commit 52ff00a38447f06a17eab1caa2cf0730a119c751"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}, {"source": "cve-coordination@google.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.2}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-77"}]}, {"source": "cve-coordination@google.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-78"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tinygltf_project:tinygltf:*:*:*:*:*:*:*:*", "versionEndExcluding": "2.6.0", "matchCriteriaId": "078C039E-D2B4-44A7-BEC7-7B77F794FB1D"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:11.0:*:*:*:*:*:*:*", "matchCriteriaId": "FA6FEEC2-9F11-4643-8827-749718254FED"}]}]}], "references": [{"url": "https://bugs.chromium.org/p/oss-fuzz/issues/detail?id=49053", "source": "cve-coordination@google.com", "tags": ["Exploit", "Issue Tracking", "Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/syoyo/tinygltf/blob/master/README.md", "source": "cve-coordination@google.com", "tags": ["Product", "Third Party Advisory"]}, {"url": "https://github.com/syoyo/tinygltf/commit/52ff00a38447f06a17eab1caa2cf0730a119c751", "source": "cve-coordination@google.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/syoyo/tinygltf/issues/368", "source": "cve-coordination@google.com", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}, {"url": "https://www.debian.org/security/2022/dsa-5232", "source": "cve-coordination@google.com", "tags": ["Third Party Advisory"]}]}, "github_commit_url": "https://github.com/syoyo/tinygltf/commit/52ff00a38447f06a17eab1caa2cf0730a119c751"}}