{"buggy_code": ["<Project ToolsVersion=\"3.5\" DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <PropertyGroup>\n    <Configuration Condition=\" '$(Configuration)' == '' \">Release</Configuration>\n    <Platform Condition=\" '$(Platform)' == '' \">AnyCPU</Platform>\n    <ProductVersion>9.0.30729</ProductVersion>\n    <SchemaVersion>2.0</SchemaVersion>\n    <ProjectGuid>{06299ED2-056A-427C-8C84-D716197080EB}</ProjectGuid>\n    <OutputType>Library</OutputType>\n    <AppDesignerFolder>Properties</AppDesignerFolder>\n    <RootNamespace>SSharpSmartThreadPool</RootNamespace>\n    <AssemblyName>SSharpSmartThreadPool</AssemblyName>\n    <ProjectTypeGuids>{0B4745B0-194B-4BB6-8E21-E9057CA92300};{4D628B5B-2FBC-4AA6-8C16-197242AEB884};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>\n    <PlatformFamilyName>WindowsCE</PlatformFamilyName>\n    <PlatformID>E2BECB1F-8C8C-41ba-B736-9BE7D946A398</PlatformID>\n    <OSVersion>5.0</OSVersion>\n    <DeployDirSuffix>SmartDeviceProject1</DeployDirSuffix>\n    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>\n    <NativePlatformName>Windows CE</NativePlatformName>\n    <FormFactorID>\n    </FormFactorID>\n  </PropertyGroup>\n  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' \">\n    <AllowedReferenceRelatedFileExtensions>.allowedReferenceRelatedFileExtensions</AllowedReferenceRelatedFileExtensions>\n    <DebugSymbols>true</DebugSymbols>\n    <DebugType>full</DebugType>\n    <Optimize>false</Optimize>\n    <OutputPath>bin\\Debug\\</OutputPath>\n    <DefineConstants>DEBUG;TRACE;_WINDOWS_CE;_WINDOWS;SSHARP</DefineConstants>\n    <ErrorReport>prompt</ErrorReport>\n    <WarningLevel>4</WarningLevel>\n    <FileAlignment>512</FileAlignment>\n    <NoStdLib>true</NoStdLib>\n    <NoConfig>true</NoConfig>\n    <GenerateSerializationAssemblies>off</GenerateSerializationAssemblies>\n  </PropertyGroup>\n  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' \">\n    <AllowedReferenceRelatedFileExtensions>.allowedReferenceRelatedFileExtensions</AllowedReferenceRelatedFileExtensions>\n    <DebugType>none</DebugType>\n    <Optimize>true</Optimize>\n    <OutputPath>bin\\Release\\</OutputPath>\n    <ErrorReport>prompt</ErrorReport>\n    <WarningLevel>4</WarningLevel>\n    <FileAlignment>512</FileAlignment>\n    <NoStdLib>true</NoStdLib>\n    <NoConfig>true</NoConfig>\n    <GenerateSerializationAssemblies>off</GenerateSerializationAssemblies>\n    <DefineConstants>_WINDOWS_CE;_WINDOWS;SSHARP</DefineConstants>\n  </PropertyGroup>\n  <ItemGroup>\n    <Reference Include=\"mscorlib\" />\n    <Reference Include=\"SimplSharpCustomAttributesInterface, Version=1.0.0.0, Culture=neutral, PublicKeyToken=1099c178b3b54c3b, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>..\\..\\..\\..\\..\\ProgramData\\Crestron\\SDK\\SimplSharpCustomAttributesInterface.dll</HintPath>\n      <Private>False</Private>\n    </Reference>\n    <Reference Include=\"SimplSharpHelperInterface, Version=1.0.0.0, Culture=neutral, PublicKeyToken=1099c178b3b54c3b, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>..\\..\\..\\..\\..\\ProgramData\\Crestron\\SDK\\SimplSharpHelperInterface.dll</HintPath>\n      <Private>False</Private>\n    </Reference>\n    <Reference Include=\"SimplSharpPro, Version=1.4.0.14, Culture=neutral, PublicKeyToken=1099c178b3b54c3b, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>..\\..\\..\\..\\..\\ProgramData\\Crestron\\SDK\\SimplSharpPro.exe</HintPath>\n      <Private>False</Private>\n    </Reference>\n    <Reference Include=\"SSharpThreadingLibrary, Version=1.0.0.10633, Culture=neutral, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>..\\..\\..\\Simpl# Libraries\\SSharpThreadingLibrary\\SSharpThreadingLibrary\\bin\\Release\\SSharpThreadingLibrary.dll</HintPath>\n    </Reference>\n    <Reference Include=\"System\" />\n    <Reference Include=\"System.Core\" />\n    <Reference Include=\"System.Data\" />\n  </ItemGroup>\n  <ItemGroup>\n    <Compile Include=\"CallerThreadContext.cs\" />\n    <Compile Include=\"CanceledWorkItemsGroup.cs\" />\n    <Compile Include=\"EventWaitHandle.cs\" />\n    <Compile Include=\"EventWaitHandleFactory.cs\" />\n    <Compile Include=\"Exceptions.cs\" />\n    <Compile Include=\"Interfaces.cs\" />\n    <Compile Include=\"InternalInterfaces.cs\" />\n    <Compile Include=\"PriorityQueue.cs\" />\n    <Compile Include=\"Properties\\AssemblyInfo.cs\" />\n    <Compile Include=\"SmartThreadPool.cs\" />\n    <Compile Include=\"SmartThreadPool.ThreadEntry.cs\" />\n    <Compile Include=\"STPEventWaitHandle.cs\">\n      <SubType>Code</SubType>\n    </Compile>\n    <Compile Include=\"STPPerformanceCounter.cs\">\n      <SubType>Code</SubType>\n    </Compile>\n    <Compile Include=\"STPStartInfo.cs\" />\n    <Compile Include=\"SynchronizedDictionary.cs\" />\n    <Compile Include=\"WIGStartInfo.cs\" />\n    <Compile Include=\"WorkItem.cs\" />\n    <Compile Include=\"WorkItem.WorkItemResult.cs\" />\n    <Compile Include=\"WorkItemFactory.cs\" />\n    <Compile Include=\"WorkItemInfo.cs\" />\n    <Compile Include=\"WorkItemResultTWrapper.cs\" />\n    <Compile Include=\"WorkItemsGroup.cs\" />\n    <Compile Include=\"WorkItemsGroupBase.cs\" />\n    <Compile Include=\"WorkItemsQueue.cs\" />\n    <None Include=\"Properties\\ControlSystem.cfg\" />\n  </ItemGroup>\n  <Import Project=\"$(MSBuildBinPath)\\Microsoft.CompactFramework.CSharp.targets\" />\n  <ProjectExtensions>\n    <VisualStudio>\n      <FlavorProperties GUID=\"{0B4745B0-194B-4BB6-8E21-E9057CA92300}\">\n        <ProgramIdTag>SSharpSmartThreadPoo</ProgramIdTag>\n        <SystemName>SSharpSmartThreadPool</SystemName>\n        <Programmer />\n        <ArchiveFilename>C:\\Projects\\Crestron\\Simpl# Pro Libraries\\SSharpSmartThreadPool\\SSharpSmartThreadPool\\bin\\Debug\\SSharpSmartThreadPool.cplz</ArchiveFilename>\n        <MinFirmwareVersion>1.009.0029</MinFirmwareVersion>\n        <CompiledOn>3/14/2015 4:17:08 AM</CompiledOn>\n        <AdditionalInfo />\n        <EmbedSourceArchive>False</EmbedSourceArchive>\n        <CopyTo />\n        <OriginalReferenceSources>\n          <Reference sourceFilename=\"../../../Simpl%23%20Libraries/SSharpThreadingLibrary/SSharpThreadingLibrary/bin/Release/SSharpThreadingLibrary.dll\" referenceName=\"SSharpThreadingLibrary\" />\n        </OriginalReferenceSources>\n      </FlavorProperties>\n    </VisualStudio>\n  </ProjectExtensions>\n  <PropertyGroup>\n    <PostBuildEvent>rem S# Pro preparation will execute after these operations</PostBuildEvent>\n  </PropertyGroup>\n</Project>", "#region Release History\n\n// Smart Thread Pool\n// 7 Aug 2004 - Initial release\n//\n// 14 Sep 2004 - Bug fixes \n//\n// 15 Oct 2004 - Added new features\n//\t\t- Work items return result.\n//\t\t- Support waiting synchronization for multiple work items.\n//\t\t- Work items can be cancelled.\n//\t\t- Passage of the caller thread\u2019s context to the thread in the pool.\n//\t\t- Minimal usage of WIN32 handles.\n//\t\t- Minor bug fixes.\n//\n// 26 Dec 2004 - Changes:\n//\t\t- Removed static constructors.\n//      - Added finalizers.\n//\t\t- Changed Exceptions so they are serializable.\n//\t\t- Fixed the bug in one of the SmartThreadPool constructors.\n//\t\t- Changed the SmartThreadPool.WaitAll() so it will support any number of waiters. \n//        The SmartThreadPool.WaitAny() is still limited by the .NET Framework.\n//\t\t- Added PostExecute with options on which cases to call it.\n//      - Added option to dispose of the state objects.\n//      - Added a WaitForIdle() method that waits until the work items queue is empty.\n//      - Added an STPStartInfo class for the initialization of the thread pool.\n//      - Changed exception handling so if a work item throws an exception it \n//        is rethrown at GetResult(), rather then firing an UnhandledException event.\n//        Note that PostExecute exception are always ignored.\n//\n// 25 Mar 2005 - Changes:\n//\t\t- Fixed lost of work items bug\n//\n// 3 Jul 2005: Changes.\n//      - Fixed bug where Enqueue() throws an exception because PopWaiter() returned null, hardly reconstructed. \n//\n// 16 Aug 2005: Changes.\n//\t\t- Fixed bug where the InUseThreads becomes negative when canceling work items. \n//\n// 31 Jan 2006 - Changes:\n//\t\t- Added work items priority\n//\t\t- Removed support of chained delegates in callbacks and post executes (nobody really use this)\n//\t\t- Added work items groups\n//\t\t- Added work items groups idle event\n//\t\t- Changed SmartThreadPool.WaitAll() behavior so when it gets empty array\n//\t\t  it returns true rather then throwing an exception.\n//\t\t- Added option to start the STP and the WIG as suspended\n//\t\t- Exception behavior changed, the real exception is returned by an \n//\t\t  inner exception\n//\t\t- Added option to keep the Http context of the caller thread. (Thanks to Steven T.)\n//\t\t- Added performance counters\n//\t\t- Added priority to the threads in the pool\n//\n// 13 Feb 2006 - Changes:\n//\t\t- Added a call to the dispose of the Performance Counter so\n//\t\t  their won't be a Performance Counter leak.\n//\t\t- Added exception catch in case the Performance Counters cannot \n//\t\t  be created.\n//\n// 17 May 2008 - Changes:\n//      - Changed the dispose behavior and removed the Finalizers.\n//      - Enabled the change of the MaxThreads and MinThreads at run time.\n//      - Enabled the change of the Concurrency of a IWorkItemsGroup at run \n//        time If the IWorkItemsGroup is a SmartThreadPool then the Concurrency \n//        refers to the MaxThreads. \n//      - Improved the cancel behavior.\n//      - Added events for thread creation and termination. \n//      - Fixed the HttpContext context capture.\n//      - Changed internal collections so they use generic collections\n//      - Added IsIdle flag to the SmartThreadPool and IWorkItemsGroup\n//      - Added support for WinCE\n//      - Added support for Action<T> and Func<T>\n//\n// 07 April 2009 - Changes:\n//      - Added support for Silverlight and Mono\n//      - Added Join, Choice, and Pipe to SmartThreadPool.\n//      - Added local performance counters (for Mono, Silverlight, and WindowsCE)\n//      - Changed duration measures from DateTime.Now to Stopwatch.\n//      - Queues changed from System.Collections.Queue to System.Collections.Generic.LinkedList<T>.\n//\n// 21 December 2009 - Changes:\n//      - Added work item timeout (passive)\n//\n// 20 August 2012 - Changes:\n//      - Added set name to threads\n//      - Fixed the WorkItemsQueue.Dequeue. \n//        Replaced while (!Monitor.TryEnter(this)); with lock(this) { ... }\n//      - Fixed SmartThreadPool.Pipe\n//      - Added IsBackground option to threads\n//      - Added ApartmentState to threads\n//      - Fixed thread creation when queuing many work items at the same time.\n//\n// 24 August 2012 - Changes:\n//      - Enabled cancel abort after cancel. See: http://smartthreadpool.codeplex.com/discussions/345937 by alecswan\n//      - Added option to set MaxStackSize of threads \n\n#endregion\n\nusing System;\nusing System.Security;\nusing Amib.SSharpThreading.Internal;\nusing Crestron.SimplSharp;\nusing Crestron.SimplSharpPro.CrestronThread;\nusing ThreadPriority = Crestron.SimplSharpPro.CrestronThread.Thread.eThreadPriority;\nusing SSharp.Threading;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Runtime.CompilerServices;\n//using SSMono.Diagnostics;\nusing ThreadAbortException = System.Threading.ThreadAbortException;\nusing ThreadStateException = System.Threading.ThreadStateException;\n\nnamespace Amib.SSharpThreading\n\t{\n\t#region SmartThreadPool class\n\t/// <summary>\n\t/// Smart thread pool class.\n\t/// </summary>\n\tpublic partial class SmartThreadPool : WorkItemsGroupBase, IDisposable\n\t\t{\n\t\t#region Public Default Constants\n\n\t\t/// <summary>\n\t\t/// Default minimum number of threads the thread pool contains. (0)\n\t\t/// </summary>\n\t\tpublic const int DefaultMinWorkerThreads = 0;\n\n\t\t/// <summary>\n\t\t/// Default maximum number of threads the thread pool contains. (25)\n\t\t/// </summary>\n\t\tpublic const int DefaultMaxWorkerThreads = 25;\n\n\t\t/// <summary>\n\t\t/// Default idle timeout in milliseconds. (One minute)\n\t\t/// </summary>\n\t\tpublic const int DefaultIdleTimeout = 60 * 1000; // One minute\n\n\t\t/// <summary>\n\t\t/// Indicate to copy the security context of the caller and then use it in the call. (false)\n\t\t/// </summary>\n\t\tpublic const bool DefaultUseCallerCallContext = false;\n\n\t\t/// <summary>\n\t\t/// Indicate to copy the HTTP context of the caller and then use it in the call. (false)\n\t\t/// </summary>\n\t\tpublic const bool DefaultUseCallerHttpContext = false;\n\n\t\t/// <summary>\n\t\t/// Indicate to dispose of the state objects if they support the IDispose interface. (false)\n\t\t/// </summary>\n\t\tpublic const bool DefaultDisposeOfStateObjects = false;\n\n\t\t/// <summary>\n\t\t/// The default option to run the post execute (CallToPostExecute.Always)\n\t\t/// </summary>\n\t\tpublic const CallToPostExecute DefaultCallToPostExecute = CallToPostExecute.Always;\n\n\t\t/// <summary>\n\t\t/// The default post execute method to run. (None)\n\t\t/// When null it means not to call it.\n\t\t/// </summary>\n\t\tpublic static readonly PostExecuteWorkItemCallback DefaultPostExecuteWorkItemCallback;\n\n\t\t/// <summary>\n\t\t/// The default work item priority (WorkItemPriority.Normal)\n\t\t/// </summary>\n\t\tpublic const WorkItemPriority DefaultWorkItemPriority = WorkItemPriority.Normal;\n\n\t\t/// <summary>\n\t\t/// The default is to work on work items as soon as they arrive\n\t\t/// and not to wait for the start. (false)\n\t\t/// </summary>\n\t\tpublic const bool DefaultStartSuspended = false;\n\n\t\t/// <summary>\n\t\t/// The default name to use for the performance counters instance. (null)\n\t\t/// </summary>\n\t\tpublic static readonly string DefaultPerformanceCounterInstanceName;\n\n#if !(WINDOWS_PHONE)\n\n\t\t/// <summary>\n\t\t/// The default thread priority (ThreadPriority.Normal)\n\t\t/// </summary>\n\n\t\tpublic const ThreadPriority DefaultThreadPriority = ThreadPriority.MediumPriority;\n#endif\n\t\t/// <summary>\n\t\t/// The default thread pool name. (SmartThreadPool)\n\t\t/// </summary>\n\t\tpublic const string DefaultThreadPoolName = \"SmartThreadPool\";\n\n\t\t/// <summary>\n\t\t/// The default Max Stack Size. (SmartThreadPool)\n\t\t/// </summary>\n\t\tpublic static readonly int? DefaultMaxStackSize = null;\n\n\t\t/// <summary>\n\t\t/// The default fill state with params. (false)\n\t\t/// It is relevant only to QueueWorkItem of Action&lt;...&gt;/Func&lt;...&gt;\n\t\t/// </summary>\n\t\tpublic const bool DefaultFillStateWithArgs = false;\n\n\t\t/// <summary>\n\t\t/// The default thread backgroundness. (true)\n\t\t/// </summary>\n\t\tpublic const bool DefaultAreThreadsBackground = true;\n\n#if !(_SILVERLIGHT) && !(WINDOWS_PHONE) && !(_WINDOWS_CE)\n        /// <summary>\n        /// The default apartment state of a thread in the thread pool. \n        /// The default is ApartmentState.Unknown which means the STP will not \n        /// set the apartment of the thread. It will use the .NET default.\n        /// </summary>\n        public const ApartmentState DefaultApartmentState = ApartmentState.Unknown;\n#endif\n\n\t\t#endregion\n\n\t\t#region Member Variables\n\n\t\t/// <summary>\n\t\t/// Dictionary of all the threads in the thread pool.\n\t\t/// </summary>\n\t\tprivate readonly SynchronizedDictionary<Thread, ThreadEntry> _workerThreads = new SynchronizedDictionary<Thread, ThreadEntry> ();\n\n\t\t/// <summary>\n\t\t/// Queue of work items.\n\t\t/// </summary>\n\t\tprivate readonly WorkItemsQueue _workItemsQueue = new WorkItemsQueue ();\n\n\t\t/// <summary>\n\t\t/// Count the work items handled.\n\t\t/// Used by the performance counter.\n\t\t/// </summary>\n\t\tprivate int _workItemsProcessed;\n\n\t\t/// <summary>\n\t\t/// Number of threads that currently work (not idle).\n\t\t/// </summary>\n\t\tprivate int _inUseWorkerThreads;\n\n\t\t/// <summary>\n\t\t/// Stores a copy of the original STPStartInfo.\n\t\t/// It is used to change the MinThread and MaxThreads\n\t\t/// </summary>\n\t\tprivate STPStartInfo _stpStartInfo;\n\n\t\t/// <summary>\n\t\t/// Total number of work items that are stored in the work items queue \n\t\t/// plus the work items that the threads in the pool are working on.\n\t\t/// </summary>\n\t\tprivate int _currentWorkItemsCount;\n\n\t\t/// <summary>\n\t\t/// Signaled when the thread pool is idle, i.e. no thread is busy\n\t\t/// and the work items queue is empty\n\t\t/// </summary>\n\t\t//private ManualResetEvent _isIdleWaitHandle = new ManualResetEvent(true);\n\t\tprivate ManualResetEvent _isIdleWaitHandle = EventWaitHandleFactory.CreateManualResetEvent (true);\n\n\t\t/// <summary>\n\t\t/// An event to signal all the threads to quit immediately.\n\t\t/// </summary>\n\t\t//private ManualResetEvent _shuttingDownEvent = new ManualResetEvent(false);\n\t\tprivate ManualResetEvent _shuttingDownEvent = EventWaitHandleFactory.CreateManualResetEvent (false);\n\n\t\t/// <summary>\n\t\t/// A flag to indicate if the Smart Thread Pool is now suspended.\n\t\t/// </summary>\n\t\tprivate bool _isSuspended;\n\n\t\t/// <summary>\n\t\t/// A flag to indicate the threads to quit.\n\t\t/// </summary>\n\t\tprivate bool _shutdown;\n\n\t\t/// <summary>\n\t\t/// Counts the threads created in the pool.\n\t\t/// It is used to name the threads.\n\t\t/// </summary>\n\t\tprivate int _threadCounter;\n\n\t\t/// <summary>\n\t\t/// Indicate that the SmartThreadPool has been disposed\n\t\t/// </summary>\n\t\tprivate bool _isDisposed;\n\n\t\t/// <summary>\n\t\t/// Holds all the WorkItemsGroup instaces that have at least one \n\t\t/// work item int the SmartThreadPool\n\t\t/// This variable is used in case of Shutdown\n\t\t/// </summary>\n\t\tprivate readonly SynchronizedDictionary<IWorkItemsGroup, IWorkItemsGroup> _workItemsGroups = new SynchronizedDictionary<IWorkItemsGroup, IWorkItemsGroup> ();\n\n\t\t/// <summary>\n\t\t/// A common object for all the work items int the STP\n\t\t/// so we can mark them to cancel in O(1)\n\t\t/// </summary>\n\t\tprivate CanceledWorkItemsGroup _canceledSmartThreadPool = new CanceledWorkItemsGroup ();\n\n\t\t/// <summary>\n\t\t/// Windows STP performance counters\n\t\t/// </summary>\n\t\tprivate ISTPInstancePerformanceCounters _windowsPCs = NullSTPInstancePerformanceCounters.Instance;\n\n\t\t/// <summary>\n\t\t/// Local STP performance counters\n\t\t/// </summary>\n\t\tprivate ISTPInstancePerformanceCounters _localPCs = NullSTPInstancePerformanceCounters.Instance;\n\n#if (WINDOWS_PHONE) \n        private static readonly Dictionary<int, ThreadEntry> _threadEntries = new Dictionary<int, ThreadEntry>();\n#elif (_WINDOWS_CE)\n\t\tprivate static LocalDataStoreSlot _threadEntrySlot = Thread.AllocateDataSlot ();\n#else\n        [ThreadStatic]\n        private static ThreadEntry _threadEntry;\n\n#endif\n\n\t\t/// <summary>\n\t\t/// An event to call after a thread is created, but before \n\t\t/// it's first use.\n\t\t/// </summary>\n\t\tprivate event ThreadInitializationHandler _onThreadInitialization;\n\n\t\t/// <summary>\n\t\t/// An event to call when a thread is about to exit, after \n\t\t/// it is no longer belong to the pool.\n\t\t/// </summary>\n\t\tprivate event ThreadTerminationHandler _onThreadTermination;\n\n\t\t#endregion\n\n\t\t#region Per thread properties\n\n\t\t/// <summary>\n\t\t/// A reference to the current work item a thread from the thread pool \n\t\t/// is executing.\n\t\t/// </summary>\n\t\tinternal static ThreadEntry CurrentThreadEntry\n\t\t\t{\n#if (WINDOWS_PHONE)\n            get\n            {\n                lock(_threadEntries)\n                {\n                    ThreadEntry threadEntry;\n                    if (_threadEntries.TryGetValue(Thread.CurrentThread.ManagedThreadId, out threadEntry))\n                    {\n                        return threadEntry;\n                    }\n                }\n                return null;\n            }\n            set\n            {\n                lock(_threadEntries)\n                {\n                    _threadEntries[Thread.CurrentThread.ManagedThreadId] = value;\n                }\n            }\n#elif (_WINDOWS_CE)\n\t\t\tget\n\t\t\t\t{\n\t\t\t\t//Thread.CurrentThread.ManagedThreadId\n\t\t\t\treturn Thread.GetData (_threadEntrySlot) as ThreadEntry;\n\t\t\t\t}\n\t\t\tset\n\t\t\t\t{\n\t\t\t\tThread.SetData (_threadEntrySlot, value);\n\t\t\t\t}\n#else\n            get\n            {\n                return _threadEntry;\n            }\n            set\n            {\n                _threadEntry = value;\n            }\n#endif\n\t\t\t}\n\t\t#endregion\n\n\t\t#region Construction and Finalization\n\n\t\t/// <summary>\n\t\t/// Constructor\n\t\t/// </summary>\n\t\tpublic SmartThreadPool ()\n\t\t\t{\n\t\t\t_stpStartInfo = new STPStartInfo ();\n\t\t\tInitialize ();\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Constructor\n\t\t/// </summary>\n\t\t/// <param name=\"idleTimeout\">Idle timeout in milliseconds</param>\n\t\tpublic SmartThreadPool (int idleTimeout)\n\t\t\t{\n\t\t\t_stpStartInfo = new STPStartInfo\n\t\t\t{\n\t\t\t\tIdleTimeout = idleTimeout,\n\t\t\t};\n\t\t\tInitialize ();\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Constructor\n\t\t/// </summary>\n\t\t/// <param name=\"idleTimeout\">Idle timeout in milliseconds</param>\n\t\t/// <param name=\"maxWorkerThreads\">Upper limit of threads in the pool</param>\n\t\tpublic SmartThreadPool (\n\t\t\tint idleTimeout,\n\t\t\tint maxWorkerThreads)\n\t\t\t{\n\t\t\t_stpStartInfo = new STPStartInfo\n\t\t\t{\n\t\t\t\tIdleTimeout = idleTimeout,\n\t\t\t\tMaxWorkerThreads = maxWorkerThreads,\n\t\t\t};\n\t\t\tInitialize ();\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Constructor\n\t\t/// </summary>\n\t\t/// <param name=\"idleTimeout\">Idle timeout in milliseconds</param>\n\t\t/// <param name=\"maxWorkerThreads\">Upper limit of threads in the pool</param>\n\t\t/// <param name=\"minWorkerThreads\">Lower limit of threads in the pool</param>\n\t\tpublic SmartThreadPool (\n\t\t\tint idleTimeout,\n\t\t\tint maxWorkerThreads,\n\t\t\tint minWorkerThreads)\n\t\t\t{\n\t\t\t_stpStartInfo = new STPStartInfo\n\t\t\t{\n\t\t\t\tIdleTimeout = idleTimeout,\n\t\t\t\tMaxWorkerThreads = maxWorkerThreads,\n\t\t\t\tMinWorkerThreads = minWorkerThreads,\n\t\t\t};\n\t\t\tInitialize ();\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Constructor\n\t\t/// </summary>\n\t\t/// <param name=\"stpStartInfo\">A SmartThreadPool configuration that overrides the default behavior</param>\n\t\tpublic SmartThreadPool (STPStartInfo stpStartInfo)\n\t\t\t{\n\t\t\t_stpStartInfo = new STPStartInfo (stpStartInfo);\n\t\t\tInitialize ();\n\t\t\t}\n\n\t\tprivate void Initialize ()\n\t\t\t{\n\t\t\tName = _stpStartInfo.ThreadPoolName;\n\t\t\tValidateSTPStartInfo ();\n\n\t\t\t// _stpStartInfoRW stores a read/write copy of the STPStartInfo.\n\t\t\t// Actually only MaxWorkerThreads and MinWorkerThreads are overwritten\n\n\t\t\t_isSuspended = _stpStartInfo.StartSuspended;\n\n#if (_WINDOWS_CE) || (_SILVERLIGHT) || (_MONO) || (WINDOWS_PHONE)\n\t\t\tif (null != _stpStartInfo.PerformanceCounterInstanceName)\n\t\t\t\t{\n\t\t\t\tthrow new NotSupportedException (\"Performance counters are not implemented for Compact Framework/Silverlight/Mono, instead use StpStartInfo.EnableLocalPerformanceCounters\");\n\t\t\t\t}\n#else\n            if (null != _stpStartInfo.PerformanceCounterInstanceName)\n            {\n                try\n                {\n                    _windowsPCs = new STPInstancePerformanceCounters(_stpStartInfo.PerformanceCounterInstanceName);\n                }\n                catch (Exception e)\n                {\n                    //Debug.WriteLine(\"Unable to create Performance Counters: \" + e);\n                    _windowsPCs = NullSTPInstancePerformanceCounters.Instance;\n                }\n            }\n#endif\n\n\t\t\tif (_stpStartInfo.EnableLocalPerformanceCounters)\n\t\t\t\t{\n\t\t\t\t_localPCs = new LocalSTPInstancePerformanceCounters ();\n\t\t\t\t}\n\n\t\t\t// If the STP is not started suspended then start the threads.\n\t\t\tif (!_isSuspended)\n\t\t\t\t{\n\t\t\t\tStartOptimalNumberOfThreads ();\n\t\t\t\t}\n\t\t\t}\n\n\t\tprivate void StartOptimalNumberOfThreads ()\n\t\t\t{\n\t\t\tint threadsCount = Math.Max (_workItemsQueue.Count, _stpStartInfo.MinWorkerThreads);\n\t\t\tthreadsCount = Math.Min (threadsCount, _stpStartInfo.MaxWorkerThreads);\n\t\t\tthreadsCount -= _workerThreads.Count;\n\t\t\tif (threadsCount > 0)\n\t\t\t\t{\n\t\t\t\tStartThreads (threadsCount);\n\t\t\t\t}\n\t\t\t}\n\n\t\tprivate void ValidateSTPStartInfo ()\n\t\t\t{\n\t\t\tif (_stpStartInfo.MinWorkerThreads < 0)\n\t\t\t\t{\n\t\t\t\tthrow new ArgumentOutOfRangeException (\n\t\t\t\t\t\"MinWorkerThreads\", \"MinWorkerThreads cannot be negative\");\n\t\t\t\t}\n\n\t\t\tif (_stpStartInfo.MaxWorkerThreads <= 0)\n\t\t\t\t{\n\t\t\t\tthrow new ArgumentOutOfRangeException (\n\t\t\t\t\t\"MaxWorkerThreads\", \"MaxWorkerThreads must be greater than zero\");\n\t\t\t\t}\n\n\t\t\tif (_stpStartInfo.MinWorkerThreads > _stpStartInfo.MaxWorkerThreads)\n\t\t\t\t{\n\t\t\t\tthrow new ArgumentOutOfRangeException (\n\t\t\t\t\t\"MinWorkerThreads, maxWorkerThreads\",\n\t\t\t\t\t\"MaxWorkerThreads must be greater or equal to MinWorkerThreads\");\n\t\t\t\t}\n\t\t\t}\n\n\t\tprivate static void ValidateCallback (Delegate callback)\n\t\t\t{\n\t\t\tif (callback.GetInvocationList ().Length > 1)\n\t\t\t\t{\n\t\t\t\tthrow new NotSupportedException (\"SmartThreadPool doesn't support delegates chains\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t#endregion\n\n\t\t#region Thread Processing\n\n\t\t/// <summary>\n\t\t/// Waits on the queue for a work item, shutdown, or timeout.\n\t\t/// </summary>\n\t\t/// <returns>\n\t\t/// Returns the WaitingCallback or null in case of timeout or shutdown.\n\t\t/// </returns>\n\t\tprivate WorkItem Dequeue ()\n\t\t\t{\n\t\t\tWorkItem workItem =\n\t\t\t\t_workItemsQueue.DequeueWorkItem (_stpStartInfo.IdleTimeout, _shuttingDownEvent);\n\n\t\t\treturn workItem;\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Put a new work item in the queue\n\t\t/// </summary>\n\t\t/// <param name=\"workItem\">A work item to queue</param>\n\t\tinternal override void Enqueue (WorkItem workItem)\n\t\t\t{\n\t\t\t// Make sure the workItem is not null\n\t\t\t//Debug.Assert (null != workItem);\n\n\t\t\tIncrementWorkItemsCount ();\n\n\t\t\tworkItem.CanceledSmartThreadPool = _canceledSmartThreadPool;\n\t\t\t_workItemsQueue.EnqueueWorkItem (workItem);\n\t\t\tworkItem.WorkItemIsQueued ();\n\n\t\t\t// If all the threads are busy then try to create a new one\n\t\t\tif (_currentWorkItemsCount > _workerThreads.Count)\n\t\t\t\t{\n\t\t\t\tStartThreads (1);\n\t\t\t\t}\n\t\t\t}\n\n\t\tprivate void IncrementWorkItemsCount ()\n\t\t\t{\n\t\t\t_windowsPCs.SampleWorkItems (_workItemsQueue.Count, _workItemsProcessed);\n\t\t\t_localPCs.SampleWorkItems (_workItemsQueue.Count, _workItemsProcessed);\n\t\t\tint count = Interlocked.Increment (ref _currentWorkItemsCount);\n\t\t\t//Trace.WriteLine(\"WorkItemsCount = \" + _currentWorkItemsCount.ToString());\n\t\t\tif (count == 1)\n\t\t\t\t{\n\t\t\t\tIsIdle = false;\n\t\t\t\t_isIdleWaitHandle.Reset ();\n\t\t\t\t}\n\t\t\t}\n\n\t\tprivate void DecrementWorkItemsCount ()\n\t\t\t{\n\t\t\tint count = Interlocked.Decrement (ref _currentWorkItemsCount);\n\t\t\t//Trace.WriteLine(\"WorkItemsCount = \" + _currentWorkItemsCount.ToString());\n\t\t\tif (count == 0)\n\t\t\t\t{\n\t\t\t\tIsIdle = true;\n\t\t\t\t_isIdleWaitHandle.Set ();\n\t\t\t\t}\n\n\t\t\tInterlocked.Increment (ref _workItemsProcessed);\n\n\t\t\tif (!_shutdown)\n\t\t\t\t{\n\t\t\t\t// The counter counts even if the work item was cancelled\n\t\t\t\t_windowsPCs.SampleWorkItems (_workItemsQueue.Count, _workItemsProcessed);\n\t\t\t\t_localPCs.SampleWorkItems (_workItemsQueue.Count, _workItemsProcessed);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\tinternal void RegisterWorkItemsGroup (IWorkItemsGroup workItemsGroup)\n\t\t\t{\n\t\t\t_workItemsGroups[workItemsGroup] = workItemsGroup;\n\t\t\t}\n\n\t\tinternal void UnregisterWorkItemsGroup (IWorkItemsGroup workItemsGroup)\n\t\t\t{\n\t\t\tif (_workItemsGroups.Contains (workItemsGroup))\n\t\t\t\t{\n\t\t\t\t_workItemsGroups.Remove (workItemsGroup);\n\t\t\t\t}\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Inform that the current thread is about to quit or quiting.\n\t\t/// The same thread may call this method more than once.\n\t\t/// </summary>\n\t\tprivate void InformCompleted ()\n\t\t\t{\n\t\t\t// There is no need to lock the two methods together \n\t\t\t// since only the current thread removes itself\n\t\t\t// and the _workerThreads is a synchronized dictionary\n\t\t\tif (_workerThreads.Contains (Thread.CurrentThread))\n\t\t\t\t{\n\t\t\t\t_workerThreads.Remove (Thread.CurrentThread);\n\t\t\t\t_windowsPCs.SampleThreads (_workerThreads.Count, _inUseWorkerThreads);\n\t\t\t\t_localPCs.SampleThreads (_workerThreads.Count, _inUseWorkerThreads);\n\t\t\t\t}\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Starts new threads\n\t\t/// </summary>\n\t\t/// <param name=\"threadsCount\">The number of threads to start</param>\n\t\tprivate void StartThreads (int threadsCount)\n\t\t\t{\n\t\t\tif (_isSuspended)\n\t\t\t\t{\n\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\tlock (_workerThreads.SyncRoot)\n\t\t\t\t{\n\t\t\t\t// Don't start threads on shut down\n\t\t\t\tif (_shutdown)\n\t\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < threadsCount; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t// Don't create more threads then the upper limit\n\t\t\t\t\tif (_workerThreads.Count >= _stpStartInfo.MaxWorkerThreads)\n\t\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Create a new thread\n\n#if (_SILVERLIGHT) || (WINDOWS_PHONE) || (_WINDOWS_CE)\n#if SSHARP\n\t\t\t\t\tvar te = new ThreadEntry (this);\n\n\t\t\t\t\tThread workerThread = new Thread (ProcessQueuedItems, te, Thread.eThreadStartOptions.CreateSuspended);\n#else\n\t\t\t\t\tThread workerThread = new Thread (ProcessQueuedItems, null);\n#endif\n#else\n                    Thread workerThread =\n                        _stpStartInfo.MaxStackSize.HasValue\n                        ? new Thread(ProcessQueuedItems, _stpStartInfo.MaxStackSize.Value)\n                        : new Thread(ProcessQueuedItems);\n#endif\n\t\t\t\t\t// Configure the new thread and start it\n\t\t\t\t\tworkerThread.Name = \"STP \" + Name + \" Thread #\" + _threadCounter;\n#if !SSHARP\n\t\t\t\t\tworkerThread.IsBackground = _stpStartInfo.AreThreadsBackground;\n#endif\n\n#if !(_SILVERLIGHT) && !(_WINDOWS_CE) && !(WINDOWS_PHONE)\n                    if (_stpStartInfo.ApartmentState != ApartmentState.Unknown)\n                    {\n                        workerThread.SetApartmentState(_stpStartInfo.ApartmentState);\n                    }\n#endif\n\n#if !(_SILVERLIGHT) && !(WINDOWS_PHONE)\n\t\t\t\t\tworkerThread.Priority = _stpStartInfo.ThreadPriority;\n#endif\n\t\t\t\t\tworkerThread.Start ();\n\t\t\t\t\t++_threadCounter;\n\n#if SSHARP\n\t\t\t\t\t_workerThreads.AddPendingEntry ();\n#else\n\t\t\t\t\t// Add it to the dictionary and update its creation time.\n\t\t\t\t\t_workerThreads[workerThread] = new ThreadEntry (this);\n#endif\n\n\t\t\t\t\t_windowsPCs.SampleThreads (_workerThreads.Count, _inUseWorkerThreads);\n\t\t\t\t\t_localPCs.SampleThreads (_workerThreads.Count, _inUseWorkerThreads);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// A worker thread method that processes work items from the work items queue.\n\t\t/// </summary>\n\t\tprivate object ProcessQueuedItems (object state)\n\t\t\t{\n#if SSHARP\n\t\t\tvar te = (ThreadEntry)state;\n\t\t\t_workerThreads[Thread.CurrentThread] = te;\n\t\t\t_workerThreads.RemovePendingEntry ();\n#endif\n\n\t\t\t// Keep the entry of the dictionary as thread's variable to avoid the synchronization locks\n\t\t\t// of the dictionary.\n\t\t\tCurrentThreadEntry = _workerThreads[Thread.CurrentThread];\n\n\t\t\tFireOnThreadInitialization ();\n\n\t\t\ttry\n\t\t\t\t{\n\t\t\t\tbool bInUseWorkerThreadsWasIncremented = false;\n\n\t\t\t\t// Process until shutdown.\n\t\t\t\twhile (!_shutdown)\n\t\t\t\t\t{\n\t\t\t\t\t// Update the last time this thread was seen alive.\n\t\t\t\t\t// It's good for debugging.\n\t\t\t\t\tCurrentThreadEntry.IAmAlive ();\n\n\t\t\t\t\t// The following block handles the when the MaxWorkerThreads has been\n\t\t\t\t\t// incremented by the user at run-time.\n\t\t\t\t\t// Double lock for quit.\n\t\t\t\t\tif (_workerThreads.Count > _stpStartInfo.MaxWorkerThreads)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tlock (_workerThreads.SyncRoot)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (_workerThreads.Count > _stpStartInfo.MaxWorkerThreads)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Inform that the thread is quiting and then quit.\n\t\t\t\t\t\t\t\t// This method must be called within this lock or else\n\t\t\t\t\t\t\t\t// more threads will quit and the thread pool will go\n\t\t\t\t\t\t\t\t// below the lower limit.\n\t\t\t\t\t\t\t\tInformCompleted ();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Wait for a work item, shutdown, or timeout\n\t\t\t\t\tWorkItem workItem = Dequeue ();\n\n\t\t\t\t\t// Update the last time this thread was seen alive.\n\t\t\t\t\t// It's good for debugging.\n\t\t\t\t\tCurrentThreadEntry.IAmAlive ();\n\n\t\t\t\t\t// On timeout or shut down.\n\t\t\t\t\tif (null == workItem)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t// Double lock for quit.\n\t\t\t\t\t\tif (_workerThreads.Count > _stpStartInfo.MinWorkerThreads)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlock (_workerThreads.SyncRoot)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (_workerThreads.Count > _stpStartInfo.MinWorkerThreads)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Inform that the thread is quiting and then quit.\n\t\t\t\t\t\t\t\t\t// This method must be called within this lock or else\n\t\t\t\t\t\t\t\t\t// more threads will quit and the thread pool will go\n\t\t\t\t\t\t\t\t\t// below the lower limit.\n\t\t\t\t\t\t\t\t\tInformCompleted ();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// If we didn't quit then skip to the next iteration.\n\t\t\t\t\tif (null == workItem)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t// Initialize the value to false\n\t\t\t\t\t\tbInUseWorkerThreadsWasIncremented = false;\n\n\t\t\t\t\t\t// Set the Current Work Item of the thread.\n\t\t\t\t\t\t// Store the Current Work Item  before the workItem.StartingWorkItem() is called, \n\t\t\t\t\t\t// so WorkItem.Cancel can work when the work item is between InQueue and InProgress \n\t\t\t\t\t\t// states.\n\t\t\t\t\t\t// If the work item has been cancelled BEFORE the workItem.StartingWorkItem() \n\t\t\t\t\t\t// (work item is in InQueue state) then workItem.StartingWorkItem() will return false.\n\t\t\t\t\t\t// If the work item has been cancelled AFTER the workItem.StartingWorkItem() then\n\t\t\t\t\t\t// (work item is in InProgress state) then the thread will be aborted\n\t\t\t\t\t\tCurrentThreadEntry.CurrentWorkItem = workItem;\n\n\t\t\t\t\t\t// Change the state of the work item to 'in progress' if possible.\n\t\t\t\t\t\t// We do it here so if the work item has been canceled we won't \n\t\t\t\t\t\t// increment the _inUseWorkerThreads.\n\t\t\t\t\t\t// The cancel mechanism doesn't delete items from the queue,  \n\t\t\t\t\t\t// it marks the work item as canceled, and when the work item\n\t\t\t\t\t\t// is dequeued, we just skip it.\n\t\t\t\t\t\t// If the post execute of work item is set to always or to\n\t\t\t\t\t\t// call when the work item is canceled then the StartingWorkItem()\n\t\t\t\t\t\t// will return true, so the post execute can run.\n\t\t\t\t\t\tif (!workItem.StartingWorkItem ())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Execute the callback.  Make sure to accurately\n\t\t\t\t\t\t// record how many callbacks are currently executing.\n\t\t\t\t\t\tint inUseWorkerThreads = Interlocked.Increment (ref _inUseWorkerThreads);\n\t\t\t\t\t\t_windowsPCs.SampleThreads (_workerThreads.Count, inUseWorkerThreads);\n\t\t\t\t\t\t_localPCs.SampleThreads (_workerThreads.Count, inUseWorkerThreads);\n\n\t\t\t\t\t\t// Mark that the _inUseWorkerThreads incremented, so in the finally{}\n\t\t\t\t\t\t// statement we will decrement it correctly.\n\t\t\t\t\t\tbInUseWorkerThreadsWasIncremented = true;\n\n\t\t\t\t\t\tworkItem.FireWorkItemStarted ();\n\n\t\t\t\t\t\tExecuteWorkItem (workItem);\n\t\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tex.GetHashCode ();\n\t\t\t\t\t\t// Do nothing\n\t\t\t\t\t\t}\n\t\t\t\t\tfinally\n\t\t\t\t\t\t{\n\t\t\t\t\t\tworkItem.DisposeOfState ();\n\n\t\t\t\t\t\t// Set the CurrentWorkItem to null, since we \n\t\t\t\t\t\t// no longer run user's code.\n\t\t\t\t\t\tCurrentThreadEntry.CurrentWorkItem = null;\n\n\t\t\t\t\t\t// Decrement the _inUseWorkerThreads only if we had \n\t\t\t\t\t\t// incremented it. Note the cancelled work items don't\n\t\t\t\t\t\t// increment _inUseWorkerThreads.\n\t\t\t\t\t\tif (bInUseWorkerThreadsWasIncremented)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint inUseWorkerThreads = Interlocked.Decrement (ref _inUseWorkerThreads);\n\t\t\t\t\t\t\t_windowsPCs.SampleThreads (_workerThreads.Count, inUseWorkerThreads);\n\t\t\t\t\t\t\t_localPCs.SampleThreads (_workerThreads.Count, inUseWorkerThreads);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Notify that the work item has been completed.\n\t\t\t\t\t\t// WorkItemsGroup may enqueue their next work item.\n\t\t\t\t\t\tworkItem.FireWorkItemCompleted ();\n\n\t\t\t\t\t\t// Decrement the number of work items here so the idle \n\t\t\t\t\t\t// ManualResetEvent won't fluctuate.\n\t\t\t\t\t\tDecrementWorkItemsCount ();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#if SSHARP\n\t\t\tcatch (Exception tae)\n#else\n\t\t\tcatch (ThreadAbortException tae)\n#endif\n\t\t\t\t{\n#if SSHARP\n\t\t\t\tException e = tae;\n\n\t\t\t\tif (tae is ThreadAbortException)\n\t\t\t\t\t{\n#endif\n\t\t\t\ttae.GetHashCode ();\n\t\t\t\t// Handle the abort exception gracfully.\n#if !(_WINDOWS_CE) && !(_SILVERLIGHT) && !(WINDOWS_PHONE)\n\t\t\t\tThread.ResetAbort();\n#endif\n\n\t\t\t\t}\n#if !SSHARP\n\t\t\tcatch (Exception e)\n\t\t\t\t{\n#endif\n\t\t\t\t//Debug.Assert (null != e);\n\t\t\t\t}\n\t\t\tfinally\n\t\t\t\t{\n\t\t\t\tInformCompleted ();\n\t\t\t\tFireOnThreadTermination ();\n\t\t\t\t}\n\n\t\t\treturn null;\n\t\t\t}\n\n\t\tprivate void ExecuteWorkItem (WorkItem workItem)\n\t\t\t{\n\t\t\t_windowsPCs.SampleWorkItemsWaitTime (workItem.WaitingTime);\n\t\t\t_localPCs.SampleWorkItemsWaitTime (workItem.WaitingTime);\n\t\t\ttry\n\t\t\t\t{\n\t\t\t\tworkItem.Execute ();\n\t\t\t\t}\n\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t_windowsPCs.SampleWorkItemsProcessTime (workItem.ProcessTime);\n\t\t\t\t_localPCs.SampleWorkItemsProcessTime (workItem.ProcessTime);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t#endregion\n\n\t\t#region Public Methods\n\n\t\tprivate void ValidateWaitForIdle ()\n\t\t\t{\n\t\t\tif (null != CurrentThreadEntry && CurrentThreadEntry.AssociatedSmartThreadPool == this)\n\t\t\t\t{\n\t\t\t\tthrow new NotSupportedException (\n\t\t\t\t\t\"WaitForIdle cannot be called from a thread on its SmartThreadPool, it causes a deadlock\");\n\t\t\t\t}\n\t\t\t}\n\n\t\tinternal static void ValidateWorkItemsGroupWaitForIdle (IWorkItemsGroup workItemsGroup)\n\t\t\t{\n\t\t\tif (null == CurrentThreadEntry)\n\t\t\t\t{\n\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\tWorkItem workItem = CurrentThreadEntry.CurrentWorkItem;\n\t\t\tValidateWorkItemsGroupWaitForIdleImpl (workItemsGroup, workItem);\n\t\t\tif ((null != workItemsGroup) &&\n\t\t\t\t(null != workItem) &&\n\t\t\t\tCurrentThreadEntry.CurrentWorkItem.WasQueuedBy (workItemsGroup))\n\t\t\t\t{\n\t\t\t\tthrow new NotSupportedException (\"WaitForIdle cannot be called from a thread on its SmartThreadPool, it causes a deadlock\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t[MethodImpl (MethodImplOptions.NoInlining)]\n\t\tprivate static void ValidateWorkItemsGroupWaitForIdleImpl (IWorkItemsGroup workItemsGroup, WorkItem workItem)\n\t\t\t{\n\t\t\tif ((null != workItemsGroup) &&\n\t\t\t\t(null != workItem) &&\n\t\t\t\tworkItem.WasQueuedBy (workItemsGroup))\n\t\t\t\t{\n\t\t\t\tthrow new NotSupportedException (\"WaitForIdle cannot be called from a thread on its SmartThreadPool, it causes a deadlock\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Force the SmartThreadPool to shutdown\n\t\t/// </summary>\n\t\tpublic void Shutdown ()\n\t\t\t{\n\t\t\tShutdown (true, 0);\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Force the SmartThreadPool to shutdown with timeout\n\t\t/// </summary>\n\t\tpublic void Shutdown (bool forceAbort, TimeSpan timeout)\n\t\t\t{\n\t\t\tShutdown (forceAbort, (int)timeout.TotalMilliseconds);\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Empties the queue of work items and abort the threads in the pool.\n\t\t/// </summary>\n\t\tpublic void Shutdown (bool forceAbort, int millisecondsTimeout)\n\t\t\t{\n\t\t\tValidateNotDisposed ();\n\n\t\t\tISTPInstancePerformanceCounters pcs = _windowsPCs;\n\n\t\t\tif (NullSTPInstancePerformanceCounters.Instance != _windowsPCs)\n\t\t\t\t{\n\t\t\t\t// Set the _pcs to \"null\" to stop updating the performance\n\t\t\t\t// counters\n\t\t\t\t_windowsPCs = NullSTPInstancePerformanceCounters.Instance;\n\n\t\t\t\tpcs.Dispose ();\n\t\t\t\t}\n\n\t\t\tThread[] threads;\n\t\t\tlock (_workerThreads.SyncRoot)\n\t\t\t\t{\n\t\t\t\t// Shutdown the work items queue\n\t\t\t\t_workItemsQueue.Dispose ();\n\n\t\t\t\t// Signal the threads to exit\n\t\t\t\t_shutdown = true;\n\t\t\t\t_shuttingDownEvent.Set ();\n\n\t\t\t\t// Make a copy of the threads' references in the pool\n#if SSHARP\n\t\t\t\tthreads = new Thread[_workerThreads.RealCount];\n#else\n\t\t\t\tthreads = new Thread[_workerThreads.Count];\n#endif\n\t\t\t\t_workerThreads.Keys.CopyTo (threads, 0);\n\t\t\t\t}\n\n\t\t\tint millisecondsLeft = millisecondsTimeout;\n\t\t\tStopwatch stopwatch = Stopwatch.StartNew ();\n\t\t\t//DateTime start = DateTime.UtcNow;\n\t\t\tbool waitInfinitely = (Timeout.Infinite == millisecondsTimeout);\n\t\t\tbool timeout = false;\n\n\t\t\t// Each iteration we update the time left for the timeout.\n\t\t\tforeach (Thread thread in threads)\n\t\t\t\t{\n\t\t\t\t// Join don't work with negative numbers\n\t\t\t\tif (!waitInfinitely && (millisecondsLeft < 0))\n\t\t\t\t\t{\n\t\t\t\t\ttimeout = true;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t// Wait for the thread to terminate\n#if SSHARP\n\t\t\t\tbool success;\n\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\tsuccess = thread.Join (millisecondsLeft);\n\t\t\t\t\t}\n\t\t\t\tcatch (NullReferenceException)\n\t\t\t\t\t{\n\t\t\t\t\tsuccess = true;\n\t\t\t\t\t}\n#else\n\t\t\t\tbool success = thread.Join (millisecondsLeft);\n#endif\n\t\t\t\tif (!success)\n\t\t\t\t\t{\n\t\t\t\t\ttimeout = true;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tif (!waitInfinitely)\n\t\t\t\t\t{\n\t\t\t\t\t// Update the time left to wait\n\t\t\t\t\t//TimeSpan ts = DateTime.UtcNow - start;\n\t\t\t\t\tmillisecondsLeft = millisecondsTimeout - (int)stopwatch.ElapsedMilliseconds;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tif (timeout && forceAbort)\n\t\t\t\t{\n\t\t\t\t// Abort the threads in the pool\n\t\t\t\tforeach (Thread thread in threads)\n\t\t\t\t\t{\n\n#if SSHARP\n\t\t\t\t\tbool running = false;\n\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\trunning = thread != null && !thread.Join (0);\n\t\t\t\t\t\t}\n\t\t\t\t\tcatch (NullReferenceException)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\n\t\t\t\t\tif (running)\n#else\n\t\t\t\t\tif ((thread != null)\n#if (_WINDOWS_CE)\n\t\t\t\t\t\t&& !thread.Join (0)\n#else\n                        && thread.IsAlive\n#endif\n)\n#endif\n\t\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthread.Abort (); // Shutdown\n\t\t\t\t\t\t\t}\n#if SSHARP\n\t\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (e.GetType () != typeof (System.Threading.ThreadAbortException) && e.GetType () != typeof (SecurityException))\n\t\t\t\t\t\t\t\tthrow;\n\t\t\t\t\t\t\te.GetHashCode ();\n\t\t\t\t\t\t\t}\n#else\n\t\t\t\t\t\tcatch (SecurityException e)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\te.GetHashCode ();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (ThreadStateException ex)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tex.GetHashCode ();\n\t\t\t\t\t\t\t// In case the thread has been terminated \n\t\t\t\t\t\t\t// after the check if it is alive.\n\t\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Wait for all work items to complete\n\t\t/// </summary>\n\t\t/// <param name=\"waitableResults\">Array of work item result objects</param>\n\t\t/// <returns>\n\t\t/// true when every work item in workItemResults has completed; otherwise false.\n\t\t/// </returns>\n\t\tpublic static bool WaitAll (\n\t\t\tIWaitableResult[] waitableResults)\n\t\t\t{\n\t\t\treturn WaitAll (waitableResults, Timeout.Infinite, true);\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Wait for all work items to complete\n\t\t/// </summary>\n\t\t/// <param name=\"waitableResults\">Array of work item result objects</param>\n\t\t/// <param name=\"timeout\">The number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely. </param>\n\t\t/// <param name=\"exitContext\">\n\t\t/// true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. \n\t\t/// </param>\n\t\t/// <returns>\n\t\t/// true when every work item in workItemResults has completed; otherwise false.\n\t\t/// </returns>\n\t\tpublic static bool WaitAll (\n\t\t\tIWaitableResult[] waitableResults,\n\t\t\tTimeSpan timeout,\n\t\t\tbool exitContext)\n\t\t\t{\n\t\t\treturn WaitAll (waitableResults, (int)timeout.TotalMilliseconds, exitContext);\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Wait for all work items to complete\n\t\t/// </summary>\n\t\t/// <param name=\"waitableResults\">Array of work item result objects</param>\n\t\t/// <param name=\"timeout\">The number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely. </param>\n\t\t/// <param name=\"exitContext\">\n\t\t/// true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. \n\t\t/// </param>\n\t\t/// <param name=\"cancelWaitHandle\">A cancel wait handle to interrupt the wait if needed</param>\n\t\t/// <returns>\n\t\t/// true when every work item in workItemResults has completed; otherwise false.\n\t\t/// </returns>\n\t\tpublic static bool WaitAll (\n\t\t\tIWaitableResult[] waitableResults,\n\t\t\tTimeSpan timeout,\n\t\t\tbool exitContext,\n\t\t\tWaitHandle cancelWaitHandle)\n\t\t\t{\n\t\t\treturn WaitAll (waitableResults, (int)timeout.TotalMilliseconds, exitContext, cancelWaitHandle);\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Wait for all work items to complete\n\t\t/// </summary>\n\t\t/// <param name=\"waitableResults\">Array of work item result objects</param>\n\t\t/// <param name=\"millisecondsTimeout\">The number of milliseconds to wait, or Timeout.Infinite (-1) to wait indefinitely.</param>\n\t\t/// <param name=\"exitContext\">\n\t\t/// true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. \n\t\t/// </param>\n\t\t/// <returns>\n\t\t/// true when every work item in workItemResults has completed; otherwise false.\n\t\t/// </returns>\n\t\tpublic static bool WaitAll (\n\t\t\tIWaitableResult[] waitableResults,\n\t\t\tint millisecondsTimeout,\n\t\t\tbool exitContext)\n\t\t\t{\n\t\t\treturn WorkItem.WaitAll (waitableResults, millisecondsTimeout, exitContext, null);\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Wait for all work items to complete\n\t\t/// </summary>\n\t\t/// <param name=\"waitableResults\">Array of work item result objects</param>\n\t\t/// <param name=\"millisecondsTimeout\">The number of milliseconds to wait, or Timeout.Infinite (-1) to wait indefinitely.</param>\n\t\t/// <param name=\"exitContext\">\n\t\t/// true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. \n\t\t/// </param>\n\t\t/// <param name=\"cancelWaitHandle\">A cancel wait handle to interrupt the wait if needed</param>\n\t\t/// <returns>\n\t\t/// true when every work item in workItemResults has completed; otherwise false.\n\t\t/// </returns>\n\t\tpublic static bool WaitAll (\n\t\t\tIWaitableResult[] waitableResults,\n\t\t\tint millisecondsTimeout,\n\t\t\tbool exitContext,\n\t\t\tWaitHandle cancelWaitHandle)\n\t\t\t{\n\t\t\treturn WorkItem.WaitAll (waitableResults, millisecondsTimeout, exitContext, cancelWaitHandle);\n\t\t\t}\n\n\n\t\t/// <summary>\n\t\t/// Waits for any of the work items in the specified array to complete, cancel, or timeout\n\t\t/// </summary>\n\t\t/// <param name=\"waitableResults\">Array of work item result objects</param>\n\t\t/// <returns>\n\t\t/// The array index of the work item result that satisfied the wait, or WaitTimeout if any of the work items has been canceled.\n\t\t/// </returns>\n\t\tpublic static int WaitAny (\n\t\t\tIWaitableResult[] waitableResults)\n\t\t\t{\n\t\t\treturn WaitAny (waitableResults, Timeout.Infinite, true);\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Waits for any of the work items in the specified array to complete, cancel, or timeout\n\t\t/// </summary>\n\t\t/// <param name=\"waitableResults\">Array of work item result objects</param>\n\t\t/// <param name=\"timeout\">The number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely. </param>\n\t\t/// <param name=\"exitContext\">\n\t\t/// true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. \n\t\t/// </param>\n\t\t/// <returns>\n\t\t/// The array index of the work item result that satisfied the wait, or WaitTimeout if no work item result satisfied the wait and a time interval equivalent to millisecondsTimeout has passed or the work item has been canceled.\n\t\t/// </returns>\n\t\tpublic static int WaitAny (\n\t\t\tIWaitableResult[] waitableResults,\n\t\t\tTimeSpan timeout,\n\t\t\tbool exitContext)\n\t\t\t{\n\t\t\treturn WaitAny (waitableResults, (int)timeout.TotalMilliseconds, exitContext);\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Waits for any of the work items in the specified array to complete, cancel, or timeout\n\t\t/// </summary>\n\t\t/// <param name=\"waitableResults\">Array of work item result objects</param>\n\t\t/// <param name=\"timeout\">The number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely. </param>\n\t\t/// <param name=\"exitContext\">\n\t\t/// true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. \n\t\t/// </param>\n\t\t/// <param name=\"cancelWaitHandle\">A cancel wait handle to interrupt the wait if needed</param>\n\t\t/// <returns>\n\t\t/// The array index of the work item result that satisfied the wait, or WaitTimeout if no work item result satisfied the wait and a time interval equivalent to millisecondsTimeout has passed or the work item has been canceled.\n\t\t/// </returns>\n\t\tpublic static int WaitAny (\n\t\t\tIWaitableResult[] waitableResults,\n\t\t\tTimeSpan timeout,\n\t\t\tbool exitContext,\n\t\t\tWaitHandle cancelWaitHandle)\n\t\t\t{\n\t\t\treturn WaitAny (waitableResults, (int)timeout.TotalMilliseconds, exitContext, cancelWaitHandle);\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Waits for any of the work items in the specified array to complete, cancel, or timeout\n\t\t/// </summary>\n\t\t/// <param name=\"waitableResults\">Array of work item result objects</param>\n\t\t/// <param name=\"millisecondsTimeout\">The number of milliseconds to wait, or Timeout.Infinite (-1) to wait indefinitely.</param>\n\t\t/// <param name=\"exitContext\">\n\t\t/// true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. \n\t\t/// </param>\n\t\t/// <returns>\n\t\t/// The array index of the work item result that satisfied the wait, or WaitTimeout if no work item result satisfied the wait and a time interval equivalent to millisecondsTimeout has passed or the work item has been canceled.\n\t\t/// </returns>\n\t\tpublic static int WaitAny (\n\t\t\tIWaitableResult[] waitableResults,\n\t\t\tint millisecondsTimeout,\n\t\t\tbool exitContext)\n\t\t\t{\n\t\t\treturn WorkItem.WaitAny (waitableResults, millisecondsTimeout, exitContext, null);\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Waits for any of the work items in the specified array to complete, cancel, or timeout\n\t\t/// </summary>\n\t\t/// <param name=\"waitableResults\">Array of work item result objects</param>\n\t\t/// <param name=\"millisecondsTimeout\">The number of milliseconds to wait, or Timeout.Infinite (-1) to wait indefinitely.</param>\n\t\t/// <param name=\"exitContext\">\n\t\t/// true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. \n\t\t/// </param>\n\t\t/// <param name=\"cancelWaitHandle\">A cancel wait handle to interrupt the wait if needed</param>\n\t\t/// <returns>\n\t\t/// The array index of the work item result that satisfied the wait, or WaitTimeout if no work item result satisfied the wait and a time interval equivalent to millisecondsTimeout has passed or the work item has been canceled.\n\t\t/// </returns>\n\t\tpublic static int WaitAny (\n\t\t\tIWaitableResult[] waitableResults,\n\t\t\tint millisecondsTimeout,\n\t\t\tbool exitContext,\n\t\t\tWaitHandle cancelWaitHandle)\n\t\t\t{\n\t\t\treturn WorkItem.WaitAny (waitableResults, millisecondsTimeout, exitContext, cancelWaitHandle);\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Creates a new WorkItemsGroup.\n\t\t/// </summary>\n\t\t/// <param name=\"concurrency\">The number of work items that can be run concurrently</param>\n\t\t/// <returns>A reference to the WorkItemsGroup</returns>\n\t\tpublic IWorkItemsGroup CreateWorkItemsGroup (int concurrency)\n\t\t\t{\n\t\t\tIWorkItemsGroup workItemsGroup = new WorkItemsGroup (this, concurrency, _stpStartInfo);\n\t\t\treturn workItemsGroup;\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Creates a new WorkItemsGroup.\n\t\t/// </summary>\n\t\t/// <param name=\"concurrency\">The number of work items that can be run concurrently</param>\n\t\t/// <param name=\"wigStartInfo\">A WorkItemsGroup configuration that overrides the default behavior</param>\n\t\t/// <returns>A reference to the WorkItemsGroup</returns>\n\t\tpublic IWorkItemsGroup CreateWorkItemsGroup (int concurrency, WIGStartInfo wigStartInfo)\n\t\t\t{\n\t\t\tIWorkItemsGroup workItemsGroup = new WorkItemsGroup (this, concurrency, wigStartInfo);\n\t\t\treturn workItemsGroup;\n\t\t\t}\n\n\t\t#region Fire Thread's Events\n\n\t\tprivate void FireOnThreadInitialization ()\n\t\t\t{\n\t\t\tif (null != _onThreadInitialization)\n\t\t\t\t{\n\t\t\t\tforeach (ThreadInitializationHandler tih in _onThreadInitialization.GetInvocationList ())\n\t\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\ttih ();\n\t\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\te.GetHashCode ();\n\t\t\t\t\t\t//Debug.Assert (false);\n\t\t\t\t\t\tthrow;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tprivate void FireOnThreadTermination ()\n\t\t\t{\n\t\t\tif (null != _onThreadTermination)\n\t\t\t\t{\n\t\t\t\tforeach (ThreadTerminationHandler tth in _onThreadTermination.GetInvocationList ())\n\t\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\ttth ();\n\t\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\te.GetHashCode ();\n\t\t\t\t\t\t//Debug.Assert (false);\n\t\t\t\t\t\tthrow;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t#endregion\n\n\t\t/// <summary>\n\t\t/// This event is fired when a thread is created.\n\t\t/// Use it to initialize a thread before the work items use it.\n\t\t/// </summary>\n\t\tpublic event ThreadInitializationHandler OnThreadInitialization\n\t\t\t{\n\t\t\tadd { _onThreadInitialization += value; }\n\t\t\tremove { _onThreadInitialization -= value; }\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// This event is fired when a thread is terminating.\n\t\t/// Use it for cleanup.\n\t\t/// </summary>\n\t\tpublic event ThreadTerminationHandler OnThreadTermination\n\t\t\t{\n\t\t\tadd { _onThreadTermination += value; }\n\t\t\tremove { _onThreadTermination -= value; }\n\t\t\t}\n\n\n\t\tinternal void CancelAbortWorkItemsGroup (WorkItemsGroup wig)\n\t\t\t{\n\t\t\tThreadEntry[] threadEntries;\n\t\t\tlock (_workerThreads.SyncRoot)\n\t\t\t\t{\n\t\t\t\tthreadEntries = new ThreadEntry[_workerThreads.RealCount];\n\t\t\t\t_workerThreads.Values.CopyTo (threadEntries, 0);\n\t\t\t\t}\n\n\t\t\tforeach (ThreadEntry threadEntry in threadEntries)\n\t\t\t\t{\n\t\t\t\tWorkItem workItem = threadEntry.CurrentWorkItem;\n\t\t\t\tif (null != workItem &&\n\t\t\t\t\tworkItem.WasQueuedBy (wig) &&\n\t\t\t\t\t!workItem.IsCanceled)\n\t\t\t\t\t{\n\t\t\t\t\tthreadEntry.CurrentWorkItem.GetWorkItemResult ().Cancel (true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t#endregion\n\n\t\t#region Properties\n\n\t\t/// <summary>\n\t\t/// Get/Set the lower limit of threads in the pool.\n\t\t/// </summary>\n\t\tpublic int MinThreads\n\t\t\t{\n\t\t\tget\n\t\t\t\t{\n\t\t\t\tValidateNotDisposed ();\n\t\t\t\treturn _stpStartInfo.MinWorkerThreads;\n\t\t\t\t}\n\t\t\tset\n\t\t\t\t{\n\t\t\t\t//Debug.Assert (value >= 0);\n\t\t\t\t//Debug.Assert (value <= _stpStartInfo.MaxWorkerThreads);\n\t\t\t\tif (_stpStartInfo.MaxWorkerThreads < value)\n\t\t\t\t\t{\n\t\t\t\t\t_stpStartInfo.MaxWorkerThreads = value;\n\t\t\t\t\t}\n\t\t\t\t_stpStartInfo.MinWorkerThreads = value;\n\t\t\t\tStartOptimalNumberOfThreads ();\n\t\t\t\t}\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Get/Set the upper limit of threads in the pool.\n\t\t/// </summary>\n\t\tpublic int MaxThreads\n\t\t\t{\n\t\t\tget\n\t\t\t\t{\n\t\t\t\tValidateNotDisposed ();\n\t\t\t\treturn _stpStartInfo.MaxWorkerThreads;\n\t\t\t\t}\n\n\t\t\tset\n\t\t\t\t{\n\t\t\t\t//Debug.Assert (value > 0);\n\t\t\t\t//Debug.Assert (value >= _stpStartInfo.MinWorkerThreads);\n\t\t\t\tif (_stpStartInfo.MinWorkerThreads > value)\n\t\t\t\t\t{\n\t\t\t\t\t_stpStartInfo.MinWorkerThreads = value;\n\t\t\t\t\t}\n\t\t\t\t_stpStartInfo.MaxWorkerThreads = value;\n\t\t\t\tStartOptimalNumberOfThreads ();\n\t\t\t\t}\n\t\t\t}\n\t\t/// <summary>\n\t\t/// Get the number of threads in the thread pool.\n\t\t/// Should be between the lower and the upper limits.\n\t\t/// </summary>\n\t\tpublic int ActiveThreads\n\t\t\t{\n\t\t\tget\n\t\t\t\t{\n\t\t\t\tValidateNotDisposed ();\n\t\t\t\treturn _workerThreads.Count;\n\t\t\t\t}\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Get the number of busy (not idle) threads in the thread pool.\n\t\t/// </summary>\n\t\tpublic int InUseThreads\n\t\t\t{\n\t\t\tget\n\t\t\t\t{\n\t\t\t\tValidateNotDisposed ();\n\t\t\t\treturn _inUseWorkerThreads;\n\t\t\t\t}\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Returns true if the current running work item has been cancelled.\n\t\t/// Must be used within the work item's callback method.\n\t\t/// The work item should sample this value in order to know if it\n\t\t/// needs to quit before its completion.\n\t\t/// </summary>\n\t\tpublic static bool IsWorkItemCanceled\n\t\t\t{\n\t\t\tget\n\t\t\t\t{\n\t\t\t\treturn CurrentThreadEntry.CurrentWorkItem.IsCanceled;\n\t\t\t\t}\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Checks if the work item has been cancelled, and if yes then abort the thread.\n\t\t/// Can be used with Cancel and timeout\n\t\t/// </summary>\n\t\tpublic static void AbortOnWorkItemCancel ()\n\t\t\t{\n\t\t\tif (IsWorkItemCanceled)\n\t\t\t\t{\n\t\t\t\tThread.CurrentThread.Abort ();\n\t\t\t\t}\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Thread Pool start information (readonly)\n\t\t/// </summary>\n\t\tpublic STPStartInfo STPStartInfo\n\t\t\t{\n\t\t\tget\n\t\t\t\t{\n\t\t\t\treturn _stpStartInfo.AsReadOnly ();\n\t\t\t\t}\n\t\t\t}\n\n\t\tpublic bool IsShuttingdown\n\t\t\t{\n\t\t\tget { return _shutdown; }\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Return the local calculated performance counters\n\t\t/// Available only if STPStartInfo.EnableLocalPerformanceCounters is true.\n\t\t/// </summary>\n\t\tpublic ISTPPerformanceCountersReader PerformanceCountersReader\n\t\t\t{\n\t\t\tget { return (ISTPPerformanceCountersReader)_localPCs; }\n\t\t\t}\n\t\t#endregion\n\n\t\t#region IDisposable Members\n\n\t\tpublic void Dispose ()\n\t\t\t{\n\t\t\tif (!_isDisposed)\n\t\t\t\t{\n\t\t\t\tif (!_shutdown)\n\t\t\t\t\t{\n\t\t\t\t\tShutdown ();\n\t\t\t\t\t}\n\n\t\t\t\tif (null != _shuttingDownEvent)\n\t\t\t\t\t{\n\t\t\t\t\t_shuttingDownEvent.Close ();\n\t\t\t\t\t_shuttingDownEvent = null;\n\t\t\t\t\t}\n\t\t\t\t_workerThreads.Clear ();\n\n\t\t\t\tif (null != _isIdleWaitHandle)\n\t\t\t\t\t{\n\t\t\t\t\t_isIdleWaitHandle.Close ();\n\t\t\t\t\t_isIdleWaitHandle = null;\n\t\t\t\t\t}\n\n\t\t\t\t_isDisposed = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\tprivate void ValidateNotDisposed ()\n\t\t\t{\n\t\t\tif (_isDisposed)\n\t\t\t\t{\n\t\t\t\tthrow new ObjectDisposedException (GetType ().ToString (), \"The SmartThreadPool has been shutdown\");\n\t\t\t\t}\n\t\t\t}\n\t\t#endregion\n\n\t\t#region WorkItemsGroupBase Overrides\n\n\t\t/// <summary>\n\t\t/// Get/Set the maximum number of work items that execute cocurrency on the thread pool\n\t\t/// </summary>\n\t\tpublic override int Concurrency\n\t\t\t{\n\t\t\tget { return MaxThreads; }\n\t\t\tset { MaxThreads = value; }\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Get the number of work items in the queue.\n\t\t/// </summary>\n\t\tpublic override int WaitingCallbacks\n\t\t\t{\n\t\t\tget\n\t\t\t\t{\n\t\t\t\tValidateNotDisposed ();\n\t\t\t\treturn _workItemsQueue.Count;\n\t\t\t\t}\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Get an array with all the state objects of the currently running items.\n\t\t/// The array represents a snap shot and impact performance.\n\t\t/// </summary>\n\t\tpublic override object[] GetStates ()\n\t\t\t{\n\t\t\tobject[] states = _workItemsQueue.GetStates ();\n\t\t\treturn states;\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// WorkItemsGroup start information (readonly)\n\t\t/// </summary>\n\t\tpublic override WIGStartInfo WIGStartInfo\n\t\t\t{\n\t\t\tget { return _stpStartInfo.AsReadOnly (); }\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Start the thread pool if it was started suspended.\n\t\t/// If it is already running, this method is ignored.\n\t\t/// </summary>\n\t\tpublic override void Start ()\n\t\t\t{\n\t\t\tif (!_isSuspended)\n\t\t\t\t{\n\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t_isSuspended = false;\n\n\t\t\tICollection workItemsGroups = _workItemsGroups.Values;\n\t\t\tforeach (WorkItemsGroup workItemsGroup in workItemsGroups)\n\t\t\t\t{\n\t\t\t\tworkItemsGroup.OnSTPIsStarting ();\n\t\t\t\t}\n\n\t\t\tStartOptimalNumberOfThreads ();\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Cancel all work items using thread abortion\n\t\t/// </summary>\n\t\t/// <param name=\"abortExecution\">True to stop work items by raising ThreadAbortException</param>\n\t\tpublic override void Cancel (bool abortExecution)\n\t\t\t{\n\t\t\t_canceledSmartThreadPool.IsCanceled = true;\n\t\t\t_canceledSmartThreadPool = new CanceledWorkItemsGroup ();\n\n\t\t\tICollection workItemsGroups = _workItemsGroups.Values;\n\t\t\tforeach (WorkItemsGroup workItemsGroup in workItemsGroups)\n\t\t\t\t{\n\t\t\t\tworkItemsGroup.Cancel (abortExecution);\n\t\t\t\t}\n\n\t\t\tif (abortExecution)\n\t\t\t\t{\n\t\t\t\tforeach (ThreadEntry threadEntry in _workerThreads.Values)\n\t\t\t\t\t{\n\t\t\t\t\tWorkItem workItem = threadEntry.CurrentWorkItem;\n\t\t\t\t\tif (null != workItem &&\n\t\t\t\t\t\tthreadEntry.AssociatedSmartThreadPool == this &&\n\t\t\t\t\t\t!workItem.IsCanceled)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tthreadEntry.CurrentWorkItem.GetWorkItemResult ().Cancel (true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Wait for the thread pool to be idle\n\t\t/// </summary>\n\t\tpublic override bool WaitForIdle (int millisecondsTimeout)\n\t\t\t{\n\t\t\tValidateWaitForIdle ();\n\t\t\treturn STPEventWaitHandle.WaitOne (_isIdleWaitHandle, millisecondsTimeout, false);\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// This event is fired when all work items are completed.\n\t\t/// (When IsIdle changes to true)\n\t\t/// This event only work on WorkItemsGroup. On SmartThreadPool\n\t\t/// it throws the NotImplementedException.\n\t\t/// </summary>\n\t\tpublic override event WorkItemsGroupIdleHandler OnIdle\n\t\t\t{\n\t\t\tadd\n\t\t\t\t{\n\t\t\t\tthrow new NotImplementedException (\"This event is not implemented in the SmartThreadPool class. Please create a WorkItemsGroup in order to use this feature.\");\n\t\t\t\t//_onIdle += value;\n\t\t\t\t}\n\t\t\tremove\n\t\t\t\t{\n\t\t\t\tthrow new NotImplementedException (\"This event is not implemented in the SmartThreadPool class. Please create a WorkItemsGroup in order to use this feature.\");\n\t\t\t\t//_onIdle -= value;\n\t\t\t\t}\n\t\t\t}\n\n\t\tinternal override void PreQueueWorkItem ()\n\t\t\t{\n\t\t\tValidateNotDisposed ();\n\t\t\t}\n\n\t\t#endregion\n\n\t\t#region Join, Choice, Pipe, etc.\n\n\t\t/// <summary>\n\t\t/// Executes all actions in parallel.\n\t\t/// Returns when they all finish.\n\t\t/// </summary>\n\t\t/// <param name=\"actions\">Actions to execute</param>\n\t\tpublic void Join (IEnumerable<Action> actions)\n\t\t\t{\n\t\t\tWIGStartInfo wigStartInfo = new WIGStartInfo { StartSuspended = true };\n\t\t\tIWorkItemsGroup workItemsGroup = CreateWorkItemsGroup (int.MaxValue, wigStartInfo);\n\t\t\tforeach (Action action in actions)\n\t\t\t\t{\n\t\t\t\tworkItemsGroup.QueueWorkItem (action);\n\t\t\t\t}\n\t\t\tworkItemsGroup.Start ();\n\t\t\tworkItemsGroup.WaitForIdle ();\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Executes all actions in parallel.\n\t\t/// Returns when they all finish.\n\t\t/// </summary>\n\t\t/// <param name=\"actions\">Actions to execute</param>\n\t\tpublic void Join (params Action[] actions)\n\t\t\t{\n\t\t\tJoin ((IEnumerable<Action>)actions);\n\t\t\t}\n\n\t\tprivate class ChoiceIndex\n\t\t\t{\n\t\t\tpublic int _index = -1;\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Executes all actions in parallel\n\t\t/// Returns when the first one completes\n\t\t/// </summary>\n\t\t/// <param name=\"actions\">Actions to execute</param>\n\t\tpublic int Choice (IEnumerable<Action> actions)\n\t\t\t{\n\t\t\tWIGStartInfo wigStartInfo = new WIGStartInfo { StartSuspended = true };\n\t\t\tIWorkItemsGroup workItemsGroup = CreateWorkItemsGroup (int.MaxValue, wigStartInfo);\n\n\t\t\tManualResetEvent anActionCompleted = new ManualResetEvent (false);\n\n\t\t\tChoiceIndex choiceIndex = new ChoiceIndex ();\n\n\t\t\tint i = 0;\n\t\t\tforeach (Action action in actions)\n\t\t\t\t{\n\t\t\t\tAction act = action;\n\t\t\t\tint value = i;\n\t\t\t\tworkItemsGroup.QueueWorkItem (() => { act (); Interlocked.CompareExchange (ref choiceIndex._index, value, -1); anActionCompleted.Set (); });\n\t\t\t\t++i;\n\t\t\t\t}\n\t\t\tworkItemsGroup.Start ();\n\t\t\tanActionCompleted.WaitOne ();\n\n\t\t\treturn choiceIndex._index;\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Executes all actions in parallel\n\t\t/// Returns when the first one completes\n\t\t/// </summary>\n\t\t/// <param name=\"actions\">Actions to execute</param>\n\t\tpublic int Choice (params Action[] actions)\n\t\t\t{\n\t\t\treturn Choice ((IEnumerable<Action>)actions);\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Executes actions in sequence asynchronously.\n\t\t/// Returns immediately.\n\t\t/// </summary>\n\t\t/// <param name=\"pipeState\">A state context that passes </param>\n\t\t/// <param name=\"actions\">Actions to execute in the order they should run</param>\n\t\tpublic void Pipe<T> (T pipeState, IEnumerable<Action<T>> actions)\n\t\t\t{\n\t\t\tWIGStartInfo wigStartInfo = new WIGStartInfo { StartSuspended = true };\n\t\t\tIWorkItemsGroup workItemsGroup = CreateWorkItemsGroup (1, wigStartInfo);\n\t\t\tforeach (Action<T> action in actions)\n\t\t\t\t{\n\t\t\t\tAction<T> act = action;\n\t\t\t\tworkItemsGroup.QueueWorkItem (() => act (pipeState));\n\t\t\t\t}\n\t\t\tworkItemsGroup.Start ();\n\t\t\tworkItemsGroup.WaitForIdle ();\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Executes actions in sequence asynchronously.\n\t\t/// Returns immediately.\n\t\t/// </summary>\n\t\t/// <param name=\"pipeState\"></param>\n\t\t/// <param name=\"actions\">Actions to execute in the order they should run</param>\n\t\tpublic void Pipe<T> (T pipeState, params Action<T>[] actions)\n\t\t\t{\n\t\t\tPipe (pipeState, (IEnumerable<Action<T>>)actions);\n\t\t\t}\n\t\t#endregion\n\t\t}\n\t#endregion\n\t}\n", "<Project ToolsVersion=\"3.5\" DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <PropertyGroup>\n    <Configuration Condition=\" '$(Configuration)' == '' \">Release</Configuration>\n    <Platform Condition=\" '$(Platform)' == '' \">AnyCPU</Platform>\n    <ProductVersion>9.0.30729</ProductVersion>\n    <SchemaVersion>2.0</SchemaVersion>\n    <ProjectGuid>{43AEC3F3-0D6D-406C-B4B1-45FCEAA8817A}</ProjectGuid>\n    <OutputType>Library</OutputType>\n    <AppDesignerFolder>Properties</AppDesignerFolder>\n    <RootNamespace>SSharpSmartThreadPoolTests</RootNamespace>\n    <AssemblyName>SSharpSmartThreadPoolTests</AssemblyName>\n    <ProjectTypeGuids>{0B4745B0-194B-4BB6-8E21-E9057CA92300};{4D628B5B-2FBC-4AA6-8C16-197242AEB884};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>\n    <PlatformFamilyName>WindowsCE</PlatformFamilyName>\n    <PlatformID>E2BECB1F-8C8C-41ba-B736-9BE7D946A398</PlatformID>\n    <OSVersion>5.0</OSVersion>\n    <DeployDirSuffix>SmartDeviceProject1</DeployDirSuffix>\n    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>\n    <NativePlatformName>Windows CE</NativePlatformName>\n    <FormFactorID>\n    </FormFactorID>\n  </PropertyGroup>\n  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' \">\n    <AllowedReferenceRelatedFileExtensions>.allowedReferenceRelatedFileExtensions</AllowedReferenceRelatedFileExtensions>\n    <DebugSymbols>true</DebugSymbols>\n    <DebugType>full</DebugType>\n    <Optimize>false</Optimize>\n    <OutputPath>bin\\Debug\\</OutputPath>\n    <DefineConstants>DEBUG;TRACE;_WINDOWS_CE;_WINDOWS;SSHARP</DefineConstants>\n    <ErrorReport>prompt</ErrorReport>\n    <WarningLevel>4</WarningLevel>\n    <FileAlignment>512</FileAlignment>\n    <NoStdLib>true</NoStdLib>\n    <NoConfig>true</NoConfig>\n    <GenerateSerializationAssemblies>off</GenerateSerializationAssemblies>\n    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>\n  </PropertyGroup>\n  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' \">\n    <AllowedReferenceRelatedFileExtensions>.allowedReferenceRelatedFileExtensions</AllowedReferenceRelatedFileExtensions>\n    <DebugType>none</DebugType>\n    <Optimize>true</Optimize>\n    <OutputPath>bin\\Release\\</OutputPath>\n    <ErrorReport>prompt</ErrorReport>\n    <WarningLevel>4</WarningLevel>\n    <FileAlignment>512</FileAlignment>\n    <NoStdLib>true</NoStdLib>\n    <NoConfig>true</NoConfig>\n    <GenerateSerializationAssemblies>off</GenerateSerializationAssemblies>\n    <DefineConstants>_WINDOWS_CE;_WINDOWS;SSHARP</DefineConstants>\n  </PropertyGroup>\n  <ItemGroup>\n    <Reference Include=\"mscorlib\" />\n    <Reference Include=\"SimplSharpCustomAttributesInterface, Version=1.0.0.0, Culture=neutral, PublicKeyToken=1099c178b3b54c3b, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>..\\..\\..\\..\\..\\ProgramData\\Crestron\\SDK\\SimplSharpCustomAttributesInterface.dll</HintPath>\n      <Private>False</Private>\n    </Reference>\n    <Reference Include=\"SimplSharpHelperInterface, Version=1.0.0.0, Culture=neutral, PublicKeyToken=1099c178b3b54c3b, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>..\\..\\..\\..\\..\\ProgramData\\Crestron\\SDK\\SimplSharpHelperInterface.dll</HintPath>\n      <Private>False</Private>\n    </Reference>\n    <Reference Include=\"SimplSharpPro, Version=1.4.0.14, Culture=neutral, PublicKeyToken=1099c178b3b54c3b, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>..\\..\\..\\..\\..\\ProgramData\\Crestron\\SDK\\SimplSharpPro.exe</HintPath>\n      <Private>False</Private>\n    </Reference>\n    <Reference Include=\"SSharpCrestronExtensionsLibrary, Version=1.0.0.13603, Culture=neutral, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>..\\..\\..\\Simpl# Libraries\\SSharpCrestronExtensionsLibrary\\SSharpCrestronExtensionsLibrary\\bin\\Release\\SSharpCrestronExtensionsLibrary.dll</HintPath>\n    </Reference>\n    <Reference Include=\"SSharpNunitLite, Version=3.0.5543.22955, Culture=neutral, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>..\\..\\SSharpNUnitLite3\\SSharpNunitLite\\bin\\Release\\SSharpNunitLite.dll</HintPath>\n    </Reference>\n    <Reference Include=\"SSharpThreadingLibrary, Version=1.0.0.15966, Culture=neutral, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>..\\..\\..\\Simpl# Libraries\\SSharpThreadingLibrary\\SSharpThreadingLibrary\\bin\\Release\\SSharpThreadingLibrary.dll</HintPath>\n    </Reference>\n    <Reference Include=\"SSMonoDiagnosticsLibrary, Version=1.0.0.23683, Culture=neutral, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>..\\..\\..\\Simpl# Libraries\\SSMonoDiagnosticsLibrary\\SSMonoDiagnosticsLibrary\\bin\\Release\\SSMonoDiagnosticsLibrary.dll</HintPath>\n    </Reference>\n    <Reference Include=\"System\" />\n    <Reference Include=\"System.Core\" />\n    <Reference Include=\"System.Data\" />\n  </ItemGroup>\n  <ItemGroup>\n    <Compile Include=\"PermutationGenerator.cs\" />\n    <Compile Include=\"Properties\\AssemblyInfo.cs\" />\n    <Compile Include=\"QueueWorkItemHelper.cs\" />\n    <Compile Include=\"TestActionT.cs\" />\n    <Compile Include=\"TestCancel.cs\" />\n    <Compile Include=\"TestChainedDelegates.cs\" />\n    <Compile Include=\"TestConcurrencyChanges.cs\" />\n    <Compile Include=\"TestExceptions.cs\" />\n    <Compile Include=\"TestFalseFillStateWithParams.cs\" />\n    <Compile Include=\"TestFillStateWithParams.cs\" />\n    <Compile Include=\"TestFunc.cs\" />\n    <Compile Include=\"TestFuncT.cs\" />\n    <Compile Include=\"TestGetResult.cs\" />\n    <Compile Include=\"TestMultipleWorkItems.cs\" />\n    <Compile Include=\"TestParallelMethods.cs\" />\n    <Compile Include=\"TestPostExecute.cs\" />\n    <Compile Include=\"TestPriorityQueue.cs\" />\n    <Compile Include=\"TestQueueWorkItem.cs\" />\n    <Compile Include=\"TestStartSuspended.cs\" />\n    <Compile Include=\"TestStateDispose.cs\" />\n    <Compile Include=\"TestThreadPriority.cs\" />\n    <Compile Include=\"TestThreadsCreate.cs\" />\n    <Compile Include=\"TestWaitForIdle.cs\" />\n    <Compile Include=\"TestWIGActionT.cs\" />\n    <Compile Include=\"TestWIGChainedDelegates.cs\" />\n    <Compile Include=\"TestWIGConcurrency.cs\" />\n    <Compile Include=\"TestWIGConcurrencyChanges.cs\" />\n    <Compile Include=\"TestWIGExceptions.cs\" />\n    <Compile Include=\"TestWIGFillStateWithParams.cs\" />\n    <Compile Include=\"TestWIGFuncT.cs\" />\n    <Compile Include=\"TestWIGGetResult.cs\" />\n    <Compile Include=\"TestWIGMultipleWorkItems.cs\" />\n    <Compile Include=\"TestWIGPostExecute.cs\" />\n    <Compile Include=\"TestWIGQueueWorkItem.cs\" />\n    <Compile Include=\"TestWIGStateDispose.cs\" />\n    <Compile Include=\"TestWIGWaitForIdle.cs\" />\n    <Compile Include=\"TestWorkItemsGroups.cs\" />\n    <Compile Include=\"TestWorkItemsQueue.cs\" />\n    <Compile Include=\"TestWorkItemTimeout.cs\" />\n    <None Include=\"Properties\\ControlSystem.cfg\" />\n  </ItemGroup>\n  <ItemGroup>\n    <ProjectReference Include=\"..\\SSharpSmartThreadPool\\SSharpSmartThreadPool.csproj\">\n      <Project>{06299ED2-056A-427C-8C84-D716197080EB}</Project>\n      <Name>SSharpSmartThreadPool</Name>\n    </ProjectReference>\n  </ItemGroup>\n  <Import Project=\"$(MSBuildBinPath)\\Microsoft.CompactFramework.CSharp.targets\" />\n  <ProjectExtensions>\n    <VisualStudio>\n      <FlavorProperties GUID=\"{0B4745B0-194B-4BB6-8E21-E9057CA92300}\">\n        <ProgramIdTag>SSharpSmartThreadPoolTests</ProgramIdTag>\n        <SystemName>SSharpSmartThreadPoolTests</SystemName>\n        <Programmer />\n        <ArchiveFilename>C:\\Projects\\Crestron\\Simpl# Pro Libraries\\SSharpSmartThreadPool\\SSharpSmartThreadPoolTests\\bin\\Debug\\SSharpSmartThreadPoolTests.cplz</ArchiveFilename>\n        <MinFirmwareVersion>1.009.0029</MinFirmwareVersion>\n        <CompiledOn>3/13/2015 10:04:01 AM</CompiledOn>\n        <AdditionalInfo />\n        <EmbedSourceArchive>False</EmbedSourceArchive>\n        <CopyTo>\n          <DebugAnyCPU />\n          <ReleaseAnyCPU />\n        </CopyTo>\n        <OriginalReferenceSources>\n          <Reference sourceFilename=\"../../SSharpNUnitLite3/SSharpNunitLite/bin/Release/SSharpNunitLite.dll\" referenceName=\"SSharpNunitLite\" />\n          <Reference sourceFilename=\"../../../Simpl%23%20Libraries/SSharpCrestronExtensionsLibrary/SSharpCrestronExtensionsLibrary/bin/Release/SSharpCrestronExtensionsLibrary.dll\" referenceName=\"SSharpCrestronExtensionsLibrary\" />\n        </OriginalReferenceSources>\n      </FlavorProperties>\n    </VisualStudio>\n  </ProjectExtensions>\n  <PropertyGroup>\n    <PostBuildEvent>rem S# Pro preparation will execute after these operations</PostBuildEvent>\n  </PropertyGroup>\n</Project>"], "fixing_code": ["<Project ToolsVersion=\"3.5\" DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <PropertyGroup>\n    <Configuration Condition=\" '$(Configuration)' == '' \">Release</Configuration>\n    <Platform Condition=\" '$(Platform)' == '' \">AnyCPU</Platform>\n    <ProductVersion>9.0.30729</ProductVersion>\n    <SchemaVersion>2.0</SchemaVersion>\n    <ProjectGuid>{06299ED2-056A-427C-8C84-D716197080EB}</ProjectGuid>\n    <OutputType>Library</OutputType>\n    <AppDesignerFolder>Properties</AppDesignerFolder>\n    <RootNamespace>SSharpSmartThreadPool</RootNamespace>\n    <AssemblyName>SSharpSmartThreadPool</AssemblyName>\n    <ProjectTypeGuids>{0B4745B0-194B-4BB6-8E21-E9057CA92300};{4D628B5B-2FBC-4AA6-8C16-197242AEB884};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>\n    <PlatformFamilyName>WindowsCE</PlatformFamilyName>\n    <PlatformID>E2BECB1F-8C8C-41ba-B736-9BE7D946A398</PlatformID>\n    <OSVersion>5.0</OSVersion>\n    <DeployDirSuffix>SmartDeviceProject1</DeployDirSuffix>\n    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>\n    <NativePlatformName>Windows CE</NativePlatformName>\n    <FormFactorID>\n    </FormFactorID>\n  </PropertyGroup>\n  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' \">\n    <AllowedReferenceRelatedFileExtensions>.allowedReferenceRelatedFileExtensions</AllowedReferenceRelatedFileExtensions>\n    <DebugSymbols>true</DebugSymbols>\n    <DebugType>full</DebugType>\n    <Optimize>false</Optimize>\n    <OutputPath>bin\\Debug\\</OutputPath>\n    <DefineConstants>DEBUG;TRACE;_WINDOWS_CE;_WINDOWS;SSHARP</DefineConstants>\n    <ErrorReport>prompt</ErrorReport>\n    <WarningLevel>4</WarningLevel>\n    <FileAlignment>512</FileAlignment>\n    <NoStdLib>true</NoStdLib>\n    <NoConfig>true</NoConfig>\n    <GenerateSerializationAssemblies>off</GenerateSerializationAssemblies>\n  </PropertyGroup>\n  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' \">\n    <AllowedReferenceRelatedFileExtensions>.allowedReferenceRelatedFileExtensions</AllowedReferenceRelatedFileExtensions>\n    <DebugType>none</DebugType>\n    <Optimize>true</Optimize>\n    <OutputPath>bin\\Release\\</OutputPath>\n    <ErrorReport>prompt</ErrorReport>\n    <WarningLevel>4</WarningLevel>\n    <FileAlignment>512</FileAlignment>\n    <NoStdLib>true</NoStdLib>\n    <NoConfig>true</NoConfig>\n    <GenerateSerializationAssemblies>off</GenerateSerializationAssemblies>\n    <DefineConstants>_WINDOWS_CE;_WINDOWS;SSHARP</DefineConstants>\n  </PropertyGroup>\n  <ItemGroup>\n    <Reference Include=\"mscorlib\" />\n    <Reference Include=\"SimplSharpCustomAttributesInterface, Version=1.0.0.0, Culture=neutral, PublicKeyToken=1099c178b3b54c3b, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>..\\..\\..\\..\\..\\ProgramData\\Crestron\\SDK\\SimplSharpCustomAttributesInterface.dll</HintPath>\n      <Private>False</Private>\n    </Reference>\n    <Reference Include=\"SimplSharpHelperInterface, Version=1.0.0.0, Culture=neutral, PublicKeyToken=1099c178b3b54c3b, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>..\\..\\..\\..\\..\\ProgramData\\Crestron\\SDK\\SimplSharpHelperInterface.dll</HintPath>\n      <Private>False</Private>\n    </Reference>\n    <Reference Include=\"SimplSharpPro, Version=1.4.0.14, Culture=neutral, PublicKeyToken=1099c178b3b54c3b, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>..\\..\\..\\..\\..\\ProgramData\\Crestron\\SDK\\SimplSharpPro.exe</HintPath>\n      <Private>False</Private>\n    </Reference>\n    <Reference Include=\"SSharpThreadingLibrary, Version=1.0.0.10633, Culture=neutral, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>..\\..\\..\\Simpl# Libraries\\SSharpThreadingLibrary\\SSharpThreadingLibrary\\bin\\Release\\SSharpThreadingLibrary.dll</HintPath>\n    </Reference>\n    <Reference Include=\"System\" />\n    <Reference Include=\"System.Core\" />\n    <Reference Include=\"System.Data\" />\n  </ItemGroup>\n  <ItemGroup>\n    <Compile Include=\"CallerThreadContext.cs\" />\n    <Compile Include=\"CanceledWorkItemsGroup.cs\" />\n    <Compile Include=\"EventWaitHandle.cs\" />\n    <Compile Include=\"EventWaitHandleFactory.cs\" />\n    <Compile Include=\"Exceptions.cs\" />\n    <Compile Include=\"Interfaces.cs\" />\n    <Compile Include=\"InternalInterfaces.cs\" />\n    <Compile Include=\"PriorityQueue.cs\" />\n    <Compile Include=\"Properties\\AssemblyInfo.cs\" />\n    <Compile Include=\"SmartThreadPool.cs\" />\n    <Compile Include=\"SmartThreadPool.ThreadEntry.cs\" />\n    <Compile Include=\"STPEventWaitHandle.cs\">\n      <SubType>Code</SubType>\n    </Compile>\n    <Compile Include=\"STPPerformanceCounter.cs\">\n      <SubType>Code</SubType>\n    </Compile>\n    <Compile Include=\"STPStartInfo.cs\" />\n    <Compile Include=\"SynchronizedDictionary.cs\" />\n    <Compile Include=\"WIGStartInfo.cs\" />\n    <Compile Include=\"WorkItem.cs\" />\n    <Compile Include=\"WorkItem.WorkItemResult.cs\" />\n    <Compile Include=\"WorkItemFactory.cs\" />\n    <Compile Include=\"WorkItemInfo.cs\" />\n    <Compile Include=\"WorkItemResultTWrapper.cs\" />\n    <Compile Include=\"WorkItemsGroup.cs\" />\n    <Compile Include=\"WorkItemsGroupBase.cs\" />\n    <Compile Include=\"WorkItemsQueue.cs\" />\n    <None Include=\"Properties\\ControlSystem.cfg\" />\n  </ItemGroup>\n  <Import Project=\"$(MSBuildBinPath)\\Microsoft.CompactFramework.CSharp.targets\" />\n  <ProjectExtensions>\n    <VisualStudio>\n      <FlavorProperties GUID=\"{0B4745B0-194B-4BB6-8E21-E9057CA92300}\">\n        <ProgramIdTag>SSharpSmartThreadPoo</ProgramIdTag>\n        <SystemName>SSharpSmartThreadPool</SystemName>\n        <Programmer />\n        <ArchiveFilename>C:\\Projects\\Crestron\\Simpl# Pro Libraries\\SSharpSmartThreadPool\\SSharpSmartThreadPool\\bin\\Debug\\SSharpSmartThreadPool.cplz</ArchiveFilename>\n        <MinFirmwareVersion>1.009.0029</MinFirmwareVersion>\n        <CompiledOn>3/14/2015 11:03:51 AM</CompiledOn>\n        <AdditionalInfo />\n        <EmbedSourceArchive>False</EmbedSourceArchive>\n        <CopyTo />\n        <OriginalReferenceSources>\n          <Reference sourceFilename=\"../../../Simpl%23%20Libraries/SSharpThreadingLibrary/SSharpThreadingLibrary/bin/Release/SSharpThreadingLibrary.dll\" referenceName=\"SSharpThreadingLibrary\" />\n        </OriginalReferenceSources>\n      </FlavorProperties>\n    </VisualStudio>\n  </ProjectExtensions>\n  <PropertyGroup>\n    <PostBuildEvent>rem S# Pro preparation will execute after these operations</PostBuildEvent>\n  </PropertyGroup>\n</Project>", "#region Release History\n\n// Smart Thread Pool\n// 7 Aug 2004 - Initial release\n//\n// 14 Sep 2004 - Bug fixes \n//\n// 15 Oct 2004 - Added new features\n//\t\t- Work items return result.\n//\t\t- Support waiting synchronization for multiple work items.\n//\t\t- Work items can be cancelled.\n//\t\t- Passage of the caller thread\u2019s context to the thread in the pool.\n//\t\t- Minimal usage of WIN32 handles.\n//\t\t- Minor bug fixes.\n//\n// 26 Dec 2004 - Changes:\n//\t\t- Removed static constructors.\n//      - Added finalizers.\n//\t\t- Changed Exceptions so they are serializable.\n//\t\t- Fixed the bug in one of the SmartThreadPool constructors.\n//\t\t- Changed the SmartThreadPool.WaitAll() so it will support any number of waiters. \n//        The SmartThreadPool.WaitAny() is still limited by the .NET Framework.\n//\t\t- Added PostExecute with options on which cases to call it.\n//      - Added option to dispose of the state objects.\n//      - Added a WaitForIdle() method that waits until the work items queue is empty.\n//      - Added an STPStartInfo class for the initialization of the thread pool.\n//      - Changed exception handling so if a work item throws an exception it \n//        is rethrown at GetResult(), rather then firing an UnhandledException event.\n//        Note that PostExecute exception are always ignored.\n//\n// 25 Mar 2005 - Changes:\n//\t\t- Fixed lost of work items bug\n//\n// 3 Jul 2005: Changes.\n//      - Fixed bug where Enqueue() throws an exception because PopWaiter() returned null, hardly reconstructed. \n//\n// 16 Aug 2005: Changes.\n//\t\t- Fixed bug where the InUseThreads becomes negative when canceling work items. \n//\n// 31 Jan 2006 - Changes:\n//\t\t- Added work items priority\n//\t\t- Removed support of chained delegates in callbacks and post executes (nobody really use this)\n//\t\t- Added work items groups\n//\t\t- Added work items groups idle event\n//\t\t- Changed SmartThreadPool.WaitAll() behavior so when it gets empty array\n//\t\t  it returns true rather then throwing an exception.\n//\t\t- Added option to start the STP and the WIG as suspended\n//\t\t- Exception behavior changed, the real exception is returned by an \n//\t\t  inner exception\n//\t\t- Added option to keep the Http context of the caller thread. (Thanks to Steven T.)\n//\t\t- Added performance counters\n//\t\t- Added priority to the threads in the pool\n//\n// 13 Feb 2006 - Changes:\n//\t\t- Added a call to the dispose of the Performance Counter so\n//\t\t  their won't be a Performance Counter leak.\n//\t\t- Added exception catch in case the Performance Counters cannot \n//\t\t  be created.\n//\n// 17 May 2008 - Changes:\n//      - Changed the dispose behavior and removed the Finalizers.\n//      - Enabled the change of the MaxThreads and MinThreads at run time.\n//      - Enabled the change of the Concurrency of a IWorkItemsGroup at run \n//        time If the IWorkItemsGroup is a SmartThreadPool then the Concurrency \n//        refers to the MaxThreads. \n//      - Improved the cancel behavior.\n//      - Added events for thread creation and termination. \n//      - Fixed the HttpContext context capture.\n//      - Changed internal collections so they use generic collections\n//      - Added IsIdle flag to the SmartThreadPool and IWorkItemsGroup\n//      - Added support for WinCE\n//      - Added support for Action<T> and Func<T>\n//\n// 07 April 2009 - Changes:\n//      - Added support for Silverlight and Mono\n//      - Added Join, Choice, and Pipe to SmartThreadPool.\n//      - Added local performance counters (for Mono, Silverlight, and WindowsCE)\n//      - Changed duration measures from DateTime.Now to Stopwatch.\n//      - Queues changed from System.Collections.Queue to System.Collections.Generic.LinkedList<T>.\n//\n// 21 December 2009 - Changes:\n//      - Added work item timeout (passive)\n//\n// 20 August 2012 - Changes:\n//      - Added set name to threads\n//      - Fixed the WorkItemsQueue.Dequeue. \n//        Replaced while (!Monitor.TryEnter(this)); with lock(this) { ... }\n//      - Fixed SmartThreadPool.Pipe\n//      - Added IsBackground option to threads\n//      - Added ApartmentState to threads\n//      - Fixed thread creation when queuing many work items at the same time.\n//\n// 24 August 2012 - Changes:\n//      - Enabled cancel abort after cancel. See: http://smartthreadpool.codeplex.com/discussions/345937 by alecswan\n//      - Added option to set MaxStackSize of threads \n\n#endregion\n\nusing System;\nusing System.Security;\nusing Amib.SSharpThreading.Internal;\nusing Crestron.SimplSharp;\nusing Crestron.SimplSharpPro.CrestronThread;\nusing ThreadPriority = Crestron.SimplSharpPro.CrestronThread.Thread.eThreadPriority;\nusing SSharp.Threading;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Runtime.CompilerServices;\n//using SSMono.Diagnostics;\nusing ThreadAbortException = System.Threading.ThreadAbortException;\nusing ThreadStateException = System.Threading.ThreadStateException;\n\nnamespace Amib.SSharpThreading\n\t{\n\t#region SmartThreadPool class\n\t/// <summary>\n\t/// Smart thread pool class.\n\t/// </summary>\n\tpublic partial class SmartThreadPool : WorkItemsGroupBase, IDisposable\n\t\t{\n\t\t#region Public Default Constants\n\n\t\t/// <summary>\n\t\t/// Default minimum number of threads the thread pool contains. (0)\n\t\t/// </summary>\n\t\tpublic const int DefaultMinWorkerThreads = 0;\n\n\t\t/// <summary>\n\t\t/// Default maximum number of threads the thread pool contains. (25)\n\t\t/// </summary>\n\t\tpublic const int DefaultMaxWorkerThreads = 25;\n\n\t\t/// <summary>\n\t\t/// Default idle timeout in milliseconds. (One minute)\n\t\t/// </summary>\n\t\tpublic const int DefaultIdleTimeout = 60 * 1000; // One minute\n\n\t\t/// <summary>\n\t\t/// Indicate to copy the security context of the caller and then use it in the call. (false)\n\t\t/// </summary>\n\t\tpublic const bool DefaultUseCallerCallContext = false;\n\n\t\t/// <summary>\n\t\t/// Indicate to copy the HTTP context of the caller and then use it in the call. (false)\n\t\t/// </summary>\n\t\tpublic const bool DefaultUseCallerHttpContext = false;\n\n\t\t/// <summary>\n\t\t/// Indicate to dispose of the state objects if they support the IDispose interface. (false)\n\t\t/// </summary>\n\t\tpublic const bool DefaultDisposeOfStateObjects = false;\n\n\t\t/// <summary>\n\t\t/// The default option to run the post execute (CallToPostExecute.Always)\n\t\t/// </summary>\n\t\tpublic const CallToPostExecute DefaultCallToPostExecute = CallToPostExecute.Always;\n\n\t\t/// <summary>\n\t\t/// The default post execute method to run. (None)\n\t\t/// When null it means not to call it.\n\t\t/// </summary>\n\t\tpublic static readonly PostExecuteWorkItemCallback DefaultPostExecuteWorkItemCallback;\n\n\t\t/// <summary>\n\t\t/// The default work item priority (WorkItemPriority.Normal)\n\t\t/// </summary>\n\t\tpublic const WorkItemPriority DefaultWorkItemPriority = WorkItemPriority.Normal;\n\n\t\t/// <summary>\n\t\t/// The default is to work on work items as soon as they arrive\n\t\t/// and not to wait for the start. (false)\n\t\t/// </summary>\n\t\tpublic const bool DefaultStartSuspended = false;\n\n\t\t/// <summary>\n\t\t/// The default name to use for the performance counters instance. (null)\n\t\t/// </summary>\n\t\tpublic static readonly string DefaultPerformanceCounterInstanceName;\n\n#if !(WINDOWS_PHONE)\n\n\t\t/// <summary>\n\t\t/// The default thread priority (ThreadPriority.Normal)\n\t\t/// </summary>\n\n\t\tpublic const ThreadPriority DefaultThreadPriority = ThreadPriority.MediumPriority;\n#endif\n\t\t/// <summary>\n\t\t/// The default thread pool name. (SmartThreadPool)\n\t\t/// </summary>\n\t\tpublic const string DefaultThreadPoolName = \"SmartThreadPool\";\n\n\t\t/// <summary>\n\t\t/// The default Max Stack Size. (SmartThreadPool)\n\t\t/// </summary>\n\t\tpublic static readonly int? DefaultMaxStackSize = null;\n\n\t\t/// <summary>\n\t\t/// The default fill state with params. (false)\n\t\t/// It is relevant only to QueueWorkItem of Action&lt;...&gt;/Func&lt;...&gt;\n\t\t/// </summary>\n\t\tpublic const bool DefaultFillStateWithArgs = false;\n\n\t\t/// <summary>\n\t\t/// The default thread backgroundness. (true)\n\t\t/// </summary>\n\t\tpublic const bool DefaultAreThreadsBackground = true;\n\n#if !(_SILVERLIGHT) && !(WINDOWS_PHONE) && !(_WINDOWS_CE)\n        /// <summary>\n        /// The default apartment state of a thread in the thread pool. \n        /// The default is ApartmentState.Unknown which means the STP will not \n        /// set the apartment of the thread. It will use the .NET default.\n        /// </summary>\n        public const ApartmentState DefaultApartmentState = ApartmentState.Unknown;\n#endif\n\n\t\t#endregion\n\n\t\t#region Member Variables\n\n\t\t/// <summary>\n\t\t/// Dictionary of all the threads in the thread pool.\n\t\t/// </summary>\n\t\tprivate readonly SynchronizedDictionary<Thread, ThreadEntry> _workerThreads = new SynchronizedDictionary<Thread, ThreadEntry> ();\n\n\t\t/// <summary>\n\t\t/// Queue of work items.\n\t\t/// </summary>\n\t\tprivate readonly WorkItemsQueue _workItemsQueue = new WorkItemsQueue ();\n\n\t\t/// <summary>\n\t\t/// Count the work items handled.\n\t\t/// Used by the performance counter.\n\t\t/// </summary>\n\t\tprivate int _workItemsProcessed;\n\n\t\t/// <summary>\n\t\t/// Number of threads that currently work (not idle).\n\t\t/// </summary>\n\t\tprivate int _inUseWorkerThreads;\n\n\t\t/// <summary>\n\t\t/// Stores a copy of the original STPStartInfo.\n\t\t/// It is used to change the MinThread and MaxThreads\n\t\t/// </summary>\n\t\tprivate STPStartInfo _stpStartInfo;\n\n\t\t/// <summary>\n\t\t/// Total number of work items that are stored in the work items queue \n\t\t/// plus the work items that the threads in the pool are working on.\n\t\t/// </summary>\n\t\tprivate int _currentWorkItemsCount;\n\n\t\t/// <summary>\n\t\t/// Signaled when the thread pool is idle, i.e. no thread is busy\n\t\t/// and the work items queue is empty\n\t\t/// </summary>\n\t\t//private ManualResetEvent _isIdleWaitHandle = new ManualResetEvent(true);\n\t\tprivate ManualResetEvent _isIdleWaitHandle = EventWaitHandleFactory.CreateManualResetEvent (true);\n\n\t\t/// <summary>\n\t\t/// An event to signal all the threads to quit immediately.\n\t\t/// </summary>\n\t\t//private ManualResetEvent _shuttingDownEvent = new ManualResetEvent(false);\n\t\tprivate ManualResetEvent _shuttingDownEvent = EventWaitHandleFactory.CreateManualResetEvent (false);\n\n\t\t/// <summary>\n\t\t/// A flag to indicate if the Smart Thread Pool is now suspended.\n\t\t/// </summary>\n\t\tprivate bool _isSuspended;\n\n\t\t/// <summary>\n\t\t/// A flag to indicate the threads to quit.\n\t\t/// </summary>\n\t\tprivate bool _shutdown;\n\n\t\t/// <summary>\n\t\t/// Counts the threads created in the pool.\n\t\t/// It is used to name the threads.\n\t\t/// </summary>\n\t\tprivate int _threadCounter;\n\n\t\t/// <summary>\n\t\t/// Indicate that the SmartThreadPool has been disposed\n\t\t/// </summary>\n\t\tprivate bool _isDisposed;\n\n\t\t/// <summary>\n\t\t/// Holds all the WorkItemsGroup instaces that have at least one \n\t\t/// work item int the SmartThreadPool\n\t\t/// This variable is used in case of Shutdown\n\t\t/// </summary>\n\t\tprivate readonly SynchronizedDictionary<IWorkItemsGroup, IWorkItemsGroup> _workItemsGroups = new SynchronizedDictionary<IWorkItemsGroup, IWorkItemsGroup> ();\n\n\t\t/// <summary>\n\t\t/// A common object for all the work items int the STP\n\t\t/// so we can mark them to cancel in O(1)\n\t\t/// </summary>\n\t\tprivate CanceledWorkItemsGroup _canceledSmartThreadPool = new CanceledWorkItemsGroup ();\n\n\t\t/// <summary>\n\t\t/// Windows STP performance counters\n\t\t/// </summary>\n\t\tprivate ISTPInstancePerformanceCounters _windowsPCs = NullSTPInstancePerformanceCounters.Instance;\n\n\t\t/// <summary>\n\t\t/// Local STP performance counters\n\t\t/// </summary>\n\t\tprivate ISTPInstancePerformanceCounters _localPCs = NullSTPInstancePerformanceCounters.Instance;\n\n#if (WINDOWS_PHONE) \n        private static readonly Dictionary<int, ThreadEntry> _threadEntries = new Dictionary<int, ThreadEntry>();\n#elif (_WINDOWS_CE)\n\t\tprivate static LocalDataStoreSlot _threadEntrySlot = Thread.AllocateDataSlot ();\n#else\n        [ThreadStatic]\n        private static ThreadEntry _threadEntry;\n\n#endif\n\n\t\t/// <summary>\n\t\t/// An event to call after a thread is created, but before \n\t\t/// it's first use.\n\t\t/// </summary>\n\t\tprivate event ThreadInitializationHandler _onThreadInitialization;\n\n\t\t/// <summary>\n\t\t/// An event to call when a thread is about to exit, after \n\t\t/// it is no longer belong to the pool.\n\t\t/// </summary>\n\t\tprivate event ThreadTerminationHandler _onThreadTermination;\n\n\t\t#endregion\n\n\t\t#region Per thread properties\n\n\t\t/// <summary>\n\t\t/// A reference to the current work item a thread from the thread pool \n\t\t/// is executing.\n\t\t/// </summary>\n\t\tinternal static ThreadEntry CurrentThreadEntry\n\t\t\t{\n#if (WINDOWS_PHONE)\n            get\n            {\n                lock(_threadEntries)\n                {\n                    ThreadEntry threadEntry;\n                    if (_threadEntries.TryGetValue(Thread.CurrentThread.ManagedThreadId, out threadEntry))\n                    {\n                        return threadEntry;\n                    }\n                }\n                return null;\n            }\n            set\n            {\n                lock(_threadEntries)\n                {\n                    _threadEntries[Thread.CurrentThread.ManagedThreadId] = value;\n                }\n            }\n#elif (_WINDOWS_CE)\n\t\t\tget\n\t\t\t\t{\n\t\t\t\t//Thread.CurrentThread.ManagedThreadId\n\t\t\t\treturn Thread.GetData (_threadEntrySlot) as ThreadEntry;\n\t\t\t\t}\n\t\t\tset\n\t\t\t\t{\n\t\t\t\tThread.SetData (_threadEntrySlot, value);\n\t\t\t\t}\n#else\n            get\n            {\n                return _threadEntry;\n            }\n            set\n            {\n                _threadEntry = value;\n            }\n#endif\n\t\t\t}\n\t\t#endregion\n\n\t\t#region Construction and Finalization\n\n\t\t/// <summary>\n\t\t/// Constructor\n\t\t/// </summary>\n\t\tpublic SmartThreadPool ()\n\t\t\t{\n\t\t\t_stpStartInfo = new STPStartInfo ();\n\t\t\tInitialize ();\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Constructor\n\t\t/// </summary>\n\t\t/// <param name=\"idleTimeout\">Idle timeout in milliseconds</param>\n\t\tpublic SmartThreadPool (int idleTimeout)\n\t\t\t{\n\t\t\t_stpStartInfo = new STPStartInfo\n\t\t\t{\n\t\t\t\tIdleTimeout = idleTimeout,\n\t\t\t};\n\t\t\tInitialize ();\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Constructor\n\t\t/// </summary>\n\t\t/// <param name=\"idleTimeout\">Idle timeout in milliseconds</param>\n\t\t/// <param name=\"maxWorkerThreads\">Upper limit of threads in the pool</param>\n\t\tpublic SmartThreadPool (\n\t\t\tint idleTimeout,\n\t\t\tint maxWorkerThreads)\n\t\t\t{\n\t\t\t_stpStartInfo = new STPStartInfo\n\t\t\t{\n\t\t\t\tIdleTimeout = idleTimeout,\n\t\t\t\tMaxWorkerThreads = maxWorkerThreads,\n\t\t\t};\n\t\t\tInitialize ();\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Constructor\n\t\t/// </summary>\n\t\t/// <param name=\"idleTimeout\">Idle timeout in milliseconds</param>\n\t\t/// <param name=\"maxWorkerThreads\">Upper limit of threads in the pool</param>\n\t\t/// <param name=\"minWorkerThreads\">Lower limit of threads in the pool</param>\n\t\tpublic SmartThreadPool (\n\t\t\tint idleTimeout,\n\t\t\tint maxWorkerThreads,\n\t\t\tint minWorkerThreads)\n\t\t\t{\n\t\t\t_stpStartInfo = new STPStartInfo\n\t\t\t{\n\t\t\t\tIdleTimeout = idleTimeout,\n\t\t\t\tMaxWorkerThreads = maxWorkerThreads,\n\t\t\t\tMinWorkerThreads = minWorkerThreads,\n\t\t\t};\n\t\t\tInitialize ();\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Constructor\n\t\t/// </summary>\n\t\t/// <param name=\"stpStartInfo\">A SmartThreadPool configuration that overrides the default behavior</param>\n\t\tpublic SmartThreadPool (STPStartInfo stpStartInfo)\n\t\t\t{\n\t\t\t_stpStartInfo = new STPStartInfo (stpStartInfo);\n\t\t\tInitialize ();\n\t\t\t}\n\n\t\tprivate void Initialize ()\n\t\t\t{\n\t\t\tName = _stpStartInfo.ThreadPoolName;\n\t\t\tValidateSTPStartInfo ();\n\n\t\t\t// _stpStartInfoRW stores a read/write copy of the STPStartInfo.\n\t\t\t// Actually only MaxWorkerThreads and MinWorkerThreads are overwritten\n\n\t\t\t_isSuspended = _stpStartInfo.StartSuspended;\n\n#if (_WINDOWS_CE) || (_SILVERLIGHT) || (_MONO) || (WINDOWS_PHONE)\n\t\t\tif (null != _stpStartInfo.PerformanceCounterInstanceName)\n\t\t\t\t{\n\t\t\t\tthrow new NotSupportedException (\"Performance counters are not implemented for Compact Framework/Silverlight/Mono, instead use StpStartInfo.EnableLocalPerformanceCounters\");\n\t\t\t\t}\n#else\n            if (null != _stpStartInfo.PerformanceCounterInstanceName)\n            {\n                try\n                {\n                    _windowsPCs = new STPInstancePerformanceCounters(_stpStartInfo.PerformanceCounterInstanceName);\n                }\n                catch (Exception e)\n                {\n                    //Debug.WriteLine(\"Unable to create Performance Counters: \" + e);\n                    _windowsPCs = NullSTPInstancePerformanceCounters.Instance;\n                }\n            }\n#endif\n\n\t\t\tif (_stpStartInfo.EnableLocalPerformanceCounters)\n\t\t\t\t{\n\t\t\t\t_localPCs = new LocalSTPInstancePerformanceCounters ();\n\t\t\t\t}\n\n\t\t\t// If the STP is not started suspended then start the threads.\n\t\t\tif (!_isSuspended)\n\t\t\t\t{\n\t\t\t\tStartOptimalNumberOfThreads ();\n\t\t\t\t}\n\t\t\t}\n\n\t\tprivate void StartOptimalNumberOfThreads ()\n\t\t\t{\n\t\t\tint threadsCount = Math.Max (_workItemsQueue.Count, _stpStartInfo.MinWorkerThreads);\n\t\t\tthreadsCount = Math.Min (threadsCount, _stpStartInfo.MaxWorkerThreads);\n\t\t\tthreadsCount -= _workerThreads.Count;\n\t\t\tif (threadsCount > 0)\n\t\t\t\t{\n\t\t\t\tStartThreads (threadsCount);\n\t\t\t\t}\n\t\t\t}\n\n\t\tprivate void ValidateSTPStartInfo ()\n\t\t\t{\n\t\t\tif (_stpStartInfo.MinWorkerThreads < 0)\n\t\t\t\t{\n\t\t\t\tthrow new ArgumentOutOfRangeException (\n\t\t\t\t\t\"MinWorkerThreads\", \"MinWorkerThreads cannot be negative\");\n\t\t\t\t}\n\n\t\t\tif (_stpStartInfo.MaxWorkerThreads <= 0)\n\t\t\t\t{\n\t\t\t\tthrow new ArgumentOutOfRangeException (\n\t\t\t\t\t\"MaxWorkerThreads\", \"MaxWorkerThreads must be greater than zero\");\n\t\t\t\t}\n\n\t\t\tif (_stpStartInfo.MinWorkerThreads > _stpStartInfo.MaxWorkerThreads)\n\t\t\t\t{\n\t\t\t\tthrow new ArgumentOutOfRangeException (\n\t\t\t\t\t\"MinWorkerThreads, maxWorkerThreads\",\n\t\t\t\t\t\"MaxWorkerThreads must be greater or equal to MinWorkerThreads\");\n\t\t\t\t}\n\t\t\t}\n\n\t\tprivate static void ValidateCallback (Delegate callback)\n\t\t\t{\n\t\t\tif (callback.GetInvocationList ().Length > 1)\n\t\t\t\t{\n\t\t\t\tthrow new NotSupportedException (\"SmartThreadPool doesn't support delegates chains\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t#endregion\n\n\t\t#region Thread Processing\n\n\t\t/// <summary>\n\t\t/// Waits on the queue for a work item, shutdown, or timeout.\n\t\t/// </summary>\n\t\t/// <returns>\n\t\t/// Returns the WaitingCallback or null in case of timeout or shutdown.\n\t\t/// </returns>\n\t\tprivate WorkItem Dequeue ()\n\t\t\t{\n\t\t\tWorkItem workItem =\n\t\t\t\t_workItemsQueue.DequeueWorkItem (_stpStartInfo.IdleTimeout, _shuttingDownEvent);\n\n\t\t\treturn workItem;\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Put a new work item in the queue\n\t\t/// </summary>\n\t\t/// <param name=\"workItem\">A work item to queue</param>\n\t\tinternal override void Enqueue (WorkItem workItem)\n\t\t\t{\n\t\t\t// Make sure the workItem is not null\n\t\t\t//Debug.Assert (null != workItem);\n\n\t\t\tIncrementWorkItemsCount ();\n\n\t\t\tworkItem.CanceledSmartThreadPool = _canceledSmartThreadPool;\n\t\t\t_workItemsQueue.EnqueueWorkItem (workItem);\n\t\t\tworkItem.WorkItemIsQueued ();\n\n\t\t\t// If all the threads are busy then try to create a new one\n\t\t\tif (_currentWorkItemsCount > _workerThreads.Count)\n\t\t\t\t{\n\t\t\t\tStartThreads (1);\n\t\t\t\t}\n\t\t\t}\n\n\t\tprivate void IncrementWorkItemsCount ()\n\t\t\t{\n\t\t\t_windowsPCs.SampleWorkItems (_workItemsQueue.Count, _workItemsProcessed);\n\t\t\t_localPCs.SampleWorkItems (_workItemsQueue.Count, _workItemsProcessed);\n\t\t\tint count = Interlocked.Increment (ref _currentWorkItemsCount);\n\t\t\t//Trace.WriteLine(\"WorkItemsCount = \" + _currentWorkItemsCount.ToString());\n\t\t\tif (count == 1)\n\t\t\t\t{\n\t\t\t\tIsIdle = false;\n\t\t\t\t_isIdleWaitHandle.Reset ();\n\t\t\t\t}\n\t\t\t}\n\n\t\tprivate void DecrementWorkItemsCount ()\n\t\t\t{\n\t\t\tint count = Interlocked.Decrement (ref _currentWorkItemsCount);\n\t\t\t//Trace.WriteLine(\"WorkItemsCount = \" + _currentWorkItemsCount.ToString());\n\t\t\tif (count == 0)\n\t\t\t\t{\n\t\t\t\tIsIdle = true;\n\t\t\t\t_isIdleWaitHandle.Set ();\n\t\t\t\t}\n\n\t\t\tInterlocked.Increment (ref _workItemsProcessed);\n\n\t\t\tif (!_shutdown)\n\t\t\t\t{\n\t\t\t\t// The counter counts even if the work item was cancelled\n\t\t\t\t_windowsPCs.SampleWorkItems (_workItemsQueue.Count, _workItemsProcessed);\n\t\t\t\t_localPCs.SampleWorkItems (_workItemsQueue.Count, _workItemsProcessed);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\tinternal void RegisterWorkItemsGroup (IWorkItemsGroup workItemsGroup)\n\t\t\t{\n\t\t\t_workItemsGroups[workItemsGroup] = workItemsGroup;\n\t\t\t}\n\n\t\tinternal void UnregisterWorkItemsGroup (IWorkItemsGroup workItemsGroup)\n\t\t\t{\n\t\t\tif (_workItemsGroups.Contains (workItemsGroup))\n\t\t\t\t{\n\t\t\t\t_workItemsGroups.Remove (workItemsGroup);\n\t\t\t\t}\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Inform that the current thread is about to quit or quiting.\n\t\t/// The same thread may call this method more than once.\n\t\t/// </summary>\n\t\tprivate void InformCompleted ()\n\t\t\t{\n\t\t\t// There is no need to lock the two methods together \n\t\t\t// since only the current thread removes itself\n\t\t\t// and the _workerThreads is a synchronized dictionary\n\t\t\tif (_workerThreads.Contains (Thread.CurrentThread))\n\t\t\t\t{\n\t\t\t\t_workerThreads.Remove (Thread.CurrentThread);\n\t\t\t\t_windowsPCs.SampleThreads (_workerThreads.Count, _inUseWorkerThreads);\n\t\t\t\t_localPCs.SampleThreads (_workerThreads.Count, _inUseWorkerThreads);\n\t\t\t\t}\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Starts new threads\n\t\t/// </summary>\n\t\t/// <param name=\"threadsCount\">The number of threads to start</param>\n\t\tprivate void StartThreads (int threadsCount)\n\t\t\t{\n\t\t\tif (_isSuspended)\n\t\t\t\t{\n\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\tlock (_workerThreads.SyncRoot)\n\t\t\t\t{\n\t\t\t\t// Don't start threads on shut down\n\t\t\t\tif (_shutdown)\n\t\t\t\t\t{\n\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\tfor (int i = 0; i < threadsCount; ++i)\n\t\t\t\t\t{\n\t\t\t\t\t// Don't create more threads then the upper limit\n\t\t\t\t\tif (_workerThreads.Count >= _stpStartInfo.MaxWorkerThreads)\n\t\t\t\t\t\t{\n\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Create a new thread\n\n#if (_SILVERLIGHT) || (WINDOWS_PHONE) || (_WINDOWS_CE)\n#if SSHARP\n\t\t\t\t\tvar te = new ThreadEntry (this);\n\n\t\t\t\t\tThread workerThread = new Thread (ProcessQueuedItems, te, Thread.eThreadStartOptions.CreateSuspended);\n#else\n\t\t\t\t\tThread workerThread = new Thread (ProcessQueuedItems, null);\n#endif\n#else\n                    Thread workerThread =\n                        _stpStartInfo.MaxStackSize.HasValue\n                        ? new Thread(ProcessQueuedItems, _stpStartInfo.MaxStackSize.Value)\n                        : new Thread(ProcessQueuedItems);\n#endif\n\t\t\t\t\t// Configure the new thread and start it\n\t\t\t\t\tworkerThread.Name = \"STP \" + Name + \" Thread #\" + _threadCounter;\n#if !SSHARP\n\t\t\t\t\tworkerThread.IsBackground = _stpStartInfo.AreThreadsBackground;\n#endif\n\n#if !(_SILVERLIGHT) && !(_WINDOWS_CE) && !(WINDOWS_PHONE)\n                    if (_stpStartInfo.ApartmentState != ApartmentState.Unknown)\n                    {\n                        workerThread.SetApartmentState(_stpStartInfo.ApartmentState);\n                    }\n#endif\n\n#if !(_SILVERLIGHT) && !(WINDOWS_PHONE)\n\t\t\t\t\tworkerThread.Priority = _stpStartInfo.ThreadPriority;\n#endif\n\t\t\t\t\tworkerThread.Start ();\n\t\t\t\t\t++_threadCounter;\n\n#if SSHARP\n\t\t\t\t\t_workerThreads.AddPendingEntry ();\n#else\n\t\t\t\t\t// Add it to the dictionary and update its creation time.\n\t\t\t\t\t_workerThreads[workerThread] = new ThreadEntry (this);\n#endif\n\n\t\t\t\t\t_windowsPCs.SampleThreads (_workerThreads.Count, _inUseWorkerThreads);\n\t\t\t\t\t_localPCs.SampleThreads (_workerThreads.Count, _inUseWorkerThreads);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// A worker thread method that processes work items from the work items queue.\n\t\t/// </summary>\n\t\tprivate object ProcessQueuedItems (object state)\n\t\t\t{\n#if SSHARP\n\t\t\tvar te = (ThreadEntry)state;\n\t\t\t_workerThreads[Thread.CurrentThread] = te;\n\t\t\t_workerThreads.RemovePendingEntry ();\n#endif\n\n\t\t\t// Keep the entry of the dictionary as thread's variable to avoid the synchronization locks\n\t\t\t// of the dictionary.\n\t\t\tCurrentThreadEntry = _workerThreads[Thread.CurrentThread];\n\n\t\t\tFireOnThreadInitialization ();\n\n\t\t\ttry\n\t\t\t\t{\n\t\t\t\tbool bInUseWorkerThreadsWasIncremented = false;\n\n\t\t\t\t// Process until shutdown.\n\t\t\t\twhile (!_shutdown)\n\t\t\t\t\t{\n\t\t\t\t\t// Update the last time this thread was seen alive.\n\t\t\t\t\t// It's good for debugging.\n\t\t\t\t\tCurrentThreadEntry.IAmAlive ();\n\n\t\t\t\t\t// The following block handles the when the MaxWorkerThreads has been\n\t\t\t\t\t// incremented by the user at run-time.\n\t\t\t\t\t// Double lock for quit.\n\t\t\t\t\tif (_workerThreads.Count > _stpStartInfo.MaxWorkerThreads)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tlock (_workerThreads.SyncRoot)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (_workerThreads.Count > _stpStartInfo.MaxWorkerThreads)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t// Inform that the thread is quiting and then quit.\n\t\t\t\t\t\t\t\t// This method must be called within this lock or else\n\t\t\t\t\t\t\t\t// more threads will quit and the thread pool will go\n\t\t\t\t\t\t\t\t// below the lower limit.\n\t\t\t\t\t\t\t\tInformCompleted ();\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// Wait for a work item, shutdown, or timeout\n\t\t\t\t\tWorkItem workItem = Dequeue ();\n\n\t\t\t\t\t// Update the last time this thread was seen alive.\n\t\t\t\t\t// It's good for debugging.\n\t\t\t\t\tCurrentThreadEntry.IAmAlive ();\n\n\t\t\t\t\t// On timeout or shut down.\n\t\t\t\t\tif (null == workItem)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t// Double lock for quit.\n\t\t\t\t\t\tif (_workerThreads.Count > _stpStartInfo.MinWorkerThreads)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tlock (_workerThreads.SyncRoot)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (_workerThreads.Count > _stpStartInfo.MinWorkerThreads)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t// Inform that the thread is quiting and then quit.\n\t\t\t\t\t\t\t\t\t// This method must be called within this lock or else\n\t\t\t\t\t\t\t\t\t// more threads will quit and the thread pool will go\n\t\t\t\t\t\t\t\t\t// below the lower limit.\n\t\t\t\t\t\t\t\t\tInformCompleted ();\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// If we didn't quit then skip to the next iteration.\n\t\t\t\t\tif (null == workItem)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t// Initialize the value to false\n\t\t\t\t\t\tbInUseWorkerThreadsWasIncremented = false;\n\n\t\t\t\t\t\t// Set the Current Work Item of the thread.\n\t\t\t\t\t\t// Store the Current Work Item  before the workItem.StartingWorkItem() is called, \n\t\t\t\t\t\t// so WorkItem.Cancel can work when the work item is between InQueue and InProgress \n\t\t\t\t\t\t// states.\n\t\t\t\t\t\t// If the work item has been cancelled BEFORE the workItem.StartingWorkItem() \n\t\t\t\t\t\t// (work item is in InQueue state) then workItem.StartingWorkItem() will return false.\n\t\t\t\t\t\t// If the work item has been cancelled AFTER the workItem.StartingWorkItem() then\n\t\t\t\t\t\t// (work item is in InProgress state) then the thread will be aborted\n\t\t\t\t\t\tCurrentThreadEntry.CurrentWorkItem = workItem;\n\n\t\t\t\t\t\t// Change the state of the work item to 'in progress' if possible.\n\t\t\t\t\t\t// We do it here so if the work item has been canceled we won't \n\t\t\t\t\t\t// increment the _inUseWorkerThreads.\n\t\t\t\t\t\t// The cancel mechanism doesn't delete items from the queue,  \n\t\t\t\t\t\t// it marks the work item as canceled, and when the work item\n\t\t\t\t\t\t// is dequeued, we just skip it.\n\t\t\t\t\t\t// If the post execute of work item is set to always or to\n\t\t\t\t\t\t// call when the work item is canceled then the StartingWorkItem()\n\t\t\t\t\t\t// will return true, so the post execute can run.\n\t\t\t\t\t\tif (!workItem.StartingWorkItem ())\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Execute the callback.  Make sure to accurately\n\t\t\t\t\t\t// record how many callbacks are currently executing.\n\t\t\t\t\t\tint inUseWorkerThreads = Interlocked.Increment (ref _inUseWorkerThreads);\n\t\t\t\t\t\t_windowsPCs.SampleThreads (_workerThreads.Count, inUseWorkerThreads);\n\t\t\t\t\t\t_localPCs.SampleThreads (_workerThreads.Count, inUseWorkerThreads);\n\n\t\t\t\t\t\t// Mark that the _inUseWorkerThreads incremented, so in the finally{}\n\t\t\t\t\t\t// statement we will decrement it correctly.\n\t\t\t\t\t\tbInUseWorkerThreadsWasIncremented = true;\n\n\t\t\t\t\t\tworkItem.FireWorkItemStarted ();\n\n\t\t\t\t\t\tExecuteWorkItem (workItem);\n\t\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception ex)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tex.GetHashCode ();\n\t\t\t\t\t\t// Do nothing\n\t\t\t\t\t\t}\n\t\t\t\t\tfinally\n\t\t\t\t\t\t{\n\t\t\t\t\t\tworkItem.DisposeOfState ();\n\n\t\t\t\t\t\t// Set the CurrentWorkItem to null, since we \n\t\t\t\t\t\t// no longer run user's code.\n\t\t\t\t\t\tCurrentThreadEntry.CurrentWorkItem = null;\n\n\t\t\t\t\t\t// Decrement the _inUseWorkerThreads only if we had \n\t\t\t\t\t\t// incremented it. Note the cancelled work items don't\n\t\t\t\t\t\t// increment _inUseWorkerThreads.\n\t\t\t\t\t\tif (bInUseWorkerThreadsWasIncremented)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tint inUseWorkerThreads = Interlocked.Decrement (ref _inUseWorkerThreads);\n\t\t\t\t\t\t\t_windowsPCs.SampleThreads (_workerThreads.Count, inUseWorkerThreads);\n\t\t\t\t\t\t\t_localPCs.SampleThreads (_workerThreads.Count, inUseWorkerThreads);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Notify that the work item has been completed.\n\t\t\t\t\t\t// WorkItemsGroup may enqueue their next work item.\n\t\t\t\t\t\tworkItem.FireWorkItemCompleted ();\n\n\t\t\t\t\t\t// Decrement the number of work items here so the idle \n\t\t\t\t\t\t// ManualResetEvent won't fluctuate.\n\t\t\t\t\t\tDecrementWorkItemsCount ();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n#if SSHARP\n\t\t\tcatch (Exception tae)\n#else\n\t\t\tcatch (ThreadAbortException tae)\n#endif\n\t\t\t\t{\n#if SSHARP\n\t\t\t\tException e = tae;\n\n\t\t\t\tif (tae is ThreadAbortException)\n\t\t\t\t\t{\n#endif\n\t\t\t\ttae.GetHashCode ();\n\t\t\t\t// Handle the abort exception gracfully.\n#if !(_WINDOWS_CE) && !(_SILVERLIGHT) && !(WINDOWS_PHONE)\n\t\t\t\tThread.ResetAbort();\n#endif\n\n\t\t\t\t}\n#if !SSHARP\n\t\t\tcatch (Exception e)\n\t\t\t\t{\n#endif\n\t\t\t\t//Debug.Assert (null != e);\n\t\t\t\t}\n\t\t\tfinally\n\t\t\t\t{\n\t\t\t\tInformCompleted ();\n\t\t\t\tFireOnThreadTermination ();\n\t\t\t\t}\n\n\t\t\treturn null;\n\t\t\t}\n\n\t\tprivate void ExecuteWorkItem (WorkItem workItem)\n\t\t\t{\n\t\t\t_windowsPCs.SampleWorkItemsWaitTime (workItem.WaitingTime);\n\t\t\t_localPCs.SampleWorkItemsWaitTime (workItem.WaitingTime);\n\t\t\ttry\n\t\t\t\t{\n\t\t\t\tworkItem.Execute ();\n\t\t\t\t}\n\t\t\tfinally\n\t\t\t\t{\n\t\t\t\t_windowsPCs.SampleWorkItemsProcessTime (workItem.ProcessTime);\n\t\t\t\t_localPCs.SampleWorkItemsProcessTime (workItem.ProcessTime);\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t#endregion\n\n\t\t#region Public Methods\n\n\t\tprivate void ValidateWaitForIdle ()\n\t\t\t{\n\t\t\tif (null != CurrentThreadEntry && CurrentThreadEntry.AssociatedSmartThreadPool == this)\n\t\t\t\t{\n\t\t\t\tthrow new NotSupportedException (\n\t\t\t\t\t\"WaitForIdle cannot be called from a thread on its SmartThreadPool, it causes a deadlock\");\n\t\t\t\t}\n\t\t\t}\n\n\t\tinternal static void ValidateWorkItemsGroupWaitForIdle (IWorkItemsGroup workItemsGroup)\n\t\t\t{\n\t\t\tif (null == CurrentThreadEntry)\n\t\t\t\t{\n\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\tWorkItem workItem = CurrentThreadEntry.CurrentWorkItem;\n\t\t\tValidateWorkItemsGroupWaitForIdleImpl (workItemsGroup, workItem);\n\t\t\tif ((null != workItemsGroup) &&\n\t\t\t\t(null != workItem) &&\n\t\t\t\tCurrentThreadEntry.CurrentWorkItem.WasQueuedBy (workItemsGroup))\n\t\t\t\t{\n\t\t\t\tthrow new NotSupportedException (\"WaitForIdle cannot be called from a thread on its SmartThreadPool, it causes a deadlock\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t[MethodImpl (MethodImplOptions.NoInlining)]\n\t\tprivate static void ValidateWorkItemsGroupWaitForIdleImpl (IWorkItemsGroup workItemsGroup, WorkItem workItem)\n\t\t\t{\n\t\t\tif ((null != workItemsGroup) &&\n\t\t\t\t(null != workItem) &&\n\t\t\t\tworkItem.WasQueuedBy (workItemsGroup))\n\t\t\t\t{\n\t\t\t\tthrow new NotSupportedException (\"WaitForIdle cannot be called from a thread on its SmartThreadPool, it causes a deadlock\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Force the SmartThreadPool to shutdown\n\t\t/// </summary>\n\t\tpublic void Shutdown ()\n\t\t\t{\n\t\t\tShutdown (true, 0);\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Force the SmartThreadPool to shutdown with timeout\n\t\t/// </summary>\n\t\tpublic void Shutdown (bool forceAbort, TimeSpan timeout)\n\t\t\t{\n\t\t\tShutdown (forceAbort, (int)timeout.TotalMilliseconds);\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Empties the queue of work items and abort the threads in the pool.\n\t\t/// </summary>\n\t\tpublic void Shutdown (bool forceAbort, int millisecondsTimeout)\n\t\t\t{\n\t\t\tValidateNotDisposed ();\n\n\t\t\tISTPInstancePerformanceCounters pcs = _windowsPCs;\n\n\t\t\tif (NullSTPInstancePerformanceCounters.Instance != _windowsPCs)\n\t\t\t\t{\n\t\t\t\t// Set the _pcs to \"null\" to stop updating the performance\n\t\t\t\t// counters\n\t\t\t\t_windowsPCs = NullSTPInstancePerformanceCounters.Instance;\n\n\t\t\t\tpcs.Dispose ();\n\t\t\t\t}\n\n\t\t\tThread[] threads;\n\t\t\tlock (_workerThreads.SyncRoot)\n\t\t\t\t{\n\t\t\t\t// Shutdown the work items queue\n\t\t\t\t_workItemsQueue.Dispose ();\n\n\t\t\t\t// Signal the threads to exit\n\t\t\t\t_shutdown = true;\n\t\t\t\t_shuttingDownEvent.Set ();\n\n\t\t\t\t// Make a copy of the threads' references in the pool\n#if SSHARP\n\t\t\t\tthreads = new Thread[_workerThreads.RealCount];\n#else\n\t\t\t\tthreads = new Thread[_workerThreads.Count];\n#endif\n\t\t\t\t_workerThreads.Keys.CopyTo (threads, 0);\n\t\t\t\t}\n\n\t\t\tint millisecondsLeft = millisecondsTimeout;\n\t\t\tStopwatch stopwatch = Stopwatch.StartNew ();\n\t\t\t//DateTime start = DateTime.UtcNow;\n\t\t\tbool waitInfinitely = (Timeout.Infinite == millisecondsTimeout);\n\t\t\tbool timeout = false;\n\n\t\t\t// Each iteration we update the time left for the timeout.\n\t\t\tforeach (Thread thread in threads)\n\t\t\t\t{\n\t\t\t\t// Join don't work with negative numbers\n\t\t\t\tif (!waitInfinitely && (millisecondsLeft < 0))\n\t\t\t\t\t{\n\t\t\t\t\ttimeout = true;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t// Wait for the thread to terminate\n#if SSHARP\n\t\t\t\tbool success;\n\t\t\t\ttry\n\t\t\t\t\t{\n\t\t\t\t\tsuccess = thread.Join (millisecondsLeft);\n\t\t\t\t\t}\n\t\t\t\tcatch (NullReferenceException)\n\t\t\t\t\t{\n\t\t\t\t\tsuccess = true;\n\t\t\t\t\t}\n#else\n\t\t\t\tbool success = thread.Join (millisecondsLeft);\n#endif\n\t\t\t\tif (!success)\n\t\t\t\t\t{\n\t\t\t\t\ttimeout = true;\n\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\tif (!waitInfinitely)\n\t\t\t\t\t{\n\t\t\t\t\t// Update the time left to wait\n\t\t\t\t\t//TimeSpan ts = DateTime.UtcNow - start;\n\t\t\t\t\tmillisecondsLeft = millisecondsTimeout - (int)stopwatch.ElapsedMilliseconds;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\tif (timeout && forceAbort)\n\t\t\t\t{\n\t\t\t\t// Abort the threads in the pool\n\t\t\t\tforeach (Thread thread in threads)\n\t\t\t\t\t{\n\n#if SSHARP\n\t\t\t\t\tbool running = false;\n\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\trunning = thread != null && !thread.Join (0);\n\t\t\t\t\t\t}\n\t\t\t\t\tcatch (NullReferenceException)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\n\t\t\t\t\tif (running)\n#else\n\t\t\t\t\tif ((thread != null)\n#if (_WINDOWS_CE)\n\t\t\t\t\t\t&& !thread.Join (0)\n#else\n                        && thread.IsAlive\n#endif\n)\n#endif\n\t\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthread.Abort (); // Shutdown\n\t\t\t\t\t\t\t}\n#if SSHARP\n\t\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (e.GetType () != typeof (System.Threading.ThreadAbortException) && e.GetType () != typeof (SecurityException))\n\t\t\t\t\t\t\t\tthrow;\n\t\t\t\t\t\t\te.GetHashCode ();\n\t\t\t\t\t\t\t}\n#else\n\t\t\t\t\t\tcatch (SecurityException e)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\te.GetHashCode ();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch (ThreadStateException ex)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\tex.GetHashCode ();\n\t\t\t\t\t\t\t// In case the thread has been terminated \n\t\t\t\t\t\t\t// after the check if it is alive.\n\t\t\t\t\t\t\t}\n#endif\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Wait for all work items to complete\n\t\t/// </summary>\n\t\t/// <param name=\"waitableResults\">Array of work item result objects</param>\n\t\t/// <returns>\n\t\t/// true when every work item in workItemResults has completed; otherwise false.\n\t\t/// </returns>\n\t\tpublic static bool WaitAll (\n\t\t\tIWaitableResult[] waitableResults)\n\t\t\t{\n\t\t\treturn WaitAll (waitableResults, Timeout.Infinite, true);\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Wait for all work items to complete\n\t\t/// </summary>\n\t\t/// <param name=\"waitableResults\">Array of work item result objects</param>\n\t\t/// <param name=\"timeout\">The number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely. </param>\n\t\t/// <param name=\"exitContext\">\n\t\t/// true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. \n\t\t/// </param>\n\t\t/// <returns>\n\t\t/// true when every work item in workItemResults has completed; otherwise false.\n\t\t/// </returns>\n\t\tpublic static bool WaitAll (\n\t\t\tIWaitableResult[] waitableResults,\n\t\t\tTimeSpan timeout,\n\t\t\tbool exitContext)\n\t\t\t{\n\t\t\treturn WaitAll (waitableResults, (int)timeout.TotalMilliseconds, exitContext);\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Wait for all work items to complete\n\t\t/// </summary>\n\t\t/// <param name=\"waitableResults\">Array of work item result objects</param>\n\t\t/// <param name=\"timeout\">The number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely. </param>\n\t\t/// <param name=\"exitContext\">\n\t\t/// true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. \n\t\t/// </param>\n\t\t/// <param name=\"cancelWaitHandle\">A cancel wait handle to interrupt the wait if needed</param>\n\t\t/// <returns>\n\t\t/// true when every work item in workItemResults has completed; otherwise false.\n\t\t/// </returns>\n\t\tpublic static bool WaitAll (\n\t\t\tIWaitableResult[] waitableResults,\n\t\t\tTimeSpan timeout,\n\t\t\tbool exitContext,\n\t\t\tWaitHandle cancelWaitHandle)\n\t\t\t{\n\t\t\treturn WaitAll (waitableResults, (int)timeout.TotalMilliseconds, exitContext, cancelWaitHandle);\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Wait for all work items to complete\n\t\t/// </summary>\n\t\t/// <param name=\"waitableResults\">Array of work item result objects</param>\n\t\t/// <param name=\"millisecondsTimeout\">The number of milliseconds to wait, or Timeout.Infinite (-1) to wait indefinitely.</param>\n\t\t/// <param name=\"exitContext\">\n\t\t/// true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. \n\t\t/// </param>\n\t\t/// <returns>\n\t\t/// true when every work item in workItemResults has completed; otherwise false.\n\t\t/// </returns>\n\t\tpublic static bool WaitAll (\n\t\t\tIWaitableResult[] waitableResults,\n\t\t\tint millisecondsTimeout,\n\t\t\tbool exitContext)\n\t\t\t{\n\t\t\treturn WorkItem.WaitAll (waitableResults, millisecondsTimeout, exitContext, null);\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Wait for all work items to complete\n\t\t/// </summary>\n\t\t/// <param name=\"waitableResults\">Array of work item result objects</param>\n\t\t/// <param name=\"millisecondsTimeout\">The number of milliseconds to wait, or Timeout.Infinite (-1) to wait indefinitely.</param>\n\t\t/// <param name=\"exitContext\">\n\t\t/// true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. \n\t\t/// </param>\n\t\t/// <param name=\"cancelWaitHandle\">A cancel wait handle to interrupt the wait if needed</param>\n\t\t/// <returns>\n\t\t/// true when every work item in workItemResults has completed; otherwise false.\n\t\t/// </returns>\n\t\tpublic static bool WaitAll (\n\t\t\tIWaitableResult[] waitableResults,\n\t\t\tint millisecondsTimeout,\n\t\t\tbool exitContext,\n\t\t\tWaitHandle cancelWaitHandle)\n\t\t\t{\n\t\t\treturn WorkItem.WaitAll (waitableResults, millisecondsTimeout, exitContext, cancelWaitHandle);\n\t\t\t}\n\n\n\t\t/// <summary>\n\t\t/// Waits for any of the work items in the specified array to complete, cancel, or timeout\n\t\t/// </summary>\n\t\t/// <param name=\"waitableResults\">Array of work item result objects</param>\n\t\t/// <returns>\n\t\t/// The array index of the work item result that satisfied the wait, or WaitTimeout if any of the work items has been canceled.\n\t\t/// </returns>\n\t\tpublic static int WaitAny (\n\t\t\tIWaitableResult[] waitableResults)\n\t\t\t{\n\t\t\treturn WaitAny (waitableResults, Timeout.Infinite, true);\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Waits for any of the work items in the specified array to complete, cancel, or timeout\n\t\t/// </summary>\n\t\t/// <param name=\"waitableResults\">Array of work item result objects</param>\n\t\t/// <param name=\"timeout\">The number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely. </param>\n\t\t/// <param name=\"exitContext\">\n\t\t/// true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. \n\t\t/// </param>\n\t\t/// <returns>\n\t\t/// The array index of the work item result that satisfied the wait, or WaitTimeout if no work item result satisfied the wait and a time interval equivalent to millisecondsTimeout has passed or the work item has been canceled.\n\t\t/// </returns>\n\t\tpublic static int WaitAny (\n\t\t\tIWaitableResult[] waitableResults,\n\t\t\tTimeSpan timeout,\n\t\t\tbool exitContext)\n\t\t\t{\n\t\t\treturn WaitAny (waitableResults, (int)timeout.TotalMilliseconds, exitContext);\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Waits for any of the work items in the specified array to complete, cancel, or timeout\n\t\t/// </summary>\n\t\t/// <param name=\"waitableResults\">Array of work item result objects</param>\n\t\t/// <param name=\"timeout\">The number of milliseconds to wait, or a TimeSpan that represents -1 milliseconds to wait indefinitely. </param>\n\t\t/// <param name=\"exitContext\">\n\t\t/// true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. \n\t\t/// </param>\n\t\t/// <param name=\"cancelWaitHandle\">A cancel wait handle to interrupt the wait if needed</param>\n\t\t/// <returns>\n\t\t/// The array index of the work item result that satisfied the wait, or WaitTimeout if no work item result satisfied the wait and a time interval equivalent to millisecondsTimeout has passed or the work item has been canceled.\n\t\t/// </returns>\n\t\tpublic static int WaitAny (\n\t\t\tIWaitableResult[] waitableResults,\n\t\t\tTimeSpan timeout,\n\t\t\tbool exitContext,\n\t\t\tWaitHandle cancelWaitHandle)\n\t\t\t{\n\t\t\treturn WaitAny (waitableResults, (int)timeout.TotalMilliseconds, exitContext, cancelWaitHandle);\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Waits for any of the work items in the specified array to complete, cancel, or timeout\n\t\t/// </summary>\n\t\t/// <param name=\"waitableResults\">Array of work item result objects</param>\n\t\t/// <param name=\"millisecondsTimeout\">The number of milliseconds to wait, or Timeout.Infinite (-1) to wait indefinitely.</param>\n\t\t/// <param name=\"exitContext\">\n\t\t/// true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. \n\t\t/// </param>\n\t\t/// <returns>\n\t\t/// The array index of the work item result that satisfied the wait, or WaitTimeout if no work item result satisfied the wait and a time interval equivalent to millisecondsTimeout has passed or the work item has been canceled.\n\t\t/// </returns>\n\t\tpublic static int WaitAny (\n\t\t\tIWaitableResult[] waitableResults,\n\t\t\tint millisecondsTimeout,\n\t\t\tbool exitContext)\n\t\t\t{\n\t\t\treturn WorkItem.WaitAny (waitableResults, millisecondsTimeout, exitContext, null);\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Waits for any of the work items in the specified array to complete, cancel, or timeout\n\t\t/// </summary>\n\t\t/// <param name=\"waitableResults\">Array of work item result objects</param>\n\t\t/// <param name=\"millisecondsTimeout\">The number of milliseconds to wait, or Timeout.Infinite (-1) to wait indefinitely.</param>\n\t\t/// <param name=\"exitContext\">\n\t\t/// true to exit the synchronization domain for the context before the wait (if in a synchronized context), and reacquire it; otherwise, false. \n\t\t/// </param>\n\t\t/// <param name=\"cancelWaitHandle\">A cancel wait handle to interrupt the wait if needed</param>\n\t\t/// <returns>\n\t\t/// The array index of the work item result that satisfied the wait, or WaitTimeout if no work item result satisfied the wait and a time interval equivalent to millisecondsTimeout has passed or the work item has been canceled.\n\t\t/// </returns>\n\t\tpublic static int WaitAny (\n\t\t\tIWaitableResult[] waitableResults,\n\t\t\tint millisecondsTimeout,\n\t\t\tbool exitContext,\n\t\t\tWaitHandle cancelWaitHandle)\n\t\t\t{\n\t\t\treturn WorkItem.WaitAny (waitableResults, millisecondsTimeout, exitContext, cancelWaitHandle);\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Creates a new WorkItemsGroup.\n\t\t/// </summary>\n\t\t/// <param name=\"concurrency\">The number of work items that can be run concurrently</param>\n\t\t/// <returns>A reference to the WorkItemsGroup</returns>\n\t\tpublic IWorkItemsGroup CreateWorkItemsGroup (int concurrency)\n\t\t\t{\n\t\t\tIWorkItemsGroup workItemsGroup = new WorkItemsGroup (this, concurrency, _stpStartInfo);\n\t\t\treturn workItemsGroup;\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Creates a new WorkItemsGroup.\n\t\t/// </summary>\n\t\t/// <param name=\"concurrency\">The number of work items that can be run concurrently</param>\n\t\t/// <param name=\"wigStartInfo\">A WorkItemsGroup configuration that overrides the default behavior</param>\n\t\t/// <returns>A reference to the WorkItemsGroup</returns>\n\t\tpublic IWorkItemsGroup CreateWorkItemsGroup (int concurrency, WIGStartInfo wigStartInfo)\n\t\t\t{\n\t\t\tIWorkItemsGroup workItemsGroup = new WorkItemsGroup (this, concurrency, wigStartInfo);\n\t\t\treturn workItemsGroup;\n\t\t\t}\n\n\t\t#region Fire Thread's Events\n\n\t\tprivate void FireOnThreadInitialization ()\n\t\t\t{\n\t\t\tif (null != _onThreadInitialization)\n\t\t\t\t{\n\t\t\t\tforeach (ThreadInitializationHandler tih in _onThreadInitialization.GetInvocationList ())\n\t\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\ttih ();\n\t\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\te.GetHashCode ();\n\t\t\t\t\t\t//Debug.Assert (false);\n\t\t\t\t\t\tthrow;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tprivate void FireOnThreadTermination ()\n\t\t\t{\n\t\t\tif (null != _onThreadTermination)\n\t\t\t\t{\n\t\t\t\tforeach (ThreadTerminationHandler tth in _onThreadTermination.GetInvocationList ())\n\t\t\t\t\t{\n\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\ttth ();\n\t\t\t\t\t\t}\n\t\t\t\t\tcatch (Exception e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\te.GetHashCode ();\n\t\t\t\t\t\t//Debug.Assert (false);\n\t\t\t\t\t\tthrow;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t#endregion\n\n\t\t/// <summary>\n\t\t/// This event is fired when a thread is created.\n\t\t/// Use it to initialize a thread before the work items use it.\n\t\t/// </summary>\n\t\tpublic event ThreadInitializationHandler OnThreadInitialization\n\t\t\t{\n\t\t\tadd { _onThreadInitialization += value; }\n\t\t\tremove { _onThreadInitialization -= value; }\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// This event is fired when a thread is terminating.\n\t\t/// Use it for cleanup.\n\t\t/// </summary>\n\t\tpublic event ThreadTerminationHandler OnThreadTermination\n\t\t\t{\n\t\t\tadd { _onThreadTermination += value; }\n\t\t\tremove { _onThreadTermination -= value; }\n\t\t\t}\n\n\n\t\tinternal void CancelAbortWorkItemsGroup (WorkItemsGroup wig)\n\t\t\t{\n\t\t\tThreadEntry[] threadEntries;\n\t\t\tlock (_workerThreads.SyncRoot)\n\t\t\t\t{\n\t\t\t\tthreadEntries = new ThreadEntry[_workerThreads.RealCount];\n\t\t\t\t_workerThreads.Values.CopyTo (threadEntries, 0);\n\t\t\t\t}\n\n\t\t\tforeach (ThreadEntry threadEntry in threadEntries)\n\t\t\t\t{\n\t\t\t\tWorkItem workItem = threadEntry.CurrentWorkItem;\n\t\t\t\tif (null != workItem &&\n\t\t\t\t\tworkItem.WasQueuedBy (wig) &&\n\t\t\t\t\t!workItem.IsCanceled)\n\t\t\t\t\t{\n\t\t\t\t\tthreadEntry.CurrentWorkItem.GetWorkItemResult ().Cancel (true);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t#endregion\n\n\t\t#region Properties\n\n\t\t/// <summary>\n\t\t/// Get/Set the lower limit of threads in the pool.\n\t\t/// </summary>\n\t\tpublic int MinThreads\n\t\t\t{\n\t\t\tget\n\t\t\t\t{\n\t\t\t\tValidateNotDisposed ();\n\t\t\t\treturn _stpStartInfo.MinWorkerThreads;\n\t\t\t\t}\n\t\t\tset\n\t\t\t\t{\n\t\t\t\t//Debug.Assert (value >= 0);\n\t\t\t\t//Debug.Assert (value <= _stpStartInfo.MaxWorkerThreads);\n\t\t\t\tif (_stpStartInfo.MaxWorkerThreads < value)\n\t\t\t\t\t{\n\t\t\t\t\t_stpStartInfo.MaxWorkerThreads = value;\n\t\t\t\t\t}\n\t\t\t\t_stpStartInfo.MinWorkerThreads = value;\n\t\t\t\tStartOptimalNumberOfThreads ();\n\t\t\t\t}\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Get/Set the upper limit of threads in the pool.\n\t\t/// </summary>\n\t\tpublic int MaxThreads\n\t\t\t{\n\t\t\tget\n\t\t\t\t{\n\t\t\t\tValidateNotDisposed ();\n\t\t\t\treturn _stpStartInfo.MaxWorkerThreads;\n\t\t\t\t}\n\n\t\t\tset\n\t\t\t\t{\n\t\t\t\t//Debug.Assert (value > 0);\n\t\t\t\t//Debug.Assert (value >= _stpStartInfo.MinWorkerThreads);\n\t\t\t\tif (_stpStartInfo.MinWorkerThreads > value)\n\t\t\t\t\t{\n\t\t\t\t\t_stpStartInfo.MinWorkerThreads = value;\n\t\t\t\t\t}\n\t\t\t\t_stpStartInfo.MaxWorkerThreads = value;\n\t\t\t\tStartOptimalNumberOfThreads ();\n\t\t\t\t}\n\t\t\t}\n\t\t/// <summary>\n\t\t/// Get the number of threads in the thread pool.\n\t\t/// Should be between the lower and the upper limits.\n\t\t/// </summary>\n\t\tpublic int ActiveThreads\n\t\t\t{\n\t\t\tget\n\t\t\t\t{\n\t\t\t\tValidateNotDisposed ();\n\t\t\t\treturn _workerThreads.Count;\n\t\t\t\t}\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Get the number of busy (not idle) threads in the thread pool.\n\t\t/// </summary>\n\t\tpublic int InUseThreads\n\t\t\t{\n\t\t\tget\n\t\t\t\t{\n\t\t\t\tValidateNotDisposed ();\n\t\t\t\treturn _inUseWorkerThreads;\n\t\t\t\t}\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Returns true if the current running work item has been cancelled.\n\t\t/// Must be used within the work item's callback method.\n\t\t/// The work item should sample this value in order to know if it\n\t\t/// needs to quit before its completion.\n\t\t/// </summary>\n\t\tpublic static bool IsWorkItemCanceled\n\t\t\t{\n\t\t\tget\n\t\t\t\t{\n\t\t\t\treturn CurrentThreadEntry.CurrentWorkItem.IsCanceled;\n\t\t\t\t}\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Checks if the work item has been cancelled, and if yes then abort the thread.\n\t\t/// Can be used with Cancel and timeout\n\t\t/// </summary>\n\t\tpublic static void AbortOnWorkItemCancel ()\n\t\t\t{\n\t\t\tif (IsWorkItemCanceled)\n\t\t\t\t{\n\t\t\t\tThread.CurrentThread.Abort ();\n\t\t\t\t}\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Thread Pool start information (readonly)\n\t\t/// </summary>\n\t\tpublic STPStartInfo STPStartInfo\n\t\t\t{\n\t\t\tget\n\t\t\t\t{\n\t\t\t\treturn _stpStartInfo.AsReadOnly ();\n\t\t\t\t}\n\t\t\t}\n\n\t\tpublic bool IsShuttingdown\n\t\t\t{\n\t\t\tget { return _shutdown; }\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Return the local calculated performance counters\n\t\t/// Available only if STPStartInfo.EnableLocalPerformanceCounters is true.\n\t\t/// </summary>\n\t\tpublic ISTPPerformanceCountersReader PerformanceCountersReader\n\t\t\t{\n\t\t\tget { return (ISTPPerformanceCountersReader)_localPCs; }\n\t\t\t}\n\t\t#endregion\n\n\t\t#region IDisposable Members\n\n\t\tpublic void Dispose ()\n\t\t\t{\n\t\t\tif (!_isDisposed)\n\t\t\t\t{\n\t\t\t\tif (!_shutdown)\n\t\t\t\t\t{\n\t\t\t\t\tShutdown ();\n\t\t\t\t\t}\n\n\t\t\t\tif (null != _shuttingDownEvent)\n\t\t\t\t\t{\n\t\t\t\t\t_shuttingDownEvent.Close ();\n\t\t\t\t\t_shuttingDownEvent = null;\n\t\t\t\t\t}\n\t\t\t\t_workerThreads.Clear ();\n\n\t\t\t\tif (null != _isIdleWaitHandle)\n\t\t\t\t\t{\n\t\t\t\t\t_isIdleWaitHandle.Close ();\n\t\t\t\t\t_isIdleWaitHandle = null;\n\t\t\t\t\t}\n\n\t\t\t\t_isDisposed = true;\n\t\t\t\t}\n\t\t\t}\n\n\t\tprivate void ValidateNotDisposed ()\n\t\t\t{\n\t\t\tif (_isDisposed)\n\t\t\t\t{\n\t\t\t\tthrow new ObjectDisposedException (GetType ().ToString (), \"The SmartThreadPool has been shutdown\");\n\t\t\t\t}\n\t\t\t}\n\t\t#endregion\n\n\t\t#region WorkItemsGroupBase Overrides\n\n\t\t/// <summary>\n\t\t/// Get/Set the maximum number of work items that execute cocurrency on the thread pool\n\t\t/// </summary>\n\t\tpublic override int Concurrency\n\t\t\t{\n\t\t\tget { return MaxThreads; }\n\t\t\tset { MaxThreads = value; }\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Get the number of work items in the queue.\n\t\t/// </summary>\n\t\tpublic override int WaitingCallbacks\n\t\t\t{\n\t\t\tget\n\t\t\t\t{\n\t\t\t\tValidateNotDisposed ();\n\t\t\t\treturn _workItemsQueue.Count;\n\t\t\t\t}\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Get an array with all the state objects of the currently running items.\n\t\t/// The array represents a snap shot and impact performance.\n\t\t/// </summary>\n\t\tpublic override object[] GetStates ()\n\t\t\t{\n\t\t\tobject[] states = _workItemsQueue.GetStates ();\n\t\t\treturn states;\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// WorkItemsGroup start information (readonly)\n\t\t/// </summary>\n\t\tpublic override WIGStartInfo WIGStartInfo\n\t\t\t{\n\t\t\tget { return _stpStartInfo.AsReadOnly (); }\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Start the thread pool if it was started suspended.\n\t\t/// If it is already running, this method is ignored.\n\t\t/// </summary>\n\t\tpublic override void Start ()\n\t\t\t{\n\t\t\tif (!_isSuspended)\n\t\t\t\t{\n\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t_isSuspended = false;\n\n\t\t\tICollection workItemsGroups = _workItemsGroups.Values;\n\t\t\tforeach (WorkItemsGroup workItemsGroup in workItemsGroups)\n\t\t\t\t{\n\t\t\t\tworkItemsGroup.OnSTPIsStarting ();\n\t\t\t\t}\n\n\t\t\tStartOptimalNumberOfThreads ();\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Cancel all work items using thread abortion\n\t\t/// </summary>\n\t\t/// <param name=\"abortExecution\">True to stop work items by raising ThreadAbortException</param>\n\t\tpublic override void Cancel (bool abortExecution)\n\t\t\t{\n\t\t\t_canceledSmartThreadPool.IsCanceled = true;\n\t\t\t_canceledSmartThreadPool = new CanceledWorkItemsGroup ();\n\n\t\t\tICollection workItemsGroups = _workItemsGroups.Values;\n\t\t\tforeach (WorkItemsGroup workItemsGroup in workItemsGroups)\n\t\t\t\t{\n\t\t\t\tworkItemsGroup.Cancel (abortExecution);\n\t\t\t\t}\n\n\t\t\tif (abortExecution)\n\t\t\t\t{\n\t\t\t\tThreadEntry[] threadEntries;\n\t\t\t\tlock (_workerThreads.SyncRoot)\n\t\t\t\t\t{\n\t\t\t\t\tthreadEntries = new ThreadEntry[_workerThreads.RealCount];\n\t\t\t\t\t_workerThreads.Values.CopyTo (threadEntries, 0);\n\t\t\t\t\t}\n\n\t\t\t\tforeach (ThreadEntry threadEntry in threadEntries)\n\t\t\t\t\t{\n\t\t\t\t\tWorkItem workItem = threadEntry.CurrentWorkItem;\n\t\t\t\t\tif (null != workItem &&\n\t\t\t\t\t\tthreadEntry.AssociatedSmartThreadPool == this &&\n\t\t\t\t\t\t!workItem.IsCanceled)\n\t\t\t\t\t\t{\n\t\t\t\t\t\tthreadEntry.CurrentWorkItem.GetWorkItemResult ().Cancel (true);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Wait for the thread pool to be idle\n\t\t/// </summary>\n\t\tpublic override bool WaitForIdle (int millisecondsTimeout)\n\t\t\t{\n\t\t\tValidateWaitForIdle ();\n\t\t\treturn STPEventWaitHandle.WaitOne (_isIdleWaitHandle, millisecondsTimeout, false);\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// This event is fired when all work items are completed.\n\t\t/// (When IsIdle changes to true)\n\t\t/// This event only work on WorkItemsGroup. On SmartThreadPool\n\t\t/// it throws the NotImplementedException.\n\t\t/// </summary>\n\t\tpublic override event WorkItemsGroupIdleHandler OnIdle\n\t\t\t{\n\t\t\tadd\n\t\t\t\t{\n\t\t\t\tthrow new NotImplementedException (\"This event is not implemented in the SmartThreadPool class. Please create a WorkItemsGroup in order to use this feature.\");\n\t\t\t\t//_onIdle += value;\n\t\t\t\t}\n\t\t\tremove\n\t\t\t\t{\n\t\t\t\tthrow new NotImplementedException (\"This event is not implemented in the SmartThreadPool class. Please create a WorkItemsGroup in order to use this feature.\");\n\t\t\t\t//_onIdle -= value;\n\t\t\t\t}\n\t\t\t}\n\n\t\tinternal override void PreQueueWorkItem ()\n\t\t\t{\n\t\t\tValidateNotDisposed ();\n\t\t\t}\n\n\t\t#endregion\n\n\t\t#region Join, Choice, Pipe, etc.\n\n\t\t/// <summary>\n\t\t/// Executes all actions in parallel.\n\t\t/// Returns when they all finish.\n\t\t/// </summary>\n\t\t/// <param name=\"actions\">Actions to execute</param>\n\t\tpublic void Join (IEnumerable<Action> actions)\n\t\t\t{\n\t\t\tWIGStartInfo wigStartInfo = new WIGStartInfo { StartSuspended = true };\n\t\t\tIWorkItemsGroup workItemsGroup = CreateWorkItemsGroup (int.MaxValue, wigStartInfo);\n\t\t\tforeach (Action action in actions)\n\t\t\t\t{\n\t\t\t\tworkItemsGroup.QueueWorkItem (action);\n\t\t\t\t}\n\t\t\tworkItemsGroup.Start ();\n\t\t\tworkItemsGroup.WaitForIdle ();\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Executes all actions in parallel.\n\t\t/// Returns when they all finish.\n\t\t/// </summary>\n\t\t/// <param name=\"actions\">Actions to execute</param>\n\t\tpublic void Join (params Action[] actions)\n\t\t\t{\n\t\t\tJoin ((IEnumerable<Action>)actions);\n\t\t\t}\n\n\t\tprivate class ChoiceIndex\n\t\t\t{\n\t\t\tpublic int _index = -1;\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Executes all actions in parallel\n\t\t/// Returns when the first one completes\n\t\t/// </summary>\n\t\t/// <param name=\"actions\">Actions to execute</param>\n\t\tpublic int Choice (IEnumerable<Action> actions)\n\t\t\t{\n\t\t\tWIGStartInfo wigStartInfo = new WIGStartInfo { StartSuspended = true };\n\t\t\tIWorkItemsGroup workItemsGroup = CreateWorkItemsGroup (int.MaxValue, wigStartInfo);\n\n\t\t\tManualResetEvent anActionCompleted = new ManualResetEvent (false);\n\n\t\t\tChoiceIndex choiceIndex = new ChoiceIndex ();\n\n\t\t\tint i = 0;\n\t\t\tforeach (Action action in actions)\n\t\t\t\t{\n\t\t\t\tAction act = action;\n\t\t\t\tint value = i;\n\t\t\t\tworkItemsGroup.QueueWorkItem (() => { act (); Interlocked.CompareExchange (ref choiceIndex._index, value, -1); anActionCompleted.Set (); });\n\t\t\t\t++i;\n\t\t\t\t}\n\t\t\tworkItemsGroup.Start ();\n\t\t\tanActionCompleted.WaitOne ();\n\n\t\t\treturn choiceIndex._index;\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Executes all actions in parallel\n\t\t/// Returns when the first one completes\n\t\t/// </summary>\n\t\t/// <param name=\"actions\">Actions to execute</param>\n\t\tpublic int Choice (params Action[] actions)\n\t\t\t{\n\t\t\treturn Choice ((IEnumerable<Action>)actions);\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Executes actions in sequence asynchronously.\n\t\t/// Returns immediately.\n\t\t/// </summary>\n\t\t/// <param name=\"pipeState\">A state context that passes </param>\n\t\t/// <param name=\"actions\">Actions to execute in the order they should run</param>\n\t\tpublic void Pipe<T> (T pipeState, IEnumerable<Action<T>> actions)\n\t\t\t{\n\t\t\tWIGStartInfo wigStartInfo = new WIGStartInfo { StartSuspended = true };\n\t\t\tIWorkItemsGroup workItemsGroup = CreateWorkItemsGroup (1, wigStartInfo);\n\t\t\tforeach (Action<T> action in actions)\n\t\t\t\t{\n\t\t\t\tAction<T> act = action;\n\t\t\t\tworkItemsGroup.QueueWorkItem (() => act (pipeState));\n\t\t\t\t}\n\t\t\tworkItemsGroup.Start ();\n\t\t\tworkItemsGroup.WaitForIdle ();\n\t\t\t}\n\n\t\t/// <summary>\n\t\t/// Executes actions in sequence asynchronously.\n\t\t/// Returns immediately.\n\t\t/// </summary>\n\t\t/// <param name=\"pipeState\"></param>\n\t\t/// <param name=\"actions\">Actions to execute in the order they should run</param>\n\t\tpublic void Pipe<T> (T pipeState, params Action<T>[] actions)\n\t\t\t{\n\t\t\tPipe (pipeState, (IEnumerable<Action<T>>)actions);\n\t\t\t}\n\t\t#endregion\n\t\t}\n\t#endregion\n\t}\n", "<Project ToolsVersion=\"3.5\" DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <PropertyGroup>\n    <Configuration Condition=\" '$(Configuration)' == '' \">Release</Configuration>\n    <Platform Condition=\" '$(Platform)' == '' \">AnyCPU</Platform>\n    <ProductVersion>9.0.30729</ProductVersion>\n    <SchemaVersion>2.0</SchemaVersion>\n    <ProjectGuid>{43AEC3F3-0D6D-406C-B4B1-45FCEAA8817A}</ProjectGuid>\n    <OutputType>Library</OutputType>\n    <AppDesignerFolder>Properties</AppDesignerFolder>\n    <RootNamespace>SSharpSmartThreadPoolTests</RootNamespace>\n    <AssemblyName>SSharpSmartThreadPoolTests</AssemblyName>\n    <ProjectTypeGuids>{0B4745B0-194B-4BB6-8E21-E9057CA92300};{4D628B5B-2FBC-4AA6-8C16-197242AEB884};{FAE04EC0-301F-11D3-BF4B-00C04F79EFBC}</ProjectTypeGuids>\n    <PlatformFamilyName>WindowsCE</PlatformFamilyName>\n    <PlatformID>E2BECB1F-8C8C-41ba-B736-9BE7D946A398</PlatformID>\n    <OSVersion>5.0</OSVersion>\n    <DeployDirSuffix>SmartDeviceProject1</DeployDirSuffix>\n    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>\n    <NativePlatformName>Windows CE</NativePlatformName>\n    <FormFactorID>\n    </FormFactorID>\n  </PropertyGroup>\n  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' \">\n    <AllowedReferenceRelatedFileExtensions>.allowedReferenceRelatedFileExtensions</AllowedReferenceRelatedFileExtensions>\n    <DebugSymbols>true</DebugSymbols>\n    <DebugType>full</DebugType>\n    <Optimize>false</Optimize>\n    <OutputPath>bin\\Debug\\</OutputPath>\n    <DefineConstants>DEBUG;TRACE;_WINDOWS_CE;_WINDOWS;SSHARP</DefineConstants>\n    <ErrorReport>prompt</ErrorReport>\n    <WarningLevel>4</WarningLevel>\n    <FileAlignment>512</FileAlignment>\n    <NoStdLib>true</NoStdLib>\n    <NoConfig>true</NoConfig>\n    <GenerateSerializationAssemblies>off</GenerateSerializationAssemblies>\n    <AllowUnsafeBlocks>true</AllowUnsafeBlocks>\n  </PropertyGroup>\n  <PropertyGroup Condition=\" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' \">\n    <AllowedReferenceRelatedFileExtensions>.allowedReferenceRelatedFileExtensions</AllowedReferenceRelatedFileExtensions>\n    <DebugType>none</DebugType>\n    <Optimize>true</Optimize>\n    <OutputPath>bin\\Release\\</OutputPath>\n    <ErrorReport>prompt</ErrorReport>\n    <WarningLevel>4</WarningLevel>\n    <FileAlignment>512</FileAlignment>\n    <NoStdLib>true</NoStdLib>\n    <NoConfig>true</NoConfig>\n    <GenerateSerializationAssemblies>off</GenerateSerializationAssemblies>\n    <DefineConstants>_WINDOWS_CE;_WINDOWS;SSHARP</DefineConstants>\n  </PropertyGroup>\n  <ItemGroup>\n    <Reference Include=\"mscorlib\" />\n    <Reference Include=\"SimplSharpCustomAttributesInterface, Version=1.0.0.0, Culture=neutral, PublicKeyToken=1099c178b3b54c3b, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>..\\..\\..\\..\\..\\ProgramData\\Crestron\\SDK\\SimplSharpCustomAttributesInterface.dll</HintPath>\n      <Private>False</Private>\n    </Reference>\n    <Reference Include=\"SimplSharpHelperInterface, Version=1.0.0.0, Culture=neutral, PublicKeyToken=1099c178b3b54c3b, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>..\\..\\..\\..\\..\\ProgramData\\Crestron\\SDK\\SimplSharpHelperInterface.dll</HintPath>\n      <Private>False</Private>\n    </Reference>\n    <Reference Include=\"SimplSharpPro, Version=1.4.0.14, Culture=neutral, PublicKeyToken=1099c178b3b54c3b, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>..\\..\\..\\..\\..\\ProgramData\\Crestron\\SDK\\SimplSharpPro.exe</HintPath>\n      <Private>False</Private>\n    </Reference>\n    <Reference Include=\"SSharpCrestronExtensionsLibrary, Version=1.0.0.13603, Culture=neutral, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>..\\..\\..\\Simpl# Libraries\\SSharpCrestronExtensionsLibrary\\SSharpCrestronExtensionsLibrary\\bin\\Release\\SSharpCrestronExtensionsLibrary.dll</HintPath>\n    </Reference>\n    <Reference Include=\"SSharpNunitLite, Version=3.0.5543.22955, Culture=neutral, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>..\\..\\SSharpNUnitLite3\\SSharpNunitLite\\bin\\Release\\SSharpNunitLite.dll</HintPath>\n    </Reference>\n    <Reference Include=\"SSharpThreadingLibrary, Version=1.0.0.15966, Culture=neutral, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>..\\..\\..\\Simpl# Libraries\\SSharpThreadingLibrary\\SSharpThreadingLibrary\\bin\\Release\\SSharpThreadingLibrary.dll</HintPath>\n    </Reference>\n    <Reference Include=\"SSMonoDiagnosticsLibrary, Version=1.0.0.23683, Culture=neutral, processorArchitecture=MSIL\">\n      <SpecificVersion>False</SpecificVersion>\n      <HintPath>..\\..\\..\\Simpl# Libraries\\SSMonoDiagnosticsLibrary\\SSMonoDiagnosticsLibrary\\bin\\Release\\SSMonoDiagnosticsLibrary.dll</HintPath>\n    </Reference>\n    <Reference Include=\"System\" />\n    <Reference Include=\"System.Core\" />\n    <Reference Include=\"System.Data\" />\n  </ItemGroup>\n  <ItemGroup>\n    <Compile Include=\"PermutationGenerator.cs\" />\n    <Compile Include=\"Properties\\AssemblyInfo.cs\" />\n    <Compile Include=\"QueueWorkItemHelper.cs\" />\n    <Compile Include=\"TestActionT.cs\" />\n    <Compile Include=\"TestCancel.cs\" />\n    <Compile Include=\"TestChainedDelegates.cs\" />\n    <Compile Include=\"TestConcurrencyChanges.cs\" />\n    <Compile Include=\"TestExceptions.cs\" />\n    <Compile Include=\"TestFalseFillStateWithParams.cs\" />\n    <Compile Include=\"TestFillStateWithParams.cs\" />\n    <Compile Include=\"TestFunc.cs\" />\n    <Compile Include=\"TestFuncT.cs\" />\n    <Compile Include=\"TestGetResult.cs\" />\n    <Compile Include=\"TestMultipleWorkItems.cs\" />\n    <Compile Include=\"TestParallelMethods.cs\" />\n    <Compile Include=\"TestPostExecute.cs\" />\n    <Compile Include=\"TestPriorityQueue.cs\" />\n    <Compile Include=\"TestQueueWorkItem.cs\" />\n    <Compile Include=\"TestStartSuspended.cs\" />\n    <Compile Include=\"TestStateDispose.cs\" />\n    <Compile Include=\"TestThreadPriority.cs\" />\n    <Compile Include=\"TestThreadsCreate.cs\" />\n    <Compile Include=\"TestWaitForIdle.cs\" />\n    <Compile Include=\"TestWIGActionT.cs\" />\n    <Compile Include=\"TestWIGChainedDelegates.cs\" />\n    <Compile Include=\"TestWIGConcurrency.cs\" />\n    <Compile Include=\"TestWIGConcurrencyChanges.cs\" />\n    <Compile Include=\"TestWIGExceptions.cs\" />\n    <Compile Include=\"TestWIGFillStateWithParams.cs\" />\n    <Compile Include=\"TestWIGFuncT.cs\" />\n    <Compile Include=\"TestWIGGetResult.cs\" />\n    <Compile Include=\"TestWIGMultipleWorkItems.cs\" />\n    <Compile Include=\"TestWIGPostExecute.cs\" />\n    <Compile Include=\"TestWIGQueueWorkItem.cs\" />\n    <Compile Include=\"TestWIGStateDispose.cs\" />\n    <Compile Include=\"TestWIGWaitForIdle.cs\" />\n    <Compile Include=\"TestWorkItemsGroups.cs\" />\n    <Compile Include=\"TestWorkItemsQueue.cs\" />\n    <Compile Include=\"TestWorkItemTimeout.cs\" />\n    <None Include=\"Properties\\ControlSystem.cfg\" />\n  </ItemGroup>\n  <ItemGroup>\n    <ProjectReference Include=\"..\\SSharpSmartThreadPool\\SSharpSmartThreadPool.csproj\">\n      <Project>{06299ED2-056A-427C-8C84-D716197080EB}</Project>\n      <Name>SSharpSmartThreadPool</Name>\n    </ProjectReference>\n  </ItemGroup>\n  <Import Project=\"$(MSBuildBinPath)\\Microsoft.CompactFramework.CSharp.targets\" />\n  <ProjectExtensions>\n    <VisualStudio>\n      <FlavorProperties GUID=\"{0B4745B0-194B-4BB6-8E21-E9057CA92300}\">\n        <ProgramIdTag>SSharpSmartThreadPoolTests</ProgramIdTag>\n        <SystemName>SSharpSmartThreadPoolTests</SystemName>\n        <Programmer />\n        <ArchiveFilename>C:\\Projects\\Crestron\\Simpl# Pro Libraries\\SSharpSmartThreadPool\\SSharpSmartThreadPoolTests\\bin\\Debug\\SSharpSmartThreadPoolTests.cplz</ArchiveFilename>\n        <MinFirmwareVersion>1.009.0029</MinFirmwareVersion>\n        <CompiledOn>3/14/2015 11:00:21 AM</CompiledOn>\n        <AdditionalInfo />\n        <EmbedSourceArchive>False</EmbedSourceArchive>\n        <CopyTo />\n        <OriginalReferenceSources>\n          <Reference sourceFilename=\"../../SSharpNUnitLite3/SSharpNunitLite/bin/Release/SSharpNunitLite.dll\" referenceName=\"SSharpNunitLite\" />\n          <Reference sourceFilename=\"../../../Simpl%23%20Libraries/SSharpCrestronExtensionsLibrary/SSharpCrestronExtensionsLibrary/bin/Release/SSharpCrestronExtensionsLibrary.dll\" referenceName=\"SSharpCrestronExtensionsLibrary\" />\n        </OriginalReferenceSources>\n      </FlavorProperties>\n    </VisualStudio>\n  </ProjectExtensions>\n  <PropertyGroup>\n    <PostBuildEvent>rem S# Pro preparation will execute after these operations</PostBuildEvent>\n  </PropertyGroup>\n</Project>"], "filenames": ["SSharpSmartThreadPool/SSharpSmartThreadPool.csproj", "SSharpSmartThreadPool/SmartThreadPool.cs", "SSharpSmartThreadPoolTests/SSharpSmartThreadPoolTests.csproj"], "buggy_code_start_loc": [114, 1660, 144], "buggy_code_end_loc": [115, 1661, 151], "fixing_code_start_loc": [114, 1660, 144], "fixing_code_end_loc": [115, 1668, 148], "type": "CWE-362", "message": "A vulnerability was found in oznetmaster SSharpSmartThreadPool. It has been classified as problematic. This affects an unknown part of the file SSharpSmartThreadPool/SmartThreadPool.cs. The manipulation leads to race condition within a thread. The name of the patch is 0e58073c831093aad75e077962e9fb55cad0dc5f. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-218463.", "other": {"cve": {"id": "CVE-2015-10067", "sourceIdentifier": "cna@vuldb.com", "published": "2023-01-18T01:15:11.337", "lastModified": "2023-01-25T17:42:22.260", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "A vulnerability was found in oznetmaster SSharpSmartThreadPool. It has been classified as problematic. This affects an unknown part of the file SSharpSmartThreadPool/SmartThreadPool.cs. The manipulation leads to race condition within a thread. The name of the patch is 0e58073c831093aad75e077962e9fb55cad0dc5f. It is recommended to apply a patch to fix this issue. The associated identifier of this vulnerability is VDB-218463."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.1, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.2, "impactScore": 5.9}], "cvssMetricV30": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:A/AC:H/PR:L/UI:N/S:U/C:L/I:L/A:L", "attackVector": "ADJACENT_NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "LOW", "integrityImpact": "LOW", "availabilityImpact": "LOW", "baseScore": 4.6, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.2, "impactScore": 3.4}], "cvssMetricV2": [{"source": "cna@vuldb.com", "type": "Secondary", "cvssData": {"version": "2.0", "vectorString": "AV:A/AC:H/Au:S/C:P/I:P/A:P", "accessVector": "ADJACENT_NETWORK", "accessComplexity": "HIGH", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 4.0}, "baseSeverity": "MEDIUM", "exploitabilityScore": 2.5, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-362"}]}, {"source": "cna@vuldb.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-366"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:ssharpsmartthreadpool_project:ssharpsmartthreadpool:*:*:*:*:*:*:*:*", "versionEndExcluding": "2015-03-13", "matchCriteriaId": "585FB338-4B0B-435F-8589-66758B4F74FF"}]}]}], "references": [{"url": "https://github.com/oznetmaster/SSharpSmartThreadPool/commit/0e58073c831093aad75e077962e9fb55cad0dc5f", "source": "cna@vuldb.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://vuldb.com/?ctiid.218463", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}, {"url": "https://vuldb.com/?id.218463", "source": "cna@vuldb.com", "tags": ["Permissions Required", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/oznetmaster/SSharpSmartThreadPool/commit/0e58073c831093aad75e077962e9fb55cad0dc5f"}}