{"buggy_code": ["# -*- coding: utf-8 -*-\n'''\nSupport for the Git SCM\n'''\nfrom __future__ import absolute_import\n\n# Import python libs\nimport os\nimport subprocess\n\n# Import salt libs\nfrom salt import utils\nfrom salt.exceptions import SaltInvocationError, CommandExecutionError\nfrom salt.ext.six.moves.urllib.parse import urlparse as _urlparse  # pylint: disable=no-name-in-module,import-error\nfrom salt.ext.six.moves.urllib.parse import urlunparse as _urlunparse  # pylint: disable=no-name-in-module,import-error\n\n\ndef __virtual__():\n    '''\n    Only load if git exists on the system\n    '''\n    return True if utils.which('git') else False\n\n\ndef _git_run(cmd, cwd=None, runas=None, identity=None, **kwargs):\n    '''\n    simple, throw an exception with the error message on an error return code.\n\n    this function may be moved to the command module, spliced with\n    'cmd.run_all', and used as an alternative to 'cmd.run_all'. Some\n    commands don't return proper retcodes, so this can't replace 'cmd.run_all'.\n    '''\n    env = {}\n\n    if identity:\n        stderrs = []\n\n        # if the statefile provides multiple identities, they need to be tried\n        # (but also allow a string instead of a list)\n        if not isinstance(identity, list):\n            # force it into a list\n            identity = [identity]\n\n        # try each of the identities, independently\n        for id_file in identity:\n            env = {\n                'GIT_IDENTITY': id_file\n            }\n\n            # copy wrapper to area accessible by ``runas`` user\n            # currently no suppport in windows for wrapping git ssh\n            if not utils.is_windows():\n                ssh_id_wrapper = os.path.join(utils.templates.TEMPLATE_DIRNAME,\n                                              'git/ssh-id-wrapper')\n                tmp_file = utils.mkstemp()\n                utils.files.copyfile(ssh_id_wrapper, tmp_file)\n                os.chmod(tmp_file, 0o500)\n                os.chown(tmp_file, __salt__['file.user_to_uid'](runas), -1)\n                env['GIT_SSH'] = tmp_file\n\n            try:\n                result = __salt__['cmd.run_all'](cmd,\n                                                 cwd=cwd,\n                                                 runas=runas,\n                                                 env=env,\n                                                 python_shell=False,\n                                                 **kwargs)\n            finally:\n                if 'GIT_SSH' in env:\n                    os.remove(env['GIT_SSH'])\n\n            # if the command was successful, no need to try additional IDs\n            if result['retcode'] == 0:\n                return result['stdout']\n            else:\n                stderrs.append(result['stderr'])\n\n        # we've tried all IDs and still haven't passed, so error out\n        raise CommandExecutionError(\"\\n\\n\".join(stderrs))\n\n    else:\n        result = __salt__['cmd.run_all'](cmd,\n                                         cwd=cwd,\n                                         runas=runas,\n                                         env=env,\n                                         python_shell=False,\n                                         **kwargs)\n        retcode = result['retcode']\n\n        if retcode == 0:\n            return result['stdout']\n        else:\n            raise CommandExecutionError(\n                'Command {0!r} failed. Stderr: {1!r}'.format(cmd,\n                                                             result['stderr']))\n\n\ndef _git_getdir(cwd, user=None):\n    '''\n    Returns the absolute path to the top-level of a given repo because some Git\n    commands are sensitive to where they're run from (archive for one)\n    '''\n    cmd_bare = 'git rev-parse --is-bare-repository'\n    is_bare = __salt__['cmd.run_stdout'](cmd_bare, cwd, runas=user) == 'true'\n\n    if is_bare:\n        return cwd\n\n    cmd_toplvl = 'git rev-parse --show-toplevel'\n    return __salt__['cmd.run'](cmd_toplvl, cwd)\n\n\ndef _check_git():\n    '''\n    Check if git is available\n    '''\n    utils.check_or_die('git')\n\n\ndef _add_http_basic_auth(repository, https_user=None, https_pass=None):\n    if https_user is None and https_pass is None:\n        return repository\n    else:\n        urltuple = _urlparse(repository)\n        if urltuple.scheme == 'https':\n            if https_pass:\n                auth_string = \"{0}:{1}\".format(https_user, https_pass)\n            else:\n                auth_string = https_user\n            netloc = \"{0}@{1}\".format(auth_string, urltuple.netloc)\n            urltuple = urltuple._replace(netloc=netloc)\n            return _urlunparse(urltuple)\n        else:\n            raise ValueError('Basic Auth only supported for HTTPS scheme')\n\n\ndef current_branch(cwd, user=None):\n    '''\n    Returns the current branch name, if on a branch.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.current_branch /path/to/repo\n    '''\n    cmd = r'git rev-parse --abbrev-ref HEAD'\n\n    return __salt__['cmd.run_stdout'](cmd, cwd=cwd, runas=user)\n\n\ndef revision(cwd, rev='HEAD', short=False, user=None):\n    '''\n    Returns the long hash of a given identifier (hash, branch, tag, HEAD, etc)\n\n    cwd\n        The path to the Git repository\n\n    rev: HEAD\n        The revision\n\n    short: False\n        Return an abbreviated SHA1 git hash\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.revision /path/to/repo mybranch\n    '''\n    _check_git()\n\n    cmd = 'git rev-parse {0}{1}'.format('--short ' if short else '', rev)\n    return _git_run(cmd, cwd, runas=user)\n\n\ndef clone(cwd, repository, opts=None, user=None, identity=None,\n          https_user=None, https_pass=None):\n    '''\n    Clone a new repository\n\n    cwd\n        The path to the Git repository\n\n    repository\n        The git URI of the repository\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    identity : None\n        A path to a private key to use over SSH\n\n    https_user : None\n        HTTP Basic Auth username for HTTPS (only) clones\n\n        .. versionadded:: 20515.5.0\n\n    https_pass : None\n        HTTP Basic Auth password for HTTPS (only) clones\n\n        .. versionadded:: 2015.5.0\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.clone /path/to/repo git://github.com/saltstack/salt.git\n\n        salt '*' git.clone /path/to/repo.git\\\\\n                git://github.com/saltstack/salt.git '--bare --origin github'\n\n    '''\n    _check_git()\n\n    repository = _add_http_basic_auth(repository, https_user, https_pass)\n\n    if not opts:\n        opts = ''\n    if utils.is_windows():\n        cmd = 'git clone {0} {1} {2}'.format(repository, cwd, opts)\n    else:\n        cmd = 'git clone {0} {1!r} {2}'.format(repository, cwd, opts)\n\n    return _git_run(cmd, runas=user, identity=identity)\n\n\ndef describe(cwd, rev='HEAD', user=None):\n    '''\n    Returns the git describe string (or the SHA hash if there are no tags) for\n    the given revision\n\n    cwd\n        The path to the Git repository\n\n    rev: HEAD\n        The revision to describe\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt '*' git.describe /path/to/repo\n\n        salt '*' git.describe /path/to/repo develop\n    '''\n    cmd = 'git describe {0}'.format(rev)\n    return __salt__['cmd.run_stdout'](cmd,\n                                      cwd=cwd,\n                                      runas=user,\n                                      python_shell=False)\n\n\ndef archive(cwd, output, rev='HEAD', fmt=None, prefix=None, user=None):\n    '''\n    Export a tarball from the repository\n\n    cwd\n        The path to the Git repository\n\n    output\n        The path to the archive tarball\n\n    rev: HEAD\n        The revision to create an archive from\n\n    fmt: None\n        Format of the resulting archive, zip and tar are commonly used\n\n    prefix : None\n        Prepend <prefix>/ to every filename in the archive\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    If ``prefix`` is not specified it defaults to the basename of the repo\n    directory.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.archive /path/to/repo /path/to/archive.tar.gz\n    '''\n    _check_git()\n\n    basename = '{0}/'.format(os.path.basename(_git_getdir(cwd, user=user)))\n\n    cmd = 'git archive{prefix}{fmt} -o {output} {rev}'.format(\n            rev=rev,\n            output=output,\n            fmt=' --format={0}'.format(fmt) if fmt else '',\n            prefix=' --prefix=\"{0}\"'.format(prefix if prefix else basename)\n    )\n\n    return _git_run(cmd, cwd=cwd, runas=user)\n\n\ndef fetch(cwd, opts=None, user=None, identity=None):\n    '''\n    Perform a fetch on the given repository\n\n    cwd\n        The path to the Git repository\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    identity : None\n        A path to a private key to use over SSH\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.fetch /path/to/repo '--all'\n\n        salt '*' git.fetch cwd=/path/to/repo opts='--all' user=johnny\n    '''\n    _check_git()\n\n    if not opts:\n        opts = ''\n    cmd = 'git fetch {0}'.format(opts)\n\n    return _git_run(cmd, cwd=cwd, runas=user, identity=identity)\n\n\ndef pull(cwd, opts=None, user=None, identity=None):\n    '''\n    Perform a pull on the given repository\n\n    cwd\n        The path to the Git repository\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    identity : None\n        A path to a private key to use over SSH\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.pull /path/to/repo opts='--rebase origin master'\n    '''\n    _check_git()\n\n    if not opts:\n        opts = ''\n    return _git_run('git pull {0}'.format(opts),\n                    cwd=cwd,\n                    runas=user,\n                    identity=identity)\n\n\ndef rebase(cwd, rev='master', opts=None, user=None):\n    '''\n    Rebase the current branch\n\n    cwd\n        The path to the Git repository\n\n    rev : master\n        The revision to rebase onto the current branch\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.rebase /path/to/repo master\n        salt '*' git.rebase /path/to/repo 'origin master'\n\n    That is the same as:\n\n    .. code-block:: bash\n\n        git rebase master\n        git rebase origin master\n    '''\n    _check_git()\n\n    if not opts:\n        opts = ''\n    return _git_run('git rebase {0} {1}'.format(opts, rev),\n                    cwd=cwd,\n                    runas=user)\n\n\ndef checkout(cwd, rev, force=False, opts=None, user=None):\n    '''\n    Checkout a given revision\n\n    cwd\n        The path to the Git repository\n\n    rev\n        The remote branch or revision to checkout\n\n    force : False\n        Force a checkout even if there might be overwritten changes\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt '*' git.checkout /path/to/repo somebranch user=jeff\n\n        salt '*' git.checkout /path/to/repo opts='testbranch -- conf/file1 file2'\n\n        salt '*' git.checkout /path/to/repo rev=origin/mybranch opts=--track\n    '''\n    _check_git()\n\n    if not opts:\n        opts = ''\n    cmd = 'git checkout {0} {1} {2}'.format(' -f' if force else '', rev, opts)\n    return _git_run(cmd, cwd=cwd, runas=user)\n\n\ndef merge(cwd, branch='@{upstream}', opts=None, user=None):\n    '''\n    Merge a given branch\n\n    cwd\n        The path to the Git repository\n\n    branch : @{upstream}\n        The remote branch or revision to merge into the current branch\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.fetch /path/to/repo\n        salt '*' git.merge /path/to/repo @{upstream}\n    '''\n    _check_git()\n\n    if not opts:\n        opts = ''\n    cmd = 'git merge {0} {1}'.format(branch,\n                                     opts)\n\n    return _git_run(cmd, cwd, runas=user)\n\n\ndef init(cwd, opts=None, user=None):\n    '''\n    Initialize a new git repository\n\n    cwd\n        The path to the Git repository\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.init /path/to/repo.git opts='--bare'\n    '''\n    _check_git()\n    if not opts:\n        opts = ''\n    cmd = 'git init {0} {1}'.format(cwd, opts)\n    return _git_run(cmd, runas=user)\n\n\ndef submodule(cwd, init=True, opts=None, user=None, identity=None):\n    '''\n    Initialize git submodules\n\n    cwd\n        The path to the Git repository\n\n    init : True\n        Ensure that new submodules are initialized\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    identity : None\n        A path to a private key to use over SSH\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.submodule /path/to/repo.git/sub/repo\n    '''\n    _check_git()\n\n    if not opts:\n        opts = ''\n    cmd = 'git submodule update {0} {1}'.format('--init' if init else '', opts)\n    return _git_run(cmd, cwd=cwd, runas=user, identity=identity)\n\n\ndef status(cwd, user=None):\n    '''\n    Return the status of the repository. The returned format uses the status\n    codes of git's 'porcelain' output mode\n\n    cwd\n        The path to the Git repository\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.status /path/to/git/repo\n    '''\n    cmd = 'git status -z --porcelain'\n    stdout = _git_run(cmd, cwd=cwd, runas=user)\n    state_by_file = []\n    for line in stdout.split(\"\\0\"):\n        state = line[:2]\n        filename = line[3:]\n        if filename != '' and state != '':\n            state_by_file.append((state, filename))\n    return state_by_file\n\n\ndef add(cwd, file_name, user=None, opts=None):\n    '''\n    add a file to git\n\n    cwd\n        The path to the Git repository\n\n    file_name\n        Path to the file in the cwd\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.add /path/to/git/repo /path/to/file\n\n    '''\n\n    if not opts:\n        opts = ''\n    cmd = 'git add {0} {1}'.format(file_name, opts)\n    return _git_run(cmd, cwd=cwd, runas=user)\n\n\ndef rm(cwd, file_name, user=None, opts=None):\n    '''\n    Remove a file from git\n\n    cwd\n        The path to the Git repository\n\n    file_name\n        Path to the file in the cwd\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.rm /path/to/git/repo /path/to/file\n    '''\n\n    if not opts:\n        opts = ''\n    cmd = 'git rm {0} {1}'.format(file_name, opts)\n    return _git_run(cmd, cwd=cwd, runas=user)\n\n\ndef commit(cwd, message, user=None, opts=None):\n    '''\n    create a commit\n\n    cwd\n        The path to the Git repository\n\n    message\n        The commit message\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.commit /path/to/git/repo 'The commit message'\n    '''\n\n    cmd = subprocess.list2cmdline(['git', 'commit', '-m', message])\n    # add opts separately; they don't need to be quoted\n    if opts:\n        cmd = cmd + ' ' + opts\n    return _git_run(cmd, cwd=cwd, runas=user)\n\n\ndef push(cwd, remote_name, branch='master', user=None, opts=None,\n         identity=None):\n    '''\n    Push to remote\n\n    cwd\n        The path to the Git repository\n\n    remote_name\n        Name of the remote to push to\n\n    branch : master\n        Name of the branch to push\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    identity : None\n        A path to a private key to use over SSH\n\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.push /path/to/git/repo remote-name\n    '''\n\n    if not opts:\n        opts = ''\n    cmd = 'git push {0} {1} {2}'.format(remote_name, branch, opts)\n    return _git_run(cmd, cwd=cwd, runas=user, identity=identity)\n\n\ndef remotes(cwd, user=None):\n    '''\n    Get remotes like git remote -v\n\n    cwd\n        The path to the Git repository\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.remotes /path/to/repo\n    '''\n    cmd = 'git remote'\n    ret = _git_run(cmd, cwd=cwd, runas=user)\n    res = dict()\n    for remote_name in ret.splitlines():\n        remote = remote_name.strip()\n        res[remote] = remote_get(cwd, remote, user=user)\n    return res\n\n\ndef remote_get(cwd, remote='origin', user=None):\n    '''\n    get the fetch and push URL for a specified remote name\n\n    remote : origin\n        the remote name used to define the fetch and push URL\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.remote_get /path/to/repo\n        salt '*' git.remote_get /path/to/repo upstream\n    '''\n    try:\n        cmd = 'git remote show -n {0}'.format(remote)\n        ret = _git_run(cmd, cwd=cwd, runas=user)\n        lines = ret.splitlines()\n        remote_fetch_url = lines[1].replace('Fetch URL: ', '').strip()\n        remote_push_url = lines[2].replace('Push  URL: ', '').strip()\n        if remote_fetch_url != remote and remote_push_url != remote:\n            res = (remote_fetch_url, remote_push_url)\n            return res\n        else:\n            return None\n    except CommandExecutionError:\n        return None\n\n\ndef remote_set(cwd, name='origin', url=None, user=None, https_user=None,\n               https_pass=None):\n    '''\n    sets a remote with name and URL like git remote add <remote_name> <remote_url>\n\n    remote_name : origin\n        defines the remote name\n\n    remote_url : None\n        defines the remote URL; should not be None!\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    https_user : None\n        HTTP Basic Auth username for HTTPS (only) clones\n\n        .. versionadded:: 2015.5.0\n\n    https_pass : None\n        HTTP Basic Auth password for HTTPS (only) clones\n\n        .. versionadded:: 2015.5.0\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.remote_set /path/to/repo remote_url=git@github.com:saltstack/salt.git\n        salt '*' git.remote_set /path/to/repo origin git@github.com:saltstack/salt.git\n    '''\n    if remote_get(cwd, name):\n        cmd = 'git remote rm {0}'.format(name)\n        _git_run(cmd, cwd=cwd, runas=user)\n    url = _add_http_basic_auth(url, https_user, https_pass)\n    cmd = 'git remote add {0} {1}'.format(name, url)\n    _git_run(cmd, cwd=cwd, runas=user)\n    return remote_get(cwd=cwd, remote=name, user=None)\n\n\ndef branch(cwd, rev, opts=None, user=None):\n    '''\n    Interacts with branches.\n\n    cwd\n        The path to the Git repository\n\n    rev\n        The branch/revision to be used in the command.\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.branch mybranch --set-upstream-to=origin/mybranch\n    '''\n    cmd = 'git branch {0} {1}'.format(rev, opts)\n    _git_run(cmd, cwd=cwd, user=user)\n    return current_branch(cwd, user=user)\n\n\ndef reset(cwd, opts=None, user=None):\n    '''\n    Reset the repository checkout\n\n    cwd\n        The path to the Git repository\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.reset /path/to/repo master\n    '''\n    _check_git()\n\n    if not opts:\n        opts = ''\n    return _git_run('git reset {0}'.format(opts), cwd=cwd, runas=user)\n\n\ndef stash(cwd, opts=None, user=None):\n    '''\n    Stash changes in the repository checkout\n\n    cwd\n        The path to the Git repository\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.stash /path/to/repo master\n    '''\n    _check_git()\n\n    if not opts:\n        opts = ''\n    return _git_run('git stash {0}'.format(opts), cwd=cwd, runas=user)\n\n\ndef config_set(cwd=None, setting_name=None, setting_value=None, user=None, is_global=False):\n    '''\n    Set a key in the git configuration file (.git/config) of the repository or\n    globally.\n\n    cwd : None\n        Options path to the Git repository\n\n        .. versionchanged:: 2014.7.0\n            Made ``cwd`` optional\n\n    setting_name : None\n        The name of the configuration key to set. Required.\n\n    setting_value : None\n        The (new) value to set. Required.\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    is_global : False\n        Set to True to use the '--global' flag with 'git config'\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.config_set /path/to/repo user.email me@example.com\n    '''\n    if setting_name is None or setting_value is None:\n        raise TypeError('Missing required parameter setting_name for git.config_set')\n    if cwd is None and not is_global:\n        raise SaltInvocationError('Either `is_global` must be set to True or '\n                                  'you must provide `cwd`')\n\n    if is_global:\n        cmd = 'git config --global {0} \"{1}\"'.format(setting_name, setting_value)\n    else:\n        cmd = 'git config {0} \"{1}\"'.format(setting_name, setting_value)\n\n    _check_git()\n\n    return _git_run(cmd, cwd=cwd, runas=user)\n\n\ndef config_get(cwd=None, setting_name=None, user=None):\n    '''\n    Get a key or keys from the git configuration file (.git/config).\n\n    cwd : None\n        Optional path to a Git repository\n\n        .. versionchanged:: 2014.7.0\n            Made ``cwd`` optional\n\n    setting_name : None\n        The name of the configuration key to get. Required.\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.config_get setting_name=user.email\n        salt '*' git.config_get /path/to/repo user.name arthur\n    '''\n    if setting_name is None:\n        raise TypeError('Missing required parameter setting_name for git.config_get')\n    _check_git()\n\n    return _git_run('git config {0}'.format(setting_name), cwd=cwd, runas=user)\n\n\ndef ls_remote(cwd, repository=\"origin\", branch=\"master\", user=None,\n              identity=None, https_user=None, https_pass=None):\n    '''\n    Returns the upstream hash for any given URL and branch.\n\n    cwd\n        The path to the Git repository\n\n    repository: origin\n        The name of the repository to get the revision from. Can be the name of\n        a remote, an URL, etc.\n\n    branch: master\n        The name of the branch to get the revision from.\n\n    user : none\n        run git as a user other than what the minion runs as\n\n    identity : none\n        a path to a private key to use over ssh\n\n    https_user : None\n        HTTP Basic Auth username for HTTPS (only) clones\n\n        .. versionadded:: 2015.5.0\n\n    https_pass : None\n        HTTP Basic Auth password for HTTPS (only) clones\n\n        .. versionadded:: 2015.5.0\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.ls_remote /pat/to/repo origin master\n\n    '''\n    _check_git()\n    repository = _add_http_basic_auth(repository, https_user, https_pass)\n    cmd = ' '.join([\"git\", \"ls-remote\", \"-h\", str(repository), str(branch), \"| cut -f 1\"])\n    return _git_run(cmd, cwd=cwd, runas=user, identity=identity)\n", "# -*- coding: utf-8 -*-\n'''\n    :codeauthor: :email:`Tarjei Hus\u00f8y <git@thusoy.com>`\n'''\n\n# Import Salt Testing Libs\nfrom salttesting import TestCase\nfrom salttesting.helpers import ensure_in_syspath\n\nensure_in_syspath('../../')\n\n# Import Salt Libs\nfrom salt.modules import git\n\n\nclass GitTestCase(TestCase):\n    '''\n    TestCase for salt.modules.git module\n    '''\n\n    def test_http_basic_authentication(self):\n        '''\n            Test that HTTP Basic auth works as intended.\n        '''\n        # ((user, pass), expected) tuples\n        test_inputs = [\n            ((None, None), 'https://example.com'),\n            (('user', None), 'https://user@example.com'),\n            (('user', 'pass'), 'https://user:pass@example.com'),\n        ]\n        for (user, password), expected in test_inputs:\n            kwargs = {\n                'https_user': user,\n                'https_pass': password,\n                'repository': 'https://example.com',\n            }\n            result = git._add_http_basic_auth(**kwargs)\n            self.assertEqual(result, expected)\n\n\nif __name__ == '__main__':\n    from integration import run_tests\n    run_tests(GitTestCase, needs_daemon=False)\n"], "fixing_code": ["# -*- coding: utf-8 -*-\n'''\nSupport for the Git SCM\n'''\nfrom __future__ import absolute_import\n\n# Import python libs\nimport os\nimport re\nimport subprocess\n\n# Import salt libs\nfrom salt import utils\nfrom salt.exceptions import SaltInvocationError, CommandExecutionError\nfrom salt.ext.six.moves.urllib.parse import urlparse as _urlparse  # pylint: disable=no-name-in-module,import-error\nfrom salt.ext.six.moves.urllib.parse import urlunparse as _urlunparse  # pylint: disable=no-name-in-module,import-error\n\n\ndef __virtual__():\n    '''\n    Only load if git exists on the system\n    '''\n    return True if utils.which('git') else False\n\n\ndef _git_run(cmd, cwd=None, runas=None, identity=None, **kwargs):\n    '''\n    simple, throw an exception with the error message on an error return code.\n\n    this function may be moved to the command module, spliced with\n    'cmd.run_all', and used as an alternative to 'cmd.run_all'. Some\n    commands don't return proper retcodes, so this can't replace 'cmd.run_all'.\n    '''\n    env = {}\n\n    if identity:\n        stderrs = []\n\n        # if the statefile provides multiple identities, they need to be tried\n        # (but also allow a string instead of a list)\n        if not isinstance(identity, list):\n            # force it into a list\n            identity = [identity]\n\n        # try each of the identities, independently\n        for id_file in identity:\n            env = {\n                'GIT_IDENTITY': id_file\n            }\n\n            # copy wrapper to area accessible by ``runas`` user\n            # currently no suppport in windows for wrapping git ssh\n            if not utils.is_windows():\n                ssh_id_wrapper = os.path.join(utils.templates.TEMPLATE_DIRNAME,\n                                              'git/ssh-id-wrapper')\n                tmp_file = utils.mkstemp()\n                utils.files.copyfile(ssh_id_wrapper, tmp_file)\n                os.chmod(tmp_file, 0o500)\n                os.chown(tmp_file, __salt__['file.user_to_uid'](runas), -1)\n                env['GIT_SSH'] = tmp_file\n\n            try:\n                result = __salt__['cmd.run_all'](cmd,\n                                                 cwd=cwd,\n                                                 runas=runas,\n                                                 output_loglevel='quiet',\n                                                 env=env,\n                                                 python_shell=False,\n                                                 **kwargs)\n            finally:\n                if 'GIT_SSH' in env:\n                    os.remove(env['GIT_SSH'])\n\n            # if the command was successful, no need to try additional IDs\n            if result['retcode'] == 0:\n                return result['stdout']\n            else:\n                stderr = _remove_sensitive_data(result['stderr'])\n                stderrs.append(stderr)\n\n        # we've tried all IDs and still haven't passed, so error out\n        raise CommandExecutionError(\"\\n\\n\".join(stderrs))\n\n    else:\n        result = __salt__['cmd.run_all'](cmd,\n                                         cwd=cwd,\n                                         runas=runas,\n                                         output_loglevel='quiet',\n                                         env=env,\n                                         python_shell=False,\n                                         **kwargs)\n        retcode = result['retcode']\n\n        if retcode == 0:\n            return result['stdout']\n        else:\n            stderr = _remove_sensitive_data(result['stderr'])\n            raise CommandExecutionError(\n                'Command {0!r} failed. Stderr: {1!r}'.format(cmd, stderr))\n\n\ndef _remove_sensitive_data(sensitive_output):\n    '''\n        Remove HTTP user and password.\n    '''\n    return re.sub('(https?)://.*@', r'\\1://<redacted>@', sensitive_output)\n\n\ndef _git_getdir(cwd, user=None):\n    '''\n    Returns the absolute path to the top-level of a given repo because some Git\n    commands are sensitive to where they're run from (archive for one)\n    '''\n    cmd_bare = 'git rev-parse --is-bare-repository'\n    is_bare = __salt__['cmd.run_stdout'](cmd_bare, cwd, runas=user) == 'true'\n\n    if is_bare:\n        return cwd\n\n    cmd_toplvl = 'git rev-parse --show-toplevel'\n    return __salt__['cmd.run'](cmd_toplvl, cwd)\n\n\ndef _check_git():\n    '''\n    Check if git is available\n    '''\n    utils.check_or_die('git')\n\n\ndef _add_http_basic_auth(repository, https_user=None, https_pass=None):\n    if https_user is None and https_pass is None:\n        return repository\n    else:\n        urltuple = _urlparse(repository)\n        if urltuple.scheme == 'https':\n            if https_pass:\n                auth_string = \"{0}:{1}\".format(https_user, https_pass)\n            else:\n                auth_string = https_user\n            netloc = \"{0}@{1}\".format(auth_string, urltuple.netloc)\n            urltuple = urltuple._replace(netloc=netloc)\n            return _urlunparse(urltuple)\n        else:\n            raise ValueError('Basic Auth only supported for HTTPS scheme')\n\n\ndef current_branch(cwd, user=None):\n    '''\n    Returns the current branch name, if on a branch.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.current_branch /path/to/repo\n    '''\n    cmd = r'git rev-parse --abbrev-ref HEAD'\n\n    return __salt__['cmd.run_stdout'](cmd, cwd=cwd, runas=user)\n\n\ndef revision(cwd, rev='HEAD', short=False, user=None):\n    '''\n    Returns the long hash of a given identifier (hash, branch, tag, HEAD, etc)\n\n    cwd\n        The path to the Git repository\n\n    rev: HEAD\n        The revision\n\n    short: False\n        Return an abbreviated SHA1 git hash\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.revision /path/to/repo mybranch\n    '''\n    _check_git()\n\n    cmd = 'git rev-parse {0}{1}'.format('--short ' if short else '', rev)\n    return _git_run(cmd, cwd, runas=user)\n\n\ndef clone(cwd, repository, opts=None, user=None, identity=None,\n          https_user=None, https_pass=None):\n    '''\n    Clone a new repository\n\n    cwd\n        The path to the Git repository\n\n    repository\n        The git URI of the repository\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    identity : None\n        A path to a private key to use over SSH\n\n    https_user : None\n        HTTP Basic Auth username for HTTPS (only) clones\n\n        .. versionadded:: 20515.5.0\n\n    https_pass : None\n        HTTP Basic Auth password for HTTPS (only) clones\n\n        .. versionadded:: 2015.5.0\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.clone /path/to/repo git://github.com/saltstack/salt.git\n\n        salt '*' git.clone /path/to/repo.git\\\\\n                git://github.com/saltstack/salt.git '--bare --origin github'\n\n    '''\n    _check_git()\n\n    repository = _add_http_basic_auth(repository, https_user, https_pass)\n\n    if not opts:\n        opts = ''\n    if utils.is_windows():\n        cmd = 'git clone {0} {1} {2}'.format(repository, cwd, opts)\n    else:\n        cmd = 'git clone {0} {1!r} {2}'.format(repository, cwd, opts)\n\n    return _git_run(cmd, runas=user, identity=identity)\n\n\ndef describe(cwd, rev='HEAD', user=None):\n    '''\n    Returns the git describe string (or the SHA hash if there are no tags) for\n    the given revision\n\n    cwd\n        The path to the Git repository\n\n    rev: HEAD\n        The revision to describe\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt '*' git.describe /path/to/repo\n\n        salt '*' git.describe /path/to/repo develop\n    '''\n    cmd = 'git describe {0}'.format(rev)\n    return __salt__['cmd.run_stdout'](cmd,\n                                      cwd=cwd,\n                                      runas=user,\n                                      python_shell=False)\n\n\ndef archive(cwd, output, rev='HEAD', fmt=None, prefix=None, user=None):\n    '''\n    Export a tarball from the repository\n\n    cwd\n        The path to the Git repository\n\n    output\n        The path to the archive tarball\n\n    rev: HEAD\n        The revision to create an archive from\n\n    fmt: None\n        Format of the resulting archive, zip and tar are commonly used\n\n    prefix : None\n        Prepend <prefix>/ to every filename in the archive\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    If ``prefix`` is not specified it defaults to the basename of the repo\n    directory.\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.archive /path/to/repo /path/to/archive.tar.gz\n    '''\n    _check_git()\n\n    basename = '{0}/'.format(os.path.basename(_git_getdir(cwd, user=user)))\n\n    cmd = 'git archive{prefix}{fmt} -o {output} {rev}'.format(\n            rev=rev,\n            output=output,\n            fmt=' --format={0}'.format(fmt) if fmt else '',\n            prefix=' --prefix=\"{0}\"'.format(prefix if prefix else basename)\n    )\n\n    return _git_run(cmd, cwd=cwd, runas=user)\n\n\ndef fetch(cwd, opts=None, user=None, identity=None):\n    '''\n    Perform a fetch on the given repository\n\n    cwd\n        The path to the Git repository\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    identity : None\n        A path to a private key to use over SSH\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.fetch /path/to/repo '--all'\n\n        salt '*' git.fetch cwd=/path/to/repo opts='--all' user=johnny\n    '''\n    _check_git()\n\n    if not opts:\n        opts = ''\n    cmd = 'git fetch {0}'.format(opts)\n\n    return _git_run(cmd, cwd=cwd, runas=user, identity=identity)\n\n\ndef pull(cwd, opts=None, user=None, identity=None):\n    '''\n    Perform a pull on the given repository\n\n    cwd\n        The path to the Git repository\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    identity : None\n        A path to a private key to use over SSH\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.pull /path/to/repo opts='--rebase origin master'\n    '''\n    _check_git()\n\n    if not opts:\n        opts = ''\n    return _git_run('git pull {0}'.format(opts),\n                    cwd=cwd,\n                    runas=user,\n                    identity=identity)\n\n\ndef rebase(cwd, rev='master', opts=None, user=None):\n    '''\n    Rebase the current branch\n\n    cwd\n        The path to the Git repository\n\n    rev : master\n        The revision to rebase onto the current branch\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.rebase /path/to/repo master\n        salt '*' git.rebase /path/to/repo 'origin master'\n\n    That is the same as:\n\n    .. code-block:: bash\n\n        git rebase master\n        git rebase origin master\n    '''\n    _check_git()\n\n    if not opts:\n        opts = ''\n    return _git_run('git rebase {0} {1}'.format(opts, rev),\n                    cwd=cwd,\n                    runas=user)\n\n\ndef checkout(cwd, rev, force=False, opts=None, user=None):\n    '''\n    Checkout a given revision\n\n    cwd\n        The path to the Git repository\n\n    rev\n        The remote branch or revision to checkout\n\n    force : False\n        Force a checkout even if there might be overwritten changes\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Examples:\n\n    .. code-block:: bash\n\n        salt '*' git.checkout /path/to/repo somebranch user=jeff\n\n        salt '*' git.checkout /path/to/repo opts='testbranch -- conf/file1 file2'\n\n        salt '*' git.checkout /path/to/repo rev=origin/mybranch opts=--track\n    '''\n    _check_git()\n\n    if not opts:\n        opts = ''\n    cmd = 'git checkout {0} {1} {2}'.format(' -f' if force else '', rev, opts)\n    return _git_run(cmd, cwd=cwd, runas=user)\n\n\ndef merge(cwd, branch='@{upstream}', opts=None, user=None):\n    '''\n    Merge a given branch\n\n    cwd\n        The path to the Git repository\n\n    branch : @{upstream}\n        The remote branch or revision to merge into the current branch\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.fetch /path/to/repo\n        salt '*' git.merge /path/to/repo @{upstream}\n    '''\n    _check_git()\n\n    if not opts:\n        opts = ''\n    cmd = 'git merge {0} {1}'.format(branch,\n                                     opts)\n\n    return _git_run(cmd, cwd, runas=user)\n\n\ndef init(cwd, opts=None, user=None):\n    '''\n    Initialize a new git repository\n\n    cwd\n        The path to the Git repository\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.init /path/to/repo.git opts='--bare'\n    '''\n    _check_git()\n    if not opts:\n        opts = ''\n    cmd = 'git init {0} {1}'.format(cwd, opts)\n    return _git_run(cmd, runas=user)\n\n\ndef submodule(cwd, init=True, opts=None, user=None, identity=None):\n    '''\n    Initialize git submodules\n\n    cwd\n        The path to the Git repository\n\n    init : True\n        Ensure that new submodules are initialized\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    identity : None\n        A path to a private key to use over SSH\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.submodule /path/to/repo.git/sub/repo\n    '''\n    _check_git()\n\n    if not opts:\n        opts = ''\n    cmd = 'git submodule update {0} {1}'.format('--init' if init else '', opts)\n    return _git_run(cmd, cwd=cwd, runas=user, identity=identity)\n\n\ndef status(cwd, user=None):\n    '''\n    Return the status of the repository. The returned format uses the status\n    codes of git's 'porcelain' output mode\n\n    cwd\n        The path to the Git repository\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.status /path/to/git/repo\n    '''\n    cmd = 'git status -z --porcelain'\n    stdout = _git_run(cmd, cwd=cwd, runas=user)\n    state_by_file = []\n    for line in stdout.split(\"\\0\"):\n        state = line[:2]\n        filename = line[3:]\n        if filename != '' and state != '':\n            state_by_file.append((state, filename))\n    return state_by_file\n\n\ndef add(cwd, file_name, user=None, opts=None):\n    '''\n    add a file to git\n\n    cwd\n        The path to the Git repository\n\n    file_name\n        Path to the file in the cwd\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.add /path/to/git/repo /path/to/file\n\n    '''\n\n    if not opts:\n        opts = ''\n    cmd = 'git add {0} {1}'.format(file_name, opts)\n    return _git_run(cmd, cwd=cwd, runas=user)\n\n\ndef rm(cwd, file_name, user=None, opts=None):\n    '''\n    Remove a file from git\n\n    cwd\n        The path to the Git repository\n\n    file_name\n        Path to the file in the cwd\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.rm /path/to/git/repo /path/to/file\n    '''\n\n    if not opts:\n        opts = ''\n    cmd = 'git rm {0} {1}'.format(file_name, opts)\n    return _git_run(cmd, cwd=cwd, runas=user)\n\n\ndef commit(cwd, message, user=None, opts=None):\n    '''\n    create a commit\n\n    cwd\n        The path to the Git repository\n\n    message\n        The commit message\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.commit /path/to/git/repo 'The commit message'\n    '''\n\n    cmd = subprocess.list2cmdline(['git', 'commit', '-m', message])\n    # add opts separately; they don't need to be quoted\n    if opts:\n        cmd = cmd + ' ' + opts\n    return _git_run(cmd, cwd=cwd, runas=user)\n\n\ndef push(cwd, remote_name, branch='master', user=None, opts=None,\n         identity=None):\n    '''\n    Push to remote\n\n    cwd\n        The path to the Git repository\n\n    remote_name\n        Name of the remote to push to\n\n    branch : master\n        Name of the branch to push\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    identity : None\n        A path to a private key to use over SSH\n\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.push /path/to/git/repo remote-name\n    '''\n\n    if not opts:\n        opts = ''\n    cmd = 'git push {0} {1} {2}'.format(remote_name, branch, opts)\n    return _git_run(cmd, cwd=cwd, runas=user, identity=identity)\n\n\ndef remotes(cwd, user=None):\n    '''\n    Get remotes like git remote -v\n\n    cwd\n        The path to the Git repository\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.remotes /path/to/repo\n    '''\n    cmd = 'git remote'\n    ret = _git_run(cmd, cwd=cwd, runas=user)\n    res = dict()\n    for remote_name in ret.splitlines():\n        remote = remote_name.strip()\n        res[remote] = remote_get(cwd, remote, user=user)\n    return res\n\n\ndef remote_get(cwd, remote='origin', user=None):\n    '''\n    get the fetch and push URL for a specified remote name\n\n    remote : origin\n        the remote name used to define the fetch and push URL\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.remote_get /path/to/repo\n        salt '*' git.remote_get /path/to/repo upstream\n    '''\n    try:\n        cmd = 'git remote show -n {0}'.format(remote)\n        ret = _git_run(cmd, cwd=cwd, runas=user)\n        lines = ret.splitlines()\n        remote_fetch_url = lines[1].replace('Fetch URL: ', '').strip()\n        remote_push_url = lines[2].replace('Push  URL: ', '').strip()\n        if remote_fetch_url != remote and remote_push_url != remote:\n            res = (remote_fetch_url, remote_push_url)\n            return res\n        else:\n            return None\n    except CommandExecutionError:\n        return None\n\n\ndef remote_set(cwd, name='origin', url=None, user=None, https_user=None,\n               https_pass=None):\n    '''\n    sets a remote with name and URL like git remote add <remote_name> <remote_url>\n\n    remote_name : origin\n        defines the remote name\n\n    remote_url : None\n        defines the remote URL; should not be None!\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    https_user : None\n        HTTP Basic Auth username for HTTPS (only) clones\n\n        .. versionadded:: 2015.5.0\n\n    https_pass : None\n        HTTP Basic Auth password for HTTPS (only) clones\n\n        .. versionadded:: 2015.5.0\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.remote_set /path/to/repo remote_url=git@github.com:saltstack/salt.git\n        salt '*' git.remote_set /path/to/repo origin git@github.com:saltstack/salt.git\n    '''\n    if remote_get(cwd, name):\n        cmd = 'git remote rm {0}'.format(name)\n        _git_run(cmd, cwd=cwd, runas=user)\n    url = _add_http_basic_auth(url, https_user, https_pass)\n    cmd = 'git remote add {0} {1}'.format(name, url)\n    _git_run(cmd, cwd=cwd, runas=user)\n    return remote_get(cwd=cwd, remote=name, user=None)\n\n\ndef branch(cwd, rev, opts=None, user=None):\n    '''\n    Interacts with branches.\n\n    cwd\n        The path to the Git repository\n\n    rev\n        The branch/revision to be used in the command.\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.branch mybranch --set-upstream-to=origin/mybranch\n    '''\n    cmd = 'git branch {0} {1}'.format(rev, opts)\n    _git_run(cmd, cwd=cwd, user=user)\n    return current_branch(cwd, user=user)\n\n\ndef reset(cwd, opts=None, user=None):\n    '''\n    Reset the repository checkout\n\n    cwd\n        The path to the Git repository\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.reset /path/to/repo master\n    '''\n    _check_git()\n\n    if not opts:\n        opts = ''\n    return _git_run('git reset {0}'.format(opts), cwd=cwd, runas=user)\n\n\ndef stash(cwd, opts=None, user=None):\n    '''\n    Stash changes in the repository checkout\n\n    cwd\n        The path to the Git repository\n\n    opts : None\n        Any additional options to add to the command line\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.stash /path/to/repo master\n    '''\n    _check_git()\n\n    if not opts:\n        opts = ''\n    return _git_run('git stash {0}'.format(opts), cwd=cwd, runas=user)\n\n\ndef config_set(cwd=None, setting_name=None, setting_value=None, user=None, is_global=False):\n    '''\n    Set a key in the git configuration file (.git/config) of the repository or\n    globally.\n\n    cwd : None\n        Options path to the Git repository\n\n        .. versionchanged:: 2014.7.0\n            Made ``cwd`` optional\n\n    setting_name : None\n        The name of the configuration key to set. Required.\n\n    setting_value : None\n        The (new) value to set. Required.\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    is_global : False\n        Set to True to use the '--global' flag with 'git config'\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.config_set /path/to/repo user.email me@example.com\n    '''\n    if setting_name is None or setting_value is None:\n        raise TypeError('Missing required parameter setting_name for git.config_set')\n    if cwd is None and not is_global:\n        raise SaltInvocationError('Either `is_global` must be set to True or '\n                                  'you must provide `cwd`')\n\n    if is_global:\n        cmd = 'git config --global {0} \"{1}\"'.format(setting_name, setting_value)\n    else:\n        cmd = 'git config {0} \"{1}\"'.format(setting_name, setting_value)\n\n    _check_git()\n\n    return _git_run(cmd, cwd=cwd, runas=user)\n\n\ndef config_get(cwd=None, setting_name=None, user=None):\n    '''\n    Get a key or keys from the git configuration file (.git/config).\n\n    cwd : None\n        Optional path to a Git repository\n\n        .. versionchanged:: 2014.7.0\n            Made ``cwd`` optional\n\n    setting_name : None\n        The name of the configuration key to get. Required.\n\n    user : None\n        Run git as a user other than what the minion runs as\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.config_get setting_name=user.email\n        salt '*' git.config_get /path/to/repo user.name arthur\n    '''\n    if setting_name is None:\n        raise TypeError('Missing required parameter setting_name for git.config_get')\n    _check_git()\n\n    return _git_run('git config {0}'.format(setting_name), cwd=cwd, runas=user)\n\n\ndef ls_remote(cwd, repository=\"origin\", branch=\"master\", user=None,\n              identity=None, https_user=None, https_pass=None):\n    '''\n    Returns the upstream hash for any given URL and branch.\n\n    cwd\n        The path to the Git repository\n\n    repository: origin\n        The name of the repository to get the revision from. Can be the name of\n        a remote, an URL, etc.\n\n    branch: master\n        The name of the branch to get the revision from.\n\n    user : none\n        run git as a user other than what the minion runs as\n\n    identity : none\n        a path to a private key to use over ssh\n\n    https_user : None\n        HTTP Basic Auth username for HTTPS (only) clones\n\n        .. versionadded:: 2015.5.0\n\n    https_pass : None\n        HTTP Basic Auth password for HTTPS (only) clones\n\n        .. versionadded:: 2015.5.0\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' git.ls_remote /pat/to/repo origin master\n\n    '''\n    _check_git()\n    repository = _add_http_basic_auth(repository, https_user, https_pass)\n    cmd = ' '.join([\"git\", \"ls-remote\", \"-h\", str(repository), str(branch), \"| cut -f 1\"])\n    return _git_run(cmd, cwd=cwd, runas=user, identity=identity)\n", "# -*- coding: utf-8 -*-\n'''\n    :codeauthor: :email:`Tarjei Hus\u00f8y <git@thusoy.com>`\n'''\n\n# Import Salt Testing Libs\nfrom salttesting import TestCase\nfrom salttesting.helpers import ensure_in_syspath\n\nensure_in_syspath('../../')\n\n# Import Salt Libs\nfrom salt.modules import git\n\n\nclass GitTestCase(TestCase):\n    '''\n    TestCase for salt.modules.git module\n    '''\n\n    def test_http_basic_authentication(self):\n        '''\n            Test that HTTP Basic auth works as intended.\n        '''\n        # ((user, pass), expected) tuples\n        test_inputs = [\n            ((None, None), 'https://example.com'),\n            (('user', None), 'https://user@example.com'),\n            (('user', 'pass'), 'https://user:pass@example.com'),\n        ]\n        for (user, password), expected in test_inputs:\n            kwargs = {\n                'https_user': user,\n                'https_pass': password,\n                'repository': 'https://example.com',\n            }\n            result = git._add_http_basic_auth(**kwargs)\n            self.assertEqual(result, expected)\n\n    def test_https_user_and_pw_is_confidential(self):\n        sensitive_outputs = (\n            'https://deadbeaf@example.com',\n            'https://user:pw@example.com',\n        )\n        sanitized = 'https://<redacted>@example.com'\n        for sensitive_output in sensitive_outputs:\n            result = git._remove_sensitive_data(sensitive_output)\n            self.assertEqual(result, sanitized)\n\n    def test_git_ssh_user_is_not_treated_as_sensitive(self):\n        not_sensitive_outputs = (\n            'ssh://user@example.com',\n        )\n        for not_sensitive_output in not_sensitive_outputs:\n            result = git._remove_sensitive_data(not_sensitive_output)\n            self.assertEqual(result, not_sensitive_output)\n\n\nif __name__ == '__main__':\n    from integration import run_tests\n    run_tests(GitTestCase, needs_daemon=False)\n"], "filenames": ["salt/modules/git.py", "tests/unit/modules/git_test.py"], "buggy_code_start_loc": [8, 39], "buggy_code_end_loc": [96, 39], "fixing_code_start_loc": [9, 40], "fixing_code_end_loc": [107, 58], "type": "CWE-200", "message": "salt before 2015.5.5 leaks git usernames and passwords to the log.", "other": {"cve": {"id": "CVE-2015-6918", "sourceIdentifier": "cve@mitre.org", "published": "2017-10-10T16:29:00.417", "lastModified": "2017-11-05T21:18:20.237", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "salt before 2015.5.5 leaks git usernames and passwords to the log."}, {"lang": "es", "value": "salt en versiones anteriores a la 2015.5.5 fuga nombres de usuario y contrase\u00f1as de git al log."}], "metrics": {"cvssMetricV30": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.0", "vectorString": "CVSS:3.0/AV:N/AC:H/PR:L/UI:N/S:C/C:H/I:N/A:N", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "LOW", "userInteraction": "NONE", "scope": "CHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 6.3, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 4.0}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:S/C:P/I:N/A:N", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "NONE", "availabilityImpact": "NONE", "baseScore": 3.5}, "baseSeverity": "LOW", "exploitabilityScore": 6.8, "impactScore": 2.9, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-200"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:saltstack:salt_2015:*:*:*:*:*:*:*:*", "versionEndIncluding": "5.4", "matchCriteriaId": "A241B444-0215-4D01-ABCB-25C8D2CF9804"}]}]}], "references": [{"url": "https://bugzilla.redhat.com/show_bug.cgi?id=1257154", "source": "cve@mitre.org", "tags": ["Issue Tracking", "Patch", "Third Party Advisory", "VDB Entry"]}, {"url": "https://github.com/saltstack/salt/commit/28aa9b105804ff433d8f663b2f9b804f2b75495a", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/saltstack/salt/commit/28aa9b105804ff433d8f663b2f9b804f2b75495a"}}