{"buggy_code": ["# -*- coding: utf-8 -*-\nfrom captcha import fields\nfrom django import forms\nfrom django.conf import settings\nfrom django.contrib.auth import get_user_model\nfrom django.contrib.auth.forms import PasswordResetForm as DjangoPasswordResetForm\nfrom django.contrib.auth.forms import UserCreationForm\nfrom django.contrib.auth.tokens import default_token_generator\nfrom django.contrib.sites.models import Site\nfrom django.urls import reverse\nfrom django.utils.translation import gettext_lazy as _\nfrom django.utils.translation import override\n\nfrom tcms.core.utils import request_host_link\nfrom tcms.core.utils.mailto import mailto\nfrom tcms.kiwi_auth.models import UserActivationKey\nfrom tcms.utils.permissions import initiate_user_with_default_setups\n\nUser = get_user_model()  # pylint: disable=invalid-name\n\n\nclass CustomCaptchaTextInput(fields.CaptchaTextInput):\n    template_name = \"captcha_field.html\"\n\n\nclass RegistrationForm(UserCreationForm):\n    email = forms.EmailField()\n    captcha = (\n        fields.CaptchaField(\n            widget=CustomCaptchaTextInput(attrs={\"class\": \"form-control\"})\n        )\n        if settings.USE_CAPTCHA\n        else None\n    )\n\n    class Meta:\n        model = User\n        fields = (\"username\",)\n\n    def clean_email(self):\n        email = self.cleaned_data[\"email\"]\n        try:\n            User.objects.get(email=email)\n        except User.DoesNotExist:\n            return email\n        raise forms.ValidationError(_(\"A user with that email already exists.\"))\n\n    def save(self, commit=True):\n        user = super().save(commit=False)\n        user.email = self.cleaned_data[\"email\"]\n        user.is_active = False\n        user.set_password(self.cleaned_data[\"password1\"])\n\n        if User.objects.filter(is_superuser=True).count() == 0:\n            user.is_superuser = True\n            user.is_active = True\n\n        if commit:\n            user.save()\n            initiate_user_with_default_setups(user)\n        return user\n\n    def set_activation_key(self):\n        return UserActivationKey.set_random_key_for_user(user=self.instance)\n\n    @override(settings.LANGUAGE_CODE)\n    def send_confirm_mail(self, request, activation_key):\n        current_site = Site.objects.get(pk=settings.SITE_ID)\n        confirm_url = request_host_link(request, current_site.domain) + reverse(\n            \"tcms-confirm\",\n            args=[\n                activation_key.activation_key,\n            ],\n        )\n\n        mailto(\n            template_name=\"email/confirm_registration.txt\",\n            recipients=self.cleaned_data[\"email\"],\n            subject=_(\"Your new %s account confirmation\") % current_site.domain,\n            context={\n                \"user\": self.instance,\n                \"site_domain\": current_site.domain,\n                \"confirm_url\": confirm_url,\n            },\n        )\n\n\nclass PasswordResetForm(\n    DjangoPasswordResetForm\n):  # pylint: disable=must-inherit-from-model-form\n    \"\"\"\n    Overrides the default form b/c it uses Site.objects.get_current()\n    which uses an internal cache and produces wrong results when\n    kiwitcms-tenants is installed.\n    \"\"\"\n\n    def save(  # pylint: disable=too-many-arguments\n        self,\n        domain_override=None,\n        subject_template_name=\"registration/password_reset_subject.txt\",\n        email_template_name=\"registration/password_reset_email.html\",\n        use_https=False,\n        token_generator=default_token_generator,\n        from_email=None,\n        request=None,\n        html_email_template_name=None,\n        extra_email_context=None,\n    ):\n        current_site = Site.objects.get(pk=settings.SITE_ID)\n        # call the stock method and just overrides the domain\n        super().save(\n            current_site.domain,\n            subject_template_name,\n            email_template_name,\n            use_https,\n            token_generator,\n            from_email,\n            request,\n            html_email_template_name,\n            extra_email_context,\n        )\n", "# -*- coding: utf-8 -*-\n# pylint: disable=invalid-name\n\nimport datetime\n\nfrom django.conf import settings\nfrom django.contrib.auth import get_user_model\nfrom django.contrib.sites.models import Site\nfrom django.test import TestCase, override_settings\nfrom django.urls import reverse\nfrom django.utils import timezone\nfrom django.utils.translation import gettext_lazy as _\nfrom mock import patch\n\nfrom tcms import signals\nfrom tcms.kiwi_auth import forms\nfrom tcms.kiwi_auth.models import UserActivationKey\nfrom tcms.tests.factories import UserFactory\n\nfrom . import __FOR_TESTING__\n\nUser = get_user_model()  # pylint: disable=invalid-name\n\n\nclass TestSetRandomKey(TestCase):\n    \"\"\"Test case for UserActivationKey.set_random_key_for_user\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.new_user = UserFactory()\n\n    @patch(\"tcms.kiwi_auth.models.datetime\")\n    def test_set_random_key(self, mock_datetime):\n        now = timezone.now()\n        in_7_days = datetime.timedelta(7)\n\n        mock_datetime.datetime.today.return_value = now\n        mock_datetime.timedelta.return_value = in_7_days\n\n        activation_key = UserActivationKey.set_random_key_for_user(self.new_user)\n        self.assertEqual(self.new_user, activation_key.user)\n        self.assertNotEqual(\"\", activation_key.activation_key)\n        self.assertEqual(now + in_7_days, activation_key.key_expires)\n\n\nclass TestForceToSetRandomKey(TestCase):\n    \"\"\"Test case for UserActivationKey.set_random_key_for_user forcely\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.new_user = UserFactory()\n        cls.origin_activation_key = UserActivationKey.set_random_key_for_user(\n            cls.new_user\n        )\n\n    def test_set_random_key_forcely(self):\n        new_activation_key = UserActivationKey.set_random_key_for_user(\n            self.new_user, force=True\n        )\n        self.assertEqual(self.origin_activation_key.user, new_activation_key.user)\n        self.assertNotEqual(\n            self.origin_activation_key.activation_key, new_activation_key.activation_key\n        )\n\n\n# ### Test cases for view methods ###\n\n\nclass TestLogout(TestCase):\n    \"\"\"Test for logout view method\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):\n        super(TestLogout, cls).setUpTestData()\n\n        cls.tester = UserFactory()\n        cls.tester.set_password(\"password\")\n        cls.tester.save()\n        cls.logout_url = reverse(\"tcms-logout\")\n\n    def test_logout_redirects_to_login_page(self):\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.tester.username, password=\"password\"\n        )\n        response = self.client.get(self.logout_url, follow=True)\n        self.assertRedirects(response, reverse(\"tcms-login\"))\n\n    def test_logout_then_goto_next(self):\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.tester.username, password=\"password\"\n        )\n        next_url = reverse(\"tcms-login\") + \"?next=\" + reverse(\"plans-search\")\n        response = self.client.get(self.logout_url, {\"next\": next_url}, follow=True)\n        self.assertRedirects(response, next_url)\n\n\nclass TestRegistration(TestCase):\n    def setUp(self):\n        self.register_url = reverse(\"tcms-register\")\n        self.fake_activate_key = \"secret-activate-key\"\n\n    def test_open_registration_page(self):\n        response = self.client.get(self.register_url)\n        _register = _(\"Register\")\n        self.assertContains(response, f\">{_register}</button>\")\n\n    def assert_user_registration(self, username, follow=False):\n        with patch(\"tcms.kiwi_auth.models.secrets\") as _secrets:\n            _secrets.token_hex.return_value = self.fake_activate_key\n\n            try:\n                # https://github.com/mbi/django-simple-captcha/issues/84\n                # pylint: disable=import-outside-toplevel\n                from captcha.conf import settings as captcha_settings\n\n                captcha_settings.CAPTCHA_TEST_MODE = True\n\n                response = self.client.post(\n                    self.register_url,\n                    {\n                        \"username\": username,\n                        \"password1\": __FOR_TESTING__,\n                        \"password2\": __FOR_TESTING__,\n                        \"email\": \"new-tester@example.com\",\n                        \"captcha_0\": \"PASSED\",\n                        \"captcha_1\": \"PASSED\",\n                    },\n                    follow=follow,\n                )\n            finally:\n                captcha_settings.CAPTCHA_TEST_MODE = False\n\n        user = User.objects.get(username=username)\n        self.assertEqual(\"new-tester@example.com\", user.email)\n        if User.objects.filter(is_superuser=True).count() == 1 and user.is_superuser:\n            self.assertTrue(user.is_active)\n        else:\n            self.assertFalse(user.is_active)\n\n        key = UserActivationKey.objects.get(user=user)\n        self.assertEqual(self.fake_activate_key, key.activation_key)\n\n        return response, user\n\n    @patch(\"tcms.signals.USER_REGISTERED_SIGNAL.send\")\n    def test_register_user_sends_signal(self, signal_mock):\n        self.assert_user_registration(\"new-signal-tester\")\n        self.assertTrue(signal_mock.called)\n        self.assertEqual(1, signal_mock.call_count)\n\n    @override_settings(ADMINS=[(\"Test Admin\", \"admin@kiwitcms.org\")])\n    @patch(\"tcms.core.utils.mailto.send_mail\")\n    def test_signal_handler_notifies_admins(self, send_mail):\n        # connect the handler b/c it is not connected by default\n        signals.USER_REGISTERED_SIGNAL.connect(signals.notify_admins)\n\n        try:\n            response, user = self.assert_user_registration(\"signal-handler\")\n            self.assertRedirects(\n                response, reverse(\"core-views-index\"), target_status_code=302\n            )\n\n            # 1 - verification mail, 2 - email to admin\n            self.assertTrue(send_mail.called)\n            self.assertEqual(2, send_mail.call_count)\n\n            # verify we've actually sent the admin email\n            self.assertIn(\n                str(_(\"New user awaiting approval\")), send_mail.call_args_list[0][0][0]\n            )\n            values = {\n                \"username\": \"signal-handler\",\n                \"user_url\": f\"http://testserver/admin/auth/user/{user.pk}/change/\",\n            }\n            expected = (\n                _(\n                    \"\"\"Dear Administrator,\nsomebody just registered an account with username %(username)s at your\nKiwi TCMS instance and is awaiting your approval!\n\nGo to %(user_url)s to activate the account!\"\"\"\n                )\n                % values\n            )\n            self.assertEqual(\n                expected.strip(), send_mail.call_args_list[0][0][1].strip()\n            )\n            self.assertIn(\"admin@kiwitcms.org\", send_mail.call_args_list[0][0][-1])\n        finally:\n            signals.USER_REGISTERED_SIGNAL.disconnect(signals.notify_admins)\n\n    @patch(\"tcms.core.utils.mailto.send_mail\")\n    def test_register_user_by_email_confirmation(self, send_mail):\n        response, user = self.assert_user_registration(\"new-tester\", follow=True)\n        self.assertContains(\n            response,\n            _(\n                \"Your account has been created, please check your mailbox for confirmation\"\n            ),\n        )\n\n        site = Site.objects.get(pk=settings.SITE_ID)\n        _confirm_url = reverse(\"tcms-confirm\", args=[self.fake_activate_key])\n        confirm_url = f\"http://{site.domain}{_confirm_url}\"\n\n        # Verify notification mail\n        values = {\n            \"user\": user.username,\n            \"site_domain\": site.domain,\n            \"confirm_url\": confirm_url,\n        }\n        expected_subject = (\n            settings.EMAIL_SUBJECT_PREFIX\n            + _(\"Your new %s account confirmation\") % site.domain\n        )\n        expected_body = (\n            _(\n                \"\"\"Welcome %(user)s,\nthank you for signing up for an %(site_domain)s account!\n\nTo activate your account, click this link:\n%(confirm_url)s\"\"\"\n            )\n            % values\n            + \"\\n\"\n        )\n        send_mail.assert_called_once_with(\n            expected_subject,\n            expected_body,\n            settings.DEFAULT_FROM_EMAIL,\n            [\"new-tester@example.com\"],\n            fail_silently=False,\n        )\n\n    @override_settings(\n        AUTO_APPROVE_NEW_USERS=False,\n        ADMINS=[(\"admin1\", \"admin1@example.com\"), (\"admin2\", \"admin2@example.com\")],\n    )\n    def test_register_user_and_activate_by_admin(self):\n        response, _user = self.assert_user_registration(\"plan-tester\", follow=True)\n\n        self.assertContains(\n            response,\n            _(\n                \"Your account has been created, but you need an administrator to activate it\"\n            ),\n        )\n\n        for name, email in settings.ADMINS:\n            self.assertContains(\n                response, f'<a href=\"mailto:{email}\">{name}</a>', html=True\n            )\n\n    def test_invalid_form(self):\n        response = self.client.post(\n            self.register_url,\n            {\n                \"username\": \"kiwi-tester\",\n                \"password1\": __FOR_TESTING__,\n                \"password2\": f\"000-{__FOR_TESTING__}\",\n                \"email\": \"new-tester@example.com\",\n            },\n            follow=False,\n        )\n\n        self.assertContains(response, _(\"The two password fields didn\u2019t match.\"))\n        self.assertEqual(response.status_code, 200)\n        self.assertTemplateUsed(response, \"registration/registration_form.html\")\n\n    def test_register_user_already_registered(self):\n        User.objects.create_user(\"kiwi-tester\", \"new-tester@example.com\", \"password\")\n\n        response = self.client.post(\n            self.register_url,\n            {\n                \"username\": \"test_user\",\n                \"password1\": __FOR_TESTING__,\n                \"password2\": __FOR_TESTING__,\n                \"email\": \"new-tester@example.com\",\n            },\n            follow=False,\n        )\n        self.assertContains(response, _(\"A user with that email already exists.\"))\n\n        user = User.objects.filter(username=\"test_user\")\n        self.assertEqual(user.count(), 0)\n\n    def test_first_user_is_superuser(self):\n        _response, user = self.assert_user_registration(\"tester_1\")\n\n        self.assertTrue(user.is_superuser)\n        self.assertTrue(user.is_active)\n\n    def test_only_one_superuser(self):\n        user1 = User.objects.create_user(\n            \"kiwi-tester\", \"tester@example.com\", \"password\"\n        )\n        user1.is_superuser = True\n        user1.save()\n\n        self.assertTrue(user1.is_superuser)\n\n        _response, user2 = self.assert_user_registration(\"plan-tester\")\n        self.assertFalse(user2.is_superuser)\n\n\nclass TestConfirm(TestCase):\n    \"\"\"Test for activation key confirmation\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.new_user = UserFactory()\n\n    def setUp(self):\n        self.new_user.is_active = False\n        self.new_user.save()\n\n    def test_fail_if_activation_key_does_not_exist(self):\n        confirm_url = reverse(\"tcms-confirm\", args=[\"nonexisting-activation-key\"])\n        response = self.client.get(confirm_url, follow=True)\n\n        self.assertContains(\n            response, _(\"This activation key no longer exists in the database\")\n        )\n\n        # user account not activated\n        user = User.objects.get(username=self.new_user.username)\n        self.assertFalse(user.is_active)\n\n    def test_fail_if_activation_key_expired(self):\n        fake_activation_key = \"secret-activation-key\"\n\n        with patch(\"tcms.kiwi_auth.models.secrets\") as _secrets:\n            _secrets.token_hex.return_value = fake_activation_key\n            key = UserActivationKey.set_random_key_for_user(self.new_user)\n            key.key_expires = timezone.now() - datetime.timedelta(days=10)\n            key.save()\n\n        confirm_url = reverse(\"tcms-confirm\", args=[fake_activation_key])\n        response = self.client.get(confirm_url, follow=True)\n\n        self.assertContains(response, _(\"This activation key has expired\"))\n\n        # user account not activated\n        user = User.objects.get(username=self.new_user.username)\n        self.assertFalse(user.is_active)\n\n    def test_confirm(self):\n        fake_activate_key = \"secret-activate-key\"\n\n        with patch(\"tcms.kiwi_auth.models.secrets\") as _secrets:\n            _secrets.token_hex.return_value = fake_activate_key\n            UserActivationKey.set_random_key_for_user(self.new_user)\n\n        confirm_url = reverse(\"tcms-confirm\", args=[fake_activate_key])\n        response = self.client.get(confirm_url, follow=True)\n\n        self.assertContains(response, _(\"Your account has been activated successfully\"))\n\n        # user account activated\n        user = User.objects.get(username=self.new_user.username)\n        self.assertTrue(user.is_active)\n        activate_key_deleted = not UserActivationKey.objects.filter(user=user).exists()\n        self.assertTrue(activate_key_deleted)\n\n\nclass TestLoginViewWithCustomTemplate(TestCase):\n    \"\"\"Test for login view with custom template\"\"\"\n\n    def test_get_template_names(self):\n        response = self.client.get(reverse(\"tcms-login\"))\n        self.assertIsNotNone(response.template_name)\n        self.assertEqual(\n            response.template_name,\n            [\"registration/custom_login.html\", \"registration/login.html\"],\n        )\n\n\nclass TestPasswordResetView(TestCase):\n    \"\"\"Test for password reset view\"\"\"\n\n    def setUp(self):\n        self.password_reset_url = reverse(\"tcms-password_reset\")\n\n    def test_form_class(self):\n        response = self.client.get(self.password_reset_url)\n        self.assertEqual(\n            str(type(response.context[\"form\"])),\n            str(forms.PasswordResetForm),\n        )\n\n    def test_open_password_reset_page(self):\n        response = self.client.get(self.password_reset_url)\n\n        _password_reset = _(\"Password reset\")\n        self.assertContains(response, f\">{_password_reset}</button>\")\n\n    @patch(\"tcms.kiwi_auth.forms.DjangoPasswordResetForm.send_mail\")\n    def test_send_mail_for_password_reset(self, mail_sent):\n        user = User.objects.create_user(\"kiwi-tester\", \"tester@example.com\", \"password\")\n        user.is_active = True\n        user.save()\n        data = {\"email\": \"tester@example.com\"}\n        response = self.client.post(self.password_reset_url, data, follow=True)\n\n        self.assertContains(response, _(\"Password reset email was sent\"))\n\n        # Verify mail is sent\n        mail_sent.assert_called_once()\n", "{% extends \"base.html\" %}\n{% load i18n %}\n{% block html_class %}login-pf{% endblock %}\n{% block title %}{{ title }}{% endblock %}\n\n{% block contents %}\n<div class=\"container\">\n  <div class=\"row\">\n    <div class=\"col-sm-7 col-md-6 col-lg-5 login\">\n      <form class=\"form-horizontal\" role=\"form\" action=\"{% url \"tcms-password_reset\" %}\" method=\"POST\">\n        {% csrf_token %}\n        <input type=\"hidden\" name=\"next\" value=\"{{ REQUEST_CONTENTS.next }}\" />\n\n        <div class=\"form-group\">\n          {{ form.email.errors }}\n          <label for=\"inputEmail\" class=\"col-sm-2 col-md-2 control-label\">{% trans \"E-mail\" %}</label>\n          <div class=\"col-sm-10 col-md-10\">\n            <input type=\"text\" class=\"form-control\" id=\"inputEmail\" name=\"email\" placeholder=\"\" tabindex=\"1\">\n          </div>\n        </div>\n        <div class=\"form-group\">\n          <div class=\"col-xs-12 col-sm-offset-2 col-sm-10 col-md-offset-2 col-md-10 submit\">\n            <button type=\"submit\" class=\"btn btn-primary btn-lg\" tabindex=\"4\">{% trans \"Password reset\" %}</button>\n          </div>\n        </div>\n      </form>\n    </div><!--/.col-*-->\n    <div class=\"col-sm-5 col-md-6 col-lg-7 details\">\n      <p>\n        <strong>{% trans \"Kiwi TCMS password reset\" %}!</strong>\n      </p>\n    </div><!--/.col-*-->\n  </div><!--/.row-->\n</div><!--/.container-->\n{% endblock %}\n"], "fixing_code": ["# -*- coding: utf-8 -*-\nfrom captcha import fields\nfrom django import forms\nfrom django.conf import settings\nfrom django.contrib.auth import get_user_model\nfrom django.contrib.auth.forms import PasswordResetForm as DjangoPasswordResetForm\nfrom django.contrib.auth.forms import UserCreationForm\nfrom django.contrib.auth.tokens import default_token_generator\nfrom django.contrib.sites.models import Site\nfrom django.urls import reverse\nfrom django.utils.translation import gettext_lazy as _\nfrom django.utils.translation import override\n\nfrom tcms.core.utils import request_host_link\nfrom tcms.core.utils.mailto import mailto\nfrom tcms.kiwi_auth.models import UserActivationKey\nfrom tcms.utils.permissions import initiate_user_with_default_setups\n\nUser = get_user_model()  # pylint: disable=invalid-name\n\n\nclass CustomCaptchaTextInput(fields.CaptchaTextInput):\n    template_name = \"captcha_field.html\"\n\n\nclass RegistrationForm(UserCreationForm):\n    email = forms.EmailField()\n    captcha = (\n        fields.CaptchaField(\n            widget=CustomCaptchaTextInput(attrs={\"class\": \"form-control\"})\n        )\n        if settings.USE_CAPTCHA\n        else None\n    )\n\n    class Meta:\n        model = User\n        fields = (\"username\",)\n\n    def clean_email(self):\n        email = self.cleaned_data[\"email\"]\n        try:\n            User.objects.get(email=email)\n        except User.DoesNotExist:\n            return email\n        raise forms.ValidationError(_(\"A user with that email already exists.\"))\n\n    def save(self, commit=True):\n        user = super().save(commit=False)\n        user.email = self.cleaned_data[\"email\"]\n        user.is_active = False\n        user.set_password(self.cleaned_data[\"password1\"])\n\n        if User.objects.filter(is_superuser=True).count() == 0:\n            user.is_superuser = True\n            user.is_active = True\n\n        if commit:\n            user.save()\n            initiate_user_with_default_setups(user)\n        return user\n\n    def set_activation_key(self):\n        return UserActivationKey.set_random_key_for_user(user=self.instance)\n\n    @override(settings.LANGUAGE_CODE)\n    def send_confirm_mail(self, request, activation_key):\n        current_site = Site.objects.get(pk=settings.SITE_ID)\n        confirm_url = request_host_link(request, current_site.domain) + reverse(\n            \"tcms-confirm\",\n            args=[\n                activation_key.activation_key,\n            ],\n        )\n\n        mailto(\n            template_name=\"email/confirm_registration.txt\",\n            recipients=self.cleaned_data[\"email\"],\n            subject=_(\"Your new %s account confirmation\") % current_site.domain,\n            context={\n                \"user\": self.instance,\n                \"site_domain\": current_site.domain,\n                \"confirm_url\": confirm_url,\n            },\n        )\n\n\nclass PasswordResetForm(\n    DjangoPasswordResetForm\n):  # pylint: disable=must-inherit-from-model-form\n    \"\"\"\n    Overrides the default form b/c it uses Site.objects.get_current()\n    which uses an internal cache and produces wrong results when\n    kiwitcms-tenants is installed.\n    \"\"\"\n\n    captcha = (\n        fields.CaptchaField(\n            widget=CustomCaptchaTextInput(attrs={\"class\": \"form-control\"})\n        )\n        if settings.USE_CAPTCHA\n        else None\n    )\n\n    def save(  # pylint: disable=too-many-arguments\n        self,\n        domain_override=None,\n        subject_template_name=\"registration/password_reset_subject.txt\",\n        email_template_name=\"registration/password_reset_email.html\",\n        use_https=False,\n        token_generator=default_token_generator,\n        from_email=None,\n        request=None,\n        html_email_template_name=None,\n        extra_email_context=None,\n    ):\n        current_site = Site.objects.get(pk=settings.SITE_ID)\n        # call the stock method and just overrides the domain\n        super().save(\n            current_site.domain,\n            subject_template_name,\n            email_template_name,\n            use_https,\n            token_generator,\n            from_email,\n            request,\n            html_email_template_name,\n            extra_email_context,\n        )\n", "# -*- coding: utf-8 -*-\n# pylint: disable=invalid-name\n\nimport datetime\n\nfrom django.conf import settings\nfrom django.contrib.auth import get_user_model\nfrom django.contrib.sites.models import Site\nfrom django.test import TestCase, override_settings\nfrom django.urls import reverse\nfrom django.utils import timezone\nfrom django.utils.translation import gettext_lazy as _\nfrom mock import patch\n\nfrom tcms import signals\nfrom tcms.kiwi_auth import forms\nfrom tcms.kiwi_auth.models import UserActivationKey\nfrom tcms.tests.factories import UserFactory\n\nfrom . import __FOR_TESTING__\n\nUser = get_user_model()  # pylint: disable=invalid-name\n\n\nclass TestSetRandomKey(TestCase):\n    \"\"\"Test case for UserActivationKey.set_random_key_for_user\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.new_user = UserFactory()\n\n    @patch(\"tcms.kiwi_auth.models.datetime\")\n    def test_set_random_key(self, mock_datetime):\n        now = timezone.now()\n        in_7_days = datetime.timedelta(7)\n\n        mock_datetime.datetime.today.return_value = now\n        mock_datetime.timedelta.return_value = in_7_days\n\n        activation_key = UserActivationKey.set_random_key_for_user(self.new_user)\n        self.assertEqual(self.new_user, activation_key.user)\n        self.assertNotEqual(\"\", activation_key.activation_key)\n        self.assertEqual(now + in_7_days, activation_key.key_expires)\n\n\nclass TestForceToSetRandomKey(TestCase):\n    \"\"\"Test case for UserActivationKey.set_random_key_for_user forcely\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.new_user = UserFactory()\n        cls.origin_activation_key = UserActivationKey.set_random_key_for_user(\n            cls.new_user\n        )\n\n    def test_set_random_key_forcely(self):\n        new_activation_key = UserActivationKey.set_random_key_for_user(\n            self.new_user, force=True\n        )\n        self.assertEqual(self.origin_activation_key.user, new_activation_key.user)\n        self.assertNotEqual(\n            self.origin_activation_key.activation_key, new_activation_key.activation_key\n        )\n\n\n# ### Test cases for view methods ###\n\n\nclass TestLogout(TestCase):\n    \"\"\"Test for logout view method\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):\n        super(TestLogout, cls).setUpTestData()\n\n        cls.tester = UserFactory()\n        cls.tester.set_password(\"password\")\n        cls.tester.save()\n        cls.logout_url = reverse(\"tcms-logout\")\n\n    def test_logout_redirects_to_login_page(self):\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.tester.username, password=\"password\"\n        )\n        response = self.client.get(self.logout_url, follow=True)\n        self.assertRedirects(response, reverse(\"tcms-login\"))\n\n    def test_logout_then_goto_next(self):\n        self.client.login(  # nosec:B106:hardcoded_password_funcarg\n            username=self.tester.username, password=\"password\"\n        )\n        next_url = reverse(\"tcms-login\") + \"?next=\" + reverse(\"plans-search\")\n        response = self.client.get(self.logout_url, {\"next\": next_url}, follow=True)\n        self.assertRedirects(response, next_url)\n\n\nclass TestRegistration(TestCase):\n    def setUp(self):\n        self.register_url = reverse(\"tcms-register\")\n        self.fake_activate_key = \"secret-activate-key\"\n\n    def test_open_registration_page(self):\n        response = self.client.get(self.register_url)\n        _register = _(\"Register\")\n        self.assertContains(response, f\">{_register}</button>\")\n\n    def assert_user_registration(self, username, follow=False):\n        with patch(\"tcms.kiwi_auth.models.secrets\") as _secrets:\n            _secrets.token_hex.return_value = self.fake_activate_key\n\n            try:\n                # https://github.com/mbi/django-simple-captcha/issues/84\n                # pylint: disable=import-outside-toplevel\n                from captcha.conf import settings as captcha_settings\n\n                captcha_settings.CAPTCHA_TEST_MODE = True\n\n                response = self.client.post(\n                    self.register_url,\n                    {\n                        \"username\": username,\n                        \"password1\": __FOR_TESTING__,\n                        \"password2\": __FOR_TESTING__,\n                        \"email\": \"new-tester@example.com\",\n                        \"captcha_0\": \"PASSED\",\n                        \"captcha_1\": \"PASSED\",\n                    },\n                    follow=follow,\n                )\n            finally:\n                captcha_settings.CAPTCHA_TEST_MODE = False\n\n        user = User.objects.get(username=username)\n        self.assertEqual(\"new-tester@example.com\", user.email)\n        if User.objects.filter(is_superuser=True).count() == 1 and user.is_superuser:\n            self.assertTrue(user.is_active)\n        else:\n            self.assertFalse(user.is_active)\n\n        key = UserActivationKey.objects.get(user=user)\n        self.assertEqual(self.fake_activate_key, key.activation_key)\n\n        return response, user\n\n    @patch(\"tcms.signals.USER_REGISTERED_SIGNAL.send\")\n    def test_register_user_sends_signal(self, signal_mock):\n        self.assert_user_registration(\"new-signal-tester\")\n        self.assertTrue(signal_mock.called)\n        self.assertEqual(1, signal_mock.call_count)\n\n    @override_settings(ADMINS=[(\"Test Admin\", \"admin@kiwitcms.org\")])\n    @patch(\"tcms.core.utils.mailto.send_mail\")\n    def test_signal_handler_notifies_admins(self, send_mail):\n        # connect the handler b/c it is not connected by default\n        signals.USER_REGISTERED_SIGNAL.connect(signals.notify_admins)\n\n        try:\n            response, user = self.assert_user_registration(\"signal-handler\")\n            self.assertRedirects(\n                response, reverse(\"core-views-index\"), target_status_code=302\n            )\n\n            # 1 - verification mail, 2 - email to admin\n            self.assertTrue(send_mail.called)\n            self.assertEqual(2, send_mail.call_count)\n\n            # verify we've actually sent the admin email\n            self.assertIn(\n                str(_(\"New user awaiting approval\")), send_mail.call_args_list[0][0][0]\n            )\n            values = {\n                \"username\": \"signal-handler\",\n                \"user_url\": f\"http://testserver/admin/auth/user/{user.pk}/change/\",\n            }\n            expected = (\n                _(\n                    \"\"\"Dear Administrator,\nsomebody just registered an account with username %(username)s at your\nKiwi TCMS instance and is awaiting your approval!\n\nGo to %(user_url)s to activate the account!\"\"\"\n                )\n                % values\n            )\n            self.assertEqual(\n                expected.strip(), send_mail.call_args_list[0][0][1].strip()\n            )\n            self.assertIn(\"admin@kiwitcms.org\", send_mail.call_args_list[0][0][-1])\n        finally:\n            signals.USER_REGISTERED_SIGNAL.disconnect(signals.notify_admins)\n\n    @patch(\"tcms.core.utils.mailto.send_mail\")\n    def test_register_user_by_email_confirmation(self, send_mail):\n        response, user = self.assert_user_registration(\"new-tester\", follow=True)\n        self.assertContains(\n            response,\n            _(\n                \"Your account has been created, please check your mailbox for confirmation\"\n            ),\n        )\n\n        site = Site.objects.get(pk=settings.SITE_ID)\n        _confirm_url = reverse(\"tcms-confirm\", args=[self.fake_activate_key])\n        confirm_url = f\"http://{site.domain}{_confirm_url}\"\n\n        # Verify notification mail\n        values = {\n            \"user\": user.username,\n            \"site_domain\": site.domain,\n            \"confirm_url\": confirm_url,\n        }\n        expected_subject = (\n            settings.EMAIL_SUBJECT_PREFIX\n            + _(\"Your new %s account confirmation\") % site.domain\n        )\n        expected_body = (\n            _(\n                \"\"\"Welcome %(user)s,\nthank you for signing up for an %(site_domain)s account!\n\nTo activate your account, click this link:\n%(confirm_url)s\"\"\"\n            )\n            % values\n            + \"\\n\"\n        )\n        send_mail.assert_called_once_with(\n            expected_subject,\n            expected_body,\n            settings.DEFAULT_FROM_EMAIL,\n            [\"new-tester@example.com\"],\n            fail_silently=False,\n        )\n\n    @override_settings(\n        AUTO_APPROVE_NEW_USERS=False,\n        ADMINS=[(\"admin1\", \"admin1@example.com\"), (\"admin2\", \"admin2@example.com\")],\n    )\n    def test_register_user_and_activate_by_admin(self):\n        response, _user = self.assert_user_registration(\"plan-tester\", follow=True)\n\n        self.assertContains(\n            response,\n            _(\n                \"Your account has been created, but you need an administrator to activate it\"\n            ),\n        )\n\n        for name, email in settings.ADMINS:\n            self.assertContains(\n                response, f'<a href=\"mailto:{email}\">{name}</a>', html=True\n            )\n\n    def test_invalid_form(self):\n        response = self.client.post(\n            self.register_url,\n            {\n                \"username\": \"kiwi-tester\",\n                \"password1\": __FOR_TESTING__,\n                \"password2\": f\"000-{__FOR_TESTING__}\",\n                \"email\": \"new-tester@example.com\",\n            },\n            follow=False,\n        )\n\n        self.assertContains(response, _(\"The two password fields didn\u2019t match.\"))\n        self.assertEqual(response.status_code, 200)\n        self.assertTemplateUsed(response, \"registration/registration_form.html\")\n\n    def test_register_user_already_registered(self):\n        User.objects.create_user(\"kiwi-tester\", \"new-tester@example.com\", \"password\")\n\n        response = self.client.post(\n            self.register_url,\n            {\n                \"username\": \"test_user\",\n                \"password1\": __FOR_TESTING__,\n                \"password2\": __FOR_TESTING__,\n                \"email\": \"new-tester@example.com\",\n            },\n            follow=False,\n        )\n        self.assertContains(response, _(\"A user with that email already exists.\"))\n\n        user = User.objects.filter(username=\"test_user\")\n        self.assertEqual(user.count(), 0)\n\n    def test_first_user_is_superuser(self):\n        _response, user = self.assert_user_registration(\"tester_1\")\n\n        self.assertTrue(user.is_superuser)\n        self.assertTrue(user.is_active)\n\n    def test_only_one_superuser(self):\n        user1 = User.objects.create_user(\n            \"kiwi-tester\", \"tester@example.com\", \"password\"\n        )\n        user1.is_superuser = True\n        user1.save()\n\n        self.assertTrue(user1.is_superuser)\n\n        _response, user2 = self.assert_user_registration(\"plan-tester\")\n        self.assertFalse(user2.is_superuser)\n\n\nclass TestConfirm(TestCase):\n    \"\"\"Test for activation key confirmation\"\"\"\n\n    @classmethod\n    def setUpTestData(cls):\n        cls.new_user = UserFactory()\n\n    def setUp(self):\n        self.new_user.is_active = False\n        self.new_user.save()\n\n    def test_fail_if_activation_key_does_not_exist(self):\n        confirm_url = reverse(\"tcms-confirm\", args=[\"nonexisting-activation-key\"])\n        response = self.client.get(confirm_url, follow=True)\n\n        self.assertContains(\n            response, _(\"This activation key no longer exists in the database\")\n        )\n\n        # user account not activated\n        user = User.objects.get(username=self.new_user.username)\n        self.assertFalse(user.is_active)\n\n    def test_fail_if_activation_key_expired(self):\n        fake_activation_key = \"secret-activation-key\"\n\n        with patch(\"tcms.kiwi_auth.models.secrets\") as _secrets:\n            _secrets.token_hex.return_value = fake_activation_key\n            key = UserActivationKey.set_random_key_for_user(self.new_user)\n            key.key_expires = timezone.now() - datetime.timedelta(days=10)\n            key.save()\n\n        confirm_url = reverse(\"tcms-confirm\", args=[fake_activation_key])\n        response = self.client.get(confirm_url, follow=True)\n\n        self.assertContains(response, _(\"This activation key has expired\"))\n\n        # user account not activated\n        user = User.objects.get(username=self.new_user.username)\n        self.assertFalse(user.is_active)\n\n    def test_confirm(self):\n        fake_activate_key = \"secret-activate-key\"\n\n        with patch(\"tcms.kiwi_auth.models.secrets\") as _secrets:\n            _secrets.token_hex.return_value = fake_activate_key\n            UserActivationKey.set_random_key_for_user(self.new_user)\n\n        confirm_url = reverse(\"tcms-confirm\", args=[fake_activate_key])\n        response = self.client.get(confirm_url, follow=True)\n\n        self.assertContains(response, _(\"Your account has been activated successfully\"))\n\n        # user account activated\n        user = User.objects.get(username=self.new_user.username)\n        self.assertTrue(user.is_active)\n        activate_key_deleted = not UserActivationKey.objects.filter(user=user).exists()\n        self.assertTrue(activate_key_deleted)\n\n\nclass TestLoginViewWithCustomTemplate(TestCase):\n    \"\"\"Test for login view with custom template\"\"\"\n\n    def test_get_template_names(self):\n        response = self.client.get(reverse(\"tcms-login\"))\n        self.assertIsNotNone(response.template_name)\n        self.assertEqual(\n            response.template_name,\n            [\"registration/custom_login.html\", \"registration/login.html\"],\n        )\n\n\nclass TestPasswordResetView(TestCase):\n    \"\"\"Test for password reset view\"\"\"\n\n    def setUp(self):\n        self.password_reset_url = reverse(\"tcms-password_reset\")\n\n    def test_form_class(self):\n        response = self.client.get(self.password_reset_url)\n        self.assertEqual(\n            str(type(response.context[\"form\"])),\n            str(forms.PasswordResetForm),\n        )\n\n    def test_open_password_reset_page(self):\n        response = self.client.get(self.password_reset_url)\n\n        _password_reset = _(\"Password reset\")\n        self.assertContains(response, f\">{_password_reset}</button>\")\n\n    @patch(\"tcms.kiwi_auth.forms.DjangoPasswordResetForm.send_mail\")\n    def test_send_mail_for_password_reset(self, mail_sent):\n        user = User.objects.create_user(\"kiwi-tester\", \"tester@example.com\", \"password\")\n        user.is_active = True\n        user.save()\n\n        try:\n            # https://github.com/mbi/django-simple-captcha/issues/84\n            # pylint: disable=import-outside-toplevel\n            from captcha.conf import settings as captcha_settings\n\n            captcha_settings.CAPTCHA_TEST_MODE = True\n\n            response = self.client.post(\n                self.password_reset_url,\n                {\n                    \"email\": \"tester@example.com\",\n                    \"captcha_0\": \"PASSED\",\n                    \"captcha_1\": \"PASSED\",\n                },\n                follow=True,\n            )\n        finally:\n            captcha_settings.CAPTCHA_TEST_MODE = False\n\n        self.assertContains(response, _(\"Password reset email was sent\"))\n\n        # Verify mail is sent\n        mail_sent.assert_called_once()\n", "{% extends \"base.html\" %}\n{% load i18n %}\n{% block html_class %}login-pf{% endblock %}\n{% block title %}{{ title }}{% endblock %}\n\n{% block contents %}\n<div class=\"container\">\n  <div class=\"row\">\n    <div class=\"col-sm-7 col-md-6 col-lg-5 login\">\n      <form class=\"form-horizontal\" role=\"form\" action=\"{% url \"tcms-password_reset\" %}\" method=\"POST\">\n        {% csrf_token %}\n        <input type=\"hidden\" name=\"next\" value=\"{{ REQUEST_CONTENTS.next }}\" />\n\n        <div class=\"form-group\">\n          {{ form.email.errors }}\n          <label for=\"inputEmail\" class=\"col-sm-2 col-md-2 control-label\">{% trans \"E-mail\" %}</label>\n          <div class=\"col-sm-10 col-md-10\">\n            <input type=\"text\" class=\"form-control\" id=\"inputEmail\" name=\"email\" placeholder=\"\" tabindex=\"1\">\n          </div>\n        </div>\n        {% if 'captcha' in form.fields %}\n            {{ form.captcha.errors }}\n            {{ form.captcha }}\n        {% endif %}\n        <div class=\"form-group\">\n          <div class=\"col-xs-12 col-sm-offset-2 col-sm-10 col-md-offset-2 col-md-10 submit\">\n            <button type=\"submit\" class=\"btn btn-primary btn-lg\" tabindex=\"4\">{% trans \"Password reset\" %}</button>\n          </div>\n        </div>\n      </form>\n    </div><!--/.col-*-->\n    <div class=\"col-sm-5 col-md-6 col-lg-7 details\">\n      <p>\n        <strong>{% trans \"Kiwi TCMS password reset\" %}!</strong>\n      </p>\n    </div><!--/.col-*-->\n  </div><!--/.row-->\n</div><!--/.container-->\n{% endblock %}\n"], "filenames": ["tcms/kiwi_auth/forms.py", "tcms/kiwi_auth/tests/test_views.py", "tcms/templates/registration/password_reset_form.html"], "buggy_code_start_loc": [96, 403, 20], "buggy_code_end_loc": [96, 405, 20], "fixing_code_start_loc": [97, 403, 21], "fixing_code_end_loc": [105, 422, 25], "type": "CWE-770", "message": "Kiwi TCMS, an open source test management system, does not impose rate limits in versions prior to 12.0. This makes it easier to attempt denial-of-service attacks against the Password reset page. An attacker could potentially send a large number of emails if they know the email addresses of users in Kiwi TCMS. Additionally that may strain SMTP resources. Users should upgrade to v12.0 or later to receive a patch. As potential workarounds, users may install and configure a rate-limiting proxy in front of Kiwi TCMS and/or configure rate limits on their email server when possible.", "other": {"cve": {"id": "CVE-2023-25171", "sourceIdentifier": "security-advisories@github.com", "published": "2023-02-15T15:15:11.653", "lastModified": "2023-02-24T17:34:28.320", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "Kiwi TCMS, an open source test management system, does not impose rate limits in versions prior to 12.0. This makes it easier to attempt denial-of-service attacks against the Password reset page. An attacker could potentially send a large number of emails if they know the email addresses of users in Kiwi TCMS. Additionally that may strain SMTP resources. Users should upgrade to v12.0 or later to receive a patch. As potential workarounds, users may install and configure a rate-limiting proxy in front of Kiwi TCMS and/or configure rate limits on their email server when possible."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:H/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "HIGH", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.9, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 2.2, "impactScore": 3.6}, {"source": "security-advisories@github.com", "type": "Secondary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 7.5, "baseSeverity": "HIGH"}, "exploitabilityScore": 3.9, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}, {"source": "security-advisories@github.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-770"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:kiwitcms:kiwi_tcms:*:*:*:*:*:*:*:*", "versionEndExcluding": "12.0", "matchCriteriaId": "F9830382-D694-402E-98CE-29217187D623"}]}]}], "references": [{"url": "https://github.com/kiwitcms/Kiwi/commit/761305d04f5910ba14cc04d1255a8f1afdbb87f3", "source": "security-advisories@github.com", "tags": ["Patch"]}, {"url": "https://github.com/kiwitcms/Kiwi/security/advisories/GHSA-7j9h-3jxf-3vrf", "source": "security-advisories@github.com", "tags": ["Vendor Advisory"]}, {"url": "https://huntr.dev/bounties/3b712cb6-3fa3-4f71-8562-7a7016c6262e", "source": "security-advisories@github.com", "tags": ["Permissions Required"]}, {"url": "https://kiwitcms.org/blog/kiwi-tcms-team/2023/02/15/kiwi-tcms-120/", "source": "security-advisories@github.com", "tags": ["Release Notes"]}]}, "github_commit_url": "https://github.com/kiwitcms/Kiwi/commit/761305d04f5910ba14cc04d1255a8f1afdbb87f3"}}