{"buggy_code": ["/*\n** The Sleuth Kit\n**\n** Brian Carrier [carrier <at> sleuthkit [dot] org]\n** Copyright (c) 2006-2011 Brian Carrier, Basis Technology.  All Rights reserved\n** Copyright (c) 2003-2005 Brian Carrier.  All rights reserved\n**\n** TASK\nv** Copyright (c) 2002-2003 Brian Carrier, @stake Inc.  All rights reserved\n**\n** Copyright (c) 1997,1998,1999, International Business Machines\n** Corporation and others. All Rights Reserved.\n*/\n\n/**\n*\\file yaffs.cpp\n* Contains the internal TSK YAFFS2 file system functions.\n*/\n\n/* TCT\n* LICENSE\n*\tThis software is distributed under the IBM Public License.\n* AUTHOR(S)\n*\tWietse Venema\n*\tIBM T.J. Watson Research\n*\tP.O. Box 704\n*\tYorktown Heights, NY 10598, USA\n--*/\n\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <string.h>\n\n#include \"tsk_fs_i.h\"\n#include \"tsk_yaffs.h\"\n#include \"tsk_fs.h\"\n\n/*\n* Implementation Notes:\n*    - As inode, we use object id and a version number derived from the \n*      number of unique sequence ids for the object still left in the\n*      file system.\n*\n*    - The version numbers start at 1 and increase as they get closer to\n*      the the latest version.  Version number 0 is a special version\n*      that is equivalent to the latest version (without having to know\n*      the latest version number.)\n*\n*    - Since inodes are composed using the object id in the least \n*      significant bits and the version up higher, requesting the\n*      inode that matches the object id you are looking for will\n*      retrieve the latest version of this object.\n*\n*    - Files always exist in the latest version of their parent directory \n*      only.\n*\n*    - Filenames are not unique even with attached version numbers, since\n*      version numbers are namespaced by inode.\n*\n*    - The cache stores a lot of info via the structure.  As this is\n*      used for investigations, we assume these decisions will be updated\n*      to expose the most useful view of this log based file system.  TSK\n*      doesn't seem have a real way to expose a versioned view of a log\n*      based file system like this.  Shoehorning it into the framework\n*      ends up dropping some information.  I looked at using resource \n*      streams as versions, but the abstraction breaks quickly.\n*\n*/\n\nstatic const int TWELVE_BITS_MASK = 0xFFF; // Only keep 12 bits\n\nstatic uint8_t \n    yaffsfs_read_header(YAFFSFS_INFO *yfs, YaffsHeader ** header, TSK_OFF_T offset);\nstatic uint8_t\n    yaffsfs_load_attrs(TSK_FS_FILE *file);\n\n/**\n * Generate an inode number based on the file's object and version numbers\n */\nstatic TSK_RETVAL_ENUM\n    yaffscache_obj_id_and_version_to_inode(uint32_t obj_id, uint32_t version_num, TSK_INUM_T *inode) {\n        if ((obj_id & ~YAFFS_OBJECT_ID_MASK) != 0) {\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_FS);\n            tsk_error_set_errstr(\n                \"yaffsfs_parse_image_load_cache: Max object ID %\" PRIu32 \" is invalid\", obj_id);\n            return TSK_ERR;\n        }\n\n        if ((version_num & ~YAFFS_VERSION_NUM_MASK) != 0) {\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_FS);\n            tsk_error_set_errstr(\n                \"yaffsfs_parse_image_load_cache: Max version number %\" PRIu32 \" is invalid\", version_num);\n            return TSK_ERR;\n        }\n\n        *inode = obj_id | (version_num << YAFFS_VERSION_NUM_SHIFT);\n        return TSK_OK;\n}\n\n/**\n * Given the TSK-generated inode address, extract the object id and version number from it\n */\nstatic TSK_RETVAL_ENUM\n    yaffscache_inode_to_obj_id_and_version(TSK_INUM_T inode, uint32_t *obj_id, uint32_t *version_num) {\n        *obj_id = inode & YAFFS_OBJECT_ID_MASK;\n        *version_num = (inode >> YAFFS_VERSION_NUM_SHIFT) & YAFFS_VERSION_NUM_MASK;\n\n        return TSK_OK;\n}\n\n/*\n* Order it like yaffs2.git does -- sort by (seq_num, offset/block)\n*/\nstatic int\n    yaffscache_chunk_compare(YaffsCacheChunk *curr, uint32_t addee_obj_id, TSK_OFF_T addee_offset, uint32_t addee_seq_number)\n{\n    if (curr->ycc_obj_id == addee_obj_id) {\n        if (curr->ycc_seq_number == addee_seq_number) {\n            if (curr->ycc_offset == addee_offset) {\n                return 0;\n            }\n            else if (curr->ycc_offset < addee_offset) {\n                return -1;\n            }\n            else {\n                return 1;\n            }\n        }\n        else if (curr->ycc_seq_number < addee_seq_number) {\n            return -1;\n        }\n        else {\n            return 1;\n        }\n    }\n    else if (curr->ycc_obj_id < addee_obj_id) {\n        return -1;\n    }\n    else {\n        return 1;\n    }\n}\n\nstatic TSK_RETVAL_ENUM\n    yaffscache_chunk_find_insertion_point(YAFFSFS_INFO *yfs, uint32_t obj_id, TSK_OFF_T offset, uint32_t seq_number, YaffsCacheChunk **chunk)\n{\n    YaffsCacheChunk *curr, *prev;\n\n    // Have we seen this obj_id? If not, add an entry for it\n    if(yfs->chunkMap->find(obj_id) == yfs->chunkMap->end()){\n        fflush(stderr);\n        YaffsCacheChunkGroup chunkGroup;\n        chunkGroup.cache_chunks_head = NULL;\n        chunkGroup.cache_chunks_tail = NULL;\n        yfs->chunkMap->insert(std::make_pair(obj_id, chunkGroup));\n    }\n\n    curr = yfs->chunkMap->operator[](obj_id).cache_chunks_head;\n    prev = NULL;\n\n    if (chunk == NULL) {\n        return TSK_ERR;\n    }\n\n    while(curr != NULL) {\n        // Compares obj id, then seq num, then offset. -1 => current < new\n        int cmp = yaffscache_chunk_compare(curr, obj_id, offset, seq_number);\n\n        if (cmp == 0) {\n            *chunk = curr;\n            return TSK_OK;\n        }\n        else if (cmp == 1) {\n            *chunk = prev;\n            return TSK_STOP;\n        }\n\n        prev = curr;\n        curr = curr->ycc_next;\n    }\n\n    *chunk = prev;\n    return TSK_STOP;\n}\n\n/**\n * Add a chunk to the cache. \n * @param yfs\n * @param offset Byte offset this chunk was found in (in the disk image)\n * @param seq_number Sequence number of this chunk\n * @param obj_id Object Id this chunk is associated with\n * @param parent_id Parent object ID that this chunk/object is associated with\n */\nstatic TSK_RETVAL_ENUM\n    yaffscache_chunk_add(YAFFSFS_INFO *yfs, TSK_OFF_T offset, uint32_t seq_number,\n    uint32_t obj_id, uint32_t chunk_id, uint32_t parent_id)\n{\n    TSK_RETVAL_ENUM result;\n    YaffsCacheChunk *prev;\n    YaffsCacheChunk *chunk;\n    if ((chunk = (YaffsCacheChunk*)tsk_malloc(sizeof(YaffsCacheChunk))) == NULL) {\n        return TSK_ERR;\n    }\n\n    chunk->ycc_offset = offset;\n    chunk->ycc_seq_number = seq_number;\n    chunk->ycc_obj_id = obj_id;\n    chunk->ycc_chunk_id = chunk_id;\n    chunk->ycc_parent_id = parent_id;\n\n    // Bit of a hack here. In some images, the root directory (obj_id = 1) lists iself as its parent\n    // directory, which can cause issues later when we get directory contents. To prevent this,\n    // if a chunk comes in with obj_id = 1 and parent_id = 1, manually set the parent ID to zero.\n    if((obj_id == 1) && (parent_id == 1)){\n        chunk->ycc_parent_id = 0;\n    }\n\n    // Find the chunk that should go right before the new chunk\n    result = yaffscache_chunk_find_insertion_point(yfs, obj_id, offset, seq_number, &prev);\n\n    if (result == TSK_ERR) {\n        return TSK_ERR;\n    }\n\n    if (prev == NULL) {\n        // No previous chunk - new chunk is the lowest we've seen and the new start of the list\n        chunk->ycc_prev = NULL;\n        chunk->ycc_next = yfs->chunkMap->operator[](obj_id).cache_chunks_head;\n    }\n    else {\n        chunk->ycc_prev = prev;\n        chunk->ycc_next = prev->ycc_next;\n    }\n\n    if (chunk->ycc_next != NULL) {\n        // If we're not at the end, set the prev pointer on the next chunk to point to our new one\n        chunk->ycc_next->ycc_prev = chunk;\n    }\n    else {\n        yfs->chunkMap->operator[](obj_id).cache_chunks_tail = chunk;\n    }\n\n    if (chunk->ycc_prev != NULL) {\n        // If we're not at the beginning, set the next pointer on the previous chunk to point at our new one\n        chunk->ycc_prev->ycc_next = chunk;\n    }\n    else {\n        yfs->chunkMap->operator[](obj_id).cache_chunks_head = chunk;\n    }\n\n    return TSK_OK;\n}\n\n\n/**\n * Get the file object from the cache.\n * @returns TSK_OK if it was found and TSK_STOP if we did not find it\n */\nstatic TSK_RETVAL_ENUM\n    yaffscache_object_find(YAFFSFS_INFO *yfs, uint32_t obj_id, YaffsCacheObject **obj)\n{\n    YaffsCacheObject *curr, *prev;\n    curr = yfs->cache_objects;\n    prev = NULL;\n\n    if (obj == NULL) {\n        return TSK_ERR;\n    }\n\n    while(curr != NULL) {\n        if (curr->yco_obj_id == obj_id) {\n            *obj = curr;\n            return TSK_OK;\n        }\n        else if (curr->yco_obj_id > obj_id) {\n            *obj = prev;\n            return TSK_STOP;\n        }\n\n        prev = curr;\n        curr = curr->yco_next;\n    }\n\n    *obj = prev;\n    return TSK_STOP;\n}\n\n/**\n * Add an object to the cache if it does not already exist in there.\n * @returns TSK_ERR  on error, TSK_OK otherwise.\n */\nstatic TSK_RETVAL_ENUM\n    yaffscache_object_find_or_add(YAFFSFS_INFO *yfs, uint32_t obj_id, YaffsCacheObject **obj)\n{\n    YaffsCacheObject *prev;\n    TSK_RETVAL_ENUM result;\n\n    if (obj == NULL) {\n        return TSK_ERR;\n    }\n\n    // Look for this obj_id in yfs->cache_objects\n    // If not found, add it in the correct spot\n    // yaffscache_object_find returns the last object with obj_id less than the one\n    // we were searching for, so use that to insert the new one in the list\n    result = yaffscache_object_find(yfs, obj_id, &prev);\n    if (result == TSK_OK) {\n        *obj = prev;\n        return TSK_OK;\n    }\n    else if (result == TSK_STOP) {\n        *obj = (YaffsCacheObject *) tsk_malloc(sizeof(YaffsCacheObject));\n        (*obj)->yco_obj_id = obj_id;\n        if (prev == NULL) {\n            (*obj)->yco_next = yfs->cache_objects;\n            yfs->cache_objects = *obj;\n        }\n        else {\n            (*obj)->yco_next = prev->yco_next;\n            prev->yco_next = (*obj);\n        }\n        return TSK_OK;\n    }\n    else {\n        *obj = NULL;\n        return TSK_ERR;\n    }\n}\n\nstatic TSK_RETVAL_ENUM\n    yaffscache_object_add_version(YaffsCacheObject *obj, YaffsCacheChunk *chunk)\n{\n    uint32_t ver_number;\n    YaffsCacheChunk *header_chunk = NULL;\n    YaffsCacheVersion *version;\n\n    // Going to try ignoring unlinked/deleted headers (objID 3 and 4)\n    if ((chunk->ycc_chunk_id == 0) && (chunk->ycc_parent_id != YAFFS_OBJECT_UNLINKED) \n        &&(chunk->ycc_parent_id != YAFFS_OBJECT_DELETED)) {\n            header_chunk = chunk;\n    }\n\n    /* If this is the second version (since last header_chunk is not NULL) and no\n    * header was added, get rid of this incomplete old version -- can't be\n    * reasonably recovered.\n    *\n    * TODO: These chunks are still in the structure and can be walked,\n    *       but I'm not sure how to represent this set of data chunks\n    *       with no metadata under TSK. This is rare and we don't have\n    *       a testcase for it now. Punting right now.\n    *\n    * Edit: Shouldn't get to this point anymore. Changes to \n    *       yaffscache_versions_insert_chunk make a version continue until it\n    *       has a header block.\n    */\n    if (obj->yco_latest != NULL) {\n        if (obj->yco_latest->ycv_header_chunk == NULL) {\n            YaffsCacheVersion *incomplete = obj->yco_latest;\n\n            if (tsk_verbose)\n                tsk_fprintf(stderr, \"yaffscache_object_add_version: \"\n                \"removed an incomplete first version (no header)\\n\");\n\n            obj->yco_latest = obj->yco_latest->ycv_prior;\n            free(incomplete);\n        }\n    }\n\n    if (obj->yco_latest != NULL) {\n        ver_number = obj->yco_latest->ycv_version + 1;\n\n        /* Until a new header is given, use the last seen header. */\n        if (header_chunk == NULL) {\n            header_chunk = obj->yco_latest->ycv_header_chunk;\n\n            // If we haven't seen a good header yet and we have a deleted/unlinked one, use it\n            if((header_chunk == NULL) && (chunk->ycc_chunk_id == 0)){\n                header_chunk = chunk;\n            }\n        }\n    }\n    else {\n        ver_number = 1;\n    }\n\n    if ((version = (YaffsCacheVersion *) tsk_malloc(sizeof(YaffsCacheVersion))) == NULL) {\n        return TSK_ERR;\n    }\n\n    version->ycv_prior = obj->yco_latest;\n    version->ycv_version = ver_number;\n    version->ycv_seq_number = chunk->ycc_seq_number;\n    version->ycv_header_chunk = header_chunk;\n    version->ycv_first_chunk = chunk;\n    version->ycv_last_chunk = chunk;\n\n    obj->yco_latest = version;\n\n    return TSK_OK;\n}\n\n/**\n * Add a chunk to its corresponding object in the cache. \n */\nstatic TSK_RETVAL_ENUM\n    yaffscache_versions_insert_chunk(YAFFSFS_INFO *yfs, YaffsCacheChunk *chunk)\n{\n    YaffsCacheObject *obj;\n    TSK_RETVAL_ENUM result;\n    YaffsCacheVersion *version;\n\n    // Building a list in yfs->cache_objects, sorted by obj_id\n    result = yaffscache_object_find_or_add(yfs, chunk->ycc_obj_id, &obj);\n    if (result != TSK_OK) {\n        return TSK_ERR;\n    }\n    version = obj->yco_latest;\n\n    /* First chunk in this object? */\n    if (version == NULL) {\n        yaffscache_object_add_version(obj, chunk);\n    }\n    else {\n        /* Chunk in the same update? */\n        if (chunk->ycc_seq_number == version->ycv_seq_number) {\n            version->ycv_last_chunk = chunk;\n            if ((chunk->ycc_chunk_id == 0) && (chunk->ycc_parent_id != YAFFS_OBJECT_UNLINKED) \n                &&(chunk->ycc_parent_id != YAFFS_OBJECT_DELETED)) {\n                    version->ycv_header_chunk = chunk;\n            }\n            else if((chunk->ycc_chunk_id == 0) && (version->ycv_header_chunk == NULL)){\n                version->ycv_header_chunk = chunk;\n            }\n        }\n        // If there was no header for the last version, continue adding to it instead\n        // of starting a new version. \n        else if(version->ycv_header_chunk == NULL){\n            version->ycv_seq_number = chunk->ycc_seq_number;\n            version->ycv_last_chunk = chunk;\n            if ((chunk->ycc_chunk_id == 0) && (chunk->ycc_parent_id != YAFFS_OBJECT_UNLINKED) \n                &&(chunk->ycc_parent_id != YAFFS_OBJECT_DELETED)) {\n                    version->ycv_header_chunk = chunk;\n            }\n            else if((chunk->ycc_chunk_id == 0) && (version->ycv_header_chunk == NULL)){\n                version->ycv_header_chunk = chunk;\n            }\n        }\n        else if(chunk->ycc_chunk_id == 0){   // Directories only have a header block\n            // If we're looking at a new version of a directory where the previous version had the same name, \n            // leave everything in the same version. Multiple versions of the same directory aren't really giving us \n            // any information.\n            YaffsHeader * newHeader;\n            yaffsfs_read_header(yfs, &newHeader, chunk->ycc_offset);\n            if((newHeader != NULL) && (newHeader->obj_type == YAFFS_TYPE_DIRECTORY)){\n                // Read in the old header\n                YaffsHeader * oldHeader;\n                yaffsfs_read_header(yfs, &oldHeader, version->ycv_header_chunk->ycc_offset);\n                if((oldHeader != NULL) && (oldHeader->obj_type == YAFFS_TYPE_DIRECTORY) &&\n                    (0 == strncmp(oldHeader->name, newHeader->name, YAFFS_HEADER_NAME_LENGTH))){\n                        version->ycv_seq_number = chunk->ycc_seq_number;\n                        version->ycv_last_chunk = chunk;\n                        version->ycv_header_chunk = chunk;\n                }\n                else{\n                    // The older header either isn't a directory or it doesn't have the same name, so leave it\n                    // as its own version\n                    yaffscache_object_add_version(obj, chunk);\n                }\n            }\n            else{\n                //  Not a directory\n                yaffscache_object_add_version(obj, chunk);\n            }\n        }\n        else{\n            //  Otherwise, add this chunk as the start of a new version\n            yaffscache_object_add_version(obj, chunk);\n        }\n    }\n\n    return TSK_OK;\n}\n\nstatic TSK_RETVAL_ENUM\n    yaffscache_versions_compute(YAFFSFS_INFO *yfs)\n{\n    std::map<unsigned int,YaffsCacheChunkGroup>::iterator iter;\n    for( iter = yfs->chunkMap->begin(); iter != yfs->chunkMap->end(); ++iter ) {\n        YaffsCacheChunk *chunk_curr = yfs->chunkMap->operator[](iter->first).cache_chunks_head;\n\n        while(chunk_curr != NULL) {\n            if (yaffscache_versions_insert_chunk(yfs, chunk_curr) != TSK_OK) {\n                return TSK_ERR;\n            }\n\n            chunk_curr = chunk_curr->ycc_next;\n        }\n    }\n\n    return TSK_OK;\n}\n\n/**\n * Callback for yaffscache_find_children()\n * @param obj Object that is a child\n * @param version Version of the object\n * @param args Pointer to what was passed into yaffscache_find_children\n */\ntypedef TSK_RETVAL_ENUM yc_find_children_cb(YaffsCacheObject *obj, YaffsCacheVersion *version, void *args);\n\n/**\n * Search the cache for objects that are children of the given address.\n * @param yfs\n * @param parent_inode Inode of folder/directory\n * @param cb Call back to call for each found child\n * @param args Pointer to structure that will be passed to cb\n * @returns TSK_ERR on error\n */\nstatic TSK_RETVAL_ENUM\n    yaffscache_find_children(YAFFSFS_INFO *yfs, TSK_INUM_T parent_inode, yc_find_children_cb cb, void *args)\n{\n    YaffsCacheObject *obj;\n\n    uint32_t parent_id, version_num;\n    if (yaffscache_inode_to_obj_id_and_version(parent_inode, &parent_id, &version_num) != TSK_OK) {\n        return TSK_ERR;\n    }\n\n    /* Iterate over all objects and all versions of the objects to see if one is the child\n     * of the given parent. */\n    for (obj = yfs->cache_objects; obj != NULL; obj = obj->yco_next) {\n        YaffsCacheVersion *version;\n        for (version = obj->yco_latest; version != NULL; version = version->ycv_prior) {\n            /* Is this an incomplete version? */\n            if (version->ycv_header_chunk == NULL) {\n                continue;\n            }\n\n            if (version->ycv_header_chunk->ycc_parent_id == parent_id) {\n                TSK_RETVAL_ENUM result = cb(obj, version, args);\n                if (result != TSK_OK)\n                    return result;\n            }\n        }\n    }\n\n    return TSK_OK;\n}\n\n/**\n * Lookup an object based on its inode.\n * @param yfs\n * @param inode\n * @param version [out] Pointer to store version of the object that was found (if inode had a version of 0)\n * @param obj_ret [out] Pointer to store found object into\n * @returns TSK_ERR on error. \n */\nstatic TSK_RETVAL_ENUM\n    yaffscache_version_find_by_inode(YAFFSFS_INFO *yfs, TSK_INUM_T inode, YaffsCacheVersion **version, YaffsCacheObject **obj_ret) {\n        uint32_t obj_id, version_num;\n        YaffsCacheObject *obj;\n        YaffsCacheVersion *curr;\n\n        if (version == NULL) {\n            return TSK_ERR;\n        }\n\n        // convert inode to obj and version and find it in cache\n        if (yaffscache_inode_to_obj_id_and_version(inode, &obj_id, &version_num) != TSK_OK) {\n            *version = NULL;\n            return TSK_ERR;\n        }\n\n        if (yaffscache_object_find(yfs, obj_id, &obj) != TSK_OK) {\n            *version = NULL;\n            return TSK_ERR;\n        }\n\n        if (version_num == 0) {\n            if (obj_ret != NULL) {\n                *obj_ret = obj;\n            }\n            *version = obj->yco_latest;\n            return TSK_OK;\n        }\n\n        // Find the requested version in the list. \n        for(curr = obj->yco_latest; curr != NULL; curr = curr->ycv_prior) {\n            if (curr->ycv_version == version_num) {\n                if (obj_ret != NULL) {\n                    *obj_ret = obj;\n                }\n                *version = curr;\n                return TSK_OK;\n            }\n        }\n\n        if (obj_ret != NULL) {\n            *obj_ret = NULL;\n        }\n        *version = NULL;\n        return TSK_ERR;\n}\n\nstatic void\n    yaffscache_object_dump(FILE *fp, YaffsCacheObject *obj)\n{\n    YaffsCacheVersion *next_version = obj->yco_latest;\n    YaffsCacheChunk *chunk = next_version->ycv_last_chunk;\n\n    fprintf(fp, \"Object %d\\n\", obj->yco_obj_id);\n    while(chunk != NULL && chunk->ycc_obj_id == obj->yco_obj_id) {\n        if (next_version != NULL && \n            chunk == next_version->ycv_last_chunk) {\n                fprintf(fp, \"  @%d: %p %p %p\\n\", \n                    next_version->ycv_version, \n                    (void*) next_version->ycv_header_chunk,\n                    (void*) next_version->ycv_first_chunk,\n                    (void*)next_version->ycv_last_chunk);\n                next_version = next_version->ycv_prior;\n        }\n\n        fprintf(fp, \"    + %p %08x %08x %0\" PRIxOFF \"\\n\",\n            (void*) chunk,\n            chunk->ycc_chunk_id,\n            chunk->ycc_seq_number,\n            chunk->ycc_offset);\n\n        chunk = chunk->ycc_prev;\n    }\n}\n\n/*\nstatic void\n    yaffscache_objects_dump(FILE *fp, YAFFSFS_INFO *yfs)\n{\n    YaffsCacheObject *obj;\n\n    for(obj = yfs->cache_objects; obj != NULL; obj = obj->yco_next)\n        yaffscache_object_dump(fp, obj);\n}\n*/\n\nstatic void\n    yaffscache_objects_stats(YAFFSFS_INFO *yfs, \n    unsigned int *obj_count,\n    uint32_t *obj_first, uint32_t *obj_last,\n    uint32_t *version_count,\n    uint32_t *version_first, uint32_t *version_last)\n{\n    YaffsCacheObject *obj;\n    YaffsCacheVersion *ver;\n\n    /* deleted and unlinked special objects don't have headers */\n    *obj_count = 2;\n    *obj_first = 0xffffffff;\n    *obj_last = 0;\n\n    *version_count = 0;\n    *version_first = 0xffffffff;\n    *version_last = 0;\n\n    for(obj = yfs->cache_objects; obj != NULL; obj = obj->yco_next) {\n        *obj_count += 1;\n        if (obj->yco_obj_id < *obj_first)\n            *obj_first = obj->yco_obj_id;\n        if (obj->yco_obj_id > *obj_last)\n            *obj_last = obj->yco_obj_id;\n\n        for(ver = obj->yco_latest; ver != NULL; ver = ver->ycv_prior) {\n            *version_count += 1;\n            if (ver->ycv_seq_number < *version_first)\n                *version_first = ver->ycv_seq_number;\n            if (ver->ycv_seq_number > *version_last)\n                *version_last = ver->ycv_seq_number;\n        }\n    }\n}\n\nstatic void\n    yaffscache_objects_free(YAFFSFS_INFO *yfs)\n{\n    if((yfs != NULL) && (yfs->cache_objects != NULL)){\n        YaffsCacheObject *obj = yfs->cache_objects;\n        while(obj != NULL) {\n            YaffsCacheObject *to_free = obj;\n\n            YaffsCacheVersion *ver = obj->yco_latest;\n            while(ver != NULL) {\n                YaffsCacheVersion *v_to_free = ver;\n                ver = ver->ycv_prior;\n                free(v_to_free);\n            }\n\n            obj = obj->yco_next;\n            free(to_free);\n        }\n    }\n}\n\nstatic void\n    yaffscache_chunks_free(YAFFSFS_INFO *yfs)\n{\n    if((yfs != NULL) && (yfs->chunkMap != NULL)){\n        // Free the YaffsCacheChunks in each ChunkGroup\n        std::map<unsigned int,YaffsCacheChunkGroup>::iterator iter;\n        for( iter = yfs->chunkMap->begin(); iter != yfs->chunkMap->end(); ++iter ) {\n            YaffsCacheChunk *chunk = yfs->chunkMap->operator[](iter->first).cache_chunks_head;\n            while(chunk != NULL) {\n                YaffsCacheChunk *to_free = chunk;\n                chunk = chunk->ycc_next;\n                free(to_free);\n            }\n        }\n\n        // Free the map\n        yfs->chunkMap->clear();\n        delete yfs->chunkMap;\n    }\n\n}\n\n\n\n/*\n* Parsing and helper functions\n*\n*\n*/\n\n/* Function to parse config file\n *\n * @param img_info Image info for this image\n * @param map<string, int> Stores values from config file indexed on parameter name\n * @returns YAFFS_CONFIG_STATUS One of \tYAFFS_CONFIG_OK, YAFFS_CONFIG_FILE_NOT_FOUND, or YAFFS_CONFIG_ERROR\n */\nstatic YAFFS_CONFIG_STATUS\nyaffs_load_config_file(TSK_IMG_INFO * a_img_info, std::map<std::string, std::string> & results){\n    size_t config_file_name_len;\n    TSK_TCHAR * config_file_name;\n    FILE* config_file;\n    char buf[1001];\n\n    // Ensure there is at least one image name\n    if(a_img_info->num_img < 1){\n        return YAFFS_CONFIG_ERROR;\n    }\n\n    // Construct the name of the config file from the first image name\n    config_file_name_len = TSTRLEN(a_img_info->images[0]);\n    config_file_name_len += TSTRLEN(YAFFS_CONFIG_FILE_SUFFIX);\n    config_file_name = (TSK_TCHAR *) tsk_malloc(sizeof(TSK_TCHAR) * (config_file_name_len + 1));\n\n    TSTRNCPY(config_file_name, a_img_info->images[0], TSTRLEN(a_img_info->images[0]) + 1);\n    TSTRNCAT(config_file_name, YAFFS_CONFIG_FILE_SUFFIX, TSTRLEN(YAFFS_CONFIG_FILE_SUFFIX) + 1);\n\n#ifdef TSK_WIN32\n    HANDLE hWin;\n\n    if ((hWin = CreateFile(config_file_name, GENERIC_READ,\n            FILE_SHARE_READ, 0, OPEN_EXISTING, 0,\n            0)) == INVALID_HANDLE_VALUE) {\n\n        // For the moment, assume that the file just doesn't exist, which isn't an error\n        free(config_file_name);\n        return YAFFS_CONFIG_FILE_NOT_FOUND;\n    }\n    config_file = _fdopen(_open_osfhandle((intptr_t) hWin, _O_RDONLY), \"r\");\n    if (config_file == NULL) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS);\n        tsk_error_set_errstr(\n                    \"yaffs_load_config: Error converting Windows handle to C handle\");\n        free(config_file_name);\n        CloseHandle(hWin);\n        return YAFFS_CONFIG_ERROR;\n    }\n#else\n    if (NULL == (config_file = fopen(config_file_name, \"r\"))) {\n        free(config_file_name);\n        return YAFFS_CONFIG_FILE_NOT_FOUND;\n    }\n#endif\n\n    while(fgets(buf, 1000, config_file) != NULL){\n\n        // Is it a comment?\n        if((buf[0] == '#') || (buf[0] == ';')){\n            continue;\n        }\n\n        // Is there a '=' ?\n        if(strchr(buf, '=') == NULL){\n            continue;\n        }\n\n        // Copy to strings while removing whitespace and converting to lower case\n        std::string paramName(\"\");\n        std::string paramVal(\"\");\n        \n        const char * paramNamePtr = strtok(buf, \"=\");\n        while(*paramNamePtr != '\\0'){\n            if(! isspace((char)(*paramNamePtr))){\n                paramName += tolower((char)(*paramNamePtr));\n            }\n            paramNamePtr++;\n        }\n    \n        const char * paramValPtr = strtok(NULL, \"=\");\n        while(*paramValPtr != '\\0'){\n            if(! isspace(*paramValPtr)){\n                paramVal += tolower((char)(*paramValPtr));\n            }\n            paramValPtr++;\n        }\n        \n        // Make sure this parameter is not already in the map\n        if(results.find(paramName) != results.end()){\n            // Duplicate parameter - return an error\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_FS);\n            tsk_error_set_errstr(\n                        \"yaffs_load_config: Duplicate parameter name in config file (\\\"%s\\\"). %s\", paramName.c_str(), YAFFS_HELP_MESSAGE);\n            fclose(config_file);\n            free(config_file_name);\n            return YAFFS_CONFIG_ERROR;\n        }\n\n        // Add this entry to the map\n        results[paramName] = paramVal;\n    }\n\n    fclose(config_file);\n    free(config_file_name);\n    return YAFFS_CONFIG_OK;\n}\n\n/*\n * Helper function for yaffs_validate_config\n * Tests that a string consists only of digits and has at least one digit\n * (Can modify later if we want negative fields to be valid)\n *\n * @param numStr String to test\n * @returns 1 on error, 0 on success\n */\nstatic int\nyaffs_validate_integer_field(std::string numStr){\n    unsigned int i;\n\n    // Test if empty\n    if(numStr.length() == 0){\n        return 1;\n    }\n\n    // Test each character\n    for(i = 0;i < numStr.length();i++){\n        if(isdigit(numStr[i]) == 0){\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\n/*\n * Function to validate the contents of the config file\n * Currently testing:\n *  All YAFFS_CONFIG fields should be integers (if they exist)\n *  Either need all three of YAFFS_CONFIG_SEQ_NUM_STR, YAFFS_CONFIG_OBJ_ID_STR, YAFFS_CONFIG_CHUNK_ID_STR\n *   or none of them\n *\n * @param paramMap Holds mapping of parameter name to parameter value\n * @returns 1 on error (invalid parameters), 0 on success\n */\nstatic int\nyaffs_validate_config_file(std::map<std::string, std::string> & paramMap){\n    int offset_field_count;\n\n    // Make a list of all fields to test\n    std::set<std::string> integerParams;\n    integerParams.insert(YAFFS_CONFIG_SEQ_NUM_STR);\n    integerParams.insert(YAFFS_CONFIG_OBJ_ID_STR);\n    integerParams.insert(YAFFS_CONFIG_CHUNK_ID_STR);\n    integerParams.insert(YAFFS_CONFIG_PAGE_SIZE_STR);\n    integerParams.insert(YAFFS_CONFIG_SPARE_SIZE_STR);\n    integerParams.insert(YAFFS_CONFIG_CHUNKS_PER_BLOCK_STR);\n\n    // If the parameter is set, verify that the value is an int\n    for(std::set<std::string>::iterator it = integerParams.begin();it != integerParams.end();it++){\n        if((paramMap.find(*it) != paramMap.end()) && \n            (0 != yaffs_validate_integer_field(paramMap[*it]))){\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_FS);\n            tsk_error_set_errstr(\n                        \"yaffs_validate_config_file: Empty or non-integer value for Yaffs2 parameter \\\"%s\\\". %s\", (*it).c_str(), YAFFS_HELP_MESSAGE);\n            return 1;\n        }\n    }\n\n    // Check that we have all three spare offset fields, or none of the three\n    offset_field_count = 0;\n    if(paramMap.find(YAFFS_CONFIG_SEQ_NUM_STR) != paramMap.end()){\n        offset_field_count++;\n    }\n    if(paramMap.find(YAFFS_CONFIG_OBJ_ID_STR) != paramMap.end()){\n        offset_field_count++;\n    }\n    if(paramMap.find(YAFFS_CONFIG_CHUNK_ID_STR) != paramMap.end()){\n        offset_field_count++;\n    }\n\n    if(! ((offset_field_count == 0) || (offset_field_count == 3))){\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_FS);\n            tsk_error_set_errstr(\n                        \"yaffs_validate_config_file: Require either all three spare offset fields or none. %s\", YAFFS_HELP_MESSAGE);\n            return 1;\n    }\n\n    // Make sure there aren't any unexpected fields present\n    for(std::map<std::string, std::string>::iterator it = paramMap.begin(); it != paramMap.end();it++){\n        if(integerParams.find(it->first) == integerParams.end()){\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_FS);\n            tsk_error_set_errstr(\n                        \"yaffs_validate_config_file: Found unexpected field in config file (\\\"%s\\\"). %s\", it->first.c_str(), YAFFS_HELP_MESSAGE);\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\n/*\n* Function to attempt to determine the layout of the yaffs spare area.\n* Results of the analysis (if the format could be determined) will be stored\n* in yfs variables. \n*\n* @param yfs File system being analyzed\n* @param maxBlocksToTest Number of block groups to scan to detect spare area or 0 if there is no limit.\n* @returns TSK_ERR if format could not be detected and TSK_OK if it could be.\n*/\nstatic TSK_RETVAL_ENUM \nyaffs_initialize_spare_format(YAFFSFS_INFO * yfs, TSK_OFF_T maxBlocksToTest){\n\n    // Testing parameters - can all be changed\n    unsigned int blocksToTest = 10;  // Number of blocks (64 chunks) to test\n    unsigned int chunksToTest = 10;  // Number of chunks to test in each block \n    unsigned int minChunksRead = 10; // Minimum number of chunks we require to run the test (we might not get the full number we want to test for a very small file)\n\n    unsigned int chunkSize = yfs->page_size + yfs->spare_size;\n    unsigned int blockSize = yfs->chunks_per_block * chunkSize;\n\n    TSK_FS_INFO *fs = &(yfs->fs_info);\n    unsigned char *spareBuffer;\n\n    unsigned int blockIndex;\n    unsigned int chunkIndex;\n\n    unsigned int currentOffset;\n\n    unsigned char * allSpares;\n    unsigned int allSparesLength;\n    \n    TSK_OFF_T maxBlocks;\n\n    bool skipBlock;\n    int goodOffset;\n    unsigned int nGoodSpares;\n    unsigned int nBlocksTested;\n\n    int okOffsetFound = 0;   // Used as a flag for if we've found an offset that sort of works but doesn't seem great\n    int goodOffsetFound = 0; // Flag to mark that we've found an offset that also passed secondary testing\n    int bestOffset = 0;\n\n    bool allSameByte; // Used in test that the spare area fields not be one repeated byte\n\n    unsigned int i;\n\n    int thisChunkBase;\n    int lastChunkBase;\n\n    // The spare area needs to be at least 16 bytes to run the test\n    if(yfs->spare_size < 16){\n        if(tsk_verbose && (! yfs->autoDetect)){\n            tsk_fprintf(stderr,\n                \"yaffs_initialize_spare_format failed - given spare size (%d) is not large enough to contain needed fields\\n\", yfs->spare_size);\n        }\n        return TSK_ERR;\n    }\n\n    if ((spareBuffer = (unsigned char*) tsk_malloc(yfs->spare_size)) == NULL) {\n        return TSK_ERR;\n    }\n\n    allSparesLength = yfs->spare_size * blocksToTest * chunksToTest;\n    if ((allSpares = (unsigned char*) tsk_malloc(allSparesLength)) == NULL) {\n        free(spareBuffer);\n        return TSK_ERR;\n    }\n\n    // Initialize the pointers to one of the configurations we've seen (thought these defaults should not get used)\n    yfs->spare_seq_offset = 0;\n    yfs->spare_obj_id_offset = 4;\n    yfs->spare_chunk_id_offset = 8;\n    yfs->spare_nbytes_offset = 12;\n\n    // Assume the data we want is 16 consecutive bytes in the order:\n    //  seq num, obj id, chunk id, byte count\n    //  (not sure we're guaranteed this but we wouldn't be able to deal with the alternative anyway)\n    // Seq num is the important one. This number is constant in each block (block = 64 chunks), meaning\n    //  all chunks in a block will share the same sequence number. The YAFFS2 descriptions would seem to\n    //  indicate it should be different for each block, but this doesn't seem to always be the case.\n    //  In particular we frequently see the 0x1000 seq number used over multiple blocks, but this isn't the only\n    //  observed exception.\n\n    // Calculate the number of blocks in the image\n    maxBlocks = yfs->fs_info.img_info->size / (yfs->chunks_per_block * chunkSize);\n\n    // If maxBlocksToTest = 0 (unlimited), set it to the total number of blocks\n    // Also reduce the number of blocks to test if it is larger than the total number of blocks\n    if ((maxBlocksToTest == 0) || (maxBlocksToTest > maxBlocks)){\n        maxBlocksToTest = maxBlocks;\n    }\n\n    nGoodSpares = 0;\n    nBlocksTested = 0;\n    for (TSK_OFF_T blockIndex = 0;blockIndex < maxBlocksToTest;blockIndex++){\n\n        // Read the last spare area that we want to test first\n        TSK_OFF_T offset = (TSK_OFF_T)blockIndex * blockSize + (chunksToTest - 1) * chunkSize + yfs->page_size;\n        ssize_t cnt = tsk_img_read(fs->img_info, offset, (char *) spareBuffer,\n            yfs->spare_size);\n        if ((cnt < 0) || ((unsigned int)cnt < yfs->spare_size)) {\n            break;\n        }\n\n        // Is the spare all 0xff / 0x00?\n        // If not, we know we should have all allocated chunks since YAFFS2 writes sequentially in a block\n        //  - can't have an unallocated chunk followed by an allocated one\n        // We occasionally see almost all null spare area with a few 0xff, which is not a valid spare.\n        skipBlock = true;\n        for (i = 0;i < yfs->spare_size;i++){\n            if((spareBuffer[i] != 0xff) && (spareBuffer[i] != 0x00)){\n                skipBlock = false;\n                break;\n            }\n        }\n\n        if (skipBlock){\n            continue;\n        }\n\n        // If this block is potentialy valid (i.e., the spare contains something besides 0x00 and 0xff), copy all the spares into\n        // the big array of extracted spare areas\n\n        // Copy this spare area\n        nGoodSpares++;\n        for (i = 0;i < yfs->spare_size;i++){\n            allSpares[nBlocksTested * yfs->spare_size * chunksToTest + (chunksToTest - 1) * yfs->spare_size + i] = spareBuffer[i];\n        }\n\n        // Copy all earlier spare areas in the block\n        for (chunkIndex = 0;chunkIndex < chunksToTest - 1;chunkIndex++){\n            offset = blockIndex * blockSize + chunkIndex * chunkSize + yfs->page_size;\n            cnt = tsk_img_read(fs->img_info, offset, (char *) spareBuffer,\n                yfs->spare_size);\n            if ((cnt < 0) || ((unsigned int)cnt < yfs->spare_size)) {\n                // We really shouldn't run out of data here since we already read in the furthest entry\n                break; // Break out of chunksToTest loop\n            }\n\n            nGoodSpares++;\n            for(i = 0;i < yfs->spare_size;i++){\n                allSpares[nBlocksTested * yfs->spare_size * chunksToTest + chunkIndex * yfs->spare_size + i] = spareBuffer[i];\n            }\n        }\n\n        // Record that we've found a potentially valid block\n        nBlocksTested++;\n\n        // If we've found enough potentailly valid blocks, break\n        if (nBlocksTested >= blocksToTest){\n            break;\n        }\n    }\n\n    // Make sure we read enough data to reasonably perform the testing\n    if (nGoodSpares < minChunksRead){\n\n        if (tsk_verbose && (! yfs->autoDetect)){\n            tsk_fprintf(stderr,\n                \"yaffs_initialize_spare_format failed - not enough potentially valid data could be read\\n\");\n        }\n\n        free(spareBuffer);\n        free(allSpares);\n        return TSK_ERR;\n    }\n\n    if (tsk_verbose && (! yfs->autoDetect)){\n        tsk_fprintf(stderr,\n            \"yaffs_initialize_spare_format: Testing potential offsets for the sequence number in the spare area\\n\");\n    }\n\n    // Print out the collected spare areas if we're in verbose mode\n    if(tsk_verbose && (! yfs->autoDetect)){\n        for(blockIndex = 0;blockIndex < nBlocksTested;blockIndex++){\n            for(chunkIndex = 0;chunkIndex < chunksToTest;chunkIndex++){\n                for(i = 0;i < yfs->spare_size;i++){\n                    fprintf(stderr, \"%02x\", allSpares[blockIndex * yfs->spare_size * chunksToTest + chunkIndex * yfs->spare_size + i]);\n                }\n                fprintf(stderr, \"\\n\");\n            }\n        }\n    }\n\n    // Test all indices into the spare area (that leave enough space for all 16 bytes)\n    for(currentOffset = 0;currentOffset <= yfs->spare_size - 16;currentOffset++){\n        goodOffset = 1;\n        for(blockIndex = 0;blockIndex < nBlocksTested;blockIndex++){\n            for(chunkIndex = 1;chunkIndex < chunksToTest;chunkIndex++){\n\n                lastChunkBase = blockIndex * yfs->spare_size * chunksToTest + (chunkIndex - 1) * yfs->spare_size;\n                thisChunkBase = lastChunkBase + yfs->spare_size;\n\n                // Seq num should not be all 0xff (we tested earlier that the chunk has been initialized)\n                if((0xff == allSpares[thisChunkBase + currentOffset]) &&\n                    (0xff == allSpares[thisChunkBase + currentOffset + 1]) &&\n                    (0xff == allSpares[thisChunkBase + currentOffset + 2]) &&\n                    (0xff == allSpares[thisChunkBase + currentOffset + 3])){\n                        if(tsk_verbose && (! yfs->autoDetect)){\n                            tsk_fprintf(stderr,\n                                \"yaffs_initialize_spare_format: Eliminating offset %d - invalid sequence number 0xffffffff\\n\", \n                                currentOffset);\n                        }\n                        goodOffset = 0;\n                        break;\n                }\n\n                // Seq num should not be zero\n                if((0 == allSpares[thisChunkBase + currentOffset]) &&\n                    (0 == allSpares[thisChunkBase + currentOffset + 1]) &&\n                    (0 == allSpares[thisChunkBase + currentOffset + 2]) &&\n                    (0 == allSpares[thisChunkBase + currentOffset + 3])){\n                        if(tsk_verbose && (! yfs->autoDetect)){\n                            tsk_fprintf(stderr,\n                                \"yaffs_initialize_spare_format: Eliminating offset %d - invalid sequence number 0\\n\", \n                                currentOffset);\n                        }\n                        goodOffset = 0;\n                        break;\n                }\n\n                // Seq num should match the previous one in the block\n                if((allSpares[lastChunkBase + currentOffset] != allSpares[thisChunkBase + currentOffset]) ||\n                    (allSpares[lastChunkBase + currentOffset + 1] != allSpares[thisChunkBase + currentOffset + 1]) ||\n                    (allSpares[lastChunkBase + currentOffset + 2] != allSpares[thisChunkBase + currentOffset + 2]) ||\n                    (allSpares[lastChunkBase + currentOffset + 3] != allSpares[thisChunkBase + currentOffset + 3])){\n                        if(tsk_verbose && (! yfs->autoDetect)){\n                            tsk_fprintf(stderr,\n                                \"yaffs_initialize_spare_format: Eliminating offset %d - did not match previous chunk sequence number\\n\", \n                                currentOffset);\n                        }\n                        goodOffset = 0;\n                        break;\n                }\n\n                // Obj id should not be zero\n                if((0 == allSpares[thisChunkBase + currentOffset + 4]) &&\n                    (0 == allSpares[thisChunkBase + currentOffset + 5]) &&\n                    (0 == allSpares[thisChunkBase + currentOffset + 6]) &&\n                    (0 == allSpares[thisChunkBase + currentOffset + 7])){\n                        if(tsk_verbose && (! yfs->autoDetect)){\n                            tsk_fprintf(stderr,\n                                \"yaffs_initialize_spare_format: Eliminating offset %d - invalid object id 0\\n\", \n                                currentOffset);\n                        }\n                        goodOffset = 0;\n                        break;\n                }\n\n                // All 16 bytes should not be the same\n                // (It is theoretically possible that this could be valid, but incredibly unlikely)\n                allSameByte = true;\n                for(i = 1;i < 16;i++){\n                    if(allSpares[thisChunkBase + currentOffset] != allSpares[thisChunkBase + currentOffset + i]){\n                        allSameByte = false;\n                        break;\n                    }\n                }\n                if(allSameByte){\n                    if(tsk_verbose && (! yfs->autoDetect)){\n                        tsk_fprintf(stderr,\n                            \"yaffs_initialize_spare_format: Eliminating offset %d - all repeated bytes\\n\", \n                            currentOffset);\n                    }\n                    goodOffset = 0;\n                    break;\n                }\n\n            } // End of loop over chunks\n\n            if(!goodOffset){ // Break out of loop over blocks\n                break;\n            }\n        }\n        if(goodOffset){\n\n            // Note that we've found an offset that is at least promising\n            if((! goodOffsetFound) && (! okOffsetFound)){\n                bestOffset = currentOffset;\n            }\n            okOffsetFound = 1;\n\n            if(tsk_verbose && (! yfs->autoDetect)){\n                tsk_fprintf(stderr,\n                    \"yaffs_initialize_spare_format: Found potential spare offsets:  %d (sequence number), %d (object id), %d (chunk id), %d (n bytes)\\n\",\n                    currentOffset, currentOffset+4, currentOffset+8, currentOffset+12);\n            }\n\n            // Now do some more tests\n            // Really need some more real-world test data to do this right.\n            int possibleError = 0;\n\n            // We probably don't want the first byte to always be 0xff\n            int firstByteFF = 1;\n            for(blockIndex = 0;blockIndex < nBlocksTested;blockIndex++){\n                for(chunkIndex = 1;chunkIndex < chunksToTest;chunkIndex++){\n                    if(allSpares[blockIndex * yfs->spare_size * chunksToTest + chunkIndex * yfs->spare_size + currentOffset] != 0xff){\n                        firstByteFF = 0;\n                    }\n                }\n            }\n\n            if(firstByteFF){\n                if(tsk_verbose && (! yfs->autoDetect)){\n                    tsk_fprintf(stderr,\n                        \"yaffs_initialize_spare_format:  Previous data starts with all 0xff bytes. Looking for better offsets.\\n\");\n                }\n                possibleError = 1;\n            }\n\n            if(! possibleError){\n\n                // If we already have a good offset, print this one out but don't record it\n                if(! goodOffsetFound){\n\n                    goodOffsetFound = 1;\n                    bestOffset = currentOffset;\n\n                    // Offset passed additional testing and we haven't seen an earlier good one, so go ahead and use it\n                    if(tsk_verbose && (! yfs->autoDetect)){\n                        tsk_fprintf(stderr,\n                            \"yaffs_initialize_spare_format:  Previous offsets appear good - will use as final offsets\\n\");\n                    }\n\n                }\n                else{\n                    // Keep using the old one\n                    if(tsk_verbose && (! yfs->autoDetect)){\n                        tsk_fprintf(stderr,\n                            \"yaffs_initialize_spare_format:  Previous offsets appear good but staying with earlier valid ones\\n\");\n                    }\n                }\n            }\n        }\n    }\n\n    free(spareBuffer);\n    free(allSpares);\n\n    if(okOffsetFound || goodOffsetFound){\n        // Record everything\n        yfs->spare_seq_offset = bestOffset;\n        yfs->spare_obj_id_offset = bestOffset + 4;\n        yfs->spare_chunk_id_offset = bestOffset + 8;\n        yfs->spare_nbytes_offset = bestOffset + 12;\n\n        if(tsk_verbose && (! yfs->autoDetect)){\n            tsk_fprintf(stderr,\n                \"yaffs_initialize_spare_format: Final offsets: %d (sequence number), %d (object id), %d (chunk id), %d (n bytes)\\n\",\n                bestOffset, bestOffset+4, bestOffset+8, bestOffset+12);\n            tsk_fprintf(stderr,\n                \"If these do not seem valid: %s\\n\", YAFFS_HELP_MESSAGE);\n        }\n        return TSK_OK;\n    }\n    else{\n        return TSK_ERR;\n    }\n}\n\n/**\n* yaffsfs_read_header( ... )\n*\n*/\nstatic uint8_t \n    yaffsfs_read_header(YAFFSFS_INFO *yfs, YaffsHeader ** header, TSK_OFF_T offset)\n{\n    unsigned char *hdr;\n    ssize_t cnt;\n    YaffsHeader *head;\n    TSK_FS_INFO *fs = &(yfs->fs_info);\n\n    if ((hdr = (unsigned char*) tsk_malloc(yfs->page_size)) == NULL) {\n        return 1;\n    }\n\n    cnt = tsk_img_read(fs->img_info, offset, (char *) hdr,\n        yfs->page_size);\n    if ((cnt < 0) || ((unsigned int)cnt < yfs->page_size)) {\n        free(hdr);\n        return 1;\n    }\n\n    if ((head = (YaffsHeader*) tsk_malloc( sizeof(YaffsHeader))) == NULL) {\n        free(hdr);\n        return 1;\n    }\n\n    memcpy(&head->obj_type, hdr, 4);\n    memcpy(&head->parent_id, &hdr[4], 4);\n    memcpy(head->name, (char*) &hdr[0xA], YAFFS_HEADER_NAME_LENGTH);\n    memcpy(&head->file_mode, &hdr[0x10C], 4);\n    memcpy(&head->user_id, &hdr[0x110], 4);\n    memcpy(&head->group_id, &hdr[0x114], 4);\n    memcpy(&head->atime, &hdr[0x118], 4);\n    memcpy(&head->mtime, &hdr[0x11C], 4);\n    memcpy(&head->ctime, &hdr[0x120], 4);\n    memcpy(&head->file_size, &hdr[0x124], 4);\n    memcpy(&head->equivalent_id, &hdr[0x128], 4);\n    memcpy(head->alias, (char*) &hdr[0x12C], YAFFS_HEADER_ALIAS_LENGTH);\n\n    //memcpy(&head->rdev_mode, &hdr[0x1CC], 4);\n    //memcpy(&head->win_ctime, &hdr[0x1D0], 8);\n    //memcpy(&head->win_atime, &hdr[0x1D8], 8);\n    //memcpy(&head->win_mtime, &hdr[0x1E0], 8);\n    //memcpy(&head->inband_obj_id, &hdr[0x1E8], 4);\n    //memcpy(&head->inband_is_shrink, &hdr[0x1EC], 4);\n\n    // NOTE: This isn't in Android 3.3 kernel but is in YAFFS2 git\n    //memcpy(&head->file_size_high, &hdr[0x1F0], 4);\n\n    free(hdr);\n\n    *header = head;\n    return 0;\n}\n\n/**\n* Read and parse the YAFFS2 tags in the NAND spare bytes.\n*\n* @param info is a YAFFS fs handle\n* @param spare YaffsSpare object to be populated\n* @param offset, offset to read from\n*\n* @returns 0 on success and 1 on error\n*/\nstatic uint8_t \n    yaffsfs_read_spare(YAFFSFS_INFO *yfs, YaffsSpare ** spare, TSK_OFF_T offset)\n{\n    unsigned char *spr;\n    ssize_t cnt;\n    YaffsSpare *sp;\n    TSK_FS_INFO *fs = &(yfs->fs_info);\n\n    uint32_t seq_number;\n    uint32_t object_id;\n    uint32_t chunk_id;\n\n    // Should have checked this by now, but just in case\n    if((yfs->spare_seq_offset + 4 > yfs->spare_size) ||\n        (yfs->spare_obj_id_offset + 4 > yfs->spare_size) ||\n        (yfs->spare_chunk_id_offset + 4 > yfs->spare_size)){\n            return 1;\n    }\n\n    if ((spr = (unsigned char*) tsk_malloc(yfs->spare_size)) == NULL) {\n        return 1;\n    }\n\n    if (yfs->spare_size < 46) { // Why is this 46?\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_ARG);\n        tsk_error_set_errstr(\"yaffsfs_read_spare: spare size is too small\");\n        free(spr);\n        return 1;\n    }\n\n    cnt = tsk_img_read(fs->img_info, offset, (char*) spr, yfs->spare_size);\n    if ((cnt < 0) || ((unsigned int)cnt < yfs->spare_size)) {\n        // couldn't read sufficient bytes...\n        if (spare) {\n            free(spr);\n            *spare = NULL;\n        }\n        return 1;\n    }\n\n    if ((sp = (YaffsSpare*) tsk_malloc(sizeof(YaffsSpare))) == NULL) {\n        return 1;\n    }\n\n    memset(sp, 0, sizeof(YaffsSpare));\n\n    /*\n    * Complete read of the YAFFS2 spare\n    */\n\n\n    // The format of the spare area should have been determined earlier\n    memcpy(&seq_number, &spr[yfs->spare_seq_offset], 4);\n    memcpy(&object_id, &spr[yfs->spare_obj_id_offset], 4);\n    memcpy(&chunk_id, &spr[yfs->spare_chunk_id_offset], 4);\n\n    if ((YAFFS_SPARE_FLAGS_IS_HEADER & chunk_id) != 0) {\n\n        sp->seq_number = seq_number;\n        sp->object_id = object_id & ~YAFFS_SPARE_OBJECT_TYPE_MASK;\n        sp->chunk_id = 0;\n\n        sp->has_extra_fields = 1;\n        sp->extra_parent_id = chunk_id & YAFFS_SPARE_PARENT_ID_MASK;\n        sp->extra_object_type =\n            (object_id & YAFFS_SPARE_OBJECT_TYPE_MASK)\n            >> YAFFS_SPARE_OBJECT_TYPE_SHIFT;\n    }\n    else {\n        sp->seq_number = seq_number;\n        sp->object_id = object_id;\n        sp->chunk_id = chunk_id;\n\n        sp->has_extra_fields = 0;\n    }\n\n    free(spr);\n    *spare = sp;\n\n    return 0;\n}\n\nstatic uint8_t \n    yaffsfs_is_spare_valid(YAFFSFS_INFO * /*yfs*/, YaffsSpare *spare)\n{\n    if (spare == NULL) {\n        return 1;\n    }\n\n    if ((spare->object_id > YAFFS_MAX_OBJECT_ID) ||\n        (spare->seq_number < YAFFS_LOWEST_SEQUENCE_NUMBER) ||\n        (spare->seq_number > YAFFS_HIGHEST_SEQUENCE_NUMBER)) {\n            return 1;\n    }\n\n    return 0;\n}\n\nstatic uint8_t \n    yaffsfs_read_chunk(YAFFSFS_INFO *yfs,\n    YaffsHeader **header, YaffsSpare **spare, TSK_OFF_T offset)\n{\n    TSK_OFF_T header_offset = offset;\n    TSK_OFF_T spare_offset = offset + yfs->page_size; \n\n    if (header == NULL || spare == NULL) {\n        return 1;\n    }\n\n    if (yaffsfs_read_header(yfs, header, header_offset) != 0) {\n        return 1;\n    }\n\n    if (yaffsfs_read_spare(yfs, spare, spare_offset) != 0) {\n        free(*header);\n        *header = NULL;\n        return 1;\n    }\n\n    return 0;\n}\n\n/**\n * Cycle through the entire image and populate the cache with objects as they are found.\n */\nstatic uint8_t \n    yaffsfs_parse_image_load_cache(YAFFSFS_INFO * yfs)\n{\n    uint8_t status = TSK_OK;\n    uint32_t nentries = 0;\n    YaffsSpare *spare = NULL;\n\n    uint8_t tempBuf[8];\n    uint32_t parentID;\n\n    if (yfs->cache_objects)\n        return 0;\n\n    for(TSK_OFF_T offset = 0;offset < yfs->fs_info.img_info->size;offset += yfs->page_size + yfs->spare_size){\n        status = yaffsfs_read_spare( yfs, &spare, offset + yfs->page_size);\n        if (status != TSK_OK) {\n            break;\n        }\n\n        if (yaffsfs_is_spare_valid(yfs, spare) == TSK_OK) {\n\n\n            if((spare->has_extra_fields) || (spare->chunk_id != 0)){\n                yaffscache_chunk_add(yfs,\n                    offset, \n                    spare->seq_number, \n                    spare->object_id, \n                    spare->chunk_id, \n                    spare->extra_parent_id);\n            }\n            else{\n                // If we have a header block and didn't extract it already from the spare, get the parent ID from\n                // the non-spare data\n                if(8 == tsk_img_read(yfs->fs_info.img_info, offset, (char*) tempBuf, 8)){\n                    memcpy(&parentID, &tempBuf[4], 4);\n\n                    yaffscache_chunk_add(yfs,\n                        offset, \n                        spare->seq_number, \n                        spare->object_id, \n                        spare->chunk_id, \n                        parentID);\n                }\n                else{\n                    // Really shouldn't happen\n                    fprintf(stderr, \"Error reading header to get parent id at offset %\" PRIxOFF \"\\n\", offset);\n                    yaffscache_chunk_add(yfs,\n                        offset, \n                        spare->seq_number, \n                        spare->object_id, \n                        spare->chunk_id, \n                        0);\n                }\n            }\n        }\n\n        free(spare);\n        spare = NULL;\n\n        ++nentries;\n    }\n\n    if (tsk_verbose)\n        fprintf(stderr, \"yaffsfs_parse_image_load_cache: read %d entries\\n\", nentries);\n\n    if (tsk_verbose)\n        fprintf(stderr, \"yaffsfs_parse_image_load_cache: started processing chunks for version cache...\\n\");\n    fflush(stderr);\n\n    // At this point, we have a list of chunks sorted by obj id, seq number, and offset\n    // This makes the list of objects in cache_objects, which link to different versions\n    yaffscache_versions_compute(yfs);\n\n    if (tsk_verbose)\n        fprintf(stderr, \"yaffsfs_parse_image_load_cache: done version cache!\\n\");\n    fflush(stderr);\n\n\n    // Having multiple inodes point to the same object seems to cause trouble in TSK, especially in orphan file detection,\n    //  so set the version number of the final one to zero.\n    // While we're at it, find the highest obj_id and the highest version (before resetting to zero)\n    YaffsCacheObject * currObj = yfs->cache_objects;\n    YaffsCacheVersion * currVer;\n    while(currObj != NULL){\n        if(currObj->yco_obj_id > yfs->max_obj_id){\n            yfs->max_obj_id = currObj->yco_obj_id;\n        }\n\n        currVer = currObj->yco_latest;\n        if(currVer->ycv_version > yfs->max_version){\n            yfs->max_version = currVer->ycv_version;\n        }\n\n        currVer->ycv_version = 0;\n        currObj = currObj->yco_next;\n    }\n\n    // Use the max object id and version number to construct an upper bound on the inode\n    TSK_INUM_T max_inum = 0;\n    if (TSK_OK != yaffscache_obj_id_and_version_to_inode(yfs->max_obj_id, yfs->max_version, &max_inum)) {\n        return TSK_ERR;\n    }\n    yfs->fs_info.last_inum = max_inum + 1; // One more for the orphan dir\n\n    // Make sure the orphan dir is greater than the root dir\n    if (yfs->fs_info.last_inum <= yfs->fs_info.root_inum) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS);\n        tsk_error_set_errstr(\n            \"yaffsfs_parse_image_load_cache: Maximum inum %\" PRIuINUM \" is not greater than the root inum\", yfs->fs_info.last_inum);\n        return TSK_ERR;\n    }\n\n    return TSK_OK;\n}\n\n// A version is allocated if:\n//   1. This version is pointed to by yco_latest\n//   2. This version didn't have a delete/unlinked header after the most recent copy of the normal header\nstatic uint8_t yaffs_is_version_allocated(YAFFSFS_INFO * yfs, TSK_INUM_T inode){\n    YaffsCacheObject * obj;\n    YaffsCacheVersion * version;\n    YaffsCacheChunk * curr;\n\n    TSK_RETVAL_ENUM result = yaffscache_version_find_by_inode(yfs, inode, &version, &obj);\n    if (result != TSK_OK) {\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"yaffs_is_version_allocated: yaffscache_version_find_by_inode failed! (inode: %d)\\n\", inode);\n        return 0;\n    }\n\n    if(obj->yco_latest == version){\n        curr = obj->yco_latest->ycv_header_chunk;\n        while(curr != NULL){\n            // We're looking for a newer unlinked or deleted header. If one exists, then this object should be considered unallocated\n            if((curr->ycc_parent_id == YAFFS_OBJECT_UNLINKED) || (curr->ycc_parent_id == YAFFS_OBJECT_DELETED)){\n                return 0;\n            }\n            curr = curr ->ycc_next;\n        }\n        return 1;\n    }\n    else{\n        return 0;\n    }\n\n}\n\n/*\n* TSK integration\n*\n*\n*/\n\nstatic uint8_t\n    yaffs_make_directory(YAFFSFS_INFO *yaffsfs, TSK_FS_FILE *a_fs_file, \n    TSK_INUM_T inode, const char *name)\n{\n    TSK_FS_FILE *fs_file = a_fs_file;\n\n\n    fs_file->meta->type = TSK_FS_META_TYPE_DIR;\n    fs_file->meta->mode = (TSK_FS_META_MODE_ENUM)0;\n    fs_file->meta->nlink = 1;\n\n    if((inode == YAFFS_OBJECT_UNLINKED) || (inode == YAFFS_OBJECT_DELETED) ||\n        (inode == yaffsfs->fs_info.last_inum)){\n            fs_file->meta->flags =\n                (TSK_FS_META_FLAG_ENUM)(TSK_FS_META_FLAG_USED | TSK_FS_META_FLAG_ALLOC);\n    }\n    else{\n        if(yaffs_is_version_allocated(yaffsfs, inode)){\n            fs_file->meta->flags =\n                (TSK_FS_META_FLAG_ENUM)(TSK_FS_META_FLAG_USED | TSK_FS_META_FLAG_ALLOC);\n        }\n        else{\n            fs_file->meta->flags =\n                (TSK_FS_META_FLAG_ENUM)(TSK_FS_META_FLAG_USED | TSK_FS_META_FLAG_UNALLOC);\n        }\n    }\n    fs_file->meta->uid = fs_file->meta->gid = 0;\n    fs_file->meta->mtime = fs_file->meta->atime = fs_file->meta->ctime =\n        fs_file->meta->crtime = 0;\n    fs_file->meta->mtime_nano = fs_file->meta->atime_nano =\n        fs_file->meta->ctime_nano = fs_file->meta->crtime_nano = 0;\n\n    if (fs_file->meta->name2 == NULL) {\n        if ((fs_file->meta->name2 = (TSK_FS_META_NAME_LIST *)\n            tsk_malloc(sizeof(TSK_FS_META_NAME_LIST))) == NULL) {\n            return 1;\n        }\n        fs_file->meta->name2->next = NULL;\n    }\n\n    if (fs_file->meta->attr != NULL) {\n        tsk_fs_attrlist_markunused(fs_file->meta->attr);\n    }\n    else {\n        fs_file->meta->attr = tsk_fs_attrlist_alloc();\n    }\n\n    strncpy(fs_file->meta->name2->name, name,\n        TSK_FS_META_NAME_LIST_NSIZE);\n\n    fs_file->meta->size = 0;\n    fs_file->meta->attr_state = TSK_FS_META_ATTR_EMPTY;\n    fs_file->meta->addr = inode;\n    return 0;\n}\n\nstatic uint8_t\n    yaffs_make_regularfile( YAFFSFS_INFO * yaffsfs, TSK_FS_FILE * a_fs_file, \n    TSK_INUM_T inode, const char * name )\n{\n    TSK_FS_FILE *fs_file = a_fs_file;\n\n    fs_file->meta->type = TSK_FS_META_TYPE_REG;\n    fs_file->meta->mode = (TSK_FS_META_MODE_ENUM)0;\n    fs_file->meta->nlink =1;\n\n    if(yaffs_is_version_allocated(yaffsfs, inode)){\n        fs_file->meta->flags =\n            (TSK_FS_META_FLAG_ENUM)(TSK_FS_META_FLAG_USED | TSK_FS_META_FLAG_ALLOC);\n    }\n    else{\n        fs_file->meta->flags =\n            (TSK_FS_META_FLAG_ENUM)(TSK_FS_META_FLAG_USED | TSK_FS_META_FLAG_UNALLOC);\n    }\n\n    fs_file->meta->uid = fs_file->meta->gid = 0;\n    fs_file->meta->mtime = fs_file->meta->atime = fs_file->meta->ctime =\n        fs_file->meta->crtime = 0;\n    fs_file->meta->mtime_nano = fs_file->meta->atime_nano =\n        fs_file->meta->ctime_nano = fs_file->meta->crtime_nano = 0;\n\n    if (fs_file->meta->name2 == NULL) {\n        if ((fs_file->meta->name2 = (TSK_FS_META_NAME_LIST *)\n            tsk_malloc(sizeof(TSK_FS_META_NAME_LIST))) == NULL)\n            return 1;\n        fs_file->meta->name2->next = NULL;\n    }\n\n    if (fs_file->meta->attr != NULL) {\n        tsk_fs_attrlist_markunused(fs_file->meta->attr);\n    }\n    else {\n        fs_file->meta->attr = tsk_fs_attrlist_alloc();\n    }\n\n    fs_file->meta->addr = inode;\n    strncpy(fs_file->meta->name2->name, name,\n        TSK_FS_META_NAME_LIST_NSIZE);\n\n    fs_file->meta->size = 0;\n    fs_file->meta->attr_state = TSK_FS_META_ATTR_EMPTY;\n\n    return 0;\n}\n\n/**\n* \\internal \n* Create YAFFS2 Deleted Object\n*\n* @ param yaffs file system\n* fs_file to copy file information to\n* return 1 on error, 0 on success\n*/\nstatic uint8_t\n    yaffs_make_deleted( YAFFSFS_INFO * yaffsfs, TSK_FS_FILE * a_fs_file )\n{\n    TSK_FS_FILE *fs_file = a_fs_file;\n\n    if (tsk_verbose)\n        tsk_fprintf(stderr, \"yaffs_make_deleted: Making virtual deleted node\\n\");\n\n    if (yaffs_make_directory(yaffsfs, fs_file, YAFFS_OBJECT_DELETED, YAFFS_OBJECT_DELETED_NAME))\n        return 1;\n\n    return 0;\n}\n\n/**\n* \\internal \n* Create YAFFS2 Unlinked object\n*\n* @ param yaffs file system\n* fs_file to copy file information to\n* return 1 on error, 0 on success\n*/\nstatic uint8_t\n    yaffs_make_unlinked( YAFFSFS_INFO * yaffsfs, TSK_FS_FILE * a_fs_file )\n{\n    TSK_FS_FILE * fs_file = a_fs_file;\n\n    if (tsk_verbose)\n        tsk_fprintf(stderr, \"yaffs_make_unlinked: Making virtual unlinked node\\n\");\n\n    if (yaffs_make_directory(yaffsfs, fs_file, YAFFS_OBJECT_UNLINKED, YAFFS_OBJECT_UNLINKED_NAME))\n        return 1;\n\n    return 0;\n}\n\n/**\n* \\internal \n* Create YAFFS2 orphan object\n*\n* @ param yaffs file system\n* fs_file to copy file information to\n* return 1 on error, 0 on success\n*/\nstatic uint8_t\n    yaffs_make_orphan_dir( YAFFSFS_INFO * yaffsfs, TSK_FS_FILE * a_fs_file )\n{\n    TSK_FS_FILE * fs_file = a_fs_file;\n    TSK_FS_NAME *fs_name = tsk_fs_name_alloc(256, 0);\n    if (fs_name == NULL)\n        return TSK_ERR;\n\n    if (tsk_verbose)\n        tsk_fprintf(stderr, \"yaffs_make_orphan_dir: Making orphan dir node\\n\");\n\n    if (tsk_fs_dir_make_orphan_dir_name(&(yaffsfs->fs_info), fs_name)) {\n        tsk_fs_name_free(fs_name);\n        return TSK_ERR;\n    }\n\n    if (yaffs_make_directory(yaffsfs, fs_file, yaffsfs->fs_info.last_inum, (char *)fs_name)){\n        tsk_fs_name_free(fs_name);\n        return 1;\n    }\n    tsk_fs_name_free(fs_name);\n    return 0;\n}\n\n/* yaffsfs_inode_lookup - lookup inode, external interface\n*\n* Returns 1 on error and 0 on success\n*\n*/\n\nstatic uint8_t\n    yaffs_inode_lookup(TSK_FS_INFO *a_fs, TSK_FS_FILE * a_fs_file,\n    TSK_INUM_T inum)\n{\n    YAFFSFS_INFO *yfs = (YAFFSFS_INFO *)a_fs;\n    YaffsCacheObject *obj;\n    YaffsCacheVersion *version;\n    YaffsHeader *header = NULL;\n    YaffsSpare *spare = NULL;\n    TSK_RETVAL_ENUM result;\n    uint8_t type;\n    const char *real_name;\n\n    if (a_fs_file == NULL) {\n        tsk_error_set_errno(TSK_ERR_FS_ARG);\n        tsk_error_set_errstr(\"yaffsfs_inode_lookup: fs_file is NULL\");\n        return 1;\n    }\n\n    if (a_fs_file->meta == NULL) {\n        if ((a_fs_file->meta =\n            tsk_fs_meta_alloc(YAFFS_FILE_CONTENT_LEN)) == NULL)\n            return 1;\n    }\n    else {\n        tsk_fs_meta_reset(a_fs_file->meta);\n    }\n\n    if (tsk_verbose)\n        tsk_fprintf(stderr, \"yaffs_inode_lookup: looking up %\" PRIuINUM \"\\n\",inum);\n\n    switch(inum) {\n    case YAFFS_OBJECT_UNLINKED:\n        yaffs_make_unlinked(yfs, a_fs_file);\n        return 0;\n\n    case YAFFS_OBJECT_DELETED:\n        yaffs_make_deleted(yfs, a_fs_file);\n        return 0;\n    }\n\n    if(inum == yfs->fs_info.last_inum){\n        yaffs_make_orphan_dir(yfs, a_fs_file);\n        return 0;\n    }\n\n    result = yaffscache_version_find_by_inode(yfs, inum, &version, &obj);\n    if (result != TSK_OK) {\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"yaffs_inode_lookup: yaffscache_version_find_by_inode failed! (inode = %d)\\n\", inum);\n        return 1;\n    }\n\n    if(version->ycv_header_chunk == NULL){\n        return 1;\n    }\n\n    if (yaffsfs_read_chunk(yfs, &header, &spare, version->ycv_header_chunk->ycc_offset) != TSK_OK) {\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"yaffs_inode_lookup: yaffsfs_read_chunk failed!\\n\");\n        return 1;\n    }\n\n    type = header->obj_type;\n\n    switch(inum) {\n    case YAFFS_OBJECT_LOSTNFOUND:\n        real_name = YAFFS_OBJECT_LOSTNFOUND_NAME;\n        break;\n    case YAFFS_OBJECT_UNLINKED:\n        real_name = YAFFS_OBJECT_UNLINKED_NAME;\n        break;\n    case YAFFS_OBJECT_DELETED:\n        real_name = YAFFS_OBJECT_DELETED_NAME;\n        break;\n    default:\n        real_name = header->name;\n        break;\n    }\n\n    switch(type) {\n    case YAFFS_TYPE_FILE:\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"yaffs_inode_lookup: is a file\\n\");\n        yaffs_make_regularfile(yfs, a_fs_file, inum, real_name);\n        break;\n\n    case YAFFS_TYPE_DIRECTORY:\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"yaffs_inode_lookup: is a directory\\n\");\n        yaffs_make_directory(yfs, a_fs_file, inum, real_name);\n        break;\n\n    case YAFFS_TYPE_SOFTLINK:\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"yaffs_inode_lookup: is a symbolic link\\n\");\n        yaffs_make_regularfile(yfs, a_fs_file, inum, real_name);\n        a_fs_file->meta->type = TSK_FS_META_TYPE_LNK;\n        break;\n\n    case YAFFS_TYPE_HARDLINK:\n    case YAFFS_TYPE_UNKNOWN:\n    default:\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"yaffs_inode_lookup: is *** UNHANDLED *** (type %d, header at 0x%x)\\n\", type, version->ycv_header_chunk->ycc_offset);\n        // We can still set a few things\n        a_fs_file->meta->type = TSK_FS_META_TYPE_UNDEF;\n        a_fs_file->meta->addr = inum;\n        if(yaffs_is_version_allocated(yfs, inum)){\n            a_fs_file->meta->flags =\n                (TSK_FS_META_FLAG_ENUM)(TSK_FS_META_FLAG_USED | TSK_FS_META_FLAG_ALLOC);\n        }\n        else{\n            a_fs_file->meta->flags =\n                (TSK_FS_META_FLAG_ENUM)(TSK_FS_META_FLAG_USED | TSK_FS_META_FLAG_UNALLOC);\n        }\n        if (a_fs_file->meta->name2 == NULL) {\n            if ((a_fs_file->meta->name2 = (TSK_FS_META_NAME_LIST *)\n                tsk_malloc(sizeof(TSK_FS_META_NAME_LIST))) == NULL){\n                    return 1;\n            }\n            a_fs_file->meta->name2->next = NULL;\n        }\n        strncpy(a_fs_file->meta->name2->name, real_name,\n            TSK_FS_META_NAME_LIST_NSIZE);\n        break;\n    }\n\n    /* Who owns this? I'm following the way FATFS does it by freeing + NULLing \n    * this and mallocing if used. \n    */\n    free(a_fs_file->meta->link);\n    a_fs_file->meta->link = NULL;\n\n    if (type != YAFFS_TYPE_HARDLINK) {\n        a_fs_file->meta->mode = (TSK_FS_META_MODE_ENUM)(header->file_mode & TWELVE_BITS_MASK); // chop at 12 bits;\n        a_fs_file->meta->uid = header->user_id;\n        a_fs_file->meta->gid = header->group_id;\n        a_fs_file->meta->mtime = header->mtime;\n        a_fs_file->meta->atime = header->atime;\n        a_fs_file->meta->ctime = header->ctime;\n    }\n\n    if (type == YAFFS_TYPE_FILE) {\n        a_fs_file->meta->size = header->file_size;\n        // NOTE: This isn't in Android 3.3 kernel but is in YAFFS2 git\n        //a_fs_file->meta->size |= ((TSK_OFF_T) header->file_size_high) << 32;\n    }\n\n    if (type == YAFFS_TYPE_HARDLINK) {\n        // TODO: Store equivalent_id somewhere? */\n    }\n\n    if (type == YAFFS_TYPE_SOFTLINK) {\n        a_fs_file->meta->link = (char*)tsk_malloc(YAFFS_HEADER_ALIAS_LENGTH);\n        if (a_fs_file->meta->link == NULL) {\n            free(header);\n            free(spare);\n            return 1;\n        }\n\n        memcpy(a_fs_file->meta->link, header->alias, YAFFS_HEADER_ALIAS_LENGTH);\n    }\n\n    free(header);\n    free(spare);\n    return 0;\n}\n\n\n\n/* yaffsfs_inode_walk - inode iterator\n*\n* flags used: TSK_FS_META_FLAG_USED, TSK_FS_META_FLAG_UNUSED,\n*  TSK_FS_META_FLAG_ALLOC, TSK_FS_META_FLAG_UNALLOC, TSK_FS_META_FLAG_ORPHAN\n*\n*  Return 1 on error and 0 on success\n*/\n\nstatic uint8_t\n    yaffsfs_inode_walk(TSK_FS_INFO *fs, TSK_INUM_T start_inum,\n    TSK_INUM_T end_inum, TSK_FS_META_FLAG_ENUM flags,\n    TSK_FS_META_WALK_CB a_action, void *a_ptr)\n{\n    YAFFSFS_INFO *yfs = (YAFFSFS_INFO *)fs;\n    TSK_FS_FILE *fs_file;\n    TSK_RETVAL_ENUM result;\n\n    uint32_t start_obj_id;\n    uint32_t start_ver_number;\n    uint32_t end_obj_id;\n    uint32_t end_ver_number;\n\n    uint32_t obj_id;\n\n    YaffsCacheObject *curr_obj;\n    YaffsCacheVersion *curr_version;\n\n    result = yaffscache_inode_to_obj_id_and_version(start_inum, &start_obj_id, &start_ver_number);\n\n    result = yaffscache_inode_to_obj_id_and_version(end_inum, &end_obj_id, &end_ver_number);\n\n    if (end_obj_id < start_obj_id) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_WALK_RNG);\n        tsk_error_set_errstr(\"yaffsfs_inode_walk: end object id must be >= start object id: \"\n            \"%\" PRIx32 \" must be >= %\" PRIx32 \"\",\n            end_obj_id, start_obj_id);\n        return 1;\n    }\n\n    /* The ORPHAN flag is unsupported for YAFFS2 */\n    if (flags & TSK_FS_META_FLAG_ORPHAN) {\n        if (tsk_verbose){\n            tsk_fprintf(stderr, \"yaffsfs_inode_walk: ORPHAN flag unsupported by YAFFS2\");\n        }\n    }\n\n    if (((flags & TSK_FS_META_FLAG_ALLOC) == 0) &&\n        ((flags & TSK_FS_META_FLAG_UNALLOC) == 0)) {\n            flags = (TSK_FS_META_FLAG_ENUM)(flags | TSK_FS_META_FLAG_ALLOC | TSK_FS_META_FLAG_UNALLOC);\n    }\n\n    /* If neither of the USED or UNUSED flags are set, then set them\n    * both\n    */\n    if (((flags & TSK_FS_META_FLAG_USED) == 0) &&\n        ((flags & TSK_FS_META_FLAG_UNUSED) == 0)) {\n            flags = (TSK_FS_META_FLAG_ENUM)(flags | TSK_FS_META_FLAG_USED | TSK_FS_META_FLAG_UNUSED);\n    }\n\n    if ((fs_file = tsk_fs_file_alloc(fs)) == NULL)\n        return 1;\n    if ((fs_file->meta =\n        tsk_fs_meta_alloc(YAFFS_FILE_CONTENT_LEN)) == NULL)\n        return 1;\n\n\n    for (obj_id = start_obj_id; obj_id <= end_obj_id; obj_id++) {\n        int retval;\n\n        result = yaffscache_version_find_by_inode(yfs, obj_id, &curr_version, &curr_obj);\n        if (result == TSK_OK) {\n\n            TSK_INUM_T curr_inode;\n            YaffsCacheVersion *version;\n\n            // ALLOC, UNALLOC, or both are set at this point \n            if (flags & TSK_FS_META_FLAG_ALLOC) {\n                // Allocated only - just look at current version\n                if (yaffscache_obj_id_and_version_to_inode(obj_id, curr_obj->yco_latest->ycv_version, &curr_inode) != TSK_OK) {\n                    tsk_fs_file_close(fs_file);\n                    return 1;\n                }\n\n                // It's possible for the current version to be unallocated if the last header was a deleted or unlinked header\n                if(yaffs_is_version_allocated(yfs, curr_inode)){\n                    if (yaffs_inode_lookup(fs, fs_file, curr_inode) != TSK_OK) {\n                        tsk_fs_file_close(fs_file);\n                        return 1;\n                    }\n\n                    retval = a_action(fs_file, a_ptr);\n                    if (retval == TSK_WALK_STOP) {\n                        tsk_fs_file_close(fs_file);\n                        return 0;\n                    }\n                    else if (retval == TSK_WALK_ERROR) {\n                        tsk_fs_file_close(fs_file);\n                        return 1;\n                    }\n                }\n            }\n            if (flags & TSK_FS_META_FLAG_UNALLOC){\n                for (version = curr_obj->yco_latest; version != NULL; version = version->ycv_prior) {\n                    if (yaffscache_obj_id_and_version_to_inode(obj_id, version->ycv_version, &curr_inode) != TSK_OK) {\n                        tsk_fs_file_close(fs_file);\n                        return 1;\n                    }\n\n                    if(! yaffs_is_version_allocated(yfs, curr_inode)){\n                        if (yaffs_inode_lookup(fs, fs_file, curr_inode) != TSK_OK) {\n                            tsk_fs_file_close(fs_file);\n                            return 1;\n                        }\n\n                        retval = a_action(fs_file, a_ptr);\n                        if (retval == TSK_WALK_STOP) {\n                            tsk_fs_file_close(fs_file);\n                            return 0;\n                        }\n                        else if (retval == TSK_WALK_ERROR) {\n                            tsk_fs_file_close(fs_file);\n                            return 1;\n                        }\n                    }\n                }\n            }\n\n            curr_obj = curr_obj->yco_next;\n        }\n    }\n\n    /*\n    * Cleanup.\n    */\n    tsk_fs_file_close(fs_file);\n    return 0;\n}\n\nstatic TSK_FS_BLOCK_FLAG_ENUM\n    yaffsfs_block_getflags(TSK_FS_INFO *fs, TSK_DADDR_T a_addr)\n{\n    YAFFSFS_INFO *yfs = (YAFFSFS_INFO *)fs;\n    TSK_FS_BLOCK_FLAG_ENUM flags = TSK_FS_BLOCK_FLAG_UNUSED;\n\n    TSK_OFF_T offset = (a_addr * (fs->block_pre_size + fs->block_size + fs->block_post_size)) + yfs->page_size;\n    YaffsSpare *spare = NULL;\n    YaffsHeader *header = NULL;\n    if (yaffsfs_read_spare(yfs, &spare, offset) != TSK_OK) {\n        /* NOTE: Uh, how do we signal error? */\n        return flags;\n    }\n\n    if (yaffsfs_is_spare_valid(yfs, spare) == TSK_OK) {\n        /* XXX: Do we count blocks of older versions unallocated?\n        *      If so, we need a smarter way to do this :/\n        *\n        *      Walk the object from this block and see if this\n        *      block is used in the latest version. Could pre-\n        *      calculate this at cache time as well.\n        */\n\n\n        if (spare->chunk_id == 0) {\n            flags = (TSK_FS_BLOCK_FLAG_ENUM)(flags | TSK_FS_BLOCK_FLAG_META);\n        } else {\n            flags = (TSK_FS_BLOCK_FLAG_ENUM)(flags | TSK_FS_BLOCK_FLAG_CONT);\n        }\n\n        // Have obj id and offset\n        // 1. Is the current version of this object allocated?\n        // 2. If this is a header, is it the header of the current version?\n        // 3. Is the chunk id too big given the current header?\n        // 4. Is there a more recent version of this chunk id?\n        YaffsCacheObject * obj = NULL;\n        yaffscache_object_find(yfs, spare->object_id, &obj);\n\n        // The result really shouldn't be NULL since we loaded every chunk\n        if(obj != NULL){\n            if(! yaffs_is_version_allocated(yfs, spare->object_id)){\n                // If the current version isn't allocated, then no chunks in it are\n                flags = (TSK_FS_BLOCK_FLAG_ENUM)(flags | TSK_FS_BLOCK_FLAG_UNALLOC);\n            }\n            else if (obj->yco_latest == NULL || obj->yco_latest->ycv_header_chunk == NULL) { \n                flags = (TSK_FS_BLOCK_FLAG_ENUM)(flags | TSK_FS_BLOCK_FLAG_UNALLOC); \n            }\n            else if(spare->chunk_id == 0){\n                if(obj->yco_latest->ycv_header_chunk->ycc_offset == offset - yfs->page_size){\n                    // Have header chunk and it's the most recent header chunk\n                    flags = (TSK_FS_BLOCK_FLAG_ENUM)(flags | TSK_FS_BLOCK_FLAG_ALLOC);\n                }\n                else{\n                    // Have header chunk but isn't the most recent\n                    flags = (TSK_FS_BLOCK_FLAG_ENUM)(flags | TSK_FS_BLOCK_FLAG_UNALLOC);\n                }\n            }\n            else{\n                // Read in the full header\n                yaffsfs_read_header(yfs, &header, obj->yco_latest->ycv_header_chunk->ycc_offset);\n\n                // chunk_id is 1-based, so for example chunk id 2 would be too big for a file\n                //   500 bytes long\n                if(header->file_size <= ((spare->chunk_id - 1) * (fs->block_size))){\n                    flags = (TSK_FS_BLOCK_FLAG_ENUM)(flags | TSK_FS_BLOCK_FLAG_UNALLOC);\n                }\n                else{\n                    // Since at this point we know there should be a chunk with this chunk id in the file, if\n                    // this is the most recent version of the chunk assume it's part of the current version of the object.\n                    YaffsCacheChunk * curr = obj->yco_latest->ycv_last_chunk;\n                    while(curr != NULL){ // curr should really never make it to the beginning of the list\n\n                        // Did we find our chunk?\n                        if(curr->ycc_offset == offset - yfs->page_size){\n                            flags = (TSK_FS_BLOCK_FLAG_ENUM)(flags | TSK_FS_BLOCK_FLAG_ALLOC);\n                            break;\n                        }\n\n                        // Did we find a different chunk with our chunk id?\n                        if(curr->ycc_chunk_id == spare->chunk_id){\n                            flags = (TSK_FS_BLOCK_FLAG_ENUM)(flags | TSK_FS_BLOCK_FLAG_UNALLOC);\n                            break;\n                        }\n                        curr = curr->ycc_prev;\n                    }\n                }\n            }\n        }\n\n    } else {\n        flags = (TSK_FS_BLOCK_FLAG_ENUM)(flags | TSK_FS_BLOCK_FLAG_UNUSED | TSK_FS_BLOCK_FLAG_UNALLOC);\n    }\n\n    free(spare);\n    free(header);\n    return flags;\n}\n\n\n/* yaffsfs_block_walk - block iterator\n*\n* flags: TSK_FS_BLOCK_FLAG_ALLOC, TSK_FS_BLOCK_FLAG_UNALLOC, TSK_FS_BLOCK_FLAG_CONT,\n*  TSK_FS_BLOCK_FLAG_META\n*\n*  Return 1 on error and 0 on success\n*/\nstatic uint8_t\n    yaffsfs_block_walk(TSK_FS_INFO *a_fs, TSK_DADDR_T a_start_blk,\n    TSK_DADDR_T a_end_blk, TSK_FS_BLOCK_WALK_FLAG_ENUM a_flags,\n    TSK_FS_BLOCK_WALK_CB a_action, void *a_ptr)\n{\n    TSK_FS_BLOCK *fs_block;\n    TSK_DADDR_T addr;\n\n    // clean up any error messages that are lying around\n    tsk_error_reset();\n\n    /*\n    * Sanity checks.\n    */\n    if (a_start_blk < a_fs->first_block || a_start_blk > a_fs->last_block) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_WALK_RNG);\n        tsk_error_set_errstr(\"yaffsfs_block_walk: start block: %\" PRIuDADDR,\n            a_start_blk);\n        return 1;\n    }\n    if (a_end_blk < a_fs->first_block || a_end_blk > a_fs->last_block\n        || a_end_blk < a_start_blk) {\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_FS_WALK_RNG);\n            tsk_error_set_errstr(\"yaffsfs_block_walk: end block: %\" PRIuDADDR ,\n                a_end_blk);\n            return 1;\n    }\n\n    /* Sanity check on a_flags -- make sure at least one ALLOC is set */\n    if (((a_flags & TSK_FS_BLOCK_WALK_FLAG_ALLOC) == 0) &&\n        ((a_flags & TSK_FS_BLOCK_WALK_FLAG_UNALLOC) == 0)) {\n            a_flags = (TSK_FS_BLOCK_WALK_FLAG_ENUM)\n                (a_flags | TSK_FS_BLOCK_WALK_FLAG_ALLOC |\n                TSK_FS_BLOCK_WALK_FLAG_UNALLOC);\n    }\n    if (((a_flags & TSK_FS_BLOCK_WALK_FLAG_META) == 0) &&\n        ((a_flags & TSK_FS_BLOCK_WALK_FLAG_CONT) == 0)) {\n            a_flags = (TSK_FS_BLOCK_WALK_FLAG_ENUM)\n                (a_flags | TSK_FS_BLOCK_WALK_FLAG_CONT | TSK_FS_BLOCK_WALK_FLAG_META);\n    }\n\n\n    if ((fs_block = tsk_fs_block_alloc(a_fs)) == NULL) {\n        return 1;\n    }\n\n    for (addr = a_start_blk; addr <= a_end_blk; addr++) {\n        int retval;\n        int myflags;\n\n        myflags = yaffsfs_block_getflags(a_fs, addr);\n\n        // test if we should call the callback with this one\n        if ((myflags & TSK_FS_BLOCK_FLAG_META)\n            && (!(a_flags & TSK_FS_BLOCK_WALK_FLAG_META)))\n            continue;\n        else if ((myflags & TSK_FS_BLOCK_FLAG_CONT)\n            && (!(a_flags & TSK_FS_BLOCK_WALK_FLAG_CONT)))\n            continue;\n        else if ((myflags & TSK_FS_BLOCK_FLAG_ALLOC)\n            && (!(a_flags & TSK_FS_BLOCK_WALK_FLAG_ALLOC)))\n            continue;\n        else if ((myflags & TSK_FS_BLOCK_FLAG_UNALLOC)\n            && (!(a_flags & TSK_FS_BLOCK_WALK_FLAG_UNALLOC)))\n            continue;\n\n        if (tsk_fs_block_get(a_fs, fs_block, addr) == NULL) {\n            tsk_error_set_errstr2(\"yaffsfs_block_walk: block %\" PRIuDADDR,\n                addr);\n            tsk_fs_block_free(fs_block);\n            return 1;\n        }\n\n        retval = a_action(fs_block, a_ptr);\n        if (retval == TSK_WALK_STOP) {\n            break;\n        }\n        else if (retval == TSK_WALK_ERROR) {\n            tsk_fs_block_free(fs_block);\n            return 1;\n        }\n    }\n\n    /*\n    * Cleanup.\n    */\n    tsk_fs_block_free(fs_block);\n    return 0;\n}\n\nstatic uint8_t\n    yaffsfs_fscheck(TSK_FS_INFO * /*fs*/, FILE * /*hFile*/)\n{\n    tsk_error_reset();\n    tsk_error_set_errno(TSK_ERR_FS_UNSUPFUNC);\n    tsk_error_set_errstr(\"fscheck not implemented yet for YAFFS\");\n    return 1;\n}\n\n\n/**\n* Print details about the file system to a file handle.\n*\n* @param fs File system to print details on\n* @param hFile File handle to print text to\n*\n* @returns 1 on error and 0 on success\n*/\nstatic uint8_t\n    yaffsfs_fsstat(TSK_FS_INFO * fs, FILE * hFile)\n{\n    YAFFSFS_INFO *yfs = (YAFFSFS_INFO *) fs;\n    unsigned int obj_count, version_count;\n    uint32_t obj_first, obj_last, version_first, version_last;\n\n    // clean up any error messages that are lying around\n    tsk_error_reset();\n\n    tsk_fprintf(hFile, \"FILE SYSTEM INFORMATION\\n\");\n    tsk_fprintf(hFile, \"--------------------------------------------\\n\");\n\n    tsk_fprintf(hFile, \"File System Type: YAFFS2\\n\");\n    tsk_fprintf(hFile, \"Page Size: %u\\n\", yfs->page_size);\n    tsk_fprintf(hFile, \"Spare Size: %u\\n\", yfs->spare_size);\n    tsk_fprintf(hFile, \"Spare Offsets: Sequence number: %d, Object ID: %d, Chunk ID: %d, nBytes: %d\\n\",\n        yfs->spare_seq_offset, yfs->spare_obj_id_offset, yfs->spare_chunk_id_offset, yfs->spare_nbytes_offset);\n\n    tsk_fprintf(hFile, \"\\nMETADATA INFORMATION\\n\");\n    tsk_fprintf(hFile, \"--------------------------------------------\\n\");\n\n\n    yaffscache_objects_stats(yfs, \n        &obj_count, &obj_first, &obj_last,\n        &version_count, &version_first, &version_last);\n\n    tsk_fprintf(hFile, \"Number of Allocated Objects: %u\\n\", obj_count);\n    tsk_fprintf(hFile, \"Object Id Range: %\" PRIu32 \" - %\" PRIu32 \"\\n\",\n        obj_first, obj_last);\n    tsk_fprintf(hFile, \"Number of Total Object Versions: %u\\n\", version_count);\n    tsk_fprintf(hFile, \"Object Version Range: %\" PRIu32 \" - %\" PRIu32 \"\\n\",\n        version_first, version_last);\n\n    return 0;\n}\n\n/************************* istat *******************************/\n\ntypedef struct {\n    FILE *hFile;\n    int idx;\n} YAFFSFS_PRINT_ADDR;\n\n/* Callback for istat to print the block addresses */\nstatic TSK_WALK_RET_ENUM\n    print_addr_act(YAFFSFS_INFO * /*fs_file*/, TSK_OFF_T /*a_off*/,\n    TSK_DADDR_T addr, char * /*buf*/, size_t /*size*/,\n    TSK_FS_BLOCK_FLAG_ENUM flags, void *a_ptr)\n{\n    YAFFSFS_PRINT_ADDR *print = (YAFFSFS_PRINT_ADDR *) a_ptr;\n\n    if (flags & TSK_FS_BLOCK_FLAG_CONT) {\n        tsk_fprintf(print->hFile, \"%\" PRIuDADDR \" \", addr);\n\n        if (++(print->idx) == 8) {\n            tsk_fprintf(print->hFile, \"\\n\");\n            print->idx = 0;\n        }\n    }\n\n    return TSK_WALK_CONT;\n}\n\n/**\n* Print details on a specific file to a file handle.\n*\n* @param fs File system file is located in\n* @param hFile File handle to print text to\n* @param inum Address of file in file system\n* @param numblock The number of blocks in file to force print (can go beyond file size)\n* @param sec_skew Clock skew in seconds to also print times in\n*\n* @returns 1 on error and 0 on success\n*/\nstatic uint8_t\n    yaffsfs_istat(TSK_FS_INFO *fs, TSK_FS_ISTAT_FLAG_ENUM flags, FILE * hFile, TSK_INUM_T inum,\n    TSK_DADDR_T numblock, int32_t sec_skew)\n{\n    TSK_FS_META *fs_meta;\n    TSK_FS_FILE *fs_file;\n    YAFFSFS_INFO *yfs = (YAFFSFS_INFO *)fs;\n    char ls[12];\n    YAFFSFS_PRINT_ADDR print;\n    char timeBuf[32];\n    YaffsCacheObject * obj = NULL;\n    YaffsCacheVersion * version = NULL;\n    YaffsHeader * header = NULL;\n\n    yaffscache_version_find_by_inode(yfs, inum, &version, &obj);\n\n    if ((fs_file = tsk_fs_file_open_meta(fs, NULL, inum)) == NULL) {\n        return 1;\n    }\n    fs_meta = fs_file->meta;\n\n    tsk_fprintf(hFile, \"inode: %\" PRIuINUM \"\\n\", inum);\n    tsk_fprintf(hFile, \"%sAllocated\\n\",\n        (fs_meta->flags & TSK_FS_META_FLAG_ALLOC) ? \"\" : \"Not \");\n\n    if (fs_meta->link)\n        tsk_fprintf(hFile, \"symbolic link to: %s\\n\", fs_meta->link);\n\n    tsk_fprintf(hFile, \"uid / gid: %\" PRIuUID \" / %\" PRIuGID \"\\n\",\n        fs_meta->uid, fs_meta->gid);\n\n    tsk_fs_meta_make_ls(fs_meta, ls, sizeof(ls));\n    tsk_fprintf(hFile, \"mode: %s\\n\", ls);\n\n    tsk_fprintf(hFile, \"size: %\" PRIdOFF \"\\n\", fs_meta->size);\n    tsk_fprintf(hFile, \"num of links: %d\\n\", fs_meta->nlink);\n\n    if(version != NULL){\n        yaffsfs_read_header(yfs, &header, version->ycv_header_chunk->ycc_offset);\n        if(header != NULL){\n            tsk_fprintf(hFile, \"Name: %s\\n\", header->name);\n        }\n    }\n\n    if (sec_skew != 0) {\n        tsk_fprintf(hFile, \"\\nAdjusted Inode Times:\\n\");\n        fs_meta->mtime -= sec_skew;\n        fs_meta->atime -= sec_skew;\n        fs_meta->ctime -= sec_skew;\n\n        tsk_fprintf(hFile, \"Accessed:\\t%s\\n\",\n            tsk_fs_time_to_str(fs_meta->atime, timeBuf));\n        tsk_fprintf(hFile, \"File Modified:\\t%s\\n\",\n            tsk_fs_time_to_str(fs_meta->mtime, timeBuf));\n        tsk_fprintf(hFile, \"Inode Modified:\\t%s\\n\",\n            tsk_fs_time_to_str(fs_meta->ctime, timeBuf));\n\n        fs_meta->mtime += sec_skew;\n        fs_meta->atime += sec_skew;\n        fs_meta->ctime += sec_skew;\n\n        tsk_fprintf(hFile, \"\\nOriginal Inode Times:\\n\");\n    }\n    else {\n        tsk_fprintf(hFile, \"\\nInode Times:\\n\");\n    }\n\n    tsk_fprintf(hFile, \"Accessed:\\t%s\\n\",\n        tsk_fs_time_to_str(fs_meta->atime, timeBuf));\n    tsk_fprintf(hFile, \"File Modified:\\t%s\\n\",\n        tsk_fs_time_to_str(fs_meta->mtime, timeBuf));\n    tsk_fprintf(hFile, \"Inode Modified:\\t%s\\n\",\n        tsk_fs_time_to_str(fs_meta->ctime, timeBuf));\n\n    if(version != NULL){\n        tsk_fprintf(hFile, \"\\nHeader Chunk:\\n\");\n        tsk_fprintf(hFile, \"%\" PRIuDADDR \"\\n\", (version->ycv_header_chunk->ycc_offset / (yfs->page_size + yfs->spare_size)));\n    }\n\n    if (numblock > 0) {\n        TSK_OFF_T lower_size = numblock * fs->block_size;\n        fs_meta->size = (lower_size < fs_meta->size)?(lower_size):(fs_meta->size);\n    }\n    tsk_fprintf(hFile, \"\\nData Chunks:\\n\");\n\n\n    if (flags & TSK_FS_ISTAT_RUNLIST){\n        const TSK_FS_ATTR *fs_attr_default =\n            tsk_fs_file_attr_get_type(fs_file,\n                TSK_FS_ATTR_TYPE_DEFAULT, 0, 0);\n        if (fs_attr_default && (fs_attr_default->flags & TSK_FS_ATTR_NONRES)) {\n            if (tsk_fs_attr_print(fs_attr_default, hFile)) {\n                tsk_fprintf(hFile, \"\\nError creating run lists  \");\n                tsk_error_print(hFile);\n                tsk_error_reset();\n            }\n        }\n    }\n    else {\n        print.idx = 0;\n        print.hFile = hFile;\n\n        if (tsk_fs_file_walk(fs_file, TSK_FS_FILE_WALK_FLAG_AONLY,\n            (TSK_FS_FILE_WALK_CB)print_addr_act, (void *)&print)) {\n            tsk_fprintf(hFile, \"\\nError reading file:  \");\n            tsk_error_print(hFile);\n            tsk_error_reset();\n        }\n        else if (print.idx != 0) {\n            tsk_fprintf(hFile, \"\\n\");\n        }\n    }\n\n    tsk_fs_file_close(fs_file);\n\n    return 0;\n}\n\n/* yaffsfs_close - close an yaffsfs file system */\nstatic void\n    yaffsfs_close(TSK_FS_INFO *fs)\n{\n    if(fs != NULL){\n        YAFFSFS_INFO *yfs = (YAFFSFS_INFO *)fs;\n\n        fs->tag = 0;\n\n        // Walk and free the cache structures\n        yaffscache_objects_free(yfs);\n        yaffscache_chunks_free(yfs);\n\n        //tsk_deinit_lock(&yaffsfs->lock);\n        tsk_fs_free(fs);\n\t}\n}\n\ntypedef struct _dir_open_cb_args {\n    YAFFSFS_INFO *yfs;\n    TSK_FS_DIR *dir;\n    TSK_INUM_T parent_addr;\n} dir_open_cb_args;\n\nstatic TSK_RETVAL_ENUM\n    yaffs_dir_open_meta_cb(YaffsCacheObject * /*obj*/, YaffsCacheVersion *version, void *args) {\n        dir_open_cb_args *cb_args = (dir_open_cb_args *) args;\n        YaffsCacheChunk *chunk = version->ycv_header_chunk;\n        TSK_INUM_T curr_inode = 0;\n        uint32_t obj_id = chunk->ycc_obj_id;\n        uint32_t chunk_id = chunk->ycc_chunk_id;\n        uint32_t vnum = version->ycv_version;\n        YaffsHeader *header = NULL;\n        TSK_FS_NAME * fs_name;\n        char *file_ext;\n        char version_string[64]; // Allow a max of 64 bytes in the version string\n\n        yaffscache_obj_id_and_version_to_inode(obj_id, vnum, &curr_inode);\n\n        if (chunk_id != 0) {\n            return TSK_ERR;\n        }\n\n        if (tsk_verbose)\n            fprintf(stderr, \"dir_open_find_children_cb: %08\" PRIxINUM \" -> %08\" PRIx32 \":%d\\n\", cb_args->parent_addr, obj_id, vnum);\n\n\n        if (yaffsfs_read_header(cb_args->yfs, &header, chunk->ycc_offset) != TSK_OK) {\n            return TSK_ERR;\n        }\n\n        if ((fs_name = tsk_fs_name_alloc(YAFFSFS_MAXNAMLEN + 64, 0)) == NULL) {\n            free(header);\n            return TSK_ERR;\n        }\n\n        switch (obj_id) {\n        case YAFFS_OBJECT_LOSTNFOUND:\n            strncpy(fs_name->name, YAFFS_OBJECT_LOSTNFOUND_NAME,\n                fs_name->name_size - 64);\n            break;\n        case YAFFS_OBJECT_UNLINKED:\n            strncpy(fs_name->name, YAFFS_OBJECT_UNLINKED_NAME,\n                fs_name->name_size - 64);\n            break;\n        case YAFFS_OBJECT_DELETED:\n            strncpy(fs_name->name, YAFFS_OBJECT_DELETED_NAME,\n                fs_name->name_size - 64);\n            break;\n        default:\n            strncpy(fs_name->name, header->name, fs_name->name_size - 64);\n            break;\n        }\n        fs_name->name[fs_name->name_size - 65] = 0;\n\n        // Only put object/version string onto unallocated versions\n        if(! yaffs_is_version_allocated(cb_args->yfs, curr_inode)){ \n            // Also copy the extension so that it also shows up after the version string, which allows\n            // easier searching by file extension. Max extension length is 5 characters after the dot,\n            // and require at least one character before the dot\n            file_ext = strrchr(fs_name->name, '.');\n            if((file_ext != NULL) && (file_ext != fs_name->name) && (strlen(file_ext) < 7)){\n               snprintf(version_string, 64, \"#%d,%d%s\", obj_id, vnum, file_ext);\n            }\n            else{\n               snprintf(version_string, 64, \"#%d,%d\", obj_id, vnum);\n            }\n            strncat(fs_name->name, version_string, 64);\n            fs_name->flags = TSK_FS_NAME_FLAG_UNALLOC;\n        }\n        else{\n            fs_name->flags = TSK_FS_NAME_FLAG_ALLOC;\n        }\n\n        fs_name->meta_addr = curr_inode;\n\n        switch (header->obj_type) {\n        case YAFFS_TYPE_FILE:\n            fs_name->type = TSK_FS_NAME_TYPE_REG;\n            break;\n\n        case YAFFS_TYPE_DIRECTORY:\n            fs_name->type = TSK_FS_NAME_TYPE_DIR;\n            break;\n\n        case YAFFS_TYPE_SOFTLINK:\n        case YAFFS_TYPE_HARDLINK:\n            fs_name->type = TSK_FS_NAME_TYPE_LNK;\n            break;\n\n        case YAFFS_TYPE_SPECIAL:\n            fs_name->type = TSK_FS_NAME_TYPE_UNDEF; // Could be a socket\n            break;\n\n        default:\n            if (tsk_verbose)\n                fprintf(stderr, \"yaffs_dir_open_meta_cb: unhandled object type\\n\");\n            fs_name->type = TSK_FS_NAME_TYPE_UNDEF;\n            break;\n        }\n\n        free(header);\n\n        if (tsk_fs_dir_add(cb_args->dir, fs_name)) {\n            tsk_fs_name_free(fs_name);\n            return TSK_ERR;\n        }\n\n        /* A copy is made in tsk_fs_dir_add, so we can free this one */\n        tsk_fs_name_free(fs_name);\n\n        return TSK_OK;\n}\n\nstatic TSK_RETVAL_ENUM\n    yaffsfs_dir_open_meta(TSK_FS_INFO *a_fs, TSK_FS_DIR ** a_fs_dir,\n    TSK_INUM_T a_addr)\n{\n    TSK_FS_DIR *fs_dir;\n    TSK_FS_NAME *fs_name;\n    YAFFSFS_INFO *yfs = (YAFFSFS_INFO *)a_fs;\n    int should_walk_children = 0;\n    uint32_t obj_id;\n    uint32_t ver_number;\n\n    if (a_addr < a_fs->first_inum || a_addr > a_fs->last_inum) { \n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_WALK_RNG);\n        tsk_error_set_errstr(\"yaffs_dir_open_meta: Invalid inode value: %\"\n            PRIuINUM, a_addr);\n        return TSK_ERR;\n    }\n    else if (a_fs_dir == NULL) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_ARG);\n        tsk_error_set_errstr(\"yaffs_dir_open_meta: NULL fs_dir argument given\");\n        return TSK_ERR;\n    }\n\n    fs_dir = *a_fs_dir;\n\n    if (fs_dir) {\n        tsk_fs_dir_reset(fs_dir);\n        fs_dir->addr = a_addr;\n    }\n    else if ((*a_fs_dir = fs_dir = tsk_fs_dir_alloc(a_fs, a_addr, 128)) == NULL) {\n        return TSK_ERR;\n    }\n\n    if (tsk_verbose)\n        fprintf(stderr,\"yaffs_dir_open_meta: called for directory %\" PRIu32 \"\\n\", (uint32_t) a_addr);\n\n    //  handle the orphan directory if its contents were requested\n    if (a_addr == TSK_FS_ORPHANDIR_INUM(a_fs)) {\n        return tsk_fs_dir_find_orphans(a_fs, fs_dir);\n    }\n\n    if ((fs_name = tsk_fs_name_alloc(YAFFSFS_MAXNAMLEN, 0)) == NULL) {\n        return TSK_ERR;\n    }\n\n\n    if ((fs_dir->fs_file = \n        tsk_fs_file_open_meta(a_fs, NULL, a_addr)) == NULL) {\n            tsk_error_errstr2_concat(\" - yaffs_dir_open_meta\");\n            tsk_fs_name_free(fs_name);\n            return TSK_ERR;\n    }\n\n    // extract obj_id and ver_number from inum\n    yaffscache_inode_to_obj_id_and_version(a_addr, &obj_id, &ver_number);\n\n    // Decide if we should walk the directory structure\n    if (obj_id == YAFFS_OBJECT_DELETED ||\n        obj_id == YAFFS_OBJECT_UNLINKED) {\n            should_walk_children = 1;\n    }\n    else {\n        YaffsCacheObject *obj;\n        YaffsCacheVersion *versionFound;\n        TSK_RETVAL_ENUM result = yaffscache_version_find_by_inode(yfs, a_addr, &versionFound, &obj);\n        if (result != TSK_OK) {\n            if (tsk_verbose)\n                tsk_fprintf(stderr, \"yaffsfs_dir_open_meta: yaffscache_version_find_by_inode failed! (inode: %d\\n\", a_addr);\n            tsk_fs_name_free(fs_name);\n            return TSK_ERR;\n        }\n\n        /* Only attach files onto the latest version of the directory */\n        should_walk_children = (obj->yco_latest == versionFound);\n    }\n\n    // Search the cache for the children of this object and add them to fs_dir\n    if (should_walk_children) {\n        dir_open_cb_args args;\n        args.yfs = yfs;\n        args.dir = fs_dir;\n        args.parent_addr = a_addr;\n        yaffscache_find_children(yfs, a_addr, yaffs_dir_open_meta_cb, &args);\n    }\n\n    // add special entries to root directory\n    if (obj_id == YAFFS_OBJECT_ROOT) {\n        strncpy(fs_name->name, YAFFS_OBJECT_UNLINKED_NAME, fs_name->name_size);\n        fs_name->meta_addr = YAFFS_OBJECT_UNLINKED;\n        fs_name->type = TSK_FS_NAME_TYPE_DIR;\n        fs_name->flags = TSK_FS_NAME_FLAG_ALLOC;\n        if (tsk_fs_dir_add(fs_dir, fs_name)) {\n            tsk_fs_name_free(fs_name);\n            return TSK_ERR;\n        }\n\n        strncpy(fs_name->name, YAFFS_OBJECT_DELETED_NAME, fs_name->name_size);\n        fs_name->meta_addr = YAFFS_OBJECT_DELETED;\n        fs_name->type = TSK_FS_NAME_TYPE_DIR;\n        fs_name->flags = TSK_FS_NAME_FLAG_ALLOC;\n        if (tsk_fs_dir_add(fs_dir, fs_name)) {\n            tsk_fs_name_free(fs_name);\n            return TSK_ERR;\n        }\n\n        // orphan directory\n        if (tsk_fs_dir_make_orphan_dir_name(a_fs, fs_name)) {\n            tsk_fs_name_free(fs_name);\n            return TSK_ERR;\n        }\n        fs_name->meta_addr = yfs->fs_info.last_inum;\n        fs_name->type = TSK_FS_NAME_TYPE_DIR;\n        fs_name->flags = TSK_FS_NAME_FLAG_ALLOC;\n        if (tsk_fs_dir_add(fs_dir, fs_name)) {\n            tsk_fs_name_free(fs_name);\n            return TSK_ERR;\n        }\n    }\n\n    tsk_fs_name_free(fs_name);\n    return TSK_OK;\n}\n\nstatic TSK_FS_ATTR_TYPE_ENUM\n    yaffsfs_get_default_attr_type(const TSK_FS_FILE * /*a_file*/)\n{\n    return TSK_FS_ATTR_TYPE_DEFAULT;\n}\n\nstatic uint8_t\n    yaffsfs_load_attrs(TSK_FS_FILE *file)\n{\n    TSK_FS_ATTR *attr;\n    TSK_FS_META *meta;\n    TSK_FS_INFO *fs;\n    YAFFSFS_INFO *yfs;\n    TSK_FS_ATTR_RUN *data_run;\n    TSK_DADDR_T file_block_count;\n    YaffsCacheObject *obj;\n    YaffsCacheVersion *version;\n    TSK_RETVAL_ENUM result;\n    TSK_LIST *chunks_seen = NULL;\n    YaffsCacheChunk *curr;\n    TSK_FS_ATTR_RUN *data_run_new;\n\n\n    if (file == NULL || file->meta == NULL || file->fs_info == NULL)\n    {\n        tsk_error_set_errno(TSK_ERR_FS_ARG);\n        tsk_error_set_errstr\n            (\"yaffsfs_load_attrs: called with NULL pointers\");\n        return 1;\n    }\n\n    meta = file->meta;\n    yfs = (YAFFSFS_INFO *)file->fs_info;\n    fs = &yfs->fs_info;\n\n    // see if we have already loaded the runs\n    if ((meta->attr != NULL)\n        && (meta->attr_state == TSK_FS_META_ATTR_STUDIED)) {\n            return 0;\n    }\n    else if (meta->attr_state == TSK_FS_META_ATTR_ERROR) {\n        return 1;\n    }\n    // not sure why this would ever happen, but...\n    else if (meta->attr != NULL) {\n        tsk_fs_attrlist_markunused(meta->attr);\n    }\n    else if (meta->attr == NULL) {\n        meta->attr = tsk_fs_attrlist_alloc();\n    }\n\n    attr = tsk_fs_attrlist_getnew(meta->attr, TSK_FS_ATTR_NONRES);\n    if (attr == NULL) {\n        meta->attr_state = TSK_FS_META_ATTR_ERROR;\n        return 1;\n    }\n\n    if (meta->size == 0) {\n        data_run = NULL;\n    }\n    else {\n        /* BC: I'm not entirely sure this is needed.  My guess is that\n         * this was done instead of maintaining the head of the list of \n         * runs.  In theory, the tsk_fs_attr_add_run() method should handle\n         * the fillers. */\n        data_run = tsk_fs_attr_run_alloc();\n        if (data_run == NULL) {\n            tsk_fs_attr_run_free(data_run);\n            meta->attr_state = TSK_FS_META_ATTR_ERROR;\n            return 1;\n        }\n\n        data_run->offset = 0;\n        data_run->addr = 0;\n        data_run->len = (meta->size + fs->block_size - 1) / fs->block_size;\n        data_run->flags = TSK_FS_ATTR_RUN_FLAG_FILLER;\n    }\n    \n\n    // initialize the data run\n    if (tsk_fs_attr_set_run(file, attr, data_run, NULL,\n        TSK_FS_ATTR_TYPE_DEFAULT, TSK_FS_ATTR_ID_DEFAULT,\n        meta->size, meta->size, roundup(meta->size, fs->block_size), (TSK_FS_ATTR_FLAG_ENUM)0, 0)) {\n            meta->attr_state = TSK_FS_META_ATTR_ERROR;\n            return 1;\n    }\n\n    // If the file has size zero, return now\n    if(meta->size == 0){\n        meta->attr_state = TSK_FS_META_ATTR_STUDIED;\n        return 0;\n    }\n\n\n    /* Get the version for the given object. */\n    result = yaffscache_version_find_by_inode(yfs, meta->addr, &version, &obj);\n    if (result != TSK_OK || version == NULL) {\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"yaffsfs_load_attrs: yaffscache_version_find_by_inode failed!\\n\");\n        meta->attr_state = TSK_FS_META_ATTR_ERROR;\n        return 1;\n    }\n\n    if (tsk_verbose)\n        yaffscache_object_dump(stderr, obj);\n\n    file_block_count = data_run->len;\n    /* Cycle through the chunks for this version of this object */\n    curr = version->ycv_last_chunk;\n    while (curr != NULL && curr->ycc_obj_id == obj->yco_obj_id) {\n\n        if (curr->ycc_chunk_id == 0) {\n            if (tsk_verbose)\n                tsk_fprintf(stderr, \"yaffsfs_load_attrs: skipping header chunk\\n\");\n        }\n        else if (tsk_list_find(chunks_seen, curr->ycc_chunk_id)) {\n            if (tsk_verbose)\n                tsk_fprintf(stderr, \"yaffsfs_load_attrs: skipping duplicate chunk\\n\");\n        }\n        else if (curr->ycc_chunk_id > file_block_count) {\n            if (tsk_verbose)\n                tsk_fprintf(stderr, \"yaffsfs_load_attrs: skipping chunk past end\\n\");\n        }\n        /* We like this chunk */\n        else {\n            // add it to our internal list\n            if (tsk_list_add(&chunks_seen, curr->ycc_chunk_id)) {\n                meta->attr_state = TSK_FS_META_ATTR_ERROR;\n                tsk_list_free(chunks_seen);\n                chunks_seen = NULL;\n                return 1;\n            }\n\n            data_run_new = tsk_fs_attr_run_alloc();\n            if (data_run_new == NULL) {\n                tsk_fs_attr_run_free(data_run_new);\n                meta->attr_state = TSK_FS_META_ATTR_ERROR;\n                return 1;\n            }\n\n            data_run_new->offset = (curr->ycc_chunk_id - 1);\n            data_run_new->addr = curr->ycc_offset / (fs->block_pre_size + fs->block_size + fs->block_post_size);\n            data_run_new->len = 1;\n            data_run_new->flags = TSK_FS_ATTR_RUN_FLAG_NONE;\n\n            if (tsk_verbose)\n                tsk_fprintf(stderr, \"yaffsfs_load_attrs: @@@ Chunk %d : %08x is at offset 0x%016llx\\n\",\n                curr->ycc_chunk_id, curr->ycc_seq_number, curr->ycc_offset);\n\n            tsk_fs_attr_add_run(fs, attr, data_run_new);\n        }\n\n        curr = curr->ycc_prev;\n    }\n\n    tsk_list_free(chunks_seen);\n    meta->attr_state = TSK_FS_META_ATTR_STUDIED;\n    return 0;\n}\n\nstatic uint8_t \n    yaffsfs_jentry_walk(TSK_FS_INFO * /*info*/, int /*entry*/,\n    TSK_FS_JENTRY_WALK_CB /*cb*/, void * /*fn*/)\n{\n    tsk_error_reset();\n    tsk_error_set_errno(TSK_ERR_FS_UNSUPFUNC);\n    tsk_error_set_errstr(\"Journal support for YAFFS is not implemented\");\n    return 1;\n}\n\nstatic uint8_t \n    yaffsfs_jblk_walk(TSK_FS_INFO * /*info*/, TSK_DADDR_T /*daddr*/,\n    TSK_DADDR_T /*daddrt*/, int /*entry*/, TSK_FS_JBLK_WALK_CB /*cb*/,\n    void * /*fn*/)\n{\n    tsk_error_reset();\n    tsk_error_set_errno(TSK_ERR_FS_UNSUPFUNC);\n    tsk_error_set_errstr(\"Journal support for YAFFS is not implemented\");\n    return 1;\n}\n\nstatic uint8_t \n    yaffsfs_jopen(TSK_FS_INFO * /*info*/, TSK_INUM_T /*inum*/)\n{\n    tsk_error_reset();\n    tsk_error_set_errno(TSK_ERR_FS_UNSUPFUNC);\n    tsk_error_set_errstr(\"Journal support for YAFFS is not implemented\");\n    return 1;\n}\n\n/**\n* \\internal\n* Open part of a disk image as a Yaffs/2 file system.\n*\n* @param img_info Disk image to analyze\n* @param offset Byte offset where file system starts\n* @param ftype Specific type of file system\n* @param test Going to use this - 1 if we're doing auto-detect, 0 if not (display more verbose messages if the user specified YAFFS2)\n* @returns NULL on error or if data is not an Yaffs/3 file system\n*/\nTSK_FS_INFO *\n    yaffs2_open(TSK_IMG_INFO * img_info, TSK_OFF_T offset,\n    TSK_FS_TYPE_ENUM ftype, uint8_t test)\n{\n    YAFFSFS_INFO *yaffsfs = NULL;\n    TSK_FS_INFO *fs = NULL;\n    const unsigned int psize = img_info->page_size;\n    const unsigned int ssize = img_info->spare_size;\n    YaffsHeader * first_header = NULL;\n    TSK_FS_DIR *test_dir;\n    std::map<std::string, std::string> configParams;\n    YAFFS_CONFIG_STATUS config_file_status;\n\n    // clean up any error messages that are lying around\n    tsk_error_reset();\n\n    if (TSK_FS_TYPE_ISYAFFS2(ftype) == 0) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_ARG);\n        tsk_error_set_errstr(\"Invalid FS Type in yaffsfs_open\");\n        return NULL;\n    }\n\n    if (img_info->sector_size == 0) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_ARG);\n        tsk_error_set_errstr(\"yaffs2_open: sector size is 0\");\n        return NULL;\n    }\n\n    \n\n    if ((yaffsfs = (YAFFSFS_INFO *) tsk_fs_malloc(sizeof(YAFFSFS_INFO))) == NULL)\n        return NULL;\n    yaffsfs->cache_objects = NULL;\n    yaffsfs->chunkMap = NULL;\n\n    fs = &(yaffsfs->fs_info);\n\n    fs->tag = TSK_FS_INFO_TAG;\n    fs->ftype = ftype;\n    fs->flags = (TSK_FS_INFO_FLAG_ENUM)0;\n    fs->img_info = img_info;\n    fs->offset = offset;\n    fs->endian = TSK_LIT_ENDIAN;\n\n    // Read config file (if it exists)\n    config_file_status = yaffs_load_config_file(img_info, configParams);\n    // BL-6929(JTS): When using external readers, this call will fail.\n    // Not having a config should not be a fatal error.\n  /*if(config_file_status == YAFFS_CONFIG_ERROR){\n        // tsk_error was set by yaffs_load_config\n        goto on_error;\n    }\n    else*/ if(config_file_status == YAFFS_CONFIG_OK){\n        // Validate the input\n        // If it fails validation, return (tsk_error will be set up already)\n        if(1 == yaffs_validate_config_file(configParams)){\n            goto on_error;\n        }\n    }\n\n    // If we read these fields from the config file, use those values. Otherwise use the defaults\n    if(configParams.find(YAFFS_CONFIG_PAGE_SIZE_STR) != configParams.end()){\n        yaffsfs->page_size = atoi(configParams[YAFFS_CONFIG_PAGE_SIZE_STR].c_str());\n    }\n    else{\n        yaffsfs->page_size = psize == 0 ? YAFFS_DEFAULT_PAGE_SIZE : psize;\n    }\n\n    if(configParams.find(YAFFS_CONFIG_SPARE_SIZE_STR) != configParams.end()){\n        yaffsfs->spare_size = atoi(configParams[YAFFS_CONFIG_SPARE_SIZE_STR].c_str());\n    }\n    else{\n        yaffsfs->spare_size = ssize == 0 ? YAFFS_DEFAULT_SPARE_SIZE : ssize;\n    }\n\n    if(configParams.find(YAFFS_CONFIG_CHUNKS_PER_BLOCK_STR) != configParams.end()){\n        yaffsfs->chunks_per_block = atoi(configParams[YAFFS_CONFIG_CHUNKS_PER_BLOCK_STR].c_str());\n    }\n    else{\n        yaffsfs->chunks_per_block = 64;\n    }\n\n    // TODO: Why are 2 different memory allocation methods used in the same code?\n    // This makes things unnecessary complex.\n    yaffsfs->max_obj_id = 1;\n    yaffsfs->max_version = 0;\n\n    // Keep track of whether we're doing auto-detection of the file system\n    if(test){\n        yaffsfs->autoDetect = 1;\n    }\n    else{\n        yaffsfs->autoDetect = 0;\n    }\n\n    // Determine the layout of the spare area\n    // If it was specified in the config file, use those values. Otherwise do the auto-detection\n    if(configParams.find(YAFFS_CONFIG_SEQ_NUM_STR) != configParams.end()){\n        // In the validation step, we ensured that if one of the offsets was set, we have all of them\n        yaffsfs->spare_seq_offset = atoi(configParams[YAFFS_CONFIG_SEQ_NUM_STR].c_str());\n        yaffsfs->spare_obj_id_offset = atoi(configParams[YAFFS_CONFIG_OBJ_ID_STR].c_str());\n        yaffsfs->spare_chunk_id_offset = atoi(configParams[YAFFS_CONFIG_CHUNK_ID_STR].c_str());\n\n        // Check that the offsets are valid for the given spare area size (fields are 4 bytes long)\n        if((yaffsfs->spare_seq_offset + 4 > yaffsfs->spare_size) ||\n            (yaffsfs->spare_obj_id_offset + 4 > yaffsfs->spare_size) ||\n            (yaffsfs->spare_chunk_id_offset + 4 > yaffsfs->spare_size)){\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_FS);\n            tsk_error_set_errstr(\"yaffs2_open: Offset(s) in config file too large for spare area (size %d). %s\", yaffsfs->spare_size, YAFFS_HELP_MESSAGE);\n            goto on_error;\n        }\n\n\n        // nBytes isn't currently used, so just set to zero\n        yaffsfs->spare_nbytes_offset = 0;\n    }\n    else{\n        // Decide how many blocks to test. If we're not doing auto-detection, set to zero (no limit)\n        unsigned int maxBlocksToTest;\n        if(yaffsfs->autoDetect){\n            maxBlocksToTest = YAFFS_DEFAULT_MAX_TEST_BLOCKS;\n        }\n        else{\n            maxBlocksToTest = 0;\n        }\n\n        if(yaffs_initialize_spare_format(yaffsfs, maxBlocksToTest) != TSK_OK){\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_FS_MAGIC);\n            tsk_error_set_errstr(\"not a YAFFS file system (bad spare format). %s\", YAFFS_HELP_MESSAGE);\n            if (tsk_verbose)\n                fprintf(stderr, \"yaffsfs_open: could not find valid spare area format\\n%s\\n\", YAFFS_HELP_MESSAGE);\n            goto on_error;\n        }\n    }\n\n    /*\n    * Read the first record, make sure it's a valid header...\n    *\n    * Used for verification and autodetection of\n    * the FS type.\n    */\n    if (yaffsfs_read_header(yaffsfs, &first_header, 0)) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_MAGIC);\n        tsk_error_set_errstr(\"not a YAFFS file system (first record). %s\", YAFFS_HELP_MESSAGE);\n        if (tsk_verbose)\n            fprintf(stderr, \"yaffsfs_open: invalid first record\\n%s\\n\", YAFFS_HELP_MESSAGE);\n        goto on_error;\n    }\n    free(first_header);\n    first_header = NULL;\n\n    fs->duname = \"Chunk\";\n\n    /*\n    * Calculate the meta data info\n    */\n    //fs->last_inum = 0xffffffff; // Will update this as we go\n    fs->last_inum = 0;\n    fs->root_inum = YAFFS_OBJECT_ROOT;\n    fs->first_inum = YAFFS_OBJECT_FIRST;\n    //fs->inum_count = fs->last_inum; // For now this will be the last_inum - 1 (after we calculate it)\n\n    /*\n    * Calculate the block info\n    */\n    fs->dev_bsize = img_info->sector_size;\n    fs->block_size = yaffsfs->page_size;\n    fs->block_pre_size = 0;\n    fs->block_post_size = yaffsfs->spare_size;\n    fs->block_count = img_info->size / (fs->block_pre_size + fs->block_size + fs->block_post_size);\n    fs->first_block = 0;\n    fs->last_block_act = fs->last_block = fs->block_count ? fs->block_count - 1 : 0;\n\n    /* Set the generic function pointers */\n    fs->inode_walk = yaffsfs_inode_walk;\n    fs->block_walk = yaffsfs_block_walk;\n    fs->block_getflags = yaffsfs_block_getflags;\n\n    fs->get_default_attr_type = yaffsfs_get_default_attr_type;\n    fs->load_attrs = yaffsfs_load_attrs;\n\n    fs->file_add_meta = yaffs_inode_lookup;\n    fs->dir_open_meta = yaffsfs_dir_open_meta;\n    fs->fsstat = yaffsfs_fsstat;\n    fs->fscheck = yaffsfs_fscheck;\n    fs->istat = yaffsfs_istat;\n    fs->name_cmp = tsk_fs_unix_name_cmp;\n\n    fs->close = yaffsfs_close;\n\n    /* Journal */\n    fs->jblk_walk = yaffsfs_jblk_walk;\n    fs->jentry_walk = yaffsfs_jentry_walk;\n    fs->jopen = yaffsfs_jopen;\n\n    /* Initialize the caches */\n    if (tsk_verbose)\n        fprintf(stderr, \"yaffsfs_open: building cache...\\n\");\n\n    /* Build cache */\n    /* NOTE: The only modifications to the cache happen here, during at \n    *       the open. Should be fine with no lock, even if access to the\n    *       cache is shared among threads.\n    */\n    //tsk_init_lock(&yaffsfs->lock);\n    yaffsfs->chunkMap = new std::map<uint32_t, YaffsCacheChunkGroup>;\n    if (TSK_OK != yaffsfs_parse_image_load_cache(yaffsfs)) {\n        goto on_error;\n    }\n\n    if (tsk_verbose) {\n        fprintf(stderr, \"yaffsfs_open: done building cache!\\n\");\n        //yaffscache_objects_dump(yaffsfs, stderr);\n    }\n\n    // Update the number of inums now that we've read in the file system\n    fs->inum_count = fs->last_inum - 1;\n\n    test_dir = tsk_fs_dir_open_meta(fs, fs->root_inum);\n    if (test_dir == NULL) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_MAGIC);\n        tsk_error_set_errstr(\"not a YAFFS file system (no root directory). %s\", YAFFS_HELP_MESSAGE);\n        if (tsk_verbose)\n            fprintf(stderr, \"yaffsfs_open: invalid file system\\n%s\\n\", YAFFS_HELP_MESSAGE);\n        goto on_error;\n    }\n    tsk_fs_dir_close(test_dir);\n\n    return fs;\n\non_error:\n    // yaffsfs_close frees all the cache objects\n    yaffsfs_close(fs);\n\n    return NULL;\n}\n\n"], "fixing_code": ["/*\n** The Sleuth Kit\n**\n** Brian Carrier [carrier <at> sleuthkit [dot] org]\n** Copyright (c) 2006-2011 Brian Carrier, Basis Technology.  All Rights reserved\n** Copyright (c) 2003-2005 Brian Carrier.  All rights reserved\n**\n** TASK\nv** Copyright (c) 2002-2003 Brian Carrier, @stake Inc.  All rights reserved\n**\n** Copyright (c) 1997,1998,1999, International Business Machines\n** Corporation and others. All Rights Reserved.\n*/\n\n/**\n*\\file yaffs.cpp\n* Contains the internal TSK YAFFS2 file system functions.\n*/\n\n/* TCT\n* LICENSE\n*\tThis software is distributed under the IBM Public License.\n* AUTHOR(S)\n*\tWietse Venema\n*\tIBM T.J. Watson Research\n*\tP.O. Box 704\n*\tYorktown Heights, NY 10598, USA\n--*/\n\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <string.h>\n\n#include \"tsk_fs_i.h\"\n#include \"tsk_yaffs.h\"\n#include \"tsk_fs.h\"\n\n/*\n* Implementation Notes:\n*    - As inode, we use object id and a version number derived from the \n*      number of unique sequence ids for the object still left in the\n*      file system.\n*\n*    - The version numbers start at 1 and increase as they get closer to\n*      the the latest version.  Version number 0 is a special version\n*      that is equivalent to the latest version (without having to know\n*      the latest version number.)\n*\n*    - Since inodes are composed using the object id in the least \n*      significant bits and the version up higher, requesting the\n*      inode that matches the object id you are looking for will\n*      retrieve the latest version of this object.\n*\n*    - Files always exist in the latest version of their parent directory \n*      only.\n*\n*    - Filenames are not unique even with attached version numbers, since\n*      version numbers are namespaced by inode.\n*\n*    - The cache stores a lot of info via the structure.  As this is\n*      used for investigations, we assume these decisions will be updated\n*      to expose the most useful view of this log based file system.  TSK\n*      doesn't seem have a real way to expose a versioned view of a log\n*      based file system like this.  Shoehorning it into the framework\n*      ends up dropping some information.  I looked at using resource \n*      streams as versions, but the abstraction breaks quickly.\n*\n*/\n\nstatic const int TWELVE_BITS_MASK = 0xFFF; // Only keep 12 bits\n\nstatic uint8_t \n    yaffsfs_read_header(YAFFSFS_INFO *yfs, YaffsHeader ** header, TSK_OFF_T offset);\nstatic uint8_t\n    yaffsfs_load_attrs(TSK_FS_FILE *file);\n\n/**\n * Generate an inode number based on the file's object and version numbers\n */\nstatic TSK_RETVAL_ENUM\n    yaffscache_obj_id_and_version_to_inode(uint32_t obj_id, uint32_t version_num, TSK_INUM_T *inode) {\n        if ((obj_id & ~YAFFS_OBJECT_ID_MASK) != 0) {\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_FS);\n            tsk_error_set_errstr(\n                \"yaffsfs_parse_image_load_cache: Max object ID %\" PRIu32 \" is invalid\", obj_id);\n            return TSK_ERR;\n        }\n\n        if ((version_num & ~YAFFS_VERSION_NUM_MASK) != 0) {\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_FS);\n            tsk_error_set_errstr(\n                \"yaffsfs_parse_image_load_cache: Max version number %\" PRIu32 \" is invalid\", version_num);\n            return TSK_ERR;\n        }\n\n        *inode = obj_id | (version_num << YAFFS_VERSION_NUM_SHIFT);\n        return TSK_OK;\n}\n\n/**\n * Given the TSK-generated inode address, extract the object id and version number from it\n */\nstatic TSK_RETVAL_ENUM\n    yaffscache_inode_to_obj_id_and_version(TSK_INUM_T inode, uint32_t *obj_id, uint32_t *version_num) {\n        *obj_id = inode & YAFFS_OBJECT_ID_MASK;\n        *version_num = (inode >> YAFFS_VERSION_NUM_SHIFT) & YAFFS_VERSION_NUM_MASK;\n\n        return TSK_OK;\n}\n\n/*\n* Order it like yaffs2.git does -- sort by (seq_num, offset/block)\n*/\nstatic int\n    yaffscache_chunk_compare(YaffsCacheChunk *curr, uint32_t addee_obj_id, TSK_OFF_T addee_offset, uint32_t addee_seq_number)\n{\n    if (curr->ycc_obj_id == addee_obj_id) {\n        if (curr->ycc_seq_number == addee_seq_number) {\n            if (curr->ycc_offset == addee_offset) {\n                return 0;\n            }\n            else if (curr->ycc_offset < addee_offset) {\n                return -1;\n            }\n            else {\n                return 1;\n            }\n        }\n        else if (curr->ycc_seq_number < addee_seq_number) {\n            return -1;\n        }\n        else {\n            return 1;\n        }\n    }\n    else if (curr->ycc_obj_id < addee_obj_id) {\n        return -1;\n    }\n    else {\n        return 1;\n    }\n}\n\nstatic TSK_RETVAL_ENUM\n    yaffscache_chunk_find_insertion_point(YAFFSFS_INFO *yfs, uint32_t obj_id, TSK_OFF_T offset, uint32_t seq_number, YaffsCacheChunk **chunk)\n{\n    YaffsCacheChunk *curr, *prev;\n\n    // Have we seen this obj_id? If not, add an entry for it\n    if(yfs->chunkMap->find(obj_id) == yfs->chunkMap->end()){\n        fflush(stderr);\n        YaffsCacheChunkGroup chunkGroup;\n        chunkGroup.cache_chunks_head = NULL;\n        chunkGroup.cache_chunks_tail = NULL;\n        yfs->chunkMap->insert(std::make_pair(obj_id, chunkGroup));\n    }\n\n    curr = yfs->chunkMap->operator[](obj_id).cache_chunks_head;\n    prev = NULL;\n\n    if (chunk == NULL) {\n        return TSK_ERR;\n    }\n\n    while(curr != NULL) {\n        // Compares obj id, then seq num, then offset. -1 => current < new\n        int cmp = yaffscache_chunk_compare(curr, obj_id, offset, seq_number);\n\n        if (cmp == 0) {\n            *chunk = curr;\n            return TSK_OK;\n        }\n        else if (cmp == 1) {\n            *chunk = prev;\n            return TSK_STOP;\n        }\n\n        prev = curr;\n        curr = curr->ycc_next;\n    }\n\n    *chunk = prev;\n    return TSK_STOP;\n}\n\n/**\n * Add a chunk to the cache. \n * @param yfs\n * @param offset Byte offset this chunk was found in (in the disk image)\n * @param seq_number Sequence number of this chunk\n * @param obj_id Object Id this chunk is associated with\n * @param parent_id Parent object ID that this chunk/object is associated with\n */\nstatic TSK_RETVAL_ENUM\n    yaffscache_chunk_add(YAFFSFS_INFO *yfs, TSK_OFF_T offset, uint32_t seq_number,\n    uint32_t obj_id, uint32_t chunk_id, uint32_t parent_id)\n{\n    TSK_RETVAL_ENUM result;\n    YaffsCacheChunk *prev;\n    YaffsCacheChunk *chunk;\n    if ((chunk = (YaffsCacheChunk*)tsk_malloc(sizeof(YaffsCacheChunk))) == NULL) {\n        return TSK_ERR;\n    }\n\n    chunk->ycc_offset = offset;\n    chunk->ycc_seq_number = seq_number;\n    chunk->ycc_obj_id = obj_id;\n    chunk->ycc_chunk_id = chunk_id;\n    chunk->ycc_parent_id = parent_id;\n\n    // Bit of a hack here. In some images, the root directory (obj_id = 1) lists iself as its parent\n    // directory, which can cause issues later when we get directory contents. To prevent this,\n    // if a chunk comes in with obj_id = 1 and parent_id = 1, manually set the parent ID to zero.\n    if((obj_id == 1) && (parent_id == 1)){\n        chunk->ycc_parent_id = 0;\n    }\n\n    // Find the chunk that should go right before the new chunk\n    result = yaffscache_chunk_find_insertion_point(yfs, obj_id, offset, seq_number, &prev);\n\n    if (result == TSK_ERR) {\n        return TSK_ERR;\n    }\n\n    if (prev == NULL) {\n        // No previous chunk - new chunk is the lowest we've seen and the new start of the list\n        chunk->ycc_prev = NULL;\n        chunk->ycc_next = yfs->chunkMap->operator[](obj_id).cache_chunks_head;\n    }\n    else {\n        chunk->ycc_prev = prev;\n        chunk->ycc_next = prev->ycc_next;\n    }\n\n    if (chunk->ycc_next != NULL) {\n        // If we're not at the end, set the prev pointer on the next chunk to point to our new one\n        chunk->ycc_next->ycc_prev = chunk;\n    }\n    else {\n        yfs->chunkMap->operator[](obj_id).cache_chunks_tail = chunk;\n    }\n\n    if (chunk->ycc_prev != NULL) {\n        // If we're not at the beginning, set the next pointer on the previous chunk to point at our new one\n        chunk->ycc_prev->ycc_next = chunk;\n    }\n    else {\n        yfs->chunkMap->operator[](obj_id).cache_chunks_head = chunk;\n    }\n\n    return TSK_OK;\n}\n\n\n/**\n * Get the file object from the cache.\n * @returns TSK_OK if it was found and TSK_STOP if we did not find it\n */\nstatic TSK_RETVAL_ENUM\n    yaffscache_object_find(YAFFSFS_INFO *yfs, uint32_t obj_id, YaffsCacheObject **obj)\n{\n    YaffsCacheObject *curr, *prev;\n    curr = yfs->cache_objects;\n    prev = NULL;\n\n    if (obj == NULL) {\n        return TSK_ERR;\n    }\n\n    while(curr != NULL) {\n        if (curr->yco_obj_id == obj_id) {\n            *obj = curr;\n            return TSK_OK;\n        }\n        else if (curr->yco_obj_id > obj_id) {\n            *obj = prev;\n            return TSK_STOP;\n        }\n\n        prev = curr;\n        curr = curr->yco_next;\n    }\n\n    *obj = prev;\n    return TSK_STOP;\n}\n\n/**\n * Add an object to the cache if it does not already exist in there.\n * @returns TSK_ERR  on error, TSK_OK otherwise.\n */\nstatic TSK_RETVAL_ENUM\n    yaffscache_object_find_or_add(YAFFSFS_INFO *yfs, uint32_t obj_id, YaffsCacheObject **obj)\n{\n    YaffsCacheObject *prev;\n    TSK_RETVAL_ENUM result;\n\n    if (obj == NULL) {\n        return TSK_ERR;\n    }\n\n    // Look for this obj_id in yfs->cache_objects\n    // If not found, add it in the correct spot\n    // yaffscache_object_find returns the last object with obj_id less than the one\n    // we were searching for, so use that to insert the new one in the list\n    result = yaffscache_object_find(yfs, obj_id, &prev);\n    if (result == TSK_OK) {\n        *obj = prev;\n        return TSK_OK;\n    }\n    else if (result == TSK_STOP) {\n        *obj = (YaffsCacheObject *) tsk_malloc(sizeof(YaffsCacheObject));\n        (*obj)->yco_obj_id = obj_id;\n        if (prev == NULL) {\n            (*obj)->yco_next = yfs->cache_objects;\n            yfs->cache_objects = *obj;\n        }\n        else {\n            (*obj)->yco_next = prev->yco_next;\n            prev->yco_next = (*obj);\n        }\n        return TSK_OK;\n    }\n    else {\n        *obj = NULL;\n        return TSK_ERR;\n    }\n}\n\nstatic TSK_RETVAL_ENUM\n    yaffscache_object_add_version(YaffsCacheObject *obj, YaffsCacheChunk *chunk)\n{\n    uint32_t ver_number;\n    YaffsCacheChunk *header_chunk = NULL;\n    YaffsCacheVersion *version;\n\n    // Going to try ignoring unlinked/deleted headers (objID 3 and 4)\n    if ((chunk->ycc_chunk_id == 0) && (chunk->ycc_parent_id != YAFFS_OBJECT_UNLINKED) \n        &&(chunk->ycc_parent_id != YAFFS_OBJECT_DELETED)) {\n            header_chunk = chunk;\n    }\n\n    /* If this is the second version (since last header_chunk is not NULL) and no\n    * header was added, get rid of this incomplete old version -- can't be\n    * reasonably recovered.\n    *\n    * TODO: These chunks are still in the structure and can be walked,\n    *       but I'm not sure how to represent this set of data chunks\n    *       with no metadata under TSK. This is rare and we don't have\n    *       a testcase for it now. Punting right now.\n    *\n    * Edit: Shouldn't get to this point anymore. Changes to \n    *       yaffscache_versions_insert_chunk make a version continue until it\n    *       has a header block.\n    */\n    if (obj->yco_latest != NULL) {\n        if (obj->yco_latest->ycv_header_chunk == NULL) {\n            YaffsCacheVersion *incomplete = obj->yco_latest;\n\n            if (tsk_verbose)\n                tsk_fprintf(stderr, \"yaffscache_object_add_version: \"\n                \"removed an incomplete first version (no header)\\n\");\n\n            obj->yco_latest = obj->yco_latest->ycv_prior;\n            free(incomplete);\n        }\n    }\n\n    if (obj->yco_latest != NULL) {\n        ver_number = obj->yco_latest->ycv_version + 1;\n\n        /* Until a new header is given, use the last seen header. */\n        if (header_chunk == NULL) {\n            header_chunk = obj->yco_latest->ycv_header_chunk;\n\n            // If we haven't seen a good header yet and we have a deleted/unlinked one, use it\n            if((header_chunk == NULL) && (chunk->ycc_chunk_id == 0)){\n                header_chunk = chunk;\n            }\n        }\n    }\n    else {\n        ver_number = 1;\n    }\n\n    if ((version = (YaffsCacheVersion *) tsk_malloc(sizeof(YaffsCacheVersion))) == NULL) {\n        return TSK_ERR;\n    }\n\n    version->ycv_prior = obj->yco_latest;\n    version->ycv_version = ver_number;\n    version->ycv_seq_number = chunk->ycc_seq_number;\n    version->ycv_header_chunk = header_chunk;\n    version->ycv_first_chunk = chunk;\n    version->ycv_last_chunk = chunk;\n\n    obj->yco_latest = version;\n\n    return TSK_OK;\n}\n\n/**\n * Add a chunk to its corresponding object in the cache. \n */\nstatic TSK_RETVAL_ENUM\n    yaffscache_versions_insert_chunk(YAFFSFS_INFO *yfs, YaffsCacheChunk *chunk)\n{\n    YaffsCacheObject *obj;\n    TSK_RETVAL_ENUM result;\n    YaffsCacheVersion *version;\n\n    // Building a list in yfs->cache_objects, sorted by obj_id\n    result = yaffscache_object_find_or_add(yfs, chunk->ycc_obj_id, &obj);\n    if (result != TSK_OK) {\n        return TSK_ERR;\n    }\n    version = obj->yco_latest;\n\n    /* First chunk in this object? */\n    if (version == NULL) {\n        yaffscache_object_add_version(obj, chunk);\n    }\n    else {\n        /* Chunk in the same update? */\n        if (chunk->ycc_seq_number == version->ycv_seq_number) {\n            version->ycv_last_chunk = chunk;\n            if ((chunk->ycc_chunk_id == 0) && (chunk->ycc_parent_id != YAFFS_OBJECT_UNLINKED) \n                &&(chunk->ycc_parent_id != YAFFS_OBJECT_DELETED)) {\n                    version->ycv_header_chunk = chunk;\n            }\n            else if((chunk->ycc_chunk_id == 0) && (version->ycv_header_chunk == NULL)){\n                version->ycv_header_chunk = chunk;\n            }\n        }\n        // If there was no header for the last version, continue adding to it instead\n        // of starting a new version. \n        else if(version->ycv_header_chunk == NULL){\n            version->ycv_seq_number = chunk->ycc_seq_number;\n            version->ycv_last_chunk = chunk;\n            if ((chunk->ycc_chunk_id == 0) && (chunk->ycc_parent_id != YAFFS_OBJECT_UNLINKED) \n                &&(chunk->ycc_parent_id != YAFFS_OBJECT_DELETED)) {\n                    version->ycv_header_chunk = chunk;\n            }\n            else if((chunk->ycc_chunk_id == 0) && (version->ycv_header_chunk == NULL)){\n                version->ycv_header_chunk = chunk;\n            }\n        }\n        else if(chunk->ycc_chunk_id == 0){   // Directories only have a header block\n            // If we're looking at a new version of a directory where the previous version had the same name, \n            // leave everything in the same version. Multiple versions of the same directory aren't really giving us \n            // any information.\n            YaffsHeader * newHeader;\n            yaffsfs_read_header(yfs, &newHeader, chunk->ycc_offset);\n            if((newHeader != NULL) && (newHeader->obj_type == YAFFS_TYPE_DIRECTORY)){\n                // Read in the old header\n                YaffsHeader * oldHeader;\n                yaffsfs_read_header(yfs, &oldHeader, version->ycv_header_chunk->ycc_offset);\n                if((oldHeader != NULL) && (oldHeader->obj_type == YAFFS_TYPE_DIRECTORY) &&\n                    (0 == strncmp(oldHeader->name, newHeader->name, YAFFS_HEADER_NAME_LENGTH))){\n                        version->ycv_seq_number = chunk->ycc_seq_number;\n                        version->ycv_last_chunk = chunk;\n                        version->ycv_header_chunk = chunk;\n                }\n                else{\n                    // The older header either isn't a directory or it doesn't have the same name, so leave it\n                    // as its own version\n                    yaffscache_object_add_version(obj, chunk);\n                }\n            }\n            else{\n                //  Not a directory\n                yaffscache_object_add_version(obj, chunk);\n            }\n        }\n        else{\n            //  Otherwise, add this chunk as the start of a new version\n            yaffscache_object_add_version(obj, chunk);\n        }\n    }\n\n    return TSK_OK;\n}\n\nstatic TSK_RETVAL_ENUM\n    yaffscache_versions_compute(YAFFSFS_INFO *yfs)\n{\n    std::map<unsigned int,YaffsCacheChunkGroup>::iterator iter;\n    for( iter = yfs->chunkMap->begin(); iter != yfs->chunkMap->end(); ++iter ) {\n        YaffsCacheChunk *chunk_curr = yfs->chunkMap->operator[](iter->first).cache_chunks_head;\n\n        while(chunk_curr != NULL) {\n            if (yaffscache_versions_insert_chunk(yfs, chunk_curr) != TSK_OK) {\n                return TSK_ERR;\n            }\n\n            chunk_curr = chunk_curr->ycc_next;\n        }\n    }\n\n    return TSK_OK;\n}\n\n/**\n * Callback for yaffscache_find_children()\n * @param obj Object that is a child\n * @param version Version of the object\n * @param args Pointer to what was passed into yaffscache_find_children\n */\ntypedef TSK_RETVAL_ENUM yc_find_children_cb(YaffsCacheObject *obj, YaffsCacheVersion *version, void *args);\n\n/**\n * Search the cache for objects that are children of the given address.\n * @param yfs\n * @param parent_inode Inode of folder/directory\n * @param cb Call back to call for each found child\n * @param args Pointer to structure that will be passed to cb\n * @returns TSK_ERR on error\n */\nstatic TSK_RETVAL_ENUM\n    yaffscache_find_children(YAFFSFS_INFO *yfs, TSK_INUM_T parent_inode, yc_find_children_cb cb, void *args)\n{\n    YaffsCacheObject *obj;\n\n    uint32_t parent_id, version_num;\n    if (yaffscache_inode_to_obj_id_and_version(parent_inode, &parent_id, &version_num) != TSK_OK) {\n        return TSK_ERR;\n    }\n\n    /* Iterate over all objects and all versions of the objects to see if one is the child\n     * of the given parent. */\n    for (obj = yfs->cache_objects; obj != NULL; obj = obj->yco_next) {\n        YaffsCacheVersion *version;\n        for (version = obj->yco_latest; version != NULL; version = version->ycv_prior) {\n            /* Is this an incomplete version? */\n            if (version->ycv_header_chunk == NULL) {\n                continue;\n            }\n\n            if (version->ycv_header_chunk->ycc_parent_id == parent_id) {\n                TSK_RETVAL_ENUM result = cb(obj, version, args);\n                if (result != TSK_OK)\n                    return result;\n            }\n        }\n    }\n\n    return TSK_OK;\n}\n\n/**\n * Lookup an object based on its inode.\n * @param yfs\n * @param inode\n * @param version [out] Pointer to store version of the object that was found (if inode had a version of 0)\n * @param obj_ret [out] Pointer to store found object into\n * @returns TSK_ERR on error. \n */\nstatic TSK_RETVAL_ENUM\n    yaffscache_version_find_by_inode(YAFFSFS_INFO *yfs, TSK_INUM_T inode, YaffsCacheVersion **version, YaffsCacheObject **obj_ret) {\n        uint32_t obj_id, version_num;\n        YaffsCacheObject *obj;\n        YaffsCacheVersion *curr;\n\n        if (version == NULL) {\n            return TSK_ERR;\n        }\n\n        // convert inode to obj and version and find it in cache\n        if (yaffscache_inode_to_obj_id_and_version(inode, &obj_id, &version_num) != TSK_OK) {\n            *version = NULL;\n            return TSK_ERR;\n        }\n\n        if (yaffscache_object_find(yfs, obj_id, &obj) != TSK_OK) {\n            *version = NULL;\n            return TSK_ERR;\n        }\n\n        if (version_num == 0) {\n            if (obj_ret != NULL) {\n                *obj_ret = obj;\n            }\n            *version = obj->yco_latest;\n            return TSK_OK;\n        }\n\n        // Find the requested version in the list. \n        for(curr = obj->yco_latest; curr != NULL; curr = curr->ycv_prior) {\n            if (curr->ycv_version == version_num) {\n                if (obj_ret != NULL) {\n                    *obj_ret = obj;\n                }\n                *version = curr;\n                return TSK_OK;\n            }\n        }\n\n        if (obj_ret != NULL) {\n            *obj_ret = NULL;\n        }\n        *version = NULL;\n        return TSK_ERR;\n}\n\nstatic void\n    yaffscache_object_dump(FILE *fp, YaffsCacheObject *obj)\n{\n    YaffsCacheVersion *next_version = obj->yco_latest;\n    YaffsCacheChunk *chunk = next_version->ycv_last_chunk;\n\n    fprintf(fp, \"Object %d\\n\", obj->yco_obj_id);\n    while(chunk != NULL && chunk->ycc_obj_id == obj->yco_obj_id) {\n        if (next_version != NULL && \n            chunk == next_version->ycv_last_chunk) {\n                fprintf(fp, \"  @%d: %p %p %p\\n\", \n                    next_version->ycv_version, \n                    (void*) next_version->ycv_header_chunk,\n                    (void*) next_version->ycv_first_chunk,\n                    (void*)next_version->ycv_last_chunk);\n                next_version = next_version->ycv_prior;\n        }\n\n        fprintf(fp, \"    + %p %08x %08x %0\" PRIxOFF \"\\n\",\n            (void*) chunk,\n            chunk->ycc_chunk_id,\n            chunk->ycc_seq_number,\n            chunk->ycc_offset);\n\n        chunk = chunk->ycc_prev;\n    }\n}\n\n/*\nstatic void\n    yaffscache_objects_dump(FILE *fp, YAFFSFS_INFO *yfs)\n{\n    YaffsCacheObject *obj;\n\n    for(obj = yfs->cache_objects; obj != NULL; obj = obj->yco_next)\n        yaffscache_object_dump(fp, obj);\n}\n*/\n\nstatic void\n    yaffscache_objects_stats(YAFFSFS_INFO *yfs, \n    unsigned int *obj_count,\n    uint32_t *obj_first, uint32_t *obj_last,\n    uint32_t *version_count,\n    uint32_t *version_first, uint32_t *version_last)\n{\n    YaffsCacheObject *obj;\n    YaffsCacheVersion *ver;\n\n    /* deleted and unlinked special objects don't have headers */\n    *obj_count = 2;\n    *obj_first = 0xffffffff;\n    *obj_last = 0;\n\n    *version_count = 0;\n    *version_first = 0xffffffff;\n    *version_last = 0;\n\n    for(obj = yfs->cache_objects; obj != NULL; obj = obj->yco_next) {\n        *obj_count += 1;\n        if (obj->yco_obj_id < *obj_first)\n            *obj_first = obj->yco_obj_id;\n        if (obj->yco_obj_id > *obj_last)\n            *obj_last = obj->yco_obj_id;\n\n        for(ver = obj->yco_latest; ver != NULL; ver = ver->ycv_prior) {\n            *version_count += 1;\n            if (ver->ycv_seq_number < *version_first)\n                *version_first = ver->ycv_seq_number;\n            if (ver->ycv_seq_number > *version_last)\n                *version_last = ver->ycv_seq_number;\n        }\n    }\n}\n\nstatic void\n    yaffscache_objects_free(YAFFSFS_INFO *yfs)\n{\n    if((yfs != NULL) && (yfs->cache_objects != NULL)){\n        YaffsCacheObject *obj = yfs->cache_objects;\n        while(obj != NULL) {\n            YaffsCacheObject *to_free = obj;\n\n            YaffsCacheVersion *ver = obj->yco_latest;\n            while(ver != NULL) {\n                YaffsCacheVersion *v_to_free = ver;\n                ver = ver->ycv_prior;\n                free(v_to_free);\n            }\n\n            obj = obj->yco_next;\n            free(to_free);\n        }\n    }\n}\n\nstatic void\n    yaffscache_chunks_free(YAFFSFS_INFO *yfs)\n{\n    if((yfs != NULL) && (yfs->chunkMap != NULL)){\n        // Free the YaffsCacheChunks in each ChunkGroup\n        std::map<unsigned int,YaffsCacheChunkGroup>::iterator iter;\n        for( iter = yfs->chunkMap->begin(); iter != yfs->chunkMap->end(); ++iter ) {\n            YaffsCacheChunk *chunk = yfs->chunkMap->operator[](iter->first).cache_chunks_head;\n            while(chunk != NULL) {\n                YaffsCacheChunk *to_free = chunk;\n                chunk = chunk->ycc_next;\n                free(to_free);\n            }\n        }\n\n        // Free the map\n        yfs->chunkMap->clear();\n        delete yfs->chunkMap;\n    }\n\n}\n\n\n\n/*\n* Parsing and helper functions\n*\n*\n*/\n\n/* Function to parse config file\n *\n * @param img_info Image info for this image\n * @param map<string, int> Stores values from config file indexed on parameter name\n * @returns YAFFS_CONFIG_STATUS One of \tYAFFS_CONFIG_OK, YAFFS_CONFIG_FILE_NOT_FOUND, or YAFFS_CONFIG_ERROR\n */\nstatic YAFFS_CONFIG_STATUS\nyaffs_load_config_file(TSK_IMG_INFO * a_img_info, std::map<std::string, std::string> & results){\n    size_t config_file_name_len;\n    TSK_TCHAR * config_file_name;\n    FILE* config_file;\n    char buf[1001];\n\n    // Ensure there is at least one image name\n    if(a_img_info->num_img < 1){\n        return YAFFS_CONFIG_ERROR;\n    }\n\n    // Construct the name of the config file from the first image name\n    config_file_name_len = TSTRLEN(a_img_info->images[0]);\n    config_file_name_len += TSTRLEN(YAFFS_CONFIG_FILE_SUFFIX);\n    config_file_name = (TSK_TCHAR *) tsk_malloc(sizeof(TSK_TCHAR) * (config_file_name_len + 1));\n\n    TSTRNCPY(config_file_name, a_img_info->images[0], TSTRLEN(a_img_info->images[0]) + 1);\n    TSTRNCAT(config_file_name, YAFFS_CONFIG_FILE_SUFFIX, TSTRLEN(YAFFS_CONFIG_FILE_SUFFIX) + 1);\n\n#ifdef TSK_WIN32\n    HANDLE hWin;\n\n    if ((hWin = CreateFile(config_file_name, GENERIC_READ,\n            FILE_SHARE_READ, 0, OPEN_EXISTING, 0,\n            0)) == INVALID_HANDLE_VALUE) {\n\n        // For the moment, assume that the file just doesn't exist, which isn't an error\n        free(config_file_name);\n        return YAFFS_CONFIG_FILE_NOT_FOUND;\n    }\n    config_file = _fdopen(_open_osfhandle((intptr_t) hWin, _O_RDONLY), \"r\");\n    if (config_file == NULL) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS);\n        tsk_error_set_errstr(\n                    \"yaffs_load_config: Error converting Windows handle to C handle\");\n        free(config_file_name);\n        CloseHandle(hWin);\n        return YAFFS_CONFIG_ERROR;\n    }\n#else\n    if (NULL == (config_file = fopen(config_file_name, \"r\"))) {\n        free(config_file_name);\n        return YAFFS_CONFIG_FILE_NOT_FOUND;\n    }\n#endif\n\n    while(fgets(buf, 1000, config_file) != NULL){\n\n        // Is it a comment?\n        if((buf[0] == '#') || (buf[0] == ';')){\n            continue;\n        }\n\n        // Is there a '=' ?\n        if(strchr(buf, '=') == NULL){\n            continue;\n        }\n\n        // Copy to strings while removing whitespace and converting to lower case\n        std::string paramName(\"\");\n        std::string paramVal(\"\");\n        \n        const char * paramNamePtr = strtok(buf, \"=\");\n        while(*paramNamePtr != '\\0'){\n            if(! isspace((char)(*paramNamePtr))){\n                paramName += tolower((char)(*paramNamePtr));\n            }\n            paramNamePtr++;\n        }\n    \n        const char * paramValPtr = strtok(NULL, \"=\");\n        while(*paramValPtr != '\\0'){\n            if(! isspace(*paramValPtr)){\n                paramVal += tolower((char)(*paramValPtr));\n            }\n            paramValPtr++;\n        }\n        \n        // Make sure this parameter is not already in the map\n        if(results.find(paramName) != results.end()){\n            // Duplicate parameter - return an error\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_FS);\n            tsk_error_set_errstr(\n                        \"yaffs_load_config: Duplicate parameter name in config file (\\\"%s\\\"). %s\", paramName.c_str(), YAFFS_HELP_MESSAGE);\n            fclose(config_file);\n            free(config_file_name);\n            return YAFFS_CONFIG_ERROR;\n        }\n\n        // Add this entry to the map\n        results[paramName] = paramVal;\n    }\n\n    fclose(config_file);\n    free(config_file_name);\n    return YAFFS_CONFIG_OK;\n}\n\n/*\n * Helper function for yaffs_validate_config\n * Tests that a string consists only of digits and has at least one digit\n * (Can modify later if we want negative fields to be valid)\n *\n * @param numStr String to test\n * @returns 1 on error, 0 on success\n */\nstatic int\nyaffs_validate_integer_field(std::string numStr){\n    unsigned int i;\n\n    // Test if empty\n    if(numStr.length() == 0){\n        return 1;\n    }\n\n    // Test each character\n    for(i = 0;i < numStr.length();i++){\n        if(isdigit(numStr[i]) == 0){\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\n/*\n * Function to validate the contents of the config file\n * Currently testing:\n *  All YAFFS_CONFIG fields should be integers (if they exist)\n *  Either need all three of YAFFS_CONFIG_SEQ_NUM_STR, YAFFS_CONFIG_OBJ_ID_STR, YAFFS_CONFIG_CHUNK_ID_STR\n *   or none of them\n *\n * @param paramMap Holds mapping of parameter name to parameter value\n * @returns 1 on error (invalid parameters), 0 on success\n */\nstatic int\nyaffs_validate_config_file(std::map<std::string, std::string> & paramMap){\n    int offset_field_count;\n\n    // Make a list of all fields to test\n    std::set<std::string> integerParams;\n    integerParams.insert(YAFFS_CONFIG_SEQ_NUM_STR);\n    integerParams.insert(YAFFS_CONFIG_OBJ_ID_STR);\n    integerParams.insert(YAFFS_CONFIG_CHUNK_ID_STR);\n    integerParams.insert(YAFFS_CONFIG_PAGE_SIZE_STR);\n    integerParams.insert(YAFFS_CONFIG_SPARE_SIZE_STR);\n    integerParams.insert(YAFFS_CONFIG_CHUNKS_PER_BLOCK_STR);\n\n    // If the parameter is set, verify that the value is an int\n    for(std::set<std::string>::iterator it = integerParams.begin();it != integerParams.end();it++){\n        if((paramMap.find(*it) != paramMap.end()) && \n            (0 != yaffs_validate_integer_field(paramMap[*it]))){\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_FS);\n            tsk_error_set_errstr(\n                        \"yaffs_validate_config_file: Empty or non-integer value for Yaffs2 parameter \\\"%s\\\". %s\", (*it).c_str(), YAFFS_HELP_MESSAGE);\n            return 1;\n        }\n    }\n\n    // Check that we have all three spare offset fields, or none of the three\n    offset_field_count = 0;\n    if(paramMap.find(YAFFS_CONFIG_SEQ_NUM_STR) != paramMap.end()){\n        offset_field_count++;\n    }\n    if(paramMap.find(YAFFS_CONFIG_OBJ_ID_STR) != paramMap.end()){\n        offset_field_count++;\n    }\n    if(paramMap.find(YAFFS_CONFIG_CHUNK_ID_STR) != paramMap.end()){\n        offset_field_count++;\n    }\n\n    if(! ((offset_field_count == 0) || (offset_field_count == 3))){\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_FS);\n            tsk_error_set_errstr(\n                        \"yaffs_validate_config_file: Require either all three spare offset fields or none. %s\", YAFFS_HELP_MESSAGE);\n            return 1;\n    }\n\n    // Make sure there aren't any unexpected fields present\n    for(std::map<std::string, std::string>::iterator it = paramMap.begin(); it != paramMap.end();it++){\n        if(integerParams.find(it->first) == integerParams.end()){\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_FS);\n            tsk_error_set_errstr(\n                        \"yaffs_validate_config_file: Found unexpected field in config file (\\\"%s\\\"). %s\", it->first.c_str(), YAFFS_HELP_MESSAGE);\n            return 1;\n        }\n    }\n\n    return 0;\n}\n\n/*\n* Function to attempt to determine the layout of the yaffs spare area.\n* Results of the analysis (if the format could be determined) will be stored\n* in yfs variables. \n*\n* @param yfs File system being analyzed\n* @param maxBlocksToTest Number of block groups to scan to detect spare area or 0 if there is no limit.\n* @returns TSK_ERR if format could not be detected and TSK_OK if it could be.\n*/\nstatic TSK_RETVAL_ENUM \nyaffs_initialize_spare_format(YAFFSFS_INFO * yfs, TSK_OFF_T maxBlocksToTest){\n\n    // Testing parameters - can all be changed\n    unsigned int blocksToTest = 10;  // Number of blocks (64 chunks) to test\n    unsigned int chunksToTest = 10;  // Number of chunks to test in each block \n    unsigned int minChunksRead = 10; // Minimum number of chunks we require to run the test (we might not get the full number we want to test for a very small file)\n\n    unsigned int chunkSize = yfs->page_size + yfs->spare_size;\n    unsigned int blockSize = yfs->chunks_per_block * chunkSize;\n\n    TSK_FS_INFO *fs = &(yfs->fs_info);\n    unsigned char *spareBuffer;\n\n    unsigned int blockIndex;\n    unsigned int chunkIndex;\n\n    unsigned int currentOffset;\n\n    unsigned char * allSpares;\n    unsigned int allSparesLength;\n    \n    TSK_OFF_T maxBlocks;\n\n    bool skipBlock;\n    int goodOffset;\n    unsigned int nGoodSpares;\n    unsigned int nBlocksTested;\n\n    int okOffsetFound = 0;   // Used as a flag for if we've found an offset that sort of works but doesn't seem great\n    int goodOffsetFound = 0; // Flag to mark that we've found an offset that also passed secondary testing\n    int bestOffset = 0;\n\n    bool allSameByte; // Used in test that the spare area fields not be one repeated byte\n\n    unsigned int i;\n\n    int thisChunkBase;\n    int lastChunkBase;\n\n    // The spare area needs to be at least 16 bytes to run the test\n    if(yfs->spare_size < 16){\n        if(tsk_verbose && (! yfs->autoDetect)){\n            tsk_fprintf(stderr,\n                \"yaffs_initialize_spare_format failed - given spare size (%d) is not large enough to contain needed fields\\n\", yfs->spare_size);\n        }\n        return TSK_ERR;\n    }\n\n    if ((spareBuffer = (unsigned char*) tsk_malloc(yfs->spare_size)) == NULL) {\n        return TSK_ERR;\n    }\n\n    allSparesLength = yfs->spare_size * blocksToTest * chunksToTest;\n    if ((allSpares = (unsigned char*) tsk_malloc(allSparesLength)) == NULL) {\n        free(spareBuffer);\n        return TSK_ERR;\n    }\n\n    // Initialize the pointers to one of the configurations we've seen (thought these defaults should not get used)\n    yfs->spare_seq_offset = 0;\n    yfs->spare_obj_id_offset = 4;\n    yfs->spare_chunk_id_offset = 8;\n    yfs->spare_nbytes_offset = 12;\n\n    // Assume the data we want is 16 consecutive bytes in the order:\n    //  seq num, obj id, chunk id, byte count\n    //  (not sure we're guaranteed this but we wouldn't be able to deal with the alternative anyway)\n    // Seq num is the important one. This number is constant in each block (block = 64 chunks), meaning\n    //  all chunks in a block will share the same sequence number. The YAFFS2 descriptions would seem to\n    //  indicate it should be different for each block, but this doesn't seem to always be the case.\n    //  In particular we frequently see the 0x1000 seq number used over multiple blocks, but this isn't the only\n    //  observed exception.\n\n    // Calculate the number of blocks in the image\n    maxBlocks = yfs->fs_info.img_info->size / (yfs->chunks_per_block * chunkSize);\n\n    // If maxBlocksToTest = 0 (unlimited), set it to the total number of blocks\n    // Also reduce the number of blocks to test if it is larger than the total number of blocks\n    if ((maxBlocksToTest == 0) || (maxBlocksToTest > maxBlocks)){\n        maxBlocksToTest = maxBlocks;\n    }\n\n    nGoodSpares = 0;\n    nBlocksTested = 0;\n    for (TSK_OFF_T blockIndex = 0;blockIndex < maxBlocksToTest;blockIndex++){\n\n        // Read the last spare area that we want to test first\n        TSK_OFF_T offset = (TSK_OFF_T)blockIndex * blockSize + (chunksToTest - 1) * chunkSize + yfs->page_size;\n        ssize_t cnt = tsk_img_read(fs->img_info, offset, (char *) spareBuffer,\n            yfs->spare_size);\n        if ((cnt < 0) || ((unsigned int)cnt < yfs->spare_size)) {\n            break;\n        }\n\n        // Is the spare all 0xff / 0x00?\n        // If not, we know we should have all allocated chunks since YAFFS2 writes sequentially in a block\n        //  - can't have an unallocated chunk followed by an allocated one\n        // We occasionally see almost all null spare area with a few 0xff, which is not a valid spare.\n        skipBlock = true;\n        for (i = 0;i < yfs->spare_size;i++){\n            if((spareBuffer[i] != 0xff) && (spareBuffer[i] != 0x00)){\n                skipBlock = false;\n                break;\n            }\n        }\n\n        if (skipBlock){\n            continue;\n        }\n\n        // If this block is potentialy valid (i.e., the spare contains something besides 0x00 and 0xff), copy all the spares into\n        // the big array of extracted spare areas\n\n        // Copy this spare area\n        nGoodSpares++;\n        for (i = 0;i < yfs->spare_size;i++){\n            allSpares[nBlocksTested * yfs->spare_size * chunksToTest + (chunksToTest - 1) * yfs->spare_size + i] = spareBuffer[i];\n        }\n\n        // Copy all earlier spare areas in the block\n        for (chunkIndex = 0;chunkIndex < chunksToTest - 1;chunkIndex++){\n            offset = blockIndex * blockSize + chunkIndex * chunkSize + yfs->page_size;\n            cnt = tsk_img_read(fs->img_info, offset, (char *) spareBuffer,\n                yfs->spare_size);\n            if ((cnt < 0) || ((unsigned int)cnt < yfs->spare_size)) {\n                // We really shouldn't run out of data here since we already read in the furthest entry\n                break; // Break out of chunksToTest loop\n            }\n\n            nGoodSpares++;\n            for(i = 0;i < yfs->spare_size;i++){\n                allSpares[nBlocksTested * yfs->spare_size * chunksToTest + chunkIndex * yfs->spare_size + i] = spareBuffer[i];\n            }\n        }\n\n        // Record that we've found a potentially valid block\n        nBlocksTested++;\n\n        // If we've found enough potentailly valid blocks, break\n        if (nBlocksTested >= blocksToTest){\n            break;\n        }\n    }\n\n    // Make sure we read enough data to reasonably perform the testing\n    if (nGoodSpares < minChunksRead){\n\n        if (tsk_verbose && (! yfs->autoDetect)){\n            tsk_fprintf(stderr,\n                \"yaffs_initialize_spare_format failed - not enough potentially valid data could be read\\n\");\n        }\n\n        free(spareBuffer);\n        free(allSpares);\n        return TSK_ERR;\n    }\n\n    if (tsk_verbose && (! yfs->autoDetect)){\n        tsk_fprintf(stderr,\n            \"yaffs_initialize_spare_format: Testing potential offsets for the sequence number in the spare area\\n\");\n    }\n\n    // Print out the collected spare areas if we're in verbose mode\n    if(tsk_verbose && (! yfs->autoDetect)){\n        for(blockIndex = 0;blockIndex < nBlocksTested;blockIndex++){\n            for(chunkIndex = 0;chunkIndex < chunksToTest;chunkIndex++){\n                for(i = 0;i < yfs->spare_size;i++){\n                    fprintf(stderr, \"%02x\", allSpares[blockIndex * yfs->spare_size * chunksToTest + chunkIndex * yfs->spare_size + i]);\n                }\n                fprintf(stderr, \"\\n\");\n            }\n        }\n    }\n\n    // Test all indices into the spare area (that leave enough space for all 16 bytes)\n    for(currentOffset = 0;currentOffset <= yfs->spare_size - 16;currentOffset++){\n        goodOffset = 1;\n        for(blockIndex = 0;blockIndex < nBlocksTested;blockIndex++){\n            for(chunkIndex = 1;chunkIndex < chunksToTest;chunkIndex++){\n\n                lastChunkBase = blockIndex * yfs->spare_size * chunksToTest + (chunkIndex - 1) * yfs->spare_size;\n                thisChunkBase = lastChunkBase + yfs->spare_size;\n\n                // Seq num should not be all 0xff (we tested earlier that the chunk has been initialized)\n                if((0xff == allSpares[thisChunkBase + currentOffset]) &&\n                    (0xff == allSpares[thisChunkBase + currentOffset + 1]) &&\n                    (0xff == allSpares[thisChunkBase + currentOffset + 2]) &&\n                    (0xff == allSpares[thisChunkBase + currentOffset + 3])){\n                        if(tsk_verbose && (! yfs->autoDetect)){\n                            tsk_fprintf(stderr,\n                                \"yaffs_initialize_spare_format: Eliminating offset %d - invalid sequence number 0xffffffff\\n\", \n                                currentOffset);\n                        }\n                        goodOffset = 0;\n                        break;\n                }\n\n                // Seq num should not be zero\n                if((0 == allSpares[thisChunkBase + currentOffset]) &&\n                    (0 == allSpares[thisChunkBase + currentOffset + 1]) &&\n                    (0 == allSpares[thisChunkBase + currentOffset + 2]) &&\n                    (0 == allSpares[thisChunkBase + currentOffset + 3])){\n                        if(tsk_verbose && (! yfs->autoDetect)){\n                            tsk_fprintf(stderr,\n                                \"yaffs_initialize_spare_format: Eliminating offset %d - invalid sequence number 0\\n\", \n                                currentOffset);\n                        }\n                        goodOffset = 0;\n                        break;\n                }\n\n                // Seq num should match the previous one in the block\n                if((allSpares[lastChunkBase + currentOffset] != allSpares[thisChunkBase + currentOffset]) ||\n                    (allSpares[lastChunkBase + currentOffset + 1] != allSpares[thisChunkBase + currentOffset + 1]) ||\n                    (allSpares[lastChunkBase + currentOffset + 2] != allSpares[thisChunkBase + currentOffset + 2]) ||\n                    (allSpares[lastChunkBase + currentOffset + 3] != allSpares[thisChunkBase + currentOffset + 3])){\n                        if(tsk_verbose && (! yfs->autoDetect)){\n                            tsk_fprintf(stderr,\n                                \"yaffs_initialize_spare_format: Eliminating offset %d - did not match previous chunk sequence number\\n\", \n                                currentOffset);\n                        }\n                        goodOffset = 0;\n                        break;\n                }\n\n                // Obj id should not be zero\n                if((0 == allSpares[thisChunkBase + currentOffset + 4]) &&\n                    (0 == allSpares[thisChunkBase + currentOffset + 5]) &&\n                    (0 == allSpares[thisChunkBase + currentOffset + 6]) &&\n                    (0 == allSpares[thisChunkBase + currentOffset + 7])){\n                        if(tsk_verbose && (! yfs->autoDetect)){\n                            tsk_fprintf(stderr,\n                                \"yaffs_initialize_spare_format: Eliminating offset %d - invalid object id 0\\n\", \n                                currentOffset);\n                        }\n                        goodOffset = 0;\n                        break;\n                }\n\n                // All 16 bytes should not be the same\n                // (It is theoretically possible that this could be valid, but incredibly unlikely)\n                allSameByte = true;\n                for(i = 1;i < 16;i++){\n                    if(allSpares[thisChunkBase + currentOffset] != allSpares[thisChunkBase + currentOffset + i]){\n                        allSameByte = false;\n                        break;\n                    }\n                }\n                if(allSameByte){\n                    if(tsk_verbose && (! yfs->autoDetect)){\n                        tsk_fprintf(stderr,\n                            \"yaffs_initialize_spare_format: Eliminating offset %d - all repeated bytes\\n\", \n                            currentOffset);\n                    }\n                    goodOffset = 0;\n                    break;\n                }\n\n            } // End of loop over chunks\n\n            if(!goodOffset){ // Break out of loop over blocks\n                break;\n            }\n        }\n        if(goodOffset){\n\n            // Note that we've found an offset that is at least promising\n            if((! goodOffsetFound) && (! okOffsetFound)){\n                bestOffset = currentOffset;\n            }\n            okOffsetFound = 1;\n\n            if(tsk_verbose && (! yfs->autoDetect)){\n                tsk_fprintf(stderr,\n                    \"yaffs_initialize_spare_format: Found potential spare offsets:  %d (sequence number), %d (object id), %d (chunk id), %d (n bytes)\\n\",\n                    currentOffset, currentOffset+4, currentOffset+8, currentOffset+12);\n            }\n\n            // Now do some more tests\n            // Really need some more real-world test data to do this right.\n            int possibleError = 0;\n\n            // We probably don't want the first byte to always be 0xff\n            int firstByteFF = 1;\n            for(blockIndex = 0;blockIndex < nBlocksTested;blockIndex++){\n                for(chunkIndex = 1;chunkIndex < chunksToTest;chunkIndex++){\n                    if(allSpares[blockIndex * yfs->spare_size * chunksToTest + chunkIndex * yfs->spare_size + currentOffset] != 0xff){\n                        firstByteFF = 0;\n                    }\n                }\n            }\n\n            if(firstByteFF){\n                if(tsk_verbose && (! yfs->autoDetect)){\n                    tsk_fprintf(stderr,\n                        \"yaffs_initialize_spare_format:  Previous data starts with all 0xff bytes. Looking for better offsets.\\n\");\n                }\n                possibleError = 1;\n            }\n\n            if(! possibleError){\n\n                // If we already have a good offset, print this one out but don't record it\n                if(! goodOffsetFound){\n\n                    goodOffsetFound = 1;\n                    bestOffset = currentOffset;\n\n                    // Offset passed additional testing and we haven't seen an earlier good one, so go ahead and use it\n                    if(tsk_verbose && (! yfs->autoDetect)){\n                        tsk_fprintf(stderr,\n                            \"yaffs_initialize_spare_format:  Previous offsets appear good - will use as final offsets\\n\");\n                    }\n\n                }\n                else{\n                    // Keep using the old one\n                    if(tsk_verbose && (! yfs->autoDetect)){\n                        tsk_fprintf(stderr,\n                            \"yaffs_initialize_spare_format:  Previous offsets appear good but staying with earlier valid ones\\n\");\n                    }\n                }\n            }\n        }\n    }\n\n    free(spareBuffer);\n    free(allSpares);\n\n    if(okOffsetFound || goodOffsetFound){\n        // Record everything\n        yfs->spare_seq_offset = bestOffset;\n        yfs->spare_obj_id_offset = bestOffset + 4;\n        yfs->spare_chunk_id_offset = bestOffset + 8;\n        yfs->spare_nbytes_offset = bestOffset + 12;\n\n        if(tsk_verbose && (! yfs->autoDetect)){\n            tsk_fprintf(stderr,\n                \"yaffs_initialize_spare_format: Final offsets: %d (sequence number), %d (object id), %d (chunk id), %d (n bytes)\\n\",\n                bestOffset, bestOffset+4, bestOffset+8, bestOffset+12);\n            tsk_fprintf(stderr,\n                \"If these do not seem valid: %s\\n\", YAFFS_HELP_MESSAGE);\n        }\n        return TSK_OK;\n    }\n    else{\n        return TSK_ERR;\n    }\n}\n\n/**\n* yaffsfs_read_header( ... )\n*\n*/\nstatic uint8_t \n    yaffsfs_read_header(YAFFSFS_INFO *yfs, YaffsHeader ** header, TSK_OFF_T offset)\n{\n    unsigned char *hdr;\n    ssize_t cnt;\n    YaffsHeader *head;\n    TSK_FS_INFO *fs = &(yfs->fs_info);\n\n    if ((hdr = (unsigned char*) tsk_malloc(yfs->page_size)) == NULL) {\n        return 1;\n    }\n\n    cnt = tsk_img_read(fs->img_info, offset, (char *) hdr,\n        yfs->page_size);\n    if ((cnt < 0) || ((unsigned int)cnt < yfs->page_size)) {\n        free(hdr);\n        return 1;\n    }\n\n    if ((head = (YaffsHeader*) tsk_malloc( sizeof(YaffsHeader))) == NULL) {\n        free(hdr);\n        return 1;\n    }\n\n    memcpy(&head->obj_type, hdr, 4);\n    memcpy(&head->parent_id, &hdr[4], 4);\n    memcpy(head->name, (char*) &hdr[0xA], YAFFS_HEADER_NAME_LENGTH);\n    memcpy(&head->file_mode, &hdr[0x10C], 4);\n    memcpy(&head->user_id, &hdr[0x110], 4);\n    memcpy(&head->group_id, &hdr[0x114], 4);\n    memcpy(&head->atime, &hdr[0x118], 4);\n    memcpy(&head->mtime, &hdr[0x11C], 4);\n    memcpy(&head->ctime, &hdr[0x120], 4);\n    memcpy(&head->file_size, &hdr[0x124], 4);\n    memcpy(&head->equivalent_id, &hdr[0x128], 4);\n    memcpy(head->alias, (char*) &hdr[0x12C], YAFFS_HEADER_ALIAS_LENGTH);\n\n    //memcpy(&head->rdev_mode, &hdr[0x1CC], 4);\n    //memcpy(&head->win_ctime, &hdr[0x1D0], 8);\n    //memcpy(&head->win_atime, &hdr[0x1D8], 8);\n    //memcpy(&head->win_mtime, &hdr[0x1E0], 8);\n    //memcpy(&head->inband_obj_id, &hdr[0x1E8], 4);\n    //memcpy(&head->inband_is_shrink, &hdr[0x1EC], 4);\n\n    // NOTE: This isn't in Android 3.3 kernel but is in YAFFS2 git\n    //memcpy(&head->file_size_high, &hdr[0x1F0], 4);\n\n    free(hdr);\n\n    *header = head;\n    return 0;\n}\n\n/**\n* Read and parse the YAFFS2 tags in the NAND spare bytes.\n*\n* @param info is a YAFFS fs handle\n* @param spare YaffsSpare object to be populated\n* @param offset, offset to read from\n*\n* @returns 0 on success and 1 on error\n*/\nstatic uint8_t \n    yaffsfs_read_spare(YAFFSFS_INFO *yfs, YaffsSpare ** spare, TSK_OFF_T offset)\n{\n    unsigned char *spr;\n    ssize_t cnt;\n    YaffsSpare *sp;\n    TSK_FS_INFO *fs = &(yfs->fs_info);\n\n    uint32_t seq_number;\n    uint32_t object_id;\n    uint32_t chunk_id;\n\n    // Should have checked this by now, but just in case\n    if((yfs->spare_seq_offset + 4 > yfs->spare_size) ||\n        (yfs->spare_obj_id_offset + 4 > yfs->spare_size) ||\n        (yfs->spare_chunk_id_offset + 4 > yfs->spare_size)){\n            return 1;\n    }\n\n    if ((spr = (unsigned char*) tsk_malloc(yfs->spare_size)) == NULL) {\n        return 1;\n    }\n\n    if (yfs->spare_size < 46) { // Why is this 46?\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_ARG);\n        tsk_error_set_errstr(\"yaffsfs_read_spare: spare size is too small\");\n        free(spr);\n        return 1;\n    }\n\n    cnt = tsk_img_read(fs->img_info, offset, (char*) spr, yfs->spare_size);\n    if ((cnt < 0) || ((unsigned int)cnt < yfs->spare_size)) {\n        // couldn't read sufficient bytes...\n        if (spare) {\n            free(spr);\n            *spare = NULL;\n        }\n        return 1;\n    }\n\n    if ((sp = (YaffsSpare*) tsk_malloc(sizeof(YaffsSpare))) == NULL) {\n        return 1;\n    }\n\n    memset(sp, 0, sizeof(YaffsSpare));\n\n    /*\n    * Complete read of the YAFFS2 spare\n    */\n\n\n    // The format of the spare area should have been determined earlier\n    memcpy(&seq_number, &spr[yfs->spare_seq_offset], 4);\n    memcpy(&object_id, &spr[yfs->spare_obj_id_offset], 4);\n    memcpy(&chunk_id, &spr[yfs->spare_chunk_id_offset], 4);\n\n    if ((YAFFS_SPARE_FLAGS_IS_HEADER & chunk_id) != 0) {\n\n        sp->seq_number = seq_number;\n        sp->object_id = object_id & ~YAFFS_SPARE_OBJECT_TYPE_MASK;\n        sp->chunk_id = 0;\n\n        sp->has_extra_fields = 1;\n        sp->extra_parent_id = chunk_id & YAFFS_SPARE_PARENT_ID_MASK;\n        sp->extra_object_type =\n            (object_id & YAFFS_SPARE_OBJECT_TYPE_MASK)\n            >> YAFFS_SPARE_OBJECT_TYPE_SHIFT;\n    }\n    else {\n        sp->seq_number = seq_number;\n        sp->object_id = object_id;\n        sp->chunk_id = chunk_id;\n\n        sp->has_extra_fields = 0;\n    }\n\n    free(spr);\n    *spare = sp;\n\n    return 0;\n}\n\nstatic uint8_t \n    yaffsfs_is_spare_valid(YAFFSFS_INFO * /*yfs*/, YaffsSpare *spare)\n{\n    if (spare == NULL) {\n        return 1;\n    }\n\n    if ((spare->object_id > YAFFS_MAX_OBJECT_ID) ||\n        (spare->seq_number < YAFFS_LOWEST_SEQUENCE_NUMBER) ||\n        (spare->seq_number > YAFFS_HIGHEST_SEQUENCE_NUMBER)) {\n            return 1;\n    }\n\n    return 0;\n}\n\nstatic uint8_t \n    yaffsfs_read_chunk(YAFFSFS_INFO *yfs,\n    YaffsHeader **header, YaffsSpare **spare, TSK_OFF_T offset)\n{\n    TSK_OFF_T header_offset = offset;\n    TSK_OFF_T spare_offset = offset + yfs->page_size; \n\n    if (header == NULL || spare == NULL) {\n        return 1;\n    }\n\n    if (yaffsfs_read_header(yfs, header, header_offset) != 0) {\n        return 1;\n    }\n\n    if (yaffsfs_read_spare(yfs, spare, spare_offset) != 0) {\n        free(*header);\n        *header = NULL;\n        return 1;\n    }\n\n    return 0;\n}\n\n/**\n * Cycle through the entire image and populate the cache with objects as they are found.\n */\nstatic uint8_t \n    yaffsfs_parse_image_load_cache(YAFFSFS_INFO * yfs)\n{\n    uint8_t status = TSK_OK;\n    uint32_t nentries = 0;\n    YaffsSpare *spare = NULL;\n\n    uint8_t tempBuf[8];\n    uint32_t parentID;\n\n    if (yfs->cache_objects)\n        return 0;\n\n    for(TSK_OFF_T offset = 0;offset < yfs->fs_info.img_info->size;offset += yfs->page_size + yfs->spare_size){\n        status = yaffsfs_read_spare( yfs, &spare, offset + yfs->page_size);\n        if (status != TSK_OK) {\n            break;\n        }\n\n        if (yaffsfs_is_spare_valid(yfs, spare) == TSK_OK) {\n\n\n            if((spare->has_extra_fields) || (spare->chunk_id != 0)){\n                yaffscache_chunk_add(yfs,\n                    offset, \n                    spare->seq_number, \n                    spare->object_id, \n                    spare->chunk_id, \n                    spare->extra_parent_id);\n            }\n            else{\n                // If we have a header block and didn't extract it already from the spare, get the parent ID from\n                // the non-spare data\n                if(8 == tsk_img_read(yfs->fs_info.img_info, offset, (char*) tempBuf, 8)){\n                    memcpy(&parentID, &tempBuf[4], 4);\n\n                    yaffscache_chunk_add(yfs,\n                        offset, \n                        spare->seq_number, \n                        spare->object_id, \n                        spare->chunk_id, \n                        parentID);\n                }\n                else{\n                    // Really shouldn't happen\n                    fprintf(stderr, \"Error reading header to get parent id at offset %\" PRIxOFF \"\\n\", offset);\n                    yaffscache_chunk_add(yfs,\n                        offset, \n                        spare->seq_number, \n                        spare->object_id, \n                        spare->chunk_id, \n                        0);\n                }\n            }\n        }\n\n        free(spare);\n        spare = NULL;\n\n        ++nentries;\n    }\n\n    if (tsk_verbose)\n        fprintf(stderr, \"yaffsfs_parse_image_load_cache: read %d entries\\n\", nentries);\n\n    if (tsk_verbose)\n        fprintf(stderr, \"yaffsfs_parse_image_load_cache: started processing chunks for version cache...\\n\");\n    fflush(stderr);\n\n    // At this point, we have a list of chunks sorted by obj id, seq number, and offset\n    // This makes the list of objects in cache_objects, which link to different versions\n    yaffscache_versions_compute(yfs);\n\n    if (tsk_verbose)\n        fprintf(stderr, \"yaffsfs_parse_image_load_cache: done version cache!\\n\");\n    fflush(stderr);\n\n\n    // Having multiple inodes point to the same object seems to cause trouble in TSK, especially in orphan file detection,\n    //  so set the version number of the final one to zero.\n    // While we're at it, find the highest obj_id and the highest version (before resetting to zero)\n    YaffsCacheObject * currObj = yfs->cache_objects;\n    YaffsCacheVersion * currVer;\n    while(currObj != NULL){\n        if(currObj->yco_obj_id > yfs->max_obj_id){\n            yfs->max_obj_id = currObj->yco_obj_id;\n        }\n\n        currVer = currObj->yco_latest;\n        if(currVer->ycv_version > yfs->max_version){\n            yfs->max_version = currVer->ycv_version;\n        }\n\n        currVer->ycv_version = 0;\n        currObj = currObj->yco_next;\n    }\n\n    // Use the max object id and version number to construct an upper bound on the inode\n    TSK_INUM_T max_inum = 0;\n    if (TSK_OK != yaffscache_obj_id_and_version_to_inode(yfs->max_obj_id, yfs->max_version, &max_inum)) {\n        return TSK_ERR;\n    }\n    yfs->fs_info.last_inum = max_inum + 1; // One more for the orphan dir\n\n    // Make sure the orphan dir is greater than the root dir\n    if (yfs->fs_info.last_inum <= yfs->fs_info.root_inum) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS);\n        tsk_error_set_errstr(\n            \"yaffsfs_parse_image_load_cache: Maximum inum %\" PRIuINUM \" is not greater than the root inum\", yfs->fs_info.last_inum);\n        return TSK_ERR;\n    }\n\n    return TSK_OK;\n}\n\n// A version is allocated if:\n//   1. This version is pointed to by yco_latest\n//   2. This version didn't have a delete/unlinked header after the most recent copy of the normal header\nstatic uint8_t yaffs_is_version_allocated(YAFFSFS_INFO * yfs, TSK_INUM_T inode){\n    YaffsCacheObject * obj;\n    YaffsCacheVersion * version;\n    YaffsCacheChunk * curr;\n\n    TSK_RETVAL_ENUM result = yaffscache_version_find_by_inode(yfs, inode, &version, &obj);\n    if (result != TSK_OK) {\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"yaffs_is_version_allocated: yaffscache_version_find_by_inode failed! (inode: %d)\\n\", inode);\n        return 0;\n    }\n\n    if(obj->yco_latest == version){\n        curr = obj->yco_latest->ycv_header_chunk;\n        while(curr != NULL){\n            // We're looking for a newer unlinked or deleted header. If one exists, then this object should be considered unallocated\n            if((curr->ycc_parent_id == YAFFS_OBJECT_UNLINKED) || (curr->ycc_parent_id == YAFFS_OBJECT_DELETED)){\n                return 0;\n            }\n            curr = curr ->ycc_next;\n        }\n        return 1;\n    }\n    else{\n        return 0;\n    }\n\n}\n\n/*\n* TSK integration\n*\n*\n*/\n\nstatic uint8_t\n    yaffs_make_directory(YAFFSFS_INFO *yaffsfs, TSK_FS_FILE *a_fs_file, \n    TSK_INUM_T inode, const char *name)\n{\n    TSK_FS_FILE *fs_file = a_fs_file;\n\n\n    fs_file->meta->type = TSK_FS_META_TYPE_DIR;\n    fs_file->meta->mode = (TSK_FS_META_MODE_ENUM)0;\n    fs_file->meta->nlink = 1;\n\n    if((inode == YAFFS_OBJECT_UNLINKED) || (inode == YAFFS_OBJECT_DELETED) ||\n        (inode == yaffsfs->fs_info.last_inum)){\n            fs_file->meta->flags =\n                (TSK_FS_META_FLAG_ENUM)(TSK_FS_META_FLAG_USED | TSK_FS_META_FLAG_ALLOC);\n    }\n    else{\n        if(yaffs_is_version_allocated(yaffsfs, inode)){\n            fs_file->meta->flags =\n                (TSK_FS_META_FLAG_ENUM)(TSK_FS_META_FLAG_USED | TSK_FS_META_FLAG_ALLOC);\n        }\n        else{\n            fs_file->meta->flags =\n                (TSK_FS_META_FLAG_ENUM)(TSK_FS_META_FLAG_USED | TSK_FS_META_FLAG_UNALLOC);\n        }\n    }\n    fs_file->meta->uid = fs_file->meta->gid = 0;\n    fs_file->meta->mtime = fs_file->meta->atime = fs_file->meta->ctime =\n        fs_file->meta->crtime = 0;\n    fs_file->meta->mtime_nano = fs_file->meta->atime_nano =\n        fs_file->meta->ctime_nano = fs_file->meta->crtime_nano = 0;\n\n    if (fs_file->meta->name2 == NULL) {\n        if ((fs_file->meta->name2 = (TSK_FS_META_NAME_LIST *)\n            tsk_malloc(sizeof(TSK_FS_META_NAME_LIST))) == NULL) {\n            return 1;\n        }\n        fs_file->meta->name2->next = NULL;\n    }\n\n    if (fs_file->meta->attr != NULL) {\n        tsk_fs_attrlist_markunused(fs_file->meta->attr);\n    }\n    else {\n        fs_file->meta->attr = tsk_fs_attrlist_alloc();\n    }\n\n    strncpy(fs_file->meta->name2->name, name,\n        TSK_FS_META_NAME_LIST_NSIZE);\n\n    fs_file->meta->size = 0;\n    fs_file->meta->attr_state = TSK_FS_META_ATTR_EMPTY;\n    fs_file->meta->addr = inode;\n    return 0;\n}\n\nstatic uint8_t\n    yaffs_make_regularfile( YAFFSFS_INFO * yaffsfs, TSK_FS_FILE * a_fs_file, \n    TSK_INUM_T inode, const char * name )\n{\n    TSK_FS_FILE *fs_file = a_fs_file;\n\n    fs_file->meta->type = TSK_FS_META_TYPE_REG;\n    fs_file->meta->mode = (TSK_FS_META_MODE_ENUM)0;\n    fs_file->meta->nlink =1;\n\n    if(yaffs_is_version_allocated(yaffsfs, inode)){\n        fs_file->meta->flags =\n            (TSK_FS_META_FLAG_ENUM)(TSK_FS_META_FLAG_USED | TSK_FS_META_FLAG_ALLOC);\n    }\n    else{\n        fs_file->meta->flags =\n            (TSK_FS_META_FLAG_ENUM)(TSK_FS_META_FLAG_USED | TSK_FS_META_FLAG_UNALLOC);\n    }\n\n    fs_file->meta->uid = fs_file->meta->gid = 0;\n    fs_file->meta->mtime = fs_file->meta->atime = fs_file->meta->ctime =\n        fs_file->meta->crtime = 0;\n    fs_file->meta->mtime_nano = fs_file->meta->atime_nano =\n        fs_file->meta->ctime_nano = fs_file->meta->crtime_nano = 0;\n\n    if (fs_file->meta->name2 == NULL) {\n        if ((fs_file->meta->name2 = (TSK_FS_META_NAME_LIST *)\n            tsk_malloc(sizeof(TSK_FS_META_NAME_LIST))) == NULL)\n            return 1;\n        fs_file->meta->name2->next = NULL;\n    }\n\n    if (fs_file->meta->attr != NULL) {\n        tsk_fs_attrlist_markunused(fs_file->meta->attr);\n    }\n    else {\n        fs_file->meta->attr = tsk_fs_attrlist_alloc();\n    }\n\n    fs_file->meta->addr = inode;\n    strncpy(fs_file->meta->name2->name, name,\n        TSK_FS_META_NAME_LIST_NSIZE);\n\n    fs_file->meta->size = 0;\n    fs_file->meta->attr_state = TSK_FS_META_ATTR_EMPTY;\n\n    return 0;\n}\n\n/**\n* \\internal \n* Create YAFFS2 Deleted Object\n*\n* @ param yaffs file system\n* fs_file to copy file information to\n* return 1 on error, 0 on success\n*/\nstatic uint8_t\n    yaffs_make_deleted( YAFFSFS_INFO * yaffsfs, TSK_FS_FILE * a_fs_file )\n{\n    TSK_FS_FILE *fs_file = a_fs_file;\n\n    if (tsk_verbose)\n        tsk_fprintf(stderr, \"yaffs_make_deleted: Making virtual deleted node\\n\");\n\n    if (yaffs_make_directory(yaffsfs, fs_file, YAFFS_OBJECT_DELETED, YAFFS_OBJECT_DELETED_NAME))\n        return 1;\n\n    return 0;\n}\n\n/**\n* \\internal \n* Create YAFFS2 Unlinked object\n*\n* @ param yaffs file system\n* fs_file to copy file information to\n* return 1 on error, 0 on success\n*/\nstatic uint8_t\n    yaffs_make_unlinked( YAFFSFS_INFO * yaffsfs, TSK_FS_FILE * a_fs_file )\n{\n    TSK_FS_FILE * fs_file = a_fs_file;\n\n    if (tsk_verbose)\n        tsk_fprintf(stderr, \"yaffs_make_unlinked: Making virtual unlinked node\\n\");\n\n    if (yaffs_make_directory(yaffsfs, fs_file, YAFFS_OBJECT_UNLINKED, YAFFS_OBJECT_UNLINKED_NAME))\n        return 1;\n\n    return 0;\n}\n\n/**\n* \\internal \n* Create YAFFS2 orphan object\n*\n* @ param yaffs file system\n* fs_file to copy file information to\n* return 1 on error, 0 on success\n*/\nstatic uint8_t\n    yaffs_make_orphan_dir( YAFFSFS_INFO * yaffsfs, TSK_FS_FILE * a_fs_file )\n{\n    TSK_FS_FILE * fs_file = a_fs_file;\n    TSK_FS_NAME *fs_name = tsk_fs_name_alloc(256, 0);\n    if (fs_name == NULL)\n        return TSK_ERR;\n\n    if (tsk_verbose)\n        tsk_fprintf(stderr, \"yaffs_make_orphan_dir: Making orphan dir node\\n\");\n\n    if (tsk_fs_dir_make_orphan_dir_name(&(yaffsfs->fs_info), fs_name)) {\n        tsk_fs_name_free(fs_name);\n        return TSK_ERR;\n    }\n\n    if (yaffs_make_directory(yaffsfs, fs_file, yaffsfs->fs_info.last_inum, (char *)fs_name)){\n        tsk_fs_name_free(fs_name);\n        return 1;\n    }\n    tsk_fs_name_free(fs_name);\n    return 0;\n}\n\n/* yaffsfs_inode_lookup - lookup inode, external interface\n*\n* Returns 1 on error and 0 on success\n*\n*/\n\nstatic uint8_t\n    yaffs_inode_lookup(TSK_FS_INFO *a_fs, TSK_FS_FILE * a_fs_file,\n    TSK_INUM_T inum)\n{\n    YAFFSFS_INFO *yfs = (YAFFSFS_INFO *)a_fs;\n    YaffsCacheObject *obj;\n    YaffsCacheVersion *version;\n    YaffsHeader *header = NULL;\n    YaffsSpare *spare = NULL;\n    TSK_RETVAL_ENUM result;\n    uint8_t type;\n    const char *real_name;\n\n    if (a_fs_file == NULL) {\n        tsk_error_set_errno(TSK_ERR_FS_ARG);\n        tsk_error_set_errstr(\"yaffsfs_inode_lookup: fs_file is NULL\");\n        return 1;\n    }\n\n    if (a_fs_file->meta == NULL) {\n        if ((a_fs_file->meta =\n            tsk_fs_meta_alloc(YAFFS_FILE_CONTENT_LEN)) == NULL)\n            return 1;\n    }\n    else {\n        tsk_fs_meta_reset(a_fs_file->meta);\n    }\n\n    if (tsk_verbose)\n        tsk_fprintf(stderr, \"yaffs_inode_lookup: looking up %\" PRIuINUM \"\\n\",inum);\n\n    switch(inum) {\n    case YAFFS_OBJECT_UNLINKED:\n        yaffs_make_unlinked(yfs, a_fs_file);\n        return 0;\n\n    case YAFFS_OBJECT_DELETED:\n        yaffs_make_deleted(yfs, a_fs_file);\n        return 0;\n    }\n\n    if(inum == yfs->fs_info.last_inum){\n        yaffs_make_orphan_dir(yfs, a_fs_file);\n        return 0;\n    }\n\n    result = yaffscache_version_find_by_inode(yfs, inum, &version, &obj);\n    if (result != TSK_OK) {\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"yaffs_inode_lookup: yaffscache_version_find_by_inode failed! (inode = %d)\\n\", inum);\n        return 1;\n    }\n\n    if(version->ycv_header_chunk == NULL){\n        return 1;\n    }\n\n    if (yaffsfs_read_chunk(yfs, &header, &spare, version->ycv_header_chunk->ycc_offset) != TSK_OK) {\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"yaffs_inode_lookup: yaffsfs_read_chunk failed!\\n\");\n        return 1;\n    }\n\n    type = header->obj_type;\n\n    switch(inum) {\n    case YAFFS_OBJECT_LOSTNFOUND:\n        real_name = YAFFS_OBJECT_LOSTNFOUND_NAME;\n        break;\n    case YAFFS_OBJECT_UNLINKED:\n        real_name = YAFFS_OBJECT_UNLINKED_NAME;\n        break;\n    case YAFFS_OBJECT_DELETED:\n        real_name = YAFFS_OBJECT_DELETED_NAME;\n        break;\n    default:\n        real_name = header->name;\n        break;\n    }\n\n    switch(type) {\n    case YAFFS_TYPE_FILE:\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"yaffs_inode_lookup: is a file\\n\");\n        yaffs_make_regularfile(yfs, a_fs_file, inum, real_name);\n        break;\n\n    case YAFFS_TYPE_DIRECTORY:\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"yaffs_inode_lookup: is a directory\\n\");\n        yaffs_make_directory(yfs, a_fs_file, inum, real_name);\n        break;\n\n    case YAFFS_TYPE_SOFTLINK:\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"yaffs_inode_lookup: is a symbolic link\\n\");\n        yaffs_make_regularfile(yfs, a_fs_file, inum, real_name);\n        a_fs_file->meta->type = TSK_FS_META_TYPE_LNK;\n        break;\n\n    case YAFFS_TYPE_HARDLINK:\n    case YAFFS_TYPE_UNKNOWN:\n    default:\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"yaffs_inode_lookup: is *** UNHANDLED *** (type %d, header at 0x%x)\\n\", type, version->ycv_header_chunk->ycc_offset);\n        // We can still set a few things\n        a_fs_file->meta->type = TSK_FS_META_TYPE_UNDEF;\n        a_fs_file->meta->addr = inum;\n        if(yaffs_is_version_allocated(yfs, inum)){\n            a_fs_file->meta->flags =\n                (TSK_FS_META_FLAG_ENUM)(TSK_FS_META_FLAG_USED | TSK_FS_META_FLAG_ALLOC);\n        }\n        else{\n            a_fs_file->meta->flags =\n                (TSK_FS_META_FLAG_ENUM)(TSK_FS_META_FLAG_USED | TSK_FS_META_FLAG_UNALLOC);\n        }\n        if (a_fs_file->meta->name2 == NULL) {\n            if ((a_fs_file->meta->name2 = (TSK_FS_META_NAME_LIST *)\n                tsk_malloc(sizeof(TSK_FS_META_NAME_LIST))) == NULL){\n                    return 1;\n            }\n            a_fs_file->meta->name2->next = NULL;\n        }\n        strncpy(a_fs_file->meta->name2->name, real_name,\n            TSK_FS_META_NAME_LIST_NSIZE);\n        break;\n    }\n\n    /* Who owns this? I'm following the way FATFS does it by freeing + NULLing \n    * this and mallocing if used. \n    */\n    free(a_fs_file->meta->link);\n    a_fs_file->meta->link = NULL;\n\n    if (type != YAFFS_TYPE_HARDLINK) {\n        a_fs_file->meta->mode = (TSK_FS_META_MODE_ENUM)(header->file_mode & TWELVE_BITS_MASK); // chop at 12 bits;\n        a_fs_file->meta->uid = header->user_id;\n        a_fs_file->meta->gid = header->group_id;\n        a_fs_file->meta->mtime = header->mtime;\n        a_fs_file->meta->atime = header->atime;\n        a_fs_file->meta->ctime = header->ctime;\n    }\n\n    if (type == YAFFS_TYPE_FILE) {\n        a_fs_file->meta->size = header->file_size;\n        // NOTE: This isn't in Android 3.3 kernel but is in YAFFS2 git\n        //a_fs_file->meta->size |= ((TSK_OFF_T) header->file_size_high) << 32;\n    }\n\n    if (type == YAFFS_TYPE_HARDLINK) {\n        // TODO: Store equivalent_id somewhere? */\n    }\n\n    if (type == YAFFS_TYPE_SOFTLINK) {\n        a_fs_file->meta->link = (char*)tsk_malloc(YAFFS_HEADER_ALIAS_LENGTH);\n        if (a_fs_file->meta->link == NULL) {\n            free(header);\n            free(spare);\n            return 1;\n        }\n\n        memcpy(a_fs_file->meta->link, header->alias, YAFFS_HEADER_ALIAS_LENGTH);\n    }\n\n    free(header);\n    free(spare);\n    return 0;\n}\n\n\n\n/* yaffsfs_inode_walk - inode iterator\n*\n* flags used: TSK_FS_META_FLAG_USED, TSK_FS_META_FLAG_UNUSED,\n*  TSK_FS_META_FLAG_ALLOC, TSK_FS_META_FLAG_UNALLOC, TSK_FS_META_FLAG_ORPHAN\n*\n*  Return 1 on error and 0 on success\n*/\n\nstatic uint8_t\n    yaffsfs_inode_walk(TSK_FS_INFO *fs, TSK_INUM_T start_inum,\n    TSK_INUM_T end_inum, TSK_FS_META_FLAG_ENUM flags,\n    TSK_FS_META_WALK_CB a_action, void *a_ptr)\n{\n    YAFFSFS_INFO *yfs = (YAFFSFS_INFO *)fs;\n    TSK_FS_FILE *fs_file;\n    TSK_RETVAL_ENUM result;\n\n    uint32_t start_obj_id;\n    uint32_t start_ver_number;\n    uint32_t end_obj_id;\n    uint32_t end_ver_number;\n\n    uint32_t obj_id;\n\n    YaffsCacheObject *curr_obj;\n    YaffsCacheVersion *curr_version;\n\n    result = yaffscache_inode_to_obj_id_and_version(start_inum, &start_obj_id, &start_ver_number);\n\n    result = yaffscache_inode_to_obj_id_and_version(end_inum, &end_obj_id, &end_ver_number);\n\n    if (end_obj_id < start_obj_id) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_WALK_RNG);\n        tsk_error_set_errstr(\"yaffsfs_inode_walk: end object id must be >= start object id: \"\n            \"%\" PRIx32 \" must be >= %\" PRIx32 \"\",\n            end_obj_id, start_obj_id);\n        return 1;\n    }\n\n    /* The ORPHAN flag is unsupported for YAFFS2 */\n    if (flags & TSK_FS_META_FLAG_ORPHAN) {\n        if (tsk_verbose){\n            tsk_fprintf(stderr, \"yaffsfs_inode_walk: ORPHAN flag unsupported by YAFFS2\");\n        }\n    }\n\n    if (((flags & TSK_FS_META_FLAG_ALLOC) == 0) &&\n        ((flags & TSK_FS_META_FLAG_UNALLOC) == 0)) {\n            flags = (TSK_FS_META_FLAG_ENUM)(flags | TSK_FS_META_FLAG_ALLOC | TSK_FS_META_FLAG_UNALLOC);\n    }\n\n    /* If neither of the USED or UNUSED flags are set, then set them\n    * both\n    */\n    if (((flags & TSK_FS_META_FLAG_USED) == 0) &&\n        ((flags & TSK_FS_META_FLAG_UNUSED) == 0)) {\n            flags = (TSK_FS_META_FLAG_ENUM)(flags | TSK_FS_META_FLAG_USED | TSK_FS_META_FLAG_UNUSED);\n    }\n\n    if ((fs_file = tsk_fs_file_alloc(fs)) == NULL)\n        return 1;\n    if ((fs_file->meta =\n        tsk_fs_meta_alloc(YAFFS_FILE_CONTENT_LEN)) == NULL)\n        return 1;\n\n\n    for (obj_id = start_obj_id; obj_id <= end_obj_id; obj_id++) {\n        int retval;\n\n        result = yaffscache_version_find_by_inode(yfs, obj_id, &curr_version, &curr_obj);\n        if (result == TSK_OK) {\n\n            TSK_INUM_T curr_inode;\n            YaffsCacheVersion *version;\n\n            // ALLOC, UNALLOC, or both are set at this point \n            if (flags & TSK_FS_META_FLAG_ALLOC) {\n                // Allocated only - just look at current version\n                if (yaffscache_obj_id_and_version_to_inode(obj_id, curr_obj->yco_latest->ycv_version, &curr_inode) != TSK_OK) {\n                    tsk_fs_file_close(fs_file);\n                    return 1;\n                }\n\n                // It's possible for the current version to be unallocated if the last header was a deleted or unlinked header\n                if(yaffs_is_version_allocated(yfs, curr_inode)){\n                    if (yaffs_inode_lookup(fs, fs_file, curr_inode) != TSK_OK) {\n                        tsk_fs_file_close(fs_file);\n                        return 1;\n                    }\n\n                    retval = a_action(fs_file, a_ptr);\n                    if (retval == TSK_WALK_STOP) {\n                        tsk_fs_file_close(fs_file);\n                        return 0;\n                    }\n                    else if (retval == TSK_WALK_ERROR) {\n                        tsk_fs_file_close(fs_file);\n                        return 1;\n                    }\n                }\n            }\n            if (flags & TSK_FS_META_FLAG_UNALLOC){\n                for (version = curr_obj->yco_latest; version != NULL; version = version->ycv_prior) {\n                    if (yaffscache_obj_id_and_version_to_inode(obj_id, version->ycv_version, &curr_inode) != TSK_OK) {\n                        tsk_fs_file_close(fs_file);\n                        return 1;\n                    }\n\n                    if(! yaffs_is_version_allocated(yfs, curr_inode)){\n                        if (yaffs_inode_lookup(fs, fs_file, curr_inode) != TSK_OK) {\n                            tsk_fs_file_close(fs_file);\n                            return 1;\n                        }\n\n                        retval = a_action(fs_file, a_ptr);\n                        if (retval == TSK_WALK_STOP) {\n                            tsk_fs_file_close(fs_file);\n                            return 0;\n                        }\n                        else if (retval == TSK_WALK_ERROR) {\n                            tsk_fs_file_close(fs_file);\n                            return 1;\n                        }\n                    }\n                }\n            }\n\n            curr_obj = curr_obj->yco_next;\n        }\n    }\n\n    /*\n    * Cleanup.\n    */\n    tsk_fs_file_close(fs_file);\n    return 0;\n}\n\nstatic TSK_FS_BLOCK_FLAG_ENUM\n    yaffsfs_block_getflags(TSK_FS_INFO *fs, TSK_DADDR_T a_addr)\n{\n    YAFFSFS_INFO *yfs = (YAFFSFS_INFO *)fs;\n    TSK_FS_BLOCK_FLAG_ENUM flags = TSK_FS_BLOCK_FLAG_UNUSED;\n\n    TSK_OFF_T offset = (a_addr * (fs->block_pre_size + fs->block_size + fs->block_post_size)) + yfs->page_size;\n    YaffsSpare *spare = NULL;\n    YaffsHeader *header = NULL;\n    if (yaffsfs_read_spare(yfs, &spare, offset) != TSK_OK) {\n        /* NOTE: Uh, how do we signal error? */\n        return flags;\n    }\n\n    if (yaffsfs_is_spare_valid(yfs, spare) == TSK_OK) {\n        /* XXX: Do we count blocks of older versions unallocated?\n        *      If so, we need a smarter way to do this :/\n        *\n        *      Walk the object from this block and see if this\n        *      block is used in the latest version. Could pre-\n        *      calculate this at cache time as well.\n        */\n\n\n        if (spare->chunk_id == 0) {\n            flags = (TSK_FS_BLOCK_FLAG_ENUM)(flags | TSK_FS_BLOCK_FLAG_META);\n        } else {\n            flags = (TSK_FS_BLOCK_FLAG_ENUM)(flags | TSK_FS_BLOCK_FLAG_CONT);\n        }\n\n        // Have obj id and offset\n        // 1. Is the current version of this object allocated?\n        // 2. If this is a header, is it the header of the current version?\n        // 3. Is the chunk id too big given the current header?\n        // 4. Is there a more recent version of this chunk id?\n        YaffsCacheObject * obj = NULL;\n        yaffscache_object_find(yfs, spare->object_id, &obj);\n\n        // The result really shouldn't be NULL since we loaded every chunk\n        if(obj != NULL){\n            if(! yaffs_is_version_allocated(yfs, spare->object_id)){\n                // If the current version isn't allocated, then no chunks in it are\n                flags = (TSK_FS_BLOCK_FLAG_ENUM)(flags | TSK_FS_BLOCK_FLAG_UNALLOC);\n            }\n            else if (obj->yco_latest == NULL || obj->yco_latest->ycv_header_chunk == NULL) { \n                flags = (TSK_FS_BLOCK_FLAG_ENUM)(flags | TSK_FS_BLOCK_FLAG_UNALLOC); \n            }\n            else if(spare->chunk_id == 0){\n                if(obj->yco_latest->ycv_header_chunk->ycc_offset == offset - yfs->page_size){\n                    // Have header chunk and it's the most recent header chunk\n                    flags = (TSK_FS_BLOCK_FLAG_ENUM)(flags | TSK_FS_BLOCK_FLAG_ALLOC);\n                }\n                else{\n                    // Have header chunk but isn't the most recent\n                    flags = (TSK_FS_BLOCK_FLAG_ENUM)(flags | TSK_FS_BLOCK_FLAG_UNALLOC);\n                }\n            }\n            else{\n                // Read in the full header\n                yaffsfs_read_header(yfs, &header, obj->yco_latest->ycv_header_chunk->ycc_offset);\n\n                // chunk_id is 1-based, so for example chunk id 2 would be too big for a file\n                //   500 bytes long\n                if(header->file_size <= ((spare->chunk_id - 1) * (fs->block_size))){\n                    flags = (TSK_FS_BLOCK_FLAG_ENUM)(flags | TSK_FS_BLOCK_FLAG_UNALLOC);\n                }\n                else{\n                    // Since at this point we know there should be a chunk with this chunk id in the file, if\n                    // this is the most recent version of the chunk assume it's part of the current version of the object.\n                    YaffsCacheChunk * curr = obj->yco_latest->ycv_last_chunk;\n                    while(curr != NULL){ // curr should really never make it to the beginning of the list\n\n                        // Did we find our chunk?\n                        if(curr->ycc_offset == offset - yfs->page_size){\n                            flags = (TSK_FS_BLOCK_FLAG_ENUM)(flags | TSK_FS_BLOCK_FLAG_ALLOC);\n                            break;\n                        }\n\n                        // Did we find a different chunk with our chunk id?\n                        if(curr->ycc_chunk_id == spare->chunk_id){\n                            flags = (TSK_FS_BLOCK_FLAG_ENUM)(flags | TSK_FS_BLOCK_FLAG_UNALLOC);\n                            break;\n                        }\n                        curr = curr->ycc_prev;\n                    }\n                }\n            }\n        }\n\n    } else {\n        flags = (TSK_FS_BLOCK_FLAG_ENUM)(flags | TSK_FS_BLOCK_FLAG_UNUSED | TSK_FS_BLOCK_FLAG_UNALLOC);\n    }\n\n    free(spare);\n    free(header);\n    return flags;\n}\n\n\n/* yaffsfs_block_walk - block iterator\n*\n* flags: TSK_FS_BLOCK_FLAG_ALLOC, TSK_FS_BLOCK_FLAG_UNALLOC, TSK_FS_BLOCK_FLAG_CONT,\n*  TSK_FS_BLOCK_FLAG_META\n*\n*  Return 1 on error and 0 on success\n*/\nstatic uint8_t\n    yaffsfs_block_walk(TSK_FS_INFO *a_fs, TSK_DADDR_T a_start_blk,\n    TSK_DADDR_T a_end_blk, TSK_FS_BLOCK_WALK_FLAG_ENUM a_flags,\n    TSK_FS_BLOCK_WALK_CB a_action, void *a_ptr)\n{\n    TSK_FS_BLOCK *fs_block;\n    TSK_DADDR_T addr;\n\n    // clean up any error messages that are lying around\n    tsk_error_reset();\n\n    /*\n    * Sanity checks.\n    */\n    if (a_start_blk < a_fs->first_block || a_start_blk > a_fs->last_block) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_WALK_RNG);\n        tsk_error_set_errstr(\"yaffsfs_block_walk: start block: %\" PRIuDADDR,\n            a_start_blk);\n        return 1;\n    }\n    if (a_end_blk < a_fs->first_block || a_end_blk > a_fs->last_block\n        || a_end_blk < a_start_blk) {\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_FS_WALK_RNG);\n            tsk_error_set_errstr(\"yaffsfs_block_walk: end block: %\" PRIuDADDR ,\n                a_end_blk);\n            return 1;\n    }\n\n    /* Sanity check on a_flags -- make sure at least one ALLOC is set */\n    if (((a_flags & TSK_FS_BLOCK_WALK_FLAG_ALLOC) == 0) &&\n        ((a_flags & TSK_FS_BLOCK_WALK_FLAG_UNALLOC) == 0)) {\n            a_flags = (TSK_FS_BLOCK_WALK_FLAG_ENUM)\n                (a_flags | TSK_FS_BLOCK_WALK_FLAG_ALLOC |\n                TSK_FS_BLOCK_WALK_FLAG_UNALLOC);\n    }\n    if (((a_flags & TSK_FS_BLOCK_WALK_FLAG_META) == 0) &&\n        ((a_flags & TSK_FS_BLOCK_WALK_FLAG_CONT) == 0)) {\n            a_flags = (TSK_FS_BLOCK_WALK_FLAG_ENUM)\n                (a_flags | TSK_FS_BLOCK_WALK_FLAG_CONT | TSK_FS_BLOCK_WALK_FLAG_META);\n    }\n\n\n    if ((fs_block = tsk_fs_block_alloc(a_fs)) == NULL) {\n        return 1;\n    }\n\n    for (addr = a_start_blk; addr <= a_end_blk; addr++) {\n        int retval;\n        int myflags;\n\n        myflags = yaffsfs_block_getflags(a_fs, addr);\n\n        // test if we should call the callback with this one\n        if ((myflags & TSK_FS_BLOCK_FLAG_META)\n            && (!(a_flags & TSK_FS_BLOCK_WALK_FLAG_META)))\n            continue;\n        else if ((myflags & TSK_FS_BLOCK_FLAG_CONT)\n            && (!(a_flags & TSK_FS_BLOCK_WALK_FLAG_CONT)))\n            continue;\n        else if ((myflags & TSK_FS_BLOCK_FLAG_ALLOC)\n            && (!(a_flags & TSK_FS_BLOCK_WALK_FLAG_ALLOC)))\n            continue;\n        else if ((myflags & TSK_FS_BLOCK_FLAG_UNALLOC)\n            && (!(a_flags & TSK_FS_BLOCK_WALK_FLAG_UNALLOC)))\n            continue;\n\n        if (tsk_fs_block_get(a_fs, fs_block, addr) == NULL) {\n            tsk_error_set_errstr2(\"yaffsfs_block_walk: block %\" PRIuDADDR,\n                addr);\n            tsk_fs_block_free(fs_block);\n            return 1;\n        }\n\n        retval = a_action(fs_block, a_ptr);\n        if (retval == TSK_WALK_STOP) {\n            break;\n        }\n        else if (retval == TSK_WALK_ERROR) {\n            tsk_fs_block_free(fs_block);\n            return 1;\n        }\n    }\n\n    /*\n    * Cleanup.\n    */\n    tsk_fs_block_free(fs_block);\n    return 0;\n}\n\nstatic uint8_t\n    yaffsfs_fscheck(TSK_FS_INFO * /*fs*/, FILE * /*hFile*/)\n{\n    tsk_error_reset();\n    tsk_error_set_errno(TSK_ERR_FS_UNSUPFUNC);\n    tsk_error_set_errstr(\"fscheck not implemented yet for YAFFS\");\n    return 1;\n}\n\n\n/**\n* Print details about the file system to a file handle.\n*\n* @param fs File system to print details on\n* @param hFile File handle to print text to\n*\n* @returns 1 on error and 0 on success\n*/\nstatic uint8_t\n    yaffsfs_fsstat(TSK_FS_INFO * fs, FILE * hFile)\n{\n    YAFFSFS_INFO *yfs = (YAFFSFS_INFO *) fs;\n    unsigned int obj_count, version_count;\n    uint32_t obj_first, obj_last, version_first, version_last;\n\n    // clean up any error messages that are lying around\n    tsk_error_reset();\n\n    tsk_fprintf(hFile, \"FILE SYSTEM INFORMATION\\n\");\n    tsk_fprintf(hFile, \"--------------------------------------------\\n\");\n\n    tsk_fprintf(hFile, \"File System Type: YAFFS2\\n\");\n    tsk_fprintf(hFile, \"Page Size: %u\\n\", yfs->page_size);\n    tsk_fprintf(hFile, \"Spare Size: %u\\n\", yfs->spare_size);\n    tsk_fprintf(hFile, \"Spare Offsets: Sequence number: %d, Object ID: %d, Chunk ID: %d, nBytes: %d\\n\",\n        yfs->spare_seq_offset, yfs->spare_obj_id_offset, yfs->spare_chunk_id_offset, yfs->spare_nbytes_offset);\n\n    tsk_fprintf(hFile, \"\\nMETADATA INFORMATION\\n\");\n    tsk_fprintf(hFile, \"--------------------------------------------\\n\");\n\n\n    yaffscache_objects_stats(yfs, \n        &obj_count, &obj_first, &obj_last,\n        &version_count, &version_first, &version_last);\n\n    tsk_fprintf(hFile, \"Number of Allocated Objects: %u\\n\", obj_count);\n    tsk_fprintf(hFile, \"Object Id Range: %\" PRIu32 \" - %\" PRIu32 \"\\n\",\n        obj_first, obj_last);\n    tsk_fprintf(hFile, \"Number of Total Object Versions: %u\\n\", version_count);\n    tsk_fprintf(hFile, \"Object Version Range: %\" PRIu32 \" - %\" PRIu32 \"\\n\",\n        version_first, version_last);\n\n    return 0;\n}\n\n/************************* istat *******************************/\n\ntypedef struct {\n    FILE *hFile;\n    int idx;\n} YAFFSFS_PRINT_ADDR;\n\n/* Callback for istat to print the block addresses */\nstatic TSK_WALK_RET_ENUM\n    print_addr_act(YAFFSFS_INFO * /*fs_file*/, TSK_OFF_T /*a_off*/,\n    TSK_DADDR_T addr, char * /*buf*/, size_t /*size*/,\n    TSK_FS_BLOCK_FLAG_ENUM flags, void *a_ptr)\n{\n    YAFFSFS_PRINT_ADDR *print = (YAFFSFS_PRINT_ADDR *) a_ptr;\n\n    if (flags & TSK_FS_BLOCK_FLAG_CONT) {\n        tsk_fprintf(print->hFile, \"%\" PRIuDADDR \" \", addr);\n\n        if (++(print->idx) == 8) {\n            tsk_fprintf(print->hFile, \"\\n\");\n            print->idx = 0;\n        }\n    }\n\n    return TSK_WALK_CONT;\n}\n\n/**\n* Print details on a specific file to a file handle.\n*\n* @param fs File system file is located in\n* @param hFile File handle to print text to\n* @param inum Address of file in file system\n* @param numblock The number of blocks in file to force print (can go beyond file size)\n* @param sec_skew Clock skew in seconds to also print times in\n*\n* @returns 1 on error and 0 on success\n*/\nstatic uint8_t\n    yaffsfs_istat(TSK_FS_INFO *fs, TSK_FS_ISTAT_FLAG_ENUM flags, FILE * hFile, TSK_INUM_T inum,\n    TSK_DADDR_T numblock, int32_t sec_skew)\n{\n    TSK_FS_META *fs_meta;\n    TSK_FS_FILE *fs_file;\n    YAFFSFS_INFO *yfs = (YAFFSFS_INFO *)fs;\n    char ls[12];\n    YAFFSFS_PRINT_ADDR print;\n    char timeBuf[128];\n    YaffsCacheObject * obj = NULL;\n    YaffsCacheVersion * version = NULL;\n    YaffsHeader * header = NULL;\n\n    yaffscache_version_find_by_inode(yfs, inum, &version, &obj);\n\n    if ((fs_file = tsk_fs_file_open_meta(fs, NULL, inum)) == NULL) {\n        return 1;\n    }\n    fs_meta = fs_file->meta;\n\n    tsk_fprintf(hFile, \"inode: %\" PRIuINUM \"\\n\", inum);\n    tsk_fprintf(hFile, \"%sAllocated\\n\",\n        (fs_meta->flags & TSK_FS_META_FLAG_ALLOC) ? \"\" : \"Not \");\n\n    if (fs_meta->link)\n        tsk_fprintf(hFile, \"symbolic link to: %s\\n\", fs_meta->link);\n\n    tsk_fprintf(hFile, \"uid / gid: %\" PRIuUID \" / %\" PRIuGID \"\\n\",\n        fs_meta->uid, fs_meta->gid);\n\n    tsk_fs_meta_make_ls(fs_meta, ls, sizeof(ls));\n    tsk_fprintf(hFile, \"mode: %s\\n\", ls);\n\n    tsk_fprintf(hFile, \"size: %\" PRIdOFF \"\\n\", fs_meta->size);\n    tsk_fprintf(hFile, \"num of links: %d\\n\", fs_meta->nlink);\n\n    if(version != NULL){\n        yaffsfs_read_header(yfs, &header, version->ycv_header_chunk->ycc_offset);\n        if(header != NULL){\n            tsk_fprintf(hFile, \"Name: %s\\n\", header->name);\n        }\n    }\n\n    if (sec_skew != 0) {\n        tsk_fprintf(hFile, \"\\nAdjusted Inode Times:\\n\");\n        fs_meta->mtime -= sec_skew;\n        fs_meta->atime -= sec_skew;\n        fs_meta->ctime -= sec_skew;\n\n        tsk_fprintf(hFile, \"Accessed:\\t%s\\n\",\n            tsk_fs_time_to_str(fs_meta->atime, timeBuf));\n        tsk_fprintf(hFile, \"File Modified:\\t%s\\n\",\n            tsk_fs_time_to_str(fs_meta->mtime, timeBuf));\n        tsk_fprintf(hFile, \"Inode Modified:\\t%s\\n\",\n            tsk_fs_time_to_str(fs_meta->ctime, timeBuf));\n\n        fs_meta->mtime += sec_skew;\n        fs_meta->atime += sec_skew;\n        fs_meta->ctime += sec_skew;\n\n        tsk_fprintf(hFile, \"\\nOriginal Inode Times:\\n\");\n    }\n    else {\n        tsk_fprintf(hFile, \"\\nInode Times:\\n\");\n    }\n\n    tsk_fprintf(hFile, \"Accessed:\\t%s\\n\",\n        tsk_fs_time_to_str(fs_meta->atime, timeBuf));\n    tsk_fprintf(hFile, \"File Modified:\\t%s\\n\",\n        tsk_fs_time_to_str(fs_meta->mtime, timeBuf));\n    tsk_fprintf(hFile, \"Inode Modified:\\t%s\\n\",\n        tsk_fs_time_to_str(fs_meta->ctime, timeBuf));\n\n    if(version != NULL){\n        tsk_fprintf(hFile, \"\\nHeader Chunk:\\n\");\n        tsk_fprintf(hFile, \"%\" PRIuDADDR \"\\n\", (version->ycv_header_chunk->ycc_offset / (yfs->page_size + yfs->spare_size)));\n    }\n\n    if (numblock > 0) {\n        TSK_OFF_T lower_size = numblock * fs->block_size;\n        fs_meta->size = (lower_size < fs_meta->size)?(lower_size):(fs_meta->size);\n    }\n    tsk_fprintf(hFile, \"\\nData Chunks:\\n\");\n\n\n    if (flags & TSK_FS_ISTAT_RUNLIST){\n        const TSK_FS_ATTR *fs_attr_default =\n            tsk_fs_file_attr_get_type(fs_file,\n                TSK_FS_ATTR_TYPE_DEFAULT, 0, 0);\n        if (fs_attr_default && (fs_attr_default->flags & TSK_FS_ATTR_NONRES)) {\n            if (tsk_fs_attr_print(fs_attr_default, hFile)) {\n                tsk_fprintf(hFile, \"\\nError creating run lists  \");\n                tsk_error_print(hFile);\n                tsk_error_reset();\n            }\n        }\n    }\n    else {\n        print.idx = 0;\n        print.hFile = hFile;\n\n        if (tsk_fs_file_walk(fs_file, TSK_FS_FILE_WALK_FLAG_AONLY,\n            (TSK_FS_FILE_WALK_CB)print_addr_act, (void *)&print)) {\n            tsk_fprintf(hFile, \"\\nError reading file:  \");\n            tsk_error_print(hFile);\n            tsk_error_reset();\n        }\n        else if (print.idx != 0) {\n            tsk_fprintf(hFile, \"\\n\");\n        }\n    }\n\n    tsk_fs_file_close(fs_file);\n\n    return 0;\n}\n\n/* yaffsfs_close - close an yaffsfs file system */\nstatic void\n    yaffsfs_close(TSK_FS_INFO *fs)\n{\n    if(fs != NULL){\n        YAFFSFS_INFO *yfs = (YAFFSFS_INFO *)fs;\n\n        fs->tag = 0;\n\n        // Walk and free the cache structures\n        yaffscache_objects_free(yfs);\n        yaffscache_chunks_free(yfs);\n\n        //tsk_deinit_lock(&yaffsfs->lock);\n        tsk_fs_free(fs);\n\t}\n}\n\ntypedef struct _dir_open_cb_args {\n    YAFFSFS_INFO *yfs;\n    TSK_FS_DIR *dir;\n    TSK_INUM_T parent_addr;\n} dir_open_cb_args;\n\nstatic TSK_RETVAL_ENUM\n    yaffs_dir_open_meta_cb(YaffsCacheObject * /*obj*/, YaffsCacheVersion *version, void *args) {\n        dir_open_cb_args *cb_args = (dir_open_cb_args *) args;\n        YaffsCacheChunk *chunk = version->ycv_header_chunk;\n        TSK_INUM_T curr_inode = 0;\n        uint32_t obj_id = chunk->ycc_obj_id;\n        uint32_t chunk_id = chunk->ycc_chunk_id;\n        uint32_t vnum = version->ycv_version;\n        YaffsHeader *header = NULL;\n        TSK_FS_NAME * fs_name;\n        char *file_ext;\n        char version_string[64]; // Allow a max of 64 bytes in the version string\n\n        yaffscache_obj_id_and_version_to_inode(obj_id, vnum, &curr_inode);\n\n        if (chunk_id != 0) {\n            return TSK_ERR;\n        }\n\n        if (tsk_verbose)\n            fprintf(stderr, \"dir_open_find_children_cb: %08\" PRIxINUM \" -> %08\" PRIx32 \":%d\\n\", cb_args->parent_addr, obj_id, vnum);\n\n\n        if (yaffsfs_read_header(cb_args->yfs, &header, chunk->ycc_offset) != TSK_OK) {\n            return TSK_ERR;\n        }\n\n        if ((fs_name = tsk_fs_name_alloc(YAFFSFS_MAXNAMLEN + 64, 0)) == NULL) {\n            free(header);\n            return TSK_ERR;\n        }\n\n        switch (obj_id) {\n        case YAFFS_OBJECT_LOSTNFOUND:\n            strncpy(fs_name->name, YAFFS_OBJECT_LOSTNFOUND_NAME,\n                fs_name->name_size - 64);\n            break;\n        case YAFFS_OBJECT_UNLINKED:\n            strncpy(fs_name->name, YAFFS_OBJECT_UNLINKED_NAME,\n                fs_name->name_size - 64);\n            break;\n        case YAFFS_OBJECT_DELETED:\n            strncpy(fs_name->name, YAFFS_OBJECT_DELETED_NAME,\n                fs_name->name_size - 64);\n            break;\n        default:\n            strncpy(fs_name->name, header->name, fs_name->name_size - 64);\n            break;\n        }\n        fs_name->name[fs_name->name_size - 65] = 0;\n\n        // Only put object/version string onto unallocated versions\n        if(! yaffs_is_version_allocated(cb_args->yfs, curr_inode)){ \n            // Also copy the extension so that it also shows up after the version string, which allows\n            // easier searching by file extension. Max extension length is 5 characters after the dot,\n            // and require at least one character before the dot\n            file_ext = strrchr(fs_name->name, '.');\n            if((file_ext != NULL) && (file_ext != fs_name->name) && (strlen(file_ext) < 7)){\n               snprintf(version_string, 64, \"#%d,%d%s\", obj_id, vnum, file_ext);\n            }\n            else{\n               snprintf(version_string, 64, \"#%d,%d\", obj_id, vnum);\n            }\n            strncat(fs_name->name, version_string, 64);\n            fs_name->flags = TSK_FS_NAME_FLAG_UNALLOC;\n        }\n        else{\n            fs_name->flags = TSK_FS_NAME_FLAG_ALLOC;\n        }\n\n        fs_name->meta_addr = curr_inode;\n\n        switch (header->obj_type) {\n        case YAFFS_TYPE_FILE:\n            fs_name->type = TSK_FS_NAME_TYPE_REG;\n            break;\n\n        case YAFFS_TYPE_DIRECTORY:\n            fs_name->type = TSK_FS_NAME_TYPE_DIR;\n            break;\n\n        case YAFFS_TYPE_SOFTLINK:\n        case YAFFS_TYPE_HARDLINK:\n            fs_name->type = TSK_FS_NAME_TYPE_LNK;\n            break;\n\n        case YAFFS_TYPE_SPECIAL:\n            fs_name->type = TSK_FS_NAME_TYPE_UNDEF; // Could be a socket\n            break;\n\n        default:\n            if (tsk_verbose)\n                fprintf(stderr, \"yaffs_dir_open_meta_cb: unhandled object type\\n\");\n            fs_name->type = TSK_FS_NAME_TYPE_UNDEF;\n            break;\n        }\n\n        free(header);\n\n        if (tsk_fs_dir_add(cb_args->dir, fs_name)) {\n            tsk_fs_name_free(fs_name);\n            return TSK_ERR;\n        }\n\n        /* A copy is made in tsk_fs_dir_add, so we can free this one */\n        tsk_fs_name_free(fs_name);\n\n        return TSK_OK;\n}\n\nstatic TSK_RETVAL_ENUM\n    yaffsfs_dir_open_meta(TSK_FS_INFO *a_fs, TSK_FS_DIR ** a_fs_dir,\n    TSK_INUM_T a_addr)\n{\n    TSK_FS_DIR *fs_dir;\n    TSK_FS_NAME *fs_name;\n    YAFFSFS_INFO *yfs = (YAFFSFS_INFO *)a_fs;\n    int should_walk_children = 0;\n    uint32_t obj_id;\n    uint32_t ver_number;\n\n    if (a_addr < a_fs->first_inum || a_addr > a_fs->last_inum) { \n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_WALK_RNG);\n        tsk_error_set_errstr(\"yaffs_dir_open_meta: Invalid inode value: %\"\n            PRIuINUM, a_addr);\n        return TSK_ERR;\n    }\n    else if (a_fs_dir == NULL) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_ARG);\n        tsk_error_set_errstr(\"yaffs_dir_open_meta: NULL fs_dir argument given\");\n        return TSK_ERR;\n    }\n\n    fs_dir = *a_fs_dir;\n\n    if (fs_dir) {\n        tsk_fs_dir_reset(fs_dir);\n        fs_dir->addr = a_addr;\n    }\n    else if ((*a_fs_dir = fs_dir = tsk_fs_dir_alloc(a_fs, a_addr, 128)) == NULL) {\n        return TSK_ERR;\n    }\n\n    if (tsk_verbose)\n        fprintf(stderr,\"yaffs_dir_open_meta: called for directory %\" PRIu32 \"\\n\", (uint32_t) a_addr);\n\n    //  handle the orphan directory if its contents were requested\n    if (a_addr == TSK_FS_ORPHANDIR_INUM(a_fs)) {\n        return tsk_fs_dir_find_orphans(a_fs, fs_dir);\n    }\n\n    if ((fs_name = tsk_fs_name_alloc(YAFFSFS_MAXNAMLEN, 0)) == NULL) {\n        return TSK_ERR;\n    }\n\n\n    if ((fs_dir->fs_file = \n        tsk_fs_file_open_meta(a_fs, NULL, a_addr)) == NULL) {\n            tsk_error_errstr2_concat(\" - yaffs_dir_open_meta\");\n            tsk_fs_name_free(fs_name);\n            return TSK_ERR;\n    }\n\n    // extract obj_id and ver_number from inum\n    yaffscache_inode_to_obj_id_and_version(a_addr, &obj_id, &ver_number);\n\n    // Decide if we should walk the directory structure\n    if (obj_id == YAFFS_OBJECT_DELETED ||\n        obj_id == YAFFS_OBJECT_UNLINKED) {\n            should_walk_children = 1;\n    }\n    else {\n        YaffsCacheObject *obj;\n        YaffsCacheVersion *versionFound;\n        TSK_RETVAL_ENUM result = yaffscache_version_find_by_inode(yfs, a_addr, &versionFound, &obj);\n        if (result != TSK_OK) {\n            if (tsk_verbose)\n                tsk_fprintf(stderr, \"yaffsfs_dir_open_meta: yaffscache_version_find_by_inode failed! (inode: %d\\n\", a_addr);\n            tsk_fs_name_free(fs_name);\n            return TSK_ERR;\n        }\n\n        /* Only attach files onto the latest version of the directory */\n        should_walk_children = (obj->yco_latest == versionFound);\n    }\n\n    // Search the cache for the children of this object and add them to fs_dir\n    if (should_walk_children) {\n        dir_open_cb_args args;\n        args.yfs = yfs;\n        args.dir = fs_dir;\n        args.parent_addr = a_addr;\n        yaffscache_find_children(yfs, a_addr, yaffs_dir_open_meta_cb, &args);\n    }\n\n    // add special entries to root directory\n    if (obj_id == YAFFS_OBJECT_ROOT) {\n        strncpy(fs_name->name, YAFFS_OBJECT_UNLINKED_NAME, fs_name->name_size);\n        fs_name->meta_addr = YAFFS_OBJECT_UNLINKED;\n        fs_name->type = TSK_FS_NAME_TYPE_DIR;\n        fs_name->flags = TSK_FS_NAME_FLAG_ALLOC;\n        if (tsk_fs_dir_add(fs_dir, fs_name)) {\n            tsk_fs_name_free(fs_name);\n            return TSK_ERR;\n        }\n\n        strncpy(fs_name->name, YAFFS_OBJECT_DELETED_NAME, fs_name->name_size);\n        fs_name->meta_addr = YAFFS_OBJECT_DELETED;\n        fs_name->type = TSK_FS_NAME_TYPE_DIR;\n        fs_name->flags = TSK_FS_NAME_FLAG_ALLOC;\n        if (tsk_fs_dir_add(fs_dir, fs_name)) {\n            tsk_fs_name_free(fs_name);\n            return TSK_ERR;\n        }\n\n        // orphan directory\n        if (tsk_fs_dir_make_orphan_dir_name(a_fs, fs_name)) {\n            tsk_fs_name_free(fs_name);\n            return TSK_ERR;\n        }\n        fs_name->meta_addr = yfs->fs_info.last_inum;\n        fs_name->type = TSK_FS_NAME_TYPE_DIR;\n        fs_name->flags = TSK_FS_NAME_FLAG_ALLOC;\n        if (tsk_fs_dir_add(fs_dir, fs_name)) {\n            tsk_fs_name_free(fs_name);\n            return TSK_ERR;\n        }\n    }\n\n    tsk_fs_name_free(fs_name);\n    return TSK_OK;\n}\n\nstatic TSK_FS_ATTR_TYPE_ENUM\n    yaffsfs_get_default_attr_type(const TSK_FS_FILE * /*a_file*/)\n{\n    return TSK_FS_ATTR_TYPE_DEFAULT;\n}\n\nstatic uint8_t\n    yaffsfs_load_attrs(TSK_FS_FILE *file)\n{\n    TSK_FS_ATTR *attr;\n    TSK_FS_META *meta;\n    TSK_FS_INFO *fs;\n    YAFFSFS_INFO *yfs;\n    TSK_FS_ATTR_RUN *data_run;\n    TSK_DADDR_T file_block_count;\n    YaffsCacheObject *obj;\n    YaffsCacheVersion *version;\n    TSK_RETVAL_ENUM result;\n    TSK_LIST *chunks_seen = NULL;\n    YaffsCacheChunk *curr;\n    TSK_FS_ATTR_RUN *data_run_new;\n\n\n    if (file == NULL || file->meta == NULL || file->fs_info == NULL)\n    {\n        tsk_error_set_errno(TSK_ERR_FS_ARG);\n        tsk_error_set_errstr\n            (\"yaffsfs_load_attrs: called with NULL pointers\");\n        return 1;\n    }\n\n    meta = file->meta;\n    yfs = (YAFFSFS_INFO *)file->fs_info;\n    fs = &yfs->fs_info;\n\n    // see if we have already loaded the runs\n    if ((meta->attr != NULL)\n        && (meta->attr_state == TSK_FS_META_ATTR_STUDIED)) {\n            return 0;\n    }\n    else if (meta->attr_state == TSK_FS_META_ATTR_ERROR) {\n        return 1;\n    }\n    // not sure why this would ever happen, but...\n    else if (meta->attr != NULL) {\n        tsk_fs_attrlist_markunused(meta->attr);\n    }\n    else if (meta->attr == NULL) {\n        meta->attr = tsk_fs_attrlist_alloc();\n    }\n\n    attr = tsk_fs_attrlist_getnew(meta->attr, TSK_FS_ATTR_NONRES);\n    if (attr == NULL) {\n        meta->attr_state = TSK_FS_META_ATTR_ERROR;\n        return 1;\n    }\n\n    if (meta->size == 0) {\n        data_run = NULL;\n    }\n    else {\n        /* BC: I'm not entirely sure this is needed.  My guess is that\n         * this was done instead of maintaining the head of the list of \n         * runs.  In theory, the tsk_fs_attr_add_run() method should handle\n         * the fillers. */\n        data_run = tsk_fs_attr_run_alloc();\n        if (data_run == NULL) {\n            tsk_fs_attr_run_free(data_run);\n            meta->attr_state = TSK_FS_META_ATTR_ERROR;\n            return 1;\n        }\n\n        data_run->offset = 0;\n        data_run->addr = 0;\n        data_run->len = (meta->size + fs->block_size - 1) / fs->block_size;\n        data_run->flags = TSK_FS_ATTR_RUN_FLAG_FILLER;\n    }\n    \n\n    // initialize the data run\n    if (tsk_fs_attr_set_run(file, attr, data_run, NULL,\n        TSK_FS_ATTR_TYPE_DEFAULT, TSK_FS_ATTR_ID_DEFAULT,\n        meta->size, meta->size, roundup(meta->size, fs->block_size), (TSK_FS_ATTR_FLAG_ENUM)0, 0)) {\n            meta->attr_state = TSK_FS_META_ATTR_ERROR;\n            return 1;\n    }\n\n    // If the file has size zero, return now\n    if(meta->size == 0){\n        meta->attr_state = TSK_FS_META_ATTR_STUDIED;\n        return 0;\n    }\n\n\n    /* Get the version for the given object. */\n    result = yaffscache_version_find_by_inode(yfs, meta->addr, &version, &obj);\n    if (result != TSK_OK || version == NULL) {\n        if (tsk_verbose)\n            tsk_fprintf(stderr, \"yaffsfs_load_attrs: yaffscache_version_find_by_inode failed!\\n\");\n        meta->attr_state = TSK_FS_META_ATTR_ERROR;\n        return 1;\n    }\n\n    if (tsk_verbose)\n        yaffscache_object_dump(stderr, obj);\n\n    file_block_count = data_run->len;\n    /* Cycle through the chunks for this version of this object */\n    curr = version->ycv_last_chunk;\n    while (curr != NULL && curr->ycc_obj_id == obj->yco_obj_id) {\n\n        if (curr->ycc_chunk_id == 0) {\n            if (tsk_verbose)\n                tsk_fprintf(stderr, \"yaffsfs_load_attrs: skipping header chunk\\n\");\n        }\n        else if (tsk_list_find(chunks_seen, curr->ycc_chunk_id)) {\n            if (tsk_verbose)\n                tsk_fprintf(stderr, \"yaffsfs_load_attrs: skipping duplicate chunk\\n\");\n        }\n        else if (curr->ycc_chunk_id > file_block_count) {\n            if (tsk_verbose)\n                tsk_fprintf(stderr, \"yaffsfs_load_attrs: skipping chunk past end\\n\");\n        }\n        /* We like this chunk */\n        else {\n            // add it to our internal list\n            if (tsk_list_add(&chunks_seen, curr->ycc_chunk_id)) {\n                meta->attr_state = TSK_FS_META_ATTR_ERROR;\n                tsk_list_free(chunks_seen);\n                chunks_seen = NULL;\n                return 1;\n            }\n\n            data_run_new = tsk_fs_attr_run_alloc();\n            if (data_run_new == NULL) {\n                tsk_fs_attr_run_free(data_run_new);\n                meta->attr_state = TSK_FS_META_ATTR_ERROR;\n                return 1;\n            }\n\n            data_run_new->offset = (curr->ycc_chunk_id - 1);\n            data_run_new->addr = curr->ycc_offset / (fs->block_pre_size + fs->block_size + fs->block_post_size);\n            data_run_new->len = 1;\n            data_run_new->flags = TSK_FS_ATTR_RUN_FLAG_NONE;\n\n            if (tsk_verbose)\n                tsk_fprintf(stderr, \"yaffsfs_load_attrs: @@@ Chunk %d : %08x is at offset 0x%016llx\\n\",\n                curr->ycc_chunk_id, curr->ycc_seq_number, curr->ycc_offset);\n\n            tsk_fs_attr_add_run(fs, attr, data_run_new);\n        }\n\n        curr = curr->ycc_prev;\n    }\n\n    tsk_list_free(chunks_seen);\n    meta->attr_state = TSK_FS_META_ATTR_STUDIED;\n    return 0;\n}\n\nstatic uint8_t \n    yaffsfs_jentry_walk(TSK_FS_INFO * /*info*/, int /*entry*/,\n    TSK_FS_JENTRY_WALK_CB /*cb*/, void * /*fn*/)\n{\n    tsk_error_reset();\n    tsk_error_set_errno(TSK_ERR_FS_UNSUPFUNC);\n    tsk_error_set_errstr(\"Journal support for YAFFS is not implemented\");\n    return 1;\n}\n\nstatic uint8_t \n    yaffsfs_jblk_walk(TSK_FS_INFO * /*info*/, TSK_DADDR_T /*daddr*/,\n    TSK_DADDR_T /*daddrt*/, int /*entry*/, TSK_FS_JBLK_WALK_CB /*cb*/,\n    void * /*fn*/)\n{\n    tsk_error_reset();\n    tsk_error_set_errno(TSK_ERR_FS_UNSUPFUNC);\n    tsk_error_set_errstr(\"Journal support for YAFFS is not implemented\");\n    return 1;\n}\n\nstatic uint8_t \n    yaffsfs_jopen(TSK_FS_INFO * /*info*/, TSK_INUM_T /*inum*/)\n{\n    tsk_error_reset();\n    tsk_error_set_errno(TSK_ERR_FS_UNSUPFUNC);\n    tsk_error_set_errstr(\"Journal support for YAFFS is not implemented\");\n    return 1;\n}\n\n/**\n* \\internal\n* Open part of a disk image as a Yaffs/2 file system.\n*\n* @param img_info Disk image to analyze\n* @param offset Byte offset where file system starts\n* @param ftype Specific type of file system\n* @param test Going to use this - 1 if we're doing auto-detect, 0 if not (display more verbose messages if the user specified YAFFS2)\n* @returns NULL on error or if data is not an Yaffs/3 file system\n*/\nTSK_FS_INFO *\n    yaffs2_open(TSK_IMG_INFO * img_info, TSK_OFF_T offset,\n    TSK_FS_TYPE_ENUM ftype, uint8_t test)\n{\n    YAFFSFS_INFO *yaffsfs = NULL;\n    TSK_FS_INFO *fs = NULL;\n    const unsigned int psize = img_info->page_size;\n    const unsigned int ssize = img_info->spare_size;\n    YaffsHeader * first_header = NULL;\n    TSK_FS_DIR *test_dir;\n    std::map<std::string, std::string> configParams;\n    YAFFS_CONFIG_STATUS config_file_status;\n\n    // clean up any error messages that are lying around\n    tsk_error_reset();\n\n    if (TSK_FS_TYPE_ISYAFFS2(ftype) == 0) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_ARG);\n        tsk_error_set_errstr(\"Invalid FS Type in yaffsfs_open\");\n        return NULL;\n    }\n\n    if (img_info->sector_size == 0) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_ARG);\n        tsk_error_set_errstr(\"yaffs2_open: sector size is 0\");\n        return NULL;\n    }\n\n    \n\n    if ((yaffsfs = (YAFFSFS_INFO *) tsk_fs_malloc(sizeof(YAFFSFS_INFO))) == NULL)\n        return NULL;\n    yaffsfs->cache_objects = NULL;\n    yaffsfs->chunkMap = NULL;\n\n    fs = &(yaffsfs->fs_info);\n\n    fs->tag = TSK_FS_INFO_TAG;\n    fs->ftype = ftype;\n    fs->flags = (TSK_FS_INFO_FLAG_ENUM)0;\n    fs->img_info = img_info;\n    fs->offset = offset;\n    fs->endian = TSK_LIT_ENDIAN;\n\n    // Read config file (if it exists)\n    config_file_status = yaffs_load_config_file(img_info, configParams);\n    // BL-6929(JTS): When using external readers, this call will fail.\n    // Not having a config should not be a fatal error.\n  /*if(config_file_status == YAFFS_CONFIG_ERROR){\n        // tsk_error was set by yaffs_load_config\n        goto on_error;\n    }\n    else*/ if(config_file_status == YAFFS_CONFIG_OK){\n        // Validate the input\n        // If it fails validation, return (tsk_error will be set up already)\n        if(1 == yaffs_validate_config_file(configParams)){\n            goto on_error;\n        }\n    }\n\n    // If we read these fields from the config file, use those values. Otherwise use the defaults\n    if(configParams.find(YAFFS_CONFIG_PAGE_SIZE_STR) != configParams.end()){\n        yaffsfs->page_size = atoi(configParams[YAFFS_CONFIG_PAGE_SIZE_STR].c_str());\n    }\n    else{\n        yaffsfs->page_size = psize == 0 ? YAFFS_DEFAULT_PAGE_SIZE : psize;\n    }\n\n    if(configParams.find(YAFFS_CONFIG_SPARE_SIZE_STR) != configParams.end()){\n        yaffsfs->spare_size = atoi(configParams[YAFFS_CONFIG_SPARE_SIZE_STR].c_str());\n    }\n    else{\n        yaffsfs->spare_size = ssize == 0 ? YAFFS_DEFAULT_SPARE_SIZE : ssize;\n    }\n\n    if(configParams.find(YAFFS_CONFIG_CHUNKS_PER_BLOCK_STR) != configParams.end()){\n        yaffsfs->chunks_per_block = atoi(configParams[YAFFS_CONFIG_CHUNKS_PER_BLOCK_STR].c_str());\n    }\n    else{\n        yaffsfs->chunks_per_block = 64;\n    }\n\n    // TODO: Why are 2 different memory allocation methods used in the same code?\n    // This makes things unnecessary complex.\n    yaffsfs->max_obj_id = 1;\n    yaffsfs->max_version = 0;\n\n    // Keep track of whether we're doing auto-detection of the file system\n    if(test){\n        yaffsfs->autoDetect = 1;\n    }\n    else{\n        yaffsfs->autoDetect = 0;\n    }\n\n    // Determine the layout of the spare area\n    // If it was specified in the config file, use those values. Otherwise do the auto-detection\n    if(configParams.find(YAFFS_CONFIG_SEQ_NUM_STR) != configParams.end()){\n        // In the validation step, we ensured that if one of the offsets was set, we have all of them\n        yaffsfs->spare_seq_offset = atoi(configParams[YAFFS_CONFIG_SEQ_NUM_STR].c_str());\n        yaffsfs->spare_obj_id_offset = atoi(configParams[YAFFS_CONFIG_OBJ_ID_STR].c_str());\n        yaffsfs->spare_chunk_id_offset = atoi(configParams[YAFFS_CONFIG_CHUNK_ID_STR].c_str());\n\n        // Check that the offsets are valid for the given spare area size (fields are 4 bytes long)\n        if((yaffsfs->spare_seq_offset + 4 > yaffsfs->spare_size) ||\n            (yaffsfs->spare_obj_id_offset + 4 > yaffsfs->spare_size) ||\n            (yaffsfs->spare_chunk_id_offset + 4 > yaffsfs->spare_size)){\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_FS);\n            tsk_error_set_errstr(\"yaffs2_open: Offset(s) in config file too large for spare area (size %d). %s\", yaffsfs->spare_size, YAFFS_HELP_MESSAGE);\n            goto on_error;\n        }\n\n\n        // nBytes isn't currently used, so just set to zero\n        yaffsfs->spare_nbytes_offset = 0;\n    }\n    else{\n        // Decide how many blocks to test. If we're not doing auto-detection, set to zero (no limit)\n        unsigned int maxBlocksToTest;\n        if(yaffsfs->autoDetect){\n            maxBlocksToTest = YAFFS_DEFAULT_MAX_TEST_BLOCKS;\n        }\n        else{\n            maxBlocksToTest = 0;\n        }\n\n        if(yaffs_initialize_spare_format(yaffsfs, maxBlocksToTest) != TSK_OK){\n            tsk_error_reset();\n            tsk_error_set_errno(TSK_ERR_FS_MAGIC);\n            tsk_error_set_errstr(\"not a YAFFS file system (bad spare format). %s\", YAFFS_HELP_MESSAGE);\n            if (tsk_verbose)\n                fprintf(stderr, \"yaffsfs_open: could not find valid spare area format\\n%s\\n\", YAFFS_HELP_MESSAGE);\n            goto on_error;\n        }\n    }\n\n    /*\n    * Read the first record, make sure it's a valid header...\n    *\n    * Used for verification and autodetection of\n    * the FS type.\n    */\n    if (yaffsfs_read_header(yaffsfs, &first_header, 0)) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_MAGIC);\n        tsk_error_set_errstr(\"not a YAFFS file system (first record). %s\", YAFFS_HELP_MESSAGE);\n        if (tsk_verbose)\n            fprintf(stderr, \"yaffsfs_open: invalid first record\\n%s\\n\", YAFFS_HELP_MESSAGE);\n        goto on_error;\n    }\n    free(first_header);\n    first_header = NULL;\n\n    fs->duname = \"Chunk\";\n\n    /*\n    * Calculate the meta data info\n    */\n    //fs->last_inum = 0xffffffff; // Will update this as we go\n    fs->last_inum = 0;\n    fs->root_inum = YAFFS_OBJECT_ROOT;\n    fs->first_inum = YAFFS_OBJECT_FIRST;\n    //fs->inum_count = fs->last_inum; // For now this will be the last_inum - 1 (after we calculate it)\n\n    /*\n    * Calculate the block info\n    */\n    fs->dev_bsize = img_info->sector_size;\n    fs->block_size = yaffsfs->page_size;\n    fs->block_pre_size = 0;\n    fs->block_post_size = yaffsfs->spare_size;\n    fs->block_count = img_info->size / (fs->block_pre_size + fs->block_size + fs->block_post_size);\n    fs->first_block = 0;\n    fs->last_block_act = fs->last_block = fs->block_count ? fs->block_count - 1 : 0;\n\n    /* Set the generic function pointers */\n    fs->inode_walk = yaffsfs_inode_walk;\n    fs->block_walk = yaffsfs_block_walk;\n    fs->block_getflags = yaffsfs_block_getflags;\n\n    fs->get_default_attr_type = yaffsfs_get_default_attr_type;\n    fs->load_attrs = yaffsfs_load_attrs;\n\n    fs->file_add_meta = yaffs_inode_lookup;\n    fs->dir_open_meta = yaffsfs_dir_open_meta;\n    fs->fsstat = yaffsfs_fsstat;\n    fs->fscheck = yaffsfs_fscheck;\n    fs->istat = yaffsfs_istat;\n    fs->name_cmp = tsk_fs_unix_name_cmp;\n\n    fs->close = yaffsfs_close;\n\n    /* Journal */\n    fs->jblk_walk = yaffsfs_jblk_walk;\n    fs->jentry_walk = yaffsfs_jentry_walk;\n    fs->jopen = yaffsfs_jopen;\n\n    /* Initialize the caches */\n    if (tsk_verbose)\n        fprintf(stderr, \"yaffsfs_open: building cache...\\n\");\n\n    /* Build cache */\n    /* NOTE: The only modifications to the cache happen here, during at \n    *       the open. Should be fine with no lock, even if access to the\n    *       cache is shared among threads.\n    */\n    //tsk_init_lock(&yaffsfs->lock);\n    yaffsfs->chunkMap = new std::map<uint32_t, YaffsCacheChunkGroup>;\n    if (TSK_OK != yaffsfs_parse_image_load_cache(yaffsfs)) {\n        goto on_error;\n    }\n\n    if (tsk_verbose) {\n        fprintf(stderr, \"yaffsfs_open: done building cache!\\n\");\n        //yaffscache_objects_dump(yaffsfs, stderr);\n    }\n\n    // Update the number of inums now that we've read in the file system\n    fs->inum_count = fs->last_inum - 1;\n\n    test_dir = tsk_fs_dir_open_meta(fs, fs->root_inum);\n    if (test_dir == NULL) {\n        tsk_error_reset();\n        tsk_error_set_errno(TSK_ERR_FS_MAGIC);\n        tsk_error_set_errstr(\"not a YAFFS file system (no root directory). %s\", YAFFS_HELP_MESSAGE);\n        if (tsk_verbose)\n            fprintf(stderr, \"yaffsfs_open: invalid file system\\n%s\\n\", YAFFS_HELP_MESSAGE);\n        goto on_error;\n    }\n    tsk_fs_dir_close(test_dir);\n\n    return fs;\n\non_error:\n    // yaffsfs_close frees all the cache objects\n    yaffsfs_close(fs);\n\n    return NULL;\n}\n\n"], "filenames": ["tsk/fs/yaffs.cpp"], "buggy_code_start_loc": [2442], "buggy_code_end_loc": [2443], "fixing_code_start_loc": [2442], "fixing_code_end_loc": [2443], "type": "CWE-787", "message": "In version 4.8.0 and earlier of The Sleuth Kit (TSK), there is a stack buffer overflow vulnerability in the YAFFS file timestamp parsing logic in yaffsfs_istat() in fs/yaffs.c.", "other": {"cve": {"id": "CVE-2020-10232", "sourceIdentifier": "cve@mitre.org", "published": "2020-03-09T00:15:10.830", "lastModified": "2022-11-29T16:57:27.777", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In version 4.8.0 and earlier of The Sleuth Kit (TSK), there is a stack buffer overflow vulnerability in the YAFFS file timestamp parsing logic in yaffsfs_istat() in fs/yaffs.c."}, {"lang": "es", "value": "En la versi\u00f3n 4.8.0 y anteriores de The Sleuth Kit (TSK), se presenta una vulnerabilidad de desbordamiento del b\u00fafer de la pila en la l\u00f3gica de an\u00e1lisis de marca de tiempo de archivo YAFFS en la funci\u00f3n yaffsfs_istat() en el archivo fs/yaffs.c."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 9.8, "baseSeverity": "CRITICAL"}, "exploitabilityScore": 3.9, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 7.5}, "baseSeverity": "HIGH", "exploitabilityScore": 10.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-787"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:sleuthkit:the_sleuth_kit:*:*:*:*:*:*:*:*", "versionEndIncluding": "4.8.0", "matchCriteriaId": "82607605-9F72-4A99-9704-09E58BA042E0"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:8.0:*:*:*:*:*:*:*", "matchCriteriaId": "C11E6FB0-C8C0-4527-9AA0-CB9B316F8F43"}, {"vulnerable": true, "criteria": "cpe:2.3:o:debian:debian_linux:9.0:*:*:*:*:*:*:*", "matchCriteriaId": "DEECE5FC-CACF-4496-A3E7-164736409252"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:30:*:*:*:*:*:*:*", "matchCriteriaId": "97A4B8DF-58DA-4AB6-A1F9-331B36409BA3"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:31:*:*:*:*:*:*:*", "matchCriteriaId": "80F0FA5D-8D3B-4C0E-81E2-87998286AF33"}, {"vulnerable": true, "criteria": "cpe:2.3:o:fedoraproject:fedora:32:*:*:*:*:*:*:*", "matchCriteriaId": "36D96259-24BD-44E2-96D9-78CE1D41F956"}]}]}], "references": [{"url": "https://github.com/sleuthkit/sleuthkit/commit/459ae818fc8dae717549810150de4d191ce158f1", "source": "cve@mitre.org", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2020/03/msg00011.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.debian.org/debian-lts-announce/2022/06/msg00015.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/5EY53OYU7UZLAJWNIVVNR3EX2RNCCFTB/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/AQR2QY3IAF2IG6HGBSKGL66VUDOTC3OA/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://lists.fedoraproject.org/archives/list/package-announce@lists.fedoraproject.org/message/FFQKIE5U3LS5U7POPGS7YHLUSW2URWGJ/", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/sleuthkit/sleuthkit/commit/459ae818fc8dae717549810150de4d191ce158f1"}}