{"buggy_code": ["/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * Copyright (C) 2011 D. R. Commander.  All Rights Reserved.\n * Copyright 2009-2014 Pierre Ossman for Cendio AB\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n#include <assert.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n#include <rdr/InStream.h>\n#include <rdr/OutStream.h>\n#include <rfb/Exception.h>\n#include <rfb/PixelFormat.h>\n#include <rfb/util.h>\n\n#ifdef _WIN32\n#define strcasecmp _stricmp\n#endif\n\nusing namespace rfb;\n\nrdr::U8 PixelFormat::upconvTable[256*8];\nrdr::U8 PixelFormat::downconvTable[256*8];\n\nclass PixelFormat::Init {\npublic:\n  Init();\n};\n\nPixelFormat::Init PixelFormat::_init;\n\n\nPixelFormat::Init::Init()\n{\n  int bits;\n\n  // Shifting bits is almost perfect, but not quite. And\n  // a lookup table is still quicker when there is a large\n  // difference between the source and destination depth.\n\n  for (bits = 1;bits <= 8;bits++) {\n    int i, maxVal;\n    rdr::U8 *subUpTable;\n    rdr::U8 *subDownTable;\n\n    maxVal = (1 << bits) - 1;\n    subUpTable = &upconvTable[(bits-1)*256];\n    subDownTable = &downconvTable[(bits-1)*256];\n\n    for (i = 0;i <= maxVal;i++)\n      subUpTable[i] = i * 255 / maxVal;\n\n    // Duplicate the up table so that we don't have to care about\n    // the upper bits when doing a lookup\n    for (;i < 256;i += maxVal+1)\n      memcpy(&subUpTable[i], &subUpTable[0], maxVal+1);\n\n    for (i = 0;i <= 255;i++)\n      subDownTable[i] = (i * maxVal + 128) / 255;\n  }\n}\n\n\nPixelFormat::PixelFormat(int b, int d, bool e, bool t,\n                         int rm, int gm, int bm, int rs, int gs, int bs)\n  : bpp(b), depth(d), trueColour(t), bigEndian(e),\n    redMax(rm), greenMax(gm), blueMax(bm),\n    redShift(rs), greenShift(gs), blueShift(bs)\n{\n  if (!isSane())\n    throw Exception(\"invalid pixel format\");\n\n  updateState();\n}\n\nPixelFormat::PixelFormat()\n  : bpp(8), depth(8), trueColour(true), bigEndian(false),\n    redMax(7), greenMax(7), blueMax(3),\n    redShift(0), greenShift(3), blueShift(6)\n{\n  updateState();\n}\n\nbool PixelFormat::equal(const PixelFormat& other) const\n{\n  if (bpp != other.bpp || depth != other.depth)\n    return false;\n\n  if (redMax != other.redMax)\n    return false;\n  if (greenMax != other.greenMax)\n    return false;\n  if (blueMax != other.blueMax)\n    return false;\n\n  // Endianness requires more care to determine compatibility\n  if (bigEndian == other.bigEndian || bpp == 8) {\n    if (redShift != other.redShift)\n      return false;\n    if (greenShift != other.greenShift)\n      return false;\n    if (blueShift != other.blueShift)\n      return false;\n  } else {\n    // Has to be the same byte for each channel\n    if (redShift/8 != (3 - other.redShift/8))\n      return false;\n    if (greenShift/8 != (3 - other.greenShift/8))\n      return false;\n    if (blueShift/8 != (3 - other.blueShift/8))\n      return false;\n\n    // And the same bit offset within the byte\n    if (redShift%8 != other.redShift%8)\n      return false;\n    if (greenShift%8 != other.greenShift%8)\n      return false;\n    if (blueShift%8 != other.blueShift%8)\n      return false;\n\n    // And not cross a byte boundary\n    if (redShift/8 != (redShift + redBits - 1)/8)\n      return false;\n    if (greenShift/8 != (greenShift + greenBits - 1)/8)\n      return false;\n    if (blueShift/8 != (blueShift + blueBits - 1)/8)\n      return false;\n  }\n\n  return true;\n}\n\nvoid PixelFormat::read(rdr::InStream* is)\n{\n  bpp = is->readU8();\n  depth = is->readU8();\n  bigEndian = is->readU8();\n  trueColour = is->readU8();\n  redMax = is->readU16();\n  greenMax = is->readU16();\n  blueMax = is->readU16();\n  redShift = is->readU8();\n  greenShift = is->readU8();\n  blueShift = is->readU8();\n  is->skip(3);\n\n  // We have no real support for colour maps. If the client\n  // wants one, then we force a 8-bit true colour format and\n  // pretend it's a colour map.\n  if (!trueColour) {\n    redMax = 7;\n    greenMax = 7;\n    blueMax = 3;\n    redShift = 0;\n    greenShift = 3;\n    blueShift = 6;\n  }\n\n  if (!isSane())\n    throw Exception(\"invalid pixel format\");\n\n  updateState();\n}\n\nvoid PixelFormat::write(rdr::OutStream* os) const\n{\n  os->writeU8(bpp);\n  os->writeU8(depth);\n  os->writeU8(bigEndian);\n  os->writeU8(trueColour);\n  os->writeU16(redMax);\n  os->writeU16(greenMax);\n  os->writeU16(blueMax);\n  os->writeU8(redShift);\n  os->writeU8(greenShift);\n  os->writeU8(blueShift);\n  os->pad(3);\n}\n\n\nbool PixelFormat::is888(void) const\n{\n  if (!trueColour)\n    return false;\n  if (bpp != 32)\n    return false;\n  if (depth != 24)\n    return false;\n  if (redMax != 255)\n    return false;\n  if (greenMax != 255)\n    return false;\n  if (blueMax != 255)\n    return false;\n\n  return true;\n}\n\n\nbool PixelFormat::isBigEndian(void) const\n{\n  return bigEndian;\n}\n\n\nbool PixelFormat::isLittleEndian(void) const\n{\n  return ! bigEndian;\n}\n\n\nvoid PixelFormat::bufferFromRGB(rdr::U8 *dst, const rdr::U8* src, int pixels) const\n{\n  bufferFromRGB(dst, src, pixels, pixels, 1);\n}\n\nvoid PixelFormat::bufferFromRGB(rdr::U8 *dst, const rdr::U8* src,\n                                int w, int stride, int h) const\n{\n  if (is888()) {\n    // Optimised common case\n    rdr::U8 *r, *g, *b, *x;\n\n    if (bigEndian) {\n      r = dst + (24 - redShift)/8;\n      g = dst + (24 - greenShift)/8;\n      b = dst + (24 - blueShift)/8;\n      x = dst + (24 - (48 - redShift - greenShift - blueShift))/8;\n    } else {\n      r = dst + redShift/8;\n      g = dst + greenShift/8;\n      b = dst + blueShift/8;\n      x = dst + (48 - redShift - greenShift - blueShift)/8;\n    }\n\n    int dstPad = (stride - w) * 4;\n    while (h--) {\n      int w_ = w;\n      while (w_--) {\n        *r = *(src++);\n        *g = *(src++);\n        *b = *(src++);\n        *x = 0;\n        r += 4;\n        g += 4;\n        b += 4;\n        x += 4;\n      }\n      r += dstPad;\n      g += dstPad;\n      b += dstPad;\n      x += dstPad;\n    }\n  } else {\n    // Generic code\n    int dstPad = (stride - w) * bpp/8;\n    while (h--) {\n      int w_ = w;\n      while (w_--) {\n        Pixel p;\n        rdr::U8 r, g, b;\n\n        r = *(src++);\n        g = *(src++);\n        b = *(src++);\n\n        p = pixelFromRGB(r, g, b);\n\n        bufferFromPixel(dst, p);\n        dst += bpp/8;\n      }\n      dst += dstPad;\n    }\n  }\n}\n\n\nvoid PixelFormat::rgbFromBuffer(rdr::U8* dst, const rdr::U8* src, int pixels) const\n{\n  rgbFromBuffer(dst, src, pixels, pixels, 1);\n}\n\n\nvoid PixelFormat::rgbFromBuffer(rdr::U8* dst, const rdr::U8* src,\n                                int w, int stride, int h) const\n{\n  if (is888()) {\n    // Optimised common case\n    const rdr::U8 *r, *g, *b;\n\n    if (bigEndian) {\n      r = src + (24 - redShift)/8;\n      g = src + (24 - greenShift)/8;\n      b = src + (24 - blueShift)/8;\n    } else {\n      r = src + redShift/8;\n      g = src + greenShift/8;\n      b = src + blueShift/8;\n    }\n\n    int srcPad = (stride - w) * 4;\n    while (h--) {\n      int w_ = w;\n      while (w_--) {\n        *(dst++) = *r;\n        *(dst++) = *g;\n        *(dst++) = *b;\n        r += 4;\n        g += 4;\n        b += 4;\n      }\n      r += srcPad;\n      g += srcPad;\n      b += srcPad;\n    }\n  } else {\n    // Generic code\n    int srcPad = (stride - w) * bpp/8;\n    while (h--) {\n      int w_ = w;\n      while (w_--) {\n        Pixel p;\n        rdr::U8 r, g, b;\n\n        p = pixelFromBuffer(src);\n\n        rgbFromPixel(p, &r, &g, &b);\n\n        *(dst++) = r;\n        *(dst++) = g;\n        *(dst++) = b;\n        src += bpp/8;\n      }\n      src += srcPad;\n    }\n  }\n}\n\n\nPixel PixelFormat::pixelFromPixel(const PixelFormat &srcPF, Pixel src) const\n{\n  rdr::U16 r, g, b;\n  srcPF.rgbFromPixel(src, &r, &g, &b);\n  return pixelFromRGB(r, g, b);\n}\n\n\nvoid PixelFormat::bufferFromBuffer(rdr::U8* dst, const PixelFormat &srcPF,\n                                   const rdr::U8* src, int pixels) const\n{\n  bufferFromBuffer(dst, srcPF, src, pixels, 1, pixels, pixels);\n}\n\n#define IS_ALIGNED(v, a) (((intptr_t)v & (a-1)) == 0)\n\nvoid PixelFormat::bufferFromBuffer(rdr::U8* dst, const PixelFormat &srcPF,\n                                   const rdr::U8* src, int w, int h,\n                                   int dstStride, int srcStride) const\n{\n  if (equal(srcPF)) {\n    // Trivial case\n    while (h--) {\n      memcpy(dst, src, w * bpp/8);\n      dst += dstStride * bpp/8;\n      src += srcStride * srcPF.bpp/8;\n    }\n  } else if (is888() && srcPF.is888()) {\n    // Optimised common case A: byte shuffling (e.g. endian conversion)\n    rdr::U8 *d[4], *s[4];\n    int dstPad, srcPad;\n\n    if (bigEndian) {\n      s[0] = dst + (24 - redShift)/8;\n      s[1] = dst + (24 - greenShift)/8;\n      s[2] = dst + (24 - blueShift)/8;\n      s[3] = dst + (24 - (48 - redShift - greenShift - blueShift))/8;\n    } else {\n      s[0] = dst + redShift/8;\n      s[1] = dst + greenShift/8;\n      s[2] = dst + blueShift/8;\n      s[3] = dst + (48 - redShift - greenShift - blueShift)/8;\n    }\n\n    if (srcPF.bigEndian) {\n      d[(24 - srcPF.redShift)/8] = s[0];\n      d[(24 - srcPF.greenShift)/8] = s[1];\n      d[(24 - srcPF.blueShift)/8] = s[2];\n      d[(24 - (48 - srcPF.redShift - srcPF.greenShift - srcPF.blueShift))/8] = s[3];\n    } else {\n      d[srcPF.redShift/8] = s[0];\n      d[srcPF.greenShift/8] = s[1];\n      d[srcPF.blueShift/8] = s[2];\n      d[(48 - srcPF.redShift - srcPF.greenShift - srcPF.blueShift)/8] = s[3];\n    }\n\n    dstPad = (dstStride - w) * 4;\n    srcPad = (srcStride - w) * 4;\n    while (h--) {\n      int w_ = w;\n      while (w_--) {\n        *d[0] = *(src++);\n        *d[1] = *(src++);\n        *d[2] = *(src++);\n        *d[3] = *(src++);\n        d[0] += 4;\n        d[1] += 4;\n        d[2] += 4;\n        d[3] += 4;\n      }\n      d[0] += dstPad;\n      d[1] += dstPad;\n      d[2] += dstPad;\n      d[3] += dstPad;\n      src += srcPad;\n    }\n  } else if (IS_ALIGNED(dst, bpp/8) && srcPF.is888()) {\n    // Optimised common case B: 888 source\n    switch (bpp) {\n    case 8:\n      directBufferFromBufferFrom888((rdr::U8*)dst, srcPF, src,\n                                    w, h, dstStride, srcStride);\n      break;\n    case 16:\n      directBufferFromBufferFrom888((rdr::U16*)dst, srcPF, src,\n                                    w, h, dstStride, srcStride);\n      break;\n    case 32:\n      directBufferFromBufferFrom888((rdr::U32*)dst, srcPF, src,\n                                    w, h, dstStride, srcStride);\n      break;\n    }\n  } else if (IS_ALIGNED(src, srcPF.bpp/8) && is888()) {\n    // Optimised common case C: 888 destination\n    switch (srcPF.bpp) {\n    case 8:\n      directBufferFromBufferTo888(dst, srcPF, (rdr::U8*)src,\n                                  w, h, dstStride, srcStride);\n      break;\n    case 16:\n      directBufferFromBufferTo888(dst, srcPF, (rdr::U16*)src,\n                                  w, h, dstStride, srcStride);\n      break;\n    case 32:\n      directBufferFromBufferTo888(dst, srcPF, (rdr::U32*)src,\n                                  w, h, dstStride, srcStride);\n      break;\n    }\n  } else {\n    // Generic code\n    int dstPad = (dstStride - w) * bpp/8;\n    int srcPad = (srcStride - w) * srcPF.bpp/8;\n    while (h--) {\n      int w_ = w;\n      while (w_--) {\n        Pixel p;\n        rdr::U8 r, g, b;\n\n        p = srcPF.pixelFromBuffer(src);\n        srcPF.rgbFromPixel(p, &r, &g, &b);\n        p = pixelFromRGB(r, g, b);\n        bufferFromPixel(dst, p);\n\n        dst += bpp/8;\n        src += srcPF.bpp/8;\n      }\n      dst += dstPad;\n      src += srcPad;\n    }\n  }\n}\n\n\nvoid PixelFormat::print(char* str, int len) const\n{\n  // Unfortunately snprintf is not widely available so we build the string up\n  // using strncat - not pretty, but should be safe against buffer overruns.\n\n  char num[20];\n  if (len < 1) return;\n  str[0] = 0;\n  strncat(str, \"depth \", len-1-strlen(str));\n  sprintf(num,\"%d\",depth);\n  strncat(str, num, len-1-strlen(str));\n  strncat(str, \" (\", len-1-strlen(str));\n  sprintf(num,\"%d\",bpp);\n  strncat(str, num, len-1-strlen(str));\n  strncat(str, \"bpp)\", len-1-strlen(str));\n  if (bpp != 8) {\n    if (bigEndian)\n      strncat(str, \" big-endian\", len-1-strlen(str));\n    else\n      strncat(str, \" little-endian\", len-1-strlen(str));\n  }\n\n  if (!trueColour) {\n    strncat(str, \" color-map\", len-1-strlen(str));\n    return;\n  }\n\n  if (blueShift == 0 && greenShift > blueShift && redShift > greenShift &&\n      blueMax  == (1 << greenShift) - 1 &&\n      greenMax == (1 << (redShift-greenShift)) - 1 &&\n      redMax   == (1 << (depth-redShift)) - 1)\n  {\n    strncat(str, \" rgb\", len-1-strlen(str));\n    sprintf(num,\"%d\",depth-redShift);\n    strncat(str, num, len-1-strlen(str));\n    sprintf(num,\"%d\",redShift-greenShift);\n    strncat(str, num, len-1-strlen(str));\n    sprintf(num,\"%d\",greenShift);\n    strncat(str, num, len-1-strlen(str));\n    return;\n  }\n\n  if (redShift == 0 && greenShift > redShift && blueShift > greenShift &&\n      redMax   == (1 << greenShift) - 1 &&\n      greenMax == (1 << (blueShift-greenShift)) - 1 &&\n      blueMax  == (1 << (depth-blueShift)) - 1)\n  {\n    strncat(str, \" bgr\", len-1-strlen(str));\n    sprintf(num,\"%d\",depth-blueShift);\n    strncat(str, num, len-1-strlen(str));\n    sprintf(num,\"%d\",blueShift-greenShift);\n    strncat(str, num, len-1-strlen(str));\n    sprintf(num,\"%d\",greenShift);\n    strncat(str, num, len-1-strlen(str));\n    return;\n  }\n\n  strncat(str, \" rgb max \", len-1-strlen(str));\n  sprintf(num,\"%d,\",redMax);\n  strncat(str, num, len-1-strlen(str));\n  sprintf(num,\"%d,\",greenMax);\n  strncat(str, num, len-1-strlen(str));\n  sprintf(num,\"%d\",blueMax);\n  strncat(str, num, len-1-strlen(str));\n  strncat(str, \" shift \", len-1-strlen(str));\n  sprintf(num,\"%d,\",redShift);\n  strncat(str, num, len-1-strlen(str));\n  sprintf(num,\"%d,\",greenShift);\n  strncat(str, num, len-1-strlen(str));\n  sprintf(num,\"%d\",blueShift);\n  strncat(str, num, len-1-strlen(str));\n}\n\n\nbool PixelFormat::parse(const char* str)\n{\n  char rgbbgr[4];\n  int bits1, bits2, bits3;\n  if (sscanf(str, \"%3s%1d%1d%1d\", rgbbgr, &bits1, &bits2, &bits3) < 4)\n    return false;\n  \n  depth = bits1 + bits2 + bits3;\n  bpp = depth <= 8 ? 8 : ((depth <= 16) ? 16 : 32);\n  trueColour = true;\n  rdr::U32 endianTest = 1;\n  bigEndian = (*(rdr::U8*)&endianTest == 0);\n\n  greenShift = bits3;\n  greenMax = (1 << bits2) - 1;\n\n  if (strcasecmp(rgbbgr, \"bgr\") == 0) {\n    redShift = 0;\n    redMax = (1 << bits3) - 1;\n    blueShift = bits3 + bits2;\n    blueMax = (1 << bits1) - 1;\n  } else if (strcasecmp(rgbbgr, \"rgb\") == 0) {\n    blueShift = 0;\n    blueMax = (1 << bits3) - 1;\n    redShift = bits3 + bits2;\n    redMax = (1 << bits1) - 1;\n  } else {\n    return false;\n  }\n\n  assert(isSane());\n\n  updateState();\n\n  return true;\n}\n\n\nstatic int bits(rdr::U16 value)\n{\n  int bits;\n\n  bits = 16;\n\n  if (!(value & 0xff00)) {\n    bits -= 8;\n    value <<= 8;\n  }\n  if (!(value & 0xf000)) {\n    bits -= 4;\n    value <<= 4;\n  }\n  if (!(value & 0xc000)) {\n    bits -= 2;\n    value <<= 2;\n  }\n  if (!(value & 0x8000)) {\n    bits -= 1;\n    value <<= 1;\n  }\n\n  return bits;\n}\n\nvoid PixelFormat::updateState(void)\n{\n  int endianTest = 1;\n\n  redBits = bits(redMax);\n  greenBits = bits(greenMax);\n  blueBits = bits(blueMax);\n\n  maxBits = redBits;\n  if (greenBits > maxBits)\n    maxBits = greenBits;\n  if (blueBits > maxBits)\n    maxBits = blueBits;\n\n  minBits = redBits;\n  if (greenBits < minBits)\n    minBits = greenBits;\n  if (blueBits < minBits)\n    minBits = blueBits;\n\n  if (((*(char*)&endianTest) == 0) != bigEndian)\n    endianMismatch = true;\n  else\n    endianMismatch = false;\n}\n\nbool PixelFormat::isSane(void)\n{\n  int totalBits;\n\n  if ((bpp != 8) && (bpp != 16) && (bpp != 32))\n    return false;\n  if (depth > bpp)\n    return false;\n\n  if (!trueColour && (depth != 8))\n    return false;\n\n  if ((redMax & (redMax + 1)) != 0)\n    return false;\n  if ((greenMax & (greenMax + 1)) != 0)\n    return false;\n  if ((blueMax & (blueMax + 1)) != 0)\n    return false;\n\n  /*\n   * We don't allow individual channels > 8 bits in order to keep our\n   * conversions simple.\n   */\n  if (redMax >= (1 << 8))\n    return false;\n  if (greenMax >= (1 << 8))\n    return false;\n  if (blueMax >= (1 << 8))\n    return false;\n\n  totalBits = bits(redMax) + bits(greenMax) + bits(blueMax);\n  if (totalBits > depth)\n    return false;\n\n  if ((bits(redMax) + redShift) > bpp)\n    return false;\n  if ((bits(greenMax) + greenShift) > bpp)\n    return false;\n  if ((bits(blueMax) + blueShift) > bpp)\n    return false;\n\n  if (((redMax << redShift) & (greenMax << greenShift)) != 0)\n    return false;\n  if (((redMax << redShift) & (blueMax << blueShift)) != 0)\n    return false;\n  if (((greenMax << greenShift) & (blueMax << blueShift)) != 0)\n    return false;\n\n  return true;\n}\n\n// Preprocessor generated, optimised methods\n\n#define INBPP 8\n#define OUTBPP 8\n#include \"PixelFormatBPP.cxx\"\n#undef OUTBPP\n#define OUTBPP 16\n#include \"PixelFormatBPP.cxx\"\n#undef OUTBPP\n#define OUTBPP 32\n#include \"PixelFormatBPP.cxx\"\n#undef OUTBPP\n#undef INBPP\n\n#define INBPP 16\n#define OUTBPP 8\n#include \"PixelFormatBPP.cxx\"\n#undef OUTBPP\n#define OUTBPP 16\n#include \"PixelFormatBPP.cxx\"\n#undef OUTBPP\n#define OUTBPP 32\n#include \"PixelFormatBPP.cxx\"\n#undef OUTBPP\n#undef INBPP\n\n#define INBPP 32\n#define OUTBPP 8\n#include \"PixelFormatBPP.cxx\"\n#undef OUTBPP\n#define OUTBPP 16\n#include \"PixelFormatBPP.cxx\"\n#undef OUTBPP\n#define OUTBPP 32\n#include \"PixelFormatBPP.cxx\"\n#undef OUTBPP\n#undef INBPP\n\n", "/* Copyright 2019 Pierre Ossman <ossman@cendio.se> for Cendio AB\n *\n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#include <stdio.h>\n\n#include <rfb/PixelFormat.h>\n#include <rfb/Exception.h>\n\nstatic void doTest(bool should_fail, int b, int d, bool e, bool t,\n                   int rm, int gm, int bm, int rs, int gs, int bs)\n{\n    rfb::PixelFormat* pf;\n\n    printf(\"PixelFormat(%d, %d, %s, %s, %d, %d, %d, %d, %d, %d): \",\n           b, d, e ? \"true\" : \"false\", t ? \"true\": \"false\",\n           rm, gm, bm, rs, gs, bs);\n\n    try {\n        pf = new rfb::PixelFormat(b, d, e, t, rm, gm, bm, rs, gs, bs);\n    } catch(rfb::Exception &e) {\n        if (should_fail)\n            printf(\"OK\");\n        else\n            printf(\"FAILED\");\n        printf(\"\\n\");\n        fflush(stdout);\n        return;\n    }\n\n    delete pf;\n\n    if (should_fail)\n        printf(\"FAILED\");\n    else\n        printf(\"OK\");\n    printf(\"\\n\");\n    fflush(stdout);\n}\n\nstatic void do888Test(bool expected, int b, int d, bool e, bool t,\n                   int rm, int gm, int bm, int rs, int gs, int bs)\n{\n    rfb::PixelFormat* pf;\n\n    printf(\"PixelFormat(%d, %d, %s, %s, %d, %d, %d, %d, %d, %d): \",\n           b, d, e ? \"true\" : \"false\", t ? \"true\": \"false\",\n           rm, gm, bm, rs, gs, bs);\n\n    pf = new rfb::PixelFormat(b, d, e, t, rm, gm, bm, rs, gs, bs);\n\n    if (pf->is888() == expected)\n        printf(\"OK\");\n    else\n        printf(\"FAILED\");\n    printf(\"\\n\");\n    fflush(stdout);\n\n    delete pf;\n}\n\nstatic void sanityTests()\n{\n    printf(\"Sanity checks:\\n\\n\");\n\n    /* Normal true color formats */\n\n    doTest(false, 32, 24, false, true, 255, 255, 255, 0, 8, 16);\n    doTest(false, 32, 24, false, true, 255, 255, 255, 24, 16, 8);\n\n    doTest(false, 16, 16, false, true, 15, 31, 15, 0, 5, 11);\n\n    doTest(false, 8, 8, false, true, 3, 7, 3, 0, 2, 5);\n\n    /* Excessive bpp */\n\n    doTest(false, 32, 16, false, true, 15, 31, 15, 0, 5, 11);\n\n    doTest(false, 16, 16, false, true, 15, 31, 15, 0, 5, 11);\n\n    doTest(false, 32, 8, false, true, 3, 7, 3, 0, 2, 5);\n\n    doTest(false, 16, 8, false, true, 3, 7, 3, 0, 2, 5);\n\n    /* Colour map */\n\n    doTest(false, 8, 8, false, false, 0, 0, 0, 0, 0, 0);\n\n    /* Invalid bpp */\n\n    doTest(true, 64, 24, false, true, 255, 255, 255, 0, 8, 16);\n\n    doTest(true, 18, 16, false, true, 15, 31, 15, 0, 5, 11);\n\n    doTest(true, 3, 3, false, true, 1, 1, 1, 0, 1, 2);\n\n    /* Invalid depth */\n\n    doTest(true, 16, 24, false, true, 15, 31, 15, 0, 5, 11);\n\n    doTest(true, 8, 24, false, true, 3, 7, 3, 0, 2, 5);\n    doTest(true, 8, 16, false, true, 3, 7, 3, 0, 2, 5);\n\n    doTest(true, 32, 24, false, false, 0, 0, 0, 0, 0, 0);\n\n    /* Invalid max values */\n\n    doTest(true, 32, 24, false, true, 254, 255, 255, 0, 8, 16);\n    doTest(true, 32, 24, false, true, 255, 253, 255, 0, 8, 16);\n    doTest(true, 32, 24, false, true, 255, 255, 252, 0, 8, 16);\n\n    doTest(true, 32, 24, false, true, 511, 127, 127, 0, 16, 20);\n    doTest(true, 32, 24, false, true, 127, 511, 127, 0, 4, 20);\n    doTest(true, 32, 24, false, true, 127, 127, 511, 0, 4, 8);\n\n    /* Insufficient depth */\n\n    doTest(true, 32, 16, false, true, 255, 255, 255, 0, 8, 16);\n\n    /* Invalid shift values */\n\n    doTest(true, 32, 24, false, true, 255, 255, 255, 25, 8, 16);\n    doTest(true, 32, 24, false, true, 255, 255, 255, 0, 25, 16);\n    doTest(true, 32, 24, false, true, 255, 255, 255, 0, 8, 25);\n\n    /* Overlapping channels */\n\n    doTest(true, 32, 24, false, true, 255, 255, 255, 0, 7, 16);\n    doTest(true, 32, 24, false, true, 255, 255, 255, 0, 8, 15);\n    doTest(true, 32, 24, false, true, 255, 255, 255, 0, 16, 7);\n\n    printf(\"\\n\");\n}\n\nvoid is888Tests()\n{\n    printf(\"Simple format detection:\\n\\n\");\n\n    /* Positive cases */\n\n    do888Test(true, 32, 24, false, true, 255, 255, 255, 0, 8, 16);\n    do888Test(true, 32, 24, false, true, 255, 255, 255, 24, 16, 8);\n    do888Test(true, 32, 24, false, true, 255, 255, 255, 24, 8, 0);\n\n    /* Low depth */\n\n    do888Test(false, 32, 16, false, true, 15, 31, 15, 0, 8, 16);\n    do888Test(false, 32, 8, false, true, 3, 7, 3, 0, 8, 16);\n\n    /* Low bpp and depth */\n\n    do888Test(false, 16, 16, false, true, 15, 31, 15, 0, 5, 11);\n    do888Test(false, 8, 8, false, true, 3, 7, 3, 0, 2, 5);\n\n    /* Colour map */\n\n    do888Test(false, 8, 8, false, false, 0, 0, 0, 0, 0, 0);\n\n    printf(\"\\n\");\n}\n\nint main(int argc, char** argv)\n{\n    sanityTests();\n    is888Tests();\n\n    return 0;\n}\n"], "fixing_code": ["/* Copyright (C) 2002-2005 RealVNC Ltd.  All Rights Reserved.\n * Copyright (C) 2011 D. R. Commander.  All Rights Reserved.\n * Copyright 2009-2014 Pierre Ossman for Cendio AB\n * \n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n * \n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n#include <assert.h>\n#include <stdio.h>\n#include <stdint.h>\n#include <string.h>\n#include <rdr/InStream.h>\n#include <rdr/OutStream.h>\n#include <rfb/Exception.h>\n#include <rfb/PixelFormat.h>\n#include <rfb/util.h>\n\n#ifdef _WIN32\n#define strcasecmp _stricmp\n#endif\n\nusing namespace rfb;\n\nrdr::U8 PixelFormat::upconvTable[256*8];\nrdr::U8 PixelFormat::downconvTable[256*8];\n\nclass PixelFormat::Init {\npublic:\n  Init();\n};\n\nPixelFormat::Init PixelFormat::_init;\n\n\nPixelFormat::Init::Init()\n{\n  int bits;\n\n  // Shifting bits is almost perfect, but not quite. And\n  // a lookup table is still quicker when there is a large\n  // difference between the source and destination depth.\n\n  for (bits = 1;bits <= 8;bits++) {\n    int i, maxVal;\n    rdr::U8 *subUpTable;\n    rdr::U8 *subDownTable;\n\n    maxVal = (1 << bits) - 1;\n    subUpTable = &upconvTable[(bits-1)*256];\n    subDownTable = &downconvTable[(bits-1)*256];\n\n    for (i = 0;i <= maxVal;i++)\n      subUpTable[i] = i * 255 / maxVal;\n\n    // Duplicate the up table so that we don't have to care about\n    // the upper bits when doing a lookup\n    for (;i < 256;i += maxVal+1)\n      memcpy(&subUpTable[i], &subUpTable[0], maxVal+1);\n\n    for (i = 0;i <= 255;i++)\n      subDownTable[i] = (i * maxVal + 128) / 255;\n  }\n}\n\n\nPixelFormat::PixelFormat(int b, int d, bool e, bool t,\n                         int rm, int gm, int bm, int rs, int gs, int bs)\n  : bpp(b), depth(d), trueColour(t), bigEndian(e),\n    redMax(rm), greenMax(gm), blueMax(bm),\n    redShift(rs), greenShift(gs), blueShift(bs)\n{\n  if (!isSane())\n    throw Exception(\"invalid pixel format\");\n\n  updateState();\n}\n\nPixelFormat::PixelFormat()\n  : bpp(8), depth(8), trueColour(true), bigEndian(false),\n    redMax(7), greenMax(7), blueMax(3),\n    redShift(0), greenShift(3), blueShift(6)\n{\n  updateState();\n}\n\nbool PixelFormat::equal(const PixelFormat& other) const\n{\n  if (bpp != other.bpp || depth != other.depth)\n    return false;\n\n  if (redMax != other.redMax)\n    return false;\n  if (greenMax != other.greenMax)\n    return false;\n  if (blueMax != other.blueMax)\n    return false;\n\n  // Endianness requires more care to determine compatibility\n  if (bigEndian == other.bigEndian || bpp == 8) {\n    if (redShift != other.redShift)\n      return false;\n    if (greenShift != other.greenShift)\n      return false;\n    if (blueShift != other.blueShift)\n      return false;\n  } else {\n    // Has to be the same byte for each channel\n    if (redShift/8 != (3 - other.redShift/8))\n      return false;\n    if (greenShift/8 != (3 - other.greenShift/8))\n      return false;\n    if (blueShift/8 != (3 - other.blueShift/8))\n      return false;\n\n    // And the same bit offset within the byte\n    if (redShift%8 != other.redShift%8)\n      return false;\n    if (greenShift%8 != other.greenShift%8)\n      return false;\n    if (blueShift%8 != other.blueShift%8)\n      return false;\n\n    // And not cross a byte boundary\n    if (redShift/8 != (redShift + redBits - 1)/8)\n      return false;\n    if (greenShift/8 != (greenShift + greenBits - 1)/8)\n      return false;\n    if (blueShift/8 != (blueShift + blueBits - 1)/8)\n      return false;\n  }\n\n  return true;\n}\n\nvoid PixelFormat::read(rdr::InStream* is)\n{\n  bpp = is->readU8();\n  depth = is->readU8();\n  bigEndian = is->readU8();\n  trueColour = is->readU8();\n  redMax = is->readU16();\n  greenMax = is->readU16();\n  blueMax = is->readU16();\n  redShift = is->readU8();\n  greenShift = is->readU8();\n  blueShift = is->readU8();\n  is->skip(3);\n\n  // We have no real support for colour maps. If the client\n  // wants one, then we force a 8-bit true colour format and\n  // pretend it's a colour map.\n  if (!trueColour) {\n    redMax = 7;\n    greenMax = 7;\n    blueMax = 3;\n    redShift = 0;\n    greenShift = 3;\n    blueShift = 6;\n  }\n\n  if (!isSane())\n    throw Exception(\"invalid pixel format\");\n\n  updateState();\n}\n\nvoid PixelFormat::write(rdr::OutStream* os) const\n{\n  os->writeU8(bpp);\n  os->writeU8(depth);\n  os->writeU8(bigEndian);\n  os->writeU8(trueColour);\n  os->writeU16(redMax);\n  os->writeU16(greenMax);\n  os->writeU16(blueMax);\n  os->writeU8(redShift);\n  os->writeU8(greenShift);\n  os->writeU8(blueShift);\n  os->pad(3);\n}\n\n\nbool PixelFormat::is888(void) const\n{\n  if (!trueColour)\n    return false;\n  if (bpp != 32)\n    return false;\n  if (depth != 24)\n    return false;\n  if (redMax != 255)\n    return false;\n  if (greenMax != 255)\n    return false;\n  if (blueMax != 255)\n    return false;\n  if ((redShift & 0x7) != 0)\n    return false;\n  if ((greenShift & 0x7) != 0)\n    return false;\n  if ((blueShift & 0x7) != 0)\n    return false;\n\n  return true;\n}\n\n\nbool PixelFormat::isBigEndian(void) const\n{\n  return bigEndian;\n}\n\n\nbool PixelFormat::isLittleEndian(void) const\n{\n  return ! bigEndian;\n}\n\n\nvoid PixelFormat::bufferFromRGB(rdr::U8 *dst, const rdr::U8* src, int pixels) const\n{\n  bufferFromRGB(dst, src, pixels, pixels, 1);\n}\n\nvoid PixelFormat::bufferFromRGB(rdr::U8 *dst, const rdr::U8* src,\n                                int w, int stride, int h) const\n{\n  if (is888()) {\n    // Optimised common case\n    rdr::U8 *r, *g, *b, *x;\n\n    if (bigEndian) {\n      r = dst + (24 - redShift)/8;\n      g = dst + (24 - greenShift)/8;\n      b = dst + (24 - blueShift)/8;\n      x = dst + (24 - (48 - redShift - greenShift - blueShift))/8;\n    } else {\n      r = dst + redShift/8;\n      g = dst + greenShift/8;\n      b = dst + blueShift/8;\n      x = dst + (48 - redShift - greenShift - blueShift)/8;\n    }\n\n    int dstPad = (stride - w) * 4;\n    while (h--) {\n      int w_ = w;\n      while (w_--) {\n        *r = *(src++);\n        *g = *(src++);\n        *b = *(src++);\n        *x = 0;\n        r += 4;\n        g += 4;\n        b += 4;\n        x += 4;\n      }\n      r += dstPad;\n      g += dstPad;\n      b += dstPad;\n      x += dstPad;\n    }\n  } else {\n    // Generic code\n    int dstPad = (stride - w) * bpp/8;\n    while (h--) {\n      int w_ = w;\n      while (w_--) {\n        Pixel p;\n        rdr::U8 r, g, b;\n\n        r = *(src++);\n        g = *(src++);\n        b = *(src++);\n\n        p = pixelFromRGB(r, g, b);\n\n        bufferFromPixel(dst, p);\n        dst += bpp/8;\n      }\n      dst += dstPad;\n    }\n  }\n}\n\n\nvoid PixelFormat::rgbFromBuffer(rdr::U8* dst, const rdr::U8* src, int pixels) const\n{\n  rgbFromBuffer(dst, src, pixels, pixels, 1);\n}\n\n\nvoid PixelFormat::rgbFromBuffer(rdr::U8* dst, const rdr::U8* src,\n                                int w, int stride, int h) const\n{\n  if (is888()) {\n    // Optimised common case\n    const rdr::U8 *r, *g, *b;\n\n    if (bigEndian) {\n      r = src + (24 - redShift)/8;\n      g = src + (24 - greenShift)/8;\n      b = src + (24 - blueShift)/8;\n    } else {\n      r = src + redShift/8;\n      g = src + greenShift/8;\n      b = src + blueShift/8;\n    }\n\n    int srcPad = (stride - w) * 4;\n    while (h--) {\n      int w_ = w;\n      while (w_--) {\n        *(dst++) = *r;\n        *(dst++) = *g;\n        *(dst++) = *b;\n        r += 4;\n        g += 4;\n        b += 4;\n      }\n      r += srcPad;\n      g += srcPad;\n      b += srcPad;\n    }\n  } else {\n    // Generic code\n    int srcPad = (stride - w) * bpp/8;\n    while (h--) {\n      int w_ = w;\n      while (w_--) {\n        Pixel p;\n        rdr::U8 r, g, b;\n\n        p = pixelFromBuffer(src);\n\n        rgbFromPixel(p, &r, &g, &b);\n\n        *(dst++) = r;\n        *(dst++) = g;\n        *(dst++) = b;\n        src += bpp/8;\n      }\n      src += srcPad;\n    }\n  }\n}\n\n\nPixel PixelFormat::pixelFromPixel(const PixelFormat &srcPF, Pixel src) const\n{\n  rdr::U16 r, g, b;\n  srcPF.rgbFromPixel(src, &r, &g, &b);\n  return pixelFromRGB(r, g, b);\n}\n\n\nvoid PixelFormat::bufferFromBuffer(rdr::U8* dst, const PixelFormat &srcPF,\n                                   const rdr::U8* src, int pixels) const\n{\n  bufferFromBuffer(dst, srcPF, src, pixels, 1, pixels, pixels);\n}\n\n#define IS_ALIGNED(v, a) (((intptr_t)v & (a-1)) == 0)\n\nvoid PixelFormat::bufferFromBuffer(rdr::U8* dst, const PixelFormat &srcPF,\n                                   const rdr::U8* src, int w, int h,\n                                   int dstStride, int srcStride) const\n{\n  if (equal(srcPF)) {\n    // Trivial case\n    while (h--) {\n      memcpy(dst, src, w * bpp/8);\n      dst += dstStride * bpp/8;\n      src += srcStride * srcPF.bpp/8;\n    }\n  } else if (is888() && srcPF.is888()) {\n    // Optimised common case A: byte shuffling (e.g. endian conversion)\n    rdr::U8 *d[4], *s[4];\n    int dstPad, srcPad;\n\n    if (bigEndian) {\n      s[0] = dst + (24 - redShift)/8;\n      s[1] = dst + (24 - greenShift)/8;\n      s[2] = dst + (24 - blueShift)/8;\n      s[3] = dst + (24 - (48 - redShift - greenShift - blueShift))/8;\n    } else {\n      s[0] = dst + redShift/8;\n      s[1] = dst + greenShift/8;\n      s[2] = dst + blueShift/8;\n      s[3] = dst + (48 - redShift - greenShift - blueShift)/8;\n    }\n\n    if (srcPF.bigEndian) {\n      d[(24 - srcPF.redShift)/8] = s[0];\n      d[(24 - srcPF.greenShift)/8] = s[1];\n      d[(24 - srcPF.blueShift)/8] = s[2];\n      d[(24 - (48 - srcPF.redShift - srcPF.greenShift - srcPF.blueShift))/8] = s[3];\n    } else {\n      d[srcPF.redShift/8] = s[0];\n      d[srcPF.greenShift/8] = s[1];\n      d[srcPF.blueShift/8] = s[2];\n      d[(48 - srcPF.redShift - srcPF.greenShift - srcPF.blueShift)/8] = s[3];\n    }\n\n    dstPad = (dstStride - w) * 4;\n    srcPad = (srcStride - w) * 4;\n    while (h--) {\n      int w_ = w;\n      while (w_--) {\n        *d[0] = *(src++);\n        *d[1] = *(src++);\n        *d[2] = *(src++);\n        *d[3] = *(src++);\n        d[0] += 4;\n        d[1] += 4;\n        d[2] += 4;\n        d[3] += 4;\n      }\n      d[0] += dstPad;\n      d[1] += dstPad;\n      d[2] += dstPad;\n      d[3] += dstPad;\n      src += srcPad;\n    }\n  } else if (IS_ALIGNED(dst, bpp/8) && srcPF.is888()) {\n    // Optimised common case B: 888 source\n    switch (bpp) {\n    case 8:\n      directBufferFromBufferFrom888((rdr::U8*)dst, srcPF, src,\n                                    w, h, dstStride, srcStride);\n      break;\n    case 16:\n      directBufferFromBufferFrom888((rdr::U16*)dst, srcPF, src,\n                                    w, h, dstStride, srcStride);\n      break;\n    case 32:\n      directBufferFromBufferFrom888((rdr::U32*)dst, srcPF, src,\n                                    w, h, dstStride, srcStride);\n      break;\n    }\n  } else if (IS_ALIGNED(src, srcPF.bpp/8) && is888()) {\n    // Optimised common case C: 888 destination\n    switch (srcPF.bpp) {\n    case 8:\n      directBufferFromBufferTo888(dst, srcPF, (rdr::U8*)src,\n                                  w, h, dstStride, srcStride);\n      break;\n    case 16:\n      directBufferFromBufferTo888(dst, srcPF, (rdr::U16*)src,\n                                  w, h, dstStride, srcStride);\n      break;\n    case 32:\n      directBufferFromBufferTo888(dst, srcPF, (rdr::U32*)src,\n                                  w, h, dstStride, srcStride);\n      break;\n    }\n  } else {\n    // Generic code\n    int dstPad = (dstStride - w) * bpp/8;\n    int srcPad = (srcStride - w) * srcPF.bpp/8;\n    while (h--) {\n      int w_ = w;\n      while (w_--) {\n        Pixel p;\n        rdr::U8 r, g, b;\n\n        p = srcPF.pixelFromBuffer(src);\n        srcPF.rgbFromPixel(p, &r, &g, &b);\n        p = pixelFromRGB(r, g, b);\n        bufferFromPixel(dst, p);\n\n        dst += bpp/8;\n        src += srcPF.bpp/8;\n      }\n      dst += dstPad;\n      src += srcPad;\n    }\n  }\n}\n\n\nvoid PixelFormat::print(char* str, int len) const\n{\n  // Unfortunately snprintf is not widely available so we build the string up\n  // using strncat - not pretty, but should be safe against buffer overruns.\n\n  char num[20];\n  if (len < 1) return;\n  str[0] = 0;\n  strncat(str, \"depth \", len-1-strlen(str));\n  sprintf(num,\"%d\",depth);\n  strncat(str, num, len-1-strlen(str));\n  strncat(str, \" (\", len-1-strlen(str));\n  sprintf(num,\"%d\",bpp);\n  strncat(str, num, len-1-strlen(str));\n  strncat(str, \"bpp)\", len-1-strlen(str));\n  if (bpp != 8) {\n    if (bigEndian)\n      strncat(str, \" big-endian\", len-1-strlen(str));\n    else\n      strncat(str, \" little-endian\", len-1-strlen(str));\n  }\n\n  if (!trueColour) {\n    strncat(str, \" color-map\", len-1-strlen(str));\n    return;\n  }\n\n  if (blueShift == 0 && greenShift > blueShift && redShift > greenShift &&\n      blueMax  == (1 << greenShift) - 1 &&\n      greenMax == (1 << (redShift-greenShift)) - 1 &&\n      redMax   == (1 << (depth-redShift)) - 1)\n  {\n    strncat(str, \" rgb\", len-1-strlen(str));\n    sprintf(num,\"%d\",depth-redShift);\n    strncat(str, num, len-1-strlen(str));\n    sprintf(num,\"%d\",redShift-greenShift);\n    strncat(str, num, len-1-strlen(str));\n    sprintf(num,\"%d\",greenShift);\n    strncat(str, num, len-1-strlen(str));\n    return;\n  }\n\n  if (redShift == 0 && greenShift > redShift && blueShift > greenShift &&\n      redMax   == (1 << greenShift) - 1 &&\n      greenMax == (1 << (blueShift-greenShift)) - 1 &&\n      blueMax  == (1 << (depth-blueShift)) - 1)\n  {\n    strncat(str, \" bgr\", len-1-strlen(str));\n    sprintf(num,\"%d\",depth-blueShift);\n    strncat(str, num, len-1-strlen(str));\n    sprintf(num,\"%d\",blueShift-greenShift);\n    strncat(str, num, len-1-strlen(str));\n    sprintf(num,\"%d\",greenShift);\n    strncat(str, num, len-1-strlen(str));\n    return;\n  }\n\n  strncat(str, \" rgb max \", len-1-strlen(str));\n  sprintf(num,\"%d,\",redMax);\n  strncat(str, num, len-1-strlen(str));\n  sprintf(num,\"%d,\",greenMax);\n  strncat(str, num, len-1-strlen(str));\n  sprintf(num,\"%d\",blueMax);\n  strncat(str, num, len-1-strlen(str));\n  strncat(str, \" shift \", len-1-strlen(str));\n  sprintf(num,\"%d,\",redShift);\n  strncat(str, num, len-1-strlen(str));\n  sprintf(num,\"%d,\",greenShift);\n  strncat(str, num, len-1-strlen(str));\n  sprintf(num,\"%d\",blueShift);\n  strncat(str, num, len-1-strlen(str));\n}\n\n\nbool PixelFormat::parse(const char* str)\n{\n  char rgbbgr[4];\n  int bits1, bits2, bits3;\n  if (sscanf(str, \"%3s%1d%1d%1d\", rgbbgr, &bits1, &bits2, &bits3) < 4)\n    return false;\n  \n  depth = bits1 + bits2 + bits3;\n  bpp = depth <= 8 ? 8 : ((depth <= 16) ? 16 : 32);\n  trueColour = true;\n  rdr::U32 endianTest = 1;\n  bigEndian = (*(rdr::U8*)&endianTest == 0);\n\n  greenShift = bits3;\n  greenMax = (1 << bits2) - 1;\n\n  if (strcasecmp(rgbbgr, \"bgr\") == 0) {\n    redShift = 0;\n    redMax = (1 << bits3) - 1;\n    blueShift = bits3 + bits2;\n    blueMax = (1 << bits1) - 1;\n  } else if (strcasecmp(rgbbgr, \"rgb\") == 0) {\n    blueShift = 0;\n    blueMax = (1 << bits3) - 1;\n    redShift = bits3 + bits2;\n    redMax = (1 << bits1) - 1;\n  } else {\n    return false;\n  }\n\n  assert(isSane());\n\n  updateState();\n\n  return true;\n}\n\n\nstatic int bits(rdr::U16 value)\n{\n  int bits;\n\n  bits = 16;\n\n  if (!(value & 0xff00)) {\n    bits -= 8;\n    value <<= 8;\n  }\n  if (!(value & 0xf000)) {\n    bits -= 4;\n    value <<= 4;\n  }\n  if (!(value & 0xc000)) {\n    bits -= 2;\n    value <<= 2;\n  }\n  if (!(value & 0x8000)) {\n    bits -= 1;\n    value <<= 1;\n  }\n\n  return bits;\n}\n\nvoid PixelFormat::updateState(void)\n{\n  int endianTest = 1;\n\n  redBits = bits(redMax);\n  greenBits = bits(greenMax);\n  blueBits = bits(blueMax);\n\n  maxBits = redBits;\n  if (greenBits > maxBits)\n    maxBits = greenBits;\n  if (blueBits > maxBits)\n    maxBits = blueBits;\n\n  minBits = redBits;\n  if (greenBits < minBits)\n    minBits = greenBits;\n  if (blueBits < minBits)\n    minBits = blueBits;\n\n  if (((*(char*)&endianTest) == 0) != bigEndian)\n    endianMismatch = true;\n  else\n    endianMismatch = false;\n}\n\nbool PixelFormat::isSane(void)\n{\n  int totalBits;\n\n  if ((bpp != 8) && (bpp != 16) && (bpp != 32))\n    return false;\n  if (depth > bpp)\n    return false;\n\n  if (!trueColour && (depth != 8))\n    return false;\n\n  if ((redMax & (redMax + 1)) != 0)\n    return false;\n  if ((greenMax & (greenMax + 1)) != 0)\n    return false;\n  if ((blueMax & (blueMax + 1)) != 0)\n    return false;\n\n  /*\n   * We don't allow individual channels > 8 bits in order to keep our\n   * conversions simple.\n   */\n  if (redMax >= (1 << 8))\n    return false;\n  if (greenMax >= (1 << 8))\n    return false;\n  if (blueMax >= (1 << 8))\n    return false;\n\n  totalBits = bits(redMax) + bits(greenMax) + bits(blueMax);\n  if (totalBits > depth)\n    return false;\n\n  if ((bits(redMax) + redShift) > bpp)\n    return false;\n  if ((bits(greenMax) + greenShift) > bpp)\n    return false;\n  if ((bits(blueMax) + blueShift) > bpp)\n    return false;\n\n  if (((redMax << redShift) & (greenMax << greenShift)) != 0)\n    return false;\n  if (((redMax << redShift) & (blueMax << blueShift)) != 0)\n    return false;\n  if (((greenMax << greenShift) & (blueMax << blueShift)) != 0)\n    return false;\n\n  return true;\n}\n\n// Preprocessor generated, optimised methods\n\n#define INBPP 8\n#define OUTBPP 8\n#include \"PixelFormatBPP.cxx\"\n#undef OUTBPP\n#define OUTBPP 16\n#include \"PixelFormatBPP.cxx\"\n#undef OUTBPP\n#define OUTBPP 32\n#include \"PixelFormatBPP.cxx\"\n#undef OUTBPP\n#undef INBPP\n\n#define INBPP 16\n#define OUTBPP 8\n#include \"PixelFormatBPP.cxx\"\n#undef OUTBPP\n#define OUTBPP 16\n#include \"PixelFormatBPP.cxx\"\n#undef OUTBPP\n#define OUTBPP 32\n#include \"PixelFormatBPP.cxx\"\n#undef OUTBPP\n#undef INBPP\n\n#define INBPP 32\n#define OUTBPP 8\n#include \"PixelFormatBPP.cxx\"\n#undef OUTBPP\n#define OUTBPP 16\n#include \"PixelFormatBPP.cxx\"\n#undef OUTBPP\n#define OUTBPP 32\n#include \"PixelFormatBPP.cxx\"\n#undef OUTBPP\n#undef INBPP\n\n", "/* Copyright 2019 Pierre Ossman <ossman@cendio.se> for Cendio AB\n *\n * This is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 2 of the License, or\n * (at your option) any later version.\n *\n * This software is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this software; if not, write to the Free Software\n * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307,\n * USA.\n */\n\n#include <stdio.h>\n\n#include <rfb/PixelFormat.h>\n#include <rfb/Exception.h>\n\nstatic void doTest(bool should_fail, int b, int d, bool e, bool t,\n                   int rm, int gm, int bm, int rs, int gs, int bs)\n{\n    rfb::PixelFormat* pf;\n\n    printf(\"PixelFormat(%d, %d, %s, %s, %d, %d, %d, %d, %d, %d): \",\n           b, d, e ? \"true\" : \"false\", t ? \"true\": \"false\",\n           rm, gm, bm, rs, gs, bs);\n\n    try {\n        pf = new rfb::PixelFormat(b, d, e, t, rm, gm, bm, rs, gs, bs);\n    } catch(rfb::Exception &e) {\n        if (should_fail)\n            printf(\"OK\");\n        else\n            printf(\"FAILED\");\n        printf(\"\\n\");\n        fflush(stdout);\n        return;\n    }\n\n    delete pf;\n\n    if (should_fail)\n        printf(\"FAILED\");\n    else\n        printf(\"OK\");\n    printf(\"\\n\");\n    fflush(stdout);\n}\n\nstatic void do888Test(bool expected, int b, int d, bool e, bool t,\n                   int rm, int gm, int bm, int rs, int gs, int bs)\n{\n    rfb::PixelFormat* pf;\n\n    printf(\"PixelFormat(%d, %d, %s, %s, %d, %d, %d, %d, %d, %d): \",\n           b, d, e ? \"true\" : \"false\", t ? \"true\": \"false\",\n           rm, gm, bm, rs, gs, bs);\n\n    pf = new rfb::PixelFormat(b, d, e, t, rm, gm, bm, rs, gs, bs);\n\n    if (pf->is888() == expected)\n        printf(\"OK\");\n    else\n        printf(\"FAILED\");\n    printf(\"\\n\");\n    fflush(stdout);\n\n    delete pf;\n}\n\nstatic void sanityTests()\n{\n    printf(\"Sanity checks:\\n\\n\");\n\n    /* Normal true color formats */\n\n    doTest(false, 32, 24, false, true, 255, 255, 255, 0, 8, 16);\n    doTest(false, 32, 24, false, true, 255, 255, 255, 24, 16, 8);\n\n    doTest(false, 16, 16, false, true, 15, 31, 15, 0, 5, 11);\n\n    doTest(false, 8, 8, false, true, 3, 7, 3, 0, 2, 5);\n\n    /* Excessive bpp */\n\n    doTest(false, 32, 16, false, true, 15, 31, 15, 0, 5, 11);\n\n    doTest(false, 16, 16, false, true, 15, 31, 15, 0, 5, 11);\n\n    doTest(false, 32, 8, false, true, 3, 7, 3, 0, 2, 5);\n\n    doTest(false, 16, 8, false, true, 3, 7, 3, 0, 2, 5);\n\n    /* Colour map */\n\n    doTest(false, 8, 8, false, false, 0, 0, 0, 0, 0, 0);\n\n    /* Invalid bpp */\n\n    doTest(true, 64, 24, false, true, 255, 255, 255, 0, 8, 16);\n\n    doTest(true, 18, 16, false, true, 15, 31, 15, 0, 5, 11);\n\n    doTest(true, 3, 3, false, true, 1, 1, 1, 0, 1, 2);\n\n    /* Invalid depth */\n\n    doTest(true, 16, 24, false, true, 15, 31, 15, 0, 5, 11);\n\n    doTest(true, 8, 24, false, true, 3, 7, 3, 0, 2, 5);\n    doTest(true, 8, 16, false, true, 3, 7, 3, 0, 2, 5);\n\n    doTest(true, 32, 24, false, false, 0, 0, 0, 0, 0, 0);\n\n    /* Invalid max values */\n\n    doTest(true, 32, 24, false, true, 254, 255, 255, 0, 8, 16);\n    doTest(true, 32, 24, false, true, 255, 253, 255, 0, 8, 16);\n    doTest(true, 32, 24, false, true, 255, 255, 252, 0, 8, 16);\n\n    doTest(true, 32, 24, false, true, 511, 127, 127, 0, 16, 20);\n    doTest(true, 32, 24, false, true, 127, 511, 127, 0, 4, 20);\n    doTest(true, 32, 24, false, true, 127, 127, 511, 0, 4, 8);\n\n    /* Insufficient depth */\n\n    doTest(true, 32, 16, false, true, 255, 255, 255, 0, 8, 16);\n\n    /* Invalid shift values */\n\n    doTest(true, 32, 24, false, true, 255, 255, 255, 25, 8, 16);\n    doTest(true, 32, 24, false, true, 255, 255, 255, 0, 25, 16);\n    doTest(true, 32, 24, false, true, 255, 255, 255, 0, 8, 25);\n\n    /* Overlapping channels */\n\n    doTest(true, 32, 24, false, true, 255, 255, 255, 0, 7, 16);\n    doTest(true, 32, 24, false, true, 255, 255, 255, 0, 8, 15);\n    doTest(true, 32, 24, false, true, 255, 255, 255, 0, 16, 7);\n\n    printf(\"\\n\");\n}\n\nvoid is888Tests()\n{\n    printf(\"Simple format detection:\\n\\n\");\n\n    /* Positive cases */\n\n    do888Test(true, 32, 24, false, true, 255, 255, 255, 0, 8, 16);\n    do888Test(true, 32, 24, false, true, 255, 255, 255, 24, 16, 8);\n    do888Test(true, 32, 24, false, true, 255, 255, 255, 24, 8, 0);\n\n    /* Low depth */\n\n    do888Test(false, 32, 16, false, true, 15, 31, 15, 0, 8, 16);\n    do888Test(false, 32, 8, false, true, 3, 7, 3, 0, 8, 16);\n\n    /* Low bpp and depth */\n\n    do888Test(false, 16, 16, false, true, 15, 31, 15, 0, 5, 11);\n    do888Test(false, 8, 8, false, true, 3, 7, 3, 0, 2, 5);\n\n    /* Colour map */\n\n    do888Test(false, 8, 8, false, false, 0, 0, 0, 0, 0, 0);\n\n    /* Odd shifts */\n\n    do888Test(false, 32, 24, false, true, 255, 255, 255, 0, 8, 18);\n    do888Test(false, 32, 24, false, true, 255, 255, 255, 0, 11, 24);\n    do888Test(false, 32, 24, false, true, 255, 255, 255, 4, 16, 24);\n\n    printf(\"\\n\");\n}\n\nint main(int argc, char** argv)\n{\n    sanityTests();\n    is888Tests();\n\n    return 0;\n}\n"], "filenames": ["common/rfb/PixelFormat.cxx", "tests/unit/pixelformat.cxx"], "buggy_code_start_loc": [208, 172], "buggy_code_end_loc": [208, 172], "fixing_code_start_loc": [209, 173], "fixing_code_end_loc": [215, 179], "type": "CWE-754", "message": "TigerVNC version prior to 1.10.1 is vulnerable to stack buffer overflow, which could be triggered from CMsgReader::readSetCursor. This vulnerability occurs due to insufficient sanitization of PixelFormat. Since remote attacker can choose offset from start of the buffer to start writing his values, exploitation of this vulnerability could potentially result into remote code execution. This attack appear to be exploitable via network connectivity.", "other": {"cve": {"id": "CVE-2019-15695", "sourceIdentifier": "vulnerability@kaspersky.com", "published": "2019-12-26T16:15:10.793", "lastModified": "2020-10-16T20:00:16.167", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "TigerVNC version prior to 1.10.1 is vulnerable to stack buffer overflow, which could be triggered from CMsgReader::readSetCursor. This vulnerability occurs due to insufficient sanitization of PixelFormat. Since remote attacker can choose offset from start of the buffer to start writing his values, exploitation of this vulnerability could potentially result into remote code execution. This attack appear to be exploitable via network connectivity."}, {"lang": "es", "value": "TigerVNC versi\u00f3n anterior a 1.10.1, es vulnerable al desbordamiento de b\u00fafer de pila, que podr\u00eda ser activada desde la funci\u00f3n CMsgReader::readSetCursor. Esta vulnerabilidad se presenta debido al saneamiento insuficiente de PixelFormat. Dado que el atacante remoto puede elegir el desplazamiento desde el arranque del b\u00fafer para comenzar a escribir sus valores, la explotaci\u00f3n de esta vulnerabilidad podr\u00eda resultar potencialmente en una ejecuci\u00f3n de c\u00f3digo remota. Este ataque parece ser explotable a trav\u00e9s de la conectividad de red."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "HIGH", "userInteraction": "NONE", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 7.2, "baseSeverity": "HIGH"}, "exploitabilityScore": 1.2, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:L/Au:S/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "LOW", "authentication": "SINGLE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.5}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.0, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": false}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-754"}, {"lang": "en", "value": "CWE-787"}]}, {"source": "vulnerability@kaspersky.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-121"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:tigervnc:tigervnc:*:*:*:*:*:*:*:*", "versionEndExcluding": "1.10.1", "matchCriteriaId": "5DB31840-DC35-40A5-8126-FF5FDD81EAD7"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2020-01/msg00039.html", "source": "vulnerability@kaspersky.com", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/CendioOssman/tigervnc/commit/05e28490873a861379c943bf616614b78b558b89", "source": "vulnerability@kaspersky.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/TigerVNC/tigervnc/releases/tag/v1.10.1", "source": "vulnerability@kaspersky.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://www.openwall.com/lists/oss-security/2019/12/20/2", "source": "vulnerability@kaspersky.com", "tags": ["Exploit", "Mailing List", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/CendioOssman/tigervnc/commit/05e28490873a861379c943bf616614b78b558b89"}}