{"buggy_code": ["/* -*- C++ -*-\n * File: libraw_const.h\n * Copyright 2008-2019 LibRaw LLC (info@libraw.org)\n * Created: Sat Mar  8 , 2008\n * LibRaw error codes\nLibRaw is free software; you can redistribute it and/or modify\nit under the terms of the one of two licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n */\n\n#ifndef _LIBRAW_ERRORS_H\n#define _LIBRAW_ERRORS_H\n\n#define LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD 0.75\n#define LIBRAW_DEFAULT_AUTO_BRIGHTNESS_THRESHOLD 0.01\n/* limit allocation size, default is 2Gb */\n#define LIBRAW_MAX_ALLOC_MB_DEFAULT 2048L\n\n/* Check if enough file space exists before tag read */\n#ifndef LIBRAW_NO_IOSPACE_CHECK\n#define LIBRAW_IOSPACE_CHECK\n#endif\n/* LibRaw uses own memory pool management, with LIBRAW_MSIZE (512)\nentries. It is enough for parsing/decoding non-damaged files, but\nmay overflow on specially crafted files (eg. with many string values\nlike XMP blocks.\nLIBRAW_MEMPOOL_CHECK define will result in error on pool overflow */\n#ifndef LIBRAW_NO_MEMPOOL_CHECK\n#define LIBRAW_MEMPOOL_CHECK\n#endif\n\n#define LIBRAW_MAX_METADATA_BLOCKS 1024\n#define LIBRAW_CBLACK_SIZE 4104\n#define LIBRAW_IFD_MAXCOUNT 10\n#define LIBRAW_CRXTRACKS_MAXCOUNT 16\n\n#define LIBRAW_AHD_TILE 512\n\nenum LibRaw_openbayer_patterns\n{\n  LIBRAW_OPENBAYER_RGGB = 0x94,\n  LIBRAW_OPENBAYER_BGGR = 0x16,\n  LIBRAW_OPENBAYER_GRBG = 0x61,\n  LIBRAW_OPENBAYER_GBRG = 0x49\n};\n\nenum LibRaw_dngfields_marks\n{\n  LIBRAW_DNGFM_FORWARDMATRIX = 1,\n  LIBRAW_DNGFM_ILLUMINANT = 1 << 1,\n  LIBRAW_DNGFM_COLORMATRIX = 1 << 2,\n  LIBRAW_DNGFM_CALIBRATION = 1 << 3,\n  LIBRAW_DNGFM_ANALOGBALANCE = 1 << 4,\n  LIBRAW_DNGFM_BLACK = 1 << 5,\n  LIBRAW_DNGFM_WHITE = 1 << 6,\n  LIBRAW_DNGFM_OPCODE2 = 1 << 7,\n  LIBRAW_DNGFM_LINTABLE = 1 << 8,\n  LIBRAW_DNGFM_CROPORIGIN = 1 << 9,\n  LIBRAW_DNGFM_CROPSIZE = 1 << 10,\n  LIBRAW_DNGFM_PREVIEWCS = 1 << 11,\n  LIBRAW_DNGFM_ASSHOTNEUTRAL = 1 << 12,\n  LIBRAW_DNGFM_BASELINEEXPOSURE = 1 << 13,\n  LIBRAW_DNGFM_LINEARRESPONSELIMIT = 1 << 14\n};\n\nenum LibRaw_As_Shot_WB_Applied_codes\n{\n  LIBRAW_ASWB_APPLIED = 1,\n  LIBRAW_ASWB_CANON = 2,\n  LIBRAW_ASWB_NIKON = 4,\n  LIBRAW_ASWB_NIKON_SRAW = 8,\n  LIBRAW_ASWB_PENTAX = 16\n};\n\nenum LibRaw_whitebalance_code\n{\n  /*\n      EXIF light sources\n      12 = FL-D; Daylight fluorescent (D 5700K \u2013 7100K) (F1,F5)\n      13 = FL-N; Day white fluorescent (N 4600K \u2013 5400K) (F7,F8)\n      14 = FL-W; Cool white fluorescent (W 3900K \u2013 4500K) (F2,F6, office, store,\n     warehouse) 15 = FL-WW; White fluorescent (WW 3200K \u2013 3700K) (F3,\n     residential) 16 = FL-L; Soft/Warm white fluorescent (L 2600K - 3250K) (F4,\n     kitchen, bath)\n  */\n  LIBRAW_WBI_Unknown = 0,\n  LIBRAW_WBI_Daylight = 1,\n  LIBRAW_WBI_Fluorescent = 2,\n  LIBRAW_WBI_Tungsten = 3,\n  LIBRAW_WBI_Flash = 4,\n  LIBRAW_WBI_FineWeather = 9,\n  LIBRAW_WBI_Cloudy = 10,\n  LIBRAW_WBI_Shade = 11,\n  LIBRAW_WBI_FL_D = 12,\n  LIBRAW_WBI_FL_N = 13,\n  LIBRAW_WBI_FL_W = 14,\n  LIBRAW_WBI_FL_WW = 15,\n  LIBRAW_WBI_FL_L = 16,\n  LIBRAW_WBI_Ill_A = 17,\n  LIBRAW_WBI_Ill_B = 18,\n  LIBRAW_WBI_Ill_C = 19,\n  LIBRAW_WBI_D55 = 20,\n  LIBRAW_WBI_D65 = 21,\n  LIBRAW_WBI_D75 = 22,\n  LIBRAW_WBI_D50 = 23,\n  LIBRAW_WBI_StudioTungsten = 24,\n  LIBRAW_WBI_Sunset = 64,\n  LIBRAW_WBI_HT_Mercury = 67,\n  LIBRAW_WBI_Auto = 82,\n  LIBRAW_WBI_Custom = 83,\n  LIBRAW_WBI_Auto1 = 85,\n  LIBRAW_WBI_Auto2 = 86,\n  LIBRAW_WBI_Auto3 = 87,\n  LIBRAW_WBI_Auto4 = 88,\n  LIBRAW_WBI_Custom1 = 90,\n  LIBRAW_WBI_Custom2 = 91,\n  LIBRAW_WBI_Custom3 = 92,\n  LIBRAW_WBI_Custom4 = 93,\n  LIBRAW_WBI_Custom5 = 94,\n  LIBRAW_WBI_Custom6 = 95,\n  LIBRAW_WBI_Measured = 100,\n  LIBRAW_WBI_Underwater = 120,\n  LIBRAW_WBI_Kelvin = 254,\n  LIBRAW_WBI_Other = 255,\n  LIBRAW_WBI_None = 0xffff\n};\n\nenum LibRaw_MultiExposure_related\n{\n  LIBRAW_ME_NONE = 0,\n  LIBRAW_ME_SIMPLE = 1,\n  LIBRAW_ME_OVERLAY = 2,\n  LIBRAW_ME_HDR = 3\n};\n\nenum LibRaw_dng_processing\n{\n  LIBRAW_DNG_NONE = 0,\n  LIBRAW_DNG_FLOAT = 1,\n  LIBRAW_DNG_LINEAR = 2,\n  LIBRAW_DNG_DEFLATE = 4,\n  LIBRAW_DNG_XTRANS = 8,\n  LIBRAW_DNG_OTHER = 16,\n  LIBRAW_DNG_8BIT = 32,\n  /*LIBRAW_DNG_LARGERANGE=64,*/ /* more than 16 bit integer */\n  LIBRAW_DNG_ALL =\n      LIBRAW_DNG_FLOAT | LIBRAW_DNG_LINEAR | LIBRAW_DNG_XTRANS |\n      LIBRAW_DNG_8BIT | LIBRAW_DNG_OTHER /* |LIBRAW_DNG_LARGERANGE */,\n  LIBRAW_DNG_DEFAULT = LIBRAW_DNG_FLOAT | LIBRAW_DNG_LINEAR |\n                       LIBRAW_DNG_DEFLATE | LIBRAW_DNG_8BIT\n};\n\nenum LibRaw_runtime_capabilities\n{\n  LIBRAW_CAPS_RAWSPEED = 1,\n  LIBRAW_CAPS_DNGSDK = 2,\n  LIBRAW_CAPS_GPRSDK = 4,\n  LIBRAW_CAPS_UNICODEPATHS = 8\n};\n\nenum LibRaw_cameramaker_index\n{\n  LIBRAW_CAMERAMAKER_Unknown = 0,\n  LIBRAW_CAMERAMAKER_Agfa,\n  LIBRAW_CAMERAMAKER_Alcatel,\n  LIBRAW_CAMERAMAKER_Apple,\n  LIBRAW_CAMERAMAKER_Aptina,\n  LIBRAW_CAMERAMAKER_AVT,\n  LIBRAW_CAMERAMAKER_Baumer,\n  LIBRAW_CAMERAMAKER_Broadcom,\n  LIBRAW_CAMERAMAKER_Canon,\n  LIBRAW_CAMERAMAKER_Casio,\n  LIBRAW_CAMERAMAKER_CINE,\n  LIBRAW_CAMERAMAKER_Clauss,\n  LIBRAW_CAMERAMAKER_Contax,\n  LIBRAW_CAMERAMAKER_Creative,\n  LIBRAW_CAMERAMAKER_DJI,\n  LIBRAW_CAMERAMAKER_DXO,\n  LIBRAW_CAMERAMAKER_Epson,\n  LIBRAW_CAMERAMAKER_Foculus,\n  LIBRAW_CAMERAMAKER_Fujifilm,\n  LIBRAW_CAMERAMAKER_Generic,\n  LIBRAW_CAMERAMAKER_Gione,\n  LIBRAW_CAMERAMAKER_GITUP,\n  LIBRAW_CAMERAMAKER_Google,\n  LIBRAW_CAMERAMAKER_GoPro,\n  LIBRAW_CAMERAMAKER_Hasselblad,\n  LIBRAW_CAMERAMAKER_HTC,\n  LIBRAW_CAMERAMAKER_I_Mobile,\n  LIBRAW_CAMERAMAKER_Imacon,\n  LIBRAW_CAMERAMAKER_Kodak,\n  LIBRAW_CAMERAMAKER_Konica,\n  LIBRAW_CAMERAMAKER_Leaf,\n  LIBRAW_CAMERAMAKER_Leica,\n  LIBRAW_CAMERAMAKER_Lenovo,\n  LIBRAW_CAMERAMAKER_LG,\n  LIBRAW_CAMERAMAKER_Mamiya,\n  LIBRAW_CAMERAMAKER_Matrix,\n  LIBRAW_CAMERAMAKER_Meizu,\n  LIBRAW_CAMERAMAKER_Micron,\n  LIBRAW_CAMERAMAKER_Minolta,\n  LIBRAW_CAMERAMAKER_Motorola,\n  LIBRAW_CAMERAMAKER_NGM,\n  LIBRAW_CAMERAMAKER_Nikon,\n  LIBRAW_CAMERAMAKER_Nokia,\n  LIBRAW_CAMERAMAKER_Olympus,\n  LIBRAW_CAMERAMAKER_OmniVison,\n  LIBRAW_CAMERAMAKER_Panasonic,\n  LIBRAW_CAMERAMAKER_Parrot,\n  LIBRAW_CAMERAMAKER_Pentax,\n  LIBRAW_CAMERAMAKER_PhaseOne,\n  LIBRAW_CAMERAMAKER_PhotoControl,\n  LIBRAW_CAMERAMAKER_Photron,\n  LIBRAW_CAMERAMAKER_Pixelink,\n  LIBRAW_CAMERAMAKER_Polaroid,\n  LIBRAW_CAMERAMAKER_RED,\n  LIBRAW_CAMERAMAKER_Ricoh,\n  LIBRAW_CAMERAMAKER_Rollei,\n  LIBRAW_CAMERAMAKER_RoverShot,\n  LIBRAW_CAMERAMAKER_Samsung,\n  LIBRAW_CAMERAMAKER_Sigma,\n  LIBRAW_CAMERAMAKER_Sinar,\n  LIBRAW_CAMERAMAKER_SMaL,\n  LIBRAW_CAMERAMAKER_Sony,\n  LIBRAW_CAMERAMAKER_ST_Micro,\n  LIBRAW_CAMERAMAKER_THL,\n  LIBRAW_CAMERAMAKER_Xiaomi,\n  LIBRAW_CAMERAMAKER_XIAOYI,\n  LIBRAW_CAMERAMAKER_YI,\n  LIBRAW_CAMERAMAKER_Yuneec,\n  // Insert additional indexes here\n  LIBRAW_CAMERAMAKER_TheLastOne,\n};\n\nenum LibRaw_camera_mounts\n{\n  LIBRAW_MOUNT_Unknown = 0,\n  LIBRAW_MOUNT_Minolta_A = 1,\n  LIBRAW_MOUNT_Sony_E = 2,\n  LIBRAW_MOUNT_Canon_EF = 3,\n  LIBRAW_MOUNT_Canon_EF_S = 4,\n  LIBRAW_MOUNT_Canon_EF_M = 5,\n  LIBRAW_MOUNT_Nikon_F = 6,\n  LIBRAW_MOUNT_Nikon_CX = 7, /* used in 'Nikon 1' series */\n  LIBRAW_MOUNT_FT = 8,       /* original 4/3 */\n  LIBRAW_MOUNT_mFT = 9,      /* micro 4/3 */\n  LIBRAW_MOUNT_Pentax_K = 10,\n  LIBRAW_MOUNT_Pentax_Q = 11,\n  LIBRAW_MOUNT_Pentax_645 = 12,\n  LIBRAW_MOUNT_Fuji_X = 13,\n  LIBRAW_MOUNT_Leica_M = 14, /* Leica rangefinder bayonet */\n  LIBRAW_MOUNT_Leica_R = 15, /* Leica SLRs, 'R' for reflex */\n  LIBRAW_MOUNT_Leica_S = 16, /* LIBRAW_FORMAT_LeicaS 'MF' */\n  LIBRAW_MOUNT_Samsung_NX = 17,\n  LIBRAW_MOUNT_RicohModule = 18,\n  LIBRAW_MOUNT_Samsung_NX_M = 19,\n  LIBRAW_MOUNT_Leica_L = 20, /* camera mount throat, takes SL and TL lenses */\n  LIBRAW_MOUNT_Contax_N = 21,\n  LIBRAW_MOUNT_Sigma_X3F = 22,\n  LIBRAW_MOUNT_Leica_TL = 23, /* lens, mounts on 'L' throat, APS-C */\n  LIBRAW_MOUNT_Leica_SL = 24, /* lens, mounts on 'L' throat, FF */\n  LIBRAW_MOUNT_Nikon_Z = 25,\n  LIBRAW_MOUNT_Canon_RF = 26,\n  LIBRAW_MOUNT_C = 27,              /* C-mount */\n  LIBRAW_MOUNT_Fuji_GF = 50,        /* Fujifilm GFX cameras, G mount */\n  LIBRAW_MOUNT_Hasselblad_H = 51,   /* Hasselblad Hn cameras, HC & HCD lenses */\n  LIBRAW_MOUNT_Hasselblad_XCD = 52, /* Hasselblad Xn cameras, XCD lenses */\n  LIBRAW_MOUNT_Hasselblad_V = 53,\n  LIBRAW_MOUNT_Contax645 = 54,\n  LIBRAW_MOUNT_Mamiya645 = 55,\n  LIBRAW_MOUNT_Rollei_bayonet =\n      56, /* Rollei Hy-6: Leaf AFi, Sinar Hy6- models */\n  LIBRAW_MOUNT_Alpa = 57,\n  LIBRAW_MOUNT_Mamiya67 = 58, /* Mamiya RB67, RZ67 */\n  LIBRAW_MOUNT_Fuji_GX = 59,  /* Fujifilm GX680 */\n  LIBRAW_MOUNT_LF = 97,\n  LIBRAW_MOUNT_DigitalBack = 98,\n  LIBRAW_MOUNT_FixedLens = 99,\n  LIBRAW_MOUNT_IL_UM = 100 /* Interchangeable lens, mount unknown */\n};\n\nenum LibRaw_camera_formats\n{\n  LIBRAW_FORMAT_Unknown = 0,\n  LIBRAW_FORMAT_APSC = 1,\n  LIBRAW_FORMAT_FF = 2,\n  LIBRAW_FORMAT_MF = 3,\n  LIBRAW_FORMAT_APSH = 4,\n  LIBRAW_FORMAT_1INCH = 5,\n  LIBRAW_FORMAT_1div2p3INCH = 6, /* 1/2.3\" */\n  LIBRAW_FORMAT_1div1p7INCH = 7, /* 1/1.7\" */\n  LIBRAW_FORMAT_FT = 8,          /* sensor size in FT & mFT cameras */\n  LIBRAW_FORMAT_CROP645 = 9,     /* 44x33mm */\n  LIBRAW_FORMAT_LeicaS = 10,     /* 'MF' Leicas */\n  LIBRAW_FORMAT_645 = 11,\n  LIBRAW_FORMAT_66 = 12,\n  LIBRAW_FORMAT_69 = 13,\n  LIBRAW_FORMAT_LF = 14,\n  LIBRAW_FORMAT_Leica_DMR = 15,\n  LIBRAW_FORMAT_67 = 16,\n  LIBRAW_FORMAT_SigmaAPSC = 17, /* DP1, DP2, SD15, SD14, SD10, SD9 */\n  LIBRAW_FORMAT_SigmaMerrill =\n      18, /* SD1,  'SD1 Merrill',  'DP1 Merrill',  'DP2 Merrill' */\n  LIBRAW_FORMAT_SigmaAPSH = 19, /* 'sd Quattro H' */\n  LIBRAW_FORMAT_3648 = 20,      /* DALSA FTF4052C (Mamiya ZD) */\n  LIBRAW_FORMAT_68 = 21         /* Fujifilm GX680 */\n};\n\nenum LibRawImageAspects\n{\n  LIBRAW_IMAGE_ASPECT_UNKNOWN = 0,\n  LIBRAW_IMAGE_ASPECT_3to2 = 1,\n  LIBRAW_IMAGE_ASPECT_1to1 = 2,\n  LIBRAW_IMAGE_ASPECT_4to3 = 3,\n  LIBRAW_IMAGE_ASPECT_16to9 = 4,\n  LIBRAW_IMAGE_ASPECT_5to4 = 5,\n  LIBRAW_IMAGE_ASPECT_OTHER = 6\n};\n\nenum LibRaw_lens_focal_types\n{\n  LIBRAW_FT_UNDEFINED = 0,\n  LIBRAW_FT_PRIME_LENS = 1,\n  LIBRAW_FT_ZOOM_LENS = 2,\n  LIBRAW_FT_ZOOM_LENS_CONSTANT_APERTURE = 3,\n  LIBRAW_FT_ZOOM_LENS_VARIABLE_APERTURE = 4\n};\n\nenum LibRaw_sony_cameratypes\n{\n  LIBRAW_SONY_DSC = 1,\n  LIBRAW_SONY_DSLR = 2,\n  LIBRAW_SONY_NEX = 3,\n  LIBRAW_SONY_SLT = 4,\n  LIBRAW_SONY_ILCE = 5,\n  LIBRAW_SONY_ILCA = 6\n};\n\nenum LibRaw_KodakSensors\n{\n  LIBRAW_Kodak_UnknownSensor = 0,\n  LIBRAW_Kodak_M1 = 1,\n  LIBRAW_Kodak_M15 = 2,\n  LIBRAW_Kodak_M16 = 3,\n  LIBRAW_Kodak_M17 = 4,\n  LIBRAW_Kodak_M2 = 5,\n  LIBRAW_Kodak_M23 = 6,\n  LIBRAW_Kodak_M24 = 7,\n  LIBRAW_Kodak_M3 = 8,\n  LIBRAW_Kodak_M5 = 9,\n  LIBRAW_Kodak_M6 = 10,\n  LIBRAW_Kodak_C14 = 11,\n  LIBRAW_Kodak_X14 = 12,\n  LIBRAW_Kodak_M11 = 13\n};\n\nenum LibRaw_HasselbladFormatCodes {\n  LIBRAW_HF_Unknown = 0,\n  LIBRAW_HF_3FR,\n  LIBRAW_HF_FFF,\n  LIBRAW_HF_Imacon,\n  LIBRAW_HF_HasselbladDNG,\n  LIBRAW_HF_AdobeDNG,\n  LIBRAW_HF_AdobeDNG_fromPhocusDNG\n};\n\nenum LibRaw_processing_options\n{\n  LIBRAW_PROCESSING_SONYARW2_NONE = 0,\n  LIBRAW_PROCESSING_SONYARW2_BASEONLY = 1,\n  LIBRAW_PROCESSING_SONYARW2_DELTAONLY = 1 << 1,\n  LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE = 1 << 2,\n  LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE = 1 << 3,\n  LIBRAW_PROCESSING_SONYARW2_ALLFLAGS =\n      LIBRAW_PROCESSING_SONYARW2_BASEONLY +\n      LIBRAW_PROCESSING_SONYARW2_DELTAONLY +\n      LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE +\n      LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE,\n  LIBRAW_PROCESSING_DP2Q_INTERPOLATERG = 1 << 4,\n  LIBRAW_PROCESSING_DP2Q_INTERPOLATEAF = 1 << 5,\n  LIBRAW_PROCESSING_PENTAX_PS_ALLFRAMES = 1 << 6,\n  LIBRAW_PROCESSING_CONVERTFLOAT_TO_INT = 1 << 7,\n  LIBRAW_PROCESSING_SRAW_NO_RGB = 1 << 8,\n  LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE = 1 << 9,\n  LIBRAW_PROCESSING_NO_ROTATE_FOR_KODAK_THUMBNAILS = 1 << 11,\n  LIBRAW_PROCESSING_USE_DNG_DEFAULT_CROP = 1 << 12,\n  LIBRAW_PROCESSING_USE_PPM16_THUMBS = 1 << 13,\n  LIBRAW_PROCESSING_SKIP_MAKERNOTES = 1 << 14,\n  LIBRAW_PROCESSING_DONT_CHECK_DNG_ILLUMINANT = 1 << 15,\n  LIBRAW_PROCESSING_DNGSDK_ZEROCOPY = 1 << 16,\n  LIBRAW_PROCESSING_ZEROFILTERS_FOR_MONOCHROMETIFFS = 1 << 17,\n  LIBRAW_PROCESSING_DNG_ADD_ENHANCED = 1 << 18,\n  LIBRAW_PROCESSING_DNG_ADD_PREVIEWS = 1 << 19,\n  LIBRAW_PROCESSING_DNG_PREFER_LARGEST_IMAGE = 1 << 20\n};\n\nenum LibRaw_decoder_flags\n{\n  LIBRAW_DECODER_HASCURVE = 1 << 4,\n  LIBRAW_DECODER_SONYARW2 = 1 << 5,\n  LIBRAW_DECODER_TRYRAWSPEED = 1 << 6,\n  LIBRAW_DECODER_OWNALLOC = 1 << 7,\n  LIBRAW_DECODER_FIXEDMAXC = 1 << 8,\n  LIBRAW_DECODER_ADOBECOPYPIXEL = 1 << 9,\n  LIBRAW_DECODER_LEGACY_WITH_MARGINS = 1 << 10,\n  LIBRAW_DECODER_3CHANNEL = 1 << 11,\n  LIBRAW_DECODER_SINAR4SHOT = 1 << 11,\n  LIBRAW_DECODER_FLATDATA = 1 << 12,\n  LIBRAW_DECODER_FLAT_BG2_SWAPPED = 1<<13,\n  LIBRAW_DECODER_NOTSET = 1 << 15\n};\n\n#define LIBRAW_XTRANS 9\n\nenum LibRaw_constructor_flags\n{\n  LIBRAW_OPTIONS_NONE = 0,\n  LIBRAW_OPIONS_NO_MEMERR_CALLBACK = 1,\n  LIBRAW_OPIONS_NO_DATAERR_CALLBACK = 1 << 1\n};\n\nenum LibRaw_warnings\n{\n  LIBRAW_WARN_NONE = 0,\n  LIBRAW_WARN_BAD_CAMERA_WB = 1 << 2,\n  LIBRAW_WARN_NO_METADATA = 1 << 3,\n  LIBRAW_WARN_NO_JPEGLIB = 1 << 4,\n  LIBRAW_WARN_NO_EMBEDDED_PROFILE = 1 << 5,\n  LIBRAW_WARN_NO_INPUT_PROFILE = 1 << 6,\n  LIBRAW_WARN_BAD_OUTPUT_PROFILE = 1 << 7,\n  LIBRAW_WARN_NO_BADPIXELMAP = 1 << 8,\n  LIBRAW_WARN_BAD_DARKFRAME_FILE = 1 << 9,\n  LIBRAW_WARN_BAD_DARKFRAME_DIM = 1 << 10,\n  LIBRAW_WARN_NO_JASPER = 1 << 11,\n  LIBRAW_WARN_RAWSPEED_PROBLEM = 1 << 12,\n  LIBRAW_WARN_RAWSPEED_UNSUPPORTED = 1 << 13,\n  LIBRAW_WARN_RAWSPEED_PROCESSED = 1 << 14,\n  LIBRAW_WARN_FALLBACK_TO_AHD = 1 << 15,\n  LIBRAW_WARN_PARSEFUJI_PROCESSED = 1 << 16,\n  LIBRAW_WARN_DNGSDK_PROCESSED = 1 << 17,\n  LIBRAW_WARN_DNG_IMAGES_REORDERED = 1 << 18\n};\n\nenum LibRaw_exceptions\n{\n  LIBRAW_EXCEPTION_NONE = 0,\n  LIBRAW_EXCEPTION_ALLOC = 1,\n  LIBRAW_EXCEPTION_DECODE_RAW = 2,\n  LIBRAW_EXCEPTION_DECODE_JPEG = 3,\n  LIBRAW_EXCEPTION_IO_EOF = 4,\n  LIBRAW_EXCEPTION_IO_CORRUPT = 5,\n  LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK = 6,\n  LIBRAW_EXCEPTION_BAD_CROP = 7,\n  LIBRAW_EXCEPTION_IO_BADFILE = 8,\n  LIBRAW_EXCEPTION_DECODE_JPEG2000 = 9,\n  LIBRAW_EXCEPTION_TOOBIG = 10,\n  LIBRAW_EXCEPTION_MEMPOOL = 11\n};\n\nenum LibRaw_progress\n{\n  LIBRAW_PROGRESS_START = 0,\n  LIBRAW_PROGRESS_OPEN = 1,\n  LIBRAW_PROGRESS_IDENTIFY = 1 << 1,\n  LIBRAW_PROGRESS_SIZE_ADJUST = 1 << 2,\n  LIBRAW_PROGRESS_LOAD_RAW = 1 << 3,\n  LIBRAW_PROGRESS_RAW2_IMAGE = 1 << 4,\n  LIBRAW_PROGRESS_REMOVE_ZEROES = 1 << 5,\n  LIBRAW_PROGRESS_BAD_PIXELS = 1 << 6,\n  LIBRAW_PROGRESS_DARK_FRAME = 1 << 7,\n  LIBRAW_PROGRESS_FOVEON_INTERPOLATE = 1 << 8,\n  LIBRAW_PROGRESS_SCALE_COLORS = 1 << 9,\n  LIBRAW_PROGRESS_PRE_INTERPOLATE = 1 << 10,\n  LIBRAW_PROGRESS_INTERPOLATE = 1 << 11,\n  LIBRAW_PROGRESS_MIX_GREEN = 1 << 12,\n  LIBRAW_PROGRESS_MEDIAN_FILTER = 1 << 13,\n  LIBRAW_PROGRESS_HIGHLIGHTS = 1 << 14,\n  LIBRAW_PROGRESS_FUJI_ROTATE = 1 << 15,\n  LIBRAW_PROGRESS_FLIP = 1 << 16,\n  LIBRAW_PROGRESS_APPLY_PROFILE = 1 << 17,\n  LIBRAW_PROGRESS_CONVERT_RGB = 1 << 18,\n  LIBRAW_PROGRESS_STRETCH = 1 << 19,\n  /* reserved */\n  LIBRAW_PROGRESS_STAGE20 = 1 << 20,\n  LIBRAW_PROGRESS_STAGE21 = 1 << 21,\n  LIBRAW_PROGRESS_STAGE22 = 1 << 22,\n  LIBRAW_PROGRESS_STAGE23 = 1 << 23,\n  LIBRAW_PROGRESS_STAGE24 = 1 << 24,\n  LIBRAW_PROGRESS_STAGE25 = 1 << 25,\n  LIBRAW_PROGRESS_STAGE26 = 1 << 26,\n  LIBRAW_PROGRESS_STAGE27 = 1 << 27,\n\n  LIBRAW_PROGRESS_THUMB_LOAD = 1 << 28,\n  LIBRAW_PROGRESS_TRESERVED1 = 1 << 29,\n  LIBRAW_PROGRESS_TRESERVED2 = 1 << 30,\n  LIBRAW_PROGRESS_TRESERVED3 = 1 << 31\n};\n#define LIBRAW_PROGRESS_THUMB_MASK 0x0fffffff\n\nenum LibRaw_errors\n{\n  LIBRAW_SUCCESS = 0,\n  LIBRAW_UNSPECIFIED_ERROR = -1,\n  LIBRAW_FILE_UNSUPPORTED = -2,\n  LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE = -3,\n  LIBRAW_OUT_OF_ORDER_CALL = -4,\n  LIBRAW_NO_THUMBNAIL = -5,\n  LIBRAW_UNSUPPORTED_THUMBNAIL = -6,\n  LIBRAW_INPUT_CLOSED = -7,\n  LIBRAW_NOT_IMPLEMENTED = -8,\n  LIBRAW_UNSUFFICIENT_MEMORY = -100007,\n  LIBRAW_DATA_ERROR = -100008,\n  LIBRAW_IO_ERROR = -100009,\n  LIBRAW_CANCELLED_BY_CALLBACK = -100010,\n  LIBRAW_BAD_CROP = -100011,\n  LIBRAW_TOO_BIG = -100012,\n  LIBRAW_MEMPOOL_OVERFLOW = -100013\n};\n\n#define LIBRAW_FATAL_ERROR(ec) ((ec) < -100000)\n\nenum LibRaw_thumbnail_formats\n{\n  LIBRAW_THUMBNAIL_UNKNOWN = 0,\n  LIBRAW_THUMBNAIL_JPEG = 1,\n  LIBRAW_THUMBNAIL_BITMAP = 2,\n  LIBRAW_THUMBNAIL_BITMAP16 = 3,\n  LIBRAW_THUMBNAIL_LAYER = 4,\n  LIBRAW_THUMBNAIL_ROLLEI = 5\n};\n\nenum LibRaw_image_formats\n{\n  LIBRAW_IMAGE_JPEG = 1,\n  LIBRAW_IMAGE_BITMAP = 2\n};\n\n#endif\n", "/* -*- C++ -*-\r\n * File: libraw_crxdec.cpp\r\n * Copyright (C) 2018-2019 Alexey Danilchenko\r\n * Copyright (C) 2019 Alex Tutubalin, LibRaw LLC\r\n *\r\n   Canon CR3 file decoder\r\n\r\nLibRaw is free software; you can redistribute it and/or modify\r\nit under the terms of the one of two licenses as you choose:\r\n\r\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\r\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\r\n\r\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\r\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\r\n\r\n */\r\n\r\n#include \"../../internal/libraw_cxx_defs.h\"\r\n\r\n#ifdef _abs\r\n#undef _abs\r\n#undef _min\r\n#undef _constrain\r\n#endif\r\n#define _abs(x) (((x) ^ ((int32_t)(x) >> 31)) - ((int32_t)(x) >> 31))\r\n#define _min(a, b) ((a) < (b) ? (a) : (b))\r\n#define _constrain(x, l, u) ((x) < (l) ? (l) : ((x) > (u) ? (u) : (x)))\r\n\r\n#if defined(__clang__) || defined(__GNUG__)\r\n#define libraw_inline inline __attribute__((always_inline))\r\n#elif defined(_MSC_VER) && _MSC_VER > 1400\r\n#define libraw_inline __forceinline\r\n#else\r\n#define libraw_inline inline\r\n#endif\r\n\r\n// this should be divisible by 4\r\n#define CRX_BUF_SIZE 0x10000\r\n#if !defined(_WIN32) || (defined (__GNUC__) && !defined(__INTRINSIC_SPECIAL__BitScanReverse))  \r\n/* __INTRINSIC_SPECIAL__BitScanReverse found in MinGW32-W64 v7.30 headers, may be there is a better solution? */\r\ntypedef uint32_t DWORD;\r\ntypedef uint8_t byte;\r\nlibraw_inline void _BitScanReverse(DWORD *Index, unsigned long Mask)\r\n{\r\n  *Index = sizeof(unsigned long) * 8 - 1 - __builtin_clzl(Mask);\r\n}\r\n#if LibRawBigEndian\r\n#define _byteswap_ulong(x) (x)\r\n#else\r\n#define _byteswap_ulong(x) __builtin_bswap32(x)\r\n#endif\r\n#endif\r\n\r\nstruct CrxBitstream\r\n{\r\n  uint8_t mdatBuf[CRX_BUF_SIZE];\r\n  uint64_t mdatSize;\r\n  uint64_t curBufOffset;\r\n  uint32_t curPos;\r\n  uint32_t curBufSize;\r\n  uint32_t bitData;\r\n  int32_t bitsLeft;\r\n  LibRaw_abstract_datastream *input;\r\n};\r\n\r\nstruct CrxBandParam\r\n{\r\n  CrxBitstream bitStream;\r\n  int16_t subbandWidth;\r\n  int16_t subbandHeight;\r\n  int32_t roundedBitsMask;\r\n  int32_t roundedBits;\r\n  int16_t curLine;\r\n  int32_t *lineBuf0;\r\n  int32_t *lineBuf1;\r\n  int32_t *lineBuf2;\r\n  int32_t sParam;\r\n  int32_t kParam;\r\n  int32_t *paramData;\r\n  int32_t *nonProgrData;\r\n  int8_t supportsPartial;\r\n};\r\n\r\nstruct CrxWaveletTransform\r\n{\r\n  int32_t *subband0Buf;\r\n  int32_t *subband1Buf;\r\n  int32_t *subband2Buf;\r\n  int32_t *subband3Buf;\r\n  int32_t *lineBuf[8];\r\n  int16_t curLine;\r\n  int16_t curH;\r\n  int8_t fltTapH;\r\n  int16_t height;\r\n  int16_t width;\r\n};\r\n\r\nstruct CrxSubband\r\n{\r\n  CrxBandParam *bandParam;\r\n  uint64_t mdatOffset;\r\n  uint8_t *bandBuf;\r\n  int32_t bandSize;\r\n  uint64_t dataSize;\r\n  int8_t supportsPartial;\r\n  int32_t quantValue;\r\n  uint16_t width;\r\n  uint16_t height;\r\n  int32_t paramK;\r\n  int64_t dataOffset;\r\n};\r\n\r\nstruct CrxPlaneComp\r\n{\r\n  byte *compBuf;\r\n  CrxSubband *subBands;\r\n  CrxWaveletTransform *waveletTransform;\r\n  int8_t compNumber;\r\n  int64_t dataOffset;\r\n  int32_t compSize;\r\n  int8_t supportsPartial;\r\n  int32_t roundedBitsMask;\r\n  int8_t tileFlag;\r\n};\r\n\r\nstruct CrxTile\r\n{\r\n  CrxPlaneComp *comps;\r\n  int8_t tileFlag;\r\n  int8_t tileNumber;\r\n  int64_t dataOffset;\r\n  int32_t tileSize;\r\n  uint16_t width;\r\n  uint16_t height;\r\n};\r\n\r\nstruct CrxImage\r\n{\r\n  uint8_t nPlanes;\r\n  uint16_t planeWidth;\r\n  uint16_t planeHeight;\r\n  uint8_t samplePrecision;\r\n  uint8_t subbandCount;\r\n  uint8_t levels;\r\n  uint8_t nBits;\r\n  uint8_t encType;\r\n  uint8_t tileCols;\r\n  uint8_t tileRows;\r\n  CrxTile *tiles;\r\n  uint64_t mdatOffset;\r\n  uint64_t mdatSize;\r\n  int16_t *outBufs[4]; // one per plane\r\n  int16_t *planeBuf;\r\n  LibRaw_abstract_datastream *input;\r\n};\r\n\r\nenum TileFlags\r\n{\r\n  E_HAS_TILES_ON_THE_RIGHT = 1,\r\n  E_HAS_TILES_ON_THE_LEFT = 2,\r\n  E_HAS_TILES_ON_THE_BOTTOM = 4,\r\n  E_HAS_TILES_ON_THE_TOP = 8\r\n};\r\n\r\nint32_t exCoefNumTbl[0x120] = {\r\n    // level 1\r\n    1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,\r\n    1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,\r\n    1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,\r\n    1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n\r\n    // level 2\r\n    1, 1, 3, 3, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 3, 2, 1, 0, 1, 0, 0, 0, 0, 0, 1,\r\n    2, 4, 4, 2, 1, 2, 1, 0, 0, 0, 0, 1, 1, 4, 3, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1,\r\n    3, 3, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 3, 2, 1, 0, 1, 0, 0, 0, 0, 0, 1, 2, 4,\r\n    4, 2, 1, 2, 1, 0, 0, 0, 0, 1, 1, 4, 3, 1, 1, 1, 1, 0, 0, 0, 0,\r\n\r\n    // level 3\r\n    1, 1, 7, 7, 1, 1, 3, 3, 1, 1, 1, 1, 1, 0, 7, 6, 1, 0, 3, 2, 1, 0, 1, 0, 1,\r\n    2, 10, 10, 2, 2, 5, 4, 2, 1, 2, 1, 1, 1, 10, 9, 1, 2, 4, 4, 2, 1, 2, 1, 1,\r\n    1, 9, 9, 1, 2, 4, 4, 2, 1, 2, 1, 1, 0, 9, 8, 1, 1, 4, 3, 1, 1, 1, 1, 1, 2,\r\n    8, 8, 2, 1, 4, 3, 1, 1, 1, 1, 1, 1, 8, 7, 1, 1, 3, 3, 1, 1, 1, 1};\r\n\r\nuint32_t JS[32] = {1,     1,     1,     1,     2,      2,      2,      2,\r\n                   4,     4,     4,     4,     8,      8,      8,      8,\r\n                   0x10,  0x10,  0x20,  0x20,  0x40,   0x40,   0x80,   0x80,\r\n                   0x100, 0x200, 0x400, 0x800, 0x1000, 0x2000, 0x4000, 0x8000};\r\n\r\nuint32_t J[32] = {0, 0, 0, 0, 1,    1,    1,    1,    2,    2,   2,\r\n                  2, 3, 3, 3, 3,    4,    4,    5,    5,    6,   6,\r\n                  7, 7, 8, 9, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};\r\n\r\nstatic inline void crxFillBuffer(CrxBitstream *bitStrm)\r\n{\r\n  if (bitStrm->curPos >= bitStrm->curBufSize && bitStrm->mdatSize)\r\n  {\r\n    bitStrm->curPos = 0;\r\n    bitStrm->curBufOffset += bitStrm->curBufSize;\r\n#ifdef LIBRAW_USE_OPENMP\r\n#pragma omp critical\r\n#endif\r\n    {\r\n#ifndef LIBRAW_USE_OPENMP\r\n      bitStrm->input->lock();\r\n#endif\r\n      bitStrm->input->seek(bitStrm->curBufOffset, SEEK_SET);\r\n      bitStrm->curBufSize = bitStrm->input->read(\r\n          bitStrm->mdatBuf, 1, _min(bitStrm->mdatSize, CRX_BUF_SIZE));\r\n#ifndef LIBRAW_USE_OPENMP\r\n      bitStrm->input->unlock();\r\n#endif\r\n      if (bitStrm->curBufSize < 1) // nothing read\r\n        throw LIBRAW_EXCEPTION_IO_EOF;\r\n      bitStrm->mdatSize -= bitStrm->curBufSize;\r\n    }\r\n  }\r\n}\r\n\r\nlibraw_inline int crxBitstreamGetZeros(CrxBitstream *bitStrm)\r\n{\r\n  uint32_t bitData = bitStrm->bitData;\r\n  uint32_t nonZeroBit = 0;\r\n  uint64_t nextData = 0;\r\n  int32_t result = 0;\r\n\r\n  if (bitStrm->bitData)\r\n  {\r\n    _BitScanReverse((DWORD *)&nonZeroBit, (DWORD)bitStrm->bitData);\r\n    result = 31 - nonZeroBit;\r\n    bitStrm->bitData <<= 32 - nonZeroBit;\r\n    bitStrm->bitsLeft -= 32 - nonZeroBit;\r\n  }\r\n  else\r\n  {\r\n    uint32_t bitsLeft = bitStrm->bitsLeft;\r\n    while (1)\r\n    {\r\n      while (bitStrm->curPos + 4 <= bitStrm->curBufSize)\r\n      {\r\n        nextData =\r\n            _byteswap_ulong(*(uint32_t *)(bitStrm->mdatBuf + bitStrm->curPos));\r\n        bitStrm->curPos += 4;\r\n        crxFillBuffer(bitStrm);\r\n        if (nextData)\r\n        {\r\n          _BitScanReverse((DWORD *)&nonZeroBit, (DWORD)nextData);\r\n          result = bitsLeft + 31 - nonZeroBit;\r\n          bitStrm->bitData = nextData << (32 - nonZeroBit);\r\n          bitStrm->bitsLeft = nonZeroBit;\r\n          return result;\r\n        }\r\n        bitsLeft += 32;\r\n      }\r\n      if (bitStrm->curBufSize < bitStrm->curPos + 1)\r\n        break; // error\r\n      nextData = bitStrm->mdatBuf[bitStrm->curPos++];\r\n      crxFillBuffer(bitStrm);\r\n      if (nextData)\r\n        break;\r\n      bitsLeft += 8;\r\n    }\r\n    _BitScanReverse((DWORD *)&nonZeroBit, (DWORD)nextData);\r\n    result = (uint32_t)(bitsLeft + 7 - nonZeroBit);\r\n    bitStrm->bitData = nextData << (32 - nonZeroBit);\r\n    bitStrm->bitsLeft = nonZeroBit;\r\n  }\r\n  return result;\r\n}\r\n\r\nlibraw_inline uint32_t crxBitstreamGetBits(CrxBitstream *bitStrm, int bits)\r\n{\r\n  int bitsLeft = bitStrm->bitsLeft;\r\n  uint32_t bitData = bitStrm->bitData;\r\n  uint32_t nextWord;\r\n  uint8_t nextByte;\r\n  uint32_t result;\r\n\r\n  if (bitsLeft < bits)\r\n  {\r\n    // get them from stream\r\n    if (bitStrm->curPos + 4 <= bitStrm->curBufSize)\r\n    {\r\n      nextWord =\r\n          _byteswap_ulong(*(uint32_t *)(bitStrm->mdatBuf + bitStrm->curPos));\r\n      bitStrm->curPos += 4;\r\n      crxFillBuffer(bitStrm);\r\n      bitStrm->bitsLeft = 32 - (bits - bitsLeft);\r\n      result = ((nextWord >> bitsLeft) | bitData) >> (32 - bits);\r\n      bitStrm->bitData = nextWord << (bits - bitsLeft);\r\n      return result;\r\n    }\r\n    // less than a word left - read byte at a time\r\n    do\r\n    {\r\n      if (bitStrm->curPos >= bitStrm->curBufSize)\r\n        break; // error\r\n      bitsLeft += 8;\r\n      nextByte = bitStrm->mdatBuf[bitStrm->curPos++];\r\n      crxFillBuffer(bitStrm);\r\n      bitData |= nextByte << (32 - bitsLeft);\r\n    } while (bitsLeft < bits);\r\n  }\r\n  result = bitData >> (32 - bits); // 32-bits\r\n  bitStrm->bitData = bitData << bits;\r\n  bitStrm->bitsLeft = bitsLeft - bits;\r\n  return result;\r\n}\r\n\r\nlibraw_inline int crxPredictKParameter(int32_t prevK, int32_t bitCode,\r\n                                       int32_t maxVal = 0)\r\n{\r\n  int32_t newKParam = prevK - (bitCode < (1 << prevK >> 1)) +\r\n                      ((bitCode >> prevK) > 2) + ((bitCode >> prevK) > 5);\r\n\r\n  return !maxVal || newKParam < maxVal ? newKParam : maxVal;\r\n}\r\n\r\nlibraw_inline void crxDecodeSymbolL1(CrxBandParam *param,\r\n                                     int32_t doMedianPrediction,\r\n                                     int32_t notEOL = 0)\r\n{\r\n  if (doMedianPrediction)\r\n  {\r\n    int32_t symb[4];\r\n\r\n    int32_t delta = param->lineBuf0[1] - param->lineBuf0[0];\r\n    symb[2] = param->lineBuf1[0];\r\n    symb[0] = symb[1] = delta + symb[2];\r\n    symb[3] = param->lineBuf0[1];\r\n\r\n    param->lineBuf1[1] =\r\n        symb[(((param->lineBuf0[0] < param->lineBuf1[0]) ^ (delta < 0)) << 1) +\r\n             ((param->lineBuf1[0] < param->lineBuf0[1]) ^ (delta < 0))];\r\n  }\r\n  else\r\n    param->lineBuf1[1] = param->lineBuf0[1];\r\n\r\n  // get next error symbol\r\n  uint32_t bitCode = crxBitstreamGetZeros(&param->bitStream);\r\n  if (bitCode >= 41)\r\n    bitCode = crxBitstreamGetBits(&param->bitStream, 21);\r\n  else if (param->kParam)\r\n    bitCode = crxBitstreamGetBits(&param->bitStream, param->kParam) |\r\n              (bitCode << param->kParam);\r\n\r\n  // add converted (+/-) error code to predicted value\r\n  param->lineBuf1[1] += -(bitCode & 1) ^ (bitCode >> 1);\r\n\r\n  // for not end of the line - use one symbol ahead to estimate next K\r\n  if (notEOL)\r\n  {\r\n    int32_t nextDelta = (param->lineBuf0[2] - param->lineBuf0[1]) << 1;\r\n    bitCode = (bitCode + _abs(nextDelta)) >> 1;\r\n    ++param->lineBuf0;\r\n  }\r\n\r\n  // update K parameter\r\n  param->kParam = crxPredictKParameter(param->kParam, bitCode, 15);\r\n\r\n  ++param->lineBuf1;\r\n}\r\n\r\nint crxDecodeLine(CrxBandParam *param)\r\n{\r\n  int length = param->subbandWidth;\r\n\r\n  param->lineBuf1[0] = param->lineBuf0[1];\r\n  for (; length > 1; --length)\r\n  {\r\n    if (param->lineBuf1[0] != param->lineBuf0[1] ||\r\n        param->lineBuf1[0] != param->lineBuf0[2])\r\n    {\r\n      crxDecodeSymbolL1(param, 1, 1);\r\n    }\r\n    else\r\n    {\r\n      int nSyms = 0;\r\n      if (crxBitstreamGetBits(&param->bitStream, 1))\r\n      {\r\n        nSyms = 1;\r\n        while (crxBitstreamGetBits(&param->bitStream, 1))\r\n        {\r\n          nSyms += JS[param->sParam];\r\n          if (nSyms > length)\r\n          {\r\n            nSyms = length;\r\n            break;\r\n          }\r\n          if (param->sParam < 31)\r\n            ++param->sParam;\r\n          if (nSyms == length)\r\n            break;\r\n        }\r\n\r\n        if (nSyms < length)\r\n        {\r\n          if (J[param->sParam])\r\n            nSyms += crxBitstreamGetBits(&param->bitStream, J[param->sParam]);\r\n          if (param->sParam > 0)\r\n            --param->sParam;\r\n          if (nSyms > length)\r\n            return -1;\r\n        }\r\n\r\n        length -= nSyms;\r\n\r\n        // copy symbol nSyms times\r\n        param->lineBuf0 += nSyms;\r\n\r\n        // copy symbol nSyms times\r\n        while (nSyms-- > 0)\r\n        {\r\n          param->lineBuf1[1] = param->lineBuf1[0];\r\n          ++param->lineBuf1;\r\n        }\r\n      }\r\n\r\n      if (length > 0)\r\n        crxDecodeSymbolL1(param, 0, (length > 1));\r\n    }\r\n  }\r\n\r\n  if (length == 1)\r\n    crxDecodeSymbolL1(param, 1, 0);\r\n\r\n  param->lineBuf1[1] = param->lineBuf1[0] + 1;\r\n\r\n  return 0;\r\n}\r\n\r\nlibraw_inline void crxDecodeSymbolL1Rounded(CrxBandParam *param,\r\n                                            int32_t doSym = 1,\r\n                                            int32_t doCode = 1)\r\n{\r\n  int32_t sym = param->lineBuf0[1];\r\n\r\n  if (doSym)\r\n  {\r\n    // calculate the next symbol gradient\r\n    int32_t symb[4];\r\n    int32_t deltaH = param->lineBuf0[1] - param->lineBuf0[0];\r\n    symb[2] = param->lineBuf1[0];\r\n    symb[0] = symb[1] = deltaH + symb[2];\r\n    symb[3] = param->lineBuf0[1];\r\n    sym =\r\n        symb[(((param->lineBuf0[0] < param->lineBuf1[0]) ^ (deltaH < 0)) << 1) +\r\n             ((param->lineBuf1[0] < param->lineBuf0[1]) ^ (deltaH < 0))];\r\n  }\r\n\r\n  uint32_t bitCode = crxBitstreamGetZeros(&param->bitStream);\r\n  if (bitCode >= 41)\r\n    bitCode = crxBitstreamGetBits(&param->bitStream, 21);\r\n  else if (param->kParam)\r\n    bitCode = crxBitstreamGetBits(&param->bitStream, param->kParam) |\r\n              (bitCode << param->kParam);\r\n  int32_t code = -(bitCode & 1) ^ (bitCode >> 1);\r\n  param->lineBuf1[1] = param->roundedBitsMask * 2 * code + (code >> 31) + sym;\r\n\r\n  if (doCode)\r\n  {\r\n    if (param->lineBuf0[2] > param->lineBuf0[1])\r\n      code = (param->lineBuf0[2] - param->lineBuf0[1] + param->roundedBitsMask -\r\n              1) >>\r\n             param->roundedBits;\r\n    else\r\n      code = -(\r\n          (param->lineBuf0[1] - param->lineBuf0[2] + param->roundedBitsMask) >>\r\n          param->roundedBits);\r\n\r\n    param->kParam = crxPredictKParameter(param->kParam,\r\n                                         (bitCode + 2 * _abs(code)) >> 1, 15);\r\n  }\r\n  else\r\n    param->kParam = crxPredictKParameter(param->kParam, bitCode, 15);\r\n\r\n  ++param->lineBuf1;\r\n}\r\n\r\nint crxDecodeLineRounded(CrxBandParam *param)\r\n{\r\n  int32_t valueReached = 0;\r\n\r\n  param->lineBuf0[0] = param->lineBuf0[1];\r\n  param->lineBuf1[0] = param->lineBuf0[1];\r\n  int32_t length = param->subbandWidth;\r\n\r\n  for (; length > 1; --length)\r\n  {\r\n    if (_abs(param->lineBuf0[2] - param->lineBuf0[1]) > param->roundedBitsMask)\r\n    {\r\n      crxDecodeSymbolL1Rounded(param);\r\n      ++param->lineBuf0;\r\n      valueReached = 1;\r\n    }\r\n    else if (valueReached || _abs(param->lineBuf0[0] - param->lineBuf1[0]) >\r\n                                 param->roundedBitsMask)\r\n    {\r\n      crxDecodeSymbolL1Rounded(param);\r\n      ++param->lineBuf0;\r\n      valueReached = 0;\r\n    }\r\n    else\r\n    {\r\n      int nSyms = 0;\r\n      if (crxBitstreamGetBits(&param->bitStream, 1))\r\n      {\r\n        nSyms = 1;\r\n        while (crxBitstreamGetBits(&param->bitStream, 1))\r\n        {\r\n          nSyms += JS[param->sParam];\r\n          if (nSyms > length)\r\n          {\r\n            nSyms = length;\r\n            break;\r\n          }\r\n          if (param->sParam < 31)\r\n            ++param->sParam;\r\n          if (nSyms == length)\r\n            break;\r\n        }\r\n        if (nSyms < length)\r\n        {\r\n          if (J[param->sParam])\r\n            nSyms += crxBitstreamGetBits(&param->bitStream, J[param->sParam]);\r\n          if (param->sParam > 0)\r\n            --param->sParam;\r\n        }\r\n        if (nSyms > length)\r\n          return -1;\r\n      }\r\n      length -= nSyms;\r\n\r\n      // copy symbol nSyms times\r\n      param->lineBuf0 += nSyms;\r\n\r\n      // copy symbol nSyms times\r\n      while (nSyms-- > 0)\r\n      {\r\n        param->lineBuf1[1] = param->lineBuf1[0];\r\n        ++param->lineBuf1;\r\n      }\r\n\r\n      if (length > 1)\r\n      {\r\n        crxDecodeSymbolL1Rounded(param, 0);\r\n        ++param->lineBuf0;\r\n        valueReached = _abs(param->lineBuf0[1] - param->lineBuf0[0]) >\r\n                       param->roundedBitsMask;\r\n      }\r\n      else if (length == 1)\r\n        crxDecodeSymbolL1Rounded(param, 0, 0);\r\n    }\r\n  }\r\n  if (length == 1)\r\n    crxDecodeSymbolL1Rounded(param, 1, 0);\r\n\r\n  param->lineBuf1[1] = param->lineBuf1[0] + 1;\r\n\r\n  return 0;\r\n}\r\n\r\nint crxDecodeLineNoRefPrevLine(CrxBandParam *param)\r\n{\r\n  int32_t i = 0;\r\n\r\n  for (; i < param->subbandWidth - 1; i++)\r\n  {\r\n    if (param->lineBuf0[i + 2] | param->lineBuf0[i + 1] | param->lineBuf1[i])\r\n    {\r\n      uint32_t bitCode = crxBitstreamGetZeros(&param->bitStream);\r\n      if (bitCode >= 41)\r\n        bitCode = crxBitstreamGetBits(&param->bitStream, 21);\r\n      else if (param->kParam)\r\n        bitCode = crxBitstreamGetBits(&param->bitStream, param->kParam) |\r\n                  (bitCode << param->kParam);\r\n      param->lineBuf1[i + 1] = -(bitCode & 1) ^ (bitCode >> 1);\r\n      param->kParam = crxPredictKParameter(param->kParam, bitCode);\r\n      if (param->lineBuf2[i + 1] - param->kParam <= 1)\r\n      {\r\n        if (param->kParam >= 15)\r\n          param->kParam = 15;\r\n      }\r\n      else\r\n        ++param->kParam;\r\n    }\r\n    else\r\n    {\r\n      int nSyms = 0;\r\n      if (crxBitstreamGetBits(&param->bitStream, 1))\r\n      {\r\n        nSyms = 1;\r\n        if (i != param->subbandWidth - 1)\r\n        {\r\n          while (crxBitstreamGetBits(&param->bitStream, 1))\r\n          {\r\n            nSyms += JS[param->sParam];\r\n            if (i + nSyms > param->subbandWidth)\r\n            {\r\n              nSyms = param->subbandWidth - i;\r\n              break;\r\n            }\r\n            if (param->sParam < 31)\r\n              ++param->sParam;\r\n            if (i + nSyms == param->subbandWidth)\r\n              break;\r\n          }\r\n          if (i + nSyms < param->subbandWidth)\r\n          {\r\n            if (J[param->sParam])\r\n              nSyms += crxBitstreamGetBits(&param->bitStream, J[param->sParam]);\r\n            if (param->sParam > 0)\r\n              --param->sParam;\r\n          }\r\n          if (i + nSyms > param->subbandWidth)\r\n            return -1;\r\n        }\r\n      }\r\n      else if (i > param->subbandWidth)\r\n        return -1;\r\n\r\n      if (nSyms > 0)\r\n      {\r\n        memset(param->lineBuf1 + i + 1, 0, nSyms * sizeof(int32_t));\r\n        memset(param->lineBuf2 + i, 0, nSyms * sizeof(int32_t));\r\n        i += nSyms;\r\n      }\r\n\r\n      if (i >= param->subbandWidth - 1)\r\n      {\r\n        if (i == param->subbandWidth - 1)\r\n        {\r\n          uint32_t bitCode = crxBitstreamGetZeros(&param->bitStream);\r\n          if (bitCode >= 41)\r\n            bitCode = crxBitstreamGetBits(&param->bitStream, 21);\r\n          else if (param->kParam)\r\n            bitCode = crxBitstreamGetBits(&param->bitStream, param->kParam) |\r\n                      (bitCode << param->kParam);\r\n          param->lineBuf1[i + 1] = -((bitCode + 1) & 1) ^ ((bitCode + 1) >> 1);\r\n          param->kParam = crxPredictKParameter(param->kParam, bitCode, 15);\r\n          param->lineBuf2[i] = param->kParam;\r\n        }\r\n        continue;\r\n      }\r\n      else\r\n      {\r\n        uint32_t bitCode = crxBitstreamGetZeros(&param->bitStream);\r\n        if (bitCode >= 41)\r\n          bitCode = crxBitstreamGetBits(&param->bitStream, 21);\r\n        else if (param->kParam)\r\n          bitCode = crxBitstreamGetBits(&param->bitStream, param->kParam) |\r\n                    (bitCode << param->kParam);\r\n        param->lineBuf1[i + 1] = -((bitCode + 1) & 1) ^ ((bitCode + 1) >> 1);\r\n        param->kParam = crxPredictKParameter(param->kParam, bitCode);\r\n        if (param->lineBuf2[i + 1] - param->kParam <= 1)\r\n        {\r\n          if (param->kParam >= 15)\r\n            param->kParam = 15;\r\n        }\r\n        else\r\n          ++param->kParam;\r\n      }\r\n    }\r\n    param->lineBuf2[i] = param->kParam;\r\n  }\r\n  if (i == param->subbandWidth - 1)\r\n  {\r\n    int32_t bitCode = crxBitstreamGetZeros(&param->bitStream);\r\n    if (bitCode >= 41)\r\n      bitCode = crxBitstreamGetBits(&param->bitStream, 21);\r\n    else if (param->kParam)\r\n      bitCode = crxBitstreamGetBits(&param->bitStream, param->kParam) |\r\n                (bitCode << param->kParam);\r\n    param->lineBuf1[i + 1] = -(bitCode & 1) ^ (bitCode >> 1);\r\n    param->kParam = crxPredictKParameter(param->kParam, bitCode, 15);\r\n    param->lineBuf2[i] = param->kParam;\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\nint crxDecodeTopLine(CrxBandParam *param)\r\n{\r\n  param->lineBuf1[0] = 0;\r\n\r\n  int32_t length = param->subbandWidth;\r\n\r\n  // read the line from bitstream\r\n  for (; length > 1; --length)\r\n  {\r\n    if (param->lineBuf1[0])\r\n      param->lineBuf1[1] = param->lineBuf1[0];\r\n    else\r\n    {\r\n      int nSyms = 0;\r\n      if (crxBitstreamGetBits(&param->bitStream, 1))\r\n      {\r\n        nSyms = 1;\r\n        while (crxBitstreamGetBits(&param->bitStream, 1))\r\n        {\r\n          nSyms += JS[param->sParam];\r\n          if (nSyms > length)\r\n          {\r\n            nSyms = length;\r\n            break;\r\n          }\r\n          if (param->sParam < 31)\r\n            ++param->sParam;\r\n          if (nSyms == length)\r\n            break;\r\n        }\r\n        if (nSyms < length)\r\n        {\r\n          if (J[param->sParam])\r\n            nSyms += crxBitstreamGetBits(&param->bitStream, J[param->sParam]);\r\n          if (param->sParam > 0)\r\n            --param->sParam;\r\n          if (nSyms > length)\r\n            return -1;\r\n        }\r\n\r\n        length -= nSyms;\r\n\r\n        // copy symbol nSyms times\r\n        while (nSyms-- > 0)\r\n        {\r\n          param->lineBuf1[1] = param->lineBuf1[0];\r\n          ++param->lineBuf1;\r\n        }\r\n\r\n        if (length <= 0)\r\n          break;\r\n      }\r\n\r\n      param->lineBuf1[1] = 0;\r\n    }\r\n\r\n    uint32_t bitCode = crxBitstreamGetZeros(&param->bitStream);\r\n    if (bitCode >= 41)\r\n      bitCode = crxBitstreamGetBits(&param->bitStream, 21);\r\n    else if (param->kParam)\r\n      bitCode = crxBitstreamGetBits(&param->bitStream, param->kParam) |\r\n                (bitCode << param->kParam);\r\n    param->lineBuf1[1] += -(bitCode & 1) ^ (bitCode >> 1);\r\n    param->kParam = crxPredictKParameter(param->kParam, bitCode, 15);\r\n    ++param->lineBuf1;\r\n  }\r\n\r\n  if (length == 1)\r\n  {\r\n    param->lineBuf1[1] = param->lineBuf1[0];\r\n    uint32_t bitCode = crxBitstreamGetZeros(&param->bitStream);\r\n    if (bitCode >= 41)\r\n      bitCode = crxBitstreamGetBits(&param->bitStream, 21);\r\n    else if (param->kParam)\r\n      bitCode = crxBitstreamGetBits(&param->bitStream, param->kParam) |\r\n                (bitCode << param->kParam);\r\n    param->lineBuf1[1] += -(bitCode & 1) ^ (bitCode >> 1);\r\n    param->kParam = crxPredictKParameter(param->kParam, bitCode, 15);\r\n    ++param->lineBuf1;\r\n  }\r\n\r\n  param->lineBuf1[1] = param->lineBuf1[0] + 1;\r\n\r\n  return 0;\r\n}\r\n\r\nint crxDecodeTopLineRounded(CrxBandParam *param)\r\n{\r\n  param->lineBuf1[0] = 0;\r\n\r\n  int32_t length = param->subbandWidth;\r\n\r\n  // read the line from bitstream\r\n  for (; length > 1; --length)\r\n  {\r\n    if (_abs(param->lineBuf1[0]) > param->roundedBitsMask)\r\n      param->lineBuf1[1] = param->lineBuf1[0];\r\n    else\r\n    {\r\n      int nSyms = 0;\r\n      if (crxBitstreamGetBits(&param->bitStream, 1))\r\n      {\r\n        nSyms = 1;\r\n        while (crxBitstreamGetBits(&param->bitStream, 1))\r\n        {\r\n          nSyms += JS[param->sParam];\r\n          if (nSyms > length)\r\n          {\r\n            nSyms = length;\r\n            break;\r\n          }\r\n          if (param->sParam < 31)\r\n            ++param->sParam;\r\n          if (nSyms == length)\r\n            break;\r\n        }\r\n        if (nSyms < length)\r\n        {\r\n          if (J[param->sParam])\r\n            nSyms += crxBitstreamGetBits(&param->bitStream, J[param->sParam]);\r\n          if (param->sParam > 0)\r\n            --param->sParam;\r\n          if (nSyms > length)\r\n            return -1;\r\n        }\r\n      }\r\n\r\n      length -= nSyms;\r\n\r\n      // copy symbol nSyms times\r\n      while (nSyms-- > 0)\r\n      {\r\n        param->lineBuf1[1] = param->lineBuf1[0];\r\n        ++param->lineBuf1;\r\n      }\r\n\r\n      if (length <= 0)\r\n        break;\r\n\r\n      param->lineBuf1[1] = 0;\r\n    }\r\n\r\n    uint32_t bitCode = crxBitstreamGetZeros(&param->bitStream);\r\n    if (bitCode >= 41)\r\n      bitCode = crxBitstreamGetBits(&param->bitStream, 21);\r\n    else if (param->kParam)\r\n      bitCode = crxBitstreamGetBits(&param->bitStream, param->kParam) |\r\n                (bitCode << param->kParam);\r\n\r\n    int32_t sVal = -(bitCode & 1) ^ (bitCode >> 1);\r\n    param->lineBuf1[1] += param->roundedBitsMask * 2 * sVal + (sVal >> 31);\r\n    param->kParam = crxPredictKParameter(param->kParam, bitCode, 15);\r\n    ++param->lineBuf1;\r\n  }\r\n\r\n  if (length == 1)\r\n  {\r\n    uint32_t bitCode = crxBitstreamGetZeros(&param->bitStream);\r\n    if (bitCode >= 41)\r\n      bitCode = crxBitstreamGetBits(&param->bitStream, 21);\r\n    else if (param->kParam)\r\n      bitCode = crxBitstreamGetBits(&param->bitStream, param->kParam) |\r\n                (bitCode << param->kParam);\r\n    int32_t sVal = -(bitCode & 1) ^ (bitCode >> 1);\r\n    param->lineBuf1[1] += param->roundedBitsMask * 2 * sVal + (sVal >> 31);\r\n    param->kParam = crxPredictKParameter(param->kParam, bitCode, 15);\r\n    ++param->lineBuf1;\r\n  }\r\n\r\n  param->lineBuf1[1] = param->lineBuf1[0] + 1;\r\n\r\n  return 0;\r\n}\r\n\r\nint crxDecodeTopLineNoRefPrevLine(CrxBandParam *param)\r\n{\r\n  param->lineBuf0[0] = 0;\r\n  param->lineBuf1[0] = 0;\r\n  int32_t length = param->subbandWidth;\r\n  for (; length > 1; --length)\r\n  {\r\n    if (param->lineBuf1[0])\r\n    {\r\n      uint32_t bitCode = crxBitstreamGetZeros(&param->bitStream);\r\n      if (bitCode >= 41)\r\n        bitCode = crxBitstreamGetBits(&param->bitStream, 21);\r\n      else if (param->kParam)\r\n        bitCode = crxBitstreamGetBits(&param->bitStream, param->kParam) |\r\n                  (bitCode << param->kParam);\r\n      param->lineBuf1[1] = -(bitCode & 1) ^ (bitCode >> 1);\r\n      param->kParam = crxPredictKParameter(param->kParam, bitCode, 15);\r\n    }\r\n    else\r\n    {\r\n      int nSyms = 0;\r\n      if (crxBitstreamGetBits(&param->bitStream, 1))\r\n      {\r\n        nSyms = 1;\r\n        while (crxBitstreamGetBits(&param->bitStream, 1))\r\n        {\r\n          nSyms += JS[param->sParam];\r\n          if (nSyms > length)\r\n          {\r\n            nSyms = length;\r\n            break;\r\n          }\r\n          if (param->sParam < 31)\r\n            ++param->sParam;\r\n          if (nSyms == length)\r\n            break;\r\n        }\r\n        if (nSyms < length)\r\n        {\r\n          if (J[param->sParam])\r\n            nSyms += crxBitstreamGetBits(&param->bitStream, J[param->sParam]);\r\n          if (param->sParam > 0)\r\n            --param->sParam;\r\n          if (nSyms > length)\r\n            return -1;\r\n        }\r\n      }\r\n\r\n      length -= nSyms;\r\n\r\n      // copy symbol nSyms times\r\n      while (nSyms-- > 0)\r\n      {\r\n        param->lineBuf2[0] = 0;\r\n        param->lineBuf1[1] = 0;\r\n        ++param->lineBuf1;\r\n        ++param->lineBuf2;\r\n      }\r\n\r\n      if (length <= 0)\r\n        break;\r\n      uint32_t bitCode = crxBitstreamGetZeros(&param->bitStream);\r\n      if (bitCode >= 41)\r\n        bitCode = crxBitstreamGetBits(&param->bitStream, 21);\r\n      else if (param->kParam)\r\n        bitCode = crxBitstreamGetBits(&param->bitStream, param->kParam) |\r\n                  (bitCode << param->kParam);\r\n      param->lineBuf1[1] = -((bitCode + 1) & 1) ^ ((bitCode + 1) >> 1);\r\n      param->kParam = crxPredictKParameter(param->kParam, bitCode, 15);\r\n    }\r\n    param->lineBuf2[0] = param->kParam;\r\n    ++param->lineBuf2;\r\n    ++param->lineBuf1;\r\n  }\r\n\r\n  if (length == 1)\r\n  {\r\n    uint32_t bitCode = crxBitstreamGetZeros(&param->bitStream);\r\n    if (bitCode >= 41)\r\n      bitCode = crxBitstreamGetBits(&param->bitStream, 21);\r\n    else if (param->kParam)\r\n      bitCode = crxBitstreamGetBits(&param->bitStream, param->kParam) |\r\n                (bitCode << param->kParam);\r\n    param->lineBuf1[1] = -(bitCode & 1) ^ (bitCode >> 1);\r\n    param->kParam = crxPredictKParameter(param->kParam, bitCode, 15);\r\n    param->lineBuf2[0] = param->kParam;\r\n    ++param->lineBuf1;\r\n  }\r\n\r\n  param->lineBuf1[1] = 0;\r\n\r\n  return 0;\r\n}\r\n\r\nint crxDecodeLine(CrxBandParam *param, uint8_t *bandBuf)\r\n{\r\n  if (!param || !bandBuf)\r\n    return -1;\r\n  if (param->curLine >= param->subbandHeight)\r\n    return -1;\r\n\r\n  if (param->curLine == 0)\r\n  {\r\n    int32_t lineLength = param->subbandWidth + 2;\r\n\r\n    param->sParam = 0;\r\n    param->kParam = 0;\r\n    if (param->supportsPartial)\r\n    {\r\n      if (param->roundedBitsMask <= 0)\r\n      {\r\n        param->lineBuf0 = (int32_t *)param->paramData;\r\n        param->lineBuf1 = param->lineBuf0 + lineLength;\r\n        int32_t *lineBuf = param->lineBuf1 + 1;\r\n        if (crxDecodeTopLine(param))\r\n          return -1;\r\n        memcpy(bandBuf, lineBuf, param->subbandWidth * sizeof(int32_t));\r\n        ++param->curLine;\r\n      }\r\n      else\r\n      {\r\n        param->roundedBits = 1;\r\n        if (param->roundedBitsMask & ~1)\r\n        {\r\n          while (param->roundedBitsMask >> param->roundedBits)\r\n            ++param->roundedBits;\r\n        }\r\n        param->lineBuf0 = (int32_t *)param->paramData;\r\n        param->lineBuf1 = param->lineBuf0 + lineLength;\r\n        int32_t *lineBuf = param->lineBuf1 + 1;\r\n        if (crxDecodeTopLineRounded(param))\r\n          return -1;\r\n        memcpy(bandBuf, lineBuf, param->subbandWidth * sizeof(int32_t));\r\n        ++param->curLine;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      param->lineBuf2 = (int32_t *)param->nonProgrData;\r\n      param->lineBuf0 = (int32_t *)param->paramData;\r\n      param->lineBuf1 = param->lineBuf0 + lineLength;\r\n      int32_t *lineBuf = param->lineBuf1 + 1;\r\n      if (crxDecodeTopLineNoRefPrevLine(param))\r\n        return -1;\r\n      memcpy(bandBuf, lineBuf, param->subbandWidth * sizeof(int32_t));\r\n      ++param->curLine;\r\n    }\r\n  }\r\n  else if (!param->supportsPartial)\r\n  {\r\n    int32_t lineLength = param->subbandWidth + 2;\r\n    param->lineBuf2 = (int32_t *)param->nonProgrData;\r\n    if (param->curLine & 1)\r\n    {\r\n      param->lineBuf1 = (int32_t *)param->paramData;\r\n      param->lineBuf0 = param->lineBuf1 + lineLength;\r\n    }\r\n    else\r\n    {\r\n      param->lineBuf0 = (int32_t *)param->paramData;\r\n      param->lineBuf1 = param->lineBuf0 + lineLength;\r\n    }\r\n    int32_t *lineBuf = param->lineBuf1 + 1;\r\n    if (crxDecodeLineNoRefPrevLine(param))\r\n      return -1;\r\n    memcpy(bandBuf, lineBuf, param->subbandWidth * sizeof(int32_t));\r\n    ++param->curLine;\r\n  }\r\n  else if (param->roundedBitsMask <= 0)\r\n  {\r\n    int32_t lineLength = param->subbandWidth + 2;\r\n    if (param->curLine & 1)\r\n    {\r\n      param->lineBuf1 = (int32_t *)param->paramData;\r\n      param->lineBuf0 = param->lineBuf1 + lineLength;\r\n    }\r\n    else\r\n    {\r\n      param->lineBuf0 = (int32_t *)param->paramData;\r\n      param->lineBuf1 = param->lineBuf0 + lineLength;\r\n    }\r\n    int32_t *lineBuf = param->lineBuf1 + 1;\r\n    if (crxDecodeLine(param))\r\n      return -1;\r\n    memcpy(bandBuf, lineBuf, param->subbandWidth * sizeof(int32_t));\r\n    ++param->curLine;\r\n  }\r\n  else\r\n  {\r\n    int32_t lineLength = param->subbandWidth + 2;\r\n    if (param->curLine & 1)\r\n    {\r\n      param->lineBuf1 = (int32_t *)param->paramData;\r\n      param->lineBuf0 = param->lineBuf1 + lineLength;\r\n    }\r\n    else\r\n    {\r\n      param->lineBuf0 = (int32_t *)param->paramData;\r\n      param->lineBuf1 = param->lineBuf0 + lineLength;\r\n    }\r\n    int32_t *lineBuf = param->lineBuf1 + 1;\r\n    if (crxDecodeLineRounded(param))\r\n      return -1;\r\n    memcpy(bandBuf, lineBuf, param->subbandWidth * sizeof(int32_t));\r\n    ++param->curLine;\r\n  }\r\n  return 0;\r\n}\r\n\r\nint crxDecodeLineWithIQuantization(CrxSubband *subband)\r\n{\r\n  int32_t q_step_tbl[6] = {0x28, 0x2D, 0x33, 0x39, 0x40, 0x48};\r\n\r\n  if (!subband->dataSize)\r\n  {\r\n    memset(subband->bandBuf, 0, subband->bandSize);\r\n    return 0;\r\n  }\r\n\r\n  if (subband->supportsPartial)\r\n  {\r\n    uint32_t bitCode = crxBitstreamGetZeros(&subband->bandParam->bitStream);\r\n    if (bitCode >= 23)\r\n      bitCode = crxBitstreamGetBits(&subband->bandParam->bitStream, 8);\r\n    else if (subband->paramK)\r\n      bitCode =\r\n          crxBitstreamGetBits(&subband->bandParam->bitStream, subband->paramK) |\r\n          (bitCode << subband->paramK);\r\n\r\n    subband->quantValue +=\r\n        -(bitCode & 1) ^ (bitCode >> 1); // converting encoded to signed integer\r\n    subband->paramK = crxPredictKParameter(subband->paramK, bitCode);\r\n    if (subband->paramK > 7)\r\n      return -1;\r\n  }\r\n  if (crxDecodeLine(subband->bandParam, subband->bandBuf))\r\n    return -1;\r\n\r\n  if (subband->width <= 0)\r\n    return 0LL;\r\n\r\n  // update subband buffers\r\n  int32_t *bandBuf = (int32_t *)subband->bandBuf;\r\n  int32_t qScale =\r\n      q_step_tbl[subband->quantValue % 6] >> (6 - subband->quantValue / 6);\r\n  if (subband->quantValue / 6 >= 6)\r\n    qScale = q_step_tbl[subband->quantValue % 6] *\r\n             (1 << (subband->quantValue / 6 + 26));\r\n\r\n  if (qScale != 1)\r\n    for (int32_t i = 0; i < subband->width; i++)\r\n      bandBuf[i] *= qScale;\r\n\r\n  return 0;\r\n}\r\n\r\nvoid crxHorizontal53(int32_t *lineBufLA, int32_t *lineBufLB,\r\n                     CrxWaveletTransform *wavelet, uint32_t tileFlag)\r\n{\r\n  int32_t *band0Buf = wavelet->subband0Buf;\r\n  int32_t *band1Buf = wavelet->subband1Buf;\r\n  int32_t *band2Buf = wavelet->subband2Buf;\r\n  int32_t *band3Buf = wavelet->subband3Buf;\r\n\r\n  if (wavelet->width <= 1)\r\n  {\r\n    lineBufLA[0] = band0Buf[0];\r\n    lineBufLB[0] = band2Buf[0];\r\n  }\r\n  else\r\n  {\r\n    if (tileFlag & E_HAS_TILES_ON_THE_LEFT)\r\n    {\r\n      lineBufLA[0] = band0Buf[0] - ((band1Buf[0] + band1Buf[1] + 2) >> 2);\r\n      lineBufLB[0] = band2Buf[0] - ((band3Buf[0] + band3Buf[1] + 2) >> 2);\r\n      ++band1Buf;\r\n      ++band3Buf;\r\n    }\r\n    else\r\n    {\r\n      lineBufLA[0] = band0Buf[0] - ((band1Buf[0] + 1) >> 1);\r\n      lineBufLB[0] = band2Buf[0] - ((band3Buf[0] + 1) >> 1);\r\n    }\r\n    ++band0Buf;\r\n    ++band2Buf;\r\n\r\n    for (int i = 0; i < wavelet->width - 3; i += 2)\r\n    {\r\n      int32_t delta = band0Buf[0] - ((band1Buf[0] + band1Buf[1] + 2) >> 2);\r\n      lineBufLA[1] = band1Buf[0] + ((delta + lineBufLA[0]) >> 1);\r\n      lineBufLA[2] = delta;\r\n\r\n      delta = band2Buf[0] - ((band3Buf[0] + band3Buf[1] + 2) >> 2);\r\n      lineBufLB[1] = band3Buf[0] + ((delta + lineBufLB[0]) >> 1);\r\n      lineBufLB[2] = delta;\r\n\r\n      ++band0Buf;\r\n      ++band1Buf;\r\n      ++band2Buf;\r\n      ++band3Buf;\r\n      lineBufLA += 2;\r\n      lineBufLB += 2;\r\n    }\r\n    if (tileFlag & E_HAS_TILES_ON_THE_RIGHT)\r\n    {\r\n      int32_t deltaA = band0Buf[0] - ((band1Buf[0] + band1Buf[1] + 2) >> 2);\r\n      lineBufLA[1] = band1Buf[0] + ((deltaA + lineBufLA[0]) >> 1);\r\n\r\n      int32_t deltaB = band2Buf[0] - ((band3Buf[0] + band3Buf[1] + 2) >> 2);\r\n      lineBufLB[1] = band3Buf[0] + ((deltaB + lineBufLB[0]) >> 1);\r\n\r\n      if (wavelet->width & 1)\r\n      {\r\n        lineBufLA[2] = deltaA;\r\n        lineBufLB[2] = deltaB;\r\n      }\r\n    }\r\n    else if (wavelet->width & 1)\r\n    {\r\n      lineBufLA[1] =\r\n          band1Buf[0] +\r\n          ((lineBufLA[0] + band0Buf[0] - ((band1Buf[0] + 1) >> 1)) >> 1);\r\n      lineBufLA[2] = band0Buf[0] - ((band1Buf[0] + 1) >> 1);\r\n\r\n      lineBufLB[1] =\r\n          band3Buf[0] +\r\n          ((lineBufLB[0] + band2Buf[0] - ((band3Buf[0] + 1) >> 1)) >> 1);\r\n      lineBufLB[2] = band2Buf[0] - ((band3Buf[0] + 1) >> 1);\r\n    }\r\n    else\r\n    {\r\n      lineBufLA[1] = lineBufLA[0] + band1Buf[0];\r\n      lineBufLB[1] = lineBufLB[0] + band3Buf[0];\r\n    }\r\n  }\r\n}\r\n\r\nint32_t *crxIdwt53FilterGetLine(CrxPlaneComp *comp, int32_t level)\r\n{\r\n  int32_t *result = comp->waveletTransform[level]\r\n                        .lineBuf[(comp->waveletTransform[level].fltTapH -\r\n                                  comp->waveletTransform[level].curH + 5) %\r\n                                     5 +\r\n                                 3];\r\n  comp->waveletTransform[level].curH--;\r\n  return result;\r\n}\r\n\r\nint crxIdwt53FilterDecode(CrxPlaneComp *comp, int32_t level)\r\n{\r\n  if (comp->waveletTransform[level].curH)\r\n    return 0;\r\n\r\n  CrxSubband *sband = comp->subBands + 3 * level;\r\n\r\n  if (comp->waveletTransform[level].height - 3 <=\r\n          comp->waveletTransform[level].curLine &&\r\n      !(comp->tileFlag & E_HAS_TILES_ON_THE_BOTTOM))\r\n  {\r\n    if (comp->waveletTransform[level].height & 1)\r\n    {\r\n      if (level)\r\n      {\r\n        if (crxIdwt53FilterDecode(comp, level - 1))\r\n          return -1;\r\n      }\r\n      else if (crxDecodeLineWithIQuantization(sband))\r\n        return -1;\r\n\r\n      if (crxDecodeLineWithIQuantization(sband + 1))\r\n        return -1;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    if (level)\r\n    {\r\n      if (crxIdwt53FilterDecode(comp, level - 1))\r\n        return -1;\r\n    }\r\n    else if (crxDecodeLineWithIQuantization(sband)) // LL band\r\n      return -1;\r\n\r\n    if (crxDecodeLineWithIQuantization(sband + 1) || // HL band\r\n        crxDecodeLineWithIQuantization(sband + 2) || // LH band\r\n        crxDecodeLineWithIQuantization(sband + 3))   // HH band\r\n      return -1;\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\nint crxIdwt53FilterTransform(CrxPlaneComp *comp, uint32_t level)\r\n{\r\n  CrxWaveletTransform *wavelet = comp->waveletTransform + level;\r\n\r\n  if (wavelet->curH)\r\n    return 0;\r\n\r\n  if (wavelet->curLine >= wavelet->height - 3)\r\n  {\r\n    if (!(comp->tileFlag & E_HAS_TILES_ON_THE_BOTTOM))\r\n    {\r\n      if (wavelet->height & 1)\r\n      {\r\n        if (level)\r\n        {\r\n          if (!wavelet[-1].curH)\r\n            if (crxIdwt53FilterTransform(comp, level - 1))\r\n              return -1;\r\n          wavelet->subband0Buf = crxIdwt53FilterGetLine(comp, level - 1);\r\n        }\r\n        int32_t *band0Buf = wavelet->subband0Buf;\r\n        int32_t *band1Buf = wavelet->subband1Buf;\r\n        int32_t *lineBufH0 = wavelet->lineBuf[wavelet->fltTapH + 3];\r\n        int32_t *lineBufH1 = wavelet->lineBuf[(wavelet->fltTapH + 1) % 5 + 3];\r\n        int32_t *lineBufH2 = wavelet->lineBuf[(wavelet->fltTapH + 2) % 5 + 3];\r\n\r\n        int32_t *lineBufL0 = wavelet->lineBuf[0];\r\n        int32_t *lineBufL1 = wavelet->lineBuf[1];\r\n        wavelet->lineBuf[1] = wavelet->lineBuf[2];\r\n        wavelet->lineBuf[2] = lineBufL1;\r\n\r\n        // process L bands\r\n        if (wavelet->width <= 1)\r\n        {\r\n          lineBufL0[0] = band0Buf[0];\r\n        }\r\n        else\r\n        {\r\n          if (comp->tileFlag & E_HAS_TILES_ON_THE_LEFT)\r\n          {\r\n            lineBufL0[0] = band0Buf[0] - ((band1Buf[0] + band1Buf[1] + 2) >> 2);\r\n            ++band1Buf;\r\n          }\r\n          else\r\n          {\r\n            lineBufL0[0] = band0Buf[0] - ((band1Buf[0] + 1) >> 1);\r\n          }\r\n          ++band0Buf;\r\n          for (int i = 0; i < wavelet->width - 3; i += 2)\r\n          {\r\n            int32_t delta =\r\n                band0Buf[0] - ((band1Buf[0] + band1Buf[1] + 2) >> 2);\r\n            lineBufL0[1] = band1Buf[0] + ((lineBufL0[0] + delta) >> 1);\r\n            lineBufL0[2] = delta;\r\n            ++band0Buf;\r\n            ++band1Buf;\r\n            lineBufL0 += 2;\r\n          }\r\n          if (comp->tileFlag & E_HAS_TILES_ON_THE_RIGHT)\r\n          {\r\n            int32_t delta =\r\n                band0Buf[0] - ((band1Buf[0] + band1Buf[1] + 2) >> 2);\r\n            lineBufL0[1] = band1Buf[0] + ((lineBufL0[0] + delta) >> 1);\r\n            if (wavelet->width & 1)\r\n              lineBufL0[2] = delta;\r\n          }\r\n          else if (wavelet->width & 1)\r\n          {\r\n            int32_t delta = band0Buf[0] - ((band1Buf[0] + 1) >> 1);\r\n            lineBufL0[1] = band1Buf[0] + ((lineBufL0[0] + delta) >> 1);\r\n            lineBufL0[2] = delta;\r\n          }\r\n          else\r\n            lineBufL0[1] = band1Buf[0] + lineBufL0[0];\r\n        }\r\n\r\n        // process H bands\r\n        lineBufL0 = wavelet->lineBuf[0];\r\n        lineBufL1 = wavelet->lineBuf[1];\r\n        for (int32_t i = 0; i < wavelet->width; i++)\r\n        {\r\n          int32_t delta = lineBufL0[i] - ((lineBufL1[i] + 1) >> 1);\r\n          lineBufH1[i] = lineBufL1[i] + ((delta + lineBufH0[i]) >> 1);\r\n          lineBufH2[i] = delta;\r\n        }\r\n        wavelet->curH += 3;\r\n        wavelet->curLine += 3;\r\n        wavelet->fltTapH = (wavelet->fltTapH + 3) % 5;\r\n      }\r\n      else\r\n      {\r\n        int32_t *lineBufL2 = wavelet->lineBuf[2];\r\n        int32_t *lineBufH0 = wavelet->lineBuf[wavelet->fltTapH + 3];\r\n        int32_t *lineBufH1 = wavelet->lineBuf[(wavelet->fltTapH + 1) % 5 + 3];\r\n        wavelet->lineBuf[1] = lineBufL2;\r\n        wavelet->lineBuf[2] = wavelet->lineBuf[1];\r\n\r\n        for (int32_t i = 0; i < wavelet->width; i++)\r\n          lineBufH1[i] = lineBufH0[i] + lineBufL2[i];\r\n\r\n        wavelet->curH += 2;\r\n        wavelet->curLine += 2;\r\n        wavelet->fltTapH = (wavelet->fltTapH + 2) % 5;\r\n      }\r\n    }\r\n  }\r\n  else\r\n  {\r\n    if (level)\r\n    {\r\n      if (!wavelet[-1].curH && crxIdwt53FilterTransform(comp, level - 1))\r\n        return -1;\r\n      wavelet->subband0Buf = crxIdwt53FilterGetLine(comp, level - 1);\r\n    }\r\n\r\n    int32_t *band0Buf = wavelet->subband0Buf;\r\n    int32_t *band1Buf = wavelet->subband1Buf;\r\n    int32_t *band2Buf = wavelet->subband2Buf;\r\n    int32_t *band3Buf = wavelet->subband3Buf;\r\n\r\n    int32_t *lineBufL0 = wavelet->lineBuf[0];\r\n    int32_t *lineBufL1 = wavelet->lineBuf[1];\r\n    int32_t *lineBufL2 = wavelet->lineBuf[2];\r\n    int32_t *lineBufH0 = wavelet->lineBuf[wavelet->fltTapH + 3];\r\n    int32_t *lineBufH1 = wavelet->lineBuf[(wavelet->fltTapH + 1) % 5 + 3];\r\n    int32_t *lineBufH2 = wavelet->lineBuf[(wavelet->fltTapH + 2) % 5 + 3];\r\n\r\n    wavelet->lineBuf[1] = wavelet->lineBuf[2];\r\n    wavelet->lineBuf[2] = lineBufL1;\r\n\r\n    // process L bands\r\n    if (wavelet->width <= 1)\r\n    {\r\n      lineBufL0[0] = band0Buf[0];\r\n      lineBufL1[0] = band2Buf[0];\r\n    }\r\n    else\r\n    {\r\n      if (comp->tileFlag & E_HAS_TILES_ON_THE_LEFT)\r\n      {\r\n        lineBufL0[0] = band0Buf[0] - ((band1Buf[0] + band1Buf[1] + 2) >> 2);\r\n        lineBufL1[0] = band2Buf[0] - ((band3Buf[0] + band3Buf[1] + 2) >> 2);\r\n        ++band1Buf;\r\n        ++band3Buf;\r\n      }\r\n      else\r\n      {\r\n        lineBufL0[0] = band0Buf[0] - ((band1Buf[0] + 1) >> 1);\r\n        lineBufL1[0] = band2Buf[0] - ((band3Buf[0] + 1) >> 1);\r\n      }\r\n      ++band0Buf;\r\n      ++band2Buf;\r\n      for (int i = 0; i < wavelet->width - 3; i += 2)\r\n      {\r\n        int32_t delta = band0Buf[0] - ((band1Buf[0] + band1Buf[1] + 2) >> 2);\r\n        lineBufL0[1] = band1Buf[0] + ((delta + lineBufL0[0]) >> 1);\r\n        lineBufL0[2] = delta;\r\n\r\n        delta = band2Buf[0] - ((band3Buf[0] + band3Buf[1] + 2) >> 2);\r\n        lineBufL1[1] = band3Buf[0] + ((delta + lineBufL1[0]) >> 1);\r\n        lineBufL1[2] = delta;\r\n\r\n        ++band0Buf;\r\n        ++band1Buf;\r\n        ++band2Buf;\r\n        ++band3Buf;\r\n        lineBufL0 += 2;\r\n        lineBufL1 += 2;\r\n      }\r\n      if (comp->tileFlag & E_HAS_TILES_ON_THE_RIGHT)\r\n      {\r\n        int32_t deltaA = band0Buf[0] - ((band1Buf[0] + band1Buf[1] + 2) >> 2);\r\n        lineBufL0[1] = band1Buf[0] + ((deltaA + lineBufL0[0]) >> 1);\r\n\r\n        int32_t deltaB = band2Buf[0] - ((band3Buf[0] + band3Buf[1] + 2) >> 2);\r\n        lineBufL1[1] = band3Buf[0] + ((deltaB + lineBufL1[0]) >> 1);\r\n\r\n        if (wavelet->width & 1)\r\n        {\r\n          lineBufL0[2] = deltaA;\r\n          lineBufL1[2] = deltaB;\r\n        }\r\n      }\r\n      else if (wavelet->width & 1)\r\n      {\r\n        int32_t delta = band0Buf[0] - ((band1Buf[0] + 1) >> 1);\r\n        lineBufL0[1] = band1Buf[0] + ((delta + lineBufL0[0]) >> 1);\r\n        lineBufL0[2] = delta;\r\n\r\n        delta = band2Buf[0] - ((band3Buf[0] + 1) >> 1);\r\n        lineBufL1[1] = band3Buf[0] + ((delta + lineBufL1[0]) >> 1);\r\n        lineBufL1[2] = delta;\r\n      }\r\n      else\r\n      {\r\n        lineBufL0[1] = lineBufL0[0] + band1Buf[0];\r\n        lineBufL1[1] = lineBufL1[0] + band3Buf[0];\r\n      }\r\n    }\r\n\r\n    // process H bands\r\n    lineBufL0 = wavelet->lineBuf[0];\r\n    lineBufL1 = wavelet->lineBuf[1];\r\n    lineBufL2 = wavelet->lineBuf[2];\r\n    for (int32_t i = 0; i < wavelet->width; i++)\r\n    {\r\n      int32_t delta = lineBufL0[i] - ((lineBufL2[i] + lineBufL1[i] + 2) >> 2);\r\n      lineBufH1[i] = lineBufL1[i] + ((delta + lineBufH0[i]) >> 1);\r\n      lineBufH2[i] = delta;\r\n    }\r\n    if (wavelet->curLine >= wavelet->height - 3 && wavelet->height & 1)\r\n    {\r\n      wavelet->curH += 3;\r\n      wavelet->curLine += 3;\r\n      wavelet->fltTapH = (wavelet->fltTapH + 3) % 5;\r\n    }\r\n    else\r\n    {\r\n      wavelet->curH += 2;\r\n      wavelet->curLine += 2;\r\n      wavelet->fltTapH = (wavelet->fltTapH + 2) % 5;\r\n    }\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\nint crxIdwt53FilterInitialize(CrxPlaneComp *comp, int32_t prevLevel)\r\n{\r\n  if (prevLevel < 0)\r\n    return 0;\r\n\r\n  for (int curLevel = 0, curBand = 0; curLevel < prevLevel + 1;\r\n       curLevel++, curBand += 3)\r\n  {\r\n    CrxWaveletTransform *wavelet = comp->waveletTransform + curLevel;\r\n    if (curLevel)\r\n      wavelet[0].subband0Buf = crxIdwt53FilterGetLine(comp, curLevel - 1);\r\n    else if (crxDecodeLineWithIQuantization(comp->subBands + curBand))\r\n      return -1;\r\n\r\n    int32_t *lineBufH0 = wavelet->lineBuf[wavelet->fltTapH + 3];\r\n    if (wavelet->height > 1)\r\n    {\r\n      if (crxDecodeLineWithIQuantization(comp->subBands + curBand + 1) ||\r\n          crxDecodeLineWithIQuantization(comp->subBands + curBand + 2) ||\r\n          crxDecodeLineWithIQuantization(comp->subBands + curBand + 3))\r\n        return -1;\r\n\r\n      int32_t *lineBufL0 = wavelet->lineBuf[0];\r\n      int32_t *lineBufL1 = wavelet->lineBuf[1];\r\n      int32_t *lineBufL2 = wavelet->lineBuf[2];\r\n\r\n      if (comp->tileFlag & E_HAS_TILES_ON_THE_TOP)\r\n      {\r\n        crxHorizontal53(lineBufL0, wavelet->lineBuf[1], wavelet,\r\n                        comp->tileFlag);\r\n        if (crxDecodeLineWithIQuantization(comp->subBands + curBand + 3) ||\r\n            crxDecodeLineWithIQuantization(comp->subBands + curBand + 2))\r\n          return -1;\r\n\r\n        int32_t *band2Buf = wavelet->subband2Buf;\r\n        int32_t *band3Buf = wavelet->subband3Buf;\r\n\r\n        // process L band\r\n        if (wavelet->width <= 1)\r\n          lineBufL2[0] = band2Buf[0];\r\n        else\r\n        {\r\n          if (comp->tileFlag & E_HAS_TILES_ON_THE_LEFT)\r\n          {\r\n            lineBufL2[0] = band2Buf[0] - ((band3Buf[0] + band3Buf[1] + 2) >> 2);\r\n            ++band3Buf;\r\n          }\r\n          else\r\n            lineBufL2[0] = band2Buf[0] - ((band3Buf[0] + 1) >> 1);\r\n\r\n          ++band2Buf;\r\n\r\n          for (int i = 0; i < wavelet->width - 3; i += 2)\r\n          {\r\n            int32_t delta =\r\n                band2Buf[0] - ((band3Buf[0] + band3Buf[1] + 2) >> 2);\r\n            lineBufL2[1] = band3Buf[0] + ((lineBufL2[0] + delta) >> 1);\r\n            lineBufL2[2] = delta;\r\n\r\n            ++band2Buf;\r\n            ++band3Buf;\r\n            lineBufL2 += 2;\r\n          }\r\n          if (comp->tileFlag & E_HAS_TILES_ON_THE_RIGHT)\r\n          {\r\n            int32_t delta =\r\n                band2Buf[0] - ((band3Buf[0] + band3Buf[1] + 2) >> 2);\r\n            lineBufL2[1] = band3Buf[0] + ((lineBufL2[0] + delta) >> 1);\r\n            if (wavelet->width & 1)\r\n              lineBufL2[2] = delta;\r\n          }\r\n          else if (wavelet->width & 1)\r\n          {\r\n            int32_t delta = band2Buf[0] - ((band3Buf[0] + 1) >> 1);\r\n\r\n            lineBufL2[1] = band3Buf[0] + ((lineBufL2[0] + delta) >> 1);\r\n            lineBufL2[2] = delta;\r\n          }\r\n          else\r\n          {\r\n            lineBufL2[1] = band3Buf[0] + lineBufL2[0];\r\n          }\r\n        }\r\n\r\n        // process H band\r\n        for (int32_t i = 0; i < wavelet->width; i++)\r\n          lineBufH0[i] =\r\n              lineBufL0[i] - ((lineBufL1[i] + lineBufL2[i] + 2) >> 2);\r\n      }\r\n      else\r\n      {\r\n        crxHorizontal53(lineBufL0, wavelet->lineBuf[2], wavelet,\r\n                        comp->tileFlag);\r\n        for (int i = 0; i < wavelet->width; i++)\r\n          lineBufH0[i] = lineBufL0[i] - ((lineBufL2[i] + 1) >> 1);\r\n      }\r\n\r\n      if (crxIdwt53FilterDecode(comp, curLevel) ||\r\n          crxIdwt53FilterTransform(comp, curLevel))\r\n        return -1;\r\n    }\r\n    else\r\n    {\r\n      if (crxDecodeLineWithIQuantization(comp->subBands + curBand + 1))\r\n        return -1;\r\n\r\n      int32_t *band0Buf = wavelet->subband0Buf;\r\n      int32_t *band1Buf = wavelet->subband1Buf;\r\n\r\n      // process H band\r\n      if (wavelet->width <= 1)\r\n        lineBufH0[0] = band0Buf[0];\r\n      else\r\n      {\r\n        if (comp->tileFlag & E_HAS_TILES_ON_THE_LEFT)\r\n        {\r\n          lineBufH0[0] = band0Buf[0] - ((band1Buf[0] + band1Buf[1] + 2) >> 2);\r\n          ++band1Buf;\r\n        }\r\n        else\r\n          lineBufH0[0] = band0Buf[0] - ((band1Buf[0] + 1) >> 1);\r\n\r\n        ++band0Buf;\r\n\r\n        for (int i = 0; i < wavelet->width - 3; i += 2)\r\n        {\r\n          int32_t delta = band0Buf[0] - ((band1Buf[0] + band1Buf[1] + 2) >> 2);\r\n          lineBufH0[1] = band1Buf[0] + ((lineBufH0[0] + delta) >> 1);\r\n          lineBufH0[2] = delta;\r\n\r\n          ++band0Buf;\r\n          ++band1Buf;\r\n          lineBufH0 += 2;\r\n        }\r\n\r\n        if (comp->tileFlag & E_HAS_TILES_ON_THE_RIGHT)\r\n        {\r\n          int32_t delta = band0Buf[0] - ((band1Buf[0] + band1Buf[1] + 2) >> 2);\r\n          lineBufH0[1] = band1Buf[0] + ((lineBufH0[0] + delta) >> 1);\r\n          lineBufH0[2] = delta;\r\n        }\r\n        else if (wavelet->width & 1)\r\n        {\r\n          int32_t delta = band0Buf[0] - ((band1Buf[0] + 1) >> 1);\r\n          lineBufH0[1] = band1Buf[0] + ((lineBufH0[0] + delta) >> 1);\r\n          lineBufH0[2] = delta;\r\n        }\r\n        else\r\n        {\r\n          lineBufH0[1] = band1Buf[0] + lineBufH0[0];\r\n        }\r\n      }\r\n      ++wavelet->curLine;\r\n      ++wavelet->curH;\r\n      wavelet->fltTapH = (wavelet->fltTapH + 1) % 5;\r\n    }\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\nvoid crxFreeSubbandData(CrxImage *image, CrxPlaneComp *comp)\r\n{\r\n  if (comp->compBuf)\r\n  {\r\n    free(comp->compBuf);\r\n    comp->compBuf = 0;\r\n  }\r\n\r\n  if (!comp->subBands)\r\n    return;\r\n\r\n  for (int32_t i = 0; i < image->subbandCount; i++)\r\n  {\r\n    if (comp->subBands[i].bandParam)\r\n    {\r\n      free(comp->subBands[i].bandParam);\r\n      comp->subBands[i].bandParam = 0LL;\r\n    }\r\n    comp->subBands[i].bandBuf = 0;\r\n    comp->subBands[i].bandSize = 0;\r\n  }\r\n}\r\n\r\nvoid crxConvertPlaneLine(CrxImage *img, int imageRow, int imageCol = 0,\r\n                         int plane = 0, int32_t *lineData = 0,\r\n                         int lineLength = 0)\r\n{\r\n  if (lineData)\r\n  {\r\n    uint64_t rawOffset = 4 * img->planeWidth * imageRow + 2 * imageCol;\r\n    if (img->encType == 1)\r\n    {\r\n      int32_t maxVal = 1 << (img->nBits - 1);\r\n      int32_t minVal = -maxVal;\r\n      --maxVal;\r\n      for (int i = 0; i < lineLength; i++)\r\n        img->outBufs[plane][rawOffset + 2 * i] =\r\n            _constrain(lineData[i], minVal, maxVal);\r\n    }\r\n    else if (img->encType == 3)\r\n    {\r\n      // copy to intermediate planeBuf\r\n      rawOffset = plane * img->planeWidth * img->planeHeight +\r\n                  img->planeWidth * imageRow + imageCol;\r\n      for (int i = 0; i < lineLength; i++)\r\n        img->planeBuf[rawOffset + i] = lineData[i];\r\n    }\r\n    else if (img->nPlanes == 4)\r\n    {\r\n      int32_t median = 1 << (img->nBits - 1);\r\n      int32_t maxVal = (1 << img->nBits) - 1;\r\n      for (int i = 0; i < lineLength; i++)\r\n        img->outBufs[plane][rawOffset + 2 * i] =\r\n            _constrain(median + lineData[i], 0, maxVal);\r\n    }\r\n    else if (img->nPlanes == 1)\r\n    {\r\n      int32_t maxVal = (1 << img->nBits) - 1;\r\n      int32_t median = 1 << (img->nBits - 1);\r\n      rawOffset = img->planeWidth * imageRow + imageCol;\r\n      for (int i = 0; i < lineLength; i++)\r\n        img->outBufs[0][rawOffset + i] =\r\n            _constrain(median + lineData[i], 0, maxVal);\r\n    }\r\n  }\r\n  else if (img->encType == 3 && img->planeBuf)\r\n  {\r\n    int32_t planeSize = img->planeWidth * img->planeHeight;\r\n    int16_t *plane0 = img->planeBuf + imageRow * img->planeWidth;\r\n    int16_t *plane1 = plane0 + planeSize;\r\n    int16_t *plane2 = plane1 + planeSize;\r\n    int16_t *plane3 = plane2 + planeSize;\r\n\r\n    int32_t median = 1 << (img->nBits - 1) << 10;\r\n    int32_t maxVal = (1 << img->nBits) - 1;\r\n    uint32_t rawLineOffset = 4 * img->planeWidth * imageRow;\r\n\r\n    // for this stage - all except imageRow is ignored\r\n    for (int i = 0; i < img->planeWidth; i++)\r\n    {\r\n      int32_t gr =\r\n          median + (plane0[i] << 10) - 168 * plane1[i] - 585 * plane3[i];\r\n      int32_t val = 0;\r\n      if (gr < 0)\r\n        gr = -(((_abs(gr) + 512) >> 9) & ~1);\r\n      else\r\n        gr = ((_abs(gr) + 512) >> 9) & ~1;\r\n\r\n      // Essentially R = round(median + P0 + 1.474*P3)\r\n      val = (median + (plane0[i] << 10) + 1510 * plane3[i] + 512) >> 10;\r\n      img->outBufs[0][rawLineOffset + 2 * i] = _constrain(val, 0, maxVal);\r\n      // Essentially G1 = round(median + P0 + P2 - 0.164*P1 - 0.571*P3)\r\n      val = (plane2[i] + gr + 1) >> 1;\r\n      img->outBufs[1][rawLineOffset + 2 * i] = _constrain(val, 0, maxVal);\r\n      // Essentially G1 = round(median + P0 - P2 - 0.164*P1 - 0.571*P3)\r\n      val = (gr - plane2[i] + 1) >> 1;\r\n      img->outBufs[2][rawLineOffset + 2 * i] = _constrain(val, 0, maxVal);\r\n      // Essentially B = round(median + P0 + 1.881*P1)\r\n      val = (median + (plane0[i] << 10) + 1927 * plane1[i] + 512) >> 10;\r\n      img->outBufs[3][rawLineOffset + 2 * i] = _constrain(val, 0, maxVal);\r\n    }\r\n  }\r\n}\r\n\r\nint crxParamInit(CrxBandParam **param, uint64_t subbandMdatOffset,\r\n                 uint64_t subbandDataSize, uint32_t subbandWidth,\r\n                 uint32_t subbandHeight, int32_t supportsPartial,\r\n                 uint32_t roundedBitsMask, LibRaw_abstract_datastream *input)\r\n{\r\n  int32_t progrDataSize = supportsPartial ? 0 : sizeof(int32_t) * subbandWidth;\r\n  int32_t paramLength = 2 * subbandWidth + 4;\r\n  uint8_t *paramBuf = (uint8_t *)calloc(\r\n      1, sizeof(CrxBandParam) + sizeof(int32_t) * paramLength + progrDataSize);\r\n\r\n  if (!paramBuf)\r\n    return -1;\r\n\r\n  *param = (CrxBandParam *)paramBuf;\r\n\r\n  paramBuf += sizeof(CrxBandParam);\r\n\r\n  (*param)->paramData = (int32_t *)paramBuf;\r\n  (*param)->nonProgrData =\r\n      progrDataSize ? (*param)->paramData + paramLength : 0;\r\n  (*param)->subbandWidth = subbandWidth;\r\n  (*param)->subbandHeight = subbandHeight;\r\n  (*param)->roundedBits = 0;\r\n  (*param)->curLine = 0;\r\n  (*param)->roundedBitsMask = roundedBitsMask;\r\n  (*param)->supportsPartial = supportsPartial;\r\n  (*param)->bitStream.bitData = 0;\r\n  (*param)->bitStream.bitsLeft = 0;\r\n  (*param)->bitStream.mdatSize = subbandDataSize;\r\n  (*param)->bitStream.curPos = 0;\r\n  (*param)->bitStream.curBufSize = 0;\r\n  (*param)->bitStream.curBufOffset = subbandMdatOffset;\r\n  (*param)->bitStream.input = input;\r\n\r\n  crxFillBuffer(&(*param)->bitStream);\r\n\r\n  return 0;\r\n}\r\n\r\nint crxSetupSubbandData(CrxImage *img, CrxPlaneComp *planeComp,\r\n                        const CrxTile *tile, uint32_t mdatOffset)\r\n{\r\n  long compDataSize = 0;\r\n  long waveletDataOffset = 0;\r\n  long compCoeffDataOffset = 0;\r\n  int32_t toSubbands = 3 * img->levels + 1;\r\n  int32_t transformWidth = 0;\r\n\r\n  CrxSubband *subbands = planeComp->subBands;\r\n\r\n  // calculate sizes\r\n  for (int32_t subbandNum = 0; subbandNum < toSubbands; subbandNum++)\r\n  {\r\n    subbands[subbandNum].bandSize =\r\n        subbands[subbandNum].width * sizeof(int32_t); // 4bytes\r\n    compDataSize += subbands[subbandNum].bandSize;\r\n  }\r\n\r\n  if (img->levels)\r\n  {\r\n    int32_t encLevels = img->levels ? img->levels : 1;\r\n    waveletDataOffset = (compDataSize + 7) & ~7;\r\n    compDataSize =\r\n        (sizeof(CrxWaveletTransform) * encLevels + waveletDataOffset + 7) & ~7;\r\n    compCoeffDataOffset = compDataSize;\r\n\r\n    // calc wavelet line buffer sizes (always at one level up from current)\r\n    for (int level = 0; level < img->levels; ++level)\r\n      if (level < img->levels - 1)\r\n        compDataSize += 8 * sizeof(int32_t) *\r\n                        planeComp->subBands[3 * (level + 1) + 2].width;\r\n      else\r\n        compDataSize += 8 * sizeof(int32_t) * tile->width;\r\n  }\r\n\r\n  // buffer allocation\r\n  planeComp->compBuf = (uint8_t *)malloc(compDataSize);\r\n  if (!planeComp->compBuf)\r\n    return -1;\r\n\r\n  // subbands buffer and sizes initialisation\r\n  uint64_t subbandMdatOffset = img->mdatOffset + mdatOffset;\r\n  uint8_t *subbandBuf = planeComp->compBuf;\r\n\r\n  for (int32_t subbandNum = 0; subbandNum < toSubbands; subbandNum++)\r\n  {\r\n    subbands[subbandNum].bandBuf = subbandBuf;\r\n    subbandBuf += subbands[subbandNum].bandSize;\r\n    subbands[subbandNum].mdatOffset =\r\n        subbandMdatOffset + subbands[subbandNum].dataOffset;\r\n  }\r\n\r\n  // wavelet data initialisation\r\n  if (img->levels)\r\n  {\r\n    CrxWaveletTransform *waveletTransforms =\r\n        (CrxWaveletTransform *)(planeComp->compBuf + waveletDataOffset);\r\n    int32_t *paramData = (int32_t *)(planeComp->compBuf + compCoeffDataOffset);\r\n\r\n    planeComp->waveletTransform = waveletTransforms;\r\n    waveletTransforms[0].subband0Buf = (int32_t *)subbands->bandBuf;\r\n\r\n    for (int level = 0; level < img->levels; ++level)\r\n    {\r\n      int32_t band = 3 * level + 1;\r\n\r\n      if (level >= img->levels - 1)\r\n      {\r\n        waveletTransforms[level].height = tile->height;\r\n        transformWidth = tile->width;\r\n      }\r\n      else\r\n      {\r\n        waveletTransforms[level].height = subbands[band + 3].height;\r\n        transformWidth = subbands[band + 4].width;\r\n      }\r\n      waveletTransforms[level].width = transformWidth;\r\n      waveletTransforms[level].lineBuf[0] = paramData;\r\n      waveletTransforms[level].lineBuf[1] =\r\n          waveletTransforms[level].lineBuf[0] + transformWidth;\r\n      waveletTransforms[level].lineBuf[2] =\r\n          waveletTransforms[level].lineBuf[1] + transformWidth;\r\n      waveletTransforms[level].lineBuf[3] =\r\n          waveletTransforms[level].lineBuf[2] + transformWidth;\r\n      waveletTransforms[level].lineBuf[4] =\r\n          waveletTransforms[level].lineBuf[3] + transformWidth;\r\n      waveletTransforms[level].lineBuf[5] =\r\n          waveletTransforms[level].lineBuf[4] + transformWidth;\r\n      waveletTransforms[level].lineBuf[6] =\r\n          waveletTransforms[level].lineBuf[5] + transformWidth;\r\n      waveletTransforms[level].lineBuf[7] =\r\n          waveletTransforms[level].lineBuf[6] + transformWidth;\r\n      waveletTransforms[level].curLine = 0;\r\n      waveletTransforms[level].curH = 0;\r\n      waveletTransforms[level].fltTapH = 0;\r\n      waveletTransforms[level].subband1Buf = (int32_t *)subbands[band].bandBuf;\r\n      waveletTransforms[level].subband2Buf =\r\n          (int32_t *)subbands[band + 1].bandBuf;\r\n      waveletTransforms[level].subband3Buf =\r\n          (int32_t *)subbands[band + 2].bandBuf;\r\n\r\n      paramData = waveletTransforms[level].lineBuf[7] + transformWidth;\r\n    }\r\n  }\r\n\r\n  // decoding params and bitstream initialisation\r\n  for (int32_t subbandNum = 0; subbandNum < toSubbands; subbandNum++)\r\n  {\r\n    if (subbands[subbandNum].dataSize)\r\n    {\r\n      int32_t supportsPartial = 0;\r\n      uint32_t roundedBitsMask = 0;\r\n\r\n      if (planeComp->supportsPartial && subbandNum == 0)\r\n      {\r\n        roundedBitsMask = planeComp->roundedBitsMask;\r\n        supportsPartial = 1;\r\n      }\r\n      if (crxParamInit(&subbands[subbandNum].bandParam,\r\n                       subbands[subbandNum].mdatOffset,\r\n                       subbands[subbandNum].dataSize,\r\n                       subbands[subbandNum].width, subbands[subbandNum].height,\r\n                       supportsPartial, roundedBitsMask, img->input))\r\n        return -1;\r\n    }\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\nint LibRaw::crxDecodePlane(void *p, uint32_t planeNumber)\r\n{\r\n  CrxImage *img = (CrxImage *)p;\r\n  int imageRow = 0;\r\n  for (int tRow = 0; tRow < img->tileRows; tRow++)\r\n  {\r\n    int imageCol = 0;\r\n    for (int tCol = 0; tCol < img->tileCols; tCol++)\r\n    {\r\n      CrxTile *tile = img->tiles + tRow * img->tileRows + tCol;\r\n      CrxPlaneComp *planeComp = tile->comps + planeNumber;\r\n      uint64_t tileMdatOffset = tile->dataOffset + planeComp->dataOffset;\r\n\r\n      // decode single tile\r\n      if (crxSetupSubbandData(img, planeComp, tile, tileMdatOffset))\r\n        return -1;\r\n\r\n      if (img->levels)\r\n      {\r\n        if (crxIdwt53FilterInitialize(planeComp, img->levels - 1))\r\n          return -1;\r\n        for (int i = 0; i < tile->height; ++i)\r\n        {\r\n          if (crxIdwt53FilterDecode(planeComp, img->levels - 1) ||\r\n              crxIdwt53FilterTransform(planeComp, img->levels - 1))\r\n            return -1;\r\n          int32_t *lineData =\r\n              crxIdwt53FilterGetLine(planeComp, img->levels - 1);\r\n          crxConvertPlaneLine(img, imageRow + i, imageCol, planeNumber,\r\n                              lineData, tile->width);\r\n        }\r\n      }\r\n      else\r\n      {\r\n        // we have the only subband in this case\r\n        if (!planeComp->subBands->dataSize)\r\n        {\r\n          memset(planeComp->subBands->bandBuf, 0,\r\n                 planeComp->subBands->bandSize);\r\n          return 0;\r\n        }\r\n\r\n        for (int i = 0; i < tile->height; ++i)\r\n        {\r\n          if (crxDecodeLine(planeComp->subBands->bandParam,\r\n                            planeComp->subBands->bandBuf))\r\n            return -1;\r\n          int32_t *lineData = (int32_t *)planeComp->subBands->bandBuf;\r\n          crxConvertPlaneLine(img, imageRow + i, imageCol, planeNumber,\r\n                              lineData, tile->width);\r\n        }\r\n      }\r\n      imageCol += tile->width;\r\n    }\r\n    imageRow += img->tiles[tRow * img->tileRows].height;\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\nint crxReadSubbandHeaders(crx_data_header_t *hdr, CrxImage *img, CrxTile *tile,\r\n                          CrxPlaneComp *comp, uint8_t **subbandMdatPtr,\r\n                          uint32_t *mdatSize)\r\n{\r\n  CrxSubband *band = comp->subBands + img->subbandCount - 1; // set to last band\r\n  uint32_t bandHeight = tile->height;\r\n  uint32_t bandWidth = tile->width;\r\n  int32_t bandWidthExCoef = 0;\r\n  int32_t bandHeightExCoef = 0;\r\n  if (img->levels)\r\n  {\r\n    // Build up subband sequences to crxDecode to a level in a header\r\n\r\n    // Coefficient structure is a bit unclear and convoluted:\r\n    //   3 levels max - 8 groups (for tile width rounded to 8 bytes)\r\n    //                  of 3 band per level 4 sets of coefficients for each\r\n    int32_t *rowExCoef =\r\n        exCoefNumTbl + 0x60 * (img->levels - 1) + 12 * (tile->width & 7);\r\n    int32_t *colExCoef =\r\n        exCoefNumTbl + 0x60 * (img->levels - 1) + 12 * (tile->height & 7);\r\n    for (int level = 0; level < img->levels; ++level)\r\n    {\r\n      int32_t widthOddPixel = bandWidth & 1;\r\n      int32_t heightOddPixel = bandHeight & 1;\r\n      bandWidth = (widthOddPixel + bandWidth) >> 1;\r\n      bandHeight = (heightOddPixel + bandHeight) >> 1;\r\n\r\n      int32_t bandWidthExCoef0 = 0;\r\n      int32_t bandWidthExCoef1 = 0;\r\n      int32_t bandHeightExCoef0 = 0;\r\n      int32_t bandHeightExCoef1 = 0;\r\n      if (tile->tileFlag & E_HAS_TILES_ON_THE_RIGHT)\r\n      {\r\n        bandWidthExCoef0 = rowExCoef[0];\r\n        bandWidthExCoef1 = rowExCoef[1];\r\n      }\r\n      if (tile->tileFlag & E_HAS_TILES_ON_THE_LEFT)\r\n        ++bandWidthExCoef0;\r\n      if (tile->tileFlag & E_HAS_TILES_ON_THE_BOTTOM)\r\n      {\r\n        bandHeightExCoef0 = colExCoef[0];\r\n        bandHeightExCoef1 = colExCoef[1];\r\n      }\r\n      if (tile->tileFlag & E_HAS_TILES_ON_THE_TOP)\r\n        ++bandHeightExCoef0;\r\n\r\n      band[0].width = bandWidth + bandWidthExCoef0 - widthOddPixel;\r\n      band[0].height = bandHeight + bandHeightExCoef0 - heightOddPixel;\r\n\r\n      band[-1].width = bandWidth + bandWidthExCoef1;\r\n      band[-1].height = bandHeight + bandHeightExCoef0 - heightOddPixel;\r\n\r\n      band[-2].width = bandWidth + bandWidthExCoef0 - widthOddPixel;\r\n      band[-2].height = bandHeight + bandHeightExCoef1;\r\n\r\n      rowExCoef += 4;\r\n      colExCoef += 4;\r\n      band -= 3;\r\n    }\r\n    bandWidthExCoef = bandHeightExCoef = 0;\r\n    if (tile->tileFlag & E_HAS_TILES_ON_THE_RIGHT)\r\n      bandWidthExCoef =\r\n          exCoefNumTbl[0x60 * (img->levels - 1) + 12 * (tile->width & 7) +\r\n                       4 * (img->levels - 1) + 1];\r\n    if (tile->tileFlag & E_HAS_TILES_ON_THE_BOTTOM)\r\n      bandHeightExCoef =\r\n          exCoefNumTbl[0x60 * (img->levels - 1) + 12 * (tile->height & 7) +\r\n                       4 * (img->levels - 1) + 1];\r\n  }\r\n  band->width = bandWidthExCoef + bandWidth;\r\n  band->height = bandHeightExCoef + bandHeight;\r\n\r\n  if (!img->subbandCount)\r\n    return 0;\r\n  int32_t curSubband = 0;\r\n  int32_t subbandOffset = 0;\r\n  band = comp->subBands;\r\n  for (int curSubband = 0; curSubband < img->subbandCount; curSubband++, band++)\r\n  {\r\n    if (*mdatSize < 0xC)\r\n      return -1;\r\n\r\n    if (LibRaw::sgetn(2, *subbandMdatPtr) != 0xFF03)\r\n      return -1;\r\n\r\n    uint32_t bitData = LibRaw::sgetn(4, *subbandMdatPtr + 8);\r\n    uint32_t subbandSize = LibRaw::sgetn(4, *subbandMdatPtr + 4);\r\n\r\n    if (curSubband != bitData >> 28)\r\n    {\r\n      band->dataSize = subbandSize;\r\n      return -1;\r\n    }\r\n    band->dataSize = subbandSize - (bitData & 0x7FF);\r\n    band->supportsPartial = bitData & 0x8000 ? 1 : 0;\r\n    band->dataOffset = subbandOffset;\r\n    band->quantValue = (bitData >> 19) & 0xFF;\r\n    band->paramK = 0;\r\n    band->bandParam = 0;\r\n    band->bandBuf = 0;\r\n    band->bandSize = 0;\r\n\r\n    subbandOffset += subbandSize;\r\n\r\n    *subbandMdatPtr += 0xC;\r\n    *mdatSize -= 0xC;\r\n  }\r\n  return 0;\r\n}\r\n\r\nint crxReadImageHeaders(crx_data_header_t *hdr, CrxImage *img, uint8_t *mdatPtr,\r\n                        uint32_t mdatSize)\r\n{\r\n  int nTiles = img->tileRows * img->tileCols;\r\n\r\n  if (!nTiles)\r\n    return -1;\r\n\r\n  if (!img->tiles)\r\n  {\r\n    img->tiles = (CrxTile *)malloc(\r\n        sizeof(CrxTile) * nTiles +\r\n        sizeof(CrxPlaneComp) * nTiles * img->nPlanes +\r\n        sizeof(CrxSubband) * nTiles * img->nPlanes * img->subbandCount);\r\n    if (!img->tiles)\r\n      return -1;\r\n\r\n    // memory areas in allocated chunk\r\n    CrxTile *tile = img->tiles;\r\n    CrxPlaneComp *comps = (CrxPlaneComp *)(tile + nTiles);\r\n    CrxSubband *bands = (CrxSubband *)(comps + img->nPlanes * nTiles);\r\n\r\n    for (int curTile = 0; curTile < nTiles; curTile++, tile++)\r\n    {\r\n      tile->tileFlag = 0; // tile neighbouring flags\r\n      tile->tileNumber = curTile;\r\n      tile->tileSize = 0;\r\n      tile->comps = comps + curTile * img->nPlanes;\r\n\r\n      if ((curTile + 1) % img->tileCols)\r\n      {\r\n        // not the last tile in a tile row\r\n        tile->width = hdr->tileWidth;\r\n        if (img->tileCols > 1)\r\n        {\r\n          tile->tileFlag = E_HAS_TILES_ON_THE_RIGHT;\r\n          if (curTile % img->tileCols)\r\n            // not the first tile in tile row\r\n            tile->tileFlag |= E_HAS_TILES_ON_THE_LEFT;\r\n        }\r\n      }\r\n      else\r\n      {\r\n        // last tile in a tile row\r\n        tile->width = img->planeWidth - hdr->tileWidth * (img->tileCols - 1);\r\n        if (img->tileCols > 1)\r\n          tile->tileFlag = E_HAS_TILES_ON_THE_LEFT;\r\n      }\r\n      if (curTile < nTiles - img->tileCols)\r\n      {\r\n        // in first tile row\r\n        tile->height = hdr->tileHeight;\r\n        if (img->tileRows > 1)\r\n        {\r\n          tile->tileFlag |= E_HAS_TILES_ON_THE_BOTTOM;\r\n          if (curTile >= img->tileCols)\r\n            tile->tileFlag |= E_HAS_TILES_ON_THE_TOP;\r\n        }\r\n      }\r\n      else\r\n      {\r\n        // non first tile row\r\n        tile->height = img->planeHeight - hdr->tileHeight * (img->tileRows - 1);\r\n        if (img->tileRows > 1)\r\n          tile->tileFlag |= E_HAS_TILES_ON_THE_TOP;\r\n      }\r\n      if (img->nPlanes)\r\n      {\r\n        CrxPlaneComp *comp = tile->comps;\r\n        CrxSubband *band = bands + curTile * img->nPlanes * img->subbandCount;\r\n\r\n        for (int curComp = 0; curComp < img->nPlanes; curComp++, comp++)\r\n        {\r\n          comp->compNumber = curComp;\r\n          comp->supportsPartial = 1;\r\n          comp->tileFlag = tile->tileFlag;\r\n          comp->subBands = band;\r\n          comp->compBuf = 0;\r\n          comp->waveletTransform = 0;\r\n          if (img->subbandCount)\r\n          {\r\n            for (int curBand = 0; curBand < img->subbandCount;\r\n                 curBand++, band++)\r\n            {\r\n              band->supportsPartial = 0;\r\n              band->quantValue = 4;\r\n              band->bandParam = 0;\r\n              band->dataSize = 0;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  uint32_t tileOffset = 0;\r\n  uint32_t dataSize = mdatSize;\r\n  uint8_t *dataPtr = mdatPtr;\r\n  CrxTile *tile = img->tiles;\r\n\r\n  for (int curTile = 0; curTile < nTiles; curTile++, tile++)\r\n  {\r\n    if (dataSize < 0xC)\r\n      return -1;\r\n\r\n    if (LibRaw::sgetn(2, dataPtr) != 0xFF01)\r\n      return -1;\r\n    if (LibRaw::sgetn(2, dataPtr + 8) != curTile)\r\n      return -1;\r\n\r\n    dataSize -= 0xC;\r\n\r\n    tile->tileSize = LibRaw::sgetn(4, dataPtr + 4);\r\n    tile->dataOffset = tileOffset;\r\n\r\n    int32_t hdrExtraBytes = LibRaw::sgetn(2, dataPtr + 2) - 8;\r\n    tileOffset += tile->tileSize;\r\n    dataPtr += hdrExtraBytes + 0xC;\r\n    dataSize -= hdrExtraBytes;\r\n\r\n    uint32_t compOffset = 0;\r\n    CrxPlaneComp *comp = tile->comps;\r\n\r\n    for (int compNum = 0; compNum < img->nPlanes; compNum++, comp++)\r\n    {\r\n      if (dataSize < 0xC)\r\n        return -1;\r\n\r\n      if (LibRaw::sgetn(2, dataPtr) != 0xFF02)\r\n        return -1;\r\n      if (compNum != dataPtr[8] >> 4)\r\n        return -1;\r\n\r\n      comp->compSize = LibRaw::sgetn(4, dataPtr + 4);\r\n\r\n      int32_t compHdrRoundedBits = (dataPtr[8] >> 1) & 3;\r\n      comp->supportsPartial = (dataPtr[8] & 8) != 0;\r\n\r\n      comp->dataOffset = compOffset;\r\n      comp->tileFlag = tile->tileFlag;\r\n\r\n      compOffset += comp->compSize;\r\n      dataSize -= 0xC;\r\n      dataPtr += 0xC;\r\n\r\n      comp->roundedBitsMask = 0;\r\n\r\n      if (compHdrRoundedBits)\r\n      {\r\n        if (img->levels || !comp->supportsPartial)\r\n          return -1;\r\n\r\n        comp->roundedBitsMask = 1 << (compHdrRoundedBits - 1);\r\n      }\r\n\r\n      if (crxReadSubbandHeaders(hdr, img, tile, comp, &dataPtr, &dataSize))\r\n        return -1;\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n\r\nint crxSetupImageData(crx_data_header_t *hdr, CrxImage *img, int16_t *outBuf,\r\n                      uint64_t mdatOffset, uint32_t mdatSize,\r\n                      uint8_t *mdatHdrPtr)\r\n{\r\n  int IncrBitTable[32] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0,\r\n                          0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0};\r\n\r\n  img->planeWidth = hdr->f_width;\r\n  img->planeHeight = hdr->f_height;\r\n\r\n  if (hdr->tileWidth < 0x16 || hdr->tileHeight < 0x16 ||\r\n      img->planeWidth > 0x7FFF || img->planeHeight > 0x7FFF)\r\n    return -1;\r\n\r\n  img->tileCols = (img->planeWidth + hdr->tileWidth - 1) / hdr->tileWidth;\r\n  img->tileRows = (img->planeHeight + hdr->tileHeight - 1) / hdr->tileHeight;\r\n\r\n  if (img->tileCols > 0xFF || img->tileRows > 0xFF ||\r\n      img->planeWidth - hdr->tileWidth * (img->tileCols - 1) < 0x16 ||\r\n      img->planeHeight - hdr->tileHeight * (img->tileRows - 1) < 0x16)\r\n    return -1;\r\n\r\n  img->tiles = 0;\r\n  img->levels = hdr->imageLevels;\r\n  img->subbandCount = 3 * img->levels + 1; // 3 bands per level + one last LL\r\n  img->nPlanes = hdr->nPlanes;\r\n  img->nBits = hdr->nBits;\r\n  img->encType = hdr->encType;\r\n  img->samplePrecision = hdr->nBits + IncrBitTable[4 * hdr->encType + 2] + 1;\r\n  img->mdatOffset = mdatOffset + hdr->mdatHdrSize;\r\n  img->mdatSize = mdatSize;\r\n  img->planeBuf = 0;\r\n  img->outBufs[0] = img->outBufs[1] = img->outBufs[2] = img->outBufs[3] = 0;\r\n\r\n  // The encoding type 3 needs all 4 planes to be decoded to generate row of\r\n  // RGGB values. It seems to be using some other colour space for raw encoding\r\n  // It is a massive buffer so ideallly it will need a different approach:\r\n  // decode planes line by line and convert single line then without\r\n  // intermediate plane buffer. At the moment though it's too many changes so\r\n  // left as is.\r\n  if (img->encType == 3 && img->nPlanes == 4 && img->nBits > 8)\r\n  {\r\n    img->planeBuf =\r\n        (int16_t *)malloc(img->planeHeight * img->planeWidth * img->nPlanes *\r\n                          ((img->samplePrecision + 7) >> 3));\r\n    if (!img->planeBuf)\r\n      return -1;\r\n  }\r\n\r\n  int32_t rowSize = 2 * img->planeWidth;\r\n\r\n  if (img->nPlanes == 1)\r\n    img->outBufs[0] = outBuf;\r\n  else\r\n    switch (hdr->cfaLayout)\r\n    {\r\n    case 0:\r\n      // R G\r\n      // G B\r\n      img->outBufs[0] = outBuf;\r\n      img->outBufs[1] = outBuf + 1;\r\n      img->outBufs[2] = outBuf + rowSize;\r\n      img->outBufs[3] = img->outBufs[2] + 1;\r\n      break;\r\n    case 1:\r\n      // G R\r\n      // B G\r\n      img->outBufs[1] = outBuf;\r\n      img->outBufs[0] = outBuf + 1;\r\n      img->outBufs[3] = outBuf + rowSize;\r\n      img->outBufs[2] = img->outBufs[3] + 1;\r\n      break;\r\n    case 2:\r\n      // G B\r\n      // R G\r\n      img->outBufs[2] = outBuf;\r\n      img->outBufs[3] = outBuf + 1;\r\n      img->outBufs[0] = outBuf + rowSize;\r\n      img->outBufs[1] = img->outBufs[0] + 1;\r\n      break;\r\n    case 3:\r\n      // B G\r\n      // G R\r\n      img->outBufs[3] = outBuf;\r\n      img->outBufs[2] = outBuf + 1;\r\n      img->outBufs[1] = outBuf + rowSize;\r\n      img->outBufs[0] = img->outBufs[1] + 1;\r\n      break;\r\n    }\r\n\r\n  // read header\r\n  return crxReadImageHeaders(hdr, img, mdatHdrPtr, mdatSize);\r\n}\r\n\r\nint crxFreeImageData(CrxImage *img)\r\n{\r\n  CrxTile *tile = img->tiles;\r\n  int nTiles = img->tileRows * img->tileCols;\r\n\r\n  if (img->tiles)\r\n  {\r\n    for (int32_t curTile = 0; curTile < nTiles; curTile++, tile++)\r\n      if (tile[curTile].comps)\r\n        for (int32_t curPlane = 0; curPlane < img->nPlanes; curPlane++)\r\n          crxFreeSubbandData(img, tile[curTile].comps + curPlane);\r\n    free(img->tiles);\r\n    img->tiles = 0;\r\n  }\r\n\r\n  if (img->planeBuf)\r\n  {\r\n    free(img->planeBuf);\r\n    img->planeBuf = 0;\r\n  }\r\n\r\n  return 0;\r\n}\r\nvoid LibRaw::crxLoadDecodeLoop(void *img, int nPlanes)\r\n{\r\n#ifdef LIBRAW_USE_OPENMP\r\n  int results[4]; // nPlanes is always <= 4\r\n#pragma omp parallel for\r\n  for (int32_t plane = 0; plane < nPlanes; ++plane)\r\n    results[plane] = crxDecodePlane(img, plane);\r\n\r\n  for (int32_t plane = 0; plane < nPlanes; ++plane)\r\n    if (results[plane])\r\n      derror();\r\n#else\r\n  for (int32_t plane = 0; plane < nPlanes; ++plane)\r\n    if (crxDecodePlane(img, plane))\r\n      derror();\r\n#endif\r\n}\r\n\r\nvoid LibRaw::crxConvertPlaneLineDf(void *p, int imageRow)\r\n{\r\n  crxConvertPlaneLine((CrxImage *)p, imageRow);\r\n}\r\n\r\nvoid LibRaw::crxLoadFinalizeLoopE3(void *p, int planeHeight)\r\n{\r\n#ifdef LIBRAW_USE_OPENMP\r\n#pragma omp parallel for\r\n#endif\r\n  for (int i = 0; i < planeHeight; ++i)\r\n    crxConvertPlaneLineDf(p, i);\r\n}\r\n\r\nvoid LibRaw::crxLoadRaw()\r\n{\r\n  CrxImage img;\r\n  if (libraw_internal_data.unpacker_data.crx_track_selected < 0 ||\r\n      libraw_internal_data.unpacker_data.crx_track_selected >=\r\n          LIBRAW_CRXTRACKS_MAXCOUNT)\r\n    derror();\r\n  crx_data_header_t hdr =\r\n      libraw_internal_data.unpacker_data\r\n          .crx_header[libraw_internal_data.unpacker_data.crx_track_selected];\r\n\r\n  img.input = libraw_internal_data.internal_data.input;\r\n\r\n  // update sizes for the planes\r\n  if (hdr.nPlanes == 4)\r\n  {\r\n    hdr.f_width >>= 1;\r\n    hdr.f_height >>= 1;\r\n    hdr.tileWidth >>= 1;\r\n    hdr.tileHeight >>= 1;\r\n  }\r\n\r\n  imgdata.color.maximum = (1 << hdr.nBits) - 1;\r\n\r\n  uint8_t *hdrBuf = (uint8_t *)malloc(hdr.mdatHdrSize);\r\n\r\n  // read image header\r\n#ifdef LIBRAW_USE_OPENMP\r\n#pragma omp critical\r\n#endif\r\n  {\r\n#ifndef LIBRAW_USE_OPENMP\r\n    libraw_internal_data.internal_data.input->lock();\r\n#endif\r\n    libraw_internal_data.internal_data.input->seek(\r\n        libraw_internal_data.unpacker_data.data_offset, SEEK_SET);\r\n    libraw_internal_data.internal_data.input->read(hdrBuf, 1, hdr.mdatHdrSize);\r\n#ifndef LIBRAW_USE_OPENMP\r\n    libraw_internal_data.internal_data.input->unlock();\r\n#endif\r\n  }\r\n\r\n  // parse and setup the image data\r\n  if (crxSetupImageData(&hdr, &img, (int16_t *)imgdata.rawdata.raw_image,\r\n                        libraw_internal_data.unpacker_data.data_offset,\r\n                        libraw_internal_data.unpacker_data.data_size, hdrBuf))\r\n    derror();\r\n  free(hdrBuf);\r\n\r\n  crxLoadDecodeLoop(&img, hdr.nPlanes);\r\n\r\n  if (img.encType == 3)\r\n    crxLoadFinalizeLoopE3(&img, img.planeHeight);\r\n\r\n  crxFreeImageData(&img);\r\n}\r\n\r\nint LibRaw::crxParseImageHeader(uchar *cmp1TagData, int nTrack)\r\n{\r\n  if (nTrack < 0 || nTrack >= LIBRAW_CRXTRACKS_MAXCOUNT)\r\n    return -1;\r\n  if (!cmp1TagData)\r\n    return -1;\r\n\r\n  crx_data_header_t *hdr =\r\n      &libraw_internal_data.unpacker_data.crx_header[nTrack];\r\n\r\n  hdr->version = sgetn(2, cmp1TagData + 4);\r\n  hdr->f_width = sgetn(4, cmp1TagData + 8);\r\n  hdr->f_height = sgetn(4, cmp1TagData + 12);\r\n  hdr->tileWidth = sgetn(4, cmp1TagData + 16);\r\n  hdr->tileHeight = sgetn(4, cmp1TagData + 20);\r\n  hdr->nBits = cmp1TagData[24];\r\n  hdr->nPlanes = cmp1TagData[25] >> 4;\r\n  hdr->cfaLayout = cmp1TagData[25] & 0xF;\r\n  hdr->encType = cmp1TagData[26] >> 4;\r\n  hdr->imageLevels = cmp1TagData[26] & 0xF;\r\n  hdr->hasTileCols = cmp1TagData[27] >> 7;\r\n  hdr->hasTileRows = (cmp1TagData[27] >> 6) & 1;\r\n  hdr->mdatHdrSize = sgetn(4, cmp1TagData + 28);\r\n\r\n  // validation\r\n  if (hdr->version != 0x100 || !hdr->mdatHdrSize)\r\n    return -1;\r\n  if (hdr->encType == 1)\r\n  {\r\n    if (hdr->nBits > 15)\r\n      return -1;\r\n  }\r\n  else\r\n  {\r\n    if (hdr->encType && hdr->encType != 3)\r\n      return -1;\r\n    if (hdr->nBits > 14)\r\n      return -1;\r\n  }\r\n\r\n  if (hdr->nPlanes == 1)\r\n  {\r\n    if (hdr->cfaLayout || hdr->encType)\r\n      return -1;\r\n    if (hdr->nBits != 8)\r\n      return -1;\r\n  }\r\n  else if (hdr->nPlanes != 4 || hdr->f_width & 1 || hdr->f_height & 1 ||\r\n           hdr->tileWidth & 1 || hdr->tileHeight & 1 || hdr->cfaLayout > 3u ||\r\n           (hdr->encType && hdr->encType != 1 && hdr->encType != 3) ||\r\n           hdr->nBits == 8)\r\n    return -1;\r\n\r\n  if (hdr->tileWidth > hdr->f_width || hdr->tileHeight > hdr->f_height)\r\n    return -1;\r\n\r\n  if (hdr->imageLevels > 3 || hdr->hasTileCols > 1 || hdr->hasTileRows > 1)\r\n    return -1;\r\n  return 0;\r\n}\r\n\r\n#undef _abs\r\n#undef _min\r\n#undef _constrain\r\n#undef libraw_inline\r\n"], "fixing_code": ["/* -*- C++ -*-\n * File: libraw_const.h\n * Copyright 2008-2019 LibRaw LLC (info@libraw.org)\n * Created: Sat Mar  8 , 2008\n * LibRaw error codes\nLibRaw is free software; you can redistribute it and/or modify\nit under the terms of the one of two licenses as you choose:\n\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\n\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\n\n */\n\n#ifndef _LIBRAW_ERRORS_H\n#define _LIBRAW_ERRORS_H\n\n#define LIBRAW_DEFAULT_ADJUST_MAXIMUM_THRESHOLD 0.75\n#define LIBRAW_DEFAULT_AUTO_BRIGHTNESS_THRESHOLD 0.01\n/* limit allocation size, default is 2Gb */\n#define LIBRAW_MAX_ALLOC_MB_DEFAULT 2048L\n\n/* Check if enough file space exists before tag read */\n#ifndef LIBRAW_NO_IOSPACE_CHECK\n#define LIBRAW_IOSPACE_CHECK\n#endif\n#ifndef LIBRAW_NO_CR3_MEMPOOL\n#define LIBRAW_CR3_MEMPOOL\n#endif\n\n\n/* LibRaw uses own memory pool management, with LIBRAW_MSIZE (512)\nentries. It is enough for parsing/decoding non-damaged files, but\nmay overflow on specially crafted files (eg. with many string values\nlike XMP blocks.\nLIBRAW_MEMPOOL_CHECK define will result in error on pool overflow */\n#ifndef LIBRAW_NO_MEMPOOL_CHECK\n#define LIBRAW_MEMPOOL_CHECK\n#endif\n\n#define LIBRAW_MAX_METADATA_BLOCKS 1024\n#define LIBRAW_CBLACK_SIZE 4104\n#define LIBRAW_IFD_MAXCOUNT 10\n#define LIBRAW_CRXTRACKS_MAXCOUNT 16\n\n#define LIBRAW_AHD_TILE 512\n\nenum LibRaw_openbayer_patterns\n{\n  LIBRAW_OPENBAYER_RGGB = 0x94,\n  LIBRAW_OPENBAYER_BGGR = 0x16,\n  LIBRAW_OPENBAYER_GRBG = 0x61,\n  LIBRAW_OPENBAYER_GBRG = 0x49\n};\n\nenum LibRaw_dngfields_marks\n{\n  LIBRAW_DNGFM_FORWARDMATRIX = 1,\n  LIBRAW_DNGFM_ILLUMINANT = 1 << 1,\n  LIBRAW_DNGFM_COLORMATRIX = 1 << 2,\n  LIBRAW_DNGFM_CALIBRATION = 1 << 3,\n  LIBRAW_DNGFM_ANALOGBALANCE = 1 << 4,\n  LIBRAW_DNGFM_BLACK = 1 << 5,\n  LIBRAW_DNGFM_WHITE = 1 << 6,\n  LIBRAW_DNGFM_OPCODE2 = 1 << 7,\n  LIBRAW_DNGFM_LINTABLE = 1 << 8,\n  LIBRAW_DNGFM_CROPORIGIN = 1 << 9,\n  LIBRAW_DNGFM_CROPSIZE = 1 << 10,\n  LIBRAW_DNGFM_PREVIEWCS = 1 << 11,\n  LIBRAW_DNGFM_ASSHOTNEUTRAL = 1 << 12,\n  LIBRAW_DNGFM_BASELINEEXPOSURE = 1 << 13,\n  LIBRAW_DNGFM_LINEARRESPONSELIMIT = 1 << 14\n};\n\nenum LibRaw_As_Shot_WB_Applied_codes\n{\n  LIBRAW_ASWB_APPLIED = 1,\n  LIBRAW_ASWB_CANON = 2,\n  LIBRAW_ASWB_NIKON = 4,\n  LIBRAW_ASWB_NIKON_SRAW = 8,\n  LIBRAW_ASWB_PENTAX = 16\n};\n\nenum LibRaw_whitebalance_code\n{\n  /*\n      EXIF light sources\n      12 = FL-D; Daylight fluorescent (D 5700K \u2013 7100K) (F1,F5)\n      13 = FL-N; Day white fluorescent (N 4600K \u2013 5400K) (F7,F8)\n      14 = FL-W; Cool white fluorescent (W 3900K \u2013 4500K) (F2,F6, office, store,\n     warehouse) 15 = FL-WW; White fluorescent (WW 3200K \u2013 3700K) (F3,\n     residential) 16 = FL-L; Soft/Warm white fluorescent (L 2600K - 3250K) (F4,\n     kitchen, bath)\n  */\n  LIBRAW_WBI_Unknown = 0,\n  LIBRAW_WBI_Daylight = 1,\n  LIBRAW_WBI_Fluorescent = 2,\n  LIBRAW_WBI_Tungsten = 3,\n  LIBRAW_WBI_Flash = 4,\n  LIBRAW_WBI_FineWeather = 9,\n  LIBRAW_WBI_Cloudy = 10,\n  LIBRAW_WBI_Shade = 11,\n  LIBRAW_WBI_FL_D = 12,\n  LIBRAW_WBI_FL_N = 13,\n  LIBRAW_WBI_FL_W = 14,\n  LIBRAW_WBI_FL_WW = 15,\n  LIBRAW_WBI_FL_L = 16,\n  LIBRAW_WBI_Ill_A = 17,\n  LIBRAW_WBI_Ill_B = 18,\n  LIBRAW_WBI_Ill_C = 19,\n  LIBRAW_WBI_D55 = 20,\n  LIBRAW_WBI_D65 = 21,\n  LIBRAW_WBI_D75 = 22,\n  LIBRAW_WBI_D50 = 23,\n  LIBRAW_WBI_StudioTungsten = 24,\n  LIBRAW_WBI_Sunset = 64,\n  LIBRAW_WBI_HT_Mercury = 67,\n  LIBRAW_WBI_Auto = 82,\n  LIBRAW_WBI_Custom = 83,\n  LIBRAW_WBI_Auto1 = 85,\n  LIBRAW_WBI_Auto2 = 86,\n  LIBRAW_WBI_Auto3 = 87,\n  LIBRAW_WBI_Auto4 = 88,\n  LIBRAW_WBI_Custom1 = 90,\n  LIBRAW_WBI_Custom2 = 91,\n  LIBRAW_WBI_Custom3 = 92,\n  LIBRAW_WBI_Custom4 = 93,\n  LIBRAW_WBI_Custom5 = 94,\n  LIBRAW_WBI_Custom6 = 95,\n  LIBRAW_WBI_Measured = 100,\n  LIBRAW_WBI_Underwater = 120,\n  LIBRAW_WBI_Kelvin = 254,\n  LIBRAW_WBI_Other = 255,\n  LIBRAW_WBI_None = 0xffff\n};\n\nenum LibRaw_MultiExposure_related\n{\n  LIBRAW_ME_NONE = 0,\n  LIBRAW_ME_SIMPLE = 1,\n  LIBRAW_ME_OVERLAY = 2,\n  LIBRAW_ME_HDR = 3\n};\n\nenum LibRaw_dng_processing\n{\n  LIBRAW_DNG_NONE = 0,\n  LIBRAW_DNG_FLOAT = 1,\n  LIBRAW_DNG_LINEAR = 2,\n  LIBRAW_DNG_DEFLATE = 4,\n  LIBRAW_DNG_XTRANS = 8,\n  LIBRAW_DNG_OTHER = 16,\n  LIBRAW_DNG_8BIT = 32,\n  /*LIBRAW_DNG_LARGERANGE=64,*/ /* more than 16 bit integer */\n  LIBRAW_DNG_ALL =\n      LIBRAW_DNG_FLOAT | LIBRAW_DNG_LINEAR | LIBRAW_DNG_XTRANS |\n      LIBRAW_DNG_8BIT | LIBRAW_DNG_OTHER /* |LIBRAW_DNG_LARGERANGE */,\n  LIBRAW_DNG_DEFAULT = LIBRAW_DNG_FLOAT | LIBRAW_DNG_LINEAR |\n                       LIBRAW_DNG_DEFLATE | LIBRAW_DNG_8BIT\n};\n\nenum LibRaw_runtime_capabilities\n{\n  LIBRAW_CAPS_RAWSPEED = 1,\n  LIBRAW_CAPS_DNGSDK = 2,\n  LIBRAW_CAPS_GPRSDK = 4,\n  LIBRAW_CAPS_UNICODEPATHS = 8\n};\n\nenum LibRaw_cameramaker_index\n{\n  LIBRAW_CAMERAMAKER_Unknown = 0,\n  LIBRAW_CAMERAMAKER_Agfa,\n  LIBRAW_CAMERAMAKER_Alcatel,\n  LIBRAW_CAMERAMAKER_Apple,\n  LIBRAW_CAMERAMAKER_Aptina,\n  LIBRAW_CAMERAMAKER_AVT,\n  LIBRAW_CAMERAMAKER_Baumer,\n  LIBRAW_CAMERAMAKER_Broadcom,\n  LIBRAW_CAMERAMAKER_Canon,\n  LIBRAW_CAMERAMAKER_Casio,\n  LIBRAW_CAMERAMAKER_CINE,\n  LIBRAW_CAMERAMAKER_Clauss,\n  LIBRAW_CAMERAMAKER_Contax,\n  LIBRAW_CAMERAMAKER_Creative,\n  LIBRAW_CAMERAMAKER_DJI,\n  LIBRAW_CAMERAMAKER_DXO,\n  LIBRAW_CAMERAMAKER_Epson,\n  LIBRAW_CAMERAMAKER_Foculus,\n  LIBRAW_CAMERAMAKER_Fujifilm,\n  LIBRAW_CAMERAMAKER_Generic,\n  LIBRAW_CAMERAMAKER_Gione,\n  LIBRAW_CAMERAMAKER_GITUP,\n  LIBRAW_CAMERAMAKER_Google,\n  LIBRAW_CAMERAMAKER_GoPro,\n  LIBRAW_CAMERAMAKER_Hasselblad,\n  LIBRAW_CAMERAMAKER_HTC,\n  LIBRAW_CAMERAMAKER_I_Mobile,\n  LIBRAW_CAMERAMAKER_Imacon,\n  LIBRAW_CAMERAMAKER_Kodak,\n  LIBRAW_CAMERAMAKER_Konica,\n  LIBRAW_CAMERAMAKER_Leaf,\n  LIBRAW_CAMERAMAKER_Leica,\n  LIBRAW_CAMERAMAKER_Lenovo,\n  LIBRAW_CAMERAMAKER_LG,\n  LIBRAW_CAMERAMAKER_Mamiya,\n  LIBRAW_CAMERAMAKER_Matrix,\n  LIBRAW_CAMERAMAKER_Meizu,\n  LIBRAW_CAMERAMAKER_Micron,\n  LIBRAW_CAMERAMAKER_Minolta,\n  LIBRAW_CAMERAMAKER_Motorola,\n  LIBRAW_CAMERAMAKER_NGM,\n  LIBRAW_CAMERAMAKER_Nikon,\n  LIBRAW_CAMERAMAKER_Nokia,\n  LIBRAW_CAMERAMAKER_Olympus,\n  LIBRAW_CAMERAMAKER_OmniVison,\n  LIBRAW_CAMERAMAKER_Panasonic,\n  LIBRAW_CAMERAMAKER_Parrot,\n  LIBRAW_CAMERAMAKER_Pentax,\n  LIBRAW_CAMERAMAKER_PhaseOne,\n  LIBRAW_CAMERAMAKER_PhotoControl,\n  LIBRAW_CAMERAMAKER_Photron,\n  LIBRAW_CAMERAMAKER_Pixelink,\n  LIBRAW_CAMERAMAKER_Polaroid,\n  LIBRAW_CAMERAMAKER_RED,\n  LIBRAW_CAMERAMAKER_Ricoh,\n  LIBRAW_CAMERAMAKER_Rollei,\n  LIBRAW_CAMERAMAKER_RoverShot,\n  LIBRAW_CAMERAMAKER_Samsung,\n  LIBRAW_CAMERAMAKER_Sigma,\n  LIBRAW_CAMERAMAKER_Sinar,\n  LIBRAW_CAMERAMAKER_SMaL,\n  LIBRAW_CAMERAMAKER_Sony,\n  LIBRAW_CAMERAMAKER_ST_Micro,\n  LIBRAW_CAMERAMAKER_THL,\n  LIBRAW_CAMERAMAKER_Xiaomi,\n  LIBRAW_CAMERAMAKER_XIAOYI,\n  LIBRAW_CAMERAMAKER_YI,\n  LIBRAW_CAMERAMAKER_Yuneec,\n  // Insert additional indexes here\n  LIBRAW_CAMERAMAKER_TheLastOne,\n};\n\nenum LibRaw_camera_mounts\n{\n  LIBRAW_MOUNT_Unknown = 0,\n  LIBRAW_MOUNT_Minolta_A = 1,\n  LIBRAW_MOUNT_Sony_E = 2,\n  LIBRAW_MOUNT_Canon_EF = 3,\n  LIBRAW_MOUNT_Canon_EF_S = 4,\n  LIBRAW_MOUNT_Canon_EF_M = 5,\n  LIBRAW_MOUNT_Nikon_F = 6,\n  LIBRAW_MOUNT_Nikon_CX = 7, /* used in 'Nikon 1' series */\n  LIBRAW_MOUNT_FT = 8,       /* original 4/3 */\n  LIBRAW_MOUNT_mFT = 9,      /* micro 4/3 */\n  LIBRAW_MOUNT_Pentax_K = 10,\n  LIBRAW_MOUNT_Pentax_Q = 11,\n  LIBRAW_MOUNT_Pentax_645 = 12,\n  LIBRAW_MOUNT_Fuji_X = 13,\n  LIBRAW_MOUNT_Leica_M = 14, /* Leica rangefinder bayonet */\n  LIBRAW_MOUNT_Leica_R = 15, /* Leica SLRs, 'R' for reflex */\n  LIBRAW_MOUNT_Leica_S = 16, /* LIBRAW_FORMAT_LeicaS 'MF' */\n  LIBRAW_MOUNT_Samsung_NX = 17,\n  LIBRAW_MOUNT_RicohModule = 18,\n  LIBRAW_MOUNT_Samsung_NX_M = 19,\n  LIBRAW_MOUNT_Leica_L = 20, /* camera mount throat, takes SL and TL lenses */\n  LIBRAW_MOUNT_Contax_N = 21,\n  LIBRAW_MOUNT_Sigma_X3F = 22,\n  LIBRAW_MOUNT_Leica_TL = 23, /* lens, mounts on 'L' throat, APS-C */\n  LIBRAW_MOUNT_Leica_SL = 24, /* lens, mounts on 'L' throat, FF */\n  LIBRAW_MOUNT_Nikon_Z = 25,\n  LIBRAW_MOUNT_Canon_RF = 26,\n  LIBRAW_MOUNT_C = 27,              /* C-mount */\n  LIBRAW_MOUNT_Fuji_GF = 50,        /* Fujifilm GFX cameras, G mount */\n  LIBRAW_MOUNT_Hasselblad_H = 51,   /* Hasselblad Hn cameras, HC & HCD lenses */\n  LIBRAW_MOUNT_Hasselblad_XCD = 52, /* Hasselblad Xn cameras, XCD lenses */\n  LIBRAW_MOUNT_Hasselblad_V = 53,\n  LIBRAW_MOUNT_Contax645 = 54,\n  LIBRAW_MOUNT_Mamiya645 = 55,\n  LIBRAW_MOUNT_Rollei_bayonet =\n      56, /* Rollei Hy-6: Leaf AFi, Sinar Hy6- models */\n  LIBRAW_MOUNT_Alpa = 57,\n  LIBRAW_MOUNT_Mamiya67 = 58, /* Mamiya RB67, RZ67 */\n  LIBRAW_MOUNT_Fuji_GX = 59,  /* Fujifilm GX680 */\n  LIBRAW_MOUNT_LF = 97,\n  LIBRAW_MOUNT_DigitalBack = 98,\n  LIBRAW_MOUNT_FixedLens = 99,\n  LIBRAW_MOUNT_IL_UM = 100 /* Interchangeable lens, mount unknown */\n};\n\nenum LibRaw_camera_formats\n{\n  LIBRAW_FORMAT_Unknown = 0,\n  LIBRAW_FORMAT_APSC = 1,\n  LIBRAW_FORMAT_FF = 2,\n  LIBRAW_FORMAT_MF = 3,\n  LIBRAW_FORMAT_APSH = 4,\n  LIBRAW_FORMAT_1INCH = 5,\n  LIBRAW_FORMAT_1div2p3INCH = 6, /* 1/2.3\" */\n  LIBRAW_FORMAT_1div1p7INCH = 7, /* 1/1.7\" */\n  LIBRAW_FORMAT_FT = 8,          /* sensor size in FT & mFT cameras */\n  LIBRAW_FORMAT_CROP645 = 9,     /* 44x33mm */\n  LIBRAW_FORMAT_LeicaS = 10,     /* 'MF' Leicas */\n  LIBRAW_FORMAT_645 = 11,\n  LIBRAW_FORMAT_66 = 12,\n  LIBRAW_FORMAT_69 = 13,\n  LIBRAW_FORMAT_LF = 14,\n  LIBRAW_FORMAT_Leica_DMR = 15,\n  LIBRAW_FORMAT_67 = 16,\n  LIBRAW_FORMAT_SigmaAPSC = 17, /* DP1, DP2, SD15, SD14, SD10, SD9 */\n  LIBRAW_FORMAT_SigmaMerrill =\n      18, /* SD1,  'SD1 Merrill',  'DP1 Merrill',  'DP2 Merrill' */\n  LIBRAW_FORMAT_SigmaAPSH = 19, /* 'sd Quattro H' */\n  LIBRAW_FORMAT_3648 = 20,      /* DALSA FTF4052C (Mamiya ZD) */\n  LIBRAW_FORMAT_68 = 21         /* Fujifilm GX680 */\n};\n\nenum LibRawImageAspects\n{\n  LIBRAW_IMAGE_ASPECT_UNKNOWN = 0,\n  LIBRAW_IMAGE_ASPECT_3to2 = 1,\n  LIBRAW_IMAGE_ASPECT_1to1 = 2,\n  LIBRAW_IMAGE_ASPECT_4to3 = 3,\n  LIBRAW_IMAGE_ASPECT_16to9 = 4,\n  LIBRAW_IMAGE_ASPECT_5to4 = 5,\n  LIBRAW_IMAGE_ASPECT_OTHER = 6\n};\n\nenum LibRaw_lens_focal_types\n{\n  LIBRAW_FT_UNDEFINED = 0,\n  LIBRAW_FT_PRIME_LENS = 1,\n  LIBRAW_FT_ZOOM_LENS = 2,\n  LIBRAW_FT_ZOOM_LENS_CONSTANT_APERTURE = 3,\n  LIBRAW_FT_ZOOM_LENS_VARIABLE_APERTURE = 4\n};\n\nenum LibRaw_sony_cameratypes\n{\n  LIBRAW_SONY_DSC = 1,\n  LIBRAW_SONY_DSLR = 2,\n  LIBRAW_SONY_NEX = 3,\n  LIBRAW_SONY_SLT = 4,\n  LIBRAW_SONY_ILCE = 5,\n  LIBRAW_SONY_ILCA = 6\n};\n\nenum LibRaw_KodakSensors\n{\n  LIBRAW_Kodak_UnknownSensor = 0,\n  LIBRAW_Kodak_M1 = 1,\n  LIBRAW_Kodak_M15 = 2,\n  LIBRAW_Kodak_M16 = 3,\n  LIBRAW_Kodak_M17 = 4,\n  LIBRAW_Kodak_M2 = 5,\n  LIBRAW_Kodak_M23 = 6,\n  LIBRAW_Kodak_M24 = 7,\n  LIBRAW_Kodak_M3 = 8,\n  LIBRAW_Kodak_M5 = 9,\n  LIBRAW_Kodak_M6 = 10,\n  LIBRAW_Kodak_C14 = 11,\n  LIBRAW_Kodak_X14 = 12,\n  LIBRAW_Kodak_M11 = 13\n};\n\nenum LibRaw_HasselbladFormatCodes {\n  LIBRAW_HF_Unknown = 0,\n  LIBRAW_HF_3FR,\n  LIBRAW_HF_FFF,\n  LIBRAW_HF_Imacon,\n  LIBRAW_HF_HasselbladDNG,\n  LIBRAW_HF_AdobeDNG,\n  LIBRAW_HF_AdobeDNG_fromPhocusDNG\n};\n\nenum LibRaw_processing_options\n{\n  LIBRAW_PROCESSING_SONYARW2_NONE = 0,\n  LIBRAW_PROCESSING_SONYARW2_BASEONLY = 1,\n  LIBRAW_PROCESSING_SONYARW2_DELTAONLY = 1 << 1,\n  LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE = 1 << 2,\n  LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE = 1 << 3,\n  LIBRAW_PROCESSING_SONYARW2_ALLFLAGS =\n      LIBRAW_PROCESSING_SONYARW2_BASEONLY +\n      LIBRAW_PROCESSING_SONYARW2_DELTAONLY +\n      LIBRAW_PROCESSING_SONYARW2_DELTAZEROBASE +\n      LIBRAW_PROCESSING_SONYARW2_DELTATOVALUE,\n  LIBRAW_PROCESSING_DP2Q_INTERPOLATERG = 1 << 4,\n  LIBRAW_PROCESSING_DP2Q_INTERPOLATEAF = 1 << 5,\n  LIBRAW_PROCESSING_PENTAX_PS_ALLFRAMES = 1 << 6,\n  LIBRAW_PROCESSING_CONVERTFLOAT_TO_INT = 1 << 7,\n  LIBRAW_PROCESSING_SRAW_NO_RGB = 1 << 8,\n  LIBRAW_PROCESSING_SRAW_NO_INTERPOLATE = 1 << 9,\n  LIBRAW_PROCESSING_NO_ROTATE_FOR_KODAK_THUMBNAILS = 1 << 11,\n  LIBRAW_PROCESSING_USE_DNG_DEFAULT_CROP = 1 << 12,\n  LIBRAW_PROCESSING_USE_PPM16_THUMBS = 1 << 13,\n  LIBRAW_PROCESSING_SKIP_MAKERNOTES = 1 << 14,\n  LIBRAW_PROCESSING_DONT_CHECK_DNG_ILLUMINANT = 1 << 15,\n  LIBRAW_PROCESSING_DNGSDK_ZEROCOPY = 1 << 16,\n  LIBRAW_PROCESSING_ZEROFILTERS_FOR_MONOCHROMETIFFS = 1 << 17,\n  LIBRAW_PROCESSING_DNG_ADD_ENHANCED = 1 << 18,\n  LIBRAW_PROCESSING_DNG_ADD_PREVIEWS = 1 << 19,\n  LIBRAW_PROCESSING_DNG_PREFER_LARGEST_IMAGE = 1 << 20\n};\n\nenum LibRaw_decoder_flags\n{\n  LIBRAW_DECODER_HASCURVE = 1 << 4,\n  LIBRAW_DECODER_SONYARW2 = 1 << 5,\n  LIBRAW_DECODER_TRYRAWSPEED = 1 << 6,\n  LIBRAW_DECODER_OWNALLOC = 1 << 7,\n  LIBRAW_DECODER_FIXEDMAXC = 1 << 8,\n  LIBRAW_DECODER_ADOBECOPYPIXEL = 1 << 9,\n  LIBRAW_DECODER_LEGACY_WITH_MARGINS = 1 << 10,\n  LIBRAW_DECODER_3CHANNEL = 1 << 11,\n  LIBRAW_DECODER_SINAR4SHOT = 1 << 11,\n  LIBRAW_DECODER_FLATDATA = 1 << 12,\n  LIBRAW_DECODER_FLAT_BG2_SWAPPED = 1<<13,\n  LIBRAW_DECODER_NOTSET = 1 << 15\n};\n\n#define LIBRAW_XTRANS 9\n\nenum LibRaw_constructor_flags\n{\n  LIBRAW_OPTIONS_NONE = 0,\n  LIBRAW_OPIONS_NO_MEMERR_CALLBACK = 1,\n  LIBRAW_OPIONS_NO_DATAERR_CALLBACK = 1 << 1\n};\n\nenum LibRaw_warnings\n{\n  LIBRAW_WARN_NONE = 0,\n  LIBRAW_WARN_BAD_CAMERA_WB = 1 << 2,\n  LIBRAW_WARN_NO_METADATA = 1 << 3,\n  LIBRAW_WARN_NO_JPEGLIB = 1 << 4,\n  LIBRAW_WARN_NO_EMBEDDED_PROFILE = 1 << 5,\n  LIBRAW_WARN_NO_INPUT_PROFILE = 1 << 6,\n  LIBRAW_WARN_BAD_OUTPUT_PROFILE = 1 << 7,\n  LIBRAW_WARN_NO_BADPIXELMAP = 1 << 8,\n  LIBRAW_WARN_BAD_DARKFRAME_FILE = 1 << 9,\n  LIBRAW_WARN_BAD_DARKFRAME_DIM = 1 << 10,\n  LIBRAW_WARN_NO_JASPER = 1 << 11,\n  LIBRAW_WARN_RAWSPEED_PROBLEM = 1 << 12,\n  LIBRAW_WARN_RAWSPEED_UNSUPPORTED = 1 << 13,\n  LIBRAW_WARN_RAWSPEED_PROCESSED = 1 << 14,\n  LIBRAW_WARN_FALLBACK_TO_AHD = 1 << 15,\n  LIBRAW_WARN_PARSEFUJI_PROCESSED = 1 << 16,\n  LIBRAW_WARN_DNGSDK_PROCESSED = 1 << 17,\n  LIBRAW_WARN_DNG_IMAGES_REORDERED = 1 << 18\n};\n\nenum LibRaw_exceptions\n{\n  LIBRAW_EXCEPTION_NONE = 0,\n  LIBRAW_EXCEPTION_ALLOC = 1,\n  LIBRAW_EXCEPTION_DECODE_RAW = 2,\n  LIBRAW_EXCEPTION_DECODE_JPEG = 3,\n  LIBRAW_EXCEPTION_IO_EOF = 4,\n  LIBRAW_EXCEPTION_IO_CORRUPT = 5,\n  LIBRAW_EXCEPTION_CANCELLED_BY_CALLBACK = 6,\n  LIBRAW_EXCEPTION_BAD_CROP = 7,\n  LIBRAW_EXCEPTION_IO_BADFILE = 8,\n  LIBRAW_EXCEPTION_DECODE_JPEG2000 = 9,\n  LIBRAW_EXCEPTION_TOOBIG = 10,\n  LIBRAW_EXCEPTION_MEMPOOL = 11\n};\n\nenum LibRaw_progress\n{\n  LIBRAW_PROGRESS_START = 0,\n  LIBRAW_PROGRESS_OPEN = 1,\n  LIBRAW_PROGRESS_IDENTIFY = 1 << 1,\n  LIBRAW_PROGRESS_SIZE_ADJUST = 1 << 2,\n  LIBRAW_PROGRESS_LOAD_RAW = 1 << 3,\n  LIBRAW_PROGRESS_RAW2_IMAGE = 1 << 4,\n  LIBRAW_PROGRESS_REMOVE_ZEROES = 1 << 5,\n  LIBRAW_PROGRESS_BAD_PIXELS = 1 << 6,\n  LIBRAW_PROGRESS_DARK_FRAME = 1 << 7,\n  LIBRAW_PROGRESS_FOVEON_INTERPOLATE = 1 << 8,\n  LIBRAW_PROGRESS_SCALE_COLORS = 1 << 9,\n  LIBRAW_PROGRESS_PRE_INTERPOLATE = 1 << 10,\n  LIBRAW_PROGRESS_INTERPOLATE = 1 << 11,\n  LIBRAW_PROGRESS_MIX_GREEN = 1 << 12,\n  LIBRAW_PROGRESS_MEDIAN_FILTER = 1 << 13,\n  LIBRAW_PROGRESS_HIGHLIGHTS = 1 << 14,\n  LIBRAW_PROGRESS_FUJI_ROTATE = 1 << 15,\n  LIBRAW_PROGRESS_FLIP = 1 << 16,\n  LIBRAW_PROGRESS_APPLY_PROFILE = 1 << 17,\n  LIBRAW_PROGRESS_CONVERT_RGB = 1 << 18,\n  LIBRAW_PROGRESS_STRETCH = 1 << 19,\n  /* reserved */\n  LIBRAW_PROGRESS_STAGE20 = 1 << 20,\n  LIBRAW_PROGRESS_STAGE21 = 1 << 21,\n  LIBRAW_PROGRESS_STAGE22 = 1 << 22,\n  LIBRAW_PROGRESS_STAGE23 = 1 << 23,\n  LIBRAW_PROGRESS_STAGE24 = 1 << 24,\n  LIBRAW_PROGRESS_STAGE25 = 1 << 25,\n  LIBRAW_PROGRESS_STAGE26 = 1 << 26,\n  LIBRAW_PROGRESS_STAGE27 = 1 << 27,\n\n  LIBRAW_PROGRESS_THUMB_LOAD = 1 << 28,\n  LIBRAW_PROGRESS_TRESERVED1 = 1 << 29,\n  LIBRAW_PROGRESS_TRESERVED2 = 1 << 30,\n  LIBRAW_PROGRESS_TRESERVED3 = 1 << 31\n};\n#define LIBRAW_PROGRESS_THUMB_MASK 0x0fffffff\n\nenum LibRaw_errors\n{\n  LIBRAW_SUCCESS = 0,\n  LIBRAW_UNSPECIFIED_ERROR = -1,\n  LIBRAW_FILE_UNSUPPORTED = -2,\n  LIBRAW_REQUEST_FOR_NONEXISTENT_IMAGE = -3,\n  LIBRAW_OUT_OF_ORDER_CALL = -4,\n  LIBRAW_NO_THUMBNAIL = -5,\n  LIBRAW_UNSUPPORTED_THUMBNAIL = -6,\n  LIBRAW_INPUT_CLOSED = -7,\n  LIBRAW_NOT_IMPLEMENTED = -8,\n  LIBRAW_UNSUFFICIENT_MEMORY = -100007,\n  LIBRAW_DATA_ERROR = -100008,\n  LIBRAW_IO_ERROR = -100009,\n  LIBRAW_CANCELLED_BY_CALLBACK = -100010,\n  LIBRAW_BAD_CROP = -100011,\n  LIBRAW_TOO_BIG = -100012,\n  LIBRAW_MEMPOOL_OVERFLOW = -100013\n};\n\n#define LIBRAW_FATAL_ERROR(ec) ((ec) < -100000)\n\nenum LibRaw_thumbnail_formats\n{\n  LIBRAW_THUMBNAIL_UNKNOWN = 0,\n  LIBRAW_THUMBNAIL_JPEG = 1,\n  LIBRAW_THUMBNAIL_BITMAP = 2,\n  LIBRAW_THUMBNAIL_BITMAP16 = 3,\n  LIBRAW_THUMBNAIL_LAYER = 4,\n  LIBRAW_THUMBNAIL_ROLLEI = 5\n};\n\nenum LibRaw_image_formats\n{\n  LIBRAW_IMAGE_JPEG = 1,\n  LIBRAW_IMAGE_BITMAP = 2\n};\n\n#endif\n", "/* -*- C++ -*-\r\n * File: libraw_crxdec.cpp\r\n * Copyright (C) 2018-2019 Alexey Danilchenko\r\n * Copyright (C) 2019 Alex Tutubalin, LibRaw LLC\r\n *\r\n   Canon CR3 file decoder\r\n\r\nLibRaw is free software; you can redistribute it and/or modify\r\nit under the terms of the one of two licenses as you choose:\r\n\r\n1. GNU LESSER GENERAL PUBLIC LICENSE version 2.1\r\n   (See file LICENSE.LGPL provided in LibRaw distribution archive for details).\r\n\r\n2. COMMON DEVELOPMENT AND DISTRIBUTION LICENSE (CDDL) Version 1.0\r\n   (See file LICENSE.CDDL provided in LibRaw distribution archive for details).\r\n\r\n */\r\n\r\n#include \"../../internal/libraw_cxx_defs.h\"\r\n\r\n#ifdef _abs\r\n#undef _abs\r\n#undef _min\r\n#undef _constrain\r\n#endif\r\n#define _abs(x) (((x) ^ ((int32_t)(x) >> 31)) - ((int32_t)(x) >> 31))\r\n#define _min(a, b) ((a) < (b) ? (a) : (b))\r\n#define _constrain(x, l, u) ((x) < (l) ? (l) : ((x) > (u) ? (u) : (x)))\r\n\r\n#if defined(__clang__) || defined(__GNUG__)\r\n#define libraw_inline inline __attribute__((always_inline))\r\n#elif defined(_MSC_VER) && _MSC_VER > 1400\r\n#define libraw_inline __forceinline\r\n#else\r\n#define libraw_inline inline\r\n#endif\r\n\r\n// this should be divisible by 4\r\n#define CRX_BUF_SIZE 0x10000\r\n#if !defined(_WIN32) || (defined (__GNUC__) && !defined(__INTRINSIC_SPECIAL__BitScanReverse))  \r\n/* __INTRINSIC_SPECIAL__BitScanReverse found in MinGW32-W64 v7.30 headers, may be there is a better solution? */\r\ntypedef uint32_t DWORD;\r\ntypedef uint8_t byte;\r\nlibraw_inline void _BitScanReverse(DWORD *Index, unsigned long Mask)\r\n{\r\n  *Index = sizeof(unsigned long) * 8 - 1 - __builtin_clzl(Mask);\r\n}\r\n#if LibRawBigEndian\r\n#define _byteswap_ulong(x) (x)\r\n#else\r\n#define _byteswap_ulong(x) __builtin_bswap32(x)\r\n#endif\r\n#endif\r\n\r\nstruct CrxBitstream\r\n{\r\n  uint8_t mdatBuf[CRX_BUF_SIZE];\r\n  uint64_t mdatSize;\r\n  uint64_t curBufOffset;\r\n  uint32_t curPos;\r\n  uint32_t curBufSize;\r\n  uint32_t bitData;\r\n  int32_t bitsLeft;\r\n  LibRaw_abstract_datastream *input;\r\n};\r\n\r\nstruct CrxBandParam\r\n{\r\n  CrxBitstream bitStream;\r\n  int16_t subbandWidth;\r\n  int16_t subbandHeight;\r\n  int32_t roundedBitsMask;\r\n  int32_t roundedBits;\r\n  int16_t curLine;\r\n  int32_t *lineBuf0;\r\n  int32_t *lineBuf1;\r\n  int32_t *lineBuf2;\r\n  int32_t sParam;\r\n  int32_t kParam;\r\n  int32_t *paramData;\r\n  int32_t *nonProgrData;\r\n  int8_t supportsPartial;\r\n};\r\n\r\nstruct CrxWaveletTransform\r\n{\r\n  int32_t *subband0Buf;\r\n  int32_t *subband1Buf;\r\n  int32_t *subband2Buf;\r\n  int32_t *subband3Buf;\r\n  int32_t *lineBuf[8];\r\n  int16_t curLine;\r\n  int16_t curH;\r\n  int8_t fltTapH;\r\n  int16_t height;\r\n  int16_t width;\r\n};\r\n\r\nstruct CrxSubband\r\n{\r\n  CrxBandParam *bandParam;\r\n  uint64_t mdatOffset;\r\n  uint8_t *bandBuf;\r\n  int32_t bandSize;\r\n  uint64_t dataSize;\r\n  int8_t supportsPartial;\r\n  int32_t quantValue;\r\n  uint16_t width;\r\n  uint16_t height;\r\n  int32_t paramK;\r\n  int64_t dataOffset;\r\n};\r\n\r\nstruct CrxPlaneComp\r\n{\r\n  byte *compBuf;\r\n  CrxSubband *subBands;\r\n  CrxWaveletTransform *waveletTransform;\r\n  int8_t compNumber;\r\n  int64_t dataOffset;\r\n  int32_t compSize;\r\n  int8_t supportsPartial;\r\n  int32_t roundedBitsMask;\r\n  int8_t tileFlag;\r\n};\r\n\r\nstruct CrxTile\r\n{\r\n  CrxPlaneComp *comps;\r\n  int8_t tileFlag;\r\n  int8_t tileNumber;\r\n  int64_t dataOffset;\r\n  int32_t tileSize;\r\n  uint16_t width;\r\n  uint16_t height;\r\n};\r\n\r\nstruct CrxImage\r\n{\r\n  uint8_t nPlanes;\r\n  uint16_t planeWidth;\r\n  uint16_t planeHeight;\r\n  uint8_t samplePrecision;\r\n  uint8_t subbandCount;\r\n  uint8_t levels;\r\n  uint8_t nBits;\r\n  uint8_t encType;\r\n  uint8_t tileCols;\r\n  uint8_t tileRows;\r\n  CrxTile *tiles;\r\n  uint64_t mdatOffset;\r\n  uint64_t mdatSize;\r\n  int16_t *outBufs[4]; // one per plane\r\n  int16_t *planeBuf;\r\n  LibRaw_abstract_datastream *input;\r\n#ifdef LIBRAW_CR3_MEMPOOL\r\n  libraw_memmgr memmgr;\r\n  CrxImage() : memmgr(0){}\r\n#endif\r\n};\r\n\r\nenum TileFlags\r\n{\r\n  E_HAS_TILES_ON_THE_RIGHT = 1,\r\n  E_HAS_TILES_ON_THE_LEFT = 2,\r\n  E_HAS_TILES_ON_THE_BOTTOM = 4,\r\n  E_HAS_TILES_ON_THE_TOP = 8\r\n};\r\n\r\nint32_t exCoefNumTbl[0x120] = {\r\n    // level 1\r\n    1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,\r\n    1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,\r\n    1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,\r\n    1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,\r\n\r\n    // level 2\r\n    1, 1, 3, 3, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 3, 2, 1, 0, 1, 0, 0, 0, 0, 0, 1,\r\n    2, 4, 4, 2, 1, 2, 1, 0, 0, 0, 0, 1, 1, 4, 3, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1,\r\n    3, 3, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 3, 2, 1, 0, 1, 0, 0, 0, 0, 0, 1, 2, 4,\r\n    4, 2, 1, 2, 1, 0, 0, 0, 0, 1, 1, 4, 3, 1, 1, 1, 1, 0, 0, 0, 0,\r\n\r\n    // level 3\r\n    1, 1, 7, 7, 1, 1, 3, 3, 1, 1, 1, 1, 1, 0, 7, 6, 1, 0, 3, 2, 1, 0, 1, 0, 1,\r\n    2, 10, 10, 2, 2, 5, 4, 2, 1, 2, 1, 1, 1, 10, 9, 1, 2, 4, 4, 2, 1, 2, 1, 1,\r\n    1, 9, 9, 1, 2, 4, 4, 2, 1, 2, 1, 1, 0, 9, 8, 1, 1, 4, 3, 1, 1, 1, 1, 1, 2,\r\n    8, 8, 2, 1, 4, 3, 1, 1, 1, 1, 1, 1, 8, 7, 1, 1, 3, 3, 1, 1, 1, 1};\r\n\r\nuint32_t JS[32] = {1,     1,     1,     1,     2,      2,      2,      2,\r\n                   4,     4,     4,     4,     8,      8,      8,      8,\r\n                   0x10,  0x10,  0x20,  0x20,  0x40,   0x40,   0x80,   0x80,\r\n                   0x100, 0x200, 0x400, 0x800, 0x1000, 0x2000, 0x4000, 0x8000};\r\n\r\nuint32_t J[32] = {0, 0, 0, 0, 1,    1,    1,    1,    2,    2,   2,\r\n                  2, 3, 3, 3, 3,    4,    4,    5,    5,    6,   6,\r\n                  7, 7, 8, 9, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F};\r\n\r\nstatic inline void crxFillBuffer(CrxBitstream *bitStrm)\r\n{\r\n  if (bitStrm->curPos >= bitStrm->curBufSize && bitStrm->mdatSize)\r\n  {\r\n    bitStrm->curPos = 0;\r\n    bitStrm->curBufOffset += bitStrm->curBufSize;\r\n#ifdef LIBRAW_USE_OPENMP\r\n#pragma omp critical\r\n#endif\r\n    {\r\n#ifndef LIBRAW_USE_OPENMP\r\n      bitStrm->input->lock();\r\n#endif\r\n      bitStrm->input->seek(bitStrm->curBufOffset, SEEK_SET);\r\n      bitStrm->curBufSize = bitStrm->input->read(\r\n          bitStrm->mdatBuf, 1, _min(bitStrm->mdatSize, CRX_BUF_SIZE));\r\n#ifndef LIBRAW_USE_OPENMP\r\n      bitStrm->input->unlock();\r\n#endif\r\n      if (bitStrm->curBufSize < 1) // nothing read\r\n        throw LIBRAW_EXCEPTION_IO_EOF;\r\n      bitStrm->mdatSize -= bitStrm->curBufSize;\r\n    }\r\n  }\r\n}\r\n\r\nlibraw_inline int crxBitstreamGetZeros(CrxBitstream *bitStrm)\r\n{\r\n  uint32_t bitData = bitStrm->bitData;\r\n  uint32_t nonZeroBit = 0;\r\n  uint64_t nextData = 0;\r\n  int32_t result = 0;\r\n\r\n  if (bitStrm->bitData)\r\n  {\r\n    _BitScanReverse((DWORD *)&nonZeroBit, (DWORD)bitStrm->bitData);\r\n    result = 31 - nonZeroBit;\r\n    bitStrm->bitData <<= 32 - nonZeroBit;\r\n    bitStrm->bitsLeft -= 32 - nonZeroBit;\r\n  }\r\n  else\r\n  {\r\n    uint32_t bitsLeft = bitStrm->bitsLeft;\r\n    while (1)\r\n    {\r\n      while (bitStrm->curPos + 4 <= bitStrm->curBufSize)\r\n      {\r\n        nextData =\r\n            _byteswap_ulong(*(uint32_t *)(bitStrm->mdatBuf + bitStrm->curPos));\r\n        bitStrm->curPos += 4;\r\n        crxFillBuffer(bitStrm);\r\n        if (nextData)\r\n        {\r\n          _BitScanReverse((DWORD *)&nonZeroBit, (DWORD)nextData);\r\n          result = bitsLeft + 31 - nonZeroBit;\r\n          bitStrm->bitData = nextData << (32 - nonZeroBit);\r\n          bitStrm->bitsLeft = nonZeroBit;\r\n          return result;\r\n        }\r\n        bitsLeft += 32;\r\n      }\r\n      if (bitStrm->curBufSize < bitStrm->curPos + 1)\r\n        break; // error\r\n      nextData = bitStrm->mdatBuf[bitStrm->curPos++];\r\n      crxFillBuffer(bitStrm);\r\n      if (nextData)\r\n        break;\r\n      bitsLeft += 8;\r\n    }\r\n    _BitScanReverse((DWORD *)&nonZeroBit, (DWORD)nextData);\r\n    result = (uint32_t)(bitsLeft + 7 - nonZeroBit);\r\n    bitStrm->bitData = nextData << (32 - nonZeroBit);\r\n    bitStrm->bitsLeft = nonZeroBit;\r\n  }\r\n  return result;\r\n}\r\n\r\nlibraw_inline uint32_t crxBitstreamGetBits(CrxBitstream *bitStrm, int bits)\r\n{\r\n  int bitsLeft = bitStrm->bitsLeft;\r\n  uint32_t bitData = bitStrm->bitData;\r\n  uint32_t nextWord;\r\n  uint8_t nextByte;\r\n  uint32_t result;\r\n\r\n  if (bitsLeft < bits)\r\n  {\r\n    // get them from stream\r\n    if (bitStrm->curPos + 4 <= bitStrm->curBufSize)\r\n    {\r\n      nextWord =\r\n          _byteswap_ulong(*(uint32_t *)(bitStrm->mdatBuf + bitStrm->curPos));\r\n      bitStrm->curPos += 4;\r\n      crxFillBuffer(bitStrm);\r\n      bitStrm->bitsLeft = 32 - (bits - bitsLeft);\r\n      result = ((nextWord >> bitsLeft) | bitData) >> (32 - bits);\r\n      bitStrm->bitData = nextWord << (bits - bitsLeft);\r\n      return result;\r\n    }\r\n    // less than a word left - read byte at a time\r\n    do\r\n    {\r\n      if (bitStrm->curPos >= bitStrm->curBufSize)\r\n        break; // error\r\n      bitsLeft += 8;\r\n      nextByte = bitStrm->mdatBuf[bitStrm->curPos++];\r\n      crxFillBuffer(bitStrm);\r\n      bitData |= nextByte << (32 - bitsLeft);\r\n    } while (bitsLeft < bits);\r\n  }\r\n  result = bitData >> (32 - bits); // 32-bits\r\n  bitStrm->bitData = bitData << bits;\r\n  bitStrm->bitsLeft = bitsLeft - bits;\r\n  return result;\r\n}\r\n\r\nlibraw_inline int crxPredictKParameter(int32_t prevK, int32_t bitCode,\r\n                                       int32_t maxVal = 0)\r\n{\r\n  int32_t newKParam = prevK - (bitCode < (1 << prevK >> 1)) +\r\n                      ((bitCode >> prevK) > 2) + ((bitCode >> prevK) > 5);\r\n\r\n  return !maxVal || newKParam < maxVal ? newKParam : maxVal;\r\n}\r\n\r\nlibraw_inline void crxDecodeSymbolL1(CrxBandParam *param,\r\n                                     int32_t doMedianPrediction,\r\n                                     int32_t notEOL = 0)\r\n{\r\n  if (doMedianPrediction)\r\n  {\r\n    int32_t symb[4];\r\n\r\n    int32_t delta = param->lineBuf0[1] - param->lineBuf0[0];\r\n    symb[2] = param->lineBuf1[0];\r\n    symb[0] = symb[1] = delta + symb[2];\r\n    symb[3] = param->lineBuf0[1];\r\n\r\n    param->lineBuf1[1] =\r\n        symb[(((param->lineBuf0[0] < param->lineBuf1[0]) ^ (delta < 0)) << 1) +\r\n             ((param->lineBuf1[0] < param->lineBuf0[1]) ^ (delta < 0))];\r\n  }\r\n  else\r\n    param->lineBuf1[1] = param->lineBuf0[1];\r\n\r\n  // get next error symbol\r\n  uint32_t bitCode = crxBitstreamGetZeros(&param->bitStream);\r\n  if (bitCode >= 41)\r\n    bitCode = crxBitstreamGetBits(&param->bitStream, 21);\r\n  else if (param->kParam)\r\n    bitCode = crxBitstreamGetBits(&param->bitStream, param->kParam) |\r\n              (bitCode << param->kParam);\r\n\r\n  // add converted (+/-) error code to predicted value\r\n  param->lineBuf1[1] += -(bitCode & 1) ^ (bitCode >> 1);\r\n\r\n  // for not end of the line - use one symbol ahead to estimate next K\r\n  if (notEOL)\r\n  {\r\n    int32_t nextDelta = (param->lineBuf0[2] - param->lineBuf0[1]) << 1;\r\n    bitCode = (bitCode + _abs(nextDelta)) >> 1;\r\n    ++param->lineBuf0;\r\n  }\r\n\r\n  // update K parameter\r\n  param->kParam = crxPredictKParameter(param->kParam, bitCode, 15);\r\n\r\n  ++param->lineBuf1;\r\n}\r\n\r\nint crxDecodeLine(CrxBandParam *param)\r\n{\r\n  int length = param->subbandWidth;\r\n\r\n  param->lineBuf1[0] = param->lineBuf0[1];\r\n  for (; length > 1; --length)\r\n  {\r\n    if (param->lineBuf1[0] != param->lineBuf0[1] ||\r\n        param->lineBuf1[0] != param->lineBuf0[2])\r\n    {\r\n      crxDecodeSymbolL1(param, 1, 1);\r\n    }\r\n    else\r\n    {\r\n      int nSyms = 0;\r\n      if (crxBitstreamGetBits(&param->bitStream, 1))\r\n      {\r\n        nSyms = 1;\r\n        while (crxBitstreamGetBits(&param->bitStream, 1))\r\n        {\r\n          nSyms += JS[param->sParam];\r\n          if (nSyms > length)\r\n          {\r\n            nSyms = length;\r\n            break;\r\n          }\r\n          if (param->sParam < 31)\r\n            ++param->sParam;\r\n          if (nSyms == length)\r\n            break;\r\n        }\r\n\r\n        if (nSyms < length)\r\n        {\r\n          if (J[param->sParam])\r\n            nSyms += crxBitstreamGetBits(&param->bitStream, J[param->sParam]);\r\n          if (param->sParam > 0)\r\n            --param->sParam;\r\n          if (nSyms > length)\r\n            return -1;\r\n        }\r\n\r\n        length -= nSyms;\r\n\r\n        // copy symbol nSyms times\r\n        param->lineBuf0 += nSyms;\r\n\r\n        // copy symbol nSyms times\r\n        while (nSyms-- > 0)\r\n        {\r\n          param->lineBuf1[1] = param->lineBuf1[0];\r\n          ++param->lineBuf1;\r\n        }\r\n      }\r\n\r\n      if (length > 0)\r\n        crxDecodeSymbolL1(param, 0, (length > 1));\r\n    }\r\n  }\r\n\r\n  if (length == 1)\r\n    crxDecodeSymbolL1(param, 1, 0);\r\n\r\n  param->lineBuf1[1] = param->lineBuf1[0] + 1;\r\n\r\n  return 0;\r\n}\r\n\r\nlibraw_inline void crxDecodeSymbolL1Rounded(CrxBandParam *param,\r\n                                            int32_t doSym = 1,\r\n                                            int32_t doCode = 1)\r\n{\r\n  int32_t sym = param->lineBuf0[1];\r\n\r\n  if (doSym)\r\n  {\r\n    // calculate the next symbol gradient\r\n    int32_t symb[4];\r\n    int32_t deltaH = param->lineBuf0[1] - param->lineBuf0[0];\r\n    symb[2] = param->lineBuf1[0];\r\n    symb[0] = symb[1] = deltaH + symb[2];\r\n    symb[3] = param->lineBuf0[1];\r\n    sym =\r\n        symb[(((param->lineBuf0[0] < param->lineBuf1[0]) ^ (deltaH < 0)) << 1) +\r\n             ((param->lineBuf1[0] < param->lineBuf0[1]) ^ (deltaH < 0))];\r\n  }\r\n\r\n  uint32_t bitCode = crxBitstreamGetZeros(&param->bitStream);\r\n  if (bitCode >= 41)\r\n    bitCode = crxBitstreamGetBits(&param->bitStream, 21);\r\n  else if (param->kParam)\r\n    bitCode = crxBitstreamGetBits(&param->bitStream, param->kParam) |\r\n              (bitCode << param->kParam);\r\n  int32_t code = -(bitCode & 1) ^ (bitCode >> 1);\r\n  param->lineBuf1[1] = param->roundedBitsMask * 2 * code + (code >> 31) + sym;\r\n\r\n  if (doCode)\r\n  {\r\n    if (param->lineBuf0[2] > param->lineBuf0[1])\r\n      code = (param->lineBuf0[2] - param->lineBuf0[1] + param->roundedBitsMask -\r\n              1) >>\r\n             param->roundedBits;\r\n    else\r\n      code = -(\r\n          (param->lineBuf0[1] - param->lineBuf0[2] + param->roundedBitsMask) >>\r\n          param->roundedBits);\r\n\r\n    param->kParam = crxPredictKParameter(param->kParam,\r\n                                         (bitCode + 2 * _abs(code)) >> 1, 15);\r\n  }\r\n  else\r\n    param->kParam = crxPredictKParameter(param->kParam, bitCode, 15);\r\n\r\n  ++param->lineBuf1;\r\n}\r\n\r\nint crxDecodeLineRounded(CrxBandParam *param)\r\n{\r\n  int32_t valueReached = 0;\r\n\r\n  param->lineBuf0[0] = param->lineBuf0[1];\r\n  param->lineBuf1[0] = param->lineBuf0[1];\r\n  int32_t length = param->subbandWidth;\r\n\r\n  for (; length > 1; --length)\r\n  {\r\n    if (_abs(param->lineBuf0[2] - param->lineBuf0[1]) > param->roundedBitsMask)\r\n    {\r\n      crxDecodeSymbolL1Rounded(param);\r\n      ++param->lineBuf0;\r\n      valueReached = 1;\r\n    }\r\n    else if (valueReached || _abs(param->lineBuf0[0] - param->lineBuf1[0]) >\r\n                                 param->roundedBitsMask)\r\n    {\r\n      crxDecodeSymbolL1Rounded(param);\r\n      ++param->lineBuf0;\r\n      valueReached = 0;\r\n    }\r\n    else\r\n    {\r\n      int nSyms = 0;\r\n      if (crxBitstreamGetBits(&param->bitStream, 1))\r\n      {\r\n        nSyms = 1;\r\n        while (crxBitstreamGetBits(&param->bitStream, 1))\r\n        {\r\n          nSyms += JS[param->sParam];\r\n          if (nSyms > length)\r\n          {\r\n            nSyms = length;\r\n            break;\r\n          }\r\n          if (param->sParam < 31)\r\n            ++param->sParam;\r\n          if (nSyms == length)\r\n            break;\r\n        }\r\n        if (nSyms < length)\r\n        {\r\n          if (J[param->sParam])\r\n            nSyms += crxBitstreamGetBits(&param->bitStream, J[param->sParam]);\r\n          if (param->sParam > 0)\r\n            --param->sParam;\r\n        }\r\n        if (nSyms > length)\r\n          return -1;\r\n      }\r\n      length -= nSyms;\r\n\r\n      // copy symbol nSyms times\r\n      param->lineBuf0 += nSyms;\r\n\r\n      // copy symbol nSyms times\r\n      while (nSyms-- > 0)\r\n      {\r\n        param->lineBuf1[1] = param->lineBuf1[0];\r\n        ++param->lineBuf1;\r\n      }\r\n\r\n      if (length > 1)\r\n      {\r\n        crxDecodeSymbolL1Rounded(param, 0);\r\n        ++param->lineBuf0;\r\n        valueReached = _abs(param->lineBuf0[1] - param->lineBuf0[0]) >\r\n                       param->roundedBitsMask;\r\n      }\r\n      else if (length == 1)\r\n        crxDecodeSymbolL1Rounded(param, 0, 0);\r\n    }\r\n  }\r\n  if (length == 1)\r\n    crxDecodeSymbolL1Rounded(param, 1, 0);\r\n\r\n  param->lineBuf1[1] = param->lineBuf1[0] + 1;\r\n\r\n  return 0;\r\n}\r\n\r\nint crxDecodeLineNoRefPrevLine(CrxBandParam *param)\r\n{\r\n  int32_t i = 0;\r\n\r\n  for (; i < param->subbandWidth - 1; i++)\r\n  {\r\n    if (param->lineBuf0[i + 2] | param->lineBuf0[i + 1] | param->lineBuf1[i])\r\n    {\r\n      uint32_t bitCode = crxBitstreamGetZeros(&param->bitStream);\r\n      if (bitCode >= 41)\r\n        bitCode = crxBitstreamGetBits(&param->bitStream, 21);\r\n      else if (param->kParam)\r\n        bitCode = crxBitstreamGetBits(&param->bitStream, param->kParam) |\r\n                  (bitCode << param->kParam);\r\n      param->lineBuf1[i + 1] = -(bitCode & 1) ^ (bitCode >> 1);\r\n      param->kParam = crxPredictKParameter(param->kParam, bitCode);\r\n      if (param->lineBuf2[i + 1] - param->kParam <= 1)\r\n      {\r\n        if (param->kParam >= 15)\r\n          param->kParam = 15;\r\n      }\r\n      else\r\n        ++param->kParam;\r\n    }\r\n    else\r\n    {\r\n      int nSyms = 0;\r\n      if (crxBitstreamGetBits(&param->bitStream, 1))\r\n      {\r\n        nSyms = 1;\r\n        if (i != param->subbandWidth - 1)\r\n        {\r\n          while (crxBitstreamGetBits(&param->bitStream, 1))\r\n          {\r\n            nSyms += JS[param->sParam];\r\n            if (i + nSyms > param->subbandWidth)\r\n            {\r\n              nSyms = param->subbandWidth - i;\r\n              break;\r\n            }\r\n            if (param->sParam < 31)\r\n              ++param->sParam;\r\n            if (i + nSyms == param->subbandWidth)\r\n              break;\r\n          }\r\n          if (i + nSyms < param->subbandWidth)\r\n          {\r\n            if (J[param->sParam])\r\n              nSyms += crxBitstreamGetBits(&param->bitStream, J[param->sParam]);\r\n            if (param->sParam > 0)\r\n              --param->sParam;\r\n          }\r\n          if (i + nSyms > param->subbandWidth)\r\n            return -1;\r\n        }\r\n      }\r\n      else if (i > param->subbandWidth)\r\n        return -1;\r\n\r\n      if (nSyms > 0)\r\n      {\r\n        memset(param->lineBuf1 + i + 1, 0, nSyms * sizeof(int32_t));\r\n        memset(param->lineBuf2 + i, 0, nSyms * sizeof(int32_t));\r\n        i += nSyms;\r\n      }\r\n\r\n      if (i >= param->subbandWidth - 1)\r\n      {\r\n        if (i == param->subbandWidth - 1)\r\n        {\r\n          uint32_t bitCode = crxBitstreamGetZeros(&param->bitStream);\r\n          if (bitCode >= 41)\r\n            bitCode = crxBitstreamGetBits(&param->bitStream, 21);\r\n          else if (param->kParam)\r\n            bitCode = crxBitstreamGetBits(&param->bitStream, param->kParam) |\r\n                      (bitCode << param->kParam);\r\n          param->lineBuf1[i + 1] = -((bitCode + 1) & 1) ^ ((bitCode + 1) >> 1);\r\n          param->kParam = crxPredictKParameter(param->kParam, bitCode, 15);\r\n          param->lineBuf2[i] = param->kParam;\r\n        }\r\n        continue;\r\n      }\r\n      else\r\n      {\r\n        uint32_t bitCode = crxBitstreamGetZeros(&param->bitStream);\r\n        if (bitCode >= 41)\r\n          bitCode = crxBitstreamGetBits(&param->bitStream, 21);\r\n        else if (param->kParam)\r\n          bitCode = crxBitstreamGetBits(&param->bitStream, param->kParam) |\r\n                    (bitCode << param->kParam);\r\n        param->lineBuf1[i + 1] = -((bitCode + 1) & 1) ^ ((bitCode + 1) >> 1);\r\n        param->kParam = crxPredictKParameter(param->kParam, bitCode);\r\n        if (param->lineBuf2[i + 1] - param->kParam <= 1)\r\n        {\r\n          if (param->kParam >= 15)\r\n            param->kParam = 15;\r\n        }\r\n        else\r\n          ++param->kParam;\r\n      }\r\n    }\r\n    param->lineBuf2[i] = param->kParam;\r\n  }\r\n  if (i == param->subbandWidth - 1)\r\n  {\r\n    int32_t bitCode = crxBitstreamGetZeros(&param->bitStream);\r\n    if (bitCode >= 41)\r\n      bitCode = crxBitstreamGetBits(&param->bitStream, 21);\r\n    else if (param->kParam)\r\n      bitCode = crxBitstreamGetBits(&param->bitStream, param->kParam) |\r\n                (bitCode << param->kParam);\r\n    param->lineBuf1[i + 1] = -(bitCode & 1) ^ (bitCode >> 1);\r\n    param->kParam = crxPredictKParameter(param->kParam, bitCode, 15);\r\n    param->lineBuf2[i] = param->kParam;\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\nint crxDecodeTopLine(CrxBandParam *param)\r\n{\r\n  param->lineBuf1[0] = 0;\r\n\r\n  int32_t length = param->subbandWidth;\r\n\r\n  // read the line from bitstream\r\n  for (; length > 1; --length)\r\n  {\r\n    if (param->lineBuf1[0])\r\n      param->lineBuf1[1] = param->lineBuf1[0];\r\n    else\r\n    {\r\n      int nSyms = 0;\r\n      if (crxBitstreamGetBits(&param->bitStream, 1))\r\n      {\r\n        nSyms = 1;\r\n        while (crxBitstreamGetBits(&param->bitStream, 1))\r\n        {\r\n          nSyms += JS[param->sParam];\r\n          if (nSyms > length)\r\n          {\r\n            nSyms = length;\r\n            break;\r\n          }\r\n          if (param->sParam < 31)\r\n            ++param->sParam;\r\n          if (nSyms == length)\r\n            break;\r\n        }\r\n        if (nSyms < length)\r\n        {\r\n          if (J[param->sParam])\r\n            nSyms += crxBitstreamGetBits(&param->bitStream, J[param->sParam]);\r\n          if (param->sParam > 0)\r\n            --param->sParam;\r\n          if (nSyms > length)\r\n            return -1;\r\n        }\r\n\r\n        length -= nSyms;\r\n\r\n        // copy symbol nSyms times\r\n        while (nSyms-- > 0)\r\n        {\r\n          param->lineBuf1[1] = param->lineBuf1[0];\r\n          ++param->lineBuf1;\r\n        }\r\n\r\n        if (length <= 0)\r\n          break;\r\n      }\r\n\r\n      param->lineBuf1[1] = 0;\r\n    }\r\n\r\n    uint32_t bitCode = crxBitstreamGetZeros(&param->bitStream);\r\n    if (bitCode >= 41)\r\n      bitCode = crxBitstreamGetBits(&param->bitStream, 21);\r\n    else if (param->kParam)\r\n      bitCode = crxBitstreamGetBits(&param->bitStream, param->kParam) |\r\n                (bitCode << param->kParam);\r\n    param->lineBuf1[1] += -(bitCode & 1) ^ (bitCode >> 1);\r\n    param->kParam = crxPredictKParameter(param->kParam, bitCode, 15);\r\n    ++param->lineBuf1;\r\n  }\r\n\r\n  if (length == 1)\r\n  {\r\n    param->lineBuf1[1] = param->lineBuf1[0];\r\n    uint32_t bitCode = crxBitstreamGetZeros(&param->bitStream);\r\n    if (bitCode >= 41)\r\n      bitCode = crxBitstreamGetBits(&param->bitStream, 21);\r\n    else if (param->kParam)\r\n      bitCode = crxBitstreamGetBits(&param->bitStream, param->kParam) |\r\n                (bitCode << param->kParam);\r\n    param->lineBuf1[1] += -(bitCode & 1) ^ (bitCode >> 1);\r\n    param->kParam = crxPredictKParameter(param->kParam, bitCode, 15);\r\n    ++param->lineBuf1;\r\n  }\r\n\r\n  param->lineBuf1[1] = param->lineBuf1[0] + 1;\r\n\r\n  return 0;\r\n}\r\n\r\nint crxDecodeTopLineRounded(CrxBandParam *param)\r\n{\r\n  param->lineBuf1[0] = 0;\r\n\r\n  int32_t length = param->subbandWidth;\r\n\r\n  // read the line from bitstream\r\n  for (; length > 1; --length)\r\n  {\r\n    if (_abs(param->lineBuf1[0]) > param->roundedBitsMask)\r\n      param->lineBuf1[1] = param->lineBuf1[0];\r\n    else\r\n    {\r\n      int nSyms = 0;\r\n      if (crxBitstreamGetBits(&param->bitStream, 1))\r\n      {\r\n        nSyms = 1;\r\n        while (crxBitstreamGetBits(&param->bitStream, 1))\r\n        {\r\n          nSyms += JS[param->sParam];\r\n          if (nSyms > length)\r\n          {\r\n            nSyms = length;\r\n            break;\r\n          }\r\n          if (param->sParam < 31)\r\n            ++param->sParam;\r\n          if (nSyms == length)\r\n            break;\r\n        }\r\n        if (nSyms < length)\r\n        {\r\n          if (J[param->sParam])\r\n            nSyms += crxBitstreamGetBits(&param->bitStream, J[param->sParam]);\r\n          if (param->sParam > 0)\r\n            --param->sParam;\r\n          if (nSyms > length)\r\n            return -1;\r\n        }\r\n      }\r\n\r\n      length -= nSyms;\r\n\r\n      // copy symbol nSyms times\r\n      while (nSyms-- > 0)\r\n      {\r\n        param->lineBuf1[1] = param->lineBuf1[0];\r\n        ++param->lineBuf1;\r\n      }\r\n\r\n      if (length <= 0)\r\n        break;\r\n\r\n      param->lineBuf1[1] = 0;\r\n    }\r\n\r\n    uint32_t bitCode = crxBitstreamGetZeros(&param->bitStream);\r\n    if (bitCode >= 41)\r\n      bitCode = crxBitstreamGetBits(&param->bitStream, 21);\r\n    else if (param->kParam)\r\n      bitCode = crxBitstreamGetBits(&param->bitStream, param->kParam) |\r\n                (bitCode << param->kParam);\r\n\r\n    int32_t sVal = -(bitCode & 1) ^ (bitCode >> 1);\r\n    param->lineBuf1[1] += param->roundedBitsMask * 2 * sVal + (sVal >> 31);\r\n    param->kParam = crxPredictKParameter(param->kParam, bitCode, 15);\r\n    ++param->lineBuf1;\r\n  }\r\n\r\n  if (length == 1)\r\n  {\r\n    uint32_t bitCode = crxBitstreamGetZeros(&param->bitStream);\r\n    if (bitCode >= 41)\r\n      bitCode = crxBitstreamGetBits(&param->bitStream, 21);\r\n    else if (param->kParam)\r\n      bitCode = crxBitstreamGetBits(&param->bitStream, param->kParam) |\r\n                (bitCode << param->kParam);\r\n    int32_t sVal = -(bitCode & 1) ^ (bitCode >> 1);\r\n    param->lineBuf1[1] += param->roundedBitsMask * 2 * sVal + (sVal >> 31);\r\n    param->kParam = crxPredictKParameter(param->kParam, bitCode, 15);\r\n    ++param->lineBuf1;\r\n  }\r\n\r\n  param->lineBuf1[1] = param->lineBuf1[0] + 1;\r\n\r\n  return 0;\r\n}\r\n\r\nint crxDecodeTopLineNoRefPrevLine(CrxBandParam *param)\r\n{\r\n  param->lineBuf0[0] = 0;\r\n  param->lineBuf1[0] = 0;\r\n  int32_t length = param->subbandWidth;\r\n  for (; length > 1; --length)\r\n  {\r\n    if (param->lineBuf1[0])\r\n    {\r\n      uint32_t bitCode = crxBitstreamGetZeros(&param->bitStream);\r\n      if (bitCode >= 41)\r\n        bitCode = crxBitstreamGetBits(&param->bitStream, 21);\r\n      else if (param->kParam)\r\n        bitCode = crxBitstreamGetBits(&param->bitStream, param->kParam) |\r\n                  (bitCode << param->kParam);\r\n      param->lineBuf1[1] = -(bitCode & 1) ^ (bitCode >> 1);\r\n      param->kParam = crxPredictKParameter(param->kParam, bitCode, 15);\r\n    }\r\n    else\r\n    {\r\n      int nSyms = 0;\r\n      if (crxBitstreamGetBits(&param->bitStream, 1))\r\n      {\r\n        nSyms = 1;\r\n        while (crxBitstreamGetBits(&param->bitStream, 1))\r\n        {\r\n          nSyms += JS[param->sParam];\r\n          if (nSyms > length)\r\n          {\r\n            nSyms = length;\r\n            break;\r\n          }\r\n          if (param->sParam < 31)\r\n            ++param->sParam;\r\n          if (nSyms == length)\r\n            break;\r\n        }\r\n        if (nSyms < length)\r\n        {\r\n          if (J[param->sParam])\r\n            nSyms += crxBitstreamGetBits(&param->bitStream, J[param->sParam]);\r\n          if (param->sParam > 0)\r\n            --param->sParam;\r\n          if (nSyms > length)\r\n            return -1;\r\n        }\r\n      }\r\n\r\n      length -= nSyms;\r\n\r\n      // copy symbol nSyms times\r\n      while (nSyms-- > 0)\r\n      {\r\n        param->lineBuf2[0] = 0;\r\n        param->lineBuf1[1] = 0;\r\n        ++param->lineBuf1;\r\n        ++param->lineBuf2;\r\n      }\r\n\r\n      if (length <= 0)\r\n        break;\r\n      uint32_t bitCode = crxBitstreamGetZeros(&param->bitStream);\r\n      if (bitCode >= 41)\r\n        bitCode = crxBitstreamGetBits(&param->bitStream, 21);\r\n      else if (param->kParam)\r\n        bitCode = crxBitstreamGetBits(&param->bitStream, param->kParam) |\r\n                  (bitCode << param->kParam);\r\n      param->lineBuf1[1] = -((bitCode + 1) & 1) ^ ((bitCode + 1) >> 1);\r\n      param->kParam = crxPredictKParameter(param->kParam, bitCode, 15);\r\n    }\r\n    param->lineBuf2[0] = param->kParam;\r\n    ++param->lineBuf2;\r\n    ++param->lineBuf1;\r\n  }\r\n\r\n  if (length == 1)\r\n  {\r\n    uint32_t bitCode = crxBitstreamGetZeros(&param->bitStream);\r\n    if (bitCode >= 41)\r\n      bitCode = crxBitstreamGetBits(&param->bitStream, 21);\r\n    else if (param->kParam)\r\n      bitCode = crxBitstreamGetBits(&param->bitStream, param->kParam) |\r\n                (bitCode << param->kParam);\r\n    param->lineBuf1[1] = -(bitCode & 1) ^ (bitCode >> 1);\r\n    param->kParam = crxPredictKParameter(param->kParam, bitCode, 15);\r\n    param->lineBuf2[0] = param->kParam;\r\n    ++param->lineBuf1;\r\n  }\r\n\r\n  param->lineBuf1[1] = 0;\r\n\r\n  return 0;\r\n}\r\n\r\nint crxDecodeLine(CrxBandParam *param, uint8_t *bandBuf)\r\n{\r\n  if (!param || !bandBuf)\r\n    return -1;\r\n  if (param->curLine >= param->subbandHeight)\r\n    return -1;\r\n\r\n  if (param->curLine == 0)\r\n  {\r\n    int32_t lineLength = param->subbandWidth + 2;\r\n\r\n    param->sParam = 0;\r\n    param->kParam = 0;\r\n    if (param->supportsPartial)\r\n    {\r\n      if (param->roundedBitsMask <= 0)\r\n      {\r\n        param->lineBuf0 = (int32_t *)param->paramData;\r\n        param->lineBuf1 = param->lineBuf0 + lineLength;\r\n        int32_t *lineBuf = param->lineBuf1 + 1;\r\n        if (crxDecodeTopLine(param))\r\n          return -1;\r\n        memcpy(bandBuf, lineBuf, param->subbandWidth * sizeof(int32_t));\r\n        ++param->curLine;\r\n      }\r\n      else\r\n      {\r\n        param->roundedBits = 1;\r\n        if (param->roundedBitsMask & ~1)\r\n        {\r\n          while (param->roundedBitsMask >> param->roundedBits)\r\n            ++param->roundedBits;\r\n        }\r\n        param->lineBuf0 = (int32_t *)param->paramData;\r\n        param->lineBuf1 = param->lineBuf0 + lineLength;\r\n        int32_t *lineBuf = param->lineBuf1 + 1;\r\n        if (crxDecodeTopLineRounded(param))\r\n          return -1;\r\n        memcpy(bandBuf, lineBuf, param->subbandWidth * sizeof(int32_t));\r\n        ++param->curLine;\r\n      }\r\n    }\r\n    else\r\n    {\r\n      param->lineBuf2 = (int32_t *)param->nonProgrData;\r\n      param->lineBuf0 = (int32_t *)param->paramData;\r\n      param->lineBuf1 = param->lineBuf0 + lineLength;\r\n      int32_t *lineBuf = param->lineBuf1 + 1;\r\n      if (crxDecodeTopLineNoRefPrevLine(param))\r\n        return -1;\r\n      memcpy(bandBuf, lineBuf, param->subbandWidth * sizeof(int32_t));\r\n      ++param->curLine;\r\n    }\r\n  }\r\n  else if (!param->supportsPartial)\r\n  {\r\n    int32_t lineLength = param->subbandWidth + 2;\r\n    param->lineBuf2 = (int32_t *)param->nonProgrData;\r\n    if (param->curLine & 1)\r\n    {\r\n      param->lineBuf1 = (int32_t *)param->paramData;\r\n      param->lineBuf0 = param->lineBuf1 + lineLength;\r\n    }\r\n    else\r\n    {\r\n      param->lineBuf0 = (int32_t *)param->paramData;\r\n      param->lineBuf1 = param->lineBuf0 + lineLength;\r\n    }\r\n    int32_t *lineBuf = param->lineBuf1 + 1;\r\n    if (crxDecodeLineNoRefPrevLine(param))\r\n      return -1;\r\n    memcpy(bandBuf, lineBuf, param->subbandWidth * sizeof(int32_t));\r\n    ++param->curLine;\r\n  }\r\n  else if (param->roundedBitsMask <= 0)\r\n  {\r\n    int32_t lineLength = param->subbandWidth + 2;\r\n    if (param->curLine & 1)\r\n    {\r\n      param->lineBuf1 = (int32_t *)param->paramData;\r\n      param->lineBuf0 = param->lineBuf1 + lineLength;\r\n    }\r\n    else\r\n    {\r\n      param->lineBuf0 = (int32_t *)param->paramData;\r\n      param->lineBuf1 = param->lineBuf0 + lineLength;\r\n    }\r\n    int32_t *lineBuf = param->lineBuf1 + 1;\r\n    if (crxDecodeLine(param))\r\n      return -1;\r\n    memcpy(bandBuf, lineBuf, param->subbandWidth * sizeof(int32_t));\r\n    ++param->curLine;\r\n  }\r\n  else\r\n  {\r\n    int32_t lineLength = param->subbandWidth + 2;\r\n    if (param->curLine & 1)\r\n    {\r\n      param->lineBuf1 = (int32_t *)param->paramData;\r\n      param->lineBuf0 = param->lineBuf1 + lineLength;\r\n    }\r\n    else\r\n    {\r\n      param->lineBuf0 = (int32_t *)param->paramData;\r\n      param->lineBuf1 = param->lineBuf0 + lineLength;\r\n    }\r\n    int32_t *lineBuf = param->lineBuf1 + 1;\r\n    if (crxDecodeLineRounded(param))\r\n      return -1;\r\n    memcpy(bandBuf, lineBuf, param->subbandWidth * sizeof(int32_t));\r\n    ++param->curLine;\r\n  }\r\n  return 0;\r\n}\r\n\r\nint crxDecodeLineWithIQuantization(CrxSubband *subband)\r\n{\r\n  int32_t q_step_tbl[6] = {0x28, 0x2D, 0x33, 0x39, 0x40, 0x48};\r\n\r\n  if (!subband->dataSize)\r\n  {\r\n    memset(subband->bandBuf, 0, subband->bandSize);\r\n    return 0;\r\n  }\r\n\r\n  if (subband->supportsPartial)\r\n  {\r\n    uint32_t bitCode = crxBitstreamGetZeros(&subband->bandParam->bitStream);\r\n    if (bitCode >= 23)\r\n      bitCode = crxBitstreamGetBits(&subband->bandParam->bitStream, 8);\r\n    else if (subband->paramK)\r\n      bitCode =\r\n          crxBitstreamGetBits(&subband->bandParam->bitStream, subband->paramK) |\r\n          (bitCode << subband->paramK);\r\n\r\n    subband->quantValue +=\r\n        -(bitCode & 1) ^ (bitCode >> 1); // converting encoded to signed integer\r\n    subband->paramK = crxPredictKParameter(subband->paramK, bitCode);\r\n    if (subband->paramK > 7)\r\n      return -1;\r\n  }\r\n  if (crxDecodeLine(subband->bandParam, subband->bandBuf))\r\n    return -1;\r\n\r\n  if (subband->width <= 0)\r\n    return 0LL;\r\n\r\n  // update subband buffers\r\n  int32_t *bandBuf = (int32_t *)subband->bandBuf;\r\n  int32_t qScale =\r\n      q_step_tbl[subband->quantValue % 6] >> (6 - subband->quantValue / 6);\r\n  if (subband->quantValue / 6 >= 6)\r\n    qScale = q_step_tbl[subband->quantValue % 6] *\r\n             (1 << (subband->quantValue / 6 + 26));\r\n\r\n  if (qScale != 1)\r\n    for (int32_t i = 0; i < subband->width; i++)\r\n      bandBuf[i] *= qScale;\r\n\r\n  return 0;\r\n}\r\n\r\nvoid crxHorizontal53(int32_t *lineBufLA, int32_t *lineBufLB,\r\n                     CrxWaveletTransform *wavelet, uint32_t tileFlag)\r\n{\r\n  int32_t *band0Buf = wavelet->subband0Buf;\r\n  int32_t *band1Buf = wavelet->subband1Buf;\r\n  int32_t *band2Buf = wavelet->subband2Buf;\r\n  int32_t *band3Buf = wavelet->subband3Buf;\r\n\r\n  if (wavelet->width <= 1)\r\n  {\r\n    lineBufLA[0] = band0Buf[0];\r\n    lineBufLB[0] = band2Buf[0];\r\n  }\r\n  else\r\n  {\r\n    if (tileFlag & E_HAS_TILES_ON_THE_LEFT)\r\n    {\r\n      lineBufLA[0] = band0Buf[0] - ((band1Buf[0] + band1Buf[1] + 2) >> 2);\r\n      lineBufLB[0] = band2Buf[0] - ((band3Buf[0] + band3Buf[1] + 2) >> 2);\r\n      ++band1Buf;\r\n      ++band3Buf;\r\n    }\r\n    else\r\n    {\r\n      lineBufLA[0] = band0Buf[0] - ((band1Buf[0] + 1) >> 1);\r\n      lineBufLB[0] = band2Buf[0] - ((band3Buf[0] + 1) >> 1);\r\n    }\r\n    ++band0Buf;\r\n    ++band2Buf;\r\n\r\n    for (int i = 0; i < wavelet->width - 3; i += 2)\r\n    {\r\n      int32_t delta = band0Buf[0] - ((band1Buf[0] + band1Buf[1] + 2) >> 2);\r\n      lineBufLA[1] = band1Buf[0] + ((delta + lineBufLA[0]) >> 1);\r\n      lineBufLA[2] = delta;\r\n\r\n      delta = band2Buf[0] - ((band3Buf[0] + band3Buf[1] + 2) >> 2);\r\n      lineBufLB[1] = band3Buf[0] + ((delta + lineBufLB[0]) >> 1);\r\n      lineBufLB[2] = delta;\r\n\r\n      ++band0Buf;\r\n      ++band1Buf;\r\n      ++band2Buf;\r\n      ++band3Buf;\r\n      lineBufLA += 2;\r\n      lineBufLB += 2;\r\n    }\r\n    if (tileFlag & E_HAS_TILES_ON_THE_RIGHT)\r\n    {\r\n      int32_t deltaA = band0Buf[0] - ((band1Buf[0] + band1Buf[1] + 2) >> 2);\r\n      lineBufLA[1] = band1Buf[0] + ((deltaA + lineBufLA[0]) >> 1);\r\n\r\n      int32_t deltaB = band2Buf[0] - ((band3Buf[0] + band3Buf[1] + 2) >> 2);\r\n      lineBufLB[1] = band3Buf[0] + ((deltaB + lineBufLB[0]) >> 1);\r\n\r\n      if (wavelet->width & 1)\r\n      {\r\n        lineBufLA[2] = deltaA;\r\n        lineBufLB[2] = deltaB;\r\n      }\r\n    }\r\n    else if (wavelet->width & 1)\r\n    {\r\n      lineBufLA[1] =\r\n          band1Buf[0] +\r\n          ((lineBufLA[0] + band0Buf[0] - ((band1Buf[0] + 1) >> 1)) >> 1);\r\n      lineBufLA[2] = band0Buf[0] - ((band1Buf[0] + 1) >> 1);\r\n\r\n      lineBufLB[1] =\r\n          band3Buf[0] +\r\n          ((lineBufLB[0] + band2Buf[0] - ((band3Buf[0] + 1) >> 1)) >> 1);\r\n      lineBufLB[2] = band2Buf[0] - ((band3Buf[0] + 1) >> 1);\r\n    }\r\n    else\r\n    {\r\n      lineBufLA[1] = lineBufLA[0] + band1Buf[0];\r\n      lineBufLB[1] = lineBufLB[0] + band3Buf[0];\r\n    }\r\n  }\r\n}\r\n\r\nint32_t *crxIdwt53FilterGetLine(CrxPlaneComp *comp, int32_t level)\r\n{\r\n  int32_t *result = comp->waveletTransform[level]\r\n                        .lineBuf[(comp->waveletTransform[level].fltTapH -\r\n                                  comp->waveletTransform[level].curH + 5) %\r\n                                     5 +\r\n                                 3];\r\n  comp->waveletTransform[level].curH--;\r\n  return result;\r\n}\r\n\r\nint crxIdwt53FilterDecode(CrxPlaneComp *comp, int32_t level)\r\n{\r\n  if (comp->waveletTransform[level].curH)\r\n    return 0;\r\n\r\n  CrxSubband *sband = comp->subBands + 3 * level;\r\n\r\n  if (comp->waveletTransform[level].height - 3 <=\r\n          comp->waveletTransform[level].curLine &&\r\n      !(comp->tileFlag & E_HAS_TILES_ON_THE_BOTTOM))\r\n  {\r\n    if (comp->waveletTransform[level].height & 1)\r\n    {\r\n      if (level)\r\n      {\r\n        if (crxIdwt53FilterDecode(comp, level - 1))\r\n          return -1;\r\n      }\r\n      else if (crxDecodeLineWithIQuantization(sband))\r\n        return -1;\r\n\r\n      if (crxDecodeLineWithIQuantization(sband + 1))\r\n        return -1;\r\n    }\r\n  }\r\n  else\r\n  {\r\n    if (level)\r\n    {\r\n      if (crxIdwt53FilterDecode(comp, level - 1))\r\n        return -1;\r\n    }\r\n    else if (crxDecodeLineWithIQuantization(sband)) // LL band\r\n      return -1;\r\n\r\n    if (crxDecodeLineWithIQuantization(sband + 1) || // HL band\r\n        crxDecodeLineWithIQuantization(sband + 2) || // LH band\r\n        crxDecodeLineWithIQuantization(sband + 3))   // HH band\r\n      return -1;\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\nint crxIdwt53FilterTransform(CrxPlaneComp *comp, uint32_t level)\r\n{\r\n  CrxWaveletTransform *wavelet = comp->waveletTransform + level;\r\n\r\n  if (wavelet->curH)\r\n    return 0;\r\n\r\n  if (wavelet->curLine >= wavelet->height - 3)\r\n  {\r\n    if (!(comp->tileFlag & E_HAS_TILES_ON_THE_BOTTOM))\r\n    {\r\n      if (wavelet->height & 1)\r\n      {\r\n        if (level)\r\n        {\r\n          if (!wavelet[-1].curH)\r\n            if (crxIdwt53FilterTransform(comp, level - 1))\r\n              return -1;\r\n          wavelet->subband0Buf = crxIdwt53FilterGetLine(comp, level - 1);\r\n        }\r\n        int32_t *band0Buf = wavelet->subband0Buf;\r\n        int32_t *band1Buf = wavelet->subband1Buf;\r\n        int32_t *lineBufH0 = wavelet->lineBuf[wavelet->fltTapH + 3];\r\n        int32_t *lineBufH1 = wavelet->lineBuf[(wavelet->fltTapH + 1) % 5 + 3];\r\n        int32_t *lineBufH2 = wavelet->lineBuf[(wavelet->fltTapH + 2) % 5 + 3];\r\n\r\n        int32_t *lineBufL0 = wavelet->lineBuf[0];\r\n        int32_t *lineBufL1 = wavelet->lineBuf[1];\r\n        wavelet->lineBuf[1] = wavelet->lineBuf[2];\r\n        wavelet->lineBuf[2] = lineBufL1;\r\n\r\n        // process L bands\r\n        if (wavelet->width <= 1)\r\n        {\r\n          lineBufL0[0] = band0Buf[0];\r\n        }\r\n        else\r\n        {\r\n          if (comp->tileFlag & E_HAS_TILES_ON_THE_LEFT)\r\n          {\r\n            lineBufL0[0] = band0Buf[0] - ((band1Buf[0] + band1Buf[1] + 2) >> 2);\r\n            ++band1Buf;\r\n          }\r\n          else\r\n          {\r\n            lineBufL0[0] = band0Buf[0] - ((band1Buf[0] + 1) >> 1);\r\n          }\r\n          ++band0Buf;\r\n          for (int i = 0; i < wavelet->width - 3; i += 2)\r\n          {\r\n            int32_t delta =\r\n                band0Buf[0] - ((band1Buf[0] + band1Buf[1] + 2) >> 2);\r\n            lineBufL0[1] = band1Buf[0] + ((lineBufL0[0] + delta) >> 1);\r\n            lineBufL0[2] = delta;\r\n            ++band0Buf;\r\n            ++band1Buf;\r\n            lineBufL0 += 2;\r\n          }\r\n          if (comp->tileFlag & E_HAS_TILES_ON_THE_RIGHT)\r\n          {\r\n            int32_t delta =\r\n                band0Buf[0] - ((band1Buf[0] + band1Buf[1] + 2) >> 2);\r\n            lineBufL0[1] = band1Buf[0] + ((lineBufL0[0] + delta) >> 1);\r\n            if (wavelet->width & 1)\r\n              lineBufL0[2] = delta;\r\n          }\r\n          else if (wavelet->width & 1)\r\n          {\r\n            int32_t delta = band0Buf[0] - ((band1Buf[0] + 1) >> 1);\r\n            lineBufL0[1] = band1Buf[0] + ((lineBufL0[0] + delta) >> 1);\r\n            lineBufL0[2] = delta;\r\n          }\r\n          else\r\n            lineBufL0[1] = band1Buf[0] + lineBufL0[0];\r\n        }\r\n\r\n        // process H bands\r\n        lineBufL0 = wavelet->lineBuf[0];\r\n        lineBufL1 = wavelet->lineBuf[1];\r\n        for (int32_t i = 0; i < wavelet->width; i++)\r\n        {\r\n          int32_t delta = lineBufL0[i] - ((lineBufL1[i] + 1) >> 1);\r\n          lineBufH1[i] = lineBufL1[i] + ((delta + lineBufH0[i]) >> 1);\r\n          lineBufH2[i] = delta;\r\n        }\r\n        wavelet->curH += 3;\r\n        wavelet->curLine += 3;\r\n        wavelet->fltTapH = (wavelet->fltTapH + 3) % 5;\r\n      }\r\n      else\r\n      {\r\n        int32_t *lineBufL2 = wavelet->lineBuf[2];\r\n        int32_t *lineBufH0 = wavelet->lineBuf[wavelet->fltTapH + 3];\r\n        int32_t *lineBufH1 = wavelet->lineBuf[(wavelet->fltTapH + 1) % 5 + 3];\r\n        wavelet->lineBuf[1] = lineBufL2;\r\n        wavelet->lineBuf[2] = wavelet->lineBuf[1];\r\n\r\n        for (int32_t i = 0; i < wavelet->width; i++)\r\n          lineBufH1[i] = lineBufH0[i] + lineBufL2[i];\r\n\r\n        wavelet->curH += 2;\r\n        wavelet->curLine += 2;\r\n        wavelet->fltTapH = (wavelet->fltTapH + 2) % 5;\r\n      }\r\n    }\r\n  }\r\n  else\r\n  {\r\n    if (level)\r\n    {\r\n      if (!wavelet[-1].curH && crxIdwt53FilterTransform(comp, level - 1))\r\n        return -1;\r\n      wavelet->subband0Buf = crxIdwt53FilterGetLine(comp, level - 1);\r\n    }\r\n\r\n    int32_t *band0Buf = wavelet->subband0Buf;\r\n    int32_t *band1Buf = wavelet->subband1Buf;\r\n    int32_t *band2Buf = wavelet->subband2Buf;\r\n    int32_t *band3Buf = wavelet->subband3Buf;\r\n\r\n    int32_t *lineBufL0 = wavelet->lineBuf[0];\r\n    int32_t *lineBufL1 = wavelet->lineBuf[1];\r\n    int32_t *lineBufL2 = wavelet->lineBuf[2];\r\n    int32_t *lineBufH0 = wavelet->lineBuf[wavelet->fltTapH + 3];\r\n    int32_t *lineBufH1 = wavelet->lineBuf[(wavelet->fltTapH + 1) % 5 + 3];\r\n    int32_t *lineBufH2 = wavelet->lineBuf[(wavelet->fltTapH + 2) % 5 + 3];\r\n\r\n    wavelet->lineBuf[1] = wavelet->lineBuf[2];\r\n    wavelet->lineBuf[2] = lineBufL1;\r\n\r\n    // process L bands\r\n    if (wavelet->width <= 1)\r\n    {\r\n      lineBufL0[0] = band0Buf[0];\r\n      lineBufL1[0] = band2Buf[0];\r\n    }\r\n    else\r\n    {\r\n      if (comp->tileFlag & E_HAS_TILES_ON_THE_LEFT)\r\n      {\r\n        lineBufL0[0] = band0Buf[0] - ((band1Buf[0] + band1Buf[1] + 2) >> 2);\r\n        lineBufL1[0] = band2Buf[0] - ((band3Buf[0] + band3Buf[1] + 2) >> 2);\r\n        ++band1Buf;\r\n        ++band3Buf;\r\n      }\r\n      else\r\n      {\r\n        lineBufL0[0] = band0Buf[0] - ((band1Buf[0] + 1) >> 1);\r\n        lineBufL1[0] = band2Buf[0] - ((band3Buf[0] + 1) >> 1);\r\n      }\r\n      ++band0Buf;\r\n      ++band2Buf;\r\n      for (int i = 0; i < wavelet->width - 3; i += 2)\r\n      {\r\n        int32_t delta = band0Buf[0] - ((band1Buf[0] + band1Buf[1] + 2) >> 2);\r\n        lineBufL0[1] = band1Buf[0] + ((delta + lineBufL0[0]) >> 1);\r\n        lineBufL0[2] = delta;\r\n\r\n        delta = band2Buf[0] - ((band3Buf[0] + band3Buf[1] + 2) >> 2);\r\n        lineBufL1[1] = band3Buf[0] + ((delta + lineBufL1[0]) >> 1);\r\n        lineBufL1[2] = delta;\r\n\r\n        ++band0Buf;\r\n        ++band1Buf;\r\n        ++band2Buf;\r\n        ++band3Buf;\r\n        lineBufL0 += 2;\r\n        lineBufL1 += 2;\r\n      }\r\n      if (comp->tileFlag & E_HAS_TILES_ON_THE_RIGHT)\r\n      {\r\n        int32_t deltaA = band0Buf[0] - ((band1Buf[0] + band1Buf[1] + 2) >> 2);\r\n        lineBufL0[1] = band1Buf[0] + ((deltaA + lineBufL0[0]) >> 1);\r\n\r\n        int32_t deltaB = band2Buf[0] - ((band3Buf[0] + band3Buf[1] + 2) >> 2);\r\n        lineBufL1[1] = band3Buf[0] + ((deltaB + lineBufL1[0]) >> 1);\r\n\r\n        if (wavelet->width & 1)\r\n        {\r\n          lineBufL0[2] = deltaA;\r\n          lineBufL1[2] = deltaB;\r\n        }\r\n      }\r\n      else if (wavelet->width & 1)\r\n      {\r\n        int32_t delta = band0Buf[0] - ((band1Buf[0] + 1) >> 1);\r\n        lineBufL0[1] = band1Buf[0] + ((delta + lineBufL0[0]) >> 1);\r\n        lineBufL0[2] = delta;\r\n\r\n        delta = band2Buf[0] - ((band3Buf[0] + 1) >> 1);\r\n        lineBufL1[1] = band3Buf[0] + ((delta + lineBufL1[0]) >> 1);\r\n        lineBufL1[2] = delta;\r\n      }\r\n      else\r\n      {\r\n        lineBufL0[1] = lineBufL0[0] + band1Buf[0];\r\n        lineBufL1[1] = lineBufL1[0] + band3Buf[0];\r\n      }\r\n    }\r\n\r\n    // process H bands\r\n    lineBufL0 = wavelet->lineBuf[0];\r\n    lineBufL1 = wavelet->lineBuf[1];\r\n    lineBufL2 = wavelet->lineBuf[2];\r\n    for (int32_t i = 0; i < wavelet->width; i++)\r\n    {\r\n      int32_t delta = lineBufL0[i] - ((lineBufL2[i] + lineBufL1[i] + 2) >> 2);\r\n      lineBufH1[i] = lineBufL1[i] + ((delta + lineBufH0[i]) >> 1);\r\n      lineBufH2[i] = delta;\r\n    }\r\n    if (wavelet->curLine >= wavelet->height - 3 && wavelet->height & 1)\r\n    {\r\n      wavelet->curH += 3;\r\n      wavelet->curLine += 3;\r\n      wavelet->fltTapH = (wavelet->fltTapH + 3) % 5;\r\n    }\r\n    else\r\n    {\r\n      wavelet->curH += 2;\r\n      wavelet->curLine += 2;\r\n      wavelet->fltTapH = (wavelet->fltTapH + 2) % 5;\r\n    }\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\nint crxIdwt53FilterInitialize(CrxPlaneComp *comp, int32_t prevLevel)\r\n{\r\n  if (prevLevel < 0)\r\n    return 0;\r\n\r\n  for (int curLevel = 0, curBand = 0; curLevel < prevLevel + 1;\r\n       curLevel++, curBand += 3)\r\n  {\r\n    CrxWaveletTransform *wavelet = comp->waveletTransform + curLevel;\r\n    if (curLevel)\r\n      wavelet[0].subband0Buf = crxIdwt53FilterGetLine(comp, curLevel - 1);\r\n    else if (crxDecodeLineWithIQuantization(comp->subBands + curBand))\r\n      return -1;\r\n\r\n    int32_t *lineBufH0 = wavelet->lineBuf[wavelet->fltTapH + 3];\r\n    if (wavelet->height > 1)\r\n    {\r\n      if (crxDecodeLineWithIQuantization(comp->subBands + curBand + 1) ||\r\n          crxDecodeLineWithIQuantization(comp->subBands + curBand + 2) ||\r\n          crxDecodeLineWithIQuantization(comp->subBands + curBand + 3))\r\n        return -1;\r\n\r\n      int32_t *lineBufL0 = wavelet->lineBuf[0];\r\n      int32_t *lineBufL1 = wavelet->lineBuf[1];\r\n      int32_t *lineBufL2 = wavelet->lineBuf[2];\r\n\r\n      if (comp->tileFlag & E_HAS_TILES_ON_THE_TOP)\r\n      {\r\n        crxHorizontal53(lineBufL0, wavelet->lineBuf[1], wavelet,\r\n                        comp->tileFlag);\r\n        if (crxDecodeLineWithIQuantization(comp->subBands + curBand + 3) ||\r\n            crxDecodeLineWithIQuantization(comp->subBands + curBand + 2))\r\n          return -1;\r\n\r\n        int32_t *band2Buf = wavelet->subband2Buf;\r\n        int32_t *band3Buf = wavelet->subband3Buf;\r\n\r\n        // process L band\r\n        if (wavelet->width <= 1)\r\n          lineBufL2[0] = band2Buf[0];\r\n        else\r\n        {\r\n          if (comp->tileFlag & E_HAS_TILES_ON_THE_LEFT)\r\n          {\r\n            lineBufL2[0] = band2Buf[0] - ((band3Buf[0] + band3Buf[1] + 2) >> 2);\r\n            ++band3Buf;\r\n          }\r\n          else\r\n            lineBufL2[0] = band2Buf[0] - ((band3Buf[0] + 1) >> 1);\r\n\r\n          ++band2Buf;\r\n\r\n          for (int i = 0; i < wavelet->width - 3; i += 2)\r\n          {\r\n            int32_t delta =\r\n                band2Buf[0] - ((band3Buf[0] + band3Buf[1] + 2) >> 2);\r\n            lineBufL2[1] = band3Buf[0] + ((lineBufL2[0] + delta) >> 1);\r\n            lineBufL2[2] = delta;\r\n\r\n            ++band2Buf;\r\n            ++band3Buf;\r\n            lineBufL2 += 2;\r\n          }\r\n          if (comp->tileFlag & E_HAS_TILES_ON_THE_RIGHT)\r\n          {\r\n            int32_t delta =\r\n                band2Buf[0] - ((band3Buf[0] + band3Buf[1] + 2) >> 2);\r\n            lineBufL2[1] = band3Buf[0] + ((lineBufL2[0] + delta) >> 1);\r\n            if (wavelet->width & 1)\r\n              lineBufL2[2] = delta;\r\n          }\r\n          else if (wavelet->width & 1)\r\n          {\r\n            int32_t delta = band2Buf[0] - ((band3Buf[0] + 1) >> 1);\r\n\r\n            lineBufL2[1] = band3Buf[0] + ((lineBufL2[0] + delta) >> 1);\r\n            lineBufL2[2] = delta;\r\n          }\r\n          else\r\n          {\r\n            lineBufL2[1] = band3Buf[0] + lineBufL2[0];\r\n          }\r\n        }\r\n\r\n        // process H band\r\n        for (int32_t i = 0; i < wavelet->width; i++)\r\n          lineBufH0[i] =\r\n              lineBufL0[i] - ((lineBufL1[i] + lineBufL2[i] + 2) >> 2);\r\n      }\r\n      else\r\n      {\r\n        crxHorizontal53(lineBufL0, wavelet->lineBuf[2], wavelet,\r\n                        comp->tileFlag);\r\n        for (int i = 0; i < wavelet->width; i++)\r\n          lineBufH0[i] = lineBufL0[i] - ((lineBufL2[i] + 1) >> 1);\r\n      }\r\n\r\n      if (crxIdwt53FilterDecode(comp, curLevel) ||\r\n          crxIdwt53FilterTransform(comp, curLevel))\r\n        return -1;\r\n    }\r\n    else\r\n    {\r\n      if (crxDecodeLineWithIQuantization(comp->subBands + curBand + 1))\r\n        return -1;\r\n\r\n      int32_t *band0Buf = wavelet->subband0Buf;\r\n      int32_t *band1Buf = wavelet->subband1Buf;\r\n\r\n      // process H band\r\n      if (wavelet->width <= 1)\r\n        lineBufH0[0] = band0Buf[0];\r\n      else\r\n      {\r\n        if (comp->tileFlag & E_HAS_TILES_ON_THE_LEFT)\r\n        {\r\n          lineBufH0[0] = band0Buf[0] - ((band1Buf[0] + band1Buf[1] + 2) >> 2);\r\n          ++band1Buf;\r\n        }\r\n        else\r\n          lineBufH0[0] = band0Buf[0] - ((band1Buf[0] + 1) >> 1);\r\n\r\n        ++band0Buf;\r\n\r\n        for (int i = 0; i < wavelet->width - 3; i += 2)\r\n        {\r\n          int32_t delta = band0Buf[0] - ((band1Buf[0] + band1Buf[1] + 2) >> 2);\r\n          lineBufH0[1] = band1Buf[0] + ((lineBufH0[0] + delta) >> 1);\r\n          lineBufH0[2] = delta;\r\n\r\n          ++band0Buf;\r\n          ++band1Buf;\r\n          lineBufH0 += 2;\r\n        }\r\n\r\n        if (comp->tileFlag & E_HAS_TILES_ON_THE_RIGHT)\r\n        {\r\n          int32_t delta = band0Buf[0] - ((band1Buf[0] + band1Buf[1] + 2) >> 2);\r\n          lineBufH0[1] = band1Buf[0] + ((lineBufH0[0] + delta) >> 1);\r\n          lineBufH0[2] = delta;\r\n        }\r\n        else if (wavelet->width & 1)\r\n        {\r\n          int32_t delta = band0Buf[0] - ((band1Buf[0] + 1) >> 1);\r\n          lineBufH0[1] = band1Buf[0] + ((lineBufH0[0] + delta) >> 1);\r\n          lineBufH0[2] = delta;\r\n        }\r\n        else\r\n        {\r\n          lineBufH0[1] = band1Buf[0] + lineBufH0[0];\r\n        }\r\n      }\r\n      ++wavelet->curLine;\r\n      ++wavelet->curH;\r\n      wavelet->fltTapH = (wavelet->fltTapH + 1) % 5;\r\n    }\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\nvoid crxFreeSubbandData(CrxImage *image, CrxPlaneComp *comp)\r\n{\r\n  if (comp->compBuf)\r\n  {\r\n    free(comp->compBuf);\r\n    comp->compBuf = 0;\r\n  }\r\n\r\n  if (!comp->subBands)\r\n    return;\r\n\r\n  for (int32_t i = 0; i < image->subbandCount; i++)\r\n  {\r\n    if (comp->subBands[i].bandParam)\r\n    {\r\n      free(comp->subBands[i].bandParam);\r\n      comp->subBands[i].bandParam = 0LL;\r\n    }\r\n    comp->subBands[i].bandBuf = 0;\r\n    comp->subBands[i].bandSize = 0;\r\n  }\r\n}\r\n\r\nvoid crxConvertPlaneLine(CrxImage *img, int imageRow, int imageCol = 0,\r\n                         int plane = 0, int32_t *lineData = 0,\r\n                         int lineLength = 0)\r\n{\r\n  if (lineData)\r\n  {\r\n    uint64_t rawOffset = 4 * img->planeWidth * imageRow + 2 * imageCol;\r\n    if (img->encType == 1)\r\n    {\r\n      int32_t maxVal = 1 << (img->nBits - 1);\r\n      int32_t minVal = -maxVal;\r\n      --maxVal;\r\n      for (int i = 0; i < lineLength; i++)\r\n        img->outBufs[plane][rawOffset + 2 * i] =\r\n            _constrain(lineData[i], minVal, maxVal);\r\n    }\r\n    else if (img->encType == 3)\r\n    {\r\n      // copy to intermediate planeBuf\r\n      rawOffset = plane * img->planeWidth * img->planeHeight +\r\n                  img->planeWidth * imageRow + imageCol;\r\n      for (int i = 0; i < lineLength; i++)\r\n        img->planeBuf[rawOffset + i] = lineData[i];\r\n    }\r\n    else if (img->nPlanes == 4)\r\n    {\r\n      int32_t median = 1 << (img->nBits - 1);\r\n      int32_t maxVal = (1 << img->nBits) - 1;\r\n      for (int i = 0; i < lineLength; i++)\r\n        img->outBufs[plane][rawOffset + 2 * i] =\r\n            _constrain(median + lineData[i], 0, maxVal);\r\n    }\r\n    else if (img->nPlanes == 1)\r\n    {\r\n      int32_t maxVal = (1 << img->nBits) - 1;\r\n      int32_t median = 1 << (img->nBits - 1);\r\n      rawOffset = img->planeWidth * imageRow + imageCol;\r\n      for (int i = 0; i < lineLength; i++)\r\n        img->outBufs[0][rawOffset + i] =\r\n            _constrain(median + lineData[i], 0, maxVal);\r\n    }\r\n  }\r\n  else if (img->encType == 3 && img->planeBuf)\r\n  {\r\n    int32_t planeSize = img->planeWidth * img->planeHeight;\r\n    int16_t *plane0 = img->planeBuf + imageRow * img->planeWidth;\r\n    int16_t *plane1 = plane0 + planeSize;\r\n    int16_t *plane2 = plane1 + planeSize;\r\n    int16_t *plane3 = plane2 + planeSize;\r\n\r\n    int32_t median = 1 << (img->nBits - 1) << 10;\r\n    int32_t maxVal = (1 << img->nBits) - 1;\r\n    uint32_t rawLineOffset = 4 * img->planeWidth * imageRow;\r\n\r\n    // for this stage - all except imageRow is ignored\r\n    for (int i = 0; i < img->planeWidth; i++)\r\n    {\r\n      int32_t gr =\r\n          median + (plane0[i] << 10) - 168 * plane1[i] - 585 * plane3[i];\r\n      int32_t val = 0;\r\n      if (gr < 0)\r\n        gr = -(((_abs(gr) + 512) >> 9) & ~1);\r\n      else\r\n        gr = ((_abs(gr) + 512) >> 9) & ~1;\r\n\r\n      // Essentially R = round(median + P0 + 1.474*P3)\r\n      val = (median + (plane0[i] << 10) + 1510 * plane3[i] + 512) >> 10;\r\n      img->outBufs[0][rawLineOffset + 2 * i] = _constrain(val, 0, maxVal);\r\n      // Essentially G1 = round(median + P0 + P2 - 0.164*P1 - 0.571*P3)\r\n      val = (plane2[i] + gr + 1) >> 1;\r\n      img->outBufs[1][rawLineOffset + 2 * i] = _constrain(val, 0, maxVal);\r\n      // Essentially G1 = round(median + P0 - P2 - 0.164*P1 - 0.571*P3)\r\n      val = (gr - plane2[i] + 1) >> 1;\r\n      img->outBufs[2][rawLineOffset + 2 * i] = _constrain(val, 0, maxVal);\r\n      // Essentially B = round(median + P0 + 1.881*P1)\r\n      val = (median + (plane0[i] << 10) + 1927 * plane1[i] + 512) >> 10;\r\n      img->outBufs[3][rawLineOffset + 2 * i] = _constrain(val, 0, maxVal);\r\n    }\r\n  }\r\n}\r\n\r\nint crxParamInit(\r\n#ifdef LIBRAW_CR3_MEMPOOL\r\n\tlibraw_memmgr&  mm,\r\n#endif\t\r\n\tCrxBandParam **param, uint64_t subbandMdatOffset,\r\n                 uint64_t subbandDataSize, uint32_t subbandWidth,\r\n                 uint32_t subbandHeight, int32_t supportsPartial,\r\n                 uint32_t roundedBitsMask, LibRaw_abstract_datastream *input)\r\n{\r\n  int32_t progrDataSize = supportsPartial ? 0 : sizeof(int32_t) * subbandWidth;\r\n  int32_t paramLength = 2 * subbandWidth + 4;\r\n  uint8_t *paramBuf = (uint8_t *)\r\n#ifdef LIBRAW_CR3_MEMPOOL\r\n\t  mm.\r\n#endif\r\n\t  calloc(\r\n      1, sizeof(CrxBandParam) + sizeof(int32_t) * paramLength + progrDataSize);\r\n\r\n  if (!paramBuf)\r\n    return -1;\r\n\r\n  *param = (CrxBandParam *)paramBuf;\r\n\r\n  paramBuf += sizeof(CrxBandParam);\r\n\r\n  (*param)->paramData = (int32_t *)paramBuf;\r\n  (*param)->nonProgrData =\r\n      progrDataSize ? (*param)->paramData + paramLength : 0;\r\n  (*param)->subbandWidth = subbandWidth;\r\n  (*param)->subbandHeight = subbandHeight;\r\n  (*param)->roundedBits = 0;\r\n  (*param)->curLine = 0;\r\n  (*param)->roundedBitsMask = roundedBitsMask;\r\n  (*param)->supportsPartial = supportsPartial;\r\n  (*param)->bitStream.bitData = 0;\r\n  (*param)->bitStream.bitsLeft = 0;\r\n  (*param)->bitStream.mdatSize = subbandDataSize;\r\n  (*param)->bitStream.curPos = 0;\r\n  (*param)->bitStream.curBufSize = 0;\r\n  (*param)->bitStream.curBufOffset = subbandMdatOffset;\r\n  (*param)->bitStream.input = input;\r\n\r\n  crxFillBuffer(&(*param)->bitStream);\r\n\r\n  return 0;\r\n}\r\n\r\nint crxSetupSubbandData(CrxImage *img, CrxPlaneComp *planeComp,\r\n                        const CrxTile *tile, uint32_t mdatOffset)\r\n{\r\n  long compDataSize = 0;\r\n  long waveletDataOffset = 0;\r\n  long compCoeffDataOffset = 0;\r\n  int32_t toSubbands = 3 * img->levels + 1;\r\n  int32_t transformWidth = 0;\r\n\r\n  CrxSubband *subbands = planeComp->subBands;\r\n\r\n  // calculate sizes\r\n  for (int32_t subbandNum = 0; subbandNum < toSubbands; subbandNum++)\r\n  {\r\n    subbands[subbandNum].bandSize =\r\n        subbands[subbandNum].width * sizeof(int32_t); // 4bytes\r\n    compDataSize += subbands[subbandNum].bandSize;\r\n  }\r\n\r\n  if (img->levels)\r\n  {\r\n    int32_t encLevels = img->levels ? img->levels : 1;\r\n    waveletDataOffset = (compDataSize + 7) & ~7;\r\n    compDataSize =\r\n        (sizeof(CrxWaveletTransform) * encLevels + waveletDataOffset + 7) & ~7;\r\n    compCoeffDataOffset = compDataSize;\r\n\r\n    // calc wavelet line buffer sizes (always at one level up from current)\r\n    for (int level = 0; level < img->levels; ++level)\r\n      if (level < img->levels - 1)\r\n        compDataSize += 8 * sizeof(int32_t) *\r\n                        planeComp->subBands[3 * (level + 1) + 2].width;\r\n      else\r\n        compDataSize += 8 * sizeof(int32_t) * tile->width;\r\n  }\r\n\r\n  // buffer allocation\r\n  planeComp->compBuf = (uint8_t *)\r\n#ifdef LIBRAW_CR3_MEMPOOL\r\n\t  img->memmgr.\r\n#endif\r\n\t  malloc(compDataSize);\r\n  if (!planeComp->compBuf)\r\n    return -1;\r\n\r\n  // subbands buffer and sizes initialisation\r\n  uint64_t subbandMdatOffset = img->mdatOffset + mdatOffset;\r\n  uint8_t *subbandBuf = planeComp->compBuf;\r\n\r\n  for (int32_t subbandNum = 0; subbandNum < toSubbands; subbandNum++)\r\n  {\r\n    subbands[subbandNum].bandBuf = subbandBuf;\r\n    subbandBuf += subbands[subbandNum].bandSize;\r\n    subbands[subbandNum].mdatOffset =\r\n        subbandMdatOffset + subbands[subbandNum].dataOffset;\r\n  }\r\n\r\n  // wavelet data initialisation\r\n  if (img->levels)\r\n  {\r\n    CrxWaveletTransform *waveletTransforms =\r\n        (CrxWaveletTransform *)(planeComp->compBuf + waveletDataOffset);\r\n    int32_t *paramData = (int32_t *)(planeComp->compBuf + compCoeffDataOffset);\r\n\r\n    planeComp->waveletTransform = waveletTransforms;\r\n    waveletTransforms[0].subband0Buf = (int32_t *)subbands->bandBuf;\r\n\r\n    for (int level = 0; level < img->levels; ++level)\r\n    {\r\n      int32_t band = 3 * level + 1;\r\n\r\n      if (level >= img->levels - 1)\r\n      {\r\n        waveletTransforms[level].height = tile->height;\r\n        transformWidth = tile->width;\r\n      }\r\n      else\r\n      {\r\n        waveletTransforms[level].height = subbands[band + 3].height;\r\n        transformWidth = subbands[band + 4].width;\r\n      }\r\n      waveletTransforms[level].width = transformWidth;\r\n      waveletTransforms[level].lineBuf[0] = paramData;\r\n      waveletTransforms[level].lineBuf[1] =\r\n          waveletTransforms[level].lineBuf[0] + transformWidth;\r\n      waveletTransforms[level].lineBuf[2] =\r\n          waveletTransforms[level].lineBuf[1] + transformWidth;\r\n      waveletTransforms[level].lineBuf[3] =\r\n          waveletTransforms[level].lineBuf[2] + transformWidth;\r\n      waveletTransforms[level].lineBuf[4] =\r\n          waveletTransforms[level].lineBuf[3] + transformWidth;\r\n      waveletTransforms[level].lineBuf[5] =\r\n          waveletTransforms[level].lineBuf[4] + transformWidth;\r\n      waveletTransforms[level].lineBuf[6] =\r\n          waveletTransforms[level].lineBuf[5] + transformWidth;\r\n      waveletTransforms[level].lineBuf[7] =\r\n          waveletTransforms[level].lineBuf[6] + transformWidth;\r\n      waveletTransforms[level].curLine = 0;\r\n      waveletTransforms[level].curH = 0;\r\n      waveletTransforms[level].fltTapH = 0;\r\n      waveletTransforms[level].subband1Buf = (int32_t *)subbands[band].bandBuf;\r\n      waveletTransforms[level].subband2Buf =\r\n          (int32_t *)subbands[band + 1].bandBuf;\r\n      waveletTransforms[level].subband3Buf =\r\n          (int32_t *)subbands[band + 2].bandBuf;\r\n\r\n      paramData = waveletTransforms[level].lineBuf[7] + transformWidth;\r\n    }\r\n  }\r\n\r\n  // decoding params and bitstream initialisation\r\n  for (int32_t subbandNum = 0; subbandNum < toSubbands; subbandNum++)\r\n  {\r\n    if (subbands[subbandNum].dataSize)\r\n    {\r\n      int32_t supportsPartial = 0;\r\n      uint32_t roundedBitsMask = 0;\r\n\r\n      if (planeComp->supportsPartial && subbandNum == 0)\r\n      {\r\n        roundedBitsMask = planeComp->roundedBitsMask;\r\n        supportsPartial = 1;\r\n      }\r\n      if (crxParamInit(\r\n#ifdef LIBRAW_CR3_MEMPOOL\r\n\t\t  img->memmgr,\r\n#endif\r\n\t\t  &subbands[subbandNum].bandParam,\r\n                       subbands[subbandNum].mdatOffset,\r\n                       subbands[subbandNum].dataSize,\r\n                       subbands[subbandNum].width, subbands[subbandNum].height,\r\n                       supportsPartial, roundedBitsMask, img->input))\r\n        return -1;\r\n    }\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\nint LibRaw::crxDecodePlane(void *p, uint32_t planeNumber)\r\n{\r\n  CrxImage *img = (CrxImage *)p;\r\n  int imageRow = 0;\r\n  for (int tRow = 0; tRow < img->tileRows; tRow++)\r\n  {\r\n    int imageCol = 0;\r\n    for (int tCol = 0; tCol < img->tileCols; tCol++)\r\n    {\r\n      CrxTile *tile = img->tiles + tRow * img->tileRows + tCol;\r\n      CrxPlaneComp *planeComp = tile->comps + planeNumber;\r\n      uint64_t tileMdatOffset = tile->dataOffset + planeComp->dataOffset;\r\n\r\n      // decode single tile\r\n      if (crxSetupSubbandData(img, planeComp, tile, tileMdatOffset))\r\n        return -1;\r\n\r\n      if (img->levels)\r\n      {\r\n        if (crxIdwt53FilterInitialize(planeComp, img->levels - 1))\r\n          return -1;\r\n        for (int i = 0; i < tile->height; ++i)\r\n        {\r\n          if (crxIdwt53FilterDecode(planeComp, img->levels - 1) ||\r\n              crxIdwt53FilterTransform(planeComp, img->levels - 1))\r\n            return -1;\r\n          int32_t *lineData =\r\n              crxIdwt53FilterGetLine(planeComp, img->levels - 1);\r\n          crxConvertPlaneLine(img, imageRow + i, imageCol, planeNumber,\r\n                              lineData, tile->width);\r\n        }\r\n      }\r\n      else\r\n      {\r\n        // we have the only subband in this case\r\n        if (!planeComp->subBands->dataSize)\r\n        {\r\n          memset(planeComp->subBands->bandBuf, 0,\r\n                 planeComp->subBands->bandSize);\r\n          return 0;\r\n        }\r\n\r\n        for (int i = 0; i < tile->height; ++i)\r\n        {\r\n          if (crxDecodeLine(planeComp->subBands->bandParam,\r\n                            planeComp->subBands->bandBuf))\r\n            return -1;\r\n          int32_t *lineData = (int32_t *)planeComp->subBands->bandBuf;\r\n          crxConvertPlaneLine(img, imageRow + i, imageCol, planeNumber,\r\n                              lineData, tile->width);\r\n        }\r\n      }\r\n      imageCol += tile->width;\r\n    }\r\n    imageRow += img->tiles[tRow * img->tileRows].height;\r\n  }\r\n\r\n  return 0;\r\n}\r\n\r\nint crxReadSubbandHeaders(crx_data_header_t *hdr, CrxImage *img, CrxTile *tile,\r\n                          CrxPlaneComp *comp, uint8_t **subbandMdatPtr,\r\n                          uint32_t *mdatSize)\r\n{\r\n  CrxSubband *band = comp->subBands + img->subbandCount - 1; // set to last band\r\n  uint32_t bandHeight = tile->height;\r\n  uint32_t bandWidth = tile->width;\r\n  int32_t bandWidthExCoef = 0;\r\n  int32_t bandHeightExCoef = 0;\r\n  if (img->levels)\r\n  {\r\n    // Build up subband sequences to crxDecode to a level in a header\r\n\r\n    // Coefficient structure is a bit unclear and convoluted:\r\n    //   3 levels max - 8 groups (for tile width rounded to 8 bytes)\r\n    //                  of 3 band per level 4 sets of coefficients for each\r\n    int32_t *rowExCoef =\r\n        exCoefNumTbl + 0x60 * (img->levels - 1) + 12 * (tile->width & 7);\r\n    int32_t *colExCoef =\r\n        exCoefNumTbl + 0x60 * (img->levels - 1) + 12 * (tile->height & 7);\r\n    for (int level = 0; level < img->levels; ++level)\r\n    {\r\n      int32_t widthOddPixel = bandWidth & 1;\r\n      int32_t heightOddPixel = bandHeight & 1;\r\n      bandWidth = (widthOddPixel + bandWidth) >> 1;\r\n      bandHeight = (heightOddPixel + bandHeight) >> 1;\r\n\r\n      int32_t bandWidthExCoef0 = 0;\r\n      int32_t bandWidthExCoef1 = 0;\r\n      int32_t bandHeightExCoef0 = 0;\r\n      int32_t bandHeightExCoef1 = 0;\r\n      if (tile->tileFlag & E_HAS_TILES_ON_THE_RIGHT)\r\n      {\r\n        bandWidthExCoef0 = rowExCoef[0];\r\n        bandWidthExCoef1 = rowExCoef[1];\r\n      }\r\n      if (tile->tileFlag & E_HAS_TILES_ON_THE_LEFT)\r\n        ++bandWidthExCoef0;\r\n      if (tile->tileFlag & E_HAS_TILES_ON_THE_BOTTOM)\r\n      {\r\n        bandHeightExCoef0 = colExCoef[0];\r\n        bandHeightExCoef1 = colExCoef[1];\r\n      }\r\n      if (tile->tileFlag & E_HAS_TILES_ON_THE_TOP)\r\n        ++bandHeightExCoef0;\r\n\r\n      band[0].width = bandWidth + bandWidthExCoef0 - widthOddPixel;\r\n      band[0].height = bandHeight + bandHeightExCoef0 - heightOddPixel;\r\n\r\n      band[-1].width = bandWidth + bandWidthExCoef1;\r\n      band[-1].height = bandHeight + bandHeightExCoef0 - heightOddPixel;\r\n\r\n      band[-2].width = bandWidth + bandWidthExCoef0 - widthOddPixel;\r\n      band[-2].height = bandHeight + bandHeightExCoef1;\r\n\r\n      rowExCoef += 4;\r\n      colExCoef += 4;\r\n      band -= 3;\r\n    }\r\n    bandWidthExCoef = bandHeightExCoef = 0;\r\n    if (tile->tileFlag & E_HAS_TILES_ON_THE_RIGHT)\r\n      bandWidthExCoef =\r\n          exCoefNumTbl[0x60 * (img->levels - 1) + 12 * (tile->width & 7) +\r\n                       4 * (img->levels - 1) + 1];\r\n    if (tile->tileFlag & E_HAS_TILES_ON_THE_BOTTOM)\r\n      bandHeightExCoef =\r\n          exCoefNumTbl[0x60 * (img->levels - 1) + 12 * (tile->height & 7) +\r\n                       4 * (img->levels - 1) + 1];\r\n  }\r\n  band->width = bandWidthExCoef + bandWidth;\r\n  band->height = bandHeightExCoef + bandHeight;\r\n\r\n  if (!img->subbandCount)\r\n    return 0;\r\n  int32_t curSubband = 0;\r\n  int32_t subbandOffset = 0;\r\n  band = comp->subBands;\r\n  for (int curSubband = 0; curSubband < img->subbandCount; curSubband++, band++)\r\n  {\r\n    if (*mdatSize < 0xC)\r\n      return -1;\r\n\r\n    if (LibRaw::sgetn(2, *subbandMdatPtr) != 0xFF03)\r\n      return -1;\r\n\r\n    uint32_t bitData = LibRaw::sgetn(4, *subbandMdatPtr + 8);\r\n    uint32_t subbandSize = LibRaw::sgetn(4, *subbandMdatPtr + 4);\r\n\r\n    if (curSubband != bitData >> 28)\r\n    {\r\n      band->dataSize = subbandSize;\r\n      return -1;\r\n    }\r\n    band->dataSize = subbandSize - (bitData & 0x7FF);\r\n    band->supportsPartial = bitData & 0x8000 ? 1 : 0;\r\n    band->dataOffset = subbandOffset;\r\n    band->quantValue = (bitData >> 19) & 0xFF;\r\n    band->paramK = 0;\r\n    band->bandParam = 0;\r\n    band->bandBuf = 0;\r\n    band->bandSize = 0;\r\n\r\n    subbandOffset += subbandSize;\r\n\r\n    *subbandMdatPtr += 0xC;\r\n    *mdatSize -= 0xC;\r\n  }\r\n  return 0;\r\n}\r\n\r\nint crxReadImageHeaders(crx_data_header_t *hdr, CrxImage *img, uint8_t *mdatPtr,\r\n                        uint32_t mdatSize)\r\n{\r\n  int nTiles = img->tileRows * img->tileCols;\r\n\r\n  if (!nTiles)\r\n    return -1;\r\n\r\n  if (!img->tiles)\r\n  {\r\n    img->tiles = (CrxTile *)\r\n#ifdef LIBRAW_CR3_MEMPOOL\r\n\t\timg->memmgr.\r\n#endif\r\n\t\tcalloc(\r\n        sizeof(CrxTile) * nTiles +\r\n        sizeof(CrxPlaneComp) * nTiles * img->nPlanes +\r\n        sizeof(CrxSubband) * nTiles * img->nPlanes * img->subbandCount,1);\r\n    if (!img->tiles)\r\n      return -1;\r\n\r\n    // memory areas in allocated chunk\r\n    CrxTile *tile = img->tiles;\r\n    CrxPlaneComp *comps = (CrxPlaneComp *)(tile + nTiles);\r\n    CrxSubband *bands = (CrxSubband *)(comps + img->nPlanes * nTiles);\r\n\r\n    for (int curTile = 0; curTile < nTiles; curTile++, tile++)\r\n    {\r\n      tile->tileFlag = 0; // tile neighbouring flags\r\n      tile->tileNumber = curTile;\r\n      tile->tileSize = 0;\r\n      tile->comps = comps + curTile * img->nPlanes;\r\n\r\n      if ((curTile + 1) % img->tileCols)\r\n      {\r\n        // not the last tile in a tile row\r\n        tile->width = hdr->tileWidth;\r\n        if (img->tileCols > 1)\r\n        {\r\n          tile->tileFlag = E_HAS_TILES_ON_THE_RIGHT;\r\n          if (curTile % img->tileCols)\r\n            // not the first tile in tile row\r\n            tile->tileFlag |= E_HAS_TILES_ON_THE_LEFT;\r\n        }\r\n      }\r\n      else\r\n      {\r\n        // last tile in a tile row\r\n        tile->width = img->planeWidth - hdr->tileWidth * (img->tileCols - 1);\r\n        if (img->tileCols > 1)\r\n          tile->tileFlag = E_HAS_TILES_ON_THE_LEFT;\r\n      }\r\n      if (curTile < nTiles - img->tileCols)\r\n      {\r\n        // in first tile row\r\n        tile->height = hdr->tileHeight;\r\n        if (img->tileRows > 1)\r\n        {\r\n          tile->tileFlag |= E_HAS_TILES_ON_THE_BOTTOM;\r\n          if (curTile >= img->tileCols)\r\n            tile->tileFlag |= E_HAS_TILES_ON_THE_TOP;\r\n        }\r\n      }\r\n      else\r\n      {\r\n        // non first tile row\r\n        tile->height = img->planeHeight - hdr->tileHeight * (img->tileRows - 1);\r\n        if (img->tileRows > 1)\r\n          tile->tileFlag |= E_HAS_TILES_ON_THE_TOP;\r\n      }\r\n      if (img->nPlanes)\r\n      {\r\n        CrxPlaneComp *comp = tile->comps;\r\n        CrxSubband *band = bands + curTile * img->nPlanes * img->subbandCount;\r\n\r\n        for (int curComp = 0; curComp < img->nPlanes; curComp++, comp++)\r\n        {\r\n          comp->compNumber = curComp;\r\n          comp->supportsPartial = 1;\r\n          comp->tileFlag = tile->tileFlag;\r\n          comp->subBands = band;\r\n          comp->compBuf = 0;\r\n          comp->waveletTransform = 0;\r\n          if (img->subbandCount)\r\n          {\r\n            for (int curBand = 0; curBand < img->subbandCount;\r\n                 curBand++, band++)\r\n            {\r\n              band->supportsPartial = 0;\r\n              band->quantValue = 4;\r\n              band->bandParam = 0;\r\n              band->dataSize = 0;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  uint32_t tileOffset = 0;\r\n  uint32_t dataSize = mdatSize;\r\n  uint8_t *dataPtr = mdatPtr;\r\n  CrxTile *tile = img->tiles;\r\n\r\n  for (int curTile = 0; curTile < nTiles; curTile++, tile++)\r\n  {\r\n    if (dataSize < 0xC)\r\n      return -1;\r\n\r\n    if (LibRaw::sgetn(2, dataPtr) != 0xFF01)\r\n      return -1;\r\n    if (LibRaw::sgetn(2, dataPtr + 8) != curTile)\r\n      return -1;\r\n\r\n    dataSize -= 0xC;\r\n\r\n    tile->tileSize = LibRaw::sgetn(4, dataPtr + 4);\r\n    tile->dataOffset = tileOffset;\r\n\r\n    int32_t hdrExtraBytes = LibRaw::sgetn(2, dataPtr + 2) - 8;\r\n    tileOffset += tile->tileSize;\r\n    dataPtr += hdrExtraBytes + 0xC;\r\n    dataSize -= hdrExtraBytes;\r\n\r\n    uint32_t compOffset = 0;\r\n    CrxPlaneComp *comp = tile->comps;\r\n\r\n    for (int compNum = 0; compNum < img->nPlanes; compNum++, comp++)\r\n    {\r\n      if (dataSize < 0xC)\r\n        return -1;\r\n\r\n      if (LibRaw::sgetn(2, dataPtr) != 0xFF02)\r\n        return -1;\r\n      if (compNum != dataPtr[8] >> 4)\r\n        return -1;\r\n\r\n      comp->compSize = LibRaw::sgetn(4, dataPtr + 4);\r\n\r\n      int32_t compHdrRoundedBits = (dataPtr[8] >> 1) & 3;\r\n      comp->supportsPartial = (dataPtr[8] & 8) != 0;\r\n\r\n      comp->dataOffset = compOffset;\r\n      comp->tileFlag = tile->tileFlag;\r\n\r\n      compOffset += comp->compSize;\r\n      dataSize -= 0xC;\r\n      dataPtr += 0xC;\r\n\r\n      comp->roundedBitsMask = 0;\r\n\r\n      if (compHdrRoundedBits)\r\n      {\r\n        if (img->levels || !comp->supportsPartial)\r\n          return -1;\r\n\r\n        comp->roundedBitsMask = 1 << (compHdrRoundedBits - 1);\r\n      }\r\n\r\n      if (crxReadSubbandHeaders(hdr, img, tile, comp, &dataPtr, &dataSize))\r\n        return -1;\r\n    }\r\n  }\r\n  return 0;\r\n}\r\n\r\nint crxSetupImageData(crx_data_header_t *hdr, CrxImage *img, int16_t *outBuf,\r\n                      uint64_t mdatOffset, uint32_t mdatSize,\r\n                      uint8_t *mdatHdrPtr)\r\n{\r\n  int IncrBitTable[32] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0,\r\n                          0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0};\r\n\r\n  img->planeWidth = hdr->f_width;\r\n  img->planeHeight = hdr->f_height;\r\n\r\n  if (hdr->tileWidth < 0x16 || hdr->tileHeight < 0x16 ||\r\n      img->planeWidth > 0x7FFF || img->planeHeight > 0x7FFF)\r\n    return -1;\r\n\r\n  img->tileCols = (img->planeWidth + hdr->tileWidth - 1) / hdr->tileWidth;\r\n  img->tileRows = (img->planeHeight + hdr->tileHeight - 1) / hdr->tileHeight;\r\n\r\n  if (img->tileCols > 0xFF || img->tileRows > 0xFF ||\r\n      img->planeWidth - hdr->tileWidth * (img->tileCols - 1) < 0x16 ||\r\n      img->planeHeight - hdr->tileHeight * (img->tileRows - 1) < 0x16)\r\n    return -1;\r\n\r\n  img->tiles = 0;\r\n  img->levels = hdr->imageLevels;\r\n  img->subbandCount = 3 * img->levels + 1; // 3 bands per level + one last LL\r\n  img->nPlanes = hdr->nPlanes;\r\n  img->nBits = hdr->nBits;\r\n  img->encType = hdr->encType;\r\n  img->samplePrecision = hdr->nBits + IncrBitTable[4 * hdr->encType + 2] + 1;\r\n  img->mdatOffset = mdatOffset + hdr->mdatHdrSize;\r\n  img->mdatSize = mdatSize;\r\n  img->planeBuf = 0;\r\n  img->outBufs[0] = img->outBufs[1] = img->outBufs[2] = img->outBufs[3] = 0;\r\n\r\n  // The encoding type 3 needs all 4 planes to be decoded to generate row of\r\n  // RGGB values. It seems to be using some other colour space for raw encoding\r\n  // It is a massive buffer so ideallly it will need a different approach:\r\n  // decode planes line by line and convert single line then without\r\n  // intermediate plane buffer. At the moment though it's too many changes so\r\n  // left as is.\r\n  if (img->encType == 3 && img->nPlanes == 4 && img->nBits > 8)\r\n  {\r\n    img->planeBuf =\r\n        (int16_t *)\r\n#ifdef LIBRAW_CR3_MEMPOOL\r\n\t\timg->memmgr.\r\n#endif\r\n\t\tmalloc(img->planeHeight * img->planeWidth * img->nPlanes *\r\n                          ((img->samplePrecision + 7) >> 3));\r\n    if (!img->planeBuf)\r\n      return -1;\r\n  }\r\n\r\n  int32_t rowSize = 2 * img->planeWidth;\r\n\r\n  if (img->nPlanes == 1)\r\n    img->outBufs[0] = outBuf;\r\n  else\r\n    switch (hdr->cfaLayout)\r\n    {\r\n    case 0:\r\n      // R G\r\n      // G B\r\n      img->outBufs[0] = outBuf;\r\n      img->outBufs[1] = outBuf + 1;\r\n      img->outBufs[2] = outBuf + rowSize;\r\n      img->outBufs[3] = img->outBufs[2] + 1;\r\n      break;\r\n    case 1:\r\n      // G R\r\n      // B G\r\n      img->outBufs[1] = outBuf;\r\n      img->outBufs[0] = outBuf + 1;\r\n      img->outBufs[3] = outBuf + rowSize;\r\n      img->outBufs[2] = img->outBufs[3] + 1;\r\n      break;\r\n    case 2:\r\n      // G B\r\n      // R G\r\n      img->outBufs[2] = outBuf;\r\n      img->outBufs[3] = outBuf + 1;\r\n      img->outBufs[0] = outBuf + rowSize;\r\n      img->outBufs[1] = img->outBufs[0] + 1;\r\n      break;\r\n    case 3:\r\n      // B G\r\n      // G R\r\n      img->outBufs[3] = outBuf;\r\n      img->outBufs[2] = outBuf + 1;\r\n      img->outBufs[1] = outBuf + rowSize;\r\n      img->outBufs[0] = img->outBufs[1] + 1;\r\n      break;\r\n    }\r\n\r\n  // read header\r\n  return crxReadImageHeaders(hdr, img, mdatHdrPtr, mdatSize);\r\n}\r\n\r\nint crxFreeImageData(CrxImage *img)\r\n{\r\n#ifdef LIBRAW_CR3_MEMPOOL\r\n\timg->memmgr.cleanup();\r\n#else\r\n  CrxTile *tile = img->tiles;\r\n  int nTiles = img->tileRows * img->tileCols;\r\n\r\n  if (img->tiles)\r\n  {\r\n    for (int32_t curTile = 0; curTile < nTiles; curTile++, tile++)\r\n      if (tile[curTile].comps)\r\n        for (int32_t curPlane = 0; curPlane < img->nPlanes; curPlane++)\r\n          crxFreeSubbandData(img, tile[curTile].comps + curPlane);\r\n    free(img->tiles);\r\n    img->tiles = 0;\r\n  }\r\n\r\n  if (img->planeBuf)\r\n  {\r\n    free(img->planeBuf);\r\n    img->planeBuf = 0;\r\n  }\r\n#endif\r\n  return 0;\r\n}\r\n\r\nvoid LibRaw::crxLoadDecodeLoop(void *img, int nPlanes)\r\n{\r\n#ifdef LIBRAW_USE_OPENMP\r\n  int results[4]; // nPlanes is always <= 4\r\n#pragma omp parallel for\r\n  for (int32_t plane = 0; plane < nPlanes; ++plane)\r\n    results[plane] = crxDecodePlane(img, plane);\r\n\r\n  for (int32_t plane = 0; plane < nPlanes; ++plane)\r\n    if (results[plane])\r\n      derror();\r\n#else\r\n  for (int32_t plane = 0; plane < nPlanes; ++plane)\r\n    if (crxDecodePlane(img, plane))\r\n      derror();\r\n#endif\r\n}\r\n\r\nvoid LibRaw::crxConvertPlaneLineDf(void *p, int imageRow)\r\n{\r\n  crxConvertPlaneLine((CrxImage *)p, imageRow);\r\n}\r\n\r\nvoid LibRaw::crxLoadFinalizeLoopE3(void *p, int planeHeight)\r\n{\r\n#ifdef LIBRAW_USE_OPENMP\r\n#pragma omp parallel for\r\n#endif\r\n  for (int i = 0; i < planeHeight; ++i)\r\n    crxConvertPlaneLineDf(p, i);\r\n}\r\n\r\nvoid LibRaw::crxLoadRaw()\r\n{\r\n  CrxImage img;\r\n  if (libraw_internal_data.unpacker_data.crx_track_selected < 0 ||\r\n      libraw_internal_data.unpacker_data.crx_track_selected >=\r\n          LIBRAW_CRXTRACKS_MAXCOUNT)\r\n    derror();\r\n  crx_data_header_t hdr =\r\n      libraw_internal_data.unpacker_data\r\n          .crx_header[libraw_internal_data.unpacker_data.crx_track_selected];\r\n\r\n  img.input = libraw_internal_data.internal_data.input;\r\n\r\n  // update sizes for the planes\r\n  if (hdr.nPlanes == 4)\r\n  {\r\n    hdr.f_width >>= 1;\r\n    hdr.f_height >>= 1;\r\n    hdr.tileWidth >>= 1;\r\n    hdr.tileHeight >>= 1;\r\n  }\r\n\r\n  imgdata.color.maximum = (1 << hdr.nBits) - 1;\r\n\r\n  uint8_t *hdrBuf = (uint8_t *)malloc(hdr.mdatHdrSize);\r\n\r\n  // read image header\r\n#ifdef LIBRAW_USE_OPENMP\r\n#pragma omp critical\r\n#endif\r\n  {\r\n#ifndef LIBRAW_USE_OPENMP\r\n    libraw_internal_data.internal_data.input->lock();\r\n#endif\r\n    libraw_internal_data.internal_data.input->seek(\r\n        libraw_internal_data.unpacker_data.data_offset, SEEK_SET);\r\n    libraw_internal_data.internal_data.input->read(hdrBuf, 1, hdr.mdatHdrSize);\r\n#ifndef LIBRAW_USE_OPENMP\r\n    libraw_internal_data.internal_data.input->unlock();\r\n#endif\r\n  }\r\n\r\n  // parse and setup the image data\r\n  if (crxSetupImageData(&hdr, &img, (int16_t *)imgdata.rawdata.raw_image,\r\n                        libraw_internal_data.unpacker_data.data_offset,\r\n                        libraw_internal_data.unpacker_data.data_size, hdrBuf))\r\n    derror();\r\n  free(hdrBuf);\r\n\r\n  crxLoadDecodeLoop(&img, hdr.nPlanes);\r\n\r\n  if (img.encType == 3)\r\n    crxLoadFinalizeLoopE3(&img, img.planeHeight);\r\n\r\n  crxFreeImageData(&img);\r\n}\r\n\r\nint LibRaw::crxParseImageHeader(uchar *cmp1TagData, int nTrack)\r\n{\r\n  if (nTrack < 0 || nTrack >= LIBRAW_CRXTRACKS_MAXCOUNT)\r\n    return -1;\r\n  if (!cmp1TagData)\r\n    return -1;\r\n\r\n  crx_data_header_t *hdr =\r\n      &libraw_internal_data.unpacker_data.crx_header[nTrack];\r\n\r\n  hdr->version = sgetn(2, cmp1TagData + 4);\r\n  hdr->f_width = sgetn(4, cmp1TagData + 8);\r\n  hdr->f_height = sgetn(4, cmp1TagData + 12);\r\n  hdr->tileWidth = sgetn(4, cmp1TagData + 16);\r\n  hdr->tileHeight = sgetn(4, cmp1TagData + 20);\r\n  hdr->nBits = cmp1TagData[24];\r\n  hdr->nPlanes = cmp1TagData[25] >> 4;\r\n  hdr->cfaLayout = cmp1TagData[25] & 0xF;\r\n  hdr->encType = cmp1TagData[26] >> 4;\r\n  hdr->imageLevels = cmp1TagData[26] & 0xF;\r\n  hdr->hasTileCols = cmp1TagData[27] >> 7;\r\n  hdr->hasTileRows = (cmp1TagData[27] >> 6) & 1;\r\n  hdr->mdatHdrSize = sgetn(4, cmp1TagData + 28);\r\n\r\n  // validation\r\n  if (hdr->version != 0x100 || !hdr->mdatHdrSize)\r\n    return -1;\r\n  if (hdr->encType == 1)\r\n  {\r\n    if (hdr->nBits > 15)\r\n      return -1;\r\n  }\r\n  else\r\n  {\r\n    if (hdr->encType && hdr->encType != 3)\r\n      return -1;\r\n    if (hdr->nBits > 14)\r\n      return -1;\r\n  }\r\n\r\n  if (hdr->nPlanes == 1)\r\n  {\r\n    if (hdr->cfaLayout || hdr->encType)\r\n      return -1;\r\n    if (hdr->nBits != 8)\r\n      return -1;\r\n  }\r\n  else if (hdr->nPlanes != 4 || hdr->f_width & 1 || hdr->f_height & 1 ||\r\n           hdr->tileWidth & 1 || hdr->tileHeight & 1 || hdr->cfaLayout > 3u ||\r\n           (hdr->encType && hdr->encType != 1 && hdr->encType != 3) ||\r\n           hdr->nBits == 8)\r\n    return -1;\r\n\r\n  if (hdr->tileWidth > hdr->f_width || hdr->tileHeight > hdr->f_height)\r\n    return -1;\r\n\r\n  if (hdr->imageLevels > 3 || hdr->hasTileCols > 1 || hdr->hasTileRows > 1)\r\n    return -1;\r\n  return 0;\r\n}\r\n\r\n#undef _abs\r\n#undef _min\r\n#undef _constrain\r\n#undef libraw_inline\r\n"], "filenames": ["libraw/libraw_const.h", "src/decoders/crx.cpp"], "buggy_code_start_loc": [28, 155], "buggy_code_end_loc": [28, 2358], "fixing_code_start_loc": [29, 156], "fixing_code_end_loc": [34, 2391], "type": "CWE-770", "message": "In LibRaw, there is a memory corruption vulnerability within the \"crxFreeSubbandData()\" function (libraw\\src\\decoders\\crx.cpp) when processing cr3 files.", "other": {"cve": {"id": "CVE-2020-35534", "sourceIdentifier": "secalert@redhat.com", "published": "2022-09-01T18:15:08.970", "lastModified": "2022-09-07T17:35:56.900", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "In LibRaw, there is a memory corruption vulnerability within the \"crxFreeSubbandData()\" function (libraw\\src\\decoders\\crx.cpp) when processing cr3 files."}, {"lang": "es", "value": "En LibRaw, se presenta una vulnerabilidad de corrupci\u00f3n de memoria en la funci\u00f3n \"crxFreeSubbandData()\" (libraw\\src\\decoders\\crx.cpp) cuando son procesados archivos cr3"}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:L/AC:L/PR:N/UI:R/S:U/C:N/I:N/A:H", "attackVector": "LOCAL", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "NONE", "integrityImpact": "NONE", "availabilityImpact": "HIGH", "baseScore": 5.5, "baseSeverity": "MEDIUM"}, "exploitabilityScore": 1.8, "impactScore": 3.6}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-770"}]}, {"source": "secalert@redhat.com", "type": "Secondary", "description": [{"lang": "en", "value": "CWE-400"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.20.0:-:*:*:*:*:*:*", "matchCriteriaId": "E00F0C8F-11AC-42B2-8D85-27028B41EBF3"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.20.0:rc2:*:*:*:*:*:*", "matchCriteriaId": "B4B8669B-CE7F-47D2-9111-E7787EAD6E7E"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.20.1:*:*:*:*:*:*:*", "matchCriteriaId": "8269B02E-558F-4AA5-9EEA-87226A3D1816"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.20.2:*:*:*:*:*:*:*", "matchCriteriaId": "06DBABB8-8921-4E8B-B9E5-FFE6CCE79EB9"}, {"vulnerable": true, "criteria": "cpe:2.3:a:libraw:libraw:0.21.0:beta1:*:*:*:*:*:*", "matchCriteriaId": "36C296E2-1899-457B-9EB2-916A33E383C2"}]}]}], "references": [{"url": "https://github.com/LibRaw/LibRaw/commit/e41f331e90b383e3208cefb74e006df44bf3a4b8", "source": "secalert@redhat.com", "tags": ["Patch", "Third Party Advisory"]}, {"url": "https://github.com/LibRaw/LibRaw/issues/279", "source": "secalert@redhat.com", "tags": ["Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/LibRaw/LibRaw/commit/e41f331e90b383e3208cefb74e006df44bf3a4b8"}}