{"buggy_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%               FFFFF   OOO   U   U  RRRR   IIIII  EEEEE  RRRR                %\n%               F      O   O  U   U  R   R    I    E      R   R               %\n%               FFF    O   O  U   U  RRRR     I    EEE    RRRR                %\n%               F      O   O  U   U  R R      I    E      R R                 %\n%               F       OOO    UUU   R  R   IIIII  EEEEE  R  R                %\n%                                                                             %\n%                                                                             %\n%                MagickCore Discrete Fourier Transform Methods                %\n%                                                                             %\n%                              Software Design                                %\n%                                Sean Burke                                   %\n%                               Fred Weinhaus                                 %\n%                                   Cristy                                    %\n%                                 July 2009                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/fourier.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#if defined(MAGICKCORE_FFTW_DELEGATE)\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n#include <complex.h>\n#endif\n#include <fftw3.h>\n#if !defined(MAGICKCORE_HAVE_CABS)\n#define cabs(z)  (sqrt(z[0]*z[0]+z[1]*z[1]))\n#endif\n#if !defined(MAGICKCORE_HAVE_CARG)\n#define carg(z)  (atan2(cimag(z),creal(z)))\n#endif\n#if !defined(MAGICKCORE_HAVE_CIMAG)\n#define cimag(z)  (z[1])\n#endif\n#if !defined(MAGICKCORE_HAVE_CREAL)\n#define creal(z)  (z[0])\n#endif\n#endif\n\f\n/*\n  Typedef declarations.\n*/\ntypedef struct _FourierInfo\n{\n  PixelChannel\n    channel;\n\n  MagickBooleanType\n    modulus;\n\n  size_t\n    width,\n    height;\n\n  ssize_t\n    center;\n} FourierInfo;\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     C o m p l e x I m a g e s                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ComplexImages() performs complex mathematics on an image sequence.\n%\n%  The format of the ComplexImages method is:\n%\n%      MagickBooleanType ComplexImages(Image *images,const ComplexOperator op,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o op: A complex operator.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,\n  ExceptionInfo *exception)\n{\n#define ComplexImageTag  \"Complex/Image\"\n\n  CacheView\n    *Ai_view,\n    *Ar_view,\n    *Bi_view,\n    *Br_view,\n    *Ci_view,\n    *Cr_view;\n\n  const char\n    *artifact;\n\n  const Image\n    *Ai_image,\n    *Ar_image,\n    *Bi_image,\n    *Br_image;\n\n  double\n    snr;\n\n  Image\n    *Ci_image,\n    *complex_images,\n    *Cr_image,\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  ssize_t\n    y;\n\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (images->next == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ImageSequenceRequired\",\"`%s'\",images->filename);\n      return((Image *) NULL);\n    }\n  image=CloneImage(images,0,0,MagickTrue,exception);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return(image);\n    }\n  image->depth=32UL;\n  complex_images=NewImageList();\n  AppendImageToList(&complex_images,image);\n  image=CloneImage(images,0,0,MagickTrue,exception);\n  if (image == (Image *) NULL)\n    {\n      complex_images=DestroyImageList(complex_images);\n      return(complex_images);\n    }\n  AppendImageToList(&complex_images,image);\n  /*\n    Apply complex mathematics to image pixels.\n  */\n  artifact=GetImageArtifact(image,\"complex:snr\");\n  snr=0.0;\n  if (artifact != (const char *) NULL)\n    snr=StringToDouble(artifact,(char **) NULL);\n  Ar_image=images;\n  Ai_image=images->next;\n  Br_image=images;\n  Bi_image=images->next;\n  if ((images->next->next != (Image *) NULL) &&\n      (images->next->next->next != (Image *) NULL))\n    {\n      Br_image=images->next->next;\n      Bi_image=images->next->next->next;\n    }\n  Cr_image=complex_images;\n  Ci_image=complex_images->next;\n  Ar_view=AcquireVirtualCacheView(Ar_image,exception);\n  Ai_view=AcquireVirtualCacheView(Ai_image,exception);\n  Br_view=AcquireVirtualCacheView(Br_image,exception);\n  Bi_view=AcquireVirtualCacheView(Bi_image,exception);\n  Cr_view=AcquireAuthenticCacheView(Cr_image,exception);\n  Ci_view=AcquireAuthenticCacheView(Ci_image,exception);\n  status=MagickTrue;\n  progress=0;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(Cr_image,complex_images,Cr_image->rows,1L)\n#endif\n  for (y=0; y < (ssize_t) Cr_image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict Ai,\n      *magick_restrict Ar,\n      *magick_restrict Bi,\n      *magick_restrict Br;\n\n    register Quantum\n      *magick_restrict Ci,\n      *magick_restrict Cr;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    Ar=GetCacheViewVirtualPixels(Ar_view,0,y,Cr_image->columns,1,exception);\n    Ai=GetCacheViewVirtualPixels(Ai_view,0,y,Cr_image->columns,1,exception);\n    Br=GetCacheViewVirtualPixels(Br_view,0,y,Cr_image->columns,1,exception);\n    Bi=GetCacheViewVirtualPixels(Bi_view,0,y,Cr_image->columns,1,exception);\n    Cr=QueueCacheViewAuthenticPixels(Cr_view,0,y,Cr_image->columns,1,exception);\n    Ci=QueueCacheViewAuthenticPixels(Ci_view,0,y,Ci_image->columns,1,exception);\n    if ((Ar == (const Quantum *) NULL) || (Ai == (const Quantum *) NULL) || \n        (Br == (const Quantum *) NULL) || (Bi == (const Quantum *) NULL) ||\n        (Cr == (Quantum *) NULL) || (Ci == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) Cr_image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) GetPixelChannels(Cr_image); i++)\n      {\n        switch (op)\n        {\n          case AddComplexOperator:\n          {\n            Cr[i]=Ar[i]+Br[i];\n            Ci[i]=Ai[i]+Bi[i];\n            break;\n          }\n          case ConjugateComplexOperator:\n          default:\n          {\n            Cr[i]=Ar[i];\n            Ci[i]=(-Bi[i]);\n            break;\n          }\n          case DivideComplexOperator:\n          {\n            double\n              gamma;\n\n            gamma=PerceptibleReciprocal((double) Br[i]*Br[i]+Bi[i]*Bi[i]+snr);\n            Cr[i]=gamma*((double) Ar[i]*Br[i]+(double) Ai[i]*Bi[i]);\n            Ci[i]=gamma*((double) Ai[i]*Br[i]-(double) Ar[i]*Bi[i]);\n            break;\n          }\n          case MagnitudePhaseComplexOperator:\n          {\n            Cr[i]=sqrt((double) Ar[i]*Ar[i]+(double) Ai[i]*Ai[i]);\n            Ci[i]=atan2((double) Ai[i],(double) Ar[i])/(2.0*MagickPI)+0.5;\n            break;\n          }\n          case MultiplyComplexOperator:\n          {\n            Cr[i]=QuantumScale*((double) Ar[i]*Br[i]-(double) Ai[i]*Bi[i]);\n            Ci[i]=QuantumScale*((double) Ai[i]*Br[i]+(double) Ar[i]*Bi[i]);\n            break;\n          }\n          case RealImaginaryComplexOperator:\n          {\n            Cr[i]=Ar[i]*cos(2.0*MagickPI*(Ai[i]-0.5));\n            Ci[i]=Ar[i]*sin(2.0*MagickPI*(Ai[i]-0.5));\n            break;\n          }\n          case SubtractComplexOperator:\n          {\n            Cr[i]=Ar[i]-Br[i];\n            Ci[i]=Ai[i]-Bi[i];\n            break;\n          }\n        }\n      }\n      Ar+=GetPixelChannels(Ar_image);\n      Ai+=GetPixelChannels(Ai_image);\n      Br+=GetPixelChannels(Br_image);\n      Bi+=GetPixelChannels(Bi_image);\n      Cr+=GetPixelChannels(Cr_image);\n      Ci+=GetPixelChannels(Ci_image);\n    }\n    if (SyncCacheViewAuthenticPixels(Ci_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (SyncCacheViewAuthenticPixels(Cr_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (images->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(images,ComplexImageTag,progress,images->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  Cr_view=DestroyCacheView(Cr_view);\n  Ci_view=DestroyCacheView(Ci_view);\n  Br_view=DestroyCacheView(Br_view);\n  Bi_view=DestroyCacheView(Bi_view);\n  Ar_view=DestroyCacheView(Ar_view);\n  Ai_view=DestroyCacheView(Ai_view);\n  if (status == MagickFalse)\n    complex_images=DestroyImageList(complex_images);\n  return(complex_images);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     F o r w a r d F o u r i e r T r a n s f o r m I m a g e                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ForwardFourierTransformImage() implements the discrete Fourier transform\n%  (DFT) of the image either as a magnitude / phase or real / imaginary image\n%  pair.\n%\n%  The format of the ForwadFourierTransformImage method is:\n%\n%      Image *ForwardFourierTransformImage(const Image *image,\n%        const MagickBooleanType modulus,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o modulus: if true, return as transform as a magnitude / phase pair\n%      otherwise a real / imaginary image pair.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(MAGICKCORE_FFTW_DELEGATE)\n\nstatic MagickBooleanType RollFourier(const size_t width,const size_t height,\n  const ssize_t x_offset,const ssize_t y_offset,double *roll_pixels)\n{\n  double\n    *source_pixels;\n\n  MemoryInfo\n    *source_info;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    u,\n    v,\n    y;\n\n  /*\n    Move zero frequency (DC, average color) from (0,0) to (width/2,height/2).\n  */\n  source_info=AcquireVirtualMemory(width,height*sizeof(*source_pixels));\n  if (source_info == (MemoryInfo *) NULL)\n    return(MagickFalse);\n  source_pixels=(double *) GetVirtualMemoryBlob(source_info);\n  i=0L;\n  for (y=0L; y < (ssize_t) height; y++)\n  {\n    if (y_offset < 0L)\n      v=((y+y_offset) < 0L) ? y+y_offset+(ssize_t) height : y+y_offset;\n    else\n      v=((y+y_offset) > ((ssize_t) height-1L)) ? y+y_offset-(ssize_t) height :\n        y+y_offset;\n    for (x=0L; x < (ssize_t) width; x++)\n    {\n      if (x_offset < 0L)\n        u=((x+x_offset) < 0L) ? x+x_offset+(ssize_t) width : x+x_offset;\n      else\n        u=((x+x_offset) > ((ssize_t) width-1L)) ? x+x_offset-(ssize_t) width :\n          x+x_offset;\n      source_pixels[v*width+u]=roll_pixels[i++];\n    }\n  }\n  (void) memcpy(roll_pixels,source_pixels,height*width*\n    sizeof(*source_pixels));\n  source_info=RelinquishVirtualMemory(source_info);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType ForwardQuadrantSwap(const size_t width,\n  const size_t height,double *source_pixels,double *forward_pixels)\n{\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    center,\n    y;\n\n  /*\n    Swap quadrants.\n  */\n  center=(ssize_t) (width/2L)+1L;\n  status=RollFourier((size_t) center,height,0L,(ssize_t) height/2L,\n    source_pixels);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  for (y=0L; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      forward_pixels[y*width+x+width/2L]=source_pixels[y*center+x];\n  for (y=1; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      forward_pixels[(height-y)*width+width/2L-x-1L]=\n        source_pixels[y*center+x+1L];\n  for (x=0L; x < (ssize_t) (width/2L); x++)\n    forward_pixels[width/2L-x-1L]=source_pixels[x+1L];\n  return(MagickTrue);\n}\n\nstatic void CorrectPhaseLHS(const size_t width,const size_t height,\n  double *fourier_pixels)\n{\n  register ssize_t\n    x;\n\n  ssize_t\n    y;\n\n  for (y=0L; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      fourier_pixels[y*width+x]*=(-1.0);\n}\n\nstatic MagickBooleanType ForwardFourier(const FourierInfo *fourier_info,\n  Image *image,double *magnitude,double *phase,ExceptionInfo *exception)\n{\n  CacheView\n    *magnitude_view,\n    *phase_view;\n\n  double\n    *magnitude_pixels,\n    *phase_pixels;\n\n  Image\n    *magnitude_image,\n    *phase_image;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *magnitude_info,\n    *phase_info;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    i,\n    y;\n\n  magnitude_image=GetFirstImageInList(image);\n  phase_image=GetNextImageInList(image);\n  if (phase_image == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ImageSequenceRequired\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  /*\n    Create \"Fourier Transform\" image from constituent arrays.\n  */\n  magnitude_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*magnitude_pixels));\n  phase_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*phase_pixels));\n  if ((magnitude_info == (MemoryInfo *) NULL) ||\n      (phase_info == (MemoryInfo *) NULL))\n    {\n      if (phase_info != (MemoryInfo *) NULL)\n        phase_info=RelinquishVirtualMemory(phase_info);\n      if (magnitude_info != (MemoryInfo *) NULL)\n        magnitude_info=RelinquishVirtualMemory(magnitude_info);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  magnitude_pixels=(double *) GetVirtualMemoryBlob(magnitude_info);\n  (void) memset(magnitude_pixels,0,fourier_info->width*\n    fourier_info->height*sizeof(*magnitude_pixels));\n  phase_pixels=(double *) GetVirtualMemoryBlob(phase_info);\n  (void) memset(phase_pixels,0,fourier_info->width*\n    fourier_info->height*sizeof(*phase_pixels));\n  status=ForwardQuadrantSwap(fourier_info->width,fourier_info->height,\n    magnitude,magnitude_pixels);\n  if (status != MagickFalse)\n    status=ForwardQuadrantSwap(fourier_info->width,fourier_info->height,phase,\n      phase_pixels);\n  CorrectPhaseLHS(fourier_info->width,fourier_info->height,phase_pixels);\n  if (fourier_info->modulus != MagickFalse)\n    {\n      i=0L;\n      for (y=0L; y < (ssize_t) fourier_info->height; y++)\n        for (x=0L; x < (ssize_t) fourier_info->width; x++)\n        {\n          phase_pixels[i]/=(2.0*MagickPI);\n          phase_pixels[i]+=0.5;\n          i++;\n        }\n    }\n  magnitude_view=AcquireAuthenticCacheView(magnitude_image,exception);\n  i=0L;\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    q=GetCacheViewAuthenticPixels(magnitude_view,0L,y,fourier_info->width,1UL,\n      exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          SetPixelRed(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          SetPixelGreen(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          SetPixelBlue(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          SetPixelBlack(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          SetPixelAlpha(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n      }\n      i++;\n      q+=GetPixelChannels(magnitude_image);\n    }\n    status=SyncCacheViewAuthenticPixels(magnitude_view,exception);\n    if (status == MagickFalse)\n      break;\n  }\n  magnitude_view=DestroyCacheView(magnitude_view);\n  i=0L;\n  phase_view=AcquireAuthenticCacheView(phase_image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    q=GetCacheViewAuthenticPixels(phase_view,0L,y,fourier_info->width,1UL,\n      exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          SetPixelRed(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          SetPixelGreen(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          SetPixelBlue(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          SetPixelBlack(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          SetPixelAlpha(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n      }\n      i++;\n      q+=GetPixelChannels(phase_image);\n    }\n    status=SyncCacheViewAuthenticPixels(phase_view,exception);\n    if (status == MagickFalse)\n      break;\n   }\n  phase_view=DestroyCacheView(phase_view);\n  phase_info=RelinquishVirtualMemory(phase_info);\n  magnitude_info=RelinquishVirtualMemory(magnitude_info);\n  return(status);\n}\n\nstatic MagickBooleanType ForwardFourierTransform(FourierInfo *fourier_info,\n  const Image *image,double *magnitude_pixels,double *phase_pixels,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  const char\n    *value;\n\n  double\n    *source_pixels;\n\n  fftw_complex\n    *forward_pixels;\n\n  fftw_plan\n    fftw_r2c_plan;\n\n  MemoryInfo\n    *forward_info,\n    *source_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  /*\n    Generate the forward Fourier transform.\n  */\n  source_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*source_pixels));\n  if (source_info == (MemoryInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  source_pixels=(double *) GetVirtualMemoryBlob(source_info);\n  memset(source_pixels,0,fourier_info->width*fourier_info->height*\n    sizeof(*source_pixels));\n  i=0L;\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    p=GetCacheViewVirtualPixels(image_view,0L,y,fourier_info->width,1UL,\n      exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          source_pixels[i]=QuantumScale*GetPixelRed(image,p);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          source_pixels[i]=QuantumScale*GetPixelGreen(image,p);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          source_pixels[i]=QuantumScale*GetPixelBlue(image,p);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          source_pixels[i]=QuantumScale*GetPixelBlack(image,p);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          source_pixels[i]=QuantumScale*GetPixelAlpha(image,p);\n          break;\n        }\n      }\n      i++;\n      p+=GetPixelChannels(image);\n    }\n  }\n  image_view=DestroyCacheView(image_view);\n  forward_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    (fourier_info->height/2+1)*sizeof(*forward_pixels));\n  if (forward_info == (MemoryInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      source_info=(MemoryInfo *) RelinquishVirtualMemory(source_info);\n      return(MagickFalse);\n    }\n  forward_pixels=(fftw_complex *) GetVirtualMemoryBlob(forward_info);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp critical (MagickCore_ForwardFourierTransform)\n#endif\n  fftw_r2c_plan=fftw_plan_dft_r2c_2d(fourier_info->width,fourier_info->height,\n    source_pixels,forward_pixels,FFTW_ESTIMATE);\n  fftw_execute_dft_r2c(fftw_r2c_plan,source_pixels,forward_pixels);\n  fftw_destroy_plan(fftw_r2c_plan);\n  source_info=(MemoryInfo *) RelinquishVirtualMemory(source_info);\n  value=GetImageArtifact(image,\"fourier:normalize\");\n  if ((value == (const char *) NULL) || (LocaleCompare(value,\"forward\") == 0))\n    {\n      double\n        gamma;\n\n      /*\n        Normalize fourier transform.\n      */\n      i=0L;\n      gamma=PerceptibleReciprocal((double) fourier_info->width*\n        fourier_info->height);\n      for (y=0L; y < (ssize_t) fourier_info->height; y++)\n        for (x=0L; x < (ssize_t) fourier_info->center; x++)\n        {\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n          forward_pixels[i]*=gamma;\n#else\n          forward_pixels[i][0]*=gamma;\n          forward_pixels[i][1]*=gamma;\n#endif\n          i++;\n        }\n    }\n  /*\n    Generate magnitude and phase (or real and imaginary).\n  */\n  i=0L;\n  if (fourier_info->modulus != MagickFalse)\n    for (y=0L; y < (ssize_t) fourier_info->height; y++)\n      for (x=0L; x < (ssize_t) fourier_info->center; x++)\n      {\n        magnitude_pixels[i]=cabs(forward_pixels[i]);\n        phase_pixels[i]=carg(forward_pixels[i]);\n        i++;\n      }\n  else\n    for (y=0L; y < (ssize_t) fourier_info->height; y++)\n      for (x=0L; x < (ssize_t) fourier_info->center; x++)\n      {\n        magnitude_pixels[i]=creal(forward_pixels[i]);\n        phase_pixels[i]=cimag(forward_pixels[i]);\n        i++;\n      }\n  forward_info=(MemoryInfo *) RelinquishVirtualMemory(forward_info);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType ForwardFourierTransformChannel(const Image *image,\n  const PixelChannel channel,const MagickBooleanType modulus,\n  Image *fourier_image,ExceptionInfo *exception)\n{\n  double\n    *magnitude_pixels,\n    *phase_pixels;\n\n  FourierInfo\n    fourier_info;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *magnitude_info,\n    *phase_info;\n\n  fourier_info.width=image->columns;\n  fourier_info.height=image->rows;\n  if ((image->columns != image->rows) || ((image->columns % 2) != 0) ||\n      ((image->rows % 2) != 0))\n    {\n      size_t extent=image->columns < image->rows ? image->rows : image->columns;\n      fourier_info.width=(extent & 0x01) == 1 ? extent+1UL : extent;\n    }\n  fourier_info.height=fourier_info.width;\n  fourier_info.center=(ssize_t) (fourier_info.width/2L)+1L;\n  fourier_info.channel=channel;\n  fourier_info.modulus=modulus;\n  magnitude_info=AcquireVirtualMemory((size_t) fourier_info.width,\n    (fourier_info.height/2+1)*sizeof(*magnitude_pixels));\n  phase_info=AcquireVirtualMemory((size_t) fourier_info.width,\n    (fourier_info.height/2+1)*sizeof(*phase_pixels));\n  if ((magnitude_info == (MemoryInfo *) NULL) ||\n      (phase_info == (MemoryInfo *) NULL))\n    {\n      if (phase_info != (MemoryInfo *) NULL)\n        phase_info=RelinquishVirtualMemory(phase_info);\n      if (magnitude_info == (MemoryInfo *) NULL)\n        magnitude_info=RelinquishVirtualMemory(magnitude_info);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  magnitude_pixels=(double *) GetVirtualMemoryBlob(magnitude_info);\n  phase_pixels=(double *) GetVirtualMemoryBlob(phase_info);\n  status=ForwardFourierTransform(&fourier_info,image,magnitude_pixels,\n    phase_pixels,exception);\n  if (status != MagickFalse)\n    status=ForwardFourier(&fourier_info,fourier_image,magnitude_pixels,\n      phase_pixels,exception);\n  phase_info=RelinquishVirtualMemory(phase_info);\n  magnitude_info=RelinquishVirtualMemory(magnitude_info);\n  return(status);\n}\n#endif\n\nMagickExport Image *ForwardFourierTransformImage(const Image *image,\n  const MagickBooleanType modulus,ExceptionInfo *exception)\n{\n  Image\n    *fourier_image;\n\n  fourier_image=NewImageList();\n#if !defined(MAGICKCORE_FFTW_DELEGATE)\n  (void) modulus;\n  (void) ThrowMagickException(exception,GetMagickModule(),\n    MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (FFTW)\",\n    image->filename);\n#else\n  {\n    Image\n      *magnitude_image;\n\n    size_t\n      height,\n      width;\n\n    width=image->columns;\n    height=image->rows;\n    if ((image->columns != image->rows) || ((image->columns % 2) != 0) ||\n        ((image->rows % 2) != 0))\n      {\n        size_t extent=image->columns < image->rows ? image->rows :\n          image->columns;\n        width=(extent & 0x01) == 1 ? extent+1UL : extent;\n      }\n    height=width;\n    magnitude_image=CloneImage(image,width,height,MagickTrue,exception);\n    if (magnitude_image != (Image *) NULL)\n      {\n        Image\n          *phase_image;\n\n        magnitude_image->storage_class=DirectClass;\n        magnitude_image->depth=32UL;\n        phase_image=CloneImage(image,width,height,MagickTrue,exception);\n        if (phase_image == (Image *) NULL)\n          magnitude_image=DestroyImage(magnitude_image);\n        else\n          {\n            MagickBooleanType\n              is_gray,\n              status;\n\n            phase_image->storage_class=DirectClass;\n            phase_image->depth=32UL;\n            AppendImageToList(&fourier_image,magnitude_image);\n            AppendImageToList(&fourier_image,phase_image);\n            status=MagickTrue;\n            is_gray=IsImageGray(image);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n            #pragma omp parallel sections\n#endif\n            {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                if (is_gray != MagickFalse)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    GrayPixelChannel,modulus,fourier_image,exception);\n                else\n                  thread_status=ForwardFourierTransformChannel(image,\n                    RedPixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                thread_status=MagickTrue;\n                if (is_gray == MagickFalse)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    GreenPixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                thread_status=MagickTrue;\n                if (is_gray == MagickFalse)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    BluePixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                thread_status=MagickTrue;\n                if (image->colorspace == CMYKColorspace)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    BlackPixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                thread_status=MagickTrue;\n                if (image->alpha_trait != UndefinedPixelTrait)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    AlphaPixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n            }\n            if (status == MagickFalse)\n              fourier_image=DestroyImageList(fourier_image);\n            fftw_cleanup();\n          }\n      }\n  }\n#endif\n  return(fourier_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     I n v e r s e F o u r i e r T r a n s f o r m I m a g e                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InverseFourierTransformImage() implements the inverse discrete Fourier\n%  transform (DFT) of the image either as a magnitude / phase or real /\n%  imaginary image pair.\n%\n%  The format of the InverseFourierTransformImage method is:\n%\n%      Image *InverseFourierTransformImage(const Image *magnitude_image,\n%        const Image *phase_image,const MagickBooleanType modulus,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o magnitude_image: the magnitude or real image.\n%\n%    o phase_image: the phase or imaginary image.\n%\n%    o modulus: if true, return transform as a magnitude / phase pair\n%      otherwise a real / imaginary image pair.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(MAGICKCORE_FFTW_DELEGATE)\nstatic MagickBooleanType InverseQuadrantSwap(const size_t width,\n  const size_t height,const double *source,double *destination)\n{\n  register ssize_t\n    x;\n\n  ssize_t\n    center,\n    y;\n\n  /*\n    Swap quadrants.\n  */\n  center=(ssize_t) (width/2L)+1L;\n  for (y=1L; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L+1L); x++)\n      destination[(height-y)*center-x+width/2L]=source[y*width+x];\n  for (y=0L; y < (ssize_t) height; y++)\n    destination[y*center]=source[y*width+width/2L];\n  for (x=0L; x < center; x++)\n    destination[x]=source[center-x-1L];\n  return(RollFourier(center,height,0L,(ssize_t) height/-2L,destination));\n}\n\nstatic MagickBooleanType InverseFourier(FourierInfo *fourier_info,\n  const Image *magnitude_image,const Image *phase_image,\n  fftw_complex *fourier_pixels,ExceptionInfo *exception)\n{\n  CacheView\n    *magnitude_view,\n    *phase_view;\n\n  double\n    *inverse_pixels,\n    *magnitude_pixels,\n    *phase_pixels;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *inverse_info,\n    *magnitude_info,\n    *phase_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  /*\n    Inverse fourier - read image and break down into a double array.\n  */\n  magnitude_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*magnitude_pixels));\n  phase_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*phase_pixels));\n  inverse_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    (fourier_info->height/2+1)*sizeof(*inverse_pixels));\n  if ((magnitude_info == (MemoryInfo *) NULL) ||\n      (phase_info == (MemoryInfo *) NULL) ||\n      (inverse_info == (MemoryInfo *) NULL))\n    {\n      if (magnitude_info != (MemoryInfo *) NULL)\n        magnitude_info=RelinquishVirtualMemory(magnitude_info);\n      if (phase_info != (MemoryInfo *) NULL)\n        phase_info=RelinquishVirtualMemory(phase_info);\n      if (inverse_info != (MemoryInfo *) NULL)\n        inverse_info=RelinquishVirtualMemory(inverse_info);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        magnitude_image->filename);\n      return(MagickFalse);\n    }\n  magnitude_pixels=(double *) GetVirtualMemoryBlob(magnitude_info);\n  phase_pixels=(double *) GetVirtualMemoryBlob(phase_info);\n  inverse_pixels=(double *) GetVirtualMemoryBlob(inverse_info);\n  i=0L;\n  magnitude_view=AcquireVirtualCacheView(magnitude_image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    p=GetCacheViewVirtualPixels(magnitude_view,0L,y,fourier_info->width,1UL,\n      exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelRed(magnitude_image,p);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelGreen(magnitude_image,p);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelBlue(magnitude_image,p);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelBlack(magnitude_image,p);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelAlpha(magnitude_image,p);\n          break;\n        }\n      }\n      i++;\n      p+=GetPixelChannels(magnitude_image);\n    }\n  }\n  magnitude_view=DestroyCacheView(magnitude_view);\n  status=InverseQuadrantSwap(fourier_info->width,fourier_info->height,\n    magnitude_pixels,inverse_pixels);\n  (void) memcpy(magnitude_pixels,inverse_pixels,fourier_info->height*\n    fourier_info->center*sizeof(*magnitude_pixels));\n  i=0L;\n  phase_view=AcquireVirtualCacheView(phase_image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    p=GetCacheViewVirtualPixels(phase_view,0,y,fourier_info->width,1,\n      exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelRed(phase_image,p);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelGreen(phase_image,p);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelBlue(phase_image,p);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelBlack(phase_image,p);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelAlpha(phase_image,p);\n          break;\n        }\n      }\n      i++;\n      p+=GetPixelChannels(phase_image);\n    }\n  }\n  if (fourier_info->modulus != MagickFalse)\n    {\n      i=0L;\n      for (y=0L; y < (ssize_t) fourier_info->height; y++)\n        for (x=0L; x < (ssize_t) fourier_info->width; x++)\n        {\n          phase_pixels[i]-=0.5;\n          phase_pixels[i]*=(2.0*MagickPI);\n          i++;\n        }\n    }\n  phase_view=DestroyCacheView(phase_view);\n  CorrectPhaseLHS(fourier_info->width,fourier_info->height,phase_pixels);\n  if (status != MagickFalse)\n    status=InverseQuadrantSwap(fourier_info->width,fourier_info->height,\n      phase_pixels,inverse_pixels);\n  (void) memcpy(phase_pixels,inverse_pixels,fourier_info->height*\n    fourier_info->center*sizeof(*phase_pixels));\n  inverse_info=RelinquishVirtualMemory(inverse_info);\n  /*\n    Merge two sets.\n  */\n  i=0L;\n  if (fourier_info->modulus != MagickFalse)\n    for (y=0L; y < (ssize_t) fourier_info->height; y++)\n       for (x=0L; x < (ssize_t) fourier_info->center; x++)\n       {\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n         fourier_pixels[i]=magnitude_pixels[i]*cos(phase_pixels[i])+I*\n           magnitude_pixels[i]*sin(phase_pixels[i]);\n#else\n         fourier_pixels[i][0]=magnitude_pixels[i]*cos(phase_pixels[i]);\n         fourier_pixels[i][1]=magnitude_pixels[i]*sin(phase_pixels[i]);\n#endif\n         i++;\n      }\n  else\n    for (y=0L; y < (ssize_t) fourier_info->height; y++)\n      for (x=0L; x < (ssize_t) fourier_info->center; x++)\n      {\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n        fourier_pixels[i]=magnitude_pixels[i]+I*phase_pixels[i];\n#else\n        fourier_pixels[i][0]=magnitude_pixels[i];\n        fourier_pixels[i][1]=phase_pixels[i];\n#endif\n        i++;\n      }\n  magnitude_info=RelinquishVirtualMemory(magnitude_info);\n  phase_info=RelinquishVirtualMemory(phase_info);\n  return(status);\n}\n\nstatic MagickBooleanType InverseFourierTransform(FourierInfo *fourier_info,\n  fftw_complex *fourier_pixels,Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  const char\n    *value;\n\n  double\n    *source_pixels;\n\n  fftw_plan\n    fftw_c2r_plan;\n\n  MemoryInfo\n    *source_info;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  source_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*source_pixels));\n  if (source_info == (MemoryInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  source_pixels=(double *) GetVirtualMemoryBlob(source_info);\n  value=GetImageArtifact(image,\"fourier:normalize\");\n  if (LocaleCompare(value,\"inverse\") == 0)\n    {\n      double\n        gamma;\n\n      /*\n        Normalize inverse transform.\n      */\n      i=0L;\n      gamma=PerceptibleReciprocal((double) fourier_info->width*\n        fourier_info->height);\n      for (y=0L; y < (ssize_t) fourier_info->height; y++)\n        for (x=0L; x < (ssize_t) fourier_info->center; x++)\n        {\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n          fourier_pixels[i]*=gamma;\n#else\n          fourier_pixels[i][0]*=gamma;\n          fourier_pixels[i][1]*=gamma;\n#endif\n          i++;\n        }\n    }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp critical (MagickCore_InverseFourierTransform)\n#endif\n  fftw_c2r_plan=fftw_plan_dft_c2r_2d(fourier_info->width,fourier_info->height,\n    fourier_pixels,source_pixels,FFTW_ESTIMATE);\n  fftw_execute_dft_c2r(fftw_c2r_plan,fourier_pixels,source_pixels);\n  fftw_destroy_plan(fftw_c2r_plan);\n  i=0L;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    if (y >= (ssize_t) image->rows)\n      break;\n    q=GetCacheViewAuthenticPixels(image_view,0L,y,fourier_info->width >\n      image->columns ? image->columns : fourier_info->width,1UL,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      if (x < (ssize_t) image->columns)\n        switch (fourier_info->channel)\n        {\n          case RedPixelChannel:\n          default:\n          {\n            SetPixelRed(image,ClampToQuantum(QuantumRange*source_pixels[i]),q);\n            break;\n          }\n          case GreenPixelChannel:\n          {\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*source_pixels[i]),\n              q);\n            break;\n          }\n          case BluePixelChannel:\n          {\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*source_pixels[i]),\n              q);\n            break;\n          }\n          case BlackPixelChannel:\n          {\n            SetPixelBlack(image,ClampToQuantum(QuantumRange*source_pixels[i]),\n              q);\n            break;\n          }\n          case AlphaPixelChannel:\n          {\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*source_pixels[i]),\n              q);\n            break;\n          }\n        }\n      i++;\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      break;\n  }\n  image_view=DestroyCacheView(image_view);\n  source_info=RelinquishVirtualMemory(source_info);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType InverseFourierTransformChannel(\n  const Image *magnitude_image,const Image *phase_image,\n  const PixelChannel channel,const MagickBooleanType modulus,\n  Image *fourier_image,ExceptionInfo *exception)\n{\n  fftw_complex\n    *inverse_pixels;\n\n  FourierInfo\n    fourier_info;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *inverse_info;\n\n  fourier_info.width=magnitude_image->columns;\n  fourier_info.height=magnitude_image->rows;\n  if ((magnitude_image->columns != magnitude_image->rows) ||\n      ((magnitude_image->columns % 2) != 0) ||\n      ((magnitude_image->rows % 2) != 0))\n    {\n      size_t extent=magnitude_image->columns < magnitude_image->rows ?\n        magnitude_image->rows : magnitude_image->columns;\n      fourier_info.width=(extent & 0x01) == 1 ? extent+1UL : extent;\n    }\n  fourier_info.height=fourier_info.width;\n  fourier_info.center=(ssize_t) (fourier_info.width/2L)+1L;\n  fourier_info.channel=channel;\n  fourier_info.modulus=modulus;\n  inverse_info=AcquireVirtualMemory((size_t) fourier_info.width,\n    (fourier_info.height/2+1)*sizeof(*inverse_pixels));\n  if (inverse_info == (MemoryInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        magnitude_image->filename);\n      return(MagickFalse);\n    }\n  inverse_pixels=(fftw_complex *) GetVirtualMemoryBlob(inverse_info);\n  status=InverseFourier(&fourier_info,magnitude_image,phase_image,\n    inverse_pixels,exception);\n  if (status != MagickFalse)\n    status=InverseFourierTransform(&fourier_info,inverse_pixels,fourier_image,\n      exception);\n  inverse_info=RelinquishVirtualMemory(inverse_info);\n  return(status);\n}\n#endif\n\nMagickExport Image *InverseFourierTransformImage(const Image *magnitude_image,\n  const Image *phase_image,const MagickBooleanType modulus,\n  ExceptionInfo *exception)\n{\n  Image\n    *fourier_image;\n\n  assert(magnitude_image != (Image *) NULL);\n  assert(magnitude_image->signature == MagickCoreSignature);\n  if (magnitude_image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      magnitude_image->filename);\n  if (phase_image == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ImageSequenceRequired\",\"`%s'\",magnitude_image->filename);\n      return((Image *) NULL);\n    }\n#if !defined(MAGICKCORE_FFTW_DELEGATE)\n  fourier_image=(Image *) NULL;\n  (void) modulus;\n  (void) ThrowMagickException(exception,GetMagickModule(),\n    MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (FFTW)\",\n    magnitude_image->filename);\n#else\n  {\n    fourier_image=CloneImage(magnitude_image,magnitude_image->columns,\n      magnitude_image->rows,MagickTrue,exception);\n    if (fourier_image != (Image *) NULL)\n      {\n        MagickBooleanType\n          is_gray,\n          status;\n\n        status=MagickTrue;\n        is_gray=IsImageGray(magnitude_image);\n        if (is_gray != MagickFalse)\n          is_gray=IsImageGray(phase_image);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp parallel sections\n#endif\n        {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            if (is_gray != MagickFalse)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,GrayPixelChannel,modulus,fourier_image,exception);\n            else\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,RedPixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            thread_status=MagickTrue;\n            if (is_gray == MagickFalse)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,GreenPixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            thread_status=MagickTrue;\n            if (is_gray == MagickFalse)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,BluePixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            thread_status=MagickTrue;\n            if (magnitude_image->colorspace == CMYKColorspace)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,BlackPixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            thread_status=MagickTrue;\n            if (magnitude_image->alpha_trait != UndefinedPixelTrait)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,AlphaPixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n        }\n        if (status == MagickFalse)\n          fourier_image=DestroyImage(fourier_image);\n      }\n    fftw_cleanup();\n  }\n#endif\n  return(fourier_image);\n}\n"], "fixing_code": ["/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%               FFFFF   OOO   U   U  RRRR   IIIII  EEEEE  RRRR                %\n%               F      O   O  U   U  R   R    I    E      R   R               %\n%               FFF    O   O  U   U  RRRR     I    EEE    RRRR                %\n%               F      O   O  U   U  R R      I    E      R R                 %\n%               F       OOO    UUU   R  R   IIIII  EEEEE  R  R                %\n%                                                                             %\n%                                                                             %\n%                MagickCore Discrete Fourier Transform Methods                %\n%                                                                             %\n%                              Software Design                                %\n%                                Sean Burke                                   %\n%                               Fred Weinhaus                                 %\n%                                   Cristy                                    %\n%                                 July 2009                                   %\n%                                                                             %\n%                                                                             %\n%  Copyright 1999-2019 ImageMagick Studio LLC, a non-profit organization      %\n%  dedicated to making software imaging solutions freely available.           %\n%                                                                             %\n%  You may not use this file except in compliance with the License.  You may  %\n%  obtain a copy of the License at                                            %\n%                                                                             %\n%    https://imagemagick.org/script/license.php                               %\n%                                                                             %\n%  Unless required by applicable law or agreed to in writing, software        %\n%  distributed under the License is distributed on an \"AS IS\" BASIS,          %\n%  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.   %\n%  See the License for the specific language governing permissions and        %\n%  limitations under the License.                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\n%\n*/\n\f\n/*\n  Include declarations.\n*/\n#include \"MagickCore/studio.h\"\n#include \"MagickCore/artifact.h\"\n#include \"MagickCore/attribute.h\"\n#include \"MagickCore/blob.h\"\n#include \"MagickCore/cache.h\"\n#include \"MagickCore/image.h\"\n#include \"MagickCore/image-private.h\"\n#include \"MagickCore/list.h\"\n#include \"MagickCore/fourier.h\"\n#include \"MagickCore/log.h\"\n#include \"MagickCore/memory_.h\"\n#include \"MagickCore/monitor.h\"\n#include \"MagickCore/monitor-private.h\"\n#include \"MagickCore/pixel-accessor.h\"\n#include \"MagickCore/pixel-private.h\"\n#include \"MagickCore/property.h\"\n#include \"MagickCore/quantum-private.h\"\n#include \"MagickCore/resource_.h\"\n#include \"MagickCore/string-private.h\"\n#include \"MagickCore/thread-private.h\"\n#if defined(MAGICKCORE_FFTW_DELEGATE)\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n#include <complex.h>\n#endif\n#include <fftw3.h>\n#if !defined(MAGICKCORE_HAVE_CABS)\n#define cabs(z)  (sqrt(z[0]*z[0]+z[1]*z[1]))\n#endif\n#if !defined(MAGICKCORE_HAVE_CARG)\n#define carg(z)  (atan2(cimag(z),creal(z)))\n#endif\n#if !defined(MAGICKCORE_HAVE_CIMAG)\n#define cimag(z)  (z[1])\n#endif\n#if !defined(MAGICKCORE_HAVE_CREAL)\n#define creal(z)  (z[0])\n#endif\n#endif\n\f\n/*\n  Typedef declarations.\n*/\ntypedef struct _FourierInfo\n{\n  PixelChannel\n    channel;\n\n  MagickBooleanType\n    modulus;\n\n  size_t\n    width,\n    height;\n\n  ssize_t\n    center;\n} FourierInfo;\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     C o m p l e x I m a g e s                                               %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ComplexImages() performs complex mathematics on an image sequence.\n%\n%  The format of the ComplexImages method is:\n%\n%      MagickBooleanType ComplexImages(Image *images,const ComplexOperator op,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o op: A complex operator.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\nMagickExport Image *ComplexImages(const Image *images,const ComplexOperator op,\n  ExceptionInfo *exception)\n{\n#define ComplexImageTag  \"Complex/Image\"\n\n  CacheView\n    *Ai_view,\n    *Ar_view,\n    *Bi_view,\n    *Br_view,\n    *Ci_view,\n    *Cr_view;\n\n  const char\n    *artifact;\n\n  const Image\n    *Ai_image,\n    *Ar_image,\n    *Bi_image,\n    *Br_image;\n\n  double\n    snr;\n\n  Image\n    *Ci_image,\n    *complex_images,\n    *Cr_image,\n    *image;\n\n  MagickBooleanType\n    status;\n\n  MagickOffsetType\n    progress;\n\n  size_t\n    number_channels;\n\n  ssize_t\n    y;\n\n  assert(images != (Image *) NULL);\n  assert(images->signature == MagickCoreSignature);\n  if (images->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",images->filename);\n  assert(exception != (ExceptionInfo *) NULL);\n  assert(exception->signature == MagickCoreSignature);\n  if (images->next == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ImageSequenceRequired\",\"`%s'\",images->filename);\n      return((Image *) NULL);\n    }\n  image=CloneImage(images,0,0,MagickTrue,exception);\n  if (image == (Image *) NULL)\n    return((Image *) NULL);\n  if (SetImageStorageClass(image,DirectClass,exception) == MagickFalse)\n    {\n      image=DestroyImageList(image);\n      return(image);\n    }\n  image->depth=32UL;\n  complex_images=NewImageList();\n  AppendImageToList(&complex_images,image);\n  image=CloneImage(images,0,0,MagickTrue,exception);\n  if (image == (Image *) NULL)\n    {\n      complex_images=DestroyImageList(complex_images);\n      return(complex_images);\n    }\n  AppendImageToList(&complex_images,image);\n  /*\n    Apply complex mathematics to image pixels.\n  */\n  artifact=GetImageArtifact(image,\"complex:snr\");\n  snr=0.0;\n  if (artifact != (const char *) NULL)\n    snr=StringToDouble(artifact,(char **) NULL);\n  Ar_image=images;\n  Ai_image=images->next;\n  Br_image=images;\n  Bi_image=images->next;\n  if ((images->next->next != (Image *) NULL) &&\n      (images->next->next->next != (Image *) NULL))\n    {\n      Br_image=images->next->next;\n      Bi_image=images->next->next->next;\n    }\n  Cr_image=complex_images;\n  Ci_image=complex_images->next;\n  number_channels=MagickMin(MagickMin(MagickMin(\n    Ar_image->number_channels,Ai_image->number_channels),MagickMin(\n    Br_image->number_channels,Bi_image->number_channels)),MagickMin(\n    Cr_image->number_channels,Ci_image->number_channels));\n  Ar_view=AcquireVirtualCacheView(Ar_image,exception);\n  Ai_view=AcquireVirtualCacheView(Ai_image,exception);\n  Br_view=AcquireVirtualCacheView(Br_image,exception);\n  Bi_view=AcquireVirtualCacheView(Bi_image,exception);\n  Cr_view=AcquireAuthenticCacheView(Cr_image,exception);\n  Ci_view=AcquireAuthenticCacheView(Ci_image,exception);\n  status=MagickTrue;\n  progress=0;\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp parallel for schedule(static) shared(progress,status) \\\n    magick_number_threads(Cr_image,complex_images,Cr_image->rows,1L)\n#endif\n  for (y=0; y < (ssize_t) Cr_image->rows; y++)\n  {\n    register const Quantum\n      *magick_restrict Ai,\n      *magick_restrict Ar,\n      *magick_restrict Bi,\n      *magick_restrict Br;\n\n    register Quantum\n      *magick_restrict Ci,\n      *magick_restrict Cr;\n\n    register ssize_t\n      x;\n\n    if (status == MagickFalse)\n      continue;\n    Ar=GetCacheViewVirtualPixels(Ar_view,0,y,Cr_image->columns,1,exception);\n    Ai=GetCacheViewVirtualPixels(Ai_view,0,y,Cr_image->columns,1,exception);\n    Br=GetCacheViewVirtualPixels(Br_view,0,y,Cr_image->columns,1,exception);\n    Bi=GetCacheViewVirtualPixels(Bi_view,0,y,Cr_image->columns,1,exception);\n    Cr=QueueCacheViewAuthenticPixels(Cr_view,0,y,Cr_image->columns,1,exception);\n    Ci=QueueCacheViewAuthenticPixels(Ci_view,0,y,Ci_image->columns,1,exception);\n    if ((Ar == (const Quantum *) NULL) || (Ai == (const Quantum *) NULL) || \n        (Br == (const Quantum *) NULL) || (Bi == (const Quantum *) NULL) ||\n        (Cr == (Quantum *) NULL) || (Ci == (Quantum *) NULL))\n      {\n        status=MagickFalse;\n        continue;\n      }\n    for (x=0; x < (ssize_t) Cr_image->columns; x++)\n    {\n      register ssize_t\n        i;\n\n      for (i=0; i < (ssize_t) number_channels; i++)\n      {\n        switch (op)\n        {\n          case AddComplexOperator:\n          {\n            Cr[i]=Ar[i]+Br[i];\n            Ci[i]=Ai[i]+Bi[i];\n            break;\n          }\n          case ConjugateComplexOperator:\n          default:\n          {\n            Cr[i]=Ar[i];\n            Ci[i]=(-Bi[i]);\n            break;\n          }\n          case DivideComplexOperator:\n          {\n            double\n              gamma;\n\n            gamma=PerceptibleReciprocal((double) Br[i]*Br[i]+Bi[i]*Bi[i]+snr);\n            Cr[i]=gamma*((double) Ar[i]*Br[i]+(double) Ai[i]*Bi[i]);\n            Ci[i]=gamma*((double) Ai[i]*Br[i]-(double) Ar[i]*Bi[i]);\n            break;\n          }\n          case MagnitudePhaseComplexOperator:\n          {\n            Cr[i]=sqrt((double) Ar[i]*Ar[i]+(double) Ai[i]*Ai[i]);\n            Ci[i]=atan2((double) Ai[i],(double) Ar[i])/(2.0*MagickPI)+0.5;\n            break;\n          }\n          case MultiplyComplexOperator:\n          {\n            Cr[i]=QuantumScale*((double) Ar[i]*Br[i]-(double) Ai[i]*Bi[i]);\n            Ci[i]=QuantumScale*((double) Ai[i]*Br[i]+(double) Ar[i]*Bi[i]);\n            break;\n          }\n          case RealImaginaryComplexOperator:\n          {\n            Cr[i]=Ar[i]*cos(2.0*MagickPI*(Ai[i]-0.5));\n            Ci[i]=Ar[i]*sin(2.0*MagickPI*(Ai[i]-0.5));\n            break;\n          }\n          case SubtractComplexOperator:\n          {\n            Cr[i]=Ar[i]-Br[i];\n            Ci[i]=Ai[i]-Bi[i];\n            break;\n          }\n        }\n      }\n      Ar+=GetPixelChannels(Ar_image);\n      Ai+=GetPixelChannels(Ai_image);\n      Br+=GetPixelChannels(Br_image);\n      Bi+=GetPixelChannels(Bi_image);\n      Cr+=GetPixelChannels(Cr_image);\n      Ci+=GetPixelChannels(Ci_image);\n    }\n    if (SyncCacheViewAuthenticPixels(Ci_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (SyncCacheViewAuthenticPixels(Cr_view,exception) == MagickFalse)\n      status=MagickFalse;\n    if (images->progress_monitor != (MagickProgressMonitor) NULL)\n      {\n        MagickBooleanType\n          proceed;\n\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp atomic\n#endif\n        progress++;\n        proceed=SetImageProgress(images,ComplexImageTag,progress,images->rows);\n        if (proceed == MagickFalse)\n          status=MagickFalse;\n      }\n  }\n  Cr_view=DestroyCacheView(Cr_view);\n  Ci_view=DestroyCacheView(Ci_view);\n  Br_view=DestroyCacheView(Br_view);\n  Bi_view=DestroyCacheView(Bi_view);\n  Ar_view=DestroyCacheView(Ar_view);\n  Ai_view=DestroyCacheView(Ai_view);\n  if (status == MagickFalse)\n    complex_images=DestroyImageList(complex_images);\n  return(complex_images);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     F o r w a r d F o u r i e r T r a n s f o r m I m a g e                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  ForwardFourierTransformImage() implements the discrete Fourier transform\n%  (DFT) of the image either as a magnitude / phase or real / imaginary image\n%  pair.\n%\n%  The format of the ForwadFourierTransformImage method is:\n%\n%      Image *ForwardFourierTransformImage(const Image *image,\n%        const MagickBooleanType modulus,ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o image: the image.\n%\n%    o modulus: if true, return as transform as a magnitude / phase pair\n%      otherwise a real / imaginary image pair.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(MAGICKCORE_FFTW_DELEGATE)\n\nstatic MagickBooleanType RollFourier(const size_t width,const size_t height,\n  const ssize_t x_offset,const ssize_t y_offset,double *roll_pixels)\n{\n  double\n    *source_pixels;\n\n  MemoryInfo\n    *source_info;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    u,\n    v,\n    y;\n\n  /*\n    Move zero frequency (DC, average color) from (0,0) to (width/2,height/2).\n  */\n  source_info=AcquireVirtualMemory(width,height*sizeof(*source_pixels));\n  if (source_info == (MemoryInfo *) NULL)\n    return(MagickFalse);\n  source_pixels=(double *) GetVirtualMemoryBlob(source_info);\n  i=0L;\n  for (y=0L; y < (ssize_t) height; y++)\n  {\n    if (y_offset < 0L)\n      v=((y+y_offset) < 0L) ? y+y_offset+(ssize_t) height : y+y_offset;\n    else\n      v=((y+y_offset) > ((ssize_t) height-1L)) ? y+y_offset-(ssize_t) height :\n        y+y_offset;\n    for (x=0L; x < (ssize_t) width; x++)\n    {\n      if (x_offset < 0L)\n        u=((x+x_offset) < 0L) ? x+x_offset+(ssize_t) width : x+x_offset;\n      else\n        u=((x+x_offset) > ((ssize_t) width-1L)) ? x+x_offset-(ssize_t) width :\n          x+x_offset;\n      source_pixels[v*width+u]=roll_pixels[i++];\n    }\n  }\n  (void) memcpy(roll_pixels,source_pixels,height*width*\n    sizeof(*source_pixels));\n  source_info=RelinquishVirtualMemory(source_info);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType ForwardQuadrantSwap(const size_t width,\n  const size_t height,double *source_pixels,double *forward_pixels)\n{\n  MagickBooleanType\n    status;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    center,\n    y;\n\n  /*\n    Swap quadrants.\n  */\n  center=(ssize_t) (width/2L)+1L;\n  status=RollFourier((size_t) center,height,0L,(ssize_t) height/2L,\n    source_pixels);\n  if (status == MagickFalse)\n    return(MagickFalse);\n  for (y=0L; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      forward_pixels[y*width+x+width/2L]=source_pixels[y*center+x];\n  for (y=1; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      forward_pixels[(height-y)*width+width/2L-x-1L]=\n        source_pixels[y*center+x+1L];\n  for (x=0L; x < (ssize_t) (width/2L); x++)\n    forward_pixels[width/2L-x-1L]=source_pixels[x+1L];\n  return(MagickTrue);\n}\n\nstatic void CorrectPhaseLHS(const size_t width,const size_t height,\n  double *fourier_pixels)\n{\n  register ssize_t\n    x;\n\n  ssize_t\n    y;\n\n  for (y=0L; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L); x++)\n      fourier_pixels[y*width+x]*=(-1.0);\n}\n\nstatic MagickBooleanType ForwardFourier(const FourierInfo *fourier_info,\n  Image *image,double *magnitude,double *phase,ExceptionInfo *exception)\n{\n  CacheView\n    *magnitude_view,\n    *phase_view;\n\n  double\n    *magnitude_pixels,\n    *phase_pixels;\n\n  Image\n    *magnitude_image,\n    *phase_image;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *magnitude_info,\n    *phase_info;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    x;\n\n  ssize_t\n    i,\n    y;\n\n  magnitude_image=GetFirstImageInList(image);\n  phase_image=GetNextImageInList(image);\n  if (phase_image == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ImageSequenceRequired\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  /*\n    Create \"Fourier Transform\" image from constituent arrays.\n  */\n  magnitude_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*magnitude_pixels));\n  phase_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*phase_pixels));\n  if ((magnitude_info == (MemoryInfo *) NULL) ||\n      (phase_info == (MemoryInfo *) NULL))\n    {\n      if (phase_info != (MemoryInfo *) NULL)\n        phase_info=RelinquishVirtualMemory(phase_info);\n      if (magnitude_info != (MemoryInfo *) NULL)\n        magnitude_info=RelinquishVirtualMemory(magnitude_info);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  magnitude_pixels=(double *) GetVirtualMemoryBlob(magnitude_info);\n  (void) memset(magnitude_pixels,0,fourier_info->width*\n    fourier_info->height*sizeof(*magnitude_pixels));\n  phase_pixels=(double *) GetVirtualMemoryBlob(phase_info);\n  (void) memset(phase_pixels,0,fourier_info->width*\n    fourier_info->height*sizeof(*phase_pixels));\n  status=ForwardQuadrantSwap(fourier_info->width,fourier_info->height,\n    magnitude,magnitude_pixels);\n  if (status != MagickFalse)\n    status=ForwardQuadrantSwap(fourier_info->width,fourier_info->height,phase,\n      phase_pixels);\n  CorrectPhaseLHS(fourier_info->width,fourier_info->height,phase_pixels);\n  if (fourier_info->modulus != MagickFalse)\n    {\n      i=0L;\n      for (y=0L; y < (ssize_t) fourier_info->height; y++)\n        for (x=0L; x < (ssize_t) fourier_info->width; x++)\n        {\n          phase_pixels[i]/=(2.0*MagickPI);\n          phase_pixels[i]+=0.5;\n          i++;\n        }\n    }\n  magnitude_view=AcquireAuthenticCacheView(magnitude_image,exception);\n  i=0L;\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    q=GetCacheViewAuthenticPixels(magnitude_view,0L,y,fourier_info->width,1UL,\n      exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          SetPixelRed(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          SetPixelGreen(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          SetPixelBlue(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          SetPixelBlack(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          SetPixelAlpha(magnitude_image,ClampToQuantum(QuantumRange*\n            magnitude_pixels[i]),q);\n          break;\n        }\n      }\n      i++;\n      q+=GetPixelChannels(magnitude_image);\n    }\n    status=SyncCacheViewAuthenticPixels(magnitude_view,exception);\n    if (status == MagickFalse)\n      break;\n  }\n  magnitude_view=DestroyCacheView(magnitude_view);\n  i=0L;\n  phase_view=AcquireAuthenticCacheView(phase_image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    q=GetCacheViewAuthenticPixels(phase_view,0L,y,fourier_info->width,1UL,\n      exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          SetPixelRed(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          SetPixelGreen(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          SetPixelBlue(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          SetPixelBlack(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          SetPixelAlpha(phase_image,ClampToQuantum(QuantumRange*\n            phase_pixels[i]),q);\n          break;\n        }\n      }\n      i++;\n      q+=GetPixelChannels(phase_image);\n    }\n    status=SyncCacheViewAuthenticPixels(phase_view,exception);\n    if (status == MagickFalse)\n      break;\n   }\n  phase_view=DestroyCacheView(phase_view);\n  phase_info=RelinquishVirtualMemory(phase_info);\n  magnitude_info=RelinquishVirtualMemory(magnitude_info);\n  return(status);\n}\n\nstatic MagickBooleanType ForwardFourierTransform(FourierInfo *fourier_info,\n  const Image *image,double *magnitude_pixels,double *phase_pixels,\n  ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  const char\n    *value;\n\n  double\n    *source_pixels;\n\n  fftw_complex\n    *forward_pixels;\n\n  fftw_plan\n    fftw_r2c_plan;\n\n  MemoryInfo\n    *forward_info,\n    *source_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  /*\n    Generate the forward Fourier transform.\n  */\n  source_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*source_pixels));\n  if (source_info == (MemoryInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  source_pixels=(double *) GetVirtualMemoryBlob(source_info);\n  memset(source_pixels,0,fourier_info->width*fourier_info->height*\n    sizeof(*source_pixels));\n  i=0L;\n  image_view=AcquireVirtualCacheView(image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    p=GetCacheViewVirtualPixels(image_view,0L,y,fourier_info->width,1UL,\n      exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          source_pixels[i]=QuantumScale*GetPixelRed(image,p);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          source_pixels[i]=QuantumScale*GetPixelGreen(image,p);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          source_pixels[i]=QuantumScale*GetPixelBlue(image,p);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          source_pixels[i]=QuantumScale*GetPixelBlack(image,p);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          source_pixels[i]=QuantumScale*GetPixelAlpha(image,p);\n          break;\n        }\n      }\n      i++;\n      p+=GetPixelChannels(image);\n    }\n  }\n  image_view=DestroyCacheView(image_view);\n  forward_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    (fourier_info->height/2+1)*sizeof(*forward_pixels));\n  if (forward_info == (MemoryInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      source_info=(MemoryInfo *) RelinquishVirtualMemory(source_info);\n      return(MagickFalse);\n    }\n  forward_pixels=(fftw_complex *) GetVirtualMemoryBlob(forward_info);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp critical (MagickCore_ForwardFourierTransform)\n#endif\n  fftw_r2c_plan=fftw_plan_dft_r2c_2d(fourier_info->width,fourier_info->height,\n    source_pixels,forward_pixels,FFTW_ESTIMATE);\n  fftw_execute_dft_r2c(fftw_r2c_plan,source_pixels,forward_pixels);\n  fftw_destroy_plan(fftw_r2c_plan);\n  source_info=(MemoryInfo *) RelinquishVirtualMemory(source_info);\n  value=GetImageArtifact(image,\"fourier:normalize\");\n  if ((value == (const char *) NULL) || (LocaleCompare(value,\"forward\") == 0))\n    {\n      double\n        gamma;\n\n      /*\n        Normalize fourier transform.\n      */\n      i=0L;\n      gamma=PerceptibleReciprocal((double) fourier_info->width*\n        fourier_info->height);\n      for (y=0L; y < (ssize_t) fourier_info->height; y++)\n        for (x=0L; x < (ssize_t) fourier_info->center; x++)\n        {\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n          forward_pixels[i]*=gamma;\n#else\n          forward_pixels[i][0]*=gamma;\n          forward_pixels[i][1]*=gamma;\n#endif\n          i++;\n        }\n    }\n  /*\n    Generate magnitude and phase (or real and imaginary).\n  */\n  i=0L;\n  if (fourier_info->modulus != MagickFalse)\n    for (y=0L; y < (ssize_t) fourier_info->height; y++)\n      for (x=0L; x < (ssize_t) fourier_info->center; x++)\n      {\n        magnitude_pixels[i]=cabs(forward_pixels[i]);\n        phase_pixels[i]=carg(forward_pixels[i]);\n        i++;\n      }\n  else\n    for (y=0L; y < (ssize_t) fourier_info->height; y++)\n      for (x=0L; x < (ssize_t) fourier_info->center; x++)\n      {\n        magnitude_pixels[i]=creal(forward_pixels[i]);\n        phase_pixels[i]=cimag(forward_pixels[i]);\n        i++;\n      }\n  forward_info=(MemoryInfo *) RelinquishVirtualMemory(forward_info);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType ForwardFourierTransformChannel(const Image *image,\n  const PixelChannel channel,const MagickBooleanType modulus,\n  Image *fourier_image,ExceptionInfo *exception)\n{\n  double\n    *magnitude_pixels,\n    *phase_pixels;\n\n  FourierInfo\n    fourier_info;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *magnitude_info,\n    *phase_info;\n\n  fourier_info.width=image->columns;\n  fourier_info.height=image->rows;\n  if ((image->columns != image->rows) || ((image->columns % 2) != 0) ||\n      ((image->rows % 2) != 0))\n    {\n      size_t extent=image->columns < image->rows ? image->rows : image->columns;\n      fourier_info.width=(extent & 0x01) == 1 ? extent+1UL : extent;\n    }\n  fourier_info.height=fourier_info.width;\n  fourier_info.center=(ssize_t) (fourier_info.width/2L)+1L;\n  fourier_info.channel=channel;\n  fourier_info.modulus=modulus;\n  magnitude_info=AcquireVirtualMemory((size_t) fourier_info.width,\n    (fourier_info.height/2+1)*sizeof(*magnitude_pixels));\n  phase_info=AcquireVirtualMemory((size_t) fourier_info.width,\n    (fourier_info.height/2+1)*sizeof(*phase_pixels));\n  if ((magnitude_info == (MemoryInfo *) NULL) ||\n      (phase_info == (MemoryInfo *) NULL))\n    {\n      if (phase_info != (MemoryInfo *) NULL)\n        phase_info=RelinquishVirtualMemory(phase_info);\n      if (magnitude_info == (MemoryInfo *) NULL)\n        magnitude_info=RelinquishVirtualMemory(magnitude_info);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  magnitude_pixels=(double *) GetVirtualMemoryBlob(magnitude_info);\n  phase_pixels=(double *) GetVirtualMemoryBlob(phase_info);\n  status=ForwardFourierTransform(&fourier_info,image,magnitude_pixels,\n    phase_pixels,exception);\n  if (status != MagickFalse)\n    status=ForwardFourier(&fourier_info,fourier_image,magnitude_pixels,\n      phase_pixels,exception);\n  phase_info=RelinquishVirtualMemory(phase_info);\n  magnitude_info=RelinquishVirtualMemory(magnitude_info);\n  return(status);\n}\n#endif\n\nMagickExport Image *ForwardFourierTransformImage(const Image *image,\n  const MagickBooleanType modulus,ExceptionInfo *exception)\n{\n  Image\n    *fourier_image;\n\n  fourier_image=NewImageList();\n#if !defined(MAGICKCORE_FFTW_DELEGATE)\n  (void) modulus;\n  (void) ThrowMagickException(exception,GetMagickModule(),\n    MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (FFTW)\",\n    image->filename);\n#else\n  {\n    Image\n      *magnitude_image;\n\n    size_t\n      height,\n      width;\n\n    width=image->columns;\n    height=image->rows;\n    if ((image->columns != image->rows) || ((image->columns % 2) != 0) ||\n        ((image->rows % 2) != 0))\n      {\n        size_t extent=image->columns < image->rows ? image->rows :\n          image->columns;\n        width=(extent & 0x01) == 1 ? extent+1UL : extent;\n      }\n    height=width;\n    magnitude_image=CloneImage(image,width,height,MagickTrue,exception);\n    if (magnitude_image != (Image *) NULL)\n      {\n        Image\n          *phase_image;\n\n        magnitude_image->storage_class=DirectClass;\n        magnitude_image->depth=32UL;\n        phase_image=CloneImage(image,width,height,MagickTrue,exception);\n        if (phase_image == (Image *) NULL)\n          magnitude_image=DestroyImage(magnitude_image);\n        else\n          {\n            MagickBooleanType\n              is_gray,\n              status;\n\n            phase_image->storage_class=DirectClass;\n            phase_image->depth=32UL;\n            AppendImageToList(&fourier_image,magnitude_image);\n            AppendImageToList(&fourier_image,phase_image);\n            status=MagickTrue;\n            is_gray=IsImageGray(image);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n            #pragma omp parallel sections\n#endif\n            {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                if (is_gray != MagickFalse)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    GrayPixelChannel,modulus,fourier_image,exception);\n                else\n                  thread_status=ForwardFourierTransformChannel(image,\n                    RedPixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                thread_status=MagickTrue;\n                if (is_gray == MagickFalse)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    GreenPixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                thread_status=MagickTrue;\n                if (is_gray == MagickFalse)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    BluePixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                thread_status=MagickTrue;\n                if (image->colorspace == CMYKColorspace)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    BlackPixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n              #pragma omp section\n#endif\n              {\n                MagickBooleanType\n                  thread_status;\n\n                thread_status=MagickTrue;\n                if (image->alpha_trait != UndefinedPixelTrait)\n                  thread_status=ForwardFourierTransformChannel(image,\n                    AlphaPixelChannel,modulus,fourier_image,exception);\n                if (thread_status == MagickFalse)\n                  status=thread_status;\n              }\n            }\n            if (status == MagickFalse)\n              fourier_image=DestroyImageList(fourier_image);\n            fftw_cleanup();\n          }\n      }\n  }\n#endif\n  return(fourier_image);\n}\n\f\n/*\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%     I n v e r s e F o u r i e r T r a n s f o r m I m a g e                 %\n%                                                                             %\n%                                                                             %\n%                                                                             %\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  InverseFourierTransformImage() implements the inverse discrete Fourier\n%  transform (DFT) of the image either as a magnitude / phase or real /\n%  imaginary image pair.\n%\n%  The format of the InverseFourierTransformImage method is:\n%\n%      Image *InverseFourierTransformImage(const Image *magnitude_image,\n%        const Image *phase_image,const MagickBooleanType modulus,\n%        ExceptionInfo *exception)\n%\n%  A description of each parameter follows:\n%\n%    o magnitude_image: the magnitude or real image.\n%\n%    o phase_image: the phase or imaginary image.\n%\n%    o modulus: if true, return transform as a magnitude / phase pair\n%      otherwise a real / imaginary image pair.\n%\n%    o exception: return any errors or warnings in this structure.\n%\n*/\n\n#if defined(MAGICKCORE_FFTW_DELEGATE)\nstatic MagickBooleanType InverseQuadrantSwap(const size_t width,\n  const size_t height,const double *source,double *destination)\n{\n  register ssize_t\n    x;\n\n  ssize_t\n    center,\n    y;\n\n  /*\n    Swap quadrants.\n  */\n  center=(ssize_t) (width/2L)+1L;\n  for (y=1L; y < (ssize_t) height; y++)\n    for (x=0L; x < (ssize_t) (width/2L+1L); x++)\n      destination[(height-y)*center-x+width/2L]=source[y*width+x];\n  for (y=0L; y < (ssize_t) height; y++)\n    destination[y*center]=source[y*width+width/2L];\n  for (x=0L; x < center; x++)\n    destination[x]=source[center-x-1L];\n  return(RollFourier(center,height,0L,(ssize_t) height/-2L,destination));\n}\n\nstatic MagickBooleanType InverseFourier(FourierInfo *fourier_info,\n  const Image *magnitude_image,const Image *phase_image,\n  fftw_complex *fourier_pixels,ExceptionInfo *exception)\n{\n  CacheView\n    *magnitude_view,\n    *phase_view;\n\n  double\n    *inverse_pixels,\n    *magnitude_pixels,\n    *phase_pixels;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *inverse_info,\n    *magnitude_info,\n    *phase_info;\n\n  register const Quantum\n    *p;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  /*\n    Inverse fourier - read image and break down into a double array.\n  */\n  magnitude_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*magnitude_pixels));\n  phase_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*phase_pixels));\n  inverse_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    (fourier_info->height/2+1)*sizeof(*inverse_pixels));\n  if ((magnitude_info == (MemoryInfo *) NULL) ||\n      (phase_info == (MemoryInfo *) NULL) ||\n      (inverse_info == (MemoryInfo *) NULL))\n    {\n      if (magnitude_info != (MemoryInfo *) NULL)\n        magnitude_info=RelinquishVirtualMemory(magnitude_info);\n      if (phase_info != (MemoryInfo *) NULL)\n        phase_info=RelinquishVirtualMemory(phase_info);\n      if (inverse_info != (MemoryInfo *) NULL)\n        inverse_info=RelinquishVirtualMemory(inverse_info);\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        magnitude_image->filename);\n      return(MagickFalse);\n    }\n  magnitude_pixels=(double *) GetVirtualMemoryBlob(magnitude_info);\n  phase_pixels=(double *) GetVirtualMemoryBlob(phase_info);\n  inverse_pixels=(double *) GetVirtualMemoryBlob(inverse_info);\n  i=0L;\n  magnitude_view=AcquireVirtualCacheView(magnitude_image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    p=GetCacheViewVirtualPixels(magnitude_view,0L,y,fourier_info->width,1UL,\n      exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelRed(magnitude_image,p);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelGreen(magnitude_image,p);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelBlue(magnitude_image,p);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelBlack(magnitude_image,p);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          magnitude_pixels[i]=QuantumScale*GetPixelAlpha(magnitude_image,p);\n          break;\n        }\n      }\n      i++;\n      p+=GetPixelChannels(magnitude_image);\n    }\n  }\n  magnitude_view=DestroyCacheView(magnitude_view);\n  status=InverseQuadrantSwap(fourier_info->width,fourier_info->height,\n    magnitude_pixels,inverse_pixels);\n  (void) memcpy(magnitude_pixels,inverse_pixels,fourier_info->height*\n    fourier_info->center*sizeof(*magnitude_pixels));\n  i=0L;\n  phase_view=AcquireVirtualCacheView(phase_image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    p=GetCacheViewVirtualPixels(phase_view,0,y,fourier_info->width,1,\n      exception);\n    if (p == (const Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      switch (fourier_info->channel)\n      {\n        case RedPixelChannel:\n        default:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelRed(phase_image,p);\n          break;\n        }\n        case GreenPixelChannel:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelGreen(phase_image,p);\n          break;\n        }\n        case BluePixelChannel:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelBlue(phase_image,p);\n          break;\n        }\n        case BlackPixelChannel:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelBlack(phase_image,p);\n          break;\n        }\n        case AlphaPixelChannel:\n        {\n          phase_pixels[i]=QuantumScale*GetPixelAlpha(phase_image,p);\n          break;\n        }\n      }\n      i++;\n      p+=GetPixelChannels(phase_image);\n    }\n  }\n  if (fourier_info->modulus != MagickFalse)\n    {\n      i=0L;\n      for (y=0L; y < (ssize_t) fourier_info->height; y++)\n        for (x=0L; x < (ssize_t) fourier_info->width; x++)\n        {\n          phase_pixels[i]-=0.5;\n          phase_pixels[i]*=(2.0*MagickPI);\n          i++;\n        }\n    }\n  phase_view=DestroyCacheView(phase_view);\n  CorrectPhaseLHS(fourier_info->width,fourier_info->height,phase_pixels);\n  if (status != MagickFalse)\n    status=InverseQuadrantSwap(fourier_info->width,fourier_info->height,\n      phase_pixels,inverse_pixels);\n  (void) memcpy(phase_pixels,inverse_pixels,fourier_info->height*\n    fourier_info->center*sizeof(*phase_pixels));\n  inverse_info=RelinquishVirtualMemory(inverse_info);\n  /*\n    Merge two sets.\n  */\n  i=0L;\n  if (fourier_info->modulus != MagickFalse)\n    for (y=0L; y < (ssize_t) fourier_info->height; y++)\n       for (x=0L; x < (ssize_t) fourier_info->center; x++)\n       {\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n         fourier_pixels[i]=magnitude_pixels[i]*cos(phase_pixels[i])+I*\n           magnitude_pixels[i]*sin(phase_pixels[i]);\n#else\n         fourier_pixels[i][0]=magnitude_pixels[i]*cos(phase_pixels[i]);\n         fourier_pixels[i][1]=magnitude_pixels[i]*sin(phase_pixels[i]);\n#endif\n         i++;\n      }\n  else\n    for (y=0L; y < (ssize_t) fourier_info->height; y++)\n      for (x=0L; x < (ssize_t) fourier_info->center; x++)\n      {\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n        fourier_pixels[i]=magnitude_pixels[i]+I*phase_pixels[i];\n#else\n        fourier_pixels[i][0]=magnitude_pixels[i];\n        fourier_pixels[i][1]=phase_pixels[i];\n#endif\n        i++;\n      }\n  magnitude_info=RelinquishVirtualMemory(magnitude_info);\n  phase_info=RelinquishVirtualMemory(phase_info);\n  return(status);\n}\n\nstatic MagickBooleanType InverseFourierTransform(FourierInfo *fourier_info,\n  fftw_complex *fourier_pixels,Image *image,ExceptionInfo *exception)\n{\n  CacheView\n    *image_view;\n\n  const char\n    *value;\n\n  double\n    *source_pixels;\n\n  fftw_plan\n    fftw_c2r_plan;\n\n  MemoryInfo\n    *source_info;\n\n  register Quantum\n    *q;\n\n  register ssize_t\n    i,\n    x;\n\n  ssize_t\n    y;\n\n  source_info=AcquireVirtualMemory((size_t) fourier_info->width,\n    fourier_info->height*sizeof(*source_pixels));\n  if (source_info == (MemoryInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",image->filename);\n      return(MagickFalse);\n    }\n  source_pixels=(double *) GetVirtualMemoryBlob(source_info);\n  value=GetImageArtifact(image,\"fourier:normalize\");\n  if (LocaleCompare(value,\"inverse\") == 0)\n    {\n      double\n        gamma;\n\n      /*\n        Normalize inverse transform.\n      */\n      i=0L;\n      gamma=PerceptibleReciprocal((double) fourier_info->width*\n        fourier_info->height);\n      for (y=0L; y < (ssize_t) fourier_info->height; y++)\n        for (x=0L; x < (ssize_t) fourier_info->center; x++)\n        {\n#if defined(MAGICKCORE_HAVE_COMPLEX_H)\n          fourier_pixels[i]*=gamma;\n#else\n          fourier_pixels[i][0]*=gamma;\n          fourier_pixels[i][1]*=gamma;\n#endif\n          i++;\n        }\n    }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n  #pragma omp critical (MagickCore_InverseFourierTransform)\n#endif\n  fftw_c2r_plan=fftw_plan_dft_c2r_2d(fourier_info->width,fourier_info->height,\n    fourier_pixels,source_pixels,FFTW_ESTIMATE);\n  fftw_execute_dft_c2r(fftw_c2r_plan,fourier_pixels,source_pixels);\n  fftw_destroy_plan(fftw_c2r_plan);\n  i=0L;\n  image_view=AcquireAuthenticCacheView(image,exception);\n  for (y=0L; y < (ssize_t) fourier_info->height; y++)\n  {\n    if (y >= (ssize_t) image->rows)\n      break;\n    q=GetCacheViewAuthenticPixels(image_view,0L,y,fourier_info->width >\n      image->columns ? image->columns : fourier_info->width,1UL,exception);\n    if (q == (Quantum *) NULL)\n      break;\n    for (x=0L; x < (ssize_t) fourier_info->width; x++)\n    {\n      if (x < (ssize_t) image->columns)\n        switch (fourier_info->channel)\n        {\n          case RedPixelChannel:\n          default:\n          {\n            SetPixelRed(image,ClampToQuantum(QuantumRange*source_pixels[i]),q);\n            break;\n          }\n          case GreenPixelChannel:\n          {\n            SetPixelGreen(image,ClampToQuantum(QuantumRange*source_pixels[i]),\n              q);\n            break;\n          }\n          case BluePixelChannel:\n          {\n            SetPixelBlue(image,ClampToQuantum(QuantumRange*source_pixels[i]),\n              q);\n            break;\n          }\n          case BlackPixelChannel:\n          {\n            SetPixelBlack(image,ClampToQuantum(QuantumRange*source_pixels[i]),\n              q);\n            break;\n          }\n          case AlphaPixelChannel:\n          {\n            SetPixelAlpha(image,ClampToQuantum(QuantumRange*source_pixels[i]),\n              q);\n            break;\n          }\n        }\n      i++;\n      q+=GetPixelChannels(image);\n    }\n    if (SyncCacheViewAuthenticPixels(image_view,exception) == MagickFalse)\n      break;\n  }\n  image_view=DestroyCacheView(image_view);\n  source_info=RelinquishVirtualMemory(source_info);\n  return(MagickTrue);\n}\n\nstatic MagickBooleanType InverseFourierTransformChannel(\n  const Image *magnitude_image,const Image *phase_image,\n  const PixelChannel channel,const MagickBooleanType modulus,\n  Image *fourier_image,ExceptionInfo *exception)\n{\n  fftw_complex\n    *inverse_pixels;\n\n  FourierInfo\n    fourier_info;\n\n  MagickBooleanType\n    status;\n\n  MemoryInfo\n    *inverse_info;\n\n  fourier_info.width=magnitude_image->columns;\n  fourier_info.height=magnitude_image->rows;\n  if ((magnitude_image->columns != magnitude_image->rows) ||\n      ((magnitude_image->columns % 2) != 0) ||\n      ((magnitude_image->rows % 2) != 0))\n    {\n      size_t extent=magnitude_image->columns < magnitude_image->rows ?\n        magnitude_image->rows : magnitude_image->columns;\n      fourier_info.width=(extent & 0x01) == 1 ? extent+1UL : extent;\n    }\n  fourier_info.height=fourier_info.width;\n  fourier_info.center=(ssize_t) (fourier_info.width/2L)+1L;\n  fourier_info.channel=channel;\n  fourier_info.modulus=modulus;\n  inverse_info=AcquireVirtualMemory((size_t) fourier_info.width,\n    (fourier_info.height/2+1)*sizeof(*inverse_pixels));\n  if (inverse_info == (MemoryInfo *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),\n        ResourceLimitError,\"MemoryAllocationFailed\",\"`%s'\",\n        magnitude_image->filename);\n      return(MagickFalse);\n    }\n  inverse_pixels=(fftw_complex *) GetVirtualMemoryBlob(inverse_info);\n  status=InverseFourier(&fourier_info,magnitude_image,phase_image,\n    inverse_pixels,exception);\n  if (status != MagickFalse)\n    status=InverseFourierTransform(&fourier_info,inverse_pixels,fourier_image,\n      exception);\n  inverse_info=RelinquishVirtualMemory(inverse_info);\n  return(status);\n}\n#endif\n\nMagickExport Image *InverseFourierTransformImage(const Image *magnitude_image,\n  const Image *phase_image,const MagickBooleanType modulus,\n  ExceptionInfo *exception)\n{\n  Image\n    *fourier_image;\n\n  assert(magnitude_image != (Image *) NULL);\n  assert(magnitude_image->signature == MagickCoreSignature);\n  if (magnitude_image->debug != MagickFalse)\n    (void) LogMagickEvent(TraceEvent,GetMagickModule(),\"%s\",\n      magnitude_image->filename);\n  if (phase_image == (Image *) NULL)\n    {\n      (void) ThrowMagickException(exception,GetMagickModule(),ImageError,\n        \"ImageSequenceRequired\",\"`%s'\",magnitude_image->filename);\n      return((Image *) NULL);\n    }\n#if !defined(MAGICKCORE_FFTW_DELEGATE)\n  fourier_image=(Image *) NULL;\n  (void) modulus;\n  (void) ThrowMagickException(exception,GetMagickModule(),\n    MissingDelegateWarning,\"DelegateLibrarySupportNotBuiltIn\",\"`%s' (FFTW)\",\n    magnitude_image->filename);\n#else\n  {\n    fourier_image=CloneImage(magnitude_image,magnitude_image->columns,\n      magnitude_image->rows,MagickTrue,exception);\n    if (fourier_image != (Image *) NULL)\n      {\n        MagickBooleanType\n          is_gray,\n          status;\n\n        status=MagickTrue;\n        is_gray=IsImageGray(magnitude_image);\n        if (is_gray != MagickFalse)\n          is_gray=IsImageGray(phase_image);\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n        #pragma omp parallel sections\n#endif\n        {\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            if (is_gray != MagickFalse)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,GrayPixelChannel,modulus,fourier_image,exception);\n            else\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,RedPixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            thread_status=MagickTrue;\n            if (is_gray == MagickFalse)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,GreenPixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            thread_status=MagickTrue;\n            if (is_gray == MagickFalse)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,BluePixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            thread_status=MagickTrue;\n            if (magnitude_image->colorspace == CMYKColorspace)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,BlackPixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n#if defined(MAGICKCORE_OPENMP_SUPPORT)\n          #pragma omp section\n#endif\n          {\n            MagickBooleanType\n              thread_status;\n\n            thread_status=MagickTrue;\n            if (magnitude_image->alpha_trait != UndefinedPixelTrait)\n              thread_status=InverseFourierTransformChannel(magnitude_image,\n                phase_image,AlphaPixelChannel,modulus,fourier_image,exception);\n            if (thread_status == MagickFalse)\n              status=thread_status;\n          }\n        }\n        if (status == MagickFalse)\n          fourier_image=DestroyImage(fourier_image);\n      }\n    fftw_cleanup();\n  }\n#endif\n  return(fourier_image);\n}\n"], "filenames": ["MagickCore/fourier.c"], "buggy_code_start_loc": [169], "buggy_code_end_loc": [270], "fixing_code_start_loc": [170], "fixing_code_end_loc": [277], "type": "CWE-125", "message": "ImageMagick 7.0.8-50 Q16 has a heap-based buffer over-read in MagickCore/fourier.c in ComplexImages.", "other": {"cve": {"id": "CVE-2019-13302", "sourceIdentifier": "cve@mitre.org", "published": "2019-07-05T01:15:10.373", "lastModified": "2023-03-02T15:57:24.170", "vulnStatus": "Analyzed", "descriptions": [{"lang": "en", "value": "ImageMagick 7.0.8-50 Q16 has a heap-based buffer over-read in MagickCore/fourier.c in ComplexImages."}, {"lang": "es", "value": "ImageMagick versi\u00f3n 7.0.8-50 Q16 tiene una sobrelectura de b\u00fafer basada en memoria din\u00e1mica (heap) en lMagickCore/fourier.c en ComplexImages."}], "metrics": {"cvssMetricV31": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "3.1", "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:U/C:H/I:H/A:H", "attackVector": "NETWORK", "attackComplexity": "LOW", "privilegesRequired": "NONE", "userInteraction": "REQUIRED", "scope": "UNCHANGED", "confidentialityImpact": "HIGH", "integrityImpact": "HIGH", "availabilityImpact": "HIGH", "baseScore": 8.8, "baseSeverity": "HIGH"}, "exploitabilityScore": 2.8, "impactScore": 5.9}], "cvssMetricV2": [{"source": "nvd@nist.gov", "type": "Primary", "cvssData": {"version": "2.0", "vectorString": "AV:N/AC:M/Au:N/C:P/I:P/A:P", "accessVector": "NETWORK", "accessComplexity": "MEDIUM", "authentication": "NONE", "confidentialityImpact": "PARTIAL", "integrityImpact": "PARTIAL", "availabilityImpact": "PARTIAL", "baseScore": 6.8}, "baseSeverity": "MEDIUM", "exploitabilityScore": 8.6, "impactScore": 6.4, "acInsufInfo": false, "obtainAllPrivilege": false, "obtainUserPrivilege": false, "obtainOtherPrivilege": false, "userInteractionRequired": true}]}, "weaknesses": [{"source": "nvd@nist.gov", "type": "Primary", "description": [{"lang": "en", "value": "CWE-125"}]}], "configurations": [{"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:a:imagemagick:imagemagick:7.0.8-50:q16:*:*:*:*:*:*", "matchCriteriaId": "25CCEA99-8329-46C6-9625-4FE15F24CF69"}]}]}, {"nodes": [{"operator": "OR", "negate": false, "cpeMatch": [{"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.0:*:*:*:*:*:*:*", "matchCriteriaId": "F1E78106-58E6-4D59-990F-75DA575BFAD9"}, {"vulnerable": true, "criteria": "cpe:2.3:o:opensuse:leap:15.1:*:*:*:*:*:*:*", "matchCriteriaId": "B620311B-34A3-48A6-82DF-6F078D7A4493"}]}]}], "references": [{"url": "http://lists.opensuse.org/opensuse-security-announce/2019-08/msg00069.html", "source": "cve@mitre.org", "tags": ["Mailing List", "Third Party Advisory"]}, {"url": "https://github.com/ImageMagick/ImageMagick/commit/d5089971bd792311aaab5cb73460326d7ef7f32d", "source": "cve@mitre.org", "tags": ["Patch"]}, {"url": "https://github.com/ImageMagick/ImageMagick/issues/1597", "source": "cve@mitre.org", "tags": ["Exploit", "Issue Tracking", "Patch", "Third Party Advisory"]}]}, "github_commit_url": "https://github.com/ImageMagick/ImageMagick/commit/d5089971bd792311aaab5cb73460326d7ef7f32d"}}